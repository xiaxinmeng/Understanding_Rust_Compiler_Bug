{"sha": "dee5ea7a0bfe95367820a443ef4a7c813e598b55", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGVlNWVhN2EwYmZlOTUzNjc4MjBhNDQzZWY0YTdjODEzZTU5OGI1NQ==", "commit": {"author": {"name": "Kostya Serebryany", "email": "kcc@google.com", "date": "2014-05-22T07:09:21Z"}, "committer": {"name": "Kostya Serebryany", "email": "kcc@gcc.gnu.org", "date": "2014-05-22T07:09:21Z"}, "message": "libsanitizer merge from upstream r209283\n\nFrom-SVN: r210743", "tree": {"sha": "f90afdf42b3ae78508a5c6422f458a5bb0216aa2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f90afdf42b3ae78508a5c6422f458a5bb0216aa2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dee5ea7a0bfe95367820a443ef4a7c813e598b55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dee5ea7a0bfe95367820a443ef4a7c813e598b55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dee5ea7a0bfe95367820a443ef4a7c813e598b55", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dee5ea7a0bfe95367820a443ef4a7c813e598b55/comments", "author": {"login": "kcc", "id": 1789297, "node_id": "MDQ6VXNlcjE3ODkyOTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1789297?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kcc", "html_url": "https://github.com/kcc", "followers_url": "https://api.github.com/users/kcc/followers", "following_url": "https://api.github.com/users/kcc/following{/other_user}", "gists_url": "https://api.github.com/users/kcc/gists{/gist_id}", "starred_url": "https://api.github.com/users/kcc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kcc/subscriptions", "organizations_url": "https://api.github.com/users/kcc/orgs", "repos_url": "https://api.github.com/users/kcc/repos", "events_url": "https://api.github.com/users/kcc/events{/privacy}", "received_events_url": "https://api.github.com/users/kcc/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b95591361e32a755231d99c348f8a43e2aed0187", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b95591361e32a755231d99c348f8a43e2aed0187", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b95591361e32a755231d99c348f8a43e2aed0187"}], "stats": {"total": 17627, "additions": 12526, "deletions": 5101}, "files": [{"sha": "edbb9c6dd7a0563e9e3e1cfe80574c09e2648247", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -1,3 +1,9 @@\n+2014-05-22  Kostya Serebryany  <kcc@google.com>\n+\n+\t* c-c++-common/tsan/mutexset1.c: Update the test to match\n+\tupstream r209283.\n+\t* g++.dg/asan/symbolize-callback-1.C: Delete the deprecated test.\n+\n 2014-05-21  Marek Polacek  <polacek@redhat.com>\n \n \tPR sanitizer/61272"}, {"sha": "d27f7c817cbd4225f52a35b8a4da1d8b349b7cd4", "filename": "gcc/testsuite/c-c++-common/tsan/mutexset1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftsan%2Fmutexset1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftsan%2Fmutexset1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftsan%2Fmutexset1.c?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -35,6 +35,6 @@ int main() {\n /* { dg-output \"WARNING: ThreadSanitizer: data race.*(\\n|\\r\\n|\\r)\" } */\n /* { dg-output \"  Read of size 4 at 0x\\[0-9a-f\\]+ by thread T1 \\\\(mutexes: write M\\[0-9\\]\\\\):.*\" } */\n /* { dg-output \"  Previous write of size 4 at 0x\\[0-9a-f\\]+ by thread T2:.*\" } */\n-/* { dg-output \"  Mutex M\\[0-9\\] created at:.*\" } */\n+/* { dg-output \"  Mutex M\\[0-9\\] \\\\(0x.*\\\\) created at:.*\" } */\n /* { dg-output \"    #0 pthread_mutex_init.*\" } */\n /* { dg-output \"    #1 main (.*mutexset1.c|\\\\?{2}):\\[0-9]+.*\" } */"}, {"sha": "9978958f9e26ec2a42da046200e02da18ef047c3", "filename": "gcc/testsuite/g++.dg/asan/symbolize-callback-1.C", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b95591361e32a755231d99c348f8a43e2aed0187/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fsymbolize-callback-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b95591361e32a755231d99c348f8a43e2aed0187/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fsymbolize-callback-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fsymbolize-callback-1.C?ref=b95591361e32a755231d99c348f8a43e2aed0187", "patch": "@@ -1,21 +0,0 @@\n-// { dg-do run }\n-// { dg-skip-if \"\" { *-*-* }  { \"*\" } { \"-O2\" } }\n-// { dg-options \"-fno-builtin-malloc -fno-builtin-free\" }\n-// { dg-shouldfail \"asan\" }\n-\n-#include <stdio.h>\n-#include <stdlib.h>\n-\n-extern \"C\"\n-bool __asan_symbolize(const void *, char *out_buffer, int out_size) {\n-  snprintf(out_buffer, out_size, \"MySymbolizer\");\n-  return true;\n-}\n-\n-int main() {\n-  char *x = (char*)malloc(10);\n-  free(x);\n-  return x[5];\n-}\n-\n-// { dg-output \"MySymbolizer\" }"}, {"sha": "fe06edc882f187be5b4cf3515b9e7adecf3bd802", "filename": "libsanitizer/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FChangeLog?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -1,3 +1,13 @@\n+2014-05-22  Kostya Serebryany  <kcc@google.com>\n+\n+\t* All source files: Merge from upstream r209283.\n+\t* asan/Makefile.am (asan_files): Added new files.\n+\t* asan/Makefile.in: Regenerate.\n+\t* tsan/Makefile.am (tsan_files): Added new files.\n+\t* tsan/Makefile.in: Regenerate.\n+\t* sanitizer_common/Makefile.am (sanitizer_common_files): Added new files.\n+\t* sanitizer_common/Makefile.in: Regenerate.\n+\n 2014-05-14  Yury Gribov  <y.gribov@samsung.com>\n \n \tPR sanitizer/61100"}, {"sha": "84e88e10b77e551495c2ead247d369d68077860c", "filename": "libsanitizer/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FMERGE?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -1,4 +1,4 @@\n-196489\n+209283\n \n The first line of this file holds the svn revision number of the\n last merge done from the master library sources."}, {"sha": "fdc2b4513d90865f52621ec6488d2bc4f224ffc9", "filename": "libsanitizer/asan/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2FMakefile.am?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -15,6 +15,7 @@ toolexeclib_LTLIBRARIES = libasan.la\n nodist_toolexeclib_HEADERS = libasan_preinit.o\n \n asan_files = \\\n+\tasan_activation.cc \\\n \tasan_allocator2.cc \\\n \tasan_dll_thunk.cc \\\n \tasan_fake_stack.cc \\"}, {"sha": "cae6493fc9f9dff811b24a0763a637d5aea19da7", "filename": "libsanitizer/asan/Makefile.in", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2FMakefile.in?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -88,12 +88,13 @@ libasan_la_DEPENDENCIES =  \\\n \t$(top_builddir)/sanitizer_common/libsanitizer_common.la \\\n \t$(top_builddir)/lsan/libsanitizer_lsan.la $(am__append_2) \\\n \t$(am__append_3) $(am__DEPENDENCIES_1)\n-am__objects_1 = asan_allocator2.lo asan_dll_thunk.lo \\\n-\tasan_fake_stack.lo asan_globals.lo asan_interceptors.lo \\\n-\tasan_linux.lo asan_mac.lo asan_malloc_linux.lo \\\n-\tasan_malloc_mac.lo asan_malloc_win.lo asan_new_delete.lo \\\n-\tasan_poisoning.lo asan_posix.lo asan_report.lo asan_rtl.lo \\\n-\tasan_stack.lo asan_stats.lo asan_thread.lo asan_win.lo\n+am__objects_1 = asan_activation.lo asan_allocator2.lo \\\n+\tasan_dll_thunk.lo asan_fake_stack.lo asan_globals.lo \\\n+\tasan_interceptors.lo asan_linux.lo asan_mac.lo \\\n+\tasan_malloc_linux.lo asan_malloc_mac.lo asan_malloc_win.lo \\\n+\tasan_new_delete.lo asan_poisoning.lo asan_posix.lo \\\n+\tasan_report.lo asan_rtl.lo asan_stack.lo asan_stats.lo \\\n+\tasan_thread.lo asan_win.lo\n am_libasan_la_OBJECTS = $(am__objects_1)\n libasan_la_OBJECTS = $(am_libasan_la_OBJECTS)\n libasan_la_LINK = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) \\\n@@ -272,6 +273,7 @@ ACLOCAL_AMFLAGS = -I $(top_srcdir) -I $(top_srcdir)/config\n toolexeclib_LTLIBRARIES = libasan.la\n nodist_toolexeclib_HEADERS = libasan_preinit.o\n asan_files = \\\n+\tasan_activation.cc \\\n \tasan_allocator2.cc \\\n \tasan_dll_thunk.cc \\\n \tasan_fake_stack.cc \\\n@@ -412,6 +414,7 @@ mostlyclean-compile:\n distclean-compile:\n \t-rm -f *.tab.c\n \n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_activation.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_allocator2.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_dll_thunk.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_fake_stack.Plo@am__quote@"}, {"sha": "235451c8aec24d45672d1b7a9832e6003f7c3129", "filename": "libsanitizer/asan/asan_activation.cc", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_activation.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_activation.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_activation.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -0,0 +1,72 @@\n+//===-- asan_activation.cc --------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// ASan activation/deactivation logic.\n+//===----------------------------------------------------------------------===//\n+\n+#include \"asan_activation.h\"\n+#include \"asan_allocator.h\"\n+#include \"asan_flags.h\"\n+#include \"asan_internal.h\"\n+#include \"sanitizer_common/sanitizer_flags.h\"\n+\n+namespace __asan {\n+\n+static struct AsanDeactivatedFlags {\n+  int quarantine_size;\n+  int max_redzone;\n+  int malloc_context_size;\n+  bool poison_heap;\n+} asan_deactivated_flags;\n+\n+static bool asan_is_deactivated;\n+\n+void AsanStartDeactivated() {\n+  VReport(1, \"Deactivating ASan\\n\");\n+  // Save flag values.\n+  asan_deactivated_flags.quarantine_size = flags()->quarantine_size;\n+  asan_deactivated_flags.max_redzone = flags()->max_redzone;\n+  asan_deactivated_flags.poison_heap = flags()->poison_heap;\n+  asan_deactivated_flags.malloc_context_size =\n+      common_flags()->malloc_context_size;\n+\n+  flags()->quarantine_size = 0;\n+  flags()->max_redzone = 16;\n+  flags()->poison_heap = false;\n+  common_flags()->malloc_context_size = 0;\n+\n+  asan_is_deactivated = true;\n+}\n+\n+void AsanActivate() {\n+  if (!asan_is_deactivated) return;\n+  VReport(1, \"Activating ASan\\n\");\n+\n+  // Restore flag values.\n+  // FIXME: this is not atomic, and there may be other threads alive.\n+  flags()->quarantine_size = asan_deactivated_flags.quarantine_size;\n+  flags()->max_redzone = asan_deactivated_flags.max_redzone;\n+  flags()->poison_heap = asan_deactivated_flags.poison_heap;\n+  common_flags()->malloc_context_size =\n+      asan_deactivated_flags.malloc_context_size;\n+\n+  ParseExtraActivationFlags();\n+\n+  ReInitializeAllocator();\n+\n+  asan_is_deactivated = false;\n+  VReport(\n+      1,\n+      \"quarantine_size %d, max_redzone %d, poison_heap %d, malloc_context_size \"\n+      \"%d\\n\",\n+      flags()->quarantine_size, flags()->max_redzone, flags()->poison_heap,\n+      common_flags()->malloc_context_size);\n+}\n+\n+}  // namespace __asan"}, {"sha": "01f2d46d2228f006880c3dd774876ad701d54b7d", "filename": "libsanitizer/asan/asan_activation.h", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_activation.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_activation.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_activation.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -0,0 +1,21 @@\n+//===-- asan_activation.h ---------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// ASan activation/deactivation logic.\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef ASAN_ACTIVATION_H\n+#define ASAN_ACTIVATION_H\n+\n+namespace __asan {\n+void AsanStartDeactivated();\n+void AsanActivate();\n+}  // namespace __asan\n+\n+#endif  // ASAN_ACTIVATION_H"}, {"sha": "174a5997d4bb1b2f1152b595debf5cb7c75075a9", "filename": "libsanitizer/asan/asan_allocator.h", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_allocator.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -15,6 +15,7 @@\n \n #include \"asan_internal.h\"\n #include \"asan_interceptors.h\"\n+#include \"sanitizer_common/sanitizer_allocator.h\"\n #include \"sanitizer_common/sanitizer_list.h\"\n \n namespace __asan {\n@@ -29,6 +30,7 @@ static const uptr kNumberOfSizeClasses = 255;\n struct AsanChunk;\n \n void InitializeAllocator();\n+void ReInitializeAllocator();\n \n class AsanChunkView {\n  public:\n@@ -40,6 +42,7 @@ class AsanChunkView {\n   uptr UsedSize();  // Size requested by the user.\n   uptr AllocTid();\n   uptr FreeTid();\n+  bool Eq(const AsanChunkView &c) const { return chunk_ == c.chunk_; }\n   void GetAllocStack(StackTrace *stack);\n   void GetFreeStack(StackTrace *stack);\n   bool AddrIsInside(uptr addr, uptr access_size, sptr *offset) {\n@@ -88,9 +91,46 @@ class AsanChunkFifoList: public IntrusiveList<AsanChunk> {\n   uptr size_;\n };\n \n+struct AsanMapUnmapCallback {\n+  void OnMap(uptr p, uptr size) const;\n+  void OnUnmap(uptr p, uptr size) const;\n+};\n+\n+#if SANITIZER_CAN_USE_ALLOCATOR64\n+# if defined(__powerpc64__)\n+const uptr kAllocatorSpace =  0xa0000000000ULL;\n+const uptr kAllocatorSize  =  0x20000000000ULL;  // 2T.\n+# else\n+const uptr kAllocatorSpace = 0x600000000000ULL;\n+const uptr kAllocatorSize  =  0x40000000000ULL;  // 4T.\n+# endif\n+typedef DefaultSizeClassMap SizeClassMap;\n+typedef SizeClassAllocator64<kAllocatorSpace, kAllocatorSize, 0 /*metadata*/,\n+    SizeClassMap, AsanMapUnmapCallback> PrimaryAllocator;\n+#else  // Fallback to SizeClassAllocator32.\n+static const uptr kRegionSizeLog = 20;\n+static const uptr kNumRegions = SANITIZER_MMAP_RANGE_SIZE >> kRegionSizeLog;\n+# if SANITIZER_WORDSIZE == 32\n+typedef FlatByteMap<kNumRegions> ByteMap;\n+# elif SANITIZER_WORDSIZE == 64\n+typedef TwoLevelByteMap<(kNumRegions >> 12), 1 << 12> ByteMap;\n+# endif\n+typedef CompactSizeClassMap SizeClassMap;\n+typedef SizeClassAllocator32<0, SANITIZER_MMAP_RANGE_SIZE, 16,\n+  SizeClassMap, kRegionSizeLog,\n+  ByteMap,\n+  AsanMapUnmapCallback> PrimaryAllocator;\n+#endif  // SANITIZER_CAN_USE_ALLOCATOR64\n+\n+typedef SizeClassAllocatorLocalCache<PrimaryAllocator> AllocatorCache;\n+typedef LargeMmapAllocator<AsanMapUnmapCallback> SecondaryAllocator;\n+typedef CombinedAllocator<PrimaryAllocator, AllocatorCache,\n+    SecondaryAllocator> Allocator;\n+\n+\n struct AsanThreadLocalMallocStorage {\n   uptr quarantine_cache[16];\n-  uptr allocator2_cache[96 * (512 * 8 + 16)];  // Opaque.\n+  AllocatorCache allocator2_cache;\n   void CommitBack();\n  private:\n   // These objects are allocated via mmap() and are zero-initialized."}, {"sha": "bbc1ff723a49bafd2d2c96e5765d08dbded0eebc", "filename": "libsanitizer/asan/asan_allocator2.cc", "status": "modified", "additions": 44, "deletions": 60, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_allocator2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_allocator2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_allocator2.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -17,8 +17,8 @@\n #include \"asan_mapping.h\"\n #include \"asan_poisoning.h\"\n #include \"asan_report.h\"\n+#include \"asan_stack.h\"\n #include \"asan_thread.h\"\n-#include \"sanitizer_common/sanitizer_allocator.h\"\n #include \"sanitizer_common/sanitizer_flags.h\"\n #include \"sanitizer_common/sanitizer_internal_defs.h\"\n #include \"sanitizer_common/sanitizer_list.h\"\n@@ -28,65 +28,30 @@\n \n namespace __asan {\n \n-struct AsanMapUnmapCallback {\n-  void OnMap(uptr p, uptr size) const {\n-    PoisonShadow(p, size, kAsanHeapLeftRedzoneMagic);\n-    // Statistics.\n-    AsanStats &thread_stats = GetCurrentThreadStats();\n-    thread_stats.mmaps++;\n-    thread_stats.mmaped += size;\n-  }\n-  void OnUnmap(uptr p, uptr size) const {\n-    PoisonShadow(p, size, 0);\n-    // We are about to unmap a chunk of user memory.\n-    // Mark the corresponding shadow memory as not needed.\n-    // Since asan's mapping is compacting, the shadow chunk may be\n-    // not page-aligned, so we only flush the page-aligned portion.\n-    uptr page_size = GetPageSizeCached();\n-    uptr shadow_beg = RoundUpTo(MemToShadow(p), page_size);\n-    uptr shadow_end = RoundDownTo(MemToShadow(p + size), page_size);\n-    FlushUnneededShadowMemory(shadow_beg, shadow_end - shadow_beg);\n-    // Statistics.\n-    AsanStats &thread_stats = GetCurrentThreadStats();\n-    thread_stats.munmaps++;\n-    thread_stats.munmaped += size;\n-  }\n-};\n-\n-#if SANITIZER_WORDSIZE == 64\n-#if defined(__powerpc64__)\n-const uptr kAllocatorSpace =  0xa0000000000ULL;\n-const uptr kAllocatorSize  =  0x20000000000ULL;  // 2T.\n-#else\n-const uptr kAllocatorSpace = 0x600000000000ULL;\n-const uptr kAllocatorSize  =  0x40000000000ULL;  // 4T.\n-#endif\n-typedef DefaultSizeClassMap SizeClassMap;\n-typedef SizeClassAllocator64<kAllocatorSpace, kAllocatorSize, 0 /*metadata*/,\n-    SizeClassMap, AsanMapUnmapCallback> PrimaryAllocator;\n-#elif SANITIZER_WORDSIZE == 32\n-static const u64 kAddressSpaceSize = 1ULL << 32;\n-typedef CompactSizeClassMap SizeClassMap;\n-static const uptr kRegionSizeLog = 20;\n-static const uptr kFlatByteMapSize = kAddressSpaceSize >> kRegionSizeLog;\n-typedef SizeClassAllocator32<0, kAddressSpaceSize, 16,\n-  SizeClassMap, kRegionSizeLog,\n-  FlatByteMap<kFlatByteMapSize>,\n-  AsanMapUnmapCallback> PrimaryAllocator;\n-#endif\n-\n-typedef SizeClassAllocatorLocalCache<PrimaryAllocator> AllocatorCache;\n-typedef LargeMmapAllocator<AsanMapUnmapCallback> SecondaryAllocator;\n-typedef CombinedAllocator<PrimaryAllocator, AllocatorCache,\n-    SecondaryAllocator> Allocator;\n+void AsanMapUnmapCallback::OnMap(uptr p, uptr size) const {\n+  PoisonShadow(p, size, kAsanHeapLeftRedzoneMagic);\n+  // Statistics.\n+  AsanStats &thread_stats = GetCurrentThreadStats();\n+  thread_stats.mmaps++;\n+  thread_stats.mmaped += size;\n+}\n+void AsanMapUnmapCallback::OnUnmap(uptr p, uptr size) const {\n+  PoisonShadow(p, size, 0);\n+  // We are about to unmap a chunk of user memory.\n+  // Mark the corresponding shadow memory as not needed.\n+  FlushUnneededASanShadowMemory(p, size);\n+  // Statistics.\n+  AsanStats &thread_stats = GetCurrentThreadStats();\n+  thread_stats.munmaps++;\n+  thread_stats.munmaped += size;\n+}\n \n // We can not use THREADLOCAL because it is not supported on some of the\n // platforms we care about (OSX 10.6, Android).\n // static THREADLOCAL AllocatorCache cache;\n AllocatorCache *GetAllocatorCache(AsanThreadLocalMallocStorage *ms) {\n   CHECK(ms);\n-  CHECK_LE(sizeof(AllocatorCache), sizeof(ms->allocator2_cache));\n-  return reinterpret_cast<AllocatorCache *>(ms->allocator2_cache);\n+  return &ms->allocator2_cache;\n }\n \n static Allocator allocator;\n@@ -132,7 +97,8 @@ static uptr ComputeRZLog(uptr user_requested_size) {\n     user_requested_size <= (1 << 14) - 256  ? 4 :\n     user_requested_size <= (1 << 15) - 512  ? 5 :\n     user_requested_size <= (1 << 16) - 1024 ? 6 : 7;\n-  return Max(rz_log, RZSize2Log(flags()->redzone));\n+  return Min(Max(rz_log, RZSize2Log(flags()->redzone)),\n+             RZSize2Log(flags()->max_redzone));\n }\n \n // The memory chunk allocated from the underlying allocator looks like this:\n@@ -307,10 +273,14 @@ void InitializeAllocator() {\n   quarantine.Init((uptr)flags()->quarantine_size, kMaxThreadLocalQuarantine);\n }\n \n+void ReInitializeAllocator() {\n+  quarantine.Init((uptr)flags()->quarantine_size, kMaxThreadLocalQuarantine);\n+}\n+\n static void *Allocate(uptr size, uptr alignment, StackTrace *stack,\n                       AllocType alloc_type, bool can_fill) {\n-  if (!asan_inited)\n-    __asan_init();\n+  if (UNLIKELY(!asan_inited))\n+    AsanInitFromRtl();\n   Flags &fl = *flags();\n   CHECK(stack);\n   const uptr min_alignment = SHADOW_GRANULARITY;\n@@ -355,6 +325,16 @@ static void *Allocate(uptr size, uptr alignment, StackTrace *stack,\n     AllocatorCache *cache = &fallback_allocator_cache;\n     allocated = allocator.Allocate(cache, needed_size, 8, false);\n   }\n+\n+  if (*(u8 *)MEM_TO_SHADOW((uptr)allocated) == 0 && flags()->poison_heap) {\n+    // Heap poisoning is enabled, but the allocator provides an unpoisoned\n+    // chunk. This is possible if flags()->poison_heap was disabled for some\n+    // time, for example, due to flags()->start_disabled.\n+    // Anyway, poison the block before using it for anything else.\n+    uptr allocated_size = allocator.GetActuallyAllocatedSize(allocated);\n+    PoisonShadow((uptr)allocated, allocated_size, kAsanHeapLeftRedzoneMagic);\n+  }\n+\n   uptr alloc_beg = reinterpret_cast<uptr>(allocated);\n   uptr alloc_end = alloc_beg + needed_size;\n   uptr beg_plus_redzone = alloc_beg + rz_size;\n@@ -708,8 +688,12 @@ uptr PointsIntoChunk(void* p) {\n   __asan::AsanChunk *m = __asan::GetAsanChunkByAddrFastLocked(addr);\n   if (!m) return 0;\n   uptr chunk = m->Beg();\n-  if ((m->chunk_state == __asan::CHUNK_ALLOCATED) &&\n-      m->AddrIsInside(addr, /*locked_version=*/true))\n+  if (m->chunk_state != __asan::CHUNK_ALLOCATED)\n+    return 0;\n+  if (m->AddrIsInside(addr, /*locked_version=*/true))\n+    return chunk;\n+  if (IsSpecialCaseOfOperatorNew0(chunk, m->UsedSize(/*locked_version*/ true),\n+                                  addr))\n     return chunk;\n   return 0;\n }\n@@ -778,7 +762,7 @@ uptr __asan_get_estimated_allocated_size(uptr size) {\n   return size;\n }\n \n-bool __asan_get_ownership(const void *p) {\n+int __asan_get_ownership(const void *p) {\n   uptr ptr = reinterpret_cast<uptr>(p);\n   return (AllocationSize(ptr) > 0);\n }"}, {"sha": "36a9d0b5e9753d5041ebefaca94a986dc8df6beb", "filename": "libsanitizer/asan/asan_asm_instrumentation.S", "status": "added", "additions": 599, "deletions": 0, "changes": 599, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_asm_instrumentation.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_asm_instrumentation.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_asm_instrumentation.S?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -0,0 +1,599 @@\n+// This file was generated by gen_asm_instrumentation.sh. Please, do not edit\n+.section .text\n+#if defined(__x86_64__) || defined(__i386__)\n+.globl __asan_report_store1\n+.globl __asan_report_load1\n+.globl __asan_report_store2\n+.globl __asan_report_load2\n+.globl __asan_report_store4\n+.globl __asan_report_load4\n+.globl __asan_report_store8\n+.globl __asan_report_load8\n+.globl __asan_report_store16\n+.globl __asan_report_load16\n+#endif //  defined(__x86_64__) || defined(__i386__)\n+#if defined(__i386__)\n+// Sanitize 1-byte store. Takes one 4-byte address as an argument on\n+// stack, nothing is returned.\n+.globl __sanitizer_sanitize_store1\n+.type __sanitizer_sanitize_store1, @function\n+__sanitizer_sanitize_store1:\n+  pushl %ebp\n+  movl %esp, %ebp\n+  pushl %eax\n+  pushl %ecx\n+  pushl %edx\n+  pushfl\n+  movl 8(%ebp), %eax\n+  movl %eax, %ecx\n+  shrl $0x3, %ecx\n+  movb 0x20000000(%ecx), %cl\n+  testb %cl, %cl\n+  je .sanitize_store1_done\n+  movl %eax, %edx\n+  andl $0x7, %edx\n+  movsbl %cl, %ecx\n+  cmpl %ecx, %edx\n+  jl .sanitize_store1_done\n+  pushl %eax\n+  cld\n+  emms\n+  call __asan_report_store1@PLT\n+.sanitize_store1_done:\n+  popfl\n+  popl %edx\n+  popl %ecx\n+  popl %eax\n+  leave\n+  ret\n+// Sanitize 1-byte load. Takes one 4-byte address as an argument on\n+// stack, nothing is returned.\n+.globl __sanitizer_sanitize_load1\n+.type __sanitizer_sanitize_load1, @function\n+__sanitizer_sanitize_load1:\n+  pushl %ebp\n+  movl %esp, %ebp\n+  pushl %eax\n+  pushl %ecx\n+  pushl %edx\n+  pushfl\n+  movl 8(%ebp), %eax\n+  movl %eax, %ecx\n+  shrl $0x3, %ecx\n+  movb 0x20000000(%ecx), %cl\n+  testb %cl, %cl\n+  je .sanitize_load1_done\n+  movl %eax, %edx\n+  andl $0x7, %edx\n+  movsbl %cl, %ecx\n+  cmpl %ecx, %edx\n+  jl .sanitize_load1_done\n+  pushl %eax\n+  cld\n+  emms\n+  call __asan_report_load1@PLT\n+.sanitize_load1_done:\n+  popfl\n+  popl %edx\n+  popl %ecx\n+  popl %eax\n+  leave\n+  ret\n+// Sanitize 2-byte store. Takes one 4-byte address as an argument on\n+// stack, nothing is returned.\n+.globl __sanitizer_sanitize_store2\n+.type __sanitizer_sanitize_store2, @function\n+__sanitizer_sanitize_store2:\n+  pushl %ebp\n+  movl %esp, %ebp\n+  pushl %eax\n+  pushl %ecx\n+  pushl %edx\n+  pushfl\n+  movl 8(%ebp), %eax\n+  movl %eax, %ecx\n+  shrl $0x3, %ecx\n+  movb 0x20000000(%ecx), %cl\n+  testb %cl, %cl\n+  je .sanitize_store2_done\n+  movl %eax, %edx\n+  andl $0x7, %edx\n+  incl %edx\n+  movsbl %cl, %ecx\n+  cmpl %ecx, %edx\n+  jl .sanitize_store2_done\n+  pushl %eax\n+  cld\n+  emms\n+  call __asan_report_store2@PLT\n+.sanitize_store2_done:\n+  popfl\n+  popl %edx\n+  popl %ecx\n+  popl %eax\n+  leave\n+  ret\n+// Sanitize 2-byte load. Takes one 4-byte address as an argument on\n+// stack, nothing is returned.\n+.globl __sanitizer_sanitize_load2\n+.type __sanitizer_sanitize_load2, @function\n+__sanitizer_sanitize_load2:\n+  pushl %ebp\n+  movl %esp, %ebp\n+  pushl %eax\n+  pushl %ecx\n+  pushl %edx\n+  pushfl\n+  movl 8(%ebp), %eax\n+  movl %eax, %ecx\n+  shrl $0x3, %ecx\n+  movb 0x20000000(%ecx), %cl\n+  testb %cl, %cl\n+  je .sanitize_load2_done\n+  movl %eax, %edx\n+  andl $0x7, %edx\n+  incl %edx\n+  movsbl %cl, %ecx\n+  cmpl %ecx, %edx\n+  jl .sanitize_load2_done\n+  pushl %eax\n+  cld\n+  emms\n+  call __asan_report_load2@PLT\n+.sanitize_load2_done:\n+  popfl\n+  popl %edx\n+  popl %ecx\n+  popl %eax\n+  leave\n+  ret\n+// Sanitize 4-byte store. Takes one 4-byte address as an argument on\n+// stack, nothing is returned.\n+.globl __sanitizer_sanitize_store4\n+.type __sanitizer_sanitize_store4, @function\n+__sanitizer_sanitize_store4:\n+  pushl %ebp\n+  movl %esp, %ebp\n+  pushl %eax\n+  pushl %ecx\n+  pushl %edx\n+  pushfl\n+  movl 8(%ebp), %eax\n+  movl %eax, %ecx\n+  shrl $0x3, %ecx\n+  movb 0x20000000(%ecx), %cl\n+  testb %cl, %cl\n+  je .sanitize_store4_done\n+  movl %eax, %edx\n+  andl $0x7, %edx\n+  addl $0x3, %edx\n+  movsbl %cl, %ecx\n+  cmpl %ecx, %edx\n+  jl .sanitize_store4_done\n+  pushl %eax\n+  cld\n+  emms\n+  call __asan_report_store4@PLT\n+.sanitize_store4_done:\n+  popfl\n+  popl %edx\n+  popl %ecx\n+  popl %eax\n+  leave\n+  ret\n+// Sanitize 4-byte load. Takes one 4-byte address as an argument on\n+// stack, nothing is returned.\n+.globl __sanitizer_sanitize_load4\n+.type __sanitizer_sanitize_load4, @function\n+__sanitizer_sanitize_load4:\n+  pushl %ebp\n+  movl %esp, %ebp\n+  pushl %eax\n+  pushl %ecx\n+  pushl %edx\n+  pushfl\n+  movl 8(%ebp), %eax\n+  movl %eax, %ecx\n+  shrl $0x3, %ecx\n+  movb 0x20000000(%ecx), %cl\n+  testb %cl, %cl\n+  je .sanitize_load4_done\n+  movl %eax, %edx\n+  andl $0x7, %edx\n+  addl $0x3, %edx\n+  movsbl %cl, %ecx\n+  cmpl %ecx, %edx\n+  jl .sanitize_load4_done\n+  pushl %eax\n+  cld\n+  emms\n+  call __asan_report_load4@PLT\n+.sanitize_load4_done:\n+  popfl\n+  popl %edx\n+  popl %ecx\n+  popl %eax\n+  leave\n+  ret\n+// Sanitize 8-byte store. Takes one 4-byte address as an argument on\n+// stack, nothing is returned.\n+.globl __sanitizer_sanitize_store8\n+.type __sanitizer_sanitize_store8, @function\n+__sanitizer_sanitize_store8:\n+  pushl %ebp\n+  movl %esp, %ebp\n+  pushl %eax\n+  pushl %ecx\n+  pushfl\n+  movl 8(%ebp), %eax\n+  movl %eax, %ecx\n+  shrl $0x3, %ecx\n+  cmpb $0x0, 0x20000000(%ecx)\n+  je .sanitize_store8_done\n+  pushl %eax\n+  cld\n+  emms\n+  call __asan_report_store8@PLT\n+.sanitize_store8_done:\n+  popfl\n+  popl %ecx\n+  popl %eax\n+  leave\n+  ret\n+// Sanitize 8-byte load. Takes one 4-byte address as an argument on\n+// stack, nothing is returned.\n+.globl __sanitizer_sanitize_load8\n+.type __sanitizer_sanitize_load8, @function\n+__sanitizer_sanitize_load8:\n+  pushl %ebp\n+  movl %esp, %ebp\n+  pushl %eax\n+  pushl %ecx\n+  pushfl\n+  movl 8(%ebp), %eax\n+  movl %eax, %ecx\n+  shrl $0x3, %ecx\n+  cmpb $0x0, 0x20000000(%ecx)\n+  je .sanitize_load8_done\n+  pushl %eax\n+  cld\n+  emms\n+  call __asan_report_load8@PLT\n+.sanitize_load8_done:\n+  popfl\n+  popl %ecx\n+  popl %eax\n+  leave\n+  ret\n+// Sanitize 16-byte store. Takes one 4-byte address as an argument on\n+// stack, nothing is returned.\n+.globl __sanitizer_sanitize_store16\n+.type __sanitizer_sanitize_store16, @function\n+__sanitizer_sanitize_store16:\n+  pushl %ebp\n+  movl %esp, %ebp\n+  pushl %eax\n+  pushl %ecx\n+  pushfl\n+  movl 8(%ebp), %eax\n+  movl %eax, %ecx\n+  shrl $0x3, %ecx\n+  cmpw $0x0, 0x20000000(%ecx)\n+  je .sanitize_store16_done\n+  pushl %eax\n+  cld\n+  emms\n+  call __asan_report_store16@PLT\n+.sanitize_store16_done:\n+  popfl\n+  popl %ecx\n+  popl %eax\n+  leave\n+  ret\n+// Sanitize 16-byte load. Takes one 4-byte address as an argument on\n+// stack, nothing is returned.\n+.globl __sanitizer_sanitize_load16\n+.type __sanitizer_sanitize_load16, @function\n+__sanitizer_sanitize_load16:\n+  pushl %ebp\n+  movl %esp, %ebp\n+  pushl %eax\n+  pushl %ecx\n+  pushfl\n+  movl 8(%ebp), %eax\n+  movl %eax, %ecx\n+  shrl $0x3, %ecx\n+  cmpw $0x0, 0x20000000(%ecx)\n+  je .sanitize_load16_done\n+  pushl %eax\n+  cld\n+  emms\n+  call __asan_report_load16@PLT\n+.sanitize_load16_done:\n+  popfl\n+  popl %ecx\n+  popl %eax\n+  leave\n+  ret\n+#endif // defined(__i386__)\n+#if defined(__x86_64__)\n+// Sanitize 1-byte store. Takes one 8-byte address as an argument in %rdi,\n+// nothing is returned.\n+.globl __sanitizer_sanitize_store1\n+.type __sanitizer_sanitize_store1, @function\n+__sanitizer_sanitize_store1:\n+  leaq -128(%rsp), %rsp\n+  pushq %rax\n+  pushq %rcx\n+  pushfq\n+  movq %rdi, %rax\n+  shrq $0x3, %rax\n+  movb 0x7fff8000(%rax), %al\n+  test %al, %al\n+  je .sanitize_store1_done\n+  movl %edi, %ecx\n+  andl $0x7, %ecx\n+  movsbl %al, %eax\n+  cmpl %eax, %ecx\n+  jl .sanitize_store1_done\n+  subq $8, %rsp\n+  andq $-16, %rsp\n+  cld\n+  emms\n+  call __asan_report_store1@PLT\n+.sanitize_store1_done:\n+  popfq\n+  popq %rcx\n+  popq %rax\n+  leaq 128(%rsp), %rsp\n+  ret\n+// Sanitize 1-byte load. Takes one 8-byte address as an argument in %rdi,\n+// nothing is returned.\n+.globl __sanitizer_sanitize_load1\n+.type __sanitizer_sanitize_load1, @function\n+__sanitizer_sanitize_load1:\n+  leaq -128(%rsp), %rsp\n+  pushq %rax\n+  pushq %rcx\n+  pushfq\n+  movq %rdi, %rax\n+  shrq $0x3, %rax\n+  movb 0x7fff8000(%rax), %al\n+  test %al, %al\n+  je .sanitize_load1_done\n+  movl %edi, %ecx\n+  andl $0x7, %ecx\n+  movsbl %al, %eax\n+  cmpl %eax, %ecx\n+  jl .sanitize_load1_done\n+  subq $8, %rsp\n+  andq $-16, %rsp\n+  cld\n+  emms\n+  call __asan_report_load1@PLT\n+.sanitize_load1_done:\n+  popfq\n+  popq %rcx\n+  popq %rax\n+  leaq 128(%rsp), %rsp\n+  ret\n+// Sanitize 2-byte store. Takes one 8-byte address as an argument in %rdi,\n+// nothing is returned.\n+.globl __sanitizer_sanitize_store2\n+.type __sanitizer_sanitize_store2, @function\n+__sanitizer_sanitize_store2:\n+  leaq -128(%rsp), %rsp\n+  pushq %rax\n+  pushq %rcx\n+  pushfq\n+  movq %rdi, %rax\n+  shrq $0x3, %rax\n+  movb 0x7fff8000(%rax), %al\n+  test %al, %al\n+  je .sanitize_store2_done\n+  movl %edi, %ecx\n+  andl $0x7, %ecx\n+  incl %ecx\n+  movsbl %al, %eax\n+  cmpl %eax, %ecx\n+  jl .sanitize_store2_done\n+  subq $8, %rsp\n+  andq $-16, %rsp\n+  cld\n+  emms\n+  call __asan_report_store2@PLT\n+.sanitize_store2_done:\n+  popfq\n+  popq %rcx\n+  popq %rax\n+  leaq 128(%rsp), %rsp\n+  ret\n+// Sanitize 2-byte load. Takes one 8-byte address as an argument in %rdi,\n+// nothing is returned.\n+.globl __sanitizer_sanitize_load2\n+.type __sanitizer_sanitize_load2, @function\n+__sanitizer_sanitize_load2:\n+  leaq -128(%rsp), %rsp\n+  pushq %rax\n+  pushq %rcx\n+  pushfq\n+  movq %rdi, %rax\n+  shrq $0x3, %rax\n+  movb 0x7fff8000(%rax), %al\n+  test %al, %al\n+  je .sanitize_load2_done\n+  movl %edi, %ecx\n+  andl $0x7, %ecx\n+  incl %ecx\n+  movsbl %al, %eax\n+  cmpl %eax, %ecx\n+  jl .sanitize_load2_done\n+  subq $8, %rsp\n+  andq $-16, %rsp\n+  cld\n+  emms\n+  call __asan_report_load2@PLT\n+.sanitize_load2_done:\n+  popfq\n+  popq %rcx\n+  popq %rax\n+  leaq 128(%rsp), %rsp\n+  ret\n+// Sanitize 4-byte store. Takes one 8-byte address as an argument in %rdi,\n+// nothing is returned.\n+.globl __sanitizer_sanitize_store4\n+.type __sanitizer_sanitize_store4, @function\n+__sanitizer_sanitize_store4:\n+  leaq -128(%rsp), %rsp\n+  pushq %rax\n+  pushq %rcx\n+  pushfq\n+  movq %rdi, %rax\n+  shrq $0x3, %rax\n+  movb 0x7fff8000(%rax), %al\n+  test %al, %al\n+  je .sanitize_store4_done\n+  movl %edi, %ecx\n+  andl $0x7, %ecx\n+  addl $0x3, %ecx\n+  movsbl %al, %eax\n+  cmpl %eax, %ecx\n+  jl .sanitize_store4_done\n+  subq $8, %rsp\n+  andq $-16, %rsp\n+  cld\n+  emms\n+  call __asan_report_store4@PLT\n+.sanitize_store4_done:\n+  popfq\n+  popq %rcx\n+  popq %rax\n+  leaq 128(%rsp), %rsp\n+  ret\n+// Sanitize 4-byte load. Takes one 8-byte address as an argument in %rdi,\n+// nothing is returned.\n+.globl __sanitizer_sanitize_load4\n+.type __sanitizer_sanitize_load4, @function\n+__sanitizer_sanitize_load4:\n+  leaq -128(%rsp), %rsp\n+  pushq %rax\n+  pushq %rcx\n+  pushfq\n+  movq %rdi, %rax\n+  shrq $0x3, %rax\n+  movb 0x7fff8000(%rax), %al\n+  test %al, %al\n+  je .sanitize_load4_done\n+  movl %edi, %ecx\n+  andl $0x7, %ecx\n+  addl $0x3, %ecx\n+  movsbl %al, %eax\n+  cmpl %eax, %ecx\n+  jl .sanitize_load4_done\n+  subq $8, %rsp\n+  andq $-16, %rsp\n+  cld\n+  emms\n+  call __asan_report_load4@PLT\n+.sanitize_load4_done:\n+  popfq\n+  popq %rcx\n+  popq %rax\n+  leaq 128(%rsp), %rsp\n+  ret\n+// Sanitize 8-byte store. Takes one 8-byte address as an argument in %rdi,\n+// nothing is returned.\n+.globl __sanitizer_sanitize_store8\n+.type __sanitizer_sanitize_store8, @function\n+__sanitizer_sanitize_store8:\n+  leaq -128(%rsp), %rsp\n+  pushq %rax\n+  pushfq\n+  movq %rdi, %rax\n+  shrq $0x3, %rax\n+  cmpb $0x0, 0x7fff8000(%rax)\n+  je .sanitize_store8_done\n+  subq $8, %rsp\n+  andq $-16, %rsp\n+  cld\n+  emms\n+  call __asan_report_store8@PLT\n+.sanitize_store8_done:\n+  popfq\n+  popq %rax\n+  leaq 128(%rsp), %rsp\n+  ret\n+// Sanitize 8-byte load. Takes one 8-byte address as an argument in %rdi,\n+// nothing is returned.\n+.globl __sanitizer_sanitize_load8\n+.type __sanitizer_sanitize_load8, @function\n+__sanitizer_sanitize_load8:\n+  leaq -128(%rsp), %rsp\n+  pushq %rax\n+  pushfq\n+  movq %rdi, %rax\n+  shrq $0x3, %rax\n+  cmpb $0x0, 0x7fff8000(%rax)\n+  je .sanitize_load8_done\n+  subq $8, %rsp\n+  andq $-16, %rsp\n+  cld\n+  emms\n+  call __asan_report_load8@PLT\n+.sanitize_load8_done:\n+  popfq\n+  popq %rax\n+  leaq 128(%rsp), %rsp\n+  ret\n+// Sanitize 16-byte store. Takes one 8-byte address as an argument in %rdi,\n+// nothing is returned.\n+.globl __sanitizer_sanitize_store16\n+.type __sanitizer_sanitize_store16, @function\n+__sanitizer_sanitize_store16:\n+  leaq -128(%rsp), %rsp\n+  pushq %rax\n+  pushfq\n+  movq %rdi, %rax\n+  shrq $0x3, %rax\n+  cmpw $0x0, 0x7fff8000(%rax)\n+  je .sanitize_store16_done\n+  subq $8, %rsp\n+  andq $-16, %rsp\n+  cld\n+  emms\n+  call __asan_report_store16@PLT\n+.sanitize_store16_done:\n+  popfq\n+  popq %rax\n+  leaq 128(%rsp), %rsp\n+  ret\n+// Sanitize 16-byte load. Takes one 8-byte address as an argument in %rdi,\n+// nothing is returned.\n+.globl __sanitizer_sanitize_load16\n+.type __sanitizer_sanitize_load16, @function\n+__sanitizer_sanitize_load16:\n+  leaq -128(%rsp), %rsp\n+  pushq %rax\n+  pushfq\n+  movq %rdi, %rax\n+  shrq $0x3, %rax\n+  cmpw $0x0, 0x7fff8000(%rax)\n+  je .sanitize_load16_done\n+  subq $8, %rsp\n+  andq $-16, %rsp\n+  cld\n+  emms\n+  call __asan_report_load16@PLT\n+.sanitize_load16_done:\n+  popfq\n+  popq %rax\n+  leaq 128(%rsp), %rsp\n+  ret\n+#endif // defined(__x86_64__)\n+/* We do not need executable stack. */\n+#if defined(__arm__)\n+  .section .note.GNU-stack,\"\",%progbits\n+#else\n+  .section .note.GNU-stack,\"\",@progbits\n+#endif // defined(__arm__)\n+#endif // __linux__"}, {"sha": "5bed39ac06635cf37f0340cc775d532d670069f0", "filename": "libsanitizer/asan/asan_dll_thunk.cc", "status": "modified", "additions": 116, "deletions": 42, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_dll_thunk.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_dll_thunk.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_dll_thunk.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -18,6 +18,7 @@\n // Using #ifdef rather than relying on Makefiles etc.\n // simplifies the build procedure.\n #ifdef ASAN_DLL_THUNK\n+#include \"sanitizer_common/sanitizer_interception.h\"\n \n // ----------------- Helper functions and macros --------------------- {{{1\n extern \"C\" {\n@@ -113,7 +114,50 @@ static void *getRealProcAddressOrDie(const char *name) {\n   }\n // }}}\n \n+// --------- Interface interception helper functions and macros ----------- {{{1\n+// We need to intercept the ASan interface exported by the DLL thunk and forward\n+// all the functions to the runtime in the main module.\n+// However, we don't want to keep two lists of interface functions.\n+// To avoid that, the list of interface functions should be defined using the\n+// INTERFACE_FUNCTION macro. Then, all the interface can be intercepted at once\n+// by calling INTERCEPT_ASAN_INTERFACE().\n+\n+// Use macro+template magic to automatically generate the list of interface\n+// functions.  Each interface function at line LINE defines a template class\n+// with a static InterfaceInteceptor<LINE>::Execute() method intercepting the\n+// function.  The default implementation of InterfaceInteceptor<LINE> is to call\n+// the Execute() method corresponding to the previous line.\n+template<int LINE>\n+struct InterfaceInteceptor {\n+  static void Execute() { InterfaceInteceptor<LINE-1>::Execute(); }\n+};\n+\n+// There shouldn't be any interface function with negative line number.\n+template<>\n+struct InterfaceInteceptor<0> {\n+  static void Execute() {}\n+};\n+\n+#define INTERFACE_FUNCTION(name)                                               \\\n+  extern \"C\" void name() { __debugbreak(); }                                   \\\n+  template<> struct InterfaceInteceptor<__LINE__> {                            \\\n+    static void Execute() {                                                    \\\n+      void *wrapper = getRealProcAddressOrDie(#name);                          \\\n+      if (!__interception::OverrideFunction((uptr)name, (uptr)wrapper, 0))     \\\n+        abort();                                                               \\\n+      InterfaceInteceptor<__LINE__-1>::Execute();                              \\\n+    }                                                                          \\\n+  };\n+\n+// INTERCEPT_ASAN_INTERFACE must be used after the last INTERFACE_FUNCTION.\n+#define INTERCEPT_ASAN_INTERFACE InterfaceInteceptor<__LINE__>::Execute\n+\n+static void InterceptASanInterface();\n+// }}}\n+\n // ----------------- ASan own interface functions --------------------\n+// Don't use the INTERFACE_FUNCTION machinery for this function as we actually\n+// want to call it in the __asan_init interceptor.\n WRAP_W_V(__asan_should_detect_stack_use_after_return)\n \n extern \"C\" {\n@@ -123,54 +167,75 @@ extern \"C\" {\n   // __asan_option_detect_stack_use_after_return afterwards.\n   void __asan_init_v3() {\n     typedef void (*fntype)();\n-    static fntype fn = (fntype)getRealProcAddressOrDie(\"__asan_init_v3\");\n+    static fntype fn = 0;\n+    if (fn) return;\n+\n+    fn = (fntype)getRealProcAddressOrDie(\"__asan_init_v3\");\n     fn();\n     __asan_option_detect_stack_use_after_return =\n         (__asan_should_detect_stack_use_after_return() != 0);\n+\n+    InterceptASanInterface();\n   }\n }\n \n-WRAP_V_V(__asan_handle_no_return)\n-\n-WRAP_V_W(__asan_report_store1)\n-WRAP_V_W(__asan_report_store2)\n-WRAP_V_W(__asan_report_store4)\n-WRAP_V_W(__asan_report_store8)\n-WRAP_V_W(__asan_report_store16)\n-WRAP_V_WW(__asan_report_store_n)\n-\n-WRAP_V_W(__asan_report_load1)\n-WRAP_V_W(__asan_report_load2)\n-WRAP_V_W(__asan_report_load4)\n-WRAP_V_W(__asan_report_load8)\n-WRAP_V_W(__asan_report_load16)\n-WRAP_V_WW(__asan_report_load_n)\n-\n-WRAP_V_WW(__asan_register_globals)\n-WRAP_V_WW(__asan_unregister_globals)\n-\n-WRAP_W_WW(__asan_stack_malloc_0)\n-WRAP_W_WW(__asan_stack_malloc_1)\n-WRAP_W_WW(__asan_stack_malloc_2)\n-WRAP_W_WW(__asan_stack_malloc_3)\n-WRAP_W_WW(__asan_stack_malloc_4)\n-WRAP_W_WW(__asan_stack_malloc_5)\n-WRAP_W_WW(__asan_stack_malloc_6)\n-WRAP_W_WW(__asan_stack_malloc_7)\n-WRAP_W_WW(__asan_stack_malloc_8)\n-WRAP_W_WW(__asan_stack_malloc_9)\n-WRAP_W_WW(__asan_stack_malloc_10)\n-\n-WRAP_V_WWW(__asan_stack_free_0)\n-WRAP_V_WWW(__asan_stack_free_1)\n-WRAP_V_WWW(__asan_stack_free_2)\n-WRAP_V_WWW(__asan_stack_free_4)\n-WRAP_V_WWW(__asan_stack_free_5)\n-WRAP_V_WWW(__asan_stack_free_6)\n-WRAP_V_WWW(__asan_stack_free_7)\n-WRAP_V_WWW(__asan_stack_free_8)\n-WRAP_V_WWW(__asan_stack_free_9)\n-WRAP_V_WWW(__asan_stack_free_10)\n+INTERFACE_FUNCTION(__asan_handle_no_return)\n+\n+INTERFACE_FUNCTION(__asan_report_store1)\n+INTERFACE_FUNCTION(__asan_report_store2)\n+INTERFACE_FUNCTION(__asan_report_store4)\n+INTERFACE_FUNCTION(__asan_report_store8)\n+INTERFACE_FUNCTION(__asan_report_store16)\n+INTERFACE_FUNCTION(__asan_report_store_n)\n+\n+INTERFACE_FUNCTION(__asan_report_load1)\n+INTERFACE_FUNCTION(__asan_report_load2)\n+INTERFACE_FUNCTION(__asan_report_load4)\n+INTERFACE_FUNCTION(__asan_report_load8)\n+INTERFACE_FUNCTION(__asan_report_load16)\n+INTERFACE_FUNCTION(__asan_report_load_n)\n+\n+INTERFACE_FUNCTION(__asan_memcpy);\n+INTERFACE_FUNCTION(__asan_memset);\n+INTERFACE_FUNCTION(__asan_memmove);\n+\n+INTERFACE_FUNCTION(__asan_register_globals)\n+INTERFACE_FUNCTION(__asan_unregister_globals)\n+\n+INTERFACE_FUNCTION(__asan_before_dynamic_init)\n+INTERFACE_FUNCTION(__asan_after_dynamic_init)\n+\n+INTERFACE_FUNCTION(__asan_poison_stack_memory)\n+INTERFACE_FUNCTION(__asan_unpoison_stack_memory)\n+\n+INTERFACE_FUNCTION(__asan_poison_memory_region)\n+INTERFACE_FUNCTION(__asan_unpoison_memory_region)\n+\n+INTERFACE_FUNCTION(__asan_get_current_fake_stack)\n+INTERFACE_FUNCTION(__asan_addr_is_in_fake_stack)\n+\n+INTERFACE_FUNCTION(__asan_stack_malloc_0)\n+INTERFACE_FUNCTION(__asan_stack_malloc_1)\n+INTERFACE_FUNCTION(__asan_stack_malloc_2)\n+INTERFACE_FUNCTION(__asan_stack_malloc_3)\n+INTERFACE_FUNCTION(__asan_stack_malloc_4)\n+INTERFACE_FUNCTION(__asan_stack_malloc_5)\n+INTERFACE_FUNCTION(__asan_stack_malloc_6)\n+INTERFACE_FUNCTION(__asan_stack_malloc_7)\n+INTERFACE_FUNCTION(__asan_stack_malloc_8)\n+INTERFACE_FUNCTION(__asan_stack_malloc_9)\n+INTERFACE_FUNCTION(__asan_stack_malloc_10)\n+\n+INTERFACE_FUNCTION(__asan_stack_free_0)\n+INTERFACE_FUNCTION(__asan_stack_free_1)\n+INTERFACE_FUNCTION(__asan_stack_free_2)\n+INTERFACE_FUNCTION(__asan_stack_free_4)\n+INTERFACE_FUNCTION(__asan_stack_free_5)\n+INTERFACE_FUNCTION(__asan_stack_free_6)\n+INTERFACE_FUNCTION(__asan_stack_free_7)\n+INTERFACE_FUNCTION(__asan_stack_free_8)\n+INTERFACE_FUNCTION(__asan_stack_free_9)\n+INTERFACE_FUNCTION(__asan_stack_free_10)\n \n // TODO(timurrrr): Add more interface functions on the as-needed basis.\n \n@@ -190,7 +255,16 @@ WRAP_W_WWW(_realloc_dbg)\n WRAP_W_WWW(_recalloc)\n \n WRAP_W_W(_msize)\n+WRAP_W_W(_expand)\n+WRAP_W_W(_expand_dbg)\n+\n+// TODO(timurrrr): Might want to add support for _aligned_* allocation\n+// functions to detect a bit more bugs.  Those functions seem to wrap malloc().\n \n // TODO(timurrrr): Do we need to add _Crt* stuff here? (see asan_malloc_win.cc).\n \n+void InterceptASanInterface() {\n+  INTERCEPT_ASAN_INTERFACE();\n+}\n+\n #endif // ASAN_DLL_THUNK"}, {"sha": "cfe96a0882f5be84d01294537354640003b10f9d", "filename": "libsanitizer/asan/asan_fake_stack.cc", "status": "modified", "additions": 48, "deletions": 13, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_fake_stack.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_fake_stack.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_fake_stack.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -40,21 +40,32 @@ FakeStack *FakeStack::Create(uptr stack_size_log) {\n     stack_size_log = kMinStackSizeLog;\n   if (stack_size_log > kMaxStackSizeLog)\n     stack_size_log = kMaxStackSizeLog;\n+  uptr size = RequiredSize(stack_size_log);\n   FakeStack *res = reinterpret_cast<FakeStack *>(\n-      MmapOrDie(RequiredSize(stack_size_log), \"FakeStack\"));\n+      flags()->uar_noreserve ? MmapNoReserveOrDie(size, \"FakeStack\")\n+                             : MmapOrDie(size, \"FakeStack\"));\n   res->stack_size_log_ = stack_size_log;\n-  if (common_flags()->verbosity) {\n-    u8 *p = reinterpret_cast<u8 *>(res);\n-    Report(\"T%d: FakeStack created: %p -- %p stack_size_log: %zd \\n\",\n-           GetCurrentTidOrInvalid(), p,\n-           p + FakeStack::RequiredSize(stack_size_log), stack_size_log);\n-  }\n+  u8 *p = reinterpret_cast<u8 *>(res);\n+  VReport(1, \"T%d: FakeStack created: %p -- %p stack_size_log: %zd; \"\n+          \"mmapped %zdK, noreserve=%d \\n\",\n+          GetCurrentTidOrInvalid(), p,\n+          p + FakeStack::RequiredSize(stack_size_log), stack_size_log,\n+          size >> 10, flags()->uar_noreserve);\n   return res;\n }\n \n-void FakeStack::Destroy() {\n+void FakeStack::Destroy(int tid) {\n   PoisonAll(0);\n-  UnmapOrDie(this, RequiredSize(stack_size_log_));\n+  if (common_flags()->verbosity >= 2) {\n+    InternalScopedString str(kNumberOfSizeClasses * 50);\n+    for (uptr class_id = 0; class_id < kNumberOfSizeClasses; class_id++)\n+      str.append(\"%zd: %zd/%zd; \", class_id, hint_position_[class_id],\n+                 NumberOfFrames(stack_size_log(), class_id));\n+    Report(\"T%d: FakeStack destroyed: %s\\n\", tid, str.data());\n+  }\n+  uptr size = RequiredSize(stack_size_log_);\n+  FlushUnneededASanShadowMemory(reinterpret_cast<uptr>(this), size);\n+  UnmapOrDie(this, size);\n }\n \n void FakeStack::PoisonAll(u8 magic) {\n@@ -91,7 +102,7 @@ FakeFrame *FakeStack::Allocate(uptr stack_size_log, uptr class_id,\n   return 0; // We are out of fake stack.\n }\n \n-uptr FakeStack::AddrIsInFakeStack(uptr ptr) {\n+uptr FakeStack::AddrIsInFakeStack(uptr ptr, uptr *frame_beg, uptr *frame_end) {\n   uptr stack_size_log = this->stack_size_log();\n   uptr beg = reinterpret_cast<uptr>(GetFrame(stack_size_log, 0, 0));\n   uptr end = reinterpret_cast<uptr>(this) + RequiredSize(stack_size_log);\n@@ -101,7 +112,10 @@ uptr FakeStack::AddrIsInFakeStack(uptr ptr) {\n   CHECK_LE(base, ptr);\n   CHECK_LT(ptr, base + (1UL << stack_size_log));\n   uptr pos = (ptr - base) >> (kMinStackFrameSizeLog + class_id);\n-  return base + pos * BytesInSizeClass(class_id);\n+  uptr res = base + pos * BytesInSizeClass(class_id);\n+  *frame_end = res + BytesInSizeClass(class_id);\n+  *frame_beg = res + sizeof(FakeFrame);\n+  return res;\n }\n \n void FakeStack::HandleNoReturn() {\n@@ -195,14 +209,15 @@ ALWAYS_INLINE void OnFree(uptr ptr, uptr class_id, uptr size, uptr real_stack) {\n }  // namespace __asan\n \n // ---------------------- Interface ---------------- {{{1\n+using namespace __asan;\n #define DEFINE_STACK_MALLOC_FREE_WITH_CLASS_ID(class_id)                       \\\n   extern \"C\" SANITIZER_INTERFACE_ATTRIBUTE uptr                                \\\n   __asan_stack_malloc_##class_id(uptr size, uptr real_stack) {                 \\\n-    return __asan::OnMalloc(class_id, size, real_stack);                       \\\n+    return OnMalloc(class_id, size, real_stack);                               \\\n   }                                                                            \\\n   extern \"C\" SANITIZER_INTERFACE_ATTRIBUTE void __asan_stack_free_##class_id(  \\\n       uptr ptr, uptr size, uptr real_stack) {                                  \\\n-    __asan::OnFree(ptr, class_id, size, real_stack);                           \\\n+    OnFree(ptr, class_id, size, real_stack);                                   \\\n   }\n \n DEFINE_STACK_MALLOC_FREE_WITH_CLASS_ID(0)\n@@ -216,3 +231,23 @@ DEFINE_STACK_MALLOC_FREE_WITH_CLASS_ID(7)\n DEFINE_STACK_MALLOC_FREE_WITH_CLASS_ID(8)\n DEFINE_STACK_MALLOC_FREE_WITH_CLASS_ID(9)\n DEFINE_STACK_MALLOC_FREE_WITH_CLASS_ID(10)\n+extern \"C\" {\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void *__asan_get_current_fake_stack() { return GetFakeStackFast(); }\n+\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void *__asan_addr_is_in_fake_stack(void *fake_stack, void *addr, void **beg,\n+                                   void **end) {\n+  FakeStack *fs = reinterpret_cast<FakeStack*>(fake_stack);\n+  if (!fs) return 0;\n+  uptr frame_beg, frame_end;\n+  FakeFrame *frame = reinterpret_cast<FakeFrame *>(fs->AddrIsInFakeStack(\n+      reinterpret_cast<uptr>(addr), &frame_beg, &frame_end));\n+  if (!frame) return 0;\n+  if (frame->magic != kCurrentStackFrameMagic)\n+    return 0;\n+  if (beg) *beg = reinterpret_cast<void*>(frame_beg);\n+  if (end) *end = reinterpret_cast<void*>(frame_end);\n+  return reinterpret_cast<void*>(frame->real_stack);\n+}\n+}  // extern \"C\""}, {"sha": "550a86e29725db2d185dd68f81763081e0894fdf", "filename": "libsanitizer/asan/asan_fake_stack.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_fake_stack.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_fake_stack.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_fake_stack.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -63,7 +63,7 @@ class FakeStack {\n   // CTOR: create the FakeStack as a single mmap-ed object.\n   static FakeStack *Create(uptr stack_size_log);\n \n-  void Destroy();\n+  void Destroy(int tid);\n \n   // stack_size_log is at least 15 (stack_size >= 32K).\n   static uptr SizeRequiredForFlags(uptr stack_size_log) {\n@@ -127,7 +127,11 @@ class FakeStack {\n   void PoisonAll(u8 magic);\n \n   // Return the beginning of the FakeFrame or 0 if the address is not ours.\n-  uptr AddrIsInFakeStack(uptr addr);\n+  uptr AddrIsInFakeStack(uptr addr, uptr *frame_beg, uptr *frame_end);\n+  USED uptr AddrIsInFakeStack(uptr addr) {\n+    uptr t1, t2;\n+    return AddrIsInFakeStack(addr, &t1, &t2);\n+  }\n \n   // Number of bytes in a fake frame of this size class.\n   static uptr BytesInSizeClass(uptr class_id) {"}, {"sha": "42463a69b9938a3b5d1317ffc58af7aaad085719", "filename": "libsanitizer/asan/asan_flags.h", "status": "modified", "additions": 9, "deletions": 55, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_flags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_flags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_flags.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -26,88 +26,42 @@\n namespace __asan {\n \n struct Flags {\n-  // Size (in bytes) of quarantine used to detect use-after-free errors.\n-  // Lower value may reduce memory usage but increase the chance of\n-  // false negatives.\n+  // Flag descriptions are in asan_rtl.cc.\n   int  quarantine_size;\n-  // Size (in bytes) of redzones around heap objects.\n-  // Requirement: redzone >= 32, is a power of two.\n   int  redzone;\n-  // If set, prints some debugging information and does additional checks.\n+  int  max_redzone;\n   bool debug;\n-  // Controls the way to handle globals (0 - don't detect buffer overflow\n-  // on globals, 1 - detect buffer overflow, 2 - print data about registered\n-  // globals).\n   int  report_globals;\n-  // If set, attempts to catch initialization order issues.\n   bool check_initialization_order;\n-  // If set, uses custom wrappers and replacements for libc string functions\n-  // to find more errors.\n   bool replace_str;\n-  // If set, uses custom wrappers for memset/memcpy/memmove intinsics.\n   bool replace_intrin;\n-  // Used on Mac only.\n   bool mac_ignore_invalid_free;\n-  // Enables stack-use-after-return checking at run-time.\n   bool detect_stack_use_after_return;\n-  // The minimal fake stack size log.\n-  int uar_stack_size_log;\n-  // ASan allocator flag. max_malloc_fill_size is the maximal amount of bytes\n-  // that will be filled with malloc_fill_byte on malloc.\n+  int min_uar_stack_size_log;\n+  int max_uar_stack_size_log;\n+  bool uar_noreserve;\n   int max_malloc_fill_size, malloc_fill_byte;\n-  // Override exit status if something was reported.\n   int  exitcode;\n-  // If set, user may manually mark memory regions as poisoned or unpoisoned.\n   bool allow_user_poisoning;\n-  // Number of seconds to sleep between printing an error report and\n-  // terminating application. Useful for debug purposes (when one needs\n-  // to attach gdb, for example).\n   int  sleep_before_dying;\n-  // If set, registers ASan custom segv handler.\n-  bool handle_segv;\n-  // If set, allows user register segv handler even if ASan registers one.\n-  bool allow_user_segv_handler;\n-  // If set, uses alternate stack for signal handling.\n-  bool use_sigaltstack;\n-  // Allow the users to work around the bug in Nvidia drivers prior to 295.*.\n   bool check_malloc_usable_size;\n-  // If set, explicitly unmaps (huge) shadow at exit.\n   bool unmap_shadow_on_exit;\n-  // If set, calls abort() instead of _exit() after printing an error report.\n   bool abort_on_error;\n-  // Print various statistics after printing an error message or if atexit=1.\n   bool print_stats;\n-  // Print the legend for the shadow bytes.\n   bool print_legend;\n-  // If set, prints ASan exit stats even after program terminates successfully.\n   bool atexit;\n-  // If set, coverage information will be dumped at shutdown time if the\n-  // appropriate instrumentation was enabled.\n-  bool coverage;\n-  // By default, disable core dumper on 64-bit - it makes little sense\n-  // to dump 16T+ core.\n   bool disable_core;\n-  // Allow the tool to re-exec the program. This may interfere badly with the\n-  // debugger.\n   bool allow_reexec;\n-  // If set, prints not only thread creation stacks for threads in error report,\n-  // but also thread creation stacks for threads that created those threads,\n-  // etc. up to main thread.\n   bool print_full_thread_history;\n-  // Poison (or not) the heap memory on [de]allocation. Zero value is useful\n-  // for benchmarking the allocator or instrumentator.\n   bool poison_heap;\n-  // If true, poison partially addressable 8-byte aligned words (default=true).\n-  // This flag affects heap and global buffers, but not stack buffers.\n   bool poison_partial;\n-  // Report errors on malloc/delete, new/free, new/delete[], etc.\n   bool alloc_dealloc_mismatch;\n-  // If true, assume that memcmp(p1, p2, n) always reads n bytes before\n-  // comparing p1 and p2.\n   bool strict_memcmp;\n-  // If true, assume that dynamic initializers can never access globals from\n-  // other modules, even if the latter are already initialized.\n   bool strict_init_order;\n+  bool start_deactivated;\n+  int detect_invalid_pointer_pairs;\n+  bool detect_container_overflow;\n+  int detect_odr_violation;\n };\n \n extern Flags asan_flags_dont_use_directly;"}, {"sha": "132a564f4feebe509f7e36899fc37ad1b0f84ad8", "filename": "libsanitizer/asan/asan_globals.cc", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_globals.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_globals.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_globals.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -90,6 +90,19 @@ static void RegisterGlobal(const Global *g) {\n   CHECK(AddrIsInMem(g->beg));\n   CHECK(AddrIsAlignedByGranularity(g->beg));\n   CHECK(AddrIsAlignedByGranularity(g->size_with_redzone));\n+  if (flags()->detect_odr_violation) {\n+    // Try detecting ODR (One Definition Rule) violation, i.e. the situation\n+    // where two globals with the same name are defined in different modules.\n+    if (__asan_region_is_poisoned(g->beg, g->size_with_redzone)) {\n+      // This check may not be enough: if the first global is much larger\n+      // the entire redzone of the second global may be within the first global.\n+      for (ListOfGlobals *l = list_of_all_globals; l; l = l->next) {\n+        if (g->beg == l->g->beg &&\n+            (flags()->detect_odr_violation >= 2 || g->size != l->g->size))\n+          ReportODRViolation(g, l->g);\n+      }\n+    }\n+  }\n   if (flags()->poison_heap)\n     PoisonRedZones(*g);\n   ListOfGlobals *l = new(allocator_for_globals) ListOfGlobals;"}, {"sha": "19b53363a5b7cb0c31a1d1efb245fe10f064022e", "filename": "libsanitizer/asan/asan_intercepted_functions.h", "status": "removed", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b95591361e32a755231d99c348f8a43e2aed0187/libsanitizer%2Fasan%2Fasan_intercepted_functions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b95591361e32a755231d99c348f8a43e2aed0187/libsanitizer%2Fasan%2Fasan_intercepted_functions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_intercepted_functions.h?ref=b95591361e32a755231d99c348f8a43e2aed0187", "patch": "@@ -1,77 +0,0 @@\n-//===-- asan_intercepted_functions.h ----------------------------*- C++ -*-===//\n-//\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n-//\n-//===----------------------------------------------------------------------===//\n-//\n-// This file is a part of AddressSanitizer, an address sanity checker.\n-//\n-// ASan-private header containing prototypes for wrapper functions and wrappers\n-//===----------------------------------------------------------------------===//\n-#ifndef ASAN_INTERCEPTED_FUNCTIONS_H\n-#define ASAN_INTERCEPTED_FUNCTIONS_H\n-\n-#include \"sanitizer_common/sanitizer_platform_interceptors.h\"\n-\n-// Use macro to describe if specific function should be\n-// intercepted on a given platform.\n-#if !SANITIZER_WINDOWS\n-# define ASAN_INTERCEPT_ATOLL_AND_STRTOLL 1\n-# define ASAN_INTERCEPT__LONGJMP 1\n-# define ASAN_INTERCEPT_STRDUP 1\n-# define ASAN_INTERCEPT_INDEX 1\n-# define ASAN_INTERCEPT_PTHREAD_CREATE 1\n-# define ASAN_INTERCEPT_MLOCKX 1\n-#else\n-# define ASAN_INTERCEPT_ATOLL_AND_STRTOLL 0\n-# define ASAN_INTERCEPT__LONGJMP 0\n-# define ASAN_INTERCEPT_STRDUP 0\n-# define ASAN_INTERCEPT_INDEX 0\n-# define ASAN_INTERCEPT_PTHREAD_CREATE 0\n-# define ASAN_INTERCEPT_MLOCKX 0\n-#endif\n-\n-#if SANITIZER_LINUX\n-# define ASAN_USE_ALIAS_ATTRIBUTE_FOR_INDEX 1\n-#else\n-# define ASAN_USE_ALIAS_ATTRIBUTE_FOR_INDEX 0\n-#endif\n-\n-#if !SANITIZER_MAC\n-# define ASAN_INTERCEPT_STRNLEN 1\n-#else\n-# define ASAN_INTERCEPT_STRNLEN 0\n-#endif\n-\n-#if SANITIZER_LINUX && !SANITIZER_ANDROID\n-# define ASAN_INTERCEPT_SWAPCONTEXT 1\n-#else\n-# define ASAN_INTERCEPT_SWAPCONTEXT 0\n-#endif\n-\n-#if !SANITIZER_ANDROID && !SANITIZER_WINDOWS\n-# define ASAN_INTERCEPT_SIGNAL_AND_SIGACTION 1\n-#else\n-# define ASAN_INTERCEPT_SIGNAL_AND_SIGACTION 0\n-#endif\n-\n-#if !SANITIZER_WINDOWS\n-# define ASAN_INTERCEPT_SIGLONGJMP 1\n-#else\n-# define ASAN_INTERCEPT_SIGLONGJMP 0\n-#endif\n-\n-#if ASAN_HAS_EXCEPTIONS && !SANITIZER_WINDOWS\n-# define ASAN_INTERCEPT___CXA_THROW 1\n-#else\n-# define ASAN_INTERCEPT___CXA_THROW 0\n-#endif\n-\n-#if !SANITIZER_WINDOWS\n-# define ASAN_INTERCEPT___CXA_ATEXIT 1\n-#else\n-# define ASAN_INTERCEPT___CXA_ATEXIT 0\n-#endif\n-\n-#endif  // ASAN_INTERCEPTED_FUNCTIONS_H"}, {"sha": "13deab5766eadae987cb0cf38f9937cdf900be5d", "filename": "libsanitizer/asan/asan_interceptors.cc", "status": "modified", "additions": 95, "deletions": 75, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_interceptors.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_interceptors.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interceptors.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -12,14 +12,12 @@\n #include \"asan_interceptors.h\"\n \n #include \"asan_allocator.h\"\n-#include \"asan_intercepted_functions.h\"\n #include \"asan_internal.h\"\n #include \"asan_mapping.h\"\n #include \"asan_poisoning.h\"\n #include \"asan_report.h\"\n #include \"asan_stack.h\"\n #include \"asan_stats.h\"\n-#include \"interception/interception.h\"\n #include \"sanitizer_common/sanitizer_libc.h\"\n \n namespace __asan {\n@@ -43,6 +41,10 @@ static inline bool QuickCheckForUnpoisonedRegion(uptr beg, uptr size) {\n     uptr __offset = (uptr)(offset);                                     \\\n     uptr __size = (uptr)(size);                                         \\\n     uptr __bad = 0;                                                     \\\n+    if (__offset > __offset + __size) {                                 \\\n+      GET_STACK_TRACE_FATAL_HERE;                                       \\\n+      ReportStringFunctionSizeOverflow(__offset, __size, &stack);       \\\n+    }                                                                   \\\n     if (!QuickCheckForUnpoisonedRegion(__offset, __size) &&             \\\n         (__bad = __asan_region_is_poisoned(__offset, __size))) {        \\\n       GET_CURRENT_PC_BP_SP;                                             \\\n@@ -70,13 +72,6 @@ static inline bool RangesOverlap(const char *offset1, uptr length1,\n   } \\\n } while (0)\n \n-#define ENSURE_ASAN_INITED() do { \\\n-  CHECK(!asan_init_is_running); \\\n-  if (!asan_inited) { \\\n-    __asan_init(); \\\n-  } \\\n-} while (0)\n-\n static inline uptr MaybeRealStrnlen(const char *s, uptr maxlen) {\n #if ASAN_INTERCEPT_STRNLEN\n   if (REAL(strnlen) != 0) {\n@@ -106,31 +101,29 @@ DECLARE_REAL_AND_INTERCEPTOR(void *, malloc, uptr)\n DECLARE_REAL_AND_INTERCEPTOR(void, free, void *)\n \n #if !SANITIZER_MAC\n-#define ASAN_INTERCEPT_FUNC(name)                                      \\\n-  do {                                                                 \\\n-    if ((!INTERCEPT_FUNCTION(name) || !REAL(name)) &&                  \\\n-        common_flags()->verbosity > 0)                                 \\\n-      Report(\"AddressSanitizer: failed to intercept '\" #name \"'\\n\");   \\\n+#define ASAN_INTERCEPT_FUNC(name)                                        \\\n+  do {                                                                   \\\n+    if ((!INTERCEPT_FUNCTION(name) || !REAL(name)))                      \\\n+      VReport(1, \"AddressSanitizer: failed to intercept '\" #name \"'\\n\"); \\\n   } while (0)\n #else\n // OS X interceptors don't need to be initialized with INTERCEPT_FUNCTION.\n #define ASAN_INTERCEPT_FUNC(name)\n #endif  // SANITIZER_MAC\n \n #define COMMON_INTERCEPT_FUNCTION(name) ASAN_INTERCEPT_FUNC(name)\n-#define COMMON_INTERCEPTOR_UNPOISON_PARAM(ctx, count) \\\n-  do {                                                \\\n-  } while (false)\n #define COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ptr, size) \\\n   ASAN_WRITE_RANGE(ptr, size)\n #define COMMON_INTERCEPTOR_READ_RANGE(ctx, ptr, size) ASAN_READ_RANGE(ptr, size)\n-#define COMMON_INTERCEPTOR_ENTER(ctx, func, ...)                       \\\n-  do {                                                                 \\\n-    if (asan_init_is_running) return REAL(func)(__VA_ARGS__);          \\\n-    ctx = 0;                                                           \\\n-    (void) ctx;                                                        \\\n-    if (SANITIZER_MAC && !asan_inited) return REAL(func)(__VA_ARGS__); \\\n-    ENSURE_ASAN_INITED();                                              \\\n+#define COMMON_INTERCEPTOR_ENTER(ctx, func, ...)                               \\\n+  do {                                                                         \\\n+    if (asan_init_is_running)                                                  \\\n+      return REAL(func)(__VA_ARGS__);                                          \\\n+    ctx = 0;                                                                   \\\n+    (void) ctx;                                                                \\\n+    if (SANITIZER_MAC && UNLIKELY(!asan_inited))                               \\\n+      return REAL(func)(__VA_ARGS__);                                          \\\n+    ENSURE_ASAN_INITED();                                                      \\\n   } while (false)\n #define COMMON_INTERCEPTOR_FD_ACQUIRE(ctx, fd) \\\n   do {                                         \\\n@@ -194,20 +187,41 @@ INTERCEPTOR(int, pthread_create, void *thread,\n #endif  // ASAN_INTERCEPT_PTHREAD_CREATE\n \n #if ASAN_INTERCEPT_SIGNAL_AND_SIGACTION\n+\n+#if SANITIZER_ANDROID\n+INTERCEPTOR(void*, bsd_signal, int signum, void *handler) {\n+  if (!AsanInterceptsSignal(signum) ||\n+      common_flags()->allow_user_segv_handler) {\n+    return REAL(bsd_signal)(signum, handler);\n+  }\n+  return 0;\n+}\n+#else\n INTERCEPTOR(void*, signal, int signum, void *handler) {\n-  if (!AsanInterceptsSignal(signum) || flags()->allow_user_segv_handler) {\n+  if (!AsanInterceptsSignal(signum) ||\n+      common_flags()->allow_user_segv_handler) {\n     return REAL(signal)(signum, handler);\n   }\n   return 0;\n }\n+#endif\n \n INTERCEPTOR(int, sigaction, int signum, const struct sigaction *act,\n                             struct sigaction *oldact) {\n-  if (!AsanInterceptsSignal(signum) || flags()->allow_user_segv_handler) {\n+  if (!AsanInterceptsSignal(signum) ||\n+      common_flags()->allow_user_segv_handler) {\n     return REAL(sigaction)(signum, act, oldact);\n   }\n   return 0;\n }\n+\n+namespace __sanitizer {\n+int real_sigaction(int signum, const void *act, void *oldact) {\n+  return REAL(sigaction)(signum,\n+                         (struct sigaction *)act, (struct sigaction *)oldact);\n+}\n+}  // namespace __sanitizer\n+\n #elif SANITIZER_POSIX\n // We need to have defined REAL(sigaction) on posix systems.\n DEFINE_REAL(int, sigaction, int signum, const struct sigaction *act,\n@@ -284,10 +298,9 @@ static void MlockIsUnsupported() {\n   static bool printed = false;\n   if (printed) return;\n   printed = true;\n-  if (common_flags()->verbosity > 0) {\n-    Printf(\"INFO: AddressSanitizer ignores \"\n-           \"mlock/mlockall/munlock/munlockall\\n\");\n-  }\n+  VPrintf(1,\n+          \"INFO: AddressSanitizer ignores \"\n+          \"mlock/mlockall/munlock/munlockall\\n\");\n }\n \n INTERCEPTOR(int, mlock, const void *addr, uptr len) {\n@@ -315,7 +328,7 @@ static inline int CharCmp(unsigned char c1, unsigned char c2) {\n }\n \n INTERCEPTOR(int, memcmp, const void *a1, const void *a2, uptr size) {\n-  if (!asan_inited) return internal_memcmp(a1, a2, size);\n+  if (UNLIKELY(!asan_inited)) return internal_memcmp(a1, a2, size);\n   ENSURE_ASAN_INITED();\n   if (flags()->replace_intrin) {\n     if (flags()->strict_memcmp) {\n@@ -342,24 +355,8 @@ INTERCEPTOR(int, memcmp, const void *a1, const void *a2, uptr size) {\n   return REAL(memcmp(a1, a2, size));\n }\n \n-#define MEMMOVE_BODY { \\\n-  if (!asan_inited) return internal_memmove(to, from, size); \\\n-  if (asan_init_is_running) { \\\n-    return REAL(memmove)(to, from, size); \\\n-  } \\\n-  ENSURE_ASAN_INITED(); \\\n-  if (flags()->replace_intrin) { \\\n-    ASAN_READ_RANGE(from, size); \\\n-    ASAN_WRITE_RANGE(to, size); \\\n-  } \\\n-  return internal_memmove(to, from, size); \\\n-}\n-\n-INTERCEPTOR(void*, memmove, void *to, const void *from, uptr size) MEMMOVE_BODY\n-\n-INTERCEPTOR(void*, memcpy, void *to, const void *from, uptr size) {\n-#if !SANITIZER_MAC\n-  if (!asan_inited) return internal_memcpy(to, from, size);\n+void *__asan_memcpy(void *to, const void *from, uptr size) {\n+  if (UNLIKELY(!asan_inited)) return internal_memcpy(to, from, size);\n   // memcpy is called during __asan_init() from the internals\n   // of printf(...).\n   if (asan_init_is_running) {\n@@ -375,23 +372,11 @@ INTERCEPTOR(void*, memcpy, void *to, const void *from, uptr size) {\n     ASAN_READ_RANGE(from, size);\n     ASAN_WRITE_RANGE(to, size);\n   }\n-  // Interposing of resolver functions is broken on Mac OS 10.7 and 10.8, so\n-  // calling REAL(memcpy) here leads to infinite recursion.\n-  // See also http://code.google.com/p/address-sanitizer/issues/detail?id=116.\n-  return internal_memcpy(to, from, size);\n-#else\n-  // At least on 10.7 and 10.8 both memcpy() and memmove() are being replaced\n-  // with WRAP(memcpy). As a result, false positives are reported for memmove()\n-  // calls. If we just disable error reporting with\n-  // ASAN_OPTIONS=replace_intrin=0, memmove() is still replaced with\n-  // internal_memcpy(), which may lead to crashes, see\n-  // http://llvm.org/bugs/show_bug.cgi?id=16362.\n-  MEMMOVE_BODY\n-#endif  // !SANITIZER_MAC\n+  return REAL(memcpy)(to, from, size);\n }\n \n-INTERCEPTOR(void*, memset, void *block, int c, uptr size) {\n-  if (!asan_inited) return internal_memset(block, c, size);\n+void *__asan_memset(void *block, int c, uptr size) {\n+  if (UNLIKELY(!asan_inited)) return internal_memset(block, c, size);\n   // memset is called inside Printf.\n   if (asan_init_is_running) {\n     return REAL(memset)(block, c, size);\n@@ -403,8 +388,41 @@ INTERCEPTOR(void*, memset, void *block, int c, uptr size) {\n   return REAL(memset)(block, c, size);\n }\n \n+void *__asan_memmove(void *to, const void *from, uptr size) {\n+  if (UNLIKELY(!asan_inited))\n+    return internal_memmove(to, from, size);\n+  ENSURE_ASAN_INITED();\n+  if (flags()->replace_intrin) {\n+    ASAN_READ_RANGE(from, size);\n+    ASAN_WRITE_RANGE(to, size);\n+  }\n+  return internal_memmove(to, from, size);\n+}\n+\n+INTERCEPTOR(void*, memmove, void *to, const void *from, uptr size) {\n+  return __asan_memmove(to, from, size);\n+}\n+\n+INTERCEPTOR(void*, memcpy, void *to, const void *from, uptr size) {\n+#if !SANITIZER_MAC\n+  return __asan_memcpy(to, from, size);\n+#else\n+  // At least on 10.7 and 10.8 both memcpy() and memmove() are being replaced\n+  // with WRAP(memcpy). As a result, false positives are reported for memmove()\n+  // calls. If we just disable error reporting with\n+  // ASAN_OPTIONS=replace_intrin=0, memmove() is still replaced with\n+  // internal_memcpy(), which may lead to crashes, see\n+  // http://llvm.org/bugs/show_bug.cgi?id=16362.\n+  return __asan_memmove(to, from, size);\n+#endif  // !SANITIZER_MAC\n+}\n+\n+INTERCEPTOR(void*, memset, void *block, int c, uptr size) {\n+  return __asan_memset(block, c, size);\n+}\n+\n INTERCEPTOR(char*, strchr, const char *str, int c) {\n-  if (!asan_inited) return internal_strchr(str, c);\n+  if (UNLIKELY(!asan_inited)) return internal_strchr(str, c);\n   // strchr is called inside create_purgeable_zone() when MallocGuardEdges=1 is\n   // used.\n   if (asan_init_is_running) {\n@@ -473,7 +491,7 @@ INTERCEPTOR(char*, strncat, char *to, const char *from, uptr size) {\n \n INTERCEPTOR(char*, strcpy, char *to, const char *from) {  // NOLINT\n #if SANITIZER_MAC\n-  if (!asan_inited) return REAL(strcpy)(to, from);  // NOLINT\n+  if (UNLIKELY(!asan_inited)) return REAL(strcpy)(to, from);  // NOLINT\n #endif\n   // strcpy is called from malloc_default_purgeable_zone()\n   // in __asan::ReplaceSystemAlloc() on Mac.\n@@ -492,7 +510,7 @@ INTERCEPTOR(char*, strcpy, char *to, const char *from) {  // NOLINT\n \n #if ASAN_INTERCEPT_STRDUP\n INTERCEPTOR(char*, strdup, const char *s) {\n-  if (!asan_inited) return internal_strdup(s);\n+  if (UNLIKELY(!asan_inited)) return internal_strdup(s);\n   ENSURE_ASAN_INITED();\n   uptr length = REAL(strlen)(s);\n   if (flags()->replace_str) {\n@@ -506,7 +524,7 @@ INTERCEPTOR(char*, strdup, const char *s) {\n #endif\n \n INTERCEPTOR(uptr, strlen, const char *s) {\n-  if (!asan_inited) return internal_strlen(s);\n+  if (UNLIKELY(!asan_inited)) return internal_strlen(s);\n   // strlen is called from malloc_default_purgeable_zone()\n   // in __asan::ReplaceSystemAlloc() on Mac.\n   if (asan_init_is_running) {\n@@ -588,7 +606,7 @@ INTERCEPTOR(long, strtol, const char *nptr,  // NOLINT\n \n INTERCEPTOR(int, atoi, const char *nptr) {\n #if SANITIZER_MAC\n-  if (!asan_inited) return REAL(atoi)(nptr);\n+  if (UNLIKELY(!asan_inited)) return REAL(atoi)(nptr);\n #endif\n   ENSURE_ASAN_INITED();\n   if (!flags()->replace_str) {\n@@ -607,7 +625,7 @@ INTERCEPTOR(int, atoi, const char *nptr) {\n \n INTERCEPTOR(long, atol, const char *nptr) {  // NOLINT\n #if SANITIZER_MAC\n-  if (!asan_inited) return REAL(atol)(nptr);\n+  if (UNLIKELY(!asan_inited)) return REAL(atol)(nptr);\n #endif\n   ENSURE_ASAN_INITED();\n   if (!flags()->replace_str) {\n@@ -664,7 +682,7 @@ static void AtCxaAtexit(void *unused) {\n INTERCEPTOR(int, __cxa_atexit, void (*func)(void *), void *arg,\n             void *dso_handle) {\n #if SANITIZER_MAC\n-  if (!asan_inited) return REAL(__cxa_atexit)(func, arg, dso_handle);\n+  if (UNLIKELY(!asan_inited)) return REAL(__cxa_atexit)(func, arg, dso_handle);\n #endif\n   ENSURE_ASAN_INITED();\n   int res = REAL(__cxa_atexit)(func, arg, dso_handle);\n@@ -705,7 +723,7 @@ void InitializeAsanInterceptors() {\n   static bool was_called_once;\n   CHECK(was_called_once == false);\n   was_called_once = true;\n-  SANITIZER_COMMON_INTERCEPTORS_INIT;\n+  InitializeCommonInterceptors();\n \n   // Intercept mem* functions.\n   ASAN_INTERCEPT_FUNC(memcmp);\n@@ -753,8 +771,12 @@ void InitializeAsanInterceptors() {\n   ASAN_INTERCEPT_FUNC(longjmp);\n #if ASAN_INTERCEPT_SIGNAL_AND_SIGACTION\n   ASAN_INTERCEPT_FUNC(sigaction);\n+#if SANITIZER_ANDROID\n+  ASAN_INTERCEPT_FUNC(bsd_signal);\n+#else\n   ASAN_INTERCEPT_FUNC(signal);\n #endif\n+#endif\n #if ASAN_INTERCEPT_SWAPCONTEXT\n   ASAN_INTERCEPT_FUNC(swapcontext);\n #endif\n@@ -785,9 +807,7 @@ void InitializeAsanInterceptors() {\n   InitializeWindowsInterceptors();\n #endif\n \n-  if (common_flags()->verbosity > 0) {\n-    Report(\"AddressSanitizer: libc interceptors initialized\\n\");\n-  }\n+  VReport(1, \"AddressSanitizer: libc interceptors initialized\\n\");\n }\n \n }  // namespace __asan"}, {"sha": "af7cdc8a916c2cff8076e20b636130f5d233db97", "filename": "libsanitizer/asan/asan_interceptors.h", "status": "modified", "additions": 69, "deletions": 1, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_interceptors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_interceptors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interceptors.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -13,7 +13,68 @@\n #define ASAN_INTERCEPTORS_H\n \n #include \"asan_internal.h\"\n-#include \"interception/interception.h\"\n+#include \"sanitizer_common/sanitizer_interception.h\"\n+#include \"sanitizer_common/sanitizer_platform_interceptors.h\"\n+\n+// Use macro to describe if specific function should be\n+// intercepted on a given platform.\n+#if !SANITIZER_WINDOWS\n+# define ASAN_INTERCEPT_ATOLL_AND_STRTOLL 1\n+# define ASAN_INTERCEPT__LONGJMP 1\n+# define ASAN_INTERCEPT_STRDUP 1\n+# define ASAN_INTERCEPT_INDEX 1\n+# define ASAN_INTERCEPT_PTHREAD_CREATE 1\n+# define ASAN_INTERCEPT_MLOCKX 1\n+#else\n+# define ASAN_INTERCEPT_ATOLL_AND_STRTOLL 0\n+# define ASAN_INTERCEPT__LONGJMP 0\n+# define ASAN_INTERCEPT_STRDUP 0\n+# define ASAN_INTERCEPT_INDEX 0\n+# define ASAN_INTERCEPT_PTHREAD_CREATE 0\n+# define ASAN_INTERCEPT_MLOCKX 0\n+#endif\n+\n+#if SANITIZER_FREEBSD || SANITIZER_LINUX\n+# define ASAN_USE_ALIAS_ATTRIBUTE_FOR_INDEX 1\n+#else\n+# define ASAN_USE_ALIAS_ATTRIBUTE_FOR_INDEX 0\n+#endif\n+\n+#if !SANITIZER_MAC\n+# define ASAN_INTERCEPT_STRNLEN 1\n+#else\n+# define ASAN_INTERCEPT_STRNLEN 0\n+#endif\n+\n+#if SANITIZER_LINUX && !SANITIZER_ANDROID\n+# define ASAN_INTERCEPT_SWAPCONTEXT 1\n+#else\n+# define ASAN_INTERCEPT_SWAPCONTEXT 0\n+#endif\n+\n+#if !SANITIZER_WINDOWS\n+# define ASAN_INTERCEPT_SIGNAL_AND_SIGACTION 1\n+#else\n+# define ASAN_INTERCEPT_SIGNAL_AND_SIGACTION 0\n+#endif\n+\n+#if !SANITIZER_WINDOWS\n+# define ASAN_INTERCEPT_SIGLONGJMP 1\n+#else\n+# define ASAN_INTERCEPT_SIGLONGJMP 0\n+#endif\n+\n+#if ASAN_HAS_EXCEPTIONS && !SANITIZER_WINDOWS\n+# define ASAN_INTERCEPT___CXA_THROW 1\n+#else\n+# define ASAN_INTERCEPT___CXA_THROW 0\n+#endif\n+\n+#if !SANITIZER_WINDOWS\n+# define ASAN_INTERCEPT___CXA_ATEXIT 1\n+#else\n+# define ASAN_INTERCEPT___CXA_ATEXIT 0\n+#endif\n \n DECLARE_REAL(int, memcmp, const void *a1, const void *a2, uptr size)\n DECLARE_REAL(void*, memcpy, void *to, const void *from, uptr size)\n@@ -31,6 +92,13 @@ namespace __asan {\n \n void InitializeAsanInterceptors();\n \n+#define ENSURE_ASAN_INITED() do { \\\n+  CHECK(!asan_init_is_running); \\\n+  if (UNLIKELY(!asan_inited)) { \\\n+    AsanInitFromRtl(); \\\n+  } \\\n+} while (0)\n+\n }  // namespace __asan\n \n #endif  // ASAN_INTERCEPTORS_H"}, {"sha": "1940477f247642cefb56af143d58b668da9138e0", "filename": "libsanitizer/asan/asan_interface_internal.h", "status": "modified", "additions": 27, "deletions": 8, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_interface_internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_interface_internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interface_internal.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -20,7 +20,7 @@ using __sanitizer::uptr;\n extern \"C\" {\n   // This function should be called at the very beginning of the process,\n   // before any instrumented code is executed and before any call to malloc.\n-  // Everytime the asan ABI changes we also change the version number in this\n+  // Every time the asan ABI changes we also change the version number in this\n   // name. Objects build with incompatible asan ABI version\n   // will not link with run-time.\n   // Changes between ABI versions:\n@@ -75,7 +75,7 @@ extern \"C\" {\n   void __asan_unpoison_memory_region(void const volatile *addr, uptr size);\n \n   SANITIZER_INTERFACE_ATTRIBUTE\n-  bool __asan_address_is_poisoned(void const volatile *addr);\n+  int __asan_address_is_poisoned(void const volatile *addr);\n \n   SANITIZER_INTERFACE_ATTRIBUTE\n   uptr __asan_region_is_poisoned(uptr beg, uptr size);\n@@ -85,7 +85,7 @@ extern \"C\" {\n \n   SANITIZER_INTERFACE_ATTRIBUTE\n   void __asan_report_error(uptr pc, uptr bp, uptr sp,\n-                           uptr addr, bool is_write, uptr access_size);\n+                           uptr addr, int is_write, uptr access_size);\n \n   SANITIZER_INTERFACE_ATTRIBUTE\n   int __asan_set_error_exit_code(int exit_code);\n@@ -97,14 +97,10 @@ extern \"C\" {\n   SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n   /* OPTIONAL */ void __asan_on_error();\n \n-  SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n-  /* OPTIONAL */ bool __asan_symbolize(const void *pc, char *out_buffer,\n-                                       int out_size);\n-\n   SANITIZER_INTERFACE_ATTRIBUTE\n   uptr __asan_get_estimated_allocated_size(uptr size);\n \n-  SANITIZER_INTERFACE_ATTRIBUTE bool __asan_get_ownership(const void *p);\n+  SANITIZER_INTERFACE_ATTRIBUTE int __asan_get_ownership(const void *p);\n   SANITIZER_INTERFACE_ATTRIBUTE uptr __asan_get_allocated_size(const void *p);\n   SANITIZER_INTERFACE_ATTRIBUTE uptr __asan_get_current_allocated_bytes();\n   SANITIZER_INTERFACE_ATTRIBUTE uptr __asan_get_heap_size();\n@@ -123,6 +119,29 @@ extern \"C\" {\n   // Global flag, copy of ASAN_OPTIONS=detect_stack_use_after_return\n   SANITIZER_INTERFACE_ATTRIBUTE\n   extern int __asan_option_detect_stack_use_after_return;\n+\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  extern uptr *__asan_test_only_reported_buggy_pointer;\n+\n+  SANITIZER_INTERFACE_ATTRIBUTE void __asan_load1(uptr p);\n+  SANITIZER_INTERFACE_ATTRIBUTE void __asan_load2(uptr p);\n+  SANITIZER_INTERFACE_ATTRIBUTE void __asan_load4(uptr p);\n+  SANITIZER_INTERFACE_ATTRIBUTE void __asan_load8(uptr p);\n+  SANITIZER_INTERFACE_ATTRIBUTE void __asan_load16(uptr p);\n+  SANITIZER_INTERFACE_ATTRIBUTE void __asan_store1(uptr p);\n+  SANITIZER_INTERFACE_ATTRIBUTE void __asan_store2(uptr p);\n+  SANITIZER_INTERFACE_ATTRIBUTE void __asan_store4(uptr p);\n+  SANITIZER_INTERFACE_ATTRIBUTE void __asan_store8(uptr p);\n+  SANITIZER_INTERFACE_ATTRIBUTE void __asan_store16(uptr p);\n+  SANITIZER_INTERFACE_ATTRIBUTE void __asan_loadN(uptr p, uptr size);\n+  SANITIZER_INTERFACE_ATTRIBUTE void __asan_storeN(uptr p, uptr size);\n+\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+      void* __asan_memcpy(void *dst, const void *src, uptr size);\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+      void* __asan_memset(void *s, int c, uptr n);\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+      void* __asan_memmove(void* dest, const void* src, uptr n);\n }  // extern \"C\"\n \n #endif  // ASAN_INTERFACE_INTERNAL_H"}, {"sha": "d56943a08389b3aacf76dd1550ecbf8bcbd1a5c3", "filename": "libsanitizer/asan/asan_internal.h", "status": "modified", "additions": 17, "deletions": 21, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_internal.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -28,26 +28,11 @@\n \n // Build-time configuration options.\n \n-// If set, asan will install its own SEGV signal handler.\n-#ifndef ASAN_NEEDS_SEGV\n-# if SANITIZER_ANDROID == 1\n-#  define ASAN_NEEDS_SEGV 0\n-# else\n-#  define ASAN_NEEDS_SEGV 1\n-# endif\n-#endif\n-\n // If set, asan will intercept C++ exception api call(s).\n #ifndef ASAN_HAS_EXCEPTIONS\n # define ASAN_HAS_EXCEPTIONS 1\n #endif\n \n-// If set, asan uses the values of SHADOW_SCALE and SHADOW_OFFSET\n-// provided by the instrumented objects. Otherwise constants are used.\n-#ifndef ASAN_FLEXIBLE_MAPPING_AND_OFFSET\n-# define ASAN_FLEXIBLE_MAPPING_AND_OFFSET 0\n-#endif\n-\n // If set, values like allocator chunk size, as well as defaults for some flags\n // will be changed towards less memory overhead.\n #ifndef ASAN_LOW_MEMORY\n@@ -62,32 +47,41 @@\n # define ASAN_USE_PREINIT_ARRAY (SANITIZER_LINUX && !SANITIZER_ANDROID)\n #endif\n \n+#ifndef ASAN_DYNAMIC\n+# ifdef PIC\n+#  define ASAN_DYNAMIC 1\n+# else\n+#  define ASAN_DYNAMIC 0\n+# endif\n+#endif\n+\n // All internal functions in asan reside inside the __asan namespace\n // to avoid namespace collisions with the user programs.\n-// Seperate namespace also makes it simpler to distinguish the asan run-time\n+// Separate namespace also makes it simpler to distinguish the asan run-time\n // functions from the instrumented user code in a profile.\n namespace __asan {\n \n class AsanThread;\n using __sanitizer::StackTrace;\n \n+void AsanInitFromRtl();\n+\n // asan_rtl.cc\n void NORETURN ShowStatsAndAbort();\n \n-void ReplaceOperatorsNewAndDelete();\n // asan_malloc_linux.cc / asan_malloc_mac.cc\n void ReplaceSystemMalloc();\n \n // asan_linux.cc / asan_mac.cc / asan_win.cc\n void *AsanDoesNotSupportStaticLinkage();\n+void AsanCheckDynamicRTPrereqs();\n+void AsanCheckIncompatibleRT();\n \n void GetPcSpBp(void *context, uptr *pc, uptr *sp, uptr *bp);\n+void AsanOnSIGSEGV(int, void *siginfo, void *context);\n \n void MaybeReexec();\n bool AsanInterceptsSignal(int signum);\n-void SetAlternateSignalStack();\n-void UnsetAlternateSignalStack();\n-void InstallSignalHandlers();\n void ReadContextStack(void *context, uptr *stack, uptr *ssize);\n void AsanPlatformThreadInit();\n void StopInitOrderChecking();\n@@ -100,7 +94,9 @@ void PlatformTSDDtor(void *tsd);\n \n void AppendToErrorMessageBuffer(const char *buffer);\n \n-// Platfrom-specific options.\n+void ParseExtraActivationFlags();\n+\n+// Platform-specific options.\n #if SANITIZER_MAC\n bool PlatformHasDifferentMemcpyAndMemmove();\n # define PLATFORM_HAS_DIFFERENT_MEMCPY_AND_MEMMOVE \\"}, {"sha": "d893b2334d503ec81ab6d66b1d907569ec3c5e75", "filename": "libsanitizer/asan/asan_linux.cc", "status": "modified", "additions": 128, "deletions": 21, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_linux.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -11,11 +11,12 @@\n //===----------------------------------------------------------------------===//\n \n #include \"sanitizer_common/sanitizer_platform.h\"\n-#if SANITIZER_LINUX\n+#if SANITIZER_FREEBSD || SANITIZER_LINUX\n \n #include \"asan_interceptors.h\"\n #include \"asan_internal.h\"\n #include \"asan_thread.h\"\n+#include \"sanitizer_common/sanitizer_flags.h\"\n #include \"sanitizer_common/sanitizer_libc.h\"\n #include \"sanitizer_common/sanitizer_procmaps.h\"\n \n@@ -30,12 +31,41 @@\n #include <unistd.h>\n #include <unwind.h>\n \n-#if !SANITIZER_ANDROID\n-// FIXME: where to get ucontext on Android?\n-#include <sys/ucontext.h>\n+#if SANITIZER_FREEBSD\n+#include <sys/link_elf.h>\n #endif\n \n+#if SANITIZER_ANDROID || SANITIZER_FREEBSD\n+#include <ucontext.h>\n extern \"C\" void* _DYNAMIC;\n+#else\n+#include <sys/ucontext.h>\n+#include <dlfcn.h>\n+#include <link.h>\n+#endif\n+\n+// x86_64 FreeBSD 9.2 and older define 64-bit register names in both 64-bit\n+// and 32-bit modes.\n+#if SANITIZER_FREEBSD\n+#include <sys/param.h>\n+# if __FreeBSD_version <= 902001  // v9.2\n+#  define mc_eip mc_rip\n+#  define mc_ebp mc_rbp\n+#  define mc_esp mc_rsp\n+# endif\n+#endif\n+\n+typedef enum {\n+  ASAN_RT_VERSION_UNDEFINED = 0,\n+  ASAN_RT_VERSION_DYNAMIC,\n+  ASAN_RT_VERSION_STATIC,\n+} asan_rt_version_t;\n+\n+// FIXME: perhaps also store abi version here?\n+extern \"C\" {\n+SANITIZER_INTERFACE_ATTRIBUTE\n+asan_rt_version_t  __asan_rt_version;\n+}\n \n namespace __asan {\n \n@@ -48,38 +78,115 @@ void *AsanDoesNotSupportStaticLinkage() {\n   return &_DYNAMIC;  // defined in link.h\n }\n \n-void GetPcSpBp(void *context, uptr *pc, uptr *sp, uptr *bp) {\n #if SANITIZER_ANDROID\n-  *pc = *sp = *bp = 0;\n-#elif defined(__arm__)\n+// FIXME: should we do anything for Android?\n+void AsanCheckDynamicRTPrereqs() {}\n+void AsanCheckIncompatibleRT() {}\n+#else\n+static int FindFirstDSOCallback(struct dl_phdr_info *info, size_t size,\n+                                void *data) {\n+  // Continue until the first dynamic library is found\n+  if (!info->dlpi_name || info->dlpi_name[0] == 0)\n+    return 0;\n+\n+  *(const char **)data = info->dlpi_name;\n+  return 1;\n+}\n+\n+static bool IsDynamicRTName(const char *libname) {\n+  return internal_strstr(libname, \"libclang_rt.asan\") ||\n+    internal_strstr(libname, \"libasan.so\");\n+}\n+\n+static void ReportIncompatibleRT() {\n+  Report(\"Your application is linked against incompatible ASan runtimes.\\n\");\n+  Die();\n+}\n+\n+void AsanCheckDynamicRTPrereqs() {\n+  // Ensure that dynamic RT is the first DSO in the list\n+  const char *first_dso_name = 0;\n+  dl_iterate_phdr(FindFirstDSOCallback, &first_dso_name);\n+  if (first_dso_name && !IsDynamicRTName(first_dso_name)) {\n+    Report(\"ASan runtime does not come first in initial library list; \"\n+           \"you should either link runtime to your application or \"\n+           \"manually preload it with LD_PRELOAD.\\n\");\n+    Die();\n+  }\n+}\n+\n+void AsanCheckIncompatibleRT() {\n+  if (ASAN_DYNAMIC) {\n+    if (__asan_rt_version == ASAN_RT_VERSION_UNDEFINED) {\n+      __asan_rt_version = ASAN_RT_VERSION_DYNAMIC;\n+    } else if (__asan_rt_version != ASAN_RT_VERSION_DYNAMIC) {\n+      ReportIncompatibleRT();\n+    }\n+  } else {\n+    if (__asan_rt_version == ASAN_RT_VERSION_UNDEFINED) {\n+      // Ensure that dynamic runtime is not present. We should detect it\n+      // as early as possible, otherwise ASan interceptors could bind to\n+      // the functions in dynamic ASan runtime instead of the functions in\n+      // system libraries, causing crashes later in ASan initialization.\n+      MemoryMappingLayout proc_maps(/*cache_enabled*/true);\n+      char filename[128];\n+      while (proc_maps.Next(0, 0, 0, filename, sizeof(filename), 0)) {\n+        if (IsDynamicRTName(filename)) {\n+          Report(\"Your application is linked against \"\n+                 \"incompatible ASan runtimes.\\n\");\n+          Die();\n+        }\n+      }\n+      __asan_rt_version = ASAN_RT_VERSION_STATIC;\n+    } else if (__asan_rt_version != ASAN_RT_VERSION_STATIC) {\n+      ReportIncompatibleRT();\n+    }\n+  }\n+}\n+#endif  // SANITIZER_ANDROID\n+\n+void GetPcSpBp(void *context, uptr *pc, uptr *sp, uptr *bp) {\n+#if defined(__arm__)\n   ucontext_t *ucontext = (ucontext_t*)context;\n   *pc = ucontext->uc_mcontext.arm_pc;\n   *bp = ucontext->uc_mcontext.arm_fp;\n   *sp = ucontext->uc_mcontext.arm_sp;\n-# elif defined(__hppa__)\n+#elif defined(__aarch64__)\n+  ucontext_t *ucontext = (ucontext_t*)context;\n+  *pc = ucontext->uc_mcontext.pc;\n+  *bp = ucontext->uc_mcontext.regs[29];\n+  *sp = ucontext->uc_mcontext.sp;\n+#elif defined(__hppa__)\n   ucontext_t *ucontext = (ucontext_t*)context;\n   *pc = ucontext->uc_mcontext.sc_iaoq[0];\n   /* GCC uses %r3 whenever a frame pointer is needed.  */\n   *bp = ucontext->uc_mcontext.sc_gr[3];\n   *sp = ucontext->uc_mcontext.sc_gr[30];\n-# elif defined(__x86_64__)\n+#elif defined(__x86_64__)\n+# if SANITIZER_FREEBSD\n+  ucontext_t *ucontext = (ucontext_t*)context;\n+  *pc = ucontext->uc_mcontext.mc_rip;\n+  *bp = ucontext->uc_mcontext.mc_rbp;\n+  *sp = ucontext->uc_mcontext.mc_rsp;\n+# else\n   ucontext_t *ucontext = (ucontext_t*)context;\n   *pc = ucontext->uc_mcontext.gregs[REG_RIP];\n   *bp = ucontext->uc_mcontext.gregs[REG_RBP];\n   *sp = ucontext->uc_mcontext.gregs[REG_RSP];\n-# elif defined(__i386__)\n+# endif\n+#elif defined(__i386__)\n+# if SANITIZER_FREEBSD\n+  ucontext_t *ucontext = (ucontext_t*)context;\n+  *pc = ucontext->uc_mcontext.mc_eip;\n+  *bp = ucontext->uc_mcontext.mc_ebp;\n+  *sp = ucontext->uc_mcontext.mc_esp;\n+# else\n   ucontext_t *ucontext = (ucontext_t*)context;\n   *pc = ucontext->uc_mcontext.gregs[REG_EIP];\n   *bp = ucontext->uc_mcontext.gregs[REG_EBP];\n   *sp = ucontext->uc_mcontext.gregs[REG_ESP];\n-# elif defined(__powerpc__) || defined(__powerpc64__)\n-  ucontext_t *ucontext = (ucontext_t*)context;\n-  *pc = ucontext->uc_mcontext.regs->nip;\n-  *sp = ucontext->uc_mcontext.regs->gpr[PT_R1];\n-  // The powerpc{,64}-linux ABIs do not specify r31 as the frame\n-  // pointer, but GCC always uses r31 when we need a frame pointer.\n-  *bp = ucontext->uc_mcontext.regs->gpr[PT_R31];\n-# elif defined(__sparc__)\n+# endif\n+#elif defined(__sparc__)\n   ucontext_t *ucontext = (ucontext_t*)context;\n   uptr *stk_ptr;\n # if defined (__arch64__)\n@@ -93,7 +200,7 @@ void GetPcSpBp(void *context, uptr *pc, uptr *sp, uptr *bp) {\n   stk_ptr = (uptr *) *sp;\n   *bp = stk_ptr[15];\n # endif\n-# elif defined(__mips__)\n+#elif defined(__mips__)\n   ucontext_t *ucontext = (ucontext_t*)context;\n   *pc = ucontext->uc_mcontext.gregs[31];\n   *bp = ucontext->uc_mcontext.gregs[30];\n@@ -104,7 +211,7 @@ void GetPcSpBp(void *context, uptr *pc, uptr *sp, uptr *bp) {\n }\n \n bool AsanInterceptsSignal(int signum) {\n-  return signum == SIGSEGV && flags()->handle_segv;\n+  return signum == SIGSEGV && common_flags()->handle_segv;\n }\n \n void AsanPlatformThreadInit() {\n@@ -125,4 +232,4 @@ void ReadContextStack(void *context, uptr *stack, uptr *ssize) {\n \n }  // namespace __asan\n \n-#endif  // SANITIZER_LINUX\n+#endif  // SANITIZER_FREEBSD || SANITIZER_LINUX"}, {"sha": "4a295e0e355a026ec32949e74d2fe48c93540969", "filename": "libsanitizer/asan/asan_mac.cc", "status": "modified", "additions": 21, "deletions": 55, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_mac.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -15,12 +15,12 @@\n \n #include \"asan_interceptors.h\"\n #include \"asan_internal.h\"\n-#include \"asan_mac.h\"\n #include \"asan_mapping.h\"\n #include \"asan_stack.h\"\n #include \"asan_thread.h\"\n #include \"sanitizer_common/sanitizer_atomic.h\"\n #include \"sanitizer_common/sanitizer_libc.h\"\n+#include \"sanitizer_common/sanitizer_mac.h\"\n \n #include <crt_externs.h>  // for _NSGetArgv\n #include <dlfcn.h>  // for dladdr()\n@@ -51,43 +51,6 @@ void GetPcSpBp(void *context, uptr *pc, uptr *sp, uptr *bp) {\n # endif  // SANITIZER_WORDSIZE\n }\n \n-MacosVersion cached_macos_version = MACOS_VERSION_UNINITIALIZED;\n-\n-MacosVersion GetMacosVersionInternal() {\n-  int mib[2] = { CTL_KERN, KERN_OSRELEASE };\n-  char version[100];\n-  uptr len = 0, maxlen = sizeof(version) / sizeof(version[0]);\n-  for (uptr i = 0; i < maxlen; i++) version[i] = '\\0';\n-  // Get the version length.\n-  CHECK_NE(sysctl(mib, 2, 0, &len, 0, 0), -1);\n-  CHECK_LT(len, maxlen);\n-  CHECK_NE(sysctl(mib, 2, version, &len, 0, 0), -1);\n-  switch (version[0]) {\n-    case '9': return MACOS_VERSION_LEOPARD;\n-    case '1': {\n-      switch (version[1]) {\n-        case '0': return MACOS_VERSION_SNOW_LEOPARD;\n-        case '1': return MACOS_VERSION_LION;\n-        case '2': return MACOS_VERSION_MOUNTAIN_LION;\n-        case '3': return MACOS_VERSION_MAVERICKS;\n-        default: return MACOS_VERSION_UNKNOWN;\n-      }\n-    }\n-    default: return MACOS_VERSION_UNKNOWN;\n-  }\n-}\n-\n-MacosVersion GetMacosVersion() {\n-  atomic_uint32_t *cache =\n-      reinterpret_cast<atomic_uint32_t*>(&cached_macos_version);\n-  MacosVersion result =\n-      static_cast<MacosVersion>(atomic_load(cache, memory_order_acquire));\n-  if (result == MACOS_VERSION_UNINITIALIZED) {\n-    result = GetMacosVersionInternal();\n-    atomic_store(cache, result, memory_order_release);\n-  }\n-  return result;\n-}\n \n bool PlatformHasDifferentMemcpyAndMemmove() {\n   // On OS X 10.7 memcpy() and memmove() are both resolved\n@@ -172,12 +135,10 @@ void MaybeReexec() {\n       // Set DYLD_INSERT_LIBRARIES equal to the runtime dylib name.\n       setenv(kDyldInsertLibraries, info.dli_fname, /*overwrite*/0);\n     }\n-    if (common_flags()->verbosity >= 1) {\n-      Report(\"exec()-ing the program with\\n\");\n-      Report(\"%s=%s\\n\", kDyldInsertLibraries, new_env);\n-      Report(\"to enable ASan wrappers.\\n\");\n-      Report(\"Set ASAN_OPTIONS=allow_reexec=0 to disable this.\\n\");\n-    }\n+    VReport(1, \"exec()-ing the program with\\n\");\n+    VReport(1, \"%s=%s\\n\", kDyldInsertLibraries, new_env);\n+    VReport(1, \"to enable ASan wrappers.\\n\");\n+    VReport(1, \"Set ASAN_OPTIONS=allow_reexec=0 to disable this.\\n\");\n     execv(program_name, *_NSGetArgv());\n   } else {\n     // DYLD_INSERT_LIBRARIES is set and contains the runtime library.\n@@ -236,8 +197,15 @@ void *AsanDoesNotSupportStaticLinkage() {\n   return 0;\n }\n \n+// No-op. Mac does not support static linkage anyway.\n+void AsanCheckDynamicRTPrereqs() {}\n+\n+// No-op. Mac does not support static linkage anyway.\n+void AsanCheckIncompatibleRT() {}\n+\n bool AsanInterceptsSignal(int signum) {\n-  return (signum == SIGSEGV || signum == SIGBUS) && flags()->handle_segv;\n+  return (signum == SIGSEGV || signum == SIGBUS) &&\n+         common_flags()->handle_segv;\n }\n \n void AsanPlatformThreadInit() {\n@@ -309,11 +277,10 @@ extern \"C\"\n void asan_dispatch_call_block_and_release(void *block) {\n   GET_STACK_TRACE_THREAD;\n   asan_block_context_t *context = (asan_block_context_t*)block;\n-  if (common_flags()->verbosity >= 2) {\n-    Report(\"asan_dispatch_call_block_and_release(): \"\n-           \"context: %p, pthread_self: %p\\n\",\n-           block, pthread_self());\n-  }\n+  VReport(2,\n+          \"asan_dispatch_call_block_and_release(): \"\n+          \"context: %p, pthread_self: %p\\n\",\n+          block, pthread_self());\n   asan_register_worker_thread(context->parent_tid, &stack);\n   // Call the original dispatcher for the block.\n   context->func(context->block);\n@@ -347,10 +314,10 @@ asan_block_context_t *alloc_asan_context(void *ctxt, dispatch_function_t func,\n     if (common_flags()->verbosity >= 2) {                                     \\\n       Report(#dispatch_x_f \"(): context: %p, pthread_self: %p\\n\",             \\\n              asan_ctxt, pthread_self());                                      \\\n-       PRINT_CURRENT_STACK();                                                 \\\n-     }                                                                        \\\n-     return REAL(dispatch_x_f)(dq, (void*)asan_ctxt,                          \\\n-                               asan_dispatch_call_block_and_release);         \\\n+      PRINT_CURRENT_STACK();                                                  \\\n+    }                                                                         \\\n+    return REAL(dispatch_x_f)(dq, (void*)asan_ctxt,                           \\\n+                              asan_dispatch_call_block_and_release);          \\\n   }\n \n INTERCEPT_DISPATCH_X_F_3(dispatch_async_f)\n@@ -386,7 +353,6 @@ INTERCEPTOR(void, dispatch_group_async_f, dispatch_group_t group,\n \n #if !defined(MISSING_BLOCKS_SUPPORT)\n extern \"C\" {\n-// FIXME: consolidate these declarations with asan_intercepted_functions.h.\n void dispatch_async(dispatch_queue_t dq, void(^work)(void));\n void dispatch_group_async(dispatch_group_t dg, dispatch_queue_t dq,\n                           void(^work)(void));"}, {"sha": "2d1d4b0bfb33d6e11309659a281763171a89fb1b", "filename": "libsanitizer/asan/asan_mac.h", "status": "removed", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b95591361e32a755231d99c348f8a43e2aed0187/libsanitizer%2Fasan%2Fasan_mac.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b95591361e32a755231d99c348f8a43e2aed0187/libsanitizer%2Fasan%2Fasan_mac.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_mac.h?ref=b95591361e32a755231d99c348f8a43e2aed0187", "patch": "@@ -1,57 +0,0 @@\n-//===-- asan_mac.h ----------------------------------------------*- C++ -*-===//\n-//\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n-//\n-//===----------------------------------------------------------------------===//\n-//\n-// This file is a part of AddressSanitizer, an address sanity checker.\n-//\n-// Mac-specific ASan definitions.\n-//===----------------------------------------------------------------------===//\n-#ifndef ASAN_MAC_H\n-#define ASAN_MAC_H\n-\n-// CF_RC_BITS, the layout of CFRuntimeBase and __CFStrIsConstant are internal\n-// and subject to change in further CoreFoundation versions. Apple does not\n-// guarantee any binary compatibility from release to release.\n-\n-// See http://opensource.apple.com/source/CF/CF-635.15/CFInternal.h\n-#if defined(__BIG_ENDIAN__)\n-#define CF_RC_BITS 0\n-#endif\n-\n-#if defined(__LITTLE_ENDIAN__)\n-#define CF_RC_BITS 3\n-#endif\n-\n-// See http://opensource.apple.com/source/CF/CF-635.15/CFRuntime.h\n-typedef struct __CFRuntimeBase {\n-  uptr _cfisa;\n-  u8 _cfinfo[4];\n-#if __LP64__\n-  u32 _rc;\n-#endif\n-} CFRuntimeBase;\n-\n-enum MacosVersion {\n-  MACOS_VERSION_UNINITIALIZED = 0,\n-  MACOS_VERSION_UNKNOWN,\n-  MACOS_VERSION_LEOPARD,\n-  MACOS_VERSION_SNOW_LEOPARD,\n-  MACOS_VERSION_LION,\n-  MACOS_VERSION_MOUNTAIN_LION,\n-  MACOS_VERSION_MAVERICKS\n-};\n-\n-// Used by asan_malloc_mac.cc and asan_mac.cc\n-extern \"C\" void __CFInitialize();\n-\n-namespace __asan {\n-\n-MacosVersion GetMacosVersion();\n-void MaybeReplaceCFAllocator();\n-\n-}  // namespace __asan\n-\n-#endif  // ASAN_MAC_H"}, {"sha": "ba908e322d93769c5304158b09185de912f58752", "filename": "libsanitizer/asan/asan_malloc_linux.cc", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_malloc_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_malloc_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_malloc_linux.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -13,8 +13,9 @@\n //===----------------------------------------------------------------------===//\n \n #include \"sanitizer_common/sanitizer_platform.h\"\n-#if SANITIZER_LINUX\n+#if SANITIZER_FREEBSD || SANITIZER_LINUX\n \n+#include \"sanitizer_common/sanitizer_tls_get_addr.h\"\n #include \"asan_allocator.h\"\n #include \"asan_interceptors.h\"\n #include \"asan_internal.h\"\n@@ -74,7 +75,7 @@ INTERCEPTOR(void*, malloc, uptr size) {\n }\n \n INTERCEPTOR(void*, calloc, uptr nmemb, uptr size) {\n-  if (!asan_inited) {\n+  if (UNLIKELY(!asan_inited)) {\n     // Hack: dlsym calls calloc before REAL(calloc) is retrieved from dlsym.\n     const uptr kCallocPoolSize = 1024;\n     static uptr calloc_memory_for_dlsym[kCallocPoolSize];\n@@ -99,8 +100,12 @@ INTERCEPTOR(void*, memalign, uptr boundary, uptr size) {\n   return asan_memalign(boundary, size, &stack, FROM_MALLOC);\n }\n \n-INTERCEPTOR(void*, __libc_memalign, uptr align, uptr s)\n-  ALIAS(\"memalign\");\n+INTERCEPTOR(void*, __libc_memalign, uptr boundary, uptr size) {\n+  GET_STACK_TRACE_MALLOC;\n+  void *res = asan_memalign(boundary, size, &stack, FROM_MALLOC);\n+  DTLS_on_libc_memalign(res, size * boundary);\n+  return res;\n+}\n \n INTERCEPTOR(uptr, malloc_usable_size, void *ptr) {\n   GET_CURRENT_PC_BP_SP;\n@@ -146,4 +151,4 @@ INTERCEPTOR(void, malloc_stats, void) {\n   __asan_print_accumulated_stats();\n }\n \n-#endif  // SANITIZER_LINUX\n+#endif  // SANITIZER_FREEBSD || SANITIZER_LINUX"}, {"sha": "6a93ce1e8082cf95c575b2abf46faf7ee223a632", "filename": "libsanitizer/asan/asan_malloc_mac.cc", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_malloc_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_malloc_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_malloc_mac.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -22,10 +22,10 @@\n #include \"asan_allocator.h\"\n #include \"asan_interceptors.h\"\n #include \"asan_internal.h\"\n-#include \"asan_mac.h\"\n #include \"asan_report.h\"\n #include \"asan_stack.h\"\n #include \"asan_stats.h\"\n+#include \"sanitizer_common/sanitizer_mac.h\"\n \n // Similar code is used in Google Perftools,\n // http://code.google.com/p/google-perftools.\n@@ -39,7 +39,7 @@ static malloc_zone_t asan_zone;\n \n INTERCEPTOR(malloc_zone_t *, malloc_create_zone,\n                              vm_size_t start_size, unsigned zone_flags) {\n-  if (!asan_inited) __asan_init();\n+  ENSURE_ASAN_INITED();\n   GET_STACK_TRACE_MALLOC;\n   uptr page_size = GetPageSizeCached();\n   uptr allocated_size = RoundUpTo(sizeof(asan_zone), page_size);\n@@ -58,34 +58,34 @@ INTERCEPTOR(malloc_zone_t *, malloc_create_zone,\n }\n \n INTERCEPTOR(malloc_zone_t *, malloc_default_zone, void) {\n-  if (!asan_inited) __asan_init();\n+  ENSURE_ASAN_INITED();\n   return &asan_zone;\n }\n \n INTERCEPTOR(malloc_zone_t *, malloc_default_purgeable_zone, void) {\n   // FIXME: ASan should support purgeable allocations.\n   // https://code.google.com/p/address-sanitizer/issues/detail?id=139\n-  if (!asan_inited) __asan_init();\n+  ENSURE_ASAN_INITED();\n   return &asan_zone;\n }\n \n INTERCEPTOR(void, malloc_make_purgeable, void *ptr) {\n   // FIXME: ASan should support purgeable allocations. Ignoring them is fine\n   // for now.\n-  if (!asan_inited) __asan_init();\n+  ENSURE_ASAN_INITED();\n }\n \n INTERCEPTOR(int, malloc_make_nonpurgeable, void *ptr) {\n   // FIXME: ASan should support purgeable allocations. Ignoring them is fine\n   // for now.\n-  if (!asan_inited) __asan_init();\n+  ENSURE_ASAN_INITED();\n   // Must return 0 if the contents were not purged since the last call to\n   // malloc_make_purgeable().\n   return 0;\n }\n \n INTERCEPTOR(void, malloc_set_zone_name, malloc_zone_t *zone, const char *name) {\n-  if (!asan_inited) __asan_init();\n+  ENSURE_ASAN_INITED();\n   // Allocate |strlen(\"asan-\") + 1 + internal_strlen(name)| bytes.\n   size_t buflen = 6 + (name ? internal_strlen(name) : 0);\n   InternalScopedBuffer<char> new_name(buflen);\n@@ -100,44 +100,44 @@ INTERCEPTOR(void, malloc_set_zone_name, malloc_zone_t *zone, const char *name) {\n }\n \n INTERCEPTOR(void *, malloc, size_t size) {\n-  if (!asan_inited) __asan_init();\n+  ENSURE_ASAN_INITED();\n   GET_STACK_TRACE_MALLOC;\n   void *res = asan_malloc(size, &stack);\n   return res;\n }\n \n INTERCEPTOR(void, free, void *ptr) {\n-  if (!asan_inited) __asan_init();\n+  ENSURE_ASAN_INITED();\n   if (!ptr) return;\n   GET_STACK_TRACE_FREE;\n   asan_free(ptr, &stack, FROM_MALLOC);\n }\n \n INTERCEPTOR(void *, realloc, void *ptr, size_t size) {\n-  if (!asan_inited) __asan_init();\n+  ENSURE_ASAN_INITED();\n   GET_STACK_TRACE_MALLOC;\n   return asan_realloc(ptr, size, &stack);\n }\n \n INTERCEPTOR(void *, calloc, size_t nmemb, size_t size) {\n-  if (!asan_inited) __asan_init();\n+  ENSURE_ASAN_INITED();\n   GET_STACK_TRACE_MALLOC;\n   return asan_calloc(nmemb, size, &stack);\n }\n \n INTERCEPTOR(void *, valloc, size_t size) {\n-  if (!asan_inited) __asan_init();\n+  ENSURE_ASAN_INITED();\n   GET_STACK_TRACE_MALLOC;\n   return asan_memalign(GetPageSizeCached(), size, &stack, FROM_MALLOC);\n }\n \n INTERCEPTOR(size_t, malloc_good_size, size_t size) {\n-  if (!asan_inited) __asan_init();\n+  ENSURE_ASAN_INITED();\n   return asan_zone.introspect->good_size(&asan_zone, size);\n }\n \n INTERCEPTOR(int, posix_memalign, void **memptr, size_t alignment, size_t size) {\n-  if (!asan_inited) __asan_init();\n+  ENSURE_ASAN_INITED();\n   CHECK(memptr);\n   GET_STACK_TRACE_MALLOC;\n   void *result = asan_memalign(alignment, size, &stack, FROM_MALLOC);\n@@ -157,7 +157,7 @@ size_t mz_size(malloc_zone_t* zone, const void* ptr) {\n }\n \n void *mz_malloc(malloc_zone_t *zone, size_t size) {\n-  if (!asan_inited) {\n+  if (UNLIKELY(!asan_inited)) {\n     CHECK(system_malloc_zone);\n     return malloc_zone_malloc(system_malloc_zone, size);\n   }\n@@ -166,7 +166,7 @@ void *mz_malloc(malloc_zone_t *zone, size_t size) {\n }\n \n void *mz_calloc(malloc_zone_t *zone, size_t nmemb, size_t size) {\n-  if (!asan_inited) {\n+  if (UNLIKELY(!asan_inited)) {\n     // Hack: dlsym calls calloc before REAL(calloc) is retrieved from dlsym.\n     const size_t kCallocPoolSize = 1024;\n     static uptr calloc_memory_for_dlsym[kCallocPoolSize];\n@@ -182,7 +182,7 @@ void *mz_calloc(malloc_zone_t *zone, size_t nmemb, size_t size) {\n }\n \n void *mz_valloc(malloc_zone_t *zone, size_t size) {\n-  if (!asan_inited) {\n+  if (UNLIKELY(!asan_inited)) {\n     CHECK(system_malloc_zone);\n     return malloc_zone_valloc(system_malloc_zone, size);\n   }\n@@ -240,7 +240,7 @@ void mz_destroy(malloc_zone_t* zone) {\n #if defined(MAC_OS_X_VERSION_10_6) && \\\n     MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_6\n void *mz_memalign(malloc_zone_t *zone, size_t align, size_t size) {\n-  if (!asan_inited) {\n+  if (UNLIKELY(!asan_inited)) {\n     CHECK(system_malloc_zone);\n     return malloc_zone_memalign(system_malloc_zone, align, size);\n   }"}, {"sha": "8463d5ef2e94ef8a40d21da6d54cbdd3881194a7", "filename": "libsanitizer/asan/asan_malloc_win.cc", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_malloc_win.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_malloc_win.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_malloc_win.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -17,7 +17,7 @@\n #include \"asan_interceptors.h\"\n #include \"asan_internal.h\"\n #include \"asan_stack.h\"\n-#include \"interception/interception.h\"\n+#include \"sanitizer_common/sanitizer_interception.h\"\n \n #include <stddef.h>\n \n@@ -101,6 +101,21 @@ size_t _msize(void *ptr) {\n   return asan_malloc_usable_size(ptr, pc, bp);\n }\n \n+SANITIZER_INTERFACE_ATTRIBUTE\n+void *_expand(void *memblock, size_t size) {\n+  // _expand is used in realloc-like functions to resize the buffer if possible.\n+  // We don't want memory to stand still while resizing buffers, so return 0.\n+  return 0;\n+}\n+\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void *_expand_dbg(void *memblock, size_t size) {\n+  return 0;\n+}\n+\n+// TODO(timurrrr): Might want to add support for _aligned_* allocation\n+// functions to detect a bit more bugs.  Those functions seem to wrap malloc().\n+\n int _CrtDbgReport(int, const char*, int,\n                   const char*, const char*, ...) {\n   ShowStatsAndAbort();"}, {"sha": "86e391f5968d84498caf0b9cbd29318474ff8fa7", "filename": "libsanitizer/asan/asan_mapping.h", "status": "modified", "additions": 52, "deletions": 25, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_mapping.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_mapping.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_mapping.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -41,54 +41,81 @@\n // || `[0x00007fff8000, 0x00008fff6fff]` || LowShadow  ||\n // || `[0x000000000000, 0x00007fff7fff]` || LowMem     ||\n //\n-// Default Linux/i386 mapping:\n+// Default Linux/i386 mapping on x86_64 machine:\n // || `[0x40000000, 0xffffffff]` || HighMem    ||\n // || `[0x28000000, 0x3fffffff]` || HighShadow ||\n // || `[0x24000000, 0x27ffffff]` || ShadowGap  ||\n // || `[0x20000000, 0x23ffffff]` || LowShadow  ||\n // || `[0x00000000, 0x1fffffff]` || LowMem     ||\n //\n+// Default Linux/i386 mapping on i386 machine\n+// (addresses starting with 0xc0000000 are reserved\n+// for kernel and thus not sanitized):\n+// || `[0x38000000, 0xbfffffff]` || HighMem    ||\n+// || `[0x27000000, 0x37ffffff]` || HighShadow ||\n+// || `[0x24000000, 0x26ffffff]` || ShadowGap  ||\n+// || `[0x20000000, 0x23ffffff]` || LowShadow  ||\n+// || `[0x00000000, 0x1fffffff]` || LowMem     ||\n+//\n // Default Linux/MIPS mapping:\n // || `[0x2aaa8000, 0xffffffff]` || HighMem    ||\n // || `[0x0fffd000, 0x2aaa7fff]` || HighShadow ||\n // || `[0x0bffd000, 0x0fffcfff]` || ShadowGap  ||\n // || `[0x0aaa8000, 0x0bffcfff]` || LowShadow  ||\n // || `[0x00000000, 0x0aaa7fff]` || LowMem     ||\n+//\n+// Shadow mapping on FreeBSD/x86-64 with SHADOW_OFFSET == 0x400000000000:\n+// || `[0x500000000000, 0x7fffffffffff]` || HighMem    ||\n+// || `[0x4a0000000000, 0x4fffffffffff]` || HighShadow ||\n+// || `[0x480000000000, 0x49ffffffffff]` || ShadowGap  ||\n+// || `[0x400000000000, 0x47ffffffffff]` || LowShadow  ||\n+// || `[0x000000000000, 0x3fffffffffff]` || LowMem     ||\n+//\n+// Shadow mapping on FreeBSD/i386 with SHADOW_OFFSET == 0x40000000:\n+// || `[0x60000000, 0xffffffff]` || HighMem    ||\n+// || `[0x4c000000, 0x5fffffff]` || HighShadow ||\n+// || `[0x48000000, 0x4bffffff]` || ShadowGap  ||\n+// || `[0x40000000, 0x47ffffff]` || LowShadow  ||\n+// || `[0x00000000, 0x3fffffff]` || LowMem     ||\n \n static const u64 kDefaultShadowScale = 3;\n-static const u64 kDefaultShadowOffset32 = 1ULL << 29;\n+static const u64 kDefaultShadowOffset32 = 1ULL << 29;  // 0x20000000\n+static const u64 kIosShadowOffset32 = 1ULL << 30;  // 0x40000000\n static const u64 kDefaultShadowOffset64 = 1ULL << 44;\n static const u64 kDefaultShort64bitShadowOffset = 0x7FFF8000;  // < 2G.\n-static const u64 kPPC64_ShadowOffset64 = 1ULL << 41;\n+static const u64 kAArch64_ShadowOffset64 = 1ULL << 36;\n static const u64 kMIPS32_ShadowOffset32 = 0x0aaa8000;\n+static const u64 kFreeBSD_ShadowOffset32 = 1ULL << 30;  // 0x40000000\n+static const u64 kFreeBSD_ShadowOffset64 = 1ULL << 46;  // 0x400000000000\n \n-#if ASAN_FLEXIBLE_MAPPING_AND_OFFSET == 1\n-extern \"C\" SANITIZER_INTERFACE_ATTRIBUTE uptr __asan_mapping_scale;\n-extern \"C\" SANITIZER_INTERFACE_ATTRIBUTE uptr __asan_mapping_offset;\n-# define SHADOW_SCALE (__asan_mapping_scale)\n-# define SHADOW_OFFSET (__asan_mapping_offset)\n+#define SHADOW_SCALE kDefaultShadowScale\n+#if SANITIZER_ANDROID\n+# define SHADOW_OFFSET (0)\n #else\n-# define SHADOW_SCALE kDefaultShadowScale\n-# if SANITIZER_ANDROID\n-#  define SHADOW_OFFSET (0)\n+# if SANITIZER_WORDSIZE == 32\n+#  if defined(__mips__)\n+#    define SHADOW_OFFSET kMIPS32_ShadowOffset32\n+#  elif SANITIZER_FREEBSD\n+#    define SHADOW_OFFSET kFreeBSD_ShadowOffset32\n+#  else\n+#    if SANITIZER_IOS\n+#      define SHADOW_OFFSET kIosShadowOffset32\n+#    else\n+#      define SHADOW_OFFSET kDefaultShadowOffset32\n+#    endif\n+#  endif\n # else\n-#  if SANITIZER_WORDSIZE == 32\n-#   if defined(__mips__)\n-#     define SHADOW_OFFSET kMIPS32_ShadowOffset32\n-#   else\n-#     define SHADOW_OFFSET kDefaultShadowOffset32\n-#   endif\n+#  if defined(__aarch64__)\n+#    define SHADOW_OFFSET kAArch64_ShadowOffset64\n+#  elif SANITIZER_FREEBSD\n+#    define SHADOW_OFFSET kFreeBSD_ShadowOffset64\n+#  elif SANITIZER_MAC\n+#   define SHADOW_OFFSET kDefaultShadowOffset64\n #  else\n-#   if defined(__powerpc64__)\n-#    define SHADOW_OFFSET kPPC64_ShadowOffset64\n-#   elif SANITIZER_MAC\n-#    define SHADOW_OFFSET kDefaultShadowOffset64\n-#   else\n-#    define SHADOW_OFFSET kDefaultShort64bitShadowOffset\n-#   endif\n+#   define SHADOW_OFFSET kDefaultShort64bitShadowOffset\n #  endif\n # endif\n-#endif  // ASAN_FLEXIBLE_MAPPING_AND_OFFSET\n+#endif\n \n #define SHADOW_GRANULARITY (1ULL << SHADOW_SCALE)\n #define MEM_TO_SHADOW(mem) (((mem) >> SHADOW_SCALE) + (SHADOW_OFFSET))"}, {"sha": "a1ab2cd8c39e6fed1a470a5a5a30c8e54a2130f2", "filename": "libsanitizer/asan/asan_new_delete.cc", "status": "modified", "additions": 25, "deletions": 18, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_new_delete.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_new_delete.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_new_delete.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -14,20 +14,14 @@\n #include \"asan_internal.h\"\n #include \"asan_stack.h\"\n \n-#include <stddef.h>\n+#include \"sanitizer_common/sanitizer_interception.h\"\n \n-namespace __asan {\n-// This function is a no-op. We need it to make sure that object file\n-// with our replacements will actually be loaded from static ASan\n-// run-time library at link-time.\n-void ReplaceOperatorsNewAndDelete() { }\n-}\n+#include <stddef.h>\n \n using namespace __asan;  // NOLINT\n \n-// On Android new() goes through malloc interceptors.\n-// See also https://code.google.com/p/address-sanitizer/issues/detail?id=131.\n-#if !SANITIZER_ANDROID\n+// This code has issues on OSX.\n+// See https://code.google.com/p/address-sanitizer/issues/detail?id=131.\n \n // Fake std::nothrow_t to avoid including <new>.\n namespace std {\n@@ -46,6 +40,15 @@ struct nothrow_t {};\n // To make sure that C++ allocation/deallocation operators are overridden on\n // OS X we need to intercept them using their mangled names.\n #if !SANITIZER_MAC\n+// FreeBSD prior v9.2 have wrong definition of 'size_t'.\n+// http://svnweb.freebsd.org/base?view=revision&revision=232261\n+#if SANITIZER_FREEBSD && SANITIZER_WORDSIZE == 32\n+#include <sys/param.h>\n+#if __FreeBSD_version <= 902001  // v9.2\n+#define size_t unsigned\n+#endif  // __FreeBSD_version\n+#endif  // SANITIZER_FREEBSD && SANITIZER_WORDSIZE == 32\n+\n INTERCEPTOR_ATTRIBUTE\n void *operator new(size_t size) { OPERATOR_NEW_BODY(FROM_NEW); }\n INTERCEPTOR_ATTRIBUTE\n@@ -78,15 +81,21 @@ INTERCEPTOR(void *, _ZnamRKSt9nothrow_t, size_t size, std::nothrow_t const&) {\n \n #if !SANITIZER_MAC\n INTERCEPTOR_ATTRIBUTE\n-void operator delete(void *ptr) { OPERATOR_DELETE_BODY(FROM_NEW); }\n+void operator delete(void *ptr) throw() {\n+  OPERATOR_DELETE_BODY(FROM_NEW);\n+}\n INTERCEPTOR_ATTRIBUTE\n-void operator delete[](void *ptr) { OPERATOR_DELETE_BODY(FROM_NEW_BR); }\n+void operator delete[](void *ptr) throw() {\n+  OPERATOR_DELETE_BODY(FROM_NEW_BR);\n+}\n INTERCEPTOR_ATTRIBUTE\n-void operator delete(void *ptr, std::nothrow_t const&)\n-{ OPERATOR_DELETE_BODY(FROM_NEW); }\n+void operator delete(void *ptr, std::nothrow_t const&) {\n+  OPERATOR_DELETE_BODY(FROM_NEW);\n+}\n INTERCEPTOR_ATTRIBUTE\n-void operator delete[](void *ptr, std::nothrow_t const&)\n-{ OPERATOR_DELETE_BODY(FROM_NEW_BR); }\n+void operator delete[](void *ptr, std::nothrow_t const&) {\n+  OPERATOR_DELETE_BODY(FROM_NEW_BR);\n+}\n \n #else  // SANITIZER_MAC\n INTERCEPTOR(void, _ZdlPv, void *ptr) {\n@@ -102,5 +111,3 @@ INTERCEPTOR(void, _ZdaPvRKSt9nothrow_t, void *ptr, std::nothrow_t const&) {\n   OPERATOR_DELETE_BODY(FROM_NEW_BR);\n }\n #endif\n-\n-#endif"}, {"sha": "a532c5c4388e04c298d9f17adb4667e212a5a197", "filename": "libsanitizer/asan/asan_poisoning.cc", "status": "modified", "additions": 77, "deletions": 25, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_poisoning.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_poisoning.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_poisoning.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -11,6 +11,8 @@\n //===----------------------------------------------------------------------===//\n \n #include \"asan_poisoning.h\"\n+#include \"asan_report.h\"\n+#include \"asan_stack.h\"\n #include \"sanitizer_common/sanitizer_libc.h\"\n #include \"sanitizer_common/sanitizer_flags.h\"\n \n@@ -48,6 +50,15 @@ struct ShadowSegmentEndpoint {\n   }\n };\n \n+void FlushUnneededASanShadowMemory(uptr p, uptr size) {\n+    // Since asan's mapping is compacting, the shadow chunk may be\n+    // not page-aligned, so we only flush the page-aligned portion.\n+    uptr page_size = GetPageSizeCached();\n+    uptr shadow_beg = RoundUpTo(MemToShadow(p), page_size);\n+    uptr shadow_end = RoundDownTo(MemToShadow(p + size), page_size);\n+    FlushUnneededShadowMemory(shadow_beg, shadow_end - shadow_beg);\n+}\n+\n }  // namespace __asan\n \n // ---------------------- Interface ---------------- {{{1\n@@ -67,10 +78,8 @@ void __asan_poison_memory_region(void const volatile *addr, uptr size) {\n   if (!flags()->allow_user_poisoning || size == 0) return;\n   uptr beg_addr = (uptr)addr;\n   uptr end_addr = beg_addr + size;\n-  if (common_flags()->verbosity >= 1) {\n-    Printf(\"Trying to poison memory region [%p, %p)\\n\",\n-           (void*)beg_addr, (void*)end_addr);\n-  }\n+  VPrintf(1, \"Trying to poison memory region [%p, %p)\\n\", (void *)beg_addr,\n+          (void *)end_addr);\n   ShadowSegmentEndpoint beg(beg_addr);\n   ShadowSegmentEndpoint end(end_addr);\n   if (beg.chunk == end.chunk) {\n@@ -109,10 +118,8 @@ void __asan_unpoison_memory_region(void const volatile *addr, uptr size) {\n   if (!flags()->allow_user_poisoning || size == 0) return;\n   uptr beg_addr = (uptr)addr;\n   uptr end_addr = beg_addr + size;\n-  if (common_flags()->verbosity >= 1) {\n-    Printf(\"Trying to unpoison memory region [%p, %p)\\n\",\n-           (void*)beg_addr, (void*)end_addr);\n-  }\n+  VPrintf(1, \"Trying to unpoison memory region [%p, %p)\\n\", (void *)beg_addr,\n+          (void *)end_addr);\n   ShadowSegmentEndpoint beg(beg_addr);\n   ShadowSegmentEndpoint end(end_addr);\n   if (beg.chunk == end.chunk) {\n@@ -137,7 +144,7 @@ void __asan_unpoison_memory_region(void const volatile *addr, uptr size) {\n   }\n }\n \n-bool __asan_address_is_poisoned(void const volatile *addr) {\n+int __asan_address_is_poisoned(void const volatile *addr) {\n   return __asan::AddressIsPoisoned((uptr)addr);\n }\n \n@@ -146,6 +153,7 @@ uptr __asan_region_is_poisoned(uptr beg, uptr size) {\n   uptr end = beg + size;\n   if (!AddrIsInMem(beg)) return beg;\n   if (!AddrIsInMem(end)) return end;\n+  CHECK_LT(beg, end);\n   uptr aligned_b = RoundUpTo(beg, SHADOW_GRANULARITY);\n   uptr aligned_e = RoundDownTo(end, SHADOW_GRANULARITY);\n   uptr shadow_beg = MemToShadow(aligned_b);\n@@ -243,48 +251,53 @@ static void PoisonAlignedStackMemory(uptr addr, uptr size, bool do_poison) {\n }\n \n void __asan_poison_stack_memory(uptr addr, uptr size) {\n-  if (common_flags()->verbosity > 0)\n-    Report(\"poisoning: %p %zx\\n\", (void*)addr, size);\n+  VReport(1, \"poisoning: %p %zx\\n\", (void *)addr, size);\n   PoisonAlignedStackMemory(addr, size, true);\n }\n \n void __asan_unpoison_stack_memory(uptr addr, uptr size) {\n-  if (common_flags()->verbosity > 0)\n-    Report(\"unpoisoning: %p %zx\\n\", (void*)addr, size);\n+  VReport(1, \"unpoisoning: %p %zx\\n\", (void *)addr, size);\n   PoisonAlignedStackMemory(addr, size, false);\n }\n \n void __sanitizer_annotate_contiguous_container(const void *beg_p,\n                                                const void *end_p,\n                                                const void *old_mid_p,\n                                                const void *new_mid_p) {\n-  if (common_flags()->verbosity >= 2)\n-    Printf(\"contiguous_container: %p %p %p %p\\n\", beg_p, end_p, old_mid_p,\n-           new_mid_p);\n+  if (!flags()->detect_container_overflow) return;\n+  VPrintf(2, \"contiguous_container: %p %p %p %p\\n\", beg_p, end_p, old_mid_p,\n+          new_mid_p);\n   uptr beg = reinterpret_cast<uptr>(beg_p);\n-  uptr end= reinterpret_cast<uptr>(end_p);\n+  uptr end = reinterpret_cast<uptr>(end_p);\n   uptr old_mid = reinterpret_cast<uptr>(old_mid_p);\n   uptr new_mid = reinterpret_cast<uptr>(new_mid_p);\n   uptr granularity = SHADOW_GRANULARITY;\n-  CHECK(beg <= old_mid && beg <= new_mid && old_mid <= end && new_mid <= end &&\n-        IsAligned(beg, granularity));\n+  if (!(beg <= old_mid && beg <= new_mid && old_mid <= end && new_mid <= end &&\n+        IsAligned(beg, granularity))) {\n+    GET_STACK_TRACE_FATAL_HERE;\n+    ReportBadParamsToAnnotateContiguousContainer(beg, end, old_mid, new_mid,\n+                                                 &stack);\n+  }\n   CHECK_LE(end - beg,\n            FIRST_32_SECOND_64(1UL << 30, 1UL << 34)); // Sanity check.\n \n   uptr a = RoundDownTo(Min(old_mid, new_mid), granularity);\n   uptr c = RoundUpTo(Max(old_mid, new_mid), granularity);\n   uptr d1 = RoundDownTo(old_mid, granularity);\n-  uptr d2 = RoundUpTo(old_mid, granularity);\n+  // uptr d2 = RoundUpTo(old_mid, granularity);\n   // Currently we should be in this state:\n   // [a, d1) is good, [d2, c) is bad, [d1, d2) is partially good.\n   // Make a quick sanity check that we are indeed in this state.\n-  if (d1 != d2)\n-    CHECK_EQ(*(u8*)MemToShadow(d1), old_mid - d1);\n+  //\n+  // FIXME: Two of these three checks are disabled until we fix\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=258.\n+  // if (d1 != d2)\n+  //  CHECK_EQ(*(u8*)MemToShadow(d1), old_mid - d1);\n   if (a + granularity <= d1)\n     CHECK_EQ(*(u8*)MemToShadow(a), 0);\n-  if (d2 + granularity <= c && c <= end)\n-    CHECK_EQ(*(u8 *)MemToShadow(c - granularity),\n-             kAsanContiguousContainerOOBMagic);\n+  // if (d2 + granularity <= c && c <= end)\n+  //   CHECK_EQ(*(u8 *)MemToShadow(c - granularity),\n+  //            kAsanContiguousContainerOOBMagic);\n \n   uptr b1 = RoundDownTo(new_mid, granularity);\n   uptr b2 = RoundUpTo(new_mid, granularity);\n@@ -297,3 +310,42 @@ void __sanitizer_annotate_contiguous_container(const void *beg_p,\n     *(u8*)MemToShadow(b1) = static_cast<u8>(new_mid - b1);\n   }\n }\n+\n+int __sanitizer_verify_contiguous_container(const void *beg_p,\n+                                            const void *mid_p,\n+                                            const void *end_p) {\n+  if (!flags()->detect_container_overflow) return 1;\n+  uptr beg = reinterpret_cast<uptr>(beg_p);\n+  uptr end = reinterpret_cast<uptr>(end_p);\n+  uptr mid = reinterpret_cast<uptr>(mid_p);\n+  CHECK_LE(beg, mid);\n+  CHECK_LE(mid, end);\n+  // Check some bytes starting from beg, some bytes around mid, and some bytes\n+  // ending with end.\n+  uptr kMaxRangeToCheck = 32;\n+  uptr r1_beg = beg;\n+  uptr r1_end = Min(end + kMaxRangeToCheck, mid);\n+  uptr r2_beg = Max(beg, mid - kMaxRangeToCheck);\n+  uptr r2_end = Min(end, mid + kMaxRangeToCheck);\n+  uptr r3_beg = Max(end - kMaxRangeToCheck, mid);\n+  uptr r3_end = end;\n+  for (uptr i = r1_beg; i < r1_end; i++)\n+    if (AddressIsPoisoned(i))\n+      return 0;\n+  for (uptr i = r2_beg; i < mid; i++)\n+    if (AddressIsPoisoned(i))\n+      return 0;\n+  for (uptr i = mid; i < r2_end; i++)\n+    if (!AddressIsPoisoned(i))\n+      return 0;\n+  for (uptr i = r3_beg; i < r3_end; i++)\n+    if (!AddressIsPoisoned(i))\n+      return 0;\n+  return 1;\n+}\n+// --- Implementation of LSan-specific functions --- {{{1\n+namespace __lsan {\n+bool WordIsPoisoned(uptr addr) {\n+  return (__asan_region_is_poisoned(addr, sizeof(uptr)) != 0);\n+}\n+}"}, {"sha": "326d9ba1b67be3477ecc547b2100d8fa1385d2c5", "filename": "libsanitizer/asan/asan_poisoning.h", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_poisoning.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_poisoning.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_poisoning.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -13,6 +13,7 @@\n #include \"asan_interceptors.h\"\n #include \"asan_internal.h\"\n #include \"asan_mapping.h\"\n+#include \"sanitizer_common/sanitizer_flags.h\"\n \n namespace __asan {\n \n@@ -32,10 +33,35 @@ void PoisonShadowPartialRightRedzone(uptr addr,\n ALWAYS_INLINE void FastPoisonShadow(uptr aligned_beg, uptr aligned_size,\n                                     u8 value) {\n   DCHECK(flags()->poison_heap);\n+  uptr PageSize = GetPageSizeCached();\n   uptr shadow_beg = MEM_TO_SHADOW(aligned_beg);\n   uptr shadow_end = MEM_TO_SHADOW(\n       aligned_beg + aligned_size - SHADOW_GRANULARITY) + 1;\n-  REAL(memset)((void*)shadow_beg, value, shadow_end - shadow_beg);\n+  // FIXME: Page states are different on Windows, so using the same interface\n+  // for mapping shadow and zeroing out pages doesn't \"just work\", so we should\n+  // probably provide higher-level interface for these operations.\n+  // For now, just memset on Windows.\n+  if (value ||\n+      SANITIZER_WINDOWS == 1 ||\n+      shadow_end - shadow_beg < common_flags()->clear_shadow_mmap_threshold) {\n+    REAL(memset)((void*)shadow_beg, value, shadow_end - shadow_beg);\n+  } else {\n+    uptr page_beg = RoundUpTo(shadow_beg, PageSize);\n+    uptr page_end = RoundDownTo(shadow_end, PageSize);\n+\n+    if (page_beg >= page_end) {\n+      REAL(memset)((void *)shadow_beg, 0, shadow_end - shadow_beg);\n+    } else {\n+      if (page_beg != shadow_beg) {\n+        REAL(memset)((void *)shadow_beg, 0, page_beg - shadow_beg);\n+      }\n+      if (page_end != shadow_end) {\n+        REAL(memset)((void *)page_end, 0, shadow_end - page_end);\n+      }\n+      void *res = MmapFixedNoReserve(page_beg, page_end - page_beg);\n+      CHECK_EQ(page_beg, res);\n+    }\n+  }\n }\n \n ALWAYS_INLINE void FastPoisonShadowPartialRightRedzone(\n@@ -55,4 +81,8 @@ ALWAYS_INLINE void FastPoisonShadowPartialRightRedzone(\n   }\n }\n \n+// Calls __sanitizer::FlushUnneededShadowMemory() on\n+// [MemToShadow(p), MemToShadow(p+size)] with proper rounding.\n+void FlushUnneededASanShadowMemory(uptr p, uptr size);\n+\n }  // namespace __asan"}, {"sha": "8f3798a2e5953b8e21044dc70c95b7810c26d21a", "filename": "libsanitizer/asan/asan_posix.cc", "status": "modified", "additions": 16, "deletions": 59, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_posix.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_posix.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_posix.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -11,7 +11,7 @@\n //===----------------------------------------------------------------------===//\n \n #include \"sanitizer_common/sanitizer_platform.h\"\n-#if SANITIZER_LINUX || SANITIZER_MAC\n+#if SANITIZER_POSIX\n \n #include \"asan_internal.h\"\n #include \"asan_interceptors.h\"\n@@ -28,70 +28,27 @@\n #include <sys/resource.h>\n #include <unistd.h>\n \n-static const uptr kAltStackSize = SIGSTKSZ * 4;  // SIGSTKSZ is not enough.\n-\n namespace __asan {\n \n-static void MaybeInstallSigaction(int signum,\n-                                  void (*handler)(int, siginfo_t *, void *)) {\n-  if (!AsanInterceptsSignal(signum))\n-    return;\n-  struct sigaction sigact;\n-  REAL(memset)(&sigact, 0, sizeof(sigact));\n-  sigact.sa_sigaction = handler;\n-  sigact.sa_flags = SA_SIGINFO;\n-  if (flags()->use_sigaltstack) sigact.sa_flags |= SA_ONSTACK;\n-  CHECK_EQ(0, REAL(sigaction)(signum, &sigact, 0));\n-  if (common_flags()->verbosity >= 1) {\n-    Report(\"Installed the sigaction for signal %d\\n\", signum);\n-  }\n-}\n-\n-static void     ASAN_OnSIGSEGV(int, siginfo_t *siginfo, void *context) {\n-  uptr addr = (uptr)siginfo->si_addr;\n+void AsanOnSIGSEGV(int, void *siginfo, void *context) {\n+  uptr addr = (uptr)((siginfo_t*)siginfo)->si_addr;\n+  int code = (int)((siginfo_t*)siginfo)->si_code;\n   // Write the first message using the bullet-proof write.\n   if (13 != internal_write(2, \"ASAN:SIGSEGV\\n\", 13)) Die();\n   uptr pc, sp, bp;\n   GetPcSpBp(context, &pc, &sp, &bp);\n-  ReportSIGSEGV(pc, sp, bp, addr);\n-}\n-\n-void SetAlternateSignalStack() {\n-  stack_t altstack, oldstack;\n-  CHECK_EQ(0, sigaltstack(0, &oldstack));\n-  // If the alternate stack is already in place, do nothing.\n-  if ((oldstack.ss_flags & SS_DISABLE) == 0) return;\n-  // TODO(glider): the mapped stack should have the MAP_STACK flag in the\n-  // future. It is not required by man 2 sigaltstack now (they're using\n-  // malloc()).\n-  void* base = MmapOrDie(kAltStackSize, __FUNCTION__);\n-  altstack.ss_sp = base;\n-  altstack.ss_flags = 0;\n-  altstack.ss_size = kAltStackSize;\n-  CHECK_EQ(0, sigaltstack(&altstack, 0));\n-  if (common_flags()->verbosity > 0) {\n-    Report(\"Alternative stack for T%d set: [%p,%p)\\n\",\n-           GetCurrentTidOrInvalid(),\n-           altstack.ss_sp, (char*)altstack.ss_sp + altstack.ss_size);\n-  }\n-}\n-\n-void UnsetAlternateSignalStack() {\n-  stack_t altstack, oldstack;\n-  altstack.ss_sp = 0;\n-  altstack.ss_flags = SS_DISABLE;\n-  altstack.ss_size = 0;\n-  CHECK_EQ(0, sigaltstack(&altstack, &oldstack));\n-  UnmapOrDie(oldstack.ss_sp, oldstack.ss_size);\n-}\n \n-void InstallSignalHandlers() {\n-  // Set the alternate signal stack for the main thread.\n-  // This will cause SetAlternateSignalStack to be called twice, but the stack\n-  // will be actually set only once.\n-  if (flags()->use_sigaltstack) SetAlternateSignalStack();\n-  MaybeInstallSigaction(SIGSEGV, ASAN_OnSIGSEGV);\n-  MaybeInstallSigaction(SIGBUS, ASAN_OnSIGSEGV);\n+  // Access at a reasonable offset above SP, or slightly below it (to account\n+  // for x86_64 redzone, ARM push of multiple registers, etc) is probably a\n+  // stack overflow.\n+  // We also check si_code to filter out SEGV caused by something else other\n+  // then hitting the guard page or unmapped memory, like, for example,\n+  // unaligned memory access.\n+  if (addr + 128 > sp && addr < sp + 0xFFFF &&\n+      (code == si_SEGV_MAPERR || code == si_SEGV_ACCERR))\n+    ReportStackOverflow(pc, sp, bp, context, addr);\n+  else\n+    ReportSIGSEGV(pc, sp, bp, context, addr);\n }\n \n // ---------------------- TSD ---------------- {{{1\n@@ -125,4 +82,4 @@ void PlatformTSDDtor(void *tsd) {\n }\n }  // namespace __asan\n \n-#endif  // SANITIZER_LINUX || SANITIZER_MAC\n+#endif  // SANITIZER_POSIX"}, {"sha": "d0a89b9677e0879fc69a91dd65c4b7f0343a8aa6", "filename": "libsanitizer/asan/asan_report.cc", "status": "modified", "additions": 223, "deletions": 105, "changes": 328, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_report.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_report.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_report.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -43,11 +43,9 @@ void AppendToErrorMessageBuffer(const char *buffer) {\n }\n \n // ---------------------- Decorator ------------------------------ {{{1\n-class Decorator: private __sanitizer::AnsiColorDecorator {\n+class Decorator: public __sanitizer::SanitizerCommonDecorator {\n  public:\n-  Decorator() : __sanitizer::AnsiColorDecorator(PrintsToTtyCached()) { }\n-  const char *Warning()    { return Red(); }\n-  const char *EndWarning() { return Default(); }\n+  Decorator() : SanitizerCommonDecorator() { }\n   const char *Access()     { return Blue(); }\n   const char *EndAccess()  { return Default(); }\n   const char *Location()   { return Green(); }\n@@ -89,68 +87,77 @@ class Decorator: private __sanitizer::AnsiColorDecorator {\n \n // ---------------------- Helper functions ----------------------- {{{1\n \n-static void PrintShadowByte(const char *before, u8 byte,\n-                            const char *after = \"\\n\") {\n+static void PrintShadowByte(InternalScopedString *str, const char *before,\n+                            u8 byte, const char *after = \"\\n\") {\n   Decorator d;\n-  Printf(\"%s%s%x%x%s%s\", before,\n-         d.ShadowByte(byte), byte >> 4, byte & 15, d.EndShadowByte(), after);\n+  str->append(\"%s%s%x%x%s%s\", before, d.ShadowByte(byte), byte >> 4, byte & 15,\n+              d.EndShadowByte(), after);\n }\n \n-static void PrintShadowBytes(const char *before, u8 *bytes,\n-                             u8 *guilty, uptr n) {\n+static void PrintShadowBytes(InternalScopedString *str, const char *before,\n+                             u8 *bytes, u8 *guilty, uptr n) {\n   Decorator d;\n-  if (before)\n-    Printf(\"%s%p:\", before, bytes);\n+  if (before) str->append(\"%s%p:\", before, bytes);\n   for (uptr i = 0; i < n; i++) {\n     u8 *p = bytes + i;\n-    const char *before = p == guilty ? \"[\" :\n-        (p - 1 == guilty && i != 0) ? \"\" : \" \";\n+    const char *before =\n+        p == guilty ? \"[\" : (p - 1 == guilty && i != 0) ? \"\" : \" \";\n     const char *after = p == guilty ? \"]\" : \"\";\n-    PrintShadowByte(before, *p, after);\n+    PrintShadowByte(str, before, *p, after);\n   }\n-  Printf(\"\\n\");\n-}\n-\n-static void PrintLegend() {\n-  Printf(\"Shadow byte legend (one shadow byte represents %d \"\n-         \"application bytes):\\n\", (int)SHADOW_GRANULARITY);\n-  PrintShadowByte(\"  Addressable:           \", 0);\n-  Printf(\"  Partially addressable: \");\n-  for (u8 i = 1; i < SHADOW_GRANULARITY; i++)\n-    PrintShadowByte(\"\", i, \" \");\n-  Printf(\"\\n\");\n-  PrintShadowByte(\"  Heap left redzone:       \", kAsanHeapLeftRedzoneMagic);\n-  PrintShadowByte(\"  Heap right redzone:      \", kAsanHeapRightRedzoneMagic);\n-  PrintShadowByte(\"  Freed heap region:       \", kAsanHeapFreeMagic);\n-  PrintShadowByte(\"  Stack left redzone:      \", kAsanStackLeftRedzoneMagic);\n-  PrintShadowByte(\"  Stack mid redzone:       \", kAsanStackMidRedzoneMagic);\n-  PrintShadowByte(\"  Stack right redzone:     \", kAsanStackRightRedzoneMagic);\n-  PrintShadowByte(\"  Stack partial redzone:   \", kAsanStackPartialRedzoneMagic);\n-  PrintShadowByte(\"  Stack after return:      \", kAsanStackAfterReturnMagic);\n-  PrintShadowByte(\"  Stack use after scope:   \", kAsanStackUseAfterScopeMagic);\n-  PrintShadowByte(\"  Global redzone:          \", kAsanGlobalRedzoneMagic);\n-  PrintShadowByte(\"  Global init order:       \", kAsanInitializationOrderMagic);\n-  PrintShadowByte(\"  Poisoned by user:        \", kAsanUserPoisonedMemoryMagic);\n-  PrintShadowByte(\"  Contiguous container OOB:\",\n+  str->append(\"\\n\");\n+}\n+\n+static void PrintLegend(InternalScopedString *str) {\n+  str->append(\n+      \"Shadow byte legend (one shadow byte represents %d \"\n+      \"application bytes):\\n\",\n+      (int)SHADOW_GRANULARITY);\n+  PrintShadowByte(str, \"  Addressable:           \", 0);\n+  str->append(\"  Partially addressable: \");\n+  for (u8 i = 1; i < SHADOW_GRANULARITY; i++) PrintShadowByte(str, \"\", i, \" \");\n+  str->append(\"\\n\");\n+  PrintShadowByte(str, \"  Heap left redzone:       \",\n+                  kAsanHeapLeftRedzoneMagic);\n+  PrintShadowByte(str, \"  Heap right redzone:      \",\n+                  kAsanHeapRightRedzoneMagic);\n+  PrintShadowByte(str, \"  Freed heap region:       \", kAsanHeapFreeMagic);\n+  PrintShadowByte(str, \"  Stack left redzone:      \",\n+                  kAsanStackLeftRedzoneMagic);\n+  PrintShadowByte(str, \"  Stack mid redzone:       \",\n+                  kAsanStackMidRedzoneMagic);\n+  PrintShadowByte(str, \"  Stack right redzone:     \",\n+                  kAsanStackRightRedzoneMagic);\n+  PrintShadowByte(str, \"  Stack partial redzone:   \",\n+                  kAsanStackPartialRedzoneMagic);\n+  PrintShadowByte(str, \"  Stack after return:      \",\n+                  kAsanStackAfterReturnMagic);\n+  PrintShadowByte(str, \"  Stack use after scope:   \",\n+                  kAsanStackUseAfterScopeMagic);\n+  PrintShadowByte(str, \"  Global redzone:          \", kAsanGlobalRedzoneMagic);\n+  PrintShadowByte(str, \"  Global init order:       \",\n+                  kAsanInitializationOrderMagic);\n+  PrintShadowByte(str, \"  Poisoned by user:        \",\n+                  kAsanUserPoisonedMemoryMagic);\n+  PrintShadowByte(str, \"  Container overflow:      \",\n                   kAsanContiguousContainerOOBMagic);\n-  PrintShadowByte(\"  ASan internal:           \", kAsanInternalHeapMagic);\n+  PrintShadowByte(str, \"  ASan internal:           \", kAsanInternalHeapMagic);\n }\n \n static void PrintShadowMemoryForAddress(uptr addr) {\n-  if (!AddrIsInMem(addr))\n-    return;\n+  if (!AddrIsInMem(addr)) return;\n   uptr shadow_addr = MemToShadow(addr);\n   const uptr n_bytes_per_row = 16;\n   uptr aligned_shadow = shadow_addr & ~(n_bytes_per_row - 1);\n-  Printf(\"Shadow bytes around the buggy address:\\n\");\n+  InternalScopedString str(4096 * 8);\n+  str.append(\"Shadow bytes around the buggy address:\\n\");\n   for (int i = -5; i <= 5; i++) {\n     const char *prefix = (i == 0) ? \"=>\" : \"  \";\n-    PrintShadowBytes(prefix,\n-                     (u8*)(aligned_shadow + i * n_bytes_per_row),\n-                     (u8*)shadow_addr, n_bytes_per_row);\n+    PrintShadowBytes(&str, prefix, (u8 *)(aligned_shadow + i * n_bytes_per_row),\n+                     (u8 *)shadow_addr, n_bytes_per_row);\n   }\n-  if (flags()->print_legend)\n-    PrintLegend();\n+  if (flags()->print_legend) PrintLegend(&str);\n+  Printf(\"%s\", str.data());\n }\n \n static void PrintZoneForPointer(uptr ptr, uptr zone_ptr,\n@@ -182,44 +189,52 @@ static bool IsASCII(unsigned char c) {\n static const char *MaybeDemangleGlobalName(const char *name) {\n   // We can spoil names of globals with C linkage, so use an heuristic\n   // approach to check if the name should be demangled.\n-  return (name[0] == '_' && name[1] == 'Z')\n-             ? Symbolizer::Get()->Demangle(name)\n-             : name;\n+  bool should_demangle = false;\n+  if (name[0] == '_' && name[1] == 'Z')\n+    should_demangle = true;\n+  else if (SANITIZER_WINDOWS && name[0] == '\\01' && name[1] == '?')\n+    should_demangle = true;\n+\n+  return should_demangle ? Symbolizer::Get()->Demangle(name) : name;\n }\n \n // Check if the global is a zero-terminated ASCII string. If so, print it.\n-static void PrintGlobalNameIfASCII(const __asan_global &g) {\n+static void PrintGlobalNameIfASCII(InternalScopedString *str,\n+                                   const __asan_global &g) {\n   for (uptr p = g.beg; p < g.beg + g.size - 1; p++) {\n     unsigned char c = *(unsigned char*)p;\n     if (c == '\\0' || !IsASCII(c)) return;\n   }\n   if (*(char*)(g.beg + g.size - 1) != '\\0') return;\n-  Printf(\"  '%s' is ascii string '%s'\\n\",\n-         MaybeDemangleGlobalName(g.name), (char*)g.beg);\n+  str->append(\"  '%s' is ascii string '%s'\\n\", MaybeDemangleGlobalName(g.name),\n+              (char *)g.beg);\n }\n \n bool DescribeAddressRelativeToGlobal(uptr addr, uptr size,\n                                      const __asan_global &g) {\n   static const uptr kMinimalDistanceFromAnotherGlobal = 64;\n   if (addr <= g.beg - kMinimalDistanceFromAnotherGlobal) return false;\n   if (addr >= g.beg + g.size_with_redzone) return false;\n+  InternalScopedString str(4096);\n   Decorator d;\n-  Printf(\"%s\", d.Location());\n+  str.append(\"%s\", d.Location());\n   if (addr < g.beg) {\n-    Printf(\"%p is located %zd bytes to the left\", (void*)addr, g.beg - addr);\n+    str.append(\"%p is located %zd bytes to the left\", (void *)addr,\n+               g.beg - addr);\n   } else if (addr + size > g.beg + g.size) {\n     if (addr < g.beg + g.size)\n       addr = g.beg + g.size;\n-    Printf(\"%p is located %zd bytes to the right\", (void*)addr,\n-           addr - (g.beg + g.size));\n+    str.append(\"%p is located %zd bytes to the right\", (void *)addr,\n+               addr - (g.beg + g.size));\n   } else {\n     // Can it happen?\n-    Printf(\"%p is located %zd bytes inside\", (void*)addr, addr - g.beg);\n+    str.append(\"%p is located %zd bytes inside\", (void *)addr, addr - g.beg);\n   }\n-  Printf(\" of global variable '%s' from '%s' (0x%zx) of size %zu\\n\",\n+  str.append(\" of global variable '%s' from '%s' (0x%zx) of size %zu\\n\",\n              MaybeDemangleGlobalName(g.name), g.module_name, g.beg, g.size);\n-  Printf(\"%s\", d.EndLocation());\n-  PrintGlobalNameIfASCII(g);\n+  str.append(\"%s\", d.EndLocation());\n+  PrintGlobalNameIfASCII(&str, g);\n+  Printf(\"%s\", str.data());\n   return true;\n }\n \n@@ -288,16 +303,18 @@ void PrintAccessAndVarIntersection(const char *var_name,\n              addr - prev_var_end >= var_beg - addr_end)\n       pos_descr = \"underflows\";\n   }\n-  Printf(\"    [%zd, %zd) '%s'\", var_beg, var_beg + var_size, var_name);\n+  InternalScopedString str(1024);\n+  str.append(\"    [%zd, %zd) '%s'\", var_beg, var_beg + var_size, var_name);\n   if (pos_descr) {\n     Decorator d;\n     // FIXME: we may want to also print the size of the access here,\n     // but in case of accesses generated by memset it may be confusing.\n-    Printf(\"%s <== Memory access at offset %zd %s this variable%s\\n\",\n-           d.Location(), addr, pos_descr, d.EndLocation());\n+    str.append(\"%s <== Memory access at offset %zd %s this variable%s\\n\",\n+               d.Location(), addr, pos_descr, d.EndLocation());\n   } else {\n-    Printf(\"\\n\");\n+    str.append(\"\\n\");\n   }\n+  Printf(\"%s\", str.data());\n }\n \n struct StackVarDescr {\n@@ -346,7 +363,7 @@ bool DescribeAddressIfStack(uptr addr, uptr access_size) {\n   alloca_stack.trace[0] = frame_pc + 16;\n   alloca_stack.size = 1;\n   Printf(\"%s\", d.EndLocation());\n-  PrintStack(&alloca_stack);\n+  alloca_stack.Print();\n   // Report the number of stack objects.\n   char *p;\n   uptr n_objects = (uptr)internal_simple_strtoll(frame_descr, &p, 10);\n@@ -394,24 +411,26 @@ static void DescribeAccessToHeapChunk(AsanChunkView chunk, uptr addr,\n                                       uptr access_size) {\n   sptr offset;\n   Decorator d;\n-  Printf(\"%s\", d.Location());\n+  InternalScopedString str(4096);\n+  str.append(\"%s\", d.Location());\n   if (chunk.AddrIsAtLeft(addr, access_size, &offset)) {\n-    Printf(\"%p is located %zd bytes to the left of\", (void*)addr, offset);\n+    str.append(\"%p is located %zd bytes to the left of\", (void *)addr, offset);\n   } else if (chunk.AddrIsAtRight(addr, access_size, &offset)) {\n     if (offset < 0) {\n       addr -= offset;\n       offset = 0;\n     }\n-    Printf(\"%p is located %zd bytes to the right of\", (void*)addr, offset);\n+    str.append(\"%p is located %zd bytes to the right of\", (void *)addr, offset);\n   } else if (chunk.AddrIsInside(addr, access_size, &offset)) {\n-    Printf(\"%p is located %zd bytes inside of\", (void*)addr, offset);\n+    str.append(\"%p is located %zd bytes inside of\", (void*)addr, offset);\n   } else {\n-    Printf(\"%p is located somewhere around (this is AddressSanitizer bug!)\",\n-           (void*)addr);\n+    str.append(\"%p is located somewhere around (this is AddressSanitizer bug!)\",\n+               (void *)addr);\n   }\n-  Printf(\" %zu-byte region [%p,%p)\\n\", chunk.UsedSize(),\n-         (void*)(chunk.Beg()), (void*)(chunk.End()));\n-  Printf(\"%s\", d.EndLocation());\n+  str.append(\" %zu-byte region [%p,%p)\\n\", chunk.UsedSize(),\n+             (void *)(chunk.Beg()), (void *)(chunk.End()));\n+  str.append(\"%s\", d.EndLocation());\n+  Printf(\"%s\", str.data());\n }\n \n void DescribeHeapAddress(uptr addr, uptr access_size) {\n@@ -439,7 +458,7 @@ void DescribeHeapAddress(uptr addr, uptr access_size) {\n            d.EndAllocation());\n     StackTrace free_stack;\n     chunk.GetFreeStack(&free_stack);\n-    PrintStack(&free_stack);\n+    free_stack.Print();\n     Printf(\"%spreviously allocated by thread T%d%s here:%s\\n\",\n            d.Allocation(), alloc_thread->tid,\n            ThreadNameWithParenthesis(alloc_thread, tname, sizeof(tname)),\n@@ -450,7 +469,7 @@ void DescribeHeapAddress(uptr addr, uptr access_size) {\n            ThreadNameWithParenthesis(alloc_thread, tname, sizeof(tname)),\n            d.EndAllocation());\n   }\n-  PrintStack(&alloc_stack);\n+  alloc_stack.Print();\n   DescribeThread(GetCurrentThread());\n   if (free_thread)\n     DescribeThread(free_thread);\n@@ -481,15 +500,16 @@ void DescribeThread(AsanThreadContext *context) {\n   }\n   context->announced = true;\n   char tname[128];\n-  Printf(\"Thread T%d%s\", context->tid,\n-         ThreadNameWithParenthesis(context->tid, tname, sizeof(tname)));\n-  Printf(\" created by T%d%s here:\\n\",\n-         context->parent_tid,\n-         ThreadNameWithParenthesis(context->parent_tid,\n-                                   tname, sizeof(tname)));\n+  InternalScopedString str(1024);\n+  str.append(\"Thread T%d%s\", context->tid,\n+             ThreadNameWithParenthesis(context->tid, tname, sizeof(tname)));\n+  str.append(\n+      \" created by T%d%s here:\\n\", context->parent_tid,\n+      ThreadNameWithParenthesis(context->parent_tid, tname, sizeof(tname)));\n+  Printf(\"%s\", str.data());\n   uptr stack_size;\n   const uptr *stack_trace = StackDepotGet(context->stack_id, &stack_size);\n-  PrintStack(stack_trace, stack_size);\n+  StackTrace::PrintStack(stack_trace, stack_size);\n   // Recursively described parent thread if needed.\n   if (flags()->print_full_thread_history) {\n     AsanThreadContext *parent_context =\n@@ -539,6 +559,8 @@ class ScopedInErrorReport {\n   NORETURN ~ScopedInErrorReport() {\n     // Make sure the current thread is announced.\n     DescribeThread(GetCurrentThread());\n+    // We may want to grab this lock again when printing stats.\n+    asanThreadRegistry().Unlock();\n     // Print memory stats.\n     if (flags()->print_stats)\n       __asan_print_accumulated_stats();\n@@ -550,17 +572,33 @@ class ScopedInErrorReport {\n   }\n };\n \n-void ReportSIGSEGV(uptr pc, uptr sp, uptr bp, uptr addr) {\n+void ReportStackOverflow(uptr pc, uptr sp, uptr bp, void *context, uptr addr) {\n   ScopedInErrorReport in_report;\n   Decorator d;\n   Printf(\"%s\", d.Warning());\n-  Report(\"ERROR: AddressSanitizer: SEGV on unknown address %p\"\n-             \" (pc %p sp %p bp %p T%d)\\n\",\n-             (void*)addr, (void*)pc, (void*)sp, (void*)bp,\n-             GetCurrentTidOrInvalid());\n+  Report(\n+      \"ERROR: AddressSanitizer: stack-overflow on address %p\"\n+      \" (pc %p sp %p bp %p T%d)\\n\",\n+      (void *)addr, (void *)pc, (void *)sp, (void *)bp,\n+      GetCurrentTidOrInvalid());\n   Printf(\"%s\", d.EndWarning());\n-  GET_STACK_TRACE_FATAL(pc, bp);\n-  PrintStack(&stack);\n+  GET_STACK_TRACE_SIGNAL(pc, bp, context);\n+  stack.Print();\n+  ReportErrorSummary(\"stack-overflow\", &stack);\n+}\n+\n+void ReportSIGSEGV(uptr pc, uptr sp, uptr bp, void *context, uptr addr) {\n+  ScopedInErrorReport in_report;\n+  Decorator d;\n+  Printf(\"%s\", d.Warning());\n+  Report(\n+      \"ERROR: AddressSanitizer: SEGV on unknown address %p\"\n+      \" (pc %p sp %p bp %p T%d)\\n\",\n+      (void *)addr, (void *)pc, (void *)sp, (void *)bp,\n+      GetCurrentTidOrInvalid());\n+  Printf(\"%s\", d.EndWarning());\n+  GET_STACK_TRACE_SIGNAL(pc, bp, context);\n+  stack.Print();\n   Printf(\"AddressSanitizer can not provide additional info.\\n\");\n   ReportErrorSummary(\"SEGV\", &stack);\n }\n@@ -578,7 +616,7 @@ void ReportDoubleFree(uptr addr, StackTrace *free_stack) {\n   Printf(\"%s\", d.EndWarning());\n   CHECK_GT(free_stack->size, 0);\n   GET_STACK_TRACE_FATAL(free_stack->trace[0], free_stack->top_frame_bp);\n-  PrintStack(&stack);\n+  stack.Print();\n   DescribeHeapAddress(addr, 1);\n   ReportErrorSummary(\"double-free\", &stack);\n }\n@@ -595,7 +633,7 @@ void ReportFreeNotMalloced(uptr addr, StackTrace *free_stack) {\n   Printf(\"%s\", d.EndWarning());\n   CHECK_GT(free_stack->size, 0);\n   GET_STACK_TRACE_FATAL(free_stack->trace[0], free_stack->top_frame_bp);\n-  PrintStack(&stack);\n+  stack.Print();\n   DescribeHeapAddress(addr, 1);\n   ReportErrorSummary(\"bad-free\", &stack);\n }\n@@ -616,7 +654,7 @@ void ReportAllocTypeMismatch(uptr addr, StackTrace *free_stack,\n   Printf(\"%s\", d.EndWarning());\n   CHECK_GT(free_stack->size, 0);\n   GET_STACK_TRACE_FATAL(free_stack->trace[0], free_stack->top_frame_bp);\n-  PrintStack(&stack);\n+  stack.Print();\n   DescribeHeapAddress(addr, 1);\n   ReportErrorSummary(\"alloc-dealloc-mismatch\", &stack);\n   Report(\"HINT: if you don't care about these warnings you may set \"\n@@ -631,7 +669,7 @@ void ReportMallocUsableSizeNotOwned(uptr addr, StackTrace *stack) {\n              \"malloc_usable_size() for pointer which is \"\n              \"not owned: %p\\n\", addr);\n   Printf(\"%s\", d.EndWarning());\n-  PrintStack(stack);\n+  stack->Print();\n   DescribeHeapAddress(addr, 1);\n   ReportErrorSummary(\"bad-malloc_usable_size\", stack);\n }\n@@ -644,7 +682,7 @@ void ReportAsanGetAllocatedSizeNotOwned(uptr addr, StackTrace *stack) {\n              \"__asan_get_allocated_size() for pointer which is \"\n              \"not owned: %p\\n\", addr);\n   Printf(\"%s\", d.EndWarning());\n-  PrintStack(stack);\n+  stack->Print();\n   DescribeHeapAddress(addr, 1);\n   ReportErrorSummary(\"bad-__asan_get_allocated_size\", stack);\n }\n@@ -661,12 +699,81 @@ void ReportStringFunctionMemoryRangesOverlap(\n              \"memory ranges [%p,%p) and [%p, %p) overlap\\n\", \\\n              bug_type, offset1, offset1 + length1, offset2, offset2 + length2);\n   Printf(\"%s\", d.EndWarning());\n-  PrintStack(stack);\n+  stack->Print();\n   DescribeAddress((uptr)offset1, length1);\n   DescribeAddress((uptr)offset2, length2);\n   ReportErrorSummary(bug_type, stack);\n }\n \n+void ReportStringFunctionSizeOverflow(uptr offset, uptr size,\n+                                      StackTrace *stack) {\n+  ScopedInErrorReport in_report;\n+  Decorator d;\n+  const char *bug_type = \"negative-size-param\";\n+  Printf(\"%s\", d.Warning());\n+  Report(\"ERROR: AddressSanitizer: %s: (size=%zd)\\n\", bug_type, size);\n+  Printf(\"%s\", d.EndWarning());\n+  stack->Print();\n+  DescribeAddress(offset, size);\n+  ReportErrorSummary(bug_type, stack);\n+}\n+\n+void ReportBadParamsToAnnotateContiguousContainer(uptr beg, uptr end,\n+                                                  uptr old_mid, uptr new_mid,\n+                                                  StackTrace *stack) {\n+  ScopedInErrorReport in_report;\n+  Report(\"ERROR: AddressSanitizer: bad parameters to \"\n+         \"__sanitizer_annotate_contiguous_container:\\n\"\n+         \"      beg     : %p\\n\"\n+         \"      end     : %p\\n\"\n+         \"      old_mid : %p\\n\"\n+         \"      new_mid : %p\\n\",\n+         beg, end, old_mid, new_mid);\n+  stack->Print();\n+  ReportErrorSummary(\"bad-__sanitizer_annotate_contiguous_container\", stack);\n+}\n+\n+void ReportODRViolation(const __asan_global *g1, const __asan_global *g2) {\n+  ScopedInErrorReport in_report;\n+  Decorator d;\n+  Printf(\"%s\", d.Warning());\n+  Report(\"ERROR: AddressSanitizer: odr-violation (%p):\\n\", g1->beg);\n+  Printf(\"%s\", d.EndWarning());\n+  Printf(\"  [1] size=%zd %s %s\\n\", g1->size, g1->name, g1->module_name);\n+  Printf(\"  [2] size=%zd %s %s\\n\", g2->size, g2->name, g2->module_name);\n+  Report(\"HINT: if you don't care about these warnings you may set \"\n+         \"ASAN_OPTIONS=detect_odr_violation=0\\n\");\n+  ReportErrorSummary(\"odr-violation\", g1->module_name, 0, g1->name);\n+}\n+\n+// ----------------------- CheckForInvalidPointerPair ----------- {{{1\n+static NOINLINE void\n+ReportInvalidPointerPair(uptr pc, uptr bp, uptr sp, uptr a1, uptr a2) {\n+  ScopedInErrorReport in_report;\n+  Decorator d;\n+  Printf(\"%s\", d.Warning());\n+  Report(\"ERROR: AddressSanitizer: invalid-pointer-pair: %p %p\\n\", a1, a2);\n+  Printf(\"%s\", d.EndWarning());\n+  GET_STACK_TRACE_FATAL(pc, bp);\n+  stack.Print();\n+  DescribeAddress(a1, 1);\n+  DescribeAddress(a2, 1);\n+  ReportErrorSummary(\"invalid-pointer-pair\", &stack);\n+}\n+\n+static INLINE void CheckForInvalidPointerPair(void *p1, void *p2) {\n+  if (!flags()->detect_invalid_pointer_pairs) return;\n+  uptr a1 = reinterpret_cast<uptr>(p1);\n+  uptr a2 = reinterpret_cast<uptr>(p2);\n+  AsanChunkView chunk1 = FindHeapChunkByAddress(a1);\n+  AsanChunkView chunk2 = FindHeapChunkByAddress(a2);\n+  bool valid1 = chunk1.IsValid();\n+  bool valid2 = chunk2.IsValid();\n+  if ((valid1 != valid2) || (valid1 && valid2 && !chunk1.Eq(chunk2))) {\n+    GET_CALLER_PC_BP_SP;                                              \\\n+    return ReportInvalidPointerPair(pc, bp, sp, a1, a2);\n+  }\n+}\n // ----------------------- Mac-specific reports ----------------- {{{1\n \n void WarnMacFreeUnallocated(\n@@ -676,7 +783,7 @@ void WarnMacFreeUnallocated(\n              \"AddressSanitizer is ignoring this error on Mac OS now.\\n\",\n              addr);\n   PrintZoneForPointer(addr, zone_ptr, zone_name);\n-  PrintStack(stack);\n+  stack->Print();\n   DescribeHeapAddress(addr, 1);\n }\n \n@@ -687,7 +794,7 @@ void ReportMacMzReallocUnknown(\n              \"This is an unrecoverable problem, exiting now.\\n\",\n              addr);\n   PrintZoneForPointer(addr, zone_ptr, zone_name);\n-  PrintStack(stack);\n+  stack->Print();\n   DescribeHeapAddress(addr, 1);\n }\n \n@@ -698,7 +805,7 @@ void ReportMacCfReallocUnknown(\n              \"This is an unrecoverable problem, exiting now.\\n\",\n              addr);\n   PrintZoneForPointer(addr, zone_ptr, zone_name);\n-  PrintStack(stack);\n+  stack->Print();\n   DescribeHeapAddress(addr, 1);\n }\n \n@@ -707,8 +814,8 @@ void ReportMacCfReallocUnknown(\n // --------------------------- Interface --------------------- {{{1\n using namespace __asan;  // NOLINT\n \n-void __asan_report_error(uptr pc, uptr bp, uptr sp,\n-                         uptr addr, bool is_write, uptr access_size) {\n+void __asan_report_error(uptr pc, uptr bp, uptr sp, uptr addr, int is_write,\n+                         uptr access_size) {\n   ScopedInErrorReport in_report;\n \n   // Determine the error type.\n@@ -774,7 +881,7 @@ void __asan_report_error(uptr pc, uptr bp, uptr sp,\n          d.EndAccess());\n \n   GET_STACK_TRACE_FATAL(pc, bp);\n-  PrintStack(&stack);\n+  stack.Print();\n \n   DescribeAddress(addr, access_size);\n   ReportErrorSummary(bug_descr, &stack);\n@@ -786,7 +893,7 @@ void NOINLINE __asan_set_error_report_callback(void (*callback)(const char*)) {\n   if (callback) {\n     error_message_buffer_size = 1 << 16;\n     error_message_buffer =\n-        (char*)MmapOrDie(error_message_buffer_size, __FUNCTION__);\n+        (char*)MmapOrDie(error_message_buffer_size, __func__);\n     error_message_buffer_pos = 0;\n   }\n }\n@@ -795,6 +902,17 @@ void __asan_describe_address(uptr addr) {\n   DescribeAddress(addr, 1);\n }\n \n+extern \"C\" {\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void __sanitizer_ptr_sub(void *a, void *b) {\n+  CheckForInvalidPointerPair(a, b);\n+}\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void __sanitizer_ptr_cmp(void *a, void *b) {\n+  CheckForInvalidPointerPair(a, b);\n+}\n+}  // extern \"C\"\n+\n #if !SANITIZER_SUPPORTS_WEAK_HOOKS\n // Provide default implementation of __asan_on_error that does nothing\n // and may be overriden by user."}, {"sha": "d9a0bca64233e886e416fbc4660b864ddaaa3569", "filename": "libsanitizer/asan/asan_report.h", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_report.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_report.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_report.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -30,7 +30,10 @@ void DescribeAddress(uptr addr, uptr access_size);\n void DescribeThread(AsanThreadContext *context);\n \n // Different kinds of error reports.\n-void NORETURN ReportSIGSEGV(uptr pc, uptr sp, uptr bp, uptr addr);\n+void NORETURN\n+    ReportStackOverflow(uptr pc, uptr sp, uptr bp, void *context, uptr addr);\n+void NORETURN\n+    ReportSIGSEGV(uptr pc, uptr sp, uptr bp, void *context, uptr addr);\n void NORETURN ReportDoubleFree(uptr addr, StackTrace *free_stack);\n void NORETURN ReportFreeNotMalloced(uptr addr, StackTrace *free_stack);\n void NORETURN ReportAllocTypeMismatch(uptr addr, StackTrace *free_stack,\n@@ -43,6 +46,14 @@ void NORETURN ReportAsanGetAllocatedSizeNotOwned(uptr addr,\n void NORETURN ReportStringFunctionMemoryRangesOverlap(\n     const char *function, const char *offset1, uptr length1,\n     const char *offset2, uptr length2, StackTrace *stack);\n+void NORETURN\n+ReportStringFunctionSizeOverflow(uptr offset, uptr size, StackTrace *stack);\n+void NORETURN\n+ReportBadParamsToAnnotateContiguousContainer(uptr beg, uptr end, uptr old_mid,\n+                                             uptr new_mid, StackTrace *stack);\n+\n+void NORETURN\n+ReportODRViolation(const __asan_global *g1, const __asan_global *g2);\n \n // Mac-specific errors and warnings.\n void WarnMacFreeUnallocated("}, {"sha": "00b4b95868e253d0711bede7a0b72f906e039170", "filename": "libsanitizer/asan/asan_rtl.cc", "status": "modified", "additions": 319, "deletions": 121, "changes": 440, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_rtl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_rtl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_rtl.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -9,6 +9,7 @@\n //\n // Main file of the ASan run-time library.\n //===----------------------------------------------------------------------===//\n+#include \"asan_activation.h\"\n #include \"asan_allocator.h\"\n #include \"asan_interceptors.h\"\n #include \"asan_interface_internal.h\"\n@@ -26,6 +27,7 @@\n #include \"lsan/lsan_common.h\"\n \n int __asan_option_detect_stack_use_after_return;  // Global interface symbol.\n+uptr *__asan_test_only_reported_buggy_pointer;  // Used only for testing asan.\n \n namespace __asan {\n \n@@ -49,7 +51,7 @@ static void AsanDie() {\n       UnmapOrDie((void*)kLowShadowBeg, kHighShadowEnd - kLowShadowBeg);\n     }\n   }\n-  if (flags()->coverage)\n+  if (common_flags()->coverage)\n     __sanitizer_cov_dump();\n   if (death_callback)\n     death_callback();\n@@ -60,8 +62,8 @@ static void AsanDie() {\n \n static void AsanCheckFailed(const char *file, int line, const char *cond,\n                             u64 v1, u64 v2) {\n-  Report(\"AddressSanitizer CHECK failed: %s:%d \\\"%s\\\" (0x%zx, 0x%zx)\\n\",\n-             file, line, cond, (uptr)v1, (uptr)v2);\n+  Report(\"AddressSanitizer CHECK failed: %s:%d \\\"%s\\\" (0x%zx, 0x%zx)\\n\", file,\n+         line, cond, (uptr)v1, (uptr)v2);\n   // FIXME: check for infinite recursion without a thread-local counter here.\n   PRINT_CURRENT_STACK();\n   Die();\n@@ -76,7 +78,7 @@ static const char *MaybeCallAsanDefaultOptions() {\n   return (&__asan_default_options) ? __asan_default_options() : \"\";\n }\n \n-static const char *MaybeUseAsanDefaultOptionsCompileDefiniton() {\n+static const char *MaybeUseAsanDefaultOptionsCompileDefinition() {\n #ifdef ASAN_DEFAULT_OPTIONS\n // Stringize the macro value.\n # define ASAN_STRINGIZE(x) #x\n@@ -91,110 +93,210 @@ static void ParseFlagsFromString(Flags *f, const char *str) {\n   CommonFlags *cf = common_flags();\n   ParseCommonFlagsFromString(cf, str);\n   CHECK((uptr)cf->malloc_context_size <= kStackTraceMax);\n-\n-  ParseFlag(str, &f->quarantine_size, \"quarantine_size\");\n-  ParseFlag(str, &f->redzone, \"redzone\");\n+  // Please write meaningful flag descriptions when adding new flags.\n+  ParseFlag(str, &f->quarantine_size, \"quarantine_size\",\n+            \"Size (in bytes) of quarantine used to detect use-after-free \"\n+            \"errors. Lower value may reduce memory usage but increase the \"\n+            \"chance of false negatives.\");\n+  ParseFlag(str, &f->redzone, \"redzone\",\n+            \"Minimal size (in bytes) of redzones around heap objects. \"\n+            \"Requirement: redzone >= 16, is a power of two.\");\n+  ParseFlag(str, &f->max_redzone, \"max_redzone\",\n+            \"Maximal size (in bytes) of redzones around heap objects.\");\n   CHECK_GE(f->redzone, 16);\n+  CHECK_GE(f->max_redzone, f->redzone);\n+  CHECK_LE(f->max_redzone, 2048);\n   CHECK(IsPowerOfTwo(f->redzone));\n-\n-  ParseFlag(str, &f->debug, \"debug\");\n-  ParseFlag(str, &f->report_globals, \"report_globals\");\n-  ParseFlag(str, &f->check_initialization_order, \"check_initialization_order\");\n-\n-  ParseFlag(str, &f->replace_str, \"replace_str\");\n-  ParseFlag(str, &f->replace_intrin, \"replace_intrin\");\n-  ParseFlag(str, &f->mac_ignore_invalid_free, \"mac_ignore_invalid_free\");\n+  CHECK(IsPowerOfTwo(f->max_redzone));\n+\n+  ParseFlag(str, &f->debug, \"debug\",\n+      \"If set, prints some debugging information and does additional checks.\");\n+  ParseFlag(str, &f->report_globals, \"report_globals\",\n+      \"Controls the way to handle globals (0 - don't detect buffer overflow on \"\n+      \"globals, 1 - detect buffer overflow, 2 - print data about registered \"\n+      \"globals).\");\n+\n+  ParseFlag(str, &f->check_initialization_order,\n+      \"check_initialization_order\",\n+      \"If set, attempts to catch initialization order issues.\");\n+\n+  ParseFlag(str, &f->replace_str, \"replace_str\",\n+      \"If set, uses custom wrappers and replacements for libc string functions \"\n+      \"to find more errors.\");\n+\n+  ParseFlag(str, &f->replace_intrin, \"replace_intrin\",\n+      \"If set, uses custom wrappers for memset/memcpy/memmove intinsics.\");\n+  ParseFlag(str, &f->mac_ignore_invalid_free, \"mac_ignore_invalid_free\",\n+      \"Ignore invalid free() calls to work around some bugs. Used on OS X \"\n+      \"only.\");\n   ParseFlag(str, &f->detect_stack_use_after_return,\n-            \"detect_stack_use_after_return\");\n-  ParseFlag(str, &f->uar_stack_size_log, \"uar_stack_size_log\");\n-  ParseFlag(str, &f->max_malloc_fill_size, \"max_malloc_fill_size\");\n-  ParseFlag(str, &f->malloc_fill_byte, \"malloc_fill_byte\");\n-  ParseFlag(str, &f->exitcode, \"exitcode\");\n-  ParseFlag(str, &f->allow_user_poisoning, \"allow_user_poisoning\");\n-  ParseFlag(str, &f->sleep_before_dying, \"sleep_before_dying\");\n-  ParseFlag(str, &f->handle_segv, \"handle_segv\");\n-  ParseFlag(str, &f->allow_user_segv_handler, \"allow_user_segv_handler\");\n-  ParseFlag(str, &f->use_sigaltstack, \"use_sigaltstack\");\n-  ParseFlag(str, &f->check_malloc_usable_size, \"check_malloc_usable_size\");\n-  ParseFlag(str, &f->unmap_shadow_on_exit, \"unmap_shadow_on_exit\");\n-  ParseFlag(str, &f->abort_on_error, \"abort_on_error\");\n-  ParseFlag(str, &f->print_stats, \"print_stats\");\n-  ParseFlag(str, &f->print_legend, \"print_legend\");\n-  ParseFlag(str, &f->atexit, \"atexit\");\n-  ParseFlag(str, &f->coverage, \"coverage\");\n-  ParseFlag(str, &f->disable_core, \"disable_core\");\n-  ParseFlag(str, &f->allow_reexec, \"allow_reexec\");\n-  ParseFlag(str, &f->print_full_thread_history, \"print_full_thread_history\");\n-  ParseFlag(str, &f->poison_heap, \"poison_heap\");\n-  ParseFlag(str, &f->poison_partial, \"poison_partial\");\n-  ParseFlag(str, &f->alloc_dealloc_mismatch, \"alloc_dealloc_mismatch\");\n-  ParseFlag(str, &f->strict_memcmp, \"strict_memcmp\");\n-  ParseFlag(str, &f->strict_init_order, \"strict_init_order\");\n+      \"detect_stack_use_after_return\",\n+      \"Enables stack-use-after-return checking at run-time.\");\n+  ParseFlag(str, &f->min_uar_stack_size_log, \"min_uar_stack_size_log\",\n+      \"Minimum fake stack size log.\");\n+  ParseFlag(str, &f->max_uar_stack_size_log, \"max_uar_stack_size_log\",\n+      \"Maximum fake stack size log.\");\n+  ParseFlag(str, &f->uar_noreserve, \"uar_noreserve\",\n+      \"Use mmap with 'norserve' flag to allocate fake stack.\");\n+  ParseFlag(str, &f->max_malloc_fill_size, \"max_malloc_fill_size\",\n+      \"ASan allocator flag. max_malloc_fill_size is the maximal amount of \"\n+      \"bytes that will be filled with malloc_fill_byte on malloc.\");\n+  ParseFlag(str, &f->malloc_fill_byte, \"malloc_fill_byte\",\n+      \"Value used to fill the newly allocated memory.\");\n+  ParseFlag(str, &f->exitcode, \"exitcode\",\n+      \"Override the program exit status if the tool found an error.\");\n+  ParseFlag(str, &f->allow_user_poisoning, \"allow_user_poisoning\",\n+      \"If set, user may manually mark memory regions as poisoned or \"\n+      \"unpoisoned.\");\n+  ParseFlag(str, &f->sleep_before_dying, \"sleep_before_dying\",\n+      \"Number of seconds to sleep between printing an error report and \"\n+      \"terminating the program. Useful for debugging purposes (e.g. when one \"\n+      \"needs to attach gdb).\");\n+\n+  ParseFlag(str, &f->check_malloc_usable_size, \"check_malloc_usable_size\",\n+      \"Allows the users to work around the bug in Nvidia drivers prior to \"\n+      \"295.*.\");\n+\n+  ParseFlag(str, &f->unmap_shadow_on_exit, \"unmap_shadow_on_exit\",\n+      \"If set, explicitly unmaps the (huge) shadow at exit.\");\n+  ParseFlag(str, &f->abort_on_error, \"abort_on_error\",\n+      \"If set, the tool calls abort() instead of _exit() after printing the \"\n+      \"error report.\");\n+  ParseFlag(str, &f->print_stats, \"print_stats\",\n+      \"Print various statistics after printing an error message or if \"\n+      \"atexit=1.\");\n+  ParseFlag(str, &f->print_legend, \"print_legend\",\n+      \"Print the legend for the shadow bytes.\");\n+  ParseFlag(str, &f->atexit, \"atexit\",\n+      \"If set, prints ASan exit stats even after program terminates \"\n+      \"successfully.\");\n+\n+  ParseFlag(str, &f->disable_core, \"disable_core\",\n+      \"Disable core dumping. By default, disable_core=1 on 64-bit to avoid \"\n+      \"dumping a 16T+ core file. \"\n+      \"Ignored on OSes that don't dump core by default.\");\n+\n+  ParseFlag(str, &f->allow_reexec, \"allow_reexec\",\n+      \"Allow the tool to re-exec the program. This may interfere badly with \"\n+      \"the debugger.\");\n+\n+  ParseFlag(str, &f->print_full_thread_history,\n+      \"print_full_thread_history\",\n+      \"If set, prints thread creation stacks for the threads involved in the \"\n+      \"report and their ancestors up to the main thread.\");\n+\n+  ParseFlag(str, &f->poison_heap, \"poison_heap\",\n+      \"Poison (or not) the heap memory on [de]allocation. Zero value is useful \"\n+      \"for benchmarking the allocator or instrumentator.\");\n+\n+  ParseFlag(str, &f->poison_partial, \"poison_partial\",\n+      \"If true, poison partially addressable 8-byte aligned words \"\n+      \"(default=true). This flag affects heap and global buffers, but not \"\n+      \"stack buffers.\");\n+\n+  ParseFlag(str, &f->alloc_dealloc_mismatch, \"alloc_dealloc_mismatch\",\n+      \"Report errors on malloc/delete, new/free, new/delete[], etc.\");\n+  ParseFlag(str, &f->strict_memcmp, \"strict_memcmp\",\n+      \"If true, assume that memcmp(p1, p2, n) always reads n bytes before \"\n+      \"comparing p1 and p2.\");\n+\n+  ParseFlag(str, &f->strict_init_order, \"strict_init_order\",\n+      \"If true, assume that dynamic initializers can never access globals from \"\n+      \"other modules, even if the latter are already initialized.\");\n+\n+  ParseFlag(str, &f->start_deactivated, \"start_deactivated\",\n+      \"If true, ASan tweaks a bunch of other flags (quarantine, redzone, heap \"\n+      \"poisoning) to reduce memory consumption as much as possible, and \"\n+      \"restores them to original values when the first instrumented module is \"\n+      \"loaded into the process. This is mainly intended to be used on \"\n+      \"Android. \");\n+\n+  ParseFlag(str, &f->detect_invalid_pointer_pairs,\n+      \"detect_invalid_pointer_pairs\",\n+      \"If non-zero, try to detect operations like <, <=, >, >= and - on \"\n+      \"invalid pointer pairs (e.g. when pointers belong to different objects). \"\n+      \"The bigger the value the harder we try.\");\n+\n+  ParseFlag(str, &f->detect_container_overflow,\n+      \"detect_container_overflow\",\n+      \"If true, honor the container overflow  annotations. \"\n+      \"See https://code.google.com/p/address-sanitizer/wiki/ContainerOverflow\");\n+\n+  ParseFlag(str, &f->detect_odr_violation, \"detect_odr_violation\",\n+            \"If >=2, detect violation of One-Definition-Rule (ODR); \"\n+            \"If ==1, detect ODR-violation only if the two variables \"\n+            \"have different sizes\");\n }\n \n void InitializeFlags(Flags *f, const char *env) {\n   CommonFlags *cf = common_flags();\n   SetCommonFlagsDefaults(cf);\n+  cf->detect_leaks = CAN_SANITIZE_LEAKS;\n   cf->external_symbolizer_path = GetEnv(\"ASAN_SYMBOLIZER_PATH\");\n   cf->malloc_context_size = kDefaultMallocContextSize;\n+  cf->intercept_tls_get_addr = true;\n+  cf->coverage = false;\n \n   internal_memset(f, 0, sizeof(*f));\n   f->quarantine_size = (ASAN_LOW_MEMORY) ? 1UL << 26 : 1UL << 28;\n   f->redzone = 16;\n+  f->max_redzone = 2048;\n   f->debug = false;\n   f->report_globals = 1;\n   f->check_initialization_order = false;\n   f->replace_str = true;\n   f->replace_intrin = true;\n   f->mac_ignore_invalid_free = false;\n   f->detect_stack_use_after_return = false;  // Also needs the compiler flag.\n-  f->uar_stack_size_log = 0;\n+  f->min_uar_stack_size_log = 16;  // We can't do smaller anyway.\n+  f->max_uar_stack_size_log = 20;  // 1Mb per size class, i.e. ~11Mb per thread.\n+  f->uar_noreserve = false;\n   f->max_malloc_fill_size = 0x1000;  // By default, fill only the first 4K.\n   f->malloc_fill_byte = 0xbe;\n   f->exitcode = ASAN_DEFAULT_FAILURE_EXITCODE;\n   f->allow_user_poisoning = true;\n   f->sleep_before_dying = 0;\n-  f->handle_segv = ASAN_NEEDS_SEGV;\n-  f->allow_user_segv_handler = false;\n-  f->use_sigaltstack = false;\n   f->check_malloc_usable_size = true;\n   f->unmap_shadow_on_exit = false;\n   f->abort_on_error = false;\n   f->print_stats = false;\n   f->print_legend = true;\n   f->atexit = false;\n-  f->coverage = false;\n   f->disable_core = (SANITIZER_WORDSIZE == 64);\n   f->allow_reexec = true;\n   f->print_full_thread_history = true;\n   f->poison_heap = true;\n   f->poison_partial = true;\n   // Turn off alloc/dealloc mismatch checker on Mac and Windows for now.\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=131\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=309\n   // TODO(glider,timurrrr): Fix known issues and enable this back.\n   f->alloc_dealloc_mismatch = (SANITIZER_MAC == 0) && (SANITIZER_WINDOWS == 0);\n   f->strict_memcmp = true;\n   f->strict_init_order = false;\n+  f->start_deactivated = false;\n+  f->detect_invalid_pointer_pairs = 0;\n+  f->detect_container_overflow = true;\n \n   // Override from compile definition.\n-  ParseFlagsFromString(f, MaybeUseAsanDefaultOptionsCompileDefiniton());\n+  ParseFlagsFromString(f, MaybeUseAsanDefaultOptionsCompileDefinition());\n \n   // Override from user-specified string.\n   ParseFlagsFromString(f, MaybeCallAsanDefaultOptions());\n-  if (cf->verbosity) {\n-    Report(\"Using the defaults from __asan_default_options: %s\\n\",\n-           MaybeCallAsanDefaultOptions());\n-  }\n+  VReport(1, \"Using the defaults from __asan_default_options: %s\\n\",\n+          MaybeCallAsanDefaultOptions());\n \n   // Override from command line.\n   ParseFlagsFromString(f, env);\n+  if (common_flags()->help) {\n+    PrintFlagDescriptions();\n+  }\n \n-#if !CAN_SANITIZE_LEAKS\n-  if (cf->detect_leaks) {\n+  if (!CAN_SANITIZE_LEAKS && cf->detect_leaks) {\n     Report(\"%s: detect_leaks is not supported on this platform.\\n\",\n            SanitizerToolName);\n     cf->detect_leaks = false;\n   }\n-#endif\n \n   // Make \"strict_init_order\" imply \"check_initialization_order\".\n   // TODO(samsonov): Use a single runtime flag for an init-order checker.\n@@ -203,6 +305,17 @@ void InitializeFlags(Flags *f, const char *env) {\n   }\n }\n \n+// Parse flags that may change between startup and activation.\n+// On Android they come from a system property.\n+// On other platforms this is no-op.\n+void ParseExtraActivationFlags() {\n+  char buf[100];\n+  GetExtraActivationFlags(buf, sizeof(buf));\n+  ParseFlagsFromString(flags(), buf);\n+  if (buf[0] != '\\0')\n+    VReport(1, \"Extra activation flags: %s\\n\", buf);\n+}\n+\n // -------------------------- Globals --------------------- {{{1\n int asan_inited;\n bool asan_init_is_running;\n@@ -224,6 +337,7 @@ static void ReserveShadowMemoryRange(uptr beg, uptr end) {\n   CHECK_EQ((beg % GetPageSizeCached()), 0);\n   CHECK_EQ(((end + 1) % GetPageSizeCached()), 0);\n   uptr size = end - beg + 1;\n+  DecreaseTotalMmap(size);  // Don't count the shadow against mmap_limit_mb.\n   void *res = MmapFixedNoReserve(beg, size);\n   if (res != (void*)beg) {\n     Report(\"ReserveShadowMemoryRange failed while trying to map 0x%zx bytes. \"\n@@ -269,6 +383,53 @@ void __asan_report_ ## type ## _n(uptr addr, uptr size) {      \\\n ASAN_REPORT_ERROR_N(load, false)\n ASAN_REPORT_ERROR_N(store, true)\n \n+#define ASAN_MEMORY_ACCESS_CALLBACK(type, is_write, size)                      \\\n+  extern \"C\" NOINLINE INTERFACE_ATTRIBUTE void __asan_##type##size(uptr addr); \\\n+  void __asan_##type##size(uptr addr) {                                        \\\n+    uptr sp = MEM_TO_SHADOW(addr);                                             \\\n+    uptr s = size <= SHADOW_GRANULARITY ? *reinterpret_cast<u8 *>(sp)          \\\n+                                        : *reinterpret_cast<u16 *>(sp);        \\\n+    if (UNLIKELY(s)) {                                                         \\\n+      if (UNLIKELY(size >= SHADOW_GRANULARITY ||                               \\\n+                   ((s8)((addr & (SHADOW_GRANULARITY - 1)) + size - 1)) >=     \\\n+                       (s8)s)) {                                               \\\n+        if (__asan_test_only_reported_buggy_pointer) {                         \\\n+          *__asan_test_only_reported_buggy_pointer = addr;                     \\\n+        } else {                                                               \\\n+          GET_CALLER_PC_BP_SP;                                                 \\\n+          __asan_report_error(pc, bp, sp, addr, is_write, size);               \\\n+        }                                                                      \\\n+      }                                                                        \\\n+    }                                                                          \\\n+  }\n+\n+ASAN_MEMORY_ACCESS_CALLBACK(load, false, 1)\n+ASAN_MEMORY_ACCESS_CALLBACK(load, false, 2)\n+ASAN_MEMORY_ACCESS_CALLBACK(load, false, 4)\n+ASAN_MEMORY_ACCESS_CALLBACK(load, false, 8)\n+ASAN_MEMORY_ACCESS_CALLBACK(load, false, 16)\n+ASAN_MEMORY_ACCESS_CALLBACK(store, true, 1)\n+ASAN_MEMORY_ACCESS_CALLBACK(store, true, 2)\n+ASAN_MEMORY_ACCESS_CALLBACK(store, true, 4)\n+ASAN_MEMORY_ACCESS_CALLBACK(store, true, 8)\n+ASAN_MEMORY_ACCESS_CALLBACK(store, true, 16)\n+\n+extern \"C\"\n+NOINLINE INTERFACE_ATTRIBUTE void __asan_loadN(uptr addr, uptr size) {\n+  if (__asan_region_is_poisoned(addr, size)) {\n+    GET_CALLER_PC_BP_SP;\n+    __asan_report_error(pc, bp, sp, addr, false, size);\n+  }\n+}\n+\n+extern \"C\"\n+NOINLINE INTERFACE_ATTRIBUTE void __asan_storeN(uptr addr, uptr size) {\n+  if (__asan_region_is_poisoned(addr, size)) {\n+    GET_CALLER_PC_BP_SP;\n+    __asan_report_error(pc, bp, sp, addr, true, size);\n+  }\n+}\n+\n // Force the linker to keep the symbols for various ASan interface functions.\n // We want to keep those in the executable in order to let the instrumented\n // dynamic libraries access the symbol even if it is not used by the executable\n@@ -372,7 +533,8 @@ static void PrintAddressSpaceLayout() {\n            (void*)MEM_TO_SHADOW(kMidShadowEnd));\n   }\n   Printf(\"\\n\");\n-  Printf(\"red_zone=%zu\\n\", (uptr)flags()->redzone);\n+  Printf(\"redzone=%zu\\n\", (uptr)flags()->redzone);\n+  Printf(\"max_redzone=%zu\\n\", (uptr)flags()->max_redzone);\n   Printf(\"quarantine_size=%zuM\\n\", (uptr)flags()->quarantine_size >> 20);\n   Printf(\"malloc_context_size=%zu\\n\",\n          (uptr)common_flags()->malloc_context_size);\n@@ -387,59 +549,17 @@ static void PrintAddressSpaceLayout() {\n           kHighShadowBeg > kMidMemEnd);\n }\n \n-}  // namespace __asan\n-\n-// ---------------------- Interface ---------------- {{{1\n-using namespace __asan;  // NOLINT\n-\n-#if !SANITIZER_SUPPORTS_WEAK_HOOKS\n-extern \"C\" {\n-SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n-const char* __asan_default_options() { return \"\"; }\n-}  // extern \"C\"\n-#endif\n-\n-int NOINLINE __asan_set_error_exit_code(int exit_code) {\n-  int old = flags()->exitcode;\n-  flags()->exitcode = exit_code;\n-  return old;\n-}\n-\n-void NOINLINE __asan_handle_no_return() {\n-  int local_stack;\n-  AsanThread *curr_thread = GetCurrentThread();\n-  CHECK(curr_thread);\n-  uptr PageSize = GetPageSizeCached();\n-  uptr top = curr_thread->stack_top();\n-  uptr bottom = ((uptr)&local_stack - PageSize) & ~(PageSize-1);\n-  static const uptr kMaxExpectedCleanupSize = 64 << 20;  // 64M\n-  if (top - bottom > kMaxExpectedCleanupSize) {\n-    static bool reported_warning = false;\n-    if (reported_warning)\n-      return;\n-    reported_warning = true;\n-    Report(\"WARNING: ASan is ignoring requested __asan_handle_no_return: \"\n-           \"stack top: %p; bottom %p; size: %p (%zd)\\n\"\n-           \"False positive error reports may follow\\n\"\n-           \"For details see \"\n-           \"http://code.google.com/p/address-sanitizer/issues/detail?id=189\\n\",\n-           top, bottom, top - bottom, top - bottom);\n-    return;\n-  }\n-  PoisonShadow(bottom, top - bottom, 0);\n-  if (curr_thread->has_fake_stack())\n-    curr_thread->fake_stack()->HandleNoReturn();\n-}\n-\n-void NOINLINE __asan_set_death_callback(void (*callback)(void)) {\n-  death_callback = callback;\n-}\n-\n-void __asan_init() {\n-  if (asan_inited) return;\n+static void AsanInitInternal() {\n+  if (LIKELY(asan_inited)) return;\n   SanitizerToolName = \"AddressSanitizer\";\n   CHECK(!asan_init_is_running && \"ASan init calls itself!\");\n   asan_init_is_running = true;\n+\n+  // Initialize flags. This must be done early, because most of the\n+  // initialization steps look at flags().\n+  const char *options = GetEnv(\"ASAN_OPTIONS\");\n+  InitializeFlags(flags(), options);\n+\n   InitializeHighMemEnd();\n \n   // Make sure we are not statically linked.\n@@ -450,18 +570,21 @@ void __asan_init() {\n   SetCheckFailedCallback(AsanCheckFailed);\n   SetPrintfAndReportCallback(AppendToErrorMessageBuffer);\n \n-  // Initialize flags. This must be done early, because most of the\n-  // initialization steps look at flags().\n-  const char *options = GetEnv(\"ASAN_OPTIONS\");\n-  InitializeFlags(flags(), options);\n+  if (!flags()->start_deactivated)\n+    ParseExtraActivationFlags();\n+\n   __sanitizer_set_report_path(common_flags()->log_path);\n   __asan_option_detect_stack_use_after_return =\n       flags()->detect_stack_use_after_return;\n+  CHECK_LE(flags()->min_uar_stack_size_log, flags()->max_uar_stack_size_log);\n \n-  if (common_flags()->verbosity && options) {\n-    Report(\"Parsed ASAN_OPTIONS: %s\\n\", options);\n+  if (options) {\n+    VReport(1, \"Parsed ASAN_OPTIONS: %s\\n\", options);\n   }\n \n+  if (flags()->start_deactivated)\n+    AsanStartDeactivated();\n+\n   // Re-exec ourselves if we need to set additional env or command line args.\n   MaybeReexec();\n \n@@ -471,7 +594,6 @@ void __asan_init() {\n   InitializeAsanInterceptors();\n \n   ReplaceSystemMalloc();\n-  ReplaceOperatorsNewAndDelete();\n \n   uptr shadow_start = kLowShadowBeg;\n   if (kLowShadowBeg)\n@@ -501,6 +623,7 @@ void __asan_init() {\n     ReserveShadowMemoryRange(kHighShadowBeg, kHighShadowEnd);\n     // protect the gap.\n     ProtectGap(kShadowGapBeg, kShadowGapEnd - kShadowGapBeg + 1);\n+    CHECK_EQ(kShadowGapEnd, kHighShadowBeg - 1);\n   } else if (kMidMemBeg &&\n       MemoryRangeIsAvailable(shadow_start, kMidMemBeg - 1) &&\n       MemoryRangeIsAvailable(kMidMemEnd + 1, kHighShadowEnd)) {\n@@ -523,18 +646,13 @@ void __asan_init() {\n   }\n \n   AsanTSDInit(PlatformTSDDtor);\n-  InstallSignalHandlers();\n+  InstallDeadlySignalHandlers(AsanOnSIGSEGV);\n \n   // Allocator should be initialized before starting external symbolizer, as\n   // fork() on Mac locks the allocator.\n   InitializeAllocator();\n \n-  // Start symbolizer process if necessary.\n-  if (common_flags()->symbolize) {\n-    Symbolizer::Init(common_flags()->external_symbolizer_path);\n-  } else {\n-    Symbolizer::Disable();\n-  }\n+  Symbolizer::Init(common_flags()->external_symbolizer_path);\n \n   // On Linux AsanThread::ThreadStart() calls malloc() that's why asan_inited\n   // should be set to 1 prior to initializing the threads.\n@@ -544,8 +662,10 @@ void __asan_init() {\n   if (flags()->atexit)\n     Atexit(asan_atexit);\n \n-  if (flags()->coverage)\n+  if (common_flags()->coverage) {\n+    __sanitizer_cov_init();\n     Atexit(__sanitizer_cov_dump);\n+  }\n \n   // interceptors\n   InitTlsSize();\n@@ -559,6 +679,7 @@ void __asan_init() {\n   SetCurrentThread(main_thread);\n   main_thread->ThreadStart(internal_getpid());\n   force_interface_symbols();  // no-op.\n+  SanitizerInitializeUnwinder();\n \n #if CAN_SANITIZE_LEAKS\n   __lsan::InitCommonLsan();\n@@ -567,7 +688,84 @@ void __asan_init() {\n   }\n #endif  // CAN_SANITIZE_LEAKS\n \n-  if (common_flags()->verbosity) {\n-    Report(\"AddressSanitizer Init done\\n\");\n+  VReport(1, \"AddressSanitizer Init done\\n\");\n+}\n+\n+// Initialize as requested from some part of ASan runtime library (interceptors,\n+// allocator, etc).\n+void AsanInitFromRtl() {\n+  AsanInitInternal();\n+}\n+\n+#if ASAN_DYNAMIC\n+// Initialize runtime in case it's LD_PRELOAD-ed into unsanitized executable\n+// (and thus normal initializer from .preinit_array haven't run).\n+\n+class AsanInitializer {\n+public:  // NOLINT\n+  AsanInitializer() {\n+    AsanCheckIncompatibleRT();\n+    AsanCheckDynamicRTPrereqs();\n+    if (UNLIKELY(!asan_inited))\n+      __asan_init();\n   }\n+};\n+\n+static AsanInitializer asan_initializer;\n+#endif  // ASAN_DYNAMIC\n+\n+}  // namespace __asan\n+\n+// ---------------------- Interface ---------------- {{{1\n+using namespace __asan;  // NOLINT\n+\n+#if !SANITIZER_SUPPORTS_WEAK_HOOKS\n+extern \"C\" {\n+SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n+const char* __asan_default_options() { return \"\"; }\n+}  // extern \"C\"\n+#endif\n+\n+int NOINLINE __asan_set_error_exit_code(int exit_code) {\n+  int old = flags()->exitcode;\n+  flags()->exitcode = exit_code;\n+  return old;\n+}\n+\n+void NOINLINE __asan_handle_no_return() {\n+  int local_stack;\n+  AsanThread *curr_thread = GetCurrentThread();\n+  CHECK(curr_thread);\n+  uptr PageSize = GetPageSizeCached();\n+  uptr top = curr_thread->stack_top();\n+  uptr bottom = ((uptr)&local_stack - PageSize) & ~(PageSize-1);\n+  static const uptr kMaxExpectedCleanupSize = 64 << 20;  // 64M\n+  if (top - bottom > kMaxExpectedCleanupSize) {\n+    static bool reported_warning = false;\n+    if (reported_warning)\n+      return;\n+    reported_warning = true;\n+    Report(\"WARNING: ASan is ignoring requested __asan_handle_no_return: \"\n+           \"stack top: %p; bottom %p; size: %p (%zd)\\n\"\n+           \"False positive error reports may follow\\n\"\n+           \"For details see \"\n+           \"http://code.google.com/p/address-sanitizer/issues/detail?id=189\\n\",\n+           top, bottom, top - bottom, top - bottom);\n+    return;\n+  }\n+  PoisonShadow(bottom, top - bottom, 0);\n+  if (curr_thread->has_fake_stack())\n+    curr_thread->fake_stack()->HandleNoReturn();\n+}\n+\n+void NOINLINE __asan_set_death_callback(void (*callback)(void)) {\n+  death_callback = callback;\n+}\n+\n+// Initialize as requested from instrumented application code.\n+// We use this call as a trigger to wake up ASan from deactivated state.\n+void __asan_init() {\n+  AsanCheckIncompatibleRT();\n+  AsanActivate();\n+  AsanInitInternal();\n }"}, {"sha": "96178e8247b67e1630b4a001cee165f627903cea", "filename": "libsanitizer/asan/asan_stack.cc", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_stack.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_stack.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_stack.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -10,40 +10,10 @@\n // Code for ASan stack trace.\n //===----------------------------------------------------------------------===//\n #include \"asan_internal.h\"\n-#include \"asan_flags.h\"\n #include \"asan_stack.h\"\n-#include \"sanitizer_common/sanitizer_flags.h\"\n-\n-namespace __asan {\n-\n-static bool MaybeCallAsanSymbolize(const void *pc, char *out_buffer,\n-                                   int out_size) {\n-  return (&__asan_symbolize) ? __asan_symbolize(pc, out_buffer, out_size)\n-                             : false;\n-}\n-\n-void PrintStack(const uptr *trace, uptr size) {\n-  StackTrace::PrintStack(trace, size, MaybeCallAsanSymbolize);\n-}\n-\n-void PrintStack(StackTrace *stack) {\n-  PrintStack(stack->trace, stack->size);\n-}\n-\n-}  // namespace __asan\n \n // ------------------ Interface -------------- {{{1\n \n-// Provide default implementation of __asan_symbolize that does nothing\n-// and may be overriden by user if he wants to use his own symbolization.\n-// ASan on Windows has its own implementation of this.\n-#if !SANITIZER_WINDOWS && !SANITIZER_SUPPORTS_WEAK_HOOKS\n-SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE NOINLINE\n-bool __asan_symbolize(const void *pc, char *out_buffer, int out_size) {\n-  return false;\n-}\n-#endif\n-\n extern \"C\" {\n SANITIZER_INTERFACE_ATTRIBUTE\n void __sanitizer_print_stack_trace() {"}, {"sha": "d31c0afa83bcfd5dcdec9c9a06173baeddd76550", "filename": "libsanitizer/asan/asan_stack.h", "status": "modified", "additions": 44, "deletions": 31, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_stack.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_stack.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_stack.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -19,49 +19,62 @@\n \n namespace __asan {\n \n-void PrintStack(StackTrace *stack);\n-void PrintStack(const uptr *trace, uptr size);\n-\n-}  // namespace __asan\n-\n // Get the stack trace with the given pc and bp.\n // The pc will be in the position 0 of the resulting stack trace.\n // The bp may refer to the current frame or to the caller's frame.\n+ALWAYS_INLINE\n+void GetStackTraceWithPcBpAndContext(StackTrace *stack, uptr max_depth, uptr pc,\n+                                     uptr bp, void *context, bool fast) {\n #if SANITIZER_WINDOWS\n-#define GET_STACK_TRACE_WITH_PC_AND_BP(max_s, pc, bp, fast) \\\n-  StackTrace stack;                                         \\\n-  stack.Unwind(max_s, pc, bp, 0, 0, fast)\n+  stack->Unwind(max_depth, pc, bp, context, 0, 0, fast);\n #else\n-#define GET_STACK_TRACE_WITH_PC_AND_BP(max_s, pc, bp, fast)                    \\\n-  StackTrace stack;                                                            \\\n-  {                                                                            \\\n-    AsanThread *t;                                                             \\\n-    stack.size = 0;                                                            \\\n-    if (asan_inited) {                                                         \\\n-      if ((t = GetCurrentThread()) && !t->isUnwinding()) {                     \\\n-        uptr stack_top = t->stack_top();                                       \\\n-        uptr stack_bottom = t->stack_bottom();                                 \\\n-        ScopedUnwinding unwind_scope(t);                                       \\\n-        stack.Unwind(max_s, pc, bp, stack_top, stack_bottom, fast);            \\\n-      } else if (t == 0 && !fast) {                                            \\\n-        /* If GetCurrentThread() has failed, try to do slow unwind anyways. */ \\\n-        stack.Unwind(max_s, pc, bp, 0, 0, false);                              \\\n-      }                                                                        \\\n-    }                                                                          \\\n+  AsanThread *t;\n+  stack->size = 0;\n+  if (LIKELY(asan_inited)) {\n+    if ((t = GetCurrentThread()) && !t->isUnwinding()) {\n+      uptr stack_top = t->stack_top();\n+      uptr stack_bottom = t->stack_bottom();\n+      ScopedUnwinding unwind_scope(t);\n+      stack->Unwind(max_depth, pc, bp, context, stack_top, stack_bottom, fast);\n+    } else if (t == 0 && !fast) {\n+      /* If GetCurrentThread() has failed, try to do slow unwind anyways. */\n+      stack->Unwind(max_depth, pc, bp, context, 0, 0, false);\n+    }\n   }\n #endif  // SANITIZER_WINDOWS\n+}\n+\n+}  // namespace __asan\n \n // NOTE: A Rule of thumb is to retrieve stack trace in the interceptors\n // as early as possible (in functions exposed to the user), as we generally\n // don't want stack trace to contain functions from ASan internals.\n \n-#define GET_STACK_TRACE(max_size, fast)                       \\\n-  GET_STACK_TRACE_WITH_PC_AND_BP(max_size,                    \\\n-      StackTrace::GetCurrentPc(), GET_CURRENT_FRAME(), fast)\n+#define GET_STACK_TRACE(max_size, fast)                                        \\\n+  StackTrace stack;                                                            \\\n+  if (max_size <= 2) {                                                         \\\n+    stack.size = max_size;                                                     \\\n+    if (max_size > 0) {                                                        \\\n+      stack.top_frame_bp = GET_CURRENT_FRAME();                                \\\n+      stack.trace[0] = StackTrace::GetCurrentPc();                             \\\n+      if (max_size > 1)                                                        \\\n+        stack.trace[1] = GET_CALLER_PC();                                      \\\n+    }                                                                          \\\n+  } else {                                                                     \\\n+    GetStackTraceWithPcBpAndContext(&stack, max_size,                          \\\n+                                    StackTrace::GetCurrentPc(),                \\\n+                                    GET_CURRENT_FRAME(), 0, fast);             \\\n+  }\n \n-#define GET_STACK_TRACE_FATAL(pc, bp)                                 \\\n-  GET_STACK_TRACE_WITH_PC_AND_BP(kStackTraceMax, pc, bp,              \\\n-                                 common_flags()->fast_unwind_on_fatal)\n+#define GET_STACK_TRACE_FATAL(pc, bp)                                          \\\n+  StackTrace stack;                                                            \\\n+  GetStackTraceWithPcBpAndContext(&stack, kStackTraceMax, pc, bp, 0,           \\\n+                                  common_flags()->fast_unwind_on_fatal)\n+\n+#define GET_STACK_TRACE_SIGNAL(pc, bp, context)                                \\\n+  StackTrace stack;                                                            \\\n+  GetStackTraceWithPcBpAndContext(&stack, kStackTraceMax, pc, bp, context,     \\\n+                                  common_flags()->fast_unwind_on_fatal)\n \n #define GET_STACK_TRACE_FATAL_HERE                                \\\n   GET_STACK_TRACE(kStackTraceMax, common_flags()->fast_unwind_on_fatal)\n@@ -78,7 +91,7 @@ void PrintStack(const uptr *trace, uptr size);\n #define PRINT_CURRENT_STACK()   \\\n   {                             \\\n     GET_STACK_TRACE_FATAL_HERE; \\\n-    PrintStack(&stack);         \\\n+    stack.Print();              \\\n   }\n \n #endif  // ASAN_STACK_H"}, {"sha": "df85858a67bf9056576457132ca8d8e133e669c3", "filename": "libsanitizer/asan/asan_thread.cc", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_thread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_thread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_thread.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -18,6 +18,7 @@\n #include \"sanitizer_common/sanitizer_common.h\"\n #include \"sanitizer_common/sanitizer_placement_new.h\"\n #include \"sanitizer_common/sanitizer_stackdepot.h\"\n+#include \"sanitizer_common/sanitizer_tls_get_addr.h\"\n #include \"lsan/lsan_common.h\"\n \n namespace __asan {\n@@ -76,7 +77,7 @@ AsanThread *AsanThread::Create(thread_callback_t start_routine,\n                                void *arg) {\n   uptr PageSize = GetPageSizeCached();\n   uptr size = RoundUpTo(sizeof(AsanThread), PageSize);\n-  AsanThread *thread = (AsanThread*)MmapOrDie(size, __FUNCTION__);\n+  AsanThread *thread = (AsanThread*)MmapOrDie(size, __func__);\n   thread->start_routine_ = start_routine;\n   thread->arg_ = arg;\n \n@@ -85,28 +86,27 @@ AsanThread *AsanThread::Create(thread_callback_t start_routine,\n \n void AsanThread::TSDDtor(void *tsd) {\n   AsanThreadContext *context = (AsanThreadContext*)tsd;\n-  if (common_flags()->verbosity >= 1)\n-    Report(\"T%d TSDDtor\\n\", context->tid);\n+  VReport(1, \"T%d TSDDtor\\n\", context->tid);\n   if (context->thread)\n     context->thread->Destroy();\n }\n \n void AsanThread::Destroy() {\n-  if (common_flags()->verbosity >= 1) {\n-    Report(\"T%d exited\\n\", tid());\n-  }\n+  int tid = this->tid();\n+  VReport(1, \"T%d exited\\n\", tid);\n \n   malloc_storage().CommitBack();\n-  if (flags()->use_sigaltstack) UnsetAlternateSignalStack();\n-  asanThreadRegistry().FinishThread(tid());\n+  if (common_flags()->use_sigaltstack) UnsetAlternateSignalStack();\n+  asanThreadRegistry().FinishThread(tid);\n   FlushToDeadThreadStats(&stats_);\n   // We also clear the shadow on thread destruction because\n   // some code may still be executing in later TSD destructors\n   // and we don't want it to have any poisoned stack.\n   ClearShadowForThreadStackAndTLS();\n-  DeleteFakeStack();\n+  DeleteFakeStack(tid);\n   uptr size = RoundUpTo(sizeof(AsanThread), GetPageSizeCached());\n   UnmapOrDie(this, size);\n+  DTLS_Destroy();\n }\n \n // We want to create the FakeStack lazyly on the first use, but not eralier\n@@ -121,13 +121,16 @@ FakeStack *AsanThread::AsyncSignalSafeLazyInitFakeStack() {\n   // 1   -- being initialized\n   // ptr -- initialized\n   // This CAS checks if the state was 0 and if so changes it to state 1,\n-  // if that was successfull, it initilizes the pointer.\n+  // if that was successful, it initializes the pointer.\n   if (atomic_compare_exchange_strong(\n       reinterpret_cast<atomic_uintptr_t *>(&fake_stack_), &old_val, 1UL,\n       memory_order_relaxed)) {\n     uptr stack_size_log = Log2(RoundUpToPowerOfTwo(stack_size));\n-    if (flags()->uar_stack_size_log)\n-      stack_size_log = static_cast<uptr>(flags()->uar_stack_size_log);\n+    CHECK_LE(flags()->min_uar_stack_size_log, flags()->max_uar_stack_size_log);\n+    stack_size_log =\n+        Min(stack_size_log, static_cast<uptr>(flags()->max_uar_stack_size_log));\n+    stack_size_log =\n+        Max(stack_size_log, static_cast<uptr>(flags()->min_uar_stack_size_log));\n     fake_stack_ = FakeStack::Create(stack_size_log);\n     SetTLSFakeStack(fake_stack_);\n     return fake_stack_;\n@@ -140,20 +143,18 @@ void AsanThread::Init() {\n   CHECK(AddrIsInMem(stack_bottom_));\n   CHECK(AddrIsInMem(stack_top_ - 1));\n   ClearShadowForThreadStackAndTLS();\n-  if (common_flags()->verbosity >= 1) {\n-    int local = 0;\n-    Report(\"T%d: stack [%p,%p) size 0x%zx; local=%p\\n\",\n-           tid(), (void*)stack_bottom_, (void*)stack_top_,\n-           stack_top_ - stack_bottom_, &local);\n-  }\n+  int local = 0;\n+  VReport(1, \"T%d: stack [%p,%p) size 0x%zx; local=%p\\n\", tid(),\n+          (void *)stack_bottom_, (void *)stack_top_, stack_top_ - stack_bottom_,\n+          &local);\n   fake_stack_ = 0;  // Will be initialized lazily if needed.\n   AsanPlatformThreadInit();\n }\n \n thread_return_t AsanThread::ThreadStart(uptr os_id) {\n   Init();\n   asanThreadRegistry().StartThread(tid(), os_id, 0);\n-  if (flags()->use_sigaltstack) SetAlternateSignalStack();\n+  if (common_flags()->use_sigaltstack) SetAlternateSignalStack();\n \n   if (!start_routine_) {\n     // start_routine_ == 0 if we're on the main thread or on one of the\n@@ -265,10 +266,8 @@ AsanThread *GetCurrentThread() {\n \n void SetCurrentThread(AsanThread *t) {\n   CHECK(t->context());\n-  if (common_flags()->verbosity >= 2) {\n-    Report(\"SetCurrentThread: %p for thread %p\\n\",\n-           t->context(), (void*)GetThreadSelf());\n-  }\n+  VReport(2, \"SetCurrentThread: %p for thread %p\\n\", t->context(),\n+          (void *)GetThreadSelf());\n   // Make sure we do not reset the current AsanThread.\n   CHECK_EQ(0, AsanTSDGet());\n   AsanTSDSet(t->context());"}, {"sha": "33242efabaa26fd3cd54ed4ae0b5e1e37f813f96", "filename": "libsanitizer/asan/asan_thread.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_thread.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_thread.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_thread.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -15,7 +15,6 @@\n #include \"asan_allocator.h\"\n #include \"asan_internal.h\"\n #include \"asan_fake_stack.h\"\n-#include \"asan_stack.h\"\n #include \"asan_stats.h\"\n #include \"sanitizer_common/sanitizer_common.h\"\n #include \"sanitizer_common/sanitizer_libc.h\"\n@@ -76,12 +75,12 @@ class AsanThread {\n     return addr >= stack_bottom_ && addr < stack_top_;\n   }\n \n-  void DeleteFakeStack() {\n+  void DeleteFakeStack(int tid) {\n     if (!fake_stack_) return;\n     FakeStack *t = fake_stack_;\n     fake_stack_ = 0;\n     SetTLSFakeStack(0);\n-    t->Destroy();\n+    t->Destroy(tid);\n   }\n \n   bool has_fake_stack() {"}, {"sha": "03d45e3839ba79b9b93a518557e511d24fc0d497", "filename": "libsanitizer/asan/asan_win.cc", "status": "modified", "additions": 5, "deletions": 62, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_win.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fasan%2Fasan_win.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_win.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -33,11 +33,6 @@ extern \"C\" {\n \n namespace __asan {\n \n-// ---------------------- Stacktraces, symbols, etc. ---------------- {{{1\n-static BlockingMutex dbghelp_lock(LINKER_INITIALIZED);\n-static bool dbghelp_initialized = false;\n-#pragma comment(lib, \"dbghelp.lib\")\n-\n // ---------------------- TSD ---------------- {{{1\n static bool tsd_key_inited = false;\n \n@@ -73,17 +68,9 @@ void *AsanDoesNotSupportStaticLinkage() {\n   return 0;\n }\n \n-void SetAlternateSignalStack() {\n-  // FIXME: Decide what to do on Windows.\n-}\n+void AsanCheckDynamicRTPrereqs() { UNIMPLEMENTED(); }\n \n-void UnsetAlternateSignalStack() {\n-  // FIXME: Decide what to do on Windows.\n-}\n-\n-void InstallSignalHandlers() {\n-  // FIXME: Decide what to do on Windows.\n-}\n+void AsanCheckIncompatibleRT() {}\n \n void AsanPlatformThreadInit() {\n   // Nothing here for now.\n@@ -93,54 +80,10 @@ void ReadContextStack(void *context, uptr *stack, uptr *ssize) {\n   UNIMPLEMENTED();\n }\n \n-}  // namespace __asan\n-\n-// ---------------------- Interface ---------------- {{{1\n-using namespace __asan;  // NOLINT\n-\n-extern \"C\" {\n-SANITIZER_INTERFACE_ATTRIBUTE NOINLINE\n-bool __asan_symbolize(const void *addr, char *out_buffer, int buffer_size) {\n-  BlockingMutexLock lock(&dbghelp_lock);\n-  if (!dbghelp_initialized) {\n-    SymSetOptions(SYMOPT_DEFERRED_LOADS |\n-                  SYMOPT_UNDNAME |\n-                  SYMOPT_LOAD_LINES);\n-    CHECK(SymInitialize(GetCurrentProcess(), 0, TRUE));\n-    // FIXME: We don't call SymCleanup() on exit yet - should we?\n-    dbghelp_initialized = true;\n-  }\n-\n-  // See http://msdn.microsoft.com/en-us/library/ms680578(VS.85).aspx\n-  char buffer[sizeof(SYMBOL_INFO) + MAX_SYM_NAME * sizeof(CHAR)];\n-  PSYMBOL_INFO symbol = (PSYMBOL_INFO)buffer;\n-  symbol->SizeOfStruct = sizeof(SYMBOL_INFO);\n-  symbol->MaxNameLen = MAX_SYM_NAME;\n-  DWORD64 offset = 0;\n-  BOOL got_objname = SymFromAddr(GetCurrentProcess(),\n-                                 (DWORD64)addr, &offset, symbol);\n-  if (!got_objname)\n-    return false;\n-\n-  DWORD  unused;\n-  IMAGEHLP_LINE64 info;\n-  info.SizeOfStruct = sizeof(IMAGEHLP_LINE64);\n-  BOOL got_fileline = SymGetLineFromAddr64(GetCurrentProcess(),\n-                                           (DWORD64)addr, &unused, &info);\n-  int written = 0;\n-  out_buffer[0] = '\\0';\n-  // FIXME: it might be useful to print out 'obj' or 'obj+offset' info too.\n-  if (got_fileline) {\n-    written += internal_snprintf(out_buffer + written, buffer_size - written,\n-                        \" %s %s:%d\", symbol->Name,\n-                        info.FileName, info.LineNumber);\n-  } else {\n-    written += internal_snprintf(out_buffer + written, buffer_size - written,\n-                        \" %s+0x%p\", symbol->Name, offset);\n-  }\n-  return true;\n+void AsanOnSIGSEGV(int, void *siginfo, void *context) {\n+  UNIMPLEMENTED();\n }\n-}  // extern \"C\"\n \n+}  // namespace __asan\n \n #endif  // _WIN32"}, {"sha": "bf4c47895362b07ac3a4cd452e311381a37269b7", "filename": "libsanitizer/include/sanitizer/asan_interface.h", "status": "modified", "additions": 25, "deletions": 14, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Finclude%2Fsanitizer%2Fasan_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Finclude%2Fsanitizer%2Fasan_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fasan_interface.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -48,9 +48,10 @@ extern \"C\" {\n   ((void)(addr), (void)(size))\n #endif\n \n-  // Returns true iff addr is poisoned (i.e. 1-byte read/write access to this\n+  // Returns 1 if addr is poisoned (i.e. 1-byte read/write access to this\n   // address will result in error report from AddressSanitizer).\n-  bool __asan_address_is_poisoned(void const volatile *addr);\n+  // Otherwise returns 0.\n+  int __asan_address_is_poisoned(void const volatile *addr);\n \n   // If at least on byte in [beg, beg+size) is poisoned, return the address\n   // of the first such byte. Otherwise return 0.\n@@ -63,7 +64,7 @@ extern \"C\" {\n   // However it is still a part of the interface because users may want to\n   // set a breakpoint on this function in a debugger.\n   void __asan_report_error(void *pc, void *bp, void *sp,\n-                           void *addr, bool is_write, size_t access_size);\n+                           void *addr, int is_write, size_t access_size);\n \n   // Sets the exit code to use when reporting an error.\n   // Returns the old value.\n@@ -80,22 +81,14 @@ extern \"C\" {\n   // the program crashes before ASan report is printed.\n   void __asan_on_error();\n \n-  // User may provide its own implementation for symbolization function.\n-  // It should print the description of instruction at address \"pc\" to\n-  // \"out_buffer\". Description should be at most \"out_size\" bytes long.\n-  // User-specified function should return true if symbolization was\n-  // successful.\n-  bool __asan_symbolize(const void *pc, char *out_buffer,\n-                                       int out_size);\n-\n   // Returns the estimated number of bytes that will be reserved by allocator\n   // for request of \"size\" bytes. If ASan allocator can't allocate that much\n   // memory, returns the maximal possible allocation size, otherwise returns\n   // \"size\".\n   size_t __asan_get_estimated_allocated_size(size_t size);\n-  // Returns true if p was returned by the ASan allocator and\n-  // is not yet freed.\n-  bool __asan_get_ownership(const void *p);\n+  // Returns 1 if p was returned by the ASan allocator and is not yet freed.\n+  // Otherwise returns 0.\n+  int __asan_get_ownership(const void *p);\n   // Returns the number of bytes reserved for the pointer p.\n   // Requires (get_ownership(p) == true) or (p == 0).\n   size_t __asan_get_allocated_size(const void *p);\n@@ -128,6 +121,24 @@ extern \"C\" {\n   //   deallocation of \"ptr\".\n   void __asan_malloc_hook(void *ptr, size_t size);\n   void __asan_free_hook(void *ptr);\n+\n+  // The following 2 functions facilitate garbage collection in presence of\n+  // asan's fake stack.\n+\n+  // Returns an opaque handler to be used later in __asan_addr_is_in_fake_stack.\n+  // Returns NULL if the current thread does not have a fake stack.\n+  void *__asan_get_current_fake_stack();\n+\n+  // If fake_stack is non-NULL and addr belongs to a fake frame in\n+  // fake_stack, returns the address on real stack that corresponds to\n+  // the fake frame and sets beg/end to the boundaries of this fake frame.\n+  // Otherwise returns NULL and does not touch beg/end.\n+  // If beg/end are NULL, they are not touched.\n+  // This function may be called from a thread other than the owner of\n+  // fake_stack, but the owner thread need to be alive.\n+  void *__asan_addr_is_in_fake_stack(void *fake_stack, void *addr, void **beg,\n+                                     void **end);\n+\n #ifdef __cplusplus\n }  // extern \"C\"\n #endif"}, {"sha": "44870a039b4fba0d664ae2a70c1abdf70a000471", "filename": "libsanitizer/include/sanitizer/common_interface_defs.h", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Finclude%2Fsanitizer%2Fcommon_interface_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Finclude%2Fsanitizer%2Fcommon_interface_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fcommon_interface_defs.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -22,13 +22,28 @@\n #ifdef __cplusplus\n extern \"C\" {\n #endif\n+  // Arguments for __sanitizer_sandbox_on_notify() below.\n+  typedef struct {\n+    // Enable sandbox support in sanitizer coverage.\n+    int coverage_sandboxed;\n+    // File descriptor to write coverage data to. If -1 is passed, a file will\n+    // be pre-opened by __sanitizer_sandobx_on_notify(). This field has no\n+    // effect if coverage_sandboxed == 0.\n+    intptr_t coverage_fd;\n+    // If non-zero, split the coverage data into well-formed blocks. This is\n+    // useful when coverage_fd is a socket descriptor. Each block will contain\n+    // a header, allowing data from multiple processes to be sent over the same\n+    // socket.\n+    unsigned int coverage_max_block_size;\n+  } __sanitizer_sandbox_arguments;\n+\n   // Tell the tools to write their reports to \"path.<pid>\" instead of stderr.\n   void __sanitizer_set_report_path(const char *path);\n \n   // Notify the tools that the sandbox is going to be turned on. The reserved\n   // parameter will be used in the future to hold a structure with functions\n   // that the tools may call to bypass the sandbox.\n-  void __sanitizer_sandbox_on_notify(void *reserved);\n+  void __sanitizer_sandbox_on_notify(__sanitizer_sandbox_arguments *args);\n \n   // This function is called by the tool when it has just finished reporting\n   // an error. 'error_summary' is a one-line string that summarizes\n@@ -45,6 +60,8 @@ extern \"C\" {\n   void __sanitizer_unaligned_store32(void *p, uint32_t x);\n   void __sanitizer_unaligned_store64(void *p, uint64_t x);\n \n+  // Initialize coverage.\n+  void __sanitizer_cov_init();\n   // Record and dump coverage info.\n   void __sanitizer_cov_dump();\n \n@@ -54,7 +71,7 @@ extern \"C\" {\n   // in a contiguous region of memory. The container owns the region of memory\n   // [beg, end); the memory [beg, mid) is used to store the current elements\n   // and the memory [mid, end) is reserved for future elements;\n-  // end <= mid <= end. For example, in \"std::vector<> v\"\n+  // beg <= mid <= end. For example, in \"std::vector<> v\"\n   //   beg = &v[0];\n   //   end = beg + v.capacity() * sizeof(v[0]);\n   //   mid = beg + v.size()     * sizeof(v[0]);\n@@ -82,6 +99,14 @@ extern \"C\" {\n                                                  const void *end,\n                                                  const void *old_mid,\n                                                  const void *new_mid);\n+  // Returns true if the contiguous container [beg, end) ir properly poisoned\n+  // (e.g. with __sanitizer_annotate_contiguous_container), i.e. if\n+  //  - [beg, mid) is addressable,\n+  //  - [mid, end) is unaddressable.\n+  // Full verification requires O(end-beg) time; this function tries to avoid\n+  // such complexity by touching only parts of the container around beg/mid/end.\n+  int __sanitizer_verify_contiguous_container(const void *beg, const void *mid,\n+                                              const void *end);\n \n   // Print the stack trace leading to this call. Useful for debugging user code.\n   void __sanitizer_print_stack_trace();"}, {"sha": "c1b160205a748ae18a887a414ceb456f74a8a209", "filename": "libsanitizer/include/sanitizer/dfsan_interface.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Finclude%2Fsanitizer%2Fdfsan_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Finclude%2Fsanitizer%2Fdfsan_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fdfsan_interface.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -37,6 +37,9 @@ struct dfsan_label_info {\n   void *userdata;\n };\n \n+/// Signature of the callback argument to dfsan_set_write_callback().\n+typedef void (*dfsan_write_callback_t)(int fd, const void *buf, size_t count);\n+\n /// Computes the union of \\c l1 and \\c l2, possibly creating a union label in\n /// the process.\n dfsan_label dfsan_union(dfsan_label l1, dfsan_label l2);\n@@ -72,6 +75,14 @@ int dfsan_has_label(dfsan_label label, dfsan_label elem);\n /// that label, else returns 0.\n dfsan_label dfsan_has_label_with_desc(dfsan_label label, const char *desc);\n \n+/// Returns the number of labels allocated.\n+size_t dfsan_get_label_count(void);\n+\n+/// Sets a callback to be invoked on calls to write().  The callback is invoked\n+/// before the write is done.  The write is not guaranteed to succeed when the\n+/// callback executes.  Pass in NULL to remove any callback.\n+void dfsan_set_write_callback(dfsan_write_callback_t labeled_write_callback);\n+\n #ifdef __cplusplus\n }  // extern \"C\"\n "}, {"sha": "95e79245ec046f8c528bbdb56115318e17c89542", "filename": "libsanitizer/include/sanitizer/lsan_interface.h", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Finclude%2Fsanitizer%2Flsan_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Finclude%2Fsanitizer%2Flsan_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Flsan_interface.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -21,20 +21,41 @@ extern \"C\" {\n   // be treated as non-leaks. Disable/enable pairs may be nested.\n   void __lsan_disable();\n   void __lsan_enable();\n+\n   // The heap object into which p points will be treated as a non-leak.\n   void __lsan_ignore_object(const void *p);\n-  // The user may optionally provide this function to disallow leak checking\n-  // for the program it is linked into (if the return value is non-zero). This\n-  // function must be defined as returning a constant value; any behavior beyond\n-  // that is unsupported.\n-  int __lsan_is_turned_off();\n+\n+  // Memory regions registered through this interface will be treated as sources\n+  // of live pointers during leak checking. Useful if you store pointers in\n+  // mapped memory.\n+  // Points of note:\n+  // - __lsan_unregister_root_region() must be called with the same pointer and\n+  // size that have earlier been passed to __lsan_register_root_region()\n+  // - LSan will skip any inaccessible memory when scanning a root region. E.g.,\n+  // if you map memory within a larger region that you have mprotect'ed, you can\n+  // register the entire large region.\n+  // - the implementation is not optimized for performance. This interface is\n+  // intended to be used for a small number of relatively static regions.\n+  void __lsan_register_root_region(const void *p, size_t size);\n+  void __lsan_unregister_root_region(const void *p, size_t size);\n+\n   // Calling this function makes LSan enter the leak checking phase immediately.\n   // Use this if normal end-of-process leak checking happens too late (e.g. if\n   // you have intentional memory leaks in your shutdown code). Calling this\n   // function overrides end-of-process leak checking; it must be called at\n   // most once per process. This function will terminate the process if there\n   // are memory leaks and the exit_code flag is non-zero.\n   void __lsan_do_leak_check();\n+\n+  // The user may optionally provide this function to disallow leak checking\n+  // for the program it is linked into (if the return value is non-zero). This\n+  // function must be defined as returning a constant value; any behavior beyond\n+  // that is unsupported.\n+  int __lsan_is_turned_off();\n+\n+  // This function may be optionally provided by the user and should return\n+  // a string containing LSan suppressions.\n+  const char *__lsan_default_suppressions();\n #ifdef __cplusplus\n }  // extern \"C\"\n "}, {"sha": "68e510f19bdf198757db8b24015af80389ef4df0", "filename": "libsanitizer/include/sanitizer/msan_interface.h", "status": "modified", "additions": 14, "deletions": 27, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Finclude%2Fsanitizer%2Fmsan_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Finclude%2Fsanitizer%2Fmsan_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fmsan_interface.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -17,13 +17,10 @@\n #ifdef __cplusplus\n extern \"C\" {\n #endif\n-\n-#if __has_feature(memory_sanitizer)\n   /* Returns a string describing a stack origin.\n      Return NULL if the origin is invalid, or is not a stack origin. */\n   const char *__msan_get_origin_descr_if_stack(uint32_t id);\n \n-\n   /* Set raw origin for the memory range. */\n   void __msan_set_origin(const volatile void *a, size_t size, uint32_t origin);\n \n@@ -39,6 +36,10 @@ extern \"C\" {\n   /* Make memory region fully initialized (without changing its contents). */\n   void __msan_unpoison(const volatile void *a, size_t size);\n \n+  /* Make a null-terminated string fully initialized (without changing its\n+     contents). */\n+  void __msan_unpoison_string(const volatile char *a);\n+\n   /* Make memory region fully uninitialized (without changing its contents). */\n   void __msan_poison(const volatile void *a, size_t size);\n \n@@ -51,6 +52,10 @@ extern \"C\" {\n      memory range, or -1 if the whole range is good. */\n   intptr_t __msan_test_shadow(const volatile void *x, size_t size);\n \n+  /* Checks that memory range is fully initialized, and reports an error if it\n+   * is not. */\n+  void __msan_check_mem_is_initialized(const volatile void *x, size_t size);\n+\n   /* Set exit code when error(s) were detected.\n      Value of 0 means don't change the program exit code. */\n   void __msan_set_exit_code(int exit_code);\n@@ -67,13 +72,13 @@ extern \"C\" {\n      modules that were compiled without the corresponding compiler flag. */\n   void __msan_set_keep_going(int keep_going);\n \n-  /* Print shadow and origin for the memory range to stdout in a human-readable\n+  /* Print shadow and origin for the memory range to stderr in a human-readable\n      format. */\n   void __msan_print_shadow(const volatile void *x, size_t size);\n \n-  /* Print current function arguments shadow and origin to stdout in a\n+  /* Print shadow for the memory range to stderr in a minimalistic\n      human-readable format. */\n-  void __msan_print_param_shadow();\n+  void __msan_dump_shadow(const volatile void *x, size_t size);\n \n   /* Returns true if running under a dynamic tool (DynamoRio-based). */\n   int  __msan_has_dynamic_component();\n@@ -86,6 +91,9 @@ extern \"C\" {\n      a string containing Msan runtime options. See msan_flags.h for details. */\n   const char* __msan_default_options();\n \n+  // Sets the callback to be called right before death on error.\n+  // Passing 0 will unset the callback.\n+  void __msan_set_death_callback(void (*callback)(void));\n \n   /***********************************/\n   /* Allocator statistics interface. */\n@@ -132,27 +140,6 @@ extern \"C\" {\n        deallocation of \"ptr\". */\n   void __msan_malloc_hook(const volatile void *ptr, size_t size);\n   void __msan_free_hook(const volatile void *ptr);\n-\n-#else  // __has_feature(memory_sanitizer)\n-\n-#define __msan_get_origin_descr_if_stack(id) ((const char*)0)\n-#define __msan_set_origin(a, size, origin)\n-#define __msan_get_origin(a) ((uint32_t)-1)\n-#define __msan_get_track_origins() (0)\n-#define __msan_get_umr_origin() ((uint32_t)-1)\n-#define __msan_unpoison(a, size)\n-#define __msan_poison(a, size)\n-#define __msan_partial_poison(data, shadow, size)\n-#define __msan_test_shadow(x, size) ((intptr_t)-1)\n-#define __msan_set_exit_code(exit_code)\n-#define __msan_set_expect_umr(expect_umr)\n-#define __msan_print_shadow(x, size)\n-#define __msan_print_param_shadow()\n-#define __msan_has_dynamic_component() (0)\n-#define __msan_allocated_memory(data, size)\n-\n-#endif   // __has_feature(memory_sanitizer)\n-\n #ifdef __cplusplus\n }  // extern \"C\"\n #endif"}, {"sha": "d19c9109416b681483ddc14a9cc38db7f57abaae", "filename": "libsanitizer/include/sanitizer/tsan_interface_atomic.h", "status": "renamed", "additions": 90, "deletions": 73, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Finclude%2Fsanitizer%2Ftsan_interface_atomic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Finclude%2Fsanitizer%2Ftsan_interface_atomic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Ftsan_interface_atomic.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -7,14 +7,11 @@\n //\n // This file is a part of ThreadSanitizer (TSan), a race detector.\n //\n+// Public interface header for TSan atomics.\n //===----------------------------------------------------------------------===//\n #ifndef TSAN_INTERFACE_ATOMIC_H\n #define TSAN_INTERFACE_ATOMIC_H\n \n-#ifndef INTERFACE_ATTRIBUTE\n-# define INTERFACE_ATTRIBUTE __attribute__((visibility(\"default\")))\n-#endif\n-\n #ifdef __cplusplus\n extern \"C\" {\n #endif\n@@ -23,14 +20,12 @@ typedef char     __tsan_atomic8;\n typedef short    __tsan_atomic16;  // NOLINT\n typedef int      __tsan_atomic32;\n typedef long     __tsan_atomic64;  // NOLINT\n-\n #if defined(__SIZEOF_INT128__) \\\n     || (__clang_major__ * 100 + __clang_minor__ >= 302)\n __extension__ typedef __int128 __tsan_atomic128;\n-#define __TSAN_HAS_INT128 1\n+# define __TSAN_HAS_INT128 1\n #else\n-typedef char     __tsan_atomic128;\n-#define __TSAN_HAS_INT128 0\n+# define __TSAN_HAS_INT128 0\n #endif\n \n // Part of ABI, do not change.\n@@ -45,159 +40,181 @@ typedef enum {\n } __tsan_memory_order;\n \n __tsan_atomic8 __tsan_atomic8_load(const volatile __tsan_atomic8 *a,\n-    __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n+    __tsan_memory_order mo);\n __tsan_atomic16 __tsan_atomic16_load(const volatile __tsan_atomic16 *a,\n-    __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n+    __tsan_memory_order mo);\n __tsan_atomic32 __tsan_atomic32_load(const volatile __tsan_atomic32 *a,\n-    __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n+    __tsan_memory_order mo);\n __tsan_atomic64 __tsan_atomic64_load(const volatile __tsan_atomic64 *a,\n-    __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n+    __tsan_memory_order mo);\n+#if __TSAN_HAS_INT128\n __tsan_atomic128 __tsan_atomic128_load(const volatile __tsan_atomic128 *a,\n-    __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n+    __tsan_memory_order mo);\n+#endif\n \n void __tsan_atomic8_store(volatile __tsan_atomic8 *a, __tsan_atomic8 v,\n-    __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n+    __tsan_memory_order mo);\n void __tsan_atomic16_store(volatile __tsan_atomic16 *a, __tsan_atomic16 v,\n-    __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n+    __tsan_memory_order mo);\n void __tsan_atomic32_store(volatile __tsan_atomic32 *a, __tsan_atomic32 v,\n-    __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n+    __tsan_memory_order mo);\n void __tsan_atomic64_store(volatile __tsan_atomic64 *a, __tsan_atomic64 v,\n-    __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n+    __tsan_memory_order mo);\n+#if __TSAN_HAS_INT128\n void __tsan_atomic128_store(volatile __tsan_atomic128 *a, __tsan_atomic128 v,\n-    __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n+    __tsan_memory_order mo);\n+#endif\n \n __tsan_atomic8 __tsan_atomic8_exchange(volatile __tsan_atomic8 *a,\n-    __tsan_atomic8 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n+    __tsan_atomic8 v, __tsan_memory_order mo);\n __tsan_atomic16 __tsan_atomic16_exchange(volatile __tsan_atomic16 *a,\n-    __tsan_atomic16 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n+    __tsan_atomic16 v, __tsan_memory_order mo);\n __tsan_atomic32 __tsan_atomic32_exchange(volatile __tsan_atomic32 *a,\n-    __tsan_atomic32 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n+    __tsan_atomic32 v, __tsan_memory_order mo);\n __tsan_atomic64 __tsan_atomic64_exchange(volatile __tsan_atomic64 *a,\n-    __tsan_atomic64 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n+    __tsan_atomic64 v, __tsan_memory_order mo);\n+#if __TSAN_HAS_INT128\n __tsan_atomic128 __tsan_atomic128_exchange(volatile __tsan_atomic128 *a,\n-    __tsan_atomic128 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n+    __tsan_atomic128 v, __tsan_memory_order mo);\n+#endif\n \n __tsan_atomic8 __tsan_atomic8_fetch_add(volatile __tsan_atomic8 *a,\n-    __tsan_atomic8 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n+    __tsan_atomic8 v, __tsan_memory_order mo);\n __tsan_atomic16 __tsan_atomic16_fetch_add(volatile __tsan_atomic16 *a,\n-    __tsan_atomic16 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n+    __tsan_atomic16 v, __tsan_memory_order mo);\n __tsan_atomic32 __tsan_atomic32_fetch_add(volatile __tsan_atomic32 *a,\n-    __tsan_atomic32 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n+    __tsan_atomic32 v, __tsan_memory_order mo);\n __tsan_atomic64 __tsan_atomic64_fetch_add(volatile __tsan_atomic64 *a,\n-    __tsan_atomic64 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n+    __tsan_atomic64 v, __tsan_memory_order mo);\n+#if __TSAN_HAS_INT128\n __tsan_atomic128 __tsan_atomic128_fetch_add(volatile __tsan_atomic128 *a,\n-    __tsan_atomic128 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n+    __tsan_atomic128 v, __tsan_memory_order mo);\n+#endif\n \n __tsan_atomic8 __tsan_atomic8_fetch_sub(volatile __tsan_atomic8 *a,\n-    __tsan_atomic8 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n+    __tsan_atomic8 v, __tsan_memory_order mo);\n __tsan_atomic16 __tsan_atomic16_fetch_sub(volatile __tsan_atomic16 *a,\n-    __tsan_atomic16 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n+    __tsan_atomic16 v, __tsan_memory_order mo);\n __tsan_atomic32 __tsan_atomic32_fetch_sub(volatile __tsan_atomic32 *a,\n-    __tsan_atomic32 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n+    __tsan_atomic32 v, __tsan_memory_order mo);\n __tsan_atomic64 __tsan_atomic64_fetch_sub(volatile __tsan_atomic64 *a,\n-    __tsan_atomic64 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n+    __tsan_atomic64 v, __tsan_memory_order mo);\n+#if __TSAN_HAS_INT128\n __tsan_atomic128 __tsan_atomic128_fetch_sub(volatile __tsan_atomic128 *a,\n-    __tsan_atomic128 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n+    __tsan_atomic128 v, __tsan_memory_order mo);\n+#endif\n \n __tsan_atomic8 __tsan_atomic8_fetch_and(volatile __tsan_atomic8 *a,\n-    __tsan_atomic8 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n+    __tsan_atomic8 v, __tsan_memory_order mo);\n __tsan_atomic16 __tsan_atomic16_fetch_and(volatile __tsan_atomic16 *a,\n-    __tsan_atomic16 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n+    __tsan_atomic16 v, __tsan_memory_order mo);\n __tsan_atomic32 __tsan_atomic32_fetch_and(volatile __tsan_atomic32 *a,\n-    __tsan_atomic32 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n+    __tsan_atomic32 v, __tsan_memory_order mo);\n __tsan_atomic64 __tsan_atomic64_fetch_and(volatile __tsan_atomic64 *a,\n-    __tsan_atomic64 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n+    __tsan_atomic64 v, __tsan_memory_order mo);\n+#if __TSAN_HAS_INT128\n __tsan_atomic128 __tsan_atomic128_fetch_and(volatile __tsan_atomic128 *a,\n-    __tsan_atomic128 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n+    __tsan_atomic128 v, __tsan_memory_order mo);\n+#endif\n \n __tsan_atomic8 __tsan_atomic8_fetch_or(volatile __tsan_atomic8 *a,\n-    __tsan_atomic8 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n+    __tsan_atomic8 v, __tsan_memory_order mo);\n __tsan_atomic16 __tsan_atomic16_fetch_or(volatile __tsan_atomic16 *a,\n-    __tsan_atomic16 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n+    __tsan_atomic16 v, __tsan_memory_order mo);\n __tsan_atomic32 __tsan_atomic32_fetch_or(volatile __tsan_atomic32 *a,\n-    __tsan_atomic32 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n+    __tsan_atomic32 v, __tsan_memory_order mo);\n __tsan_atomic64 __tsan_atomic64_fetch_or(volatile __tsan_atomic64 *a,\n-    __tsan_atomic64 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n+    __tsan_atomic64 v, __tsan_memory_order mo);\n+#if __TSAN_HAS_INT128\n __tsan_atomic128 __tsan_atomic128_fetch_or(volatile __tsan_atomic128 *a,\n-    __tsan_atomic128 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n+    __tsan_atomic128 v, __tsan_memory_order mo);\n+#endif\n \n __tsan_atomic8 __tsan_atomic8_fetch_xor(volatile __tsan_atomic8 *a,\n-    __tsan_atomic8 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n+    __tsan_atomic8 v, __tsan_memory_order mo);\n __tsan_atomic16 __tsan_atomic16_fetch_xor(volatile __tsan_atomic16 *a,\n-    __tsan_atomic16 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n+    __tsan_atomic16 v, __tsan_memory_order mo);\n __tsan_atomic32 __tsan_atomic32_fetch_xor(volatile __tsan_atomic32 *a,\n-    __tsan_atomic32 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n+    __tsan_atomic32 v, __tsan_memory_order mo);\n __tsan_atomic64 __tsan_atomic64_fetch_xor(volatile __tsan_atomic64 *a,\n-    __tsan_atomic64 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n+    __tsan_atomic64 v, __tsan_memory_order mo);\n+#if __TSAN_HAS_INT128\n __tsan_atomic128 __tsan_atomic128_fetch_xor(volatile __tsan_atomic128 *a,\n-    __tsan_atomic128 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n+    __tsan_atomic128 v, __tsan_memory_order mo);\n+#endif\n \n __tsan_atomic8 __tsan_atomic8_fetch_nand(volatile __tsan_atomic8 *a,\n-    __tsan_atomic8 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n+    __tsan_atomic8 v, __tsan_memory_order mo);\n __tsan_atomic16 __tsan_atomic16_fetch_nand(volatile __tsan_atomic16 *a,\n-    __tsan_atomic16 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n+    __tsan_atomic16 v, __tsan_memory_order mo);\n __tsan_atomic32 __tsan_atomic32_fetch_nand(volatile __tsan_atomic32 *a,\n-    __tsan_atomic32 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n+    __tsan_atomic32 v, __tsan_memory_order mo);\n __tsan_atomic64 __tsan_atomic64_fetch_nand(volatile __tsan_atomic64 *a,\n-    __tsan_atomic64 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n+    __tsan_atomic64 v, __tsan_memory_order mo);\n+#if __TSAN_HAS_INT128\n __tsan_atomic128 __tsan_atomic128_fetch_nand(volatile __tsan_atomic128 *a,\n-    __tsan_atomic128 v, __tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n+    __tsan_atomic128 v, __tsan_memory_order mo);\n+#endif\n \n int __tsan_atomic8_compare_exchange_weak(volatile __tsan_atomic8 *a,\n     __tsan_atomic8 *c, __tsan_atomic8 v, __tsan_memory_order mo,\n-    __tsan_memory_order fail_mo) INTERFACE_ATTRIBUTE;\n+    __tsan_memory_order fail_mo);\n int __tsan_atomic16_compare_exchange_weak(volatile __tsan_atomic16 *a,\n     __tsan_atomic16 *c, __tsan_atomic16 v, __tsan_memory_order mo,\n-    __tsan_memory_order fail_mo) INTERFACE_ATTRIBUTE;\n+    __tsan_memory_order fail_mo);\n int __tsan_atomic32_compare_exchange_weak(volatile __tsan_atomic32 *a,\n     __tsan_atomic32 *c, __tsan_atomic32 v, __tsan_memory_order mo,\n-    __tsan_memory_order fail_mo) INTERFACE_ATTRIBUTE;\n+    __tsan_memory_order fail_mo);\n int __tsan_atomic64_compare_exchange_weak(volatile __tsan_atomic64 *a,\n     __tsan_atomic64 *c, __tsan_atomic64 v, __tsan_memory_order mo,\n-    __tsan_memory_order fail_mo) INTERFACE_ATTRIBUTE;\n+    __tsan_memory_order fail_mo);\n+#if __TSAN_HAS_INT128\n int __tsan_atomic128_compare_exchange_weak(volatile __tsan_atomic128 *a,\n     __tsan_atomic128 *c, __tsan_atomic128 v, __tsan_memory_order mo,\n-    __tsan_memory_order fail_mo) INTERFACE_ATTRIBUTE;\n+    __tsan_memory_order fail_mo);\n+#endif\n \n int __tsan_atomic8_compare_exchange_strong(volatile __tsan_atomic8 *a,\n     __tsan_atomic8 *c, __tsan_atomic8 v, __tsan_memory_order mo,\n-    __tsan_memory_order fail_mo) INTERFACE_ATTRIBUTE;\n+    __tsan_memory_order fail_mo);\n int __tsan_atomic16_compare_exchange_strong(volatile __tsan_atomic16 *a,\n     __tsan_atomic16 *c, __tsan_atomic16 v, __tsan_memory_order mo,\n-    __tsan_memory_order fail_mo) INTERFACE_ATTRIBUTE;\n+    __tsan_memory_order fail_mo);\n int __tsan_atomic32_compare_exchange_strong(volatile __tsan_atomic32 *a,\n     __tsan_atomic32 *c, __tsan_atomic32 v, __tsan_memory_order mo,\n-    __tsan_memory_order fail_mo) INTERFACE_ATTRIBUTE;\n+    __tsan_memory_order fail_mo);\n int __tsan_atomic64_compare_exchange_strong(volatile __tsan_atomic64 *a,\n     __tsan_atomic64 *c, __tsan_atomic64 v, __tsan_memory_order mo,\n-    __tsan_memory_order fail_mo) INTERFACE_ATTRIBUTE;\n+    __tsan_memory_order fail_mo);\n+#if __TSAN_HAS_INT128\n int __tsan_atomic128_compare_exchange_strong(volatile __tsan_atomic128 *a,\n     __tsan_atomic128 *c, __tsan_atomic128 v, __tsan_memory_order mo,\n-    __tsan_memory_order fail_mo) INTERFACE_ATTRIBUTE;\n+    __tsan_memory_order fail_mo);\n+#endif\n \n __tsan_atomic8 __tsan_atomic8_compare_exchange_val(\n     volatile __tsan_atomic8 *a, __tsan_atomic8 c, __tsan_atomic8 v,\n-    __tsan_memory_order mo, __tsan_memory_order fail_mo) INTERFACE_ATTRIBUTE;\n+    __tsan_memory_order mo, __tsan_memory_order fail_mo);\n __tsan_atomic16 __tsan_atomic16_compare_exchange_val(\n     volatile __tsan_atomic16 *a, __tsan_atomic16 c, __tsan_atomic16 v,\n-    __tsan_memory_order mo, __tsan_memory_order fail_mo) INTERFACE_ATTRIBUTE;\n+    __tsan_memory_order mo, __tsan_memory_order fail_mo);\n __tsan_atomic32 __tsan_atomic32_compare_exchange_val(\n     volatile __tsan_atomic32 *a, __tsan_atomic32 c, __tsan_atomic32 v,\n-    __tsan_memory_order mo, __tsan_memory_order fail_mo) INTERFACE_ATTRIBUTE;\n+    __tsan_memory_order mo, __tsan_memory_order fail_mo);\n __tsan_atomic64 __tsan_atomic64_compare_exchange_val(\n     volatile __tsan_atomic64 *a, __tsan_atomic64 c, __tsan_atomic64 v,\n-    __tsan_memory_order mo, __tsan_memory_order fail_mo) INTERFACE_ATTRIBUTE;\n+    __tsan_memory_order mo, __tsan_memory_order fail_mo);\n+#if __TSAN_HAS_INT128\n __tsan_atomic128 __tsan_atomic128_compare_exchange_val(\n     volatile __tsan_atomic128 *a, __tsan_atomic128 c, __tsan_atomic128 v,\n-    __tsan_memory_order mo, __tsan_memory_order fail_mo) INTERFACE_ATTRIBUTE;\n+    __tsan_memory_order mo, __tsan_memory_order fail_mo);\n+#endif\n \n-void __tsan_atomic_thread_fence(__tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n-void __tsan_atomic_signal_fence(__tsan_memory_order mo) INTERFACE_ATTRIBUTE;\n+void __tsan_atomic_thread_fence(__tsan_memory_order mo);\n+void __tsan_atomic_signal_fence(__tsan_memory_order mo);\n \n #ifdef __cplusplus\n }  // extern \"C\"\n #endif\n \n-#undef INTERFACE_ATTRIBUTE\n-\n-#endif  // #ifndef TSAN_INTERFACE_ATOMIC_H\n+#endif  // TSAN_INTERFACE_ATOMIC_H", "previous_filename": "libsanitizer/tsan/tsan_interface_atomic.h"}, {"sha": "51505e1baa2ecfcf22c796cc0fdaec9ddd96dd3e", "filename": "libsanitizer/interception/interception.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Finterception%2Finterception.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Finterception%2Finterception.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -13,7 +13,8 @@\n #ifndef INTERCEPTION_H\n #define INTERCEPTION_H\n \n-#if !defined(__linux__) && !defined(__APPLE__) && !defined(_WIN32)\n+#if !defined(__linux__) && !defined(__FreeBSD__) && \\\n+  !defined(__APPLE__) && !defined(_WIN32)\n # error \"Interception doesn't work on this operating system.\"\n #endif\n \n@@ -233,11 +234,11 @@ typedef unsigned long uptr;  // NOLINT\n \n #define INCLUDED_FROM_INTERCEPTION_LIB\n \n-#if defined(__linux__)\n+#if defined(__linux__) || defined(__FreeBSD__)\n # include \"interception_linux.h\"\n-# define INTERCEPT_FUNCTION(func) INTERCEPT_FUNCTION_LINUX(func)\n+# define INTERCEPT_FUNCTION(func) INTERCEPT_FUNCTION_LINUX_OR_FREEBSD(func)\n # define INTERCEPT_FUNCTION_VER(func, symver) \\\n-    INTERCEPT_FUNCTION_VER_LINUX(func, symver)\n+    INTERCEPT_FUNCTION_VER_LINUX_OR_FREEBSD(func, symver)\n #elif defined(__APPLE__)\n # include \"interception_mac.h\"\n # define INTERCEPT_FUNCTION(func) INTERCEPT_FUNCTION_MAC(func)"}, {"sha": "0a8305b0bf82aefe765ad8d34b56b776fc54888f", "filename": "libsanitizer/interception/interception_linux.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Finterception%2Finterception_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Finterception%2Finterception_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception_linux.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -10,10 +10,10 @@\n // Linux-specific interception methods.\n //===----------------------------------------------------------------------===//\n \n-#ifdef __linux__\n+#if defined(__linux__) || defined(__FreeBSD__)\n #include \"interception.h\"\n \n-#include <dlfcn.h>   // for dlsym\n+#include <dlfcn.h>   // for dlsym() and dlvsym()\n \n namespace __interception {\n bool GetRealFunctionAddress(const char *func_name, uptr *func_addr,\n@@ -31,4 +31,4 @@ void *GetFuncAddrVer(const char *func_name, const char *ver) {\n }  // namespace __interception\n \n \n-#endif  // __linux__\n+#endif  // __linux__ || __FreeBSD__"}, {"sha": "e2cc4c19dffe87158b9aa1a819d611ccf4346758", "filename": "libsanitizer/interception/interception_linux.h", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Finterception%2Finterception_linux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Finterception%2Finterception_linux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception_linux.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -10,7 +10,7 @@\n // Linux-specific interception methods.\n //===----------------------------------------------------------------------===//\n \n-#ifdef __linux__\n+#if defined(__linux__) || defined(__FreeBSD__)\n \n #if !defined(INCLUDED_FROM_INTERCEPTION_LIB)\n # error \"interception_linux.h should be included from interception library only\"\n@@ -26,20 +26,20 @@ bool GetRealFunctionAddress(const char *func_name, uptr *func_addr,\n void *GetFuncAddrVer(const char *func_name, const char *ver);\n }  // namespace __interception\n \n-#define INTERCEPT_FUNCTION_LINUX(func) \\\n-    ::__interception::GetRealFunctionAddress( \\\n-          #func, (::__interception::uptr*)&REAL(func), \\\n-          (::__interception::uptr)&(func), \\\n-          (::__interception::uptr)&WRAP(func))\n+#define INTERCEPT_FUNCTION_LINUX_OR_FREEBSD(func)                          \\\n+  ::__interception::GetRealFunctionAddress(                                \\\n+      #func, (::__interception::uptr *)&__interception::PTR_TO_REAL(func), \\\n+      (::__interception::uptr) & (func),                                   \\\n+      (::__interception::uptr) & WRAP(func))\n \n #if !defined(__ANDROID__)  // android does not have dlvsym\n-# define INTERCEPT_FUNCTION_VER_LINUX(func, symver) \\\n+# define INTERCEPT_FUNCTION_VER_LINUX_OR_FREEBSD(func, symver) \\\n      ::__interception::real_##func = (func##_f)(unsigned long) \\\n          ::__interception::GetFuncAddrVer(#func, symver)\n #else\n-# define INTERCEPT_FUNCTION_VER_LINUX(func, symver) \\\n-     INTERCEPT_FUNCTION_LINUX(func)\n+# define INTERCEPT_FUNCTION_VER_LINUX_OR_FREEBSD(func, symver) \\\n+     INTERCEPT_FUNCTION_LINUX_OR_FREEBSD(func)\n #endif  // !defined(__ANDROID__)\n \n #endif  // INTERCEPTION_LINUX_H\n-#endif  // __linux__\n+#endif  // __linux__ || __FreeBSD__"}, {"sha": "6ba45e26ddac5c676ef545e3ee6ae19f4e01fb88", "filename": "libsanitizer/interception/interception_type_test.cc", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Finterception%2Finterception_type_test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Finterception%2Finterception_type_test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception_type_test.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -17,21 +17,21 @@\n #include <stddef.h>\n #include <stdint.h>\n \n-COMPILER_CHECK(sizeof(SIZE_T) == sizeof(size_t));\n-COMPILER_CHECK(sizeof(SSIZE_T) == sizeof(ssize_t));\n-COMPILER_CHECK(sizeof(PTRDIFF_T) == sizeof(ptrdiff_t));\n-COMPILER_CHECK(sizeof(INTMAX_T) == sizeof(intmax_t));\n+COMPILER_CHECK(sizeof(::SIZE_T) == sizeof(size_t));\n+COMPILER_CHECK(sizeof(::SSIZE_T) == sizeof(ssize_t));\n+COMPILER_CHECK(sizeof(::PTRDIFF_T) == sizeof(ptrdiff_t));\n+COMPILER_CHECK(sizeof(::INTMAX_T) == sizeof(intmax_t));\n \n #ifndef __APPLE__\n-COMPILER_CHECK(sizeof(OFF64_T) == sizeof(off64_t));\n+COMPILER_CHECK(sizeof(::OFF64_T) == sizeof(off64_t));\n #endif\n \n // The following are the cases when pread (and friends) is used instead of\n // pread64. In those cases we need OFF_T to match off_t. We don't care about the\n // rest (they depend on _FILE_OFFSET_BITS setting when building an application).\n # if defined(__ANDROID__) || !defined _FILE_OFFSET_BITS || \\\n   _FILE_OFFSET_BITS != 64\n-COMPILER_CHECK(sizeof(OFF_T) == sizeof(off_t));\n+COMPILER_CHECK(sizeof(::OFF_T) == sizeof(off_t));\n # endif\n \n #endif"}, {"sha": "9cd717518391f7725d7c15e3875a60bf64c93949", "filename": "libsanitizer/interception/interception_win.cc", "status": "modified", "additions": 91, "deletions": 46, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Finterception%2Finterception_win.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Finterception%2Finterception_win.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception_win.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -54,91 +54,136 @@ static void WriteJumpInstruction(char *jmp_from, char *to) {\n   *(ptrdiff_t*)(jmp_from + 1) = offset;\n }\n \n-bool OverrideFunction(uptr old_func, uptr new_func, uptr *orig_old_func) {\n-#ifdef _WIN64\n-# error OverrideFunction was not tested on x64\n-#endif\n-  // Basic idea:\n-  // We write 5 bytes (jmp-to-new_func) at the beginning of the 'old_func'\n-  // to override it. We want to be able to execute the original 'old_func' from\n-  // the wrapper, so we need to keep the leading 5+ bytes ('head') of the\n-  // original instructions somewhere with a \"jmp old_func+head\".\n-  // We call these 'head'+5 bytes of instructions a \"trampoline\".\n-\n+static char *GetMemoryForTrampoline(size_t size) {\n   // Trampolines are allocated from a common pool.\n   const int POOL_SIZE = 1024;\n   static char *pool = NULL;\n   static size_t pool_used = 0;\n-  if (pool == NULL) {\n-    pool = (char*)VirtualAlloc(NULL, POOL_SIZE,\n-                               MEM_RESERVE | MEM_COMMIT,\n-                               PAGE_EXECUTE_READWRITE);\n-    // FIXME: set PAGE_EXECUTE_READ access after setting all interceptors?\n-    if (pool == NULL)\n-      return false;\n+  if (!pool) {\n+    pool = (char *)VirtualAlloc(NULL, POOL_SIZE, MEM_RESERVE | MEM_COMMIT,\n+                                PAGE_EXECUTE_READWRITE);\n+    // FIXME: Might want to apply PAGE_EXECUTE_READ access after all the\n+    // interceptors are in place.\n+    if (!pool)\n+      return NULL;\n     _memset(pool, 0xCC /* int 3 */, POOL_SIZE);\n   }\n \n-  char* old_bytes = (char*)old_func;\n-  char* trampoline = pool + pool_used;\n+  if (pool_used + size > POOL_SIZE)\n+    return NULL;\n \n-  // Find out the number of bytes of the instructions we need to copy to the\n-  // island and store it in 'head'.\n-  size_t head = 0;\n-  while (head < 5) {\n-    switch (old_bytes[head]) {\n+  char *ret = pool + pool_used;\n+  pool_used += size;\n+  return ret;\n+}\n+\n+// Returns 0 on error.\n+static size_t RoundUpToInstrBoundary(size_t size, char *code) {\n+  size_t cursor = 0;\n+  while (cursor < size) {\n+    switch (code[cursor]) {\n+      case '\\x51':  // push ecx\n+      case '\\x52':  // push edx\n+      case '\\x53':  // push ebx\n+      case '\\x54':  // push esp\n       case '\\x55':  // push ebp\n       case '\\x56':  // push esi\n       case '\\x57':  // push edi\n-        head++;\n+      case '\\x5D':  // pop ebp\n+        cursor++;\n+        continue;\n+      case '\\x6A':  // 6A XX = push XX\n+        cursor += 2;\n+        continue;\n+      case '\\xE9':  // E9 XX YY ZZ WW = jmp WWZZYYXX\n+        cursor += 5;\n         continue;\n     }\n-    switch (*(unsigned short*)(old_bytes + head)) {  // NOLINT\n+    switch (*(unsigned short*)(code + cursor)) {  // NOLINT\n       case 0xFF8B:  // 8B FF = mov edi, edi\n       case 0xEC8B:  // 8B EC = mov ebp, esp\n       case 0xC033:  // 33 C0 = xor eax, eax\n-        head += 2;\n+        cursor += 2;\n         continue;\n+      case 0x458B:  // 8B 45 XX = mov eax, dword ptr [ebp+XXh]\n+      case 0x5D8B:  // 8B 5D XX = mov ebx, dword ptr [ebp+XXh]\n       case 0xEC83:  // 83 EC XX = sub esp, XX\n-        head += 3;\n+        cursor += 3;\n         continue;\n       case 0xC1F7:  // F7 C1 XX YY ZZ WW = test ecx, WWZZYYXX\n-        head += 6;\n+        cursor += 6;\n+        continue;\n+      case 0x3D83:  // 83 3D XX YY ZZ WW TT = cmp TT, WWZZYYXX\n+        cursor += 7;\n         continue;\n     }\n-    switch (0x00FFFFFF & *(unsigned int*)(old_bytes + head)) {\n+    switch (0x00FFFFFF & *(unsigned int*)(code + cursor)) {\n       case 0x24448A:  // 8A 44 24 XX = mov eal, dword ptr [esp+XXh]\n       case 0x244C8B:  // 8B 4C 24 XX = mov ecx, dword ptr [esp+XXh]\n       case 0x24548B:  // 8B 54 24 XX = mov edx, dword ptr [esp+XXh]\n+      case 0x24748B:  // 8B 74 24 XX = mov esi, dword ptr [esp+XXh]\n       case 0x247C8B:  // 8B 7C 24 XX = mov edi, dword ptr [esp+XXh]\n-        head += 4;\n+        cursor += 4;\n         continue;\n     }\n \n     // Unknown instruction!\n-    return false;\n+    // FIXME: Unknown instruction failures might happen when we add a new\n+    // interceptor or a new compiler version. In either case, they should result\n+    // in visible and readable error messages. However, merely calling abort()\n+    // or __debugbreak() leads to an infinite recursion in CheckFailed.\n+    // Do we have a good way to abort with an error message here?\n+    return 0;\n   }\n \n-  if (pool_used + head + 5 > POOL_SIZE)\n-    return false;\n+  return cursor;\n+}\n+\n+bool OverrideFunction(uptr old_func, uptr new_func, uptr *orig_old_func) {\n+#ifdef _WIN64\n+#error OverrideFunction is not yet supported on x64\n+#endif\n+  // Function overriding works basically like this:\n+  // We write \"jmp <new_func>\" (5 bytes) at the beginning of the 'old_func'\n+  // to override it.\n+  // We might want to be able to execute the original 'old_func' from the\n+  // wrapper, in this case we need to keep the leading 5+ bytes ('head')\n+  // of the original code somewhere with a \"jmp <old_func+head>\".\n+  // We call these 'head'+5 bytes of instructions a \"trampoline\".\n+  char *old_bytes = (char *)old_func;\n+\n+  // We'll need at least 5 bytes for a 'jmp'.\n+  size_t head = 5;\n+  if (orig_old_func) {\n+    // Find out the number of bytes of the instructions we need to copy\n+    // to the trampoline and store it in 'head'.\n+    head = RoundUpToInstrBoundary(head, old_bytes);\n+    if (!head)\n+      return false;\n+\n+    // Put the needed instructions into the trampoline bytes.\n+    char *trampoline = GetMemoryForTrampoline(head + 5);\n+    if (!trampoline)\n+      return false;\n+    _memcpy(trampoline, old_bytes, head);\n+    WriteJumpInstruction(trampoline + head, old_bytes + head);\n+    *orig_old_func = (uptr)trampoline;\n+  }\n \n-  // Now put the \"jump to trampoline\" instruction into the original code.\n+  // Now put the \"jmp <new_func>\" instruction at the original code location.\n+  // We should preserve the EXECUTE flag as some of our own code might be\n+  // located in the same page (sic!).  FIXME: might consider putting the\n+  // __interception code into a separate section or something?\n   DWORD old_prot, unused_prot;\n-  if (!VirtualProtect((void*)old_func, head, PAGE_EXECUTE_READWRITE,\n+  if (!VirtualProtect((void *)old_bytes, head, PAGE_EXECUTE_READWRITE,\n                       &old_prot))\n     return false;\n \n-  // Put the needed instructions into the trampoline bytes.\n-  _memcpy(trampoline, old_bytes, head);\n-  WriteJumpInstruction(trampoline + head, old_bytes + head);\n-  *orig_old_func = (uptr)trampoline;\n-  pool_used += head + 5;\n-\n-  // Intercept the 'old_func'.\n-  WriteJumpInstruction(old_bytes, (char*)new_func);\n+  WriteJumpInstruction(old_bytes, (char *)new_func);\n   _memset(old_bytes + 5, 0xCC /* int 3 */, head - 5);\n \n-  if (!VirtualProtect((void*)old_func, head, old_prot, &unused_prot))\n+  // Restore the original permissions.\n+  if (!VirtualProtect((void *)old_bytes, head, old_prot, &unused_prot))\n     return false;  // not clear if this failure bothers us.\n \n   return true;"}, {"sha": "c1481f5fb9712f9182969bcf4ac026a1e7f4cacb", "filename": "libsanitizer/lsan/lsan.cc", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Flsan%2Flsan.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Flsan%2Flsan.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -33,6 +33,11 @@ static void InitializeCommonFlags() {\n   ParseCommonFlagsFromString(cf, GetEnv(\"LSAN_OPTIONS\"));\n }\n \n+///// Interface to the common LSan module. /////\n+bool WordIsPoisoned(uptr addr) {\n+  return false;\n+}\n+\n }  // namespace __lsan\n \n using namespace __lsan;  // NOLINT\n@@ -53,12 +58,7 @@ extern \"C\" void __lsan_init() {\n   ThreadStart(tid, GetTid());\n   SetCurrentThread(tid);\n \n-  // Start symbolizer process if necessary.\n-  if (common_flags()->symbolize) {\n-    Symbolizer::Init(common_flags()->external_symbolizer_path);\n-  } else {\n-    Symbolizer::Disable();\n-  }\n+  Symbolizer::Init(common_flags()->external_symbolizer_path);\n \n   InitCommonLsan();\n   if (common_flags()->detect_leaks && common_flags()->leak_check_at_exit)"}, {"sha": "3e81ebef2a7c4c5192956049fb04f2a236ab5aa5", "filename": "libsanitizer/lsan/lsan_allocator.cc", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Flsan%2Flsan_allocator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Flsan%2Flsan_allocator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_allocator.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -141,7 +141,11 @@ uptr PointsIntoChunk(void* p) {\n   if (addr < chunk) return 0;\n   ChunkMetadata *m = Metadata(reinterpret_cast<void *>(chunk));\n   CHECK(m);\n-  if (m->allocated && addr < chunk + m->requested_size)\n+  if (!m->allocated)\n+    return 0;\n+  if (addr < chunk + m->requested_size)\n+    return chunk;\n+  if (IsSpecialCaseOfOperatorNew0(chunk, m->requested_size, addr))\n     return chunk;\n   return 0;\n }"}, {"sha": "78afa7706d6b64d29d152c22538ab6f2c81c1f95", "filename": "libsanitizer/lsan/lsan_common.cc", "status": "modified", "additions": 238, "deletions": 112, "changes": 350, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Flsan%2Flsan_common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Flsan%2Flsan_common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_common.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -15,6 +15,7 @@\n #include \"sanitizer_common/sanitizer_common.h\"\n #include \"sanitizer_common/sanitizer_flags.h\"\n #include \"sanitizer_common/sanitizer_placement_new.h\"\n+#include \"sanitizer_common/sanitizer_procmaps.h\"\n #include \"sanitizer_common/sanitizer_stackdepot.h\"\n #include \"sanitizer_common/sanitizer_stacktrace.h\"\n #include \"sanitizer_common/sanitizer_stoptheworld.h\"\n@@ -24,7 +25,8 @@\n #if CAN_SANITIZE_LEAKS\n namespace __lsan {\n \n-// This mutex is used to prevent races between DoLeakCheck and IgnoreObject.\n+// This mutex is used to prevent races between DoLeakCheck and IgnoreObject, and\n+// also to protect the global list of root regions.\n BlockingMutex global_mutex(LINKER_INITIALIZED);\n \n THREADLOCAL int disable_counter;\n@@ -39,42 +41,56 @@ static void InitializeFlags() {\n   f->resolution = 0;\n   f->max_leaks = 0;\n   f->exitcode = 23;\n+  f->print_suppressions = true;\n   f->suppressions=\"\";\n   f->use_registers = true;\n   f->use_globals = true;\n   f->use_stacks = true;\n   f->use_tls = true;\n+  f->use_root_regions = true;\n   f->use_unaligned = false;\n-  f->verbosity = 0;\n+  f->use_poisoned = false;\n   f->log_pointers = false;\n   f->log_threads = false;\n \n   const char *options = GetEnv(\"LSAN_OPTIONS\");\n   if (options) {\n-    ParseFlag(options, &f->use_registers, \"use_registers\");\n-    ParseFlag(options, &f->use_globals, \"use_globals\");\n-    ParseFlag(options, &f->use_stacks, \"use_stacks\");\n-    ParseFlag(options, &f->use_tls, \"use_tls\");\n-    ParseFlag(options, &f->use_unaligned, \"use_unaligned\");\n-    ParseFlag(options, &f->report_objects, \"report_objects\");\n-    ParseFlag(options, &f->resolution, \"resolution\");\n+    ParseFlag(options, &f->use_registers, \"use_registers\", \"\");\n+    ParseFlag(options, &f->use_globals, \"use_globals\", \"\");\n+    ParseFlag(options, &f->use_stacks, \"use_stacks\", \"\");\n+    ParseFlag(options, &f->use_tls, \"use_tls\", \"\");\n+    ParseFlag(options, &f->use_root_regions, \"use_root_regions\", \"\");\n+    ParseFlag(options, &f->use_unaligned, \"use_unaligned\", \"\");\n+    ParseFlag(options, &f->use_poisoned, \"use_poisoned\", \"\");\n+    ParseFlag(options, &f->report_objects, \"report_objects\", \"\");\n+    ParseFlag(options, &f->resolution, \"resolution\", \"\");\n     CHECK_GE(&f->resolution, 0);\n-    ParseFlag(options, &f->max_leaks, \"max_leaks\");\n+    ParseFlag(options, &f->max_leaks, \"max_leaks\", \"\");\n     CHECK_GE(&f->max_leaks, 0);\n-    ParseFlag(options, &f->verbosity, \"verbosity\");\n-    ParseFlag(options, &f->log_pointers, \"log_pointers\");\n-    ParseFlag(options, &f->log_threads, \"log_threads\");\n-    ParseFlag(options, &f->exitcode, \"exitcode\");\n-    ParseFlag(options, &f->suppressions, \"suppressions\");\n+    ParseFlag(options, &f->log_pointers, \"log_pointers\", \"\");\n+    ParseFlag(options, &f->log_threads, \"log_threads\", \"\");\n+    ParseFlag(options, &f->exitcode, \"exitcode\", \"\");\n+    ParseFlag(options, &f->print_suppressions, \"print_suppressions\", \"\");\n+    ParseFlag(options, &f->suppressions, \"suppressions\", \"\");\n   }\n }\n \n+#define LOG_POINTERS(...)                           \\\n+  do {                                              \\\n+    if (flags()->log_pointers) Report(__VA_ARGS__); \\\n+  } while (0);\n+\n+#define LOG_THREADS(...)                           \\\n+  do {                                             \\\n+    if (flags()->log_threads) Report(__VA_ARGS__); \\\n+  } while (0);\n+\n SuppressionContext *suppression_ctx;\n \n void InitializeSuppressions() {\n   CHECK(!suppression_ctx);\n-  ALIGNED(64) static char placeholder_[sizeof(SuppressionContext)];\n-  suppression_ctx = new(placeholder_) SuppressionContext;\n+  ALIGNED(64) static char placeholder[sizeof(SuppressionContext)];\n+  suppression_ctx = new(placeholder) SuppressionContext;\n   char *suppressions_from_file;\n   uptr buffer_size;\n   if (ReadFileToBuffer(flags()->suppressions, &suppressions_from_file,\n@@ -89,8 +105,22 @@ void InitializeSuppressions() {\n     suppression_ctx->Parse(__lsan_default_suppressions());\n }\n \n+struct RootRegion {\n+  const void *begin;\n+  uptr size;\n+};\n+\n+InternalMmapVector<RootRegion> *root_regions;\n+\n+void InitializeRootRegions() {\n+  CHECK(!root_regions);\n+  ALIGNED(64) static char placeholder[sizeof(InternalMmapVector<RootRegion>)];\n+  root_regions = new(placeholder) InternalMmapVector<RootRegion>(1);\n+}\n+\n void InitCommonLsan() {\n   InitializeFlags();\n+  InitializeRootRegions();\n   if (common_flags()->detect_leaks) {\n     // Initialization which can fail or print warnings should only be done if\n     // LSan is actually enabled.\n@@ -130,8 +160,7 @@ void ScanRangeForPointers(uptr begin, uptr end,\n                           Frontier *frontier,\n                           const char *region_type, ChunkTag tag) {\n   const uptr alignment = flags()->pointer_alignment();\n-  if (flags()->log_pointers)\n-    Report(\"Scanning %s range %p-%p.\\n\", region_type, begin, end);\n+  LOG_POINTERS(\"Scanning %s range %p-%p.\\n\", region_type, begin, end);\n   uptr pp = begin;\n   if (pp % alignment)\n     pp = pp + alignment - pp % alignment;\n@@ -146,10 +175,19 @@ void ScanRangeForPointers(uptr begin, uptr end,\n     // Reachable beats ignored beats leaked.\n     if (m.tag() == kReachable) continue;\n     if (m.tag() == kIgnored && tag != kReachable) continue;\n+\n+    // Do this check relatively late so we can log only the interesting cases.\n+    if (!flags()->use_poisoned && WordIsPoisoned(pp)) {\n+      LOG_POINTERS(\n+          \"%p is poisoned: ignoring %p pointing into chunk %p-%p of size \"\n+          \"%zu.\\n\",\n+          pp, p, chunk, chunk + m.requested_size(), m.requested_size());\n+      continue;\n+    }\n+\n     m.set_tag(tag);\n-    if (flags()->log_pointers)\n-      Report(\"%p: found %p pointing into chunk %p-%p of size %zu.\\n\", pp, p,\n-             chunk, chunk + m.requested_size(), m.requested_size());\n+    LOG_POINTERS(\"%p: found %p pointing into chunk %p-%p of size %zu.\\n\", pp, p,\n+                 chunk, chunk + m.requested_size(), m.requested_size());\n     if (frontier)\n       frontier->push_back(chunk);\n   }\n@@ -168,16 +206,15 @@ static void ProcessThreads(SuspendedThreadsList const &suspended_threads,\n   uptr registers_end = registers_begin + registers.size();\n   for (uptr i = 0; i < suspended_threads.thread_count(); i++) {\n     uptr os_id = static_cast<uptr>(suspended_threads.GetThreadID(i));\n-    if (flags()->log_threads) Report(\"Processing thread %d.\\n\", os_id);\n+    LOG_THREADS(\"Processing thread %d.\\n\", os_id);\n     uptr stack_begin, stack_end, tls_begin, tls_end, cache_begin, cache_end;\n     bool thread_found = GetThreadRangesLocked(os_id, &stack_begin, &stack_end,\n                                               &tls_begin, &tls_end,\n                                               &cache_begin, &cache_end);\n     if (!thread_found) {\n       // If a thread can't be found in the thread registry, it's probably in the\n       // process of destruction. Log this event and move on.\n-      if (flags()->log_threads)\n-        Report(\"Thread %d not found in registry.\\n\", os_id);\n+      LOG_THREADS(\"Thread %d not found in registry.\\n\", os_id);\n       continue;\n     }\n     uptr sp;\n@@ -194,14 +231,12 @@ static void ProcessThreads(SuspendedThreadsList const &suspended_threads,\n                            \"REGISTERS\", kReachable);\n \n     if (flags()->use_stacks) {\n-      if (flags()->log_threads)\n-        Report(\"Stack at %p-%p, SP = %p.\\n\", stack_begin, stack_end, sp);\n+      LOG_THREADS(\"Stack at %p-%p (SP = %p).\\n\", stack_begin, stack_end, sp);\n       if (sp < stack_begin || sp >= stack_end) {\n         // SP is outside the recorded stack range (e.g. the thread is running a\n         // signal handler on alternate stack). Again, consider the entire stack\n         // range to be reachable.\n-        if (flags()->log_threads)\n-          Report(\"WARNING: stack pointer not in stack range.\\n\");\n+        LOG_THREADS(\"WARNING: stack pointer not in stack range.\\n\");\n       } else {\n         // Shrink the stack range to ignore out-of-scope values.\n         stack_begin = sp;\n@@ -212,7 +247,7 @@ static void ProcessThreads(SuspendedThreadsList const &suspended_threads,\n     }\n \n     if (flags()->use_tls) {\n-      if (flags()->log_threads) Report(\"TLS at %p-%p.\\n\", tls_begin, tls_end);\n+      LOG_THREADS(\"TLS at %p-%p.\\n\", tls_begin, tls_end);\n       if (cache_begin == cache_end) {\n         ScanRangeForPointers(tls_begin, tls_end, frontier, \"TLS\", kReachable);\n       } else {\n@@ -230,6 +265,37 @@ static void ProcessThreads(SuspendedThreadsList const &suspended_threads,\n   }\n }\n \n+static void ProcessRootRegion(Frontier *frontier, uptr root_begin,\n+                              uptr root_end) {\n+  MemoryMappingLayout proc_maps(/*cache_enabled*/true);\n+  uptr begin, end, prot;\n+  while (proc_maps.Next(&begin, &end,\n+                        /*offset*/ 0, /*filename*/ 0, /*filename_size*/ 0,\n+                        &prot)) {\n+    uptr intersection_begin = Max(root_begin, begin);\n+    uptr intersection_end = Min(end, root_end);\n+    if (intersection_begin >= intersection_end) continue;\n+    bool is_readable = prot & MemoryMappingLayout::kProtectionRead;\n+    LOG_POINTERS(\"Root region %p-%p intersects with mapped region %p-%p (%s)\\n\",\n+                 root_begin, root_end, begin, end,\n+                 is_readable ? \"readable\" : \"unreadable\");\n+    if (is_readable)\n+      ScanRangeForPointers(intersection_begin, intersection_end, frontier,\n+                           \"ROOT\", kReachable);\n+  }\n+}\n+\n+// Scans root regions for heap pointers.\n+static void ProcessRootRegions(Frontier *frontier) {\n+  if (!flags()->use_root_regions) return;\n+  CHECK(root_regions);\n+  for (uptr i = 0; i < root_regions->size(); i++) {\n+    RootRegion region = (*root_regions)[i];\n+    uptr begin_addr = reinterpret_cast<uptr>(region.begin);\n+    ProcessRootRegion(frontier, begin_addr, begin_addr + region.size);\n+  }\n+}\n+\n static void FloodFillTag(Frontier *frontier, ChunkTag tag) {\n   while (frontier->size()) {\n     uptr next_chunk = frontier->back();\n@@ -264,30 +330,27 @@ static void CollectIgnoredCb(uptr chunk, void *arg) {\n // Sets the appropriate tag on each chunk.\n static void ClassifyAllChunks(SuspendedThreadsList const &suspended_threads) {\n   // Holds the flood fill frontier.\n-  Frontier frontier(GetPageSizeCached());\n+  Frontier frontier(1);\n \n-  if (flags()->use_globals)\n-    ProcessGlobalRegions(&frontier);\n+  ProcessGlobalRegions(&frontier);\n   ProcessThreads(suspended_threads, &frontier);\n+  ProcessRootRegions(&frontier);\n   FloodFillTag(&frontier, kReachable);\n   // The check here is relatively expensive, so we do this in a separate flood\n   // fill. That way we can skip the check for chunks that are reachable\n   // otherwise.\n-  if (flags()->log_pointers)\n-    Report(\"Processing platform-specific allocations.\\n\");\n+  LOG_POINTERS(\"Processing platform-specific allocations.\\n\");\n   ProcessPlatformSpecificAllocations(&frontier);\n   FloodFillTag(&frontier, kReachable);\n \n-  if (flags()->log_pointers)\n-    Report(\"Scanning ignored chunks.\\n\");\n+  LOG_POINTERS(\"Scanning ignored chunks.\\n\");\n   CHECK_EQ(0, frontier.size());\n   ForEachChunk(CollectIgnoredCb, &frontier);\n   FloodFillTag(&frontier, kIgnored);\n \n   // Iterate over leaked chunks and mark those that are reachable from other\n   // leaked chunks.\n-  if (flags()->log_pointers)\n-    Report(\"Scanning leaked chunks.\\n\");\n+  LOG_POINTERS(\"Scanning leaked chunks.\\n\");\n   ForEachChunk(MarkIndirectlyLeakedCb, 0 /* arg */);\n }\n \n@@ -298,7 +361,8 @@ static void PrintStackTraceById(u32 stack_trace_id) {\n   StackTrace::PrintStack(trace, size);\n }\n \n-// ForEachChunk callback. Aggregates unreachable chunks into a LeakReport.\n+// ForEachChunk callback. Aggregates information about unreachable chunks into\n+// a LeakReport.\n static void CollectLeaksCb(uptr chunk, void *arg) {\n   CHECK(arg);\n   LeakReport *leak_report = reinterpret_cast<LeakReport *>(arg);\n@@ -307,26 +371,17 @@ static void CollectLeaksCb(uptr chunk, void *arg) {\n   if (!m.allocated()) return;\n   if (m.tag() == kDirectlyLeaked || m.tag() == kIndirectlyLeaked) {\n     uptr resolution = flags()->resolution;\n+    u32 stack_trace_id = 0;\n     if (resolution > 0) {\n       uptr size = 0;\n       const uptr *trace = StackDepotGet(m.stack_trace_id(), &size);\n       size = Min(size, resolution);\n-      leak_report->Add(StackDepotPut(trace, size), m.requested_size(), m.tag());\n+      stack_trace_id = StackDepotPut(trace, size);\n     } else {\n-      leak_report->Add(m.stack_trace_id(), m.requested_size(), m.tag());\n+      stack_trace_id = m.stack_trace_id();\n     }\n-  }\n-}\n-\n-// ForEachChunkCallback. Prints addresses of unreachable chunks.\n-static void PrintLeakedCb(uptr chunk, void *arg) {\n-  chunk = GetUserBegin(chunk);\n-  LsanMetadata m(chunk);\n-  if (!m.allocated()) return;\n-  if (m.tag() == kDirectlyLeaked || m.tag() == kIndirectlyLeaked) {\n-    Printf(\"%s leaked %zu byte object at %p.\\n\",\n-           m.tag() == kDirectlyLeaked ? \"Directly\" : \"Indirectly\",\n-           m.requested_size(), chunk);\n+    leak_report->AddLeakedChunk(chunk, stack_trace_id, m.requested_size(),\n+                                m.tag());\n   }\n }\n \n@@ -345,12 +400,6 @@ static void PrintMatchedSuppressions() {\n   Printf(\"%s\\n\\n\", line);\n }\n \n-static void PrintLeaked() {\n-  Printf(\"\\n\");\n-  Printf(\"Reporting individual objects:\\n\");\n-  ForEachChunk(PrintLeakedCb, 0 /* arg */);\n-}\n-\n struct DoLeakCheckParam {\n   bool success;\n   LeakReport leak_report;\n@@ -361,11 +410,8 @@ static void DoLeakCheckCallback(const SuspendedThreadsList &suspended_threads,\n   DoLeakCheckParam *param = reinterpret_cast<DoLeakCheckParam *>(arg);\n   CHECK(param);\n   CHECK(!param->success);\n-  CHECK(param->leak_report.IsEmpty());\n   ClassifyAllChunks(suspended_threads);\n   ForEachChunk(CollectLeaksCb, &param->leak_report);\n-  if (!param->leak_report.IsEmpty() && flags()->report_objects)\n-    PrintLeaked();\n   param->success = true;\n }\n \n@@ -376,7 +422,7 @@ void DoLeakCheck() {\n   if (already_done) return;\n   already_done = true;\n   if (&__lsan_is_turned_off && __lsan_is_turned_off())\n-    return;\n+      return;\n \n   DoLeakCheckParam param;\n   param.success = false;\n@@ -390,36 +436,47 @@ void DoLeakCheck() {\n     Report(\"LeakSanitizer has encountered a fatal error.\\n\");\n     Die();\n   }\n-  uptr have_unsuppressed = param.leak_report.ApplySuppressions();\n-  if (have_unsuppressed) {\n+  param.leak_report.ApplySuppressions();\n+  uptr unsuppressed_count = param.leak_report.UnsuppressedLeakCount();\n+  if (unsuppressed_count > 0) {\n     Decorator d;\n     Printf(\"\\n\"\n            \"=================================================================\"\n            \"\\n\");\n     Printf(\"%s\", d.Error());\n     Report(\"ERROR: LeakSanitizer: detected memory leaks\\n\");\n     Printf(\"%s\", d.End());\n-    param.leak_report.PrintLargest(flags()->max_leaks);\n+    param.leak_report.ReportTopLeaks(flags()->max_leaks);\n   }\n-  if (have_unsuppressed || (flags()->verbosity >= 1)) {\n+  if (flags()->print_suppressions)\n     PrintMatchedSuppressions();\n+  if (unsuppressed_count > 0) {\n     param.leak_report.PrintSummary();\n+    if (flags()->exitcode)\n+      internal__exit(flags()->exitcode);\n   }\n-  if (have_unsuppressed && flags()->exitcode)\n-    internal__exit(flags()->exitcode);\n }\n \n static Suppression *GetSuppressionForAddr(uptr addr) {\n+  Suppression *s;\n+\n+  // Suppress by module name.\n+  const char *module_name;\n+  uptr module_offset;\n+  if (Symbolizer::Get()->GetModuleNameAndOffsetForPC(addr, &module_name,\n+                                                     &module_offset) &&\n+      suppression_ctx->Match(module_name, SuppressionLeak, &s))\n+    return s;\n+\n+  // Suppress by file or function name.\n   static const uptr kMaxAddrFrames = 16;\n   InternalScopedBuffer<AddressInfo> addr_frames(kMaxAddrFrames);\n   for (uptr i = 0; i < kMaxAddrFrames; i++) new (&addr_frames[i]) AddressInfo();\n-  uptr addr_frames_num = Symbolizer::Get()->SymbolizeCode(\n+  uptr addr_frames_num = Symbolizer::Get()->SymbolizePC(\n       addr, addr_frames.data(), kMaxAddrFrames);\n   for (uptr i = 0; i < addr_frames_num; i++) {\n-    Suppression* s;\n     if (suppression_ctx->Match(addr_frames[i].function, SuppressionLeak, &s) ||\n-        suppression_ctx->Match(addr_frames[i].file, SuppressionLeak, &s) ||\n-        suppression_ctx->Match(addr_frames[i].module, SuppressionLeak, &s))\n+        suppression_ctx->Match(addr_frames[i].file, SuppressionLeak, &s))\n       return s;\n   }\n   return 0;\n@@ -439,26 +496,35 @@ static Suppression *GetSuppressionForStack(u32 stack_trace_id) {\n ///// LeakReport implementation. /////\n \n // A hard limit on the number of distinct leaks, to avoid quadratic complexity\n-// in LeakReport::Add(). We don't expect to ever see this many leaks in\n-// real-world applications.\n+// in LeakReport::AddLeakedChunk(). We don't expect to ever see this many leaks\n+// in real-world applications.\n // FIXME: Get rid of this limit by changing the implementation of LeakReport to\n // use a hash table.\n const uptr kMaxLeaksConsidered = 5000;\n \n-void LeakReport::Add(u32 stack_trace_id, uptr leaked_size, ChunkTag tag) {\n+void LeakReport::AddLeakedChunk(uptr chunk, u32 stack_trace_id,\n+                                uptr leaked_size, ChunkTag tag) {\n   CHECK(tag == kDirectlyLeaked || tag == kIndirectlyLeaked);\n   bool is_directly_leaked = (tag == kDirectlyLeaked);\n-  for (uptr i = 0; i < leaks_.size(); i++)\n+  uptr i;\n+  for (i = 0; i < leaks_.size(); i++) {\n     if (leaks_[i].stack_trace_id == stack_trace_id &&\n         leaks_[i].is_directly_leaked == is_directly_leaked) {\n       leaks_[i].hit_count++;\n       leaks_[i].total_size += leaked_size;\n-      return;\n+      break;\n     }\n-  if (leaks_.size() == kMaxLeaksConsidered) return;\n-  Leak leak = { /* hit_count */ 1, leaked_size, stack_trace_id,\n-                is_directly_leaked, /* is_suppressed */ false };\n-  leaks_.push_back(leak);\n+  }\n+  if (i == leaks_.size()) {\n+    if (leaks_.size() == kMaxLeaksConsidered) return;\n+    Leak leak = { next_id_++, /* hit_count */ 1, leaked_size, stack_trace_id,\n+                  is_directly_leaked, /* is_suppressed */ false };\n+    leaks_.push_back(leak);\n+  }\n+  if (flags()->report_objects) {\n+    LeakedObject obj = {leaks_[i].id, chunk, leaked_size};\n+    leaked_objects_.push_back(obj);\n+  }\n }\n \n static bool LeakComparator(const Leak &leak1, const Leak &leak2) {\n@@ -468,39 +534,57 @@ static bool LeakComparator(const Leak &leak1, const Leak &leak2) {\n     return leak1.is_directly_leaked;\n }\n \n-void LeakReport::PrintLargest(uptr num_leaks_to_print) {\n+void LeakReport::ReportTopLeaks(uptr num_leaks_to_report) {\n   CHECK(leaks_.size() <= kMaxLeaksConsidered);\n   Printf(\"\\n\");\n   if (leaks_.size() == kMaxLeaksConsidered)\n     Printf(\"Too many leaks! Only the first %zu leaks encountered will be \"\n            \"reported.\\n\",\n            kMaxLeaksConsidered);\n \n-  uptr unsuppressed_count = 0;\n-  for (uptr i = 0; i < leaks_.size(); i++)\n-    if (!leaks_[i].is_suppressed) unsuppressed_count++;\n-  if (num_leaks_to_print > 0 && num_leaks_to_print < unsuppressed_count)\n-    Printf(\"The %zu largest leak(s):\\n\", num_leaks_to_print);\n+  uptr unsuppressed_count = UnsuppressedLeakCount();\n+  if (num_leaks_to_report > 0 && num_leaks_to_report < unsuppressed_count)\n+    Printf(\"The %zu top leak(s):\\n\", num_leaks_to_report);\n   InternalSort(&leaks_, leaks_.size(), LeakComparator);\n-  uptr leaks_printed = 0;\n-  Decorator d;\n+  uptr leaks_reported = 0;\n   for (uptr i = 0; i < leaks_.size(); i++) {\n     if (leaks_[i].is_suppressed) continue;\n-    Printf(\"%s\", d.Leak());\n-    Printf(\"%s leak of %zu byte(s) in %zu object(s) allocated from:\\n\",\n-           leaks_[i].is_directly_leaked ? \"Direct\" : \"Indirect\",\n-           leaks_[i].total_size, leaks_[i].hit_count);\n-    Printf(\"%s\", d.End());\n-    PrintStackTraceById(leaks_[i].stack_trace_id);\n-    leaks_printed++;\n-    if (leaks_printed == num_leaks_to_print) break;\n+    PrintReportForLeak(i);\n+    leaks_reported++;\n+    if (leaks_reported == num_leaks_to_report) break;\n   }\n-  if (leaks_printed < unsuppressed_count) {\n-    uptr remaining = unsuppressed_count - leaks_printed;\n+  if (leaks_reported < unsuppressed_count) {\n+    uptr remaining = unsuppressed_count - leaks_reported;\n     Printf(\"Omitting %zu more leak(s).\\n\", remaining);\n   }\n }\n \n+void LeakReport::PrintReportForLeak(uptr index) {\n+  Decorator d;\n+  Printf(\"%s\", d.Leak());\n+  Printf(\"%s leak of %zu byte(s) in %zu object(s) allocated from:\\n\",\n+         leaks_[index].is_directly_leaked ? \"Direct\" : \"Indirect\",\n+         leaks_[index].total_size, leaks_[index].hit_count);\n+  Printf(\"%s\", d.End());\n+\n+  PrintStackTraceById(leaks_[index].stack_trace_id);\n+\n+  if (flags()->report_objects) {\n+    Printf(\"Objects leaked above:\\n\");\n+    PrintLeakedObjectsForLeak(index);\n+    Printf(\"\\n\");\n+  }\n+}\n+\n+void LeakReport::PrintLeakedObjectsForLeak(uptr index) {\n+  u32 leak_id = leaks_[index].id;\n+  for (uptr j = 0; j < leaked_objects_.size(); j++) {\n+    if (leaked_objects_[j].leak_id == leak_id)\n+      Printf(\"%p (%zu bytes)\\n\", leaked_objects_[j].addr,\n+             leaked_objects_[j].size);\n+  }\n+}\n+\n void LeakReport::PrintSummary() {\n   CHECK(leaks_.size() <= kMaxLeaksConsidered);\n   uptr bytes = 0, allocations = 0;\n@@ -516,20 +600,24 @@ void LeakReport::PrintSummary() {\n   ReportErrorSummary(summary.data());\n }\n \n-uptr LeakReport::ApplySuppressions() {\n-  uptr unsuppressed_count = 0;\n+void LeakReport::ApplySuppressions() {\n   for (uptr i = 0; i < leaks_.size(); i++) {\n     Suppression *s = GetSuppressionForStack(leaks_[i].stack_trace_id);\n     if (s) {\n       s->weight += leaks_[i].total_size;\n       s->hit_count += leaks_[i].hit_count;\n       leaks_[i].is_suppressed = true;\n-    } else {\n-    unsuppressed_count++;\n     }\n   }\n-  return unsuppressed_count;\n }\n+\n+uptr LeakReport::UnsuppressedLeakCount() {\n+  uptr result = 0;\n+  for (uptr i = 0; i < leaks_.size(); i++)\n+    if (!leaks_[i].is_suppressed) result++;\n+  return result;\n+}\n+\n }  // namespace __lsan\n #endif  // CAN_SANITIZE_LEAKS\n \n@@ -545,13 +633,51 @@ void __lsan_ignore_object(const void *p) {\n   // locked.\n   BlockingMutexLock l(&global_mutex);\n   IgnoreObjectResult res = IgnoreObjectLocked(p);\n-  if (res == kIgnoreObjectInvalid && flags()->verbosity >= 2)\n-    Report(\"__lsan_ignore_object(): no heap object found at %p\", p);\n-  if (res == kIgnoreObjectAlreadyIgnored && flags()->verbosity >= 2)\n-    Report(\"__lsan_ignore_object(): \"\n+  if (res == kIgnoreObjectInvalid)\n+    VReport(1, \"__lsan_ignore_object(): no heap object found at %p\", p);\n+  if (res == kIgnoreObjectAlreadyIgnored)\n+    VReport(1, \"__lsan_ignore_object(): \"\n            \"heap object at %p is already being ignored\\n\", p);\n-  if (res == kIgnoreObjectSuccess && flags()->verbosity >= 3)\n-    Report(\"__lsan_ignore_object(): ignoring heap object at %p\\n\", p);\n+  if (res == kIgnoreObjectSuccess)\n+    VReport(1, \"__lsan_ignore_object(): ignoring heap object at %p\\n\", p);\n+#endif  // CAN_SANITIZE_LEAKS\n+}\n+\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void __lsan_register_root_region(const void *begin, uptr size) {\n+#if CAN_SANITIZE_LEAKS\n+  BlockingMutexLock l(&global_mutex);\n+  CHECK(root_regions);\n+  RootRegion region = {begin, size};\n+  root_regions->push_back(region);\n+  VReport(1, \"Registered root region at %p of size %llu\\n\", begin, size);\n+#endif  // CAN_SANITIZE_LEAKS\n+}\n+\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void __lsan_unregister_root_region(const void *begin, uptr size) {\n+#if CAN_SANITIZE_LEAKS\n+  BlockingMutexLock l(&global_mutex);\n+  CHECK(root_regions);\n+  bool removed = false;\n+  for (uptr i = 0; i < root_regions->size(); i++) {\n+    RootRegion region = (*root_regions)[i];\n+    if (region.begin == begin && region.size == size) {\n+      removed = true;\n+      uptr last_index = root_regions->size() - 1;\n+      (*root_regions)[i] = (*root_regions)[last_index];\n+      root_regions->pop_back();\n+      VReport(1, \"Unregistered root region at %p of size %llu\\n\", begin, size);\n+      break;\n+    }\n+  }\n+  if (!removed) {\n+    Report(\n+        \"__lsan_unregister_root_region(): region at %p of size %llu has not \"\n+        \"been registered.\\n\",\n+        begin, size);\n+    Die();\n+  }\n #endif  // CAN_SANITIZE_LEAKS\n }\n "}, {"sha": "0c84d414be2ed8110c71b039953d08f960364f27", "filename": "libsanitizer/lsan/lsan_common.h", "status": "modified", "additions": 38, "deletions": 9, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Flsan%2Flsan_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Flsan%2Flsan_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_common.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -19,7 +19,7 @@\n #include \"sanitizer_common/sanitizer_platform.h\"\n #include \"sanitizer_common/sanitizer_symbolizer.h\"\n \n-#if SANITIZER_LINUX && defined(__x86_64__)\n+#if SANITIZER_LINUX && defined(__x86_64__) && (SANITIZER_WORDSIZE == 64)\n #define CAN_SANITIZE_LEAKS 1\n #else\n #define CAN_SANITIZE_LEAKS 0\n@@ -49,6 +49,8 @@ struct Flags {\n   int max_leaks;\n   // If nonzero kill the process with this exit code upon finding leaks.\n   int exitcode;\n+  // Print matched suppressions after leak checking.\n+  bool print_suppressions;\n   // Suppressions file name.\n   const char* suppressions;\n \n@@ -61,12 +63,13 @@ struct Flags {\n   bool use_registers;\n   // TLS and thread-specific storage.\n   bool use_tls;\n+  // Regions added via __lsan_register_root_region().\n+  bool use_root_regions;\n \n   // Consider unaligned pointers valid.\n   bool use_unaligned;\n-\n-  // User-visible verbosity.\n-  int verbosity;\n+  // Consider pointers found in poisoned memory to be valid.\n+  bool use_poisoned;\n \n   // Debug logging.\n   bool log_pointers;\n@@ -77,24 +80,39 @@ extern Flags lsan_flags;\n inline Flags *flags() { return &lsan_flags; }\n \n struct Leak {\n+  u32 id;\n   uptr hit_count;\n   uptr total_size;\n   u32 stack_trace_id;\n   bool is_directly_leaked;\n   bool is_suppressed;\n };\n \n+struct LeakedObject {\n+  u32 leak_id;\n+  uptr addr;\n+  uptr size;\n+};\n+\n // Aggregates leaks by stack trace prefix.\n class LeakReport {\n  public:\n-  LeakReport() : leaks_(1) {}\n-  void Add(u32 stack_trace_id, uptr leaked_size, ChunkTag tag);\n-  void PrintLargest(uptr max_leaks);\n+  LeakReport() : next_id_(0), leaks_(1), leaked_objects_(1) {}\n+  void AddLeakedChunk(uptr chunk, u32 stack_trace_id, uptr leaked_size,\n+                      ChunkTag tag);\n+  void ReportTopLeaks(uptr max_leaks);\n   void PrintSummary();\n-  bool IsEmpty() { return leaks_.size() == 0; }\n-  uptr ApplySuppressions();\n+  void ApplySuppressions();\n+  uptr UnsuppressedLeakCount();\n+\n+\n  private:\n+  void PrintReportForLeak(uptr index);\n+  void PrintLeakedObjectsForLeak(uptr index);\n+\n+  u32 next_id_;\n   InternalMmapVector<Leak> leaks_;\n+  InternalMmapVector<LeakedObject> leaked_objects_;\n };\n \n typedef InternalMmapVector<uptr> Frontier;\n@@ -119,6 +137,15 @@ void InitCommonLsan();\n void DoLeakCheck();\n bool DisabledInThisThread();\n \n+// Special case for \"new T[0]\" where T is a type with DTOR.\n+// new T[0] will allocate one word for the array size (0) and store a pointer\n+// to the end of allocated chunk.\n+inline bool IsSpecialCaseOfOperatorNew0(uptr chunk_beg, uptr chunk_size,\n+                                        uptr addr) {\n+  return chunk_size == sizeof(uptr) && chunk_beg + chunk_size == addr &&\n+         *reinterpret_cast<uptr *>(chunk_beg) == 0;\n+}\n+\n // The following must be implemented in the parent tool.\n \n void ForEachChunk(ForEachChunkCallback callback, void *arg);\n@@ -127,6 +154,8 @@ void GetAllocatorGlobalRange(uptr *begin, uptr *end);\n // Wrappers for allocator's ForceLock()/ForceUnlock().\n void LockAllocator();\n void UnlockAllocator();\n+// Returns true if [addr, addr + sizeof(void *)) is poisoned.\n+bool WordIsPoisoned(uptr addr);\n // Wrappers for ThreadRegistry access.\n void LockThreadRegistry();\n void UnlockThreadRegistry();"}, {"sha": "c318fbc4c3b4b3c438bf3d8af31f00fe48e233bf", "filename": "libsanitizer/lsan/lsan_common_linux.cc", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Flsan%2Flsan_common_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Flsan%2Flsan_common_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_common_linux.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -17,6 +17,7 @@\n #include <link.h>\n \n #include \"sanitizer_common/sanitizer_common.h\"\n+#include \"sanitizer_common/sanitizer_flags.h\"\n #include \"sanitizer_common/sanitizer_linux.h\"\n #include \"sanitizer_common/sanitizer_stackdepot.h\"\n \n@@ -41,11 +42,11 @@ void InitializePlatformSpecificModules() {\n     return;\n   }\n   if (num_matches == 0)\n-    Report(\"LeakSanitizer: Dynamic linker not found. \"\n-           \"TLS will not be handled correctly.\\n\");\n+    VReport(1, \"LeakSanitizer: Dynamic linker not found. \"\n+            \"TLS will not be handled correctly.\\n\");\n   else if (num_matches > 1)\n-    Report(\"LeakSanitizer: Multiple modules match \\\"%s\\\". \"\n-           \"TLS will not be handled correctly.\\n\", kLinkerName);\n+    VReport(1, \"LeakSanitizer: Multiple modules match \\\"%s\\\". \"\n+            \"TLS will not be handled correctly.\\n\", kLinkerName);\n   linker = 0;\n }\n \n@@ -81,6 +82,7 @@ static int ProcessGlobalRegionsCallback(struct dl_phdr_info *info, size_t size,\n \n // Scans global variables for heap pointers.\n void ProcessGlobalRegions(Frontier *frontier) {\n+  if (!flags()->use_globals) return;\n   // FIXME: dl_iterate_phdr acquires a linker lock, so we run a risk of\n   // deadlocking by running this under StopTheWorld. However, the lock is\n   // reentrant, so we should be able to fix this by acquiring the lock before\n@@ -127,6 +129,21 @@ static void ProcessPlatformSpecificAllocationsCb(uptr chunk, void *arg) {\n \n // Handles dynamically allocated TLS blocks by treating all chunks allocated\n // from ld-linux.so as reachable.\n+// Dynamic TLS blocks contain the TLS variables of dynamically loaded modules.\n+// They are allocated with a __libc_memalign() call in allocate_and_init()\n+// (elf/dl-tls.c). Glibc won't tell us the address ranges occupied by those\n+// blocks, but we can make sure they come from our own allocator by intercepting\n+// __libc_memalign(). On top of that, there is no easy way to reach them. Their\n+// addresses are stored in a dynamically allocated array (the DTV) which is\n+// referenced from the static TLS. Unfortunately, we can't just rely on the DTV\n+// being reachable from the static TLS, and the dynamic TLS being reachable from\n+// the DTV. This is because the initial DTV is allocated before our interception\n+// mechanism kicks in, and thus we don't recognize it as allocated memory. We\n+// can't special-case it either, since we don't know its size.\n+// Our solution is to include in the root set all allocations made from\n+// ld-linux.so (which is where allocate_and_init() is implemented). This is\n+// guaranteed to include all dynamic TLS blocks (and possibly other allocations\n+// which we don't care about).\n void ProcessPlatformSpecificAllocations(Frontier *frontier) {\n   if (!flags()->use_tls) return;\n   if (!linker) return;"}, {"sha": "dfaad325672e93418d3ed26d83d2d0d6f80aa6ea", "filename": "libsanitizer/lsan/lsan_interceptors.cc", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Flsan%2Flsan_interceptors.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Flsan%2Flsan_interceptors.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_interceptors.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -10,11 +10,11 @@\n //\n //===----------------------------------------------------------------------===//\n \n-#include \"interception/interception.h\"\n #include \"sanitizer_common/sanitizer_allocator.h\"\n #include \"sanitizer_common/sanitizer_atomic.h\"\n #include \"sanitizer_common/sanitizer_common.h\"\n #include \"sanitizer_common/sanitizer_flags.h\"\n+#include \"sanitizer_common/sanitizer_interception.h\"\n #include \"sanitizer_common/sanitizer_internal_defs.h\"\n #include \"sanitizer_common/sanitizer_linux.h\"\n #include \"sanitizer_common/sanitizer_platform_limits_posix.h\"\n@@ -32,19 +32,19 @@ int pthread_key_create(unsigned *key, void (*destructor)(void* v));\n int pthread_setspecific(unsigned key, const void *v);\n }\n \n-#define GET_STACK_TRACE                                                      \\\n-  StackTrace stack;                                                          \\\n-  {                                                                          \\\n-    uptr stack_top = 0, stack_bottom = 0;                                    \\\n-    ThreadContext *t;                                                        \\\n-    bool fast = common_flags()->fast_unwind_on_malloc;                       \\\n-    if (fast && (t = CurrentThreadContext())) {                              \\\n-      stack_top = t->stack_end();                                            \\\n-      stack_bottom = t->stack_begin();                                       \\\n-    }                                                                        \\\n-    stack.Unwind(__sanitizer::common_flags()->malloc_context_size,           \\\n-                 StackTrace::GetCurrentPc(),                                 \\\n-                 GET_CURRENT_FRAME(), stack_top, stack_bottom, fast);        \\\n+#define GET_STACK_TRACE                                              \\\n+  StackTrace stack;                                                  \\\n+  {                                                                  \\\n+    uptr stack_top = 0, stack_bottom = 0;                            \\\n+    ThreadContext *t;                                                \\\n+    bool fast = common_flags()->fast_unwind_on_malloc;               \\\n+    if (fast && (t = CurrentThreadContext())) {                      \\\n+      stack_top = t->stack_end();                                    \\\n+      stack_bottom = t->stack_begin();                               \\\n+    }                                                                \\\n+    stack.Unwind(__sanitizer::common_flags()->malloc_context_size,   \\\n+                 StackTrace::GetCurrentPc(), GET_CURRENT_FRAME(), 0, \\\n+                 stack_top, stack_bottom, fast);                     \\\n   }\n \n #define ENSURE_LSAN_INITED do {   \\\n@@ -150,7 +150,7 @@ INTERCEPTOR(void*, pvalloc, uptr size) {\n   return Allocate(stack, size, GetPageSizeCached(), kAlwaysClearMemory);\n }\n \n-INTERCEPTOR(void, cfree, void *p) ALIAS(\"free\");\n+INTERCEPTOR(void, cfree, void *p) ALIAS(WRAPPER_NAME(free));\n \n #define OPERATOR_NEW_BODY                              \\\n   ENSURE_LSAN_INITED;                                  \\\n@@ -171,9 +171,9 @@ void *operator new[](uptr size, std::nothrow_t const&) { OPERATOR_NEW_BODY; }\n   Deallocate(ptr);\n \n INTERCEPTOR_ATTRIBUTE\n-void operator delete(void *ptr) { OPERATOR_DELETE_BODY; }\n+void operator delete(void *ptr) throw() { OPERATOR_DELETE_BODY; }\n INTERCEPTOR_ATTRIBUTE\n-void operator delete[](void *ptr) { OPERATOR_DELETE_BODY; }\n+void operator delete[](void *ptr) throw() { OPERATOR_DELETE_BODY; }\n INTERCEPTOR_ATTRIBUTE\n void operator delete(void *ptr, std::nothrow_t const&) { OPERATOR_DELETE_BODY; }\n INTERCEPTOR_ATTRIBUTE\n@@ -183,7 +183,8 @@ void operator delete[](void *ptr, std::nothrow_t const &) {\n \n // We need this to intercept the __libc_memalign calls that are used to\n // allocate dynamic TLS space in ld-linux.so.\n-INTERCEPTOR(void *, __libc_memalign, uptr align, uptr s) ALIAS(\"memalign\");\n+INTERCEPTOR(void *, __libc_memalign, uptr align, uptr s)\n+    ALIAS(WRAPPER_NAME(memalign));\n \n ///// Thread initialization and finalization. /////\n \n@@ -236,7 +237,7 @@ INTERCEPTOR(int, pthread_create, void *th, void *attr,\n     pthread_attr_init(&myattr);\n     attr = &myattr;\n   }\n-  AdjustStackSizeLinux(attr);\n+  AdjustStackSize(attr);\n   int detached = 0;\n   pthread_attr_getdetachstate(attr, &detached);\n   ThreadParam p;"}, {"sha": "089c6936e2abda0c511de10d070872a654479d35", "filename": "libsanitizer/sanitizer_common/Makefile.am", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2FMakefile.am?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -22,6 +22,8 @@ sanitizer_common_files = \\\n \tsanitizer_common.cc \\\n \tsanitizer_common_libcdep.cc \\\n \tsanitizer_coverage.cc \\\n+\tsanitizer_deadlock_detector1.cc \\\n+\tsanitizer_deadlock_detector2.cc \\\n \tsanitizer_flags.cc \\\n \tsanitizer_libc.cc \\\n \tsanitizer_libignore.cc \\\n@@ -30,20 +32,23 @@ sanitizer_common_files = \\\n \tsanitizer_mac.cc \\\n \tsanitizer_platform_limits_linux.cc \\\n \tsanitizer_platform_limits_posix.cc \\\n-\tsanitizer_posix_libcdep.cc \\\n \tsanitizer_posix.cc \\\n+\tsanitizer_posix_libcdep.cc \\\n \tsanitizer_printf.cc \\\n+\tsanitizer_procmaps_linux.cc \\\n+\tsanitizer_procmaps_mac.cc \\\n \tsanitizer_stackdepot.cc \\\n \tsanitizer_stacktrace.cc \\\n \tsanitizer_stacktrace_libcdep.cc \\\n \tsanitizer_stoptheworld_linux_libcdep.cc \\\n \tsanitizer_suppressions.cc \\\n-\tsanitizer_symbolizer_posix_libcdep.cc \\\n-\tsanitizer_symbolizer_win.cc \\\n \tsanitizer_symbolizer.cc \\\n \tsanitizer_symbolizer_libbacktrace.cc \\\n \tsanitizer_symbolizer_libcdep.cc \\\n+\tsanitizer_symbolizer_posix_libcdep.cc \\\n+\tsanitizer_symbolizer_win.cc \\\n \tsanitizer_thread_registry.cc \\\n+\tsanitizer_tls_get_addr.cc \\\n \tsanitizer_win.cc\n \n libsanitizer_common_la_SOURCES = $(sanitizer_common_files) "}, {"sha": "1ea631590c09120ee44c23de4b9a8922c6069252", "filename": "libsanitizer/sanitizer_common/Makefile.in", "status": "modified", "additions": 27, "deletions": 13, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2FMakefile.in?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -65,19 +65,23 @@ LTLIBRARIES = $(noinst_LTLIBRARIES)\n libsanitizer_common_la_LIBADD =\n am__objects_1 = sanitizer_allocator.lo sanitizer_common.lo \\\n \tsanitizer_common_libcdep.lo sanitizer_coverage.lo \\\n-\tsanitizer_flags.lo sanitizer_libc.lo sanitizer_libignore.lo \\\n-\tsanitizer_linux.lo sanitizer_linux_libcdep.lo sanitizer_mac.lo \\\n+\tsanitizer_deadlock_detector1.lo \\\n+\tsanitizer_deadlock_detector2.lo sanitizer_flags.lo \\\n+\tsanitizer_libc.lo sanitizer_libignore.lo sanitizer_linux.lo \\\n+\tsanitizer_linux_libcdep.lo sanitizer_mac.lo \\\n \tsanitizer_platform_limits_linux.lo \\\n-\tsanitizer_platform_limits_posix.lo sanitizer_posix_libcdep.lo \\\n-\tsanitizer_posix.lo sanitizer_printf.lo sanitizer_stackdepot.lo \\\n-\tsanitizer_stacktrace.lo sanitizer_stacktrace_libcdep.lo \\\n+\tsanitizer_platform_limits_posix.lo sanitizer_posix.lo \\\n+\tsanitizer_posix_libcdep.lo sanitizer_printf.lo \\\n+\tsanitizer_procmaps_linux.lo sanitizer_procmaps_mac.lo \\\n+\tsanitizer_stackdepot.lo sanitizer_stacktrace.lo \\\n+\tsanitizer_stacktrace_libcdep.lo \\\n \tsanitizer_stoptheworld_linux_libcdep.lo \\\n-\tsanitizer_suppressions.lo \\\n-\tsanitizer_symbolizer_posix_libcdep.lo \\\n-\tsanitizer_symbolizer_win.lo sanitizer_symbolizer.lo \\\n+\tsanitizer_suppressions.lo sanitizer_symbolizer.lo \\\n \tsanitizer_symbolizer_libbacktrace.lo \\\n-\tsanitizer_symbolizer_libcdep.lo sanitizer_thread_registry.lo \\\n-\tsanitizer_win.lo\n+\tsanitizer_symbolizer_libcdep.lo \\\n+\tsanitizer_symbolizer_posix_libcdep.lo \\\n+\tsanitizer_symbolizer_win.lo sanitizer_thread_registry.lo \\\n+\tsanitizer_tls_get_addr.lo sanitizer_win.lo\n am_libsanitizer_common_la_OBJECTS = $(am__objects_1)\n libsanitizer_common_la_OBJECTS = $(am_libsanitizer_common_la_OBJECTS)\n DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)\n@@ -253,6 +257,8 @@ sanitizer_common_files = \\\n \tsanitizer_common.cc \\\n \tsanitizer_common_libcdep.cc \\\n \tsanitizer_coverage.cc \\\n+\tsanitizer_deadlock_detector1.cc \\\n+\tsanitizer_deadlock_detector2.cc \\\n \tsanitizer_flags.cc \\\n \tsanitizer_libc.cc \\\n \tsanitizer_libignore.cc \\\n@@ -261,20 +267,23 @@ sanitizer_common_files = \\\n \tsanitizer_mac.cc \\\n \tsanitizer_platform_limits_linux.cc \\\n \tsanitizer_platform_limits_posix.cc \\\n-\tsanitizer_posix_libcdep.cc \\\n \tsanitizer_posix.cc \\\n+\tsanitizer_posix_libcdep.cc \\\n \tsanitizer_printf.cc \\\n+\tsanitizer_procmaps_linux.cc \\\n+\tsanitizer_procmaps_mac.cc \\\n \tsanitizer_stackdepot.cc \\\n \tsanitizer_stacktrace.cc \\\n \tsanitizer_stacktrace_libcdep.cc \\\n \tsanitizer_stoptheworld_linux_libcdep.cc \\\n \tsanitizer_suppressions.cc \\\n-\tsanitizer_symbolizer_posix_libcdep.cc \\\n-\tsanitizer_symbolizer_win.cc \\\n \tsanitizer_symbolizer.cc \\\n \tsanitizer_symbolizer_libbacktrace.cc \\\n \tsanitizer_symbolizer_libcdep.cc \\\n+\tsanitizer_symbolizer_posix_libcdep.cc \\\n+\tsanitizer_symbolizer_win.cc \\\n \tsanitizer_thread_registry.cc \\\n+\tsanitizer_tls_get_addr.cc \\\n \tsanitizer_win.cc\n \n libsanitizer_common_la_SOURCES = $(sanitizer_common_files) \n@@ -374,6 +383,8 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_common.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_common_libcdep.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_coverage.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_deadlock_detector1.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_deadlock_detector2.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_flags.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_libc.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_libignore.Plo@am__quote@\n@@ -385,6 +396,8 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_posix.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_posix_libcdep.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_printf.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_procmaps_linux.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_procmaps_mac.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_stackdepot.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_stacktrace.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_stacktrace_libcdep.Plo@am__quote@\n@@ -396,6 +409,7 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_symbolizer_posix_libcdep.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_symbolizer_win.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_thread_registry.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_tls_get_addr.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_win.Plo@am__quote@\n \n .cc.o:"}, {"sha": "9e15d51c66c10a015a5d349979ebdba05e84430a", "filename": "libsanitizer/sanitizer_common/sanitizer_addrhashmap.h", "status": "added", "additions": 340, "deletions": 0, "changes": 340, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_addrhashmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_addrhashmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_addrhashmap.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -0,0 +1,340 @@\n+//===-- sanitizer_addrhashmap.h ---------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Concurrent uptr->T hashmap.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef SANITIZER_ADDRHASHMAP_H\n+#define SANITIZER_ADDRHASHMAP_H\n+\n+#include \"sanitizer_common.h\"\n+#include \"sanitizer_mutex.h\"\n+#include \"sanitizer_atomic.h\"\n+#include \"sanitizer_allocator_internal.h\"\n+\n+namespace __sanitizer {\n+\n+// Concurrent uptr->T hashmap.\n+// T must be a POD type, kSize is preferably a prime but can be any number.\n+// Usage example:\n+//\n+// typedef AddrHashMap<uptr, 11> Map;\n+// Map m;\n+// {\n+//   Map::Handle h(&m, addr);\n+//   use h.operator->() to access the data\n+//   if h.created() then the element was just created, and the current thread\n+//     has exclusive access to it\n+//   otherwise the current thread has only read access to the data\n+// }\n+// {\n+//   Map::Handle h(&m, addr, true);\n+//   this will remove the data from the map in Handle dtor\n+//   the current thread has exclusive access to the data\n+//   if !h.exists() then the element never existed\n+// }\n+template<typename T, uptr kSize>\n+class AddrHashMap {\n+ private:\n+  struct Cell {\n+    atomic_uintptr_t addr;\n+    T                val;\n+  };\n+\n+  struct AddBucket {\n+    uptr cap;\n+    uptr size;\n+    Cell cells[1];  // variable len\n+  };\n+\n+  static const uptr kBucketSize = 3;\n+\n+  struct Bucket {\n+    RWMutex          mtx;\n+    atomic_uintptr_t add;\n+    Cell             cells[kBucketSize];\n+  };\n+\n+ public:\n+  AddrHashMap();\n+\n+  class Handle {\n+   public:\n+    Handle(AddrHashMap<T, kSize> *map, uptr addr);\n+    Handle(AddrHashMap<T, kSize> *map, uptr addr, bool remove);\n+    Handle(AddrHashMap<T, kSize> *map, uptr addr, bool remove, bool create);\n+\n+    ~Handle();\n+    T *operator->();\n+    bool created() const;\n+    bool exists() const;\n+\n+   private:\n+    friend AddrHashMap<T, kSize>;\n+    AddrHashMap<T, kSize> *map_;\n+    Bucket                *bucket_;\n+    Cell                  *cell_;\n+    uptr                   addr_;\n+    uptr                   addidx_;\n+    bool                   created_;\n+    bool                   remove_;\n+    bool                   create_;\n+  };\n+\n+ private:\n+  friend class Handle;\n+  Bucket *table_;\n+\n+  void acquire(Handle *h);\n+  void release(Handle *h);\n+  uptr calcHash(uptr addr);\n+};\n+\n+template<typename T, uptr kSize>\n+AddrHashMap<T, kSize>::Handle::Handle(AddrHashMap<T, kSize> *map, uptr addr) {\n+  map_ = map;\n+  addr_ = addr;\n+  remove_ = false;\n+  create_ = true;\n+  map_->acquire(this);\n+}\n+\n+template<typename T, uptr kSize>\n+AddrHashMap<T, kSize>::Handle::Handle(AddrHashMap<T, kSize> *map, uptr addr,\n+    bool remove) {\n+  map_ = map;\n+  addr_ = addr;\n+  remove_ = remove;\n+  create_ = true;\n+  map_->acquire(this);\n+}\n+\n+template<typename T, uptr kSize>\n+AddrHashMap<T, kSize>::Handle::Handle(AddrHashMap<T, kSize> *map, uptr addr,\n+    bool remove, bool create) {\n+  map_ = map;\n+  addr_ = addr;\n+  remove_ = remove;\n+  create_ = create;\n+  map_->acquire(this);\n+}\n+\n+template<typename T, uptr kSize>\n+AddrHashMap<T, kSize>::Handle::~Handle() {\n+  map_->release(this);\n+}\n+\n+template <typename T, uptr kSize>\n+T *AddrHashMap<T, kSize>::Handle::operator->() {\n+  return &cell_->val;\n+}\n+\n+template<typename T, uptr kSize>\n+bool AddrHashMap<T, kSize>::Handle::created() const {\n+  return created_;\n+}\n+\n+template<typename T, uptr kSize>\n+bool AddrHashMap<T, kSize>::Handle::exists() const {\n+  return cell_ != 0;\n+}\n+\n+template<typename T, uptr kSize>\n+AddrHashMap<T, kSize>::AddrHashMap() {\n+  table_ = (Bucket*)MmapOrDie(kSize * sizeof(table_[0]), \"AddrHashMap\");\n+}\n+\n+template<typename T, uptr kSize>\n+void AddrHashMap<T, kSize>::acquire(Handle *h) {\n+  uptr addr = h->addr_;\n+  uptr hash = calcHash(addr);\n+  Bucket *b = &table_[hash];\n+\n+  h->created_ = false;\n+  h->addidx_ = -1U;\n+  h->bucket_ = b;\n+  h->cell_ = 0;\n+\n+  // If we want to remove the element, we need exclusive access to the bucket,\n+  // so skip the lock-free phase.\n+  if (h->remove_)\n+    goto locked;\n+\n+ retry:\n+  // First try to find an existing element w/o read mutex.\n+  CHECK(!h->remove_);\n+  // Check the embed cells.\n+  for (uptr i = 0; i < kBucketSize; i++) {\n+    Cell *c = &b->cells[i];\n+    uptr addr1 = atomic_load(&c->addr, memory_order_acquire);\n+    if (addr1 == addr) {\n+      h->cell_ = c;\n+      return;\n+    }\n+  }\n+\n+  // Check the add cells with read lock.\n+  if (atomic_load(&b->add, memory_order_relaxed)) {\n+    b->mtx.ReadLock();\n+    AddBucket *add = (AddBucket*)atomic_load(&b->add, memory_order_relaxed);\n+    for (uptr i = 0; i < add->size; i++) {\n+      Cell *c = &add->cells[i];\n+      uptr addr1 = atomic_load(&c->addr, memory_order_relaxed);\n+      if (addr1 == addr) {\n+        h->addidx_ = i;\n+        h->cell_ = c;\n+        return;\n+      }\n+    }\n+    b->mtx.ReadUnlock();\n+  }\n+\n+ locked:\n+  // Re-check existence under write lock.\n+  // Embed cells.\n+  b->mtx.Lock();\n+  for (uptr i = 0; i < kBucketSize; i++) {\n+    Cell *c = &b->cells[i];\n+    uptr addr1 = atomic_load(&c->addr, memory_order_relaxed);\n+    if (addr1 == addr) {\n+      if (h->remove_) {\n+        h->cell_ = c;\n+        return;\n+      }\n+      b->mtx.Unlock();\n+      goto retry;\n+    }\n+  }\n+\n+  // Add cells.\n+  AddBucket *add = (AddBucket*)atomic_load(&b->add, memory_order_relaxed);\n+  if (add) {\n+    for (uptr i = 0; i < add->size; i++) {\n+      Cell *c = &add->cells[i];\n+      uptr addr1 = atomic_load(&c->addr, memory_order_relaxed);\n+      if (addr1 == addr) {\n+        if (h->remove_) {\n+          h->addidx_ = i;\n+          h->cell_ = c;\n+          return;\n+        }\n+        b->mtx.Unlock();\n+        goto retry;\n+      }\n+    }\n+  }\n+\n+  // The element does not exist, no need to create it if we want to remove.\n+  if (h->remove_ || !h->create_) {\n+    b->mtx.Unlock();\n+    return;\n+  }\n+\n+  // Now try to create it under the mutex.\n+  h->created_ = true;\n+  // See if we have a free embed cell.\n+  for (uptr i = 0; i < kBucketSize; i++) {\n+    Cell *c = &b->cells[i];\n+    uptr addr1 = atomic_load(&c->addr, memory_order_relaxed);\n+    if (addr1 == 0) {\n+      h->cell_ = c;\n+      return;\n+    }\n+  }\n+\n+  // Store in the add cells.\n+  if (add == 0) {\n+    // Allocate a new add array.\n+    const uptr kInitSize = 64;\n+    add = (AddBucket*)InternalAlloc(kInitSize);\n+    internal_memset(add, 0, kInitSize);\n+    add->cap = (kInitSize - sizeof(*add)) / sizeof(add->cells[0]) + 1;\n+    add->size = 0;\n+    atomic_store(&b->add, (uptr)add, memory_order_relaxed);\n+  }\n+  if (add->size == add->cap) {\n+    // Grow existing add array.\n+    uptr oldsize = sizeof(*add) + (add->cap - 1) * sizeof(add->cells[0]);\n+    uptr newsize = oldsize * 2;\n+    AddBucket *add1 = (AddBucket*)InternalAlloc(newsize);\n+    internal_memset(add1, 0, newsize);\n+    add1->cap = (newsize - sizeof(*add)) / sizeof(add->cells[0]) + 1;\n+    add1->size = add->size;\n+    internal_memcpy(add1->cells, add->cells, add->size * sizeof(add->cells[0]));\n+    InternalFree(add);\n+    atomic_store(&b->add, (uptr)add1, memory_order_relaxed);\n+    add = add1;\n+  }\n+  // Store.\n+  uptr i = add->size++;\n+  Cell *c = &add->cells[i];\n+  CHECK_EQ(atomic_load(&c->addr, memory_order_relaxed), 0);\n+  h->addidx_ = i;\n+  h->cell_ = c;\n+}\n+\n+template<typename T, uptr kSize>\n+void AddrHashMap<T, kSize>::release(Handle *h) {\n+  if (h->cell_ == 0)\n+    return;\n+  Bucket *b = h->bucket_;\n+  Cell *c = h->cell_;\n+  uptr addr1 = atomic_load(&c->addr, memory_order_relaxed);\n+  if (h->created_) {\n+    // Denote completion of insertion.\n+    CHECK_EQ(addr1, 0);\n+    // After the following store, the element becomes available\n+    // for lock-free reads.\n+    atomic_store(&c->addr, h->addr_, memory_order_release);\n+    b->mtx.Unlock();\n+  } else if (h->remove_) {\n+    // Denote that the cell is empty now.\n+    CHECK_EQ(addr1, h->addr_);\n+    atomic_store(&c->addr, 0, memory_order_release);\n+    // See if we need to compact the bucket.\n+    AddBucket *add = (AddBucket*)atomic_load(&b->add, memory_order_relaxed);\n+    if (h->addidx_ == -1U) {\n+      // Removed from embed array, move an add element into the freed cell.\n+      if (add && add->size != 0) {\n+        uptr last = --add->size;\n+        Cell *c1 = &add->cells[last];\n+        c->val = c1->val;\n+        uptr addr1 = atomic_load(&c1->addr, memory_order_relaxed);\n+        atomic_store(&c->addr, addr1, memory_order_release);\n+        atomic_store(&c1->addr, 0, memory_order_release);\n+      }\n+    } else {\n+      // Removed from add array, compact it.\n+      uptr last = --add->size;\n+      Cell *c1 = &add->cells[last];\n+      if (c != c1) {\n+        *c = *c1;\n+        atomic_store(&c1->addr, 0, memory_order_relaxed);\n+      }\n+    }\n+    if (add && add->size == 0) {\n+      // FIXME(dvyukov): free add?\n+    }\n+    b->mtx.Unlock();\n+  } else {\n+    CHECK_EQ(addr1, h->addr_);\n+    if (h->addidx_ != -1U)\n+      b->mtx.ReadUnlock();\n+  }\n+}\n+\n+template<typename T, uptr kSize>\n+uptr AddrHashMap<T, kSize>::calcHash(uptr addr) {\n+  addr += addr << 10;\n+  addr ^= addr >> 6;\n+  return addr % kSize;\n+}\n+\n+} // namespace __sanitizer\n+\n+#endif // SANITIZER_ADDRHASHMAP_H"}, {"sha": "f4e3af1b06afa62dc2bd01fcf9f28b4fcb44be27", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -17,7 +17,7 @@\n namespace __sanitizer {\n \n // ThreadSanitizer for Go uses libc malloc/free.\n-#if defined(SANITIZER_GO)\n+#if defined(SANITIZER_GO) || defined(SANITIZER_USE_MALLOC)\n # if SANITIZER_LINUX && !SANITIZER_ANDROID\n extern \"C\" void *__libc_malloc(uptr size);\n extern \"C\" void __libc_free(void *ptr);\n@@ -115,7 +115,7 @@ void *LowLevelAllocator::Allocate(uptr size) {\n   if (allocated_end_ - allocated_current_ < (sptr)size) {\n     uptr size_to_allocate = Max(size, GetPageSizeCached());\n     allocated_current_ =\n-        (char*)MmapOrDie(size_to_allocate, __FUNCTION__);\n+        (char*)MmapOrDie(size_to_allocate, __func__);\n     allocated_end_ = allocated_current_ + size_to_allocate;\n     if (low_level_alloc_callback) {\n       low_level_alloc_callback((uptr)allocated_current_,"}, {"sha": "74e4402f7366c4a8e820da40c986483a0a3a2e08", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_internal.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_internal.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -22,14 +22,13 @@ namespace __sanitizer {\n typedef CompactSizeClassMap InternalSizeClassMap;\n \n static const uptr kInternalAllocatorSpace = 0;\n+static const u64 kInternalAllocatorSize = SANITIZER_MMAP_RANGE_SIZE;\n #if SANITIZER_WORDSIZE == 32\n-static const u64 kInternalAllocatorSize = (1ULL << 32);\n static const uptr kInternalAllocatorRegionSizeLog = 20;\n static const uptr kInternalAllocatorNumRegions =\n     kInternalAllocatorSize >> kInternalAllocatorRegionSizeLog;\n typedef FlatByteMap<kInternalAllocatorNumRegions> ByteMap;\n #else\n-static const u64 kInternalAllocatorSize = (1ULL << 47);\n static const uptr kInternalAllocatorRegionSizeLog = 24;\n static const uptr kInternalAllocatorNumRegions =\n     kInternalAllocatorSize >> kInternalAllocatorRegionSizeLog;\n@@ -46,10 +45,10 @@ typedef SizeClassAllocatorLocalCache<PrimaryInternalAllocator>\n // LargeMmapAllocator.\n struct CrashOnMapUnmap {\n   void OnMap(uptr p, uptr size) const {\n-    RAW_CHECK_MSG(0, \"Unexpected mmap in InternalAllocator!\");\n+    RAW_CHECK_MSG(0, \"Unexpected mmap in InternalAllocator!\\n\");\n   }\n   void OnUnmap(uptr p, uptr size) const {\n-    RAW_CHECK_MSG(0, \"Unexpected munmap in InternalAllocator!\");\n+    RAW_CHECK_MSG(0, \"Unexpected munmap in InternalAllocator!\\n\");\n   }\n };\n "}, {"sha": "6387664f63b76365fd80886e707538ef152b94e8", "filename": "libsanitizer/sanitizer_common/sanitizer_atomic.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -42,7 +42,8 @@ struct atomic_uint32_t {\n \n struct atomic_uint64_t {\n   typedef u64 Type;\n-  volatile Type val_dont_use;\n+  // On 32-bit platforms u64 is not necessary aligned on 8 bytes.\n+  volatile ALIGNED(8) Type val_dont_use;\n };\n \n struct atomic_uintptr_t {"}, {"sha": "c600999e67a8293f2d1833efc356baca5431b219", "filename": "libsanitizer/sanitizer_common/sanitizer_atomic_clang.h", "status": "modified", "additions": 18, "deletions": 53, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_clang.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_clang.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_clang.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -13,8 +13,26 @@\n #ifndef SANITIZER_ATOMIC_CLANG_H\n #define SANITIZER_ATOMIC_CLANG_H\n \n+#if defined(__i386__) || defined(__x86_64__)\n+# include \"sanitizer_atomic_clang_x86.h\"\n+#else\n+# include \"sanitizer_atomic_clang_other.h\"\n+#endif\n+\n namespace __sanitizer {\n \n+// We would like to just use compiler builtin atomic operations\n+// for loads and stores, but they are mostly broken in clang:\n+// - they lead to vastly inefficient code generation\n+// (http://llvm.org/bugs/show_bug.cgi?id=17281)\n+// - 64-bit atomic operations are not implemented on x86_32\n+// (http://llvm.org/bugs/show_bug.cgi?id=15034)\n+// - they are not implemented on ARM\n+// error: undefined reference to '__atomic_load_4'\n+\n+// See http://www.cl.cam.ac.uk/~pes20/cpp/cpp0xmappings.html\n+// for mappings of the memory model to different processors.\n+\n INLINE void atomic_signal_fence(memory_order) {\n   __asm__ __volatile__(\"\" ::: \"memory\");\n }\n@@ -23,59 +41,6 @@ INLINE void atomic_thread_fence(memory_order) {\n   __sync_synchronize();\n }\n \n-INLINE void proc_yield(int cnt) {\n-  __asm__ __volatile__(\"\" ::: \"memory\");\n-#if defined(__i386__) || defined(__x86_64__)\n-  for (int i = 0; i < cnt; i++)\n-    __asm__ __volatile__(\"pause\");\n-#endif\n-  __asm__ __volatile__(\"\" ::: \"memory\");\n-}\n-\n-template<typename T>\n-INLINE typename T::Type atomic_load(\n-    const volatile T *a, memory_order mo) {\n-  DCHECK(mo & (memory_order_relaxed | memory_order_consume\n-      | memory_order_acquire | memory_order_seq_cst));\n-  DCHECK(!((uptr)a % sizeof(*a)));\n-  typename T::Type v;\n-  // FIXME:\n-  // 64-bit atomic operations are not atomic on 32-bit platforms.\n-  // The implementation lacks necessary memory fences on ARM/PPC.\n-  // We would like to use compiler builtin atomic operations,\n-  // but they are mostly broken:\n-  // - they lead to vastly inefficient code generation\n-  // (http://llvm.org/bugs/show_bug.cgi?id=17281)\n-  // - 64-bit atomic operations are not implemented on x86_32\n-  // (http://llvm.org/bugs/show_bug.cgi?id=15034)\n-  // - they are not implemented on ARM\n-  // error: undefined reference to '__atomic_load_4'\n-  if (mo == memory_order_relaxed) {\n-    v = a->val_dont_use;\n-  } else {\n-    atomic_signal_fence(memory_order_seq_cst);\n-    v = a->val_dont_use;\n-    atomic_signal_fence(memory_order_seq_cst);\n-  }\n-  return v;\n-}\n-\n-template<typename T>\n-INLINE void atomic_store(volatile T *a, typename T::Type v, memory_order mo) {\n-  DCHECK(mo & (memory_order_relaxed | memory_order_release\n-      | memory_order_seq_cst));\n-  DCHECK(!((uptr)a % sizeof(*a)));\n-  if (mo == memory_order_relaxed) {\n-    a->val_dont_use = v;\n-  } else {\n-    atomic_signal_fence(memory_order_seq_cst);\n-    a->val_dont_use = v;\n-    atomic_signal_fence(memory_order_seq_cst);\n-  }\n-  if (mo == memory_order_seq_cst)\n-    atomic_thread_fence(memory_order_seq_cst);\n-}\n-\n template<typename T>\n INLINE typename T::Type atomic_fetch_add(volatile T *a,\n     typename T::Type v, memory_order mo) {"}, {"sha": "c66c0992e1b0b13c71139796655cd44c7eaa3eb5", "filename": "libsanitizer/sanitizer_common/sanitizer_atomic_clang_other.h", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_clang_other.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_clang_other.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_clang_other.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -0,0 +1,95 @@\n+//===-- sanitizer_atomic_clang_other.h --------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer/AddressSanitizer runtime.\n+// Not intended for direct inclusion. Include sanitizer_atomic.h.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef SANITIZER_ATOMIC_CLANG_OTHER_H\n+#define SANITIZER_ATOMIC_CLANG_OTHER_H\n+\n+namespace __sanitizer {\n+\n+INLINE void proc_yield(int cnt) {\n+  __asm__ __volatile__(\"\" ::: \"memory\");\n+}\n+\n+template<typename T>\n+INLINE typename T::Type atomic_load(\n+    const volatile T *a, memory_order mo) {\n+  DCHECK(mo & (memory_order_relaxed | memory_order_consume\n+      | memory_order_acquire | memory_order_seq_cst));\n+  DCHECK(!((uptr)a % sizeof(*a)));\n+  typename T::Type v;\n+\n+  if (sizeof(*a) < 8 || sizeof(void*) == 8) {\n+    // Assume that aligned loads are atomic.\n+    if (mo == memory_order_relaxed) {\n+      v = a->val_dont_use;\n+    } else if (mo == memory_order_consume) {\n+      // Assume that processor respects data dependencies\n+      // (and that compiler won't break them).\n+      __asm__ __volatile__(\"\" ::: \"memory\");\n+      v = a->val_dont_use;\n+      __asm__ __volatile__(\"\" ::: \"memory\");\n+    } else if (mo == memory_order_acquire) {\n+      __asm__ __volatile__(\"\" ::: \"memory\");\n+      v = a->val_dont_use;\n+      __sync_synchronize();\n+    } else {  // seq_cst\n+      // E.g. on POWER we need a hw fence even before the store.\n+      __sync_synchronize();\n+      v = a->val_dont_use;\n+      __sync_synchronize();\n+    }\n+  } else {\n+    // 64-bit load on 32-bit platform.\n+    // Gross, but simple and reliable.\n+    // Assume that it is not in read-only memory.\n+    v = __sync_fetch_and_add(\n+        const_cast<typename T::Type volatile *>(&a->val_dont_use), 0);\n+  }\n+  return v;\n+}\n+\n+template<typename T>\n+INLINE void atomic_store(volatile T *a, typename T::Type v, memory_order mo) {\n+  DCHECK(mo & (memory_order_relaxed | memory_order_release\n+      | memory_order_seq_cst));\n+  DCHECK(!((uptr)a % sizeof(*a)));\n+\n+  if (sizeof(*a) < 8 || sizeof(void*) == 8) {\n+    // Assume that aligned loads are atomic.\n+    if (mo == memory_order_relaxed) {\n+      a->val_dont_use = v;\n+    } else if (mo == memory_order_release) {\n+      __sync_synchronize();\n+      a->val_dont_use = v;\n+      __asm__ __volatile__(\"\" ::: \"memory\");\n+    } else {  // seq_cst\n+      __sync_synchronize();\n+      a->val_dont_use = v;\n+      __sync_synchronize();\n+    }\n+  } else {\n+    // 64-bit store on 32-bit platform.\n+    // Gross, but simple and reliable.\n+    typename T::Type cmp = a->val_dont_use;\n+    typename T::Type cur;\n+    for (;;) {\n+      cur = __sync_val_compare_and_swap(&a->val_dont_use, cmp, v);\n+      if (cmp == v)\n+        break;\n+      cmp = cur;\n+    }\n+  }\n+}\n+\n+}  // namespace __sanitizer\n+\n+#endif  // #ifndef SANITIZER_ATOMIC_CLANG_OTHER_H"}, {"sha": "5df210eca795d1f724dd5629e09a422c225dbe39", "filename": "libsanitizer/sanitizer_common/sanitizer_atomic_clang_x86.h", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_clang_x86.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_clang_x86.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_clang_x86.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -0,0 +1,114 @@\n+//===-- sanitizer_atomic_clang_x86.h ----------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer/AddressSanitizer runtime.\n+// Not intended for direct inclusion. Include sanitizer_atomic.h.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef SANITIZER_ATOMIC_CLANG_X86_H\n+#define SANITIZER_ATOMIC_CLANG_X86_H\n+\n+namespace __sanitizer {\n+\n+INLINE void proc_yield(int cnt) {\n+  __asm__ __volatile__(\"\" ::: \"memory\");\n+  for (int i = 0; i < cnt; i++)\n+    __asm__ __volatile__(\"pause\");\n+  __asm__ __volatile__(\"\" ::: \"memory\");\n+}\n+\n+template<typename T>\n+INLINE typename T::Type atomic_load(\n+    const volatile T *a, memory_order mo) {\n+  DCHECK(mo & (memory_order_relaxed | memory_order_consume\n+      | memory_order_acquire | memory_order_seq_cst));\n+  DCHECK(!((uptr)a % sizeof(*a)));\n+  typename T::Type v;\n+\n+  if (sizeof(*a) < 8 || sizeof(void*) == 8) {\n+    // Assume that aligned loads are atomic.\n+    if (mo == memory_order_relaxed) {\n+      v = a->val_dont_use;\n+    } else if (mo == memory_order_consume) {\n+      // Assume that processor respects data dependencies\n+      // (and that compiler won't break them).\n+      __asm__ __volatile__(\"\" ::: \"memory\");\n+      v = a->val_dont_use;\n+      __asm__ __volatile__(\"\" ::: \"memory\");\n+    } else if (mo == memory_order_acquire) {\n+      __asm__ __volatile__(\"\" ::: \"memory\");\n+      v = a->val_dont_use;\n+      // On x86 loads are implicitly acquire.\n+      __asm__ __volatile__(\"\" ::: \"memory\");\n+    } else {  // seq_cst\n+      // On x86 plain MOV is enough for seq_cst store.\n+      __asm__ __volatile__(\"\" ::: \"memory\");\n+      v = a->val_dont_use;\n+      __asm__ __volatile__(\"\" ::: \"memory\");\n+    }\n+  } else {\n+    // 64-bit load on 32-bit platform.\n+    __asm__ __volatile__(\n+        \"movq %1, %%mm0;\"  // Use mmx reg for 64-bit atomic moves\n+        \"movq %%mm0, %0;\"  // (ptr could be read-only)\n+        \"emms;\"            // Empty mmx state/Reset FP regs\n+        : \"=m\" (v)\n+        : \"m\" (a->val_dont_use)\n+        : // mark the FP stack and mmx registers as clobbered\n+          \"st\", \"st(1)\", \"st(2)\", \"st(3)\", \"st(4)\", \"st(5)\", \"st(6)\", \"st(7)\",\n+#ifdef __MMX__\n+          \"mm0\", \"mm1\", \"mm2\", \"mm3\", \"mm4\", \"mm5\", \"mm6\", \"mm7\",\n+#endif  // #ifdef __MMX__\n+          \"memory\");\n+  }\n+  return v;\n+}\n+\n+template<typename T>\n+INLINE void atomic_store(volatile T *a, typename T::Type v, memory_order mo) {\n+  DCHECK(mo & (memory_order_relaxed | memory_order_release\n+      | memory_order_seq_cst));\n+  DCHECK(!((uptr)a % sizeof(*a)));\n+\n+  if (sizeof(*a) < 8 || sizeof(void*) == 8) {\n+    // Assume that aligned loads are atomic.\n+    if (mo == memory_order_relaxed) {\n+      a->val_dont_use = v;\n+    } else if (mo == memory_order_release) {\n+      // On x86 stores are implicitly release.\n+      __asm__ __volatile__(\"\" ::: \"memory\");\n+      a->val_dont_use = v;\n+      __asm__ __volatile__(\"\" ::: \"memory\");\n+    } else {  // seq_cst\n+      // On x86 stores are implicitly release.\n+      __asm__ __volatile__(\"\" ::: \"memory\");\n+      a->val_dont_use = v;\n+      __sync_synchronize();\n+    }\n+  } else {\n+    // 64-bit store on 32-bit platform.\n+    __asm__ __volatile__(\n+        \"movq %1, %%mm0;\"  // Use mmx reg for 64-bit atomic moves\n+        \"movq %%mm0, %0;\"\n+        \"emms;\"            // Empty mmx state/Reset FP regs\n+        : \"=m\" (a->val_dont_use)\n+        : \"m\" (v)\n+        : // mark the FP stack and mmx registers as clobbered\n+          \"st\", \"st(1)\", \"st(2)\", \"st(3)\", \"st(4)\", \"st(5)\", \"st(6)\", \"st(7)\",\n+#ifdef __MMX__\n+          \"mm0\", \"mm1\", \"mm2\", \"mm3\", \"mm4\", \"mm5\", \"mm6\", \"mm7\",\n+#endif  // #ifdef __MMX__\n+          \"memory\");\n+    if (mo == memory_order_seq_cst)\n+      __sync_synchronize();\n+  }\n+}\n+\n+}  // namespace __sanitizer\n+\n+#endif  // #ifndef SANITIZER_ATOMIC_CLANG_X86_H"}, {"sha": "7e18fa38748aeb9f34b773e45cb47611ffb1b799", "filename": "libsanitizer/sanitizer_common/sanitizer_atomic_msvc.h", "status": "modified", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_msvc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_msvc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_msvc.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -22,8 +22,20 @@ extern \"C\" void _mm_pause();\n extern \"C\" long _InterlockedExchangeAdd(  // NOLINT\n     long volatile * Addend, long Value);  // NOLINT\n #pragma intrinsic(_InterlockedExchangeAdd)\n+extern \"C\" short _InterlockedCompareExchange16(  // NOLINT\n+    short volatile *Destination,                 // NOLINT\n+    short Exchange, short Comparand);            // NOLINT\n+#pragma intrinsic(_InterlockedCompareExchange16)\n+extern \"C\"\n+long long _InterlockedCompareExchange64(  // NOLINT\n+    long long volatile *Destination,              // NOLINT\n+    long long Exchange, long long Comparand);     // NOLINT\n+#pragma intrinsic(_InterlockedCompareExchange64)\n \n #ifdef _WIN64\n+extern \"C\" long long _InterlockedExchangeAdd64(     // NOLINT\n+    long long volatile * Addend, long long Value);  // NOLINT\n+#pragma intrinsic(_InterlockedExchangeAdd64)\n extern \"C\" void *_InterlockedCompareExchangePointer(\n     void *volatile *Destination,\n     void *Exchange, void *Comparand);\n@@ -106,6 +118,40 @@ INLINE u32 atomic_fetch_add(volatile atomic_uint32_t *a,\n       (volatile long*)&a->val_dont_use, (long)v);  // NOLINT\n }\n \n+INLINE uptr atomic_fetch_add(volatile atomic_uintptr_t *a,\n+    uptr v, memory_order mo) {\n+  (void)mo;\n+  DCHECK(!((uptr)a % sizeof(*a)));\n+#ifdef _WIN64\n+  return (uptr)_InterlockedExchangeAdd64(\n+      (volatile long long*)&a->val_dont_use, (long long)v);  // NOLINT\n+#else\n+  return (uptr)_InterlockedExchangeAdd(\n+      (volatile long*)&a->val_dont_use, (long)v);  // NOLINT\n+#endif\n+}\n+\n+INLINE u32 atomic_fetch_sub(volatile atomic_uint32_t *a,\n+    u32 v, memory_order mo) {\n+  (void)mo;\n+  DCHECK(!((uptr)a % sizeof(*a)));\n+  return (u32)_InterlockedExchangeAdd(\n+      (volatile long*)&a->val_dont_use, -(long)v);  // NOLINT\n+}\n+\n+INLINE uptr atomic_fetch_sub(volatile atomic_uintptr_t *a,\n+    uptr v, memory_order mo) {\n+  (void)mo;\n+  DCHECK(!((uptr)a % sizeof(*a)));\n+#ifdef _WIN64\n+  return (uptr)_InterlockedExchangeAdd64(\n+      (volatile long long*)&a->val_dont_use, -(long long)v);  // NOLINT\n+#else\n+  return (uptr)_InterlockedExchangeAdd(\n+      (volatile long*)&a->val_dont_use, -(long)v);  // NOLINT\n+#endif\n+}\n+\n INLINE u8 atomic_exchange(volatile atomic_uint8_t *a,\n     u8 v, memory_order mo) {\n   (void)mo;\n@@ -166,6 +212,45 @@ INLINE bool atomic_compare_exchange_strong(volatile atomic_uintptr_t *a,\n   return false;\n }\n \n+INLINE bool atomic_compare_exchange_strong(volatile atomic_uint16_t *a,\n+                                           u16 *cmp,\n+                                           u16 xchg,\n+                                           memory_order mo) {\n+  u16 cmpv = *cmp;\n+  u16 prev = (u16)_InterlockedCompareExchange16(\n+      (volatile short*)&a->val_dont_use, (short)xchg, (short)cmpv);\n+  if (prev == cmpv)\n+    return true;\n+  *cmp = prev;\n+  return false;\n+}\n+\n+INLINE bool atomic_compare_exchange_strong(volatile atomic_uint32_t *a,\n+                                           u32 *cmp,\n+                                           u32 xchg,\n+                                           memory_order mo) {\n+  u32 cmpv = *cmp;\n+  u32 prev = (u32)_InterlockedCompareExchange(\n+      (volatile long*)&a->val_dont_use, (long)xchg, (long)cmpv);\n+  if (prev == cmpv)\n+    return true;\n+  *cmp = prev;\n+  return false;\n+}\n+\n+INLINE bool atomic_compare_exchange_strong(volatile atomic_uint64_t *a,\n+                                           u64 *cmp,\n+                                           u64 xchg,\n+                                           memory_order mo) {\n+  u64 cmpv = *cmp;\n+  u64 prev = (u64)_InterlockedCompareExchange64(\n+      (volatile long long*)&a->val_dont_use, (long long)xchg, (long long)cmpv);\n+  if (prev == cmpv)\n+    return true;\n+  *cmp = prev;\n+  return false;\n+}\n+\n template<typename T>\n INLINE bool atomic_compare_exchange_weak(volatile T *a,\n                                          typename T::Type *cmp,"}, {"sha": "bb2872facdedce198514fe70a04b8e4e2239d17a", "filename": "libsanitizer/sanitizer_common/sanitizer_bitvector.h", "status": "added", "additions": 349, "deletions": 0, "changes": 349, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_bitvector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_bitvector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_bitvector.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -0,0 +1,349 @@\n+//===-- sanitizer_bitvector.h -----------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Specializer BitVector implementation.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef SANITIZER_BITVECTOR_H\n+#define SANITIZER_BITVECTOR_H\n+\n+#include \"sanitizer_common.h\"\n+\n+namespace __sanitizer {\n+\n+// Fixed size bit vector based on a single basic integer.\n+template <class basic_int_t = uptr>\n+class BasicBitVector {\n+ public:\n+  enum SizeEnum { kSize = sizeof(basic_int_t) * 8 };\n+\n+  uptr size() const { return kSize; }\n+  // No CTOR.\n+  void clear() { bits_ = 0; }\n+  void setAll() { bits_ = ~(basic_int_t)0; }\n+  bool empty() const { return bits_ == 0; }\n+\n+  // Returns true if the bit has changed from 0 to 1.\n+  bool setBit(uptr idx) {\n+    basic_int_t old = bits_;\n+    bits_ |= mask(idx);\n+    return bits_ != old;\n+  }\n+\n+  // Returns true if the bit has changed from 1 to 0.\n+  bool clearBit(uptr idx) {\n+    basic_int_t old = bits_;\n+    bits_ &= ~mask(idx);\n+    return bits_ != old;\n+  }\n+\n+  bool getBit(uptr idx) const { return (bits_ & mask(idx)) != 0; }\n+\n+  uptr getAndClearFirstOne() {\n+    CHECK(!empty());\n+    uptr idx = LeastSignificantSetBitIndex(bits_);\n+    clearBit(idx);\n+    return idx;\n+  }\n+\n+  // Do \"this |= v\" and return whether new bits have been added.\n+  bool setUnion(const BasicBitVector &v) {\n+    basic_int_t old = bits_;\n+    bits_ |= v.bits_;\n+    return bits_ != old;\n+  }\n+\n+  // Do \"this &= v\" and return whether any bits have been removed.\n+  bool setIntersection(const BasicBitVector &v) {\n+    basic_int_t old = bits_;\n+    bits_ &= v.bits_;\n+    return bits_ != old;\n+  }\n+\n+  // Do \"this &= ~v\" and return whether any bits have been removed.\n+  bool setDifference(const BasicBitVector &v) {\n+    basic_int_t old = bits_;\n+    bits_ &= ~v.bits_;\n+    return bits_ != old;\n+  }\n+\n+  void copyFrom(const BasicBitVector &v) { bits_ = v.bits_; }\n+\n+  // Returns true if 'this' intersects with 'v'.\n+  bool intersectsWith(const BasicBitVector &v) const {\n+    return (bits_ & v.bits_) != 0;\n+  }\n+\n+  // for (BasicBitVector<>::Iterator it(bv); it.hasNext();) {\n+  //   uptr idx = it.next();\n+  //   use(idx);\n+  // }\n+  class Iterator {\n+   public:\n+    Iterator() { }\n+    explicit Iterator(const BasicBitVector &bv) : bv_(bv) {}\n+    bool hasNext() const { return !bv_.empty(); }\n+    uptr next() { return bv_.getAndClearFirstOne(); }\n+    void clear() { bv_.clear(); }\n+   private:\n+    BasicBitVector bv_;\n+  };\n+\n+ private:\n+  basic_int_t mask(uptr idx) const {\n+    CHECK_LT(idx, size());\n+    return (basic_int_t)1UL << idx;\n+  }\n+  basic_int_t bits_;\n+};\n+\n+// Fixed size bit vector of (kLevel1Size*BV::kSize**2) bits.\n+// The implementation is optimized for better performance on\n+// sparse bit vectors, i.e. the those with few set bits.\n+template <uptr kLevel1Size = 1, class BV = BasicBitVector<> >\n+class TwoLevelBitVector {\n+  // This is essentially a 2-level bit vector.\n+  // Set bit in the first level BV indicates that there are set bits\n+  // in the corresponding BV of the second level.\n+  // This structure allows O(kLevel1Size) time for clear() and empty(),\n+  // as well fast handling of sparse BVs.\n+ public:\n+  enum SizeEnum { kSize = BV::kSize * BV::kSize * kLevel1Size };\n+  // No CTOR.\n+\n+  uptr size() const { return kSize; }\n+\n+  void clear() {\n+    for (uptr i = 0; i < kLevel1Size; i++)\n+      l1_[i].clear();\n+  }\n+\n+  void setAll() {\n+    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {\n+      l1_[i0].setAll();\n+      for (uptr i1 = 0; i1 < BV::kSize; i1++)\n+        l2_[i0][i1].setAll();\n+    }\n+  }\n+\n+  bool empty() const {\n+    for (uptr i = 0; i < kLevel1Size; i++)\n+      if (!l1_[i].empty())\n+        return false;\n+    return true;\n+  }\n+\n+  // Returns true if the bit has changed from 0 to 1.\n+  bool setBit(uptr idx) {\n+    check(idx);\n+    uptr i0 = idx0(idx);\n+    uptr i1 = idx1(idx);\n+    uptr i2 = idx2(idx);\n+    if (!l1_[i0].getBit(i1)) {\n+      l1_[i0].setBit(i1);\n+      l2_[i0][i1].clear();\n+    }\n+    bool res = l2_[i0][i1].setBit(i2);\n+    // Printf(\"%s: %zd => %zd %zd %zd; %d\\n\", __func__,\n+    // idx, i0, i1, i2, res);\n+    return res;\n+  }\n+\n+  bool clearBit(uptr idx) {\n+    check(idx);\n+    uptr i0 = idx0(idx);\n+    uptr i1 = idx1(idx);\n+    uptr i2 = idx2(idx);\n+    bool res = false;\n+    if (l1_[i0].getBit(i1)) {\n+      res = l2_[i0][i1].clearBit(i2);\n+      if (l2_[i0][i1].empty())\n+        l1_[i0].clearBit(i1);\n+    }\n+    return res;\n+  }\n+\n+  bool getBit(uptr idx) const {\n+    check(idx);\n+    uptr i0 = idx0(idx);\n+    uptr i1 = idx1(idx);\n+    uptr i2 = idx2(idx);\n+    // Printf(\"%s: %zd => %zd %zd %zd\\n\", __func__, idx, i0, i1, i2);\n+    return l1_[i0].getBit(i1) && l2_[i0][i1].getBit(i2);\n+  }\n+\n+  uptr getAndClearFirstOne() {\n+    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {\n+      if (l1_[i0].empty()) continue;\n+      uptr i1 = l1_[i0].getAndClearFirstOne();\n+      uptr i2 = l2_[i0][i1].getAndClearFirstOne();\n+      if (!l2_[i0][i1].empty())\n+        l1_[i0].setBit(i1);\n+      uptr res = i0 * BV::kSize * BV::kSize + i1 * BV::kSize + i2;\n+      // Printf(\"getAndClearFirstOne: %zd %zd %zd => %zd\\n\", i0, i1, i2, res);\n+      return res;\n+    }\n+    CHECK(0);\n+    return 0;\n+  }\n+\n+  // Do \"this |= v\" and return whether new bits have been added.\n+  bool setUnion(const TwoLevelBitVector &v) {\n+    bool res = false;\n+    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {\n+      BV t = v.l1_[i0];\n+      while (!t.empty()) {\n+        uptr i1 = t.getAndClearFirstOne();\n+        if (l1_[i0].setBit(i1))\n+          l2_[i0][i1].clear();\n+        if (l2_[i0][i1].setUnion(v.l2_[i0][i1]))\n+          res = true;\n+      }\n+    }\n+    return res;\n+  }\n+\n+  // Do \"this &= v\" and return whether any bits have been removed.\n+  bool setIntersection(const TwoLevelBitVector &v) {\n+    bool res = false;\n+    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {\n+      if (l1_[i0].setIntersection(v.l1_[i0]))\n+        res = true;\n+      if (!l1_[i0].empty()) {\n+        BV t = l1_[i0];\n+        while (!t.empty()) {\n+          uptr i1 = t.getAndClearFirstOne();\n+          if (l2_[i0][i1].setIntersection(v.l2_[i0][i1]))\n+            res = true;\n+          if (l2_[i0][i1].empty())\n+            l1_[i0].clearBit(i1);\n+        }\n+      }\n+    }\n+    return res;\n+  }\n+\n+  // Do \"this &= ~v\" and return whether any bits have been removed.\n+  bool setDifference(const TwoLevelBitVector &v) {\n+    bool res = false;\n+    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {\n+      BV t = l1_[i0];\n+      t.setIntersection(v.l1_[i0]);\n+      while (!t.empty()) {\n+        uptr i1 = t.getAndClearFirstOne();\n+        if (l2_[i0][i1].setDifference(v.l2_[i0][i1]))\n+          res = true;\n+        if (l2_[i0][i1].empty())\n+          l1_[i0].clearBit(i1);\n+      }\n+    }\n+    return res;\n+  }\n+\n+  void copyFrom(const TwoLevelBitVector &v) {\n+    clear();\n+    setUnion(v);\n+  }\n+\n+  // Returns true if 'this' intersects with 'v'.\n+  bool intersectsWith(const TwoLevelBitVector &v) const {\n+    for (uptr i0 = 0; i0 < kLevel1Size; i0++) {\n+      BV t = l1_[i0];\n+      t.setIntersection(v.l1_[i0]);\n+      while (!t.empty()) {\n+        uptr i1 = t.getAndClearFirstOne();\n+        if (!v.l1_[i0].getBit(i1)) continue;\n+        if (l2_[i0][i1].intersectsWith(v.l2_[i0][i1]))\n+          return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  // for (TwoLevelBitVector<>::Iterator it(bv); it.hasNext();) {\n+  //   uptr idx = it.next();\n+  //   use(idx);\n+  // }\n+  class Iterator {\n+   public:\n+    Iterator() { }\n+    explicit Iterator(const TwoLevelBitVector &bv) : bv_(bv), i0_(0), i1_(0) {\n+      it1_.clear();\n+      it2_.clear();\n+    }\n+\n+    bool hasNext() const {\n+      if (it1_.hasNext()) return true;\n+      for (uptr i = i0_; i < kLevel1Size; i++)\n+        if (!bv_.l1_[i].empty()) return true;\n+      return false;\n+    }\n+\n+    uptr next() {\n+      // Printf(\"++++: %zd %zd; %d %d; size %zd\\n\", i0_, i1_, it1_.hasNext(),\n+      //       it2_.hasNext(), kSize);\n+      if (!it1_.hasNext() && !it2_.hasNext()) {\n+        for (; i0_ < kLevel1Size; i0_++) {\n+          if (bv_.l1_[i0_].empty()) continue;\n+          it1_ = typename BV::Iterator(bv_.l1_[i0_]);\n+          // Printf(\"+i0: %zd %zd; %d %d; size %zd\\n\", i0_, i1_, it1_.hasNext(),\n+          //   it2_.hasNext(), kSize);\n+          break;\n+        }\n+      }\n+      if (!it2_.hasNext()) {\n+        CHECK(it1_.hasNext());\n+        i1_ = it1_.next();\n+        it2_ = typename BV::Iterator(bv_.l2_[i0_][i1_]);\n+        // Printf(\"++i1: %zd %zd; %d %d; size %zd\\n\", i0_, i1_, it1_.hasNext(),\n+        //       it2_.hasNext(), kSize);\n+      }\n+      CHECK(it2_.hasNext());\n+      uptr i2 = it2_.next();\n+      uptr res = i0_ * BV::kSize * BV::kSize + i1_ * BV::kSize + i2;\n+      // Printf(\"+ret: %zd %zd; %d %d; size %zd; res: %zd\\n\", i0_, i1_,\n+      //       it1_.hasNext(), it2_.hasNext(), kSize, res);\n+      if (!it1_.hasNext() && !it2_.hasNext())\n+        i0_++;\n+      return res;\n+    }\n+\n+   private:\n+    const TwoLevelBitVector &bv_;\n+    uptr i0_, i1_;\n+    typename BV::Iterator it1_, it2_;\n+  };\n+\n+ private:\n+  void check(uptr idx) const { CHECK_LE(idx, size()); }\n+\n+  uptr idx0(uptr idx) const {\n+    uptr res = idx / (BV::kSize * BV::kSize);\n+    CHECK_LE(res, kLevel1Size);\n+    return res;\n+  }\n+\n+  uptr idx1(uptr idx) const {\n+    uptr res = (idx / BV::kSize) % BV::kSize;\n+    CHECK_LE(res, BV::kSize);\n+    return res;\n+  }\n+\n+  uptr idx2(uptr idx) const {\n+    uptr res = idx % BV::kSize;\n+    CHECK_LE(res, BV::kSize);\n+    return res;\n+  }\n+\n+  BV l1_[kLevel1Size];\n+  BV l2_[kLevel1Size][BV::kSize];\n+};\n+\n+} // namespace __sanitizer\n+\n+#endif // SANITIZER_BITVECTOR_H"}, {"sha": "6ef0e81e044f533aee3b92e82ecce1ee4ade8c52", "filename": "libsanitizer/sanitizer_common/sanitizer_bvgraph.h", "status": "added", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_bvgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_bvgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_bvgraph.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -0,0 +1,163 @@\n+//===-- sanitizer_bvgraph.h -------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of Sanitizer runtime.\n+// BVGraph -- a directed graph.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef SANITIZER_BVGRAPH_H\n+#define SANITIZER_BVGRAPH_H\n+\n+#include \"sanitizer_common.h\"\n+#include \"sanitizer_bitvector.h\"\n+\n+namespace __sanitizer {\n+\n+// Directed graph of fixed size implemented as an array of bit vectors.\n+// Not thread-safe, all accesses should be protected by an external lock.\n+template<class BV>\n+class BVGraph {\n+ public:\n+  enum SizeEnum { kSize = BV::kSize };\n+  uptr size() const { return kSize; }\n+  // No CTOR.\n+  void clear() {\n+    for (uptr i = 0; i < size(); i++)\n+      v[i].clear();\n+  }\n+\n+  bool empty() const {\n+    for (uptr i = 0; i < size(); i++)\n+      if (!v[i].empty())\n+        return false;\n+    return true;\n+  }\n+\n+  // Returns true if a new edge was added.\n+  bool addEdge(uptr from, uptr to) {\n+    check(from, to);\n+    return v[from].setBit(to);\n+  }\n+\n+  // Returns true if at least one new edge was added.\n+  uptr addEdges(const BV &from, uptr to, uptr added_edges[],\n+                uptr max_added_edges) {\n+    uptr res = 0;\n+    t1.copyFrom(from);\n+    while (!t1.empty()) {\n+      uptr node = t1.getAndClearFirstOne();\n+      if (v[node].setBit(to))\n+        if (res < max_added_edges)\n+          added_edges[res++] = node;\n+    }\n+    return res;\n+  }\n+\n+  // *EXPERIMENTAL*\n+  // Returns true if an edge from=>to exist.\n+  // This function does not use any global state except for 'this' itself,\n+  // and thus can be called from different threads w/o locking.\n+  // This would be racy.\n+  // FIXME: investigate how much we can prove about this race being \"benign\".\n+  bool hasEdge(uptr from, uptr to) { return v[from].getBit(to); }\n+\n+  // Returns true if the edge from=>to was removed.\n+  bool removeEdge(uptr from, uptr to) {\n+    return v[from].clearBit(to);\n+  }\n+\n+  // Returns true if at least one edge *=>to was removed.\n+  bool removeEdgesTo(const BV &to) {\n+    bool res = 0;\n+    for (uptr from = 0; from < size(); from++) {\n+      if (v[from].setDifference(to))\n+        res = true;\n+    }\n+    return res;\n+  }\n+\n+  // Returns true if at least one edge from=>* was removed.\n+  bool removeEdgesFrom(const BV &from) {\n+    bool res = false;\n+    t1.copyFrom(from);\n+    while (!t1.empty()) {\n+      uptr idx = t1.getAndClearFirstOne();\n+      if (!v[idx].empty()) {\n+        v[idx].clear();\n+        res = true;\n+      }\n+    }\n+    return res;\n+  }\n+\n+  void removeEdgesFrom(uptr from) {\n+    return v[from].clear();\n+  }\n+\n+  bool hasEdge(uptr from, uptr to) const {\n+    check(from, to);\n+    return v[from].getBit(to);\n+  }\n+\n+  // Returns true if there is a path from the node 'from'\n+  // to any of the nodes in 'targets'.\n+  bool isReachable(uptr from, const BV &targets) {\n+    BV &to_visit = t1,\n+       &visited = t2;\n+    to_visit.copyFrom(v[from]);\n+    visited.clear();\n+    visited.setBit(from);\n+    while (!to_visit.empty()) {\n+      uptr idx = to_visit.getAndClearFirstOne();\n+      if (visited.setBit(idx))\n+        to_visit.setUnion(v[idx]);\n+    }\n+    return targets.intersectsWith(visited);\n+  }\n+\n+  // Finds a path from 'from' to one of the nodes in 'target',\n+  // stores up to 'path_size' items of the path into 'path',\n+  // returns the path length, or 0 if there is no path of size 'path_size'.\n+  uptr findPath(uptr from, const BV &targets, uptr *path, uptr path_size) {\n+    if (path_size == 0)\n+      return 0;\n+    path[0] = from;\n+    if (targets.getBit(from))\n+      return 1;\n+    // The function is recursive, so we don't want to create BV on stack.\n+    // Instead of a getAndClearFirstOne loop we use the slower iterator.\n+    for (typename BV::Iterator it(v[from]); it.hasNext(); ) {\n+      uptr idx = it.next();\n+      if (uptr res = findPath(idx, targets, path + 1, path_size - 1))\n+        return res + 1;\n+    }\n+    return 0;\n+  }\n+\n+  // Same as findPath, but finds a shortest path.\n+  uptr findShortestPath(uptr from, const BV &targets, uptr *path,\n+                        uptr path_size) {\n+    for (uptr p = 1; p <= path_size; p++)\n+      if (findPath(from, targets, path, p) == p)\n+        return p;\n+    return 0;\n+  }\n+\n+ private:\n+  void check(uptr idx1, uptr idx2) const {\n+    CHECK_LT(idx1, size());\n+    CHECK_LT(idx2, size());\n+  }\n+  BV v[kSize];\n+  // Keep temporary vectors here since we can not create large objects on stack.\n+  BV t1, t2;\n+};\n+\n+} // namespace __sanitizer\n+\n+#endif // SANITIZER_BVGRAPH_H"}, {"sha": "e76d4d558a1fb7edc62eea4c8b9b83fbf3b7307b", "filename": "libsanitizer/sanitizer_common/sanitizer_common.cc", "status": "modified", "additions": 32, "deletions": 6, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -91,7 +91,7 @@ uptr ReadFileToBuffer(const char *file_name, char **buff,\n     if (internal_iserror(openrv)) return 0;\n     fd_t fd = openrv;\n     UnmapOrDie(*buff, *buff_size);\n-    *buff = (char*)MmapOrDie(size, __FUNCTION__);\n+    *buff = (char*)MmapOrDie(size, __func__);\n     *buff_size = size;\n     // Read up to one page at a time.\n     read_len = 0;\n@@ -200,11 +200,11 @@ void ReportErrorSummary(const char *error_type, StackTrace *stack) {\n     return;\n   AddressInfo ai;\n #if !SANITIZER_GO\n-  if (stack->size > 0 && Symbolizer::Get()->IsAvailable()) {\n+  if (stack->size > 0 && Symbolizer::Get()->CanReturnFileLineInfo()) {\n     // Currently, we include the first stack frame into the report summary.\n     // Maybe sometimes we need to choose another frame (e.g. skip memcpy/etc).\n     uptr pc = StackTrace::GetPreviousInstructionPc(stack->trace[0]);\n-    Symbolizer::Get()->SymbolizeCode(pc, &ai, 1);\n+    Symbolizer::Get()->SymbolizePC(pc, &ai, 1);\n   }\n #endif\n   ReportErrorSummary(error_type, ai.file, ai.line, ai.function);\n@@ -242,6 +242,30 @@ char *StripModuleName(const char *module) {\n   return internal_strdup(short_module_name);\n }\n \n+static atomic_uintptr_t g_total_mmaped;\n+\n+void IncreaseTotalMmap(uptr size) {\n+  if (!common_flags()->mmap_limit_mb) return;\n+  uptr total_mmaped =\n+      atomic_fetch_add(&g_total_mmaped, size, memory_order_relaxed) + size;\n+  if ((total_mmaped >> 20) > common_flags()->mmap_limit_mb) {\n+    // Since for now mmap_limit_mb is not a user-facing flag, just CHECK.\n+    uptr mmap_limit_mb = common_flags()->mmap_limit_mb;\n+    common_flags()->mmap_limit_mb = 0;  // Allow mmap in CHECK.\n+    RAW_CHECK(total_mmaped >> 20 < mmap_limit_mb);\n+  }\n+}\n+\n+void DecreaseTotalMmap(uptr size) {\n+  if (!common_flags()->mmap_limit_mb) return;\n+  atomic_fetch_sub(&g_total_mmaped, size, memory_order_relaxed);\n+}\n+\n+static void (*sandboxing_callback)();\n+void SetSandboxingCallback(void (*f)()) {\n+  sandboxing_callback = f;\n+}\n+\n }  // namespace __sanitizer\n \n using namespace __sanitizer;  // NOLINT\n@@ -274,9 +298,11 @@ void __sanitizer_set_report_path(const char *path) {\n   }\n }\n \n-void NOINLINE __sanitizer_sandbox_on_notify(void *reserved) {\n-  (void)reserved;\n-  PrepareForSandboxing();\n+void NOINLINE\n+__sanitizer_sandbox_on_notify(__sanitizer_sandbox_arguments *args) {\n+  PrepareForSandboxing(args);\n+  if (sandboxing_callback)\n+    sandboxing_callback();\n }\n \n void __sanitizer_report_error_summary(const char *error_summary) {"}, {"sha": "86171068f6e5320ae1233aa6ea03476c109499cd", "filename": "libsanitizer/sanitizer_common/sanitizer_common.h", "status": "modified", "additions": 67, "deletions": 11, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -17,6 +17,7 @@\n #include \"sanitizer_internal_defs.h\"\n #include \"sanitizer_libc.h\"\n #include \"sanitizer_mutex.h\"\n+#include \"sanitizer_flags.h\"\n \n namespace __sanitizer {\n struct StackTrace;\n@@ -25,14 +26,12 @@ struct StackTrace;\n const uptr kWordSize = SANITIZER_WORDSIZE / 8;\n const uptr kWordSizeInBits = 8 * kWordSize;\n \n-#if defined(__powerpc__) || defined(__powerpc64__)\n-const uptr kCacheLineSize = 128;\n-#else\n const uptr kCacheLineSize = 64;\n-#endif\n \n const uptr kMaxPathLength = 512;\n \n+const uptr kMaxThreadStackSize = 1 << 30;  // 1Gb\n+\n extern const char *SanitizerToolName;  // Can be changed by the tool.\n \n uptr GetPageSize();\n@@ -51,13 +50,16 @@ void GetThreadStackAndTls(bool main, uptr *stk_addr, uptr *stk_size,\n void *MmapOrDie(uptr size, const char *mem_type);\n void UnmapOrDie(void *addr, uptr size);\n void *MmapFixedNoReserve(uptr fixed_addr, uptr size);\n+void *MmapNoReserveOrDie(uptr size, const char *mem_type);\n void *MmapFixedOrDie(uptr fixed_addr, uptr size);\n void *Mprotect(uptr fixed_addr, uptr size);\n // Map aligned chunk of address space; size and alignment are powers of two.\n void *MmapAlignedOrDie(uptr size, uptr alignment, const char *mem_type);\n // Used to check if we can map shadow memory to a fixed location.\n bool MemoryRangeIsAvailable(uptr range_start, uptr range_end);\n void FlushUnneededShadowMemory(uptr addr, uptr size);\n+void IncreaseTotalMmap(uptr size);\n+void DecreaseTotalMmap(uptr size);\n \n // InternalScopedBuffer can be used instead of large stack arrays to\n // keep frame size low.\n@@ -123,9 +125,18 @@ void RawWrite(const char *buffer);\n bool PrintsToTty();\n // Caching version of PrintsToTty(). Not thread-safe.\n bool PrintsToTtyCached();\n+bool ColorizeReports();\n void Printf(const char *format, ...);\n void Report(const char *format, ...);\n void SetPrintfAndReportCallback(void (*callback)(const char *));\n+#define VReport(level, ...)                                              \\\n+  do {                                                                   \\\n+    if ((uptr)common_flags()->verbosity >= (level)) Report(__VA_ARGS__); \\\n+  } while (0)\n+#define VPrintf(level, ...)                                              \\\n+  do {                                                                   \\\n+    if ((uptr)common_flags()->verbosity >= (level)) Printf(__VA_ARGS__); \\\n+  } while (0)\n \n // Can be used to prevent mixing error reports from different sanitizers.\n extern StaticSpinMutex CommonSanitizerReportMutex;\n@@ -169,7 +180,10 @@ u32 GetUid();\n void ReExec();\n bool StackSizeIsUnlimited();\n void SetStackSizeLimitInBytes(uptr limit);\n-void PrepareForSandboxing();\n+void AdjustStackSize(void *attr);\n+void PrepareForSandboxing(__sanitizer_sandbox_arguments *args);\n+void CovPrepareForSandboxing(__sanitizer_sandbox_arguments *args);\n+void SetSandboxingCallback(void (*f)());\n \n void InitTlsSize();\n uptr GetTlsSize();\n@@ -206,6 +220,14 @@ typedef void (*CheckFailedCallbackType)(const char *, int, const char *,\n                                        u64, u64);\n void SetCheckFailedCallback(CheckFailedCallbackType callback);\n \n+// Functions related to signal handling.\n+typedef void (*SignalHandlerType)(int, void *, void *);\n+bool IsDeadlySignal(int signum);\n+void InstallDeadlySignalHandlers(SignalHandlerType handler);\n+// Alternative signal stack (POSIX-only).\n+void SetAlternateSignalStack();\n+void UnsetAlternateSignalStack();\n+\n // We don't want a summary too long.\n const int kMaxSummaryLength = 1024;\n // Construct a one-line string:\n@@ -243,6 +265,19 @@ INLINE uptr MostSignificantSetBitIndex(uptr x) {\n   return up;\n }\n \n+INLINE uptr LeastSignificantSetBitIndex(uptr x) {\n+  CHECK_NE(x, 0U);\n+  unsigned long up;  // NOLINT\n+#if !SANITIZER_WINDOWS || defined(__clang__) || defined(__GNUC__)\n+  up = __builtin_ctzl(x);\n+#elif defined(_WIN64)\n+  _BitScanForward64(&up, x);\n+#else\n+  _BitScanForward(&up, x);\n+#endif\n+  return up;\n+}\n+\n INLINE bool IsPowerOfTwo(uptr x) {\n   return (x & (x - 1)) == 0;\n }\n@@ -307,12 +342,6 @@ INLINE int ToLower(int c) {\n   return (c >= 'A' && c <= 'Z') ? (c + 'a' - 'A') : c;\n }\n \n-#if SANITIZER_WORDSIZE == 64\n-# define FIRST_32_SECOND_64(a, b) (b)\n-#else\n-# define FIRST_32_SECOND_64(a, b) (a)\n-#endif\n-\n // A low-level vector based on mmap. May incur a significant memory overhead for\n // small vectors.\n // WARNING: The current implementation supports only POD types.\n@@ -477,6 +506,33 @@ const uptr kPthreadDestructorIterations = 0;\n \n // Callback type for iterating over a set of memory ranges.\n typedef void (*RangeIteratorCallback)(uptr begin, uptr end, void *arg);\n+\n+#if (SANITIZER_FREEBSD || SANITIZER_LINUX) && !defined(SANITIZER_GO)\n+extern uptr indirect_call_wrapper;\n+void SetIndirectCallWrapper(uptr wrapper);\n+\n+template <typename F>\n+F IndirectExternCall(F f) {\n+  typedef F (*WrapF)(F);\n+  return indirect_call_wrapper ? ((WrapF)indirect_call_wrapper)(f) : f;\n+}\n+#else\n+INLINE void SetIndirectCallWrapper(uptr wrapper) {}\n+template <typename F>\n+F IndirectExternCall(F f) {\n+  return f;\n+}\n+#endif\n+\n+#if SANITIZER_ANDROID\n+void AndroidLogWrite(const char *buffer);\n+void GetExtraActivationFlags(char *buf, uptr size);\n+void SanitizerInitializeUnwinder();\n+#else\n+INLINE void AndroidLogWrite(const char *buffer_unused) {}\n+INLINE void GetExtraActivationFlags(char *buf, uptr size) { *buf = '\\0'; }\n+INLINE void SanitizerInitializeUnwinder() {}\n+#endif\n }  // namespace __sanitizer\n \n inline void *operator new(__sanitizer::operator_new_size_type size,"}, {"sha": "f758c1a6c5263e14e6bf84c3135de2054822a5fc", "filename": "libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc", "status": "modified", "additions": 1446, "deletions": 290, "changes": 1736, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.inc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -26,7 +26,10 @@\n //   COMMON_INTERCEPTOR_HANDLE_RECVMSG\n //===----------------------------------------------------------------------===//\n #include \"interception/interception.h\"\n+#include \"sanitizer_addrhashmap.h\"\n+#include \"sanitizer_placement_new.h\"\n #include \"sanitizer_platform_interceptors.h\"\n+#include \"sanitizer_tls_get_addr.h\"\n \n #include <stdarg.h>\n \n@@ -35,7 +38,11 @@\n #endif // _WIN32\n \n #ifndef COMMON_INTERCEPTOR_INITIALIZE_RANGE\n-#define COMMON_INTERCEPTOR_INITIALIZE_RANGE(ctx, p, size) {}\n+#define COMMON_INTERCEPTOR_INITIALIZE_RANGE(p, size) {}\n+#endif\n+\n+#ifndef COMMON_INTERCEPTOR_UNPOISON_PARAM\n+#define COMMON_INTERCEPTOR_UNPOISON_PARAM(count) {}\n #endif\n \n #ifndef COMMON_INTERCEPTOR_FD_ACCESS\n@@ -58,14 +65,70 @@\n #define COMMON_INTERCEPTOR_HANDLE_RECVMSG(ctx, msg) ((void)(msg))\n #endif\n \n+#ifndef COMMON_INTERCEPTOR_FILE_OPEN\n+#define COMMON_INTERCEPTOR_FILE_OPEN(ctx, file, path) {}\n+#endif\n+\n+#ifndef COMMON_INTERCEPTOR_FILE_CLOSE\n+#define COMMON_INTERCEPTOR_FILE_CLOSE(ctx, file) {}\n+#endif\n+\n+struct FileMetadata {\n+  // For open_memstream().\n+  char **addr;\n+  SIZE_T *size;\n+};\n+\n+struct CommonInterceptorMetadata {\n+  enum {\n+    CIMT_INVALID = 0,\n+    CIMT_FILE\n+  } type;\n+  union {\n+    FileMetadata file;\n+  };\n+};\n+\n+typedef AddrHashMap<CommonInterceptorMetadata, 31051> MetadataHashMap;\n+\n+static MetadataHashMap *interceptor_metadata_map;\n+\n+#if SI_NOT_WINDOWS\n+UNUSED static void SetInterceptorMetadata(__sanitizer_FILE *addr,\n+                                          const FileMetadata &file) {\n+  MetadataHashMap::Handle h(interceptor_metadata_map, (uptr)addr);\n+  CHECK(h.created());\n+  h->type = CommonInterceptorMetadata::CIMT_FILE;\n+  h->file = file;\n+}\n+\n+UNUSED static const FileMetadata *GetInterceptorMetadata(\n+    __sanitizer_FILE *addr) {\n+  MetadataHashMap::Handle h(interceptor_metadata_map, (uptr)addr,\n+                            /* remove */ false,\n+                            /* create */ false);\n+  if (h.exists()) {\n+    CHECK(!h.created());\n+    CHECK(h->type == CommonInterceptorMetadata::CIMT_FILE);\n+    return &h->file;\n+  } else {\n+    return 0;\n+  }\n+}\n+\n+UNUSED static void DeleteInterceptorMetadata(void *addr) {\n+  MetadataHashMap::Handle h(interceptor_metadata_map, (uptr)addr, true);\n+  CHECK(h.exists());\n+}\n+#endif  // SI_NOT_WINDOWS\n+\n #if SANITIZER_INTERCEPT_TEXTDOMAIN\n INTERCEPTOR(char*, textdomain, const char *domainname) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, textdomain, domainname);\n   char* domain = REAL(textdomain)(domainname);\n   if (domain) {\n-    COMMON_INTERCEPTOR_INITIALIZE_RANGE(ctx, domain,\n-        REAL(strlen)(domain) + 1);\n+    COMMON_INTERCEPTOR_INITIALIZE_RANGE(domain, REAL(strlen)(domain) + 1);\n   }\n   return domain;\n }\n@@ -160,6 +223,34 @@ INTERCEPTOR(int, strncasecmp, const char *s1, const char *s2, SIZE_T n) {\n #define INIT_STRNCASECMP\n #endif\n \n+#if SANITIZER_INTERCEPT_MEMCHR\n+INTERCEPTOR(void*, memchr, const void *s, int c, SIZE_T n) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, memchr, s, c, n);\n+  void *res = REAL(memchr)(s, c, n);\n+  uptr len = res ? (char*)res - (char*)s + 1 : n;\n+  COMMON_INTERCEPTOR_READ_RANGE(ctx, s, len);\n+  return res;\n+}\n+\n+#define INIT_MEMCHR COMMON_INTERCEPT_FUNCTION(memchr)\n+#else\n+#define INIT_MEMCHR\n+#endif\n+\n+#if SANITIZER_INTERCEPT_MEMRCHR\n+INTERCEPTOR(void*, memrchr, const void *s, int c, SIZE_T n) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, memrchr, s, c, n);\n+  COMMON_INTERCEPTOR_READ_RANGE(ctx, s, n);\n+  return REAL(memrchr)(s, c, n);\n+}\n+\n+#define INIT_MEMRCHR COMMON_INTERCEPT_FUNCTION(memrchr)\n+#else\n+#define INIT_MEMRCHR\n+#endif\n+\n #if SANITIZER_INTERCEPT_FREXP\n INTERCEPTOR(double, frexp, double x, int *exp) {\n   void *ctx;\n@@ -449,7 +540,7 @@ static void unpoison_tm(void *ctx, __sanitizer_tm *tm) {\n   if (tm->tm_zone) {\n     // Can not use COMMON_INTERCEPTOR_WRITE_RANGE here, because tm->tm_zone\n     // can point to shared memory and tsan would report a data race.\n-    COMMON_INTERCEPTOR_INITIALIZE_RANGE(ctx, tm->tm_zone,\n+    COMMON_INTERCEPTOR_INITIALIZE_RANGE(tm->tm_zone,\n                                         REAL(strlen(tm->tm_zone)) + 1);\n   }\n }\n@@ -533,6 +624,20 @@ INTERCEPTOR(char *, asctime_r, __sanitizer_tm *tm, char *result) {\n   }\n   return res;\n }\n+INTERCEPTOR(long, mktime, __sanitizer_tm *tm) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, mktime, tm);\n+  COMMON_INTERCEPTOR_READ_RANGE(ctx, &tm->tm_sec, sizeof(tm->tm_sec));\n+  COMMON_INTERCEPTOR_READ_RANGE(ctx, &tm->tm_min, sizeof(tm->tm_min));\n+  COMMON_INTERCEPTOR_READ_RANGE(ctx, &tm->tm_hour, sizeof(tm->tm_hour));\n+  COMMON_INTERCEPTOR_READ_RANGE(ctx, &tm->tm_mday, sizeof(tm->tm_mday));\n+  COMMON_INTERCEPTOR_READ_RANGE(ctx, &tm->tm_mon, sizeof(tm->tm_mon));\n+  COMMON_INTERCEPTOR_READ_RANGE(ctx, &tm->tm_year, sizeof(tm->tm_year));\n+  COMMON_INTERCEPTOR_READ_RANGE(ctx, &tm->tm_isdst, sizeof(tm->tm_isdst));\n+  long res = REAL(mktime)(tm);\n+  if (res != -1) unpoison_tm(ctx, tm);\n+  return res;\n+}\n #define INIT_LOCALTIME_AND_FRIENDS        \\\n   COMMON_INTERCEPT_FUNCTION(localtime);   \\\n   COMMON_INTERCEPT_FUNCTION(localtime_r); \\\n@@ -541,7 +646,8 @@ INTERCEPTOR(char *, asctime_r, __sanitizer_tm *tm, char *result) {\n   COMMON_INTERCEPT_FUNCTION(ctime);       \\\n   COMMON_INTERCEPT_FUNCTION(ctime_r);     \\\n   COMMON_INTERCEPT_FUNCTION(asctime);     \\\n-  COMMON_INTERCEPT_FUNCTION(asctime_r);\n+  COMMON_INTERCEPT_FUNCTION(asctime_r);   \\\n+  COMMON_INTERCEPT_FUNCTION(mktime);\n #else\n #define INIT_LOCALTIME_AND_FRIENDS\n #endif  // SANITIZER_INTERCEPT_LOCALTIME_AND_FRIENDS\n@@ -567,9 +673,23 @@ INTERCEPTOR(char *, strptime, char *s, char *format, __sanitizer_tm *tm) {\n #define INIT_STRPTIME\n #endif\n \n-#if SANITIZER_INTERCEPT_SCANF\n+#if SANITIZER_INTERCEPT_SCANF || SANITIZER_INTERCEPT_PRINTF\n+#include \"sanitizer_common_interceptors_format.inc\"\n \n-#include \"sanitizer_common_interceptors_scanf.inc\"\n+#define FORMAT_INTERCEPTOR_IMPL(name, vname, ...)                              \\\n+  {                                                                            \\\n+    void *ctx;                                                                 \\\n+    va_list ap;                                                                \\\n+    va_start(ap, format);                                                      \\\n+    COMMON_INTERCEPTOR_ENTER(ctx, vname, __VA_ARGS__, ap);                     \\\n+    int res = WRAP(vname)(__VA_ARGS__, ap);                                    \\\n+    va_end(ap);                                                                \\\n+    return res;                                                                \\\n+  }\n+\n+#endif\n+\n+#if SANITIZER_INTERCEPT_SCANF\n \n #define VSCANF_INTERCEPTOR_IMPL(vname, allowGnuMalloc, ...)                    \\\n   {                                                                            \\\n@@ -605,35 +725,24 @@ INTERCEPTOR(int, __isoc99_vfscanf, void *stream, const char *format, va_list ap)\n VSCANF_INTERCEPTOR_IMPL(__isoc99_vfscanf, false, stream, format, ap)\n #endif  // SANITIZER_INTERCEPT_ISOC99_SCANF\n \n-#define SCANF_INTERCEPTOR_IMPL(name, vname, ...)                               \\\n-  {                                                                            \\\n-    void *ctx;                                                                 \\\n-    va_list ap;                                                                \\\n-    va_start(ap, format);                                                      \\\n-    COMMON_INTERCEPTOR_ENTER(ctx, vname, __VA_ARGS__, ap);                     \\\n-    int res = vname(__VA_ARGS__, ap);                                          \\\n-    va_end(ap);                                                                \\\n-    return res;                                                                \\\n-  }\n-\n INTERCEPTOR(int, scanf, const char *format, ...)\n-SCANF_INTERCEPTOR_IMPL(scanf, vscanf, format)\n+FORMAT_INTERCEPTOR_IMPL(scanf, vscanf, format)\n \n INTERCEPTOR(int, fscanf, void *stream, const char *format, ...)\n-SCANF_INTERCEPTOR_IMPL(fscanf, vfscanf, stream, format)\n+FORMAT_INTERCEPTOR_IMPL(fscanf, vfscanf, stream, format)\n \n INTERCEPTOR(int, sscanf, const char *str, const char *format, ...)\n-SCANF_INTERCEPTOR_IMPL(sscanf, vsscanf, str, format)\n+FORMAT_INTERCEPTOR_IMPL(sscanf, vsscanf, str, format)\n \n #if SANITIZER_INTERCEPT_ISOC99_SCANF\n INTERCEPTOR(int, __isoc99_scanf, const char *format, ...)\n-SCANF_INTERCEPTOR_IMPL(__isoc99_scanf, __isoc99_vscanf, format)\n+FORMAT_INTERCEPTOR_IMPL(__isoc99_scanf, __isoc99_vscanf, format)\n \n INTERCEPTOR(int, __isoc99_fscanf, void *stream, const char *format, ...)\n-SCANF_INTERCEPTOR_IMPL(__isoc99_fscanf, __isoc99_vfscanf, stream, format)\n+FORMAT_INTERCEPTOR_IMPL(__isoc99_fscanf, __isoc99_vfscanf, stream, format)\n \n INTERCEPTOR(int, __isoc99_sscanf, const char *str, const char *format, ...)\n-SCANF_INTERCEPTOR_IMPL(__isoc99_sscanf, __isoc99_vsscanf, str, format)\n+FORMAT_INTERCEPTOR_IMPL(__isoc99_sscanf, __isoc99_vsscanf, str, format)\n #endif\n \n #endif\n@@ -662,6 +771,171 @@ SCANF_INTERCEPTOR_IMPL(__isoc99_sscanf, __isoc99_vsscanf, str, format)\n #define INIT_ISOC99_SCANF\n #endif\n \n+#if SANITIZER_INTERCEPT_PRINTF\n+\n+#define VPRINTF_INTERCEPTOR_ENTER(vname, ...)                                  \\\n+  void *ctx;                                                                   \\\n+  COMMON_INTERCEPTOR_ENTER(ctx, vname, __VA_ARGS__);                           \\\n+  va_list aq;                                                                  \\\n+  va_copy(aq, ap);\n+\n+#define VPRINTF_INTERCEPTOR_RETURN()                                           \\\n+  va_end(aq);\n+\n+#define VPRINTF_INTERCEPTOR_IMPL(vname, ...)                                   \\\n+  {                                                                            \\\n+    VPRINTF_INTERCEPTOR_ENTER(vname, __VA_ARGS__);                             \\\n+    if (common_flags()->check_printf)                                          \\\n+      printf_common(ctx, format, aq);                                          \\\n+    int res = REAL(vname)(__VA_ARGS__);                                        \\\n+    VPRINTF_INTERCEPTOR_RETURN();                                              \\\n+    return res;                                                                \\\n+  }\n+\n+#define VSPRINTF_INTERCEPTOR_IMPL(vname, str, ...)                             \\\n+  {                                                                            \\\n+    VPRINTF_INTERCEPTOR_ENTER(vname, str, __VA_ARGS__)                         \\\n+    if (common_flags()->check_printf) {                                        \\\n+      printf_common(ctx, format, aq);                                          \\\n+    }                                                                          \\\n+    int res = REAL(vname)(str, __VA_ARGS__);                                   \\\n+    if (res >= 0) {                                                            \\\n+      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, str, res + 1);                       \\\n+    }                                                                          \\\n+    VPRINTF_INTERCEPTOR_RETURN();                                              \\\n+    return res;                                                                \\\n+  }\n+\n+#define VSNPRINTF_INTERCEPTOR_IMPL(vname, str, size, ...)                      \\\n+  {                                                                            \\\n+    VPRINTF_INTERCEPTOR_ENTER(vname, str, size, __VA_ARGS__)                   \\\n+    if (common_flags()->check_printf) {                                        \\\n+      printf_common(ctx, format, aq);                                          \\\n+    }                                                                          \\\n+    int res = REAL(vname)(str, size, __VA_ARGS__);                             \\\n+    if (res >= 0) {                                                            \\\n+      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, str, Min(size, (SIZE_T)(res + 1)));  \\\n+    }                                                                          \\\n+    VPRINTF_INTERCEPTOR_RETURN();                                              \\\n+    return res;                                                                \\\n+  }\n+\n+#define VASPRINTF_INTERCEPTOR_IMPL(vname, strp, ...)                           \\\n+  {                                                                            \\\n+    VPRINTF_INTERCEPTOR_ENTER(vname, strp, __VA_ARGS__)                        \\\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, strp, sizeof(char *));                 \\\n+    if (common_flags()->check_printf) {                                        \\\n+      printf_common(ctx, format, aq);                                          \\\n+    }                                                                          \\\n+    int res = REAL(vname)(strp, __VA_ARGS__);                                  \\\n+    if (res >= 0) {                                                            \\\n+      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, *strp, res + 1);                     \\\n+    }                                                                          \\\n+    VPRINTF_INTERCEPTOR_RETURN();                                              \\\n+    return res;                                                                \\\n+  }\n+\n+INTERCEPTOR(int, vprintf, const char *format, va_list ap)\n+VPRINTF_INTERCEPTOR_IMPL(vprintf, format, ap)\n+\n+INTERCEPTOR(int, vfprintf, __sanitizer_FILE *stream, const char *format,\n+            va_list ap)\n+VPRINTF_INTERCEPTOR_IMPL(vfprintf, stream, format, ap)\n+\n+INTERCEPTOR(int, vsnprintf, char *str, SIZE_T size, const char *format,\n+            va_list ap)\n+VSNPRINTF_INTERCEPTOR_IMPL(vsnprintf, str, size, format, ap)\n+\n+INTERCEPTOR(int, vsprintf, char *str, const char *format, va_list ap)\n+VSPRINTF_INTERCEPTOR_IMPL(vsprintf, str, format, ap)\n+\n+INTERCEPTOR(int, vasprintf, char **strp, const char *format, va_list ap)\n+VASPRINTF_INTERCEPTOR_IMPL(vasprintf, strp, format, ap)\n+\n+#if SANITIZER_INTERCEPT_ISOC99_PRINTF\n+INTERCEPTOR(int, __isoc99_vprintf, const char *format, va_list ap)\n+VPRINTF_INTERCEPTOR_IMPL(__isoc99_vprintf, format, ap)\n+\n+INTERCEPTOR(int, __isoc99_vfprintf, __sanitizer_FILE *stream,\n+            const char *format, va_list ap)\n+VPRINTF_INTERCEPTOR_IMPL(__isoc99_vfprintf, stream, format, ap)\n+\n+INTERCEPTOR(int, __isoc99_vsnprintf, char *str, SIZE_T size, const char *format,\n+            va_list ap)\n+VSNPRINTF_INTERCEPTOR_IMPL(__isoc99_vsnprintf, str, size, format, ap)\n+\n+INTERCEPTOR(int, __isoc99_vsprintf, char *str, const char *format,\n+            va_list ap)\n+VSPRINTF_INTERCEPTOR_IMPL(__isoc99_vsprintf, str, format,\n+                          ap)\n+\n+#endif  // SANITIZER_INTERCEPT_ISOC99_PRINTF\n+\n+INTERCEPTOR(int, printf, const char *format, ...)\n+FORMAT_INTERCEPTOR_IMPL(printf, vprintf, format)\n+\n+INTERCEPTOR(int, fprintf, __sanitizer_FILE *stream, const char *format, ...)\n+FORMAT_INTERCEPTOR_IMPL(fprintf, vfprintf, stream, format)\n+\n+INTERCEPTOR(int, sprintf, char *str, const char *format, ...) // NOLINT\n+FORMAT_INTERCEPTOR_IMPL(sprintf, vsprintf, str, format) // NOLINT\n+\n+INTERCEPTOR(int, snprintf, char *str, SIZE_T size, const char *format, ...)\n+FORMAT_INTERCEPTOR_IMPL(snprintf, vsnprintf, str, size, format)\n+\n+INTERCEPTOR(int, asprintf, char **strp, const char *format, ...)\n+FORMAT_INTERCEPTOR_IMPL(asprintf, vasprintf, strp, format)\n+\n+#if SANITIZER_INTERCEPT_ISOC99_PRINTF\n+INTERCEPTOR(int, __isoc99_printf, const char *format, ...)\n+FORMAT_INTERCEPTOR_IMPL(__isoc99_printf, __isoc99_vprintf, format)\n+\n+INTERCEPTOR(int, __isoc99_fprintf, __sanitizer_FILE *stream, const char *format,\n+            ...)\n+FORMAT_INTERCEPTOR_IMPL(__isoc99_fprintf, __isoc99_vfprintf, stream, format)\n+\n+INTERCEPTOR(int, __isoc99_sprintf, char *str, const char *format, ...)\n+FORMAT_INTERCEPTOR_IMPL(__isoc99_sprintf, __isoc99_vsprintf, str, format)\n+\n+INTERCEPTOR(int, __isoc99_snprintf, char *str, SIZE_T size,\n+            const char *format, ...)\n+FORMAT_INTERCEPTOR_IMPL(__isoc99_snprintf, __isoc99_vsnprintf, str, size,\n+                        format)\n+\n+#endif  // SANITIZER_INTERCEPT_ISOC99_PRINTF\n+\n+#endif  // SANITIZER_INTERCEPT_PRINTF\n+\n+#if SANITIZER_INTERCEPT_PRINTF\n+#define INIT_PRINTF                     \\\n+  COMMON_INTERCEPT_FUNCTION(printf);    \\\n+  COMMON_INTERCEPT_FUNCTION(sprintf);   \\\n+  COMMON_INTERCEPT_FUNCTION(snprintf);  \\\n+  COMMON_INTERCEPT_FUNCTION(asprintf);  \\\n+  COMMON_INTERCEPT_FUNCTION(fprintf);   \\\n+  COMMON_INTERCEPT_FUNCTION(vprintf);   \\\n+  COMMON_INTERCEPT_FUNCTION(vsprintf);  \\\n+  COMMON_INTERCEPT_FUNCTION(vsnprintf); \\\n+  COMMON_INTERCEPT_FUNCTION(vasprintf); \\\n+  COMMON_INTERCEPT_FUNCTION(vfprintf);\n+#else\n+#define INIT_PRINTF\n+#endif\n+\n+#if SANITIZER_INTERCEPT_ISOC99_PRINTF\n+#define INIT_ISOC99_PRINTF                       \\\n+  COMMON_INTERCEPT_FUNCTION(__isoc99_printf);    \\\n+  COMMON_INTERCEPT_FUNCTION(__isoc99_sprintf);   \\\n+  COMMON_INTERCEPT_FUNCTION(__isoc99_snprintf);  \\\n+  COMMON_INTERCEPT_FUNCTION(__isoc99_fprintf);   \\\n+  COMMON_INTERCEPT_FUNCTION(__isoc99_vprintf);   \\\n+  COMMON_INTERCEPT_FUNCTION(__isoc99_vsprintf);  \\\n+  COMMON_INTERCEPT_FUNCTION(__isoc99_vsnprintf); \\\n+  COMMON_INTERCEPT_FUNCTION(__isoc99_vfprintf);\n+#else\n+#define INIT_ISOC99_PRINTF\n+#endif\n+\n #if SANITIZER_INTERCEPT_IOCTL\n #include \"sanitizer_common_interceptors_ioctl.inc\"\n INTERCEPTOR(int, ioctl, int d, unsigned request, void *arg) {\n@@ -675,7 +949,14 @@ INTERCEPTOR(int, ioctl, int d, unsigned request, void *arg) {\n   if (!common_flags()->handle_ioctl) return REAL(ioctl)(d, request, arg);\n \n   const ioctl_desc *desc = ioctl_lookup(request);\n-  if (!desc) Printf(\"WARNING: unknown ioctl %x\\n\", request);\n+  ioctl_desc decoded_desc;\n+  if (!desc) {\n+    VPrintf(2, \"Decoding unknown ioctl 0x%x\\n\", request);\n+    if (!ioctl_decode(request, &decoded_desc))\n+      Printf(\"WARNING: failed decoding unknown ioctl 0x%x\\n\", request);\n+    else\n+      desc = &decoded_desc;\n+  }\n \n   if (desc) ioctl_common_pre(ctx, desc, d, request, arg);\n   int res = REAL(ioctl)(d, request, arg);\n@@ -690,35 +971,85 @@ INTERCEPTOR(int, ioctl, int d, unsigned request, void *arg) {\n #define INIT_IOCTL\n #endif\n \n+#if SANITIZER_INTERCEPT_GETPWNAM_AND_FRIENDS || \\\n+    SANITIZER_INTERCEPT_GETPWENT || SANITIZER_INTERCEPT_FGETPWENT\n+static void unpoison_passwd(void *ctx, __sanitizer_passwd *pwd) {\n+  if (pwd) {\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, pwd, sizeof(*pwd));\n+    if (pwd->pw_name)\n+      COMMON_INTERCEPTOR_INITIALIZE_RANGE(pwd->pw_name,\n+                                          REAL(strlen)(pwd->pw_name) + 1);\n+    if (pwd->pw_passwd)\n+      COMMON_INTERCEPTOR_INITIALIZE_RANGE(pwd->pw_passwd,\n+                                          REAL(strlen)(pwd->pw_passwd) + 1);\n+#if !SANITIZER_ANDROID\n+    if (pwd->pw_gecos)\n+      COMMON_INTERCEPTOR_INITIALIZE_RANGE(pwd->pw_gecos,\n+                                          REAL(strlen)(pwd->pw_gecos) + 1);\n+#endif\n+#if SANITIZER_MAC\n+    if (pwd->pw_class)\n+      COMMON_INTERCEPTOR_INITIALIZE_RANGE(pwd->pw_class,\n+                                          REAL(strlen)(pwd->pw_class) + 1);\n+#endif\n+    if (pwd->pw_dir)\n+      COMMON_INTERCEPTOR_INITIALIZE_RANGE(pwd->pw_dir,\n+                                          REAL(strlen)(pwd->pw_dir) + 1);\n+    if (pwd->pw_shell)\n+      COMMON_INTERCEPTOR_INITIALIZE_RANGE(pwd->pw_shell,\n+                                          REAL(strlen)(pwd->pw_shell) + 1);\n+  }\n+}\n+\n+static void unpoison_group(void *ctx, __sanitizer_group *grp) {\n+  if (grp) {\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, grp, sizeof(*grp));\n+    if (grp->gr_name)\n+      COMMON_INTERCEPTOR_INITIALIZE_RANGE(grp->gr_name,\n+                                          REAL(strlen)(grp->gr_name) + 1);\n+    if (grp->gr_passwd)\n+      COMMON_INTERCEPTOR_INITIALIZE_RANGE(grp->gr_passwd,\n+                                          REAL(strlen)(grp->gr_passwd) + 1);\n+    char **p = grp->gr_mem;\n+    for (; *p; ++p) {\n+      COMMON_INTERCEPTOR_INITIALIZE_RANGE(*p, REAL(strlen)(*p) + 1);\n+    }\n+    COMMON_INTERCEPTOR_INITIALIZE_RANGE(grp->gr_mem,\n+                                        (p - grp->gr_mem + 1) * sizeof(*p));\n+  }\n+}\n+#endif  // SANITIZER_INTERCEPT_GETPWNAM_AND_FRIENDS ||\n+        // SANITIZER_INTERCEPT_GETPWENT || SANITIZER_INTERCEPT_FGETPWENT\n+\n #if SANITIZER_INTERCEPT_GETPWNAM_AND_FRIENDS\n-INTERCEPTOR(void *, getpwnam, const char *name) {\n+INTERCEPTOR(__sanitizer_passwd *, getpwnam, const char *name) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, getpwnam, name);\n   COMMON_INTERCEPTOR_READ_RANGE(ctx, name, REAL(strlen)(name) + 1);\n-  void *res = REAL(getpwnam)(name);\n-  if (res != 0) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, struct_passwd_sz);\n+  __sanitizer_passwd *res = REAL(getpwnam)(name);\n+  if (res != 0) unpoison_passwd(ctx, res);\n   return res;\n }\n-INTERCEPTOR(void *, getpwuid, u32 uid) {\n+INTERCEPTOR(__sanitizer_passwd *, getpwuid, u32 uid) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, getpwuid, uid);\n-  void *res = REAL(getpwuid)(uid);\n-  if (res != 0) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, struct_passwd_sz);\n+  __sanitizer_passwd *res = REAL(getpwuid)(uid);\n+  if (res != 0) unpoison_passwd(ctx, res);\n   return res;\n }\n-INTERCEPTOR(void *, getgrnam, const char *name) {\n+INTERCEPTOR(__sanitizer_group *, getgrnam, const char *name) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, getgrnam, name);\n   COMMON_INTERCEPTOR_READ_RANGE(ctx, name, REAL(strlen)(name) + 1);\n-  void *res = REAL(getgrnam)(name);\n-  if (res != 0) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, struct_group_sz);\n+  __sanitizer_group *res = REAL(getgrnam)(name);\n+  if (res != 0) unpoison_group(ctx, res);\n   return res;\n }\n-INTERCEPTOR(void *, getgrgid, u32 gid) {\n+INTERCEPTOR(__sanitizer_group *, getgrgid, u32 gid) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, getgrgid, gid);\n-  void *res = REAL(getgrgid)(gid);\n-  if (res != 0) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, struct_group_sz);\n+  __sanitizer_group *res = REAL(getgrgid)(gid);\n+  if (res != 0) unpoison_group(ctx, res);\n   return res;\n }\n #define INIT_GETPWNAM_AND_FRIENDS      \\\n@@ -731,50 +1062,54 @@ INTERCEPTOR(void *, getgrgid, u32 gid) {\n #endif\n \n #if SANITIZER_INTERCEPT_GETPWNAM_R_AND_FRIENDS\n-INTERCEPTOR(int, getpwnam_r, const char *name, void *pwd, char *buf,\n-            SIZE_T buflen, void **result) {\n+INTERCEPTOR(int, getpwnam_r, const char *name, __sanitizer_passwd *pwd,\n+            char *buf, SIZE_T buflen, __sanitizer_passwd **result) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, getpwnam_r, name, pwd, buf, buflen, result);\n   COMMON_INTERCEPTOR_READ_RANGE(ctx, name, REAL(strlen)(name) + 1);\n   int res = REAL(getpwnam_r)(name, pwd, buf, buflen, result);\n   if (!res) {\n-    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, pwd, struct_passwd_sz);\n+    if (result && *result) unpoison_passwd(ctx, *result);\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, buflen);\n   }\n+  if (result) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, result, sizeof(*result));\n   return res;\n }\n-INTERCEPTOR(int, getpwuid_r, u32 uid, void *pwd, char *buf, SIZE_T buflen,\n-            void **result) {\n+INTERCEPTOR(int, getpwuid_r, u32 uid, __sanitizer_passwd *pwd, char *buf,\n+            SIZE_T buflen, __sanitizer_passwd **result) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, getpwuid_r, uid, pwd, buf, buflen, result);\n   int res = REAL(getpwuid_r)(uid, pwd, buf, buflen, result);\n   if (!res) {\n-    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, pwd, struct_passwd_sz);\n+    if (result && *result) unpoison_passwd(ctx, *result);\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, buflen);\n   }\n+  if (result) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, result, sizeof(*result));\n   return res;\n }\n-INTERCEPTOR(int, getgrnam_r, const char *name, void *grp, char *buf,\n-            SIZE_T buflen, void **result) {\n+INTERCEPTOR(int, getgrnam_r, const char *name, __sanitizer_group *grp,\n+            char *buf, SIZE_T buflen, __sanitizer_group **result) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, getgrnam_r, name, grp, buf, buflen, result);\n   COMMON_INTERCEPTOR_READ_RANGE(ctx, name, REAL(strlen)(name) + 1);\n   int res = REAL(getgrnam_r)(name, grp, buf, buflen, result);\n   if (!res) {\n-    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, grp, struct_group_sz);\n+    if (result && *result) unpoison_group(ctx, *result);\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, buflen);\n   }\n+  if (result) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, result, sizeof(*result));\n   return res;\n }\n-INTERCEPTOR(int, getgrgid_r, u32 gid, void *grp, char *buf, SIZE_T buflen,\n-            void **result) {\n+INTERCEPTOR(int, getgrgid_r, u32 gid, __sanitizer_group *grp, char *buf,\n+            SIZE_T buflen, __sanitizer_group **result) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, getgrgid_r, gid, grp, buf, buflen, result);\n   int res = REAL(getgrgid_r)(gid, grp, buf, buflen, result);\n   if (!res) {\n-    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, grp, struct_group_sz);\n+    if (result && *result) unpoison_group(ctx, *result);\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, buflen);\n   }\n+  if (result) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, result, sizeof(*result));\n   return res;\n }\n #define INIT_GETPWNAM_R_AND_FRIENDS      \\\n@@ -786,6 +1121,141 @@ INTERCEPTOR(int, getgrgid_r, u32 gid, void *grp, char *buf, SIZE_T buflen,\n #define INIT_GETPWNAM_R_AND_FRIENDS\n #endif\n \n+#if SANITIZER_INTERCEPT_GETPWENT\n+INTERCEPTOR(__sanitizer_passwd *, getpwent, int dummy) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, getpwent, dummy);\n+  __sanitizer_passwd *res = REAL(getpwent)(dummy);\n+  if (res != 0) unpoison_passwd(ctx, res);\n+  return res;\n+}\n+INTERCEPTOR(__sanitizer_group *, getgrent, int dummy) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, getgrent, dummy);\n+  __sanitizer_group *res = REAL(getgrent)(dummy);\n+  if (res != 0) unpoison_group(ctx, res);;\n+  return res;\n+}\n+#define INIT_GETPWENT                  \\\n+  COMMON_INTERCEPT_FUNCTION(getpwent); \\\n+  COMMON_INTERCEPT_FUNCTION(getgrent);\n+#else\n+#define INIT_GETPWENT\n+#endif\n+\n+#if SANITIZER_INTERCEPT_FGETPWENT\n+INTERCEPTOR(__sanitizer_passwd *, fgetpwent, void *fp) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, fgetpwent, fp);\n+  __sanitizer_passwd *res = REAL(fgetpwent)(fp);\n+  if (res != 0) unpoison_passwd(ctx, res);\n+  return res;\n+}\n+INTERCEPTOR(__sanitizer_group *, fgetgrent, void *fp) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, fgetgrent, fp);\n+  __sanitizer_group *res = REAL(fgetgrent)(fp);\n+  if (res != 0) unpoison_group(ctx, res);\n+  return res;\n+}\n+#define INIT_FGETPWENT                  \\\n+  COMMON_INTERCEPT_FUNCTION(fgetpwent); \\\n+  COMMON_INTERCEPT_FUNCTION(fgetgrent);\n+#else\n+#define INIT_FGETPWENT\n+#endif\n+\n+#if SANITIZER_INTERCEPT_GETPWENT_R\n+INTERCEPTOR(int, getpwent_r, __sanitizer_passwd *pwbuf, char *buf,\n+            SIZE_T buflen, __sanitizer_passwd **pwbufp) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, getpwent_r, pwbuf, buf, buflen, pwbufp);\n+  int res = REAL(getpwent_r)(pwbuf, buf, buflen, pwbufp);\n+  if (!res) {\n+    if (pwbufp && *pwbufp) unpoison_passwd(ctx, *pwbufp);\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, buflen);\n+  }\n+  if (pwbufp) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, pwbufp, sizeof(*pwbufp));\n+  return res;\n+}\n+INTERCEPTOR(int, fgetpwent_r, void *fp, __sanitizer_passwd *pwbuf, char *buf,\n+            SIZE_T buflen, __sanitizer_passwd **pwbufp) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, fgetpwent_r, fp, pwbuf, buf, buflen, pwbufp);\n+  int res = REAL(fgetpwent_r)(fp, pwbuf, buf, buflen, pwbufp);\n+  if (!res) {\n+    if (pwbufp && *pwbufp) unpoison_passwd(ctx, *pwbufp);\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, buflen);\n+  }\n+  if (pwbufp) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, pwbufp, sizeof(*pwbufp));\n+  return res;\n+}\n+INTERCEPTOR(int, getgrent_r, __sanitizer_group *pwbuf, char *buf, SIZE_T buflen,\n+            __sanitizer_group **pwbufp) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, getgrent_r, pwbuf, buf, buflen, pwbufp);\n+  int res = REAL(getgrent_r)(pwbuf, buf, buflen, pwbufp);\n+  if (!res) {\n+    if (pwbufp && *pwbufp) unpoison_group(ctx, *pwbufp);\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, buflen);\n+  }\n+  if (pwbufp) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, pwbufp, sizeof(*pwbufp));\n+  return res;\n+}\n+INTERCEPTOR(int, fgetgrent_r, void *fp, __sanitizer_group *pwbuf, char *buf,\n+            SIZE_T buflen, __sanitizer_group **pwbufp) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, fgetgrent_r, fp, pwbuf, buf, buflen, pwbufp);\n+  int res = REAL(fgetgrent_r)(fp, pwbuf, buf, buflen, pwbufp);\n+  if (!res) {\n+    if (pwbufp && *pwbufp) unpoison_group(ctx, *pwbufp);\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, buflen);\n+  }\n+  if (pwbufp) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, pwbufp, sizeof(*pwbufp));\n+  return res;\n+}\n+#define INIT_GETPWENT_R                   \\\n+  COMMON_INTERCEPT_FUNCTION(getpwent_r);  \\\n+  COMMON_INTERCEPT_FUNCTION(fgetpwent_r); \\\n+  COMMON_INTERCEPT_FUNCTION(getgrent_r);  \\\n+  COMMON_INTERCEPT_FUNCTION(fgetgrent_r);\n+#else\n+#define INIT_GETPWENT_R\n+#endif\n+\n+#if SANITIZER_INTERCEPT_SETPWENT\n+// The only thing these interceptors do is disable any nested interceptors.\n+// These functions may open nss modules and call uninstrumented functions from\n+// them, and we don't want things like strlen() to trigger.\n+INTERCEPTOR(void, setpwent, int dummy) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, setpwent, dummy);\n+  REAL(setpwent)(dummy);\n+}\n+INTERCEPTOR(void, endpwent, int dummy) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, endpwent, dummy);\n+  REAL(endpwent)(dummy);\n+}\n+INTERCEPTOR(void, setgrent, int dummy) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, setgrent, dummy);\n+  REAL(setgrent)(dummy);\n+}\n+INTERCEPTOR(void, endgrent, int dummy) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, endgrent, dummy);\n+  REAL(endgrent)(dummy);\n+}\n+#define INIT_SETPWENT                  \\\n+  COMMON_INTERCEPT_FUNCTION(setpwent); \\\n+  COMMON_INTERCEPT_FUNCTION(endpwent); \\\n+  COMMON_INTERCEPT_FUNCTION(setgrent); \\\n+  COMMON_INTERCEPT_FUNCTION(endgrent);\n+#else\n+#define INIT_SETPWENT\n+#endif\n+\n #if SANITIZER_INTERCEPT_CLOCK_GETTIME\n INTERCEPTOR(int, clock_getres, u32 clk_id, void *tp) {\n   void *ctx;\n@@ -861,34 +1331,33 @@ static void unpoison_glob_t(void *ctx, __sanitizer_glob_t *pglob) {\n }\n \n static THREADLOCAL __sanitizer_glob_t *pglob_copy;\n-static THREADLOCAL void *glob_ctx;\n \n static void wrapped_gl_closedir(void *dir) {\n-  COMMON_INTERCEPTOR_UNPOISON_PARAM(glob_ctx, 1);\n-  pglob_copy->gl_closedir(dir);\n+  COMMON_INTERCEPTOR_UNPOISON_PARAM(1);\n+  IndirectExternCall(pglob_copy->gl_closedir)(dir);\n }\n \n static void *wrapped_gl_readdir(void *dir) {\n-  COMMON_INTERCEPTOR_UNPOISON_PARAM(glob_ctx, 1);\n-  return pglob_copy->gl_readdir(dir);\n+  COMMON_INTERCEPTOR_UNPOISON_PARAM(1);\n+  return IndirectExternCall(pglob_copy->gl_readdir)(dir);\n }\n \n static void *wrapped_gl_opendir(const char *s) {\n-  COMMON_INTERCEPTOR_UNPOISON_PARAM(glob_ctx, 1);\n-  COMMON_INTERCEPTOR_WRITE_RANGE(glob_ctx, s, REAL(strlen)(s) + 1);\n-  return pglob_copy->gl_opendir(s);\n+  COMMON_INTERCEPTOR_UNPOISON_PARAM(1);\n+  COMMON_INTERCEPTOR_INITIALIZE_RANGE(s, REAL(strlen)(s) + 1);\n+  return IndirectExternCall(pglob_copy->gl_opendir)(s);\n }\n \n static int wrapped_gl_lstat(const char *s, void *st) {\n-  COMMON_INTERCEPTOR_UNPOISON_PARAM(glob_ctx, 2);\n-  COMMON_INTERCEPTOR_WRITE_RANGE(glob_ctx, s, REAL(strlen)(s) + 1);\n-  return pglob_copy->gl_lstat(s, st);\n+  COMMON_INTERCEPTOR_UNPOISON_PARAM(2);\n+  COMMON_INTERCEPTOR_INITIALIZE_RANGE(s, REAL(strlen)(s) + 1);\n+  return IndirectExternCall(pglob_copy->gl_lstat)(s, st);\n }\n \n static int wrapped_gl_stat(const char *s, void *st) {\n-  COMMON_INTERCEPTOR_UNPOISON_PARAM(glob_ctx, 2);\n-  COMMON_INTERCEPTOR_WRITE_RANGE(glob_ctx, s, REAL(strlen)(s) + 1);\n-  return pglob_copy->gl_stat(s, st);\n+  COMMON_INTERCEPTOR_UNPOISON_PARAM(2);\n+  COMMON_INTERCEPTOR_INITIALIZE_RANGE(s, REAL(strlen)(s) + 1);\n+  return IndirectExternCall(pglob_copy->gl_stat)(s, st);\n }\n \n INTERCEPTOR(int, glob, const char *pattern, int flags,\n@@ -907,7 +1376,6 @@ INTERCEPTOR(int, glob, const char *pattern, int flags,\n     Swap(pglob->gl_lstat, glob_copy.gl_lstat);\n     Swap(pglob->gl_stat, glob_copy.gl_stat);\n     pglob_copy = &glob_copy;\n-    glob_ctx = ctx;\n   }\n   int res = REAL(glob)(pattern, flags, errfunc, pglob);\n   if (flags & glob_altdirfunc) {\n@@ -918,7 +1386,6 @@ INTERCEPTOR(int, glob, const char *pattern, int flags,\n     Swap(pglob->gl_stat, glob_copy.gl_stat);\n   }\n   pglob_copy = 0;\n-  glob_ctx = 0;\n   if ((!res || res == glob_nomatch) && pglob) unpoison_glob_t(ctx, pglob);\n   return res;\n }\n@@ -939,7 +1406,6 @@ INTERCEPTOR(int, glob64, const char *pattern, int flags,\n     Swap(pglob->gl_lstat, glob_copy.gl_lstat);\n     Swap(pglob->gl_stat, glob_copy.gl_stat);\n     pglob_copy = &glob_copy;\n-    glob_ctx = ctx;\n   }\n   int res = REAL(glob64)(pattern, flags, errfunc, pglob);\n   if (flags & glob_altdirfunc) {\n@@ -950,7 +1416,6 @@ INTERCEPTOR(int, glob64, const char *pattern, int flags,\n     Swap(pglob->gl_stat, glob_copy.gl_stat);\n   }\n   pglob_copy = 0;\n-  glob_ctx = 0;\n   if ((!res || res == glob_nomatch) && pglob) unpoison_glob_t(ctx, pglob);\n   return res;\n }\n@@ -1000,6 +1465,19 @@ INTERCEPTOR(int, wait3, int *status, int options, void *rusage) {\n   }\n   return res;\n }\n+#if SANITIZER_ANDROID\n+INTERCEPTOR(int, __wait4, int pid, int *status, int options, void *rusage) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, __wait4, pid, status, options, rusage);\n+  int res = REAL(__wait4)(pid, status, options, rusage);\n+  if (res != -1) {\n+    if (status) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, status, sizeof(*status));\n+    if (rusage) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, rusage, struct_rusage_sz);\n+  }\n+  return res;\n+}\n+#define INIT_WAIT4 COMMON_INTERCEPT_FUNCTION(__wait4);\n+#else\n INTERCEPTOR(int, wait4, int pid, int *status, int options, void *rusage) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, wait4, pid, status, options, rusage);\n@@ -1010,14 +1488,16 @@ INTERCEPTOR(int, wait4, int pid, int *status, int options, void *rusage) {\n   }\n   return res;\n }\n+#define INIT_WAIT4 COMMON_INTERCEPT_FUNCTION(wait4);\n+#endif  // SANITIZER_ANDROID\n #define INIT_WAIT                     \\\n   COMMON_INTERCEPT_FUNCTION(wait);    \\\n   COMMON_INTERCEPT_FUNCTION(waitid);  \\\n   COMMON_INTERCEPT_FUNCTION(waitpid); \\\n-  COMMON_INTERCEPT_FUNCTION(wait3);   \\\n-  COMMON_INTERCEPT_FUNCTION(wait4);\n+  COMMON_INTERCEPT_FUNCTION(wait3);\n #else\n #define INIT_WAIT\n+#define INIT_WAIT4\n #endif\n \n #if SANITIZER_INTERCEPT_INET\n@@ -1227,14 +1707,12 @@ INTERCEPTOR(int, gethostent_r, struct __sanitizer_hostent *ret, char *buf,\n   COMMON_INTERCEPTOR_ENTER(ctx, gethostent_r, ret, buf, buflen, result,\n                            h_errnop);\n   int res = REAL(gethostent_r)(ret, buf, buflen, result, h_errnop);\n-  if (res == 0) {\n-    if (result) {\n-      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, result, sizeof(*result));\n-      if (*result) write_hostent(ctx, *result);\n-    }\n-    if (h_errnop)\n-      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, h_errnop, sizeof(*h_errnop));\n+  if (result) {\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, result, sizeof(*result));\n+    if (res == 0 && *result) write_hostent(ctx, *result);\n   }\n+  if (h_errnop)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, h_errnop, sizeof(*h_errnop));\n   return res;\n }\n \n@@ -1247,14 +1725,12 @@ INTERCEPTOR(int, gethostbyaddr_r, void *addr, int len, int type,\n   COMMON_INTERCEPTOR_READ_RANGE(ctx, addr, len);\n   int res = REAL(gethostbyaddr_r)(addr, len, type, ret, buf, buflen, result,\n                                   h_errnop);\n-  if (res == 0) {\n-    if (result) {\n-      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, result, sizeof(*result));\n-      if (*result) write_hostent(ctx, *result);\n-    }\n-    if (h_errnop)\n-      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, h_errnop, sizeof(*h_errnop));\n+  if (result) {\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, result, sizeof(*result));\n+    if (res == 0 && *result) write_hostent(ctx, *result);\n   }\n+  if (h_errnop)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, h_errnop, sizeof(*h_errnop));\n   return res;\n }\n \n@@ -1265,14 +1741,12 @@ INTERCEPTOR(int, gethostbyname_r, char *name, struct __sanitizer_hostent *ret,\n   COMMON_INTERCEPTOR_ENTER(ctx, gethostbyname_r, name, ret, buf, buflen, result,\n                            h_errnop);\n   int res = REAL(gethostbyname_r)(name, ret, buf, buflen, result, h_errnop);\n-  if (res == 0) {\n-    if (result) {\n-      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, result, sizeof(*result));\n-      if (*result) write_hostent(ctx, *result);\n-    }\n-    if (h_errnop)\n-      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, h_errnop, sizeof(*h_errnop));\n+  if (result) {\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, result, sizeof(*result));\n+    if (res == 0 && *result) write_hostent(ctx, *result);\n   }\n+  if (h_errnop)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, h_errnop, sizeof(*h_errnop));\n   return res;\n }\n \n@@ -1284,14 +1758,12 @@ INTERCEPTOR(int, gethostbyname2_r, char *name, int af,\n                            result, h_errnop);\n   int res =\n       REAL(gethostbyname2_r)(name, af, ret, buf, buflen, result, h_errnop);\n-  if (res == 0) {\n-    if (result) {\n-      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, result, sizeof(*result));\n-      if (*result) write_hostent(ctx, *result);\n-    }\n-    if (h_errnop)\n-      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, h_errnop, sizeof(*h_errnop));\n+  if (result) {\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, result, sizeof(*result));\n+    if (res == 0 && *result) write_hostent(ctx, *result);\n   }\n+  if (h_errnop)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, h_errnop, sizeof(*h_errnop));\n   return res;\n }\n #define INIT_GETHOSTBYNAME_R                  \\\n@@ -1834,7 +2306,7 @@ INTERCEPTOR(char *, strerror, int errnum) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, strerror, errnum);\n   char *res = REAL(strerror)(errnum);\n-  if (res) COMMON_INTERCEPTOR_INITIALIZE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n+  if (res) COMMON_INTERCEPTOR_INITIALIZE_RANGE(res, REAL(strlen)(res) + 1);\n   return res;\n }\n #define INIT_STRERROR COMMON_INTERCEPT_FUNCTION(strerror);\n@@ -1890,38 +2362,34 @@ typedef int (*scandir_filter_f)(const struct __sanitizer_dirent *);\n typedef int (*scandir_compar_f)(const struct __sanitizer_dirent **,\n                                 const struct __sanitizer_dirent **);\n \n-static THREADLOCAL void *scandir_ctx;\n static THREADLOCAL scandir_filter_f scandir_filter;\n static THREADLOCAL scandir_compar_f scandir_compar;\n \n static int wrapped_scandir_filter(const struct __sanitizer_dirent *dir) {\n-  COMMON_INTERCEPTOR_UNPOISON_PARAM(scandir_ctx, 1);\n-  COMMON_INTERCEPTOR_WRITE_RANGE(scandir_ctx, dir, dir->d_reclen);\n-  return scandir_filter(dir);\n+  COMMON_INTERCEPTOR_UNPOISON_PARAM(1);\n+  COMMON_INTERCEPTOR_INITIALIZE_RANGE(dir, dir->d_reclen);\n+  return IndirectExternCall(scandir_filter)(dir);\n }\n \n static int wrapped_scandir_compar(const struct __sanitizer_dirent **a,\n                                   const struct __sanitizer_dirent **b) {\n-  COMMON_INTERCEPTOR_UNPOISON_PARAM(scandir_ctx, 2);\n-  COMMON_INTERCEPTOR_WRITE_RANGE(scandir_ctx, a, sizeof(*a));\n-  COMMON_INTERCEPTOR_WRITE_RANGE(scandir_ctx, *a, (*a)->d_reclen);\n-  COMMON_INTERCEPTOR_WRITE_RANGE(scandir_ctx, b, sizeof(*b));\n-  COMMON_INTERCEPTOR_WRITE_RANGE(scandir_ctx, *b, (*b)->d_reclen);\n-  return scandir_compar(a, b);\n+  COMMON_INTERCEPTOR_UNPOISON_PARAM(2);\n+  COMMON_INTERCEPTOR_INITIALIZE_RANGE(a, sizeof(*a));\n+  COMMON_INTERCEPTOR_INITIALIZE_RANGE(*a, (*a)->d_reclen);\n+  COMMON_INTERCEPTOR_INITIALIZE_RANGE(b, sizeof(*b));\n+  COMMON_INTERCEPTOR_INITIALIZE_RANGE(*b, (*b)->d_reclen);\n+  return IndirectExternCall(scandir_compar)(a, b);\n }\n \n INTERCEPTOR(int, scandir, char *dirp, __sanitizer_dirent ***namelist,\n             scandir_filter_f filter, scandir_compar_f compar) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, scandir, dirp, namelist, filter, compar);\n   if (dirp) COMMON_INTERCEPTOR_READ_RANGE(ctx, dirp, REAL(strlen)(dirp) + 1);\n-  CHECK_EQ(0, scandir_ctx);\n-  scandir_ctx = ctx;\n   scandir_filter = filter;\n   scandir_compar = compar;\n   int res = REAL(scandir)(dirp, namelist, filter ? wrapped_scandir_filter : 0,\n                           compar ? wrapped_scandir_compar : 0);\n-  scandir_ctx = 0;\n   scandir_filter = 0;\n   scandir_compar = 0;\n   if (namelist && res > 0) {\n@@ -1943,39 +2411,35 @@ typedef int (*scandir64_filter_f)(const struct __sanitizer_dirent64 *);\n typedef int (*scandir64_compar_f)(const struct __sanitizer_dirent64 **,\n                                   const struct __sanitizer_dirent64 **);\n \n-static THREADLOCAL void *scandir64_ctx;\n static THREADLOCAL scandir64_filter_f scandir64_filter;\n static THREADLOCAL scandir64_compar_f scandir64_compar;\n \n static int wrapped_scandir64_filter(const struct __sanitizer_dirent64 *dir) {\n-  COMMON_INTERCEPTOR_UNPOISON_PARAM(scandir64_ctx, 1);\n-  COMMON_INTERCEPTOR_WRITE_RANGE(scandir64_ctx, dir, dir->d_reclen);\n-  return scandir64_filter(dir);\n+  COMMON_INTERCEPTOR_UNPOISON_PARAM(1);\n+  COMMON_INTERCEPTOR_INITIALIZE_RANGE(dir, dir->d_reclen);\n+  return IndirectExternCall(scandir64_filter)(dir);\n }\n \n static int wrapped_scandir64_compar(const struct __sanitizer_dirent64 **a,\n                                     const struct __sanitizer_dirent64 **b) {\n-  COMMON_INTERCEPTOR_UNPOISON_PARAM(scandir64_ctx, 2);\n-  COMMON_INTERCEPTOR_WRITE_RANGE(scandir64_ctx, a, sizeof(*a));\n-  COMMON_INTERCEPTOR_WRITE_RANGE(scandir64_ctx, *a, (*a)->d_reclen);\n-  COMMON_INTERCEPTOR_WRITE_RANGE(scandir64_ctx, b, sizeof(*b));\n-  COMMON_INTERCEPTOR_WRITE_RANGE(scandir64_ctx, *b, (*b)->d_reclen);\n-  return scandir64_compar(a, b);\n+  COMMON_INTERCEPTOR_UNPOISON_PARAM(2);\n+  COMMON_INTERCEPTOR_INITIALIZE_RANGE(a, sizeof(*a));\n+  COMMON_INTERCEPTOR_INITIALIZE_RANGE(*a, (*a)->d_reclen);\n+  COMMON_INTERCEPTOR_INITIALIZE_RANGE(b, sizeof(*b));\n+  COMMON_INTERCEPTOR_INITIALIZE_RANGE(*b, (*b)->d_reclen);\n+  return IndirectExternCall(scandir64_compar)(a, b);\n }\n \n INTERCEPTOR(int, scandir64, char *dirp, __sanitizer_dirent64 ***namelist,\n             scandir64_filter_f filter, scandir64_compar_f compar) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, scandir64, dirp, namelist, filter, compar);\n   if (dirp) COMMON_INTERCEPTOR_READ_RANGE(ctx, dirp, REAL(strlen)(dirp) + 1);\n-  CHECK_EQ(0, scandir64_ctx);\n-  scandir64_ctx = ctx;\n   scandir64_filter = filter;\n   scandir64_compar = compar;\n   int res =\n       REAL(scandir64)(dirp, namelist, filter ? wrapped_scandir64_filter : 0,\n                       compar ? wrapped_scandir64_compar : 0);\n-  scandir64_ctx = 0;\n   scandir64_filter = 0;\n   scandir64_compar = 0;\n   if (namelist && res > 0) {\n@@ -2243,53 +2707,6 @@ INTERCEPTOR(int, pthread_mutex_unlock, void *m) {\n #define INIT_PTHREAD_MUTEX_UNLOCK\n #endif\n \n-#if SANITIZER_INTERCEPT_PTHREAD_COND\n-INTERCEPTOR(int, pthread_cond_wait, void *c, void *m) {\n-  void *ctx;\n-  COMMON_INTERCEPTOR_ENTER(ctx, pthread_cond_wait, c, m);\n-  COMMON_INTERCEPTOR_MUTEX_UNLOCK(ctx, m);\n-  COMMON_INTERCEPTOR_READ_RANGE(ctx, c, pthread_cond_t_sz);\n-  int res = REAL(pthread_cond_wait)(c, m);\n-  COMMON_INTERCEPTOR_MUTEX_LOCK(ctx, m);\n-  return res;\n-}\n-\n-INTERCEPTOR(int, pthread_cond_init, void *c, void *a) {\n-  void *ctx;\n-  COMMON_INTERCEPTOR_ENTER(ctx, pthread_cond_init, c, a);\n-  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, c, pthread_cond_t_sz);\n-  return REAL(pthread_cond_init)(c, a);\n-}\n-\n-INTERCEPTOR(int, pthread_cond_signal, void *c) {\n-  void *ctx;\n-  COMMON_INTERCEPTOR_ENTER(ctx, pthread_cond_signal, c);\n-  COMMON_INTERCEPTOR_READ_RANGE(ctx, c, pthread_cond_t_sz);\n-  return REAL(pthread_cond_signal)(c);\n-}\n-\n-INTERCEPTOR(int, pthread_cond_broadcast, void *c) {\n-  void *ctx;\n-  COMMON_INTERCEPTOR_ENTER(ctx, pthread_cond_broadcast, c);\n-  COMMON_INTERCEPTOR_READ_RANGE(ctx, c, pthread_cond_t_sz);\n-  return REAL(pthread_cond_broadcast)(c);\n-}\n-\n-#define INIT_PTHREAD_COND_WAIT \\\n-  INTERCEPT_FUNCTION_VER(pthread_cond_wait, \"GLIBC_2.3.2\")\n-#define INIT_PTHREAD_COND_INIT \\\n-  INTERCEPT_FUNCTION_VER(pthread_cond_init, \"GLIBC_2.3.2\")\n-#define INIT_PTHREAD_COND_SIGNAL \\\n-  INTERCEPT_FUNCTION_VER(pthread_cond_signal, \"GLIBC_2.3.2\")\n-#define INIT_PTHREAD_COND_BROADCAST \\\n-  INTERCEPT_FUNCTION_VER(pthread_cond_broadcast, \"GLIBC_2.3.2\")\n-#else\n-#define INIT_PTHREAD_COND_WAIT\n-#define INIT_PTHREAD_COND_INIT\n-#define INIT_PTHREAD_COND_SIGNAL\n-#define INIT_PTHREAD_COND_BROADCAST\n-#endif\n-\n #if SANITIZER_INTERCEPT_GETMNTENT || SANITIZER_INTERCEPT_GETMNTENT_R\n static void write_mntent(void *ctx, __sanitizer_mntent *mnt) {\n   COMMON_INTERCEPTOR_WRITE_RANGE(ctx, mnt, sizeof(*mnt));\n@@ -2446,15 +2863,15 @@ INTERCEPTOR(char *, ether_ntoa, __sanitizer_ether_addr *addr) {\n   COMMON_INTERCEPTOR_ENTER(ctx, ether_ntoa, addr);\n   if (addr) COMMON_INTERCEPTOR_READ_RANGE(ctx, addr, sizeof(*addr));\n   char *res = REAL(ether_ntoa)(addr);\n-  if (res) COMMON_INTERCEPTOR_INITIALIZE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n+  if (res) COMMON_INTERCEPTOR_INITIALIZE_RANGE(res, REAL(strlen)(res) + 1);\n   return res;\n }\n INTERCEPTOR(__sanitizer_ether_addr *, ether_aton, char *buf) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, ether_aton, buf);\n   if (buf) COMMON_INTERCEPTOR_READ_RANGE(ctx, buf, REAL(strlen)(buf) + 1);\n   __sanitizer_ether_addr *res = REAL(ether_aton)(buf);\n-  if (res) COMMON_INTERCEPTOR_INITIALIZE_RANGE(ctx, res, sizeof(*res));\n+  if (res) COMMON_INTERCEPTOR_INITIALIZE_RANGE(res, sizeof(*res));\n   return res;\n }\n INTERCEPTOR(int, ether_ntohost, char *hostname, __sanitizer_ether_addr *addr) {\n@@ -2592,9 +3009,13 @@ INTERCEPTOR(int, pthread_attr_getstack, void *attr, void **addr, SIZE_T *size) {\n // We may need to call the real pthread_attr_getstack from the run-time\n // in sanitizer_common, but we don't want to include the interception headers\n // there. So, just define this function here.\n-int __sanitizer_pthread_attr_getstack(void *attr, void **addr, SIZE_T *size) {\n+namespace __sanitizer {\n+extern \"C\" {\n+int real_pthread_attr_getstack(void *attr, void **addr, SIZE_T *size) {\n   return REAL(pthread_attr_getstack)(attr, addr, size);\n }\n+}  // extern \"C\"\n+}  // namespace __sanitizer\n \n #define INIT_PTHREAD_ATTR_GET                             \\\n   COMMON_INTERCEPT_FUNCTION(pthread_attr_getdetachstate); \\\n@@ -2644,7 +3065,7 @@ INTERCEPTOR(char *, tmpnam, char *s) {\n     if (s)\n       COMMON_INTERCEPTOR_WRITE_RANGE(ctx, s, REAL(strlen)(s) + 1);\n     else\n-      COMMON_INTERCEPTOR_INITIALIZE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n+      COMMON_INTERCEPTOR_INITIALIZE_RANGE(res, REAL(strlen)(res) + 1);\n   }\n   return res;\n }\n@@ -2673,7 +3094,7 @@ INTERCEPTOR(char *, tempnam, char *dir, char *pfx) {\n   if (dir) COMMON_INTERCEPTOR_READ_RANGE(ctx, dir, REAL(strlen)(dir) + 1);\n   if (pfx) COMMON_INTERCEPTOR_READ_RANGE(ctx, pfx, REAL(strlen)(pfx) + 1);\n   char *res = REAL(tempnam)(dir, pfx);\n-  if (res) COMMON_INTERCEPTOR_INITIALIZE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n+  if (res) COMMON_INTERCEPTOR_INITIALIZE_RANGE(res, REAL(strlen)(res) + 1);\n   return res;\n }\n #define INIT_TEMPNAM COMMON_INTERCEPT_FUNCTION(tempnam);\n@@ -2836,6 +3257,18 @@ INTERCEPTOR(int, lrand48_r, void *buffer, long *result) {\n #define INIT_DRAND48_R\n #endif\n \n+#if SANITIZER_INTERCEPT_RAND_R\n+INTERCEPTOR(int, rand_r, unsigned *seedp) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, rand_r, seedp);\n+  COMMON_INTERCEPTOR_READ_RANGE(ctx, seedp, sizeof(*seedp));\n+  return REAL(rand_r)(seedp);\n+}\n+#define INIT_RAND_R COMMON_INTERCEPT_FUNCTION(rand_r);\n+#else\n+#define INIT_RAND_R\n+#endif\n+\n #if SANITIZER_INTERCEPT_GETLINE\n INTERCEPTOR(SSIZE_T, getline, char **lineptr, SIZE_T *n, void *stream) {\n   void *ctx;\n@@ -2906,117 +3339,840 @@ INTERCEPTOR(__sanitizer_clock_t, times, void *tms) {\n #define INIT_TIMES\n #endif\n \n-#define SANITIZER_COMMON_INTERCEPTORS_INIT \\\n-  INIT_TEXTDOMAIN;                         \\\n-  INIT_STRCMP;                             \\\n-  INIT_STRNCMP;                            \\\n-  INIT_STRCASECMP;                         \\\n-  INIT_STRNCASECMP;                        \\\n-  INIT_READ;                               \\\n-  INIT_PREAD;                              \\\n-  INIT_PREAD64;                            \\\n-  INIT_READV;                              \\\n-  INIT_PREADV;                             \\\n-  INIT_PREADV64;                           \\\n-  INIT_WRITE;                              \\\n-  INIT_PWRITE;                             \\\n-  INIT_PWRITE64;                           \\\n-  INIT_WRITEV;                             \\\n-  INIT_PWRITEV;                            \\\n-  INIT_PWRITEV64;                          \\\n-  INIT_PRCTL;                              \\\n-  INIT_LOCALTIME_AND_FRIENDS;              \\\n-  INIT_STRPTIME;                           \\\n-  INIT_SCANF;                              \\\n-  INIT_ISOC99_SCANF;                       \\\n-  INIT_FREXP;                              \\\n-  INIT_FREXPF_FREXPL;                      \\\n-  INIT_GETPWNAM_AND_FRIENDS;               \\\n-  INIT_GETPWNAM_R_AND_FRIENDS;             \\\n-  INIT_CLOCK_GETTIME;                      \\\n-  INIT_GETITIMER;                          \\\n-  INIT_TIME;                               \\\n-  INIT_GLOB;                               \\\n-  INIT_WAIT;                               \\\n-  INIT_INET;                               \\\n-  INIT_PTHREAD_GETSCHEDPARAM;              \\\n-  INIT_GETADDRINFO;                        \\\n-  INIT_GETNAMEINFO;                        \\\n-  INIT_GETSOCKNAME;                        \\\n-  INIT_GETHOSTBYNAME;                      \\\n-  INIT_GETHOSTBYNAME_R;                    \\\n-  INIT_GETSOCKOPT;                         \\\n-  INIT_ACCEPT;                             \\\n-  INIT_ACCEPT4;                            \\\n-  INIT_MODF;                               \\\n-  INIT_RECVMSG;                            \\\n-  INIT_GETPEERNAME;                        \\\n-  INIT_IOCTL;                              \\\n-  INIT_INET_ATON;                          \\\n-  INIT_SYSINFO;                            \\\n-  INIT_READDIR;                            \\\n-  INIT_READDIR64;                          \\\n-  INIT_PTRACE;                             \\\n-  INIT_SETLOCALE;                          \\\n-  INIT_GETCWD;                             \\\n-  INIT_GET_CURRENT_DIR_NAME;               \\\n-  INIT_STRTOIMAX;                          \\\n-  INIT_MBSTOWCS;                           \\\n-  INIT_MBSNRTOWCS;                         \\\n-  INIT_WCSTOMBS;                           \\\n-  INIT_WCSNRTOMBS;                         \\\n-  INIT_TCGETATTR;                          \\\n-  INIT_REALPATH;                           \\\n-  INIT_CANONICALIZE_FILE_NAME;             \\\n-  INIT_CONFSTR;                            \\\n-  INIT_SCHED_GETAFFINITY;                  \\\n-  INIT_STRERROR;                           \\\n-  INIT_STRERROR_R;                         \\\n-  INIT_XPG_STRERROR_R;                     \\\n-  INIT_SCANDIR;                            \\\n-  INIT_SCANDIR64;                          \\\n-  INIT_GETGROUPS;                          \\\n-  INIT_POLL;                               \\\n-  INIT_PPOLL;                              \\\n-  INIT_WORDEXP;                            \\\n-  INIT_SIGWAIT;                            \\\n-  INIT_SIGWAITINFO;                        \\\n-  INIT_SIGTIMEDWAIT;                       \\\n-  INIT_SIGSETOPS;                          \\\n-  INIT_SIGPENDING;                         \\\n-  INIT_SIGPROCMASK;                        \\\n-  INIT_BACKTRACE;                          \\\n-  INIT__EXIT;                              \\\n-  INIT_PTHREAD_MUTEX_LOCK;                 \\\n-  INIT_PTHREAD_MUTEX_UNLOCK;               \\\n-  INIT_PTHREAD_COND_WAIT;                  \\\n-  INIT_PTHREAD_COND_INIT;                  \\\n-  INIT_PTHREAD_COND_SIGNAL;                \\\n-  INIT_PTHREAD_COND_BROADCAST;             \\\n-  INIT_GETMNTENT;                          \\\n-  INIT_GETMNTENT_R;                        \\\n-  INIT_STATFS;                             \\\n-  INIT_STATFS64;                           \\\n-  INIT_STATVFS;                            \\\n-  INIT_STATVFS64;                          \\\n-  INIT_INITGROUPS;                         \\\n-  INIT_ETHER;                              \\\n-  INIT_ETHER_R;                            \\\n-  INIT_SHMCTL;                             \\\n-  INIT_RANDOM_R;                           \\\n-  INIT_PTHREAD_ATTR_GET;                   \\\n-  INIT_PTHREAD_ATTR_GETINHERITSCHED;       \\\n-  INIT_PTHREAD_ATTR_GETAFFINITY_NP;        \\\n-  INIT_TMPNAM;                             \\\n-  INIT_TMPNAM_R;                           \\\n-  INIT_TEMPNAM;                            \\\n-  INIT_PTHREAD_SETNAME_NP;                 \\\n-  INIT_SINCOS;                             \\\n-  INIT_REMQUO;                             \\\n-  INIT_LGAMMA;                             \\\n-  INIT_LGAMMA_R;                           \\\n-  INIT_DRAND48_R;                          \\\n-  INIT_GETLINE;                            \\\n-  INIT_ICONV;                              \\\n-  INIT_TIMES;                              \\\n-/**/\n+#if SANITIZER_INTERCEPT_TLS_GET_ADDR\n+#define INIT_TLS_GET_ADDR COMMON_INTERCEPT_FUNCTION(__tls_get_addr)\n+INTERCEPTOR(void *, __tls_get_addr, void *arg) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, __tls_get_addr, arg);\n+  void *res = REAL(__tls_get_addr)(arg);\n+  DTLS_on_tls_get_addr(arg, res);\n+  return res;\n+}\n+#else\n+#define INIT_TLS_GET_ADDR\n+#endif\n+\n+#if SANITIZER_INTERCEPT_LISTXATTR\n+INTERCEPTOR(SSIZE_T, listxattr, const char *path, char *list, SIZE_T size) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, listxattr, path, list, size);\n+  if (path) COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n+  SSIZE_T res = REAL(listxattr)(path, list, size);\n+  // Here and below, size == 0 is a special case where nothing is written to the\n+  // buffer, and res contains the desired buffer size.\n+  if (size && res > 0 && list) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, list, res);\n+  return res;\n+}\n+INTERCEPTOR(SSIZE_T, llistxattr, const char *path, char *list, SIZE_T size) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, llistxattr, path, list, size);\n+  if (path) COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n+  SSIZE_T res = REAL(llistxattr)(path, list, size);\n+  if (size && res > 0 && list) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, list, res);\n+  return res;\n+}\n+INTERCEPTOR(SSIZE_T, flistxattr, int fd, char *list, SIZE_T size) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, flistxattr, fd, list, size);\n+  SSIZE_T res = REAL(flistxattr)(fd, list, size);\n+  if (size && res > 0 && list) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, list, res);\n+  return res;\n+}\n+#define INIT_LISTXATTR                   \\\n+  COMMON_INTERCEPT_FUNCTION(listxattr);  \\\n+  COMMON_INTERCEPT_FUNCTION(llistxattr); \\\n+  COMMON_INTERCEPT_FUNCTION(flistxattr);\n+#else\n+#define INIT_LISTXATTR\n+#endif\n+\n+#if SANITIZER_INTERCEPT_GETXATTR\n+INTERCEPTOR(SSIZE_T, getxattr, const char *path, const char *name, char *value,\n+            SIZE_T size) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, getxattr, path, name, value, size);\n+  if (path) COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n+  if (name) COMMON_INTERCEPTOR_READ_RANGE(ctx, name, REAL(strlen)(name) + 1);\n+  SSIZE_T res = REAL(getxattr)(path, name, value, size);\n+  if (size && res > 0 && value) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, value, res);\n+  return res;\n+}\n+INTERCEPTOR(SSIZE_T, lgetxattr, const char *path, const char *name, char *value,\n+            SIZE_T size) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, lgetxattr, path, name, value, size);\n+  if (path) COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n+  if (name) COMMON_INTERCEPTOR_READ_RANGE(ctx, name, REAL(strlen)(name) + 1);\n+  SSIZE_T res = REAL(lgetxattr)(path, name, value, size);\n+  if (size && res > 0 && value) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, value, res);\n+  return res;\n+}\n+INTERCEPTOR(SSIZE_T, fgetxattr, int fd, const char *name, char *value,\n+            SIZE_T size) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, fgetxattr, fd, name, value, size);\n+  if (name) COMMON_INTERCEPTOR_READ_RANGE(ctx, name, REAL(strlen)(name) + 1);\n+  SSIZE_T res = REAL(fgetxattr)(fd, name, value, size);\n+  if (size && res > 0 && value) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, value, res);\n+  return res;\n+}\n+#define INIT_GETXATTR                   \\\n+  COMMON_INTERCEPT_FUNCTION(getxattr);  \\\n+  COMMON_INTERCEPT_FUNCTION(lgetxattr); \\\n+  COMMON_INTERCEPT_FUNCTION(fgetxattr);\n+#else\n+#define INIT_GETXATTR\n+#endif\n+\n+#if SANITIZER_INTERCEPT_GETRESID\n+INTERCEPTOR(int, getresuid, void *ruid, void *euid, void *suid) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, getresuid, ruid, euid, suid);\n+  int res = REAL(getresuid)(ruid, euid, suid);\n+  if (res >= 0) {\n+    if (ruid) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ruid, uid_t_sz);\n+    if (euid) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, euid, uid_t_sz);\n+    if (suid) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, suid, uid_t_sz);\n+  }\n+  return res;\n+}\n+INTERCEPTOR(int, getresgid, void *rgid, void *egid, void *sgid) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, getresgid, rgid, egid, sgid);\n+  int res = REAL(getresgid)(rgid, egid, sgid);\n+  if (res >= 0) {\n+    if (rgid) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, rgid, gid_t_sz);\n+    if (egid) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, egid, gid_t_sz);\n+    if (sgid) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, sgid, gid_t_sz);\n+  }\n+  return res;\n+}\n+#define INIT_GETRESID                   \\\n+  COMMON_INTERCEPT_FUNCTION(getresuid); \\\n+  COMMON_INTERCEPT_FUNCTION(getresgid);\n+#else\n+#define INIT_GETRESID\n+#endif\n+\n+#if SANITIZER_INTERCEPT_GETIFADDRS\n+// As long as getifaddrs()/freeifaddrs() use calloc()/free(), we don't need to\n+// intercept freeifaddrs(). If that ceases to be the case, we might need to\n+// intercept it to poison the memory again.\n+INTERCEPTOR(int, getifaddrs, __sanitizer_ifaddrs **ifap) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, getifaddrs, ifap);\n+  int res = REAL(getifaddrs)(ifap);\n+  if (res == 0 && ifap) {\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ifap, sizeof(void *));\n+    __sanitizer_ifaddrs *p = *ifap;\n+    while (p) {\n+      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p, sizeof(__sanitizer_ifaddrs));\n+      if (p->ifa_name)\n+        COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p->ifa_name,\n+                                       REAL(strlen)(p->ifa_name) + 1);\n+      if (p->ifa_addr)\n+        COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p->ifa_addr, struct_sockaddr_sz);\n+      if (p->ifa_netmask)\n+        COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p->ifa_netmask, struct_sockaddr_sz);\n+      // On Linux this is a union, but the other member also points to a\n+      // struct sockaddr, so the following is sufficient.\n+      if (p->ifa_dstaddr)\n+        COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p->ifa_dstaddr, struct_sockaddr_sz);\n+      // FIXME(smatveev): Unpoison p->ifa_data as well.\n+      p = p->ifa_next;\n+    }\n+  }\n+  return res;\n+}\n+#define INIT_GETIFADDRS                  \\\n+  COMMON_INTERCEPT_FUNCTION(getifaddrs);\n+#else\n+#define INIT_GETIFADDRS\n+#endif\n+\n+#if SANITIZER_INTERCEPT_IF_INDEXTONAME\n+INTERCEPTOR(char *, if_indextoname, unsigned int ifindex, char* ifname) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, if_indextoname, ifindex, ifname);\n+  char *res = REAL(if_indextoname)(ifindex, ifname);\n+  if (res && ifname)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ifname, REAL(strlen)(ifname) + 1);\n+  return res;\n+}\n+INTERCEPTOR(unsigned int, if_nametoindex, const char* ifname) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, if_nametoindex, ifname);\n+  if (ifname)\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, ifname, REAL(strlen)(ifname) + 1);\n+  return REAL(if_nametoindex)(ifname);\n+}\n+#define INIT_IF_INDEXTONAME                  \\\n+  COMMON_INTERCEPT_FUNCTION(if_indextoname); \\\n+  COMMON_INTERCEPT_FUNCTION(if_nametoindex);\n+#else\n+#define INIT_IF_INDEXTONAME\n+#endif\n+\n+#if SANITIZER_INTERCEPT_CAPGET\n+INTERCEPTOR(int, capget, void *hdrp, void *datap) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, capget, hdrp, datap);\n+  if (hdrp)\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, hdrp, __user_cap_header_struct_sz);\n+  int res = REAL(capget)(hdrp, datap);\n+  if (res == 0 && datap)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, datap, __user_cap_data_struct_sz);\n+  // We can also return -1 and write to hdrp->version if the version passed in\n+  // hdrp->version is unsupported. But that's not a trivial condition to check,\n+  // and anyway COMMON_INTERCEPTOR_READ_RANGE protects us to some extent.\n+  return res;\n+}\n+INTERCEPTOR(int, capset, void *hdrp, const void *datap) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, capset, hdrp, datap);\n+  if (hdrp)\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, hdrp, __user_cap_header_struct_sz);\n+  if (datap)\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, datap, __user_cap_data_struct_sz);\n+  return REAL(capset)(hdrp, datap);\n+}\n+#define INIT_CAPGET                  \\\n+  COMMON_INTERCEPT_FUNCTION(capget); \\\n+  COMMON_INTERCEPT_FUNCTION(capset);\n+#else\n+#define INIT_CAPGET\n+#endif\n+\n+#if SANITIZER_INTERCEPT_AEABI_MEM\n+DECLARE_REAL_AND_INTERCEPTOR(void *, memmove, void *, const void *, uptr);\n+DECLARE_REAL_AND_INTERCEPTOR(void *, memcpy, void *, const void *, uptr);\n+DECLARE_REAL_AND_INTERCEPTOR(void *, memset, void *, int, uptr);\n+\n+INTERCEPTOR(void *, __aeabi_memmove, void *to, const void *from, uptr size) {\n+  return WRAP(memmove)(to, from, size);\n+}\n+INTERCEPTOR(void *, __aeabi_memmove4, void *to, const void *from, uptr size) {\n+  return WRAP(memmove)(to, from, size);\n+}\n+INTERCEPTOR(void *, __aeabi_memmove8, void *to, const void *from, uptr size) {\n+  return WRAP(memmove)(to, from, size);\n+}\n+INTERCEPTOR(void *, __aeabi_memcpy, void *to, const void *from, uptr size) {\n+  return WRAP(memcpy)(to, from, size);\n+}\n+INTERCEPTOR(void *, __aeabi_memcpy4, void *to, const void *from, uptr size) {\n+  return WRAP(memcpy)(to, from, size);\n+}\n+INTERCEPTOR(void *, __aeabi_memcpy8, void *to, const void *from, uptr size) {\n+  return WRAP(memcpy)(to, from, size);\n+}\n+// Note the argument order.\n+INTERCEPTOR(void *, __aeabi_memset, void *block, uptr size, int c) {\n+  return WRAP(memset)(block, c, size);\n+}\n+INTERCEPTOR(void *, __aeabi_memset4, void *block, uptr size, int c) {\n+  return WRAP(memset)(block, c, size);\n+}\n+INTERCEPTOR(void *, __aeabi_memset8, void *block, uptr size, int c) {\n+  return WRAP(memset)(block, c, size);\n+}\n+INTERCEPTOR(void *, __aeabi_memclr, void *block, uptr size) {\n+  return WRAP(memset)(block, 0, size);\n+}\n+INTERCEPTOR(void *, __aeabi_memclr4, void *block, uptr size) {\n+  return WRAP(memset)(block, 0, size);\n+}\n+INTERCEPTOR(void *, __aeabi_memclr8, void *block, uptr size) {\n+  return WRAP(memset)(block, 0, size);\n+}\n+#define INIT_AEABI_MEM                         \\\n+  COMMON_INTERCEPT_FUNCTION(__aeabi_memmove);  \\\n+  COMMON_INTERCEPT_FUNCTION(__aeabi_memmove4); \\\n+  COMMON_INTERCEPT_FUNCTION(__aeabi_memmove8); \\\n+  COMMON_INTERCEPT_FUNCTION(__aeabi_memcpy);   \\\n+  COMMON_INTERCEPT_FUNCTION(__aeabi_memcpy4);  \\\n+  COMMON_INTERCEPT_FUNCTION(__aeabi_memcpy8);  \\\n+  COMMON_INTERCEPT_FUNCTION(__aeabi_memset);   \\\n+  COMMON_INTERCEPT_FUNCTION(__aeabi_memset4);  \\\n+  COMMON_INTERCEPT_FUNCTION(__aeabi_memset8);  \\\n+  COMMON_INTERCEPT_FUNCTION(__aeabi_memclr);   \\\n+  COMMON_INTERCEPT_FUNCTION(__aeabi_memclr4);  \\\n+  COMMON_INTERCEPT_FUNCTION(__aeabi_memclr8);\n+#else\n+#define INIT_AEABI_MEM\n+#endif  // SANITIZER_INTERCEPT_AEABI_MEM\n+\n+#if SANITIZER_INTERCEPT___BZERO\n+DECLARE_REAL_AND_INTERCEPTOR(void *, memset, void *, int, uptr);\n+\n+INTERCEPTOR(void *, __bzero, void *block, uptr size) {\n+  return WRAP(memset)(block, 0, size);\n+}\n+#define INIT___BZERO COMMON_INTERCEPT_FUNCTION(__bzero);\n+#else\n+#define INIT___BZERO\n+#endif  // SANITIZER_INTERCEPT___BZERO\n+\n+#if SANITIZER_INTERCEPT_FTIME\n+INTERCEPTOR(int, ftime, __sanitizer_timeb *tp) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, ftime, tp);\n+  int res = REAL(ftime)(tp);\n+  if (tp)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, tp, sizeof(*tp));\n+  return res;\n+}\n+#define INIT_FTIME COMMON_INTERCEPT_FUNCTION(ftime);\n+#else\n+#define INIT_FTIME\n+#endif  // SANITIZER_INTERCEPT_FTIME\n+\n+#if SANITIZER_INTERCEPT_XDR\n+INTERCEPTOR(void, xdrmem_create, __sanitizer_XDR *xdrs, uptr addr,\n+            unsigned size, int op) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, xdrmem_create, xdrs, addr, size, op);\n+  REAL(xdrmem_create)(xdrs, addr, size, op);\n+  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, xdrs, sizeof(*xdrs));\n+  if (op == __sanitizer_XDR_ENCODE) {\n+    // It's not obvious how much data individual xdr_ routines write.\n+    // Simply unpoison the entire target buffer in advance.\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, (void *)addr, size);\n+  }\n+}\n+\n+INTERCEPTOR(void, xdrstdio_create, __sanitizer_XDR *xdrs, void *file, int op) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, xdrstdio_create, xdrs, file, op);\n+  REAL(xdrstdio_create)(xdrs, file, op);\n+  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, xdrs, sizeof(*xdrs));\n+}\n+\n+#define XDR_INTERCEPTOR(F, T)                             \\\n+  INTERCEPTOR(int, F, __sanitizer_XDR *xdrs, T *p) {      \\\n+    void *ctx;                                            \\\n+    COMMON_INTERCEPTOR_ENTER(ctx, F, xdrs, p);            \\\n+    if (p && xdrs->x_op == __sanitizer_XDR_ENCODE)        \\\n+      COMMON_INTERCEPTOR_READ_RANGE(ctx, p, sizeof(*p));  \\\n+    int res = REAL(F)(xdrs, p);                           \\\n+    if (res && p && xdrs->x_op == __sanitizer_XDR_DECODE) \\\n+      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p, sizeof(*p)); \\\n+    return res;                                           \\\n+  }\n+\n+XDR_INTERCEPTOR(xdr_short, short)\n+XDR_INTERCEPTOR(xdr_u_short, unsigned short)\n+XDR_INTERCEPTOR(xdr_int, int)\n+XDR_INTERCEPTOR(xdr_u_int, unsigned)\n+XDR_INTERCEPTOR(xdr_long, long)\n+XDR_INTERCEPTOR(xdr_u_long, unsigned long)\n+XDR_INTERCEPTOR(xdr_hyper, long long)\n+XDR_INTERCEPTOR(xdr_u_hyper, unsigned long long)\n+XDR_INTERCEPTOR(xdr_longlong_t, long long)\n+XDR_INTERCEPTOR(xdr_u_longlong_t, unsigned long long)\n+XDR_INTERCEPTOR(xdr_int8_t, u8)\n+XDR_INTERCEPTOR(xdr_uint8_t, u8)\n+XDR_INTERCEPTOR(xdr_int16_t, u16)\n+XDR_INTERCEPTOR(xdr_uint16_t, u16)\n+XDR_INTERCEPTOR(xdr_int32_t, u32)\n+XDR_INTERCEPTOR(xdr_uint32_t, u32)\n+XDR_INTERCEPTOR(xdr_int64_t, u64)\n+XDR_INTERCEPTOR(xdr_uint64_t, u64)\n+XDR_INTERCEPTOR(xdr_quad_t, long long)\n+XDR_INTERCEPTOR(xdr_u_quad_t, unsigned long long)\n+XDR_INTERCEPTOR(xdr_bool, bool)\n+XDR_INTERCEPTOR(xdr_enum, int)\n+XDR_INTERCEPTOR(xdr_char, char)\n+XDR_INTERCEPTOR(xdr_u_char, unsigned char)\n+XDR_INTERCEPTOR(xdr_float, float)\n+XDR_INTERCEPTOR(xdr_double, double)\n+\n+// FIXME: intercept xdr_array, opaque, union, vector, reference, pointer,\n+// wrapstring, sizeof\n+\n+INTERCEPTOR(int, xdr_bytes, __sanitizer_XDR *xdrs, char **p, unsigned *sizep,\n+            unsigned maxsize) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, xdr_bytes, xdrs, p, sizep, maxsize);\n+  if (p && sizep && xdrs->x_op == __sanitizer_XDR_ENCODE) {\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, p, sizeof(*p));\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, sizep, sizeof(*sizep));\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, *p, *sizep);\n+  }\n+  int res = REAL(xdr_bytes)(xdrs, p, sizep, maxsize);\n+  if (p && sizep && xdrs->x_op == __sanitizer_XDR_DECODE) {\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p, sizeof(*p));\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, sizep, sizeof(*sizep));\n+    if (res && *p && *sizep) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, *p, *sizep);\n+  }\n+  return res;\n+}\n+\n+INTERCEPTOR(int, xdr_string, __sanitizer_XDR *xdrs, char **p,\n+            unsigned maxsize) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, xdr_string, xdrs, p, maxsize);\n+  if (p && xdrs->x_op == __sanitizer_XDR_ENCODE) {\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, p, sizeof(*p));\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, *p, REAL(strlen)(*p) + 1);\n+  }\n+  int res = REAL(xdr_string)(xdrs, p, maxsize);\n+  if (p && xdrs->x_op == __sanitizer_XDR_DECODE) {\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p, sizeof(*p));\n+    if (res && *p)\n+      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, *p, REAL(strlen)(*p) + 1);\n+  }\n+  return res;\n+}\n+\n+#define INIT_XDR                               \\\n+  COMMON_INTERCEPT_FUNCTION(xdrmem_create);    \\\n+  COMMON_INTERCEPT_FUNCTION(xdrstdio_create);  \\\n+  COMMON_INTERCEPT_FUNCTION(xdr_short);        \\\n+  COMMON_INTERCEPT_FUNCTION(xdr_u_short);      \\\n+  COMMON_INTERCEPT_FUNCTION(xdr_int);          \\\n+  COMMON_INTERCEPT_FUNCTION(xdr_u_int);        \\\n+  COMMON_INTERCEPT_FUNCTION(xdr_long);         \\\n+  COMMON_INTERCEPT_FUNCTION(xdr_u_long);       \\\n+  COMMON_INTERCEPT_FUNCTION(xdr_hyper);        \\\n+  COMMON_INTERCEPT_FUNCTION(xdr_u_hyper);      \\\n+  COMMON_INTERCEPT_FUNCTION(xdr_longlong_t);   \\\n+  COMMON_INTERCEPT_FUNCTION(xdr_u_longlong_t); \\\n+  COMMON_INTERCEPT_FUNCTION(xdr_int8_t);       \\\n+  COMMON_INTERCEPT_FUNCTION(xdr_uint8_t);      \\\n+  COMMON_INTERCEPT_FUNCTION(xdr_int16_t);      \\\n+  COMMON_INTERCEPT_FUNCTION(xdr_uint16_t);     \\\n+  COMMON_INTERCEPT_FUNCTION(xdr_int32_t);      \\\n+  COMMON_INTERCEPT_FUNCTION(xdr_uint32_t);     \\\n+  COMMON_INTERCEPT_FUNCTION(xdr_int64_t);      \\\n+  COMMON_INTERCEPT_FUNCTION(xdr_uint64_t);     \\\n+  COMMON_INTERCEPT_FUNCTION(xdr_quad_t);       \\\n+  COMMON_INTERCEPT_FUNCTION(xdr_u_quad_t);     \\\n+  COMMON_INTERCEPT_FUNCTION(xdr_bool);         \\\n+  COMMON_INTERCEPT_FUNCTION(xdr_enum);         \\\n+  COMMON_INTERCEPT_FUNCTION(xdr_char);         \\\n+  COMMON_INTERCEPT_FUNCTION(xdr_u_char);       \\\n+  COMMON_INTERCEPT_FUNCTION(xdr_float);        \\\n+  COMMON_INTERCEPT_FUNCTION(xdr_double);       \\\n+  COMMON_INTERCEPT_FUNCTION(xdr_bytes);        \\\n+  COMMON_INTERCEPT_FUNCTION(xdr_string);\n+#else\n+#define INIT_XDR\n+#endif  // SANITIZER_INTERCEPT_XDR\n+\n+#if SANITIZER_INTERCEPT_TSEARCH\n+INTERCEPTOR(void *, tsearch, void *key, void **rootp,\n+            int (*compar)(const void *, const void *)) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, tsearch, key, rootp, compar);\n+  void *res = REAL(tsearch)(key, rootp, compar);\n+  if (res && *(void **)res == key)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, sizeof(void *));\n+  return res;\n+}\n+#define INIT_TSEARCH COMMON_INTERCEPT_FUNCTION(tsearch);\n+#else\n+#define INIT_TSEARCH\n+#endif\n+\n+#if SANITIZER_INTERCEPT_LIBIO_INTERNALS || SANITIZER_INTERCEPT_FOPEN || \\\n+    SANITIZER_INTERCEPT_OPEN_MEMSTREAM\n+void unpoison_file(__sanitizer_FILE *fp) {\n+#if SANITIZER_HAS_STRUCT_FILE\n+  COMMON_INTERCEPTOR_INITIALIZE_RANGE(fp, sizeof(*fp));\n+  if (fp->_IO_read_base && fp->_IO_read_base < fp->_IO_read_end)\n+    COMMON_INTERCEPTOR_INITIALIZE_RANGE(fp->_IO_read_base,\n+                                        fp->_IO_read_end - fp->_IO_read_base);\n+#endif  // SANITIZER_HAS_STRUCT_FILE\n+}\n+#endif\n+\n+#if SANITIZER_INTERCEPT_LIBIO_INTERNALS\n+// These guys are called when a .c source is built with -O2.\n+INTERCEPTOR(int, __uflow, __sanitizer_FILE *fp) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, __uflow, fp);\n+  int res = REAL(__uflow)(fp);\n+  unpoison_file(fp);\n+  return res;\n+}\n+INTERCEPTOR(int, __underflow, __sanitizer_FILE *fp) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, __underflow, fp);\n+  int res = REAL(__underflow)(fp);\n+  unpoison_file(fp);\n+  return res;\n+}\n+INTERCEPTOR(int, __overflow, __sanitizer_FILE *fp, int ch) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, __overflow, fp, ch);\n+  int res = REAL(__overflow)(fp, ch);\n+  unpoison_file(fp);\n+  return res;\n+}\n+INTERCEPTOR(int, __wuflow, __sanitizer_FILE *fp) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, __wuflow, fp);\n+  int res = REAL(__wuflow)(fp);\n+  unpoison_file(fp);\n+  return res;\n+}\n+INTERCEPTOR(int, __wunderflow, __sanitizer_FILE *fp) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, __wunderflow, fp);\n+  int res = REAL(__wunderflow)(fp);\n+  unpoison_file(fp);\n+  return res;\n+}\n+INTERCEPTOR(int, __woverflow, __sanitizer_FILE *fp, int ch) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, __woverflow, fp, ch);\n+  int res = REAL(__woverflow)(fp, ch);\n+  unpoison_file(fp);\n+  return res;\n+}\n+#define INIT_LIBIO_INTERNALS               \\\n+  COMMON_INTERCEPT_FUNCTION(__uflow);      \\\n+  COMMON_INTERCEPT_FUNCTION(__underflow);  \\\n+  COMMON_INTERCEPT_FUNCTION(__overflow);   \\\n+  COMMON_INTERCEPT_FUNCTION(__wuflow);     \\\n+  COMMON_INTERCEPT_FUNCTION(__wunderflow); \\\n+  COMMON_INTERCEPT_FUNCTION(__woverflow);\n+#else\n+#define INIT_LIBIO_INTERNALS\n+#endif\n+\n+#if SANITIZER_INTERCEPT_FOPEN\n+INTERCEPTOR(__sanitizer_FILE *, fopen, const char *path, const char *mode) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, fopen, path, mode);\n+  COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n+  COMMON_INTERCEPTOR_READ_RANGE(ctx, mode, REAL(strlen)(mode) + 1);\n+  __sanitizer_FILE *res = REAL(fopen)(path, mode);\n+  COMMON_INTERCEPTOR_FILE_OPEN(ctx, res, path);\n+  if (res) unpoison_file(res);\n+  return res;\n+}\n+INTERCEPTOR(__sanitizer_FILE *, fdopen, int fd, const char *mode) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, fdopen, fd, mode);\n+  COMMON_INTERCEPTOR_READ_RANGE(ctx, mode, REAL(strlen)(mode) + 1);\n+  __sanitizer_FILE *res = REAL(fdopen)(fd, mode);\n+  if (res) unpoison_file(res);\n+  return res;\n+}\n+INTERCEPTOR(__sanitizer_FILE *, freopen, const char *path, const char *mode,\n+            __sanitizer_FILE *fp) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, freopen, path, mode, fp);\n+  COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n+  COMMON_INTERCEPTOR_READ_RANGE(ctx, mode, REAL(strlen)(mode) + 1);\n+  COMMON_INTERCEPTOR_FILE_CLOSE(ctx, fp);\n+  __sanitizer_FILE *res = REAL(freopen)(path, mode, fp);\n+  COMMON_INTERCEPTOR_FILE_OPEN(ctx, res, path);\n+  if (res) unpoison_file(res);\n+  return res;\n+}\n+#define INIT_FOPEN                   \\\n+  COMMON_INTERCEPT_FUNCTION(fopen);  \\\n+  COMMON_INTERCEPT_FUNCTION(fdopen); \\\n+  COMMON_INTERCEPT_FUNCTION(freopen);\n+#else\n+#define INIT_FOPEN\n+#endif\n+\n+#if SANITIZER_INTERCEPT_FOPEN64\n+INTERCEPTOR(__sanitizer_FILE *, fopen64, const char *path, const char *mode) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, fopen64, path, mode);\n+  COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n+  COMMON_INTERCEPTOR_READ_RANGE(ctx, mode, REAL(strlen)(mode) + 1);\n+  __sanitizer_FILE *res = REAL(fopen64)(path, mode);\n+  COMMON_INTERCEPTOR_FILE_OPEN(ctx, res, path);\n+  if (res) unpoison_file(res);\n+  return res;\n+}\n+INTERCEPTOR(__sanitizer_FILE *, freopen64, const char *path, const char *mode,\n+            __sanitizer_FILE *fp) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, freopen64, path, mode, fp);\n+  COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n+  COMMON_INTERCEPTOR_READ_RANGE(ctx, mode, REAL(strlen)(mode) + 1);\n+  COMMON_INTERCEPTOR_FILE_CLOSE(ctx, fp);\n+  __sanitizer_FILE *res = REAL(freopen64)(path, mode, fp);\n+  COMMON_INTERCEPTOR_FILE_OPEN(ctx, res, path);\n+  if (res) unpoison_file(res);\n+  return res;\n+}\n+#define INIT_FOPEN64                  \\\n+  COMMON_INTERCEPT_FUNCTION(fopen64); \\\n+  COMMON_INTERCEPT_FUNCTION(freopen64);\n+#else\n+#define INIT_FOPEN64\n+#endif\n+\n+#if SANITIZER_INTERCEPT_OPEN_MEMSTREAM\n+INTERCEPTOR(__sanitizer_FILE *, open_memstream, char **ptr, SIZE_T *sizeloc) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, open_memstream, ptr, sizeloc);\n+  __sanitizer_FILE *res = REAL(open_memstream)(ptr, sizeloc);\n+  if (res) {\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ptr, sizeof(*ptr));\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, sizeloc, sizeof(*sizeloc));\n+    unpoison_file(res);\n+    FileMetadata file = {ptr, sizeloc};\n+    SetInterceptorMetadata(res, file);\n+  }\n+  return res;\n+}\n+INTERCEPTOR(__sanitizer_FILE *, open_wmemstream, wchar_t **ptr,\n+            SIZE_T *sizeloc) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, open_wmemstream, ptr, sizeloc);\n+  __sanitizer_FILE *res = REAL(open_wmemstream)(ptr, sizeloc);\n+  if (res) {\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ptr, sizeof(*ptr));\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, sizeloc, sizeof(*sizeloc));\n+    unpoison_file(res);\n+    FileMetadata file = {(char **)ptr, sizeloc};\n+    SetInterceptorMetadata(res, file);\n+  }\n+  return res;\n+}\n+INTERCEPTOR(__sanitizer_FILE *, fmemopen, void *buf, SIZE_T size,\n+            const char *mode) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, fmemopen, buf, size, mode);\n+  __sanitizer_FILE *res = REAL(fmemopen)(buf, size, mode);\n+  if (res) unpoison_file(res);\n+  return res;\n+}\n+#define INIT_OPEN_MEMSTREAM                   \\\n+  COMMON_INTERCEPT_FUNCTION(open_memstream);  \\\n+  COMMON_INTERCEPT_FUNCTION(open_wmemstream); \\\n+  COMMON_INTERCEPT_FUNCTION(fmemopen);\n+#else\n+#define INIT_OPEN_MEMSTREAM\n+#endif\n+\n+#if SANITIZER_INTERCEPT_OBSTACK\n+static void initialize_obstack(__sanitizer_obstack *obstack) {\n+  COMMON_INTERCEPTOR_INITIALIZE_RANGE(obstack, sizeof(*obstack));\n+  if (obstack->chunk)\n+    COMMON_INTERCEPTOR_INITIALIZE_RANGE(obstack->chunk,\n+                                        sizeof(*obstack->chunk));\n+}\n+\n+INTERCEPTOR(int, _obstack_begin_1, __sanitizer_obstack *obstack, int sz,\n+            int align, void *(*alloc_fn)(uptr arg, uptr sz),\n+            void (*free_fn)(uptr arg, void *p)) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, _obstack_begin_1, obstack, sz, align, alloc_fn,\n+                           free_fn);\n+  int res = REAL(_obstack_begin_1)(obstack, sz, align, alloc_fn, free_fn);\n+  if (res) initialize_obstack(obstack);\n+  return res;\n+}\n+INTERCEPTOR(int, _obstack_begin, __sanitizer_obstack *obstack, int sz,\n+            int align, void *(*alloc_fn)(uptr sz), void (*free_fn)(void *p)) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, _obstack_begin, obstack, sz, align, alloc_fn,\n+                           free_fn);\n+  int res = REAL(_obstack_begin)(obstack, sz, align, alloc_fn, free_fn);\n+  if (res) initialize_obstack(obstack);\n+  return res;\n+}\n+INTERCEPTOR(void, _obstack_newchunk, __sanitizer_obstack *obstack, int length) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, _obstack_newchunk, obstack, length);\n+  REAL(_obstack_newchunk)(obstack, length);\n+  if (obstack->chunk)\n+    COMMON_INTERCEPTOR_INITIALIZE_RANGE(\n+        obstack->chunk, obstack->next_free - (char *)obstack->chunk);\n+}\n+#define INIT_OBSTACK                           \\\n+  COMMON_INTERCEPT_FUNCTION(_obstack_begin_1); \\\n+  COMMON_INTERCEPT_FUNCTION(_obstack_begin);   \\\n+  COMMON_INTERCEPT_FUNCTION(_obstack_newchunk);\n+#else\n+#define INIT_OBSTACK\n+#endif\n+\n+#if SANITIZER_INTERCEPT_FFLUSH\n+INTERCEPTOR(int, fflush, __sanitizer_FILE *fp) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, fflush, fp);\n+  int res = REAL(fflush)(fp);\n+  // FIXME: handle fp == NULL\n+  if (fp) {\n+    const FileMetadata *m = GetInterceptorMetadata(fp);\n+    if (m) COMMON_INTERCEPTOR_INITIALIZE_RANGE(*m->addr, *m->size);\n+  }\n+  return res;\n+}\n+#define INIT_FFLUSH COMMON_INTERCEPT_FUNCTION(fflush);\n+#else\n+#define INIT_FFLUSH\n+#endif\n+\n+#if SANITIZER_INTERCEPT_FCLOSE\n+INTERCEPTOR(int, fclose, __sanitizer_FILE *fp) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, fclose, fp);\n+  if (fp) {\n+    COMMON_INTERCEPTOR_FILE_CLOSE(ctx, fp);\n+    const FileMetadata *m = GetInterceptorMetadata(fp);\n+    if (m) {\n+      COMMON_INTERCEPTOR_INITIALIZE_RANGE(*m->addr, *m->size);\n+      DeleteInterceptorMetadata(fp);\n+    }\n+  }\n+  return REAL(fclose)(fp);\n+}\n+#define INIT_FCLOSE COMMON_INTERCEPT_FUNCTION(fclose);\n+#else\n+#define INIT_FCLOSE\n+#endif\n+\n+static void InitializeCommonInterceptors() {\n+  static u64 metadata_mem[sizeof(MetadataHashMap) / sizeof(u64) + 1];\n+  interceptor_metadata_map = new((void *)&metadata_mem) MetadataHashMap();\n+\n+  INIT_TEXTDOMAIN;\n+  INIT_STRCMP;\n+  INIT_STRNCMP;\n+  INIT_STRCASECMP;\n+  INIT_STRNCASECMP;\n+  INIT_MEMCHR;\n+  INIT_MEMRCHR;\n+  INIT_READ;\n+  INIT_PREAD;\n+  INIT_PREAD64;\n+  INIT_READV;\n+  INIT_PREADV;\n+  INIT_PREADV64;\n+  INIT_WRITE;\n+  INIT_PWRITE;\n+  INIT_PWRITE64;\n+  INIT_WRITEV;\n+  INIT_PWRITEV;\n+  INIT_PWRITEV64;\n+  INIT_PRCTL;\n+  INIT_LOCALTIME_AND_FRIENDS;\n+  INIT_STRPTIME;\n+  INIT_SCANF;\n+  INIT_ISOC99_SCANF;\n+  INIT_PRINTF;\n+  INIT_ISOC99_PRINTF;\n+  INIT_FREXP;\n+  INIT_FREXPF_FREXPL;\n+  INIT_GETPWNAM_AND_FRIENDS;\n+  INIT_GETPWNAM_R_AND_FRIENDS;\n+  INIT_GETPWENT;\n+  INIT_FGETPWENT;\n+  INIT_GETPWENT_R;\n+  INIT_SETPWENT;\n+  INIT_CLOCK_GETTIME;\n+  INIT_GETITIMER;\n+  INIT_TIME;\n+  INIT_GLOB;\n+  INIT_WAIT;\n+  INIT_WAIT4;\n+  INIT_INET;\n+  INIT_PTHREAD_GETSCHEDPARAM;\n+  INIT_GETADDRINFO;\n+  INIT_GETNAMEINFO;\n+  INIT_GETSOCKNAME;\n+  INIT_GETHOSTBYNAME;\n+  INIT_GETHOSTBYNAME_R;\n+  INIT_GETSOCKOPT;\n+  INIT_ACCEPT;\n+  INIT_ACCEPT4;\n+  INIT_MODF;\n+  INIT_RECVMSG;\n+  INIT_GETPEERNAME;\n+  INIT_IOCTL;\n+  INIT_INET_ATON;\n+  INIT_SYSINFO;\n+  INIT_READDIR;\n+  INIT_READDIR64;\n+  INIT_PTRACE;\n+  INIT_SETLOCALE;\n+  INIT_GETCWD;\n+  INIT_GET_CURRENT_DIR_NAME;\n+  INIT_STRTOIMAX;\n+  INIT_MBSTOWCS;\n+  INIT_MBSNRTOWCS;\n+  INIT_WCSTOMBS;\n+  INIT_WCSNRTOMBS;\n+  INIT_TCGETATTR;\n+  INIT_REALPATH;\n+  INIT_CANONICALIZE_FILE_NAME;\n+  INIT_CONFSTR;\n+  INIT_SCHED_GETAFFINITY;\n+  INIT_STRERROR;\n+  INIT_STRERROR_R;\n+  INIT_XPG_STRERROR_R;\n+  INIT_SCANDIR;\n+  INIT_SCANDIR64;\n+  INIT_GETGROUPS;\n+  INIT_POLL;\n+  INIT_PPOLL;\n+  INIT_WORDEXP;\n+  INIT_SIGWAIT;\n+  INIT_SIGWAITINFO;\n+  INIT_SIGTIMEDWAIT;\n+  INIT_SIGSETOPS;\n+  INIT_SIGPENDING;\n+  INIT_SIGPROCMASK;\n+  INIT_BACKTRACE;\n+  INIT__EXIT;\n+  INIT_PTHREAD_MUTEX_LOCK;\n+  INIT_PTHREAD_MUTEX_UNLOCK;\n+  INIT_GETMNTENT;\n+  INIT_GETMNTENT_R;\n+  INIT_STATFS;\n+  INIT_STATFS64;\n+  INIT_STATVFS;\n+  INIT_STATVFS64;\n+  INIT_INITGROUPS;\n+  INIT_ETHER;\n+  INIT_ETHER_R;\n+  INIT_SHMCTL;\n+  INIT_RANDOM_R;\n+  INIT_PTHREAD_ATTR_GET;\n+  INIT_PTHREAD_ATTR_GETINHERITSCHED;\n+  INIT_PTHREAD_ATTR_GETAFFINITY_NP;\n+  INIT_TMPNAM;\n+  INIT_TMPNAM_R;\n+  INIT_TEMPNAM;\n+  INIT_PTHREAD_SETNAME_NP;\n+  INIT_SINCOS;\n+  INIT_REMQUO;\n+  INIT_LGAMMA;\n+  INIT_LGAMMA_R;\n+  INIT_DRAND48_R;\n+  INIT_RAND_R;\n+  INIT_GETLINE;\n+  INIT_ICONV;\n+  INIT_TIMES;\n+  INIT_TLS_GET_ADDR;\n+  INIT_LISTXATTR;\n+  INIT_GETXATTR;\n+  INIT_GETRESID;\n+  INIT_GETIFADDRS;\n+  INIT_IF_INDEXTONAME;\n+  INIT_CAPGET;\n+  INIT_AEABI_MEM;\n+  INIT___BZERO;\n+  INIT_FTIME;\n+  INIT_XDR;\n+  INIT_TSEARCH;\n+  INIT_LIBIO_INTERNALS;\n+  INIT_FOPEN;\n+  INIT_FOPEN64;\n+  INIT_OPEN_MEMSTREAM;\n+  INIT_OBSTACK;\n+  INIT_FFLUSH;\n+  INIT_FCLOSE;\n+}"}, {"sha": "dfc4ac6b556a87f1f7d0bf2e3013e5d09d453d53", "filename": "libsanitizer/sanitizer_common/sanitizer_common_interceptors_format.inc", "status": "added", "additions": 554, "deletions": 0, "changes": 554, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_format.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_format.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_format.inc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -0,0 +1,554 @@\n+//===-- sanitizer_common_interceptors_format.inc ----------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Scanf/printf implementation for use in *Sanitizer interceptors.\n+// Follows http://pubs.opengroup.org/onlinepubs/9699919799/functions/fscanf.html\n+// and http://pubs.opengroup.org/onlinepubs/9699919799/functions/fprintf.html\n+// with a few common GNU extensions.\n+//\n+//===----------------------------------------------------------------------===//\n+#include <stdarg.h>\n+\n+static const char *parse_number(const char *p, int *out) {\n+  *out = internal_atoll(p);\n+  while (*p >= '0' && *p <= '9')\n+    ++p;\n+  return p;\n+}\n+\n+static const char *maybe_parse_param_index(const char *p, int *out) {\n+  // n$\n+  if (*p >= '0' && *p <= '9') {\n+    int number;\n+    const char *q = parse_number(p, &number);\n+    CHECK(q);\n+    if (*q == '$') {\n+      *out = number;\n+      p = q + 1;\n+    }\n+  }\n+\n+  // Otherwise, do not change p. This will be re-parsed later as the field\n+  // width.\n+  return p;\n+}\n+\n+static bool char_is_one_of(char c, const char *s) {\n+  return !!internal_strchr(s, c);\n+}\n+\n+static const char *maybe_parse_length_modifier(const char *p, char ll[2]) {\n+  if (char_is_one_of(*p, \"jztLq\")) {\n+    ll[0] = *p;\n+    ++p;\n+  } else if (*p == 'h') {\n+    ll[0] = 'h';\n+    ++p;\n+    if (*p == 'h') {\n+      ll[1] = 'h';\n+      ++p;\n+    }\n+  } else if (*p == 'l') {\n+    ll[0] = 'l';\n+    ++p;\n+    if (*p == 'l') {\n+      ll[1] = 'l';\n+      ++p;\n+    }\n+  }\n+  return p;\n+}\n+\n+// Returns true if the character is an integer conversion specifier.\n+static bool format_is_integer_conv(char c) {\n+  return char_is_one_of(c, \"diouxXn\");\n+}\n+\n+// Returns true if the character is an floating point conversion specifier.\n+static bool format_is_float_conv(char c) {\n+  return char_is_one_of(c, \"aAeEfFgG\");\n+}\n+\n+// Returns string output character size for string-like conversions,\n+// or 0 if the conversion is invalid.\n+static int format_get_char_size(char convSpecifier,\n+                                const char lengthModifier[2]) {\n+  if (char_is_one_of(convSpecifier, \"CS\")) {\n+    return sizeof(wchar_t);\n+  }\n+\n+  if (char_is_one_of(convSpecifier, \"cs[\")) {\n+    if (lengthModifier[0] == 'l' && lengthModifier[1] == '\\0')\n+      return sizeof(wchar_t);\n+    else if (lengthModifier[0] == '\\0')\n+      return sizeof(char);\n+  }\n+\n+  return 0;\n+}\n+\n+enum FormatStoreSize {\n+  // Store size not known in advance; can be calculated as wcslen() of the\n+  // destination buffer.\n+  FSS_WCSLEN = -2,\n+  // Store size not known in advance; can be calculated as strlen() of the\n+  // destination buffer.\n+  FSS_STRLEN = -1,\n+  // Invalid conversion specifier.\n+  FSS_INVALID = 0\n+};\n+\n+// Returns the memory size of a format directive (if >0), or a value of\n+// FormatStoreSize.\n+static int format_get_value_size(char convSpecifier,\n+                                 const char lengthModifier[2],\n+                                 bool promote_float) {\n+  if (format_is_integer_conv(convSpecifier)) {\n+    switch (lengthModifier[0]) {\n+    case 'h':\n+      return lengthModifier[1] == 'h' ? sizeof(char) : sizeof(short);\n+    case 'l':\n+      return lengthModifier[1] == 'l' ? sizeof(long long) : sizeof(long);\n+    case 'q':\n+      return sizeof(long long);\n+    case 'L':\n+      return sizeof(long long);\n+    case 'j':\n+      return sizeof(INTMAX_T);\n+    case 'z':\n+      return sizeof(SIZE_T);\n+    case 't':\n+      return sizeof(PTRDIFF_T);\n+    case 0:\n+      return sizeof(int);\n+    default:\n+      return FSS_INVALID;\n+    }\n+  }\n+\n+  if (format_is_float_conv(convSpecifier)) {\n+    switch (lengthModifier[0]) {\n+    case 'L':\n+    case 'q':\n+      return sizeof(long double);\n+    case 'l':\n+      return lengthModifier[1] == 'l' ? sizeof(long double)\n+                                           : sizeof(double);\n+    case 0:\n+      // Printf promotes floats to doubles but scanf does not\n+      return promote_float ? sizeof(double) : sizeof(float);\n+    default:\n+      return FSS_INVALID;\n+    }\n+  }\n+\n+  if (convSpecifier == 'p') {\n+    if (lengthModifier[0] != 0)\n+      return FSS_INVALID;\n+    return sizeof(void *);\n+  }\n+\n+  return FSS_INVALID;\n+}\n+\n+struct ScanfDirective {\n+  int argIdx; // argument index, or -1 if not specified (\"%n$\")\n+  int fieldWidth;\n+  const char *begin;\n+  const char *end;\n+  bool suppressed; // suppress assignment (\"*\")\n+  bool allocate;   // allocate space (\"m\")\n+  char lengthModifier[2];\n+  char convSpecifier;\n+  bool maybeGnuMalloc;\n+};\n+\n+// Parse scanf format string. If a valid directive in encountered, it is\n+// returned in dir. This function returns the pointer to the first\n+// unprocessed character, or 0 in case of error.\n+// In case of the end-of-string, a pointer to the closing \\0 is returned.\n+static const char *scanf_parse_next(const char *p, bool allowGnuMalloc,\n+                                    ScanfDirective *dir) {\n+  internal_memset(dir, 0, sizeof(*dir));\n+  dir->argIdx = -1;\n+\n+  while (*p) {\n+    if (*p != '%') {\n+      ++p;\n+      continue;\n+    }\n+    dir->begin = p;\n+    ++p;\n+    // %%\n+    if (*p == '%') {\n+      ++p;\n+      continue;\n+    }\n+    if (*p == '\\0') {\n+      return 0;\n+    }\n+    // %n$\n+    p = maybe_parse_param_index(p, &dir->argIdx);\n+    CHECK(p);\n+    // *\n+    if (*p == '*') {\n+      dir->suppressed = true;\n+      ++p;\n+    }\n+    // Field width\n+    if (*p >= '0' && *p <= '9') {\n+      p = parse_number(p, &dir->fieldWidth);\n+      CHECK(p);\n+      if (dir->fieldWidth <= 0)  // Width if at all must be non-zero\n+        return 0;\n+    }\n+    // m\n+    if (*p == 'm') {\n+      dir->allocate = true;\n+      ++p;\n+    }\n+    // Length modifier.\n+    p = maybe_parse_length_modifier(p, dir->lengthModifier);\n+    // Conversion specifier.\n+    dir->convSpecifier = *p++;\n+    // Consume %[...] expression.\n+    if (dir->convSpecifier == '[') {\n+      if (*p == '^')\n+        ++p;\n+      if (*p == ']')\n+        ++p;\n+      while (*p && *p != ']')\n+        ++p;\n+      if (*p == 0)\n+        return 0; // unexpected end of string\n+                  // Consume the closing ']'.\n+      ++p;\n+    }\n+    // This is unfortunately ambiguous between old GNU extension\n+    // of %as, %aS and %a[...] and newer POSIX %a followed by\n+    // letters s, S or [.\n+    if (allowGnuMalloc && dir->convSpecifier == 'a' &&\n+        !dir->lengthModifier[0]) {\n+      if (*p == 's' || *p == 'S') {\n+        dir->maybeGnuMalloc = true;\n+        ++p;\n+      } else if (*p == '[') {\n+        // Watch for %a[h-j%d], if % appears in the\n+        // [...] range, then we need to give up, we don't know\n+        // if scanf will parse it as POSIX %a [h-j %d ] or\n+        // GNU allocation of string with range dh-j plus %.\n+        const char *q = p + 1;\n+        if (*q == '^')\n+          ++q;\n+        if (*q == ']')\n+          ++q;\n+        while (*q && *q != ']' && *q != '%')\n+          ++q;\n+        if (*q == 0 || *q == '%')\n+          return 0;\n+        p = q + 1; // Consume the closing ']'.\n+        dir->maybeGnuMalloc = true;\n+      }\n+    }\n+    dir->end = p;\n+    break;\n+  }\n+  return p;\n+}\n+\n+static int scanf_get_value_size(ScanfDirective *dir) {\n+  if (dir->allocate) {\n+    if (!char_is_one_of(dir->convSpecifier, \"cCsS[\"))\n+      return FSS_INVALID;\n+    return sizeof(char *);\n+  }\n+\n+  if (dir->maybeGnuMalloc) {\n+    if (dir->convSpecifier != 'a' || dir->lengthModifier[0])\n+      return FSS_INVALID;\n+    // This is ambiguous, so check the smaller size of char * (if it is\n+    // a GNU extension of %as, %aS or %a[...]) and float (if it is\n+    // POSIX %a followed by s, S or [ letters).\n+    return sizeof(char *) < sizeof(float) ? sizeof(char *) : sizeof(float);\n+  }\n+\n+  if (char_is_one_of(dir->convSpecifier, \"cCsS[\")) {\n+    bool needsTerminator = char_is_one_of(dir->convSpecifier, \"sS[\");\n+    unsigned charSize =\n+        format_get_char_size(dir->convSpecifier, dir->lengthModifier);\n+    if (charSize == 0)\n+      return FSS_INVALID;\n+    if (dir->fieldWidth == 0) {\n+      if (!needsTerminator)\n+        return charSize;\n+      return (charSize == sizeof(char)) ? FSS_STRLEN : FSS_WCSLEN;\n+    }\n+    return (dir->fieldWidth + needsTerminator) * charSize;\n+  }\n+\n+  return format_get_value_size(dir->convSpecifier, dir->lengthModifier, false);\n+}\n+\n+// Common part of *scanf interceptors.\n+// Process format string and va_list, and report all store ranges.\n+// Stops when \"consuming\" n_inputs input items.\n+static void scanf_common(void *ctx, int n_inputs, bool allowGnuMalloc,\n+                         const char *format, va_list aq) {\n+  CHECK_GT(n_inputs, 0);\n+  const char *p = format;\n+\n+  COMMON_INTERCEPTOR_READ_RANGE(ctx, format, internal_strlen(format) + 1);\n+\n+  while (*p) {\n+    ScanfDirective dir;\n+    p = scanf_parse_next(p, allowGnuMalloc, &dir);\n+    if (!p)\n+      break;\n+    if (dir.convSpecifier == 0) {\n+      // This can only happen at the end of the format string.\n+      CHECK_EQ(*p, 0);\n+      break;\n+    }\n+    // Here the directive is valid. Do what it says.\n+    if (dir.argIdx != -1) {\n+      // Unsupported.\n+      break;\n+    }\n+    if (dir.suppressed)\n+      continue;\n+    int size = scanf_get_value_size(&dir);\n+    if (size == FSS_INVALID) {\n+      Report(\"WARNING: unexpected format specifier in scanf interceptor: \"\n+        \"%.*s\\n\", dir.end - dir.begin, dir.begin);\n+      break;\n+    }\n+    void *argp = va_arg(aq, void *);\n+    if (dir.convSpecifier != 'n')\n+      --n_inputs;\n+    if (n_inputs < 0)\n+      break;\n+    if (size == FSS_STRLEN) {\n+      size = internal_strlen((const char *)argp) + 1;\n+    } else if (size == FSS_WCSLEN) {\n+      // FIXME: actually use wcslen() to calculate it.\n+      size = 0;\n+    }\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, argp, size);\n+  }\n+}\n+\n+#if SANITIZER_INTERCEPT_PRINTF\n+\n+struct PrintfDirective {\n+  int fieldWidth;\n+  int fieldPrecision;\n+  int argIdx; // width argument index, or -1 if not specified (\"%*n$\")\n+  int precisionIdx; // precision argument index, or -1 if not specified (\".*n$\")\n+  const char *begin;\n+  const char *end;\n+  bool starredWidth;\n+  bool starredPrecision;\n+  char lengthModifier[2];\n+  char convSpecifier;\n+};\n+\n+static const char *maybe_parse_number(const char *p, int *out) {\n+  if (*p >= '0' && *p <= '9')\n+    p = parse_number(p, out);\n+  return p;\n+}\n+\n+static const char *maybe_parse_number_or_star(const char *p, int *out,\n+                                              bool *star) {\n+  if (*p == '*') {\n+    *star = true;\n+    ++p;\n+  } else {\n+    *star = false;\n+    p = maybe_parse_number(p, out);\n+  }\n+  return p;\n+}\n+\n+// Parse printf format string. Same as scanf_parse_next.\n+static const char *printf_parse_next(const char *p, PrintfDirective *dir) {\n+  internal_memset(dir, 0, sizeof(*dir));\n+  dir->argIdx = -1;\n+  dir->precisionIdx = -1;\n+\n+  while (*p) {\n+    if (*p != '%') {\n+      ++p;\n+      continue;\n+    }\n+    dir->begin = p;\n+    ++p;\n+    // %%\n+    if (*p == '%') {\n+      ++p;\n+      continue;\n+    }\n+    if (*p == '\\0') {\n+      return 0;\n+    }\n+    // %n$\n+    p = maybe_parse_param_index(p, &dir->precisionIdx);\n+    CHECK(p);\n+    // Flags\n+    while (char_is_one_of(*p, \"'-+ #0\")) {\n+      ++p;\n+    }\n+    // Field width\n+    p = maybe_parse_number_or_star(p, &dir->fieldWidth,\n+                                   &dir->starredWidth);\n+    if (!p)\n+      return 0;\n+    // Precision\n+    if (*p == '.') {\n+      ++p;\n+      // Actual precision is optional (surprise!)\n+      p = maybe_parse_number_or_star(p, &dir->fieldPrecision,\n+                                     &dir->starredPrecision);\n+      if (!p)\n+        return 0;\n+      // m$\n+      if (dir->starredPrecision) {\n+        p = maybe_parse_param_index(p, &dir->precisionIdx);\n+        CHECK(p);\n+      }\n+    }\n+    // Length modifier.\n+    p = maybe_parse_length_modifier(p, dir->lengthModifier);\n+    // Conversion specifier.\n+    dir->convSpecifier = *p++;\n+    dir->end = p;\n+    break;\n+  }\n+  return p;\n+}\n+\n+static int printf_get_value_size(PrintfDirective *dir) {\n+  if (dir->convSpecifier == 'm') {\n+    return sizeof(char *);\n+  }\n+\n+  if (char_is_one_of(dir->convSpecifier, \"cCsS\")) {\n+    unsigned charSize =\n+        format_get_char_size(dir->convSpecifier, dir->lengthModifier);\n+    if (charSize == 0)\n+      return FSS_INVALID;\n+    if (char_is_one_of(dir->convSpecifier, \"sS\")) {\n+      return (charSize == sizeof(char)) ? FSS_STRLEN : FSS_WCSLEN;\n+    }\n+    return charSize;\n+  }\n+\n+  return format_get_value_size(dir->convSpecifier, dir->lengthModifier, true);\n+}\n+\n+#define SKIP_SCALAR_ARG(aq, convSpecifier, size)                   \\\n+  do {                                                             \\\n+    if (format_is_float_conv(convSpecifier)) {                     \\\n+      switch (size) {                                              \\\n+      case 8:                                                      \\\n+        va_arg(*aq, double);                                       \\\n+        break;                                                     \\\n+      case 16:                                                     \\\n+        va_arg(*aq, long double);                                  \\\n+        break;                                                     \\\n+      default:                                                     \\\n+        Report(\"WARNING: unexpected floating-point arg size\"       \\\n+               \" in printf interceptor: %d\\n\", size);              \\\n+        return;                                                    \\\n+      }                                                            \\\n+    } else {                                                       \\\n+      switch (size) {                                              \\\n+      case 1:                                                      \\\n+      case 2:                                                      \\\n+      case 4:                                                      \\\n+        va_arg(*aq, u32);                                          \\\n+        break;                                                     \\\n+      case 8:                                                      \\\n+        va_arg(*aq, u64);                                          \\\n+        break;                                                     \\\n+      default:                                                     \\\n+        Report(\"WARNING: unexpected arg size\"                      \\\n+               \" in printf interceptor: %d\\n\", size);              \\\n+        return;                                                    \\\n+      }                                                            \\\n+    }                                                              \\\n+  } while (0)\n+\n+// Common part of *printf interceptors.\n+// Process format string and va_list, and report all load ranges.\n+static void printf_common(void *ctx, const char *format, va_list aq) {\n+  COMMON_INTERCEPTOR_READ_RANGE(ctx, format, internal_strlen(format) + 1);\n+\n+  const char *p = format;\n+\n+  while (*p) {\n+    PrintfDirective dir;\n+    p = printf_parse_next(p, &dir);\n+    if (!p)\n+      break;\n+    if (dir.convSpecifier == 0) {\n+      // This can only happen at the end of the format string.\n+      CHECK_EQ(*p, 0);\n+      break;\n+    }\n+    // Here the directive is valid. Do what it says.\n+    if (dir.argIdx != -1 || dir.precisionIdx != -1) {\n+      // Unsupported.\n+      break;\n+    }\n+    if (dir.starredWidth) {\n+      // Dynamic width\n+      SKIP_SCALAR_ARG(&aq, 'd', sizeof(int));\n+    }\n+    if (dir.starredPrecision) {\n+      // Dynamic precision\n+      SKIP_SCALAR_ARG(&aq, 'd', sizeof(int));\n+    }\n+    int size = printf_get_value_size(&dir);\n+    if (size == FSS_INVALID) {\n+      Report(\"WARNING: unexpected format specifier in printf \"\n+             \"interceptor: %.*s\\n\", dir.end - dir.begin, dir.begin);\n+      break;\n+    }\n+    if (dir.convSpecifier == 'n') {\n+      void *argp = va_arg(aq, void *);\n+      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, argp, size);\n+      continue;\n+    } else if (size == FSS_STRLEN) {\n+      if (void *argp = va_arg(aq, void *)) {\n+        if (dir.starredPrecision) {\n+          // FIXME: properly support starred precision for strings.\n+          size = 0;\n+        } else if (dir.fieldPrecision > 0) {\n+          // Won't read more than \"precision\" symbols.\n+          size = internal_strnlen((const char *)argp, dir.fieldPrecision);\n+          if (size < dir.fieldPrecision) size++;\n+        } else {\n+          // Whole string will be accessed.\n+          size = internal_strlen((const char *)argp) + 1;\n+        }\n+        COMMON_INTERCEPTOR_READ_RANGE(ctx, argp, size);\n+      }\n+    } else if (size == FSS_WCSLEN) {\n+      if (void *argp = va_arg(aq, void *)) {\n+        // FIXME: Properly support wide-character strings (via wcsrtombs).\n+        size = 0;\n+        COMMON_INTERCEPTOR_READ_RANGE(ctx, argp, size);\n+      }\n+    } else {\n+      // Skip non-pointer args\n+      SKIP_SCALAR_ARG(&aq, dir.convSpecifier, size);\n+    }\n+  }\n+}\n+\n+#endif  // SANITIZER_INTERCEPT_PRINTF"}, {"sha": "96d171a92f572fa604e65f759cf24b34f1c8e21b", "filename": "libsanitizer/sanitizer_common/sanitizer_common_interceptors_ioctl.inc", "status": "modified", "additions": 50, "deletions": 10, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_ioctl.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_ioctl.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_ioctl.inc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -12,14 +12,18 @@\n \n struct ioctl_desc {\n   unsigned req;\n-  // FIXME: support read+write arguments. Those are currently marked as WRITE.\n+  // FIXME: support read+write arguments. Currently READWRITE and WRITE do the\n+  // same thing.\n+  // XXX: The declarations below may use WRITE instead of READWRITE, unless\n+  // explicitly noted.\n   enum {\n     NONE,\n     READ,\n     WRITE,\n+    READWRITE,\n     CUSTOM\n-  } type : 2;\n-  unsigned size : 30;\n+  } type : 3;\n+  unsigned size : 29;\n   const char* name;\n };\n \n@@ -487,11 +491,15 @@ static void ioctl_init() {\n // Handle the most evil ioctls that encode argument value as part of request id.\n static unsigned ioctl_request_fixup(unsigned req) {\n #if SANITIZER_LINUX\n-  if ((req & ~0x3fff001fU) == IOCTL_EVIOCGBIT)\n+  // Strip size and event number.\n+  const unsigned kEviocgbitMask =\n+      (IOC_SIZEMASK << IOC_SIZESHIFT) | EVIOC_EV_MAX;\n+  if ((req & ~kEviocgbitMask) == IOCTL_EVIOCGBIT)\n     return IOCTL_EVIOCGBIT;\n-  if ((req & ~0x3fU) == IOCTL_EVIOCGABS)\n+  // Strip absolute axis number.\n+  if ((req & ~EVIOC_ABS_MAX) == IOCTL_EVIOCGABS)\n     return IOCTL_EVIOCGABS;\n-  if ((req & ~0x3fU) == IOCTL_EVIOCSABS)\n+  if ((req & ~EVIOC_ABS_MAX) == IOCTL_EVIOCSABS)\n     return IOCTL_EVIOCSABS;\n #endif\n   return req;\n@@ -513,24 +521,56 @@ static const ioctl_desc *ioctl_table_lookup(unsigned req) {\n     return 0;\n }\n \n+static bool ioctl_decode(unsigned req, ioctl_desc *desc) {\n+  CHECK(desc);\n+  desc->req = req;\n+  desc->name = \"<DECODED_IOCTL>\";\n+  desc->size = IOC_SIZE(req);\n+  // Sanity check.\n+  if (desc->size > 1024) return false;\n+  unsigned dir = IOC_DIR(req);\n+  switch (dir) {\n+    case IOC_NONE:\n+      desc->type = ioctl_desc::NONE;\n+      break;\n+    case IOC_READ | IOC_WRITE:\n+      desc->type = ioctl_desc::READWRITE;\n+      break;\n+    case IOC_READ:\n+      desc->type = ioctl_desc::WRITE;\n+      break;\n+    case IOC_WRITE:\n+      desc->type = ioctl_desc::READ;\n+      break;\n+    default:\n+      return false;\n+  }\n+  if (desc->type != IOC_NONE && desc->size == 0) return false;\n+  char id = IOC_TYPE(req);\n+  // Sanity check.\n+  if (!(id >= 'a' && id <= 'z') && !(id >= 'A' && id <= 'Z')) return false;\n+  return true;\n+}\n+\n static const ioctl_desc *ioctl_lookup(unsigned req) {\n   req = ioctl_request_fixup(req);\n   const ioctl_desc *desc = ioctl_table_lookup(req);\n   if (desc) return desc;\n \n   // Try stripping access size from the request id.\n-  desc = ioctl_table_lookup(req & ~0x3fff0000U);\n+  desc = ioctl_table_lookup(req & ~(IOC_SIZEMASK << IOC_SIZESHIFT));\n   // Sanity check: requests that encode access size are either read or write and\n   // have size of 0 in the table.\n   if (desc && desc->size == 0 &&\n-      (desc->type == ioctl_desc::WRITE || desc->type == ioctl_desc::READ))\n+      (desc->type == ioctl_desc::READWRITE || desc->type == ioctl_desc::WRITE ||\n+       desc->type == ioctl_desc::READ))\n     return desc;\n   return 0;\n }\n \n static void ioctl_common_pre(void *ctx, const ioctl_desc *desc, int d,\n                              unsigned request, void *arg) {\n-  if (desc->type == ioctl_desc::READ) {\n+  if (desc->type == ioctl_desc::READ || desc->type == ioctl_desc::READWRITE) {\n     unsigned size = desc->size ? desc->size : IOC_SIZE(request);\n     COMMON_INTERCEPTOR_READ_RANGE(ctx, arg, size);\n   }\n@@ -548,7 +588,7 @@ static void ioctl_common_pre(void *ctx, const ioctl_desc *desc, int d,\n \n static void ioctl_common_post(void *ctx, const ioctl_desc *desc, int res, int d,\n                               unsigned request, void *arg) {\n-  if (desc->type == ioctl_desc::WRITE) {\n+  if (desc->type == ioctl_desc::WRITE || desc->type == ioctl_desc::READWRITE) {\n     // FIXME: add verbose output\n     unsigned size = desc->size ? desc->size : IOC_SIZE(request);\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, arg, size);"}, {"sha": "2660dada2bebfa388c9af7254291866ce1379c72", "filename": "libsanitizer/sanitizer_common/sanitizer_common_interceptors_scanf.inc", "status": "removed", "additions": 0, "deletions": 309, "changes": 309, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b95591361e32a755231d99c348f8a43e2aed0187/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_scanf.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b95591361e32a755231d99c348f8a43e2aed0187/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_scanf.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_scanf.inc?ref=b95591361e32a755231d99c348f8a43e2aed0187", "patch": "@@ -1,309 +0,0 @@\n-//===-- sanitizer_common_interceptors_scanf.inc -----------------*- C++ -*-===//\n-//\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n-//\n-//===----------------------------------------------------------------------===//\n-//\n-// Scanf implementation for use in *Sanitizer interceptors.\n-// Follows http://pubs.opengroup.org/onlinepubs/9699919799/functions/fscanf.html\n-// with a few common GNU extensions.\n-//\n-//===----------------------------------------------------------------------===//\n-#include <stdarg.h>\n-\n-struct ScanfDirective {\n-  int argIdx; // argument index, or -1 of not specified (\"%n$\")\n-  int fieldWidth;\n-  bool suppressed; // suppress assignment (\"*\")\n-  bool allocate;   // allocate space (\"m\")\n-  char lengthModifier[2];\n-  char convSpecifier;\n-  bool maybeGnuMalloc;\n-};\n-\n-static const char *parse_number(const char *p, int *out) {\n-  *out = internal_atoll(p);\n-  while (*p >= '0' && *p <= '9')\n-    ++p;\n-  return p;\n-}\n-\n-static bool char_is_one_of(char c, const char *s) {\n-  return !!internal_strchr(s, c);\n-}\n-\n-// Parse scanf format string. If a valid directive in encountered, it is\n-// returned in dir. This function returns the pointer to the first\n-// unprocessed character, or 0 in case of error.\n-// In case of the end-of-string, a pointer to the closing \\0 is returned.\n-static const char *scanf_parse_next(const char *p, bool allowGnuMalloc,\n-                                    ScanfDirective *dir) {\n-  internal_memset(dir, 0, sizeof(*dir));\n-  dir->argIdx = -1;\n-\n-  while (*p) {\n-    if (*p != '%') {\n-      ++p;\n-      continue;\n-    }\n-    ++p;\n-    // %%\n-    if (*p == '%') {\n-      ++p;\n-      continue;\n-    }\n-    if (*p == '\\0') {\n-      return 0;\n-    }\n-    // %n$\n-    if (*p >= '0' && *p <= '9') {\n-      int number;\n-      const char *q = parse_number(p, &number);\n-      if (*q == '$') {\n-        dir->argIdx = number;\n-        p = q + 1;\n-      }\n-      // Otherwise, do not change p. This will be re-parsed later as the field\n-      // width.\n-    }\n-    // *\n-    if (*p == '*') {\n-      dir->suppressed = true;\n-      ++p;\n-    }\n-    // Field width.\n-    if (*p >= '0' && *p <= '9') {\n-      p = parse_number(p, &dir->fieldWidth);\n-      if (dir->fieldWidth <= 0)\n-        return 0;\n-    }\n-    // m\n-    if (*p == 'm') {\n-      dir->allocate = true;\n-      ++p;\n-    }\n-    // Length modifier.\n-    if (char_is_one_of(*p, \"jztLq\")) {\n-      dir->lengthModifier[0] = *p;\n-      ++p;\n-    } else if (*p == 'h') {\n-      dir->lengthModifier[0] = 'h';\n-      ++p;\n-      if (*p == 'h') {\n-        dir->lengthModifier[1] = 'h';\n-        ++p;\n-      }\n-    } else if (*p == 'l') {\n-      dir->lengthModifier[0] = 'l';\n-      ++p;\n-      if (*p == 'l') {\n-        dir->lengthModifier[1] = 'l';\n-        ++p;\n-      }\n-    }\n-    // Conversion specifier.\n-    dir->convSpecifier = *p++;\n-    // Consume %[...] expression.\n-    if (dir->convSpecifier == '[') {\n-      if (*p == '^')\n-        ++p;\n-      if (*p == ']')\n-        ++p;\n-      while (*p && *p != ']')\n-        ++p;\n-      if (*p == 0)\n-        return 0; // unexpected end of string\n-                  // Consume the closing ']'.\n-      ++p;\n-    }\n-    // This is unfortunately ambiguous between old GNU extension\n-    // of %as, %aS and %a[...] and newer POSIX %a followed by\n-    // letters s, S or [.\n-    if (allowGnuMalloc && dir->convSpecifier == 'a' &&\n-        !dir->lengthModifier[0]) {\n-      if (*p == 's' || *p == 'S') {\n-        dir->maybeGnuMalloc = true;\n-        ++p;\n-      } else if (*p == '[') {\n-        // Watch for %a[h-j%d], if % appears in the\n-        // [...] range, then we need to give up, we don't know\n-        // if scanf will parse it as POSIX %a [h-j %d ] or\n-        // GNU allocation of string with range dh-j plus %.\n-        const char *q = p + 1;\n-        if (*q == '^')\n-          ++q;\n-        if (*q == ']')\n-          ++q;\n-        while (*q && *q != ']' && *q != '%')\n-          ++q;\n-        if (*q == 0 || *q == '%')\n-          return 0;\n-        p = q + 1; // Consume the closing ']'.\n-        dir->maybeGnuMalloc = true;\n-      }\n-    }\n-    break;\n-  }\n-  return p;\n-}\n-\n-// Returns true if the character is an integer conversion specifier.\n-static bool scanf_is_integer_conv(char c) {\n-  return char_is_one_of(c, \"diouxXn\");\n-}\n-\n-// Returns true if the character is an floating point conversion specifier.\n-static bool scanf_is_float_conv(char c) {\n-  return char_is_one_of(c, \"aAeEfFgG\");\n-}\n-\n-// Returns string output character size for string-like conversions,\n-// or 0 if the conversion is invalid.\n-static int scanf_get_char_size(ScanfDirective *dir) {\n-  if (char_is_one_of(dir->convSpecifier, \"CS\")) {\n-    // wchar_t\n-    return 0;\n-  }\n-\n-  if (char_is_one_of(dir->convSpecifier, \"cs[\")) {\n-    if (dir->lengthModifier[0] == 'l')\n-      // wchar_t\n-      return 0;\n-    else if (dir->lengthModifier[0] == 0)\n-      return sizeof(char);\n-    else\n-      return 0;\n-  }\n-\n-  return 0;\n-}\n-\n-enum ScanfStoreSize {\n-  // Store size not known in advance; can be calculated as strlen() of the\n-  // destination buffer.\n-  SSS_STRLEN = -1,\n-  // Invalid conversion specifier.\n-  SSS_INVALID = 0\n-};\n-\n-// Returns the store size of a scanf directive (if >0), or a value of\n-// ScanfStoreSize.\n-static int scanf_get_store_size(ScanfDirective *dir) {\n-  if (dir->allocate) {\n-    if (!char_is_one_of(dir->convSpecifier, \"cCsS[\"))\n-      return SSS_INVALID;\n-    return sizeof(char *);\n-  }\n-\n-  if (dir->maybeGnuMalloc) {\n-    if (dir->convSpecifier != 'a' || dir->lengthModifier[0])\n-      return SSS_INVALID;\n-    // This is ambiguous, so check the smaller size of char * (if it is\n-    // a GNU extension of %as, %aS or %a[...]) and float (if it is\n-    // POSIX %a followed by s, S or [ letters).\n-    return sizeof(char *) < sizeof(float) ? sizeof(char *) : sizeof(float);\n-  }\n-\n-  if (scanf_is_integer_conv(dir->convSpecifier)) {\n-    switch (dir->lengthModifier[0]) {\n-    case 'h':\n-      return dir->lengthModifier[1] == 'h' ? sizeof(char) : sizeof(short);\n-    case 'l':\n-      return dir->lengthModifier[1] == 'l' ? sizeof(long long) : sizeof(long);\n-    case 'L':\n-      return sizeof(long long);\n-    case 'j':\n-      return sizeof(INTMAX_T);\n-    case 'z':\n-      return sizeof(SIZE_T);\n-    case 't':\n-      return sizeof(PTRDIFF_T);\n-    case 0:\n-      return sizeof(int);\n-    default:\n-      return SSS_INVALID;\n-    }\n-  }\n-\n-  if (scanf_is_float_conv(dir->convSpecifier)) {\n-    switch (dir->lengthModifier[0]) {\n-    case 'L':\n-    case 'q':\n-      return sizeof(long double);\n-    case 'l':\n-      return dir->lengthModifier[1] == 'l' ? sizeof(long double)\n-                                           : sizeof(double);\n-    case 0:\n-      return sizeof(float);\n-    default:\n-      return SSS_INVALID;\n-    }\n-  }\n-\n-  if (char_is_one_of(dir->convSpecifier, \"sS[\")) {\n-    unsigned charSize = scanf_get_char_size(dir);\n-    if (charSize == 0)\n-      return SSS_INVALID;\n-    if (dir->fieldWidth == 0)\n-      return SSS_STRLEN;\n-    return (dir->fieldWidth + 1) * charSize;\n-  }\n-\n-  if (char_is_one_of(dir->convSpecifier, \"cC\")) {\n-    unsigned charSize = scanf_get_char_size(dir);\n-    if (charSize == 0)\n-      return SSS_INVALID;\n-    if (dir->fieldWidth == 0)\n-      return charSize;\n-    return dir->fieldWidth * charSize;\n-  }\n-\n-  if (dir->convSpecifier == 'p') {\n-    if (dir->lengthModifier[1] != 0)\n-      return SSS_INVALID;\n-    return sizeof(void *);\n-  }\n-\n-  return SSS_INVALID;\n-}\n-\n-// Common part of *scanf interceptors.\n-// Process format string and va_list, and report all store ranges.\n-// Stops when \"consuming\" n_inputs input items.\n-static void scanf_common(void *ctx, int n_inputs, bool allowGnuMalloc,\n-                         const char *format, va_list aq) {\n-  CHECK_GT(n_inputs, 0);\n-  const char *p = format;\n-\n-  while (*p) {\n-    ScanfDirective dir;\n-    p = scanf_parse_next(p, allowGnuMalloc, &dir);\n-    if (!p)\n-      break;\n-    if (dir.convSpecifier == 0) {\n-      // This can only happen at the end of the format string.\n-      CHECK_EQ(*p, 0);\n-      break;\n-    }\n-    // Here the directive is valid. Do what it says.\n-    if (dir.argIdx != -1) {\n-      // Unsupported.\n-      break;\n-    }\n-    if (dir.suppressed)\n-      continue;\n-    int size = scanf_get_store_size(&dir);\n-    if (size == SSS_INVALID)\n-      break;\n-    void *argp = va_arg(aq, void *);\n-    if (dir.convSpecifier != 'n')\n-      --n_inputs;\n-    if (n_inputs < 0)\n-      break;\n-    if (size == SSS_STRLEN) {\n-      size = internal_strlen((const char *)argp) + 1;\n-    }\n-    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, argp, size);\n-  }\n-}"}, {"sha": "d8330630b5f6ad9a6f8ea35334cd19d1b17f1621", "filename": "libsanitizer/sanitizer_common/sanitizer_common_libcdep.cc", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_libcdep.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -10,6 +10,7 @@\n //===----------------------------------------------------------------------===//\n \n #include \"sanitizer_common.h\"\n+#include \"sanitizer_flags.h\"\n \n namespace __sanitizer {\n \n@@ -32,4 +33,10 @@ bool PrintsToTtyCached() {\n   }\n   return prints_to_tty;\n }\n+\n+bool ColorizeReports() {\n+  const char *flag = common_flags()->color;\n+  return internal_strcmp(flag, \"always\") == 0 ||\n+         (internal_strcmp(flag, \"auto\") == 0 && PrintsToTtyCached());\n+}\n }  // namespace __sanitizer"}, {"sha": "6be2f51b80acd8f0dc78ba401b737e3392e792ea", "filename": "libsanitizer/sanitizer_common/sanitizer_common_syscalls.inc", "status": "modified", "additions": 26, "deletions": 21, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_syscalls.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_syscalls.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_syscalls.inc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -232,13 +232,15 @@ POST_SYSCALL(settimeofday)(long res, void *tv, void *tz) {\n   }\n }\n \n+#if !SANITIZER_ANDROID\n PRE_SYSCALL(adjtimex)(void *txc_p) {}\n \n POST_SYSCALL(adjtimex)(long res, void *txc_p) {\n   if (res >= 0) {\n     if (txc_p) POST_WRITE(txc_p, struct_timex_sz);\n   }\n }\n+#endif\n \n PRE_SYSCALL(times)(void *tbuf) {}\n \n@@ -384,24 +386,21 @@ PRE_SYSCALL(acct)(const void *name) {\n \n POST_SYSCALL(acct)(long res, const void *name) {}\n \n-PRE_SYSCALL(capget)(void *header, void *dataptr) {}\n+PRE_SYSCALL(capget)(void *header, void *dataptr) {\n+  if (header) PRE_READ(header, __user_cap_header_struct_sz);\n+}\n \n POST_SYSCALL(capget)(long res, void *header, void *dataptr) {\n-  if (res >= 0) {\n-    if (header) POST_WRITE(header, __user_cap_header_struct_sz);\n+  if (res >= 0)\n     if (dataptr) POST_WRITE(dataptr, __user_cap_data_struct_sz);\n-  }\n }\n \n PRE_SYSCALL(capset)(void *header, const void *data) {\n+  if (header) PRE_READ(header, __user_cap_header_struct_sz);\n   if (data) PRE_READ(data, __user_cap_data_struct_sz);\n }\n \n-POST_SYSCALL(capset)(long res, void *header, const void *data) {\n-  if (res >= 0) {\n-    if (header) POST_WRITE(header, __user_cap_header_struct_sz);\n-  }\n-}\n+POST_SYSCALL(capset)(long res, void *header, const void *data) {}\n \n PRE_SYSCALL(personality)(long personality) {}\n \n@@ -494,13 +493,15 @@ POST_SYSCALL(clock_gettime)(long res, long which_clock, void *tp) {\n   }\n }\n \n+#if !SANITIZER_ANDROID\n PRE_SYSCALL(clock_adjtime)(long which_clock, void *tx) {}\n \n POST_SYSCALL(clock_adjtime)(long res, long which_clock, void *tx) {\n   if (res >= 0) {\n     if (tx) POST_WRITE(tx, struct_timex_sz);\n   }\n }\n+#endif\n \n PRE_SYSCALL(clock_getres)(long which_clock, void *tp) {}\n \n@@ -918,13 +919,15 @@ POST_SYSCALL(newfstat)(long res, long fd, void *statbuf) {\n   }\n }\n \n+#if !SANITIZER_ANDROID\n PRE_SYSCALL(ustat)(long dev, void *ubuf) {}\n \n POST_SYSCALL(ustat)(long res, long dev, void *ubuf) {\n   if (res >= 0) {\n     if (ubuf) POST_WRITE(ubuf, struct_ustat_sz);\n   }\n }\n+#endif  // !SANITIZER_ANDROID\n \n PRE_SYSCALL(stat64)(const void *filename, void *statbuf) {\n   if (filename)\n@@ -1002,8 +1005,8 @@ PRE_SYSCALL(getxattr)(const void *path, const void *name, void *value,\n \n POST_SYSCALL(getxattr)(long res, const void *path, const void *name,\n                        void *value, long size) {\n-  if (res >= 0) {\n-    if (value) POST_WRITE(value, size);\n+  if (size && res > 0) {\n+    if (value) POST_WRITE(value, res);\n   }\n }\n \n@@ -1017,8 +1020,8 @@ PRE_SYSCALL(lgetxattr)(const void *path, const void *name, void *value,\n \n POST_SYSCALL(lgetxattr)(long res, const void *path, const void *name,\n                         void *value, long size) {\n-  if (res >= 0) {\n-    if (value) POST_WRITE(value, size);\n+  if (size && res > 0) {\n+    if (value) POST_WRITE(value, res);\n   }\n }\n \n@@ -1029,8 +1032,8 @@ PRE_SYSCALL(fgetxattr)(long fd, const void *name, void *value, long size) {\n \n POST_SYSCALL(fgetxattr)(long res, long fd, const void *name, void *value,\n                         long size) {\n-  if (res >= 0) {\n-    if (value) POST_WRITE(value, size);\n+  if (size && res > 0) {\n+    if (value) POST_WRITE(value, res);\n   }\n }\n \n@@ -1040,8 +1043,8 @@ PRE_SYSCALL(listxattr)(const void *path, void *list, long size) {\n }\n \n POST_SYSCALL(listxattr)(long res, const void *path, void *list, long size) {\n-  if (res >= 0) {\n-    if (list) POST_WRITE(list, size);\n+  if (size && res > 0) {\n+    if (list) POST_WRITE(list, res);\n   }\n }\n \n@@ -1051,16 +1054,16 @@ PRE_SYSCALL(llistxattr)(const void *path, void *list, long size) {\n }\n \n POST_SYSCALL(llistxattr)(long res, const void *path, void *list, long size) {\n-  if (res >= 0) {\n-    if (list) POST_WRITE(list, size);\n+  if (size && res > 0) {\n+    if (list) POST_WRITE(list, res);\n   }\n }\n \n PRE_SYSCALL(flistxattr)(long fd, void *list, long size) {}\n \n POST_SYSCALL(flistxattr)(long res, long fd, void *list, long size) {\n-  if (res >= 0) {\n-    if (list) POST_WRITE(list, size);\n+  if (size && res > 0) {\n+    if (list) POST_WRITE(list, res);\n   }\n }\n \n@@ -2080,13 +2083,15 @@ POST_SYSCALL(msgrcv)(long res, long msqid, void *msgp, long msgsz, long msgtyp,\n   }\n }\n \n+#if !SANITIZER_ANDROID\n PRE_SYSCALL(msgctl)(long msqid, long cmd, void *buf) {}\n \n POST_SYSCALL(msgctl)(long res, long msqid, long cmd, void *buf) {\n   if (res >= 0) {\n     if (buf) POST_WRITE(buf, struct_msqid_ds_sz);\n   }\n }\n+#endif\n \n PRE_SYSCALL(semget)(long key, long nsems, long semflg) {}\n "}, {"sha": "b88e9e7ed0a8eef9ed66bb1440c0e4db5b92d3af", "filename": "libsanitizer/sanitizer_common/sanitizer_coverage.cc", "status": "modified", "additions": 134, "deletions": 31, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -9,15 +9,15 @@\n // This file implements run-time support for a poor man's coverage tool.\n //\n // Compiler instrumentation:\n-// For every function F the compiler injects the following code:\n+// For every interesting basic block the compiler injects the following code:\n // if (*Guard) {\n-//    __sanitizer_cov(&F);\n+//    __sanitizer_cov();\n //    *Guard = 1;\n // }\n-// It's fine to call __sanitizer_cov more than once for a given function.\n+// It's fine to call __sanitizer_cov more than once for a given block.\n //\n // Run-time:\n-//  - __sanitizer_cov(pc): record that we've executed a given PC.\n+//  - __sanitizer_cov(): record that we've executed the PC (GET_CALLER_PC).\n //  - __sanitizer_cov_dump: dump the coverage data to disk.\n //  For every module of the current process that has coverage data\n //  this will create a file module_name.PID.sancov. The file format is simple:\n@@ -35,40 +35,103 @@\n #include \"sanitizer_libc.h\"\n #include \"sanitizer_mutex.h\"\n #include \"sanitizer_procmaps.h\"\n+#include \"sanitizer_stacktrace.h\"\n #include \"sanitizer_flags.h\"\n \n-struct CovData {\n-  BlockingMutex mu;\n-  InternalMmapVector<uptr> v;\n-};\n+atomic_uint32_t dump_once_guard;  // Ensure that CovDump runs only once.\n+\n+// pc_array is the array containing the covered PCs.\n+// To make the pc_array thread- and async-signal-safe it has to be large enough.\n+// 128M counters \"ought to be enough for anybody\" (4M on 32-bit).\n+// pc_array is allocated with MmapNoReserveOrDie and so it uses only as\n+// much RAM as it really needs.\n+static const uptr kPcArraySize = FIRST_32_SECOND_64(1 << 22, 1 << 27);\n+static uptr *pc_array;\n+static atomic_uintptr_t pc_array_index;\n \n-static uptr cov_data_placeholder[sizeof(CovData) / sizeof(uptr)];\n-COMPILER_CHECK(sizeof(cov_data_placeholder) >= sizeof(CovData));\n-static CovData *cov_data = reinterpret_cast<CovData*>(cov_data_placeholder);\n+static bool cov_sandboxed = false;\n+static int cov_fd = kInvalidFd;\n+static unsigned int cov_max_block_size = 0;\n \n namespace __sanitizer {\n \n // Simply add the pc into the vector under lock. If the function is called more\n // than once for a given PC it will be inserted multiple times, which is fine.\n static void CovAdd(uptr pc) {\n-  BlockingMutexLock lock(&cov_data->mu);\n-  cov_data->v.push_back(pc);\n+  if (!pc_array) return;\n+  uptr idx = atomic_fetch_add(&pc_array_index, 1, memory_order_relaxed);\n+  CHECK_LT(idx, kPcArraySize);\n+  pc_array[idx] = pc;\n+}\n+\n+void CovInit() {\n+  pc_array = reinterpret_cast<uptr *>(\n+      MmapNoReserveOrDie(sizeof(uptr) * kPcArraySize, \"CovInit\"));\n }\n \n static inline bool CompareLess(const uptr &a, const uptr &b) {\n   return a < b;\n }\n \n+// Block layout for packed file format: header, followed by module name (no\n+// trailing zero), followed by data blob.\n+struct CovHeader {\n+  int pid;\n+  unsigned int module_name_length;\n+  unsigned int data_length;\n+};\n+\n+static void CovWritePacked(int pid, const char *module, const void *blob,\n+                           unsigned int blob_size) {\n+  CHECK_GE(cov_fd, 0);\n+  unsigned module_name_length = internal_strlen(module);\n+  CovHeader header = {pid, module_name_length, blob_size};\n+\n+  if (cov_max_block_size == 0) {\n+    // Writing to a file. Just go ahead.\n+    internal_write(cov_fd, &header, sizeof(header));\n+    internal_write(cov_fd, module, module_name_length);\n+    internal_write(cov_fd, blob, blob_size);\n+  } else {\n+    // Writing to a socket. We want to split the data into appropriately sized\n+    // blocks.\n+    InternalScopedBuffer<char> block(cov_max_block_size);\n+    CHECK_EQ((uptr)block.data(), (uptr)(CovHeader *)block.data());\n+    uptr header_size_with_module = sizeof(header) + module_name_length;\n+    CHECK_LT(header_size_with_module, cov_max_block_size);\n+    unsigned int max_payload_size =\n+        cov_max_block_size - header_size_with_module;\n+    char *block_pos = block.data();\n+    internal_memcpy(block_pos, &header, sizeof(header));\n+    block_pos += sizeof(header);\n+    internal_memcpy(block_pos, module, module_name_length);\n+    block_pos += module_name_length;\n+    char *block_data_begin = block_pos;\n+    char *blob_pos = (char *)blob;\n+    while (blob_size > 0) {\n+      unsigned int payload_size = Min(blob_size, max_payload_size);\n+      blob_size -= payload_size;\n+      internal_memcpy(block_data_begin, blob_pos, payload_size);\n+      blob_pos += payload_size;\n+      ((CovHeader *)block.data())->data_length = payload_size;\n+      internal_write(cov_fd, block.data(),\n+                     header_size_with_module + payload_size);\n+    }\n+  }\n+}\n+\n // Dump the coverage on disk.\n-void CovDump() {\n+static void CovDump() {\n+  if (!common_flags()->coverage) return;\n #if !SANITIZER_WINDOWS\n-  BlockingMutexLock lock(&cov_data->mu);\n-  InternalMmapVector<uptr> &v = cov_data->v;\n-  InternalSort(&v, v.size(), CompareLess);\n-  InternalMmapVector<u32> offsets(v.size());\n-  const uptr *vb = v.data();\n-  const uptr *ve = vb + v.size();\n-  MemoryMappingLayout proc_maps(/*cache_enabled*/false);\n+  if (atomic_fetch_add(&dump_once_guard, 1, memory_order_relaxed))\n+    return;\n+  uptr size = atomic_load(&pc_array_index, memory_order_relaxed);\n+  InternalSort(&pc_array, size, CompareLess);\n+  InternalMmapVector<u32> offsets(size);\n+  const uptr *vb = pc_array;\n+  const uptr *ve = vb + size;\n+  MemoryMappingLayout proc_maps(/*cache_enabled*/true);\n   uptr mb, me, off, prot;\n   InternalScopedBuffer<char> module(4096);\n   InternalScopedBuffer<char> path(4096 * 2);\n@@ -77,8 +140,9 @@ void CovDump() {\n        i++) {\n     if ((prot & MemoryMappingLayout::kProtectionExecute) == 0)\n       continue;\n+    while (vb < ve && *vb < mb) vb++;\n     if (vb >= ve) break;\n-    if (mb <= *vb && *vb < me) {\n+    if (*vb < me) {\n       offsets.clear();\n       const uptr *old_vb = vb;\n       CHECK_LE(off, *vb);\n@@ -88,24 +152,63 @@ void CovDump() {\n         offsets.push_back(static_cast<u32>(diff));\n       }\n       char *module_name = StripModuleName(module.data());\n-      internal_snprintf((char *)path.data(), path.size(), \"%s.%zd.sancov\",\n-                        module_name, internal_getpid());\n+      if (cov_sandboxed) {\n+        CovWritePacked(internal_getpid(), module_name, offsets.data(),\n+                       offsets.size() * sizeof(u32));\n+        VReport(1, \" CovDump: %zd PCs written to packed file\\n\", vb - old_vb);\n+      } else {\n+        // One file per module per process.\n+        internal_snprintf((char *)path.data(), path.size(), \"%s.%zd.sancov\",\n+                          module_name, internal_getpid());\n+        uptr fd = OpenFile(path.data(), true);\n+        if (internal_iserror(fd)) {\n+          Report(\" CovDump: failed to open %s for writing\\n\", path.data());\n+        } else {\n+          internal_write(fd, offsets.data(), offsets.size() * sizeof(u32));\n+          internal_close(fd);\n+          VReport(1, \" CovDump: %s: %zd PCs written\\n\", path.data(),\n+                  vb - old_vb);\n+        }\n+      }\n       InternalFree(module_name);\n-      uptr fd = OpenFile(path.data(), true);\n-      internal_write(fd, offsets.data(), offsets.size() * sizeof(u32));\n-      internal_close(fd);\n-      if (common_flags()->verbosity)\n-        Report(\" CovDump: %s: %zd PCs written\\n\", path.data(), vb - old_vb);\n     }\n   }\n+  if (cov_fd >= 0)\n+    internal_close(cov_fd);\n #endif  // !SANITIZER_WINDOWS\n }\n \n+static void OpenPackedFileForWriting() {\n+  CHECK(cov_fd == kInvalidFd);\n+  InternalScopedBuffer<char> path(1024);\n+  internal_snprintf((char *)path.data(), path.size(), \"%zd.sancov.packed\",\n+                    internal_getpid());\n+  uptr fd = OpenFile(path.data(), true);\n+  if (internal_iserror(fd)) {\n+    Report(\" Coverage: failed to open %s for writing\\n\", path.data());\n+    Die();\n+  }\n+  cov_fd = fd;\n+}\n+\n+void CovPrepareForSandboxing(__sanitizer_sandbox_arguments *args) {\n+  if (!args) return;\n+  if (!common_flags()->coverage) return;\n+  cov_sandboxed = args->coverage_sandboxed;\n+  if (!cov_sandboxed) return;\n+  cov_fd = args->coverage_fd;\n+  cov_max_block_size = args->coverage_max_block_size;\n+  if (cov_fd < 0)\n+    // Pre-open the file now. The sandbox won't allow us to do it later.\n+    OpenPackedFileForWriting();\n+}\n+\n }  // namespace __sanitizer\n \n extern \"C\" {\n-SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_cov(void *pc) {\n-  CovAdd(reinterpret_cast<uptr>(pc));\n+SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_cov() {\n+  CovAdd(StackTrace::GetPreviousInstructionPc(GET_CALLER_PC()));\n }\n SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_cov_dump() { CovDump(); }\n+SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_cov_init() { CovInit(); }\n }  // extern \"C\""}, {"sha": "949c486a14acc6386649f6dc349b759d5f29686e", "filename": "libsanitizer/sanitizer_common/sanitizer_deadlock_detector.h", "status": "added", "additions": 410, "deletions": 0, "changes": 410, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_deadlock_detector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_deadlock_detector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_deadlock_detector.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -0,0 +1,410 @@\n+//===-- sanitizer_deadlock_detector.h ---------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of Sanitizer runtime.\n+// The deadlock detector maintains a directed graph of lock acquisitions.\n+// When a lock event happens, the detector checks if the locks already held by\n+// the current thread are reachable from the newly acquired lock.\n+//\n+// The detector can handle only a fixed amount of simultaneously live locks\n+// (a lock is alive if it has been locked at least once and has not been\n+// destroyed). When the maximal number of locks is reached the entire graph\n+// is flushed and the new lock epoch is started. The node ids from the old\n+// epochs can not be used with any of the detector methods except for\n+// nodeBelongsToCurrentEpoch().\n+//\n+// FIXME: this is work in progress, nothing really works yet.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef SANITIZER_DEADLOCK_DETECTOR_H\n+#define SANITIZER_DEADLOCK_DETECTOR_H\n+\n+#include \"sanitizer_common.h\"\n+#include \"sanitizer_bvgraph.h\"\n+\n+namespace __sanitizer {\n+\n+// Thread-local state for DeadlockDetector.\n+// It contains the locks currently held by the owning thread.\n+template <class BV>\n+class DeadlockDetectorTLS {\n+ public:\n+  // No CTOR.\n+  void clear() {\n+    bv_.clear();\n+    epoch_ = 0;\n+    n_recursive_locks = 0;\n+    n_all_locks_ = 0;\n+  }\n+\n+  bool empty() const { return bv_.empty(); }\n+\n+  void ensureCurrentEpoch(uptr current_epoch) {\n+    if (epoch_ == current_epoch) return;\n+    bv_.clear();\n+    epoch_ = current_epoch;\n+  }\n+\n+  uptr getEpoch() const { return epoch_; }\n+\n+  // Returns true if this is the first (non-recursive) acquisition of this lock.\n+  bool addLock(uptr lock_id, uptr current_epoch, u32 stk) {\n+    // Printf(\"addLock: %zx %zx stk %u\\n\", lock_id, current_epoch, stk);\n+    CHECK_EQ(epoch_, current_epoch);\n+    if (!bv_.setBit(lock_id)) {\n+      // The lock is already held by this thread, it must be recursive.\n+      CHECK_LT(n_recursive_locks, ARRAY_SIZE(recursive_locks));\n+      recursive_locks[n_recursive_locks++] = lock_id;\n+      return false;\n+    }\n+    CHECK_LT(n_all_locks_, ARRAY_SIZE(all_locks_with_contexts_));\n+    // lock_id < BV::kSize, can cast to a smaller int.\n+    u32 lock_id_short = static_cast<u32>(lock_id);\n+    LockWithContext l = {lock_id_short, stk};\n+    all_locks_with_contexts_[n_all_locks_++] = l;\n+    return true;\n+  }\n+\n+  void removeLock(uptr lock_id) {\n+    if (n_recursive_locks) {\n+      for (sptr i = n_recursive_locks - 1; i >= 0; i--) {\n+        if (recursive_locks[i] == lock_id) {\n+          n_recursive_locks--;\n+          Swap(recursive_locks[i], recursive_locks[n_recursive_locks]);\n+          return;\n+        }\n+      }\n+    }\n+    // Printf(\"remLock: %zx %zx\\n\", lock_id, epoch_);\n+    CHECK(bv_.clearBit(lock_id));\n+    if (n_all_locks_) {\n+      for (sptr i = n_all_locks_ - 1; i >= 0; i--) {\n+        if (all_locks_with_contexts_[i].lock == static_cast<u32>(lock_id)) {\n+          Swap(all_locks_with_contexts_[i],\n+               all_locks_with_contexts_[n_all_locks_ - 1]);\n+          n_all_locks_--;\n+          break;\n+        }\n+      }\n+    }\n+  }\n+\n+  u32 findLockContext(uptr lock_id) {\n+    for (uptr i = 0; i < n_all_locks_; i++)\n+      if (all_locks_with_contexts_[i].lock == static_cast<u32>(lock_id))\n+        return all_locks_with_contexts_[i].stk;\n+    return 0;\n+  }\n+\n+  const BV &getLocks(uptr current_epoch) const {\n+    CHECK_EQ(epoch_, current_epoch);\n+    return bv_;\n+  }\n+\n+  uptr getNumLocks() const { return n_all_locks_; }\n+  uptr getLock(uptr idx) const { return all_locks_with_contexts_[idx].lock; }\n+\n+ private:\n+  BV bv_;\n+  uptr epoch_;\n+  uptr recursive_locks[64];\n+  uptr n_recursive_locks;\n+  struct LockWithContext {\n+    u32 lock;\n+    u32 stk;\n+  };\n+  LockWithContext all_locks_with_contexts_[64];\n+  uptr n_all_locks_;\n+};\n+\n+// DeadlockDetector.\n+// For deadlock detection to work we need one global DeadlockDetector object\n+// and one DeadlockDetectorTLS object per evey thread.\n+// This class is not thread safe, all concurrent accesses should be guarded\n+// by an external lock.\n+// Most of the methods of this class are not thread-safe (i.e. should\n+// be protected by an external lock) unless explicitly told otherwise.\n+template <class BV>\n+class DeadlockDetector {\n+ public:\n+  typedef BV BitVector;\n+\n+  uptr size() const { return g_.size(); }\n+\n+  // No CTOR.\n+  void clear() {\n+    current_epoch_ = 0;\n+    available_nodes_.clear();\n+    recycled_nodes_.clear();\n+    g_.clear();\n+    n_edges_ = 0;\n+  }\n+\n+  // Allocate new deadlock detector node.\n+  // If we are out of available nodes first try to recycle some.\n+  // If there is nothing to recycle, flush the graph and increment the epoch.\n+  // Associate 'data' (opaque user's object) with the new node.\n+  uptr newNode(uptr data) {\n+    if (!available_nodes_.empty())\n+      return getAvailableNode(data);\n+    if (!recycled_nodes_.empty()) {\n+      // Printf(\"recycling: n_edges_ %zd\\n\", n_edges_);\n+      for (sptr i = n_edges_ - 1; i >= 0; i--) {\n+        if (recycled_nodes_.getBit(edges_[i].from) ||\n+            recycled_nodes_.getBit(edges_[i].to)) {\n+          Swap(edges_[i], edges_[n_edges_ - 1]);\n+          n_edges_--;\n+        }\n+      }\n+      CHECK(available_nodes_.empty());\n+      // removeEdgesFrom was called in removeNode.\n+      g_.removeEdgesTo(recycled_nodes_);\n+      available_nodes_.setUnion(recycled_nodes_);\n+      recycled_nodes_.clear();\n+      return getAvailableNode(data);\n+    }\n+    // We are out of vacant nodes. Flush and increment the current_epoch_.\n+    current_epoch_ += size();\n+    recycled_nodes_.clear();\n+    available_nodes_.setAll();\n+    g_.clear();\n+    return getAvailableNode(data);\n+  }\n+\n+  // Get data associated with the node created by newNode().\n+  uptr getData(uptr node) const { return data_[nodeToIndex(node)]; }\n+\n+  bool nodeBelongsToCurrentEpoch(uptr node) {\n+    return node && (node / size() * size()) == current_epoch_;\n+  }\n+\n+  void removeNode(uptr node) {\n+    uptr idx = nodeToIndex(node);\n+    CHECK(!available_nodes_.getBit(idx));\n+    CHECK(recycled_nodes_.setBit(idx));\n+    g_.removeEdgesFrom(idx);\n+  }\n+\n+  void ensureCurrentEpoch(DeadlockDetectorTLS<BV> *dtls) {\n+    dtls->ensureCurrentEpoch(current_epoch_);\n+  }\n+\n+  // Returns true if there is a cycle in the graph after this lock event.\n+  // Ideally should be called before the lock is acquired so that we can\n+  // report a deadlock before a real deadlock happens.\n+  bool onLockBefore(DeadlockDetectorTLS<BV> *dtls, uptr cur_node) {\n+    ensureCurrentEpoch(dtls);\n+    uptr cur_idx = nodeToIndex(cur_node);\n+    return g_.isReachable(cur_idx, dtls->getLocks(current_epoch_));\n+  }\n+\n+  u32 findLockContext(DeadlockDetectorTLS<BV> *dtls, uptr node) {\n+    return dtls->findLockContext(nodeToIndex(node));\n+  }\n+\n+  // Add cur_node to the set of locks held currently by dtls.\n+  void onLockAfter(DeadlockDetectorTLS<BV> *dtls, uptr cur_node, u32 stk = 0) {\n+    ensureCurrentEpoch(dtls);\n+    uptr cur_idx = nodeToIndex(cur_node);\n+    dtls->addLock(cur_idx, current_epoch_, stk);\n+  }\n+\n+  // Experimental *racy* fast path function.\n+  // Returns true if all edges from the currently held locks to cur_node exist.\n+  bool hasAllEdges(DeadlockDetectorTLS<BV> *dtls, uptr cur_node) {\n+    uptr local_epoch = dtls->getEpoch();\n+    // Read from current_epoch_ is racy.\n+    if (cur_node && local_epoch == current_epoch_ &&\n+        local_epoch == nodeToEpoch(cur_node)) {\n+      uptr cur_idx = nodeToIndexUnchecked(cur_node);\n+      for (uptr i = 0, n = dtls->getNumLocks(); i < n; i++) {\n+        if (!g_.hasEdge(dtls->getLock(i), cur_idx))\n+          return false;\n+      }\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  // Adds edges from currently held locks to cur_node,\n+  // returns the number of added edges, and puts the sources of added edges\n+  // into added_edges[].\n+  // Should be called before onLockAfter.\n+  uptr addEdges(DeadlockDetectorTLS<BV> *dtls, uptr cur_node, u32 stk,\n+                int unique_tid) {\n+    ensureCurrentEpoch(dtls);\n+    uptr cur_idx = nodeToIndex(cur_node);\n+    uptr added_edges[40];\n+    uptr n_added_edges = g_.addEdges(dtls->getLocks(current_epoch_), cur_idx,\n+                                     added_edges, ARRAY_SIZE(added_edges));\n+    for (uptr i = 0; i < n_added_edges; i++) {\n+      if (n_edges_ < ARRAY_SIZE(edges_)) {\n+        Edge e = {(u16)added_edges[i], (u16)cur_idx,\n+                  dtls->findLockContext(added_edges[i]), stk,\n+                  unique_tid};\n+        edges_[n_edges_++] = e;\n+      }\n+      // Printf(\"Edge%zd: %u %zd=>%zd in T%d\\n\",\n+      //        n_edges_, stk, added_edges[i], cur_idx, unique_tid);\n+    }\n+    return n_added_edges;\n+  }\n+\n+  bool findEdge(uptr from_node, uptr to_node, u32 *stk_from, u32 *stk_to,\n+                int *unique_tid) {\n+    uptr from_idx = nodeToIndex(from_node);\n+    uptr to_idx = nodeToIndex(to_node);\n+    for (uptr i = 0; i < n_edges_; i++) {\n+      if (edges_[i].from == from_idx && edges_[i].to == to_idx) {\n+        *stk_from = edges_[i].stk_from;\n+        *stk_to = edges_[i].stk_to;\n+        *unique_tid = edges_[i].unique_tid;\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  // Test-only function. Handles the before/after lock events,\n+  // returns true if there is a cycle.\n+  bool onLock(DeadlockDetectorTLS<BV> *dtls, uptr cur_node, u32 stk = 0) {\n+    ensureCurrentEpoch(dtls);\n+    bool is_reachable = !isHeld(dtls, cur_node) && onLockBefore(dtls, cur_node);\n+    addEdges(dtls, cur_node, stk, 0);\n+    onLockAfter(dtls, cur_node, stk);\n+    return is_reachable;\n+  }\n+\n+  // Handles the try_lock event, returns false.\n+  // When a try_lock event happens (i.e. a try_lock call succeeds) we need\n+  // to add this lock to the currently held locks, but we should not try to\n+  // change the lock graph or to detect a cycle.  We may want to investigate\n+  // whether a more aggressive strategy is possible for try_lock.\n+  bool onTryLock(DeadlockDetectorTLS<BV> *dtls, uptr cur_node, u32 stk = 0) {\n+    ensureCurrentEpoch(dtls);\n+    uptr cur_idx = nodeToIndex(cur_node);\n+    dtls->addLock(cur_idx, current_epoch_, stk);\n+    return false;\n+  }\n+\n+  // Returns true iff dtls is empty (no locks are currently held) and we can\n+  // add the node to the currently held locks w/o chanding the global state.\n+  // This operation is thread-safe as it only touches the dtls.\n+  bool onFirstLock(DeadlockDetectorTLS<BV> *dtls, uptr node, u32 stk = 0) {\n+    if (!dtls->empty()) return false;\n+    if (dtls->getEpoch() && dtls->getEpoch() == nodeToEpoch(node)) {\n+      dtls->addLock(nodeToIndexUnchecked(node), nodeToEpoch(node), stk);\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  // Finds a path between the lock 'cur_node' (currently not held in dtls)\n+  // and some currently held lock, returns the length of the path\n+  // or 0 on failure.\n+  uptr findPathToLock(DeadlockDetectorTLS<BV> *dtls, uptr cur_node, uptr *path,\n+                      uptr path_size) {\n+    tmp_bv_.copyFrom(dtls->getLocks(current_epoch_));\n+    uptr idx = nodeToIndex(cur_node);\n+    CHECK(!tmp_bv_.getBit(idx));\n+    uptr res = g_.findShortestPath(idx, tmp_bv_, path, path_size);\n+    for (uptr i = 0; i < res; i++)\n+      path[i] = indexToNode(path[i]);\n+    if (res)\n+      CHECK_EQ(path[0], cur_node);\n+    return res;\n+  }\n+\n+  // Handle the unlock event.\n+  // This operation is thread-safe as it only touches the dtls.\n+  void onUnlock(DeadlockDetectorTLS<BV> *dtls, uptr node) {\n+    if (dtls->getEpoch() == nodeToEpoch(node))\n+      dtls->removeLock(nodeToIndexUnchecked(node));\n+  }\n+\n+  // Tries to handle the lock event w/o writing to global state.\n+  // Returns true on success.\n+  // This operation is thread-safe as it only touches the dtls\n+  // (modulo racy nature of hasAllEdges).\n+  bool onLockFast(DeadlockDetectorTLS<BV> *dtls, uptr node, u32 stk = 0) {\n+    if (hasAllEdges(dtls, node)) {\n+      dtls->addLock(nodeToIndexUnchecked(node), nodeToEpoch(node), stk);\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  bool isHeld(DeadlockDetectorTLS<BV> *dtls, uptr node) const {\n+    return dtls->getLocks(current_epoch_).getBit(nodeToIndex(node));\n+  }\n+\n+  uptr testOnlyGetEpoch() const { return current_epoch_; }\n+  bool testOnlyHasEdge(uptr l1, uptr l2) {\n+    return g_.hasEdge(nodeToIndex(l1), nodeToIndex(l2));\n+  }\n+  // idx1 and idx2 are raw indices to g_, not lock IDs.\n+  bool testOnlyHasEdgeRaw(uptr idx1, uptr idx2) {\n+    return g_.hasEdge(idx1, idx2);\n+  }\n+\n+  void Print() {\n+    for (uptr from = 0; from < size(); from++)\n+      for (uptr to = 0; to < size(); to++)\n+        if (g_.hasEdge(from, to))\n+          Printf(\"  %zx => %zx\\n\", from, to);\n+  }\n+\n+ private:\n+  void check_idx(uptr idx) const { CHECK_LT(idx, size()); }\n+\n+  void check_node(uptr node) const {\n+    CHECK_GE(node, size());\n+    CHECK_EQ(current_epoch_, nodeToEpoch(node));\n+  }\n+\n+  uptr indexToNode(uptr idx) const {\n+    check_idx(idx);\n+    return idx + current_epoch_;\n+  }\n+\n+  uptr nodeToIndexUnchecked(uptr node) const { return node % size(); }\n+\n+  uptr nodeToIndex(uptr node) const {\n+    check_node(node);\n+    return nodeToIndexUnchecked(node);\n+  }\n+\n+  uptr nodeToEpoch(uptr node) const { return node / size() * size(); }\n+\n+  uptr getAvailableNode(uptr data) {\n+    uptr idx = available_nodes_.getAndClearFirstOne();\n+    data_[idx] = data;\n+    return indexToNode(idx);\n+  }\n+\n+  struct Edge {\n+    u16 from;\n+    u16 to;\n+    u32 stk_from;\n+    u32 stk_to;\n+    int unique_tid;\n+  };\n+\n+  uptr current_epoch_;\n+  BV available_nodes_;\n+  BV recycled_nodes_;\n+  BV tmp_bv_;\n+  BVGraph<BV> g_;\n+  uptr data_[BV::kSize];\n+  Edge edges_[BV::kSize * 32];\n+  uptr n_edges_;\n+};\n+\n+} // namespace __sanitizer\n+\n+#endif // SANITIZER_DEADLOCK_DETECTOR_H"}, {"sha": "fc6f5dcfbb4e7932964a1e57aa81dfdaaf02c955", "filename": "libsanitizer/sanitizer_common/sanitizer_deadlock_detector1.cc", "status": "added", "additions": 187, "deletions": 0, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_deadlock_detector1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_deadlock_detector1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_deadlock_detector1.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -0,0 +1,187 @@\n+//===-- sanitizer_deadlock_detector1.cc -----------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Deadlock detector implementation based on NxN adjacency bit matrix.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_deadlock_detector_interface.h\"\n+#include \"sanitizer_deadlock_detector.h\"\n+#include \"sanitizer_allocator_internal.h\"\n+#include \"sanitizer_placement_new.h\"\n+#include \"sanitizer_mutex.h\"\n+\n+#if SANITIZER_DEADLOCK_DETECTOR_VERSION == 1\n+\n+namespace __sanitizer {\n+\n+typedef TwoLevelBitVector<> DDBV;  // DeadlockDetector's bit vector.\n+\n+struct DDPhysicalThread {\n+};\n+\n+struct DDLogicalThread {\n+  u64 ctx;\n+  DeadlockDetectorTLS<DDBV> dd;\n+  DDReport rep;\n+  bool report_pending;\n+};\n+\n+struct DD : public DDetector {\n+  SpinMutex mtx;\n+  DeadlockDetector<DDBV> dd;\n+  DDFlags flags;\n+\n+  explicit DD(const DDFlags *flags);\n+\n+  DDPhysicalThread* CreatePhysicalThread();\n+  void DestroyPhysicalThread(DDPhysicalThread *pt);\n+\n+  DDLogicalThread* CreateLogicalThread(u64 ctx);\n+  void DestroyLogicalThread(DDLogicalThread *lt);\n+\n+  void MutexInit(DDCallback *cb, DDMutex *m);\n+  void MutexBeforeLock(DDCallback *cb, DDMutex *m, bool wlock);\n+  void MutexAfterLock(DDCallback *cb, DDMutex *m, bool wlock, bool trylock);\n+  void MutexBeforeUnlock(DDCallback *cb, DDMutex *m, bool wlock);\n+  void MutexDestroy(DDCallback *cb, DDMutex *m);\n+\n+  DDReport *GetReport(DDCallback *cb);\n+\n+  void MutexEnsureID(DDLogicalThread *lt, DDMutex *m);\n+  void ReportDeadlock(DDCallback *cb, DDMutex *m);\n+};\n+\n+DDetector *DDetector::Create(const DDFlags *flags) {\n+  (void)flags;\n+  void *mem = MmapOrDie(sizeof(DD), \"deadlock detector\");\n+  return new(mem) DD(flags);\n+}\n+\n+DD::DD(const DDFlags *flags)\n+    : flags(*flags) {\n+  dd.clear();\n+}\n+\n+DDPhysicalThread* DD::CreatePhysicalThread() {\n+  return 0;\n+}\n+\n+void DD::DestroyPhysicalThread(DDPhysicalThread *pt) {\n+}\n+\n+DDLogicalThread* DD::CreateLogicalThread(u64 ctx) {\n+  DDLogicalThread *lt = (DDLogicalThread*)InternalAlloc(sizeof(*lt));\n+  lt->ctx = ctx;\n+  lt->dd.clear();\n+  lt->report_pending = false;\n+  return lt;\n+}\n+\n+void DD::DestroyLogicalThread(DDLogicalThread *lt) {\n+  lt->~DDLogicalThread();\n+  InternalFree(lt);\n+}\n+\n+void DD::MutexInit(DDCallback *cb, DDMutex *m) {\n+  m->id = 0;\n+  m->stk = cb->Unwind();\n+}\n+\n+void DD::MutexEnsureID(DDLogicalThread *lt, DDMutex *m) {\n+  if (!dd.nodeBelongsToCurrentEpoch(m->id))\n+    m->id = dd.newNode(reinterpret_cast<uptr>(m));\n+  dd.ensureCurrentEpoch(&lt->dd);\n+}\n+\n+void DD::MutexBeforeLock(DDCallback *cb,\n+    DDMutex *m, bool wlock) {\n+  DDLogicalThread *lt = cb->lt;\n+  if (lt->dd.empty()) return;  // This will be the first lock held by lt.\n+  if (dd.hasAllEdges(&lt->dd, m->id)) return;  // We already have all edges.\n+  SpinMutexLock lk(&mtx);\n+  MutexEnsureID(lt, m);\n+  if (dd.isHeld(&lt->dd, m->id))\n+    return;  // FIXME: allow this only for recursive locks.\n+  if (dd.onLockBefore(&lt->dd, m->id)) {\n+    // Actually add this edge now so that we have all the stack traces.\n+    dd.addEdges(&lt->dd, m->id, cb->Unwind(), cb->UniqueTid());\n+    ReportDeadlock(cb, m);\n+  }\n+}\n+\n+void DD::ReportDeadlock(DDCallback *cb, DDMutex *m) {\n+  DDLogicalThread *lt = cb->lt;\n+  uptr path[10];\n+  uptr len = dd.findPathToLock(&lt->dd, m->id, path, ARRAY_SIZE(path));\n+  CHECK_GT(len, 0U);  // Hm.. cycle of 10 locks? I'd like to see that.\n+  CHECK_EQ(m->id, path[0]);\n+  lt->report_pending = true;\n+  DDReport *rep = &lt->rep;\n+  rep->n = len;\n+  for (uptr i = 0; i < len; i++) {\n+    uptr from = path[i];\n+    uptr to = path[(i + 1) % len];\n+    DDMutex *m0 = (DDMutex*)dd.getData(from);\n+    DDMutex *m1 = (DDMutex*)dd.getData(to);\n+\n+    u32 stk_from = -1U, stk_to = -1U;\n+    int unique_tid = 0;\n+    dd.findEdge(from, to, &stk_from, &stk_to, &unique_tid);\n+    // Printf(\"Edge: %zd=>%zd: %u/%u T%d\\n\", from, to, stk_from, stk_to,\n+    //    unique_tid);\n+    rep->loop[i].thr_ctx = unique_tid;\n+    rep->loop[i].mtx_ctx0 = m0->ctx;\n+    rep->loop[i].mtx_ctx1 = m1->ctx;\n+    rep->loop[i].stk[0] = stk_to;\n+    rep->loop[i].stk[1] = stk_from;\n+  }\n+}\n+\n+void DD::MutexAfterLock(DDCallback *cb, DDMutex *m, bool wlock, bool trylock) {\n+  DDLogicalThread *lt = cb->lt;\n+  u32 stk = 0;\n+  if (flags.second_deadlock_stack)\n+    stk = cb->Unwind();\n+  // Printf(\"T%p MutexLock:   %zx stk %u\\n\", lt, m->id, stk);\n+  if (dd.onFirstLock(&lt->dd, m->id, stk))\n+    return;\n+  if (dd.onLockFast(&lt->dd, m->id, stk))\n+    return;\n+\n+  SpinMutexLock lk(&mtx);\n+  MutexEnsureID(lt, m);\n+  if (wlock)  // Only a recursive rlock may be held.\n+    CHECK(!dd.isHeld(&lt->dd, m->id));\n+  if (!trylock)\n+    dd.addEdges(&lt->dd, m->id, stk ? stk : cb->Unwind(), cb->UniqueTid());\n+  dd.onLockAfter(&lt->dd, m->id, stk);\n+}\n+\n+void DD::MutexBeforeUnlock(DDCallback *cb, DDMutex *m, bool wlock) {\n+  // Printf(\"T%p MutexUnLock: %zx\\n\", cb->lt, m->id);\n+  dd.onUnlock(&cb->lt->dd, m->id);\n+}\n+\n+void DD::MutexDestroy(DDCallback *cb,\n+    DDMutex *m) {\n+  if (!m->id) return;\n+  SpinMutexLock lk(&mtx);\n+  if (dd.nodeBelongsToCurrentEpoch(m->id))\n+    dd.removeNode(m->id);\n+  m->id = 0;\n+}\n+\n+DDReport *DD::GetReport(DDCallback *cb) {\n+  if (!cb->lt->report_pending)\n+    return 0;\n+  cb->lt->report_pending = false;\n+  return &cb->lt->rep;\n+}\n+\n+}  // namespace __sanitizer\n+#endif  // #if SANITIZER_DEADLOCK_DETECTOR_VERSION == 1"}, {"sha": "f4d46d99736dac68270ecbdd2418235a19d3e32c", "filename": "libsanitizer/sanitizer_common/sanitizer_deadlock_detector2.cc", "status": "added", "additions": 427, "deletions": 0, "changes": 427, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_deadlock_detector2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_deadlock_detector2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_deadlock_detector2.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -0,0 +1,427 @@\n+//===-- sanitizer_deadlock_detector2.cc -----------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Deadlock detector implementation based on adjacency lists.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_deadlock_detector_interface.h\"\n+#include \"sanitizer_common.h\"\n+#include \"sanitizer_allocator_internal.h\"\n+#include \"sanitizer_placement_new.h\"\n+#include \"sanitizer_mutex.h\"\n+\n+#if SANITIZER_DEADLOCK_DETECTOR_VERSION == 2\n+\n+namespace __sanitizer {\n+\n+const int kMaxNesting = 64;\n+const u32 kNoId = -1;\n+const u32 kEndId = -2;\n+const int kMaxLink = 8;\n+const int kL1Size = 1024;\n+const int kL2Size = 1024;\n+const int kMaxMutex = kL1Size * kL2Size;\n+\n+struct Id {\n+  u32 id;\n+  u32 seq;\n+\n+  explicit Id(u32 id = 0, u32 seq = 0)\n+      : id(id)\n+      , seq(seq) {\n+  }\n+};\n+\n+struct Link {\n+  u32 id;\n+  u32 seq;\n+  u32 tid;\n+  u32 stk0;\n+  u32 stk1;\n+\n+  explicit Link(u32 id = 0, u32 seq = 0, u32 tid = 0, u32 s0 = 0, u32 s1 = 0)\n+      : id(id)\n+      , seq(seq)\n+      , tid(tid)\n+      , stk0(s0)\n+      , stk1(s1) {\n+  }\n+};\n+\n+struct DDPhysicalThread {\n+  DDReport rep;\n+  bool report_pending;\n+  bool visited[kMaxMutex];\n+  Link pending[kMaxMutex];\n+  Link path[kMaxMutex];\n+};\n+\n+struct ThreadMutex {\n+  u32 id;\n+  u32 stk;\n+};\n+\n+struct DDLogicalThread {\n+  u64         ctx;\n+  ThreadMutex locked[kMaxNesting];\n+  int         nlocked;\n+};\n+\n+struct Mutex {\n+  StaticSpinMutex mtx;\n+  u32 seq;\n+  int nlink;\n+  Link link[kMaxLink];\n+};\n+\n+struct DD : public DDetector {\n+  explicit DD(const DDFlags *flags);\n+\n+  DDPhysicalThread* CreatePhysicalThread();\n+  void DestroyPhysicalThread(DDPhysicalThread *pt);\n+\n+  DDLogicalThread* CreateLogicalThread(u64 ctx);\n+  void DestroyLogicalThread(DDLogicalThread *lt);\n+\n+  void MutexInit(DDCallback *cb, DDMutex *m);\n+  void MutexBeforeLock(DDCallback *cb, DDMutex *m, bool wlock);\n+  void MutexAfterLock(DDCallback *cb, DDMutex *m, bool wlock,\n+      bool trylock);\n+  void MutexBeforeUnlock(DDCallback *cb, DDMutex *m, bool wlock);\n+  void MutexDestroy(DDCallback *cb, DDMutex *m);\n+\n+  DDReport *GetReport(DDCallback *cb);\n+\n+  void CycleCheck(DDPhysicalThread *pt, DDLogicalThread *lt, DDMutex *mtx);\n+  void Report(DDPhysicalThread *pt, DDLogicalThread *lt, int npath);\n+  u32 allocateId(DDCallback *cb);\n+  Mutex *getMutex(u32 id);\n+  u32 getMutexId(Mutex *m);\n+\n+  DDFlags flags;\n+\n+  Mutex* mutex[kL1Size];\n+\n+  SpinMutex mtx;\n+  InternalMmapVector<u32> free_id;\n+  int id_gen;\n+};\n+\n+DDetector *DDetector::Create(const DDFlags *flags) {\n+  (void)flags;\n+  void *mem = MmapOrDie(sizeof(DD), \"deadlock detector\");\n+  return new(mem) DD(flags);\n+}\n+\n+DD::DD(const DDFlags *flags)\n+    : flags(*flags)\n+    , free_id(1024) {\n+  id_gen = 0;\n+}\n+\n+DDPhysicalThread* DD::CreatePhysicalThread() {\n+  DDPhysicalThread *pt = (DDPhysicalThread*)MmapOrDie(sizeof(DDPhysicalThread),\n+      \"deadlock detector (physical thread)\");\n+  return pt;\n+}\n+\n+void DD::DestroyPhysicalThread(DDPhysicalThread *pt) {\n+  pt->~DDPhysicalThread();\n+  UnmapOrDie(pt, sizeof(DDPhysicalThread));\n+}\n+\n+DDLogicalThread* DD::CreateLogicalThread(u64 ctx) {\n+  DDLogicalThread *lt = (DDLogicalThread*)InternalAlloc(\n+      sizeof(DDLogicalThread));\n+  lt->ctx = ctx;\n+  lt->nlocked = 0;\n+  return lt;\n+}\n+\n+void DD::DestroyLogicalThread(DDLogicalThread *lt) {\n+  lt->~DDLogicalThread();\n+  InternalFree(lt);\n+}\n+\n+void DD::MutexInit(DDCallback *cb, DDMutex *m) {\n+  VPrintf(2, \"#%llu: DD::MutexInit(%p)\\n\", cb->lt->ctx, m);\n+  m->id = kNoId;\n+  m->recursion = 0;\n+  atomic_store(&m->owner, 0, memory_order_relaxed);\n+}\n+\n+Mutex *DD::getMutex(u32 id) {\n+  return &mutex[id / kL2Size][id % kL2Size];\n+}\n+\n+u32 DD::getMutexId(Mutex *m) {\n+  for (int i = 0; i < kL1Size; i++) {\n+    Mutex *tab = mutex[i];\n+    if (tab == 0)\n+      break;\n+    if (m >= tab && m < tab + kL2Size)\n+      return i * kL2Size + (m - tab);\n+  }\n+  return -1;\n+}\n+\n+u32 DD::allocateId(DDCallback *cb) {\n+  u32 id = -1;\n+  SpinMutexLock l(&mtx);\n+  if (free_id.size() > 0) {\n+    id = free_id.back();\n+    free_id.pop_back();\n+  } else {\n+    CHECK_LT(id_gen, kMaxMutex);\n+    if ((id_gen % kL2Size) == 0) {\n+      mutex[id_gen / kL2Size] = (Mutex*)MmapOrDie(kL2Size * sizeof(Mutex),\n+          \"deadlock detector (mutex table)\");\n+    }\n+    id = id_gen++;\n+  }\n+  CHECK_LE(id, kMaxMutex);\n+  VPrintf(3, \"#%llu: DD::allocateId assign id %d\\n\",\n+      cb->lt->ctx, id);\n+  return id;\n+}\n+\n+void DD::MutexBeforeLock(DDCallback *cb, DDMutex *m, bool wlock) {\n+  VPrintf(2, \"#%llu: DD::MutexBeforeLock(%p, wlock=%d) nlocked=%d\\n\",\n+      cb->lt->ctx, m, wlock, cb->lt->nlocked);\n+  DDPhysicalThread *pt = cb->pt;\n+  DDLogicalThread *lt = cb->lt;\n+\n+  uptr owner = atomic_load(&m->owner, memory_order_relaxed);\n+  if (owner == (uptr)cb->lt) {\n+    VPrintf(3, \"#%llu: DD::MutexBeforeLock recursive\\n\",\n+        cb->lt->ctx);\n+    return;\n+  }\n+\n+  CHECK_LE(lt->nlocked, kMaxNesting);\n+\n+  // FIXME(dvyukov): don't allocate id if lt->nlocked == 0?\n+  if (m->id == kNoId)\n+    m->id = allocateId(cb);\n+\n+  ThreadMutex *tm = &lt->locked[lt->nlocked++];\n+  tm->id = m->id;\n+  if (flags.second_deadlock_stack)\n+    tm->stk = cb->Unwind();\n+  if (lt->nlocked == 1) {\n+    VPrintf(3, \"#%llu: DD::MutexBeforeLock first mutex\\n\",\n+        cb->lt->ctx);\n+    return;\n+  }\n+\n+  bool added = false;\n+  Mutex *mtx = getMutex(m->id);\n+  for (int i = 0; i < lt->nlocked - 1; i++) {\n+    u32 id1 = lt->locked[i].id;\n+    u32 stk1 = lt->locked[i].stk;\n+    Mutex *mtx1 = getMutex(id1);\n+    SpinMutexLock l(&mtx1->mtx);\n+    if (mtx1->nlink == kMaxLink) {\n+      // FIXME(dvyukov): check stale links\n+      continue;\n+    }\n+    int li = 0;\n+    for (; li < mtx1->nlink; li++) {\n+      Link *link = &mtx1->link[li];\n+      if (link->id == m->id) {\n+        if (link->seq != mtx->seq) {\n+          link->seq = mtx->seq;\n+          link->tid = lt->ctx;\n+          link->stk0 = stk1;\n+          link->stk1 = cb->Unwind();\n+          added = true;\n+          VPrintf(3, \"#%llu: DD::MutexBeforeLock added %d->%d link\\n\",\n+              cb->lt->ctx, getMutexId(mtx1), m->id);\n+        }\n+        break;\n+      }\n+    }\n+    if (li == mtx1->nlink) {\n+      // FIXME(dvyukov): check stale links\n+      Link *link = &mtx1->link[mtx1->nlink++];\n+      link->id = m->id;\n+      link->seq = mtx->seq;\n+      link->tid = lt->ctx;\n+      link->stk0 = stk1;\n+      link->stk1 = cb->Unwind();\n+      added = true;\n+      VPrintf(3, \"#%llu: DD::MutexBeforeLock added %d->%d link\\n\",\n+          cb->lt->ctx, getMutexId(mtx1), m->id);\n+    }\n+  }\n+\n+  if (!added || mtx->nlink == 0) {\n+    VPrintf(3, \"#%llu: DD::MutexBeforeLock don't check\\n\",\n+        cb->lt->ctx);\n+    return;\n+  }\n+\n+  CycleCheck(pt, lt, m);\n+}\n+\n+void DD::MutexAfterLock(DDCallback *cb, DDMutex *m, bool wlock,\n+    bool trylock) {\n+  VPrintf(2, \"#%llu: DD::MutexAfterLock(%p, wlock=%d, try=%d) nlocked=%d\\n\",\n+      cb->lt->ctx, m, wlock, trylock, cb->lt->nlocked);\n+  DDLogicalThread *lt = cb->lt;\n+\n+  uptr owner = atomic_load(&m->owner, memory_order_relaxed);\n+  if (owner == (uptr)cb->lt) {\n+    VPrintf(3, \"#%llu: DD::MutexAfterLock recursive\\n\", cb->lt->ctx);\n+    CHECK(wlock);\n+    m->recursion++;\n+    return;\n+  }\n+  CHECK_EQ(owner, 0);\n+  if (wlock) {\n+    VPrintf(3, \"#%llu: DD::MutexAfterLock set owner\\n\", cb->lt->ctx);\n+    CHECK_EQ(m->recursion, 0);\n+    m->recursion = 1;\n+    atomic_store(&m->owner, (uptr)cb->lt, memory_order_relaxed);\n+  }\n+\n+  if (!trylock)\n+    return;\n+\n+  CHECK_LE(lt->nlocked, kMaxNesting);\n+  if (m->id == kNoId)\n+    m->id = allocateId(cb);\n+  ThreadMutex *tm = &lt->locked[lt->nlocked++];\n+  tm->id = m->id;\n+  if (flags.second_deadlock_stack)\n+    tm->stk = cb->Unwind();\n+}\n+\n+void DD::MutexBeforeUnlock(DDCallback *cb, DDMutex *m, bool wlock) {\n+  VPrintf(2, \"#%llu: DD::MutexBeforeUnlock(%p, wlock=%d) nlocked=%d\\n\",\n+      cb->lt->ctx, m, wlock, cb->lt->nlocked);\n+  DDLogicalThread *lt = cb->lt;\n+\n+  uptr owner = atomic_load(&m->owner, memory_order_relaxed);\n+  if (owner == (uptr)cb->lt) {\n+    VPrintf(3, \"#%llu: DD::MutexBeforeUnlock recursive\\n\", cb->lt->ctx);\n+    if (--m->recursion > 0)\n+      return;\n+    VPrintf(3, \"#%llu: DD::MutexBeforeUnlock reset owner\\n\", cb->lt->ctx);\n+    atomic_store(&m->owner, 0, memory_order_relaxed);\n+  }\n+  CHECK_NE(m->id, kNoId);\n+  int last = lt->nlocked - 1;\n+  for (int i = last; i >= 0; i--) {\n+    if (cb->lt->locked[i].id == m->id) {\n+      lt->locked[i] = lt->locked[last];\n+      lt->nlocked--;\n+      break;\n+    }\n+  }\n+}\n+\n+void DD::MutexDestroy(DDCallback *cb, DDMutex *m) {\n+  VPrintf(2, \"#%llu: DD::MutexDestroy(%p)\\n\",\n+      cb->lt->ctx, m);\n+  DDLogicalThread *lt = cb->lt;\n+\n+  if (m->id == kNoId)\n+    return;\n+\n+  // Remove the mutex from lt->locked if there.\n+  int last = lt->nlocked - 1;\n+  for (int i = last; i >= 0; i--) {\n+    if (lt->locked[i].id == m->id) {\n+      lt->locked[i] = lt->locked[last];\n+      lt->nlocked--;\n+      break;\n+    }\n+  }\n+\n+  // Clear and invalidate the mutex descriptor.\n+  {\n+    Mutex *mtx = getMutex(m->id);\n+    SpinMutexLock l(&mtx->mtx);\n+    mtx->seq++;\n+    mtx->nlink = 0;\n+  }\n+\n+  // Return id to cache.\n+  {\n+    SpinMutexLock l(&mtx);\n+    free_id.push_back(m->id);\n+  }\n+}\n+\n+void DD::CycleCheck(DDPhysicalThread *pt, DDLogicalThread *lt,\n+    DDMutex *m) {\n+  internal_memset(pt->visited, 0, sizeof(pt->visited));\n+  int npath = 0;\n+  int npending = 0;\n+  {\n+    Mutex *mtx = getMutex(m->id);\n+    SpinMutexLock l(&mtx->mtx);\n+    for (int li = 0; li < mtx->nlink; li++)\n+      pt->pending[npending++] = mtx->link[li];\n+  }\n+  while (npending > 0) {\n+    Link link = pt->pending[--npending];\n+    if (link.id == kEndId) {\n+      npath--;\n+      continue;\n+    }\n+    if (pt->visited[link.id])\n+      continue;\n+    Mutex *mtx1 = getMutex(link.id);\n+    SpinMutexLock l(&mtx1->mtx);\n+    if (mtx1->seq != link.seq)\n+      continue;\n+    pt->visited[link.id] = true;\n+    if (mtx1->nlink == 0)\n+      continue;\n+    pt->path[npath++] = link;\n+    pt->pending[npending++] = Link(kEndId);\n+    if (link.id == m->id)\n+      return Report(pt, lt, npath);  // Bingo!\n+    for (int li = 0; li < mtx1->nlink; li++) {\n+      Link *link1 = &mtx1->link[li];\n+      // Mutex *mtx2 = getMutex(link->id);\n+      // FIXME(dvyukov): fast seq check\n+      // FIXME(dvyukov): fast nlink != 0 check\n+      // FIXME(dvyukov): fast pending check?\n+      // FIXME(dvyukov): npending can be larger than kMaxMutex\n+      pt->pending[npending++] = *link1;\n+    }\n+  }\n+}\n+\n+void DD::Report(DDPhysicalThread *pt, DDLogicalThread *lt, int npath) {\n+  DDReport *rep = &pt->rep;\n+  rep->n = npath;\n+  for (int i = 0; i < npath; i++) {\n+    Link *link = &pt->path[i];\n+    Link *link0 = &pt->path[i ? i - 1 : npath - 1];\n+    rep->loop[i].thr_ctx = link->tid;\n+    rep->loop[i].mtx_ctx0 = link0->id;\n+    rep->loop[i].mtx_ctx1 = link->id;\n+    rep->loop[i].stk[0] = flags.second_deadlock_stack ? link->stk0 : 0;\n+    rep->loop[i].stk[1] = link->stk1;\n+  }\n+  pt->report_pending = true;\n+}\n+\n+DDReport *DD::GetReport(DDCallback *cb) {\n+  if (!cb->pt->report_pending)\n+    return 0;\n+  cb->pt->report_pending = false;\n+  return &cb->pt->rep;\n+}\n+\n+}  // namespace __sanitizer\n+#endif  // #if SANITIZER_DEADLOCK_DETECTOR_VERSION == 2"}, {"sha": "59d8d93fe13384c6a136446b052618ac20ead2ad", "filename": "libsanitizer/sanitizer_common/sanitizer_deadlock_detector_interface.h", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_deadlock_detector_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_deadlock_detector_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_deadlock_detector_interface.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -0,0 +1,91 @@\n+//===-- sanitizer_deadlock_detector_interface.h -----------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of Sanitizer runtime.\n+// Abstract deadlock detector interface.\n+// FIXME: this is work in progress, nothing really works yet.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef SANITIZER_DEADLOCK_DETECTOR_INTERFACE_H\n+#define SANITIZER_DEADLOCK_DETECTOR_INTERFACE_H\n+\n+#ifndef SANITIZER_DEADLOCK_DETECTOR_VERSION\n+# define SANITIZER_DEADLOCK_DETECTOR_VERSION 1\n+#endif\n+\n+#include \"sanitizer_internal_defs.h\"\n+#include \"sanitizer_atomic.h\"\n+\n+namespace __sanitizer {\n+\n+// dd - deadlock detector.\n+// lt - logical (user) thread.\n+// pt - physical (OS) thread.\n+\n+struct DDPhysicalThread;\n+struct DDLogicalThread;\n+\n+struct DDMutex {\n+#if SANITIZER_DEADLOCK_DETECTOR_VERSION == 1\n+  uptr id;\n+  u32  stk;  // creation stack\n+#elif SANITIZER_DEADLOCK_DETECTOR_VERSION == 2\n+  u32              id;\n+  u32              recursion;\n+  atomic_uintptr_t owner;\n+#else\n+# error \"BAD SANITIZER_DEADLOCK_DETECTOR_VERSION\"\n+#endif\n+  u64  ctx;\n+};\n+\n+struct DDFlags {\n+  bool second_deadlock_stack;\n+};\n+\n+struct DDReport {\n+  enum { kMaxLoopSize = 8 };\n+  int n;  // number of entries in loop\n+  struct {\n+    u64 thr_ctx;   // user thread context\n+    u64 mtx_ctx0;  // user mutex context, start of the edge\n+    u64 mtx_ctx1;  // user mutex context, end of the edge\n+    u32 stk[2];  // stack ids for the edge\n+  } loop[kMaxLoopSize];\n+};\n+\n+struct DDCallback {\n+  DDPhysicalThread *pt;\n+  DDLogicalThread  *lt;\n+\n+  virtual u32 Unwind() { return 0; }\n+  virtual int UniqueTid() { return 0; }\n+};\n+\n+struct DDetector {\n+  static DDetector *Create(const DDFlags *flags);\n+\n+  virtual DDPhysicalThread* CreatePhysicalThread() { return 0; }\n+  virtual void DestroyPhysicalThread(DDPhysicalThread *pt) {}\n+\n+  virtual DDLogicalThread* CreateLogicalThread(u64 ctx) { return 0; }\n+  virtual void DestroyLogicalThread(DDLogicalThread *lt) {}\n+\n+  virtual void MutexInit(DDCallback *cb, DDMutex *m) {}\n+  virtual void MutexBeforeLock(DDCallback *cb, DDMutex *m, bool wlock) {}\n+  virtual void MutexAfterLock(DDCallback *cb, DDMutex *m, bool wlock,\n+      bool trylock) {}\n+  virtual void MutexBeforeUnlock(DDCallback *cb, DDMutex *m, bool wlock) {}\n+  virtual void MutexDestroy(DDCallback *cb, DDMutex *m) {}\n+\n+  virtual DDReport *GetReport(DDCallback *cb) { return 0; }\n+};\n+\n+} // namespace __sanitizer\n+\n+#endif // SANITIZER_DEADLOCK_DETECTOR_INTERFACE_H"}, {"sha": "e90d79e436025c44dd22e2e9ff07954aa69bfa9a", "filename": "libsanitizer/sanitizer_common/sanitizer_flags.cc", "status": "modified", "additions": 143, "deletions": 18, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -13,39 +13,121 @@\n \n #include \"sanitizer_common.h\"\n #include \"sanitizer_libc.h\"\n+#include \"sanitizer_list.h\"\n \n namespace __sanitizer {\n \n+CommonFlags common_flags_dont_use;\n+\n+struct FlagDescription {\n+  const char *name;\n+  const char *description;\n+  FlagDescription *next;\n+};\n+\n+IntrusiveList<FlagDescription> flag_descriptions;\n+\n void SetCommonFlagsDefaults(CommonFlags *f) {\n   f->symbolize = true;\n   f->external_symbolizer_path = 0;\n+  f->allow_addr2line = false;\n   f->strip_path_prefix = \"\";\n   f->fast_unwind_on_fatal = false;\n   f->fast_unwind_on_malloc = true;\n   f->handle_ioctl = false;\n   f->malloc_context_size = 1;\n   f->log_path = \"stderr\";\n   f->verbosity = 0;\n-  f->detect_leaks = false;\n+  f->detect_leaks = true;\n   f->leak_check_at_exit = true;\n   f->allocator_may_return_null = false;\n   f->print_summary = true;\n+  f->check_printf = true;\n+  // TODO(glider): tools may want to set different defaults for handle_segv.\n+  f->handle_segv = SANITIZER_NEEDS_SEGV;\n+  f->allow_user_segv_handler = false;\n+  f->use_sigaltstack = true;\n+  f->detect_deadlocks = false;\n+  f->clear_shadow_mmap_threshold = 64 * 1024;\n+  f->color = \"auto\";\n+  f->legacy_pthread_cond = false;\n+  f->intercept_tls_get_addr = false;\n+  f->coverage = false;\n+  f->full_address_space = false;\n }\n \n void ParseCommonFlagsFromString(CommonFlags *f, const char *str) {\n-  ParseFlag(str, &f->symbolize, \"symbolize\");\n-  ParseFlag(str, &f->external_symbolizer_path, \"external_symbolizer_path\");\n-  ParseFlag(str, &f->strip_path_prefix, \"strip_path_prefix\");\n-  ParseFlag(str, &f->fast_unwind_on_fatal, \"fast_unwind_on_fatal\");\n-  ParseFlag(str, &f->fast_unwind_on_malloc, \"fast_unwind_on_malloc\");\n-  ParseFlag(str, &f->handle_ioctl, \"handle_ioctl\");\n-  ParseFlag(str, &f->malloc_context_size, \"malloc_context_size\");\n-  ParseFlag(str, &f->log_path, \"log_path\");\n-  ParseFlag(str, &f->verbosity, \"verbosity\");\n-  ParseFlag(str, &f->detect_leaks, \"detect_leaks\");\n-  ParseFlag(str, &f->leak_check_at_exit, \"leak_check_at_exit\");\n-  ParseFlag(str, &f->allocator_may_return_null, \"allocator_may_return_null\");\n-  ParseFlag(str, &f->print_summary, \"print_summary\");\n+  ParseFlag(str, &f->symbolize, \"symbolize\",\n+      \"If set, use the online symbolizer from common sanitizer runtime to turn \"\n+      \"virtual addresses to file/line locations.\");\n+  ParseFlag(str, &f->external_symbolizer_path, \"external_symbolizer_path\",\n+      \"Path to external symbolizer. If empty, the tool will search $PATH for \"\n+      \"the symbolizer.\");\n+  ParseFlag(str, &f->allow_addr2line, \"allow_addr2line\",\n+      \"If set, allows online symbolizer to run addr2line binary to symbolize \"\n+      \"stack traces (addr2line will only be used if llvm-symbolizer binary is \"\n+      \"unavailable.\");\n+  ParseFlag(str, &f->strip_path_prefix, \"strip_path_prefix\",\n+      \"Strips this prefix from file paths in error reports.\");\n+  ParseFlag(str, &f->fast_unwind_on_fatal, \"fast_unwind_on_fatal\",\n+      \"If available, use the fast frame-pointer-based unwinder on fatal \"\n+      \"errors.\");\n+  ParseFlag(str, &f->fast_unwind_on_malloc, \"fast_unwind_on_malloc\",\n+      \"If available, use the fast frame-pointer-based unwinder on \"\n+      \"malloc/free.\");\n+  ParseFlag(str, &f->handle_ioctl, \"handle_ioctl\",\n+      \"Intercept and handle ioctl requests.\");\n+  ParseFlag(str, &f->malloc_context_size, \"malloc_context_size\",\n+      \"Max number of stack frames kept for each allocation/deallocation.\");\n+  ParseFlag(str, &f->log_path, \"log_path\",\n+      \"Write logs to \\\"log_path.pid\\\". The special values are \\\"stdout\\\" and \"\n+      \"\\\"stderr\\\". The default is \\\"stderr\\\".\");\n+  ParseFlag(str, &f->verbosity, \"verbosity\",\n+      \"Verbosity level (0 - silent, 1 - a bit of output, 2+ - more output).\");\n+  ParseFlag(str, &f->detect_leaks, \"detect_leaks\",\n+      \"Enable memory leak detection.\");\n+  ParseFlag(str, &f->leak_check_at_exit, \"leak_check_at_exit\",\n+      \"Invoke leak checking in an atexit handler. Has no effect if \"\n+      \"detect_leaks=false, or if __lsan_do_leak_check() is called before the \"\n+      \"handler has a chance to run.\");\n+  ParseFlag(str, &f->allocator_may_return_null, \"allocator_may_return_null\",\n+      \"If false, the allocator will crash instead of returning 0 on \"\n+      \"out-of-memory.\");\n+  ParseFlag(str, &f->print_summary, \"print_summary\",\n+      \"If false, disable printing error summaries in addition to error \"\n+      \"reports.\");\n+  ParseFlag(str, &f->check_printf, \"check_printf\",\n+      \"Check printf arguments.\");\n+  ParseFlag(str, &f->handle_segv, \"handle_segv\",\n+      \"If set, registers the tool's custom SEGV handler (both SIGBUS and \"\n+      \"SIGSEGV on OSX).\");\n+  ParseFlag(str, &f->allow_user_segv_handler, \"allow_user_segv_handler\",\n+      \"If set, allows user to register a SEGV handler even if the tool \"\n+      \"registers one.\");\n+  ParseFlag(str, &f->use_sigaltstack, \"use_sigaltstack\",\n+      \"If set, uses alternate stack for signal handling.\");\n+  ParseFlag(str, &f->detect_deadlocks, \"detect_deadlocks\",\n+      \"If set, deadlock detection is enabled.\");\n+  ParseFlag(str, &f->clear_shadow_mmap_threshold,\n+            \"clear_shadow_mmap_threshold\",\n+      \"Large shadow regions are zero-filled using mmap(NORESERVE) instead of \"\n+      \"memset(). This is the threshold size in bytes.\");\n+  ParseFlag(str, &f->color, \"color\",\n+      \"Colorize reports: (always|never|auto).\");\n+  ParseFlag(str, &f->legacy_pthread_cond, \"legacy_pthread_cond\",\n+      \"Enables support for dynamic libraries linked with libpthread 2.2.5.\");\n+  ParseFlag(str, &f->intercept_tls_get_addr, \"intercept_tls_get_addr\",\n+            \"Intercept __tls_get_addr.\");\n+  ParseFlag(str, &f->help, \"help\", \"Print the flag descriptions.\");\n+  ParseFlag(str, &f->mmap_limit_mb, \"mmap_limit_mb\",\n+            \"Limit the amount of mmap-ed memory (excluding shadow) in Mb; \"\n+            \"not a user-facing flag, used mosly for testing the tools\");\n+  ParseFlag(str, &f->coverage, \"coverage\",\n+      \"If set, coverage information will be dumped at program shutdown (if the \"\n+      \"coverage instrumentation was enabled at compile time).\");\n+  ParseFlag(str, &f->full_address_space, \"full_address_space\",\n+            \"Sanitize complete address space; \"\n+            \"by default kernel area on 32-bit platforms will not be sanitized\");\n \n   // Do a sanity check for certain flags.\n   if (f->malloc_context_size < 1)\n@@ -100,9 +182,40 @@ static bool StartsWith(const char *flag, int flag_length, const char *value) {\n          (0 == internal_strncmp(flag, value, value_length));\n }\n \n-void ParseFlag(const char *env, bool *flag, const char *name) {\n+static LowLevelAllocator allocator_for_flags;\n+\n+// The linear scan is suboptimal, but the number of flags is relatively small.\n+bool FlagInDescriptionList(const char *name) {\n+  IntrusiveList<FlagDescription>::Iterator it(&flag_descriptions);\n+  while (it.hasNext()) {\n+    if (!internal_strcmp(it.next()->name, name)) return true;\n+  }\n+  return false;\n+}\n+\n+void AddFlagDescription(const char *name, const char *description) {\n+  if (FlagInDescriptionList(name)) return;\n+  FlagDescription *new_description = new(allocator_for_flags) FlagDescription;\n+  new_description->name = name;\n+  new_description->description = description;\n+  flag_descriptions.push_back(new_description);\n+}\n+\n+// TODO(glider): put the descriptions inside CommonFlags.\n+void PrintFlagDescriptions() {\n+  IntrusiveList<FlagDescription>::Iterator it(&flag_descriptions);\n+  Printf(\"Available flags for %s:\\n\", SanitizerToolName);\n+  while (it.hasNext()) {\n+    FlagDescription *descr = it.next();\n+    Printf(\"\\t%s\\n\\t\\t- %s\\n\", descr->name, descr->description);\n+  }\n+}\n+\n+void ParseFlag(const char *env, bool *flag,\n+               const char *name, const char *descr) {\n   const char *value;\n   int value_length;\n+  AddFlagDescription(name, descr);\n   if (!GetFlagValue(env, name, &value, &value_length))\n     return;\n   if (StartsWith(value, value_length, \"0\") ||\n@@ -115,19 +228,31 @@ void ParseFlag(const char *env, bool *flag, const char *name) {\n     *flag = true;\n }\n \n-void ParseFlag(const char *env, int *flag, const char *name) {\n+void ParseFlag(const char *env, int *flag,\n+               const char *name, const char *descr) {\n   const char *value;\n   int value_length;\n+  AddFlagDescription(name, descr);\n   if (!GetFlagValue(env, name, &value, &value_length))\n     return;\n   *flag = static_cast<int>(internal_atoll(value));\n }\n \n-static LowLevelAllocator allocator_for_flags;\n+void ParseFlag(const char *env, uptr *flag,\n+               const char *name, const char *descr) {\n+  const char *value;\n+  int value_length;\n+  AddFlagDescription(name, descr);\n+  if (!GetFlagValue(env, name, &value, &value_length))\n+    return;\n+  *flag = static_cast<uptr>(internal_atoll(value));\n+}\n \n-void ParseFlag(const char *env, const char **flag, const char *name) {\n+void ParseFlag(const char *env, const char **flag,\n+               const char *name, const char *descr) {\n   const char *value;\n   int value_length;\n+  AddFlagDescription(name, descr);\n   if (!GetFlagValue(env, name, &value, &value_length))\n     return;\n   // Copy the flag value. Don't use locks here, as flags are parsed at"}, {"sha": "107b6776b3a4fb4103d95ee6da78f8c36377f5ad", "filename": "libsanitizer/sanitizer_common/sanitizer_flags.h", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -16,51 +16,53 @@\n \n namespace __sanitizer {\n \n-void ParseFlag(const char *env, bool *flag, const char *name);\n-void ParseFlag(const char *env, int *flag, const char *name);\n-void ParseFlag(const char *env, const char **flag, const char *name);\n+void ParseFlag(const char *env, bool *flag,\n+    const char *name, const char *descr);\n+void ParseFlag(const char *env, int *flag,\n+    const char *name, const char *descr);\n+void ParseFlag(const char *env, uptr *flag,\n+    const char *name, const char *descr);\n+void ParseFlag(const char *env, const char **flag,\n+    const char *name, const char *descr);\n \n struct CommonFlags {\n-  // If set, use the online symbolizer from common sanitizer runtime.\n   bool symbolize;\n-  // Path to external symbolizer. If it is NULL, symbolizer will be looked for\n-  // in PATH. If it is empty, external symbolizer will not be started.\n   const char *external_symbolizer_path;\n-  // Strips this prefix from file paths in error reports.\n+  bool allow_addr2line;\n   const char *strip_path_prefix;\n-  // Use fast (frame-pointer-based) unwinder on fatal errors (if available).\n   bool fast_unwind_on_fatal;\n-  // Use fast (frame-pointer-based) unwinder on malloc/free (if available).\n   bool fast_unwind_on_malloc;\n-  // Intercept and handle ioctl requests.\n   bool handle_ioctl;\n-  // Max number of stack frames kept for each allocation/deallocation.\n   int malloc_context_size;\n-  // Write logs to \"log_path.pid\".\n-  // The special values are \"stdout\" and \"stderr\".\n-  // The default is \"stderr\".\n   const char *log_path;\n-  // Verbosity level (0 - silent, 1 - a bit of output, 2+ - more output).\n   int  verbosity;\n-  // Enable memory leak detection.\n   bool detect_leaks;\n-  // Invoke leak checking in an atexit handler. Has no effect if\n-  // detect_leaks=false, or if __lsan_do_leak_check() is called before the\n-  // handler has a chance to run.\n   bool leak_check_at_exit;\n-  // If false, the allocator will crash instead of returning 0 on out-of-memory.\n   bool allocator_may_return_null;\n-  // If false, disable printing error summaries in addition to error reports.\n   bool print_summary;\n+  bool check_printf;\n+  bool handle_segv;\n+  bool allow_user_segv_handler;\n+  bool use_sigaltstack;\n+  bool detect_deadlocks;\n+  uptr clear_shadow_mmap_threshold;\n+  const char *color;\n+  bool legacy_pthread_cond;\n+  bool intercept_tls_get_addr;\n+  bool help;\n+  uptr mmap_limit_mb;\n+  bool coverage;\n+  bool full_address_space;\n };\n \n inline CommonFlags *common_flags() {\n-  static CommonFlags f;\n-  return &f;\n+  extern CommonFlags common_flags_dont_use;\n+  return &common_flags_dont_use;\n }\n \n void SetCommonFlagsDefaults(CommonFlags *f);\n void ParseCommonFlagsFromString(CommonFlags *f, const char *str);\n+void PrintFlagDescriptions();\n \n }  // namespace __sanitizer\n "}, {"sha": "2346fa859b10140be379d196f7a8a7022d7efaa0", "filename": "libsanitizer/sanitizer_common/sanitizer_interception.h", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_interception.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_interception.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_interception.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -0,0 +1,23 @@\n+//===-- sanitizer_interception.h --------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Common macro definitions for interceptors.\n+// Always use this headers instead of interception/interception.h.\n+//\n+//===----------------------------------------------------------------------===//\n+#ifndef SANITIZER_INTERCEPTION_H\n+#define SANITIZER_INTERCEPTION_H\n+\n+#include \"interception/interception.h\"\n+#include \"sanitizer_common.h\"\n+\n+#if SANITIZER_LINUX && !defined(SANITIZER_GO)\n+#undef REAL\n+#define REAL(x) IndirectExternCall(__interception::PTR_TO_REAL(x))\n+#endif\n+\n+#endif  // SANITIZER_INTERCEPTION_H"}, {"sha": "a925d306b6183ed2cf2385ca829c1aafb9fca635", "filename": "libsanitizer/sanitizer_common/sanitizer_internal_defs.h", "status": "modified", "additions": 28, "deletions": 17, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_internal_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_internal_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_internal_defs.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -32,10 +32,9 @@\n # define SANITIZER_SUPPORTS_WEAK_HOOKS 0\n #endif\n \n-#if __LP64__ || defined(_WIN64)\n-#  define SANITIZER_WORDSIZE 64\n-#else\n-#  define SANITIZER_WORDSIZE 32\n+// If set, the tool will install its own SEGV signal handler.\n+#ifndef SANITIZER_NEEDS_SEGV\n+# define SANITIZER_NEEDS_SEGV 1\n #endif\n \n // GCC does not understand __has_feature\n@@ -57,7 +56,7 @@ typedef unsigned long uptr;  // NOLINT\n typedef signed   long sptr;  // NOLINT\n #endif  // defined(_WIN64)\n #if defined(__x86_64__)\n-// Since x32 uses ILP32 data model in 64-bit hardware mode,  we must use\n+// Since x32 uses ILP32 data model in 64-bit hardware mode, we must use\n // 64-bit pointer to unwind stack frame.\n typedef unsigned long long uhwptr;  // NOLINT\n #else\n@@ -97,11 +96,15 @@ extern \"C\" {\n   SANITIZER_INTERFACE_ATTRIBUTE\n   void __sanitizer_set_report_path(const char *path);\n \n-  // Notify the tools that the sandbox is going to be turned on. The reserved\n-  // parameter will be used in the future to hold a structure with functions\n-  // that the tools may call to bypass the sandbox.\n-  SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n-  void __sanitizer_sandbox_on_notify(void *reserved);\n+  typedef struct {\n+      int coverage_sandboxed;\n+      __sanitizer::sptr coverage_fd;\n+      unsigned int coverage_max_block_size;\n+  } __sanitizer_sandbox_arguments;\n+\n+  // Notify the tools that the sandbox is going to be turned on.\n+  SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE void\n+      __sanitizer_sandbox_on_notify(__sanitizer_sandbox_arguments *args);\n \n   // This function is called by the tool when it has just finished reporting\n   // an error. 'error_summary' is a one-line string that summarizes\n@@ -110,12 +113,16 @@ extern \"C\" {\n   void __sanitizer_report_error_summary(const char *error_summary);\n \n   SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_cov_dump();\n-  SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_cov(void *pc);\n+  SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_cov_init();\n+  SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_cov();\n   SANITIZER_INTERFACE_ATTRIBUTE\n   void __sanitizer_annotate_contiguous_container(const void *beg,\n                                                  const void *end,\n                                                  const void *old_mid,\n                                                  const void *new_mid);\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  int __sanitizer_verify_contiguous_container(const void *beg, const void *mid,\n+                                              const void *end);\n }  // extern \"C\"\n \n \n@@ -141,8 +148,6 @@ using namespace __sanitizer;  // NOLINT\n # define NOTHROW\n # define LIKELY(x) (x)\n # define UNLIKELY(x) (x)\n-# define UNUSED\n-# define USED\n # define PREFETCH(x) /* _mm_prefetch(x, _MM_HINT_NTA) */\n #else  // _MSC_VER\n # define ALWAYS_INLINE inline __attribute__((always_inline))\n@@ -157,8 +162,6 @@ using namespace __sanitizer;  // NOLINT\n # define NOTHROW throw()\n # define LIKELY(x)     __builtin_expect(!!(x), 1)\n # define UNLIKELY(x)   __builtin_expect(!!(x), 0)\n-# define UNUSED __attribute__((unused))\n-# define USED __attribute__((used))\n # if defined(__i386__) || defined(__x86_64__)\n // __builtin_prefetch(x) generates prefetchnt0 on x86\n #  define PREFETCH(x) __asm__(\"prefetchnta (%0)\" : : \"r\" (x))\n@@ -167,6 +170,14 @@ using namespace __sanitizer;  // NOLINT\n # endif\n #endif  // _MSC_VER\n \n+#if !defined(_MSC_VER) || defined(__clang__)\n+# define UNUSED __attribute__((unused))\n+# define USED __attribute__((used))\n+#else\n+# define UNUSED\n+# define USED\n+#endif\n+\n // Unaligned versions of basic types.\n typedef ALIGNED(1) u16 uu16;\n typedef ALIGNED(1) u32 uu32;\n@@ -197,7 +208,7 @@ void NORETURN CheckFailed(const char *file, int line, const char *cond,\n \n // Check macro\n #define RAW_CHECK_MSG(expr, msg) do { \\\n-  if (!(expr)) { \\\n+  if (UNLIKELY(!(expr))) { \\\n     RawWrite(msg); \\\n     Die(); \\\n   } \\\n@@ -209,7 +220,7 @@ void NORETURN CheckFailed(const char *file, int line, const char *cond,\n   do { \\\n     __sanitizer::u64 v1 = (u64)(c1); \\\n     __sanitizer::u64 v2 = (u64)(c2); \\\n-    if (!(v1 op v2)) \\\n+    if (UNLIKELY(!(v1 op v2))) \\\n       __sanitizer::CheckFailed(__FILE__, __LINE__, \\\n         \"(\" #c1 \") \" #op \" (\" #c2 \")\", v1, v2); \\\n   } while (false) \\"}, {"sha": "c13a66d88cde4e1e8291bfcd38a7d6b4d1e84b46", "filename": "libsanitizer/sanitizer_common/sanitizer_libc.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -16,7 +16,7 @@ namespace __sanitizer {\n \n // Make the compiler think that something is going on there.\n static inline void break_optimization(void *arg) {\n-#if SANITIZER_WINDOWS\n+#if _MSC_VER\n   // FIXME: make sure this is actually enough.\n   __asm;\n #else"}, {"sha": "fd03b791c58e6320a83d555dedeab6007d2b0889", "filename": "libsanitizer/sanitizer_common/sanitizer_libc.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -89,12 +89,16 @@ uptr internal_waitpid(int pid, int *status, int options);\n uptr internal_getpid();\n uptr internal_getppid();\n \n+int internal_fork();\n+\n // Threading\n uptr internal_sched_yield();\n \n // Error handling\n bool internal_iserror(uptr retval, int *rverrno = 0);\n \n+int internal_sigaction(int signum, const void *act, void *oldact);\n+\n }  // namespace __sanitizer\n \n #endif  // SANITIZER_LIBC_H"}, {"sha": "c88550dec8d8a81bb6ff1149e9196e5057388ea2", "filename": "libsanitizer/sanitizer_common/sanitizer_libignore.cc", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_libignore.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_libignore.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_libignore.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -74,9 +74,10 @@ void LibIgnore::OnLibraryLoaded(const char *name) {\n         loaded = true;\n         if (lib->loaded)\n           continue;\n-        if (common_flags()->verbosity)\n-          Report(\"Matched called_from_lib suppression '%s' against library\"\n-              \" '%s'\\n\", lib->templ, module.data());\n+        VReport(1,\n+                \"Matched called_from_lib suppression '%s' against library\"\n+                \" '%s'\\n\",\n+                lib->templ, module.data());\n         lib->loaded = true;\n         lib->name = internal_strdup(module.data());\n         const uptr idx = atomic_load(&loaded_count_, memory_order_relaxed);"}, {"sha": "faa85acd696eb626330de3905f41098877d551e5", "filename": "libsanitizer/sanitizer_common/sanitizer_linux.cc", "status": "modified", "additions": 254, "deletions": 270, "changes": 524, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -11,9 +11,10 @@\n //===----------------------------------------------------------------------===//\n \n #include \"sanitizer_platform.h\"\n-#if SANITIZER_LINUX\n+#if SANITIZER_FREEBSD || SANITIZER_LINUX\n \n #include \"sanitizer_common.h\"\n+#include \"sanitizer_flags.h\"\n #include \"sanitizer_internal_defs.h\"\n #include \"sanitizer_libc.h\"\n #include \"sanitizer_linux.h\"\n@@ -23,7 +24,10 @@\n #include \"sanitizer_stacktrace.h\"\n #include \"sanitizer_symbolizer.h\"\n \n+#if !SANITIZER_FREEBSD\n #include <asm/param.h>\n+#endif\n+\n #include <dlfcn.h>\n #include <errno.h>\n #include <fcntl.h>\n@@ -42,10 +46,25 @@\n #include <unistd.h>\n #include <unwind.h>\n \n+#if SANITIZER_FREEBSD\n+#include <machine/atomic.h>\n+extern \"C\" {\n+// <sys/umtx.h> must be included after <errno.h> and <sys/types.h> on\n+// FreeBSD 9.2 and 10.0.\n+#include <sys/umtx.h>\n+}\n+#endif  // SANITIZER_FREEBSD\n+\n #if !SANITIZER_ANDROID\n #include <sys/signal.h>\n #endif\n \n+#if SANITIZER_ANDROID\n+#include <android/log.h>\n+#include <sys/system_properties.h>\n+#endif\n+\n+#if SANITIZER_LINUX\n // <linux/time.h>\n struct kernel_timeval {\n   long tv_sec;\n@@ -55,19 +74,20 @@ struct kernel_timeval {\n // <linux/futex.h> is broken on some linux distributions.\n const int FUTEX_WAIT = 0;\n const int FUTEX_WAKE = 1;\n+#endif  // SANITIZER_LINUX\n \n-// Are we using 32-bit or 64-bit syscalls?\n+// Are we using 32-bit or 64-bit Linux syscalls?\n // x32 (which defines __x86_64__) has SANITIZER_WORDSIZE == 32\n // but it still needs to use 64-bit syscalls.\n-#if defined(__x86_64__) || SANITIZER_WORDSIZE == 64\n+#if SANITIZER_LINUX && (defined(__x86_64__) || SANITIZER_WORDSIZE == 64)\n # define SANITIZER_LINUX_USES_64BIT_SYSCALLS 1\n #else\n # define SANITIZER_LINUX_USES_64BIT_SYSCALLS 0\n #endif\n \n namespace __sanitizer {\n \n-#ifdef __x86_64__\n+#if SANITIZER_LINUX && defined(__x86_64__)\n #include \"sanitizer_syscall_linux_x86_64.inc\"\n #else\n #include \"sanitizer_syscall_generic.inc\"\n@@ -76,28 +96,38 @@ namespace __sanitizer {\n // --------------- sanitizer_libc.h\n uptr internal_mmap(void *addr, uptr length, int prot, int flags,\n                     int fd, u64 offset) {\n-#if SANITIZER_LINUX_USES_64BIT_SYSCALLS\n-  return internal_syscall(__NR_mmap, (uptr)addr, length, prot, flags, fd,\n+#if SANITIZER_FREEBSD || SANITIZER_LINUX_USES_64BIT_SYSCALLS\n+  return internal_syscall(SYSCALL(mmap), (uptr)addr, length, prot, flags, fd,\n                           offset);\n #else\n-  return internal_syscall(__NR_mmap2, addr, length, prot, flags, fd, offset);\n+  return internal_syscall(SYSCALL(mmap2), addr, length, prot, flags, fd,\n+                          offset);\n #endif\n }\n \n uptr internal_munmap(void *addr, uptr length) {\n-  return internal_syscall(__NR_munmap, (uptr)addr, length);\n+  return internal_syscall(SYSCALL(munmap), (uptr)addr, length);\n }\n \n uptr internal_close(fd_t fd) {\n-  return internal_syscall(__NR_close, fd);\n+  return internal_syscall(SYSCALL(close), fd);\n }\n \n uptr internal_open(const char *filename, int flags) {\n-  return internal_syscall(__NR_open, (uptr)filename, flags);\n+#if SANITIZER_USES_CANONICAL_LINUX_SYSCALLS\n+  return internal_syscall(SYSCALL(openat), AT_FDCWD, (uptr)filename, flags);\n+#else\n+  return internal_syscall(SYSCALL(open), (uptr)filename, flags);\n+#endif\n }\n \n uptr internal_open(const char *filename, int flags, u32 mode) {\n-  return internal_syscall(__NR_open, (uptr)filename, flags, mode);\n+#if SANITIZER_USES_CANONICAL_LINUX_SYSCALLS\n+  return internal_syscall(SYSCALL(openat), AT_FDCWD, (uptr)filename, flags,\n+                          mode);\n+#else\n+  return internal_syscall(SYSCALL(open), (uptr)filename, flags, mode);\n+#endif\n }\n \n uptr OpenFile(const char *filename, bool write) {\n@@ -107,17 +137,19 @@ uptr OpenFile(const char *filename, bool write) {\n \n uptr internal_read(fd_t fd, void *buf, uptr count) {\n   sptr res;\n-  HANDLE_EINTR(res, (sptr)internal_syscall(__NR_read, fd, (uptr)buf, count));\n+  HANDLE_EINTR(res, (sptr)internal_syscall(SYSCALL(read), fd, (uptr)buf,\n+               count));\n   return res;\n }\n \n uptr internal_write(fd_t fd, const void *buf, uptr count) {\n   sptr res;\n-  HANDLE_EINTR(res, (sptr)internal_syscall(__NR_write, fd, (uptr)buf, count));\n+  HANDLE_EINTR(res, (sptr)internal_syscall(SYSCALL(write), fd, (uptr)buf,\n+               count));\n   return res;\n }\n \n-#if !SANITIZER_LINUX_USES_64BIT_SYSCALLS\n+#if !SANITIZER_LINUX_USES_64BIT_SYSCALLS && !SANITIZER_FREEBSD\n static void stat64_to_stat(struct stat64 *in, struct stat *out) {\n   internal_memset(out, 0, sizeof(*out));\n   out->st_dev = in->st_dev;\n@@ -138,33 +170,43 @@ static void stat64_to_stat(struct stat64 *in, struct stat *out) {\n #endif\n \n uptr internal_stat(const char *path, void *buf) {\n-#if SANITIZER_LINUX_USES_64BIT_SYSCALLS\n-  return internal_syscall(__NR_stat, (uptr)path, (uptr)buf);\n+#if SANITIZER_FREEBSD\n+  return internal_syscall(SYSCALL(stat), path, buf);\n+#elif SANITIZER_USES_CANONICAL_LINUX_SYSCALLS\n+  return internal_syscall(SYSCALL(newfstatat), AT_FDCWD, (uptr)path,\n+                          (uptr)buf, 0);\n+#elif SANITIZER_LINUX_USES_64BIT_SYSCALLS\n+  return internal_syscall(SYSCALL(stat), (uptr)path, (uptr)buf);\n #else\n   struct stat64 buf64;\n-  int res = internal_syscall(__NR_stat64, path, &buf64);\n+  int res = internal_syscall(SYSCALL(stat64), path, &buf64);\n   stat64_to_stat(&buf64, (struct stat *)buf);\n   return res;\n #endif\n }\n \n uptr internal_lstat(const char *path, void *buf) {\n-#if SANITIZER_LINUX_USES_64BIT_SYSCALLS\n-  return internal_syscall(__NR_lstat, (uptr)path, (uptr)buf);\n+#if SANITIZER_FREEBSD\n+  return internal_syscall(SYSCALL(lstat), path, buf);\n+#elif SANITIZER_USES_CANONICAL_LINUX_SYSCALLS\n+  return internal_syscall(SYSCALL(newfstatat), AT_FDCWD, (uptr)path,\n+                         (uptr)buf, AT_SYMLINK_NOFOLLOW);\n+#elif SANITIZER_LINUX_USES_64BIT_SYSCALLS\n+  return internal_syscall(SYSCALL(lstat), (uptr)path, (uptr)buf);\n #else\n   struct stat64 buf64;\n-  int res = internal_syscall(__NR_lstat64, path, &buf64);\n+  int res = internal_syscall(SYSCALL(lstat64), path, &buf64);\n   stat64_to_stat(&buf64, (struct stat *)buf);\n   return res;\n #endif\n }\n \n uptr internal_fstat(fd_t fd, void *buf) {\n-#if SANITIZER_LINUX_USES_64BIT_SYSCALLS\n-  return internal_syscall(__NR_fstat, fd, (uptr)buf);\n+#if SANITIZER_FREEBSD || SANITIZER_LINUX_USES_64BIT_SYSCALLS\n+  return internal_syscall(SYSCALL(fstat), fd, (uptr)buf);\n #else\n   struct stat64 buf64;\n-  int res = internal_syscall(__NR_fstat64, fd, &buf64);\n+  int res = internal_syscall(SYSCALL(fstat64), fd, &buf64);\n   stat64_to_stat(&buf64, (struct stat *)buf);\n   return res;\n #endif\n@@ -178,48 +220,80 @@ uptr internal_filesize(fd_t fd) {\n }\n \n uptr internal_dup2(int oldfd, int newfd) {\n-  return internal_syscall(__NR_dup2, oldfd, newfd);\n+#if SANITIZER_USES_CANONICAL_LINUX_SYSCALLS\n+  return internal_syscall(SYSCALL(dup3), oldfd, newfd, 0);\n+#else\n+  return internal_syscall(SYSCALL(dup2), oldfd, newfd);\n+#endif\n }\n \n uptr internal_readlink(const char *path, char *buf, uptr bufsize) {\n-  return internal_syscall(__NR_readlink, (uptr)path, (uptr)buf, bufsize);\n+#if SANITIZER_USES_CANONICAL_LINUX_SYSCALLS\n+  return internal_syscall(SYSCALL(readlinkat), AT_FDCWD,\n+                          (uptr)path, (uptr)buf, bufsize);\n+#else\n+  return internal_syscall(SYSCALL(readlink), (uptr)path, (uptr)buf, bufsize);\n+#endif\n }\n \n uptr internal_unlink(const char *path) {\n-  return internal_syscall(__NR_unlink, (uptr)path);\n+#if SANITIZER_USES_CANONICAL_LINUX_SYSCALLS\n+  return internal_syscall(SYSCALL(unlinkat), AT_FDCWD, (uptr)path, 0);\n+#else\n+  return internal_syscall(SYSCALL(unlink), (uptr)path);\n+#endif\n }\n \n uptr internal_sched_yield() {\n-  return internal_syscall(__NR_sched_yield);\n+  return internal_syscall(SYSCALL(sched_yield));\n }\n \n void internal__exit(int exitcode) {\n-  internal_syscall(__NR_exit_group, exitcode);\n+#if SANITIZER_FREEBSD\n+  internal_syscall(SYSCALL(exit), exitcode);\n+#else\n+  internal_syscall(SYSCALL(exit_group), exitcode);\n+#endif\n   Die();  // Unreachable.\n }\n \n uptr internal_execve(const char *filename, char *const argv[],\n                      char *const envp[]) {\n-  return internal_syscall(__NR_execve, (uptr)filename, (uptr)argv, (uptr)envp);\n+  return internal_syscall(SYSCALL(execve), (uptr)filename, (uptr)argv,\n+                          (uptr)envp);\n }\n \n // ----------------- sanitizer_common.h\n bool FileExists(const char *filename) {\n+#if SANITIZER_USES_CANONICAL_LINUX_SYSCALLS\n+  struct stat st;\n+  if (internal_syscall(SYSCALL(newfstatat), AT_FDCWD, filename, &st, 0))\n+    return false;\n+#else\n   struct stat st;\n   if (internal_stat(filename, &st))\n     return false;\n   // Sanity check: filename is a regular file.\n   return S_ISREG(st.st_mode);\n+#endif\n }\n \n uptr GetTid() {\n-  return internal_syscall(__NR_gettid);\n+#if SANITIZER_FREEBSD\n+  return (uptr)pthread_self();\n+#else\n+  return internal_syscall(SYSCALL(gettid));\n+#endif\n }\n \n u64 NanoTime() {\n+#if SANITIZER_FREEBSD\n+  timeval tv;\n+#else\n   kernel_timeval tv;\n+#endif\n   internal_memset(&tv, 0, sizeof(tv));\n-  internal_syscall(__NR_gettimeofday, (uptr)&tv, 0);\n+  internal_syscall(SYSCALL(gettimeofday), (uptr)&tv, 0);\n   return (u64)tv.tv_sec * 1000*1000*1000 + tv.tv_usec * 1000;\n }\n \n@@ -303,7 +377,18 @@ void ReExec() {\n   Die();\n }\n \n-void PrepareForSandboxing() {\n+// Stub implementation of GetThreadStackAndTls for Go.\n+#if SANITIZER_GO\n+void GetThreadStackAndTls(bool main, uptr *stk_addr, uptr *stk_size,\n+                          uptr *tls_addr, uptr *tls_size) {\n+  *stk_addr = 0;\n+  *stk_size = 0;\n+  *tls_addr = 0;\n+  *tls_size = 0;\n+}\n+#endif  // SANITIZER_GO\n+\n+void PrepareForSandboxing(__sanitizer_sandbox_arguments *args) {\n   // Some kinds of sandboxes may forbid filesystem access, so we won't be able\n   // to read the file mappings from /proc/self/maps. Luckily, neither the\n   // process will be able to load additional libraries, so it's fine to use the\n@@ -313,216 +398,10 @@ void PrepareForSandboxing() {\n #if !SANITIZER_GO\n   if (Symbolizer *sym = Symbolizer::GetOrNull())\n     sym->PrepareForSandboxing();\n+  CovPrepareForSandboxing(args);\n #endif\n }\n \n-// ----------------- sanitizer_procmaps.h\n-// Linker initialized.\n-ProcSelfMapsBuff MemoryMappingLayout::cached_proc_self_maps_;\n-StaticSpinMutex MemoryMappingLayout::cache_lock_;  // Linker initialized.\n-\n-MemoryMappingLayout::MemoryMappingLayout(bool cache_enabled) {\n-  proc_self_maps_.len =\n-      ReadFileToBuffer(\"/proc/self/maps\", &proc_self_maps_.data,\n-                       &proc_self_maps_.mmaped_size, 1 << 26);\n-  if (cache_enabled) {\n-    if (proc_self_maps_.mmaped_size == 0) {\n-      LoadFromCache();\n-      CHECK_GT(proc_self_maps_.len, 0);\n-    }\n-  } else {\n-    CHECK_GT(proc_self_maps_.mmaped_size, 0);\n-  }\n-  Reset();\n-  // FIXME: in the future we may want to cache the mappings on demand only.\n-  if (cache_enabled)\n-    CacheMemoryMappings();\n-}\n-\n-MemoryMappingLayout::~MemoryMappingLayout() {\n-  // Only unmap the buffer if it is different from the cached one. Otherwise\n-  // it will be unmapped when the cache is refreshed.\n-  if (proc_self_maps_.data != cached_proc_self_maps_.data) {\n-    UnmapOrDie(proc_self_maps_.data, proc_self_maps_.mmaped_size);\n-  }\n-}\n-\n-void MemoryMappingLayout::Reset() {\n-  current_ = proc_self_maps_.data;\n-}\n-\n-// static\n-void MemoryMappingLayout::CacheMemoryMappings() {\n-  SpinMutexLock l(&cache_lock_);\n-  // Don't invalidate the cache if the mappings are unavailable.\n-  ProcSelfMapsBuff old_proc_self_maps;\n-  old_proc_self_maps = cached_proc_self_maps_;\n-  cached_proc_self_maps_.len =\n-      ReadFileToBuffer(\"/proc/self/maps\", &cached_proc_self_maps_.data,\n-                       &cached_proc_self_maps_.mmaped_size, 1 << 26);\n-  if (cached_proc_self_maps_.mmaped_size == 0) {\n-    cached_proc_self_maps_ = old_proc_self_maps;\n-  } else {\n-    if (old_proc_self_maps.mmaped_size) {\n-      UnmapOrDie(old_proc_self_maps.data,\n-                 old_proc_self_maps.mmaped_size);\n-    }\n-  }\n-}\n-\n-void MemoryMappingLayout::LoadFromCache() {\n-  SpinMutexLock l(&cache_lock_);\n-  if (cached_proc_self_maps_.data) {\n-    proc_self_maps_ = cached_proc_self_maps_;\n-  }\n-}\n-\n-// Parse a hex value in str and update str.\n-static uptr ParseHex(char **str) {\n-  uptr x = 0;\n-  char *s;\n-  for (s = *str; ; s++) {\n-    char c = *s;\n-    uptr v = 0;\n-    if (c >= '0' && c <= '9')\n-      v = c - '0';\n-    else if (c >= 'a' && c <= 'f')\n-      v = c - 'a' + 10;\n-    else if (c >= 'A' && c <= 'F')\n-      v = c - 'A' + 10;\n-    else\n-      break;\n-    x = x * 16 + v;\n-  }\n-  *str = s;\n-  return x;\n-}\n-\n-static bool IsOneOf(char c, char c1, char c2) {\n-  return c == c1 || c == c2;\n-}\n-\n-static bool IsDecimal(char c) {\n-  return c >= '0' && c <= '9';\n-}\n-\n-static bool IsHex(char c) {\n-  return (c >= '0' && c <= '9')\n-      || (c >= 'a' && c <= 'f');\n-}\n-\n-static uptr ReadHex(const char *p) {\n-  uptr v = 0;\n-  for (; IsHex(p[0]); p++) {\n-    if (p[0] >= '0' && p[0] <= '9')\n-      v = v * 16 + p[0] - '0';\n-    else\n-      v = v * 16 + p[0] - 'a' + 10;\n-  }\n-  return v;\n-}\n-\n-static uptr ReadDecimal(const char *p) {\n-  uptr v = 0;\n-  for (; IsDecimal(p[0]); p++)\n-    v = v * 10 + p[0] - '0';\n-  return v;\n-}\n-\n-\n-bool MemoryMappingLayout::Next(uptr *start, uptr *end, uptr *offset,\n-                               char filename[], uptr filename_size,\n-                               uptr *protection) {\n-  char *last = proc_self_maps_.data + proc_self_maps_.len;\n-  if (current_ >= last) return false;\n-  uptr dummy;\n-  if (!start) start = &dummy;\n-  if (!end) end = &dummy;\n-  if (!offset) offset = &dummy;\n-  char *next_line = (char*)internal_memchr(current_, '\\n', last - current_);\n-  if (next_line == 0)\n-    next_line = last;\n-  // Example: 08048000-08056000 r-xp 00000000 03:0c 64593   /foo/bar\n-  *start = ParseHex(&current_);\n-  CHECK_EQ(*current_++, '-');\n-  *end = ParseHex(&current_);\n-  CHECK_EQ(*current_++, ' ');\n-  uptr local_protection = 0;\n-  CHECK(IsOneOf(*current_, '-', 'r'));\n-  if (*current_++ == 'r')\n-    local_protection |= kProtectionRead;\n-  CHECK(IsOneOf(*current_, '-', 'w'));\n-  if (*current_++ == 'w')\n-    local_protection |= kProtectionWrite;\n-  CHECK(IsOneOf(*current_, '-', 'x'));\n-  if (*current_++ == 'x')\n-    local_protection |= kProtectionExecute;\n-  CHECK(IsOneOf(*current_, 's', 'p'));\n-  if (*current_++ == 's')\n-    local_protection |= kProtectionShared;\n-  if (protection) {\n-    *protection = local_protection;\n-  }\n-  CHECK_EQ(*current_++, ' ');\n-  *offset = ParseHex(&current_);\n-  CHECK_EQ(*current_++, ' ');\n-  ParseHex(&current_);\n-  CHECK_EQ(*current_++, ':');\n-  ParseHex(&current_);\n-  CHECK_EQ(*current_++, ' ');\n-  while (IsDecimal(*current_))\n-    current_++;\n-  // Qemu may lack the trailing space.\n-  // http://code.google.com/p/address-sanitizer/issues/detail?id=160\n-  // CHECK_EQ(*current_++, ' ');\n-  // Skip spaces.\n-  while (current_ < next_line && *current_ == ' ')\n-    current_++;\n-  // Fill in the filename.\n-  uptr i = 0;\n-  while (current_ < next_line) {\n-    if (filename && i < filename_size - 1)\n-      filename[i++] = *current_;\n-    current_++;\n-  }\n-  if (filename && i < filename_size)\n-    filename[i] = 0;\n-  current_ = next_line + 1;\n-  return true;\n-}\n-\n-// Gets the object name and the offset by walking MemoryMappingLayout.\n-bool MemoryMappingLayout::GetObjectNameAndOffset(uptr addr, uptr *offset,\n-                                                 char filename[],\n-                                                 uptr filename_size,\n-                                                 uptr *protection) {\n-  return IterateForObjectNameAndOffset(addr, offset, filename, filename_size,\n-                                       protection);\n-}\n-\n-void GetMemoryProfile(fill_profile_f cb, uptr *stats, uptr stats_size) {\n-  char *smaps = 0;\n-  uptr smaps_cap = 0;\n-  uptr smaps_len = ReadFileToBuffer(\"/proc/self/smaps\",\n-      &smaps, &smaps_cap, 64<<20);\n-  uptr start = 0;\n-  bool file = false;\n-  const char *pos = smaps;\n-  while (pos < smaps + smaps_len) {\n-    if (IsHex(pos[0])) {\n-      start = ReadHex(pos);\n-      for (; *pos != '/' && *pos > '\\n'; pos++) {}\n-      file = *pos == '/';\n-    } else if (internal_strncmp(pos, \"Rss:\", 4) == 0) {\n-      for (; *pos < '0' || *pos > '9'; pos++) {}\n-      uptr rss = ReadDecimal(pos) * 1024;\n-      cb(start, rss, file, stats, stats_size);\n-    }\n-    while (*pos++ != '\\n') {}\n-  }\n-  UnmapOrDie(smaps, smaps_cap);\n-}\n-\n enum MutexState {\n   MtxUnlocked = 0,\n   MtxLocked = 1,\n@@ -541,16 +420,26 @@ void BlockingMutex::Lock() {\n   atomic_uint32_t *m = reinterpret_cast<atomic_uint32_t *>(&opaque_storage_);\n   if (atomic_exchange(m, MtxLocked, memory_order_acquire) == MtxUnlocked)\n     return;\n-  while (atomic_exchange(m, MtxSleeping, memory_order_acquire) != MtxUnlocked)\n-    internal_syscall(__NR_futex, (uptr)m, FUTEX_WAIT, MtxSleeping, 0, 0, 0);\n+  while (atomic_exchange(m, MtxSleeping, memory_order_acquire) != MtxUnlocked) {\n+#if SANITIZER_FREEBSD\n+    _umtx_op(m, UMTX_OP_WAIT_UINT, MtxSleeping, 0, 0);\n+#else\n+    internal_syscall(SYSCALL(futex), (uptr)m, FUTEX_WAIT, MtxSleeping, 0, 0, 0);\n+#endif\n+  }\n }\n \n void BlockingMutex::Unlock() {\n   atomic_uint32_t *m = reinterpret_cast<atomic_uint32_t *>(&opaque_storage_);\n   u32 v = atomic_exchange(m, MtxUnlocked, memory_order_relaxed);\n   CHECK_NE(v, MtxUnlocked);\n-  if (v == MtxSleeping)\n-    internal_syscall(__NR_futex, (uptr)m, FUTEX_WAKE, 1, 0, 0, 0);\n+  if (v == MtxSleeping) {\n+#if SANITIZER_FREEBSD\n+    _umtx_op(m, UMTX_OP_WAKE, 1, 0, 0);\n+#else\n+    internal_syscall(SYSCALL(futex), (uptr)m, FUTEX_WAKE, 1, 0, 0, 0);\n+#endif\n+  }\n }\n \n void BlockingMutex::CheckLocked() {\n@@ -563,71 +452,133 @@ void BlockingMutex::CheckLocked() {\n // Note that getdents64 uses a different structure format. We only provide the\n // 32-bit syscall here.\n struct linux_dirent {\n+#if SANITIZER_X32\n+  u64 d_ino;\n+  u64 d_off;\n+#else\n   unsigned long      d_ino;\n   unsigned long      d_off;\n+#endif\n   unsigned short     d_reclen;\n   char               d_name[256];\n };\n \n // Syscall wrappers.\n uptr internal_ptrace(int request, int pid, void *addr, void *data) {\n-  return internal_syscall(__NR_ptrace, request, pid, (uptr)addr, (uptr)data);\n+  return internal_syscall(SYSCALL(ptrace), request, pid, (uptr)addr,\n+                          (uptr)data);\n }\n \n uptr internal_waitpid(int pid, int *status, int options) {\n-  return internal_syscall(__NR_wait4, pid, (uptr)status, options,\n+  return internal_syscall(SYSCALL(wait4), pid, (uptr)status, options,\n                           0 /* rusage */);\n }\n \n uptr internal_getpid() {\n-  return internal_syscall(__NR_getpid);\n+  return internal_syscall(SYSCALL(getpid));\n }\n \n uptr internal_getppid() {\n-  return internal_syscall(__NR_getppid);\n+  return internal_syscall(SYSCALL(getppid));\n }\n \n uptr internal_getdents(fd_t fd, struct linux_dirent *dirp, unsigned int count) {\n-  return internal_syscall(__NR_getdents, fd, (uptr)dirp, count);\n+#if SANITIZER_USES_CANONICAL_LINUX_SYSCALLS\n+  return internal_syscall(SYSCALL(getdents64), fd, (uptr)dirp, count);\n+#else\n+  return internal_syscall(SYSCALL(getdents), fd, (uptr)dirp, count);\n+#endif\n }\n \n uptr internal_lseek(fd_t fd, OFF_T offset, int whence) {\n-  return internal_syscall(__NR_lseek, fd, offset, whence);\n+  return internal_syscall(SYSCALL(lseek), fd, offset, whence);\n }\n \n+#if SANITIZER_LINUX\n uptr internal_prctl(int option, uptr arg2, uptr arg3, uptr arg4, uptr arg5) {\n-  return internal_syscall(__NR_prctl, option, arg2, arg3, arg4, arg5);\n+  return internal_syscall(SYSCALL(prctl), option, arg2, arg3, arg4, arg5);\n }\n+#endif\n \n uptr internal_sigaltstack(const struct sigaltstack *ss,\n                          struct sigaltstack *oss) {\n-  return internal_syscall(__NR_sigaltstack, (uptr)ss, (uptr)oss);\n+  return internal_syscall(SYSCALL(sigaltstack), (uptr)ss, (uptr)oss);\n }\n \n-uptr internal_sigaction(int signum, const __sanitizer_kernel_sigaction_t *act,\n-    __sanitizer_kernel_sigaction_t *oldact) {\n-  return internal_syscall(__NR_rt_sigaction, signum, act, oldact,\n-      sizeof(__sanitizer_kernel_sigset_t));\n+int internal_fork() {\n+  return internal_syscall(SYSCALL(fork));\n }\n \n-uptr internal_sigprocmask(int how, __sanitizer_kernel_sigset_t *set,\n-    __sanitizer_kernel_sigset_t *oldset) {\n-  return internal_syscall(__NR_rt_sigprocmask, (uptr)how, &set->sig[0],\n-      &oldset->sig[0], sizeof(__sanitizer_kernel_sigset_t));\n+#if SANITIZER_LINUX\n+// Doesn't set sa_restorer, use with caution (see below).\n+int internal_sigaction_norestorer(int signum, const void *act, void *oldact) {\n+  __sanitizer_kernel_sigaction_t k_act, k_oldact;\n+  internal_memset(&k_act, 0, sizeof(__sanitizer_kernel_sigaction_t));\n+  internal_memset(&k_oldact, 0, sizeof(__sanitizer_kernel_sigaction_t));\n+  const __sanitizer_sigaction *u_act = (__sanitizer_sigaction *)act;\n+  __sanitizer_sigaction *u_oldact = (__sanitizer_sigaction *)oldact;\n+  if (u_act) {\n+    k_act.handler = u_act->handler;\n+    k_act.sigaction = u_act->sigaction;\n+    internal_memcpy(&k_act.sa_mask, &u_act->sa_mask,\n+                    sizeof(__sanitizer_kernel_sigset_t));\n+    k_act.sa_flags = u_act->sa_flags;\n+    // FIXME: most often sa_restorer is unset, however the kernel requires it\n+    // to point to a valid signal restorer that calls the rt_sigreturn syscall.\n+    // If sa_restorer passed to the kernel is NULL, the program may crash upon\n+    // signal delivery or fail to unwind the stack in the signal handler.\n+    // libc implementation of sigaction() passes its own restorer to\n+    // rt_sigaction, so we need to do the same (we'll need to reimplement the\n+    // restorers; for x86_64 the restorer address can be obtained from\n+    // oldact->sa_restorer upon a call to sigaction(xxx, NULL, oldact).\n+    k_act.sa_restorer = u_act->sa_restorer;\n+  }\n+\n+  uptr result = internal_syscall(SYSCALL(rt_sigaction), (uptr)signum,\n+      (uptr)(u_act ? &k_act : NULL),\n+      (uptr)(u_oldact ? &k_oldact : NULL),\n+      (uptr)sizeof(__sanitizer_kernel_sigset_t));\n+\n+  if ((result == 0) && u_oldact) {\n+    u_oldact->handler = k_oldact.handler;\n+    u_oldact->sigaction = k_oldact.sigaction;\n+    internal_memcpy(&u_oldact->sa_mask, &k_oldact.sa_mask,\n+                    sizeof(__sanitizer_kernel_sigset_t));\n+    u_oldact->sa_flags = k_oldact.sa_flags;\n+    u_oldact->sa_restorer = k_oldact.sa_restorer;\n+  }\n+  return result;\n }\n+#endif  // SANITIZER_LINUX\n \n-void internal_sigfillset(__sanitizer_kernel_sigset_t *set) {\n+uptr internal_sigprocmask(int how, __sanitizer_sigset_t *set,\n+    __sanitizer_sigset_t *oldset) {\n+#if SANITIZER_FREEBSD\n+  return internal_syscall(SYSCALL(sigprocmask), how, set, oldset);\n+#else\n+  __sanitizer_kernel_sigset_t *k_set = (__sanitizer_kernel_sigset_t *)set;\n+  __sanitizer_kernel_sigset_t *k_oldset = (__sanitizer_kernel_sigset_t *)oldset;\n+  return internal_syscall(SYSCALL(rt_sigprocmask), (uptr)how,\n+                          (uptr)&k_set->sig[0], (uptr)&k_oldset->sig[0],\n+                          sizeof(__sanitizer_kernel_sigset_t));\n+#endif\n+}\n+\n+void internal_sigfillset(__sanitizer_sigset_t *set) {\n   internal_memset(set, 0xff, sizeof(*set));\n }\n \n-void internal_sigdelset(__sanitizer_kernel_sigset_t *set, int signum) {\n+#if SANITIZER_LINUX\n+void internal_sigdelset(__sanitizer_sigset_t *set, int signum) {\n   signum -= 1;\n   CHECK_GE(signum, 0);\n   CHECK_LT(signum, sizeof(*set) * 8);\n-  const uptr idx = signum / (sizeof(set->sig[0]) * 8);\n-  const uptr bit = signum % (sizeof(set->sig[0]) * 8);\n-  set->sig[idx] &= ~(1 << bit);\n+  __sanitizer_kernel_sigset_t *k_set = (__sanitizer_kernel_sigset_t *)set;\n+  const uptr idx = signum / (sizeof(k_set->sig[0]) * 8);\n+  const uptr bit = signum % (sizeof(k_set->sig[0]) * 8);\n+  k_set->sig[idx] &= ~(1 << bit);\n }\n+#endif  // SANITIZER_LINUX\n \n // ThreadLister implementation.\n ThreadLister::ThreadLister(int pid)\n@@ -698,7 +649,7 @@ bool ThreadLister::GetDirectoryEntries() {\n }\n \n uptr GetPageSize() {\n-#if defined(__x86_64__) || defined(__i386__)\n+#if SANITIZER_LINUX && (defined(__x86_64__) || defined(__i386__))\n   return EXEC_PAGESIZE;\n #else\n   return sysconf(_SC_PAGESIZE);  // EXEC_PAGESIZE may not be trustworthy.\n@@ -753,8 +704,10 @@ bool LibraryNameIs(const char *full_name, const char *base_name) {\n #if !SANITIZER_ANDROID\n // Call cb for each region mapped by map.\n void ForEachMappedRegion(link_map *map, void (*cb)(const void *, uptr)) {\n+#if !SANITIZER_FREEBSD\n   typedef ElfW(Phdr) Elf_Phdr;\n   typedef ElfW(Ehdr) Elf_Ehdr;\n+#endif  // !SANITIZER_FREEBSD\n   char *base = (char *)map->l_addr;\n   Elf_Ehdr *ehdr = (Elf_Ehdr *)base;\n   char *phdrs = base + ehdr->e_phoff;\n@@ -788,7 +741,7 @@ void ForEachMappedRegion(link_map *map, void (*cb)(const void *, uptr)) {\n }\n #endif\n \n-#if defined(__x86_64__)\n+#if defined(__x86_64__) && SANITIZER_LINUX\n // We cannot use glibc's clone wrapper, because it messes with the child\n // task's TLS. It writes the PID and TID of the child task to its thread\n // descriptor, but in our case the child task shares the thread descriptor with\n@@ -807,7 +760,7 @@ uptr internal_clone(int (*fn)(void *), void *child_stack, int flags, void *arg,\n   register void *r8 __asm__(\"r8\") = newtls;\n   register int *r10 __asm__(\"r10\") = child_tidptr;\n   __asm__ __volatile__(\n-                       /* %rax = syscall(%rax = __NR_clone,\n+                       /* %rax = syscall(%rax = SYSCALL(clone),\n                         *                %rdi = flags,\n                         *                %rsi = child_stack,\n                         *                %rdx = parent_tidptr,\n@@ -841,7 +794,7 @@ uptr internal_clone(int (*fn)(void *), void *child_stack, int flags, void *arg,\n                        /* Return to parent. */\n                      \"1:\\n\"\n                        : \"=a\" (res)\n-                       : \"a\"(__NR_clone), \"i\"(__NR_exit),\n+                       : \"a\"(SYSCALL(clone)), \"i\"(SYSCALL(exit)),\n                          \"S\"(child_stack),\n                          \"D\"(flags),\n                          \"d\"(parent_tidptr),\n@@ -850,7 +803,38 @@ uptr internal_clone(int (*fn)(void *), void *child_stack, int flags, void *arg,\n                        : \"rsp\", \"memory\", \"r11\", \"rcx\");\n   return res;\n }\n-#endif  // defined(__x86_64__)\n+#endif  // defined(__x86_64__) && SANITIZER_LINUX\n+\n+#if SANITIZER_ANDROID\n+// This thing is not, strictly speaking, async signal safe, but it does not seem\n+// to cause any issues. Alternative is writing to log devices directly, but\n+// their location and message format might change in the future, so we'd really\n+// like to avoid that.\n+void AndroidLogWrite(const char *buffer) {\n+  char *copy = internal_strdup(buffer);\n+  char *p = copy;\n+  char *q;\n+  // __android_log_write has an implicit message length limit.\n+  // Print one line at a time.\n+  do {\n+    q = internal_strchr(p, '\\n');\n+    if (q) *q = '\\0';\n+    __android_log_write(ANDROID_LOG_INFO, NULL, p);\n+    if (q) p = q + 1;\n+  } while (q);\n+  InternalFree(copy);\n+}\n+\n+void GetExtraActivationFlags(char *buf, uptr size) {\n+  CHECK(size > PROP_VALUE_MAX);\n+  __system_property_get(\"asan.options\", buf);\n+}\n+#endif\n+\n+bool IsDeadlySignal(int signum) {\n+  return (signum == SIGSEGV) && common_flags()->handle_segv;\n+}\n+\n }  // namespace __sanitizer\n \n-#endif  // SANITIZER_LINUX\n+#endif  // SANITIZER_FREEBSD || SANITIZER_LINUX"}, {"sha": "086834c3a2f9dd26c638dd9a3153968527cd5dd5", "filename": "libsanitizer/sanitizer_common/sanitizer_linux.h", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -12,7 +12,7 @@\n #define SANITIZER_LINUX_H\n \n #include \"sanitizer_platform.h\"\n-#if SANITIZER_LINUX\n+#if SANITIZER_FREEBSD || SANITIZER_LINUX\n #include \"sanitizer_common.h\"\n #include \"sanitizer_internal_defs.h\"\n #include \"sanitizer_platform_limits_posix.h\"\n@@ -27,20 +27,25 @@ struct linux_dirent;\n \n // Syscall wrappers.\n uptr internal_getdents(fd_t fd, struct linux_dirent *dirp, unsigned int count);\n-uptr internal_prctl(int option, uptr arg2, uptr arg3, uptr arg4, uptr arg5);\n uptr internal_sigaltstack(const struct sigaltstack* ss,\n                           struct sigaltstack* oss);\n-uptr internal_sigaction(int signum, const __sanitizer_kernel_sigaction_t *act,\n-    __sanitizer_kernel_sigaction_t *oldact);\n-uptr internal_sigprocmask(int how, __sanitizer_kernel_sigset_t *set,\n-    __sanitizer_kernel_sigset_t *oldset);\n-void internal_sigfillset(__sanitizer_kernel_sigset_t *set);\n-void internal_sigdelset(__sanitizer_kernel_sigset_t *set, int signum);\n+uptr internal_sigprocmask(int how, __sanitizer_sigset_t *set,\n+    __sanitizer_sigset_t *oldset);\n+void internal_sigfillset(__sanitizer_sigset_t *set);\n \n-#ifdef __x86_64__\n+// Linux-only syscalls.\n+#if SANITIZER_LINUX\n+uptr internal_prctl(int option, uptr arg2, uptr arg3, uptr arg4, uptr arg5);\n+// Used only by sanitizer_stoptheworld. Signal handlers that are actually used\n+// (like the process-wide error reporting SEGV handler) must use\n+// internal_sigaction instead.\n+int internal_sigaction_norestorer(int signum, const void *act, void *oldact);\n+void internal_sigdelset(__sanitizer_sigset_t *set, int signum);\n+#if defined(__x86_64__)\n uptr internal_clone(int (*fn)(void *), void *child_stack, int flags, void *arg,\n                     int *parent_tidptr, void *newtls, int *child_tidptr);\n #endif\n+#endif  // SANITIZER_LINUX\n \n // This class reads thread IDs from /proc/<pid>/task using only syscalls.\n class ThreadLister {\n@@ -64,8 +69,6 @@ class ThreadLister {\n   int bytes_read_;\n };\n \n-void AdjustStackSizeLinux(void *attr);\n-\n // Exposed for testing.\n uptr ThreadDescriptorSize();\n uptr ThreadSelf();\n@@ -84,5 +87,5 @@ void CacheBinaryName();\n void ForEachMappedRegion(link_map *map, void (*cb)(const void *, uptr));\n }  // namespace __sanitizer\n \n-#endif  // SANITIZER_LINUX\n+#endif  // SANITIZER_FREEBSD || SANITIZER_LINUX\n #endif  // SANITIZER_LINUX_H"}, {"sha": "e754b26e693d35ae89c852555d650b3c0befa661", "filename": "libsanitizer/sanitizer_common/sanitizer_linux_libcdep.cc", "status": "modified", "additions": 202, "deletions": 53, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_libcdep.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -11,7 +11,7 @@\n //===----------------------------------------------------------------------===//\n \n #include \"sanitizer_platform.h\"\n-#if SANITIZER_LINUX\n+#if SANITIZER_FREEBSD || SANITIZER_LINUX\n \n #include \"sanitizer_common.h\"\n #include \"sanitizer_flags.h\"\n@@ -23,27 +23,53 @@\n \n #include <dlfcn.h>\n #include <pthread.h>\n-#include <sys/prctl.h>\n+#include <signal.h>\n #include <sys/resource.h>\n+#if SANITIZER_FREEBSD\n+#define _GNU_SOURCE  // to declare _Unwind_Backtrace() from <unwind.h>\n+#endif\n #include <unwind.h>\n \n+#if SANITIZER_FREEBSD\n+#include <pthread_np.h>\n+#define pthread_getattr_np pthread_attr_get_np\n+#endif\n+\n+#if SANITIZER_LINUX\n+#include <sys/prctl.h>\n+#endif\n+\n #if !SANITIZER_ANDROID\n #include <elf.h>\n #include <link.h>\n #include <unistd.h>\n #endif\n \n+namespace __sanitizer {\n+\n // This function is defined elsewhere if we intercepted pthread_attr_getstack.\n-SANITIZER_WEAK_ATTRIBUTE\n-int __sanitizer_pthread_attr_getstack(void *attr, void **addr, size_t *size) {\n-  return pthread_attr_getstack((pthread_attr_t*)attr, addr, size);\n+extern \"C\" {\n+SANITIZER_WEAK_ATTRIBUTE int\n+real_pthread_attr_getstack(void *attr, void **addr, size_t *size);\n+}  // extern \"C\"\n+\n+static int my_pthread_attr_getstack(void *attr, void **addr, size_t *size) {\n+  if (real_pthread_attr_getstack)\n+    return real_pthread_attr_getstack((pthread_attr_t *)attr, addr, size);\n+  return pthread_attr_getstack((pthread_attr_t *)attr, addr, size);\n }\n \n-namespace __sanitizer {\n+SANITIZER_WEAK_ATTRIBUTE int\n+real_sigaction(int signum, const void *act, void *oldact);\n+\n+int internal_sigaction(int signum, const void *act, void *oldact) {\n+  if (real_sigaction)\n+    return real_sigaction(signum, act, oldact);\n+  return sigaction(signum, (struct sigaction *)act, (struct sigaction *)oldact);\n+}\n \n void GetThreadStackTopAndBottom(bool at_initialization, uptr *stack_top,\n                                 uptr *stack_bottom) {\n-  static const uptr kMaxThreadStackSize = 1 << 30;  // 1Gb\n   CHECK(stack_top);\n   CHECK(stack_bottom);\n   if (at_initialization) {\n@@ -77,19 +103,18 @@ void GetThreadStackTopAndBottom(bool at_initialization, uptr *stack_top,\n     return;\n   }\n   pthread_attr_t attr;\n+  pthread_attr_init(&attr);\n   CHECK_EQ(pthread_getattr_np(pthread_self(), &attr), 0);\n   uptr stacksize = 0;\n   void *stackaddr = 0;\n-  __sanitizer_pthread_attr_getstack(&attr, &stackaddr, (size_t*)&stacksize);\n+  my_pthread_attr_getstack(&attr, &stackaddr, (size_t*)&stacksize);\n   pthread_attr_destroy(&attr);\n \n   CHECK_LE(stacksize, kMaxThreadStackSize);  // Sanity check.\n   *stack_top = (uptr)stackaddr + stacksize;\n   *stack_bottom = (uptr)stackaddr;\n }\n \n-// Does not compile for Go because dlsym() requires -ldl\n-#ifndef SANITIZER_GO\n bool SetEnv(const char *name, const char *value) {\n   void *f = dlsym(RTLD_NEXT, \"setenv\");\n   if (f == 0)\n@@ -98,9 +123,8 @@ bool SetEnv(const char *name, const char *value) {\n   setenv_ft setenv_f;\n   CHECK_EQ(sizeof(setenv_f), sizeof(f));\n   internal_memcpy(&setenv_f, &f, sizeof(f));\n-  return setenv_f(name, value, 1) == 0;\n+  return IndirectExternCall(setenv_f)(name, value, 1) == 0;\n }\n-#endif\n \n bool SanitizerSetThreadName(const char *name) {\n #ifdef PR_SET_NAME\n@@ -123,8 +147,52 @@ bool SanitizerGetThreadName(char *name, int max_len) {\n #endif\n }\n \n-#ifndef SANITIZER_GO\n //------------------------- SlowUnwindStack -----------------------------------\n+\n+typedef struct {\n+  uptr absolute_pc;\n+  uptr stack_top;\n+  uptr stack_size;\n+} backtrace_frame_t;\n+\n+extern \"C\" {\n+typedef void *(*acquire_my_map_info_list_func)();\n+typedef void (*release_my_map_info_list_func)(void *map);\n+typedef sptr (*unwind_backtrace_signal_arch_func)(\n+    void *siginfo, void *sigcontext, void *map_info_list,\n+    backtrace_frame_t *backtrace, uptr ignore_depth, uptr max_depth);\n+acquire_my_map_info_list_func acquire_my_map_info_list;\n+release_my_map_info_list_func release_my_map_info_list;\n+unwind_backtrace_signal_arch_func unwind_backtrace_signal_arch;\n+} // extern \"C\"\n+\n+#if SANITIZER_ANDROID\n+void SanitizerInitializeUnwinder() {\n+  void *p = dlopen(\"libcorkscrew.so\", RTLD_LAZY);\n+  if (!p) {\n+    VReport(1,\n+            \"Failed to open libcorkscrew.so. You may see broken stack traces \"\n+            \"in SEGV reports.\");\n+    return;\n+  }\n+  acquire_my_map_info_list =\n+      (acquire_my_map_info_list_func)(uptr)dlsym(p, \"acquire_my_map_info_list\");\n+  release_my_map_info_list =\n+      (release_my_map_info_list_func)(uptr)dlsym(p, \"release_my_map_info_list\");\n+  unwind_backtrace_signal_arch = (unwind_backtrace_signal_arch_func)(uptr)dlsym(\n+      p, \"unwind_backtrace_signal_arch\");\n+  if (!acquire_my_map_info_list || !release_my_map_info_list ||\n+      !unwind_backtrace_signal_arch) {\n+    VReport(1,\n+            \"Failed to find one of the required symbols in libcorkscrew.so. \"\n+            \"You may see broken stack traces in SEGV reports.\");\n+    acquire_my_map_info_list = NULL;\n+    unwind_backtrace_signal_arch = NULL;\n+    release_my_map_info_list = NULL;\n+  }\n+}\n+#endif\n+\n #ifdef __arm__\n #define UNWIND_STOP _URC_END_OF_STACK\n #define UNWIND_CONTINUE _URC_NO_REASON\n@@ -161,9 +229,8 @@ _Unwind_Reason_Code Unwind_Trace(struct _Unwind_Context *ctx, void *param) {\n }\n \n void StackTrace::SlowUnwindStack(uptr pc, uptr max_depth) {\n+  CHECK_GE(max_depth, 2);\n   size = 0;\n-  if (max_depth == 0)\n-    return;\n   UnwindTraceArg arg = {this, Min(max_depth + 1, kStackTraceMax)};\n   _Unwind_Backtrace(Unwind_Trace, &arg);\n   // We need to pop a few frames so that pc is on top.\n@@ -175,9 +242,35 @@ void StackTrace::SlowUnwindStack(uptr pc, uptr max_depth) {\n   trace[0] = pc;\n }\n \n-#endif  // !SANITIZER_GO\n+void StackTrace::SlowUnwindStackWithContext(uptr pc, void *context,\n+                                            uptr max_depth) {\n+  CHECK_GE(max_depth, 2);\n+  if (!unwind_backtrace_signal_arch) {\n+    SlowUnwindStack(pc, max_depth);\n+    return;\n+  }\n+\n+  void *map = acquire_my_map_info_list();\n+  CHECK(map);\n+  InternalScopedBuffer<backtrace_frame_t> frames(kStackTraceMax);\n+  // siginfo argument appears to be unused.\n+  sptr res = unwind_backtrace_signal_arch(/* siginfo */ NULL, context, map,\n+                                          frames.data(),\n+                                          /* ignore_depth */ 0, max_depth);\n+  release_my_map_info_list(map);\n+  if (res < 0) return;\n+  CHECK_LE((uptr)res, kStackTraceMax);\n+\n+  size = 0;\n+  // +2 compensate for libcorkscrew unwinder returning addresses of call\n+  // instructions instead of raw return addresses.\n+  for (sptr i = 0; i < res; ++i)\n+    trace[size++] = frames[i].absolute_pc + 2;\n+}\n \n+#if !SANITIZER_FREEBSD\n static uptr g_tls_size;\n+#endif\n \n #ifdef __i386__\n # define DL_INTERNAL_FUNCTION __attribute__((regparm(3), stdcall))\n@@ -186,7 +279,7 @@ static uptr g_tls_size;\n #endif\n \n void InitTlsSize() {\n-#if !defined(SANITIZER_GO) && !SANITIZER_ANDROID\n+#if !SANITIZER_FREEBSD && !SANITIZER_ANDROID\n   typedef void (*get_tls_func)(size_t*, size_t*) DL_INTERNAL_FUNCTION;\n   get_tls_func get_tls;\n   void *get_tls_static_info_ptr = dlsym(RTLD_NEXT, \"_dl_get_tls_static_info\");\n@@ -196,16 +289,12 @@ void InitTlsSize() {\n   CHECK_NE(get_tls, 0);\n   size_t tls_size = 0;\n   size_t tls_align = 0;\n-  get_tls(&tls_size, &tls_align);\n+  IndirectExternCall(get_tls)(&tls_size, &tls_align);\n   g_tls_size = tls_size;\n-#endif\n-}\n-\n-uptr GetTlsSize() {\n-  return g_tls_size;\n+#endif  // !SANITIZER_FREEBSD && !SANITIZER_ANDROID\n }\n \n-#if defined(__x86_64__) || defined(__i386__)\n+#if (defined(__x86_64__) || defined(__i386__)) && SANITIZER_LINUX\n // sizeof(struct thread) from glibc.\n static atomic_uintptr_t kThreadDescriptorSize;\n \n@@ -221,7 +310,9 @@ uptr ThreadDescriptorSize() {\n     int minor = internal_simple_strtoll(buf + 8, &end, 10);\n     if (end != buf + 8 && (*end == '\\0' || *end == '.')) {\n       /* sizeof(struct thread) values from various glibc versions.  */\n-      if (minor <= 3)\n+      if (SANITIZER_X32)\n+        val = 1728;  // Assume only one particular version for x32.\n+      else if (minor <= 3)\n         val = FIRST_32_SECOND_64(1104, 1696);\n       else if (minor == 4)\n         val = FIRST_32_SECOND_64(1120, 1728);\n@@ -253,27 +344,79 @@ uptr ThreadSelfOffset() {\n \n uptr ThreadSelf() {\n   uptr descr_addr;\n-#ifdef __i386__\n+# if defined(__i386__)\n   asm(\"mov %%gs:%c1,%0\" : \"=r\"(descr_addr) : \"i\"(kThreadSelfOffset));\n-#else\n+# elif defined(__x86_64__)\n   asm(\"mov %%fs:%c1,%0\" : \"=r\"(descr_addr) : \"i\"(kThreadSelfOffset));\n-#endif\n+# else\n+#  error \"unsupported CPU arch\"\n+# endif\n   return descr_addr;\n }\n-#endif  // defined(__x86_64__) || defined(__i386__)\n+#endif  // (defined(__x86_64__) || defined(__i386__)) && SANITIZER_LINUX\n+\n+#if SANITIZER_FREEBSD\n+static void **ThreadSelfSegbase() {\n+  void **segbase = 0;\n+# if defined(__i386__)\n+  // sysarch(I386_GET_GSBASE, segbase);\n+  __asm __volatile(\"mov %%gs:0, %0\" : \"=r\" (segbase));\n+# elif defined(__x86_64__)\n+  // sysarch(AMD64_GET_FSBASE, segbase);\n+  __asm __volatile(\"movq %%fs:0, %0\" : \"=r\" (segbase));\n+# else\n+#  error \"unsupported CPU arch for FreeBSD platform\"\n+# endif\n+  return segbase;\n+}\n \n-void GetThreadStackAndTls(bool main, uptr *stk_addr, uptr *stk_size,\n-                          uptr *tls_addr, uptr *tls_size) {\n-#ifndef SANITIZER_GO\n-#if defined(__x86_64__) || defined(__i386__)\n-  *tls_addr = ThreadSelf();\n-  *tls_size = GetTlsSize();\n-  *tls_addr -= *tls_size;\n-  *tls_addr += ThreadDescriptorSize();\n+uptr ThreadSelf() {\n+  return (uptr)ThreadSelfSegbase()[2];\n+}\n+#endif  // SANITIZER_FREEBSD\n+\n+static void GetTls(uptr *addr, uptr *size) {\n+#if SANITIZER_LINUX\n+# if defined(__x86_64__) || defined(__i386__)\n+  *addr = ThreadSelf();\n+  *size = GetTlsSize();\n+  *addr -= *size;\n+  *addr += ThreadDescriptorSize();\n+# else\n+  *addr = 0;\n+  *size = 0;\n+# endif\n+#elif SANITIZER_FREEBSD\n+  void** segbase = ThreadSelfSegbase();\n+  *addr = 0;\n+  *size = 0;\n+  if (segbase != 0) {\n+    // tcbalign = 16\n+    // tls_size = round(tls_static_space, tcbalign);\n+    // dtv = segbase[1];\n+    // dtv[2] = segbase - tls_static_space;\n+    void **dtv = (void**) segbase[1];\n+    *addr = (uptr) dtv[2];\n+    *size = (*addr == 0) ? 0 : ((uptr) segbase[0] - (uptr) dtv[2]);\n+  }\n+#else\n+# error \"Unknown OS\"\n+#endif\n+}\n+\n+uptr GetTlsSize() {\n+#if SANITIZER_FREEBSD\n+  uptr addr, size;\n+  GetTls(&addr, &size);\n+  return size;\n #else\n-  *tls_addr = 0;\n-  *tls_size = 0;\n+  return g_tls_size;\n #endif\n+}\n+\n+void GetThreadStackAndTls(bool main, uptr *stk_addr, uptr *stk_size,\n+                          uptr *tls_addr, uptr *tls_size) {\n+  GetTls(tls_addr, tls_size);\n \n   uptr stack_top, stack_bottom;\n   GetThreadStackTopAndBottom(main, &stack_top, &stack_bottom);\n@@ -289,30 +432,25 @@ void GetThreadStackAndTls(bool main, uptr *stk_addr, uptr *stk_size,\n       *tls_addr = *stk_addr + *stk_size;\n     }\n   }\n-#else  // SANITIZER_GO\n-  *stk_addr = 0;\n-  *stk_size = 0;\n-  *tls_addr = 0;\n-  *tls_size = 0;\n-#endif  // SANITIZER_GO\n }\n \n-void AdjustStackSizeLinux(void *attr_) {\n+void AdjustStackSize(void *attr_) {\n   pthread_attr_t *attr = (pthread_attr_t *)attr_;\n   uptr stackaddr = 0;\n   size_t stacksize = 0;\n-  __sanitizer_pthread_attr_getstack(attr, (void**)&stackaddr, &stacksize);\n+  my_pthread_attr_getstack(attr, (void**)&stackaddr, &stacksize);\n   // GLibC will return (0 - stacksize) as the stack address in the case when\n   // stacksize is set, but stackaddr is not.\n   bool stack_set = (stackaddr != 0) && (stackaddr + stacksize != 0);\n   // We place a lot of tool data into TLS, account for that.\n   const uptr minstacksize = GetTlsSize() + 128*1024;\n   if (stacksize < minstacksize) {\n     if (!stack_set) {\n-      if (common_flags()->verbosity && stacksize != 0)\n-        Printf(\"Sanitizer: increasing stacksize %zu->%zu\\n\", stacksize,\n-               minstacksize);\n-      pthread_attr_setstacksize(attr, minstacksize);\n+      if (stacksize != 0) {\n+        VPrintf(1, \"Sanitizer: increasing stacksize %zu->%zu\\n\", stacksize,\n+                minstacksize);\n+        pthread_attr_setstacksize(attr, minstacksize);\n+      }\n     } else {\n       Printf(\"Sanitizer: pre-allocated stack size is insufficient: \"\n              \"%zu < %zu\\n\", stacksize, minstacksize);\n@@ -324,10 +462,13 @@ void AdjustStackSizeLinux(void *attr_) {\n #if SANITIZER_ANDROID\n uptr GetListOfModules(LoadedModule *modules, uptr max_modules,\n                       string_predicate_t filter) {\n-  return 0;\n+  MemoryMappingLayout memory_mapping(false);\n+  return memory_mapping.DumpListOfModules(modules, max_modules, filter);\n }\n #else  // SANITIZER_ANDROID\n+# if !SANITIZER_FREEBSD\n typedef ElfW(Phdr) Elf_Phdr;\n+# endif\n \n struct DlIteratePhdrData {\n   LoadedModule *modules;\n@@ -378,6 +519,14 @@ uptr GetListOfModules(LoadedModule *modules, uptr max_modules,\n }\n #endif  // SANITIZER_ANDROID\n \n+uptr indirect_call_wrapper;\n+\n+void SetIndirectCallWrapper(uptr wrapper) {\n+  CHECK(!indirect_call_wrapper);\n+  CHECK(wrapper);\n+  indirect_call_wrapper = wrapper;\n+}\n+\n }  // namespace __sanitizer\n \n-#endif  // SANITIZER_LINUX\n+#endif  // SANITIZER_FREEBSD || SANITIZER_LINUX"}, {"sha": "b72c548e3850f1cf1ec4338657baebf3188fe946", "filename": "libsanitizer/sanitizer_common/sanitizer_list.h", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_list.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_list.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_list.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -24,6 +24,8 @@ namespace __sanitizer {\n // non-zero-initialized objects before using.\n template<class Item>\n struct IntrusiveList {\n+  friend class Iterator;\n+\n   void clear() {\n     first_ = last_ = 0;\n     size_ = 0;\n@@ -111,6 +113,21 @@ struct IntrusiveList {\n     }\n   }\n \n+  class Iterator {\n+   public:\n+    explicit Iterator(IntrusiveList<Item> *list)\n+        : list_(list), current_(list->first_) { }\n+    Item *next() {\n+      Item *ret = current_;\n+      if (current_) current_ = current_->next;\n+      return ret;\n+    }\n+    bool hasNext() const { return current_ != 0; }\n+   private:\n+    IntrusiveList<Item> *list_;\n+    Item *current_;\n+  };\n+\n // private, don't use directly.\n   uptr size_;\n   Item *first_;"}, {"sha": "6deba53d3e8aa27386c01c018703bfa494f8054c", "filename": "libsanitizer/sanitizer_common/sanitizer_mac.cc", "status": "modified", "additions": 73, "deletions": 172, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -5,9 +5,8 @@\n //\n //===----------------------------------------------------------------------===//\n //\n-// This file is shared between AddressSanitizer and ThreadSanitizer\n-// run-time libraries and implements mac-specific functions from\n-// sanitizer_libc.h.\n+// This file is shared between various sanitizers' runtime libraries and\n+// implements OSX-specific functions.\n //===----------------------------------------------------------------------===//\n \n #include \"sanitizer_platform.h\"\n@@ -21,20 +20,22 @@\n #include <stdio.h>\n \n #include \"sanitizer_common.h\"\n+#include \"sanitizer_flags.h\"\n #include \"sanitizer_internal_defs.h\"\n #include \"sanitizer_libc.h\"\n+#include \"sanitizer_mac.h\"\n #include \"sanitizer_placement_new.h\"\n #include \"sanitizer_procmaps.h\"\n \n #include <crt_externs.h>  // for _NSGetEnviron\n #include <fcntl.h>\n-#include <mach-o/dyld.h>\n-#include <mach-o/loader.h>\n #include <pthread.h>\n #include <sched.h>\n+#include <signal.h>\n #include <sys/mman.h>\n #include <sys/resource.h>\n #include <sys/stat.h>\n+#include <sys/sysctl.h>\n #include <sys/types.h>\n #include <unistd.h>\n #include <libkern/OSAtomic.h>\n@@ -118,6 +119,16 @@ uptr internal_getpid() {\n   return getpid();\n }\n \n+int internal_sigaction(int signum, const void *act, void *oldact) {\n+  return sigaction(signum,\n+                   (struct sigaction *)act, (struct sigaction *)oldact);\n+}\n+\n+int internal_fork() {\n+  // TODO(glider): this may call user's pthread_atfork() handlers which is bad.\n+  return fork();\n+}\n+\n // ----------------- sanitizer_common.h\n bool FileExists(const char *filename) {\n   struct stat st;\n@@ -136,6 +147,20 @@ void GetThreadStackTopAndBottom(bool at_initialization, uptr *stack_top,\n   CHECK(stack_top);\n   CHECK(stack_bottom);\n   uptr stacksize = pthread_get_stacksize_np(pthread_self());\n+  // pthread_get_stacksize_np() returns an incorrect stack size for the main\n+  // thread on Mavericks. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=261\n+  if ((GetMacosVersion() == MACOS_VERSION_MAVERICKS) && at_initialization &&\n+      stacksize == (1 << 19))  {\n+    struct rlimit rl;\n+    CHECK_EQ(getrlimit(RLIMIT_STACK, &rl), 0);\n+    // Most often rl.rlim_cur will be the desired 8M.\n+    if (rl.rlim_cur < kMaxThreadStackSize) {\n+      stacksize = rl.rlim_cur;\n+    } else {\n+      stacksize = kMaxThreadStackSize;\n+    }\n+  }\n   void *stackaddr = pthread_get_stackaddr_np(pthread_self());\n   *stack_top = (uptr)stackaddr;\n   *stack_bottom = *stack_top - stacksize;\n@@ -169,156 +194,15 @@ void ReExec() {\n   UNIMPLEMENTED();\n }\n \n-void PrepareForSandboxing() {\n+void PrepareForSandboxing(__sanitizer_sandbox_arguments *args) {\n+  (void)args;\n   // Nothing here for now.\n }\n \n uptr GetPageSize() {\n   return sysconf(_SC_PAGESIZE);\n }\n \n-// ----------------- sanitizer_procmaps.h\n-\n-MemoryMappingLayout::MemoryMappingLayout(bool cache_enabled) {\n-  Reset();\n-}\n-\n-MemoryMappingLayout::~MemoryMappingLayout() {\n-}\n-\n-// More information about Mach-O headers can be found in mach-o/loader.h\n-// Each Mach-O image has a header (mach_header or mach_header_64) starting with\n-// a magic number, and a list of linker load commands directly following the\n-// header.\n-// A load command is at least two 32-bit words: the command type and the\n-// command size in bytes. We're interested only in segment load commands\n-// (LC_SEGMENT and LC_SEGMENT_64), which tell that a part of the file is mapped\n-// into the task's address space.\n-// The |vmaddr|, |vmsize| and |fileoff| fields of segment_command or\n-// segment_command_64 correspond to the memory address, memory size and the\n-// file offset of the current memory segment.\n-// Because these fields are taken from the images as is, one needs to add\n-// _dyld_get_image_vmaddr_slide() to get the actual addresses at runtime.\n-\n-void MemoryMappingLayout::Reset() {\n-  // Count down from the top.\n-  // TODO(glider): as per man 3 dyld, iterating over the headers with\n-  // _dyld_image_count is thread-unsafe. We need to register callbacks for\n-  // adding and removing images which will invalidate the MemoryMappingLayout\n-  // state.\n-  current_image_ = _dyld_image_count();\n-  current_load_cmd_count_ = -1;\n-  current_load_cmd_addr_ = 0;\n-  current_magic_ = 0;\n-  current_filetype_ = 0;\n-}\n-\n-// static\n-void MemoryMappingLayout::CacheMemoryMappings() {\n-  // No-op on Mac for now.\n-}\n-\n-void MemoryMappingLayout::LoadFromCache() {\n-  // No-op on Mac for now.\n-}\n-\n-// Next and NextSegmentLoad were inspired by base/sysinfo.cc in\n-// Google Perftools, http://code.google.com/p/google-perftools.\n-\n-// NextSegmentLoad scans the current image for the next segment load command\n-// and returns the start and end addresses and file offset of the corresponding\n-// segment.\n-// Note that the segment addresses are not necessarily sorted.\n-template<u32 kLCSegment, typename SegmentCommand>\n-bool MemoryMappingLayout::NextSegmentLoad(\n-    uptr *start, uptr *end, uptr *offset,\n-    char filename[], uptr filename_size, uptr *protection) {\n-  if (protection)\n-    UNIMPLEMENTED();\n-  const char* lc = current_load_cmd_addr_;\n-  current_load_cmd_addr_ += ((const load_command *)lc)->cmdsize;\n-  if (((const load_command *)lc)->cmd == kLCSegment) {\n-    const sptr dlloff = _dyld_get_image_vmaddr_slide(current_image_);\n-    const SegmentCommand* sc = (const SegmentCommand *)lc;\n-    if (start) *start = sc->vmaddr + dlloff;\n-    if (end) *end = sc->vmaddr + sc->vmsize + dlloff;\n-    if (offset) {\n-      if (current_filetype_ == /*MH_EXECUTE*/ 0x2) {\n-        *offset = sc->vmaddr;\n-      } else {\n-        *offset = sc->fileoff;\n-      }\n-    }\n-    if (filename) {\n-      internal_strncpy(filename, _dyld_get_image_name(current_image_),\n-                       filename_size);\n-    }\n-    return true;\n-  }\n-  return false;\n-}\n-\n-bool MemoryMappingLayout::Next(uptr *start, uptr *end, uptr *offset,\n-                               char filename[], uptr filename_size,\n-                               uptr *protection) {\n-  for (; current_image_ >= 0; current_image_--) {\n-    const mach_header* hdr = _dyld_get_image_header(current_image_);\n-    if (!hdr) continue;\n-    if (current_load_cmd_count_ < 0) {\n-      // Set up for this image;\n-      current_load_cmd_count_ = hdr->ncmds;\n-      current_magic_ = hdr->magic;\n-      current_filetype_ = hdr->filetype;\n-      switch (current_magic_) {\n-#ifdef MH_MAGIC_64\n-        case MH_MAGIC_64: {\n-          current_load_cmd_addr_ = (char*)hdr + sizeof(mach_header_64);\n-          break;\n-        }\n-#endif\n-        case MH_MAGIC: {\n-          current_load_cmd_addr_ = (char*)hdr + sizeof(mach_header);\n-          break;\n-        }\n-        default: {\n-          continue;\n-        }\n-      }\n-    }\n-\n-    for (; current_load_cmd_count_ >= 0; current_load_cmd_count_--) {\n-      switch (current_magic_) {\n-        // current_magic_ may be only one of MH_MAGIC, MH_MAGIC_64.\n-#ifdef MH_MAGIC_64\n-        case MH_MAGIC_64: {\n-          if (NextSegmentLoad<LC_SEGMENT_64, struct segment_command_64>(\n-                  start, end, offset, filename, filename_size, protection))\n-            return true;\n-          break;\n-        }\n-#endif\n-        case MH_MAGIC: {\n-          if (NextSegmentLoad<LC_SEGMENT, struct segment_command>(\n-                  start, end, offset, filename, filename_size, protection))\n-            return true;\n-          break;\n-        }\n-      }\n-    }\n-    // If we get here, no more load_cmd's in this image talk about\n-    // segments.  Go on to the next image.\n-  }\n-  return false;\n-}\n-\n-bool MemoryMappingLayout::GetObjectNameAndOffset(uptr addr, uptr *offset,\n-                                                 char filename[],\n-                                                 uptr filename_size,\n-                                                 uptr *protection) {\n-  return IterateForObjectNameAndOffset(addr, offset, filename, filename_size,\n-                                       protection);\n-}\n-\n BlockingMutex::BlockingMutex(LinkerInitialized) {\n   // We assume that OS_SPINLOCK_INIT is zero\n }\n@@ -377,32 +261,49 @@ void GetThreadStackAndTls(bool main, uptr *stk_addr, uptr *stk_size,\n uptr GetListOfModules(LoadedModule *modules, uptr max_modules,\n                       string_predicate_t filter) {\n   MemoryMappingLayout memory_mapping(false);\n-  memory_mapping.Reset();\n-  uptr cur_beg, cur_end, cur_offset;\n-  InternalScopedBuffer<char> module_name(kMaxPathLength);\n-  uptr n_modules = 0;\n-  for (uptr i = 0;\n-       n_modules < max_modules &&\n-           memory_mapping.Next(&cur_beg, &cur_end, &cur_offset,\n-                               module_name.data(), module_name.size(), 0);\n-       i++) {\n-    const char *cur_name = module_name.data();\n-    if (cur_name[0] == '\\0')\n-      continue;\n-    if (filter && !filter(cur_name))\n-      continue;\n-    LoadedModule *cur_module = 0;\n-    if (n_modules > 0 &&\n-        0 == internal_strcmp(cur_name, modules[n_modules - 1].full_name())) {\n-      cur_module = &modules[n_modules - 1];\n-    } else {\n-      void *mem = &modules[n_modules];\n-      cur_module = new(mem) LoadedModule(cur_name, cur_beg);\n-      n_modules++;\n+  return memory_mapping.DumpListOfModules(modules, max_modules, filter);\n+}\n+\n+bool IsDeadlySignal(int signum) {\n+  return (signum == SIGSEGV || signum == SIGBUS) && common_flags()->handle_segv;\n+}\n+\n+MacosVersion cached_macos_version = MACOS_VERSION_UNINITIALIZED;\n+\n+MacosVersion GetMacosVersionInternal() {\n+  int mib[2] = { CTL_KERN, KERN_OSRELEASE };\n+  char version[100];\n+  uptr len = 0, maxlen = sizeof(version) / sizeof(version[0]);\n+  for (uptr i = 0; i < maxlen; i++) version[i] = '\\0';\n+  // Get the version length.\n+  CHECK_NE(sysctl(mib, 2, 0, &len, 0, 0), -1);\n+  CHECK_LT(len, maxlen);\n+  CHECK_NE(sysctl(mib, 2, version, &len, 0, 0), -1);\n+  switch (version[0]) {\n+    case '9': return MACOS_VERSION_LEOPARD;\n+    case '1': {\n+      switch (version[1]) {\n+        case '0': return MACOS_VERSION_SNOW_LEOPARD;\n+        case '1': return MACOS_VERSION_LION;\n+        case '2': return MACOS_VERSION_MOUNTAIN_LION;\n+        case '3': return MACOS_VERSION_MAVERICKS;\n+        default: return MACOS_VERSION_UNKNOWN;\n+      }\n     }\n-    cur_module->addAddressRange(cur_beg, cur_end);\n+    default: return MACOS_VERSION_UNKNOWN;\n+  }\n+}\n+\n+MacosVersion GetMacosVersion() {\n+  atomic_uint32_t *cache =\n+      reinterpret_cast<atomic_uint32_t*>(&cached_macos_version);\n+  MacosVersion result =\n+      static_cast<MacosVersion>(atomic_load(cache, memory_order_acquire));\n+  if (result == MACOS_VERSION_UNINITIALIZED) {\n+    result = GetMacosVersionInternal();\n+    atomic_store(cache, result, memory_order_release);\n   }\n-  return n_modules;\n+  return result;\n }\n \n }  // namespace __sanitizer"}, {"sha": "63055297fef118661259e0151ebff555c17f4c9d", "filename": "libsanitizer/sanitizer_common/sanitizer_mac.h", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -0,0 +1,34 @@\n+//===-- sanitizer_mac.h -----------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is shared between various sanitizers' runtime libraries and\n+// provides definitions for OSX-specific functions.\n+//===----------------------------------------------------------------------===//\n+#ifndef SANITIZER_MAC_H\n+#define SANITIZER_MAC_H\n+\n+#include \"sanitizer_platform.h\"\n+#if SANITIZER_MAC\n+\n+namespace __sanitizer {\n+\n+enum MacosVersion {\n+  MACOS_VERSION_UNINITIALIZED = 0,\n+  MACOS_VERSION_UNKNOWN,\n+  MACOS_VERSION_LEOPARD,\n+  MACOS_VERSION_SNOW_LEOPARD,\n+  MACOS_VERSION_LION,\n+  MACOS_VERSION_MOUNTAIN_LION,\n+  MACOS_VERSION_MAVERICKS\n+};\n+\n+MacosVersion GetMacosVersion();\n+\n+}  // namespace __sanitizer\n+\n+#endif  // SANITIZER_MAC\n+#endif  // SANITIZER_MAC_H"}, {"sha": "adc3add6008ad32ee5e87b14425bca3f59ce16ea", "filename": "libsanitizer/sanitizer_common/sanitizer_mutex.h", "status": "modified", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_mutex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_mutex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_mutex.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -81,6 +81,88 @@ class BlockingMutex {\n   uptr owner_;  // for debugging\n };\n \n+// Reader-writer spin mutex.\n+class RWMutex {\n+ public:\n+  RWMutex() {\n+    atomic_store(&state_, kUnlocked, memory_order_relaxed);\n+  }\n+\n+  ~RWMutex() {\n+    CHECK_EQ(atomic_load(&state_, memory_order_relaxed), kUnlocked);\n+  }\n+\n+  void Lock() {\n+    u32 cmp = kUnlocked;\n+    if (atomic_compare_exchange_strong(&state_, &cmp, kWriteLock,\n+                                       memory_order_acquire))\n+      return;\n+    LockSlow();\n+  }\n+\n+  void Unlock() {\n+    u32 prev = atomic_fetch_sub(&state_, kWriteLock, memory_order_release);\n+    DCHECK_NE(prev & kWriteLock, 0);\n+    (void)prev;\n+  }\n+\n+  void ReadLock() {\n+    u32 prev = atomic_fetch_add(&state_, kReadLock, memory_order_acquire);\n+    if ((prev & kWriteLock) == 0)\n+      return;\n+    ReadLockSlow();\n+  }\n+\n+  void ReadUnlock() {\n+    u32 prev = atomic_fetch_sub(&state_, kReadLock, memory_order_release);\n+    DCHECK_EQ(prev & kWriteLock, 0);\n+    DCHECK_GT(prev & ~kWriteLock, 0);\n+    (void)prev;\n+  }\n+\n+  void CheckLocked() {\n+    CHECK_NE(atomic_load(&state_, memory_order_relaxed), kUnlocked);\n+  }\n+\n+ private:\n+  atomic_uint32_t state_;\n+\n+  enum {\n+    kUnlocked = 0,\n+    kWriteLock = 1,\n+    kReadLock = 2\n+  };\n+\n+  void NOINLINE LockSlow() {\n+    for (int i = 0;; i++) {\n+      if (i < 10)\n+        proc_yield(10);\n+      else\n+        internal_sched_yield();\n+      u32 cmp = atomic_load(&state_, memory_order_relaxed);\n+      if (cmp == kUnlocked &&\n+          atomic_compare_exchange_weak(&state_, &cmp, kWriteLock,\n+                                       memory_order_acquire))\n+          return;\n+    }\n+  }\n+\n+  void NOINLINE ReadLockSlow() {\n+    for (int i = 0;; i++) {\n+      if (i < 10)\n+        proc_yield(10);\n+      else\n+        internal_sched_yield();\n+      u32 prev = atomic_load(&state_, memory_order_acquire);\n+      if ((prev & kWriteLock) == 0)\n+        return;\n+    }\n+  }\n+\n+  RWMutex(const RWMutex&);\n+  void operator = (const RWMutex&);\n+};\n+\n template<typename MutexType>\n class GenericScopedLock {\n  public:\n@@ -121,6 +203,8 @@ class GenericScopedReadLock {\n \n typedef GenericScopedLock<StaticSpinMutex> SpinMutexLock;\n typedef GenericScopedLock<BlockingMutex> BlockingMutexLock;\n+typedef GenericScopedLock<RWMutex> RWMutexLock;\n+typedef GenericScopedReadLock<RWMutex> RWMutexReadLock;\n \n }  // namespace __sanitizer\n "}, {"sha": "14594d5ce553af33d6b7c7ebe3e2ad1d795a1d3d", "filename": "libsanitizer/sanitizer_common/sanitizer_platform.h", "status": "modified", "additions": 61, "deletions": 2, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -11,7 +11,8 @@\n #ifndef SANITIZER_PLATFORM_H\n #define SANITIZER_PLATFORM_H\n \n-#if !defined(__linux__) && !defined(__APPLE__) && !defined(_WIN32)\n+#if !defined(__linux__) && !defined(__FreeBSD__) && \\\n+  !defined(__APPLE__) && !defined(_WIN32)\n # error \"This operating system is not supported\"\n #endif\n \n@@ -21,6 +22,12 @@\n # define SANITIZER_LINUX   0\n #endif\n \n+#if defined(__FreeBSD__)\n+# define SANITIZER_FREEBSD 1\n+#else\n+# define SANITIZER_FREEBSD 0\n+#endif\n+\n #if defined(__APPLE__)\n # define SANITIZER_MAC     1\n # include <TargetConditionals.h>\n@@ -46,6 +53,58 @@\n # define SANITIZER_ANDROID 0\n #endif\n \n-#define SANITIZER_POSIX (SANITIZER_LINUX || SANITIZER_MAC)\n+#define SANITIZER_POSIX (SANITIZER_FREEBSD || SANITIZER_LINUX || SANITIZER_MAC)\n+\n+#if __LP64__ || defined(_WIN64)\n+#  define SANITIZER_WORDSIZE 64\n+#else\n+#  define SANITIZER_WORDSIZE 32\n+#endif\n+\n+#if SANITIZER_WORDSIZE == 64\n+# define FIRST_32_SECOND_64(a, b) (b)\n+#else\n+# define FIRST_32_SECOND_64(a, b) (a)\n+#endif\n+\n+#if defined(__x86_64__) && !defined(_LP64)\n+# define SANITIZER_X32 1\n+#else\n+# define SANITIZER_X32 0\n+#endif\n+\n+// By default we allow to use SizeClassAllocator64 on 64-bit platform.\n+// But in some cases (e.g. AArch64's 39-bit address space) SizeClassAllocator64\n+// does not work well and we need to fallback to SizeClassAllocator32.\n+// For such platforms build this code with -DSANITIZER_CAN_USE_ALLOCATOR64=0 or\n+// change the definition of SANITIZER_CAN_USE_ALLOCATOR64 here.\n+#ifndef SANITIZER_CAN_USE_ALLOCATOR64\n+# if defined(__aarch64__)\n+#  define SANITIZER_CAN_USE_ALLOCATOR64 0\n+# else\n+#  define SANITIZER_CAN_USE_ALLOCATOR64 (SANITIZER_WORDSIZE == 64)\n+# endif\n+#endif\n+\n+// The range of addresses which can be returned my mmap.\n+// FIXME: this value should be different on different platforms,\n+// e.g. on AArch64 it is most likely (1ULL << 39). Larger values will still work\n+// but will consume more memory for TwoLevelByteMap.\n+#if defined(__aarch64__)\n+# define SANITIZER_MMAP_RANGE_SIZE FIRST_32_SECOND_64(1ULL << 32, 1ULL << 39)\n+#else\n+# define SANITIZER_MMAP_RANGE_SIZE FIRST_32_SECOND_64(1ULL << 32, 1ULL << 47)\n+#endif\n+\n+// The AArch64 linux port uses the canonical syscall set as mandated by\n+// the upstream linux community for all new ports. Other ports may still\n+// use legacy syscalls.\n+#ifndef SANITIZER_USES_CANONICAL_LINUX_SYSCALLS\n+# if defined(__aarch64__) && SANITIZER_LINUX\n+# define SANITIZER_USES_CANONICAL_LINUX_SYSCALLS 1\n+# else\n+# define SANITIZER_USES_CANONICAL_LINUX_SYSCALLS 0\n+# endif\n+#endif\n \n #endif // SANITIZER_PLATFORM_H"}, {"sha": "92bbc0051063a1a9d523b92ecf432d2a3c4a8db8", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_interceptors.h", "status": "modified", "additions": 140, "deletions": 108, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -45,14 +45,16 @@\n # define SI_IOS 0\n #endif\n \n-# define SANITIZER_INTERCEPT_STRCMP 1\n-# define SANITIZER_INTERCEPT_TEXTDOMAIN SI_LINUX_NOT_ANDROID\n-# define SANITIZER_INTERCEPT_STRCASECMP SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_STRCMP 1\n+#define SANITIZER_INTERCEPT_TEXTDOMAIN SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_STRCASECMP SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_MEMCHR 1\n+#define SANITIZER_INTERCEPT_MEMRCHR SI_LINUX\n \n-# define SANITIZER_INTERCEPT_READ   SI_NOT_WINDOWS\n-# define SANITIZER_INTERCEPT_PREAD  SI_NOT_WINDOWS\n-# define SANITIZER_INTERCEPT_WRITE  SI_NOT_WINDOWS\n-# define SANITIZER_INTERCEPT_PWRITE SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_READ   SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_PREAD  SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_WRITE  SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_PWRITE SI_NOT_WINDOWS\n \n #define SANITIZER_INTERCEPT_PREAD64 SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_PWRITE64 SI_LINUX_NOT_ANDROID\n@@ -65,109 +67,139 @@\n #define SANITIZER_INTERCEPT_PREADV64 SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_PWRITEV64 SI_LINUX_NOT_ANDROID\n \n-# define SANITIZER_INTERCEPT_PRCTL   SI_LINUX\n-\n-# define SANITIZER_INTERCEPT_LOCALTIME_AND_FRIENDS SI_NOT_WINDOWS\n-# define SANITIZER_INTERCEPT_STRPTIME SI_NOT_WINDOWS\n-\n-# define SANITIZER_INTERCEPT_SCANF SI_NOT_WINDOWS\n-# define SANITIZER_INTERCEPT_ISOC99_SCANF SI_LINUX\n-\n-# define SANITIZER_INTERCEPT_FREXP 1\n-# define SANITIZER_INTERCEPT_FREXPF_FREXPL SI_NOT_WINDOWS\n-\n-# define SANITIZER_INTERCEPT_GETPWNAM_AND_FRIENDS SI_NOT_WINDOWS\n-# define SANITIZER_INTERCEPT_GETPWNAM_R_AND_FRIENDS \\\n-    SI_MAC || SI_LINUX_NOT_ANDROID\n-# define SANITIZER_INTERCEPT_CLOCK_GETTIME SI_LINUX\n-# define SANITIZER_INTERCEPT_GETITIMER SI_NOT_WINDOWS\n-# define SANITIZER_INTERCEPT_TIME SI_NOT_WINDOWS\n-# define SANITIZER_INTERCEPT_GLOB SI_LINUX_NOT_ANDROID\n-# define SANITIZER_INTERCEPT_WAIT SI_NOT_WINDOWS\n-# define SANITIZER_INTERCEPT_INET SI_NOT_WINDOWS\n-# define SANITIZER_INTERCEPT_PTHREAD_GETSCHEDPARAM SI_NOT_WINDOWS\n-# define SANITIZER_INTERCEPT_GETADDRINFO SI_NOT_WINDOWS\n-# define SANITIZER_INTERCEPT_GETNAMEINFO SI_NOT_WINDOWS\n-# define SANITIZER_INTERCEPT_GETSOCKNAME SI_NOT_WINDOWS\n-# define SANITIZER_INTERCEPT_GETHOSTBYNAME SI_NOT_WINDOWS\n-# define SANITIZER_INTERCEPT_GETHOSTBYNAME_R SI_LINUX\n-# define SANITIZER_INTERCEPT_GETSOCKOPT SI_NOT_WINDOWS\n-# define SANITIZER_INTERCEPT_ACCEPT SI_NOT_WINDOWS\n-# define SANITIZER_INTERCEPT_ACCEPT4 SI_LINUX\n-# define SANITIZER_INTERCEPT_MODF SI_NOT_WINDOWS\n-# define SANITIZER_INTERCEPT_RECVMSG SI_NOT_WINDOWS\n-# define SANITIZER_INTERCEPT_GETPEERNAME SI_NOT_WINDOWS\n-# define SANITIZER_INTERCEPT_IOCTL SI_NOT_WINDOWS\n-# define SANITIZER_INTERCEPT_INET_ATON SI_NOT_WINDOWS\n-# define SANITIZER_INTERCEPT_SYSINFO SI_LINUX\n-# define SANITIZER_INTERCEPT_READDIR SI_NOT_WINDOWS\n-# define SANITIZER_INTERCEPT_READDIR64 SI_LINUX_NOT_ANDROID\n-# define SANITIZER_INTERCEPT_PTRACE SI_LINUX_NOT_ANDROID && \\\n-  (defined(__i386) || defined (__x86_64))  // NOLINT\n-# define SANITIZER_INTERCEPT_SETLOCALE SI_NOT_WINDOWS\n-# define SANITIZER_INTERCEPT_GETCWD SI_NOT_WINDOWS\n-# define SANITIZER_INTERCEPT_GET_CURRENT_DIR_NAME SI_LINUX\n-# define SANITIZER_INTERCEPT_STRTOIMAX SI_NOT_WINDOWS\n-# define SANITIZER_INTERCEPT_MBSTOWCS SI_NOT_WINDOWS\n-# define SANITIZER_INTERCEPT_MBSNRTOWCS SI_MAC || SI_LINUX_NOT_ANDROID\n-# define SANITIZER_INTERCEPT_WCSTOMBS SI_NOT_WINDOWS\n-# define SANITIZER_INTERCEPT_WCSNRTOMBS SI_MAC || SI_LINUX_NOT_ANDROID\n-# define SANITIZER_INTERCEPT_TCGETATTR SI_LINUX\n-# define SANITIZER_INTERCEPT_REALPATH SI_NOT_WINDOWS\n-# define SANITIZER_INTERCEPT_CANONICALIZE_FILE_NAME SI_LINUX_NOT_ANDROID\n-# define SANITIZER_INTERCEPT_CONFSTR SI_MAC || SI_LINUX_NOT_ANDROID\n-# define SANITIZER_INTERCEPT_SCHED_GETAFFINITY SI_LINUX_NOT_ANDROID\n-# define SANITIZER_INTERCEPT_STRERROR SI_NOT_WINDOWS\n-# define SANITIZER_INTERCEPT_STRERROR_R SI_NOT_WINDOWS\n-# define SANITIZER_INTERCEPT_XPG_STRERROR_R SI_LINUX_NOT_ANDROID\n-# define SANITIZER_INTERCEPT_SCANDIR SI_LINUX_NOT_ANDROID\n-# define SANITIZER_INTERCEPT_SCANDIR64 SI_LINUX_NOT_ANDROID\n-# define SANITIZER_INTERCEPT_GETGROUPS SI_NOT_WINDOWS\n-# define SANITIZER_INTERCEPT_POLL SI_NOT_WINDOWS\n-# define SANITIZER_INTERCEPT_PPOLL SI_LINUX_NOT_ANDROID\n-# define SANITIZER_INTERCEPT_WORDEXP SI_MAC || SI_LINUX_NOT_ANDROID\n-# define SANITIZER_INTERCEPT_SIGWAIT SI_NOT_WINDOWS\n-# define SANITIZER_INTERCEPT_SIGWAITINFO SI_LINUX_NOT_ANDROID\n-# define SANITIZER_INTERCEPT_SIGTIMEDWAIT SI_LINUX_NOT_ANDROID\n-# define SANITIZER_INTERCEPT_SIGSETOPS SI_NOT_WINDOWS\n-# define SANITIZER_INTERCEPT_SIGPENDING SI_NOT_WINDOWS\n-# define SANITIZER_INTERCEPT_SIGPROCMASK SI_NOT_WINDOWS\n-# define SANITIZER_INTERCEPT_BACKTRACE SI_LINUX_NOT_ANDROID\n-# define SANITIZER_INTERCEPT_GETMNTENT SI_LINUX\n-# define SANITIZER_INTERCEPT_GETMNTENT_R SI_LINUX_NOT_ANDROID\n-# define SANITIZER_INTERCEPT_STATFS SI_NOT_WINDOWS\n-# define SANITIZER_INTERCEPT_STATFS64 \\\n-    (SI_MAC && !SI_IOS) || SI_LINUX_NOT_ANDROID\n-# define SANITIZER_INTERCEPT_STATVFS SI_LINUX_NOT_ANDROID\n-# define SANITIZER_INTERCEPT_STATVFS64 SI_LINUX_NOT_ANDROID\n-# define SANITIZER_INTERCEPT_INITGROUPS SI_NOT_WINDOWS\n-# define SANITIZER_INTERCEPT_ETHER SI_NOT_WINDOWS\n-# define SANITIZER_INTERCEPT_ETHER_R SI_LINUX_NOT_ANDROID\n-# define SANITIZER_INTERCEPT_SHMCTL \\\n-    (SI_LINUX_NOT_ANDROID && SANITIZER_WORDSIZE == 64)\n-# define SANITIZER_INTERCEPT_RANDOM_R SI_LINUX_NOT_ANDROID\n-# define SANITIZER_INTERCEPT_PTHREAD_ATTR_GET SI_NOT_WINDOWS\n-# define SANITIZER_INTERCEPT_PTHREAD_ATTR_GETINHERITSCHED \\\n-  SI_MAC || SI_LINUX_NOT_ANDROID\n-# define SANITIZER_INTERCEPT_PTHREAD_ATTR_GETAFFINITY_NP SI_LINUX_NOT_ANDROID\n-# define SANITIZER_INTERCEPT_TMPNAM SI_NOT_WINDOWS\n-# define SANITIZER_INTERCEPT_TMPNAM_R SI_LINUX_NOT_ANDROID\n-# define SANITIZER_INTERCEPT_TEMPNAM SI_NOT_WINDOWS\n-# define SANITIZER_INTERCEPT_SINCOS SI_LINUX\n-# define SANITIZER_INTERCEPT_REMQUO SI_NOT_WINDOWS\n-# define SANITIZER_INTERCEPT_LGAMMA SI_NOT_WINDOWS\n-# define SANITIZER_INTERCEPT_LGAMMA_R SI_LINUX\n-# define SANITIZER_INTERCEPT_DRAND48_R SI_LINUX_NOT_ANDROID\n-# define SANITIZER_INTERCEPT_ICONV SI_LINUX_NOT_ANDROID\n-# define SANITIZER_INTERCEPT_TIMES SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_PRCTL   SI_LINUX\n \n-// FIXME: getline seems to be available on OSX 10.7\n-# define SANITIZER_INTERCEPT_GETLINE SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_LOCALTIME_AND_FRIENDS SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_STRPTIME SI_NOT_WINDOWS\n+\n+#define SANITIZER_INTERCEPT_SCANF SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_ISOC99_SCANF SI_LINUX\n+\n+#ifndef SANITIZER_INTERCEPT_PRINTF\n+# define SANITIZER_INTERCEPT_PRINTF SI_NOT_WINDOWS\n+# define SANITIZER_INTERCEPT_ISOC99_PRINTF SI_LINUX\n+#endif\n \n-# define SANITIZER_INTERCEPT__EXIT SI_LINUX\n+#define SANITIZER_INTERCEPT_FREXP 1\n+#define SANITIZER_INTERCEPT_FREXPF_FREXPL SI_NOT_WINDOWS\n \n-# define SANITIZER_INTERCEPT_PHTREAD_MUTEX SI_NOT_WINDOWS\n-# define SANITIZER_INTERCEPT_PTHREAD_COND SI_NOT_WINDOWS\n-# define SANITIZER_INTERCEPT_PTHREAD_SETNAME_NP SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_GETPWNAM_AND_FRIENDS SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_GETPWNAM_R_AND_FRIENDS \\\n+  SI_MAC || SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_GETPWENT SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_FGETPWENT SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_GETPWENT_R SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_SETPWENT SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_CLOCK_GETTIME SI_LINUX\n+#define SANITIZER_INTERCEPT_GETITIMER SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_TIME SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_GLOB SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_WAIT SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_INET SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_PTHREAD_GETSCHEDPARAM SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_GETADDRINFO SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_GETNAMEINFO SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_GETSOCKNAME SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_GETHOSTBYNAME SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_GETHOSTBYNAME_R SI_LINUX\n+#define SANITIZER_INTERCEPT_GETSOCKOPT SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_ACCEPT SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_ACCEPT4 SI_LINUX\n+#define SANITIZER_INTERCEPT_MODF SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_RECVMSG SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_GETPEERNAME SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_IOCTL SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_INET_ATON SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_SYSINFO SI_LINUX\n+#define SANITIZER_INTERCEPT_READDIR SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_READDIR64 SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_PTRACE SI_LINUX_NOT_ANDROID && \\\n+   (defined(__i386) || defined (__x86_64))  // NOLINT\n+#define SANITIZER_INTERCEPT_SETLOCALE SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_GETCWD SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_GET_CURRENT_DIR_NAME SI_LINUX\n+#define SANITIZER_INTERCEPT_STRTOIMAX SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_MBSTOWCS SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_MBSNRTOWCS SI_MAC || SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_WCSTOMBS SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_WCSNRTOMBS SI_MAC || SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_TCGETATTR SI_LINUX\n+#define SANITIZER_INTERCEPT_REALPATH SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_CANONICALIZE_FILE_NAME SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_CONFSTR SI_MAC || SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_SCHED_GETAFFINITY SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_STRERROR SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_STRERROR_R SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_XPG_STRERROR_R SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_SCANDIR SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_SCANDIR64 SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_GETGROUPS SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_POLL SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_PPOLL SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_WORDEXP (SI_MAC && !SI_IOS) || SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_SIGWAIT SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_SIGWAITINFO SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_SIGTIMEDWAIT SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_SIGSETOPS SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_SIGPENDING SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_SIGPROCMASK SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_BACKTRACE SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_GETMNTENT SI_LINUX\n+#define SANITIZER_INTERCEPT_GETMNTENT_R SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_STATFS SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_STATFS64 \\\n+  (SI_MAC && !SI_IOS) || SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_STATVFS SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_STATVFS64 SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_INITGROUPS SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_ETHER SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_ETHER_R SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_SHMCTL \\\n+  (SI_LINUX_NOT_ANDROID && SANITIZER_WORDSIZE == 64)\n+#define SANITIZER_INTERCEPT_RANDOM_R SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_PTHREAD_ATTR_GET SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_PTHREAD_ATTR_GETINHERITSCHED \\\n+  SI_MAC || SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_PTHREAD_ATTR_GETAFFINITY_NP SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_TMPNAM SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_TMPNAM_R SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_TEMPNAM SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_SINCOS SI_LINUX\n+#define SANITIZER_INTERCEPT_REMQUO SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_LGAMMA SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_LGAMMA_R SI_LINUX\n+#define SANITIZER_INTERCEPT_DRAND48_R SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_RAND_R SI_MAC || SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_ICONV SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_TIMES SI_NOT_WINDOWS\n+\n+// FIXME: getline seems to be available on OSX 10.7\n+#define SANITIZER_INTERCEPT_GETLINE SI_LINUX_NOT_ANDROID\n+\n+#define SANITIZER_INTERCEPT__EXIT SI_LINUX\n+\n+#define SANITIZER_INTERCEPT_PHTREAD_MUTEX SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_PTHREAD_SETNAME_NP SI_LINUX_NOT_ANDROID\n+\n+#define SANITIZER_INTERCEPT_TLS_GET_ADDR SI_LINUX_NOT_ANDROID\n+\n+#define SANITIZER_INTERCEPT_LISTXATTR SI_LINUX\n+#define SANITIZER_INTERCEPT_GETXATTR SI_LINUX\n+#define SANITIZER_INTERCEPT_GETRESID SI_LINUX\n+#define SANITIZER_INTERCEPT_GETIFADDRS SI_LINUX_NOT_ANDROID || SI_MAC\n+#define SANITIZER_INTERCEPT_IF_INDEXTONAME SI_LINUX_NOT_ANDROID || SI_MAC\n+#define SANITIZER_INTERCEPT_CAPGET SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_AEABI_MEM SI_LINUX && defined(__arm__)\n+#define SANITIZER_INTERCEPT___BZERO SI_MAC\n+#define SANITIZER_INTERCEPT_FTIME SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_XDR SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_TSEARCH SI_LINUX_NOT_ANDROID || SI_MAC\n+#define SANITIZER_INTERCEPT_LIBIO_INTERNALS SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_FOPEN SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_FOPEN64 SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_OPEN_MEMSTREAM SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_OBSTACK SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_FFLUSH SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_FCLOSE SI_NOT_WINDOWS\n \n #endif  // #ifndef SANITIZER_PLATFORM_INTERCEPTORS_H"}, {"sha": "76ee9001b7d184b237b03c7916a72feb1d085cce", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_linux.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_linux.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -62,7 +62,7 @@ namespace __sanitizer {\n   unsigned struct_statfs64_sz = sizeof(struct statfs64);\n }  // namespace __sanitizer\n \n-#if !defined(__powerpc64__) && !defined(__x86_64__)\n+#if !defined(__powerpc64__) && !defined(__x86_64__) && !defined(__aarch64__)\n COMPILER_CHECK(struct___old_kernel_stat_sz == sizeof(struct __old_kernel_stat));\n #endif\n "}, {"sha": "a93d38d8aacedc8efd7aa14acf685867396f634c", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.cc", "status": "modified", "additions": 318, "deletions": 102, "changes": 420, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -12,10 +12,7 @@\n \n \n #include \"sanitizer_platform.h\"\n-#if SANITIZER_LINUX || SANITIZER_MAC\n-\n-#include \"sanitizer_internal_defs.h\"\n-#include \"sanitizer_platform_limits_posix.h\"\n+#if SANITIZER_LINUX || SANITIZER_FREEBSD || SANITIZER_MAC\n \n #include <arpa/inet.h>\n #include <dirent.h>\n@@ -31,23 +28,27 @@\n #include <pwd.h>\n #include <signal.h>\n #include <stddef.h>\n+#include <sys/mman.h>\n #include <sys/resource.h>\n #include <sys/socket.h>\n #include <sys/stat.h>\n #include <sys/time.h>\n+#include <sys/timeb.h>\n #include <sys/times.h>\n #include <sys/types.h>\n #include <sys/utsname.h>\n #include <termios.h>\n #include <time.h>\n #include <wchar.h>\n \n+#if !SANITIZER_ANDROID\n+#include <sys/mount.h>\n+#endif\n+\n #if SANITIZER_LINUX\n+#include <malloc.h>\n #include <mntent.h>\n #include <netinet/ether.h>\n-#include <utime.h>\n-#include <sys/mount.h>\n-#include <sys/ptrace.h>\n #include <sys/sysinfo.h>\n #include <sys/vt.h>\n #include <linux/cdrom.h>\n@@ -62,18 +63,63 @@\n #include <linux/posix_types.h>\n #endif\n \n+#if SANITIZER_FREEBSD\n+# include <sys/mount.h>\n+# include <sys/sockio.h>\n+# include <sys/socket.h>\n+# include <sys/filio.h>\n+# include <sys/signal.h>\n+# include <sys/timespec.h>\n+# include <sys/timex.h>\n+# include <sys/mqueue.h>\n+# include <sys/msg.h>\n+# include <sys/ipc.h>\n+# include <sys/msg.h>\n+# include <sys/statvfs.h>\n+# include <sys/soundcard.h>\n+# include <sys/mtio.h>\n+# include <sys/consio.h>\n+# include <sys/kbio.h>\n+# include <sys/link_elf.h>\n+# include <netinet/ip_mroute.h>\n+# include <netinet/in.h>\n+# include <netinet/ip_compat.h>\n+# include <net/ethernet.h>\n+# include <net/ppp_defs.h>\n+# include <glob.h>\n+# include <term.h>\n+\n+#define _KERNEL  // to declare 'shminfo' structure\n+# include <sys/shm.h>\n+#undef _KERNEL\n+\n+#undef INLINE  // to avoid clashes with sanitizers' definitions\n+#endif\n+\n+#if SANITIZER_FREEBSD || SANITIZER_IOS\n+#undef IOC_DIRMASK\n+#endif\n+\n+#if SANITIZER_LINUX || SANITIZER_FREEBSD\n+# include <utime.h>\n+# include <sys/ptrace.h>\n+#endif\n+\n #if !SANITIZER_ANDROID\n+#include <ifaddrs.h>\n #include <sys/ucontext.h>\n #include <wordexp.h>\n #endif\n \n #if SANITIZER_LINUX && !SANITIZER_ANDROID\n #include <glob.h>\n+#include <obstack.h>\n #include <mqueue.h>\n #include <net/if_ppp.h>\n #include <netax25/ax25.h>\n #include <netipx/ipx.h>\n #include <netrom/netrom.h>\n+#include <rpc/xdr.h>\n #include <scsi/scsi.h>\n #include <sys/mtio.h>\n #include <sys/kd.h>\n@@ -92,7 +138,6 @@\n #include <linux/serial.h>\n #include <sys/msg.h>\n #include <sys/ipc.h>\n-#include <sys/shm.h>\n #endif // SANITIZER_LINUX && !SANITIZER_ANDROID\n \n #if SANITIZER_ANDROID\n@@ -112,16 +157,19 @@\n #if SANITIZER_MAC\n #include <net/ethernet.h>\n #include <sys/filio.h>\n-#include <sys/mount.h>\n #include <sys/sockio.h>\n #endif\n \n+// Include these after system headers to avoid name clashes and ambiguities.\n+#include \"sanitizer_internal_defs.h\"\n+#include \"sanitizer_platform_limits_posix.h\"\n+\n namespace __sanitizer {\n   unsigned struct_utsname_sz = sizeof(struct utsname);\n   unsigned struct_stat_sz = sizeof(struct stat);\n-#if !SANITIZER_IOS\n+#if !SANITIZER_IOS && !SANITIZER_FREEBSD\n   unsigned struct_stat64_sz = sizeof(struct stat64);\n-#endif // !SANITIZER_IOS\n+#endif  // !SANITIZER_IOS && !SANITIZER_FREEBSD\n   unsigned struct_rusage_sz = sizeof(struct rusage);\n   unsigned struct_tm_sz = sizeof(struct tm);\n   unsigned struct_passwd_sz = sizeof(struct passwd);\n@@ -134,6 +182,7 @@ namespace __sanitizer {\n   unsigned pid_t_sz = sizeof(pid_t);\n   unsigned timeval_sz = sizeof(timeval);\n   unsigned uid_t_sz = sizeof(uid_t);\n+  unsigned gid_t_sz = sizeof(gid_t);\n   unsigned mbstate_t_sz = sizeof(mbstate_t);\n   unsigned sigset_t_sz = sizeof(sigset_t);\n   unsigned struct_timezone_sz = sizeof(struct timezone);\n@@ -147,33 +196,40 @@ namespace __sanitizer {\n #endif // SANITIZER_MAC && !SANITIZER_IOS\n \n #if !SANITIZER_ANDROID\n+  unsigned struct_sockaddr_sz = sizeof(struct sockaddr);\n   unsigned ucontext_t_sz = sizeof(ucontext_t);\n #endif // !SANITIZER_ANDROID\n \n #if SANITIZER_LINUX\n-  unsigned struct_rlimit_sz = sizeof(struct rlimit);\n   unsigned struct_epoll_event_sz = sizeof(struct epoll_event);\n   unsigned struct_sysinfo_sz = sizeof(struct sysinfo);\n-  unsigned struct_timespec_sz = sizeof(struct timespec);\n   unsigned __user_cap_header_struct_sz =\n       sizeof(struct __user_cap_header_struct);\n   unsigned __user_cap_data_struct_sz = sizeof(struct __user_cap_data_struct);\n-  unsigned struct_utimbuf_sz = sizeof(struct utimbuf);\n   unsigned struct_new_utsname_sz = sizeof(struct new_utsname);\n   unsigned struct_old_utsname_sz = sizeof(struct old_utsname);\n   unsigned struct_oldold_utsname_sz = sizeof(struct oldold_utsname);\n+#endif  // SANITIZER_LINUX\n+\n+#if SANITIZER_LINUX || SANITIZER_FREEBSD\n+  unsigned struct_rlimit_sz = sizeof(struct rlimit);\n+  unsigned struct_timespec_sz = sizeof(struct timespec);\n+  unsigned struct_utimbuf_sz = sizeof(struct utimbuf);\n   unsigned struct_itimerspec_sz = sizeof(struct itimerspec);\n-  unsigned struct_ustat_sz = sizeof(struct ustat);\n-#endif // SANITIZER_LINUX\n+#endif  // SANITIZER_LINUX || SANITIZER_FREEBSD\n \n #if SANITIZER_LINUX && !SANITIZER_ANDROID\n+  unsigned struct_ustat_sz = sizeof(struct ustat);\n   unsigned struct_rlimit64_sz = sizeof(struct rlimit64);\n+  unsigned struct_statvfs64_sz = sizeof(struct statvfs64);\n+#endif  // SANITIZER_LINUX && !SANITIZER_ANDROID\n+\n+#if (SANITIZER_LINUX || SANITIZER_FREEBSD) && !SANITIZER_ANDROID\n   unsigned struct_timex_sz = sizeof(struct timex);\n   unsigned struct_msqid_ds_sz = sizeof(struct msqid_ds);\n   unsigned struct_mq_attr_sz = sizeof(struct mq_attr);\n   unsigned struct_statvfs_sz = sizeof(struct statvfs);\n-  unsigned struct_statvfs64_sz = sizeof(struct statvfs64);\n-#endif // SANITIZER_LINUX && !SANITIZER_ANDROID\n+#endif  // (SANITIZER_LINUX || SANITIZER_FREEBSD) && !SANITIZER_ANDROID\n \n   uptr sig_ign = (uptr)SIG_IGN;\n   uptr sig_dfl = (uptr)SIG_DFL;\n@@ -184,15 +240,17 @@ namespace __sanitizer {\n #endif\n \n \n-#if SANITIZER_LINUX && !SANITIZER_ANDROID\n+#if (SANITIZER_LINUX || SANITIZER_FREEBSD) && !SANITIZER_ANDROID\n   unsigned struct_shminfo_sz = sizeof(struct shminfo);\n   unsigned struct_shm_info_sz = sizeof(struct shm_info);\n   int shmctl_ipc_stat = (int)IPC_STAT;\n   int shmctl_ipc_info = (int)IPC_INFO;\n   int shmctl_shm_info = (int)SHM_INFO;\n-  int shmctl_shm_stat = (int)SHM_INFO;\n+  int shmctl_shm_stat = (int)SHM_STAT;\n #endif\n \n+  int map_fixed = MAP_FIXED;\n+\n   int af_inet = (int)AF_INET;\n   int af_inet6 = (int)AF_INET6;\n \n@@ -205,13 +263,13 @@ namespace __sanitizer {\n       return 0;\n   }\n \n-#if SANITIZER_LINUX && !SANITIZER_ANDROID\n+#if (SANITIZER_LINUX || SANITIZER_FREEBSD) && !SANITIZER_ANDROID\n   int glob_nomatch = GLOB_NOMATCH;\n   int glob_altdirfunc = GLOB_ALTDIRFUNC;\n #endif\n \n #if SANITIZER_LINUX && !SANITIZER_ANDROID && \\\n-      (defined(__i386) || defined (__x86_64))  // NOLINT\n+    (defined(__i386) || defined(__x86_64))\n   unsigned struct_user_regs_struct_sz = sizeof(struct user_regs_struct);\n   unsigned struct_user_fpregs_struct_sz = sizeof(struct user_fpregs_struct);\n #ifdef __x86_64\n@@ -229,15 +287,21 @@ namespace __sanitizer {\n   int ptrace_setfpregs = PTRACE_SETFPREGS;\n   int ptrace_getfpxregs = PTRACE_GETFPXREGS;\n   int ptrace_setfpxregs = PTRACE_SETFPXREGS;\n+#if (defined(PTRACE_GETSIGINFO) && defined(PTRACE_SETSIGINFO)) ||              \\\n+    (defined(PT_GETSIGINFO) && defined(PT_SETSIGINFO))\n   int ptrace_getsiginfo = PTRACE_GETSIGINFO;\n   int ptrace_setsiginfo = PTRACE_SETSIGINFO;\n+#else\n+  int ptrace_getsiginfo = -1;\n+  int ptrace_setsiginfo = -1;\n+#endif  // PTRACE_GETSIGINFO/PTRACE_SETSIGINFO\n #if defined(PTRACE_GETREGSET) && defined(PTRACE_SETREGSET)\n   int ptrace_getregset = PTRACE_GETREGSET;\n   int ptrace_setregset = PTRACE_SETREGSET;\n #else\n   int ptrace_getregset = -1;\n   int ptrace_setregset = -1;\n-#endif\n+#endif  // PTRACE_GETREGSET/PTRACE_SETREGSET\n #endif\n \n   unsigned path_max = PATH_MAX;\n@@ -257,15 +321,6 @@ namespace __sanitizer {\n   unsigned struct_cdrom_tocentry_sz = sizeof(struct cdrom_tocentry);\n   unsigned struct_cdrom_tochdr_sz = sizeof(struct cdrom_tochdr);\n   unsigned struct_cdrom_volctrl_sz = sizeof(struct cdrom_volctrl);\n-#if SOUND_VERSION >= 0x040000\n-  unsigned struct_copr_buffer_sz = 0;\n-  unsigned struct_copr_debug_buf_sz = 0;\n-  unsigned struct_copr_msg_sz = 0;\n-#else\n-  unsigned struct_copr_buffer_sz = sizeof(struct copr_buffer);\n-  unsigned struct_copr_debug_buf_sz = sizeof(struct copr_debug_buf);\n-  unsigned struct_copr_msg_sz = sizeof(struct copr_msg);\n-#endif\n   unsigned struct_ff_effect_sz = sizeof(struct ff_effect);\n   unsigned struct_floppy_drive_params_sz = sizeof(struct floppy_drive_params);\n   unsigned struct_floppy_drive_struct_sz = sizeof(struct floppy_drive_struct);\n@@ -279,23 +334,34 @@ namespace __sanitizer {\n   unsigned struct_hd_geometry_sz = sizeof(struct hd_geometry);\n   unsigned struct_input_absinfo_sz = sizeof(struct input_absinfo);\n   unsigned struct_input_id_sz = sizeof(struct input_id);\n+  unsigned struct_mtpos_sz = sizeof(struct mtpos);\n+  unsigned struct_termio_sz = sizeof(struct termio);\n+  unsigned struct_vt_consize_sz = sizeof(struct vt_consize);\n+  unsigned struct_vt_sizes_sz = sizeof(struct vt_sizes);\n+  unsigned struct_vt_stat_sz = sizeof(struct vt_stat);\n+#endif  // SANITIZER_LINUX\n+\n+#if SANITIZER_LINUX || SANITIZER_FREEBSD\n+#if SOUND_VERSION >= 0x040000\n+  unsigned struct_copr_buffer_sz = 0;\n+  unsigned struct_copr_debug_buf_sz = 0;\n+  unsigned struct_copr_msg_sz = 0;\n+#else\n+  unsigned struct_copr_buffer_sz = sizeof(struct copr_buffer);\n+  unsigned struct_copr_debug_buf_sz = sizeof(struct copr_debug_buf);\n+  unsigned struct_copr_msg_sz = sizeof(struct copr_msg);\n+#endif\n   unsigned struct_midi_info_sz = sizeof(struct midi_info);\n   unsigned struct_mtget_sz = sizeof(struct mtget);\n   unsigned struct_mtop_sz = sizeof(struct mtop);\n-  unsigned struct_mtpos_sz = sizeof(struct mtpos);\n   unsigned struct_rtentry_sz = sizeof(struct rtentry);\n   unsigned struct_sbi_instrument_sz = sizeof(struct sbi_instrument);\n   unsigned struct_seq_event_rec_sz = sizeof(struct seq_event_rec);\n   unsigned struct_synth_info_sz = sizeof(struct synth_info);\n-  unsigned struct_termio_sz = sizeof(struct termio);\n-  unsigned struct_vt_consize_sz = sizeof(struct vt_consize);\n   unsigned struct_vt_mode_sz = sizeof(struct vt_mode);\n-  unsigned struct_vt_sizes_sz = sizeof(struct vt_sizes);\n-  unsigned struct_vt_stat_sz = sizeof(struct vt_stat);\n-#endif\n+#endif  // SANITIZER_LINUX || SANITIZER_FREEBSD\n \n #if SANITIZER_LINUX && !SANITIZER_ANDROID\n-  unsigned struct_audio_buf_info_sz = sizeof(struct audio_buf_info);\n   unsigned struct_ax25_parms_struct_sz = sizeof(struct ax25_parms_struct);\n   unsigned struct_cyclades_monitor_sz = sizeof(struct cyclades_monitor);\n #if EV_VERSION > (0x010000)\n@@ -310,7 +376,6 @@ namespace __sanitizer {\n   unsigned struct_kbsentry_sz = sizeof(struct kbsentry);\n   unsigned struct_mtconfiginfo_sz = sizeof(struct mtconfiginfo);\n   unsigned struct_nr_parms_struct_sz = sizeof(struct nr_parms_struct);\n-  unsigned struct_ppp_stats_sz = sizeof(struct ppp_stats);\n   unsigned struct_scc_modem_sz = sizeof(struct scc_modem);\n   unsigned struct_scc_stat_sz = sizeof(struct scc_stat);\n   unsigned struct_serial_multiport_struct_sz\n@@ -319,7 +384,12 @@ namespace __sanitizer {\n   unsigned struct_sockaddr_ax25_sz = sizeof(struct sockaddr_ax25);\n   unsigned struct_unimapdesc_sz = sizeof(struct unimapdesc);\n   unsigned struct_unimapinit_sz = sizeof(struct unimapinit);\n-#endif\n+#endif  // SANITIZER_LINUX && !SANITIZER_ANDROID\n+\n+#if (SANITIZER_LINUX || SANITIZER_FREEBSD) && !SANITIZER_ANDROID\n+  unsigned struct_audio_buf_info_sz = sizeof(struct audio_buf_info);\n+  unsigned struct_ppp_stats_sz = sizeof(struct ppp_stats);\n+#endif  // (SANITIZER_LINUX || SANITIZER_FREEBSD) && !SANITIZER_ANDROID\n \n #if !SANITIZER_ANDROID && !SANITIZER_MAC\n   unsigned struct_sioc_sg_req_sz = sizeof(struct sioc_sg_req);\n@@ -372,10 +442,11 @@ namespace __sanitizer {\n   unsigned IOCTL_TIOCSPGRP = TIOCSPGRP;\n   unsigned IOCTL_TIOCSTI = TIOCSTI;\n   unsigned IOCTL_TIOCSWINSZ = TIOCSWINSZ;\n-#if (SANITIZER_LINUX && !SANITIZER_ANDROID)\n+#if ((SANITIZER_LINUX || SANITIZER_FREEBSD) && !SANITIZER_ANDROID)\n   unsigned IOCTL_SIOCGETSGCNT = SIOCGETSGCNT;\n   unsigned IOCTL_SIOCGETVIFCNT = SIOCGETVIFCNT;\n #endif\n+\n #if SANITIZER_LINUX\n   unsigned IOCTL_EVIOCGABS = EVIOCGABS(0);\n   unsigned IOCTL_EVIOCGBIT = EVIOCGBIT(0, 0);\n@@ -466,9 +537,7 @@ namespace __sanitizer {\n   unsigned IOCTL_HDIO_SET_MULTCOUNT = HDIO_SET_MULTCOUNT;\n   unsigned IOCTL_HDIO_SET_NOWERR = HDIO_SET_NOWERR;\n   unsigned IOCTL_HDIO_SET_UNMASKINTR = HDIO_SET_UNMASKINTR;\n-  unsigned IOCTL_MTIOCGET = MTIOCGET;\n   unsigned IOCTL_MTIOCPOS = MTIOCPOS;\n-  unsigned IOCTL_MTIOCTOP = MTIOCTOP;\n   unsigned IOCTL_PPPIOCGASYNCMAP = PPPIOCGASYNCMAP;\n   unsigned IOCTL_PPPIOCGDEBUG = PPPIOCGDEBUG;\n   unsigned IOCTL_PPPIOCGFLAGS = PPPIOCGFLAGS;\n@@ -480,9 +549,7 @@ namespace __sanitizer {\n   unsigned IOCTL_PPPIOCSMAXCID = PPPIOCSMAXCID;\n   unsigned IOCTL_PPPIOCSMRU = PPPIOCSMRU;\n   unsigned IOCTL_PPPIOCSXASYNCMAP = PPPIOCSXASYNCMAP;\n-  unsigned IOCTL_SIOCADDRT = SIOCADDRT;\n   unsigned IOCTL_SIOCDARP = SIOCDARP;\n-  unsigned IOCTL_SIOCDELRT = SIOCDELRT;\n   unsigned IOCTL_SIOCDRARP = SIOCDRARP;\n   unsigned IOCTL_SIOCGARP = SIOCGARP;\n   unsigned IOCTL_SIOCGIFENCAP = SIOCGIFENCAP;\n@@ -501,7 +568,7 @@ namespace __sanitizer {\n   unsigned IOCTL_SIOCSIFMEM = SIOCSIFMEM;\n   unsigned IOCTL_SIOCSIFSLAVE = SIOCSIFSLAVE;\n   unsigned IOCTL_SIOCSRARP = SIOCSRARP;\n-#if SOUND_VERSION >= 0x040000\n+# if SOUND_VERSION >= 0x040000\n   unsigned IOCTL_SNDCTL_COPR_HALT = IOCTL_NOT_PRESENT;\n   unsigned IOCTL_SNDCTL_COPR_LOAD = IOCTL_NOT_PRESENT;\n   unsigned IOCTL_SNDCTL_COPR_RCODE = IOCTL_NOT_PRESENT;\n@@ -518,7 +585,7 @@ namespace __sanitizer {\n   unsigned IOCTL_SOUND_PCM_READ_RATE = IOCTL_NOT_PRESENT;\n   unsigned IOCTL_SOUND_PCM_WRITE_CHANNELS = IOCTL_NOT_PRESENT;\n   unsigned IOCTL_SOUND_PCM_WRITE_FILTER = IOCTL_NOT_PRESENT;\n-#else\n+# else  // SOUND_VERSION\n   unsigned IOCTL_SNDCTL_COPR_HALT = SNDCTL_COPR_HALT;\n   unsigned IOCTL_SNDCTL_COPR_LOAD = SNDCTL_COPR_LOAD;\n   unsigned IOCTL_SNDCTL_COPR_RCODE = SNDCTL_COPR_RCODE;\n@@ -535,7 +602,41 @@ namespace __sanitizer {\n   unsigned IOCTL_SOUND_PCM_READ_RATE = SOUND_PCM_READ_RATE;\n   unsigned IOCTL_SOUND_PCM_WRITE_CHANNELS = SOUND_PCM_WRITE_CHANNELS;\n   unsigned IOCTL_SOUND_PCM_WRITE_FILTER = SOUND_PCM_WRITE_FILTER;\n-#endif\n+#endif  // SOUND_VERSION\n+  unsigned IOCTL_TCFLSH = TCFLSH;\n+  unsigned IOCTL_TCGETA = TCGETA;\n+  unsigned IOCTL_TCGETS = TCGETS;\n+  unsigned IOCTL_TCSBRK = TCSBRK;\n+  unsigned IOCTL_TCSBRKP = TCSBRKP;\n+  unsigned IOCTL_TCSETA = TCSETA;\n+  unsigned IOCTL_TCSETAF = TCSETAF;\n+  unsigned IOCTL_TCSETAW = TCSETAW;\n+  unsigned IOCTL_TCSETS = TCSETS;\n+  unsigned IOCTL_TCSETSF = TCSETSF;\n+  unsigned IOCTL_TCSETSW = TCSETSW;\n+  unsigned IOCTL_TCXONC = TCXONC;\n+  unsigned IOCTL_TIOCGLCKTRMIOS = TIOCGLCKTRMIOS;\n+  unsigned IOCTL_TIOCGSOFTCAR = TIOCGSOFTCAR;\n+  unsigned IOCTL_TIOCINQ = TIOCINQ;\n+  unsigned IOCTL_TIOCLINUX = TIOCLINUX;\n+  unsigned IOCTL_TIOCSERCONFIG = TIOCSERCONFIG;\n+  unsigned IOCTL_TIOCSERGETLSR = TIOCSERGETLSR;\n+  unsigned IOCTL_TIOCSERGWILD = TIOCSERGWILD;\n+  unsigned IOCTL_TIOCSERSWILD = TIOCSERSWILD;\n+  unsigned IOCTL_TIOCSLCKTRMIOS = TIOCSLCKTRMIOS;\n+  unsigned IOCTL_TIOCSSOFTCAR = TIOCSSOFTCAR;\n+  unsigned IOCTL_VT_DISALLOCATE = VT_DISALLOCATE;\n+  unsigned IOCTL_VT_GETSTATE = VT_GETSTATE;\n+  unsigned IOCTL_VT_RESIZE = VT_RESIZE;\n+  unsigned IOCTL_VT_RESIZEX = VT_RESIZEX;\n+  unsigned IOCTL_VT_SENDSIG = VT_SENDSIG;\n+#endif // SANITIZER_LINUX\n+\n+#if SANITIZER_LINUX || SANITIZER_FREEBSD\n+  unsigned IOCTL_MTIOCGET = MTIOCGET;\n+  unsigned IOCTL_MTIOCTOP = MTIOCTOP;\n+  unsigned IOCTL_SIOCADDRT = SIOCADDRT;\n+  unsigned IOCTL_SIOCDELRT = SIOCDELRT;\n   unsigned IOCTL_SNDCTL_DSP_GETBLKSIZE = SNDCTL_DSP_GETBLKSIZE;\n   unsigned IOCTL_SNDCTL_DSP_GETFMTS = SNDCTL_DSP_GETFMTS;\n   unsigned IOCTL_SNDCTL_DSP_NONBLOCK = SNDCTL_DSP_NONBLOCK;\n@@ -620,40 +721,14 @@ namespace __sanitizer {\n   unsigned IOCTL_SOUND_MIXER_WRITE_SYNTH = SOUND_MIXER_WRITE_SYNTH;\n   unsigned IOCTL_SOUND_MIXER_WRITE_TREBLE = SOUND_MIXER_WRITE_TREBLE;\n   unsigned IOCTL_SOUND_MIXER_WRITE_VOLUME = SOUND_MIXER_WRITE_VOLUME;\n-  unsigned IOCTL_TCFLSH = TCFLSH;\n-  unsigned IOCTL_TCGETA = TCGETA;\n-  unsigned IOCTL_TCGETS = TCGETS;\n-  unsigned IOCTL_TCSBRK = TCSBRK;\n-  unsigned IOCTL_TCSBRKP = TCSBRKP;\n-  unsigned IOCTL_TCSETA = TCSETA;\n-  unsigned IOCTL_TCSETAF = TCSETAF;\n-  unsigned IOCTL_TCSETAW = TCSETAW;\n-  unsigned IOCTL_TCSETS = TCSETS;\n-  unsigned IOCTL_TCSETSF = TCSETSF;\n-  unsigned IOCTL_TCSETSW = TCSETSW;\n-  unsigned IOCTL_TCXONC = TCXONC;\n-  unsigned IOCTL_TIOCGLCKTRMIOS = TIOCGLCKTRMIOS;\n-  unsigned IOCTL_TIOCGSOFTCAR = TIOCGSOFTCAR;\n-  unsigned IOCTL_TIOCINQ = TIOCINQ;\n-  unsigned IOCTL_TIOCLINUX = TIOCLINUX;\n-  unsigned IOCTL_TIOCSERCONFIG = TIOCSERCONFIG;\n-  unsigned IOCTL_TIOCSERGETLSR = TIOCSERGETLSR;\n-  unsigned IOCTL_TIOCSERGWILD = TIOCSERGWILD;\n-  unsigned IOCTL_TIOCSERSWILD = TIOCSERSWILD;\n-  unsigned IOCTL_TIOCSLCKTRMIOS = TIOCSLCKTRMIOS;\n-  unsigned IOCTL_TIOCSSOFTCAR = TIOCSSOFTCAR;\n   unsigned IOCTL_VT_ACTIVATE = VT_ACTIVATE;\n-  unsigned IOCTL_VT_DISALLOCATE = VT_DISALLOCATE;\n   unsigned IOCTL_VT_GETMODE = VT_GETMODE;\n-  unsigned IOCTL_VT_GETSTATE = VT_GETSTATE;\n   unsigned IOCTL_VT_OPENQRY = VT_OPENQRY;\n   unsigned IOCTL_VT_RELDISP = VT_RELDISP;\n-  unsigned IOCTL_VT_RESIZE = VT_RESIZE;\n-  unsigned IOCTL_VT_RESIZEX = VT_RESIZEX;\n-  unsigned IOCTL_VT_SENDSIG = VT_SENDSIG;\n   unsigned IOCTL_VT_SETMODE = VT_SETMODE;\n   unsigned IOCTL_VT_WAITACTIVE = VT_WAITACTIVE;\n-#endif\n+#endif  // SANITIZER_LINUX || SANITIZER_FREEBSD\n+\n #if SANITIZER_LINUX && !SANITIZER_ANDROID\n   unsigned IOCTL_CYGETDEFTHRESH = CYGETDEFTHRESH;\n   unsigned IOCTL_CYGETDEFTIMEOUT = CYGETDEFTIMEOUT;\n@@ -685,37 +760,25 @@ namespace __sanitizer {\n   unsigned IOCTL_FS_IOC_SETVERSION = FS_IOC_SETVERSION;\n   unsigned IOCTL_GIO_CMAP = GIO_CMAP;\n   unsigned IOCTL_GIO_FONT = GIO_FONT;\n-  unsigned IOCTL_GIO_SCRNMAP = GIO_SCRNMAP;\n   unsigned IOCTL_GIO_UNIMAP = GIO_UNIMAP;\n   unsigned IOCTL_GIO_UNISCRNMAP = GIO_UNISCRNMAP;\n   unsigned IOCTL_KDADDIO = KDADDIO;\n   unsigned IOCTL_KDDELIO = KDDELIO;\n-  unsigned IOCTL_KDDISABIO = KDDISABIO;\n-  unsigned IOCTL_KDENABIO = KDENABIO;\n   unsigned IOCTL_KDGETKEYCODE = KDGETKEYCODE;\n-  unsigned IOCTL_KDGETLED = KDGETLED;\n-  unsigned IOCTL_KDGETMODE = KDGETMODE;\n   unsigned IOCTL_KDGKBDIACR = KDGKBDIACR;\n   unsigned IOCTL_KDGKBENT = KDGKBENT;\n   unsigned IOCTL_KDGKBLED = KDGKBLED;\n   unsigned IOCTL_KDGKBMETA = KDGKBMETA;\n-  unsigned IOCTL_KDGKBMODE = KDGKBMODE;\n   unsigned IOCTL_KDGKBSENT = KDGKBSENT;\n-  unsigned IOCTL_KDGKBTYPE = KDGKBTYPE;\n   unsigned IOCTL_KDMAPDISP = KDMAPDISP;\n-  unsigned IOCTL_KDMKTONE = KDMKTONE;\n   unsigned IOCTL_KDSETKEYCODE = KDSETKEYCODE;\n-  unsigned IOCTL_KDSETLED = KDSETLED;\n-  unsigned IOCTL_KDSETMODE = KDSETMODE;\n   unsigned IOCTL_KDSIGACCEPT = KDSIGACCEPT;\n   unsigned IOCTL_KDSKBDIACR = KDSKBDIACR;\n   unsigned IOCTL_KDSKBENT = KDSKBENT;\n   unsigned IOCTL_KDSKBLED = KDSKBLED;\n   unsigned IOCTL_KDSKBMETA = KDSKBMETA;\n-  unsigned IOCTL_KDSKBMODE = KDSKBMODE;\n   unsigned IOCTL_KDSKBSENT = KDSKBSENT;\n   unsigned IOCTL_KDUNMAPDISP = KDUNMAPDISP;\n-  unsigned IOCTL_KIOCSOUND = KIOCSOUND;\n   unsigned IOCTL_LPABORT = LPABORT;\n   unsigned IOCTL_LPABORTOPEN = LPABORTOPEN;\n   unsigned IOCTL_LPCAREFUL = LPCAREFUL;\n@@ -730,7 +793,6 @@ namespace __sanitizer {\n   unsigned IOCTL_MTIOCSETCONFIG = MTIOCSETCONFIG;\n   unsigned IOCTL_PIO_CMAP = PIO_CMAP;\n   unsigned IOCTL_PIO_FONT = PIO_FONT;\n-  unsigned IOCTL_PIO_SCRNMAP = PIO_SCRNMAP;\n   unsigned IOCTL_PIO_UNIMAP = PIO_UNIMAP;\n   unsigned IOCTL_PIO_UNIMAPCLR = PIO_UNIMAPCLR;\n   unsigned IOCTL_PIO_UNISCRNMAP = PIO_UNISCRNMAP;\n@@ -752,20 +814,40 @@ namespace __sanitizer {\n   unsigned IOCTL_SIOCNRGETPARMS = SIOCNRGETPARMS;\n   unsigned IOCTL_SIOCNRRTCTL = SIOCNRRTCTL;\n   unsigned IOCTL_SIOCNRSETPARMS = SIOCNRSETPARMS;\n-  unsigned IOCTL_SNDCTL_DSP_GETISPACE = SNDCTL_DSP_GETISPACE;\n-  unsigned IOCTL_SNDCTL_DSP_GETOSPACE = SNDCTL_DSP_GETOSPACE;\n   unsigned IOCTL_TIOCGSERIAL = TIOCGSERIAL;\n   unsigned IOCTL_TIOCSERGETMULTI = TIOCSERGETMULTI;\n   unsigned IOCTL_TIOCSERSETMULTI = TIOCSERSETMULTI;\n   unsigned IOCTL_TIOCSSERIAL = TIOCSSERIAL;\n-#endif\n+#endif  // SANITIZER_LINUX && !SANITIZER_ANDROID\n \n+#if (SANITIZER_LINUX || SANITIZER_FREEBSD) && !SANITIZER_ANDROID\n+  unsigned IOCTL_GIO_SCRNMAP = GIO_SCRNMAP;\n+  unsigned IOCTL_KDDISABIO = KDDISABIO;\n+  unsigned IOCTL_KDENABIO = KDENABIO;\n+  unsigned IOCTL_KDGETLED = KDGETLED;\n+  unsigned IOCTL_KDGETMODE = KDGETMODE;\n+  unsigned IOCTL_KDGKBMODE = KDGKBMODE;\n+  unsigned IOCTL_KDGKBTYPE = KDGKBTYPE;\n+  unsigned IOCTL_KDMKTONE = KDMKTONE;\n+  unsigned IOCTL_KDSETLED = KDSETLED;\n+  unsigned IOCTL_KDSETMODE = KDSETMODE;\n+  unsigned IOCTL_KDSKBMODE = KDSKBMODE;\n+  unsigned IOCTL_KIOCSOUND = KIOCSOUND;\n+  unsigned IOCTL_PIO_SCRNMAP = PIO_SCRNMAP;\n+  unsigned IOCTL_SNDCTL_DSP_GETISPACE = SNDCTL_DSP_GETISPACE;\n+  unsigned IOCTL_SNDCTL_DSP_GETOSPACE = SNDCTL_DSP_GETOSPACE;\n+#endif  // (SANITIZER_LINUX || SANITIZER_FREEBSD) && !SANITIZER_ANDROID\n+\n+  const int errno_EINVAL = EINVAL;\n // EOWNERDEAD is not present in some older platforms.\n #if defined(EOWNERDEAD)\n-  extern const int errno_EOWNERDEAD = EOWNERDEAD;\n+  const int errno_EOWNERDEAD = EOWNERDEAD;\n #else\n-  extern const int errno_EOWNERDEAD = -1;\n+  const int errno_EOWNERDEAD = -1;\n #endif\n+\n+  const int si_SEGV_MAPERR = SEGV_MAPERR;\n+  const int si_SEGV_ACCERR = SEGV_ACCERR;\n }  // namespace __sanitizer\n \n COMPILER_CHECK(sizeof(__sanitizer_pthread_attr_t) >= sizeof(pthread_attr_t));\n@@ -774,18 +856,41 @@ COMPILER_CHECK(sizeof(socklen_t) == sizeof(unsigned));\n CHECK_TYPE_SIZE(pthread_key_t);\n \n #if SANITIZER_LINUX\n+// FIXME: We define those on Linux and Mac, but only check on Linux.\n+COMPILER_CHECK(IOC_NRBITS == _IOC_NRBITS);\n+COMPILER_CHECK(IOC_TYPEBITS == _IOC_TYPEBITS);\n+COMPILER_CHECK(IOC_SIZEBITS == _IOC_SIZEBITS);\n+COMPILER_CHECK(IOC_DIRBITS == _IOC_DIRBITS);\n+COMPILER_CHECK(IOC_NRMASK == _IOC_NRMASK);\n+COMPILER_CHECK(IOC_TYPEMASK == _IOC_TYPEMASK);\n+COMPILER_CHECK(IOC_SIZEMASK == _IOC_SIZEMASK);\n+COMPILER_CHECK(IOC_DIRMASK == _IOC_DIRMASK);\n+COMPILER_CHECK(IOC_NRSHIFT == _IOC_NRSHIFT);\n+COMPILER_CHECK(IOC_TYPESHIFT == _IOC_TYPESHIFT);\n+COMPILER_CHECK(IOC_SIZESHIFT == _IOC_SIZESHIFT);\n+COMPILER_CHECK(IOC_DIRSHIFT == _IOC_DIRSHIFT);\n+COMPILER_CHECK(IOC_NONE == _IOC_NONE);\n+COMPILER_CHECK(IOC_WRITE == _IOC_WRITE);\n+COMPILER_CHECK(IOC_READ == _IOC_READ);\n+COMPILER_CHECK(EVIOC_ABS_MAX == ABS_MAX);\n+COMPILER_CHECK(EVIOC_EV_MAX == EV_MAX);\n+COMPILER_CHECK(IOC_SIZE(0x12345678) == _IOC_SIZE(0x12345678));\n+COMPILER_CHECK(IOC_DIR(0x12345678) == _IOC_DIR(0x12345678));\n+COMPILER_CHECK(IOC_NR(0x12345678) == _IOC_NR(0x12345678));\n+COMPILER_CHECK(IOC_TYPE(0x12345678) == _IOC_TYPE(0x12345678));\n+#endif  // SANITIZER_LINUX\n+\n+#if SANITIZER_LINUX || SANITIZER_FREEBSD\n // There are more undocumented fields in dl_phdr_info that we are not interested\n // in.\n COMPILER_CHECK(sizeof(__sanitizer_dl_phdr_info) <= sizeof(dl_phdr_info));\n CHECK_SIZE_AND_OFFSET(dl_phdr_info, dlpi_addr);\n CHECK_SIZE_AND_OFFSET(dl_phdr_info, dlpi_name);\n CHECK_SIZE_AND_OFFSET(dl_phdr_info, dlpi_phdr);\n CHECK_SIZE_AND_OFFSET(dl_phdr_info, dlpi_phnum);\n+#endif  // SANITIZER_LINUX || SANITIZER_FREEBSD\n \n-COMPILER_CHECK(IOC_SIZE(0x12345678) == _IOC_SIZE(0x12345678));\n-#endif\n-\n-#if SANITIZER_LINUX && !SANITIZER_ANDROID\n+#if (SANITIZER_LINUX || SANITIZER_FREEBSD) && !SANITIZER_ANDROID\n CHECK_TYPE_SIZE(glob_t);\n CHECK_SIZE_AND_OFFSET(glob_t, gl_pathc);\n CHECK_SIZE_AND_OFFSET(glob_t, gl_pathv);\n@@ -837,6 +942,8 @@ COMPILER_CHECK(sizeof(__sanitizer_dirent) <= sizeof(dirent));\n CHECK_SIZE_AND_OFFSET(dirent, d_ino);\n #if SANITIZER_MAC\n CHECK_SIZE_AND_OFFSET(dirent, d_seekoff);\n+#elif SANITIZER_FREEBSD\n+// There is no 'd_off' field on FreeBSD.\n #else\n CHECK_SIZE_AND_OFFSET(dirent, d_off);\n #endif\n@@ -921,15 +1028,20 @@ CHECK_SIZE_AND_OFFSET(mntent, mnt_passno);\n \n CHECK_TYPE_SIZE(ether_addr);\n \n-#if SANITIZER_LINUX && !SANITIZER_ANDROID\n+#if (SANITIZER_LINUX || SANITIZER_FREEBSD) && !SANITIZER_ANDROID\n CHECK_TYPE_SIZE(ipc_perm);\n+# if SANITIZER_FREEBSD\n+CHECK_SIZE_AND_OFFSET(ipc_perm, key);\n+CHECK_SIZE_AND_OFFSET(ipc_perm, seq);\n+# else\n CHECK_SIZE_AND_OFFSET(ipc_perm, __key);\n+CHECK_SIZE_AND_OFFSET(ipc_perm, __seq);\n+# endif\n CHECK_SIZE_AND_OFFSET(ipc_perm, uid);\n CHECK_SIZE_AND_OFFSET(ipc_perm, gid);\n CHECK_SIZE_AND_OFFSET(ipc_perm, cuid);\n CHECK_SIZE_AND_OFFSET(ipc_perm, cgid);\n CHECK_SIZE_AND_OFFSET(ipc_perm, mode);\n-CHECK_SIZE_AND_OFFSET(ipc_perm, __seq);\n \n CHECK_TYPE_SIZE(shmid_ds);\n CHECK_SIZE_AND_OFFSET(shmid_ds, shm_perm);\n@@ -944,4 +1056,108 @@ CHECK_SIZE_AND_OFFSET(shmid_ds, shm_nattch);\n \n CHECK_TYPE_SIZE(clock_t);\n \n-#endif  // SANITIZER_LINUX || SANITIZER_MAC\n+#if !SANITIZER_ANDROID\n+CHECK_TYPE_SIZE(ifaddrs);\n+CHECK_SIZE_AND_OFFSET(ifaddrs, ifa_next);\n+CHECK_SIZE_AND_OFFSET(ifaddrs, ifa_name);\n+CHECK_SIZE_AND_OFFSET(ifaddrs, ifa_addr);\n+CHECK_SIZE_AND_OFFSET(ifaddrs, ifa_netmask);\n+#if SANITIZER_LINUX || SANITIZER_FREEBSD\n+// Compare against the union, because we can't reach into the union in a\n+// compliant way.\n+#ifdef ifa_dstaddr\n+#undef ifa_dstaddr\n+#endif\n+# if SANITIZER_FREEBSD\n+CHECK_SIZE_AND_OFFSET(ifaddrs, ifa_dstaddr);\n+# else\n+COMPILER_CHECK(sizeof(((__sanitizer_ifaddrs *)NULL)->ifa_dstaddr) ==\n+               sizeof(((ifaddrs *)NULL)->ifa_ifu));\n+COMPILER_CHECK(offsetof(__sanitizer_ifaddrs, ifa_dstaddr) ==\n+               offsetof(ifaddrs, ifa_ifu));\n+# endif  // SANITIZER_FREEBSD\n+#else\n+CHECK_SIZE_AND_OFFSET(ifaddrs, ifa_dstaddr);\n+#endif  // SANITIZER_LINUX\n+CHECK_SIZE_AND_OFFSET(ifaddrs, ifa_data);\n+#endif\n+\n+#if SANITIZER_LINUX\n+COMPILER_CHECK(sizeof(__sanitizer_mallinfo) == sizeof(struct mallinfo));\n+#endif\n+\n+CHECK_TYPE_SIZE(timeb);\n+CHECK_SIZE_AND_OFFSET(timeb, time);\n+CHECK_SIZE_AND_OFFSET(timeb, millitm);\n+CHECK_SIZE_AND_OFFSET(timeb, timezone);\n+CHECK_SIZE_AND_OFFSET(timeb, dstflag);\n+\n+CHECK_TYPE_SIZE(passwd);\n+CHECK_SIZE_AND_OFFSET(passwd, pw_name);\n+CHECK_SIZE_AND_OFFSET(passwd, pw_passwd);\n+CHECK_SIZE_AND_OFFSET(passwd, pw_uid);\n+CHECK_SIZE_AND_OFFSET(passwd, pw_gid);\n+CHECK_SIZE_AND_OFFSET(passwd, pw_dir);\n+CHECK_SIZE_AND_OFFSET(passwd, pw_shell);\n+\n+#if !SANITIZER_ANDROID\n+CHECK_SIZE_AND_OFFSET(passwd, pw_gecos);\n+#endif\n+\n+#if SANITIZER_MAC\n+CHECK_SIZE_AND_OFFSET(passwd, pw_change);\n+CHECK_SIZE_AND_OFFSET(passwd, pw_expire);\n+CHECK_SIZE_AND_OFFSET(passwd, pw_class);\n+#endif\n+\n+\n+CHECK_TYPE_SIZE(group);\n+CHECK_SIZE_AND_OFFSET(group, gr_name);\n+CHECK_SIZE_AND_OFFSET(group, gr_passwd);\n+CHECK_SIZE_AND_OFFSET(group, gr_gid);\n+CHECK_SIZE_AND_OFFSET(group, gr_mem);\n+\n+#if SANITIZER_LINUX && !SANITIZER_ANDROID\n+CHECK_TYPE_SIZE(XDR);\n+CHECK_SIZE_AND_OFFSET(XDR, x_op);\n+CHECK_SIZE_AND_OFFSET(XDR, x_ops);\n+CHECK_SIZE_AND_OFFSET(XDR, x_public);\n+CHECK_SIZE_AND_OFFSET(XDR, x_private);\n+CHECK_SIZE_AND_OFFSET(XDR, x_base);\n+CHECK_SIZE_AND_OFFSET(XDR, x_handy);\n+COMPILER_CHECK(__sanitizer_XDR_ENCODE == XDR_ENCODE);\n+COMPILER_CHECK(__sanitizer_XDR_DECODE == XDR_DECODE);\n+COMPILER_CHECK(__sanitizer_XDR_FREE == XDR_FREE);\n+#endif\n+\n+#if SANITIZER_LINUX && !SANITIZER_ANDROID\n+COMPILER_CHECK(sizeof(__sanitizer_FILE) <= sizeof(FILE));\n+CHECK_SIZE_AND_OFFSET(FILE, _flags);\n+CHECK_SIZE_AND_OFFSET(FILE, _IO_read_ptr);\n+CHECK_SIZE_AND_OFFSET(FILE, _IO_read_end);\n+CHECK_SIZE_AND_OFFSET(FILE, _IO_read_base);\n+CHECK_SIZE_AND_OFFSET(FILE, _IO_write_ptr);\n+CHECK_SIZE_AND_OFFSET(FILE, _IO_write_end);\n+CHECK_SIZE_AND_OFFSET(FILE, _IO_write_base);\n+CHECK_SIZE_AND_OFFSET(FILE, _IO_buf_base);\n+CHECK_SIZE_AND_OFFSET(FILE, _IO_buf_end);\n+CHECK_SIZE_AND_OFFSET(FILE, _IO_save_base);\n+CHECK_SIZE_AND_OFFSET(FILE, _IO_backup_base);\n+CHECK_SIZE_AND_OFFSET(FILE, _IO_save_end);\n+CHECK_SIZE_AND_OFFSET(FILE, _markers);\n+CHECK_SIZE_AND_OFFSET(FILE, _chain);\n+CHECK_SIZE_AND_OFFSET(FILE, _fileno);\n+#endif\n+\n+#if SANITIZER_LINUX && !SANITIZER_ANDROID\n+COMPILER_CHECK(sizeof(__sanitizer__obstack_chunk) <= sizeof(_obstack_chunk));\n+CHECK_SIZE_AND_OFFSET(_obstack_chunk, limit);\n+CHECK_SIZE_AND_OFFSET(_obstack_chunk, prev);\n+CHECK_TYPE_SIZE(obstack);\n+CHECK_SIZE_AND_OFFSET(obstack, chunk_size);\n+CHECK_SIZE_AND_OFFSET(obstack, chunk);\n+CHECK_SIZE_AND_OFFSET(obstack, object_base);\n+CHECK_SIZE_AND_OFFSET(obstack, next_free);\n+#endif\n+\n+#endif  // SANITIZER_LINUX || SANITIZER_FREEBSD || SANITIZER_MAC"}, {"sha": "dece2d3cbdd2a171bf90b995e3f270ff7ed017a0", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.h", "status": "modified", "additions": 349, "deletions": 96, "changes": 445, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -19,19 +19,18 @@\n namespace __sanitizer {\n   extern unsigned struct_utsname_sz;\n   extern unsigned struct_stat_sz;\n-#if !SANITIZER_IOS\n+#if !SANITIZER_FREEBSD && !SANITIZER_IOS\n   extern unsigned struct_stat64_sz;\n #endif\n   extern unsigned struct_rusage_sz;\n-  extern unsigned struct_passwd_sz;\n-  extern unsigned struct_group_sz;\n   extern unsigned siginfo_t_sz;\n   extern unsigned struct_itimerval_sz;\n   extern unsigned pthread_t_sz;\n   extern unsigned pthread_cond_t_sz;\n   extern unsigned pid_t_sz;\n   extern unsigned timeval_sz;\n   extern unsigned uid_t_sz;\n+  extern unsigned gid_t_sz;\n   extern unsigned mbstate_t_sz;\n   extern unsigned struct_timezone_sz;\n   extern unsigned struct_tms_sz;\n@@ -40,6 +39,7 @@ namespace __sanitizer {\n   extern unsigned struct_sched_param_sz;\n   extern unsigned struct_statfs_sz;\n   extern unsigned struct_statfs64_sz;\n+  extern unsigned struct_sockaddr_sz;\n \n #if !SANITIZER_ANDROID\n   extern unsigned ucontext_t_sz;\n@@ -48,23 +48,21 @@ namespace __sanitizer {\n #if SANITIZER_LINUX\n \n #if defined(__x86_64__)\n-  const unsigned struct___old_kernel_stat_sz = 32;\n   const unsigned struct_kernel_stat_sz = 144;\n   const unsigned struct_kernel_stat64_sz = 0;\n #elif defined(__i386__)\n-  const unsigned struct___old_kernel_stat_sz = 32;\n   const unsigned struct_kernel_stat_sz = 64;\n   const unsigned struct_kernel_stat64_sz = 96;\n #elif defined(__arm__)\n-  const unsigned struct___old_kernel_stat_sz = 32;\n   const unsigned struct_kernel_stat_sz = 64;\n   const unsigned struct_kernel_stat64_sz = 104;\n+#elif defined(__aarch64__)\n+  const unsigned struct_kernel_stat_sz = 128;\n+  const unsigned struct_kernel_stat64_sz = 104;\n #elif defined(__powerpc__) && !defined(__powerpc64__)\n-  const unsigned struct___old_kernel_stat_sz = 32;\n   const unsigned struct_kernel_stat_sz = 72;\n   const unsigned struct_kernel_stat64_sz = 104;\n #elif defined(__powerpc64__)\n-  const unsigned struct___old_kernel_stat_sz = 0;\n   const unsigned struct_kernel_stat_sz = 144;\n   const unsigned struct_kernel_stat64_sz = 104;\n #endif\n@@ -74,23 +72,28 @@ namespace __sanitizer {\n     // More fields that vary with the kernel version.\n   };\n \n-  extern unsigned struct_utimbuf_sz;\n+  extern unsigned struct_epoll_event_sz;\n+  extern unsigned struct_sysinfo_sz;\n+  extern unsigned __user_cap_header_struct_sz;\n+  extern unsigned __user_cap_data_struct_sz;\n   extern unsigned struct_new_utsname_sz;\n   extern unsigned struct_old_utsname_sz;\n   extern unsigned struct_oldold_utsname_sz;\n-  extern unsigned struct_msqid_ds_sz;\n-  extern unsigned struct_mq_attr_sz;\n-  extern unsigned struct_timex_sz;\n-  extern unsigned struct_ustat_sz;\n+\n+  const unsigned struct_kexec_segment_sz = 4 * sizeof(unsigned long);\n+#endif  // SANITIZER_LINUX\n+\n+#if SANITIZER_LINUX || SANITIZER_FREEBSD\n+\n+#if defined(__powerpc64__)\n+  const unsigned struct___old_kernel_stat_sz = 0;\n+#else\n+  const unsigned struct___old_kernel_stat_sz = 32;\n+#endif\n \n   extern unsigned struct_rlimit_sz;\n-  extern unsigned struct_epoll_event_sz;\n-  extern unsigned struct_sysinfo_sz;\n+  extern unsigned struct_utimbuf_sz;\n   extern unsigned struct_timespec_sz;\n-  extern unsigned __user_cap_header_struct_sz;\n-  extern unsigned __user_cap_data_struct_sz;\n-  const unsigned old_sigset_t_sz = sizeof(unsigned long);\n-  const unsigned struct_kexec_segment_sz = 4 * sizeof(unsigned long);\n \n   struct __sanitizer_iocb {\n     u64   aio_data;\n@@ -127,11 +130,23 @@ namespace __sanitizer {\n     uptr newlen;\n     unsigned long ___unused[4];\n   };\n-#endif // SANITIZER_LINUX\n+\n+  const unsigned old_sigset_t_sz = sizeof(unsigned long);\n+#endif // SANITIZER_LINUX || SANITIZER_FREEBSD\n+\n+#if SANITIZER_ANDROID\n+  struct __sanitizer_mallinfo {\n+    uptr v[10];\n+  };\n+#endif\n \n #if SANITIZER_LINUX && !SANITIZER_ANDROID\n+  struct __sanitizer_mallinfo {\n+    int v[10];\n+  };\n+\n+  extern unsigned struct_ustat_sz;\n   extern unsigned struct_rlimit64_sz;\n-  extern unsigned struct_statvfs_sz;\n   extern unsigned struct_statvfs64_sz;\n \n   struct __sanitizer_ipc_perm {\n@@ -200,19 +215,121 @@ namespace __sanitizer {\n     uptr __unused5;\n   #endif\n   };\n-  #endif  // SANITIZER_LINUX && !SANITIZER_ANDROID\n+#elif SANITIZER_FREEBSD\n+  struct __sanitizer_ipc_perm {\n+    unsigned int cuid;\n+    unsigned int cgid;\n+    unsigned int uid;\n+    unsigned int gid;\n+    unsigned short mode;\n+    unsigned short seq;\n+    long key;\n+  };\n+\n+  struct __sanitizer_shmid_ds {\n+    __sanitizer_ipc_perm shm_perm;\n+    unsigned long shm_segsz;\n+    unsigned int shm_lpid;\n+    unsigned int shm_cpid;\n+    int shm_nattch;\n+    unsigned long shm_atime;\n+    unsigned long shm_dtime;\n+    unsigned long shm_ctime;\n+  };\n+#endif\n+\n+#if (SANITIZER_LINUX || SANITIZER_FREEBSD) && !SANITIZER_ANDROID\n+  extern unsigned struct_msqid_ds_sz;\n+  extern unsigned struct_mq_attr_sz;\n+  extern unsigned struct_timex_sz;\n+  extern unsigned struct_statvfs_sz;\n+#endif  // (SANITIZER_LINUX || SANITIZER_FREEBSD) && !SANITIZER_ANDROID\n \n   struct __sanitizer_iovec {\n-    void  *iov_base;\n+    void *iov_base;\n     uptr iov_len;\n   };\n \n+#if !SANITIZER_ANDROID\n+  struct __sanitizer_ifaddrs {\n+    struct __sanitizer_ifaddrs *ifa_next;\n+    char *ifa_name;\n+    unsigned int ifa_flags;\n+    void *ifa_addr;    // (struct sockaddr *)\n+    void *ifa_netmask; // (struct sockaddr *)\n+    // This is a union on Linux.\n+# ifdef ifa_dstaddr\n+# undef ifa_dstaddr\n+# endif\n+    void *ifa_dstaddr; // (struct sockaddr *)\n+    void *ifa_data;\n+  };\n+#endif  // !SANITIZER_ANDROID\n+\n #if SANITIZER_MAC\n   typedef unsigned long __sanitizer_pthread_key_t;\n #else\n   typedef unsigned __sanitizer_pthread_key_t;\n #endif\n \n+#if SANITIZER_LINUX && !SANITIZER_ANDROID\n+\n+  struct __sanitizer_XDR {\n+    int x_op;\n+    void *x_ops;\n+    uptr x_public;\n+    uptr x_private;\n+    uptr x_base;\n+    unsigned x_handy;\n+  };\n+\n+  const int __sanitizer_XDR_ENCODE = 0;\n+  const int __sanitizer_XDR_DECODE = 1;\n+  const int __sanitizer_XDR_FREE = 2;\n+#endif\n+\n+  struct __sanitizer_passwd {\n+    char *pw_name;\n+    char *pw_passwd;\n+    int pw_uid;\n+    int pw_gid;\n+#if SANITIZER_MAC || SANITIZER_FREEBSD\n+    long pw_change;\n+    char *pw_class;\n+#endif\n+#if !SANITIZER_ANDROID\n+    char *pw_gecos;\n+#endif\n+    char *pw_dir;\n+    char *pw_shell;\n+#if SANITIZER_MAC || SANITIZER_FREEBSD\n+    long pw_expire;\n+#endif\n+#if SANITIZER_FREEBSD\n+    int pw_fields;\n+#endif\n+  };\n+\n+  struct __sanitizer_group {\n+    char *gr_name;\n+    char *gr_passwd;\n+    int gr_gid;\n+    char **gr_mem;\n+  };\n+\n+#if defined(__x86_64__) && !defined(_LP64)\n+  typedef long long __sanitizer_time_t;\n+#else\n+  typedef long __sanitizer_time_t;\n+#endif\n+\n+  struct __sanitizer_timeb {\n+    __sanitizer_time_t time;\n+    unsigned short millitm;\n+    short timezone;\n+    short dstflag;\n+  };\n+\n   struct __sanitizer_ether_addr {\n     u8 octet[6];\n   };\n@@ -242,7 +359,7 @@ namespace __sanitizer {\n   };\n #endif\n \n-#if SANITIZER_ANDROID || SANITIZER_MAC\n+#if SANITIZER_ANDROID || SANITIZER_MAC || SANITIZER_FREEBSD\n   struct __sanitizer_msghdr {\n     void *msg_name;\n     unsigned msg_namelen;\n@@ -281,6 +398,12 @@ namespace __sanitizer {\n     unsigned short d_reclen;\n     // more fields that we don't care about\n   };\n+#elif SANITIZER_FREEBSD\n+  struct __sanitizer_dirent {\n+    unsigned int d_fileno;\n+    unsigned short d_reclen;\n+    // more fields that we don't care about\n+  };\n #elif SANITIZER_ANDROID || defined(__x86_64__)\n   struct __sanitizer_dirent {\n     unsigned long long d_ino;\n@@ -306,13 +429,16 @@ namespace __sanitizer {\n   };\n #endif\n \n-#if defined(__x86_64__) && !defined(_LP64)\n+// 'clock_t' is 32 bits wide on x64 FreeBSD\n+#if SANITIZER_FREEBSD\n+  typedef int __sanitizer_clock_t;\n+#elif defined(__x86_64__) && !defined(_LP64)\n   typedef long long __sanitizer_clock_t;\n #else\n   typedef long __sanitizer_clock_t;\n #endif\n \n-#if SANITIZER_LINUX\n+#if SANITIZER_LINUX || SANITIZER_FREEBSD\n #if defined(_LP64) || defined(__x86_64__) || defined(__powerpc__)\n   typedef unsigned __sanitizer___kernel_uid_t;\n   typedef unsigned __sanitizer___kernel_gid_t;\n@@ -326,7 +452,7 @@ namespace __sanitizer {\n   typedef long __sanitizer___kernel_off_t;\n #endif\n \n-#if defined(__powerpc__)\n+#if defined(__powerpc__) || defined(__aarch64__)\n   typedef unsigned int __sanitizer___kernel_old_uid_t;\n   typedef unsigned int __sanitizer___kernel_old_gid_t;\n #else\n@@ -357,28 +483,44 @@ namespace __sanitizer {\n     // The size is determined by looking at sizeof of real sigset_t on linux.\n     uptr val[128 / sizeof(uptr)];\n   };\n+#elif SANITIZER_FREEBSD\n+  struct __sanitizer_sigset_t {\n+     // uint32_t * 4\n+     unsigned int __bits[4];\n+  };\n #endif\n \n+  // Linux system headers define the 'sa_handler' and 'sa_sigaction' macros.\n   struct __sanitizer_sigaction {\n     union {\n-      void (*sa_handler)(int sig);\n-      void (*sa_sigaction)(int sig, void *siginfo, void *uctx);\n+      void (*sigaction)(int sig, void *siginfo, void *uctx);\n+      void (*handler)(int sig);\n     };\n+#if SANITIZER_FREEBSD\n+    int sa_flags;\n+    __sanitizer_sigset_t sa_mask;\n+#else\n     __sanitizer_sigset_t sa_mask;\n     int sa_flags;\n+#endif\n #if SANITIZER_LINUX\n     void (*sa_restorer)();\n #endif\n   };\n \n+#if SANITIZER_FREEBSD\n+  typedef __sanitizer_sigset_t __sanitizer_kernel_sigset_t;\n+#else\n   struct __sanitizer_kernel_sigset_t {\n     u8 sig[8];\n   };\n+#endif\n \n+  // Linux system headers define the 'sa_handler' and 'sa_sigaction' macros.\n   struct __sanitizer_kernel_sigaction_t {\n     union {\n-      void (*sigaction)(int signo, void *info, void *ctx);\n       void (*handler)(int signo);\n+      void (*sigaction)(int signo, void *info, void *ctx);\n     };\n     unsigned long sa_flags;\n     void (*sa_restorer)(void);\n@@ -397,7 +539,7 @@ namespace __sanitizer {\n   extern int af_inet6;\n   uptr __sanitizer_in_addr_sz(int af);\n \n-#if SANITIZER_LINUX\n+#if SANITIZER_LINUX || SANITIZER_FREEBSD\n   struct __sanitizer_dl_phdr_info {\n     uptr dlpi_addr;\n     const char *dlpi_name;\n@@ -411,7 +553,7 @@ namespace __sanitizer {\n     int ai_family;\n     int ai_socktype;\n     int ai_protocol;\n-#if SANITIZER_ANDROID || SANITIZER_MAC\n+#if SANITIZER_ANDROID || SANITIZER_MAC || SANITIZER_FREEBSD\n     unsigned ai_addrlen;\n     char *ai_canonname;\n     void *ai_addr;\n@@ -437,13 +579,14 @@ namespace __sanitizer {\n     short revents;\n   };\n \n-#if SANITIZER_ANDROID || SANITIZER_MAC\n+#if SANITIZER_ANDROID || SANITIZER_MAC || SANITIZER_FREEBSD\n   typedef unsigned __sanitizer_nfds_t;\n #else\n   typedef unsigned long __sanitizer_nfds_t;\n #endif\n \n-#if SANITIZER_LINUX && !SANITIZER_ANDROID\n+#if !SANITIZER_ANDROID\n+# if SANITIZER_LINUX\n   struct __sanitizer_glob_t {\n     uptr gl_pathc;\n     char **gl_pathv;\n@@ -456,21 +599,66 @@ namespace __sanitizer {\n     int (*gl_lstat)(const char *, void *);\n     int (*gl_stat)(const char *, void *);\n   };\n+# elif SANITIZER_FREEBSD\n+  struct __sanitizer_glob_t {\n+    uptr gl_pathc;\n+    uptr gl_matchc;\n+    uptr gl_offs;\n+    int gl_flags;\n+    char **gl_pathv;\n+    int (*gl_errfunc)(const char*, int);\n+    void (*gl_closedir)(void *dirp);\n+    struct dirent *(*gl_readdir)(void *dirp);\n+    void *(*gl_opendir)(const char*);\n+    int (*gl_lstat)(const char*, void* /* struct stat* */);\n+    int (*gl_stat)(const char*, void* /* struct stat* */);\n+  };\n+# endif  // SANITIZER_FREEBSD\n \n+# if SANITIZER_LINUX || SANITIZER_FREEBSD\n   extern int glob_nomatch;\n   extern int glob_altdirfunc;\n-#endif\n+# endif\n+#endif  // !SANITIZER_ANDROID\n \n   extern unsigned path_max;\n \n   struct __sanitizer_wordexp_t {\n     uptr we_wordc;\n     char **we_wordv;\n     uptr we_offs;\n+#if SANITIZER_FREEBSD\n+    char *we_strings;\n+    uptr we_nbytes;\n+#endif\n   };\n \n+#if SANITIZER_LINUX && !SANITIZER_ANDROID\n+  struct __sanitizer_FILE {\n+    int _flags;\n+    char *_IO_read_ptr;\n+    char *_IO_read_end;\n+    char *_IO_read_base;\n+    char *_IO_write_base;\n+    char *_IO_write_ptr;\n+    char *_IO_write_end;\n+    char *_IO_buf_base;\n+    char *_IO_buf_end;\n+    char *_IO_save_base;\n+    char *_IO_backup_base;\n+    char *_IO_save_end;\n+    void *_markers;\n+    __sanitizer_FILE *_chain;\n+    int _fileno;\n+  };\n+# define SANITIZER_HAS_STRUCT_FILE 1\n+#else\n+  typedef void __sanitizer_FILE;\n+# define SANITIZER_HAS_STRUCT_FILE 0\n+#endif\n+\n #if SANITIZER_LINUX && !SANITIZER_ANDROID && \\\n-      (defined(__i386) || defined (__x86_64))  // NOLINT\n+    (defined(__i386) || defined(__x86_64))\n   extern unsigned struct_user_regs_struct_sz;\n   extern unsigned struct_user_fpregs_struct_sz;\n   extern unsigned struct_user_fpxregs_struct_sz;\n@@ -490,7 +678,7 @@ namespace __sanitizer {\n   extern int ptrace_setregset;\n #endif\n \n-#if SANITIZER_LINUX && !SANITIZER_ANDROID\n+#if (SANITIZER_LINUX || SANITIZER_FREEBSD) && !SANITIZER_ANDROID\n   extern unsigned struct_shminfo_sz;\n   extern unsigned struct_shm_info_sz;\n   extern int shmctl_ipc_stat;\n@@ -499,6 +687,8 @@ namespace __sanitizer {\n   extern int shmctl_shm_stat;\n #endif\n \n+  extern int map_fixed;\n+\n   // ioctl arguments\n   struct __sanitizer_ifconf {\n     int ifc_len;\n@@ -511,7 +701,54 @@ namespace __sanitizer {\n   };\n #endif\n \n-#define IOC_SIZE(nr) (((nr) >> 16) & 0x3fff)\n+#if SANITIZER_LINUX && !SANITIZER_ANDROID\n+struct __sanitizer__obstack_chunk {\n+  char *limit;\n+  struct __sanitizer__obstack_chunk *prev;\n+};\n+\n+struct __sanitizer_obstack {\n+  long chunk_size;\n+  struct __sanitizer__obstack_chunk *chunk;\n+  char *object_base;\n+  char *next_free;\n+  uptr more_fields[7];\n+};\n+#endif\n+\n+#define IOC_NRBITS 8\n+#define IOC_TYPEBITS 8\n+#if defined(__powerpc__) || defined(__powerpc64__)\n+#define IOC_SIZEBITS 13\n+#define IOC_DIRBITS 3\n+#define IOC_NONE 1U\n+#define IOC_WRITE 4U\n+#define IOC_READ 2U\n+#else\n+#define IOC_SIZEBITS 14\n+#define IOC_DIRBITS 2\n+#define IOC_NONE 0U\n+#define IOC_WRITE 1U\n+#define IOC_READ 2U\n+#endif\n+#define IOC_NRMASK ((1 << IOC_NRBITS) - 1)\n+#define IOC_TYPEMASK ((1 << IOC_TYPEBITS) - 1)\n+#define IOC_SIZEMASK ((1 << IOC_SIZEBITS) - 1)\n+#if defined(IOC_DIRMASK)\n+#undef IOC_DIRMASK\n+#endif\n+#define IOC_DIRMASK ((1 << IOC_DIRBITS) - 1)\n+#define IOC_NRSHIFT 0\n+#define IOC_TYPESHIFT (IOC_NRSHIFT + IOC_NRBITS)\n+#define IOC_SIZESHIFT (IOC_TYPESHIFT + IOC_TYPEBITS)\n+#define IOC_DIRSHIFT (IOC_SIZESHIFT + IOC_SIZEBITS)\n+#define EVIOC_EV_MAX 0x1f\n+#define EVIOC_ABS_MAX 0x3f\n+\n+#define IOC_DIR(nr) (((nr) >> IOC_DIRSHIFT) & IOC_DIRMASK)\n+#define IOC_TYPE(nr) (((nr) >> IOC_TYPESHIFT) & IOC_TYPEMASK)\n+#define IOC_NR(nr) (((nr) >> IOC_NRSHIFT) & IOC_NRMASK)\n+#define IOC_SIZE(nr) (((nr) >> IOC_SIZESHIFT) & IOC_SIZEMASK)\n \n   extern unsigned struct_arpreq_sz;\n   extern unsigned struct_ifreq_sz;\n@@ -527,9 +764,6 @@ namespace __sanitizer {\n   extern unsigned struct_cdrom_tocentry_sz;\n   extern unsigned struct_cdrom_tochdr_sz;\n   extern unsigned struct_cdrom_volctrl_sz;\n-  extern unsigned struct_copr_buffer_sz;\n-  extern unsigned struct_copr_debug_buf_sz;\n-  extern unsigned struct_copr_msg_sz;\n   extern unsigned struct_ff_effect_sz;\n   extern unsigned struct_floppy_drive_params_sz;\n   extern unsigned struct_floppy_drive_struct_sz;\n@@ -543,23 +777,28 @@ namespace __sanitizer {\n   extern unsigned struct_hd_geometry_sz;\n   extern unsigned struct_input_absinfo_sz;\n   extern unsigned struct_input_id_sz;\n+  extern unsigned struct_mtpos_sz;\n+  extern unsigned struct_termio_sz;\n+  extern unsigned struct_vt_consize_sz;\n+  extern unsigned struct_vt_sizes_sz;\n+  extern unsigned struct_vt_stat_sz;\n+#endif  // SANITIZER_LINUX\n+\n+#if SANITIZER_LINUX || SANITIZER_FREEBSD\n+  extern unsigned struct_copr_buffer_sz;\n+  extern unsigned struct_copr_debug_buf_sz;\n+  extern unsigned struct_copr_msg_sz;\n   extern unsigned struct_midi_info_sz;\n   extern unsigned struct_mtget_sz;\n   extern unsigned struct_mtop_sz;\n-  extern unsigned struct_mtpos_sz;\n   extern unsigned struct_rtentry_sz;\n   extern unsigned struct_sbi_instrument_sz;\n   extern unsigned struct_seq_event_rec_sz;\n   extern unsigned struct_synth_info_sz;\n-  extern unsigned struct_termio_sz;\n-  extern unsigned struct_vt_consize_sz;\n   extern unsigned struct_vt_mode_sz;\n-  extern unsigned struct_vt_sizes_sz;\n-  extern unsigned struct_vt_stat_sz;\n-#endif\n+#endif // SANITIZER_LINUX || SANITIZER_FREEBSD\n \n #if SANITIZER_LINUX && !SANITIZER_ANDROID\n-  extern unsigned struct_audio_buf_info_sz;\n   extern unsigned struct_ax25_parms_struct_sz;\n   extern unsigned struct_cyclades_monitor_sz;\n   extern unsigned struct_input_keymap_entry_sz;\n@@ -570,15 +809,19 @@ namespace __sanitizer {\n   extern unsigned struct_kbsentry_sz;\n   extern unsigned struct_mtconfiginfo_sz;\n   extern unsigned struct_nr_parms_struct_sz;\n-  extern unsigned struct_ppp_stats_sz;\n   extern unsigned struct_scc_modem_sz;\n   extern unsigned struct_scc_stat_sz;\n   extern unsigned struct_serial_multiport_struct_sz;\n   extern unsigned struct_serial_struct_sz;\n   extern unsigned struct_sockaddr_ax25_sz;\n   extern unsigned struct_unimapdesc_sz;\n   extern unsigned struct_unimapinit_sz;\n-#endif\n+#endif  // SANITIZER_LINUX && !SANITIZER_ANDROID\n+\n+#if (SANITIZER_LINUX || SANITIZER_FREEBSD) && !SANITIZER_ANDROID\n+  extern unsigned struct_audio_buf_info_sz;\n+  extern unsigned struct_ppp_stats_sz;\n+#endif  // (SANITIZER_LINUX || SANITIZER_FREEBSD) && !SANITIZER_ANDROID\n \n #if !SANITIZER_ANDROID && !SANITIZER_MAC\n   extern unsigned struct_sioc_sg_req_sz;\n@@ -635,7 +878,7 @@ namespace __sanitizer {\n   extern unsigned IOCTL_TIOCSPGRP;\n   extern unsigned IOCTL_TIOCSTI;\n   extern unsigned IOCTL_TIOCSWINSZ;\n-#if (SANITIZER_LINUX && !SANITIZER_ANDROID)\n+#if (SANITIZER_LINUX || SANITIZER_FREEBSD) && !SANITIZER_ANDROID\n   extern unsigned IOCTL_SIOCGETSGCNT;\n   extern unsigned IOCTL_SIOCGETVIFCNT;\n #endif\n@@ -729,9 +972,7 @@ namespace __sanitizer {\n   extern unsigned IOCTL_HDIO_SET_MULTCOUNT;\n   extern unsigned IOCTL_HDIO_SET_NOWERR;\n   extern unsigned IOCTL_HDIO_SET_UNMASKINTR;\n-  extern unsigned IOCTL_MTIOCGET;\n   extern unsigned IOCTL_MTIOCPOS;\n-  extern unsigned IOCTL_MTIOCTOP;\n   extern unsigned IOCTL_PPPIOCGASYNCMAP;\n   extern unsigned IOCTL_PPPIOCGDEBUG;\n   extern unsigned IOCTL_PPPIOCGFLAGS;\n@@ -743,9 +984,7 @@ namespace __sanitizer {\n   extern unsigned IOCTL_PPPIOCSMAXCID;\n   extern unsigned IOCTL_PPPIOCSMRU;\n   extern unsigned IOCTL_PPPIOCSXASYNCMAP;\n-  extern unsigned IOCTL_SIOCADDRT;\n   extern unsigned IOCTL_SIOCDARP;\n-  extern unsigned IOCTL_SIOCDELRT;\n   extern unsigned IOCTL_SIOCDRARP;\n   extern unsigned IOCTL_SIOCGARP;\n   extern unsigned IOCTL_SIOCGIFENCAP;\n@@ -774,6 +1013,39 @@ namespace __sanitizer {\n   extern unsigned IOCTL_SNDCTL_COPR_SENDMSG;\n   extern unsigned IOCTL_SNDCTL_COPR_WCODE;\n   extern unsigned IOCTL_SNDCTL_COPR_WDATA;\n+  extern unsigned IOCTL_TCFLSH;\n+  extern unsigned IOCTL_TCGETA;\n+  extern unsigned IOCTL_TCGETS;\n+  extern unsigned IOCTL_TCSBRK;\n+  extern unsigned IOCTL_TCSBRKP;\n+  extern unsigned IOCTL_TCSETA;\n+  extern unsigned IOCTL_TCSETAF;\n+  extern unsigned IOCTL_TCSETAW;\n+  extern unsigned IOCTL_TCSETS;\n+  extern unsigned IOCTL_TCSETSF;\n+  extern unsigned IOCTL_TCSETSW;\n+  extern unsigned IOCTL_TCXONC;\n+  extern unsigned IOCTL_TIOCGLCKTRMIOS;\n+  extern unsigned IOCTL_TIOCGSOFTCAR;\n+  extern unsigned IOCTL_TIOCINQ;\n+  extern unsigned IOCTL_TIOCLINUX;\n+  extern unsigned IOCTL_TIOCSERCONFIG;\n+  extern unsigned IOCTL_TIOCSERGETLSR;\n+  extern unsigned IOCTL_TIOCSERGWILD;\n+  extern unsigned IOCTL_TIOCSERSWILD;\n+  extern unsigned IOCTL_TIOCSLCKTRMIOS;\n+  extern unsigned IOCTL_TIOCSSOFTCAR;\n+  extern unsigned IOCTL_VT_DISALLOCATE;\n+  extern unsigned IOCTL_VT_GETSTATE;\n+  extern unsigned IOCTL_VT_RESIZE;\n+  extern unsigned IOCTL_VT_RESIZEX;\n+  extern unsigned IOCTL_VT_SENDSIG;\n+#endif  // SANITIZER_LINUX\n+#if SANITIZER_LINUX || SANITIZER_FREEBSD\n+  extern unsigned IOCTL_MTIOCGET;\n+  extern unsigned IOCTL_MTIOCTOP;\n+  extern unsigned IOCTL_SIOCADDRT;\n+  extern unsigned IOCTL_SIOCDELRT;\n   extern unsigned IOCTL_SNDCTL_DSP_GETBLKSIZE;\n   extern unsigned IOCTL_SNDCTL_DSP_GETFMTS;\n   extern unsigned IOCTL_SNDCTL_DSP_NONBLOCK;\n@@ -864,40 +1136,14 @@ namespace __sanitizer {\n   extern unsigned IOCTL_SOUND_PCM_READ_RATE;\n   extern unsigned IOCTL_SOUND_PCM_WRITE_CHANNELS;\n   extern unsigned IOCTL_SOUND_PCM_WRITE_FILTER;\n-  extern unsigned IOCTL_TCFLSH;\n-  extern unsigned IOCTL_TCGETA;\n-  extern unsigned IOCTL_TCGETS;\n-  extern unsigned IOCTL_TCSBRK;\n-  extern unsigned IOCTL_TCSBRKP;\n-  extern unsigned IOCTL_TCSETA;\n-  extern unsigned IOCTL_TCSETAF;\n-  extern unsigned IOCTL_TCSETAW;\n-  extern unsigned IOCTL_TCSETS;\n-  extern unsigned IOCTL_TCSETSF;\n-  extern unsigned IOCTL_TCSETSW;\n-  extern unsigned IOCTL_TCXONC;\n-  extern unsigned IOCTL_TIOCGLCKTRMIOS;\n-  extern unsigned IOCTL_TIOCGSOFTCAR;\n-  extern unsigned IOCTL_TIOCINQ;\n-  extern unsigned IOCTL_TIOCLINUX;\n-  extern unsigned IOCTL_TIOCSERCONFIG;\n-  extern unsigned IOCTL_TIOCSERGETLSR;\n-  extern unsigned IOCTL_TIOCSERGWILD;\n-  extern unsigned IOCTL_TIOCSERSWILD;\n-  extern unsigned IOCTL_TIOCSLCKTRMIOS;\n-  extern unsigned IOCTL_TIOCSSOFTCAR;\n   extern unsigned IOCTL_VT_ACTIVATE;\n-  extern unsigned IOCTL_VT_DISALLOCATE;\n   extern unsigned IOCTL_VT_GETMODE;\n-  extern unsigned IOCTL_VT_GETSTATE;\n   extern unsigned IOCTL_VT_OPENQRY;\n   extern unsigned IOCTL_VT_RELDISP;\n-  extern unsigned IOCTL_VT_RESIZE;\n-  extern unsigned IOCTL_VT_RESIZEX;\n-  extern unsigned IOCTL_VT_SENDSIG;\n   extern unsigned IOCTL_VT_SETMODE;\n   extern unsigned IOCTL_VT_WAITACTIVE;\n-#endif\n+#endif  // SANITIZER_LINUX || SANITIZER_FREEBSD\n+\n #if SANITIZER_LINUX && !SANITIZER_ANDROID\n   extern unsigned IOCTL_CYGETDEFTHRESH;\n   extern unsigned IOCTL_CYGETDEFTIMEOUT;\n@@ -923,37 +1169,25 @@ namespace __sanitizer {\n   extern unsigned IOCTL_FS_IOC_SETVERSION;\n   extern unsigned IOCTL_GIO_CMAP;\n   extern unsigned IOCTL_GIO_FONT;\n-  extern unsigned IOCTL_GIO_SCRNMAP;\n   extern unsigned IOCTL_GIO_UNIMAP;\n   extern unsigned IOCTL_GIO_UNISCRNMAP;\n   extern unsigned IOCTL_KDADDIO;\n   extern unsigned IOCTL_KDDELIO;\n-  extern unsigned IOCTL_KDDISABIO;\n-  extern unsigned IOCTL_KDENABIO;\n   extern unsigned IOCTL_KDGETKEYCODE;\n-  extern unsigned IOCTL_KDGETLED;\n-  extern unsigned IOCTL_KDGETMODE;\n   extern unsigned IOCTL_KDGKBDIACR;\n   extern unsigned IOCTL_KDGKBENT;\n   extern unsigned IOCTL_KDGKBLED;\n   extern unsigned IOCTL_KDGKBMETA;\n-  extern unsigned IOCTL_KDGKBMODE;\n   extern unsigned IOCTL_KDGKBSENT;\n-  extern unsigned IOCTL_KDGKBTYPE;\n   extern unsigned IOCTL_KDMAPDISP;\n-  extern unsigned IOCTL_KDMKTONE;\n   extern unsigned IOCTL_KDSETKEYCODE;\n-  extern unsigned IOCTL_KDSETLED;\n-  extern unsigned IOCTL_KDSETMODE;\n   extern unsigned IOCTL_KDSIGACCEPT;\n   extern unsigned IOCTL_KDSKBDIACR;\n   extern unsigned IOCTL_KDSKBENT;\n   extern unsigned IOCTL_KDSKBLED;\n   extern unsigned IOCTL_KDSKBMETA;\n-  extern unsigned IOCTL_KDSKBMODE;\n   extern unsigned IOCTL_KDSKBSENT;\n   extern unsigned IOCTL_KDUNMAPDISP;\n-  extern unsigned IOCTL_KIOCSOUND;\n   extern unsigned IOCTL_LPABORT;\n   extern unsigned IOCTL_LPABORTOPEN;\n   extern unsigned IOCTL_LPCAREFUL;\n@@ -968,7 +1202,6 @@ namespace __sanitizer {\n   extern unsigned IOCTL_MTIOCSETCONFIG;\n   extern unsigned IOCTL_PIO_CMAP;\n   extern unsigned IOCTL_PIO_FONT;\n-  extern unsigned IOCTL_PIO_SCRNMAP;\n   extern unsigned IOCTL_PIO_UNIMAP;\n   extern unsigned IOCTL_PIO_UNIMAPCLR;\n   extern unsigned IOCTL_PIO_UNISCRNMAP;\n@@ -996,9 +1229,29 @@ namespace __sanitizer {\n   extern unsigned IOCTL_TIOCSERGETMULTI;\n   extern unsigned IOCTL_TIOCSERSETMULTI;\n   extern unsigned IOCTL_TIOCSSERIAL;\n+#endif  // SANITIZER_LINUX && !SANITIZER_ANDROID\n+\n+#if (SANITIZER_LINUX || SANITIZER_FREEBSD) && !SANITIZER_ANDROID\n+  extern unsigned IOCTL_GIO_SCRNMAP;\n+  extern unsigned IOCTL_KDDISABIO;\n+  extern unsigned IOCTL_KDENABIO;\n+  extern unsigned IOCTL_KDGETLED;\n+  extern unsigned IOCTL_KDGETMODE;\n+  extern unsigned IOCTL_KDGKBMODE;\n+  extern unsigned IOCTL_KDGKBTYPE;\n+  extern unsigned IOCTL_KDMKTONE;\n+  extern unsigned IOCTL_KDSETLED;\n+  extern unsigned IOCTL_KDSETMODE;\n+  extern unsigned IOCTL_KDSKBMODE;\n+  extern unsigned IOCTL_KIOCSOUND;\n+  extern unsigned IOCTL_PIO_SCRNMAP;\n #endif\n \n+  extern const int errno_EINVAL;\n   extern const int errno_EOWNERDEAD;\n+\n+  extern const int si_SEGV_MAPERR;\n+  extern const int si_SEGV_ACCERR;\n }  // namespace __sanitizer\n \n #define CHECK_TYPE_SIZE(TYPE) \\"}, {"sha": "e24d5ed503160580027d85173c261d6a753ea1aa", "filename": "libsanitizer/sanitizer_common/sanitizer_posix.cc", "status": "modified", "additions": 87, "deletions": 12, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -11,7 +11,7 @@\n //===----------------------------------------------------------------------===//\n \n #include \"sanitizer_platform.h\"\n-#if SANITIZER_LINUX || SANITIZER_MAC\n+#if SANITIZER_POSIX\n \n #include \"sanitizer_common.h\"\n #include \"sanitizer_libc.h\"\n@@ -20,28 +20,80 @@\n \n #include <sys/mman.h>\n \n+#if SANITIZER_LINUX\n+#include <sys/utsname.h>\n+#endif\n+\n+#if SANITIZER_LINUX && !SANITIZER_ANDROID\n+#include <sys/personality.h>\n+#endif\n+\n namespace __sanitizer {\n \n // ------------- sanitizer_common.h\n uptr GetMmapGranularity() {\n   return GetPageSize();\n }\n \n+#if SANITIZER_WORDSIZE == 32\n+// Take care of unusable kernel area in top gigabyte.\n+static uptr GetKernelAreaSize() {\n+#if SANITIZER_LINUX\n+  const uptr gbyte = 1UL << 30;\n+\n+  // Firstly check if there are writable segments\n+  // mapped to top gigabyte (e.g. stack).\n+  MemoryMappingLayout proc_maps(/*cache_enabled*/true);\n+  uptr end, prot;\n+  while (proc_maps.Next(/*start*/0, &end,\n+                        /*offset*/0, /*filename*/0,\n+                        /*filename_size*/0, &prot)) {\n+    if ((end >= 3 * gbyte)\n+        && (prot & MemoryMappingLayout::kProtectionWrite) != 0)\n+      return 0;\n+  }\n+\n+#if !SANITIZER_ANDROID\n+  // Even if nothing is mapped, top Gb may still be accessible\n+  // if we are running on 64-bit kernel.\n+  // Uname may report misleading results if personality type\n+  // is modified (e.g. under schroot) so check this as well.\n+  struct utsname uname_info;\n+  int pers = personality(0xffffffffUL);\n+  if (!(pers & PER_MASK)\n+      && uname(&uname_info) == 0\n+      && internal_strstr(uname_info.machine, \"64\"))\n+    return 0;\n+#endif  // SANITIZER_ANDROID\n+\n+  // Top gigabyte is reserved for kernel.\n+  return gbyte;\n+#else\n+  return 0;\n+#endif  // SANITIZER_LINUX\n+}\n+#endif  // SANITIZER_WORDSIZE == 32\n+\n uptr GetMaxVirtualAddress() {\n #if SANITIZER_WORDSIZE == 64\n # if defined(__powerpc64__)\n   // On PowerPC64 we have two different address space layouts: 44- and 46-bit.\n-  // We somehow need to figure our which one we are using now and choose\n+  // We somehow need to figure out which one we are using now and choose\n   // one of 0x00000fffffffffffUL and 0x00003fffffffffffUL.\n   // Note that with 'ulimit -s unlimited' the stack is moved away from the top\n   // of the address space, so simply checking the stack address is not enough.\n   return (1ULL << 44) - 1;  // 0x00000fffffffffffUL\n+# elif defined(__aarch64__)\n+  return (1ULL << 39) - 1;\n # else\n   return (1ULL << 47) - 1;  // 0x00007fffffffffffUL;\n # endif\n #else  // SANITIZER_WORDSIZE == 32\n-  // FIXME: We can probably lower this on Android?\n-  return (1ULL << 32) - 1;  // 0xffffffff;\n+  uptr res = (1ULL << 32) - 1;  // 0xffffffff;\n+  if (!common_flags()->full_address_space)\n+    res -= GetKernelAreaSize();\n+  CHECK_LT(reinterpret_cast<uptr>(&res), res);\n+  return res;\n #endif  // SANITIZER_WORDSIZE\n }\n \n@@ -60,11 +112,13 @@ void *MmapOrDie(uptr size, const char *mem_type) {\n       Die();\n     }\n     recursion_count++;\n-    Report(\"ERROR: %s failed to allocate 0x%zx (%zd) bytes of %s: %d\\n\",\n+    Report(\"ERROR: %s failed to \"\n+           \"allocate 0x%zx (%zd) bytes of %s (errno: %d)\\n\",\n            SanitizerToolName, size, size, mem_type, reserrno);\n     DumpProcessMap();\n     CHECK(\"unable to mmap\" && 0);\n   }\n+  IncreaseTotalMmap(size);\n   return (void *)res;\n }\n \n@@ -76,6 +130,25 @@ void UnmapOrDie(void *addr, uptr size) {\n            SanitizerToolName, size, size, addr);\n     CHECK(\"unable to unmap\" && 0);\n   }\n+  DecreaseTotalMmap(size);\n+}\n+\n+void *MmapNoReserveOrDie(uptr size, const char *mem_type) {\n+  uptr PageSize = GetPageSizeCached();\n+  uptr p = internal_mmap(0,\n+      RoundUpTo(size, PageSize),\n+      PROT_READ | PROT_WRITE,\n+      MAP_PRIVATE | MAP_ANON | MAP_NORESERVE,\n+      -1, 0);\n+  int reserrno;\n+  if (internal_iserror(p, &reserrno)) {\n+    Report(\"ERROR: %s failed to \"\n+           \"allocate noreserve 0x%zx (%zd) bytes for '%s' (errno: %d)\\n\",\n+           SanitizerToolName, size, size, mem_type, reserrno);\n+    CHECK(\"unable to mmap\" && 0);\n+  }\n+  IncreaseTotalMmap(size);\n+  return (void *)p;\n }\n \n void *MmapFixedNoReserve(uptr fixed_addr, uptr size) {\n@@ -87,9 +160,10 @@ void *MmapFixedNoReserve(uptr fixed_addr, uptr size) {\n       -1, 0);\n   int reserrno;\n   if (internal_iserror(p, &reserrno))\n-    Report(\"ERROR: \"\n-           \"%s failed to allocate 0x%zx (%zd) bytes at address %p (%d)\\n\",\n+    Report(\"ERROR: %s failed to \"\n+           \"allocate 0x%zx (%zd) bytes at address %zx (errno: %d)\\n\",\n            SanitizerToolName, size, size, fixed_addr, reserrno);\n+  IncreaseTotalMmap(size);\n   return (void *)p;\n }\n \n@@ -102,11 +176,12 @@ void *MmapFixedOrDie(uptr fixed_addr, uptr size) {\n       -1, 0);\n   int reserrno;\n   if (internal_iserror(p, &reserrno)) {\n-    Report(\"ERROR:\"\n-           \" %s failed to allocate 0x%zx (%zd) bytes at address %p (%d)\\n\",\n+    Report(\"ERROR: %s failed to \"\n+           \"allocate 0x%zx (%zd) bytes at address %zx (errno: %d)\\n\",\n            SanitizerToolName, size, size, fixed_addr, reserrno);\n     CHECK(\"unable to mmap\" && 0);\n   }\n+  IncreaseTotalMmap(size);\n   return (void *)p;\n }\n \n@@ -157,7 +232,7 @@ void DumpProcessMap() {\n   MemoryMappingLayout proc_maps(/*cache_enabled*/true);\n   uptr start, end;\n   const sptr kBufSize = 4095;\n-  char *filename = (char*)MmapOrDie(kBufSize, __FUNCTION__);\n+  char *filename = (char*)MmapOrDie(kBufSize, __func__);\n   Report(\"Process memory map follows:\\n\");\n   while (proc_maps.Next(&start, &end, /* file_offset */0,\n                         filename, kBufSize, /* protection */0)) {\n@@ -204,7 +279,7 @@ void MaybeOpenReportFile() {\n   if (report_fd_pid == pid) return;\n   InternalScopedBuffer<char> report_path_full(4096);\n   internal_snprintf(report_path_full.data(), report_path_full.size(),\n-                    \"%s.%d\", report_path_prefix, pid);\n+                    \"%s.%zu\", report_path_prefix, pid);\n   uptr openrv = OpenFile(report_path_full.data(), true);\n   if (internal_iserror(openrv)) {\n     report_fd = kStderrFd;\n@@ -248,4 +323,4 @@ bool GetCodeRangeForFile(const char *module, uptr *start, uptr *end) {\n \n }  // namespace __sanitizer\n \n-#endif  // SANITIZER_LINUX || SANITIZER_MAC\n+#endif  // SANITIZER_POSIX"}, {"sha": "8e3a96f01e4d8d1c9c67e59ecd5ed976e17ded9b", "filename": "libsanitizer/sanitizer_common/sanitizer_posix_libcdep.cc", "status": "modified", "additions": 59, "deletions": 3, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix_libcdep.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -12,12 +12,15 @@\n \n #include \"sanitizer_platform.h\"\n \n-#if SANITIZER_LINUX || SANITIZER_MAC\n+#if SANITIZER_POSIX\n #include \"sanitizer_common.h\"\n+#include \"sanitizer_flags.h\"\n+#include \"sanitizer_platform_limits_posix.h\"\n #include \"sanitizer_stacktrace.h\"\n \n #include <errno.h>\n #include <pthread.h>\n+#include <signal.h>\n #include <stdlib.h>\n #include <sys/mman.h>\n #include <sys/resource.h>\n@@ -49,7 +52,7 @@ void DisableCoreDumper() {\n bool StackSizeIsUnlimited() {\n   struct rlimit rlim;\n   CHECK_EQ(0, getrlimit(RLIMIT_STACK, &rlim));\n-  return (rlim.rlim_cur == (uptr)-1);\n+  return ((uptr)rlim.rlim_cur == (uptr)-1);\n }\n \n void SetStackSizeLimitInBytes(uptr limit) {\n@@ -87,6 +90,59 @@ int internal_isatty(fd_t fd) {\n   return isatty(fd);\n }\n \n+#ifndef SANITIZER_GO\n+// TODO(glider): different tools may require different altstack size.\n+static const uptr kAltStackSize = SIGSTKSZ * 4;  // SIGSTKSZ is not enough.\n+\n+void SetAlternateSignalStack() {\n+  stack_t altstack, oldstack;\n+  CHECK_EQ(0, sigaltstack(0, &oldstack));\n+  // If the alternate stack is already in place, do nothing.\n+  // Android always sets an alternate stack, but it's too small for us.\n+  if (!SANITIZER_ANDROID && !(oldstack.ss_flags & SS_DISABLE)) return;\n+  // TODO(glider): the mapped stack should have the MAP_STACK flag in the\n+  // future. It is not required by man 2 sigaltstack now (they're using\n+  // malloc()).\n+  void* base = MmapOrDie(kAltStackSize, __func__);\n+  altstack.ss_sp = (char*) base;\n+  altstack.ss_flags = 0;\n+  altstack.ss_size = kAltStackSize;\n+  CHECK_EQ(0, sigaltstack(&altstack, 0));\n+}\n+\n+void UnsetAlternateSignalStack() {\n+  stack_t altstack, oldstack;\n+  altstack.ss_sp = 0;\n+  altstack.ss_flags = SS_DISABLE;\n+  altstack.ss_size = kAltStackSize;  // Some sane value required on Darwin.\n+  CHECK_EQ(0, sigaltstack(&altstack, &oldstack));\n+  UnmapOrDie(oldstack.ss_sp, oldstack.ss_size);\n+}\n+\n+typedef void (*sa_sigaction_t)(int, siginfo_t *, void *);\n+static void MaybeInstallSigaction(int signum,\n+                                  SignalHandlerType handler) {\n+  if (!IsDeadlySignal(signum))\n+    return;\n+  struct sigaction sigact;\n+  internal_memset(&sigact, 0, sizeof(sigact));\n+  sigact.sa_sigaction = (sa_sigaction_t)handler;\n+  sigact.sa_flags = SA_SIGINFO;\n+  if (common_flags()->use_sigaltstack) sigact.sa_flags |= SA_ONSTACK;\n+  CHECK_EQ(0, internal_sigaction(signum, &sigact, 0));\n+  VReport(1, \"Installed the sigaction for signal %d\\n\", signum);\n+}\n+\n+void InstallDeadlySignalHandlers(SignalHandlerType handler) {\n+  // Set the alternate signal stack for the main thread.\n+  // This will cause SetAlternateSignalStack to be called twice, but the stack\n+  // will be actually set only once.\n+  if (common_flags()->use_sigaltstack) SetAlternateSignalStack();\n+  MaybeInstallSigaction(SIGSEGV, handler);\n+  MaybeInstallSigaction(SIGBUS, handler);\n+}\n+#endif  // SANITIZER_GO\n+\n }  // namespace __sanitizer\n \n-#endif\n+#endif  // SANITIZER_POSIX"}, {"sha": "4fc26308ee48c50e7f64b88d36f8c5c470bb7ed5", "filename": "libsanitizer/sanitizer_common/sanitizer_printf.cc", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_printf.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_printf.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_printf.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -14,6 +14,7 @@\n \n \n #include \"sanitizer_common.h\"\n+#include \"sanitizer_flags.h\"\n #include \"sanitizer_libc.h\"\n \n #include <stdio.h>\n@@ -92,19 +93,22 @@ static int AppendSignedDecimal(char **buff, const char *buff_end, s64 num,\n                       minimal_num_length, pad_with_zero, negative);\n }\n \n-static int AppendString(char **buff, const char *buff_end, const char *s) {\n+static int AppendString(char **buff, const char *buff_end, int precision,\n+                        const char *s) {\n   if (s == 0)\n     s = \"<null>\";\n   int result = 0;\n   for (; *s; s++) {\n+    if (precision >= 0 && result >= precision)\n+      break;\n     result += AppendChar(buff, buff_end, *s);\n   }\n   return result;\n }\n \n static int AppendPointer(char **buff, const char *buff_end, u64 ptr_value) {\n   int result = 0;\n-  result += AppendString(buff, buff_end, \"0x\");\n+  result += AppendString(buff, buff_end, -1, \"0x\");\n   result += AppendUnsigned(buff, buff_end, ptr_value, 16,\n                            (SANITIZER_WORDSIZE == 64) ? 12 : 8, true);\n   return result;\n@@ -113,7 +117,7 @@ static int AppendPointer(char **buff, const char *buff_end, u64 ptr_value) {\n int VSNPrintf(char *buff, int buff_length,\n               const char *format, va_list args) {\n   static const char *kPrintfFormatsHelp =\n-    \"Supported Printf formats: %([0-9]*)?(z|ll)?{d,u,x}; %p; %s; %c\\n\";\n+    \"Supported Printf formats: %([0-9]*)?(z|ll)?{d,u,x}; %p; %(\\\\.\\\\*)?s; %c\\n\";\n   RAW_CHECK(format);\n   RAW_CHECK(buff_length > 0);\n   const char *buff_end = &buff[buff_length - 1];\n@@ -133,13 +137,21 @@ int VSNPrintf(char *buff, int buff_length,\n         width = width * 10 + *cur++ - '0';\n       }\n     }\n+    bool have_precision = (cur[0] == '.' && cur[1] == '*');\n+    int precision = -1;\n+    if (have_precision) {\n+      cur += 2;\n+      precision = va_arg(args, int);\n+    }\n     bool have_z = (*cur == 'z');\n     cur += have_z;\n     bool have_ll = !have_z && (cur[0] == 'l' && cur[1] == 'l');\n     cur += have_ll * 2;\n     s64 dval;\n     u64 uval;\n     bool have_flags = have_width | have_z | have_ll;\n+    // Only %s supports precision for now\n+    CHECK(!(precision >= 0 && *cur != 's'));\n     switch (*cur) {\n       case 'd': {\n         dval = have_ll ? va_arg(args, s64)\n@@ -165,7 +177,7 @@ int VSNPrintf(char *buff, int buff_length,\n       }\n       case 's': {\n         RAW_CHECK_MSG(!have_flags, kPrintfFormatsHelp);\n-        result += AppendString(&buff, buff_end, va_arg(args, char*));\n+        result += AppendString(&buff, buff_end, precision, va_arg(args, char*));\n         break;\n       }\n       case 'c': {\n@@ -258,13 +270,15 @@ static void SharedPrintfCode(bool append_pid, const char *format,\n     break;\n   }\n   RawWrite(buffer);\n+  AndroidLogWrite(buffer);\n   CallPrintfAndReportCallback(buffer);\n   // If we had mapped any memory, clean up.\n   if (buffer != local_buffer)\n     UnmapOrDie((void *)buffer, buffer_size);\n   va_end(args2);\n }\n \n+FORMAT(1, 2)\n void Printf(const char *format, ...) {\n   va_list args;\n   va_start(args, format);\n@@ -273,6 +287,7 @@ void Printf(const char *format, ...) {\n }\n \n // Like Printf, but prints the current PID before the output string.\n+FORMAT(1, 2)\n void Report(const char *format, ...) {\n   va_list args;\n   va_start(args, format);\n@@ -284,6 +299,7 @@ void Report(const char *format, ...) {\n // Returns the number of symbols that should have been written to buffer\n // (not including trailing '\\0'). Thus, the string is truncated\n // iff return value is not less than \"length\".\n+FORMAT(3, 4)\n int internal_snprintf(char *buffer, uptr length, const char *format, ...) {\n   va_list args;\n   va_start(args, format);\n@@ -292,13 +308,15 @@ int internal_snprintf(char *buffer, uptr length, const char *format, ...) {\n   return needed_length;\n }\n \n+FORMAT(2, 3)\n void InternalScopedString::append(const char *format, ...) {\n   CHECK_LT(length_, size());\n   va_list args;\n   va_start(args, format);\n   VSNPrintf(data() + length_, size() - length_, format, args);\n   va_end(args);\n   length_ += internal_strlen(data() + length_);\n+  CHECK_LT(length_, size());\n }\n \n }  // namespace __sanitizer"}, {"sha": "d140c47fda9bef6204a004abef691d08735e9aaf", "filename": "libsanitizer/sanitizer_common/sanitizer_procmaps.h", "status": "modified", "additions": 11, "deletions": 56, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -12,49 +12,35 @@\n #ifndef SANITIZER_PROCMAPS_H\n #define SANITIZER_PROCMAPS_H\n \n+#include \"sanitizer_common.h\"\n #include \"sanitizer_internal_defs.h\"\n #include \"sanitizer_mutex.h\"\n \n namespace __sanitizer {\n \n-#if SANITIZER_WINDOWS\n-class MemoryMappingLayout {\n- public:\n-  explicit MemoryMappingLayout(bool cache_enabled) {\n-    (void)cache_enabled;\n-  }\n-  bool GetObjectNameAndOffset(uptr addr, uptr *offset,\n-                              char filename[], uptr filename_size,\n-                              uptr *protection) {\n-    UNIMPLEMENTED();\n-  }\n-};\n-\n-#else  // SANITIZER_WINDOWS\n-#if SANITIZER_LINUX\n+#if SANITIZER_FREEBSD || SANITIZER_LINUX\n struct ProcSelfMapsBuff {\n   char *data;\n   uptr mmaped_size;\n   uptr len;\n };\n-#endif  // SANITIZER_LINUX\n+#endif  // SANITIZER_FREEBSD || SANITIZER_LINUX\n \n class MemoryMappingLayout {\n  public:\n   explicit MemoryMappingLayout(bool cache_enabled);\n+  ~MemoryMappingLayout();\n   bool Next(uptr *start, uptr *end, uptr *offset,\n             char filename[], uptr filename_size, uptr *protection);\n   void Reset();\n-  // Gets the object file name and the offset in that object for a given\n-  // address 'addr'. Returns true on success.\n-  bool GetObjectNameAndOffset(uptr addr, uptr *offset,\n-                              char filename[], uptr filename_size,\n-                              uptr *protection);\n   // In some cases, e.g. when running under a sandbox on Linux, ASan is unable\n   // to obtain the memory mappings. It should fall back to pre-cached data\n   // instead of aborting.\n   static void CacheMemoryMappings();\n-  ~MemoryMappingLayout();\n+\n+  // Stores the list of mapped objects into an array.\n+  uptr DumpListOfModules(LoadedModule *modules, uptr max_modules,\n+                         string_predicate_t filter);\n \n   // Memory protection masks.\n   static const uptr kProtectionRead = 1;\n@@ -64,39 +50,10 @@ class MemoryMappingLayout {\n \n  private:\n   void LoadFromCache();\n-  // Default implementation of GetObjectNameAndOffset.\n-  // Quite slow, because it iterates through the whole process map for each\n-  // lookup.\n-  bool IterateForObjectNameAndOffset(uptr addr, uptr *offset,\n-                                     char filename[], uptr filename_size,\n-                                     uptr *protection) {\n-    Reset();\n-    uptr start, end, file_offset;\n-    for (int i = 0; Next(&start, &end, &file_offset, filename, filename_size,\n-                         protection);\n-         i++) {\n-      if (addr >= start && addr < end) {\n-        // Don't subtract 'start' for the first entry:\n-        // * If a binary is compiled w/o -pie, then the first entry in\n-        //   process maps is likely the binary itself (all dynamic libs\n-        //   are mapped higher in address space). For such a binary,\n-        //   instruction offset in binary coincides with the actual\n-        //   instruction address in virtual memory (as code section\n-        //   is mapped to a fixed memory range).\n-        // * If a binary is compiled with -pie, all the modules are\n-        //   mapped high at address space (in particular, higher than\n-        //   shadow memory of the tool), so the module can't be the\n-        //   first entry.\n-        *offset = (addr - (i ? start : 0)) + file_offset;\n-        return true;\n-      }\n-    }\n-    if (filename_size)\n-      filename[0] = '\\0';\n-    return false;\n-  }\n \n-# if SANITIZER_LINUX\n+  // FIXME: Hide implementation details for different platforms in\n+  // platform-specific files.\n+# if SANITIZER_FREEBSD || SANITIZER_LINUX\n   ProcSelfMapsBuff proc_self_maps_;\n   char *current_;\n \n@@ -127,8 +84,6 @@ void GetMemoryProfile(fill_profile_f cb, uptr *stats, uptr stats_size);\n // Returns code range for the specified module.\n bool GetCodeRangeForFile(const char *module, uptr *start, uptr *end);\n \n-#endif  // SANITIZER_WINDOWS\n-\n }  // namespace __sanitizer\n \n #endif  // SANITIZER_PROCMAPS_H"}, {"sha": "20a074a799f71237871a8c952668e3265b943fcb", "filename": "libsanitizer/sanitizer_common/sanitizer_procmaps_linux.cc", "status": "added", "additions": 302, "deletions": 0, "changes": 302, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_linux.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -0,0 +1,302 @@\n+//===-- sanitizer_procmaps_linux.cc ---------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Information about the process mappings (Linux-specific parts).\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_platform.h\"\n+#if SANITIZER_FREEBSD || SANITIZER_LINUX\n+#include \"sanitizer_common.h\"\n+#include \"sanitizer_placement_new.h\"\n+#include \"sanitizer_procmaps.h\"\n+\n+#if SANITIZER_FREEBSD\n+#include <unistd.h>\n+#include <sys/sysctl.h>\n+#include <sys/user.h>\n+#endif\n+\n+namespace __sanitizer {\n+\n+// Linker initialized.\n+ProcSelfMapsBuff MemoryMappingLayout::cached_proc_self_maps_;\n+StaticSpinMutex MemoryMappingLayout::cache_lock_;  // Linker initialized.\n+\n+static void ReadProcMaps(ProcSelfMapsBuff *proc_maps) {\n+#if SANITIZER_FREEBSD\n+  const int Mib[4] = { CTL_KERN, KERN_PROC, KERN_PROC_VMMAP, getpid() };\n+  size_t Size = 0;\n+  int Err = sysctl(Mib, 4, NULL, &Size, NULL, 0);\n+  CHECK_EQ(Err, 0);\n+  CHECK_GT(Size, 0);\n+\n+  size_t MmapedSize = Size * 4 / 3;\n+  void *VmMap = MmapOrDie(MmapedSize, \"ReadProcMaps()\");\n+  Size = MmapedSize;\n+  Err = sysctl(Mib, 4, VmMap, &Size, NULL, 0);\n+  CHECK_EQ(Err, 0);\n+\n+  proc_maps->data = (char*)VmMap;\n+  proc_maps->mmaped_size = MmapedSize;\n+  proc_maps->len = Size;\n+#else\n+  proc_maps->len = ReadFileToBuffer(\"/proc/self/maps\", &proc_maps->data,\n+                                    &proc_maps->mmaped_size, 1 << 26);\n+#endif\n+}\n+\n+MemoryMappingLayout::MemoryMappingLayout(bool cache_enabled) {\n+  ReadProcMaps(&proc_self_maps_);\n+  if (cache_enabled) {\n+    if (proc_self_maps_.mmaped_size == 0) {\n+      LoadFromCache();\n+      CHECK_GT(proc_self_maps_.len, 0);\n+    }\n+  } else {\n+    CHECK_GT(proc_self_maps_.mmaped_size, 0);\n+  }\n+  Reset();\n+  // FIXME: in the future we may want to cache the mappings on demand only.\n+  if (cache_enabled)\n+    CacheMemoryMappings();\n+}\n+\n+MemoryMappingLayout::~MemoryMappingLayout() {\n+  // Only unmap the buffer if it is different from the cached one. Otherwise\n+  // it will be unmapped when the cache is refreshed.\n+  if (proc_self_maps_.data != cached_proc_self_maps_.data) {\n+    UnmapOrDie(proc_self_maps_.data, proc_self_maps_.mmaped_size);\n+  }\n+}\n+\n+void MemoryMappingLayout::Reset() {\n+  current_ = proc_self_maps_.data;\n+}\n+\n+// static\n+void MemoryMappingLayout::CacheMemoryMappings() {\n+  SpinMutexLock l(&cache_lock_);\n+  // Don't invalidate the cache if the mappings are unavailable.\n+  ProcSelfMapsBuff old_proc_self_maps;\n+  old_proc_self_maps = cached_proc_self_maps_;\n+  ReadProcMaps(&cached_proc_self_maps_);\n+  if (cached_proc_self_maps_.mmaped_size == 0) {\n+    cached_proc_self_maps_ = old_proc_self_maps;\n+  } else {\n+    if (old_proc_self_maps.mmaped_size) {\n+      UnmapOrDie(old_proc_self_maps.data,\n+                 old_proc_self_maps.mmaped_size);\n+    }\n+  }\n+}\n+\n+void MemoryMappingLayout::LoadFromCache() {\n+  SpinMutexLock l(&cache_lock_);\n+  if (cached_proc_self_maps_.data) {\n+    proc_self_maps_ = cached_proc_self_maps_;\n+  }\n+}\n+\n+#if !SANITIZER_FREEBSD\n+// Parse a hex value in str and update str.\n+static uptr ParseHex(char **str) {\n+  uptr x = 0;\n+  char *s;\n+  for (s = *str; ; s++) {\n+    char c = *s;\n+    uptr v = 0;\n+    if (c >= '0' && c <= '9')\n+      v = c - '0';\n+    else if (c >= 'a' && c <= 'f')\n+      v = c - 'a' + 10;\n+    else if (c >= 'A' && c <= 'F')\n+      v = c - 'A' + 10;\n+    else\n+      break;\n+    x = x * 16 + v;\n+  }\n+  *str = s;\n+  return x;\n+}\n+\n+static bool IsOneOf(char c, char c1, char c2) {\n+  return c == c1 || c == c2;\n+}\n+#endif\n+\n+static bool IsDecimal(char c) {\n+  return c >= '0' && c <= '9';\n+}\n+\n+static bool IsHex(char c) {\n+  return (c >= '0' && c <= '9')\n+      || (c >= 'a' && c <= 'f');\n+}\n+\n+static uptr ReadHex(const char *p) {\n+  uptr v = 0;\n+  for (; IsHex(p[0]); p++) {\n+    if (p[0] >= '0' && p[0] <= '9')\n+      v = v * 16 + p[0] - '0';\n+    else\n+      v = v * 16 + p[0] - 'a' + 10;\n+  }\n+  return v;\n+}\n+\n+static uptr ReadDecimal(const char *p) {\n+  uptr v = 0;\n+  for (; IsDecimal(p[0]); p++)\n+    v = v * 10 + p[0] - '0';\n+  return v;\n+}\n+\n+bool MemoryMappingLayout::Next(uptr *start, uptr *end, uptr *offset,\n+                               char filename[], uptr filename_size,\n+                               uptr *protection) {\n+  char *last = proc_self_maps_.data + proc_self_maps_.len;\n+  if (current_ >= last) return false;\n+  uptr dummy;\n+  if (!start) start = &dummy;\n+  if (!end) end = &dummy;\n+  if (!offset) offset = &dummy;\n+  if (!protection) protection = &dummy;\n+#if SANITIZER_FREEBSD\n+  struct kinfo_vmentry *VmEntry = (struct kinfo_vmentry*)current_;\n+\n+  *start = (uptr)VmEntry->kve_start;\n+  *end = (uptr)VmEntry->kve_end;\n+  *offset = (uptr)VmEntry->kve_offset;\n+\n+  *protection = 0;\n+  if ((VmEntry->kve_protection & KVME_PROT_READ) != 0)\n+    *protection |= kProtectionRead;\n+  if ((VmEntry->kve_protection & KVME_PROT_WRITE) != 0)\n+    *protection |= kProtectionWrite;\n+  if ((VmEntry->kve_protection & KVME_PROT_EXEC) != 0)\n+    *protection |= kProtectionExecute;\n+\n+  if (filename != NULL && filename_size > 0) {\n+    internal_snprintf(filename,\n+                      Min(filename_size, (uptr)PATH_MAX),\n+                      \"%s\", VmEntry->kve_path);\n+  }\n+\n+  current_ += VmEntry->kve_structsize;\n+#else  // !SANITIZER_FREEBSD\n+  char *next_line = (char*)internal_memchr(current_, '\\n', last - current_);\n+  if (next_line == 0)\n+    next_line = last;\n+  // Example: 08048000-08056000 r-xp 00000000 03:0c 64593   /foo/bar\n+  *start = ParseHex(&current_);\n+  CHECK_EQ(*current_++, '-');\n+  *end = ParseHex(&current_);\n+  CHECK_EQ(*current_++, ' ');\n+  CHECK(IsOneOf(*current_, '-', 'r'));\n+  *protection = 0;\n+  if (*current_++ == 'r')\n+    *protection |= kProtectionRead;\n+  CHECK(IsOneOf(*current_, '-', 'w'));\n+  if (*current_++ == 'w')\n+    *protection |= kProtectionWrite;\n+  CHECK(IsOneOf(*current_, '-', 'x'));\n+  if (*current_++ == 'x')\n+    *protection |= kProtectionExecute;\n+  CHECK(IsOneOf(*current_, 's', 'p'));\n+  if (*current_++ == 's')\n+    *protection |= kProtectionShared;\n+  CHECK_EQ(*current_++, ' ');\n+  *offset = ParseHex(&current_);\n+  CHECK_EQ(*current_++, ' ');\n+  ParseHex(&current_);\n+  CHECK_EQ(*current_++, ':');\n+  ParseHex(&current_);\n+  CHECK_EQ(*current_++, ' ');\n+  while (IsDecimal(*current_))\n+    current_++;\n+  // Qemu may lack the trailing space.\n+  // http://code.google.com/p/address-sanitizer/issues/detail?id=160\n+  // CHECK_EQ(*current_++, ' ');\n+  // Skip spaces.\n+  while (current_ < next_line && *current_ == ' ')\n+    current_++;\n+  // Fill in the filename.\n+  uptr i = 0;\n+  while (current_ < next_line) {\n+    if (filename && i < filename_size - 1)\n+      filename[i++] = *current_;\n+    current_++;\n+  }\n+  if (filename && i < filename_size)\n+    filename[i] = 0;\n+  current_ = next_line + 1;\n+#endif  // !SANITIZER_FREEBSD\n+  return true;\n+}\n+\n+uptr MemoryMappingLayout::DumpListOfModules(LoadedModule *modules,\n+                                            uptr max_modules,\n+                                            string_predicate_t filter) {\n+  Reset();\n+  uptr cur_beg, cur_end, cur_offset;\n+  InternalScopedBuffer<char> module_name(kMaxPathLength);\n+  uptr n_modules = 0;\n+  for (uptr i = 0; n_modules < max_modules &&\n+                       Next(&cur_beg, &cur_end, &cur_offset, module_name.data(),\n+                            module_name.size(), 0);\n+       i++) {\n+    const char *cur_name = module_name.data();\n+    if (cur_name[0] == '\\0')\n+      continue;\n+    if (filter && !filter(cur_name))\n+      continue;\n+    void *mem = &modules[n_modules];\n+    // Don't subtract 'cur_beg' from the first entry:\n+    // * If a binary is compiled w/o -pie, then the first entry in\n+    //   process maps is likely the binary itself (all dynamic libs\n+    //   are mapped higher in address space). For such a binary,\n+    //   instruction offset in binary coincides with the actual\n+    //   instruction address in virtual memory (as code section\n+    //   is mapped to a fixed memory range).\n+    // * If a binary is compiled with -pie, all the modules are\n+    //   mapped high at address space (in particular, higher than\n+    //   shadow memory of the tool), so the module can't be the\n+    //   first entry.\n+    uptr base_address = (i ? cur_beg : 0) - cur_offset;\n+    LoadedModule *cur_module = new(mem) LoadedModule(cur_name, base_address);\n+    cur_module->addAddressRange(cur_beg, cur_end);\n+    n_modules++;\n+  }\n+  return n_modules;\n+}\n+\n+void GetMemoryProfile(fill_profile_f cb, uptr *stats, uptr stats_size) {\n+  char *smaps = 0;\n+  uptr smaps_cap = 0;\n+  uptr smaps_len = ReadFileToBuffer(\"/proc/self/smaps\",\n+      &smaps, &smaps_cap, 64<<20);\n+  uptr start = 0;\n+  bool file = false;\n+  const char *pos = smaps;\n+  while (pos < smaps + smaps_len) {\n+    if (IsHex(pos[0])) {\n+      start = ReadHex(pos);\n+      for (; *pos != '/' && *pos > '\\n'; pos++) {}\n+      file = *pos == '/';\n+    } else if (internal_strncmp(pos, \"Rss:\", 4) == 0) {\n+      for (; *pos < '0' || *pos > '9'; pos++) {}\n+      uptr rss = ReadDecimal(pos) * 1024;\n+      cb(start, rss, file, stats, stats_size);\n+    }\n+    while (*pos++ != '\\n') {}\n+  }\n+  UnmapOrDie(smaps, smaps_cap);\n+}\n+\n+}  // namespace __sanitizer\n+\n+#endif  // SANITIZER_FREEBSD || SANITIZER_LINUX"}, {"sha": "c68530683467b713c13624d51290fd1c47c0448e", "filename": "libsanitizer/sanitizer_common/sanitizer_procmaps_mac.cc", "status": "added", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_mac.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -0,0 +1,186 @@\n+//===-- sanitizer_procmaps_mac.cc -----------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Information about the process mappings (Mac-specific parts).\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_platform.h\"\n+#if SANITIZER_MAC\n+#include \"sanitizer_common.h\"\n+#include \"sanitizer_placement_new.h\"\n+#include \"sanitizer_procmaps.h\"\n+\n+#include <mach-o/dyld.h>\n+#include <mach-o/loader.h>\n+\n+namespace __sanitizer {\n+\n+MemoryMappingLayout::MemoryMappingLayout(bool cache_enabled) {\n+  Reset();\n+}\n+\n+MemoryMappingLayout::~MemoryMappingLayout() {\n+}\n+\n+// More information about Mach-O headers can be found in mach-o/loader.h\n+// Each Mach-O image has a header (mach_header or mach_header_64) starting with\n+// a magic number, and a list of linker load commands directly following the\n+// header.\n+// A load command is at least two 32-bit words: the command type and the\n+// command size in bytes. We're interested only in segment load commands\n+// (LC_SEGMENT and LC_SEGMENT_64), which tell that a part of the file is mapped\n+// into the task's address space.\n+// The |vmaddr|, |vmsize| and |fileoff| fields of segment_command or\n+// segment_command_64 correspond to the memory address, memory size and the\n+// file offset of the current memory segment.\n+// Because these fields are taken from the images as is, one needs to add\n+// _dyld_get_image_vmaddr_slide() to get the actual addresses at runtime.\n+\n+void MemoryMappingLayout::Reset() {\n+  // Count down from the top.\n+  // TODO(glider): as per man 3 dyld, iterating over the headers with\n+  // _dyld_image_count is thread-unsafe. We need to register callbacks for\n+  // adding and removing images which will invalidate the MemoryMappingLayout\n+  // state.\n+  current_image_ = _dyld_image_count();\n+  current_load_cmd_count_ = -1;\n+  current_load_cmd_addr_ = 0;\n+  current_magic_ = 0;\n+  current_filetype_ = 0;\n+}\n+\n+// static\n+void MemoryMappingLayout::CacheMemoryMappings() {\n+  // No-op on Mac for now.\n+}\n+\n+void MemoryMappingLayout::LoadFromCache() {\n+  // No-op on Mac for now.\n+}\n+\n+// Next and NextSegmentLoad were inspired by base/sysinfo.cc in\n+// Google Perftools, http://code.google.com/p/google-perftools.\n+\n+// NextSegmentLoad scans the current image for the next segment load command\n+// and returns the start and end addresses and file offset of the corresponding\n+// segment.\n+// Note that the segment addresses are not necessarily sorted.\n+template<u32 kLCSegment, typename SegmentCommand>\n+bool MemoryMappingLayout::NextSegmentLoad(\n+    uptr *start, uptr *end, uptr *offset,\n+    char filename[], uptr filename_size, uptr *protection) {\n+  if (protection)\n+    UNIMPLEMENTED();\n+  const char* lc = current_load_cmd_addr_;\n+  current_load_cmd_addr_ += ((const load_command *)lc)->cmdsize;\n+  if (((const load_command *)lc)->cmd == kLCSegment) {\n+    const sptr dlloff = _dyld_get_image_vmaddr_slide(current_image_);\n+    const SegmentCommand* sc = (const SegmentCommand *)lc;\n+    if (start) *start = sc->vmaddr + dlloff;\n+    if (end) *end = sc->vmaddr + sc->vmsize + dlloff;\n+    if (offset) {\n+      if (current_filetype_ == /*MH_EXECUTE*/ 0x2) {\n+        *offset = sc->vmaddr;\n+      } else {\n+        *offset = sc->fileoff;\n+      }\n+    }\n+    if (filename) {\n+      internal_strncpy(filename, _dyld_get_image_name(current_image_),\n+                       filename_size);\n+    }\n+    return true;\n+  }\n+  return false;\n+}\n+\n+bool MemoryMappingLayout::Next(uptr *start, uptr *end, uptr *offset,\n+                               char filename[], uptr filename_size,\n+                               uptr *protection) {\n+  for (; current_image_ >= 0; current_image_--) {\n+    const mach_header* hdr = _dyld_get_image_header(current_image_);\n+    if (!hdr) continue;\n+    if (current_load_cmd_count_ < 0) {\n+      // Set up for this image;\n+      current_load_cmd_count_ = hdr->ncmds;\n+      current_magic_ = hdr->magic;\n+      current_filetype_ = hdr->filetype;\n+      switch (current_magic_) {\n+#ifdef MH_MAGIC_64\n+        case MH_MAGIC_64: {\n+          current_load_cmd_addr_ = (char*)hdr + sizeof(mach_header_64);\n+          break;\n+        }\n+#endif\n+        case MH_MAGIC: {\n+          current_load_cmd_addr_ = (char*)hdr + sizeof(mach_header);\n+          break;\n+        }\n+        default: {\n+          continue;\n+        }\n+      }\n+    }\n+\n+    for (; current_load_cmd_count_ >= 0; current_load_cmd_count_--) {\n+      switch (current_magic_) {\n+        // current_magic_ may be only one of MH_MAGIC, MH_MAGIC_64.\n+#ifdef MH_MAGIC_64\n+        case MH_MAGIC_64: {\n+          if (NextSegmentLoad<LC_SEGMENT_64, struct segment_command_64>(\n+                  start, end, offset, filename, filename_size, protection))\n+            return true;\n+          break;\n+        }\n+#endif\n+        case MH_MAGIC: {\n+          if (NextSegmentLoad<LC_SEGMENT, struct segment_command>(\n+                  start, end, offset, filename, filename_size, protection))\n+            return true;\n+          break;\n+        }\n+      }\n+    }\n+    // If we get here, no more load_cmd's in this image talk about\n+    // segments.  Go on to the next image.\n+  }\n+  return false;\n+}\n+\n+uptr MemoryMappingLayout::DumpListOfModules(LoadedModule *modules,\n+                                            uptr max_modules,\n+                                            string_predicate_t filter) {\n+  Reset();\n+  uptr cur_beg, cur_end;\n+  InternalScopedBuffer<char> module_name(kMaxPathLength);\n+  uptr n_modules = 0;\n+  for (uptr i = 0; n_modules < max_modules &&\n+                       Next(&cur_beg, &cur_end, 0, module_name.data(),\n+                            module_name.size(), 0);\n+       i++) {\n+    const char *cur_name = module_name.data();\n+    if (cur_name[0] == '\\0')\n+      continue;\n+    if (filter && !filter(cur_name))\n+      continue;\n+    LoadedModule *cur_module = 0;\n+    if (n_modules > 0 &&\n+        0 == internal_strcmp(cur_name, modules[n_modules - 1].full_name())) {\n+      cur_module = &modules[n_modules - 1];\n+    } else {\n+      void *mem = &modules[n_modules];\n+      cur_module = new(mem) LoadedModule(cur_name, cur_beg);\n+      n_modules++;\n+    }\n+    cur_module->addAddressRange(cur_beg, cur_end);\n+  }\n+  return n_modules;\n+}\n+\n+}  // namespace __sanitizer\n+\n+#endif  // SANITIZER_MAC"}, {"sha": "c85105851112a53a53267677170a093f6a2119bd", "filename": "libsanitizer/sanitizer_common/sanitizer_report_decorator.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_report_decorator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_report_decorator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_report_decorator.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -15,6 +15,8 @@\n #ifndef SANITIZER_REPORT_DECORATOR_H\n #define SANITIZER_REPORT_DECORATOR_H\n \n+#include \"sanitizer_common.h\"\n+\n namespace __sanitizer {\n class AnsiColorDecorator {\n   // FIXME: This is not portable. It assumes the special strings are printed to\n@@ -34,6 +36,15 @@ class AnsiColorDecorator {\n  private:\n   bool ansi_;\n };\n+\n+class SanitizerCommonDecorator: protected AnsiColorDecorator {\n+ public:\n+  SanitizerCommonDecorator()\n+      : __sanitizer::AnsiColorDecorator(ColorizeReports()) { }\n+  const char *Warning()    { return Red(); }\n+  const char *EndWarning() { return Default(); }\n+};\n+\n }  // namespace __sanitizer\n \n #endif  // SANITIZER_REPORT_DECORATOR_H"}, {"sha": "3938f03a4d8fe028459013ea2931b37f812dc1e5", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace.cc", "status": "modified", "additions": 9, "deletions": 98, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -11,9 +11,7 @@\n \n #include \"sanitizer_common.h\"\n #include \"sanitizer_flags.h\"\n-#include \"sanitizer_procmaps.h\"\n #include \"sanitizer_stacktrace.h\"\n-#include \"sanitizer_symbolizer.h\"\n \n namespace __sanitizer {\n \n@@ -22,108 +20,21 @@ uptr StackTrace::GetPreviousInstructionPc(uptr pc) {\n   // Cancel Thumb bit.\n   pc = pc & (~1);\n #endif\n-#if defined(__powerpc__) || defined(__powerpc64__)\n-  // PCs are always 4 byte aligned.\n-  return pc - 4;\n-#elif defined(__sparc__)\n+#if defined(__sparc__)\n   return pc - 8;\n #else\n   return pc - 1;\n #endif\n }\n \n-static void PrintStackFramePrefix(InternalScopedString *buffer, uptr frame_num,\n-                                  uptr pc) {\n-  buffer->append(\"    #%zu 0x%zx\", frame_num, pc);\n-}\n-\n-void StackTrace::PrintStack(const uptr *addr, uptr size,\n-                            SymbolizeCallback symbolize_callback) {\n-  if (addr == 0 || size == 0) {\n-    Printf(\"    <empty stack>\\n\\n\");\n-    return;\n-  }\n-  MemoryMappingLayout proc_maps(/*cache_enabled*/true);\n-  InternalScopedBuffer<char> buff(GetPageSizeCached() * 2);\n-  InternalScopedBuffer<AddressInfo> addr_frames(64);\n-  InternalScopedString frame_desc(GetPageSizeCached() * 2);\n-  uptr frame_num = 0;\n-  for (uptr i = 0; i < size && addr[i]; i++) {\n-    // PCs in stack traces are actually the return addresses, that is,\n-    // addresses of the next instructions after the call.\n-    uptr pc = GetPreviousInstructionPc(addr[i]);\n-    uptr addr_frames_num = 0;  // The number of stack frames for current\n-                               // instruction address.\n-    if (symbolize_callback) {\n-      if (symbolize_callback((void*)pc, buff.data(), buff.size())) {\n-        addr_frames_num = 1;\n-        frame_desc.clear();\n-        PrintStackFramePrefix(&frame_desc, frame_num, pc);\n-        // We can't know anything about the string returned by external\n-        // symbolizer, but if it starts with filename, try to strip path prefix\n-        // from it.\n-        frame_desc.append(\n-            \" %s\",\n-            StripPathPrefix(buff.data(), common_flags()->strip_path_prefix));\n-        Printf(\"%s\\n\", frame_desc.data());\n-        frame_num++;\n-      }\n-    }\n-    if (common_flags()->symbolize && addr_frames_num == 0) {\n-      // Use our own (online) symbolizer, if necessary.\n-      if (Symbolizer *sym = Symbolizer::GetOrNull())\n-        addr_frames_num =\n-            sym->SymbolizeCode(pc, addr_frames.data(), addr_frames.size());\n-      for (uptr j = 0; j < addr_frames_num; j++) {\n-        AddressInfo &info = addr_frames[j];\n-        frame_desc.clear();\n-        PrintStackFramePrefix(&frame_desc, frame_num, pc);\n-        if (info.function) {\n-          frame_desc.append(\" in %s\", info.function);\n-        }\n-        if (info.file) {\n-          frame_desc.append(\" \");\n-          PrintSourceLocation(&frame_desc, info.file, info.line, info.column);\n-        } else if (info.module) {\n-          frame_desc.append(\" \");\n-          PrintModuleAndOffset(&frame_desc, info.module, info.module_offset);\n-        }\n-        Printf(\"%s\\n\", frame_desc.data());\n-        frame_num++;\n-        info.Clear();\n-      }\n-    }\n-    if (addr_frames_num == 0) {\n-      // If online symbolization failed, try to output at least module and\n-      // offset for instruction.\n-      frame_desc.clear();\n-      PrintStackFramePrefix(&frame_desc, frame_num, pc);\n-      uptr offset;\n-      if (proc_maps.GetObjectNameAndOffset(pc, &offset,\n-                                           buff.data(), buff.size(),\n-                                           /* protection */0)) {\n-        frame_desc.append(\" \");\n-        PrintModuleAndOffset(&frame_desc, buff.data(), offset);\n-      }\n-      Printf(\"%s\\n\", frame_desc.data());\n-      frame_num++;\n-    }\n-  }\n-  // Always print a trailing empty line after stack trace.\n-  Printf(\"\\n\");\n-}\n-\n uptr StackTrace::GetCurrentPc() {\n   return GET_CALLER_PC();\n }\n \n void StackTrace::FastUnwindStack(uptr pc, uptr bp,\n                                  uptr stack_top, uptr stack_bottom,\n                                  uptr max_depth) {\n-  if (max_depth == 0) {\n-    size = 0;\n-    return;\n-  }\n+  CHECK_GE(max_depth, 2);\n   trace[0] = pc;\n   size = 1;\n   uhwptr *frame = (uhwptr *)bp;\n@@ -144,22 +55,22 @@ void StackTrace::FastUnwindStack(uptr pc, uptr bp,\n   }\n }\n \n+static bool MatchPc(uptr cur_pc, uptr trace_pc, uptr threshold) {\n+  return cur_pc - trace_pc <= threshold || trace_pc - cur_pc <= threshold;\n+}\n+\n void StackTrace::PopStackFrames(uptr count) {\n-  CHECK(size >= count);\n+  CHECK_LT(count, size);\n   size -= count;\n-  for (uptr i = 0; i < size; i++) {\n+  for (uptr i = 0; i < size; ++i) {\n     trace[i] = trace[i + count];\n   }\n }\n \n-static bool MatchPc(uptr cur_pc, uptr trace_pc, uptr threshold) {\n-  return cur_pc - trace_pc <= threshold || trace_pc - cur_pc <= threshold;\n-}\n-\n uptr StackTrace::LocatePcInTrace(uptr pc) {\n   // Use threshold to find PC in stack trace, as PC we want to unwind from may\n   // slightly differ from return address in the actual unwinded stack trace.\n-  const int kPcThreshold = 192;\n+  const int kPcThreshold = 288;\n   for (uptr i = 0; i < size; ++i) {\n     if (MatchPc(pc, trace[i], kPcThreshold))\n       return i;"}, {"sha": "f66857ed1fb7ad2717db6805fcdf27366177ae72", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace.h", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -17,10 +17,9 @@ namespace __sanitizer {\n \n static const uptr kStackTraceMax = 256;\n \n-#if SANITIZER_LINUX && (defined(__arm__) || \\\n-    defined(__powerpc__) || defined(__powerpc64__) || \\\n-    defined(__sparc__) || \\\n-    defined(__mips__))\n+#if SANITIZER_LINUX && (defined(__aarch64__) || defined(__powerpc__) || \\\n+                        defined(__powerpc64__) || defined(__sparc__) || \\\n+                        defined(__mips__))\n # define SANITIZER_CAN_FAST_UNWIND 0\n #elif SANITIZER_WINDOWS\n # define SANITIZER_CAN_FAST_UNWIND 0\n@@ -36,8 +35,10 @@ struct StackTrace {\n   uptr trace[kStackTraceMax];\n \n   // Prints a symbolized stacktrace, followed by an empty line.\n-  static void PrintStack(const uptr *addr, uptr size,\n-                         SymbolizeCallback symbolize_callback = 0);\n+  static void PrintStack(const uptr *addr, uptr size);\n+  void Print() const {\n+    PrintStack(trace, size);\n+  }\n \n   void CopyFrom(const uptr *src, uptr src_size) {\n     top_frame_bp = 0;\n@@ -56,7 +57,7 @@ struct StackTrace {\n     return request_fast_unwind;\n   }\n \n-  void Unwind(uptr max_depth, uptr pc, uptr bp, uptr stack_top,\n+  void Unwind(uptr max_depth, uptr pc, uptr bp, void *context, uptr stack_top,\n               uptr stack_bottom, bool request_fast_unwind);\n \n   static uptr GetCurrentPc();\n@@ -66,6 +67,8 @@ struct StackTrace {\n   void FastUnwindStack(uptr pc, uptr bp, uptr stack_top, uptr stack_bottom,\n                        uptr max_depth);\n   void SlowUnwindStack(uptr pc, uptr max_depth);\n+  void SlowUnwindStackWithContext(uptr pc, void *context,\n+                                  uptr max_depth);\n   void PopStackFrames(uptr count);\n   uptr LocatePcInTrace(uptr pc);\n };"}, {"sha": "c3c1045ee04acf31006117cf8830c88597d7f537", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace_libcdep.cc", "status": "modified", "additions": 69, "deletions": 7, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_libcdep.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -9,18 +9,80 @@\n // run-time libraries.\n //===----------------------------------------------------------------------===//\n \n+#include \"sanitizer_common.h\"\n #include \"sanitizer_stacktrace.h\"\n+#include \"sanitizer_symbolizer.h\"\n \n namespace __sanitizer {\n \n-void StackTrace::Unwind(uptr max_depth, uptr pc, uptr bp, uptr stack_top,\n-                        uptr stack_bottom, bool request_fast_unwind) {\n-  if (!WillUseFastUnwind(request_fast_unwind))\n-    SlowUnwindStack(pc, max_depth);\n-  else\n-    FastUnwindStack(pc, bp, stack_top, stack_bottom, max_depth);\n+static void PrintStackFramePrefix(InternalScopedString *buffer, uptr frame_num,\n+                                  uptr pc) {\n+  buffer->append(\"    #%zu 0x%zx\", frame_num, pc);\n+}\n \n-  top_frame_bp = size ? bp : 0;\n+void StackTrace::PrintStack(const uptr *addr, uptr size) {\n+  if (addr == 0 || size == 0) {\n+    Printf(\"    <empty stack>\\n\\n\");\n+    return;\n+  }\n+  InternalScopedBuffer<char> buff(GetPageSizeCached() * 2);\n+  InternalScopedBuffer<AddressInfo> addr_frames(64);\n+  InternalScopedString frame_desc(GetPageSizeCached() * 2);\n+  uptr frame_num = 0;\n+  for (uptr i = 0; i < size && addr[i]; i++) {\n+    // PCs in stack traces are actually the return addresses, that is,\n+    // addresses of the next instructions after the call.\n+    uptr pc = GetPreviousInstructionPc(addr[i]);\n+    uptr addr_frames_num = Symbolizer::GetOrInit()->SymbolizePC(\n+        pc, addr_frames.data(), addr_frames.size());\n+    for (uptr j = 0; j < addr_frames_num; j++) {\n+      AddressInfo &info = addr_frames[j];\n+      frame_desc.clear();\n+      PrintStackFramePrefix(&frame_desc, frame_num, pc);\n+      if (info.function) {\n+        frame_desc.append(\" in %s\", info.function);\n+        // Print offset in function if we don't know the source file.\n+        if (!info.file && info.function_offset != AddressInfo::kUnknown)\n+          frame_desc.append(\"+0x%zx\", info.function_offset);\n+      }\n+      if (info.file) {\n+        frame_desc.append(\" \");\n+        PrintSourceLocation(&frame_desc, info.file, info.line, info.column);\n+      } else if (info.module) {\n+        frame_desc.append(\" \");\n+        PrintModuleAndOffset(&frame_desc, info.module, info.module_offset);\n+      }\n+      Printf(\"%s\\n\", frame_desc.data());\n+      frame_num++;\n+      info.Clear();\n+    }\n+  }\n+  // Always print a trailing empty line after stack trace.\n+  Printf(\"\\n\");\n+}\n+\n+void StackTrace::Unwind(uptr max_depth, uptr pc, uptr bp, void *context,\n+                        uptr stack_top, uptr stack_bottom,\n+                        bool request_fast_unwind) {\n+  top_frame_bp = (max_depth > 0) ? bp : 0;\n+  // Avoid doing any work for small max_depth.\n+  if (max_depth == 0) {\n+    size = 0;\n+    return;\n+  }\n+  if (max_depth == 1) {\n+    size = 1;\n+    trace[0] = pc;\n+    return;\n+  }\n+  if (!WillUseFastUnwind(request_fast_unwind)) {\n+    if (context)\n+      SlowUnwindStackWithContext(pc, context, max_depth);\n+    else\n+      SlowUnwindStack(pc, max_depth);\n+  } else {\n+    FastUnwindStack(pc, bp, stack_top, stack_bottom, max_depth);\n+  }\n }\n \n }  // namespace __sanitizer"}, {"sha": "58812023674ed2f18b0333a6d02e2e5f231fcd2a", "filename": "libsanitizer/sanitizer_common/sanitizer_stoptheworld_linux_libcdep.cc", "status": "modified", "additions": 25, "deletions": 33, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld_linux_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld_linux_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld_linux_libcdep.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -98,12 +98,11 @@ bool ThreadSuspender::SuspendThread(SuspendedThreadID thread_id) {\n                        &pterrno)) {\n     // Either the thread is dead, or something prevented us from attaching.\n     // Log this event and move on.\n-    if (common_flags()->verbosity)\n-      Report(\"Could not attach to thread %d (errno %d).\\n\", thread_id, pterrno);\n+    VReport(1, \"Could not attach to thread %d (errno %d).\\n\", thread_id,\n+            pterrno);\n     return false;\n   } else {\n-    if (common_flags()->verbosity)\n-      Report(\"Attached to thread %d.\\n\", thread_id);\n+    VReport(1, \"Attached to thread %d.\\n\", thread_id);\n     // The thread is not guaranteed to stop before ptrace returns, so we must\n     // wait on it.\n     uptr waitpid_status;\n@@ -112,9 +111,8 @@ bool ThreadSuspender::SuspendThread(SuspendedThreadID thread_id) {\n     if (internal_iserror(waitpid_status, &wperrno)) {\n       // Got a ECHILD error. I don't think this situation is possible, but it\n       // doesn't hurt to report it.\n-      if (common_flags()->verbosity)\n-        Report(\"Waiting on thread %d failed, detaching (errno %d).\\n\",\n-            thread_id, wperrno);\n+      VReport(1, \"Waiting on thread %d failed, detaching (errno %d).\\n\",\n+              thread_id, wperrno);\n       internal_ptrace(PTRACE_DETACH, thread_id, NULL, NULL);\n       return false;\n     }\n@@ -129,14 +127,12 @@ void ThreadSuspender::ResumeAllThreads() {\n     int pterrno;\n     if (!internal_iserror(internal_ptrace(PTRACE_DETACH, tid, NULL, NULL),\n                           &pterrno)) {\n-      if (common_flags()->verbosity)\n-        Report(\"Detached from thread %d.\\n\", tid);\n+      VReport(1, \"Detached from thread %d.\\n\", tid);\n     } else {\n       // Either the thread is dead, or we are already detached.\n       // The latter case is possible, for instance, if this function was called\n       // from a signal handler.\n-      if (common_flags()->verbosity)\n-        Report(\"Could not detach from thread %d (errno %d).\\n\", tid, pterrno);\n+      VReport(1, \"Could not detach from thread %d (errno %d).\\n\", tid, pterrno);\n     }\n   }\n }\n@@ -248,18 +244,18 @@ static int TracerThread(void* argument) {\n   // the mask we inherited from the caller thread.\n   for (uptr signal_index = 0; signal_index < ARRAY_SIZE(kUnblockedSignals);\n        signal_index++) {\n-    __sanitizer_kernel_sigaction_t new_sigaction;\n+    __sanitizer_sigaction new_sigaction;\n     internal_memset(&new_sigaction, 0, sizeof(new_sigaction));\n     new_sigaction.sigaction = TracerThreadSignalHandler;\n     new_sigaction.sa_flags = SA_ONSTACK | SA_SIGINFO;\n     internal_sigfillset(&new_sigaction.sa_mask);\n-    internal_sigaction(kUnblockedSignals[signal_index], &new_sigaction, NULL);\n+    internal_sigaction_norestorer(kUnblockedSignals[signal_index],\n+                                  &new_sigaction, NULL);\n   }\n \n   int exit_code = 0;\n   if (!thread_suspender.SuspendAllThreads()) {\n-    if (common_flags()->verbosity)\n-      Report(\"Failed suspending threads.\\n\");\n+    VReport(1, \"Failed suspending threads.\\n\");\n     exit_code = 3;\n   } else {\n     tracer_thread_argument->callback(thread_suspender.suspended_threads_list(),\n@@ -299,9 +295,9 @@ class ScopedStackSpaceWithGuard {\n \n // We have a limitation on the stack frame size, so some stuff had to be moved\n // into globals.\n-static __sanitizer_kernel_sigset_t blocked_sigset;\n-static __sanitizer_kernel_sigset_t old_sigset;\n-static __sanitizer_kernel_sigaction_t old_sigactions\n+static __sanitizer_sigset_t blocked_sigset;\n+static __sanitizer_sigset_t old_sigset;\n+static __sanitizer_sigaction old_sigactions\n     [ARRAY_SIZE(kUnblockedSignals)];\n \n class StopTheWorldScope {\n@@ -318,12 +314,12 @@ class StopTheWorldScope {\n       // Remove the signal from the set of blocked signals.\n       internal_sigdelset(&blocked_sigset, kUnblockedSignals[signal_index]);\n       // Install the default handler.\n-      __sanitizer_kernel_sigaction_t new_sigaction;\n+      __sanitizer_sigaction new_sigaction;\n       internal_memset(&new_sigaction, 0, sizeof(new_sigaction));\n       new_sigaction.handler = SIG_DFL;\n       internal_sigfillset(&new_sigaction.sa_mask);\n-      internal_sigaction(kUnblockedSignals[signal_index], &new_sigaction,\n-                      &old_sigactions[signal_index]);\n+      internal_sigaction_norestorer(kUnblockedSignals[signal_index],\n+          &new_sigaction, &old_sigactions[signal_index]);\n     }\n     int sigprocmask_status =\n         internal_sigprocmask(SIG_BLOCK, &blocked_sigset, &old_sigset);\n@@ -344,8 +340,8 @@ class StopTheWorldScope {\n     // Restore the signal handlers.\n     for (uptr signal_index = 0; signal_index < ARRAY_SIZE(kUnblockedSignals);\n          signal_index++) {\n-      internal_sigaction(kUnblockedSignals[signal_index],\n-                &old_sigactions[signal_index], NULL);\n+      internal_sigaction_norestorer(kUnblockedSignals[signal_index],\n+                                    &old_sigactions[signal_index], NULL);\n     }\n     internal_sigprocmask(SIG_SETMASK, &old_sigset, &old_sigset);\n   }\n@@ -387,8 +383,7 @@ void StopTheWorld(StopTheWorldCallback callback, void *argument) {\n       /* child_tidptr */);\n   int local_errno = 0;\n   if (internal_iserror(tracer_pid, &local_errno)) {\n-    if (common_flags()->verbosity)\n-      Report(\"Failed spawning a tracer thread (errno %d).\\n\", local_errno);\n+    VReport(1, \"Failed spawning a tracer thread (errno %d).\\n\", local_errno);\n     tracer_thread_argument.mutex.Unlock();\n   } else {\n     ScopedSetTracerPID scoped_set_tracer_pid(tracer_pid);\n@@ -404,11 +399,9 @@ void StopTheWorld(StopTheWorldCallback callback, void *argument) {\n     // At this point, any signal will either be blocked or kill us, so waitpid\n     // should never return (and set errno) while the tracer thread is alive.\n     uptr waitpid_status = internal_waitpid(tracer_pid, NULL, __WALL);\n-    if (internal_iserror(waitpid_status, &local_errno)) {\n-      if (common_flags()->verbosity)\n-        Report(\"Waiting on the tracer thread failed (errno %d).\\n\",\n-            local_errno);\n-    }\n+    if (internal_iserror(waitpid_status, &local_errno))\n+      VReport(1, \"Waiting on the tracer thread failed (errno %d).\\n\",\n+              local_errno);\n   }\n }\n \n@@ -449,9 +442,8 @@ int SuspendedThreadsList::GetRegistersAndSP(uptr index,\n   int pterrno;\n   if (internal_iserror(internal_ptrace(PTRACE_GETREGS, tid, NULL, &regs),\n                        &pterrno)) {\n-    if (common_flags()->verbosity)\n-      Report(\"Could not get registers from thread %d (errno %d).\\n\",\n-           tid, pterrno);\n+    VReport(1, \"Could not get registers from thread %d (errno %d).\\n\", tid,\n+            pterrno);\n     return -1;\n   }\n "}, {"sha": "1766fb5a3190173b584ebbda7ac590b4749d7cc8", "filename": "libsanitizer/sanitizer_common/sanitizer_suppressions.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_suppressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_suppressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_suppressions.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -18,8 +18,8 @@\n namespace __sanitizer {\n \n static const char *const kTypeStrings[SuppressionTypeCount] = {\n-  \"none\", \"race\", \"mutex\", \"thread\", \"signal\", \"leak\", \"called_from_lib\"\n-};\n+    \"none\",   \"race\", \"mutex\",           \"thread\",\n+    \"signal\", \"leak\", \"called_from_lib\", \"deadlock\"};\n \n bool TemplateMatch(char *templ, const char *str) {\n   if (str == 0 || str[0] == 0)"}, {"sha": "033ddc5f52adb35fbb37913d7519132ad87665ea", "filename": "libsanitizer/sanitizer_common/sanitizer_suppressions.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_suppressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_suppressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_suppressions.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -24,6 +24,7 @@ enum SuppressionType {\n   SuppressionSignal,\n   SuppressionLeak,\n   SuppressionLib,\n+  SuppressionDeadlock,\n   SuppressionTypeCount\n };\n "}, {"sha": "05fc6a7cbb92d5a6d6862782fffd976d88e5497f", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer.h", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -25,23 +25,30 @@ namespace __sanitizer {\n \n struct AddressInfo {\n   uptr address;\n+\n   char *module;\n   uptr module_offset;\n+\n+  static const uptr kUnknown = ~(uptr)0;\n   char *function;\n+  uptr function_offset;\n+\n   char *file;\n   int line;\n   int column;\n \n   AddressInfo() {\n     internal_memset(this, 0, sizeof(AddressInfo));\n+    function_offset = kUnknown;\n   }\n \n-  // Deletes all strings and sets all fields to zero.\n+  // Deletes all strings and resets all fields.\n   void Clear() {\n     InternalFree(module);\n     InternalFree(function);\n     InternalFree(file);\n     internal_memset(this, 0, sizeof(AddressInfo));\n+    function_offset = kUnknown;\n   }\n \n   void FillAddressAndModuleInfo(uptr addr, const char *mod_name,\n@@ -77,22 +84,20 @@ class Symbolizer {\n   /// reasons as this function will check $PATH for an external symbolizer.  Not\n   /// thread safe.\n   static Symbolizer *Init(const char* path_to_external = 0);\n-  /// Initialize the symbolizer in a disabled state.  Not thread safe.\n-  static Symbolizer *Disable();\n   // Fills at most \"max_frames\" elements of \"frames\" with descriptions\n   // for a given address (in all inlined functions). Returns the number\n   // of descriptions actually filled.\n-  virtual uptr SymbolizeCode(uptr address, AddressInfo *frames,\n-                             uptr max_frames) {\n+  virtual uptr SymbolizePC(uptr address, AddressInfo *frames, uptr max_frames) {\n     return 0;\n   }\n   virtual bool SymbolizeData(uptr address, DataInfo *info) {\n     return false;\n   }\n-  virtual bool IsAvailable() {\n+  virtual bool GetModuleNameAndOffsetForPC(uptr pc, const char **module_name,\n+                                           uptr *module_address) {\n     return false;\n   }\n-  virtual bool IsExternalAvailable() {\n+  virtual bool CanReturnFileLineInfo() {\n     return false;\n   }\n   // Release internal caches (if any).\n@@ -119,6 +124,8 @@ class Symbolizer {\n   /// Create a symbolizer and store it to symbolizer_ without checking if one\n   /// already exists.  Not thread safe.\n   static Symbolizer *CreateAndStore(const char *path_to_external);\n+  /// Initialize the symbolizer in a disabled state.  Not thread safe.\n+  static Symbolizer *Disable();\n \n   static Symbolizer *symbolizer_;\n   static StaticSpinMutex init_mu_;"}, {"sha": "86d32e529ec7aeb6b2405f142e9c40ed241f54e7", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_libbacktrace.cc", "status": "modified", "additions": 16, "deletions": 29, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libbacktrace.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libbacktrace.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libbacktrace.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -35,7 +35,7 @@ namespace __sanitizer {\n \n namespace {\n \n-#if SANITIZER_CP_DEMANGLE\n+# if SANITIZER_CP_DEMANGLE\n struct CplusV3DemangleData {\n   char *buf;\n   uptr size, allocated;\n@@ -62,13 +62,13 @@ static void CplusV3DemangleCallback(const char *s, size_t l, void *vdata) {\n }\n }  // extern \"C\"\n \n-char *CplusV3Demangle(const char *name, bool always_alloc) {\n+char *CplusV3Demangle(const char *name) {\n   CplusV3DemangleData data;\n   data.buf = 0;\n   data.size = 0;\n   data.allocated = 0;\n   if (cplus_demangle_v3_callback(name, DMGL_PARAMS | DMGL_ANSI,\n-\t\t\t\t CplusV3DemangleCallback, &data)) {\n+                                 CplusV3DemangleCallback, &data)) {\n     if (data.size + 64 > data.allocated)\n       return data.buf;\n     char *buf = internal_strdup(data.buf);\n@@ -77,17 +77,9 @@ char *CplusV3Demangle(const char *name, bool always_alloc) {\n   }\n   if (data.buf)\n     InternalFree(data.buf);\n-  if (always_alloc)\n-    return internal_strdup(name);\n-  return 0;\n-}\n-#else\n-const char *CplusV3Demangle(const char *name, bool always_alloc) {\n-  if (always_alloc)\n-    return internal_strdup(name);\n   return 0;\n }\n-#endif\n+# endif  // SANITIZER_CP_DEMANGLE\n \n struct SymbolizeCodeData {\n   AddressInfo *frames;\n@@ -107,7 +99,7 @@ static int SymbolizeCodePCInfoCallback(void *vdata, uintptr_t addr,\n     info->Clear();\n     info->FillAddressAndModuleInfo(addr, cdata->module_name,\n                                    cdata->module_offset);\n-    info->function = CplusV3Demangle(function, true);\n+    info->function = LibbacktraceSymbolizer::Demangle(function, true);\n     if (filename)\n       info->file = internal_strdup(filename);\n     info->line = lineno;\n@@ -125,7 +117,7 @@ static void SymbolizeCodeCallback(void *vdata, uintptr_t addr,\n     info->Clear();\n     info->FillAddressAndModuleInfo(addr, cdata->module_name,\n                                    cdata->module_offset);\n-    info->function = CplusV3Demangle(symname, true);\n+    info->function = LibbacktraceSymbolizer::Demangle(symname, true);\n     cdata->n_frames = 1;\n   }\n }\n@@ -134,7 +126,7 @@ static void SymbolizeDataCallback(void *vdata, uintptr_t, const char *symname,\n                                   uintptr_t symval, uintptr_t symsize) {\n   DataInfo *info = (DataInfo *)vdata;\n   if (symname && symval) {\n-    info->name = CplusV3Demangle(symname, true);\n+    info->name = LibbacktraceSymbolizer::Demangle(symname, true);\n     info->start = symval;\n     info->size = symsize;\n   }\n@@ -179,17 +171,6 @@ bool LibbacktraceSymbolizer::SymbolizeData(DataInfo *info) {\n   return true;\n }\n \n-const char *LibbacktraceSymbolizer::Demangle(const char *name) {\n-#if SANITIZER_CP_DEMANGLE\n-  const char *demangled = CplusV3Demangle(name, false);\n-  if (demangled)\n-    return demangled;\n-  return name;\n-#else\n-  return 0;\n-#endif\n-}\n-\n #else  // SANITIZER_LIBBACKTRACE\n \n LibbacktraceSymbolizer *LibbacktraceSymbolizer::get(LowLevelAllocator *alloc) {\n@@ -208,10 +189,16 @@ bool LibbacktraceSymbolizer::SymbolizeData(DataInfo *info) {\n   return false;\n }\n \n-const char *LibbacktraceSymbolizer::Demangle(const char *name) {\n+#endif  // SANITIZER_LIBBACKTRACE\n+\n+char *LibbacktraceSymbolizer::Demangle(const char *name, bool always_alloc) {\n+#if SANITIZER_LIBBACKTRACE && SANITIZER_CP_DEMANGLE\n+  if (char *demangled = CplusV3Demangle(name))\n+    return demangled;\n+#endif\n+  if (always_alloc)\n+    return internal_strdup(name);\n   return 0;\n }\n \n-#endif  // SANITIZER_LIBBACKTRACE\n-\n }  // namespace __sanitizer"}, {"sha": "c7a83bfca921a26d088ebf764546caeeb1a93c61", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_libbacktrace.h", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libbacktrace.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libbacktrace.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libbacktrace.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -1,4 +1,4 @@\n-//===-- sanitizer_symbolizer_libbacktrace.h -------------------------------===//\n+//===-- sanitizer_symbolizer_libbacktrace.h ---------------------*- C++ -*-===//\n //\n // This file is distributed under the University of Illinois Open Source\n // License. See LICENSE.TXT for details.\n@@ -9,6 +9,8 @@\n // run-time libraries.\n // Header for libbacktrace symbolizer.\n //===----------------------------------------------------------------------===//\n+#ifndef SANITIZER_SYMBOLIZER_LIBBACKTRACE_H\n+#define SANITIZER_SYMBOLIZER_LIBBACKTRACE_H\n \n #include \"sanitizer_platform.h\"\n #include \"sanitizer_common.h\"\n@@ -18,6 +20,10 @@\n # define SANITIZER_LIBBACKTRACE 0\n #endif\n \n+#ifndef SANITIZER_CP_DEMANGLE\n+# define SANITIZER_CP_DEMANGLE 0\n+#endif\n+\n namespace __sanitizer {\n \n class LibbacktraceSymbolizer {\n@@ -29,7 +35,8 @@ class LibbacktraceSymbolizer {\n \n   bool SymbolizeData(DataInfo *info);\n \n-  const char *Demangle(const char *name);\n+  // May return NULL if demangling failed.\n+  static char *Demangle(const char *name, bool always_alloc = false);\n \n  private:\n   explicit LibbacktraceSymbolizer(void *state) : state_(state) {}\n@@ -38,3 +45,4 @@ class LibbacktraceSymbolizer {\n };\n \n }  // namespace __sanitizer\n+#endif  // SANITIZER_SYMBOLIZER_LIBBACKTRACE_H"}, {"sha": "161c21b3aad7475e85bd8413939138db1edebe07", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_posix_libcdep.cc", "status": "modified", "additions": 297, "deletions": 159, "changes": 456, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_posix_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_posix_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_posix_libcdep.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -14,6 +14,7 @@\n #if SANITIZER_POSIX\n #include \"sanitizer_allocator_internal.h\"\n #include \"sanitizer_common.h\"\n+#include \"sanitizer_flags.h\"\n #include \"sanitizer_internal_defs.h\"\n #include \"sanitizer_linux.h\"\n #include \"sanitizer_placement_new.h\"\n@@ -52,107 +53,6 @@ static const char *DemangleCXXABI(const char *name) {\n   return name;\n }\n \n-#if defined(__x86_64__)\n-static const char* const kSymbolizerArch = \"--default-arch=x86_64\";\n-#elif defined(__i386__)\n-static const char* const kSymbolizerArch = \"--default-arch=i386\";\n-#elif defined(__powerpc64__)\n-static const char* const kSymbolizerArch = \"--default-arch=powerpc64\";\n-#else\n-static const char* const kSymbolizerArch = \"--default-arch=unknown\";\n-#endif\n-\n-static const int kSymbolizerStartupTimeMillis = 10;\n-\n-// Creates external symbolizer connected via pipe, user should write\n-// to output_fd and read from input_fd.\n-static bool StartSymbolizerSubprocess(const char *path_to_symbolizer,\n-                                      int *input_fd, int *output_fd) {\n-  if (!FileExists(path_to_symbolizer)) {\n-    Report(\"WARNING: invalid path to external symbolizer!\\n\");\n-    return false;\n-  }\n-\n-  int *infd = NULL;\n-  int *outfd = NULL;\n-  // The client program may close its stdin and/or stdout and/or stderr\n-  // thus allowing socketpair to reuse file descriptors 0, 1 or 2.\n-  // In this case the communication between the forked processes may be\n-  // broken if either the parent or the child tries to close or duplicate\n-  // these descriptors. The loop below produces two pairs of file\n-  // descriptors, each greater than 2 (stderr).\n-  int sock_pair[5][2];\n-  for (int i = 0; i < 5; i++) {\n-    if (pipe(sock_pair[i]) == -1) {\n-      for (int j = 0; j < i; j++) {\n-        internal_close(sock_pair[j][0]);\n-        internal_close(sock_pair[j][1]);\n-      }\n-      Report(\"WARNING: Can't create a socket pair to start \"\n-             \"external symbolizer (errno: %d)\\n\", errno);\n-      return false;\n-    } else if (sock_pair[i][0] > 2 && sock_pair[i][1] > 2) {\n-      if (infd == NULL) {\n-        infd = sock_pair[i];\n-      } else {\n-        outfd = sock_pair[i];\n-        for (int j = 0; j < i; j++) {\n-          if (sock_pair[j] == infd) continue;\n-          internal_close(sock_pair[j][0]);\n-          internal_close(sock_pair[j][1]);\n-        }\n-        break;\n-      }\n-    }\n-  }\n-  CHECK(infd);\n-  CHECK(outfd);\n-\n-  int pid = fork();\n-  if (pid == -1) {\n-    // Fork() failed.\n-    internal_close(infd[0]);\n-    internal_close(infd[1]);\n-    internal_close(outfd[0]);\n-    internal_close(outfd[1]);\n-    Report(\"WARNING: failed to fork external symbolizer \"\n-           \" (errno: %d)\\n\", errno);\n-    return false;\n-  } else if (pid == 0) {\n-    // Child subprocess.\n-    internal_close(STDOUT_FILENO);\n-    internal_close(STDIN_FILENO);\n-    internal_dup2(outfd[0], STDIN_FILENO);\n-    internal_dup2(infd[1], STDOUT_FILENO);\n-    internal_close(outfd[0]);\n-    internal_close(outfd[1]);\n-    internal_close(infd[0]);\n-    internal_close(infd[1]);\n-    for (int fd = getdtablesize(); fd > 2; fd--)\n-      internal_close(fd);\n-    execl(path_to_symbolizer, path_to_symbolizer, kSymbolizerArch, (char*)0);\n-    internal__exit(1);\n-  }\n-\n-  // Continue execution in parent process.\n-  internal_close(outfd[0]);\n-  internal_close(infd[1]);\n-  *input_fd = infd[0];\n-  *output_fd = outfd[1];\n-\n-  // Check that symbolizer subprocess started successfully.\n-  int pid_status;\n-  SleepForMillis(kSymbolizerStartupTimeMillis);\n-  int exited_pid = waitpid(pid, &pid_status, WNOHANG);\n-  if (exited_pid != 0) {\n-    // Either waitpid failed, or child has already exited.\n-    Report(\"WARNING: external symbolizer didn't start up correctly!\\n\");\n-    return false;\n-  }\n-\n-  return true;\n-}\n-\n // Extracts the prefix of \"str\" that consists of any characters not\n // present in \"delims\" string, and copies this prefix to \"result\", allocating\n // space for it.\n@@ -192,29 +92,30 @@ static const char *ExtractUptr(const char *str, const char *delims,\n   return ret;\n }\n \n-// ExternalSymbolizer encapsulates communication between the tool and\n-// external symbolizer program, running in a different subprocess,\n-// For now we assume the following protocol:\n-// For each request of the form\n-//   <module_name> <module_offset>\n-// passed to STDIN, external symbolizer prints to STDOUT response:\n-//   <function_name>\n-//   <file_name>:<line_number>:<column_number>\n-//   <function_name>\n-//   <file_name>:<line_number>:<column_number>\n-//   ...\n-//   <empty line>\n-// ExternalSymbolizer may not be used from two threads simultaneously.\n-class ExternalSymbolizer {\n+class ExternalSymbolizerInterface {\n+ public:\n+  // Can't declare pure virtual functions in sanitizer runtimes:\n+  // __cxa_pure_virtual might be unavailable.\n+  virtual char *SendCommand(bool is_data, const char *module_name,\n+                            uptr module_offset) {\n+    UNIMPLEMENTED();\n+  }\n+};\n+\n+// SymbolizerProcess encapsulates communication between the tool and\n+// external symbolizer program, running in a different subprocess.\n+// SymbolizerProcess may not be used from two threads simultaneously.\n+class SymbolizerProcess : public ExternalSymbolizerInterface {\n  public:\n-  explicit ExternalSymbolizer(const char *path)\n+  explicit SymbolizerProcess(const char *path)\n       : path_(path),\n         input_fd_(kInvalidFd),\n         output_fd_(kInvalidFd),\n         times_restarted_(0),\n-        failed_to_start_(false) {\n+        failed_to_start_(false),\n+        reported_invalid_path_(false) {\n     CHECK(path_);\n-    CHECK_NE(path[0], '\\0');\n+    CHECK_NE(path_[0], '\\0');\n   }\n \n   char *SendCommand(bool is_data, const char *module_name, uptr module_offset) {\n@@ -231,25 +132,23 @@ class ExternalSymbolizer {\n     return 0;\n   }\n \n-  void Flush() {\n-  }\n-\n  private:\n   bool Restart() {\n     if (input_fd_ != kInvalidFd)\n       internal_close(input_fd_);\n     if (output_fd_ != kInvalidFd)\n       internal_close(output_fd_);\n-    return StartSymbolizerSubprocess(path_, &input_fd_, &output_fd_);\n+    return StartSymbolizerSubprocess();\n   }\n \n   char *SendCommandImpl(bool is_data, const char *module_name,\n                         uptr module_offset) {\n     if (input_fd_ == kInvalidFd || output_fd_ == kInvalidFd)\n       return 0;\n     CHECK(module_name);\n-    internal_snprintf(buffer_, kBufferSize, \"%s\\\"%s\\\" 0x%zx\\n\",\n-                      is_data ? \"DATA \" : \"\", module_name, module_offset);\n+    if (!RenderInputCommand(buffer_, kBufferSize, is_data, module_name,\n+                            module_offset))\n+      return 0;\n     if (!writeToSymbolizer(buffer_, internal_strlen(buffer_)))\n       return 0;\n     if (!readFromSymbolizer(buffer_, kBufferSize))\n@@ -263,20 +162,18 @@ class ExternalSymbolizer {\n     uptr read_len = 0;\n     while (true) {\n       uptr just_read = internal_read(input_fd_, buffer + read_len,\n-                                     max_length - read_len);\n+                                     max_length - read_len - 1);\n       // We can't read 0 bytes, as we don't expect external symbolizer to close\n       // its stdout.\n       if (just_read == 0 || just_read == (uptr)-1) {\n         Report(\"WARNING: Can't read from symbolizer at fd %d\\n\", input_fd_);\n         return false;\n       }\n       read_len += just_read;\n-      // Empty line marks the end of symbolizer output.\n-      if (read_len >= 2 && buffer[read_len - 1] == '\\n' &&\n-                           buffer[read_len - 2] == '\\n') {\n+      if (ReachedEndOfOutput(buffer, read_len))\n         break;\n-      }\n     }\n+    buffer[read_len] = '\\0';\n     return true;\n   }\n \n@@ -291,6 +188,110 @@ class ExternalSymbolizer {\n     return true;\n   }\n \n+  bool StartSymbolizerSubprocess() {\n+    if (!FileExists(path_)) {\n+      if (!reported_invalid_path_) {\n+        Report(\"WARNING: invalid path to external symbolizer!\\n\");\n+        reported_invalid_path_ = true;\n+      }\n+      return false;\n+    }\n+\n+    int *infd = NULL;\n+    int *outfd = NULL;\n+    // The client program may close its stdin and/or stdout and/or stderr\n+    // thus allowing socketpair to reuse file descriptors 0, 1 or 2.\n+    // In this case the communication between the forked processes may be\n+    // broken if either the parent or the child tries to close or duplicate\n+    // these descriptors. The loop below produces two pairs of file\n+    // descriptors, each greater than 2 (stderr).\n+    int sock_pair[5][2];\n+    for (int i = 0; i < 5; i++) {\n+      if (pipe(sock_pair[i]) == -1) {\n+        for (int j = 0; j < i; j++) {\n+          internal_close(sock_pair[j][0]);\n+          internal_close(sock_pair[j][1]);\n+        }\n+        Report(\"WARNING: Can't create a socket pair to start \"\n+               \"external symbolizer (errno: %d)\\n\", errno);\n+        return false;\n+      } else if (sock_pair[i][0] > 2 && sock_pair[i][1] > 2) {\n+        if (infd == NULL) {\n+          infd = sock_pair[i];\n+        } else {\n+          outfd = sock_pair[i];\n+          for (int j = 0; j < i; j++) {\n+            if (sock_pair[j] == infd) continue;\n+            internal_close(sock_pair[j][0]);\n+            internal_close(sock_pair[j][1]);\n+          }\n+          break;\n+        }\n+      }\n+    }\n+    CHECK(infd);\n+    CHECK(outfd);\n+\n+    // Real fork() may call user callbacks registered with pthread_atfork().\n+    int pid = internal_fork();\n+    if (pid == -1) {\n+      // Fork() failed.\n+      internal_close(infd[0]);\n+      internal_close(infd[1]);\n+      internal_close(outfd[0]);\n+      internal_close(outfd[1]);\n+      Report(\"WARNING: failed to fork external symbolizer \"\n+             \" (errno: %d)\\n\", errno);\n+      return false;\n+    } else if (pid == 0) {\n+      // Child subprocess.\n+      internal_close(STDOUT_FILENO);\n+      internal_close(STDIN_FILENO);\n+      internal_dup2(outfd[0], STDIN_FILENO);\n+      internal_dup2(infd[1], STDOUT_FILENO);\n+      internal_close(outfd[0]);\n+      internal_close(outfd[1]);\n+      internal_close(infd[0]);\n+      internal_close(infd[1]);\n+      for (int fd = getdtablesize(); fd > 2; fd--)\n+        internal_close(fd);\n+      ExecuteWithDefaultArgs(path_);\n+      internal__exit(1);\n+    }\n+\n+    // Continue execution in parent process.\n+    internal_close(outfd[0]);\n+    internal_close(infd[1]);\n+    input_fd_ = infd[0];\n+    output_fd_ = outfd[1];\n+\n+    // Check that symbolizer subprocess started successfully.\n+    int pid_status;\n+    SleepForMillis(kSymbolizerStartupTimeMillis);\n+    int exited_pid = waitpid(pid, &pid_status, WNOHANG);\n+    if (exited_pid != 0) {\n+      // Either waitpid failed, or child has already exited.\n+      Report(\"WARNING: external symbolizer didn't start up correctly!\\n\");\n+      return false;\n+    }\n+\n+    return true;\n+  }\n+\n+  virtual bool RenderInputCommand(char *buffer, uptr max_length, bool is_data,\n+                                  const char *module_name,\n+                                  uptr module_offset) const {\n+    UNIMPLEMENTED();\n+  }\n+\n+  virtual bool ReachedEndOfOutput(const char *buffer, uptr length) const {\n+    UNIMPLEMENTED();\n+  }\n+\n+  virtual void ExecuteWithDefaultArgs(const char *path_to_binary) const {\n+    UNIMPLEMENTED();\n+  }\n+\n   const char *path_;\n   int input_fd_;\n   int output_fd_;\n@@ -299,8 +300,120 @@ class ExternalSymbolizer {\n   char buffer_[kBufferSize];\n \n   static const uptr kMaxTimesRestarted = 5;\n+  static const int kSymbolizerStartupTimeMillis = 10;\n   uptr times_restarted_;\n   bool failed_to_start_;\n+  bool reported_invalid_path_;\n+};\n+\n+// For now we assume the following protocol:\n+// For each request of the form\n+//   <module_name> <module_offset>\n+// passed to STDIN, external symbolizer prints to STDOUT response:\n+//   <function_name>\n+//   <file_name>:<line_number>:<column_number>\n+//   <function_name>\n+//   <file_name>:<line_number>:<column_number>\n+//   ...\n+//   <empty line>\n+class LLVMSymbolizerProcess : public SymbolizerProcess {\n+ public:\n+  explicit LLVMSymbolizerProcess(const char *path) : SymbolizerProcess(path) {}\n+\n+ private:\n+  bool RenderInputCommand(char *buffer, uptr max_length, bool is_data,\n+                          const char *module_name, uptr module_offset) const {\n+    internal_snprintf(buffer, max_length, \"%s\\\"%s\\\" 0x%zx\\n\",\n+                      is_data ? \"DATA \" : \"\", module_name, module_offset);\n+    return true;\n+  }\n+\n+  bool ReachedEndOfOutput(const char *buffer, uptr length) const {\n+    // Empty line marks the end of llvm-symbolizer output.\n+    return length >= 2 && buffer[length - 1] == '\\n' &&\n+           buffer[length - 2] == '\\n';\n+  }\n+\n+  void ExecuteWithDefaultArgs(const char *path_to_binary) const {\n+#if defined(__x86_64__)\n+    const char* const kSymbolizerArch = \"--default-arch=x86_64\";\n+#elif defined(__i386__)\n+    const char* const kSymbolizerArch = \"--default-arch=i386\";\n+#elif defined(__powerpc64__)\n+    const char* const kSymbolizerArch = \"--default-arch=powerpc64\";\n+#else\n+    const char* const kSymbolizerArch = \"--default-arch=unknown\";\n+#endif\n+    execl(path_to_binary, path_to_binary, kSymbolizerArch, (char *)0);\n+  }\n+};\n+\n+class Addr2LineProcess : public SymbolizerProcess {\n+ public:\n+  Addr2LineProcess(const char *path, const char *module_name)\n+      : SymbolizerProcess(path), module_name_(internal_strdup(module_name)) {}\n+\n+  const char *module_name() const { return module_name_; }\n+\n+ private:\n+  bool RenderInputCommand(char *buffer, uptr max_length, bool is_data,\n+                          const char *module_name, uptr module_offset) const {\n+    if (is_data)\n+      return false;\n+    CHECK_EQ(0, internal_strcmp(module_name, module_name_));\n+    internal_snprintf(buffer, max_length, \"0x%zx\\n\", module_offset);\n+    return true;\n+  }\n+\n+  bool ReachedEndOfOutput(const char *buffer, uptr length) const {\n+    // Output should consist of two lines.\n+    int num_lines = 0;\n+    for (uptr i = 0; i < length; ++i) {\n+      if (buffer[i] == '\\n')\n+        num_lines++;\n+      if (num_lines >= 2)\n+        return true;\n+    }\n+    return false;\n+  }\n+\n+  void ExecuteWithDefaultArgs(const char *path_to_binary) const {\n+    execl(path_to_binary, path_to_binary, \"-Cfe\", module_name_, (char *)0);\n+  }\n+\n+  const char *module_name_;  // Owned, leaked.\n+};\n+\n+class Addr2LinePool : public ExternalSymbolizerInterface {\n+ public:\n+  explicit Addr2LinePool(const char *addr2line_path,\n+                         LowLevelAllocator *allocator)\n+      : addr2line_path_(addr2line_path), allocator_(allocator),\n+        addr2line_pool_(16) {}\n+\n+  char *SendCommand(bool is_data, const char *module_name, uptr module_offset) {\n+    if (is_data)\n+      return 0;\n+    Addr2LineProcess *addr2line = 0;\n+    for (uptr i = 0; i < addr2line_pool_.size(); ++i) {\n+      if (0 ==\n+          internal_strcmp(module_name, addr2line_pool_[i]->module_name())) {\n+        addr2line = addr2line_pool_[i];\n+        break;\n+      }\n+    }\n+    if (!addr2line) {\n+      addr2line =\n+          new(*allocator_) Addr2LineProcess(addr2line_path_, module_name);\n+      addr2line_pool_.push_back(addr2line);\n+    }\n+    return addr2line->SendCommand(is_data, module_name, module_offset);\n+  }\n+\n+ private:\n+  const char *addr2line_path_;\n+  LowLevelAllocator *allocator_;\n+  InternalMmapVector<Addr2LineProcess*> addr2line_pool_;\n };\n \n #if SANITIZER_SUPPORTS_WEAK_HOOKS\n@@ -384,23 +497,22 @@ class InternalSymbolizer {\n \n class POSIXSymbolizer : public Symbolizer {\n  public:\n-  POSIXSymbolizer(ExternalSymbolizer *external_symbolizer,\n+  POSIXSymbolizer(ExternalSymbolizerInterface *external_symbolizer,\n                   InternalSymbolizer *internal_symbolizer,\n                   LibbacktraceSymbolizer *libbacktrace_symbolizer)\n       : Symbolizer(),\n         external_symbolizer_(external_symbolizer),\n         internal_symbolizer_(internal_symbolizer),\n         libbacktrace_symbolizer_(libbacktrace_symbolizer) {}\n \n-  uptr SymbolizeCode(uptr addr, AddressInfo *frames, uptr max_frames) {\n+  uptr SymbolizePC(uptr addr, AddressInfo *frames, uptr max_frames) {\n     BlockingMutexLock l(&mu_);\n     if (max_frames == 0)\n       return 0;\n-    LoadedModule *module = FindModuleForAddress(addr);\n-    if (module == 0)\n+    const char *module_name;\n+    uptr module_offset;\n+    if (!FindModuleNameAndOffsetForAddress(addr, &module_name, &module_offset))\n       return 0;\n-    const char *module_name = module->full_name();\n-    uptr module_offset = addr - module->base_address();\n     // First, try to use libbacktrace symbolizer (if it's available).\n     if (libbacktrace_symbolizer_ != 0) {\n       mu_.CheckLocked();\n@@ -472,6 +584,7 @@ class POSIXSymbolizer : public Symbolizer {\n     info->address = addr;\n     info->module = internal_strdup(module_name);\n     info->module_offset = module_offset;\n+    // First, try to use libbacktrace symbolizer (if it's available).\n     if (libbacktrace_symbolizer_ != 0) {\n       mu_.CheckLocked();\n       if (libbacktrace_symbolizer_->SymbolizeData(info))\n@@ -487,13 +600,15 @@ class POSIXSymbolizer : public Symbolizer {\n     return true;\n   }\n \n-  bool IsAvailable() {\n-    return internal_symbolizer_ != 0 || external_symbolizer_ != 0 ||\n-        libbacktrace_symbolizer_ != 0;\n+  bool GetModuleNameAndOffsetForPC(uptr pc, const char **module_name,\n+                                   uptr *module_address) {\n+    BlockingMutexLock l(&mu_);\n+    return FindModuleNameAndOffsetForAddress(pc, module_name, module_address);\n   }\n \n-  bool IsExternalAvailable() {\n-    return external_symbolizer_ != 0;\n+  bool CanReturnFileLineInfo() {\n+    return internal_symbolizer_ != 0 || external_symbolizer_ != 0 ||\n+           libbacktrace_symbolizer_ != 0;\n   }\n \n   void Flush() {\n@@ -502,22 +617,20 @@ class POSIXSymbolizer : public Symbolizer {\n       SymbolizerScope sym_scope(this);\n       internal_symbolizer_->Flush();\n     }\n-    if (external_symbolizer_ != 0)\n-      external_symbolizer_->Flush();\n   }\n \n   const char *Demangle(const char *name) {\n     BlockingMutexLock l(&mu_);\n     // Run hooks even if we don't use internal symbolizer, as cxxabi\n     // demangle may call system functions.\n     SymbolizerScope sym_scope(this);\n-    if (internal_symbolizer_ != 0)\n-      return internal_symbolizer_->Demangle(name);\n+    // Try to use libbacktrace demangler (if available).\n     if (libbacktrace_symbolizer_ != 0) {\n-      const char *demangled = libbacktrace_symbolizer_->Demangle(name);\n-      if (demangled)\n-\treturn demangled;\n+      if (const char *demangled = libbacktrace_symbolizer_->Demangle(name))\n+        return demangled;\n     }\n+    if (internal_symbolizer_ != 0)\n+      return internal_symbolizer_->Demangle(name);\n     return DemangleCXXABI(name);\n   }\n \n@@ -540,6 +653,7 @@ class POSIXSymbolizer : public Symbolizer {\n     }\n     // Otherwise, fall back to external symbolizer.\n     if (external_symbolizer_) {\n+      SymbolizerScope sym_scope(this);\n       return external_symbolizer_->SendCommand(is_data, module_name,\n                                                module_offset);\n     }\n@@ -555,8 +669,7 @@ class POSIXSymbolizer : public Symbolizer {\n       CHECK(modules_);\n       n_modules_ = GetListOfModules(modules_, kMaxNumberOfModuleContexts,\n                                     /* filter */ 0);\n-      // FIXME: Return this check when GetListOfModules is implemented on Mac.\n-      // CHECK_GT(n_modules_, 0);\n+      CHECK_GT(n_modules_, 0);\n       CHECK_LT(n_modules_, kMaxNumberOfModuleContexts);\n       modules_fresh_ = true;\n       modules_were_reloaded = true;\n@@ -577,6 +690,17 @@ class POSIXSymbolizer : public Symbolizer {\n     return 0;\n   }\n \n+  bool FindModuleNameAndOffsetForAddress(uptr address, const char **module_name,\n+                                         uptr *module_offset) {\n+    mu_.CheckLocked();\n+    LoadedModule *module = FindModuleForAddress(address);\n+    if (module == 0)\n+      return false;\n+    *module_name = module->full_name();\n+    *module_offset = address - module->base_address();\n+    return true;\n+  }\n+\n   // 16K loaded modules should be enough for everyone.\n   static const uptr kMaxNumberOfModuleContexts = 1 << 14;\n   LoadedModule *modules_;  // Array of module descriptions is leaked.\n@@ -585,27 +709,41 @@ class POSIXSymbolizer : public Symbolizer {\n   bool modules_fresh_;\n   BlockingMutex mu_;\n \n-  ExternalSymbolizer *external_symbolizer_;        // Leaked.\n-  InternalSymbolizer *const internal_symbolizer_;  // Leaked.\n-  LibbacktraceSymbolizer *libbacktrace_symbolizer_;  // Leaked.\n+  ExternalSymbolizerInterface *external_symbolizer_;  // Leaked.\n+  InternalSymbolizer *const internal_symbolizer_;     // Leaked.\n+  LibbacktraceSymbolizer *libbacktrace_symbolizer_;   // Leaked.\n };\n \n Symbolizer *Symbolizer::PlatformInit(const char *path_to_external) {\n+  if (!common_flags()->symbolize) {\n+    return new(symbolizer_allocator_) POSIXSymbolizer(0, 0, 0);\n+  }\n   InternalSymbolizer* internal_symbolizer =\n       InternalSymbolizer::get(&symbolizer_allocator_);\n-  ExternalSymbolizer *external_symbolizer = 0;\n+  ExternalSymbolizerInterface *external_symbolizer = 0;\n   LibbacktraceSymbolizer *libbacktrace_symbolizer = 0;\n \n   if (!internal_symbolizer) {\n     libbacktrace_symbolizer =\n         LibbacktraceSymbolizer::get(&symbolizer_allocator_);\n     if (!libbacktrace_symbolizer) {\n-      // Find path to llvm-symbolizer if it's not provided.\n-      if (!path_to_external)\n-        path_to_external = FindPathToBinary(\"llvm-symbolizer\");\n-      if (path_to_external && path_to_external[0] != '\\0')\n-        external_symbolizer = new(symbolizer_allocator_)\n-            ExternalSymbolizer(path_to_external);\n+      if (path_to_external && path_to_external[0] == '\\0') {\n+        // External symbolizer is explicitly disabled. Do nothing.\n+      } else {\n+        // Find path to llvm-symbolizer if it's not provided.\n+        if (!path_to_external)\n+          path_to_external = FindPathToBinary(\"llvm-symbolizer\");\n+        if (path_to_external) {\n+          external_symbolizer = new(symbolizer_allocator_)\n+              LLVMSymbolizerProcess(path_to_external);\n+        } else if (common_flags()->allow_addr2line) {\n+          // If llvm-symbolizer is not found, try to use addr2line.\n+          if (const char *addr2line_path = FindPathToBinary(\"addr2line\")) {\n+            external_symbolizer = new(symbolizer_allocator_)\n+                Addr2LinePool(addr2line_path, &symbolizer_allocator_);\n+          }\n+        }\n+      }\n     }\n   }\n "}, {"sha": "c014c6af42bd90e7d4a7ff36df69e60bfc7610ef", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_win.cc", "status": "modified", "additions": 86, "deletions": 1, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_win.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_win.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_win.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -12,11 +12,96 @@\n \n #include \"sanitizer_platform.h\"\n #if SANITIZER_WINDOWS\n+#include <windows.h>\n+#include <dbghelp.h>\n+#pragma comment(lib, \"dbghelp.lib\")\n+\n #include \"sanitizer_symbolizer.h\"\n \n namespace __sanitizer {\n \n-Symbolizer *Symbolizer::PlatformInit(const char *path_to_external) { return 0; }\n+class WinSymbolizer : public Symbolizer {\n+ public:\n+  WinSymbolizer() : initialized_(false) {}\n+\n+  uptr SymbolizePC(uptr addr, AddressInfo *frames, uptr max_frames) {\n+    if (max_frames == 0)\n+      return 0;\n+\n+    BlockingMutexLock l(&dbghelp_mu_);\n+    if (!initialized_) {\n+      SymSetOptions(SYMOPT_DEFERRED_LOADS |\n+                    SYMOPT_UNDNAME |\n+                    SYMOPT_LOAD_LINES);\n+      CHECK(SymInitialize(GetCurrentProcess(), 0, TRUE));\n+      // FIXME: We don't call SymCleanup() on exit yet - should we?\n+      initialized_ = true;\n+    }\n+\n+    // See http://msdn.microsoft.com/en-us/library/ms680578(VS.85).aspx\n+    char buffer[sizeof(SYMBOL_INFO) + MAX_SYM_NAME * sizeof(CHAR)];\n+    PSYMBOL_INFO symbol = (PSYMBOL_INFO)buffer;\n+    symbol->SizeOfStruct = sizeof(SYMBOL_INFO);\n+    symbol->MaxNameLen = MAX_SYM_NAME;\n+    DWORD64 offset = 0;\n+    BOOL got_objname = SymFromAddr(GetCurrentProcess(),\n+                                   (DWORD64)addr, &offset, symbol);\n+    if (!got_objname)\n+      return 0;\n+\n+    DWORD unused;\n+    IMAGEHLP_LINE64 line_info;\n+    line_info.SizeOfStruct = sizeof(IMAGEHLP_LINE64);\n+    BOOL got_fileline = SymGetLineFromAddr64(GetCurrentProcess(), (DWORD64)addr,\n+                                             &unused, &line_info);\n+    AddressInfo *info = &frames[0];\n+    info->Clear();\n+    info->function = internal_strdup(symbol->Name);\n+    info->function_offset = (uptr)offset;\n+    if (got_fileline) {\n+      info->file = internal_strdup(line_info.FileName);\n+      info->line = line_info.LineNumber;\n+    }\n+\n+    IMAGEHLP_MODULE64 mod_info;\n+    internal_memset(&mod_info, 0, sizeof(mod_info));\n+    mod_info.SizeOfStruct = sizeof(mod_info);\n+    if (SymGetModuleInfo64(GetCurrentProcess(), addr, &mod_info))\n+      info->FillAddressAndModuleInfo(addr, mod_info.ImageName,\n+                                     addr - (uptr)mod_info.BaseOfImage);\n+    return 1;\n+  }\n+\n+  bool CanReturnFileLineInfo() {\n+    return true;\n+  }\n+\n+  const char *Demangle(const char *name) {\n+    CHECK(initialized_);\n+    static char demangle_buffer[1000];\n+    if (name[0] == '\\01' &&\n+        UnDecorateSymbolName(name + 1, demangle_buffer, sizeof(demangle_buffer),\n+                             UNDNAME_NAME_ONLY))\n+      return demangle_buffer;\n+    else\n+      return name;\n+  }\n+\n+  // FIXME: Implement GetModuleNameAndOffsetForPC().\n+\n+ private:\n+  // All DbgHelp functions are single threaded, so we should use a mutex to\n+  // serialize accesses.\n+  BlockingMutex dbghelp_mu_;\n+  bool initialized_;\n+};\n+\n+Symbolizer *Symbolizer::PlatformInit(const char *path_to_external) {\n+  static bool called_once = false;\n+  CHECK(!called_once && \"Shouldn't create more than one symbolizer\");\n+  called_once = true;\n+  return new(symbolizer_allocator_) WinSymbolizer();\n+}\n \n }  // namespace __sanitizer\n "}, {"sha": "7667b753a8b189b0f2bf243616f31f372f333864", "filename": "libsanitizer/sanitizer_common/sanitizer_syscall_generic.inc", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscall_generic.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscall_generic.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscall_generic.inc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -9,7 +9,17 @@\n //\n //===----------------------------------------------------------------------===//\n \n-#define internal_syscall syscall\n+#if SANITIZER_FREEBSD\n+# define SYSCALL(name) SYS_ ## name\n+#else\n+# define SYSCALL(name) __NR_ ## name\n+#endif\n+\n+#if SANITIZER_FREEBSD && defined(__x86_64__)\n+# define internal_syscall __syscall\n+# else\n+# define internal_syscall syscall\n+#endif\n \n bool internal_iserror(uptr retval, int *rverrno) {\n   if (retval == (uptr)-1) {"}, {"sha": "b610d66be4ff5a0c1c8ee85ac82ec315deb3c240", "filename": "libsanitizer/sanitizer_common/sanitizer_syscall_linux_x86_64.inc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscall_linux_x86_64.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscall_linux_x86_64.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscall_linux_x86_64.inc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -9,6 +9,8 @@\n //\n //===----------------------------------------------------------------------===//\n \n+#define SYSCALL(name) __NR_ ## name\n+\n static uptr internal_syscall(u64 nr) {\n   u64 retval;\n   asm volatile(\"syscall\" : \"=a\"(retval) : \"a\"(nr) : \"rcx\", \"r11\","}, {"sha": "0ad47561b8b1d749ea65c2da15a08b917e5e888e", "filename": "libsanitizer/sanitizer_common/sanitizer_thread_registry.cc", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_thread_registry.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_thread_registry.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_thread_registry.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -15,8 +15,9 @@\n namespace __sanitizer {\n \n ThreadContextBase::ThreadContextBase(u32 tid)\n-    : tid(tid), unique_id(0), os_id(0), user_id(0), status(ThreadStatusInvalid),\n-      detached(false), reuse_count(0), parent_tid(0), next(0) {\n+    : tid(tid), unique_id(0), reuse_count(), os_id(0), user_id(0),\n+      status(ThreadStatusInvalid),\n+      detached(false), parent_tid(0), next(0) {\n   name[0] = '\\0';\n }\n \n@@ -76,7 +77,6 @@ void ThreadContextBase::SetCreated(uptr _user_id, u64 _unique_id,\n \n void ThreadContextBase::Reset() {\n   status = ThreadStatusInvalid;\n-  reuse_count++;\n   SetName(0);\n   OnReset();\n }\n@@ -86,10 +86,11 @@ void ThreadContextBase::Reset() {\n const u32 ThreadRegistry::kUnknownTid = ~0U;\n \n ThreadRegistry::ThreadRegistry(ThreadContextFactory factory, u32 max_threads,\n-                               u32 thread_quarantine_size)\n+                               u32 thread_quarantine_size, u32 max_reuse)\n     : context_factory_(factory),\n       max_threads_(max_threads),\n       thread_quarantine_size_(thread_quarantine_size),\n+      max_reuse_(max_reuse),\n       mtx_(),\n       n_contexts_(0),\n       total_threads_(0),\n@@ -128,8 +129,13 @@ u32 ThreadRegistry::CreateThread(uptr user_id, bool detached, u32 parent_tid,\n     tctx = context_factory_(tid);\n     threads_[tid] = tctx;\n   } else {\n+#ifndef SANITIZER_GO\n     Report(\"%s: Thread limit (%u threads) exceeded. Dying.\\n\",\n            SanitizerToolName, max_threads_);\n+#else\n+    Printf(\"race: limit on %u simultaneously alive goroutines is exceeded,\"\n+        \" dying\\n\", max_threads_);\n+#endif\n     Die();\n   }\n   CHECK_NE(tctx, 0);\n@@ -275,6 +281,9 @@ void ThreadRegistry::QuarantinePush(ThreadContextBase *tctx) {\n   dead_threads_.pop_front();\n   CHECK_EQ(tctx->status, ThreadStatusDead);\n   tctx->Reset();\n+  tctx->reuse_count++;\n+  if (max_reuse_ > 0 && tctx->reuse_count >= max_reuse_)\n+    return;\n   invalid_threads_.push_back(tctx);\n }\n "}, {"sha": "2d7f9e90e0d8c1db371c8da05adac0de8871eb64", "filename": "libsanitizer/sanitizer_common/sanitizer_thread_registry.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_thread_registry.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_thread_registry.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_thread_registry.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -36,13 +36,13 @@ class ThreadContextBase {\n \n   const u32 tid;  // Thread ID. Main thread should have tid = 0.\n   u64 unique_id;  // Unique thread ID.\n+  u32 reuse_count;  // Number of times this tid was reused.\n   uptr os_id;     // PID (used for reporting).\n   uptr user_id;   // Some opaque user thread id (e.g. pthread_t).\n   char name[64];  // As annotated by user.\n \n   ThreadStatus status;\n   bool detached;\n-  int reuse_count;\n \n   u32 parent_tid;\n   ThreadContextBase *next;  // For storing thread contexts in a list.\n@@ -75,7 +75,7 @@ class ThreadRegistry {\n   static const u32 kUnknownTid;\n \n   ThreadRegistry(ThreadContextFactory factory, u32 max_threads,\n-                 u32 thread_quarantine_size);\n+                 u32 thread_quarantine_size, u32 max_reuse = 0);\n   void GetNumberOfThreads(uptr *total = 0, uptr *running = 0, uptr *alive = 0);\n   uptr GetMaxAliveThreads();\n \n@@ -117,6 +117,7 @@ class ThreadRegistry {\n   const ThreadContextFactory context_factory_;\n   const u32 max_threads_;\n   const u32 thread_quarantine_size_;\n+  const u32 max_reuse_;\n \n   BlockingMutex mtx_;\n "}, {"sha": "1d6170f9157cbd7366c902f80089a5cac5e36c77", "filename": "libsanitizer/sanitizer_common/sanitizer_tls_get_addr.cc", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_tls_get_addr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_tls_get_addr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_tls_get_addr.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -0,0 +1,129 @@\n+//===-- sanitizer_tls_get_addr.cc -----------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Handle the __tls_get_addr call.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_tls_get_addr.h\"\n+\n+#include \"sanitizer_flags.h\"\n+#include \"sanitizer_platform_interceptors.h\"\n+\n+namespace __sanitizer {\n+#if SANITIZER_INTERCEPT_TLS_GET_ADDR\n+\n+// The actual parameter that comes to __tls_get_addr\n+// is a pointer to a struct with two words in it:\n+struct TlsGetAddrParam {\n+  uptr dso_id;\n+  uptr offset;\n+};\n+\n+// Glibc starting from 2.19 allocates tls using __signal_safe_memalign,\n+// which has such header.\n+struct Glibc_2_19_tls_header {\n+  uptr size;\n+  uptr start;\n+};\n+\n+// This must be static TLS\n+__attribute__((tls_model(\"initial-exec\")))\n+static __thread DTLS dtls;\n+\n+// Make sure we properly destroy the DTLS objects:\n+// this counter should never get too large.\n+static atomic_uintptr_t number_of_live_dtls;\n+\n+static const uptr kDestroyedThread = -1;\n+\n+static inline void DTLS_Deallocate(DTLS::DTV *dtv, uptr size) {\n+  if (!size) return;\n+  VPrintf(2, \"__tls_get_addr: DTLS_Deallocate %p %zd\\n\", dtv, size);\n+  UnmapOrDie(dtv, size * sizeof(DTLS::DTV));\n+  atomic_fetch_sub(&number_of_live_dtls, 1, memory_order_relaxed);\n+}\n+\n+static inline void DTLS_Resize(uptr new_size) {\n+  if (dtls.dtv_size >= new_size) return;\n+  new_size = RoundUpToPowerOfTwo(new_size);\n+  new_size = Max(new_size, 4096UL / sizeof(DTLS::DTV));\n+  DTLS::DTV *new_dtv =\n+      (DTLS::DTV *)MmapOrDie(new_size * sizeof(DTLS::DTV), \"DTLS_Resize\");\n+  uptr num_live_dtls =\n+      atomic_fetch_add(&number_of_live_dtls, 1, memory_order_relaxed);\n+  VPrintf(2, \"__tls_get_addr: DTLS_Resize %p %zd\\n\", &dtls, num_live_dtls);\n+  CHECK_LT(num_live_dtls, 1 << 20);\n+  uptr old_dtv_size = dtls.dtv_size;\n+  DTLS::DTV *old_dtv = dtls.dtv;\n+  if (old_dtv_size)\n+    internal_memcpy(new_dtv, dtls.dtv, dtls.dtv_size * sizeof(DTLS::DTV));\n+  dtls.dtv = new_dtv;\n+  dtls.dtv_size = new_size;\n+  if (old_dtv_size)\n+    DTLS_Deallocate(old_dtv, old_dtv_size);\n+}\n+\n+void DTLS_Destroy() {\n+  if (!common_flags()->intercept_tls_get_addr) return;\n+  VPrintf(2, \"__tls_get_addr: DTLS_Destroy %p %zd\\n\", &dtls, dtls.dtv_size);\n+  uptr s = dtls.dtv_size;\n+  dtls.dtv_size = kDestroyedThread;  // Do this before unmap for AS-safety.\n+  DTLS_Deallocate(dtls.dtv, s);\n+}\n+\n+void DTLS_on_tls_get_addr(void *arg_void, void *res) {\n+  if (!common_flags()->intercept_tls_get_addr) return;\n+  TlsGetAddrParam *arg = reinterpret_cast<TlsGetAddrParam *>(arg_void);\n+  uptr dso_id = arg->dso_id;\n+  if (dtls.dtv_size == kDestroyedThread) return;\n+  DTLS_Resize(dso_id + 1);\n+  if (dtls.dtv[dso_id].beg)\n+    return;\n+  uptr tls_size = 0;\n+  uptr tls_beg = reinterpret_cast<uptr>(res) - arg->offset;\n+  VPrintf(2, \"__tls_get_addr: %p {%p,%p} => %p; tls_beg: %p; sp: %p \"\n+             \"num_live_dtls %zd\\n\",\n+          arg, arg->dso_id, arg->offset, res, tls_beg, &tls_beg,\n+          atomic_load(&number_of_live_dtls, memory_order_relaxed));\n+  if (dtls.last_memalign_ptr == tls_beg) {\n+    tls_size = dtls.last_memalign_size;\n+    VPrintf(2, \"__tls_get_addr: glibc <=2.18 suspected; tls={%p,%p}\\n\",\n+        tls_beg, tls_size);\n+  } else if ((tls_beg % 4096) == sizeof(Glibc_2_19_tls_header)) {\n+    // We may want to check gnu_get_libc_version().\n+    Glibc_2_19_tls_header *header = (Glibc_2_19_tls_header *)tls_beg - 1;\n+    tls_size = header->size;\n+    tls_beg = header->start;\n+    VPrintf(2, \"__tls_get_addr: glibc >=2.19 suspected; tls={%p %p}\\n\",\n+        tls_beg, tls_size);\n+  } else {\n+    VPrintf(2, \"__tls_get_addr: Can't guess glibc version\\n\");\n+    // This may happen inside the DTOR of main thread, so just ignore it.\n+    tls_size = 0;\n+  }\n+  dtls.dtv[dso_id].beg = tls_beg;\n+  dtls.dtv[dso_id].size = tls_size;\n+}\n+\n+void DTLS_on_libc_memalign(void *ptr, uptr size) {\n+  if (!common_flags()->intercept_tls_get_addr) return;\n+  VPrintf(2, \"DTLS_on_libc_memalign: %p %p\\n\", ptr, size);\n+  dtls.last_memalign_ptr = reinterpret_cast<uptr>(ptr);\n+  dtls.last_memalign_size = size;\n+}\n+\n+DTLS *DTLS_Get() { return &dtls; }\n+\n+#else\n+void DTLS_on_libc_memalign(void *ptr, uptr size) {}\n+void DTLS_on_tls_get_addr(void *arg, void *res) {}\n+DTLS *DTLS_Get() { return 0; }\n+void DTLS_Destroy() {}\n+#endif  // SANITIZER_INTERCEPT_TLS_GET_ADDR\n+\n+}  // namespace __sanitizer"}, {"sha": "22a5e1c41c21bf9e119681df16def76debb98408", "filename": "libsanitizer/sanitizer_common/sanitizer_tls_get_addr.h", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_tls_get_addr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_tls_get_addr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_tls_get_addr.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -0,0 +1,56 @@\n+//===-- sanitizer_tls_get_addr.h --------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Handle the __tls_get_addr call.\n+//\n+// All this magic is specific to glibc and is required to workaround\n+// the lack of interface that would tell us about the Dynamic TLS (DTLS).\n+// https://sourceware.org/bugzilla/show_bug.cgi?id=16291\n+//\n+// The matters get worse because the glibc implementation changed between\n+// 2.18 and 2.19:\n+// https://groups.google.com/forum/#!topic/address-sanitizer/BfwYD8HMxTM\n+//\n+// Before 2.19, every DTLS chunk is allocated with __libc_memalign,\n+// which we intercept and thus know where is the DTLS.\n+// Since 2.19, DTLS chunks are allocated with __signal_safe_memalign,\n+// which is an internal function that wraps a mmap call, neither of which\n+// we can intercept. Luckily, __signal_safe_memalign has a simple parseable\n+// header which we can use.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef SANITIZER_TLS_GET_ADDR_H\n+#define SANITIZER_TLS_GET_ADDR_H\n+\n+#include \"sanitizer_common.h\"\n+\n+namespace __sanitizer {\n+\n+struct DTLS {\n+  // Array of DTLS chunks for the current Thread.\n+  // If beg == 0, the chunk is unused.\n+  struct DTV {\n+    uptr beg, size;\n+  };\n+\n+  uptr dtv_size;\n+  DTV *dtv;  // dtv_size elements, allocated by MmapOrDie.\n+\n+  // Auxiliary fields, don't access them outside sanitizer_tls_get_addr.cc\n+  uptr last_memalign_size;\n+  uptr last_memalign_ptr;\n+};\n+\n+void DTLS_on_tls_get_addr(void *arg, void *res);\n+void DTLS_on_libc_memalign(void *ptr, uptr size);\n+DTLS *DTLS_Get();\n+void DTLS_Destroy();  // Make sure to call this before the thread is destroyed.\n+\n+}  // namespace __sanitizer\n+\n+#endif  // SANITIZER_TLS_GET_ADDR_H"}, {"sha": "6065838cefe30442b24408607464f65b2f945360", "filename": "libsanitizer/sanitizer_common/sanitizer_win.cc", "status": "modified", "additions": 85, "deletions": 16, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -78,17 +78,19 @@ void GetThreadStackTopAndBottom(bool at_initialization, uptr *stack_top,\n void *MmapOrDie(uptr size, const char *mem_type) {\n   void *rv = VirtualAlloc(0, size, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);\n   if (rv == 0) {\n-    Report(\"ERROR: Failed to allocate 0x%zx (%zd) bytes of %s\\n\",\n-           size, size, mem_type);\n+    Report(\"ERROR: %s failed to \"\n+           \"allocate 0x%zx (%zd) bytes of %s (error code: %d)\\n\",\n+           SanitizerToolName, size, size, mem_type, GetLastError());\n     CHECK(\"unable to mmap\" && 0);\n   }\n   return rv;\n }\n \n void UnmapOrDie(void *addr, uptr size) {\n   if (VirtualFree(addr, size, MEM_DECOMMIT) == 0) {\n-    Report(\"ERROR: Failed to deallocate 0x%zx (%zd) bytes at address %p\\n\",\n-           size, size, addr);\n+    Report(\"ERROR: %s failed to \"\n+           \"deallocate 0x%zx (%zd) bytes at address %p (error code: %d)\\n\",\n+           SanitizerToolName, size, size, addr, GetLastError());\n     CHECK(\"unable to unmap\" && 0);\n   }\n }\n@@ -99,15 +101,21 @@ void *MmapFixedNoReserve(uptr fixed_addr, uptr size) {\n   void *p = VirtualAlloc((LPVOID)fixed_addr, size,\n       MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);\n   if (p == 0)\n-    Report(\"ERROR: Failed to allocate 0x%zx (%zd) bytes at %p (%d)\\n\",\n-           size, size, fixed_addr, GetLastError());\n+    Report(\"ERROR: %s failed to \"\n+           \"allocate %p (%zd) bytes at %p (error code: %d)\\n\",\n+           SanitizerToolName, size, size, fixed_addr, GetLastError());\n   return p;\n }\n \n void *MmapFixedOrDie(uptr fixed_addr, uptr size) {\n   return MmapFixedNoReserve(fixed_addr, size);\n }\n \n+void *MmapNoReserveOrDie(uptr size, const char *mem_type) {\n+  // FIXME: make this really NoReserve?\n+  return MmapOrDie(size, mem_type);\n+}\n+\n void *Mprotect(uptr fixed_addr, uptr size) {\n   return VirtualAlloc((LPVOID)fixed_addr, size,\n                       MEM_RESERVE | MEM_COMMIT, PAGE_NOACCESS);\n@@ -175,14 +183,15 @@ void DumpProcessMap() {\n }\n \n void DisableCoreDumper() {\n-  UNIMPLEMENTED();\n+  // Do nothing.\n }\n \n void ReExec() {\n   UNIMPLEMENTED();\n }\n \n-void PrepareForSandboxing() {\n+void PrepareForSandboxing(__sanitizer_sandbox_arguments *args) {\n+  (void)args;\n   // Nothing here for now.\n }\n \n@@ -264,13 +273,48 @@ uptr internal_read(fd_t fd, void *buf, uptr count) {\n uptr internal_write(fd_t fd, const void *buf, uptr count) {\n   if (fd != kStderrFd)\n     UNIMPLEMENTED();\n-  HANDLE err = GetStdHandle(STD_ERROR_HANDLE);\n-  if (err == 0)\n-    return 0;  // FIXME: this might not work on some apps.\n-  DWORD ret;\n-  if (!WriteFile(err, buf, count, &ret, 0))\n+\n+  static HANDLE output_stream = 0;\n+  // Abort immediately if we know printing is not possible.\n+  if (output_stream == INVALID_HANDLE_VALUE)\n     return 0;\n-  return ret;\n+\n+  // If called for the first time, try to use stderr to output stuff,\n+  // falling back to stdout if anything goes wrong.\n+  bool fallback_to_stdout = false;\n+  if (output_stream == 0) {\n+    output_stream = GetStdHandle(STD_ERROR_HANDLE);\n+    // We don't distinguish \"no such handle\" from error.\n+    if (output_stream == 0)\n+      output_stream = INVALID_HANDLE_VALUE;\n+\n+    if (output_stream == INVALID_HANDLE_VALUE) {\n+      // Retry with stdout?\n+      output_stream = GetStdHandle(STD_OUTPUT_HANDLE);\n+      if (output_stream == 0)\n+        output_stream = INVALID_HANDLE_VALUE;\n+      if (output_stream == INVALID_HANDLE_VALUE)\n+        return 0;\n+    } else {\n+      // Successfully got an stderr handle.  However, if WriteFile() fails,\n+      // we can still try to fallback to stdout.\n+      fallback_to_stdout = true;\n+    }\n+  }\n+\n+  DWORD ret;\n+  if (WriteFile(output_stream, buf, count, &ret, 0))\n+    return ret;\n+\n+  // Re-try with stdout if using a valid stderr handle fails.\n+  if (fallback_to_stdout) {\n+    output_stream = GetStdHandle(STD_OUTPUT_HANDLE);\n+    if (output_stream == 0)\n+      output_stream = INVALID_HANDLE_VALUE;\n+    if (output_stream != INVALID_HANDLE_VALUE)\n+      return internal_write(fd, buf, count);\n+  }\n+  return 0;\n }\n \n uptr internal_stat(const char *path, void *buf) {\n@@ -375,25 +419,32 @@ void GetThreadStackAndTls(bool main, uptr *stk_addr, uptr *stk_size,\n }\n \n void StackTrace::SlowUnwindStack(uptr pc, uptr max_depth) {\n+  CHECK_GE(max_depth, 2);\n   // FIXME: CaptureStackBackTrace might be too slow for us.\n   // FIXME: Compare with StackWalk64.\n   // FIXME: Look at LLVMUnhandledExceptionFilter in Signals.inc\n   size = CaptureStackBackTrace(2, Min(max_depth, kStackTraceMax),\n                                (void**)trace, 0);\n+  if (size == 0)\n+    return;\n+\n   // Skip the RTL frames by searching for the PC in the stacktrace.\n   uptr pc_location = LocatePcInTrace(pc);\n   PopStackFrames(pc_location);\n }\n \n+void StackTrace::SlowUnwindStackWithContext(uptr pc, void *context,\n+                                            uptr max_depth) {\n+  UNREACHABLE(\"no signal context on windows\");\n+}\n+\n void MaybeOpenReportFile() {\n   // Windows doesn't have native fork, and we don't support Cygwin or other\n   // environments that try to fake it, so the initial report_fd will always be\n   // correct.\n }\n \n void RawWrite(const char *buffer) {\n-  static const char *kRawWriteError =\n-      \"RawWrite can't output requested buffer!\\n\";\n   uptr length = (uptr)internal_strlen(buffer);\n   if (length != internal_write(report_fd, buffer, length)) {\n     // stderr may be closed, but we may be able to print to the debugger\n@@ -403,6 +454,24 @@ void RawWrite(const char *buffer) {\n   }\n }\n \n+void SetAlternateSignalStack() {\n+  // FIXME: Decide what to do on Windows.\n+}\n+\n+void UnsetAlternateSignalStack() {\n+  // FIXME: Decide what to do on Windows.\n+}\n+\n+void InstallDeadlySignalHandlers(SignalHandlerType handler) {\n+  (void)handler;\n+  // FIXME: Decide what to do on Windows.\n+}\n+\n+bool IsDeadlySignal(int signum) {\n+  // FIXME: Decide what to do on Windows.\n+  return false;\n+}\n+\n }  // namespace __sanitizer\n \n #endif  // _WIN32"}, {"sha": "5d98e215e0571b04306efdff9355be807f09a644", "filename": "libsanitizer/tsan/Makefile.am", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2FMakefile.am?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55", "patch": "@@ -11,32 +11,32 @@ ACLOCAL_AMFLAGS = -I m4\n toolexeclib_LTLIBRARIES = libtsan.la\n \n tsan_files = \\\n-        tsan_clock.cc \\\n-        tsan_interface_atomic.cc \\\n-        tsan_mutex.cc \\\n-        tsan_report.cc \\\n-        tsan_rtl_thread.cc \\\n-        tsan_symbolize.cc \\\n-        tsan_flags.cc \\\n-        tsan_interface.cc \\\n-        tsan_platform_linux.cc \\\n-        tsan_rtl.cc \\\n-        tsan_stat.cc \\\n-        tsan_sync.cc \\\n-\ttsan_ignoreset.cc \\\n-        tsan_interceptors.cc \\\n-        tsan_md5.cc \\\n-        tsan_platform_mac.cc \\\n-        tsan_rtl_mutex.cc \\\n-        tsan_suppressions.cc \\\n-        tsan_interface_ann.cc \\\n-        tsan_mman.cc \\\n-        tsan_rtl_report.cc \\\n+\ttsan_clock.cc \\\n \ttsan_fd.cc \\\n-        tsan_interface_java.cc \\\n-        tsan_mutexset.cc \\\n-        tsan_symbolize_addr2line_linux.cc \\\n-        tsan_rtl_amd64.S\n+\ttsan_flags.cc \\\n+\ttsan_ignoreset.cc \\\n+\ttsan_interceptors.cc \\\n+\ttsan_interface_ann.cc \\\n+\ttsan_interface_atomic.cc \\\n+\ttsan_interface.cc \\\n+\ttsan_interface_java.cc \\\n+\ttsan_md5.cc \\\n+\ttsan_mman.cc \\\n+\ttsan_mutex.cc \\\n+\ttsan_mutexset.cc \\\n+\ttsan_platform_linux.cc \\\n+\ttsan_platform_mac.cc \\\n+\ttsan_platform_windows.cc \\\n+\ttsan_report.cc \\\n+\ttsan_rtl.cc \\\n+\ttsan_rtl_mutex.cc \\\n+\ttsan_rtl_report.cc \\\n+\ttsan_rtl_thread.cc \\\n+\ttsan_stat.cc \\\n+\ttsan_suppressions.cc \\\n+\ttsan_symbolize.cc \\\n+\ttsan_sync.cc \\\n+\ttsan_rtl_amd64.S\n \n libtsan_la_SOURCES = $(tsan_files) \n libtsan_la_LIBADD = $(top_builddir)/sanitizer_common/libsanitizer_common.la $(top_builddir)/interception/libinterception.la"}, {"sha": "068aaa87fe8277141f2e44bfef9f4dee20849c96", "filename": "libsanitizer/tsan/Makefile.in", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2FMakefile.in?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55"}, {"sha": "b944cc50d54fd61d65cd75e1ea33061a876ad2b9", "filename": "libsanitizer/tsan/tsan_clock.cc", "status": "modified", "additions": 297, "deletions": 58, "changes": 355, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_clock.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_clock.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_clock.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55"}, {"sha": "2ce480b2d16335c883649ba4155e1770e45f28c1", "filename": "libsanitizer/tsan/tsan_clock.h", "status": "modified", "additions": 37, "deletions": 17, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_clock.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_clock.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_clock.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55"}, {"sha": "cc65ae8b4a30141eafd1b783beb0726e86770339", "filename": "libsanitizer/tsan/tsan_defs.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_defs.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55"}, {"sha": "7d62ae4c5ff3b2aecdfda275eab53502139b2399", "filename": "libsanitizer/tsan/tsan_fd.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_fd.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_fd.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_fd.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55"}, {"sha": "57ae62cfe8ba83f1eef0665129047fe1c15074fa", "filename": "libsanitizer/tsan/tsan_fd.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_fd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_fd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_fd.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55"}, {"sha": "e241cb6cda47b1fb567f60244e688f0e65128dbc", "filename": "libsanitizer/tsan/tsan_flags.cc", "status": "modified", "additions": 39, "deletions": 30, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_flags.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_flags.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_flags.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55"}, {"sha": "4bf459d59817251234f764f003c05b53544dc631", "filename": "libsanitizer/tsan/tsan_flags.h", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_flags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_flags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_flags.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55"}, {"sha": "19a3b7b0643a2745b6c0493afff9d77416d2dd65", "filename": "libsanitizer/tsan/tsan_interceptors.cc", "status": "modified", "additions": 347, "deletions": 225, "changes": 572, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_interceptors.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_interceptors.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interceptors.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55"}, {"sha": "20e3d9a35ac7c4f03f85bb9e891d9a8829bc379f", "filename": "libsanitizer/tsan/tsan_interface_ann.cc", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_interface_ann.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_interface_ann.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface_ann.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55"}, {"sha": "3f5a4ccc9f7158fdeefd58a78ae57afd32fea8df", "filename": "libsanitizer/tsan/tsan_interface_atomic.cc", "status": "modified", "additions": 230, "deletions": 59, "changes": 289, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_interface_atomic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_interface_atomic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface_atomic.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55"}, {"sha": "7f451690946e9d554abd00a0cea5a5db0dc6ffb8", "filename": "libsanitizer/tsan/tsan_interface_java.cc", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_interface_java.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_interface_java.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface_java.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55"}, {"sha": "bd30cd52e637e5861aa76d8527a3ad248e361538", "filename": "libsanitizer/tsan/tsan_mman.cc", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_mman.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_mman.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_mman.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55"}, {"sha": "0c3bb4a672135c26478a06a291c65272702aa1cb", "filename": "libsanitizer/tsan/tsan_mutex.cc", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_mutex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_mutex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_mutex.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55"}, {"sha": "f075ce831e6e13aa791480889bd45906e202eadb", "filename": "libsanitizer/tsan/tsan_mutex.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_mutex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_mutex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_mutex.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55"}, {"sha": "7fdc194109fac1d732f6f966f4139916b141adf4", "filename": "libsanitizer/tsan/tsan_mutexset.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_mutexset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_mutexset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_mutexset.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55"}, {"sha": "60eb1a8499548761fc9c3a50e366e19a75734038", "filename": "libsanitizer/tsan/tsan_platform.h", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_platform.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_platform.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55"}, {"sha": "062e84615cc77de475abd494c0d9f22c7d30b5a8", "filename": "libsanitizer/tsan/tsan_platform_linux.cc", "status": "modified", "additions": 23, "deletions": 34, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_platform_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_platform_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform_linux.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55"}, {"sha": "c3d4d905219cbe0d5b7dd3597bf292c8db3f55ae", "filename": "libsanitizer/tsan/tsan_platform_mac.cc", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_platform_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_platform_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform_mac.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55"}, {"sha": "f16bebf7f4c574fba7b9cd67911268c8d62f2bba", "filename": "libsanitizer/tsan/tsan_platform_windows.cc", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_platform_windows.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_platform_windows.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform_windows.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55"}, {"sha": "00a512e0cf8615fa82010273cb382582ca46a3c8", "filename": "libsanitizer/tsan/tsan_report.cc", "status": "modified", "additions": 83, "deletions": 12, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_report.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_report.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_report.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55"}, {"sha": "d773e057af0ad3f504bf0061bdf72076e7556f73", "filename": "libsanitizer/tsan/tsan_report.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_report.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_report.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_report.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55"}, {"sha": "7932a6d9e0424af107a791c1eac0794a9c944623", "filename": "libsanitizer/tsan/tsan_rtl.cc", "status": "modified", "additions": 109, "deletions": 48, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_rtl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_rtl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55"}, {"sha": "e6bc8b285955da70d9f3e401011646253e13476d", "filename": "libsanitizer/tsan/tsan_rtl.h", "status": "modified", "additions": 43, "deletions": 21, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_rtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_rtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55"}, {"sha": "3724571cfff21df6c2f75013bc90aa1de2c67405", "filename": "libsanitizer/tsan/tsan_rtl_mutex.cc", "status": "modified", "additions": 182, "deletions": 57, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_rtl_mutex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_rtl_mutex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_mutex.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55"}, {"sha": "d19deb066dff87734a9d471de9b3f875bcc33704", "filename": "libsanitizer/tsan/tsan_rtl_report.cc", "status": "modified", "additions": 52, "deletions": 45, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_rtl_report.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_rtl_report.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_report.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55"}, {"sha": "385af7e1fa6703a81932233d7abc2ab1cb98d4be", "filename": "libsanitizer/tsan/tsan_rtl_thread.cc", "status": "modified", "additions": 25, "deletions": 27, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_rtl_thread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_rtl_thread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_thread.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55"}, {"sha": "e8d3a790b1c7c84a7570a13deb7a9e093585b392", "filename": "libsanitizer/tsan/tsan_stat.cc", "status": "modified", "additions": 24, "deletions": 333, "changes": 357, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_stat.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_stat.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_stat.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55"}, {"sha": "5bdd9de82132ca12ea5cb033def07c781a7a217a", "filename": "libsanitizer/tsan/tsan_stat.h", "status": "modified", "additions": 27, "deletions": 331, "changes": 358, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_stat.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_stat.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_stat.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55"}, {"sha": "ce8d5fe861135590492ec8156e2865de55f8004d", "filename": "libsanitizer/tsan/tsan_suppressions.cc", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_suppressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_suppressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_suppressions.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55"}, {"sha": "fa36017846cdbec6321a607a8910355013e65a57", "filename": "libsanitizer/tsan/tsan_symbolize.cc", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_symbolize.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_symbolize.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_symbolize.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55"}, {"sha": "0d9077ed379afe9f282713d6ccd54b568ed22f02", "filename": "libsanitizer/tsan/tsan_symbolize.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_symbolize.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_symbolize.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_symbolize.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55"}, {"sha": "c278a42f3178786f40b8cd4106a6dcf512d4e0ed", "filename": "libsanitizer/tsan/tsan_symbolize_addr2line_linux.cc", "status": "removed", "additions": 0, "deletions": 191, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b95591361e32a755231d99c348f8a43e2aed0187/libsanitizer%2Ftsan%2Ftsan_symbolize_addr2line_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b95591361e32a755231d99c348f8a43e2aed0187/libsanitizer%2Ftsan%2Ftsan_symbolize_addr2line_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_symbolize_addr2line_linux.cc?ref=b95591361e32a755231d99c348f8a43e2aed0187"}, {"sha": "f6f2cb731e7ae7d2d02de9f8d64224de57c6f456", "filename": "libsanitizer/tsan/tsan_sync.cc", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_sync.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_sync.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_sync.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55"}, {"sha": "3838df91d7574e727d433b7bf083599acb16b904", "filename": "libsanitizer/tsan/tsan_sync.h", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_sync.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_sync.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_sync.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55"}, {"sha": "f65ad2b556081e5d08f0a9accee454b4343eea94", "filename": "libsanitizer/tsan/tsan_vector.h", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_vector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Ftsan%2Ftsan_vector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_vector.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55"}, {"sha": "1dfe7255f68371c40454591373f2b622a745fed7", "filename": "libsanitizer/ubsan/ubsan_diag.cc", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fubsan%2Fubsan_diag.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fubsan%2Fubsan_diag.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_diag.cc?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55"}, {"sha": "abfd31fbd9962325b8c2a2f926bf169cc9c62811", "filename": "libsanitizer/ubsan/ubsan_value.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fubsan%2Fubsan_value.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee5ea7a0bfe95367820a443ef4a7c813e598b55/libsanitizer%2Fubsan%2Fubsan_value.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_value.h?ref=dee5ea7a0bfe95367820a443ef4a7c813e598b55"}]}