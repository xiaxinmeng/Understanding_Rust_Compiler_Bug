{"sha": "97f309c3e2c4592466ebf4fe8b5d721eacad9245", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTdmMzA5YzNlMmM0NTkyNDY2ZWJmNGZlOGI1ZDcyMWVhY2FkOTI0NQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-06-30T21:08:54Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-06-30T21:08:54Z"}, "message": "i386: Always use TARGET_DEEP_BRANCH_PREDICTION.\n\nWhile it could be possible to output_set_got such that we can\nindividually annotate the instructions, it's simpler to simply\nadmit that all processors currently being manufactured do want\ndeep branch prediction.  At which point all of the complication\nsimply goes away.\n\n        * config/i386/i386.h (X86_TUNE_DEEP_BRANCH_PREDICTION): Remove.\n        (TARGET_DEEP_BRANCH_PREDICTION): Remove.\n        * config/i386/i386.c: Don't include dwarf2out.h.\n        (initial_ix86_tune_features): Remove X86_TUNE_DEEP_BRANCH_PREDICTION.\n        (output_set_got): Don't test TARGET_DEEP_BRANCH_PREDICTION, delete\n        all code dead thereafter.  Don't do dwarf2out_flush_queued_reg_saves.\n        (ix86_expand_prologue): Set REG_CFA_FLUSH_QUEUE on set_got insn.\n        (machopic_output_stub): Don't test TARGET_DEEP_BRANCH_PREDICTION.\n\nFrom-SVN: r175730", "tree": {"sha": "facd947000653009e40df553bd0b3afb2bc3f9e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/facd947000653009e40df553bd0b3afb2bc3f9e6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/97f309c3e2c4592466ebf4fe8b5d721eacad9245", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97f309c3e2c4592466ebf4fe8b5d721eacad9245", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97f309c3e2c4592466ebf4fe8b5d721eacad9245", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97f309c3e2c4592466ebf4fe8b5d721eacad9245/comments", "author": null, "committer": null, "parents": [{"sha": "ef284364b4fb287a01cfcbabab5c5e60e36c83a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef284364b4fb287a01cfcbabab5c5e60e36c83a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef284364b4fb287a01cfcbabab5c5e60e36c83a5"}], "stats": {"total": 119, "additions": 27, "deletions": 92}, "files": [{"sha": "3a1b56ae3408a92a0f819387868ffb4749a9bb6a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97f309c3e2c4592466ebf4fe8b5d721eacad9245/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97f309c3e2c4592466ebf4fe8b5d721eacad9245/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=97f309c3e2c4592466ebf4fe8b5d721eacad9245", "patch": "@@ -1,3 +1,14 @@\n+2011-06-30  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/i386/i386.h (X86_TUNE_DEEP_BRANCH_PREDICTION): Remove.\n+\t(TARGET_DEEP_BRANCH_PREDICTION): Remove.\n+\t* config/i386/i386.c: Don't include dwarf2out.h.\n+\t(initial_ix86_tune_features): Remove X86_TUNE_DEEP_BRANCH_PREDICTION.\n+\t(output_set_got): Don't test TARGET_DEEP_BRANCH_PREDICTION, delete\n+\tall code dead thereafter.  Don't do dwarf2out_flush_queued_reg_saves.\n+\t(ix86_expand_prologue): Set REG_CFA_FLUSH_QUEUE on set_got insn.\n+\t(machopic_output_stub): Don't test TARGET_DEEP_BRANCH_PREDICTION.\n+\n 2011-06-30  Richard Henderson  <rth@redhat.com>\n \n \t* reg-notes.def (REG_CFA_FLUSH_QUEUE): New."}, {"sha": "04cb07d5740f795763f3588d32670bd1900e65b4", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 16, "deletions": 89, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97f309c3e2c4592466ebf4fe8b5d721eacad9245/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97f309c3e2c4592466ebf4fe8b5d721eacad9245/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=97f309c3e2c4592466ebf4fe8b5d721eacad9245", "patch": "@@ -55,7 +55,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"params.h\"\n #include \"cselib.h\"\n #include \"debug.h\"\n-#include \"dwarf2out.h\"\n #include \"sched-int.h\"\n #include \"sbitmap.h\"\n #include \"fibheap.h\"\n@@ -1847,10 +1846,6 @@ static unsigned int initial_ix86_tune_features[X86_TUNE_LAST] = {\n   m_486 | m_PENT | m_ATOM | m_PPRO | m_AMD_MULTIPLE | m_K6\n   | m_CORE2I7 | m_GENERIC,\n \n-  /* X86_TUNE_DEEP_BRANCH_PREDICTION */\n-  m_ATOM | m_PPRO | m_K6_GEODE | m_AMD_MULTIPLE | m_PENT4\n-  | m_CORE2I7 | m_GENERIC,\n-\n   /* X86_TUNE_BRANCH_PREDICTION_HINTS: Branch hints were put in P4 based\n      on simulation result. But after P4 was made, no performance benefit\n      was observed with branch hints.  It also increases the code size.\n@@ -8331,31 +8326,11 @@ output_set_got (rtx dest, rtx label ATTRIBUTE_UNUSED)\n \n   xops[1] = gen_rtx_SYMBOL_REF (Pmode, GOT_SYMBOL_NAME);\n \n-  if (! TARGET_DEEP_BRANCH_PREDICTION || !flag_pic)\n+  if (!flag_pic)\n     {\n       xops[2] = gen_rtx_LABEL_REF (Pmode, label ? label : gen_label_rtx ());\n \n-      if (!flag_pic)\n-\toutput_asm_insn (\"mov%z0\\t{%2, %0|%0, %2}\", xops);\n-      else\n-\t{\n-\t  output_asm_insn (\"call\\t%a2\", xops);\n-#ifdef DWARF2_UNWIND_INFO\n-\t  /* The call to next label acts as a push.  */\n-\t  if (dwarf2out_do_frame ())\n-\t    {\n-\t      rtx insn;\n-\t      start_sequence ();\n-\t      insn = emit_insn (gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n-\t\t\t\t\t     gen_rtx_PLUS (Pmode,\n-\t\t\t\t\t\t\t   stack_pointer_rtx,\n-\t\t\t\t\t\t\t   GEN_INT (-4))));\n-\t      RTX_FRAME_RELATED_P (insn) = 1;\n-\t      dwarf2out_frame_debug (insn, true);\n-\t      end_sequence ();\n-\t    }\n-#endif\n-\t}\n+      output_asm_insn (\"mov%z0\\t{%2, %0|%0, %2}\", xops);\n \n #if TARGET_MACHO\n       /* Output the Mach-O \"canonical\" label name (\"Lxx$pb\") here too.  This\n@@ -8366,42 +8341,13 @@ output_set_got (rtx dest, rtx label ATTRIBUTE_UNUSED)\n \n       targetm.asm_out.internal_label (asm_out_file, \"L\",\n \t\t\t\t      CODE_LABEL_NUMBER (XEXP (xops[2], 0)));\n-\n-      if (flag_pic)\n-\t{\n-\t  output_asm_insn (\"pop%z0\\t%0\", xops);\n-#ifdef DWARF2_UNWIND_INFO\n-\t  /* The pop is a pop and clobbers dest, but doesn't restore it\n-\t     for unwind info purposes.  */\n-\t  if (dwarf2out_do_frame ())\n-\t    {\n-\t      rtx insn;\n-\t      start_sequence ();\n-\t      insn = emit_insn (gen_rtx_SET (VOIDmode, dest, const0_rtx));\n-\t      dwarf2out_frame_debug (insn, true);\n-\t      insn = emit_insn (gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n-\t\t\t\t\t     gen_rtx_PLUS (Pmode,\n-\t\t\t\t\t\t\t   stack_pointer_rtx,\n-\t\t\t\t\t\t\t   GEN_INT (4))));\n-\t      RTX_FRAME_RELATED_P (insn) = 1;\n-\t      dwarf2out_frame_debug (insn, true);\n-\t      end_sequence ();\n-\t    }\n-#endif\n-\t}\n     }\n   else\n     {\n       char name[32];\n       get_pc_thunk_name (name, REGNO (dest));\n       pic_labels_used |= 1 << REGNO (dest);\n \n-#ifdef DWARF2_UNWIND_INFO\n-      /* Ensure all queued register saves are flushed before the\n-\t call.  */\n-      if (dwarf2out_do_frame ())\n-\tdwarf2out_flush_queued_reg_saves ();\n-#endif\n       xops[2] = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (name));\n       xops[2] = gen_rtx_MEM (QImode, xops[2]);\n       output_asm_insn (\"call\\t%X2\", xops);\n@@ -8416,13 +8362,8 @@ output_set_got (rtx dest, rtx label ATTRIBUTE_UNUSED)\n #endif\n     }\n \n-  if (TARGET_MACHO)\n-    return \"\";\n-\n-  if (!flag_pic || TARGET_DEEP_BRANCH_PREDICTION)\n+  if (!TARGET_MACHO)\n     output_asm_insn (\"add%z0\\t{%1, %0|%0, %1}\", xops);\n-  else\n-    output_asm_insn (\"add%z0\\t{%1+[.-%a2], %0|%0, %1+(.-%a2)}\", xops);\n \n   return \"\";\n }\n@@ -10146,7 +10087,11 @@ ix86_expand_prologue (void)\n             insn = emit_insn (gen_set_got_rex64 (pic_offset_table_rtx));\n \t}\n       else\n-        insn = emit_insn (gen_set_got (pic_offset_table_rtx));\n+\t{\n+          insn = emit_insn (gen_set_got (pic_offset_table_rtx));\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t  add_reg_note (insn, REG_CFA_FLUSH_QUEUE, NULL_RTX);\n+\t}\n     }\n \n   /* In the pic_reg_used case, make sure that the got load isn't deleted\n@@ -28987,12 +28932,7 @@ machopic_output_stub (FILE *file, const char *symb, const char *stub)\n   if (MACHOPIC_ATT_STUB)\n     switch_to_section (darwin_sections[machopic_picsymbol_stub3_section]);\n   else if (MACHOPIC_PURE)\n-    {\n-      if (TARGET_DEEP_BRANCH_PREDICTION)\n-\tswitch_to_section (darwin_sections[machopic_picsymbol_stub2_section]);\n-      else\n-    switch_to_section (darwin_sections[machopic_picsymbol_stub_section]);\n-    }\n+    switch_to_section (darwin_sections[machopic_picsymbol_stub2_section]);\n   else\n     switch_to_section (darwin_sections[machopic_symbol_stub_section]);\n \n@@ -29006,19 +28946,11 @@ machopic_output_stub (FILE *file, const char *symb, const char *stub)\n   else if (MACHOPIC_PURE)\n     {\n       /* PIC stub.  */\n-      if (TARGET_DEEP_BRANCH_PREDICTION)\n-\t{\n-\t  /* 25-byte PIC stub using \"CALL get_pc_thunk\".  */\n-\t  rtx tmp = gen_rtx_REG (SImode, 2 /* ECX */);\n-\t  output_set_got (tmp, NULL_RTX);\t/* \"CALL ___<cpu>.get_pc_thunk.cx\".  */\n-\t  fprintf (file, \"LPC$%d:\\tmovl\\t%s-LPC$%d(%%ecx),%%ecx\\n\", label, lazy_ptr_name, label);\n-\t}\n-      else\n-\t{\n-\t  /* 26-byte PIC stub using inline picbase: \"CALL L42 ! L42: pop %eax\".  */\n-\t  fprintf (file, \"\\tcall LPC$%d\\nLPC$%d:\\tpopl %%ecx\\n\", label, label);\n-\t  fprintf (file, \"\\tmovl %s-LPC$%d(%%ecx),%%ecx\\n\", lazy_ptr_name, label);\n-\t}\n+      /* 25-byte PIC stub using \"CALL get_pc_thunk\".  */\n+      rtx tmp = gen_rtx_REG (SImode, 2 /* ECX */);\n+      output_set_got (tmp, NULL_RTX);\t/* \"CALL ___<cpu>.get_pc_thunk.cx\".  */\n+      fprintf (file, \"LPC$%d:\\tmovl\\t%s-LPC$%d(%%ecx),%%ecx\\n\",\n+\t       label, lazy_ptr_name, label);\n       fprintf (file, \"\\tjmp\\t*%%ecx\\n\");\n     }\n   else\n@@ -29047,13 +28979,8 @@ machopic_output_stub (FILE *file, const char *symb, const char *stub)\n      compatibility with existing dylibs.  */\n   if (MACHOPIC_PURE)\n     {\n-      /* PIC stubs.  */\n-      if (TARGET_DEEP_BRANCH_PREDICTION)\n-\t/* 25-byte PIC stub using \"CALL get_pc_thunk\".  */\n-\tswitch_to_section (darwin_sections[machopic_lazy_symbol_ptr2_section]);\n-      else\n-\t/* 26-byte PIC stub using inline picbase: \"CALL L42 ! L42: pop %ebx\".  */\n-  switch_to_section (darwin_sections[machopic_lazy_symbol_ptr_section]);\n+      /* 25-byte PIC stub using \"CALL get_pc_thunk\".  */\n+      switch_to_section (darwin_sections[machopic_lazy_symbol_ptr2_section]);\n     }\n   else\n     /* 16-byte -mdynamic-no-pic stub.  */"}, {"sha": "a1ac6b656daf14fefe04a7f79dd4d93677cb6d43", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97f309c3e2c4592466ebf4fe8b5d721eacad9245/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97f309c3e2c4592466ebf4fe8b5d721eacad9245/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=97f309c3e2c4592466ebf4fe8b5d721eacad9245", "patch": "@@ -249,7 +249,6 @@ enum ix86_tune_indices {\n   X86_TUNE_PUSH_MEMORY,\n   X86_TUNE_ZERO_EXTEND_WITH_AND,\n   X86_TUNE_UNROLL_STRLEN,\n-  X86_TUNE_DEEP_BRANCH_PREDICTION,\n   X86_TUNE_BRANCH_PREDICTION_HINTS,\n   X86_TUNE_DOUBLE_WITH_ADD,\n   X86_TUNE_USE_SAHF,\n@@ -324,8 +323,6 @@ extern unsigned char ix86_tune_features[X86_TUNE_LAST];\n #define TARGET_ZERO_EXTEND_WITH_AND \\\n \tix86_tune_features[X86_TUNE_ZERO_EXTEND_WITH_AND]\n #define TARGET_UNROLL_STRLEN\tix86_tune_features[X86_TUNE_UNROLL_STRLEN]\n-#define TARGET_DEEP_BRANCH_PREDICTION \\\n-\tix86_tune_features[X86_TUNE_DEEP_BRANCH_PREDICTION]\n #define TARGET_BRANCH_PREDICTION_HINTS \\\n \tix86_tune_features[X86_TUNE_BRANCH_PREDICTION_HINTS]\n #define TARGET_DOUBLE_WITH_ADD\tix86_tune_features[X86_TUNE_DOUBLE_WITH_ADD]"}]}