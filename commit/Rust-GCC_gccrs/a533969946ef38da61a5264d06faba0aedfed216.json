{"sha": "a533969946ef38da61a5264d06faba0aedfed216", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTUzMzk2OTk0NmVmMzhkYTYxYTUyNjRkMDZmYWJhMGFlZGZlZDIxNg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-05-17T15:30:03Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-05-17T15:30:03Z"}, "message": "(compare_spill_regs): New function.\n\n(reload_as_needed): Sort the spilled regs.\n(allocate_reload_reg): If we have group needs and failure would be fatal, do\nnot try to do round-robin allocation of the spill regs.\n\nFrom-SVN: r7318", "tree": {"sha": "8eb60e048ff1d62807061501544a20bfe21ea5c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8eb60e048ff1d62807061501544a20bfe21ea5c3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a533969946ef38da61a5264d06faba0aedfed216", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a533969946ef38da61a5264d06faba0aedfed216", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a533969946ef38da61a5264d06faba0aedfed216", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a533969946ef38da61a5264d06faba0aedfed216/comments", "author": null, "committer": null, "parents": [{"sha": "58e09803edf76a4ffeae0e151972d08bf86e8771", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58e09803edf76a4ffeae0e151972d08bf86e8771", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58e09803edf76a4ffeae0e151972d08bf86e8771"}], "stats": {"total": 30, "additions": 27, "deletions": 3}, "files": [{"sha": "5fa49ed2e5913bc00bd16b8b02bfd8eb26bafa60", "filename": "gcc/reload1.c", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a533969946ef38da61a5264d06faba0aedfed216/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a533969946ef38da61a5264d06faba0aedfed216/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=a533969946ef38da61a5264d06faba0aedfed216", "patch": "@@ -345,6 +345,7 @@ static void scan_paradoxical_subregs\tPROTO((rtx));\n static int hard_reg_use_compare\t\tPROTO((struct hard_reg_n_uses *,\n \t\t\t\t\t       struct hard_reg_n_uses *));\n static void order_regs_for_reload\tPROTO((void));\n+static void compare_spill_regs\t\tPROTO((short *, short *));\n static void reload_as_needed\t\tPROTO((rtx, int));\n static void forget_old_reloads_1\tPROTO((rtx, rtx));\n static int reload_reg_class_lower\tPROTO((short *, short *));\n@@ -3588,6 +3589,14 @@ order_regs_for_reload ()\n       potential_reload_regs[o++] = hard_reg_n_uses[i].regno;\n }\n \f\n+/* Used in reload_as_needed to sort the spilled regs.  */\n+static int\n+compare_spill_regs (r1, r2)\n+     short *r1, *r2;\n+{\n+  return *r1 < *r2 ? -1: 1;\n+}\n+\n /* Reload pseudo-registers into hard regs around each insn as needed.\n    Additional register load insns are output before the insn that needs it\n    and perhaps store insns after insns that modify the reloaded pseudo reg.\n@@ -3635,6 +3644,11 @@ reload_as_needed (first, live_known)\n \n   num_not_at_initial_offset = 0;\n \n+  /* Order the spilled regs, so that allocate_reload_regs can guarantee to\n+     pack registers with group needs.  */\n+  if (n_spills > 1)\n+    qsort (spill_regs, n_spills, sizeof (short), compare_spill_regs);\n+\n   for (insn = first; insn;)\n     {\n       register rtx next = NEXT_INSN (insn);\n@@ -4558,9 +4572,19 @@ allocate_reload_reg (r, insn, last_reload, noerror)\n       /* I is the index in spill_regs.\n \t We advance it round-robin between insns to use all spill regs\n \t equally, so that inherited reloads have a chance\n-\t of leapfrogging each other.  */\n-\n-      for (count = 0, i = last_spill_reg; count < n_spills; count++)\n+\t of leapfrogging each other.  Don't do this, however, when we have\n+\t group needs and failure would be fatal; if we only have a relatively\n+\t small number of spill registers, and more than one of them has\n+\t group needs, then by starting in the middle, we may end up \n+\t allocating the first one in such a way that we are not left with\n+\t sufficient groups to handle the rest.  */\n+\n+      if (noerror || ! force_group)\n+\ti = last_spill_reg;\n+      else\n+\ti = -1;\n+\t  \n+      for (count = 0; count < n_spills; count++)\n \t{\n \t  int class = (int) reload_reg_class[r];\n "}]}