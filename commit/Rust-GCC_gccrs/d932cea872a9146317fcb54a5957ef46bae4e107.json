{"sha": "d932cea872a9146317fcb54a5957ef46bae4e107", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDkzMmNlYTg3MmE5MTQ2MzE3ZmNiNTRhNTk1N2VmNDZiYWU0ZTEwNw==", "commit": {"author": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2013-01-06T15:50:09Z"}, "committer": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2013-01-06T15:50:09Z"}, "message": "re PR fortran/42769 ([OOP] ICE  in resolve_typebound_procedure)\n\n\tPR fortran/42769\n\tPR fortran/45836\n\tPR fortran/45900\n\t* module.c (read_module): Don't reuse local symtree if the associated\n\tsymbol isn't exactly the one wanted.  Don't reuse local symtree if it is\n\tambiguous.\n\t* resolve.c (resolve_call): Use symtree's name instead of symbol's to\n\tlookup the symtree.\n\n\tPR fortran/42769\n\tPR fortran/45836\n\tPR fortran/45900\n\t* gfortran.dg/use_23.f90: New test.\n\t* gfortran.dg/use_24.f90: New test.\n\t* gfortran.dg/use_25.f90: New test.\n\t* gfortran.dg/use_26.f90: New test.\n\t* gfortran.dg/use_27.f90: New test.\n\nFrom-SVN: r194949", "tree": {"sha": "ca4dded937c2755d9c199ab4c9697b25287fff38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ca4dded937c2755d9c199ab4c9697b25287fff38"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d932cea872a9146317fcb54a5957ef46bae4e107", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d932cea872a9146317fcb54a5957ef46bae4e107", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d932cea872a9146317fcb54a5957ef46bae4e107", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d932cea872a9146317fcb54a5957ef46bae4e107/comments", "author": null, "committer": null, "parents": [{"sha": "9d1818902c053258956c3b8562d29afba4889e86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d1818902c053258956c3b8562d29afba4889e86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d1818902c053258956c3b8562d29afba4889e86"}], "stats": {"total": 350, "additions": 346, "deletions": 4}, "files": [{"sha": "f08f9b4c547e2e07bbf0af5e75c1e0ee20498048", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d932cea872a9146317fcb54a5957ef46bae4e107/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d932cea872a9146317fcb54a5957ef46bae4e107/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=d932cea872a9146317fcb54a5957ef46bae4e107", "patch": "@@ -1,3 +1,14 @@\n+2013-01-06  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\tPR fortran/42769\n+\tPR fortran/45836\n+\tPR fortran/45900\n+\t* module.c (read_module): Don't reuse local symtree if the associated\n+\tsymbol isn't exactly the one wanted.  Don't reuse local symtree if it is\n+\tambiguous.\n+\t* resolve.c (resolve_call): Use symtree's name instead of symbol's to\n+\tlookup the symtree.\n+\n 2013-01-05  Steven G. Kargl  <kargl@gcc.gnu.org>\n \t    Mikael Morin  <mikael@gcc.gnu.org>\n "}, {"sha": "f3b3caa1ad817be80097fb0f30b4055fa4dd7184", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d932cea872a9146317fcb54a5957ef46bae4e107/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d932cea872a9146317fcb54a5957ef46bae4e107/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=d932cea872a9146317fcb54a5957ef46bae4e107", "patch": "@@ -4663,8 +4663,14 @@ read_module (void)\n \t  if (p == NULL)\n \t    {\n \t      st = gfc_find_symtree (gfc_current_ns->sym_root, name);\n-\t      if (st != NULL)\n-\t\tinfo->u.rsym.symtree = st;\n+\t      if (st != NULL\n+\t\t  && strcmp (st->n.sym->name, info->u.rsym.true_name) == 0\n+\t\t  && st->n.sym->module != NULL\n+\t\t  && strcmp (st->n.sym->module, info->u.rsym.module) == 0)\n+\t\t{\n+\t\t  info->u.rsym.symtree = st;\n+\t\t  info->u.rsym.sym = st->n.sym;\n+\t\t}\n \t      continue;\n \t    }\n \n@@ -4685,7 +4691,8 @@ read_module (void)\n \t      /* Check for ambiguous symbols.  */\n \t      if (check_for_ambiguous (st->n.sym, info))\n \t\tst->ambiguous = 1;\n-\t      info->u.rsym.symtree = st;\n+\t      else\n+\t\tinfo->u.rsym.symtree = st;\n \t    }\n \t  else\n \t    {"}, {"sha": "b81f2319aa64be625bac16b25076e5398c8482bd", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d932cea872a9146317fcb54a5957ef46bae4e107/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d932cea872a9146317fcb54a5957ef46bae4e107/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=d932cea872a9146317fcb54a5957ef46bae4e107", "patch": "@@ -3776,7 +3776,7 @@ resolve_call (gfc_code *c)\n   if (csym && gfc_current_ns->parent && csym->ns != gfc_current_ns)\n     {\n       gfc_symtree *st;\n-      gfc_find_sym_tree (csym->name, gfc_current_ns, 1, &st);\n+      gfc_find_sym_tree (c->symtree->name, gfc_current_ns, 1, &st);\n       sym = st ? st->n.sym : NULL;\n       if (sym && csym != sym\n \t      && sym->ns == gfc_current_ns"}, {"sha": "2e5c99ddec454a21fd79499618ed8a151a5c29d3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d932cea872a9146317fcb54a5957ef46bae4e107/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d932cea872a9146317fcb54a5957ef46bae4e107/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d932cea872a9146317fcb54a5957ef46bae4e107", "patch": "@@ -1,3 +1,14 @@\n+2013-01-06  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\tPR fortran/42769\n+\tPR fortran/45836\n+\tPR fortran/45900\n+\t* gfortran.dg/use_23.f90: New test.\n+\t* gfortran.dg/use_24.f90: New test.\n+\t* gfortran.dg/use_25.f90: New test.\n+\t* gfortran.dg/use_26.f90: New test.\n+\t* gfortran.dg/use_27.f90: New test.\n+\n 2013-01-06  Olivier Hainque  <hainque@adacore.com>\n \n \t* gnat.dg/specs/clause_on_volatile.ads: New test."}, {"sha": "da05e1a8e207f6e519352b7b3a07e6f659ab94f1", "filename": "gcc/testsuite/gfortran.dg/use_23.f90", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d932cea872a9146317fcb54a5957ef46bae4e107/gcc%2Ftestsuite%2Fgfortran.dg%2Fuse_23.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d932cea872a9146317fcb54a5957ef46bae4e107/gcc%2Ftestsuite%2Fgfortran.dg%2Fuse_23.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fuse_23.f90?ref=d932cea872a9146317fcb54a5957ef46bae4e107", "patch": "@@ -0,0 +1,42 @@\n+! { dg-do compile }\n+!\n+! PR fortran/42769\n+! This test used to ICE in resolve_typebound_procedure because T1's GET\n+! procedure was wrongly associated to MOD2's MY_GET (instead of the original\n+! MOD1's MY_GET) in MOD3's SUB.\n+!\n+! Original testcase by Salvator Filippone <sfilippone@uniroma2.it>\n+! Reduced by Janus Weil <janus@gcc.gnu.org>\n+\n+module mod1\n+  type :: t1\n+  contains\n+    procedure, nopass :: get => my_get\n+  end type\n+contains \n+  logical function my_get()\n+  end function\n+end module\n+\n+module mod2\n+contains \n+  logical function my_get()\n+  end function\n+end module\n+\n+module mod3\n+contains\n+  subroutine sub(a)\n+    use mod2, only: my_get\n+    use mod1, only: t1\n+    type(t1) :: a\n+  end subroutine\n+end module\n+\n+\n+use mod2, only: my_get\n+use mod3, only: sub\n+end \n+\n+\n+"}, {"sha": "b709347b0fd2308cc700b6db22403171f8b23c37", "filename": "gcc/testsuite/gfortran.dg/use_24.f90", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d932cea872a9146317fcb54a5957ef46bae4e107/gcc%2Ftestsuite%2Fgfortran.dg%2Fuse_24.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d932cea872a9146317fcb54a5957ef46bae4e107/gcc%2Ftestsuite%2Fgfortran.dg%2Fuse_24.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fuse_24.f90?ref=d932cea872a9146317fcb54a5957ef46bae4e107", "patch": "@@ -0,0 +1,53 @@\n+! { dg-do run }\n+!\n+! PR fortran/42769\n+! The static resolution of A%GET used to be incorrectly simplified to MOD2's\n+! MY_GET instead of the original MOD1's MY_GET, depending on the order in which\n+! MOD1 and MOD2 were use-associated.\n+!\n+! Original testcase by Salvator Filippone <sfilippone@uniroma2.it>\n+! Reduced by Janus Weil <janus@gcc.gnu.org>\n+\n+module mod1\n+  type :: t1\n+  contains\n+    procedure, nopass :: get => my_get\n+  end type\n+contains \n+  subroutine my_get(i)\n+    i = 2\n+  end subroutine\n+end module\n+\n+module mod2\n+contains \n+  subroutine my_get(i)    ! must have the same name as the function in mod1\n+    i = 5\n+  end subroutine\n+end module\n+\n+\n+ call test1()\n+ call test2()\n+\n+contains\n+\n+ subroutine test1()\n+  use mod2\n+  use mod1\n+  type(t1) :: a\n+  call a%get(j)\n+  if (j /= 2) call abort\n+ end subroutine test1\n+\n+ subroutine test2()\n+  use mod1\n+  use mod2\n+  type(t1) :: a\n+  call a%get(j)\n+  if (j /= 2) call abort\n+ end subroutine test2\n+end\n+\n+\n+"}, {"sha": "b79297f9fce992971db24a8b0e3cfe5a0ad6b66e", "filename": "gcc/testsuite/gfortran.dg/use_25.f90", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d932cea872a9146317fcb54a5957ef46bae4e107/gcc%2Ftestsuite%2Fgfortran.dg%2Fuse_25.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d932cea872a9146317fcb54a5957ef46bae4e107/gcc%2Ftestsuite%2Fgfortran.dg%2Fuse_25.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fuse_25.f90?ref=d932cea872a9146317fcb54a5957ef46bae4e107", "patch": "@@ -0,0 +1,39 @@\n+! { dg-do compile }\n+!\n+! PR fortran/42769\n+! This test used to be rejected because the typebound call A%GET was\n+! simplified to MY_GET which is an ambiguous name in the main program\n+! namespace.\n+!\n+! Original testcase by Salvator Filippone <sfilippone@uniroma2.it>\n+! Reduced by Janus Weil <janus@gcc.gnu.org>\n+\n+module mod1\n+  type :: t1\n+  contains\n+    procedure, nopass :: get => my_get\n+  end type\n+contains \n+  subroutine my_get()\n+    print *,\"my_get (mod1)\"\n+  end subroutine\n+end module\n+\n+module mod2\n+contains \n+  subroutine my_get()    ! must have the same name as the function in mod1\n+    print *,\"my_get (mod2)\"\n+  end subroutine\n+end module\n+\n+  use mod2\n+  use mod1\n+  type(t1) :: a\n+  call call_get\n+  contains\n+  subroutine call_get\n+    call a%get()\n+  end subroutine call_get\n+end\n+\n+"}, {"sha": "2e66401a14c861ae249d098172fa759f82671123", "filename": "gcc/testsuite/gfortran.dg/use_26.f90", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d932cea872a9146317fcb54a5957ef46bae4e107/gcc%2Ftestsuite%2Fgfortran.dg%2Fuse_26.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d932cea872a9146317fcb54a5957ef46bae4e107/gcc%2Ftestsuite%2Fgfortran.dg%2Fuse_26.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fuse_26.f90?ref=d932cea872a9146317fcb54a5957ef46bae4e107", "patch": "@@ -0,0 +1,76 @@\n+! { dg-do compile }\n+!\n+! PR fortran/45836\n+! The B_TYPE_INSTANCE%SIZERETURN() typebound function used to be rejected on a\n+! type mismatch because the function was resolved to A's SIZERETURN instead of\n+! B's because of the ambiguity of the SIZERETURN name in the MAIN namespace.\n+!\n+! Original testcase by someone <ortp21@gmail.com>\n+\n+module A\n+implicit none\n+    type :: a_type\n+    private\n+        integer :: size = 1\n+    contains\n+        procedure :: sizeReturn\n+    end type a_type\n+    contains\n+        function sizeReturn( a_type_ )\n+            implicit none\n+            integer :: sizeReturn\n+            class(a_type) :: a_type_\n+\n+            sizeReturn = a_type_%size\n+        end function sizeReturn\n+end module A\n+\n+module B\n+implicit none\n+    type :: b_type\n+    private\n+        integer :: size = 2\n+    contains\n+        procedure :: sizeReturn\n+    end type b_type\n+    contains\n+        function sizeReturn( b_type_ )\n+            implicit none\n+            integer :: sizeReturn\n+            class(b_type) :: b_type_\n+\n+            sizeReturn = b_type_%size\n+        end function sizeReturn\n+end module B\n+\n+program main\n+\n+  call test1\n+  call test2\n+\n+contains\n+\n+  subroutine test1\n+    use A\n+    use B\n+    implicit none\n+    type(a_type) :: a_type_instance\n+    type(b_type) :: b_type_instance\n+\n+    print *, a_type_instance%sizeReturn()\n+    print *, b_type_instance%sizeReturn()\n+  end subroutine test1\n+\n+  subroutine test2\n+    use B\n+    use A\n+    implicit none\n+    type(a_type) :: a_type_instance\n+    type(b_type) :: b_type_instance\n+\n+    print *, a_type_instance%sizeReturn()\n+    print *, b_type_instance%sizeReturn()\n+  end subroutine test2\n+end program main\n+\n+"}, {"sha": "71d77cc01804f4ca0c9db667556bcade9c541a54", "filename": "gcc/testsuite/gfortran.dg/use_27.f90", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d932cea872a9146317fcb54a5957ef46bae4e107/gcc%2Ftestsuite%2Fgfortran.dg%2Fuse_27.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d932cea872a9146317fcb54a5957ef46bae4e107/gcc%2Ftestsuite%2Fgfortran.dg%2Fuse_27.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fuse_27.f90?ref=d932cea872a9146317fcb54a5957ef46bae4e107", "patch": "@@ -0,0 +1,103 @@\n+! { dg-do run }\n+!\n+! PR fortran/45900\n+! The BTYPEINSTANCE%CALLBACK() typebound call was resolved incorrectly to\n+! A's CALLBACK procedure instead of B's because the CALLBACK name is ambiguous\n+! in the MAIN namespace.\n+!\n+! Original testcase by someone <ortp21@gmail.com>\n+\n+module A\n+implicit none\n+    type :: aType\n+    contains\n+        procedure :: callback\n+    end type aType\n+    contains\n+        subroutine callback( callback_, i )\n+            implicit none\n+            class(aType) :: callback_\n+            integer :: i\n+\n+            i = 3\n+        end subroutine callback\n+\n+        subroutine solver( callback_, i )\n+            implicit none\n+            class(aType) :: callback_\n+            integer :: i\n+\n+            call callback_%callback(i)\n+        end subroutine solver\n+end module A\n+\n+module B\n+use A, only: aType\n+implicit none\n+    type, extends(aType) :: bType\n+        integer :: i\n+    contains\n+        procedure :: callback\n+    end type bType\n+    contains\n+        subroutine callback( callback_, i )\n+            implicit none\n+            class(bType) :: callback_\n+            integer :: i\n+\n+            i = 7\n+        end subroutine callback\n+end module B\n+\n+program main\n+  call test1()\n+  call test2()\n+\n+contains\n+\n+  subroutine test1\n+    use A\n+    use B\n+    implicit none\n+    type(aType) :: aTypeInstance\n+    type(bType) :: bTypeInstance\n+    integer :: iflag\n+\n+    bTypeInstance%i = 4\n+\n+    iflag = 0\n+    call bTypeInstance%callback(iflag)\n+    if (iflag /= 7) call abort\n+    iflag = 1\n+    call solver( bTypeInstance, iflag )\n+    if (iflag /= 7) call abort\n+\n+    iflag = 2\n+    call aTypeInstance%callback(iflag)\n+    if (iflag /= 3) call abort\n+  end subroutine test1\n+\n+  subroutine test2\n+    use B\n+    use A\n+    implicit none\n+    type(aType) :: aTypeInstance\n+    type(bType) :: bTypeInstance\n+    integer :: iflag\n+\n+    bTypeInstance%i = 4\n+\n+    iflag = 0\n+    call bTypeInstance%callback(iflag)\n+    if (iflag /= 7) call abort\n+    iflag = 1\n+    call solver( bTypeInstance, iflag )\n+    if (iflag /= 7) call abort\n+\n+    iflag = 2\n+    call aTypeInstance%callback(iflag)\n+    if (iflag /= 3) call abort\n+  end subroutine test2\n+end program main\n+\n+"}]}