{"sha": "49abe0767c9b670ea05e674e698bd10f9bcb606f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDlhYmUwNzY3YzliNjcwZWEwNWU2NzRlNjk4YmQxMGY5YmNiNjA2Zg==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2016-01-15T19:33:33Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2016-01-15T19:33:33Z"}, "message": "re PR rtl-optimization/69030 (ICE on x86_64-linux-gnu at -O2 and above in 32-bit mode (ICE in copy_rtx, at rtl.c:358))\n\n2016-01-15  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR rtl-optimization/69030\n\t* lra-spills.c (remove_pseudos): Check nrefs and make the function\n\treturning bool.\n\t(spill_pseudos): Delete debug insn for dead pseudo.\n\t(lra_spill): Initiate spill_hard_reg and slots memory separately.\n\nFrom-SVN: r232445", "tree": {"sha": "c68e20774a0c3b350714b1e74bfb6ee1db9747a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c68e20774a0c3b350714b1e74bfb6ee1db9747a5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/49abe0767c9b670ea05e674e698bd10f9bcb606f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49abe0767c9b670ea05e674e698bd10f9bcb606f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49abe0767c9b670ea05e674e698bd10f9bcb606f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49abe0767c9b670ea05e674e698bd10f9bcb606f/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a579f4c752e8c172551cc7b7a13ccf4caaec3126", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a579f4c752e8c172551cc7b7a13ccf4caaec3126", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a579f4c752e8c172551cc7b7a13ccf4caaec3126"}], "stats": {"total": 185, "additions": 126, "deletions": 59}, "files": [{"sha": "e3dc3280a957db9085411175fd6a435aaa766d28", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49abe0767c9b670ea05e674e698bd10f9bcb606f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49abe0767c9b670ea05e674e698bd10f9bcb606f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=49abe0767c9b670ea05e674e698bd10f9bcb606f", "patch": "@@ -1,3 +1,11 @@\n+2016-01-15  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR rtl-optimization/69030\n+\t* lra-spills.c (remove_pseudos): Check nrefs and make the function\n+\treturning bool.\n+\t(spill_pseudos): Delete debug insn for dead pseudo.\n+\t(lra_spill): Initiate spill_hard_reg and slots memory separately.\n+\n 2016-01-15  Jiong Wang  <jiong.wang@arm.com>\n \n \t* config/aarch64/aarch64-builtins.c (aarch64_types_unopus_qualifiers):\n@@ -51,7 +59,7 @@\n \t(vcvtns_u32_f32): Likewise.\n \t(vcvtpd_u64_f64): Likewise.\n \t(vcvtps_u32_f32): Likewise.\n-\t\n+\n 2016-01-15  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* config/aarch64/aarch64.c (aarch64_if_then_else_costs): Handle"}, {"sha": "fa0a579d74c3e426f8bd7768591de33421508e30", "filename": "gcc/lra-spills.c", "status": "modified", "additions": 84, "deletions": 58, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49abe0767c9b670ea05e674e698bd10f9bcb606f/gcc%2Flra-spills.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49abe0767c9b670ea05e674e698bd10f9bcb606f/gcc%2Flra-spills.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-spills.c?ref=49abe0767c9b670ea05e674e698bd10f9bcb606f", "patch": "@@ -396,17 +396,19 @@ assign_stack_slot_num_and_sort_pseudos (int *pseudo_regnos, int n)\n \n /* Recursively process LOC in INSN and change spilled pseudos to the\n    corresponding memory or spilled hard reg.  Ignore spilled pseudos\n-   created from the scratches.\t*/\n-static void\n+   created from the scratches.  Return true if the pseudo nrefs equal\n+   to 0 (don't change the pseudo in this case).  Otherwise return false.  */\n+static bool\n remove_pseudos (rtx *loc, rtx_insn *insn)\n {\n   int i;\n   rtx hard_reg;\n   const char *fmt;\n   enum rtx_code code;\n-\n+  bool res = false;\n+  \n   if (*loc == NULL_RTX)\n-    return;\n+    return res;\n   code = GET_CODE (*loc);\n   if (code == REG && (i = REGNO (*loc)) >= FIRST_PSEUDO_REGISTER\n       && lra_get_regno_hard_regno (i) < 0\n@@ -416,6 +418,9 @@ remove_pseudos (rtx *loc, rtx_insn *insn)\n \t into scratches back.  */\n       && ! lra_former_scratch_p (i))\n     {\n+      if (lra_reg_info[i].nrefs == 0\n+\t  && pseudo_slots[i].mem == NULL && spill_hard_reg[i] == NULL)\n+\treturn true;\n       if ((hard_reg = spill_hard_reg[i]) != NULL_RTX)\n \t*loc = copy_rtx (hard_reg);\n       else\n@@ -425,22 +430,23 @@ remove_pseudos (rtx *loc, rtx_insn *insn)\n \t\t\t\t\tfalse, false, 0, true);\n \t  *loc = x != pseudo_slots[i].mem ? x : copy_rtx (x);\n \t}\n-      return;\n+      return res;\n     }\n \n   fmt = GET_RTX_FORMAT (code);\n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n     {\n       if (fmt[i] == 'e')\n-\tremove_pseudos (&XEXP (*loc, i), insn);\n+\tres = remove_pseudos (&XEXP (*loc, i), insn) || res;\n       else if (fmt[i] == 'E')\n \t{\n \t  int j;\n \n \t  for (j = XVECLEN (*loc, i) - 1; j >= 0; j--)\n-\t    remove_pseudos (&XVECEXP (*loc, i, j), insn);\n+\t    res = remove_pseudos (&XVECEXP (*loc, i, j), insn) || res;\n \t}\n     }\n+  return res;\n }\n \n /* Convert spilled pseudos into their stack slots or spill hard regs,\n@@ -450,7 +456,7 @@ static void\n spill_pseudos (void)\n {\n   basic_block bb;\n-  rtx_insn *insn;\n+  rtx_insn *insn, *curr;\n   int i;\n   bitmap_head spilled_pseudos, changed_insns;\n \n@@ -467,52 +473,70 @@ spill_pseudos (void)\n     }\n   FOR_EACH_BB_FN (bb, cfun)\n     {\n-      FOR_BB_INSNS (bb, insn)\n-\tif (bitmap_bit_p (&changed_insns, INSN_UID (insn)))\n-\t  {\n-\t    rtx *link_loc, link;\n-\t    remove_pseudos (&PATTERN (insn), insn);\n-\t    if (CALL_P (insn))\n-\t      remove_pseudos (&CALL_INSN_FUNCTION_USAGE (insn), insn);\n-\t    for (link_loc = &REG_NOTES (insn);\n-\t\t (link = *link_loc) != NULL_RTX;\n-\t\t link_loc = &XEXP (link, 1))\n-\t      {\n-\t\tswitch (REG_NOTE_KIND (link))\n-\t\t  {\n-\t\t  case REG_FRAME_RELATED_EXPR:\n-\t\t  case REG_CFA_DEF_CFA:\n-\t\t  case REG_CFA_ADJUST_CFA:\n-\t\t  case REG_CFA_OFFSET:\n-\t\t  case REG_CFA_REGISTER:\n-\t\t  case REG_CFA_EXPRESSION:\n-\t\t  case REG_CFA_RESTORE:\n-\t\t  case REG_CFA_SET_VDRAP:\n-\t\t    remove_pseudos (&XEXP (link, 0), insn);\n-\t\t    break;\n-\t\t  default:\n-\t\t    break;\n-\t\t  }\n-\t      }\n-\t    if (lra_dump_file != NULL)\n-\t      fprintf (lra_dump_file,\n-\t\t       \"Changing spilled pseudos to memory in insn #%u\\n\",\n-\t\t       INSN_UID (insn));\n-\t    lra_push_insn (insn);\n-\t    if (lra_reg_spill_p || targetm.different_addr_displacement_p ())\n-\t      lra_set_used_insn_alternative (insn, -1);\n-\t  }\n-\telse if (CALL_P (insn))\n-\t  /* Presence of any pseudo in CALL_INSN_FUNCTION_USAGE does\n-\t     not affect value of insn_bitmap of the corresponding\n-\t     lra_reg_info.  That is because we don't need to reload\n-\t     pseudos in CALL_INSN_FUNCTION_USAGEs.  So if we process\n-\t     only insns in the insn_bitmap of given pseudo here, we\n-\t     can miss the pseudo in some\n-\t     CALL_INSN_FUNCTION_USAGEs.  */\n-\t  remove_pseudos (&CALL_INSN_FUNCTION_USAGE (insn), insn);\n-      bitmap_and_compl_into (df_get_live_in (bb), &spilled_pseudos);\n-      bitmap_and_compl_into (df_get_live_out (bb), &spilled_pseudos);\n+      FOR_BB_INSNS_SAFE (bb, insn, curr)\n+\t{\n+\t  bool removed_pseudo_p = false;\n+\t  \n+\t  if (bitmap_bit_p (&changed_insns, INSN_UID (insn)))\n+\t    {\n+\t      rtx *link_loc, link;\n+\n+\t      removed_pseudo_p = remove_pseudos (&PATTERN (insn), insn);\n+\t      if (CALL_P (insn)\n+\t\t  && remove_pseudos (&CALL_INSN_FUNCTION_USAGE (insn), insn))\n+\t\tremoved_pseudo_p = true;\n+\t      for (link_loc = &REG_NOTES (insn);\n+\t\t   (link = *link_loc) != NULL_RTX;\n+\t\t   link_loc = &XEXP (link, 1))\n+\t\t{\n+\t\t  switch (REG_NOTE_KIND (link))\n+\t\t    {\n+\t\t    case REG_FRAME_RELATED_EXPR:\n+\t\t    case REG_CFA_DEF_CFA:\n+\t\t    case REG_CFA_ADJUST_CFA:\n+\t\t    case REG_CFA_OFFSET:\n+\t\t    case REG_CFA_REGISTER:\n+\t\t    case REG_CFA_EXPRESSION:\n+\t\t    case REG_CFA_RESTORE:\n+\t\t    case REG_CFA_SET_VDRAP:\n+\t\t      if (remove_pseudos (&XEXP (link, 0), insn))\n+\t\t\tremoved_pseudo_p = true;\n+\t\t      break;\n+\t\t    default:\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t      if (lra_dump_file != NULL)\n+\t\tfprintf (lra_dump_file,\n+\t\t\t \"Changing spilled pseudos to memory in insn #%u\\n\",\n+\t\t\t INSN_UID (insn));\n+\t      lra_push_insn (insn);\n+\t      if (lra_reg_spill_p || targetm.different_addr_displacement_p ())\n+\t\tlra_set_used_insn_alternative (insn, -1);\n+\t    }\n+\t  else if (CALL_P (insn)\n+\t\t   /* Presence of any pseudo in CALL_INSN_FUNCTION_USAGE\n+\t\t      does not affect value of insn_bitmap of the\n+\t\t      corresponding lra_reg_info.  That is because we\n+\t\t      don't need to reload pseudos in\n+\t\t      CALL_INSN_FUNCTION_USAGEs.  So if we process only\n+\t\t      insns in the insn_bitmap of given pseudo here, we\n+\t\t      can miss the pseudo in some\n+\t\t      CALL_INSN_FUNCTION_USAGEs.  */\n+\t\t   && remove_pseudos (&CALL_INSN_FUNCTION_USAGE (insn), insn))\n+\t    removed_pseudo_p = true;\n+\t  if (removed_pseudo_p)\n+\t    {\n+\t      lra_assert (DEBUG_INSN_P (insn));\n+\t      lra_set_insn_deleted (insn);\n+\t      if (lra_dump_file != NULL)\n+\t\tfprintf (lra_dump_file,\n+\t\t\t \"Debug insn #%u is deleted as containing removed pseudo\\n\",\n+\t\t\t INSN_UID (insn));\n+\t    }\n+\t  bitmap_and_compl_into (df_get_live_in (bb), &spilled_pseudos);\n+\t  bitmap_and_compl_into (df_get_live_out (bb), &spilled_pseudos);\n+\t}\n     }\n   bitmap_clear (&spilled_pseudos);\n   bitmap_clear (&changed_insns);\n@@ -548,12 +572,14 @@ lra_spill (void)\n     if (lra_reg_info[i].nrefs != 0 && lra_get_regno_hard_regno (i) < 0\n \t/* We do not want to assign memory for former scratches.  */\n \t&& ! lra_former_scratch_p (i))\n-      {\n-\tspill_hard_reg[i] = NULL_RTX;\n-\tpseudo_regnos[n++] = i;\n-      }\n+      pseudo_regnos[n++] = i;\n   lra_assert (n > 0);\n   pseudo_slots = XNEWVEC (struct pseudo_slot, regs_num);\n+  for (i = FIRST_PSEUDO_REGISTER; i < regs_num; i++)\n+    {\n+      spill_hard_reg[i] = NULL_RTX;\n+      pseudo_slots[i].mem = NULL_RTX;\n+    }\n   slots = XNEWVEC (struct slot, regs_num);\n   /* Sort regnos according their usage frequencies.  */\n   qsort (pseudo_regnos, n, sizeof (int), regno_freq_compare);"}, {"sha": "0a4e6e737bc505a8dbcb1e7c2fc18464e97dcb0c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49abe0767c9b670ea05e674e698bd10f9bcb606f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49abe0767c9b670ea05e674e698bd10f9bcb606f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=49abe0767c9b670ea05e674e698bd10f9bcb606f", "patch": "@@ -1,3 +1,8 @@\n+2016-01-15  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR rtl-optimization/69030\n+\t* gcc.target/i386/pr69030.c: New.\n+\n 2016-01-15  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* gcc.target/aarch64/target_attr_17.c: New test."}, {"sha": "30919c72c9139f469764c9160ea3ff18cec1a66f", "filename": "gcc/testsuite/gcc.target/i386/pr69030.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49abe0767c9b670ea05e674e698bd10f9bcb606f/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr69030.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49abe0767c9b670ea05e674e698bd10f9bcb606f/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr69030.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr69030.c?ref=49abe0767c9b670ea05e674e698bd10f9bcb606f", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -g -w\" } */\n+\n+int a, b, c = 7, d;\n+static unsigned e, g;\n+char f;\n+static unsigned fn1() {\n+  unsigned h = e - b ^ c;\n+  int i = h / c & a * g, j = g * h;\n+  if (h) {\n+    if (d)\n+      h = e;\n+    j = a;\n+    a = (a && (g % f && i) % h) | c | ~2;\n+    if (b)\n+      printf(\"\", 1);\n+  }\n+  c = i;\n+  a = j;\n+  return 2;\n+}\n+\n+int main() {\n+  for (; b < -18; --b)\n+    g = 0;\n+  fn1();\n+  return 0;\n+}"}]}