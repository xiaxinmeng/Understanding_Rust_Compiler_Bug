{"sha": "cde9d596263ef8fe62bda9c684e3203aac3d359f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2RlOWQ1OTYyNjNlZjhmZTYyYmRhOWM2ODRlMzIwM2FhYzNkMzU5Zg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2015-11-23T15:55:58Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2015-11-23T15:55:58Z"}, "message": "Add uaddv4_optab and usubv4_optab\n\n\tPR target/67089\n    \t* optabs.def (uaddv4_optab, usubv4_optab): New.\n    \t* internal-fn.c (expand_addsub_overflow): Use uaddv4_optab\n    \tand usubv4_optab in the u +- u -> u case.\n    \t* doc/md.texi (Standard Names): Document addv{m}4, subv{m}4,\n    \tmulv{m}4, uaddv{m}4, usubv{m}4, umulv{m}4.\n\n    \t* config/i386/i386.md (uaddv<SWI>4, usubv<SWI>4): New.\n\nFrom-SVN: r230767", "tree": {"sha": "ecbc7891727861ed13892cd5a688e7b0e3b06490", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ecbc7891727861ed13892cd5a688e7b0e3b06490"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cde9d596263ef8fe62bda9c684e3203aac3d359f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cde9d596263ef8fe62bda9c684e3203aac3d359f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cde9d596263ef8fe62bda9c684e3203aac3d359f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cde9d596263ef8fe62bda9c684e3203aac3d359f/comments", "author": null, "committer": null, "parents": [{"sha": "3789bf8412fb7ecde28694552d6c1f35a4e8ce52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3789bf8412fb7ecde28694552d6c1f35a4e8ce52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3789bf8412fb7ecde28694552d6c1f35a4e8ce52"}], "stats": {"total": 302, "additions": 210, "deletions": 92}, "files": [{"sha": "cd57e0c27a7d89a4bbf18145b2ec4ca31e73b838", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cde9d596263ef8fe62bda9c684e3203aac3d359f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cde9d596263ef8fe62bda9c684e3203aac3d359f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cde9d596263ef8fe62bda9c684e3203aac3d359f", "patch": "@@ -1,3 +1,19 @@\n+2015-11-23  Richard Henderson  <rth@redhat.com>\n+\n+\t* optabs.def (uaddv4_optab, usubv4_optab): New.\n+\t* internal-fn.c (expand_addsub_overflow): Use them.\n+\t* doc/md.texi (Standard Names): Add uaddv<m>4, usubv<m>4.\n+\n+\t* config/i386/i386.c (ix86_cc_mode): Extend add overflow check\n+\tto reversed operands.\n+\t* config/i386/i386.md (uaddv<SWI>4, usubv<SWI>4): New.\n+\t(*add<SWI>3_cconly_overflow_1): Rename *add<SWI>3_cconly_overflow.\n+\t(*add<SWI>3_cc_overflow_1): Rename *add<SWI>3_cc_overflow.\n+\t(*addsi3_zext_cc_overflow_1): Rename *add3_zext_cc_overflow.\n+\t(*add<SWI>3_cconly_overflow_2): New.\n+\t(*add<SWI>3_cc_overflow_2): New.\n+\t(*addsi3_zext_cc_overflow_2): New.\n+\n 2015-11-23  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/68465"}, {"sha": "cc4254427968255b8f67dcc5fae78e333a39846f", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cde9d596263ef8fe62bda9c684e3203aac3d359f/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cde9d596263ef8fe62bda9c684e3203aac3d359f/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=cde9d596263ef8fe62bda9c684e3203aac3d359f", "patch": "@@ -21137,7 +21137,8 @@ ix86_cc_mode (enum rtx_code code, rtx op0, rtx op1)\n     case LTU:\t\t\t/* CF=1 */\n       /* Detect overflow checks.  They need just the carry flag.  */\n       if (GET_CODE (op0) == PLUS\n-\t  && rtx_equal_p (op1, XEXP (op0, 0)))\n+\t  && (rtx_equal_p (op1, XEXP (op0, 0))\n+\t      || rtx_equal_p (op1, XEXP (op0, 1))))\n \treturn CCCmode;\n       else\n \treturn CCmode;"}, {"sha": "a57d165f21f89faf7975c2e50537cb7393621c52", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 74, "deletions": 3, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cde9d596263ef8fe62bda9c684e3203aac3d359f/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cde9d596263ef8fe62bda9c684e3203aac3d359f/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=cde9d596263ef8fe62bda9c684e3203aac3d359f", "patch": "@@ -6156,6 +6156,22 @@\n \t\t  (const_string \"4\")]\n \t      (const_string \"<MODE_SIZE>\")))])\n \n+(define_expand \"uaddv<mode>4\"\n+  [(parallel [(set (reg:CCC FLAGS_REG)\n+\t\t   (compare:CCC\n+\t\t     (plus:SWI\n+\t\t       (match_operand:SWI 1 \"nonimmediate_operand\")\n+\t\t       (match_operand:SWI 2 \"<general_operand>\"))\n+\t\t     (match_dup 1)))\n+\t      (set (match_operand:SWI 0 \"register_operand\")\n+\t\t   (plus:SWI (match_dup 1) (match_dup 2)))])\n+   (set (pc) (if_then_else\n+\t       (ltu (reg:CCC FLAGS_REG) (const_int 0))\n+\t       (label_ref (match_operand 3))\n+\t       (pc)))]\n+  \"\"\n+  \"ix86_fixup_binary_operands_no_copy (PLUS, <MODE>mode, operands);\")\n+\n ;; The lea patterns for modes less than 32 bits need to be matched by\n ;; several insns converted to real lea by splitters.\n \n@@ -6461,6 +6477,20 @@\n \t\t  (const_string \"4\")]\n \t      (const_string \"<MODE_SIZE>\")))])\n \n+(define_expand \"usubv<mode>4\"\n+  [(parallel [(set (reg:CC FLAGS_REG)\n+\t\t   (compare:CC\n+\t\t     (match_operand:SWI 1 \"nonimmediate_operand\")\n+\t\t     (match_operand:SWI 2 \"<general_operand>\")))\n+\t      (set (match_operand:SWI 0 \"register_operand\")\n+\t\t   (minus:SWI (match_dup 1) (match_dup 2)))])\n+   (set (pc) (if_then_else\n+\t       (ltu (reg:CC FLAGS_REG) (const_int 0))\n+\t       (label_ref (match_operand 3))\n+\t       (pc)))]\n+  \"\"\n+  \"ix86_fixup_binary_operands_no_copy (MINUS, <MODE>mode, operands);\")\n+\n (define_insn \"*sub<mode>_3\"\n   [(set (reg FLAGS_REG)\n \t(compare (match_operand:SWI 1 \"nonimmediate_operand\" \"0,0\")\n@@ -6611,7 +6641,7 @@\n       (clobber (match_scratch:QI 2))])]\n   \"!(MEM_P (operands[0]) && MEM_P (operands[1]))\")\n \n-(define_insn \"*add<mode>3_cconly_overflow\"\n+(define_insn \"*add<mode>3_cconly_overflow_1\"\n   [(set (reg:CCC FLAGS_REG)\n \t(compare:CCC\n \t  (plus:SWI\n@@ -6624,7 +6654,20 @@\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n-(define_insn \"*add<mode>3_cc_overflow\"\n+(define_insn \"*add<mode>3_cconly_overflow_2\"\n+  [(set (reg:CCC FLAGS_REG)\n+\t(compare:CCC\n+\t  (plus:SWI\n+\t    (match_operand:SWI 1 \"nonimmediate_operand\" \"%0\")\n+\t    (match_operand:SWI 2 \"<general_operand>\" \"<g>\"))\n+\t  (match_dup 2)))\n+   (clobber (match_scratch:SWI 0 \"=<r>\"))]\n+  \"!(MEM_P (operands[1]) && MEM_P (operands[2]))\"\n+  \"add{<imodesuffix>}\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"*add<mode>3_cc_overflow_1\"\n   [(set (reg:CCC FLAGS_REG)\n \t(compare:CCC\n \t    (plus:SWI\n@@ -6638,7 +6681,21 @@\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n-(define_insn \"*addsi3_zext_cc_overflow\"\n+(define_insn \"*add<mode>3_cc_overflow_2\"\n+  [(set (reg:CCC FLAGS_REG)\n+\t(compare:CCC\n+\t    (plus:SWI\n+\t\t(match_operand:SWI 1 \"nonimmediate_operand\" \"%0,0\")\n+\t\t(match_operand:SWI 2 \"<general_operand>\" \"<r><i>,<r>m\"))\n+\t    (match_dup 2)))\n+   (set (match_operand:SWI 0 \"nonimmediate_operand\" \"=<r>m,<r>\")\n+\t(plus:SWI (match_dup 1) (match_dup 2)))]\n+  \"ix86_binary_operator_ok (PLUS, <MODE>mode, operands)\"\n+  \"add{<imodesuffix>}\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"*addsi3_zext_cc_overflow_1\"\n   [(set (reg:CCC FLAGS_REG)\n \t(compare:CCC\n \t  (plus:SI\n@@ -6652,6 +6709,20 @@\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"mode\" \"SI\")])\n \n+(define_insn \"*addsi3_zext_cc_overflow_2\"\n+  [(set (reg:CCC FLAGS_REG)\n+\t(compare:CCC\n+\t  (plus:SI\n+\t    (match_operand:SI 1 \"nonimmediate_operand\" \"%0\")\n+\t    (match_operand:SI 2 \"x86_64_general_operand\" \"rme\"))\n+\t  (match_dup 2)))\n+   (set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:DI (plus:SI (match_dup 1) (match_dup 2))))]\n+  \"TARGET_64BIT && ix86_binary_operator_ok (PLUS, SImode, operands)\"\n+  \"add{l}\\t{%2, %k0|%k0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"mode\" \"SI\")])\n+\n ;; The patterns that match these are at the end of this file.\n \n (define_expand \"<plusminus_insn>xf3\""}, {"sha": "de1b58a985e301bc7b3048aec744897d9ba0efcc", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cde9d596263ef8fe62bda9c684e3203aac3d359f/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cde9d596263ef8fe62bda9c684e3203aac3d359f/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=cde9d596263ef8fe62bda9c684e3203aac3d359f", "patch": "@@ -4913,12 +4913,17 @@ signed integer addition with overflow checking.\n @item @samp{subv@var{m}4}, @samp{mulv@var{m}4}\n Similar, for other signed arithmetic operations.\n \n-@cindex @code{umulv@var{m}4} instruction pattern\n-@item @samp{umulv@var{m}4}\n-Like @code{mulv@var{m}4} but for unsigned multiplication.  That is to\n-say, the operation is the same as signed multiplication but the jump\n+@cindex @code{uaddv@var{m}4} instruction pattern\n+@item @samp{uaddv@var{m}4}\n+Like @code{addv@var{m}4} but for unsigned addition.  That is to\n+say, the operation is the same as signed addition but the jump\n is taken only on unsigned overflow.\n \n+@cindex @code{usubv@var{m}4} instruction pattern\n+@cindex @code{umulv@var{m}4} instruction pattern\n+@item @samp{usubv@var{m}4}, @samp{umulv@var{m}4}\n+Similar, for other unsigned arithmetic operations.\n+\n @cindex @code{addptr@var{m}3} instruction pattern\n @item @samp{addptr@var{m}3}\n Like @code{add@var{m}3} but is guaranteed to only be used for address"}, {"sha": "b15657f442bd81720523478058ef14e2ab37f59a", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 107, "deletions": 84, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cde9d596263ef8fe62bda9c684e3203aac3d359f/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cde9d596263ef8fe62bda9c684e3203aac3d359f/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=cde9d596263ef8fe62bda9c684e3203aac3d359f", "patch": "@@ -546,6 +546,33 @@ expand_addsub_overflow (location_t loc, tree_code code, tree lhs,\n   /* u1 +- u2 -> ur  */\n   if (uns0_p && uns1_p && unsr_p)\n     {\n+      insn_code icode = optab_handler (code == PLUS_EXPR ? uaddv4_optab\n+                                       : usubv4_optab, mode);\n+      if (icode != CODE_FOR_nothing)\n+\t{\n+\t  struct expand_operand ops[4];\n+\t  rtx_insn *last = get_last_insn ();\n+\n+\t  res = gen_reg_rtx (mode);\n+\t  create_output_operand (&ops[0], res, mode);\n+\t  create_input_operand (&ops[1], op0, mode);\n+\t  create_input_operand (&ops[2], op1, mode);\n+\t  create_fixed_operand (&ops[3], do_error);\n+\t  if (maybe_expand_insn (icode, 4, ops))\n+\t    {\n+\t      last = get_last_insn ();\n+\t      if (profile_status_for_fn (cfun) != PROFILE_ABSENT\n+\t\t  && JUMP_P (last)\n+\t\t  && any_condjump_p (last)\n+\t\t  && !find_reg_note (last, REG_BR_PROB, 0))\n+\t\tadd_int_reg_note (last, REG_BR_PROB, PROB_VERY_UNLIKELY);\n+\t      emit_jump (done_label);\n+\t      goto do_error_label;\n+\t    }\n+\n+\t  delete_insns_since (last);\n+\t}\n+\n       /* Compute the operation.  On RTL level, the addition is always\n \t unsigned.  */\n       res = expand_binop (mode, code == PLUS_EXPR ? add_optab : sub_optab,\n@@ -737,92 +764,88 @@ expand_addsub_overflow (location_t loc, tree_code code, tree lhs,\n   gcc_assert (!uns0_p && !uns1_p && !unsr_p);\n \n   /* s1 +- s2 -> sr  */\n- do_signed: ;\n-  enum insn_code icode;\n-  icode = optab_handler (code == PLUS_EXPR ? addv4_optab : subv4_optab, mode);\n-  if (icode != CODE_FOR_nothing)\n-    {\n-      struct expand_operand ops[4];\n-      rtx_insn *last = get_last_insn ();\n-\n-      res = gen_reg_rtx (mode);\n-      create_output_operand (&ops[0], res, mode);\n-      create_input_operand (&ops[1], op0, mode);\n-      create_input_operand (&ops[2], op1, mode);\n-      create_fixed_operand (&ops[3], do_error);\n-      if (maybe_expand_insn (icode, 4, ops))\n-\t{\n-\t  last = get_last_insn ();\n-\t  if (profile_status_for_fn (cfun) != PROFILE_ABSENT\n-\t      && JUMP_P (last)\n-\t      && any_condjump_p (last)\n-\t      && !find_reg_note (last, REG_BR_PROB, 0))\n-\t    add_int_reg_note (last, REG_BR_PROB, PROB_VERY_UNLIKELY);\n-\t  emit_jump (done_label);\n-        }\n-      else\n-\t{\n-\t  delete_insns_since (last);\n-\t  icode = CODE_FOR_nothing;\n-\t}\n-    }\n-\n-  if (icode == CODE_FOR_nothing)\n-    {\n-      rtx_code_label *sub_check = gen_label_rtx ();\n-      int pos_neg = 3;\n-\n-      /* Compute the operation.  On RTL level, the addition is always\n-\t unsigned.  */\n-      res = expand_binop (mode, code == PLUS_EXPR ? add_optab : sub_optab,\n-\t\t\t  op0, op1, NULL_RTX, false, OPTAB_LIB_WIDEN);\n-\n-      /* If we can prove one of the arguments (for MINUS_EXPR only\n-\t the second operand, as subtraction is not commutative) is always\n-\t non-negative or always negative, we can do just one comparison\n-\t and conditional jump instead of 2 at runtime, 3 present in the\n-\t emitted code.  If one of the arguments is CONST_INT, all we\n-\t need is to make sure it is op1, then the first\n-\t do_compare_rtx_and_jump will be just folded.  Otherwise try\n-\t to use range info if available.  */\n-      if (code == PLUS_EXPR && CONST_INT_P (op0))\n-\tstd::swap (op0, op1);\n-      else if (CONST_INT_P (op1))\n-\t;\n-      else if (code == PLUS_EXPR && TREE_CODE (arg0) == SSA_NAME)\n-\t{\n-\t  pos_neg = get_range_pos_neg (arg0);\n-\t  if (pos_neg != 3)\n-\t    std::swap (op0, op1);\n-\t}\n-      if (pos_neg == 3 && !CONST_INT_P (op1) && TREE_CODE (arg1) == SSA_NAME)\n-\tpos_neg = get_range_pos_neg (arg1);\n-\n-      /* If the op1 is negative, we have to use a different check.  */\n-      if (pos_neg == 3)\n-\tdo_compare_rtx_and_jump (op1, const0_rtx, LT, false, mode, NULL_RTX,\n-\t\t\t\t NULL, sub_check, PROB_EVEN);\n-\n-      /* Compare the result of the operation with one of the operands.  */\n-      if (pos_neg & 1)\n-\tdo_compare_rtx_and_jump (res, op0, code == PLUS_EXPR ? GE : LE,\n-\t\t\t\t false, mode, NULL_RTX, NULL, done_label,\n-\t\t\t\t PROB_VERY_LIKELY);\n-\n-      /* If we get here, we have to print the error.  */\n-      if (pos_neg == 3)\n-\t{\n-\t  emit_jump (do_error);\n+ do_signed:\n+  {\n+    insn_code icode = optab_handler (code == PLUS_EXPR ? addv4_optab\n+\t\t\t\t     : subv4_optab, mode);\n+    if (icode != CODE_FOR_nothing)\n+      {\n+\tstruct expand_operand ops[4];\n+\trtx_insn *last = get_last_insn ();\n+\n+\tres = gen_reg_rtx (mode);\n+\tcreate_output_operand (&ops[0], res, mode);\n+\tcreate_input_operand (&ops[1], op0, mode);\n+\tcreate_input_operand (&ops[2], op1, mode);\n+\tcreate_fixed_operand (&ops[3], do_error);\n+\tif (maybe_expand_insn (icode, 4, ops))\n+\t  {\n+\t    last = get_last_insn ();\n+\t    if (profile_status_for_fn (cfun) != PROFILE_ABSENT\n+\t\t&& JUMP_P (last)\n+\t\t&& any_condjump_p (last)\n+\t\t&& !find_reg_note (last, REG_BR_PROB, 0))\n+\t      add_int_reg_note (last, REG_BR_PROB, PROB_VERY_UNLIKELY);\n+\t    emit_jump (done_label);\n+\t    goto do_error_label;\n+\t  }\n+\n+\tdelete_insns_since (last);\n+      }\n+\n+    rtx_code_label *sub_check = gen_label_rtx ();\n+    int pos_neg = 3;\n+\n+    /* Compute the operation.  On RTL level, the addition is always\n+       unsigned.  */\n+    res = expand_binop (mode, code == PLUS_EXPR ? add_optab : sub_optab,\n+\t\t\top0, op1, NULL_RTX, false, OPTAB_LIB_WIDEN);\n+\n+    /* If we can prove one of the arguments (for MINUS_EXPR only\n+       the second operand, as subtraction is not commutative) is always\n+       non-negative or always negative, we can do just one comparison\n+       and conditional jump instead of 2 at runtime, 3 present in the\n+       emitted code.  If one of the arguments is CONST_INT, all we\n+       need is to make sure it is op1, then the first\n+       do_compare_rtx_and_jump will be just folded.  Otherwise try\n+       to use range info if available.  */\n+    if (code == PLUS_EXPR && CONST_INT_P (op0))\n+      std::swap (op0, op1);\n+    else if (CONST_INT_P (op1))\n+      ;\n+    else if (code == PLUS_EXPR && TREE_CODE (arg0) == SSA_NAME)\n+      {\n+        pos_neg = get_range_pos_neg (arg0);\n+        if (pos_neg != 3)\n+\t  std::swap (op0, op1);\n+      }\n+    if (pos_neg == 3 && !CONST_INT_P (op1) && TREE_CODE (arg1) == SSA_NAME)\n+      pos_neg = get_range_pos_neg (arg1);\n+\n+    /* If the op1 is negative, we have to use a different check.  */\n+    if (pos_neg == 3)\n+      do_compare_rtx_and_jump (op1, const0_rtx, LT, false, mode, NULL_RTX,\n+\t\t\t       NULL, sub_check, PROB_EVEN);\n+\n+    /* Compare the result of the operation with one of the operands.  */\n+    if (pos_neg & 1)\n+      do_compare_rtx_and_jump (res, op0, code == PLUS_EXPR ? GE : LE,\n+\t\t\t       false, mode, NULL_RTX, NULL, done_label,\n+\t\t\t       PROB_VERY_LIKELY);\n \n-\t  emit_label (sub_check);\n-\t}\n+    /* If we get here, we have to print the error.  */\n+    if (pos_neg == 3)\n+      {\n+\temit_jump (do_error);\n+\temit_label (sub_check);\n+      }\n \n-      /* We have k = a + b for b < 0 here.  k <= a must hold.  */\n-      if (pos_neg & 2)\n-\tdo_compare_rtx_and_jump (res, op0, code == PLUS_EXPR ? LE : GE,\n-\t\t\t\t false, mode, NULL_RTX, NULL, done_label,\n-\t\t\t\t PROB_VERY_LIKELY);\n-    }\n+    /* We have k = a + b for b < 0 here.  k <= a must hold.  */\n+    if (pos_neg & 2)\n+      do_compare_rtx_and_jump (res, op0, code == PLUS_EXPR ? LE : GE,\n+\t\t\t       false, mode, NULL_RTX, NULL, done_label,\n+\t\t\t       PROB_VERY_LIKELY);\n+  }\n \n  do_error_label:\n   emit_label (do_error);"}, {"sha": "c141a3ca6fffc031e27318814a0f12405b4c0ec1", "filename": "gcc/optabs.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cde9d596263ef8fe62bda9c684e3203aac3d359f/gcc%2Foptabs.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cde9d596263ef8fe62bda9c684e3203aac3d359f/gcc%2Foptabs.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.def?ref=cde9d596263ef8fe62bda9c684e3203aac3d359f", "patch": "@@ -197,6 +197,8 @@ OPTAB_D (ctrap_optab, \"ctrap$a4\")\n OPTAB_D (addv4_optab, \"addv$I$a4\")\n OPTAB_D (subv4_optab, \"subv$I$a4\")\n OPTAB_D (mulv4_optab, \"mulv$I$a4\")\n+OPTAB_D (uaddv4_optab, \"uaddv$I$a4\")\n+OPTAB_D (usubv4_optab, \"usubv$I$a4\")\n OPTAB_D (umulv4_optab, \"umulv$I$a4\")\n OPTAB_D (negv3_optab, \"negv$I$a3\")\n OPTAB_D (addptr3_optab, \"addptr$a3\")"}]}