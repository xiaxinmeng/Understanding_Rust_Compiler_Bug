{"sha": "b6f571b7d3f815d36a5c6a6d91c9e6c87b824206", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjZmNTcxYjdkM2Y4MTVkMzZhNWM2YTZkOTFjOWU2Yzg3YjgyNDIwNg==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2005-07-30T05:33:39Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2005-07-30T05:33:39Z"}, "message": "PR fortran/22570 and related issues.\n\n2005-07-30 Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/22570 and related issues.\n\t* transfer.c (formatted_transfer): Make sure that there\n\treally is data present before X- or T- editing. Move all\n\ttreatment of tabbing during writes to start of next data\n\tproducing format. Suppress incorrect zeroing of bytes_left\n\tin slash formating. Insert int cast for assignment of a\n\tdifference of two gfc_offsets.\n\n\tPR fortran/22570 an related issues.\n\t* gfortran.dg/x_slash_1.f: New test.\n\nFrom-SVN: r102583", "tree": {"sha": "d1f71752d784e659f5544b3649b25b016e7c2462", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d1f71752d784e659f5544b3649b25b016e7c2462"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b6f571b7d3f815d36a5c6a6d91c9e6c87b824206", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6f571b7d3f815d36a5c6a6d91c9e6c87b824206", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6f571b7d3f815d36a5c6a6d91c9e6c87b824206", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6f571b7d3f815d36a5c6a6d91c9e6c87b824206/comments", "author": null, "committer": null, "parents": [{"sha": "0cbc4d773a832fcda2aaa9c5dae163b2038af2e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0cbc4d773a832fcda2aaa9c5dae163b2038af2e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0cbc4d773a832fcda2aaa9c5dae163b2038af2e3"}], "stats": {"total": 173, "additions": 156, "deletions": 17}, "files": [{"sha": "ec62a9581a729d8b7e6570260a3724a90731e1d1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6f571b7d3f815d36a5c6a6d91c9e6c87b824206/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6f571b7d3f815d36a5c6a6d91c9e6c87b824206/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b6f571b7d3f815d36a5c6a6d91c9e6c87b824206", "patch": "@@ -1,3 +1,8 @@\n+2005-07-30 Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/22570 an related issues.\n+\t* gfortran.dg/x_slash_1.f: New test.\n+\n 2005-07-30  Joseph S. Myers  <joseph@codesourcery.com>\n \n \tPR c/23143"}, {"sha": "f4f9ed2281c30baacaa066c06d60cb3a04a72934", "filename": "gcc/testsuite/gfortran.dg/x_slash_1.f", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6f571b7d3f815d36a5c6a6d91c9e6c87b824206/gcc%2Ftestsuite%2Fgfortran.dg%2Fx_slash_1.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6f571b7d3f815d36a5c6a6d91c9e6c87b824206/gcc%2Ftestsuite%2Fgfortran.dg%2Fx_slash_1.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fx_slash_1.f?ref=b6f571b7d3f815d36a5c6a6d91c9e6c87b824206", "patch": "@@ -0,0 +1,116 @@\n+c { dg-do run }\n+c This program tests the fixes to PR22570.\n+c\n+c Provided by Paul Thomas - pault@gcc.gnu.org\n+c\n+       program x_slash\n+       character*60 a\n+       character*1  b, c\n+\n+       open (10, status = \"scratch\")\n+\n+c Check that lines with only x-editing followed by a slash generate\n+c spaces and that subsequent lines have spaces where they should.\n+c Line 1 we ignore.\n+c Line 2 has nothing but x editing, followed by a slash.\n+c Line 3 has x editing finished off by a 1h*\n+\n+       write (10, 100)\n+ 100   format (1h1,58x,1h!,/,60x,/,59x,1h*,/)\n+       rewind (10)\n+\n+       read (10, 200) a\n+       read (10, 200) a\n+       do i = 1,60\n+         if (ichar(a(i:i)).ne.32) call abort ()\n+       end do\n+       read (10, 200) a\n+ 200   format (a60)\n+       do i = 1,59\n+         if (ichar(a(i:i)).ne.32) call abort ()\n+       end do\n+       if (a(60:60).ne.\"*\") call abort ()\n+       rewind (10)\n+\n+c Check that sequences of t- and x-editing generate the correct \n+c number of spaces.\n+c Line 1 we ignore.\n+c Line 2 has tabs to the right of present position.\n+c Line 3 has tabs to the left of present position.\n+\n+       write (10, 101)\n+ 101   format (1h1,58x,1h#,/,t38,2x,1h ,tr10,9x,1h$,/,\n+     >         6habcdef,tl4,2x,6hghijkl,t1,59x,1h*)\n+       rewind (10)\n+\n+       read (10, 200) a\n+       read (10, 200) a\n+       do i = 1,59\n+         if (ichar(a(i:i)).ne.32) call abort ()\n+       end do\n+       if (a(60:60).ne.\"$\") call abort ()\n+       read (10, 200) a\n+       if (a(1:10).ne.\"abcdghijkl\") call abort ()\n+       do i = 11,59\n+         if (ichar(a(i:i)).ne.32) call abort ()\n+       end do\n+       if (a(60:60).ne.\"*\") call abort ()\n+       rewind (10)\n+\n+c Now repeat the first test, with the write broken up into three\n+c separate statements. This checks that the position counters are\n+c correctly reset for each statement.\n+\n+       write (10,102) \"#\"\n+       write (10,103)\n+       write (10,102) \"$\"\n+ 102   format(59x,a1)\n+ 103   format(60x)\n+       rewind (10)\n+       read (10, 200) a\n+       read (10, 200) a\n+       read (10, 200) a\n+       do i = 11,59\n+         if (ichar(a(i:i)).ne.32) call abort ()\n+       end do\n+       if (a(60:60).ne.\"$\") call abort ()\n+       rewind (10)\n+\n+c Next we check multiple read x- and t-editing.\n+c First, tab to the right.\n+\n+       read (10, 201) b, c\n+201    format (tr10,49x,a1,/,/,2x,t60,a1)\n+       if ((b.ne.\"#\").or.(c.ne.\"$\")) call abort ()\n+       rewind (10)\n+\n+c Now break it up into three reads and use left tabs.\n+\n+       read (10, 202) b\n+202    format (10x,tl10,59x,a1)\n+       read (10, 203)\n+203    format ()\n+       read (10, 204) c\n+204    format (10x,t5,55x,a1)\n+       if ((b.ne.\"#\").or.(c.ne.\"$\")) call abort ()\n+       close (10)\n+\n+c Now, check that trailing spaces are not transmitted when we have\n+c run out of data (Thanks to Jack Howarth for finding this one:\n+c http://gcc.gnu.org/ml/fortran/2005-07/msg00395.html).\n+\n+       open (10, pad = \"no\", status = \"scratch\")\n+       b = achar (0)\n+       write (10, 105) 42\n+  105  format (i10,1x,i10)\n+       write (10, 106)\n+  106  format (\"============================\")\n+       rewind (10)\n+       read (10, 205, iostat = ier) i, b\n+  205  format (i10,a1)\n+       if ((ier.eq.0).or.(ichar(b).ne.0)) call abort ()\n+\n+c That's all for now, folks! \n+\n+       end\n+"}, {"sha": "84bcc4843f3243ec481cffe21923f7234cf52510", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6f571b7d3f815d36a5c6a6d91c9e6c87b824206/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6f571b7d3f815d36a5c6a6d91c9e6c87b824206/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=b6f571b7d3f815d36a5c6a6d91c9e6c87b824206", "patch": "@@ -1,3 +1,13 @@\n+2005-07-30 Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/22570 and related issues.\n+\t* transfer.c (formatted_transfer): Make sure that there\n+\treally is data present before X- or T- editing. Move all\n+\ttreatment of tabbing during writes to start of next data\n+\tproducing format. Suppress incorrect zeroing of bytes_left\n+\tin slash formating. Insert int cast for assignment of a\n+\tdifference of two gfc_offsets.\n+\n 2005-07-23  Jerry DeLisle  <jvdelisle@verizon.net>\n \n \t* io/write.c (write_float): Revise output of IEEE exceptional"}, {"sha": "357e090f2b7bbb2c740560f7c507065ae23882da", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 25, "deletions": 17, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6f571b7d3f815d36a5c6a6d91c9e6c87b824206/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6f571b7d3f815d36a5c6a6d91c9e6c87b824206/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=b6f571b7d3f815d36a5c6a6d91c9e6c87b824206", "patch": "@@ -480,16 +480,25 @@ formatted_transfer (bt type, void *p, int len)\n \treturn;\t      /* No data descriptors left (already raised).  */\n \n       /* Now discharge T, TR and X movements to the right.  This is delayed\n-\t until a data producing format to supress trailing spaces.  */\n+\t until a data producing format to suppress trailing spaces.  */\n       t = f->format;\n-      if (g.mode == WRITING && skips > 0\n-\t&&    (t == FMT_I || t == FMT_B || t == FMT_O || t == FMT_Z\n-\t    || t == FMT_F || t == FMT_E || t == FMT_EN || t == FMT_ES\n-\t    || t == FMT_G || t == FMT_L || t == FMT_A || t == FMT_D\n+      if (g.mode == WRITING && skips != 0\n+\t&& ((n>0 && (  t == FMT_I  || t == FMT_B  || t == FMT_O\n+\t\t    || t == FMT_Z  || t == FMT_F  || t == FMT_E\n+\t\t    || t == FMT_EN || t == FMT_ES || t == FMT_G\n+\t\t    || t == FMT_L  || t == FMT_A  || t == FMT_D))\n \t    || t == FMT_STRING))\n \t{\n-\t  write_x (skips, pending_spaces);\n-\t  max_pos = (int)(current_unit->recl - current_unit->bytes_left);\n+\t  if (skips > 0)\n+\t    {\n+\t      write_x (skips, pending_spaces);\n+\t      max_pos = (int)(current_unit->recl - current_unit->bytes_left);\n+\t    }\n+\t  if (skips < 0)\n+\t    {\n+\t      move_pos_offset (current_unit->s, skips);\n+\t      current_unit->bytes_left -= (gfc_offset)skips;\n+\t    }\n \t  skips = pending_spaces = 0;\n \t}\n \n@@ -724,19 +733,19 @@ formatted_transfer (bt type, void *p, int len)\n \n \t  /* Writes occur just before the switch on f->format, above, so that\n \t     trailing blanks are suppressed.  */\n-\t  if (skips > 0)\n+\t  if (g.mode == READING)\n \t    {\n-\t      if (g.mode == READING)\n+\t      if (skips > 0)\n \t\t{\n \t\t  f->u.n = skips;\n \t\t  read_x (f);\n \t\t}\n-\t    }\n-\t  if (skips < 0)\n-\t    {\n-\t      move_pos_offset (current_unit->s, skips);\n-\t      current_unit->bytes_left -= skips;\n-\t      skips = pending_spaces = 0;\n+\t      if (skips < 0)\n+\t\t{\n+\t\t  move_pos_offset (current_unit->s, skips);\n+\t\t  current_unit->bytes_left -= (gfc_offset)skips;\n+\t\t  skips = pending_spaces = 0;\n+\t\t}\n \t    }\n \n \t  break;\n@@ -779,7 +788,6 @@ formatted_transfer (bt type, void *p, int len)\n \tcase FMT_SLASH:\n \t  consume_data_flag = 0 ;\n \t  skips = pending_spaces = 0;\n-\t  current_unit->bytes_left = 0;\n \t  next_record (0);\n \t  break;\n \n@@ -818,7 +826,7 @@ formatted_transfer (bt type, void *p, int len)\n       if (g.mode == READING)\n \tskips = 0;\n \n-      pos = current_unit->recl - current_unit->bytes_left;\n+      pos = (int)(current_unit->recl - current_unit->bytes_left);\n       max_pos = (max_pos > pos) ? max_pos : pos;\n \n     }"}]}