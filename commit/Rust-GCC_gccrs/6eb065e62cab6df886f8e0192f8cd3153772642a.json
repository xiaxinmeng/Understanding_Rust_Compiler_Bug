{"sha": "6eb065e62cab6df886f8e0192f8cd3153772642a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmViMDY1ZTYyY2FiNmRmODg2ZjhlMDE5MmY4Y2QzMTUzNzcyNjQyYQ==", "commit": {"author": {"name": "Sterling Augustine", "email": "sterling@tensilica.com", "date": "2007-11-13T22:41:50Z"}, "committer": {"name": "Bob Wilson", "email": "bwilson@gcc.gnu.org", "date": "2007-11-13T22:41:50Z"}, "message": "unwind-dw2-xtensa.c: New.\n\n\t* config/xtensa/unwind-dw2-xtensa.c: New.\n\t* config/xtensa/unwind-dw2-xtensa.h: New.\n\t* config/xtensa/xtensa.h (MUST_USE_SJLJ_EXCEPTIONS): Remove.\n\t(DWARF2_UNWIND_INFO): Remove.\n\t(DWARF_FRAME_REGISTERS): Define.\n\t(EH_RETURN_DATA_REGNO): Define.\n\t* config/xtensa/xtensa.md (UNSPECV_EH_RETURN): Define.\n\t(eh_return): New.\n\t* config/xtensa/t-xtensa (LIB2ADDEH): Define.\n\nCo-Authored-By: Bob Wilson <bob.wilson@acm.org>\n\nFrom-SVN: r130160", "tree": {"sha": "a5fc28e4335068f95fba5d755544b3369c28b81e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a5fc28e4335068f95fba5d755544b3369c28b81e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6eb065e62cab6df886f8e0192f8cd3153772642a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6eb065e62cab6df886f8e0192f8cd3153772642a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6eb065e62cab6df886f8e0192f8cd3153772642a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6eb065e62cab6df886f8e0192f8cd3153772642a/comments", "author": null, "committer": null, "parents": [{"sha": "b423089ec2c2f36aa263dd60f123876dcdef8e1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b423089ec2c2f36aa263dd60f123876dcdef8e1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b423089ec2c2f36aa263dd60f123876dcdef8e1c"}], "stats": {"total": 650, "additions": 646, "deletions": 4}, "files": [{"sha": "d4517ad5646582a0564081d0f9d34200c17686e6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eb065e62cab6df886f8e0192f8cd3153772642a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eb065e62cab6df886f8e0192f8cd3153772642a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6eb065e62cab6df886f8e0192f8cd3153772642a", "patch": "@@ -1,3 +1,16 @@\n+2007-11-13  Sterling Augustine  <sterling@tensilica.com>\n+\t    Bob Wilson  <bob.wilson@acm.org>\n+\t\n+\t* config/xtensa/unwind-dw2-xtensa.c: New.\n+\t* config/xtensa/unwind-dw2-xtensa.h: New.\n+\t* config/xtensa/xtensa.h (MUST_USE_SJLJ_EXCEPTIONS): Remove.\n+\t(DWARF2_UNWIND_INFO): Remove.\n+\t(DWARF_FRAME_REGISTERS): Define.\n+\t(EH_RETURN_DATA_REGNO): Define.\n+\t* config/xtensa/xtensa.md (UNSPECV_EH_RETURN): Define.\n+\t(eh_return): New.\n+\t* config/xtensa/t-xtensa (LIB2ADDEH): Define.\n+\t\n 2007-11-13  Jakub Jelinek  <jakub@redhat.com>\n \n \t* doc/invoke.texi: Fix description of -fsched-stalled-insns=0,"}, {"sha": "b0a7e8115e452e4a98821e77f3ac2462d0beda6c", "filename": "gcc/config/xtensa/t-xtensa", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eb065e62cab6df886f8e0192f8cd3153772642a/gcc%2Fconfig%2Fxtensa%2Ft-xtensa", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eb065e62cab6df886f8e0192f8cd3153772642a/gcc%2Fconfig%2Fxtensa%2Ft-xtensa", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Ft-xtensa?ref=6eb065e62cab6df886f8e0192f8cd3153772642a", "patch": "@@ -11,6 +11,8 @@ LIB1ASMFUNCS = _mulsi3 _divsi3 _modsi3 _udivsi3 _umodsi3 \\\n \t_truncdfsf2 _extendsfdf2\n \n LIB2FUNCS_EXTRA = $(srcdir)/config/xtensa/lib2funcs.S\n+LIB2ADDEH = $(srcdir)/config/xtensa/unwind-dw2-xtensa.c \\\n+   $(srcdir)/unwind-dw2-fde.c $(srcdir)/unwind-sjlj.c $(srcdir)/unwind-c.c\n \n $(T)crti.o: $(srcdir)/config/xtensa/crti.asm $(GCC_PASSES)\n \t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(MULTILIB_CFLAGS) $(INCLUDES) \\"}, {"sha": "1dd4f9dee3f1bed723ef9f91d9731a4054049c0f", "filename": "gcc/config/xtensa/unwind-dw2-xtensa.c", "status": "added", "additions": 546, "deletions": 0, "changes": 546, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eb065e62cab6df886f8e0192f8cd3153772642a/gcc%2Fconfig%2Fxtensa%2Funwind-dw2-xtensa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eb065e62cab6df886f8e0192f8cd3153772642a/gcc%2Fconfig%2Fxtensa%2Funwind-dw2-xtensa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Funwind-dw2-xtensa.c?ref=6eb065e62cab6df886f8e0192f8cd3153772642a", "patch": "@@ -0,0 +1,546 @@\n+/* DWARF2 exception handling and frame unwinding for Xtensa.\n+   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,\n+   2007\n+   Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   In addition to the permissions in the GNU General Public License, the\n+   Free Software Foundation gives you unlimited permission to link the\n+   compiled version of this file into combinations with other programs,\n+   and to distribute those combinations without any restriction coming\n+   from the use of this file.  (The General Public License restrictions\n+   do apply in other respects; for example, they cover modification of\n+   the file, and distribution when not linked into a combined\n+   executable.)\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+   02110-1301, USA.  */\n+\n+#include \"tconfig.h\"\n+#include \"tsystem.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"dwarf2.h\"\n+#include \"unwind.h\"\n+#ifdef __USING_SJLJ_EXCEPTIONS__\n+# define NO_SIZE_OF_ENCODED_VALUE\n+#endif\n+#include \"unwind-pe.h\"\n+#include \"unwind-dw2-fde.h\"\n+#include \"unwind-dw2-xtensa.h\"\n+\n+#ifndef __USING_SJLJ_EXCEPTIONS__\n+\n+/* The standard CIE and FDE structures work fine for Xtensa but the\n+   variable-size register window save areas are not a good fit for the rest\n+   of the standard DWARF unwinding mechanism.  Nor is that mechanism\n+   necessary, since the register save areas are always in fixed locations\n+   in each stack frame.  This file is a stripped down and customized version\n+   of the standard DWARF unwinding code.  It needs to be customized to have\n+   builtin logic for finding the save areas and also to track the stack\n+   pointer value (besides the CFA) while unwinding since the primary save\n+   area is located below the stack pointer.  It is stripped down to reduce\n+   code size and ease the maintenance burden of tracking changes in the\n+   standard version of the code.  */\n+\n+#ifndef DWARF_REG_TO_UNWIND_COLUMN\n+#define DWARF_REG_TO_UNWIND_COLUMN(REGNO) (REGNO)\n+#endif\n+\n+#define XTENSA_RA_FIELD_MASK 0x3FFFFFFF\n+\n+/* This is the register and unwind state for a particular frame.  This\n+   provides the information necessary to unwind up past a frame and return\n+   to its caller.  */\n+struct _Unwind_Context\n+{\n+  /* Track register window save areas of 4 registers each, instead of\n+     keeping separate addresses for the individual registers.  */\n+  _Unwind_Word *reg[4];\n+\n+  void *cfa;\n+  void *sp;\n+  void *ra;\n+\n+  /* Cache the 2 high bits to replace the window size in return addresses.  */\n+  _Unwind_Word ra_high_bits;\n+\n+  void *lsda;\n+  struct dwarf_eh_bases bases;\n+  /* Signal frame context.  */\n+#define SIGNAL_FRAME_BIT ((~(_Unwind_Word) 0 >> 1) + 1)\n+  _Unwind_Word flags;\n+  /* 0 for now, can be increased when further fields are added to\n+     struct _Unwind_Context.  */\n+  _Unwind_Word version;\n+};\n+\n+\f\n+/* Read unaligned data from the instruction buffer.  */\n+\n+union unaligned\n+{\n+  void *p;\n+} __attribute__ ((packed));\n+\n+static void uw_update_context (struct _Unwind_Context *, _Unwind_FrameState *);\n+static _Unwind_Reason_Code uw_frame_state_for (struct _Unwind_Context *,\n+\t\t\t\t\t       _Unwind_FrameState *);\n+\n+static inline void *\n+read_pointer (const void *p) { const union unaligned *up = p; return up->p; }\n+\f\n+static inline _Unwind_Word\n+_Unwind_IsSignalFrame (struct _Unwind_Context *context)\n+{\n+  return (context->flags & SIGNAL_FRAME_BIT) ? 1 : 0;\n+}\n+\n+static inline void\n+_Unwind_SetSignalFrame (struct _Unwind_Context *context, int val)\n+{\n+  if (val)\n+    context->flags |= SIGNAL_FRAME_BIT;\n+  else\n+    context->flags &= ~SIGNAL_FRAME_BIT;\n+}\n+\f\n+/* Get the value of register INDEX as saved in CONTEXT.  */\n+\n+inline _Unwind_Word\n+_Unwind_GetGR (struct _Unwind_Context *context, int index)\n+{\n+  _Unwind_Word *ptr;\n+\n+  index = DWARF_REG_TO_UNWIND_COLUMN (index);\n+  ptr = context->reg[index >> 2] + (index & 3);\n+\n+  return *ptr;\n+}\n+\n+/* Get the value of the CFA as saved in CONTEXT.  */\n+\n+_Unwind_Word\n+_Unwind_GetCFA (struct _Unwind_Context *context)\n+{\n+  return (_Unwind_Ptr) context->cfa;\n+}\n+\n+/* Overwrite the saved value for register INDEX in CONTEXT with VAL.  */\n+\n+inline void\n+_Unwind_SetGR (struct _Unwind_Context *context, int index, _Unwind_Word val)\n+{\n+  _Unwind_Word *ptr;\n+\n+  index = DWARF_REG_TO_UNWIND_COLUMN (index);\n+  ptr = context->reg[index >> 2] + (index & 3);\n+\n+  *ptr = val;\n+}\n+\n+/* Retrieve the return address for CONTEXT.  */\n+\n+inline _Unwind_Ptr\n+_Unwind_GetIP (struct _Unwind_Context *context)\n+{\n+  return (_Unwind_Ptr) context->ra;\n+}\n+\n+/* Retrieve the return address and flag whether that IP is before\n+   or after first not yet fully executed instruction.  */\n+\n+inline _Unwind_Ptr\n+_Unwind_GetIPInfo (struct _Unwind_Context *context, int *ip_before_insn)\n+{\n+  *ip_before_insn = _Unwind_IsSignalFrame (context);\n+  return (_Unwind_Ptr) context->ra;\n+}\n+\n+/* Overwrite the return address for CONTEXT with VAL.  */\n+\n+inline void\n+_Unwind_SetIP (struct _Unwind_Context *context, _Unwind_Ptr val)\n+{\n+  context->ra = (void *) val;\n+}\n+\n+void *\n+_Unwind_GetLanguageSpecificData (struct _Unwind_Context *context)\n+{\n+  return context->lsda;\n+}\n+\n+_Unwind_Ptr\n+_Unwind_GetRegionStart (struct _Unwind_Context *context)\n+{\n+  return (_Unwind_Ptr) context->bases.func;\n+}\n+\n+void *\n+_Unwind_FindEnclosingFunction (void *pc)\n+{\n+  struct dwarf_eh_bases bases;\n+  const struct dwarf_fde *fde = _Unwind_Find_FDE (pc-1, &bases);\n+  if (fde)\n+    return bases.func;\n+  else\n+    return NULL;\n+}\n+\n+_Unwind_Ptr\n+_Unwind_GetDataRelBase (struct _Unwind_Context *context)\n+{\n+  return (_Unwind_Ptr) context->bases.dbase;\n+}\n+\n+_Unwind_Ptr\n+_Unwind_GetTextRelBase (struct _Unwind_Context *context)\n+{\n+  return (_Unwind_Ptr) context->bases.tbase;\n+}\n+\n+#ifdef MD_UNWIND_SUPPORT\n+#include MD_UNWIND_SUPPORT\n+#endif\n+\f\n+/* Extract any interesting information from the CIE for the translation\n+   unit F belongs to.  Return a pointer to the byte after the augmentation,\n+   or NULL if we encountered an undecipherable augmentation.  */\n+\n+static const unsigned char *\n+extract_cie_info (const struct dwarf_cie *cie, struct _Unwind_Context *context,\n+\t\t  _Unwind_FrameState *fs)\n+{\n+  const unsigned char *aug = cie->augmentation;\n+  const unsigned char *p = aug + strlen ((const char *)aug) + 1;\n+  const unsigned char *ret = NULL;\n+  _uleb128_t utmp;\n+  _sleb128_t stmp;\n+\n+  /* g++ v2 \"eh\" has pointer immediately following augmentation string,\n+     so it must be handled first.  */\n+  if (aug[0] == 'e' && aug[1] == 'h')\n+    {\n+      fs->eh_ptr = read_pointer (p);\n+      p += sizeof (void *);\n+      aug += 2;\n+    }\n+\n+  /* Immediately following the augmentation are the code and\n+     data alignment and return address column.  */\n+  p = read_uleb128 (p, &utmp);\n+  p = read_sleb128 (p, &stmp);\n+  if (cie->version == 1)\n+    fs->retaddr_column = *p++;\n+  else\n+    {\n+      p = read_uleb128 (p, &utmp);\n+      fs->retaddr_column = (_Unwind_Word)utmp;\n+    }\n+  fs->lsda_encoding = DW_EH_PE_omit;\n+\n+  /* If the augmentation starts with 'z', then a uleb128 immediately\n+     follows containing the length of the augmentation field following\n+     the size.  */\n+  if (*aug == 'z')\n+    {\n+      p = read_uleb128 (p, &utmp);\n+      ret = p + utmp;\n+\n+      fs->saw_z = 1;\n+      ++aug;\n+    }\n+\n+  /* Iterate over recognized augmentation subsequences.  */\n+  while (*aug != '\\0')\n+    {\n+      /* \"L\" indicates a byte showing how the LSDA pointer is encoded.  */\n+      if (aug[0] == 'L')\n+\t{\n+\t  fs->lsda_encoding = *p++;\n+\t  aug += 1;\n+\t}\n+\n+      /* \"R\" indicates a byte indicating how FDE addresses are encoded.  */\n+      else if (aug[0] == 'R')\n+\t{\n+\t  fs->fde_encoding = *p++;\n+\t  aug += 1;\n+\t}\n+\n+      /* \"P\" indicates a personality routine in the CIE augmentation.  */\n+      else if (aug[0] == 'P')\n+\t{\n+\t  _Unwind_Ptr personality;\n+\t  \n+\t  p = read_encoded_value (context, *p, p + 1, &personality);\n+\t  fs->personality = (_Unwind_Personality_Fn) personality;\n+\t  aug += 1;\n+\t}\n+\n+      /* \"S\" indicates a signal frame.  */\n+      else if (aug[0] == 'S')\n+\t{\n+\t  fs->signal_frame = 1;\n+\t  aug += 1;\n+\t}\n+\n+      /* Otherwise we have an unknown augmentation string.\n+\t Bail unless we saw a 'z' prefix.  */\n+      else\n+\treturn ret;\n+    }\n+\n+  return ret ? ret : p;\n+}\n+\f\n+/* Given the _Unwind_Context CONTEXT for a stack frame, look up the FDE for\n+   its caller and decode it into FS.  This function also sets the\n+   lsda member of CONTEXT, as it is really information\n+   about the caller's frame.  */\n+\n+static _Unwind_Reason_Code\n+uw_frame_state_for (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n+{\n+  const struct dwarf_fde *fde;\n+  const struct dwarf_cie *cie;\n+  const unsigned char *aug;\n+  int window_size;\n+  _Unwind_Word *ra_ptr;\n+\n+  memset (fs, 0, sizeof (*fs));\n+  context->lsda = 0;\n+\n+  ra_ptr = context->reg[0];\n+  if (ra_ptr && *ra_ptr == 0)\n+    return _URC_END_OF_STACK;\n+\n+  fde = _Unwind_Find_FDE (context->ra + _Unwind_IsSignalFrame (context) - 1,\n+\t\t\t  &context->bases);\n+  if (fde == NULL)\n+    {\n+#ifdef MD_FALLBACK_FRAME_STATE_FOR\n+      _Unwind_Reason_Code reason;\n+      /* Couldn't find frame unwind info for this function.  Try a\n+\t target-specific fallback mechanism.  This will necessarily\n+\t not provide a personality routine or LSDA.  */\n+      reason = MD_FALLBACK_FRAME_STATE_FOR (context, fs);\n+      if (reason != _URC_END_OF_STACK)\n+\treturn reason;\n+      /* The frame was not recognized and handled by the fallback function,\n+\t but it is not really the end of the stack.  Fall through here and\n+\t unwind it anyway.  */\n+#endif\n+      fs->pc = context->ra;\n+    }\n+  else\n+    {\n+      fs->pc = context->bases.func;\n+\n+      cie = get_cie (fde);\n+      if (extract_cie_info (cie, context, fs) == NULL)\n+\t/* CIE contained unknown augmentation.  */\n+\treturn _URC_FATAL_PHASE1_ERROR;\n+\n+      /* Locate augmentation for the fde.  */\n+      aug = (const unsigned char *) fde + sizeof (*fde);\n+      aug += 2 * size_of_encoded_value (fs->fde_encoding);\n+      if (fs->saw_z)\n+\t{\n+\t  _uleb128_t i;\n+\t  aug = read_uleb128 (aug, &i);\n+\t}\n+      if (fs->lsda_encoding != DW_EH_PE_omit)\n+\t{\n+\t  _Unwind_Ptr lsda;\n+\n+\t  aug = read_encoded_value (context, fs->lsda_encoding, aug, &lsda);\n+\t  context->lsda = (void *) lsda;\n+\t}\n+    }\n+\n+  /* Find the window size from the high bits of the return address.  */\n+  if (ra_ptr)\n+    window_size = (*ra_ptr >> 30) * 4;\n+  else\n+    window_size = 8;\n+\n+  fs->retaddr_column = window_size;\n+\n+  return _URC_NO_REASON;\n+}\n+\f\n+static void\n+uw_update_context_1 (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n+{\n+  struct _Unwind_Context orig_context = *context;\n+  _Unwind_Word *sp, *cfa, *next_cfa;\n+  int i;\n+\n+  if (fs->signal_frame)\n+    {\n+      cfa = (_Unwind_Word *) fs->signal_regs[1];\n+      next_cfa = (_Unwind_Word *) cfa[-3];\n+\n+      for (i = 0; i < 4; i++)\n+\tcontext->reg[i] = fs->signal_regs + (i << 2);\n+    }\n+  else\n+    {\n+      int window_size = fs->retaddr_column >> 2;\n+\n+      sp = (_Unwind_Word *) orig_context.sp;\n+      cfa = (_Unwind_Word *) orig_context.cfa;\n+      next_cfa = (_Unwind_Word *) cfa[-3];\n+\n+      /* Registers a0-a3 are in the save area below sp.  */\n+      context->reg[0] = sp - 4;\n+\n+      /* Find the extra save area below next_cfa.  */\n+      for (i = 1; i < window_size; i++)\n+\tcontext->reg[i] = next_cfa - 4 * (1 + window_size - i);\n+\n+      /* Remaining registers rotate from previous save areas.  */\n+      for (i = window_size; i < 4; i++)\n+\tcontext->reg[i] = orig_context.reg[i - window_size];\n+    }\n+\n+  context->sp = cfa;\n+  context->cfa = next_cfa;\n+\n+  _Unwind_SetSignalFrame (context, fs->signal_frame);\n+}\n+\n+/* CONTEXT describes the unwind state for a frame, and FS describes the FDE\n+   of its caller.  Update CONTEXT to refer to the caller as well.  Note\n+   that the lsda member is not updated here, but later in\n+   uw_frame_state_for.  */\n+\n+static void\n+uw_update_context (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n+{\n+  uw_update_context_1 (context, fs);\n+\n+  /* Compute the return address now, since the return address column\n+     can change from frame to frame.  */\n+  context->ra = (void *) ((_Unwind_GetGR (context, fs->retaddr_column)\n+\t\t\t   & XTENSA_RA_FIELD_MASK) | context->ra_high_bits);\n+}\n+\n+static void\n+uw_advance_context (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n+{\n+  uw_update_context (context, fs);\n+}\n+\f\n+/* Fill in CONTEXT for top-of-stack.  The only valid registers at this\n+   level will be the return address and the CFA.  */\n+\n+#define uw_init_context(CONTEXT)\t\t\t\t\t   \\\n+  do\t\t\t\t\t\t\t\t\t   \\\n+    {\t\t\t\t\t\t\t\t\t   \\\n+      __builtin_unwind_init ();\t\t\t\t\t\t   \\\n+      uw_init_context_1 (CONTEXT, __builtin_dwarf_cfa (),\t\t   \\\n+\t\t\t __builtin_return_address (0));\t\t\t   \\\n+    }\t\t\t\t\t\t\t\t\t   \\\n+  while (0)\n+\n+static void\n+uw_init_context_1 (struct _Unwind_Context *context, void *outer_cfa,\n+\t\t   void *outer_ra)\n+{\n+  void *ra = __builtin_return_address (0);\n+  void *cfa = __builtin_dwarf_cfa ();\n+  _Unwind_FrameState fs;\n+\n+  memset (context, 0, sizeof (struct _Unwind_Context));\n+  context->ra = ra;\n+\n+  memset (&fs, 0, sizeof (fs));\n+  fs.retaddr_column = 8;\n+  context->sp = cfa;\n+  context->cfa = outer_cfa;\n+  context->ra_high_bits =\n+    ((_Unwind_Word) uw_init_context_1) & ~XTENSA_RA_FIELD_MASK;\n+  uw_update_context_1 (context, &fs);\n+\n+  context->ra = outer_ra;\n+}\n+\n+\n+/* Install TARGET into CURRENT so that we can return to it.  This is a\n+   macro because __builtin_eh_return must be invoked in the context of\n+   our caller.  */\n+\n+#define uw_install_context(CURRENT, TARGET)\t\t\t\t \\\n+  do\t\t\t\t\t\t\t\t\t \\\n+    {\t\t\t\t\t\t\t\t\t \\\n+      long offset = uw_install_context_1 ((CURRENT), (TARGET));\t\t \\\n+      void *handler = __builtin_frob_return_addr ((TARGET)->ra);\t \\\n+      __builtin_eh_return (offset, handler);\t\t\t\t \\\n+    }\t\t\t\t\t\t\t\t\t \\\n+  while (0)\n+\n+static long\n+uw_install_context_1 (struct _Unwind_Context *current,\n+\t\t      struct _Unwind_Context *target)\n+{\n+  long i;\n+\n+  /* The eh_return insn assumes a window size of 8, so don't bother copying\n+     the save areas for registers a8-a15 since they won't be reloaded.  */\n+  for (i = 0; i < 2; ++i)\n+    {\n+      void *c = current->reg[i];\n+      void *t = target->reg[i];\n+\n+      if (t && c && t != c)\n+\tmemcpy (c, t, 4 * sizeof (_Unwind_Word));\n+    }\n+\n+  return 0;\n+}\n+\n+static inline _Unwind_Ptr\n+uw_identify_context (struct _Unwind_Context *context)\n+{\n+  return _Unwind_GetCFA (context);\n+}\n+\n+\n+#include \"unwind.inc\"\n+\n+#if defined (USE_GAS_SYMVER) && defined (SHARED) && defined (USE_LIBUNWIND_EXCEPTIONS)\n+alias (_Unwind_Backtrace);\n+alias (_Unwind_DeleteException);\n+alias (_Unwind_FindEnclosingFunction);\n+alias (_Unwind_ForcedUnwind);\n+alias (_Unwind_GetDataRelBase);\n+alias (_Unwind_GetTextRelBase);\n+alias (_Unwind_GetCFA);\n+alias (_Unwind_GetGR);\n+alias (_Unwind_GetIP);\n+alias (_Unwind_GetLanguageSpecificData);\n+alias (_Unwind_GetRegionStart);\n+alias (_Unwind_RaiseException);\n+alias (_Unwind_Resume);\n+alias (_Unwind_Resume_or_Rethrow);\n+alias (_Unwind_SetGR);\n+alias (_Unwind_SetIP);\n+#endif\n+\n+#endif /* !USING_SJLJ_EXCEPTIONS */"}, {"sha": "99341172eac4ac3a99ac5f1682cc52b025c063b5", "filename": "gcc/config/xtensa/unwind-dw2-xtensa.h", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eb065e62cab6df886f8e0192f8cd3153772642a/gcc%2Fconfig%2Fxtensa%2Funwind-dw2-xtensa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eb065e62cab6df886f8e0192f8cd3153772642a/gcc%2Fconfig%2Fxtensa%2Funwind-dw2-xtensa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Funwind-dw2-xtensa.h?ref=6eb065e62cab6df886f8e0192f8cd3153772642a", "patch": "@@ -0,0 +1,57 @@\n+/* DWARF2 frame unwind data structure for Xtensa.\n+   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2007\n+   Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   In addition to the permissions in the GNU General Public License, the\n+   Free Software Foundation gives you unlimited permission to link the\n+   compiled version of this file into combinations with other programs,\n+   and to distribute those combinations without any restriction coming\n+   from the use of this file.  (The General Public License restrictions\n+   do apply in other respects; for example, they cover modification of\n+   the file, and distribution when not linked into a combined\n+   executable.)\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+   02110-1301, USA.  */\n+\n+/* A target can override (perhaps for backward compatibility) how\n+   many dwarf2 columns are unwound.  */\n+#ifndef DWARF_FRAME_REGISTERS\n+#define DWARF_FRAME_REGISTERS FIRST_PSEUDO_REGISTER\n+#endif\n+\n+/* Xtensa's variable-size register window save areas can be unwound without\n+   any unwind info.  This is a stripped down version of the standard DWARF\n+   _Unwind_FrameState.  */\n+typedef struct\n+{\n+  /* The PC described by the current frame state.  */\n+  void *pc;\n+\n+  /* The information we care about from the CIE/FDE.  */\n+  _Unwind_Personality_Fn personality;\n+  _Unwind_Word retaddr_column;\n+  unsigned char fde_encoding;\n+  unsigned char lsda_encoding;\n+  unsigned char saw_z;\n+  unsigned char signal_frame;\n+  void *eh_ptr;\n+\n+  /* Saved registers for a signal frame.  */\n+  _Unwind_Word *signal_regs;\n+} _Unwind_FrameState;\n+"}, {"sha": "7887345f9f51c338f7cbd3a2940fa89ed6164cee", "filename": "gcc/config/xtensa/xtensa.h", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eb065e62cab6df886f8e0192f8cd3153772642a/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eb065e62cab6df886f8e0192f8cd3153772642a/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.h?ref=6eb065e62cab6df886f8e0192f8cd3153772642a", "patch": "@@ -1062,12 +1062,15 @@ typedef struct xtensa_args\n /* How to start an assembler comment.  */\n #define ASM_COMMENT_START \"#\"\n \n-/* Generate DWARF2 unwind info to get the DW_AT_frame_base set correctly,\n-   even though we don't yet use it for unwinding.  */\n-#define MUST_USE_SJLJ_EXCEPTIONS 1\n-#define DWARF2_UNWIND_INFO 1\n+/* Exception handling.  Xtensa uses much of the standard DWARF2 unwinding\n+   machinery, but the variable size register window save areas are too\n+   complicated to efficiently describe with CFI entries.  The CFA must\n+   still be specified in DWARF so that DW_AT_frame_base is set correctly\n+   for debugging.  */\n #define INCOMING_RETURN_ADDR_RTX gen_rtx_REG (Pmode, 0)\n #define DWARF_FRAME_RETURN_COLUMN DWARF_FRAME_REGNUM (0)\n+#define DWARF_FRAME_REGISTERS 16\n+#define EH_RETURN_DATA_REGNO(N) ((N) < 2 ? (N) + 2 : INVALID_REGNUM)\n \n /* Xtensa constant pool breaks the devices in crtstuff.c to control\n    section in where code resides.  We have to write it as asm code.  Use"}, {"sha": "37e29e70039235578bdc7e49117984c5c9f752c5", "filename": "gcc/config/xtensa/xtensa.md", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eb065e62cab6df886f8e0192f8cd3153772642a/gcc%2Fconfig%2Fxtensa%2Fxtensa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eb065e62cab6df886f8e0192f8cd3153772642a/gcc%2Fconfig%2Fxtensa%2Fxtensa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.md?ref=6eb065e62cab6df886f8e0192f8cd3153772642a", "patch": "@@ -35,6 +35,7 @@\n   (UNSPECV_MEMW\t\t3)\n   (UNSPECV_S32RI\t4)\n   (UNSPECV_S32C1I\t5)\n+  (UNSPECV_EH_RETURN\t6)\n ])\n \n ;; This code iterator allows signed and unsigned widening multiplications\n@@ -1600,6 +1601,26 @@\n   DONE;\n })\n \n+;; Stuff an address into the return address register along with the window\n+;; size in the high bits.  Because we don't have the window size of the\n+;; previous frame, assume the function called out with a CALL8 since that\n+;; is what compilers always use.  Note: __builtin_frob_return_addr has\n+;; already been applied to the handler, but the generic version doesn't\n+;; allow us to frob it quite enough, so we just frob here.\n+\n+(define_insn_and_split \"eh_return\"\n+  [(set (reg:SI A0_REG)\n+\t(unspec_volatile:SI [(match_operand:SI 0 \"register_operand\" \"r\")]\n+\t\t\t    UNSPECV_EH_RETURN))\n+   (clobber (match_scratch:SI 1 \"=r\"))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(set (match_dup 1) (ashift:SI (match_dup 0) (const_int 2)))\n+   (set (match_dup 1) (plus:SI (match_dup 1) (const_int 2)))\n+   (set (reg:SI A0_REG) (rotatert:SI (match_dup 1) (const_int 2)))]\n+  \"\")\n+\n ;; Setting up a frame pointer is tricky for Xtensa because GCC doesn't\n ;; know if a frame pointer is required until the reload pass, and\n ;; because there may be an incoming argument value in the hard frame"}]}