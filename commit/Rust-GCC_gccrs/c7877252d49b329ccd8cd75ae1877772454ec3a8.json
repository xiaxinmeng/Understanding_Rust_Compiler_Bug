{"sha": "c7877252d49b329ccd8cd75ae1877772454ec3a8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzc4NzcyNTJkNDliMzI5Y2NkOGNkNzVhZTE4Nzc3NzI0NTRlYzNhOA==", "commit": {"author": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2005-08-07T22:59:00Z"}, "committer": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2005-08-07T22:59:00Z"}, "message": "Forgot to remove and add these files in the previous commit.\n\n\t* io/backspace.c: File removed, contents moved to ...\n\t* io/endfile.c: Ditto.\n\t* io/rewind.c: Ditto.\n\t* io/file_pos.c: New file, ... here.\n\nFrom-SVN: r102836", "tree": {"sha": "d94fc4ff5bd4d47b085805dbf7f7b4b91a55f035", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d94fc4ff5bd4d47b085805dbf7f7b4b91a55f035"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c7877252d49b329ccd8cd75ae1877772454ec3a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7877252d49b329ccd8cd75ae1877772454ec3a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7877252d49b329ccd8cd75ae1877772454ec3a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7877252d49b329ccd8cd75ae1877772454ec3a8/comments", "author": null, "committer": null, "parents": [{"sha": "6403ec5ff6aa7436ed28d1cdbfaedd30dec78fbe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6403ec5ff6aa7436ed28d1cdbfaedd30dec78fbe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6403ec5ff6aa7436ed28d1cdbfaedd30dec78fbe"}], "stats": {"total": 279, "additions": 117, "deletions": 162}, "files": [{"sha": "8d01ea1076b019a3d2df41bb0f2866277a6b610e", "filename": "libgfortran/io/endfile.c", "status": "removed", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6403ec5ff6aa7436ed28d1cdbfaedd30dec78fbe/libgfortran%2Fio%2Fendfile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6403ec5ff6aa7436ed28d1cdbfaedd30dec78fbe/libgfortran%2Fio%2Fendfile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fendfile.c?ref=6403ec5ff6aa7436ed28d1cdbfaedd30dec78fbe", "patch": "@@ -1,59 +0,0 @@\n-/* Copyright (C) 2002-2003 Free Software Foundation, Inc.\n-   Contributed by Andy Vaught\n-\n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n-\n-Libgfortran is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-In addition to the permissions in the GNU General Public License, the\n-Free Software Foundation gives you unlimited permission to link the\n-compiled version of this file into combinations with other programs,\n-and to distribute those combinations without any restriction coming\n-from the use of this file.  (The General Public License restrictions\n-do apply in other respects; for example, they cover modification of\n-the file, and distribution when not linked into a combine\n-executable.)\n-\n-Libgfortran is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with Libgfortran; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#include \"config.h\"\n-#include \"libgfortran.h\"\n-#include \"io.h\"\n-\n-/* endfile.c--  Implement the ENDFILE statement */\n-\n-extern void st_endfile (void);\n-export_proto(st_endfile);\n-\n-void\n-st_endfile (void)\n-{\n-  gfc_unit *u;\n-\n-  library_start ();\n-\n-  u = get_unit (0);\n-  if (u != NULL)\n-    {\n-      current_unit = u;\t\t/* next_record() needs this set */\n-      if (u->current_record)\n-\tnext_record (1);\n-\n-      flush(u->s);\n-      struncate (u->s);\n-      u->endfile = AFTER_ENDFILE;\n-    }\n-\n-  library_end ();\n-}"}, {"sha": "760b8b16f413f8476197467c67a6a3a888702dd6", "filename": "libgfortran/io/file_pos.c", "status": "renamed", "additions": 117, "deletions": 25, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7877252d49b329ccd8cd75ae1877772454ec3a8/libgfortran%2Fio%2Ffile_pos.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7877252d49b329ccd8cd75ae1877772454ec3a8/libgfortran%2Fio%2Ffile_pos.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ffile_pos.c?ref=c7877252d49b329ccd8cd75ae1877772454ec3a8", "patch": "@@ -1,7 +1,7 @@\n-/* Copyright (C) 2002-2003 Free Software Foundation, Inc.\n-   Contributed by Andy Vaught\n+/* Copyright (C) 2002-2003, 2005 Free Software Foundation, Inc.\n+   Contributed by Andy Vaught and Janne Blomqvist\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n@@ -32,12 +32,14 @@ Boston, MA 02111-1307, USA.  */\n #include \"libgfortran.h\"\n #include \"io.h\"\n \n-/* backspace.c -- Implement the BACKSPACE statement */\n+/* file_pos.c-- Implement the file positioning statements, i.e. BACKSPACE,\n+   ENDFILE, and REWIND as well as the FLUSH statement.  */\n+\n \n /* formatted_backspace(void)-- Move the file back one line.  The\n- * current position is after the newline that terminates the previous\n- * record, and we have to sift backwards to find the newline before\n- * that or the start of the file, whichever comes first. */\n+   current position is after the newline that terminates the previous\n+   record, and we have to sift backwards to find the newline before\n+   that or the start of the file, whichever comes first.  */\n \n #define READ_CHUNK 4096\n \n@@ -59,12 +61,12 @@ formatted_backspace (void)\n       if (p == NULL)\n \tgoto io_error;\n \n-      /* Because we've moved backwords from the current position, it\n-       * should not be possible to get a short read.  Because it isn't\n-       * clear what to do about such thing, we ignore the possibility. */\n+      /* We have moved backwards from the current position, it should\n+         not be possible to get a short read.  Because it is not\n+         clear what to do about such thing, we ignore the possibility.  */\n \n       /* There is no memrchr() in the C library, so we have to do it\n-       * ourselves. */\n+         ourselves.  */\n \n       n--;\n       while (n >= 0)\n@@ -74,14 +76,13 @@ formatted_backspace (void)\n \t      base += n + 1;\n \t      goto done;\n \t    }\n-\n \t  n--;\n \t}\n \n     }\n   while (base != 0);\n \n-  /* base is the new pointer.  Seek to it exactly */\n+  /* base is the new pointer.  Seek to it exactly.  */\n  done:\n   if (sseek (current_unit->s, base) == FAILURE)\n     goto io_error;\n@@ -95,9 +96,9 @@ formatted_backspace (void)\n }\n \n \n-/* unformatted_backspace()-- Move the file backwards for an\n- * unformatted sequential file.  We are guaranteed to be between\n- * records on entry and we have to shift to the previous record.  */\n+/* unformatted_backspace() -- Move the file backwards for an unformatted\n+   sequential file.  We are guaranteed to be between records on entry and \n+   we have to shift to the previous record.  */\n \n static void\n unformatted_backspace (void)\n@@ -145,14 +146,14 @@ st_backspace (void)\n \n   current_unit = u;\n \n-  /* Ignore direct access.  Non-advancing I/O is only allowed for\n-   * formatted sequential I/O and the next direct access transfer\n-   * repositions the file anyway. */\n+  /* Ignore direct access.  Non-advancing I/O is only allowed for formatted\n+     sequential I/O and the next direct access transfer repositions the file \n+     anyway.  */\n \n   if (u->flags.access == ACCESS_DIRECT)\n     goto done;\n \n-  /* Check for special cases involving the ENDFILE record first */\n+  /* Check for special cases involving the ENDFILE record first.  */\n \n   if (u->endfile == AFTER_ENDFILE)\n     u->endfile = AT_ENDFILE;\n@@ -162,11 +163,11 @@ st_backspace (void)\n \tgoto done;\t\t/* Common special case */\n \n       if (u->mode == WRITING)\n-      {\n-\tflush (u->s);\n-\tstruncate (u->s);\n-\tu->mode = READING;\n-      }\n+\t{\n+\t  flush (u->s);\n+\t  struncate (u->s);\n+\t  u->mode = READING;\n+        }\n \n       if (u->flags.form == FORM_FORMATTED)\n \tformatted_backspace ();\n@@ -180,3 +181,94 @@ st_backspace (void)\n  done:\n   library_end ();\n }\n+\n+\n+extern void st_endfile (void);\n+export_proto(st_endfile);\n+\n+void\n+st_endfile (void)\n+{\n+  gfc_unit *u;\n+\n+  library_start ();\n+\n+  u = get_unit (0);\n+  if (u != NULL)\n+    {\n+      current_unit = u;\t\t/* next_record() needs this set.  */\n+      if (u->current_record)\n+\tnext_record (1);\n+\n+      flush(u->s);\n+      struncate (u->s);\n+      u->endfile = AFTER_ENDFILE;\n+    }\n+\n+  library_end ();\n+}\n+\n+\n+extern void st_rewind (void);\n+export_proto(st_rewind);\n+\n+void\n+st_rewind (void)\n+{\n+  gfc_unit *u;\n+\n+  library_start ();\n+\n+  u = find_unit (ioparm.unit);\n+  if (u != NULL)\n+    {\n+      if (u->flags.access != ACCESS_SEQUENTIAL)\n+\tgenerate_error (ERROR_BAD_OPTION,\n+\t\t\t\"Cannot REWIND a file opened for DIRECT access\");\n+      else\n+\t{\n+\t  /* If we have been writing to the file, the last written record\n+\t     is the last record in the file, so truncate the file now.\n+\t     Reset to read mode so two consecutive rewind statements do not\n+\t     delete the file contents.  Flush buffer when switching mode.  */\n+          if (u->mode == WRITING)\n+\t    {\n+\t      flush (u->s);\n+\t      struncate (u->s);\n+\t    }\n+\t  u->mode = READING;\n+\t  u->last_record = 0;\n+\t  if (sseek (u->s, 0) == FAILURE)\n+\t    generate_error (ERROR_OS, NULL);\n+\n+\t  u->endfile = NO_ENDFILE;\n+\t  u->current_record = 0;\n+\t  test_endfile (u);\n+\t}\n+      /* Update position for INQUIRE.  */\n+      u->flags.position = POSITION_REWIND;\n+    }\n+\n+  library_end ();\n+}\n+\n+\n+extern void st_flush (void);\n+export_proto(st_flush);\n+\n+void\n+st_flush (void)\n+{\n+  gfc_unit *u;\n+\n+  library_start ();\n+\n+  u = get_unit (0);\n+  if (u != NULL)\n+    {\n+      current_unit = u;  /* Just to be sure.  */\n+      flush(u->s);\n+    }\n+\n+  library_end ();\n+}", "previous_filename": "libgfortran/io/backspace.c"}, {"sha": "48d57bafaa53a719694e3e7f6253466e49f5e6f5", "filename": "libgfortran/io/rewind.c", "status": "removed", "additions": 0, "deletions": 78, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6403ec5ff6aa7436ed28d1cdbfaedd30dec78fbe/libgfortran%2Fio%2Frewind.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6403ec5ff6aa7436ed28d1cdbfaedd30dec78fbe/libgfortran%2Fio%2Frewind.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Frewind.c?ref=6403ec5ff6aa7436ed28d1cdbfaedd30dec78fbe", "patch": "@@ -1,78 +0,0 @@\n-/* Copyright (C) 2002-2003 Free Software Foundation, Inc.\n-   Contributed by Andy Vaught\n-\n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n-\n-Libgfortran is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-In addition to the permissions in the GNU General Public License, the\n-Free Software Foundation gives you unlimited permission to link the\n-compiled version of this file into combinations with other programs,\n-and to distribute those combinations without any restriction coming\n-from the use of this file.  (The General Public License restrictions\n-do apply in other respects; for example, they cover modification of\n-the file, and distribution when not linked into a combine\n-executable.)\n-\n-Libgfortran is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with Libgfortran; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#include \"config.h\"\n-#include \"libgfortran.h\"\n-#include \"io.h\"\n-\n-/* rewind.c--  Implement the rewind statement */\n-\n-extern void st_rewind (void);\n-export_proto(st_rewind);\n-\n-void\n-st_rewind (void)\n-{\n-  gfc_unit *u;\n-\n-  library_start ();\n-\n-  u = find_unit (ioparm.unit);\n-  if (u != NULL)\n-    {\n-      if (u->flags.access != ACCESS_SEQUENTIAL)\n-\tgenerate_error (ERROR_BAD_OPTION,\n-\t\t\t\"Cannot REWIND a file opened for DIRECT access\");\n-      else\n-\t{\n-\t  /* If we have been writing to the file, the last written record\n-\t     is the last record in the file, so truncate the file now.\n-\t     Reset to read mode so two consecutive rewind statements\n-\t     don't delete the file contents.  Flush buffer when switching\n-\t     mode.  */\n-          if (u->mode == WRITING)\n-\t    {\n-\t      flush (u->s);\n-\t      struncate (u->s);\n-\t    }\n-\t  u->mode = READING;\n-\t  u->last_record = 0;\n-\t  if (sseek (u->s, 0) == FAILURE)\n-\t    generate_error (ERROR_OS, NULL);\n-\n-\t  u->endfile = NO_ENDFILE;\n-\t  u->current_record = 0;\n-\t  test_endfile (u);\n-\t}\n-      /* update position for INQUIRE */\n-      u->flags.position = POSITION_REWIND;\n-    }\n-\n-  library_end ();\n-}"}]}