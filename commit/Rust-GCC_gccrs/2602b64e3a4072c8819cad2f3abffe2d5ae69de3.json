{"sha": "2602b64e3a4072c8819cad2f3abffe2d5ae69de3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjYwMmI2NGUzYTQwNzJjODgxOWNhZDJmM2FiZmZlMmQ1YWU2OWRlMw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-11T10:41:49Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-11T10:41:49Z"}, "message": "[multiple changes]\n\n2013-04-11  Robert Dewar  <dewar@adacore.com>\n\n\t* stand.ads: Minor reformatting.\n\n2013-04-11  Matthew Heaney  <heaney@adacore.com>\n\n\t* a-convec.adb, a-coinve.adb, a-cobove.adb (\"=\"): Increment lock\n\tcounts before entering loop.\n\t(Find, Find_Index): Ditto.\n\t(Is_Sorted, Merge, Sort): Ditto.\n\t(Reverse_Find, Reverse_Find_Index): Ditto.\n\nFrom-SVN: r197765", "tree": {"sha": "069c1a85b564c4049f489530114e91480b59b401", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/069c1a85b564c4049f489530114e91480b59b401"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2602b64e3a4072c8819cad2f3abffe2d5ae69de3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2602b64e3a4072c8819cad2f3abffe2d5ae69de3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2602b64e3a4072c8819cad2f3abffe2d5ae69de3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2602b64e3a4072c8819cad2f3abffe2d5ae69de3/comments", "author": null, "committer": null, "parents": [{"sha": "c8d636509a850e8e90b995426241fa5054728367", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8d636509a850e8e90b995426241fa5054728367", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8d636509a850e8e90b995426241fa5054728367"}], "stats": {"total": 1536, "additions": 1022, "deletions": 514}, "files": [{"sha": "3582e9f35bb8e13311affadfcd543a385c5b018d", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2602b64e3a4072c8819cad2f3abffe2d5ae69de3/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2602b64e3a4072c8819cad2f3abffe2d5ae69de3/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=2602b64e3a4072c8819cad2f3abffe2d5ae69de3", "patch": "@@ -1,3 +1,15 @@\n+2013-04-11  Robert Dewar  <dewar@adacore.com>\n+\n+\t* stand.ads: Minor reformatting.\n+\n+2013-04-11  Matthew Heaney  <heaney@adacore.com>\n+\n+\t* a-convec.adb, a-coinve.adb, a-cobove.adb (\"=\"): Increment lock\n+\tcounts before entering loop.\n+\t(Find, Find_Index): Ditto.\n+\t(Is_Sorted, Merge, Sort): Ditto.\n+\t(Reverse_Find, Reverse_Find_Index): Ditto.\n+\n 2013-04-11  Robert Dewar  <dewar@adacore.com>\n \n \t* exp_ch11.ads, exp_ch11.adb (Expand_N_Raise_Expression): New procedure."}, {"sha": "01755cfd80fa9c71f20fe13851c9312d51ac787f", "filename": "gcc/ada/a-cobove.adb", "status": "modified", "additions": 289, "deletions": 87, "changes": 376, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2602b64e3a4072c8819cad2f3abffe2d5ae69de3/gcc%2Fada%2Fa-cobove.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2602b64e3a4072c8819cad2f3abffe2d5ae69de3/gcc%2Fada%2Fa-cobove.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cobove.adb?ref=2602b64e3a4072c8819cad2f3abffe2d5ae69de3", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -112,8 +112,8 @@ package body Ada.Containers.Bounded_Vectors is\n          raise Constraint_Error with \"new length is out of range\";\n       end if;\n \n-      --  It is now safe compute the length of the new vector, without fear of\n-      --  overflow.\n+      --  It is now safe to compute the length of the new vector, without fear\n+      --  of overflow.\n \n       N := LN + RN;\n \n@@ -122,6 +122,7 @@ package body Ada.Containers.Bounded_Vectors is\n       --  Count_Type'Base as the type for intermediate values.\n \n       if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+\n          --  We perform a two-part test. First we determine whether the\n          --  computed Last value lies in the base range of the type, and then\n          --  determine whether it lies in the range of the index (sub)type.\n@@ -150,6 +151,7 @@ package body Ada.Containers.Bounded_Vectors is\n          end if;\n \n       elsif Index_Type'First <= 0 then\n+\n          --  Here we can compute Last directly, in the normal way. We know that\n          --  No_Index is less than 0, so there is no danger of overflow when\n          --  adding the (positive) value of length.\n@@ -280,6 +282,14 @@ package body Ada.Containers.Bounded_Vectors is\n    ---------\n \n    overriding function \"=\" (Left, Right : Vector) return Boolean is\n+      BL : Natural renames Left'Unrestricted_Access.Busy;\n+      LL : Natural renames Left'Unrestricted_Access.Lock;\n+\n+      BR : Natural renames Right'Unrestricted_Access.Busy;\n+      LR : Natural renames Right'Unrestricted_Access.Lock;\n+\n+      Result : Boolean;\n+\n    begin\n       if Left'Address = Right'Address then\n          return True;\n@@ -289,13 +299,40 @@ package body Ada.Containers.Bounded_Vectors is\n          return False;\n       end if;\n \n+      --  Per AI05-0022, the container implementation is required to detect\n+      --  element tampering by a generic actual subprogram.\n+\n+      BL := BL + 1;\n+      LL := LL + 1;\n+\n+      BR := BR + 1;\n+      LR := LR + 1;\n+\n+      Result := True;\n       for J in Count_Type range 1 .. Left.Length loop\n          if Left.Elements (J) /= Right.Elements (J) then\n-            return False;\n+            Result := False;\n+            exit;\n          end if;\n       end loop;\n \n-      return True;\n+      BL := BL - 1;\n+      LL := LL - 1;\n+\n+      BR := BR - 1;\n+      LR := LR - 1;\n+\n+      return Result;\n+\n+   exception\n+      when others =>\n+         BL := BL - 1;\n+         LL := LL - 1;\n+\n+         BR := BR - 1;\n+         LR := LR - 1;\n+\n+         raise;\n    end \"=\";\n \n    ------------\n@@ -543,7 +580,6 @@ package body Ada.Containers.Bounded_Vectors is\n \n       if Count_Type'Base'Last >= Index_Type'Pos (Index_Type'Base'Last) then\n          Count2 := Count_Type'Base (Old_Last) - Count_Type'Base (Index) + 1;\n-\n       else\n          Count2 := Count_Type'Base (Old_Last - Index + 1);\n       end if;\n@@ -567,7 +603,6 @@ package body Ada.Containers.Bounded_Vectors is\n       if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n          Off := Count_Type'Base (Index - Index_Type'First);\n          New_Last := Old_Last - Index_Type'Base (Count);\n-\n       else\n          Off := Count_Type'Base (Index) - Count_Type'Base (Index_Type'First);\n          New_Last := Index_Type'Base (Count_Type'Base (Old_Last) - Count);\n@@ -579,7 +614,6 @@ package body Ada.Containers.Bounded_Vectors is\n       declare\n          EA  : Elements_Array renames Container.Elements;\n          Idx : constant Count_Type := EA'First + Off;\n-\n       begin\n          EA (Idx .. Old_Len - Count) := EA (Idx + Count .. Old_Len);\n          Container.Last := New_Last;\n@@ -621,14 +655,14 @@ package body Ada.Containers.Bounded_Vectors is\n    begin\n       if Count = 0 then\n          return;\n-      end if;\n \n-      if Count >= Length (Container) then\n+      elsif Count >= Length (Container) then\n          Clear (Container);\n          return;\n-      end if;\n \n-      Delete (Container, Index_Type'First, Count);\n+      else\n+         Delete (Container, Index_Type'First, Count);\n+      end if;\n    end Delete_First;\n \n    -----------------\n@@ -738,13 +772,42 @@ package body Ada.Containers.Bounded_Vectors is\n          end if;\n       end if;\n \n-      for J in Position.Index .. Container.Last loop\n-         if Container.Elements (To_Array_Index (J)) = Item then\n-            return (Container'Unrestricted_Access, J);\n+      --  Per AI05-0022, the container implementation is required to detect\n+      --  element tampering by a generic actual subprogram.\n+\n+      declare\n+         B : Natural renames Container'Unrestricted_Access.Busy;\n+         L : Natural renames Container'Unrestricted_Access.Lock;\n+\n+         Result : Index_Type'Base;\n+\n+      begin\n+         B := B + 1;\n+         L := L + 1;\n+\n+         Result := No_Index;\n+         for J in Position.Index .. Container.Last loop\n+            if Container.Elements (To_Array_Index (J)) = Item then\n+               Result := J;\n+               exit;\n+            end if;\n+         end loop;\n+\n+         B := B - 1;\n+         L := L - 1;\n+\n+         if Result = No_Index then\n+            return No_Element;\n+         else\n+            return Cursor'(Container'Unrestricted_Access, Result);\n          end if;\n-      end loop;\n \n-      return No_Element;\n+      exception\n+         when others =>\n+            B := B - 1;\n+            L := L - 1;\n+            raise;\n+      end;\n    end Find;\n \n    ----------------\n@@ -756,14 +819,36 @@ package body Ada.Containers.Bounded_Vectors is\n       Item      : Element_Type;\n       Index     : Index_Type := Index_Type'First) return Extended_Index\n    is\n+      B : Natural renames Container'Unrestricted_Access.Busy;\n+      L : Natural renames Container'Unrestricted_Access.Lock;\n+\n+      Result : Index_Type'Base;\n+\n    begin\n+      --  Per AI05-0022, the container implementation is required to detect\n+      --  element tampering by a generic actual subprogram.\n+\n+      B := B + 1;\n+      L := L + 1;\n+\n+      Result := No_Index;\n       for Indx in Index .. Container.Last loop\n          if Container.Elements (To_Array_Index (Indx)) = Item then\n-            return Indx;\n+            Result := Indx;\n+            exit;\n          end if;\n       end loop;\n \n-      return No_Index;\n+      B := B - 1;\n+      L := L - 1;\n+\n+      return Result;\n+\n+   exception\n+      when others =>\n+         B := B - 1;\n+         L := L - 1;\n+         raise;\n    end Find_Index;\n \n    -----------\n@@ -841,17 +926,40 @@ package body Ada.Containers.Bounded_Vectors is\n             return True;\n          end if;\n \n+         --  Per AI05-0022, the container implementation is required to detect\n+         --  element tampering by a generic actual subprogram.\n+\n          declare\n             EA : Elements_Array renames Container.Elements;\n+\n+            B : Natural renames Container'Unrestricted_Access.Busy;\n+            L : Natural renames Container'Unrestricted_Access.Lock;\n+\n+            Result : Boolean;\n+\n          begin\n+            B := B + 1;\n+            L := L + 1;\n+\n+            Result := True;\n             for J in 1 .. Container.Length - 1 loop\n                if EA (J + 1) < EA (J) then\n-                  return False;\n+                  Result := False;\n+                  exit;\n                end if;\n             end loop;\n-         end;\n \n-         return True;\n+            B := B - 1;\n+            L := L - 1;\n+\n+            return Result;\n+\n+         exception\n+            when others =>\n+               B := B - 1;\n+               L := L - 1;\n+               raise;\n+         end;\n       end Is_Sorted;\n \n       -----------\n@@ -862,7 +970,6 @@ package body Ada.Containers.Bounded_Vectors is\n          I, J : Count_Type;\n \n       begin\n-\n          --  The semantics of Merge changed slightly per AI05-0021. It was\n          --  originally the case that if Target and Source denoted the same\n          --  container object, then the GNAT implementation of Merge did\n@@ -893,21 +1000,35 @@ package body Ada.Containers.Bounded_Vectors is\n          I := Target.Length;\n          Target.Set_Length (I + Source.Length);\n \n+         --  Per AI05-0022, the container implementation is required to detect\n+         --  element tampering by a generic actual subprogram.\n+\n          declare\n             TA : Elements_Array renames Target.Elements;\n             SA : Elements_Array renames Source.Elements;\n \n+            TB : Natural renames Target.Busy;\n+            TL : Natural renames Target.Lock;\n+\n+            SB : Natural renames Source.Busy;\n+            SL : Natural renames Source.Lock;\n+\n          begin\n+            TB := TB + 1;\n+            TL := TL + 1;\n+\n+            SB := SB + 1;\n+            SL := SL + 1;\n+\n             J := Target.Length;\n             while not Source.Is_Empty loop\n                pragma Assert (Source.Length <= 1\n-                                or else not (SA (Source.Length) <\n-                                             SA (Source.Length - 1)));\n+                 or else not (SA (Source.Length) < SA (Source.Length - 1)));\n \n                if I = 0 then\n                   TA (1 .. J) := SA (1 .. Source.Length);\n                   Source.Last := No_Index;\n-                  return;\n+                  exit;\n                end if;\n \n                pragma Assert (I <= 1\n@@ -924,6 +1045,22 @@ package body Ada.Containers.Bounded_Vectors is\n \n                J := J - 1;\n             end loop;\n+\n+            TB := TB - 1;\n+            TL := TL - 1;\n+\n+            SB := SB - 1;\n+            SL := SL - 1;\n+\n+         exception\n+            when others =>\n+               TB := TB - 1;\n+               TL := TL - 1;\n+\n+               SB := SB - 1;\n+               SL := SL - 1;\n+\n+               raise;\n          end;\n       end Merge;\n \n@@ -960,7 +1097,28 @@ package body Ada.Containers.Bounded_Vectors is\n               \"attempt to tamper with cursors (vector is busy)\";\n          end if;\n \n-         Sort (Container.Elements (1 .. Container.Length));\n+         --  Per AI05-0022, the container implementation is required to detect\n+         --  element tampering by a generic actual subprogram.\n+\n+         declare\n+            B : Natural renames Container.Busy;\n+            L : Natural renames Container.Lock;\n+\n+         begin\n+            B := B + 1;\n+            L := L + 1;\n+\n+            Sort (Container.Elements (1 .. Container.Length));\n+\n+            B := B - 1;\n+            L := L - 1;\n+\n+         exception\n+            when others =>\n+               B := B - 1;\n+               L := L - 1;\n+               raise;\n+         end;\n       end Sort;\n \n    end Generic_Sorting;\n@@ -1056,17 +1214,20 @@ package body Ada.Containers.Bounded_Vectors is\n       --  acceptable, then we compute the new last index from that.\n \n       if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+\n          --  We have to handle the case when there might be more values in the\n          --  range of Index_Type than in the range of Count_Type.\n \n          if Index_Type'First <= 0 then\n+\n             --  We know that No_Index (the same as Index_Type'First - 1) is\n             --  less than 0, so it is safe to compute the following sum without\n             --  fear of overflow.\n \n             Index := No_Index + Index_Type'Base (Count_Type'Last);\n \n             if Index <= Index_Type'Last then\n+\n                --  We have determined that range of Index_Type has at least as\n                --  many values as in Count_Type, so Count_Type'Last is the\n                --  maximum number of items that are allowed.\n@@ -1091,13 +1252,15 @@ package body Ada.Containers.Bounded_Vectors is\n          end if;\n \n       elsif Index_Type'First <= 0 then\n+\n          --  We know that No_Index (the same as Index_Type'First - 1) is less\n          --  than 0, so it is safe to compute the following sum without fear of\n          --  overflow.\n \n          J := Count_Type'Base (No_Index) + Count_Type'Last;\n \n          if J <= Count_Type'Base (Index_Type'Last) then\n+\n             --  We have determined that range of Index_Type has at least as\n             --  many values as in Count_Type, so Count_Type'Last is the maximum\n             --  number of items that are allowed.\n@@ -1151,6 +1314,7 @@ package body Ada.Containers.Bounded_Vectors is\n       J := To_Array_Index (Before);\n \n       if Before > Container.Last then\n+\n          --  The new items are being appended to the vector, so no\n          --  sliding of existing elements is required.\n \n@@ -1508,17 +1672,20 @@ package body Ada.Containers.Bounded_Vectors is\n       --  acceptable, then we compute the new last index from that.\n \n       if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+\n          --  We have to handle the case when there might be more values in the\n          --  range of Index_Type than in the range of Count_Type.\n \n          if Index_Type'First <= 0 then\n+\n             --  We know that No_Index (the same as Index_Type'First - 1) is\n             --  less than 0, so it is safe to compute the following sum without\n             --  fear of overflow.\n \n             Index := No_Index + Index_Type'Base (Count_Type'Last);\n \n             if Index <= Index_Type'Last then\n+\n                --  We have determined that range of Index_Type has at least as\n                --  many values as in Count_Type, so Count_Type'Last is the\n                --  maximum number of items that are allowed.\n@@ -1543,13 +1710,15 @@ package body Ada.Containers.Bounded_Vectors is\n          end if;\n \n       elsif Index_Type'First <= 0 then\n+\n          --  We know that No_Index (the same as Index_Type'First - 1) is less\n          --  than 0, so it is safe to compute the following sum without fear of\n          --  overflow.\n \n          J := Count_Type'Base (No_Index) + Count_Type'Last;\n \n          if J <= Count_Type'Base (Index_Type'Last) then\n+\n             --  We have determined that range of Index_Type has at least as\n             --  many values as in Count_Type, so Count_Type'Last is the maximum\n             --  number of items that are allowed.\n@@ -1608,6 +1777,7 @@ package body Ada.Containers.Bounded_Vectors is\n       --  unused storage for the new items.\n \n       if Before <= Container.Last then\n+\n          --  The space is being inserted before some existing elements,\n          --  so we must slide the existing elements up to their new home.\n \n@@ -1927,36 +2097,30 @@ package body Ada.Containers.Bounded_Vectors is\n    begin\n       if Position.Container = null then\n          return No_Element;\n-      end if;\n-\n-      if Position.Index < Position.Container.Last then\n+      elsif Position.Index < Position.Container.Last then\n          return (Position.Container, Position.Index + 1);\n+      else\n+         return No_Element;\n       end if;\n-\n-      return No_Element;\n    end Next;\n \n    function Next (Object : Iterator; Position : Cursor) return Cursor is\n    begin\n       if Position.Container = null then\n          return No_Element;\n-      end if;\n-\n-      if Position.Container /= Object.Container then\n+      elsif Position.Container /= Object.Container then\n          raise Program_Error with\n            \"Position cursor of Next designates wrong vector\";\n+      else\n+         return Next (Position);\n       end if;\n-\n-      return Next (Position);\n    end Next;\n \n    procedure Next (Position : in out Cursor) is\n    begin\n       if Position.Container = null then\n          return;\n-      end if;\n-\n-      if Position.Index < Position.Container.Last then\n+      elsif Position.Index < Position.Container.Last then\n          Position.Index := Position.Index + 1;\n       else\n          Position := No_Element;\n@@ -1992,9 +2156,7 @@ package body Ada.Containers.Bounded_Vectors is\n    begin\n       if Position.Container = null then\n          return;\n-      end if;\n-\n-      if Position.Index > Index_Type'First then\n+      elsif Position.Index > Index_Type'First then\n          Position.Index := Position.Index - 1;\n       else\n          Position := No_Element;\n@@ -2005,27 +2167,23 @@ package body Ada.Containers.Bounded_Vectors is\n    begin\n       if Position.Container = null then\n          return No_Element;\n-      end if;\n-\n-      if Position.Index > Index_Type'First then\n+      elsif Position.Index > Index_Type'First then\n          return (Position.Container, Position.Index - 1);\n+      else\n+         return No_Element;\n       end if;\n-\n-      return No_Element;\n    end Previous;\n \n    function Previous (Object : Iterator; Position : Cursor) return Cursor is\n    begin\n       if Position.Container = null then\n          return No_Element;\n-      end if;\n-\n-      if Position.Container /= Object.Container then\n+      elsif Position.Container /= Object.Container then\n          raise Program_Error with\n            \"Position cursor of Previous designates wrong vector\";\n+      else\n+         return Previous (Position);\n       end if;\n-\n-      return Previous (Position);\n    end Previous;\n \n    -------------------\n@@ -2069,9 +2227,9 @@ package body Ada.Containers.Bounded_Vectors is\n    begin\n       if Position.Container = null then\n          raise Constraint_Error with \"Position cursor has no element\";\n+      else\n+         Query_Element (Position.Container.all, Position.Index, Process);\n       end if;\n-\n-      Query_Element (Position.Container.all, Position.Index, Process);\n    end Query_Element;\n \n    ----------\n@@ -2146,9 +2304,9 @@ package body Ada.Containers.Bounded_Vectors is\n \n       declare\n          A : Elements_Array renames Container.Elements;\n-         I : constant Count_Type := To_Array_Index (Position.Index);\n+         J : constant Count_Type := To_Array_Index (Position.Index);\n       begin\n-         return (Element => A (I)'Access);\n+         return (Element => A (J)'Access);\n       end;\n    end Reference;\n \n@@ -2163,9 +2321,9 @@ package body Ada.Containers.Bounded_Vectors is\n \n       declare\n          A : Elements_Array renames Container.Elements;\n-         I : constant Count_Type := To_Array_Index (Index);\n+         J : constant Count_Type := To_Array_Index (Index);\n       begin\n-         return (Element => A (I)'Access);\n+         return (Element => A (J)'Access);\n       end;\n    end Reference;\n \n@@ -2181,14 +2339,12 @@ package body Ada.Containers.Bounded_Vectors is\n    begin\n       if Index > Container.Last then\n          raise Constraint_Error with \"Index is out of range\";\n-      end if;\n-\n-      if Container.Lock > 0 then\n+      elsif Container.Lock > 0 then\n          raise Program_Error with\n            \"attempt to tamper with elements (vector is locked)\";\n+      else\n+         Container.Elements (To_Array_Index (Index)) := New_Item;\n       end if;\n-\n-      Container.Elements (To_Array_Index (Index)) := New_Item;\n    end Replace_Element;\n \n    procedure Replace_Element\n@@ -2199,22 +2355,20 @@ package body Ada.Containers.Bounded_Vectors is\n    begin\n       if Position.Container = null then\n          raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      elsif Position.Container /= Container'Unrestricted_Access then\n          raise Program_Error with \"Position cursor denotes wrong container\";\n-      end if;\n \n-      if Position.Index > Container.Last then\n+      elsif Position.Index > Container.Last then\n          raise Constraint_Error with \"Position cursor is out of range\";\n-      end if;\n \n-      if Container.Lock > 0 then\n+      elsif Container.Lock > 0 then\n          raise Program_Error with\n            \"attempt to tamper with elements (vector is locked)\";\n-      end if;\n \n-      Container.Elements (To_Array_Index (Position.Index)) := New_Item;\n+      else\n+         Container.Elements (To_Array_Index (Position.Index)) := New_Item;\n+      end if;\n    end Replace_Element;\n \n    ----------------------\n@@ -2300,13 +2454,41 @@ package body Ada.Containers.Bounded_Vectors is\n          then Container.Last\n          else Position.Index);\n \n-      for Indx in reverse Index_Type'First .. Last loop\n-         if Container.Elements (To_Array_Index (Indx)) = Item then\n-            return (Container'Unrestricted_Access, Indx);\n-         end if;\n-      end loop;\n+      --  Per AI05-0022, the container implementation is required to detect\n+      --  element tampering by a generic actual subprogram.\n+\n+      declare\n+         B : Natural renames Container'Unrestricted_Access.Busy;\n+         L : Natural renames Container'Unrestricted_Access.Lock;\n+\n+         Result : Index_Type'Base;\n+\n+      begin\n+         B := B + 1;\n+         L := L + 1;\n+\n+         Result := No_Index;\n+         for Indx in reverse Index_Type'First .. Last loop\n+            if Container.Elements (To_Array_Index (Indx)) = Item then\n+               Result := Indx;\n+               exit;\n+            end if;\n+         end loop;\n+\n+         B := B - 1;\n+         L := L - 1;\n \n-      return No_Element;\n+         if Result = No_Index then\n+            return No_Element;\n+         else\n+            return Cursor'(Container'Unrestricted_Access, Result);\n+         end if;\n+      exception\n+         when others =>\n+            B := B - 1;\n+            L := L - 1;\n+            raise;\n+      end;\n    end Reverse_Find;\n \n    ------------------------\n@@ -2318,17 +2500,39 @@ package body Ada.Containers.Bounded_Vectors is\n       Item      : Element_Type;\n       Index     : Index_Type := Index_Type'Last) return Extended_Index\n    is\n+      B : Natural renames Container'Unrestricted_Access.Busy;\n+      L : Natural renames Container'Unrestricted_Access.Lock;\n+\n       Last : constant Index_Type'Base :=\n         Index_Type'Min (Container.Last, Index);\n \n+      Result : Index_Type'Base;\n+\n    begin\n+      --  Per AI05-0022, the container implementation is required to detect\n+      --  element tampering by a generic actual subprogram.\n+\n+      B := B + 1;\n+      L := L + 1;\n+\n+      Result := No_Index;\n       for Indx in reverse Index_Type'First .. Last loop\n          if Container.Elements (To_Array_Index (Indx)) = Item then\n-            return Indx;\n+            Result := Indx;\n+            exit;\n          end if;\n       end loop;\n \n-      return No_Index;\n+      B := B - 1;\n+      L := L - 1;\n+\n+      return Result;\n+\n+   exception\n+      when others =>\n+         B := B - 1;\n+         L := L - 1;\n+         raise;\n    end Reverse_Find_Index;\n \n    ---------------------\n@@ -2375,10 +2579,8 @@ package body Ada.Containers.Bounded_Vectors is\n \n       if Count >= 0 then\n          Container.Delete_Last (Count);\n-\n       elsif Container.Last >= Index_Type'Last then\n          raise Constraint_Error with \"vector is already at its maximum length\";\n-\n       else\n          Container.Insert_Space (Container.Last + 1, -Count);\n       end if;\n@@ -2451,11 +2653,11 @@ package body Ada.Containers.Bounded_Vectors is\n       --  hence we also know that\n       --    Index - Index_Type'First >= 0\n \n-      --  The issue is that even though 0 is guaranteed to be a value\n-      --  in the type Index_Type'Base, there's no guarantee that the\n-      --  difference is a value in that type. To prevent overflow we\n-      --  use the wider of Count_Type'Base and Index_Type'Base to\n-      --  perform intermediate calculations.\n+      --  The issue is that even though 0 is guaranteed to be a value in\n+      --  the type Index_Type'Base, there's no guarantee that the difference\n+      --  is a value in that type. To prevent overflow we use the wider\n+      --  of Count_Type'Base and Index_Type'Base to perform intermediate\n+      --  calculations.\n \n       if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n          Offset := Count_Type'Base (Index - Index_Type'First);"}, {"sha": "d63ebc0750079f6d57080258d897ae87820c2a35", "filename": "gcc/ada/a-coinve.adb", "status": "modified", "additions": 377, "deletions": 226, "changes": 603, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2602b64e3a4072c8819cad2f3abffe2d5ae69de3/gcc%2Fada%2Fa-coinve.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2602b64e3a4072c8819cad2f3abffe2d5ae69de3/gcc%2Fada%2Fa-coinve.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coinve.adb?ref=2602b64e3a4072c8819cad2f3abffe2d5ae69de3", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -117,7 +117,6 @@ package body Ada.Containers.Indefinite_Vectors is\n \n             return (Controlled with Elements, Right.Last, 0, 0);\n          end;\n-\n       end if;\n \n       if RN = 0 then\n@@ -243,7 +242,6 @@ package body Ada.Containers.Indefinite_Vectors is\n       declare\n          LE : Elements_Array renames\n                 Left.Elements.EA (Index_Type'First .. Left.Last);\n-\n          RE : Elements_Array renames\n                 Right.Elements.EA (Index_Type'First .. Right.Last);\n \n@@ -514,6 +512,14 @@ package body Ada.Containers.Indefinite_Vectors is\n    ---------\n \n    overriding function \"=\" (Left, Right : Vector) return Boolean is\n+      BL : Natural renames Left'Unrestricted_Access.Busy;\n+      LL : Natural renames Left'Unrestricted_Access.Lock;\n+\n+      BR : Natural renames Right'Unrestricted_Access.Busy;\n+      LR : Natural renames Right'Unrestricted_Access.Lock;\n+\n+      Result : Boolean;\n+\n    begin\n       if Left'Address = Right'Address then\n          return True;\n@@ -523,21 +529,49 @@ package body Ada.Containers.Indefinite_Vectors is\n          return False;\n       end if;\n \n+      --  Per AI05-0022, the container implementation is required to detect\n+      --  element tampering by a generic actual subprogram.\n+\n+      BL := BL + 1;\n+      LL := LL + 1;\n+\n+      BR := BR + 1;\n+      LR := LR + 1;\n+\n+      Result := True;\n       for J in Index_Type'First .. Left.Last loop\n          if Left.Elements.EA (J) = null then\n             if Right.Elements.EA (J) /= null then\n-               return False;\n+               Result := False;\n+               exit;\n             end if;\n \n          elsif Right.Elements.EA (J) = null then\n-            return False;\n+            Result := False;\n+            exit;\n \n          elsif Left.Elements.EA (J).all /= Right.Elements.EA (J).all then\n-            return False;\n+            Result := False;\n+            exit;\n          end if;\n       end loop;\n \n-      return True;\n+      BL := BL - 1;\n+      LL := LL - 1;\n+\n+      BR := BR - 1;\n+      LR := LR - 1;\n+\n+      return Result;\n+   exception\n+      when others =>\n+         BL := BL - 1;\n+         LL := LL - 1;\n+\n+         BR := BR - 1;\n+         LR := LR - 1;\n+\n+         raise;\n    end \"=\";\n \n    ------------\n@@ -564,12 +598,12 @@ package body Ada.Containers.Indefinite_Vectors is\n \n          Container.Elements := new Elements_Type (L);\n \n-         for I in E'Range loop\n-            if E (I) /= null then\n-               Container.Elements.EA (I) := new Element_Type'(E (I).all);\n+         for J in E'Range loop\n+            if E (J) /= null then\n+               Container.Elements.EA (J) := new Element_Type'(E (J).all);\n             end if;\n \n-            Container.Last := I;\n+            Container.Last := J;\n          end loop;\n       end;\n    end Adjust;\n@@ -596,16 +630,11 @@ package body Ada.Containers.Indefinite_Vectors is\n    begin\n       if Is_Empty (New_Item) then\n          return;\n-      end if;\n-\n-      if Container.Last = Index_Type'Last then\n+      elsif Container.Last = Index_Type'Last then\n          raise Constraint_Error with \"vector is already at its maximum length\";\n+      else\n+         Insert (Container, Container.Last + 1, New_Item);\n       end if;\n-\n-      Insert\n-        (Container,\n-         Container.Last + 1,\n-         New_Item);\n    end Append;\n \n    procedure Append\n@@ -616,17 +645,11 @@ package body Ada.Containers.Indefinite_Vectors is\n    begin\n       if Count = 0 then\n          return;\n-      end if;\n-\n-      if Container.Last = Index_Type'Last then\n+      elsif Container.Last = Index_Type'Last then\n          raise Constraint_Error with \"vector is already at its maximum length\";\n+      else\n+         Insert (Container, Container.Last + 1, New_Item, Count);\n       end if;\n-\n-      Insert\n-        (Container,\n-         Container.Last + 1,\n-         New_Item,\n-         Count);\n    end Append;\n \n    ------------\n@@ -637,10 +660,10 @@ package body Ada.Containers.Indefinite_Vectors is\n    begin\n       if Target'Address = Source'Address then\n          return;\n+      else\n+         Target.Clear;\n+         Target.Append (Source);\n       end if;\n-\n-      Target.Clear;\n-      Target.Append (Source);\n    end Assign;\n \n    --------------\n@@ -651,9 +674,9 @@ package body Ada.Containers.Indefinite_Vectors is\n    begin\n       if Container.Elements = null then\n          return 0;\n+      else\n+         return Container.Elements.EA'Length;\n       end if;\n-\n-      return Container.Elements.EA'Length;\n    end Capacity;\n \n    -----------\n@@ -665,17 +688,18 @@ package body Ada.Containers.Indefinite_Vectors is\n       if Container.Busy > 0 then\n          raise Program_Error with\n            \"attempt to tamper with cursors (vector is busy)\";\n-      end if;\n \n-      while Container.Last >= Index_Type'First loop\n-         declare\n-            X : Element_Access := Container.Elements.EA (Container.Last);\n-         begin\n-            Container.Elements.EA (Container.Last) := null;\n-            Container.Last := Container.Last - 1;\n-            Free (X);\n-         end;\n-      end loop;\n+      else\n+         while Container.Last >= Index_Type'First loop\n+            declare\n+               X : Element_Access := Container.Elements.EA (Container.Last);\n+            begin\n+               Container.Elements.EA (Container.Last) := null;\n+               Container.Last := Container.Last - 1;\n+               Free (X);\n+            end;\n+         end loop;\n+      end if;\n    end Clear;\n \n    ------------------------\n@@ -840,9 +864,9 @@ package body Ada.Containers.Indefinite_Vectors is\n       if Index > Old_Last then\n          if Index > Old_Last + 1 then\n             raise Constraint_Error with \"Index is out of range (too large)\";\n+         else\n+            return;\n          end if;\n-\n-         return;\n       end if;\n \n       --  Here and elsewhere we treat deleting 0 items from the container as a\n@@ -934,7 +958,6 @@ package body Ada.Containers.Indefinite_Vectors is\n       if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n          New_Last := Old_Last - Index_Type'Base (Count);\n          J := Index + Index_Type'Base (Count);\n-\n       else\n          New_Last := Index_Type'Base (Count_Type'Base (Old_Last) - Count);\n          J := Index_Type'Base (Count_Type'Base (Index) + Count);\n@@ -987,19 +1010,17 @@ package body Ada.Containers.Indefinite_Vectors is\n    begin\n       if Position.Container = null then\n          raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      elsif Position.Container /= Container'Unrestricted_Access then\n          raise Program_Error with \"Position cursor denotes wrong container\";\n-      end if;\n \n-      if Position.Index > Container.Last then\n+      elsif Position.Index > Container.Last then\n          raise Program_Error with \"Position index is out of range\";\n-      end if;\n-\n-      Delete (Container, Position.Index, Count);\n \n-      Position := No_Element;\n+      else\n+         Delete (Container, Position.Index, Count);\n+         Position := No_Element;\n+      end if;\n    end Delete;\n \n    ------------------\n@@ -1013,14 +1034,14 @@ package body Ada.Containers.Indefinite_Vectors is\n    begin\n       if Count = 0 then\n          return;\n-      end if;\n \n-      if Count >= Length (Container) then\n+      elsif Count >= Length (Container) then\n          Clear (Container);\n          return;\n-      end if;\n \n-      Delete (Container, Index_Type'First, Count);\n+      else\n+         Delete (Container, Index_Type'First, Count);\n+      end if;\n    end Delete_First;\n \n    -----------------\n@@ -1110,13 +1131,12 @@ package body Ada.Containers.Indefinite_Vectors is\n \n       declare\n          EA : constant Element_Access := Container.Elements.EA (Index);\n-\n       begin\n          if EA = null then\n             raise Constraint_Error with \"element is empty\";\n+         else\n+            return EA.all;\n          end if;\n-\n-         return EA.all;\n       end;\n    end Element;\n \n@@ -1132,14 +1152,13 @@ package body Ada.Containers.Indefinite_Vectors is\n \n       declare\n          EA : constant Element_Access :=\n-           Position.Container.Elements.EA (Position.Index);\n-\n+                Position.Container.Elements.EA (Position.Index);\n       begin\n          if EA = null then\n             raise Constraint_Error with \"element is empty\";\n+         else\n+            return EA.all;\n          end if;\n-\n-         return EA.all;\n       end;\n    end Element;\n \n@@ -1201,15 +1220,44 @@ package body Ada.Containers.Indefinite_Vectors is\n          end if;\n       end if;\n \n-      for J in Position.Index .. Container.Last loop\n-         if Container.Elements.EA (J) /= null\n-           and then Container.Elements.EA (J).all = Item\n-         then\n-            return (Container'Unrestricted_Access, J);\n+      --  Per AI05-0022, the container implementation is required to detect\n+      --  element tampering by a generic actual subprogram.\n+\n+      declare\n+         B : Natural renames Container'Unrestricted_Access.Busy;\n+         L : Natural renames Container'Unrestricted_Access.Lock;\n+\n+         Result : Index_Type'Base;\n+\n+      begin\n+         B := B + 1;\n+         L := L + 1;\n+\n+         Result := No_Index;\n+         for J in Position.Index .. Container.Last loop\n+            if Container.Elements.EA (J) /= null\n+              and then Container.Elements.EA (J).all = Item\n+            then\n+               Result := J;\n+               exit;\n+            end if;\n+         end loop;\n+\n+         B := B - 1;\n+         L := L - 1;\n+\n+         if Result = No_Index then\n+            return No_Element;\n+         else\n+            return Cursor'(Container'Unrestricted_Access, Result);\n          end if;\n-      end loop;\n \n-      return No_Element;\n+      exception\n+         when others =>\n+            B := B - 1;\n+            L := L - 1;\n+            raise;\n+      end;\n    end Find;\n \n    ----------------\n@@ -1221,16 +1269,38 @@ package body Ada.Containers.Indefinite_Vectors is\n       Item      : Element_Type;\n       Index     : Index_Type := Index_Type'First) return Extended_Index\n    is\n+      B : Natural renames Container'Unrestricted_Access.Busy;\n+      L : Natural renames Container'Unrestricted_Access.Lock;\n+\n+      Result : Index_Type'Base;\n+\n    begin\n+      --  Per AI05-0022, the container implementation is required to detect\n+      --  element tampering by a generic actual subprogram.\n+\n+      B := B + 1;\n+      L := L + 1;\n+\n+      Result := No_Index;\n       for Indx in Index .. Container.Last loop\n          if Container.Elements.EA (Indx) /= null\n            and then Container.Elements.EA (Indx).all = Item\n          then\n-            return Indx;\n+            Result := Indx;\n+            exit;\n          end if;\n       end loop;\n \n-      return No_Index;\n+      B := B - 1;\n+      L := L - 1;\n+\n+      return Result;\n+\n+   exception\n+      when others =>\n+         B := B - 1;\n+         L := L - 1;\n+         raise;\n    end Find_Index;\n \n    -----------\n@@ -1281,14 +1351,13 @@ package body Ada.Containers.Indefinite_Vectors is\n \n       declare\n          EA : constant Element_Access :=\n-           Container.Elements.EA (Index_Type'First);\n-\n+                Container.Elements.EA (Index_Type'First);\n       begin\n          if EA = null then\n             raise Constraint_Error with \"first element is empty\";\n+         else\n+            return EA.all;\n          end if;\n-\n-         return EA.all;\n       end;\n    end First_Element;\n \n@@ -1340,17 +1409,40 @@ package body Ada.Containers.Indefinite_Vectors is\n             return True;\n          end if;\n \n+         --  Per AI05-0022, the container implementation is required to detect\n+         --  element tampering by a generic actual subprogram.\n+\n          declare\n             E : Elements_Array renames Container.Elements.EA;\n+\n+            B : Natural renames Container'Unrestricted_Access.Busy;\n+            L : Natural renames Container'Unrestricted_Access.Lock;\n+\n+            Result : Boolean;\n+\n          begin\n+            B := B + 1;\n+            L := L + 1;\n+\n+            Result := True;\n             for I in Index_Type'First .. Container.Last - 1 loop\n                if Is_Less (E (I + 1), E (I)) then\n-                  return False;\n+                  Result := False;\n+                  exit;\n                end if;\n             end loop;\n-         end;\n \n-         return True;\n+            B := B - 1;\n+            L := L - 1;\n+\n+            return Result;\n+\n+         exception\n+            when others =>\n+               B := B - 1;\n+               L := L - 1;\n+               raise;\n+         end;\n       end Is_Sorted;\n \n       -----------\n@@ -1361,7 +1453,6 @@ package body Ada.Containers.Indefinite_Vectors is\n          I, J : Index_Type'Base;\n \n       begin\n-\n          --  The semantics of Merge changed slightly per AI05-0021. It was\n          --  originally the case that if Target and Source denoted the same\n          --  container object, then the GNAT implementation of Merge did\n@@ -1392,53 +1483,86 @@ package body Ada.Containers.Indefinite_Vectors is\n          I := Target.Last;  -- original value (before Set_Length)\n          Target.Set_Length (Length (Target) + Length (Source));\n \n-         J := Target.Last;  -- new value (after Set_Length)\n-         while Source.Last >= Index_Type'First loop\n-            pragma Assert\n-              (Source.Last <= Index_Type'First\n-                 or else not (Is_Less\n-                                (Source.Elements.EA (Source.Last),\n-                                 Source.Elements.EA (Source.Last - 1))));\n+         --  Per AI05-0022, the container implementation is required to detect\n+         --  element tampering by a generic actual subprogram.\n+\n+         declare\n+            TA : Elements_Array renames Target.Elements.EA;\n+            SA : Elements_Array renames Source.Elements.EA;\n+\n+            TB : Natural renames Target.Busy;\n+            TL : Natural renames Target.Lock;\n+\n+            SB : Natural renames Source.Busy;\n+            SL : Natural renames Source.Lock;\n+\n+         begin\n+            TB := TB + 1;\n+            TL := TL + 1;\n+\n+            SB := SB + 1;\n+            SL := SL + 1;\n+\n+            J := Target.Last;  -- new value (after Set_Length)\n+            while Source.Last >= Index_Type'First loop\n+               pragma Assert\n+                 (Source.Last <= Index_Type'First\n+                   or else not (Is_Less (SA (Source.Last),\n+                                         SA (Source.Last - 1))));\n+\n+               if I < Index_Type'First then\n+                  declare\n+                     Src : Elements_Array renames\n+                             SA (Index_Type'First .. Source.Last);\n+                  begin\n+                     TA (Index_Type'First .. J) := Src;\n+                     Src := (others => null);\n+                  end;\n+\n+                  Source.Last := No_Index;\n+                  exit;\n+               end if;\n+\n+               pragma Assert\n+                 (I <= Index_Type'First\n+                    or else not (Is_Less (TA (I), TA (I - 1))));\n \n-            if I < Index_Type'First then\n                declare\n-                  Src : Elements_Array renames\n-                    Source.Elements.EA (Index_Type'First .. Source.Last);\n+                  Src : Element_Access renames SA (Source.Last);\n+                  Tgt : Element_Access renames TA (I);\n \n                begin\n-                  Target.Elements.EA (Index_Type'First .. J) := Src;\n-                  Src := (others => null);\n+                  if Is_Less (Src, Tgt) then\n+                     Target.Elements.EA (J) := Tgt;\n+                     Tgt := null;\n+                     I := I - 1;\n+\n+                  else\n+                     Target.Elements.EA (J) := Src;\n+                     Src := null;\n+                     Source.Last := Source.Last - 1;\n+                  end if;\n                end;\n \n-               Source.Last := No_Index;\n-               return;\n-            end if;\n+               J := J - 1;\n+            end loop;\n \n-            pragma Assert\n-              (I <= Index_Type'First\n-                 or else not (Is_Less\n-                                (Target.Elements.EA (I),\n-                                 Target.Elements.EA (I - 1))));\n+            TB := TB - 1;\n+            TL := TL - 1;\n \n-            declare\n-               Src : Element_Access renames Source.Elements.EA (Source.Last);\n-               Tgt : Element_Access renames Target.Elements.EA (I);\n+            SB := SB - 1;\n+            SL := SL - 1;\n \n-            begin\n-               if Is_Less (Src, Tgt) then\n-                  Target.Elements.EA (J) := Tgt;\n-                  Tgt := null;\n-                  I := I - 1;\n+         exception\n+            when others =>\n+               TB := TB - 1;\n+               TL := TL - 1;\n \n-               else\n-                  Target.Elements.EA (J) := Src;\n-                  Src := null;\n-                  Source.Last := Source.Last - 1;\n-               end if;\n-            end;\n+               SB := SB - 1;\n+               SL := SL - 1;\n \n-            J := J - 1;\n-         end loop;\n+               raise;\n+         end;\n       end Merge;\n \n       ----------\n@@ -1475,7 +1599,28 @@ package body Ada.Containers.Indefinite_Vectors is\n               \"attempt to tamper with cursors (vector is busy)\";\n          end if;\n \n-         Sort (Container.Elements.EA (Index_Type'First .. Container.Last));\n+         --  Per AI05-0022, the container implementation is required to detect\n+         --  element tampering by a generic actual subprogram.\n+\n+         declare\n+            B : Natural renames Container.Busy;\n+            L : Natural renames Container.Lock;\n+\n+         begin\n+            B := B + 1;\n+            L := L + 1;\n+\n+            Sort (Container.Elements.EA (Index_Type'First .. Container.Last));\n+\n+            B := B - 1;\n+            L := L - 1;\n+\n+         exception\n+            when others =>\n+               B := B - 1;\n+               L := L - 1;\n+               raise;\n+         end;\n       end Sort;\n \n    end Generic_Sorting;\n@@ -1488,9 +1633,9 @@ package body Ada.Containers.Indefinite_Vectors is\n    begin\n       if Position.Container = null then\n          return False;\n+      else\n+         return Position.Index <= Position.Container.Last;\n       end if;\n-\n-      return Position.Index <= Position.Container.Last;\n    end Has_Element;\n \n    ------------\n@@ -1663,7 +1808,6 @@ package body Ada.Containers.Indefinite_Vectors is\n \n       if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n          New_Last := No_Index + Index_Type'Base (New_Length);\n-\n       else\n          New_Last := Index_Type'Base (Count_Type'Base (No_Index) + New_Length);\n       end if;\n@@ -1859,7 +2003,6 @@ package body Ada.Containers.Indefinite_Vectors is\n \n       if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n          Dst_Last := No_Index + Index_Type'Base (New_Capacity);\n-\n       else\n          Dst_Last :=\n            Index_Type'Base (Count_Type'Base (No_Index) + New_Capacity);\n@@ -1888,9 +2031,8 @@ package body Ada.Containers.Indefinite_Vectors is\n             --  The new items are being appended to the vector, so no\n             --  sliding of existing elements is required.\n \n-            --  We have copied the elements from to the old, source array to\n-            --  the new, destination array, so we can now deallocate the old\n-            --  array.\n+            --  We have copied the elements from to the old source array to the\n+            --  new destination array, so we can now deallocate the old array.\n \n             Container.Elements := Dst;\n             Free (Src);\n@@ -1899,11 +2041,11 @@ package body Ada.Containers.Indefinite_Vectors is\n \n             for Idx in Before .. New_Last loop\n \n-               --  In order to preserve container invariants, we always\n-               --  attempt the element allocation first, before setting the\n-               --  Last index value, in case the allocation fails (either\n-               --  because there is no storage available, or because element\n-               --  initialization fails).\n+               --  In order to preserve container invariants, we always attempt\n+               --  the element allocation first, before setting the Last index\n+               --  value, in case the allocation fails (either because there\n+               --  is no storage available, or because element initialization\n+               --  fails).\n \n                declare\n                   --  The element allocator may need an accessibility check in\n@@ -1928,24 +2070,21 @@ package body Ada.Containers.Indefinite_Vectors is\n \n             if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n                Index := Before + Index_Type'Base (Count);\n-\n             else\n                Index := Index_Type'Base (Count_Type'Base (Before) + Count);\n             end if;\n \n             Dst.EA (Index .. New_Last) := Src.EA (Before .. Container.Last);\n \n-            --  We have copied the elements from to the old, source array to\n-            --  the new, destination array, so we can now deallocate the old\n-            --  array.\n+            --  We have copied the elements from to the old source array to the\n+            --  new destination array, so we can now deallocate the old array.\n \n             Container.Elements := Dst;\n             Container.Last := New_Last;\n             Free (Src);\n \n             --  The new array has a range in the middle containing null access\n-            --  values. We now fill in that partition of the array with the new\n-            --  items.\n+            --  values. Fill in that partition of the array with the new items.\n \n             for Idx in Before .. Index - 1 loop\n \n@@ -2081,7 +2220,6 @@ package body Ada.Containers.Indefinite_Vectors is\n \n       if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n          J := Before + Index_Type'Base (N);\n-\n       else\n          J := Index_Type'Base (Count_Type'Base (Before) + N);\n       end if;\n@@ -2105,7 +2243,6 @@ package body Ada.Containers.Indefinite_Vectors is\n \n          if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n             Dst_Index := J - Index_Type'Base (Src'Length);\n-\n          else\n             Dst_Index := Index_Type'Base (Count_Type'Base (J) - Src'Length);\n          end if;\n@@ -2138,9 +2275,7 @@ package body Ada.Containers.Indefinite_Vectors is\n          return;\n       end if;\n \n-      if Before.Container = null\n-        or else Before.Index > Container.Last\n-      then\n+      if Before.Container = null or else Before.Index > Container.Last then\n          if Container.Last = Index_Type'Last then\n             raise Constraint_Error with\n               \"vector is already at its maximum length\";\n@@ -2172,9 +2307,7 @@ package body Ada.Containers.Indefinite_Vectors is\n       end if;\n \n       if Is_Empty (New_Item) then\n-         if Before.Container = null\n-           or else Before.Index > Container.Last\n-         then\n+         if Before.Container = null or else Before.Index > Container.Last then\n             Position := No_Element;\n          else\n             Position := (Container'Unrestricted_Access, Before.Index);\n@@ -2183,9 +2316,7 @@ package body Ada.Containers.Indefinite_Vectors is\n          return;\n       end if;\n \n-      if Before.Container = null\n-        or else Before.Index > Container.Last\n-      then\n+      if Before.Container = null or else Before.Index > Container.Last then\n          if Container.Last = Index_Type'Last then\n             raise Constraint_Error with\n               \"vector is already at its maximum length\";\n@@ -2221,9 +2352,7 @@ package body Ada.Containers.Indefinite_Vectors is\n          return;\n       end if;\n \n-      if Before.Container = null\n-        or else Before.Index > Container.Last\n-      then\n+      if Before.Container = null or else Before.Index > Container.Last then\n          if Container.Last = Index_Type'Last then\n             raise Constraint_Error with\n               \"vector is already at its maximum length\";\n@@ -2266,9 +2395,7 @@ package body Ada.Containers.Indefinite_Vectors is\n          return;\n       end if;\n \n-      if Before.Container = null\n-        or else Before.Index > Container.Last\n-      then\n+      if Before.Container = null or else Before.Index > Container.Last then\n          if Container.Last = Index_Type'Last then\n             raise Constraint_Error with\n               \"vector is already at its maximum length\";\n@@ -2330,9 +2457,7 @@ package body Ada.Containers.Indefinite_Vectors is\n       --  deeper flaw in the caller's algorithm, so that case is treated as a\n       --  proper error.)\n \n-      if Before > Container.Last\n-        and then Before > Container.Last + 1\n-      then\n+      if Before > Container.Last and then Before > Container.Last + 1 then\n          raise Constraint_Error with\n            \"Before index is out of range (too large)\";\n       end if;\n@@ -2453,7 +2578,6 @@ package body Ada.Containers.Indefinite_Vectors is\n \n       if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n          New_Last := No_Index + Index_Type'Base (New_Length);\n-\n       else\n          New_Last := Index_Type'Base (Count_Type'Base (No_Index) + New_Length);\n       end if;\n@@ -2490,7 +2614,8 @@ package body Ada.Containers.Indefinite_Vectors is\n       end if;\n \n       if New_Length <= Container.Elements.EA'Length then\n-         --  In this case, we're inserting elements into a vector that has\n+\n+         --  In this case, we are inserting elements into a vector that has\n          --  already allocated an internal array, and the existing array has\n          --  enough unused storage for the new items.\n \n@@ -2501,13 +2626,12 @@ package body Ada.Containers.Indefinite_Vectors is\n             if Before <= Container.Last then\n \n                --  The new space is being inserted before some existing\n-               --  elements, so we must slide the existing elements up to their\n-               --  new home. We use the wider of Index_Type'Base and\n+               --  elements, so we must slide the existing elements up to\n+               --  their new home. We use the wider of Index_Type'Base and\n                --  Count_Type'Base as the type for intermediate index values.\n \n                if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n                   Index := Before + Index_Type'Base (Count);\n-\n                else\n                   Index := Index_Type'Base (Count_Type'Base (Before) + Count);\n                end if;\n@@ -2554,7 +2678,6 @@ package body Ada.Containers.Indefinite_Vectors is\n \n       if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n          Dst_Last := No_Index + Index_Type'Base (New_Capacity);\n-\n       else\n          Dst_Last :=\n            Index_Type'Base (Count_Type'Base (No_Index) + New_Capacity);\n@@ -2585,7 +2708,6 @@ package body Ada.Containers.Indefinite_Vectors is\n \n             if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n                Index := Before + Index_Type'Base (Count);\n-\n             else\n                Index := Index_Type'Base (Count_Type'Base (Before) + Count);\n             end if;\n@@ -2619,9 +2741,7 @@ package body Ada.Containers.Indefinite_Vectors is\n       end if;\n \n       if Count = 0 then\n-         if Before.Container = null\n-           or else Before.Index > Container.Last\n-         then\n+         if Before.Container = null or else Before.Index > Container.Last then\n             Position := No_Element;\n          else\n             Position := (Container'Unrestricted_Access, Before.Index);\n@@ -2810,14 +2930,13 @@ package body Ada.Containers.Indefinite_Vectors is\n \n       declare\n          EA : constant Element_Access :=\n-           Container.Elements.EA (Container.Last);\n-\n+                Container.Elements.EA (Container.Last);\n       begin\n          if EA = null then\n             raise Constraint_Error with \"last element is empty\";\n+         else\n+            return EA.all;\n          end if;\n-\n-         return EA.all;\n       end;\n    end Last_Element;\n \n@@ -2903,36 +3022,30 @@ package body Ada.Containers.Indefinite_Vectors is\n    begin\n       if Position.Container = null then\n          return No_Element;\n-      end if;\n-\n-      if Position.Index < Position.Container.Last then\n+      elsif Position.Index < Position.Container.Last then\n          return (Position.Container, Position.Index + 1);\n+      else\n+         return No_Element;\n       end if;\n-\n-      return No_Element;\n    end Next;\n \n    function Next (Object : Iterator; Position : Cursor) return Cursor is\n    begin\n       if Position.Container = null then\n          return No_Element;\n-      end if;\n-\n-      if Position.Container /= Object.Container then\n+      elsif Position.Container /= Object.Container then\n          raise Program_Error with\n            \"Position cursor of Next designates wrong vector\";\n+      else\n+         return Next (Position);\n       end if;\n-\n-      return Next (Position);\n    end Next;\n \n    procedure Next (Position : in out Cursor) is\n    begin\n       if Position.Container = null then\n          return;\n-      end if;\n-\n-      if Position.Index < Position.Container.Last then\n+      elsif Position.Index < Position.Container.Last then\n          Position.Index := Position.Index + 1;\n       else\n          Position := No_Element;\n@@ -2954,10 +3067,7 @@ package body Ada.Containers.Indefinite_Vectors is\n       Count     : Count_Type := 1)\n    is\n    begin\n-      Insert (Container,\n-              Index_Type'First,\n-              New_Item,\n-              Count);\n+      Insert (Container, Index_Type'First, New_Item, Count);\n    end Prepend;\n \n    --------------\n@@ -2968,9 +3078,7 @@ package body Ada.Containers.Indefinite_Vectors is\n    begin\n       if Position.Container = null then\n          return;\n-      end if;\n-\n-      if Position.Index > Index_Type'First then\n+      elsif Position.Index > Index_Type'First then\n          Position.Index := Position.Index - 1;\n       else\n          Position := No_Element;\n@@ -2981,27 +3089,23 @@ package body Ada.Containers.Indefinite_Vectors is\n    begin\n       if Position.Container = null then\n          return No_Element;\n-      end if;\n-\n-      if Position.Index > Index_Type'First then\n+      elsif Position.Index > Index_Type'First then\n          return (Position.Container, Position.Index - 1);\n+      else\n+         return No_Element;\n       end if;\n-\n-      return No_Element;\n    end Previous;\n \n    function Previous (Object : Iterator; Position : Cursor) return Cursor is\n    begin\n       if Position.Container = null then\n          return No_Element;\n-      end if;\n-\n-      if Position.Container /= Object.Container then\n+      elsif Position.Container /= Object.Container then\n          raise Program_Error with\n            \"Position cursor of Previous designates wrong vector\";\n+      else\n+         return Previous (Position);\n       end if;\n-\n-      return Previous (Position);\n    end Previous;\n \n    -------------------\n@@ -3049,9 +3153,9 @@ package body Ada.Containers.Indefinite_Vectors is\n    begin\n       if Position.Container = null then\n          raise Constraint_Error with \"Position cursor has no element\";\n+      else\n+         Query_Element (Position.Container.all, Position.Index, Process);\n       end if;\n-\n-      Query_Element (Position.Container.all, Position.Index, Process);\n    end Query_Element;\n \n    ----------\n@@ -3064,8 +3168,7 @@ package body Ada.Containers.Indefinite_Vectors is\n    is\n       Length : Count_Type'Base;\n       Last   : Index_Type'Base := Index_Type'Pred (Index_Type'First);\n-\n-      B : Boolean;\n+      B      : Boolean;\n \n    begin\n       Clear (Container);\n@@ -3616,23 +3719,50 @@ package body Ada.Containers.Indefinite_Vectors is\n          raise Program_Error with \"Position cursor denotes wrong container\";\n       end if;\n \n-      if Position.Container = null\n-        or else Position.Index > Container.Last\n-      then\n+      if Position.Container = null or else Position.Index > Container.Last then\n          Last := Container.Last;\n       else\n          Last := Position.Index;\n       end if;\n \n-      for Indx in reverse Index_Type'First .. Last loop\n-         if Container.Elements.EA (Indx) /= null\n-           and then Container.Elements.EA (Indx).all = Item\n-         then\n-            return (Container'Unrestricted_Access, Indx);\n+      --  Per AI05-0022, the container implementation is required to detect\n+      --  element tampering by a generic actual subprogram.\n+\n+      declare\n+         B : Natural renames Container'Unrestricted_Access.Busy;\n+         L : Natural renames Container'Unrestricted_Access.Lock;\n+\n+         Result : Index_Type'Base;\n+\n+      begin\n+         B := B + 1;\n+         L := L + 1;\n+\n+         Result := No_Index;\n+         for Indx in reverse Index_Type'First .. Last loop\n+            if Container.Elements.EA (Indx) /= null\n+              and then Container.Elements.EA (Indx).all = Item\n+            then\n+               Result := Indx;\n+               exit;\n+            end if;\n+         end loop;\n+\n+         B := B - 1;\n+         L := L - 1;\n+\n+         if Result = No_Index then\n+            return No_Element;\n+         else\n+            return Cursor'(Container'Unrestricted_Access, Result);\n          end if;\n-      end loop;\n \n-      return No_Element;\n+      exception\n+         when others =>\n+            B := B - 1;\n+            L := L - 1;\n+            raise;\n+      end;\n    end Reverse_Find;\n \n    ------------------------\n@@ -3644,18 +3774,41 @@ package body Ada.Containers.Indefinite_Vectors is\n       Item      : Element_Type;\n       Index     : Index_Type := Index_Type'Last) return Extended_Index\n    is\n+      B : Natural renames Container'Unrestricted_Access.Busy;\n+      L : Natural renames Container'Unrestricted_Access.Lock;\n+\n       Last : constant Index_Type'Base :=\n         (if Index > Container.Last then Container.Last else Index);\n+\n+      Result : Index_Type'Base;\n+\n    begin\n+      --  Per AI05-0022, the container implementation is required to detect\n+      --  element tampering by a generic actual subprogram.\n+\n+      B := B + 1;\n+      L := L + 1;\n+\n+      Result := No_Index;\n       for Indx in reverse Index_Type'First .. Last loop\n          if Container.Elements.EA (Indx) /= null\n            and then Container.Elements.EA (Indx).all = Item\n          then\n-            return Indx;\n+            Result := Indx;\n+            exit;\n          end if;\n       end loop;\n \n-      return No_Index;\n+      B := B - 1;\n+      L := L - 1;\n+\n+      return Result;\n+\n+   exception\n+      when others =>\n+         B := B - 1;\n+         L := L - 1;\n+         raise;\n    end Reverse_Find_Index;\n \n    ---------------------\n@@ -3800,13 +3953,11 @@ package body Ada.Containers.Indefinite_Vectors is\n    begin\n       if Position.Container = null then\n          return No_Index;\n-      end if;\n-\n-      if Position.Index <= Position.Container.Last then\n+      elsif Position.Index <= Position.Container.Last then\n          return Position.Index;\n+      else\n+         return No_Index;\n       end if;\n-\n-      return No_Index;\n    end To_Index;\n \n    ---------------\n@@ -4072,13 +4223,13 @@ package body Ada.Containers.Indefinite_Vectors is\n    begin\n       if Position.Container = null then\n          raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      elsif Position.Container /= Container'Unrestricted_Access then\n          raise Program_Error with \"Position cursor denotes wrong container\";\n-      end if;\n \n-      Update_Element (Container, Position.Index, Process);\n+      else\n+         Update_Element (Container, Position.Index, Process);\n+      end if;\n    end Update_Element;\n \n    -----------"}, {"sha": "5b722fe8a7240f7229f032ce3500bb4523c92e9e", "filename": "gcc/ada/a-convec.adb", "status": "modified", "additions": 330, "deletions": 185, "changes": 515, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2602b64e3a4072c8819cad2f3abffe2d5ae69de3/gcc%2Fada%2Fa-convec.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2602b64e3a4072c8819cad2f3abffe2d5ae69de3/gcc%2Fada%2Fa-convec.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-convec.adb?ref=2602b64e3a4072c8819cad2f3abffe2d5ae69de3", "patch": "@@ -84,25 +84,21 @@ package body Ada.Containers.Vectors is\n          end if;\n \n          declare\n-            RE : Elements_Array renames\n-              Right.Elements.EA (Index_Type'First .. Right.Last);\n-\n+            RE       : Elements_Array renames\n+                         Right.Elements.EA (Index_Type'First .. Right.Last);\n             Elements : constant Elements_Access :=\n-              new Elements_Type'(Right.Last, RE);\n-\n+                         new Elements_Type'(Right.Last, RE);\n          begin\n             return (Controlled with Elements, Right.Last, 0, 0);\n          end;\n       end if;\n \n       if RN = 0 then\n          declare\n-            LE : Elements_Array renames\n-                   Left.Elements.EA (Index_Type'First .. Left.Last);\n-\n+            LE       : Elements_Array renames\n+                         Left.Elements.EA (Index_Type'First .. Left.Last);\n             Elements : constant Elements_Access :=\n-              new Elements_Type'(Left.Last, LE);\n-\n+                         new Elements_Type'(Left.Last, LE);\n          begin\n             return (Controlled with Elements, Left.Last, 0, 0);\n          end;\n@@ -197,15 +193,12 @@ package body Ada.Containers.Vectors is\n       end if;\n \n       declare\n-         LE : Elements_Array renames\n-           Left.Elements.EA (Index_Type'First .. Left.Last);\n-\n-         RE : Elements_Array renames\n-           Right.Elements.EA (Index_Type'First .. Right.Last);\n-\n+         LE       : Elements_Array renames\n+                      Left.Elements.EA (Index_Type'First .. Left.Last);\n+         RE       : Elements_Array renames\n+                      Right.Elements.EA (Index_Type'First .. Right.Last);\n          Elements : constant Elements_Access :=\n-           new Elements_Type'(Last, LE & RE);\n-\n+                      new Elements_Type'(Last, LE & RE);\n       begin\n          return (Controlled with Elements, Last, 0, 0);\n       end;\n@@ -247,14 +240,11 @@ package body Ada.Containers.Vectors is\n       end if;\n \n       declare\n-         Last : constant Index_Type := Left.Last + 1;\n-\n-         LE : Elements_Array renames\n-           Left.Elements.EA (Index_Type'First .. Left.Last);\n-\n+         Last     : constant Index_Type := Left.Last + 1;\n+         LE       : Elements_Array renames\n+                      Left.Elements.EA (Index_Type'First .. Left.Last);\n          Elements : constant Elements_Access :=\n-           new Elements_Type'(Last => Last, EA => LE & Right);\n-\n+                      new Elements_Type'(Last => Last, EA => LE & Right);\n       begin\n          return (Controlled with Elements, Last, 0, 0);\n       end;\n@@ -275,7 +265,6 @@ package body Ada.Containers.Vectors is\n               new Elements_Type'\n                 (Last => Index_Type'First,\n                  EA   => (others => Left));\n-\n          begin\n             return (Controlled with Elements, Index_Type'First, 0, 0);\n          end;\n@@ -346,6 +335,14 @@ package body Ada.Containers.Vectors is\n    ---------\n \n    overriding function \"=\" (Left, Right : Vector) return Boolean is\n+      BL : Natural renames Left'Unrestricted_Access.Busy;\n+      LL : Natural renames Left'Unrestricted_Access.Lock;\n+\n+      BR : Natural renames Right'Unrestricted_Access.Busy;\n+      LR : Natural renames Right'Unrestricted_Access.Lock;\n+\n+      Result : Boolean;\n+\n    begin\n       if Left'Address = Right'Address then\n          return True;\n@@ -355,13 +352,40 @@ package body Ada.Containers.Vectors is\n          return False;\n       end if;\n \n+      --  Per AI05-0022, the container implementation is required to detect\n+      --  element tampering by a generic actual subprogram.\n+\n+      BL := BL + 1;\n+      LL := LL + 1;\n+\n+      BR := BR + 1;\n+      LR := LR + 1;\n+\n+      Result := True;\n       for J in Index_Type range Index_Type'First .. Left.Last loop\n          if Left.Elements.EA (J) /= Right.Elements.EA (J) then\n-            return False;\n+            Result := False;\n+            exit;\n          end if;\n       end loop;\n \n-      return True;\n+      BL := BL - 1;\n+      LL := LL - 1;\n+\n+      BR := BR - 1;\n+      LR := LR - 1;\n+\n+      return Result;\n+\n+   exception\n+      when others =>\n+         BL := BL - 1;\n+         LL := LL - 1;\n+\n+         BR := BR - 1;\n+         LR := LR - 1;\n+\n+         raise;\n    end \"=\";\n \n    ------------\n@@ -418,16 +442,11 @@ package body Ada.Containers.Vectors is\n    begin\n       if Is_Empty (New_Item) then\n          return;\n-      end if;\n-\n-      if Container.Last = Index_Type'Last then\n+      elsif Container.Last = Index_Type'Last then\n          raise Constraint_Error with \"vector is already at its maximum length\";\n+      else\n+         Insert (Container, Container.Last + 1, New_Item);\n       end if;\n-\n-      Insert\n-        (Container,\n-         Container.Last + 1,\n-         New_Item);\n    end Append;\n \n    procedure Append\n@@ -438,17 +457,11 @@ package body Ada.Containers.Vectors is\n    begin\n       if Count = 0 then\n          return;\n-      end if;\n-\n-      if Container.Last = Index_Type'Last then\n+      elsif Container.Last = Index_Type'Last then\n          raise Constraint_Error with \"vector is already at its maximum length\";\n+      else\n+         Insert (Container, Container.Last + 1, New_Item, Count);\n       end if;\n-\n-      Insert\n-        (Container,\n-         Container.Last + 1,\n-         New_Item,\n-         Count);\n    end Append;\n \n    ------------\n@@ -459,10 +472,10 @@ package body Ada.Containers.Vectors is\n    begin\n       if Target'Address = Source'Address then\n          return;\n+      else\n+         Target.Clear;\n+         Target.Append (Source);\n       end if;\n-\n-      Target.Clear;\n-      Target.Append (Source);\n    end Assign;\n \n    --------------\n@@ -638,9 +651,9 @@ package body Ada.Containers.Vectors is\n       if Index > Old_Last then\n          if Index > Old_Last + 1 then\n             raise Constraint_Error with \"Index is out of range (too large)\";\n+         else\n+            return;\n          end if;\n-\n-         return;\n       end if;\n \n       --  Here and elsewhere we treat deleting 0 items from the container as a\n@@ -668,7 +681,6 @@ package body Ada.Containers.Vectors is\n \n       if Count_Type'Base'Last >= Index_Type'Pos (Index_Type'Base'Last) then\n          Count2 := Count_Type'Base (Old_Last) - Count_Type'Base (Index) + 1;\n-\n       else\n          Count2 := Count_Type'Base (Old_Last - Index + 1);\n       end if;\n@@ -694,7 +706,6 @@ package body Ada.Containers.Vectors is\n       if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n          New_Last := Old_Last - Index_Type'Base (Count);\n          J := Index + Index_Type'Base (Count);\n-\n       else\n          New_Last := Index_Type'Base (Count_Type'Base (Old_Last) - Count);\n          J := Index_Type'Base (Count_Type'Base (Index) + Count);\n@@ -708,7 +719,6 @@ package body Ada.Containers.Vectors is\n \n       declare\n          EA : Elements_Array renames Container.Elements.EA;\n-\n       begin\n          EA (Index .. New_Last) := EA (J .. Old_Last);\n          Container.Last := New_Last;\n@@ -725,18 +735,17 @@ package body Ada.Containers.Vectors is\n    begin\n       if Position.Container = null then\n          raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      elsif Position.Container /= Container'Unrestricted_Access then\n          raise Program_Error with \"Position cursor denotes wrong container\";\n-      end if;\n \n-      if Position.Index > Container.Last then\n+      elsif Position.Index > Container.Last then\n          raise Program_Error with \"Position index is out of range\";\n-      end if;\n \n-      Delete (Container, Position.Index, Count);\n-      Position := No_Element;\n+      else\n+         Delete (Container, Position.Index, Count);\n+         Position := No_Element;\n+      end if;\n    end Delete;\n \n    ------------------\n@@ -750,14 +759,14 @@ package body Ada.Containers.Vectors is\n    begin\n       if Count = 0 then\n          return;\n-      end if;\n \n-      if Count >= Length (Container) then\n+      elsif Count >= Length (Container) then\n          Clear (Container);\n          return;\n-      end if;\n \n-      Delete (Container, Index_Type'First, Count);\n+      else\n+         Delete (Container, Index_Type'First, Count);\n+      end if;\n    end Delete_First;\n \n    -----------------\n@@ -823,9 +832,9 @@ package body Ada.Containers.Vectors is\n    begin\n       if Index > Container.Last then\n          raise Constraint_Error with \"Index is out of range\";\n+      else\n+         return Container.Elements.EA (Index);\n       end if;\n-\n-      return Container.Elements.EA (Index);\n    end Element;\n \n    function Element (Position : Cursor) return Element_Type is\n@@ -850,11 +859,12 @@ package body Ada.Containers.Vectors is\n       if Container.Busy > 0 then\n          raise Program_Error with\n            \"attempt to tamper with cursors (vector is busy)\";\n-      end if;\n \n-      Container.Elements := null;\n-      Container.Last := No_Index;\n-      Free (X);\n+      else\n+         Container.Elements := null;\n+         Container.Last := No_Index;\n+         Free (X);\n+      end if;\n    end Finalize;\n \n    procedure Finalize (Object : in out Iterator) is\n@@ -899,13 +909,42 @@ package body Ada.Containers.Vectors is\n          end if;\n       end if;\n \n-      for J in Position.Index .. Container.Last loop\n-         if Container.Elements.EA (J) = Item then\n-            return (Container'Unrestricted_Access, J);\n+      --  Per AI05-0022, the container implementation is required to detect\n+      --  element tampering by a generic actual subprogram.\n+\n+      declare\n+         B : Natural renames Container'Unrestricted_Access.Busy;\n+         L : Natural renames Container'Unrestricted_Access.Lock;\n+\n+         Result : Index_Type'Base;\n+\n+      begin\n+         B := B + 1;\n+         L := L + 1;\n+\n+         Result := No_Index;\n+         for J in Position.Index .. Container.Last loop\n+            if Container.Elements.EA (J) = Item then\n+               Result := J;\n+               exit;\n+            end if;\n+         end loop;\n+\n+         B := B - 1;\n+         L := L - 1;\n+\n+         if Result = No_Index then\n+            return No_Element;\n+         else\n+            return Cursor'(Container'Unrestricted_Access, Result);\n          end if;\n-      end loop;\n \n-      return No_Element;\n+      exception\n+         when others =>\n+            B := B - 1;\n+            L := L - 1;\n+            raise;\n+      end;\n    end Find;\n \n    ----------------\n@@ -917,14 +956,36 @@ package body Ada.Containers.Vectors is\n       Item      : Element_Type;\n       Index     : Index_Type := Index_Type'First) return Extended_Index\n    is\n+      B : Natural renames Container'Unrestricted_Access.Busy;\n+      L : Natural renames Container'Unrestricted_Access.Lock;\n+\n+      Result : Index_Type'Base;\n+\n    begin\n+      --  Per AI05-0022, the container implementation is required to detect\n+      --  element tampering by a generic actual subprogram.\n+\n+      B := B + 1;\n+      L := L + 1;\n+\n+      Result := No_Index;\n       for Indx in Index .. Container.Last loop\n          if Container.Elements.EA (Indx) = Item then\n-            return Indx;\n+            Result := Indx;\n+            exit;\n          end if;\n       end loop;\n \n-      return No_Index;\n+      B := B - 1;\n+      L := L - 1;\n+\n+      return Result;\n+\n+   exception\n+      when others =>\n+         B := B - 1;\n+         L := L - 1;\n+         raise;\n    end Find_Index;\n \n    -----------\n@@ -1002,17 +1063,40 @@ package body Ada.Containers.Vectors is\n             return True;\n          end if;\n \n+         --  Per AI05-0022, the container implementation is required to detect\n+         --  element tampering by a generic actual subprogram.\n+\n          declare\n             EA : Elements_Array renames Container.Elements.EA;\n+\n+            B : Natural renames Container'Unrestricted_Access.Busy;\n+            L : Natural renames Container'Unrestricted_Access.Lock;\n+\n+            Result : Boolean;\n+\n          begin\n+            B := B + 1;\n+            L := L + 1;\n+\n+            Result := True;\n             for J in Index_Type'First .. Container.Last - 1 loop\n                if EA (J + 1) < EA (J) then\n-                  return False;\n+                  Result := False;\n+                  exit;\n                end if;\n             end loop;\n-         end;\n \n-         return True;\n+            B := B - 1;\n+            L := L - 1;\n+\n+            return Result;\n+\n+         exception\n+            when others =>\n+               B := B - 1;\n+               L := L - 1;\n+               raise;\n+         end;\n       end Is_Sorted;\n \n       -----------\n@@ -1053,23 +1137,38 @@ package body Ada.Containers.Vectors is\n \n          Target.Set_Length (Length (Target) + Length (Source));\n \n+         --  Per AI05-0022, the container implementation is required to detect\n+         --  element tampering by a generic actual subprogram.\n+\n          declare\n             TA : Elements_Array renames Target.Elements.EA;\n             SA : Elements_Array renames Source.Elements.EA;\n \n+            TB : Natural renames Target.Busy;\n+            TL : Natural renames Target.Lock;\n+\n+            SB : Natural renames Source.Busy;\n+            SL : Natural renames Source.Lock;\n+\n          begin\n+            TB := TB + 1;\n+            TL := TL + 1;\n+\n+            SB := SB + 1;\n+            SL := SL + 1;\n+\n             J := Target.Last;\n             while Source.Last >= Index_Type'First loop\n                pragma Assert (Source.Last <= Index_Type'First\n-                                or else not (SA (Source.Last) <\n-                                             SA (Source.Last - 1)));\n+                               or else not (SA (Source.Last) <\n+                                            SA (Source.Last - 1)));\n \n                if I < Index_Type'First then\n                   TA (Index_Type'First .. J) :=\n                     SA (Index_Type'First .. Source.Last);\n \n                   Source.Last := No_Index;\n-                  return;\n+                  exit;\n                end if;\n \n                pragma Assert (I <= Index_Type'First\n@@ -1086,6 +1185,22 @@ package body Ada.Containers.Vectors is\n \n                J := J - 1;\n             end loop;\n+\n+            TB := TB - 1;\n+            TL := TL - 1;\n+\n+            SB := SB - 1;\n+            SL := SL - 1;\n+\n+         exception\n+            when others =>\n+               TB := TB - 1;\n+               TL := TL - 1;\n+\n+               SB := SB - 1;\n+               SL := SL - 1;\n+\n+               raise;\n          end;\n       end Merge;\n \n@@ -1122,7 +1237,28 @@ package body Ada.Containers.Vectors is\n               \"attempt to tamper with cursors (vector is busy)\";\n          end if;\n \n-         Sort (Container.Elements.EA (Index_Type'First .. Container.Last));\n+         --  Per AI05-0022, the container implementation is required to detect\n+         --  element tampering by a generic actual subprogram.\n+\n+         declare\n+            B : Natural renames Container.Busy;\n+            L : Natural renames Container.Lock;\n+\n+         begin\n+            B := B + 1;\n+            L := L + 1;\n+\n+            Sort (Container.Elements.EA (Index_Type'First .. Container.Last));\n+\n+            B := B - 1;\n+            L := L - 1;\n+\n+         exception\n+            when others =>\n+               B := B - 1;\n+               L := L - 1;\n+               raise;\n+         end;\n       end Sort;\n \n    end Generic_Sorting;\n@@ -1182,9 +1318,7 @@ package body Ada.Containers.Vectors is\n       --  deeper flaw in the caller's algorithm, so that case is treated as a\n       --  proper error.)\n \n-      if Before > Container.Last\n-        and then Before > Container.Last + 1\n-      then\n+      if Before > Container.Last and then Before > Container.Last + 1 then\n          raise Constraint_Error with\n            \"Before index is out of range (too large)\";\n       end if;\n@@ -1374,7 +1508,6 @@ package body Ada.Containers.Vectors is\n \n                if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n                   Index := Before + Index_Type'Base (Count);\n-\n                else\n                   Index := Index_Type'Base (Count_Type'Base (Before) + Count);\n                end if;\n@@ -1402,9 +1535,9 @@ package body Ada.Containers.Vectors is\n          if New_Capacity > Count_Type'Last / 2 then\n             New_Capacity := Count_Type'Last;\n             exit;\n+         else\n+            New_Capacity := 2 * New_Capacity;\n          end if;\n-\n-         New_Capacity := 2 * New_Capacity;\n       end loop;\n \n       if New_Capacity > Max_Length then\n@@ -1421,7 +1554,6 @@ package body Ada.Containers.Vectors is\n \n       if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n          Dst_Last := No_Index + Index_Type'Base (New_Capacity);\n-\n       else\n          Dst_Last :=\n            Index_Type'Base (Count_Type'Base (No_Index) + New_Capacity);\n@@ -1455,7 +1587,6 @@ package body Ada.Containers.Vectors is\n \n             if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n                Index := Before + Index_Type'Base (Count);\n-\n             else\n                Index := Index_Type'Base (Count_Type'Base (Before) + Count);\n             end if;\n@@ -1475,6 +1606,7 @@ package body Ada.Containers.Vectors is\n \n       declare\n          X : Elements_Access := Container.Elements;\n+\n       begin\n          --  We first isolate the old internal array, removing it from the\n          --  container and replacing it with the new internal array, before we\n@@ -1518,7 +1650,6 @@ package body Ada.Containers.Vectors is\n \n       if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n          J := (Before - 1) + Index_Type'Base (N);\n-\n       else\n          J := Index_Type'Base (Count_Type'Base (Before - 1) + N);\n       end if;\n@@ -1549,7 +1680,7 @@ package body Ada.Containers.Vectors is\n            Index_Type'First .. L;\n \n          Src : Elements_Array renames\n-           Container.Elements.EA (Src_Index_Subtype);\n+                 Container.Elements.EA (Src_Index_Subtype);\n \n          K : Index_Type'Base;\n \n@@ -1562,7 +1693,6 @@ package body Ada.Containers.Vectors is\n \n          if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n             K := L + Index_Type'Base (Src'Length);\n-\n          else\n             K := Index_Type'Base (Count_Type'Base (L) + Src'Length);\n          end if;\n@@ -1594,7 +1724,7 @@ package body Ada.Containers.Vectors is\n            F .. Container.Last;\n \n          Src : Elements_Array renames\n-           Container.Elements.EA (Src_Index_Subtype);\n+                 Container.Elements.EA (Src_Index_Subtype);\n \n          K : Index_Type'Base;\n \n@@ -1606,7 +1736,6 @@ package body Ada.Containers.Vectors is\n \n          if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n             K := F - Index_Type'Base (Src'Length);\n-\n          else\n             K := Index_Type'Base (Count_Type'Base (F) - Src'Length);\n          end if;\n@@ -1633,9 +1762,7 @@ package body Ada.Containers.Vectors is\n          return;\n       end if;\n \n-      if Before.Container = null\n-        or else Before.Index > Container.Last\n-      then\n+      if Before.Container = null or else Before.Index > Container.Last then\n          if Container.Last = Index_Type'Last then\n             raise Constraint_Error with\n               \"vector is already at its maximum length\";\n@@ -1666,9 +1793,7 @@ package body Ada.Containers.Vectors is\n       end if;\n \n       if Is_Empty (New_Item) then\n-         if Before.Container = null\n-           or else Before.Index > Container.Last\n-         then\n+         if Before.Container = null or else Before.Index > Container.Last then\n             Position := No_Element;\n          else\n             Position := (Container'Unrestricted_Access, Before.Index);\n@@ -1677,9 +1802,7 @@ package body Ada.Containers.Vectors is\n          return;\n       end if;\n \n-      if Before.Container = null\n-        or else Before.Index > Container.Last\n-      then\n+      if Before.Container = null or else Before.Index > Container.Last then\n          if Container.Last = Index_Type'Last then\n             raise Constraint_Error with\n               \"vector is already at its maximum length\";\n@@ -1715,9 +1838,7 @@ package body Ada.Containers.Vectors is\n          return;\n       end if;\n \n-      if Before.Container = null\n-        or else Before.Index > Container.Last\n-      then\n+      if Before.Container = null or else Before.Index > Container.Last then\n          if Container.Last = Index_Type'Last then\n             raise Constraint_Error with\n               \"vector is already at its maximum length\";\n@@ -1749,9 +1870,7 @@ package body Ada.Containers.Vectors is\n       end if;\n \n       if Count = 0 then\n-         if Before.Container = null\n-           or else Before.Index > Container.Last\n-         then\n+         if Before.Container = null or else Before.Index > Container.Last then\n             Position := No_Element;\n          else\n             Position := (Container'Unrestricted_Access, Before.Index);\n@@ -1760,9 +1879,7 @@ package body Ada.Containers.Vectors is\n          return;\n       end if;\n \n-      if Before.Container = null\n-        or else Before.Index > Container.Last\n-      then\n+      if Before.Container = null or else Before.Index > Container.Last then\n          if Container.Last = Index_Type'Last then\n             raise Constraint_Error with\n               \"vector is already at its maximum length\";\n@@ -1799,7 +1916,6 @@ package body Ada.Containers.Vectors is\n    is\n       New_Item : Element_Type;  -- Default-initialized value\n       pragma Warnings (Off, New_Item);\n-\n    begin\n       Insert (Container, Before, New_Item, Position, Count);\n    end Insert;\n@@ -1849,9 +1965,7 @@ package body Ada.Containers.Vectors is\n       --  deeper flaw in the caller's algorithm, so that case is treated as a\n       --  proper error.)\n \n-      if Before > Container.Last\n-        and then Before > Container.Last + 1\n-      then\n+      if Before > Container.Last and then Before > Container.Last + 1 then\n          raise Constraint_Error with\n            \"Before index is out of range (too large)\";\n       end if;\n@@ -1973,7 +2087,6 @@ package body Ada.Containers.Vectors is\n \n       if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n          New_Last := No_Index + Index_Type'Base (New_Length);\n-\n       else\n          New_Last := Index_Type'Base (Count_Type'Base (No_Index) + New_Length);\n       end if;\n@@ -2081,7 +2194,6 @@ package body Ada.Containers.Vectors is\n \n       if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n          Dst_Last := No_Index + Index_Type'Base (New_Capacity);\n-\n       else\n          Dst_Last :=\n            Index_Type'Base (Count_Type'Base (No_Index) + New_Capacity);\n@@ -2113,7 +2225,6 @@ package body Ada.Containers.Vectors is\n \n             if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n                Index := Before + Index_Type'Base (Count);\n-\n             else\n                Index := Index_Type'Base (Count_Type'Base (Before) + Count);\n             end if;\n@@ -2166,9 +2277,7 @@ package body Ada.Containers.Vectors is\n       end if;\n \n       if Count = 0 then\n-         if Before.Container = null\n-           or else Before.Index > Container.Last\n-         then\n+         if Before.Container = null or else Before.Index > Container.Last then\n             Position := No_Element;\n          else\n             Position := (Container'Unrestricted_Access, Before.Index);\n@@ -2177,9 +2286,7 @@ package body Ada.Containers.Vectors is\n          return;\n       end if;\n \n-      if Before.Container = null\n-        or else Before.Index > Container.Last\n-      then\n+      if Before.Container = null or else Before.Index > Container.Last then\n          if Container.Last = Index_Type'Last then\n             raise Constraint_Error with\n               \"vector is already at its maximum length\";\n@@ -2250,9 +2357,9 @@ package body Ada.Containers.Vectors is\n       --  for a reverse iterator, Container.Last is the beginning.\n \n       return It : constant Iterator :=\n-        (Limited_Controlled with\n-           Container => V,\n-           Index     => No_Index)\n+                    (Limited_Controlled with\n+                       Container => V,\n+                       Index     => No_Index)\n       do\n          B := B + 1;\n       end return;\n@@ -2303,9 +2410,9 @@ package body Ada.Containers.Vectors is\n       --  is a forward or reverse iteration.\n \n       return It : constant Iterator :=\n-        (Limited_Controlled with\n-           Container => V,\n-           Index     => Start.Index)\n+                    (Limited_Controlled with\n+                       Container => V,\n+                       Index     => Start.Index)\n       do\n          B := B + 1;\n       end return;\n@@ -2455,14 +2562,12 @@ package body Ada.Containers.Vectors is\n    begin\n       if Position.Container = null then\n          return No_Element;\n-      end if;\n-\n-      if Position.Container /= Object.Container then\n+      elsif Position.Container /= Object.Container then\n          raise Program_Error with\n            \"Position cursor of Next designates wrong vector\";\n+      else\n+         return Next (Position);\n       end if;\n-\n-      return Next (Position);\n    end Next;\n \n    procedure Next (Position : in out Cursor) is\n@@ -2491,10 +2596,7 @@ package body Ada.Containers.Vectors is\n       Count     : Count_Type := 1)\n    is\n    begin\n-      Insert (Container,\n-              Index_Type'First,\n-              New_Item,\n-              Count);\n+      Insert (Container, Index_Type'First, New_Item, Count);\n    end Prepend;\n \n    --------------\n@@ -2516,14 +2618,12 @@ package body Ada.Containers.Vectors is\n    begin\n       if Position.Container = null then\n          return No_Element;\n-      end if;\n-\n-      if Position.Container /= Object.Container then\n+      elsif Position.Container /= Object.Container then\n          raise Program_Error with\n            \"Position cursor of Previous designates wrong vector\";\n+      else\n+         return Previous (Position);\n       end if;\n-\n-      return Previous (Position);\n    end Previous;\n \n    procedure Previous (Position : in out Cursor) is\n@@ -2578,9 +2678,9 @@ package body Ada.Containers.Vectors is\n    begin\n       if Position.Container = null then\n          raise Constraint_Error with \"Position cursor has no element\";\n+      else\n+         Query_Element (Position.Container.all, Position.Index, Process);\n       end if;\n-\n-      Query_Element (Position.Container.all, Position.Index, Process);\n    end Query_Element;\n \n    ----------\n@@ -2677,6 +2777,7 @@ package body Ada.Containers.Vectors is\n    begin\n       if Index > Container.Last then\n          raise Constraint_Error with \"Index is out of range\";\n+\n       else\n          declare\n             C : Vector renames Container'Unrestricted_Access.all;\n@@ -2706,14 +2807,12 @@ package body Ada.Containers.Vectors is\n    begin\n       if Index > Container.Last then\n          raise Constraint_Error with \"Index is out of range\";\n-      end if;\n-\n-      if Container.Lock > 0 then\n+      elsif Container.Lock > 0 then\n          raise Program_Error with\n            \"attempt to tamper with elements (vector is locked)\";\n+      else\n+         Container.Elements.EA (Index) := New_Item;\n       end if;\n-\n-      Container.Elements.EA (Index) := New_Item;\n    end Replace_Element;\n \n    procedure Replace_Element\n@@ -2724,22 +2823,21 @@ package body Ada.Containers.Vectors is\n    begin\n       if Position.Container = null then\n          raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      elsif Position.Container /= Container'Unrestricted_Access then\n          raise Program_Error with \"Position cursor denotes wrong container\";\n-      end if;\n \n-      if Position.Index > Container.Last then\n+      elsif Position.Index > Container.Last then\n          raise Constraint_Error with \"Position cursor is out of range\";\n-      end if;\n \n-      if Container.Lock > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with elements (vector is locked)\";\n-      end if;\n+      else\n+         if Container.Lock > 0 then\n+            raise Program_Error with\n+              \"attempt to tamper with elements (vector is locked)\";\n+         end if;\n \n-      Container.Elements.EA (Position.Index) := New_Item;\n+         Container.Elements.EA (Position.Index) := New_Item;\n+      end if;\n    end Replace_Element;\n \n    ----------------------\n@@ -3126,13 +3224,42 @@ package body Ada.Containers.Vectors is\n          then Container.Last\n          else Position.Index);\n \n-      for Indx in reverse Index_Type'First .. Last loop\n-         if Container.Elements.EA (Indx) = Item then\n-            return (Container'Unrestricted_Access, Indx);\n+      --  Per AI05-0022, the container implementation is required to detect\n+      --  element tampering by a generic actual subprogram.\n+\n+      declare\n+         B : Natural renames Container'Unrestricted_Access.Busy;\n+         L : Natural renames Container'Unrestricted_Access.Lock;\n+\n+         Result : Index_Type'Base;\n+\n+      begin\n+         B := B + 1;\n+         L := L + 1;\n+\n+         Result := No_Index;\n+         for Indx in reverse Index_Type'First .. Last loop\n+            if Container.Elements.EA (Indx) = Item then\n+               Result := Indx;\n+               exit;\n+            end if;\n+         end loop;\n+\n+         B := B - 1;\n+         L := L - 1;\n+\n+         if Result = No_Index then\n+            return No_Element;\n+         else\n+            return Cursor'(Container'Unrestricted_Access, Result);\n          end if;\n-      end loop;\n \n-      return No_Element;\n+      exception\n+         when others =>\n+            B := B - 1;\n+            L := L - 1;\n+            raise;\n+      end;\n    end Reverse_Find;\n \n    ------------------------\n@@ -3144,17 +3271,39 @@ package body Ada.Containers.Vectors is\n       Item      : Element_Type;\n       Index     : Index_Type := Index_Type'Last) return Extended_Index\n    is\n+      B : Natural renames Container'Unrestricted_Access.Busy;\n+      L : Natural renames Container'Unrestricted_Access.Lock;\n+\n       Last : constant Index_Type'Base :=\n         Index_Type'Min (Container.Last, Index);\n \n+      Result : Index_Type'Base;\n+\n    begin\n+      --  Per AI05-0022, the container implementation is required to detect\n+      --  element tampering by a generic actual subprogram.\n+\n+      B := B + 1;\n+      L := L + 1;\n+\n+      Result := No_Index;\n       for Indx in reverse Index_Type'First .. Last loop\n          if Container.Elements.EA (Indx) = Item then\n-            return Indx;\n+            Result := Indx;\n+            exit;\n          end if;\n       end loop;\n \n-      return No_Index;\n+      B := B - 1;\n+      L := L - 1;\n+\n+      return Result;\n+\n+   exception\n+      when others =>\n+         B := B - 1;\n+         L := L - 1;\n+         raise;\n    end Reverse_Find_Index;\n \n    ---------------------\n@@ -3245,21 +3394,19 @@ package body Ada.Containers.Vectors is\n    begin\n       if I.Container = null then\n          raise Constraint_Error with \"I cursor has no element\";\n-      end if;\n \n-      if J.Container = null then\n+      elsif J.Container = null then\n          raise Constraint_Error with \"J cursor has no element\";\n-      end if;\n \n-      if I.Container /= Container'Unrestricted_Access then\n+      elsif I.Container /= Container'Unrestricted_Access then\n          raise Program_Error with \"I cursor denotes wrong container\";\n-      end if;\n \n-      if J.Container /= Container'Unrestricted_Access then\n+      elsif J.Container /= Container'Unrestricted_Access then\n          raise Program_Error with \"J cursor denotes wrong container\";\n-      end if;\n \n-      Swap (Container, I.Index, J.Index);\n+      else\n+         Swap (Container, I.Index, J.Index);\n+      end if;\n    end Swap;\n \n    ---------------\n@@ -3286,13 +3433,11 @@ package body Ada.Containers.Vectors is\n    begin\n       if Position.Container = null then\n          return No_Index;\n-      end if;\n-\n-      if Position.Index <= Position.Container.Last then\n+      elsif Position.Index <= Position.Container.Last then\n          return Position.Index;\n+      else\n+         return No_Index;\n       end if;\n-\n-      return No_Index;\n    end To_Index;\n \n    ---------------"}, {"sha": "33a184ccfbc0036570dfe276002f14c18629cbef", "filename": "gcc/ada/stand.ads", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2602b64e3a4072c8819cad2f3abffe2d5ae69de3/gcc%2Fada%2Fstand.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2602b64e3a4072c8819cad2f3abffe2d5ae69de3/gcc%2Fada%2Fstand.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fstand.ads?ref=2602b64e3a4072c8819cad2f3abffe2d5ae69de3", "patch": "@@ -364,23 +364,21 @@ package Stand is\n    Any_Type : Entity_Id;\n    --  Used to represent some unknown type. Any_Type is the type of an\n    --  unresolved operator, and it is the type of a node where a type error\n-   --  has been detected.  Any_Type plays an important role in avoiding\n-   --  cascaded errors, because it is compatible with all other types, and is\n-   --  propagated to any expression that has a subexpression of Any_Type.\n-   --  When resolving operators, Any_Type is the initial type of the node\n-   --  before any of its candidate interpretations has been examined. If after\n-   --  examining all of them the type is still Any_Type, the node has no\n-   --  possible interpretation and an error can be emitted (and Any_Type will\n-   --  be propagated upwards).\n-\n+   --  has been detected. Any_Type plays an important role in avoiding cascaded\n+   --  errors, because it is compatible with all other types, and is propagated\n+   --  to any expression that has a subexpression of Any_Type. When resolving\n+   --  operators, Any_Type is the initial type of the node before any of its\n+   --  candidate interpretations has been examined. If after examining all of\n+   --  them the type is still Any_Type, the node has no possible interpretation\n+   --  and an error can be emitted (and Any_Type will be propagated upwards).\n+   --\n    --  There is one situation in which Any_Type is used to legitimately\n-   --  represent a case where the type is not known pre-resolution, and\n-   --  that is for the N_Raise_Expression node. In this case, the Etype\n-   --  being set to Any_Type is normal and does not represent an error.\n-   --  In particular, it is compatible with the type of any constituend of\n-   --  the enclosing expression, if any.  The type is eventually replaced\n-   --  with the type of the context, which plays no role in the resolution\n-   --  of the Raise_Expression.\n+   --  represent a case where the type is not known pre-resolution, and that\n+   --  is for the N_Raise_Expression node. In this case, the Etype being set to\n+   --  Any_Type is normal and does not represent an error. In particular, it is\n+   --  compatible with the type of any constituent of the enclosing expression,\n+   --  if any. The type is eventually replaced with the type of the context,\n+   --  which plays no role in the resolution of the Raise_Expression.\n \n    Any_Access : Entity_Id;\n    --  Used to resolve the overloaded literal NULL"}]}