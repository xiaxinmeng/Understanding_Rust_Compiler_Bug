{"sha": "3f156a6ce05f9e2b8cd37d1226c98d8b2be478ad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2YxNTZhNmNlMDVmOWUyYjhjZDM3ZDEyMjZjOThkOGIyYmU0NzhhZA==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2016-11-24T19:54:27Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2016-11-24T19:54:27Z"}, "message": "re PR rtl-optimization/77541 (wrong code with 512bit vectors of int128 @ -O1)\n\n2016-11-24  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR rtl-optimization/77541\n\t* lra-constraints.c (struct input_reload): Add field match_p.\n\t(get_reload_reg): Check modes of input reloads to generate unique\n\tvalue reload pseudo.\n\t(match_reload): Add input reload pseudo for the current insn.\n\n2016-11-24  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR rtl-optimization/77541\n\t* gcc.target/i386/pr77541.c: New.\n\nFrom-SVN: r242848", "tree": {"sha": "3d8db136aa4db952b3202183f98c3424a25b1fcc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d8db136aa4db952b3202183f98c3424a25b1fcc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3f156a6ce05f9e2b8cd37d1226c98d8b2be478ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f156a6ce05f9e2b8cd37d1226c98d8b2be478ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f156a6ce05f9e2b8cd37d1226c98d8b2be478ad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f156a6ce05f9e2b8cd37d1226c98d8b2be478ad/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fba5a793b30b22de6ac5ad185b99b45b835227fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fba5a793b30b22de6ac5ad185b99b45b835227fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fba5a793b30b22de6ac5ad185b99b45b835227fd"}], "stats": {"total": 123, "additions": 92, "deletions": 31}, "files": [{"sha": "a20c48ac097022d7ec6b7703a251ffabc56aa4a4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f156a6ce05f9e2b8cd37d1226c98d8b2be478ad/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f156a6ce05f9e2b8cd37d1226c98d8b2be478ad/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3f156a6ce05f9e2b8cd37d1226c98d8b2be478ad", "patch": "@@ -1,3 +1,11 @@\n+2016-11-24  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR rtl-optimization/77541\n+\t* lra-constraints.c (struct input_reload): Add field match_p.\n+\t(get_reload_reg): Check modes of input reloads to generate unique\n+\tvalue reload pseudo.\n+\t(match_reload): Add input reload pseudo for the current insn.\n+\n 2016-11-24  James Greenhalgh  <james.greenhalgh@arm.com>\n \n \t* config/aarch64/aarch64-c.c (aarch64_update_cpp_builtins): Update"}, {"sha": "133b55ce0ba48f7924af722039ff8380c8934b2e", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 54, "deletions": 31, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f156a6ce05f9e2b8cd37d1226c98d8b2be478ad/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f156a6ce05f9e2b8cd37d1226c98d8b2be478ad/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=3f156a6ce05f9e2b8cd37d1226c98d8b2be478ad", "patch": "@@ -529,6 +529,8 @@ init_curr_operand_mode (void)\n /* Structure describes input reload of the current insns.  */\n struct input_reload\n {\n+  /* True for input reload of matched operands.  */\n+  bool match_p;\n   /* Reloaded value.  */\n   rtx input;\n   /* Reload pseudo used.  */\n@@ -563,6 +565,7 @@ get_reload_reg (enum op_type type, machine_mode mode, rtx original,\n {\n   int i, regno;\n   enum reg_class new_class;\n+  bool unique_p = false;\n \n   if (type == OP_OUT)\n     {\n@@ -574,39 +577,53 @@ get_reload_reg (enum op_type type, machine_mode mode, rtx original,\n      e.g. volatile memory.  */\n   if (! side_effects_p (original))\n     for (i = 0; i < curr_insn_input_reloads_num; i++)\n-      if (rtx_equal_p (curr_insn_input_reloads[i].input, original)\n-\t  && in_class_p (curr_insn_input_reloads[i].reg, rclass, &new_class))\n-\t{\n-\t  rtx reg = curr_insn_input_reloads[i].reg;\n-\t  regno = REGNO (reg);\n-\t  /* If input is equal to original and both are VOIDmode,\n-\t     GET_MODE (reg) might be still different from mode.\n-\t     Ensure we don't return *result_reg with wrong mode.  */\n-\t  if (GET_MODE (reg) != mode)\n-\t    {\n-\t      if (in_subreg_p)\n-\t\tcontinue;\n-\t      if (GET_MODE_SIZE (GET_MODE (reg)) < GET_MODE_SIZE (mode))\n-\t\tcontinue;\n-\t      reg = lowpart_subreg (mode, reg, GET_MODE (reg));\n-\t      if (reg == NULL_RTX || GET_CODE (reg) != SUBREG)\n-\t\tcontinue;\n-\t    }\n-\t  *result_reg = reg;\n-\t  if (lra_dump_file != NULL)\n-\t    {\n-\t      fprintf (lra_dump_file, \"\t Reuse r%d for reload \", regno);\n-\t      dump_value_slim (lra_dump_file, original, 1);\n-\t    }\n-\t  if (new_class != lra_get_allocno_class (regno))\n-\t    lra_change_class (regno, new_class, \", change to\", false);\n-\t  if (lra_dump_file != NULL)\n-\t    fprintf (lra_dump_file, \"\\n\");\n-\t  return false;\n-\t}\n-  *result_reg = lra_create_new_reg (mode, original, rclass, title);\n+      {\n+\tif (! curr_insn_input_reloads[i].match_p\n+\t    && rtx_equal_p (curr_insn_input_reloads[i].input, original)\n+\t    && in_class_p (curr_insn_input_reloads[i].reg, rclass, &new_class))\n+\t  {\n+\t    rtx reg = curr_insn_input_reloads[i].reg;\n+\t    regno = REGNO (reg);\n+\t    /* If input is equal to original and both are VOIDmode,\n+\t       GET_MODE (reg) might be still different from mode.\n+\t       Ensure we don't return *result_reg with wrong mode.  */\n+\t    if (GET_MODE (reg) != mode)\n+\t      {\n+\t\tif (in_subreg_p)\n+\t\t  continue;\n+\t\tif (GET_MODE_SIZE (GET_MODE (reg)) < GET_MODE_SIZE (mode))\n+\t\t  continue;\n+\t\treg = lowpart_subreg (mode, reg, GET_MODE (reg));\n+\t\tif (reg == NULL_RTX || GET_CODE (reg) != SUBREG)\n+\t\t  continue;\n+\t      }\n+\t    *result_reg = reg;\n+\t    if (lra_dump_file != NULL)\n+\t      {\n+\t\tfprintf (lra_dump_file, \"\t Reuse r%d for reload \", regno);\n+\t\tdump_value_slim (lra_dump_file, original, 1);\n+\t      }\n+\t    if (new_class != lra_get_allocno_class (regno))\n+\t      lra_change_class (regno, new_class, \", change to\", false);\n+\t    if (lra_dump_file != NULL)\n+\t      fprintf (lra_dump_file, \"\\n\");\n+\t    return false;\n+\t  }\n+\t/* If we have an input reload with a different mode, make sure it\n+\t   will get a different hard reg.  */\n+\telse if (REG_P (original)\n+\t\t && REG_P (curr_insn_input_reloads[i].input)\n+\t\t && REGNO (original) == REGNO (curr_insn_input_reloads[i].input)\n+\t\t && (GET_MODE (original)\n+\t\t     != GET_MODE (curr_insn_input_reloads[i].input)))\n+\t  unique_p = true;\n+      }\n+  *result_reg = (unique_p\n+\t\t ? lra_create_new_reg_with_unique_value\n+\t\t : lra_create_new_reg) (mode, original, rclass, title);\n   lra_assert (curr_insn_input_reloads_num < LRA_MAX_INSN_RELOADS);\n   curr_insn_input_reloads[curr_insn_input_reloads_num].input = original;\n+  curr_insn_input_reloads[curr_insn_input_reloads_num].match_p = false;\n   curr_insn_input_reloads[curr_insn_input_reloads_num++].reg = *result_reg;\n   return true;\n }\n@@ -1002,6 +1019,12 @@ match_reload (signed char out, signed char *ins, signed char *outs,\n   lra_emit_move (copy_rtx (new_in_reg), in_rtx);\n   *before = get_insns ();\n   end_sequence ();\n+  /* Add the new pseudo to consider values of subsequent input reload\n+     pseudos.  */\n+  lra_assert (curr_insn_input_reloads_num < LRA_MAX_INSN_RELOADS);\n+  curr_insn_input_reloads[curr_insn_input_reloads_num].input = in_rtx;\n+  curr_insn_input_reloads[curr_insn_input_reloads_num].match_p = true;\n+  curr_insn_input_reloads[curr_insn_input_reloads_num++].reg = new_in_reg;\n   for (i = 0; (in = ins[i]) >= 0; i++)\n     {\n       lra_assert"}, {"sha": "0994787853c40dcf0d1dc40c189cfdf33dbfe571", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f156a6ce05f9e2b8cd37d1226c98d8b2be478ad/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f156a6ce05f9e2b8cd37d1226c98d8b2be478ad/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3f156a6ce05f9e2b8cd37d1226c98d8b2be478ad", "patch": "@@ -1,3 +1,8 @@\n+2016-11-24  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR rtl-optimization/77541\n+\t* gcc.target/i386/pr77541.c: New.\n+\n 2016-11-24  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/78500"}, {"sha": "2c533bb3b7d47dca9242362f9f54f7d745c89440", "filename": "gcc/testsuite/gcc.target/i386/pr77541.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f156a6ce05f9e2b8cd37d1226c98d8b2be478ad/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr77541.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f156a6ce05f9e2b8cd37d1226c98d8b2be478ad/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr77541.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr77541.c?ref=3f156a6ce05f9e2b8cd37d1226c98d8b2be478ad", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-options \"-O2 -Wno-psabi\" } */\n+\n+#define MAGIC 0x0706050403020100\n+\n+typedef unsigned long long u64;\n+typedef unsigned __int128 v64u128 __attribute__ ((vector_size (64)));\n+\n+v64u128 __attribute__ ((noinline, noclone))\n+foo (u64 x1, u64 x2, u64 x3, u64 x4, v64u128 x5)\n+{\n+  (void)x1, (void)x2;\n+  x4 >>= x4 & 63;\n+  return x3 + x4 + x5;\n+}\n+\n+int\n+main ()\n+{\n+  v64u128 x = foo (0, 0, 0, MAGIC, (v64u128) {});\n+  if (x[0] != MAGIC || x[1] != MAGIC || x[2] != MAGIC || x[3] != MAGIC)\n+    __builtin_abort();\n+  return 0;\n+}"}]}