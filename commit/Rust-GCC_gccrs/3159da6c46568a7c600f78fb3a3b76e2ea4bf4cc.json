{"sha": "3159da6c46568a7c600f78fb3a3b76e2ea4bf4cc", "node_id": "C_kwDOANBUbNoAKDMxNTlkYTZjNDY1NjhhN2M2MDBmNzhmYjNhM2I3NmUyZWE0YmY0Y2M", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-01-10T16:43:23Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-01-10T16:43:23Z"}, "message": "x86_64: Ignore zero width bitfields in ABI and issue -Wpsabi warning about C zero width bitfield ABI changes [PR102024]\n\nFor zero-width bitfields current GCC classify_argument does:\n                  if (DECL_BIT_FIELD (field))\n                    {\n                      for (i = (int_bit_position (field)\n                                + (bit_offset % 64)) / 8 / 8;\n                           i < ((int_bit_position (field) + (bit_offset % 64))\n                                + tree_to_shwi (DECL_SIZE (field))\n                                + 63) / 8 / 8; i++)\n                        classes[i]\n                          = merge_classes (X86_64_INTEGER_CLASS, classes[i]);\n                    }\nwhich I think means that if the zero-width bitfields are at bit-positions\n(in the toplevel aggregate) which are multiples of 64 bits doesn't do\nanything, (int_bit_position (field) + (bit_offset % 64)) / 64 and\n(int_bit_position (field) + (bit_offset % 64) + 63) / 64 should be equal.\nBut for zero-width bitfields at other bit positions it will call\nmerge_classes once.  Now, the typical case is that the zero width bitfield\nis surrounded by some bitfields and in that case, it doesn't change\nanything, but it can be sandwitched in between floats too as the testcases\nshow.\nIn C we had this behavior, in C++ previously the FE was removing the\nzero-width bitfields and therefore they were ignored.\nLLVM and ICC seems to ignore those bitfields both in C and C++ (== passing\nstruct S in SSE register rather than in GPR).\n\nThe x86-64 psABI has been recently clarified by\nhttps://gitlab.com/x86-psABIs/x86-64-ABI/-/commit/1aa4398d26c250b252a0c4a0f777216c9a6789ec\nthat zero width bitfield should be always ignored.\n\nThis patch implements that and emits a warning for C for cases where the ABI\nchanged from GCC 11.\n\n2022-01-10  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR target/102024\n\t* config/i386/i386.c (classify_argument): Add zero_width_bitfields\n\targument, when seeing DECL_FIELD_CXX_ZERO_WIDTH_BIT_FIELD bitfields,\n\talways ignore them, when seeing other zero sized bitfields, either\n\tset zero_width_bitfields to 1 and ignore it or if equal to 2 process\n\tit.  Pass it to recursive calls.  Add wrapper\n\twith old arguments and diagnose ABI differences for C structures\n\twith zero width bitfields.  Formatting fixes.\n\n\t* gcc.target/i386/pr102024.c: New test.\n\t* g++.target/i386/pr102024.C: New test.", "tree": {"sha": "02753c9088dddd8bfc92671e9574d39b0ac2302d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/02753c9088dddd8bfc92671e9574d39b0ac2302d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3159da6c46568a7c600f78fb3a3b76e2ea4bf4cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3159da6c46568a7c600f78fb3a3b76e2ea4bf4cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3159da6c46568a7c600f78fb3a3b76e2ea4bf4cc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3159da6c46568a7c600f78fb3a3b76e2ea4bf4cc/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b6eac7c4fba0e8c752978cc83d3641fa579fe13d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6eac7c4fba0e8c752978cc83d3641fa579fe13d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6eac7c4fba0e8c752978cc83d3641fa579fe13d"}], "stats": {"total": 89, "additions": 82, "deletions": 7}, "files": [{"sha": "fb9b626ebea1b03a396dd39c5b965f12ae8779dd", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 58, "deletions": 7, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3159da6c46568a7c600f78fb3a3b76e2ea4bf4cc/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3159da6c46568a7c600f78fb3a3b76e2ea4bf4cc/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=3159da6c46568a7c600f78fb3a3b76e2ea4bf4cc", "patch": "@@ -2065,7 +2065,8 @@ merge_classes (enum x86_64_reg_class class1, enum x86_64_reg_class class2)\n \n static int\n classify_argument (machine_mode mode, const_tree type,\n-\t\t   enum x86_64_reg_class classes[MAX_CLASSES], int bit_offset)\n+\t\t   enum x86_64_reg_class classes[MAX_CLASSES], int bit_offset,\n+\t\t   int &zero_width_bitfields)\n {\n   HOST_WIDE_INT bytes\n     = mode == BLKmode ? int_size_in_bytes (type) : (int) GET_MODE_SIZE (mode);\n@@ -2123,6 +2124,16 @@ classify_argument (machine_mode mode, const_tree type,\n \t\t     misaligned integers.  */\n \t\t  if (DECL_BIT_FIELD (field))\n \t\t    {\n+\t\t      if (integer_zerop (DECL_SIZE (field)))\n+\t\t\t{\n+\t\t\t  if (DECL_FIELD_CXX_ZERO_WIDTH_BIT_FIELD (field))\n+\t\t\t    continue;\n+\t\t\t  if (zero_width_bitfields != 2)\n+\t\t\t    {\n+\t\t\t      zero_width_bitfields = 1;\n+\t\t\t      continue;\n+\t\t\t    }\n+\t\t\t}\n \t\t      for (i = (int_bit_position (field)\n \t\t\t\t+ (bit_offset % 64)) / 8 / 8;\n \t\t\t   i < ((int_bit_position (field) + (bit_offset % 64))\n@@ -2160,7 +2171,8 @@ classify_argument (machine_mode mode, const_tree type,\n \t\t      num = classify_argument (TYPE_MODE (type), type,\n \t\t\t\t\t       subclasses,\n \t\t\t\t\t       (int_bit_position (field)\n-\t\t\t\t\t\t+ bit_offset) % 512);\n+\t\t\t\t\t\t+ bit_offset) % 512,\n+\t\t\t\t\t       zero_width_bitfields);\n \t\t      if (!num)\n \t\t\treturn 0;\n \t\t      pos = (int_bit_position (field)\n@@ -2178,7 +2190,8 @@ classify_argument (machine_mode mode, const_tree type,\n \t  {\n \t    int num;\n \t    num = classify_argument (TYPE_MODE (TREE_TYPE (type)),\n-\t\t\t\t     TREE_TYPE (type), subclasses, bit_offset);\n+\t\t\t\t     TREE_TYPE (type), subclasses, bit_offset,\n+\t\t\t\t     zero_width_bitfields);\n \t    if (!num)\n \t      return 0;\n \n@@ -2211,7 +2224,7 @@ classify_argument (machine_mode mode, const_tree type,\n \n \t\t  num = classify_argument (TYPE_MODE (TREE_TYPE (field)),\n \t\t\t\t\t   TREE_TYPE (field), subclasses,\n-\t\t\t\t\t   bit_offset);\n+\t\t\t\t\t   bit_offset, zero_width_bitfields);\n \t\t  if (!num)\n \t\t    return 0;\n \t\t  for (i = 0; i < num && i < words; i++)\n@@ -2231,7 +2244,7 @@ classify_argument (machine_mode mode, const_tree type,\n \t     X86_64_SSEUP_CLASS, everything should be passed in\n \t     memory.  */\n \t  if (classes[0] != X86_64_SSE_CLASS)\n-\t      return 0;\n+\t    return 0;\n \n \t  for (i = 1; i < words; i++)\n \t    if (classes[i] != X86_64_SSEUP_CLASS)\n@@ -2257,8 +2270,8 @@ classify_argument (machine_mode mode, const_tree type,\n \t      classes[i] = X86_64_SSE_CLASS;\n \t    }\n \n-\t  /*  If X86_64_X87UP_CLASS isn't preceded by X86_64_X87_CLASS,\n-\t       everything should be passed in memory.  */\n+\t  /* If X86_64_X87UP_CLASS isn't preceded by X86_64_X87_CLASS,\n+\t     everything should be passed in memory.  */\n \t  if (classes[i] == X86_64_X87UP_CLASS\n \t      && (classes[i - 1] != X86_64_X87_CLASS))\n \t    {\n@@ -2487,6 +2500,44 @@ classify_argument (machine_mode mode, const_tree type,\n     }\n }\n \n+/* Wrapper around classify_argument with the extra zero_width_bitfields\n+   argument, to diagnose GCC 12.1 ABI differences for C.  */\n+\n+static int\n+classify_argument (machine_mode mode, const_tree type,\n+\t\t   enum x86_64_reg_class classes[MAX_CLASSES], int bit_offset)\n+{\n+  int zero_width_bitfields = 0;\n+  static bool warned = false;\n+  int n = classify_argument (mode, type, classes, bit_offset,\n+\t\t\t     zero_width_bitfields);\n+  if (!zero_width_bitfields || warned || !warn_psabi)\n+    return n;\n+  enum x86_64_reg_class alt_classes[MAX_CLASSES];\n+  zero_width_bitfields = 2;\n+  if (classify_argument (mode, type, alt_classes, bit_offset,\n+\t\t\t zero_width_bitfields) != n)\n+    zero_width_bitfields = 3;\n+  else\n+    for (int i = 0; i < n; i++)\n+      if (classes[i] != alt_classes[i])\n+\t{\n+\t  zero_width_bitfields = 3;\n+\t  break;\n+\t}\n+  if (zero_width_bitfields == 3)\n+    {\n+      warned = true;\n+      const char *url\n+\t= CHANGES_ROOT_URL \"gcc-12/changes.html#zero_width_bitfields\";\n+\n+      inform (input_location,\n+\t      \"the ABI of passing C structures with zero-width bit-fields\"\n+\t      \" has changed in GCC %{12.1%}\", url);\n+    }\n+  return n;\n+}\n+\n /* Examine the argument and return set number of register required in each\n    class.  Return true iff parameter should be passed in memory.  */\n "}, {"sha": "0fbc0268a8e4d1302add3a6a2191b0006d4e41e0", "filename": "gcc/testsuite/g++.target/i386/pr102024.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3159da6c46568a7c600f78fb3a3b76e2ea4bf4cc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fpr102024.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3159da6c46568a7c600f78fb3a3b76e2ea4bf4cc/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fpr102024.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fpr102024.C?ref=3159da6c46568a7c600f78fb3a3b76e2ea4bf4cc", "patch": "@@ -0,0 +1,12 @@\n+// PR target/102024\n+// { dg-do compile }\n+\n+struct S { float a; int : 0; float b; };\n+void foo (struct S x);\n+\n+void\n+bar (void)\n+{\n+  struct S s = { 0.0f, 0.0f };\n+  foo (s);\t// { dg-bogus \"the ABI of passing C structures with zero-width bit-fields has changed in GCC 12.1\" }\n+}"}, {"sha": "703195b53bcc734d6350a15f8f767bffc8a0ae6b", "filename": "gcc/testsuite/gcc.target/i386/pr102024.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3159da6c46568a7c600f78fb3a3b76e2ea4bf4cc/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102024.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3159da6c46568a7c600f78fb3a3b76e2ea4bf4cc/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102024.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102024.c?ref=3159da6c46568a7c600f78fb3a3b76e2ea4bf4cc", "patch": "@@ -0,0 +1,12 @@\n+/* PR target/102024 */\n+/* { dg-do compile } */\n+\n+struct S { float a; int : 0; float b; };\n+void foo (struct S x);\n+\n+void\n+bar (void)\n+{\n+  struct S s = { 0.0f, 0.0f };\n+  foo (s);\t/* { dg-message \"the ABI of passing C structures with zero-width bit-fields has changed in GCC 12.1\" \"\" { target { ! ia32 } } } */\n+}"}]}