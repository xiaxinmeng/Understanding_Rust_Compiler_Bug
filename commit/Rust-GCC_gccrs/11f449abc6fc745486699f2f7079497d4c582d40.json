{"sha": "11f449abc6fc745486699f2f7079497d4c582d40", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTFmNDQ5YWJjNmZjNzQ1NDg2Njk5ZjJmNzA3OTQ5N2Q0YzU4MmQ0MA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2011-06-14T18:15:43Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2011-06-14T18:15:43Z"}, "message": "re PR c++/49290 ([C++0x] ICE in in cxx_eval_indirect_ref, at cp/semantics.c:6795)\n\n\tPR c++/49290\n\t* semantics.c (cxx_fold_indirect_ref): Local, more permissive copy\n\tof fold_indirect_ref_1.\n\t(cxx_eval_indirect_ref): Use it.\n\nFrom-SVN: r175041", "tree": {"sha": "4f165ec8e718ed30836e45e57e1842a5f4d553fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4f165ec8e718ed30836e45e57e1842a5f4d553fa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/11f449abc6fc745486699f2f7079497d4c582d40", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11f449abc6fc745486699f2f7079497d4c582d40", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11f449abc6fc745486699f2f7079497d4c582d40", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11f449abc6fc745486699f2f7079497d4c582d40/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "870c3cf85df843ce0ead00bcd9886f5ead4df98a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/870c3cf85df843ce0ead00bcd9886f5ead4df98a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/870c3cf85df843ce0ead00bcd9886f5ead4df98a"}], "stats": {"total": 215, "additions": 175, "deletions": 40}, "files": [{"sha": "5ae5d2d91ce08e1f6389e5104dcfcbadd1c0bc41", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11f449abc6fc745486699f2f7079497d4c582d40/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11f449abc6fc745486699f2f7079497d4c582d40/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=11f449abc6fc745486699f2f7079497d4c582d40", "patch": "@@ -1,3 +1,10 @@\n+2011-06-14  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/49290\n+\t* semantics.c (cxx_fold_indirect_ref): Local, more permissive copy\n+\tof fold_indirect_ref_1.\n+\t(cxx_eval_indirect_ref): Use it.\n+\n 2011-06-11  Jan Hubicka  <jh@suse.cz>\n \n \t* decl2.c (cp_write_global_declarations): Process aliases; look trhough"}, {"sha": "55f9519c43b17f19d38ee117d5b8e633c850ab5b", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 144, "deletions": 40, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11f449abc6fc745486699f2f7079497d4c582d40/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11f449abc6fc745486699f2f7079497d4c582d40/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=11f449abc6fc745486699f2f7079497d4c582d40", "patch": "@@ -6755,28 +6755,16 @@ cxx_eval_vec_init (const constexpr_call *call, tree t,\n    because we're dealing with things like ADDR_EXPR of INTEGER_CST which\n    don't really make sense outside of constant expression evaluation.  Also\n    we want to allow folding to COMPONENT_REF, which could cause trouble\n-   with TBAA in fold_indirect_ref_1.  */\n+   with TBAA in fold_indirect_ref_1.\n+\n+   Try to keep this function synced with fold_indirect_ref_1.  */\n \n static tree\n-cxx_eval_indirect_ref (const constexpr_call *call, tree t,\n-\t\t       bool allow_non_constant, bool addr,\n-\t\t       bool *non_constant_p)\n+cxx_fold_indirect_ref (location_t loc, tree type, tree op0, bool *empty_base)\n {\n-  tree orig_op0 = TREE_OPERAND (t, 0);\n-  tree op0 = cxx_eval_constant_expression (call, orig_op0, allow_non_constant,\n-\t\t\t\t\t   /*addr*/false, non_constant_p);\n-  tree type, sub, subtype, r;\n-  bool empty_base;\n+  tree sub, subtype;\n \n-  /* Don't VERIFY_CONSTANT here.  */\n-  if (*non_constant_p)\n-    return t;\n-\n-  type = TREE_TYPE (t);\n   sub = op0;\n-  r = NULL_TREE;\n-  empty_base = false;\n-\n   STRIP_NOPS (sub);\n   subtype = TREE_TYPE (sub);\n   gcc_assert (POINTER_TYPE_P (subtype));\n@@ -6786,16 +6774,52 @@ cxx_eval_indirect_ref (const constexpr_call *call, tree t,\n       tree op = TREE_OPERAND (sub, 0);\n       tree optype = TREE_TYPE (op);\n \n+      /* *&CONST_DECL -> to the value of the const decl.  */\n+      if (TREE_CODE (op) == CONST_DECL)\n+\treturn DECL_INITIAL (op);\n+      /* *&p => p;  make sure to handle *&\"str\"[cst] here.  */\n       if (same_type_ignoring_top_level_qualifiers_p (optype, type))\n-\tr = op;\n+\t{\n+\t  tree fop = fold_read_from_constant_string (op);\n+\t  if (fop)\n+\t    return fop;\n+\t  else\n+\t    return op;\n+\t}\n+      /* *(foo *)&fooarray => fooarray[0] */\n+      else if (TREE_CODE (optype) == ARRAY_TYPE\n+\t       && (same_type_ignoring_top_level_qualifiers_p\n+\t\t   (type, TREE_TYPE (optype))))\n+\t{\n+\t  tree type_domain = TYPE_DOMAIN (optype);\n+\t  tree min_val = size_zero_node;\n+\t  if (type_domain && TYPE_MIN_VALUE (type_domain))\n+\t    min_val = TYPE_MIN_VALUE (type_domain);\n+\t  return build4_loc (loc, ARRAY_REF, type, op, min_val,\n+\t\t\t     NULL_TREE, NULL_TREE);\n+\t}\n+      /* *(foo *)&complexfoo => __real__ complexfoo */\n+      else if (TREE_CODE (optype) == COMPLEX_TYPE\n+\t       && (same_type_ignoring_top_level_qualifiers_p\n+\t\t   (type, TREE_TYPE (optype))))\n+\treturn fold_build1_loc (loc, REALPART_EXPR, type, op);\n+      /* *(foo *)&vectorfoo => BIT_FIELD_REF<vectorfoo,...> */\n+      else if (TREE_CODE (optype) == VECTOR_TYPE\n+\t       && (same_type_ignoring_top_level_qualifiers_p\n+\t\t   (type, TREE_TYPE (optype))))\n+\t{\n+\t  tree part_width = TYPE_SIZE (type);\n+\t  tree index = bitsize_int (0);\n+\t  return fold_build3_loc (loc, BIT_FIELD_REF, type, op, part_width, index);\n+\t}\n       /* Also handle conversion to an empty base class, which\n \t is represented with a NOP_EXPR.  */\n-      else if (!addr && is_empty_class (type)\n+      else if (is_empty_class (type)\n \t       && CLASS_TYPE_P (optype)\n \t       && DERIVED_FROM_P (type, optype))\n \t{\n-\t  r = op;\n-\t  empty_base = true;\n+\t  *empty_base = true;\n+\t  return op;\n \t}\n       /* *(foo *)&struct_with_foo_field => COMPONENT_REF */\n       else if (RECORD_OR_UNION_TYPE_P (optype))\n@@ -6807,7 +6831,7 @@ cxx_eval_indirect_ref (const constexpr_call *call, tree t,\n \t\t&& (same_type_ignoring_top_level_qualifiers_p\n \t\t    (TREE_TYPE (field), type)))\n \t      {\n-\t\tr = fold_build3 (COMPONENT_REF, type, op, field, NULL_TREE);\n+\t\treturn fold_build3 (COMPONENT_REF, type, op, field, NULL_TREE);\n \t\tbreak;\n \t      }\n \t}\n@@ -6825,8 +6849,49 @@ cxx_eval_indirect_ref (const constexpr_call *call, tree t,\n \t  op00 = TREE_OPERAND (op00, 0);\n \t  op00type = TREE_TYPE (op00);\n \n+\t  /* ((foo*)&vectorfoo)[1] => BIT_FIELD_REF<vectorfoo,...> */\n+\t  if (TREE_CODE (op00type) == VECTOR_TYPE\n+\t      && (same_type_ignoring_top_level_qualifiers_p\n+\t\t  (type, TREE_TYPE (op00type))))\n+\t    {\n+\t      HOST_WIDE_INT offset = tree_low_cst (op01, 0);\n+\t      tree part_width = TYPE_SIZE (type);\n+\t      unsigned HOST_WIDE_INT part_widthi = tree_low_cst (part_width, 0)/BITS_PER_UNIT;\n+\t      unsigned HOST_WIDE_INT indexi = offset * BITS_PER_UNIT;\n+\t      tree index = bitsize_int (indexi);\n+\n+\t      if (offset/part_widthi <= TYPE_VECTOR_SUBPARTS (op00type))\n+\t\treturn fold_build3_loc (loc,\n+\t\t\t\t\tBIT_FIELD_REF, type, op00,\n+\t\t\t\t\tpart_width, index);\n+\n+\t    }\n+\t  /* ((foo*)&complexfoo)[1] => __imag__ complexfoo */\n+\t  else if (TREE_CODE (op00type) == COMPLEX_TYPE\n+\t\t   && (same_type_ignoring_top_level_qualifiers_p\n+\t\t       (type, TREE_TYPE (op00type))))\n+\t    {\n+\t      tree size = TYPE_SIZE_UNIT (type);\n+\t      if (tree_int_cst_equal (size, op01))\n+\t\treturn fold_build1_loc (loc, IMAGPART_EXPR, type, op00);\n+\t    }\n+\t  /* ((foo *)&fooarray)[1] => fooarray[1] */\n+\t  else if (TREE_CODE (op00type) == ARRAY_TYPE\n+\t\t   && (same_type_ignoring_top_level_qualifiers_p\n+\t\t       (type, TREE_TYPE (op00type))))\n+\t    {\n+\t      tree type_domain = TYPE_DOMAIN (op00type);\n+\t      tree min_val = size_zero_node;\n+\t      if (type_domain && TYPE_MIN_VALUE (type_domain))\n+\t\tmin_val = TYPE_MIN_VALUE (type_domain);\n+\t      op01 = size_binop_loc (loc, EXACT_DIV_EXPR, op01,\n+\t\t\t\t     TYPE_SIZE_UNIT (type));\n+\t      op01 = size_binop_loc (loc, PLUS_EXPR, op01, min_val);\n+\t      return build4_loc (loc, ARRAY_REF, type, op00, op01,\n+\t\t\t\t NULL_TREE, NULL_TREE);\n+\t    }\n \t  /* ((foo *)&struct_with_foo_field)[1] => COMPONENT_REF */\n-\t  if (RECORD_OR_UNION_TYPE_P (op00type))\n+\t  else if (RECORD_OR_UNION_TYPE_P (op00type))\n \t    {\n \t      tree field = TYPE_FIELDS (op00type);\n \t      for (; field; field = DECL_CHAIN (field))\n@@ -6835,32 +6900,71 @@ cxx_eval_indirect_ref (const constexpr_call *call, tree t,\n \t\t    && (same_type_ignoring_top_level_qualifiers_p\n \t\t\t(TREE_TYPE (field), type)))\n \t\t  {\n-\t\t    r = fold_build3 (COMPONENT_REF, type, op00,\n+\t\t    return fold_build3 (COMPONENT_REF, type, op00,\n \t\t\t\t     field, NULL_TREE);\n \t\t    break;\n \t\t  }\n \t    }\n \t}\n     }\n+  /* *(foo *)fooarrptreturn> (*fooarrptr)[0] */\n+  else if (TREE_CODE (TREE_TYPE (subtype)) == ARRAY_TYPE\n+\t   && (same_type_ignoring_top_level_qualifiers_p\n+\t       (type, TREE_TYPE (TREE_TYPE (subtype)))))\n+    {\n+      tree type_domain;\n+      tree min_val = size_zero_node;\n+      sub = cxx_fold_indirect_ref (loc, TREE_TYPE (subtype), sub, NULL);\n+      if (!sub)\n+\tsub = build1_loc (loc, INDIRECT_REF, TREE_TYPE (subtype), sub);\n+      type_domain = TYPE_DOMAIN (TREE_TYPE (sub));\n+      if (type_domain && TYPE_MIN_VALUE (type_domain))\n+\tmin_val = TYPE_MIN_VALUE (type_domain);\n+      return build4_loc (loc, ARRAY_REF, type, sub, min_val, NULL_TREE,\n+\t\t\t NULL_TREE);\n+    }\n \n-  /* Let build_fold_indirect_ref handle the cases it does fine with.  */\n-  if (r == NULL_TREE)\n-    r = build_fold_indirect_ref (op0);\n-  if (TREE_CODE (r) != INDIRECT_REF)\n+  return NULL_TREE;\n+}\n+\n+static tree\n+cxx_eval_indirect_ref (const constexpr_call *call, tree t,\n+\t\t       bool allow_non_constant, bool addr,\n+\t\t       bool *non_constant_p)\n+{\n+  tree orig_op0 = TREE_OPERAND (t, 0);\n+  tree op0 = cxx_eval_constant_expression (call, orig_op0, allow_non_constant,\n+\t\t\t\t\t   /*addr*/false, non_constant_p);\n+  bool empty_base = false;\n+  tree r;\n+\n+  /* Don't VERIFY_CONSTANT here.  */\n+  if (*non_constant_p)\n+    return t;\n+\n+  r = cxx_fold_indirect_ref (EXPR_LOCATION (t), TREE_TYPE (t), op0,\n+\t\t\t     &empty_base);\n+\n+  if (r)\n     r = cxx_eval_constant_expression (call, r, allow_non_constant,\n \t\t\t\t      addr, non_constant_p);\n-  else if (TREE_CODE (sub) == ADDR_EXPR\n-\t   || TREE_CODE (sub) == POINTER_PLUS_EXPR)\n+  else\n     {\n-      gcc_assert (!same_type_ignoring_top_level_qualifiers_p\n-\t\t  (TREE_TYPE (TREE_TYPE (sub)), TREE_TYPE (t)));\n-      /* FIXME Mike Miller wants this to be OK.  */\n-      if (!allow_non_constant)\n-\terror (\"accessing value of %qE through a %qT glvalue in a \"\n-\t       \"constant expression\", build_fold_indirect_ref (sub),\n-\t       TREE_TYPE (t));\n-      *non_constant_p = true;\n-      return t;\n+      tree sub = op0;\n+      STRIP_NOPS (sub);\n+      if (TREE_CODE (sub) == ADDR_EXPR\n+\t  || TREE_CODE (sub) == POINTER_PLUS_EXPR)\n+\t{\n+\t  gcc_assert (!same_type_ignoring_top_level_qualifiers_p\n+\t\t      (TREE_TYPE (TREE_TYPE (sub)), TREE_TYPE (t)));\n+\t  /* FIXME Mike Miller wants this to be OK.  */\n+\t  if (!allow_non_constant)\n+\t    error (\"accessing value of %qE through a %qT glvalue in a \"\n+\t\t   \"constant expression\", build_fold_indirect_ref (sub),\n+\t\t   TREE_TYPE (t));\n+\t  *non_constant_p = true;\n+\t  return t;\n+\t}\n     }\n \n   /* If we're pulling out the value of an empty base, make sure\n@@ -6873,7 +6977,7 @@ cxx_eval_indirect_ref (const constexpr_call *call, tree t,\n       TREE_CONSTANT (r) = true;\n     }\n \n-  if (TREE_CODE (r) == INDIRECT_REF && TREE_OPERAND (r, 0) == orig_op0)\n+  if (r == NULL_TREE)\n     return t;\n   return r;\n }"}, {"sha": "8b324e3524faca3e10ecee6e9a949793e2d4e79a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11f449abc6fc745486699f2f7079497d4c582d40/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11f449abc6fc745486699f2f7079497d4c582d40/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=11f449abc6fc745486699f2f7079497d4c582d40", "patch": "@@ -1,3 +1,7 @@\n+2011-06-14  Jason Merrill  <jason@redhat.com>\n+\n+\t* g++.dg/cpp0x/constexpr-array-ptr7.C: New.\n+\n 2011-06-14  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR fortran/49103"}, {"sha": "44775c0703c532705c6177e7db69729ee813cab3", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-array-ptr7.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11f449abc6fc745486699f2f7079497d4c582d40/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-array-ptr7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11f449abc6fc745486699f2f7079497d4c582d40/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-array-ptr7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-array-ptr7.C?ref=11f449abc6fc745486699f2f7079497d4c582d40", "patch": "@@ -0,0 +1,20 @@\n+// PR c++/49290\n+// { dg-options -std=c++0x }\n+\n+typedef unsigned T;\n+struct S\n+{\n+  constexpr T foo (void);\n+  unsigned s1[16];\n+};\n+\n+constexpr T\n+S::foo ()\n+{\n+  return *(T *) (s1 + 10);\n+}\n+\n+constexpr S s = { 0,1,2,3,4,5,6,7,8,9,10 };\n+\n+#define SA(X) static_assert ((X), #X)\n+SA(s.foo() == 10);"}]}