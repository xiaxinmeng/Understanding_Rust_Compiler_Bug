{"sha": "a2ef9558d17aeb038cbc8a66a203f7a8e6c6e81e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTJlZjk1NThkMTdhZWIwMzhjYmM4YTY2YTIwM2Y3YThlNmM2ZTgxZQ==", "commit": {"author": {"name": "Markus Trippelsdorf", "email": "markus@trippelsdorf.de", "date": "2017-12-17T12:01:25Z"}, "committer": {"name": "Markus Trippelsdorf", "email": "trippels@gcc.gnu.org", "date": "2017-12-17T12:01:25Z"}, "message": "Correct imul (r64) latency for modern Intel CPUs\n\nSince Sandybridge the 64bit multiplication latency is three cycles, not\nfour. So update the costs to reflect reality.\n\n\t* x86-tune-costs.h (skylake_cost, core_cost): Decrease r64 multiply\n\tlatencies.\n\n\t* gcc.target/i386/wmul-3.c: New test.\n\nFrom-SVN: r255760", "tree": {"sha": "b25c6818a61fd8d5752c2aa8a73c912df16c2234", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b25c6818a61fd8d5752c2aa8a73c912df16c2234"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a2ef9558d17aeb038cbc8a66a203f7a8e6c6e81e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2ef9558d17aeb038cbc8a66a203f7a8e6c6e81e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2ef9558d17aeb038cbc8a66a203f7a8e6c6e81e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2ef9558d17aeb038cbc8a66a203f7a8e6c6e81e/comments", "author": null, "committer": null, "parents": [{"sha": "d7f06bc3f7e1e1da11c065cc96a81f15bd0ca68f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7f06bc3f7e1e1da11c065cc96a81f15bd0ca68f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7f06bc3f7e1e1da11c065cc96a81f15bd0ca68f"}], "stats": {"total": 84, "additions": 80, "deletions": 4}, "files": [{"sha": "0f0418590bead6594931166ad0f7970d8c80deff", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ef9558d17aeb038cbc8a66a203f7a8e6c6e81e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ef9558d17aeb038cbc8a66a203f7a8e6c6e81e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a2ef9558d17aeb038cbc8a66a203f7a8e6c6e81e", "patch": "@@ -1,3 +1,8 @@\n+2017-12-17  Markus Trippelsdorf  <markus@trippelsdorf.de>\n+\n+\t* x86-tune-costs.h (skylake_cost, core_cost): Decrease r64 multiply\n+\tlatencies.\n+\n 2017-12-16  Sandra Loosemore  <sandra@codesourcery.com>\n \n \t* doc/invoke.texi: Fix some typos."}, {"sha": "477e478f1f7769e92fa5325d5a4d4dde79ac9f42", "filename": "gcc/config/i386/x86-tune-costs.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ef9558d17aeb038cbc8a66a203f7a8e6c6e81e/gcc%2Fconfig%2Fi386%2Fx86-tune-costs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ef9558d17aeb038cbc8a66a203f7a8e6c6e81e/gcc%2Fconfig%2Fi386%2Fx86-tune-costs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fx86-tune-costs.h?ref=a2ef9558d17aeb038cbc8a66a203f7a8e6c6e81e", "patch": "@@ -1538,8 +1538,8 @@ struct processor_costs skylake_cost = {\n   {COSTS_N_INSNS (3),\t\t\t/* cost of starting multiply for QI */\n    COSTS_N_INSNS (4),\t\t\t/*\t\t\t\t HI */\n    COSTS_N_INSNS (3),\t\t\t/*\t\t\t\t SI */\n-   COSTS_N_INSNS (4),\t\t\t/*\t\t\t\t DI */\n-   COSTS_N_INSNS (4)},\t\t\t/*\t\t\t      other */\n+   COSTS_N_INSNS (3),\t\t\t/*\t\t\t\t DI */\n+   COSTS_N_INSNS (3)},\t\t\t/*\t\t\t      other */\n   0,\t\t\t\t\t/* cost of multiply per each bit set */\n   /* Expanding div/mod currently doesn't consider parallelism. So the cost\n      model is not realistic. We compensate by increasing the latencies a bit.  */\n@@ -2341,8 +2341,9 @@ struct processor_costs core_cost = {\n   {COSTS_N_INSNS (3),\t\t\t/* cost of starting multiply for QI */\n    COSTS_N_INSNS (4),\t\t\t/*\t\t\t\t HI */\n    COSTS_N_INSNS (3),\t\t\t/*\t\t\t\t SI */\n-   COSTS_N_INSNS (4),\t\t\t/*\t\t\t\t DI */\n-   COSTS_N_INSNS (4)},\t\t\t/*\t\t\t      other */\n+   /* Here we tune for Sandybridge or newer.  */\n+   COSTS_N_INSNS (3),\t\t\t/*\t\t\t\t DI */\n+   COSTS_N_INSNS (3)},\t\t\t/*\t\t\t      other */\n   0,\t\t\t\t\t/* cost of multiply per each bit set */\n   /* Expanding div/mod currently doesn't consider parallelism. So the cost\n      model is not realistic. We compensate by increasing the latencies a bit.  */"}, {"sha": "c7d3977e43e8ea19a22fff3104e8c48ce6d87b6f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ef9558d17aeb038cbc8a66a203f7a8e6c6e81e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ef9558d17aeb038cbc8a66a203f7a8e6c6e81e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a2ef9558d17aeb038cbc8a66a203f7a8e6c6e81e", "patch": "@@ -1,3 +1,7 @@\n+2017-12-17  Markus Trippelsdorf  <markus@trippelsdorf.de> \n+\n+\t* gcc.target/i386/wmul-3.c: New test.\n+\n 2017-12-16  Martin Sebor  <msebor@redhat.com>\n \n \tPR tree-optimization/78918"}, {"sha": "5f1619076386a089c720fffc7da39f9c471281e9", "filename": "gcc/testsuite/gcc.target/i386/wmul-3.c", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ef9558d17aeb038cbc8a66a203f7a8e6c6e81e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fwmul-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ef9558d17aeb038cbc8a66a203f7a8e6c6e81e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fwmul-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fwmul-3.c?ref=a2ef9558d17aeb038cbc8a66a203f7a8e6c6e81e", "patch": "@@ -0,0 +1,66 @@\n+/* { dg-do compile { target { ! ia32 } } } */\n+/* { dg-options \"-O2 -march=sandybridge\" } */\n+\n+#include <stdint.h>\n+#include <string.h>\n+\n+static const char b100_tab[200] = {\n+    '0', '0', '0', '1', '0', '2', '0', '3', '0', '4',\n+    '0', '5', '0', '6', '0', '7', '0', '8', '0', '9',\n+    '1', '0', '1', '1', '1', '2', '1', '3', '1', '4',\n+    '1', '5', '1', '6', '1', '7', '1', '8', '1', '9',\n+    '2', '0', '2', '1', '2', '2', '2', '3', '2', '4',\n+    '2', '5', '2', '6', '2', '7', '2', '8', '2', '9',\n+    '3', '0', '3', '1', '3', '2', '3', '3', '3', '4',\n+    '3', '5', '3', '6', '3', '7', '3', '8', '3', '9',\n+    '4', '0', '4', '1', '4', '2', '4', '3', '4', '4',\n+    '4', '5', '4', '6', '4', '7', '4', '8', '4', '9',\n+    '5', '0', '5', '1', '5', '2', '5', '3', '5', '4',\n+    '5', '5', '5', '6', '5', '7', '5', '8', '5', '9',\n+    '6', '0', '6', '1', '6', '2', '6', '3', '6', '4',\n+    '6', '5', '6', '6', '6', '7', '6', '8', '6', '9',\n+    '7', '0', '7', '1', '7', '2', '7', '3', '7', '4',\n+    '7', '5', '7', '6', '7', '7', '7', '8', '7', '9',\n+    '8', '0', '8', '1', '8', '2', '8', '3', '8', '4',\n+    '8', '5', '8', '6', '8', '7', '8', '8', '8', '9',\n+    '9', '0', '9', '1', '9', '2', '9', '3', '9', '4',\n+    '9', '5', '9', '6', '9', '7', '9', '8', '9', '9',\n+};\n+\n+void uint64_to_ascii_ta7_32_base100(uint64_t val, char *dst) {\n+  const int64_t POW10_10 = ((int64_t)10) * 1000 * 1000 * 1000;\n+  const uint64_t POW2_57_DIV_POW100_4 =\n+      ((int64_t)(1) << 57) / 100 / 100 / 100 / 100 + 1;\n+  const uint64_t MASK32 = ((int64_t)(1) << 32) - 1;\n+  int64_t hix = val / POW10_10;\n+  int64_t lox = val % POW10_10;\n+  int64_t lor = lox & (uint64_t)(-2);\n+  uint64_t hi = hix * POW2_57_DIV_POW100_4;\n+  uint64_t lo = lor * POW2_57_DIV_POW100_4;\n+  memcpy(dst + 0 * 10 + 0, &b100_tab[(hi >> 57) * 2], 2);\n+  memcpy(dst + 1 * 10 + 0, &b100_tab[(lo >> 57) * 2], 2);\n+  hi = (hi >> 25) + 1;\n+  lo = (lo >> 25) + 1;\n+  hi = (hi & MASK32) * 100;\n+  lo = (lo & MASK32) * 100;\n+  memcpy(dst + 0 * 10 + 2, &b100_tab[(hi >> 32) * 2], 2);\n+  hi = (hi & MASK32) * 100;\n+  memcpy(dst + 1 * 10 + 2, &b100_tab[(lo >> 32) * 2], 2);\n+  lo = (lo & MASK32) * 100;\n+  memcpy(dst + 0 * 10 + 4, &b100_tab[(hi >> 32) * 2], 2);\n+  hi = (hi & MASK32) * 100;\n+  memcpy(dst + 1 * 10 + 4, &b100_tab[(lo >> 32) * 2], 2);\n+  lo = (lo & MASK32) * 100;\n+  memcpy(dst + 0 * 10 + 6, &b100_tab[(hi >> 32) * 2], 2);\n+  hi = (hi & MASK32) * 100;\n+  memcpy(dst + 1 * 10 + 6, &b100_tab[(lo >> 32) * 2], 2);\n+  lo = (lo & MASK32) * 100;\n+  hi >>= 32;\n+  lo >>= 32;\n+  lo = (lo & (-2)) | (lox & 1);\n+  memcpy(dst + 0 * 10 + 8, &b100_tab[hi * 2], 2);\n+  memcpy(dst + 1 * 10 + 8, &b100_tab[lo * 2], 2);\n+  dst[2 * 10] = 0;\n+}\n+\n+/* { dg-final { scan-assembler-times \"imulq\" 11 } } */"}]}