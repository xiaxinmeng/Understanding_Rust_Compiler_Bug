{"sha": "42348101742f1257f76247b577489a7c2b8db31b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDIzNDgxMDE3NDJmMTI1N2Y3NjI0N2I1Nzc0ODlhN2MyYjhkYjMxYg==", "commit": {"author": {"name": "Mark Wielaard", "email": "mark@klomp.org", "date": "2004-08-26T16:10:54Z"}, "committer": {"name": "Mark Wielaard", "email": "mark@gcc.gnu.org", "date": "2004-08-26T16:10:54Z"}, "message": "re PR libgcj/17002 (java.util.TimeZone.getDefault() is broken)\n\n2004-08-26  Mark Wielaard  <mark@klomp.org>\n\n       Fixes PR libgcj/17002:\n       * java/util/TimeZone.java (defaultZone): Try a couple of ways to get\n       a TimeZoneId string and then try to convert that to a TimeZone with\n       getDefaultSystemTimeZone(String).\n       (timezones0): Changed type from Hashtable to HashMap.\n       (timezones): Create HashMap, not Hashtable.\n       (getDefaultTimeZone): New method, rewritten from CNI version.\n       (readTimeZoneFile): New method.\n       (readtzFile): Likewise.\n       (skipFully): Likewise.\n       * java/util/natTimeZone.cc (getSystemTimeZone): Renamed to\n       getDefaultTimeZoneId and rewritten.\n       (getDefaultTimeZoneId): Rewritten in java.\n\nFrom-SVN: r86623", "tree": {"sha": "6df4fd9c7b305a1f8cf73d45d5127b66f4df689c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6df4fd9c7b305a1f8cf73d45d5127b66f4df689c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/42348101742f1257f76247b577489a7c2b8db31b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42348101742f1257f76247b577489a7c2b8db31b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42348101742f1257f76247b577489a7c2b8db31b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42348101742f1257f76247b577489a7c2b8db31b/comments", "author": null, "committer": null, "parents": [{"sha": "20edd06b2f06e2ec2d5454793487fb97aeb9fa61", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20edd06b2f06e2ec2d5454793487fb97aeb9fa61", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20edd06b2f06e2ec2d5454793487fb97aeb9fa61"}], "stats": {"total": 681, "additions": 538, "deletions": 143}, "files": [{"sha": "fb6d55596b34da9d6c2416c85e13f797644f5868", "filename": "libjava/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42348101742f1257f76247b577489a7c2b8db31b/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42348101742f1257f76247b577489a7c2b8db31b/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=42348101742f1257f76247b577489a7c2b8db31b", "patch": "@@ -1,3 +1,19 @@\n+2004-08-26  Mark Wielaard  <mark@klomp.org>\n+\n+\tFixes PR libgcj/17002:\n+\t* java/util/TimeZone.java (defaultZone): Try a couple of ways to get\n+\ta TimeZoneId string and then try to convert that to a TimeZone with\n+\tgetDefaultSystemTimeZone(String).\n+\t(timezones0): Changed type from Hashtable to HashMap.\n+\t(timezones): Create HashMap, not Hashtable.\n+\t(getDefaultTimeZone): New method, rewritten from CNI version.\n+\t(readTimeZoneFile): New method.\n+\t(readtzFile): Likewise.\n+\t(skipFully): Likewise.\n+\t* java/util/natTimeZone.cc (getSystemTimeZone): Renamed to\n+\tgetDefaultTimeZoneId and rewritten.\n+\t(getDefaultTimeZoneId): Rewritten in java.\n+\t\n 2004-08-25  David Daney  <daney@avtrex.com>\n \n \t* Makefile.am (AM_GCJFLAGS):  Add LIBGCJ_JAVAFLAGS."}, {"sha": "cc3c7a3d283314c782aef3f08ea23b1bba834a23", "filename": "libjava/java/util/TimeZone.java", "status": "modified", "additions": 438, "deletions": 34, "changes": 472, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42348101742f1257f76247b577489a7c2b8db31b/libjava%2Fjava%2Futil%2FTimeZone.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42348101742f1257f76247b577489a7c2b8db31b/libjava%2Fjava%2Futil%2FTimeZone.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FTimeZone.java?ref=42348101742f1257f76247b577489a7c2b8db31b", "patch": "@@ -40,6 +40,9 @@\n package java.util;\n import gnu.classpath.Configuration;\n \n+import java.io.*;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n import java.text.DateFormatSymbols;\n \n /**\n@@ -83,44 +86,99 @@ public abstract class TimeZone implements java.io.Serializable, Cloneable\n    * The default time zone, as returned by getDefault.\n    */\n   private static TimeZone defaultZone0;\n-  /* initialize this static field lazily to overhead if\n-   * it is not needed: \n+\n+  /**\n+   * Tries to get the default TimeZone for this system if not already\n+   * set.  It will call <code>getDefaultTimeZone(String)</code> with\n+   * the result of\n+   * <code>System.getProperty(\"user.timezone\")</code>,\n+   * <code>System.getenv(\"TZ\")</code>,\n+   * <code>readTimeZoneFile(\"/etc/timezone\")</code>,\n+   * <code>readtzFile(\"/etc/localtime\")</code> and\n+   * <code>getDefaultTimeZoneId()</code>\n+   * till a supported TimeZone is found.\n+   * If every method fails GMT is returned.\n    */\n-  private static synchronized TimeZone defaultZone() {\n+  private static synchronized TimeZone defaultZone()\n+  {\n     /* Look up default timezone */\n     if (defaultZone0 == null) \n       {\n-\tif (Configuration.INIT_LOAD_LIBRARY)\n-\t  {\n-\t    System.loadLibrary(\"javautil\");\n-\t  }\n-\tString tzid = System.getProperty(\"user.timezone\");\n-\t\n-\tif (tzid == null)\n-\t  tzid = getDefaultTimeZoneId();\n-\t\n-\tif (tzid == null)\n-\t  tzid = \"GMT\";\n-\t\n-\tdefaultZone0 = getTimeZone(tzid);\n+\tdefaultZone0 = (TimeZone) AccessController.doPrivileged\n+\t  (new PrivilegedAction()\n+\t    {\n+\t      public Object run()\n+\t      {\n+\t\tif (Configuration.INIT_LOAD_LIBRARY)\n+\t\t  {\n+\t\t    System.loadLibrary(\"javautil\");\n+\t\t  }\n+\t\t\n+\t\tTimeZone zone = null;\n+\t\t\n+\t\t// Prefer System property user.timezone.\n+\t\tString tzid = System.getProperty(\"user.timezone\");\n+\t\tif (tzid != null && !tzid.equals(\"\"))\n+\t\t  zone = getDefaultTimeZone(tzid);\n+\t\t\n+\t\t// See if TZ environment variable is set and accessible.\n+\t\tif (zone == null)\n+\t\t  {\n+\t\t    tzid = System.getenv(\"TZ\");\n+\t\t    if (tzid != null && !tzid.equals(\"\"))\n+\t\t      zone = getDefaultTimeZone(tzid);\n+\t\t  }\n+\t\t\n+\t\t// Try to parse /etc/timezone.\n+\t\tif (zone == null)\n+\t\t  {\n+\t\t    tzid = readTimeZoneFile(\"/etc/timezone\");\n+\t\t    if (tzid != null && !tzid.equals(\"\"))\n+\t\t      zone = getDefaultTimeZone(tzid);\n+\t\t  }\n+\t\t\n+\t\t// Try to parse /etc/localtime\n+\t\tif (zone == null)\n+\t\t  {\n+\t\t    tzid = readtzFile(\"/etc/localtime\");\n+\t\t    if (tzid != null && !tzid.equals(\"\"))\n+\t\t      zone = getDefaultTimeZone(tzid);\n+\t\t  }\n+\t\t\n+\t\t// Try some system specific way\n+\t\tif (zone == null)\n+\t\t  {\n+\t\t    tzid = getDefaultTimeZoneId();\n+\t\t    if (tzid != null && !tzid.equals(\"\"))\n+\t\t      zone = getDefaultTimeZone(tzid);\n+\t\t  }\n+\t\t\n+\t\t// Fall back on GMT.\n+\t\tif (zone == null)\n+\t\t  zone = (TimeZone) timezones().get(\"GMT\");\n+\t\t\n+\t\treturn zone;\n+\t      }\n+\t    });\n       }\n+    \n     return defaultZone0; \n   }\n-\n-\n+  \n   private static final long serialVersionUID = 3581463369166924961L;\n \n   /**\n-   * Hashtable for timezones by ID.  \n+   * HashMap for timezones by ID.  \n    */\n-  private static Hashtable timezones0;\n+  private static HashMap timezones0;\n   /* initialize this static field lazily to overhead if\n    * it is not needed: \n    */\n-  private static synchronized Hashtable timezones() {\n-    if (timezones0==null) \n+  private static synchronized HashMap timezones()\n+  {\n+    if (timezones0 == null) \n       {\n-\tHashtable timezones = new Hashtable();\n+\tHashMap timezones = new HashMap();\n \ttimezones0 = timezones;\n \n \tTimeZone tz;\n@@ -784,18 +842,362 @@ private static synchronized Hashtable timezones() {\n     return timezones0;\n   }\n \n-\n-  /* This method returns us a time zone id string which is in the\n-     form <standard zone name><GMT offset><daylight time zone name>.\n-     The GMT offset is in seconds, except where it is evenly divisible\n-     by 3600, then it is in hours.  If the zone does not observe\n-     daylight time, then the daylight zone name is omitted.  Examples:\n-     in Chicago, the timezone would be CST6CDT.  In Indianapolis \n-     (which does not have Daylight Savings Time) the string would\n-     be EST5\n+  /**\n+   * This method returns a time zone id string which is in the form\n+   * (standard zone name) or (standard zone name)(GMT offset) or\n+   * (standard zone name)(GMT offset)(daylight time zone name).  The\n+   * GMT offset can be in seconds, or where it is evenly divisible by\n+   * 3600, then it can be in hours.  The offset must be the time to\n+   * add to the local time to get GMT.  If a offset is given and the\n+   * time zone observes daylight saving then the (daylight time zone\n+   * name) must also be given (otherwise it is assumed the time zone\n+   * does not observe any daylight savings).\n+   * <p>\n+   * The result of this method is given to getDefaultTimeZone(String)\n+   * which tries to map the time zone id to a known TimeZone.  See\n+   * that method on how the returned String is mapped to a real\n+   * TimeZone object.\n    */\n   private static native String getDefaultTimeZoneId();\n \n+  /**\n+   * Tries to read the time zone name from a file. Only the first\n+   * consecutive letters, digits, slashes, dashes and underscores are\n+   * read from the file. If the file cannot be read or an IOException\n+   * occurs null is returned.\n+   * <p>\n+   * The /etc/timezone file is not standard, but a lot of systems have\n+   * it. If it exist the first line always contains a string\n+   * describing the timezone of the host of domain. Some systems\n+   * contain a /etc/TIMEZONE file which is used to set the TZ\n+   * environment variable (which is checked before /etc/timezone is\n+   * read).\n+   */\n+  private static String readTimeZoneFile(String file)\n+  {\n+    File f = new File(file);\n+    if (!f.exists())\n+      return null;\n+\n+    InputStreamReader isr = null;\n+    try\n+      {\n+\tFileInputStream fis = new FileInputStream(f);\n+\tBufferedInputStream bis = new BufferedInputStream(fis);\n+\tisr = new InputStreamReader(bis);\n+\t\n+\tStringBuffer sb = new StringBuffer();\n+\tint i = isr.read();\n+\twhile (i != -1)\n+\t  {\n+\t    char c = (char) i;\n+\t    if (Character.isLetter(c) || Character.isDigit(c)\n+\t\t|| c == '/' || c == '-' || c == '_')\n+\t      {\n+\t\tsb.append(c);\n+\t\ti = isr.read();\n+\t      }\n+\t    else\n+\t      break;\n+\t  }\n+\treturn sb.toString();\n+      }\n+    catch (IOException ioe)\n+      {\n+\t// Parse error, not a proper tzfile.\n+\treturn null;\n+      }\n+    finally\n+      {\n+\ttry\n+\t  {\n+\t    if (isr != null)\n+\t      isr.close();\n+\t  }\n+\tcatch (IOException ioe)\n+\t  {\n+\t    // Error while close, nothing we can do.\n+\t  }\n+      }\n+  }\n+\n+  /**\n+   * Tries to read a file as a \"standard\" tzfile and return a time\n+   * zone id string as expected by <code>getDefaultTimeZone(String)</code>.\n+   * If the file doesn't exist, an IOException occurs or it isn't a tzfile\n+   * that can be parsed null is returned.\n+   * <p>\n+   * The tzfile structure (as also used by glibc) is described in the Olson\n+   * tz database archive as can be found at\n+   * <code>ftp://elsie.nci.nih.gov/pub/</code>.\n+   * <p>\n+   * At least the following platforms support the tzdata file format\n+   * and /etc/localtime (GNU/Linux, Darwin, Solaris and FreeBSD at\n+   * least). Some systems (like Darwin) don't start the file with the\n+   * required magic bytes 'TZif', this implementation can handle\n+   * that).\n+   */\n+  private static String readtzFile(String file)\n+  {\n+    File f = new File(file);\n+    if (!f.exists())\n+      return null;\n+    \n+    DataInputStream dis = null;\n+    try\n+      {\n+        FileInputStream fis = new FileInputStream(f);\n+        BufferedInputStream bis = new BufferedInputStream(fis);\n+        dis = new DataInputStream(bis);\n+\t\n+        // Make sure we are reading a tzfile.\n+        byte[] tzif = new byte[4];\n+        dis.readFully(tzif);\n+        if (tzif[0] == 'T' && tzif[1] == 'Z'\n+            && tzif[2] == 'i' && tzif[3] == 'f')\n+\t  // Reserved bytes, ttisgmtcnt, ttisstdcnt and leapcnt\n+\t  skipFully(dis, 16 + 3 * 4);\n+\telse\n+\t  // Darwin has tzdata files that don't start with the TZif marker\n+\t  skipFully(dis, 16 + 3 * 4 - 4);\n+\t\n+\tint timecnt = dis.readInt();\n+\tint typecnt = dis.readInt();\n+\tif (typecnt > 0)\n+\t  {\n+\t    int charcnt = dis.readInt();\n+\t    // Transition times plus indexed transition times.\n+\t    skipFully(dis, timecnt * (4 + 1));\n+\t    \n+\t    // Get last gmt_offset and dst/non-dst time zone names.\n+\t    int abbrind = -1;\n+\t    int dst_abbrind = -1;\n+\t    int gmt_offset = 0;\n+\t    while (typecnt-- > 0)\n+\t      {\n+\t\t// gmtoff\n+\t\tint offset = dis.readInt();\n+\t\tint dst = dis.readByte();\n+\t\tif (dst == 0)\n+\t\t  {\n+\t\t    abbrind = dis.readByte();\n+\t\t    gmt_offset = offset;\n+\t\t  }\n+\t\telse\n+\t\t  dst_abbrind = dis.readByte();\n+\t      }\n+\t    \n+\t    // gmt_offset is the offset you must add to UTC/GMT to\n+\t    // get the local time, we need the offset to add to\n+\t    // the local time to get UTC/GMT.\n+\t    gmt_offset *= -1;\n+\t    \n+\t    // Turn into hours if possible.\n+\t    if (gmt_offset % 3600 == 0)\n+\t      gmt_offset /= 3600;\n+\t    \n+\t    if (abbrind >= 0)\n+\t      {\n+\t\tbyte[] names = new byte[charcnt];\n+\t\tdis.readFully(names);\n+\t\tint j = abbrind;\n+\t\twhile (j < charcnt && names[j] != 0)\n+\t\t  j++;\n+\t\t\n+\t\tString zonename = new String(names, abbrind, j - abbrind,\n+\t\t\t\t\t     \"ASCII\");\n+\t\t\n+\t\tString dst_zonename;\n+\t\tif (dst_abbrind >= 0)\n+\t\t  {\n+\t\t    j = dst_abbrind;\n+\t\t    while (j < charcnt && names[j] != 0)\n+\t\t      j++;\n+\t\t    dst_zonename = new String(names, dst_abbrind,\n+\t\t\t\t\t      j - dst_abbrind, \"ASCII\");\n+\t\t  }\n+\t\telse\n+\t\t  dst_zonename = \"\";\n+\t\t\n+\t\t// Only use gmt offset when necessary.\n+\t\t// Also special case GMT+/- timezones.\n+\t\tString offset_string;\n+\t\tif (\"\".equals(dst_zonename)\n+\t\t    && (gmt_offset == 0\n+\t\t\t|| zonename.startsWith(\"GMT+\")\n+\t\t\t|| zonename.startsWith(\"GMT-\")))\n+\t\t  offset_string = \"\";\n+\t\telse\n+\t\t  offset_string = Integer.toString(gmt_offset);\n+\t\t\n+\t\tString id = zonename + offset_string + dst_zonename;\n+\t\t\n+\t\treturn id;\n+\t      }\n+\t  }\n+\t\n+\t// Something didn't match while reading the file.\n+\treturn null;\n+      }\n+    catch (IOException ioe)\n+      {\n+\t// Parse error, not a proper tzfile.\n+\treturn null;\n+      }\n+    finally\n+      {\n+\ttry\n+\t  {\n+\t    if (dis != null)\n+\t      dis.close();\n+\t  }\n+\tcatch(IOException ioe)\n+\t  {\n+\t    // Error while close, nothing we can do.\n+\t  }\n+      }\n+  }\n+  \n+  /**\n+   * Skips the requested number of bytes in the given InputStream.\n+   * Throws EOFException if not enough bytes could be skipped.\n+   * Negative numbers of bytes to skip are ignored.\n+   */\n+  private static void skipFully(InputStream is, long l) throws IOException\n+  {\n+    while (l > 0)\n+      {\n+        long k = is.skip(l);\n+        if (k <= 0)\n+          throw new EOFException();\n+        l -= k;\n+      }\n+  }\n+  \n+  /**\n+   * Maps a time zone name (with optional GMT offset and daylight time\n+   * zone name) to one of the known time zones.  This method called\n+   * with the result of <code>System.getProperty(\"user.timezone\")</code>\n+   * or <code>getDefaultTimeZoneId()</code>.  Note that giving one of\n+   * the standard tz data names from ftp://elsie.nci.nih.gov/pub/ is\n+   * preferred.  The time zone name can be given as follows:\n+   * <code>(standard zone name)[(GMT offset)[(daylight time zone name)]]</code>\n+   * <p>\n+   * If only a (standard zone name) is given (no numbers in the\n+   * String) then it gets mapped directly to the TimeZone with that\n+   * name, if that fails null is returned.\n+   * <p>\n+   * A GMT offset is the offset to add to the local time to get GMT.\n+   * If a (GMT offset) is included (either in seconds or hours) then\n+   * an attempt is made to find a TimeZone name matching both the name\n+   * and the offset (that doesn't observe daylight time, if the\n+   * timezone observes daylight time then you must include a daylight\n+   * time zone name after the offset), if that fails then a TimeZone\n+   * with the given GMT offset is returned (whether or not the\n+   * TimeZone observes daylight time is ignored), if that also fails\n+   * the GMT TimeZone is returned.\n+   * <p>\n+   * If the String ends with (GMT offset)(daylight time zone name)\n+   * then an attempt is made to find a TimeZone with the given name and\n+   * GMT offset that also observes (the daylight time zone name is not\n+   * currently used in any other way), if that fails a TimeZone with\n+   * the given GMT offset that observes daylight time is returned, if\n+   * that also fails the GMT TimeZone is returned.\n+   * <p>\n+   * Examples: In Chicago, the time zone id could be \"CST6CDT\", but\n+   * the preferred name would be \"America/Chicago\".  In Indianapolis\n+   * (which does not have Daylight Savings Time) the string could be\n+   * \"EST5\", but the preferred name would be \"America/Indianapolis\".\n+   * The standard time zone name for The Netherlands is \"Europe/Amsterdam\",\n+   * but can also be given as \"CET-1CEST\".\n+   */\n+  private static TimeZone getDefaultTimeZone(String sysTimeZoneId)\n+  {\n+    // First find start of GMT offset info and any Daylight zone name.\n+    int startGMToffset = 0;\n+    int sysTimeZoneIdLength = sysTimeZoneId.length();\n+    for (int i = 0; i < sysTimeZoneIdLength && startGMToffset == 0; i++)\n+      {\n+\tchar c = sysTimeZoneId.charAt(i);\n+\tif (c == '+' || c == '-' || Character.isDigit(c))\n+\t  startGMToffset = i;\n+      }\n+    \n+    String tzBasename;\n+    if (startGMToffset == 0)\n+      tzBasename = sysTimeZoneId;\n+    else\n+      tzBasename = sysTimeZoneId.substring (0, startGMToffset);\n+    \n+    int startDaylightZoneName = 0;\n+    for (int i = sysTimeZoneIdLength - 1;\n+\t i >= 0 && !Character.isDigit(sysTimeZoneId.charAt(i)); --i)\n+      startDaylightZoneName = i;\n+    \n+    boolean useDaylightTime = startDaylightZoneName > 0;\n+    \n+    // Integer.parseInt() doesn't handle leading +.\n+    if (sysTimeZoneId.charAt(startGMToffset) == '+')\n+      startGMToffset++;\n+    \n+    int gmtOffset = 0;\n+    if (startGMToffset > 0)\n+      {\n+\tgmtOffset = Integer.parseInt\n+\t  (startDaylightZoneName == 0\n+\t   ? sysTimeZoneId.substring(startGMToffset)\n+\t   : sysTimeZoneId.substring(startGMToffset,\n+\t\t\t\t     startDaylightZoneName));\n+\t\n+\t// Offset could be in hours or seconds.  Convert to millis.\n+\t// The offset is given as the time to add to local time to get GMT\n+\t// we need the time to add to GMT to get localtime.\n+\tif (gmtOffset < 24)\n+\t  gmtOffset *= 60 * 60;\n+\tgmtOffset *= -1000;\n+      }\n+    \n+    // Try to be optimistic and get the timezone that matches the base name.\n+    // If we only have the base name then just accept this timezone.\n+    // Otherwise check the gmtOffset and day light attributes.\n+    TimeZone tz = (TimeZone) timezones().get(tzBasename);\n+    if (tz != null\n+\t&& (tzBasename == sysTimeZoneId\n+\t    || (tz.getRawOffset() == gmtOffset\n+\t\t&& tz.useDaylightTime() == useDaylightTime)))\n+      return tz;\n+    \n+    // Maybe there is one with the daylight zone name?\n+    if (useDaylightTime)\n+      {\n+\tString daylightZoneName;\n+\tdaylightZoneName = sysTimeZoneId.substring(startDaylightZoneName);\n+\tif (!daylightZoneName.equals(tzBasename))\n+\t  {\n+\t    tz = (TimeZone) timezones().get(tzBasename);\n+\t    if (tz != null\n+\t\t&& tz.getRawOffset() == gmtOffset\n+\t\t&& tz.useDaylightTime())\n+\t      return tz;\n+\t  }\n+      }\n+    \n+    // If no match, see if a valid timezone has similar attributes as this\n+    // and then use it instead. We take the first one that looks OKish.\n+    if (startGMToffset > 0)\n+      {\n+\tString[] ids = getAvailableIDs(gmtOffset);\n+\tfor (int i = 0; i < ids.length; i++)\n+\t  {\n+\t    tz = (TimeZone) timezones().get(ids[i]);\n+\t    if (tz.useDaylightTime() == useDaylightTime)\n+\t      return tz;\n+\t  }\n+      }\n+    \n+    return null;\n+  }\n+\n   /**\n    * Gets the time zone offset, for current date, modified in case of \n    * daylight savings.  This is the offset to add to UTC to get the local\n@@ -1140,16 +1542,18 @@ public static String[] getAvailableIDs()\n   /**\n    * Returns the time zone under which the host is running.  This\n    * can be changed with setDefault.\n-   * @return the time zone for this host.\n+   *\n+   * @return A clone of the current default time zone for this host.\n    * @see #setDefault\n    */\n   public static TimeZone getDefault()\n   {\n-    return defaultZone();\n+    return (TimeZone) defaultZone().clone();\n   }\n \n   public static void setDefault(TimeZone zone)\n   {\n+    // Hmmmm. No Security checks?\n     defaultZone0 = zone;\n   }\n "}, {"sha": "c23d9e6555e5fa8ca602b225591187a7167c229e", "filename": "libjava/java/util/natTimeZone.cc", "status": "modified", "additions": 84, "deletions": 109, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42348101742f1257f76247b577489a7c2b8db31b/libjava%2Fjava%2Futil%2FnatTimeZone.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42348101742f1257f76247b577489a7c2b8db31b/libjava%2Fjava%2Futil%2FnatTimeZone.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FnatTimeZone.cc?ref=42348101742f1257f76247b577489a7c2b8db31b", "patch": "@@ -1,6 +1,7 @@\n // natTimeZone.cc -- Native side of TimeZone class.\n \n-/* Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003  Free Software Foundation\n+/* Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004\n+   Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -33,53 +34,105 @@ details.  */\n \n #include <string.h>\n \n-/*\n- * This method returns a time zone string that is used by init_properties\n- * to set the default timezone property 'user.timezone'.  That value is\n- * used by default as a key into the timezone table used by the\n- * java::util::TimeZone class.\n+/**\n+ * This method returns a time zone id string which is in the form\n+ * (standard zone name) or (standard zone name)(GMT offset) or\n+ * (standard zone name)(GMT offset)(daylight time zone name).  The\n+ * GMT offset can be in seconds, or where it is evenly divisible by\n+ * 3600, then it can be in hours.  The offset must be the time to\n+ * add to the local time to get GMT.  If a offset is given and the\n+ * time zone observes daylight saving then the (daylight time zone\n+ * name) must also be given (otherwise it is assumed the time zone\n+ * does not observe any daylight savings).\n+ * <p>\n+ * The result of this method is given to getDefaultTimeZone(String)\n+ * which tries to map the time zone id to a known TimeZone.  See\n+ * that method on how the returned String is mapped to a real\n+ * TimeZone object.\n  */\n-static jstring\n-getSystemTimeZone (void)\n+jstring\n+java::util::TimeZone::getDefaultTimeZoneId ()\n {\n-  struct tm *tim;\n+  struct tm tim;\n+#ifndef HAVE_LOCALTIME_R\n+  struct tm *lt_tim;\n+#endif\n+#ifdef HAVE_TM_ZONE\n+  int month;\n+#endif\n   time_t current_time;\n   long tzoffset;\n   const char *tz1, *tz2;\n   char *tzid;\n \n-  current_time = time(0);\n+  time(&current_time);\n+#ifdef HAVE_LOCALTIME_R\n+  localtime_r(&current_time, &tim);\n+#else\n+  /* Fall back on non-thread safe localtime. */\n+  lt_tim = localtime(&current_time);\n+  memcpy(&tim, lt_tim, sizeof (struct tm));\n+#endif\n+  mktime(&tim);\n+\n+#ifdef HAVE_TM_ZONE\n+  /* We will cycle through the months to make sure we hit dst. */\n+  month = tim.tm_mon;\n+  tz1 = tz2 = NULL;\n+  while (tz1 == NULL || tz2 == NULL)\n+    {\n+      if (tim.tm_isdst > 0)\n+        tz2 = tim.tm_zone;\n+      else if (tz1 == NULL)\n+        {\n+          tz1 = tim.tm_zone;\n+          month = tim.tm_mon;\n+        }\n+\n+      if (tz1 == NULL || tz2 == NULL)\n+        {\n+          tim.tm_mon++;\n+          tim.tm_mon %= 12;\n+        }\n+\n+      if (tim.tm_mon == month && tz2 == NULL)\n+        tz2 = \"\";\n+      else\n+        mktime(&tim);\n+    }\n+  /* We want to make sure the tm struct we use later on is not dst. */\n+  tim.tm_mon = month;\n+  mktime(&tim);\n+#elif defined (HAVE_TZNAME)\n+  /* If dst is never used, tzname[1] is the empty string. */\n+  tzset();\n+  tz1 = tzname[0];\n+  tz2 = tzname[1];\n+#else\n+  /* Some targets have no concept of timezones. Assume GMT without dst. */\n+  tz1 = \"GMT\";\n+  tz2 = \"\";\n+#endif\n \n-  mktime(tim = localtime(&current_time));\n #ifdef STRUCT_TM_HAS_GMTOFF\n-  // tm_gmtoff is secs EAST of UTC.\n-  tzoffset = -(tim->tm_gmtoff) + tim->tm_isdst * 3600L;\n+  /* tm_gmtoff is the number of seconds that you must add to GMT to get\n+     local time, we need the number of seconds to add to the local time\n+     to get GMT. */\n+  tzoffset = -1L * tim.tm_gmtoff;\n #elif HAVE_UNDERSCORE_TIMEZONE\n   tzoffset = _timezone;\n #elif HAVE_TIMEZONE\n-  // timezone is secs WEST of UTC.\n+  /* timezone is secs WEST of UTC. */\n   tzoffset = timezone;\t\n #else\n-  // FIXME: there must be another global if neither tm_gmtoff nor timezone\n-  // is available, esp. if tzname is valid.\n-  // Richard Earnshaw <rearnsha@arm.com> has suggested using difftime to\n-  // calculate between gmtime and localtime (and accounting for possible\n-  // daylight savings time) as an alternative.\n+  /* FIXME: there must be another global if neither tm_gmtoff nor timezone\n+     is available, esp. if tzname is valid.\n+     Richard Earnshaw <rearnsha@arm.com> has suggested using difftime to\n+     calculate between gmtime and localtime (and accounting for possible\n+     daylight savings time) as an alternative. */\n   tzoffset = 0L;\n #endif\n \n-#ifdef HAVE_TM_ZONE\n-  tz1 = tim->tm_zone;\n-  tz2 = \"\";\n-#elif defined (HAVE_TZNAME)\n-  tz1 = tzname[0];\n-  tz2 = strcmp (tzname[0], tzname[1]) ? tzname[1] : \"\";\n-#else\n-  // Some targets have no concept of timezones.\n-  tz1 = \"???\";\n-  tz2 = tz1;\n-#endif\n-\n   if ((tzoffset % 3600) == 0)\n     tzoffset = tzoffset / 3600;\n \n@@ -90,81 +143,3 @@ getSystemTimeZone (void)\n \n   return retval;\n }\n-\n-// Get the System Timezone as reported by the OS.  It should be in\n-// the form PST8PDT so we'll need to parse it and check that it's valid.\n-// FIXME: Using the code from Classpath for generating the System\n-// Timezone IMO is suboptimal because it ignores whether the rules for\n-// DST match up.\n-jstring\n-java::util::TimeZone::getDefaultTimeZoneId ()\n-{\n-  jstring sysTimeZoneId = getSystemTimeZone ();\n-\n-  using namespace java::lang;\n-\n-  // Check if this is a valid timezone.  Make sure the IDs match\n-  // since getTimeZone returns GMT if no match is found.\n-  TimeZone *tz = TimeZone::getTimeZone (sysTimeZoneId);\n-  if (tz->getID ()->equals (sysTimeZoneId))\n-    return sysTimeZoneId;\n-\n-  // Check if the base part of sysTimeZoneId is a valid timezone that\n-  // matches with daylight usage and rawOffset.  Make sure the IDs match\n-  // since getTimeZone returns GMT if no match is found.\n-  // First find start of GMT offset info and any Daylight zone name.\n-  int startGMToffset = 0;\n-  int sysTimeZoneIdLength = sysTimeZoneId->length();\n-  for (int i = 0; i < sysTimeZoneIdLength && startGMToffset == 0; i++)\n-    {\n-      if (Character::isDigit (sysTimeZoneId->charAt (i)))\n-\tstartGMToffset = i;\n-    }\n-\n-  int startDaylightZoneName = 0;\n-  jboolean usesDaylight = false;\n-  for (int i = sysTimeZoneIdLength - 1;\n-       i >= 0 && !Character::isDigit (sysTimeZoneId->charAt (i)); --i)\n-    {\n-      startDaylightZoneName = i;\n-    }\n-  if (startDaylightZoneName > 0)\n-    usesDaylight = true;\n-\n-  int GMToffset\n-    = Integer::parseInt (startDaylightZoneName == 0 ?\n-\t\t\t sysTimeZoneId->substring (startGMToffset) :\n-\t\t\t sysTimeZoneId->substring (startGMToffset,\n-\t\t\t\t\t\t   startDaylightZoneName));\n-\n-  // Offset could be in hours or seconds.  Convert to millis.\n-  if (GMToffset < 24)\n-    GMToffset *= 60 * 60;\n-  GMToffset *= -1000;\n-\n-  jstring tzBasename = sysTimeZoneId->substring (0, startGMToffset);\n-  tz = TimeZone::getTimeZone (tzBasename);\n-  if (tz->getID ()->equals (tzBasename) && tz->getRawOffset () == GMToffset)\n-    {\n-      jboolean tzUsesDaylight = tz->useDaylightTime ();\n-      if (usesDaylight && tzUsesDaylight || !usesDaylight && !tzUsesDaylight)\n-\treturn tzBasename;\n-    }\n-\n-  // If no match, see if a valid timezone has the same attributes as this\n-  // and then use it instead.\n-  jstringArray IDs = TimeZone::getAvailableIDs (GMToffset);\n-  jstring *elts = elements (IDs);\n-  for (int i = 0; i < IDs->length; ++i)\n-    {\n-      // FIXME: The daylight savings rules may not match the rules\n-      // for the desired zone.\n-      jboolean IDusesDaylight =\n-\tTimeZone::getTimeZone (elts[i])->useDaylightTime ();\n-      if (usesDaylight && IDusesDaylight || !usesDaylight && !IDusesDaylight)\n-\treturn elts[i];\n-    }\n-\n-  // If all else fails, return null.\n-  return NULL;\n-}"}]}