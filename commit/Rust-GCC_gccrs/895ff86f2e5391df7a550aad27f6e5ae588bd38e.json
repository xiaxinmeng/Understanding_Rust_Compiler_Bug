{"sha": "895ff86f2e5391df7a550aad27f6e5ae588bd38e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODk1ZmY4NmYyZTUzOTFkZjdhNTUwYWFkMjdmNmU1YWU1ODhiZDM4ZQ==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2015-01-30T22:22:58Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2015-01-30T22:22:58Z"}, "message": "re PR rtl-optimization/64688 (internal compiler error: Max. number of generated reload insns per insn is achieved (90))\n\n2015-01-30  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR target/64688\n\t* lra-constraints.c (original_subreg_reg_mode): New.\n\t(simplify_operand_subreg): Try to simplify subreg of const.  Use\n\toriginal_subreg_reg_mode for it.\n\t(swap_operands): Update original_subreg_reg_mode.\n\t(curr_insn_transform): Set up original_subreg_reg_mode.\n\n2015-01-30  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR target/64688\n\t* g++.dg/pr64688-2.C: New.\n\nFrom-SVN: r220297", "tree": {"sha": "154cb926be6887899fb3f09d2ae3dd113e663dd5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/154cb926be6887899fb3f09d2ae3dd113e663dd5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/895ff86f2e5391df7a550aad27f6e5ae588bd38e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/895ff86f2e5391df7a550aad27f6e5ae588bd38e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/895ff86f2e5391df7a550aad27f6e5ae588bd38e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/895ff86f2e5391df7a550aad27f6e5ae588bd38e/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1c9cc1d30401ff075f1195f648f5223d233349f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c9cc1d30401ff075f1195f648f5223d233349f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c9cc1d30401ff075f1195f648f5223d233349f6"}], "stats": {"total": 201, "additions": 189, "deletions": 12}, "files": [{"sha": "0e1e8bb2d8ba1fe8124719b2d57ba22c74bae650", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/895ff86f2e5391df7a550aad27f6e5ae588bd38e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/895ff86f2e5391df7a550aad27f6e5ae588bd38e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=895ff86f2e5391df7a550aad27f6e5ae588bd38e", "patch": "@@ -1,3 +1,12 @@\n+2015-01-30  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR target/64688\n+\t* lra-constraints.c (original_subreg_reg_mode): New.\n+\t(simplify_operand_subreg): Try to simplify subreg of const.  Use\n+\toriginal_subreg_reg_mode for it.\n+\t(swap_operands): Update original_subreg_reg_mode.\n+\t(curr_insn_transform): Set up original_subreg_reg_mode.\n+\n 2015-01-30  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tPR target/64617"}, {"sha": "827c453b0fb111c866f79386f6f8b98ad00275e6", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 39, "deletions": 12, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/895ff86f2e5391df7a550aad27f6e5ae588bd38e/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/895ff86f2e5391df7a550aad27f6e5ae588bd38e/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=895ff86f2e5391df7a550aad27f6e5ae588bd38e", "patch": "@@ -170,6 +170,10 @@ static basic_block curr_bb;\n static lra_insn_recog_data_t curr_id;\n static struct lra_static_insn_data *curr_static_id;\n static machine_mode curr_operand_mode[MAX_RECOG_OPERANDS];\n+/* Mode of the register substituted by its equivalence with VOIDmode\n+   (e.g. constant) and whose subreg is given operand of the current\n+   insn.  VOIDmode in all other cases.  */\n+static machine_mode original_subreg_reg_mode[MAX_RECOG_OPERANDS];\n \n \f\n \n@@ -1382,13 +1386,13 @@ static int valid_address_p (machine_mode mode, rtx addr, addr_space_t as);\n \n /* Make reloads for subreg in operand NOP with internal subreg mode\n    REG_MODE, add new reloads for further processing.  Return true if\n-   any reload was generated.  */\n+   any change was done.  */\n static bool\n simplify_operand_subreg (int nop, machine_mode reg_mode)\n {\n   int hard_regno;\n   rtx_insn *before, *after;\n-  machine_mode mode;\n+  machine_mode mode, innermode;\n   rtx reg, new_reg;\n   rtx operand = *curr_id->operand_loc[nop];\n   enum reg_class regclass;\n@@ -1401,6 +1405,7 @@ simplify_operand_subreg (int nop, machine_mode reg_mode)\n \n   mode = GET_MODE (operand);\n   reg = SUBREG_REG (operand);\n+  innermode = GET_MODE (reg);\n   type = curr_static_id->operand[nop].type;\n   /* If we change address for paradoxical subreg of memory, the\n      address might violate the necessary alignment or the access might\n@@ -1419,7 +1424,7 @@ simplify_operand_subreg (int nop, machine_mode reg_mode)\n       alter_subreg (curr_id->operand_loc[nop], false);\n       subst = *curr_id->operand_loc[nop];\n       lra_assert (MEM_P (subst));\n-      if (! valid_address_p (GET_MODE (reg), XEXP (reg, 0),\n+      if (! valid_address_p (innermode, XEXP (reg, 0),\n \t\t\t     MEM_ADDR_SPACE (reg))\n \t  || valid_address_p (GET_MODE (subst), XEXP (subst, 0),\n \t\t\t      MEM_ADDR_SPACE (subst)))\n@@ -1434,6 +1439,20 @@ simplify_operand_subreg (int nop, machine_mode reg_mode)\n       alter_subreg (curr_id->operand_loc[nop], false);\n       return true;\n     }\n+  else if (CONSTANT_P (reg))\n+    {\n+      /* Try to simplify subreg of constant.  It is usually result of\n+\t equivalence substitution.  */\n+      if (innermode == VOIDmode\n+\t  && (innermode = original_subreg_reg_mode[nop]) == VOIDmode)\n+\tinnermode = curr_static_id->operand[nop].mode;\n+      if ((new_reg = simplify_subreg (mode, reg, innermode,\n+\t\t\t\t      SUBREG_BYTE (operand))) != NULL_RTX)\n+\t{\n+\t  *curr_id->operand_loc[nop] = new_reg;\n+\t  return true;\n+\t}\n+    }\n   /* Put constant into memory when we have mixed modes.  It generates\n      a better code in most cases as it does not need a secondary\n      reload memory.  It also prevents LRA looping when LRA is using\n@@ -1453,9 +1472,9 @@ simplify_operand_subreg (int nop, machine_mode reg_mode)\n        && (hard_regno = lra_get_regno_hard_regno (REGNO (reg))) >= 0\n        /* Don't reload paradoxical subregs because we could be looping\n \t  having repeatedly final regno out of hard regs range.  */\n-       && (hard_regno_nregs[hard_regno][GET_MODE (reg)]\n+       && (hard_regno_nregs[hard_regno][innermode]\n \t   >= hard_regno_nregs[hard_regno][mode])\n-       && simplify_subreg_regno (hard_regno, GET_MODE (reg),\n+       && simplify_subreg_regno (hard_regno, innermode,\n \t\t\t\t SUBREG_BYTE (operand), mode) < 0\n        /* Don't reload subreg for matching reload.  It is actually\n \t  valid subreg in LRA.  */\n@@ -1481,7 +1500,7 @@ simplify_operand_subreg (int nop, machine_mode reg_mode)\n \t  bitmap_set_bit (&lra_subreg_reload_pseudos, REGNO (new_reg));\n \n \t  insert_before = (type != OP_OUT\n-\t\t\t   || GET_MODE_SIZE (GET_MODE (reg)) > GET_MODE_SIZE (mode));\n+\t\t\t   || GET_MODE_SIZE (innermode) > GET_MODE_SIZE (mode));\n \t  insert_after = (type != OP_IN);\n \t  insert_move_for_subreg (insert_before ? &before : NULL,\n \t\t\t\t  insert_after ? &after : NULL,\n@@ -1524,7 +1543,7 @@ simplify_operand_subreg (int nop, machine_mode reg_mode)\n   else if (REG_P (reg)\n \t   && REGNO (reg) >= FIRST_PSEUDO_REGISTER\n \t   && (hard_regno = lra_get_regno_hard_regno (REGNO (reg))) >= 0\n-\t   && (hard_regno_nregs[hard_regno][GET_MODE (reg)]\n+\t   && (hard_regno_nregs[hard_regno][innermode]\n \t       < hard_regno_nregs[hard_regno][mode])\n \t   && (regclass = lra_get_allocno_class (REGNO (reg)))\n \t   && (type != OP_IN\n@@ -1542,7 +1561,7 @@ simplify_operand_subreg (int nop, machine_mode reg_mode)\n \t  bool insert_before, insert_after;\n \n \t  PUT_MODE (new_reg, mode);\n-          subreg = simplify_gen_subreg (GET_MODE (reg), new_reg, mode, 0);\n+          subreg = simplify_gen_subreg (innermode, new_reg, mode, 0);\n \t  bitmap_set_bit (&lra_subreg_reload_pseudos, REGNO (new_reg));\n \n \t  insert_before = (type != OP_OUT);\n@@ -3286,6 +3305,9 @@ swap_operands (int nop)\n   machine_mode mode = curr_operand_mode[nop];\n   curr_operand_mode[nop] = curr_operand_mode[nop + 1];\n   curr_operand_mode[nop + 1] = mode;\n+  mode = original_subreg_reg_mode[nop];\n+  original_subreg_reg_mode[nop] = original_subreg_reg_mode[nop + 1];\n+  original_subreg_reg_mode[nop + 1] = mode;\n   rtx x = *curr_id->operand_loc[nop];\n   *curr_id->operand_loc[nop] = *curr_id->operand_loc[nop + 1];\n   *curr_id->operand_loc[nop + 1] = x;\n@@ -3389,21 +3411,26 @@ curr_insn_transform (bool check_only_p)\n \tif (GET_CODE (old) == SUBREG)\n \t  old = SUBREG_REG (old);\n \tsubst = get_equiv_with_elimination (old, curr_insn);\n+\toriginal_subreg_reg_mode[i] = VOIDmode;\n \tif (subst != old)\n \t  {\n \t    subst = copy_rtx (subst);\n \t    lra_assert (REG_P (old));\n-\t    if (GET_CODE (op) == SUBREG)\n-\t      SUBREG_REG (op) = subst;\n-\t    else\n+\t    if (GET_CODE (op) != SUBREG)\n \t      *curr_id->operand_loc[i] = subst;\n+\t    else\n+\t      {\n+\t\tSUBREG_REG (op) = subst;\n+\t\tif (GET_MODE (subst) == VOIDmode)\n+\t\t  original_subreg_reg_mode[i] = GET_MODE (old);\n+\t      }\n \t    if (lra_dump_file != NULL)\n \t      {\n \t\tfprintf (lra_dump_file,\n \t\t\t \"Changing pseudo %d in operand %i of insn %u on equiv \",\n \t\t\t REGNO (old), i, INSN_UID (curr_insn));\n \t\tdump_value_slim (lra_dump_file, subst, 1);\n-\t      fprintf (lra_dump_file, \"\\n\");\n+\t\tfprintf (lra_dump_file, \"\\n\");\n \t      }\n \t    op_change_p = change_p = true;\n \t  }"}, {"sha": "b7f46e4581cbc9acd1a1d35e2080add553f96bf0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/895ff86f2e5391df7a550aad27f6e5ae588bd38e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/895ff86f2e5391df7a550aad27f6e5ae588bd38e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=895ff86f2e5391df7a550aad27f6e5ae588bd38e", "patch": "@@ -1,3 +1,8 @@\n+2015-01-30  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR target/64688\n+\t* g++.dg/pr64688-2.C: New.\n+\n 2015-01-30  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* gcc.target/i386/fuse-caller-save-rec.c: Require nonpic target."}, {"sha": "c4a22b80760a5d3d75bcc2fd7db08b037545aa60", "filename": "gcc/testsuite/g++.dg/pr64688-2.C", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/895ff86f2e5391df7a550aad27f6e5ae588bd38e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr64688-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/895ff86f2e5391df7a550aad27f6e5ae588bd38e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr64688-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr64688-2.C?ref=895ff86f2e5391df7a550aad27f6e5ae588bd38e", "patch": "@@ -0,0 +1,136 @@\n+// { dg-do compile { target i?86-*-* x86_64-*-* } }\n+// { dg-options \"-std=c++11 -O3 -march=westmere\" }\n+\n+template <int> struct int_ {};\n+template <typename> struct add_const { typedef int type; };\n+template <typename> struct add_reference { typedef int type; };\n+template <typename T> struct next { typedef typename T::next type; };\n+template <typename> struct size_impl;\n+template <typename T> struct msvc_eti_base : T {};\n+template <int N> struct long_ {\n+  static const int value = N;\n+  typedef long_<N + 1> next;\n+};\n+template <typename Sequence>\n+struct size : msvc_eti_base<typename size_impl<\n+typename Sequence::tag>::template apply<Sequence>> {};\n+template <typename Base> struct v_item : Base {\n+  typedef typename next<typename Base::size>::type size;\n+};\n+template <typename = int> struct vector0 {\n+  typedef int tag;\n+  typedef long_<0> size;\n+};\n+template <> struct size_impl<int> {\n+  template <typename Vector> struct apply : Vector::size {};\n+};\n+template <typename> struct vector3 : v_item<v_item<v_item<vector0<>>>> {};\n+template <typename> struct layout { typedef vector3<int> color_space_t; };\n+template <typename> struct kth_element_const_reference_type;\n+template <typename> struct iterator_adaptor_get_base;\n+template <typename, typename, int> struct homogeneous_color_base;\n+template <typename> struct element_const_reference_type;\n+template <typename Element, typename Layout>\n+  struct homogeneous_color_base<Element, Layout, 3> {\n+  Element _v0, _v1, _v2;\n+  typename element_const_reference_type<homogeneous_color_base>::type\n+    at(int_<0>) {\n+    return _v0;\n+  }\n+  typename element_const_reference_type<homogeneous_color_base>::type\n+    at(int_<1>) {\n+    return _v1;\n+  }\n+  typename element_const_reference_type<homogeneous_color_base>::type\n+    at(int_<2>) {\n+    return _v2;\n+  }\n+};\n+template <typename Element, typename Layout, int K1>\n+  struct kth_element_const_reference_type<\n+  homogeneous_color_base<Element, Layout, K1>>\n+  : add_reference<typename add_const<Element>::type> {};\n+template <int K, typename E, typename L, int N>\n+  typename add_reference<typename add_const<E>::type>::type\n+  at_c(homogeneous_color_base<E, L, N> p1) {\n+  return p1.at(int_<K>());\n+}\n+template <typename> class memory_based_step_iterator;\n+template <typename> class memory_based_2d_locator;\n+template <typename> class image_view;\n+template <typename, typename> struct pixel;\n+struct iterator_type_from_pixel {\n+  typedef pixel<unsigned char, layout<vector3<int>>> *type;\n+};\n+template <typename XIterator> struct type_from_x_iterator {\n+    typedef image_view<\n+    memory_based_2d_locator<memory_based_step_iterator<XIterator>>> view_t;\n+};\n+template <typename>\n+struct element_const_reference_type\n+: kth_element_const_reference_type<\n+homogeneous_color_base<unsigned, layout<int>, 3>> {};\n+template <typename, typename>\n+  struct pixel : homogeneous_color_base<unsigned char, layout<int>,\n+  size<layout<int>::color_space_t>::value> {\n+};\n+template <typename Iterator>\n+struct iterator_adaptor_get_base<memory_based_step_iterator<Iterator>> {\n+  typedef Iterator type;\n+};\n+template <typename> class memory_based_2d_locator {\n+ public:\n+    typedef iterator_adaptor_get_base<memory_based_step_iterator<\n+      pixel<unsigned, layout<vector3<int>>> *>>::type x_iterator;\n+};\n+template <typename> class image_view {\n+ public:\n+  typedef memory_based_2d_locator<int>::x_iterator x_iterator;\n+  x_iterator row_begin___trans_tmp_2;\n+  x_iterator row_begin(int) { return row_begin___trans_tmp_2; }\n+};\n+template <typename, bool, typename = int> class image {\n+ public:\n+ typedef type_from_x_iterator<iterator_type_from_pixel::type>::view_t view_t;\n+ image(int);\n+};\n+template <typename Pixel, bool IsPlanar, typename Alloc>\n+  typename image<Pixel, 0>::view_t view(image<Pixel, IsPlanar, Alloc>);\n+template <typename Op> void measure_time(Op p1) {\n+  for (;;)\n+    p1();\n+}\n+template <typename, typename> struct fill_nongil_t;\n+template <typename T, typename P>\n+  struct fill_nongil_t<\n+      image_view<memory_based_2d_locator<\n+  memory_based_step_iterator<pixel<T, layout<vector3<int>>> *>>>,\n+  P> {\n+    typedef image_view<memory_based_2d_locator<\n+      memory_based_step_iterator<pixel<T, layout<vector3<int>>> *>>> View;\n+    View _v;\n+    P _p;\n+ fill_nongil_t(View p1, P) : _v(p1) {}\n+    void operator()() {\n+      T *first = (T *)_v.row_begin(0);\n+      T last;\n+      while (first != &last) {\n+\tfirst[0] = at_c<0>(_p);\n+\tfirst[1] = at_c<1>(_p);\n+\tfirst[2] = at_c<2>(_p);\n+\tfirst += 3;\n+      }\n+    }\n+};\n+template <typename, typename> void test_fill(int) {\n+  image<int, 0>::view_t __trans_tmp_1;\n+  image<int, 0> im(0);\n+  __trans_tmp_1 = view(im);\n+  measure_time(fill_nongil_t<\n+\t             image_view<memory_based_2d_locator<memory_based_step_iterator<\n+\t       pixel<unsigned char, layout<vector3<int>>> *>>>,\n+\t       pixel<unsigned, int>>(__trans_tmp_1, pixel<unsigned, int>()));\n+}\n+void performance_testtest_method() {\n+  test_fill<image_view<int>, pixel<unsigned, int>>(0);\n+}"}]}