{"sha": "45095d73f1ca5bb8a4954fdbf62af8351bbc52e1", "node_id": "C_kwDOANBUbNoAKDQ1MDk1ZDczZjFjYTViYjhhNDk1NGZkYmY2MmFmODM1MWJiYzUyZTE", "commit": {"author": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-08-08T08:09:42Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-08-10T06:28:42Z"}, "message": "compile: Move and rename `SimpleIntrinsics` -> `BuiltinsContext`\n\nThis will allow us to use the class for more than just math builtins", "tree": {"sha": "797386f0ee59b248a06f0149238c96bb8051215f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/797386f0ee59b248a06f0149238c96bb8051215f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/45095d73f1ca5bb8a4954fdbf62af8351bbc52e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45095d73f1ca5bb8a4954fdbf62af8351bbc52e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45095d73f1ca5bb8a4954fdbf62af8351bbc52e1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45095d73f1ca5bb8a4954fdbf62af8351bbc52e1/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8749b66879f3ef78182d7712e5da981cc55f747a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8749b66879f3ef78182d7712e5da981cc55f747a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8749b66879f3ef78182d7712e5da981cc55f747a"}], "stats": {"total": 339, "additions": 185, "deletions": 154}, "files": [{"sha": "13c16d15723f0ea27a1f2d562100956434595e0d", "filename": "gcc/rust/backend/rust-builtins.h", "status": "added", "additions": 181, "deletions": 0, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45095d73f1ca5bb8a4954fdbf62af8351bbc52e1/gcc%2Frust%2Fbackend%2Frust-builtins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45095d73f1ca5bb8a4954fdbf62af8351bbc52e1/gcc%2Frust%2Fbackend%2Frust-builtins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-builtins.h?ref=45095d73f1ca5bb8a4954fdbf62af8351bbc52e1", "patch": "@@ -0,0 +1,181 @@\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_BUILTINS_H\n+#define RUST_BUILTINS_H\n+\n+#include \"rust-system.h\"\n+#include \"tree.h\"\n+#include \"langhooks.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+// https://github.com/rust-lang/rust/blob/master/library/core/src/intrinsics.rs\n+// https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_llvm/src/intrinsic.rs\n+// https://github.com/Rust-GCC/gccrs/issues/658\n+//\n+//   let llvm_name = match name {\n+//     sym::sqrtf32 => \"llvm.sqrt.f32\",\n+//     sym::sqrtf64 => \"llvm.sqrt.f64\",\n+//     sym::powif32 => \"llvm.powi.f32\",\n+//     sym::powif64 => \"llvm.powi.f64\",\n+//     sym::sinf32 => \"llvm.sin.f32\",\n+//     sym::sinf64 => \"llvm.sin.f64\",\n+//     sym::cosf32 => \"llvm.cos.f32\",\n+//     sym::cosf64 => \"llvm.cos.f64\",\n+//     sym::powf32 => \"llvm.pow.f32\",\n+//     sym::powf64 => \"llvm.pow.f64\",\n+//     sym::expf32 => \"llvm.exp.f32\",\n+//     sym::expf64 => \"llvm.exp.f64\",\n+//     sym::exp2f32 => \"llvm.exp2.f32\",\n+//     sym::exp2f64 => \"llvm.exp2.f64\",\n+//     sym::logf32 => \"llvm.log.f32\",\n+//     sym::logf64 => \"llvm.log.f64\",\n+//     sym::log10f32 => \"llvm.log10.f32\",\n+//     sym::log10f64 => \"llvm.log10.f64\",\n+//     sym::log2f32 => \"llvm.log2.f32\",\n+//     sym::log2f64 => \"llvm.log2.f64\",\n+//     sym::fmaf32 => \"llvm.fma.f32\",\n+//     sym::fmaf64 => \"llvm.fma.f64\",\n+//     sym::fabsf32 => \"llvm.fabs.f32\",\n+//     sym::fabsf64 => \"llvm.fabs.f64\",\n+//     sym::minnumf32 => \"llvm.minnum.f32\",\n+//     sym::minnumf64 => \"llvm.minnum.f64\",\n+//     sym::maxnumf32 => \"llvm.maxnum.f32\",\n+//     sym::maxnumf64 => \"llvm.maxnum.f64\",\n+//     sym::copysignf32 => \"llvm.copysign.f32\",\n+//     sym::copysignf64 => \"llvm.copysign.f64\",\n+//     sym::floorf32 => \"llvm.floor.f32\",\n+//     sym::floorf64 => \"llvm.floor.f64\",\n+//     sym::ceilf32 => \"llvm.ceil.f32\",\n+//     sym::ceilf64 => \"llvm.ceil.f64\",\n+//     sym::truncf32 => \"llvm.trunc.f32\",\n+//     sym::truncf64 => \"llvm.trunc.f64\",\n+//     sym::rintf32 => \"llvm.rint.f32\",\n+//     sym::rintf64 => \"llvm.rint.f64\",\n+//     sym::nearbyintf32 => \"llvm.nearbyint.f32\",\n+//     sym::nearbyintf64 => \"llvm.nearbyint.f64\",\n+//     sym::roundf32 => \"llvm.round.f32\",\n+//     sym::roundf64 => \"llvm.round.f64\",\n+//     _ => return None,\n+// };\n+// Some(cx.get_intrinsic(&llvm_name))\n+class BuiltinsContext\n+{\n+public:\n+  static BuiltinsContext &get ()\n+  {\n+    static BuiltinsContext instance;\n+    return instance;\n+  }\n+\n+  bool lookup_simple_builtin (const std::string &name, tree *builtin)\n+  {\n+    auto it = rust_intrinsic_to_gcc_builtin.find (name);\n+    if (it == rust_intrinsic_to_gcc_builtin.end ())\n+      return false;\n+\n+    return lookup_gcc_builtin (it->second, builtin);\n+  }\n+\n+private:\n+  static const int builtin_const = 1 << 0;\n+  static const int builtin_noreturn = 1 << 1;\n+  static const int builtin_novops = 1 << 2;\n+\n+  BuiltinsContext () { setup (); }\n+\n+  void setup ()\n+  {\n+    tree math_function_type_f32\n+      = build_function_type_list (float_type_node, float_type_node, NULL_TREE);\n+\n+    define_builtin (\"sinf32\", BUILT_IN_SINF, \"__builtin_sinf\", \"sinf\",\n+\t\t    math_function_type_f32, builtin_const);\n+\n+    define_builtin (\"sqrtf32\", BUILT_IN_SQRTF, \"__builtin_sqrtf\", \"sqrtf\",\n+\t\t    math_function_type_f32, builtin_const);\n+\n+    define_builtin (\"unreachable\", BUILT_IN_UNREACHABLE,\n+\t\t    \"__builtin_unreachable\", NULL,\n+\t\t    build_function_type (void_type_node, void_list_node),\n+\t\t    builtin_const | builtin_noreturn);\n+\n+    define_builtin (\"abort\", BUILT_IN_ABORT, \"__builtin_abort\", \"abort\",\n+\t\t    build_function_type (void_type_node, void_list_node),\n+\t\t    builtin_const | builtin_noreturn);\n+\n+    define_builtin (\"breakpoint\", BUILT_IN_TRAP, \"__builtin_trap\", \"breakpoint\",\n+\t\t    build_function_type (void_type_node, void_list_node),\n+\t\t    builtin_const | builtin_noreturn);\n+  }\n+\n+  // Define a builtin function.  BCODE is the builtin function code\n+  // defined by builtins.def.  NAME is the name of the builtin function.\n+  // LIBNAME is the name of the corresponding library function, and is\n+  // NULL if there isn't one.  FNTYPE is the type of the function.\n+  // CONST_P is true if the function has the const attribute.\n+  // NORETURN_P is true if the function has the noreturn attribute.\n+  void define_builtin (const std::string rust_name, built_in_function bcode,\n+\t\t       const char *name, const char *libname, tree fntype,\n+\t\t       int flags)\n+  {\n+    tree decl = add_builtin_function (name, fntype, bcode, BUILT_IN_NORMAL,\n+\t\t\t\t      libname, NULL_TREE);\n+    if ((flags & builtin_const) != 0)\n+      TREE_READONLY (decl) = 1;\n+    if ((flags & builtin_noreturn) != 0)\n+      TREE_THIS_VOLATILE (decl) = 1;\n+    if ((flags & builtin_novops) != 0)\n+      DECL_IS_NOVOPS (decl) = 1;\n+    set_builtin_decl (bcode, decl, true);\n+    this->builtin_functions_[name] = decl;\n+    if (libname != NULL)\n+      {\n+\tdecl = add_builtin_function (libname, fntype, bcode, BUILT_IN_NORMAL,\n+\t\t\t\t     NULL, NULL_TREE);\n+\tif ((flags & builtin_const) != 0)\n+\t  TREE_READONLY (decl) = 1;\n+\tif ((flags & builtin_noreturn) != 0)\n+\t  TREE_THIS_VOLATILE (decl) = 1;\n+\tif ((flags & builtin_novops) != 0)\n+\t  DECL_IS_NOVOPS (decl) = 1;\n+\tthis->builtin_functions_[libname] = decl;\n+      }\n+\n+    rust_intrinsic_to_gcc_builtin[rust_name] = name;\n+  }\n+\n+  bool lookup_gcc_builtin (const std::string &name, tree *builtin)\n+  {\n+    auto it = builtin_functions_.find (name);\n+    if (it == builtin_functions_.end ())\n+      return false;\n+\n+    *builtin = it->second;\n+    return true;\n+  }\n+\n+  // A mapping of the GCC built-ins exposed to GCC Rust.\n+  std::map<std::string, tree> builtin_functions_;\n+  std::map<std::string, std::string> rust_intrinsic_to_gcc_builtin;\n+};\n+\n+} // namespace Compile\n+} // namespace Rust\n+\n+#endif // RUST_BUILTINS_H"}, {"sha": "ebf1ed61f55dcebb27e82e77268486fbd3c50624", "filename": "gcc/rust/backend/rust-compile-intrinsic.cc", "status": "modified", "additions": 3, "deletions": 154, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45095d73f1ca5bb8a4954fdbf62af8351bbc52e1/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45095d73f1ca5bb8a4954fdbf62af8351bbc52e1/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.cc?ref=45095d73f1ca5bb8a4954fdbf62af8351bbc52e1", "patch": "@@ -20,6 +20,7 @@\n #include \"rust-compile-context.h\"\n #include \"rust-compile-type.h\"\n #include \"rust-compile-fnparam.h\"\n+#include \"rust-builtins.h\"\n #include \"rust-diagnostics.h\"\n #include \"rust-location.h\"\n #include \"rust-tree.h\"\n@@ -28,157 +29,6 @@\n namespace Rust {\n namespace Compile {\n \n-// https://github.com/rust-lang/rust/blob/master/library/core/src/intrinsics.rs\n-// https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_llvm/src/intrinsic.rs\n-// https://github.com/Rust-GCC/gccrs/issues/658\n-//\n-//   let llvm_name = match name {\n-//     sym::sqrtf32 => \"llvm.sqrt.f32\",\n-//     sym::sqrtf64 => \"llvm.sqrt.f64\",\n-//     sym::powif32 => \"llvm.powi.f32\",\n-//     sym::powif64 => \"llvm.powi.f64\",\n-//     sym::sinf32 => \"llvm.sin.f32\",\n-//     sym::sinf64 => \"llvm.sin.f64\",\n-//     sym::cosf32 => \"llvm.cos.f32\",\n-//     sym::cosf64 => \"llvm.cos.f64\",\n-//     sym::powf32 => \"llvm.pow.f32\",\n-//     sym::powf64 => \"llvm.pow.f64\",\n-//     sym::expf32 => \"llvm.exp.f32\",\n-//     sym::expf64 => \"llvm.exp.f64\",\n-//     sym::exp2f32 => \"llvm.exp2.f32\",\n-//     sym::exp2f64 => \"llvm.exp2.f64\",\n-//     sym::logf32 => \"llvm.log.f32\",\n-//     sym::logf64 => \"llvm.log.f64\",\n-//     sym::log10f32 => \"llvm.log10.f32\",\n-//     sym::log10f64 => \"llvm.log10.f64\",\n-//     sym::log2f32 => \"llvm.log2.f32\",\n-//     sym::log2f64 => \"llvm.log2.f64\",\n-//     sym::fmaf32 => \"llvm.fma.f32\",\n-//     sym::fmaf64 => \"llvm.fma.f64\",\n-//     sym::fabsf32 => \"llvm.fabs.f32\",\n-//     sym::fabsf64 => \"llvm.fabs.f64\",\n-//     sym::minnumf32 => \"llvm.minnum.f32\",\n-//     sym::minnumf64 => \"llvm.minnum.f64\",\n-//     sym::maxnumf32 => \"llvm.maxnum.f32\",\n-//     sym::maxnumf64 => \"llvm.maxnum.f64\",\n-//     sym::copysignf32 => \"llvm.copysign.f32\",\n-//     sym::copysignf64 => \"llvm.copysign.f64\",\n-//     sym::floorf32 => \"llvm.floor.f32\",\n-//     sym::floorf64 => \"llvm.floor.f64\",\n-//     sym::ceilf32 => \"llvm.ceil.f32\",\n-//     sym::ceilf64 => \"llvm.ceil.f64\",\n-//     sym::truncf32 => \"llvm.trunc.f32\",\n-//     sym::truncf64 => \"llvm.trunc.f64\",\n-//     sym::rintf32 => \"llvm.rint.f32\",\n-//     sym::rintf64 => \"llvm.rint.f64\",\n-//     sym::nearbyintf32 => \"llvm.nearbyint.f32\",\n-//     sym::nearbyintf64 => \"llvm.nearbyint.f64\",\n-//     sym::roundf32 => \"llvm.round.f32\",\n-//     sym::roundf64 => \"llvm.round.f64\",\n-//     _ => return None,\n-// };\n-// Some(cx.get_intrinsic(&llvm_name))\n-class SimpleIntrinsics\n-{\n-public:\n-  static SimpleIntrinsics &get ()\n-  {\n-    static SimpleIntrinsics instance;\n-    return instance;\n-  }\n-\n-  bool lookup_simple_builtin (const std::string &name, tree *builtin)\n-  {\n-    auto it = rust_intrinsic_to_gcc_builtin.find (name);\n-    if (it == rust_intrinsic_to_gcc_builtin.end ())\n-      return false;\n-\n-    return lookup_gcc_builtin (it->second, builtin);\n-  }\n-\n-private:\n-  static const int builtin_const = 1 << 0;\n-  static const int builtin_noreturn = 1 << 1;\n-  static const int builtin_novops = 1 << 2;\n-\n-  SimpleIntrinsics () { setup (); }\n-\n-  void setup ()\n-  {\n-    tree math_function_type_f32\n-      = build_function_type_list (float_type_node, float_type_node, NULL_TREE);\n-\n-    define_builtin (\"sinf32\", BUILT_IN_SINF, \"__builtin_sinf\", \"sinf\",\n-\t\t    math_function_type_f32, builtin_const);\n-\n-    define_builtin (\"sqrtf32\", BUILT_IN_SQRTF, \"__builtin_sqrtf\", \"sqrtf\",\n-\t\t    math_function_type_f32, builtin_const);\n-\n-    define_builtin (\"unreachable\", BUILT_IN_UNREACHABLE,\n-\t\t    \"__builtin_unreachable\", NULL,\n-\t\t    build_function_type (void_type_node, void_list_node),\n-\t\t    builtin_const | builtin_noreturn);\n-\n-    define_builtin (\"abort\", BUILT_IN_ABORT, \"__builtin_abort\", \"abort\",\n-\t\t    build_function_type (void_type_node, void_list_node),\n-\t\t    builtin_const | builtin_noreturn);\n-\n-    define_builtin (\"breakpoint\", BUILT_IN_TRAP, \"__builtin_trap\", \"breakpoint\",\n-\t\t    build_function_type (void_type_node, void_list_node),\n-\t\t    builtin_const | builtin_noreturn);\n-  }\n-\n-  // Define a builtin function.  BCODE is the builtin function code\n-  // defined by builtins.def.  NAME is the name of the builtin function.\n-  // LIBNAME is the name of the corresponding library function, and is\n-  // NULL if there isn't one.  FNTYPE is the type of the function.\n-  // CONST_P is true if the function has the const attribute.\n-  // NORETURN_P is true if the function has the noreturn attribute.\n-  void define_builtin (const std::string rust_name, built_in_function bcode,\n-\t\t       const char *name, const char *libname, tree fntype,\n-\t\t       int flags)\n-  {\n-    tree decl = add_builtin_function (name, fntype, bcode, BUILT_IN_NORMAL,\n-\t\t\t\t      libname, NULL_TREE);\n-    if ((flags & builtin_const) != 0)\n-      TREE_READONLY (decl) = 1;\n-    if ((flags & builtin_noreturn) != 0)\n-      TREE_THIS_VOLATILE (decl) = 1;\n-    if ((flags & builtin_novops) != 0)\n-      DECL_IS_NOVOPS (decl) = 1;\n-    set_builtin_decl (bcode, decl, true);\n-    this->builtin_functions_[name] = decl;\n-    if (libname != NULL)\n-      {\n-\tdecl = add_builtin_function (libname, fntype, bcode, BUILT_IN_NORMAL,\n-\t\t\t\t     NULL, NULL_TREE);\n-\tif ((flags & builtin_const) != 0)\n-\t  TREE_READONLY (decl) = 1;\n-\tif ((flags & builtin_noreturn) != 0)\n-\t  TREE_THIS_VOLATILE (decl) = 1;\n-\tif ((flags & builtin_novops) != 0)\n-\t  DECL_IS_NOVOPS (decl) = 1;\n-\tthis->builtin_functions_[libname] = decl;\n-      }\n-\n-    rust_intrinsic_to_gcc_builtin[rust_name] = name;\n-  }\n-\n-  bool lookup_gcc_builtin (const std::string &name, tree *builtin)\n-  {\n-    auto it = builtin_functions_.find (name);\n-    if (it == builtin_functions_.end ())\n-      return false;\n-\n-    *builtin = it->second;\n-    return true;\n-  }\n-\n-  // A mapping of the GCC built-ins exposed to GCC Rust.\n-  std::map<std::string, tree> builtin_functions_;\n-  std::map<std::string, std::string> rust_intrinsic_to_gcc_builtin;\n-};\n-\n static tree\n offset_intrinsic_handler (Context *ctx, TyTy::BaseType *fntype);\n static tree\n@@ -214,9 +64,8 @@ Intrinsics::compile (TyTy::FnType *fntype)\n   rust_assert (fntype->get_abi () == ABI::INTRINSIC);\n \n   tree builtin = error_mark_node;\n-  SimpleIntrinsics &simple_intrinsics = SimpleIntrinsics::get ();\n-  if (simple_intrinsics.lookup_simple_builtin (fntype->get_identifier (),\n-\t\t\t\t\t       &builtin))\n+  BuiltinsContext &builtin_ctx = BuiltinsContext::get ();\n+  if (builtin_ctx.lookup_simple_builtin (fntype->get_identifier (), &builtin))\n     return builtin;\n \n   // is it an generic builtin?"}, {"sha": "dceb0864fd490c7f377e3ae3b39201e4850ce8a1", "filename": "gcc/rust/backend/rust-compile-intrinsic.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45095d73f1ca5bb8a4954fdbf62af8351bbc52e1/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45095d73f1ca5bb8a4954fdbf62af8351bbc52e1/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.h?ref=45095d73f1ca5bb8a4954fdbf62af8351bbc52e1", "patch": "@@ -18,6 +18,7 @@\n #define RUST_COMPILE_INTRINSIC\n \n #include \"rust-compile-context.h\"\n+#include \"langhooks.h\"\n \n namespace Rust {\n namespace Compile {"}]}