{"sha": "10d48c59b0df93ea62b2f5d5850e10a60c43acff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTBkNDhjNTliMGRmOTNlYTYyYjJmNWQ1ODUwZTEwYTYwYzQzYWNmZg==", "commit": {"author": {"name": "David Tolnay", "email": "dtolnay@gmail.com", "date": "2016-11-16T23:09:27Z"}, "committer": {"name": "Mark Wielaard", "email": "mark@gcc.gnu.org", "date": "2016-11-16T23:09:27Z"}, "message": "libiberty: Add Rust symbol demangling.\n\nAdds Rust symbol demangler. Rust mangles symbols using GNU_V3 style,\nadding a hash and various special character subtitutions. This adds\na new rust style to cplus_demangle and adds 3 helper functions\nrust_demangle, rust_demangle_sym and rust_is_mangled.\n\nrust-demangle.c was written by David. Mark did the code formatting to\nGNU style and integration into the gcc/libiberty build system and\ntestsuite.\n\ninclude/ChangeLog:\n\n2016-11-03  David Tolnay <dtolnay@gmail.com>\n           Mark Wielaard  <mark@klomp.org>\n\n       * demangle.h (DMGL_RUST): New macro.\n       (DMGL_STYLE_MASK): Add DMGL_RUST.\n       (demangling_styles): Add dlang_rust.\n       (RUST_DEMANGLING_STYLE_STRING): New macro.\n       (RUST_DEMANGLING): New macro.\n       (rust_demangle): New prototype.\n       (rust_is_mangled): Likewise.\n       (rust_demangle_sym): Likewise.\n\nlibiberty/ChangeLog:\n\n2016-11-03  David Tolnay <dtolnay@gmail.com>\n           Mark Wielaard  <mark@klomp.org>\n\n       * Makefile.in (CFILES): Add rust-demangle.c.\n       (REQUIRED_OFILES): Add rust-demangle.o.\n       * cplus-dem.c (libiberty_demanglers): Add rust_demangling case.\n       (cplus_demangle): Handle RUST_DEMANGLING.\n       (rust_demangle): New function.\n       * rust-demangle.c: New file.\n       * testsuite/Makefile.in (really-check): Add check-rust-demangle.\n       (check-rust-demangle): New rule.\n       * testsuite/rust-demangle-expected: New file.\n\nCo-Authored-By: Mark Wielaard <mark@klomp.org>\n\nFrom-SVN: r242524", "tree": {"sha": "3b8f116c9b4374f4fdcfa2ea9deeb92b304dde92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3b8f116c9b4374f4fdcfa2ea9deeb92b304dde92"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10d48c59b0df93ea62b2f5d5850e10a60c43acff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10d48c59b0df93ea62b2f5d5850e10a60c43acff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10d48c59b0df93ea62b2f5d5850e10a60c43acff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10d48c59b0df93ea62b2f5d5850e10a60c43acff/comments", "author": {"login": "dtolnay", "id": 1940490, "node_id": "MDQ6VXNlcjE5NDA0OTA=", "avatar_url": "https://avatars.githubusercontent.com/u/1940490?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dtolnay", "html_url": "https://github.com/dtolnay", "followers_url": "https://api.github.com/users/dtolnay/followers", "following_url": "https://api.github.com/users/dtolnay/following{/other_user}", "gists_url": "https://api.github.com/users/dtolnay/gists{/gist_id}", "starred_url": "https://api.github.com/users/dtolnay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dtolnay/subscriptions", "organizations_url": "https://api.github.com/users/dtolnay/orgs", "repos_url": "https://api.github.com/users/dtolnay/repos", "events_url": "https://api.github.com/users/dtolnay/events{/privacy}", "received_events_url": "https://api.github.com/users/dtolnay/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "46b2baa723df876837763f269717413d04a226e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46b2baa723df876837763f269717413d04a226e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46b2baa723df876837763f269717413d04a226e0"}], "stats": {"total": 630, "additions": 624, "deletions": 6}, "files": [{"sha": "a0a29db1df947b5ac71ff5a7bf322d15109f5ece", "filename": "include/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d48c59b0df93ea62b2f5d5850e10a60c43acff/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d48c59b0df93ea62b2f5d5850e10a60c43acff/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=10d48c59b0df93ea62b2f5d5850e10a60c43acff", "patch": "@@ -1,3 +1,15 @@\n+2016-11-03  David Tolnay <dtolnay@gmail.com>\n+\t    Mark Wielaard  <mark@klomp.org>\n+\n+\t* demangle.h (DMGL_RUST): New macro.\n+\t(DMGL_STYLE_MASK): Add DMGL_RUST.\n+\t(demangling_styles): Add dlang_rust.\n+\t(RUST_DEMANGLING_STYLE_STRING): New macro.\n+\t(RUST_DEMANGLING): New macro.\n+\t(rust_demangle): New prototype.\n+\t(rust_is_mangled): Likewise.\n+\t(rust_demangle_sym): Likewise.\n+\n 2016-11-07  Jason Merrill  <jason@redhat.com>\n \n \t* demangle.h (enum demangle_component_type): Add"}, {"sha": "4e2f9fb75c8058e56b8eaeed92a4fc1ebd7d5827", "filename": "include/demangle.h", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d48c59b0df93ea62b2f5d5850e10a60c43acff/include%2Fdemangle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d48c59b0df93ea62b2f5d5850e10a60c43acff/include%2Fdemangle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fdemangle.h?ref=10d48c59b0df93ea62b2f5d5850e10a60c43acff", "patch": "@@ -63,9 +63,10 @@ extern \"C\" {\n #define DMGL_GNU_V3\t (1 << 14)\n #define DMGL_GNAT\t (1 << 15)\n #define DMGL_DLANG\t (1 << 16)\n+#define DMGL_RUST\t (1 << 17)\t/* Rust wraps GNU_V3 style mangling.  */\n \n /* If none of these are set, use 'current_demangling_style' as the default. */\n-#define DMGL_STYLE_MASK (DMGL_AUTO|DMGL_GNU|DMGL_LUCID|DMGL_ARM|DMGL_HP|DMGL_EDG|DMGL_GNU_V3|DMGL_JAVA|DMGL_GNAT|DMGL_DLANG)\n+#define DMGL_STYLE_MASK (DMGL_AUTO|DMGL_GNU|DMGL_LUCID|DMGL_ARM|DMGL_HP|DMGL_EDG|DMGL_GNU_V3|DMGL_JAVA|DMGL_GNAT|DMGL_DLANG|DMGL_RUST)\n \n /* Enumeration of possible demangling styles.\n \n@@ -88,7 +89,8 @@ extern enum demangling_styles\n   gnu_v3_demangling = DMGL_GNU_V3,\n   java_demangling = DMGL_JAVA,\n   gnat_demangling = DMGL_GNAT,\n-  dlang_demangling = DMGL_DLANG\n+  dlang_demangling = DMGL_DLANG,\n+  rust_demangling = DMGL_RUST\n } current_demangling_style;\n \n /* Define string names for the various demangling styles. */\n@@ -104,6 +106,7 @@ extern enum demangling_styles\n #define JAVA_DEMANGLING_STYLE_STRING          \"java\"\n #define GNAT_DEMANGLING_STYLE_STRING          \"gnat\"\n #define DLANG_DEMANGLING_STYLE_STRING         \"dlang\"\n+#define RUST_DEMANGLING_STYLE_STRING          \"rust\"\n \n /* Some macros to test what demangling style is active. */\n \n@@ -118,6 +121,7 @@ extern enum demangling_styles\n #define JAVA_DEMANGLING (((int) CURRENT_DEMANGLING_STYLE) & DMGL_JAVA)\n #define GNAT_DEMANGLING (((int) CURRENT_DEMANGLING_STYLE) & DMGL_GNAT)\n #define DLANG_DEMANGLING (((int) CURRENT_DEMANGLING_STYLE) & DMGL_DLANG)\n+#define RUST_DEMANGLING (((int) CURRENT_DEMANGLING_STYLE) & DMGL_RUST)\n \n /* Provide information about the available demangle styles. This code is\n    pulled from gdb into libiberty because it is useful to binutils also.  */\n@@ -175,6 +179,27 @@ ada_demangle (const char *mangled, int options);\n extern char *\n dlang_demangle (const char *mangled, int options);\n \n+/* Returns non-zero iff MANGLED is a rust mangled symbol.  MANGLED must\n+   already have been demangled through cplus_demangle_v3.  If this function\n+   returns non-zero then MANGLED can be demangled (in-place) using\n+   RUST_DEMANGLE_SYM.  */\n+extern int\n+rust_is_mangled (const char *mangled);\n+\n+/* Demangles SYM (in-place) if RUST_IS_MANGLED returned non-zero for SYM.\n+   If RUST_IS_MANGLED returned zero for SYM then RUST_DEMANGLE_SYM might\n+   replace characters that cannot be demangled with '?' and might truncate\n+   SYM.  After calling RUST_DEMANGLE_SYM SYM might be shorter, but never\n+   larger.  */\n+extern void\n+rust_demangle_sym (char *sym);\n+\n+/* Demangles MANGLED if it was GNU_V3 and then RUST mangled, otherwise\n+   returns NULL. Uses CPLUS_DEMANGLE_V3, RUST_IS_MANGLED and\n+   RUST_DEMANGLE_SYM.  Returns a new string that is owned by the caller.  */\n+extern char *\n+rust_demangle (const char *mangled, int options);\n+\n enum gnu_v3_ctor_kinds {\n   gnu_v3_complete_object_ctor = 1,\n   gnu_v3_base_object_ctor,"}, {"sha": "4e71750ec8a68a50341866236f7b821f76943d59", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d48c59b0df93ea62b2f5d5850e10a60c43acff/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d48c59b0df93ea62b2f5d5850e10a60c43acff/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=10d48c59b0df93ea62b2f5d5850e10a60c43acff", "patch": "@@ -1,3 +1,16 @@\n+2016-11-03  David Tolnay <dtolnay@gmail.com>\n+\t    Mark Wielaard  <mark@klomp.org>\n+\n+\t* Makefile.in (CFILES): Add rust-demangle.c.\n+\t(REQUIRED_OFILES): Add rust-demangle.o.\n+\t* cplus-dem.c (libiberty_demanglers): Add rust_demangling case.\n+\t(cplus_demangle): Handle RUST_DEMANGLING.\n+\t(rust_demangle): New function.\n+\t* rust-demangle.c: New file.\n+\t* testsuite/Makefile.in (really-check): Add check-rust-demangle.\n+\t(check-rust-demangle): New rule.\n+\t* testsuite/rust-demangle-expected: New file.\n+\n 2016-11-15  Mark Wielaard  <mark@klomp.org>\n \n \t* cp-demangle.c (d_expression_1): Make sure third expression"}, {"sha": "0ff9e45e45ef6fd6b96bef3de53c620f48e2b7f3", "filename": "libiberty/Makefile.in", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d48c59b0df93ea62b2f5d5850e10a60c43acff/libiberty%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d48c59b0df93ea62b2f5d5850e10a60c43acff/libiberty%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FMakefile.in?ref=10d48c59b0df93ea62b2f5d5850e10a60c43acff", "patch": "@@ -146,6 +146,7 @@ CFILES = alloca.c argv.c asprintf.c atexit.c\t\t\t\t\\\n \t pex-unix.c pex-win32.c\t\t\t\t\t\t\\\n          physmem.c putenv.c\t\t\t\t\t\t\\\n \trandom.c regex.c rename.c rindex.c\t\t\t\t\\\n+\trust-demangle.c\t\t\t\t\t\t\t\\\n \tsafe-ctype.c setenv.c setproctitle.c sha1.c sigsetmask.c        \\\n \t simple-object.c simple-object-coff.c simple-object-elf.c\t\\\n \t simple-object-mach-o.c simple-object-xcoff.c\t\t\t\\\n@@ -183,6 +184,7 @@ REQUIRED_OFILES =\t\t\t\t\t\t\t\\\n \t./partition.$(objext) ./pexecute.$(objext) ./physmem.$(objext)\t\\\n \t./pex-common.$(objext) ./pex-one.$(objext)\t\t\t\\\n \t./@pexecute@.$(objext) ./vprintf-support.$(objext)\t\t\\\n+\t./rust-demangle.$(objext)\t\t\t\t\t\\\n \t./safe-ctype.$(objext)\t\t\t\t\t\t\\\n \t./simple-object.$(objext) ./simple-object-coff.$(objext)\t\\\n \t./simple-object-elf.$(objext) ./simple-object-mach-o.$(objext)\t\\\n@@ -1188,6 +1190,17 @@ $(CONFIGURED_OFILES): stamp-picdir stamp-noasandir\n \telse true; fi\n \t$(COMPILE.c) $(srcdir)/rindex.c $(OUTPUT_OPTION)\n \n+./rust-demangle.$(objext): $(srcdir)/rust-demangle.c config.h \\\n+\t$(INCDIR)/ansidecl.h $(INCDIR)/demangle.h $(INCDIR)/libiberty.h \\\n+\t$(INCDIR)/safe-ctype.h\n+\tif [ x\"$(PICFLAG)\" != x ]; then \\\n+\t  $(COMPILE.c) $(PICFLAG) $(srcdir)/rust-demangle.c -o pic/$@; \\\n+\telse true; fi\n+\tif [ x\"$(NOASANFLAG)\" != x ]; then \\\n+\t  $(COMPILE.c) $(PICFLAG) $(NOASANFLAG) $(srcdir)/rust-demangle.c -o noasan/$@; \\\n+\telse true; fi\n+\t$(COMPILE.c) $(srcdir)/rust-demangle.c $(OUTPUT_OPTION)\n+\n ./safe-ctype.$(objext): $(srcdir)/safe-ctype.c $(INCDIR)/ansidecl.h \\\n \t$(INCDIR)/safe-ctype.h\n \tif [ x\"$(PICFLAG)\" != x ]; then \\"}, {"sha": "0386da59c3deddab8def287c1177145d57534f8f", "filename": "libiberty/cplus-dem.c", "status": "modified", "additions": 45, "deletions": 2, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d48c59b0df93ea62b2f5d5850e10a60c43acff/libiberty%2Fcplus-dem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d48c59b0df93ea62b2f5d5850e10a60c43acff/libiberty%2Fcplus-dem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcplus-dem.c?ref=10d48c59b0df93ea62b2f5d5850e10a60c43acff", "patch": "@@ -322,6 +322,12 @@ const struct demangler_engine libiberty_demanglers[] =\n     \"DLANG style demangling\"\n   }\n   ,\n+  {\n+    RUST_DEMANGLING_STYLE_STRING,\n+    rust_demangling,\n+    \"Rust style demangling\"\n+  }\n+  ,\n   {\n     NULL, unknown_demangling, NULL\n   }\n@@ -874,10 +880,26 @@ cplus_demangle (const char *mangled, int options)\n     work->options |= (int) current_demangling_style & DMGL_STYLE_MASK;\n \n   /* The V3 ABI demangling is implemented elsewhere.  */\n-  if (GNU_V3_DEMANGLING || AUTO_DEMANGLING)\n+  if (GNU_V3_DEMANGLING || RUST_DEMANGLING || AUTO_DEMANGLING)\n     {\n       ret = cplus_demangle_v3 (mangled, work->options);\n-      if (ret || GNU_V3_DEMANGLING)\n+      if (GNU_V3_DEMANGLING)\n+\treturn ret;\n+\n+      if (ret)\n+\t{\n+\t  /* Rust symbols are GNU_V3 mangled plus some extra subtitutions.\n+\t     The subtitutions are always smaller, so do in place changes.  */\n+\t  if (rust_is_mangled (ret))\n+\t    rust_demangle_sym (ret);\n+\t  else if (RUST_DEMANGLING)\n+\t    {\n+\t      free (ret);\n+\t      ret = NULL;\n+\t    }\n+\t}\n+\n+      if (ret || RUST_DEMANGLING)\n \treturn ret;\n     }\n \n@@ -903,6 +925,27 @@ cplus_demangle (const char *mangled, int options)\n   return (ret);\n }\n \n+char *\n+rust_demangle (const char *mangled, int options)\n+{\n+  /* Rust symbols are GNU_V3 mangled plus some extra subtitutions.  */\n+  char *ret = cplus_demangle_v3 (mangled, options);\n+\n+  /* The Rust subtitutions are always smaller, so do in place changes.  */\n+  if (ret != NULL)\n+    {\n+      if (rust_is_mangled (ret))\n+\trust_demangle_sym (ret);\n+      else\n+\t{\n+\t  free (ret);\n+\t  ret = NULL;\n+\t}\n+    }\n+\n+  return ret;\n+}\n+\n /* Demangle ada names.  The encoding is documented in gcc/ada/exp_dbug.ads.  */\n \n char *"}, {"sha": "326881e48f72f1a377e40e2b77df7527ad72567c", "filename": "libiberty/rust-demangle.c", "status": "added", "additions": 348, "deletions": 0, "changes": 348, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d48c59b0df93ea62b2f5d5850e10a60c43acff/libiberty%2Frust-demangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d48c59b0df93ea62b2f5d5850e10a60c43acff/libiberty%2Frust-demangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Frust-demangle.c?ref=10d48c59b0df93ea62b2f5d5850e10a60c43acff", "patch": "@@ -0,0 +1,348 @@\n+/* Demangler for the Rust programming language\n+   Copyright 2016 Free Software Foundation, Inc.\n+   Written by David Tolnay (dtolnay@gmail.com).\n+\n+This file is part of the libiberty library.\n+Libiberty is free software; you can redistribute it and/or\n+modify it under the terms of the GNU Library General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU Library General Public\n+License, the Free Software Foundation gives you unlimited permission\n+to link the compiled version of this file into combinations with other\n+programs, and to distribute those combinations without any restriction\n+coming from the use of this file.  (The Library Public License\n+restrictions do apply in other respects; for example, they cover\n+modification of the file, and distribution when not linked into a\n+combined executable.)\n+\n+Libiberty is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+Library General Public License for more details.\n+\n+You should have received a copy of the GNU Library General Public\n+License along with libiberty; see the file COPYING.LIB.\n+If not, see <http://www.gnu.org/licenses/>.  */\n+\n+\n+#ifdef HAVE_CONFIG_H\n+#include \"config.h\"\n+#endif\n+\n+#include \"safe-ctype.h\"\n+\n+#include <sys/types.h>\n+#include <string.h>\n+#include <stdio.h>\n+\n+#ifdef HAVE_STRING_H\n+#include <string.h>\n+#else\n+extern size_t strlen(const char *s);\n+extern int strncmp(const char *s1, const char *s2, size_t n);\n+extern void *memset(void *s, int c, size_t n);\n+#endif\n+\n+#include <demangle.h>\n+#include \"libiberty.h\"\n+\n+\n+/* Mangled Rust symbols look like this:\n+     _$LT$std..sys..fd..FileDesc$u20$as$u20$core..ops..Drop$GT$::drop::hc68340e1baa4987a\n+\n+   The original symbol is:\n+     <std::sys::fd::FileDesc as core::ops::Drop>::drop\n+\n+   The last component of the path is a 64-bit hash in lowercase hex,\n+   prefixed with \"h\". Rust does not have a global namespace between\n+   crates, an illusion which Rust maintains by using the hash to\n+   distinguish things that would otherwise have the same symbol.\n+\n+   Any path component not starting with a XID_Start character is\n+   prefixed with \"_\".\n+\n+   The following escape sequences are used:\n+\n+   \",\"  =>  $C$\n+   \"@\"  =>  $SP$\n+   \"*\"  =>  $BP$\n+   \"&\"  =>  $RF$\n+   \"<\"  =>  $LT$\n+   \">\"  =>  $GT$\n+   \"(\"  =>  $LP$\n+   \")\"  =>  $RP$\n+   \" \"  =>  $u20$\n+   \"\\\"\" =>  $u22$\n+   \"'\"  =>  $u27$\n+   \"+\"  =>  $u2b$\n+   \";\"  =>  $u3b$\n+   \"[\"  =>  $u5b$\n+   \"]\"  =>  $u5d$\n+   \"{\"  =>  $u7b$\n+   \"}\"  =>  $u7d$\n+   \"~\"  =>  $u7e$\n+\n+   A double \"..\" means \"::\" and a single \".\" means \"-\".\n+\n+   The only characters allowed in the mangled symbol are a-zA-Z0-9 and _.:$  */\n+\n+static const char *hash_prefix = \"::h\";\n+static const size_t hash_prefix_len = 3;\n+static const size_t hash_len = 16;\n+\n+static int is_prefixed_hash (const char *start);\n+static int looks_like_rust (const char *sym, size_t len);\n+static int unescape (const char **in, char **out, const char *seq, char value);\n+\n+/* INPUT: sym: symbol that has been through C++ (gnu v3) demangling\n+\n+   This function looks for the following indicators:\n+\n+   1. The hash must consist of \"h\" followed by 16 lowercase hex digits.\n+\n+   2. As a sanity check, the hash must use between 5 and 15 of the 16\n+      possible hex digits. This is true of 99.9998% of hashes so once\n+      in your life you may see a false negative. The point is to\n+      notice path components that could be Rust hashes but are\n+      probably not, like \"haaaaaaaaaaaaaaaa\". In this case a false\n+      positive (non-Rust symbol has an important path component\n+      removed because it looks like a Rust hash) is worse than a false\n+      negative (the rare Rust symbol is not demangled) so this sets\n+      the balance in favor of false negatives.\n+\n+   3. There must be no characters other than a-zA-Z0-9 and _.:$\n+\n+   4. There must be no unrecognized $-sign sequences.\n+\n+   5. There must be no sequence of three or more dots in a row (\"...\").  */\n+\n+int\n+rust_is_mangled (const char *sym)\n+{\n+  size_t len, len_without_hash;\n+\n+  if (!sym)\n+    return 0;\n+\n+  len = strlen (sym);\n+  if (len <= hash_prefix_len + hash_len)\n+    /* Not long enough to contain \"::h\" + hash + something else */\n+    return 0;\n+\n+  len_without_hash = len - (hash_prefix_len + hash_len);\n+  if (!is_prefixed_hash (sym + len_without_hash))\n+    return 0;\n+\n+  return looks_like_rust (sym, len_without_hash);\n+}\n+\n+/* A hash is the prefix \"::h\" followed by 16 lowercase hex digits. The\n+   hex digits must comprise between 5 and 15 (inclusive) distinct\n+   digits.  */\n+\n+static int\n+is_prefixed_hash (const char *str)\n+{\n+  const char *end;\n+  char seen[16];\n+  size_t i;\n+  int count;\n+\n+  if (strncmp (str, hash_prefix, hash_prefix_len))\n+    return 0;\n+  str += hash_prefix_len;\n+\n+  memset (seen, 0, sizeof(seen));\n+  for (end = str + hash_len; str < end; str++)\n+    if (*str >= '0' && *str <= '9')\n+      seen[*str - '0'] = 1;\n+    else if (*str >= 'a' && *str <= 'f')\n+      seen[*str - 'a' + 10] = 1;\n+    else\n+      return 0;\n+\n+  /* Count how many distinct digits seen */\n+  count = 0;\n+  for (i = 0; i < 16; i++)\n+    if (seen[i])\n+      count++;\n+\n+  return count >= 5 && count <= 15;\n+}\n+\n+static int\n+looks_like_rust (const char *str, size_t len)\n+{\n+  const char *end = str + len;\n+\n+  while (str < end)\n+    switch (*str)\n+      {\n+      case '$':\n+\tif (!strncmp (str, \"$C$\", 3))\n+\t  str += 3;\n+\telse if (!strncmp (str, \"$SP$\", 4)\n+\t\t || !strncmp (str, \"$BP$\", 4)\n+\t\t || !strncmp (str, \"$RF$\", 4)\n+\t\t || !strncmp (str, \"$LT$\", 4)\n+\t\t || !strncmp (str, \"$GT$\", 4)\n+\t\t || !strncmp (str, \"$LP$\", 4)\n+\t\t || !strncmp (str, \"$RP$\", 4))\n+\t  str += 4;\n+\telse if (!strncmp (str, \"$u20$\", 5)\n+\t\t || !strncmp (str, \"$u22$\", 5)\n+\t\t || !strncmp (str, \"$u27$\", 5)\n+\t\t || !strncmp (str, \"$u2b$\", 5)\n+\t\t || !strncmp (str, \"$u3b$\", 5)\n+\t\t || !strncmp (str, \"$u5b$\", 5)\n+\t\t || !strncmp (str, \"$u5d$\", 5)\n+\t\t || !strncmp (str, \"$u7b$\", 5)\n+\t\t || !strncmp (str, \"$u7d$\", 5)\n+\t\t || !strncmp (str, \"$u7e$\", 5))\n+\t  str += 5;\n+\telse\n+\t  return 0;\n+\tbreak;\n+      case '.':\n+\t/* Do not allow three or more consecutive dots */\n+\tif (!strncmp (str, \"...\", 3))\n+\t  return 0;\n+\t/* Fall through */\n+      case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n+      case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n+      case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n+      case 's': case 't': case 'u': case 'v': case 'w': case 'x':\n+      case 'y': case 'z':\n+      case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n+      case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n+      case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n+      case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n+      case 'Y': case 'Z':\n+      case '0': case '1': case '2': case '3': case '4': case '5':\n+      case '6': case '7': case '8': case '9':\n+      case '_':\n+      case ':':\n+\tstr++;\n+\tbreak;\n+      default:\n+\treturn 0;\n+      }\n+\n+  return 1;\n+}\n+\n+/*\n+  INPUT: sym: symbol for which rust_is_mangled(sym) returned 1.\n+\n+  The input is demangled in-place because the mangled name is always\n+  longer than the demangled one.  */\n+\n+void\n+rust_demangle_sym (char *sym)\n+{\n+  const char *in;\n+  char *out;\n+  const char *end;\n+\n+  if (!sym)\n+    return;\n+\n+  in = sym;\n+  out = sym;\n+  end = sym + strlen (sym) - (hash_prefix_len + hash_len);\n+\n+  while (in < end)\n+    switch (*in)\n+      {\n+      case '$':\n+\tif (!(unescape (&in, &out, \"$C$\", ',')\n+\t      || unescape (&in, &out, \"$SP$\", '@')\n+\t      || unescape (&in, &out, \"$BP$\", '*')\n+\t      || unescape (&in, &out, \"$RF$\", '&')\n+\t      || unescape (&in, &out, \"$LT$\", '<')\n+\t      || unescape (&in, &out, \"$GT$\", '>')\n+\t      || unescape (&in, &out, \"$LP$\", '(')\n+\t      || unescape (&in, &out, \"$RP$\", ')')\n+\t      || unescape (&in, &out, \"$u20$\", ' ')\n+\t      || unescape (&in, &out, \"$u22$\", '\\\"')\n+\t      || unescape (&in, &out, \"$u27$\", '\\'')\n+\t      || unescape (&in, &out, \"$u2b$\", '+')\n+\t      || unescape (&in, &out, \"$u3b$\", ';')\n+\t      || unescape (&in, &out, \"$u5b$\", '[')\n+\t      || unescape (&in, &out, \"$u5d$\", ']')\n+\t      || unescape (&in, &out, \"$u7b$\", '{')\n+\t      || unescape (&in, &out, \"$u7d$\", '}')\n+\t      || unescape (&in, &out, \"$u7e$\", '~'))) {\n+\t  /* unexpected escape sequence, not looks_like_rust. */\n+\t  goto fail;\n+\t}\n+\tbreak;\n+      case '_':\n+\t/* If this is the start of a path component and the next\n+\t   character is an escape sequence, ignore the underscore. The\n+\t   mangler inserts an underscore to make sure the path\n+\t   component begins with a XID_Start character. */\n+\tif ((in == sym || in[-1] == ':') && in[1] == '$')\n+\t  in++;\n+\telse\n+\t  *out++ = *in++;\n+\tbreak;\n+      case '.':\n+\tif (in[1] == '.')\n+\t  {\n+\t    /* \"..\" becomes \"::\" */\n+\t    *out++ = ':';\n+\t    *out++ = ':';\n+\t    in += 2;\n+\t  }\n+\telse\n+\t  {\n+\t    /* \".\" becomes \"-\" */\n+\t    *out++ = '-';\n+\t    in++;\n+\t  }\n+\tbreak;\n+      case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n+      case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n+      case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n+      case 's': case 't': case 'u': case 'v': case 'w': case 'x':\n+      case 'y': case 'z':\n+      case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n+      case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n+      case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n+      case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n+      case 'Y': case 'Z':\n+      case '0': case '1': case '2': case '3': case '4': case '5':\n+      case '6': case '7': case '8': case '9':\n+      case ':':\n+\t*out++ = *in++;\n+\tbreak;\n+      default:\n+\t/* unexpected character in symbol, not looks_like_rust.  */\n+\tgoto fail;\n+      }\n+  goto done;\n+\n+fail:\n+  *out++ = '?'; /* This is pretty lame, but it's hard to do better. */\n+done:\n+  *out = '\\0';\n+}\n+\n+static int\n+unescape (const char **in, char **out, const char *seq, char value)\n+{\n+  size_t len = strlen (seq);\n+\n+  if (strncmp (*in, seq, len))\n+    return 0;\n+\n+  **out = value;\n+\n+  *in += len;\n+  *out += 1;\n+\n+  return 1;\n+}"}, {"sha": "da0b2f41c0c46d061d2902d9c07cfe10445d0e1b", "filename": "libiberty/testsuite/Makefile.in", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d48c59b0df93ea62b2f5d5850e10a60c43acff/libiberty%2Ftestsuite%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d48c59b0df93ea62b2f5d5850e10a60c43acff/libiberty%2Ftestsuite%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Ftestsuite%2FMakefile.in?ref=10d48c59b0df93ea62b2f5d5850e10a60c43acff", "patch": "@@ -45,8 +45,8 @@ all:\n # CHECK is set to \"really_check\" or the empty string by configure.\n check: @CHECK@\n \n-really-check: check-cplus-dem check-d-demangle check-pexecute check-expandargv \\\n-\t\tcheck-strtol\n+really-check: check-cplus-dem check-d-demangle check-rust-demangle \\\n+\t\tcheck-pexecute check-expandargv check-strtol\n \n # Run some tests of the demangler.\n check-cplus-dem: test-demangle $(srcdir)/demangle-expected\n@@ -55,6 +55,9 @@ check-cplus-dem: test-demangle $(srcdir)/demangle-expected\n check-d-demangle: test-demangle $(srcdir)/d-demangle-expected\n \t./test-demangle < $(srcdir)/d-demangle-expected\n \n+check-rust-demangle: test-demangle $(srcdir)/rust-demangle-expected\n+\t./test-demangle < $(srcdir)/rust-demangle-expected\n+\n # Check the pexecute code.\n check-pexecute: test-pexecute\n \t./test-pexecute"}, {"sha": "0b4288fc37d70548e93a2233cbeaaecd1929bf55", "filename": "libiberty/testsuite/rust-demangle-expected", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d48c59b0df93ea62b2f5d5850e10a60c43acff/libiberty%2Ftestsuite%2Frust-demangle-expected", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d48c59b0df93ea62b2f5d5850e10a60c43acff/libiberty%2Ftestsuite%2Frust-demangle-expected", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Ftestsuite%2Frust-demangle-expected?ref=10d48c59b0df93ea62b2f5d5850e10a60c43acff", "patch": "@@ -0,0 +1,161 @@\n+# This file holds test cases for the Rust demangler.\n+# Each test case looks like this:\n+#  options\n+#  input to be demangled\n+#  expected output\n+#\n+# See demangle-expected for documentation of supported options.\n+#\n+# A line starting with `#' is ignored.\n+# However, blank lines in this file are NOT ignored.\n+#\n+############\n+#\n+# Coverage Tests\n+#\n+#\n+# Demangles as rust symbol.\n+--format=rust\n+_ZN4main4main17he714a2e23ed7db23E\n+main::main\n+# Also demangles as c++ gnu v3 mangled symbol. But with extra Rust hash.\n+--format=gnu-v3\n+_ZN4main4main17he714a2e23ed7db23E\n+main::main::he714a2e23ed7db23\n+# But auto should demangle fully gnu-v3 -> rust -> demangled, not partially.\n+--format=auto\n+_ZN4main4main17he714a2e23ed7db23E\n+main::main\n+# Hash is exactly 16 hex chars. Not more.\n+--format=auto\n+_ZN4main4main18h1e714a2e23ed7db23E\n+main::main::h1e714a2e23ed7db23\n+# Not less.\n+--format=auto\n+_ZN4main4main16h714a2e23ed7db23E\n+main::main::h714a2e23ed7db23\n+# And not non-hex.\n+--format=auto\n+_ZN4main4main17he714a2e23ed7db2gE\n+main::main::he714a2e23ed7db2g\n+# $XX$ substitutions should not contain just numbers.\n+--format=auto\n+_ZN4main4$99$17he714a2e23ed7db23E\n+main::$99$::he714a2e23ed7db23\n+# _ at start of path should be removed.\n+# \"..\" translates to \"::\" \"$GT$\" to \">\" and \"$LT$\" to \"<\".\n+--format=rust\n+_ZN71_$LT$Test$u20$$u2b$$u20$$u27$static$u20$as$u20$foo..Bar$LT$Test$GT$$GT$3bar17h930b740aa94f1d3aE\n+<Test + 'static as foo::Bar<Test>>::bar\n+#\n+--format=rust\n+_ZN54_$LT$I$u20$as$u20$core..iter..traits..IntoIterator$GT$9into_iter17h8581507801fb8615E\n+<I as core::iter::traits::IntoIterator>::into_iter\n+#\n+--format=rust\n+_ZN10parse_tsan4main17hdbbfdf1c6a7e27d9E\n+parse_tsan::main\n+#\n+--format=rust\n+_ZN65_$LT$std..env..Args$u20$as$u20$core..iter..iterator..Iterator$GT$4next17h420a7c8d0c7eef40E\n+<std::env::Args as core::iter::iterator::Iterator>::next\n+#\n+--format=rust\n+_ZN4core3str9from_utf817hdcea28871313776dE\n+core::str::from_utf8\n+#\n+--format=rust\n+_ZN4core3mem7size_of17h18bde9bb8c22e2cfE\n+core::mem::size_of\n+#\n+--format=rust\n+_ZN5alloc4heap8allocate17hd55c03e6cb81d924E\n+alloc::heap::allocate\n+#\n+--format=rust\n+_ZN4core3ptr8null_mut17h736cce09ca0ac11aE\n+core::ptr::null_mut\n+#\n+--format=rust\n+_ZN4core3ptr31_$LT$impl$u20$$BP$mut$u20$T$GT$7is_null17h7f9de798bc3f0879E\n+core::ptr::<impl *mut T>::is_null\n+#\n+--format=rust\n+_ZN40_$LT$alloc..raw_vec..RawVec$LT$T$GT$$GT$6double17h4166e2b47539e1ffE\n+<alloc::raw_vec::RawVec<T>>::double\n+#\n+--format=rust\n+_ZN39_$LT$collections..vec..Vec$LT$T$GT$$GT$4push17hd4b6b23c1b88141aE\n+<collections::vec::Vec<T>>::push\n+#\n+--format=rust\n+_ZN70_$LT$collections..vec..Vec$LT$T$GT$$u20$as$u20$core..ops..DerefMut$GT$9deref_mut17hf299b860dc5a831cE\n+<collections::vec::Vec<T> as core::ops::DerefMut>::deref_mut\n+#\n+--format=rust\n+_ZN63_$LT$core..ptr..Unique$LT$T$GT$$u20$as$u20$core..ops..Deref$GT$5deref17hc784b4a166cb5e5cE\n+<core::ptr::Unique<T> as core::ops::Deref>::deref\n+#\n+--format=rust\n+_ZN40_$LT$alloc..raw_vec..RawVec$LT$T$GT$$GT$3ptr17h7570b6e9070b693bE\n+<alloc::raw_vec::RawVec<T>>::ptr\n+#\n+--format=rust\n+_ZN4core3ptr31_$LT$impl$u20$$BP$mut$u20$T$GT$7is_null17h0f3228f343444ac8E\n+core::ptr::<impl *mut T>::is_null\n+#\n+--format=rust\n+_ZN53_$LT$$u5b$T$u5d$$u20$as$u20$core..slice..SliceExt$GT$10as_mut_ptr17h153241df1c7d1666E\n+<[T] as core::slice::SliceExt>::as_mut_ptr\n+#\n+--format=rust\n+_ZN11collections5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$10as_mut_ptr17hf12a6d0409938c96E\n+collections::slice::<impl [T]>::as_mut_ptr\n+#\n+--format=rust\n+_ZN4core3ptr5write17h651fe53ec860e780E\n+core::ptr::write\n+#\n+--format=rust\n+_ZN65_$LT$std..env..Args$u20$as$u20$core..iter..iterator..Iterator$GT$4next17h420a7c8d0c7eef40E\n+<std::env::Args as core::iter::iterator::Iterator>::next\n+#\n+--format=rust\n+_ZN54_$LT$I$u20$as$u20$core..iter..traits..IntoIterator$GT$9into_iter17he06cb713aae5b465E\n+<I as core::iter::traits::IntoIterator>::into_iter\n+#\n+--format=rust\n+_ZN71_$LT$collections..vec..IntoIter$LT$T$GT$$u20$as$u20$core..ops..Drop$GT$4drop17hf7f23304ebe62eedE\n+<collections::vec::IntoIter<T> as core::ops::Drop>::drop\n+#\n+--format=rust\n+_ZN86_$LT$collections..vec..IntoIter$LT$T$GT$$u20$as$u20$core..iter..iterator..Iterator$GT$4next17h04b3fbf148c39713E\n+<collections::vec::IntoIter<T> as core::iter::iterator::Iterator>::next\n+#\n+--format=rust\n+_ZN75_$LT$$RF$$u27$a$u20$mut$u20$I$u20$as$u20$core..iter..iterator..Iterator$GT$4next17ha050492063e0fd20E\n+<&'a mut I as core::iter::iterator::Iterator>::next\n+# Different hashes are OK, they are just stripped.\n+--format=rust\n+_ZN13drop_contents17hfe3c0a68c8ad1c74E\n+drop_contents\n+#\n+--format=rust\n+_ZN13drop_contents17h48cb59bef15bb555E\n+drop_contents\n+#\n+--format=rust\n+_ZN4core3mem7size_of17h900b33157bf58f26E\n+core::mem::size_of\n+#\n+--format=rust\n+_ZN67_$LT$alloc..raw_vec..RawVec$LT$T$GT$$u20$as$u20$core..ops..Drop$GT$4drop17h96a5cf6e94807905E\n+<alloc::raw_vec::RawVec<T> as core::ops::Drop>::drop\n+#\n+--format=rust\n+_ZN68_$LT$core..nonzero..NonZero$LT$T$GT$$u20$as$u20$core..ops..Deref$GT$5deref17hc49056f882aa46dbE\n+<core::nonzero::NonZero<T> as core::ops::Deref>::deref\n+#\n+--format=rust\n+_ZN63_$LT$core..ptr..Unique$LT$T$GT$$u20$as$u20$core..ops..Deref$GT$5deref17h19f2ad4920655e85E\n+<core::ptr::Unique<T> as core::ops::Deref>::deref"}]}