{"sha": "f990f3a3b68334b54faea6de0f4edfbd8f23b8f0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjk5MGYzYTNiNjgzMzRiNTRmYWVhNmRlMGY0ZWRmYmQ4ZjIzYjhmMA==", "commit": {"author": {"name": "Aaron Sawdey", "email": "acsawdey@linux.vnet.ibm.com", "date": "2017-06-29T20:10:05Z"}, "committer": {"name": "Aaron Sawdey", "email": "acsawdey@gcc.gnu.org", "date": "2017-06-29T20:10:05Z"}, "message": "rs6000.c (toc_relative_expr_p): Make tocrel_base and tocrel_offset be pointer args rather than implicitly using...\n\n2017-06-29  Aaron Sawdey  <acsawdey@linux.vnet.ibm.com>\n\n        * config/rs6000/rs6000.c (toc_relative_expr_p): Make tocrel_base\n        and tocrel_offset be pointer args rather than implicitly using\n        static versions.\n        (legitimate_constant_pool_address_p, rs6000_emit_move,\n        const_load_sequence_p, adjust_vperm): Add local tocrel_base and\n        tocrel_offset and use in toc_relative_expr_p call.\n        (print_operand, print_operand_address): Use static tocrel_base_oac\n        and tocrel_offset_oac.\n        (rs6000_output_addr_const_extra): Use static tocrel_base_oac and\n        tocrel_offset_oac.\n\nFrom-SVN: r249815", "tree": {"sha": "32a513d4404bedb2078707af45b7048e5e128d61", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/32a513d4404bedb2078707af45b7048e5e128d61"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f990f3a3b68334b54faea6de0f4edfbd8f23b8f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f990f3a3b68334b54faea6de0f4edfbd8f23b8f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f990f3a3b68334b54faea6de0f4edfbd8f23b8f0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f990f3a3b68334b54faea6de0f4edfbd8f23b8f0/comments", "author": null, "committer": null, "parents": [{"sha": "5497bd2bb6410e58eff6f57e53700dec646b1315", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5497bd2bb6410e58eff6f57e53700dec646b1315", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5497bd2bb6410e58eff6f57e53700dec646b1315"}], "stats": {"total": 67, "additions": 48, "deletions": 19}, "files": [{"sha": "00431eede65987402a14b94f6feac9c8925e0232", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f990f3a3b68334b54faea6de0f4edfbd8f23b8f0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f990f3a3b68334b54faea6de0f4edfbd8f23b8f0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f990f3a3b68334b54faea6de0f4edfbd8f23b8f0", "patch": "@@ -1,3 +1,16 @@\n+2017-06-29  Aaron Sawdey  <acsawdey@linux.vnet.ibm.com>\n+\n+        * config/rs6000/rs6000.c (toc_relative_expr_p): Make tocrel_base\n+        and tocrel_offset be pointer args rather than implicitly using\n+        static versions.\n+        (legitimate_constant_pool_address_p, rs6000_emit_move,\n+        const_load_sequence_p, adjust_vperm): Add local tocrel_base and\n+        tocrel_offset and use in toc_relative_expr_p call.\n+        (print_operand, print_operand_address): Use static tocrel_base_oac\n+        and tocrel_offset_oac.\n+        (rs6000_output_addr_const_extra): Use static tocrel_base_oac and\n+        tocrel_offset_oac.\n+\n 2017-06-29  Maya Rashish  <coypu@sdf.org>\n \n \t* config/vax/builtins.md (ffssi2_internal): Correct constraint."}, {"sha": "aeec9b2f1c2ea39b09ea20fa7128a8ada080ffc2", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f990f3a3b68334b54faea6de0f4edfbd8f23b8f0/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f990f3a3b68334b54faea6de0f4edfbd8f23b8f0/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=f990f3a3b68334b54faea6de0f4edfbd8f23b8f0", "patch": "@@ -40,7 +40,7 @@ extern int num_insns_constant_wide (HOST_WIDE_INT);\n extern int small_data_operand (rtx, machine_mode);\n extern bool mem_operand_gpr (rtx, machine_mode);\n extern bool mem_operand_ds_form (rtx, machine_mode);\n-extern bool toc_relative_expr_p (const_rtx, bool);\n+extern bool toc_relative_expr_p (const_rtx, bool, const_rtx *, const_rtx *);\n extern void validate_condition_mode (enum rtx_code, machine_mode);\n extern bool legitimate_constant_pool_address_p (const_rtx, machine_mode,\n \t\t\t\t\t\tbool);"}, {"sha": "fde16730a368671d46e719b079440580e48471dc", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 34, "deletions": 18, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f990f3a3b68334b54faea6de0f4edfbd8f23b8f0/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f990f3a3b68334b54faea6de0f4edfbd8f23b8f0/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=f990f3a3b68334b54faea6de0f4edfbd8f23b8f0", "patch": "@@ -8628,14 +8628,20 @@ constant_pool_expr_p (rtx op)\n \t  && ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (get_pool_constant (base), Pmode));\n }\n \n-static const_rtx tocrel_base, tocrel_offset;\n+/* These are only used to pass through from print_operand/print_operand_address\n+   to rs6000_output_addr_const_extra over the intervening function\n+   output_addr_const which is not target code.  */\n+static const_rtx tocrel_base_oac, tocrel_offset_oac;\n \n /* Return true if OP is a toc pointer relative address (the output\n    of create_TOC_reference).  If STRICT, do not match non-split\n-   -mcmodel=large/medium toc pointer relative addresses.  */\n+   -mcmodel=large/medium toc pointer relative addresses.  If the pointers \n+   are non-NULL, place base and offset pieces in TOCREL_BASE_RET and \n+   TOCREL_OFFSET_RET respectively.  */\n \n bool\n-toc_relative_expr_p (const_rtx op, bool strict)\n+toc_relative_expr_p (const_rtx op, bool strict, const_rtx *tocrel_base_ret,\n+\t\t     const_rtx *tocrel_offset_ret)\n {\n   if (!TARGET_TOC)\n     return false;\n@@ -8655,14 +8661,20 @@ toc_relative_expr_p (const_rtx op, bool strict)\n \top = XEXP (op, 1);\n     }\n \n-  tocrel_base = op;\n-  tocrel_offset = const0_rtx;\n+  const_rtx tocrel_base = op;\n+  const_rtx tocrel_offset = const0_rtx;\n+\n   if (GET_CODE (op) == PLUS && add_cint_operand (XEXP (op, 1), GET_MODE (op)))\n     {\n       tocrel_base = XEXP (op, 0);\n       tocrel_offset = XEXP (op, 1);\n     }\n \n+  if (tocrel_base_ret)\n+    *tocrel_base_ret = tocrel_base;\n+  if (tocrel_offset_ret)\n+    *tocrel_offset_ret = tocrel_offset;\n+\n   return (GET_CODE (tocrel_base) == UNSPEC\n \t  && XINT (tocrel_base, 1) == UNSPEC_TOCREL);\n }\n@@ -8674,7 +8686,8 @@ bool\n legitimate_constant_pool_address_p (const_rtx x, machine_mode mode,\n \t\t\t\t    bool strict)\n {\n-  return (toc_relative_expr_p (x, strict)\n+  const_rtx tocrel_base, tocrel_offset;\n+  return (toc_relative_expr_p (x, strict, &tocrel_base, &tocrel_offset)\n \t  && (TARGET_CMODEL != CMODEL_MEDIUM\n \t      || constant_pool_expr_p (XVECEXP (tocrel_base, 0, 0))\n \t      || mode == QImode\n@@ -11069,7 +11082,7 @@ rs6000_emit_move (rtx dest, rtx source, machine_mode mode)\n \t\t\t   > (TARGET_CMODEL != CMODEL_SMALL ? 3 : 2)))\n \t\t   || (GET_CODE (operands[0]) == REG\n \t\t       && FP_REGNO_P (REGNO (operands[0]))))\n-\t       && !toc_relative_expr_p (operands[1], false)\n+\t       && !toc_relative_expr_p (operands[1], false, NULL, NULL)\n \t       && (TARGET_CMODEL == CMODEL_SMALL\n \t\t   || can_create_pseudo_p ()\n \t\t   || (REG_P (operands[0])\n@@ -21812,14 +21825,14 @@ print_operand (FILE *file, rtx x, int code)\n \t}\n       else\n \t{\n-\t  if (toc_relative_expr_p (x, false))\n+\t  if (toc_relative_expr_p (x, false, &tocrel_base_oac, &tocrel_offset_oac))\n \t    /* This hack along with a corresponding hack in\n \t       rs6000_output_addr_const_extra arranges to output addends\n \t       where the assembler expects to find them.  eg.\n \t       (plus (unspec [(symbol_ref (\"x\")) (reg 2)] tocrel) 4)\n \t       without this hack would be output as \"x@toc+4\".  We\n \t       want \"x+4@toc\".  */\n-\t    output_addr_const (file, CONST_CAST_RTX (tocrel_base));\n+\t    output_addr_const (file, CONST_CAST_RTX (tocrel_base_oac));\n \t  else\n \t    output_addr_const (file, x);\n \t}\n@@ -21886,7 +21899,7 @@ print_operand_address (FILE *file, rtx x)\n       fprintf (file, \"@l(%s)\", reg_names[ REGNO (XEXP (x, 0)) ]);\n     }\n #endif\n-  else if (toc_relative_expr_p (x, false))\n+  else if (toc_relative_expr_p (x, false, &tocrel_base_oac, &tocrel_offset_oac))\n     {\n       /* This hack along with a corresponding hack in\n \t rs6000_output_addr_const_extra arranges to output addends\n@@ -21895,17 +21908,17 @@ print_operand_address (FILE *file, rtx x)\n \t .       (plus (unspec [(symbol_ref (\"x\")) (reg 2)] tocrel) 8))\n \t without this hack would be output as \"x@toc+8@l(9)\".  We\n \t want \"x+8@toc@l(9)\".  */\n-      output_addr_const (file, CONST_CAST_RTX (tocrel_base));\n+      output_addr_const (file, CONST_CAST_RTX (tocrel_base_oac));\n       if (GET_CODE (x) == LO_SUM)\n \tfprintf (file, \"@l(%s)\", reg_names[REGNO (XEXP (x, 0))]);\n       else\n-\tfprintf (file, \"(%s)\", reg_names[REGNO (XVECEXP (tocrel_base, 0, 1))]);\n+\tfprintf (file, \"(%s)\", reg_names[REGNO (XVECEXP (tocrel_base_oac, 0, 1))]);\n     }\n   else\n     gcc_unreachable ();\n }\n \f\n-/* Implement TARGET_OUTPUT_ADDR_CONST_EXTRA.  */\n+/* Implement TARGET_ASM_OUTPUT_ADDR_CONST_EXTRA.  */\n \n static bool\n rs6000_output_addr_const_extra (FILE *file, rtx x)\n@@ -21918,11 +21931,11 @@ rs6000_output_addr_const_extra (FILE *file, rtx x)\n \t\t\t     && REG_P (XVECEXP (x, 0, 1))\n \t\t\t     && REGNO (XVECEXP (x, 0, 1)) == TOC_REGISTER);\n \toutput_addr_const (file, XVECEXP (x, 0, 0));\n-\tif (x == tocrel_base && tocrel_offset != const0_rtx)\n+\tif (x == tocrel_base_oac && tocrel_offset_oac != const0_rtx)\n \t  {\n-\t    if (INTVAL (tocrel_offset) >= 0)\n+\t    if (INTVAL (tocrel_offset_oac) >= 0)\n \t      fprintf (file, \"+\");\n-\t    output_addr_const (file, CONST_CAST_RTX (tocrel_offset));\n+\t    output_addr_const (file, CONST_CAST_RTX (tocrel_offset_oac));\n \t  }\n \tif (!TARGET_AIX || (TARGET_ELF && TARGET_MINIMAL_TOC))\n \t  {\n@@ -39312,6 +39325,8 @@ const_load_sequence_p (swap_web_entry *insn_entry, rtx insn)\n   if (!insn_entry[uid].is_swap || insn_entry[uid].is_load)\n     return false;\n \n+  const_rtx tocrel_base;\n+\n   /* Find the unique use in the swap and locate its def.  If the def\n      isn't unique, punt.  */\n   struct df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n@@ -39357,7 +39372,7 @@ const_load_sequence_p (swap_web_entry *insn_entry, rtx insn)\n \t  rtx tocrel_expr = SET_SRC (tocrel_body);\n \t  if (GET_CODE (tocrel_expr) == MEM)\n \t    tocrel_expr = XEXP (tocrel_expr, 0);\n-\t  if (!toc_relative_expr_p (tocrel_expr, false))\n+\t  if (!toc_relative_expr_p (tocrel_expr, false, &tocrel_base, NULL))\n \t    return false;\n \t  split_const (XVECEXP (tocrel_base, 0, 0), &base, &offset);\n \t  if (GET_CODE (base) != SYMBOL_REF || !CONSTANT_POOL_ADDRESS_P (base))\n@@ -40118,11 +40133,12 @@ adjust_vperm (rtx_insn *insn)\n      to set tocrel_base; otherwise it would be unnecessary as we've\n      already established it will return true.  */\n   rtx base, offset;\n+  const_rtx tocrel_base;\n   rtx tocrel_expr = SET_SRC (PATTERN (tocrel_insn));\n   /* There is an extra level of indirection for small/large code models.  */\n   if (GET_CODE (tocrel_expr) == MEM)\n     tocrel_expr = XEXP (tocrel_expr, 0);\n-  if (!toc_relative_expr_p (tocrel_expr, false))\n+  if (!toc_relative_expr_p (tocrel_expr, false, &tocrel_base, NULL))\n     gcc_unreachable ();\n   split_const (XVECEXP (tocrel_base, 0, 0), &base, &offset);\n   rtx const_vector = get_pool_constant (base);"}]}