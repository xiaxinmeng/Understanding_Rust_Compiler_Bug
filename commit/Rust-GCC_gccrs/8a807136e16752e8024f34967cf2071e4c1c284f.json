{"sha": "8a807136e16752e8024f34967cf2071e4c1c284f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGE4MDcxMzZlMTY3NTJlODAyNGYzNDk2N2NmMjA3MWU0YzFjMjg0Zg==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "rakdver@atrey.karlin.mff.cuni.cz", "date": "2004-07-17T18:08:10Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2004-07-17T18:08:10Z"}, "message": "loop-init.c (loop_optimizer_init, [...]): Do not destroy dominance information.\n\n\t* loop-init.c (loop_optimizer_init, loop_optimizer_finalize): Do not\n\tdestroy dominance information.\n\t* passes.c (rest_of_handle_loop2):  Free dominance information.\n\t* tree-cfg.c (cleanup_tree_cfg): Remove unreachable blocks before\n\tjump threading.\n\t(thread_jumps): Update dominance information and remove unreachable\n\tblocks.\n\t* tree-ssa-phiopt.c (replace_phi_with_stmt):  Update dominance\n\tinformation and remove the unreachable block.\n\nFrom-SVN: r84873", "tree": {"sha": "f9b4d8d5ff8c3cf2b8b7d8b0817c4d09fca2073d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f9b4d8d5ff8c3cf2b8b7d8b0817c4d09fca2073d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8a807136e16752e8024f34967cf2071e4c1c284f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a807136e16752e8024f34967cf2071e4c1c284f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a807136e16752e8024f34967cf2071e4c1c284f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a807136e16752e8024f34967cf2071e4c1c284f/comments", "author": null, "committer": null, "parents": [{"sha": "0e242c8215a01f83fd09116711e8ec13e5341d93", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e242c8215a01f83fd09116711e8ec13e5341d93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e242c8215a01f83fd09116711e8ec13e5341d93"}], "stats": {"total": 79, "additions": 68, "deletions": 11}, "files": [{"sha": "c86cd8e7a5ee4a068006616e90882e02abbf3bb3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a807136e16752e8024f34967cf2071e4c1c284f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a807136e16752e8024f34967cf2071e4c1c284f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8a807136e16752e8024f34967cf2071e4c1c284f", "patch": "@@ -1,3 +1,15 @@\n+2004-07-17  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n+\n+\t* loop-init.c (loop_optimizer_init, loop_optimizer_finalize): Do not\n+\tdestroy dominance information.\n+\t* passes.c (rest_of_handle_loop2):  Free dominance information.\n+\t* tree-cfg.c (cleanup_tree_cfg): Remove unreachable blocks before\n+\tjump threading.\n+\t(thread_jumps): Update dominance information and remove unreachable\n+\tblocks.\n+\t* tree-ssa-phiopt.c (replace_phi_with_stmt):  Update dominance\n+\tinformation and remove the unreachable block.\n+\n 2004-07-17  Graham Stott  <graham.stott@btinternet.com>\n \n \t* emit-rtl.c (reorder_insns): Don't set BB for a BARRIER insn."}, {"sha": "35fa12ea3e64b4884bca9d44e8ea04024bd37436", "filename": "gcc/loop-init.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a807136e16752e8024f34967cf2071e4c1c284f/gcc%2Floop-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a807136e16752e8024f34967cf2071e4c1c284f/gcc%2Floop-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-init.c?ref=8a807136e16752e8024f34967cf2071e4c1c284f", "patch": "@@ -55,7 +55,6 @@ loop_optimizer_init (FILE *dumpfile)\n     {\n       /* No loops.  */\n       flow_loops_free (loops);\n-      free_dominance_info (CDI_DOMINATORS);\n       free (loops);\n \n       return NULL;\n@@ -105,7 +104,6 @@ loop_optimizer_finalize (struct loops *loops, FILE *dumpfile)\n \n   /* Clean up.  */\n   flow_loops_free (loops);\n-  free_dominance_info (CDI_DOMINATORS);\n   free (loops);\n \n   /* Checking.  */"}, {"sha": "108d18583adbdb4824e03f79ea65aca1e3c57d77", "filename": "gcc/passes.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a807136e16752e8024f34967cf2071e4c1c284f/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a807136e16752e8024f34967cf2071e4c1c284f/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=8a807136e16752e8024f34967cf2071e4c1c284f", "patch": "@@ -1380,6 +1380,8 @@ rest_of_handle_loop2 (void)\n       loop_optimizer_finalize (loops, dump_file);\n     }\n \n+  free_dominance_info (CDI_DOMINATORS);\n+\n   /* Finalize layout changes.  */\n   FOR_EACH_BB (bb)\n     if (bb->next_bb != EXIT_BLOCK_PTR)"}, {"sha": "c80dcf1d086c97cf3106dcd8e98c4fd543111d78", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 46, "deletions": 5, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a807136e16752e8024f34967cf2071e4c1c284f/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a807136e16752e8024f34967cf2071e4c1c284f/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=8a807136e16752e8024f34967cf2071e4c1c284f", "patch": "@@ -733,8 +733,8 @@ cleanup_tree_cfg (void)\n   while (something_changed)\n     {\n       something_changed = cleanup_control_flow ();\n-      something_changed |= thread_jumps ();\n       something_changed |= delete_unreachable_blocks ();\n+      something_changed |= thread_jumps ();\n     }\n \n   /* Merging the blocks creates no new opportunities for the other\n@@ -3904,7 +3904,7 @@ static bool\n thread_jumps (void)\n {\n   edge e, next, last, old;\n-  basic_block bb, dest, tmp;\n+  basic_block bb, dest, tmp, old_dest, dom;\n   tree phi;\n   int arg;\n   bool retval = false;\n@@ -3991,11 +3991,9 @@ thread_jumps (void)\n \n \t  /* Perform the redirection.  */\n \t  retval = true;\n+\t  old_dest = e->dest;\n \t  e = redirect_edge_and_branch (e, dest);\n \n-\t  /* TODO -- updating dominators in this case is simple.  */\n-\t  free_dominance_info (CDI_DOMINATORS);\n-\n \t  if (!old)\n \t    {\n \t      /* Update PHI nodes.   We know that the new argument should\n@@ -4009,6 +4007,49 @@ thread_jumps (void)\n \t\t  add_phi_arg (&phi, PHI_ARG_DEF (phi, arg), e);\n \t\t}\n \t    }\n+\n+\t  /* Update the dominators.  */\n+\t  if (dom_computed[CDI_DOMINATORS] >= DOM_CONS_OK)\n+\t    {\n+\t      /* Remove the unreachable blocks (observe that if all blocks\n+\t\t were reachable before, only those in the path we threaded\n+\t\t over and did not have any predecessor outside of the path\n+\t\t become unreachable).  */\n+\t      for (; old_dest != dest; old_dest = tmp)\n+\t\t{\n+\t\t  tmp = old_dest->succ->dest;\n+\n+\t\t  if (old_dest->pred)\n+\t\t    break;\n+\n+\t\t  delete_basic_block (old_dest);\n+\t\t}\n+\t      /* If the dominator of the destination was in the path, set its\n+\t\t dominator to the start of the redirected edge.  */\n+\t      if (get_immediate_dominator (CDI_DOMINATORS, old_dest) == NULL)\n+\t\tset_immediate_dominator (CDI_DOMINATORS, old_dest, bb);\n+\n+\t      /* Now proceed like if we forwarded just over one edge at a time.\n+\t\t Algorithm for forwarding over edge A --> B then is\n+\n+\t\t if (idom (B) == A)\n+\t\t   idom (B) = idom (A);\n+\t\t recount_idom (A);  */\n+\n+\t      for (; old_dest != dest; old_dest = tmp)\n+\t\t{\n+\t\t  tmp = old_dest->succ->dest;\n+\n+\t\t  if (get_immediate_dominator (CDI_DOMINATORS, tmp) == old_dest)\n+\t\t    {\n+\t\t      dom = get_immediate_dominator (CDI_DOMINATORS, old_dest);\n+  \t\t      set_immediate_dominator (CDI_DOMINATORS, tmp, dom);\n+\t\t    }\n+\n+\t\t  dom = recount_dominator (CDI_DOMINATORS, old_dest);\n+\t\t  set_immediate_dominator (CDI_DOMINATORS, old_dest, dom);\n+\t\t}\n+\t    }\n \t}\n \n       /* Reset the forwardable bit on our block since it's no longer in"}, {"sha": "50c845e76379bb61800f271b03c653a3600bbb6c", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a807136e16752e8024f34967cf2071e4c1c284f/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a807136e16752e8024f34967cf2071e4c1c284f/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=8a807136e16752e8024f34967cf2071e4c1c284f", "patch": "@@ -236,6 +236,8 @@ static void\n replace_phi_with_stmt (block_stmt_iterator bsi, basic_block bb,\n \t\t       basic_block cond_block, tree phi, tree new)\n {\n+  basic_block block_to_remove;\n+\n   /* Insert our new statement at the head of our block.  */\n   bsi_insert_after (&bsi, new, BSI_NEW_STMT);\n   \n@@ -250,21 +252,23 @@ replace_phi_with_stmt (block_stmt_iterator bsi, basic_block bb,\n   release_phi_node (phi);\n   bb_ann (bb)->phi_nodes = NULL;\n   \n-  /* Disconnect the edge leading into the empty block.  That will\n-     make the empty block unreachable and it will be removed later.  */\n+  /* Remove the empty basic block.  */\n   if (cond_block->succ->dest == bb)\n     {\n       cond_block->succ->flags |= EDGE_FALLTHRU;\n       cond_block->succ->flags &= ~(EDGE_TRUE_VALUE | EDGE_FALSE_VALUE);\n-      ssa_remove_edge (cond_block->succ->succ_next);\n+\n+      block_to_remove = cond_block->succ->succ_next->dest;\n     }\n   else\n     {\n       cond_block->succ->succ_next->flags |= EDGE_FALLTHRU;\n       cond_block->succ->succ_next->flags\n \t&= ~(EDGE_TRUE_VALUE | EDGE_FALSE_VALUE);\n-      ssa_remove_edge (cond_block->succ);\n+\n+      block_to_remove = cond_block->succ->dest;\n     }\n+  delete_basic_block (block_to_remove);\n   \n   /* Eliminate the COND_EXPR at the end of COND_BLOCK.  */\n   bsi = bsi_last (cond_block);"}]}