{"sha": "58f7dab40db417ab669a0a1e146aa6e3227e3989", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NThmN2RhYjQwZGI0MTdhYjY2OWEwYTFlMTQ2YWE2ZTMyMjdlMzk4OQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-10-13T15:24:50Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-10-13T15:24:50Z"}, "message": "runtime: copy mstats code from Go 1.7 runtime\n    \n    This replaces mem.go and the C runtime_ReadMemStats function with the Go\n    1.7 mstats.go.\n    \n    The GCStats code is commented out for now.  The corresponding gccgo code\n    is in runtime/mgc0.c.\n    \n    The variables memstats and worldsema are shared between the Go code and\n    the C code, but are not exported.  To make this work, add temporary\n    accessor functions acquireWorldsema, releaseWorldsema, getMstats (the\n    latter known as mstats in the C code).\n    \n    Check the preemptoff field of m when allocating and when considering\n    whether to start a GC.  This works with the new stopTheWorld and\n    startTheWorld functions in Go, which are essentially the Go 1.7\n    versions.\n    \n    Change the compiler to stack allocate closures when compiling the\n    runtime package.  Within the runtime packages closures do not escape.\n    This is similar to what the gc compiler does, except that the gc\n    compiler, when compiling the runtime package, gives an error if escape\n    analysis shows that a closure does escape.  I added this here because\n    the Go version of ReadMemStats calls systemstack with a closure, and\n    having that allocate memory was causing some tests that measure memory\n    allocations to fail.\n    \n    Reviewed-on: https://go-review.googlesource.com/30972\n\nFrom-SVN: r241124", "tree": {"sha": "d5aaac15d5bd0d4b125140016f3ea84a714e3713", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d5aaac15d5bd0d4b125140016f3ea84a714e3713"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/58f7dab40db417ab669a0a1e146aa6e3227e3989", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58f7dab40db417ab669a0a1e146aa6e3227e3989", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58f7dab40db417ab669a0a1e146aa6e3227e3989", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58f7dab40db417ab669a0a1e146aa6e3227e3989/comments", "author": null, "committer": null, "parents": [{"sha": "5b1548fd79423c451b96f897701dc4aa51131b86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b1548fd79423c451b96f897701dc4aa51131b86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b1548fd79423c451b96f897701dc4aa51131b86"}], "stats": {"total": 1018, "additions": 668, "deletions": 350}, "files": [{"sha": "0a116a835e94b856af2a18539ba77bc22c8b0e5c", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58f7dab40db417ab669a0a1e146aa6e3227e3989/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58f7dab40db417ab669a0a1e146aa6e3227e3989/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=58f7dab40db417ab669a0a1e146aa6e3227e3989", "patch": "@@ -1,4 +1,4 @@\n-6c9070324d5b7c8483bc7c17b0a8faaa1fb1ae30\n+681580a3afc687ba3ff9ef240c67e8630e4306e6\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "b7411d14ffa4c628f8f45966a8e83aa51678fde5", "filename": "gcc/go/gofrontend/parse.cc", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58f7dab40db417ab669a0a1e146aa6e3227e3989/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58f7dab40db417ab669a0a1e146aa6e3227e3989/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fparse.cc?ref=58f7dab40db417ab669a0a1e146aa6e3227e3989", "patch": "@@ -3026,6 +3026,21 @@ Parse::create_closure(Named_object* function, Enclosing_vars* enclosing_vars,\n   Struct_type* st = closure_var->var_value()->type()->deref()->struct_type();\n   Expression* cv = Expression::make_struct_composite_literal(st, initializer,\n \t\t\t\t\t\t\t     location);\n+\n+  // When compiling the runtime, closures do not escape.  When escape\n+  // analysis becomes the default, and applies to closures, this\n+  // should be changed to make it an error if a closure escapes.\n+  if (this->gogo_->compiling_runtime()\n+      && this->gogo_->package_name() == \"runtime\")\n+    {\n+      Temporary_statement* ctemp = Statement::make_temporary(st, cv, location);\n+      this->gogo_->add_statement(ctemp);\n+      Expression* ref = Expression::make_temporary_reference(ctemp, location);\n+      Expression* addr = Expression::make_unary(OPERATOR_AND, ref, location);\n+      addr->unary_expression()->set_does_not_escape();\n+      return addr;\n+    }\n+\n   return Expression::make_heap_expression(cv, location);\n }\n "}, {"sha": "b41d741b93d404a3030c2fd2672ce9ad638aeba0", "filename": "libgo/go/runtime/mem.go", "status": "removed", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b1548fd79423c451b96f897701dc4aa51131b86/libgo%2Fgo%2Fruntime%2Fmem.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b1548fd79423c451b96f897701dc4aa51131b86/libgo%2Fgo%2Fruntime%2Fmem.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmem.go?ref=5b1548fd79423c451b96f897701dc4aa51131b86", "patch": "@@ -1,77 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package runtime\n-\n-import \"unsafe\"\n-\n-// Note: the MemStats struct should be kept in sync with\n-// struct MStats in malloc.h\n-\n-// A MemStats records statistics about the memory allocator.\n-type MemStats struct {\n-\t// General statistics.\n-\tAlloc      uint64 // bytes allocated and still in use\n-\tTotalAlloc uint64 // bytes allocated (even if freed)\n-\tSys        uint64 // bytes obtained from system (sum of XxxSys below)\n-\tLookups    uint64 // number of pointer lookups\n-\tMallocs    uint64 // number of mallocs\n-\tFrees      uint64 // number of frees\n-\n-\t// Main allocation heap statistics.\n-\tHeapAlloc    uint64 // bytes allocated and still in use\n-\tHeapSys      uint64 // bytes obtained from system\n-\tHeapIdle     uint64 // bytes in idle spans\n-\tHeapInuse    uint64 // bytes in non-idle span\n-\tHeapReleased uint64 // bytes released to the OS\n-\tHeapObjects  uint64 // total number of allocated objects\n-\n-\t// Low-level fixed-size structure allocator statistics.\n-\t//\tInuse is bytes used now.\n-\t//\tSys is bytes obtained from system.\n-\tStackInuse  uint64 // bootstrap stacks\n-\tStackSys    uint64\n-\tMSpanInuse  uint64 // mspan structures\n-\tMSpanSys    uint64\n-\tMCacheInuse uint64 // mcache structures\n-\tMCacheSys   uint64\n-\tBuckHashSys uint64 // profiling bucket hash table\n-\tGCSys       uint64 // GC metadata\n-\tOtherSys    uint64 // other system allocations\n-\n-\t// Garbage collector statistics.\n-\tNextGC        uint64 // next run in HeapAlloc time (bytes)\n-\tLastGC        uint64 // last run in absolute time (ns)\n-\tPauseTotalNs  uint64\n-\tPauseNs       [256]uint64 // circular buffer of recent GC pause times, most recent at [(NumGC+255)%256]\n-\tPauseEnd      [256]uint64 // circular buffer of recent GC pause end times\n-\tNumGC         uint32\n-\tGCCPUFraction float64 // fraction of CPU time used by GC\n-\tEnableGC      bool\n-\tDebugGC       bool\n-\n-\t// Per-size allocation statistics.\n-\t// 61 is NumSizeClasses in the C code.\n-\tBySize [61]struct {\n-\t\tSize    uint32\n-\t\tMallocs uint64\n-\t\tFrees   uint64\n-\t}\n-}\n-\n-var Sizeof_C_MStats uintptr // filled in by malloc.goc\n-\n-func init() {\n-\tvar memStats MemStats\n-\tif Sizeof_C_MStats != unsafe.Sizeof(memStats) {\n-\t\tprintln(Sizeof_C_MStats, unsafe.Sizeof(memStats))\n-\t\tpanic(\"MStats vs MemStatsType size mismatch\")\n-\t}\n-}\n-\n-// ReadMemStats populates m with memory allocator statistics.\n-func ReadMemStats(m *MemStats)\n-\n-// GC runs a garbage collection.\n-func GC()"}, {"sha": "6ec268d421cfe882850ddf61d1243d5e273717b5", "filename": "libgo/go/runtime/mstats.go", "status": "added", "additions": 418, "deletions": 0, "changes": 418, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58f7dab40db417ab669a0a1e146aa6e3227e3989/libgo%2Fgo%2Fruntime%2Fmstats.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58f7dab40db417ab669a0a1e146aa6e3227e3989/libgo%2Fgo%2Fruntime%2Fmstats.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmstats.go?ref=58f7dab40db417ab669a0a1e146aa6e3227e3989", "patch": "@@ -0,0 +1,418 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Memory statistics\n+\n+package runtime\n+\n+import (\n+\t\"runtime/internal/atomic\"\n+\t\"runtime/internal/sys\"\n+\t\"unsafe\"\n+)\n+\n+// Statistics.\n+// If you edit this structure, also edit type MemStats below.\n+type mstats struct {\n+\t// General statistics.\n+\talloc       uint64 // bytes allocated and not yet freed\n+\ttotal_alloc uint64 // bytes allocated (even if freed)\n+\tsys         uint64 // bytes obtained from system (should be sum of xxx_sys below, no locking, approximate)\n+\tnlookup     uint64 // number of pointer lookups\n+\tnmalloc     uint64 // number of mallocs\n+\tnfree       uint64 // number of frees\n+\n+\t// Statistics about malloc heap.\n+\t// protected by mheap.lock\n+\theap_alloc    uint64 // bytes allocated and not yet freed (same as alloc above)\n+\theap_sys      uint64 // bytes obtained from system\n+\theap_idle     uint64 // bytes in idle spans\n+\theap_inuse    uint64 // bytes in non-idle spans\n+\theap_released uint64 // bytes released to the os\n+\theap_objects  uint64 // total number of allocated objects\n+\n+\t// Statistics about allocation of low-level fixed-size structures.\n+\t// Protected by FixAlloc locks.\n+\tstacks_inuse uint64 // this number is included in heap_inuse above\n+\tstacks_sys   uint64 // always 0 in mstats\n+\tmspan_inuse  uint64 // mspan structures\n+\tmspan_sys    uint64\n+\tmcache_inuse uint64 // mcache structures\n+\tmcache_sys   uint64\n+\tbuckhash_sys uint64 // profiling bucket hash table\n+\tgc_sys       uint64\n+\tother_sys    uint64\n+\n+\t// Statistics about garbage collector.\n+\t// Protected by mheap or stopping the world during GC.\n+\tnext_gc         uint64 // next gc (in heap_live time)\n+\tlast_gc         uint64 // last gc (in absolute time)\n+\tpause_total_ns  uint64\n+\tpause_ns        [256]uint64 // circular buffer of recent gc pause lengths\n+\tpause_end       [256]uint64 // circular buffer of recent gc end times (nanoseconds since 1970)\n+\tnumgc           uint32\n+\tgc_cpu_fraction float64 // fraction of CPU time used by GC\n+\tenablegc        bool\n+\tdebuggc         bool\n+\n+\t// Statistics about allocation size classes.\n+\n+\tby_size [_NumSizeClasses]struct {\n+\t\tsize    uint32\n+\t\tnmalloc uint64\n+\t\tnfree   uint64\n+\t}\n+\n+\t// Statistics below here are not exported to Go directly.\n+\n+\ttinyallocs uint64 // number of tiny allocations that didn't cause actual allocation; not exported to go directly\n+\n+\t// heap_live is the number of bytes considered live by the GC.\n+\t// That is: retained by the most recent GC plus allocated\n+\t// since then. heap_live <= heap_alloc, since heap_alloc\n+\t// includes unmarked objects that have not yet been swept (and\n+\t// hence goes up as we allocate and down as we sweep) while\n+\t// heap_live excludes these objects (and hence only goes up\n+\t// between GCs).\n+\t//\n+\t// This is updated atomically without locking. To reduce\n+\t// contention, this is updated only when obtaining a span from\n+\t// an mcentral and at this point it counts all of the\n+\t// unallocated slots in that span (which will be allocated\n+\t// before that mcache obtains another span from that\n+\t// mcentral). Hence, it slightly overestimates the \"true\" live\n+\t// heap size. It's better to overestimate than to\n+\t// underestimate because 1) this triggers the GC earlier than\n+\t// necessary rather than potentially too late and 2) this\n+\t// leads to a conservative GC rate rather than a GC rate that\n+\t// is potentially too low.\n+\t//\n+\t// Whenever this is updated, call traceHeapAlloc() and\n+\t// gcController.revise().\n+\theap_live uint64\n+\n+\t// heap_scan is the number of bytes of \"scannable\" heap. This\n+\t// is the live heap (as counted by heap_live), but omitting\n+\t// no-scan objects and no-scan tails of objects.\n+\t//\n+\t// Whenever this is updated, call gcController.revise().\n+\theap_scan uint64\n+\n+\t// heap_marked is the number of bytes marked by the previous\n+\t// GC. After mark termination, heap_live == heap_marked, but\n+\t// unlike heap_live, heap_marked does not change until the\n+\t// next mark termination.\n+\theap_marked uint64\n+\n+\t// heap_reachable is an estimate of the reachable heap bytes\n+\t// at the end of the previous GC.\n+\theap_reachable uint64\n+}\n+\n+var memstats mstats\n+\n+// A MemStats records statistics about the memory allocator.\n+type MemStats struct {\n+\t// General statistics.\n+\tAlloc      uint64 // bytes allocated and not yet freed\n+\tTotalAlloc uint64 // bytes allocated (even if freed)\n+\tSys        uint64 // bytes obtained from system (sum of XxxSys below)\n+\tLookups    uint64 // number of pointer lookups\n+\tMallocs    uint64 // number of mallocs\n+\tFrees      uint64 // number of frees\n+\n+\t// Main allocation heap statistics.\n+\tHeapAlloc    uint64 // bytes allocated and not yet freed (same as Alloc above)\n+\tHeapSys      uint64 // bytes obtained from system\n+\tHeapIdle     uint64 // bytes in idle spans\n+\tHeapInuse    uint64 // bytes in non-idle span\n+\tHeapReleased uint64 // bytes released to the OS\n+\tHeapObjects  uint64 // total number of allocated objects\n+\n+\t// Low-level fixed-size structure allocator statistics.\n+\t//\tInuse is bytes used now.\n+\t//\tSys is bytes obtained from system.\n+\tStackInuse  uint64 // bytes used by stack allocator\n+\tStackSys    uint64\n+\tMSpanInuse  uint64 // mspan structures\n+\tMSpanSys    uint64\n+\tMCacheInuse uint64 // mcache structures\n+\tMCacheSys   uint64\n+\tBuckHashSys uint64 // profiling bucket hash table\n+\tGCSys       uint64 // GC metadata\n+\tOtherSys    uint64 // other system allocations\n+\n+\t// Garbage collector statistics.\n+\tNextGC        uint64 // next collection will happen when HeapAlloc \u2265 this amount\n+\tLastGC        uint64 // end time of last collection (nanoseconds since 1970)\n+\tPauseTotalNs  uint64\n+\tPauseNs       [256]uint64 // circular buffer of recent GC pause durations, most recent at [(NumGC+255)%256]\n+\tPauseEnd      [256]uint64 // circular buffer of recent GC pause end times\n+\tNumGC         uint32\n+\tGCCPUFraction float64 // fraction of CPU time used by GC\n+\tEnableGC      bool\n+\tDebugGC       bool\n+\n+\t// Per-size allocation statistics.\n+\t// 61 is NumSizeClasses in the C code.\n+\tBySize [61]struct {\n+\t\tSize    uint32\n+\t\tMallocs uint64\n+\t\tFrees   uint64\n+\t}\n+}\n+\n+// Size of the trailing by_size array differs between Go and C,\n+// and all data after by_size is local to runtime, not exported.\n+// NumSizeClasses was changed, but we cannot change Go struct because of backward compatibility.\n+// sizeof_C_MStats is what C thinks about size of Go struct.\n+var sizeof_C_MStats = unsafe.Offsetof(memstats.by_size) + 61*unsafe.Sizeof(memstats.by_size[0])\n+\n+func init() {\n+\tvar memStats MemStats\n+\tif sizeof_C_MStats != unsafe.Sizeof(memStats) {\n+\t\tprintln(sizeof_C_MStats, unsafe.Sizeof(memStats))\n+\t\tthrow(\"MStats vs MemStatsType size mismatch\")\n+\t}\n+}\n+\n+// ReadMemStats populates m with memory allocator statistics.\n+func ReadMemStats(m *MemStats) {\n+\tstopTheWorld(\"read mem stats\")\n+\n+\tsystemstack(func() {\n+\t\treadmemstats_m(m)\n+\t})\n+\n+\tstartTheWorld()\n+}\n+\n+func readmemstats_m(stats *MemStats) {\n+\tupdatememstats(nil)\n+\n+\t// Size of the trailing by_size array differs between Go and C,\n+\t// NumSizeClasses was changed, but we cannot change Go struct because of backward compatibility.\n+\tmemmove(unsafe.Pointer(stats), unsafe.Pointer(&memstats), sizeof_C_MStats)\n+\n+\t// Stack numbers are part of the heap numbers, separate those out for user consumption\n+\tstats.StackSys += stats.StackInuse\n+\tstats.HeapInuse -= stats.StackInuse\n+\tstats.HeapSys -= stats.StackInuse\n+}\n+\n+// For gccgo this is in runtime/mgc0.c.\n+func updatememstats(stats *gcstats)\n+\n+/*\n+For gccgo these are still in runtime/mgc0.c.\n+\n+//go:linkname readGCStats runtime/debug.readGCStats\n+func readGCStats(pauses *[]uint64) {\n+\tsystemstack(func() {\n+\t\treadGCStats_m(pauses)\n+\t})\n+}\n+\n+func readGCStats_m(pauses *[]uint64) {\n+\tp := *pauses\n+\t// Calling code in runtime/debug should make the slice large enough.\n+\tif cap(p) < len(memstats.pause_ns)+3 {\n+\t\tthrow(\"short slice passed to readGCStats\")\n+\t}\n+\n+\t// Pass back: pauses, pause ends, last gc (absolute time), number of gc, total pause ns.\n+\tlock(&mheap_.lock)\n+\n+\tn := memstats.numgc\n+\tif n > uint32(len(memstats.pause_ns)) {\n+\t\tn = uint32(len(memstats.pause_ns))\n+\t}\n+\n+\t// The pause buffer is circular. The most recent pause is at\n+\t// pause_ns[(numgc-1)%len(pause_ns)], and then backward\n+\t// from there to go back farther in time. We deliver the times\n+\t// most recent first (in p[0]).\n+\tp = p[:cap(p)]\n+\tfor i := uint32(0); i < n; i++ {\n+\t\tj := (memstats.numgc - 1 - i) % uint32(len(memstats.pause_ns))\n+\t\tp[i] = memstats.pause_ns[j]\n+\t\tp[n+i] = memstats.pause_end[j]\n+\t}\n+\n+\tp[n+n] = memstats.last_gc\n+\tp[n+n+1] = uint64(memstats.numgc)\n+\tp[n+n+2] = memstats.pause_total_ns\n+\tunlock(&mheap_.lock)\n+\t*pauses = p[:n+n+3]\n+}\n+\n+//go:nowritebarrier\n+func updatememstats(stats *gcstats) {\n+\tif stats != nil {\n+\t\t*stats = gcstats{}\n+\t}\n+\tfor mp := allm; mp != nil; mp = mp.alllink {\n+\t\tif stats != nil {\n+\t\t\tsrc := (*[unsafe.Sizeof(gcstats{}) / 8]uint64)(unsafe.Pointer(&mp.gcstats))\n+\t\t\tdst := (*[unsafe.Sizeof(gcstats{}) / 8]uint64)(unsafe.Pointer(stats))\n+\t\t\tfor i, v := range src {\n+\t\t\t\tdst[i] += v\n+\t\t\t}\n+\t\t\tmp.gcstats = gcstats{}\n+\t\t}\n+\t}\n+\n+\tmemstats.mcache_inuse = uint64(mheap_.cachealloc.inuse)\n+\tmemstats.mspan_inuse = uint64(mheap_.spanalloc.inuse)\n+\tmemstats.sys = memstats.heap_sys + memstats.stacks_sys + memstats.mspan_sys +\n+\t\tmemstats.mcache_sys + memstats.buckhash_sys + memstats.gc_sys + memstats.other_sys\n+\n+\t// Calculate memory allocator stats.\n+\t// During program execution we only count number of frees and amount of freed memory.\n+\t// Current number of alive object in the heap and amount of alive heap memory\n+\t// are calculated by scanning all spans.\n+\t// Total number of mallocs is calculated as number of frees plus number of alive objects.\n+\t// Similarly, total amount of allocated memory is calculated as amount of freed memory\n+\t// plus amount of alive heap memory.\n+\tmemstats.alloc = 0\n+\tmemstats.total_alloc = 0\n+\tmemstats.nmalloc = 0\n+\tmemstats.nfree = 0\n+\tfor i := 0; i < len(memstats.by_size); i++ {\n+\t\tmemstats.by_size[i].nmalloc = 0\n+\t\tmemstats.by_size[i].nfree = 0\n+\t}\n+\n+\t// Flush MCache's to MCentral.\n+\tsystemstack(flushallmcaches)\n+\n+\t// Aggregate local stats.\n+\tcachestats()\n+\n+\t// Scan all spans and count number of alive objects.\n+\tlock(&mheap_.lock)\n+\tfor i := uint32(0); i < mheap_.nspan; i++ {\n+\t\ts := h_allspans[i]\n+\t\tif s.state != mSpanInUse {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif s.sizeclass == 0 {\n+\t\t\tmemstats.nmalloc++\n+\t\t\tmemstats.alloc += uint64(s.elemsize)\n+\t\t} else {\n+\t\t\tmemstats.nmalloc += uint64(s.allocCount)\n+\t\t\tmemstats.by_size[s.sizeclass].nmalloc += uint64(s.allocCount)\n+\t\t\tmemstats.alloc += uint64(s.allocCount) * uint64(s.elemsize)\n+\t\t}\n+\t}\n+\tunlock(&mheap_.lock)\n+\n+\t// Aggregate by size class.\n+\tsmallfree := uint64(0)\n+\tmemstats.nfree = mheap_.nlargefree\n+\tfor i := 0; i < len(memstats.by_size); i++ {\n+\t\tmemstats.nfree += mheap_.nsmallfree[i]\n+\t\tmemstats.by_size[i].nfree = mheap_.nsmallfree[i]\n+\t\tmemstats.by_size[i].nmalloc += mheap_.nsmallfree[i]\n+\t\tsmallfree += mheap_.nsmallfree[i] * uint64(class_to_size[i])\n+\t}\n+\tmemstats.nfree += memstats.tinyallocs\n+\tmemstats.nmalloc += memstats.nfree\n+\n+\t// Calculate derived stats.\n+\tmemstats.total_alloc = memstats.alloc + mheap_.largefree + smallfree\n+\tmemstats.heap_alloc = memstats.alloc\n+\tmemstats.heap_objects = memstats.nmalloc - memstats.nfree\n+}\n+\n+//go:nowritebarrier\n+func cachestats() {\n+\tfor i := 0; ; i++ {\n+\t\tp := allp[i]\n+\t\tif p == nil {\n+\t\t\tbreak\n+\t\t}\n+\t\tc := p.mcache\n+\t\tif c == nil {\n+\t\t\tcontinue\n+\t\t}\n+\t\tpurgecachedstats(c)\n+\t}\n+}\n+\n+//go:nowritebarrier\n+func flushallmcaches() {\n+\tfor i := 0; ; i++ {\n+\t\tp := allp[i]\n+\t\tif p == nil {\n+\t\t\tbreak\n+\t\t}\n+\t\tc := p.mcache\n+\t\tif c == nil {\n+\t\t\tcontinue\n+\t\t}\n+\t\tc.releaseAll()\n+\t\tstackcache_clear(c)\n+\t}\n+}\n+\n+//go:nosplit\n+func purgecachedstats(c *mcache) {\n+\t// Protected by either heap or GC lock.\n+\th := &mheap_\n+\tmemstats.heap_scan += uint64(c.local_scan)\n+\tc.local_scan = 0\n+\tmemstats.tinyallocs += uint64(c.local_tinyallocs)\n+\tc.local_tinyallocs = 0\n+\tmemstats.nlookup += uint64(c.local_nlookup)\n+\tc.local_nlookup = 0\n+\th.largefree += uint64(c.local_largefree)\n+\tc.local_largefree = 0\n+\th.nlargefree += uint64(c.local_nlargefree)\n+\tc.local_nlargefree = 0\n+\tfor i := 0; i < len(c.local_nsmallfree); i++ {\n+\t\th.nsmallfree[i] += uint64(c.local_nsmallfree[i])\n+\t\tc.local_nsmallfree[i] = 0\n+\t}\n+}\n+\n+*/\n+\n+// Atomically increases a given *system* memory stat. We are counting on this\n+// stat never overflowing a uintptr, so this function must only be used for\n+// system memory stats.\n+//\n+// The current implementation for little endian architectures is based on\n+// xadduintptr(), which is less than ideal: xadd64() should really be used.\n+// Using xadduintptr() is a stop-gap solution until arm supports xadd64() that\n+// doesn't use locks.  (Locks are a problem as they require a valid G, which\n+// restricts their useability.)\n+//\n+// A side-effect of using xadduintptr() is that we need to check for\n+// overflow errors.\n+//go:nosplit\n+func mSysStatInc(sysStat *uint64, n uintptr) {\n+\tif sys.BigEndian != 0 {\n+\t\tatomic.Xadd64(sysStat, int64(n))\n+\t\treturn\n+\t}\n+\tif val := atomic.Xadduintptr((*uintptr)(unsafe.Pointer(sysStat)), n); val < n {\n+\t\tprint(\"runtime: stat overflow: val \", val, \", n \", n, \"\\n\")\n+\t\texit(2)\n+\t}\n+}\n+\n+// Atomically decreases a given *system* memory stat. Same comments as\n+// mSysStatInc apply.\n+//go:nosplit\n+func mSysStatDec(sysStat *uint64, n uintptr) {\n+\tif sys.BigEndian != 0 {\n+\t\tatomic.Xadd64(sysStat, -int64(n))\n+\t\treturn\n+\t}\n+\tif val := atomic.Xadduintptr((*uintptr)(unsafe.Pointer(sysStat)), uintptr(-int64(n))); val+n < n {\n+\t\tprint(\"runtime: stat underflow: val \", val, \", n \", n, \"\\n\")\n+\t\texit(2)\n+\t}\n+}"}, {"sha": "13fc5e5cb0f7966ac9fd5dde6f57e440e0faa130", "filename": "libgo/go/runtime/stubs.go", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58f7dab40db417ab669a0a1e146aa6e3227e3989/libgo%2Fgo%2Fruntime%2Fstubs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58f7dab40db417ab669a0a1e146aa6e3227e3989/libgo%2Fgo%2Fruntime%2Fstubs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fstubs.go?ref=58f7dab40db417ab669a0a1e146aa6e3227e3989", "patch": "@@ -367,3 +367,51 @@ func typeBitsBulkBarrier(typ *_type, p, size uintptr) {}\n \n // Here for gccgo until we port msize.go.\n func roundupsize(uintptr) uintptr\n+\n+// Here for gccgo until we port mgc.go.\n+func GC()\n+\n+// Here for gccgo until we port proc.go.\n+var worldsema uint32 = 1\n+\n+func stopTheWorldWithSema()\n+func startTheWorldWithSema()\n+\n+// For gccgo to call from C code.\n+//go:linkname acquireWorldsema runtime.acquireWorldsema\n+func acquireWorldsema() {\n+\tsemacquire(&worldsema, false)\n+}\n+\n+// For gccgo to call from C code.\n+//go:linkname releaseWorldsema runtime.releaseWorldsema\n+func releaseWorldsema() {\n+\tsemrelease(&worldsema)\n+}\n+\n+// Here for gccgo until we port proc.go.\n+func stopTheWorld(reason string) {\n+\tsemacquire(&worldsema, false)\n+\tgetg().m.preemptoff = reason\n+\tgetg().m.gcing = 1\n+\tsystemstack(stopTheWorldWithSema)\n+}\n+\n+// Here for gccgo until we port proc.go.\n+func startTheWorld() {\n+\tgetg().m.gcing = 0\n+\tgetg().m.locks++\n+\tsystemstack(startTheWorldWithSema)\n+\t// worldsema must be held over startTheWorldWithSema to ensure\n+\t// gomaxprocs cannot change while worldsema is held.\n+\tsemrelease(&worldsema)\n+\tgetg().m.preemptoff = \"\"\n+\tgetg().m.locks--\n+}\n+\n+// For gccgo to call from C code, so that the C code and the Go code\n+// can share the memstats variable for now.\n+//go:linkname getMstats runtime.getMstats\n+func getMstats() *mstats {\n+\treturn &memstats\n+}"}, {"sha": "123e074666db6e5b190f93af733d6170dc1772c1", "filename": "libgo/runtime/cpuprof.goc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58f7dab40db417ab669a0a1e146aa6e3227e3989/libgo%2Fruntime%2Fcpuprof.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58f7dab40db417ab669a0a1e146aa6e3227e3989/libgo%2Fruntime%2Fcpuprof.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fcpuprof.goc?ref=58f7dab40db417ab669a0a1e146aa6e3227e3989", "patch": "@@ -146,7 +146,7 @@ runtime_SetCPUProfileRate(intgo hz)\n \truntime_lock(&lk);\n \tif(hz > 0) {\n \t\tif(prof == nil) {\n-\t\t\tprof = runtime_SysAlloc(sizeof *prof, &mstats.other_sys);\n+\t\t\tprof = runtime_SysAlloc(sizeof *prof, &mstats()->other_sys);\n \t\t\tif(prof == nil) {\n \t\t\t\truntime_printf(\"runtime: cpu profiling cannot allocate memory\\n\");\n \t\t\t\truntime_unlock(&lk);"}, {"sha": "158ff5ee54e01ed14627dec1ab94f686ee56f1ec", "filename": "libgo/runtime/heapdump.c", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58f7dab40db417ab669a0a1e146aa6e3227e3989/libgo%2Fruntime%2Fheapdump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58f7dab40db417ab669a0a1e146aa6e3227e3989/libgo%2Fruntime%2Fheapdump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fheapdump.c?ref=58f7dab40db417ab669a0a1e146aa6e3227e3989", "patch": "@@ -489,33 +489,33 @@ dumpmemstats(void)\n \tint32 i;\n \n \tdumpint(TagMemStats);\n-\tdumpint(mstats.alloc);\n-\tdumpint(mstats.total_alloc);\n-\tdumpint(mstats.sys);\n-\tdumpint(mstats.nlookup);\n-\tdumpint(mstats.nmalloc);\n-\tdumpint(mstats.nfree);\n-\tdumpint(mstats.heap_alloc);\n-\tdumpint(mstats.heap_sys);\n-\tdumpint(mstats.heap_idle);\n-\tdumpint(mstats.heap_inuse);\n-\tdumpint(mstats.heap_released);\n-\tdumpint(mstats.heap_objects);\n-\tdumpint(mstats.stacks_inuse);\n-\tdumpint(mstats.stacks_sys);\n-\tdumpint(mstats.mspan_inuse);\n-\tdumpint(mstats.mspan_sys);\n-\tdumpint(mstats.mcache_inuse);\n-\tdumpint(mstats.mcache_sys);\n-\tdumpint(mstats.buckhash_sys);\n-\tdumpint(mstats.gc_sys);\n-\tdumpint(mstats.other_sys);\n-\tdumpint(mstats.next_gc);\n-\tdumpint(mstats.last_gc);\n-\tdumpint(mstats.pause_total_ns);\n+\tdumpint(mstats()->alloc);\n+\tdumpint(mstats()->total_alloc);\n+\tdumpint(mstats()->sys);\n+\tdumpint(mstats()->nlookup);\n+\tdumpint(mstats()->nmalloc);\n+\tdumpint(mstats()->nfree);\n+\tdumpint(mstats()->heap_alloc);\n+\tdumpint(mstats()->heap_sys);\n+\tdumpint(mstats()->heap_idle);\n+\tdumpint(mstats()->heap_inuse);\n+\tdumpint(mstats()->heap_released);\n+\tdumpint(mstats()->heap_objects);\n+\tdumpint(mstats()->stacks_inuse);\n+\tdumpint(mstats()->stacks_sys);\n+\tdumpint(mstats()->mspan_inuse);\n+\tdumpint(mstats()->mspan_sys);\n+\tdumpint(mstats()->mcache_inuse);\n+\tdumpint(mstats()->mcache_sys);\n+\tdumpint(mstats()->buckhash_sys);\n+\tdumpint(mstats()->gc_sys);\n+\tdumpint(mstats()->other_sys);\n+\tdumpint(mstats()->next_gc);\n+\tdumpint(mstats()->last_gc);\n+\tdumpint(mstats()->pause_total_ns);\n \tfor(i = 0; i < 256; i++)\n-\t\tdumpint(mstats.pause_ns[i]);\n-\tdumpint(mstats.numgc);\n+\t\tdumpint(mstats()->pause_ns[i]);\n+\tdumpint(mstats()->numgc);\n }\n \n static void\n@@ -615,11 +615,11 @@ runtime_debug_WriteHeapDump(uintptr fd)\n \tG *g;\n \n \t// Stop the world.\n-\truntime_semacquire(&runtime_worldsema, false);\n+\truntime_acquireWorldsema();\n \tm = runtime_m();\n \tm->gcing = 1;\n \tm->locks++;\n-\truntime_stoptheworld();\n+\truntime_stopTheWorldWithSema();\n \n \t// Update stats so we can dump them.\n \t// As a side effect, flushes all the MCaches so the MSpan.freelist\n@@ -640,8 +640,8 @@ runtime_debug_WriteHeapDump(uintptr fd)\n \n \t// Start up the world again.\n \tm->gcing = 0;\n-\truntime_semrelease(&runtime_worldsema);\n-\truntime_starttheworld();\n+\truntime_releaseWorldsema();\n+\truntime_startTheWorldWithSema();\n \tm->locks--;\n }\n "}, {"sha": "4f81d82f5b51e6c4af0cae8c5bbdfac9feee15c1", "filename": "libgo/runtime/malloc.goc", "status": "modified", "additions": 12, "deletions": 22, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58f7dab40db417ab669a0a1e146aa6e3227e3989/libgo%2Fruntime%2Fmalloc.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58f7dab40db417ab669a0a1e146aa6e3227e3989/libgo%2Fruntime%2Fmalloc.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmalloc.goc?ref=58f7dab40db417ab669a0a1e146aa6e3227e3989", "patch": "@@ -51,12 +51,9 @@ package runtime\n \n // Mark mheap as 'no pointers', it does not contain interesting pointers but occupies ~45K.\n MHeap runtime_mheap;\n-MStats mstats;\n \n int32\truntime_checking;\n \n-extern MStats mstats;\t// defined in zruntime_def_$GOOS_$GOARCH.go\n-\n extern volatile intgo runtime_MemProfileRate\n   __asm__ (GOSYM_PREFIX \"runtime.MemProfileRate\");\n \n@@ -81,6 +78,7 @@ runtime_mallocgc(uintptr size, uintptr typ, uint32 flag)\n \tMLink *v, *next;\n \tbyte *tiny;\n \tbool incallback;\n+\tMStats *pmstats;\n \n \tif(size == 0) {\n \t\t// All 0-length allocations use this pointer.\n@@ -105,7 +103,7 @@ runtime_mallocgc(uintptr size, uintptr typ, uint32 flag)\n \t\tflag |= FlagNoInvokeGC;\n \t}\n \n-\tif(runtime_gcwaiting() && g != m->g0 && m->locks == 0 && !(flag & FlagNoInvokeGC)) {\n+\tif(runtime_gcwaiting() && g != m->g0 && m->locks == 0 && !(flag & FlagNoInvokeGC) && m->preemptoff.len == 0) {\n \t\truntime_gosched();\n \t\tm = runtime_m();\n \t}\n@@ -252,7 +250,8 @@ runtime_mallocgc(uintptr size, uintptr typ, uint32 flag)\n \n \tm->locks--;\n \n-\tif(!(flag & FlagNoInvokeGC) && mstats.heap_alloc >= mstats.next_gc)\n+\tpmstats = mstats();\n+\tif(!(flag & FlagNoInvokeGC) && pmstats->heap_alloc >= pmstats->next_gc)\n \t\truntime_gc(0);\n \n \tif(incallback)\n@@ -472,9 +471,9 @@ runtime_purgecachedstats(MCache *c)\n \n \t// Protected by either heap or GC lock.\n \th = &runtime_mheap;\n-\tmstats.heap_alloc += (intptr)c->local_cachealloc;\n+\tmstats()->heap_alloc += (intptr)c->local_cachealloc;\n \tc->local_cachealloc = 0;\n-\tmstats.nlookup += c->local_nlookup;\n+\tmstats()->nlookup += c->local_nlookup;\n \tc->local_nlookup = 0;\n \th->largefree += c->local_largefree;\n \tc->local_largefree = 0;\n@@ -486,13 +485,6 @@ runtime_purgecachedstats(MCache *c)\n \t}\n }\n \n-extern uintptr runtime_sizeof_C_MStats\n-  __asm__ (GOSYM_PREFIX \"runtime.Sizeof_C_MStats\");\n-\n-// Size of the trailing by_size array differs between Go and C,\n-// _NumSizeClasses was changed, but we can not change Go struct because of backward compatibility.\n-// sizeof_C_MStats is what C thinks about size of Go struct.\n-\n // Initialized in mallocinit because it's defined in go/runtime/mem.go.\n \n #define MaxArena32 (2U<<30)\n@@ -508,8 +500,6 @@ runtime_mallocinit(void)\n \tuint64 i;\n \tbool reserved;\n \n-\truntime_sizeof_C_MStats = sizeof(MStats) - (_NumSizeClasses - 61) * sizeof(mstats.by_size[0]);\n-\n \tp = nil;\n \tp_size = 0;\n \tarena_size = 0;\n@@ -685,7 +675,7 @@ runtime_MHeap_SysAlloc(MHeap *h, uintptr n)\n \tif(n <= (uintptr)(h->arena_end - h->arena_used)) {\n \t\t// Keep taking from our reservation.\n \t\tp = h->arena_used;\n-\t\truntime_SysMap(p, n, h->arena_reserved, &mstats.heap_sys);\n+\t\truntime_SysMap(p, n, h->arena_reserved, &mstats()->heap_sys);\n \t\th->arena_used += n;\n \t\truntime_MHeap_MapBits(h);\n \t\truntime_MHeap_MapSpans(h);\n@@ -703,14 +693,14 @@ runtime_MHeap_SysAlloc(MHeap *h, uintptr n)\n \t// try to get memory at a location chosen by the OS\n \t// and hope that it is in the range we allocated bitmap for.\n \tp_size = ROUND(n, PageSize) + PageSize;\n-\tp = runtime_SysAlloc(p_size, &mstats.heap_sys);\n+\tp = runtime_SysAlloc(p_size, &mstats()->heap_sys);\n \tif(p == nil)\n \t\treturn nil;\n \n \tif(p < h->arena_start || (uintptr)(p+p_size - h->arena_start) >= MaxArena32) {\n \t\truntime_printf(\"runtime: memory allocated by OS (%p) not in usable range [%p,%p)\\n\",\n \t\t\tp, h->arena_start, h->arena_start+MaxArena32);\n-\t\truntime_SysFree(p, p_size, &mstats.heap_sys);\n+\t\truntime_SysFree(p, p_size, &mstats()->heap_sys);\n \t\treturn nil;\n \t}\n \t\n@@ -763,7 +753,7 @@ runtime_persistentalloc(uintptr size, uintptr align, uint64 *stat)\n \truntime_lock(&persistent);\n \tpersistent.pos = (byte*)ROUND((uintptr)persistent.pos, align);\n \tif(persistent.pos + size > persistent.end) {\n-\t\tpersistent.pos = runtime_SysAlloc(PersistentAllocChunk, &mstats.other_sys);\n+\t\tpersistent.pos = runtime_SysAlloc(PersistentAllocChunk, &mstats()->other_sys);\n \t\tif(persistent.pos == nil) {\n \t\t\truntime_unlock(&persistent);\n \t\t\truntime_throw(\"runtime: cannot allocate memory\");\n@@ -773,10 +763,10 @@ runtime_persistentalloc(uintptr size, uintptr align, uint64 *stat)\n \tp = persistent.pos;\n \tpersistent.pos += size;\n \truntime_unlock(&persistent);\n-\tif(stat != &mstats.other_sys) {\n+\tif(stat != &mstats()->other_sys) {\n \t\t// reaccount the allocation against provided stat\n \t\truntime_xadd64(stat, size);\n-\t\truntime_xadd64(&mstats.other_sys, -(uint64)size);\n+\t\truntime_xadd64(&mstats()->other_sys, -(uint64)size);\n \t}\n \treturn p;\n }"}, {"sha": "5e74b8c1f1abe43ebb4b6a7ebb0312199a589603", "filename": "libgo/runtime/malloc.h", "status": "modified", "additions": 5, "deletions": 58, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58f7dab40db417ab669a0a1e146aa6e3227e3989/libgo%2Fruntime%2Fmalloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58f7dab40db417ab669a0a1e146aa6e3227e3989/libgo%2Fruntime%2Fmalloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmalloc.h?ref=58f7dab40db417ab669a0a1e146aa6e3227e3989", "patch": "@@ -83,7 +83,7 @@\n typedef struct MCentral\tMCentral;\n typedef struct MHeap\tMHeap;\n typedef struct mspan\tMSpan;\n-typedef struct MStats\tMStats;\n+typedef struct mstats\tMStats;\n typedef struct mlink\tMLink;\n typedef struct mtypes\tMTypes;\n typedef struct gcstats\tGCStats;\n@@ -216,63 +216,10 @@ void\truntime_FixAlloc_Init(FixAlloc *f, uintptr size, void (*first)(void*, byte*\n void*\truntime_FixAlloc_Alloc(FixAlloc *f);\n void\truntime_FixAlloc_Free(FixAlloc *f, void *p);\n \n-\n-// Statistics.\n-// Shared with Go: if you edit this structure, also edit type MemStats in mem.go.\n-struct MStats\n-{\n-\t// General statistics.\n-\tuint64\talloc;\t\t// bytes allocated and still in use\n-\tuint64\ttotal_alloc;\t// bytes allocated (even if freed)\n-\tuint64\tsys;\t\t// bytes obtained from system (should be sum of xxx_sys below, no locking, approximate)\n-\tuint64\tnlookup;\t// number of pointer lookups\n-\tuint64\tnmalloc;\t// number of mallocs\n-\tuint64\tnfree;  // number of frees\n-\n-\t// Statistics about malloc heap.\n-\t// protected by mheap.Lock\n-\tuint64\theap_alloc;\t// bytes allocated and still in use\n-\tuint64\theap_sys;\t// bytes obtained from system\n-\tuint64\theap_idle;\t// bytes in idle spans\n-\tuint64\theap_inuse;\t// bytes in non-idle spans\n-\tuint64\theap_released;\t// bytes released to the OS\n-\tuint64\theap_objects;\t// total number of allocated objects\n-\n-\t// Statistics about allocation of low-level fixed-size structures.\n-\t// Protected by FixAlloc locks.\n-\tuint64\tstacks_inuse;\t// bootstrap stacks\n-\tuint64\tstacks_sys;\n-\tuint64\tmspan_inuse;\t// MSpan structures\n-\tuint64\tmspan_sys;\n-\tuint64\tmcache_inuse;\t// MCache structures\n-\tuint64\tmcache_sys;\n-\tuint64\tbuckhash_sys;\t// profiling bucket hash table\n-\tuint64\tgc_sys;\n-\tuint64\tother_sys;\n-\n-\t// Statistics about garbage collector.\n-\t// Protected by mheap or stopping the world during GC.\n-\tuint64\tnext_gc;\t// next GC (in heap_alloc time)\n-\tuint64  last_gc;\t// last GC (in absolute time)\n-\tuint64\tpause_total_ns;\n-\tuint64\tpause_ns[256];\n-\tuint64\tpause_end[256];\n-\tuint32\tnumgc;\n-\tfloat64\tgc_cpu_fraction;\n-\tbool\tenablegc;\n-\tbool\tdebuggc;\n-\n-\t// Statistics about allocation size classes.\n-\tstruct {\n-\t\tuint32 size;\n-\t\tuint64 nmalloc;\n-\t\tuint64 nfree;\n-\t} by_size[_NumSizeClasses];\n-};\n-\n-extern MStats mstats\n-  __asm__ (GOSYM_PREFIX \"runtime.memStats\");\n-void\truntime_updatememstats(GCStats *stats);\n+extern MStats *mstats(void)\n+  __asm__ (GOSYM_PREFIX \"runtime.getMstats\");\n+void\truntime_updatememstats(GCStats *stats)\n+  __asm__ (GOSYM_PREFIX \"runtime.updatememstats\");\n \n // Size classes.  Computed and initialized by InitSizes.\n //"}, {"sha": "853b5c7ae835fb997e3b333f589e8d69a9ffb0e5", "filename": "libgo/runtime/mem_posix_memalign.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58f7dab40db417ab669a0a1e146aa6e3227e3989/libgo%2Fruntime%2Fmem_posix_memalign.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58f7dab40db417ab669a0a1e146aa6e3227e3989/libgo%2Fruntime%2Fmem_posix_memalign.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmem_posix_memalign.c?ref=58f7dab40db417ab669a0a1e146aa6e3227e3989", "patch": "@@ -9,7 +9,7 @@ runtime_SysAlloc(uintptr n)\n {\n \tvoid *p;\n \n-\tmstats.sys += n;\n+\tmstats()->sys += n;\n \terrno = posix_memalign(&p, PageSize, n);\n \tif (errno > 0) {\n \t\tperror(\"posix_memalign\");\n@@ -29,7 +29,7 @@ runtime_SysUnused(void *v, uintptr n)\n void\n runtime_SysFree(void *v, uintptr n)\n {\n-\tmstats.sys -= n;\n+\tmstats()->sys -= n;\n \tfree(v);\n }\n "}, {"sha": "487767878282a6687b058ea7d7a18d340c5e4c04", "filename": "libgo/runtime/mgc0.c", "status": "modified", "additions": 69, "deletions": 106, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58f7dab40db417ab669a0a1e146aa6e3227e3989/libgo%2Fruntime%2Fmgc0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58f7dab40db417ab669a0a1e146aa6e3227e3989/libgo%2Fruntime%2Fmgc0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmgc0.c?ref=58f7dab40db417ab669a0a1e146aa6e3227e3989", "patch": "@@ -145,21 +145,6 @@ clearpools(void)\n \t}\n }\n \n-// Holding worldsema grants an M the right to try to stop the world.\n-// The procedure is:\n-//\n-//\truntime_semacquire(&runtime_worldsema);\n-//\tm->gcing = 1;\n-//\truntime_stoptheworld();\n-//\n-//\t... do stuff ...\n-//\n-//\tm->gcing = 0;\n-//\truntime_semrelease(&runtime_worldsema);\n-//\truntime_starttheworld();\n-//\n-uint32 runtime_worldsema = 1;\n-\n typedef struct Workbuf Workbuf;\n struct Workbuf\n {\n@@ -1377,7 +1362,7 @@ getempty(Workbuf *b)\n \t\truntime_lock(&work);\n \t\tif(work.nchunk < sizeof *b) {\n \t\t\twork.nchunk = 1<<20;\n-\t\t\twork.chunk = runtime_SysAlloc(work.nchunk, &mstats.gc_sys);\n+\t\t\twork.chunk = runtime_SysAlloc(work.nchunk, &mstats()->gc_sys);\n \t\t\tif(work.chunk == nil)\n \t\t\t\truntime_throw(\"runtime: cannot allocate memory\");\n \t\t}\n@@ -1558,7 +1543,7 @@ runtime_queuefinalizer(void *p, FuncVal *fn, const FuncType *ft, const PtrType *\n \truntime_lock(&finlock);\n \tif(finq == nil || finq->cnt == finq->cap) {\n \t\tif(finc == nil) {\n-\t\t\tfinc = runtime_persistentalloc(FinBlockSize, 0, &mstats.gc_sys);\n+\t\t\tfinc = runtime_persistentalloc(FinBlockSize, 0, &mstats()->gc_sys);\n \t\t\tfinc->cap = (FinBlockSize - sizeof(FinBlock)) / sizeof(Finalizer) + 1;\n \t\t\tfinc->alllink = allfin;\n \t\t\tallfin = finc;\n@@ -1755,7 +1740,7 @@ runtime_MSpan_Sweep(MSpan *s)\n \t\t\t\truntime_MHeap_Free(&runtime_mheap, s, 1);\n \t\t\tc->local_nlargefree++;\n \t\t\tc->local_largefree += size;\n-\t\t\truntime_xadd64(&mstats.next_gc, -(uint64)(size * (gcpercent + 100)/100));\n+\t\t\truntime_xadd64(&mstats()->next_gc, -(uint64)(size * (gcpercent + 100)/100));\n \t\t\tres = true;\n \t\t} else {\n \t\t\t// Free small object.\n@@ -1797,7 +1782,7 @@ runtime_MSpan_Sweep(MSpan *s)\n \tif(nfree > 0) {\n \t\tc->local_nsmallfree[cl] += nfree;\n \t\tc->local_cachealloc -= nfree * size;\n-\t\truntime_xadd64(&mstats.next_gc, -(uint64)(nfree * size * (gcpercent + 100)/100));\n+\t\truntime_xadd64(&mstats()->next_gc, -(uint64)(nfree * size * (gcpercent + 100)/100));\n \t\tres = runtime_MCentral_FreeSpan(&runtime_mheap.central[cl], s, nfree, head.next, end);\n \t\t//MCentral_FreeSpan updates sweepgen\n \t}\n@@ -2010,6 +1995,7 @@ runtime_updatememstats(GCStats *stats)\n \tuint32 i;\n \tuint64 stacks_inuse, smallfree;\n \tuint64 *src, *dst;\n+\tMStats *pmstats;\n \n \tif(stats)\n \t\truntime_memclr((byte*)stats, sizeof(*stats));\n@@ -2024,11 +2010,12 @@ runtime_updatememstats(GCStats *stats)\n \t\t\truntime_memclr((byte*)&mp->gcstats, sizeof(mp->gcstats));\n \t\t}\n \t}\n-\tmstats.stacks_inuse = stacks_inuse;\n-\tmstats.mcache_inuse = runtime_mheap.cachealloc.inuse;\n-\tmstats.mspan_inuse = runtime_mheap.spanalloc.inuse;\n-\tmstats.sys = mstats.heap_sys + mstats.stacks_sys + mstats.mspan_sys +\n-\t\tmstats.mcache_sys + mstats.buckhash_sys + mstats.gc_sys + mstats.other_sys;\n+\tpmstats = mstats();\n+\tpmstats->stacks_inuse = stacks_inuse;\n+\tpmstats->mcache_inuse = runtime_mheap.cachealloc.inuse;\n+\tpmstats->mspan_inuse = runtime_mheap.spanalloc.inuse;\n+\tpmstats->sys = pmstats->heap_sys + pmstats->stacks_sys + pmstats->mspan_sys +\n+\t\tpmstats->mcache_sys + pmstats->buckhash_sys + pmstats->gc_sys + pmstats->other_sys;\n \t\n \t// Calculate memory allocator stats.\n \t// During program execution we only count number of frees and amount of freed memory.\n@@ -2037,13 +2024,13 @@ runtime_updatememstats(GCStats *stats)\n \t// Total number of mallocs is calculated as number of frees plus number of alive objects.\n \t// Similarly, total amount of allocated memory is calculated as amount of freed memory\n \t// plus amount of alive heap memory.\n-\tmstats.alloc = 0;\n-\tmstats.total_alloc = 0;\n-\tmstats.nmalloc = 0;\n-\tmstats.nfree = 0;\n-\tfor(i = 0; i < nelem(mstats.by_size); i++) {\n-\t\tmstats.by_size[i].nmalloc = 0;\n-\t\tmstats.by_size[i].nfree = 0;\n+\tpmstats->alloc = 0;\n+\tpmstats->total_alloc = 0;\n+\tpmstats->nmalloc = 0;\n+\tpmstats->nfree = 0;\n+\tfor(i = 0; i < nelem(pmstats->by_size); i++) {\n+\t\tpmstats->by_size[i].nmalloc = 0;\n+\t\tpmstats->by_size[i].nfree = 0;\n \t}\n \n \t// Flush MCache's to MCentral.\n@@ -2058,30 +2045,30 @@ runtime_updatememstats(GCStats *stats)\n \t\tif(s->state != MSpanInUse)\n \t\t\tcontinue;\n \t\tif(s->sizeclass == 0) {\n-\t\t\tmstats.nmalloc++;\n-\t\t\tmstats.alloc += s->elemsize;\n+\t\t\tpmstats->nmalloc++;\n+\t\t\tpmstats->alloc += s->elemsize;\n \t\t} else {\n-\t\t\tmstats.nmalloc += s->ref;\n-\t\t\tmstats.by_size[s->sizeclass].nmalloc += s->ref;\n-\t\t\tmstats.alloc += s->ref*s->elemsize;\n+\t\t\tpmstats->nmalloc += s->ref;\n+\t\t\tpmstats->by_size[s->sizeclass].nmalloc += s->ref;\n+\t\t\tpmstats->alloc += s->ref*s->elemsize;\n \t\t}\n \t}\n \n \t// Aggregate by size class.\n \tsmallfree = 0;\n-\tmstats.nfree = runtime_mheap.nlargefree;\n-\tfor(i = 0; i < nelem(mstats.by_size); i++) {\n-\t\tmstats.nfree += runtime_mheap.nsmallfree[i];\n-\t\tmstats.by_size[i].nfree = runtime_mheap.nsmallfree[i];\n-\t\tmstats.by_size[i].nmalloc += runtime_mheap.nsmallfree[i];\n+\tpmstats->nfree = runtime_mheap.nlargefree;\n+\tfor(i = 0; i < nelem(pmstats->by_size); i++) {\n+\t\tpmstats->nfree += runtime_mheap.nsmallfree[i];\n+\t\tpmstats->by_size[i].nfree = runtime_mheap.nsmallfree[i];\n+\t\tpmstats->by_size[i].nmalloc += runtime_mheap.nsmallfree[i];\n \t\tsmallfree += runtime_mheap.nsmallfree[i] * runtime_class_to_size[i];\n \t}\n-\tmstats.nmalloc += mstats.nfree;\n+\tpmstats->nmalloc += pmstats->nfree;\n \n \t// Calculate derived stats.\n-\tmstats.total_alloc = mstats.alloc + runtime_mheap.largefree + smallfree;\n-\tmstats.heap_alloc = mstats.alloc;\n-\tmstats.heap_objects = mstats.nmalloc - mstats.nfree;\n+\tpmstats->total_alloc = pmstats->alloc + runtime_mheap.largefree + smallfree;\n+\tpmstats->heap_alloc = pmstats->alloc;\n+\tpmstats->heap_objects = pmstats->nmalloc - pmstats->nfree;\n }\n \n // Structure of arguments passed to function gc().\n@@ -2119,6 +2106,7 @@ runtime_gc(int32 force)\n \tG *g;\n \tstruct gc_args a;\n \tint32 i;\n+\tMStats *pmstats;\n \n \t// The atomic operations are not atomic if the uint64s\n \t// are not aligned on uint64 boundaries. This has been\n@@ -2141,7 +2129,8 @@ runtime_gc(int32 force)\n \t// while holding a lock.  The next mallocgc\n \t// without a lock will do the gc instead.\n \tm = runtime_m();\n-\tif(!mstats.enablegc || runtime_g() == m->g0 || m->locks > 0 || runtime_panicking)\n+\tpmstats = mstats();\n+\tif(!pmstats->enablegc || runtime_g() == m->g0 || m->locks > 0 || runtime_panicking || m->preemptoff.len > 0)\n \t\treturn;\n \n \tif(gcpercent == GcpercentUnknown) {\t// first time through\n@@ -2153,19 +2142,19 @@ runtime_gc(int32 force)\n \tif(gcpercent < 0)\n \t\treturn;\n \n-\truntime_semacquire(&runtime_worldsema, false);\n-\tif(force==0 && mstats.heap_alloc < mstats.next_gc) {\n+\truntime_acquireWorldsema();\n+\tif(force==0 && pmstats->heap_alloc < pmstats->next_gc) {\n \t\t// typically threads which lost the race to grab\n \t\t// worldsema exit here when gc is done.\n-\t\truntime_semrelease(&runtime_worldsema);\n+\t\truntime_releaseWorldsema();\n \t\treturn;\n \t}\n \n \t// Ok, we're doing it!  Stop everybody else\n \ta.start_time = runtime_nanotime();\n \ta.eagersweep = force >= 2;\n \tm->gcing = 1;\n-\truntime_stoptheworld();\n+\truntime_stopTheWorldWithSema();\n \t\n \tclearpools();\n \n@@ -2189,8 +2178,8 @@ runtime_gc(int32 force)\n \t// all done\n \tm->gcing = 0;\n \tm->locks++;\n-\truntime_semrelease(&runtime_worldsema);\n-\truntime_starttheworld();\n+\truntime_releaseWorldsema();\n+\truntime_startTheWorldWithSema();\n \tm->locks--;\n \n \t// now that gc is done, kick off finalizer thread if needed\n@@ -2220,6 +2209,7 @@ gc(struct gc_args *args)\n \tuint64 heap0, heap1, obj, ninstr;\n \tGCStats stats;\n \tuint32 i;\n+\tMStats *pmstats;\n \t// Eface eface;\n \n \tm = runtime_m();\n@@ -2275,28 +2265,29 @@ gc(struct gc_args *args)\n \tcachestats();\n \t// next_gc calculation is tricky with concurrent sweep since we don't know size of live heap\n \t// estimate what was live heap size after previous GC (for tracing only)\n-\theap0 = mstats.next_gc*100/(gcpercent+100);\n+\tpmstats = mstats();\n+\theap0 = pmstats->next_gc*100/(gcpercent+100);\n \t// conservatively set next_gc to high value assuming that everything is live\n \t// concurrent/lazy sweep will reduce this number while discovering new garbage\n-\tmstats.next_gc = mstats.heap_alloc+(mstats.heap_alloc-runtime_stacks_sys)*gcpercent/100;\n+\tpmstats->next_gc = pmstats->heap_alloc+(pmstats->heap_alloc-runtime_stacks_sys)*gcpercent/100;\n \n \ttm4 = runtime_nanotime();\n-\tmstats.last_gc = runtime_unixnanotime();  // must be Unix time to make sense to user\n-\tmstats.pause_ns[mstats.numgc%nelem(mstats.pause_ns)] = tm4 - tm0;\n-\tmstats.pause_end[mstats.numgc%nelem(mstats.pause_end)] = mstats.last_gc;\n-\tmstats.pause_total_ns += tm4 - tm0;\n-\tmstats.numgc++;\n-\tif(mstats.debuggc)\n+\tpmstats->last_gc = runtime_unixnanotime();  // must be Unix time to make sense to user\n+\tpmstats->pause_ns[pmstats->numgc%nelem(pmstats->pause_ns)] = tm4 - tm0;\n+\tpmstats->pause_end[pmstats->numgc%nelem(pmstats->pause_end)] = pmstats->last_gc;\n+\tpmstats->pause_total_ns += tm4 - tm0;\n+\tpmstats->numgc++;\n+\tif(pmstats->debuggc)\n \t\truntime_printf(\"pause %D\\n\", tm4-tm0);\n \n \tif(runtime_debug.gctrace) {\n-\t\theap1 = mstats.heap_alloc;\n+\t\theap1 = pmstats->heap_alloc;\n \t\truntime_updatememstats(&stats);\n-\t\tif(heap1 != mstats.heap_alloc) {\n-\t\t\truntime_printf(\"runtime: mstats skew: heap=%D/%D\\n\", heap1, mstats.heap_alloc);\n+\t\tif(heap1 != pmstats->heap_alloc) {\n+\t\t\truntime_printf(\"runtime: mstats skew: heap=%D/%D\\n\", heap1, pmstats->heap_alloc);\n \t\t\truntime_throw(\"mstats skew\");\n \t\t}\n-\t\tobj = mstats.nmalloc - mstats.nfree;\n+\t\tobj = pmstats->nmalloc - pmstats->nfree;\n \n \t\tstats.nprocyield += work.markfor->nprocyield;\n \t\tstats.nosyield += work.markfor->nosyield;\n@@ -2305,9 +2296,9 @@ gc(struct gc_args *args)\n \t\truntime_printf(\"gc%d(%d): %D+%D+%D+%D us, %D -> %D MB, %D (%D-%D) objects,\"\n \t\t\t\t\" %d/%d/%d sweeps,\"\n \t\t\t\t\" %D(%D) handoff, %D(%D) steal, %D/%D/%D yields\\n\",\n-\t\t\tmstats.numgc, work.nproc, (tm1-tm0)/1000, (tm2-tm1)/1000, (tm3-tm2)/1000, (tm4-tm3)/1000,\n+\t\t\tpmstats->numgc, work.nproc, (tm1-tm0)/1000, (tm2-tm1)/1000, (tm3-tm2)/1000, (tm4-tm3)/1000,\n \t\t\theap0>>20, heap1>>20, obj,\n-\t\t\tmstats.nmalloc, mstats.nfree,\n+\t\t\tpmstats->nmalloc, pmstats->nfree,\n \t\t\tsweep.nspan, gcstats.nbgsweep, gcstats.npausesweep,\n \t\t\tstats.nhandoff, stats.nhandoffcnt,\n \t\t\twork.markfor->nsteal, work.markfor->nstealcnt,\n@@ -2346,7 +2337,7 @@ gc(struct gc_args *args)\n \n \t// Free the old cached array if necessary.\n \tif(sweep.spans && sweep.spans != runtime_mheap.allspans)\n-\t\truntime_SysFree(sweep.spans, sweep.nspan*sizeof(sweep.spans[0]), &mstats.other_sys);\n+\t\truntime_SysFree(sweep.spans, sweep.nspan*sizeof(sweep.spans[0]), &pmstats->other_sys);\n \t// Cache the current array.\n \truntime_mheap.sweepspans = runtime_mheap.allspans;\n \truntime_mheap.sweepgen += 2;\n@@ -2377,36 +2368,6 @@ gc(struct gc_args *args)\n \tm->traceback = 0;\n }\n \n-extern uintptr runtime_sizeof_C_MStats\n-  __asm__ (GOSYM_PREFIX \"runtime.Sizeof_C_MStats\");\n-\n-void runtime_ReadMemStats(MStats *)\n-  __asm__ (GOSYM_PREFIX \"runtime.ReadMemStats\");\n-\n-void\n-runtime_ReadMemStats(MStats *stats)\n-{\n-\tM *m;\n-\n-\t// Have to acquire worldsema to stop the world,\n-\t// because stoptheworld can only be used by\n-\t// one goroutine at a time, and there might be\n-\t// a pending garbage collection already calling it.\n-\truntime_semacquire(&runtime_worldsema, false);\n-\tm = runtime_m();\n-\tm->gcing = 1;\n-\truntime_stoptheworld();\n-\truntime_updatememstats(nil);\n-\t// Size of the trailing by_size array differs between Go and C,\n-\t// _NumSizeClasses was changed, but we can not change Go struct because of backward compatibility.\n-\truntime_memmove(stats, &mstats, runtime_sizeof_C_MStats);\n-\tm->gcing = 0;\n-\tm->locks++;\n-\truntime_semrelease(&runtime_worldsema);\n-\truntime_starttheworld();\n-\tm->locks--;\n-}\n-\n void runtime_debug_readGCStats(Slice*)\n   __asm__(\"runtime_debug.readGCStats\");\n \n@@ -2415,28 +2376,30 @@ runtime_debug_readGCStats(Slice *pauses)\n {\n \tuint64 *p;\n \tuint32 i, n;\n+\tMStats *pmstats;\n \n \t// Calling code in runtime/debug should make the slice large enough.\n-\tif((size_t)pauses->cap < nelem(mstats.pause_ns)+3)\n+\tpmstats = mstats();\n+\tif((size_t)pauses->cap < nelem(pmstats->pause_ns)+3)\n \t\truntime_throw(\"runtime: short slice passed to readGCStats\");\n \n \t// Pass back: pauses, last gc (absolute time), number of gc, total pause ns.\n \tp = (uint64*)pauses->array;\n \truntime_lock(&runtime_mheap);\n-\tn = mstats.numgc;\n-\tif(n > nelem(mstats.pause_ns))\n-\t\tn = nelem(mstats.pause_ns);\n+\tn = pmstats->numgc;\n+\tif(n > nelem(pmstats->pause_ns))\n+\t\tn = nelem(pmstats->pause_ns);\n \t\n \t// The pause buffer is circular. The most recent pause is at\n \t// pause_ns[(numgc-1)%nelem(pause_ns)], and then backward\n \t// from there to go back farther in time. We deliver the times\n \t// most recent first (in p[0]).\n \tfor(i=0; i<n; i++)\n-\t\tp[i] = mstats.pause_ns[(mstats.numgc-1-i)%nelem(mstats.pause_ns)];\n+\t\tp[i] = pmstats->pause_ns[(pmstats->numgc-1-i)%nelem(pmstats->pause_ns)];\n \n-\tp[n] = mstats.last_gc;\n-\tp[n+1] = mstats.numgc;\n-\tp[n+2] = mstats.pause_total_ns;\t\n+\tp[n] = pmstats->last_gc;\n+\tp[n+1] = pmstats->numgc;\n+\tp[n+2] = pmstats->pause_total_ns;\n \truntime_unlock(&runtime_mheap);\n \tpauses->__count = n+3;\n }\n@@ -2745,7 +2708,7 @@ runtime_MHeap_MapBits(MHeap *h)\n \tif(h->bitmap_mapped >= n)\n \t\treturn;\n \n-\truntime_SysMap(h->arena_start - n, n - h->bitmap_mapped, h->arena_reserved, &mstats.gc_sys);\n+\truntime_SysMap(h->arena_start - n, n - h->bitmap_mapped, h->arena_reserved, &mstats()->gc_sys);\n \th->bitmap_mapped = n;\n }\n "}, {"sha": "c167bdc81959ee4144400180209a42f48e9ef639", "filename": "libgo/runtime/mheap.c", "status": "modified", "additions": 30, "deletions": 23, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58f7dab40db417ab669a0a1e146aa6e3227e3989/libgo%2Fruntime%2Fmheap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58f7dab40db417ab669a0a1e146aa6e3227e3989/libgo%2Fruntime%2Fmheap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmheap.c?ref=58f7dab40db417ab669a0a1e146aa6e3227e3989", "patch": "@@ -36,15 +36,15 @@ RecordSpan(void *vh, byte *p)\n \t\tcap = 64*1024/sizeof(all[0]);\n \t\tif(cap < h->nspancap*3/2)\n \t\t\tcap = h->nspancap*3/2;\n-\t\tall = (MSpan**)runtime_SysAlloc(cap*sizeof(all[0]), &mstats.other_sys);\n+\t\tall = (MSpan**)runtime_SysAlloc(cap*sizeof(all[0]), &mstats()->other_sys);\n \t\tif(all == nil)\n \t\t\truntime_throw(\"runtime: cannot allocate memory\");\n \t\tif(h->allspans) {\n \t\t\truntime_memmove(all, h->allspans, h->nspancap*sizeof(all[0]));\n \t\t\t// Don't free the old array if it's referenced by sweep.\n \t\t\t// See the comment in mgc0.c.\n \t\t\tif(h->allspans != runtime_mheap.sweepspans)\n-\t\t\t\truntime_SysFree(h->allspans, h->nspancap*sizeof(all[0]), &mstats.other_sys);\n+\t\t\t\truntime_SysFree(h->allspans, h->nspancap*sizeof(all[0]), &mstats()->other_sys);\n \t\t}\n \t\th->allspans = all;\n \t\th->nspancap = cap;\n@@ -56,12 +56,14 @@ RecordSpan(void *vh, byte *p)\n void\n runtime_MHeap_Init(MHeap *h)\n {\n+\tMStats *pmstats;\n \tuint32 i;\n \n-\truntime_FixAlloc_Init(&h->spanalloc, sizeof(MSpan), RecordSpan, h, &mstats.mspan_sys);\n-\truntime_FixAlloc_Init(&h->cachealloc, sizeof(MCache), nil, nil, &mstats.mcache_sys);\n-\truntime_FixAlloc_Init(&h->specialfinalizeralloc, sizeof(SpecialFinalizer), nil, nil, &mstats.other_sys);\n-\truntime_FixAlloc_Init(&h->specialprofilealloc, sizeof(SpecialProfile), nil, nil, &mstats.other_sys);\n+\tpmstats = mstats();\n+\truntime_FixAlloc_Init(&h->spanalloc, sizeof(MSpan), RecordSpan, h, &pmstats->mspan_sys);\n+\truntime_FixAlloc_Init(&h->cachealloc, sizeof(MCache), nil, nil, &pmstats->mcache_sys);\n+\truntime_FixAlloc_Init(&h->specialfinalizeralloc, sizeof(SpecialFinalizer), nil, nil, &pmstats->other_sys);\n+\truntime_FixAlloc_Init(&h->specialprofilealloc, sizeof(SpecialProfile), nil, nil, &pmstats->other_sys);\n \t// h->mapcache needs no init\n \tfor(i=0; i<nelem(h->free); i++) {\n \t\truntime_MSpanList_Init(&h->free[i]);\n@@ -88,7 +90,7 @@ runtime_MHeap_MapSpans(MHeap *h)\n \tn = ROUND(n, pagesize);\n \tif(h->spans_mapped >= n)\n \t\treturn;\n-\truntime_SysMap((byte*)h->spans + h->spans_mapped, n - h->spans_mapped, h->arena_reserved, &mstats.other_sys);\n+\truntime_SysMap((byte*)h->spans + h->spans_mapped, n - h->spans_mapped, h->arena_reserved, &mstats()->other_sys);\n \th->spans_mapped = n;\n }\n \n@@ -173,17 +175,19 @@ MHeap_Reclaim(MHeap *h, uintptr npage)\n MSpan*\n runtime_MHeap_Alloc(MHeap *h, uintptr npage, int32 sizeclass, bool large, bool needzero)\n {\n+\tMStats *pmstats;\n \tMSpan *s;\n \n \truntime_lock(h);\n-\tmstats.heap_alloc += (intptr)runtime_m()->mcache->local_cachealloc;\n+\tpmstats = mstats();\n+\tpmstats->heap_alloc += (intptr)runtime_m()->mcache->local_cachealloc;\n \truntime_m()->mcache->local_cachealloc = 0;\n \ts = MHeap_AllocLocked(h, npage, sizeclass);\n \tif(s != nil) {\n-\t\tmstats.heap_inuse += npage<<PageShift;\n+\t\tpmstats->heap_inuse += npage<<PageShift;\n \t\tif(large) {\n-\t\t\tmstats.heap_objects++;\n-\t\t\tmstats.heap_alloc += npage<<PageShift;\n+\t\t\tpmstats->heap_objects++;\n+\t\t\tpmstats->heap_alloc += npage<<PageShift;\n \t\t\t// Swept spans are at the end of lists.\n \t\t\tif(s->npages < nelem(h->free))\n \t\t\t\truntime_MSpanList_InsertBack(&h->busy[s->npages], s);\n@@ -237,8 +241,8 @@ MHeap_AllocLocked(MHeap *h, uintptr npage, int32 sizeclass)\n \truntime_MSpanList_Remove(s);\n \truntime_atomicstore(&s->sweepgen, h->sweepgen);\n \ts->state = MSpanInUse;\n-\tmstats.heap_idle -= s->npages<<PageShift;\n-\tmstats.heap_released -= s->npreleased<<PageShift;\n+\tmstats()->heap_idle -= s->npages<<PageShift;\n+\tmstats()->heap_released -= s->npreleased<<PageShift;\n \tif(s->npreleased > 0)\n \t\truntime_SysUsed((void*)(s->start<<PageShift), s->npages<<PageShift);\n \ts->npreleased = 0;\n@@ -326,7 +330,7 @@ MHeap_Grow(MHeap *h, uintptr npage)\n \t\t\tv = runtime_MHeap_SysAlloc(h, ask);\n \t\t}\n \t\tif(v == nil) {\n-\t\t\truntime_printf(\"runtime: out of memory: cannot allocate %D-byte block (%D in use)\\n\", (uint64)ask, mstats.heap_sys);\n+\t\t\truntime_printf(\"runtime: out of memory: cannot allocate %D-byte block (%D in use)\\n\", (uint64)ask, mstats()->heap_sys);\n \t\t\treturn false;\n \t\t}\n \t}\n@@ -386,13 +390,16 @@ runtime_MHeap_LookupMaybe(MHeap *h, void *v)\n void\n runtime_MHeap_Free(MHeap *h, MSpan *s, int32 acct)\n {\n+\tMStats *pmstats;\n+\n \truntime_lock(h);\n-\tmstats.heap_alloc += (intptr)runtime_m()->mcache->local_cachealloc;\n+\tpmstats = mstats();\n+\tpmstats->heap_alloc += (intptr)runtime_m()->mcache->local_cachealloc;\n \truntime_m()->mcache->local_cachealloc = 0;\n-\tmstats.heap_inuse -= s->npages<<PageShift;\n+\tpmstats->heap_inuse -= s->npages<<PageShift;\n \tif(acct) {\n-\t\tmstats.heap_alloc -= s->npages<<PageShift;\n-\t\tmstats.heap_objects--;\n+\t\tpmstats->heap_alloc -= s->npages<<PageShift;\n+\t\tpmstats->heap_objects--;\n \t}\n \tMHeap_FreeLocked(h, s);\n \truntime_unlock(h);\n@@ -411,7 +418,7 @@ MHeap_FreeLocked(MHeap *h, MSpan *s)\n \t\t\ts, s->start<<PageShift, s->state, s->ref, s->sweepgen, h->sweepgen);\n \t\truntime_throw(\"MHeap_FreeLocked - invalid free\");\n \t}\n-\tmstats.heap_idle += s->npages<<PageShift;\n+\tmstats()->heap_idle += s->npages<<PageShift;\n \ts->state = MSpanFree;\n \truntime_MSpanList_Remove(s);\n \t// Stamp newly unused spans. The scavenger will use that\n@@ -472,7 +479,7 @@ scavengelist(MSpan *list, uint64 now, uint64 limit)\n \tfor(s=list->next; s != list; s=s->next) {\n \t\tif((now - s->unusedsince) > limit && s->npreleased != s->npages) {\n \t\t\treleased = (s->npages - s->npreleased) << PageShift;\n-\t\t\tmstats.heap_released += released;\n+\t\t\tmstats()->heap_released += released;\n \t\t\tsumreleased += released;\n \t\t\ts->npreleased = s->npages;\n \n@@ -508,8 +515,8 @@ scavenge(int32 k, uint64 now, uint64 limit)\n \t\tif(sumreleased > 0)\n \t\t\truntime_printf(\"scvg%d: %D MB released\\n\", k, (uint64)sumreleased>>20);\n \t\truntime_printf(\"scvg%d: inuse: %D, idle: %D, sys: %D, released: %D, consumed: %D (MB)\\n\",\n-\t\t\tk, mstats.heap_inuse>>20, mstats.heap_idle>>20, mstats.heap_sys>>20,\n-\t\t\tmstats.heap_released>>20, (mstats.heap_sys - mstats.heap_released)>>20);\n+\t\t\tk, mstats()->heap_inuse>>20, mstats()->heap_idle>>20, mstats()->heap_sys>>20,\n+\t\t\tmstats()->heap_released>>20, (mstats()->heap_sys - mstats()->heap_released)>>20);\n \t}\n }\n \n@@ -550,7 +557,7 @@ runtime_MHeap_Scavenger(void* dummy)\n \n \t\truntime_lock(h);\n \t\tunixnow = runtime_unixnanotime();\n-\t\tif(unixnow - mstats.last_gc > forcegc) {\n+\t\tif(unixnow - mstats()->last_gc > forcegc) {\n \t\t\truntime_unlock(h);\n \t\t\t// The scavenger can not block other goroutines,\n \t\t\t// otherwise deadlock detector can fire spuriously."}, {"sha": "c4966a4ba81ee481b0162e4ca6223382972ff094", "filename": "libgo/runtime/mprof.goc", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58f7dab40db417ab669a0a1e146aa6e3227e3989/libgo%2Fruntime%2Fmprof.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58f7dab40db417ab669a0a1e146aa6e3227e3989/libgo%2Fruntime%2Fmprof.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmprof.goc?ref=58f7dab40db417ab669a0a1e146aa6e3227e3989", "patch": "@@ -90,7 +90,7 @@ stkbucket(int32 typ, uintptr size, Location *stk, int32 nstk, bool alloc)\n \tBucket *b;\n \n \tif(buckhash == nil) {\n-\t\tbuckhash = runtime_SysAlloc(BuckHashSize*sizeof buckhash[0], &mstats.buckhash_sys);\n+\t\tbuckhash = runtime_SysAlloc(BuckHashSize*sizeof buckhash[0], &mstats()->buckhash_sys);\n \t\tif(buckhash == nil)\n \t\t\truntime_throw(\"runtime: cannot allocate memory\");\n \t}\n@@ -127,7 +127,7 @@ stkbucket(int32 typ, uintptr size, Location *stk, int32 nstk, bool alloc)\n \tif(!alloc)\n \t\treturn nil;\n \n-\tb = runtime_persistentalloc(sizeof *b + nstk*sizeof stk[0], 0, &mstats.buckhash_sys);\n+\tb = runtime_persistentalloc(sizeof *b + nstk*sizeof stk[0], 0, &mstats()->buckhash_sys);\n \tbucketmem += sizeof *b + nstk*sizeof stk[0];\n \truntime_memmove(b->stk, stk, nstk*sizeof stk[0]);\n \tb->typ = typ;\n@@ -408,11 +408,11 @@ func Stack(b Slice, all bool) (n int) {\n \tpc = (byte*)(uintptr)runtime_getcallerpc(&b);\n \n \tif(all) {\n-\t\truntime_semacquire(&runtime_worldsema, false);\n+\t\truntime_acquireWorldsema();\n \t\truntime_m()->gcing = 1;\n-\t\truntime_stoptheworld();\n-\t\tenablegc = mstats.enablegc;\n-\t\tmstats.enablegc = false;\n+\t\truntime_stopTheWorldWithSema();\n+\t\tenablegc = mstats()->enablegc;\n+\t\tmstats()->enablegc = false;\n \t}\n \n \tif(b.__count == 0)\n@@ -436,9 +436,9 @@ func Stack(b Slice, all bool) (n int) {\n \t\n \tif(all) {\n \t\truntime_m()->gcing = 0;\n-\t\tmstats.enablegc = enablegc;\n-\t\truntime_semrelease(&runtime_worldsema);\n-\t\truntime_starttheworld();\n+\t\tmstats()->enablegc = enablegc;\n+\t\truntime_releaseWorldsema();\n+\t\truntime_startTheWorldWithSema();\n \t}\n }\n \n@@ -469,9 +469,9 @@ func GoroutineProfile(b Slice) (n int, ok bool) {\n \tok = false;\n \tn = runtime_gcount();\n \tif(n <= b.__count) {\n-\t\truntime_semacquire(&runtime_worldsema, false);\n+\t\truntime_acquireWorldsema();\n \t\truntime_m()->gcing = 1;\n-\t\truntime_stoptheworld();\n+\t\truntime_stopTheWorldWithSema();\n \n \t\tn = runtime_gcount();\n \t\tif(n <= b.__count) {\n@@ -488,8 +488,8 @@ func GoroutineProfile(b Slice) (n int, ok bool) {\n \t\t}\n \t\n \t\truntime_m()->gcing = 0;\n-\t\truntime_semrelease(&runtime_worldsema);\n-\t\truntime_starttheworld();\n+\t\truntime_releaseWorldsema();\n+\t\truntime_startTheWorldWithSema();\n \t}\n }\n "}, {"sha": "b82c70929798766f595eeff1c446c626b388db1f", "filename": "libgo/runtime/msize.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58f7dab40db417ab669a0a1e146aa6e3227e3989/libgo%2Fruntime%2Fmsize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58f7dab40db417ab669a0a1e146aa6e3227e3989/libgo%2Fruntime%2Fmsize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmsize.c?ref=58f7dab40db417ab669a0a1e146aa6e3227e3989", "patch": "@@ -60,6 +60,7 @@ runtime_InitSizes(void)\n \tint32 align, sizeclass, size, nextsize, n;\n \tuint32 i;\n \tuintptr allocsize, npages;\n+\tMStats *pmstats;\n \n \t// Initialize the runtime_class_to_size table (and choose class sizes in the process).\n \truntime_class_to_size[0] = 0;\n@@ -134,8 +135,9 @@ runtime_InitSizes(void)\n \t}\n \n \t// Copy out for statistics table.\n+\tpmstats = mstats();\n \tfor(i=0; i<nelem(runtime_class_to_size); i++)\n-\t\tmstats.by_size[i].size = runtime_class_to_size[i];\n+\t\tpmstats->by_size[i].size = runtime_class_to_size[i];\n \treturn;\n \n dump:"}, {"sha": "ecd426f19cc8e62b104c174cbe3cd407d97b0f61", "filename": "libgo/runtime/netpoll.goc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58f7dab40db417ab669a0a1e146aa6e3227e3989/libgo%2Fruntime%2Fnetpoll.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58f7dab40db417ab669a0a1e146aa6e3227e3989/libgo%2Fruntime%2Fnetpoll.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fnetpoll.goc?ref=58f7dab40db417ab669a0a1e146aa6e3227e3989", "patch": "@@ -459,7 +459,7 @@ allocPollDesc(void)\n \t\t\tn = 1;\n \t\t// Must be in non-GC memory because can be referenced\n \t\t// only from epoll/kqueue internals.\n-\t\tpd = runtime_persistentalloc(n*sizeof(*pd), 0, &mstats.other_sys);\n+\t\tpd = runtime_persistentalloc(n*sizeof(*pd), 0, &mstats()->other_sys);\n \t\tfor(i = 0; i < n; i++) {\n \t\t\tpd[i].link = pollcache.first;\n \t\t\tpollcache.first = &pd[i];"}, {"sha": "b32a1d5af8932eb6bc2afe0f973659e6be373708", "filename": "libgo/runtime/netpoll_select.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58f7dab40db417ab669a0a1e146aa6e3227e3989/libgo%2Fruntime%2Fnetpoll_select.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58f7dab40db417ab669a0a1e146aa6e3227e3989/libgo%2Fruntime%2Fnetpoll_select.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fnetpoll_select.c?ref=58f7dab40db417ab669a0a1e146aa6e3227e3989", "patch": "@@ -149,7 +149,7 @@ runtime_netpoll(bool block)\n \n \tif(inuse) {\n \t\tif(!allocatedfds) {\n-\t\t\tprfds = runtime_SysAlloc(4 * sizeof fds, &mstats.other_sys);\n+\t\t\tprfds = runtime_SysAlloc(4 * sizeof fds, &mstats()->other_sys);\n \t\t\tpwfds = prfds + 1;\n \t\t\tpefds = pwfds + 1;\n \t\t\tptfds = pefds + 1;\n@@ -239,7 +239,7 @@ runtime_netpoll(bool block)\n \t\tgoto retry;\n \n \tif(allocatedfds) {\n-\t\truntime_SysFree(prfds, 4 * sizeof fds, &mstats.other_sys);\n+\t\truntime_SysFree(prfds, 4 * sizeof fds, &mstats()->other_sys);\n \t} else {\n \t\truntime_lock(&selectlock);\n \t\tinuse = false;"}, {"sha": "d8a26fd77ad170b88054f6b8d18f54950179c5d7", "filename": "libgo/runtime/proc.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58f7dab40db417ab669a0a1e146aa6e3227e3989/libgo%2Fruntime%2Fproc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58f7dab40db417ab669a0a1e146aa6e3227e3989/libgo%2Fruntime%2Fproc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fproc.c?ref=58f7dab40db417ab669a0a1e146aa6e3227e3989", "patch": "@@ -508,7 +508,7 @@ runtime_schedinit(void)\n \tprocresize(procs);\n \n \t// Can not enable GC until all roots are registered.\n-\t// mstats.enablegc = 1;\n+\t// mstats()->enablegc = 1;\n }\n \n extern void main_init(void) __asm__ (GOSYM_PREFIX \"__go_init_main\");\n@@ -633,7 +633,7 @@ runtime_main(void* dummy __attribute__((unused)))\n \t// For gccgo we have to wait until after main is initialized\n \t// to enable GC, because initializing main registers the GC\n \t// roots.\n-\tmstats.enablegc = 1;\n+\tmstats()->enablegc = 1;\n \n \tif(runtime_isarchive) {\n \t\t// This is not a complete program, but is instead a\n@@ -951,7 +951,7 @@ runtime_freezetheworld(void)\n }\n \n void\n-runtime_stoptheworld(void)\n+runtime_stopTheWorldWithSema(void)\n {\n \tint32 i;\n \tuint32 s;\n@@ -1001,7 +1001,7 @@ mhelpgc(void)\n }\n \n void\n-runtime_starttheworld(void)\n+runtime_startTheWorldWithSema(void)\n {\n \tP *p, *p1;\n \tM *mp;\n@@ -1045,7 +1045,7 @@ runtime_starttheworld(void)\n \t\t\tmp = (M*)p->m;\n \t\t\tp->m = 0;\n \t\t\tif(mp->nextp)\n-\t\t\t\truntime_throw(\"starttheworld: inconsistent mp->nextp\");\n+\t\t\t\truntime_throw(\"startTheWorldWithSema: inconsistent mp->nextp\");\n \t\t\tmp->nextp = (uintptr)p;\n \t\t\truntime_notewakeup(&mp->park);\n \t\t} else {\n@@ -2373,7 +2373,7 @@ runtime_malg(int32 stacksize, byte** ret_stack, uintptr* ret_stacksize)\n                 // 32-bit mode, the Go allocation space is all of\n                 // memory anyhow.\n \t\tif(sizeof(void*) == 8) {\n-\t\t\tvoid *p = runtime_SysAlloc(stacksize, &mstats.other_sys);\n+\t\t\tvoid *p = runtime_SysAlloc(stacksize, &mstats()->other_sys);\n \t\t\tif(p == nil)\n \t\t\t\truntime_throw(\"runtime: cannot allocate memory for goroutine stack\");\n \t\t\t*ret_stack = (byte*)p;\n@@ -2583,13 +2583,13 @@ runtime_gomaxprocsfunc(int32 n)\n \t}\n \truntime_unlock(&runtime_sched);\n \n-\truntime_semacquire(&runtime_worldsema, false);\n+\truntime_acquireWorldsema();\n \tg->m->gcing = 1;\n-\truntime_stoptheworld();\n+\truntime_stopTheWorldWithSema();\n \tnewprocs = n;\n \tg->m->gcing = 0;\n-\truntime_semrelease(&runtime_worldsema);\n-\truntime_starttheworld();\n+\truntime_releaseWorldsema();\n+\truntime_startTheWorldWithSema();\n \n \treturn ret;\n }"}, {"sha": "b7e59021e4087ccef82b9789158fe9d99986f946", "filename": "libgo/runtime/runtime.h", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58f7dab40db417ab669a0a1e146aa6e3227e3989/libgo%2Fruntime%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58f7dab40db417ab669a0a1e146aa6e3227e3989/libgo%2Fruntime%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.h?ref=58f7dab40db417ab669a0a1e146aa6e3227e3989", "patch": "@@ -448,9 +448,14 @@ int32\truntime_setmaxthreads(int32);\n G*\truntime_timejump(void);\n void\truntime_iterate_finq(void (*callback)(FuncVal*, void*, const FuncType*, const PtrType*));\n \n-void\truntime_stoptheworld(void);\n-void\truntime_starttheworld(void);\n-extern uint32 runtime_worldsema;\n+void\truntime_stopTheWorldWithSema(void)\n+  __asm__(GOSYM_PREFIX \"runtime.stopTheWorldWithSema\");\n+void\truntime_startTheWorldWithSema(void)\n+  __asm__(GOSYM_PREFIX \"runtime.startTheWorldWithSema\");\n+void\truntime_acquireWorldsema(void)\n+  __asm__(GOSYM_PREFIX \"runtime.acquireWorldsema\");\n+void\truntime_releaseWorldsema(void)\n+  __asm__(GOSYM_PREFIX \"runtime.releaseWorldsema\");\n \n /*\n  * mutual exclusion locks.  in the uncontended case,"}]}