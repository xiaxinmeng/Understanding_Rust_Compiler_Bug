{"sha": "92d0b05816f5bd8f811177892459727097fe41a2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTJkMGIwNTgxNmY1YmQ4ZjgxMTE3Nzg5MjQ1OTcyNzA5N2ZlNDFhMg==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2015-05-22T16:13:07Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2015-05-22T16:13:07Z"}, "message": "pa.c (mem_shadd_or_shadd_rtx_p): New function factored out of hppa_legitimize_address to handle both forms of a...\n\n\t* pa.c (mem_shadd_or_shadd_rtx_p): New function factored out\n\tof hppa_legitimize_address to handle both forms of a multiply\n\tby 2, 4 or 8.\n\t(hppa_legitimize_address): Use mem_shadd_or_shadd_rtx_p.\n\tAlways generate the ASHIFT variant as the result is not directly\n\tused in a MEM.  Update comments and refactor slightly to improve\n\treadability.\n\nFrom-SVN: r223579", "tree": {"sha": "a9da7740f72ab1d83c847b331e93174b76926f42", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a9da7740f72ab1d83c847b331e93174b76926f42"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/92d0b05816f5bd8f811177892459727097fe41a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92d0b05816f5bd8f811177892459727097fe41a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92d0b05816f5bd8f811177892459727097fe41a2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92d0b05816f5bd8f811177892459727097fe41a2/comments", "author": null, "committer": null, "parents": [{"sha": "9b789cc15c38f6c67de873408e8397fbd7ada75b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b789cc15c38f6c67de873408e8397fbd7ada75b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b789cc15c38f6c67de873408e8397fbd7ada75b"}], "stats": {"total": 146, "additions": 98, "deletions": 48}, "files": [{"sha": "e2d49e67f1349ba80d3b7ee4cdc30e0f67ed827c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d0b05816f5bd8f811177892459727097fe41a2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d0b05816f5bd8f811177892459727097fe41a2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=92d0b05816f5bd8f811177892459727097fe41a2", "patch": "@@ -1,3 +1,13 @@\n+2015-05-22  Jeff Law  <law@redhat.com>\n+\n+\t* pa.c (mem_shadd_or_shadd_rtx_p): New function factored out\n+\tof hppa_legitimize_address to handle both forms of a multiply\n+\tby 2, 4 or 8.\n+\t(hppa_legitimize_address): Use mem_shadd_or_shadd_rtx_p. \n+\tAlways generate the ASHIFT variant as the result is not directly\n+\tused in a MEM.  Update comments and refactor slightly to improve\n+\treadability.\n+\n 2015-05-22  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \tPR target/65491"}, {"sha": "090eeb4a80816159276b161939b4db0bd275939e", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 88, "deletions": 48, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d0b05816f5bd8f811177892459727097fe41a2/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d0b05816f5bd8f811177892459727097fe41a2/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=92d0b05816f5bd8f811177892459727097fe41a2", "patch": "@@ -997,6 +997,23 @@ legitimize_tls_address (rtx addr)\n   return ret;\n }\n \n+/* Helper for hppa_legitimize_address.  Given X, return true if it\n+   is a left shift by 1, 2 or 3 positions or a multiply by 2, 4 or 8.\n+\n+   This respectively represent canonical shift-add rtxs or scaled\n+   memory addresses.  */\n+static bool\n+mem_shadd_or_shadd_rtx_p (rtx x)\n+{\n+  return ((GET_CODE (x) == ASHIFT\n+\t   || GET_CODE (x) == MULT)\n+\t  && GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t  && ((GET_CODE (x) == ASHIFT\n+\t       && pa_shadd_constant_p (INTVAL (XEXP (x, 1))))\n+\t      || (GET_CODE (x) == MULT\n+\t\t  && pa_mem_shadd_constant_p (INTVAL (XEXP (x, 1))))));\n+}\n+\n /* Try machine-dependent ways of modifying an illegitimate address\n    to be legitimate.  If we find one, return the new, valid address.\n    This macro is used in only one place: `memory_address' in explow.c.\n@@ -1042,6 +1059,13 @@ legitimize_tls_address (rtx addr)\n    manner if Y is 2, 4, or 8.  (allows more shadd insns and shifted indexed\n    addressing modes to be used).\n \n+   Note that the addresses passed into hppa_legitimize_address always\n+   come from a MEM, so we only have to match the MULT form on incoming\n+   addresses.  But to be future proof we also match the ASHIFT form.\n+\n+   However, this routine always places those shift-add sequences into\n+   registers, so we have to generate the ASHIFT form as our output.\n+\n    Put X and Z into registers.  Then put the entire expression into\n    a register.  */\n \n@@ -1138,18 +1162,21 @@ hppa_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n       return plus_constant (Pmode, ptr_reg, offset - newoffset);\n     }\n \n-  /* Handle (plus (mult (a) (shadd_constant)) (b)).  */\n+  /* Handle (plus (mult (a) (mem_shadd_constant)) (b)).  */\n \n-  if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 0)) == MULT\n-      && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n-      && pa_shadd_constant_p (INTVAL (XEXP (XEXP (x, 0), 1)))\n+  if (GET_CODE (x) == PLUS\n+      && mem_shadd_or_shadd_rtx_p (XEXP (x, 0))\n       && (OBJECT_P (XEXP (x, 1))\n \t  || GET_CODE (XEXP (x, 1)) == SUBREG)\n       && GET_CODE (XEXP (x, 1)) != CONST)\n     {\n-      int val = INTVAL (XEXP (XEXP (x, 0), 1));\n-      rtx reg1, reg2;\n+      /* If we were given a MULT, we must fix the constant\n+\t as we're going to create the ASHIFT form.  */\n+      int shift_val = INTVAL (XEXP (XEXP (x, 0), 1));\n+      if (GET_CODE (XEXP (x, 0)) == MULT)\n+\tshift_val = exact_log2 (shift_val);\n \n+      rtx reg1, reg2;\n       reg1 = XEXP (x, 1);\n       if (GET_CODE (reg1) != REG)\n \treg1 = force_reg (Pmode, force_operand (reg1, 0));\n@@ -1158,26 +1185,30 @@ hppa_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n       if (GET_CODE (reg2) != REG)\n         reg2 = force_reg (Pmode, force_operand (reg2, 0));\n \n-      return force_reg (Pmode, gen_rtx_PLUS (Pmode,\n-\t\t\t\t\t     gen_rtx_MULT (Pmode,\n-\t\t\t\t\t\t\t   reg2,\n-\t\t\t\t\t\t\t   GEN_INT (val)),\n-\t\t\t\t\t     reg1));\n+      return force_reg (Pmode,\n+\t\t\tgen_rtx_PLUS (Pmode,\n+\t\t\t\t      gen_rtx_ASHIFT (Pmode, reg2,\n+\t\t\t\t\t\t      GEN_INT (shift_val)),\n+\t\t\t\t      reg1));\n     }\n \n-  /* Similarly for (plus (plus (mult (a) (shadd_constant)) (b)) (c)).\n+  /* Similarly for (plus (plus (mult (a) (mem_shadd_constant)) (b)) (c)).\n \n      Only do so for floating point modes since this is more speculative\n      and we lose if it's an integer store.  */\n   if (GET_CODE (x) == PLUS\n       && GET_CODE (XEXP (x, 0)) == PLUS\n-      && GET_CODE (XEXP (XEXP (x, 0), 0)) == MULT\n-      && GET_CODE (XEXP (XEXP (XEXP (x, 0), 0), 1)) == CONST_INT\n-      && pa_shadd_constant_p (INTVAL (XEXP (XEXP (XEXP (x, 0), 0), 1)))\n+      && mem_shadd_or_shadd_rtx_p (XEXP (XEXP (x, 0), 0))\n       && (mode == SFmode || mode == DFmode))\n     {\n+      int shift_val = INTVAL (XEXP (XEXP (XEXP (x, 0), 0), 1));\n+\n+      /* If we were given a MULT, we must fix the constant\n+\t as we're going to create the ASHIFT form.  */\n+      if (GET_CODE (XEXP (XEXP (x, 0), 0)) == MULT)\n+\tshift_val = exact_log2 (shift_val);\n \n-      /* First, try and figure out what to use as a base register.  */\n+      /* Try and figure out what to use as a base register.  */\n       rtx reg1, reg2, base, idx;\n \n       reg1 = XEXP (XEXP (x, 0), 1);\n@@ -1201,9 +1232,9 @@ hppa_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n \t{\n \t  base = reg1;\n \t  idx = gen_rtx_PLUS (Pmode,\n-\t\t\t      gen_rtx_MULT (Pmode,\n-\t\t\t\t\t    XEXP (XEXP (XEXP (x, 0), 0), 0),\n-\t\t\t\t\t    XEXP (XEXP (XEXP (x, 0), 0), 1)),\n+\t\t\t      gen_rtx_ASHIFT (Pmode,\n+\t\t\t\t\t      XEXP (XEXP (XEXP (x, 0), 0), 0),\n+\t\t\t\t\t      GEN_INT (shift_val)),\n \t\t\t      XEXP (x, 1));\n \t}\n       else if (GET_CODE (reg2) == REG\n@@ -1225,8 +1256,8 @@ hppa_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n \t{\n \t  /* Divide the CONST_INT by the scale factor, then add it to A.  */\n \t  int val = INTVAL (XEXP (idx, 1));\n+\t  val /= (1 << shift_val);\n \n-\t  val /= INTVAL (XEXP (XEXP (idx, 0), 1));\n \t  reg1 = XEXP (XEXP (idx, 0), 0);\n \t  if (GET_CODE (reg1) != REG)\n \t    reg1 = force_reg (Pmode, force_operand (reg1, 0));\n@@ -1237,8 +1268,8 @@ hppa_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n \t  return\n \t    force_reg\n \t      (Pmode, gen_rtx_PLUS (Pmode,\n-\t\t\t\t    gen_rtx_MULT (Pmode, reg1,\n-\t\t\t\t\t\t  XEXP (XEXP (idx, 0), 1)),\n+\t\t\t\t    gen_rtx_ASHIFT (Pmode, reg1,\n+\t\t\t\t\t\t    GEN_INT (shift_val)),\n \t\t\t\t    base));\n \t}\n \n@@ -1247,7 +1278,6 @@ hppa_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n \t  && INTVAL (XEXP (idx, 1)) <= 4096\n \t  && INTVAL (XEXP (idx, 1)) >= -4096)\n \t{\n-\t  int val = INTVAL (XEXP (XEXP (idx, 0), 1));\n \t  rtx reg1, reg2;\n \n \t  reg1 = force_reg (Pmode, gen_rtx_PLUS (Pmode, base, XEXP (idx, 1)));\n@@ -1256,11 +1286,11 @@ hppa_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n \t  if (GET_CODE (reg2) != CONST_INT)\n \t    reg2 = force_reg (Pmode, force_operand (reg2, 0));\n \n-\t  return force_reg (Pmode, gen_rtx_PLUS (Pmode,\n-\t\t\t\t\t\t gen_rtx_MULT (Pmode,\n-\t\t\t\t\t\t\t       reg2,\n-\t\t\t\t\t\t\t       GEN_INT (val)),\n-\t\t\t\t\t\t reg1));\n+\t  return force_reg (Pmode,\n+\t\t\t    gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t  gen_rtx_ASHIFT (Pmode, reg2,\n+\t\t\t\t\t\t\t  GEN_INT (shift_val)),\n+\t\t\t\t\t  reg1));\n \t}\n \n       /* Get the index into a register, then add the base + index and\n@@ -1278,8 +1308,8 @@ hppa_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n \n       reg1 = force_reg (Pmode,\n \t\t\tgen_rtx_PLUS (Pmode,\n-\t\t\t\t      gen_rtx_MULT (Pmode, reg1,\n-\t\t\t\t\t\t    XEXP (XEXP (idx, 0), 1)),\n+\t\t\t\t      gen_rtx_ASHIFT (Pmode, reg1,\n+\t\t\t\t\t\t      GEN_INT (shift_val)),\n \t\t\t\t      reg2));\n \n       /* Add the result to our base register and return.  */\n@@ -1315,7 +1345,7 @@ hppa_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n       if (GET_CODE (y) == PLUS || GET_CODE (y) == MINUS)\n \t{\n \t  /* See if this looks like\n-\t\t(plus (mult (reg) (shadd_const))\n+\t\t(plus (mult (reg) (mem_shadd_const))\n \t\t      (const (plus (symbol_ref) (const_int))))\n \n \t     Where const_int is small.  In that case the const\n@@ -1324,14 +1354,18 @@ hppa_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n \t     If const_int is big, but can be divided evenly by shadd_const\n \t     and added to (reg).  This allows more scaled indexed addresses.  */\n \t  if (GET_CODE (XEXP (y, 0)) == SYMBOL_REF\n-\t      && GET_CODE (XEXP (x, 0)) == MULT\n+\t      && mem_shadd_or_shadd_rtx_p (XEXP (x, 0))\n \t      && GET_CODE (XEXP (y, 1)) == CONST_INT\n \t      && INTVAL (XEXP (y, 1)) >= -4096\n-\t      && INTVAL (XEXP (y, 1)) <= 4095\n-\t      && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n-\t      && pa_shadd_constant_p (INTVAL (XEXP (XEXP (x, 0), 1))))\n+\t      && INTVAL (XEXP (y, 1)) <= 4095)\n \t    {\n-\t      int val = INTVAL (XEXP (XEXP (x, 0), 1));\n+\t      int shift_val = INTVAL (XEXP (XEXP (x, 0), 1));\n+\n+\t      /* If we were given a MULT, we must fix the constant\n+\t\t as we're going to create the ASHIFT form.  */\n+\t      if (GET_CODE (XEXP (x, 0)) == MULT)\n+\t\tshift_val = exact_log2 (shift_val);\n+\n \t      rtx reg1, reg2;\n \n \t      reg1 = XEXP (x, 1);\n@@ -1342,21 +1376,27 @@ hppa_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n \t      if (GET_CODE (reg2) != REG)\n \t        reg2 = force_reg (Pmode, force_operand (reg2, 0));\n \n-\t      return force_reg (Pmode,\n-\t\t\t\tgen_rtx_PLUS (Pmode,\n-\t\t\t\t\t      gen_rtx_MULT (Pmode,\n-\t\t\t\t\t\t\t    reg2,\n-\t\t\t\t\t\t\t    GEN_INT (val)),\n-\t\t\t\t\t      reg1));\n+\t      return\n+\t\tforce_reg (Pmode,\n+\t\t\t   gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t gen_rtx_ASHIFT (Pmode,\n+\t\t\t\t\t\t\t reg2,\n+\t\t\t\t\t\t\t GEN_INT (shift_val)),\n+\t\t\t\t\t reg1));\n \t    }\n \t  else if ((mode == DFmode || mode == SFmode)\n \t\t   && GET_CODE (XEXP (y, 0)) == SYMBOL_REF\n-\t\t   && GET_CODE (XEXP (x, 0)) == MULT\n+\t\t   && mem_shadd_or_shadd_rtx_p (XEXP (x, 0))\n \t\t   && GET_CODE (XEXP (y, 1)) == CONST_INT\n-\t\t   && INTVAL (XEXP (y, 1)) % INTVAL (XEXP (XEXP (x, 0), 1)) == 0\n-\t\t   && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n-\t\t   && pa_shadd_constant_p (INTVAL (XEXP (XEXP (x, 0), 1))))\n+\t\t   && INTVAL (XEXP (y, 1)) % (1 << INTVAL (XEXP (XEXP (x, 0), 1))) == 0)\n \t    {\n+\t      int shift_val = INTVAL (XEXP (XEXP (x, 0), 1));\n+\n+\t      /* If we were given a MULT, we must fix the constant\n+\t\t as we're going to create the ASHIFT form.  */\n+\t      if (GET_CODE (XEXP (x, 0)) == MULT)\n+\t\tshift_val = exact_log2 (shift_val);\n+\n \t      regx1\n \t\t= force_reg (Pmode, GEN_INT (INTVAL (XEXP (y, 1))\n \t\t\t\t\t     / INTVAL (XEXP (XEXP (x, 0), 1))));\n@@ -1368,8 +1408,8 @@ hppa_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n \t      return\n \t\tforce_reg (Pmode,\n \t\t\t   gen_rtx_PLUS (Pmode,\n-\t\t\t\t\t gen_rtx_MULT (Pmode, regx2,\n-\t\t\t\t\t\t       XEXP (XEXP (x, 0), 1)),\n+\t\t\t\t\t gen_rtx_ASHIFT (Pmode, regx2,\n+\t\t\t\t\t\t         GEN_INT (shift_val)),\n \t\t\t\t\t force_reg (Pmode, XEXP (y, 0))));\n \t    }\n \t  else if (GET_CODE (XEXP (y, 1)) == CONST_INT"}]}