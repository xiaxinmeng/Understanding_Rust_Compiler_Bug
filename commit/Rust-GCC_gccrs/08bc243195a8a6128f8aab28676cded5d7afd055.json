{"sha": "08bc243195a8a6128f8aab28676cded5d7afd055", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDhiYzI0MzE5NWE4YTYxMjhmOGFhYjI4Njc2Y2RlZDVkN2FmZDA1NQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1998-10-31T20:44:46Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-10-31T20:44:46Z"}, "message": "c-common.c (c_get_alias_set): Allow all type-punning through unions.\n\n\ufffd\n        * c-common.c (c_get_alias_set): Allow all type-punning through\n        unions.  Don't get confused about the type of a bit-field, despite\n        the antics of build_modify_expr.\n\nFrom-SVN: r23481", "tree": {"sha": "86c2bd76ff3b4b065432438c38694e48e5a6b8f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/86c2bd76ff3b4b065432438c38694e48e5a6b8f5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/08bc243195a8a6128f8aab28676cded5d7afd055", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08bc243195a8a6128f8aab28676cded5d7afd055", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08bc243195a8a6128f8aab28676cded5d7afd055", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08bc243195a8a6128f8aab28676cded5d7afd055/comments", "author": null, "committer": null, "parents": [{"sha": "43d8a6c79fd61bd8ac341bd8600af1711349f88d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43d8a6c79fd61bd8ac341bd8600af1711349f88d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43d8a6c79fd61bd8ac341bd8600af1711349f88d"}], "stats": {"total": 38, "additions": 22, "deletions": 16}, "files": [{"sha": "f45b5662020f435c007777eb85024eba9177104f", "filename": "gcc/c-common.c", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08bc243195a8a6128f8aab28676cded5d7afd055/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08bc243195a8a6128f8aab28676cded5d7afd055/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=08bc243195a8a6128f8aab28676cded5d7afd055", "patch": "@@ -3135,6 +3135,7 @@ c_get_alias_set (t)\n      tree t;\n {\n   tree type;\n+  tree u;\n \n   if (t == error_mark_node)\n     return 0;\n@@ -3155,22 +3156,18 @@ c_get_alias_set (t)\n        the conservative assumption.  */\n     return 0;\n \n-  if ((TREE_CODE (t) == COMPONENT_REF\n-       && TREE_CODE (TREE_TYPE (TREE_OPERAND (t, 0))) == UNION_TYPE)\n-      /* Also permit punning when accessing an array which is a union\n-\t member.  This makes the current sparc va_arg macro work, but may\n-\t not be otherwise necessary.  */\n-      || (TREE_CODE (t) == ARRAY_REF\n-\t  && TREE_CODE (TREE_OPERAND (t, 0)) == COMPONENT_REF\n-\t  && (TREE_CODE (TREE_TYPE (TREE_OPERAND (TREE_OPERAND (t, 0), 0)))\n-\t      == UNION_TYPE)))\n-    /* Permit type-punning when accessing a union, provided the\n-       access is directly through the union.  For example, this code does\n-       not permit taking the address of a union member and then\n-       storing through it.  Even the type-punning allowed here is a\n-       GCC extension, albeit a common and useful one; the C standard\n-       says that such accesses have implementation-defined behavior.  */ \n-    return 0;\n+  /* Permit type-punning when accessing a union, provided the access\n+     is directly through the union.  For example, this code does not\n+     permit taking the address of a union member and then storing\n+     through it.  Even the type-punning allowed here is a GCC\n+     extension, albeit a common and useful one; the C standard says\n+     that such accesses have implementation-defined behavior.  */\n+  for (u = t;\n+       TREE_CODE (u) == COMPONENT_REF || TREE_CODE (u) == ARRAY_REF;\n+       u = TREE_OPERAND (u, 0))\n+    if (TREE_CODE (u) == COMPONENT_REF\n+\t&& TREE_CODE (TREE_TYPE (TREE_OPERAND (u, 0))) == UNION_TYPE)\n+      return 0;\n \n   if (TREE_CODE (t) == INDIRECT_REF)\n     {\n@@ -3184,6 +3181,15 @@ c_get_alias_set (t)\n \n   /* From here on, only the type matters.  */\n \n+  if (TREE_CODE (t) == COMPONENT_REF\n+      && DECL_BIT_FIELD_TYPE (TREE_OPERAND (t, 1)))\n+    /* Since build_modify_expr calls get_unwidened for stores to\n+       component references, the type of a bit field can be changed\n+       from (say) `unsigned int : 16' to `unsigned short' or from \n+       `enum E : 16' to `short'.  We want the real type of the\n+       bit-field in this case, not some the integral equivalent.  */\n+    type = DECL_BIT_FIELD_TYPE (TREE_OPERAND (t, 1));\n+\n   if (TYPE_ALIAS_SET_KNOWN_P (type))\n     /* If we've already calculated the value, just return it.  */\n     return TYPE_ALIAS_SET (type);"}]}