{"sha": "41775162a7e2b03f6c1f9324370dacb71527151f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDE3NzUxNjJhN2UyYjAzZjZjMWY5MzI0MzcwZGFjYjcxNTI3MTUxZg==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@integrable-solutions.net", "date": "2004-10-03T23:02:30Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2004-10-03T23:02:30Z"}, "message": "Convert diagnostics to use quoting flag q 1/n\n\n        Convert diagnostics to use quoting flag q 1/n\n        * error.c (locate_error): Ignore quoting flag q.\n        * call.c (build_user_type_conversion_1,\n        build_operator_new_call,\n        build_object_call, op_error, build_conditional_expr,\n        build_new_op, build_op_delete_call, enforce_access,\n        convert_like_real, convert_arg_to_ellipsis, build_x_va_arg,\n        convert_default_arg, build_over_call, build_new_method_call,\n        joust, perform_implicit_conversion, initialize_reference): Use\n        the\n        quoting flag q.\n\nFrom-SVN: r88465", "tree": {"sha": "440a66bef9c38813c2ca7ae32c4ae9903aabf5f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/440a66bef9c38813c2ca7ae32c4ae9903aabf5f6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/41775162a7e2b03f6c1f9324370dacb71527151f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41775162a7e2b03f6c1f9324370dacb71527151f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41775162a7e2b03f6c1f9324370dacb71527151f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41775162a7e2b03f6c1f9324370dacb71527151f/comments", "author": {"login": "cxx-undef", "id": 5528103, "node_id": "MDQ6VXNlcjU1MjgxMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/5528103?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cxx-undef", "html_url": "https://github.com/cxx-undef", "followers_url": "https://api.github.com/users/cxx-undef/followers", "following_url": "https://api.github.com/users/cxx-undef/following{/other_user}", "gists_url": "https://api.github.com/users/cxx-undef/gists{/gist_id}", "starred_url": "https://api.github.com/users/cxx-undef/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cxx-undef/subscriptions", "organizations_url": "https://api.github.com/users/cxx-undef/orgs", "repos_url": "https://api.github.com/users/cxx-undef/repos", "events_url": "https://api.github.com/users/cxx-undef/events{/privacy}", "received_events_url": "https://api.github.com/users/cxx-undef/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "103b83eaf0e63701d5b84704723230e1d5c36a78", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/103b83eaf0e63701d5b84704723230e1d5c36a78", "html_url": "https://github.com/Rust-GCC/gccrs/commit/103b83eaf0e63701d5b84704723230e1d5c36a78"}], "stats": {"total": 130, "additions": 74, "deletions": 56}, "files": [{"sha": "25057cf710dc63debca2e6735379a0e6b065d56b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41775162a7e2b03f6c1f9324370dacb71527151f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41775162a7e2b03f6c1f9324370dacb71527151f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=41775162a7e2b03f6c1f9324370dacb71527151f", "patch": "@@ -1,3 +1,15 @@\n+2004-10-03  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n+\n+\tConvert diagnostics to use quoting flag q 1/n\n+\t* error.c (locate_error): Ignore quoting flag q.\n+\t* call.c (build_user_type_conversion_1, build_operator_new_call,\n+\tbuild_object_call, op_error, build_conditional_expr,\n+\tbuild_new_op, build_op_delete_call, enforce_access,\n+\tconvert_like_real, convert_arg_to_ellipsis, build_x_va_arg,\n+\tconvert_default_arg, build_over_call, build_new_method_call,\n+\tjoust, perform_implicit_conversion, initialize_reference): Use the\n+\tquoting flag q.\n+\n 2004-10-03  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \tPR c++/17797"}, {"sha": "bd607abb9a39e3d8e99ed5d0e592c2f6cbef3bf6", "filename": "gcc/cp/call.c", "status": "modified", "additions": 55, "deletions": 54, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41775162a7e2b03f6c1f9324370dacb71527151f/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41775162a7e2b03f6c1f9324370dacb71527151f/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=41775162a7e2b03f6c1f9324370dacb71527151f", "patch": "@@ -2600,7 +2600,7 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags)\n     {\n       if (flags & LOOKUP_COMPLAIN)\n \t{\n-\t  error (\"conversion from `%T' to `%T' is ambiguous\",\n+\t  error (\"conversion from %qT to %qT is ambiguous\",\n \t\t    fromtype, totype);\n \t  print_z_candidates (candidates);\n \t}\n@@ -2754,10 +2754,10 @@ build_new_function_call (tree fn, tree args)\n       if (TREE_CODE (fn) == TEMPLATE_ID_EXPR)\n \tfn = TREE_OPERAND (fn, 0);\n       if (!any_viable_p)\n-\terror (\"no matching function for call to `%D(%A)'\",\n+\terror (\"no matching function for call to %<%D(%A)%>\",\n \t       DECL_NAME (OVL_CURRENT (fn)), args);\n       else\n-\terror (\"call of overloaded `%D(%A)' is ambiguous\",\n+\terror (\"call of overloaded %<%D(%A)%> is ambiguous\",\n \t       DECL_NAME (OVL_CURRENT (fn)), args);\n       if (candidates)\n \tprint_z_candidates (candidates);\n@@ -2812,10 +2812,10 @@ build_operator_new_call (tree fnname, tree args, tree *size, tree *cookie_size)\n   if (!cand)\n     {\n       if (!any_viable_p)\n-\terror (\"no matching function for call to `%D(%A)'\",\n+\terror (\"no matching function for call to %<%D(%A)%>\",\n \t       DECL_NAME (OVL_CURRENT (fns)), args);\n       else\n-\terror (\"call of overloaded `%D(%A)' is ambiguous\",\n+\terror (\"call of overloaded %<%D(%A)%> is ambiguous\",\n \t       DECL_NAME (OVL_CURRENT (fns)), args);\n       if (candidates)\n \tprint_z_candidates (candidates);\n@@ -2952,7 +2952,7 @@ build_object_call (tree obj, tree args)\n   candidates = splice_viable (candidates, pedantic, &any_viable_p);\n   if (!any_viable_p)\n     {\n-      error (\"no match for call to `(%T) (%A)'\", TREE_TYPE (obj), args);\n+      error (\"no match for call to %<(%T) (%A)%>\", TREE_TYPE (obj), args);\n       print_z_candidates (candidates);\n       result = error_mark_node;\n     }\n@@ -2961,7 +2961,7 @@ build_object_call (tree obj, tree args)\n       cand = tourney (candidates);\n       if (cand == 0)\n \t{\n-\t  error (\"call of `(%T) (%A)' is ambiguous\", TREE_TYPE (obj), args);\n+\t  error (\"call of %<(%T) (%A)%> is ambiguous\", TREE_TYPE (obj), args);\n \t  print_z_candidates (candidates);\n \t  result = error_mark_node;\n \t}\n@@ -2998,30 +2998,30 @@ op_error (enum tree_code code, enum tree_code code2,\n   switch (code)\n     {\n     case COND_EXPR:\n-      error (\"%s for ternary 'operator?:' in '%E ? %E : %E'\",\n+      error (\"%s for ternary %<operator?:%> in %<%E ? %E : %E%>\",\n              problem, arg1, arg2, arg3);\n       break;\n       \n     case POSTINCREMENT_EXPR:\n     case POSTDECREMENT_EXPR:\n-      error (\"%s for 'operator%s' in '%E%s'\", problem, opname, arg1, opname);\n+      error (\"%s for %<operator%s%> in %<%E%s%>\", problem, opname, arg1, opname);\n       break;\n       \n     case ARRAY_REF:\n-      error (\"%s for 'operator[]' in '%E[%E]'\", problem, arg1, arg2);\n+      error (\"%s for %<operator[]%> in %<%E[%E]%>\", problem, arg1, arg2);\n       break;\n \n     case REALPART_EXPR:\n     case IMAGPART_EXPR:\n-      error (\"%s for '%s' in '%s %E'\", problem, opname, opname, arg1);\n+      error (\"%s for %qs in %<%s %E%>\", problem, opname, opname, arg1);\n       break;\n       \n     default:\n       if (arg2)\n-\terror (\"%s for 'operator%s' in '%E %s %E'\",\n+\terror (\"%s for %<operator%s%> in %<%E %s %E%>\",\n                problem, opname, arg1, opname, arg2);\n       else\n-\terror (\"%s for 'operator%s' in '%s%E'\",\n+\terror (\"%s for %<operator%s%> in %<%s%E%>\",\n                problem, opname, opname, arg1);\n       break;\n     }\n@@ -3188,7 +3188,7 @@ build_conditional_expr (tree arg1, tree arg2, tree arg3)\n \tresult_type = void_type_node;\n       else\n \t{\n-\t  error (\"`%E' has type `void' and is not a throw-expression\",\n+\t  error (\"%qE has type %<void%> and is not a throw-expression\",\n \t\t    VOID_TYPE_P (arg2_type) ? arg2 : arg3);\n \t  return error_mark_node;\n \t}\n@@ -3693,9 +3693,10 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n \t  /* Look for an `operator++ (int)'.  If they didn't have\n \t     one, then we fall back to the old way of doing things.  */\n \t  if (flags & LOOKUP_COMPLAIN)\n-\t    pedwarn (\"no `%D(int)' declared for postfix `%s', trying prefix operator instead\",\n-\t\t\tfnname, \n-\t\t\toperator_name_info[code].name);\n+\t    pedwarn (\"no %<%D(int)%> declared for postfix %qs, \"\n+                     \"trying prefix operator instead\",\n+                     fnname, \n+                     operator_name_info[code].name);\n \t  if (code == POSTINCREMENT_EXPR)\n \t    code = PREINCREMENT_EXPR;\n \t  else\n@@ -3745,9 +3746,9 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n \t      && candidates->next\n \t      && ! candidates->next->next)\n \t    {\n-\t      warning (\"using synthesized `%#D' for copy assignment\",\n+\t      warning (\"using synthesized %q#D for copy assignment\",\n \t\t\t  cand->fn);\n-\t      cp_warning_at (\"  where cfront would use `%#D'\",\n+\t      cp_warning_at (\"  where cfront would use %q#D\",\n \t\t\t     cand == candidates\n \t\t\t     ? candidates->next->fn\n \t\t\t     : candidates->fn);\n@@ -3779,8 +3780,8 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n \t\t  && (TYPE_MAIN_VARIANT (TREE_TYPE (arg1))\n \t\t      != TYPE_MAIN_VARIANT (TREE_TYPE (arg2))))\n \t\t{\n-\t\t  warning (\"comparison between `%#T' and `%#T'\", \n-\t\t\t      TREE_TYPE (arg1), TREE_TYPE (arg2));\n+\t\t  warning (\"comparison between %q#T and %q#T\", \n+                           TREE_TYPE (arg1), TREE_TYPE (arg2));\n \t\t}\n \t      break;\n \t    default:\n@@ -4036,7 +4037,7 @@ build_op_delete_call (enum tree_code code, tree addr, tree size,\n   if (placement)\n     return NULL_TREE;\n \n-  error (\"no suitable `operator %s' for `%T'\",\n+  error (\"no suitable %<operator %s> for %qT\",\n \t operator_name_info[(int)code].name, type);\n   return error_mark_node;\n }\n@@ -4053,11 +4054,11 @@ enforce_access (tree basetype_path, tree decl)\n   if (!accessible_p (basetype_path, decl))\n     {\n       if (TREE_PRIVATE (decl))\n-\tcp_error_at (\"`%+#D' is private\", decl);\n+\tcp_error_at (\"%q+#D is private\", decl);\n       else if (TREE_PROTECTED (decl))\n-\tcp_error_at (\"`%+#D' is protected\", decl);\n+\tcp_error_at (\"%q+#D is protected\", decl);\n       else\n-\tcp_error_at (\"`%+#D' is inaccessible\", decl);\n+\tcp_error_at (\"%q+#D is inaccessible\", decl);\n       error (\"within this context\");\n       return false;\n     }\n@@ -4141,9 +4142,9 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \t  else if (t->kind == ck_identity)\n \t    break;\n \t}\n-      pedwarn (\"invalid conversion from `%T' to `%T'\", TREE_TYPE (expr), totype);\n+      pedwarn (\"invalid conversion from %qT to %qT\", TREE_TYPE (expr), totype);\n       if (fn)\n-\tpedwarn (\"  initializing argument %P of `%D'\", argnum, fn);\n+\tpedwarn (\"  initializing argument %P of %qD\", argnum, fn);\n       return cp_convert (totype, expr);\n     }\n   \n@@ -4203,11 +4204,11 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \t      {\n \t\tif (fn)\n \t\t  diagnostic_fn \n-\t\t    (\"  initializing argument %P of `%D' from result of `%D'\",\n+\t\t    (\"  initializing argument %P of %qD from result of %qD\",\n \t\t     argnum, fn, convfn);\n \t\telse\n \t\t diagnostic_fn \n-\t\t   (\"  initializing temporary from result of `%D'\",  convfn);\n+\t\t   (\"  initializing temporary from result of %qD\",  convfn);\n \t      }\n \t    expr = build_cplus_new (totype, expr);\n \t  }\n@@ -4267,7 +4268,7 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n       expr = build_temp (expr, totype, LOOKUP_NORMAL|LOOKUP_ONLYCONVERTING,\n \t\t\t &diagnostic_fn);\n       if (diagnostic_fn && fn)\n-\tdiagnostic_fn (\"  initializing argument %P of `%D'\", argnum, fn);\n+\tdiagnostic_fn (\"  initializing argument %P of %qD\", argnum, fn);\n       return build_cplus_new (totype, expr);\n \n     case ck_ref_bind:\n@@ -4286,13 +4287,13 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \t\tcp_lvalue_kind lvalue = real_lvalue_p (expr);\n \t\t\n \t\tif (lvalue & clk_bitfield)\n-\t\t  error (\"cannot bind bitfield `%E' to `%T'\",\n+\t\t  error (\"cannot bind bitfield %qE to %qT\",\n \t\t\t expr, ref_type);\n \t\telse if (lvalue & clk_packed)\n-\t\t  error (\"cannot bind packed field `%E' to `%T'\",\n+\t\t  error (\"cannot bind packed field %qE to %qT\",\n \t\t\t expr, ref_type);\n \t\telse\n-\t\t  error (\"cannot bind rvalue `%E' to `%T'\", expr, ref_type);\n+\t\t  error (\"cannot bind rvalue %qE to %qT\", expr, ref_type);\n \t\treturn error_mark_node;\n \t      }\n \t    expr = build_target_expr_with_type (expr, type);\n@@ -4377,7 +4378,7 @@ convert_arg_to_ellipsis (tree arg)\n \t there is no need to emit a warning, since the expression won't be \n \t evaluated. We keep the builtin_trap just as a safety check.  */\n       if (!skip_evaluation)\n-\twarning (\"cannot pass objects of non-POD type `%#T' through `...'; \"\n+\twarning (\"cannot pass objects of non-POD type %q#T through %<...%>; \"\n \t         \"call will abort at runtime\", TREE_TYPE (arg));\n       arg = call_builtin_trap ();\n       arg = build2 (COMPOUND_EXPR, integer_type_node, arg,\n@@ -4403,9 +4404,8 @@ build_x_va_arg (tree expr, tree type)\n   if (! pod_type_p (type))\n     {\n       /* Undefined behavior [expr.call] 5.2.2/7.  */\n-      warning (\"cannot receive objects of non-POD type `%#T' through `...'; \\\n-call will abort at runtime\",\n-\t       type);\n+      warning (\"cannot receive objects of non-POD type %q#T' through %<...%>; \"\n+               \"call will abort at runtime\", type);\n       expr = convert (build_pointer_type (type), null_node);\n       expr = build2 (COMPOUND_EXPR, TREE_TYPE (expr),\n \t\t     call_builtin_trap (), expr);\n@@ -4447,7 +4447,7 @@ convert_default_arg (tree type, tree arg, tree fn, int parmnum)\n      conversion cannot be performed.  */\n   if (TREE_CODE (arg) == DEFAULT_ARG)\n     {\n-      error (\"the default argument for parameter %d of `%D' has \"\n+      error (\"the default argument for parameter %d of %qD has \"\n \t     \"not yet been parsed\",\n \t     parmnum, fn);\n       return error_mark_node;\n@@ -4671,7 +4671,7 @@ build_over_call (struct z_candidate *cand, int flags)\n       /* Check that the base class is accessible.  */\n       if (!accessible_base_p (TREE_TYPE (argtype), \n \t\t\t      BINFO_TYPE (cand->conversion_path)))\n-\terror (\"`%T' is not an accessible base of `%T'\",\n+\terror (\"%qT is not an accessible base of %qT\",\n \t       BINFO_TYPE (cand->conversion_path),\n \t       TREE_TYPE (argtype));\n       /* If fn was found by a using declaration, the conversion path\n@@ -4921,7 +4921,7 @@ build_java_interface_fn_ref (tree fn, tree instance)\n   if (!iface_ref || TREE_CODE (iface_ref) != VAR_DECL\n       || DECL_CONTEXT (iface_ref) != iface)\n     {\n-      error (\"could not find class$ field in java interface type `%T'\", \n+      error (\"could not find class$ field in java interface type %qT\", \n \t\tiface);\n       return error_mark_node;\n     }\n@@ -5183,7 +5183,7 @@ build_new_method_call (tree instance, tree fns, tree args,\n \n   if (!BASELINK_P (fns))\n     {\n-      error (\"call to non-function `%D'\", fns);\n+      error (\"call to non-function %qD\", fns);\n       return error_mark_node;\n     }\n \n@@ -5208,7 +5208,8 @@ build_new_method_call (tree instance, tree fns, tree args,\n   if (! IS_AGGR_TYPE (basetype))\n     {\n       if ((flags & LOOKUP_COMPLAIN) && basetype != error_mark_node)\n-\terror (\"request for member `%D' in `%E', which is of non-aggregate type `%T'\",\n+\terror (\"request for member %qD in %qE, which is of non-aggregate \"\n+               \"type %qT\",\n \t       fns, instance, basetype);\n \n       return error_mark_node;\n@@ -5286,7 +5287,7 @@ build_new_method_call (tree instance, tree fns, tree args,\n \t  bool free_p;\n \n \t  pretty_name = name_as_c_string (name, basetype, &free_p);\n-\t  error (\"no matching function for call to `%T::%s(%A)%#V'\",\n+\t  error (\"no matching function for call to %<%T::%s(%A)%#V%>\",\n \t\t basetype, pretty_name, user_args,\n \t\t TREE_TYPE (TREE_TYPE (instance_ptr)));\n \t  if (free_p)\n@@ -5304,7 +5305,7 @@ build_new_method_call (tree instance, tree fns, tree args,\n \t  bool free_p;\n \n \t  pretty_name = name_as_c_string (name, basetype, &free_p);\n-\t  error (\"call of overloaded `%s(%A)' is ambiguous\", pretty_name,\n+\t  error (\"call of overloaded %<%s(%A)%> is ambiguous\", pretty_name,\n \t\t user_args);\n \t  print_z_candidates (candidates);\n \t  if (free_p)\n@@ -5321,14 +5322,14 @@ build_new_method_call (tree instance, tree fns, tree args,\n \t    /* This is not an error, it is runtime undefined\n \t       behavior.  */\n \t    warning ((DECL_CONSTRUCTOR_P (current_function_decl) ? \n-\t\t      \"abstract virtual `%#D' called from constructor\"\n-\t\t      : \"abstract virtual `%#D' called from destructor\"),\n+\t\t      \"abstract virtual %q#D called from constructor\"\n+\t\t      : \"abstract virtual %q#D called from destructor\"),\n \t\t     cand->fn);\n \t  \n \t  if (TREE_CODE (TREE_TYPE (cand->fn)) == METHOD_TYPE\n \t      && is_dummy_object (instance_ptr))\n \t    {\n-\t      error (\"cannot call member function `%D' without object\", \n+\t      error (\"cannot call member function %qD without object\", \n \t\t     cand->fn);\n \t      call = error_mark_node;\n \t    }\n@@ -5933,9 +5934,9 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn)\n \n \t      if (warn)\n \t\t{\n-\t\t  warning (\"passing `%T' chooses `%T' over `%T'\",\n+\t\t  warning (\"passing %qT chooses %qT over %qT\",\n \t\t\t      type, type1, type2);\n-\t\t  warning (\"  in call to `%D'\", w->fn);\n+\t\t  warning (\"  in call to %qD\", w->fn);\n \t\t}\n \t      else\n \t\tadd_warning (w, l);\n@@ -5992,8 +5993,8 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn)\n \t  tree source = source_type (w->convs[0]);\n \t  if (! DECL_CONSTRUCTOR_P (w->fn))\n \t    source = TREE_TYPE (source);\n-\t  warning (\"choosing `%D' over `%D'\", w->fn, l->fn);\n-\t  warning (\"  for conversion from `%T' to `%T'\",\n+\t  warning (\"choosing %qD over %qD\", w->fn, l->fn);\n+\t  warning (\"  for conversion from %qT to %qT\",\n \t\t   source, w->second_conv->type);\n \t  warning (\"  because conversion sequence for the argument is better\");\n \t}\n@@ -6257,7 +6258,7 @@ perform_implicit_conversion (tree type, tree expr)\n \t\t\t      LOOKUP_NORMAL);\n   if (!conv)\n     {\n-      error (\"could not convert `%E' to `%T'\", expr, type);\n+      error (\"could not convert %qE to %qT\", expr, type);\n       expr = error_mark_node;\n     }\n   else\n@@ -6382,11 +6383,11 @@ initialize_reference (tree type, tree expr, tree decl, tree *cleanup)\n       if (!(TYPE_QUALS (TREE_TYPE (type)) & TYPE_QUAL_CONST)\n           && !real_lvalue_p (expr))\n         error (\"invalid initialization of non-const reference of \"\n-               \"type '%T' from a temporary of type '%T'\",\n+               \"type %qT from a temporary of type %qT\",\n                type, TREE_TYPE (expr));\n       else\n         error (\"invalid initialization of reference of type \"\n-\t       \"'%T' from expression of type '%T'\", type, \n+\t       \"%qT from expression of type %qT\", type, \n \t       TREE_TYPE (expr));\n       return error_mark_node;\n     }"}, {"sha": "b6148fa81ec8578bd356e022a5f2ededa06ebc2e", "filename": "gcc/cp/error.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41775162a7e2b03f6c1f9324370dacb71527151f/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41775162a7e2b03f6c1f9324370dacb71527151f/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=41775162a7e2b03f6c1f9324370dacb71527151f", "patch": "@@ -2332,9 +2332,14 @@ locate_error (const char *msgid, va_list ap)\n       plus = 0;\n       if (*f == '%')\n \t{\n-\t  f++;\n+          if (*++f == 'q')\n+            ++f;                /* ignore quoting flag.  */\n+\n \t  if (*f == '+')\n-\t    f++, plus = 1;\n+            {\n+              ++f;\n+              plus = 1;\n+            }\n \t  if (*f == '#')\n \t    f++;\n "}]}