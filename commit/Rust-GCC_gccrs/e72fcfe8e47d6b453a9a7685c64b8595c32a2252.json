{"sha": "e72fcfe8e47d6b453a9a7685c64b8595c32a2252", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTcyZmNmZThlNDdkNmI0NTNhOWE3Njg1YzY0Yjg1OTVjMzJhMjI1Mg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2003-02-12T21:48:59Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2003-02-12T21:48:59Z"}, "message": "Makefile.in (CRTSTUFF_CFLAGS): Add -fno-unit-at-a-time\n\n\t* Makefile.in (CRTSTUFF_CFLAGS): Add -fno-unit-at-a-time\n\t(OBJS): Add callgraph.o\n\t(callgraph.o): New.\n\t* c-decl.c (expand_body_1): Break out from ...\n\t(expand_body): This one;  change calling convention\n\t(finish_function): Move some of expand_body logic here.\n\t(c_expand_deferred_function): Update call of expand_body\n\t(c_expand_stmt): Use c_expand_body_1.\n\t* c-lang.c (LANG_HOOKS_CALLGRAPH_EXPAND_FUNCTION): Define.\n\t* c-objc-commin.c (c_objc_common_finish_file): Use callgraph code.\n\t* c-tree.h (c_expand_body): Declare.\n\t* callgraph.c: New file.\n\t* flags.h (flag_unit_at_a_time): Declare.\n\t* langhooks.h (LANG_HOOKS_CALLGRAPH_LOWER_FUNCTION,\n\tLANG_HOOKS_CALLGRAPH_EXPAND_FUNCTION,\n\tLANG_HOOKS_CALLGRAPH_INITIALIZER): New macros.\n\t* langhooks.h (struct lang_hooks_for_callgraph): New.\n\t(struct lang_hooks): Add callgraph field.\n\t* toplev.c (flag_unit_at_a_time): New.\n\t(lang_independent_options): Add flag_unit_at_a_time.\n\t(process_options): Disable unit-at-a-time mode for frontends not\n\tsupporting callgraph.\n\t* tree-inline.c (typedef struct inline_data): Add \"decl\"\n\t(expand_call_inline): Update callgraph.\n\t(optimize_inline_calls): Set id.decl.\n\t* tree.h (cgraph_finalize_function, cgraph_finalize_compilation_unit,\n\tcgraph_create_edges, dump_cgraph, cgraph_optimize, cgraph_remove_call\n\tcgraph_calls_p): Declare.\n\t* invoke.texi (-funit-at-a-time): Document\n\nFrom-SVN: r62789", "tree": {"sha": "145028e0c53cc6c7857dc24db0335535b3ff24ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/145028e0c53cc6c7857dc24db0335535b3ff24ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e72fcfe8e47d6b453a9a7685c64b8595c32a2252", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e72fcfe8e47d6b453a9a7685c64b8595c32a2252", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e72fcfe8e47d6b453a9a7685c64b8595c32a2252", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e72fcfe8e47d6b453a9a7685c64b8595c32a2252/comments", "author": null, "committer": null, "parents": [{"sha": "9037b0c71ed8277d06fd67fff15ea40aee9754ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9037b0c71ed8277d06fd67fff15ea40aee9754ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9037b0c71ed8277d06fd67fff15ea40aee9754ef"}], "stats": {"total": 790, "additions": 742, "deletions": 48}, "files": [{"sha": "9ee4179a54b882de9a75f969c20667ff06199be8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e72fcfe8e47d6b453a9a7685c64b8595c32a2252/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e72fcfe8e47d6b453a9a7685c64b8595c32a2252/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e72fcfe8e47d6b453a9a7685c64b8595c32a2252", "patch": "@@ -1,3 +1,35 @@\n+Wed Feb 12 22:47:18 CET 2003  Jan Hubicka  <jh@suse.cz>\n+\n+\t* Makefile.in (CRTSTUFF_CFLAGS): Add -fno-unit-at-a-time\n+\t(OBJS): Add callgraph.o\n+\t(callgraph.o): New.\n+\t* c-decl.c (expand_body_1): Break out from ...\n+\t(expand_body): This one;  change calling convention\n+\t(finish_function): Move some of expand_body logic here.\n+\t(c_expand_deferred_function): Update call of expand_body\n+\t(c_expand_stmt): Use c_expand_body_1.\n+\t* c-lang.c (LANG_HOOKS_CALLGRAPH_EXPAND_FUNCTION): Define.\n+\t* c-objc-commin.c (c_objc_common_finish_file): Use callgraph code.\n+\t* c-tree.h (c_expand_body): Declare.\n+\t* callgraph.c: New file.\n+\t* flags.h (flag_unit_at_a_time): Declare.\n+\t* langhooks.h (LANG_HOOKS_CALLGRAPH_LOWER_FUNCTION,\n+\tLANG_HOOKS_CALLGRAPH_EXPAND_FUNCTION,\n+\tLANG_HOOKS_CALLGRAPH_INITIALIZER): New macros.\n+\t* langhooks.h (struct lang_hooks_for_callgraph): New.\n+\t(struct lang_hooks): Add callgraph field.\n+\t* toplev.c (flag_unit_at_a_time): New.\n+\t(lang_independent_options): Add flag_unit_at_a_time.\n+\t(process_options): Disable unit-at-a-time mode for frontends not\n+\tsupporting callgraph.\n+\t* tree-inline.c (typedef struct inline_data): Add \"decl\"\n+\t(expand_call_inline): Update callgraph.\n+\t(optimize_inline_calls): Set id.decl.\n+\t* tree.h (cgraph_finalize_function, cgraph_finalize_compilation_unit,\n+\tcgraph_create_edges, dump_cgraph, cgraph_optimize, cgraph_remove_call\n+\tcgraph_calls_p): Declare.\n+\t* invoke.texi (-funit-at-a-time): Document\n+\n 2003-02-12  Aldy Hernandez  <aldyh@redhat.com>\n \n         * config/rs6000/spe.h: Fix misc formatting."}, {"sha": "d528378214bad77074006e1cf2051d7a3d14101c", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e72fcfe8e47d6b453a9a7685c64b8595c32a2252/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e72fcfe8e47d6b453a9a7685c64b8595c32a2252/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=e72fcfe8e47d6b453a9a7685c64b8595c32a2252", "patch": "@@ -416,7 +416,7 @@ TARGET_LIBGCC2_CFLAGS =\n # Options to use when compiling crtbegin/end.\n CRTSTUFF_CFLAGS = -O2 $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) -g0 \\\n   -finhibit-size-directive -fno-inline-functions -fno-exceptions \\\n-  -fno-zero-initialized-in-bss\n+  -fno-zero-initialized-in-bss -fno-unit-at-a-time\n \n # Additional sources to handle exceptions; overridden by targets as needed.\n LIB2ADDEH = $(srcdir)/unwind-dw2.c $(srcdir)/unwind-dw2-fde.c \\\n@@ -785,7 +785,7 @@ OBJS = alias.o bb-reorder.o bitmap.o builtins.o caller-save.o calls.o\t   \\\n  sibcall.o simplify-rtx.o sreal.o ssa.o ssa-ccp.o ssa-dce.o stmt.o\t   \\\n  stor-layout.o stringpool.o timevar.o toplev.o tracer.o tree.o tree-dump.o \\\n  tree-inline.o unroll.o varasm.o varray.o version.o vmsdbgout.o xcoffout.o \\\n- alloc-pool.o et-forest.o\t\t\t\t\t\t   \\\n+ alloc-pool.o et-forest.o cgraph.o\t\t\t\t\t   \\\n  $(GGC) $(out_object_file) $(EXTRA_OBJS) $(host_hook_obj)\n \n BACKEND = main.o libbackend.a\n@@ -1530,6 +1530,8 @@ jump.o : jump.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) flags.h \\\n simplify-rtx.o : simplify-rtx.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(REGS_H) hard-reg-set.h flags.h real.h insn-config.h $(RECOG_H) $(EXPR_H) toplev.h \\\n    output.h function.h $(GGC_H) $(OBSTACK_H) $(TM_P_H) $(TREE_H) $(TARGET_H)\n+cgraph.o : cgraph.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n+   langhooks.h tree-inline.h toplev.h flags.h ggc.h  $(TARGET_H)\n cselib.o : cselib.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(REGS_H) \\\n    hard-reg-set.h flags.h real.h insn-config.h $(RECOG_H) $(EXPR_H) toplev.h \\\n    output.h function.h cselib.h $(GGC_H) $(TM_P_H) gt-cselib.h"}, {"sha": "a0c1d56c131b7c70fa0c133192fd3f7b01582dea", "filename": "gcc/c-decl.c", "status": "modified", "additions": 74, "deletions": 44, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e72fcfe8e47d6b453a9a7685c64b8595c32a2252/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e72fcfe8e47d6b453a9a7685c64b8595c32a2252/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=e72fcfe8e47d6b453a9a7685c64b8595c32a2252", "patch": "@@ -282,7 +282,7 @@ static tree grokdeclarator\t\tPARAMS ((tree, tree, enum decl_context,\n static tree grokparms\t\t\tPARAMS ((tree, int));\n static void layout_array_type\t\tPARAMS ((tree));\n static tree c_make_fname_decl           PARAMS ((tree, int));\n-static void c_expand_body               PARAMS ((tree, int, int));\n+static void c_expand_body_1             PARAMS ((tree, int));\n static void warn_if_shadowing\t\tPARAMS ((tree, tree));\n static bool flexible_array_type_p\tPARAMS ((tree));\n \f\n@@ -6412,10 +6412,62 @@ finish_function (nested, can_defer_p)\n   free_after_compilation (cfun);\n   cfun = NULL;\n \n+  if (flag_unit_at_a_time)\n+    {\n+      cgraph_finalize_function (fndecl, DECL_SAVED_TREE (fndecl));\n+      current_function_decl = NULL;\n+      return;\n+    }\n+\n   if (! nested)\n     {\n-      /* Generate RTL for the body of this function.  */\n-      c_expand_body (fndecl, nested, can_defer_p);\n+      /* Function is parsed.\n+\t Generate RTL for the body of this function or defer\n+\t it for later expansion.  */\n+      int uninlinable = 1;\n+\n+      /* There's no reason to do any of the work here if we're only doing\n+\t semantic analysis; this code just generates RTL.  */\n+      if (flag_syntax_only)\n+\t{\n+\t  current_function_decl = NULL;\n+\t  DECL_SAVED_TREE (fndecl) = NULL_TREE;\n+\t  return;\n+\t}\n+\n+      if (flag_inline_trees)\n+\t{\n+\t  /* First, cache whether the current function is inlinable.  Some\n+\t     predicates depend on cfun and current_function_decl to\n+\t     function completely.  */\n+\t  timevar_push (TV_INTEGRATION);\n+\t  uninlinable = ! tree_inlinable_function_p (fndecl);\n+\t  \n+\t  if (! uninlinable && can_defer_p\n+\t      /* Save function tree for inlining.  Should return 0 if the\n+\t\t language does not support function deferring or the\n+\t\t function could not be deferred.  */\n+\t      && defer_fn (fndecl))\n+\t    {\n+\t      /* Let the back-end know that this function exists.  */\n+\t      (*debug_hooks->deferred_inline_function) (fndecl);\n+\t      timevar_pop (TV_INTEGRATION);\n+\t      current_function_decl = NULL;\n+\t      return;\n+\t    }\n+\t  \n+\t  /* Then, inline any functions called in it.  */\n+\t  optimize_inline_calls (fndecl);\n+\t  timevar_pop (TV_INTEGRATION);\n+\t}\n+\n+      c_expand_body (fndecl);\n+\n+      if (uninlinable)\n+\t{\n+\t  /* Allow the body of the function to be garbage collected.  */\n+\t  DECL_SAVED_TREE (fndecl) = NULL_TREE;\n+\t}\n \n       /* Let the error reporting routines know that we're outside a\n \t function.  For a nested function, this value is used in\n@@ -6434,7 +6486,13 @@ c_expand_deferred_function (fndecl)\n      function was deferred, e.g. in duplicate_decls.  */\n   if (DECL_INLINE (fndecl) && DECL_RESULT (fndecl))\n     {\n-      c_expand_body (fndecl, 0, 0);\n+      if (flag_inline_trees)\n+\t{\n+\t  timevar_push (TV_INTEGRATION);\n+\t  optimize_inline_calls (fndecl);\n+\t  timevar_pop (TV_INTEGRATION);\n+\t}\n+      c_expand_body (fndecl);\n       current_function_decl = NULL;\n     }\n }\n@@ -6445,42 +6503,10 @@ c_expand_deferred_function (fndecl)\n    generation of RTL.  */\n \n static void\n-c_expand_body (fndecl, nested_p, can_defer_p)\n+c_expand_body_1 (fndecl, nested_p)\n      tree fndecl;\n-     int nested_p, can_defer_p;\n+     int nested_p;\n {\n-  int uninlinable = 1;\n-\n-  /* There's no reason to do any of the work here if we're only doing\n-     semantic analysis; this code just generates RTL.  */\n-  if (flag_syntax_only)\n-    return;\n-\n-  if (flag_inline_trees)\n-    {\n-      /* First, cache whether the current function is inlinable.  Some\n-         predicates depend on cfun and current_function_decl to\n-         function completely.  */\n-      timevar_push (TV_INTEGRATION);\n-      uninlinable = ! tree_inlinable_function_p (fndecl);\n-      \n-      if (! uninlinable && can_defer_p\n-\t  /* Save function tree for inlining.  Should return 0 if the\n-             language does not support function deferring or the\n-             function could not be deferred.  */\n-\t  && defer_fn (fndecl))\n-\t{\n-\t  /* Let the back-end know that this function exists.  */\n-\t  (*debug_hooks->deferred_inline_function) (fndecl);\n-          timevar_pop (TV_INTEGRATION);\n-\t  return;\n-\t}\n-      \n-      /* Then, inline any functions called in it.  */\n-      optimize_inline_calls (fndecl);\n-      timevar_pop (TV_INTEGRATION);\n-    }\n-\n   timevar_push (TV_EXPAND);\n \n   if (nested_p)\n@@ -6519,11 +6545,6 @@ c_expand_body (fndecl, nested_p, can_defer_p)\n \n   /* Generate the RTL for this function.  */\n   expand_stmt (DECL_SAVED_TREE (fndecl));\n-  if (uninlinable)\n-    {\n-      /* Allow the body of the function to be garbage collected.  */\n-      DECL_SAVED_TREE (fndecl) = NULL_TREE;\n-    }\n \n   /* We hard-wired immediate_size_expand to zero above.\n      expand_function_end will decrement this variable.  So, we set the\n@@ -6621,6 +6642,15 @@ c_expand_body (fndecl, nested_p, can_defer_p)\n     pop_function_context ();\n   timevar_pop (TV_EXPAND);\n }\n+\n+/* Like c_expand_body_1 but only for unnested functions.  */\n+\n+void\n+c_expand_body (fndecl)\n+     tree fndecl;\n+{\n+  c_expand_body_1 (fndecl, 0);\n+}\n \f\n /* Check the declarations given in a for-loop for satisfying the C99\n    constraints.  */\n@@ -6854,7 +6884,7 @@ c_expand_decl_stmt (t)\n   if (TREE_CODE (decl) == FUNCTION_DECL\n       && DECL_CONTEXT (decl) == current_function_decl\n       && DECL_SAVED_TREE (decl))\n-    c_expand_body (decl, /*nested_p=*/1, /*can_defer_p=*/0);\n+    c_expand_body_1 (decl, 1);\n }\n \n /* Return the IDENTIFIER_GLOBAL_VALUE of T, for use in common code, since"}, {"sha": "116561e9d0723a033c14517aef7362139910dde4", "filename": "gcc/c-lang.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e72fcfe8e47d6b453a9a7685c64b8595c32a2252/gcc%2Fc-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e72fcfe8e47d6b453a9a7685c64b8595c32a2252/gcc%2Fc-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lang.c?ref=e72fcfe8e47d6b453a9a7685c64b8595c32a2252", "patch": "@@ -99,6 +99,9 @@ static void c_init_options PARAMS ((void));\n #undef LANG_HOOKS_TREE_DUMP_DUMP_TREE_FN\n #define LANG_HOOKS_TREE_DUMP_DUMP_TREE_FN c_dump_tree\n \n+#undef LANG_HOOKS_CALLGRAPH_EXPAND_FUNCTION\n+#define LANG_HOOKS_CALLGRAPH_EXPAND_FUNCTION c_expand_body\n+\n #undef LANG_HOOKS_TYPE_FOR_MODE\n #define LANG_HOOKS_TYPE_FOR_MODE c_common_type_for_mode\n #undef LANG_HOOKS_TYPE_FOR_SIZE"}, {"sha": "a84ddc8fd70c9aa0f5614270e0fa37298f09d221", "filename": "gcc/c-objc-common.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e72fcfe8e47d6b453a9a7685c64b8595c32a2252/gcc%2Fc-objc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e72fcfe8e47d6b453a9a7685c64b8595c32a2252/gcc%2Fc-objc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-objc-common.c?ref=e72fcfe8e47d6b453a9a7685c64b8595c32a2252", "patch": "@@ -361,7 +361,13 @@ c_objc_common_finish_file ()\n   if (pch_file)\n     c_common_write_pch ();\n \n-  expand_deferred_fns ();\n+  if (flag_unit_at_a_time)\n+    {\n+      cgraph_finalize_compilation_unit ();\n+      cgraph_optimize ();\n+    }\n+  else\n+    expand_deferred_fns ();\n \n   if (static_ctors)\n     {"}, {"sha": "c69838692acf64abd239a4886f6c5d3ab03dc7c0", "filename": "gcc/c-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e72fcfe8e47d6b453a9a7685c64b8595c32a2252/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e72fcfe8e47d6b453a9a7685c64b8595c32a2252/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=e72fcfe8e47d6b453a9a7685c64b8595c32a2252", "patch": "@@ -172,6 +172,7 @@ extern void finish_file\t\t\t\tPARAMS ((void));\n extern int objc_comptypes                 \tPARAMS ((tree, tree, int));\n extern tree objc_message_selector\t\tPARAMS ((void));\n extern tree lookup_objc_ivar\t\t\tPARAMS ((tree));\n+extern void c_expand_body\t\t\tPARAMS ((tree));\n \n \f\n /* in c-parse.in */"}, {"sha": "a199fe6617f9532c80b5fe5ef4dff7d8f71e1f15", "filename": "gcc/cgraph.c", "status": "added", "additions": 563, "deletions": 0, "changes": 563, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e72fcfe8e47d6b453a9a7685c64b8595c32a2252/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e72fcfe8e47d6b453a9a7685c64b8595c32a2252/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=e72fcfe8e47d6b453a9a7685c64b8595c32a2252", "patch": "@@ -0,0 +1,563 @@\n+/* Callgraph handling code.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+   Contributed by Jan Hubicka\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"tree-inline.h\"\n+#include \"langhooks.h\"\n+#include \"hashtab.h\"\n+#include \"toplev.h\"\n+#include \"flags.h\"\n+#include \"ggc.h\"\n+#include \"debug.h\"\n+#include \"target.h\"\n+\n+/* The cgraph data strutcture.\n+   Each function decl has assigned cgraph_node listing calees and callers.  */\n+\n+struct cgraph_node\n+{\n+  tree decl;\n+  struct cgraph_edge *callees;\n+  struct cgraph_edge *callers;\n+  struct cgraph_node *next;\n+  /* For nested functions points to function the node is nested in.  */\n+  struct cgraph_node *origin;\n+  /* Points to first nested function, if any.  */\n+  struct cgraph_node *nested;\n+  /* Pointer to the next function with same origin, if any.  */\n+  struct cgraph_node *next_nested;\n+  void *aux;\n+\n+  /* Set when function must be output - it is externally visible\n+     or it's address is taken.  */\n+  bool needed;\n+  /* Set when function is reachable by call from other function\n+     that is eighter reachable or needed.  */\n+  bool reachable;\n+  /* Set when the frontend has been asked to lower representation of this\n+     function into trees.  Callees lists are not available when lowered\n+     is not set.  */\n+  bool lowered;\n+  /* Set when function is scheduled to be assembled.  */\n+  bool output;\n+};\n+\n+struct cgraph_edge\n+{\n+  struct cgraph_node *caller, *callee;\n+  struct cgraph_edge *next_caller;\n+  struct cgraph_edge *next_callee;\n+};\n+\n+/* Hash table used to convert declarations into nodes.  */\n+static htab_t cgraph_hash = 0;\n+\n+/* The linked list of cgraph nodes.  */\n+static struct cgraph_node *cgraph_nodes;\n+\n+/* Number of nodes in existence.  */\n+static int cgraph_n_nodes;\n+\n+static struct cgraph_node *cgraph_node PARAMS ((tree decl));\n+static struct cgraph_edge *create_edge PARAMS ((struct cgraph_node *,\n+\t\t\t\t\t\tstruct cgraph_node *));\n+static void remove_edge PARAMS ((struct cgraph_node *, struct cgraph_node *));\n+static struct cgraph_edge *record_call PARAMS ((tree, tree));\n+static tree record_call_1 PARAMS ((tree *, int *, void *));\n+static hashval_t hash_node PARAMS ((const PTR));\n+static int eq_node PARAMS ((const PTR, const PTR));\n+static struct cgraph_node *cgraph_node PARAMS ((tree));\n+static void cgraph_expand_functions PARAMS ((void));\n+static void cgraph_mark_functions_to_output PARAMS ((void));\n+static void cgraph_expand_function PARAMS ((struct cgraph_node *));\n+static void cgraph_mark_needed_node PARAMS ((struct cgraph_node *, int));\n+\n+/* Returns a hash code for P.  */\n+\n+static hashval_t\n+hash_node (p)\n+     const PTR p;\n+{\n+  return (hashval_t)\n+    htab_hash_pointer (DECL_ASSEMBLER_NAME\n+\t\t       (((struct cgraph_node *) p)->decl));\n+}\n+\n+/* Returns non-zero if P1 and P2 are equal.  */\n+\n+static int\n+eq_node (p1, p2)\n+     const PTR p1;\n+     const PTR p2;\n+{\n+  return ((DECL_ASSEMBLER_NAME (((struct cgraph_node *) p1)->decl)) ==\n+\t  DECL_ASSEMBLER_NAME ((tree) p2));\n+}\n+\n+/* Return cgraph node assigned to DECL.  Create new one when needed.  */\n+static struct cgraph_node *\n+cgraph_node (decl)\n+     tree decl;\n+{\n+  struct cgraph_node *node;\n+  struct cgraph_node **slot;\n+\n+  if (!cgraph_hash)\n+    cgraph_hash = htab_create (10, hash_node, eq_node, NULL);\n+\n+  slot =\n+    (struct cgraph_node **) htab_find_slot_with_hash (cgraph_hash, decl,\n+\t\t\t\t\t\t      htab_hash_pointer\n+\t\t\t\t\t\t      (DECL_ASSEMBLER_NAME\n+\t\t\t\t\t\t       (decl)), 1);\n+  if (*slot)\n+    return *slot;\n+  node = xcalloc (sizeof (*node), 1);\n+  node->decl = decl;\n+  node->next = cgraph_nodes;\n+  cgraph_nodes = node;\n+  cgraph_n_nodes++;\n+  *slot = node;\n+  if (DECL_CONTEXT (decl))\n+    {\n+      node->origin = cgraph_node (DECL_CONTEXT (decl));\n+      node->next_nested = node->origin->nested;\n+      node->origin->nested = node;\n+    }\n+  return node;\n+}\n+\n+/* Create edge from CALLER to CALLEE in the cgraph.  */\n+\n+static struct cgraph_edge *\n+create_edge (caller, callee)\n+     struct cgraph_node *caller, *callee;\n+{\n+  struct cgraph_edge *edge = xmalloc (sizeof (struct cgraph_edge));\n+\n+  edge->caller = caller;\n+  edge->callee = callee;\n+  edge->next_caller = callee->callers;\n+  edge->next_callee = caller->callees;\n+  caller->callees = edge;\n+  callee->callers = edge;\n+  return edge;\n+}\n+\n+/* Remove the edge from CALLER to CALLEE in the cgraph.  */\n+\n+static void\n+remove_edge (caller, callee)\n+     struct cgraph_node *caller, *callee;\n+{\n+  struct cgraph_edge **edge, **edge2;\n+\n+  for (edge = &callee->callers; *edge && (*edge)->caller != caller;\n+       edge = &((*edge)->next_caller))\n+    continue;\n+  if (!*edge)\n+    abort ();\n+  *edge = (*edge)->next_caller;\n+  for (edge2 = &caller->callees; *edge2 && (*edge2)->callee != callee;\n+       edge2 = &(*edge2)->next_callee)\n+    continue;\n+  if (!*edge2)\n+    abort ();\n+  *edge2 = (*edge2)->next_callee;\n+}\n+\n+/* Record call from CALLER to CALLEE  */\n+\n+static struct cgraph_edge *\n+record_call (caller, callee)\n+     tree caller, callee;\n+{\n+  return create_edge (cgraph_node (caller), cgraph_node (callee));\n+}\n+\n+void\n+cgraph_remove_call (caller, callee)\n+     tree caller, callee;\n+{\n+  remove_edge (cgraph_node (caller), cgraph_node (callee));\n+}\n+\n+/* Return true when CALLER_DECL calls CALLEE_DECL.  */\n+\n+bool\n+cgraph_calls_p (caller_decl, callee_decl)\n+     tree caller_decl, callee_decl;\n+{\n+  struct cgraph_node *caller = cgraph_node (caller_decl);\n+  struct cgraph_node *callee = cgraph_node (callee_decl);\n+  struct cgraph_edge *edge;\n+\n+  for (edge = callee->callers; edge && (edge)->caller != caller;\n+       edge = (edge->next_caller))\n+    continue;\n+  return edge != NULL;\n+}\n+\n+/* Walk tree and record all calls.  Called via walk_tree.  */\n+static tree\n+record_call_1 (tp, walk_subtrees, data)\n+     tree *tp;\n+     int *walk_subtrees;\n+     void *data;\n+{\n+  /* Record dereferences to the functions.  This makes the functions\n+     reachable unconditionally.  */\n+  if (TREE_CODE (*tp) == ADDR_EXPR)\n+    {\n+      tree decl = TREE_OPERAND (*tp, 0);\n+      if (TREE_CODE (decl) == FUNCTION_DECL)\n+        cgraph_mark_needed_node (cgraph_node (decl), 1);\n+    }\n+  else if (TREE_CODE (*tp) == CALL_EXPR)\n+    {\n+      tree decl = TREE_OPERAND (*tp, 0);\n+      if (TREE_CODE (decl) == ADDR_EXPR)\n+\tdecl = TREE_OPERAND (decl, 0);\n+      if (TREE_CODE (decl) == FUNCTION_DECL)\n+\t{\n+\t  if (DECL_BUILT_IN (decl))\n+\t    return NULL;\n+\t  record_call (data, decl);\n+\t  walk_tree (&TREE_OPERAND (*tp, 1), record_call_1, data, NULL);\n+\t  *walk_subtrees = 0;\n+\t}\n+    }\n+  return NULL;\n+}\n+\n+/* Create cgraph edges for function calles via BODY.  */\n+\n+void\n+cgraph_create_edges (decl, body)\n+     tree decl;\n+     tree body;\n+{\n+  walk_tree (&body, record_call_1, decl, NULL);\n+}\n+\n+/* Analyze function once it is parsed.  Set up the local information\n+   available - create cgraph edges for function calles via BODY.  */\n+\n+void\n+cgraph_finalize_function (decl, body)\n+     tree decl;\n+     tree body ATTRIBUTE_UNUSED;\n+{\n+  struct cgraph_node *node = cgraph_node (decl);\n+\n+  node->decl = decl;\n+\n+  /* Set TREE_UNINLINABLE flag.  */\n+  tree_inlinable_function_p (decl);\n+\n+  (*debug_hooks->deferred_inline_function) (decl);\n+}\n+\n+/* Dump the callgraph.  */\n+\n+void\n+dump_cgraph (f)\n+     FILE *f;\n+{\n+  struct cgraph_node *node;\n+\n+  fprintf (f, \"\\nCallgraph:\\n\\n\");\n+  for (node = cgraph_nodes; node; node = node->next)\n+    {\n+      struct cgraph_edge *edge;\n+      fprintf (f, \"%s\", IDENTIFIER_POINTER (DECL_NAME (node->decl)));\n+      if (node->origin)\n+\tfprintf (f, \" nested in: %s\",\n+\t\t IDENTIFIER_POINTER (DECL_NAME (node->origin->decl)));\n+      if (node->needed)\n+\tfprintf (f, \" needed\");\n+      else if (node->reachable)\n+\tfprintf (f, \" reachable\");\n+      if (DECL_SAVED_TREE (node->decl))\n+\tfprintf (f, \" tree\");\n+\n+      fprintf (f, \"\\n  called by :\");\n+      for (edge = node->callers; edge; edge = edge->next_caller)\n+\tfprintf (f, \"%s \",\n+\t\t IDENTIFIER_POINTER (DECL_NAME (edge->caller->decl)));\n+\n+      fprintf (f, \"\\n  calls: \");\n+      for (edge = node->callees; edge; edge = edge->next_callee)\n+\tfprintf (f, \"%s \",\n+\t\t IDENTIFIER_POINTER (DECL_NAME (edge->callee->decl)));\n+      fprintf (f, \"\\n\");\n+    }\n+}\n+\n+static struct cgraph_node *queue = NULL;\n+\n+/* Notify finalize_compilation_unit that given node is reachable\n+   or needed.  */\n+static void\n+cgraph_mark_needed_node (node, needed)\n+     struct cgraph_node *node;\n+     int needed;\n+{\n+  if (needed)\n+    {\n+      if (DECL_SAVED_TREE (node->decl))\n+        announce_function (node->decl);\n+      node->needed = 1;\n+    }\n+  if (!node->reachable)\n+    {\n+      node->reachable = 1;\n+      if (DECL_SAVED_TREE (node->decl))\n+\t{\n+\t  node->aux = queue;\n+\t  queue = node;\n+        }\n+    }\n+}\n+\n+/* Analyze the whole compilation unit once it is parsed completely.  */\n+\n+void\n+cgraph_finalize_compilation_unit ()\n+{\n+  struct cgraph_node *node;\n+  struct cgraph_edge *edge;\n+\n+  /* Collect entry points to the unit.  */\n+\n+  if (!quiet_flag)\n+    fprintf (stderr, \"\\n\\nUnit entry points:\");\n+\n+  for (node = cgraph_nodes; node; node = node->next)\n+    {\n+      tree decl = node->decl;\n+\n+      if (!DECL_SAVED_TREE (decl))\n+\tcontinue;\n+      if ((TREE_PUBLIC (decl) && !DECL_COMDAT (decl) && !DECL_EXTERNAL (decl))\n+\t  || (DECL_ASSEMBLER_NAME_SET_P (decl)\n+\t      && TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl))))\n+\t{\n+          cgraph_mark_needed_node (node, 1);\n+\t}\n+    }\n+\n+  /*  Propagate reachability flag and lower representation of all reachable\n+      functions.  In the future, lowering will introduce new functions and\n+      new entry points on the way (by template instantiation and virtual\n+      method table generation for instance).  */\n+  while (queue)\n+    {\n+      tree decl = queue->decl;\n+\n+      node = queue;\n+      queue = queue->aux;\n+      if (node->lowered || !node->reachable || !DECL_SAVED_TREE (decl))\n+\tabort ();\n+\n+      /* At the moment frontend automatically emits all nested functions.  */\n+      if (node->nested)\n+\t{\n+\t  struct cgraph_node *node2;\n+\n+\t  for (node2 = node->nested; node2; node2 = node2->next_nested)\n+\t    if (!node2->reachable)\n+\t      cgraph_mark_needed_node (node2, 0);\n+\t}\n+\n+      if (lang_hooks.callgraph.lower_function)\n+\t(*lang_hooks.callgraph.lower_function) (decl);\n+      /* First kill forward declaration so reverse inling works properly.  */\n+      cgraph_create_edges (decl, DECL_SAVED_TREE (decl));\n+\n+      for (edge = node->callees; edge; edge = edge->next_callee)\n+\t{\n+\t  if (!edge->callee->reachable)\n+            cgraph_mark_needed_node (edge->callee, 0);\n+\t}\n+      node->lowered = true;\n+    }\n+  if (!quiet_flag)\n+    fprintf (stderr, \"\\n\\nReclaiming functions:\");\n+\n+  for (node = cgraph_nodes; node; node = node->next)\n+    {\n+      tree decl = node->decl;\n+\n+      if (!node->reachable && DECL_SAVED_TREE (decl))\n+\t{\n+\t  DECL_SAVED_TREE (decl) = NULL;\n+\t  announce_function (decl);\n+\t}\n+    }\n+  ggc_collect ();\n+}\n+\n+/* Expand all functions that must be output.  */\n+\n+#define NPREDECESORS(node) (size_t)((node)->aux)\n+#define SET_NPREDECESORS(node,n) (node)->aux = (void *) (n);\n+\n+/* Figure out what functions we want to assemble.  */\n+\n+static void\n+cgraph_mark_functions_to_output ()\n+{\n+  struct cgraph_node *node;\n+\n+  /* Figure out functions we want to assemble.  */\n+  for (node = cgraph_nodes; node; node = node->next)\n+    {\n+      tree decl = node->decl;\n+\n+      if (DECL_SAVED_TREE (decl)\n+\t  && (node->needed\n+\t      || (DECL_UNINLINABLE (decl) && node->reachable)\n+\t      || TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl)))\n+\t  && !TREE_ASM_WRITTEN (decl) && !node->origin\n+\t  && !DECL_EXTERNAL (decl))\n+\tnode->output = 1;\n+    }\n+}\n+\n+/* Expand function specified by NODE.  */\n+static void\n+cgraph_expand_function (node)\n+     struct cgraph_node *node;\n+{\n+  tree decl = node->decl;\n+\n+  announce_function (decl);\n+  if (flag_inline_trees)\n+    optimize_inline_calls (decl);\n+  (*lang_hooks.callgraph.expand_function) (decl);\n+  if (DECL_UNINLINABLE (decl))\n+    DECL_SAVED_TREE (decl) = NULL;\n+  current_function_decl = NULL;\n+}\n+\n+\n+/* Expand all functions that must be output. \n+  \n+   Attempt to topologically sort the nodes so function is output when\n+   all called functions are already assembled to allow data to be propagated\n+   accross the callgraph.  Use stack to get smaller distance between function\n+   and it's callees (later we may use more sophisticated algorithm for\n+   function reordering, we will likely want to use subsections to make output\n+   functions to appear in top-down order, not bottom-up they are assembled).  */\n+\n+static void\n+cgraph_expand_functions ()\n+{\n+  struct cgraph_node *node;\n+  struct cgraph_node **stack =\n+    xcalloc (sizeof (struct cgraph_node *), cgraph_n_nodes);\n+  int stack_size = 0;\n+  struct cgraph_edge *edge;\n+\n+  cgraph_mark_functions_to_output ();\n+\n+  for (node = cgraph_nodes; node; node = node->next)\n+    if (node->output)\n+      {\n+\tint n = 0;\n+\tfor (edge = node->callees; edge; edge = edge->next_callee)\n+\t  if (edge->callee->output)\n+\t    n++;\n+\tSET_NPREDECESORS (node, n);\n+\tif (n == 0)\n+\t  stack[stack_size++] = node;\n+      }\n+  while (1)\n+    {\n+      struct cgraph_node *minnode;\n+      while (stack_size)\n+\t{\n+\t  node = stack[--stack_size];\n+\t  node->output = 0;\n+\n+\t  for (edge = node->callers; edge; edge = edge->next_caller)\n+\t    if (edge->caller->output)\n+\t      {\n+\t        SET_NPREDECESORS (edge->caller,\n+\t\t    \t\t  NPREDECESORS (edge->caller) - 1);\n+\t\tif (!NPREDECESORS (edge->caller))\n+\t\t  stack[stack_size++] = edge->caller;\n+\t      }\n+\t  if (!node->reachable)\n+\t    abort ();\n+\t  cgraph_expand_function (node);\n+\t}\n+      minnode = NULL;\n+      /* We found cycle.  Break it and try again.  */\n+      for (node = cgraph_nodes; node; node = node->next)\n+\tif (node->output\n+\t    && (!minnode\n+\t        || NPREDECESORS (minnode) > NPREDECESORS (node)))\n+\t  minnode = node;\n+      if (!minnode)\n+\treturn;\n+      stack[stack_size++] = minnode;\n+    }\n+}\n+\n+/* Perform simple optimizations based on callgraph.  */\n+\n+void\n+cgraph_optimize ()\n+{\n+  struct cgraph_node *node;\n+  bool changed = true;\n+  struct cgraph_edge *edge;\n+\n+  if (!quiet_flag)\n+    fprintf (stderr, \"\\n\\nAssembling functions:\");\n+\n+  /* Output everything.  \n+     ??? Our inline heuristic may decide to not inline functions previously\n+     marked as inlinable thus adding new function bodies that must be output.\n+     Later we should move all inlining decisions to callgraph code to make\n+     this impossible.  */\n+  cgraph_expand_functions ();\n+  while (changed)\n+    {\n+      changed = false;\n+      for (node = cgraph_nodes; node; node = node->next)\n+\t{\n+\t  if (!node->needed)\n+\t    continue;\n+\n+\t  for (edge = node->callees; edge; edge = edge->next_callee)\n+\t    if (!edge->callee->needed)\n+\t      changed = edge->callee->needed = true;\n+\t}\n+    }\n+  cgraph_expand_functions ();\n+}"}, {"sha": "a21f1bb69c35d8c9b2295bfa5afe832e75ebc4bf", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e72fcfe8e47d6b453a9a7685c64b8595c32a2252/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e72fcfe8e47d6b453a9a7685c64b8595c32a2252/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=e72fcfe8e47d6b453a9a7685c64b8595c32a2252", "patch": "@@ -290,7 +290,7 @@ in the following sections.\n -fsched-spec-load-dangerous  -fsignaling-nans @gol\n -fsingle-precision-constant  -fssa -fssa-ccp -fssa-dce @gol\n -fstrength-reduce  -fstrict-aliasing  -ftracer -fthread-jumps @gol\n--funroll-all-loops  -funroll-loops  -funswitch-loops @gol\n+-funit-at-a-time -funroll-all-loops  -funroll-loops  -funswitch-loops @gol\n --param @var{name}=@var{value}\n -O  -O0  -O1  -O2  -O3  -Os}\n \n@@ -4261,6 +4261,11 @@ Perform tail duplication to enlarge superblock size. This transformation\n simplifies the control flow of the function allowing other optimizations to do\n better job.\n \n+@item -funit-at-a-time\n+@opindex funit-at-a-time\n+Parse the whole compilation unit before starting to produce code.  This allows some\n+extra optimizations to take place but consumes more memory.\n+\n @item -funroll-loops\n @opindex funroll-loops\n Unroll loops whose number of iterations can be determined at compile"}, {"sha": "18cffaa479bbcb27dcae2cfe35c4d8990b4c25c1", "filename": "gcc/flags.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e72fcfe8e47d6b453a9a7685c64b8595c32a2252/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e72fcfe8e47d6b453a9a7685c64b8595c32a2252/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=e72fcfe8e47d6b453a9a7685c64b8595c32a2252", "patch": "@@ -652,6 +652,8 @@ extern int flag_zero_initialized_in_bss;\n /* Nonzero means disable transformations observable by signaling NaNs.  */\n extern int flag_signaling_nans;\n \n+extern int flag_unit_at_a_time;\n+\n /* True if the given mode has a NaN representation and the treatment of\n    NaN operands is important.  Certain optimizations, such as folding\n    x * 0 into x, are not correct for NaN operands, and are normally"}, {"sha": "c38fdd8c1f64cd416f2f62dc460e55d3461c04fa", "filename": "gcc/langhooks-def.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e72fcfe8e47d6b453a9a7685c64b8595c32a2252/gcc%2Flanghooks-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e72fcfe8e47d6b453a9a7685c64b8595c32a2252/gcc%2Flanghooks-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks-def.h?ref=e72fcfe8e47d6b453a9a7685c64b8595c32a2252", "patch": "@@ -164,6 +164,14 @@ tree lhd_tree_inlining_convert_parm_for_inlining PARAMS ((tree, tree, tree));\n   LANG_HOOKS_TREE_INLINING_CONVERT_PARM_FOR_INLINING \\\n } \\\n \n+#define LANG_HOOKS_CALLGRAPH_LOWER_FUNCTION NULL\n+#define LANG_HOOKS_CALLGRAPH_EXPAND_FUNCTION NULL\n+\n+#define LANG_HOOKS_CALLGRAPH_INITIALIZER { \\\n+  LANG_HOOKS_CALLGRAPH_LOWER_FUNCTION, \\\n+  LANG_HOOKS_CALLGRAPH_EXPAND_FUNCTION, \\\n+} \\\n+\n #define LANG_HOOKS_FUNCTION_INITIALIZER {\t\\\n   LANG_HOOKS_FUNCTION_INIT,\t\t\t\\\n   LANG_HOOKS_FUNCTION_FINAL,\t\t\t\\\n@@ -261,6 +269,7 @@ int lhd_tree_dump_type_quals\t\t\tPARAMS ((tree));\n   LANG_HOOKS_FORMAT_ATTRIBUTE_TABLE, \\\n   LANG_HOOKS_FUNCTION_INITIALIZER, \\\n   LANG_HOOKS_TREE_INLINING_INITIALIZER, \\\n+  LANG_HOOKS_CALLGRAPH_INITIALIZER, \\\n   LANG_HOOKS_TREE_DUMP_INITIALIZER, \\\n   LANG_HOOKS_DECLS, \\\n   LANG_HOOKS_FOR_TYPES_INITIALIZER \\"}, {"sha": "3118d2cfc696cc3655c5cb33fc9309a292d3c7ab", "filename": "gcc/langhooks.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e72fcfe8e47d6b453a9a7685c64b8595c32a2252/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e72fcfe8e47d6b453a9a7685c64b8595c32a2252/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=e72fcfe8e47d6b453a9a7685c64b8595c32a2252", "patch": "@@ -58,6 +58,15 @@ struct lang_hooks_for_tree_inlining\n \t\t\t\t\t\t\t union tree_node *));\n };\n \n+struct lang_hooks_for_callgraph\n+{\n+  /* Function passed as argument is needed and will be compiled.\n+     Lower the representation so the calls are explicit.  */\n+  void (*lower_function) PARAMS ((union tree_node *));\n+  /* Produce RTL for function passed as argument.  */\n+  void (*expand_function) PARAMS ((union tree_node *));\n+};\n+\n /* Lang hooks for management of language-specific data or status\n    when entering / leaving functions etc.  */\n struct lang_hooks_for_functions\n@@ -353,6 +362,8 @@ struct lang_hooks\n \n   struct lang_hooks_for_tree_inlining tree_inlining;\n \n+  struct lang_hooks_for_callgraph callgraph;\n+\n   struct lang_hooks_for_tree_dump tree_dump;\n \n   struct lang_hooks_for_decls decls;"}, {"sha": "0e05323503e81705c9f9078e4dac70fa3ed355f3", "filename": "gcc/toplev.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e72fcfe8e47d6b453a9a7685c64b8595c32a2252/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e72fcfe8e47d6b453a9a7685c64b8595c32a2252/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=e72fcfe8e47d6b453a9a7685c64b8595c32a2252", "patch": "@@ -883,6 +883,10 @@ int flag_new_regalloc = 0;\n \n int flag_tracer = 0;\n \n+/* Nonzero if we perform whole unit at a time compilation.  */\n+\n+int flag_unit_at_a_time = 0;\n+\n /* Values of the -falign-* flags: how much to align labels in code.\n    0 means `use default', 1 means `don't align'.\n    For each variable, there is an _log variant which is the power\n@@ -989,6 +993,8 @@ static const lang_independent_options f_options[] =\n    N_(\"Optimize sibling and tail recursive calls\") },\n   {\"tracer\", &flag_tracer, 1,\n    N_(\"Perform superblock formation via tail duplication\") },\n+  {\"unit-at-a-time\", &flag_unit_at_a_time, 1,\n+   N_(\"Compile whole compilation unit at a time\") },\n   {\"cse-follow-jumps\", &flag_cse_follow_jumps, 1,\n    N_(\"When running CSE, follow jumps to their targets\") },\n   {\"cse-skip-blocks\", &flag_cse_skip_blocks, 1,\n@@ -5124,6 +5130,11 @@ process_options ()\n   if (flag_asynchronous_unwind_tables)\n     flag_unwind_tables = 1;\n \n+  /* Disable unit-at-a-time mode for frontends not supporting callgraph\n+     interface.  */\n+  if (flag_unit_at_a_time && ! lang_hooks.callgraph.expand_function)\n+    flag_unit_at_a_time = 0;\n+\n   /* Warn about options that are not supported on this machine.  */\n #ifndef INSN_SCHEDULING\n   if (flag_schedule_insns || flag_schedule_insns_after_reload)"}, {"sha": "19b7a4f8fc8d12e024932f7da714ab87f1fda787", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e72fcfe8e47d6b453a9a7685c64b8595c32a2252/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e72fcfe8e47d6b453a9a7685c64b8595c32a2252/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=e72fcfe8e47d6b453a9a7685c64b8595c32a2252", "patch": "@@ -103,6 +103,8 @@ typedef struct inline_data\n   /* Hash table used to prevent walk_tree from visiting the same node\n      umpteen million times.  */\n   htab_t tree_pruner;\n+  /* Decl of function we are inlining into.  */\n+  tree decl;\n } inline_data;\n \n /* Prototypes.  */\n@@ -1368,6 +1370,13 @@ expand_call_inline (tp, walk_subtrees, data)\n   /* For accounting, subtract one for the saved call/ret.  */\n   id->inlined_stmts += DECL_NUM_STMTS (fn) - 1;\n \n+  /* Update callgraph if needed.  */\n+  if (id->decl && flag_unit_at_a_time)\n+    {\n+      cgraph_remove_call (id->decl, fn);\n+      cgraph_create_edges (id->decl, *inlined_body);\n+    }\n+\n   /* Recurse into the body of the just inlined function.  */\n   expand_calls_inline (inlined_body, id);\n   VARRAY_POP (id->fns);\n@@ -1414,6 +1423,7 @@ optimize_inline_calls (fn)\n   /* Clear out ID.  */\n   memset (&id, 0, sizeof (id));\n \n+  id.decl = fn;\n   /* Don't allow recursion into FN.  */\n   VARRAY_TREE_INIT (id.fns, 32, \"fns\");\n   VARRAY_PUSH_TREE (id.fns, fn);"}, {"sha": "e5344782fb8bbeb315407821bccb5f092bd14536", "filename": "gcc/tree.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e72fcfe8e47d6b453a9a7685c64b8595c32a2252/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e72fcfe8e47d6b453a9a7685c64b8595c32a2252/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=e72fcfe8e47d6b453a9a7685c64b8595c32a2252", "patch": "@@ -3164,6 +3164,15 @@ extern const char *dump_flag_name\tPARAMS ((enum tree_dump_index));\n \n extern void set_decl_rtl\t\tPARAMS ((tree, rtx));\n \n+/* In callgraph.c  */\n+void cgraph_finalize_function\t\tPARAMS ((tree, tree));\n+void cgraph_finalize_compilation_unit\tPARAMS ((void));\n+void cgraph_create_edges\t\tPARAMS ((tree, tree));\n+void dump_cgraph\t\t\tPARAMS ((FILE *));\n+void cgraph_optimize\t\t\tPARAMS ((void));\n+void cgraph_remove_call\t\t\tPARAMS ((tree, tree));\n+bool cgraph_calls_p\t\t\tPARAMS ((tree, tree));\n+\n \f\n /* Redefine abort to report an internal error w/o coredump, and\n    reporting the location of the error in the source file.  This logic"}]}