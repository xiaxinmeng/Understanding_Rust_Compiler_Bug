{"sha": "2096ebd393a5a25921c85de1209b38c715924e22", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjA5NmViZDM5M2E1YTI1OTIxYzg1ZGUxMjA5YjM4YzcxNTkyNGUyMg==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-11-09T23:12:47Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-11-09T23:12:47Z"}, "message": "c++: Reuse identical ATOMIC_CONSTRs during normalization\n\nProfiling revealed that sat_hasher::equal accounts for nearly 40% of\ncompile time in some cmcstl2 tests.\n\nThis patch eliminates this bottleneck by caching the ATOMIC_CONSTRs\nreturned by normalize_atom.  This in turn allows us to replace the\nexpensive atomic_constraints_identical_p check in sat_hasher::equal\nwith cheap pointer equality, with no loss in cache hit rate.\n\nWith this patch, compile time for the cmcstl2 test\ntest/algorithm/set_symmetric_difference4.cpp drops from 19s to 11s with\nan --enable-checking=release compiler.\n\ngcc/cp/ChangeLog:\n\n\t* constraint.cc (atom_cache): Define this deletable hash_table.\n\t(normalize_atom): Use it to cache ATOMIC_CONSTRs when not\n\tgenerating diagnostics.\n\t(sat_hasher::hash): Use htab_hash_pointer instead of\n\thash_atomic_constraint.\n\t(sat_hasher::equal): Test for pointer equality instead of\n\tatomic_constraints_identical_p.\n\t* cp-tree.h (struct atom_hasher): Moved and renamed from ...\n\t* logic.cc (struct constraint_hash): ... here.\n\t(clause::m_set): Adjust accordingly.", "tree": {"sha": "3e41d28c28f581e254a7d0065e729c452b282039", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3e41d28c28f581e254a7d0065e729c452b282039"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2096ebd393a5a25921c85de1209b38c715924e22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2096ebd393a5a25921c85de1209b38c715924e22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2096ebd393a5a25921c85de1209b38c715924e22", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2096ebd393a5a25921c85de1209b38c715924e22/comments", "author": null, "committer": null, "parents": [{"sha": "71a8040716c1342547a19c25bd0203ac29258ef3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71a8040716c1342547a19c25bd0203ac29258ef3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71a8040716c1342547a19c25bd0203ac29258ef3"}], "stats": {"total": 59, "additions": 40, "deletions": 19}, "files": [{"sha": "613ced26e2b2dd55db169e1dbfa0f1a8c7d0cd65", "filename": "gcc/cp/constraint.cc", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2096ebd393a5a25921c85de1209b38c715924e22/gcc%2Fcp%2Fconstraint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2096ebd393a5a25921c85de1209b38c715924e22/gcc%2Fcp%2Fconstraint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstraint.cc?ref=2096ebd393a5a25921c85de1209b38c715924e22", "patch": "@@ -710,6 +710,10 @@ normalize_concept_check (tree check, tree args, norm_info info)\n   return normalize_expression (def, subst, info);\n }\n \n+/* Used by normalize_atom to cache ATOMIC_CONSTRs.  */\n+\n+static GTY((deletable)) hash_table<atom_hasher> *atom_cache;\n+\n /* The normal form of an atom depends on the expression. The normal\n    form of a function call to a function concept is a check constraint\n    for that concept. The normal form of a reference to a variable\n@@ -729,7 +733,19 @@ normalize_atom (tree t, tree args, norm_info info)\n   /* Build a new info object for the atom.  */\n   tree ci = build_tree_list (t, info.context);\n \n-  return build1 (ATOMIC_CONSTR, ci, map);\n+  tree atom = build1 (ATOMIC_CONSTR, ci, map);\n+  if (!info.generate_diagnostics ())\n+    {\n+      /* Cache the ATOMIC_CONSTRs that we return, so that sat_hasher::equal\n+\t later can cheaply compare two atoms using just pointer equality.  */\n+      if (!atom_cache)\n+\tatom_cache = hash_table<atom_hasher>::create_ggc (31);\n+      tree *slot = atom_cache->find_slot (atom, INSERT);\n+      if (*slot)\n+\treturn *slot;\n+      *slot = atom;\n+    }\n+  return atom;\n }\n \n /* Returns the normal form of an expression. */\n@@ -2294,13 +2310,18 @@ struct sat_hasher : ggc_ptr_hash<sat_entry>\n {\n   static hashval_t hash (sat_entry *e)\n   {\n-    hashval_t value = hash_atomic_constraint (e->constr);\n+    /* Since normalize_atom caches the ATOMIC_CONSTRs it returns,\n+       we can assume pointer-based identity for fast hashing and\n+       comparison.  Even if this assumption is violated, that's\n+       okay, we'll just get a cache miss.  */\n+    hashval_t value = htab_hash_pointer (e->constr);\n     return iterative_hash_template_arg (e->args, value);\n   }\n \n   static bool equal (sat_entry *e1, sat_entry *e2)\n   {\n-    if (!atomic_constraints_identical_p (e1->constr, e2->constr))\n+    /* As in sat_hasher::hash.  */\n+    if (e1->constr != e2->constr)\n       return false;\n     return template_args_equal (e1->args, e2->args);\n   }"}, {"sha": "c7e25dfec8d46335f8f0c09b415e23acd32d97b9", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2096ebd393a5a25921c85de1209b38c715924e22/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2096ebd393a5a25921c85de1209b38c715924e22/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=2096ebd393a5a25921c85de1209b38c715924e22", "patch": "@@ -7839,6 +7839,21 @@ extern hashval_t iterative_hash_constraint      (tree, hashval_t);\n extern hashval_t hash_atomic_constraint         (tree);\n extern void diagnose_constraints                (location_t, tree, tree);\n \n+/* A structural hasher for ATOMIC_CONSTRs.  */\n+\n+struct atom_hasher : default_hash_traits<tree>\n+{\n+  static hashval_t hash (tree t)\n+  {\n+    return hash_atomic_constraint (t);\n+  }\n+\n+  static bool equal (tree t1, tree t2)\n+  {\n+    return atomic_constraints_identical_p (t1, t2);\n+  }\n+};\n+\n /* in logic.cc */\n extern bool subsumes                            (tree, tree);\n "}, {"sha": "6701488bc1cce9af2957b6c15e0a0d6f065f54cd", "filename": "gcc/cp/logic.cc", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2096ebd393a5a25921c85de1209b38c715924e22/gcc%2Fcp%2Flogic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2096ebd393a5a25921c85de1209b38c715924e22/gcc%2Fcp%2Flogic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flogic.cc?ref=2096ebd393a5a25921c85de1209b38c715924e22", "patch": "@@ -47,21 +47,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"toplev.h\"\n #include \"type-utils.h\"\n \n-/* Hash functions for atomic constrains.  */\n-\n-struct constraint_hash : default_hash_traits<tree>\n-{\n-  static hashval_t hash (tree t)\n-  {\n-    return hash_atomic_constraint (t);\n-  }\n-\n-  static bool equal (tree t1, tree t2)\n-  {\n-    return atomic_constraints_identical_p (t1, t2);\n-  }\n-};\n-\n /* A conjunctive or disjunctive clause.\n \n    Each clause maintains an iterator that refers to the current\n@@ -219,7 +204,7 @@ struct clause\n   }\n \n   std::list<tree> m_terms; /* The list of terms.  */\n-  hash_set<tree, false, constraint_hash> m_set; /* The set of atomic constraints.  */\n+  hash_set<tree, false, atom_hasher> m_set; /* The set of atomic constraints.  */\n   iterator m_current; /* The current term.  */\n };\n "}]}