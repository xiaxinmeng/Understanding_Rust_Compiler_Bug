{"sha": "d2653984bf029176260b5afd80f2bec90aa040f5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDI2NTM5ODRiZjAyOTE3NjI2MGI1YWZkODBmMmJlYzkwYWEwNDBmNQ==", "commit": {"author": {"name": "Torvald Riegel", "email": "triegel@redhat.com", "date": "2016-01-16T22:08:41Z"}, "committer": {"name": "Torvald Riegel", "email": "torvald@gcc.gnu.org", "date": "2016-01-16T22:08:41Z"}, "message": "libitm: Ensure proxy privatization safety.\n\n\t* method-gl.cc (gl_wt_dispatch::trycommit): Ensure proxy privatization\n\tsafety.\n\t* method-ml.cc (ml_wt_dispatch::trycommit): Likewise.\n\t* libitm/testsuite/libitm.c/priv-1.c: New.\n\nFrom-SVN: r232469", "tree": {"sha": "6344612f38b36403102234efac1277ca09d2d40b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6344612f38b36403102234efac1277ca09d2d40b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d2653984bf029176260b5afd80f2bec90aa040f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2653984bf029176260b5afd80f2bec90aa040f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2653984bf029176260b5afd80f2bec90aa040f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2653984bf029176260b5afd80f2bec90aa040f5/comments", "author": {"login": "triegelrh", "id": 62400967, "node_id": "MDQ6VXNlcjYyNDAwOTY3", "avatar_url": "https://avatars.githubusercontent.com/u/62400967?v=4", "gravatar_id": "", "url": "https://api.github.com/users/triegelrh", "html_url": "https://github.com/triegelrh", "followers_url": "https://api.github.com/users/triegelrh/followers", "following_url": "https://api.github.com/users/triegelrh/following{/other_user}", "gists_url": "https://api.github.com/users/triegelrh/gists{/gist_id}", "starred_url": "https://api.github.com/users/triegelrh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/triegelrh/subscriptions", "organizations_url": "https://api.github.com/users/triegelrh/orgs", "repos_url": "https://api.github.com/users/triegelrh/repos", "events_url": "https://api.github.com/users/triegelrh/events{/privacy}", "received_events_url": "https://api.github.com/users/triegelrh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "197a6aa6f9d5d341d74c73bbc9714c51bf9fde70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/197a6aa6f9d5d341d74c73bbc9714c51bf9fde70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/197a6aa6f9d5d341d74c73bbc9714c51bf9fde70"}], "stats": {"total": 154, "additions": 149, "deletions": 5}, "files": [{"sha": "fd41c82d858ad39958aaee2a76372635feed3105", "filename": "libitm/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2653984bf029176260b5afd80f2bec90aa040f5/libitm%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2653984bf029176260b5afd80f2bec90aa040f5/libitm%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2FChangeLog?ref=d2653984bf029176260b5afd80f2bec90aa040f5", "patch": "@@ -1,3 +1,10 @@\n+2016-01-16  Torvald Riegel  <triegel@redhat.com>\n+\n+\t* method-gl.cc (gl_wt_dispatch::trycommit): Ensure proxy privatization\n+\tsafety.\n+\t* method-ml.cc (ml_wt_dispatch::trycommit): Likewise.\n+\t* libitm/testsuite/libitm.c/priv-1.c: New.\n+\n 2015-01-15  Torvald Riegel  <triegel@redhat.com>\n \n \ttestsuite/libitm.c++/libstdc++-safeexc.C: New."}, {"sha": "b51c802f19170817e61432e07d134c944d7585aa", "filename": "libitm/method-gl.cc", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2653984bf029176260b5afd80f2bec90aa040f5/libitm%2Fmethod-gl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2653984bf029176260b5afd80f2bec90aa040f5/libitm%2Fmethod-gl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fmethod-gl.cc?ref=d2653984bf029176260b5afd80f2bec90aa040f5", "patch": "@@ -291,12 +291,18 @@ class gl_wt_dispatch : public abi_dispatch\n         // See begin_or_restart() for why we need release memory order here.\n \tv = gl_mg::clear_locked(v) + 1;\n \to_gl_mg.orec.store(v, memory_order_release);\n-\n-\t// Need to ensure privatization safety. Every other transaction must\n-\t// have a snapshot time that is at least as high as our commit time\n-\t// (i.e., our commit must be visible to them).\n-\tpriv_time = v;\n       }\n+\n+    // Need to ensure privatization safety. Every other transaction must have\n+    // a snapshot time that is at least as high as our commit time (i.e., our\n+    // commit must be visible to them).  Because of proxy privatization, we\n+    // must ensure that even if we are a read-only transaction.  See\n+    // ml_wt_dispatch::trycommit() for details: We can't get quite the same\n+    // set of problems because we just use one orec and thus, for example,\n+    // there cannot be concurrent writers -- but we can still get pending\n+    // loads to privatized data when not ensuring privatization safety, which\n+    // is problematic if the program unmaps the privatized memory.\n+    priv_time = v;\n     return true;\n   }\n "}, {"sha": "c1a6771d3f91bd4dbfe42444f3350539f1024ea8", "filename": "libitm/method-ml.cc", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2653984bf029176260b5afd80f2bec90aa040f5/libitm%2Fmethod-ml.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2653984bf029176260b5afd80f2bec90aa040f5/libitm%2Fmethod-ml.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fmethod-ml.cc?ref=d2653984bf029176260b5afd80f2bec90aa040f5", "patch": "@@ -513,6 +513,21 @@ class ml_wt_dispatch : public abi_dispatch\n     if (!tx->writelog.size())\n       {\n         tx->readlog.clear();\n+        // We still need to ensure privatization safety, unfortunately.  While\n+        // we cannot have privatized anything by ourselves (because we are not\n+        // an update transaction), we can have observed the commits of\n+        // another update transaction that privatized something.  Because any\n+        // commit happens before ensuring privatization, our snapshot and\n+        // commit can thus have happened before ensuring privatization safety\n+        // for this commit/snapshot time.  Therefore, before we can return to\n+        // nontransactional code that might use the privatized data, we must\n+        // ensure privatization safety for our snapshot time.\n+        // This still seems to be better than not allowing use of the\n+        // snapshot time before privatization safety has been ensured because\n+        // we at least can run transactions such as this one, and in the\n+        // meantime the transaction producing this commit time might have\n+        // finished ensuring privatization safety for it.\n+        priv_time = tx->shared_state.load(memory_order_relaxed);\n         return true;\n       }\n "}, {"sha": "635d5237f2985c8be1f507e12e9790bee7aa60eb", "filename": "libitm/testsuite/libitm.c/priv-1.c", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2653984bf029176260b5afd80f2bec90aa040f5/libitm%2Ftestsuite%2Flibitm.c%2Fpriv-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2653984bf029176260b5afd80f2bec90aa040f5/libitm%2Ftestsuite%2Flibitm.c%2Fpriv-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Ftestsuite%2Flibitm.c%2Fpriv-1.c?ref=d2653984bf029176260b5afd80f2bec90aa040f5", "patch": "@@ -0,0 +1,116 @@\n+/* Quick stress test for proxy privatization.  */\n+\n+/* We need to use a TM method that has to enforce privatization safety\n+   explicitly.  */\n+/* { dg-set-target-env-var ITM_DEFAULT_METHOD \"ml_wt\" } */\n+\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <pthread.h>\n+\n+/* Make them likely to be mapped to different orecs.  */\n+#define ALIGN __attribute__((aligned (256)))\n+/* Don't make these static to work around PR 68591.  */\n+int x ALIGN;\n+int *ptr ALIGN;\n+int *priv_ptr ALIGN;\n+int priv_value ALIGN;\n+int barrier ALIGN = 0;\n+const int iters = 100;\n+\n+static void arrive_and_wait (int expected_value)\n+{\n+  int now = __atomic_add_fetch (&barrier, 1, __ATOMIC_ACQ_REL);\n+  while (now < expected_value)\n+    __atomic_load (&barrier, &now, __ATOMIC_ACQUIRE);\n+}\n+\n+static void __attribute__((transaction_pure,noinline)) delay (int i)\n+{\n+  for (volatile int v = 0; v < i; v++);\n+}\n+\n+/* This tries to catch a case in which proxy privatization safety is not\n+   ensured by privatization_user.  Specifically, it's access to the value\n+   of it's transactional snapshot of ptr must read from an uncommitted write\n+   by writer; thus, writer must still be active but must have read ptr before\n+   proxy can privatize *ptr by assigning to ptr.\n+   We try to make this interleaving more likely by delaying the commit of\n+   writer and the start of proxy.  */\n+static void *writer (void *dummy __attribute__((unused)))\n+{\n+  for (int i = 0; i < iters; i++)\n+    {\n+      /* Initialize state in each round.  */\n+      x = 0;\n+      ptr = &x;\n+      priv_ptr = NULL;\n+      int wrote = 1;\n+      arrive_and_wait (i * 6 + 3);\n+      /* Interference by another writer.  Has a conflict with the proxy\n+\t privatizer.  */\n+      __transaction_atomic\n+\t{\n+\t  if (ptr != NULL)\n+\t    *ptr = 1;\n+\t  else\n+\t    wrote = 0;\n+\t  delay (2000000);\n+\t}\n+      arrive_and_wait (i * 6 + 6);\n+      /* If the previous transaction committed first, wrote == 1 and x == 1;\n+\t otherwise, if the proxy came first, wrote == 0 and priv_value == 0.\n+       */\n+      if (wrote != priv_value)\n+\tabort ();\n+    }\n+  return NULL;\n+}\n+\n+static void *proxy (void *dummy __attribute__((unused)))\n+{\n+  for (int i = 0; i < iters; i++)\n+    {\n+      arrive_and_wait (i * 6 + 3);\n+      delay(1000000);\n+      __transaction_atomic\n+\t{\n+\t  /* Hand-off to privatization-user and its read-only transaction and\n+\t     subsequent use of privatization.  */\n+\t  priv_ptr = ptr;\n+\t  ptr = NULL;\n+\t}\n+      arrive_and_wait (i * 6 + 6);\n+    }\n+  return NULL;\n+}\n+\n+static void *privatization_user (void *dummy __attribute__((unused)))\n+{\n+  for (int i = 0; i < iters; i++)\n+    {\n+      arrive_and_wait (i * 6 + 3);\n+      /* Spin until we have gotten a pointer from the proxy.  Then access\n+\t the value pointed to nontransactionally.  */\n+      int *p = NULL;\n+      while (p == NULL)\n+\t__transaction_atomic { p = priv_ptr; }\n+      priv_value = *p;\n+      arrive_and_wait (i * 6 + 6);\n+    }\n+  return NULL;\n+}\n+\n+int main()\n+{\n+  pthread_t p[3];\n+\n+  pthread_create (p+0, NULL, writer, NULL);\n+  pthread_create (p+1, NULL, proxy, NULL);\n+  pthread_create (p+2, NULL, privatization_user, NULL);\n+\n+  for (int i = 0; i < 3; ++i)\n+    pthread_join  (p[i], NULL);\n+\n+  return 0;\n+}"}]}