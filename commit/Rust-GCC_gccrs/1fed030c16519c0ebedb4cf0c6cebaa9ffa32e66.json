{"sha": "1fed030c16519c0ebedb4cf0c6cebaa9ffa32e66", "node_id": "C_kwDOANBUbNoAKDFmZWQwMzBjMTY1MTljMGViZWRiNGNmMGM2Y2ViYWE5ZmZhMzJlNjY", "commit": {"author": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-08-29T10:51:33Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2023-01-31T13:16:49Z"}, "message": "gccrs: macros: Handle matchers properly in repetitions\n\ngcc/rust/ChangeLog:\n\n\t* expand/rust-macro-expand.cc (MacroExpander::match_matcher): Handle\n\tfragments differently based on whether or not we are currently trying\n\tto match a matcher in a repetition context.\n\t(MacroExpander::match_n_matches): Use new `in_repetition` argument\n\tproperly when calling `match_matcher`.\n\t* expand/rust-macro-expand.h (MacroExpander::match_matcher): Allow\n\tpassing extra `in_repetition` bool argument\n\ngcc/testsuite/ChangeLog:\n\n\t* rust/compile/macro43.rs: New test.", "tree": {"sha": "eb4c5bd6a99ad154f0d395260a59292acfafb157", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb4c5bd6a99ad154f0d395260a59292acfafb157"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1fed030c16519c0ebedb4cf0c6cebaa9ffa32e66", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fed030c16519c0ebedb4cf0c6cebaa9ffa32e66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1fed030c16519c0ebedb4cf0c6cebaa9ffa32e66", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fed030c16519c0ebedb4cf0c6cebaa9ffa32e66/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f7014b28b81f43f62086d75222a9cfe7ca562b27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7014b28b81f43f62086d75222a9cfe7ca562b27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7014b28b81f43f62086d75222a9cfe7ca562b27"}], "stats": {"total": 80, "additions": 74, "deletions": 6}, "files": [{"sha": "df258bd96ece344aefeafb4e0e0fedc2d5fe6a7d", "filename": "gcc/rust/expand/rust-macro-expand.cc", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fed030c16519c0ebedb4cf0c6cebaa9ffa32e66/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fed030c16519c0ebedb4cf0c6cebaa9ffa32e66/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc?ref=1fed030c16519c0ebedb4cf0c6cebaa9ffa32e66", "patch": "@@ -435,7 +435,7 @@ MacroExpander::match_fragment (Parser<MacroInvocLexer> &parser,\n \n bool\n MacroExpander::match_matcher (Parser<MacroInvocLexer> &parser,\n-\t\t\t      AST::MacroMatcher &matcher)\n+\t\t\t      AST::MacroMatcher &matcher, bool in_repetition)\n {\n   if (depth_exceeds_recursion_limit ())\n     {\n@@ -485,8 +485,12 @@ MacroExpander::match_matcher (Parser<MacroInvocLexer> &parser,\n \n \t    // matched fragment get the offset in the token stream\n \t    size_t offs_end = source.get_offs ();\n-\t    sub_stack.insert_metavar (\n-\t      MatchedFragment (fragment->get_ident (), offs_begin, offs_end));\n+\t    if (in_repetition)\n+\t      sub_stack.append_fragment (\n+\t\tMatchedFragment (fragment->get_ident (), offs_begin, offs_end));\n+\t    else\n+\t      sub_stack.insert_metavar (\n+\t\tMatchedFragment (fragment->get_ident (), offs_begin, offs_end));\n \t  }\n \t  break;\n \n@@ -509,7 +513,7 @@ MacroExpander::match_matcher (Parser<MacroInvocLexer> &parser,\n \t    AST::MacroMatcher *m\n \t      = static_cast<AST::MacroMatcher *> (match.get ());\n \t    expansion_depth++;\n-\t    if (!match_matcher (parser, *m))\n+\t    if (!match_matcher (parser, *m, in_repetition))\n \t      {\n \t\texpansion_depth--;\n \t\treturn false;\n@@ -619,7 +623,7 @@ MacroExpander::match_n_matches (Parser<MacroInvocLexer> &parser,\n \t      case AST::MacroMatch::MacroMatchType::Matcher: {\n \t\tAST::MacroMatcher *m\n \t\t  = static_cast<AST::MacroMatcher *> (match.get ());\n-\t\tvalid_current_match = match_matcher (parser, *m);\n+\t\tvalid_current_match = match_matcher (parser, *m, true);\n \t      }\n \t      break;\n \t    }"}, {"sha": "bef140236b31da0870b8dd172dc869e89610705e", "filename": "gcc/rust/expand/rust-macro-expand.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fed030c16519c0ebedb4cf0c6cebaa9ffa32e66/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fed030c16519c0ebedb4cf0c6cebaa9ffa32e66/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.h?ref=1fed030c16519c0ebedb4cf0c6cebaa9ffa32e66", "patch": "@@ -273,7 +273,7 @@ struct MacroExpander\n \t\t\t AST::MacroMatchRepetition &rep);\n \n   bool match_matcher (Parser<MacroInvocLexer> &parser,\n-\t\t      AST::MacroMatcher &matcher);\n+\t\t      AST::MacroMatcher &matcher, bool in_repetition = false);\n \n   /**\n    * Match any amount of matches"}, {"sha": "c7bf50a030e62b533fbdb0585577f2bc1081bc47", "filename": "gcc/testsuite/rust/compile/macro43.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fed030c16519c0ebedb4cf0c6cebaa9ffa32e66/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro43.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fed030c16519c0ebedb4cf0c6cebaa9ffa32e66/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro43.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro43.rs?ref=1fed030c16519c0ebedb4cf0c6cebaa9ffa32e66", "patch": "@@ -0,0 +1,64 @@\n+macro_rules! nonzero_integers {\n+    ( $( $Ty: ident($Int: ty); )+ ) => {\n+        $(\n+            /// An integer that is known not to equal zero.\n+            ///\n+            /// This enables some memory layout optimization.\n+            /// For example, `Option<NonZeroU32>` is the same size as `u32`:\n+            ///\n+            /// ```rust\n+            /// use std::mem::size_of;\n+            /// assert_eq!(size_of::<Option<std::num::NonZeroU32>>(), size_of::<u32>());\n+            /// ```\n+            #[stable(feature = \"nonzero\", since = \"1.28.0\")]\n+            #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]\n+            #[repr(transparent)]\n+            pub struct $Ty(NonZero<$Int>);\n+\n+            impl $Ty {\n+                /// Create a non-zero without checking the value.\n+                ///\n+                /// # Safety\n+                ///\n+                /// The value must not be zero.\n+                #[stable(feature = \"nonzero\", since = \"1.28.0\")]\n+                #[inline]\n+                pub const unsafe fn new_unchecked(n: $Int) -> Self {\n+                    $Ty(NonZero(n))\n+                }\n+\n+                /// Create a non-zero if the given value is not zero.\n+                #[stable(feature = \"nonzero\", since = \"1.28.0\")]\n+                #[inline]\n+                pub fn new(n: $Int) -> Option<Self> {\n+                    if n != 0 {\n+                        Some($Ty(NonZero(n)))\n+                    } else {\n+                        None\n+                    }\n+                }\n+\n+                /// Returns the value as a primitive type.\n+                #[stable(feature = \"nonzero\", since = \"1.28.0\")]\n+                #[inline]\n+                pub fn get(self) -> $Int {\n+                    self.0 .0\n+                }\n+\n+            }\n+\n+            impl_nonzero_fmt! { // { dg-error \"unknown macro\" }\n+                (Debug, Display, Binary, Octal, LowerHex, UpperHex) for $Ty\n+            }\n+        )+\n+    }\n+}\n+\n+nonzero_integers! {\n+    NonZeroU8(u8);\n+    NonZeroU16(u16);\n+    NonZeroU32(u32);\n+    NonZeroU64(u64);\n+    NonZeroU128(u128);\n+    NonZeroUsize(usize);\n+}"}]}