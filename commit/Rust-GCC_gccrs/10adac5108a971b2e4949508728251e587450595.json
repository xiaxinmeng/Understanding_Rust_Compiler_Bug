{"sha": "10adac5108a971b2e4949508728251e587450595", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTBhZGFjNTEwOGE5NzFiMmU0OTQ5NTA4NzI4MjUxZTU4NzQ1MDU5NQ==", "commit": {"author": {"name": "Xinliang David Li", "email": "davidxl@gcc.gnu.org", "date": "2011-04-29T00:19:35Z"}, "committer": {"name": "Xinliang David Li", "email": "davidxl@gcc.gnu.org", "date": "2011-04-29T00:19:35Z"}, "message": "split checksum into cfg checksum and line checksum\n\nFrom-SVN: r173147", "tree": {"sha": "d953d6304eb53816e1ea571fc8d365f55655d39a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d953d6304eb53816e1ea571fc8d365f55655d39a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10adac5108a971b2e4949508728251e587450595", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10adac5108a971b2e4949508728251e587450595", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10adac5108a971b2e4949508728251e587450595", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10adac5108a971b2e4949508728251e587450595/comments", "author": null, "committer": null, "parents": [{"sha": "112cee354d70b375f142e342d79a5ddb93f3a0fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/112cee354d70b375f142e342d79a5ddb93f3a0fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/112cee354d70b375f142e342d79a5ddb93f3a0fd"}], "stats": {"total": 346, "additions": 264, "deletions": 82}, "files": [{"sha": "fdbc4f1212e863b9fee25e3091788ee1c5ec29ff", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10adac5108a971b2e4949508728251e587450595/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10adac5108a971b2e4949508728251e587450595/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=10adac5108a971b2e4949508728251e587450595", "patch": "@@ -1,3 +1,29 @@\n+2011-04-28  David Li  <davidxl@google.com>\n+\n+\t* tree.c (crc32_string): Use crc32_byte.\n+\t(crc32_byte): New function.\n+\t* tree.h (crc32_byte): New function.\n+\t* gcov.c (read_graph_file): Handle new cfg_cksum.\n+\t(read_count_file): Ditto.\n+\t* profile.c (instrument_values): Ditto.\n+\t(get_exec_counts): Ditto.\n+\t(read_profile_edge_counts): Ditto.\n+\t(compute_branch_probabilities): Ditto.\n+\t(compute_value_histograms): Ditto.\n+\t(branch_prob): Ditto.\n+\t(end_branch_prob): Ditto.\n+\t* coverage.c (read_counts_file): Ditto.\n+\t(get_coverage_counts): Ditto.\n+\t(tree_coverage_counter_addr): Ditto.\n+\t(coverage_checksum_string): Ditto.\n+\t(coverage_begin_output): Ditto.\n+\t(coverage_end_function): Ditto.\n+\t(build_fn_info_type): Ditto.\n+\t(build_fn_info_value): Ditto.\n+\t* libgcov.c (gcov_exit): Ditto.\n+\t* gcov-dump.c (tag_function): Ditto.\n+\t(compute_checksum): Remove.\n+\n 2011-04-29  Alan Modra  <amodra@gmail.com>\n \n \t* config/rs6000/rs6000.c (rs6000_delegitimize_address): Handle"}, {"sha": "1efd714c94091222f44cffc1926ff8431e632612", "filename": "gcc/coverage.c", "status": "modified", "additions": 90, "deletions": 38, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10adac5108a971b2e4949508728251e587450595/gcc%2Fcoverage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10adac5108a971b2e4949508728251e587450595/gcc%2Fcoverage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.c?ref=10adac5108a971b2e4949508728251e587450595", "patch": "@@ -51,13 +51,15 @@ along with GCC; see the file COPYING3.  If not see\n #include \"intl.h\"\n #include \"filenames.h\"\n \n+#include \"gcov-io.h\"\n #include \"gcov-io.c\"\n \n struct function_list\n {\n   struct function_list *next;\t /* next function */\n   unsigned ident;\t\t /* function ident */\n-  unsigned checksum;\t         /* function checksum */\n+  unsigned lineno_checksum;\t /* function lineno checksum */\n+  unsigned cfg_checksum;\t /* function cfg checksum */\n   unsigned n_ctrs[GCOV_COUNTERS];/* number of counters.  */\n };\n \n@@ -69,7 +71,8 @@ typedef struct counts_entry\n   unsigned ctr;\n \n   /* Store  */\n-  unsigned checksum;\n+  unsigned lineno_checksum;\n+  unsigned cfg_checksum;\n   gcov_type *counts;\n   struct gcov_ctr_summary summary;\n \n@@ -114,8 +117,6 @@ static hashval_t htab_counts_entry_hash (const void *);\n static int htab_counts_entry_eq (const void *, const void *);\n static void htab_counts_entry_del (void *);\n static void read_counts_file (void);\n-static unsigned compute_checksum (void);\n-static unsigned coverage_checksum_string (unsigned, const char *);\n static tree build_fn_info_type (unsigned);\n static tree build_fn_info_value (const struct function_list *, tree);\n static tree build_ctr_info_type (void);\n@@ -171,11 +172,12 @@ static void\n read_counts_file (void)\n {\n   gcov_unsigned_t fn_ident = 0;\n-  gcov_unsigned_t checksum = -1;\n   counts_entry_t *summaried = NULL;\n   unsigned seen_summary = 0;\n   gcov_unsigned_t tag;\n   int is_error = 0;\n+  unsigned lineno_checksum = 0;\n+  unsigned cfg_checksum = 0;\n \n   if (!gcov_open (da_file_name, 1))\n     return;\n@@ -215,7 +217,8 @@ read_counts_file (void)\n       if (tag == GCOV_TAG_FUNCTION)\n \t{\n \t  fn_ident = gcov_read_unsigned ();\n-\t  checksum = gcov_read_unsigned ();\n+\t  lineno_checksum = gcov_read_unsigned ();\n+\t  cfg_checksum = gcov_read_unsigned ();\n \t  if (seen_summary)\n \t    {\n \t      /* We have already seen a summary, this means that this\n@@ -265,24 +268,26 @@ read_counts_file (void)\n \t  if (!entry)\n \t    {\n \t      *slot = entry = XCNEW (counts_entry_t);\n-\t      entry->ident = elt.ident;\n+\t      entry->ident = fn_ident;\n \t      entry->ctr = elt.ctr;\n-\t      entry->checksum = checksum;\n+\t      entry->lineno_checksum = lineno_checksum;\n+\t      entry->cfg_checksum = cfg_checksum;\n \t      entry->summary.num = n_counts;\n \t      entry->counts = XCNEWVEC (gcov_type, n_counts);\n \t    }\n-\t  else if (entry->checksum != checksum)\n+\t  else if (entry->lineno_checksum != lineno_checksum\n+\t\t   || entry->cfg_checksum != cfg_checksum)\n \t    {\n-\t      error (\"coverage mismatch for function %u while reading execution counters\",\n-\t\t     fn_ident);\n-\t      error (\"checksum is %x instead of %x\", entry->checksum, checksum);\n+\t      error (\"Profile data for function %u is corrupted\", fn_ident);\n+\t      error (\"checksum is (%x,%x) instead of (%x,%x)\",\n+\t\t     entry->lineno_checksum, entry->cfg_checksum,\n+\t\t     lineno_checksum, cfg_checksum);\n \t      htab_delete (counts_hash);\n \t      break;\n \t    }\n \t  else if (entry->summary.num != n_counts)\n \t    {\n-\t      error (\"coverage mismatch for function %u while reading execution counters\",\n-\t\t     fn_ident);\n+\t      error (\"Profile data for function %u is corrupted\", fn_ident);\n \t      error (\"number of counters is %d instead of %d\", entry->summary.num, n_counts);\n \t      htab_delete (counts_hash);\n \t      break;\n@@ -324,10 +329,10 @@ read_counts_file (void)\n \n gcov_type *\n get_coverage_counts (unsigned counter, unsigned expected,\n+                     unsigned cfg_checksum, unsigned lineno_checksum,\n \t\t     const struct gcov_ctr_summary **summary)\n {\n   counts_entry_t *entry, elt;\n-  gcov_unsigned_t checksum = -1;\n \n   /* No hash table, no counts.  */\n   if (!counts_hash)\n@@ -352,26 +357,21 @@ get_coverage_counts (unsigned counter, unsigned expected,\n       return NULL;\n     }\n \n-  checksum = compute_checksum ();\n-  if (entry->checksum != checksum\n+  if (entry->cfg_checksum != cfg_checksum\n       || entry->summary.num != expected)\n     {\n       static int warned = 0;\n       bool warning_printed = false;\n       tree id = DECL_ASSEMBLER_NAME (current_function_decl);\n \n-      warning_printed = \n-\twarning_at (input_location, OPT_Wcoverage_mismatch, \n-\t\t    \"coverage mismatch for function \"\n-\t\t    \"%qE while reading counter %qs\", id, ctr_names[counter]);\n+      warning_printed =\n+\twarning_at (input_location, OPT_Wcoverage_mismatch,\n+\t\t    \"The control flow of function %qE does not match \"\n+\t\t    \"its profile data (counter %qs)\", id, ctr_names[counter]);\n       if (warning_printed)\n \t{\n-\t  if (entry->checksum != checksum)\n-\t    inform (input_location, \"checksum is %x instead of %x\",\n-\t\t    entry->checksum, checksum);\n-\t  else\n-\t    inform (input_location, \"number of counters is %d instead of %d\",\n-\t\t    entry->summary.num, expected);\n+\t inform (input_location, \"Use -Wno-error=coverage-mismatch to tolerate \"\n+\t \t \"the mismatch but performance may drop if the function is hot\");\n \t  \n \t  if (!seen_error ()\n \t      && !warned++)\n@@ -388,6 +388,12 @@ get_coverage_counts (unsigned counter, unsigned expected,\n \n       return NULL;\n     }\n+    else if (entry->lineno_checksum != lineno_checksum)\n+      {\n+        warning (0, \"Source location for function %qE have changed,\"\n+                 \" the profile data may be out of date\",\n+                 DECL_ASSEMBLER_NAME (current_function_decl));\n+      }\n \n   if (summary)\n     *summary = &entry->summary;\n@@ -467,6 +473,7 @@ tree_coverage_counter_addr (unsigned counter, unsigned no)\n \t\t\t\t       NULL, NULL));\n }\n \f\n+\n /* Generate a checksum for a string.  CHKSUM is the current\n    checksum.  */\n \n@@ -529,8 +536,8 @@ coverage_checksum_string (unsigned chksum, const char *string)\n \n /* Compute checksum for the current function.  We generate a CRC32.  */\n \n-static unsigned\n-compute_checksum (void)\n+unsigned\n+coverage_compute_lineno_checksum (void)\n {\n   expanded_location xloc\n     = expand_location (DECL_SOURCE_LOCATION (current_function_decl));\n@@ -542,14 +549,44 @@ compute_checksum (void)\n \n   return chksum;\n }\n+\n+/* Compute cfg checksum for the current function.\n+   The checksum is calculated carefully so that\n+   source code changes that doesn't affect the control flow graph\n+   won't change the checksum.\n+   This is to make the profile data useable across source code change.\n+   The downside of this is that the compiler may use potentially\n+   wrong profile data - that the source code change has non-trivial impact\n+   on the validity of profile data (e.g. the reversed condition)\n+   but the compiler won't detect the change and use the wrong profile data.  */\n+\n+unsigned\n+coverage_compute_cfg_checksum (void)\n+{\n+  basic_block bb;\n+  unsigned chksum = n_basic_blocks;\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      edge e;\n+      edge_iterator ei;\n+      chksum = crc32_byte (chksum, bb->index);\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+        {\n+          chksum = crc32_byte (chksum, e->dest->index);\n+        }\n+    }\n+\n+  return chksum;\n+}\n \f\n /* Begin output to the graph file for the current function.\n    Opens the output file, if not already done. Writes the\n    function header, if not already done. Returns nonzero if data\n    should be output.  */\n \n int\n-coverage_begin_output (void)\n+coverage_begin_output (unsigned lineno_checksum, unsigned cfg_checksum)\n {\n   /* We don't need to output .gcno file unless we're under -ftest-coverage\n      (e.g. -fprofile-arcs/generate/use don't need .gcno to work). */\n@@ -575,12 +612,14 @@ coverage_begin_output (void)\n \t  bbg_file_opened = 1;\n \t}\n \n+\n       /* Announce function */\n       offset = gcov_write_tag (GCOV_TAG_FUNCTION);\n       gcov_write_unsigned (current_function_funcdef_no + 1);\n-      gcov_write_unsigned (compute_checksum ());\n+      gcov_write_unsigned (lineno_checksum);\n+      gcov_write_unsigned (cfg_checksum);\n       gcov_write_string (IDENTIFIER_POINTER\n-\t\t\t (DECL_ASSEMBLER_NAME (current_function_decl)));\n+                         (DECL_ASSEMBLER_NAME (current_function_decl)));\n       gcov_write_string (xloc.file);\n       gcov_write_unsigned (xloc.line);\n       gcov_write_length (offset);\n@@ -594,7 +633,7 @@ coverage_begin_output (void)\n    error has occurred.  Save function coverage counts.  */\n \n void\n-coverage_end_function (void)\n+coverage_end_function (unsigned lineno_checksum, unsigned cfg_checksum)\n {\n   unsigned i;\n \n@@ -613,9 +652,11 @@ coverage_end_function (void)\n       *functions_tail = item;\n       functions_tail = &item->next;\n \n+\n       item->next = 0;\n       item->ident = current_function_funcdef_no + 1;\n-      item->checksum = compute_checksum ();\n+      item->lineno_checksum = lineno_checksum;\n+      item->cfg_checksum = cfg_checksum;\n       for (i = 0; i != GCOV_COUNTERS; i++)\n \t{\n \t  item->n_ctrs[i] = fn_n_ctrs[i];\n@@ -640,13 +681,18 @@ build_fn_info_type (unsigned int counters)\n   /* ident */\n   fields = build_decl (BUILTINS_LOCATION,\n \t\t       FIELD_DECL, NULL_TREE, get_gcov_unsigned_t ());\n-\n-  /* checksum */\n+  /* lineno_checksum */\n   field = build_decl (BUILTINS_LOCATION,\n \t\t      FIELD_DECL, NULL_TREE, get_gcov_unsigned_t ());\n   DECL_CHAIN (field) = fields;\n   fields = field;\n \n+  /* cfg checksum */\n+  field = build_decl (BUILTINS_LOCATION,\n+                      FIELD_DECL, NULL_TREE, get_gcov_unsigned_t ());\n+  DECL_CHAIN (field) = fields;\n+  fields = field;\n+\n   array_type = build_int_cst (NULL_TREE, counters - 1);\n   array_type = build_index_type (array_type);\n   array_type = build_array_type (get_gcov_unsigned_t (), array_type);\n@@ -680,10 +726,16 @@ build_fn_info_value (const struct function_list *function, tree type)\n \t\t\t\t\t  function->ident));\n   fields = DECL_CHAIN (fields);\n \n-  /* checksum */\n+  /* lineno_checksum */\n+  CONSTRUCTOR_APPEND_ELT (v1, fields,\n+\t\t\t  build_int_cstu (get_gcov_unsigned_t (),\n+\t\t\t\t\t  function->lineno_checksum));\n+  fields = DECL_CHAIN (fields);\n+\n+  /* cfg_checksum */\n   CONSTRUCTOR_APPEND_ELT (v1, fields,\n \t\t\t  build_int_cstu (get_gcov_unsigned_t (),\n-\t\t\t\t\t  function->checksum));\n+\t\t\t\t\t  function->cfg_checksum));\n   fields = DECL_CHAIN (fields);\n \n   /* counters */"}, {"sha": "6935c2d338b4782e6b8a7f711022302abac98c80", "filename": "gcc/coverage.h", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10adac5108a971b2e4949508728251e587450595/gcc%2Fcoverage.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10adac5108a971b2e4949508728251e587450595/gcc%2Fcoverage.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.h?ref=10adac5108a971b2e4949508728251e587450595", "patch": "@@ -28,11 +28,17 @@ extern void coverage_finish (void);\n \n /* Complete the coverage information for the current function. Once\n    per function.  */\n-extern void coverage_end_function (void);\n+extern void coverage_end_function (unsigned, unsigned);\n \n /* Start outputting coverage information for the current\n    function. Repeatable per function.  */\n-extern int coverage_begin_output (void);\n+extern int coverage_begin_output (unsigned, unsigned);\n+\n+/* Compute the control flow checksum for the current function.  */\n+extern unsigned coverage_compute_cfg_checksum (void);\n+\n+/* Compute the line number checksum for the current function.  */\n+extern unsigned coverage_compute_lineno_checksum (void);\n \n /* Allocate some counters. Repeatable per function.  */\n extern int coverage_counter_alloc (unsigned /*counter*/, unsigned/*num*/);\n@@ -44,6 +50,8 @@ extern tree tree_coverage_counter_addr (unsigned /*counter*/, unsigned/*num*/);\n /* Get all the counters for the current function.  */\n extern gcov_type *get_coverage_counts (unsigned /*counter*/,\n \t\t\t\t       unsigned /*expected*/,\n+\t\t\t\t       unsigned /*cfg_checksum*/,\n+\t\t\t\t       unsigned /*lineno_checksum*/,\n \t\t\t\t       const struct gcov_ctr_summary **);\n \n extern tree get_gcov_type (void);"}, {"sha": "e9c384382d1190ffd194df6e8f17caae3c4d3572", "filename": "gcc/gcov-dump.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10adac5108a971b2e4949508728251e587450595/gcc%2Fgcov-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10adac5108a971b2e4949508728251e587450595/gcc%2Fgcov-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-dump.c?ref=10adac5108a971b2e4949508728251e587450595", "patch": "@@ -267,7 +267,8 @@ tag_function (const char *filename ATTRIBUTE_UNUSED,\n   unsigned long pos = gcov_position ();\n \n   printf (\" ident=%u\", gcov_read_unsigned ());\n-  printf (\", checksum=0x%08x\", gcov_read_unsigned ());\n+  printf (\", lineno_checksum=0x%08x\", gcov_read_unsigned ());\n+  printf (\", cfg_checksum_checksum=0x%08x\", gcov_read_unsigned ());\n \n   if (gcov_position () - pos < length)\n     {"}, {"sha": "4f5013e11566fe73403d1e102fe90341b2584875", "filename": "gcc/gcov-io.h", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10adac5108a971b2e4949508728251e587450595/gcc%2Fgcov-io.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10adac5108a971b2e4949508728251e587450595/gcc%2Fgcov-io.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.h?ref=10adac5108a971b2e4949508728251e587450595", "patch": "@@ -103,7 +103,8 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n    \tnote: unit function-graph*\n \tunit: header int32:checksum string:source\n \tfunction-graph: announce_function basic_blocks {arcs | lines}*\n-\tannounce_function: header int32:ident int32:checksum\n+\tannounce_function: header int32:ident\n+\t\tint32:lineno_checksum int32:cfg_checksum\n \t\tstring:name string:source int32:lineno\n \tbasic_block: header int32:flags*\n \tarcs: header int32:block_no arc*\n@@ -132,7 +133,8 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n         data: {unit function-data* summary:object summary:program*}*\n \tunit: header int32:checksum\n         function-data:\tannounce_function arc_counts\n-\tannounce_function: header int32:ident int32:checksum\n+\tannounce_function: header int32:ident\n+\t\tint32:lineno_checksum int32:cfg_checksum\n \tarc_counts: header int64:count*\n \tsummary: int32:checksum {count-summary}GCOV_COUNTERS\n \tcount-summary:\tint32:num int32:runs int64:sum\n@@ -294,7 +296,7 @@ typedef HOST_WIDEST_INT gcov_type;\n    file marker -- it is not required to be present.  */\n \n #define GCOV_TAG_FUNCTION\t ((gcov_unsigned_t)0x01000000)\n-#define GCOV_TAG_FUNCTION_LENGTH (2)\n+#define GCOV_TAG_FUNCTION_LENGTH (3)\n #define GCOV_TAG_BLOCKS\t\t ((gcov_unsigned_t)0x01410000)\n #define GCOV_TAG_BLOCKS_LENGTH(NUM) (NUM)\n #define GCOV_TAG_BLOCKS_NUM(LENGTH) (LENGTH)\n@@ -412,10 +414,12 @@ struct gcov_summary\n    idiom. The number of counters is determined from the counter_mask\n    in gcov_info.  We hold an array of function info, so have to\n    explicitly calculate the correct array stride.  */\n+\n struct gcov_fn_info\n {\n   gcov_unsigned_t ident;\t/* unique ident of function */\n-  gcov_unsigned_t checksum;\t/* function checksum */\n+  gcov_unsigned_t lineno_checksum;\t/* function lineo_checksum */\n+  gcov_unsigned_t cfg_checksum;\t/* function cfg checksum */\n   unsigned n_ctrs[0];\t\t/* instrumented counters */\n };\n "}, {"sha": "27ae036740a67ed7f27993aa9611a32dbefc7303", "filename": "gcc/gcov.c", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10adac5108a971b2e4949508728251e587450595/gcc%2Fgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10adac5108a971b2e4949508728251e587450595/gcc%2Fgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov.c?ref=10adac5108a971b2e4949508728251e587450595", "patch": "@@ -54,6 +54,13 @@ along with Gcov; see the file COPYING3.  If not see\n    some places we make use of the knowledge of how profile.c works to\n    select particular algorithms here.  */\n \n+/* The code validates that the profile information read in corresponds\n+   to the code currently being compiled.  Rather than checking for\n+   identical files, the code below computes a checksum on the CFG\n+   (based on the order of basic blocks and the arcs in the CFG).  If\n+   the CFG checksum in the gcda file match the CFG checksum for the\n+   code currently being compiled, the profile data will be used.  */\n+\n /* This is the size of the buffer used to read in source file lines.  */\n \n #define STRING_SIZE 200\n@@ -161,7 +168,8 @@ typedef struct function_info\n   /* Name of function.  */\n   char *name;\n   unsigned ident;\n-  unsigned checksum;\n+  unsigned lineno_checksum;\n+  unsigned cfg_checksum;\n \n   /* Array of basic blocks.  */\n   block_t *blocks;\n@@ -807,20 +815,23 @@ read_graph_file (void)\n       if (tag == GCOV_TAG_FUNCTION)\n \t{\n \t  char *function_name;\n-\t  unsigned ident, checksum, lineno;\n+\t  unsigned ident, lineno;\n+\t  unsigned lineno_checksum, cfg_checksum;\n \t  source_t *src;\n \t  function_t *probe, *prev;\n \n \t  ident = gcov_read_unsigned ();\n-\t  checksum = gcov_read_unsigned ();\n+\t  lineno_checksum = gcov_read_unsigned ();\n+\t  cfg_checksum = gcov_read_unsigned ();\n \t  function_name = xstrdup (gcov_read_string ());\n \t  src = find_source (gcov_read_string ());\n \t  lineno = gcov_read_unsigned ();\n \n \t  fn = XCNEW (function_t);\n \t  fn->name = function_name;\n \t  fn->ident = ident;\n-\t  fn->checksum = checksum;\n+\t  fn->lineno_checksum = lineno_checksum;\n+\t  fn->cfg_checksum = cfg_checksum;\n \t  fn->src = src;\n \t  fn->line = lineno;\n \n@@ -1107,7 +1118,8 @@ read_count_file (void)\n \n \t  if (!fn)\n \t    ;\n-\t  else if (gcov_read_unsigned () != fn->checksum)\n+\t  else if (gcov_read_unsigned () != fn->lineno_checksum\n+\t\t   || gcov_read_unsigned () != fn->cfg_checksum)\n \t    {\n \t    mismatch:;\n \t      fnotice (stderr, \"%s:profile mismatch for '%s'\\n\","}, {"sha": "7d1f6d052900f96d251865f180f52738d8292e1a", "filename": "gcc/libgcov.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10adac5108a971b2e4949508728251e587450595/gcc%2Flibgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10adac5108a971b2e4949508728251e587450595/gcc%2Flibgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcov.c?ref=10adac5108a971b2e4949508728251e587450595", "patch": "@@ -372,9 +372,10 @@ gcov_exit (void)\n \n \t      /* Check function.  */\n \t      if (tag != GCOV_TAG_FUNCTION\n-\t\t  || length != GCOV_TAG_FUNCTION_LENGTH\n+\t          || length != GCOV_TAG_FUNCTION_LENGTH\n \t\t  || gcov_read_unsigned () != fi_ptr->ident\n-\t\t  || gcov_read_unsigned () != fi_ptr->checksum)\n+\t\t  || gcov_read_unsigned () != fi_ptr->lineno_checksum\n+\t\t  || gcov_read_unsigned () != fi_ptr->cfg_checksum)\n \t\t{\n \t\tread_mismatch:;\n \t\t  fprintf (stderr, \"profiling:%s:Merge mismatch for %s\\n\",\n@@ -517,7 +518,8 @@ gcov_exit (void)\n \t  /* Announce function.  */\n \t  gcov_write_tag_length (GCOV_TAG_FUNCTION, GCOV_TAG_FUNCTION_LENGTH);\n \t  gcov_write_unsigned (fi_ptr->ident);\n-\t  gcov_write_unsigned (fi_ptr->checksum);\n+\t  gcov_write_unsigned (fi_ptr->lineno_checksum);\n+\t  gcov_write_unsigned (fi_ptr->cfg_checksum);\n \n \t  c_ix = 0;\n \t  for (t_ix = 0; t_ix < GCOV_COUNTERS; t_ix++)"}, {"sha": "e85702ed8dc64cb3bf567ebaf2ddf9fa9a5f923c", "filename": "gcc/profile.c", "status": "modified", "additions": 33, "deletions": 23, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10adac5108a971b2e4949508728251e587450595/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10adac5108a971b2e4949508728251e587450595/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=10adac5108a971b2e4949508728251e587450595", "patch": "@@ -102,13 +102,6 @@ static int total_num_branches;\n \n /* Forward declarations.  */\n static void find_spanning_tree (struct edge_list *);\n-static unsigned instrument_edges (struct edge_list *);\n-static void instrument_values (histogram_values);\n-static void compute_branch_probabilities (void);\n-static void compute_value_histograms (histogram_values);\n-static gcov_type * get_exec_counts (void);\n-static basic_block find_group (basic_block);\n-static void union_groups (basic_block, basic_block);\n \n /* Add edge instrumentation code to the entire insn chain.\n \n@@ -233,10 +226,12 @@ instrument_values (histogram_values values)\n }\n \f\n \n-/* Computes hybrid profile for all matching entries in da_file.  */\n+/* Computes hybrid profile for all matching entries in da_file.  \n+   \n+   CFG_CHECKSUM is the precomputed checksum for the CFG.  */\n \n static gcov_type *\n-get_exec_counts (void)\n+get_exec_counts (unsigned cfg_checksum, unsigned lineno_checksum)\n {\n   unsigned num_edges = 0;\n   basic_block bb;\n@@ -253,7 +248,8 @@ get_exec_counts (void)\n \t  num_edges++;\n     }\n \n-  counts = get_coverage_counts (GCOV_COUNTER_ARCS, num_edges, &profile_info);\n+  counts = get_coverage_counts (GCOV_COUNTER_ARCS, num_edges, cfg_checksum,\n+\t\t\t\tlineno_checksum, &profile_info);\n   if (!counts)\n     return NULL;\n \n@@ -442,10 +438,12 @@ read_profile_edge_counts (gcov_type *exec_counts)\n }\n \n /* Compute the branch probabilities for the various branches.\n-   Annotate them accordingly.  */\n+   Annotate them accordingly.  \n+\n+   CFG_CHECKSUM is the precomputed checksum for the CFG.  */\n \n static void\n-compute_branch_probabilities (void)\n+compute_branch_probabilities (unsigned cfg_checksum, unsigned lineno_checksum)\n {\n   basic_block bb;\n   int i;\n@@ -454,7 +452,7 @@ compute_branch_probabilities (void)\n   int passes;\n   int hist_br_prob[20];\n   int num_branches;\n-  gcov_type *exec_counts = get_exec_counts ();\n+  gcov_type *exec_counts = get_exec_counts (cfg_checksum, lineno_checksum);\n   int inconsistent = 0;\n \n   /* Very simple sanity checks so we catch bugs in our profiling code.  */\n@@ -772,10 +770,13 @@ compute_branch_probabilities (void)\n }\n \n /* Load value histograms values whose description is stored in VALUES array\n-   from .gcda file.  */\n+   from .gcda file.  \n+\n+   CFG_CHECKSUM is the precomputed checksum for the CFG.  */\n \n static void\n-compute_value_histograms (histogram_values values)\n+compute_value_histograms (histogram_values values, unsigned cfg_checksum,\n+                          unsigned lineno_checksum)\n {\n   unsigned i, j, t, any;\n   unsigned n_histogram_counters[GCOV_N_VALUE_COUNTERS];\n@@ -803,7 +804,8 @@ compute_value_histograms (histogram_values values)\n \n       histogram_counts[t] =\n \tget_coverage_counts (COUNTER_FOR_HIST_TYPE (t),\n-\t\t\t     n_histogram_counters[t], NULL);\n+\t\t\t     n_histogram_counters[t], cfg_checksum,\n+\t\t\t     lineno_checksum, NULL);\n       if (histogram_counts[t])\n \tany = 1;\n       act_count[t] = histogram_counts[t];\n@@ -905,6 +907,7 @@ branch_prob (void)\n   unsigned num_instrumented;\n   struct edge_list *el;\n   histogram_values values = NULL;\n+  unsigned cfg_checksum, lineno_checksum;\n \n   total_num_times_called++;\n \n@@ -1058,11 +1061,19 @@ branch_prob (void)\n   if (dump_file)\n     fprintf (dump_file, \"%d ignored edges\\n\", ignored_edges);\n \n+\n+  /* Compute two different checksums. Note that we want to compute\n+     the checksum in only once place, since it depends on the shape\n+     of the control flow which can change during \n+     various transformations.  */\n+  cfg_checksum = coverage_compute_cfg_checksum ();\n+  lineno_checksum = coverage_compute_lineno_checksum ();\n+\n   /* Write the data from which gcov can reconstruct the basic block\n      graph.  */\n \n   /* Basic block flags */\n-  if (coverage_begin_output ())\n+  if (coverage_begin_output (lineno_checksum, cfg_checksum))\n     {\n       gcov_position_t offset;\n \n@@ -1079,7 +1090,7 @@ branch_prob (void)\n   EXIT_BLOCK_PTR->index = last_basic_block;\n \n   /* Arcs */\n-  if (coverage_begin_output ())\n+  if (coverage_begin_output (lineno_checksum, cfg_checksum))\n     {\n       gcov_position_t offset;\n \n@@ -1120,7 +1131,7 @@ branch_prob (void)\n     }\n \n   /* Line numbers.  */\n-  if (coverage_begin_output ())\n+  if (coverage_begin_output (lineno_checksum, cfg_checksum))\n     {\n       /* Initialize the output.  */\n       output_location (NULL, 0, NULL, NULL);\n@@ -1175,9 +1186,9 @@ branch_prob (void)\n \n   if (flag_branch_probabilities)\n     {\n-      compute_branch_probabilities ();\n+      compute_branch_probabilities (cfg_checksum, lineno_checksum);\n       if (flag_profile_values)\n-\tcompute_value_histograms (values);\n+\tcompute_value_histograms (values, cfg_checksum, lineno_checksum);\n     }\n \n   remove_fake_edges ();\n@@ -1205,7 +1216,7 @@ branch_prob (void)\n \n   VEC_free (histogram_value, heap, values);\n   free_edge_list (el);\n-  coverage_end_function ();\n+  coverage_end_function (lineno_checksum, cfg_checksum);\n }\n \f\n /* Union find algorithm implementation for the basic blocks using\n@@ -1372,4 +1383,3 @@ end_branch_prob (void)\n \t}\n     }\n }\n-"}, {"sha": "16666cefd7c87ed95a6d84e0a3e167d64d024686", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10adac5108a971b2e4949508728251e587450595/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10adac5108a971b2e4949508728251e587450595/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=10adac5108a971b2e4949508728251e587450595", "patch": "@@ -1,3 +1,8 @@\n+2011-04-28  Xinliang David Li  <davidxl@google.com>\n+\n+\t* testsuite/gcc.dg/tree-prof/prof-robust-1.c: New test.\n+\t* testsuite/g++.dg/prof-robust-1.C: New test.\n+\n 2011-04-28  Ira Rosen  <ira.rosen@linaro.org>\n \n \tPR tree-optimization/48765"}, {"sha": "a5d8cb3c47088eef67a5d8845575f90587d16960", "filename": "gcc/testsuite/g++.dg/prof-robust-1.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10adac5108a971b2e4949508728251e587450595/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fprof-robust-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10adac5108a971b2e4949508728251e587450595/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fprof-robust-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fprof-robust-1.C?ref=10adac5108a971b2e4949508728251e587450595", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-options \"-O2 -fno-weak\" } */\n+\n+#include <stdio.h>\n+\n+namespace {\n+  namespace {\n+    \n+    class MyClass {\n+    public:\n+      void foo() const;\n+      ~MyClass() { foo(); }\n+    };\n+    \n+    void MyClass::foo() const { printf(\"Goodbye World\\n\"); }\n+    \n+  }\n+  \n+  static MyClass variable;\n+  \n+}\n+\n+int main() {\n+  return 0;\n+}"}, {"sha": "316cfc75734adb9e94f000538f3355f5ffb91d31", "filename": "gcc/testsuite/gcc.dg/tree-prof/prof-robust-1.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10adac5108a971b2e4949508728251e587450595/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fprof-robust-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10adac5108a971b2e4949508728251e587450595/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fprof-robust-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fprof-robust-1.c?ref=10adac5108a971b2e4949508728251e587450595", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-options \"-O2 -w\" } */\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+#ifdef _PROFILE_USE\n+int foo(int x) {\n+  return 3 * x;\n+}\n+#else\n+int foo(int x) {\n+  return 3 * x;\n+}\n+#endif\n+\n+int x = 1000;\n+\n+int main(int argc, char *argv[]) {\n+  int i;\n+  int sum = 0;\n+  for (i = 0; i < x; i++)\n+    sum += i;\n+  printf(\"%d\\n\", sum);\n+  return 0;\n+}"}, {"sha": "ba90df8d3188a1e0995efe8d15674d282ee5d89b", "filename": "gcc/tree.c", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10adac5108a971b2e4949508728251e587450595/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10adac5108a971b2e4949508728251e587450595/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=10adac5108a971b2e4949508728251e587450595", "patch": "@@ -8510,14 +8510,12 @@ dump_tree_statistics (void)\n \f\n #define FILE_FUNCTION_FORMAT \"_GLOBAL__%s_%s\"\n \n-/* Generate a crc32 of a string.  */\n+/* Generate a crc32 of a byte.  */\n \n unsigned\n-crc32_string (unsigned chksum, const char *string)\n+crc32_byte (unsigned chksum, char byte)\n {\n-  do\n-    {\n-      unsigned value = *string << 24;\n+  unsigned value = (unsigned) byte << 24;\n       unsigned ix;\n \n       for (ix = 8; ix--; value <<= 1)\n@@ -8528,6 +8526,18 @@ crc32_string (unsigned chksum, const char *string)\n  \t  chksum <<= 1;\n  \t  chksum ^= feedback;\n   \t}\n+  return chksum;\n+}\n+\n+\n+/* Generate a crc32 of a string.  */\n+\n+unsigned\n+crc32_string (unsigned chksum, const char *string)\n+{\n+  do\n+    {\n+      chksum = crc32_byte (chksum, *string);\n     }\n   while (*string++);\n   return chksum;\n@@ -8551,8 +8561,10 @@ clean_symbol_name (char *p)\n       *p = '_';\n }\n \n-/* Generate a name for a special-purpose function function.\n+/* Generate a name for a special-purpose function.\n    The generated name may need to be unique across the whole link.\n+   Changes to this function may also require corresponding changes to\n+   xstrdup_mask_random.\n    TYPE is some string to identify the purpose of this function to the\n    linker or collect2; it must start with an uppercase letter,\n    one of:"}, {"sha": "c20206fea8efb5d5ecbb4a386fe62150ee75f568", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10adac5108a971b2e4949508728251e587450595/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10adac5108a971b2e4949508728251e587450595/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=10adac5108a971b2e4949508728251e587450595", "patch": "@@ -5001,6 +5001,7 @@ inlined_function_outer_scope_p (const_tree block)\n \f\n /* In tree.c */\n extern unsigned crc32_string (unsigned, const char *);\n+extern unsigned crc32_byte (unsigned, char);\n extern void clean_symbol_name (char *);\n extern tree get_file_function_name (const char *);\n extern tree get_callee_fndecl (const_tree);"}]}