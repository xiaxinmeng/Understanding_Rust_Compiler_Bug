{"sha": "9e4da9b5d5d3d8e14ab1748fafb08c6b9bfcf629", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWU0ZGE5YjVkNWQzZDhlMTRhYjE3NDhmYWZiMDhjNmI5YmZjZjYyOQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-05-02T07:40:22Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-05-02T07:40:22Z"}, "message": "Tighten early exit in vect_analyze_data_ref_dependence (PR85586)\n\nThe problem in this PR was that we didn't consider aliases between\nwrites in the same strided group.  After tightening the early exit\nwe get the expected abs(step) >= 2 versioning check.\n\n2018-05-02  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\tPR tree-optimization/85586\n\t* tree-vect-data-refs.c (vect_analyze_data_ref_dependence): Only\n\texit early for statements in the same group if the accesses are\n\tnot strided.\n\ngcc/testsuite/\n\tPR tree-optimization/85586\n\t* gcc.dg/vect/pr85586.c: New test.\n\nFrom-SVN: r259822", "tree": {"sha": "cc2d2a65d221c55d054add0a6d8e0909b1c800d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cc2d2a65d221c55d054add0a6d8e0909b1c800d6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e4da9b5d5d3d8e14ab1748fafb08c6b9bfcf629", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e4da9b5d5d3d8e14ab1748fafb08c6b9bfcf629", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e4da9b5d5d3d8e14ab1748fafb08c6b9bfcf629", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e4da9b5d5d3d8e14ab1748fafb08c6b9bfcf629/comments", "author": null, "committer": null, "parents": [{"sha": "c2e1580cbe2023f9a7ff832d52587825c85c2f6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2e1580cbe2023f9a7ff832d52587825c85c2f6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2e1580cbe2023f9a7ff832d52587825c85c2f6d"}], "stats": {"total": 61, "additions": 59, "deletions": 2}, "files": [{"sha": "53fa68d9cbb171da28f5d53e2b31bad83db2b176", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e4da9b5d5d3d8e14ab1748fafb08c6b9bfcf629/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e4da9b5d5d3d8e14ab1748fafb08c6b9bfcf629/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9e4da9b5d5d3d8e14ab1748fafb08c6b9bfcf629", "patch": "@@ -1,3 +1,10 @@\n+2018-05-02  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\tPR tree-optimization/85586\n+\t* tree-vect-data-refs.c (vect_analyze_data_ref_dependence): Only\n+\texit early for statements in the same group if the accesses are\n+\tnot strided.\n+\n 2018-05-02  Tom de Vries  <tom@codesourcery.com>\n \n \tPR lto/85451"}, {"sha": "9c93c81a3efa0e0f0fcb784fe0811cc9add903c6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e4da9b5d5d3d8e14ab1748fafb08c6b9bfcf629/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e4da9b5d5d3d8e14ab1748fafb08c6b9bfcf629/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9e4da9b5d5d3d8e14ab1748fafb08c6b9bfcf629", "patch": "@@ -1,3 +1,8 @@\n+2018-05-02  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\tPR tree-optimization/85586\n+\t* gcc.dg/vect/pr85586.c: New test.\n+\n 2018-05-01  Marc Glisse  <marc.glisse@inria.fr>\n \n \tPR tree-optimization/85143"}, {"sha": "d6cc92d5a0921d706cb2db04e5ad501cb64e8dc7", "filename": "gcc/testsuite/gcc.dg/vect/pr85586.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e4da9b5d5d3d8e14ab1748fafb08c6b9bfcf629/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr85586.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e4da9b5d5d3d8e14ab1748fafb08c6b9bfcf629/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr85586.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr85586.c?ref=9e4da9b5d5d3d8e14ab1748fafb08c6b9bfcf629", "patch": "@@ -0,0 +1,43 @@\n+#define N 100\n+\n+void __attribute__ ((noipa))\n+foo (int *out, int *in, int step)\n+{\n+  for (int i = 0; i < N; ++i)\n+    {\n+      out[0] = in[i];\n+      out[1] = 2;\n+      out += step;\n+    }\n+}\n+\n+int in[N];\n+int out[N * 2];\n+\n+int\n+main (void)\n+{\n+  for (int i = 0; i < N; ++i)\n+    {\n+      in[i] = i * (i + 1);\n+      asm volatile (\"\" ::: \"memory\");\n+    }\n+\n+  foo (out, in, 1);\n+  for (int i = 0; i < N; ++i)\n+    if (out[i] != in[i])\n+      __builtin_abort ();\n+  if (out[N] != 2)\n+    __builtin_abort ();\n+\n+  foo (out + N - 1, in, -1);\n+  if (out[0] != in[N - 1])\n+    __builtin_abort ();\n+  for (int i = 1; i <= N; ++i)\n+    if (out[i] != 2)\n+      __builtin_abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"LOOP VECTORIZED\" 1 \"vect\" { target vect_int } } } */"}, {"sha": "9608b769cf2a6650ce24a36020e0d0feae3cf2fd", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e4da9b5d5d3d8e14ab1748fafb08c6b9bfcf629/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e4da9b5d5d3d8e14ab1748fafb08c6b9bfcf629/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=9e4da9b5d5d3d8e14ab1748fafb08c6b9bfcf629", "patch": "@@ -305,9 +305,11 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n     return false;\n \n   /* We do not have to consider dependences between accesses that belong\n-     to the same group.  */\n+     to the same group, unless the stride could be smaller than the\n+     group size.  */\n   if (GROUP_FIRST_ELEMENT (stmtinfo_a)\n-      && GROUP_FIRST_ELEMENT (stmtinfo_a) == GROUP_FIRST_ELEMENT (stmtinfo_b))\n+      && GROUP_FIRST_ELEMENT (stmtinfo_a) == GROUP_FIRST_ELEMENT (stmtinfo_b)\n+      && !STMT_VINFO_STRIDED_P (stmtinfo_a))\n     return false;\n \n   /* Even if we have an anti-dependence then, as the vectorized loop covers at"}]}