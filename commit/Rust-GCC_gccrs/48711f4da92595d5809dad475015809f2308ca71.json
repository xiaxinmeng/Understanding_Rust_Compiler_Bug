{"sha": "48711f4da92595d5809dad475015809f2308ca71", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDg3MTFmNGRhOTI1OTVkNTgwOWRhZDQ3NTAxNTgwOWYyMzA4Y2E3MQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2002-06-02T16:33:01Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2002-06-02T16:33:01Z"}, "message": "Fix for PR java/1343, PR java/6336:\n\n\t* parse.y (make_nested_class_name): Remove extraneous `else'; fix\n\tformatting.  Changed return type.\n\t(anonymous_class_counter): Moved to top of file.\n\t(maybe_make_nested_class_name): Append number to class name for\n\tfunction-local classes.\n\nFrom-SVN: r54173", "tree": {"sha": "8c0c8a5d9b246c0fa0f8e47df39cf81f89cd6df3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8c0c8a5d9b246c0fa0f8e47df39cf81f89cd6df3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/48711f4da92595d5809dad475015809f2308ca71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48711f4da92595d5809dad475015809f2308ca71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48711f4da92595d5809dad475015809f2308ca71", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48711f4da92595d5809dad475015809f2308ca71/comments", "author": null, "committer": null, "parents": [{"sha": "e403d80d357106f3a0b12a290e812e9a6305c1ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e403d80d357106f3a0b12a290e812e9a6305c1ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e403d80d357106f3a0b12a290e812e9a6305c1ee"}], "stats": {"total": 237, "additions": 166, "deletions": 71}, "files": [{"sha": "1ddef436b33925c1dcc2c1fc83eb6ce9ce229f2e", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48711f4da92595d5809dad475015809f2308ca71/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48711f4da92595d5809dad475015809f2308ca71/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=48711f4da92595d5809dad475015809f2308ca71", "patch": "@@ -1,3 +1,12 @@\n+2002-06-02  Tom Tromey  <tromey@redhat.com>\n+\n+\tFix for PR java/1343, PR java/6336:\n+\t* parse.y (make_nested_class_name): Remove extraneous `else'; fix\n+\tformatting.  Changed return type.\n+\t(anonymous_class_counter): Moved to top of file.\n+\t(maybe_make_nested_class_name): Append number to class name for\n+\tfunction-local classes.\n+\n 2002-05-28  Zack Weinberg  <zack@codesourcery.com>\n \n \t* decl.c, jcf-parse.c, parse.y, typeck.c: Include real.h."}, {"sha": "665a7f7e15f52ee059313e3233bd0b68ad55ed57", "filename": "gcc/java/parse-scan.y", "status": "modified", "additions": 128, "deletions": 59, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48711f4da92595d5809dad475015809f2308ca71/gcc%2Fjava%2Fparse-scan.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48711f4da92595d5809dad475015809f2308ca71/gcc%2Fjava%2Fparse-scan.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse-scan.y?ref=48711f4da92595d5809dad475015809f2308ca71", "patch": "@@ -1,5 +1,5 @@\n /* Parser grammar for quick source code scan of Java(TM) language programs.\n-   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000, 2002 Free Software Foundation, Inc.\n    Contributed by Alexandre Petit-Bianco (apbianco@cygnus.com)\n \n This file is part of GNU CC.\n@@ -43,6 +43,9 @@ definitions and other extensions.  */\n #include \"obstack.h\"\n #include \"toplev.h\"\n \n+#define obstack_chunk_alloc xmalloc\n+#define obstack_chunk_free free\n+\n extern char *input_filename;\n extern FILE *finput, *out;\n \n@@ -62,13 +65,9 @@ int lineno;\n static int absorber;\n #define USE_ABSORBER absorber = 0\n \n-/* Keep track of the current class name and package name.  */\n-static char *current_class;\n+/* Keep track of the current package name.  */\n static const char *package_name;\n \n-/* Keep track of the current inner class qualifier. */\n-static int current_class_length;\n-\n /* Keep track of whether things have be listed before.  */\n static int previous_output;\n \n@@ -85,6 +84,22 @@ static int bracket_count;\n /* Numbers anonymous classes */\n static int anonymous_count;\n \n+/* This is used to record the current class context.  */\n+struct class_context\n+{\n+  char *name;\n+  struct class_context *next;\n+};\n+\n+/* The global class context.  */\n+static struct class_context *current_class_context;\n+\n+/* A special constant used to represent an anonymous context.  */\n+static const char *anonymous_context = \"ANONYMOUS\";\n+\n+/* Count of method depth.  */\n+static int method_depth; \n+\n /* Record a method declaration  */\n struct method_declarator {\n   const char *method_name;\n@@ -99,6 +114,9 @@ struct method_declarator {\n }\n \n /* Two actions for this grammar */\n+static int make_class_name_recursive PARAMS ((struct obstack *stack,\n+\t\t\t\t\t      struct class_context *ctx));\n+static char *get_class_name PARAMS ((void));\n static void report_class_declaration PARAMS ((const char *));\n static void report_main_declaration PARAMS ((struct method_declarator *));\n static void push_class_context PARAMS ((const char *));\n@@ -430,7 +448,10 @@ variable_initializer:\n \n /* 19.8.3 Productions from 8.4: Method Declarations  */\n method_declaration:\n-\tmethod_header method_body\n+\tmethod_header\n+\t\t{ ++method_depth; }\n+\tmethod_body\n+\t\t{ --method_depth; }\n ;\n \n method_header:\t\n@@ -923,10 +944,10 @@ class_instance_creation_expression:\n \n anonymous_class_creation:\n \tNEW_TK class_type OP_TK CP_TK\n-\t\t{ report_class_declaration (NULL); }\n+\t\t{ report_class_declaration (anonymous_context); }\n \tclass_body         \n |\tNEW_TK class_type OP_TK argument_list CP_TK\n-\t\t{ report_class_declaration (NULL); }\n+\t\t{ report_class_declaration (anonymous_context); }\n \tclass_body\n ;\n \n@@ -1155,58 +1176,100 @@ static void\n push_class_context (name)\n     const char *name;\n {\n-  /* If we already have CURRENT_CLASS set, we're in an inter\n-     class. Mangle its name. */\n-  if (current_class)\n-    {\n-      const char *p;\n-      char anonymous [3];\n-      int additional_length;\n-      \n-      /* NAME set to NULL indicates an anonymous class, which are named by\n-\t numbering them. */\n-      if (!name)\n-\t{\n-\t  sprintf (anonymous, \"%d\", ++anonymous_count);\n-\t  p = anonymous;\n-\t}\n-      else\n-\tp = name;\n-      \n-      additional_length = strlen (p)+1; /* +1 for `$' */\n-      current_class = xrealloc (current_class, \n-\t\t\t\tcurrent_class_length + additional_length + 1);\n-      current_class [current_class_length] = '$';\n-      strcpy (&current_class [current_class_length+1], p);\n-      current_class_length += additional_length;\n-    }\n-  else\n-    {\n-      if (!name)\n-\treturn;\n-      current_class_length = strlen (name);\n-      current_class = xmalloc (current_class_length+1);\n-      strcpy (current_class, name);\n-    }\n+  struct class_context *ctx;\n+\n+  ctx = (struct class_context *) xmalloc (sizeof (struct class_context));\n+  ctx->name = (char *) name;\n+  ctx->next = current_class_context;\n+  current_class_context = ctx;\n }\n \n static void\n pop_class_context ()\n {\n-  /* Go back to the last `$' and cut. */\n-  while (--current_class_length > 0\n-        && current_class [current_class_length] != '$')\n-    ;\n-  if (current_class_length)\n+  struct class_context *ctx;\n+\n+  if (current_class_context == NULL)\n+    return;\n+\n+  ctx = current_class_context->next;\n+  if (current_class_context->name != anonymous_context)\n+    free (current_class_context->name);\n+  free (current_class_context);\n+\n+  current_class_context = ctx;\n+  if (current_class_context == NULL)\n+    anonymous_count = 0;\n+}\n+\n+/* Recursively construct the class name.  This is just a helper\n+   function for get_class_name().  */\n+static int\n+make_class_name_recursive (stack, ctx)\n+     struct obstack *stack;\n+     struct class_context *ctx;\n+{\n+  if (! ctx)\n+    return 0;\n+\n+  make_class_name_recursive (stack, ctx->next);\n+\n+  /* Replace an anonymous context with the appropriate counter value.  */\n+  if (ctx->name == anonymous_context)\n     {\n-      current_class = xrealloc (current_class, current_class_length+1);\n-      current_class [current_class_length] = '\\0';\n+      char buf[50];\n+      ++anonymous_count;\n+      sprintf (buf, \"%d\", anonymous_count);\n+      ctx->name = xstrdup (buf);\n     }\n-  else\n+\n+  obstack_grow (stack, ctx->name, strlen (ctx->name));\n+  obstack_1grow (stack, '$');\n+\n+  return ISDIGIT (ctx->name[0]);\n+}\n+\n+/* Return a newly allocated string holding the name of the class.  */\n+static char *\n+get_class_name ()\n+{\n+  char *result;\n+  int last_was_digit;\n+  struct obstack name_stack;\n+\n+  obstack_init (&name_stack);\n+\n+  /* Duplicate the logic of parse.y:maybe_make_nested_class_name().  */\n+  last_was_digit = make_class_name_recursive (&name_stack,\n+\t\t\t\t\t      current_class_context->next);\n+\n+  if (! last_was_digit\n+      && method_depth\n+      && current_class_context->name != anonymous_context)\n     {\n-      current_class = NULL;\n-      anonymous_count = 0;\n+      char buf[50];\n+      ++anonymous_count;\n+      sprintf (buf, \"%d\", anonymous_count);\n+      obstack_grow (&name_stack, buf, strlen (buf));\n+      obstack_1grow (&name_stack, '$');\n     }\n+\n+  if (current_class_context->name == anonymous_context)\n+    {\n+      char buf[50];\n+      ++anonymous_count;\n+      sprintf (buf, \"%d\", anonymous_count);\n+      current_class_context->name = xstrdup (buf);\n+      obstack_grow0 (&name_stack, buf, strlen (buf));\n+    }\n+  else\n+    obstack_grow0 (&name_stack, current_class_context->name,\n+\t\t   strlen (current_class_context->name));\n+\n+  result = xstrdup (obstack_finish (&name_stack));\n+  obstack_free (&name_stack, NULL);\n+\n+  return result;\n }\n \n /* Actions defined here */\n@@ -1220,17 +1283,21 @@ report_class_declaration (name)\n   push_class_context (name);\n   if (flag_dump_class)\n     {\n+      char *name = get_class_name ();\n+\n       if (!previous_output)\n \t{\n \t  if (flag_list_filename)\n \t    fprintf (out, \"%s: \", input_filename);\n \t  previous_output = 1;\n \t}\n-\t\n+\n       if (package_name)\n-\tfprintf (out, \"%s.%s \", package_name, current_class);\n+\tfprintf (out, \"%s.%s \", package_name, name);\n       else\n-\tfprintf (out, \"%s \", current_class);\n+\tfprintf (out, \"%s \", name);\n+\n+      free (name);\n     }\n }\n \n@@ -1247,14 +1314,16 @@ report_main_declaration (declarator)\n       && declarator->args [0] == '[' \n       && (! strcmp (declarator->args+1, \"String\")\n \t  || ! strcmp (declarator->args + 1, \"java.lang.String\"))\n-      && current_class)\n+      && current_class_context)\n     {\n       if (!previous_output)\n \t{\n+\t  char *name = get_class_name ();\n \t  if (package_name)\n-\t    fprintf (out, \"%s.%s \", package_name, current_class);\n+\t    fprintf (out, \"%s.%s \", package_name, name);\n \t  else\n-\t    fprintf (out, \"%s\", current_class);\n+\t    fprintf (out, \"%s\", name);\n+\t  free (name);\n \t  previous_output = 1;\n \t}\n     }\n@@ -1274,7 +1343,7 @@ void reset_report ()\n {\n   previous_output = 0;\n   package_name = NULL;\n-  current_class = NULL;\n+  current_class_context = NULL;\n   complexity = 0;\n }\n "}, {"sha": "742cc6f3b0051c8fb04e15f3e311fe3bf8d805e7", "filename": "gcc/java/parse.y", "status": "modified", "additions": 29, "deletions": 12, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48711f4da92595d5809dad475015809f2308ca71/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48711f4da92595d5809dad475015809f2308ca71/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=48711f4da92595d5809dad475015809f2308ca71", "patch": "@@ -295,7 +295,7 @@ static int pop_current_osb PARAMS ((struct parser_ctxt *));\n /* JDK 1.1 work. FIXME */\n \n static tree maybe_make_nested_class_name PARAMS ((tree));\n-static void make_nested_class_name PARAMS ((tree));\n+static int make_nested_class_name PARAMS ((tree));\n static void set_nested_class_simple_name_value PARAMS ((tree, int));\n static void link_nested_class_to_enclosing PARAMS ((void));\n static tree resolve_inner_class PARAMS ((struct hash_table *, tree, tree *,\n@@ -423,6 +423,10 @@ static tree currently_caught_type_list;\n    `ctxp->current_loop'.  */\n static tree case_label_list; \n \n+/* Anonymous class counter. Will be reset to 1 every time a non\n+   anonymous class gets created. */\n+static int anonymous_class_counter = 1;\n+\n static tree src_parse_roots[1];\n \n /* All classes seen from source code */\n@@ -3497,24 +3501,28 @@ check_class_interface_creation (is_interface, flags, raw_name, qualified_name, d\n   return 0;\n }\n \n-static void\n+/* Construct a nested class name.  If the final component starts with\n+   a digit, return true.  Otherwise return false.  */\n+static int\n make_nested_class_name (cpc_list)\n      tree cpc_list;\n {\n   tree name;\n \n   if (!cpc_list)\n-    return;\n-  else\n-    make_nested_class_name (TREE_CHAIN (cpc_list));\n+    return 0;\n+\n+  make_nested_class_name (TREE_CHAIN (cpc_list));\n \n   /* Pick the qualified name when dealing with the first upmost\n      enclosing class */\n-  name = (TREE_CHAIN (cpc_list) ? \n-\t  TREE_PURPOSE (cpc_list) : DECL_NAME (TREE_VALUE (cpc_list)));\n+  name = (TREE_CHAIN (cpc_list)\n+\t  ? TREE_PURPOSE (cpc_list) : DECL_NAME (TREE_VALUE (cpc_list)));\n   obstack_grow (&temporary_obstack,\n \t\tIDENTIFIER_POINTER (name), IDENTIFIER_LENGTH (name));\n   obstack_1grow (&temporary_obstack, '$');\n+\n+  return ISDIGIT (IDENTIFIER_POINTER (name)[0]);\n }\n \n /* Can't redefine a class already defined in an earlier scope. */\n@@ -3723,7 +3731,20 @@ maybe_make_nested_class_name (name)\n \n   if (CPC_INNER_P ())\n     {\n-      make_nested_class_name (GET_CPC_LIST ());\n+      /* If we're in a function, we must append a number to create the\n+\t nested class name.  However, we don't do this if the class we\n+\t are constructing is anonymous, because in that case we'll\n+\t already have a number as the class name.  */\n+      if (! make_nested_class_name (GET_CPC_LIST ())\n+\t  && current_function_decl != NULL_TREE\n+\t  && ! ISDIGIT (IDENTIFIER_POINTER (name)[0]))\n+\t{\n+\t  char buf[10];\n+\t  sprintf (buf, \"%d\", anonymous_class_counter);\n+\t  ++anonymous_class_counter;\n+\t  obstack_grow (&temporary_obstack, buf, strlen (buf));\n+\t  obstack_1grow (&temporary_obstack, '$');\n+\t}\n       obstack_grow0 (&temporary_obstack,\n \t\t     IDENTIFIER_POINTER (name), \n \t\t     IDENTIFIER_LENGTH (name));\n@@ -3863,10 +3884,6 @@ create_interface (flags, id, super)\n   return decl;\n }\n \n-/* Anonymous class counter. Will be reset to 1 every time a non\n-   anonymous class gets created. */\n-static int anonymous_class_counter = 1;\n-\n /* Patch anonymous class CLASS, by either extending or implementing\n    DEP.  */\n "}]}