{"sha": "0efaba3c697596b51079f33bc4f581c052105777", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGVmYWJhM2M2OTc1OTZiNTEwNzlmMzNiYzRmNTgxYzA1MjEwNTc3Nw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-09-22T01:15:28Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-09-22T01:15:28Z"}, "message": "compiler: Fix unnamed struct type converted to interface type.\n\nFrom-SVN: r191627", "tree": {"sha": "b1ab287d2bfe22bf01345af262a5cd905eef829b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b1ab287d2bfe22bf01345af262a5cd905eef829b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0efaba3c697596b51079f33bc4f581c052105777", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0efaba3c697596b51079f33bc4f581c052105777", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0efaba3c697596b51079f33bc4f581c052105777", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0efaba3c697596b51079f33bc4f581c052105777/comments", "author": null, "committer": null, "parents": [{"sha": "bab51373dc35847b501d3917b206024ba3e7f2b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bab51373dc35847b501d3917b206024ba3e7f2b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bab51373dc35847b501d3917b206024ba3e7f2b2"}], "stats": {"total": 181, "additions": 135, "deletions": 46}, "files": [{"sha": "08e830e7a7544baae93fd443c5b3d1008eb8e070", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0efaba3c697596b51079f33bc4f581c052105777/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0efaba3c697596b51079f33bc4f581c052105777/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=0efaba3c697596b51079f33bc4f581c052105777", "patch": "@@ -293,19 +293,25 @@ Expression::convert_type_to_interface(Translate_context* context,\n       // object type: a list of function pointers for each interface\n       // method.\n       Named_type* rhs_named_type = rhs_type->named_type();\n+      Struct_type* rhs_struct_type = rhs_type->struct_type();\n       bool is_pointer = false;\n-      if (rhs_named_type == NULL)\n+      if (rhs_named_type == NULL && rhs_struct_type == NULL)\n \t{\n \t  rhs_named_type = rhs_type->deref()->named_type();\n+\t  rhs_struct_type = rhs_type->deref()->struct_type();\n \t  is_pointer = true;\n \t}\n       tree method_table;\n-      if (rhs_named_type == NULL)\n-\tmethod_table = null_pointer_node;\n-      else\n+      if (rhs_named_type != NULL)\n \tmethod_table =\n \t  rhs_named_type->interface_method_table(gogo, lhs_interface_type,\n \t\t\t\t\t\t is_pointer);\n+      else if (rhs_struct_type != NULL)\n+\tmethod_table =\n+\t  rhs_struct_type->interface_method_table(gogo, lhs_interface_type,\n+\t\t\t\t\t\t  is_pointer);\n+      else\n+\tmethod_table = null_pointer_node;\n       first_field_value = fold_convert_loc(location.gcc_location(),\n                                            const_ptr_type_node, method_table);\n     }"}, {"sha": "0d1746f1c15e753a4e7572c20eeaeb525653ea0a", "filename": "gcc/go/gofrontend/gogo-tree.cc", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0efaba3c697596b51079f33bc4f581c052105777/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0efaba3c697596b51079f33bc4f581c052105777/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc?ref=0efaba3c697596b51079f33bc4f581c052105777", "patch": "@@ -2128,8 +2128,7 @@ Gogo::slice_constructor(tree slice_type_tree, tree values, tree count,\n \n tree\n Gogo::interface_method_table_for_type(const Interface_type* interface,\n-\t\t\t\t      Named_type* type,\n-\t\t\t\t      bool is_pointer)\n+\t\t\t\t      Type* type, bool is_pointer)\n {\n   const Typed_identifier_list* interface_methods = interface->methods();\n   go_assert(!interface_methods->empty());\n@@ -2158,7 +2157,9 @@ Gogo::interface_method_table_for_type(const Interface_type* interface,\n   // interface.  If the interface has hidden methods, and the named\n   // type is defined in a different package, then the interface\n   // conversion table will be defined by that other package.\n-  if (has_hidden_methods && type->named_object()->package() != NULL)\n+  if (has_hidden_methods\n+      && type->named_type() != NULL\n+      && type->named_type()->named_object()->package() != NULL)\n     {\n       tree array_type = build_array_type(const_ptr_type_node, NULL);\n       tree decl = build_decl(BUILTINS_LOCATION, VAR_DECL, id, array_type);\n@@ -2187,13 +2188,20 @@ Gogo::interface_method_table_for_type(const Interface_type* interface,\n                                               Linemap::predeclared_location());\n   elt->value = fold_convert(const_ptr_type_node, tdp);\n \n+  Named_type* nt = type->named_type();\n+  Struct_type* st = type->struct_type();\n+  go_assert(nt != NULL || st != NULL);\n   size_t i = 1;\n   for (Typed_identifier_list::const_iterator p = interface_methods->begin();\n        p != interface_methods->end();\n        ++p, ++i)\n     {\n       bool is_ambiguous;\n-      Method* m = type->method_function(p->name(), &is_ambiguous);\n+      Method* m;\n+      if (nt != NULL)\n+\tm = nt->method_function(p->name(), &is_ambiguous);\n+      else\n+\tm = st->method_function(p->name(), &is_ambiguous);\n       go_assert(m != NULL);\n \n       Named_object* no = m->named_object();"}, {"sha": "fa61808ec3cdcf8e7c4d81b3b9b79956725de074", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0efaba3c697596b51079f33bc4f581c052105777/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0efaba3c697596b51079f33bc4f581c052105777/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=0efaba3c697596b51079f33bc4f581c052105777", "patch": "@@ -2872,7 +2872,8 @@ int\n Build_method_tables::type(Type* type)\n {\n   Named_type* nt = type->named_type();\n-  if (nt != NULL)\n+  Struct_type* st = type->struct_type();\n+  if (nt != NULL || st != NULL)\n     {\n       for (std::vector<Interface_type*>::const_iterator p =\n \t     this->interfaces_.begin();\n@@ -2882,10 +2883,23 @@ Build_method_tables::type(Type* type)\n \t  // We ask whether a pointer to the named type implements the\n \t  // interface, because a pointer can implement more methods\n \t  // than a value.\n-\t  if ((*p)->implements_interface(Type::make_pointer_type(nt), NULL))\n+\t  if (nt != NULL)\n \t    {\n-\t      nt->interface_method_table(this->gogo_, *p, false);\n-\t      nt->interface_method_table(this->gogo_, *p, true);\n+\t      if ((*p)->implements_interface(Type::make_pointer_type(nt),\n+\t\t\t\t\t     NULL))\n+\t\t{\n+\t\t  nt->interface_method_table(this->gogo_, *p, false);\n+\t\t  nt->interface_method_table(this->gogo_, *p, true);\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      if ((*p)->implements_interface(Type::make_pointer_type(st),\n+\t\t\t\t\t     NULL))\n+\t\t{\n+\t\t  st->interface_method_table(this->gogo_, *p, false);\n+\t\t  st->interface_method_table(this->gogo_, *p, true);\n+\t\t}\n \t    }\n \t}\n     }"}, {"sha": "36709f5b45b11a8ea2e7ecdbce67b752e826e52c", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0efaba3c697596b51079f33bc4f581c052105777/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0efaba3c697596b51079f33bc4f581c052105777/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=0efaba3c697596b51079f33bc4f581c052105777", "patch": "@@ -574,7 +574,7 @@ class Gogo\n   // Build an interface method table for a type: a list of function\n   // pointers, one for each interface method.  This returns a decl.\n   tree\n-  interface_method_table_for_type(const Interface_type*, Named_type*,\n+  interface_method_table_for_type(const Interface_type*, Type*,\n \t\t\t\t  bool is_pointer);\n \n   // Return a tree which allocate SIZE bytes to hold values of type"}, {"sha": "3ae54a43806a221d2740e4f4344c483ad6acd189", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 64, "deletions": 27, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0efaba3c697596b51079f33bc4f581c052105777/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0efaba3c697596b51079f33bc4f581c052105777/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=0efaba3c697596b51079f33bc4f581c052105777", "patch": "@@ -4554,6 +4554,20 @@ Struct_type::method_function(const std::string& name, bool* is_ambiguous) const\n   return Type::method_function(this->all_methods_, name, is_ambiguous);\n }\n \n+// Return a pointer to the interface method table for this type for\n+// the interface INTERFACE.  IS_POINTER is true if this is for a\n+// pointer to THIS.\n+\n+tree\n+Struct_type::interface_method_table(Gogo* gogo,\n+\t\t\t\t    const Interface_type* interface,\n+\t\t\t\t    bool is_pointer)\n+{\n+  return Type::interface_method_table(gogo, this, interface, is_pointer,\n+\t\t\t\t      &this->interface_method_tables_,\n+\t\t\t\t      &this->pointer_interface_method_tables_);\n+}\n+\n // Convert struct fields to the backend representation.  This is not\n // declared in types.h so that types.h doesn't have to #include\n // backend.h.\n@@ -7182,7 +7196,17 @@ Interface_type::do_mangled_name(Gogo* gogo, std::string* ret) const\n \t{\n \t  if (!p->name().empty())\n \t    {\n-\t      std::string n = Gogo::unpack_hidden_name(p->name());\n+\t      std::string n;\n+\t      if (!Gogo::is_hidden_name(p->name()))\n+\t\tn = p->name();\n+\t      else\n+\t\t{\n+\t\t  n = \".\";\n+\t\t  std::string pkgpath = Gogo::hidden_name_pkgpath(p->name());\n+\t\t  n.append(Gogo::pkgpath_for_symbol(pkgpath));\n+\t\t  n.append(1, '.');\n+\t\t  n.append(Gogo::unpack_hidden_name(p->name()));\n+\t\t}\n \t      char buf[20];\n \t      snprintf(buf, sizeof buf, \"%u_\",\n \t\t       static_cast<unsigned int>(n.length()));\n@@ -7735,32 +7759,9 @@ tree\n Named_type::interface_method_table(Gogo* gogo, const Interface_type* interface,\n \t\t\t\t   bool is_pointer)\n {\n-  go_assert(!interface->is_empty());\n-\n-  Interface_method_tables** pimt = (is_pointer\n-\t\t\t\t    ? &this->interface_method_tables_\n-\t\t\t\t    : &this->pointer_interface_method_tables_);\n-\n-  if (*pimt == NULL)\n-    *pimt = new Interface_method_tables(5);\n-\n-  std::pair<const Interface_type*, tree> val(interface, NULL_TREE);\n-  std::pair<Interface_method_tables::iterator, bool> ins = (*pimt)->insert(val);\n-\n-  if (ins.second)\n-    {\n-      // This is a new entry in the hash table.\n-      go_assert(ins.first->second == NULL_TREE);\n-      ins.first->second = gogo->interface_method_table_for_type(interface,\n-\t\t\t\t\t\t\t\tthis,\n-\t\t\t\t\t\t\t\tis_pointer);\n-    }\n-\n-  tree decl = ins.first->second;\n-  if (decl == error_mark_node)\n-    return error_mark_node;\n-  go_assert(decl != NULL_TREE && TREE_CODE(decl) == VAR_DECL);\n-  return build_fold_addr_expr(decl);\n+  return Type::interface_method_table(gogo, this, interface, is_pointer,\n+\t\t\t\t      &this->interface_method_tables_,\n+\t\t\t\t      &this->pointer_interface_method_tables_);\n }\n \n // Return whether a named type has any hidden fields.\n@@ -8944,6 +8945,42 @@ Type::method_function(const Methods* methods, const std::string& name,\n   return m;\n }\n \n+// Return a pointer to the interface method table for TYPE for the\n+// interface INTERFACE.\n+\n+tree\n+Type::interface_method_table(Gogo* gogo, Type* type,\n+\t\t\t     const Interface_type *interface,\n+\t\t\t     bool is_pointer,\n+\t\t\t     Interface_method_tables** method_tables,\n+\t\t\t     Interface_method_tables** pointer_tables)\n+{\n+  go_assert(!interface->is_empty());\n+\n+  Interface_method_tables** pimt = is_pointer ? method_tables : pointer_tables;\n+\n+  if (*pimt == NULL)\n+    *pimt = new Interface_method_tables(5);\n+\n+  std::pair<const Interface_type*, tree> val(interface, NULL_TREE);\n+  std::pair<Interface_method_tables::iterator, bool> ins = (*pimt)->insert(val);\n+\n+  if (ins.second)\n+    {\n+      // This is a new entry in the hash table.\n+      go_assert(ins.first->second == NULL_TREE);\n+      ins.first->second = gogo->interface_method_table_for_type(interface,\n+\t\t\t\t\t\t\t\ttype,\n+\t\t\t\t\t\t\t\tis_pointer);\n+    }\n+\n+  tree decl = ins.first->second;\n+  if (decl == error_mark_node)\n+    return error_mark_node;\n+  go_assert(decl != NULL_TREE && TREE_CODE(decl) == VAR_DECL);\n+  return build_fold_addr_expr(decl);\n+}\n+\n // Look for field or method NAME for TYPE.  Return an Expression for\n // the field or method bound to EXPR.  If there is no such field or\n // method, give an appropriate error and return an error expression."}, {"sha": "cced68ddd6888ab65c85cedb19879124afe22973", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 30, "deletions": 6, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0efaba3c697596b51079f33bc4f581c052105777/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0efaba3c697596b51079f33bc4f581c052105777/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=0efaba3c697596b51079f33bc4f581c052105777", "patch": "@@ -983,6 +983,19 @@ class Type\n   method_function(const Methods*, const std::string& name,\n \t\t  bool* is_ambiguous);\n \n+  // A mapping from interfaces to the associated interface method\n+  // tables for this type.  This maps to a decl.\n+  typedef Unordered_map_hash(const Interface_type*, tree, Type_hash_identical,\n+\t\t\t     Type_identical) Interface_method_tables;\n+\n+  // Return a pointer to the interface method table for TYPE for the\n+  // interface INTERFACE.\n+  static tree\n+  interface_method_table(Gogo* gogo, Type* type,\n+\t\t\t const Interface_type *interface, bool is_pointer,\n+\t\t\t Interface_method_tables** method_tables,\n+\t\t\t Interface_method_tables** pointer_tables);\n+\n   // Return a composite literal for the type descriptor entry for a\n   // type.\n   static Expression*\n@@ -1994,7 +2007,8 @@ class Struct_type : public Type\n  public:\n   Struct_type(Struct_field_list* fields, Location location)\n     : Type(TYPE_STRUCT),\n-      fields_(fields), location_(location), all_methods_(NULL)\n+      fields_(fields), location_(location), all_methods_(NULL),\n+      interface_method_tables_(NULL), pointer_interface_method_tables_(NULL)\n   { }\n \n   // Return the field NAME.  This only looks at local fields, not at\n@@ -2076,6 +2090,14 @@ class Struct_type : public Type\n   Method*\n   method_function(const std::string& name, bool* is_ambiguous) const;\n \n+  // Return a pointer to the interface method table for this type for\n+  // the interface INTERFACE.  If IS_POINTER is true, set the type\n+  // descriptor to a pointer to this type, otherwise set it to this\n+  // type.\n+  tree\n+  interface_method_table(Gogo*, const Interface_type* interface,\n+\t\t\t bool is_pointer);\n+\n   // Traverse just the field types of a struct type.\n   int\n   traverse_field_types(Traverse* traverse)\n@@ -2156,6 +2178,13 @@ class Struct_type : public Type\n   Location location_;\n   // If this struct is unnamed, a list of methods.\n   Methods* all_methods_;\n+  // A mapping from interfaces to the associated interface method\n+  // tables for this type.  Only used if this struct is unnamed.\n+  Interface_method_tables* interface_method_tables_;\n+  // A mapping from interfaces to the associated interface method\n+  // tables for pointers to this type.  Only used if this struct is\n+  // unnamed.\n+  Interface_method_tables* pointer_interface_method_tables_;\n };\n \n // The type of an array.\n@@ -2861,11 +2890,6 @@ class Named_type : public Type\n   void\n   create_placeholder(Gogo*);\n \n-  // A mapping from interfaces to the associated interface method\n-  // tables for this type.  This maps to a decl.\n-  typedef Unordered_map_hash(const Interface_type*, tree, Type_hash_identical,\n-\t\t\t     Type_identical) Interface_method_tables;\n-\n   // A pointer back to the Named_object for this type.\n   Named_object* named_object_;\n   // If this type is defined in a function, a pointer back to the"}]}