{"sha": "f93444883de1497f29370fd7f1ab5d828b9b08e9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjkzNDQ0ODgzZGUxNDk3ZjI5MzcwZmQ3ZjFhYjVkODI4YjliMDhlOQ==", "commit": {"author": {"name": "Sebastian Pop", "email": "sebastian.pop@amd.com", "date": "2009-01-13T15:33:13Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2009-01-13T15:33:13Z"}, "message": "re PR middle-end/38786 ([graphite] ICE with -floop-block in verify_ssa)\n\n2009-01-13  Sebastian Pop  <sebastian.pop@amd.com>\n\n\tPR tree-optimization/38786\n\t* gcc.dg/graphite/pr38786.c: New.\n\t* graphite.c (expand_scalar_variables_ssa_name): New, outlined from\n\tthe SSA_NAME case of expand_scalar_variables_expr.\n\tSet the type of an expression to the type of its assign\tstatement.\n\t(expand_scalar_variables_expr): Also gather the scalar computation\n\tused to index the memory access.  Do not pass loop_p.\n\tFix comment.  Stop recursion on tcc_constant or tcc_declaration.\n\t(expand_scalar_variables_stmt): Pass to expand_scalar_variables_expr\n\tthe gimple_stmt_iterator where it inserts new code.  Do not pass loop_p.\n\t(copy_bb_and_scalar_dependences): Do not pass loop_p.\n\t(translate_clast): Update call to copy_bb_and_scalar_dependences.\n\nFrom-SVN: r143341", "tree": {"sha": "b4edb260862454775b1db407478fdc787b9edf19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b4edb260862454775b1db407478fdc787b9edf19"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f93444883de1497f29370fd7f1ab5d828b9b08e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f93444883de1497f29370fd7f1ab5d828b9b08e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f93444883de1497f29370fd7f1ab5d828b9b08e9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f93444883de1497f29370fd7f1ab5d828b9b08e9/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2d8bb84db9611d9064f202c9bb9a779b844c2bf0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d8bb84db9611d9064f202c9bb9a779b844c2bf0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d8bb84db9611d9064f202c9bb9a779b844c2bf0"}], "stats": {"total": 259, "additions": 190, "deletions": 69}, "files": [{"sha": "bd96796a12da869acf0ca779fde64d0bab1fa1a6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f93444883de1497f29370fd7f1ab5d828b9b08e9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f93444883de1497f29370fd7f1ab5d828b9b08e9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f93444883de1497f29370fd7f1ab5d828b9b08e9", "patch": "@@ -1,3 +1,17 @@\n+2009-01-13  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\tPR tree-optimization/38786\n+\t* graphite.c (expand_scalar_variables_ssa_name): New, outlined from\n+\tthe SSA_NAME case of expand_scalar_variables_expr.\n+\tSet the type of an expression to the type of its assign\tstatement.\n+\t(expand_scalar_variables_expr): Also gather the scalar computation\n+\tused to index the memory access.  Do not pass loop_p.\n+\tFix comment.  Stop recursion on tcc_constant or tcc_declaration.\n+\t(expand_scalar_variables_stmt): Pass to expand_scalar_variables_expr\n+\tthe gimple_stmt_iterator where it inserts new code.  Do not pass loop_p.\n+\t(copy_bb_and_scalar_dependences): Do not pass loop_p.\n+\t(translate_clast): Update call to copy_bb_and_scalar_dependences.\n+\n 2009-01-13  Sebastian Pop  <sebastian.pop@amd.com>\n \n \t* graphite.h (debug_value): Removed."}, {"sha": "a9d8d450d10b8c29034684a81715a73b7c57c88a", "filename": "gcc/graphite.c", "status": "modified", "additions": 131, "deletions": 69, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f93444883de1497f29370fd7f1ab5d828b9b08e9/gcc%2Fgraphite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f93444883de1497f29370fd7f1ab5d828b9b08e9/gcc%2Fgraphite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite.c?ref=f93444883de1497f29370fd7f1ab5d828b9b08e9", "patch": "@@ -4082,111 +4082,172 @@ is_iv (tree name)\n }\n \n static void expand_scalar_variables_stmt (gimple, basic_block, scop_p,\n-\t\t\t\t\t  loop_p, htab_t);\n+\t\t\t\t\t  htab_t);\n+static tree\n+expand_scalar_variables_expr (tree, tree, enum tree_code, tree, basic_block,\n+\t\t\t      scop_p, htab_t, gimple_stmt_iterator *);\n+\n+/* Copies at GSI all the scalar computations on which the ssa_name OP0\n+   depends on in the SCOP: these are all the scalar variables used in\n+   the definition of OP0, that are defined outside BB and still in the\n+   SCOP, i.e. not a parameter of the SCOP.  The expression that is\n+   returned contains only induction variables from the generated code:\n+   MAP contains the induction variables renaming mapping, and is used\n+   to translate the names of induction variables.  */\n+\n+static tree\n+expand_scalar_variables_ssa_name (tree op0, basic_block bb,\n+\t\t\t\t  scop_p scop, htab_t map, \n+\t\t\t\t  gimple_stmt_iterator *gsi)\n+{\n+  tree var0, var1, type;\n+  gimple def_stmt;\n+  enum tree_code subcode;\n+      \n+  if (is_parameter (scop, op0)\n+      || is_iv (op0))\n+    return get_new_name_from_old_name (map, op0);\n+      \n+  def_stmt = SSA_NAME_DEF_STMT (op0);\n+      \n+  if (gimple_bb (def_stmt) == bb)\n+    {\n+      /* If the defining statement is in the basic block already\n+\t we do not need to create a new expression for it, we\n+\t only need to ensure its operands are expanded.  */\n+      expand_scalar_variables_stmt (def_stmt, bb, scop, map);\n+      return get_new_name_from_old_name (map, op0);\n+    }\n+  else\n+    {\n+      if (gimple_code (def_stmt) != GIMPLE_ASSIGN\n+\t  || !bb_in_scop_p (gimple_bb (def_stmt), scop))\n+\treturn get_new_name_from_old_name (map, op0);\n+\n+      var0 = gimple_assign_rhs1 (def_stmt);\n+      subcode = gimple_assign_rhs_code (def_stmt);\n+      var1 = gimple_assign_rhs2 (def_stmt);\n+      type = gimple_expr_type (def_stmt);\n+\n+      return expand_scalar_variables_expr (type, var0, subcode, var1, bb, scop,\n+\t\t\t\t\t   map, gsi);\n+    }\n+}\n \n-/* Constructs a tree which only contains old_ivs and parameters.  Any\n-   other variables that are defined outside BB will be eliminated by\n-   using their definitions in the constructed tree.  OLD_LOOP_FATHER\n-   is the original loop that contained BB.  */\n+/* Copies at GSI all the scalar computations on which the expression\n+   OP0 CODE OP1 depends on in the SCOP: these are all the scalar\n+   variables used in OP0 and OP1, defined outside BB and still defined\n+   in the SCOP, i.e. not a parameter of the SCOP.  The expression that\n+   is returned contains only induction variables from the generated\n+   code: MAP contains the induction variables renaming mapping, and is\n+   used to translate the names of induction variables.  */\n \n static tree\n expand_scalar_variables_expr (tree type, tree op0, enum tree_code code, \n \t\t\t      tree op1, basic_block bb, scop_p scop, \n-\t\t\t      loop_p old_loop_father, htab_t map)\n+\t\t\t      htab_t map, gimple_stmt_iterator *gsi)\n {\n-  if ((TREE_CODE_CLASS (code) == tcc_constant\n-       && code == INTEGER_CST)\n-      || TREE_CODE_CLASS (code) == tcc_reference)\n+  if (TREE_CODE_CLASS (code) == tcc_constant\n+      || TREE_CODE_CLASS (code) == tcc_declaration)\n     return op0;\n \n+  /* For data references we have to duplicate also its memory\n+     indexing.  */\n+  if (TREE_CODE_CLASS (code) == tcc_reference)\n+    {\n+      switch (code)\n+\t{\n+\tcase INDIRECT_REF:\n+\t  {\n+\t    tree old_name = TREE_OPERAND (op0, 0);\n+\t    tree expr = expand_scalar_variables_ssa_name\n+\t      (old_name, bb, scop, map, gsi);\n+\t    tree new_name = force_gimple_operand_gsi (gsi, expr, true, NULL,\n+\t\t\t\t\t\t      true, GSI_SAME_STMT);\n+\n+\t    set_symbol_mem_tag (SSA_NAME_VAR (new_name),\n+\t\t\t\tsymbol_mem_tag (SSA_NAME_VAR (old_name)));\n+\t    return fold_build1 (code, type, new_name);\n+\t  }\n+\n+\tcase ARRAY_REF:\n+\t  {\n+\t    tree op00 = TREE_OPERAND (op0, 0);\n+\t    tree op01 = TREE_OPERAND (op0, 1);\n+\t    tree op02 = TREE_OPERAND (op0, 2);\n+\t    tree op03 = TREE_OPERAND (op0, 3);\n+\t    tree base = expand_scalar_variables_expr\n+\t      (TREE_TYPE (op00), op00, TREE_CODE (op00), NULL, bb, scop,\n+\t       map, gsi);\n+\t    tree subscript = expand_scalar_variables_expr\n+\t      (TREE_TYPE (op01), op01, TREE_CODE (op01), NULL, bb, scop,\n+\t       map, gsi);\n+\n+\t    return build4 (ARRAY_REF, type, base, subscript, op02, op03);\n+\t  }\n+\n+\tdefault:\n+\t  /* The above cases should catch everything.  */\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+\n   if (TREE_CODE_CLASS (code) == tcc_unary)\n     {\n       tree op0_type = TREE_TYPE (op0);\n       enum tree_code op0_code = TREE_CODE (op0);\n-      tree op0_expr = \n-\texpand_scalar_variables_expr (op0_type, op0, op0_code,\n-\t\t\t\t      NULL, bb, scop, old_loop_father, map);\n-\n+      tree op0_expr = expand_scalar_variables_expr (op0_type, op0, op0_code,\n+\t\t\t\t\t\t    NULL, bb, scop, map, gsi);\n+  \n       return fold_build1 (code, type, op0_expr);\n     }\n \n   if (TREE_CODE_CLASS (code) == tcc_binary)\n     {\n       tree op0_type = TREE_TYPE (op0);\n       enum tree_code op0_code = TREE_CODE (op0);\n-      tree op0_expr = \n-\texpand_scalar_variables_expr (op0_type, op0, op0_code,\n-\t\t\t\t      NULL, bb, scop, old_loop_father, map);\n+      tree op0_expr = expand_scalar_variables_expr (op0_type, op0, op0_code,\n+\t\t\t\t\t\t    NULL, bb, scop, map, gsi);\n       tree op1_type = TREE_TYPE (op1);\n       enum tree_code op1_code = TREE_CODE (op1);\n-      tree op1_expr = \n-\texpand_scalar_variables_expr (op1_type, op1, op1_code,\n-\t\t\t\t      NULL, bb, scop, old_loop_father, map);\n+      tree op1_expr = expand_scalar_variables_expr (op1_type, op1, op1_code,\n+\t\t\t\t\t\t    NULL, bb, scop, map, gsi);\n \n       return fold_build2 (code, type, op0_expr, op1_expr);\n     }\n \n   if (code == SSA_NAME)\n-    {\n-      tree var0, var1;\n-      gimple def_stmt;\n-      enum tree_code subcode;\n-      \n-      if (is_parameter (scop, op0)\n-\t  || is_iv (op0))\n-\treturn get_new_name_from_old_name (map, op0);\n-      \n-      def_stmt = SSA_NAME_DEF_STMT (op0);\n-      \n-      if (gimple_bb (def_stmt) == bb)\n-\t{\n-\t  /* If the defining statement is in the basic block already\n-\t     we do not need to create a new expression for it, we\n-\t     only need to ensure its operands are expanded.  */\n-\t  expand_scalar_variables_stmt (def_stmt, bb, scop,\n-\t\t\t\t\told_loop_father, map);\n-\t  return get_new_name_from_old_name (map, op0);\n-\t}\n-      else\n-\t{\n-\t  if (gimple_code (def_stmt) != GIMPLE_ASSIGN\n-\t      || !bb_in_scop_p (gimple_bb (def_stmt), scop))\n-\t    return get_new_name_from_old_name (map, op0);\n-\n-\t  var0 = gimple_assign_rhs1 (def_stmt);\n-\t  subcode = gimple_assign_rhs_code (def_stmt);\n-\t  var1 = gimple_assign_rhs2 (def_stmt);\n-\n-\t  return expand_scalar_variables_expr (type, var0, subcode, var1,\n-\t\t\t\t\t       bb, scop, old_loop_father, map);\n-\t}\n-    }\n+    return expand_scalar_variables_ssa_name (op0, bb, scop, map, gsi);\n \n   gcc_unreachable ();\n   return NULL;\n }\n \n-/* Replicates any uses of non-parameters and non-old-ivs variablesthat\n-   are defind outside BB with code that is inserted in BB.\n-   OLD_LOOP_FATHER is the original loop that contained STMT.  */\n+/* Copies at the beginning of BB all the scalar computations on which\n+   STMT depends on in the SCOP: these are all the scalar variables used\n+   in STMT, defined outside BB and still defined in the SCOP, i.e. not a\n+   parameter of the SCOP.  The expression that is returned contains\n+   only induction variables from the generated code: MAP contains the\n+   induction variables renaming mapping, and is used to translate the\n+   names of induction variables.  */\n  \n static void\n expand_scalar_variables_stmt (gimple stmt, basic_block bb, scop_p scop,\n-\t\t\t      loop_p old_loop_father, htab_t map)\n+\t\t\t      htab_t map)\n {\n   ssa_op_iter iter;\n   use_operand_p use_p;\n+  gimple_stmt_iterator gsi = gsi_after_labels (bb);\n \n   FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_USE)\n     {\n       tree use = USE_FROM_PTR (use_p);\n       tree type = TREE_TYPE (use);\n       enum tree_code code = TREE_CODE (use);\n       tree use_expr = expand_scalar_variables_expr (type, use, code, NULL, bb,\n-\t\t\t\t\t\t    scop, old_loop_father, map);\n+\t\t\t\t\t\t    scop, map, &gsi);\n       if (use_expr != use)\n \t{\n-\t  gimple_stmt_iterator gsi = gsi_after_labels (bb);\n \t  tree new_use =\n \t    force_gimple_operand_gsi (&gsi, use_expr, true, NULL,\n \t\t\t\t      true, GSI_NEW_STMT);\n@@ -4197,21 +4258,23 @@ expand_scalar_variables_stmt (gimple stmt, basic_block bb, scop_p scop,\n   update_stmt (stmt);\n }\n \n-/* Copies the definitions outside of BB of variables that are not\n-   induction variables nor parameters.  BB must only contain\n-   \"external\" references to these types of variables.  OLD_LOOP_FATHER\n-   is the original loop that contained BB.  */\n+/* Copies at the beginning of BB all the scalar computations on which\n+   BB depends on in the SCOP: these are all the scalar variables used\n+   in BB, defined outside BB and still defined in the SCOP, i.e. not a\n+   parameter of the SCOP.  The expression that is returned contains\n+   only induction variables from the generated code: MAP contains the\n+   induction variables renaming mapping, and is used to translate the\n+   names of induction variables.  */\n \n static void \n-expand_scalar_variables (basic_block bb, scop_p scop, \n-\t\t\t loop_p old_loop_father, htab_t map)\n+expand_scalar_variables (basic_block bb, scop_p scop, htab_t map)\n {\n   gimple_stmt_iterator gsi;\n   \n   for (gsi = gsi_after_labels (bb); !gsi_end_p (gsi);)\n     {\n       gimple stmt = gsi_stmt (gsi);\n-      expand_scalar_variables_stmt (stmt, bb, scop, old_loop_father, map);\n+      expand_scalar_variables_stmt (stmt, bb, scop, map);\n       gsi_next (&gsi);\n     }\n }\n@@ -4388,7 +4451,6 @@ register_scop_liveout_renames (scop_p scop, htab_t rename_map)\n  \n static edge\n copy_bb_and_scalar_dependences (basic_block bb, scop_p scop,\n-\t\t\t\tloop_p context_loop,\n \t\t\t\tedge next_e, htab_t map)\n {\n   basic_block new_bb = split_edge (next_e);\n@@ -4398,7 +4460,7 @@ copy_bb_and_scalar_dependences (basic_block bb, scop_p scop,\n   remove_condition (new_bb);\n   rename_variables (new_bb, map);\n   remove_phi_nodes (new_bb);\n-  expand_scalar_variables (new_bb, scop, context_loop, map);\n+  expand_scalar_variables (new_bb, scop, map);\n   register_scop_liveout_renames (scop, map);\n \n   return next_e;\n@@ -4570,7 +4632,7 @@ translate_clast (scop_p scop, struct loop *context_loop,\n       loop_iv_stack_patch_for_consts (ivstack, (struct clast_user_stmt *) stmt);\n       build_iv_mapping (ivstack, map, gbb, scop);\n       next_e = copy_bb_and_scalar_dependences (GBB_BB (gbb), scop,\n-\t\t\t\t\t       context_loop, next_e, map);\n+\t\t\t\t\t       next_e, map);\n       htab_delete (map);\n       loop_iv_stack_remove_constants (ivstack);\n       update_ssa (TODO_update_ssa);"}, {"sha": "c05a25a1203a53c043eec715564070c281b53a0e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f93444883de1497f29370fd7f1ab5d828b9b08e9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f93444883de1497f29370fd7f1ab5d828b9b08e9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f93444883de1497f29370fd7f1ab5d828b9b08e9", "patch": "@@ -1,3 +1,8 @@\n+2009-01-13  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\tPR tree-optimization/38786\n+\t* gcc.dg/graphite/pr38786.c: New.\n+\n 2009-01-13  Uros Bizjak  <ubizjak@gmail.com>\n \n \tRevert:"}, {"sha": "2e68185ab62081db8827fd706219080587e752d9", "filename": "gcc/testsuite/gcc.dg/graphite/pr38786.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f93444883de1497f29370fd7f1ab5d828b9b08e9/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr38786.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f93444883de1497f29370fd7f1ab5d828b9b08e9/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr38786.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr38786.c?ref=f93444883de1497f29370fd7f1ab5d828b9b08e9", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-options \"-O2 -fgraphite-identity\" } */\n+\n+typedef struct\n+{\n+  int ****cofAC;\n+} ImageParameters;\n+typedef struct\n+{\n+  int ****cofAC;\n+} RD_DATA;\n+extern RD_DATA *rdopt;\n+extern ImageParameters *img;\n+dummy_slice_too_big (int bits_slice)\n+{\n+  int i, j, k, l;\n+  for (j = 0; j < 4; j++)\n+    for (k = 0; k < 2; k++)\n+      for (l = 0; l < 65; l++)\n+\timg->cofAC[i][j][k][l] = rdopt->cofAC[i][j][k][l];\n+}\n+/* { dg-options \"-O2 -fgraphite-identity\" } */\n+\n+typedef struct\n+{\n+  int ****cofAC;\n+} ImageParameters;\n+typedef struct\n+{\n+  int ****cofAC;\n+} RD_DATA;\n+extern RD_DATA *rdopt;\n+extern ImageParameters *img;\n+dummy_slice_too_big (int bits_slice)\n+{\n+  int i, j, k, l;\n+  for (j = 0; j < 4; j++)\n+    for (k = 0; k < 2; k++)\n+      for (l = 0; l < 65; l++)\n+\timg->cofAC[i][j][k][l] = rdopt->cofAC[i][j][k][l];\n+}"}]}