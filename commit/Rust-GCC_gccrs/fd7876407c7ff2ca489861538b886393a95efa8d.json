{"sha": "fd7876407c7ff2ca489861538b886393a95efa8d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmQ3ODc2NDA3YzdmZjJjYTQ4OTg2MTUzOGI4ODYzOTNhOTVlZmE4ZA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2012-02-29T18:28:41Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2012-02-29T18:28:41Z"}, "message": "dwarf2out.c (modified_type_die): Set DW_AT_GNAT_descriptive_type and DW_AT_artificial attributes at the end of...\n\n\t* dwarf2out.c (modified_type_die): Set DW_AT_GNAT_descriptive_type and\n\tDW_AT_artificial attributes at the end of the processing.\n\t(gen_array_type_die): Likewise.\n\t(gen_enumeration_type_die): Likewise.\n\t(gen_struct_or_union_type_die): Likewise.\n\t(add_gnat_descriptive_type_attribute): Do not suppress debug info for\n\tthe parent type.\nada/\n\t* gcc-interface/decl.c (components_to_record): Add ARTIFICIAL parameter\n\tand set TYPE_ARTIFICIAL according to it. \u00a0Adjust recursive call.\n\t(gnat_to_gnu_entity) <E_Record_Type>: Adjust call to above function.\n\t* gcc-interface/utils.c (rest_of_record_type_compilation): Do not\n\tinvoke rest_of_type_decl_compilation on the parallel type, if any.\n\nFrom-SVN: r184667", "tree": {"sha": "d7a052206dec8e0150c21d87cffdc18eb54d0f4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d7a052206dec8e0150c21d87cffdc18eb54d0f4e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fd7876407c7ff2ca489861538b886393a95efa8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd7876407c7ff2ca489861538b886393a95efa8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd7876407c7ff2ca489861538b886393a95efa8d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd7876407c7ff2ca489861538b886393a95efa8d/comments", "author": null, "committer": null, "parents": [{"sha": "a3017cf147db82ad86e5a81b9677e8ca8e29ead2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3017cf147db82ad86e5a81b9677e8ca8e29ead2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3017cf147db82ad86e5a81b9677e8ca8e29ead2"}], "stats": {"total": 82, "additions": 54, "deletions": 28}, "files": [{"sha": "1b781138362341e7ee37bdfbe28580b08a818c03", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd7876407c7ff2ca489861538b886393a95efa8d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd7876407c7ff2ca489861538b886393a95efa8d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fd7876407c7ff2ca489861538b886393a95efa8d", "patch": "@@ -1,3 +1,13 @@\n+2012-02-29  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* dwarf2out.c (modified_type_die): Set DW_AT_GNAT_descriptive_type and\n+\tDW_AT_artificial attributes at the end of the processing.\n+\t(gen_array_type_die): Likewise.\n+\t(gen_enumeration_type_die): Likewise.\n+\t(gen_struct_or_union_type_die): Likewise.\n+\t(add_gnat_descriptive_type_attribute): Do not suppress debug info for\n+\tthe parent type.\n+\n 2012-02-29  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/52419"}, {"sha": "e586354c32a29bafb6a007be163cd4926efc0fc3", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd7876407c7ff2ca489861538b886393a95efa8d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd7876407c7ff2ca489861538b886393a95efa8d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=fd7876407c7ff2ca489861538b886393a95efa8d", "patch": "@@ -1,3 +1,11 @@\n+2012-02-29  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (components_to_record): Add ARTIFICIAL parameter\n+\tand set TYPE_ARTIFICIAL according to it. \ufffdAdjust recursive call.\n+\t(gnat_to_gnu_entity) <E_Record_Type>: Adjust call to above function.\n+\t* gcc-interface/utils.c (rest_of_record_type_compilation): Do not\n+\tinvoke rest_of_type_decl_compilation on the parallel type, if any.\n+\n 2012-02-29  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/utils.c (gnat_write_global_declarations): Make sure the"}, {"sha": "5b6d2f78eee7fd27497b97b67f4a05421e65b9dc", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd7876407c7ff2ca489861538b886393a95efa8d/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd7876407c7ff2ca489861538b886393a95efa8d/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=fd7876407c7ff2ca489861538b886393a95efa8d", "patch": "@@ -160,7 +160,7 @@ static bool compile_time_known_address_p (Node_Id);\n static bool cannot_be_superflat_p (Node_Id);\n static bool constructor_address_p (tree);\n static void components_to_record (tree, Node_Id, tree, int, bool, bool, bool,\n-\t\t\t\t  bool, bool, bool, bool, tree, tree *);\n+\t\t\t\t  bool, bool, bool, bool, bool, tree, tree *);\n static Uint annotate_value (tree);\n static void annotate_rep (Entity_Id, tree);\n static tree build_position_list (tree, bool, tree, tree, unsigned int, tree);\n@@ -3128,7 +3128,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t/* Add the fields into the record type and finish it up.  */\n \tcomponents_to_record (gnu_type, Component_List (record_definition),\n \t\t\t      gnu_field_list, packed, definition, false,\n-\t\t\t      all_rep, is_unchecked_union, debug_info_p,\n+\t\t\t      all_rep, is_unchecked_union,\n+\t\t\t      !Comes_From_Source (gnat_entity), debug_info_p,\n \t\t\t      false, OK_To_Reorder_Components (gnat_entity),\n \t\t\t      all_rep ? NULL_TREE : bitsize_zero_node, NULL);\n \n@@ -7275,6 +7276,8 @@ compare_field_bitpos (const PTR rt1, const PTR rt2)\n    UNCHECKED_UNION is true if we are building this type for a record with a\n    Pragma Unchecked_Union.\n \n+   ARTIFICIAL is true if this is a type that was generated by the compiler.\n+\n    DEBUG_INFO is true if we need to write debug information about the type.\n \n    MAYBE_UNUSED is true if this type may be unused in the end; this doesn't\n@@ -7294,8 +7297,8 @@ static void\n components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n \t\t      tree gnu_field_list, int packed, bool definition,\n \t\t      bool cancel_alignment, bool all_rep,\n-\t\t      bool unchecked_union, bool debug_info,\n-\t\t      bool maybe_unused, bool reorder,\n+\t\t      bool unchecked_union, bool artificial,\n+\t\t      bool debug_info, bool maybe_unused, bool reorder,\n \t\t      tree first_free_pos, tree *p_gnu_rep_list)\n {\n   bool all_rep_and_size = all_rep && TYPE_SIZE (gnu_record_type);\n@@ -7464,7 +7467,8 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n \t  components_to_record (gnu_variant_type, Component_List (variant),\n \t\t\t\tNULL_TREE, packed, definition,\n \t\t\t\t!all_rep_and_size, all_rep, unchecked_union,\n-\t\t\t\tdebug_info, true, reorder, this_first_free_pos,\n+\t\t\t\ttrue, debug_info, true, reorder,\n+\t\t\t\tthis_first_free_pos,\n \t\t\t\tall_rep || this_first_free_pos\n \t\t\t\t? NULL : &gnu_rep_list);\n \n@@ -7706,7 +7710,10 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n     TYPE_ALIGN (gnu_record_type) = 0;\n \n   finish_record_type (gnu_record_type, nreverse (gnu_field_list),\n-\t\t      layout_with_rep ? 1 : 0, debug_info && !maybe_unused);\n+\t\t      layout_with_rep ? 1 : 0, false);\n+  TYPE_ARTIFICIAL (gnu_record_type) = artificial;\n+  if (debug_info && !maybe_unused)\n+    rest_of_record_type_compilation (gnu_record_type);\n }\n \f\n /* Given GNU_SIZE, a GCC tree representing a size, return a Uint to be"}, {"sha": "062df3a8f55ad9231dd42def0ea4b122f820f9ca", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd7876407c7ff2ca489861538b886393a95efa8d/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd7876407c7ff2ca489861538b886393a95efa8d/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=fd7876407c7ff2ca489861538b886393a95efa8d", "patch": "@@ -918,8 +918,6 @@ rest_of_record_type_compilation (tree record_type)\n       TYPE_SIZE_UNIT (new_record_type)\n \t= size_int (TYPE_ALIGN (record_type) / BITS_PER_UNIT);\n \n-      add_parallel_type (TYPE_STUB_DECL (record_type), new_record_type);\n-\n       /* Now scan all the fields, replacing each field with a new\n \t field corresponding to the new encoding.  */\n       for (old_field = TYPE_FIELDS (record_type); old_field;\n@@ -1058,7 +1056,12 @@ rest_of_record_type_compilation (tree record_type)\n       TYPE_FIELDS (new_record_type)\n \t= nreverse (TYPE_FIELDS (new_record_type));\n \n-      rest_of_type_decl_compilation (TYPE_STUB_DECL (new_record_type));\n+      /* We used to explicitly invoke rest_of_type_decl_compilation on the\n+\t parallel type for the sake of STABS.  We don't do it any more, so\n+\t as to ensure that the parallel type be processed after the type\n+\t by the debug back-end and, thus, prevent it from interfering with\n+\t the processing of a recursive type.  */\n+      add_parallel_type (TYPE_STUB_DECL (record_type), new_record_type);\n     }\n \n   rest_of_type_decl_compilation (TYPE_STUB_DECL (record_type));"}, {"sha": "63c46c00ea04bd5e53970055f15ad338871eba9a", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd7876407c7ff2ca489861538b886393a95efa8d/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd7876407c7ff2ca489861538b886393a95efa8d/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=fd7876407c7ff2ca489861538b886393a95efa8d", "patch": "@@ -9929,9 +9929,6 @@ modified_type_die (tree type, int is_const_type, int is_volatile_type,\n \t   useful source coordinates anyway.  */\n \tname = DECL_NAME (name);\n       add_name_attribute (mod_type_die, IDENTIFIER_POINTER (name));\n-      add_gnat_descriptive_type_attribute (mod_type_die, type, context_die);\n-      if (TYPE_ARTIFICIAL (type))\n-\tadd_AT_flag (mod_type_die, DW_AT_artificial, 1);\n     }\n   /* This probably indicates a bug.  */\n   else if (mod_type_die && mod_type_die->die_tag == DW_TAG_base_type)\n@@ -9960,6 +9957,10 @@ modified_type_die (tree type, int is_const_type, int is_volatile_type,\n   if (sub_die != NULL)\n     add_AT_die_ref (mod_type_die, DW_AT_type, sub_die);\n \n+  add_gnat_descriptive_type_attribute (mod_type_die, type, context_die);\n+  if (TYPE_ARTIFICIAL (type))\n+    add_AT_flag (mod_type_die, DW_AT_artificial, 1);\n+\n   return mod_type_die;\n }\n \n@@ -15493,11 +15494,7 @@ add_gnat_descriptive_type_attribute (dw_die_ref die, tree type,\n   dtype_die = lookup_type_die (dtype);\n   if (!dtype_die)\n     {\n-      /* The descriptive type indirectly references TYPE if this is also the\n-\t case for TYPE itself.  Do not deal with the circularity here.  */\n-      TYPE_DECL_SUPPRESS_DEBUG (TYPE_STUB_DECL (type)) = 1;\n       gen_type_die (dtype, context_die);\n-      TYPE_DECL_SUPPRESS_DEBUG (TYPE_STUB_DECL (type)) = 0;\n       dtype_die = lookup_type_die (dtype);\n       gcc_assert (dtype_die);\n     }\n@@ -16384,9 +16381,6 @@ gen_array_type_die (tree type, dw_die_ref context_die)\n \n   array_die = new_die (DW_TAG_array_type, scope_die, type);\n   add_name_attribute (array_die, type_tag (type));\n-  add_gnat_descriptive_type_attribute (array_die, type, context_die);\n-  if (TYPE_ARTIFICIAL (type))\n-    add_AT_flag (array_die, DW_AT_artificial, 1);\n   equate_type_number_to_die (type, array_die);\n \n   if (TREE_CODE (type) == VECTOR_TYPE)\n@@ -16446,6 +16440,10 @@ gen_array_type_die (tree type, dw_die_ref context_die)\n \n   add_type_attribute (array_die, element_type, 0, 0, context_die);\n \n+  add_gnat_descriptive_type_attribute (array_die, type, context_die);\n+  if (TYPE_ARTIFICIAL (type))\n+    add_AT_flag (array_die, DW_AT_artificial, 1);\n+\n   if (get_AT (array_die, DW_AT_name))\n     add_pubtype (type, array_die);\n }\n@@ -16689,9 +16687,6 @@ gen_enumeration_type_die (tree type, dw_die_ref context_die)\n \t\t\t  scope_die_for (type, context_die), type);\n       equate_type_number_to_die (type, type_die);\n       add_name_attribute (type_die, type_tag (type));\n-      add_gnat_descriptive_type_attribute (type_die, type, context_die);\n-      if (TYPE_ARTIFICIAL (type))\n-\tadd_AT_flag (type_die, DW_AT_artificial, 1);\n       if (dwarf_version >= 4 || !dwarf_strict)\n \t{\n \t  if (ENUM_IS_SCOPED (type))\n@@ -16747,6 +16742,10 @@ gen_enumeration_type_die (tree type, dw_die_ref context_die)\n \t    add_AT_int (enum_die, DW_AT_const_value,\n \t\t\ttree_low_cst (value, tree_int_cst_sgn (value) > 0));\n \t}\n+\n+      add_gnat_descriptive_type_attribute (type_die, type, context_die);\n+      if (TYPE_ARTIFICIAL (type))\n+\tadd_AT_flag (type_die, DW_AT_artificial, 1);\n     }\n   else\n     add_AT_flag (type_die, DW_AT_declaration, 1);\n@@ -18659,12 +18658,7 @@ gen_struct_or_union_type_die (tree type, dw_die_ref context_die,\n       if (old_die)\n \tadd_AT_specification (type_die, old_die);\n       else\n-\t{\n-\t  add_name_attribute (type_die, type_tag (type));\n-\t  add_gnat_descriptive_type_attribute (type_die, type, context_die);\n-\t  if (TYPE_ARTIFICIAL (type))\n-\t    add_AT_flag (type_die, DW_AT_artificial, 1);\n-\t}\n+\tadd_name_attribute (type_die, type_tag (type));\n     }\n   else\n     remove_AT (type_die, DW_AT_declaration);\n@@ -18697,6 +18691,10 @@ gen_struct_or_union_type_die (tree type, dw_die_ref context_die,\n       gen_member_die (type, type_die);\n       pop_decl_scope ();\n \n+      add_gnat_descriptive_type_attribute (type_die, type, context_die);\n+      if (TYPE_ARTIFICIAL (type))\n+\tadd_AT_flag (type_die, DW_AT_artificial, 1);\n+\n       /* GNU extension: Record what type our vtable lives in.  */\n       if (TYPE_VFIELD (type))\n \t{"}]}