{"sha": "f7695dbf402847104b2330126a3c61fae199cc1a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjc2OTVkYmY0MDI4NDcxMDRiMjMzMDEyNmEzYzYxZmFlMTk5Y2MxYQ==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2013-08-05T20:01:43Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2013-08-05T20:01:43Z"}, "message": "Handwritten part of conversion of passes to C++ classes\n\ngcc/\n\t* Makefile.in (PASS_MANAGER_H): Add dep on pass-instances.def.\n\t(toplev.o): Add dep on PASS_MANAGER_H.\n\t* cgraphunit.c (cgraph_process_new_functions): Rework invocation\n\tof early local pases to reflect this moving from a global to a\n\tmember of gcc::pass_manager.\n\t(cgraph_add_new_function): Likewise.\n\t* lto-cgraph.c (lto_output_node): Update for conversion of\n\tstruct ipa_opt_pass_d to a C++ subclass of opt_pass.\n\t* passes.c (opt_pass::clone): New.\n\t(opt_pass::gate): New.\n\t(opt_pass::execute): New.\n\t(opt_pass::opt_pass): New.\n\t(pass_manager::execute_early_local_passes): New.\n\t(pass_manager::execute_pass_mode_switching): new.\n\t(finish_optimization_passes): Convert to...\n\t(pass_manager::finish_optimization_passes): ...this.\n\t(finish_optimization_passes): Update for conversion of passes to\n\tC++ classes.\n\t(register_dump_files_1): Use has_gate since we cannot portably\n\tcheck a vtable entry against NULL.\n\t(dump_one_pass): Likewise.\n\t(ipa_write_summaries_2): Likewise.\n\t(ipa_write_optimization_summaries_1): Likewise.\n\t(ipa_read_summaries_1): Likewise.\n\t(ipa_read_optimization_summaries_1): Likewise.\n\t(execute_ipa_stmt_fixups): Likewise.\n\t(pass_manager::pass_manager): Rewrite pass-creation, invoking\n\tpass-creation functions rather than wiring up globals, and\n\tstoring the results in fields of pass_manager generated using\n\tpass-instances.def.\n\t(pass_manager::dump_profile_report): Update for conversion of\n\tpasses to C++ classes.\n\t(pass_manager::execute_ipa_summary_passes): Likewise.\n\t(execute_one_ipa_transform_pass): Likewise.\n\t(execute_one_pass): Use has_gate and has_execute since we cannot\n\tportably check a vtable entry against NULL.\n\t* pass_manager.h (pass_manager::finish_optimization_passes): New.\n\t(pass_manager): Use pass-instances.def to add fields for the\n\tvarious pass instances.\n\t* toplev.c (finalize): Update for move of\n\tfinish_optimization_passes to a method of gcc::pass_manager.\n\t* toplev.h (finish_optimization_passes): Move to method of class\n\tpass_manager.\n\t* tree-pass.h (struct pass_data): New.\n\t(opt_pass): Convert to C++ class, make it a subclass of\n\tpass_data.\n\t(opt_pass::gate): Convert to virtual function.\n\t(opt_pass::~opt_pass): New.\n\t(opt_pass::clone): New.\n\t(opt_pass::execute): Convert to virtual function.\n\t(opt_pass::opt_pass): New.\n\t(opt_pass::ctxt_): new.\n\t(gimple_opt_pass): Convert to subclass of opt_pass.\n\t(gimple_opt_pass::gimple_opt_pass): New.\n\t(rtl_opt_pass): Convert to subclass of opt_pass.\n\t(rtl_opt_pass::rtl_opt_pass): New.\n\t(ipa_opt_pass_d): Convert to subclass of opt_pass.\n\t(ipa_opt_pass_d::ipa_opt_pass_d): New.\n\t(simple_ipa_opt_pass): Convert to subclass of opt_pass.\n\t(simple_ipa_opt_pass::simple_ipa_opt_pass): New.\n\t* config/i386/i386.c (rest_of_handle_insert_vzeroupper): Rework\n\tinvocation of pass_mode_switching to reflect this moving from a\n\tglobal to a member of gcc::pass_manager.\n\t(ix86_option_override): Rework how pass_insert_vzeroupper is\n\tadded to the pass_manager to reflect autogenerated changes.\n\t* config/i386/t-i386 (i386.o) Add deps on CONTEXT_H and\n\tPASS_MANAGER_H.\n\ngcc/testsuite/\n\t* g++.dg/plugin/dumb_plugin.c (plugin_init): Rework how the pass\n\tis created and added to the pass_manager to reflect\n\tautogenerated changes.\n\t* g++.dg/plugin/selfassign.c (plugin_init): Likewise.\n\t* gcc.dg/plugin/one_time_plugin.c (plugin_init): Likewise.\n\t* gcc.dg/plugin/selfassign.c (plugin_init): Likewise.\n\nFrom-SVN: r201505", "tree": {"sha": "cdd5686bbad14a7a9b7c4e8de621c8b7b8826c56", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cdd5686bbad14a7a9b7c4e8de621c8b7b8826c56"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f7695dbf402847104b2330126a3c61fae199cc1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7695dbf402847104b2330126a3c61fae199cc1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7695dbf402847104b2330126a3c61fae199cc1a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7695dbf402847104b2330126a3c61fae199cc1a/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d0b2f8311e5e1917464aa4f65d506fbe4e580eb1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0b2f8311e5e1917464aa4f65d506fbe4e580eb1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0b2f8311e5e1917464aa4f65d506fbe4e580eb1"}], "stats": {"total": 386, "additions": 322, "deletions": 64}, "files": [{"sha": "ffa880bac65be067ef173815d117acadbafd68d7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7695dbf402847104b2330126a3c61fae199cc1a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7695dbf402847104b2330126a3c61fae199cc1a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f7695dbf402847104b2330126a3c61fae199cc1a", "patch": "@@ -1,3 +1,75 @@\n+2013-08-05  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tHandwritten part of conversion of passes to C++ classes.\n+\n+\t* Makefile.in (PASS_MANAGER_H): Add dep on pass-instances.def.\n+\t(toplev.o): Add dep on PASS_MANAGER_H.\n+\t* cgraphunit.c (cgraph_process_new_functions): Rework invocation\n+\tof early local pases to reflect this moving from a global to a\n+\tmember of gcc::pass_manager.\n+\t(cgraph_add_new_function): Likewise.\n+\t* lto-cgraph.c (lto_output_node): Update for conversion of\n+\tstruct ipa_opt_pass_d to a C++ subclass of opt_pass.\n+\t* passes.c (opt_pass::clone): New.\n+\t(opt_pass::gate): New.\n+\t(opt_pass::execute): New.\n+\t(opt_pass::opt_pass): New.\n+\t(pass_manager::execute_early_local_passes): New.\n+\t(pass_manager::execute_pass_mode_switching): new.\n+\t(finish_optimization_passes): Convert to...\n+\t(pass_manager::finish_optimization_passes): ...this.\n+\t(finish_optimization_passes): Update for conversion of passes to\n+\tC++ classes.\n+\t(register_dump_files_1): Use has_gate since we cannot portably\n+\tcheck a vtable entry against NULL.\n+\t(dump_one_pass): Likewise.\n+\t(ipa_write_summaries_2): Likewise.\n+\t(ipa_write_optimization_summaries_1): Likewise.\n+\t(ipa_read_summaries_1): Likewise.\n+\t(ipa_read_optimization_summaries_1): Likewise.\n+\t(execute_ipa_stmt_fixups): Likewise.\n+\t(pass_manager::pass_manager): Rewrite pass-creation, invoking\n+\tpass-creation functions rather than wiring up globals, and\n+\tstoring the results in fields of pass_manager generated using\n+\tpass-instances.def.\n+\t(pass_manager::dump_profile_report): Update for conversion of\n+\tpasses to C++ classes.\n+\t(pass_manager::execute_ipa_summary_passes): Likewise.\n+\t(execute_one_ipa_transform_pass): Likewise.\n+\t(execute_one_pass): Use has_gate and has_execute since we cannot\n+\tportably check a vtable entry against NULL.\n+\t* pass_manager.h (pass_manager::finish_optimization_passes): New.\n+\t(pass_manager): Use pass-instances.def to add fields for the\n+\tvarious pass instances.\n+\t* toplev.c (finalize): Update for move of\n+\tfinish_optimization_passes to a method of gcc::pass_manager.\n+\t* toplev.h (finish_optimization_passes): Move to method of class\n+\tpass_manager.\n+\t* tree-pass.h (struct pass_data): New.\n+\t(opt_pass): Convert to C++ class, make it a subclass of\n+\tpass_data.\n+\t(opt_pass::gate): Convert to virtual function.\n+\t(opt_pass::~opt_pass): New.\n+\t(opt_pass::clone): New.\n+\t(opt_pass::execute): Convert to virtual function.\n+\t(opt_pass::opt_pass): New.\n+\t(opt_pass::ctxt_): new.\n+\t(gimple_opt_pass): Convert to subclass of opt_pass.\n+\t(gimple_opt_pass::gimple_opt_pass): New.\n+\t(rtl_opt_pass): Convert to subclass of opt_pass.\n+\t(rtl_opt_pass::rtl_opt_pass): New.\n+\t(ipa_opt_pass_d): Convert to subclass of opt_pass.\n+\t(ipa_opt_pass_d::ipa_opt_pass_d): New.\n+\t(simple_ipa_opt_pass): Convert to subclass of opt_pass.\n+\t(simple_ipa_opt_pass::simple_ipa_opt_pass): New.\n+\t* config/i386/i386.c (rest_of_handle_insert_vzeroupper): Rework\n+\tinvocation of pass_mode_switching to reflect this moving from a\n+\tglobal to a member of gcc::pass_manager.\n+\t(ix86_option_override): Rework how pass_insert_vzeroupper is\n+\tadded to the pass_manager to reflect autogenerated changes.\n+\t* config/i386/t-i386 (i386.o) Add deps on CONTEXT_H and\n+\tPASS_MANAGER_H.\n+\n 2013-08-05  Richard Earnshaw  <rearnsha@arm.com>\n \n \tPR rtl-optimization/57708"}, {"sha": "afce540eed9fc9a47c79aa6dc547568ed40286b7", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7695dbf402847104b2330126a3c61fae199cc1a/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7695dbf402847104b2330126a3c61fae199cc1a/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=f7695dbf402847104b2330126a3c61fae199cc1a", "patch": "@@ -987,7 +987,7 @@ PLUGIN_VERSION_H = plugin-version.h configargs.h\n LIBFUNCS_H = libfuncs.h $(HASHTAB_H)\n GRAPHITE_HTAB_H = graphite-htab.h graphite-clast-to-gimple.h $(HASH_TABLE_H)\n CONTEXT_H = context.h\n-PASS_MANAGER_H = pass_manager.h\n+PASS_MANAGER_H = pass_manager.h pass-instances.def\n \n #\f\n # Now figure out from those variables how to compile and link.\n@@ -2733,7 +2733,7 @@ toplev.o : toplev.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(OPTS_H) params.def tree-mudflap.h $(TREE_PASS_H) $(GIMPLE_H) \\\n    tree-ssa-alias.h $(PLUGIN_H) realmpfr.h tree-diagnostic.h \\\n    $(TREE_PRETTY_PRINT_H) opts-diagnostic.h $(COMMON_TARGET_H) \\\n-   tsan.h diagnostic-color.h $(CONTEXT_H)\n+   tsan.h diagnostic-color.h $(CONTEXT_H) $(PASS_MANAGER_H)\n \n hwint.o : hwint.c $(CONFIG_H) $(SYSTEM_H) $(DIAGNOSTIC_CORE_H)\n "}, {"sha": "ad91117d6b1c7f56ada64c4e8d99a24ee0587abb", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7695dbf402847104b2330126a3c61fae199cc1a/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7695dbf402847104b2330126a3c61fae199cc1a/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=f7695dbf402847104b2330126a3c61fae199cc1a", "patch": "@@ -325,7 +325,7 @@ cgraph_process_new_functions (void)\n \t  push_cfun (DECL_STRUCT_FUNCTION (fndecl));\n \t  if (cgraph_state == CGRAPH_STATE_IPA_SSA\n \t      && !gimple_in_ssa_p (DECL_STRUCT_FUNCTION (fndecl)))\n-\t    execute_pass_list (pass_early_local_passes.pass.sub);\n+\t    g->get_passes ()->execute_early_local_passes ();\n \t  else if (inline_summary_vec != NULL)\n \t    compute_inline_parameters (node, true);\n \t  free_dominance_info (CDI_POST_DOMINATORS);\n@@ -509,7 +509,7 @@ cgraph_add_new_function (tree fndecl, bool lowered)\n \t    gimple_register_cfg_hooks ();\n \t    bitmap_obstack_initialize (NULL);\n \t    execute_pass_list (passes->all_lowering_passes);\n-\t    execute_pass_list (pass_early_local_passes.pass.sub);\n+\t    passes->execute_early_local_passes ();\n \t    bitmap_obstack_release (NULL);\n \t    pop_cfun ();\n \n@@ -534,7 +534,7 @@ cgraph_add_new_function (tree fndecl, bool lowered)\n \tgimple_register_cfg_hooks ();\n \tbitmap_obstack_initialize (NULL);\n \tif (!gimple_in_ssa_p (DECL_STRUCT_FUNCTION (fndecl)))\n-\t  execute_pass_list (pass_early_local_passes.pass.sub);\n+\t  g->get_passes ()->execute_early_local_passes ();\n \tbitmap_obstack_release (NULL);\n \tpop_cfun ();\n \texpand_function (node);"}, {"sha": "cce3c9c80e850d440079360f791e24d30bdcbba8", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7695dbf402847104b2330126a3c61fae199cc1a/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7695dbf402847104b2330126a3c61fae199cc1a/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=f7695dbf402847104b2330126a3c61fae199cc1a", "patch": "@@ -62,6 +62,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"dumpfile.h\"\n #include \"tree-pass.h\"\n #include \"tree-flow.h\"\n+#include \"context.h\"\n+#include \"pass_manager.h\"\n \n static rtx legitimize_dllimport_symbol (rtx, bool);\n static rtx legitimize_pe_coff_extern_decl (rtx, bool);\n@@ -2596,7 +2598,7 @@ rest_of_handle_insert_vzeroupper (void)\n   ix86_optimize_mode_switching[AVX_U128] = 1;\n \n   /* Call optimize_mode_switching.  */\n-  pass_mode_switching.pass.execute ();\n+  g->get_passes ()->execute_pass_mode_switching ();\n   return 0;\n }\n \n@@ -4028,8 +4030,9 @@ ix86_option_override_internal (bool main_args_p)\n static void\n ix86_option_override (void)\n {\n+  opt_pass *pass_insert_vzeroupper = make_pass_insert_vzeroupper (g);\n   static struct register_pass_info insert_vzeroupper_info\n-    = { &pass_insert_vzeroupper.pass, \"reload\",\n+    = { pass_insert_vzeroupper, \"reload\",\n \t1, PASS_POS_INSERT_AFTER\n       };\n "}, {"sha": "f10d570c8676231d49fcd91cabfd6f295a59f288", "filename": "gcc/config/i386/t-i386", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7695dbf402847104b2330126a3c61fae199cc1a/gcc%2Fconfig%2Fi386%2Ft-i386", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7695dbf402847104b2330126a3c61fae199cc1a/gcc%2Fconfig%2Fi386%2Ft-i386", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Ft-i386?ref=f7695dbf402847104b2330126a3c61fae199cc1a", "patch": "@@ -24,7 +24,7 @@ i386.o: $(CONFIG_H) $(SYSTEM_H) coretypes.h dumpfile.h $(TM_H) \\\n   $(GGC_H) $(TARGET_H) $(TARGET_DEF_H) langhooks.h $(CGRAPH_H) \\\n   $(TREE_GIMPLE_H) $(DWARF2_H) $(DF_H) tm-constrs.h $(PARAMS_H) \\\n   i386-builtin-types.inc debug.h dwarf2out.h sbitmap.h $(FIBHEAP_H) \\\n-  $(OPTS_H) $(DIAGNOSTIC_H) $(COMMON_TARGET_H)\n+  $(OPTS_H) $(DIAGNOSTIC_H) $(COMMON_TARGET_H) $(CONTEXT_H) $(PIPELINE_H)\n \n i386-c.o: $(srcdir)/config/i386/i386-c.c \\\n   $(srcdir)/config/i386/i386-protos.h $(CONFIG_H) $(SYSTEM_H) coretypes.h \\"}, {"sha": "0dde03a7b78bf74848018d34211ebb6c12e5264c", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7695dbf402847104b2330126a3c61fae199cc1a/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7695dbf402847104b2330126a3c61fae199cc1a/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=f7695dbf402847104b2330126a3c61fae199cc1a", "patch": "@@ -438,7 +438,7 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n   streamer_write_hwi_stream (ob->main_stream,\n \t\t\t     node->ipa_transforms_to_apply.length ());\n   FOR_EACH_VEC_ELT (node->ipa_transforms_to_apply, i, pass)\n-    streamer_write_hwi_stream (ob->main_stream, pass->pass.static_pass_number);\n+    streamer_write_hwi_stream (ob->main_stream, pass->static_pass_number);\n \n   if (tag == LTO_symtab_analyzed_node)\n     {"}, {"sha": "ea078a5eb66d612ff0f4146978f3c319c287f6b5", "filename": "gcc/pass_manager.h", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7695dbf402847104b2330126a3c61fae199cc1a/gcc%2Fpass_manager.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7695dbf402847104b2330126a3c61fae199cc1a/gcc%2Fpass_manager.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpass_manager.h?ref=f7695dbf402847104b2330126a3c61fae199cc1a", "patch": "@@ -58,6 +58,12 @@ class pass_manager\n \n   void dump_profile_report () const;\n \n+  void finish_optimization_passes ();\n+\n+  /* Access to specific passes, so that the majority can be private.  */\n+  void execute_early_local_passes ();\n+  unsigned int execute_pass_mode_switching ();\n+\n public:\n   /* The root of the compilation pass tree, once constructed.  */\n   opt_pass *all_passes;\n@@ -81,6 +87,37 @@ class pass_manager\n private:\n   context *ctxt_;\n \n+  /* References to all of the individual passes.\n+     These fields are generated via macro expansion.\n+\n+     For example:\n+         NEXT_PASS (pass_build_cfg, 1);\n+     within pass-instances.def means that there is a field:\n+         opt_pass *pass_build_cfg_1;\n+\n+     Similarly, the various:\n+        NEXT_PASS (pass_copy_prop, 1);\n+        ...\n+        NEXT_PASS (pass_copy_prop, 8);\n+     in pass-instances.def lead to fields:\n+        opt_pass *pass_copy_prop_1;\n+        ...\n+        opt_pass *pass_copy_prop_8;  */\n+\n+#define INSERT_PASSES_AFTER(PASS)\n+#define PUSH_INSERT_PASSES_WITHIN(PASS)\n+#define POP_INSERT_PASSES()\n+#define NEXT_PASS(PASS, NUM) opt_pass *PASS ## _ ## NUM\n+#define TERMINATE_PASS_LIST()\n+\n+#include \"pass-instances.def\"\n+\n+#undef INSERT_PASSES_AFTER\n+#undef PUSH_INSERT_PASSES_WITHIN\n+#undef POP_INSERT_PASSES\n+#undef NEXT_PASS\n+#undef TERMINATE_PASS_LIST\n+\n }; // class pass_manager\n \n } // namespace gcc"}, {"sha": "fcbd630dd8811023deb23707c8bb8d53ebe3864b", "filename": "gcc/passes.c", "status": "modified", "additions": 81, "deletions": 21, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7695dbf402847104b2330126a3c61fae199cc1a/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7695dbf402847104b2330126a3c61fae199cc1a/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=f7695dbf402847104b2330126a3c61fae199cc1a", "patch": "@@ -82,6 +82,54 @@ struct opt_pass *current_pass;\n \n static void register_pass_name (struct opt_pass *, const char *);\n \n+/* Most passes are single-instance (within their context) and thus don't\n+   need to implement cloning, but passes that support multiple instances\n+   *must* provide their own implementation of the clone method.\n+\n+   Handle this by providing a default implemenation, but make it a fatal\n+   error to call it.  */\n+\n+opt_pass *\n+opt_pass::clone ()\n+{\n+  internal_error (\"pass %s does not support cloning\", name);\n+}\n+\n+bool\n+opt_pass::gate ()\n+{\n+  return true;\n+}\n+\n+unsigned int\n+opt_pass::execute ()\n+{\n+  return 0;\n+}\n+\n+opt_pass::opt_pass(const pass_data &data, context *ctxt)\n+  : pass_data(data),\n+    sub(NULL),\n+    next(NULL),\n+    static_pass_number(0),\n+    ctxt_(ctxt)\n+{\n+}\n+\n+\n+void\n+pass_manager::execute_early_local_passes ()\n+{\n+  execute_pass_list (pass_early_local_passes_1->sub);\n+}\n+\n+unsigned int\n+pass_manager::execute_pass_mode_switching ()\n+{\n+  return pass_mode_switching_1->execute ();\n+}\n+\n+\n /* Call from anywhere to find out what pass this is.  Useful for\n    printing out debugging information deep inside an service\n    routine.  */\n@@ -224,6 +272,7 @@ rest_of_type_compilation (tree type, int toplev)\n \f\n \n void\n+pass_manager::\n finish_optimization_passes (void)\n {\n   int i;\n@@ -233,16 +282,16 @@ finish_optimization_passes (void)\n   timevar_push (TV_DUMP);\n   if (profile_arc_flag || flag_test_coverage || flag_branch_probabilities)\n     {\n-      dump_start (pass_profile.pass.static_pass_number, NULL);\n+      dump_start (pass_profile_1->static_pass_number, NULL);\n       end_branch_prob ();\n-      dump_finish (pass_profile.pass.static_pass_number);\n+      dump_finish (pass_profile_1->static_pass_number);\n     }\n \n   if (optimize > 0)\n     {\n-      dump_start (pass_profile.pass.static_pass_number, NULL);\n+      dump_start (pass_profile_1->static_pass_number, NULL);\n       print_combine_total_stats ();\n-      dump_finish (pass_profile.pass.static_pass_number);\n+      dump_finish (pass_profile_1->static_pass_number);\n     }\n \n   /* Do whatever is necessary to finish printing the graphs.  */\n@@ -550,7 +599,7 @@ register_dump_files_1 (struct opt_pass *pass, int properties)\n \n       /* If we have a gate, combine the properties that we could have with\n          and without the pass being examined.  */\n-      if (pass->gate)\n+      if (pass->has_gate)\n         properties &= new_properties;\n       else\n         properties = new_properties;\n@@ -679,7 +728,7 @@ dump_one_pass (struct opt_pass *pass, int pass_indent)\n   const char *pn;\n   bool is_on, is_really_on;\n \n-  is_on = (pass->gate == NULL) ? true : pass->gate();\n+  is_on = pass->has_gate ? pass->gate() : true;\n   is_really_on = override_gate_status (pass, current_function_decl, is_on);\n \n   if (pass->static_pass_number <= 0)\n@@ -1310,12 +1359,23 @@ pass_manager::pass_manager (context *ctxt)\n \n #define PUSH_INSERT_PASSES_WITHIN(PASS) \\\n   { \\\n-    struct opt_pass **p = &(PASS).pass.sub;\n+    struct opt_pass **p = &(PASS ## _1)->sub;\n \n #define POP_INSERT_PASSES() \\\n   }\n \n-#define NEXT_PASS(PASS, NUM)  (p = next_pass_1 (p, &((PASS).pass)))\n+#define NEXT_PASS(PASS, NUM) \\\n+  do { \\\n+    gcc_assert (NULL == PASS ## _ ## NUM); \\\n+    if ((NUM) == 1)                              \\\n+      PASS ## _1 = make_##PASS (ctxt_);          \\\n+    else                                         \\\n+      {                                          \\\n+        gcc_assert (PASS ## _1);                 \\\n+        PASS ## _ ## NUM = PASS ## _1->clone (); \\\n+      }                                          \\\n+    p = next_pass_1 (p, PASS ## _ ## NUM);  \\\n+  } while (0)\n \n #define TERMINATE_PASS_LIST() \\\n   *p = NULL;\n@@ -1541,7 +1601,7 @@ pass_manager::dump_profile_report () const\n \t\tfprintf (stderr, \"      \");\n \n \t      /* Size/time units change across gimple and RTL.  */\n-\t      if (i == pass_expand.pass.static_pass_number)\n+\t      if (i == pass_expand_1->static_pass_number)\n \t\tfprintf (stderr, \"|----------\");\n \t      else\n \t\t{\n@@ -1778,11 +1838,11 @@ execute_ipa_summary_passes (struct ipa_opt_pass_d *ipa_pass)\n {\n   while (ipa_pass)\n     {\n-      struct opt_pass *pass = &ipa_pass->pass;\n+      struct opt_pass *pass = ipa_pass;\n \n       /* Execute all of the IPA_PASSes in the list.  */\n-      if (ipa_pass->pass.type == IPA_PASS\n-\t  && (!pass->gate || pass->gate ())\n+      if (ipa_pass->type == IPA_PASS\n+\t  && ((!pass->has_gate) || pass->gate ())\n \t  && ipa_pass->generate_summary)\n \t{\n \t  pass_init_dump_file (pass);\n@@ -1799,7 +1859,7 @@ execute_ipa_summary_passes (struct ipa_opt_pass_d *ipa_pass)\n \n \t  pass_fini_dump_file (pass);\n \t}\n-      ipa_pass = (struct ipa_opt_pass_d *)ipa_pass->pass.next;\n+      ipa_pass = (struct ipa_opt_pass_d *)ipa_pass->next;\n     }\n }\n \n@@ -1809,7 +1869,7 @@ static void\n execute_one_ipa_transform_pass (struct cgraph_node *node,\n \t\t\t\tstruct ipa_opt_pass_d *ipa_pass)\n {\n-  struct opt_pass *pass = &ipa_pass->pass;\n+  struct opt_pass *pass = ipa_pass;\n   unsigned int todo_after = 0;\n \n   current_pass = pass;\n@@ -1933,7 +1993,7 @@ execute_one_pass (struct opt_pass *pass)\n \n   /* Check whether gate check should be avoided.\n      User controls the value of the gate through the parameter \"gate_status\". */\n-  gate_status = (pass->gate == NULL) ? true : pass->gate();\n+  gate_status = pass->has_gate ? pass->gate() : true;\n   gate_status = override_gate_status (pass, current_function_decl, gate_status);\n \n   /* Override gate with plugin.  */\n@@ -1990,7 +2050,7 @@ execute_one_pass (struct opt_pass *pass)\n     timevar_push (pass->tv_id);\n \n   /* Do it!  */\n-  if (pass->execute)\n+  if (pass->has_execute)\n     {\n       todo_after = pass->execute ();\n       do_per_function (clear_last_verified, NULL);\n@@ -2066,7 +2126,7 @@ ipa_write_summaries_2 (struct opt_pass *pass, struct lto_out_decl_state *state)\n       gcc_assert (pass->type == SIMPLE_IPA_PASS || pass->type == IPA_PASS);\n       if (pass->type == IPA_PASS\n \t  && ipa_pass->write_summary\n-\t  && (!pass->gate || pass->gate ()))\n+\t  && ((!pass->has_gate) || pass->gate ()))\n \t{\n \t  /* If a timevar is present, start it.  */\n \t  if (pass->tv_id)\n@@ -2182,7 +2242,7 @@ ipa_write_optimization_summaries_1 (struct opt_pass *pass, struct lto_out_decl_s\n       gcc_assert (pass->type == SIMPLE_IPA_PASS || pass->type == IPA_PASS);\n       if (pass->type == IPA_PASS\n \t  && ipa_pass->write_optimization_summary\n-\t  && (!pass->gate || pass->gate ()))\n+\t  && ((!pass->has_gate) || pass->gate ()))\n \t{\n \t  /* If a timevar is present, start it.  */\n \t  if (pass->tv_id)\n@@ -2259,7 +2319,7 @@ ipa_read_summaries_1 (struct opt_pass *pass)\n       gcc_assert (!cfun);\n       gcc_assert (pass->type == SIMPLE_IPA_PASS || pass->type == IPA_PASS);\n \n-      if (pass->gate == NULL || pass->gate ())\n+      if ((!pass->has_gate) || pass->gate ())\n \t{\n \t  if (pass->type == IPA_PASS && ipa_pass->read_summary)\n \t    {\n@@ -2310,7 +2370,7 @@ ipa_read_optimization_summaries_1 (struct opt_pass *pass)\n       gcc_assert (!cfun);\n       gcc_assert (pass->type == SIMPLE_IPA_PASS || pass->type == IPA_PASS);\n \n-      if (pass->gate == NULL || pass->gate ())\n+      if ((!pass->has_gate) || pass->gate ())\n \t{\n \t  if (pass->type == IPA_PASS && ipa_pass->read_optimization_summary)\n \t    {\n@@ -2388,7 +2448,7 @@ execute_ipa_stmt_fixups (struct opt_pass *pass,\n     {\n       /* Execute all of the IPA_PASSes in the list.  */\n       if (pass->type == IPA_PASS\n-\t  && (!pass->gate || pass->gate ()))\n+\t  && ((!pass->has_gate) || pass->gate ()))\n \t{\n \t  struct ipa_opt_pass_d *ipa_pass = (struct ipa_opt_pass_d *) pass;\n "}, {"sha": "387006e2e3d7a3d78f6c9030c71fa9ed405dd7f0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7695dbf402847104b2330126a3c61fae199cc1a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7695dbf402847104b2330126a3c61fae199cc1a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f7695dbf402847104b2330126a3c61fae199cc1a", "patch": "@@ -1,3 +1,12 @@\n+2013-08-05  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* g++.dg/plugin/dumb_plugin.c (plugin_init): Rework how the pass\n+\tis created and added to the pass_manager to reflect\n+\tautogenerated changes.\n+\t* g++.dg/plugin/selfassign.c (plugin_init): Likewise.\n+\t* gcc.dg/plugin/one_time_plugin.c (plugin_init): Likewise.\n+\t* gcc.dg/plugin/selfassign.c (plugin_init): Likewise.\n+\n 2013-08-04  Ed Smith-Rowland  <3dw4rd@verizon.net>\n \n \tPR c++/58072"}, {"sha": "ab69c14294e24a682089011a8591398071b94428", "filename": "gcc/testsuite/g++.dg/plugin/dumb_plugin.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7695dbf402847104b2330126a3c61fae199cc1a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fdumb_plugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7695dbf402847104b2330126a3c61fae199cc1a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fdumb_plugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fdumb_plugin.c?ref=f7695dbf402847104b2330126a3c61fae199cc1a", "patch": "@@ -11,6 +11,7 @@\n #include \"intl.h\"\n #include \"toplev.h\"\n #include \"diagnostic.h\"\n+#include \"context.h\"\n \n int plugin_is_GPL_compatible;\n \n@@ -124,7 +125,7 @@ plugin_init (struct plugin_name_args *plugin_info,\n       return 1;\n     }\n \n-  pass_info.pass = &pass_dumb_plugin_example.pass;\n+  pass_info.pass = make_pass_dumb_plugin_example (g);\n   pass_info.reference_pass_name = ref_pass_name;\n   pass_info.ref_pass_instance_number = ref_instance_number;\n   pass_info.pos_op = PASS_POS_INSERT_AFTER;"}, {"sha": "3e0b38ec3413cf8d20085965f6cec2deaee3ed6a", "filename": "gcc/testsuite/g++.dg/plugin/selfassign.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7695dbf402847104b2330126a3c61fae199cc1a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fselfassign.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7695dbf402847104b2330126a3c61fae199cc1a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fselfassign.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fselfassign.c?ref=f7695dbf402847104b2330126a3c61fae199cc1a", "patch": "@@ -15,6 +15,7 @@\n #include \"intl.h\"\n #include \"plugin-version.h\"\n #include \"diagnostic.h\"\n+#include \"context.h\"\n \n int plugin_is_GPL_compatible;\n \n@@ -309,7 +310,7 @@ plugin_init (struct plugin_name_args *plugin_info,\n     return 1;\n \n   /* Self-assign detection should happen after SSA is constructed.  */\n-  pass_info.pass = &pass_warn_self_assign.pass;\n+  pass_info.pass = make_pass_warn_self_assign (g);\n   pass_info.reference_pass_name = \"ssa\";\n   pass_info.ref_pass_instance_number = 1;\n   pass_info.pos_op = PASS_POS_INSERT_AFTER;"}, {"sha": "31dfe69b1fbe9b915522a2fab7a3f90cfa3144a0", "filename": "gcc/testsuite/gcc.dg/plugin/one_time_plugin.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7695dbf402847104b2330126a3c61fae199cc1a/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fone_time_plugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7695dbf402847104b2330126a3c61fae199cc1a/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fone_time_plugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fone_time_plugin.c?ref=f7695dbf402847104b2330126a3c61fae199cc1a", "patch": "@@ -8,6 +8,7 @@\n #include \"gimple.h\"\n #include \"tree-pass.h\"\n #include \"intl.h\"\n+#include \"context.h\"\n \n int plugin_is_GPL_compatible;\n \n@@ -53,7 +54,7 @@ int plugin_init (struct plugin_name_args *plugin_info,\n {\n   struct register_pass_info p;\n \n-  p.pass = &one_pass.pass;\n+  p.pass = make_one_pass (g);\n   p.reference_pass_name = \"cfg\";\n   p.ref_pass_instance_number = 1;\n   p.pos_op = PASS_POS_INSERT_AFTER;"}, {"sha": "3e0b38ec3413cf8d20085965f6cec2deaee3ed6a", "filename": "gcc/testsuite/gcc.dg/plugin/selfassign.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7695dbf402847104b2330126a3c61fae199cc1a/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fselfassign.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7695dbf402847104b2330126a3c61fae199cc1a/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fselfassign.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fselfassign.c?ref=f7695dbf402847104b2330126a3c61fae199cc1a", "patch": "@@ -15,6 +15,7 @@\n #include \"intl.h\"\n #include \"plugin-version.h\"\n #include \"diagnostic.h\"\n+#include \"context.h\"\n \n int plugin_is_GPL_compatible;\n \n@@ -309,7 +310,7 @@ plugin_init (struct plugin_name_args *plugin_info,\n     return 1;\n \n   /* Self-assign detection should happen after SSA is constructed.  */\n-  pass_info.pass = &pass_warn_self_assign.pass;\n+  pass_info.pass = make_pass_warn_self_assign (g);\n   pass_info.reference_pass_name = \"ssa\";\n   pass_info.ref_pass_instance_number = 1;\n   pass_info.pos_op = PASS_POS_INSERT_AFTER;"}, {"sha": "53f53fd95df93352a725eca6be4936455d67aba9", "filename": "gcc/toplev.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7695dbf402847104b2330126a3c61fae199cc1a/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7695dbf402847104b2330126a3c61fae199cc1a/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=f7695dbf402847104b2330126a3c61fae199cc1a", "patch": "@@ -76,6 +76,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"plugin.h\"\n #include \"diagnostic-color.h\"\n #include \"context.h\"\n+#include \"pass_manager.h\"\n \n #if defined(DBX_DEBUGGING_INFO) || defined(XCOFF_DEBUGGING_INFO)\n #include \"dbxout.h\"\n@@ -1818,7 +1819,7 @@ finalize (bool no_backend)\n     {\n       statistics_fini ();\n \n-      finish_optimization_passes ();\n+      g->get_passes ()->finish_optimization_passes ();\n \n       ira_finish_once ();\n     }"}, {"sha": "84ffdb0e28b5ad243b8d03616ef3a8e91f46846f", "filename": "gcc/toplev.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7695dbf402847104b2330126a3c61fae199cc1a/gcc%2Ftoplev.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7695dbf402847104b2330126a3c61fae199cc1a/gcc%2Ftoplev.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.h?ref=f7695dbf402847104b2330126a3c61fae199cc1a", "patch": "@@ -28,7 +28,6 @@ extern int toplev_main (int, char **);\n extern void rest_of_decl_compilation (tree, int, int);\n extern void rest_of_type_compilation (tree, int);\n extern void init_optimization_passes (void);\n-extern void finish_optimization_passes (void);\n extern bool enable_rtl_dump_file (void);\n \n /* In except.c.  Initialize exception handling.  This is used by the Ada"}, {"sha": "41f7d176c40ee60a981e392ea7a85ff034615cda", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 101, "deletions": 28, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7695dbf402847104b2330126a3c61fae199cc1a/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7695dbf402847104b2330126a3c61fae199cc1a/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=f7695dbf402847104b2330126a3c61fae199cc1a", "patch": "@@ -34,9 +34,8 @@ enum opt_pass_type\n   IPA_PASS\n };\n \n-/* Describe one pass; this is the common part shared across different pass\n-   types.  */\n-struct opt_pass\n+/* Metadata for a pass, non-varying across all instances of a pass.  */\n+struct pass_data\n {\n   /* Optimization pass type.  */\n   enum opt_pass_type type;\n@@ -48,23 +47,13 @@ struct opt_pass\n   /* The -fopt-info optimization group flags as defined in dumpfile.h. */\n   unsigned int optinfo_flags;\n \n-  /* If non-null, this pass and all sub-passes are executed only if\n-     the function returns true.  */\n-  bool (*gate) (void);\n+  /* If true, this pass has its own implementation of the opt_pass::gate\n+     method.  */\n+  bool has_gate;\n \n-  /* This is the code to run.  If null, then there should be sub-passes\n-     otherwise this pass does nothing.  The return value contains\n-     TODOs to execute in addition to those in TODO_flags_finish.   */\n-  unsigned int (*execute) (void);\n-\n-  /* A list of sub-passes to run, dependent on gate predicate.  */\n-  struct opt_pass *sub;\n-\n-  /* Next in the list of passes to run, independent of gate predicate.  */\n-  struct opt_pass *next;\n-\n-  /* Static pass number, used as a fragment of the dump file name.  */\n-  int static_pass_number;\n+  /* If true, this pass has its own implementation of the opt_pass::execute\n+     method.  */\n+  bool has_execute;\n \n   /* The timevar id associated with this pass.  */\n   /* ??? Ideally would be dynamically assigned.  */\n@@ -80,16 +69,72 @@ struct opt_pass\n   unsigned int todo_flags_finish;\n };\n \n+namespace gcc\n+{\n+  class context;\n+} // namespace gcc\n+\n+/* An instance of a pass.  This is also \"pass_data\" to minimize the\n+   changes in existing code.  */\n+class opt_pass : public pass_data\n+{\n+public:\n+  virtual ~opt_pass () { }\n+\n+  /* Create a copy of this pass.\n+\n+     Passes that can have multiple instances must provide their own\n+     implementation of this, to ensure that any sharing of state between\n+     this instance and the copy is \"wired up\" correctly.\n+\n+     The default implementation prints an error message and aborts.  */\n+  virtual opt_pass *clone ();\n+\n+  /* If has_gate is set, this pass and all sub-passes are executed only if\n+     the function returns true.  */\n+  virtual bool gate ();\n+\n+  /* This is the code to run.  If has_execute is false, then there should\n+     be sub-passes otherwise this pass does nothing.\n+     The return value contains TODOs to execute in addition to those in\n+     TODO_flags_finish.   */\n+  virtual unsigned int execute ();\n+\n+protected:\n+  opt_pass(const pass_data&, gcc::context *);\n+\n+public:\n+  /* A list of sub-passes to run, dependent on gate predicate.  */\n+  struct opt_pass *sub;\n+\n+  /* Next in the list of passes to run, independent of gate predicate.  */\n+  struct opt_pass *next;\n+\n+  /* Static pass number, used as a fragment of the dump file name.  */\n+  int static_pass_number;\n+\n+protected:\n+  gcc::context *ctxt_;\n+};\n+\n /* Description of GIMPLE pass.  */\n-struct gimple_opt_pass\n+class gimple_opt_pass : public opt_pass\n {\n-  struct opt_pass pass;\n+protected:\n+  gimple_opt_pass(const pass_data& data, gcc::context *ctxt)\n+    : opt_pass(data, ctxt)\n+  {\n+  }\n };\n \n /* Description of RTL pass.  */\n-struct rtl_opt_pass\n+class rtl_opt_pass : public opt_pass\n {\n-  struct opt_pass pass;\n+protected:\n+  rtl_opt_pass(const pass_data& data, gcc::context *ctxt)\n+    : opt_pass(data, ctxt)\n+  {\n+  }\n };\n \n struct varpool_node;\n@@ -98,10 +143,9 @@ struct lto_symtab_encoder_d;\n \n /* Description of IPA pass with generate summary, write, execute, read and\n    transform stages.  */\n-struct ipa_opt_pass_d\n+class ipa_opt_pass_d : public opt_pass\n {\n-  struct opt_pass pass;\n-\n+public:\n   /* IPA passes can analyze function body and variable initializers\n       using this hook and produce summary.  */\n   void (*generate_summary) (void);\n@@ -127,13 +171,42 @@ struct ipa_opt_pass_d\n   unsigned int function_transform_todo_flags_start;\n   unsigned int (*function_transform) (struct cgraph_node *);\n   void (*variable_transform) (struct varpool_node *);\n+\n+protected:\n+  ipa_opt_pass_d(const pass_data& data, gcc::context *ctxt,\n+                 void (*generate_summary) (void),\n+                 void (*write_summary) (void),\n+                 void (*read_summary) (void),\n+                 void (*write_optimization_summary) (void),\n+                 void (*read_optimization_summary) (void),\n+                 void (*stmt_fixup) (struct cgraph_node *, gimple *),\n+                 unsigned int function_transform_todo_flags_start,\n+                 unsigned int (*function_transform) (struct cgraph_node *),\n+                 void (*variable_transform) (struct varpool_node *))\n+    : opt_pass(data, ctxt),\n+\t       generate_summary(generate_summary),\n+\t       write_summary(write_summary),\n+\t       read_summary(read_summary),\n+\t       write_optimization_summary(write_optimization_summary),\n+\t       read_optimization_summary(read_optimization_summary),\n+\t       stmt_fixup(stmt_fixup),\n+\t       function_transform_todo_flags_start(\n+\t         function_transform_todo_flags_start),\n+\t       function_transform(function_transform),\n+\t       variable_transform(variable_transform)\n+  {\n+  }\n };\n \n /* Description of simple IPA pass.  Simple IPA passes have just one execute\n    hook.  */\n-struct simple_ipa_opt_pass\n+class simple_ipa_opt_pass : public opt_pass\n {\n-  struct opt_pass pass;\n+protected:\n+  simple_ipa_opt_pass(const pass_data& data, gcc::context *ctxt)\n+    : opt_pass(data, ctxt)\n+  {\n+  }\n };\n \n /* Pass properties.  */"}]}