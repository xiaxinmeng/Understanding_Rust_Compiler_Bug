{"sha": "b4c811bd14e0b3ea5a995b711aae60ee1d3daaab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjRjODExYmQxNGUwYjNlYTVhOTk1YjcxMWFhZTYwZWUxZDNkYWFhYg==", "commit": {"author": {"name": "Thomas Koenig", "email": "Thomas.Koenig@online.de", "date": "2006-12-06T19:25:44Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2006-12-06T19:25:44Z"}, "message": "re PR libfortran/30009 ([4.1 only] Unformatted reads exceeding storage units gives EOF instead of ERR)\n\n2006-12-06  Thomas Koenig  <Thomas.Koenig@online.de>\n\n\tPR libfortran/30009\n\tPR libfortran/30056\n\t* gfortran.dg/read_eof_4.f90:  Add tests.\n\t* gfortran.dg/readwrite_unf_direct_eor_1.f90:  New test.\n\t* gfortran.dg/unf_read_corrupted_1.f90: New test.\n\n2006-12-06  Thomas Koenig  <Thomas.Koenig@online.de>\n\n\tPR libfortran/30009\n\tPR libfortran/30056\n\t* libgfortran.h:  Add ERROR_CORRUPT_FILE to error_codes.\n\t* runtime/error.c (translate_error):  Add handling for\n\tERROR_CORRUPT_FILE.\n\t* io/transfer.c (read_block_direct):  Add comment about\n\tEOR for stream files.\n\tRemove test for no bytes left for direct access files.\n\tGenerate an ERROR_SHORT_RECORD if the read was short.\n\tFor unformatted sequential files:  Check endfile condition.\n\tRemove test for no bytes left.  End of file here means\n\tthat the file structure has been corrupted.  Pre-position\n\tthe file for the next record in case of error.\n\t(write_buf):  Whitespace fix.  Subtract the number of bytes\n\twritten from bytes_left.\n\nFrom-SVN: r119592", "tree": {"sha": "ca8a396e07dee2ad42be8eab7d5520d8281b63b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ca8a396e07dee2ad42be8eab7d5520d8281b63b1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b4c811bd14e0b3ea5a995b711aae60ee1d3daaab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4c811bd14e0b3ea5a995b711aae60ee1d3daaab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4c811bd14e0b3ea5a995b711aae60ee1d3daaab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4c811bd14e0b3ea5a995b711aae60ee1d3daaab/comments", "author": null, "committer": null, "parents": [{"sha": "0307c64eea66674bd3dd9a42fed80cf748e2acf8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0307c64eea66674bd3dd9a42fed80cf748e2acf8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0307c64eea66674bd3dd9a42fed80cf748e2acf8"}], "stats": {"total": 157, "additions": 118, "deletions": 39}, "files": [{"sha": "58837bc40ac72b2bc526d8666b1d30906a634e4b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c811bd14e0b3ea5a995b711aae60ee1d3daaab/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c811bd14e0b3ea5a995b711aae60ee1d3daaab/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b4c811bd14e0b3ea5a995b711aae60ee1d3daaab", "patch": "@@ -1,3 +1,11 @@\n+2006-12-06  Thomas Koenig  <Thomas.Koenig@online.de>\n+\n+\tPR libfortran/30009\n+\tPR libfortran/30056\n+\t* gfortran.dg/read_eof_4.f90:  Add tests.\n+\t* gfortran.dg/readwrite_unf_direct_eor_1.f90:  New test.\n+\t* gfortran.dg/unf_read_corrupted_1.f90: New test.\n+\n 2006-12-05  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/29729"}, {"sha": "ee95268d50dc13a857f44b4bb94ebb99cbcf8a3c", "filename": "gcc/testsuite/gfortran.dg/read_eof_4.f90", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c811bd14e0b3ea5a995b711aae60ee1d3daaab/gcc%2Ftestsuite%2Fgfortran.dg%2Fread_eof_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c811bd14e0b3ea5a995b711aae60ee1d3daaab/gcc%2Ftestsuite%2Fgfortran.dg%2Fread_eof_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fread_eof_4.f90?ref=b4c811bd14e0b3ea5a995b711aae60ee1d3daaab", "patch": "@@ -1,16 +1,30 @@\n ! { dg-do run }\n-! PR 27575 : This test checks the error checking for end of file condition.\n+! PR 27575 and PR 30009: This test checks the error checking for end\n+! of file condition.\n ! Derived from test case in PR.\n-! Submitted by Jerry DeLisle <jvdelisle@verizon.net>.\n+! Submitted by Jerry DeLisle <jvdelisle@verizon.net>, modified by\n+! Thomas Koenig <Thomas.Koenig@online.de>\n+\n       program test\n       integer i1,i2,i3\n       open(unit=11,form='unformatted')\n-      write(11)i1, i2     \n+      write (11) 1, 2\n+      write (11) 3, 4\n       close(11,status='keep')\n+\n       open(unit=11,form='unformatted')\n-      read(11, eND=100) i1, i2, i3\n+\n+      read(11, ERR=100) i1, i2, i3\n       call abort()\n- 100  read(11, end=110) i3\n-      call abort() \n- 110  close(11,status='delete')\n+  100 continue\n+      if (i1 /= 1 .or. i2 /= 2) call abort\n+\n+      read(11, ERR=110) i1, i2, i3\n+      call abort()\n+  110 continue\n+      if (i1 /= 3 .or. i2 /= 4) call abort\n+\n+      read(11, end=120) i3\n+      call abort()\n+ 120  close(11,status='delete')\n       end"}, {"sha": "2c19eba39276f98e32520a989c1798dd207719a8", "filename": "gcc/testsuite/gfortran.dg/readwrite_unf_direct_eor_1.f90", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c811bd14e0b3ea5a995b711aae60ee1d3daaab/gcc%2Ftestsuite%2Fgfortran.dg%2Freadwrite_unf_direct_eor_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c811bd14e0b3ea5a995b711aae60ee1d3daaab/gcc%2Ftestsuite%2Fgfortran.dg%2Freadwrite_unf_direct_eor_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Freadwrite_unf_direct_eor_1.f90?ref=b4c811bd14e0b3ea5a995b711aae60ee1d3daaab", "patch": "@@ -0,0 +1,13 @@\n+! { dg-do run }\n+! PR 30056 - exceeding the record length was misrepresented as an EOF\n+!            on read and ignored on write \n+      program main\n+      integer i,j\n+      open (10, form=\"unformatted\", access=\"direct\", recl=4)\n+      write (10, rec=1, err=10) 1,2\n+      call abort()\n+ 10   continue\n+      read (10,  rec=1, err=20) i, j\n+      call abort()\n+ 20   continue\n+      end"}, {"sha": "166d52915306da0f6537782663d4ada0ec0d6da9", "filename": "gcc/testsuite/gfortran.dg/unf_read_corrupted_1.f90", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c811bd14e0b3ea5a995b711aae60ee1d3daaab/gcc%2Ftestsuite%2Fgfortran.dg%2Funf_read_corrupted_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c811bd14e0b3ea5a995b711aae60ee1d3daaab/gcc%2Ftestsuite%2Fgfortran.dg%2Funf_read_corrupted_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Funf_read_corrupted_1.f90?ref=b4c811bd14e0b3ea5a995b711aae60ee1d3daaab", "patch": "@@ -0,0 +1,27 @@\n+! { dg-do run }\n+! Test the error message when an unformatted file has become\n+! corrupted.\n+program main\n+  implicit none\n+  integer :: i1, i2\n+  integer :: ios\n+  character(len=50) :: msg\n+\n+  ! Write out a truncated unformatted sequential file by\n+  ! using unformatted stream.\n+\n+  open (10, form=\"unformatted\", access=\"stream\", file=\"foo.dat\", &\n+  status=\"unknown\")\n+  write (10) 16, 1\n+  close (10, status=\"keep\")\n+\n+  ! Try to read\n+  open (10, file=\"foo.dat\", form=\"unformatted\", access=\"sequential\")\n+  i1 = 0\n+  i2 = 0\n+  read (10, iostat=ios, iomsg=msg) i1, i2\n+  if (ios == 0) call abort\n+  if (i1 /= 1) call abort\n+  if (msg /= \"Unformatted file structure has been corrupted\") call abort\n+  close (10, status=\"delete\")\n+end program main"}, {"sha": "eca621b172e075a974c96ffd9db7c8a1f236978f", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c811bd14e0b3ea5a995b711aae60ee1d3daaab/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c811bd14e0b3ea5a995b711aae60ee1d3daaab/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=b4c811bd14e0b3ea5a995b711aae60ee1d3daaab", "patch": "@@ -1,3 +1,21 @@\n+2006-12-06  Thomas Koenig  <Thomas.Koenig@online.de>\n+\n+\tPR libfortran/30009\n+\tPR libfortran/30056\n+\t* libgfortran.h:  Add ERROR_CORRUPT_FILE to error_codes.\n+\t* runtime/error.c (translate_error):  Add handling for\n+\tERROR_CORRUPT_FILE.\n+\t* io/transfer.c (read_block_direct):  Add comment about\n+\tEOR for stream files.\n+\tRemove test for no bytes left for direct access files.\n+\tGenerate an ERROR_SHORT_RECORD if the read was short.\n+\tFor unformatted sequential files:  Check endfile condition.\n+\tRemove test for no bytes left.  End of file here means\n+\tthat the file structure has been corrupted.  Pre-position\n+\tthe file for the next record in case of error.\n+\t(write_buf):  Whitespace fix.  Subtract the number of bytes\n+\twritten from bytes_left.\n+\n 2006-12-04  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libfortran/30005"}, {"sha": "163557d49b3a5f8fc61a79df7dfa0c1ad8923638", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 26, "deletions": 32, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c811bd14e0b3ea5a995b711aae60ee1d3daaab/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c811bd14e0b3ea5a995b711aae60ee1d3daaab/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=b4c811bd14e0b3ea5a995b711aae60ee1d3daaab", "patch": "@@ -374,7 +374,8 @@ read_block_direct (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n \n       if (to_read_record != have_read_record)\n \t{\n-\t  /* Short read,  e.g. if we hit EOF.  */\n+\t  /* Short read,  e.g. if we hit EOF.  For stream files,\n+\t   we have to set the end-of-file condition.  */\n \t  generate_error (&dtp->common, ERROR_END, NULL);\n \t  return;\n \t}\n@@ -388,13 +389,6 @@ read_block_direct (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n \t  short_record = 1;\n \t  to_read_record = (size_t) dtp->u.p.current_unit->bytes_left;\n \t  *nbytes = to_read_record;\n-\n-\t  if (dtp->u.p.current_unit->bytes_left == 0)\n-\t    {\n-\t      dtp->u.p.current_unit->endfile = AT_ENDFILE;\n-\t      generate_error (&dtp->common, ERROR_END, NULL);\n-\t      return;\n-\t    }\n \t}\n \n       else\n@@ -411,10 +405,12 @@ read_block_direct (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n \t  return;\n \t}\n \n-      if (to_read_record != *nbytes)  /* Short read, e.g. if we hit EOF.  */\n+      if (to_read_record != *nbytes)  \n \t{\n+\t  /* Short read, e.g. if we hit EOF.  Apparently, we read\n+\t   more than was written to the last record.  */\n \t  *nbytes = to_read_record;\n-\t  generate_error (&dtp->common, ERROR_END, NULL);\n+\t  generate_error (&dtp->common, ERROR_SHORT_RECORD, NULL);\n \t  return;\n \t}\n \n@@ -430,6 +426,12 @@ read_block_direct (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n      until the request has been fulfilled or the record has run out\n      of continuation subrecords.  */\n \n+  if (dtp->u.p.current_unit->endfile == AT_ENDFILE)\n+    {\n+      generate_error (&dtp->common, ERROR_END, NULL);\n+      return;\n+    }\n+\n   /* Check whether we exceed the total record length.  */\n \n   if (dtp->u.p.current_unit->flags.has_recl)\n@@ -453,25 +455,7 @@ read_block_direct (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n \t{\n \t  to_read_subrecord = (size_t) dtp->u.p.current_unit->bytes_left_subrecord;\n \t  to_read_record -= to_read_subrecord;\n-\n-\t  if (dtp->u.p.current_unit->bytes_left_subrecord == 0)\n-\t    {\n-\t      if (dtp->u.p.current_unit->continued)\n-\t\t{\n-\t\t  /* Skip to the next subrecord */\n-\t\t  next_record_r_unf (dtp, 0);\n-\t\t  us_read (dtp, 1);\n-\t\t  continue;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  dtp->u.p.current_unit->endfile = AT_ENDFILE;\n-\t\t  generate_error (&dtp->common, ERROR_END, NULL);\n-\t\t  return;\n-\t\t}\n-\t    }\n \t}\n-\n       else\n \t{\n \t  to_read_subrecord = to_read_record;\n@@ -490,11 +474,15 @@ read_block_direct (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n \n       have_read_record += have_read_subrecord;\n \n-      if (to_read_subrecord != have_read_subrecord)  /* Short read,\n-\t\t\t\t\t\t\te.g. if we hit EOF.  */\n+      if (to_read_subrecord != have_read_subrecord)  \n+\t\t\t\n \t{\n+\t  /* Short read, e.g. if we hit EOF.  This means the record\n+\t     structure has been corrupted, or the trailing record\n+\t     marker would still be present.  */\n+\n \t  *nbytes = have_read_record;\n-\t  generate_error (&dtp->common, ERROR_END, NULL);\n+\t  generate_error (&dtp->common, ERROR_CORRUPT_FILE, NULL);\n \t  return;\n \t}\n \n@@ -507,6 +495,11 @@ read_block_direct (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n \t    }\n \t  else\n \t    {\n+\t      /* Let's make sure the file position is correctly set for the\n+\t\t next read statement.  */\n+\n+\t      next_record_r_unf (dtp, 0);\n+\t      us_read (dtp, 0);\n \t      generate_error (&dtp->common, ERROR_SHORT_RECORD, NULL);\n \t      return;\n \t    }\n@@ -637,7 +630,8 @@ write_buf (st_parameter_dt *dtp, void *buf, size_t nbytes)\n \t  return FAILURE;\n \t}\n \n-      dtp->u.p.current_unit->strm_pos += (gfc_offset) nbytes; \n+      dtp->u.p.current_unit->strm_pos += (gfc_offset) nbytes;\n+      dtp->u.p.current_unit->bytes_left -= (gfc_offset) nbytes;\n \n       return SUCCESS;\n "}, {"sha": "c6b31ed908a8ff0358381a284a7ab84615fea608", "filename": "libgfortran/libgfortran.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c811bd14e0b3ea5a995b711aae60ee1d3daaab/libgfortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c811bd14e0b3ea5a995b711aae60ee1d3daaab/libgfortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Flibgfortran.h?ref=b4c811bd14e0b3ea5a995b711aae60ee1d3daaab", "patch": "@@ -416,6 +416,7 @@ typedef enum\n   ERROR_ALLOCATION,\n   ERROR_DIRECT_EOR,\n   ERROR_SHORT_RECORD,\n+  ERROR_CORRUPT_FILE,\n   ERROR_LAST\t\t\t/* Not a real error, the last error # + 1.  */\n }\n error_codes;"}, {"sha": "35955644ba5fab94593bd7edb242a41ccdce885c", "filename": "libgfortran/runtime/error.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c811bd14e0b3ea5a995b711aae60ee1d3daaab/libgfortran%2Fruntime%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c811bd14e0b3ea5a995b711aae60ee1d3daaab/libgfortran%2Fruntime%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Ferror.c?ref=b4c811bd14e0b3ea5a995b711aae60ee1d3daaab", "patch": "@@ -440,6 +440,10 @@ translate_error (int code)\n       p = \"I/O past end of record on unformatted file\";\n       break;\n \n+    case ERROR_CORRUPT_FILE:\n+      p = \"Unformatted file structure has been corrupted\";\n+      break;\n+\n     default:\n       p = \"Unknown error code\";\n       break;"}]}