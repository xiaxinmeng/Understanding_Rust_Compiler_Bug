{"sha": "df4e0359dad239854af0ea9eacb8e7e3719557d0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGY0ZTAzNTlkYWQyMzk4NTRhZjBlYTllYWNiOGU3ZTM3MTk1NTdkMA==", "commit": {"author": {"name": "Peter Bergner", "email": "bergner@linux.ibm.com", "date": "2021-05-31T03:45:55Z"}, "committer": {"name": "Peter Bergner", "email": "bergner@linux.ibm.com", "date": "2021-05-31T03:45:55Z"}, "message": "rs6000: MMA test case ICEs using -O3 [PR99842]\n\nThe mma_assemble_input_operand predicate does not accept reg+reg indexed\naddresses which can lead to ICEs.  The lxv and lxvp instructions have\nindexed forms (lxvx and lxvpx), so the simple solution is to just allow\nindexed addresses in the predicate.\n\n2021-05-30  Peter Bergner  <bergner@linux.ibm.com>\n\ngcc/\n\tPR target/99842\n\t* config/rs6000/predicates.md(mma_assemble_input_operand): Allow\n\tindexed form addresses.\n\ngcc/testsuite/\n\tPR target/99842\n\t* g++.target/powerpc/pr99842.C: New.", "tree": {"sha": "de3db3ab7597e286cded4a705b508dec7eee892e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/de3db3ab7597e286cded4a705b508dec7eee892e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/df4e0359dad239854af0ea9eacb8e7e3719557d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df4e0359dad239854af0ea9eacb8e7e3719557d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df4e0359dad239854af0ea9eacb8e7e3719557d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df4e0359dad239854af0ea9eacb8e7e3719557d0/comments", "author": {"login": "peter-bergner", "id": 17504345, "node_id": "MDQ6VXNlcjE3NTA0MzQ1", "avatar_url": "https://avatars.githubusercontent.com/u/17504345?v=4", "gravatar_id": "", "url": "https://api.github.com/users/peter-bergner", "html_url": "https://github.com/peter-bergner", "followers_url": "https://api.github.com/users/peter-bergner/followers", "following_url": "https://api.github.com/users/peter-bergner/following{/other_user}", "gists_url": "https://api.github.com/users/peter-bergner/gists{/gist_id}", "starred_url": "https://api.github.com/users/peter-bergner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/peter-bergner/subscriptions", "organizations_url": "https://api.github.com/users/peter-bergner/orgs", "repos_url": "https://api.github.com/users/peter-bergner/repos", "events_url": "https://api.github.com/users/peter-bergner/events{/privacy}", "received_events_url": "https://api.github.com/users/peter-bergner/received_events", "type": "User", "site_admin": false}, "committer": {"login": "peter-bergner", "id": 17504345, "node_id": "MDQ6VXNlcjE3NTA0MzQ1", "avatar_url": "https://avatars.githubusercontent.com/u/17504345?v=4", "gravatar_id": "", "url": "https://api.github.com/users/peter-bergner", "html_url": "https://github.com/peter-bergner", "followers_url": "https://api.github.com/users/peter-bergner/followers", "following_url": "https://api.github.com/users/peter-bergner/following{/other_user}", "gists_url": "https://api.github.com/users/peter-bergner/gists{/gist_id}", "starred_url": "https://api.github.com/users/peter-bergner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/peter-bergner/subscriptions", "organizations_url": "https://api.github.com/users/peter-bergner/orgs", "repos_url": "https://api.github.com/users/peter-bergner/repos", "events_url": "https://api.github.com/users/peter-bergner/events{/privacy}", "received_events_url": "https://api.github.com/users/peter-bergner/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e21e93407202e62a10c372595076c593c561bb11", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e21e93407202e62a10c372595076c593c561bb11", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e21e93407202e62a10c372595076c593c561bb11"}], "stats": {"total": 191, "additions": 190, "deletions": 1}, "files": [{"sha": "121cbf14810e247ece3de35c03d175f6853b9200", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4e0359dad239854af0ea9eacb8e7e3719557d0/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4e0359dad239854af0ea9eacb8e7e3719557d0/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=df4e0359dad239854af0ea9eacb8e7e3719557d0", "patch": "@@ -1172,7 +1172,8 @@\n   (match_test \"(mode == V16QImode\n \t\t&& (vsx_register_operand (op, mode)\n \t\t    || (MEM_P (op)\n-\t\t\t&& quad_address_p (XEXP (op, 0), mode, false))))\"))\n+\t\t\t&& (indexed_or_indirect_address (XEXP (op, 0), mode)\n+\t\t\t    || quad_address_p (XEXP (op, 0), mode, false)))))\"))\n \n ;; Return 1 if this operand is valid for an MMA disassemble insn.\n (define_predicate \"mma_disassemble_output_operand\""}, {"sha": "922450e2c2144301c72a38ece1ce1c94425cbc96", "filename": "gcc/testsuite/g++.target/powerpc/pr99842.C", "status": "added", "additions": 188, "deletions": 0, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4e0359dad239854af0ea9eacb8e7e3719557d0/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fpowerpc%2Fpr99842.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4e0359dad239854af0ea9eacb8e7e3719557d0/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fpowerpc%2Fpr99842.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fpowerpc%2Fpr99842.C?ref=df4e0359dad239854af0ea9eacb8e7e3719557d0", "patch": "@@ -0,0 +1,188 @@\n+/* PR target/99842 */\n+/* { dg-require-effective-target power10_ok } */\n+/* { dg-options \"-O3 -mdejagnu-cpu=power10 -Wno-return-type\" } */\n+\n+/* Verify we do not ICE on the following noisy creduced test case.  */\n+\n+enum { a, b, c, d };\n+template <typename> struct e;\n+template <typename g, typename h, typename k> struct e<g(h, k)> {\n+  typedef h f;\n+};\n+template <typename> struct ac;\n+template <typename ab> struct ac<const ab> : ac<ab> {};\n+template <typename> struct l;\n+template <typename, int, int m, int = 0, int = a, int = m> class n;\n+template <typename> class o;\n+template <typename, typename, typename> class ag;\n+template <typename, typename, int = c> class af;\n+template <typename> struct ad;\n+template <typename ab> struct an {\n+  typedef n<typename ab ::ah, ac<ab>::ai, ac<ab>::aj> f;\n+};\n+template <typename al> struct am { typedef o<al> f; };\n+template <typename al, typename = typename ac<al>::ao,\n+          typename = typename ac<al>::av>\n+struct ak;\n+template <typename al, typename ao> struct ak<al, ao, int> {\n+  typedef typename am<al>::f f;\n+};\n+template <typename, typename, typename> struct aq;\n+template <typename ar, typename as> struct aq<ar, ar, as> { typedef ar at; };\n+template <typename ap> ap bf(const typename ad<ap>::f *);\n+template <typename ap, int> ap aw(typename ad<ap>::f *ax) { return bf<ap>(ax); }\n+typedef __attribute__((altivec(vector__))) double au;\n+template <> struct ad<au> { typedef double f; };\n+template <> au bf(const double *ax) { return __builtin_vec_vsx_ld(0, ax); }\n+template <typename> struct az {};\n+template <typename al> class o : public l<al> {\n+public:\n+  typedef typename ac<al>::ah ah;\n+  template <typename ay> al &operator+=(const o<ay> &);\n+};\n+template <typename> struct l {};\n+template <typename ba, typename bb, int bd> struct ac<af<ba, bb, bd>> {\n+  typedef typename ba::ah ah;\n+  enum { ai, aj };\n+};\n+template <typename, typename, int bd>\n+class af\n+    : public ak<\n+          af<ag<int, const n<double, -1, -1, 3>, const n<double, -1, -1, 3>>,\n+             n<double, -1, 1, 3>, bd>,\n+          int, int>::f {};\n+template <typename, typename, typename> struct be;\n+template <typename bj, typename bg, typename g> void bi(bj, bg bm, g) {\n+  typename an<bg>::f bk(bm);\n+}\n+template <typename bj, typename bg, typename g> void bl(bj, bg bm, g bp) {\n+  be<bj, bg, g>::bn(a, bm, bp);\n+}\n+template <typename, typename, typename, typename> struct bo;\n+class bs {\n+public:\n+  bs(double *, int);\n+  double &operator()(int, int) { return bq[br]; }\n+  template <typename bw, int> bw bt(int i, int j) {\n+    double &bu = operator()(i, j);\n+    return aw<bw, b>(&bu);\n+  }\n+  double *bq;\n+  int br;\n+};\n+class ca : public bs {\n+public:\n+  ca(double *by, int bz) : bs(by, bz) {}\n+};\n+template <typename al> class ce : public am<al>::f {\n+protected:\n+  template <typename ay> void cb(l<ay>) {\n+    af<ag<int, const n<double, -1, -1, 3>, const n<double, -1, -1, 3>>,\n+       n<double, -1, 1, 3>>\n+        cc;\n+    bl(0, cc, az<typename ay::ah>());\n+  }\n+  template <typename> void ch(long);\n+  template <typename ay> void ch(l<ay> cf) { cb(cf); }\n+};\n+template <typename cg, int aa, int m, int cl, int ci, int cj>\n+struct ac<n<cg, aa, m, cl, ci, cj>> {\n+  typedef cg ah;\n+  typedef int av;\n+};\n+template <typename cg, int, int m, int, int, int>\n+class n : public ce<n<cg, m, c>> {\n+public:\n+  template <typename ab> n(ab p) { n::template ch<ab>(p); }\n+};\n+template <typename bc, typename ba, typename bb> struct ac<ag<bc, ba, bb>> {\n+  typedef ba ao;\n+  typedef typename e<bc(typename ba::ah, typename bb::ah)>::f ah;\n+  typedef typename aq<typename ac<ba>::av, typename ac<bb>::av, bc>::at av;\n+};\n+template <typename> class cm;\n+template <typename, typename r, typename cs>\n+class ag\n+    : public cm<typename aq<typename ac<r>::av, typename ac<cs>::av, int>::at> {\n+};\n+template <typename>\n+class cm : public ak<ag<int, n<double, 1, 1>, n<double, 1, 1>>>::f {};\n+template <typename al>\n+template <typename ay>\n+al &o<al>::operator+=(const o<ay> &) {\n+  af<ag<int, const n<double, -1, -1, 3>, const n<double, -1, -1, 3>>,\n+     n<double, -1, 1, 3>>\n+      co;\n+  bi(0, co, int());\n+}\n+enum { cp };\n+template <int> struct cq;\n+template <typename> struct cr {\n+  enum { q };\n+  enum { ae = cq<q>::at };\n+};\n+template <> struct cq<cp> {\n+  enum { at = d };\n+};\n+struct t {\n+  template <typename ba, typename bb, typename s> static void bn(ba, bb, s) {\n+    typedef typename bb::ah x;\n+    x u;\n+    bo<long, ca, x, ca>::bn(0, 0, ca(0, 0), ca(&u, 1), 0, 0, 0);\n+  }\n+};\n+template <typename, typename bb, int = cr<bb>::ae> struct cu;\n+template <typename cd, typename ba, typename bb, int ct, typename ah>\n+struct be<cd, af<ba, bb, ct>, az<ah>> {\n+  static void bn(cd, af<ba, bb> bm, az<ah>) {\n+    ag<int, const n<double, -1, -1, 3>, const n<double, -1, -1, 3>> da;\n+    cu<ba, bb>::cv(c, da, bm);\n+  }\n+};\n+template <typename al> struct cw {\n+  template <typename bj>\n+  static void\n+  cv(bj, ag<int, const n<double, -1, -1, 3>, const n<double, -1, -1, 3>>,\n+     n<double, -1, 1, 3> bx) {\n+    double alpha;\n+    ag<int, const n<double, -1, -1, 3>, const n<double, -1, -1, 3>> bh;\n+    al::cx(c, bh, bx, alpha);\n+  }\n+};\n+template <typename ba, typename bb> struct cu<ba, bb, d> : cw<cu<ba, bb>> {\n+  template <typename s> static void cx(s, ba, bb bx, typename af<ba, bb>::ah) {\n+    ba cz;\n+    t::bn(cz, bx, c);\n+  }\n+};\n+template <typename dj, typename, bool>\n+void db(__vector_quad *, __vector_pair &, dj);\n+template <typename, typename, typename, typename, typename, typename, int>\n+void dc(ca alhs) {\n+  typedef au dj;\n+  typedef au dd;\n+  ca bh(alhs);\n+  enum { de };\n+  __vector_quad df, dg;\n+  int j;\n+  dd v;\n+  __vector_pair dh;\n+  __builtin_mma_assemble_pair(\n+      &dh, (__attribute__((altivec(vector__))) char)bh.bt<dj, de>(0, j),\n+      (__attribute__((altivec(vector__))) char)bh.bt<dj, de>(0, j));\n+  db<dj, dd, true>(&df, dh, v);\n+  __vector_pair di;\n+  __builtin_mma_assemble_pair(\n+      &di, (__attribute__((altivec(vector__))) char)bh.bt<dj, de>(0, j),\n+      (__attribute__((altivec(vector__))) char)bh.bt<dj, de>(0, j));\n+  db<dj, dd, true>(&dg, di, v);\n+}\n+template <typename bv, typename w, typename cy> struct bo<bv, w, double, cy> {\n+  static void bn(bv, bv, w bh, cy, double, bv, double) {\n+    dc<bv, double, w, double, cy, double, d>(bh);\n+  }\n+};\n+void dm() {\n+  n<double, 1, 1> dk(1), y(0);\n+  y += dk;\n+}"}]}