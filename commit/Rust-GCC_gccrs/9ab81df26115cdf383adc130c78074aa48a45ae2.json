{"sha": "9ab81df26115cdf383adc130c78074aa48a45ae2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWFiODFkZjI2MTE1Y2RmMzgzYWRjMTMwYzc4MDc0YWE0OGE0NWFlMg==", "commit": {"author": {"name": "John David Anglin", "email": "dave.anglin@nrc-cnrc.gc.ca", "date": "2003-10-08T17:55:41Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2003-10-08T17:55:41Z"}, "message": "re PR rtl-optimization/12142 (-fnon-call-exceptions generates incorrect code)\n\n\tPR optimization/12142\n\t* cse.c (count_reg_usage): In a SET with a REG SET_DEST, count the\n\tuses of the register in the SET_SRC.  Remove unnecessary argument.\n\t* pa.c (legitimize_pic_address): Before reload, use a scratch register\n\tfor the intermediate result in loading the address of a SYMBOL_REF.\n\tSet the MEM_NOTRAP_P flag for the MEM.  Add a REG_EQUAL to the insn\n\twhich loads the SYMBOL_REF address.\n\nFrom-SVN: r72234", "tree": {"sha": "04d2ab8aacf304e21a4ca41a910c138798e74708", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/04d2ab8aacf304e21a4ca41a910c138798e74708"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9ab81df26115cdf383adc130c78074aa48a45ae2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ab81df26115cdf383adc130c78074aa48a45ae2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ab81df26115cdf383adc130c78074aa48a45ae2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ab81df26115cdf383adc130c78074aa48a45ae2/comments", "author": null, "committer": null, "parents": [{"sha": "85aa13b28714657d91baabd5862c92008071706b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85aa13b28714657d91baabd5862c92008071706b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85aa13b28714657d91baabd5862c92008071706b"}], "stats": {"total": 84, "additions": 48, "deletions": 36}, "files": [{"sha": "626e9aa43a4372509031f64f0492efc7c0ac4995", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ab81df26115cdf383adc130c78074aa48a45ae2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ab81df26115cdf383adc130c78074aa48a45ae2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9ab81df26115cdf383adc130c78074aa48a45ae2", "patch": "@@ -1,3 +1,13 @@\n+2003-10-08  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n+\n+\tPR optimization/12142\n+\t* cse.c (count_reg_usage): In a SET with a REG SET_DEST, count the\n+\tuses of the register in the SET_SRC.  Remove unnecessary argument.\n+\t* pa.c (legitimize_pic_address): Before reload, use a scratch register\n+\tfor the intermediate result in loading the address of a SYMBOL_REF.\n+\tSet the MEM_NOTRAP_P flag for the MEM.  Add a REG_EQUAL to the insn\n+\twhich loads the SYMBOL_REF address.\n+\n 2003-10-08  Timo Kokkonen  <tjko@iki.fi>\n             Eric Botcazou  <ebotcazou@libertysurf.fr>\n "}, {"sha": "366128c2c252254498a522c5dab2aa04726749a9", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ab81df26115cdf383adc130c78074aa48a45ae2/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ab81df26115cdf383adc130c78074aa48a45ae2/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=9ab81df26115cdf383adc130c78074aa48a45ae2", "patch": "@@ -836,22 +836,35 @@ legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)\n     }\n   if (GET_CODE (orig) == SYMBOL_REF)\n     {\n+      rtx insn, tmp_reg;\n+\n       if (reg == 0)\n \tabort ();\n \n-      emit_move_insn (reg,\n+      /* Before reload, allocate a temporary register for the intermediate\n+\t result.  This allows the sequence to be deleted when the final\n+\t result is unused and the insns are trivially dead.  */\n+      tmp_reg = ((reload_in_progress || reload_completed)\n+\t\t ? reg : gen_reg_rtx (Pmode));\n+\n+      emit_move_insn (tmp_reg,\n \t\t      gen_rtx_PLUS (word_mode, pic_offset_table_rtx,\n \t\t\t\t    gen_rtx_HIGH (word_mode, orig)));\n       pic_ref\n \t= gen_rtx_MEM (Pmode,\n-\t\t       gen_rtx_LO_SUM (Pmode, reg,\n+\t\t       gen_rtx_LO_SUM (Pmode, tmp_reg,\n \t\t\t\t       gen_rtx_UNSPEC (Pmode,\n \t\t\t\t\t\t       gen_rtvec (1, orig),\n \t\t\t\t\t\t       0)));\n \n       current_function_uses_pic_offset_table = 1;\n+      MEM_NOTRAP_P (pic_ref) = 1;\n       RTX_UNCHANGING_P (pic_ref) = 1;\n-      emit_move_insn (reg, pic_ref);\n+      insn = emit_move_insn (reg, pic_ref);\n+\n+      /* Put a REG_EQUAL note on this insn, so that it can be optimized.  */\n+      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_EQUAL, orig, REG_NOTES (insn));\n+\n       return reg;\n     }\n   else if (GET_CODE (orig) == CONST)"}, {"sha": "8683f4ac3380d4c1ff34c4ebadd21c749e17a886", "filename": "gcc/cse.c", "status": "modified", "additions": 22, "deletions": 33, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ab81df26115cdf383adc130c78074aa48a45ae2/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ab81df26115cdf383adc130c78074aa48a45ae2/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=9ab81df26115cdf383adc130c78074aa48a45ae2", "patch": "@@ -647,7 +647,7 @@ static void invalidate_skipped_block (rtx);\n static void cse_check_loop_start (rtx, rtx, void *);\n static void cse_set_around_loop (rtx, rtx, rtx);\n static rtx cse_basic_block (rtx, rtx, struct branch_path *, int);\n-static void count_reg_usage (rtx, int *, rtx, int);\n+static void count_reg_usage (rtx, int *, int);\n static int check_for_label_ref (rtx *, void *);\n extern void dump_class (struct table_elt*);\n static struct cse_reg_info * get_cse_reg_info (unsigned int);\n@@ -7301,14 +7301,10 @@ check_for_label_ref (rtx *rtl, void *data)\n \f\n /* Count the number of times registers are used (not set) in X.\n    COUNTS is an array in which we accumulate the count, INCR is how much\n-   we count each register usage.\n-\n-   Don't count a usage of DEST, which is the SET_DEST of a SET which\n-   contains X in its SET_SRC.  This is because such a SET does not\n-   modify the liveness of DEST.  */\n+   we count each register usage.  */\n \n static void\n-count_reg_usage (rtx x, int *counts, rtx dest, int incr)\n+count_reg_usage (rtx x, int *counts, int incr)\n {\n   enum rtx_code code;\n   rtx note;\n@@ -7321,8 +7317,7 @@ count_reg_usage (rtx x, int *counts, rtx dest, int incr)\n   switch (code = GET_CODE (x))\n     {\n     case REG:\n-      if (x != dest)\n-\tcounts[REGNO (x)] += incr;\n+      counts[REGNO (x)] += incr;\n       return;\n \n     case PC:\n@@ -7339,25 +7334,23 @@ count_reg_usage (rtx x, int *counts, rtx dest, int incr)\n       /* If we are clobbering a MEM, mark any registers inside the address\n          as being used.  */\n       if (GET_CODE (XEXP (x, 0)) == MEM)\n-\tcount_reg_usage (XEXP (XEXP (x, 0), 0), counts, NULL_RTX, incr);\n+\tcount_reg_usage (XEXP (XEXP (x, 0), 0), counts, incr);\n       return;\n \n     case SET:\n       /* Unless we are setting a REG, count everything in SET_DEST.  */\n       if (GET_CODE (SET_DEST (x)) != REG)\n-\tcount_reg_usage (SET_DEST (x), counts, NULL_RTX, incr);\n-      count_reg_usage (SET_SRC (x), counts,\n-\t\t       SET_DEST (x),\n-\t\t       incr);\n+\tcount_reg_usage (SET_DEST (x), counts, incr);\n+      count_reg_usage (SET_SRC (x), counts, incr);\n       return;\n \n     case CALL_INSN:\n-      count_reg_usage (CALL_INSN_FUNCTION_USAGE (x), counts, NULL_RTX, incr);\n+      count_reg_usage (CALL_INSN_FUNCTION_USAGE (x), counts, incr);\n       /* Fall through.  */\n \n     case INSN:\n     case JUMP_INSN:\n-      count_reg_usage (PATTERN (x), counts, NULL_RTX, incr);\n+      count_reg_usage (PATTERN (x), counts, incr);\n \n       /* Things used in a REG_EQUAL note aren't dead since loop may try to\n \t use them.  */\n@@ -7372,12 +7365,12 @@ count_reg_usage (rtx x, int *counts, rtx dest, int incr)\n \t     Process all the arguments.  */\n \t    do\n \t      {\n-\t\tcount_reg_usage (XEXP (eqv, 0), counts, NULL_RTX, incr);\n+\t\tcount_reg_usage (XEXP (eqv, 0), counts, incr);\n \t\teqv = XEXP (eqv, 1);\n \t      }\n \t    while (eqv && GET_CODE (eqv) == EXPR_LIST);\n \t  else\n-\t    count_reg_usage (eqv, counts, NULL_RTX, incr);\n+\t    count_reg_usage (eqv, counts, incr);\n \t}\n       return;\n \n@@ -7387,19 +7380,15 @@ count_reg_usage (rtx x, int *counts, rtx dest, int incr)\n \t  /* FUNCTION_USAGE expression lists may include (CLOBBER (mem /u)),\n \t     involving registers in the address.  */\n \t  || GET_CODE (XEXP (x, 0)) == CLOBBER)\n-\tcount_reg_usage (XEXP (x, 0), counts, NULL_RTX, incr);\n+\tcount_reg_usage (XEXP (x, 0), counts, incr);\n \n-      count_reg_usage (XEXP (x, 1), counts, NULL_RTX, incr);\n+      count_reg_usage (XEXP (x, 1), counts, incr);\n       return;\n \n     case ASM_OPERANDS:\n-      /* If the asm is volatile, then this insn cannot be deleted,\n-\t and so the inputs *must* be live.  */\n-      if (MEM_VOLATILE_P (x))\n-\tdest = NULL_RTX;\n       /* Iterate over just the inputs, not the constraints as well.  */\n       for (i = ASM_OPERANDS_INPUT_LENGTH (x) - 1; i >= 0; i--)\n-\tcount_reg_usage (ASM_OPERANDS_INPUT (x, i), counts, dest, incr);\n+\tcount_reg_usage (ASM_OPERANDS_INPUT (x, i), counts, incr);\n       return;\n \n     case INSN_LIST:\n@@ -7413,10 +7402,10 @@ count_reg_usage (rtx x, int *counts, rtx dest, int incr)\n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n     {\n       if (fmt[i] == 'e')\n-\tcount_reg_usage (XEXP (x, i), counts, dest, incr);\n+\tcount_reg_usage (XEXP (x, i), counts, incr);\n       else if (fmt[i] == 'E')\n \tfor (j = XVECLEN (x, i) - 1; j >= 0; j--)\n-\t  count_reg_usage (XVECEXP (x, i, j), counts, dest, incr);\n+\t  count_reg_usage (XVECEXP (x, i, j), counts, incr);\n     }\n }\n \f\n@@ -7508,11 +7497,11 @@ dead_libcall_p (rtx insn, int *counts)\n     new = XEXP (note, 0);\n \n   /* While changing insn, we must update the counts accordingly.  */\n-  count_reg_usage (insn, counts, NULL_RTX, -1);\n+  count_reg_usage (insn, counts, -1);\n \n   if (validate_change (insn, &SET_SRC (set), new, 0))\n     {\n-      count_reg_usage (insn, counts, NULL_RTX, 1);\n+      count_reg_usage (insn, counts, 1);\n       remove_note (insn, find_reg_note (insn, REG_RETVAL, NULL_RTX));\n       remove_note (insn, note);\n       return true;\n@@ -7523,14 +7512,14 @@ dead_libcall_p (rtx insn, int *counts)\n       new = force_const_mem (GET_MODE (SET_DEST (set)), new);\n       if (new && validate_change (insn, &SET_SRC (set), new, 0))\n \t{\n-\t  count_reg_usage (insn, counts, NULL_RTX, 1);\n+\t  count_reg_usage (insn, counts, 1);\n \t  remove_note (insn, find_reg_note (insn, REG_RETVAL, NULL_RTX));\n \t  remove_note (insn, note);\n \t  return true;\n \t}\n     }\n \n-  count_reg_usage (insn, counts, NULL_RTX, 1);\n+  count_reg_usage (insn, counts, 1);\n   return false;\n }\n \n@@ -7554,7 +7543,7 @@ delete_trivially_dead_insns (rtx insns, int nreg)\n   /* First count the number of times each register is used.  */\n   counts = xcalloc (nreg, sizeof (int));\n   for (insn = next_real_insn (insns); insn; insn = next_real_insn (insn))\n-    count_reg_usage (insn, counts, NULL_RTX, 1);\n+    count_reg_usage (insn, counts, 1);\n \n   do\n     {\n@@ -7598,7 +7587,7 @@ delete_trivially_dead_insns (rtx insns, int nreg)\n \n \t  if (! live_insn)\n \t    {\n-\t      count_reg_usage (insn, counts, NULL_RTX, -1);\n+\t      count_reg_usage (insn, counts, -1);\n \t      delete_insn_and_edges (insn);\n \t      ndead++;\n \t    }"}]}