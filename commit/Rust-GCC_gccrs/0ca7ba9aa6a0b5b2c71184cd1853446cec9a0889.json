{"sha": "0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGNhN2JhOWFhNmEwYjViMmM3MTE4NGNkMTg1MzQ0NmNlYzlhMDg4OQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2015-04-30T19:11:52Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2015-04-30T19:11:52Z"}, "message": "Implement N4100 File System TS\n\n\t* acinclude.m4 (GLIBCXX_ENABLE_FILESYSTEM_TS): Define.\n\t(GLIBCXX_CHECK_FILESYSTEM_DEPS): Define.\n\t* config.h.in: Regenerate.\n\t* configure: Regenerate.\n\t* configure.ac: Enable filesystem TS and check its dependencies.\n\t* include/Makefile.am: Add new headers.\n\t* include/Makefile.in: Regenerate.\n\t* include/bits/locale_conv.h (__do_str_code_cvt, __str_codecvt_in,\n\t__str_codecvt_out): Move code conversion logic from wstring_convert\n\tinto new global functions.\n\t(wstring_convert::to_bytes, wstring_convert::from_bytes): Use new\n\tfunctions.\n\t(wstring_convert::_M_conv): Remove.\n\t* include/bits/quoted_string.h (_Quoted_string): Split out of iomanip.\n\t* include/experimental/filesystem: New.\n\t* include/experimental/fs_dir.h: New.\n\t* include/experimental/fs_fwd.h: New.\n\t* include/experimental/fs_ops.h: New.\n\t* include/experimental/fs_path.h: New.\n\t* include/std/iomanip (_Quoted_string): Move to bits/quoted_string.h.\n\t* python/libstdcxx/v6/printers.py (StdExpPathPrinter): Add.\n\t* src/Makefile.am (SUBDIRS): Add filesystem.\n\t* src/Makefile.in: Regenerate.\n\t* src/filesystem/Makefile.am: New.\n\t* src/filesystem/Makefile.in: New.\n\t* src/filesystem/dir.cc: New.\n\t* src/filesystem/ops.cc: New.\n\t* src/filesystem/path.cc: New.\n\t* testsuite/experimental/filesystem/operations/absolute.cc: New.\n\t* testsuite/experimental/filesystem/operations/copy.cc: New.\n\t* testsuite/experimental/filesystem/operations/current_path.cc: New.\n\t* testsuite/experimental/filesystem/path/append/path.cc: New.\n\t* testsuite/experimental/filesystem/path/assign/assign.cc: New.\n\t* testsuite/experimental/filesystem/path/assign/copy.cc: New.\n\t* testsuite/experimental/filesystem/path/compare/compare.cc: New.\n\t* testsuite/experimental/filesystem/path/compare/path.cc: New.\n\t* testsuite/experimental/filesystem/path/compare/strings.cc: New.\n\t* testsuite/experimental/filesystem/path/concat/path.cc: New.\n\t* testsuite/experimental/filesystem/path/concat/strings.cc: New.\n\t* testsuite/experimental/filesystem/path/construct/copy.cc: New.\n\t* testsuite/experimental/filesystem/path/construct/default.cc: New.\n\t* testsuite/experimental/filesystem/path/construct/locale.cc: New.\n\t* testsuite/experimental/filesystem/path/construct/range.cc: New.\n\t* testsuite/experimental/filesystem/path/decompose/extension.cc: New.\n\t* testsuite/experimental/filesystem/path/decompose/filename.cc: New.\n\t* testsuite/experimental/filesystem/path/decompose/parent_path.cc:\n\tNew.\n\t* testsuite/experimental/filesystem/path/decompose/relative_path.cc:\n\tNew.\n\t* testsuite/experimental/filesystem/path/decompose/root_directory.cc:\n\tNew.\n\t* testsuite/experimental/filesystem/path/decompose/root_name.cc:\n\tNew.\n\t* testsuite/experimental/filesystem/path/decompose/root_path.cc:\n\tNew.\n\t* testsuite/experimental/filesystem/path/decompose/stem.cc: New.\n\t* testsuite/experimental/filesystem/path/generic/generic_string.cc:\n\tNew.\n\t* testsuite/experimental/filesystem/path/itr/traversal.cc: New.\n\t* testsuite/experimental/filesystem/path/modifiers/clear.cc: New.\n\t* testsuite/experimental/filesystem/path/modifiers/make_preferred.cc:\n\tNew.\n\t* testsuite/experimental/filesystem/path/modifiers/remove_filename.cc:\n\tNew.\n\t* testsuite/experimental/filesystem/path/modifiers/replace_extension.cc:\n\tNew.\n\t* testsuite/experimental/filesystem/path/modifiers/replace_filename.cc:\n\tNew.\n\t* testsuite/experimental/filesystem/path/modifiers/swap.cc: New.\n\t* testsuite/experimental/filesystem/path/nonmember/hash_value.cc: New.\n\t* testsuite/experimental/filesystem/path/query/empty.cc: New.\n\t* testsuite/experimental/filesystem/path/query/has_extension.cc: New.\n\t* testsuite/experimental/filesystem/path/query/has_filename.cc: New.\n\t* testsuite/experimental/filesystem/path/query/has_parent_path.cc:\n\tNew.\n\t* testsuite/experimental/filesystem/path/query/has_relative_path.cc:\n\tNew.\n\t* testsuite/experimental/filesystem/path/query/has_root_directory.cc:\n\tNew.\n\t* testsuite/experimental/filesystem/path/query/has_root_name.cc:\n\tNew.\n\t* testsuite/experimental/filesystem/path/query/has_root_path.cc:\n\tNew.\n\t* testsuite/experimental/filesystem/path/query/has_stem.cc: New.\n\t* testsuite/experimental/filesystem/path/query/is_relative.cc: New.\n\t* testsuite/util/testsuite_fs.h: New.\n\nFrom-SVN: r222654", "tree": {"sha": "898dad0f66d2410fa20e02cacb83b40aefe3d2ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/898dad0f66d2410fa20e02cacb83b40aefe3d2ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "59c1f3840203780d04974b37b617ac0d673e8c4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59c1f3840203780d04974b37b617ac0d673e8c4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59c1f3840203780d04974b37b617ac0d673e8c4a"}], "stats": {"total": 8449, "additions": 8252, "deletions": 197}, "files": [{"sha": "34e731a347c41126a9d9337187adf8373a5da5b4", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -1,3 +1,93 @@\n+2015-04-30  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\tImplement N4100 File System TS\n+\t* acinclude.m4 (GLIBCXX_ENABLE_FILESYSTEM_TS): Define.\n+\t(GLIBCXX_CHECK_FILESYSTEM_DEPS): Define.\n+\t* config.h.in: Regenerate.\n+\t* configure: Regenerate.\n+\t* configure.ac: Enable filesystem TS and check its dependencies.\n+\t* include/Makefile.am: Add new headers.\n+\t* include/Makefile.in: Regenerate.\n+\t* include/bits/locale_conv.h (__do_str_code_cvt, __str_codecvt_in,\n+\t__str_codecvt_out): Move code conversion logic from wstring_convert\n+\tinto new global functions.\n+\t(wstring_convert::to_bytes, wstring_convert::from_bytes): Use new\n+\tfunctions.\n+\t(wstring_convert::_M_conv): Remove.\n+\t* include/bits/quoted_string.h (_Quoted_string): Split out of iomanip.\n+\t* include/experimental/filesystem: New.\n+\t* include/experimental/fs_dir.h: New.\n+\t* include/experimental/fs_fwd.h: New.\n+\t* include/experimental/fs_ops.h: New.\n+\t* include/experimental/fs_path.h: New.\n+\t* include/std/iomanip (_Quoted_string): Move to bits/quoted_string.h.\n+\t* python/libstdcxx/v6/printers.py (StdExpPathPrinter): Add.\n+\t* src/Makefile.am (SUBDIRS): Add filesystem.\n+\t* src/Makefile.in: Regenerate.\n+\t* src/filesystem/Makefile.am: New.\n+\t* src/filesystem/Makefile.in: New.\n+\t* src/filesystem/dir.cc: New.\n+\t* src/filesystem/ops.cc: New.\n+\t* src/filesystem/path.cc: New.\n+\t* testsuite/experimental/filesystem/operations/absolute.cc: New.\n+\t* testsuite/experimental/filesystem/operations/copy.cc: New.\n+\t* testsuite/experimental/filesystem/operations/current_path.cc: New.\n+\t* testsuite/experimental/filesystem/path/append/path.cc: New.\n+\t* testsuite/experimental/filesystem/path/assign/assign.cc: New.\n+\t* testsuite/experimental/filesystem/path/assign/copy.cc: New.\n+\t* testsuite/experimental/filesystem/path/compare/compare.cc: New.\n+\t* testsuite/experimental/filesystem/path/compare/path.cc: New.\n+\t* testsuite/experimental/filesystem/path/compare/strings.cc: New.\n+\t* testsuite/experimental/filesystem/path/concat/path.cc: New.\n+\t* testsuite/experimental/filesystem/path/concat/strings.cc: New.\n+\t* testsuite/experimental/filesystem/path/construct/copy.cc: New.\n+\t* testsuite/experimental/filesystem/path/construct/default.cc: New.\n+\t* testsuite/experimental/filesystem/path/construct/locale.cc: New.\n+\t* testsuite/experimental/filesystem/path/construct/range.cc: New.\n+\t* testsuite/experimental/filesystem/path/decompose/extension.cc: New.\n+\t* testsuite/experimental/filesystem/path/decompose/filename.cc: New.\n+\t* testsuite/experimental/filesystem/path/decompose/parent_path.cc:\n+\tNew.\n+\t* testsuite/experimental/filesystem/path/decompose/relative_path.cc:\n+\tNew.\n+\t* testsuite/experimental/filesystem/path/decompose/root_directory.cc:\n+\tNew.\n+\t* testsuite/experimental/filesystem/path/decompose/root_name.cc:\n+\tNew.\n+\t* testsuite/experimental/filesystem/path/decompose/root_path.cc:\n+\tNew.\n+\t* testsuite/experimental/filesystem/path/decompose/stem.cc: New.\n+\t* testsuite/experimental/filesystem/path/generic/generic_string.cc:\n+\tNew.\n+\t* testsuite/experimental/filesystem/path/itr/traversal.cc: New.\n+\t* testsuite/experimental/filesystem/path/modifiers/clear.cc: New.\n+\t* testsuite/experimental/filesystem/path/modifiers/make_preferred.cc:\n+\tNew.\n+\t* testsuite/experimental/filesystem/path/modifiers/remove_filename.cc:\n+\tNew.\n+\t* testsuite/experimental/filesystem/path/modifiers/replace_extension.cc:\n+\tNew.\n+\t* testsuite/experimental/filesystem/path/modifiers/replace_filename.cc:\n+\tNew.\n+\t* testsuite/experimental/filesystem/path/modifiers/swap.cc: New.\n+\t* testsuite/experimental/filesystem/path/nonmember/hash_value.cc: New.\n+\t* testsuite/experimental/filesystem/path/query/empty.cc: New.\n+\t* testsuite/experimental/filesystem/path/query/has_extension.cc: New.\n+\t* testsuite/experimental/filesystem/path/query/has_filename.cc: New.\n+\t* testsuite/experimental/filesystem/path/query/has_parent_path.cc:\n+\tNew.\n+\t* testsuite/experimental/filesystem/path/query/has_relative_path.cc:\n+\tNew.\n+\t* testsuite/experimental/filesystem/path/query/has_root_directory.cc:\n+\tNew.\n+\t* testsuite/experimental/filesystem/path/query/has_root_name.cc:\n+\tNew.\n+\t* testsuite/experimental/filesystem/path/query/has_root_path.cc:\n+\tNew.\n+\t* testsuite/experimental/filesystem/path/query/has_stem.cc: New.\n+\t* testsuite/experimental/filesystem/path/query/is_relative.cc: New.\n+\t* testsuite/util/testsuite_fs.h: New.\n+\n 2015-04-30  Edward Smith-Rowland  <3dw4rd@verizon.net>\n \n \tAdd fundamentals TR container erasure."}, {"sha": "537ca6f926c0f3e9d67103bce4d33c65ce0c8f82", "filename": "libstdc++-v3/acinclude.m4", "status": "modified", "additions": 94, "deletions": 1, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Facinclude.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Facinclude.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Facinclude.m4?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -49,7 +49,7 @@ AC_DEFUN([GLIBCXX_CONFIGURE], [\n   # Keep these sync'd with the list in Makefile.am.  The first provides an\n   # expandable list at autoconf time; the second provides an expandable list\n   # (i.e., shell variable) at configure time.\n-  m4_define([glibcxx_SUBDIRS],[include libsupc++ src src/c++98 src/c++11 doc po testsuite python])\n+  m4_define([glibcxx_SUBDIRS],[include libsupc++ src src/c++98 src/c++11 src/filesystem doc po testsuite python])\n   SUBDIRS='glibcxx_SUBDIRS'\n \n   # These need to be absolute paths, yet at the same time need to\n@@ -3903,6 +3903,99 @@ AC_DEFUN([GLIBCXX_DEFAULT_ABI], [\n   GLIBCXX_CONDITIONAL(ENABLE_CXX11_ABI, test $glibcxx_cxx11_abi = 1)\n ])\n \n+dnl\n+dnl Check to see whether to build libstdc++fs.a\n+dnl\n+dnl --enable-libstdcxx-filesystem-ts\n+dnl\n+AC_DEFUN([GLIBCXX_ENABLE_FILESYSTEM_TS], [\n+  GLIBCXX_ENABLE(libstdcxx-filesystem-ts,auto,,\n+    [turns on ISO/IEC TS 18822 support],\n+    [permit yes|no|auto])\n+\n+  AC_MSG_CHECKING([whether to build Filesystem TS support])\n+  if test x\"$enable_libstdcxx_filesystem_ts\" = x\"auto\"; then\n+    case \"${target_os}\" in\n+      freebsd*|netbsd*|openbsd*|dragonfly*|darwin*)\n+        enable_libstdcxx_filesystem_ts=yes\n+        ;;\n+      gnu* | linux* | kfreebsd*-gnu | knetbsd*-gnu)\n+        enable_libstdcxx_filesystem_ts=yes\n+        ;;\n+      solaris*)\n+        enable_libstdcxx_filesystem_ts=yes\n+        ;;\n+      *)\n+        enable_libstdcxx_filesystem_ts=no\n+        ;;\n+    esac\n+  fi\n+  AC_MSG_RESULT($enable_libstdcxx_filesystem_ts)\n+  GLIBCXX_CONDITIONAL(ENABLE_FILESYSTEM_TS, test $enable_libstdcxx_filesystem_ts = yes)\n+])\n+\n+dnl\n+dnl Check whether the library calls required by the Filesystem TS are present\n+dnl and define _GLIBCXX_USE_REALPATH and _GLIBCXX_USE_UTIMENSAT.\n+dnl\n+AC_DEFUN([GLIBCXX_CHECK_FILESYSTEM_DEPS], [dnl\n+dnl\n+  AC_LANG_SAVE\n+  AC_LANG_CPLUSPLUS\n+  ac_save_CXXFLAGS=\"$CXXFLAGS\"\n+  CXXFLAGS=\"$CXXFLAGS -fno-exceptions\"\n+dnl\n+  AC_MSG_CHECKING([for realpath])\n+  AC_CACHE_VAL(glibcxx_cv_realpath, [dnl\n+    GCC_TRY_COMPILE_OR_LINK(\n+      [#include <stdlib.h>],\n+      [char *tmp = realpath((const char*)NULL, (char*)NULL);],\n+      [glibcxx_cv_realpath=yes],\n+      [glibcxx_cv_realpath=no])\n+  ])\n+  if test $glibcxx_cv_realpath = yes; then\n+    AC_DEFINE(_GLIBCXX_USE_REALPATH, 1, [Define if realpath is available in <stdlib.h>.])\n+  fi\n+  AC_MSG_RESULT($glibcxx_cv_realpath)\n+dnl\n+  AC_MSG_CHECKING([for utimensat])\n+  AC_CACHE_VAL(glibcxx_cv_utimensat, [dnl\n+    GCC_TRY_COMPILE_OR_LINK(\n+      [\n+        #include <fcntl.h>\n+        #include <sys/stat.h>\n+      ],\n+      [\n+        struct timespec ts[2] = { { 0, UTIME_OMIT }, { 1, 1 } };\n+        int i = utimensat(AT_FDCWD, \"path\", ts, 0);\n+      ],\n+      [glibcxx_cv_utimensat=yes],\n+      [glibcxx_cv_utimensat=no])\n+  ])\n+  if test $glibcxx_cv_utimensat = yes; then\n+    AC_DEFINE(_GLIBCXX_USE_UTIMENSAT, 1, [Define if utimensat and UTIME_OMIT are available in <sys/stat.h> and AT_FDCWD in <fcntl.h>.])\n+  fi\n+  AC_MSG_RESULT($glibcxx_cv_utimensat)\n+dnl\n+  AC_MSG_CHECKING([for struct stat.st_mtim.tv_nsec])\n+  AC_CACHE_VAL(glibcxx_cv_st_mtim, [dnl\n+    GCC_TRY_COMPILE_OR_LINK(\n+      [ #include <sys/stat.h> ],\n+      [\n+        struct stat st;\n+        return st.st_mtim.tv_nsec;\n+      ],\n+      [glibcxx_cv_st_mtim=yes],\n+      [glibcxx_cv_st_mtim=no])\n+  ])\n+  if test $glibcxx_cv_st_mtim = yes; then\n+    AC_DEFINE(_GLIBCXX_USE_ST_MTIM, 1, [Define if struct stat has timespec members.])\n+  fi\n+  AC_MSG_RESULT($glibcxx_cv_st_mtim)\n+dnl\n+  CXXFLAGS=\"$ac_save_CXXFLAGS\"\n+  AC_LANG_RESTORE\n+])\n \n # Macros from the top-level gcc directory.\n m4_include([../config/gc++filt.m4])"}, {"sha": "d763d1bc326810debdd99ff5af52215d181eef5d", "filename": "libstdc++-v3/config.h.in", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig.h.in?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -54,6 +54,10 @@\n /* Define to 1 if you have the `cosl' function. */\n #undef HAVE_COSL\n \n+/* Define to 1 if you have the <dirent.h> header file, and it defines `DIR'.\n+   */\n+#undef HAVE_DIRENT_H\n+\n /* Define to 1 if you have the <dlfcn.h> header file. */\n #undef HAVE_DLFCN_H\n \n@@ -132,6 +136,9 @@\n /* Define to 1 if you have the `fabsl' function. */\n #undef HAVE_FABSL\n \n+/* Define to 1 if you have the <fcntl.h> header file. */\n+#undef HAVE_FCNTL_H\n+\n /* Define to 1 if you have the <fenv.h> header file. */\n #undef HAVE_FENV_H\n \n@@ -294,6 +301,9 @@\n /* Define to 1 if you have the <nan.h> header file. */\n #undef HAVE_NAN_H\n \n+/* Define to 1 if you have the <ndir.h> header file, and it defines `DIR'. */\n+#undef HAVE_NDIR_H\n+\n /* Define if poll is available in <poll.h>. */\n #undef HAVE_POLL\n \n@@ -372,13 +382,20 @@\n /* Define to 1 if you have the `strtold' function. */\n #undef HAVE_STRTOLD\n \n+/* Define to 1 if `struct dirent' is a member of `d_type'. */\n+#undef HAVE_STRUCT_DIRENT_D_TYPE\n+\n /* Define if strxfrm_l is available in <string.h>. */\n #undef HAVE_STRXFRM_L\n \n /* Define to 1 if the target runtime linker supports binding the same symbol\n    to different versions. */\n #undef HAVE_SYMVER_SYMBOL_RENAMING_RUNTIME_SUPPORT\n \n+/* Define to 1 if you have the <sys/dir.h> header file, and it defines `DIR'.\n+   */\n+#undef HAVE_SYS_DIR_H\n+\n /* Define to 1 if you have the <sys/filio.h> header file. */\n #undef HAVE_SYS_FILIO_H\n \n@@ -394,6 +411,10 @@\n /* Define to 1 if you have the <sys/machine.h> header file. */\n #undef HAVE_SYS_MACHINE_H\n \n+/* Define to 1 if you have the <sys/ndir.h> header file, and it defines `DIR'.\n+   */\n+#undef HAVE_SYS_NDIR_H\n+\n /* Define to 1 if you have the <sys/param.h> header file. */\n #undef HAVE_SYS_PARAM_H\n \n@@ -406,6 +427,9 @@\n /* Define to 1 if you have the <sys/sem.h> header file. */\n #undef HAVE_SYS_SEM_H\n \n+/* Define to 1 if you have the <sys/statvfs.h> header file. */\n+#undef HAVE_SYS_STATVFS_H\n+\n /* Define to 1 if you have the <sys/stat.h> header file. */\n #undef HAVE_SYS_STAT_H\n \n@@ -858,6 +882,9 @@\n    of TR1 (Chapter 5.1). */\n #undef _GLIBCXX_USE_RANDOM_TR1\n \n+/* Define if realpath is available in <stdlib.h>. */\n+#undef _GLIBCXX_USE_REALPATH\n+\n /* Defined if sched_yield is available. */\n #undef _GLIBCXX_USE_SCHED_YIELD\n \n@@ -867,12 +894,19 @@\n /* Define if _SC_NPROC_ONLN is available in <unistd.h>. */\n #undef _GLIBCXX_USE_SC_NPROC_ONLN\n \n+/* Define if struct stat has timespec members. */\n+#undef _GLIBCXX_USE_ST_MTIM\n+\n /* Define if sysctl(), CTL_HW and HW_NCPU are available in <sys/sysctl.h>. */\n #undef _GLIBCXX_USE_SYSCTL_HW_NCPU\n \n /* Define if obsolescent tmpnam is available in <stdio.h>. */\n #undef _GLIBCXX_USE_TMPNAM\n \n+/* Define if utimensat and UTIME_OMIT are available in <sys/stat.h> and\n+   AT_FDCWD in <fcntl.h>. */\n+#undef _GLIBCXX_USE_UTIMENSAT\n+\n /* Define if code specialized for wchar_t should be used. */\n #undef _GLIBCXX_USE_WCHAR_T\n "}, {"sha": "0a059c6715f1ead6dc4d349564890a28c9fc2908", "filename": "libstdc++-v3/configure", "status": "modified", "additions": 550, "deletions": 12, "changes": 562, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfigure?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -638,6 +638,8 @@ DOT\n DOXYGEN\n BUILD_INFO_FALSE\n BUILD_INFO_TRUE\n+ENABLE_FILESYSTEM_TS_FALSE\n+ENABLE_FILESYSTEM_TS_TRUE\n baseline_subdir_switch\n baseline_dir\n HWCAP_FLAGS\n@@ -890,6 +892,7 @@ enable_libstdcxx_visibility\n enable_libstdcxx_dual_abi\n with_default_libstdcxx_abi\n enable_libstdcxx_threads\n+enable_libstdcxx_filesystem_ts\n with_gxx_include_dir\n enable_version_specific_runtime_libs\n '\n@@ -1588,6 +1591,8 @@ Optional Features:\n                           support two versions of std::string [default=yes]\n   --enable-libstdcxx-threads\n                           enable C++11 threads support [default=auto]\n+  --enable-libstdcxx-filesystem-ts\n+                          turns on ISO/IEC TS 18822 support [default=auto]\n   --enable-version-specific-runtime-libs\n                           Specify that runtime libraries should be installed\n                           in a compiler-specific directory\n@@ -2552,6 +2557,63 @@ $as_echo \"$ac_res\" >&6; }\n   eval $as_lineno_stack; test \"x$as_lineno_stack\" = x && { as_lineno=; unset as_lineno;}\n \n } # ac_fn_cxx_check_type\n+\n+# ac_fn_c_check_member LINENO AGGR MEMBER VAR INCLUDES\n+# ----------------------------------------------------\n+# Tries to find if the field MEMBER exists in type AGGR, after including\n+# INCLUDES, setting cache variable VAR accordingly.\n+ac_fn_c_check_member ()\n+{\n+  as_lineno=${as_lineno-\"$1\"} as_lineno_stack=as_lineno_stack=$as_lineno_stack\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for $2.$3\" >&5\n+$as_echo_n \"checking for $2.$3... \" >&6; }\n+if { as_var=$4; eval \"test \\\"\\${$as_var+set}\\\" = set\"; }; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+$5\n+int\n+main ()\n+{\n+static $2 ac_aggr;\n+if (ac_aggr.$3)\n+return 0;\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_c_try_compile \"$LINENO\"; then :\n+  eval \"$4=yes\"\n+else\n+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+$5\n+int\n+main ()\n+{\n+static $2 ac_aggr;\n+if (sizeof ac_aggr.$3)\n+return 0;\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_c_try_compile \"$LINENO\"; then :\n+  eval \"$4=yes\"\n+else\n+  eval \"$4=no\"\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+fi\n+eval ac_res=\\$$4\n+\t       { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_res\" >&5\n+$as_echo \"$ac_res\" >&6; }\n+  eval $as_lineno_stack; test \"x$as_lineno_stack\" = x && { as_lineno=; unset as_lineno;}\n+\n+} # ac_fn_c_check_member\n cat >config.log <<_ACEOF\n This file contains any messages produced by compilers while\n running configure, to aid debugging if configure makes a mistake.\n@@ -4951,7 +5013,7 @@ $as_echo \"$ac_cv_path_EGREP\" >&6; }\n   # expandable list at autoconf time; the second provides an expandable list\n   # (i.e., shell variable) at configure time.\n \n-  SUBDIRS='include libsupc++ src src/c++98 src/c++11 doc po testsuite python'\n+  SUBDIRS='include libsupc++ src src/c++98 src/c++11 src/filesystem doc po testsuite python'\n \n   # These need to be absolute paths, yet at the same time need to\n   # canonicalize only relative paths, because then amd will not unmount\n@@ -11593,7 +11655,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 11596 \"configure\"\n+#line 11658 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -11699,7 +11761,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 11702 \"configure\"\n+#line 11764 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -15119,7 +15181,7 @@ fi\n     #\n     # Fake what AC_TRY_COMPILE does.  XXX Look at redoing this new-style.\n     cat > conftest.$ac_ext << EOF\n-#line 15122 \"configure\"\n+#line 15184 \"configure\"\n struct S { ~S(); };\n void bar();\n void foo()\n@@ -15471,7 +15533,7 @@ $as_echo \"$glibcxx_cv_atomic_long_long\" >&6; }\n   # Fake what AC_TRY_COMPILE does.\n \n     cat > conftest.$ac_ext << EOF\n-#line 15474 \"configure\"\n+#line 15536 \"configure\"\n int main()\n {\n   typedef bool atomic_type;\n@@ -15506,7 +15568,7 @@ $as_echo \"$glibcxx_cv_atomic_bool\" >&6; }\n     rm -f conftest*\n \n     cat > conftest.$ac_ext << EOF\n-#line 15509 \"configure\"\n+#line 15571 \"configure\"\n int main()\n {\n   typedef short atomic_type;\n@@ -15541,7 +15603,7 @@ $as_echo \"$glibcxx_cv_atomic_short\" >&6; }\n     rm -f conftest*\n \n     cat > conftest.$ac_ext << EOF\n-#line 15544 \"configure\"\n+#line 15606 \"configure\"\n int main()\n {\n   // NB: _Atomic_word not necessarily int.\n@@ -15577,7 +15639,7 @@ $as_echo \"$glibcxx_cv_atomic_int\" >&6; }\n     rm -f conftest*\n \n     cat > conftest.$ac_ext << EOF\n-#line 15580 \"configure\"\n+#line 15642 \"configure\"\n int main()\n {\n   typedef long long atomic_type;\n@@ -15656,7 +15718,7 @@ $as_echo \"$as_me: WARNING: Performance of certain classes will degrade as a resu\n   # unnecessary for this test.\n \n     cat > conftest.$ac_ext << EOF\n-#line 15659 \"configure\"\n+#line 15721 \"configure\"\n int main()\n {\n   _Decimal32 d1;\n@@ -15698,7 +15760,7 @@ ac_compiler_gnu=$ac_cv_cxx_compiler_gnu\n   # unnecessary for this test.\n \n     cat > conftest.$ac_ext << EOF\n-#line 15701 \"configure\"\n+#line 15763 \"configure\"\n template<typename T1, typename T2>\n   struct same\n   { typedef T2 type; };\n@@ -15732,7 +15794,7 @@ $as_echo \"$enable_int128\" >&6; }\n     rm -f conftest*\n \n     cat > conftest.$ac_ext << EOF\n-#line 15735 \"configure\"\n+#line 15797 \"configure\"\n template<typename T1, typename T2>\n   struct same\n   { typedef T2 type; };\n@@ -78865,6 +78927,457 @@ ac_compiler_gnu=$ac_cv_c_compiler_gnu\n \n \n \n+# For Filesystem TS.\n+for ac_header in fcntl.h dirent.h sys/statvfs.h\n+do :\n+  as_ac_Header=`$as_echo \"ac_cv_header_$ac_header\" | $as_tr_sh`\n+ac_fn_c_check_header_mongrel \"$LINENO\" \"$ac_header\" \"$as_ac_Header\" \"$ac_includes_default\"\n+eval as_val=\\$$as_ac_Header\n+   if test \"x$as_val\" = x\"\"yes; then :\n+  cat >>confdefs.h <<_ACEOF\n+#define `$as_echo \"HAVE_$ac_header\" | $as_tr_cpp` 1\n+_ACEOF\n+\n+fi\n+\n+done\n+\n+ac_header_dirent=no\n+for ac_hdr in dirent.h sys/ndir.h sys/dir.h ndir.h; do\n+  as_ac_Header=`$as_echo \"ac_cv_header_dirent_$ac_hdr\" | $as_tr_sh`\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for $ac_hdr that defines DIR\" >&5\n+$as_echo_n \"checking for $ac_hdr that defines DIR... \" >&6; }\n+if { as_var=$as_ac_Header; eval \"test \\\"\\${$as_var+set}\\\" = set\"; }; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+#include <sys/types.h>\n+#include <$ac_hdr>\n+\n+int\n+main ()\n+{\n+if ((DIR *) 0)\n+return 0;\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_c_try_compile \"$LINENO\"; then :\n+  eval \"$as_ac_Header=yes\"\n+else\n+  eval \"$as_ac_Header=no\"\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+fi\n+eval ac_res=\\$$as_ac_Header\n+\t       { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_res\" >&5\n+$as_echo \"$ac_res\" >&6; }\n+eval as_val=\\$$as_ac_Header\n+   if test \"x$as_val\" = x\"\"yes; then :\n+  cat >>confdefs.h <<_ACEOF\n+#define `$as_echo \"HAVE_$ac_hdr\" | $as_tr_cpp` 1\n+_ACEOF\n+\n+ac_header_dirent=$ac_hdr; break\n+fi\n+\n+done\n+# Two versions of opendir et al. are in -ldir and -lx on SCO Xenix.\n+if test $ac_header_dirent = dirent.h; then\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for library containing opendir\" >&5\n+$as_echo_n \"checking for library containing opendir... \" >&6; }\n+if test \"${ac_cv_search_opendir+set}\" = set; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  ac_func_search_save_LIBS=$LIBS\n+cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+\n+/* Override any GCC internal prototype to avoid an error.\n+   Use char because int might match the return type of a GCC\n+   builtin and then its argument prototype would still apply.  */\n+#ifdef __cplusplus\n+extern \"C\"\n+#endif\n+char opendir ();\n+int\n+main ()\n+{\n+return opendir ();\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+for ac_lib in '' dir; do\n+  if test -z \"$ac_lib\"; then\n+    ac_res=\"none required\"\n+  else\n+    ac_res=-l$ac_lib\n+    LIBS=\"-l$ac_lib  $ac_func_search_save_LIBS\"\n+  fi\n+  if test x$gcc_no_link = xyes; then\n+  as_fn_error \"Link tests are not allowed after GCC_NO_EXECUTABLES.\" \"$LINENO\" 5\n+fi\n+if ac_fn_c_try_link \"$LINENO\"; then :\n+  ac_cv_search_opendir=$ac_res\n+fi\n+rm -f core conftest.err conftest.$ac_objext \\\n+    conftest$ac_exeext\n+  if test \"${ac_cv_search_opendir+set}\" = set; then :\n+  break\n+fi\n+done\n+if test \"${ac_cv_search_opendir+set}\" = set; then :\n+\n+else\n+  ac_cv_search_opendir=no\n+fi\n+rm conftest.$ac_ext\n+LIBS=$ac_func_search_save_LIBS\n+fi\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_search_opendir\" >&5\n+$as_echo \"$ac_cv_search_opendir\" >&6; }\n+ac_res=$ac_cv_search_opendir\n+if test \"$ac_res\" != no; then :\n+  test \"$ac_res\" = \"none required\" || LIBS=\"$ac_res $LIBS\"\n+\n+fi\n+\n+else\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for library containing opendir\" >&5\n+$as_echo_n \"checking for library containing opendir... \" >&6; }\n+if test \"${ac_cv_search_opendir+set}\" = set; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  ac_func_search_save_LIBS=$LIBS\n+cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+\n+/* Override any GCC internal prototype to avoid an error.\n+   Use char because int might match the return type of a GCC\n+   builtin and then its argument prototype would still apply.  */\n+#ifdef __cplusplus\n+extern \"C\"\n+#endif\n+char opendir ();\n+int\n+main ()\n+{\n+return opendir ();\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+for ac_lib in '' x; do\n+  if test -z \"$ac_lib\"; then\n+    ac_res=\"none required\"\n+  else\n+    ac_res=-l$ac_lib\n+    LIBS=\"-l$ac_lib  $ac_func_search_save_LIBS\"\n+  fi\n+  if test x$gcc_no_link = xyes; then\n+  as_fn_error \"Link tests are not allowed after GCC_NO_EXECUTABLES.\" \"$LINENO\" 5\n+fi\n+if ac_fn_c_try_link \"$LINENO\"; then :\n+  ac_cv_search_opendir=$ac_res\n+fi\n+rm -f core conftest.err conftest.$ac_objext \\\n+    conftest$ac_exeext\n+  if test \"${ac_cv_search_opendir+set}\" = set; then :\n+  break\n+fi\n+done\n+if test \"${ac_cv_search_opendir+set}\" = set; then :\n+\n+else\n+  ac_cv_search_opendir=no\n+fi\n+rm conftest.$ac_ext\n+LIBS=$ac_func_search_save_LIBS\n+fi\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_search_opendir\" >&5\n+$as_echo \"$ac_cv_search_opendir\" >&6; }\n+ac_res=$ac_cv_search_opendir\n+if test \"$ac_res\" != no; then :\n+  test \"$ac_res\" = \"none required\" || LIBS=\"$ac_res $LIBS\"\n+\n+fi\n+\n+fi\n+\n+\n+\n+  ac_fn_c_check_member \"$LINENO\" \"struct dirent\" \"d_type\" \"ac_cv_member_struct_dirent_d_type\" \"\n+#include <sys/types.h>\n+#ifdef HAVE_DIRENT_H\n+# include <dirent.h>\n+#else\n+# define dirent direct\n+# ifdef HAVE_SYS_NDIR_H\n+#  include <sys/ndir.h>\n+# endif\n+# ifdef HAVE_SYS_DIR_H\n+#  include <sys/dir.h>\n+# endif\n+# ifdef HAVE_NDIR_H\n+#  include <ndir.h>\n+# endif\n+#endif\n+\n+\"\n+if test \"x$ac_cv_member_struct_dirent_d_type\" = x\"\"yes; then :\n+\n+cat >>confdefs.h <<_ACEOF\n+#define HAVE_STRUCT_DIRENT_D_TYPE 1\n+_ACEOF\n+\n+\n+fi\n+\n+\n+\n+   # Check whether --enable-libstdcxx-filesystem-ts was given.\n+if test \"${enable_libstdcxx_filesystem_ts+set}\" = set; then :\n+  enableval=$enable_libstdcxx_filesystem_ts;\n+      case \"$enableval\" in\n+       yes|no|auto) ;;\n+       *) as_fn_error \"Unknown argument to enable/disable libstdcxx-filesystem-ts\" \"$LINENO\" 5 ;;\n+\t  \t        esac\n+\n+else\n+  enable_libstdcxx_filesystem_ts=auto\n+fi\n+\n+\n+\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: checking whether to build Filesystem TS support\" >&5\n+$as_echo_n \"checking whether to build Filesystem TS support... \" >&6; }\n+  if test x\"$enable_libstdcxx_filesystem_ts\" = x\"auto\"; then\n+    case \"${target_os}\" in\n+      freebsd*|netbsd*|openbsd*|dragonfly*|darwin*)\n+        enable_libstdcxx_filesystem_ts=yes\n+        ;;\n+      gnu* | linux* | kfreebsd*-gnu | knetbsd*-gnu)\n+        enable_libstdcxx_filesystem_ts=yes\n+        ;;\n+      solaris*)\n+        enable_libstdcxx_filesystem_ts=yes\n+        ;;\n+      *)\n+        enable_libstdcxx_filesystem_ts=no\n+        ;;\n+    esac\n+  fi\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $enable_libstdcxx_filesystem_ts\" >&5\n+$as_echo \"$enable_libstdcxx_filesystem_ts\" >&6; }\n+\n+\n+\n+  ac_ext=cpp\n+ac_cpp='$CXXCPP $CPPFLAGS'\n+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'\n+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'\n+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu\n+\n+  ac_save_CXXFLAGS=\"$CXXFLAGS\"\n+  CXXFLAGS=\"$CXXFLAGS -fno-exceptions\"\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for realpath\" >&5\n+$as_echo_n \"checking for realpath... \" >&6; }\n+  if test \"${glibcxx_cv_realpath+set}\" = set; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+      if test x$gcc_no_link = xyes; then\n+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+#include <stdlib.h>\n+int\n+main ()\n+{\n+char *tmp = realpath((const char*)NULL, (char*)NULL);\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_cxx_try_compile \"$LINENO\"; then :\n+  glibcxx_cv_realpath=yes\n+else\n+  glibcxx_cv_realpath=no\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+else\n+  if test x$gcc_no_link = xyes; then\n+  as_fn_error \"Link tests are not allowed after GCC_NO_EXECUTABLES.\" \"$LINENO\" 5\n+fi\n+cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+#include <stdlib.h>\n+int\n+main ()\n+{\n+char *tmp = realpath((const char*)NULL, (char*)NULL);\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_cxx_try_link \"$LINENO\"; then :\n+  glibcxx_cv_realpath=yes\n+else\n+  glibcxx_cv_realpath=no\n+fi\n+rm -f core conftest.err conftest.$ac_objext \\\n+    conftest$ac_exeext conftest.$ac_ext\n+fi\n+\n+fi\n+\n+  if test $glibcxx_cv_realpath = yes; then\n+\n+$as_echo \"#define _GLIBCXX_USE_REALPATH 1\" >>confdefs.h\n+\n+  fi\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_realpath\" >&5\n+$as_echo \"$glibcxx_cv_realpath\" >&6; }\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for utimensat\" >&5\n+$as_echo_n \"checking for utimensat... \" >&6; }\n+  if test \"${glibcxx_cv_utimensat+set}\" = set; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+      if test x$gcc_no_link = xyes; then\n+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+\n+        #include <fcntl.h>\n+        #include <sys/stat.h>\n+\n+int\n+main ()\n+{\n+\n+        struct timespec ts[2] = { { 0, UTIME_OMIT }, { 1, 1 } };\n+        int i = utimensat(AT_FDCWD, \"path\", ts, 0);\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_cxx_try_compile \"$LINENO\"; then :\n+  glibcxx_cv_utimensat=yes\n+else\n+  glibcxx_cv_utimensat=no\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+else\n+  if test x$gcc_no_link = xyes; then\n+  as_fn_error \"Link tests are not allowed after GCC_NO_EXECUTABLES.\" \"$LINENO\" 5\n+fi\n+cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+\n+        #include <fcntl.h>\n+        #include <sys/stat.h>\n+\n+int\n+main ()\n+{\n+\n+        struct timespec ts[2] = { { 0, UTIME_OMIT }, { 1, 1 } };\n+        int i = utimensat(AT_FDCWD, \"path\", ts, 0);\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_cxx_try_link \"$LINENO\"; then :\n+  glibcxx_cv_utimensat=yes\n+else\n+  glibcxx_cv_utimensat=no\n+fi\n+rm -f core conftest.err conftest.$ac_objext \\\n+    conftest$ac_exeext conftest.$ac_ext\n+fi\n+\n+fi\n+\n+  if test $glibcxx_cv_utimensat = yes; then\n+\n+$as_echo \"#define _GLIBCXX_USE_UTIMENSAT 1\" >>confdefs.h\n+\n+  fi\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_utimensat\" >&5\n+$as_echo \"$glibcxx_cv_utimensat\" >&6; }\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for struct stat.st_mtim.tv_nsec\" >&5\n+$as_echo_n \"checking for struct stat.st_mtim.tv_nsec... \" >&6; }\n+  if test \"${glibcxx_cv_st_mtim+set}\" = set; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+      if test x$gcc_no_link = xyes; then\n+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+ #include <sys/stat.h>\n+int\n+main ()\n+{\n+\n+        struct stat st;\n+        return st.st_mtim.tv_nsec;\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_cxx_try_compile \"$LINENO\"; then :\n+  glibcxx_cv_st_mtim=yes\n+else\n+  glibcxx_cv_st_mtim=no\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+else\n+  if test x$gcc_no_link = xyes; then\n+  as_fn_error \"Link tests are not allowed after GCC_NO_EXECUTABLES.\" \"$LINENO\" 5\n+fi\n+cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+ #include <sys/stat.h>\n+int\n+main ()\n+{\n+\n+        struct stat st;\n+        return st.st_mtim.tv_nsec;\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_cxx_try_link \"$LINENO\"; then :\n+  glibcxx_cv_st_mtim=yes\n+else\n+  glibcxx_cv_st_mtim=no\n+fi\n+rm -f core conftest.err conftest.$ac_objext \\\n+    conftest$ac_exeext conftest.$ac_ext\n+fi\n+\n+fi\n+\n+  if test $glibcxx_cv_st_mtim = yes; then\n+\n+$as_echo \"#define _GLIBCXX_USE_ST_MTIM 1\" >>confdefs.h\n+\n+  fi\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_st_mtim\" >&5\n+$as_echo \"$glibcxx_cv_st_mtim\" >&6; }\n+  CXXFLAGS=\"$ac_save_CXXFLAGS\"\n+  ac_ext=c\n+ac_cpp='$CPP $CPPFLAGS'\n+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'\n+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'\n+ac_compiler_gnu=$ac_cv_c_compiler_gnu\n+\n+\n+\n # Define documentation rules conditionally.\n \n # See if makeinfo has been installed and is modern enough\n@@ -79488,6 +80001,15 @@ else\n fi\n \n \n+    if test $enable_libstdcxx_filesystem_ts = yes; then\n+  ENABLE_FILESYSTEM_TS_TRUE=\n+  ENABLE_FILESYSTEM_TS_FALSE='#'\n+else\n+  ENABLE_FILESYSTEM_TS_TRUE='#'\n+  ENABLE_FILESYSTEM_TS_FALSE=\n+fi\n+\n+\n \n \n cat >confcache <<\\_ACEOF\n@@ -79713,7 +80235,7 @@ ac_config_files=\"$ac_config_files doc/xsl/customization.xsl\"\n # append it here.  Only modify Makefiles that have just been created.\n #\n # Also, get rid of this simulated-VPATH thing that automake does.\n-ac_config_files=\"$ac_config_files include/Makefile libsupc++/Makefile src/Makefile src/c++98/Makefile src/c++11/Makefile doc/Makefile po/Makefile testsuite/Makefile python/Makefile\"\n+ac_config_files=\"$ac_config_files include/Makefile libsupc++/Makefile src/Makefile src/c++98/Makefile src/c++11/Makefile src/filesystem/Makefile doc/Makefile po/Makefile testsuite/Makefile python/Makefile\"\n \n \n ac_config_commands=\"$ac_config_commands generate-headers\"\n@@ -79912,6 +80434,10 @@ if test -z \"${GLIBCXX_LDBL_COMPAT_TRUE}\" && test -z \"${GLIBCXX_LDBL_COMPAT_FALSE\n   as_fn_error \"conditional \\\"GLIBCXX_LDBL_COMPAT\\\" was never defined.\n Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n fi\n+if test -z \"${ENABLE_FILESYSTEM_TS_TRUE}\" && test -z \"${ENABLE_FILESYSTEM_TS_FALSE}\"; then\n+  as_fn_error \"conditional \\\"ENABLE_FILESYSTEM_TS\\\" was never defined.\n+Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n+fi\n if test -z \"${BUILD_INFO_TRUE}\" && test -z \"${BUILD_INFO_FALSE}\"; then\n   as_fn_error \"conditional \\\"BUILD_INFO\\\" was never defined.\n Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n@@ -80933,6 +81459,7 @@ do\n     \"src/Makefile\") CONFIG_FILES=\"$CONFIG_FILES src/Makefile\" ;;\n     \"src/c++98/Makefile\") CONFIG_FILES=\"$CONFIG_FILES src/c++98/Makefile\" ;;\n     \"src/c++11/Makefile\") CONFIG_FILES=\"$CONFIG_FILES src/c++11/Makefile\" ;;\n+    \"src/filesystem/Makefile\") CONFIG_FILES=\"$CONFIG_FILES src/filesystem/Makefile\" ;;\n     \"doc/Makefile\") CONFIG_FILES=\"$CONFIG_FILES doc/Makefile\" ;;\n     \"po/Makefile\") CONFIG_FILES=\"$CONFIG_FILES po/Makefile\" ;;\n     \"testsuite/Makefile\") CONFIG_FILES=\"$CONFIG_FILES testsuite/Makefile\" ;;\n@@ -82760,6 +83287,17 @@ _EOF\n  ;;\n     \"src/c++11/Makefile\":F) cat > vpsed$$ << \\_EOF\n s!`test -f '$<' || echo '$(srcdir)/'`!!\n+_EOF\n+   sed -f vpsed$$ $ac_file > tmp$$\n+   mv tmp$$ $ac_file\n+   rm vpsed$$\n+   echo 'MULTISUBDIR =' >> $ac_file\n+   ml_norecursion=yes\n+   . ${multi_basedir}/config-ml.in\n+   { ml_norecursion=; unset ml_norecursion;}\n+ ;;\n+    \"src/filesystem/Makefile\":F) cat > vpsed$$ << \\_EOF\n+s!`test -f '$<' || echo '$(srcdir)/'`!!\n _EOF\n    sed -f vpsed$$ $ac_file > tmp$$\n    mv tmp$$ $ac_file"}, {"sha": "4b39bfa0262d118af35ecbfc330dd82bea397f49", "filename": "libstdc++-v3/configure.ac", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfigure.ac?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -402,6 +402,12 @@ GLIBCXX_CONFIGURE_TESTSUITE\n # For gthread support.  Depends on GLIBCXX_ENABLE_SYMVERS.\n GLIBCXX_CHECK_GTHREADS\n \n+# For Filesystem TS.\n+AC_CHECK_HEADERS([fcntl.h dirent.h sys/statvfs.h])\n+AC_STRUCT_DIRENT_D_TYPE\n+GLIBCXX_ENABLE_FILESYSTEM_TS\n+GLIBCXX_CHECK_FILESYSTEM_DEPS\n+\n # Define documentation rules conditionally.\n \n # See if makeinfo has been installed and is modern enough"}, {"sha": "32be43e7e04c8888cb37121edda0beb25b08fa51", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -128,6 +128,7 @@ bits_headers = \\\n \t${bits_srcdir}/postypes.h \\\n \t${bits_srcdir}/predefined_ops.h \\\n \t${bits_srcdir}/ptr_traits.h \\\n+\t${bits_srcdir}/quoted_string.h \\\n \t${bits_srcdir}/random.h \\\n \t${bits_srcdir}/random.tcc \\\n \t${bits_srcdir}/range_access.h \\\n@@ -663,7 +664,19 @@ experimental_headers = \\\n \t${experimental_srcdir}/type_traits \\\n \t${experimental_srcdir}/unordered_map \\\n \t${experimental_srcdir}/unordered_set \\\n-\t${experimental_srcdir}/vector\n+\t${experimental_srcdir}/vector \\\n+\t${experimental_filesystem_headers}\n+\n+if ENABLE_FILESYSTEM_TS\n+experimental_filesystem_headers = \\\n+\t${experimental_srcdir}/filesystem \\\n+\t${experimental_srcdir}/fs_dir.h \\\n+\t${experimental_srcdir}/fs_fwd.h \\\n+\t${experimental_srcdir}/fs_ops.h \\\n+\t${experimental_srcdir}/fs_path.h\n+else\n+experimental_filesystem_headers =\n+endif\n \n # This is the common subset of C++ files that all three \"C\" header models use.\n c_base_srcdir = $(C_INCLUDE_DIR)"}, {"sha": "e59ee689a26aba77da5fec480a5c76f2866108c3", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -396,6 +396,7 @@ bits_headers = \\\n \t${bits_srcdir}/postypes.h \\\n \t${bits_srcdir}/predefined_ops.h \\\n \t${bits_srcdir}/ptr_traits.h \\\n+\t${bits_srcdir}/quoted_string.h \\\n \t${bits_srcdir}/random.h \\\n \t${bits_srcdir}/random.tcc \\\n \t${bits_srcdir}/range_access.h \\\n@@ -930,7 +931,16 @@ experimental_headers = \\\n \t${experimental_srcdir}/type_traits \\\n \t${experimental_srcdir}/unordered_map \\\n \t${experimental_srcdir}/unordered_set \\\n-\t${experimental_srcdir}/vector\n+\t${experimental_srcdir}/vector \\\n+\t${experimental_filesystem_headers}\n+\n+@ENABLE_FILESYSTEM_TS_FALSE@experimental_filesystem_headers = \n+@ENABLE_FILESYSTEM_TS_TRUE@experimental_filesystem_headers = \\\n+@ENABLE_FILESYSTEM_TS_TRUE@\t${experimental_srcdir}/filesystem \\\n+@ENABLE_FILESYSTEM_TS_TRUE@\t${experimental_srcdir}/fs_dir.h \\\n+@ENABLE_FILESYSTEM_TS_TRUE@\t${experimental_srcdir}/fs_fwd.h \\\n+@ENABLE_FILESYSTEM_TS_TRUE@\t${experimental_srcdir}/fs_ops.h \\\n+@ENABLE_FILESYSTEM_TS_TRUE@\t${experimental_srcdir}/fs_path.h\n \n \n # This is the common subset of C++ files that all three \"C\" header models use."}, {"sha": "8878aa1310b195d790d264a0a88e25a0be32c340", "filename": "libstdc++-v3/include/bits/locale_conv.h", "status": "modified", "additions": 117, "deletions": 56, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_conv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_conv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_conv.h?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -51,6 +51,105 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    * @{\n    */\n \n+  template<typename _OutStr, typename _InChar, typename _Codecvt,\n+\t   typename _State, typename _Fn>\n+    bool\n+    __do_str_codecvt(const _InChar* __first, const _InChar* __last,\n+\t\t     _OutStr& __outstr, const _Codecvt& __cvt, _State& __state,\n+\t\t     size_t& __count, _Fn __fn)\n+    {\n+      size_t __outchars = 0;\n+      auto __next = __first;\n+      const auto __maxlen = __cvt.max_length();\n+\n+      codecvt_base::result __result;\n+      do\n+\t{\n+\t  __outstr.resize(__outstr.size() + (__last - __next) + __maxlen);\n+\t  auto __outnext = &__outstr.front() + __outchars;\n+\t  auto const __outlast = &__outstr.back() + 1;\n+\t  __result = (__cvt.*__fn)(__state, __next, __last, __next,\n+\t\t\t\t\t__outnext, __outlast, __outnext);\n+\t  __outchars = __outnext - &__outstr.front();\n+\t}\n+      while (__result == codecvt_base::partial && __next != __last\n+\t     && (__outstr.size() - __outchars) < __maxlen);\n+\n+      if (__result == codecvt_base::error)\n+\treturn false;\n+\n+      if (__result == codecvt_base::noconv)\n+\t{\n+\t  __outstr.assign(__first, __last);\n+\t  __count = __last - __first;\n+\t}\n+      else\n+\t{\n+\t  __outstr.resize(__outchars);\n+\t  __count = __next - __first;\n+\t}\n+\n+      return true;\n+    }\n+\n+  // Convert narrow character string to wide.\n+  template<typename _CharT, typename _Traits, typename _Alloc, typename _State>\n+    inline bool\n+    __str_codecvt_in(const char* __first, const char* __last,\n+\t\t     basic_string<_CharT, _Traits, _Alloc>& __outstr,\n+\t\t     const codecvt<_CharT, char, _State>& __cvt,\n+\t\t     _State& __state, size_t& __count)\n+    {\n+      using _Codecvt = codecvt<_CharT, char, _State>;\n+      using _ConvFn\n+\t= codecvt_base::result\n+\t  (_Codecvt::*)(_State&, const char*, const char*, const char*&,\n+\t\t\t_CharT*, _CharT*, _CharT*&) const;\n+      _ConvFn __fn = &codecvt<_CharT, char, _State>::in;\n+      return __do_str_codecvt(__first, __last, __outstr, __cvt, __state,\n+\t\t\t      __count, __fn);\n+    }\n+\n+  template<typename _CharT, typename _Traits, typename _Alloc, typename _State>\n+    inline bool\n+    __str_codecvt_in(const char* __first, const char* __last,\n+\t\t     basic_string<_CharT, _Traits, _Alloc>& __outstr,\n+\t\t     const codecvt<_CharT, char, _State>& __cvt)\n+    {\n+      _State __state = {};\n+      size_t __n;\n+      return __str_codecvt_in(__first, __last, __outstr, __cvt, __state, __n);\n+    }\n+\n+  // Convert wide character string to narrow.\n+  template<typename _CharT, typename _Traits, typename _Alloc, typename _State>\n+    inline bool\n+    __str_codecvt_out(const _CharT* __first, const _CharT* __last,\n+\t\t      basic_string<char, _Traits, _Alloc>& __outstr,\n+\t\t      const codecvt<_CharT, char, _State>& __cvt,\n+\t\t      _State& __state, size_t& __count)\n+    {\n+      using _Codecvt = codecvt<_CharT, char, _State>;\n+      using _ConvFn\n+\t= codecvt_base::result\n+\t  (_Codecvt::*)(_State&, const _CharT*, const _CharT*, const _CharT*&,\n+\t\t\tchar*, char*, char*&) const;\n+      _ConvFn __fn = &codecvt<_CharT, char, _State>::out;\n+      return __do_str_codecvt(__first, __last, __outstr, __cvt, __state,\n+\t\t\t      __count, __fn);\n+    }\n+\n+  template<typename _CharT, typename _Traits, typename _Alloc, typename _State>\n+    inline bool\n+    __str_codecvt_out(const _CharT* __first, const _CharT* __last,\n+\t\t      basic_string<char, _Traits, _Alloc>& __outstr,\n+\t\t      const codecvt<_CharT, char, _State>& __cvt)\n+    {\n+      _State __state = {};\n+      size_t __n;\n+      return __str_codecvt_out(__first, __last, __outstr, __cvt, __state, __n);\n+    }\n+\n   /// String conversions\n   template<typename _Codecvt, typename _Elem = wchar_t,\n \t   typename _Wide_alloc = allocator<_Elem>,\n@@ -136,9 +235,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       wide_string\n       from_bytes(const char* __first, const char* __last)\n       {\n-\tauto __errstr = _M_with_strings ? &_M_wide_err_string : nullptr;\n-\t_ConvFn<char, _Elem> __fn = &_Codecvt::in;\n-\treturn _M_conv(__first, __last, __errstr, __fn);\n+\tif (!_M_with_cvtstate)\n+\t  _M_state = state_type();\n+\twide_string __out{ _M_wide_err_string.get_allocator() };\n+\tif (__str_codecvt_in(__first, __last, __out, *_M_cvt, _M_state,\n+\t\t\t     _M_count))\n+\t  return __out;\n+\tif (_M_with_strings)\n+\t  return _M_wide_err_string;\n+\t__throw_range_error(\"wstring_convert::from_bytes\");\n       }\n       /// @}\n \n@@ -166,9 +271,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       byte_string\n       to_bytes(const _Elem* __first, const _Elem* __last)\n       {\n-\tauto __errstr = _M_with_strings ? &_M_byte_err_string : nullptr;\n-\t_ConvFn<_Elem, char> __fn = &_Codecvt::out;\n-\treturn _M_conv(__first, __last, __errstr, __fn);\n+\tif (!_M_with_cvtstate)\n+\t  _M_state = state_type();\n+\tbyte_string __out{ _M_byte_err_string.get_allocator() };\n+\tif (__str_codecvt_out(__first, __last, __out, *_M_cvt, _M_state,\n+\t\t\t      _M_count))\n+\t  return __out;\n+\tif (_M_with_strings)\n+\t  return _M_byte_err_string;\n+\t__throw_range_error(\"wstring_convert::to_bytes\");\n       }\n       /// @}\n \n@@ -181,56 +292,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       state_type state() const { return _M_state; }\n \n     private:\n-      template<typename _InC, typename _OutC>\n-\tusing _ConvFn\n-\t  = codecvt_base::result\n-\t    (_Codecvt::*)(state_type&, const _InC*, const _InC*, const _InC*&,\n-\t\t\t  _OutC*, _OutC*, _OutC*&) const;\n-\n-      template<typename _InChar, typename _OutStr, typename _MemFn>\n-\t_OutStr\n-\t_M_conv(const _InChar* __first, const _InChar* __last,\n-\t\tconst _OutStr* __err, _MemFn __memfn)\n-\t{\n-\t  if (!_M_with_cvtstate)\n-\t    _M_state = state_type();\n-\n-\t  auto __outstr = __err ? _OutStr(__err->get_allocator()) : _OutStr();\n-\t  size_t __outchars = 0;\n-\t  auto __next = __first;\n-\t  const auto __maxlen = _M_cvt->max_length();\n-\n-\t  codecvt_base::result __result;\n-\t  do\n-\t    {\n-\t      __outstr.resize(__outstr.size() + (__last - __next) + __maxlen);\n-\t      auto __outnext = &__outstr.front() + __outchars;\n-\t      auto const __outlast = &__outstr.back() + 1;\n-\t      __result = ((*_M_cvt).*__memfn)(_M_state, __next, __last, __next,\n-\t\t\t\t\t    __outnext, __outlast, __outnext);\n-\t      __outchars = __outnext - &__outstr.front();\n-\t    }\n-\t  while (__result == codecvt_base::partial && __next != __last\n-\t\t && (__outstr.size() - __outchars) < __maxlen);\n-\n-\t  if (__result == codecvt_base::noconv)\n-\t    {\n-\t      __outstr.assign(__first, __last);\n-\t      _M_count = __outstr.size();\n-\t      return __outstr;\n-\t    }\n-\n-\t  __outstr.resize(__outchars);\n-\t  _M_count = __next - __first;\n-\n-\t  if (__result != codecvt_base::error)\n-\t    return __outstr;\n-\t  else if (__err)\n-\t    return *__err;\n-\t  else\n-\t    __throw_range_error(\"wstring_convert\");\n-\t}\n-\n       unique_ptr<_Codecvt>\t_M_cvt;\n       byte_string\t\t_M_byte_err_string;\n       wide_string\t\t_M_wide_err_string;"}, {"sha": "0805e08cc43870a766a037425bfbf72e8ee1776b", "filename": "libstdc++-v3/include/bits/quoted_string.h", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fquoted_string.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fquoted_string.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fquoted_string.h?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -0,0 +1,164 @@\n+// Helpers for quoted stream manipulators -*- C++ -*-\n+\n+// Copyright (C) 2013-2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file bits/quoted_string.h\n+ *  This is an internal header file, included by other library headers.\n+ *  Do not attempt to use it directly. @headername{iomanip}\n+ */\n+\n+#ifndef _GLIBCXX_QUOTED_STRING_H\n+#define _GLIBCXX_QUOTED_STRING_H 1\n+\n+#pragma GCC system_header\n+\n+#if __cplusplus < 201103L\n+# include <bits/c++0x_warning.h>\n+#else\n+#include <sstream>\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+  namespace __detail {\n+  _GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+    /**\n+     * @brief Struct for delimited strings.\n+     */\n+    template<typename _String, typename _CharT>\n+      struct _Quoted_string\n+      {\n+\tstatic_assert(is_reference<_String>::value\n+\t\t   || is_pointer<_String>::value,\n+\t\t      \"String type must be pointer or reference\");\n+\n+\t_Quoted_string(_String __str, _CharT __del, _CharT __esc)\n+\t: _M_string(__str), _M_delim{__del}, _M_escape{__esc}\n+\t{ }\n+\n+\t_Quoted_string&\n+\toperator=(_Quoted_string&) = delete;\n+\n+\t_String _M_string;\n+\t_CharT _M_delim;\n+\t_CharT _M_escape;\n+      };\n+\n+    /**\n+     * @brief Inserter for quoted strings.\n+     *\n+     *  _GLIBCXX_RESOLVE_LIB_DEFECTS\n+     *  DR 2344 quoted()'s interaction with padding is unclear\n+     */\n+    template<typename _CharT, typename _Traits>\n+      std::basic_ostream<_CharT, _Traits>&\n+      operator<<(std::basic_ostream<_CharT, _Traits>& __os,\n+\t\t const _Quoted_string<const _CharT*, _CharT>& __str)\n+      {\n+\tstd::basic_ostringstream<_CharT, _Traits> __ostr;\n+\t__ostr << __str._M_delim;\n+\tfor (const _CharT* __c = __str._M_string; *__c; ++__c)\n+\t  {\n+\t    if (*__c == __str._M_delim || *__c == __str._M_escape)\n+\t      __ostr << __str._M_escape;\n+\t    __ostr << *__c;\n+\t  }\n+\t__ostr << __str._M_delim;\n+\n+\treturn __os << __ostr.str();\n+      }\n+\n+    /**\n+     * @brief Inserter for quoted strings.\n+     *\n+     *  _GLIBCXX_RESOLVE_LIB_DEFECTS\n+     *  DR 2344 quoted()'s interaction with padding is unclear\n+     */\n+    template<typename _CharT, typename _Traits, typename _String>\n+      std::basic_ostream<_CharT, _Traits>&\n+      operator<<(std::basic_ostream<_CharT, _Traits>& __os,\n+\t\t const _Quoted_string<_String, _CharT>& __str)\n+      {\n+\tstd::basic_ostringstream<_CharT, _Traits> __ostr;\n+\t__ostr << __str._M_delim;\n+\tfor (auto& __c : __str._M_string)\n+\t  {\n+\t    if (__c == __str._M_delim || __c == __str._M_escape)\n+\t      __ostr << __str._M_escape;\n+\t    __ostr << __c;\n+\t  }\n+\t__ostr << __str._M_delim;\n+\n+\treturn __os << __ostr.str();\n+      }\n+\n+    /**\n+     * @brief Extractor for delimited strings.\n+     *        The left and right delimiters can be different.\n+     */\n+    template<typename _CharT, typename _Traits, typename _Alloc>\n+      std::basic_istream<_CharT, _Traits>&\n+      operator>>(std::basic_istream<_CharT, _Traits>& __is,\n+\t\t const _Quoted_string<basic_string<_CharT, _Traits, _Alloc>&,\n+\t\t\t\t      _CharT>& __str)\n+      {\n+\t_CharT __c;\n+\t__is >> __c;\n+\tif (!__is.good())\n+\t  return __is;\n+\tif (__c != __str._M_delim)\n+\t  {\n+\t    __is.unget();\n+\t    __is >> __str._M_string;\n+\t    return __is;\n+\t  }\n+\t__str._M_string.clear();\n+\tstd::ios_base::fmtflags __flags\n+\t  = __is.flags(__is.flags() & ~std::ios_base::skipws);\n+\tdo\n+\t  {\n+\t    __is >> __c;\n+\t    if (!__is.good())\n+\t      break;\n+\t    if (__c == __str._M_escape)\n+\t      {\n+\t\t__is >> __c;\n+\t\tif (!__is.good())\n+\t\t  break;\n+\t      }\n+\t    else if (__c == __str._M_delim)\n+\t      break;\n+\t    __str._M_string += __c;\n+\t  }\n+\twhile (true);\n+\t__is.setf(__flags);\n+\n+\treturn __is;\n+      }\n+\n+  _GLIBCXX_END_NAMESPACE_VERSION\n+  } // namespace __detail\n+} // namespace std\n+\n+#endif // C++11\n+#endif /* _GLIBCXX_QUOTED_STRING_H */"}, {"sha": "db7ab1117da5cb6ec08fe22eb50e60d0273d0bf8", "filename": "libstdc++-v3/include/experimental/filesystem", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Ffilesystem", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Ffilesystem", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Ffilesystem?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -0,0 +1,77 @@\n+// <experimental/filesystem> -*- C++ -*-\n+\n+// Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file experimental/filesystem\n+ *  This is a TS C++ Library header.\n+ */\n+\n+#ifndef _GLIBCXX_EXPERIMENTAL_FILESYSTEM\n+#define _GLIBCXX_EXPERIMENTAL_FILESYSTEM 1\n+\n+#pragma GCC system_header\n+\n+#if __cplusplus < 201103L\n+# include <bits/c++0x_warning.h>\n+#else\n+\n+#include <experimental/fs_fwd.h>\n+#include <experimental/fs_path.h>\n+#include <experimental/fs_dir.h>\n+#include <experimental/fs_ops.h>\n+\n+#define __cpp_lib_experimental_filesystem 201406\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+namespace experimental\n+{\n+namespace filesystem\n+{\n+inline namespace v1\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  /**\n+   * @ingroup filesystem\n+   */\n+    inline std::string filesystem_error::_M_gen_what()\n+    {\n+      std::string __what = \"filesystem error: \";\n+      __what += system_error::what();\n+      if (!_M_path1.empty())\n+\t  __what += \" [\" + _M_path1.string() + ']';\n+      if (!_M_path2.empty())\n+\t  __what += \" [\" + _M_path2.string() + ']';\n+      return __what;\n+    }\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace v1\n+} // namespace filesystem\n+} // namespace experimental\n+} // namespace std\n+\n+#endif // C++11\n+\n+#endif // _GLIBCXX_EXPERIMENTAL_FILESYSTEM"}, {"sha": "0538fd2a69736de08f061f47298d8a24a8def038", "filename": "libstdc++-v3/include/experimental/fs_dir.h", "status": "added", "additions": 326, "deletions": 0, "changes": 326, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Ffs_dir.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Ffs_dir.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Ffs_dir.h?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -0,0 +1,326 @@\n+// Filesystem directory utilities -*- C++ -*-\n+\n+// Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file experimental/fs_dir.h\n+ *  This is an internal header file, included by other library headers.\n+ *  Do not attempt to use it directly. @headername{experimental/filesystem}\n+ */\n+\n+#ifndef _GLIBCXX_EXPERIMENTAL_FS_DIR_H\n+#define _GLIBCXX_EXPERIMENTAL_FS_DIR_H 1\n+\n+#if __cplusplus < 201103L\n+# include <bits/c++0x_warning.h>\n+#else\n+# include <typeinfo>\n+# include <ext/concurrence.h>\n+# include <bits/unique_ptr.h>\n+# include <bits/shared_ptr.h>\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+namespace experimental\n+{\n+namespace filesystem\n+{\n+inline namespace v1\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  /**\n+   * @ingroup filesystem\n+   * @{\n+   */\n+\n+  class file_status\n+  {\n+  public:\n+    // constructors\n+    explicit\n+    file_status(file_type __ft = file_type::none,\n+\t        perms __prms = perms::unknown) noexcept\n+    : _M_type(__ft), _M_perms(__prms) { }\n+\n+    file_status(const file_status&) noexcept = default;\n+    file_status(file_status&&) noexcept = default;\n+    ~file_status() = default;\n+\n+    file_status& operator=(const file_status&) noexcept = default;\n+    file_status& operator=(file_status&&) noexcept = default;\n+\n+    // observers\n+    file_type  type() const noexcept { return _M_type; }\n+    perms      permissions() const noexcept { return _M_perms; }\n+\n+    // modifiers\n+    void       type(file_type __ft) noexcept { _M_type = __ft; }\n+    void       permissions(perms __prms) noexcept { _M_perms = __prms; }\n+\n+  private:\n+    file_type\t_M_type;\n+    perms\t_M_perms;\n+  };\n+\n+_GLIBCXX_BEGIN_NAMESPACE_CXX11\n+\n+  class directory_entry\n+  {\n+  public:\n+    // constructors and destructor\n+    directory_entry() noexcept = default;\n+    directory_entry(const directory_entry&) = default;\n+    directory_entry(directory_entry&&) noexcept = default;\n+    explicit directory_entry(const filesystem::path& __p) : _M_path(__p) { }\n+    ~directory_entry() = default;\n+\n+    // modifiers\n+    directory_entry& operator=(const directory_entry&) = default;\n+    directory_entry& operator=(directory_entry&&) noexcept = default;\n+\n+    void assign(const filesystem::path& __p) { _M_path = __p; }\n+\n+    void\n+    replace_filename(const filesystem::path& __p)\n+    { _M_path = _M_path.parent_path() / __p; }\n+\n+    // observers\n+    const filesystem::path&  path() const noexcept { return _M_path; }\n+    operator const filesystem::path&() const noexcept { return _M_path; }\n+\n+    file_status\n+    status() const\n+    { return filesystem::status(_M_path); }\n+\n+    file_status\n+    status(error_code& __ec) const noexcept\n+    { return filesystem::status(_M_path, __ec); }\n+\n+    file_status\n+    symlink_status() const\n+    { return filesystem::symlink_status(_M_path); }\n+\n+    file_status\n+    symlink_status(error_code& __ec) const noexcept\n+    { return filesystem::symlink_status(_M_path, __ec); }\n+\n+    bool\n+    operator< (const directory_entry& __rhs) const noexcept\n+    { return _M_path < __rhs._M_path; }\n+\n+    bool\n+    operator==(const directory_entry& __rhs) const noexcept\n+    { return _M_path == __rhs._M_path; }\n+\n+    bool\n+    operator!=(const directory_entry& __rhs) const noexcept\n+    { return _M_path != __rhs._M_path; }\n+\n+    bool\n+    operator<=(const directory_entry& __rhs) const noexcept\n+    { return _M_path <= __rhs._M_path; }\n+\n+    bool\n+    operator> (const directory_entry& __rhs) const noexcept\n+    { return _M_path > __rhs._M_path; }\n+\n+    bool\n+    operator>=(const directory_entry& __rhs) const noexcept\n+    { return _M_path >= __rhs._M_path; }\n+\n+  private:\n+    filesystem::path    _M_path;\n+  };\n+\n+  struct _Dir;\n+  class recursive_directory_iterator;\n+\n+  class directory_iterator\n+  {\n+  public:\n+    typedef directory_entry        value_type;\n+    typedef ptrdiff_t              difference_type;\n+    typedef const directory_entry* pointer;\n+    typedef const directory_entry& reference;\n+    typedef input_iterator_tag     iterator_category;\n+\n+    directory_iterator() noexcept = default;\n+\n+    explicit\n+    directory_iterator(const path& __p)\n+    : directory_iterator(__p, directory_options::none, nullptr) { }\n+\n+    directory_iterator(const path& __p, directory_options __options)\n+    : directory_iterator(__p, __options, nullptr) { }\n+\n+    directory_iterator(const path& __p, error_code& __ec) noexcept\n+    : directory_iterator(__p, directory_options::none, __ec) { }\n+\n+    directory_iterator(const path& __p,\n+      directory_options __options, error_code& __ec) noexcept\n+    : directory_iterator(__p, __options, &__ec) { }\n+\n+    directory_iterator(const directory_iterator& rhs) = default;\n+\n+    directory_iterator(directory_iterator&& rhs) noexcept = default;\n+\n+    ~directory_iterator() = default;\n+\n+    directory_iterator& operator=(const directory_iterator& rhs) = default;\n+    directory_iterator& operator=(directory_iterator&& rhs) noexcept = default;\n+\n+    const directory_entry& operator*() const;\n+    const directory_entry* operator->() const { return &**this; }\n+    directory_iterator&    operator++();\n+    directory_iterator&    increment(error_code& __ec) noexcept;\n+\n+    directory_iterator operator++(int)\n+    {\n+      auto __tmp = *this;\n+      ++*this;\n+      return __tmp;\n+    }\n+\n+    friend bool\n+    operator==(const directory_iterator& __lhs,\n+               const directory_iterator& __rhs)\n+    { return __lhs._M_dir == __rhs._M_dir; }\n+\n+  private:\n+    directory_iterator(const path&, directory_options, error_code*);\n+    directory_iterator(std::shared_ptr<_Dir>, error_code*);\n+\n+    friend class recursive_directory_iterator;\n+\n+    std::shared_ptr<_Dir> _M_dir;\n+  };\n+\n+  inline directory_iterator\n+  begin(directory_iterator __iter) { return __iter; }\n+\n+  inline directory_iterator\n+  end(directory_iterator) { return directory_iterator(); }\n+\n+  inline bool\n+  operator!=(const directory_iterator& __lhs, const directory_iterator& __rhs)\n+  { return !(__lhs == __rhs); }\n+\n+  class recursive_directory_iterator\n+  {\n+  public:\n+    typedef directory_entry        value_type;\n+    typedef ptrdiff_t              difference_type;\n+    typedef const directory_entry* pointer;\n+    typedef const directory_entry& reference;\n+    typedef input_iterator_tag     iterator_category;\n+\n+    recursive_directory_iterator() noexcept = default;\n+\n+    explicit\n+    recursive_directory_iterator(const path& __p)\n+    : recursive_directory_iterator(__p, directory_options::none, nullptr) { }\n+\n+    recursive_directory_iterator(const path& __p, directory_options __options)\n+    : recursive_directory_iterator(__p, __options, nullptr) { }\n+\n+    recursive_directory_iterator(const path& __p,\n+                                 directory_options __options,\n+                                 error_code& __ec) noexcept\n+    : recursive_directory_iterator(__p, __options, &__ec) { }\n+\n+    recursive_directory_iterator(const path& __p, error_code& __ec) noexcept\n+    : recursive_directory_iterator(__p, directory_options::none, &__ec) { }\n+\n+    recursive_directory_iterator(\n+        const recursive_directory_iterator&) = default;\n+\n+    recursive_directory_iterator(\n+        recursive_directory_iterator&&) noexcept = default;\n+\n+    ~recursive_directory_iterator();\n+\n+    // observers\n+    directory_options  options() const { return _M_options; }\n+    int                depth() const;\n+    bool               recursion_pending() const { return _M_pending; }\n+\n+    const directory_entry& operator*() const;\n+    const directory_entry* operator->() const { return &**this; }\n+\n+    // modifiers\n+    recursive_directory_iterator&\n+      operator=(const recursive_directory_iterator& rhs) noexcept;\n+    recursive_directory_iterator&\n+      operator=(recursive_directory_iterator&& rhs) noexcept;\n+\n+    recursive_directory_iterator& operator++();\n+    recursive_directory_iterator& increment(error_code& __ec) noexcept;\n+\n+    recursive_directory_iterator operator++(int)\n+    {\n+      auto __tmp = *this;\n+      ++*this;\n+      return __tmp;\n+    }\n+\n+    void pop();\n+\n+    void disable_recursion_pending() { _M_pending = false; }\n+\n+    friend bool\n+    operator==(const recursive_directory_iterator& __lhs,\n+               const recursive_directory_iterator& __rhs)\n+    { return __lhs._M_dirs == __rhs._M_dirs; }\n+\n+  private:\n+    recursive_directory_iterator(const path&, directory_options, error_code*);\n+\n+    struct _Dir_stack;\n+    std::shared_ptr<_Dir_stack> _M_dirs;\n+    directory_options _M_options;\n+    bool _M_pending;\n+  };\n+\n+  inline recursive_directory_iterator\n+  begin(recursive_directory_iterator __iter) { return __iter; }\n+\n+  inline recursive_directory_iterator\n+  end(recursive_directory_iterator) { return recursive_directory_iterator(); }\n+\n+  inline bool\n+  operator!=(const recursive_directory_iterator& __lhs,\n+             const recursive_directory_iterator& __rhs)\n+  { return !(__lhs == __rhs); }\n+\n+_GLIBCXX_END_NAMESPACE_CXX11\n+\n+  // @} group filesystem\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace v1\n+} // namespace filesystem\n+} // namespace experimental\n+} // namespace std\n+\n+#endif // C++11\n+\n+#endif // _GLIBCXX_EXPERIMENTAL_FS_DIR_H"}, {"sha": "a5ed2c5de0ef285aea2c1a8e554bc1d6ecda3ce4", "filename": "libstdc++-v3/include/experimental/fs_fwd.h", "status": "added", "additions": 289, "deletions": 0, "changes": 289, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Ffs_fwd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Ffs_fwd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Ffs_fwd.h?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -0,0 +1,289 @@\n+// Filesystem declarations -*- C++ -*-\n+\n+// Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file experimental/filesystem\n+ *  This is a TS C++ Library header.\n+ */\n+\n+#ifndef _GLIBCXX_EXPERIMENTAL_FS_FWD_H\n+#define _GLIBCXX_EXPERIMENTAL_FS_FWD_H 1\n+\n+#if __cplusplus < 201103L\n+# include <bits/c++0x_warning.h>\n+#else\n+\n+#include <system_error>\n+#include <cstdint>\n+#include <chrono>\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+namespace experimental\n+{\n+namespace filesystem\n+{\n+inline namespace v1\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+#if _GLIBCXX_USE_CXX11_ABI\n+  inline namespace __cxx11 __attribute__((__abi_tag__ (\"cxx11\"))) { }\n+#endif\n+\n+  /**\n+   * @defgroup filesystem\n+   * @ingroup experimental\n+   *\n+   * Utilities for performing operations on file systems and their components,\n+   * such as paths, regular files, and directories.\n+   *\n+   * @{\n+   */\n+\n+  class file_status;\n+_GLIBCXX_BEGIN_NAMESPACE_CXX11\n+  class path;\n+  class filesystem_error;\n+  class directory_entry;\n+  class directory_iterator;\n+  class recursive_directory_iterator;\n+_GLIBCXX_END_NAMESPACE_CXX11\n+\n+  struct space_info\n+  {\n+    uintmax_t capacity;\n+    uintmax_t free;\n+    uintmax_t available;\n+  };\n+\n+  enum class file_type : signed char {\n+      none = 0, not_found = -1, regular = 1, directory = 2, symlink = 3,\n+      block = 4, character = 5, fifo = 6, socket = 7, unknown = 8\n+  };\n+\n+  /// Bitmask type\n+  enum class copy_options : unsigned short {\n+      none = 0,\n+      skip_existing = 1, overwrite_existing = 2, update_existing = 4,\n+      recursive = 8,\n+      copy_symlinks = 16, skip_symlinks = 32,\n+      directories_only = 64, create_symlinks = 128, create_hard_links = 256\n+  };\n+\n+  constexpr copy_options\n+  operator&(copy_options __x, copy_options __y)\n+  {\n+    using __utype = typename std::underlying_type<copy_options>::type;\n+    return static_cast<copy_options>(\n+\tstatic_cast<__utype>(__x) & static_cast<__utype>(__y));\n+  }\n+\n+  constexpr copy_options\n+  operator|(copy_options __x, copy_options __y)\n+  {\n+    using __utype = typename std::underlying_type<copy_options>::type;\n+    return static_cast<copy_options>(\n+\tstatic_cast<__utype>(__x) | static_cast<__utype>(__y));\n+  }\n+\n+  constexpr copy_options\n+  operator^(copy_options __x, copy_options __y)\n+  {\n+    using __utype = typename std::underlying_type<copy_options>::type;\n+    return static_cast<copy_options>(\n+\tstatic_cast<__utype>(__x) ^ static_cast<__utype>(__y));\n+  }\n+\n+  constexpr copy_options\n+  operator~(copy_options __x)\n+  {\n+    using __utype = typename std::underlying_type<copy_options>::type;\n+    return static_cast<copy_options>(~static_cast<__utype>(__x));\n+  }\n+\n+  inline copy_options&\n+  operator&=(copy_options& __x, copy_options __y)\n+  { return __x = __x & __y; }\n+\n+  inline copy_options&\n+  operator|=(copy_options& __x, copy_options __y)\n+  { return __x = __x | __y; }\n+\n+  inline copy_options&\n+  operator^=(copy_options& __x, copy_options __y)\n+  { return __x = __x ^ __y; }\n+\n+\n+  /// Bitmask type\n+  enum class perms : unsigned {\n+      none\t\t=  0,\n+      owner_read\t=  0400,\n+      owner_write\t=  0200,\n+      owner_exec\t=  0100,\n+      owner_all\t\t=  0700,\n+      group_read\t=   040,\n+      group_write\t=   020,\n+      group_exec\t=   010,\n+      group_all\t\t=   070,\n+      others_read\t=    04,\n+      others_write\t=    02,\n+      others_exec\t=    01,\n+      others_all\t=    07,\n+      all\t\t=  0777,\n+      set_uid\t\t= 04000,\n+      set_gid\t\t= 02000,\n+      sticky_bit\t= 01000,\n+      mask\t\t= 07777,\n+      unknown\t\t=  0xFFFF,\n+      add_perms\t\t= 0x10000,\n+      remove_perms\t= 0x20000,\n+      resolve_symlinks\t= 0x40000\n+  };\n+\n+  constexpr perms\n+  operator&(perms __x, perms __y)\n+  {\n+    using __utype = typename std::underlying_type<perms>::type;\n+    return static_cast<perms>(\n+\tstatic_cast<__utype>(__x) & static_cast<__utype>(__y));\n+  }\n+\n+  constexpr perms\n+  operator|(perms __x, perms __y)\n+  {\n+    using __utype = typename std::underlying_type<perms>::type;\n+    return static_cast<perms>(\n+\tstatic_cast<__utype>(__x) | static_cast<__utype>(__y));\n+  }\n+\n+  constexpr perms\n+  operator^(perms __x, perms __y)\n+  {\n+    using __utype = typename std::underlying_type<perms>::type;\n+    return static_cast<perms>(\n+\tstatic_cast<__utype>(__x) ^ static_cast<__utype>(__y));\n+  }\n+\n+  constexpr perms\n+  operator~(perms __x)\n+  {\n+    using __utype = typename std::underlying_type<perms>::type;\n+    return static_cast<perms>(~static_cast<__utype>(__x));\n+  }\n+\n+  inline perms&\n+  operator&=(perms& __x, perms __y)\n+  { return __x = __x & __y; }\n+\n+  inline perms&\n+  operator|=(perms& __x, perms __y)\n+  { return __x = __x | __y; }\n+\n+  inline perms&\n+  operator^=(perms& __x, perms __y)\n+  { return __x = __x ^ __y; }\n+\n+  // Bitmask type\n+  enum class directory_options : unsigned char {\n+      none = 0, follow_directory_symlink = 1, skip_permission_denied = 2\n+  };\n+\n+  constexpr directory_options\n+  operator&(directory_options __x, directory_options __y)\n+  {\n+    using __utype = typename std::underlying_type<directory_options>::type;\n+    return static_cast<directory_options>(\n+\tstatic_cast<__utype>(__x) & static_cast<__utype>(__y));\n+  }\n+\n+  constexpr directory_options\n+  operator|(directory_options __x, directory_options __y)\n+  {\n+    using __utype = typename std::underlying_type<directory_options>::type;\n+    return static_cast<directory_options>(\n+\tstatic_cast<__utype>(__x) | static_cast<__utype>(__y));\n+  }\n+\n+  constexpr directory_options\n+  operator^(directory_options __x, directory_options __y)\n+  {\n+    using __utype = typename std::underlying_type<directory_options>::type;\n+    return static_cast<directory_options>(\n+\tstatic_cast<__utype>(__x) ^ static_cast<__utype>(__y));\n+  }\n+\n+  constexpr directory_options\n+  operator~(directory_options __x)\n+  {\n+    using __utype = typename std::underlying_type<directory_options>::type;\n+    return static_cast<directory_options>(~static_cast<__utype>(__x));\n+  }\n+\n+  inline directory_options&\n+  operator&=(directory_options& __x, directory_options __y)\n+  { return __x = __x & __y; }\n+\n+  inline directory_options&\n+  operator|=(directory_options& __x, directory_options __y)\n+  { return __x = __x | __y; }\n+\n+  inline directory_options&\n+  operator^=(directory_options& __x, directory_options __y)\n+  { return __x = __x ^ __y; }\n+\n+  typedef chrono::time_point<chrono::system_clock> file_time_type;\n+\n+  // operational functions\n+\n+  void copy(const path& __from, const path& __to, copy_options __options);\n+  void copy(const path& __from, const path& __to, copy_options __options,\n+\t    error_code&) noexcept;\n+\n+  bool copy_file(const path& __from, const path& __to, copy_options __option);\n+  bool copy_file(const path& __from, const path& __to, copy_options __option,\n+\t\t error_code&) noexcept;\n+\n+  path current_path();\n+\n+  file_status status(const path&);\n+  file_status status(const path&, error_code&) noexcept;\n+\n+  bool status_known(file_status) noexcept;\n+\n+  file_status symlink_status(const path&);\n+  file_status symlink_status(const path&, error_code&) noexcept;\n+\n+  bool is_regular_file(file_status) noexcept;\n+  bool is_symlink(file_status) noexcept;\n+\n+  // @} group filesystem\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace v1\n+} // namespace filesystem\n+} // namespace experimental\n+} // namespace std\n+\n+#endif // C++11\n+\n+#endif // _GLIBCXX_EXPERIMENTAL_FS_FWD_H"}, {"sha": "0878fbb8f8dff462fff7b60fc2f5597598fa64e6", "filename": "libstdc++-v3/include/experimental/fs_ops.h", "status": "added", "additions": 291, "deletions": 0, "changes": 291, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Ffs_ops.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Ffs_ops.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Ffs_ops.h?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -0,0 +1,291 @@\n+// Filesystem operational functions -*- C++ -*-\n+\n+// Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your __option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file experimental/filesystem\n+ *  This is a TS C++ Library header.\n+ */\n+\n+#ifndef _GLIBCXX_EXPERIMENTAL_FS_OPS_H\n+#define _GLIBCXX_EXPERIMENTAL_FS_OPS_H 1\n+\n+#if __cplusplus < 201103L\n+# include <bits/c++0x_warning.h>\n+#else\n+\n+#include <cstdint>\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+namespace experimental\n+{\n+namespace filesystem\n+{\n+inline namespace v1\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  /**\n+   * @ingroup filesystem\n+   * @{\n+   */\n+\n+  path absolute(const path& __p, const path& __base = current_path());\n+\n+  path canonical(const path& __p, const path& __base = current_path());\n+  path canonical(const path& p, error_code& ec);\n+  path canonical(const path& p, const path& base, error_code& ec);\n+\n+  inline void\n+  copy(const path& __from, const path& __to)\n+  { copy(__from, __to, copy_options::none); }\n+\n+  inline void\n+  copy(const path& __from, const path& __to, error_code& __ec) noexcept\n+  { copy(__from, __to, copy_options::none, __ec); }\n+\n+  void copy(const path& __from, const path& __to, copy_options options);\n+  void copy(const path& __from, const path& __to, copy_options options,\n+\t    error_code& __ec) noexcept;\n+\n+  inline bool\n+  copy_file(const path& __from, const path& __to)\n+  { return copy_file(__from, __to, copy_options::none); }\n+\n+  inline bool\n+  copy_file(const path& __from, const path& __to, error_code& __ec) noexcept\n+  { return copy_file(__from, __to, copy_options::none, __ec); }\n+\n+  bool copy_file(const path& __from, const path& __to, copy_options __option);\n+  bool copy_file(const path& __from, const path& __to, copy_options __option,\n+\t\t error_code& __ec) noexcept;\n+\n+  void copy_symlink(const path& __existing_symlink, const path& __new_symlink);\n+  void copy_symlink(const path& __existing_symlink, const path& __new_symlink,\n+\t\t    error_code& __ec) noexcept;\n+\n+  bool create_directories(const path& __p);\n+  bool create_directories(const path& __p, error_code& __ec) noexcept;\n+\n+  bool create_directory(const path& __p);\n+  bool create_directory(const path& __p, error_code& __ec) noexcept;\n+\n+  bool create_directory(const path& __p, const path& attributes);\n+  bool create_directory(const path& __p, const path& attributes,\n+\t\t\terror_code& __ec) noexcept;\n+\n+  void create_directory_symlink(const path& __to, const path& __new_symlink);\n+  void create_directory_symlink(const path& __to, const path& __new_symlink,\n+\t\t\t\terror_code& __ec) noexcept;\n+\n+  void create_hard_link(const path& __to, const path& __new_hard_link);\n+  void create_hard_link(const path& __to, const path& __new_hard_link,\n+\t\t\terror_code& __ec) noexcept;\n+\n+  void create_symlink(const path& __to, const path& __new_symlink);\n+  void create_symlink(const path& __to, const path& __new_symlink,\n+\t\t      error_code& __ec) noexcept;\n+\n+  path current_path();\n+  path current_path(error_code& __ec);\n+  void current_path(const path& __p);\n+  void current_path(const path& __p, error_code& __ec) noexcept;\n+\n+  inline bool\n+  exists(file_status __s) noexcept\n+  { return status_known(__s) && __s.type() != file_type::not_found; }\n+\n+  inline bool\n+  exists(const path& __p)\n+  { return exists(status(__p)); }\n+\n+  inline bool\n+  exists(const path& __p, error_code& __ec) noexcept\n+  { return exists(status(__p, __ec)); }\n+\n+  bool\n+  equivalent(const path& __p1, const path& __p2);\n+\n+  bool\n+  equivalent(const path& __p1, const path& __p2, error_code& __ec) noexcept;\n+\n+  uintmax_t file_size(const path& __p);\n+  uintmax_t file_size(const path& __p, error_code& __ec) noexcept;\n+\n+  uintmax_t hard_link_count(const path& __p);\n+  uintmax_t hard_link_count(const path& __p, error_code& __ec) noexcept;\n+\n+  inline bool\n+  is_block_file(file_status __s) noexcept\n+  { return __s.type() == file_type::block; }\n+\n+  inline bool\n+  is_block_file(const path& __p)\n+  { return is_block_file(status(__p)); }\n+\n+  inline bool\n+  is_block_file(const path& __p, error_code& __ec) noexcept\n+  { return is_block_file(status(__p, __ec)); }\n+\n+  inline bool\n+  is_character_file(file_status __s) noexcept\n+  { return __s.type() == file_type::character; }\n+\n+  inline bool\n+  is_character_file(const path& __p)\n+  { return is_character_file(status(__p)); }\n+\n+  inline bool\n+  is_character_file(const path& __p, error_code& __ec) noexcept\n+  { return is_character_file(status(__p, __ec)); }\n+\n+  inline bool\n+  is_directory(file_status __s) noexcept\n+  { return __s.type() == file_type::directory; }\n+\n+  inline bool\n+  is_directory(const path& __p)\n+  { return is_directory(status(__p)); }\n+\n+  inline bool\n+  is_directory(const path& __p, error_code& __ec) noexcept\n+  { return is_directory(status(__p, __ec)); }\n+\n+  bool is_empty(const path& __p);\n+  bool is_empty(const path& __p, error_code& __ec) noexcept;\n+\n+  inline bool\n+  is_fifo(file_status __s) noexcept\n+  { return __s.type() == file_type::fifo; }\n+\n+  inline bool\n+  is_fifo(const path& __p)\n+  { return is_fifo(status(__p)); }\n+\n+  inline bool\n+  is_fifo(const path& __p, error_code& __ec) noexcept\n+  { return is_fifo(status(__p, __ec)); }\n+\n+  inline bool\n+  is_other(file_status __s) noexcept\n+  {\n+    return exists(__s) && !is_regular_file(__s) && !is_directory(__s)\n+      && !is_symlink(__s);\n+  }\n+\n+  inline bool\n+  is_other(const path& __p)\n+  { return is_other(status(__p)); }\n+\n+  inline bool\n+  is_other(const path& __p, error_code& __ec) noexcept\n+  { return is_other(status(__p, __ec)); }\n+\n+  inline bool\n+  is_regular_file(file_status __s) noexcept\n+  { return __s.type() == file_type::regular; }\n+\n+  inline bool\n+  is_regular_file(const path& __p)\n+  { return is_regular_file(status(__p)); }\n+\n+  inline bool\n+  is_regular_file(const path& __p, error_code& __ec) noexcept\n+  { return is_regular_file(status(__p, __ec)); }\n+\n+  inline bool\n+  is_socket(file_status __s) noexcept\n+  { return __s.type() == file_type::socket; }\n+\n+  inline bool\n+  is_socket(const path& __p)\n+  { return is_socket(status(__p)); }\n+\n+  inline bool\n+  is_socket(const path& __p, error_code& __ec) noexcept\n+  { return is_socket(status(__p, __ec)); }\n+\n+  inline bool\n+  is_symlink(file_status __s) noexcept\n+  { return __s.type() == file_type::symlink; }\n+\n+  inline bool\n+  is_symlink(const path& __p)\n+  { return is_symlink(symlink_status(__p)); }\n+\n+  inline bool\n+  is_symlink(const path& __p, error_code& __ec) noexcept\n+  { return is_symlink(symlink_status(__p, __ec)); }\n+\n+  file_time_type  last_write_time(const path& __p);\n+  file_time_type  last_write_time(const path& __p, error_code& __ec) noexcept;\n+  void last_write_time(const path& __p, file_time_type new_time);\n+  void last_write_time(const path& __p, file_time_type new_time,\n+\t\t       error_code& __ec) noexcept;\n+\n+  void permissions(const path& __p, perms prms);\n+  void permissions(const path& __p, perms prms, error_code& __ec) noexcept;\n+\n+  path read_symlink(const path& __p);\n+  path read_symlink(const path& __p, error_code& __ec);\n+\n+  bool remove(const path& __p);\n+  bool remove(const path& __p, error_code& __ec) noexcept;\n+\n+  uintmax_t remove_all(const path& __p);\n+  uintmax_t remove_all(const path& __p, error_code& __ec) noexcept;\n+\n+  void rename(const path& __from, const path& __to);\n+  void rename(const path& __from, const path& __to, error_code& __ec) noexcept;\n+\n+  void resize_file(const path& __p, uintmax_t __size);\n+  void resize_file(const path& __p, uintmax_t __size, error_code& __ec) noexcept;\n+\n+  space_info space(const path& __p);\n+  space_info space(const path& __p, error_code& __ec) noexcept;\n+\n+  file_status status(const path& __p);\n+  file_status status(const path& __p, error_code& __ec) noexcept;\n+\n+  inline bool status_known(file_status __s) noexcept\n+  { return __s.type() != file_type::none; }\n+\n+  file_status symlink_status(const path& __p);\n+  file_status symlink_status(const path& __p, error_code& __ec) noexcept;\n+\n+  path system_complete(const path& __p);\n+  path system_complete(const path& __p, error_code& __ec);\n+\n+  path temp_directory_path();\n+  path temp_directory_path(error_code& __ec);\n+\n+  // @} group filesystem\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace v1\n+} // namespace filesystem\n+} // namespace experimental\n+} // namespace std\n+\n+#endif // C++11\n+\n+#endif // _GLIBCXX_EXPERIMENTAL_FS_OPS_H"}, {"sha": "ffc49266b7a324bbab4a14c8d331482e13bc0110", "filename": "libstdc++-v3/include/experimental/fs_path.h", "status": "added", "additions": 1014, "deletions": 0, "changes": 1014, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Ffs_path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Ffs_path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Ffs_path.h?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -0,0 +1,1014 @@\n+// Class filesystem::path -*- C++ -*-\n+\n+// Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file experimental/fs_path.h\n+ *  This is an internal header file, included by other library headers.\n+ *  Do not attempt to use it directly. @headername{experimental/filesystem}\n+ */\n+\n+#ifndef _GLIBCXX_EXPERIMENTAL_FS_PATH_H\n+#define _GLIBCXX_EXPERIMENTAL_FS_PATH_H 1\n+\n+#if __cplusplus < 201103L\n+# include <bits/c++0x_warning.h>\n+#else\n+\n+#include <utility>\n+#include <type_traits>\n+#include <list>\n+#include <locale>\n+#include <iosfwd>\n+#include <codecvt>\n+#include <system_error>\n+#include <bits/stl_algobase.h>\n+#include <bits/quoted_string.h>\n+#include <bits/locale_conv.h>\n+\n+#if defined(_WIN32) && !defined(__CYGWIN__)\n+# define _GLIBCXX_FILESYSTEM_IS_WINDOWS 1\n+# include <algorithm>\n+#endif\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+namespace experimental\n+{\n+namespace filesystem\n+{\n+inline namespace v1\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+_GLIBCXX_BEGIN_NAMESPACE_CXX11\n+\n+  /**\n+   * @ingroup filesystem\n+   * @{\n+   */\n+\n+  /// A filesystem path.\n+  class path\n+  {\n+    template<typename _CharT>\n+      struct __is_encoded_char : std::false_type { };\n+\n+    template<typename _Iter,\n+\t     typename _Iter_traits = std::iterator_traits<_Iter>>\n+      using __is_path_iter_src\n+\t= __and_<__is_encoded_char<typename _Iter_traits::value_type>,\n+\t\t std::is_base_of<std::input_iterator_tag,\n+\t\t\t\t typename _Iter_traits::iterator_category>>;\n+\n+    template<typename _Iter>\n+      static __is_path_iter_src<_Iter>\n+      __is_path_src(_Iter, int);\n+\n+    template<typename _CharT, typename _Traits, typename _Alloc>\n+      static __is_encoded_char<_CharT>\n+      __is_path_src(const basic_string<_CharT, _Traits, _Alloc>&, int);\n+\n+    template<typename _Unknown>\n+      static std::false_type\n+      __is_path_src(const _Unknown&, ...);\n+\n+    template<typename _Tp1, typename _Tp2>\n+      struct __constructible_from;\n+\n+    template<typename _Iter>\n+      struct __constructible_from<_Iter, _Iter>\n+      : __is_path_iter_src<_Iter>\n+      { };\n+\n+    template<typename _Source>\n+      struct __constructible_from<_Source, void>\n+      : decltype(__is_path_src(std::declval<_Source>(), 0))\n+      { };\n+\n+    template<typename _Tp1, typename _Tp2 = void>\n+      using _Path = typename\n+\tstd::enable_if<__and_<__not_<is_same<_Tp1, path>>,\n+\t\t\t      __constructible_from<_Tp1, _Tp2>>::value,\n+\t\t       path>::type;\n+\n+    template<typename _Source>\n+      static _Source\n+      _S_range_begin(_Source __begin) { return __begin; }\n+\n+    struct __null_terminated { };\n+\n+    template<typename _Source>\n+      static __null_terminated\n+      _S_range_end(_Source) { return {}; }\n+\n+    template<typename _CharT, typename _Traits, typename _Alloc>\n+      static const _CharT*\n+      _S_range_begin(const basic_string<_CharT, _Traits, _Alloc>& __str)\n+      { return __str.data(); }\n+\n+    template<typename _CharT, typename _Traits, typename _Alloc>\n+      static const _CharT*\n+      _S_range_end(const basic_string<_CharT, _Traits, _Alloc>& __str)\n+      { return __str.data() + __str.size(); }\n+\n+    template<typename _Tp,\n+\t     typename _Iter = decltype(_S_range_begin(std::declval<_Tp>())),\n+\t     typename _Val = typename std::iterator_traits<_Iter>::value_type>\n+      using __value_type_is_char\n+\t= typename std::enable_if<std::is_same<_Val, char>::value>::type;\n+\n+  public:\n+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n+    typedef wchar_t\t\t\t\tvalue_type;\n+    static constexpr value_type\t\t\tpreferred_separator = L'\\\\';\n+#else\n+    typedef char\t\t\t\tvalue_type;\n+    static constexpr value_type\t\t\tpreferred_separator = '/';\n+#endif\n+    typedef std::basic_string<value_type>\tstring_type;\n+\n+    // constructors and destructor\n+\n+    path() noexcept { }\n+\n+    path(const path& __p) = default;\n+\n+    path(path&& __p) noexcept\n+    : _M_pathname(std::move(__p._M_pathname)), _M_type(__p._M_type)\n+    {\n+      _M_split_cmpts();\n+      __p.clear();\n+    }\n+\n+    template<typename _Source,\n+\t     typename _Require = _Path<_Source>>\n+      path(_Source const& __source)\n+      : _M_pathname(_S_convert(_S_range_begin(__source),\n+\t\t\t       _S_range_end(__source)))\n+      { _M_split_cmpts(); }\n+\n+    template<typename _InputIterator,\n+\t     typename _Require = _Path<_InputIterator, _InputIterator>>\n+      path(_InputIterator __first, _InputIterator __last)\n+      : _M_pathname(_S_convert(__first, __last))\n+      { _M_split_cmpts(); }\n+\n+    template<typename _Source,\n+\t     typename _Require = _Path<_Source>,\n+\t     typename _Require2 = __value_type_is_char<_Source>>\n+      path(_Source const& __source, const locale& __loc)\n+      : _M_pathname(_S_convert_loc(_S_range_begin(__source),\n+\t\t\t\t   _S_range_end(__source), __loc))\n+      { _M_split_cmpts(); }\n+\n+    template<typename _InputIterator,\n+\t     typename _Require = _Path<_InputIterator, _InputIterator>,\n+\t     typename _Require2 = __value_type_is_char<_InputIterator>>\n+      path(_InputIterator __first, _InputIterator __last, const locale& __loc)\n+      : _M_pathname(_S_convert_loc(__first, __last, __loc))\n+      { _M_split_cmpts(); }\n+\n+    ~path() = default;\n+\n+    // assignments\n+\n+    path& operator=(const path& __p) = default;\n+    path& operator=(path&& __p) noexcept;\n+\n+    template<typename _Source>\n+      _Path<_Source>&\n+      operator=(_Source const& __source)\n+      { return *this = path(__source); }\n+\n+    template<typename _Source>\n+      _Path<_Source>&\n+      assign(_Source const& __source)\n+      { return *this = path(__source); }\n+\n+    template<typename _InputIterator>\n+      _Path<_InputIterator, _InputIterator>&\n+      assign(_InputIterator __first, _InputIterator __last)\n+      { return *this = path(__first, __last); }\n+\n+    // appends\n+\n+    path& operator/=(const path& __p) { return _M_append(__p._M_pathname); }\n+\n+    template <class _Source>\n+      _Path<_Source>&\n+      operator/=(_Source const& __source)\n+      { return append(__source); }\n+\n+    template<typename _Source>\n+      _Path<_Source>&\n+      append(_Source const& __source)\n+      {\n+\treturn _M_append(_S_convert(_S_range_begin(__source),\n+\t\t\t\t    _S_range_end(__source)));\n+      }\n+\n+    template<typename _InputIterator>\n+      _Path<_InputIterator, _InputIterator>&\n+      append(_InputIterator __first, _InputIterator __last)\n+      { return _M_append(_S_convert(__first, __last)); }\n+\n+    // concatenation\n+\n+    path& operator+=(const path& __x);\n+    path& operator+=(const string_type& __x);\n+    path& operator+=(const value_type* __x);\n+    path& operator+=(value_type __x);\n+\n+    template<typename _Source>\n+      _Path<_Source>&\n+      operator+=(_Source const& __x) { return concat(__x); }\n+\n+    template<typename _CharT>\n+      _Path<_CharT*, _CharT*>&\n+      operator+=(_CharT __x);\n+\n+    template<typename _Source>\n+      _Path<_Source>&\n+      concat(_Source const& __x)\n+      { return *this += _S_convert(_S_range_begin(__x), _S_range_end(__x)); }\n+\n+    template<typename _InputIterator>\n+      _Path<_InputIterator, _InputIterator>&\n+      concat(_InputIterator __first, _InputIterator __last)\n+      { return *this += _S_convert(__first, __last); }\n+\n+    // modifiers\n+\n+    void clear() noexcept { _M_pathname.clear(); _M_split_cmpts(); }\n+\n+    path& make_preferred();\n+    path& remove_filename();\n+    path& replace_filename(const path& __replacement);\n+    path& replace_extension(const path& __replacement = path());\n+\n+    void swap(path& __rhs) noexcept;\n+\n+    // native format observers\n+\n+    const string_type&  native() const noexcept { return _M_pathname; }\n+    const value_type*   c_str() const noexcept { return _M_pathname.c_str(); }\n+    operator string_type() const { return _M_pathname; }\n+\n+    template<typename _CharT, typename _Traits = std::char_traits<_CharT>,\n+\t     typename _Allocator = std::allocator<_CharT>>\n+      std::basic_string<_CharT, _Traits, _Allocator>\n+      string(const _Allocator& __a = _Allocator()) const;\n+\n+    std::string    string() const;\n+    std::wstring   wstring() const;\n+    std::string    u8string() const;\n+    std::u16string u16string() const;\n+    std::u32string u32string() const;\n+\n+    // generic format observers\n+    template<typename _CharT, typename _Traits = std::char_traits<_CharT>,\n+\t     typename _Allocator = std::allocator<_CharT>>\n+      std::basic_string<_CharT, _Traits, _Allocator>\n+      generic_string(const _Allocator& __a = _Allocator()) const;\n+\n+    std::string    generic_string() const;\n+    std::wstring   generic_wstring() const;\n+    std::string    generic_u8string() const;\n+    std::u16string generic_u16string() const;\n+    std::u32string generic_u32string() const;\n+\n+    // compare\n+\n+    int compare(const path& __p) const noexcept;\n+    int compare(const string_type& __s) const;\n+    int compare(const value_type* __s) const;\n+\n+    // decomposition\n+\n+    path root_name() const;\n+    path root_directory() const;\n+    path root_path() const;\n+    path relative_path() const;\n+    path parent_path() const;\n+    path filename() const;\n+    path stem() const;\n+    path extension() const;\n+\n+    // query\n+\n+    bool empty() const noexcept { return _M_pathname.empty(); }\n+    bool has_root_name() const;\n+    bool has_root_directory() const;\n+    bool has_root_path() const;\n+    bool has_relative_path() const;\n+    bool has_parent_path() const;\n+    bool has_filename() const;\n+    bool has_stem() const;\n+    bool has_extension() const;\n+    bool is_absolute() const;\n+    bool is_relative() const { return !is_absolute(); }\n+\n+    // iterators\n+    class iterator;\n+    typedef iterator const_iterator;\n+\n+    iterator begin() const;\n+    iterator end() const;\n+\n+  private:\n+    enum class _Type : unsigned char {\n+\t_Multi, _Root_name, _Root_dir, _Filename\n+    };\n+\n+    path(string_type __str, _Type __type) : _M_pathname(__str), _M_type(__type)\n+    {\n+      _GLIBCXX_DEBUG_ASSERT(!empty());\n+      _GLIBCXX_DEBUG_ASSERT(_M_type != _Type::_Multi);\n+    }\n+\n+    enum class _Split { _Stem, _Extension };\n+\n+    path& _M_append(const string_type& __str)\n+    {\n+      if (!_M_pathname.empty() && !_S_is_dir_sep(_M_pathname.back())\n+\t  && !__str.empty() && !_S_is_dir_sep(__str.front()))\n+\t_M_pathname += preferred_separator;\n+      _M_pathname += __str;\n+      _M_split_cmpts();\n+      return *this;\n+    }\n+\n+    pair<const string_type*, size_t> _M_find_extension() const;\n+\n+    template<typename _CharT>\n+      struct _Cvt;\n+\n+    static string_type\n+    _S_convert(value_type* __src, __null_terminated)\n+    { return string_type(__src); }\n+\n+    static string_type\n+    _S_convert(const value_type* __src, __null_terminated)\n+    { return string_type(__src); }\n+\n+    template<typename _Iter>\n+      static string_type\n+      _S_convert(_Iter __first, _Iter __last)\n+      {\n+\tusing __value_type = typename std::iterator_traits<_Iter>::value_type;\n+\treturn _Cvt<__value_type>::_S_convert(__first, __last);\n+      }\n+\n+    template<typename _InputIterator>\n+      static string_type\n+      _S_convert(_InputIterator __src, __null_terminated)\n+      {\n+\tusing _Tp = typename std::iterator_traits<_InputIterator>::value_type;\n+\tstd::basic_string<_Tp> __tmp;\n+\twhile (*__src != _Tp{})\n+\t  __tmp.push_back(*__src++);\n+\treturn _S_convert(__tmp.data(), __tmp.data() + __tmp.size());\n+      }\n+\n+    static string_type\n+    _S_convert_loc(const char* __first, const char* __last,\n+\t\t   const std::locale& __loc);\n+\n+    template<typename _Iter>\n+      static string_type\n+      _S_convert_loc(_Iter __first, _Iter __last, const std::locale& __loc)\n+      {\n+\tconst std::string __str(__first, __last);\n+\treturn _S_convert_loc(__str.data(), __str.data()+__str.size(), __loc);\n+      }\n+\n+    template<typename _InputIterator>\n+      static string_type\n+      _S_convert_loc(_InputIterator __src, __null_terminated,\n+\t\t     const std::locale& __loc)\n+      {\n+\tstd::string __tmp;\n+\twhile (*__src != '\\0')\n+\t  __tmp.push_back(*__src++);\n+\treturn _S_convert_loc(__tmp.data(), __tmp.data()+__tmp.size(), __loc);\n+      }\n+\n+    bool _S_is_dir_sep(value_type __ch)\n+    {\n+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n+      return __ch == L'/' || __ch == preferred_separator;\n+#else\n+      return __ch == '/';\n+#endif\n+    }\n+\n+    void _M_split_cmpts();\n+    void _M_trim();\n+    void _M_add_root_name(size_t n);\n+    void _M_add_root_dir(size_t pos);\n+    void _M_add_filename(size_t pos, size_t n);\n+\n+    string_type _M_pathname;\n+\n+    struct _Cmpt;\n+    using _List = std::list<_Cmpt>;\n+    _List _M_cmpts; // empty unless _M_type == _Type::_Multi\n+    _Type _M_type = _Type::_Multi;\n+  };\n+\n+  inline void swap(path& __lhs, path& __rhs) noexcept { __lhs.swap(__rhs); }\n+\n+  size_t hash_value(const path& __p) noexcept;\n+\n+  /// Compare paths\n+  inline bool operator<(const path& __lhs, const path& __rhs) noexcept\n+  { return __lhs.compare(__rhs) < 0; }\n+\n+  /// Compare paths\n+  inline bool operator<=(const path& __lhs, const path& __rhs) noexcept\n+  { return !(__rhs < __lhs); }\n+\n+  /// Compare paths\n+  inline bool operator>(const path& __lhs, const path& __rhs) noexcept\n+  { return __rhs < __lhs; }\n+\n+  /// Compare paths\n+  inline bool operator>=(const path& __lhs, const path& __rhs) noexcept\n+  { return !(__lhs < __rhs); }\n+\n+  /// Compare paths\n+  inline bool operator==(const path& __lhs, const path& __rhs) noexcept\n+  { return __lhs.compare(__rhs) == 0; }\n+\n+  /// Compare paths\n+  inline bool operator!=(const path& __lhs, const path& __rhs) noexcept\n+  { return !(__lhs == __rhs); }\n+\n+  /// Append one path to another\n+  inline path operator/(const path& __lhs, const path& __rhs)\n+  { return path(__lhs) /= __rhs; }\n+\n+  /// Write a path to a stream\n+  template<typename _CharT, typename _Traits>\n+    basic_ostream<_CharT, _Traits>&\n+    operator<<(basic_ostream<_CharT, _Traits>& __os, const path& __p)\n+    {\n+      auto __tmp = __p.string<_CharT, _Traits>();\n+      using __quoted_string\n+\t= std::__detail::_Quoted_string<decltype(__tmp)&, _CharT>;\n+      __os << __quoted_string{__tmp, '\"', '\\\\'};\n+      return __os;\n+    }\n+\n+  /// Read a path from a stream\n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>&\n+    operator>>(basic_istream<_CharT, _Traits>& __is, path& __p)\n+    {\n+      basic_string<_CharT, _Traits> __tmp;\n+      using __quoted_string\n+\t= std::__detail::_Quoted_string<decltype(__tmp)&, _CharT>;\n+      if (__is >> __quoted_string{ __tmp, '\"', '\\\\' })\n+\t__p = std::move(__tmp);\n+      return __is;\n+    }\n+\n+  // TODO constrain with _Path<Source> and __value_type_is_char\n+  template<typename _Source>\n+    inline path\n+    u8path(const _Source& __source)\n+    {\n+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n+      return path{ path::string_type{__source} };\n+#else\n+      return path{ __source };\n+#endif\n+    }\n+\n+  // TODO constrain with _Path<InputIterator, InputIterator> and __value_type_is_char\n+  template<typename _InputIterator>\n+    inline path\n+    u8path(_InputIterator __first, _InputIterator __last)\n+    {\n+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n+      return path{ path::string_type{__first, __last} };\n+#else\n+      return path{ __first, __last };\n+#endif\n+    }\n+\n+  class filesystem_error : public std::system_error\n+  {\n+  public:\n+    filesystem_error(const string& __what_arg, error_code __ec)\n+    : system_error(__ec, __what_arg) { }\n+\n+    filesystem_error(const string& __what_arg, const path& __p1,\n+\t\t     error_code __ec)\n+    : system_error(__ec, __what_arg), _M_path1(__p1) { }\n+\n+    filesystem_error(const string& __what_arg, const path& __p1,\n+\t\t     const path& __p2, error_code __ec)\n+    : system_error(__ec, __what_arg), _M_path1(__p1), _M_path2(__p2)\n+    { }\n+\n+    const path& path1() const noexcept { return _M_path1; }\n+    const path& path2() const noexcept { return _M_path2; }\n+    const char* what() const noexcept { return _M_what.c_str(); }\n+\n+  private:\n+    std::string _M_gen_what();\n+\n+    path _M_path1;\n+    path _M_path2;\n+    std::string _M_what = _M_gen_what();\n+  };\n+\n+  struct path::_Cmpt : path\n+  {\n+    _Cmpt(string_type __s, _Type __t, size_t __pos)\n+      : path(std::move(__s), __t), _M_pos(__pos) { }\n+\n+    _Cmpt() : _M_pos(-1) { }\n+\n+    size_t _M_pos;\n+  };\n+\n+  template<>\n+    struct path::__is_encoded_char<char> : std::true_type\n+    { using value_type = char; };\n+\n+  template<>\n+    struct path::__is_encoded_char<wchar_t> : std::true_type\n+    { using value_type = wchar_t; };\n+\n+  template<>\n+    struct path::__is_encoded_char<char16_t> : std::true_type\n+    { using value_type = char16_t; };\n+\n+  template<>\n+    struct path::__is_encoded_char<char32_t> : std::true_type\n+    { using value_type = char32_t; };\n+\n+  // specialize _Cvt for degenerate 'noconv' case\n+  template<>\n+    struct path::_Cvt<path::value_type>\n+    {\n+      template<typename _Iter>\n+\tstatic string_type\n+\t_S_convert(_Iter __first, _Iter __last)\n+\t{ return string_type{__first, __last}; }\n+    };\n+\n+  template<typename _CharT>\n+    struct path::_Cvt\n+    {\n+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n+      static string_type\n+      _S_wconvert(const char* __f, const char* __l, true_type)\n+      {\n+\tusing _Cvt = std::codecvt<wchar_t, char, mbstate_t>;\n+\tconst auto& __cvt = std::use_facet<_Cvt>(std::locale{});\n+\tstd::wstring __wstr;\n+\tif (__str_codecvt_in(__f, __l, __wstr, __cvt))\n+\t    return __wstr;\n+\t_GLIBCXX_THROW_OR_ABORT(filesystem_error(\n+\t      \"Cannot convert character sequence\",\n+\t      std::make_error_code(errc::illegal_byte_sequence)));\n+      }\n+\n+      static string_type\n+      _S_wconvert(const _CharT* __f, const _CharT* __l, false_type)\n+      {\n+\tstd::codecvt_utf8<_CharT> __cvt;\n+\tstd::string __str;\n+\tif (__str_codecvt_out(__f, __l, __str, __cvt))\n+\t  {\n+\t    const char* __f2 = __str.data();\n+\t    const char* __l2 = __f2 + __str.size();\n+\t    std::codecvt_utf8<wchar_t> __wcvt;\n+\t    std::wstring __wstr;\n+\t    if (__str_codecvt_in(__f2, __l2, __wstr, __wcvt))\n+\t      return __wstr;\n+\t  }\n+\t_GLIBCXX_THROW_OR_ABORT(filesystem_error(\n+\t      \"Cannot convert character sequence\",\n+\t      std::make_error_code(errc::illegal_byte_sequence)));\n+      }\n+\n+      static string_type\n+      _S_convert(const _CharT* __f, const _CharT* __l)\n+      {\n+\treturn _S_wconvert(__f, __l, is_same<_CharT, char>{});\n+      }\n+#else\n+      static string_type\n+      _S_convert(const _CharT* __f, const _CharT* __l)\n+      {\n+\tstd::codecvt_utf8<_CharT> __cvt;\n+\tstd::string __str;\n+\tif (__str_codecvt_out(__f, __l, __str, __cvt))\n+\t  return __str;\n+\t_GLIBCXX_THROW_OR_ABORT(filesystem_error(\n+\t      \"Cannot convert character sequence\",\n+\t      std::make_error_code(errc::illegal_byte_sequence)));\n+      }\n+#endif\n+\n+      static string_type\n+      _S_convert(_CharT* __f, _CharT* __l)\n+      {\n+\treturn _S_convert(const_cast<const _CharT*>(__f),\n+\t\t\t  const_cast<const _CharT*>(__l));\n+      }\n+\n+      template<typename _Iter>\n+\tstatic string_type\n+\t_S_convert(_Iter __first, _Iter __last)\n+\t{\n+\t  const std::basic_string<_CharT> __str(__first, __last);\n+\t  return _S_convert(__str.data(), __str.data() + __str.size());\n+\t}\n+\n+      template<typename _Iter, typename _Cont>\n+\tstatic string_type\n+\t_S_convert(__gnu_cxx::__normal_iterator<_Iter, _Cont> __first,\n+\t\t  __gnu_cxx::__normal_iterator<_Iter, _Cont> __last)\n+\t{ return _S_convert(__first.base(), __last.base()); }\n+    };\n+\n+  /// An iterator for the components of a path\n+  class path::iterator\n+  {\n+  public:\n+    using difference_type\t= std::ptrdiff_t;\n+    using value_type\t\t= path;\n+    using reference\t\t= const path&;\n+    using pointer\t\t= const path*;\n+    using iterator_category\t= std::bidirectional_iterator_tag;\n+\n+    iterator() : _M_path(nullptr), _M_cur(), _M_at_end() { }\n+\n+    iterator(const iterator&) = default;\n+    iterator& operator=(const iterator&) = default;\n+\n+    reference operator*() const;\n+    pointer   operator->() const { return std::__addressof(**this); }\n+\n+    iterator& operator++();\n+    iterator  operator++(int) { auto __tmp = *this; ++_M_cur; return __tmp; }\n+\n+    iterator& operator--();\n+    iterator  operator--(int) { auto __tmp = *this; --_M_cur; return __tmp; }\n+\n+    friend bool operator==(const iterator& __lhs, const iterator& __rhs)\n+    { return __lhs.equals(__rhs); }\n+\n+    friend bool operator!=(const iterator& __lhs, const iterator& __rhs)\n+    { return !__lhs.equals(__rhs); }\n+\n+  private:\n+    friend class path;\n+\n+    iterator(const path* __path, path::_List::const_iterator __iter)\n+    : _M_path(__path), _M_cur(__iter), _M_at_end()\n+    { }\n+\n+    iterator(const path* __path, bool __at_end)\n+    : _M_path(__path), _M_cur(), _M_at_end(__at_end)\n+    { }\n+\n+    bool equals(iterator) const;\n+\n+    const path* \t\t_M_path;\n+    path::_List::const_iterator _M_cur;\n+    bool\t\t\t_M_at_end;  // only used when type != _Multi\n+  };\n+\n+\n+  inline path&\n+  path::operator=(path&& __p) noexcept\n+  {\n+    _M_pathname = std::move(__p._M_pathname);\n+    _M_cmpts = std::move(__p._M_cmpts);\n+    _M_type = __p._M_type;\n+    __p.clear();\n+    return *this;\n+  }\n+\n+  inline path&\n+  path::operator+=(const path& __p)\n+  {\n+    return operator+=(__p.native());\n+  }\n+\n+  inline path&\n+  path::operator+=(const string_type& __x)\n+  {\n+    _M_pathname += __x;\n+    _M_split_cmpts();\n+    return *this;\n+  }\n+\n+  inline path&\n+  path::operator+=(const value_type* __x)\n+  {\n+    _M_pathname += __x;\n+    _M_split_cmpts();\n+    return *this;\n+  }\n+\n+  inline path&\n+  path::operator+=(value_type __x)\n+  {\n+    _M_pathname += __x;\n+    _M_split_cmpts();\n+    return *this;\n+  }\n+\n+  template<typename _CharT>\n+    inline path::_Path<_CharT*, _CharT*>&\n+    path::operator+=(_CharT __x)\n+    {\n+      auto* __addr = std::addressof(__x);\n+      return concat(__addr, __addr + 1);\n+    }\n+\n+  inline path&\n+  path::make_preferred()\n+  {\n+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n+    std::replace(_M_pathname.begin(), _M_pathname.end(), L'/',\n+\t\t preferred_separator);\n+#endif\n+    return *this;\n+  }\n+\n+  inline void path::swap(path& __rhs) noexcept\n+  {\n+    _M_pathname.swap(__rhs._M_pathname);\n+    _M_cmpts.swap(__rhs._M_cmpts);\n+    std::swap(_M_type, __rhs._M_type);\n+  }\n+\n+  template<typename _CharT, typename _Traits, typename _Allocator>\n+    inline std::basic_string<_CharT, _Traits, _Allocator>\n+    path::string(const _Allocator& __a) const\n+    {\n+      if (is_same<_CharT, value_type>::value)\n+\treturn { _M_pathname.begin(), _M_pathname.end(), __a };\n+\n+      const value_type* __first = _M_pathname.data();\n+      const value_type* __last = __first + _M_pathname.size();\n+\n+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n+      using _CharAlloc = typename __alloc_rebind<_Allocator, char>;\n+      using _String = basic_string<char, char_traits<char>, _CharAlloc>;\n+      using _WString = basic_string<_CharT, _Traits, _Allocator>;\n+\n+      // use codecvt_utf8<wchar_t> to convert native string to UTF-8\n+      codecvt_utf8<value_type> __cvt;\n+      _String __u8str{_CharAlloc{__a}};\n+      if (__str_codecvt_out(__first, __last, __u8str, __cvt))\n+\t{\n+\t  struct\n+\t  {\n+\t    const _String*\n+\t    operator()(const _String& __from, _String&, true_type)\n+\t    { return std::__addressof(__from); }\n+\n+\t    _WString*\n+\t    operator()(const _String& __from, _WString& __to, false_type)\n+\t    {\n+\t      // use codecvt_utf8<_CharT> to convert UTF-8 to wide string\n+\t      codecvt_utf8<_CharT> __cvt;\n+\t      const char* __f = __from.data();\n+\t      const char* __l = __f + __from.size();\n+\t      if (__str_codecvt_in(__f, __l, __to, __cvt))\n+\t\treturn std::__addressof(__to);\n+\t      return nullptr;\n+\t    }\n+\t  } __dispatch;\n+\t  _WString __wstr;\n+\t  if (auto* __p = __dispatch(__u8str, __wstr, is_same<_CharT, char>{}))\n+\t    return *__p;\n+\t}\n+#else\n+      codecvt_utf8<_CharT> __cvt;\n+      basic_string<_CharT, _Traits, _Allocator> __wstr{__a};\n+      if (__str_codecvt_in(__first, __last, __wstr, __cvt))\n+\treturn __wstr;\n+#endif\n+      _GLIBCXX_THROW_OR_ABORT(filesystem_error(\n+\t    \"Cannot convert character sequence\",\n+\t    std::make_error_code(errc::illegal_byte_sequence)));\n+    }\n+\n+  inline std::string\n+  path::string() const { return string<char>(); }\n+\n+  inline std::wstring\n+  path::wstring() const { return string<wchar_t>(); }\n+\n+  inline std::string\n+  path::u8string() const\n+  {\n+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n+    std::string __str;\n+    // convert from native encoding to UTF-8\n+    codecvt_utf8<value_type> __cvt;\n+    const value_type* __first = _M_pathname.data();\n+    const value_type* __last = __first + _M_pathname.size();\n+    if (__str_codecvt_out(__first, __last, __str, __cvt))\n+      return __str;\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\n+\t  \"Cannot convert character sequence\",\n+\t  std::make_error_code(errc::illegal_byte_sequence)));\n+#else\n+    return _M_pathname;\n+#endif\n+  }\n+\n+  inline std::u16string\n+  path::u16string() const { return string<char16_t>(); }\n+\n+  inline std::u32string\n+  path::u32string() const { return string<char32_t>(); }\n+\n+#ifndef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n+  template<typename _CharT, typename _Traits, typename _Allocator>\n+    inline std::basic_string<_CharT, _Traits, _Allocator>\n+    path::generic_string(const _Allocator& __a) const\n+    { return string<_CharT, _Traits, _Allocator>(__a); }\n+\n+  inline std::string\n+  path::generic_string() const { return string(); }\n+\n+  inline std::wstring\n+  path::generic_wstring() const { return wstring(); }\n+\n+  inline std::string\n+  path::generic_u8string() const { return u8string(); }\n+\n+  inline std::u16string\n+  path::generic_u16string() const { return u16string(); }\n+\n+  inline std::u32string\n+  path::generic_u32string() const { return u32string(); }\n+#endif\n+\n+  inline int\n+  path::compare(const string_type& __s) const { return compare(path(__s)); }\n+\n+  inline int\n+  path::compare(const value_type* __s) const { return compare(path(__s)); }\n+\n+  inline path\n+  path::filename() const { return empty() ? path() : *--end(); }\n+\n+  inline path\n+  path::stem() const\n+  {\n+    auto ext = _M_find_extension();\n+    if (ext.first && ext.second != 0)\n+      return path{ext.first->substr(0, ext.second)};\n+    return {};\n+  }\n+\n+  inline path\n+  path::extension() const\n+  {\n+    auto ext = _M_find_extension();\n+    if (ext.first && ext.second != string_type::npos)\n+      return path{ext.first->substr(ext.second)};\n+    return {};\n+  }\n+\n+  inline bool\n+  path::has_stem() const\n+  {\n+    auto ext = _M_find_extension();\n+    return ext.first && ext.second != 0;\n+  }\n+\n+  inline bool\n+  path::has_extension() const\n+  {\n+    auto ext = _M_find_extension();\n+    return ext.first && ext.second != string_type::npos;\n+  }\n+\n+  inline bool\n+  path::is_absolute() const\n+  {\n+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n+    return has_root_name();\n+#else\n+    return has_root_directory();\n+#endif\n+  }\n+\n+  inline path::iterator\n+  path::begin() const\n+  {\n+    if (_M_type == _Type::_Multi)\n+      return iterator(this, _M_cmpts.begin());\n+    return iterator(this, false);\n+  }\n+\n+  inline path::iterator\n+  path::end() const\n+  {\n+    if (_M_type == _Type::_Multi)\n+      return iterator(this, _M_cmpts.end());\n+    return iterator(this, true);\n+  }\n+\n+  inline path::iterator&\n+  path::iterator::operator++()\n+  {\n+    _GLIBCXX_DEBUG_ASSERT(_M_path != nullptr);\n+    if (_M_path->_M_type == _Type::_Multi)\n+      {\n+\t_GLIBCXX_DEBUG_ASSERT(_M_cur != _M_path->_M_cmpts.end());\n+\t++_M_cur;\n+      }\n+    else\n+      {\n+\t_GLIBCXX_DEBUG_ASSERT(!_M_at_end);\n+\t_M_at_end = true;\n+      }\n+    return *this;\n+  }\n+\n+  inline path::iterator&\n+  path::iterator::operator--()\n+  {\n+    _GLIBCXX_DEBUG_ASSERT(_M_path != nullptr);\n+    if (_M_path->_M_type == _Type::_Multi)\n+      {\n+\t_GLIBCXX_DEBUG_ASSERT(_M_cur != _M_path->_M_cmpts.begin());\n+\t--_M_cur;\n+      }\n+    else\n+      {\n+\t_GLIBCXX_DEBUG_ASSERT(_M_at_end);\n+\t_M_at_end = false;\n+      }\n+    return *this;\n+  }\n+\n+  inline path::iterator::reference\n+  path::iterator::operator*() const\n+  {\n+    _GLIBCXX_DEBUG_ASSERT(_M_path != nullptr);\n+    if (_M_path->_M_type == _Type::_Multi)\n+      {\n+\t_GLIBCXX_DEBUG_ASSERT(_M_cur != _M_path->_M_cmpts.end());\n+\treturn *_M_cur;\n+      }\n+    return *_M_path;\n+  }\n+\n+  inline bool\n+  path::iterator::equals(iterator __rhs) const\n+  {\n+    if (_M_path != __rhs._M_path)\n+      return false;\n+    if (_M_path == nullptr)\n+      return true;\n+    if (_M_path->_M_type == path::_Type::_Multi)\n+      return _M_cur == __rhs._M_cur;\n+    return _M_at_end == __rhs._M_at_end;\n+  }\n+\n+  // @} group filesystem\n+_GLIBCXX_END_NAMESPACE_CXX11\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace v1\n+} // namespace filesystem\n+} // namespace experimental\n+} // namespace std\n+\n+#endif // C++11\n+\n+#endif // _GLIBCXX_EXPERIMENTAL_FS_PATH_H"}, {"sha": "38f8c9d82ef84eb340fbd4435c4c6eefb246c9e2", "filename": "libstdc++-v3/include/std/iomanip", "status": "modified", "additions": 1, "deletions": 122, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fiomanip", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fiomanip", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fiomanip?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -42,7 +42,7 @@\n #if __cplusplus >= 201103L\n #include <locale>\n #if __cplusplus > 201103L\n-#include <sstream> // used in quoted.\n+#include <bits/quoted_string.h>\n #endif\n #endif\n \n@@ -450,127 +450,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n #define __cpp_lib_quoted_string_io 201304\n \n-_GLIBCXX_END_NAMESPACE_VERSION\n-  namespace __detail {\n-  _GLIBCXX_BEGIN_NAMESPACE_VERSION\n-\n-    /**\n-     * @brief Struct for delimited strings.\n-     */\n-    template<typename _String, typename _CharT>\n-      struct _Quoted_string\n-      {\n-\tstatic_assert(is_reference<_String>::value\n-\t\t   || is_pointer<_String>::value,\n-\t\t      \"String type must be pointer or reference\");\n-\n-\t_Quoted_string(_String __str, _CharT __del, _CharT __esc)\n-\t: _M_string(__str), _M_delim{__del}, _M_escape{__esc}\n-\t{ }\n-\n-\t_Quoted_string&\n-\toperator=(_Quoted_string&) = delete;\n-\n-\t_String _M_string;\n-\t_CharT _M_delim;\n-\t_CharT _M_escape;\n-      };\n-\n-    /**\n-     * @brief Inserter for quoted strings.\n-     *\n-     *  _GLIBCXX_RESOLVE_LIB_DEFECTS\n-     *  DR 2344 quoted()'s interaction with padding is unclear\n-     */\n-    template<typename _CharT, typename _Traits>\n-      auto&\n-      operator<<(std::basic_ostream<_CharT, _Traits>& __os,\n-\t\t const _Quoted_string<const _CharT*, _CharT>& __str)\n-      {\n-\tstd::basic_ostringstream<_CharT, _Traits> __ostr;\n-\t__ostr << __str._M_delim;\n-\tfor (const _CharT* __c = __str._M_string; *__c; ++__c)\n-\t  {\n-\t    if (*__c == __str._M_delim || *__c == __str._M_escape)\n-\t      __ostr << __str._M_escape;\n-\t    __ostr << *__c;\n-\t  }\n-\t__ostr << __str._M_delim;\n-\n-\treturn __os << __ostr.str();\n-      }\n-\n-    /**\n-     * @brief Inserter for quoted strings.\n-     *\n-     *  _GLIBCXX_RESOLVE_LIB_DEFECTS\n-     *  DR 2344 quoted()'s interaction with padding is unclear\n-     */\n-    template<typename _CharT, typename _Traits, typename _String>\n-      auto&\n-      operator<<(std::basic_ostream<_CharT, _Traits>& __os,\n-\t\t const _Quoted_string<_String, _CharT>& __str)\n-      {\n-\tstd::basic_ostringstream<_CharT, _Traits> __ostr;\n-\t__ostr << __str._M_delim;\n-\tfor (auto& __c : __str._M_string)\n-\t  {\n-\t    if (__c == __str._M_delim || __c == __str._M_escape)\n-\t      __ostr << __str._M_escape;\n-\t    __ostr << __c;\n-\t  }\n-\t__ostr << __str._M_delim;\n-\n-\treturn __os << __ostr.str();\n-      }\n-\n-    /**\n-     * @brief Extractor for delimited strings.\n-     *        The left and right delimiters can be different.\n-     */\n-    template<typename _CharT, typename _Traits, typename _Alloc>\n-      auto&\n-      operator>>(std::basic_istream<_CharT, _Traits>& __is,\n-\t\t const _Quoted_string<basic_string<_CharT, _Traits, _Alloc>&,\n-\t\t\t\t      _CharT>& __str)\n-      {\n-\t_CharT __c;\n-\t__is >> __c;\n-\tif (!__is.good())\n-\t  return __is;\n-\tif (__c != __str._M_delim)\n-\t  {\n-\t    __is.unget();\n-\t    __is >> __str._M_string;\n-\t    return __is;\n-\t  }\n-\t__str._M_string.clear();\n-\tstd::ios_base::fmtflags __flags\n-\t  = __is.flags(__is.flags() & ~std::ios_base::skipws);\n-\tdo\n-\t  {\n-\t    __is >> __c;\n-\t    if (!__is.good())\n-\t      break;\n-\t    if (__c == __str._M_escape)\n-\t      {\n-\t\t__is >> __c;\n-\t\tif (!__is.good())\n-\t\t  break;\n-\t      }\n-\t    else if (__c == __str._M_delim)\n-\t      break;\n-\t    __str._M_string += __c;\n-\t  }\n-\twhile (true);\n-\t__is.setf(__flags);\n-\n-\treturn __is;\n-      }\n-  _GLIBCXX_END_NAMESPACE_VERSION\n-  } // namespace __detail\n-_GLIBCXX_BEGIN_NAMESPACE_VERSION\n-\n   /**\n    * @brief Manipulator for quoted strings.\n    * @param __string String to quote."}, {"sha": "37c3b9bf29750012b25badcf001f48f350b706d7", "filename": "libstdc++-v3/python/libstdcxx/v6/printers.py", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Fpython%2Flibstdcxx%2Fv6%2Fprinters.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Fpython%2Flibstdcxx%2Fv6%2Fprinters.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fpython%2Flibstdcxx%2Fv6%2Fprinters.py?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -979,6 +979,22 @@ def to_string (self):\n     def display_hint (self):\n         return 'string'\n \n+class StdExpPathPrinter:\n+    \"Print a std::experimental::filesystem::path\"\n+\n+    def __init__ (self, typename, val):\n+        self.val = val\n+        self.list_visualizer = gdb.default_visualizer(val['_M_cmpts'])\n+\n+    def to_string (self):\n+        path = self.val ['_M_pathname']\n+        if self.list_visualizer:\n+            list_head = self.val['_M_cmpts']['_M_impl']['_M_node']\n+            if list_head.address != list_head['_M_next']:\n+                cmpts = self.list_visualizer.to_string()\n+                path = \"%s [Components %s]\" % (path, cmpts)\n+        return path\n+\n # A \"regular expression\" printer which conforms to the\n # \"SubPrettyPrinter\" protocol from gdb.printing.\n class RxPrinter(object):\n@@ -1364,6 +1380,11 @@ def build_libstdcxx_dictionary ():\n                                   'optional', StdExpOptionalPrinter)\n     libstdcxx_printer.add_version('std::experimental::fundamentals_v1::',\n                                   'basic_string_view', StdExpStringViewPrinter)\n+    # Filesystem TS components\n+    libstdcxx_printer.add_version('std::experimental::filesystem::v1::',\n+                                  'path', StdExpPathPrinter)\n+    libstdcxx_printer.add_version('std::experimental::filesystem::v1::__cxx11',\n+                                  'path', StdExpPathPrinter)\n \n     # Extensions.\n     libstdcxx_printer.add_version('__gnu_cxx::', 'slist', StdSlistPrinter)"}, {"sha": "ee5916787b152f86773f294858194a8def12320e", "filename": "libstdc++-v3/scripts/testsuite_flags.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Fscripts%2Ftestsuite_flags.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Fscripts%2Ftestsuite_flags.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fscripts%2Ftestsuite_flags.in?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -77,7 +77,8 @@ case ${query} in\n       echo ${PCHFLAGS}\n       ;;\n     --cxxldflags)\n-      SECTIONLDFLAGS=\"@SECTION_LDFLAGS@ @LIBICONV@\"\n+      SECTIONLDFLAGS=\"@SECTION_LDFLAGS@ @LIBICONV@\n+                      -L${BUILD_DIR}/src/filesystem/.libs\"\n       echo ${SECTIONLDFLAGS}\n       ;;\n     *)"}, {"sha": "a5f48b22c6db467dee572a48ad240784bd1dce65", "filename": "libstdc++-v3/src/Makefile.am", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -22,7 +22,13 @@\n \n include $(top_srcdir)/fragment.am\n \n-SUBDIRS = c++98 c++11\n+if ENABLE_FILESYSTEM_TS\n+filesystem_dir = filesystem\n+else\n+filesystem_dir =\n+endif\n+\n+SUBDIRS = c++98 c++11 $(filesystem_dir)\n \n # Cross compiler support.\n if VTV_CYGMIN\n@@ -52,6 +58,9 @@ endif\n \n vpath % $(top_srcdir)/src/c++98\n vpath % $(top_srcdir)/src/c++11\n+if ENABLE_FILESYSTEM_TS\n+vpath % $(top_srcdir)/src/filesystem\n+endif\n \n if GLIBCXX_LDBL_COMPAT\n ldbl_compat_sources = compatibility-ldbl.cc"}, {"sha": "433f9ea121a9b03f631f9b61e56d28832d6d060b", "filename": "libstdc++-v3/src/Makefile.in", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -123,7 +123,7 @@ AM_RECURSIVE_TARGETS = $(RECURSIVE_TARGETS:-recursive=) \\\n \t$(RECURSIVE_CLEAN_TARGETS:-recursive=) tags TAGS ctags CTAGS\n ETAGS = etags\n CTAGS = ctags\n-DIST_SUBDIRS = $(SUBDIRS)\n+DIST_SUBDIRS = c++98 c++11 filesystem\n ABI_TWEAKS_SRCDIR = @ABI_TWEAKS_SRCDIR@\n ACLOCAL = @ACLOCAL@\n ALLOCATOR_H = @ALLOCATOR_H@\n@@ -346,7 +346,9 @@ WARN_CXXFLAGS = \\\n \n # -I/-D flags to pass when compiling.\n AM_CPPFLAGS = $(GLIBCXX_INCLUDES)\n-SUBDIRS = c++98 c++11\n+@ENABLE_FILESYSTEM_TS_FALSE@filesystem_dir = \n+@ENABLE_FILESYSTEM_TS_TRUE@filesystem_dir = filesystem\n+SUBDIRS = c++98 c++11 $(filesystem_dir)\n @VTV_CYGMIN_FALSE@toolexeclib_LTLIBRARIES = libstdc++.la\n \n # Cross compiler support.\n@@ -859,6 +861,7 @@ uninstall-am: uninstall-toolexeclibLTLIBRARIES\n \n vpath % $(top_srcdir)/src/c++98\n vpath % $(top_srcdir)/src/c++11\n+@ENABLE_FILESYSTEM_TS_TRUE@vpath % $(top_srcdir)/src/filesystem\n \n # Use special rules for compatibility-ldbl.cc compilation, as we need to\n # pass -mlong-double-64."}, {"sha": "c6e06c87a6b0c5db6ae141c491b3c59552db4d3b", "filename": "libstdc++-v3/src/filesystem/Makefile.am", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2FMakefile.am?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -0,0 +1,100 @@\n+## Makefile for the GNU C++ Filesystem library.\n+##\n+## Copyright (C) 2014 Free Software Foundation, Inc.\n+##\n+## Process this file with automake to produce Makefile.in.\n+##\n+## This file is part of GCC.\n+##\n+## GCC is free software; you can redistribute it and/or modify\n+## it under the terms of the GNU General Public License as published by\n+## the Free Software Foundation; either version 3, or (at your option)\n+## any later version.\n+##\n+## GCC is distributed in the hope that it will be useful,\n+## but WITHOUT ANY WARRANTY; without even the implied warranty of\n+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+## GNU General Public License for more details.\n+##\n+## You should have received a copy of the GNU General Public License\n+## along with GCC; see the file COPYING3.  If not see\n+## <http://www.gnu.org/licenses/>.\n+\n+include $(top_srcdir)/fragment.am\n+\n+toolexeclib_LTLIBRARIES = libstdc++fs.la\n+\n+headers =\n+\n+sources = \\\n+\tdir.cc \\\n+\tops.cc \\\n+\tpath.cc\n+\n+# vpath % $(top_srcdir)/src/filesystem\n+\n+libstdc__fs_la_SOURCES = $(sources)\n+\n+# AM_CXXFLAGS needs to be in each subdirectory so that it can be\n+# modified in a per-library or per-sub-library way.  Need to manually\n+# set this option because CONFIG_CXXFLAGS has to be after\n+# OPTIMIZE_CXXFLAGS on the compile line so that -O2 can be overridden\n+# as the occasion call for it.\n+AM_CXXFLAGS = \\\n+\t$(glibcxx_lt_pic_flag) $(glibcxx_compiler_shared_flag) \\\n+\t-std=gnu++14 \\\n+\t$(WARN_CXXFLAGS) $(OPTIMIZE_CXXFLAGS)  $(CONFIG_CXXFLAGS)\n+\n+AM_MAKEFLAGS = \\\n+\t\"gxx_include_dir=$(gxx_include_dir)\"\n+\n+\n+# Libtool notes\n+\n+# 1) In general, libtool expects an argument such as `--tag=CXX' when\n+# using the C++ compiler, because that will enable the settings\n+# detected when C++ support was being configured.  However, when no\n+# such flag is given in the command line, libtool attempts to figure\n+# it out by matching the compiler name in each configuration section\n+# against a prefix of the command line.  The problem is that, if the\n+# compiler name and its initial flags stored in the libtool\n+# configuration file don't match those in the command line, libtool\n+# can't decide which configuration to use, and it gives up.  The\n+# correct solution is to add `--tag CXX' to LTCXXCOMPILE and maybe\n+# CXXLINK, just after $(LIBTOOL), so that libtool doesn't have to\n+# attempt to infer which configuration to use.\n+# \n+# The second tag argument, `--tag disable-shared` means that libtool\n+# only compiles each source once, for static objects. In actuality,\n+# glibcxx_lt_pic_flag and glibcxx_compiler_shared_flag are added to\n+# the libtool command that is used create the object, which is\n+# suitable for shared libraries.  The `--tag disable-shared` must be\n+# placed after --tag CXX lest things CXX undo the affect of\n+# disable-shared.\n+\n+# 2) Need to explicitly set LTCXXCOMPILE so that EXTRA_CXX_FLAGS is\n+# last. (That way, things like -O2 passed down from the toplevel can\n+# be overridden by --enable-debug.)\n+LTCXXCOMPILE = \\\n+\t$(LIBTOOL) --tag CXX --tag disable-shared \\\n+\t$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n+\t--mode=compile $(CXX) $(TOPLEVEL_INCLUDES) \\\n+\t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) $(EXTRA_CXX_FLAGS)\n+\n+LTLDFLAGS = $(shell $(SHELL) $(top_srcdir)/../libtool-ldflags $(LDFLAGS))\n+\n+# 3) We'd have a problem when building the shared libstdc++ object if\n+# the rules automake generates would be used.  We cannot allow g++ to\n+# be used since this would add -lstdc++ to the link line which of\n+# course is problematic at this point.  So, we get the top-level\n+# directory to configure libstdc++-v3 to use gcc as the C++\n+# compilation driver.\n+CXXLINK = \\\n+\t$(LIBTOOL) --tag CXX --tag disable-shared \\\n+\t$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n+\t--mode=link $(CXX) \\\n+\t$(OPT_LDFLAGS) $(SECTION_LDFLAGS) $(AM_CXXFLAGS) $(LTLDFLAGS) -o $@\n+\n+# By adding these files here, automake will remove them for 'make clean'\n+CLEANFILES = stamp-*\n+"}, {"sha": "1ff2d72d0d17fbff771b337f4631897305b919fd", "filename": "libstdc++-v3/src/filesystem/Makefile.in", "status": "added", "additions": 661, "deletions": 0, "changes": 661, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2FMakefile.in?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -0,0 +1,661 @@\n+# Makefile.in generated by automake 1.11.1 from Makefile.am.\n+# @configure_input@\n+\n+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,\n+# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,\n+# Inc.\n+# This Makefile.in is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n+# PARTICULAR PURPOSE.\n+\n+@SET_MAKE@\n+\n+VPATH = @srcdir@\n+pkgdatadir = $(datadir)/@PACKAGE@\n+pkgincludedir = $(includedir)/@PACKAGE@\n+pkglibdir = $(libdir)/@PACKAGE@\n+pkglibexecdir = $(libexecdir)/@PACKAGE@\n+am__cd = CDPATH=\"$${ZSH_VERSION+.}$(PATH_SEPARATOR)\" && cd\n+install_sh_DATA = $(install_sh) -c -m 644\n+install_sh_PROGRAM = $(install_sh) -c\n+install_sh_SCRIPT = $(install_sh) -c\n+INSTALL_HEADER = $(INSTALL_DATA)\n+transform = $(program_transform_name)\n+NORMAL_INSTALL = :\n+PRE_INSTALL = :\n+POST_INSTALL = :\n+NORMAL_UNINSTALL = :\n+PRE_UNINSTALL = :\n+POST_UNINSTALL = :\n+build_triplet = @build@\n+host_triplet = @host@\n+target_triplet = @target@\n+DIST_COMMON = $(top_srcdir)/fragment.am $(srcdir)/Makefile.in \\\n+\t$(srcdir)/Makefile.am\n+subdir = src/filesystem\n+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n+am__aclocal_m4_deps = $(top_srcdir)/../config/acx.m4 \\\n+\t$(top_srcdir)/../config/enable.m4 \\\n+\t$(top_srcdir)/../config/futex.m4 \\\n+\t$(top_srcdir)/../config/iconv.m4 \\\n+\t$(top_srcdir)/../config/lead-dot.m4 \\\n+\t$(top_srcdir)/../config/lib-ld.m4 \\\n+\t$(top_srcdir)/../config/lib-link.m4 \\\n+\t$(top_srcdir)/../config/lib-prefix.m4 \\\n+\t$(top_srcdir)/../config/lthostflags.m4 \\\n+\t$(top_srcdir)/../config/multi.m4 \\\n+\t$(top_srcdir)/../config/no-executables.m4 \\\n+\t$(top_srcdir)/../config/override.m4 \\\n+\t$(top_srcdir)/../config/stdint.m4 \\\n+\t$(top_srcdir)/../config/unwind_ipinfo.m4 \\\n+\t$(top_srcdir)/../libtool.m4 $(top_srcdir)/../ltoptions.m4 \\\n+\t$(top_srcdir)/../ltsugar.m4 $(top_srcdir)/../ltversion.m4 \\\n+\t$(top_srcdir)/../lt~obsolete.m4 $(top_srcdir)/crossconfig.m4 \\\n+\t$(top_srcdir)/linkage.m4 $(top_srcdir)/acinclude.m4 \\\n+\t$(top_srcdir)/../config/gc++filt.m4 \\\n+\t$(top_srcdir)/../config/tls.m4 $(top_srcdir)/../config/gthr.m4 \\\n+\t$(top_srcdir)/configure.ac\n+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\\n+\t$(ACLOCAL_M4)\n+CONFIG_HEADER = $(top_builddir)/config.h\n+CONFIG_CLEAN_FILES =\n+CONFIG_CLEAN_VPATH_FILES =\n+am__vpath_adj_setup = srcdirstrip=`echo \"$(srcdir)\" | sed 's|.|.|g'`;\n+am__vpath_adj = case $$p in \\\n+    $(srcdir)/*) f=`echo \"$$p\" | sed \"s|^$$srcdirstrip/||\"`;; \\\n+    *) f=$$p;; \\\n+  esac;\n+am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;\n+am__install_max = 40\n+am__nobase_strip_setup = \\\n+  srcdirstrip=`echo \"$(srcdir)\" | sed 's/[].[^$$\\\\*|]/\\\\\\\\&/g'`\n+am__nobase_strip = \\\n+  for p in $$list; do echo \"$$p\"; done | sed -e \"s|$$srcdirstrip/||\"\n+am__nobase_list = $(am__nobase_strip_setup); \\\n+  for p in $$list; do echo \"$$p $$p\"; done | \\\n+  sed \"s| $$srcdirstrip/| |;\"' / .*\\//!s/ .*/ ./; s,\\( .*\\)/[^/]*$$,\\1,' | \\\n+  $(AWK) 'BEGIN { files[\".\"] = \"\" } { files[$$2] = files[$$2] \" \" $$1; \\\n+    if (++n[$$2] == $(am__install_max)) \\\n+      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = \"\" } } \\\n+    END { for (dir in files) print dir, files[dir] }'\n+am__base_list = \\\n+  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\\n/ /g' | \\\n+  sed '$$!N;$$!N;$$!N;$$!N;s/\\n/ /g'\n+am__installdirs = \"$(DESTDIR)$(toolexeclibdir)\"\n+LTLIBRARIES = $(toolexeclib_LTLIBRARIES)\n+libstdc__fs_la_LIBADD =\n+am__objects_1 = dir.lo ops.lo path.lo\n+am_libstdc__fs_la_OBJECTS = $(am__objects_1)\n+libstdc__fs_la_OBJECTS = $(am_libstdc__fs_la_OBJECTS)\n+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)\n+depcomp =\n+am__depfiles_maybe =\n+CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \\\n+\t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)\n+CXXLD = $(CXX)\n+SOURCES = $(libstdc__fs_la_SOURCES)\n+ETAGS = etags\n+CTAGS = ctags\n+ABI_TWEAKS_SRCDIR = @ABI_TWEAKS_SRCDIR@\n+ACLOCAL = @ACLOCAL@\n+ALLOCATOR_H = @ALLOCATOR_H@\n+ALLOCATOR_NAME = @ALLOCATOR_NAME@\n+AMTAR = @AMTAR@\n+AR = @AR@\n+AS = @AS@\n+ATOMICITY_SRCDIR = @ATOMICITY_SRCDIR@\n+ATOMIC_FLAGS = @ATOMIC_FLAGS@\n+ATOMIC_WORD_SRCDIR = @ATOMIC_WORD_SRCDIR@\n+AUTOCONF = @AUTOCONF@\n+AUTOHEADER = @AUTOHEADER@\n+AUTOMAKE = @AUTOMAKE@\n+AWK = @AWK@\n+BASIC_FILE_CC = @BASIC_FILE_CC@\n+BASIC_FILE_H = @BASIC_FILE_H@\n+CC = @CC@\n+CCODECVT_CC = @CCODECVT_CC@\n+CCOLLATE_CC = @CCOLLATE_CC@\n+CCTYPE_CC = @CCTYPE_CC@\n+CFLAGS = @CFLAGS@\n+CLOCALE_CC = @CLOCALE_CC@\n+CLOCALE_H = @CLOCALE_H@\n+CLOCALE_INTERNAL_H = @CLOCALE_INTERNAL_H@\n+CMESSAGES_CC = @CMESSAGES_CC@\n+CMESSAGES_H = @CMESSAGES_H@\n+CMONEY_CC = @CMONEY_CC@\n+CNUMERIC_CC = @CNUMERIC_CC@\n+CPP = @CPP@\n+CPPFLAGS = @CPPFLAGS@\n+CPU_DEFINES_SRCDIR = @CPU_DEFINES_SRCDIR@\n+CPU_OPT_BITS_RANDOM = @CPU_OPT_BITS_RANDOM@\n+CPU_OPT_EXT_RANDOM = @CPU_OPT_EXT_RANDOM@\n+CSTDIO_H = @CSTDIO_H@\n+CTIME_CC = @CTIME_CC@\n+CTIME_H = @CTIME_H@\n+CXX = @CXX@\n+CXXCPP = @CXXCPP@\n+CXXFILT = @CXXFILT@\n+CXXFLAGS = @CXXFLAGS@\n+CYGPATH_W = @CYGPATH_W@\n+C_INCLUDE_DIR = @C_INCLUDE_DIR@\n+DBLATEX = @DBLATEX@\n+DEBUG_FLAGS = @DEBUG_FLAGS@\n+DEFS = @DEFS@\n+DOT = @DOT@\n+DOXYGEN = @DOXYGEN@\n+DSYMUTIL = @DSYMUTIL@\n+DUMPBIN = @DUMPBIN@\n+ECHO_C = @ECHO_C@\n+ECHO_N = @ECHO_N@\n+ECHO_T = @ECHO_T@\n+EGREP = @EGREP@\n+ERROR_CONSTANTS_SRCDIR = @ERROR_CONSTANTS_SRCDIR@\n+EXEEXT = @EXEEXT@\n+EXTRA_CXX_FLAGS = @EXTRA_CXX_FLAGS@\n+FGREP = @FGREP@\n+GLIBCXX_INCLUDES = @GLIBCXX_INCLUDES@\n+GLIBCXX_LIBS = @GLIBCXX_LIBS@\n+GREP = @GREP@\n+HWCAP_FLAGS = @HWCAP_FLAGS@\n+INSTALL = @INSTALL@\n+INSTALL_DATA = @INSTALL_DATA@\n+INSTALL_PROGRAM = @INSTALL_PROGRAM@\n+INSTALL_SCRIPT = @INSTALL_SCRIPT@\n+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@\n+LD = @LD@\n+LDFLAGS = @LDFLAGS@\n+LIBICONV = @LIBICONV@\n+LIBOBJS = @LIBOBJS@\n+LIBS = @LIBS@\n+LIBTOOL = @LIBTOOL@\n+LIPO = @LIPO@\n+LN_S = @LN_S@\n+LTLIBICONV = @LTLIBICONV@\n+LTLIBOBJS = @LTLIBOBJS@\n+MAINT = @MAINT@\n+MAKEINFO = @MAKEINFO@\n+MKDIR_P = @MKDIR_P@\n+NM = @NM@\n+NMEDIT = @NMEDIT@\n+OBJDUMP = @OBJDUMP@\n+OBJEXT = @OBJEXT@\n+OPTIMIZE_CXXFLAGS = @OPTIMIZE_CXXFLAGS@\n+OPT_LDFLAGS = @OPT_LDFLAGS@\n+OS_INC_SRCDIR = @OS_INC_SRCDIR@\n+OTOOL = @OTOOL@\n+OTOOL64 = @OTOOL64@\n+PACKAGE = @PACKAGE@\n+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@\n+PACKAGE_NAME = @PACKAGE_NAME@\n+PACKAGE_STRING = @PACKAGE_STRING@\n+PACKAGE_TARNAME = @PACKAGE_TARNAME@\n+PACKAGE_URL = @PACKAGE_URL@\n+PACKAGE_VERSION = @PACKAGE_VERSION@\n+PATH_SEPARATOR = @PATH_SEPARATOR@\n+PDFLATEX = @PDFLATEX@\n+RANLIB = @RANLIB@\n+SECTION_FLAGS = @SECTION_FLAGS@\n+SECTION_LDFLAGS = @SECTION_LDFLAGS@\n+SED = @SED@\n+SET_MAKE = @SET_MAKE@\n+SHELL = @SHELL@\n+STRIP = @STRIP@\n+SYMVER_FILE = @SYMVER_FILE@\n+TOPLEVEL_INCLUDES = @TOPLEVEL_INCLUDES@\n+USE_NLS = @USE_NLS@\n+VERSION = @VERSION@\n+VTV_CXXFLAGS = @VTV_CXXFLAGS@\n+VTV_CXXLINKFLAGS = @VTV_CXXLINKFLAGS@\n+VTV_PCH_CXXFLAGS = @VTV_PCH_CXXFLAGS@\n+WARN_FLAGS = @WARN_FLAGS@\n+WERROR = @WERROR@\n+XMLLINT = @XMLLINT@\n+XSLTPROC = @XSLTPROC@\n+XSL_STYLE_DIR = @XSL_STYLE_DIR@\n+abs_builddir = @abs_builddir@\n+abs_srcdir = @abs_srcdir@\n+abs_top_builddir = @abs_top_builddir@\n+abs_top_srcdir = @abs_top_srcdir@\n+ac_ct_CC = @ac_ct_CC@\n+ac_ct_CXX = @ac_ct_CXX@\n+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@\n+am__leading_dot = @am__leading_dot@\n+am__tar = @am__tar@\n+am__untar = @am__untar@\n+baseline_dir = @baseline_dir@\n+baseline_subdir_switch = @baseline_subdir_switch@\n+bindir = @bindir@\n+build = @build@\n+build_alias = @build_alias@\n+build_cpu = @build_cpu@\n+build_os = @build_os@\n+build_vendor = @build_vendor@\n+builddir = @builddir@\n+check_msgfmt = @check_msgfmt@\n+datadir = @datadir@\n+datarootdir = @datarootdir@\n+docdir = @docdir@\n+dvidir = @dvidir@\n+enable_shared = @enable_shared@\n+enable_static = @enable_static@\n+exec_prefix = @exec_prefix@\n+glibcxx_MOFILES = @glibcxx_MOFILES@\n+glibcxx_PCHFLAGS = @glibcxx_PCHFLAGS@\n+glibcxx_POFILES = @glibcxx_POFILES@\n+glibcxx_builddir = @glibcxx_builddir@\n+glibcxx_compiler_pic_flag = @glibcxx_compiler_pic_flag@\n+glibcxx_compiler_shared_flag = @glibcxx_compiler_shared_flag@\n+glibcxx_cxx98_abi = @glibcxx_cxx98_abi@\n+glibcxx_localedir = @glibcxx_localedir@\n+glibcxx_lt_pic_flag = @glibcxx_lt_pic_flag@\n+glibcxx_prefixdir = @glibcxx_prefixdir@\n+glibcxx_srcdir = @glibcxx_srcdir@\n+glibcxx_toolexecdir = @glibcxx_toolexecdir@\n+glibcxx_toolexeclibdir = @glibcxx_toolexeclibdir@\n+gxx_include_dir = @gxx_include_dir@\n+host = @host@\n+host_alias = @host_alias@\n+host_cpu = @host_cpu@\n+host_os = @host_os@\n+host_vendor = @host_vendor@\n+htmldir = @htmldir@\n+includedir = @includedir@\n+infodir = @infodir@\n+install_sh = @install_sh@\n+libdir = @libdir@\n+libexecdir = @libexecdir@\n+libtool_VERSION = @libtool_VERSION@\n+localedir = @localedir@\n+localstatedir = @localstatedir@\n+lt_host_flags = @lt_host_flags@\n+mandir = @mandir@\n+mkdir_p = @mkdir_p@\n+multi_basedir = @multi_basedir@\n+oldincludedir = @oldincludedir@\n+pdfdir = @pdfdir@\n+port_specific_symbol_files = @port_specific_symbol_files@\n+prefix = @prefix@\n+program_transform_name = @program_transform_name@\n+psdir = @psdir@\n+python_mod_dir = @python_mod_dir@\n+sbindir = @sbindir@\n+sharedstatedir = @sharedstatedir@\n+srcdir = @srcdir@\n+sysconfdir = @sysconfdir@\n+target = @target@\n+target_alias = @target_alias@\n+target_cpu = @target_cpu@\n+target_os = @target_os@\n+target_vendor = @target_vendor@\n+thread_header = @thread_header@\n+top_build_prefix = @top_build_prefix@\n+top_builddir = @top_builddir@\n+top_srcdir = @top_srcdir@\n+toplevel_builddir = @toplevel_builddir@\n+toplevel_srcdir = @toplevel_srcdir@\n+\n+# May be used by various substitution variables.\n+gcc_version := $(shell cat $(top_srcdir)/../gcc/BASE-VER)\n+MAINT_CHARSET = latin1\n+mkinstalldirs = $(SHELL) $(toplevel_srcdir)/mkinstalldirs\n+PWD_COMMAND = $${PWDCMD-pwd}\n+STAMP = echo timestamp >\n+toolexecdir = $(glibcxx_toolexecdir)\n+toolexeclibdir = $(glibcxx_toolexeclibdir)\n+@ENABLE_WERROR_FALSE@WERROR_FLAG = \n+@ENABLE_WERROR_TRUE@WERROR_FLAG = $(WERROR)\n+@ENABLE_EXTERN_TEMPLATE_FALSE@XTEMPLATE_FLAGS = \n+@ENABLE_EXTERN_TEMPLATE_TRUE@XTEMPLATE_FLAGS = -fno-implicit-templates\n+\n+# These bits are all figured out from configure.  Look in acinclude.m4\n+# or configure.ac to see how they are set.  See GLIBCXX_EXPORT_FLAGS.\n+CONFIG_CXXFLAGS = \\\n+\t$(SECTION_FLAGS) $(HWCAP_FLAGS) -frandom-seed=$@\n+\n+WARN_CXXFLAGS = \\\n+\t$(WARN_FLAGS) $(WERROR_FLAG) -fdiagnostics-show-location=once \n+\n+\n+# -I/-D flags to pass when compiling.\n+AM_CPPFLAGS = $(GLIBCXX_INCLUDES)\n+toolexeclib_LTLIBRARIES = libstdc++fs.la\n+headers = \n+sources = \\\n+\tdir.cc \\\n+\tops.cc \\\n+\tpath.cc\n+\n+\n+# vpath % $(top_srcdir)/src/filesystem\n+libstdc__fs_la_SOURCES = $(sources)\n+\n+# AM_CXXFLAGS needs to be in each subdirectory so that it can be\n+# modified in a per-library or per-sub-library way.  Need to manually\n+# set this option because CONFIG_CXXFLAGS has to be after\n+# OPTIMIZE_CXXFLAGS on the compile line so that -O2 can be overridden\n+# as the occasion call for it.\n+AM_CXXFLAGS = \\\n+\t$(glibcxx_lt_pic_flag) $(glibcxx_compiler_shared_flag) \\\n+\t-std=gnu++14 \\\n+\t$(WARN_CXXFLAGS) $(OPTIMIZE_CXXFLAGS)  $(CONFIG_CXXFLAGS)\n+\n+AM_MAKEFLAGS = \\\n+\t\"gxx_include_dir=$(gxx_include_dir)\"\n+\n+\n+# Libtool notes\n+\n+# 1) In general, libtool expects an argument such as `--tag=CXX' when\n+# using the C++ compiler, because that will enable the settings\n+# detected when C++ support was being configured.  However, when no\n+# such flag is given in the command line, libtool attempts to figure\n+# it out by matching the compiler name in each configuration section\n+# against a prefix of the command line.  The problem is that, if the\n+# compiler name and its initial flags stored in the libtool\n+# configuration file don't match those in the command line, libtool\n+# can't decide which configuration to use, and it gives up.  The\n+# correct solution is to add `--tag CXX' to LTCXXCOMPILE and maybe\n+# CXXLINK, just after $(LIBTOOL), so that libtool doesn't have to\n+# attempt to infer which configuration to use.\n+# \n+# The second tag argument, `--tag disable-shared` means that libtool\n+# only compiles each source once, for static objects. In actuality,\n+# glibcxx_lt_pic_flag and glibcxx_compiler_shared_flag are added to\n+# the libtool command that is used create the object, which is\n+# suitable for shared libraries.  The `--tag disable-shared` must be\n+# placed after --tag CXX lest things CXX undo the affect of\n+# disable-shared.\n+\n+# 2) Need to explicitly set LTCXXCOMPILE so that EXTRA_CXX_FLAGS is\n+# last. (That way, things like -O2 passed down from the toplevel can\n+# be overridden by --enable-debug.)\n+LTCXXCOMPILE = \\\n+\t$(LIBTOOL) --tag CXX --tag disable-shared \\\n+\t$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n+\t--mode=compile $(CXX) $(TOPLEVEL_INCLUDES) \\\n+\t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) $(EXTRA_CXX_FLAGS)\n+\n+LTLDFLAGS = $(shell $(SHELL) $(top_srcdir)/../libtool-ldflags $(LDFLAGS))\n+\n+# 3) We'd have a problem when building the shared libstdc++ object if\n+# the rules automake generates would be used.  We cannot allow g++ to\n+# be used since this would add -lstdc++ to the link line which of\n+# course is problematic at this point.  So, we get the top-level\n+# directory to configure libstdc++-v3 to use gcc as the C++\n+# compilation driver.\n+CXXLINK = \\\n+\t$(LIBTOOL) --tag CXX --tag disable-shared \\\n+\t$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n+\t--mode=link $(CXX) \\\n+\t$(OPT_LDFLAGS) $(SECTION_LDFLAGS) $(AM_CXXFLAGS) $(LTLDFLAGS) -o $@\n+\n+\n+# By adding these files here, automake will remove them for 'make clean'\n+CLEANFILES = stamp-*\n+all: all-am\n+\n+.SUFFIXES:\n+.SUFFIXES: .cc .lo .o .obj\n+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am $(top_srcdir)/fragment.am $(am__configure_deps)\n+\t@for dep in $?; do \\\n+\t  case '$(am__configure_deps)' in \\\n+\t    *$$dep*) \\\n+\t      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \\\n+\t        && { if test -f $@; then exit 0; else break; fi; }; \\\n+\t      exit 1;; \\\n+\t  esac; \\\n+\tdone; \\\n+\techo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign --ignore-deps src/filesystem/Makefile'; \\\n+\t$(am__cd) $(top_srcdir) && \\\n+\t  $(AUTOMAKE) --foreign --ignore-deps src/filesystem/Makefile\n+.PRECIOUS: Makefile\n+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status\n+\t@case '$?' in \\\n+\t  *config.status*) \\\n+\t    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \\\n+\t  *) \\\n+\t    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \\\n+\t    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \\\n+\tesac;\n+\n+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)\n+\tcd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh\n+\n+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)\n+\tcd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh\n+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)\n+\tcd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh\n+$(am__aclocal_m4_deps):\n+install-toolexeclibLTLIBRARIES: $(toolexeclib_LTLIBRARIES)\n+\t@$(NORMAL_INSTALL)\n+\ttest -z \"$(toolexeclibdir)\" || $(MKDIR_P) \"$(DESTDIR)$(toolexeclibdir)\"\n+\t@list='$(toolexeclib_LTLIBRARIES)'; test -n \"$(toolexeclibdir)\" || list=; \\\n+\tlist2=; for p in $$list; do \\\n+\t  if test -f $$p; then \\\n+\t    list2=\"$$list2 $$p\"; \\\n+\t  else :; fi; \\\n+\tdone; \\\n+\ttest -z \"$$list2\" || { \\\n+\t  echo \" $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 '$(DESTDIR)$(toolexeclibdir)'\"; \\\n+\t  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 \"$(DESTDIR)$(toolexeclibdir)\"; \\\n+\t}\n+\n+uninstall-toolexeclibLTLIBRARIES:\n+\t@$(NORMAL_UNINSTALL)\n+\t@list='$(toolexeclib_LTLIBRARIES)'; test -n \"$(toolexeclibdir)\" || list=; \\\n+\tfor p in $$list; do \\\n+\t  $(am__strip_dir) \\\n+\t  echo \" $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f '$(DESTDIR)$(toolexeclibdir)/$$f'\"; \\\n+\t  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f \"$(DESTDIR)$(toolexeclibdir)/$$f\"; \\\n+\tdone\n+\n+clean-toolexeclibLTLIBRARIES:\n+\t-test -z \"$(toolexeclib_LTLIBRARIES)\" || rm -f $(toolexeclib_LTLIBRARIES)\n+\t@list='$(toolexeclib_LTLIBRARIES)'; for p in $$list; do \\\n+\t  dir=\"`echo $$p | sed -e 's|/[^/]*$$||'`\"; \\\n+\t  test \"$$dir\" != \"$$p\" || dir=.; \\\n+\t  echo \"rm -f \\\"$${dir}/so_locations\\\"\"; \\\n+\t  rm -f \"$${dir}/so_locations\"; \\\n+\tdone\n+libstdc++fs.la: $(libstdc__fs_la_OBJECTS) $(libstdc__fs_la_DEPENDENCIES) \n+\t$(CXXLINK) -rpath $(toolexeclibdir) $(libstdc__fs_la_OBJECTS) $(libstdc__fs_la_LIBADD) $(LIBS)\n+\n+mostlyclean-compile:\n+\t-rm -f *.$(OBJEXT)\n+\n+distclean-compile:\n+\t-rm -f *.tab.c\n+\n+.cc.o:\n+\t$(CXXCOMPILE) -c -o $@ $<\n+\n+.cc.obj:\n+\t$(CXXCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`\n+\n+.cc.lo:\n+\t$(LTCXXCOMPILE) -c -o $@ $<\n+\n+mostlyclean-libtool:\n+\t-rm -f *.lo\n+\n+clean-libtool:\n+\t-rm -rf .libs _libs\n+\n+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)\n+\tlist='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \\\n+\tunique=`for i in $$list; do \\\n+\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n+\t  done | \\\n+\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n+\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n+\tmkid -fID $$unique\n+tags: TAGS\n+\n+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \\\n+\t\t$(TAGS_FILES) $(LISP)\n+\tset x; \\\n+\there=`pwd`; \\\n+\tlist='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \\\n+\tunique=`for i in $$list; do \\\n+\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n+\t  done | \\\n+\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n+\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n+\tshift; \\\n+\tif test -z \"$(ETAGS_ARGS)$$*$$unique\"; then :; else \\\n+\t  test -n \"$$unique\" || unique=$$empty_fix; \\\n+\t  if test $$# -gt 0; then \\\n+\t    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n+\t      \"$$@\" $$unique; \\\n+\t  else \\\n+\t    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n+\t      $$unique; \\\n+\t  fi; \\\n+\tfi\n+ctags: CTAGS\n+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \\\n+\t\t$(TAGS_FILES) $(LISP)\n+\tlist='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \\\n+\tunique=`for i in $$list; do \\\n+\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n+\t  done | \\\n+\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n+\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n+\ttest -z \"$(CTAGS_ARGS)$$unique\" \\\n+\t  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \\\n+\t     $$unique\n+\n+GTAGS:\n+\there=`$(am__cd) $(top_builddir) && pwd` \\\n+\t  && $(am__cd) $(top_srcdir) \\\n+\t  && gtags -i $(GTAGS_ARGS) \"$$here\"\n+\n+distclean-tags:\n+\t-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags\n+check-am: all-am\n+check: check-am\n+all-am: Makefile $(LTLIBRARIES)\n+installdirs:\n+\tfor dir in \"$(DESTDIR)$(toolexeclibdir)\"; do \\\n+\t  test -z \"$$dir\" || $(MKDIR_P) \"$$dir\"; \\\n+\tdone\n+install: install-am\n+install-exec: install-exec-am\n+install-data: install-data-am\n+uninstall: uninstall-am\n+\n+install-am: all-am\n+\t@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am\n+\n+installcheck: installcheck-am\n+install-strip:\n+\t$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n+\t  install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n+\t  `test -z '$(STRIP)' || \\\n+\t    echo \"INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'\"` install\n+mostlyclean-generic:\n+\n+clean-generic:\n+\t-test -z \"$(CLEANFILES)\" || rm -f $(CLEANFILES)\n+\n+distclean-generic:\n+\t-test -z \"$(CONFIG_CLEAN_FILES)\" || rm -f $(CONFIG_CLEAN_FILES)\n+\t-test . = \"$(srcdir)\" || test -z \"$(CONFIG_CLEAN_VPATH_FILES)\" || rm -f $(CONFIG_CLEAN_VPATH_FILES)\n+\n+maintainer-clean-generic:\n+\t@echo \"This command is intended for maintainers to use\"\n+\t@echo \"it deletes files that may require special tools to rebuild.\"\n+clean: clean-am\n+\n+clean-am: clean-generic clean-libtool clean-toolexeclibLTLIBRARIES \\\n+\tmostlyclean-am\n+\n+distclean: distclean-am\n+\t-rm -f Makefile\n+distclean-am: clean-am distclean-compile distclean-generic \\\n+\tdistclean-tags\n+\n+dvi: dvi-am\n+\n+dvi-am:\n+\n+html: html-am\n+\n+html-am:\n+\n+info: info-am\n+\n+info-am:\n+\n+install-data-am:\n+\n+install-dvi: install-dvi-am\n+\n+install-dvi-am:\n+\n+install-exec-am: install-toolexeclibLTLIBRARIES\n+\n+install-html: install-html-am\n+\n+install-html-am:\n+\n+install-info: install-info-am\n+\n+install-info-am:\n+\n+install-man:\n+\n+install-pdf: install-pdf-am\n+\n+install-pdf-am:\n+\n+install-ps: install-ps-am\n+\n+install-ps-am:\n+\n+installcheck-am:\n+\n+maintainer-clean: maintainer-clean-am\n+\t-rm -f Makefile\n+maintainer-clean-am: distclean-am maintainer-clean-generic\n+\n+mostlyclean: mostlyclean-am\n+\n+mostlyclean-am: mostlyclean-compile mostlyclean-generic \\\n+\tmostlyclean-libtool\n+\n+pdf: pdf-am\n+\n+pdf-am:\n+\n+ps: ps-am\n+\n+ps-am:\n+\n+uninstall-am: uninstall-toolexeclibLTLIBRARIES\n+\n+.MAKE: install-am install-strip\n+\n+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \\\n+\tclean-libtool clean-toolexeclibLTLIBRARIES ctags distclean \\\n+\tdistclean-compile distclean-generic distclean-libtool \\\n+\tdistclean-tags dvi dvi-am html html-am info info-am install \\\n+\tinstall-am install-data install-data-am install-dvi \\\n+\tinstall-dvi-am install-exec install-exec-am install-html \\\n+\tinstall-html-am install-info install-info-am install-man \\\n+\tinstall-pdf install-pdf-am install-ps install-ps-am \\\n+\tinstall-strip install-toolexeclibLTLIBRARIES installcheck \\\n+\tinstallcheck-am installdirs maintainer-clean \\\n+\tmaintainer-clean-generic mostlyclean mostlyclean-compile \\\n+\tmostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \\\n+\ttags uninstall uninstall-am uninstall-toolexeclibLTLIBRARIES\n+\n+\n+# Tell versions [3.59,3.63) of GNU make to not export all variables.\n+# Otherwise a system limit (for SysV at least) may be exceeded.\n+.NOEXPORT:"}, {"sha": "4ed869ef7831f5dc390b35d9f7c7a8f9e44bd005", "filename": "libstdc++-v3/src/filesystem/dir.cc", "status": "added", "additions": 396, "deletions": 0, "changes": 396, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fdir.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fdir.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fdir.cc?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -0,0 +1,396 @@\n+// Class filesystem::directory_entry etc. -*- C++ -*-\n+\n+// Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <experimental/filesystem>\n+#include <utility>\n+#include <stack>\n+#include <tuple>\n+#include <string.h>\n+#include <errno.h>\n+#ifdef _GLIBCXX_HAVE_DIRENT_H\n+# ifdef _GLIBCXX_HAVE_SYS_TYPES_H\n+#  include <sys/types.h>\n+# endif\n+# include <dirent.h>\n+#else\n+// TODO: replace dummy definitions with suitable Win32 code\n+#ifndef EACCES\n+# define EACCES static_cast<int>(std::errc::permission_denied)\n+#endif\n+using DIR = void;\n+using P = std::experimental::filesystem::path;\n+static DIR* opendir(const P::value_type*) { return nullptr; }\n+static void closedir(DIR*) { }\n+struct dirent { const char* d_name; };\n+static inline int readdir_r(DIR*, dirent*, dirent**)\n+{ return static_cast<int>(std::errc::not_supported); }\n+#endif\n+\n+namespace fs = std::experimental::filesystem;\n+\n+namespace\n+{\n+  struct ErrorCode\n+  {\n+    ErrorCode(std::error_code* p) : ec(p) { }\n+\n+    ErrorCode(ErrorCode&& e) : ec(std::exchange(e.ec, nullptr)) { }\n+\n+    ~ErrorCode() { if (ec) ec->clear(); }\n+\n+    void assign(int err)\n+    {\n+      ec->assign(err, std::generic_category());\n+      ec = nullptr;\n+    }\n+\n+    explicit operator bool() { return ec != nullptr; }\n+\n+    std::error_code* ec;\n+  };\n+}\n+\n+struct fs::_Dir\n+{\n+  _Dir() : dirp(nullptr) { }\n+\n+  _Dir(DIR* dirp, const fs::path& path) : dirp(dirp), path(path) { }\n+\n+  _Dir(_Dir&& d)\n+  : dirp(std::exchange(d.dirp, nullptr)), path(std::move(d.path)),\n+    entry(std::move(d.entry)), type(d.type)\n+  { }\n+\n+  _Dir& operator=(_Dir&&) = delete;\n+\n+  ~_Dir() { if (dirp) ::closedir(dirp); }\n+\n+  bool advance(ErrorCode);\n+\n+  DIR*\t\t\tdirp;\n+  fs::path\t\tpath;\n+  directory_entry\tentry;\n+  file_type\t\ttype = file_type::none;\n+};\n+\n+namespace\n+{\n+  template<typename Bitmask>\n+    bool is_set(Bitmask obj, Bitmask bits)\n+    {\n+      return (obj & bits) != Bitmask::none;\n+    }\n+\n+  fs::_Dir\n+  opendir(const fs::path& p, fs::directory_options options, ErrorCode ec)\n+  {\n+    if (DIR* dirp = ::opendir(p.c_str()))\n+      return {dirp, p};\n+\n+    const int err = errno;\n+    if (err == EACCES\n+        && is_set(options, fs::directory_options::skip_permission_denied))\n+      return {};\n+\n+    if (!ec)\n+      _GLIBCXX_THROW_OR_ABORT(fs::filesystem_error(\n+            \"directory iterator cannot open directory\", p,\n+            std::error_code(err, std::generic_category())));\n+\n+    ec.assign(err);\n+    return {};\n+  }\n+\n+  inline std::shared_ptr<fs::_Dir>\n+  make_shared_dir(fs::_Dir&& dir)\n+  {\n+    if (dir.dirp)\n+      return std::make_shared<fs::_Dir>(std::move(dir));\n+    return {};\n+  }\n+\n+  inline fs::file_type\n+  get_file_type(const dirent& d __attribute__((__unused__)))\n+  {\n+#ifdef _GLIBCXX_HAVE_STRUCT_DIRENT_D_TYPE\n+    switch (d.d_type)\n+    {\n+    case DT_BLK:\n+      return fs::file_type::block;\n+    case DT_CHR:\n+      return fs::file_type::character;\n+    case DT_DIR:\n+      return fs::file_type::directory;\n+    case DT_FIFO:\n+      return fs::file_type::fifo;\n+    case DT_LNK:\n+      return fs::file_type::symlink;\n+    case DT_REG:\n+      return fs::file_type::regular;\n+    case DT_SOCK:\n+      return fs::file_type::socket;\n+    case DT_UNKNOWN:\n+      return fs::file_type::unknown;\n+    default:\n+      return fs::file_type::none;\n+    }\n+#else\n+    return fs::file_type::none;\n+#endif\n+  }\n+}\n+\n+bool\n+fs::_Dir::advance(ErrorCode ec)\n+{\n+  ::dirent ent;\n+  ::dirent* result;\n+  if (int err = readdir_r(dirp, &ent, &result))\n+    {\n+      if (!ec)\n+\t_GLIBCXX_THROW_OR_ABORT(filesystem_error(\n+\t      \"directory iterator cannot advance\",\n+\t      std::error_code(err, std::generic_category())));\n+      ec.assign(err);\n+      return true;\n+    }\n+  else if (result != nullptr)\n+    {\n+      // skip past dot and dot-dot\n+      if (!strcmp(ent.d_name, \".\") || !strcmp(ent.d_name, \"..\"))\n+\treturn advance(std::move(ec));\n+      entry = fs::directory_entry{path / ent.d_name};\n+      type = get_file_type(ent);\n+      return true;\n+    }\n+  else\n+    {\n+      // reached the end\n+      entry = {};\n+      type = fs::file_type::none;\n+      return false;\n+    }\n+}\n+\n+fs::directory_iterator::\n+directory_iterator(const path& p, directory_options options, error_code* ec)\n+: directory_iterator(make_shared_dir(opendir(p, options, ec)), ec)\n+{ }\n+\n+fs::directory_iterator::\n+directory_iterator(std::shared_ptr<_Dir> dir, error_code* ec)\n+: _M_dir(std::move(dir))\n+{\n+  if (_M_dir && !_M_dir->advance(ec))\n+    _M_dir.reset();\n+}\n+\n+const fs::directory_entry&\n+fs::directory_iterator::operator*() const\n+{\n+  if (!_M_dir)\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\n+\t  \"non-dereferenceable directory iterator\",\n+\t  std::make_error_code(errc::invalid_argument)));\n+  return _M_dir->entry;\n+}\n+\n+fs::directory_iterator&\n+fs::directory_iterator::operator++()\n+{\n+  if (!_M_dir)\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\n+\t  \"cannot advance non-dereferenceable directory iterator\",\n+\t  std::make_error_code(errc::invalid_argument)));\n+  if (!_M_dir->advance(nullptr))\n+    _M_dir.reset();\n+  return *this;\n+}\n+\n+fs::directory_iterator&\n+fs::directory_iterator::increment(error_code& ec) noexcept\n+{\n+  if (!_M_dir)\n+    {\n+      ec = std::make_error_code(errc::invalid_argument);\n+      return *this;\n+    }\n+  if (!_M_dir->advance(&ec))\n+    _M_dir.reset();\n+  return *this;\n+}\n+\n+using Dir_iter_pair = std::pair<fs::_Dir, fs::directory_iterator>;\n+\n+struct fs::recursive_directory_iterator::_Dir_stack : std::stack<_Dir>\n+{\n+  void clear() { c.clear(); }\n+};\n+\n+fs::recursive_directory_iterator::\n+recursive_directory_iterator(const path& p, directory_options options,\n+                                 error_code* ec)\n+: _M_options(options), _M_pending(true)\n+{\n+  if (DIR* dirp = ::opendir(p.c_str()))\n+    {\n+      _M_dirs = std::make_shared<_Dir_stack>();\n+      _M_dirs->push(_Dir{ dirp, p });\n+      if (!_M_dirs->top().advance(ec))\n+\t_M_dirs.reset();\n+    }\n+  else\n+    {\n+      const int err = errno;\n+      if (err == EACCES\n+\t  && is_set(options, fs::directory_options::skip_permission_denied))\n+\treturn;\n+\n+      if (!ec)\n+\t_GLIBCXX_THROW_OR_ABORT(filesystem_error(\n+\t      \"recursive directory iterator cannot open directory\", p,\n+\t      std::error_code(err, std::generic_category())));\n+\n+      ec->assign(err, std::generic_category());\n+    }\n+}\n+\n+fs::recursive_directory_iterator::~recursive_directory_iterator() = default;\n+\n+int\n+fs::recursive_directory_iterator::depth() const\n+{\n+  return int(_M_dirs->size()) - 1;\n+}\n+\n+const fs::directory_entry&\n+fs::recursive_directory_iterator::operator*() const\n+{\n+  return _M_dirs->top().entry;\n+}\n+\n+fs::recursive_directory_iterator&\n+fs::recursive_directory_iterator::\n+operator=(const recursive_directory_iterator& other) noexcept = default;\n+\n+fs::recursive_directory_iterator&\n+fs::recursive_directory_iterator::\n+operator=(recursive_directory_iterator&& other) noexcept = default;\n+\n+fs::recursive_directory_iterator&\n+fs::recursive_directory_iterator::operator++()\n+{\n+  error_code ec;\n+  increment(ec);\n+  if (ec.value())\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\n+\t  \"cannot increment recursive directory iterator\", ec));\n+  return *this;\n+}\n+\n+namespace\n+{\n+  bool\n+  recurse(const fs::_Dir& d, fs::directory_options options, std::error_code& ec)\n+  {\n+    bool follow_symlink\n+      = is_set(options, fs::directory_options::follow_directory_symlink);\n+#ifdef _GLIBCXX_HAVE_STRUCT_DIRENT_D_TYPE\n+    if (d.type == fs::file_type::directory)\n+      return true;\n+    if (d.type == fs::file_type::symlink && follow_symlink)\n+      return d.entry.status().type() == fs::file_type::directory;\n+    if (d.type != fs::file_type::none && d.type != fs::file_type::unknown)\n+      return false;\n+#endif\n+    const fs::path& path = d.entry.path();\n+    auto type = fs::symlink_status(path, ec).type();\n+    if (ec.value())\n+      return false;\n+    if (type == fs::file_type::symlink)\n+      {\n+\tif (!follow_symlink)\n+\t  return false;\n+\ttype = fs::status(path, ec).type();\n+      }\n+    return type == fs::file_type::directory;\n+  }\n+}\n+\n+fs::recursive_directory_iterator&\n+fs::recursive_directory_iterator::increment(error_code& ec) noexcept\n+{\n+  if (!_M_dirs)\n+    {\n+      ec = std::make_error_code(errc::invalid_argument);\n+      return *this;\n+    }\n+\n+  auto& top = _M_dirs->top();\n+\n+  if (std::exchange(_M_pending, true) && recurse(top, _M_options, ec))\n+    {\n+      _Dir dir = opendir(top.entry.path(), _M_options, &ec);\n+      if (ec.value())\n+\treturn *this;\n+      if (dir.dirp)\n+\t{\n+\t  _M_dirs->push(std::move(dir));\n+\t  if (!_M_dirs->top().advance(&ec)) // dir is empty\n+\t    pop();\n+\t  return *this;\n+\t}\n+      // else skip permission denied and continue in parent dir\n+    }\n+\n+  ec.clear();\n+  while (!_M_dirs->top().advance(&ec) && !ec.value())\n+    {\n+      _M_dirs->pop();\n+      if (_M_dirs->empty())\n+\t{\n+\t  _M_dirs.reset();\n+\t  return *this;\n+\t}\n+    }\n+  return *this;\n+}\n+\n+void\n+fs::recursive_directory_iterator::pop()\n+{\n+  if (!_M_dirs)\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\n+\t  \"cannot pop non-dereferenceable recursive directory iterator\",\n+\t  std::make_error_code(errc::invalid_argument)));\n+\n+  do {\n+    _M_dirs->pop();\n+    if (_M_dirs->empty())\n+      {\n+\t_M_dirs.reset();\n+\treturn;\n+      }\n+  } while (!_M_dirs->top().advance(nullptr));\n+}"}, {"sha": "091ca722fbbde3fb3e1c06ebfaaf888c63dbde6f", "filename": "libstdc++-v3/src/filesystem/ops.cc", "status": "added", "additions": 1169, "deletions": 0, "changes": 1169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fops.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fops.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fops.cc?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -0,0 +1,1169 @@\n+// Filesystem operations -*- C++ -*-\n+\n+// Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <experimental/filesystem>\n+#include <functional>\n+#include <stack>\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <errno.h>\n+#ifdef _GLIBCXX_HAVE_UNISTD_H\n+# include <unistd.h>\n+# if defined(_GLIBCXX_HAVE_SYS_STAT_H) && defined(_GLIBCXX_HAVE_SYS_TYPES_H)\n+#  include <sys/types.h>\n+#  include <sys/stat.h>\n+# endif\n+#endif\n+#ifdef _GLIBCXX_HAVE_FCNTL_H\n+# include <fcntl.h>\n+#endif\n+#ifdef _GLIBCXX_HAVE_SYS_STATVFS_H\n+# include <sys/statvfs.h>\n+#endif\n+#ifdef _GLIBCXX_HAVE_GNU_SENDFILE\n+# include <sys/sendfile.h>\n+#else\n+# include <ext/stdio_filebuf.h>\n+# include <ostream>\n+#endif\n+\n+namespace fs = std::experimental::filesystem;\n+\n+fs::path\n+fs::absolute(const path& p, const path& base)\n+{\n+  const bool has_root_dir = p.has_root_directory();\n+  const bool has_root_name = p.has_root_name();\n+  path abs;\n+  if (has_root_dir && has_root_name)\n+    abs = p;\n+  else\n+    {\n+      abs = base.is_absolute() ? base : absolute(base);\n+      if (has_root_dir)\n+\tabs = abs.root_name() / p;\n+      else if (has_root_name)\n+\tabs = p.root_name() / abs.root_directory() / abs.relative_path()\n+\t  / p.relative_path();\n+      else\n+\tabs = abs / p;\n+    }\n+  return abs;\n+}\n+\n+namespace\n+{\n+  struct free_as_in_malloc\n+  {\n+    void operator()(void* p) const { ::free(p); }\n+  };\n+\n+  using char_ptr = std::unique_ptr<char[], free_as_in_malloc>;\n+}\n+\n+fs::path\n+fs::canonical(const path& p, const path& base, error_code& ec)\n+{\n+  path can;\n+#ifdef _GLIBCXX_USE_REALPATH\n+  if (char_ptr rp = char_ptr{::realpath(absolute(p, base).c_str(), nullptr)})\n+    {\n+      can.assign(rp.get());\n+      ec.clear();\n+    }\n+  else\n+    ec.assign(errno, std::generic_category());\n+#else\n+  ec = std::make_error_code(std::errc::not_supported);\n+#endif\n+  return can;\n+}\n+\n+fs::path\n+fs::canonical(const path& p, error_code& ec)\n+{\n+  path cur = current_path(ec);\n+  if (ec.value())\n+    return {};\n+  return canonical(p, cur, ec);\n+}\n+\n+fs::path\n+fs::canonical(const path& p, const path& base)\n+{\n+  error_code ec;\n+  path can = canonical(p, base, ec);\n+  if (ec.value())\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\"cannot canonicalize\", p, ec));\n+  return can;\n+}\n+\n+void\n+fs::copy(const path& from, const path& to, copy_options options)\n+{\n+  error_code ec;\n+  copy(from, to, options, ec);\n+  if (ec.value())\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\"cannot copy\", from, to, ec));\n+}\n+\n+namespace\n+{\n+  template<typename Bitmask>\n+    bool is_set(Bitmask obj, Bitmask bits)\n+    {\n+      return (obj & bits) != Bitmask::none;\n+    }\n+}\n+\n+#ifdef _GLIBCXX_HAVE_SYS_STAT_H\n+namespace\n+{\n+  fs::file_status\n+  make_file_status(const struct ::stat& st)\n+  {\n+    using fs::file_status;\n+    using fs::file_type;\n+    using fs::perms;\n+    file_type ft;\n+    perms perm = static_cast<perms>(st.st_mode) & perms::mask;\n+#ifdef _GLIBCXX_HAVE_S_ISREG\n+    if (S_ISREG(st.st_mode))\n+      ft = file_type::regular;\n+    else if (S_ISDIR(st.st_mode))\n+      ft = file_type::directory;\n+    else if (S_ISCHR(st.st_mode))\n+      ft = file_type::character;\n+    else if (S_ISBLK(st.st_mode))\n+      ft = file_type::block;\n+    else if (S_ISFIFO(st.st_mode))\n+      ft = file_type::fifo;\n+    else if (S_ISLNK(st.st_mode))\n+      ft = file_type::symlink;\n+    else if (S_ISSOCK(st.st_mode))\n+      ft = file_type::socket;\n+    else\n+#endif\n+      ft = file_type::unknown;\n+    return file_status{ft, perm};\n+  }\n+\n+  inline bool\n+  is_not_found_errno(int err)\n+  {\n+    return err == ENOENT || err == ENOTDIR;\n+  }\n+\n+  inline fs::file_time_type\n+  file_time(const struct ::stat& st)\n+  {\n+    using namespace std::chrono;\n+    return fs::file_time_type{\n+#ifdef _GLIBCXX_USE_ST_MTIM\n+\tseconds{st.st_mtim.tv_sec} + nanoseconds{st.st_mtim.tv_nsec}\n+#else\n+\tseconds{st.st_mtime}\n+#endif\n+    };\n+  }\n+\n+  bool\n+  do_copy_file(const fs::path& from, const fs::path& to,\n+\t       fs::copy_options option,\n+\t       struct ::stat* from_st, struct ::stat* to_st,\n+\t       std::error_code& ec) noexcept\n+  {\n+    struct ::stat st1, st2;\n+    fs::file_status t, f;\n+\n+    if (to_st == nullptr)\n+      {\n+\tif (::stat(to.c_str(), &st1))\n+\t  {\n+\t    int err = errno;\n+\t    if (!is_not_found_errno(err))\n+\t      {\n+\t\tec.assign(err, std::generic_category());\n+\t\treturn false;\n+\t      }\n+\t  }\n+\telse\n+\t  to_st = &st1;\n+      }\n+    else if (to_st == from_st)\n+      to_st = nullptr;\n+\n+    if (to_st == nullptr)\n+      t = fs::file_status{fs::file_type::not_found};\n+    else\n+      t = make_file_status(*to_st);\n+\n+    if (from_st == nullptr)\n+      {\n+\tif (::stat(from.c_str(), &st2))\n+\t  {\n+\t    ec.assign(errno, std::generic_category());\n+\t    return false;\n+\t  }\n+\telse\n+\t  from_st = &st2;\n+      }\n+    f = make_file_status(*from_st);\n+\n+    if (exists(t))\n+      {\n+\tif (!is_other(t) && !is_other(f)\n+\t    && to_st->st_dev == from_st->st_dev\n+\t    && to_st->st_ino == from_st->st_ino)\n+\t  {\n+\t    ec = std::make_error_code(std::errc::file_exists);\n+\t    return false;\n+\t  }\n+\n+\tif (is_set(option, fs::copy_options::skip_existing))\n+\t  {\n+\t    ec.clear();\n+\t    return false;\n+\t  }\n+\telse if (is_set(option, fs::copy_options::update_existing))\n+\t  {\n+\t    if (file_time(*from_st) <= file_time(*to_st))\n+\t      {\n+\t\tec.clear();\n+\t\treturn false;\n+\t      }\n+\t  }\n+\telse if (!is_set(option, fs::copy_options::overwrite_existing))\n+\t  {\n+\t    ec = std::make_error_code(std::errc::file_exists);\n+\t    return false;\n+\t  }\n+      }\n+\n+    struct CloseFD {\n+      ~CloseFD() { if (fd != -1) ::close(fd); }\n+      int fd;\n+    };\n+\n+    CloseFD in = { ::open(from.c_str(), O_RDONLY) };\n+    if (in.fd == -1)\n+      {\n+\tec.assign(errno, std::generic_category());\n+\treturn false;\n+      }\n+    CloseFD out = { ::open(to.c_str(), O_WRONLY|O_CREAT) };\n+    if (out.fd == -1)\n+      {\n+\tec.assign(errno, std::generic_category());\n+\treturn false;\n+      }\n+\n+#ifdef _GLIBCXX_HAVE_GNU_SENDFILE\n+    auto n = ::sendfile(out.fd, in.fd, nullptr, from_st->st_size);\n+    if (n != from_st->st_size)\n+      {\n+\tec.assign(errno, std::generic_category());\n+\treturn false;\n+      }\n+#else\n+    __gnu_cxx::stdio_filebuf<char> sbin(in.fd, std::ios::in);\n+    __gnu_cxx::stdio_filebuf<char> sbout(out.fd, std::ios::out);\n+    if (std::ostream(&sbout) << &sbin)\n+      {\n+\tec.clear();\n+\treturn true;\n+      }\n+    else\n+      {\n+\tec = std::make_error_code(std::errc::io_error);\n+\treturn false;\n+      }\n+#endif\n+\n+#ifdef _GLIBCXX_HAVE_FCHMOD\n+    if (::fchmod(out.fd, from_st->st_mode))\n+#else\n+    if (::chmod(to.c_str(), from_st->st_mode))\n+#endif\n+      {\n+\tec.assign(errno, std::generic_category());\n+\treturn false;\n+      }\n+    return true;\n+  }\n+}\n+#endif\n+\n+void\n+fs::copy(const path& from, const path& to, copy_options options,\n+\t error_code& ec) noexcept\n+{\n+  bool skip_symlinks = is_set(options, copy_options::skip_symlinks);\n+  bool create_symlinks = is_set(options, copy_options::create_symlinks);\n+  bool use_lstat = create_symlinks || skip_symlinks;\n+\n+  file_status f, t;\n+  struct ::stat from_st, to_st;\n+  if (use_lstat\n+      ? ::lstat(from.c_str(), &from_st)\n+      : ::stat(from.c_str(), &from_st))\n+    {\n+      ec.assign(errno, std::generic_category());\n+      return;\n+    }\n+  if (use_lstat\n+      ? ::lstat(to.c_str(), &to_st)\n+      : ::stat(to.c_str(), &to_st))\n+    {\n+      if (!is_not_found_errno(errno))\n+\t{\n+\t  ec.assign(errno, std::generic_category());\n+\t  return;\n+\t}\n+      t = file_status{file_type::not_found};\n+    }\n+  else\n+    t = make_file_status(to_st);\n+  f = make_file_status(from_st);\n+\n+  if (exists(t) && !is_other(t) && !is_other(f)\n+      && to_st.st_dev == from_st.st_dev && to_st.st_ino == from_st.st_ino)\n+    {\n+      ec = std::make_error_code(std::errc::file_exists);\n+      return;\n+    }\n+  if (is_other(f) || is_other(t))\n+    {\n+      ec = std::make_error_code(std::errc::not_supported);\n+      return;\n+    }\n+  if (is_directory(f) && is_regular_file(t))\n+    {\n+      ec = std::make_error_code(std::errc::is_a_directory);\n+      return;\n+    }\n+\n+  if (is_symlink(f))\n+    {\n+      if (skip_symlinks)\n+\tec.clear();\n+      else if (!exists(t) && is_set(options, copy_options::copy_symlinks))\n+\tcopy_symlink(from, to, ec);\n+      else\n+\t// Not clear what should be done here.\n+\t// \"Otherwise report an error as specified in Error reporting (7).\"\n+\tec = std::make_error_code(std::errc::invalid_argument);\n+    }\n+  else if (is_regular_file(f))\n+    {\n+      if (is_set(options, copy_options::directories_only))\n+\tec.clear();\n+      else if (create_symlinks)\n+\tcreate_symlink(from, to, ec);\n+      else if (is_set(options, copy_options::create_hard_links))\n+\tcreate_hard_link(from, to, ec);\n+      else if (is_directory(t))\n+\tdo_copy_file(from, to / from.filename(), options, &from_st, 0, ec);\n+      else\n+\t{\n+\t  auto ptr = exists(t) ? &to_st : &from_st;\n+\t  do_copy_file(from, to, options, &from_st, ptr,  ec);\n+\t}\n+    }\n+  else if (is_directory(f) && (is_set(options, copy_options::recursive)\n+\t\t\t       || options == copy_options::none))\n+    {\n+      if (!exists(t))\n+\tif (!create_directory(to, from, ec))\n+\t  return;\n+      // set an unused bit in options to disable further recursion\n+      if (!is_set(options, copy_options::recursive))\n+\toptions |= static_cast<copy_options>(4096);\n+      for (const directory_entry& x : directory_iterator(from))\n+\tcopy(x.path(), to/x.path().filename(), options, ec);\n+    }\n+  // \"Otherwise no effects.\" (should ec.clear() be called?)\n+}\n+\n+bool\n+fs::copy_file(const path& from, const path& to, copy_options option)\n+{\n+  error_code ec;\n+  bool result = copy_file(from, to, option, ec);\n+  if (ec.value())\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\"cannot copy file\", from, to,\n+\t  ec));\n+  return result;\n+}\n+\n+bool\n+fs::copy_file(const path& from, const path& to, copy_options option,\n+\t      error_code& ec) noexcept\n+{\n+#ifdef _GLIBCXX_HAVE_SYS_STAT_H\n+  return do_copy_file(from, to, option, nullptr, nullptr, ec);\n+#else\n+  ec = std::make_error_code(std::errc::not_supported);\n+  return false;\n+#endif\n+}\n+\n+\n+void\n+fs::copy_symlink(const path& existing_symlink, const path& new_symlink)\n+{\n+  error_code ec;\n+  copy_symlink(existing_symlink, new_symlink, ec);\n+  if (ec.value())\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\"cannot copy symlink\",\n+\t  existing_symlink, new_symlink, ec));\n+}\n+\n+void\n+fs::copy_symlink(const path& existing_symlink, const path& new_symlink,\n+\t\t error_code& ec) noexcept\n+{\n+  auto p = read_symlink(existing_symlink, ec);\n+  if (ec.value())\n+    return;\n+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n+  if (is_directory(p))\n+    {\n+      create_directory_symlink(p, new_symlink, ec);\n+      return;\n+    }\n+#endif\n+  create_symlink(p, new_symlink, ec);\n+}\n+\n+\n+bool\n+fs::create_directories(const path& p)\n+{\n+  error_code ec;\n+  bool result = create_directories(p, ec);\n+  if (ec.value())\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\"cannot create directories\", p,\n+\t  ec));\n+  return result;\n+}\n+\n+bool\n+fs::create_directories(const path& p, error_code& ec) noexcept\n+{\n+  std::stack<path> missing;\n+  path pp = p;\n+  ec.clear();\n+  while (!p.empty() && !exists(pp, ec) && !ec.value())\n+    {\n+      missing.push(pp);\n+      pp = pp.parent_path();\n+    }\n+  while (!missing.empty() && !ec.value())\n+    {\n+      create_directory(missing.top(), ec);\n+      missing.pop();\n+    }\n+  return missing.empty();\n+}\n+\n+namespace\n+{\n+  bool\n+  create_dir(const fs::path& p, fs::perms perm, std::error_code& ec)\n+  {\n+#ifdef _GLIBCXX_HAVE_SYS_STAT_H\n+    ::mode_t mode = static_cast<std::underlying_type_t<fs::perms>>(perm);\n+    if (::mkdir(p.c_str(), mode))\n+      {\n+\tec.assign(errno, std::generic_category());\n+\treturn false;\n+      }\n+    else\n+      {\n+\tec.clear();\n+\treturn true;\n+      }\n+#else\n+    ec = std::make_error_code(std::errc::not_supported);\n+    return false;\n+#endif\n+  }\n+} // namespace\n+\n+bool\n+fs::create_directory(const path& p)\n+{\n+  error_code ec;\n+  bool result = create_directory(p, ec);\n+  if (ec.value())\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\"cannot create directory\", p,\n+\t  ec));\n+  return result;\n+}\n+\n+bool\n+fs::create_directory(const path& p, error_code& ec) noexcept\n+{\n+  return create_dir(p, perms::all, ec);\n+}\n+\n+\n+bool\n+fs::create_directory(const path& p, const path& attributes)\n+{\n+  error_code ec;\n+  bool result = create_directory(p, attributes, ec);\n+  if (ec.value())\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\"cannot create directory\", p,\n+\t  ec));\n+  return result;\n+}\n+\n+bool\n+fs::create_directory(const path& p, const path& attributes,\n+\t\t     error_code& ec) noexcept\n+{\n+#ifdef _GLIBCXX_HAVE_SYS_STAT_H\n+  struct ::stat st;\n+  if (::stat(attributes.c_str(), &st))\n+    {\n+      ec.assign(errno, std::generic_category());\n+      return false;\n+    }\n+  return create_dir(p, static_cast<perms>(st.st_mode), ec);\n+#else\n+  ec = std::make_error_code(std::errc::not_supported);\n+  return false;\n+#endif\n+}\n+\n+\n+void\n+fs::create_directory_symlink(const path& to, const path& new_symlink)\n+{\n+  error_code ec;\n+  create_directory_symlink(to, new_symlink, ec);\n+  if (ec.value())\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\"cannot create directory symlink\",\n+\t  to, new_symlink, ec));\n+}\n+\n+void\n+fs::create_directory_symlink(const path& to, const path& new_symlink,\n+\t\t\t     error_code& ec) noexcept\n+{\n+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n+  ec = std::make_error_code(std::errc::not_supported);\n+#else\n+  create_symlink(to, new_symlink, ec);\n+#endif\n+}\n+\n+\n+void\n+fs::create_hard_link(const path& to, const path& new_hard_link)\n+{\n+  error_code ec;\n+  create_hard_link(to, new_hard_link, ec);\n+  if (ec.value())\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\"cannot create hard link\",\n+\t  to, new_hard_link, ec));\n+}\n+\n+void\n+fs::create_hard_link(const path& to, const path& new_hard_link,\n+\t\t     error_code& ec) noexcept\n+{\n+#ifdef _GLIBCXX_HAVE_UNISTD_H\n+  if (::link(to.c_str(), new_hard_link.c_str()))\n+    ec.assign(errno, std::generic_category());\n+  else\n+    ec.clear();\n+#else\n+  ec = std::make_error_code(std::errc::not_supported);\n+#endif\n+}\n+\n+void\n+fs::create_symlink(const path& to, const path& new_symlink)\n+{\n+  error_code ec;\n+  create_symlink(to, new_symlink, ec);\n+  if (ec.value())\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\"cannot create symlink\",\n+\t  to, new_symlink, ec));\n+}\n+\n+void\n+fs::create_symlink(const path& to, const path& new_symlink,\n+\t\t   error_code& ec) noexcept\n+{\n+#ifdef _GLIBCXX_HAVE_UNISTD_H\n+  if (::symlink(to.c_str(), new_symlink.c_str()))\n+    ec.assign(errno, std::generic_category());\n+  else\n+    ec.clear();\n+#else\n+  ec = std::make_error_code(std::errc::not_supported);\n+#endif\n+}\n+\n+\n+fs::path\n+fs::current_path()\n+{\n+  error_code ec;\n+  path p = current_path(ec);\n+  if (ec.value())\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\"cannot get current path\", ec));\n+  return p;\n+}\n+\n+fs::path\n+fs::current_path(error_code& ec)\n+{\n+  path p;\n+#ifdef _GLIBCXX_HAVE_UNISTD_H\n+#ifdef __GLIBC__\n+  if (char_ptr cwd = char_ptr{::getcwd(nullptr, 0)})\n+    {\n+      p.assign(cwd.get());\n+      ec.clear();\n+    }\n+  else\n+    ec.assign(errno, std::generic_category());\n+#else\n+  long path_max = pathconf(\".\", _PC_PATH_MAX);\n+  size_t size;\n+  if (path_max == -1)\n+      size = 1024;\n+  else if (path_max > 10240)\n+      size = 10240;\n+  else\n+      size = path_max;\n+  for (char_ptr buf; p.empty(); size *= 2)\n+    {\n+      buf.reset((char*)malloc(size));\n+      if (buf)\n+\t{\n+\t  if (getcwd(buf.get(), size))\n+\t    {\n+\t      p.assign(buf.get());\n+\t      ec.clear();\n+\t    }\n+\t  else if (errno != ERANGE)\n+\t    {\n+\t      ec.assign(errno, std::generic_category());\n+\t      return {};\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  ec = std::make_error_code(std::errc::not_enough_memory);\n+\t  return {};\n+\t}\n+    }\n+#endif  // __GLIBC__\n+#else   // _GLIBCXX_HAVE_UNISTD_H\n+  ec = std::make_error_code(std::errc::not_supported);\n+#endif\n+  return p;\n+}\n+\n+void\n+fs::current_path(const path& p)\n+{\n+  error_code ec;\n+  current_path(p, ec);\n+  if (ec.value())\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\"cannot set current path\", ec));\n+}\n+\n+void\n+fs::current_path(const path& p, error_code& ec) noexcept\n+{\n+#ifdef _GLIBCXX_HAVE_UNISTD_H\n+  if (int err = ::chdir(p.c_str()))\n+    ec.assign(err, std::generic_category());\n+  else\n+    ec.clear();\n+#else\n+  ec = std::make_error_code(std::errc::not_supported);\n+#endif\n+}\n+\n+bool\n+fs::equivalent(const path& p1, const path& p2)\n+{\n+  error_code ec;\n+  auto result = equivalent(p1, p2, ec);\n+  if (ec.value())\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\"cannot check file equivalence\",\n+\t  p1, p2, ec));\n+  return result;\n+}\n+\n+bool\n+fs::equivalent(const path& p1, const path& p2, error_code& ec) noexcept\n+{\n+#ifdef _GLIBCXX_HAVE_SYS_STAT_H\n+  struct ::stat st1, st2;\n+  if (::stat(p1.c_str(), &st1) == 0 && ::stat(p2.c_str(), &st2) == 0)\n+    {\n+      file_status s1 = make_file_status(st1);\n+      file_status s2 = make_file_status(st2);\n+      if (is_other(s1) && is_other(s2))\n+\t{\n+\t  ec = std::make_error_code(std::errc::not_supported);\n+\t  return false;\n+\t}\n+      ec.clear();\n+      return st1.st_dev == st2.st_dev && st1.st_ino == st2.st_ino;\n+    }\n+  else if (is_not_found_errno(errno))\n+    {\n+      ec = std::make_error_code(std::errc::no_such_file_or_directory);\n+      return false;\n+    }\n+  ec.assign(errno, std::generic_category());\n+#else\n+  ec = std::make_error_code(std::errc::not_supported);\n+#endif\n+  return false;\n+}\n+\n+std::uintmax_t\n+fs::file_size(const path& p)\n+{\n+  error_code ec;\n+  auto sz = file_size(p, ec);\n+  if (ec.value())\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\"cannot get file size\", p, ec));\n+  return sz;\n+}\n+\n+namespace\n+{\n+  template<typename Accessor, typename T>\n+    T\n+    do_stat(const fs::path& p, std::error_code& ec, Accessor f, T deflt)\n+    {\n+#ifdef _GLIBCXX_HAVE_SYS_STAT_H\n+      struct ::stat st;\n+      if (::stat(p.c_str(), &st))\n+\t{\n+\t  ec.assign(errno, std::generic_category());\n+\t  return deflt;\n+\t}\n+      ec.clear();\n+      return f(st);\n+#else\n+      ec = std::make_error_code(std::errc::not_supported);\n+      return deflt;\n+#endif\n+    }\n+}\n+\n+std::uintmax_t\n+fs::file_size(const path& p, error_code& ec) noexcept\n+{\n+  return do_stat(p, ec, std::mem_fn(&stat::st_size),\n+\t\t static_cast<uintmax_t>(-1));\n+}\n+\n+std::uintmax_t\n+fs::hard_link_count(const path& p)\n+{\n+  error_code ec;\n+  auto count = hard_link_count(p, ec);\n+  if (ec.value())\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\"cannot get link count\", p, ec));\n+  return count;\n+}\n+\n+std::uintmax_t\n+fs::hard_link_count(const path& p, error_code& ec) noexcept\n+{\n+  return do_stat(p, ec, std::mem_fn(&stat::st_nlink),\n+\t\t static_cast<uintmax_t>(-1));\n+}\n+\n+bool\n+fs::is_empty(const path& p)\n+{\n+  return fs::is_directory(status(p))\n+    ? fs::directory_iterator(p) == fs::directory_iterator()\n+    : fs::file_size(p) == 0;\n+}\n+\n+bool\n+fs::is_empty(const path& p, error_code& ec) noexcept\n+{\n+  auto s = status(p, ec);\n+  if (ec.value())\n+    return false;\n+  return fs::is_directory(s)\n+    ? fs::directory_iterator(p, ec) == fs::directory_iterator()\n+    : fs::file_size(p, ec) == 0;\n+}\n+\n+fs::file_time_type\n+fs::last_write_time(const path& p)\n+{\n+  error_code ec;\n+  auto t = last_write_time(p, ec);\n+  if (ec.value())\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\"cannot get file time\", p, ec));\n+  return t;\n+}\n+\n+fs::file_time_type\n+fs::last_write_time(const path& p, error_code& ec) noexcept\n+{\n+  return do_stat(p, ec, [](const auto& st) { return file_time(st); },\n+\t\t file_time_type::min());\n+}\n+\n+void\n+fs::last_write_time(const path& p, file_time_type new_time)\n+{\n+  error_code ec;\n+  last_write_time(p, new_time, ec);\n+  if (ec.value())\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\"cannot set file time\", p, ec));\n+}\n+\n+void\n+fs::last_write_time(const path& p __attribute__((__unused__)),\n+\t\t    file_time_type new_time, error_code& ec) noexcept\n+{\n+  auto d = new_time.time_since_epoch();\n+  auto s = chrono::duration_cast<chrono::seconds>(d);\n+  auto ns = chrono::duration_cast<chrono::nanoseconds>(d - s);\n+#ifdef _GLIBCXX_USE_UTIMENSAT\n+  struct ::timespec ts[2] = {\n+    { 0, UTIME_OMIT },\n+    { static_cast<std::time_t>(s.count()), static_cast<long>(ns.count()) }\n+  };\n+  if (utimensat(AT_FDCWD, p.c_str(), ts, 0))\n+    ec.assign(errno, std::generic_category());\n+  else\n+    ec.clear();\n+#else\n+  ec = std::make_error_code(std::errc::not_supported);\n+#endif\n+}\n+\n+void\n+fs::permissions(const path& p, perms prms)\n+{\n+  error_code ec;\n+  permissions(p, prms, ec);\n+  if (ec.value())\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\"cannot set permissions\", p, ec));\n+}\n+\n+void fs::permissions(const path& p, perms prms, error_code& ec) noexcept\n+{\n+  if (int err = ::fchmodat(AT_FDCWD, p.c_str(), static_cast<mode_t>(prms), 0))\n+    ec.assign(err, std::generic_category());\n+  else\n+    ec.clear();\n+}\n+\n+fs::path\n+fs::read_symlink(const path& p)\n+{\n+  error_code ec;\n+  path tgt = read_symlink(p, ec);\n+  if (ec.value())\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\"read_symlink\", p, ec));\n+  return tgt;\n+}\n+\n+fs::path fs::read_symlink(const path& p, error_code& ec)\n+{\n+#ifdef _GLIBCXX_HAVE_SYS_STAT_H\n+  struct ::stat st;\n+  if (::lstat(p.c_str(), &st))\n+    {\n+      ec.assign(errno, std::generic_category());\n+      return {};\n+    }\n+  std::string buf(st.st_size, '\\0');\n+  ssize_t len = ::readlink(p.c_str(), &buf.front(), buf.size());\n+  if (len == -1)\n+    {\n+      ec.assign(errno, std::generic_category());\n+      return {};\n+    }\n+  return path{buf.data(), buf.data()+len};\n+#else\n+  ec = std::make_error_code(std::errc::not_supported);\n+  return {};\n+#endif\n+}\n+\n+\n+bool\n+fs::remove(const path& p)\n+{\n+  error_code ec;\n+  bool result = fs::remove(p, ec);\n+  if (ec.value())\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\"cannot remove\", p, ec));\n+  return result;\n+}\n+\n+bool\n+fs::remove(const path& p, error_code& ec) noexcept\n+{\n+  if (exists(symlink_status(p, ec)))\n+    {\n+      if (::remove(p.c_str()) == 0)\n+\t{\n+\t  ec.clear();\n+\t  return true;\n+\t}\n+      else\n+\tec.assign(errno, std::generic_category());\n+    }\n+  return false;\n+}\n+\n+\n+std::uintmax_t\n+fs::remove_all(const path& p)\n+{\n+  error_code ec;\n+  bool result = remove_all(p, ec);\n+  if (ec.value())\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\"cannot remove all\", p, ec));\n+  return result;\n+}\n+\n+std::uintmax_t\n+fs::remove_all(const path& p, error_code& ec) noexcept\n+{\n+  auto fs = symlink_status(p, ec);\n+  uintmax_t count = 0;\n+  if (ec.value() == 0 && fs.type() == file_type::directory)\n+    for (directory_iterator d(p, ec), end; ec.value() == 0 && d != end; ++d)\n+      count += fs::remove(d->path(), ec);\n+  if (ec.value())\n+    return -1;\n+  return fs::remove(p, ec) ? ++count : -1;  // fs:remove() calls ec.clear()\n+}\n+\n+void\n+fs::rename(const path& from, const path& to)\n+{\n+  error_code ec;\n+  rename(from, to, ec);\n+  if (ec.value())\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\"cannot rename\", from, to, ec));\n+}\n+\n+void\n+fs::rename(const path& from, const path& to, error_code& ec) noexcept\n+{\n+  if (::rename(from.c_str(), to.c_str()))\n+    ec.assign(errno, std::generic_category());\n+  else\n+    ec.clear();\n+}\n+\n+void\n+fs::resize_file(const path& p, uintmax_t size)\n+{\n+  error_code ec;\n+  resize_file(p, size, ec);\n+  if (ec.value())\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\"cannot resize file\", p, ec));\n+}\n+\n+void\n+fs::resize_file(const path& p, uintmax_t size, error_code& ec) noexcept\n+{\n+#ifdef _GLIBCXX_HAVE_UNISTD_H\n+  if (size > static_cast<uintmax_t>(std::numeric_limits<off_t>::max()))\n+    ec.assign(EINVAL, std::generic_category());\n+  else if (::truncate(p.c_str(), size))\n+    ec.assign(errno, std::generic_category());\n+  else\n+    ec.clear();\n+#else\n+  ec = std::make_error_code(std::errc::not_supported);\n+#endif\n+}\n+\n+\n+fs::space_info\n+fs::space(const path& p)\n+{\n+  error_code ec;\n+  space_info s = space(p, ec);\n+  if (ec.value())\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\"cannot get free space\", p, ec));\n+  return s;\n+}\n+\n+fs::space_info\n+fs::space(const path& p, error_code& ec) noexcept\n+{\n+  space_info info = {\n+    static_cast<uintmax_t>(-1),\n+    static_cast<uintmax_t>(-1),\n+    static_cast<uintmax_t>(-1)\n+  };\n+#ifdef _GLIBCXX_HAVE_SYS_STATVFS_H\n+  struct ::statvfs f;\n+  if (int err = ::statvfs(p.c_str(), &f))\n+      ec.assign(err, std::generic_category());\n+  else\n+    {\n+      info = space_info{\n+\tf.f_blocks * f.f_frsize,\n+\tf.f_bfree * f.f_frsize,\n+\tf.f_bavail * f.f_frsize\n+      };\n+      ec.clear();\n+    }\n+#endif\n+  return info;\n+}\n+\n+#ifdef _GLIBCXX_HAVE_SYS_STAT_H\n+fs::file_status\n+fs::status(const fs::path& p, std::error_code& ec) noexcept\n+{\n+  file_status status;\n+  struct ::stat st;\n+  if (::stat(p.c_str(), &st))\n+    {\n+      int err = errno;\n+      ec.assign(err, std::generic_category());\n+      if (is_not_found_errno(err))\n+\tstatus = file_status{file_type::not_found};\n+    }\n+  else\n+    {\n+      status = make_file_status(st);\n+      ec.clear();\n+    }\n+  return status;\n+}\n+\n+fs::file_status\n+fs::symlink_status(const fs::path& p, std::error_code& ec) noexcept\n+{\n+  file_status status;\n+  struct ::stat st;\n+  if (::lstat(p.c_str(), &st))\n+    {\n+      int err = errno;\n+      ec.assign(err, std::generic_category());\n+      if (is_not_found_errno(err))\n+\tstatus = file_status{file_type::not_found};\n+    }\n+  else\n+    {\n+      status = make_file_status(st);\n+      ec.clear();\n+    }\n+  return status;\n+}\n+#endif\n+\n+fs::file_status\n+fs::status(const fs::path& p)\n+{\n+  std::error_code ec;\n+  auto s = status(p, ec);\n+  if (ec.value())\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\"status\", p, ec));\n+  return s;\n+}\n+\n+fs::file_status\n+fs::symlink_status(const fs::path& p)\n+{\n+  std::error_code ec;\n+  auto s = symlink_status(p, ec);\n+  if (ec.value())\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\"symlink_status\", ec));\n+  return s;\n+}\n+\n+fs::path\n+fs::system_complete(const path& p)\n+{\n+  error_code ec;\n+  path comp = system_complete(p, ec);\n+  if (ec.value())\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\"system_complete\", p, ec));\n+  return comp;\n+}\n+\n+fs::path\n+fs::system_complete(const path& p, error_code& ec)\n+{\n+  path base = current_path(ec);\n+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n+  if (p.is_absolute() || !p.has_root_name()\n+      || p.root_name() == base.root_name())\n+    return absolute(p, base);\n+  // else TODO\n+  ec = std::make_error_code(std::errc::not_supported);\n+  return {};\n+#else\n+  if (ec.value())\n+    return {};\n+  return absolute(p, base);\n+#endif\n+}\n+\n+fs::path fs::temp_directory_path()\n+{\n+  error_code ec;\n+  path tmp = temp_directory_path(ec);\n+  if (ec.value())\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\"temp_directory_path\", ec));\n+  return tmp;\n+}\n+\n+fs::path fs::temp_directory_path(error_code& ec)\n+{\n+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n+  return {}; // TODO\n+#else\n+  const char* tmpdir = ::getenv(\"TMPDIR\");\n+  if (!tmpdir)\n+    tmpdir = \"/tmp\";\n+  ec.clear();\n+  return tmpdir;\n+#endif\n+}\n+"}, {"sha": "db58f3bdb7088c8576a63899310e38cf64e7bc4c", "filename": "libstdc++-v3/src/filesystem/path.cc", "status": "added", "additions": 464, "deletions": 0, "changes": 464, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fpath.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fpath.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fpath.cc?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -0,0 +1,464 @@\n+// Class filesystem::path -*- C++ -*-\n+\n+// Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <experimental/filesystem>\n+\n+using std::experimental::filesystem::path;\n+\n+constexpr path::value_type path::preferred_separator;\n+\n+path&\n+path::remove_filename()\n+{\n+  if (_M_type == _Type::_Multi)\n+    {\n+      if (!_M_cmpts.empty())\n+\t{\n+\t  auto cmpt = --_M_cmpts.end();\n+\t  _M_pathname.erase(cmpt->_M_pos);\n+\t  _M_cmpts.erase(cmpt);\n+\t  _M_trim();\n+\t}\n+    }\n+  else\n+    clear();\n+  return *this;\n+}\n+\n+path&\n+path::replace_filename(const path& replacement)\n+{\n+  remove_filename();\n+  operator/=(replacement);\n+  return *this;\n+}\n+\n+path&\n+path::replace_extension(const path& replacement)\n+{\n+  auto ext = _M_find_extension();\n+  if (ext.first && ext.second != string_type::npos)\n+    {\n+      if (ext.first == &_M_pathname)\n+\t_M_pathname.erase(ext.second);\n+      else\n+\t{\n+\t  const auto& back = _M_cmpts.back();\n+\t  if (ext.first != &back._M_pathname)\n+\t    _GLIBCXX_THROW_OR_ABORT(\n+\t\tstd::logic_error(\"path::replace_extension failed\"));\n+\t  _M_pathname.erase(back._M_pos + ext.second);\n+\t}\n+    }\n+  if (!replacement.empty() && replacement.native()[0] != '.')\n+    _M_pathname += '.';\n+  _M_pathname += replacement.native();\n+  _M_split_cmpts();\n+  return *this;\n+}\n+\n+namespace\n+{\n+  template<typename Iter1, typename Iter2>\n+    int do_compare(Iter1 begin1, Iter1 end1, Iter2 begin2, Iter2 end2)\n+    {\n+      int cmpt = 1;\n+      while (begin1 != end1 && begin2 != end2)\n+\t{\n+\t  if (begin1->native() < begin2->native())\n+\t    return -cmpt;\n+\t  if (begin1->native() > begin2->native())\n+\t    return +cmpt;\n+\t  ++begin1;\n+\t  ++begin2;\n+\t  ++cmpt;\n+\t}\n+      if (begin1 == end1)\n+\t{\n+\t  if (begin2 == end2)\n+\t    return 0;\n+\t  return -cmpt;\n+\t}\n+      return +cmpt;\n+    }\n+}\n+\n+int\n+path::compare(const path& p) const noexcept\n+{\n+  if (_M_type == _Type::_Multi && p._M_type == _Type::_Multi)\n+    return do_compare(_M_cmpts.begin(), _M_cmpts.end(),\n+\t\t   p._M_cmpts.begin(), p._M_cmpts.end());\n+  else if (_M_type == _Type::_Multi)\n+    {\n+      _Cmpt c[1] = { { p._M_pathname, p._M_type, 0 } };\n+      return do_compare(_M_cmpts.begin(), _M_cmpts.end(), c, c+1);\n+    }\n+  else if (p._M_type == _Type::_Multi)\n+    {\n+      _Cmpt c[1] = { { _M_pathname, _M_type, 0 } };\n+      return do_compare(c, c+1, p._M_cmpts.begin(), p._M_cmpts.end());\n+    }\n+  else\n+    return _M_pathname.compare(p._M_pathname);\n+}\n+\n+path\n+path::root_name() const\n+{\n+  path __ret;\n+  if (_M_type == _Type::_Root_name)\n+    __ret = *this;\n+  else if (_M_cmpts.size()\n+      && _M_cmpts.begin()->_M_type == _Type::_Root_name)\n+    __ret = *_M_cmpts.begin();\n+  return __ret;\n+}\n+\n+path\n+path::root_directory() const\n+{\n+  path __ret;\n+  if (_M_type == _Type::_Root_dir)\n+    __ret = *this;\n+  else if (!_M_cmpts.empty())\n+    {\n+      auto __it = _M_cmpts.begin();\n+      if (__it->_M_type == _Type::_Root_name)\n+        ++__it;\n+      if (__it != _M_cmpts.end() && __it->_M_type == _Type::_Root_dir)\n+        __ret = *__it;\n+    }\n+  return __ret;\n+}\n+\n+\n+path\n+path::root_path() const\n+{\n+  path __ret;\n+  if (_M_type == _Type::_Root_name || _M_type == _Type::_Root_dir)\n+    __ret = *this;\n+  else if (!_M_cmpts.empty())\n+    {\n+      auto __it = _M_cmpts.begin();\n+      if (__it->_M_type == _Type::_Root_name)\n+        {\n+          __ret = *__it++;\n+          if (__it != _M_cmpts.end() && __it->_M_type == _Type::_Root_dir)\n+            {\n+              __ret._M_pathname += preferred_separator;\n+              __ret._M_split_cmpts();\n+            }\n+        }\n+      else if (__it->_M_type == _Type::_Root_dir)\n+        __ret = *__it;\n+    }\n+  return __ret;\n+}\n+\n+path\n+path::relative_path() const\n+{\n+  path __ret;\n+  if (_M_type == _Type::_Filename)\n+    __ret = *this;\n+  else if (!_M_cmpts.empty())\n+    {\n+      auto __it = _M_cmpts.begin();\n+      if (__it->_M_type == _Type::_Root_name)\n+        ++__it;\n+      if (__it != _M_cmpts.end() && __it->_M_type == _Type::_Root_dir)\n+        ++__it;\n+      if (__it != _M_cmpts.end())\n+        __ret.assign(_M_pathname.substr(__it->_M_pos));\n+    }\n+  return __ret;\n+}\n+\n+path\n+path::parent_path() const\n+{\n+  path __ret;\n+  if (_M_cmpts.size() < 2)\n+    return __ret;\n+  for (auto __it = _M_cmpts.begin(), __end = --_M_cmpts.end();\n+      __it != __end; ++__it)\n+    {\n+      __ret /= *__it;\n+    }\n+  return __ret;\n+}\n+\n+bool\n+path::has_root_name() const\n+{\n+  if (_M_type == _Type::_Root_name)\n+    return true;\n+  if (!_M_cmpts.empty() && _M_cmpts.begin()->_M_type == _Type::_Root_name)\n+    return true;\n+  return false;\n+}\n+\n+bool\n+path::has_root_directory() const\n+{\n+  if (_M_type == _Type::_Root_dir)\n+    return true;\n+  if (!_M_cmpts.empty())\n+    {\n+      auto __it = _M_cmpts.begin();\n+      if (__it->_M_type == _Type::_Root_name)\n+        ++__it;\n+      if (__it != _M_cmpts.end() && __it->_M_type == _Type::_Root_dir)\n+        return true;\n+    }\n+  return false;\n+}\n+\n+bool\n+path::has_root_path() const\n+{\n+  if (_M_type == _Type::_Root_name || _M_type == _Type::_Root_dir)\n+    return true;\n+  if (!_M_cmpts.empty())\n+    {\n+      auto __type = _M_cmpts.front()._M_type;\n+      if (__type == _Type::_Root_name || __type == _Type::_Root_dir)\n+        return true;\n+    }\n+  return false;\n+}\n+\n+bool\n+path::has_relative_path() const\n+{\n+  if (_M_type == _Type::_Filename)\n+    return true;\n+  if (!_M_cmpts.empty())\n+    {\n+      auto __it = _M_cmpts.begin();\n+      if (__it->_M_type == _Type::_Root_name)\n+        ++__it;\n+      if (__it != _M_cmpts.end() && __it->_M_type == _Type::_Root_dir)\n+        ++__it;\n+      if (__it != _M_cmpts.end())\n+        return true;\n+    }\n+  return false;\n+}\n+\n+\n+bool\n+path::has_parent_path() const\n+{\n+  return _M_cmpts.size() > 1;\n+}\n+\n+bool\n+path::has_filename() const\n+{\n+  return !empty();\n+}\n+\n+std::pair<const path::string_type*, std::size_t>\n+path::_M_find_extension() const\n+{\n+  const std::string* s = nullptr;\n+\n+  if (_M_type != _Type::_Multi)\n+    s = &_M_pathname;\n+  else if (!_M_cmpts.empty())\n+    {\n+      const auto& c = _M_cmpts.back();\n+      if (c._M_type == _Type::_Filename)\n+\ts = &c._M_pathname;\n+    }\n+\n+  if (s)\n+    {\n+      if (auto sz = s->size())\n+\t{\n+\t  if (sz <= 2 && (*s)[0] == '.')\n+\t    {\n+\t      if (sz == 1 || (*s)[1] == '.')  // filename is \".\" or \"..\"\n+\t\treturn { s, string_type::npos };\n+\t      else\n+\t\treturn { s, 0 };  // filename is like \".?\"\n+\t    }\n+\t  return { s, s->rfind('.') };\n+\t}\n+    }\n+  return {};\n+}\n+\n+void\n+path::_M_split_cmpts()\n+{\n+  _M_type = _Type::_Multi;\n+  _M_cmpts.clear();\n+\n+  if (_M_pathname.empty())\n+    return;\n+\n+  size_t pos = 0;\n+  const size_t len = _M_pathname.size();\n+\n+  // look for root name or root directory\n+  if (_S_is_dir_sep(_M_pathname[0]))\n+    {\n+      // look for root name, such as \"//\" or \"//foo\"\n+      if (len > 1 && _M_pathname[1] == _M_pathname[0])\n+\t{\n+\t  if (len == 2)\n+\t    {\n+\t      // entire path is just \"//\"\n+\t      _M_type = _Type::_Root_name;\n+\t      return;\n+\t    }\n+\n+\t  if (!_S_is_dir_sep(_M_pathname[2]))\n+\t    {\n+\t      // got root name, find its end\n+\t      pos = 3;\n+\t      while (pos < len && !_S_is_dir_sep(_M_pathname[pos]))\n+\t\t++pos;\n+\t      _M_add_root_name(pos);\n+\t      if (pos < len) // also got root directory\n+\t\t_M_add_root_dir(pos);\n+\t    }\n+\t  else\n+\t    {\n+\t      // got something like \"///foo\" which is just a root directory\n+\t      // composed of multiple redundant directory separators\n+\t      _M_add_root_dir(0);\n+\t    }\n+\t}\n+      else // got root directory\n+\t_M_add_root_dir(0);\n+      ++pos;\n+    }\n+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n+  else if (len > 1 && _M_pathname[1] == L':')\n+    {\n+      // got disk designator\n+      _M_add_root_name(2);\n+      if (len > 2 && _S_is_dir_sep(_M_pathname[2]))\n+\t_M_add_root_dir(2);\n+      pos = 2;\n+    }\n+#endif\n+\n+  size_t back = pos;\n+  while (pos < len)\n+    {\n+      if (_S_is_dir_sep(_M_pathname[pos]))\n+\t{\n+\t  if (back != pos)\n+\t    _M_add_filename(back, pos - back);\n+\t  back = ++pos;\n+\t}\n+      else\n+\t++pos;\n+    }\n+\n+  if (back != pos)\n+    _M_add_filename(back, pos - back);\n+  else if (_S_is_dir_sep(_M_pathname.back()))\n+    {\n+      // [path.itr]/8\n+      // \"Dot, if one or more trailing non-root slash characters are present.\"\n+      if (_M_cmpts.back()._M_type == _Type::_Filename)\n+\t{\n+\t  const auto& last = _M_cmpts.back();\n+\t  pos = last._M_pos + last._M_pathname.size();\n+\t  _M_cmpts.emplace_back(string_type(1, '.'), _Type::_Filename, pos);\n+\t}\n+    }\n+\n+  _M_trim();\n+}\n+\n+void\n+path::_M_add_root_name(size_t n)\n+{\n+  _M_cmpts.emplace_back(_M_pathname.substr(0, n), _Type::_Root_name, 0);\n+}\n+\n+void\n+path::_M_add_root_dir(size_t pos)\n+{\n+  _M_cmpts.emplace_back(_M_pathname.substr(pos, 1), _Type::_Root_dir, pos);\n+}\n+\n+void\n+path::_M_add_filename(size_t pos, size_t n)\n+{\n+  _M_cmpts.emplace_back(_M_pathname.substr(pos, n), _Type::_Filename, pos);\n+}\n+\n+void\n+path::_M_trim()\n+{\n+  if (_M_cmpts.size() == 1)\n+    {\n+      _M_type = _M_cmpts.front()._M_type;\n+      _M_cmpts.clear();\n+    }\n+}\n+\n+path::string_type\n+path::_S_convert_loc(const char* __first, const char* __last,\n+               const std::locale& __loc)\n+{\n+  auto& __cvt = std::use_facet<codecvt<wchar_t, char, mbstate_t>>(__loc);\n+  basic_string<wchar_t> __ws;\n+  if (!__str_codecvt_in(__first, __last, __ws, __cvt))\n+    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\n+\t  \"Cannot convert character sequence\",\n+\t  std::make_error_code(errc::illegal_byte_sequence)));\n+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n+  return __ws;\n+#else\n+  return _Cvt<wchar_t>::_S_convert(__ws.data(), __ws.data() + __ws.size());\n+#endif\n+}\n+\n+std::size_t\n+std::experimental::filesystem::hash_value(const path& p) noexcept\n+{\n+  // [path.non-member]\n+  // \"If for two paths, p1 == p2 then hash_value(p1) == hash_value(p2).\"\n+  // Equality works as if by traversing the range [begin(), end()), meaning\n+  // e.g. path(\"a//b\") == path(\"a/b\"), so we cannot simply hash _M_pathname\n+  // but need to iterate over individual elements. Use the hash_combine from\n+  // http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3876.pdf\n+  size_t seed = 0;\n+  for (const auto& x : p)\n+    {\n+      seed ^= std::hash<path::string_type>()(x.native()) + 0x9e3779b9\n+\t+ (seed<<6) + (seed>>2);\n+    }\n+  return seed;\n+}"}, {"sha": "14625b5bc2c7e2bb0c4b271818b9e8cc600ca254", "filename": "libstdc++-v3/testsuite/experimental/filesystem/operations/absolute.cc", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Foperations%2Fabsolute.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Foperations%2Fabsolute.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Foperations%2Fabsolute.cc?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -0,0 +1,55 @@\n+// { dg-options \"-std=gnu++11 -lstdc++fs\" }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 15.1 Absolute [fs.op.absolute]\n+\n+#include <experimental/filesystem>\n+#include <testsuite_fs.h>\n+#include <testsuite_hooks.h>\n+\n+using std::experimental::filesystem::path;\n+\n+void\n+test01()\n+{\n+  for (const path& p : __gnu_test::test_paths)\n+    VERIFY( absolute(p).is_absolute() );\n+}\n+\n+void\n+test02()\n+{\n+  path p1(\"/\");\n+  VERIFY( absolute(p1) == p1 );\n+  VERIFY( absolute(p1, \"/bar\") == p1 );\n+  path p2(\"/foo\");\n+  VERIFY( absolute(p2) == p2 );\n+  VERIFY( absolute(p2, \"/bar\") == p2 );\n+  path p3(\"foo\");\n+  VERIFY( absolute(p3) != p3 );\n+  VERIFY( absolute(p3, \"/bar\") == \"/bar/foo\" );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "2410c802f23ccc2abf0bea839d603af341299458", "filename": "libstdc++-v3/testsuite/experimental/filesystem/operations/copy.cc", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Foperations%2Fcopy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Foperations%2Fcopy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Foperations%2Fcopy.cc?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -0,0 +1,55 @@\n+// { dg-options \"-std=gnu++11 -lstdc++fs\" }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 15.3 Copy [fs.op.copy]\n+\n+#include <experimental/filesystem>\n+#include <testsuite_fs.h>\n+#include <testsuite_hooks.h>\n+\n+using std::experimental::filesystem::path;\n+\n+void\n+test01()\n+{\n+  for (const path& p : __gnu_test::test_paths)\n+    VERIFY( absolute(p).is_absolute() );\n+}\n+\n+void\n+test02()\n+{\n+  path p1(\"/\");\n+  VERIFY( absolute(p1) == p1 );\n+  VERIFY( absolute(p1, \"/bar\") == p1 );\n+  path p2(\"/foo\");\n+  VERIFY( absolute(p2) == p2 );\n+  VERIFY( absolute(p2, \"/bar\") == p2 );\n+  path p3(\"foo\");\n+  VERIFY( absolute(p3) != p3 );\n+  VERIFY( absolute(p3, \"/bar\") == \"/bar/foo\" );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "325a5a852fd494b3a9768690bb09494288c50b6d", "filename": "libstdc++-v3/testsuite/experimental/filesystem/operations/current_path.cc", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Foperations%2Fcurrent_path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Foperations%2Fcurrent_path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Foperations%2Fcurrent_path.cc?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -0,0 +1,57 @@\n+// { dg-options \"-std=gnu++11 -lstdc++fs\" }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 15.11 Current path [fs.op.current_path]\n+\n+#include <experimental/filesystem>\n+#include <testsuite_fs.h>\n+#include <testsuite_hooks.h>\n+\n+namespace fs = std::experimental::filesystem;\n+\n+void\n+test01()\n+{\n+  fs::path dot(\".\");\n+  fs::path cwd = fs::current_path();\n+  std::error_code ec;\n+  fs::path cwd2 = fs::current_path(ec);\n+  VERIFY( cwd == cwd2 );\n+}\n+\n+void\n+test02()\n+{\n+  auto oldwd = fs::current_path();\n+  auto tmpdir = fs::temp_directory_path();\n+  current_path(tmpdir);\n+  VERIFY( fs::current_path() == tmpdir );\n+  std::error_code ec;\n+  current_path(oldwd, ec);\n+  VERIFY( fs::current_path() == oldwd );\n+  VERIFY( fs::current_path(ec) == oldwd );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "75d2df0c8a33f166ffbdfdcf3eb9956d50fc61d9", "filename": "libstdc++-v3/testsuite/experimental/filesystem/path/append/path.cc", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fappend%2Fpath.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fappend%2Fpath.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fappend%2Fpath.cc?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -0,0 +1,63 @@\n+// { dg-options \"-std=gnu++11 -lstdc++fs\" }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.3 path appends [path.append]\n+\n+#include <experimental/filesystem>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+using std::experimental::filesystem::path;\n+\n+void\n+test01()\n+{\n+  const path p(\"/foo/bar\");\n+\n+  path pp = p;\n+  pp /= p;\n+  VERIFY( pp.native() == \"/foo/bar/foo/bar\" );\n+\n+  path q(\"baz\");\n+\n+  path qq = q;\n+  qq /= q;\n+  VERIFY( qq.native() == \"baz/baz\" );\n+\n+  q /= p;\n+  VERIFY( q.native() == \"baz/foo/bar\" );\n+\n+  path r = \"\";\n+  r /= path();\n+  VERIFY( r.empty() );\n+\n+  r /= path(\"rel\");\n+  VERIFY( !r.is_absolute() );\n+\n+  path s = \"dir/\";\n+  s /= path(\"/file\");\n+  VERIFY( s.native() == \"dir//file\" );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "6fd24a77cf30c076e5ee6c6604e6b056dab0d796", "filename": "libstdc++-v3/testsuite/experimental/filesystem/path/assign/assign.cc", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fassign%2Fassign.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fassign%2Fassign.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fassign%2Fassign.cc?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -0,0 +1,89 @@\n+// { dg-options \"-std=gnu++11 -lstdc++fs\" }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <testsuite_fs.h>\n+\n+using std::experimental::filesystem::path;\n+using __gnu_test::compare_paths;\n+\n+void\n+test01()\n+{\n+  for (std::string s : __gnu_test::test_paths)\n+  {\n+    path p0 = s, p1, p2, p3, p4;\n+\n+    p1 = s;\n+    compare_paths(p0, p1);\n+\n+    p2 = s.c_str();\n+    compare_paths(p0, p2);\n+\n+    std::wstring ws(s.begin(), s.end());\n+\n+    p3 = ws;\n+    compare_paths(p0, p3);\n+\n+    p4 = ws.c_str();\n+    compare_paths(p0, p4);\n+  }\n+}\n+\n+void\n+test02()\n+{\n+  for (std::string s : __gnu_test::test_paths)\n+  {\n+    path p0 = s, p1, p2, p3, p4, p5, p6, p7, p8;\n+\n+    p1.assign(s);\n+    compare_paths(p0, p1);\n+\n+    p2.assign( s.begin(), s.end() );\n+    compare_paths(p0, p2);\n+\n+    p3.assign( s.c_str() );\n+    compare_paths(p0, p3);\n+\n+    p4.assign( s.c_str(), s.c_str() + s.size() );\n+    compare_paths(p0, p4);\n+\n+    std::wstring ws(s.begin(), s.end());\n+\n+    p5.assign(ws);\n+    compare_paths(p0, p5);\n+\n+    p6.assign( ws.begin(), ws.end() );\n+    compare_paths(p0, p6);\n+\n+    p7.assign( ws.c_str() );\n+    compare_paths(p0, p7);\n+\n+    p8.assign( ws.c_str(), ws.c_str() + ws.size() );\n+    compare_paths(p0, p8);\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "29dbcd4035d3558de66a044e1a06c14632d0ab6d", "filename": "libstdc++-v3/testsuite/experimental/filesystem/path/assign/copy.cc", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fassign%2Fcopy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fassign%2Fcopy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fassign%2Fcopy.cc?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -0,0 +1,55 @@\n+// { dg-options \"-std=gnu++11 -lstdc++fs\" }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <experimental/filesystem>\n+#include <testsuite_fs.h>\n+\n+using std::experimental::filesystem::path;\n+using __gnu_test::compare_paths;\n+\n+void\n+test01()\n+{\n+  for (const path& p : __gnu_test::test_paths)\n+  {\n+    path copy;\n+    copy = p;\n+    __gnu_test::compare_paths(p, copy);\n+  }\n+}\n+\n+void\n+test02()\n+{\n+  for (const path& p : __gnu_test::test_paths)\n+  {\n+    path copy = p;\n+    path move;\n+    move = std::move(copy);\n+    __gnu_test::compare_paths(p, move);\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "e8f5e41cfa1b8f1643eab3a59c4a8f545915a146", "filename": "libstdc++-v3/testsuite/experimental/filesystem/path/compare/compare.cc", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fcompare%2Fcompare.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fcompare%2Fcompare.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fcompare%2Fcompare.cc?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -0,0 +1,50 @@\n+// { dg-options \"-std=gnu++11 -lstdc++fs\" }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.8 path compare [path.compare]\n+\n+#include <experimental/filesystem>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+using std::experimental::filesystem::path;\n+\n+void\n+test01()\n+{\n+  path p(\"/foo/bar\");\n+  VERIFY( p.compare(p) == 0 );\n+  VERIFY( p.compare(\"/foo//bar\") == 0 );\n+\n+  path q(\"/foo/baz\");\n+  VERIFY( p.compare(q) < 0 );\n+  VERIFY( q.compare(p) > 0 );\n+\n+  path r(\"/foo/bar/.\");\n+  VERIFY( p.compare(r) < 0 );\n+\n+  VERIFY( path(\"a/b/\").compare(\"a/b/.\") == 0 );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "7858af16228b2adb76b7692f1896708c691a9116", "filename": "libstdc++-v3/testsuite/experimental/filesystem/path/compare/path.cc", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fcompare%2Fpath.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fcompare%2Fpath.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fcompare%2Fpath.cc?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -0,0 +1,50 @@\n+// { dg-options \"-std=gnu++11 -lstdc++fs\" }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.8 path compare [path.compare]\n+\n+#include <experimental/filesystem>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+using std::experimental::filesystem::path;\n+\n+void\n+test01()\n+{\n+  const path p0 = \"/a/a/b/b\";\n+  for (const path& p : __gnu_test::test_paths)\n+  {\n+    VERIFY( p.compare(p) == 0 );\n+    int cmp = p.compare(p0);\n+    if (cmp == 0)\n+      VERIFY( p0.compare(p) == 0 );\n+    else if (cmp < 0)\n+      VERIFY( p0.compare(p) > 0 );\n+    else if (cmp > 0)\n+      VERIFY( p0.compare(p) < 0 );\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "7e6156819ad71b2578c137b1c9ef033171d37824", "filename": "libstdc++-v3/testsuite/experimental/filesystem/path/compare/strings.cc", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fcompare%2Fstrings.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fcompare%2Fstrings.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fcompare%2Fstrings.cc?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -0,0 +1,48 @@\n+// { dg-options \"-std=gnu++11 -lstdc++fs\" }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.8 path compare [path.compare]\n+\n+#include <experimental/filesystem>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+using std::experimental::filesystem::path;\n+\n+void\n+test01()\n+{\n+  const std::string s0 = \"/a/a/b/b\";\n+  const path p0 = s0;\n+  for (const std::string& s : __gnu_test::test_paths)\n+  {\n+    path p(s);\n+    VERIFY( p.compare(s) == 0 );\n+    VERIFY( p.compare(s.c_str()) == 0 );\n+    VERIFY( p.compare(p0) == p.compare(s0) );\n+    VERIFY( p.compare(p0) == p.compare(s0.c_str()) );\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "fceae117d2e432389349c2878ab4a4087d8f393e", "filename": "libstdc++-v3/testsuite/experimental/filesystem/path/concat/path.cc", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fconcat%2Fpath.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fconcat%2Fpath.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fconcat%2Fpath.cc?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -0,0 +1,68 @@\n+// { dg-options \"-std=gnu++11 -lstdc++fs\" }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.4 path concatenation [path.concat]\n+\n+#include <experimental/filesystem>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+using std::experimental::filesystem::path;\n+\n+void\n+test01()\n+{\n+  const path p(\"/foo/bar\");\n+\n+  path pp = p;\n+  pp += p;\n+  VERIFY( pp.native() == \"/foo/bar/foo/bar\" );\n+  VERIFY( std::distance(pp.begin(), pp.end()) == 5 );\n+\n+  path q(\"foo/bar\");\n+\n+  path qq = q;\n+  qq += q;\n+  VERIFY( qq.native() == \"foo/barfoo/bar\" );\n+  VERIFY( std::distance(qq.begin(), qq.end()) == 3 );\n+\n+  q += p;\n+  VERIFY( q.native() == \"foo/bar/foo/bar\" );\n+  VERIFY( std::distance(q.begin(), q.end()) == 4 );\n+}\n+\n+void\n+test02()\n+{\n+  for (path p : __gnu_test::test_paths)\n+  {\n+    auto prior_native = p.native();\n+    path x(\"//blah/di/blah\");\n+    p += x;\n+    VERIFY( p.native() == prior_native + x.native() );\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "e75e790a49199cffb57c9812d49dcd902eb19677", "filename": "libstdc++-v3/testsuite/experimental/filesystem/path/concat/strings.cc", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fconcat%2Fstrings.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fconcat%2Fstrings.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fconcat%2Fstrings.cc?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -0,0 +1,51 @@\n+// { dg-options \"-std=gnu++11 -lstdc++fs\" }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.4 path concatenation [path.concat]\n+\n+#include <experimental/filesystem>\n+#include <testsuite_hooks.h>\n+\n+using std::experimental::filesystem::path;\n+\n+void\n+test01()\n+{\n+  path p(\"/\");\n+  p += path::string_type(\"foo\");\n+  VERIFY( p.filename() == \"foo\" );\n+  p += \"bar\";\n+  VERIFY( p.filename() == \"foobar\" );\n+  p += '/';\n+  VERIFY( p.parent_path() == \"/foobar\" && p.filename() == \".\" );\n+  p += L\"baz.txt\";\n+  VERIFY( p.filename() == \"baz.txt\" );\n+  p.concat(\"/dir/\");\n+  VERIFY( p.parent_path() == \"/foobar/baz.txt/dir\" && p.filename() == \".\" );\n+  std::string file = \"file\";\n+  p.concat(file.begin(), file.end());\n+  VERIFY( p.filename() == \"file\" );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "d0180b6c0a264614b1943ebe345aec39bd3e84fb", "filename": "libstdc++-v3/testsuite/experimental/filesystem/path/construct/copy.cc", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fconstruct%2Fcopy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fconstruct%2Fcopy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fconstruct%2Fcopy.cc?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -0,0 +1,54 @@\n+// { dg-options \"-std=gnu++11 -lstdc++fs\" }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.1 path constructors [path.construct]\n+\n+#include <experimental/filesystem>\n+#include <testsuite_fs.h>\n+\n+using std::experimental::filesystem::path;\n+\n+void\n+test01()\n+{\n+  for (const path& p : __gnu_test::test_paths)\n+  {\n+    path copy = p;\n+    __gnu_test::compare_paths(p, copy);\n+  }\n+}\n+\n+void\n+test02()\n+{\n+  for (const path& p : __gnu_test::test_paths)\n+  {\n+    path copy = p;\n+    path move = std::move(copy);\n+    __gnu_test::compare_paths(p, move);\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "d8952a73726eb945da488b123a9bfb0a711a5081", "filename": "libstdc++-v3/testsuite/experimental/filesystem/path/construct/default.cc", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fconstruct%2Fdefault.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fconstruct%2Fdefault.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fconstruct%2Fdefault.cc?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -0,0 +1,50 @@\n+// { dg-options \"-std=gnu++11 -lstdc++fs\" }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.1 path constructors [path.construct]\n+\n+#include <experimental/filesystem>\n+#include <testsuite_hooks.h>\n+\n+using std::experimental::filesystem::path;\n+\n+void\n+test01()\n+{\n+  path p;\n+  VERIFY(  p.empty() );\n+  VERIFY( !p.has_root_path() );\n+  VERIFY( !p.has_root_name() );\n+  VERIFY( !p.has_root_directory() );\n+  VERIFY( !p.has_relative_path() );\n+  VERIFY( !p.has_parent_path() );\n+  VERIFY( !p.has_filename() );\n+  VERIFY( !p.has_stem() );\n+  VERIFY( !p.has_extension() );\n+  VERIFY( !p.is_absolute() );\n+  VERIFY(  p.is_relative() );\n+  VERIFY( std::distance(p.begin(), p.end()) == 0 );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "4c8c184159988ef8d6eab62e9f6147227cdd1006", "filename": "libstdc++-v3/testsuite/experimental/filesystem/path/construct/locale.cc", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fconstruct%2Flocale.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fconstruct%2Flocale.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fconstruct%2Flocale.cc?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -0,0 +1,39 @@\n+// { dg-options \"-std=gnu++11 -lstdc++fs\" }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.1 path constructors [path.construct]\n+\n+#include <experimental/filesystem>\n+#include <testsuite_hooks.h>\n+\n+using std::experimental::filesystem::path;\n+\n+void\n+test01()\n+{\n+  path p(\"/foo/bar\", std::locale::classic());\n+  VERIFY( p.string() == \"/foo/bar\" );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "03e50854772c46de99e45916e0df6b451bd5d5b3", "filename": "libstdc++-v3/testsuite/experimental/filesystem/path/construct/range.cc", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fconstruct%2Frange.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fconstruct%2Frange.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fconstruct%2Frange.cc?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -0,0 +1,60 @@\n+// { dg-options \"-std=gnu++11 -lstdc++fs\" }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.1 path constructors [path.construct]\n+\n+#include <experimental/filesystem>\n+#include <string>\n+#include <testsuite_fs.h>\n+\n+using std::experimental::filesystem::path;\n+using __gnu_test::compare_paths;\n+\n+void\n+test01()\n+{\n+  for (std::string s : __gnu_test::test_paths)\n+  {\n+    path p1 = s;\n+    path p2( s.begin(), s.end() );\n+    path p3( s.c_str() );\n+    path p4( s.c_str(), s.c_str() + s.size() );\n+\n+    std::wstring ws(s.begin(), s.end());\n+    path p5 = ws;\n+    path p6( ws.begin(), ws.end() );\n+    path p7( ws.c_str() );\n+    path p8( ws.c_str(), ws.c_str() + ws.size() );\n+\n+    compare_paths(p1, p2);\n+    compare_paths(p1, p3);\n+    compare_paths(p1, p4);\n+    compare_paths(p1, p5);\n+    compare_paths(p1, p6);\n+    compare_paths(p1, p7);\n+    compare_paths(p1, p8);\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "96f5bf5344eaa22049d968267e523dc1947696b4", "filename": "libstdc++-v3/testsuite/experimental/filesystem/path/decompose/extension.cc", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fdecompose%2Fextension.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fdecompose%2Fextension.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fdecompose%2Fextension.cc?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -0,0 +1,61 @@\n+// { dg-options \"-std=gnu++11 -lstdc++fs\" }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.9 path decomposition [path.decompose]\n+\n+#include <experimental/filesystem>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+using std::experimental::filesystem::path;\n+\n+void\n+test01()\n+{\n+  VERIFY( path(\"/foo/bar.txt\").extension() == path(\".txt\") );\n+  VERIFY( path(\"/foo/bar.baz.txt\").extension() == path(\".txt\") );\n+  VERIFY( path(\".bar.baz.txt\").extension() == path(\".txt\") );\n+\n+  VERIFY( path(\".hidden\").extension() == path(\".hidden\") );\n+\n+  VERIFY( path().extension() == path() );\n+  VERIFY( path(\".\").extension() == path() );\n+  VERIFY( path(\"..\").extension() == path() );\n+}\n+\n+void\n+test02()\n+{\n+  for (const path& p : __gnu_test::test_paths)\n+  {\n+    auto stem = p.stem();\n+    auto ext = p.extension();\n+    auto file = p.filename();\n+    VERIFY( stem.native() + ext.native() == file.native() );\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "dc3f07ff693ba14e39549c02a5a2f8ad4c46e881", "filename": "libstdc++-v3/testsuite/experimental/filesystem/path/decompose/filename.cc", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fdecompose%2Ffilename.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fdecompose%2Ffilename.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fdecompose%2Ffilename.cc?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -0,0 +1,58 @@\n+// { dg-options \"-std=gnu++11 -lstdc++fs\" }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.9 path decomposition [path.decompose]\n+\n+#include <experimental/filesystem>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+using std::experimental::filesystem::path;\n+\n+void\n+test01()\n+{\n+  VERIFY( path(\"/foo/bar.txt\").filename() == \"bar.txt\"  );\n+  VERIFY( path(\"/\").filename()            == \"/\"        );\n+  VERIFY( path(\".\").filename()            == \".\"        );\n+  VERIFY( path(\"..\").filename()           == \"..\"       );\n+}\n+\n+void\n+test02()\n+{\n+  for (const path& p : __gnu_test::test_paths)\n+  {\n+    path f = p.filename();\n+    if (p.empty())\n+      VERIFY( f.empty() );\n+    else\n+      VERIFY( f == *--p.end() );\n+    if (p != p.root_path())\n+      VERIFY( !f.has_root_path() );\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "2c21f6ff6993c938996465d4170a6b64238c7013", "filename": "libstdc++-v3/testsuite/experimental/filesystem/path/decompose/parent_path.cc", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fdecompose%2Fparent_path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fdecompose%2Fparent_path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fdecompose%2Fparent_path.cc?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -0,0 +1,61 @@\n+// { dg-options \"-std=gnu++11 -lstdc++fs\" }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.9 path decomposition [path.decompose]\n+\n+#include <experimental/filesystem>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+using std::experimental::filesystem::path;\n+\n+void\n+test01()\n+{\n+  path p0;\n+  VERIFY( p0.parent_path() == p0 );\n+  path p1 = \"foo\";\n+  VERIFY( p1.parent_path() == p0 );\n+  path p2 = \"foo/bar\";\n+  VERIFY( p2.parent_path() == p1 );\n+  path p3 = \"/foo/bar\";\n+  VERIFY( p3.parent_path() == path(\"/foo\") );\n+}\n+\n+void\n+test02()\n+{\n+  for (const path& p : __gnu_test::test_paths)\n+  {\n+    path pp;\n+    for (auto i = p.begin(), end = --p.end(); i != end; ++i)\n+    {\n+      pp /= *i;\n+    }\n+    VERIFY( p.parent_path() == pp );\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "16e8f864ad8dda4a38ae19871dd2d74004d2f970", "filename": "libstdc++-v3/testsuite/experimental/filesystem/path/decompose/relative_path.cc", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fdecompose%2Frelative_path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fdecompose%2Frelative_path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fdecompose%2Frelative_path.cc?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -0,0 +1,65 @@\n+// { dg-options \"-std=gnu++11 -lstdc++fs\" }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.9 path decomposition [path.decompose]\n+\n+#include <experimental/filesystem>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+using std::experimental::filesystem::path;\n+\n+void\n+test01()\n+{\n+  path p1 = \"foo\";\n+  VERIFY( p1.relative_path() == p1 );\n+  path p2 = \"foo/bar\";\n+  VERIFY( p2.relative_path() == p2 );\n+  path p3 = \"/foo/bar\";\n+  VERIFY( p3.relative_path() == p2 );\n+}\n+\n+void\n+test02()\n+{\n+  for (const path& p : __gnu_test::test_paths)\n+  {\n+    bool after_root = false;\n+    const path prel = p.relative_path();\n+    VERIFY( !prel.has_root_name() );\n+    path rel;\n+    for (const auto& cmpt : p)\n+    {\n+      if (!cmpt.has_root_path())\n+        after_root = true;\n+      if (after_root)\n+        rel /= cmpt;\n+    }\n+    VERIFY( prel == rel );\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "4f372d6ddb367d5571f40a525e7434b5ce482f8d", "filename": "libstdc++-v3/testsuite/experimental/filesystem/path/decompose/root_directory.cc", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fdecompose%2Froot_directory.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fdecompose%2Froot_directory.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fdecompose%2Froot_directory.cc?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -0,0 +1,60 @@\n+// { dg-options \"-std=gnu++11 -lstdc++fs\" }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.9 path decomposition [path.decompose]\n+\n+#include <experimental/filesystem>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+using std::experimental::filesystem::path;\n+\n+void\n+test01()\n+{\n+  path p1 = \"foo/bar\";\n+  VERIFY( p1.root_directory() == path() );\n+  path p2 = \"/foo/bar\";\n+  VERIFY( p2.root_directory() == path(\"/\") );\n+  path p3 = \"//foo\";\n+  VERIFY( p3.root_directory() == path() );\n+  path p4 = \"///foo\";\n+  VERIFY( p4.root_directory() == path(\"/\") );\n+}\n+\n+void\n+test02()\n+{\n+  for (const path& p : __gnu_test::test_paths)\n+  {\n+    path rootdir = p.root_directory();\n+    // If root-directory is composed of 'slash name',\n+    // 'slash' is excluded from the returned string.\n+    if (!rootdir.empty() && rootdir.native() != \"/\")\n+      VERIFY( rootdir.native()[0] != '/' );\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "01886738be4a74ead22386dc71163f7473fe8bec", "filename": "libstdc++-v3/testsuite/experimental/filesystem/path/decompose/root_name.cc", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fdecompose%2Froot_name.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fdecompose%2Froot_name.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fdecompose%2Froot_name.cc?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -0,0 +1,42 @@\n+// { dg-options \"-std=gnu++11 -lstdc++fs\" }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.9 path decomposition [path.decompose]\n+\n+#include <experimental/filesystem>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+using std::experimental::filesystem::path;\n+\n+void\n+test01()\n+{\n+  VERIFY( path(\"/foo/bar.txt\").extension() == \".txt\" );\n+  VERIFY( path(\"/foo/bar.baz.txt\").extension() == \".txt\" );\n+  VERIFY( path(\".\").extension().empty() );\n+  VERIFY( path(\"..\").extension().empty() );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "feb4e7995ddcf7cf9b9642eb4ad5d1fbf1cf544e", "filename": "libstdc++-v3/testsuite/experimental/filesystem/path/decompose/root_path.cc", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fdecompose%2Froot_path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fdecompose%2Froot_path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fdecompose%2Froot_path.cc?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -0,0 +1,55 @@\n+// { dg-options \"-std=gnu++11 -lstdc++fs\" }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.9 path decomposition [path.decompose]\n+\n+#include <experimental/filesystem>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+using std::experimental::filesystem::path;\n+\n+void\n+test01()\n+{\n+  path p1 = \"foo/bar\";\n+  VERIFY( p1.root_path() == path() );\n+  path p2 = \"/foo/bar\";\n+  VERIFY( p2.root_path() == path(\"/\") );\n+}\n+\n+void\n+test02()\n+{\n+  for (const path& p : __gnu_test::test_paths)\n+  {\n+    path rootp = p.root_path();\n+    path rootn = p.root_name();\n+    path rootd = p.root_directory();\n+    VERIFY( rootp == (rootn / rootd) );\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "d3611b88776d2ef9ca1ad232c463eb191f9e350e", "filename": "libstdc++-v3/testsuite/experimental/filesystem/path/decompose/stem.cc", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fdecompose%2Fstem.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fdecompose%2Fstem.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fdecompose%2Fstem.cc?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -0,0 +1,53 @@\n+// { dg-options \"-std=gnu++11 -lstdc++fs\" }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.9 path decomposition [path.decompose]\n+\n+#include <experimental/filesystem>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+using std::experimental::filesystem::path;\n+\n+void\n+test01()\n+{\n+  VERIFY( path(\"/foo/bar.txt\").stem() == path(\"bar\") );\n+  path p = \"foo.bar.baz.tar\";\n+  std::vector<std::string> v;\n+  for (; !p.extension().empty(); p = p.stem())\n+    v.push_back(p.extension().native());\n+  VERIFY( v.at(0) == \".tar\" );\n+  VERIFY( v.at(1) == \".baz\" );\n+  VERIFY( v.at(2) == \".bar\" );\n+\n+  VERIFY( path(\".hidden\").stem() == path() );\n+\n+  VERIFY( path().stem() == path() );\n+  VERIFY( path(\".\").stem() == path(\".\") );\n+  VERIFY( path(\"..\").stem() == path(\"..\") );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "1e302f2bf72e2b678830c0406d33732f2890b34e", "filename": "libstdc++-v3/testsuite/experimental/filesystem/path/generic/generic_string.cc", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fgeneric%2Fgeneric_string.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fgeneric%2Fgeneric_string.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fgeneric%2Fgeneric_string.cc?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -0,0 +1,48 @@\n+// { dg-options \"-std=gnu++11 -lstdc++fs\" }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.7 path generic format observers [path.generic.obs]\n+\n+#include <experimental/filesystem>\n+#include <testsuite_fs.h>\n+#include <testsuite_hooks.h>\n+\n+using std::experimental::filesystem::path;\n+\n+void\n+test01()\n+{\n+  for (const path& p : __gnu_test::test_paths)\n+  {\n+    path p2(p), p3;\n+    p2.swap(p3);\n+    VERIFY( p2 == path() );\n+    VERIFY( p3 == p );\n+    p2.swap(p3);\n+    VERIFY( p2 == p );\n+    VERIFY( p3 == path() );\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "0e543349d98e158a9d902e5f8cf8c075be08a3d1", "filename": "libstdc++-v3/testsuite/experimental/filesystem/path/itr/traversal.cc", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fitr%2Ftraversal.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fitr%2Ftraversal.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fitr%2Ftraversal.cc?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -0,0 +1,86 @@\n+// { dg-options \"-std=gnu++11 -lstdc++fs\" }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.5 path iterators [path.itr]\n+\n+#include <experimental/filesystem>\n+#include <vector>\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+using std::experimental::filesystem::path;\n+\n+void\n+test01()\n+{\n+  path p;\n+  VERIFY( p.begin() == p.end() );\n+\n+  std::vector<path> v, v2;\n+\n+  p = \"/\";\n+  v.assign(p.begin(), p.end());\n+  v2 = { \"/\" };\n+  VERIFY( v == v2 );\n+\n+  p = \"filename\";\n+  v.assign(p.begin(), p.end());\n+  v2 = { \"filename\" };\n+  VERIFY( v == v2 );\n+\n+  p = \"dir/\";\n+  v.assign(p.begin(), p.end());\n+  v2 = { \"dir\", \".\" };\n+  VERIFY( v == v2 );\n+\n+  p = \"//rootname/dir/\";\n+  v.assign(p.begin(), p.end());\n+  v2 = { \"//rootname\", \"/\", \"dir\", \".\" };\n+  VERIFY( v == v2 );\n+\n+  p = \"//rootname/dir/filename\";\n+  v.assign(p.begin(), p.end());\n+  v2 = { \"//rootname\", \"/\", \"dir\", \"filename\" };\n+  VERIFY( v == v2 );\n+}\n+\n+void\n+test02()\n+{\n+  using reverse_iterator = std::reverse_iterator<path::iterator>;\n+  std::vector<path> fwd, rev;\n+\n+  for (const path& p : __gnu_test::test_paths)\n+  {\n+    const auto begin = p.begin(), end = p.end();\n+    fwd.assign(begin, end);\n+    rev.assign(reverse_iterator(end), reverse_iterator(begin));\n+    VERIFY( fwd.size() == rev.size() );\n+    VERIFY( std::equal(fwd.begin(), fwd.end(), rev.rbegin()) );\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "e28f900315a502812adbb5e3991db71002747018", "filename": "libstdc++-v3/testsuite/experimental/filesystem/path/modifiers/clear.cc", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fmodifiers%2Fclear.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fmodifiers%2Fclear.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fmodifiers%2Fclear.cc?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -0,0 +1,45 @@\n+// { dg-options \"-std=gnu++11 -lstdc++fs\" }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.5 path modifiers [path.modifiers]\n+\n+#include <experimental/filesystem>\n+#include <testsuite_fs.h>\n+#include <testsuite_hooks.h>\n+\n+using std::experimental::filesystem::path;\n+\n+void\n+test01()\n+{\n+  for (path p : __gnu_test::test_paths)\n+  {\n+    path empty;\n+    p.clear();\n+    VERIFY( p.empty() );\n+    __gnu_test::compare_paths(p, empty);\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "f38ecf6fc05e905de49e5438426067164ba1ed92", "filename": "libstdc++-v3/testsuite/experimental/filesystem/path/modifiers/make_preferred.cc", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fmodifiers%2Fmake_preferred.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fmodifiers%2Fmake_preferred.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fmodifiers%2Fmake_preferred.cc?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -0,0 +1,63 @@\n+// { dg-options \"-std=gnu++11 -lstdc++fs\" }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.5 path modifiers [path.modifiers]\n+\n+#include <experimental/filesystem>\n+#include <testsuite_fs.h>\n+#include <testsuite_hooks.h>\n+\n+using std::experimental::filesystem::path;\n+\n+template<typename T, T sep>\n+struct checker\n+{\n+  static void check(const char* s) { }\n+};\n+\n+template<>\n+struct checker<char, '/'>\n+{\n+  static void check()\n+  {\n+    VERIFY( path(\"foo/bar\").make_preferred() == \"foo/bar\" );\n+  }\n+};\n+\n+template<>\n+struct checker<wchar_t, L'\\\\'>\n+{\n+  static void check()\n+  {\n+    VERIFY( path(\"foo/bar\").make_preferred() == L\"foo\\\\bar\" );\n+  }\n+};\n+\n+void\n+test01()\n+{\n+  checker<path::value_type, path::preferred_separator>::check();\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "4612e4490d6252800cc2ba75d433629790c4b4a7", "filename": "libstdc++-v3/testsuite/experimental/filesystem/path/modifiers/remove_filename.cc", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fmodifiers%2Fremove_filename.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fmodifiers%2Fremove_filename.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fmodifiers%2Fremove_filename.cc?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -0,0 +1,53 @@\n+// { dg-options \"-std=gnu++11 -lstdc++fs\" }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.5 path modifiers [path.modifiers]\n+\n+#include <experimental/filesystem>\n+#include <testsuite_fs.h>\n+#include <testsuite_hooks.h>\n+\n+using std::experimental::filesystem::path;\n+\n+void\n+test01()\n+{\n+  VERIFY( path(\"/foo\").remove_filename() == \"/\" );\n+  VERIFY( path(\"/\").remove_filename() == \"\" );\n+}\n+\n+void\n+test02()\n+{\n+  for (const path& p : __gnu_test::test_paths)\n+  {\n+    path p2(p);\n+    p2.remove_filename();\n+    p2 /= p.filename();\n+    VERIFY( p2 == p );\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "163016b09a1aa925388ddde57576ca0a3b5d87fc", "filename": "libstdc++-v3/testsuite/experimental/filesystem/path/modifiers/replace_extension.cc", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fmodifiers%2Freplace_extension.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fmodifiers%2Freplace_extension.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fmodifiers%2Freplace_extension.cc?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -0,0 +1,52 @@\n+// { dg-options \"-std=gnu++11 -lstdc++fs\" }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.5 path modifiers [path.modifiers]\n+\n+#include <experimental/filesystem>\n+#include <testsuite_fs.h>\n+#include <testsuite_hooks.h>\n+\n+using std::experimental::filesystem::path;\n+\n+void\n+test01()\n+{\n+  VERIFY( path(\"/foo.txt\").replace_extension(\"cpp\") == \"/foo.cpp\" );\n+  VERIFY( path(\"/foo.txt\").replace_extension(\".cpp\") == \"/foo.cpp\" );\n+  VERIFY( path(\"/\").replace_extension(\"bar\") == \"/.bar\" );\n+}\n+\n+void\n+test02()\n+{\n+  for (const path& p : __gnu_test::test_paths)\n+  {\n+    path p2 = p;\n+    VERIFY(p2.replace_extension(p2.extension()) == p);\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "c9706008a07ec2db3e81892c67de7a02bd72ac18", "filename": "libstdc++-v3/testsuite/experimental/filesystem/path/modifiers/replace_filename.cc", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fmodifiers%2Freplace_filename.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fmodifiers%2Freplace_filename.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fmodifiers%2Freplace_filename.cc?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -0,0 +1,52 @@\n+// { dg-options \"-std=gnu++11 -lstdc++fs\" }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.5 path modifiers [path.modifiers]\n+\n+#include <experimental/filesystem>\n+#include <testsuite_fs.h>\n+#include <testsuite_hooks.h>\n+\n+using std::experimental::filesystem::path;\n+\n+void\n+test01()\n+{\n+  VERIFY( path(\"/foo\").replace_filename(\"bar\") == \"/bar\" );\n+  VERIFY( path(\"/\").replace_filename(\"bar\") == \"bar\" );\n+}\n+\n+void\n+test02()\n+{\n+  for (const path& p : __gnu_test::test_paths)\n+  {\n+    path p2(p);\n+    p2.replace_filename(p.filename());\n+    VERIFY( p2 == p );\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "df990e05f415fa461174dd4121fe1c7a1b3a8a22", "filename": "libstdc++-v3/testsuite/experimental/filesystem/path/modifiers/swap.cc", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fmodifiers%2Fswap.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fmodifiers%2Fswap.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fmodifiers%2Fswap.cc?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -0,0 +1,44 @@\n+// { dg-options \"-std=gnu++11 -lstdc++fs\" }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.5 path modifiers [path.modifiers]\n+\n+#include <experimental/filesystem>\n+#include <testsuite_fs.h>\n+#include <testsuite_hooks.h>\n+\n+using std::experimental::filesystem::path;\n+\n+void\n+test01()\n+{\n+  const path p(\"/foo/bar\");\n+  path p1;\n+  path p2 = p;\n+  p1.swap(p2);\n+  VERIFY( p2.empty() );\n+  __gnu_test::compare_paths(p1, p);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "3971237a65727dbc34d229f13ca9360373314f32", "filename": "libstdc++-v3/testsuite/experimental/filesystem/path/nonmember/hash_value.cc", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fnonmember%2Fhash_value.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fnonmember%2Fhash_value.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fnonmember%2Fhash_value.cc?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -0,0 +1,51 @@\n+// { dg-options \"-std=gnu++11 -lstdc++fs\" }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.6 path non-member functions [path.non-member]\n+\n+#include <experimental/filesystem>\n+#include <testsuite_fs.h>\n+#include <testsuite_hooks.h>\n+\n+using std::experimental::filesystem::path;\n+\n+void\n+test01()\n+{\n+  VERIFY( hash_value(path(\"a//b\")) == hash_value(path(\"a/b\")) );\n+  VERIFY( hash_value(path(\"a/\")) == hash_value(path(\"a/.\")) );\n+}\n+\n+void\n+test02()\n+{\n+  for (const path& p : __gnu_test::test_paths)\n+  {\n+    path pp = p.native();\n+    VERIFY( hash_value(p) == hash_value(pp) );\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "b636f0726190a316596597e0955982b7c6f7c319", "filename": "libstdc++-v3/testsuite/experimental/filesystem/path/query/empty.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fquery%2Fempty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fquery%2Fempty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fquery%2Fempty.cc?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -0,0 +1,43 @@\n+// { dg-options \"-std=gnu++11 -lstdc++fs\" }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.9 path decomposition [path.decompose]\n+\n+#include <experimental/filesystem>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+using std::experimental::filesystem::path;\n+\n+void\n+test01()\n+{\n+  for (const std::string& s : __gnu_test::test_paths)\n+  {\n+    VERIFY( s.empty() == path(s).empty() );\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "1edee38112f298d6c33e95bc2a563fd84361b227", "filename": "libstdc++-v3/testsuite/experimental/filesystem/path/query/has_extension.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fquery%2Fhas_extension.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fquery%2Fhas_extension.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fquery%2Fhas_extension.cc?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -0,0 +1,43 @@\n+// { dg-options \"-std=gnu++11 -lstdc++fs\" }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.9 path decomposition [path.decompose]\n+\n+#include <experimental/filesystem>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+using std::experimental::filesystem::path;\n+\n+void\n+test01()\n+{\n+  for (const path& p : __gnu_test::test_paths)\n+  {\n+    VERIFY( p.has_extension() == !p.extension().empty() );\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "308f78762ab636e97e7356acf808a3e6962e7972", "filename": "libstdc++-v3/testsuite/experimental/filesystem/path/query/has_filename.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fquery%2Fhas_filename.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fquery%2Fhas_filename.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fquery%2Fhas_filename.cc?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -0,0 +1,43 @@\n+// { dg-options \"-std=gnu++11 -lstdc++fs\" }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.9 path decomposition [path.decompose]\n+\n+#include <experimental/filesystem>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+using std::experimental::filesystem::path;\n+\n+void\n+test01()\n+{\n+  for (const path& p : __gnu_test::test_paths)\n+  {\n+    VERIFY( p.has_filename() == !p.filename().empty() );\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "5068ebb04b9c5e656d17f34055fdc1dfd17a2c24", "filename": "libstdc++-v3/testsuite/experimental/filesystem/path/query/has_parent_path.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fquery%2Fhas_parent_path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fquery%2Fhas_parent_path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fquery%2Fhas_parent_path.cc?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -0,0 +1,43 @@\n+// { dg-options \"-std=gnu++11 -lstdc++fs\" }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.9 path decomposition [path.decompose]\n+\n+#include <experimental/filesystem>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+using std::experimental::filesystem::path;\n+\n+void\n+test01()\n+{\n+  for (const path& p : __gnu_test::test_paths)\n+  {\n+    VERIFY( p.has_parent_path() == !p.parent_path().empty() );\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "13ab666ae4ac2d18ea7af3d4ed8fc74bbe148d93", "filename": "libstdc++-v3/testsuite/experimental/filesystem/path/query/has_relative_path.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fquery%2Fhas_relative_path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fquery%2Fhas_relative_path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fquery%2Fhas_relative_path.cc?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -0,0 +1,43 @@\n+// { dg-options \"-std=gnu++11 -lstdc++fs\" }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.9 path decomposition [path.decompose]\n+\n+#include <experimental/filesystem>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+using std::experimental::filesystem::path;\n+\n+void\n+test01()\n+{\n+  for (const path& p : __gnu_test::test_paths)\n+  {\n+    VERIFY( p.has_relative_path() == !p.relative_path().empty() );\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "16df83c0ab16e7552ab96409fec0b4ce7182de47", "filename": "libstdc++-v3/testsuite/experimental/filesystem/path/query/has_root_directory.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fquery%2Fhas_root_directory.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fquery%2Fhas_root_directory.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fquery%2Fhas_root_directory.cc?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -0,0 +1,43 @@\n+// { dg-options \"-std=gnu++11 -lstdc++fs\" }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.9 path decomposition [path.decompose]\n+\n+#include <experimental/filesystem>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+using std::experimental::filesystem::path;\n+\n+void\n+test01()\n+{\n+  for (const path& p : __gnu_test::test_paths)\n+  {\n+    VERIFY( p.has_root_directory() == !p.root_directory().empty() );\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "e8f2de70693a357cc86ba3eb533aa34f7c8baffa", "filename": "libstdc++-v3/testsuite/experimental/filesystem/path/query/has_root_name.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fquery%2Fhas_root_name.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fquery%2Fhas_root_name.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fquery%2Fhas_root_name.cc?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -0,0 +1,43 @@\n+// { dg-options \"-std=gnu++11 -lstdc++fs\" }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.9 path decomposition [path.decompose]\n+\n+#include <experimental/filesystem>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+using std::experimental::filesystem::path;\n+\n+void\n+test01()\n+{\n+  for (const path& p : __gnu_test::test_paths)\n+  {\n+    VERIFY( p.has_root_name() == !p.root_name().empty() );\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "fed615fb5790afd4ebda3ecb4ec4c764c2381212", "filename": "libstdc++-v3/testsuite/experimental/filesystem/path/query/has_root_path.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fquery%2Fhas_root_path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fquery%2Fhas_root_path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fquery%2Fhas_root_path.cc?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -0,0 +1,43 @@\n+// { dg-options \"-std=gnu++11 -lstdc++fs\" }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.9 path decomposition [path.decompose]\n+\n+#include <experimental/filesystem>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+using std::experimental::filesystem::path;\n+\n+void\n+test01()\n+{\n+  for (const path& p : __gnu_test::test_paths)\n+  {\n+    VERIFY( p.has_root_path() == !p.root_path().empty() );\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "eab381a227b0d6092d8811f77842bb4c53e2d926", "filename": "libstdc++-v3/testsuite/experimental/filesystem/path/query/has_stem.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fquery%2Fhas_stem.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fquery%2Fhas_stem.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fquery%2Fhas_stem.cc?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -0,0 +1,43 @@\n+// { dg-options \"-std=gnu++11 -lstdc++fs\" }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.9 path decomposition [path.decompose]\n+\n+#include <experimental/filesystem>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+using std::experimental::filesystem::path;\n+\n+void\n+test01()\n+{\n+  for (const path& p : __gnu_test::test_paths)\n+  {\n+    VERIFY( p.has_stem() == !p.stem().empty() );\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "4512f6e747f02fd5e7a0d9247ed2f4d5700824ca", "filename": "libstdc++-v3/testsuite/experimental/filesystem/path/query/is_relative.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fquery%2Fis_relative.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fquery%2Fis_relative.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fquery%2Fis_relative.cc?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -0,0 +1,43 @@\n+// { dg-options \"-std=gnu++11 -lstdc++fs\" }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.9 path decomposition [path.decompose]\n+\n+#include <experimental/filesystem>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+using std::experimental::filesystem::path;\n+\n+void\n+test01()\n+{\n+  for (const path& p : __gnu_test::test_paths)\n+  {\n+    VERIFY( p.is_relative() == !p.is_absolute() );\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "b5fb3e3877fb25b18a302bbafd8e57d21bb170a7", "filename": "libstdc++-v3/testsuite/lib/dg-options.exp", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Flib%2Fdg-options.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Flib%2Fdg-options.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Flib%2Fdg-options.exp?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -223,6 +223,15 @@ proc dg-require-little-endian { args } {\n     return\n }\n \n+proc dg-require-filesystem-ts { args } {\n+    if { ![ check_v3_target_filesystem_ts ] } {\n+\tupvar dg-do-what dg-do-what\n+\tset dg-do-what [list [lindex ${dg-do-what} 0] \"N\" \"P\"]\n+\treturn\n+    }\n+    return\n+}\n+\n proc add_options_for_no_pch { flags } {\n     # This forces any generated and possibly included PCH to be invalid.\n     return \"-D__GLIBCXX__=99999999\""}, {"sha": "7ae4f3fc054b942335a9474052951d8567bd21c0", "filename": "libstdc++-v3/testsuite/lib/libstdc++.exp", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Flib%2Flibstdc%2B%2B.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Flib%2Flibstdc%2B%2B.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Flib%2Flibstdc%2B%2B.exp?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -1895,6 +1895,53 @@ proc check_v3_target_little_endian { } {\n     return $et_little_endian\n }\n \n+proc check_v3_target_filesystem_ts { } {\n+    global et_filesystem_ts\n+    global tool\n+\n+    if { ![info exists et_filesystem_ts_target_name] } {\n+\tset et_filesystem_ts_target_name \"\"\n+    }\n+\n+    # If the target has changed since we set the cached value, clear it.\n+    set current_target [current_target_name]\n+    if { $current_target != $et_filesystem_ts_target_name } {\n+\tverbose \"check_v3_target_filesystem_ts: `$et_filesystem_ts_target_name'\" 2\n+\tset et_filesystem_ts_target_name $current_target\n+\tif [info exists et_filesystem_ts] {\n+\t    verbose \"check_v3_target_filesystem_ts: removing cached result\" 2\n+\t    unset et_filesystem_ts\n+\t}\n+    }\n+\n+    if [info exists et_filesystem_ts] {\n+\tverbose \"check_v3_target_filesystem_ts: using cached result\" 2\n+    } else {\n+\tset et_filesystem_ts 0\n+\n+\t# Set up and preprocess a C++ test program that depends\n+\t# on debug mode activated.\n+\tset src filesystem_ts[pid].cc\n+\n+\tset f [open $src \"w\"]\n+\tputs $f \"#include <experimental/filesystem>\"\n+\tputs $f \"#if ! __cpp_lib_experimental_filesystem\"\n+\tputs $f \"#  error No Filesystem TS support\"\n+\tputs $f \"#endif\"\n+\tclose $f\n+\n+\tset lines [v3_target_compile $src /dev/null preprocess \"\"]\n+\tfile delete $src\n+\n+\tif [string match \"\" $lines] {\n+\t    # No error message, preprocessing succeeded.\n+\t    set et_filesystem_ts 1\n+\t}\n+    }\n+    verbose \"check_v3_target_filesystem_ts: $et_filesystem_ts\" 2\n+    return $et_filesystem_ts\n+}\n+\n set additional_prunes \"\"\n \n if { [info exists env(GCC_RUNTEST_PARALLELIZE_DIR)] \\"}, {"sha": "0fb3a459d93ebf06ef56d4e4ed19a0302862720c", "filename": "libstdc++-v3/testsuite/util/testsuite_fs.h", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_fs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_fs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_fs.h?ref=0ca7ba9aa6a0b5b2c71184cd1853446cec9a0889", "patch": "@@ -0,0 +1,67 @@\n+// -*- C++ -*-\n+// Filesystem utils for the C++ library testsuite.\n+//\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+//\n+\n+#ifndef _TESTSUITE_FS_H\n+#define _TESTSUITE_FS_H 1\n+\n+#include <experimental/filesystem>\n+#include <iostream>\n+#include <string>\n+\n+namespace __gnu_test\n+{\n+#define PATH_CHK(p1, p2, fn) \\\n+    if ( p1.fn() != p2.fn() ) \\\n+      throw std::experimental::filesystem::filesystem_error( #fn, p1, p2, \\\n+\t  std::make_error_code(std::errc::invalid_argument) )\n+\n+  void\n+  compare_paths(const std::experimental::filesystem::path& p1,\n+\t\tconst std::experimental::filesystem::path& p2)\n+  {\n+    // std::cout << \"Comparing \" << p1 << \" and \" << p2 << std::endl;\n+    PATH_CHK( p1, p2, string );\n+    PATH_CHK( p1, p2, empty );\n+    PATH_CHK( p1, p2, has_root_path );\n+    PATH_CHK( p1, p2, has_root_name );\n+    PATH_CHK( p1, p2, has_root_directory );\n+    PATH_CHK( p1, p2, has_relative_path );\n+    PATH_CHK( p1, p2, has_parent_path );\n+    PATH_CHK( p1, p2, has_filename );\n+    PATH_CHK( p1, p2, has_stem );\n+    PATH_CHK( p1, p2, has_extension );\n+    PATH_CHK( p1, p2, is_absolute );\n+    PATH_CHK( p1, p2, is_relative );\n+    auto d1 = std::distance(p1.begin(), p1.end());\n+    auto d2 = std::distance(p2.begin(), p2.end());\n+    if( d1 != d2 )\n+      throw std::experimental::filesystem::filesystem_error(\n+\t  \"distance(begin, end)\", p1, p2,\n+\t  std::make_error_code(std::errc::invalid_argument) );\n+  }\n+\n+  const std::string test_paths[] = {\n+    \"\", \"/\", \"//\", \"/.\", \"/./\", \"/a\", \"/a/\", \"/a//\", \"/a/b/c/d\", \"/a//b\",\n+    \"a\", \"a/b\", \"a/b/\", \"a/b/c\", \"a/b/c.d\", \"a/b/..\", \"a/b/c.\", \"a/b/.c\"\n+  };\n+\n+} // namespace __gnu_test\n+#endif"}]}