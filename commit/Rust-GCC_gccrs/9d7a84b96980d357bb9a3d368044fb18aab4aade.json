{"sha": "9d7a84b96980d357bb9a3d368044fb18aab4aade", "node_id": "C_kwDOANBUbNoAKDlkN2E4NGI5Njk4MGQzNTdiYjlhM2QzNjgwNDRmYjE4YWFiNGFhZGU", "commit": {"author": {"name": "Ard Biesheuvel", "email": "ardb@kernel.org", "date": "2022-01-21T12:09:34Z"}, "committer": {"name": "Kyrylo Tkachov", "email": "kyrylo.tkachov@arm.com", "date": "2022-01-21T12:12:26Z"}, "message": "[ARM] Add support for TLS register based stack protector canary access\n\nAdd support for accessing the stack canary value via the TLS register,\nso that multiple threads running in the same address space can use\ndistinct canary values. This is intended for the Linux kernel running in\nSMP mode, where processes entering the kernel are essentially threads\nrunning the same program concurrently: using a global variable for the\ncanary in that context is problematic because it can never be rotated,\nand so the OS is forced to use the same value as long as it remains up.\n\nUsing the TLS register to index the stack canary helps with this, as it\nallows each CPU to context switch the TLS register along with the rest\nof the process, permitting each process to use its own value for the\nstack canary.\n\ngcc/ChangeLog:\n\n\t* config/arm/arm-opts.h (enum stack_protector_guard): New.\n\t* config/arm/arm-protos.h (arm_stack_protect_tls_canary_mem):\n\tNew.\n\t* config/arm/arm.cc (TARGET_STACK_PROTECT_GUARD): Define.\n\t(arm_option_override_internal): Handle and put in error checks.\n\tfor stack protector guard options.\n\t(arm_option_reconfigure_globals): Likewise.\n\t(arm_stack_protect_tls_canary_mem): New.\n\t(arm_stack_protect_guard): New.\n\t* config/arm/arm.md (stack_protect_set): New.\n\t(stack_protect_set_tls): Likewise.\n\t(stack_protect_test): Likewise.\n\t(stack_protect_test_tls): Likewise.\n\t(reload_tp_hard): Likewise.\n\t* config/arm/arm.opt (-mstack-protector-guard): New\n\t(-mstack-protector-guard-offset): New.\n\t* doc/invoke.texi: Document new options.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/arm/stack-protector-7.c: New test.\n\t* gcc.target/arm/stack-protector-8.c: New test.", "tree": {"sha": "b8c1f3c2b381240701de8ddd36da1615a2e8dcec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b8c1f3c2b381240701de8ddd36da1615a2e8dcec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9d7a84b96980d357bb9a3d368044fb18aab4aade", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d7a84b96980d357bb9a3d368044fb18aab4aade", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d7a84b96980d357bb9a3d368044fb18aab4aade", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d7a84b96980d357bb9a3d368044fb18aab4aade/comments", "author": {"login": "ardbiesheuvel", "id": 8448088, "node_id": "MDQ6VXNlcjg0NDgwODg=", "avatar_url": "https://avatars.githubusercontent.com/u/8448088?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ardbiesheuvel", "html_url": "https://github.com/ardbiesheuvel", "followers_url": "https://api.github.com/users/ardbiesheuvel/followers", "following_url": "https://api.github.com/users/ardbiesheuvel/following{/other_user}", "gists_url": "https://api.github.com/users/ardbiesheuvel/gists{/gist_id}", "starred_url": "https://api.github.com/users/ardbiesheuvel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ardbiesheuvel/subscriptions", "organizations_url": "https://api.github.com/users/ardbiesheuvel/orgs", "repos_url": "https://api.github.com/users/ardbiesheuvel/repos", "events_url": "https://api.github.com/users/ardbiesheuvel/events{/privacy}", "received_events_url": "https://api.github.com/users/ardbiesheuvel/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ktkachov-arm", "id": 74917949, "node_id": "MDQ6VXNlcjc0OTE3OTQ5", "avatar_url": "https://avatars.githubusercontent.com/u/74917949?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktkachov-arm", "html_url": "https://github.com/ktkachov-arm", "followers_url": "https://api.github.com/users/ktkachov-arm/followers", "following_url": "https://api.github.com/users/ktkachov-arm/following{/other_user}", "gists_url": "https://api.github.com/users/ktkachov-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktkachov-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktkachov-arm/subscriptions", "organizations_url": "https://api.github.com/users/ktkachov-arm/orgs", "repos_url": "https://api.github.com/users/ktkachov-arm/repos", "events_url": "https://api.github.com/users/ktkachov-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/ktkachov-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bab0f691d522469cb5052249646909f85ce74c29", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bab0f691d522469cb5052249646909f85ce74c29", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bab0f691d522469cb5052249646909f85ce74c29"}], "stats": {"total": 186, "additions": 184, "deletions": 2}, "files": [{"sha": "24d12fafdec8d6c8e112dd68bf83def23bb74fd2", "filename": "gcc/config/arm/arm-opts.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d7a84b96980d357bb9a3d368044fb18aab4aade/gcc%2Fconfig%2Farm%2Farm-opts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d7a84b96980d357bb9a3d368044fb18aab4aade/gcc%2Fconfig%2Farm%2Farm-opts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-opts.h?ref=9d7a84b96980d357bb9a3d368044fb18aab4aade", "patch": "@@ -69,4 +69,10 @@ enum arm_tls_type {\n   TLS_GNU,\n   TLS_GNU2\n };\n+\n+/* Where to get the canary for the stack protector.  */\n+enum stack_protector_guard {\n+  SSP_TLSREG,                  /* per-thread canary in TLS register */\n+  SSP_GLOBAL                   /* global canary */\n+};\n #endif"}, {"sha": "881c72c988bdbb55fffef044e9cc3f7c0a79590b", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d7a84b96980d357bb9a3d368044fb18aab4aade/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d7a84b96980d357bb9a3d368044fb18aab4aade/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=9d7a84b96980d357bb9a3d368044fb18aab4aade", "patch": "@@ -195,6 +195,8 @@ extern void arm_split_atomic_op (enum rtx_code, rtx, rtx, rtx, rtx, rtx, rtx);\n extern rtx arm_load_tp (rtx);\n extern bool arm_coproc_builtin_available (enum unspecv);\n extern bool arm_coproc_ldc_stc_legitimate_address (rtx);\n+extern rtx arm_stack_protect_tls_canary_mem (bool);\n+\n \n #if defined TREE_CODE\n extern void arm_init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx, tree);"}, {"sha": "663f4595050917969c687c79b6384eec09dc75d6", "filename": "gcc/config/arm/arm.cc", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d7a84b96980d357bb9a3d368044fb18aab4aade/gcc%2Fconfig%2Farm%2Farm.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d7a84b96980d357bb9a3d368044fb18aab4aade/gcc%2Fconfig%2Farm%2Farm.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.cc?ref=9d7a84b96980d357bb9a3d368044fb18aab4aade", "patch": "@@ -829,6 +829,9 @@ static const struct attribute_spec arm_attribute_table[] =\n \n #undef TARGET_MD_ASM_ADJUST\n #define TARGET_MD_ASM_ADJUST arm_md_asm_adjust\n+\n+#undef TARGET_STACK_PROTECT_GUARD\n+#define TARGET_STACK_PROTECT_GUARD arm_stack_protect_guard\n \f\n /* Obstack for minipool constant handling.  */\n static struct obstack minipool_obstack;\n@@ -3176,6 +3179,26 @@ arm_option_override_internal (struct gcc_options *opts,\n   if (TARGET_THUMB2_P (opts->x_target_flags))\n     opts->x_inline_asm_unified = true;\n \n+  if (arm_stack_protector_guard == SSP_GLOBAL\n+      && opts->x_arm_stack_protector_guard_offset_str)\n+    {\n+      error (\"incompatible options %'-mstack-protector-guard=global%' and\"\n+\t     \"%'-mstack-protector-guard-offset=%qs%'\",\n+\t     arm_stack_protector_guard_offset_str);\n+    }\n+\n+  if (opts->x_arm_stack_protector_guard_offset_str)\n+    {\n+      char *end;\n+      const char *str = arm_stack_protector_guard_offset_str;\n+      errno = 0;\n+      long offs = strtol (arm_stack_protector_guard_offset_str, &end, 0);\n+      if (!*str || *end || errno)\n+\terror (\"%qs is not a valid offset in %qs\", str,\n+\t       \"-mstack-protector-guard-offset=\");\n+      arm_stack_protector_guard_offset = offs;\n+    }\n+\n #ifdef SUBTARGET_OVERRIDE_INTERNAL_OPTIONS\n   SUBTARGET_OVERRIDE_INTERNAL_OPTIONS;\n #endif\n@@ -3852,6 +3875,9 @@ arm_option_reconfigure_globals (void)\n       else\n \ttarget_thread_pointer = TP_SOFT;\n     }\n+\n+  if (!TARGET_HARD_TP && arm_stack_protector_guard == SSP_TLSREG)\n+    error(\"%'-mstack-protector-guard=tls%' needs a hardware TLS register\");\n }\n \n /* Perform some validation between the desired architecture and the rest of the\n@@ -8117,6 +8143,23 @@ legitimize_pic_address (rtx orig, machine_mode mode, rtx reg, rtx pic_reg,\n }\n \n \n+/* Generate insns that produce the address of the stack canary */\n+rtx\n+arm_stack_protect_tls_canary_mem (bool reload)\n+{\n+  rtx tp = gen_reg_rtx (SImode);\n+  if (reload)\n+    emit_insn (gen_reload_tp_hard (tp));\n+  else\n+    emit_insn (gen_load_tp_hard (tp));\n+\n+  rtx reg = gen_reg_rtx (SImode);\n+  rtx offset = GEN_INT (arm_stack_protector_guard_offset);\n+  emit_set_insn (reg, gen_rtx_PLUS (SImode, tp, offset));\n+  return gen_rtx_MEM (SImode, reg);\n+}\n+\n+\n /* Whether a register is callee saved or not.  This is necessary because high\n    registers are marked as caller saved when optimizing for size on Thumb-1\n    targets despite being callee saved in order to avoid using them.  */\n@@ -34084,6 +34127,18 @@ arm_run_selftests (void)\n #define TARGET_RUN_TARGET_SELFTESTS selftest::arm_run_selftests\n #endif /* CHECKING_P */\n \n+/* Implement TARGET_STACK_PROTECT_GUARD. In case of a\n+   global variable based guard use the default else\n+   return a null tree.  */\n+static tree\n+arm_stack_protect_guard (void)\n+{\n+  if (arm_stack_protector_guard == SSP_GLOBAL)\n+    return default_stack_protect_guard ();\n+\n+  return NULL_TREE;\n+}\n+\n /* Worker function for TARGET_MD_ASM_ADJUST, while in thumb1 mode.\n    Unlike the arm version, we do NOT implement asm flag outputs.  */\n "}, {"sha": "60468f6182c35a0b410ba800940c3d18b2cd08f5", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 69, "deletions": 2, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d7a84b96980d357bb9a3d368044fb18aab4aade/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d7a84b96980d357bb9a3d368044fb18aab4aade/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=9d7a84b96980d357bb9a3d368044fb18aab4aade", "patch": "@@ -9183,7 +9183,7 @@\n \t\t      UNSPEC_SP_SET))\n       (clobber (match_scratch:SI 2 \"\"))\n       (clobber (match_scratch:SI 3 \"\"))])]\n-  \"\"\n+  \"arm_stack_protector_guard == SSP_GLOBAL\"\n   \"\"\n )\n \n@@ -9267,7 +9267,7 @@\n       (clobber (match_scratch:SI 3 \"\"))\n       (clobber (match_scratch:SI 4 \"\"))\n       (clobber (reg:CC CC_REGNUM))])]\n-  \"\"\n+  \"arm_stack_protector_guard == SSP_GLOBAL\"\n   \"\"\n )\n \n@@ -9361,6 +9361,64 @@\n    (set_attr \"arch\" \"t,32\")]\n )\n \n+(define_expand \"stack_protect_set\"\n+  [(match_operand:SI 0 \"memory_operand\")\n+   (match_operand:SI 1 \"memory_operand\")]\n+  \"arm_stack_protector_guard == SSP_TLSREG\"\n+  \"\n+{\n+  operands[1] = arm_stack_protect_tls_canary_mem (false /* reload */);\n+  emit_insn (gen_stack_protect_set_tls (operands[0], operands[1]));\n+  DONE;\n+}\"\n+)\n+\n+;; DO NOT SPLIT THIS PATTERN.  It is important for security reasons that the\n+;; canary value does not live beyond the life of this sequence.\n+(define_insn \"stack_protect_set_tls\"\n+  [(set (match_operand:SI 0 \"memory_operand\" \"=m\")\n+       (unspec:SI [(match_operand:SI 1 \"memory_operand\" \"m\")]\n+        UNSPEC_SP_SET))\n+   (set (match_scratch:SI 2 \"=&r\") (const_int 0))]\n+  \"\"\n+  \"ldr\\\\t%2, %1\\;str\\\\t%2, %0\\;mov\\t%2, #0\"\n+  [(set_attr \"length\" \"12\")\n+   (set_attr \"conds\" \"unconditional\")\n+   (set_attr \"type\" \"multiple\")]\n+)\n+\n+(define_expand \"stack_protect_test\"\n+  [(match_operand:SI 0 \"memory_operand\")\n+   (match_operand:SI 1 \"memory_operand\")\n+   (match_operand:SI 2)]\n+  \"arm_stack_protector_guard == SSP_TLSREG\"\n+  \"\n+{\n+  operands[1] = arm_stack_protect_tls_canary_mem (true /* reload */);\n+  emit_insn (gen_stack_protect_test_tls (operands[0], operands[1]));\n+\n+  rtx cc_reg = gen_rtx_REG (CC_Zmode, CC_REGNUM);\n+  rtx eq = gen_rtx_EQ (CC_Zmode, cc_reg, const0_rtx);\n+  emit_jump_insn (gen_arm_cond_branch (operands[2], eq, cc_reg));\n+  DONE;\n+}\"\n+)\n+\n+(define_insn \"stack_protect_test_tls\"\n+  [(set (reg:CC_Z CC_REGNUM)\n+\t(compare:CC_Z (unspec:SI [(match_operand:SI 0 \"memory_operand\" \"m\")\n+\t\t\t\t  (match_operand:SI 1 \"memory_operand\" \"m\")]\n+\t\t\t\t UNSPEC_SP_TEST)\n+\t\t      (const_int 0)))\n+   (clobber (match_scratch:SI 2 \"=&r\"))\n+   (clobber (match_scratch:SI 3 \"=&r\"))]\n+  \"\"\n+  \"ldr\\t%2, %0\\;ldr\\t%3, %1\\;eors\\t%2, %3, %2\\;mov\\t%3, #0\"\n+  [(set_attr \"length\" \"16\")\n+   (set_attr \"conds\" \"set\")\n+   (set_attr \"type\" \"multiple\")]\n+)\n+\n (define_expand \"casesi\"\n   [(match_operand:SI 0 \"s_register_operand\")\t; index to jump on\n    (match_operand:SI 1 \"const_int_operand\")\t; lower bound\n@@ -12133,6 +12191,15 @@\n    (set_attr \"type\" \"mrs\")]\n )\n \n+;; Used by the TLS register based stack protector\n+(define_insn \"reload_tp_hard\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(unspec_volatile:SI [(const_int 0)] VUNSPEC_MRC))]\n+  \"TARGET_HARD_TP\"\n+  \"mrc\\\\tp15, 0, %0, c13, c0, 3\\\\t@ reload_tp_hard\"\n+  [(set_attr \"type\" \"mrs\")]\n+)\n+\n ;; Doesn't clobber R1-R3.  Must use r0 for the first operand.\n (define_insn \"load_tp_soft_fdpic\"\n   [(set (reg:SI 0) (unspec:SI [(const_int 0)] UNSPEC_TLS))"}, {"sha": "cc165346bb685eab823e81730dee102daddd32e3", "filename": "gcc/config/arm/arm.opt", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d7a84b96980d357bb9a3d368044fb18aab4aade/gcc%2Fconfig%2Farm%2Farm.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d7a84b96980d357bb9a3d368044fb18aab4aade/gcc%2Fconfig%2Farm%2Farm.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.opt?ref=9d7a84b96980d357bb9a3d368044fb18aab4aade", "patch": "@@ -321,3 +321,25 @@ Generate code which uses the core registers only (r0-r14).\n mfdpic\n Target Mask(FDPIC)\n Enable Function Descriptor PIC mode.\n+\n+mstack-protector-guard=\n+Target RejectNegative Joined Enum(stack_protector_guard) Var(arm_stack_protector_guard) Init(SSP_GLOBAL)\n+Use given stack-protector guard.\n+\n+Enum\n+Name(stack_protector_guard) Type(enum stack_protector_guard)\n+Valid arguments to -mstack-protector-guard=:\n+\n+EnumValue\n+Enum(stack_protector_guard) String(tls) Value(SSP_TLSREG)\n+\n+EnumValue\n+Enum(stack_protector_guard) String(global) Value(SSP_GLOBAL)\n+\n+mstack-protector-guard-offset=\n+Target Joined RejectNegative String Var(arm_stack_protector_guard_offset_str)\n+Use an immediate to offset from the TLS register. This option is for use with\n+fstack-protector-guard=tls and not for use in user-land code.\n+\n+TargetVariable\n+long arm_stack_protector_guard_offset = 0"}, {"sha": "309f5e38a8599811aa79ed88ad861d3d71230723", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d7a84b96980d357bb9a3d368044fb18aab4aade/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d7a84b96980d357bb9a3d368044fb18aab4aade/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=9d7a84b96980d357bb9a3d368044fb18aab4aade", "patch": "@@ -823,6 +823,7 @@ Objective-C and Objective-C++ Dialects}.\n -mpure-code @gol\n -mcmse @gol\n -mfix-cmse-cve-2021-35465 @gol\n+-mstack-protector-guard=@var{guard} -mstack-protector-guard-offset=@var{offset} @gol\n -mfdpic}\n \n @emph{AVR Options}\n@@ -21366,6 +21367,16 @@ enabled by default when the option @option{-mcpu=} is used with\n @code{cortex-m33}, @code{cortex-m35p} or @code{cortex-m55}.  The option\n @option{-mno-fix-cmse-cve-2021-35465} can be used to disable the mitigation.\n \n+@item -mstack-protector-guard=@var{guard}\n+@itemx -mstack-protector-guard-offset=@var{offset}\n+@opindex mstack-protector-guard\n+@opindex mstack-protector-guard-offset\n+Generate stack protection code using canary at @var{guard}.  Supported\n+locations are @samp{global} for a global canary or @samp{tls} for a\n+canary accessible via the TLS register. The option\n+@option{-mstack-protector-guard-offset=} is for use with\n+@option{-fstack-protector-guard=tls} and not for use in user-land code.\n+\n @item -mfdpic\n @itemx -mno-fdpic\n @opindex mfdpic"}, {"sha": "2173bc5a35a0672f3e1a33318a4b808e82575dcf", "filename": "gcc/testsuite/gcc.target/arm/stack-protector-7.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d7a84b96980d357bb9a3d368044fb18aab4aade/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fstack-protector-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d7a84b96980d357bb9a3d368044fb18aab4aade/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fstack-protector-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fstack-protector-7.c?ref=9d7a84b96980d357bb9a3d368044fb18aab4aade", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-require-effective-target arm_hard_vfp_ok }  */\n+/* { dg-require-effective-target arm_arch_v7a_ok } */\n+/* { dg-do compile } */\n+/* { dg-options \"-march=armv7-a -mfpu=vfp -fstack-protector-all -Os -mstack-protector-guard=tls -mstack-protector-guard-offset=1296 -mtp=cp15\" } */\n+\n+#include \"stack-protector-5.c\"\n+\n+/* See the comment in stack-protector-5.c.  */\n+/* { dg-final { scan-assembler-times {\\tstr\\t} 1 } } */\n+/* Expect two TLS register accesses and two occurrences of the offset */\n+/* { dg-final { scan-assembler-times {\\tmrc\\t} 2 } } */\n+/* { dg-final { scan-assembler-times {1296} 2 } } */"}, {"sha": "ea5ef321167877c77ce4c45fbdd27ab18c25ae2b", "filename": "gcc/testsuite/gcc.target/arm/stack-protector-8.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d7a84b96980d357bb9a3d368044fb18aab4aade/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fstack-protector-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d7a84b96980d357bb9a3d368044fb18aab4aade/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fstack-protector-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fstack-protector-8.c?ref=9d7a84b96980d357bb9a3d368044fb18aab4aade", "patch": "@@ -0,0 +1,7 @@\n+/* { dg-require-effective-target arm_hard_vfp_ok }  */\n+/* { dg-require-effective-target arm_arch_v7a_ok } */\n+/* { dg-do compile } */\n+/* { dg-error \"needs a hardware TLS register\" \"missing error when using TLS stack protector without hardware TLS register\" { target *-*-* } 0 } */\n+/* { dg-options \"-fstack-protector-all -Os -mstack-protector-guard=tls -mtp=soft\" } */\n+\n+int foo;"}]}