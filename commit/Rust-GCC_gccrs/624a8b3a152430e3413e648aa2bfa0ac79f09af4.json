{"sha": "624a8b3a152430e3413e648aa2bfa0ac79f09af4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjI0YThiM2ExNTI0MzBlMzQxM2U2NDhhYTJiZmEwYWM3OWYwOWFmNA==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1998-06-09T10:34:59Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-06-09T10:34:59Z"}, "message": "Makefile.in (LIB2FUNCS_EH): Define.\n\n        * Makefile.in (LIB2FUNCS_EH): Define.  Just \"_eh\" for now.\n        (LIBGCC2_CFLAGS): Remove -fexceptions.\n        (LIB2FUNCS): Remove \"_eh\".\n        (libgcc2.a): Iterate over LIB2FUNCS_EH and build everything in\n        it with -fexceptions.\n        * Makefile.in (local-alloc.o): Depend on insn-attr.h.\n        * local-alloc.c (block_alloc): Avoid creating false\n        dependencies for targets which use instruction scheduling.\n\nFrom-SVN: r20370", "tree": {"sha": "0bb9aac28ef6c3f577b92f66cc8c9118200f0464", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0bb9aac28ef6c3f577b92f66cc8c9118200f0464"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/624a8b3a152430e3413e648aa2bfa0ac79f09af4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/624a8b3a152430e3413e648aa2bfa0ac79f09af4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/624a8b3a152430e3413e648aa2bfa0ac79f09af4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/624a8b3a152430e3413e648aa2bfa0ac79f09af4/comments", "author": null, "committer": null, "parents": [{"sha": "674576f1367c7764148f04080cc39f9cf01c56b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/674576f1367c7764148f04080cc39f9cf01c56b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/674576f1367c7764148f04080cc39f9cf01c56b2"}], "stats": {"total": 81, "additions": 76, "deletions": 5}, "files": [{"sha": "734f2e685e5d5283678485c2e7b1fffefeb6d111", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624a8b3a152430e3413e648aa2bfa0ac79f09af4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624a8b3a152430e3413e648aa2bfa0ac79f09af4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=624a8b3a152430e3413e648aa2bfa0ac79f09af4", "patch": "@@ -1,3 +1,15 @@\n+Tue Jun  9 12:36:16 1998  Jeffrey A Law  (law@cygnus.com)\n+\n+\t* Makefile.in (LIB2FUNCS_EH): Define.  Just \"_eh\" for now.\n+\t(LIBGCC2_CFLAGS): Remove -fexceptions.\n+\t(LIB2FUNCS): Remove \"_eh\".\n+\t(libgcc2.a): Iterate over LIB2FUNCS_EH and build everything in\n+\tit with -fexceptions.\n+\n+\t* Makefile.in (local-alloc.o): Depend on insn-attr.h.\n+\t* local-alloc.c (block_alloc): Avoid creating false \n+\tdependencies for targets which use instruction scheduling.\n+\n Tue Jun  9 02:40:49 1998  Richard Henderson  <rth@cygnus.com>\n \n \t* mips/elf.h (ASM_DECLARE_OBJECT_NAME): Define."}, {"sha": "65b9b7122ee34b59fdaad18d13a6376ced768b23", "filename": "gcc/Makefile.in", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624a8b3a152430e3413e648aa2bfa0ac79f09af4/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624a8b3a152430e3413e648aa2bfa0ac79f09af4/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=624a8b3a152430e3413e648aa2bfa0ac79f09af4", "patch": "@@ -324,10 +324,8 @@ LIBGCC2 = libgcc2.a\n # we use this here because that should be enough, and also\n # so that -g1 will be tested.\n #\n-# -fexceptions is necessary for eh.o now that the exceptions are\n-# the default for g++ only.\n LIBGCC2_DEBUG_CFLAGS = -g1\n-LIBGCC2_CFLAGS = -O2 $(LIBGCC2_INCLUDES) $(GCC_CFLAGS) $(TARGET_LIBGCC2_CFLAGS) $(LIBGCC2_DEBUG_CFLAGS) $(GTHREAD_FLAGS) -DIN_LIBGCC2 -D__GCC_FLOAT_NOT_NEEDED -fexceptions @inhibit_libc@ \n+LIBGCC2_CFLAGS = -O2 $(LIBGCC2_INCLUDES) $(GCC_CFLAGS) $(TARGET_LIBGCC2_CFLAGS) $(LIBGCC2_DEBUG_CFLAGS) $(GTHREAD_FLAGS) -DIN_LIBGCC2 -D__GCC_FLOAT_NOT_NEEDED @inhibit_libc@ \n \n # Additional options to use when compiling libgcc2.a.\n # Some targets override this to -Iinclude\n@@ -689,7 +687,9 @@ LIB2FUNCS = _muldi3 _divdi3 _moddi3 _udivdi3 _umoddi3 _negdi2 \\\n     _fixtfdi _fixunstfdi _floatditf \\\n     __gcc_bcmp _varargs __dummy _eprintf \\\n     _bb _shtab _clear_cache _trampoline __main _exit \\\n-    _ctors _eh  _pure\n+    _ctors _pure\n+\n+LIB2FUNCS_EH = _eh\n \n FPBIT_FUNCS = _pack_sf _unpack_sf _addsub_sf _mul_sf _div_sf \\\n     _fpcmp_parts_sf _compare_sf _eq_sf _ne_sf _gt_sf _ge_sf \\\n@@ -1020,6 +1020,15 @@ libgcc2.a: libgcc2.c libgcc2.ready $(CONFIG_H) $(FPBIT) $(DPBIT) $(LIB2ADD) \\\n \t  $(AR) $(AR_FLAGS) tmplibgcc2.a $${name}$(objext); \\\n \t  rm -f $${name}$(objext); \\\n \tdone\n+\tfor name in $(LIB2FUNCS_EH); \\\n+\tdo \\\n+\t  echo $${name}; \\\n+\t  $(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) -fexceptions $(INCLUDES) -c \\\n+\t      -DL$${name} $(srcdir)/libgcc2.c -o $${name}$(objext); \\\n+\t  if [ $$? -eq 0 ] ; then true; else exit 1; fi; \\\n+\t  $(AR) $(AR_FLAGS) tmplibgcc2.a $${name}$(objext); \\\n+\t  rm -f $${name}$(objext); \\\n+\tdone\n \tif [ x$(FPBIT) != x ]; then \\\n \t  for name in $(FPBIT_FUNCS); \\\n \t  do \\\n@@ -1431,7 +1440,8 @@ regclass.o : regclass.c $(CONFIG_H) system.h $(RTL_H) hard-reg-set.h flags.h \\\n    $(BASIC_BLOCK_H) regs.h insn-config.h $(RECOG_H) reload.h real.h toplev.h \\\n    output.h\n local-alloc.o : local-alloc.c $(CONFIG_H) system.h $(RTL_H) flags.h \\\n-   $(BASIC_BLOCK_H) regs.h hard-reg-set.h insn-config.h $(RECOG_H) output.h\n+   $(BASIC_BLOCK_H) regs.h hard-reg-set.h insn-config.h $(RECOG_H) output.h \\\n+   insn-attr.h\n bitmap.o : bitmap.c $(CONFIG_H) system.h $(RTL_H) flags.h $(BASIC_BLOCK_H) \\\n    regs.h\n global.o : global.c $(CONFIG_H) system.h $(RTL_H) flags.h  \\"}, {"sha": "9daf31dda14b558a1d88b1eeb8f091e5a0dcd1a8", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/624a8b3a152430e3413e648aa2bfa0ac79f09af4/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/624a8b3a152430e3413e648aa2bfa0ac79f09af4/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=624a8b3a152430e3413e648aa2bfa0ac79f09af4", "patch": "@@ -67,6 +67,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"regs.h\"\n #include \"hard-reg-set.h\"\n #include \"insn-config.h\"\n+#include \"insn-attr.h\"\n #include \"recog.h\"\n #include \"output.h\"\n \f\n@@ -1414,15 +1415,63 @@ block_alloc (b)\n       q = qty_order[i];\n       if (qty_phys_reg[q] < 0)\n \t{\n+#ifdef INSN_SCHEDULING\n+\t  /* These values represent the adjusted lifetime of a qty so\n+\t     that it conflicts with qtys which appear near the start/end\n+\t     of this qty's lifetime.\n+\n+\t     The purpose behind extending the lifetime of this qty is to\n+\t     discourage the register allocator from creating false\n+\t     dependencies.\n+ \n+\t     The adjustment by the value +-3 indicates precisely that\n+\t     this qty conflicts with qtys in the instructions immediately\n+\t     before and after the lifetime of this qty.\n+\n+\t     Experiments have shown that higher values tend to hurt\n+\t     overall code performance.\n+\n+\t     If allocation using the extended lifetime fails we will try\n+\t     again with the qty's unadjusted lifetime.  */\n+\t  int fake_birth = MAX (0, qty_birth[q] - 3);\n+\t  int fake_death = MIN (insn_number * 2 + 1, qty_death[q] + 3);\n+#endif\n+\n \t  if (N_REG_CLASSES > 1)\n \t    {\n+#ifdef INSN_SCHEDULING\n+\t      /* We try to avoid using hard registers allocated to qtys which\n+\t\t are born immediately after this qty or die immediately before\n+\t\t this qty.\n+\n+\t\t This optimization is only appropriate when we will run\n+\t\t a scheduling pass after reload and we are not optimizing\n+\t\t for code size.  */\n+\t      if (flag_schedule_insns_after_reload && !optimize_size)\n+\t\t{\n+\t\t\n+\t\t  qty_phys_reg[q] = find_free_reg (qty_min_class[q], \n+\t\t\t\t\t\t   qty_mode[q], q, 0, 0,\n+\t\t\t\t\t\t   fake_birth, fake_death);\n+\t\t  if (qty_phys_reg[q] >= 0)\n+\t\t    continue;\n+\t\t}\n+#endif\n \t      qty_phys_reg[q] = find_free_reg (qty_min_class[q], \n \t\t\t\t\t       qty_mode[q], q, 0, 0,\n \t\t\t\t\t       qty_birth[q], qty_death[q]);\n \t      if (qty_phys_reg[q] >= 0)\n \t\tcontinue;\n \t    }\n \n+#ifdef INSN_SCHEDULING\n+\t  /* Similarly, avoid false dependencies.  */\n+\t  if (flag_schedule_insns_after_reload && !optimize_size\n+\t      && qty_alternate_class[q] != NO_REGS)\n+\t    qty_phys_reg[q] = find_free_reg (qty_alternate_class[q],\n+\t\t\t\t\t     qty_mode[q], q, 0, 0,\n+\t\t\t\t\t     fake_birth, fake_death);\n+#endif\n \t  if (qty_alternate_class[q] != NO_REGS)\n \t    qty_phys_reg[q] = find_free_reg (qty_alternate_class[q],\n \t\t\t\t\t     qty_mode[q], q, 0, 0,"}]}