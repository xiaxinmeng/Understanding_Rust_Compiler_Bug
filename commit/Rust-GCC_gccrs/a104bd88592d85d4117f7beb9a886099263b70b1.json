{"sha": "a104bd88592d85d4117f7beb9a886099263b70b1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTEwNGJkODg1OTJkODVkNDExN2Y3YmViOWE4ODYwOTkyNjNiNzBiMQ==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2017-05-14T17:50:28Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2017-05-14T17:50:28Z"}, "message": "PR middle-end/77671 - missing -Wformat-overflow warning on sprintf overflow with %s\n\ngcc/ChangeLog:\n\n\tPR middle-end/77671\n\t* gimple-fold.c (gimple_fold_builtin_sprintf): Make extern.\n\t(gimple_fold_builtin_snprintf): Same.\n\t* gimple-fold.h (gimple_fold_builtin_sprintf): Declare.\n\t(gimple_fold_builtin_snprintf): Same.\n\t* gimple-ssa-sprintf.c (get_format_string): Correct the detection\n\tof character types.\n\t(is_call_safe): New function.\n\t(try_substitute_return_value): Call it.\n\t(try_simplify_call): New function.\n\t(pass_sprintf_length::handle_gimple_call): Call it.\n\ngcc/testsuite/ChangeLog:\n\nPR middle-end/77671\n\t* gcc.dg/tree-ssa/builtin-sprintf-7.c: New test.\n\t* gcc.dg/tree-ssa/builtin-sprintf-8.c: New test.\n\t* gcc.dg/tree-ssa/builtin-sprintf-warn-1.c: Adjust.\n\t* gcc.dg/tree-ssa/builtin-sprintf-warn-2.c: Adjust.\n\t* gcc.dg/tree-ssa/builtin-sprintf-warn-3.c: Adjust.\n\nFrom-SVN: r248035", "tree": {"sha": "50e03b802f151fb4d37e1777a2b4b1d2a036f87e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/50e03b802f151fb4d37e1777a2b4b1d2a036f87e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a104bd88592d85d4117f7beb9a886099263b70b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a104bd88592d85d4117f7beb9a886099263b70b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a104bd88592d85d4117f7beb9a886099263b70b1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a104bd88592d85d4117f7beb9a886099263b70b1/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c6c0251911ac280500d939cdeae87536727e5971", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6c0251911ac280500d939cdeae87536727e5971", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6c0251911ac280500d939cdeae87536727e5971"}], "stats": {"total": 441, "additions": 365, "deletions": 76}, "files": [{"sha": "4f20bcef11e37cb43bb8d312452853ee3dbae368", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a104bd88592d85d4117f7beb9a886099263b70b1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a104bd88592d85d4117f7beb9a886099263b70b1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a104bd88592d85d4117f7beb9a886099263b70b1", "patch": "@@ -1,3 +1,17 @@\n+2017-05-14  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/77671\n+\t* gimple-fold.c (gimple_fold_builtin_sprintf): Make extern.\n+\t(gimple_fold_builtin_snprintf): Same.\n+\t* gimple-fold.h (gimple_fold_builtin_sprintf): Declare.\n+\t(gimple_fold_builtin_snprintf): Same.\n+\t* gimple-ssa-sprintf.c (get_format_string): Correct the detection\n+\tof character types.\n+\t(is_call_safe): New function.\n+\t(try_substitute_return_value): Call it.\n+\t(try_simplify_call): New function.\n+\t(pass_sprintf_length::handle_gimple_call): Call it.\n+\n 2017-05-14  Martin Sebor  <msebor@redhat.com>\n \n \tPR middle-end/80669"}, {"sha": "921e120cf865ea3edd89506b93d3299e134bf8f2", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a104bd88592d85d4117f7beb9a886099263b70b1/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a104bd88592d85d4117f7beb9a886099263b70b1/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=a104bd88592d85d4117f7beb9a886099263b70b1", "patch": "@@ -2670,11 +2670,9 @@ gimple_fold_builtin_sprintf_chk (gimple_stmt_iterator *gsi,\n    ORIG may be null if this is a 2-argument call.  We don't attempt to\n    simplify calls with more than 3 arguments.\n \n-   Return NULL_TREE if no simplification was possible, otherwise return the\n-   simplified form of the call as a tree.  If IGNORED is true, it means that\n-   the caller does not use the returned value of the function.  */\n+   Return true if simplification was possible, otherwise false.  */\n \n-static bool\n+bool\n gimple_fold_builtin_sprintf (gimple_stmt_iterator *gsi)\n {\n   gimple *stmt = gsi_stmt (*gsi);\n@@ -2795,11 +2793,9 @@ gimple_fold_builtin_sprintf (gimple_stmt_iterator *gsi)\n    FMT, and ORIG.  ORIG may be null if this is a 3-argument call.  We don't\n    attempt to simplify calls with more than 4 arguments.\n \n-   Return NULL_TREE if no simplification was possible, otherwise return the\n-   simplified form of the call as a tree.  If IGNORED is true, it means that\n-   the caller does not use the returned value of the function.  */\n+   Return true if simplification was possible, otherwise false.  */\n \n-static bool\n+bool\n gimple_fold_builtin_snprintf (gimple_stmt_iterator *gsi)\n {\n   gcall *stmt = as_a <gcall *> (gsi_stmt (*gsi));\n@@ -3384,10 +3380,7 @@ gimple_fold_builtin (gimple_stmt_iterator *gsi)\n     case BUILT_IN_SNPRINTF_CHK:\n     case BUILT_IN_VSNPRINTF_CHK:\n       return gimple_fold_builtin_snprintf_chk (gsi, fcode);\n-    case BUILT_IN_SNPRINTF:\n-      return gimple_fold_builtin_snprintf (gsi);\n-    case BUILT_IN_SPRINTF:\n-      return gimple_fold_builtin_sprintf (gsi);\n+\n     case BUILT_IN_FPRINTF:\n     case BUILT_IN_FPRINTF_UNLOCKED:\n     case BUILT_IN_VFPRINTF:"}, {"sha": "ad0b00dccadb8b1d13b71c256ba2aa00d9c82cb0", "filename": "gcc/gimple-fold.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a104bd88592d85d4117f7beb9a886099263b70b1/gcc%2Fgimple-fold.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a104bd88592d85d4117f7beb9a886099263b70b1/gcc%2Fgimple-fold.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.h?ref=a104bd88592d85d4117f7beb9a886099263b70b1", "patch": "@@ -54,6 +54,8 @@ extern tree gimple_get_virt_method_for_vtable (HOST_WIDE_INT, tree,\n \t\t\t\t\t       unsigned HOST_WIDE_INT,\n \t\t\t\t\t       bool *can_refer = NULL);\n extern tree gimple_fold_indirect_ref (tree);\n+extern bool gimple_fold_builtin_sprintf (gimple_stmt_iterator *);\n+extern bool gimple_fold_builtin_snprintf (gimple_stmt_iterator *);\n extern bool arith_code_with_undefined_signed_overflow (tree_code);\n extern gimple_seq rewrite_to_defined_overflow (gimple *);\n "}, {"sha": "f43778bbcfcd6ddf51ec9f8fc6c54f4fefe27bf4", "filename": "gcc/gimple-ssa-sprintf.c", "status": "modified", "additions": 115, "deletions": 44, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a104bd88592d85d4117f7beb9a886099263b70b1/gcc%2Fgimple-ssa-sprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a104bd88592d85d4117f7beb9a886099263b70b1/gcc%2Fgimple-ssa-sprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-sprintf.c?ref=a104bd88592d85d4117f7beb9a886099263b70b1", "patch": "@@ -526,7 +526,10 @@ get_format_string (tree format, location_t *ploc)\n   if (TREE_CODE (format) != STRING_CST)\n     return NULL;\n \n-  if (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (format))) != char_type_node)\n+  tree type = TREE_TYPE (format);\n+\n+  if (GET_MODE_CLASS (TYPE_MODE (TREE_TYPE (type))) != MODE_INT\n+      || GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (type))) != 1)\n     {\n       /* Wide format string.  */\n       return NULL;\n@@ -3511,31 +3514,25 @@ get_destination_size (tree dest)\n   return HOST_WIDE_INT_M1U;\n }\n \n-/* Given a suitable result RES of a call to a formatted output function\n-   described by INFO, substitute the result for the return value of\n-   the call.  The result is suitable if the number of bytes it represents\n-   is known and exact.  A result that isn't suitable for substitution may\n-   have its range set to the range of return values, if that is known.\n-   Return true if the call is removed and gsi_next should not be performed\n-   in the caller.  */\n+/* Return true if the call described by INFO with result RES safe to\n+   optimize (i.e., no undefined behavior), and set RETVAL to the range\n+   of its return values.  */\n \n static bool\n-try_substitute_return_value (gimple_stmt_iterator *gsi,\n-\t\t\t     const pass_sprintf_length::call_info &info,\n-\t\t\t     const format_result &res)\n+is_call_safe (const pass_sprintf_length::call_info &info,\n+\t      const format_result &res, bool under4k,\n+\t      unsigned HOST_WIDE_INT retval[2])\n {\n-  tree lhs = gimple_get_lhs (info.callstmt);\n-\n-  /* Set to true when the entire call has been removed.  */\n-  bool removed = false;\n+  if (under4k && !res.under4k)\n+    return false;\n \n   /* The minimum return value.  */\n-  unsigned HOST_WIDE_INT minretval = res.range.min;\n+  retval[0] = res.range.min;\n \n   /* The maximum return value is in most cases bounded by RES.RANGE.MAX\n      but in cases involving multibyte characters could be as large as\n      RES.RANGE.UNLIKELY.  */\n-  unsigned HOST_WIDE_INT maxretval\n+  retval[1]\n     = res.range.unlikely < res.range.max ? res.range.max : res.range.unlikely;\n \n   /* Adjust the number of bytes which includes the terminating nul\n@@ -3544,27 +3541,63 @@ try_substitute_return_value (gimple_stmt_iterator *gsi,\n      a valid range before the adjustment below is [0, INT_MAX + 1]\n      (the functions only return negative values on error or undefined\n      behavior).  */\n-  if (minretval <= target_int_max () + 1)\n-    --minretval;\n-  if (maxretval <= target_int_max () + 1)\n-    --maxretval;\n+  if (retval[0] <= target_int_max () + 1)\n+    --retval[0];\n+  if (retval[1] <= target_int_max () + 1)\n+    --retval[1];\n \n   /* Avoid the return value optimization when the behavior of the call\n      is undefined either because any directive may have produced 4K or\n      more of output, or the return value exceeds INT_MAX, or because\n      the output overflows the destination object (but leave it enabled\n      when the function is bounded because then the behavior is well-\n      defined).  */\n-  if (res.under4k\n-      && minretval == maxretval\n-      && (info.bounded || minretval < info.objsize)\n-      && minretval <= target_int_max ()\n+  if (retval[0] == retval[1]\n+      && (info.bounded || retval[0] < info.objsize)\n+      && retval[0] <= target_int_max ())\n+    return true;\n+\n+  if ((info.bounded || retval[1] < info.objsize)\n+      && (retval[0] < target_int_max ()\n+\t  && retval[1] < target_int_max ()))\n+    return true;\n+\n+  if (!under4k && (info.bounded || retval[0] < info.objsize))\n+    return true;\n+\n+  return false;\n+}\n+\n+/* Given a suitable result RES of a call to a formatted output function\n+   described by INFO, substitute the result for the return value of\n+   the call.  The result is suitable if the number of bytes it represents\n+   is known and exact.  A result that isn't suitable for substitution may\n+   have its range set to the range of return values, if that is known.\n+   Return true if the call is removed and gsi_next should not be performed\n+   in the caller.  */\n+\n+static bool\n+try_substitute_return_value (gimple_stmt_iterator *gsi,\n+\t\t\t     const pass_sprintf_length::call_info &info,\n+\t\t\t     const format_result &res)\n+{\n+  tree lhs = gimple_get_lhs (info.callstmt);\n+\n+  /* Set to true when the entire call has been removed.  */\n+  bool removed = false;\n+\n+  /* The minimum and maximum return value.  */\n+  unsigned HOST_WIDE_INT retval[2];\n+  bool safe = is_call_safe (info, res, true, retval);\n+\n+  if (safe\n+      && retval[0] == retval[1]\n       /* Not prepared to handle possibly throwing calls here; they shouldn't\n \t appear in non-artificial testcases, except when the __*_chk routines\n \t are badly declared.  */\n       && !stmt_ends_bb_p (info.callstmt))\n     {\n-      tree cst = build_int_cst (integer_type_node, minretval);\n+      tree cst = build_int_cst (integer_type_node, retval[0]);\n \n       if (lhs == NULL_TREE\n \t  && info.nowrite)\n@@ -3612,18 +3645,18 @@ try_substitute_return_value (gimple_stmt_iterator *gsi,\n     {\n       bool setrange = false;\n \n-      if ((info.bounded || maxretval < info.objsize)\n-\t  && res.under4k\n-\t  && (minretval < target_int_max ()\n-\t      && maxretval < target_int_max ()))\n+      if (safe\n+\t  && (info.bounded || retval[1] < info.objsize)\n+\t  && (retval[0] < target_int_max ()\n+\t      && retval[1] < target_int_max ()))\n \t{\n \t  /* If the result is in a valid range bounded by the size of\n \t     the destination set it so that it can be used for subsequent\n \t     optimizations.  */\n \t  int prec = TYPE_PRECISION (integer_type_node);\n \n-\t  wide_int min = wi::shwi (minretval, prec);\n-\t  wide_int max = wi::shwi (maxretval, prec);\n+\t  wide_int min = wi::shwi (retval[0], prec);\n+\t  wide_int max = wi::shwi (retval[1], prec);\n \t  set_range_info (lhs, VR_RANGE, min, max);\n \n \t  setrange = true;\n@@ -3632,21 +3665,21 @@ try_substitute_return_value (gimple_stmt_iterator *gsi,\n       if (dump_file)\n \t{\n \t  const char *inbounds\n-\t    = (minretval < info.objsize\n-\t       ? (maxretval < info.objsize\n+\t    = (retval[0] < info.objsize\n+\t       ? (retval[1] < info.objsize\n \t\t  ? \"in\" : \"potentially out-of\")\n \t       : \"out-of\");\n \n \t  const char *what = setrange ? \"Setting\" : \"Discarding\";\n-\t  if (minretval != maxretval)\n+\t  if (retval[0] != retval[1])\n \t    fprintf (dump_file,\n \t\t     \"  %s %s-bounds return value range [%llu, %llu].\\n\",\n \t\t     what, inbounds,\n-\t\t     (unsigned long long)minretval,\n-\t\t     (unsigned long long)maxretval);\n+\t\t     (unsigned long long)retval[0],\n+\t\t     (unsigned long long)retval[1]);\n \t  else\n \t    fprintf (dump_file, \"  %s %s-bounds return value %llu.\\n\",\n-\t\t     what, inbounds, (unsigned long long)minretval);\n+\t\t     what, inbounds, (unsigned long long)retval[0]);\n \t}\n     }\n \n@@ -3656,6 +3689,34 @@ try_substitute_return_value (gimple_stmt_iterator *gsi,\n   return removed;\n }\n \n+/* Try to simplify a s{,n}printf call described by INFO with result\n+   RES by replacing it with a simpler and presumably more efficient\n+   call (such as strcpy).  */\n+\n+static bool\n+try_simplify_call (gimple_stmt_iterator *gsi,\n+\t\t   const pass_sprintf_length::call_info &info,\n+\t\t   const format_result &res)\n+{\n+  unsigned HOST_WIDE_INT dummy[2];\n+  if (!is_call_safe (info, res, info.retval_used (), dummy))\n+    return false;\n+\n+  switch (info.fncode)\n+    {\n+    case BUILT_IN_SNPRINTF:\n+      return gimple_fold_builtin_snprintf (gsi);\n+\n+    case BUILT_IN_SPRINTF:\n+      return gimple_fold_builtin_sprintf (gsi);\n+\n+    default:\n+      ;\n+    }\n+\n+  return false;\n+}\n+\n /* Determine if a GIMPLE CALL is to one of the sprintf-like built-in\n    functions and if so, handle it.  Return true if the call is removed\n    and gsi_next should not be performed in the caller.  */\n@@ -3907,13 +3968,23 @@ pass_sprintf_length::handle_gimple_call (gimple_stmt_iterator *gsi)\n      attempt to substitute the computed result for the return value of\n      the call.  Avoid this optimization when -frounding-math is in effect\n      and the format string contains a floating point directive.  */\n-  if (success\n-      && optimize > 0\n-      && flag_printf_return_value\n-      && (!flag_rounding_math || !res.floating))\n-    return try_substitute_return_value (gsi, info, res);\n+  bool call_removed = false;\n+  if (success && optimize > 0)\n+    {\n+      /* Save a copy of the iterator pointing at the call.  The iterator\n+\t may change to point past the call in try_substitute_return_value\n+\t but the original value is needed in try_simplify_call.  */\n+      gimple_stmt_iterator gsi_call = *gsi;\n \n-  return false;\n+      if (flag_printf_return_value\n+\t  && (!flag_rounding_math || !res.floating))\n+\tcall_removed = try_substitute_return_value (gsi, info, res);\n+\n+      if (!call_removed)\n+\ttry_simplify_call (&gsi_call, info, res);\n+    }\n+\n+  return call_removed;\n }\n \n /* Execute the pass for function FUN.  */"}, {"sha": "ac54d650e35fec038e5cca046e3a17fa861157cc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a104bd88592d85d4117f7beb9a886099263b70b1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a104bd88592d85d4117f7beb9a886099263b70b1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a104bd88592d85d4117f7beb9a886099263b70b1", "patch": "@@ -1,3 +1,12 @@\n+2017-05-14  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/77671\n+\t* gcc.dg/tree-ssa/builtin-sprintf-7.c: New test.\n+\t* gcc.dg/tree-ssa/builtin-sprintf-8.c: New test.\n+\t* gcc.dg/tree-ssa/builtin-sprintf-warn-1.c: Adjust.\n+\t* gcc.dg/tree-ssa/builtin-sprintf-warn-2.c: Adjust.\n+\t* gcc.dg/tree-ssa/builtin-sprintf-warn-3.c: Adjust.\n+\n 2017-05-14  Martin Sebor  <msebor@redhat.com>\n \n \tPR middle-end/80669"}, {"sha": "29954aabfdb4859ad76e38b755d83432dc45fe71", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-7.c", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a104bd88592d85d4117f7beb9a886099263b70b1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a104bd88592d85d4117f7beb9a886099263b70b1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-7.c?ref=a104bd88592d85d4117f7beb9a886099263b70b1", "patch": "@@ -0,0 +1,99 @@\n+/* PR tree-optimization/77671 - missing -Wformat-overflow warning\n+   on sprintf overflow with \"%s\"\n+   { dg-compile }\n+   { dg-options \"-O2 -Wformat -Wno-format-zero-length -fdump-tree-optimized\" } */\n+\n+void sink (char*);\n+\n+extern char buffer[];\n+\n+/* String exactly 4100 characters long (plus the terminating NUL).  */\n+extern const char s4100[4101];\n+\n+void test_sprintf (const char *s)\n+{\n+#define IGN(...) __builtin_sprintf (buffer, __VA_ARGS__); sink (buffer)\n+\n+  /* Each of the following calls is expected to be transformed into\n+     one of memcpy or strcpy.  */\n+  IGN (\"\");\n+  IGN (\"a\");\n+  IGN (\"ab\");\n+  /* FIXME: Transform to strcpy/memcpy.  */\n+  /* IGN (s4100 + 5); */\n+\n+  IGN (\"%s\", \"\");\n+  IGN (\"%s\", \"a\");\n+  IGN (\"%s\", \"ab\");\n+\n+  IGN (\"%s\", s4100 + 5);\n+\n+  /* FIXME: This can be transformed into strcpy.  */\n+  /* IGN (s); */\n+  IGN (\"%s\", s);\n+}\n+\n+\n+void test_snprintf (void)\n+{\n+#undef IGN\n+#define IGN(N, ...) __builtin_snprintf (buffer, N, __VA_ARGS__); sink (buffer)\n+\n+  /* Each of the following calls is expected to be transformed into\n+     one of memcpy or strcpy.  */\n+  IGN (1, \"\");\n+  IGN (2, \"1\");\n+  IGN (8, \"1234567\");\n+\n+  /* FIXME: Transform to strcpy/memcpy.  */\n+  /* IGN (4096, s4100 + 5); */\n+\n+  IGN (1, \"%s\", \"\");\n+  IGN (2, \"%s\", \"1\");\n+  IGN (8, \"%s\", \"1234567\");\n+\n+  IGN (4096, \"%s\", s4100 + 5);\n+}\n+\n+#if 0   /* FIXME: Implement vs{,n}printf optimization.  */\n+\n+void test_vsprintf (__builtin_va_list va)\n+{\n+#undef IGN\n+#define IGN(fmt) __builtin_vsprintf (buffer, fmt, va); sink (buffer)\n+\n+  /* Each of the following calls is expected to be transformed into\n+     one of memcpy or strcpy.  */\n+  IGN (\"\");\n+  IGN (\"a\");\n+  IGN (\"ab\");\n+  IGN (s4100 + 5);\n+\n+  IGN (\"%s\");\n+}\n+\n+void test_vsnprintf (__builtin_va_list va)\n+{\n+#undef IGN\n+#define IGN(N, fmt) __builtin_vsnprintf (buffer, N, fmt, va); sink (buffer)\n+\n+  /* Each of the following calls is expected to be transformed into\n+     one of memcpy or strcpy.  */\n+  IGN (   1, \"\");\n+  IGN (   2, \"1\");\n+  IGN (   8, \"1234567\");\n+  IGN (4096, s4100 + 5);\n+}\n+\n+#endif\n+\n+/* { dg-final { scan-tree-dump-not \"builtin_sprintf\" \"optimized\" } }\n+   { dg-final { scan-tree-dump-not \"builtin_snprintf\" \"optimized\" } }\n+   { dg-final { scan-tree-dump-not \"builtin_vsprintf\" \"optimized\" } }\n+   { dg-final { scan-tree-dump-not \"builtin_vsnprintf\" \"optimized\" } } */\n+\n+#define S10    \"0123456789\"\n+#define S100   S10 S10 S10 S10 S10  S10 S10 S10 S10 S10\n+#define S1000  S100 S100 S100 S100 S100  S100 S100 S100 S100 S100\n+\n+const char s4100[4101] = S1000 S1000 S1000 S1000 S100;"}, {"sha": "2d38d12bcc22cb6b5f7bcc48947e224192ffd227", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-8.c", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a104bd88592d85d4117f7beb9a886099263b70b1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a104bd88592d85d4117f7beb9a886099263b70b1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-8.c?ref=a104bd88592d85d4117f7beb9a886099263b70b1", "patch": "@@ -0,0 +1,104 @@\n+/* PR tree-optimization/77671 - missing -Wformat-overflow warning\n+   on sprintf overflow with \"%s\"\n+\n+   Negative test verifying that sprintf family calls that must not\n+   be transformed into calls to other functions (such as memcpy)\n+   are preserved.\n+\n+   { dg-compile }\n+   { dg-options \"-O2 -Wformat -Wno-format-truncation -Wno-format-zero-length -fdump-tree-optimized\" } */\n+\n+void sink (char*, ...);\n+\n+extern char buffer[];\n+\n+/* String exactly 4100 characters long (plus the terminating NUL).  */\n+extern const char s4100[4101];\n+\n+void test_sprintf (const char *s)\n+{\n+  /* Macros to test the function call while eignoring and using\n+     the return value, respectively.  */\n+#define IGN(...) __builtin_sprintf (buffer, __VA_ARGS__), sink (buffer)\n+#define USE(...) sink (buffer, __builtin_sprintf (buffer, __VA_ARGS__))\n+\n+  /* All of the following calls to sprintf must be emitted (and not\n+     transformed into memcpy, strcpy, or similar).  */\n+\n+  /* Verify that a sprintf call with output in excess of the maximum\n+     of 4095 bytes is not transformed into memcpy/strcpy when its\n+     return value is used (the call may fail with EOVERFLOW but\n+     the error is only detectable when the function's negative return\n+     value indicates errno is valid ).  */\n+  USE (s4100);\n+\n+  USE (\"%s\", s4100);\n+\n+  /* Same as above but with string of unknown length (which could\n+     be in excess of 4K long).  */\n+  USE (s);\n+  USE (\"%s\", s);\n+}\n+\n+\n+void test_snprintf (void)\n+{\n+#undef IGN\n+#define IGN(N, ...) __builtin_snprintf (buffer, N, __VA_ARGS__); sink (buffer)\n+\n+  /* All of the following calls to sprintf must be emitted (and not\n+     transformed into memcpy, strcpy, or similar).  */\n+\n+  /* Truncated output could be optimized into strncpy (not done yet).  */\n+  IGN (1, \"123\");\n+  IGN (1, s4100);\n+\n+  IGN (1, \"%s\", \"123\");\n+  IGN (1, \"%s\", s4100);\n+\n+  /* Output in excess of the maximum of 4095 bytes.  */\n+  IGN (4097, s4100);\n+\n+  IGN (4097, \"%s\", s4100);\n+}\n+\n+\n+void test_vsprintf (__builtin_va_list va)\n+{\n+#undef IGN\n+#define IGN(fmt) __builtin_vsprintf (buffer, fmt, va); sink (buffer)\n+\n+  /* All of the following calls to vsprintf must be emitted (and not\n+     transformed into memcpy, strcpy, or similar).  */\n+\n+  /* Output in excess of the maximum of 4095 bytes.  */\n+  IGN (s4100);\n+}\n+\n+\n+void test_vsnprintf (__builtin_va_list va)\n+{\n+#undef IGN\n+#define IGN(N, fmt) __builtin_vsnprintf (buffer, N, fmt, va); sink (buffer)\n+\n+  /* All of the following calls to vsnprintf must be emitted (and not\n+     transformed into memcpy, strcpy, or similar).  */\n+\n+  /* Truncated output could be optimized into strncpy (not done yet).  */\n+  IGN (1, \"123\");\n+  IGN (1, s4100);\n+\n+  /* Output in excess of the maximum of 4095 bytes.  */\n+  IGN (4097, s4100);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"builtin_sprintf\" 4 \"optimized\" } }\n+   { dg-final { scan-tree-dump-times \"builtin_snprintf\" 6 \"optimized\" } }\n+   { dg-final { scan-tree-dump-times \"builtin_vsprintf\" 1 \"optimized\" } }\n+   { dg-final { scan-tree-dump-times \"builtin_vsnprintf\" 3 \"optimized\" } } */\n+\n+#define S10    \"0123456789\"\n+#define S100   S10 S10 S10 S10 S10  S10 S10 S10 S10 S10\n+#define S1000  S100 S100 S100 S100 S100  S100 S100 S100 S100 S100\n+\n+const char s4100[4101] = S1000 S1000 S1000 S1000 S100;"}, {"sha": "73e927fcc95c4aa2803020296c59b88b29a493f7", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a104bd88592d85d4117f7beb9a886099263b70b1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a104bd88592d85d4117f7beb9a886099263b70b1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-1.c?ref=a104bd88592d85d4117f7beb9a886099263b70b1", "patch": "@@ -1068,7 +1068,7 @@ void test_sprintf_chk_e_const (void)\n void test_sprintf_chk_s_nonconst (int w, int p, const char *s)\n {\n   T (-1, \"%s\",   s);\n-  T ( 0, \"%s\",   s);            /* { dg-warning \"writing a terminating nul\" } */\n+  T ( 0, \"%-s\",  s);            /* { dg-warning \"writing a terminating nul\" } */\n   T ( 1, \"%s\",   s);\n   T (-1, \"%.0s\", s);\n   T ( 1, \"%.0s\", s);"}, {"sha": "60695b88e47b2d34d120d28ee6afe7732c573da7", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-2.c", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a104bd88592d85d4117f7beb9a886099263b70b1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a104bd88592d85d4117f7beb9a886099263b70b1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-2.c?ref=a104bd88592d85d4117f7beb9a886099263b70b1", "patch": "@@ -94,8 +94,8 @@ struct Arrays {\n void test_s_nonconst (int w, int p, const char *s, const wchar_t *ws,\n \t\t      struct Arrays *a)\n {\n-  T (0, \"%s\",   s);             /* { dg-warning \"into a region\" \"sprintf transformed into strcpy\" { xfail *-*-* } } */\n-  T (1, \"%s\",   s);             /* { dg-warning \"nul past the end\" \"sprintf transformed into strcpy\" { xfail *-*-* } } */\n+  T (0, \"%s\",   s);             /* { dg-warning \"into a region\" } */\n+  T (1, \"%s\",   s);             /* { dg-warning \"nul past the end\" } */\n   T (1, \"%1s\",  s);             /* { dg-warning \"writing a terminating nul\" } */\n   T (1, \"%.0s\", s);\n   T (1, \"%.1s\", s);             /* { dg-warning \"may write a terminating nul\" } */\n@@ -112,30 +112,27 @@ void test_s_nonconst (int w, int p, const char *s, const wchar_t *ws,\n   T (1, \"%.1ls\",  ws);          /* { dg-warning \"may write a terminating nul\" } */\n   T (1, \"%ls\",    ws);          /* { dg-warning \"may write a terminating nul\" } */\n \n-  /* Verify that the size of the array is used in lieu of its length.\n-     The minus sign disables GCC's sprintf to strcpy transformation.\n-     In the case below, the length of s->a1 can be at most zero, so\n-     the call should not be diagnosed.  */\n-  T (1, \"%-s\", a->a1);\n+  /* Verify that the size of the array is used in lieu of its length.  */\n+  T (1, \"%s\", a->a1);\n \n   /* In the following test, since the length of the strings isn't known,\n      their type (the array) is used to bound the maximum length to 1,\n-     which means the \"%-s\" directive would not overflow the buffer,\n+     which means the \"%s\" directive would not overflow the buffer,\n      but it would leave no room for the terminating nul.  */\n-  T (1, \"%-s\", a->a2);          /* { dg-warning \"may write a terminating nul\" } */\n+  T (1, \"%s\", a->a2);           /* { dg-warning \"may write a terminating nul\" } */\n \n   /* Unlike in the test above, since the length of the string is bounded\n-     by the array type to at most 2, the \"^-s\" directive is diagnosed firts,\n+     by the array type to at most 2, the \"%s\" directive is diagnosed firts,\n      preventing the diagnostic about the terminatinb nul.  */\n-  T (1, \"%-s\", a->a3);          /* { dg-warning \"directive writing up to 2 bytes\" } */\n+  T (1, \"%s\", a->a3);           /* { dg-warning \"directive writing up to 2 bytes\" } */\n \n   /* The length of a zero length array and flexible array member is\n      unknown and at leve 2 assumed to be at least 1.  */\n-  T (1, \"%-s\", a->a0);          /* { dg-warning \"may write a terminating nul\" } */\n-  T (1, \"%-s\", a->ax);          /* { dg-warning \"may write a terminating nul\" } */\n+  T (1, \"%s\", a->a0);           /* { dg-warning \"may write a terminating nul\" } */\n+  T (1, \"%s\", a->ax);           /* { dg-warning \"may write a terminating nul\" } */\n \n-  T (2, \"%-s\", a->a0);\n-  T (2, \"%-s\", a->ax);\n+  T (2, \"%s\", a->a0);\n+  T (2, \"%s\", a->ax);\n }\n \n   /* Exercise buffer overflow detection with non-const integer arguments.  */"}, {"sha": "7cbcbdbe54c882c1e133bd976a7edbdb8e268eb8", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-3.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a104bd88592d85d4117f7beb9a886099263b70b1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a104bd88592d85d4117f7beb9a886099263b70b1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-3.c?ref=a104bd88592d85d4117f7beb9a886099263b70b1", "patch": "@@ -57,10 +57,10 @@ void test_sprintf_chk_string (const char *s, const char *t)\n {\n #define x x ()\n \n-  T (1, \"%s\", x ? \"\" : \"1\");       /* { dg-warning \"nul past the end\" } */\n-  T (1, \"%s\", x ? \"1\" : \"\");       /* { dg-warning \"nul past the end\" } */\n-  T (1, \"%s\", x ? s : \"1\");        /* { dg-warning \"nul past the end\" } */\n-  T (1, \"%s\", x ? \"1\" : s);        /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%-s\", x ? \"\" : \"1\");       /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%-s\", x ? \"1\" : \"\");       /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%-s\", x ? s : \"1\");        /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%-s\", x ? \"1\" : s);        /* { dg-warning \"nul past the end\" } */\n \n   /* When neither string is known no warning should be issued at level 1\n      since their lenghts are assumed to be zero.  */"}]}