{"sha": "afe4375b43ca2a4b57c992ab6dc6f242ddd5e124", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWZlNDM3NWI0M2NhMmE0YjU3Yzk5MmFiNmRjNmYyNDJkZGQ1ZTEyNA==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2007-04-06T09:20:23Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-04-06T09:20:23Z"}, "message": "exp_ch7.ads, [...] (Find_Final_List): If the access type is anonymous, use finalization list of enclosing dynamic scope.\n\n2007-04-06  Ed Schonberg  <schonberg@adacore.com>\n\t    Bob Duff  <duff@adacore.com>\n\t    Cyrille Comar  <comar@adacore.com>\n\n\t* exp_ch7.ads, exp_ch7.adb (Find_Final_List): If the access type is\n\tanonymous, use finalization list of enclosing dynamic scope.\n\t(Expand_N_Package_Declaration): For a library package declaration\n\twithout a corresponding body, generate RACW subprogram bodies in the\n\tspec (just as we do for the task activation call).\n\t(Convert_View): Split Is_Abstract flag into Is_Abstract_Subprogram and\n\tIs_Abstract_Type. Make sure these are called only when appropriate.\n\tRemove all code for DSP option\n\t(CW_Or_Controlled_Type): new subprogram.\n\nFrom-SVN: r123563", "tree": {"sha": "7328de656b70856fbc6fb23c83bc83e6f2c17b4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7328de656b70856fbc6fb23c83bc83e6f2c17b4c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/afe4375b43ca2a4b57c992ab6dc6f242ddd5e124", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afe4375b43ca2a4b57c992ab6dc6f242ddd5e124", "html_url": "https://github.com/Rust-GCC/gccrs/commit/afe4375b43ca2a4b57c992ab6dc6f242ddd5e124", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afe4375b43ca2a4b57c992ab6dc6f242ddd5e124/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "dee4682a7ad30b0e642d755e02168d7db25c6d67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dee4682a7ad30b0e642d755e02168d7db25c6d67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dee4682a7ad30b0e642d755e02168d7db25c6d67"}], "stats": {"total": 262, "additions": 167, "deletions": 95}, "files": [{"sha": "144d20b6f21b4d0adc5cdabe8a86abef8fca47be", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 99, "deletions": 31, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afe4375b43ca2a4b57c992ab6dc6f242ddd5e124/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afe4375b43ca2a4b57c992ab6dc6f242ddd5e124/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=afe4375b43ca2a4b57c992ab6dc6f242ddd5e124", "patch": "@@ -35,9 +35,11 @@ with Errout;   use Errout;\n with Exp_Ch9;  use Exp_Ch9;\n with Exp_Ch11; use Exp_Ch11;\n with Exp_Dbug; use Exp_Dbug;\n+with Exp_Dist; use Exp_Dist;\n with Exp_Tss;  use Exp_Tss;\n with Exp_Util; use Exp_Util;\n with Freeze;   use Freeze;\n+with Lib;      use Lib;\n with Hostparm; use Hostparm;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n@@ -46,7 +48,6 @@ with Output;   use Output;\n with Restrict; use Restrict;\n with Rident;   use Rident;\n with Rtsfind;  use Rtsfind;\n-with Targparm; use Targparm;\n with Sinfo;    use Sinfo;\n with Sem;      use Sem;\n with Sem_Ch3;  use Sem_Ch3;\n@@ -900,6 +901,15 @@ package body Exp_Ch7 is\n                    and then Controlled_Type (Corresponding_Record_Type (T)));\n    end Controlled_Type;\n \n+   ---------------------------\n+   -- CW_Or_Controlled_Type --\n+   ---------------------------\n+\n+   function CW_Or_Controlled_Type (T : Entity_Id) return Boolean is\n+   begin\n+      return Is_Class_Wide_Type (T) or else Controlled_Type (T);\n+   end CW_Or_Controlled_Type;\n+\n    --------------------------\n    -- Controller_Component --\n    --------------------------\n@@ -977,7 +987,7 @@ package body Exp_Ch7 is\n          Atyp := Etype (Arg);\n       end if;\n \n-      if Is_Abstract (Proc) and then Is_Tagged_Type (Ftyp) then\n+      if Is_Abstract_Subprogram (Proc) and then Is_Tagged_Type (Ftyp) then\n          return Unchecked_Convert_To (Class_Wide_Type (Ftyp), Arg);\n \n       elsif Ftyp /= Atyp\n@@ -1020,17 +1030,12 @@ package body Exp_Ch7 is\n       Loc       : constant Source_Ptr := Sloc (N);\n       Wrap_Node : Node_Id;\n \n-      Sec_Stk : constant Boolean :=\n-                  Sec_Stack and not Functions_Return_By_DSP_On_Target;\n-      --  We never need a secondary stack if functions return by DSP\n-\n    begin\n       --  Do not create a transient scope if we are already inside one\n \n       for S in reverse Scope_Stack.First .. Scope_Stack.Last loop\n-\n          if Scope_Stack.Table (S).Is_Transient then\n-            if Sec_Stk then\n+            if Sec_Stack then\n                Set_Uses_Sec_Stack (Scope_Stack.Table (S).Entity);\n             end if;\n \n@@ -1064,7 +1069,7 @@ package body Exp_Ch7 is\n          New_Scope (New_Internal_Entity (E_Block, Current_Scope, Loc, 'B'));\n          Set_Scope_Is_Transient;\n \n-         if Sec_Stk then\n+         if Sec_Stack then\n             Set_Uses_Sec_Stack (Current_Scope);\n             Check_Restriction (No_Secondary_Stack, N);\n          end if;\n@@ -1546,12 +1551,12 @@ package body Exp_Ch7 is\n    -- Expand_N_Package_Body --\n    ---------------------------\n \n-   --  Add call to Activate_Tasks if body is an activator (actual\n-   --  processing is in chapter 9).\n+   --  Add call to Activate_Tasks if body is an activator (actual processing\n+   --  is in chapter 9).\n \n    --  Generate subprogram descriptor for elaboration routine\n \n-   --  ENcode entity names in package body\n+   --  Encode entity names in package body\n \n    procedure Expand_N_Package_Body (N : Node_Id) is\n       Ent : constant Entity_Id := Corresponding_Spec (N);\n@@ -1583,14 +1588,76 @@ package body Exp_Ch7 is\n    --  whether a body will eventually appear.\n \n    procedure Expand_N_Package_Declaration (N : Node_Id) is\n+      Spec    : constant Node_Id := Specification (N);\n+      Decls   : List_Id;\n+\n+      No_Body : Boolean;\n+      --  True in the case of a package declaration that is a compilation unit\n+      --  and for which no associated body will be compiled in\n+      --  this compilation.\n    begin\n-      if Nkind (Parent (N)) = N_Compilation_Unit\n-        and then not Body_Required (Parent (N))\n+\n+      No_Body := False;\n+\n+      --  Case of a package declaration other than a compilation unit\n+\n+      if Nkind (Parent (N)) /= N_Compilation_Unit then\n+         null;\n+\n+      --  Case of a compilation unit that does not require a body\n+\n+      elsif not Body_Required (Parent (N))\n         and then not Unit_Requires_Body (Defining_Entity (N))\n-        and then Present (Activation_Chain_Entity (N))\n       then\n+         No_Body := True;\n+\n+      --  Special case of generating calling stubs for a remote call interface\n+      --  package: even though the package declaration requires one, the\n+      --  body won't be processed in this compilation (so any stubs for RACWs\n+      --  declared in the package must be generated here, along with the\n+      --  spec).\n+\n+      elsif Parent (N) = Cunit (Main_Unit)\n+        and then Is_Remote_Call_Interface (Defining_Entity (N))\n+        and then Distribution_Stub_Mode = Generate_Caller_Stub_Body\n+      then\n+         No_Body := True;\n+      end if;\n+\n+      --  For a package declaration that implies no associated body, generate\n+      --  task activation call and RACW supporting bodies now (since we won't\n+      --  have a specific separate compilation unit for that).\n+\n+      if No_Body then\n+\n          New_Scope (Defining_Entity (N));\n-         Build_Task_Activation_Call (N);\n+\n+         if Has_RACW (Defining_Entity (N)) then\n+\n+            --  Generate RACW subprogram bodies\n+\n+            Decls := Private_Declarations (Spec);\n+\n+            if No (Decls) then\n+               Decls := Visible_Declarations (Spec);\n+            end if;\n+\n+            if No (Decls) then\n+               Decls := New_List;\n+               Set_Visible_Declarations (Spec, Decls);\n+            end if;\n+\n+            Append_RACW_Bodies (Decls, Defining_Entity (N));\n+            Analyze_List (Decls);\n+         end if;\n+\n+         if Present (Activation_Chain_Entity (N)) then\n+\n+            --  Generate task activation call as last step of elaboration\n+\n+            Build_Task_Activation_Call (N);\n+         end if;\n+\n          Pop_Scope;\n       end if;\n \n@@ -1652,12 +1719,18 @@ package body Exp_Ch7 is\n              Selector_Name => Make_Identifier (Loc, Name_F));\n \n       --  Case of a dynamically allocated object. The final list is the\n-      --  corresponding list controller (The next entity in the scope of\n-      --  the access type with the right type). If the type comes from a\n-      --  With_Type clause, no controller was created, and we use the\n-      --  global chain instead.\n+      --  corresponding list controller (the next entity in the scope of the\n+      --  access type with the right type). If the type comes from a With_Type\n+      --  clause, no controller was created, we use the global chain instead.\n \n-      elsif Is_Access_Type (E) then\n+      --  An anonymous access type either has a list created for it when the\n+      --  allocator is a for an access parameter or an access discriminant,\n+      --  or else it uses the list of the enclosing dynamic scope, when the\n+      --  context is a declaration or an assignment.\n+\n+      elsif Is_Access_Type (E)\n+        and then Ekind (E) /= E_Anonymous_Access_Type\n+      then\n          if not From_With_Type (E) then\n             return\n               Make_Selected_Component (Loc,\n@@ -2589,7 +2662,7 @@ package body Exp_Ch7 is\n \n       if Prim = Finalize_Case or else Prim = Adjust_Case then\n          Handler := New_List (\n-           Make_Exception_Handler (Loc,\n+           Make_Implicit_Exception_Handler (Loc,\n              Exception_Choices => New_List (Make_Others_Choice (Loc)),\n              Statements        => New_List (\n                Make_Raise_Program_Error (Loc,\n@@ -3025,10 +3098,8 @@ package body Exp_Ch7 is\n                   Set_Uses_Sec_Stack (Current_Scope, False);\n \n                   if not Requires_Transient_Scope (Etype (S)) then\n-                     if not Functions_Return_By_DSP_On_Target then\n-                        Set_Uses_Sec_Stack (S, True);\n-                        Check_Restriction (No_Secondary_Stack, Action);\n-                     end if;\n+                     Set_Uses_Sec_Stack (S, True);\n+                     Check_Restriction (No_Secondary_Stack, Action);\n                   end if;\n \n                   exit;\n@@ -3046,11 +3117,8 @@ package body Exp_Ch7 is\n                elsif K = E_Procedure\n                  or else K = E_Block\n                then\n-                  if not Functions_Return_By_DSP_On_Target then\n-                     Set_Uses_Sec_Stack (S, True);\n-                     Check_Restriction (No_Secondary_Stack, Action);\n-                  end if;\n-\n+                  Set_Uses_Sec_Stack (S, True);\n+                  Check_Restriction (No_Secondary_Stack, Action);\n                   Set_Uses_Sec_Stack (Current_Scope, False);\n                   exit;\n "}, {"sha": "a062fef3921a4c779bd7bcc5e0870d4378f75b48", "filename": "gcc/ada/exp_ch7.ads", "status": "modified", "additions": 68, "deletions": 64, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afe4375b43ca2a4b57c992ab6dc6f242ddd5e124/gcc%2Fada%2Fexp_ch7.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afe4375b43ca2a4b57c992ab6dc6f242ddd5e124/gcc%2Fada%2Fexp_ch7.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.ads?ref=afe4375b43ca2a4b57c992ab6dc6f242ddd5e124", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -60,15 +60,21 @@ package Exp_Ch7 is\n    function Controlled_Type (T : Entity_Id) return Boolean;\n    --  True if T potentially needs finalization actions\n \n+   function CW_Or_Controlled_Type (T : Entity_Id) return Boolean;\n+   --  True if T is either a potentially controlled type or a class-wide type.\n+   --  Note that in normal mode, class-wide types are potentially controlled so\n+   --  this function is different from Controlled_Type only under restrictions\n+   --  No_Finalization.\n+\n    function Find_Final_List\n      (E   : Entity_Id;\n       Ref : Node_Id := Empty) return Node_Id;\n-   --  E is an entity representing a controlled object, a controlled type\n-   --  or a scope. If Ref is not empty, it is a reference to a controlled\n-   --  record, the closest Final list is in the controller component of\n-   --  the record containing Ref otherwise this function returns a\n-   --  reference to the final list attached to the closest dynamic scope\n-   --  (that can be E itself) creating this final list if necessary.\n+   --  E is an entity representing a controlled object, a controlled type or a\n+   --  scope. If Ref is not empty, it is a reference to a controlled record,\n+   --  the closest Final list is in the controller component of the record\n+   --  containing Ref otherwise this function returns a reference to the final\n+   --  list attached to the closest dynamic scope (that can be E itself)\n+   --  creating this final list if necessary.\n \n    function Has_New_Controlled_Component (E : Entity_Id) return Boolean;\n    --  E is a type entity. Give the same resul as Has_Controlled_Component\n@@ -79,54 +85,52 @@ package Exp_Ch7 is\n      (Obj_Ref     : Node_Id;\n       Flist_Ref   : Node_Id;\n       With_Attach : Node_Id) return Node_Id;\n-   --  Attach the referenced object to the referenced Final Chain\n-   --  'Flist_Ref' With_Attach is an expression of type Short_Short_Integer\n-   --  which can be either '0' to signify no attachment, '1' for\n-   --  attachement to a simply linked list or '2' for attachement to a\n-   --  doubly linked list.\n+   --  Attach the referenced object to the referenced Final Chain 'Flist_Ref'\n+   --  With_Attach is an expression of type Short_Short_Integer which can be\n+   --  either '0' to signify no attachment, '1' for attachement to a simply\n+   --  linked list or '2' for attachement to a doubly linked list.\n \n    function Make_Init_Call\n      (Ref         : Node_Id;\n       Typ         : Entity_Id;\n       Flist_Ref   : Node_Id;\n       With_Attach : Node_Id) return List_Id;\n-   --  Ref is an expression (with no-side effect and is not required to\n-   --  have been previously analyzed) that references the object to be\n-   --  initialized. Typ is the expected type of Ref, which is a controlled\n-   --  type (Is_Controlled) or a type with controlled components\n-   --  (Has_Controlled). With_Attach is an integer expression representing\n-   --  the level of attachment, see Attach_To_Final_List's Nb_Link param\n-   --  documentation in s-finimp.ads.\n+   --  Ref is an expression (with no-side effect and is not required to have\n+   --  been previously analyzed) that references the object to be initialized.\n+   --  Typ is the expected type of Ref, which is either a controlled type\n+   --  (Is_Controlled) or a type with controlled components (Has_Controlled).\n+   --  With_Attach is an integer expression which is the attchment level,\n+   --  see System.Finalization_Implementation.Attach_To_Final_List for the\n+   --  documentation of Nb_Link.\n    --\n-   --  This function will generate the appropriate calls to make\n-   --  sure that the objects referenced by Ref are initialized. The\n-   --  generate code is quite different depending on the fact the type\n-   --  IS_Controlled or HAS_Controlled but this is not the problem of the\n-   --  caller, the details are in the body.\n+   --  This function will generate the appropriate calls to make sure that the\n+   --  objects referenced by Ref are initialized. The generated code is quite\n+   --  different for an IS_Controlled type or a HAS_Controlled type, but this\n+   --  is not the problem for the caller, the details are in the body.\n \n    function Make_Adjust_Call\n      (Ref         : Node_Id;\n       Typ         : Entity_Id;\n       Flist_Ref   : Node_Id;\n       With_Attach : Node_Id;\n       Allocator   : Boolean := False) return List_Id;\n-   --  Ref is an expression (with no-side effect and is not required to\n-   --  have been previously analyzed) that references the object to be\n-   --  adjusted. Typ is the expected type of Ref, which is a controlled\n-   --  type (Is_Controlled) or a type with controlled components\n-   --  (Has_Controlled).  With_Attach is an integer expression representing\n-   --  the level of attachment, see Attach_To_Final_List's Nb_Link param\n-   --  documentation in s-finimp.ads. Note: if Typ is Finalize_Storage_Only\n-   --  and the object is at library level, then With_Attach will be ignored,\n-   --  and a zero link level will be passed to Attach_To_Final_List.\n+   --  Ref is an expression (with no-side effect and is not required to have\n+   --  been previously analyzed) that references the object to be adjusted. Typ\n+   --  is the expected type of Ref, which is a controlled type (Is_Controlled)\n+   --  or a type with controlled components (Has_Controlled). With_Attach is an\n+   --  integer expression giving the attachment level (see documentation of\n+   --  Attach_To_Final_List.Nb_Link param documentation in s-finimp.ads.\n+   --  Note: if Typ is Finalize_Storage_Only and the object is at library\n+   --  level, then With_Attach will be ignored, and a zero link level will be\n+   --  passed to Attach_To_Final_List.\n    --\n-   --  This function will generate the appropriate calls to make\n-   --  sure that the objects referenced by Ref are adjusted. The generated\n-   --  code is quite different depending on the fact the type IS_Controlled\n-   --  or HAS_Controlled but this is not the problem of the caller, the\n-   --  details are in the body. The objects must be attached when the adjust\n-   --  takes place after an initialization expression but not when it takes\n-   --  place after a regular assignment.\n+   --  This function will generate the appropriate calls to make sure that the\n+   --  objects referenced by Ref are adjusted. The generated code is quite\n+   --  different depending on the fact the type IS_Controlled or HAS_Controlled\n+   --  but this is not the problem of the caller, the details are in the body.\n+   --  The objects must be attached when the adjust takes place after an\n+   --  initialization expression but not when it takes place after a regular\n+   --  assignment.\n    --\n    --  If Allocator is True, we are adjusting a newly-created object. The\n    --  existing chaining pointers should not be left unchanged, because they\n@@ -138,21 +142,21 @@ package Exp_Ch7 is\n      (Ref         : Node_Id;\n       Typ         : Entity_Id;\n       With_Detach : Node_Id) return List_Id;\n-   --  Ref is an expression (with no-side effect and is not required\n-   --  to have been previously analyzed) that references the object to\n-   --  be Finalized. Typ is the expected type of Ref, which is a\n-   --  controlled type (Is_Controlled) or a type with controlled\n-   --  components (Has_Controlled). With_Detach is a boolean expression\n-   --  indicating whether to detach the controlled object from whatever\n-   --  finalization list it is currently attached to.\n+   --  Ref is an expression (with no-side effect and is not required to have\n+   --  been previously analyzed) that references the object to be Finalized.\n+   --  Typ is the expected type of Ref, which is a controlled type\n+   --  (Is_Controlled) or a type with controlled components (Has_Controlled).\n+   --  With_Detach is a boolean expression indicating whether to detach the\n+   --  controlled object from whatever finalization list it is currently\n+   --  attached to.\n    --\n-   --  This function will generate the appropriate calls to make\n-   --  sure that the objects referenced by Ref are finalized. The generated\n-   --  code is quite different depending on the fact the type IS_Controlled\n-   --  or HAS_Controlled but this is not the problem of the caller, the\n-   --  details are in the body. The objects must be detached when finalizing\n-   --  an unchecked deallocated object but not when finalizing the target of\n-   --  an assignment, it is not necessary either on scope exit.\n+   --  This function will generate the appropriate calls to make sure that the\n+   --  objects referenced by Ref are finalized. The generated code is quite\n+   --  different depending on the fact the type IS_Controlled or HAS_Controlled\n+   --  but this is not the problem of the caller, the details are in the body.\n+   --  The objects must be detached when finalizing an unchecked deallocated\n+   --  object but not when finalizing the target of an assignment, it is not\n+   --  necessary either on scope exit.\n \n    procedure Expand_Ctrl_Function_Call (N : Node_Id);\n    --  Expand a call to a function returning a controlled value. That is to\n@@ -167,8 +171,8 @@ package Exp_Ch7 is\n      (N   : Node_Id;\n       Obj : Node_Id;\n       Typ : Entity_Id) return List_Id;\n-   --  Generate loops to finalize any tasks or simple protected objects\n-   --  that are subcomponents of an array.\n+   --  Generate loops to finalize any tasks or simple protected objects that\n+   --  are subcomponents of an array.\n \n    function Cleanup_Protected_Object\n      (N   : Node_Id;\n@@ -191,10 +195,10 @@ package Exp_Ch7 is\n    --  Check whether composite type contains a simple protected component\n \n    function Is_Simple_Protected_Type (T : Entity_Id) return Boolean;\n-   --  Check whether argument is a protected type without entries.\n-   --  Protected types with entries are controlled, and their cleanup\n-   --  is handled by the standard finalization machinery. For simple\n-   --  protected types we generate inline code to release their locks.\n+   --  Check whether argument is a protected type without entries. Protected\n+   --  types with entries are controlled, and their cleanup is handled by the\n+   --  standard finalization machinery. For simple protected types we generate\n+   --  inline code to release their locks.\n \n    --------------------------------\n    -- Transient Scope Management --\n@@ -215,12 +219,12 @@ package Exp_Ch7 is\n    --  return the node to be wrapped if the current scope is transient\n \n    procedure Store_Before_Actions_In_Scope (L : List_Id);\n-   --  Append the list L of actions to the end of the before-actions store\n-   --  in the top of the scope stack\n+   --  Append the list L of actions to the end of the before-actions store in\n+   --  the top of the scope stack\n \n    procedure Store_After_Actions_In_Scope (L : List_Id);\n-   --  Append the list L of actions to the beginning of the after-actions\n-   --  store in the top of the scope stack\n+   --  Append the list L of actions to the beginning of the after-actions store\n+   --  in the top of the scope stack\n \n    procedure Wrap_Transient_Declaration (N : Node_Id);\n    --  N is an object declaration. Expand the finalization calls after the"}]}