{"sha": "8d4812411e608e9e61e22cdd046945885eaa5478", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGQ0ODEyNDExZTYwOGU5ZTYxZTIyY2RkMDQ2OTQ1ODg1ZWFhNTQ3OA==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1996-09-16T17:40:36Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1996-09-16T17:40:36Z"}, "message": "(ext_shift_insns, ext_shift_amounts): new arrays.\n\n(gen_ashift_hi, gen_shifty_hi_op, shl_and_kind): new functions.\nrtx_equal_function_value_matters: declare.\n(shl_and_length, shl_and_src_length, gen_shl_and): new functions.\n(shl_sext_kind, shl_sext_length, gen_shl_sext): new functions.\n\nFrom-SVN: r12726", "tree": {"sha": "50c5a09c85b7f20d07db37660de79266fbebfa74", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/50c5a09c85b7f20d07db37660de79266fbebfa74"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d4812411e608e9e61e22cdd046945885eaa5478", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d4812411e608e9e61e22cdd046945885eaa5478", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d4812411e608e9e61e22cdd046945885eaa5478", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d4812411e608e9e61e22cdd046945885eaa5478/comments", "author": null, "committer": null, "parents": [{"sha": "98e819b9b7517686db6f7a313a25e13486e4563c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98e819b9b7517686db6f7a313a25e13486e4563c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98e819b9b7517686db6f7a313a25e13486e4563c"}], "stats": {"total": 585, "additions": 585, "deletions": 0}, "files": [{"sha": "490b202d590fd7545a0ca19ef4de03fbd06bcf73", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 585, "deletions": 0, "changes": 585, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d4812411e608e9e61e22cdd046945885eaa5478/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d4812411e608e9e61e22cdd046945885eaa5478/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=8d4812411e608e9e61e22cdd046945885eaa5478", "patch": "@@ -684,6 +684,23 @@ static short shift_amounts[32][5] = {\n   {16, 8}, {16, 1, 8}, {16, 8, 2}, {16, 8, 1, 2},\n   {16, 8, 2, 2}, {16, -1, -2, 16}, {16, -2, 16}, {16, -1, 16}};\n \n+/* Likewise, but for shift amounts < 16, up to three highmost bits\n+   might be clobbered.  This is typically used when combined with some\n+   kind of sign or zero extension.  */\n+   \n+static char ext_shift_insns[]    =\n+  { 0,1,1,2,2,3,2,2,1,2,2,3,3,3,2,2,1,2,2,3,3,4,3,3,2,3,3,4,4,4,3,3};\n+\n+static short ext_shift_amounts[32][4] = {\n+  {0}, {1}, {2}, {2, 1},\n+  {2, 2}, {2, 1, 2}, {8, -2}, {8, -1},\n+  {8}, {8, 1}, {8, 2}, {8, 1, 2},\n+  {8, 2, 2}, {16, -2, -1}, {16, -2}, {16, -1},\n+  {16}, {16, 1}, {16, 2}, {16, 1, 2},\n+  {16, 2, 2}, {16, 2, 1, 2}, {16, -2, 8}, {16, -1, 8},\n+  {16, 8}, {16, 1, 8}, {16, 8, 2}, {16, 8, 1, 2},\n+  {16, 8, 2, 2}, {16, -1, -2, 16}, {16, -2, 16}, {16, -1, 16}};\n+\n /* This is used in length attributes in sh.md to help compute the length\n    of arbitrary constant shift instructions.  */\n \n@@ -825,6 +842,41 @@ gen_ashift (type, n, reg)\n     }\n }\n \n+/* Same for HImode */\n+\n+void\n+gen_ashift_hi (type, n, reg)\n+     int type;\n+     int n;\n+     rtx reg;\n+{\n+  /* Negative values here come from the shift_amounts array.  */\n+  if (n < 0)\n+    {\n+      if (type == ASHIFT)\n+\ttype = LSHIFTRT;\n+      else\n+\ttype = ASHIFT;\n+      n = -n;\n+    }\n+\n+  switch (type)\n+    {\n+    case ASHIFTRT:\n+      emit_insn (gen_ashrhi3_k (reg, reg, GEN_INT (n)));\n+      break;\n+    case LSHIFTRT:\n+      if (n == 1)\n+\temit_insn (gen_lshrhi3_m (reg, reg, GEN_INT (n)));\n+      else\n+\temit_insn (gen_lshrhi3_k (reg, reg, GEN_INT (n)));\n+      break;\n+    case ASHIFT:\n+      emit_insn (gen_ashlhi3_k (reg, reg, GEN_INT (n)));\n+      break;\n+    }\n+}\n+\n /* Output RTL to split a constant shift into its component SH constant\n    shift instructions.  */\n    \n@@ -872,6 +924,41 @@ gen_shifty_op (code, operands)\n   for (i = 0; i < max; i++)\n     gen_ashift (code, shift_amounts[value][i], operands[0]);\n }\n+   \n+/* Same as above, but optimized for values where the topmost bits don't\n+   matter.  */\n+\n+int\n+gen_shifty_hi_op (code, operands)\n+     int code;\n+     rtx *operands;\n+{\n+  int value = INTVAL (operands[2]);\n+  int max, i;\n+  void (*gen_fun)();\n+\n+  /* This operation is used by and_shl for SImode values with a few\n+     high bits known to be cleared.  */\n+  value &= 31;\n+  if (value == 0)\n+    {\n+      emit_insn (gen_nop ());\n+      return;\n+    }\n+\n+  gen_fun = GET_MODE (operands[0]) == HImode ? gen_ashift_hi : gen_ashift;\n+  if (code == ASHIFT)\n+    {\n+      max = ext_shift_insns[value];\n+      for (i = 0; i < max; i++)\n+\tgen_fun (code, ext_shift_amounts[value][i], operands[0]);\n+    }\n+  else\n+    /* When shifting right, emit the shifts in reverse order, so that\n+       solitary negative values come first.  */\n+    for (i = ext_shift_insns[value] - 1; i >= 0; i--)\n+      gen_fun (code, ext_shift_amounts[value][i], operands[0]);\n+}\n \n /* Output RTL for an arithmetic right shift.  */\n \n@@ -945,6 +1032,504 @@ expand_ashiftrt (operands)\n   emit_move_insn (operands[0], gen_rtx (REG, SImode, 4));\n   return 1;\n }\n+\n+/* Try to find a good way to implement the combiner pattern\n+  [(set (match_operand:SI 0 \"register_operand\" \"r\")\n+        (and:SI (ashift:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+                           (match_operand:SI 2 \"const_int_operand\" \"n\"))\n+                (match_operand:SI 3 \"const_int_operand\" \"n\"))) .\n+  LEFT_RTX is operand 2 in the above pattern, and MASK_RTX is operand 3.\n+  return 0 for simple right / left or left/right shift combination.\n+  return 1 for a combination of shifts with zero_extend.\n+  return 2 for a combination of shifts with an AND that needs r0.\n+  return 3 for a combination of shifts with an AND that needs an extra\n+    scratch register, when the three highmost bits of the AND mask are clear.\n+  return 4 for a combination of shifts with an AND that needs an extra\n+    scratch register, when any of the three highmost bits of the AND mask\n+    is set.\n+  If ATTRP is set, store an initial right shift width in ATTRP[0],\n+  and the instruction length in ATTRP[1] .  These values are not valid\n+  when returning 0.\n+  When ATTRP is set and returning 1, ATTRP[2] gets set to the index into\n+  shift_amounts for the last shift value that is to be used before the\n+  sign extend.  */\n+int\n+shl_and_kind (left_rtx, mask_rtx, attrp)\n+     rtx left_rtx, mask_rtx;\n+     int *attrp;\n+{\n+  unsigned HOST_WIDE_INT mask, lsb, mask2, lsb2;\n+  int left = INTVAL (left_rtx), right;\n+  int best = 0;\n+  int cost, best_cost = 10000;\n+  int best_right = 0, best_len = 0;\n+  int i;\n+  int can_ext;\n+\n+  if (left < 0 || left > 31)\n+    return 0;\n+  if (GET_CODE (mask_rtx) == CONST_INT)\n+    mask = (unsigned HOST_WIDE_INT) INTVAL (mask_rtx) >> left;\n+  else\n+    mask = (unsigned HOST_WIDE_INT) GET_MODE_MASK (SImode) >> left;\n+  /* Can this be expressed as a right shift / left shift pair ? */\n+  lsb = ((mask ^ (mask - 1)) >> 1) + 1;\n+  right = exact_log2 (lsb);\n+  mask2 = ~(mask + lsb - 1);\n+  lsb2 = ((mask2 ^ (mask2 - 1)) >> 1) + 1;\n+  /* mask has no zeroes but trailing zeroes <==> ! mask2 */\n+  if (! mask2)\n+    best_cost = shift_insns[right] + shift_insns[right + left];\n+  /* mask has no trailing zeroes <==> ! right */\n+  else if (! right && mask2 == ~(lsb2 - 1))\n+    {\n+      int late_right = exact_log2 (lsb2);\n+      best_cost = shift_insns[left + late_right] + shift_insns[late_right];\n+    }\n+  /* Try to use zero extend */\n+  if (mask2 == ~(lsb2 - 1))\n+    {\n+      int width, first;\n+\n+      for (width = 8; width <= 16; width += 8)\n+\t{\n+\t  /* Can we zero-extend right away? */\n+\t  if (lsb2 == (HOST_WIDE_INT)1 << width)\n+\t    {\n+\t      cost\n+\t\t= 1 + ext_shift_insns[right] + ext_shift_insns[left + right];\n+\t      if (cost < best_cost)\n+\t\t{\n+\t\t  best = 1;\n+\t\t  best_cost = cost;\n+\t\t  best_right = right;\n+\t\t  best_len = cost;\n+\t\t  if (attrp)\n+\t\t    attrp[2] = -1;\n+\t\t}\n+\t      continue;\n+\t    }\n+\t  /* ??? Could try to put zero extend into initial right shift,\n+\t     or even shift a bit left before the right shift. */\n+\t  /* Determine value of first part of left shift, to get to the\n+\t     zero extend cut-off point.  */\n+\t  first = width - exact_log2 (lsb2) + right;\n+\t  if (first >= 0 && right + left - first >= 0)\n+\t    {\n+\t      cost = ext_shift_insns[right] + ext_shift_insns[first] + 1\n+\t\t+ ext_shift_insns[right + left - first];\n+\t      if (cost < best_cost)\n+\t\t{\n+\t\t  best = 1;\n+\t\t  best_cost = cost;\n+\t\t  best_right = right;\n+\t\t  best_len = cost;\n+\t\t  if (attrp)\n+\t\t    attrp[2] = first;\n+\t\t  }\n+\t    }\n+\t}\n+    }\n+  /* Try to use r0 AND pattern */\n+  for (i = 0; i <= 2; i++)\n+    {\n+      if (i > right)\n+\tbreak;\n+      if (! CONST_OK_FOR_L (mask >> i))\n+\tcontinue;\n+      cost = (i != 0) + 2 + ext_shift_insns[left + i];\n+      if (cost < best_cost)\n+\t{\n+\t  best = 2;\n+\t  best_cost = cost;\n+\t  best_right = i;\n+\t  best_len = cost - 1;\n+\t}\n+    }\n+  /* Try to use a scratch register to hold the AND operand.  */\n+  can_ext = ((mask << left) & 0xe0000000) == 0;\n+  for (i = 0; i <= 2; i++)\n+    {\n+      if (i > right)\n+\tbreak;\n+      cost = (i != 0) + (CONST_OK_FOR_I (mask >> i) ? 2 : 3)\n+\t+ (can_ext ? ext_shift_insns : shift_insns)[left];\n+      if (cost < best_cost)\n+\t{\n+\t  best = 4 - can_ext;\n+\t  best_cost = cost;\n+\t  best_right = i;\n+\t  best_len = cost - 1 - ! CONST_OK_FOR_I (mask >> i);\n+\t}\n+    }\n+\n+  if (attrp)\n+    {\n+      attrp[0] = best_right;\n+      attrp[1] = best_len;\n+    }\n+  return best;\n+}\n+\n+/* This is used in length attributes of the unnamed instructions\n+   corresponding to shl_and_kind return values of 1 and 2.  */\n+int\n+shl_and_length (insn)\n+     rtx insn;\n+{\n+  rtx set_src, left_rtx, mask_rtx;\n+  int attributes[3];\n+\n+  set_src = SET_SRC (XVECEXP (PATTERN (insn), 0, 0));\n+  left_rtx = XEXP (XEXP (set_src, 0), 1);\n+  mask_rtx = XEXP (set_src, 1);\n+  shl_and_kind (left_rtx, mask_rtx, attributes);\n+  return attributes[1];\n+}\n+\n+/* This is used in length attribute of the and_shl_scratch instruction.  */\n+\n+int\n+shl_and_scr_length (insn)\n+     rtx insn;\n+{\n+  rtx set_src = SET_SRC (XVECEXP (PATTERN (insn), 0, 0));\n+  int len = shift_insns[INTVAL (XEXP (set_src, 1))];\n+  rtx op = XEXP (set_src, 0);\n+  len += shift_insns[INTVAL (XEXP (op, 1))] + 1;\n+  op = XEXP (XEXP (op, 0), 0);\n+  return len + shift_insns[INTVAL (XEXP (op, 1))];\n+}\n+\n+/* Generating rtl? */\n+extern int rtx_equal_function_value_matters;\n+\n+/* Generate rtl for instructions for which shl_and_kind advised a particular\n+   method of generating them, i.e. returned zero.  */\n+\n+int\n+gen_shl_and (dest, left_rtx, mask_rtx, source)\n+     rtx dest, left_rtx, mask_rtx, source;\n+{\n+  int attributes[3];\n+  unsigned HOST_WIDE_INT mask;\n+  int kind = shl_and_kind (left_rtx, mask_rtx, attributes);\n+  int right, total_shift;\n+  int (*shift_gen_fun) PROTO((int, rtx*)) = gen_shifty_hi_op;\n+\n+  right = attributes[0];\n+  total_shift = INTVAL (left_rtx) + right;\n+  mask = (unsigned HOST_WIDE_INT) INTVAL (mask_rtx) >> total_shift;\n+  switch (kind)\n+    {\n+    default:\n+      return -1;\n+    case 1:\n+      {\n+\tint first = attributes[2];\n+\trtx operands[3];\n+\n+\tif (first < 0)\n+\t  {\n+\t    emit_insn ((mask << right) == 0xff\n+\t\t       ? gen_zero_extendqisi2(dest, gen_rtx (SUBREG, QImode,\n+\t\t\t\t\t\t\t     source, 0))\n+\t\t       : gen_zero_extendhisi2(dest, gen_rtx (SUBREG, HImode,\n+\t\t\t\t\t\t\t     source, 0)));\n+\t    source = dest;\n+\t  }\n+\tif (source != dest)\n+\t  emit_insn (gen_movsi (dest, source));\n+\toperands[0] = dest;\n+\tif (right)\n+\t  {\n+\t    operands[2] = GEN_INT (right);\n+\t    gen_shifty_hi_op (LSHIFTRT, operands);\n+\t  }\n+\tif (first > 0)\n+\t  {\n+\t    operands[2] = GEN_INT (first);\n+\t    gen_shifty_hi_op (ASHIFT, operands);\n+\t    total_shift -= first;\n+\t    mask <<= first;\n+\t  }\n+\tif (first >= 0)\n+\t  emit_insn (mask == 0xff\n+\t\t     ? gen_zero_extendqisi2(dest, gen_rtx (SUBREG, QImode,\n+\t\t\t\t\t\t\t   dest, 0))\n+\t\t     : gen_zero_extendhisi2(dest, gen_rtx (SUBREG, HImode,\n+\t\t\t\t\t\t\t   dest, 0)));\n+\tif (total_shift > 0)\n+\t  {\n+\t    operands[2] = GEN_INT (total_shift);\n+\t    gen_shifty_hi_op (ASHIFT, operands);\n+\t  }\n+\tbreak;\n+      }\n+    case 4:\n+      shift_gen_fun = gen_shifty_op;\n+    case 2:\n+    case 3:\n+      /* Don't expand fine-grained when combining, because that will\n+         make the pattern fail.  */\n+      if (rtx_equal_function_value_matters\n+\t  || reload_in_progress || reload_completed)\n+\t{\n+\t  rtx operands[3];\n+  \n+\t  if (right)\n+\t    {\n+\t      emit_insn (gen_lshrsi3 (dest, source, GEN_INT (right)));\n+\t      source = dest;\n+\t    }\n+\t  emit_insn (gen_andsi3 (dest, source, GEN_INT (mask)));\n+\t  operands[0] = dest;\n+\t  operands[1] = dest;\n+\t  operands[2] = GEN_INT (total_shift);\n+\t  shift_gen_fun (ASHIFT, operands);\n+\t  break;\n+\t}\n+      else\n+\t{\n+\t  int neg = 0;\n+\t  if (kind != 4 && total_shift < 16)\n+\t    {\n+\t      neg = -ext_shift_amounts[total_shift][1];\n+\t      if (neg > 0)\n+\t\tneg -= ext_shift_amounts[total_shift][2];\n+\t      else\n+\t\tneg = 0;\n+\t    }\n+\t  emit_insn (gen_and_shl_scratch (dest, source,\n+\t\t\t\t\t  GEN_INT (right),\n+\t\t\t\t\t  GEN_INT (mask),\n+\t\t\t\t\t  GEN_INT (total_shift + neg),\n+\t\t\t\t\t  GEN_INT (neg)));\n+\t  emit_insn (gen_movsi (dest, dest));\n+\t  break;\n+\t}\n+    }\n+  return 0;\n+}\n+\n+/* Try to find a good way to implement the combiner pattern\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (sign_extract:SI (ashift:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+                                    (match_operand:SI 2 \"const_int_operand\" \"n\")\n+                         (match_operand:SI 3 \"const_int_operand\" \"n\")\n+                         (const_int 0)))\n+   (clobber (reg:SI 18))]\n+  LEFT_RTX is operand 2 in the above pattern, and SIZE_RTX is operand 3.\n+  return 0 for simple left / right shift combination.\n+  return 1 for left shift / 8 bit sign extend / left shift.\n+  return 2 for left shift / 16 bit sign extend / left shift.\n+  return 3 for left shift / 8 bit sign extend / shift / sign extend.\n+  return 4 for left shift / 16 bit sign extend / shift / sign extend.\n+  return 5 for left shift / 16 bit sign extend / right shift\n+  return 6 for < 8 bit sign extend / left shift.\n+  return 7 for < 8 bit sign extend / left shift / single right shift.\n+  If COSTP is nonzero, assign the calculated cost to *COSTP.  */\n+\n+int\n+shl_sext_kind (left_rtx, size_rtx, costp)\n+     rtx left_rtx, size_rtx;\n+     int *costp;\n+{\n+  int left, size, insize, ext;\n+  int cost, best_cost;\n+  int kind;\n+\n+  left = INTVAL (left_rtx);\n+  size = INTVAL (size_rtx);\n+  insize = size - left;\n+  if (insize <= 0)\n+    abort ();\n+  /* Default to left / right shift.  */\n+  kind = 0;\n+  best_cost = shift_insns[32 - insize] + ashiftrt_insns[32 - size];\n+  if (size <= 16)\n+    {\n+      /* 16 bit shift / sign extend / 16 bit shift */\n+      cost = shift_insns[16 - insize] + 1 + ashiftrt_insns[16 - size];\n+      if (cost < best_cost)\n+\t{\n+\t  kind = 5;\n+\t  best_cost = cost;\n+\t}\n+    }\n+  /* Try a plain sign extend between two shifts.  */\n+  for (ext = 16; ext >= insize; ext -= 8)\n+    {\n+      if (ext <= size)\n+\t{\n+\t  cost = ext_shift_insns[ext - insize] + 1 + shift_insns[size - ext];\n+\t  if (cost < best_cost)\n+\t    {\n+\t      kind = ext / 8U;\n+\t      best_cost = cost;\n+\t    }\n+\t}\n+      if (size <= 16)\n+\t{\n+\t  /* Maybe it's cheaper to do the second shift sloppy, and do a\n+\t     final sign extend?  */\n+\t  cost = ext_shift_insns[ext - insize] + 1\n+\t    + ext_shift_insns[size > ext ? size - ext : ext - size] + 1;\n+\t  if (cost < best_cost)\n+\t    {\n+\t      kind = ext / 8U + 2;\n+\t      best_cost = cost;\n+\t    }\n+\t}\n+    }\n+  /* Check if we can sign extend in r0 */\n+  if (insize < 8)\n+    {\n+      cost = 3 + shift_insns[left];\n+      if (cost < best_cost)\n+\t{\n+\t  kind = 6;\n+\t  best_cost = cost;\n+\t}\n+      /* Try the same with a final signed shift.  */\n+      if (left < 31)\n+\t{\n+\t  cost = 3 + ext_shift_insns[left + 1] + 1;\n+\t  if (cost < best_cost)\n+\t    {\n+\t      kind = 7;\n+\t      best_cost = cost;\n+\t    }\n+\t}\n+    }\n+  if (TARGET_SH3)\n+    {\n+      /* Try to use a dynamic shift.  */\n+      cost = shift_insns[32 - insize] + 3;\n+      if (cost < best_cost)\n+\t{\n+\t  kind = 0;\n+\t  best_cost = cost;\n+\t}\n+    }\n+  if (costp)\n+    *costp = cost;\n+  return kind;\n+}\n+\n+/* Function to be used in the length attribute of the instructions\n+   implementing this pattern.  */\n+\n+int\n+shl_sext_length (insn)\n+     rtx insn;\n+{\n+  rtx set_src, left_rtx, size_rtx;\n+  int cost;\n+\n+  set_src = SET_SRC (XVECEXP (PATTERN (insn), 0, 0));\n+  left_rtx = XEXP (XEXP (set_src, 0), 1);\n+  size_rtx = XEXP (set_src, 1);\n+  shl_sext_kind (left_rtx, size_rtx, &cost);\n+  return cost;\n+}\n+\n+/* Generate rtl for this pattern */\n+\n+int\n+gen_shl_sext (dest, left_rtx, size_rtx, source)\n+     rtx dest, left_rtx, size_rtx, source;\n+{\n+  int kind;\n+  int left, size, insize;\n+  rtx operands[3];\n+\n+  kind = shl_sext_kind (left_rtx, size_rtx);\n+  left = INTVAL (left_rtx);\n+  size = INTVAL (size_rtx);\n+  insize = size - left;\n+  switch (kind)\n+    {\n+    case 1:\n+    case 2:\n+    case 3:\n+    case 4:\n+      {\n+\tint ext = kind & 1 ? 8 : 16;\n+\tint shift2 = size - ext;\n+\n+\t/* Don't expand fine-grained when combining, because that will\n+\t   make the pattern fail.  */\n+\tif (! rtx_equal_function_value_matters\n+\t    && ! reload_in_progress && ! reload_completed)\n+\t  {\n+\t    emit_insn (gen_shl_sext_ext (dest, source, left_rtx, size_rtx));\n+\t    emit_insn (gen_movsi (dest, source));\n+\t    break;\n+\t  }\n+\tif (dest != source)\n+\t  emit_insn (gen_movsi (dest, source));\n+\toperands[0] = dest;\n+\toperands[2] = GEN_INT (ext - insize);\n+\tgen_shifty_hi_op (ASHIFT, operands);\n+\temit_insn (kind & 1\n+\t\t   ? gen_extendqisi2(dest, gen_rtx (SUBREG, QImode, dest, 0))\n+\t\t   : gen_extendhisi2(dest, gen_rtx (SUBREG, HImode, dest, 0)));\n+\tif (kind <= 2)\n+\t  {\n+\t    operands[2] = GEN_INT (shift2);\n+\t    gen_shifty_op (ASHIFT, operands);\n+\t  }\n+\telse\n+\t  {\n+\t    if (shift2 >= 0)\n+\t      {\n+\t\toperands[2] = GEN_INT (shift2);\n+\t\tgen_shifty_hi_op (ASHIFT, operands);\n+\t      }\n+\t    else\n+\t      {\n+\t\toperands[2] = GEN_INT (-shift2);\n+\t\tgen_shifty_hi_op (LSHIFTRT, operands);\n+\t      }\n+\t    emit_insn (size <= 8\n+\t\t       ? gen_extendqisi2 (dest,\n+\t\t\t\t\t  gen_rtx (SUBREG, QImode, dest, 0))\n+\t\t       : gen_extendhisi2 (dest,\n+\t\t\t\t\t  gen_rtx (SUBREG, HImode, dest, 0)));\n+\t  }\n+\tbreak;\n+      }\n+    case 5:\n+      emit_insn (gen_shl_sext_ext (dest, source, GEN_INT (16 - insize),\n+\t\t\t\t   GEN_INT (16)));\n+      emit_insn (gen_ashrsi3 (dest, dest, GEN_INT (16 - size)));\n+      break;\n+    case 6:\n+    case 7:\n+      /* Don't expand fine-grained when combining, because that will\n+\t make the pattern fail.  */\n+      if (! rtx_equal_function_value_matters\n+\t  && ! reload_in_progress && ! reload_completed)\n+\t{\n+\t  emit_insn (gen_shl_sext_ext (dest, source, left_rtx, size_rtx));\n+\t  emit_insn (gen_movsi (dest, source));\n+\t  break;\n+\t}\n+      emit_insn (gen_andsi3 (dest, source, GEN_INT ((1 << insize) - 1)));\n+      emit_insn (gen_xorsi3 (dest, dest, GEN_INT (1 << (insize - 1))));\n+      emit_insn (gen_addsi3 (dest, dest, GEN_INT (-1 << (insize - 1))));\n+      operands[0] = dest;\n+      operands[2] = kind == 7 ? GEN_INT (left + 1) : left_rtx;\n+      gen_shifty_op (ASHIFT, operands);\n+      if (kind == 7)\n+\temit_insn (gen_ashrsi3_k (dest, dest, GEN_INT (1)));\n+      break;\n+    default:\n+      return -1;\n+    }\n+  return 0;\n+}\n \f\n /* The SH cannot load a large constant into a register, constants have to\n    come from a pc relative load.  The reference of a pc relative load"}]}