{"sha": "dec8d0e5fa00ceb2ded78b8a3eba8976d860a90e", "node_id": "C_kwDOANBUbNoAKGRlYzhkMGU1ZmEwMGNlYjJkZWQ3OGI4YTNlYmE4OTc2ZDg2MGE5MGU", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-01-27T15:56:49Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-01-27T15:56:49Z"}, "message": "c++: non-dependent immediate member fn call [PR99895]\n\nHere we're emitting a bogus error during ahead of time evaluation of a\nnon-dependent immediate member function call such as a.f(args) because\nthe defacto templated form for such a call is (a.f)(args) but we're\ntrying to evaluate it using the intermediate CALL_EXPR built by\nbuild_over_call, which has the non-member form f(a, args).  The defacto\nmember form is built in build_new_method_call, so it seems we should\nhandle the immediate call there instead, or perhaps make build_over_call\nbuild the correct form in the first place.\n\nGiiven that there are many spots other than build_new_method_call that\ncall build_over_call for member functions, e.g. build_op_call, this\npatch takes the latter approach.\n\nIn passing, this patch makes us avoid wrapping PARM_DECL in\nNON_DEPENDENT_EXPR for benefit of the third testcase below.\n\n\tPR c++/99895\n\ngcc/cp/ChangeLog:\n\n\t* call.cc (build_over_call): For a non-dependent member call,\n\tbuild up a CALL_EXPR using a COMPONENT_REF callee, as in\n\tbuild_new_method_call.\n\t* pt.cc (build_non_dependent_expr): Don't wrap PARM_DECL either.\n\t* tree.cc (build_min_non_dep_op_overload): Adjust accordingly\n\tafter the build_over_call change.\n\ngcc/ChangeLog:\n\n\t* tree.cc (build_call_vec): Add const to second parameter.\n\t* tree.h (build_call_vec): Likewise.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp2a/consteval-memfn1.C: New test.\n\t* g++.dg/cpp2a/consteval-memfn2.C: New test.\n\t* g++.dg/cpp2a/consteval28.C: New test.", "tree": {"sha": "46e912a46c6c9af56ad5822f06098a7aca16a31b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/46e912a46c6c9af56ad5822f06098a7aca16a31b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dec8d0e5fa00ceb2ded78b8a3eba8976d860a90e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dec8d0e5fa00ceb2ded78b8a3eba8976d860a90e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dec8d0e5fa00ceb2ded78b8a3eba8976d860a90e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dec8d0e5fa00ceb2ded78b8a3eba8976d860a90e/comments", "author": null, "committer": null, "parents": [{"sha": "ce6054a22ae14594a2919d2ad87cd9478e616fb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce6054a22ae14594a2919d2ad87cd9478e616fb3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce6054a22ae14594a2919d2ad87cd9478e616fb3"}], "stats": {"total": 124, "additions": 94, "deletions": 30}, "files": [{"sha": "b2e89c5d783aad377095735fe8afd31567abc5af", "filename": "gcc/cp/call.cc", "status": "modified", "additions": 14, "deletions": 24, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dec8d0e5fa00ceb2ded78b8a3eba8976d860a90e/gcc%2Fcp%2Fcall.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dec8d0e5fa00ceb2ded78b8a3eba8976d860a90e/gcc%2Fcp%2Fcall.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.cc?ref=dec8d0e5fa00ceb2ded78b8a3eba8976d860a90e", "patch": "@@ -9204,44 +9204,34 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n      errors will be deferred until the template is instantiated.  */\n   if (processing_template_decl)\n     {\n-      tree expr, addr;\n-      tree return_type;\n-      const tree *argarray;\n-      unsigned int nargs;\n-\n       if (undeduced_auto_decl (fn))\n \tmark_used (fn, complain);\n       else\n \t/* Otherwise set TREE_USED for the benefit of -Wunused-function.\n \t   See PR80598.  */\n \tTREE_USED (fn) = 1;\n \n-      return_type = TREE_TYPE (TREE_TYPE (fn));\n-      nargs = vec_safe_length (args);\n+      tree return_type = TREE_TYPE (TREE_TYPE (fn));\n+      tree callee;\n       if (first_arg == NULL_TREE)\n-\targarray = args->address ();\n+\t{\n+\t  callee = build_addr_func (fn, complain);\n+\t  if (callee == error_mark_node)\n+\t    return error_mark_node;\n+\t}\n       else\n \t{\n-\t  tree *alcarray;\n-\t  unsigned int ix;\n-\t  tree arg;\n-\n-\t  ++nargs;\n-\t  alcarray = XALLOCAVEC (tree, nargs);\n-\t  alcarray[0] = build_this (first_arg);\n-\t  FOR_EACH_VEC_SAFE_ELT (args, ix, arg)\n-\t    alcarray[ix + 1] = arg;\n-\t  argarray = alcarray;\n+\t  tree binfo = TYPE_BINFO (TREE_TYPE (first_arg));\n+\t  callee = build_baselink (binfo, binfo, fn, NULL_TREE);\n+\t  callee = build_min (COMPONENT_REF, TREE_TYPE (fn),\n+\t\t\t      first_arg, callee, NULL_TREE);\n \t}\n \n-      addr = build_addr_func (fn, complain);\n-      if (addr == error_mark_node)\n-\treturn error_mark_node;\n-      expr = build_call_array_loc (input_location, return_type,\n-\t\t\t\t   addr, nargs, argarray);\n+      tree expr = build_call_vec (return_type, callee, args);\n+      SET_EXPR_LOCATION (expr, input_location);\n       if (TREE_THIS_VOLATILE (fn) && cfun)\n \tcurrent_function_returns_abnormally = 1;\n-      if (immediate_invocation_p (fn, nargs))\n+      if (immediate_invocation_p (fn, vec_safe_length (args)))\n \t{\n \t  tree obj_arg = NULL_TREE, exprimm = expr;\n \t  if (DECL_CONSTRUCTOR_P (fn))"}, {"sha": "19e73b3b77d6c7b48d90a64d62ed43e436c307d6", "filename": "gcc/cp/pt.cc", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dec8d0e5fa00ceb2ded78b8a3eba8976d860a90e/gcc%2Fcp%2Fpt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dec8d0e5fa00ceb2ded78b8a3eba8976d860a90e/gcc%2Fcp%2Fpt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.cc?ref=dec8d0e5fa00ceb2ded78b8a3eba8976d860a90e", "patch": "@@ -28410,8 +28410,10 @@ build_non_dependent_expr (tree expr)\n   if (is_overloaded_fn (inner_expr)\n       || TREE_CODE (inner_expr) == OFFSET_REF)\n     return orig_expr;\n-  /* There is no need to return a proxy for a variable or enumerator.  */\n-  if (VAR_P (expr) || TREE_CODE (expr) == CONST_DECL)\n+  /* There is no need to return a proxy for a variable, parameter\n+     or enumerator.  */\n+  if (VAR_P (expr) || TREE_CODE (expr) == PARM_DECL\n+      || TREE_CODE (expr) == CONST_DECL)\n     return orig_expr;\n   /* Preserve string constants; conversions from string constants to\n      \"char *\" are allowed, even though normally a \"const char *\""}, {"sha": "056f10f13b4370188e25b0d9d6c6fe5ce6a35d13", "filename": "gcc/cp/tree.cc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dec8d0e5fa00ceb2ded78b8a3eba8976d860a90e/gcc%2Fcp%2Ftree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dec8d0e5fa00ceb2ded78b8a3eba8976d860a90e/gcc%2Fcp%2Ftree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.cc?ref=dec8d0e5fa00ceb2ded78b8a3eba8976d860a90e", "patch": "@@ -3661,6 +3661,8 @@ build_min_non_dep_op_overload (enum tree_code op,\n   nargs = call_expr_nargs (non_dep);\n \n   expected_nargs = cp_tree_code_length (op);\n+  if (TREE_CODE (TREE_TYPE (overload)) == METHOD_TYPE)\n+    expected_nargs -= 1;\n   if ((op == POSTINCREMENT_EXPR\n        || op == POSTDECREMENT_EXPR)\n       /* With -fpermissive non_dep could be operator++().  */\n@@ -3687,7 +3689,7 @@ build_min_non_dep_op_overload (enum tree_code op,\n       tree method = build_baselink (binfo, binfo, overload, NULL_TREE);\n       fn = build_min (COMPONENT_REF, TREE_TYPE (overload),\n \t\t      object, method, NULL_TREE);\n-      for (int i = 1; i < nargs; i++)\n+      for (int i = 0; i < nargs; i++)\n \t{\n \t  tree arg = va_arg (p, tree);\n \t  vec_safe_push (args, arg);\n@@ -3723,7 +3725,6 @@ build_min_non_dep_op_overload (tree non_dep, tree overload, tree object,\n   tree method = build_baselink (binfo, binfo, overload, NULL_TREE);\n   tree fn = build_min (COMPONENT_REF, TREE_TYPE (overload),\n \t\t       object, method, NULL_TREE);\n-  nargs--;\n   gcc_assert (vec_safe_length (args) == nargs);\n \n   tree call = build_min_non_dep_call_vec (non_dep, fn, args);"}, {"sha": "910e7a1ac1e4823e204ae495d6d36f4b264c1d99", "filename": "gcc/testsuite/g++.dg/cpp2a/consteval-memfn1.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dec8d0e5fa00ceb2ded78b8a3eba8976d860a90e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconsteval-memfn1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dec8d0e5fa00ceb2ded78b8a3eba8976d860a90e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconsteval-memfn1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconsteval-memfn1.C?ref=dec8d0e5fa00ceb2ded78b8a3eba8976d860a90e", "patch": "@@ -0,0 +1,27 @@\n+// PR c++/99895\n+// { dg-do compile { target c++20 } }\n+\n+struct fixed_string {\n+  consteval int size(int n) const {\n+    if (n < 0) throw; // { dg-error \"not a constant\" }\n+    return n;\n+  }\n+\n+  static consteval int size_static(int n) {\n+    if (n < 0) throw; // { dg-error \"not a constant\" }\n+    return n;\n+  }\n+\n+  consteval void operator()() const { }\n+};\n+\n+template<class>\n+void VerifyHash(fixed_string s) {\n+  s.size(0); // { dg-bogus \"\" }\n+  s.size(-1); // { dg-message \"expansion of\" }\n+  s.size_static(0); // { dg-bogus \"\" }\n+  s.size_static(-1); // { dg-message \"expansion of\" }\n+  fixed_string::size_static(0); // { dg-bogus \"\" }\n+  fixed_string::size_static(-1); // { dg-message \"expansion of\" }\n+  s(); // { dg-bogus \"\" }\n+}"}, {"sha": "71748f46b13330b2b7b2cd0dadf75b474c96a09f", "filename": "gcc/testsuite/g++.dg/cpp2a/consteval-memfn2.C", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dec8d0e5fa00ceb2ded78b8a3eba8976d860a90e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconsteval-memfn2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dec8d0e5fa00ceb2ded78b8a3eba8976d860a90e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconsteval-memfn2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconsteval-memfn2.C?ref=dec8d0e5fa00ceb2ded78b8a3eba8976d860a90e", "patch": "@@ -0,0 +1,34 @@\n+// PR c++/99895\n+// { dg-do compile { target c++20 } }\n+\n+static constexpr unsigned hash(const char* s, unsigned length)\n+{\n+    s=s;\n+    return length;\n+}\n+template<unsigned N>\n+struct fixed_string\n+{\n+    constexpr fixed_string(const char (&s)[N])\n+    {\n+        for (int i = 0; i < N; i++)\n+            str[i] = s[i];\n+    }\n+    consteval const char* data() const { return str; }\n+    consteval unsigned size() const { return N-1; }\n+    char str[N];\n+};\n+template<unsigned expected_hash, fixed_string... s>\n+static consteval void VerifyHash()\n+{\n+    (\n+      [](auto){static_assert(hash(s.data(), s.size()) == expected_hash);}(s)\n+    ,...);\n+    // The compiler mistakenly translates s.data() into s.data(&s)\n+    // and then complains that the call is not valid, because\n+    // the function expects 0 parameters and 1 \"was provided\".\n+}\n+void foo()\n+{\n+    VerifyHash<5, \"khaki\", \"plums\">();\n+}"}, {"sha": "293a6be2fc50743b9e9545d41c80f19798e6131b", "filename": "gcc/testsuite/g++.dg/cpp2a/consteval28.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dec8d0e5fa00ceb2ded78b8a3eba8976d860a90e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconsteval28.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dec8d0e5fa00ceb2ded78b8a3eba8976d860a90e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconsteval28.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconsteval28.C?ref=dec8d0e5fa00ceb2ded78b8a3eba8976d860a90e", "patch": "@@ -0,0 +1,10 @@\n+// { dg-do compile { target c++20 } }\n+\n+struct empty { };\n+\n+consteval void f(empty) { }\n+\n+template<class>\n+void g(empty e) {\n+  f(e);\n+}"}, {"sha": "9d445b2740f59278bf76a38c67a84d3425e93aff", "filename": "gcc/tree.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dec8d0e5fa00ceb2ded78b8a3eba8976d860a90e/gcc%2Ftree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dec8d0e5fa00ceb2ded78b8a3eba8976d860a90e/gcc%2Ftree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.cc?ref=dec8d0e5fa00ceb2ded78b8a3eba8976d860a90e", "patch": "@@ -10492,7 +10492,7 @@ build_call_array_loc (location_t loc, tree return_type, tree fn,\n /* Like build_call_array, but takes a vec.  */\n \n tree\n-build_call_vec (tree return_type, tree fn, vec<tree, va_gc> *args)\n+build_call_vec (tree return_type, tree fn, const vec<tree, va_gc> *args)\n {\n   tree ret, t;\n   unsigned int ix;"}, {"sha": "4c01d94244ef8badebf1e6cf76be15ac72550f8a", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dec8d0e5fa00ceb2ded78b8a3eba8976d860a90e/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dec8d0e5fa00ceb2ded78b8a3eba8976d860a90e/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=dec8d0e5fa00ceb2ded78b8a3eba8976d860a90e", "patch": "@@ -4589,7 +4589,7 @@ extern tree build_call_valist (tree, tree, int, va_list);\n #define build_call_array(T1,T2,N,T3)\\\n    build_call_array_loc (UNKNOWN_LOCATION, T1, T2, N, T3)\n extern tree build_call_array_loc (location_t, tree, tree, int, const tree *);\n-extern tree build_call_vec (tree, tree, vec<tree, va_gc> *);\n+extern tree build_call_vec (tree, tree, const vec<tree, va_gc> *);\n extern tree build_call_expr_loc_array (location_t, tree, int, tree *);\n extern tree build_call_expr_loc_vec (location_t, tree, vec<tree, va_gc> *);\n extern tree build_call_expr_loc (location_t, tree, int, ...);"}]}