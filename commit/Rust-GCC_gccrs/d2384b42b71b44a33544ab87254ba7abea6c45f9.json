{"sha": "d2384b42b71b44a33544ab87254ba7abea6c45f9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDIzODRiNDJiNzFiNDRhMzM1NDRhYjg3MjU0YmE3YWJlYTZjNDVmOQ==", "commit": {"author": {"name": "Zoltan Hidvegi", "email": "hzoli@hzoli.2y.net", "date": "2001-11-30T23:27:52Z"}, "committer": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "2001-11-30T23:27:52Z"}, "message": "* unroll.c (unroll_loop): Correct special exit cases.\n\nFrom-SVN: r47499", "tree": {"sha": "d95f24ee811f21b2743ece3e6720b2fd527d36e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d95f24ee811f21b2743ece3e6720b2fd527d36e1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d2384b42b71b44a33544ab87254ba7abea6c45f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2384b42b71b44a33544ab87254ba7abea6c45f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2384b42b71b44a33544ab87254ba7abea6c45f9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2384b42b71b44a33544ab87254ba7abea6c45f9/comments", "author": null, "committer": null, "parents": [{"sha": "38875aba474d312aa737aec754d70cf690e6ae25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38875aba474d312aa737aec754d70cf690e6ae25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38875aba474d312aa737aec754d70cf690e6ae25"}], "stats": {"total": 45, "additions": 36, "deletions": 9}, "files": [{"sha": "b077028e7bac04bcf3e36a63edf16a5f44e87b86", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2384b42b71b44a33544ab87254ba7abea6c45f9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2384b42b71b44a33544ab87254ba7abea6c45f9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d2384b42b71b44a33544ab87254ba7abea6c45f9", "patch": "@@ -1,3 +1,7 @@\n+2001-11-30  Zoltan Hidvegi <hzoli@hzoli.2y.net>\n+\n+\t* unroll.c (unroll_loop): Correct special exit cases.\n+\n 2001-11-30  Stephane Carrez  <Stephane.Carrez@sun.com>\n \n \t* config/sparc/sparc.c (DF_MODES_NO_S): Fix pr/3623, define to"}, {"sha": "b66916e320b88db5f2dcde90cbda6afba7b4ebbc", "filename": "gcc/unroll.c", "status": "modified", "additions": 32, "deletions": 9, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2384b42b71b44a33544ab87254ba7abea6c45f9/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2384b42b71b44a33544ab87254ba7abea6c45f9/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=d2384b42b71b44a33544ab87254ba7abea6c45f9", "patch": "@@ -901,6 +901,9 @@ unroll_loop (loop, insn_count, strength_reduce_p)\n \t  rtx diff;\n \t  rtx *labels;\n \t  int abs_inc, neg_inc;\n+\t  enum rtx_code cc = loop_info->comparison_code;\n+\t  int less_p     = (cc == LE  || cc == LEU || cc == LT  || cc == LTU);\n+\t  int unsigned_p = (cc == LEU || cc == GEU || cc == LTU || cc == GTU);\n \n \t  map->reg_map = (rtx *) xmalloc (maxregnum * sizeof (rtx));\n \n@@ -933,11 +936,25 @@ unroll_loop (loop, insn_count, strength_reduce_p)\n \t     a constant.\n \n \t     We must copy the final and initial values here to avoid\n-\t     improperly shared rtl.  */\n-\n-\t  diff = expand_simple_binop (mode, MINUS, copy_rtx (final_value),\n-\t\t\t\t      copy_rtx (initial_value), NULL_RTX, 0,\n-\t\t\t\t      OPTAB_LIB_WIDEN);\n+\t     improperly shared rtl.\n+\n+\t     We have to deal with for (i = 0; --i < 6;) type loops.\n+\t     For such loops the real final value is the first time the\n+\t     loop variable overflows, so the diff we calculate is the\n+\t     distance from the overflow value.  This is 0 or ~0 for\n+\t     unsigned loops depending on the direction, or INT_MAX,\n+\t     INT_MAX+1 for signed loops.  We really do not need the\n+\t     exact value, since we are only interested in the diff\n+\t     modulo the increment, and the increment is a power of 2,\n+\t     so we can pretend that the overflow value is 0/~0.  */\n+\n+\t  if (cc == NE || less_p != neg_inc)\n+\t    diff = expand_simple_binop (mode, MINUS, copy_rtx (final_value),\n+\t\t\t\t\tcopy_rtx (initial_value), NULL_RTX, 0,\n+\t\t\t\t\tOPTAB_LIB_WIDEN);\n+\t  else\n+\t    diff = expand_simple_unop (mode, neg_inc ? NOT : NEG,\n+\t\t\t\t       copy_rtx (initial_value), NULL_RTX, 0);\n \n \t  /* Now calculate (diff % (unroll * abs (increment))) by using an\n \t     and instruction.  */\n@@ -958,11 +975,17 @@ unroll_loop (loop, insn_count, strength_reduce_p)\n \t     case.  This check does not apply if the loop has a NE\n \t     comparison at the end.  */\n \n-\t  if (loop_info->comparison_code != NE)\n+\t  if (cc != NE)\n \t    {\n-\t      emit_cmp_and_jump_insns (initial_value, final_value,\n-\t\t\t\t       neg_inc ? LE : GE,\n-\t\t\t\t       NULL_RTX, mode, 0, labels[1]);\n+\t      rtx incremented_initval;\n+\t      incremented_initval = expand_simple_binop (mode, PLUS,\n+\t\t\t\t\t\t\t initial_value,\n+\t\t\t\t\t\t\t increment,\n+\t\t\t\t\t\t\t NULL_RTX, 0,\n+\t\t\t\t\t\t\t OPTAB_LIB_WIDEN);\n+\t      emit_cmp_and_jump_insns (incremented_initval, final_value,\n+\t\t\t\t       less_p ? GE : LE, NULL_RTX,\n+\t\t\t\t       mode, unsigned_p, labels[1]);\n \t      predict_insn_def (get_last_insn (), PRED_LOOP_CONDITION,\n \t\t\t\tNOT_TAKEN);\n \t      JUMP_LABEL (get_last_insn ()) = labels[1];"}]}