{"sha": "c128599ae188817b56a12c373fde7a5a4f309976", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzEyODU5OWFlMTg4ODE3YjU2YTEyYzM3M2ZkZTdhNWE0ZjMwOTk3Ng==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2009-05-15T18:08:10Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2009-05-15T18:08:10Z"}, "message": "builtins.c (do_mpc_arg1, [...]): New.\n\n\t* builtins.c (do_mpc_arg1, fold_builtin_ccos): New.\n\t(fold_builtin_cexp): Ensure we get a complex REAL_TYPE.\n\tEvaluate constant arguments.\n\t(fold_builtin_carg): Ensure we get a complex REAL_TYPE.\n\t(fold_builtin_1): Likewise, also evaluate constant arguments.\n\tRemove superfluous break.\n\t(do_mpc_ckconv): New.\n\t* real.h: Include mpc.h.\n\t* toplev.c (print_version): Output MPC version info if available.\n\nFrom-SVN: r147591", "tree": {"sha": "d071f09b549350c8254096c5a5fc4f7fd1817db2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d071f09b549350c8254096c5a5fc4f7fd1817db2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c128599ae188817b56a12c373fde7a5a4f309976", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c128599ae188817b56a12c373fde7a5a4f309976", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c128599ae188817b56a12c373fde7a5a4f309976", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c128599ae188817b56a12c373fde7a5a4f309976/comments", "author": null, "committer": null, "parents": [{"sha": "d33e4b70f65df2876f67172944512b9d3356169f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d33e4b70f65df2876f67172944512b9d3356169f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d33e4b70f65df2876f67172944512b9d3356169f"}], "stats": {"total": 226, "additions": 211, "deletions": 15}, "files": [{"sha": "2b944bc0cf8ffe3eac8f985c985375b1507204e6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c128599ae188817b56a12c373fde7a5a4f309976/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c128599ae188817b56a12c373fde7a5a4f309976/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c128599ae188817b56a12c373fde7a5a4f309976", "patch": "@@ -1,3 +1,15 @@\n+2009-05-15  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* builtins.c (do_mpc_arg1, fold_builtin_ccos): New.\n+\t(fold_builtin_cexp): Ensure we get a complex REAL_TYPE.\n+\tEvaluate constant arguments.\n+\t(fold_builtin_carg): Ensure we get a complex REAL_TYPE.\n+\t(fold_builtin_1): Likewise, also evaluate constant arguments.\n+\tRemove superfluous break.\n+\t(do_mpc_ckconv): New.\n+\t* real.h: Include mpc.h.\n+\t* toplev.c (print_version): Output MPC version info if available.\n+\n 2009-05-15  Sandra Loosemore  <sandra@codesourcery.com>\n \n \t* fold-const.c (fold_convert_const_real_from_real): Check for"}, {"sha": "b704394f31e4ef3d618579ec44634d7cbde357f8", "filename": "gcc/builtins.c", "status": "modified", "additions": 178, "deletions": 13, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c128599ae188817b56a12c373fde7a5a4f309976/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c128599ae188817b56a12c373fde7a5a4f309976/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=c128599ae188817b56a12c373fde7a5a4f309976", "patch": "@@ -58,6 +58,9 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef PAD_VARARGS_DOWN\n #define PAD_VARARGS_DOWN BYTES_BIG_ENDIAN\n #endif\n+#ifdef HAVE_mpc\n+static tree do_mpc_arg1 (tree, tree, int (*)(mpc_ptr, mpc_srcptr, mpc_rnd_t));\n+#endif\n \n /* Define the names of the builtin function types and codes.  */\n const char *const built_in_class_names[4]\n@@ -7886,6 +7889,33 @@ fold_builtin_cosh (tree arg, tree type, tree fndecl)\n   return NULL_TREE;\n }\n \n+/* Fold function call to builtin ccos (or ccosh if HYPER is TRUE) with\n+   argument ARG.  TYPE is the type of the return value.  Return\n+   NULL_TREE if no simplification can be made.  */\n+\n+static tree\n+fold_builtin_ccos (tree arg, tree type ATTRIBUTE_UNUSED, tree fndecl,\n+\t\t   bool hyper ATTRIBUTE_UNUSED)\n+{\n+  if (validate_arg (arg, COMPLEX_TYPE)\n+      && TREE_CODE (TREE_TYPE (TREE_TYPE (arg))) == REAL_TYPE)\n+    {\n+      tree tmp;\n+\n+#ifdef HAVE_mpc\n+      /* Calculate the result when the argument is a constant.  */\n+      if ((tmp = do_mpc_arg1 (arg, type, (hyper ? mpc_cosh : mpc_cos))))\n+\treturn tmp;\n+#endif\n+  \n+      /* Optimize fn(-x) into fn(x).  */\n+      if ((tmp = fold_strip_sign_ops (arg)))\n+\treturn build_call_expr (fndecl, 1, tmp);\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n /* Fold function call to builtin tan, tanf, or tanl with argument ARG.\n    Return NULL_TREE if no simplification can be made.  */\n \n@@ -7960,10 +7990,20 @@ fold_builtin_cexp (tree arg0, tree type)\n {\n   tree rtype;\n   tree realp, imagp, ifn;\n+#ifdef HAVE_mpc\n+  tree res;\n+#endif\n \n-  if (!validate_arg (arg0, COMPLEX_TYPE))\n+  if (!validate_arg (arg0, COMPLEX_TYPE)\n+      && TREE_CODE (TREE_TYPE (TREE_TYPE (arg0))) == REAL_TYPE)\n     return NULL_TREE;\n \n+#ifdef HAVE_mpc\n+  /* Calculate the result when the argument is a constant.  */\n+  if ((res = do_mpc_arg1 (arg0, type, mpc_exp)))\n+    return res;\n+#endif\n+  \n   rtype = TREE_TYPE (TREE_TYPE (arg0));\n \n   /* In case we can figure out the real part of arg0 and it is constant zero\n@@ -9670,7 +9710,8 @@ fold_builtin_fmin_fmax (tree arg0, tree arg1, tree type, bool max)\n static tree\n fold_builtin_carg (tree arg, tree type)\n {\n-  if (validate_arg (arg, COMPLEX_TYPE))\n+  if (validate_arg (arg, COMPLEX_TYPE)\n+      && TREE_CODE (TREE_TYPE (TREE_TYPE (arg))) == REAL_TYPE)\n     {\n       tree atan2_fn = mathfn_built_in (type, BUILT_IN_ATAN2);\n       \n@@ -10215,12 +10256,14 @@ fold_builtin_1 (tree fndecl, tree arg0, bool ignore)\n       return fold_builtin_abs (arg0, type);\n \n     CASE_FLT_FN (BUILT_IN_CONJ):\n-      if (validate_arg (arg0, COMPLEX_TYPE))\n+      if (validate_arg (arg0, COMPLEX_TYPE)\n+\t&& TREE_CODE (TREE_TYPE (TREE_TYPE (arg0))) == REAL_TYPE) \n \treturn fold_build1 (CONJ_EXPR, type, arg0);\n     break;\n \n     CASE_FLT_FN (BUILT_IN_CREAL):\n-      if (validate_arg (arg0, COMPLEX_TYPE))\n+      if (validate_arg (arg0, COMPLEX_TYPE)\n+\t&& TREE_CODE (TREE_TYPE (TREE_TYPE (arg0))) == REAL_TYPE) \n \treturn non_lvalue (fold_build1 (REALPART_EXPR, type, arg0));;\n     break;\n \n@@ -10230,16 +10273,49 @@ fold_builtin_1 (tree fndecl, tree arg0, bool ignore)\n     break;\n \n     CASE_FLT_FN (BUILT_IN_CCOS):\n+      return fold_builtin_ccos(arg0, type, fndecl, /*hyper=*/ false);\n+    \n     CASE_FLT_FN (BUILT_IN_CCOSH):\n-      /* These functions are \"even\", i.e. f(x) == f(-x).  */\n-      if (validate_arg (arg0, COMPLEX_TYPE))\n-\t{\n-\t  tree narg = fold_strip_sign_ops (arg0);\n-\t  if (narg)\n-\t    return build_call_expr (fndecl, 1, narg);\n-\t}\n+      return fold_builtin_ccos(arg0, type, fndecl, /*hyper=*/ true);\n+    \n+#ifdef HAVE_mpc\n+    CASE_FLT_FN (BUILT_IN_CSIN):\n+      if (validate_arg (arg0, COMPLEX_TYPE)\n+\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (arg0))) == REAL_TYPE) \n+\treturn do_mpc_arg1 (arg0, type, mpc_sin);\n     break;\n-\n+    \n+    CASE_FLT_FN (BUILT_IN_CSINH):\n+      if (validate_arg (arg0, COMPLEX_TYPE)\n+\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (arg0))) == REAL_TYPE) \n+\treturn do_mpc_arg1 (arg0, type, mpc_sinh);\n+    break;\n+    \n+    CASE_FLT_FN (BUILT_IN_CTAN):\n+      if (validate_arg (arg0, COMPLEX_TYPE)\n+\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (arg0))) == REAL_TYPE) \n+\treturn do_mpc_arg1 (arg0, type, mpc_tan);\n+    break;\n+    \n+    CASE_FLT_FN (BUILT_IN_CTANH):\n+      if (validate_arg (arg0, COMPLEX_TYPE)\n+\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (arg0))) == REAL_TYPE) \n+\treturn do_mpc_arg1 (arg0, type, mpc_tanh);\n+    break;\n+    \n+    CASE_FLT_FN (BUILT_IN_CLOG):\n+      if (validate_arg (arg0, COMPLEX_TYPE)\n+\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (arg0))) == REAL_TYPE) \n+\treturn do_mpc_arg1 (arg0, type, mpc_log);\n+    break;\n+    \n+    CASE_FLT_FN (BUILT_IN_CSQRT):\n+      if (validate_arg (arg0, COMPLEX_TYPE)\n+\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (arg0))) == REAL_TYPE) \n+\treturn do_mpc_arg1 (arg0, type, mpc_sqrt);\n+    break;\n+#endif\n+    \n     CASE_FLT_FN (BUILT_IN_CABS):\n       return fold_builtin_cabs (arg0, type, fndecl);\n \n@@ -10293,7 +10369,6 @@ fold_builtin_1 (tree fndecl, tree arg0, bool ignore)\n \n     CASE_FLT_FN (BUILT_IN_COS):\n       return fold_builtin_cos (arg0, type, fndecl);\n-    break;\n \n     CASE_FLT_FN (BUILT_IN_TAN):\n       return fold_builtin_tan (arg0, type);\n@@ -13127,6 +13202,50 @@ do_mpfr_ckconv (mpfr_srcptr m, tree type, int inexact)\n   return NULL_TREE;\n }\n \n+#ifdef HAVE_mpc\n+/* Helper function for do_mpc_arg*().  Ensure M is a normal complex\n+   number and no overflow/underflow occurred.  INEXACT is true if M\n+   was not exactly calculated.  TYPE is the tree type for the result.\n+   This function assumes that you cleared the MPFR flags and then\n+   calculated M to see if anything subsequently set a flag prior to\n+   entering this function.  Return NULL_TREE if any checks fail.  */\n+\n+static tree\n+do_mpc_ckconv (mpc_srcptr m, tree type, int inexact)\n+{\n+  /* Proceed iff we get a normal number, i.e. not NaN or Inf and no\n+     overflow/underflow occurred.  If -frounding-math, proceed iff the\n+     result of calling FUNC was exact.  */\n+  if (mpfr_number_p (MPC_RE (m)) && mpfr_number_p (MPC_IM (m))\n+      && !mpfr_overflow_p () && !mpfr_underflow_p ()\n+      && (!flag_rounding_math || !inexact))\n+    {\n+      REAL_VALUE_TYPE re, im;\n+\n+      real_from_mpfr (&re, MPC_RE (m), type, GMP_RNDN);\n+      real_from_mpfr (&im, MPC_IM (m), type, GMP_RNDN);\n+      /* Proceed iff GCC's REAL_VALUE_TYPE can hold the MPFR values,\n+\t check for overflow/underflow.  If the REAL_VALUE_TYPE is zero\n+\t but the mpft_t is not, then we underflowed in the\n+\t conversion.  */\n+      if (real_isfinite (&re) && real_isfinite (&im)\n+\t  && (re.cl == rvc_zero) == (mpfr_zero_p (MPC_RE (m)) != 0)\n+\t  && (im.cl == rvc_zero) == (mpfr_zero_p (MPC_IM (m)) != 0))\n+        {\n+\t  REAL_VALUE_TYPE re_mode, im_mode;\n+\n+\t  real_convert (&re_mode, TYPE_MODE (TREE_TYPE (type)), &re);\n+\t  real_convert (&im_mode, TYPE_MODE (TREE_TYPE (type)), &im);\n+\t  /* Proceed iff the specified mode can hold the value.  */\n+\t  if (real_identical (&re_mode, &re) && real_identical (&im_mode, &im))\n+\t    return build_complex (type, build_real (TREE_TYPE (type), re_mode),\n+\t\t\t\t  build_real (TREE_TYPE (type), im_mode));\n+\t}\n+    }\n+  return NULL_TREE;\n+}\n+#endif /* HAVE_mpc */\n+\n /* If argument ARG is a REAL_CST, call the one-argument mpfr function\n    FUNC on it and return the resulting value as a tree with type TYPE.\n    If MIN and/or MAX are not NULL, then the supplied ARG must be\n@@ -13523,6 +13642,52 @@ do_mpfr_lgamma_r (tree arg, tree arg_sg, tree type)\n   return result;\n }\n \n+#ifdef HAVE_mpc\n+/* If argument ARG is a COMPLEX_CST, call the one-argument mpc\n+   function FUNC on it and return the resulting value as a tree with\n+   type TYPE.  The mpfr precision is set to the precision of TYPE.  We\n+   assume that function FUNC returns zero if the result could be\n+   calculated exactly within the requested precision.  */\n+\n+static tree\n+do_mpc_arg1 (tree arg, tree type, int (*func)(mpc_ptr, mpc_srcptr, mpc_rnd_t))\n+{\n+  tree result = NULL_TREE;\n+  \n+  STRIP_NOPS (arg);\n+\n+  /* To proceed, MPFR must exactly represent the target floating point\n+     format, which only happens when the target base equals two.  */\n+  if (TREE_CODE (arg) == COMPLEX_CST && !TREE_OVERFLOW (arg)\n+      && TREE_CODE (TREE_TYPE (TREE_TYPE (arg))) == REAL_TYPE\n+      && REAL_MODE_FORMAT (TYPE_MODE (TREE_TYPE (TREE_TYPE (arg))))->b == 2)\n+    {\n+      const REAL_VALUE_TYPE *const re = TREE_REAL_CST_PTR (TREE_REALPART (arg));\n+      const REAL_VALUE_TYPE *const im = TREE_REAL_CST_PTR (TREE_IMAGPART (arg));\n+\n+      if (real_isfinite (re) && real_isfinite (im))\n+        {\n+\t  const struct real_format *const fmt =\n+\t    REAL_MODE_FORMAT (TYPE_MODE (TREE_TYPE (type)));\n+\t  const int prec = fmt->p;\n+\t  const mp_rnd_t rnd = fmt->round_towards_zero ? GMP_RNDZ : GMP_RNDN;\n+\t  int inexact;\n+\t  mpc_t m;\n+\t  \n+\t  mpc_init2 (m, prec);\n+\t  mpfr_from_real (MPC_RE(m), re, rnd);\n+\t  mpfr_from_real (MPC_IM(m), im, rnd);\n+\t  mpfr_clear_flags ();\n+\t  inexact = func (m, m, rnd);\n+\t  result = do_mpc_ckconv (m, type, inexact);\n+\t  mpc_clear (m);\n+\t}\n+    }\n+\n+  return result;\n+}\n+#endif /* HAVE_mpc */\n+\n /* FIXME tuples.\n    The functions below provide an alternate interface for folding\n    builtin function calls presented as GIMPLE_CALL statements rather"}, {"sha": "0fc915cae5b7c968a1a88f52eb3cd906cd93e7f1", "filename": "gcc/real.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c128599ae188817b56a12c373fde7a5a4f309976/gcc%2Freal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c128599ae188817b56a12c373fde7a5a4f309976/gcc%2Freal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.h?ref=c128599ae188817b56a12c373fde7a5a4f309976", "patch": "@@ -24,6 +24,9 @@\n #ifndef GENERATOR_FILE\n #include <gmp.h>\n #include <mpfr.h>\n+#ifdef HAVE_mpc\n+#include <mpc.h>\n+#endif\n #endif\n #include \"machmode.h\"\n "}, {"sha": "346887b51539694108b770fcb3bcbf1408f0c2b0", "filename": "gcc/toplev.c", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c128599ae188817b56a12c373fde7a5a4f309976/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c128599ae188817b56a12c373fde7a5a4f309976/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=c128599ae188817b56a12c373fde7a5a4f309976", "patch": "@@ -1170,8 +1170,13 @@ print_version (FILE *file, const char *indent)\n     N_(\"%s%s%s %sversion %s (%s) compiled by CC, \")\n #endif\n     ;\n+#ifdef HAVE_mpc\n   static const char fmt2[] =\n-    N_(\"GMP version %s, MPFR version %s.\\n\");\n+    N_(\"GMP version %s, MPFR version %s, MPC version %s\\n\");\n+#else\n+  static const char fmt2[] =\n+    N_(\"GMP version %s, MPFR version %s\\n\");\n+#endif\n   static const char fmt3[] =\n     N_(\"%s%swarning: %s header version %s differs from library version %s.\\n\");\n   static const char fmt4[] =\n@@ -1203,7 +1208,11 @@ print_version (FILE *file, const char *indent)\n #endif\n   fprintf (file,\n \t   file == stderr ? _(fmt2) : fmt2,\n-\t   GCC_GMP_STRINGIFY_VERSION, MPFR_VERSION_STRING);\n+\t   GCC_GMP_STRINGIFY_VERSION, MPFR_VERSION_STRING\n+#ifdef HAVE_mpc\n+\t   , MPC_VERSION_STRING\n+#endif\n+\t   );\n   if (strcmp (GCC_GMP_STRINGIFY_VERSION, gmp_version))\n     fprintf (file,\n \t     file == stderr ? _(fmt3) : fmt3,\n@@ -1214,6 +1223,13 @@ print_version (FILE *file, const char *indent)\n \t     file == stderr ? _(fmt3) : fmt3,\n \t     indent, *indent != 0 ? \" \" : \"\",\n \t     \"MPFR\", MPFR_VERSION_STRING, mpfr_get_version ());\n+#ifdef HAVE_mpc\n+  if (strcmp (MPC_VERSION_STRING, mpc_get_version ()))\n+    fprintf (file,\n+\t     file == stderr ? _(fmt3) : fmt3,\n+\t     indent, *indent != 0 ? \" \" : \"\",\n+\t     \"MPC\", MPC_VERSION_STRING, mpc_get_version ());\n+#endif\n   fprintf (file,\n \t   file == stderr ? _(fmt4) : fmt4,\n \t   indent, *indent != 0 ? \" \" : \"\","}]}