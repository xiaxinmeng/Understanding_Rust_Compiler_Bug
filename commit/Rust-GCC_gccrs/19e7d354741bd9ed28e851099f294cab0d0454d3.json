{"sha": "19e7d354741bd9ed28e851099f294cab0d0454d3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTllN2QzNTQ3NDFiZDllZDI4ZTg1MTA5OWYyOTRjYWIwZDA0NTRkMw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-10-10T21:10:19Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-10-10T21:10:19Z"}, "message": "(save_tree_status): Function_maybepermanent_obstack is the function_obstack of parent function.\n\n(save_tree_status): Function_maybepermanent_obstack is the function_obstack\nof parent function.\n(restore_tree_status): Only free objects later than maybepermanent_firstobj in\nfunction_maybepermanent_obstack.\n(make_node): Fix logic error in PARM_DECL code.\nPut PARM_DECL in parent function's saveable obstack.\n\nFrom-SVN: r5713", "tree": {"sha": "f0c9ce4e8655c660579921b824b47861f2f16607", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f0c9ce4e8655c660579921b824b47861f2f16607"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/19e7d354741bd9ed28e851099f294cab0d0454d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19e7d354741bd9ed28e851099f294cab0d0454d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19e7d354741bd9ed28e851099f294cab0d0454d3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19e7d354741bd9ed28e851099f294cab0d0454d3/comments", "author": null, "committer": null, "parents": [{"sha": "1ad87b632908569ce4b8d01633cebf70b27a9cbe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ad87b632908569ce4b8d01633cebf70b27a9cbe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ad87b632908569ce4b8d01633cebf70b27a9cbe"}], "stats": {"total": 29, "additions": 21, "deletions": 8}, "files": [{"sha": "bdc72d4eb1a89bad1e6820833d146261906f637c", "filename": "gcc/tree.c", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19e7d354741bd9ed28e851099f294cab0d0454d3/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19e7d354741bd9ed28e851099f294cab0d0454d3/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=19e7d354741bd9ed28e851099f294cab0d0454d3", "patch": "@@ -319,13 +319,14 @@ save_tree_status (p)\n   p->saveable_obstack = saveable_obstack;\n   p->rtl_obstack = rtl_obstack;\n \n+  /* Objects that need to be saved in this function can be in the nonsaved\n+     obstack of the enclosing function since they can't possibly be needed\n+     once it has returned.  */\n+  function_maybepermanent_obstack = function_obstack;\n+\n   function_obstack = (struct obstack *) xmalloc (sizeof (struct obstack));\n   gcc_obstack_init (function_obstack);\n \n-  function_maybepermanent_obstack\n-    = (struct obstack *) xmalloc (sizeof (struct obstack));\n-  gcc_obstack_init (function_maybepermanent_obstack);\n-\n   current_obstack = &permanent_obstack;\n   expression_obstack = &permanent_obstack;\n   rtl_obstack = saveable_obstack = &permanent_obstack;\n@@ -346,8 +347,17 @@ restore_tree_status (p)\n   momentary_stack = p->momentary_stack;\n \n   obstack_free (&momentary_obstack, momentary_firstobj);\n+\n+  /* Free saveable storage used by the function just compiled and not\n+     saved.\n+\n+     CAUTION: This is in function_obstack of the containing function.  So\n+     we must be sure that we never allocate from that obstack during\n+     the compilation of a nested function if we expect it to survive past the\n+     nested function's end.  */\n+  obstack_free (function_maybepermanent_obstack, maybepermanent_firstobj);\n+\n   obstack_free (function_obstack, 0);\n-  obstack_free (function_maybepermanent_obstack, 0);\n   free (function_obstack);\n \n   momentary_firstobj = p->momentary_firstobj;\n@@ -813,16 +823,19 @@ make_node (code)\n \t PARM_DECLs of top-level functions do not have this problem.  However,\n \t we allocate them where we put the FUNCTION_DECL for languauges such as\n \t Ada that need to consult some flags in the PARM_DECLs of the function\n-\t when calling it.  */\n-      else if (code == PARM_DECL && obstack != &permanent_obstack)\n+\t when calling it. \n+\n+\t See comment in restore_tree_status for why we can't put this\n+\t in function_obstack.  */\n+      if (code == PARM_DECL && obstack != &permanent_obstack)\n \t{\n \t  tree context = 0;\n \t  if (current_function_decl)\n \t    context = decl_function_context (current_function_decl);\n \n \t  if (context)\n \t    obstack\n-\t      = find_function_data (context)->function_obstack;\n+\t      = find_function_data (context)->function_maybepermanent_obstack;\n \t}\n       break;\n "}]}