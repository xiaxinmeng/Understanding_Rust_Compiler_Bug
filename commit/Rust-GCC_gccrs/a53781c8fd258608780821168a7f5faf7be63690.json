{"sha": "a53781c8fd258608780821168a7f5faf7be63690", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTUzNzgxYzhmZDI1ODYwODc4MDgyMTE2OGE3ZjVmYWY3YmU2MzY5MA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2021-09-14T21:37:27Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2021-09-15T04:05:40Z"}, "message": "c++: don't predeclare std::type_info [PR48396]\n\nWe've always predeclared std::type_info, which has been wrong for a while,\nbut now with modules it becomes more of a practical problem, if we want to\ndeclare it in the purview of a module.  So don't predeclare it.  For\nbuilding up the type_info information to write out with the vtable, we can\nuse void* instead of type_info*, since they already aren't the real types.\n\n\tPR c++/48396\n\ngcc/cp/ChangeLog:\n\n\t* cp-tree.h (enum cp_tree_index): Remove CPTI_TYPE_INFO_PTR_TYPE.\n\t(type_info_ptr_type): Remove.\n\t* rtti.c (init_rtti_processing): Don't predeclare std::type_info.\n\t(typeid_ok_p): Check for null const_type_info_type_node.\n\t(type_info_ptr_type, get_void_tinfo_ptr): New fns.\n\t(get_tinfo_decl_dynamic, get_tinfo_ptr): Use them.\n\t(ptr_initializer, ptm_initializer, get_pseudo_ti_init): Use them.\n\t(get_tinfo_desc): Use const_ptr_type_node.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/rtti/undeclared1.C: New test.", "tree": {"sha": "3fb316813b7995e18206562e648e5a492667f712", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3fb316813b7995e18206562e648e5a492667f712"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a53781c8fd258608780821168a7f5faf7be63690", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a53781c8fd258608780821168a7f5faf7be63690", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a53781c8fd258608780821168a7f5faf7be63690", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a53781c8fd258608780821168a7f5faf7be63690/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ba9b07d0259b38a9eccd4eb0df327d3aaabad3c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba9b07d0259b38a9eccd4eb0df327d3aaabad3c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba9b07d0259b38a9eccd4eb0df327d3aaabad3c6"}], "stats": {"total": 104, "additions": 58, "deletions": 46}, "files": [{"sha": "060d1a0a3dbc37bd8af0a432fccca00d8f18038a", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a53781c8fd258608780821168a7f5faf7be63690/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a53781c8fd258608780821168a7f5faf7be63690/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=a53781c8fd258608780821168a7f5faf7be63690", "patch": "@@ -204,12 +204,11 @@ enum cp_tree_index\n     /* These are created at init time, but the library/headers provide\n        definitions.  */\n     CPTI_ALIGN_TYPE,\n-    CPTI_CONST_TYPE_INFO_TYPE,\n-    CPTI_TYPE_INFO_PTR_TYPE,\n     CPTI_TERMINATE_FN,\n     CPTI_CALL_UNEXPECTED_FN,\n \n     /* These are lazily inited.  */\n+    CPTI_CONST_TYPE_INFO_TYPE,\n     CPTI_GET_EXCEPTION_PTR_FN,\n     CPTI_BEGIN_CATCH_FN,\n     CPTI_END_CATCH_FN,\n@@ -251,7 +250,6 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n #define abi_node\t\t\tcp_global_trees[CPTI_ABI]\n #define global_namespace\t\tcp_global_trees[CPTI_GLOBAL]\n #define const_type_info_type_node\tcp_global_trees[CPTI_CONST_TYPE_INFO_TYPE]\n-#define type_info_ptr_type\t\tcp_global_trees[CPTI_TYPE_INFO_PTR_TYPE]\n #define conv_op_marker\t\t\tcp_global_trees[CPTI_CONV_OP_MARKER]\n #define abort_fndecl\t\t\tcp_global_trees[CPTI_ABORT_FNDECL]\n #define current_aggr\t\t\tcp_global_trees[CPTI_AGGR_TAG]"}, {"sha": "9c5066bcacc343c673a8df272d2e047113be82fc", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 52, "deletions": 43, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a53781c8fd258608780821168a7f5faf7be63690/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a53781c8fd258608780821168a7f5faf7be63690/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=a53781c8fd258608780821168a7f5faf7be63690", "patch": "@@ -125,7 +125,6 @@ static tree tinfo_name (tree, bool);\n static tree build_dynamic_cast_1 (location_t, tree, tree, tsubst_flags_t);\n static tree throw_bad_cast (void);\n static tree throw_bad_typeid (void);\n-static tree get_tinfo_ptr (tree);\n static bool typeid_ok_p (void);\n static int qualifier_flags (tree);\n static bool target_incomplete_p (tree);\n@@ -142,22 +141,11 @@ static bool typeinfo_in_lib_p (tree);\n \n static int doing_runtime = 0;\n \f\n-/* Declare language defined type_info type and a pointer to const\n-   type_info.  This is incomplete here, and will be completed when\n-   the user #includes <typeinfo>.  There are language defined\n-   restrictions on what can be done until that is included.  Create\n-   the internal versions of the ABI types.  */\n+/* Create the internal versions of the ABI types.  */\n \n void\n init_rtti_processing (void)\n {\n-  push_nested_namespace (std_node);\n-  tree type_info_type = xref_tag (class_type, get_identifier (\"type_info\"));\n-  pop_nested_namespace (std_node);\n-  const_type_info_type_node\n-    = cp_build_qualified_type (type_info_type, TYPE_QUAL_CONST);\n-  type_info_ptr_type = build_pointer_type (const_type_info_type_node);\n-\n   vec_alloc (unemitted_tinfo_decls, 124);\n \n   create_tinfo_types ();\n@@ -238,6 +226,33 @@ throw_bad_typeid (void)\n   return build_cxx_call (fn, 0, NULL, tf_warning_or_error);\n }\n \f\n+/* const type_info*.  */\n+\n+inline tree\n+type_info_ptr_type ()\n+{\n+  return build_pointer_type (const_type_info_type_node);\n+}\n+\n+/* Return a pointer to a type_info object describing TYPE, suitably\n+   cast to the language defined type (for typeid) or void (for building\n+   up the descriptors).  */\n+\n+static tree\n+get_tinfo_ptr (tree type, bool voidp = false)\n+{\n+  tree decl = get_tinfo_decl (type);\n+  mark_used (decl);\n+\n+  tree ptype = voidp ? const_ptr_type_node : type_info_ptr_type ();\n+  return build_nop (ptype, build_address (decl));\n+}\n+static inline tree\n+get_void_tinfo_ptr (tree type)\n+{\n+  return get_tinfo_ptr (type, true);\n+}\n+\n /* Return an lvalue expression whose type is \"const std::type_info\"\n    and whose value indicates the type of the expression EXP.  If EXP\n    is a reference to a polymorphic class, return the dynamic type;\n@@ -278,7 +293,7 @@ get_tinfo_decl_dynamic (tree exp, tsubst_flags_t complain)\n       index = build_int_cst (NULL_TREE,\n \t\t\t     -1 * TARGET_VTABLE_DATA_ENTRY_DISTANCE);\n       t = build_vtbl_ref (exp, index);\n-      t = convert (type_info_ptr_type, t);\n+      t = convert (type_info_ptr_type (), t);\n     }\n   else\n     /* Otherwise return the type_info for the static type of the expr.  */\n@@ -296,15 +311,22 @@ typeid_ok_p (void)\n       return false;\n     }\n \n-  if (!COMPLETE_TYPE_P (const_type_info_type_node))\n+  if (!const_type_info_type_node)\n     {\n-      gcc_rich_location richloc (input_location);\n-      maybe_add_include_fixit (&richloc, \"<typeinfo>\", false);\n-      error_at (&richloc,\n-\t\t\"must %<#include <typeinfo>%> before using\"\n-\t\t\" %<typeid%>\");\n+      tree name = get_identifier (\"type_info\");\n+      tree decl = lookup_qualified_name (std_node, name);\n+      if (TREE_CODE (decl) != TYPE_DECL)\n+\t{\n+\t  gcc_rich_location richloc (input_location);\n+\t  maybe_add_include_fixit (&richloc, \"<typeinfo>\", false);\n+\t  error_at (&richloc,\n+\t\t    \"must %<#include <typeinfo>%> before using\"\n+\t\t    \" %<typeid%>\");\n \n-      return false;\n+\t  return false;\n+\t}\n+      const_type_info_type_node\n+\t= cp_build_qualified_type (TREE_TYPE (decl), TYPE_QUAL_CONST);\n     }\n \n   tree pseudo = TYPE_MAIN_VARIANT (get_tinfo_desc (TK_TYPE_INFO_TYPE)->type);\n@@ -471,19 +493,6 @@ get_tinfo_decl_direct (tree type, tree name, int pseudo_ix)\n   return d;\n }\n \n-/* Return a pointer to a type_info object describing TYPE, suitably\n-   cast to the language defined type.  */\n-\n-static tree\n-get_tinfo_ptr (tree type)\n-{\n-  tree decl = get_tinfo_decl (type);\n-\n-  mark_used (decl);\n-  return build_nop (type_info_ptr_type,\n-\t\t    build_address (decl));\n-}\n-\n /* Return the type_info object for TYPE.  */\n \n tree\n@@ -1032,7 +1041,7 @@ ptr_initializer (tinfo_s *ti, tree target)\n   CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, init);\n   CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, build_int_cst (NULL_TREE, flags));\n   CONSTRUCTOR_APPEND_ELT (v, NULL_TREE,\n-                          get_tinfo_ptr (TYPE_MAIN_VARIANT (to)));\n+\t\t\t  get_void_tinfo_ptr (TYPE_MAIN_VARIANT (to)));\n \n   init = build_constructor (init_list_type_node, v);\n   TREE_CONSTANT (init) = 1;\n@@ -1063,8 +1072,8 @@ ptm_initializer (tinfo_s *ti, tree target)\n   CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, init);\n   CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, build_int_cst (NULL_TREE, flags));\n   CONSTRUCTOR_APPEND_ELT (v, NULL_TREE,\n-                          get_tinfo_ptr (TYPE_MAIN_VARIANT (to)));\n-  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, get_tinfo_ptr (klass));\n+\t\t\t  get_void_tinfo_ptr (TYPE_MAIN_VARIANT (to)));\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, get_void_tinfo_ptr (klass));\n \n   init = build_constructor (init_list_type_node, v);\n   TREE_CONSTANT (init) = 1;\n@@ -1156,7 +1165,7 @@ get_pseudo_ti_init (tree type, unsigned tk_index)\n     case TK_SI_CLASS_TYPE:\n       {\n \ttree base_binfo = BINFO_BASE_BINFO (TYPE_BINFO (type), 0);\n-\ttree tinfo = get_tinfo_ptr (BINFO_TYPE (base_binfo));\n+\ttree tinfo = get_void_tinfo_ptr (BINFO_TYPE (base_binfo));\n \n \t/* get_tinfo_ptr might have reallocated the tinfo_descs vector.  */\n \tti = &(*tinfo_descs)[tk_index];\n@@ -1187,7 +1196,7 @@ get_pseudo_ti_init (tree type, unsigned tk_index)\n \n \t    if ((*base_accesses)[ix] == access_public_node)\n \t      flags |= 2;\n-\t    tinfo = get_tinfo_ptr (BINFO_TYPE (base_binfo));\n+\t    tinfo = get_void_tinfo_ptr (BINFO_TYPE (base_binfo));\n \t    if (BINFO_VIRTUAL_P (base_binfo))\n \t      {\n \t\t/* We store the vtable offset at which the virtual\n@@ -1360,7 +1369,7 @@ get_tinfo_desc (unsigned ix)\n \t/* Base class internal helper. Pointer to base type, offset to\n \t   base, flags.  */\n \ttree fld_ptr = build_decl (BUILTINS_LOCATION, FIELD_DECL,\n-\t\t\t\t   NULL_TREE, type_info_ptr_type);\n+\t\t\t\t   NULL_TREE, const_ptr_type_node);\n \tDECL_CHAIN (fld_ptr) = fields;\n \tfields = fld_ptr;\n \n@@ -1396,15 +1405,15 @@ get_tinfo_desc (unsigned ix)\n \tfields = fld_mask;\n \n \ttree fld_ptr = build_decl (BUILTINS_LOCATION, FIELD_DECL,\n-\t\t\t\t   NULL_TREE, type_info_ptr_type);\n+\t\t\t\t   NULL_TREE, const_ptr_type_node);\n \tDECL_CHAIN (fld_ptr) = fields;\n \tfields = fld_ptr;\n \n \tif (ix == TK_POINTER_MEMBER_TYPE)\n \t  {\n \t    /* Add a pointer to the class too.  */\n \t    tree fld_cls = build_decl (BUILTINS_LOCATION, FIELD_DECL,\n-\t\t\t\t   NULL_TREE, type_info_ptr_type);\n+\t\t\t\t   NULL_TREE, const_ptr_type_node);\n \t    DECL_CHAIN (fld_cls) = fields;\n \t    fields = fld_cls;\n \t  }\n@@ -1421,7 +1430,7 @@ get_tinfo_desc (unsigned ix)\n \t   class.  This is really a descendant of\n \t   __class_type_info.  */\n \ttree fld_ptr = build_decl (BUILTINS_LOCATION, FIELD_DECL,\n-\t\t\t\t   NULL_TREE, type_info_ptr_type);\n+\t\t\t\t   NULL_TREE, const_ptr_type_node);\n \tDECL_CHAIN (fld_ptr) = fields;\n \tfields = fld_ptr;\n \tbreak;"}, {"sha": "9594c229f452f16d716ea27ef1269a6319ff296c", "filename": "gcc/testsuite/g++.dg/rtti/undeclared1.C", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a53781c8fd258608780821168a7f5faf7be63690/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Frtti%2Fundeclared1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a53781c8fd258608780821168a7f5faf7be63690/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Frtti%2Fundeclared1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Frtti%2Fundeclared1.C?ref=a53781c8fd258608780821168a7f5faf7be63690", "patch": "@@ -0,0 +1,5 @@\n+// PR c++/48396\n+\n+namespace std {\n+  type_info *p;\t\t\t// { dg-error \"type_info\" }\n+}"}]}