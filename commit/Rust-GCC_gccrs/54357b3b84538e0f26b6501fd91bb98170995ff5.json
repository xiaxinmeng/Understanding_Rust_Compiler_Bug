{"sha": "54357b3b84538e0f26b6501fd91bb98170995ff5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTQzNTdiM2I4NDUzOGUwZjI2YjY1MDFmZDkxYmI5ODE3MDk5NWZmNQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-06-23T13:45:36Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-06-23T13:45:36Z"}, "message": "runtime: improve handling of panic during deferred function\n    \n    When a panic occurs while processing a deferred function that\n    recovered an earlier panic, we shouldn't report the recovered panic\n    in the panic stack trace. Stop doing so by keeping track of the panic\n    that triggered a defer, marking it as aborted if we see the defer again,\n    and discarding aborted panics when a panic is recovered. This is what\n    the gc runtime does.\n    \n    The test for this is TestRecursivePanic in runtime/crash_test.go.\n    We don't run that test yet, but we will soon.\n    \n    Reviewed-on: https://go-review.googlesource.com/46461\n\nFrom-SVN: r249590", "tree": {"sha": "eea40c0f194dee2f158ed71d9fca0420fd4b4204", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eea40c0f194dee2f158ed71d9fca0420fd4b4204"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/54357b3b84538e0f26b6501fd91bb98170995ff5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54357b3b84538e0f26b6501fd91bb98170995ff5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54357b3b84538e0f26b6501fd91bb98170995ff5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54357b3b84538e0f26b6501fd91bb98170995ff5/comments", "author": null, "committer": null, "parents": [{"sha": "fb68f296283941d15505fcf610099281562fa9e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb68f296283941d15505fcf610099281562fa9e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb68f296283941d15505fcf610099281562fa9e0"}], "stats": {"total": 118, "additions": 86, "deletions": 32}, "files": [{"sha": "d82e012767cd7adec0c665929794645c0d6e07f4", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54357b3b84538e0f26b6501fd91bb98170995ff5/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54357b3b84538e0f26b6501fd91bb98170995ff5/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=54357b3b84538e0f26b6501fd91bb98170995ff5", "patch": "@@ -1,4 +1,4 @@\n-385efb8947af70b8425c833a1ab68ba5f357dfae\n+c4adba240f9d5af8ab0534316d6b05bd988c432c\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "e3d03580de5c7cb06364b681940b0ffbb54b5d10", "filename": "libgo/go/runtime/panic.go", "status": "modified", "additions": 77, "deletions": 31, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54357b3b84538e0f26b6501fd91bb98170995ff5/libgo%2Fgo%2Fruntime%2Fpanic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54357b3b84538e0f26b6501fd91bb98170995ff5/libgo%2Fgo%2Fruntime%2Fpanic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fpanic.go?ref=54357b3b84538e0f26b6501fd91bb98170995ff5", "patch": "@@ -91,6 +91,9 @@ func throwinit() {\n // arg is a value to pass to pfn.\n func deferproc(frame *bool, pfn uintptr, arg unsafe.Pointer) {\n \td := newdefer()\n+\tif d._panic != nil {\n+\t\tthrow(\"deferproc: d.panic != nil after newdefer\")\n+\t}\n \td.frame = frame\n \td.panicStack = getg()._panic\n \td.pfn = pfn\n@@ -338,17 +341,28 @@ func Goexit() {\n \t\tif d == nil {\n \t\t\tbreak\n \t\t}\n-\t\tgp._defer = d.link\n \n \t\tpfn := d.pfn\n+\t\tif pfn == 0 {\n+\t\t\tif d._panic != nil {\n+\t\t\t\td._panic.aborted = true\n+\t\t\t\td._panic = nil\n+\t\t\t}\n+\t\t\tgp._defer = d.link\n+\t\t\tfreedefer(d)\n+\t\t\tcontinue\n+\t\t}\n \t\td.pfn = 0\n \n-\t\tif pfn != 0 {\n-\t\t\tvar fn func(unsafe.Pointer)\n-\t\t\t*(*uintptr)(unsafe.Pointer(&fn)) = uintptr(unsafe.Pointer(&pfn))\n-\t\t\tfn(d.arg)\n-\t\t}\n+\t\tvar fn func(unsafe.Pointer)\n+\t\t*(*uintptr)(unsafe.Pointer(&fn)) = uintptr(unsafe.Pointer(&pfn))\n+\t\tfn(d.arg)\n \n+\t\tif gp._defer != d {\n+\t\t\tthrow(\"bad defer entry in Goexit\")\n+\t\t}\n+\t\td._panic = nil\n+\t\tgp._defer = d.link\n \t\tfreedefer(d)\n \t\t// Note: we ignore recovers here because Goexit isn't a panic\n \t}\n@@ -442,39 +456,71 @@ func gopanic(e interface{}) {\n \t\t}\n \n \t\tpfn := d.pfn\n+\n+\t\t// If defer was started by earlier panic or Goexit (and, since we're back here, that triggered a new panic),\n+\t\t// take defer off list. The earlier panic or Goexit will not continue running.\n+\t\tif pfn == 0 {\n+\t\t\tif d._panic != nil {\n+\t\t\t\td._panic.aborted = true\n+\t\t\t}\n+\t\t\td._panic = nil\n+\t\t\tgp._defer = d.link\n+\t\t\tfreedefer(d)\n+\t\t\tcontinue\n+\t\t}\n \t\td.pfn = 0\n \n-\t\tif pfn != 0 {\n-\t\t\tvar fn func(unsafe.Pointer)\n-\t\t\t*(*uintptr)(unsafe.Pointer(&fn)) = uintptr(unsafe.Pointer(&pfn))\n-\t\t\tfn(d.arg)\n+\t\t// Record the panic that is running the defer.\n+\t\t// If there is a new panic during the deferred call, that panic\n+\t\t// will find d in the list and will mark d._panic (this panic) aborted.\n+\t\td._panic = p\n \n-\t\t\tif p.recovered {\n-\t\t\t\t// Some deferred function called recover.\n-\t\t\t\t// Stop running this panic.\n-\t\t\t\tgp._panic = p.link\n-\n-\t\t\t\t// Unwind the stack by throwing an exception.\n-\t\t\t\t// The compiler has arranged to create\n-\t\t\t\t// exception handlers in each function\n-\t\t\t\t// that uses a defer statement.  These\n-\t\t\t\t// exception handlers will check whether\n-\t\t\t\t// the entry on the top of the defer stack\n-\t\t\t\t// is from the current function.  If it is,\n-\t\t\t\t// we have unwound the stack far enough.\n-\t\t\t\tunwindStack()\n-\n-\t\t\t\tthrow(\"unwindStack returned\")\n+\t\tvar fn func(unsafe.Pointer)\n+\t\t*(*uintptr)(unsafe.Pointer(&fn)) = uintptr(unsafe.Pointer(&pfn))\n+\t\tfn(d.arg)\n+\n+\t\tif gp._defer != d {\n+\t\t\tthrow(\"bad defer entry in panic\")\n+\t\t}\n+\t\td._panic = nil\n+\n+\t\tif p.recovered {\n+\t\t\t// Some deferred function called recover.\n+\t\t\t// Stop running this panic.\n+\t\t\tgp._panic = p.link\n+\n+\t\t\t// Aborted panics are marked but remain on the g.panic list.\n+\t\t\t// Remove them from the list.\n+\t\t\tfor gp._panic != nil && gp._panic.aborted {\n+\t\t\t\tgp._panic = gp._panic.link\n+\t\t\t}\n+\t\t\tif gp._panic == nil { // must be done with signal\n+\t\t\t\tgp.sig = 0\n \t\t\t}\n \n-\t\t\t// Because we executed that defer function by a panic,\n-\t\t\t// and it did not call recover, we know that we are\n-\t\t\t// not returning from the calling function--we are\n-\t\t\t// panicking through it.\n-\t\t\t*d.frame = false\n+\t\t\t// Unwind the stack by throwing an exception.\n+\t\t\t// The compiler has arranged to create\n+\t\t\t// exception handlers in each function\n+\t\t\t// that uses a defer statement.  These\n+\t\t\t// exception handlers will check whether\n+\t\t\t// the entry on the top of the defer stack\n+\t\t\t// is from the current function.  If it is,\n+\t\t\t// we have unwound the stack far enough.\n+\t\t\tunwindStack()\n+\n+\t\t\tthrow(\"unwindStack returned\")\n \t\t}\n \n+\t\t// Because we executed that defer function by a panic,\n+\t\t// and it did not call recover, we know that we are\n+\t\t// not returning from the calling function--we are\n+\t\t// panicking through it.\n+\t\t*d.frame = false\n+\n+\t\t// Deferred function did not panic. Remove d.\n+\t\t// In the p.recovered case, d will be removed by checkdefer.\n \t\tgp._defer = d.link\n+\n \t\tfreedefer(d)\n \t}\n "}, {"sha": "cdd3fcc7911f37259d2eac42ba897ebdd239873b", "filename": "libgo/go/runtime/runtime2.go", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54357b3b84538e0f26b6501fd91bb98170995ff5/libgo%2Fgo%2Fruntime%2Fruntime2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54357b3b84538e0f26b6501fd91bb98170995ff5/libgo%2Fgo%2Fruntime%2Fruntime2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fruntime2.go?ref=54357b3b84538e0f26b6501fd91bb98170995ff5", "patch": "@@ -700,6 +700,10 @@ type _defer struct {\n \t// has a defer statement itself.\n \tpanicStack *_panic\n \n+\t// The panic that caused the defer to run. This is used to\n+\t// discard panics that have already been handled.\n+\t_panic *_panic\n+\n \t// The function to call.\n \tpfn uintptr\n \n@@ -733,6 +737,10 @@ type _panic struct {\n \t// Whether this panic was pushed on the stack because of an\n \t// exception thrown in some other language.\n \tisforeign bool\n+\n+\t// Whether this panic was already seen by a deferred function\n+\t// which called panic again.\n+\taborted bool\n }\n \n const ("}]}