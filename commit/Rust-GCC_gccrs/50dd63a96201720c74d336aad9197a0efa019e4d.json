{"sha": "50dd63a96201720c74d336aad9197a0efa019e4d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTBkZDYzYTk2MjAxNzIwYzc0ZDMzNmFhZDkxOTdhMGVmYTAxOWU0ZA==", "commit": {"author": {"name": "Thomas Koenig", "email": "Thomas.Koenig@online.de", "date": "2005-04-09T21:38:47Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2005-04-09T21:38:47Z"}, "message": "re PR libfortran/19106 ([4.0 only] segfault in executable for print *,sum(a,dim=2,mask=a>0))\n\n2005-04-09  Thomas Koenig  <Thomas.Koenig@online.de>\n\n        PR libfortran/19106\n        PR libfortran/19014\n        * m4/ifunction.m4 (name`'rtype_qual`_'atype_code): ditto.\n        If retarray->data is NULL (i.e. the front end does not\n        know the rank and dimenson of the array), fill in its\n        properties and allocate memory.\n        Change the assertions about rank and dimension of retarray into\n        runtime errors and only check them for retarray->data != NULL.\n        Do the same for correcting the stride from 0 to 1 in retarray.\n        (`m'name`'rtype_qual`_'atype_code): Likewise.\n        * m4/iforeach.m4 (name`'rtype_qual`_'atype_code): Likewise.\n        Change assertion about rank of array to runtime error.\n        (`m'name`'rtype_qual`_'atype_code): Likewise.\n        * generated/all_l4.c: Regenerated.\n        * generated/all_l8.c: Regenerated.\n        * generated/any_l4.c: Regenerated.\n        * generated/any_l8.c: Regenerated.\n        * generated/count_4_l4.c: Regenerated.\n        * generated/count_4_l8.c: Regenerated.\n        * generated/count_8_l4.c: Regenerated.\n        * generated/count_8_l8.c: Regenerated.\n        * generated/maxloc0_4_i4.c: Regenerated.\n        * generated/maxloc0_4_i8.c: Regenerated.\n        * generated/maxloc0_4_r4.c: Regenerated.\n        * generated/maxloc0_4_r8.c: Regenerated.\n        * generated/maxloc0_8_i4.c: Regenerated.\n        * generated/maxloc0_8_i8.c: Regenerated.\n        * generated/maxloc0_8_r4.c: Regenerated.\n        * generated/maxloc0_8_r8.c: Regenerated.\n        * generated/maxloc1_4_i4.c: Regenerated.\n        * generated/maxloc1_4_i8.c: Regenerated.\n        * generated/maxloc1_4_r4.c: Regenerated.\n        * generated/maxloc1_4_r8.c: Regenerated.\n        * generated/maxloc1_8_i4.c: Regenerated.\n        * generated/maxloc1_8_i8.c: Regenerated.\n        * generated/maxloc1_8_r4.c: Regenerated.\n        * generated/maxloc1_8_r8.c: Regenerated.\n        * generated/maxval_i4.c: Regenerated.\n        * generated/maxval_i8.c: Regenerated.\n        * generated/maxval_r4.c: Regenerated.\n        * generated/maxval_r8.c: Regenerated.\n        * generated/minloc0_4_i4.c: Regenerated.\n        * generated/minloc0_4_i8.c: Regenerated.\n        * generated/minloc0_4_r4.c: Regenerated.\n        * generated/minloc0_4_r8.c: Regenerated.\n        * generated/minloc0_8_i4.c: Regenerated.\n        * generated/minloc0_8_i8.c: Regenerated.\n        * generated/minloc0_8_r4.c: Regenerated.\n        * generated/minloc0_8_r8.c: Regenerated.\n        * generated/minloc1_4_i4.c: Regenerated.\n        * generated/minloc1_4_i8.c: Regenerated.\n        * generated/minloc1_4_r4.c: Regenerated.\n        * generated/minloc1_4_r8.c: Regenerated.\n        * generated/minloc1_8_i4.c: Regenerated.\n        * generated/minloc1_8_i8.c: Regenerated.\n        * generated/minloc1_8_r4.c: Regenerated.\n        * generated/minloc1_8_r8.c: Regenerated.\n        * generated/minval_i4.c: Regenerated.\n        * generated/minval_i8.c: Regenerated.\n        * generated/minval_r4.c: Regenerated.\n        * generated/minval_r8.c: Regenerated.\n        * generated/product_c4.c: Regenerated.\n        * generated/product_c8.c: Regenerated.\n        * generated/product_i4.c: Regenerated.\n        * generated/product_i8.c: Regenerated.\n        * generated/product_r4.c: Regenerated.\n        * generated/product_r8.c: Regenerated.\n        * generated/sum_c4.c: Regenerated.\n        * generated/sum_c8.c: Regenerated.\n        * generated/sum_i4.c: Regenerated.\n        * generated/sum_i8.c: Regenerated.\n        * generated/sum_r4.c: Regenerated.\n        * generated/sum_r8.c: Regenerated.\n\n2005-04-09  Thomas Koenig  <Thomas.Koenig@online.de>\n\n        * gfortran.fortran-torture/execute/intrinsic_anyall.f90:\n        Added test for callee-allocated arrays with write statements.\n        * gfortran.fortran-torture/execute/intrinsic_count.f90: Likewise.\n        * gfortran.fortran-torture/execute/intrinsic_mmloc.f90: Likewise.\n        * gfortran.fortran-torture/execute/intrinsic_mmval.f90: Likewise.\n        * gfortran.fortran-torture/execute/intrinsic_product.f90: Likewise.\n        * gfortran.fortran-torture/execute/intrinsic_sum.f90: Likewise.\n\nFrom-SVN: r97929", "tree": {"sha": "25814186d85901336c2e9c7e9a89298fa18cefc7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/25814186d85901336c2e9c7e9a89298fa18cefc7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/50dd63a96201720c74d336aad9197a0efa019e4d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50dd63a96201720c74d336aad9197a0efa019e4d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50dd63a96201720c74d336aad9197a0efa019e4d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50dd63a96201720c74d336aad9197a0efa019e4d/comments", "author": null, "committer": null, "parents": [{"sha": "e5e625da47c6215bb0075bfdf7da3a7595d16a32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5e625da47c6215bb0075bfdf7da3a7595d16a32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5e625da47c6215bb0075bfdf7da3a7595d16a32"}], "stats": {"total": 2983, "additions": 2471, "deletions": 512}, "files": [{"sha": "1dfa1457971e7886e47f38b3e5077390d285d3bb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -1,3 +1,13 @@\n+2005-04-09  Thomas Koenig  <Thomas.Koenig@online.de>\n+\n+\t* gfortran.fortran-torture/execute/intrinsic_anyall.f90:\n+\tAdded test for callee-allocated arrays with write statements.\n+\t* gfortran.fortran-torture/execute/intrinsic_count.f90: Likewise.\n+\t* gfortran.fortran-torture/execute/intrinsic_mmloc.f90: Likewise.\n+\t* gfortran.fortran-torture/execute/intrinsic_mmval.f90: Likewise.\n+\t* gfortran.fortran-torture/execute/intrinsic_product.f90: Likewise.\n+\t* gfortran.fortran-torture/execute/intrinsic_sum.f90: Likewise.\n+\n 2005-04-09  Thomas Koenig  <Thomas.Koenig@online.de>\n \n \tPR libfortran/20163"}, {"sha": "4e392c569606756fc7a7e2d903f212a70254b1b2", "filename": "gcc/testsuite/gfortran.fortran-torture/execute/intrinsic_anyall.f90", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fintrinsic_anyall.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fintrinsic_anyall.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fintrinsic_anyall.f90?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -3,6 +3,7 @@ program anyall\n    implicit none\n    logical, dimension(3, 3) :: a\n    logical, dimension(3) :: b\n+   character(len=10) line\n \n    a = .false.\n    if (any(a)) call abort\n@@ -13,6 +14,12 @@ program anyall\n    if (.not. b(1)) call abort\n    if (b(2)) call abort\n    if (.not. b(3)) call abort\n+   b = .false.\n+   write (line, 9000) any(a,1)\n+   read (line, 9000) b\n+   if (.not. b(1)) call abort\n+   if (b(2)) call abort\n+   if (.not. b(3)) call abort\n \n    a = .true.\n    if (.not. all(a)) call abort\n@@ -23,4 +30,12 @@ program anyall\n    if (b(1)) call abort\n    if (.not. b(2)) call abort\n    if (b(3)) call abort\n+   b = .false.\n+   write (line, 9000) all(a,1)\n+   read (line, 9000) b\n+   if (b(1)) call abort\n+   if (.not. b(2)) call abort\n+   if (b(3)) call abort\n+\n+9000 format (9L1)\n end program"}, {"sha": "f95c198c1f56880049de53c24825bd05dc9dfcb7", "filename": "gcc/testsuite/gfortran.fortran-torture/execute/intrinsic_count.f90", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fintrinsic_count.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fintrinsic_count.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fintrinsic_count.f90?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -4,6 +4,7 @@ program intrinsic_count\n    logical(kind=4), dimension (3, 5) :: a\n    integer(kind=4), dimension (5) :: b\n    integer i\n+   character(len=10) line\n \n    a = .false.\n    if (count(a) .ne. 0) call abort\n@@ -13,9 +14,21 @@ program intrinsic_count\n    a(2, 2) = .false.\n    a(2, 5) = .false.\n    if (count(a) .ne. 12) call abort\n+   write (line, 9000) count(a)\n+   read (line, 9000) i\n+   if (i .ne. 12) call abort\n \n    b(1:3) = count(a, 2);\n    if (b(1) .ne. 4) call abort\n    if (b(2) .ne. 3) call abort\n    if (b(3) .ne. 5) call abort\n+   b = 0\n+   write (line, 9000) count(a,2)\n+   read (line, 9000) b\n+   if (b(1) .ne. 4) call abort\n+   if (b(2) .ne. 3) call abort\n+   if (b(3) .ne. 5) call abort\n+\n+9000 format(3I3)\n+\n end program"}, {"sha": "ea73913b6ef207ed97ac710b226f95780b86990c", "filename": "gcc/testsuite/gfortran.fortran-torture/execute/intrinsic_mmloc.f90", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fintrinsic_mmloc.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fintrinsic_mmloc.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fintrinsic_mmloc.f90?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -5,13 +5,20 @@ program testmmloc\n    integer, dimension (3) :: b\n    logical, dimension (3, 3) :: m\n    integer i\n+   character(len=10) line\n \n    a = reshape ((/1, 2, 3, 5, 4, 6, 9, 8, 7/), (/3, 3/));\n \n    b = minloc (a, 1)\n    if (b(1) .ne. 1) call abort\n    if (b(2) .ne. 2) call abort\n    if (b(3) .ne. 3) call abort\n+   b = -1\n+   write (line, 9000) minloc(a,1)\n+   read (line, 9000) b\n+   if (b(1) .ne. 1) call abort\n+   if (b(2) .ne. 2) call abort\n+   if (b(3) .ne. 3) call abort\n \n    m = .true.\n    m(1, 1) = .false.\n@@ -20,19 +27,43 @@ program testmmloc\n    if (b(1) .ne. 2) call abort\n    if (b(2) .ne. 2) call abort\n    if (b(3) .ne. 3) call abort\n+   b = -1\n+   write (line, 9000) minloc(a, 1, m)\n+   read (line, 9000) b\n+   if (b(1) .ne. 2) call abort\n+   if (b(2) .ne. 2) call abort\n+   if (b(3) .ne. 3) call abort\n \n    b(1:2) = minloc(a)\n    if (b(1) .ne. 1) call abort\n    if (b(2) .ne. 1) call abort\n+   b = -1\n+   write (line, 9000) minloc(a)\n+   read (line, 9000) b\n+   if (b(1) .ne. 1) call abort\n+   if (b(2) .ne. 1) call abort\n+   if (b(3) .ne. 0) call abort\n \n    b(1:2) = minloc(a, mask=m)\n    if (b(1) .ne. 2) call abort\n    if (b(2) .ne. 1) call abort\n+   b = -1\n+   write (line, 9000) minloc(a, mask=m)\n+   read (line, 9000) b\n+   if (b(1) .ne. 2) call abort\n+   if (b(2) .ne. 1) call abort\n+   if (b(3) .ne. 0) call abort\n \n    b = maxloc (a, 1)\n    if (b(1) .ne. 3) call abort\n    if (b(2) .ne. 3) call abort\n    if (b(3) .ne. 1) call abort\n+   b = -1\n+   write (line, 9000) maxloc(a, 1)\n+   read (line, 9000) b\n+   if (b(1) .ne. 3) call abort\n+   if (b(2) .ne. 3) call abort\n+   if (b(3) .ne. 1) call abort\n \n    m = .true.\n    m(1, 2) = .false.\n@@ -41,12 +72,31 @@ program testmmloc\n    if (b(1) .ne. 3) call abort\n    if (b(2) .ne. 3) call abort\n    if (b(3) .ne. 2) call abort\n+   b = -1\n+   write (line, 9000) maxloc(a, 1, m)\n+   read (line, 9000) b\n+   if (b(1) .ne. 3) call abort\n+   if (b(2) .ne. 3) call abort\n+   if (b(3) .ne. 2) call abort\n \n    b(1:2) = maxloc(a)\n    if (b(1) .ne. 1) call abort\n    if (b(2) .ne. 3) call abort\n+   b = -1\n+   write (line, 9000) maxloc(a)\n+   read (line, 9000) b\n+   if (b(1) .ne. 1) call abort\n+   if (b(2) .ne. 3) call abort\n \n    b(1:2) = maxloc(a, mask=m)\n    if (b(1) .ne. 2) call abort\n    if (b(2) .ne. 3) call abort\n+   b = -1\n+   write (line, 9000) maxloc(a, mask=m)\n+   read (line, 9000) b\n+   if (b(1) .ne. 2) call abort\n+   if (b(2) .ne. 3) call abort\n+   if (b(3) .ne. 0) call abort\n+\n+9000 format (3I3)\n end program"}, {"sha": "86ec15917279c75f04e8d7a94216d2a468ca247b", "filename": "gcc/testsuite/gfortran.fortran-torture/execute/intrinsic_mmval.f90", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fintrinsic_mmval.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fintrinsic_mmval.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fintrinsic_mmval.f90?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -5,24 +5,35 @@ program testmmval\n    integer, dimension (3) :: b\n    logical, dimension (3, 3) :: m\n    integer i\n+   character (len=9) line\n \n    a = reshape ((/1, 2, 3, 5, 4, 6, 9, 8, 7/), (/3, 3/));\n \n    b = minval (a, 1)\n    if (any(b .ne. (/1, 4, 7/))) call abort\n+   write (line, 9000) minval (a, 1)\n+   if (line .ne. '  1  4  7') call abort\n \n    m = .true.\n    m(1, 1) = .false.\n    m(1, 2) = .false.\n    b = minval (a, 1, m)\n    if (any(b .ne. (/2, 4, 7/))) call abort\n+   write (line, 9000) minval(a, 1, m)\n+   if (line .ne. '  2  4  7') call abort\n \n    b = maxval (a, 1)\n    if (any(b .ne. (/3, 6, 9/))) call abort\n+   write (line, 9000) maxval (a, 1)\n+   if (line .ne. '  3  6  9') call abort\n \n    m = .true.\n    m(1, 2) = .false.\n    m(1, 3) = .false.\n    b = maxval (a, 1, m)\n    if (any(b .ne. (/3, 6, 8/))) call abort\n+   write (line, 9000) maxval(a, 1, m)\n+   if (line .ne. '  3  6  8') call abort\n+\n+9000 format(3I3)\n end program"}, {"sha": "2892d5407cac9e649fa4cd911d6505ae2d8a5bba", "filename": "gcc/testsuite/gfortran.fortran-torture/execute/intrinsic_product.f90", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fintrinsic_product.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fintrinsic_product.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fintrinsic_product.f90?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -4,22 +4,37 @@ program testproduct\n    integer, dimension (3, 3) :: a\n    integer, dimension (3) :: b\n    logical, dimension (3, 3) :: m\n+   character(len=12) line\n \n    a = reshape ((/1, 2, 3, 4, 5, 6, 7, 8, 9/), (/3, 3/));\n \n    b = product (a, 1)\n \n    if (any(b .ne. (/6, 120, 504/))) call abort\n \n+   write (line, 9000) product(a,1)\n+   if (line .ne. '   6 120 504') call abort\n+\n    if (product (a) .ne. 362880) call abort\n \n+   write (line, 9010) product(a)\n+   if (line .ne. '362880') call abort\n+\n    m = .true.\n    m(1, 1) = .false.\n    m(2, 1) = .false.\n    b = product (a, 2, m)\n \n    if (any(b .ne. (/28, 40, 162/))) call abort\n \n+   write (line, 9000) product(a, 2, m)\n+   if (line .ne. '  28  40 162') call abort\n+\n    if (product (a, mask=m) .ne. 181440) call abort\n \n+   write (line, 9010) product(a, mask=m)\n+   if (line .ne. '181440') call abort\n+\n+9000 format (3I4)\n+9010 format (I6)\n end program"}, {"sha": "552f6c6d01f83903316c5f3dcc553b4d3bf26a86", "filename": "gcc/testsuite/gfortran.fortran-torture/execute/intrinsic_sum.f90", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fintrinsic_sum.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fintrinsic_sum.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fintrinsic_sum.f90?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -5,22 +5,35 @@ program testforall\n    integer, dimension (3) :: b\n    logical, dimension (3, 3) :: m\n    integer i\n+   character(len=9) line\n \n    a = reshape ((/1, 2, 3, 4, 5, 6, 7, 8, 9/), (/3, 3/));\n \n    if (sum(a) .ne. 45) call abort\n+   write (line, 9000) sum(a)\n+   if (line .ne. ' 45      ') call abort\n    b = sum (a, 1)\n    if (b(1) .ne. 6) call abort\n    if (b(2) .ne. 15) call abort\n    if (b(3) .ne. 24) call abort\n+   write (line, 9000) sum (a, 1)\n+   if (line .ne. '  6 15 24') call abort\n \n    m = .true.\n    m(1, 1) = .false.\n    m(2, 1) = .false.\n \n    if (sum (a, mask=m) .ne. 42) call abort\n+\n+   write(line, 9000) sum (a, mask=m)\n+   if (line .ne. ' 42      ') call abort\n+\n    b = sum (a, 2, m)\n    if (b(1) .ne. 11) call abort\n    if (b(2) .ne. 13) call abort\n    if (b(3) .ne. 18) call abort\n+   write (line, 9000) sum (a, 2, m)\n+   if (line .ne. ' 11 13 18') call abort\n+\n+9000 format(3I3)\n end program"}, {"sha": "ba0257d69b68421432b50c36fd1d3821edf659a3", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -1,3 +1,79 @@\n+2005-04-09  Thomas Koenig  <Thomas.Koenig@online.de>\n+\n+\tPR libfortran/19106\n+\tPR libfortran/19014\n+\t* m4/ifunction.m4 (name`'rtype_qual`_'atype_code): ditto.\n+\tIf retarray->data is NULL (i.e. the front end does not\n+\tknow the rank and dimenson of the array), fill in its\n+\tproperties and allocate memory.\n+\tChange the assertions about rank and dimension of retarray into\n+\truntime errors and only check them for retarray->data != NULL.\n+\tDo the same for correcting the stride from 0 to 1 in retarray.\n+\t(`m'name`'rtype_qual`_'atype_code): Likewise.\n+\t* m4/iforeach.m4 (name`'rtype_qual`_'atype_code): Likewise.\n+\tChange assertion about rank of array to runtime error.\n+\t(`m'name`'rtype_qual`_'atype_code): Likewise.\n+\t* generated/all_l4.c: Regenerated.\n+\t* generated/all_l8.c: Regenerated.\n+\t* generated/any_l4.c: Regenerated.\n+\t* generated/any_l8.c: Regenerated.\n+\t* generated/count_4_l4.c: Regenerated.\n+\t* generated/count_4_l8.c: Regenerated.\n+\t* generated/count_8_l4.c: Regenerated.\n+\t* generated/count_8_l8.c: Regenerated.\n+\t* generated/maxloc0_4_i4.c: Regenerated.\n+\t* generated/maxloc0_4_i8.c: Regenerated.\n+\t* generated/maxloc0_4_r4.c: Regenerated.\n+\t* generated/maxloc0_4_r8.c: Regenerated.\n+\t* generated/maxloc0_8_i4.c: Regenerated.\n+\t* generated/maxloc0_8_i8.c: Regenerated.\n+\t* generated/maxloc0_8_r4.c: Regenerated.\n+\t* generated/maxloc0_8_r8.c: Regenerated.\n+\t* generated/maxloc1_4_i4.c: Regenerated.\n+\t* generated/maxloc1_4_i8.c: Regenerated.\n+\t* generated/maxloc1_4_r4.c: Regenerated.\n+\t* generated/maxloc1_4_r8.c: Regenerated.\n+\t* generated/maxloc1_8_i4.c: Regenerated.\n+\t* generated/maxloc1_8_i8.c: Regenerated.\n+\t* generated/maxloc1_8_r4.c: Regenerated.\n+\t* generated/maxloc1_8_r8.c: Regenerated.\n+\t* generated/maxval_i4.c: Regenerated.\n+\t* generated/maxval_i8.c: Regenerated.\n+\t* generated/maxval_r4.c: Regenerated.\n+\t* generated/maxval_r8.c: Regenerated.\n+\t* generated/minloc0_4_i4.c: Regenerated.\n+\t* generated/minloc0_4_i8.c: Regenerated.\n+\t* generated/minloc0_4_r4.c: Regenerated.\n+\t* generated/minloc0_4_r8.c: Regenerated.\n+\t* generated/minloc0_8_i4.c: Regenerated.\n+\t* generated/minloc0_8_i8.c: Regenerated.\n+\t* generated/minloc0_8_r4.c: Regenerated.\n+\t* generated/minloc0_8_r8.c: Regenerated.\n+\t* generated/minloc1_4_i4.c: Regenerated.\n+\t* generated/minloc1_4_i8.c: Regenerated.\n+\t* generated/minloc1_4_r4.c: Regenerated.\n+\t* generated/minloc1_4_r8.c: Regenerated.\n+\t* generated/minloc1_8_i4.c: Regenerated.\n+\t* generated/minloc1_8_i8.c: Regenerated.\n+\t* generated/minloc1_8_r4.c: Regenerated.\n+\t* generated/minloc1_8_r8.c: Regenerated.\n+\t* generated/minval_i4.c: Regenerated.\n+\t* generated/minval_i8.c: Regenerated.\n+\t* generated/minval_r4.c: Regenerated.\n+\t* generated/minval_r8.c: Regenerated.\n+\t* generated/product_c4.c: Regenerated.\n+\t* generated/product_c8.c: Regenerated.\n+\t* generated/product_i4.c: Regenerated.\n+\t* generated/product_i8.c: Regenerated.\n+\t* generated/product_r4.c: Regenerated.\n+\t* generated/product_r8.c: Regenerated.\n+\t* generated/sum_c4.c: Regenerated.\n+\t* generated/sum_c8.c: Regenerated.\n+\t* generated/sum_i4.c: Regenerated.\n+\t* generated/sum_i8.c: Regenerated.\n+\t* generated/sum_r4.c: Regenerated.\n+\t* generated/sum_r8.c: Regenerated.\n+\n 2005-04-09  Thomas Koenig <Thomas.Koenig@online.de>\n \n \tPR libfortran/20163"}, {"sha": "ddf9be1338e8f3a09fbb84f8c5ad9f1fc6ef4300", "filename": "libgfortran/generated/all_l4.c", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fall_l4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fall_l4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fall_l4.c?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -55,11 +55,8 @@ all_l4 (gfc_array_l4 *retarray, gfc_array_l4 *array, index_type *pdim)\n   /* Make dim zero based to avoid confusion.  */\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   delta = array->dim[dim].stride;\n@@ -93,8 +90,17 @@ all_l4 (gfc_array_l4 *retarray, gfc_array_l4 *array, index_type *pdim)\n \t\t \t\t * retarray->dim[rank-1].stride\n \t\t\t\t * extent[rank-1]);\n       retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n     }\n-          \n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;"}, {"sha": "3978f3170986a53914cc6ce270dafa67fa7bc0d9", "filename": "libgfortran/generated/all_l8.c", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fall_l8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fall_l8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fall_l8.c?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -55,11 +55,8 @@ all_l8 (gfc_array_l8 *retarray, gfc_array_l8 *array, index_type *pdim)\n   /* Make dim zero based to avoid confusion.  */\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   delta = array->dim[dim].stride;\n@@ -93,8 +90,17 @@ all_l8 (gfc_array_l8 *retarray, gfc_array_l8 *array, index_type *pdim)\n \t\t \t\t * retarray->dim[rank-1].stride\n \t\t\t\t * extent[rank-1]);\n       retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n     }\n-          \n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;"}, {"sha": "7db73dda8efc9106ecb257b99a34bac0df5ca224", "filename": "libgfortran/generated/any_l4.c", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fany_l4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fany_l4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fany_l4.c?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -55,11 +55,8 @@ any_l4 (gfc_array_l4 *retarray, gfc_array_l4 *array, index_type *pdim)\n   /* Make dim zero based to avoid confusion.  */\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   delta = array->dim[dim].stride;\n@@ -93,8 +90,17 @@ any_l4 (gfc_array_l4 *retarray, gfc_array_l4 *array, index_type *pdim)\n \t\t \t\t * retarray->dim[rank-1].stride\n \t\t\t\t * extent[rank-1]);\n       retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n     }\n-          \n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;"}, {"sha": "7814797225ee47ec7a90dc9529421bcfcd5e05fe", "filename": "libgfortran/generated/any_l8.c", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fany_l8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fany_l8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fany_l8.c?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -55,11 +55,8 @@ any_l8 (gfc_array_l8 *retarray, gfc_array_l8 *array, index_type *pdim)\n   /* Make dim zero based to avoid confusion.  */\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   delta = array->dim[dim].stride;\n@@ -93,8 +90,17 @@ any_l8 (gfc_array_l8 *retarray, gfc_array_l8 *array, index_type *pdim)\n \t\t \t\t * retarray->dim[rank-1].stride\n \t\t\t\t * extent[rank-1]);\n       retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n     }\n-          \n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;"}, {"sha": "389c37550ff4abcc3b6912938537352419358bef", "filename": "libgfortran/generated/count_4_l4.c", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fcount_4_l4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fcount_4_l4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcount_4_l4.c?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -55,11 +55,8 @@ count_4_l4 (gfc_array_i4 *retarray, gfc_array_l4 *array, index_type *pdim)\n   /* Make dim zero based to avoid confusion.  */\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   delta = array->dim[dim].stride;\n@@ -93,8 +90,17 @@ count_4_l4 (gfc_array_i4 *retarray, gfc_array_l4 *array, index_type *pdim)\n \t\t \t\t * retarray->dim[rank-1].stride\n \t\t\t\t * extent[rank-1]);\n       retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n     }\n-          \n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;"}, {"sha": "44e75eb362e949f92f3f5e0dddc81a2d09f957fb", "filename": "libgfortran/generated/count_4_l8.c", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fcount_4_l8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fcount_4_l8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcount_4_l8.c?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -55,11 +55,8 @@ count_4_l8 (gfc_array_i4 *retarray, gfc_array_l8 *array, index_type *pdim)\n   /* Make dim zero based to avoid confusion.  */\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   delta = array->dim[dim].stride;\n@@ -93,8 +90,17 @@ count_4_l8 (gfc_array_i4 *retarray, gfc_array_l8 *array, index_type *pdim)\n \t\t \t\t * retarray->dim[rank-1].stride\n \t\t\t\t * extent[rank-1]);\n       retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n     }\n-          \n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;"}, {"sha": "33fba4ce4eeda1ecef5ea9f313ec92c3d44d104e", "filename": "libgfortran/generated/count_8_l4.c", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fcount_8_l4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fcount_8_l4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcount_8_l4.c?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -55,11 +55,8 @@ count_8_l4 (gfc_array_i8 *retarray, gfc_array_l4 *array, index_type *pdim)\n   /* Make dim zero based to avoid confusion.  */\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   delta = array->dim[dim].stride;\n@@ -93,8 +90,17 @@ count_8_l4 (gfc_array_i8 *retarray, gfc_array_l4 *array, index_type *pdim)\n \t\t \t\t * retarray->dim[rank-1].stride\n \t\t\t\t * extent[rank-1]);\n       retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n     }\n-          \n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;"}, {"sha": "a867922b6dc5c01ce3b4991844072a4a5d839836", "filename": "libgfortran/generated/count_8_l8.c", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fcount_8_l8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fcount_8_l8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcount_8_l8.c?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -55,11 +55,8 @@ count_8_l8 (gfc_array_i8 *retarray, gfc_array_l8 *array, index_type *pdim)\n   /* Make dim zero based to avoid confusion.  */\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   delta = array->dim[dim].stride;\n@@ -93,8 +90,17 @@ count_8_l8 (gfc_array_i8 *retarray, gfc_array_l8 *array, index_type *pdim)\n \t\t \t\t * retarray->dim[rank-1].stride\n \t\t\t\t * extent[rank-1]);\n       retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n     }\n-          \n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;"}, {"sha": "a483c432234ac8a2f0a482950774c0ac1f5d515a", "filename": "libgfortran/generated/maxloc0_4_i4.c", "status": "modified", "additions": 46, "deletions": 13, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fmaxloc0_4_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fmaxloc0_4_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_i4.c?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -53,13 +53,31 @@ maxloc0_4_i4 (gfc_array_i4 * retarray, gfc_array_i4 *array)\n   index_type n;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n-  assert (rank > 0);\n-  assert (GFC_DESCRIPTOR_RANK (retarray) == 1);\n-  assert (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound == rank);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->base = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n@@ -150,17 +168,32 @@ mmaxloc0_4_i4 (gfc_array_i4 * retarray, gfc_array_i4 *array,\n   index_type n;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n-  assert (rank > 0);\n-  assert (GFC_DESCRIPTOR_RANK (retarray) == 1);\n-  assert (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound == rank);\n-  assert (GFC_DESCRIPTOR_RANK (mask) == rank);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->base = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n \n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;"}, {"sha": "ced6d6a2fe1a155fd59638d2794e5488649e4cbb", "filename": "libgfortran/generated/maxloc0_4_i8.c", "status": "modified", "additions": 46, "deletions": 13, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fmaxloc0_4_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fmaxloc0_4_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_i8.c?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -53,13 +53,31 @@ maxloc0_4_i8 (gfc_array_i4 * retarray, gfc_array_i8 *array)\n   index_type n;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n-  assert (rank > 0);\n-  assert (GFC_DESCRIPTOR_RANK (retarray) == 1);\n-  assert (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound == rank);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->base = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n@@ -150,17 +168,32 @@ mmaxloc0_4_i8 (gfc_array_i4 * retarray, gfc_array_i8 *array,\n   index_type n;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n-  assert (rank > 0);\n-  assert (GFC_DESCRIPTOR_RANK (retarray) == 1);\n-  assert (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound == rank);\n-  assert (GFC_DESCRIPTOR_RANK (mask) == rank);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->base = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n \n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;"}, {"sha": "06eb04c31e6c47d794d953930dabb52585c492e3", "filename": "libgfortran/generated/maxloc0_4_r4.c", "status": "modified", "additions": 46, "deletions": 13, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fmaxloc0_4_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fmaxloc0_4_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_r4.c?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -53,13 +53,31 @@ maxloc0_4_r4 (gfc_array_i4 * retarray, gfc_array_r4 *array)\n   index_type n;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n-  assert (rank > 0);\n-  assert (GFC_DESCRIPTOR_RANK (retarray) == 1);\n-  assert (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound == rank);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->base = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n@@ -150,17 +168,32 @@ mmaxloc0_4_r4 (gfc_array_i4 * retarray, gfc_array_r4 *array,\n   index_type n;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n-  assert (rank > 0);\n-  assert (GFC_DESCRIPTOR_RANK (retarray) == 1);\n-  assert (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound == rank);\n-  assert (GFC_DESCRIPTOR_RANK (mask) == rank);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->base = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n \n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;"}, {"sha": "791321815bb7588ad26141b8b20fa9393c3a2608", "filename": "libgfortran/generated/maxloc0_4_r8.c", "status": "modified", "additions": 46, "deletions": 13, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fmaxloc0_4_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fmaxloc0_4_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_r8.c?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -53,13 +53,31 @@ maxloc0_4_r8 (gfc_array_i4 * retarray, gfc_array_r8 *array)\n   index_type n;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n-  assert (rank > 0);\n-  assert (GFC_DESCRIPTOR_RANK (retarray) == 1);\n-  assert (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound == rank);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->base = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n@@ -150,17 +168,32 @@ mmaxloc0_4_r8 (gfc_array_i4 * retarray, gfc_array_r8 *array,\n   index_type n;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n-  assert (rank > 0);\n-  assert (GFC_DESCRIPTOR_RANK (retarray) == 1);\n-  assert (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound == rank);\n-  assert (GFC_DESCRIPTOR_RANK (mask) == rank);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->base = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n \n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;"}, {"sha": "49d370d73237455e86001bfc526a06b7e1928c79", "filename": "libgfortran/generated/maxloc0_8_i4.c", "status": "modified", "additions": 46, "deletions": 13, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fmaxloc0_8_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fmaxloc0_8_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_i4.c?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -53,13 +53,31 @@ maxloc0_8_i4 (gfc_array_i8 * retarray, gfc_array_i4 *array)\n   index_type n;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n-  assert (rank > 0);\n-  assert (GFC_DESCRIPTOR_RANK (retarray) == 1);\n-  assert (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound == rank);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->base = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n@@ -150,17 +168,32 @@ mmaxloc0_8_i4 (gfc_array_i8 * retarray, gfc_array_i4 *array,\n   index_type n;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n-  assert (rank > 0);\n-  assert (GFC_DESCRIPTOR_RANK (retarray) == 1);\n-  assert (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound == rank);\n-  assert (GFC_DESCRIPTOR_RANK (mask) == rank);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->base = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n \n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;"}, {"sha": "100c011d96727a8d9efcd98035785b53e1c67570", "filename": "libgfortran/generated/maxloc0_8_i8.c", "status": "modified", "additions": 46, "deletions": 13, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fmaxloc0_8_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fmaxloc0_8_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_i8.c?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -53,13 +53,31 @@ maxloc0_8_i8 (gfc_array_i8 * retarray, gfc_array_i8 *array)\n   index_type n;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n-  assert (rank > 0);\n-  assert (GFC_DESCRIPTOR_RANK (retarray) == 1);\n-  assert (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound == rank);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->base = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n@@ -150,17 +168,32 @@ mmaxloc0_8_i8 (gfc_array_i8 * retarray, gfc_array_i8 *array,\n   index_type n;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n-  assert (rank > 0);\n-  assert (GFC_DESCRIPTOR_RANK (retarray) == 1);\n-  assert (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound == rank);\n-  assert (GFC_DESCRIPTOR_RANK (mask) == rank);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->base = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n \n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;"}, {"sha": "4cf8364d882d909959b691454511b33d48ec1a14", "filename": "libgfortran/generated/maxloc0_8_r4.c", "status": "modified", "additions": 46, "deletions": 13, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fmaxloc0_8_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fmaxloc0_8_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_r4.c?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -53,13 +53,31 @@ maxloc0_8_r4 (gfc_array_i8 * retarray, gfc_array_r4 *array)\n   index_type n;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n-  assert (rank > 0);\n-  assert (GFC_DESCRIPTOR_RANK (retarray) == 1);\n-  assert (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound == rank);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->base = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n@@ -150,17 +168,32 @@ mmaxloc0_8_r4 (gfc_array_i8 * retarray, gfc_array_r4 *array,\n   index_type n;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n-  assert (rank > 0);\n-  assert (GFC_DESCRIPTOR_RANK (retarray) == 1);\n-  assert (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound == rank);\n-  assert (GFC_DESCRIPTOR_RANK (mask) == rank);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->base = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n \n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;"}, {"sha": "1a0cceee555c6ef135b2ee092e98db35fb379285", "filename": "libgfortran/generated/maxloc0_8_r8.c", "status": "modified", "additions": 46, "deletions": 13, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fmaxloc0_8_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fmaxloc0_8_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_r8.c?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -53,13 +53,31 @@ maxloc0_8_r8 (gfc_array_i8 * retarray, gfc_array_r8 *array)\n   index_type n;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n-  assert (rank > 0);\n-  assert (GFC_DESCRIPTOR_RANK (retarray) == 1);\n-  assert (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound == rank);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->base = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n@@ -150,17 +168,32 @@ mmaxloc0_8_r8 (gfc_array_i8 * retarray, gfc_array_r8 *array,\n   index_type n;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n-  assert (rank > 0);\n-  assert (GFC_DESCRIPTOR_RANK (retarray) == 1);\n-  assert (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound == rank);\n-  assert (GFC_DESCRIPTOR_RANK (mask) == rank);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->base = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n \n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;"}, {"sha": "38c6836aa3dd5bbe20cf35b4795382ba96f85acc", "filename": "libgfortran/generated/maxloc1_4_i4.c", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fmaxloc1_4_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fmaxloc1_4_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_i4.c?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -57,11 +57,8 @@ maxloc1_4_i4 (gfc_array_i4 *retarray, gfc_array_i4 *array, index_type *pdim)\n   /* Make dim zero based to avoid confusion.  */\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   delta = array->dim[dim].stride;\n@@ -95,8 +92,17 @@ maxloc1_4_i4 (gfc_array_i4 *retarray, gfc_array_i4 *array, index_type *pdim)\n \t\t \t\t * retarray->dim[rank-1].stride\n \t\t\t\t * extent[rank-1]);\n       retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n     }\n-          \n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n@@ -191,11 +197,8 @@ mmaxloc1_4_i4 (gfc_array_i4 * retarray, gfc_array_i4 * array,\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n@@ -217,6 +220,34 @@ mmaxloc1_4_i4 (gfc_array_i4 * retarray, gfc_array_i4 * array,\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n     }\n \n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_INTEGER_4)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;"}, {"sha": "9c6c7320255a680215ad62a3442d8234f2738796", "filename": "libgfortran/generated/maxloc1_4_i8.c", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fmaxloc1_4_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fmaxloc1_4_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_i8.c?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -57,11 +57,8 @@ maxloc1_4_i8 (gfc_array_i4 *retarray, gfc_array_i8 *array, index_type *pdim)\n   /* Make dim zero based to avoid confusion.  */\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   delta = array->dim[dim].stride;\n@@ -95,8 +92,17 @@ maxloc1_4_i8 (gfc_array_i4 *retarray, gfc_array_i8 *array, index_type *pdim)\n \t\t \t\t * retarray->dim[rank-1].stride\n \t\t\t\t * extent[rank-1]);\n       retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n     }\n-          \n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n@@ -191,11 +197,8 @@ mmaxloc1_4_i8 (gfc_array_i4 * retarray, gfc_array_i8 * array,\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n@@ -217,6 +220,34 @@ mmaxloc1_4_i8 (gfc_array_i4 * retarray, gfc_array_i8 * array,\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n     }\n \n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_INTEGER_4)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;"}, {"sha": "4048d2bc65ac55bdf92225614965819906f28ba1", "filename": "libgfortran/generated/maxloc1_4_r4.c", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fmaxloc1_4_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fmaxloc1_4_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_r4.c?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -57,11 +57,8 @@ maxloc1_4_r4 (gfc_array_i4 *retarray, gfc_array_r4 *array, index_type *pdim)\n   /* Make dim zero based to avoid confusion.  */\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   delta = array->dim[dim].stride;\n@@ -95,8 +92,17 @@ maxloc1_4_r4 (gfc_array_i4 *retarray, gfc_array_r4 *array, index_type *pdim)\n \t\t \t\t * retarray->dim[rank-1].stride\n \t\t\t\t * extent[rank-1]);\n       retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n     }\n-          \n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n@@ -191,11 +197,8 @@ mmaxloc1_4_r4 (gfc_array_i4 * retarray, gfc_array_r4 * array,\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n@@ -217,6 +220,34 @@ mmaxloc1_4_r4 (gfc_array_i4 * retarray, gfc_array_r4 * array,\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n     }\n \n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_INTEGER_4)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;"}, {"sha": "f27a1df413745681a6bf703c36dadd4e040eb50f", "filename": "libgfortran/generated/maxloc1_4_r8.c", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fmaxloc1_4_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fmaxloc1_4_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_r8.c?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -57,11 +57,8 @@ maxloc1_4_r8 (gfc_array_i4 *retarray, gfc_array_r8 *array, index_type *pdim)\n   /* Make dim zero based to avoid confusion.  */\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   delta = array->dim[dim].stride;\n@@ -95,8 +92,17 @@ maxloc1_4_r8 (gfc_array_i4 *retarray, gfc_array_r8 *array, index_type *pdim)\n \t\t \t\t * retarray->dim[rank-1].stride\n \t\t\t\t * extent[rank-1]);\n       retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n     }\n-          \n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n@@ -191,11 +197,8 @@ mmaxloc1_4_r8 (gfc_array_i4 * retarray, gfc_array_r8 * array,\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n@@ -217,6 +220,34 @@ mmaxloc1_4_r8 (gfc_array_i4 * retarray, gfc_array_r8 * array,\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n     }\n \n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_INTEGER_4)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;"}, {"sha": "448c9f9bd16d5269bfcec7259a2dda3801c9b4bd", "filename": "libgfortran/generated/maxloc1_8_i4.c", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fmaxloc1_8_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fmaxloc1_8_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_i4.c?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -57,11 +57,8 @@ maxloc1_8_i4 (gfc_array_i8 *retarray, gfc_array_i4 *array, index_type *pdim)\n   /* Make dim zero based to avoid confusion.  */\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   delta = array->dim[dim].stride;\n@@ -95,8 +92,17 @@ maxloc1_8_i4 (gfc_array_i8 *retarray, gfc_array_i4 *array, index_type *pdim)\n \t\t \t\t * retarray->dim[rank-1].stride\n \t\t\t\t * extent[rank-1]);\n       retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n     }\n-          \n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n@@ -191,11 +197,8 @@ mmaxloc1_8_i4 (gfc_array_i8 * retarray, gfc_array_i4 * array,\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n@@ -217,6 +220,34 @@ mmaxloc1_8_i4 (gfc_array_i8 * retarray, gfc_array_i4 * array,\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n     }\n \n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_INTEGER_8)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;"}, {"sha": "fb91a6a05ce49f80a3d1833f9748b84b75ac836d", "filename": "libgfortran/generated/maxloc1_8_i8.c", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fmaxloc1_8_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fmaxloc1_8_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_i8.c?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -57,11 +57,8 @@ maxloc1_8_i8 (gfc_array_i8 *retarray, gfc_array_i8 *array, index_type *pdim)\n   /* Make dim zero based to avoid confusion.  */\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   delta = array->dim[dim].stride;\n@@ -95,8 +92,17 @@ maxloc1_8_i8 (gfc_array_i8 *retarray, gfc_array_i8 *array, index_type *pdim)\n \t\t \t\t * retarray->dim[rank-1].stride\n \t\t\t\t * extent[rank-1]);\n       retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n     }\n-          \n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n@@ -191,11 +197,8 @@ mmaxloc1_8_i8 (gfc_array_i8 * retarray, gfc_array_i8 * array,\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n@@ -217,6 +220,34 @@ mmaxloc1_8_i8 (gfc_array_i8 * retarray, gfc_array_i8 * array,\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n     }\n \n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_INTEGER_8)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;"}, {"sha": "33159fb28b39e35fb9e5459951e0fd44f3c22bf9", "filename": "libgfortran/generated/maxloc1_8_r4.c", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fmaxloc1_8_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fmaxloc1_8_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_r4.c?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -57,11 +57,8 @@ maxloc1_8_r4 (gfc_array_i8 *retarray, gfc_array_r4 *array, index_type *pdim)\n   /* Make dim zero based to avoid confusion.  */\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   delta = array->dim[dim].stride;\n@@ -95,8 +92,17 @@ maxloc1_8_r4 (gfc_array_i8 *retarray, gfc_array_r4 *array, index_type *pdim)\n \t\t \t\t * retarray->dim[rank-1].stride\n \t\t\t\t * extent[rank-1]);\n       retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n     }\n-          \n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n@@ -191,11 +197,8 @@ mmaxloc1_8_r4 (gfc_array_i8 * retarray, gfc_array_r4 * array,\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n@@ -217,6 +220,34 @@ mmaxloc1_8_r4 (gfc_array_i8 * retarray, gfc_array_r4 * array,\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n     }\n \n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_INTEGER_8)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;"}, {"sha": "b1f780567daabd326fef3a995841b82985ec122d", "filename": "libgfortran/generated/maxloc1_8_r8.c", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fmaxloc1_8_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fmaxloc1_8_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_r8.c?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -57,11 +57,8 @@ maxloc1_8_r8 (gfc_array_i8 *retarray, gfc_array_r8 *array, index_type *pdim)\n   /* Make dim zero based to avoid confusion.  */\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   delta = array->dim[dim].stride;\n@@ -95,8 +92,17 @@ maxloc1_8_r8 (gfc_array_i8 *retarray, gfc_array_r8 *array, index_type *pdim)\n \t\t \t\t * retarray->dim[rank-1].stride\n \t\t\t\t * extent[rank-1]);\n       retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n     }\n-          \n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n@@ -191,11 +197,8 @@ mmaxloc1_8_r8 (gfc_array_i8 * retarray, gfc_array_r8 * array,\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n@@ -217,6 +220,34 @@ mmaxloc1_8_r8 (gfc_array_i8 * retarray, gfc_array_r8 * array,\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n     }\n \n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_INTEGER_8)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;"}, {"sha": "e992327dd22637a5e646e8efb0398af9eaed3392", "filename": "libgfortran/generated/maxval_i4.c", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fmaxval_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fmaxval_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_i4.c?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -56,11 +56,8 @@ maxval_i4 (gfc_array_i4 *retarray, gfc_array_i4 *array, index_type *pdim)\n   /* Make dim zero based to avoid confusion.  */\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   delta = array->dim[dim].stride;\n@@ -94,8 +91,17 @@ maxval_i4 (gfc_array_i4 *retarray, gfc_array_i4 *array, index_type *pdim)\n \t\t \t\t * retarray->dim[rank-1].stride\n \t\t\t\t * extent[rank-1]);\n       retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n     }\n-          \n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n@@ -185,11 +191,8 @@ mmaxval_i4 (gfc_array_i4 * retarray, gfc_array_i4 * array,\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n@@ -211,6 +214,34 @@ mmaxval_i4 (gfc_array_i4 * retarray, gfc_array_i4 * array,\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n     }\n \n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_INTEGER_4)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;"}, {"sha": "3e60377155382e89cb7a26bbf1f55098c7269edb", "filename": "libgfortran/generated/maxval_i8.c", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fmaxval_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fmaxval_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_i8.c?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -56,11 +56,8 @@ maxval_i8 (gfc_array_i8 *retarray, gfc_array_i8 *array, index_type *pdim)\n   /* Make dim zero based to avoid confusion.  */\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   delta = array->dim[dim].stride;\n@@ -94,8 +91,17 @@ maxval_i8 (gfc_array_i8 *retarray, gfc_array_i8 *array, index_type *pdim)\n \t\t \t\t * retarray->dim[rank-1].stride\n \t\t\t\t * extent[rank-1]);\n       retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n     }\n-          \n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n@@ -185,11 +191,8 @@ mmaxval_i8 (gfc_array_i8 * retarray, gfc_array_i8 * array,\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n@@ -211,6 +214,34 @@ mmaxval_i8 (gfc_array_i8 * retarray, gfc_array_i8 * array,\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n     }\n \n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_INTEGER_8)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;"}, {"sha": "8e94efbfe91bd98b3db18af3794aa5cc748642f8", "filename": "libgfortran/generated/maxval_r4.c", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fmaxval_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fmaxval_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_r4.c?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -56,11 +56,8 @@ maxval_r4 (gfc_array_r4 *retarray, gfc_array_r4 *array, index_type *pdim)\n   /* Make dim zero based to avoid confusion.  */\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   delta = array->dim[dim].stride;\n@@ -94,8 +91,17 @@ maxval_r4 (gfc_array_r4 *retarray, gfc_array_r4 *array, index_type *pdim)\n \t\t \t\t * retarray->dim[rank-1].stride\n \t\t\t\t * extent[rank-1]);\n       retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n     }\n-          \n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n@@ -185,11 +191,8 @@ mmaxval_r4 (gfc_array_r4 * retarray, gfc_array_r4 * array,\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n@@ -211,6 +214,34 @@ mmaxval_r4 (gfc_array_r4 * retarray, gfc_array_r4 * array,\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n     }\n \n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_REAL_4)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;"}, {"sha": "40a3575a793aeddbf7ee6283c02b4d384023d783", "filename": "libgfortran/generated/maxval_r8.c", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fmaxval_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fmaxval_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_r8.c?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -56,11 +56,8 @@ maxval_r8 (gfc_array_r8 *retarray, gfc_array_r8 *array, index_type *pdim)\n   /* Make dim zero based to avoid confusion.  */\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   delta = array->dim[dim].stride;\n@@ -94,8 +91,17 @@ maxval_r8 (gfc_array_r8 *retarray, gfc_array_r8 *array, index_type *pdim)\n \t\t \t\t * retarray->dim[rank-1].stride\n \t\t\t\t * extent[rank-1]);\n       retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n     }\n-          \n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n@@ -185,11 +191,8 @@ mmaxval_r8 (gfc_array_r8 * retarray, gfc_array_r8 * array,\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n@@ -211,6 +214,34 @@ mmaxval_r8 (gfc_array_r8 * retarray, gfc_array_r8 * array,\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n     }\n \n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_REAL_8)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;"}, {"sha": "178bf5af5dfd52cb5d72cbf931aa2e48d54119d6", "filename": "libgfortran/generated/minloc0_4_i4.c", "status": "modified", "additions": 46, "deletions": 13, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fminloc0_4_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fminloc0_4_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_i4.c?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -53,13 +53,31 @@ minloc0_4_i4 (gfc_array_i4 * retarray, gfc_array_i4 *array)\n   index_type n;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n-  assert (rank > 0);\n-  assert (GFC_DESCRIPTOR_RANK (retarray) == 1);\n-  assert (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound == rank);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->base = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n@@ -150,17 +168,32 @@ mminloc0_4_i4 (gfc_array_i4 * retarray, gfc_array_i4 *array,\n   index_type n;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n-  assert (rank > 0);\n-  assert (GFC_DESCRIPTOR_RANK (retarray) == 1);\n-  assert (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound == rank);\n-  assert (GFC_DESCRIPTOR_RANK (mask) == rank);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->base = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n \n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;"}, {"sha": "d87a444c96cb438587192dcccf594194567d3573", "filename": "libgfortran/generated/minloc0_4_i8.c", "status": "modified", "additions": 46, "deletions": 13, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fminloc0_4_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fminloc0_4_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_i8.c?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -53,13 +53,31 @@ minloc0_4_i8 (gfc_array_i4 * retarray, gfc_array_i8 *array)\n   index_type n;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n-  assert (rank > 0);\n-  assert (GFC_DESCRIPTOR_RANK (retarray) == 1);\n-  assert (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound == rank);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->base = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n@@ -150,17 +168,32 @@ mminloc0_4_i8 (gfc_array_i4 * retarray, gfc_array_i8 *array,\n   index_type n;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n-  assert (rank > 0);\n-  assert (GFC_DESCRIPTOR_RANK (retarray) == 1);\n-  assert (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound == rank);\n-  assert (GFC_DESCRIPTOR_RANK (mask) == rank);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->base = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n \n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;"}, {"sha": "21c9edf451e24b2112cd428eb0179af0ff537902", "filename": "libgfortran/generated/minloc0_4_r4.c", "status": "modified", "additions": 46, "deletions": 13, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fminloc0_4_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fminloc0_4_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_r4.c?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -53,13 +53,31 @@ minloc0_4_r4 (gfc_array_i4 * retarray, gfc_array_r4 *array)\n   index_type n;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n-  assert (rank > 0);\n-  assert (GFC_DESCRIPTOR_RANK (retarray) == 1);\n-  assert (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound == rank);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->base = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n@@ -150,17 +168,32 @@ mminloc0_4_r4 (gfc_array_i4 * retarray, gfc_array_r4 *array,\n   index_type n;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n-  assert (rank > 0);\n-  assert (GFC_DESCRIPTOR_RANK (retarray) == 1);\n-  assert (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound == rank);\n-  assert (GFC_DESCRIPTOR_RANK (mask) == rank);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->base = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n \n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;"}, {"sha": "a00d0135e872b68551789fb58dac4af3c21c3b58", "filename": "libgfortran/generated/minloc0_4_r8.c", "status": "modified", "additions": 46, "deletions": 13, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fminloc0_4_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fminloc0_4_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_r8.c?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -53,13 +53,31 @@ minloc0_4_r8 (gfc_array_i4 * retarray, gfc_array_r8 *array)\n   index_type n;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n-  assert (rank > 0);\n-  assert (GFC_DESCRIPTOR_RANK (retarray) == 1);\n-  assert (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound == rank);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->base = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n@@ -150,17 +168,32 @@ mminloc0_4_r8 (gfc_array_i4 * retarray, gfc_array_r8 *array,\n   index_type n;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n-  assert (rank > 0);\n-  assert (GFC_DESCRIPTOR_RANK (retarray) == 1);\n-  assert (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound == rank);\n-  assert (GFC_DESCRIPTOR_RANK (mask) == rank);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->base = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n \n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;"}, {"sha": "340c54d8aee91f8c7114657ef5f7d6774372e750", "filename": "libgfortran/generated/minloc0_8_i4.c", "status": "modified", "additions": 46, "deletions": 13, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fminloc0_8_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fminloc0_8_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_i4.c?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -53,13 +53,31 @@ minloc0_8_i4 (gfc_array_i8 * retarray, gfc_array_i4 *array)\n   index_type n;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n-  assert (rank > 0);\n-  assert (GFC_DESCRIPTOR_RANK (retarray) == 1);\n-  assert (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound == rank);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->base = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n@@ -150,17 +168,32 @@ mminloc0_8_i4 (gfc_array_i8 * retarray, gfc_array_i4 *array,\n   index_type n;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n-  assert (rank > 0);\n-  assert (GFC_DESCRIPTOR_RANK (retarray) == 1);\n-  assert (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound == rank);\n-  assert (GFC_DESCRIPTOR_RANK (mask) == rank);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->base = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n \n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;"}, {"sha": "5941eb4c4b18b921ac5a007cda0b2873d128b558", "filename": "libgfortran/generated/minloc0_8_i8.c", "status": "modified", "additions": 46, "deletions": 13, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fminloc0_8_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fminloc0_8_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_i8.c?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -53,13 +53,31 @@ minloc0_8_i8 (gfc_array_i8 * retarray, gfc_array_i8 *array)\n   index_type n;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n-  assert (rank > 0);\n-  assert (GFC_DESCRIPTOR_RANK (retarray) == 1);\n-  assert (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound == rank);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->base = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n@@ -150,17 +168,32 @@ mminloc0_8_i8 (gfc_array_i8 * retarray, gfc_array_i8 *array,\n   index_type n;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n-  assert (rank > 0);\n-  assert (GFC_DESCRIPTOR_RANK (retarray) == 1);\n-  assert (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound == rank);\n-  assert (GFC_DESCRIPTOR_RANK (mask) == rank);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->base = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n \n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;"}, {"sha": "9900bc98ed5c83a901a8297becd9b2d2a358c837", "filename": "libgfortran/generated/minloc0_8_r4.c", "status": "modified", "additions": 46, "deletions": 13, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fminloc0_8_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fminloc0_8_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_r4.c?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -53,13 +53,31 @@ minloc0_8_r4 (gfc_array_i8 * retarray, gfc_array_r4 *array)\n   index_type n;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n-  assert (rank > 0);\n-  assert (GFC_DESCRIPTOR_RANK (retarray) == 1);\n-  assert (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound == rank);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->base = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n@@ -150,17 +168,32 @@ mminloc0_8_r4 (gfc_array_i8 * retarray, gfc_array_r4 *array,\n   index_type n;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n-  assert (rank > 0);\n-  assert (GFC_DESCRIPTOR_RANK (retarray) == 1);\n-  assert (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound == rank);\n-  assert (GFC_DESCRIPTOR_RANK (mask) == rank);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->base = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n \n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;"}, {"sha": "d1caf2a181c434715529f8ddacd2536952f6978c", "filename": "libgfortran/generated/minloc0_8_r8.c", "status": "modified", "additions": 46, "deletions": 13, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fminloc0_8_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fminloc0_8_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_r8.c?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -53,13 +53,31 @@ minloc0_8_r8 (gfc_array_i8 * retarray, gfc_array_r8 *array)\n   index_type n;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n-  assert (rank > 0);\n-  assert (GFC_DESCRIPTOR_RANK (retarray) == 1);\n-  assert (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound == rank);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->base = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n@@ -150,17 +168,32 @@ mminloc0_8_r8 (gfc_array_i8 * retarray, gfc_array_r8 *array,\n   index_type n;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n-  assert (rank > 0);\n-  assert (GFC_DESCRIPTOR_RANK (retarray) == 1);\n-  assert (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound == rank);\n-  assert (GFC_DESCRIPTOR_RANK (mask) == rank);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->base = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n \n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;"}, {"sha": "76f082ba61321306879b538af576b17ec3efcd85", "filename": "libgfortran/generated/minloc1_4_i4.c", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fminloc1_4_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fminloc1_4_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_i4.c?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -57,11 +57,8 @@ minloc1_4_i4 (gfc_array_i4 *retarray, gfc_array_i4 *array, index_type *pdim)\n   /* Make dim zero based to avoid confusion.  */\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   delta = array->dim[dim].stride;\n@@ -95,8 +92,17 @@ minloc1_4_i4 (gfc_array_i4 *retarray, gfc_array_i4 *array, index_type *pdim)\n \t\t \t\t * retarray->dim[rank-1].stride\n \t\t\t\t * extent[rank-1]);\n       retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n     }\n-          \n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n@@ -191,11 +197,8 @@ mminloc1_4_i4 (gfc_array_i4 * retarray, gfc_array_i4 * array,\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n@@ -217,6 +220,34 @@ mminloc1_4_i4 (gfc_array_i4 * retarray, gfc_array_i4 * array,\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n     }\n \n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_INTEGER_4)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;"}, {"sha": "358b4fa88b431d05fee4feb29a09537dc1dd643f", "filename": "libgfortran/generated/minloc1_4_i8.c", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fminloc1_4_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fminloc1_4_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_i8.c?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -57,11 +57,8 @@ minloc1_4_i8 (gfc_array_i4 *retarray, gfc_array_i8 *array, index_type *pdim)\n   /* Make dim zero based to avoid confusion.  */\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   delta = array->dim[dim].stride;\n@@ -95,8 +92,17 @@ minloc1_4_i8 (gfc_array_i4 *retarray, gfc_array_i8 *array, index_type *pdim)\n \t\t \t\t * retarray->dim[rank-1].stride\n \t\t\t\t * extent[rank-1]);\n       retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n     }\n-          \n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n@@ -191,11 +197,8 @@ mminloc1_4_i8 (gfc_array_i4 * retarray, gfc_array_i8 * array,\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n@@ -217,6 +220,34 @@ mminloc1_4_i8 (gfc_array_i4 * retarray, gfc_array_i8 * array,\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n     }\n \n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_INTEGER_4)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;"}, {"sha": "b61e6b5bb0f944e47181d1a0f2ee57453152e300", "filename": "libgfortran/generated/minloc1_4_r4.c", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fminloc1_4_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fminloc1_4_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_r4.c?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -57,11 +57,8 @@ minloc1_4_r4 (gfc_array_i4 *retarray, gfc_array_r4 *array, index_type *pdim)\n   /* Make dim zero based to avoid confusion.  */\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   delta = array->dim[dim].stride;\n@@ -95,8 +92,17 @@ minloc1_4_r4 (gfc_array_i4 *retarray, gfc_array_r4 *array, index_type *pdim)\n \t\t \t\t * retarray->dim[rank-1].stride\n \t\t\t\t * extent[rank-1]);\n       retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n     }\n-          \n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n@@ -191,11 +197,8 @@ mminloc1_4_r4 (gfc_array_i4 * retarray, gfc_array_r4 * array,\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n@@ -217,6 +220,34 @@ mminloc1_4_r4 (gfc_array_i4 * retarray, gfc_array_r4 * array,\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n     }\n \n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_INTEGER_4)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;"}, {"sha": "65c1fac6e2885bbf82d9424392ffde2e90311b38", "filename": "libgfortran/generated/minloc1_4_r8.c", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fminloc1_4_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fminloc1_4_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_r8.c?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -57,11 +57,8 @@ minloc1_4_r8 (gfc_array_i4 *retarray, gfc_array_r8 *array, index_type *pdim)\n   /* Make dim zero based to avoid confusion.  */\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   delta = array->dim[dim].stride;\n@@ -95,8 +92,17 @@ minloc1_4_r8 (gfc_array_i4 *retarray, gfc_array_r8 *array, index_type *pdim)\n \t\t \t\t * retarray->dim[rank-1].stride\n \t\t\t\t * extent[rank-1]);\n       retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n     }\n-          \n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n@@ -191,11 +197,8 @@ mminloc1_4_r8 (gfc_array_i4 * retarray, gfc_array_r8 * array,\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n@@ -217,6 +220,34 @@ mminloc1_4_r8 (gfc_array_i4 * retarray, gfc_array_r8 * array,\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n     }\n \n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_INTEGER_4)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;"}, {"sha": "a428c919c6c7a22413989bfdff136074d077c70f", "filename": "libgfortran/generated/minloc1_8_i4.c", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fminloc1_8_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fminloc1_8_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_i4.c?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -57,11 +57,8 @@ minloc1_8_i4 (gfc_array_i8 *retarray, gfc_array_i4 *array, index_type *pdim)\n   /* Make dim zero based to avoid confusion.  */\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   delta = array->dim[dim].stride;\n@@ -95,8 +92,17 @@ minloc1_8_i4 (gfc_array_i8 *retarray, gfc_array_i4 *array, index_type *pdim)\n \t\t \t\t * retarray->dim[rank-1].stride\n \t\t\t\t * extent[rank-1]);\n       retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n     }\n-          \n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n@@ -191,11 +197,8 @@ mminloc1_8_i4 (gfc_array_i8 * retarray, gfc_array_i4 * array,\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n@@ -217,6 +220,34 @@ mminloc1_8_i4 (gfc_array_i8 * retarray, gfc_array_i4 * array,\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n     }\n \n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_INTEGER_8)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;"}, {"sha": "fd7f8d6147f7b5a1729fd470bdb874751d768ae1", "filename": "libgfortran/generated/minloc1_8_i8.c", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fminloc1_8_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fminloc1_8_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_i8.c?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -57,11 +57,8 @@ minloc1_8_i8 (gfc_array_i8 *retarray, gfc_array_i8 *array, index_type *pdim)\n   /* Make dim zero based to avoid confusion.  */\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   delta = array->dim[dim].stride;\n@@ -95,8 +92,17 @@ minloc1_8_i8 (gfc_array_i8 *retarray, gfc_array_i8 *array, index_type *pdim)\n \t\t \t\t * retarray->dim[rank-1].stride\n \t\t\t\t * extent[rank-1]);\n       retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n     }\n-          \n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n@@ -191,11 +197,8 @@ mminloc1_8_i8 (gfc_array_i8 * retarray, gfc_array_i8 * array,\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n@@ -217,6 +220,34 @@ mminloc1_8_i8 (gfc_array_i8 * retarray, gfc_array_i8 * array,\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n     }\n \n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_INTEGER_8)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;"}, {"sha": "0f15fc44c8189b5ff3db05abfa015d7efa356f79", "filename": "libgfortran/generated/minloc1_8_r4.c", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fminloc1_8_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fminloc1_8_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_r4.c?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -57,11 +57,8 @@ minloc1_8_r4 (gfc_array_i8 *retarray, gfc_array_r4 *array, index_type *pdim)\n   /* Make dim zero based to avoid confusion.  */\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   delta = array->dim[dim].stride;\n@@ -95,8 +92,17 @@ minloc1_8_r4 (gfc_array_i8 *retarray, gfc_array_r4 *array, index_type *pdim)\n \t\t \t\t * retarray->dim[rank-1].stride\n \t\t\t\t * extent[rank-1]);\n       retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n     }\n-          \n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n@@ -191,11 +197,8 @@ mminloc1_8_r4 (gfc_array_i8 * retarray, gfc_array_r4 * array,\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n@@ -217,6 +220,34 @@ mminloc1_8_r4 (gfc_array_i8 * retarray, gfc_array_r4 * array,\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n     }\n \n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_INTEGER_8)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;"}, {"sha": "edd9a7191e69e5f55c1983334219d83a9c353bc1", "filename": "libgfortran/generated/minloc1_8_r8.c", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fminloc1_8_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fminloc1_8_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_r8.c?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -57,11 +57,8 @@ minloc1_8_r8 (gfc_array_i8 *retarray, gfc_array_r8 *array, index_type *pdim)\n   /* Make dim zero based to avoid confusion.  */\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   delta = array->dim[dim].stride;\n@@ -95,8 +92,17 @@ minloc1_8_r8 (gfc_array_i8 *retarray, gfc_array_r8 *array, index_type *pdim)\n \t\t \t\t * retarray->dim[rank-1].stride\n \t\t\t\t * extent[rank-1]);\n       retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n     }\n-          \n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n@@ -191,11 +197,8 @@ mminloc1_8_r8 (gfc_array_i8 * retarray, gfc_array_r8 * array,\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n@@ -217,6 +220,34 @@ mminloc1_8_r8 (gfc_array_i8 * retarray, gfc_array_r8 * array,\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n     }\n \n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_INTEGER_8)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;"}, {"sha": "69330111b9ad46bc1b048a1be52b34715dc14753", "filename": "libgfortran/generated/minval_i4.c", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fminval_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fminval_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_i4.c?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -56,11 +56,8 @@ minval_i4 (gfc_array_i4 *retarray, gfc_array_i4 *array, index_type *pdim)\n   /* Make dim zero based to avoid confusion.  */\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   delta = array->dim[dim].stride;\n@@ -94,8 +91,17 @@ minval_i4 (gfc_array_i4 *retarray, gfc_array_i4 *array, index_type *pdim)\n \t\t \t\t * retarray->dim[rank-1].stride\n \t\t\t\t * extent[rank-1]);\n       retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n     }\n-          \n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n@@ -185,11 +191,8 @@ mminval_i4 (gfc_array_i4 * retarray, gfc_array_i4 * array,\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n@@ -211,6 +214,34 @@ mminval_i4 (gfc_array_i4 * retarray, gfc_array_i4 * array,\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n     }\n \n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_INTEGER_4)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;"}, {"sha": "579e5f971813a043d3b338685cc18f1881887472", "filename": "libgfortran/generated/minval_i8.c", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fminval_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fminval_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_i8.c?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -56,11 +56,8 @@ minval_i8 (gfc_array_i8 *retarray, gfc_array_i8 *array, index_type *pdim)\n   /* Make dim zero based to avoid confusion.  */\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   delta = array->dim[dim].stride;\n@@ -94,8 +91,17 @@ minval_i8 (gfc_array_i8 *retarray, gfc_array_i8 *array, index_type *pdim)\n \t\t \t\t * retarray->dim[rank-1].stride\n \t\t\t\t * extent[rank-1]);\n       retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n     }\n-          \n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n@@ -185,11 +191,8 @@ mminval_i8 (gfc_array_i8 * retarray, gfc_array_i8 * array,\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n@@ -211,6 +214,34 @@ mminval_i8 (gfc_array_i8 * retarray, gfc_array_i8 * array,\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n     }\n \n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_INTEGER_8)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;"}, {"sha": "d936e2c871ed22a099dfe01e59bef2fa0348bd7f", "filename": "libgfortran/generated/minval_r4.c", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fminval_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fminval_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_r4.c?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -56,11 +56,8 @@ minval_r4 (gfc_array_r4 *retarray, gfc_array_r4 *array, index_type *pdim)\n   /* Make dim zero based to avoid confusion.  */\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   delta = array->dim[dim].stride;\n@@ -94,8 +91,17 @@ minval_r4 (gfc_array_r4 *retarray, gfc_array_r4 *array, index_type *pdim)\n \t\t \t\t * retarray->dim[rank-1].stride\n \t\t\t\t * extent[rank-1]);\n       retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n     }\n-          \n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n@@ -185,11 +191,8 @@ mminval_r4 (gfc_array_r4 * retarray, gfc_array_r4 * array,\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n@@ -211,6 +214,34 @@ mminval_r4 (gfc_array_r4 * retarray, gfc_array_r4 * array,\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n     }\n \n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_REAL_4)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;"}, {"sha": "a85e29efae26a9e78a9b97c5eb390c70398f4411", "filename": "libgfortran/generated/minval_r8.c", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fminval_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fminval_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_r8.c?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -56,11 +56,8 @@ minval_r8 (gfc_array_r8 *retarray, gfc_array_r8 *array, index_type *pdim)\n   /* Make dim zero based to avoid confusion.  */\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   delta = array->dim[dim].stride;\n@@ -94,8 +91,17 @@ minval_r8 (gfc_array_r8 *retarray, gfc_array_r8 *array, index_type *pdim)\n \t\t \t\t * retarray->dim[rank-1].stride\n \t\t\t\t * extent[rank-1]);\n       retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n     }\n-          \n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n@@ -185,11 +191,8 @@ mminval_r8 (gfc_array_r8 * retarray, gfc_array_r8 * array,\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n@@ -211,6 +214,34 @@ mminval_r8 (gfc_array_r8 * retarray, gfc_array_r8 * array,\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n     }\n \n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_REAL_8)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;"}, {"sha": "29604708812e64e90ff299591f1be4caa212b78f", "filename": "libgfortran/generated/product_c4.c", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fproduct_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fproduct_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_c4.c?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -55,11 +55,8 @@ product_c4 (gfc_array_c4 *retarray, gfc_array_c4 *array, index_type *pdim)\n   /* Make dim zero based to avoid confusion.  */\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   delta = array->dim[dim].stride;\n@@ -93,8 +90,17 @@ product_c4 (gfc_array_c4 *retarray, gfc_array_c4 *array, index_type *pdim)\n \t\t \t\t * retarray->dim[rank-1].stride\n \t\t\t\t * extent[rank-1]);\n       retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n     }\n-          \n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n@@ -183,11 +189,8 @@ mproduct_c4 (gfc_array_c4 * retarray, gfc_array_c4 * array,\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n@@ -209,6 +212,34 @@ mproduct_c4 (gfc_array_c4 * retarray, gfc_array_c4 * array,\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n     }\n \n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_COMPLEX_4)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;"}, {"sha": "fc3eccb11107f8ff31568dd483bc9c9c42944784", "filename": "libgfortran/generated/product_c8.c", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fproduct_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fproduct_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_c8.c?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -55,11 +55,8 @@ product_c8 (gfc_array_c8 *retarray, gfc_array_c8 *array, index_type *pdim)\n   /* Make dim zero based to avoid confusion.  */\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   delta = array->dim[dim].stride;\n@@ -93,8 +90,17 @@ product_c8 (gfc_array_c8 *retarray, gfc_array_c8 *array, index_type *pdim)\n \t\t \t\t * retarray->dim[rank-1].stride\n \t\t\t\t * extent[rank-1]);\n       retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n     }\n-          \n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n@@ -183,11 +189,8 @@ mproduct_c8 (gfc_array_c8 * retarray, gfc_array_c8 * array,\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n@@ -209,6 +212,34 @@ mproduct_c8 (gfc_array_c8 * retarray, gfc_array_c8 * array,\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n     }\n \n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_COMPLEX_8)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;"}, {"sha": "d349b66b1186bd4033c1c2d6f4932b6d6676553d", "filename": "libgfortran/generated/product_i4.c", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fproduct_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fproduct_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_i4.c?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -55,11 +55,8 @@ product_i4 (gfc_array_i4 *retarray, gfc_array_i4 *array, index_type *pdim)\n   /* Make dim zero based to avoid confusion.  */\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   delta = array->dim[dim].stride;\n@@ -93,8 +90,17 @@ product_i4 (gfc_array_i4 *retarray, gfc_array_i4 *array, index_type *pdim)\n \t\t \t\t * retarray->dim[rank-1].stride\n \t\t\t\t * extent[rank-1]);\n       retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n     }\n-          \n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n@@ -183,11 +189,8 @@ mproduct_i4 (gfc_array_i4 * retarray, gfc_array_i4 * array,\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n@@ -209,6 +212,34 @@ mproduct_i4 (gfc_array_i4 * retarray, gfc_array_i4 * array,\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n     }\n \n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_INTEGER_4)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;"}, {"sha": "1fe07458e0bab5d72e1974f1ba01d1a0f3974462", "filename": "libgfortran/generated/product_i8.c", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fproduct_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fproduct_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_i8.c?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -55,11 +55,8 @@ product_i8 (gfc_array_i8 *retarray, gfc_array_i8 *array, index_type *pdim)\n   /* Make dim zero based to avoid confusion.  */\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   delta = array->dim[dim].stride;\n@@ -93,8 +90,17 @@ product_i8 (gfc_array_i8 *retarray, gfc_array_i8 *array, index_type *pdim)\n \t\t \t\t * retarray->dim[rank-1].stride\n \t\t\t\t * extent[rank-1]);\n       retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n     }\n-          \n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n@@ -183,11 +189,8 @@ mproduct_i8 (gfc_array_i8 * retarray, gfc_array_i8 * array,\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n@@ -209,6 +212,34 @@ mproduct_i8 (gfc_array_i8 * retarray, gfc_array_i8 * array,\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n     }\n \n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_INTEGER_8)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;"}, {"sha": "592210d7705e9202d7a667890498f597588a4779", "filename": "libgfortran/generated/product_r4.c", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fproduct_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fproduct_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_r4.c?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -55,11 +55,8 @@ product_r4 (gfc_array_r4 *retarray, gfc_array_r4 *array, index_type *pdim)\n   /* Make dim zero based to avoid confusion.  */\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   delta = array->dim[dim].stride;\n@@ -93,8 +90,17 @@ product_r4 (gfc_array_r4 *retarray, gfc_array_r4 *array, index_type *pdim)\n \t\t \t\t * retarray->dim[rank-1].stride\n \t\t\t\t * extent[rank-1]);\n       retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n     }\n-          \n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n@@ -183,11 +189,8 @@ mproduct_r4 (gfc_array_r4 * retarray, gfc_array_r4 * array,\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n@@ -209,6 +212,34 @@ mproduct_r4 (gfc_array_r4 * retarray, gfc_array_r4 * array,\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n     }\n \n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_REAL_4)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;"}, {"sha": "922bcbe834e7c4708b1c979b0a0ab33c3804296d", "filename": "libgfortran/generated/product_r8.c", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fproduct_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fproduct_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_r8.c?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -55,11 +55,8 @@ product_r8 (gfc_array_r8 *retarray, gfc_array_r8 *array, index_type *pdim)\n   /* Make dim zero based to avoid confusion.  */\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   delta = array->dim[dim].stride;\n@@ -93,8 +90,17 @@ product_r8 (gfc_array_r8 *retarray, gfc_array_r8 *array, index_type *pdim)\n \t\t \t\t * retarray->dim[rank-1].stride\n \t\t\t\t * extent[rank-1]);\n       retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n     }\n-          \n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n@@ -183,11 +189,8 @@ mproduct_r8 (gfc_array_r8 * retarray, gfc_array_r8 * array,\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n@@ -209,6 +212,34 @@ mproduct_r8 (gfc_array_r8 * retarray, gfc_array_r8 * array,\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n     }\n \n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_REAL_8)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;"}, {"sha": "74efd07c65baca8e4e14d45f07a194f09d69b927", "filename": "libgfortran/generated/sum_c4.c", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fsum_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fsum_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_c4.c?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -55,11 +55,8 @@ sum_c4 (gfc_array_c4 *retarray, gfc_array_c4 *array, index_type *pdim)\n   /* Make dim zero based to avoid confusion.  */\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   delta = array->dim[dim].stride;\n@@ -93,8 +90,17 @@ sum_c4 (gfc_array_c4 *retarray, gfc_array_c4 *array, index_type *pdim)\n \t\t \t\t * retarray->dim[rank-1].stride\n \t\t\t\t * extent[rank-1]);\n       retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n     }\n-          \n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n@@ -183,11 +189,8 @@ msum_c4 (gfc_array_c4 * retarray, gfc_array_c4 * array,\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n@@ -209,6 +212,34 @@ msum_c4 (gfc_array_c4 * retarray, gfc_array_c4 * array,\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n     }\n \n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_COMPLEX_4)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;"}, {"sha": "7d688104d55e938e2e72df9d064af67e5ae22856", "filename": "libgfortran/generated/sum_c8.c", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fsum_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fsum_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_c8.c?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -55,11 +55,8 @@ sum_c8 (gfc_array_c8 *retarray, gfc_array_c8 *array, index_type *pdim)\n   /* Make dim zero based to avoid confusion.  */\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   delta = array->dim[dim].stride;\n@@ -93,8 +90,17 @@ sum_c8 (gfc_array_c8 *retarray, gfc_array_c8 *array, index_type *pdim)\n \t\t \t\t * retarray->dim[rank-1].stride\n \t\t\t\t * extent[rank-1]);\n       retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n     }\n-          \n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n@@ -183,11 +189,8 @@ msum_c8 (gfc_array_c8 * retarray, gfc_array_c8 * array,\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n@@ -209,6 +212,34 @@ msum_c8 (gfc_array_c8 * retarray, gfc_array_c8 * array,\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n     }\n \n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_COMPLEX_8)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;"}, {"sha": "01b41126746dd8e5874d122330617a00c7ff0207", "filename": "libgfortran/generated/sum_i4.c", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fsum_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fsum_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_i4.c?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -55,11 +55,8 @@ sum_i4 (gfc_array_i4 *retarray, gfc_array_i4 *array, index_type *pdim)\n   /* Make dim zero based to avoid confusion.  */\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   delta = array->dim[dim].stride;\n@@ -93,8 +90,17 @@ sum_i4 (gfc_array_i4 *retarray, gfc_array_i4 *array, index_type *pdim)\n \t\t \t\t * retarray->dim[rank-1].stride\n \t\t\t\t * extent[rank-1]);\n       retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n     }\n-          \n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n@@ -183,11 +189,8 @@ msum_i4 (gfc_array_i4 * retarray, gfc_array_i4 * array,\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n@@ -209,6 +212,34 @@ msum_i4 (gfc_array_i4 * retarray, gfc_array_i4 * array,\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n     }\n \n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_INTEGER_4)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;"}, {"sha": "df882c8137ee357f4703cf694785511aec060782", "filename": "libgfortran/generated/sum_i8.c", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fsum_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fsum_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_i8.c?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -55,11 +55,8 @@ sum_i8 (gfc_array_i8 *retarray, gfc_array_i8 *array, index_type *pdim)\n   /* Make dim zero based to avoid confusion.  */\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   delta = array->dim[dim].stride;\n@@ -93,8 +90,17 @@ sum_i8 (gfc_array_i8 *retarray, gfc_array_i8 *array, index_type *pdim)\n \t\t \t\t * retarray->dim[rank-1].stride\n \t\t\t\t * extent[rank-1]);\n       retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n     }\n-          \n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n@@ -183,11 +189,8 @@ msum_i8 (gfc_array_i8 * retarray, gfc_array_i8 * array,\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n@@ -209,6 +212,34 @@ msum_i8 (gfc_array_i8 * retarray, gfc_array_i8 * array,\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n     }\n \n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_INTEGER_8)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;"}, {"sha": "d88384dc9081904c263ea8bdf8aa47093b7a13bc", "filename": "libgfortran/generated/sum_r4.c", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fsum_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fsum_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_r4.c?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -55,11 +55,8 @@ sum_r4 (gfc_array_r4 *retarray, gfc_array_r4 *array, index_type *pdim)\n   /* Make dim zero based to avoid confusion.  */\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   delta = array->dim[dim].stride;\n@@ -93,8 +90,17 @@ sum_r4 (gfc_array_r4 *retarray, gfc_array_r4 *array, index_type *pdim)\n \t\t \t\t * retarray->dim[rank-1].stride\n \t\t\t\t * extent[rank-1]);\n       retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n     }\n-          \n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n@@ -183,11 +189,8 @@ msum_r4 (gfc_array_r4 * retarray, gfc_array_r4 * array,\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n@@ -209,6 +212,34 @@ msum_r4 (gfc_array_r4 * retarray, gfc_array_r4 * array,\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n     }\n \n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_REAL_4)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;"}, {"sha": "6658de723972b1dfddd129442ad8b873016dedc4", "filename": "libgfortran/generated/sum_r8.c", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fsum_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fgenerated%2Fsum_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_r8.c?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -55,11 +55,8 @@ sum_r8 (gfc_array_r8 *retarray, gfc_array_r8 *array, index_type *pdim)\n   /* Make dim zero based to avoid confusion.  */\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   delta = array->dim[dim].stride;\n@@ -93,8 +90,17 @@ sum_r8 (gfc_array_r8 *retarray, gfc_array_r8 *array, index_type *pdim)\n \t\t \t\t * retarray->dim[rank-1].stride\n \t\t\t\t * extent[rank-1]);\n       retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n     }\n-          \n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n@@ -183,11 +189,8 @@ msum_r8 (gfc_array_r8 * retarray, gfc_array_r8 * array,\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n@@ -209,6 +212,34 @@ msum_r8 (gfc_array_r8 * retarray, gfc_array_r8 * array,\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n     }\n \n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (GFC_REAL_8)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;"}, {"sha": "616caf94621c1767f9f354f01390cdedc789c4e8", "filename": "libgfortran/m4/iforeach.m4", "status": "modified", "additions": 46, "deletions": 13, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fm4%2Fiforeach.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fm4%2Fiforeach.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fiforeach.m4?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -20,13 +20,31 @@ name`'rtype_qual`_'atype_code (rtype * retarray, atype *array)\n   index_type n;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n-  assert (rank > 0);\n-  assert (GFC_DESCRIPTOR_RANK (retarray) == 1);\n-  assert (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound == rank);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->base = 0;\n+      retarray->data = internal_malloc_size (sizeof (rtype_name) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n@@ -109,17 +127,32 @@ void\n   index_type n;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n-  assert (rank > 0);\n-  assert (GFC_DESCRIPTOR_RANK (retarray) == 1);\n-  assert (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound == rank);\n-  assert (GFC_DESCRIPTOR_RANK (mask) == rank);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->base = 0;\n+      retarray->data = internal_malloc_size (sizeof (rtype_name) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n \n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;"}, {"sha": "b377677a5ebcad3dd61929aff3d730028a5a8589", "filename": "libgfortran/m4/ifunction.m4", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fm4%2Fifunction.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dd63a96201720c74d336aad9197a0efa019e4d/libgfortran%2Fm4%2Fifunction.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fifunction.m4?ref=50dd63a96201720c74d336aad9197a0efa019e4d", "patch": "@@ -40,11 +40,8 @@ name`'rtype_qual`_'atype_code (rtype *retarray, atype *array, index_type *pdim)\n   /* Make dim zero based to avoid confusion.  */\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   delta = array->dim[dim].stride;\n@@ -78,8 +75,17 @@ name`'rtype_qual`_'atype_code (rtype *retarray, atype *array, index_type *pdim)\n \t\t \t\t * retarray->dim[rank-1].stride\n \t\t\t\t * extent[rank-1]);\n       retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n     }\n-          \n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;\n@@ -168,11 +174,8 @@ void\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-  assert (rank == GFC_DESCRIPTOR_RANK (retarray));\n   if (array->dim[0].stride == 0)\n     array->dim[0].stride = 1;\n-  if (retarray->dim[0].stride == 0)\n-    retarray->dim[0].stride = 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n@@ -194,6 +197,34 @@ void\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n     }\n \n+  if (retarray->data == NULL)\n+    {\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->data\n+\t = internal_malloc_size (sizeof (rtype_name)\n+\t\t \t\t * retarray->dim[rank-1].stride\n+\t\t\t\t * extent[rank-1]);\n+      retarray->base = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+    }\n+  else\n+    {\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect\");\n+    }\n+\n   for (n = 0; n < rank; n++)\n     {\n       count[n] = 0;"}]}