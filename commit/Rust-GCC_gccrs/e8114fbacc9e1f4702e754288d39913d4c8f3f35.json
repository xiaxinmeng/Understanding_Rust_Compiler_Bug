{"sha": "e8114fbacc9e1f4702e754288d39913d4c8f3f35", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTgxMTRmYmFjYzllMWY0NzAyZTc1NDI4OGQzOTkxM2Q0YzhmM2YzNQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2009-03-28T12:52:13Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2009-03-28T12:52:13Z"}, "message": "re PR tree-optimization/38180 (CCP does not propagate through constant initializers)\n\n2009-03-28  Richard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/38180\n\t* tree-ssa-ccp.c (get_default_value): Simplify.\n\t(likely_value): Likewise.\n\t(surely_varying_stmt_p): Properly handle VOP case.\n\t(ccp_initialize): Likewise.\n\t(ccp_fold): Handle propagating through *&.\n\t(fold_const_aggregate_ref): Also handle decls.\n\n\t* gcc.dg/tree-ssa/ssa-ccp-24.c: New testcase.\n\nFrom-SVN: r145184", "tree": {"sha": "85a9bc8a34934b447056abbe2c2ba3dddef031c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/85a9bc8a34934b447056abbe2c2ba3dddef031c3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e8114fbacc9e1f4702e754288d39913d4c8f3f35", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8114fbacc9e1f4702e754288d39913d4c8f3f35", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8114fbacc9e1f4702e754288d39913d4c8f3f35", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8114fbacc9e1f4702e754288d39913d4c8f3f35/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d3d3011f933aaeb59829db58cc44d19e47e32e22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3d3011f933aaeb59829db58cc44d19e47e32e22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3d3011f933aaeb59829db58cc44d19e47e32e22"}], "stats": {"total": 182, "additions": 107, "deletions": 75}, "files": [{"sha": "4b746cdb319bf5e0297da372b6829a84e1bc9dbf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8114fbacc9e1f4702e754288d39913d4c8f3f35/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8114fbacc9e1f4702e754288d39913d4c8f3f35/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e8114fbacc9e1f4702e754288d39913d4c8f3f35", "patch": "@@ -1,3 +1,13 @@\n+2009-03-28  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/38180\n+\t* tree-ssa-ccp.c (get_default_value): Simplify.\n+\t(likely_value): Likewise.\n+\t(surely_varying_stmt_p): Properly handle VOP case.\n+\t(ccp_initialize): Likewise.\n+\t(ccp_fold): Handle propagating through *&.\n+\t(fold_const_aggregate_ref): Also handle decls.\n+\n 2009-03-28  Jan Hubicka  <jh@suse.cz>\n \n \t* cgraph.c (dump_cgraph_node): Add replace output flag by process."}, {"sha": "a2e329e1de3bfb49870c54587eeb2e9d625ab77d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8114fbacc9e1f4702e754288d39913d4c8f3f35/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8114fbacc9e1f4702e754288d39913d4c8f3f35/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e8114fbacc9e1f4702e754288d39913d4c8f3f35", "patch": "@@ -1,3 +1,8 @@\n+2009-03-28  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/38180\n+\t* gcc.dg/tree-ssa/ssa-ccp-24.c: New testcase.\n+\n 2009-03-28  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/38513"}, {"sha": "84f69e9d3bd25ad3eb41ab25e230faf9e991897f", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-24.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8114fbacc9e1f4702e754288d39913d4c8f3f35/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-24.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8114fbacc9e1f4702e754288d39913d4c8f3f35/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-24.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-24.c?ref=e8114fbacc9e1f4702e754288d39913d4c8f3f35", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-ccp1\" } */\n+\n+static const int x;\n+int foo()\n+{\n+  const int *p = &x;\n+  int y = *p;\n+  return y + 1;\n+}\n+\n+static const int x2[3] = { 1, 0, 2 };\n+int bar()\n+{\n+  int i = 1;\n+  const int *p = &x2[i];\n+  int y = *p;\n+  return y + 1;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"return 1;\" 2 \"ccp1\" } } */\n+/* { dg-final { cleanup-tree-dump \"ccp1\" } } */\n+"}, {"sha": "26b67224ea6fb2f7ce2133b183271af168dd6f12", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 69, "deletions": 75, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8114fbacc9e1f4702e754288d39913d4c8f3f35/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8114fbacc9e1f4702e754288d39913d4c8f3f35/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=e8114fbacc9e1f4702e754288d39913d4c8f3f35", "patch": "@@ -320,52 +320,45 @@ get_default_value (tree var)\n {\n   tree sym = SSA_NAME_VAR (var);\n   prop_value_t val = { UNINITIALIZED, NULL_TREE };\n-  tree cst_val;\n-  \n-  if (!is_gimple_reg (var))\n-    {\n-      /* Short circuit for regular CCP.  We are not interested in any\n-\t non-register when DO_STORE_CCP is false.  */\n-      val.lattice_val = VARYING;\n-    }\n-  else if ((cst_val = get_symbol_constant_value (sym)) != NULL_TREE)\n+  gimple stmt;\n+\n+  stmt = SSA_NAME_DEF_STMT (var);\n+\n+  if (gimple_nop_p (stmt))\n     {\n-      /* Globals and static variables declared 'const' take their\n-\t initial value.  */\n-      val.lattice_val = CONSTANT;\n-      val.value = cst_val;\n+      /* Variables defined by an empty statement are those used\n+\t before being initialized.  If VAR is a local variable, we\n+\t can assume initially that it is UNDEFINED, otherwise we must\n+\t consider it VARYING.  */\n+      if (is_gimple_reg (sym) && TREE_CODE (sym) != PARM_DECL)\n+\tval.lattice_val = UNDEFINED;\n+      else\n+\tval.lattice_val = VARYING;\n     }\n-  else\n-    {\n-      gimple stmt = SSA_NAME_DEF_STMT (var);\n-\n-      if (gimple_nop_p (stmt))\n+  else if (is_gimple_assign (stmt)\n+\t   /* Value-returning GIMPLE_CALL statements assign to\n+\t      a variable, and are treated similarly to GIMPLE_ASSIGN.  */\n+\t   || (is_gimple_call (stmt)\n+\t       && gimple_call_lhs (stmt) != NULL_TREE)\n+\t   || gimple_code (stmt) == GIMPLE_PHI)\n+    {\n+      tree cst;\n+      if (gimple_assign_single_p (stmt)\n+\t  && DECL_P (gimple_assign_rhs1 (stmt))\n+\t  && (cst = get_symbol_constant_value (gimple_assign_rhs1 (stmt))))\n \t{\n-\t  /* Variables defined by an empty statement are those used\n-\t     before being initialized.  If VAR is a local variable, we\n-\t     can assume initially that it is UNDEFINED, otherwise we must\n-\t     consider it VARYING.  */\n-\t  if (is_gimple_reg (sym) && TREE_CODE (sym) != PARM_DECL)\n-\t    val.lattice_val = UNDEFINED;\n-\t  else\n-\t    val.lattice_val = VARYING;\n-\t}\n-      else if (is_gimple_assign (stmt)\n-               /* Value-returning GIMPLE_CALL statements assign to\n-                  a variable, and are treated similarly to GIMPLE_ASSIGN.  */\n-               || (is_gimple_call (stmt)\n-                   && gimple_call_lhs (stmt) != NULL_TREE)\n-\t       || gimple_code (stmt) == GIMPLE_PHI)\n-        {\n-\t  /* Any other variable defined by an assignment or a PHI node\n-\t     is considered UNDEFINED.  */\n-\t  val.lattice_val = UNDEFINED;\n+\t  val.lattice_val = CONSTANT;\n+\t  val.value = cst;\n \t}\n       else\n-\t{\n-\t  /* Otherwise, VAR will never take on a constant value.  */\n-\t  val.lattice_val = VARYING;\n-\t}\n+\t/* Any other variable defined by an assignment or a PHI node\n+\t   is considered UNDEFINED.  */\n+\tval.lattice_val = UNDEFINED;\n+    }\n+  else\n+    {\n+      /* Otherwise, VAR will never take on a constant value.  */\n+      val.lattice_val = VARYING;\n     }\n \n   return val;\n@@ -501,6 +494,7 @@ likely_value (gimple stmt)\n   bool has_constant_operand, has_undefined_operand, all_undefined_operands;\n   tree use;\n   ssa_op_iter iter;\n+  unsigned i;\n \n   enum gimple_code code = gimple_code (stmt);\n \n@@ -516,33 +510,11 @@ likely_value (gimple stmt)\n   if (gimple_has_volatile_ops (stmt))\n     return VARYING;\n \n-  /* If we are not doing store-ccp, statements with loads\n-     and/or stores will never fold into a constant.  */\n-  if (!ZERO_SSA_OPERANDS (stmt, SSA_OP_ALL_VIRTUALS))\n-    return VARYING;\n-\n-  /* Note that only a GIMPLE_SINGLE_RHS assignment can satisfy\n-     is_gimple_min_invariant, so we do not consider calls or\n-     other forms of assignment.  */\n-  if (gimple_assign_single_p (stmt)\n-      && is_gimple_min_invariant (gimple_assign_rhs1 (stmt)))\n-    return CONSTANT;\n-\n-  if (code == GIMPLE_COND\n-      && is_gimple_min_invariant (gimple_cond_lhs (stmt))\n-      && is_gimple_min_invariant (gimple_cond_rhs (stmt)))\n-    return CONSTANT;\n-\n-  if (code == GIMPLE_SWITCH\n-      && is_gimple_min_invariant (gimple_switch_index (stmt)))\n-    return CONSTANT;\n-\n   /* Arrive here for more complex cases.  */\n-\n   has_constant_operand = false;\n   has_undefined_operand = false;\n   all_undefined_operands = true;\n-  FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_USE | SSA_OP_VUSE)\n+  FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_USE)\n     {\n       prop_value_t *val = get_value (use);\n \n@@ -555,6 +527,17 @@ likely_value (gimple stmt)\n \thas_constant_operand = true;\n     }\n \n+  /* There may be constants in regular rhs operands.  */\n+  for (i = is_gimple_call (stmt) + gimple_has_lhs (stmt);\n+       i < gimple_num_ops (stmt); ++i)\n+    {\n+      tree op = gimple_op (stmt, i);\n+      if (!op || TREE_CODE (op) == SSA_NAME)\n+\tcontinue;\n+      if (is_gimple_min_invariant (op))\n+\thas_constant_operand = true;\n+    }\n+\n   /* If the operation combines operands like COMPLEX_EXPR make sure to\n      not mark the result UNDEFINED if only one part of the result is\n      undefined.  */\n@@ -585,11 +568,11 @@ likely_value (gimple stmt)\n   if (has_undefined_operand)\n     return VARYING;\n \n+  /* We do not consider virtual operands here -- load from read-only\n+     memory may have only VARYING virtual operands, but still be\n+     constant.  */\n   if (has_constant_operand\n-      /* We do not consider virtual operands here -- load from read-only\n-\t memory may have only VARYING virtual operands, but still be\n-\t constant.  */\n-      || ZERO_SSA_OPERANDS (stmt, SSA_OP_USE))\n+      || gimple_references_memory_p (stmt))\n     return CONSTANT;\n \n   return VARYING;\n@@ -605,9 +588,6 @@ surely_varying_stmt_p (gimple stmt)\n   if (gimple_has_volatile_ops (stmt))\n     return true;\n \n-  if (!ZERO_SSA_OPERANDS (stmt, SSA_OP_ALL_VIRTUALS))\n-    return true;\n-\n   /* If it is a call and does not return a value or is not a\n      builtin and not an indirect call, it is varying.  */\n   if (is_gimple_call (stmt))\n@@ -619,6 +599,10 @@ surely_varying_stmt_p (gimple stmt)\n \treturn true;\n     }\n \n+  /* Any other store operation is not interesting.  */\n+  else if (!ZERO_SSA_OPERANDS (stmt, SSA_OP_VIRTUAL_DEFS))\n+    return true;\n+\n   /* Anything other than assignments and conditional jumps are not\n      interesting for CCP.  */\n   if (gimple_code (stmt) != GIMPLE_ASSIGN\n@@ -657,10 +641,7 @@ ccp_initialize (void)\n \t      /* If the statement will not produce a constant, mark\n \t\t all its outputs VARYING.  */\n \t      FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_ALL_DEFS)\n-\t\t{\n-\t\t  if (is_varying)\n-\t\t    set_value_varying (def);\n-\t\t}\n+\t\tset_value_varying (def);\n \t    }\n           prop_set_simulate_again (stmt, !is_varying);\n \t}\n@@ -953,6 +934,16 @@ ccp_fold (gimple stmt)\n \t\t\treturn fold_unary (VIEW_CONVERT_EXPR,\n \t\t\t\t\t   TREE_TYPE (rhs), val->value);\n \t\t    }\n+\t\t  else if (TREE_CODE (rhs) == INDIRECT_REF\n+\t\t\t   && TREE_CODE (TREE_OPERAND (rhs, 0)) == SSA_NAME)\n+\t\t    {\n+\t\t      prop_value_t *val = get_value (TREE_OPERAND (rhs, 0));\n+\t\t      if (val->lattice_val == CONSTANT\n+\t\t\t  && TREE_CODE (val->value) == ADDR_EXPR\n+\t\t\t  && useless_type_conversion_p (TREE_TYPE (rhs),\n+\t\t\t\t\t\t\tTREE_TYPE (TREE_TYPE (val->value))))\n+\t\t\trhs = TREE_OPERAND (val->value, 0);\n+\t\t    }\n \t\t  return fold_const_aggregate_ref (rhs);\n \t\t}\n               else if (kind == tcc_declaration)\n@@ -1144,6 +1135,9 @@ fold_const_aggregate_ref (tree t)\n   unsigned HOST_WIDE_INT cnt;\n   tree cfield, cval;\n \n+  if (TREE_CODE_CLASS (TREE_CODE (t)) == tcc_declaration)\n+    return get_symbol_constant_value (t);\n+\n   switch (TREE_CODE (t))\n     {\n     case ARRAY_REF:"}]}