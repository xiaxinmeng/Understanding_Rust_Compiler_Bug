{"sha": "85912441e43f7cf1fae2a156198362fb0cb1da81", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODU5MTI0NDFlNDNmN2NmMWZhZTJhMTU2MTk4MzYyZmIwY2IxZGE4MQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-05-04T15:42:15Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-05-04T15:42:15Z"}, "message": "Makefile.in (cgraphbuild.o): Add dependency on ipa-utils.h\n\n\n\t* Makefile.in (cgraphbuild.o): Add dependency on ipa-utils.h\n\t* cgraphbuild.c: Include ipa-utils.h\n\t(record_reference_ctx): New struct.\n\t(record_reference): Simplify to work on initializers; not statements.\n\t(mark_address, mark_load, mark_store): New.\n\t(build_cgraph_edges): Simplify using walk_stmt_load_store_addr_ops;\n\twalk PHI nodes too.\n\t(record_references_in_initializer): Update use of record_reference.\n\t(rebuild_cgraph_edges): Simplify using walk_stmt_load_store_addr_ops;\n\twalk PHI nodes too.\n\nFrom-SVN: r159032", "tree": {"sha": "78258eccf7c9f7fcc4913fb56584c03d1bcc703c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/78258eccf7c9f7fcc4913fb56584c03d1bcc703c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/85912441e43f7cf1fae2a156198362fb0cb1da81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85912441e43f7cf1fae2a156198362fb0cb1da81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85912441e43f7cf1fae2a156198362fb0cb1da81", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85912441e43f7cf1fae2a156198362fb0cb1da81/comments", "author": null, "committer": null, "parents": [{"sha": "688a10c2b9346b7c8d3d9c5ccb10b358eac3770f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/688a10c2b9346b7c8d3d9c5ccb10b358eac3770f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/688a10c2b9346b7c8d3d9c5ccb10b358eac3770f"}], "stats": {"total": 223, "additions": 158, "deletions": 65}, "files": [{"sha": "b792a5301a74f8321578390acc58e09f9490b64f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85912441e43f7cf1fae2a156198362fb0cb1da81/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85912441e43f7cf1fae2a156198362fb0cb1da81/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=85912441e43f7cf1fae2a156198362fb0cb1da81", "patch": "@@ -1,3 +1,16 @@\n+2010-05-04  Jan Hubicka  <jh@suse.cz>\n+\n+\t* Makefile.in (cgraphbuild.o): Add dependency on ipa-utils.h\n+\t* cgraphbuild.c: Include ipa-utils.h\n+\t(record_reference_ctx): New struct.\n+\t(record_reference): Simplify to work on initializers; not statements.\n+\t(mark_address, mark_load, mark_store): New.\n+\t(build_cgraph_edges): Simplify using walk_stmt_load_store_addr_ops;\n+\twalk PHI nodes too.\n+\t(record_references_in_initializer): Update use of record_reference.\n+\t(rebuild_cgraph_edges): Simplify using walk_stmt_load_store_addr_ops;\n+\twalk PHI nodes too.\n+\n 2010-05-04  Jan Hubicka  <jh@suse.cz>\n \n \t* lto-symtab.c (lto_cgraph_replace_node): Do not remove edges;"}, {"sha": "02c373aa29953d03782abc38ec0abd0970de732f", "filename": "gcc/cgraphbuild.c", "status": "modified", "additions": 145, "deletions": 65, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85912441e43f7cf1fae2a156198362fb0cb1da81/gcc%2Fcgraphbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85912441e43f7cf1fae2a156198362fb0cb1da81/gcc%2Fcgraphbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphbuild.c?ref=85912441e43f7cf1fae2a156198362fb0cb1da81", "patch": "@@ -31,6 +31,13 @@ along with GCC; see the file COPYING3.  If not see\n #include \"intl.h\"\n #include \"gimple.h\"\n #include \"tree-pass.h\"\n+#include \"ipa-utils.h\"\n+\n+/* Context of record_reference.  */\n+struct record_reference_ctx\n+{\n+  bool only_vars;\n+};\n \n /* Walk tree and record all calls and references to functions/variables.\n    Called via walk_tree: TP is pointer to tree to be examined.\n@@ -42,26 +49,31 @@ record_reference (tree *tp, int *walk_subtrees, void *data)\n {\n   tree t = *tp;\n   tree decl;\n-  bool do_callgraph = data != NULL;\n+  struct record_reference_ctx *ctx = (struct record_reference_ctx *)data;\n \n   switch (TREE_CODE (t))\n     {\n     case VAR_DECL:\n-      if (TREE_STATIC (t) || DECL_EXTERNAL (t))\n-\t{\n-\t  varpool_mark_needed_node (varpool_node (t));\n-\t  if (lang_hooks.callgraph.analyze_expr)\n-\t    return lang_hooks.callgraph.analyze_expr (tp, walk_subtrees);\n-\t}\n+    case FUNCTION_DECL:\n+      gcc_unreachable ();\n       break;\n \n     case FDESC_EXPR:\n     case ADDR_EXPR:\n       /* Record dereferences to the functions.  This makes the\n \t functions reachable unconditionally.  */\n-      decl = TREE_OPERAND (*tp, 0);\n-      if (TREE_CODE (decl) == FUNCTION_DECL && do_callgraph)\n+      decl = get_base_var (*tp);\n+      if (TREE_CODE (decl) == FUNCTION_DECL && !ctx->only_vars)\n \tcgraph_mark_address_taken_node (cgraph_node (decl));\n+\n+      if (TREE_CODE (decl) == VAR_DECL)\n+\t{\n+\t  gcc_assert (TREE_STATIC (decl) || DECL_EXTERNAL (decl));\n+\t  if (lang_hooks.callgraph.analyze_expr)\n+\t    lang_hooks.callgraph.analyze_expr (&decl, walk_subtrees);\n+\t  varpool_mark_needed_node (varpool_node (decl));\n+\t}\n+      *walk_subtrees = 0;\n       break;\n \n     default:\n@@ -126,6 +138,75 @@ compute_call_stmt_bb_frequency (tree decl, basic_block bb)\n   return freq;\n }\n \n+/* Mark address taken in STMT.  */\n+\n+static bool\n+mark_address (gimple stmt ATTRIBUTE_UNUSED, tree addr,\n+\t      void *data ATTRIBUTE_UNUSED)\n+{\n+  if (TREE_CODE (addr) == FUNCTION_DECL)\n+    {\n+      struct cgraph_node *node = cgraph_node (addr);\n+      cgraph_mark_address_taken_node (node);\n+    }\n+  else\n+    {\n+      addr = get_base_address (addr);\n+      if (addr && TREE_CODE (addr) == VAR_DECL\n+\t  && (TREE_STATIC (addr) || DECL_EXTERNAL (addr)))\n+\t{\n+\t  struct varpool_node *vnode = varpool_node (addr);\n+\t  int walk_subtrees;\n+\n+\t  if (lang_hooks.callgraph.analyze_expr)\n+\t    lang_hooks.callgraph.analyze_expr (&addr, &walk_subtrees);\n+\t  varpool_mark_needed_node (vnode);\n+\t}\n+    }\n+\n+  return false;\n+}\n+\n+/* Mark load of T.  */\n+\n+static bool\n+mark_load (gimple stmt ATTRIBUTE_UNUSED, tree t,\n+\t   void *data ATTRIBUTE_UNUSED)\n+{\n+  t = get_base_address (t);\n+  if (TREE_CODE (t) == VAR_DECL\n+      && (TREE_STATIC (t) || DECL_EXTERNAL (t)))\n+    {\n+      struct varpool_node *vnode = varpool_node (t);\n+      int walk_subtrees;\n+\n+      if (lang_hooks.callgraph.analyze_expr)\n+\tlang_hooks.callgraph.analyze_expr (&t, &walk_subtrees);\n+      varpool_mark_needed_node (vnode);\n+    }\n+  return false;\n+}\n+\n+/* Mark store of T.  */\n+\n+static bool\n+mark_store (gimple stmt ATTRIBUTE_UNUSED, tree t,\n+\t    void *data ATTRIBUTE_UNUSED)\n+{\n+  t = get_base_address (t);\n+  if (TREE_CODE (t) == VAR_DECL\n+      && (TREE_STATIC (t) || DECL_EXTERNAL (t)))\n+    {\n+      struct varpool_node *vnode = varpool_node (t);\n+      int walk_subtrees;\n+\n+      if (lang_hooks.callgraph.analyze_expr)\n+\tlang_hooks.callgraph.analyze_expr (&t, &walk_subtrees);\n+      varpool_mark_needed_node (vnode);\n+     }\n+  return false;\n+}\n+\n /* Create cgraph edges for function calls.\n    Also look for functions and variables having addresses taken.  */\n \n@@ -141,49 +222,40 @@ build_cgraph_edges (void)\n   /* Create the callgraph edges and record the nodes referenced by the function.\n      body.  */\n   FOR_EACH_BB (bb)\n-    for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-      {\n-\tgimple stmt = gsi_stmt (gsi);\n-\ttree decl;\n-\n-\tif (is_gimple_call (stmt) && (decl = gimple_call_fndecl (stmt)))\n-\t  {\n-\t    size_t i;\n-\t    size_t n = gimple_call_num_args (stmt);\n+    {\n+      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t{\n+\t  gimple stmt = gsi_stmt (gsi);\n+\t  tree decl;\n+\n+\t  if (is_gimple_call (stmt) && (decl = gimple_call_fndecl (stmt)))\n \t    cgraph_create_edge (node, cgraph_node (decl), stmt,\n-\t\t\t\tbb->count, compute_call_stmt_bb_frequency (current_function_decl, bb),\n+\t\t\t\tbb->count,\n+\t\t\t\tcompute_call_stmt_bb_frequency\n+\t\t\t\t  (current_function_decl, bb),\n \t\t\t\tbb->loop_depth);\n-\t    for (i = 0; i < n; i++)\n-\t      walk_tree (gimple_call_arg_ptr (stmt, i), record_reference,\n-\t\t\t node, visited_nodes);\n-\t    if (gimple_call_lhs (stmt))\n-\t      walk_tree (gimple_call_lhs_ptr (stmt), record_reference, node,\n-\t\t         visited_nodes);\n-\t  }\n-\telse\n-\t  {\n-\t    struct walk_stmt_info wi;\n-\t    memset (&wi, 0, sizeof (wi));\n-\t    wi.info = node;\n-\t    wi.pset = visited_nodes;\n-\t    walk_gimple_op (stmt, record_reference, &wi);\n-\t    if (gimple_code (stmt) == GIMPLE_OMP_PARALLEL\n-\t\t&& gimple_omp_parallel_child_fn (stmt))\n-\t      {\n-\t\ttree fn = gimple_omp_parallel_child_fn (stmt);\n+\t  walk_stmt_load_store_addr_ops (stmt, node, mark_load,\n+\t\t\t\t\t mark_store, mark_address);\n+\t  if (gimple_code (stmt) == GIMPLE_OMP_PARALLEL\n+\t      && gimple_omp_parallel_child_fn (stmt))\n+\t    {\n+\t      tree fn = gimple_omp_parallel_child_fn (stmt);\n+\t      cgraph_mark_needed_node (cgraph_node (fn));\n+\t    }\n+\t  if (gimple_code (stmt) == GIMPLE_OMP_TASK)\n+\t    {\n+\t      tree fn = gimple_omp_task_child_fn (stmt);\n+\t      if (fn)\n+\t\tcgraph_mark_needed_node (cgraph_node (fn));\n+\t      fn = gimple_omp_task_copy_fn (stmt);\n+\t      if (fn)\n \t\tcgraph_mark_needed_node (cgraph_node (fn));\n-\t      }\n-\t    if (gimple_code (stmt) == GIMPLE_OMP_TASK)\n-\t      {\n-\t\ttree fn = gimple_omp_task_child_fn (stmt);\n-\t\tif (fn)\n-\t\t  cgraph_mark_needed_node (cgraph_node (fn));\n-\t\tfn = gimple_omp_task_copy_fn (stmt);\n-\t\tif (fn)\n-\t\t  cgraph_mark_needed_node (cgraph_node (fn));\n-\t      }\n-\t  }\n-      }\n+\t    }\n+\t}\n+      for (gsi = gsi_start (phi_nodes (bb)); !gsi_end_p (gsi); gsi_next (&gsi))\n+\twalk_stmt_load_store_addr_ops (gsi_stmt (gsi), node,\n+\t\t\t\t       mark_load, mark_store, mark_address);\n+   }\n \n   /* Look for initializers of constant variables and private statics.  */\n   for (step = cfun->local_decls;\n@@ -194,8 +266,6 @@ build_cgraph_edges (void)\n       if (TREE_CODE (decl) == VAR_DECL\n \t  && (TREE_STATIC (decl) && !DECL_EXTERNAL (decl)))\n \tvarpool_finalize_decl (decl);\n-      else if (TREE_CODE (decl) == VAR_DECL && DECL_INITIAL (decl))\n-\twalk_tree (&DECL_INITIAL (decl), record_reference, node, visited_nodes);\n     }\n \n   pointer_set_destroy (visited_nodes);\n@@ -229,8 +299,11 @@ void\n record_references_in_initializer (tree decl, bool only_vars)\n {\n   struct pointer_set_t *visited_nodes = pointer_set_create ();\n+  struct record_reference_ctx ctx = {false};\n+\n+  ctx.only_vars = only_vars;\n   walk_tree (&DECL_INITIAL (decl), record_reference,\n-            only_vars ? NULL : decl, visited_nodes);\n+             &ctx, visited_nodes);\n   pointer_set_destroy (visited_nodes);\n }\n \n@@ -249,19 +322,26 @@ rebuild_cgraph_edges (void)\n   node->count = ENTRY_BLOCK_PTR->count;\n \n   FOR_EACH_BB (bb)\n-    for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-      {\n-\tgimple stmt = gsi_stmt (gsi);\n-\ttree decl;\n-\n-\tif (is_gimple_call (stmt) && (decl = gimple_call_fndecl (stmt)))\n-\t  cgraph_create_edge (node, cgraph_node (decl), stmt,\n-\t\t\t      bb->count,\n-\t\t\t      compute_call_stmt_bb_frequency\n-\t\t\t        (current_function_decl, bb),\n-\t\t\t      bb->loop_depth);\n-\n-      }\n+    {\n+      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t{\n+\t  gimple stmt = gsi_stmt (gsi);\n+\t  tree decl;\n+\n+\t  if (is_gimple_call (stmt) && (decl = gimple_call_fndecl (stmt)))\n+\t    cgraph_create_edge (node, cgraph_node (decl), stmt,\n+\t\t\t\tbb->count,\n+\t\t\t\tcompute_call_stmt_bb_frequency\n+\t\t\t\t  (current_function_decl, bb),\n+\t\t\t\tbb->loop_depth);\n+\t  walk_stmt_load_store_addr_ops (stmt, node, mark_load,\n+\t\t\t\t\t mark_store, mark_address);\n+\n+\t}\n+      for (gsi = gsi_start (phi_nodes (bb)); !gsi_end_p (gsi); gsi_next (&gsi))\n+\twalk_stmt_load_store_addr_ops (gsi_stmt (gsi), node,\n+\t\t\t\t       mark_load, mark_store, mark_address);\n+    }\n   gcc_assert (!node->global.inlined_to);\n \n   return 0;"}]}