{"sha": "bbeeac91f96bdcbc3eb40ec68c1fd8cf5d4a038d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmJlZWFjOTFmOTZiZGNiYzNlYjQwZWM2OGMxZmQ4Y2Y1ZDRhMDM4ZA==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2018-11-13T16:10:13Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2018-11-13T16:10:13Z"}, "message": "Ensure that dump calls are guarded with dump_enabled_p\n\nIf called when !dump_enabled_p, the dump_* functions effectively do\nnothing, but as of r263178 this doing \"nothing\" involves non-trivial\nwork internally.\n\nI wasn't sure whether the dump_* functions should assert that\n  dump_enabled_p ()\nis true when they're called, or if they should bail out immediately\nfor this case, so in this patch I implemented both, so that we get\nan assertion failure, and otherwise bail out for the case where\n!dump_enabled_p when assertions are disabled.\n\nThe patch also fixes all of the places I found during testing\n(on x86_64-pc-linux-gnu) that call into dump_* but which\nweren't guarded by\n  if (dump_enabled_p ())\n\ngcc/ChangeLog:\n\t* dumpfile.c (VERIFY_DUMP_ENABLED_P): New macro.\n\t(dump_gimple_stmt): Use it.\n\t(dump_gimple_stmt_loc): Likewise.\n\t(dump_gimple_expr): Likewise.\n\t(dump_gimple_expr_loc): Likewise.\n\t(dump_generic_expr): Likewise.\n\t(dump_generic_expr_loc): Likewise.\n\t(dump_printf): Likewise.\n\t(dump_printf_loc): Likewise.\n\t(dump_dec): Likewise.\n\t(dump_dec): Likewise.\n\t(dump_hex): Likewise.\n\t(dump_symtab_node): Likewise.\n\ngcc/ChangeLog:\n\t* gimple-loop-interchange.cc (tree_loop_interchange::interchange):\n\tGuard dump call with dump_enabled_p.\n\t* graphite-isl-ast-to-gimple.c (graphite_regenerate_ast_isl): Likewise.\n\t* graphite-optimize-isl.c (optimize_isl): Likewise.\n\t* graphite.c (graphite_transform_loops): Likewise.\n\t* tree-loop-distribution.c (pass_loop_distribution::execute): Likewise.\n\t* tree-parloops.c (parallelize_loops): Likewise.\n\t* tree-ssa-loop-niter.c (number_of_iterations_exit): Likewise.\n\t* tree-vect-data-refs.c (vect_analyze_group_access_1): Likewise.\n\t(vect_prune_runtime_alias_test_list): Likewise.\n\t* tree-vect-loop.c (vect_update_vf_for_slp): Likewise.\n\t(vect_estimate_min_profitable_iters): Likewise.\n\t* tree-vect-slp.c (vect_record_max_nunits): Likewise.\n\t(vect_build_slp_tree_2): Likewise.\n\t(vect_supported_load_permutation_p): Likewise.\n\t(vect_slp_analyze_operations): Likewise.\n\t(vect_slp_analyze_bb_1): Likewise.\n\t(vect_slp_bb): Likewise.\n\t* tree-vect-stmts.c (vect_analyze_stmt): Likewise.\n\t* tree-vectorizer.c (try_vectorize_loop_1): Likewise.\n\t(pass_slp_vectorize::execute): Likewise.\n\t(increase_alignment): Likewise.\n\nFrom-SVN: r266080", "tree": {"sha": "14626efce8213f765013cedf40bc8ad860ab9c9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/14626efce8213f765013cedf40bc8ad860ab9c9b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bbeeac91f96bdcbc3eb40ec68c1fd8cf5d4a038d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbeeac91f96bdcbc3eb40ec68c1fd8cf5d4a038d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bbeeac91f96bdcbc3eb40ec68c1fd8cf5d4a038d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbeeac91f96bdcbc3eb40ec68c1fd8cf5d4a038d/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9228f64cc2ceb54764a302103e3b754c0b6235a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9228f64cc2ceb54764a302103e3b754c0b6235a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9228f64cc2ceb54764a302103e3b754c0b6235a2"}], "stats": {"total": 324, "additions": 218, "deletions": 106}, "files": [{"sha": "2389f1cda8f9dc9788f4717e4c3f9315597c3625", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbeeac91f96bdcbc3eb40ec68c1fd8cf5d4a038d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbeeac91f96bdcbc3eb40ec68c1fd8cf5d4a038d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bbeeac91f96bdcbc3eb40ec68c1fd8cf5d4a038d", "patch": "@@ -1,3 +1,19 @@\n+2018-11-13  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* dumpfile.c (VERIFY_DUMP_ENABLED_P): New macro.\n+\t(dump_gimple_stmt): Use it.\n+\t(dump_gimple_stmt_loc): Likewise.\n+\t(dump_gimple_expr): Likewise.\n+\t(dump_gimple_expr_loc): Likewise.\n+\t(dump_generic_expr): Likewise.\n+\t(dump_generic_expr_loc): Likewise.\n+\t(dump_printf): Likewise.\n+\t(dump_printf_loc): Likewise.\n+\t(dump_dec): Likewise.\n+\t(dump_dec): Likewise.\n+\t(dump_hex): Likewise.\n+\t(dump_symtab_node): Likewise.\n+\n 2018-11-13  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR ipa/87955"}, {"sha": "a1ab20531db9cc1774679980679d8d03f15b0f25", "filename": "gcc/dumpfile.c", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbeeac91f96bdcbc3eb40ec68c1fd8cf5d4a038d/gcc%2Fdumpfile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbeeac91f96bdcbc3eb40ec68c1fd8cf5d4a038d/gcc%2Fdumpfile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdumpfile.c?ref=bbeeac91f96bdcbc3eb40ec68c1fd8cf5d4a038d", "patch": "@@ -1184,13 +1184,27 @@ dump_context dump_context::s_default;\n /* Implementation of dump_* API calls, calling into dump_context\n    member functions.  */\n \n+/* Calls to the dump_* functions do non-trivial work, so they ought\n+   to be guarded by:\n+     if (dump_enabled_p ())\n+   Assert that they are guarded, and, if assertions are disabled,\n+   bail out if the calls weren't properly guarded.  */\n+\n+#define VERIFY_DUMP_ENABLED_P \\\n+  do {\t\t\t\t\t\\\n+    gcc_assert (dump_enabled_p ());\t\\\n+    if (!dump_enabled_p ())\t\t\\\n+      return;\t\t\t\t\\\n+  } while (0)\n+\n /* Dump gimple statement GS with SPC indentation spaces and\n    EXTRA_DUMP_FLAGS on the dump streams if DUMP_KIND is enabled.  */\n \n void\n dump_gimple_stmt (dump_flags_t dump_kind, dump_flags_t extra_dump_flags,\n \t\t  gimple *gs, int spc)\n {\n+  VERIFY_DUMP_ENABLED_P;\n   dump_context::get ().dump_gimple_stmt (dump_kind, extra_dump_flags, gs, spc);\n }\n \n@@ -1200,6 +1214,7 @@ void\n dump_gimple_stmt_loc (dump_flags_t dump_kind, const dump_location_t &loc,\n \t\t      dump_flags_t extra_dump_flags, gimple *gs, int spc)\n {\n+  VERIFY_DUMP_ENABLED_P;\n   dump_context::get ().dump_gimple_stmt_loc (dump_kind, loc, extra_dump_flags,\n \t\t\t\t\t     gs, spc);\n }\n@@ -1212,6 +1227,7 @@ void\n dump_gimple_expr (dump_flags_t dump_kind, dump_flags_t extra_dump_flags,\n \t\t  gimple *gs, int spc)\n {\n+  VERIFY_DUMP_ENABLED_P;\n   dump_context::get ().dump_gimple_expr (dump_kind, extra_dump_flags, gs, spc);\n }\n \n@@ -1221,6 +1237,7 @@ void\n dump_gimple_expr_loc (dump_flags_t dump_kind, const dump_location_t &loc,\n \t\t      dump_flags_t extra_dump_flags, gimple *gs, int spc)\n {\n+  VERIFY_DUMP_ENABLED_P;\n   dump_context::get ().dump_gimple_expr_loc (dump_kind, loc, extra_dump_flags,\n \t\t\t\t\t     gs, spc);\n }\n@@ -1232,6 +1249,7 @@ void\n dump_generic_expr (dump_flags_t dump_kind, dump_flags_t extra_dump_flags,\n \t\t   tree t)\n {\n+  VERIFY_DUMP_ENABLED_P;\n   dump_context::get ().dump_generic_expr (dump_kind, extra_dump_flags, t);\n }\n \n@@ -1242,6 +1260,7 @@ void\n dump_generic_expr_loc (dump_flags_t dump_kind, const dump_location_t &loc,\n \t\t       dump_flags_t extra_dump_flags, tree t)\n {\n+  VERIFY_DUMP_ENABLED_P;\n   dump_context::get ().dump_generic_expr_loc (dump_kind, loc, extra_dump_flags,\n \t\t\t\t\t      t);\n }\n@@ -1251,6 +1270,7 @@ dump_generic_expr_loc (dump_flags_t dump_kind, const dump_location_t &loc,\n void\n dump_printf (dump_flags_t dump_kind, const char *format, ...)\n {\n+  VERIFY_DUMP_ENABLED_P;\n   va_list ap;\n   va_start (ap, format);\n   dump_context::get ().dump_printf_va (dump_kind, format, &ap);\n@@ -1264,6 +1284,7 @@ void\n dump_printf_loc (dump_flags_t dump_kind, const dump_location_t &loc,\n \t\t const char *format, ...)\n {\n+  VERIFY_DUMP_ENABLED_P;\n   va_list ap;\n   va_start (ap, format);\n   dump_context::get ().dump_printf_loc_va (dump_kind, loc, format, &ap);\n@@ -1276,6 +1297,7 @@ template<unsigned int N, typename C>\n void\n dump_dec (dump_flags_t dump_kind, const poly_int<N, C> &value)\n {\n+  VERIFY_DUMP_ENABLED_P;\n   dump_context::get ().dump_dec (dump_kind, value);\n }\n \n@@ -1288,6 +1310,7 @@ template void dump_dec (dump_flags_t, const poly_widest_int &);\n void\n dump_dec (dump_flags_t dump_kind, const poly_wide_int &value, signop sgn)\n {\n+  VERIFY_DUMP_ENABLED_P;\n   if (dump_file\n       && dump_context::get ().apply_dump_filter_p (dump_kind, pflags))\n     print_dec (value, dump_file, sgn);\n@@ -1302,6 +1325,7 @@ dump_dec (dump_flags_t dump_kind, const poly_wide_int &value, signop sgn)\n void\n dump_hex (dump_flags_t dump_kind, const poly_wide_int &value)\n {\n+  VERIFY_DUMP_ENABLED_P;\n   if (dump_file\n       && dump_context::get ().apply_dump_filter_p (dump_kind, pflags))\n     print_hex (value, dump_file);\n@@ -1325,6 +1349,7 @@ dumpfile_ensure_any_optinfo_are_flushed ()\n void\n dump_symtab_node (dump_flags_t dump_kind, symtab_node *node)\n {\n+  VERIFY_DUMP_ENABLED_P;\n   dump_context::get ().dump_symtab_node (dump_kind, node);\n }\n "}, {"sha": "9145b1217da4c4cb7a976f30a5d4ad5389e55551", "filename": "gcc/gimple-loop-interchange.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbeeac91f96bdcbc3eb40ec68c1fd8cf5d4a038d/gcc%2Fgimple-loop-interchange.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbeeac91f96bdcbc3eb40ec68c1fd8cf5d4a038d/gcc%2Fgimple-loop-interchange.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-loop-interchange.cc?ref=bbeeac91f96bdcbc3eb40ec68c1fd8cf5d4a038d", "patch": "@@ -1645,7 +1645,7 @@ tree_loop_interchange::interchange (vec<data_reference_p> datarefs,\n     }\n   simple_dce_from_worklist (m_dce_seeds);\n \n-  if (changed_p)\n+  if (changed_p && dump_enabled_p ())\n     dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, loc,\n \t\t     \"loops interchanged in loop nest\\n\");\n "}, {"sha": "0d8960c6bb2341f1e9b7040f931087c7b21280ce", "filename": "gcc/graphite-isl-ast-to-gimple.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbeeac91f96bdcbc3eb40ec68c1fd8cf5d4a038d/gcc%2Fgraphite-isl-ast-to-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbeeac91f96bdcbc3eb40ec68c1fd8cf5d4a038d/gcc%2Fgraphite-isl-ast-to-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-isl-ast-to-gimple.c?ref=bbeeac91f96bdcbc3eb40ec68c1fd8cf5d4a038d", "patch": "@@ -1518,10 +1518,13 @@ graphite_regenerate_ast_isl (scop_p scop)\n \n   if (t.codegen_error_p ())\n     {\n-      dump_user_location_t loc = find_loop_location\n-\t(scop->scop_info->region.entry->dest->loop_father);\n-      dump_printf_loc (MSG_MISSED_OPTIMIZATION, loc,\n-\t\t       \"loop nest not optimized, code generation error\\n\");\n+      if (dump_enabled_p ())\n+\t{\n+\t  dump_user_location_t loc = find_loop_location\n+\t    (scop->scop_info->region.entry->dest->loop_father);\n+\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, loc,\n+\t\t\t   \"loop nest not optimized, code generation error\\n\");\n+\t}\n \n       /* Remove the unreachable region.  */\n       remove_edge_and_dominated_blocks (if_region->true_region->region.entry);"}, {"sha": "8ceaa495a360c4e7d45b342b136c7239d7456299", "filename": "gcc/graphite-optimize-isl.c", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbeeac91f96bdcbc3eb40ec68c1fd8cf5d4a038d/gcc%2Fgraphite-optimize-isl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbeeac91f96bdcbc3eb40ec68c1fd8cf5d4a038d/gcc%2Fgraphite-optimize-isl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-optimize-isl.c?ref=bbeeac91f96bdcbc3eb40ec68c1fd8cf5d4a038d", "patch": "@@ -160,16 +160,19 @@ optimize_isl (scop_p scop)\n   if (!scop->transformed_schedule\n       || isl_ctx_last_error (scop->isl_context) != isl_error_none)\n     {\n-      dump_user_location_t loc = find_loop_location\n-\t(scop->scop_info->region.entry->dest->loop_father);\n-      if (isl_ctx_last_error (scop->isl_context) == isl_error_quota)\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, loc,\n-\t\t\t \"loop nest not optimized, optimization timed out \"\n-\t\t\t \"after %d operations [--param max-isl-operations]\\n\",\n-\t\t\t max_operations);\n-      else\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, loc,\n-\t\t\t \"loop nest not optimized, ISL signalled an error\\n\");\n+      if (dump_enabled_p ())\n+\t{\n+\t  dump_user_location_t loc = find_loop_location\n+\t    (scop->scop_info->region.entry->dest->loop_father);\n+\t  if (isl_ctx_last_error (scop->isl_context) == isl_error_quota)\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, loc,\n+\t\t\t     \"loop nest not optimized, optimization timed out \"\n+\t\t\t     \"after %d operations [--param max-isl-operations]\\n\",\n+\t\t\t     max_operations);\n+\t  else\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, loc,\n+\t\t\t     \"loop nest not optimized, ISL signalled an error\\n\");\n+\t}\n       return false;\n     }\n \n@@ -182,11 +185,14 @@ optimize_isl (scop_p scop)\n \n   if (same_schedule)\n     {\n-      dump_user_location_t loc = find_loop_location\n-\t(scop->scop_info->region.entry->dest->loop_father);\n-      dump_printf_loc (MSG_NOTE, loc,\n-\t\t       \"loop nest not optimized, optimized schedule is \"\n-\t\t       \"identical to original schedule\\n\");\n+      if (dump_enabled_p ())\n+\t{\n+\t  dump_user_location_t loc = find_loop_location\n+\t    (scop->scop_info->region.entry->dest->loop_father);\n+\t  dump_printf_loc (MSG_NOTE, loc,\n+\t\t\t   \"loop nest not optimized, optimized schedule is \"\n+\t\t\t   \"identical to original schedule\\n\");\n+\t}\n       if (dump_file)\n \tprint_schedule_ast (dump_file, scop->original_schedule, scop);\n       isl_schedule_free (scop->transformed_schedule);"}, {"sha": "f49eef606f6cded25e08e72c66f8fc590729e731", "filename": "gcc/graphite.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbeeac91f96bdcbc3eb40ec68c1fd8cf5d4a038d/gcc%2Fgraphite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbeeac91f96bdcbc3eb40ec68c1fd8cf5d4a038d/gcc%2Fgraphite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite.c?ref=bbeeac91f96bdcbc3eb40ec68c1fd8cf5d4a038d", "patch": "@@ -410,7 +410,8 @@ graphite_transform_loops (void)\n \t  continue;\n \n \tchanged = true;\n-\tif (graphite_regenerate_ast_isl (scop))\n+\tif (graphite_regenerate_ast_isl (scop)\n+\t    && dump_enabled_p ())\n \t  {\n \t    dump_user_location_t loc = find_loop_location\n \t      (scops[i]->scop_info->region.entry->dest->loop_father);"}, {"sha": "9afb5f2702cb818e02aa978afc325598a7c3f9fb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbeeac91f96bdcbc3eb40ec68c1fd8cf5d4a038d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbeeac91f96bdcbc3eb40ec68c1fd8cf5d4a038d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bbeeac91f96bdcbc3eb40ec68c1fd8cf5d4a038d", "patch": "@@ -1,3 +1,28 @@\n+2018-11-13  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* gimple-loop-interchange.cc (tree_loop_interchange::interchange):\n+\tGuard dump call with dump_enabled_p.\n+\t* graphite-isl-ast-to-gimple.c (graphite_regenerate_ast_isl): Likewise.\n+\t* graphite-optimize-isl.c (optimize_isl): Likewise.\n+\t* graphite.c (graphite_transform_loops): Likewise.\n+\t* tree-loop-distribution.c (pass_loop_distribution::execute): Likewise.\n+\t* tree-parloops.c (parallelize_loops): Likewise.\n+\t* tree-ssa-loop-niter.c (number_of_iterations_exit): Likewise.\n+\t* tree-vect-data-refs.c (vect_analyze_group_access_1): Likewise.\n+\t(vect_prune_runtime_alias_test_list): Likewise.\n+\t* tree-vect-loop.c (vect_update_vf_for_slp): Likewise.\n+\t(vect_estimate_min_profitable_iters): Likewise.\n+\t* tree-vect-slp.c (vect_record_max_nunits): Likewise.\n+\t(vect_build_slp_tree_2): Likewise.\n+\t(vect_supported_load_permutation_p): Likewise.\n+\t(vect_slp_analyze_operations): Likewise.\n+\t(vect_slp_analyze_bb_1): Likewise.\n+\t(vect_slp_bb): Likewise.\n+\t* tree-vect-stmts.c (vect_analyze_stmt): Likewise.\n+\t* tree-vectorizer.c (try_vectorize_loop_1): Likewise.\n+\t(pass_slp_vectorize::execute): Likewise.\n+\t(increase_alignment): Likewise.\n+\n 2018-11-13  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR ipa/87955"}, {"sha": "8f61a35e5b1291b2795c660b0a3b405081f06235", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbeeac91f96bdcbc3eb40ec68c1fd8cf5d4a038d/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbeeac91f96bdcbc3eb40ec68c1fd8cf5d4a038d/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=bbeeac91f96bdcbc3eb40ec68c1fd8cf5d4a038d", "patch": "@@ -3139,10 +3139,11 @@ pass_loop_distribution::execute (function *fun)\n \t  if (nb_generated_loops + nb_generated_calls > 0)\n \t    {\n \t      changed = true;\n-\t      dump_printf_loc (MSG_OPTIMIZED_LOCATIONS,\n-\t\t\t       loc, \"Loop%s %d distributed: split to %d loops \"\n-\t\t\t       \"and %d library calls.\\n\", str, loop->num,\n-\t\t\t       nb_generated_loops, nb_generated_calls);\n+\t      if (dump_enabled_p ())\n+\t\tdump_printf_loc (MSG_OPTIMIZED_LOCATIONS,\n+\t\t\t\t loc, \"Loop%s %d distributed: split to %d loops \"\n+\t\t\t\t \"and %d library calls.\\n\", str, loop->num,\n+\t\t\t\t nb_generated_loops, nb_generated_calls);\n \n \t      break;\n \t    }"}, {"sha": "4e22898268f9e0b128ab63cab7af6a346e283fa6", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbeeac91f96bdcbc3eb40ec68c1fd8cf5d4a038d/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbeeac91f96bdcbc3eb40ec68c1fd8cf5d4a038d/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=bbeeac91f96bdcbc3eb40ec68c1fd8cf5d4a038d", "patch": "@@ -3409,13 +3409,16 @@ parallelize_loops (bool oacc_kernels_p)\n       changed = true;\n       skip_loop = loop->inner;\n \n-      dump_user_location_t loop_loc = find_loop_location (loop);\n-      if (loop->inner)\n-\tdump_printf_loc (MSG_OPTIMIZED_LOCATIONS, loop_loc,\n-\t\t\t \"parallelizing outer loop %d\\n\", loop->num);\n-      else\n-\tdump_printf_loc (MSG_OPTIMIZED_LOCATIONS, loop_loc,\n-\t\t\t \"parallelizing inner loop %d\\n\", loop->num);\n+      if (dump_enabled_p ())\n+\t{\n+\t  dump_user_location_t loop_loc = find_loop_location (loop);\n+\t  if (loop->inner)\n+\t    dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, loop_loc,\n+\t\t\t     \"parallelizing outer loop %d\\n\", loop->num);\n+\t  else\n+\t    dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, loop_loc,\n+\t\t\t     \"parallelizing inner loop %d\\n\", loop->num);\n+\t}\n \n       gen_parallel_loop (loop, &reduction_list,\n \t\t\t n_threads, &niter_desc, oacc_kernels_p);"}, {"sha": "9bcd66449fa2bdca8df205299d4b972dd0e8d359", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbeeac91f96bdcbc3eb40ec68c1fd8cf5d4a038d/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbeeac91f96bdcbc3eb40ec68c1fd8cf5d4a038d/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=bbeeac91f96bdcbc3eb40ec68c1fd8cf5d4a038d", "patch": "@@ -2630,7 +2630,7 @@ number_of_iterations_exit (struct loop *loop, edge exit,\n   if (integer_nonzerop (niter->assumptions))\n     return true;\n \n-  if (warn)\n+  if (warn && dump_enabled_p ())\n     dump_printf_loc (MSG_MISSED_OPTIMIZATION, stmt,\n \t\t     \"missed loop optimization: niters analysis ends up \"\n \t\t     \"with assumptions.\\n\");"}, {"sha": "1cc0320f00d3c43d4fe44da5a61bd65f3a4ad952", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbeeac91f96bdcbc3eb40ec68c1fd8cf5d4a038d/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbeeac91f96bdcbc3eb40ec68c1fd8cf5d4a038d/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=bbeeac91f96bdcbc3eb40ec68c1fd8cf5d4a038d", "patch": "@@ -2458,7 +2458,8 @@ vect_analyze_group_access_1 (dr_vec_info *dr_info)\n \t  return true;\n \t}\n \n-      dump_printf_loc (MSG_NOTE, vect_location, \"using strided accesses\\n\");\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_NOTE, vect_location, \"using strided accesses\\n\");\n       STMT_VINFO_STRIDED_P (stmt_info) = true;\n       return true;\n     }\n@@ -3558,9 +3559,10 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n   unsigned int count = (comp_alias_ddrs.length ()\n \t\t\t+ check_unequal_addrs.length ());\n \n-  dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t   \"improved number of alias checks from %d to %d\\n\",\n-\t\t   may_alias_ddrs.length (), count);\n+  if (dump_enabled_p ())\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t     \"improved number of alias checks from %d to %d\\n\",\n+\t\t     may_alias_ddrs.length (), count);\n   if ((int) count > PARAM_VALUE (PARAM_VECT_MAX_VERSION_FOR_ALIAS_CHECKS))\n     return opt_result::failure_at\n       (vect_location,"}, {"sha": "5baf87b926cf74e748a9d6392057dd43df1a4f06", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 31, "deletions": 22, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbeeac91f96bdcbc3eb40ec68c1fd8cf5d4a038d/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbeeac91f96bdcbc3eb40ec68c1fd8cf5d4a038d/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=bbeeac91f96bdcbc3eb40ec68c1fd8cf5d4a038d", "patch": "@@ -1399,14 +1399,16 @@ vect_update_vf_for_slp (loop_vec_info loop_vinfo)\n \n   if (only_slp_in_loop)\n     {\n-      dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t       \"Loop contains only SLP stmts\\n\");\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"Loop contains only SLP stmts\\n\");\n       vectorization_factor = LOOP_VINFO_SLP_UNROLLING_FACTOR (loop_vinfo);\n     }\n   else\n     {\n-      dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t       \"Loop contains SLP and non-SLP stmts\\n\");\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"Loop contains SLP and non-SLP stmts\\n\");\n       /* Both the vectorization factor and unroll factor have the form\n \t current_vector_size * X for some rational X, so they must have\n \t a common multiple.  */\n@@ -3337,7 +3339,8 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n   /* Cost model disabled.  */\n   if (unlimited_cost_model (LOOP_VINFO_LOOP (loop_vinfo)))\n     {\n-      dump_printf_loc (MSG_NOTE, vect_location, \"cost model disabled.\\n\");\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_NOTE, vect_location, \"cost model disabled.\\n\");\n       *ret_min_profitable_niters = 0;\n       *ret_min_profitable_estimate = 0;\n       return;\n@@ -3350,9 +3353,10 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n       unsigned len = LOOP_VINFO_MAY_MISALIGN_STMTS (loop_vinfo).length ();\n       (void) add_stmt_cost (target_cost_data, len, vector_stmt, NULL, 0,\n \t\t\t    vect_prologue);\n-      dump_printf (MSG_NOTE,\n-                   \"cost model: Adding cost of checks for loop \"\n-                   \"versioning to treat misalignment.\\n\");\n+      if (dump_enabled_p ())\n+\tdump_printf (MSG_NOTE,\n+\t\t     \"cost model: Adding cost of checks for loop \"\n+\t\t     \"versioning to treat misalignment.\\n\");\n     }\n \n   /* Requires loop versioning with alias checks.  */\n@@ -3379,9 +3383,10 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n \t  (void) add_stmt_cost (target_cost_data, nstmts, scalar_stmt,\n \t\t\t\tNULL, 0, vect_prologue);\n \t}\n-      dump_printf (MSG_NOTE,\n-                   \"cost model: Adding cost of checks for loop \"\n-                   \"versioning aliasing.\\n\");\n+      if (dump_enabled_p ())\n+\tdump_printf (MSG_NOTE,\n+\t\t     \"cost model: Adding cost of checks for loop \"\n+\t\t     \"versioning aliasing.\\n\");\n     }\n \n   /* Requires loop versioning with niter checks.  */\n@@ -3390,9 +3395,10 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n       /*  FIXME: Make cost depend on complexity of individual check.  */\n       (void) add_stmt_cost (target_cost_data, 1, vector_stmt, NULL, 0,\n \t\t\t    vect_prologue);\n-      dump_printf (MSG_NOTE,\n-\t\t   \"cost model: Adding cost of checks for loop \"\n-\t\t   \"versioning niters.\\n\");\n+      if (dump_enabled_p ())\n+\tdump_printf (MSG_NOTE,\n+\t\t     \"cost model: Adding cost of checks for loop \"\n+\t\t     \"versioning niters.\\n\");\n     }\n \n   if (LOOP_REQUIRES_VERSIONING (loop_vinfo))\n@@ -3440,15 +3446,17 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n   else if (npeel < 0)\n     {\n       peel_iters_prologue = assumed_vf / 2;\n-      dump_printf (MSG_NOTE, \"cost model: \"\n-                   \"prologue peel iters set to vf/2.\\n\");\n+      if (dump_enabled_p ())\n+\tdump_printf (MSG_NOTE, \"cost model: \"\n+\t\t     \"prologue peel iters set to vf/2.\\n\");\n \n       /* If peeling for alignment is unknown, loop bound of main loop becomes\n          unknown.  */\n       peel_iters_epilogue = assumed_vf / 2;\n-      dump_printf (MSG_NOTE, \"cost model: \"\n-                   \"epilogue peel iters set to vf/2 because \"\n-                   \"peeling for alignment is unknown.\\n\");\n+      if (dump_enabled_p ())\n+\tdump_printf (MSG_NOTE, \"cost model: \"\n+\t\t     \"epilogue peel iters set to vf/2 because \"\n+\t\t     \"peeling for alignment is unknown.\\n\");\n \n       /* If peeled iterations are unknown, count a taken branch and a not taken\n          branch per peeled loop. Even if scalar loop iterations are known,\n@@ -3653,9 +3661,10 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n       return;\n     }\n \n-  dump_printf (MSG_NOTE,\n-\t       \"  Calculated minimum iters for profitability: %d\\n\",\n-\t       min_profitable_iters);\n+  if (dump_enabled_p ())\n+    dump_printf (MSG_NOTE,\n+\t\t \"  Calculated minimum iters for profitability: %d\\n\",\n+\t\t min_profitable_iters);\n \n   if (!LOOP_VINFO_FULLY_MASKED_P (loop_vinfo)\n       && min_profitable_iters < (assumed_vf + peel_iters_prologue))"}, {"sha": "f2bb8da9de29480ac8483c81c6689864b33bfd32", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 49, "deletions": 35, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbeeac91f96bdcbc3eb40ec68c1fd8cf5d4a038d/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbeeac91f96bdcbc3eb40ec68c1fd8cf5d4a038d/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=bbeeac91f96bdcbc3eb40ec68c1fd8cf5d4a038d", "patch": "@@ -575,9 +575,10 @@ vect_record_max_nunits (stmt_vec_info stmt_info, unsigned int group_size,\n       && (!nunits.is_constant (&const_nunits)\n \t  || const_nunits > group_size))\n     {\n-      dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t       \"Build SLP failed: unrolling required \"\n-\t\t       \"in basic block SLP\\n\");\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"Build SLP failed: unrolling required \"\n+\t\t\t \"in basic block SLP\\n\");\n       /* Fatal mismatch.  */\n       return false;\n     }\n@@ -1231,9 +1232,10 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n \t\t    vect_free_slp_tree (grandchild, false);\n \t\t  SLP_TREE_CHILDREN (child).truncate (0);\n \n-\t\t  dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t\t   \"Building parent vector operands from \"\n-\t\t\t\t   \"scalars instead\\n\");\n+\t\t  if (dump_enabled_p ())\n+\t\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t\t     \"Building parent vector operands from \"\n+\t\t\t\t     \"scalars instead\\n\");\n \t\t  oprnd_info->def_stmts = vNULL;\n \t\t  SLP_TREE_DEF_TYPE (child) = vect_external_def;\n \t\t  children.safe_push (child);\n@@ -1261,8 +1263,9 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n \t     scalar version.  */\n \t  && !is_pattern_stmt_p (stmt_info))\n \t{\n-\t  dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t   \"Building vector operands from scalars\\n\");\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"Building vector operands from scalars\\n\");\n \t  child = vect_create_new_slp_node (oprnd_info->def_stmts);\n \t  SLP_TREE_DEF_TYPE (child) = vect_external_def;\n \t  children.safe_push (child);\n@@ -1334,16 +1337,19 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n \t  while (j != group_size);\n \n \t  /* Swap mismatched definition stmts.  */\n-\t  dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t   \"Re-trying with swapped operands of stmts \");\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"Re-trying with swapped operands of stmts \");\n \t  for (j = 0; j < group_size; ++j)\n \t    if (matches[j] == !swap_not_matching)\n \t      {\n \t\tstd::swap (oprnds_info[0]->def_stmts[j],\n \t\t\t   oprnds_info[1]->def_stmts[j]);\n-\t\tdump_printf (MSG_NOTE, \"%d \", j);\n+\t\tif (dump_enabled_p ())\n+\t\t  dump_printf (MSG_NOTE, \"%d \", j);\n \t      }\n-\t  dump_printf (MSG_NOTE, \"\\n\");\n+\t  if (dump_enabled_p ())\n+\t    dump_printf (MSG_NOTE, \"\\n\");\n \t  /* And try again with scratch 'matches' ... */\n \t  bool *tem = XALLOCAVEC (bool, group_size);\n \t  if ((child = vect_build_slp_tree (vinfo, oprnd_info->def_stmts,\n@@ -1399,9 +1405,10 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n \t\t\tvect_free_slp_tree (grandchild, false);\n \t\t      SLP_TREE_CHILDREN (child).truncate (0);\n \n-\t\t      dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t\t       \"Building parent vector operands from \"\n-\t\t\t\t       \"scalars instead\\n\");\n+\t\t      if (dump_enabled_p ())\n+\t\t\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t\t\t \"Building parent vector operands from \"\n+\t\t\t\t\t \"scalars instead\\n\");\n \t\t      oprnd_info->def_stmts = vNULL;\n \t\t      SLP_TREE_DEF_TYPE (child) = vect_external_def;\n \t\t      children.safe_push (child);\n@@ -1757,9 +1764,10 @@ vect_supported_load_permutation_p (slp_instance slp_instn)\n \t      if (!TYPE_VECTOR_SUBPARTS (vectype).is_constant (&nunits)\n \t\t  || maxk >= (DR_GROUP_SIZE (group_info) & ~(nunits - 1)))\n \t\t{\n-\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t   \"BB vectorization with gaps at the end of \"\n-\t\t\t\t   \"a load is not supported\\n\");\n+\t\t  if (dump_enabled_p ())\n+\t\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t     \"BB vectorization with gaps at the end of \"\n+\t\t\t\t     \"a load is not supported\\n\");\n \t\t  return false;\n \t\t}\n \n@@ -1769,9 +1777,10 @@ vect_supported_load_permutation_p (slp_instance slp_instn)\n \t      if (!vect_transform_slp_perm_load (node, tem, NULL,\n \t\t\t\t\t\t 1, slp_instn, true, &n_perms))\n \t\t{\n-\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION,\n-\t\t\t\t   vect_location,\n-\t\t\t\t   \"unsupported load permutation\\n\");\n+\t\t  if (dump_enabled_p ())\n+\t\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION,\n+\t\t\t\t     vect_location,\n+\t\t\t\t     \"unsupported load permutation\\n\");\n \t\t  return false;\n \t\t}\n \t    }\n@@ -2592,9 +2601,10 @@ vect_slp_analyze_operations (vec_info *vinfo)\n         {\n \t  slp_tree node = SLP_INSTANCE_TREE (instance);\n \t  stmt_vec_info stmt_info = SLP_TREE_SCALAR_STMTS (node)[0];\n-\t  dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t   \"removing SLP instance operations starting from: %G\",\n-\t\t\t   stmt_info->stmt);\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"removing SLP instance operations starting from: %G\",\n+\t\t\t     stmt_info->stmt);\n \t  vect_free_slp_instance (instance, false);\n           vinfo->slp_instances.ordered_remove (i);\n \t  cost_vec.release ();\n@@ -2888,9 +2898,10 @@ vect_slp_analyze_bb_1 (gimple_stmt_iterator region_begin,\n \t{\n \t  slp_tree node = SLP_INSTANCE_TREE (instance);\n \t  stmt_vec_info stmt_info = SLP_TREE_SCALAR_STMTS (node)[0];\n-\t  dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t   \"removing SLP instance operations starting from: %G\",\n-\t\t\t   stmt_info->stmt);\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"removing SLP instance operations starting from: %G\",\n+\t\t\t     stmt_info->stmt);\n \t  vect_free_slp_instance (instance, false);\n \t  BB_VINFO_SLP_INSTANCES (bb_vinfo).ordered_remove (i);\n \t  continue;\n@@ -3006,14 +3017,17 @@ vect_slp_bb (basic_block bb)\n \t  vect_schedule_slp (bb_vinfo);\n \n \t  unsigned HOST_WIDE_INT bytes;\n-\t  if (current_vector_size.is_constant (&bytes))\n-\t    dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,\n-\t\t\t     \"basic block part vectorized using %wu byte \"\n-\t\t\t     \"vectors\\n\", bytes);\n-\t  else\n-\t    dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,\n-\t\t\t     \"basic block part vectorized using variable \"\n-\t\t\t     \"length vectors\\n\");\n+\t  if (dump_enabled_p ())\n+\t    {\n+\t      if (current_vector_size.is_constant (&bytes))\n+\t\tdump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,\n+\t\t\t\t \"basic block part vectorized using %wu byte \"\n+\t\t\t\t \"vectors\\n\", bytes);\n+\t      else\n+\t\tdump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,\n+\t\t\t\t \"basic block part vectorized using variable \"\n+\t\t\t\t \"length vectors\\n\");\n+\t    }\n \n \t  vectorized = true;\n \t}"}, {"sha": "74646570e2a3b6963cb9e1bf5b332024c2c77173", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbeeac91f96bdcbc3eb40ec68c1fd8cf5d4a038d/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbeeac91f96bdcbc3eb40ec68c1fd8cf5d4a038d/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=bbeeac91f96bdcbc3eb40ec68c1fd8cf5d4a038d", "patch": "@@ -9530,8 +9530,9 @@ vect_analyze_stmt (stmt_vec_info stmt_info, bool *need_to_vectorize,\n \n   if (PURE_SLP_STMT (stmt_info) && !node)\n     {\n-      dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t       \"handled only by SLP analysis\\n\");\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"handled only by SLP analysis\\n\");\n       return opt_result::success ();\n     }\n "}, {"sha": "0a4eca51ad7b93b32ba136372589eac50de9ac79", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbeeac91f96bdcbc3eb40ec68c1fd8cf5d4a038d/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbeeac91f96bdcbc3eb40ec68c1fd8cf5d4a038d/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=bbeeac91f96bdcbc3eb40ec68c1fd8cf5d4a038d", "patch": "@@ -925,8 +925,9 @@ try_vectorize_loop_1 (hash_table<simduid_to_vf> *&simduid_to_vf_htab,\n \t    }\n \t  if (!require_loop_vectorize && vect_slp_bb (bb))\n \t    {\n-\t      dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t       \"basic block vectorized\\n\");\n+\t      if (dump_enabled_p ())\n+\t\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t\t \"basic block vectorized\\n\");\n \t      fold_loop_internal_call (loop_vectorized_call,\n \t\t\t\t       boolean_true_node);\n \t      loop_vectorized_call = NULL;\n@@ -955,12 +956,15 @@ try_vectorize_loop_1 (hash_table<simduid_to_vf> *&simduid_to_vf_htab,\n     set_uid_loop_bbs (loop_vinfo, loop_vectorized_call);\n \n   unsigned HOST_WIDE_INT bytes;\n-  if (current_vector_size.is_constant (&bytes))\n-    dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,\n-\t\t     \"loop vectorized using %wu byte vectors\\n\", bytes);\n-  else\n-    dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,\n-\t\t     \"loop vectorized using variable length vectors\\n\");\n+  if (dump_enabled_p ())\n+    {\n+      if (current_vector_size.is_constant (&bytes))\n+\tdump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,\n+\t\t\t \"loop vectorized using %wu byte vectors\\n\", bytes);\n+      else\n+\tdump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,\n+\t\t\t \"loop vectorized using variable length vectors\\n\");\n+    }\n \n   loop_p new_loop = vect_transform_loop (loop_vinfo);\n   (*num_vectorized_loops)++;\n@@ -1289,7 +1293,8 @@ pass_slp_vectorize::execute (function *fun)\n   FOR_EACH_BB_FN (bb, fun)\n     {\n       if (vect_slp_bb (bb))\n-\tdump_printf_loc (MSG_NOTE, vect_location, \"basic block vectorized\\n\");\n+\tif (dump_enabled_p ())\n+\t  dump_printf_loc (MSG_NOTE, vect_location, \"basic block vectorized\\n\");\n     }\n \n   if (!in_loop_pipeline)\n@@ -1447,7 +1452,8 @@ increase_alignment (void)\n       if (alignment && vect_can_force_dr_alignment_p (decl, alignment))\n         {\n \t  vnode->increase_alignment (alignment);\n-          dump_printf (MSG_NOTE, \"Increasing alignment of decl: %T\\n\", decl);\n+\t  if (dump_enabled_p ())\n+\t    dump_printf (MSG_NOTE, \"Increasing alignment of decl: %T\\n\", decl);\n         }\n     }\n "}]}