{"sha": "356edbd763bb467a126d12fcd42d0e00a6cd6b9a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzU2ZWRiZDc2M2JiNDY3YTEyNmQxMmZjZDQyZDBlMDBhNmNkNmI5YQ==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1999-10-17T06:28:22Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-10-17T06:28:22Z"}, "message": "haifa-sched.c (true_dependency_cache): New.\n\n        * haifa-sched.c (true_dependency_cache): New.\n        (add_dependence): Use the true dependency cache to avoid expensive\n        walks down the LOG_LINKS dependency list.  Add entries to the\n        cache as necessary.\n        (remove_dependence): Remove entries from the true dependency cache\n        as needed.\n        (schedule_insns): Allocate and initialize and free the true\n        dependency cache.\n\nFrom-SVN: r30050", "tree": {"sha": "c62d0c62cce1e14b652eaa1b197057e82345ae91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c62d0c62cce1e14b652eaa1b197057e82345ae91"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/356edbd763bb467a126d12fcd42d0e00a6cd6b9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/356edbd763bb467a126d12fcd42d0e00a6cd6b9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/356edbd763bb467a126d12fcd42d0e00a6cd6b9a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/356edbd763bb467a126d12fcd42d0e00a6cd6b9a/comments", "author": null, "committer": null, "parents": [{"sha": "e75f2df7e5fd0e630926bb8f0b73198437b8ee7d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e75f2df7e5fd0e630926bb8f0b73198437b8ee7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e75f2df7e5fd0e630926bb8f0b73198437b8ee7d"}], "stats": {"total": 47, "additions": 46, "deletions": 1}, "files": [{"sha": "37612347277141c017d4ea1b5aecc988ab0088b5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/356edbd763bb467a126d12fcd42d0e00a6cd6b9a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/356edbd763bb467a126d12fcd42d0e00a6cd6b9a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=356edbd763bb467a126d12fcd42d0e00a6cd6b9a", "patch": "@@ -1,5 +1,14 @@\n Sat Oct 16 21:50:28 1999  Jeffrey A Law  (law@cygnus.com)\n \n+\t* haifa-sched.c (true_dependency_cache): New.\n+\t(add_dependence): Use the true dependency cache to avoid expensive\n+\twalks down the LOG_LINKS dependency list.  Add entries to the\n+\tcache as necessary.\n+\t(remove_dependence): Remove entries from the true dependency cache\n+\tas needed.\n+\t(schedule_insns): Allocate and initialize and free the true\n+\tdependency cache.\n+\n \t* haifa-sched.c (schedule_insns): Do not remove inter-block\n \tdependencies anymore.\n "}, {"sha": "7279226f1daa50e41bdcb2034875eb1b76599863", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/356edbd763bb467a126d12fcd42d0e00a6cd6b9a/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/356edbd763bb467a126d12fcd42d0e00a6cd6b9a/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=356edbd763bb467a126d12fcd42d0e00a6cd6b9a", "patch": "@@ -247,6 +247,14 @@ static int reg_pending_sets_all;\n static int *insn_luid;\n #define INSN_LUID(INSN) (insn_luid[INSN_UID (INSN)])\n \n+/* To speed up the test for duplicate dependency links we keep a record\n+   of true dependencies created by add_dependence.\n+\n+   Each insn has an associated bitmap for its dependencies.  Each bitmap\n+   has enough entries to represent a dependency on any other insn in the\n+   insn chain.  */\n+static sbitmap *true_dependency_cache;\n+\n /* Vector indexed by INSN_UID giving each instruction a priority.  */\n static int *insn_priority;\n #define INSN_PRIORITY(INSN) (insn_priority[INSN_UID (INSN)])\n@@ -783,6 +791,12 @@ add_dependence (insn, elem, dep_type)\n \n #endif\n \n+  /* If we already have a true dependency for ELEM, then we do not\n+     need to do anything.  Avoiding the list walk below can cut\n+     compile times dramatically for some code.  */\n+  if (TEST_BIT (true_dependency_cache[INSN_LUID (insn)], INSN_LUID (elem)))\n+    return;\n+\n   /* Check that we don't already have this dependence.  */\n   for (link = LOG_LINKS (insn); link; link = XEXP (link, 1))\n     if (XEXP (link, 0) == elem)\n@@ -791,6 +805,11 @@ add_dependence (insn, elem, dep_type)\n \t   one, then change the existing dependence to this type.  */\n \tif ((int) dep_type < (int) REG_NOTE_KIND (link))\n \t  PUT_REG_NOTE_KIND (link, dep_type);\n+\n+\t/* If we are adding a true dependency to INSN's LOG_LINKs, then\n+\t   note that in the bitmap cache of true dependency information.  */\n+\tif ((int)dep_type == 0)\n+\t  SET_BIT (true_dependency_cache[INSN_LUID (insn)], INSN_LUID (elem));\n \treturn;\n       }\n   /* Might want to check one level of transitivity to save conses.  */\n@@ -822,6 +841,13 @@ remove_dependence (insn, elem)\n \t    XEXP (prev, 1) = next;\n \t  else\n \t    LOG_LINKS (insn) = next;\n+\n+\t  /* If we are removing a true dependency from the LOG_LINKS list,\n+\t     make sure to remove it from the cache too.  */\n+\t  if (REG_NOTE_KIND (link) == 0)\n+\t    RESET_BIT (true_dependency_cache[INSN_LUID (insn)],\n+\t\t       INSN_LUID (elem));\n+\n \t  free_INSN_LIST_node (link);\n \n \t  found = 1;\n@@ -6834,7 +6860,10 @@ schedule_insns (dump_file)\n   insn_orig_block = (int *) xmalloc (max_uid * sizeof (int));\n   insn_luid = (int *) xmalloc (max_uid * sizeof (int));\n \n-  luid = 0;\n+  /* We use LUID 0 for the fake insn (UID 0) which holds dependencies for\n+     pseudos which do not cross calls.  */\n+  insn_luid[0] = 0;\n+  luid = 1;\n   for (b = 0; b < n_basic_blocks; b++)\n     for (insn = BLOCK_HEAD (b);; insn = NEXT_INSN (insn))\n       {\n@@ -6844,6 +6873,12 @@ schedule_insns (dump_file)\n \tif (insn == BLOCK_END (b))\n \t  break;\n       }\n+  \n+  /* ?!? We could save some memory by computing a per-region luid mapping\n+     which could reduce both the number of vectors in the cache and the size\n+     of each vector.  */\n+  true_dependency_cache = sbitmap_vector_alloc (luid, luid);\n+  sbitmap_vector_zero (true_dependency_cache, luid);\n \n   nr_regions = 0;\n   rgn_table = (region *) alloca ((n_basic_blocks) * sizeof (region));\n@@ -7012,6 +7047,7 @@ schedule_insns (dump_file)\n       fprintf (dump, \"\\n\\n\");\n     }\n \n+  free (true_dependency_cache);\n   free (cant_move);\n   free (fed_by_spec_load);\n   free (is_load_insn);"}]}