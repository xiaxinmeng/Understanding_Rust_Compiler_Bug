{"sha": "5b735706d761958d6702b8076ffa02e093546362", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWI3MzU3MDZkNzYxOTU4ZDY3MDJiODA3NmZmYTAyZTA5MzU0NjM2Mg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-05-07T00:12:32Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-05-07T00:12:32Z"}, "message": "Use backend types for all type conversions.\n\nFrom-SVN: r173520", "tree": {"sha": "81e5cb136de9c20f51a198f22e1058cd3af26942", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/81e5cb136de9c20f51a198f22e1058cd3af26942"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5b735706d761958d6702b8076ffa02e093546362", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b735706d761958d6702b8076ffa02e093546362", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b735706d761958d6702b8076ffa02e093546362", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b735706d761958d6702b8076ffa02e093546362/comments", "author": null, "committer": null, "parents": [{"sha": "c47d00347d7e74193dda2e9a3f55f52485e7eeeb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c47d00347d7e74193dda2e9a3f55f52485e7eeeb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c47d00347d7e74193dda2e9a3f55f52485e7eeeb"}], "stats": {"total": 572, "additions": 286, "deletions": 286}, "files": [{"sha": "93384867f41f3a5a1220124da5a3ee48d754287c", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 91, "deletions": 62, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b735706d761958d6702b8076ffa02e093546362/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b735706d761958d6702b8076ffa02e093546362/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=5b735706d761958d6702b8076ffa02e093546362", "patch": "@@ -214,7 +214,7 @@ Expression::convert_for_assignment(Translate_context* context, Type* lhs_type,\n \n   Gogo* gogo = context->gogo();\n \n-  tree lhs_type_tree = lhs_type->get_tree(gogo);\n+  tree lhs_type_tree = type_to_tree(lhs_type->get_backend(gogo));\n   if (lhs_type_tree == error_mark_node)\n     return error_mark_node;\n \n@@ -323,7 +323,7 @@ Expression::convert_type_to_interface(Translate_context* context,\n   // This should have been checked already.\n   go_assert(lhs_interface_type->implements_interface(rhs_type, NULL));\n \n-  tree lhs_type_tree = lhs_type->get_tree(gogo);\n+  tree lhs_type_tree = type_to_tree(lhs_type->get_backend(gogo));\n   if (lhs_type_tree == error_mark_node)\n     return error_mark_node;\n \n@@ -456,7 +456,7 @@ Expression::convert_interface_to_interface(Translate_context* context,\n   Interface_type* lhs_interface_type = lhs_type->interface_type();\n   bool lhs_is_empty = lhs_interface_type->is_empty();\n \n-  tree lhs_type_tree = lhs_type->get_tree(gogo);\n+  tree lhs_type_tree = type_to_tree(lhs_type->get_backend(gogo));\n   if (lhs_type_tree == error_mark_node)\n     return error_mark_node;\n \n@@ -567,7 +567,7 @@ Expression::convert_interface_to_type(Translate_context* context,\n   Gogo* gogo = context->gogo();\n   tree rhs_type_tree = TREE_TYPE(rhs_tree);\n \n-  tree lhs_type_tree = lhs_type->get_tree(gogo);\n+  tree lhs_type_tree = type_to_tree(lhs_type->get_backend(gogo));\n   if (lhs_type_tree == error_mark_node)\n     return error_mark_node;\n \n@@ -1041,7 +1041,8 @@ Temporary_reference_expression::do_get_tree(Translate_context* context)\n   tree ret = var_to_tree(bvar);\n   if (POINTER_TYPE_P(TREE_TYPE(ret)) && VOID_TYPE_P(TREE_TYPE(TREE_TYPE(ret))))\n     {\n-      tree type_tree = this->type()->base()->get_tree(context->gogo());\n+      Btype* type_btype = this->type()->base()->get_backend(context->gogo());\n+      tree type_tree = type_to_tree(type_btype);\n       ret = fold_convert_loc(this->location(), type_tree, ret);\n     }\n   return ret;\n@@ -1119,8 +1120,8 @@ Sink_expression::do_get_tree(Translate_context* context)\n   if (this->var_ == NULL_TREE)\n     {\n       go_assert(this->type_ != NULL && !this->type_->is_sink_type());\n-      this->var_ = create_tmp_var(this->type_->get_tree(context->gogo()),\n-\t\t\t\t  \"blank\");\n+      Btype* bt = this->type_->get_backend(context->gogo());\n+      this->var_ = create_tmp_var(type_to_tree(bt), \"blank\");\n     }\n   return this->var_;\n }\n@@ -1701,16 +1702,18 @@ Integer_expression::do_get_tree(Translate_context* context)\n   Gogo* gogo = context->gogo();\n   tree type;\n   if (this->type_ != NULL && !this->type_->is_abstract())\n-    type = this->type_->get_tree(gogo);\n+    type = type_to_tree(this->type_->get_backend(gogo));\n   else if (this->type_ != NULL && this->type_->float_type() != NULL)\n     {\n       // We are converting to an abstract floating point type.\n-      type = Type::lookup_float_type(\"float64\")->get_tree(gogo);\n+      Type* ftype = Type::lookup_float_type(\"float64\");\n+      type = type_to_tree(ftype->get_backend(gogo));\n     }\n   else if (this->type_ != NULL && this->type_->complex_type() != NULL)\n     {\n       // We are converting to an abstract complex type.\n-      type = Type::lookup_complex_type(\"complex128\")->get_tree(gogo);\n+      Type* ctype = Type::lookup_complex_type(\"complex128\");\n+      type = type_to_tree(ctype->get_backend(gogo));\n     }\n   else\n     {\n@@ -1720,9 +1723,15 @@ Integer_expression::do_get_tree(Translate_context* context)\n       // not <=, because we need an extra bit for the sign bit.\n       int bits = mpz_sizeinbase(this->val_, 2);\n       if (bits < INT_TYPE_SIZE)\n-\ttype = Type::lookup_integer_type(\"int\")->get_tree(gogo);\n+\t{\n+\t  Type* t = Type::lookup_integer_type(\"int\");\n+\t  type = type_to_tree(t->get_backend(gogo));\n+\t}\n       else if (bits < 64)\n-\ttype = Type::lookup_integer_type(\"int64\")->get_tree(gogo);\n+\t{\n+\t  Type* t = Type::lookup_integer_type(\"int64\");\n+\t  type = type_to_tree(t->get_backend(gogo));\n+\t}\n       else\n \ttype = long_long_integer_type_node;\n     }\n@@ -2028,18 +2037,19 @@ Float_expression::do_get_tree(Translate_context* context)\n   Gogo* gogo = context->gogo();\n   tree type;\n   if (this->type_ != NULL && !this->type_->is_abstract())\n-    type = this->type_->get_tree(gogo);\n+    type = type_to_tree(this->type_->get_backend(gogo));\n   else if (this->type_ != NULL && this->type_->integer_type() != NULL)\n     {\n       // We have an abstract integer type.  We just hope for the best.\n-      type = Type::lookup_integer_type(\"int\")->get_tree(gogo);\n+      type = type_to_tree(Type::lookup_integer_type(\"int\")->get_backend(gogo));\n     }\n   else\n     {\n       // If we still have an abstract type here, then this is being\n       // used in a constant expression which didn't get reduced.  We\n       // just use float64 and hope for the best.\n-      type = Type::lookup_float_type(\"float64\")->get_tree(gogo);\n+      Type* ft = Type::lookup_float_type(\"float64\");\n+      type = type_to_tree(ft->get_backend(gogo));\n     }\n   return Expression::float_constant_tree(this->val_, type);\n }\n@@ -2266,13 +2276,14 @@ Complex_expression::do_get_tree(Translate_context* context)\n   Gogo* gogo = context->gogo();\n   tree type;\n   if (this->type_ != NULL && !this->type_->is_abstract())\n-    type = this->type_->get_tree(gogo);\n+    type = type_to_tree(this->type_->get_backend(gogo));\n   else\n     {\n       // If we still have an abstract type here, this this is being\n       // used in a constant expression which didn't get reduced.  We\n       // just use complex128 and hope for the best.\n-      type = Type::lookup_complex_type(\"complex128\")->get_tree(gogo);\n+      Type* ct = Type::lookup_complex_type(\"complex128\");\n+      type = type_to_tree(ct->get_backend(gogo));\n     }\n   return Expression::complex_constant_tree(this->real_, this->imag_, type);\n }\n@@ -2718,7 +2729,7 @@ Const_expression::do_get_tree(Translate_context* context)\n     type_tree = NULL_TREE;\n   else\n     {\n-      type_tree = this->type_->get_tree(gogo);\n+      type_tree = type_to_tree(this->type_->get_backend(gogo));\n       if (type_tree == error_mark_node)\n \treturn error_mark_node;\n     }\n@@ -3344,7 +3355,7 @@ tree\n Type_conversion_expression::do_get_tree(Translate_context* context)\n {\n   Gogo* gogo = context->gogo();\n-  tree type_tree = this->type_->get_tree(gogo);\n+  tree type_tree = type_to_tree(this->type_->get_backend(gogo));\n   tree expr_tree = this->expr_->get_tree(context);\n \n   if (type_tree == error_mark_node\n@@ -3601,7 +3612,7 @@ Unsafe_type_conversion_expression::do_get_tree(Translate_context* context)\n   Type* t = this->type_;\n   Type* et = this->expr_->type();\n \n-  tree type_tree = this->type_->get_tree(context->gogo());\n+  tree type_tree = type_to_tree(this->type_->get_backend(context->gogo()));\n   tree expr_tree = this->expr_->get_tree(context);\n   if (type_tree == error_mark_node || expr_tree == error_mark_node)\n     return error_mark_node;\n@@ -4304,7 +4315,7 @@ Unary_expression::do_get_tree(Translate_context* context)\n \tif (TREE_TYPE(TREE_TYPE(expr)) == ptr_type_node)\n \t  {\n \t    Type* pt = this->expr_->type()->points_to();\n-\t    tree ind = pt->get_tree(context->gogo());\n+\t    tree ind = type_to_tree(pt->get_backend(context->gogo()));\n \t    expr = fold_convert_loc(loc, build_pointer_type(ind), expr);\n \t  }\n \n@@ -5984,7 +5995,8 @@ Binary_expression::do_get_tree(Translate_context* context)\n   if (this->left_->type()->is_string_type())\n     {\n       go_assert(this->op_ == OPERATOR_PLUS);\n-      tree string_type = Type::make_string_type()->get_tree(context->gogo());\n+      Type* st = Type::make_string_type();\n+      tree string_type = type_to_tree(st->get_backend(context->gogo()));\n       static tree string_plus_decl;\n       return Gogo::call_builtin(&string_plus_decl,\n \t\t\t\tthis->location(),\n@@ -6313,7 +6325,8 @@ Expression::comparison_tree(Translate_context* context, Operator op,\n \n   if (left_type->is_string_type() && right_type->is_string_type())\n     {\n-      tree string_type = Type::make_string_type()->get_tree(context->gogo());\n+      Type* st = Type::make_string_type();\n+      tree string_type = type_to_tree(st->get_backend(context->gogo()));\n       static tree string_compare_decl;\n       left_tree = Gogo::call_builtin(&string_compare_decl,\n \t\t\t\t     location,\n@@ -7151,7 +7164,7 @@ Builtin_call_expression::do_integer_constant_value(bool iota_is_constant,\n \treturn false;\n       if (arg_type->named_type() != NULL)\n \targ_type->named_type()->convert(this->gogo_);\n-      tree arg_type_tree = arg_type->get_tree(this->gogo_);\n+      tree arg_type_tree = type_to_tree(arg_type->get_backend(this->gogo_));\n       if (arg_type_tree == error_mark_node)\n \treturn false;\n       unsigned long val_long;\n@@ -7197,7 +7210,7 @@ Builtin_call_expression::do_integer_constant_value(bool iota_is_constant,\n \treturn false;\n       if (st->named_type() != NULL)\n \tst->named_type()->convert(this->gogo_);\n-      tree struct_tree = st->get_tree(this->gogo_);\n+      tree struct_tree = type_to_tree(st->get_backend(this->gogo_));\n       go_assert(TREE_CODE(struct_tree) == RECORD_TYPE);\n       tree field = TYPE_FIELDS(struct_tree);\n       for (unsigned int index = farg->field_index(); index > 0; --index)\n@@ -7792,24 +7805,26 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n \t      }\n \t    else if (arg_type->map_type() != NULL)\n \t      {\n+\t\ttree arg_type_tree = type_to_tree(arg_type->get_backend(gogo));\n \t\tstatic tree map_len_fndecl;\n \t\tval_tree = Gogo::call_builtin(&map_len_fndecl,\n \t\t\t\t\t      location,\n \t\t\t\t\t      \"__go_map_len\",\n \t\t\t\t\t      1,\n \t\t\t\t\t      integer_type_node,\n-\t\t\t\t\t      arg_type->get_tree(gogo),\n+\t\t\t\t\t      arg_type_tree,\n \t\t\t\t\t      arg_tree);\n \t      }\n \t    else if (arg_type->channel_type() != NULL)\n \t      {\n+\t\ttree arg_type_tree = type_to_tree(arg_type->get_backend(gogo));\n \t\tstatic tree chan_len_fndecl;\n \t\tval_tree = Gogo::call_builtin(&chan_len_fndecl,\n \t\t\t\t\t      location,\n \t\t\t\t\t      \"__go_chan_len\",\n \t\t\t\t\t      1,\n \t\t\t\t\t      integer_type_node,\n-\t\t\t\t\t      arg_type->get_tree(gogo),\n+\t\t\t\t\t      arg_type_tree,\n \t\t\t\t\t      arg_tree);\n \t      }\n \t    else\n@@ -7831,13 +7846,14 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n \t      }\n \t    else if (arg_type->channel_type() != NULL)\n \t      {\n+\t\ttree arg_type_tree = type_to_tree(arg_type->get_backend(gogo));\n \t\tstatic tree chan_cap_fndecl;\n \t\tval_tree = Gogo::call_builtin(&chan_cap_fndecl,\n \t\t\t\t\t      location,\n \t\t\t\t\t      \"__go_chan_cap\",\n \t\t\t\t\t      1,\n \t\t\t\t\t      integer_type_node,\n-\t\t\t\t\t      arg_type->get_tree(gogo),\n+\t\t\t\t\t      arg_type_tree,\n \t\t\t\t\t      arg_tree);\n \t      }\n \t    else\n@@ -7847,7 +7863,8 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n \tif (val_tree == error_mark_node)\n \t  return error_mark_node;\n \n-\ttree type_tree = Type::lookup_integer_type(\"int\")->get_tree(gogo);\n+\tType* int_type = Type::lookup_integer_type(\"int\");\n+\ttree type_tree = type_to_tree(int_type->get_backend(gogo));\n \tif (type_tree == TREE_TYPE(val_tree))\n \t  return val_tree;\n \telse\n@@ -7901,17 +7918,17 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n \t\t    pfndecl = &print_uint64_fndecl;\n \t\t    fnname = \"__go_print_uint64\";\n \t\t    Type* itype = Type::lookup_integer_type(\"uint64\");\n-\t\t    arg = fold_convert_loc(location, itype->get_tree(gogo),\n-\t\t\t\t\t   arg);\n+\t\t    Btype* bitype = itype->get_backend(gogo);\n+\t\t    arg = fold_convert_loc(location, type_to_tree(bitype), arg);\n \t\t  }\n \t\telse if (type->integer_type() != NULL)\n \t\t  {\n \t\t    static tree print_int64_fndecl;\n \t\t    pfndecl = &print_int64_fndecl;\n \t\t    fnname = \"__go_print_int64\";\n \t\t    Type* itype = Type::lookup_integer_type(\"int64\");\n-\t\t    arg = fold_convert_loc(location, itype->get_tree(gogo),\n-\t\t\t\t\t   arg);\n+\t\t    Btype* bitype = itype->get_backend(gogo);\n+\t\t    arg = fold_convert_loc(location, type_to_tree(bitype), arg);\n \t\t  }\n \t\telse if (type->float_type() != NULL)\n \t\t  {\n@@ -8038,7 +8055,7 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n \t  return error_mark_node;\n \n \tType *empty = Type::make_interface_type(NULL, BUILTINS_LOCATION);\n-\ttree empty_tree = empty->get_tree(context->gogo());\n+\ttree empty_tree = type_to_tree(empty->get_backend(context->gogo()));\n \n \tType* nil_type = Type::make_nil_type();\n \tExpression* nil = Expression::make_nil(location);\n@@ -8108,7 +8125,8 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n \t    go_assert(saw_errors());\n \t    return error_mark_node;\n \t  }\n-\ttree type = Type::lookup_integer_type(\"int\")->get_tree(gogo);\n+\tType* int_type = Type::lookup_integer_type(\"int\");\n+\ttree type = type_to_tree(int_type->get_backend(gogo));\n \ttree ret = Expression::integer_constant_tree(val, type);\n \tmpz_clear(val);\n \treturn ret;\n@@ -8163,7 +8181,8 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n \tlen = save_expr(len);\n \n \tType* element_type = at->element_type();\n-\ttree element_type_tree = element_type->get_tree(gogo);\n+\tBtype* element_btype = element_type->get_backend(gogo);\n+\ttree element_type_tree = type_to_tree(element_btype);\n \tif (element_type_tree == error_mark_node)\n \t  return error_mark_node;\n \ttree element_size = TYPE_SIZE_UNIT(element_type_tree);\n@@ -8226,7 +8245,7 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n \targ2_val = fold_convert_loc(location, ptr_type_node, arg2_val);\n \targ2_len = fold_convert_loc(location, size_type_node, arg2_len);\n \n-\ttree element_type_tree = element_type->get_tree(gogo);\n+\ttree element_type_tree = type_to_tree(element_type->get_backend(gogo));\n \tif (element_type_tree == error_mark_node)\n \t  return error_mark_node;\n \ttree element_size = TYPE_SIZE_UNIT(element_type_tree);\n@@ -8813,7 +8832,8 @@ Call_expression::bound_method_function(Translate_context* context,\n     {\n       if (fatype->points_to() == NULL)\n \tfatype = Type::make_pointer_type(fatype);\n-      first_arg = fold_convert(fatype->get_tree(context->gogo()), first_arg);\n+      Btype* bfatype = fatype->get_backend(context->gogo());\n+      first_arg = fold_convert(type_to_tree(bfatype), first_arg);\n       if (first_arg == error_mark_node\n \t  || TREE_TYPE(first_arg) == error_mark_node)\n \treturn error_mark_node;\n@@ -8910,7 +8930,7 @@ Call_expression::do_get_tree(Translate_context* context)\n       go_assert(i == nargs);\n     }\n \n-  tree rettype = TREE_TYPE(TREE_TYPE(fntype->get_tree(gogo)));\n+  tree rettype = TREE_TYPE(TREE_TYPE(type_to_tree(fntype->get_backend(gogo))));\n   if (rettype == error_mark_node)\n     {\n       delete[] args;\n@@ -8943,7 +8963,7 @@ Call_expression::do_get_tree(Translate_context* context)\n   // type which refers to itself.\n   if (!DECL_P(fndecl) || !DECL_IS_BUILTIN(fndecl))\n     {\n-      tree fnt = fntype->get_tree(gogo);\n+      tree fnt = type_to_tree(fntype->get_backend(gogo));\n       if (fnt == error_mark_node)\n \treturn error_mark_node;\n       fn = fold_convert_loc(location, fnt, fn);\n@@ -8995,7 +9015,7 @@ Call_expression::do_get_tree(Translate_context* context)\n   // to the correct type.\n   if (TREE_TYPE(ret) == ptr_type_node)\n     {\n-      tree t = this->type()->base()->get_tree(gogo);\n+      tree t = type_to_tree(this->type()->base()->get_backend(gogo));\n       ret = fold_convert_loc(location, t, ret);\n     }\n \n@@ -9469,7 +9489,7 @@ Array_index_expression::do_get_tree(Translate_context* context)\n       return error_mark_node;\n     }\n \n-  tree type_tree = array_type->get_tree(gogo);\n+  tree type_tree = type_to_tree(array_type->get_backend(gogo));\n   if (type_tree == error_mark_node)\n     return error_mark_node;\n \n@@ -9536,7 +9556,9 @@ Array_index_expression::do_get_tree(Translate_context* context)\n \t{\n \t  // Open array.\n \t  tree values = array_type->value_pointer_tree(gogo, array_tree);\n-\t  tree element_type_tree = array_type->element_type()->get_tree(gogo);\n+\t  Type* element_type = array_type->element_type();\n+\t  Btype* belement_type = element_type->get_backend(gogo);\n+\t  tree element_type_tree = type_to_tree(belement_type);\n \t  if (element_type_tree == error_mark_node)\n \t    return error_mark_node;\n \t  tree element_size = TYPE_SIZE_UNIT(element_type_tree);\n@@ -9585,7 +9607,8 @@ Array_index_expression::do_get_tree(Translate_context* context)\n \t\t\t\t  bad_index, bad_end);\n     }\n \n-  tree element_type_tree = array_type->element_type()->get_tree(gogo);\n+  Type* element_type = array_type->element_type();\n+  tree element_type_tree = type_to_tree(element_type->get_backend(gogo));\n   if (element_type_tree == error_mark_node)\n     return error_mark_node;\n   tree element_size = TYPE_SIZE_UNIT(element_type_tree);\n@@ -9608,7 +9631,7 @@ Array_index_expression::do_get_tree(Translate_context* context)\n   tree result_capacity_tree = fold_build2_loc(loc, MINUS_EXPR, length_type,\n \t\t\t\t\t      capacity_tree, start_tree);\n \n-  tree struct_tree = this->type()->get_tree(gogo);\n+  tree struct_tree = type_to_tree(this->type()->get_backend(gogo));\n   go_assert(TREE_CODE(struct_tree) == RECORD_TYPE);\n \n   VEC(constructor_elt,gc)* init = VEC_alloc(constructor_elt, gc, 3);\n@@ -10098,7 +10121,8 @@ Map_index_expression::get_value_pointer(Translate_context* context,\n   // an uncomparable or unhashable type.\n   TREE_NOTHROW(map_index_fndecl) = 0;\n \n-  tree val_type_tree = type->val_type()->get_tree(context->gogo());\n+  Type* val_type = type->val_type();\n+  tree val_type_tree = type_to_tree(val_type->get_backend(context->gogo()));\n   if (val_type_tree == error_mark_node)\n     return error_mark_node;\n   tree ptr_val_type_tree = build_pointer_type(val_type_tree);\n@@ -10629,7 +10653,7 @@ Allocation_expression::do_check_types(Gogo*)\n tree\n Allocation_expression::do_get_tree(Translate_context* context)\n {\n-  tree type_tree = this->type_->get_tree(context->gogo());\n+  tree type_tree = type_to_tree(this->type_->get_backend(context->gogo()));\n   if (type_tree == error_mark_node)\n     return error_mark_node;\n   tree size_tree = TYPE_SIZE_UNIT(type_tree);\n@@ -10933,7 +10957,7 @@ Struct_construction_expression::do_get_tree(Translate_context* context)\n   if (this->vals_ == NULL)\n     return this->type_->get_init_tree(gogo, false);\n \n-  tree type_tree = this->type_->get_tree(gogo);\n+  tree type_tree = type_to_tree(this->type_->get_backend(gogo));\n   if (type_tree == error_mark_node)\n     return error_mark_node;\n   go_assert(TREE_CODE(type_tree) == RECORD_TYPE);\n@@ -11269,8 +11293,9 @@ class Fixed_array_construction_expression :\n tree\n Fixed_array_construction_expression::do_get_tree(Translate_context* context)\n {\n-  return this->get_constructor_tree(context,\n-\t\t\t\t    this->type()->get_tree(context->gogo()));\n+  Type* type = this->type();\n+  Btype* btype = type->get_backend(context->gogo());\n+  return this->get_constructor_tree(context, type_to_tree(btype));\n }\n \n // Construct an open array.\n@@ -11317,7 +11342,8 @@ Open_array_construction_expression::do_get_tree(Translate_context* context)\n     }\n \n   Type* element_type = array_type->element_type();\n-  tree element_type_tree = element_type->get_tree(context->gogo());\n+  Btype* belement_type = element_type->get_backend(context->gogo());\n+  tree element_type_tree = type_to_tree(belement_type);\n   if (element_type_tree == error_mark_node)\n     return error_mark_node;\n \n@@ -11410,7 +11436,7 @@ Open_array_construction_expression::do_get_tree(Translate_context* context)\n \n   // Build a constructor for the open array.\n \n-  tree type_tree = this->type()->get_tree(context->gogo());\n+  tree type_tree = type_to_tree(this->type()->get_backend(context->gogo()));\n   if (type_tree == error_mark_node)\n     return error_mark_node;\n   go_assert(TREE_CODE(type_tree) == RECORD_TYPE);\n@@ -11587,7 +11613,7 @@ Map_construction_expression::do_get_tree(Translate_context* context)\n \n   Type* key_type = mt->key_type();\n   tree id = get_identifier(\"__key\");\n-  tree key_type_tree = key_type->get_tree(gogo);\n+  tree key_type_tree = type_to_tree(key_type->get_backend(gogo));\n   if (key_type_tree == error_mark_node)\n     return error_mark_node;\n   tree key_field = build_decl(loc, FIELD_DECL, id, key_type_tree);\n@@ -11596,7 +11622,7 @@ Map_construction_expression::do_get_tree(Translate_context* context)\n \n   Type* val_type = mt->val_type();\n   id = get_identifier(\"__val\");\n-  tree val_type_tree = val_type->get_tree(gogo);\n+  tree val_type_tree = type_to_tree(val_type->get_backend(gogo));\n   if (val_type_tree == error_mark_node)\n     return error_mark_node;\n   tree val_field = build_decl(loc, FIELD_DECL, id, val_type_tree);\n@@ -11699,7 +11725,7 @@ Map_construction_expression::do_get_tree(Translate_context* context)\n \n   tree descriptor = gogo->map_descriptor(mt);\n \n-  tree type_tree = this->type_->get_tree(gogo);\n+  tree type_tree = type_to_tree(this->type_->get_backend(gogo));\n   if (type_tree == error_mark_node)\n     return error_mark_node;\n \n@@ -12345,10 +12371,12 @@ Type_guard_expression::do_get_tree(Translate_context* context)\n \t   || expr_type->integer_type() != NULL))\n       || (expr_type->is_unsafe_pointer_type()\n \t  && this->type_->points_to() != NULL))\n-    return convert_to_pointer(this->type_->get_tree(gogo), expr_tree);\n+    return convert_to_pointer(type_to_tree(this->type_->get_backend(gogo)),\n+\t\t\t      expr_tree);\n   else if (expr_type->is_unsafe_pointer_type()\n \t   && this->type_->integer_type() != NULL)\n-    return convert_to_integer(this->type_->get_tree(gogo), expr_tree);\n+    return convert_to_integer(type_to_tree(this->type_->get_backend(gogo)),\n+\t\t\t      expr_tree);\n   else if (this->type_->interface_type() != NULL)\n     return Expression::convert_interface_to_interface(context, this->type_,\n \t\t\t\t\t\t      this->expr_->type(),\n@@ -12495,7 +12523,8 @@ Receive_expression::do_get_tree(Translate_context* context)\n       return error_mark_node;\n     }\n   Type* element_type = channel_type->element_type();\n-  tree element_type_tree = element_type->get_tree(context->gogo());\n+  Btype* element_type_btype = element_type->get_backend(context->gogo());\n+  tree element_type_tree = type_to_tree(element_type_btype);\n \n   tree channel = this->channel_->get_tree(context);\n   if (element_type_tree == error_mark_node || channel == error_mark_node)\n@@ -12613,11 +12642,11 @@ Type_info_expression::do_type()\n tree\n Type_info_expression::do_get_tree(Translate_context* context)\n {\n-  tree type_tree = this->type_->get_tree(context->gogo());\n+  tree type_tree = type_to_tree(this->type_->get_backend(context->gogo()));\n   if (type_tree == error_mark_node)\n     return error_mark_node;\n \n-  tree val_type_tree = this->type()->get_tree(context->gogo());\n+  tree val_type_tree = type_to_tree(this->type()->get_backend(context->gogo()));\n   go_assert(val_type_tree != error_mark_node);\n \n   if (this->type_info_ == TYPE_INFO_SIZE)\n@@ -12682,11 +12711,11 @@ class Struct_field_offset_expression : public Expression\n tree\n Struct_field_offset_expression::do_get_tree(Translate_context* context)\n {\n-  tree type_tree = this->type_->get_tree(context->gogo());\n+  tree type_tree = type_to_tree(this->type_->get_backend(context->gogo()));\n   if (type_tree == error_mark_node)\n     return error_mark_node;\n \n-  tree val_type_tree = this->type()->get_tree(context->gogo());\n+  tree val_type_tree = type_to_tree(this->type()->get_backend(context->gogo()));\n   go_assert(val_type_tree != error_mark_node);\n \n   const Struct_field_list* fields = this->type_->fields();"}, {"sha": "7cd75111e36bb60b7117df75003fb3fc0c35c78b", "filename": "gcc/go/gofrontend/gogo-tree.cc", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b735706d761958d6702b8076ffa02e093546362/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b735706d761958d6702b8076ffa02e093546362/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc?ref=5b735706d761958d6702b8076ffa02e093546362", "patch": "@@ -909,10 +909,13 @@ Named_object::get_tree(Gogo* gogo, Named_object* function)\n \t    Type* type = named_constant->type();\n \t    if (type != NULL && !type->is_abstract())\n \t      {\n-\t\tif (!type->is_error())\n-\t\t  expr_tree = fold_convert(type->get_tree(gogo), expr_tree);\n-\t\telse\n+\t\tif (type->is_error())\n \t\t  expr_tree = error_mark_node;\n+\t\telse\n+\t\t  {\n+\t\t    Btype* btype = type->get_backend(gogo);\n+\t\t    expr_tree = fold_convert(type_to_tree(btype), expr_tree);\n+\t\t  }\n \t      }\n \t    if (expr_tree == error_mark_node)\n \t      decl = error_mark_node;\n@@ -939,7 +942,7 @@ Named_object::get_tree(Gogo* gogo, Named_object* function)\n     case NAMED_OBJECT_TYPE:\n       {\n \tNamed_type* named_type = this->u_.type_value;\n-\ttree type_tree = named_type->get_tree(gogo);\n+\ttree type_tree = type_to_tree(named_type->get_backend(gogo));\n \tif (type_tree == error_mark_node)\n \t  decl = error_mark_node;\n \telse\n@@ -1104,7 +1107,7 @@ Function::get_or_make_decl(Gogo* gogo, Named_object* no, tree id)\n {\n   if (this->fndecl_ == NULL_TREE)\n     {\n-      tree functype = this->type_->get_tree(gogo);\n+      tree functype = type_to_tree(this->type_->get_backend(gogo));\n       if (functype == error_mark_node)\n \tthis->fndecl_ = error_mark_node;\n       else\n@@ -1217,7 +1220,7 @@ Function_declaration::get_or_make_decl(Gogo* gogo, Named_object* no, tree id)\n \t    }\n \t}\n \n-      tree functype = this->fntype_->get_tree(gogo);\n+      tree functype = type_to_tree(this->fntype_->get_backend(gogo));\n       tree decl;\n       if (functype == error_mark_node)\n \tdecl = error_mark_node;\n@@ -1424,7 +1427,7 @@ Function::build_tree(Gogo* gogo, Named_object* named_function)\n \t  else\n \t    {\n \t      source_location loc = (*p)->location();\n-\t      tree type_tree = type->get_tree(gogo);\n+\t      tree type_tree = type_to_tree(type->get_backend(gogo));\n \t      tree space = gogo->allocate_memory(type,\n \t\t\t\t\t\t TYPE_SIZE_UNIT(type_tree),\n \t\t\t\t\t\t loc);\n@@ -1712,7 +1715,7 @@ go_type_for_size(unsigned int bits, int unsignedp)\n \treturn NULL_TREE;\n     }\n   Type* type = Type::lookup_integer_type(name);\n-  return type->get_tree(go_get_gogo());\n+  return type_to_tree(type->get_backend(go_get_gogo()));\n }\n \n // Return the type to use for a mode.\n@@ -1743,7 +1746,7 @@ go_type_for_mode(enum machine_mode mode, int unsignedp)\n \t    return long_double_type_node;\n \t  return NULL_TREE;\n \t}\n-      return type->get_tree(go_get_gogo());\n+      return type_to_tree(type->get_backend(go_get_gogo()));\n     }\n   else if (mc == MODE_COMPLEX_FLOAT)\n     {\n@@ -1763,7 +1766,7 @@ go_type_for_mode(enum machine_mode mode, int unsignedp)\n \t    return complex_long_double_type_node;\n \t  return NULL_TREE;\n \t}\n-      return type->get_tree(go_get_gogo());\n+      return type_to_tree(type->get_backend(go_get_gogo()));\n     }\n   else\n     return NULL_TREE;\n@@ -1887,7 +1890,7 @@ Gogo::string_constant_tree(const std::string& val)\n tree\n Gogo::go_string_constant_tree(const std::string& val)\n {\n-  tree string_type = Type::make_string_type()->get_tree(this);\n+  tree string_type = type_to_tree(Type::make_string_type()->get_backend(this));\n \n   VEC(constructor_elt, gc)* init = VEC_alloc(constructor_elt, gc, 2);\n \n@@ -2016,13 +2019,15 @@ Gogo::map_descriptor(Map_type* maptype)\n \n   tree map_entry_type = make_node(RECORD_TYPE);\n \n+  Btype* bkey_type = keytype->get_backend(this);\n+  Btype* bval_type = valtype->get_backend(this);\n   map_entry_type = Gogo::builtin_struct(NULL, \"__map\", map_entry_type, 3,\n \t\t\t\t\t\"__next\",\n \t\t\t\t\tbuild_pointer_type(map_entry_type),\n \t\t\t\t\t\"__key\",\n-\t\t\t\t\tkeytype->get_tree(this),\n+\t\t\t\t\ttype_to_tree(bkey_type),\n \t\t\t\t\t\"__val\",\n-\t\t\t\t\tvaltype->get_tree(this));\n+\t\t\t\t\ttype_to_tree(bval_type));\n   if (map_entry_type == error_mark_node)\n     {\n       p->second = error_mark_node;\n@@ -2097,7 +2102,8 @@ tree\n Gogo::map_descriptor_type()\n {\n   static tree struct_type;\n-  tree dtype = Type::make_type_descriptor_type()->get_tree(this);\n+  Type* tdt = Type::make_type_descriptor_type();\n+  tree dtype = type_to_tree(tdt->get_backend(this));\n   dtype = build_qualified_type(dtype, TYPE_QUAL_CONST);\n   return Gogo::builtin_struct(&struct_type, \"__go_map_descriptor\", NULL_TREE,\n \t\t\t      4,\n@@ -2238,7 +2244,8 @@ Gogo::build_type_descriptor_decl(const Type* type, Expression* initializer,\n     decl_name = this->type_descriptor_decl_name(name->named_object(),\n \t\t\t\t\t\tname->in_function());\n   tree id = get_identifier_from_string(decl_name);\n-  tree descriptor_type_tree = initializer->type()->get_tree(this);\n+  Type* init_type = initializer->type();\n+  tree descriptor_type_tree = type_to_tree(init_type->get_backend(this));\n   if (descriptor_type_tree == error_mark_node)\n     {\n       *pdecl = error_mark_node;"}, {"sha": "7d1dd70a48cbbc91c9fd706275299776afe471c8", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b735706d761958d6702b8076ffa02e093546362/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b735706d761958d6702b8076ffa02e093546362/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=5b735706d761958d6702b8076ffa02e093546362", "patch": "@@ -3703,7 +3703,7 @@ Variable::get_backend_variable(Gogo* gogo, Named_object* function,\n \t    }\n \n \t  std::string n = Gogo::unpack_hidden_name(name);\n-\t  Btype* btype = tree_to_type(type->get_tree(gogo));\n+\t  Btype* btype = type->get_backend(gogo);\n \n \t  Bvariable* bvar;\n \t  if (this->is_global_)\n@@ -3753,7 +3753,7 @@ Result_variable::get_backend_variable(Gogo* gogo, Named_object* function,\n \t{\n \t  if (this->is_in_heap())\n \t    type = Type::make_pointer_type(type);\n-\t  Btype* btype = tree_to_type(type->get_tree(gogo));\n+\t  Btype* btype = type->get_backend(gogo);\n \t  tree fndecl = function->func_value()->get_decl();\n \t  Bfunction* bfunction = tree_to_function(fndecl);\n \t  std::string n = Gogo::unpack_hidden_name(name);"}, {"sha": "4fdf8f1420166a2f5229355677533441fb081b98", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b735706d761958d6702b8076ffa02e093546362/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b735706d761958d6702b8076ffa02e093546362/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=5b735706d761958d6702b8076ffa02e093546362", "patch": "@@ -375,7 +375,7 @@ Temporary_statement::do_get_backend(Translate_context* context)\n   else\n     bfunction = tree_to_function(function->func_value()->get_decl());\n \n-  Btype* btype = tree_to_type(this->type()->get_tree(context->gogo()));\n+  Btype* btype = this->type()->get_backend(context->gogo());\n \n   Bexpression* binit;\n   if (this->init_ == NULL)"}, {"sha": "fdaf8881a17e60be2e788ba98b8c1a13f7f50d46", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 132, "deletions": 168, "changes": 300, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b735706d761958d6702b8076ffa02e093546362/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b735706d761958d6702b8076ffa02e093546362/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=5b735706d761958d6702b8076ffa02e093546362", "patch": "@@ -37,7 +37,7 @@ extern \"C\"\n // Class Type.\n \n Type::Type(Type_classification classification)\n-  : classification_(classification), tree_(NULL_TREE),\n+  : classification_(classification), btype_(NULL),\n     type_descriptor_decl_(NULL_TREE)\n {\n }\n@@ -833,55 +833,56 @@ Type::check_int_value(Expression* e, const char* errmsg,\n \n // A hash table mapping unnamed types to trees.\n \n-Type::Type_trees Type::type_trees;\n+Type::Type_btypes Type::type_btypes;\n \n // Return a tree representing this type.\n \n-tree\n-Type::get_tree(Gogo* gogo)\n+Btype*\n+Type::get_backend(Gogo* gogo)\n {\n-  if (this->tree_ != NULL)\n-    return this->tree_;\n+  if (this->btype_ != NULL)\n+    return this->btype_;\n \n   if (this->forward_declaration_type() != NULL\n       || this->named_type() != NULL)\n-    return type_to_tree(this->get_btype_without_hash(gogo));\n+    return this->get_btype_without_hash(gogo);\n \n   if (this->is_error_type())\n-    return error_mark_node;\n+    return gogo->backend()->error_type();\n \n   // To avoid confusing the backend, translate all identical Go types\n-  // to the same backend type.  We use a hash table to do that.  There\n-  // is no need to use the hash table for named types, as named types\n-  // are only identical to themselves.\n+  // to the same backend representation.  We use a hash table to do\n+  // that.  There is no need to use the hash table for named types, as\n+  // named types are only identical to themselves.\n \n-  std::pair<Type*, tree> val(this, NULL);\n-  std::pair<Type_trees::iterator, bool> ins =\n-    Type::type_trees.insert(val);\n-  if (!ins.second && ins.first->second != NULL_TREE)\n+  std::pair<Type*, Btype*> val(this, NULL);\n+  std::pair<Type_btypes::iterator, bool> ins =\n+    Type::type_btypes.insert(val);\n+  if (!ins.second && ins.first->second != NULL)\n     {\n       if (gogo != NULL && gogo->named_types_are_converted())\n-\tthis->tree_ = ins.first->second;\n+\tthis->btype_ = ins.first->second;\n       return ins.first->second;\n     }\n \n-  tree t = type_to_tree(this->get_btype_without_hash(gogo));\n+  Btype* bt = this->get_btype_without_hash(gogo);\n \n-  if (ins.first->second == NULL_TREE)\n-    ins.first->second = t;\n+  if (ins.first->second == NULL)\n+    ins.first->second = bt;\n   else\n     {\n-      // We have already created a tree for this type.  This can\n-      // happen when an unnamed type is defined using a named type\n-      // which in turns uses an identical unnamed type.  Use the tree\n-      // we created earlier and ignore the one we just built.\n-      t = ins.first->second;\n+      // We have already created a backend representation for this\n+      // type.  This can happen when an unnamed type is defined using\n+      // a named type which in turns uses an identical unnamed type.\n+      // Use the tree we created earlier and ignore the one we just\n+      // built.\n+      bt = ins.first->second;\n       if (gogo == NULL || !gogo->named_types_are_converted())\n-\treturn t;\n-      this->tree_ = t;\n+\treturn bt;\n+      this->btype_ = bt;\n     }\n \n-  return t;\n+  return bt;\n }\n \n // Return the backend representation for a type without looking in the\n@@ -891,9 +892,9 @@ Type::get_tree(Gogo* gogo)\n Btype*\n Type::get_btype_without_hash(Gogo* gogo)\n {\n-  if (this->tree_ == NULL_TREE)\n+  if (this->btype_ == NULL)\n     {\n-      Btype* bt = tree_to_type(this->do_get_tree(gogo));\n+      Btype* bt = this->do_get_backend(gogo);\n \n       // For a recursive function or pointer type, we will temporarily\n       // return a circular pointer type during the recursion.  We\n@@ -906,19 +907,17 @@ Type::get_btype_without_hash(Gogo* gogo)\n       if (gogo == NULL || !gogo->named_types_are_converted())\n \treturn bt;\n \n-      tree t = type_to_tree(bt);\n-      this->tree_ = t;\n+      this->btype_ = bt;\n     }\n-\n-  return tree_to_type(this->tree_);\n+  return this->btype_;\n }\n \n // Return a tree representing a zero initialization for this type.\n \n tree\n Type::get_init_tree(Gogo* gogo, bool is_clear)\n {\n-  tree type_tree = this->get_tree(gogo);\n+  tree type_tree = type_to_tree(this->get_backend(gogo));\n   if (type_tree == error_mark_node)\n     return error_mark_node;\n   return this->do_get_init_tree(gogo, type_tree, is_clear);\n@@ -1585,9 +1584,9 @@ class Error_type : public Type\n   { }\n \n  protected:\n-  tree\n-  do_get_tree(Gogo* gogo)\n-  { return type_to_tree(gogo->backend()->error_type()); }\n+  Btype*\n+  do_get_backend(Gogo* gogo)\n+  { return gogo->backend()->error_type(); }\n \n   tree\n   do_get_init_tree(Gogo*, tree, bool)\n@@ -1623,12 +1622,9 @@ class Void_type : public Type\n   { }\n \n  protected:\n-  tree\n-  do_get_tree(Gogo* gogo)\n-  {\n-    Btype* btype = gogo->backend()->void_type();\n-    return type_to_tree(btype);\n-  }\n+  Btype*\n+  do_get_backend(Gogo* gogo)\n+  { return gogo->backend()->void_type(); }\n \n   tree\n   do_get_init_tree(Gogo*, tree, bool)\n@@ -1664,12 +1660,9 @@ class Boolean_type : public Type\n   { }\n \n  protected:\n-  tree\n-  do_get_tree(Gogo* gogo)\n-  {\n-    Btype* btype = gogo->backend()->bool_type();\n-    return type_to_tree(btype);\n-  }\n+  Btype*\n+  do_get_backend(Gogo* gogo)\n+  { return gogo->backend()->bool_type(); }\n \n   tree\n   do_get_init_tree(Gogo*, tree type_tree, bool is_clear)\n@@ -1805,18 +1798,15 @@ Integer_type::do_hash_for_method(Gogo*) const\n \n // Convert an Integer_type to the backend representation.\n \n-tree\n-Integer_type::do_get_tree(Gogo* gogo)\n+Btype*\n+Integer_type::do_get_backend(Gogo* gogo)\n {\n   if (this->is_abstract_)\n     {\n       go_assert(saw_errors());\n-      return error_mark_node;\n+      return gogo->backend()->error_type();\n     }\n-\n-  Btype* btype = gogo->backend()->integer_type(this->is_unsigned_,\n-\t\t\t\t\t       this->bits_);\n-  return type_to_tree(btype);\n+  return gogo->backend()->integer_type(this->is_unsigned_, this->bits_);\n }\n \n tree\n@@ -1946,11 +1936,10 @@ Float_type::do_hash_for_method(Gogo*) const\n \n // Convert to the backend representation.\n \n-tree\n-Float_type::do_get_tree(Gogo* gogo)\n+Btype*\n+Float_type::do_get_backend(Gogo* gogo)\n {\n-  Btype* btype = gogo->backend()->float_type(this->bits_);\n-  return type_to_tree(btype);\n+  return gogo->backend()->float_type(this->bits_);\n }\n \n tree\n@@ -2083,10 +2072,10 @@ Complex_type::do_hash_for_method(Gogo*) const\n \n // Convert to the backend representation.\n \n-tree\n-Complex_type::do_get_tree(Gogo* gogo)\n+Btype*\n+Complex_type::do_get_backend(Gogo* gogo)\n {\n-  return type_to_tree(gogo->backend()->complex_type(this->bits_));\n+  return gogo->backend()->complex_type(this->bits_);\n }\n \n // Zero initializer.\n@@ -2161,8 +2150,8 @@ Type::lookup_complex_type(const char* name)\n // Convert String_type to the backend representation.  A string is a\n // struct with two fields: a pointer to the characters and a length.\n \n-tree\n-String_type::do_get_tree(Gogo* gogo)\n+Btype*\n+String_type::do_get_backend(Gogo* gogo)\n {\n   static Btype* backend_string_type;\n   if (backend_string_type == NULL)\n@@ -2172,17 +2161,17 @@ String_type::do_get_tree(Gogo* gogo)\n       Type* b = gogo->lookup_global(\"byte\")->type_value();\n       Type* pb = Type::make_pointer_type(b);\n       fields[0].name = \"__data\";\n-      fields[0].btype = tree_to_type(pb->get_tree(gogo));\n+      fields[0].btype = pb->get_backend(gogo);\n       fields[0].location = UNKNOWN_LOCATION;\n \n       Type* int_type = Type::lookup_integer_type(\"int\");\n       fields[1].name = \"__length\";\n-      fields[1].btype = tree_to_type(int_type->get_tree(gogo));\n+      fields[1].btype = int_type->get_backend(gogo);\n       fields[1].location = UNKNOWN_LOCATION;\n \n       backend_string_type = gogo->backend()->struct_type(fields);\n     }\n-  return type_to_tree(backend_string_type);\n+  return backend_string_type;\n }\n \n // Return a tree for the length of STRING.\n@@ -2316,8 +2305,8 @@ class Sink_type : public Type\n   { }\n \n  protected:\n-  tree\n-  do_get_tree(Gogo*)\n+  Btype*\n+  do_get_backend(Gogo*)\n   { go_unreachable(); }\n \n   tree\n@@ -2601,8 +2590,8 @@ Function_type::do_hash_for_method(Gogo* gogo) const\n \n // Get the tree for a function type.\n \n-tree\n-Function_type::do_get_tree(Gogo* gogo)\n+Btype*\n+Function_type::do_get_backend(Gogo* gogo)\n {\n   Backend::Btyped_identifier breceiver;\n   if (this->receiver_ != NULL)\n@@ -2614,7 +2603,7 @@ Function_type::do_get_tree(Gogo* gogo)\n       Type* rtype = this->receiver_->type();\n       if (rtype->points_to() == NULL)\n \trtype = Type::make_pointer_type(rtype);\n-      breceiver.btype = tree_to_type(rtype->get_tree(gogo));\n+      breceiver.btype = rtype->get_backend(gogo);\n       breceiver.location = this->receiver_->location();\n     }\n \n@@ -2628,7 +2617,7 @@ Function_type::do_get_tree(Gogo* gogo)\n \t   ++p, ++i)\n \t{\n \t  bparameters[i].name = Gogo::unpack_hidden_name(p->name());\n-\t  bparameters[i].btype = tree_to_type(p->type()->get_tree(gogo));\n+\t  bparameters[i].btype = p->type()->get_backend(gogo);\n \t  bparameters[i].location = p->location();\n \t}\n       go_assert(i == bparameters.size());\n@@ -2644,15 +2633,14 @@ Function_type::do_get_tree(Gogo* gogo)\n \t   ++p, ++i)\n \t{\n \t  bresults[i].name = Gogo::unpack_hidden_name(p->name());\n-\t  bresults[i].btype = tree_to_type(p->type()->get_tree(gogo));\n+\t  bresults[i].btype = p->type()->get_backend(gogo);\n \t  bresults[i].location = p->location();\n \t}\n       go_assert(i == bresults.size());\n     }\n \n-  Btype* fntype = gogo->backend()->function_type(breceiver, bparameters,\n-\t\t\t\t\t\t bresults, this->location());\n-  return type_to_tree(fntype);\n+  return gogo->backend()->function_type(breceiver, bparameters, bresults,\n+\t\t\t\t\tthis->location());\n }\n \n // Functions are initialized to NULL.\n@@ -3060,12 +3048,11 @@ Pointer_type::do_hash_for_method(Gogo* gogo) const\n \n // The tree for a pointer type.\n \n-tree\n-Pointer_type::do_get_tree(Gogo* gogo)\n+Btype*\n+Pointer_type::do_get_backend(Gogo* gogo)\n {\n-  Btype* to_btype = tree_to_type(this->to_type_->get_tree(gogo));\n-  Btype* btype = gogo->backend()->pointer_type(to_btype);\n-  return type_to_tree(btype);\n+  Btype* to_btype = this->to_type_->get_backend(gogo);\n+  return gogo->backend()->pointer_type(to_btype);\n }\n \n // Initialize a pointer type.\n@@ -3217,12 +3204,9 @@ class Nil_type : public Type\n   { }\n \n  protected:\n-  tree\n-  do_get_tree(Gogo* gogo)\n-  {\n-    Btype* bt = gogo->backend()->pointer_type(gogo->backend()->void_type());\n-    return type_to_tree(bt);\n-  }\n+  Btype*\n+  do_get_backend(Gogo* gogo)\n+  { return gogo->backend()->pointer_type(gogo->backend()->void_type()); }\n \n   tree\n   do_get_init_tree(Gogo*, tree type_tree, bool is_clear)\n@@ -3271,8 +3255,12 @@ class Call_multiple_result_type : public Type\n     return false;\n   }\n \n-  tree\n-  do_get_tree(Gogo*);\n+  Btype*\n+  do_get_backend(Gogo* gogo)\n+  {\n+    go_assert(saw_errors());\n+    return gogo->backend()->error_type();\n+  }\n \n   tree\n   do_get_init_tree(Gogo*, tree, bool)\n@@ -3301,21 +3289,6 @@ class Call_multiple_result_type : public Type\n   Call_expression* call_;\n };\n \n-// Return the tree for a call result.\n-\n-tree\n-Call_multiple_result_type::do_get_tree(Gogo* gogo)\n-{\n-  Function_type* fntype = this->call_->get_function_type();\n-  go_assert(fntype != NULL);\n-  const Typed_identifier_list* results = fntype->results();\n-  go_assert(results != NULL && results->size() > 1);\n-  tree fntype_tree = fntype->get_tree(gogo);\n-  if (fntype_tree == error_mark_node)\n-    return error_mark_node;\n-  return TREE_TYPE(fntype_tree);\n-}\n-\n // Make a call result type.\n \n Type*\n@@ -3780,21 +3753,20 @@ get_backend_struct_fields(Gogo* gogo, const Struct_field_list* fields,\n        ++p, ++i)\n     {\n       (*bfields)[i].name = Gogo::unpack_hidden_name(p->field_name());\n-      (*bfields)[i].btype = tree_to_type(p->type()->get_tree(gogo));\n+      (*bfields)[i].btype = p->type()->get_backend(gogo);\n       (*bfields)[i].location = p->location();\n     }\n   go_assert(i == fields->size());\n }\n \n // Get the tree for a struct type.\n \n-tree\n-Struct_type::do_get_tree(Gogo* gogo)\n+Btype*\n+Struct_type::do_get_backend(Gogo* gogo)\n {\n   std::vector<Backend::Btyped_identifier> bfields;\n   get_backend_struct_fields(gogo, this->fields_, &bfields);\n-  Btype* btype = gogo->backend()->struct_type(bfields);\n-  return type_to_tree(btype);\n+  return gogo->backend()->struct_type(bfields);\n }\n \n // Initialize struct fields.\n@@ -4382,7 +4354,7 @@ Array_type::get_length_tree(Gogo* gogo)\n \t    t = Type::lookup_integer_type(\"int\");\n \t  else if (t->is_abstract())\n \t    t = t->make_non_abstract_type();\n-\t  tree tt = t->get_tree(gogo);\n+\t  tree tt = type_to_tree(t->get_backend(gogo));\n \t  this->length_tree_ = Expression::integer_constant_tree(val, tt);\n \t  mpz_clear(val);\n \t}\n@@ -4420,7 +4392,7 @@ get_backend_slice_fields(Gogo* gogo, Array_type* type,\n   bfields->resize(3);\n \n   Type* pet = Type::make_pointer_type(type->element_type());\n-  Btype* pbet = tree_to_type(pet->get_tree(gogo));\n+  Btype* pbet = pet->get_backend(gogo);\n \n   Backend::Btyped_identifier* p = &(*bfields)[0];\n   p->name = \"__values\";\n@@ -4431,12 +4403,12 @@ get_backend_slice_fields(Gogo* gogo, Array_type* type,\n \n   p = &(*bfields)[1];\n   p->name = \"__count\";\n-  p->btype = tree_to_type(int_type->get_tree(gogo));\n+  p->btype = int_type->get_backend(gogo);\n   p->location = UNKNOWN_LOCATION;\n \n   p = &(*bfields)[2];\n   p->name = \"__capacity\";\n-  p->btype = tree_to_type(int_type->get_tree(gogo));\n+  p->btype = int_type->get_backend(gogo);\n   p->location = UNKNOWN_LOCATION;\n }\n \n@@ -4445,29 +4417,28 @@ get_backend_slice_fields(Gogo* gogo, Array_type* type,\n // just like an array in C.  An open array is a struct with three\n // fields: a data pointer, the length, and the capacity.\n \n-tree\n-Array_type::do_get_tree(Gogo* gogo)\n+Btype*\n+Array_type::do_get_backend(Gogo* gogo)\n {\n   if (this->length_ == NULL)\n     {\n       std::vector<Backend::Btyped_identifier> bfields;\n       get_backend_slice_fields(gogo, this, &bfields);\n-      return type_to_tree(gogo->backend()->struct_type(bfields));\n+      return gogo->backend()->struct_type(bfields);\n     }\n   else\n     {\n       Btype* element = this->get_backend_element(gogo);\n       Bexpression* len = this->get_backend_length(gogo);\n-      Btype* ret = gogo->backend()->array_type(element, len);\n-      return type_to_tree(ret);\n+      return gogo->backend()->array_type(element, len);\n     }\n }\n \n // Return the backend representation of the element type.\n Btype*\n Array_type::get_backend_element(Gogo* gogo)\n {\n-  return tree_to_type(this->element_type_->get_tree(gogo));\n+  return this->element_type_->get_backend(gogo);\n }\n \n // Return the backend representation of the length.\n@@ -4543,7 +4514,7 @@ Array_type::do_make_expression_tree(Translate_context* context,\n   go_assert(this->length_ == NULL);\n \n   Gogo* gogo = context->gogo();\n-  tree type_tree = this->get_tree(gogo);\n+  tree type_tree = type_to_tree(this->get_backend(gogo));\n   if (type_tree == error_mark_node)\n     return error_mark_node;\n \n@@ -4555,7 +4526,7 @@ Array_type::do_make_expression_tree(Translate_context* context,\n   go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(count_field)),\n \t\t    \"__count\") == 0);\n \n-  tree element_type_tree = this->element_type_->get_tree(gogo);\n+  tree element_type_tree = type_to_tree(this->element_type_->get_backend(gogo));\n   if (element_type_tree == error_mark_node)\n     return error_mark_node;\n   tree element_size_tree = TYPE_SIZE_UNIT(element_type_tree);\n@@ -5061,8 +5032,8 @@ Map_type::do_check_make_expression(Expression_list* args,\n // represented as a pointer to a struct.  The struct is __go_map in\n // libgo/map.h.\n \n-tree\n-Map_type::do_get_tree(Gogo* gogo)\n+Btype*\n+Map_type::do_get_backend(Gogo* gogo)\n {\n   static Btype* backend_map_type;\n   if (backend_map_type == NULL)\n@@ -5071,12 +5042,12 @@ Map_type::do_get_tree(Gogo* gogo)\n \n       Type* pdt = Type::make_type_descriptor_ptr_type();\n       bfields[0].name = \"__descriptor\";\n-      bfields[0].btype = tree_to_type(pdt->get_tree(gogo));\n+      bfields[0].btype = pdt->get_backend(gogo);\n       bfields[0].location = BUILTINS_LOCATION;\n \n       Type* uintptr_type = Type::lookup_integer_type(\"uintptr\");\n       bfields[1].name = \"__element_count\";\n-      bfields[1].btype = tree_to_type(uintptr_type->get_tree(gogo));\n+      bfields[1].btype = uintptr_type->get_backend(gogo);\n       bfields[1].location = BUILTINS_LOCATION;\n \n       bfields[2].name = \"__bucket_count\";\n@@ -5094,7 +5065,7 @@ Map_type::do_get_tree(Gogo* gogo)\n       bt = gogo->backend()->named_type(\"__go_map\", bt, BUILTINS_LOCATION);\n       backend_map_type = gogo->backend()->pointer_type(bt);\n     }\n-  return type_to_tree(backend_map_type);\n+  return backend_map_type;\n }\n \n // Initialize a map.\n@@ -5132,7 +5103,7 @@ Map_type::do_make_expression_tree(Translate_context* context,\n \t\t\t\t\t   location);\n     }\n \n-  tree map_type = this->get_tree(context->gogo());\n+  tree map_type = type_to_tree(this->get_backend(context->gogo()));\n \n   static tree new_map_fndecl;\n   tree ret = Gogo::call_builtin(&new_map_fndecl,\n@@ -5329,8 +5300,8 @@ Channel_type::do_check_make_expression(Expression_list* args,\n // __go_channel struct.  The __go_channel struct is defined in\n // libgo/runtime/channel.h.\n \n-tree\n-Channel_type::do_get_tree(Gogo* gogo)\n+Btype*\n+Channel_type::do_get_backend(Gogo* gogo)\n {\n   static Btype* backend_channel_type;\n   if (backend_channel_type == NULL)\n@@ -5340,7 +5311,7 @@ Channel_type::do_get_tree(Gogo* gogo)\n       bt = gogo->backend()->named_type(\"__go_channel\", bt, BUILTINS_LOCATION);\n       backend_channel_type = gogo->backend()->pointer_type(bt);\n     }\n-  return type_to_tree(backend_channel_type);\n+  return backend_channel_type;\n }\n \n // Initialize a channel variable.\n@@ -5361,9 +5332,9 @@ Channel_type::do_make_expression_tree(Translate_context* context,\n \t\t\t\t      source_location location)\n {\n   Gogo* gogo = context->gogo();\n-  tree channel_type = this->get_tree(gogo);\n+  tree channel_type = type_to_tree(this->get_backend(gogo));\n \n-  tree element_tree = this->element_type_->get_tree(gogo);\n+  tree element_tree = type_to_tree(this->element_type_->get_backend(gogo));\n   tree element_size_tree = size_in_bytes(element_tree);\n \n   tree bad_index = NULL_TREE;\n@@ -6003,12 +5974,12 @@ Interface_type::get_backend_empty_interface_type(Gogo* gogo)\n \n       Type* pdt = Type::make_type_descriptor_ptr_type();\n       bfields[0].name = \"__type_descriptor\";\n-      bfields[0].btype = tree_to_type(pdt->get_tree(gogo));\n+      bfields[0].btype = pdt->get_backend(gogo);\n       bfields[0].location = UNKNOWN_LOCATION;\n \n       Type* vt = Type::make_pointer_type(Type::make_void_type());\n       bfields[1].name = \"__object\";\n-      bfields[1].btype = tree_to_type(vt->get_tree(gogo));\n+      bfields[1].btype = vt->get_backend(gogo);\n       bfields[1].location = UNKNOWN_LOCATION;\n \n       empty_interface_type = gogo->backend()->struct_type(bfields);\n@@ -6030,7 +6001,7 @@ get_backend_interface_fields(Gogo* gogo, Interface_type* type,\n \n   Type* pdt = Type::make_type_descriptor_ptr_type();\n   mfields[0].name = \"__type_descriptor\";\n-  mfields[0].btype = tree_to_type(pdt->get_tree(gogo));\n+  mfields[0].btype = pdt->get_backend(gogo);\n   mfields[0].location = loc;\n \n   std::string last_name = \"\";\n@@ -6040,7 +6011,7 @@ get_backend_interface_fields(Gogo* gogo, Interface_type* type,\n        ++p, ++i)\n     {\n       mfields[i].name = Gogo::unpack_hidden_name(p->name());\n-      mfields[i].btype = tree_to_type(p->type()->get_tree(gogo));\n+      mfields[i].btype = p->type()->get_backend(gogo);\n       mfields[i].location = loc;\n       // Sanity check: the names should be sorted.\n       go_assert(p->name() > last_name);\n@@ -6057,7 +6028,7 @@ get_backend_interface_fields(Gogo* gogo, Interface_type* type,\n \n   Type* vt = Type::make_pointer_type(Type::make_void_type());\n   (*bfields)[1].name = \"__object\";\n-  (*bfields)[1].btype = tree_to_type(vt->get_tree(gogo));\n+  (*bfields)[1].btype = vt->get_backend(gogo);\n   (*bfields)[1].location = UNKNOWN_LOCATION;\n }\n \n@@ -6068,20 +6039,16 @@ get_backend_interface_fields(Gogo* gogo, Interface_type* type,\n // interface to be used with the object.  The third field is the value\n // of the object itself.\n \n-tree\n-Interface_type::do_get_tree(Gogo* gogo)\n+Btype*\n+Interface_type::do_get_backend(Gogo* gogo)\n {\n   if (this->methods_ == NULL)\n-    {\n-      Btype* bt = Interface_type::get_backend_empty_interface_type(gogo);\n-      return type_to_tree(bt);\n-    }\n+    return Interface_type::get_backend_empty_interface_type(gogo);\n   else\n     {\n       std::vector<Backend::Btyped_identifier> bfields;\n       get_backend_interface_fields(gogo, this, &bfields);\n-      Btype* bt = gogo->backend()->struct_type(bfields);\n-      return type_to_tree(bt);\n+      return gogo->backend()->struct_type(bfields);\n     }\n }\n \n@@ -7200,11 +7167,11 @@ Named_type::create_placeholder(Gogo* gogo)\n \n // Get a tree for a named type.\n \n-tree\n-Named_type::do_get_tree(Gogo* gogo)\n+Btype*\n+Named_type::do_get_backend(Gogo* gogo)\n {\n   if (this->is_error_)\n-    return error_mark_node;\n+    return gogo->backend()->error_type();\n \n   Btype* bt = this->named_btype_;\n \n@@ -7213,23 +7180,23 @@ Named_type::do_get_tree(Gogo* gogo)\n       // We have not completed converting named types.  NAMED_BTYPE_\n       // is a placeholder and we shouldn't do anything further.\n       if (bt != NULL)\n-\treturn type_to_tree(bt);\n+\treturn bt;\n \n       // We don't build dependencies for types whose sizes do not\n       // change or are not relevant, so we may see them here while\n       // converting types.\n       this->create_placeholder(gogo);\n       bt = this->named_btype_;\n       go_assert(bt != NULL);\n-      return type_to_tree(bt);\n+      return bt;\n     }\n \n   // We are not converting types.  This should only be called if the\n   // type has already been converted.\n   if (!this->is_converted_)\n     {\n       go_assert(saw_errors());\n-      return error_mark_node;\n+      return gogo->backend()->error_type();\n     }\n \n   go_assert(bt != NULL);\n@@ -7240,7 +7207,7 @@ Named_type::do_get_tree(Gogo* gogo)\n   switch (base->classification())\n     {\n     case TYPE_ERROR:\n-      return error_mark_node;\n+      return gogo->backend()->error_type();\n \n     case TYPE_VOID:\n     case TYPE_BOOLEAN:\n@@ -7254,16 +7221,15 @@ Named_type::do_get_tree(Gogo* gogo)\n     case TYPE_STRUCT:\n     case TYPE_ARRAY:\n     case TYPE_INTERFACE:\n-      return type_to_tree(bt);\n+      return bt;\n \n     case TYPE_FUNCTION:\n       // Don't build a circular data structure.  GENERIC can't handle\n       // it.\n       if (this->seen_ > 0)\n \t{\n \t  this->is_circular_ = true;\n-\t  bt1 = gogo->backend()->circular_pointer_type(bt, true);\n-\t  return type_to_tree(bt1);\n+\t  return gogo->backend()->circular_pointer_type(bt, true);\n \t}\n       ++this->seen_;\n       bt1 = Type::get_named_base_btype(gogo, base);\n@@ -7272,16 +7238,15 @@ Named_type::do_get_tree(Gogo* gogo)\n \tbt1 = gogo->backend()->circular_pointer_type(bt, true);\n       if (!gogo->backend()->set_placeholder_pointer_type(bt, bt1))\n \tbt = gogo->backend()->error_type();\n-      return type_to_tree(bt);\n+      return bt;\n \n     case TYPE_POINTER:\n       // Don't build a circular data structure. GENERIC can't handle\n       // it.\n       if (this->seen_ > 0)\n \t{\n \t  this->is_circular_ = true;\n-\t  bt1 = gogo->backend()->circular_pointer_type(bt, false);\n-\t  return type_to_tree(bt1);\n+\t  return gogo->backend()->circular_pointer_type(bt, false);\n \t}\n       ++this->seen_;\n       bt1 = Type::get_named_base_btype(gogo, base);\n@@ -7290,7 +7255,7 @@ Named_type::do_get_tree(Gogo* gogo)\n \tbt1 = gogo->backend()->circular_pointer_type(bt, false);\n       if (!gogo->backend()->set_placeholder_pointer_type(bt, bt1))\n \tbt = gogo->backend()->error_type();\n-      return type_to_tree(bt);\n+      return bt;\n \n     default:\n     case TYPE_SINK:\n@@ -8409,23 +8374,22 @@ Forward_declaration_type::do_traverse(Traverse* traverse)\n \n // Get the backend representation for the type.\n \n-tree\n-Forward_declaration_type::do_get_tree(Gogo* gogo)\n+Btype*\n+Forward_declaration_type::do_get_backend(Gogo* gogo)\n {\n   if (this->is_defined())\n-    return type_to_tree(Type::get_named_base_btype(gogo, this->real_type()));\n+    return Type::get_named_base_btype(gogo, this->real_type());\n \n   if (this->warned_)\n-    return error_mark_node;\n+    return gogo->backend()->error_type();\n \n   // We represent an undefined type as a struct with no fields.  That\n   // should work fine for the backend, since the same case can arise\n   // in C.\n   std::vector<Backend::Btyped_identifier> fields;\n   Btype* bt = gogo->backend()->struct_type(fields);\n-  bt = gogo->backend()->named_type(this->name(), bt,\n-\t\t\t\t   this->named_object()->location());\n-  return type_to_tree(bt);\n+  return gogo->backend()->named_type(this->name(), bt,\n+\t\t\t\t     this->named_object()->location());\n }\n \n // Build a type descriptor for a forwarded type."}, {"sha": "74dad7b09bd67408bd83b9206e8f6ed0c4fd1170", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b735706d761958d6702b8076ffa02e093546362/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b735706d761958d6702b8076ffa02e093546362/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=5b735706d761958d6702b8076ffa02e093546362", "patch": "@@ -821,9 +821,9 @@ class Type\n   static void\n   convert_builtin_named_types(Gogo*);\n \n-  // Return a tree representing this type.\n-  tree\n-  get_tree(Gogo*);\n+  // Return the backend representation of this type.\n+  Btype*\n+  get_backend(Gogo*);\n \n   // Return a tree representing a zero initialization for this type.\n   // This will be something like an INTEGER_CST or a CONSTRUCTOR.  If\n@@ -892,9 +892,8 @@ class Type\n   virtual bool\n   do_check_make_expression(Expression_list* args, source_location);\n \n-\n-  virtual tree\n-  do_get_tree(Gogo*) = 0;\n+  virtual Btype*\n+  do_get_backend(Gogo*) = 0;\n \n   virtual tree\n   do_get_init_tree(Gogo*, tree, bool) = 0;\n@@ -1103,20 +1102,21 @@ class Type\n   Btype*\n   get_btype_without_hash(Gogo*);\n \n-  // A mapping from Type to tree, used to ensure that the GIMPLE\n+  // A mapping from Type to Btype*, used to ensure that the backend\n   // representation of identical types is identical.\n-  typedef Unordered_map_hash(const Type*, tree, Type_hash_identical,\n-\t\t\t     Type_identical) Type_trees;\n+  typedef Unordered_map_hash(const Type*, Btype*, Type_hash_identical,\n+\t\t\t     Type_identical) Type_btypes;\n \n-  static Type_trees type_trees;\n+  static Type_btypes type_btypes;\n \n   // A list of builtin named types.\n   static std::vector<Named_type*> named_builtin_types;\n \n   // The type classification.\n   Type_classification classification_;\n-  // The tree representation of the type, once it has been determined.\n-  tree tree_;\n+  // The backend representation of the type, once it has been\n+  // determined.\n+  Btype* btype_;\n   // The decl for the type descriptor for this type.  This starts out\n   // as NULL and is filled in as needed.\n   tree type_descriptor_decl_;\n@@ -1331,8 +1331,8 @@ class Integer_type : public Type\n   unsigned int\n   do_hash_for_method(Gogo*) const;\n \n-  tree\n-  do_get_tree(Gogo*);\n+  Btype*\n+  do_get_backend(Gogo*);\n \n   tree\n   do_get_init_tree(Gogo*, tree, bool);\n@@ -1403,8 +1403,8 @@ class Float_type : public Type\n   unsigned int\n   do_hash_for_method(Gogo*) const;\n \n-  tree\n-  do_get_tree(Gogo*);\n+  Btype*\n+  do_get_backend(Gogo*);\n \n   tree\n   do_get_init_tree(Gogo*, tree, bool);\n@@ -1471,8 +1471,8 @@ class Complex_type : public Type\n   unsigned int\n   do_hash_for_method(Gogo*) const;\n \n-  tree\n-  do_get_tree(Gogo*);\n+  Btype*\n+  do_get_backend(Gogo*);\n \n   tree\n   do_get_init_tree(Gogo*, tree, bool);\n@@ -1527,8 +1527,8 @@ class String_type : public Type\n   do_has_pointer() const\n   { return true; }\n \n-  tree\n-  do_get_tree(Gogo*);\n+  Btype*\n+  do_get_backend(Gogo*);\n \n   tree\n   do_get_init_tree(Gogo* gogo, tree, bool);\n@@ -1643,8 +1643,8 @@ class Function_type : public Type\n   unsigned int\n   do_hash_for_method(Gogo*) const;\n \n-  tree\n-  do_get_tree(Gogo*);\n+  Btype*\n+  do_get_backend(Gogo*);\n \n   tree\n   do_get_init_tree(Gogo*, tree, bool);\n@@ -1717,8 +1717,8 @@ class Pointer_type : public Type\n   unsigned int\n   do_hash_for_method(Gogo*) const;\n \n-  tree\n-  do_get_tree(Gogo*);\n+  Btype*\n+  do_get_backend(Gogo*);\n \n   tree\n   do_get_init_tree(Gogo*, tree, bool);\n@@ -1971,8 +1971,8 @@ class Struct_type : public Type\n   unsigned int\n   do_hash_for_method(Gogo*) const;\n \n-  tree\n-  do_get_tree(Gogo*);\n+  Btype*\n+  do_get_backend(Gogo*);\n \n   tree\n   do_get_init_tree(Gogo*, tree, bool);\n@@ -2088,8 +2088,8 @@ class Array_type : public Type\n   bool\n   do_check_make_expression(Expression_list*, source_location);\n \n-  tree\n-  do_get_tree(Gogo*);\n+  Btype*\n+  do_get_backend(Gogo*);\n \n   tree\n   do_get_init_tree(Gogo*, tree, bool);\n@@ -2179,8 +2179,8 @@ class Map_type : public Type\n   bool\n   do_check_make_expression(Expression_list*, source_location);\n \n-  tree\n-  do_get_tree(Gogo*);\n+  Btype*\n+  do_get_backend(Gogo*);\n \n   tree\n   do_get_init_tree(Gogo*, tree, bool);\n@@ -2263,8 +2263,8 @@ class Channel_type : public Type\n   bool\n   do_check_make_expression(Expression_list*, source_location);\n \n-  tree\n-  do_get_tree(Gogo*);\n+  Btype*\n+  do_get_backend(Gogo*);\n \n   tree\n   do_get_init_tree(Gogo*, tree, bool);\n@@ -2381,8 +2381,8 @@ class Interface_type : public Type\n   unsigned int\n   do_hash_for_method(Gogo*) const;\n \n-  tree\n-  do_get_tree(Gogo*);\n+  Btype*\n+  do_get_backend(Gogo*);\n \n   tree\n   do_get_init_tree(Gogo* gogo, tree, bool);\n@@ -2612,8 +2612,8 @@ class Named_type : public Type\n   do_check_make_expression(Expression_list* args, source_location location)\n   { return this->type_->check_make_expression(args, location); }\n \n-  tree\n-  do_get_tree(Gogo*);\n+  Btype*\n+  do_get_backend(Gogo*);\n \n   tree\n   do_get_init_tree(Gogo* gogo, tree type_tree, bool is_clear)\n@@ -2756,8 +2756,8 @@ class Forward_declaration_type : public Type\n   do_check_make_expression(Expression_list* args, source_location location)\n   { return this->base()->check_make_expression(args, location); }\n \n-  tree\n-  do_get_tree(Gogo* gogo);\n+  Btype*\n+  do_get_backend(Gogo* gogo);\n \n   tree\n   do_get_init_tree(Gogo* gogo, tree type_tree, bool is_clear)"}]}