{"sha": "60103a34825ddfa2e18d3d01f67d6d162c5dfaf4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjAxMDNhMzQ4MjVkZGZhMmUxOGQzZDAxZjY3ZDZkMTYyYzVkZmFmNA==", "commit": {"author": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1994-06-15T08:04:07Z"}, "committer": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1994-06-15T08:04:07Z"}, "message": "gcc.c: Include multilib.h.\n\n\t* gcc.c: Include multilib.h.\n\t(print_multi_lib, print_multi_directory, multilib_select,\n\tmultilib_dir): New static variables.\n\t(option_map): Added --print-multi-lib and --print-multi-directory.\n\t(set_spec): Get multilib_select from specs file.\n\t(process_command): Dump multilib_select into specs file.  Handle\n\t-print-multi-lib and -print-multi-directory.\n\t(do_spec_1): Try multilib_dir for %D case.\n\t(find_file): Try multilib_dir.\n\t(main): Call set_multilib_dir.  Handle print_multi_lib and\n\tprint_multi_directory.\n\t(used_arg, set_multilib_dir, print_multilib_info): New functions.\n\nFrom-SVN: r7491", "tree": {"sha": "2a87058d4d6392bdd250c97bac38d420eea7cd50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2a87058d4d6392bdd250c97bac38d420eea7cd50"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/60103a34825ddfa2e18d3d01f67d6d162c5dfaf4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60103a34825ddfa2e18d3d01f67d6d162c5dfaf4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60103a34825ddfa2e18d3d01f67d6d162c5dfaf4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60103a34825ddfa2e18d3d01f67d6d162c5dfaf4/comments", "author": null, "committer": null, "parents": [{"sha": "f6cdc7ea0f386764375769723f9693d8f9db9355", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6cdc7ea0f386764375769723f9693d8f9db9355", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6cdc7ea0f386764375769723f9693d8f9db9355"}], "stats": {"total": 306, "additions": 306, "deletions": 0}, "files": [{"sha": "00ffa389ddb3381312b3136709eba67e557da68d", "filename": "gcc/gcc.c", "status": "modified", "additions": 306, "deletions": 0, "changes": 306, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60103a34825ddfa2e18d3d01f67d6d162c5dfaf4/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60103a34825ddfa2e18d3d01f67d6d162c5dfaf4/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=60103a34825ddfa2e18d3d01f67d6d162c5dfaf4", "patch": "@@ -45,6 +45,9 @@ compilation is specified by a string called a \"spec\".  */\n #endif\n #include <stdio.h>\n \n+/* Include multi-lib information.  */\n+#include \"multilib.h\"\n+\n #ifndef R_OK\n #define R_OK 4\n #define W_OK 2\n@@ -151,6 +154,16 @@ static char *print_file_name = NULL;\n \n static char *print_prog_name = NULL;\n \n+/* Flag saying to print the relative path we'd use to\n+   find libgcc.a given the current compiler flags.  */\n+\n+static int print_multi_directory;\n+\n+/* Flag saying to print the list of subdirectories and\n+   compiler flags used to select them in a standard form.  */\n+\n+static int print_multi_lib;\n+\n /* Flag indicating whether we should print the command and arguments */\n \n static int verbose_flag;\n@@ -224,6 +237,9 @@ static int is_directory\t\tPROTO((char *, char *, int));\n static void validate_switches\tPROTO((char *));\n static void validate_all_switches PROTO((void));\n static void give_switch\t\tPROTO((int, int));\n+static int used_arg\t\tPROTO((char *, int));\n+static void set_multilib_dir\tPROTO((void));\n+static void print_multilib_info\tPROTO((void));\n static void pfatal_with_name\tPROTO((char *));\n static void perror_with_name\tPROTO((char *));\n static void perror_exec\t\tPROTO((char *));\n@@ -304,6 +320,7 @@ or with constant text in a single argument.\n \tused here.  This can be used to run a post-processor after the\n \tassembler has done it's job.\n  %D\tDump out a -L option for each directory in startfile_prefix.\n+\tIf multilib_dir is set, extra entries are generated with it affixed.\n  %l     process LINK_SPEC as a spec.\n  %L     process LIB_SPEC as a spec.\n  %S     process STARTFILE_SPEC as a spec.  A capital S is actually used here.\n@@ -433,6 +450,13 @@ proper position among the other output files.  */\n #endif\n #endif\n \n+/* MULTILIB_SELECT comes from multilib.h.  It gives a\n+   string interpreted by set_multilib_dir to select a library\n+   subdirectory based on the compiler options.  */\n+#ifndef MULTILIB_SELECT\n+#define MULTILIB_SELECT \". ;\"\n+#endif\n+\n static char *cpp_spec = CPP_SPEC;\n static char *cpp_predefines = CPP_PREDEFINES;\n static char *cc1_spec = CC1_SPEC;\n@@ -445,6 +469,7 @@ static char *lib_spec = LIB_SPEC;\n static char *endfile_spec = ENDFILE_SPEC;\n static char *startfile_spec = STARTFILE_SPEC;\n static char *switches_need_spaces = SWITCHES_NEED_SPACES;\n+static char *multilib_select = MULTILIB_SELECT;\n \n /* This defines which switch letters take arguments.  */\n \n@@ -789,6 +814,8 @@ struct option_map option_map[] =\n    {\"--print-libgcc-file-name\", \"-print-libgcc-file-name\", 0},\n    {\"--print-file-name\", \"-print-file-name=\", \"aj\"},\n    {\"--print-prog-name\", \"-print-prog-name=\", \"aj\"},\n+   {\"--print-multi-lib\", \"-print-multi-lib\", 0},\n+   {\"--print-multi-directory\", \"-print-multi-directory\", 0},\n    {\"--static\", \"-static\", 0},\n    {\"--shared\", \"-shared\", 0},\n    {\"--symbolic\", \"-symbolic\", 0},\n@@ -1144,6 +1171,8 @@ set_spec (name, spec)\n     switches_need_spaces = sl->spec;\n   else if (! strcmp (name, \"cross_compile\"))\n     cross_compile = atoi (sl->spec);\n+  else if (! strcmp (name, \"multilib\"))\n+    multilib_select = sl->spec;\n   /* Free the old spec */\n   if (old_spec)\n     free (old_spec);\n@@ -1269,6 +1298,11 @@ static char *standard_startfile_prefix_2 = \"/usr/lib/\";\n static char *tooldir_base_prefix = TOOLDIR_BASE_PREFIX;\n static char *tooldir_prefix;\n \n+/* Subdirectory to use for locating libraries.  Set by\n+   set_multilib_dir based on the compilation options.  */\n+\n+static char *multilib_dir;\n+\n /* Clear out the vector of arguments (after a command is executed).  */\n \n static void\n@@ -2340,6 +2374,7 @@ process_command (argc, argv)\n \t  printf (\"*signed_char:\\n%s\\n\\n\", signed_char_spec);\n \t  printf (\"*predefines:\\n%s\\n\\n\", cpp_predefines);\n \t  printf (\"*cross_compile:\\n%d\\n\\n\", cross_compile);\n+\t  printf (\"*multilib:\\n%s\\n\\n\", multilib_select);\n \n \t  exit (0);\n \t}\n@@ -2354,6 +2389,10 @@ process_command (argc, argv)\n \t  print_file_name = argv[i] + 17;\n       else if (! strncmp (argv[i], \"-print-prog-name=\", 17))\n \t  print_prog_name = argv[i] + 17;\n+      else if (! strcmp (argv[i], \"-print-multi-lib\"))\n+\tprint_multi_lib = 1;\n+      else if (! strcmp (argv[i], \"-print-multi-directory\"))\n+\tprint_multi_directory = 1;\n       else if (! strcmp (argv[i], \"-Xlinker\"))\n \t{\n \t  /* Pass the argument of this option to the linker when we link.  */\n@@ -2597,6 +2636,10 @@ process_command (argc, argv)\n \t;\n       else if (! strncmp (argv[i], \"-print-prog-name=\", 17))\n \t;\n+      else if (! strcmp (argv[i], \"-print-multi-lib\"))\n+\t;\n+      else if (! strcmp (argv[i], \"-print-multi-directory\"))\n+\t;\n       else if (argv[i][0] == '+' && argv[i][1] == 'e')\n \t{\n \t  /* Compensate for the +e options to the C++ front-end;\n@@ -2941,6 +2984,45 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t\t  if (pl->prefix[0] != '/')\n \t\t    continue;\n #endif\n+\t\t  /* Try subdirectory if there is one.  */\n+\t\t  if (multilib_dir != NULL)\n+\t\t    {\n+\t\t      if (machine_suffix)\n+\t\t\t{\n+\t\t\t  if (strlen (pl->prefix) + strlen (machine_suffix)\n+\t\t\t      >= bufsize)\n+\t\t\t    bufsize = (strlen (pl->prefix)\n+\t\t\t\t       + strlen (machine_suffix)) * 2 + 1;\n+\t\t\t  buffer = (char *) xrealloc (buffer, bufsize);\n+\t\t\t  strcpy (buffer, pl->prefix);\n+\t\t\t  strcat (buffer, machine_suffix);\n+\t\t\t  if (is_directory (buffer, multilib_dir, 1))\n+\t\t\t    {\n+\t\t\t      do_spec_1 (\"-L\", 0, NULL_PTR);\n+#ifdef SPACE_AFTER_L_OPTION\n+\t\t\t      do_spec_1 (\" \", 0, NULL_PTR);\n+#endif\n+\t\t\t      do_spec_1 (buffer, 1, NULL_PTR);\n+\t\t\t      do_spec_1 (multilib_dir, 1, NULL_PTR);\n+\t\t\t      /* Make this a separate argument.  */\n+\t\t\t      do_spec_1 (\" \", 0, NULL_PTR);\n+\t\t\t    }\n+\t\t\t}\n+\t\t      if (!pl->require_machine_suffix)\n+\t\t\t{\n+\t\t\t  if (is_directory (pl->prefix, multilib_dir, 1))\n+\t\t\t    {\n+\t\t\t      do_spec_1 (\"-L\", 0, NULL_PTR);\n+#ifdef SPACE_AFTER_L_OPTION\n+\t\t\t      do_spec_1 (\" \", 0, NULL_PTR);\n+#endif\n+\t\t\t      do_spec_1 (pl->prefix, 1, NULL_PTR);\n+\t\t\t      do_spec_1 (multilib_dir, 1, NULL_PTR);\n+\t\t\t      /* Make this a separate argument.  */\n+\t\t\t      do_spec_1 (\" \", 0, NULL_PTR);\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n \t\t  if (machine_suffix)\n \t\t    {\n \t\t      if (is_directory (pl->prefix, machine_suffix, 1))\n@@ -3836,6 +3918,24 @@ find_file (name)\n {\n   char *newname;\n \n+  /* Try multilib_dir if it is defined.  */\n+  if (multilib_dir != NULL)\n+    {\n+      char *try;\n+\n+      try = (char *) alloca (strlen (multilib_dir) + strlen (name) + 2);\n+      strcpy (try, multilib_dir);\n+      strcat (try, \"/\");\n+      strcat (try, name);\n+\n+      newname = find_a_file (&startfile_prefix, try, R_OK);\n+\n+      /* If we don't find it in the multi library dir, then fall\n+\t through and look for it in the normal places.  */\n+      if (newname != NULL)\n+\treturn newname;\n+    }\n+\n   newname = find_a_file (&startfile_prefix, name, R_OK);\n   return newname ? newname : name;\n }\n@@ -4022,6 +4122,10 @@ main (argc, argv)\n \n   validate_all_switches ();\n \n+  /* Now that we have the switches and the specs, set\n+     the subdirectory based on the options.  */\n+  set_multilib_dir ();\n+\n   /* Warn about any switches that no pass was interested in.  */\n \n   for (i = 0; i < n_switches; i++)\n@@ -4043,6 +4147,21 @@ main (argc, argv)\n       exit (0);\n     }\n \n+  if (print_multi_lib)\n+    {\n+      print_multilib_info ();\n+      exit (0);\n+    }\n+\n+  if (print_multi_directory)\n+    {\n+      if (multilib_dir == NULL)\n+\tprintf (\".\\n\");\n+      else\n+\tprintf (\"%s\\n\", multilib_dir);\n+      exit (0);\n+    }\n+\n   if (verbose_flag)\n     {\n       fprintf (stderr, \"gcc version %s\\n\", version_string);\n@@ -4585,3 +4704,190 @@ validate_switches (start)\n \t}\n     }\n }\n+\f\n+/* Check whether a particular argument was used.  */\n+\n+static int\n+used_arg (p, len)\n+     char *p;\n+     int len;\n+{\n+  int i;\n+\n+  for (i = 0; i < n_switches; i++)\n+    if (! strncmp (switches[i].part1, p, len)\n+\t&& strlen (switches[i].part1) == len)\n+      return 1;\n+  return 0;\n+}\n+\n+/* Work out the subdirectory to use based on the\n+   options.  The format of multilib_select is a list of elements.\n+   Each element is a subdirectory name followed by a list of options\n+   followed by a semicolon.  gcc will consider each line in turn.  If\n+   none of the options beginning with an exclamation point are\n+   present, and all of the other options are present, that\n+   subdirectory will be used.  */\n+\n+static void\n+set_multilib_dir ()\n+{\n+  char *p = multilib_select;\n+  int this_path_len;\n+  char *this_path, *this_arg;\n+  int failed;\n+\n+  while (*p != '\\0')\n+    {\n+      /* Ignore newlines.  */\n+      if (*p == '\\n')\n+\t{\n+\t  ++p;\n+\t  continue;\n+\t}\n+\n+      /* Get the initial path.  */\n+      this_path = p;\n+      while (*p != ' ')\n+\t{\n+\t  if (*p == '\\0')\n+\t    abort ();\n+\t  ++p;\n+\t}\n+      this_path_len = p - this_path;\n+\n+      /* Check the arguments.  */\n+      failed = 0;\n+      ++p;\n+      while (*p != ';')\n+\t{\n+\t  if (*p == '\\0')\n+\t    abort ();\n+\n+\t  if (failed)\n+\t    {\n+\t      ++p;\n+\t      continue;\n+\t    }\n+\n+\t  this_arg = p;\n+\t  while (*p != ' ' && *p != ';')\n+\t    {\n+\t      if (*p == '\\0')\n+\t\tabort ();\n+\t      ++p;\n+\t    }\n+\n+\t  if (*this_arg == '!')\n+\t    failed = used_arg (this_arg + 1, p - (this_arg + 1));\n+\t  else\n+\t    failed = ! used_arg (this_arg, p - this_arg);\n+\n+\t  if (*p == ' ')\n+\t    ++p;\n+\t}\n+\n+      if (! failed)\n+\t{\n+\t  if (this_path_len != 1\n+\t      || this_path[0] != '.')\n+\t    {\n+\t      multilib_dir = xmalloc (this_path_len + 1);\n+\t      strncpy (multilib_dir, this_path, this_path_len);\n+\t      multilib_dir[this_path_len] = '\\0';\n+\t    }\n+\t  break;\n+\t}\n+\n+      ++p;\n+    }      \n+}\n+\n+/* Print out the multiple library subdirectory selection\n+   information.  This prints out a series of lines.  Each line looks\n+   like SUBDIRECTORY;@OPTION@OPTION, with as many options as is\n+   required.  Only the desired options are printed out, the negative\n+   matches.  The options are print without a leading dash.  There are\n+   no spaces to make it easy to use the information in the shell.\n+   Each subdirectory is printed only once.  This assumes the ordering\n+   generated by the genmultilib script.  */\n+\n+static void\n+print_multilib_info ()\n+{\n+  char *p = multilib_select;\n+  char *last_path, *this_path;\n+  int last_path_len, skip, use_arg;\n+\n+  while (*p != '\\0')\n+    {\n+      /* Ignore newlines.  */\n+      if (*p == '\\n')\n+\t{\n+\t  ++p;\n+\t  continue;\n+\t}\n+\n+      /* Get the initial path.  */\n+      this_path = p;\n+      while (*p != ' ')\n+\t{\n+\t  if (*p == '\\0')\n+\t    abort ();\n+\t  ++p;\n+\t}\n+\n+      /* If this is a duplicate, skip it.  */\n+      skip = (p - this_path == last_path_len\n+\t      && ! strncmp (last_path, this_path, last_path_len));\n+\n+      last_path = this_path;\n+      last_path_len = p - this_path;\n+\n+      if (! skip)\n+\t{\n+\t  char *p1;\n+\n+\t  for (p1 = last_path; p1 < p; p1++)\n+\t    putchar (*p1);\n+\t  putchar (';');\n+\t}\n+\n+      ++p;\n+      while (*p != ';')\n+\t{\n+\t  int use_arg;\n+\n+\t  if (*p == '\\0')\n+\t    abort ();\n+\n+\t  if (skip)\n+\t    {\n+\t      ++p;\n+\t      continue;\n+\t    }\n+\n+\t  use_arg = *p != '!';\n+\n+\t  if (use_arg)\n+\t    putchar ('@');\n+\n+\t  while (*p != ' ' && *p != ';')\n+\t    {\n+\t      if (*p == '\\0')\n+\t\tabort ();\n+\t      if (use_arg)\n+\t\tputchar (*p);\n+\t      ++p;\n+\t    }\n+\n+\t  if (*p == ' ')\n+\t    ++p;\n+\t}\n+\n+      if (! skip)\n+\tputchar ('\\n');\n+\n+      ++p;\n+    }\n+}"}]}