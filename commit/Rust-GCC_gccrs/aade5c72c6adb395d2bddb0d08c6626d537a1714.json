{"sha": "aade5c72c6adb395d2bddb0d08c6626d537a1714", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWFkZTVjNzJjNmFkYjM5NWQyYmRkYjBkMDhjNjYyNmQ1MzdhMTcxNA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2016-06-10T12:46:30Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2016-06-10T12:46:30Z"}, "message": "profile.c: Include cfgloop.h.\n\n\n\t* profile.c: Include cfgloop.h.\n\t(branch_prob): Compute estimated number of iterations.\n\t* tree-ssa-loop-niter.c (estimate_numbers_of_iterations_loop): Do not\n\trecompute estimate number of iterations from profile.\n\nFrom-SVN: r237305", "tree": {"sha": "51e6e0da3d401e02cfe021ad40bcd7b0cf5e8df6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/51e6e0da3d401e02cfe021ad40bcd7b0cf5e8df6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aade5c72c6adb395d2bddb0d08c6626d537a1714", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aade5c72c6adb395d2bddb0d08c6626d537a1714", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aade5c72c6adb395d2bddb0d08c6626d537a1714", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aade5c72c6adb395d2bddb0d08c6626d537a1714/comments", "author": null, "committer": null, "parents": [{"sha": "1f24fd3e734381f5e268d3a9897a2268b6d0485b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f24fd3e734381f5e268d3a9897a2268b6d0485b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f24fd3e734381f5e268d3a9897a2268b6d0485b"}], "stats": {"total": 53, "additions": 40, "deletions": 13}, "files": [{"sha": "954adf379478115e6bb627d5374f2e6b63277a96", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aade5c72c6adb395d2bddb0d08c6626d537a1714/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aade5c72c6adb395d2bddb0d08c6626d537a1714/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=aade5c72c6adb395d2bddb0d08c6626d537a1714", "patch": "@@ -1,3 +1,10 @@\n+2016-06-10  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* profile.c: Include cfgloop.h.\n+\t(branch_prob): Compute estimated number of iterations.\n+\t* tree-ssa-loop-niter.c (estimate_numbers_of_iterations_loop): Do not\n+\trecompute estimate number of iterations from profile.\n+\n 2016-06-10  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n \n \tPR inline-asm/68843"}, {"sha": "4519e7d8558b4424c64decf932f59501b5a06beb", "filename": "gcc/profile.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aade5c72c6adb395d2bddb0d08c6626d537a1714/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aade5c72c6adb395d2bddb0d08c6626d537a1714/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=aade5c72c6adb395d2bddb0d08c6626d537a1714", "patch": "@@ -63,6 +63,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-iterator.h\"\n #include \"tree-cfg.h\"\n #include \"dumpfile.h\"\n+#include \"cfgloop.h\"\n \n #include \"profile.h\"\n \n@@ -1329,9 +1330,21 @@ branch_prob (void)\n   coverage_end_function (lineno_checksum, cfg_checksum);\n   if (flag_branch_probabilities && profile_info)\n     {\n+      struct loop *loop;\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \treport_predictor_hitrates ();\n       profile_status_for_fn (cfun) = PROFILE_READ;\n+\n+      /* At this moment we have precise loop iteration count estimates.\n+\t Record them to loop structure before the profile gets out of date. */\n+      FOR_EACH_LOOP (loop, 0)\n+\tif (loop->header->count)\n+\t  {\n+\t    gcov_type nit = expected_loop_iterations_unbounded (loop);\n+\t    widest_int bound = gcov_type_to_wide_int (nit);\n+\t    loop->any_estimate = false;\n+\t    record_niter_bound (loop, bound, true, false);\n+\t  }\n       compute_function_frequency ();\n     }\n }"}, {"sha": "32fe2f91eddc963a737f67b5c8f1a94b0e92c128", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aade5c72c6adb395d2bddb0d08c6626d537a1714/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aade5c72c6adb395d2bddb0d08c6626d537a1714/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=aade5c72c6adb395d2bddb0d08c6626d537a1714", "patch": "@@ -3721,8 +3721,26 @@ estimate_numbers_of_iterations_loop (struct loop *loop)\n     return;\n \n   loop->estimate_state = EST_AVAILABLE;\n-  /* Force estimate compuation but leave any existing upper bound in place.  */\n-  loop->any_estimate = false;\n+\n+  /* If we have a measured profile, use it to estimate the number of\n+     iterations.  Normally this is recorded by branch_prob right after\n+     reading the profile.  In case we however found a new loop, record the\n+     information here.\n+\n+     Explicitly check for profile status so we do not report\n+     wrong prediction hitrates for guessed loop iterations heuristics.\n+     Do not recompute already recorded bounds - we ought to be better on\n+     updating iteration bounds than updating profile in general and thus\n+     recomputing iteration bounds later in the compilation process will just\n+     introduce random roundoff errors.  */\n+  if (!loop->any_estimate\n+      && loop->header->count != 0\n+      && profile_status_for_fn (cfun) >= PROFILE_READ)\n+    {\n+      gcov_type nit = expected_loop_iterations_unbounded (loop);\n+      bound = gcov_type_to_wide_int (nit);\n+      record_niter_bound (loop, bound, true, false);\n+    }\n \n   /* Ensure that loop->nb_iterations is computed if possible.  If it turns out\n      to be constant, we avoid undefined behavior implied bounds and instead\n@@ -3756,17 +3774,6 @@ estimate_numbers_of_iterations_loop (struct loop *loop)\n \n   maybe_lower_iteration_bound (loop);\n \n-  /* If we have a measured profile, use it to estimate the number of\n-     iterations.  Explicitly check for profile status so we do not report\n-     wrong prediction hitrates for guessed loop iterations heuristics.  */\n-  if (loop->header->count != 0\n-      && profile_status_for_fn (cfun) >= PROFILE_READ)\n-    {\n-      gcov_type nit = expected_loop_iterations_unbounded (loop);\n-      bound = gcov_type_to_wide_int (nit);\n-      record_niter_bound (loop, bound, true, false);\n-    }\n-\n   /* If we know the exact number of iterations of this loop, try to\n      not break code with undefined behavior by not recording smaller\n      maximum number of iterations.  */"}]}