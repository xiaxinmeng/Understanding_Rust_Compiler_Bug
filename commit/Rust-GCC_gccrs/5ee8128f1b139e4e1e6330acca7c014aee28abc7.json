{"sha": "5ee8128f1b139e4e1e6330acca7c014aee28abc7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWVlODEyOGYxYjEzOWU0ZTFlNjMzMGFjY2E3YzAxNGFlZTI4YWJjNw==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2003-06-21T12:02:11Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2003-06-21T12:02:11Z"}, "message": "SpinnerModel.java: New file from classpath.\n\n2003-06-21  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/SpinnerModel.java:\n\tNew file from classpath.\n\t* javax/swing/border/LineBorder.java,\n\tjavax/swing/border/SoftBevelBorder.java,\n\tjavax/swing/plaf/BorderUIResource.java,\n\tjavax/swing/plaf/basic/BasicBorders.java:\n\tNew versions from classpath.\n\t* javax/swing/plaf/basic/doc-files/BasicBorders.MenuBarBorder-1.png,\n\tjavax/swing/plaf/basic/doc-files/BasicBorders.RadioButtonBorder-1.png,\n\tjavax/swing/plaf/basic/doc-files/BasicBorders.SplitPaneBorder-1.png,\n\tjavax/swing/plaf/basic/doc-files/BasicBorders.SplitPaneBorder-2.png,\n\tjavax/swing/plaf/basic/doc-files/BasicBorders.SplitPaneDividerBorder-1.png,\n\tjavax/swing/plaf/basic/doc-files/BasicBorders.ToggleButtonBorder-1.png:\n\tNew binary files from classpath.\n\nFrom-SVN: r68299", "tree": {"sha": "469600f3048baf782b462486a99be88a252aabb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/469600f3048baf782b462486a99be88a252aabb3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5ee8128f1b139e4e1e6330acca7c014aee28abc7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ee8128f1b139e4e1e6330acca7c014aee28abc7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ee8128f1b139e4e1e6330acca7c014aee28abc7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ee8128f1b139e4e1e6330acca7c014aee28abc7/comments", "author": null, "committer": null, "parents": [{"sha": "70642ee3e637e58b0d90a0608dfcceecce1f4cb8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70642ee3e637e58b0d90a0608dfcceecce1f4cb8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70642ee3e637e58b0d90a0608dfcceecce1f4cb8"}], "stats": {"total": 661, "additions": 649, "deletions": 12}, "files": [{"sha": "34a9282883ad1a54405bb26e11baed47e1dc72c6", "filename": "libjava/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ee8128f1b139e4e1e6330acca7c014aee28abc7/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ee8128f1b139e4e1e6330acca7c014aee28abc7/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=5ee8128f1b139e4e1e6330acca7c014aee28abc7", "patch": "@@ -1,3 +1,20 @@\n+2003-06-21  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/SpinnerModel.java:\n+\tNew file from classpath.\n+\t* javax/swing/border/LineBorder.java,\n+\tjavax/swing/border/SoftBevelBorder.java,\n+\tjavax/swing/plaf/BorderUIResource.java,\n+\tjavax/swing/plaf/basic/BasicBorders.java:\n+\tNew versions from classpath.\n+\t* javax/swing/plaf/basic/doc-files/BasicBorders.MenuBarBorder-1.png,\n+\tjavax/swing/plaf/basic/doc-files/BasicBorders.RadioButtonBorder-1.png,\n+\tjavax/swing/plaf/basic/doc-files/BasicBorders.SplitPaneBorder-1.png,\n+\tjavax/swing/plaf/basic/doc-files/BasicBorders.SplitPaneBorder-2.png,\n+\tjavax/swing/plaf/basic/doc-files/BasicBorders.SplitPaneDividerBorder-1.png,\n+\tjavax/swing/plaf/basic/doc-files/BasicBorders.ToggleButtonBorder-1.png:\n+\tNew binary files from classpath.\n+\n 2003-06-21  Michael Koch  <konqueror@gmx.de>\n \n \t* java/util/logging/LogRecord.java,"}, {"sha": "87d593068d6fd341eb972b038cdb22c4e695b662", "filename": "libjava/javax/swing/SpinnerModel.java", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ee8128f1b139e4e1e6330acca7c014aee28abc7/libjava%2Fjavax%2Fswing%2FSpinnerModel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ee8128f1b139e4e1e6330acca7c014aee28abc7/libjava%2Fjavax%2Fswing%2FSpinnerModel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FSpinnerModel.java?ref=5ee8128f1b139e4e1e6330acca7c014aee28abc7", "patch": "@@ -0,0 +1,54 @@\n+/* SpinnerModel.java -- \n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.swing;\n+\n+import javax.swing.event.ChangeListener;\n+\n+/**\n+ * @since 1.4\n+ */\n+public interface SpinnerModel\n+{\n+  public void setValue (Object value);\n+  public Object getValue ();\n+  public Object getNextValue ();\n+  public Object getPreviousValue ();\n+  public void addChangeListener (ChangeListener listener);\n+  public void removeChangeListener (ChangeListener listener);\n+}"}, {"sha": "3c85c29dfdbac0089115e41c648e177320d291c0", "filename": "libjava/javax/swing/border/LineBorder.java", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ee8128f1b139e4e1e6330acca7c014aee28abc7/libjava%2Fjavax%2Fswing%2Fborder%2FLineBorder.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ee8128f1b139e4e1e6330acca7c014aee28abc7/libjava%2Fjavax%2Fswing%2Fborder%2FLineBorder.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fborder%2FLineBorder.java?ref=5ee8128f1b139e4e1e6330acca7c014aee28abc7", "patch": "@@ -296,6 +296,15 @@ public Insets getBorderInsets(Component c, Insets insets)\n   }\n   \n   \n+  /**\n+   * Returns the color of the line.\n+   */\n+  public Color getLineColor()\n+  {\n+    return lineColor;\n+  }\n+  \n+  \n   /**\n    * Returns the thickness of the line in pixels.\n    */"}, {"sha": "c08fb00d259fa3165e0cfeafa1a86f4f90d1fbaa", "filename": "libjava/javax/swing/border/SoftBevelBorder.java", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ee8128f1b139e4e1e6330acca7c014aee28abc7/libjava%2Fjavax%2Fswing%2Fborder%2FSoftBevelBorder.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ee8128f1b139e4e1e6330acca7c014aee28abc7/libjava%2Fjavax%2Fswing%2Fborder%2FSoftBevelBorder.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fborder%2FSoftBevelBorder.java?ref=5ee8128f1b139e4e1e6330acca7c014aee28abc7", "patch": "@@ -60,9 +60,11 @@\n {\n   /**\n    * Determined using the <code>serialver</code> tool\n-   * of Apple/Sun JDK 1.3.1 on MacOS X 10.1.5.\n+   * of Sun JDK 1.4.1_01 on GNU/Linux 2.4.20. Interestingly,\n+   * the Apple/Sun JDK 1.3.1 on MacOS X 10.1.5 gives a different\n+   * value, namely -6658357140774549493L.\n    */\n-  static final long serialVersionUID = -6658357140774549493L;\n+  static final long serialVersionUID = 5248789787305979975L;\n \n \n   /**"}, {"sha": "9f87a8dd35f1e695da12fbe1780c937e200a2b31", "filename": "libjava/javax/swing/plaf/BorderUIResource.java", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ee8128f1b139e4e1e6330acca7c014aee28abc7/libjava%2Fjavax%2Fswing%2Fplaf%2FBorderUIResource.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ee8128f1b139e4e1e6330acca7c014aee28abc7/libjava%2Fjavax%2Fswing%2Fplaf%2FBorderUIResource.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2FBorderUIResource.java?ref=5ee8128f1b139e4e1e6330acca7c014aee28abc7", "patch": "@@ -623,10 +623,8 @@ public LineBorderUIResource(Color color, int thickness)\n      * property. However, as of JDK1.4.1, the LineBorderUIResource\n      * subclass does not have a corresponding constructor.\n      * \n-     * A request for enhancing the Swing API has been filed with Sun.\n-     * It currently is under review, its \"review ID\" is 188305.\n-     *\n-     *                         -- Sascha Brawer (brawer@dandelis.ch)\n+     * A request for enhancing the Swing API has been filed with Sun:\n+     * http://developer.java.sun.com/developer/bugParade/bugs/4879999.html\n      */\n   }\n "}, {"sha": "a543302d52166a3ee92f020443f00a72717dbc0a", "filename": "libjava/javax/swing/plaf/basic/BasicBorders.java", "status": "modified", "additions": 563, "deletions": 6, "changes": 569, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ee8128f1b139e4e1e6330acca7c014aee28abc7/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicBorders.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ee8128f1b139e4e1e6330acca7c014aee28abc7/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicBorders.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicBorders.java?ref=5ee8128f1b139e4e1e6330acca7c014aee28abc7", "patch": "@@ -72,7 +72,7 @@\n \n \n   /**\n-   * Returns a border that is suitable for a button.\n+   * Returns a border for drawing push buttons.\n    *\n    * <p>The colors of the border are retrieved from the\n    * <code>UIDefaults</code> of the currently active look and feel\n@@ -121,6 +121,136 @@ public static Border getButtonBorder()\n   }\n \n \n+  /**\n+   * Returns a border for drawing radio buttons.\n+   *\n+   * <p>The colors of the border are retrieved from the\n+   * <code>UIDefaults</code> of the currently active look and feel\n+   * using the keys <code>&#x201c;RadioButton.shadow&#x201d;</code>,\n+   * <code>&#x201c;RadioButton.darkShadow&#x201d;</code>,\n+   * <code>&#x201c;RadioButton.light&#x201d;</code>, and\n+   * <code>&#x201c;RadioButton.highlight&#x201d;</code>.\n+   *\n+   * <p><img src=\"BasicBorders.RadioButtonBorder-1.png\" width=\"300\"\n+   * height=\"135\" alt=\"[A screen shot of the returned border]\" />\n+   *\n+   * @return a {@link\n+   *         javax.swing.plaf.BorderUIResource#CompoundBorderUIResource}\n+   *         whose outer border is a {@link #RadioButtonBorder} and whose\n+   *         inner border is a {@link #MarginBorder}.\n+   */\n+  public static Border getRadioButtonBorder()\n+  {\n+    UIDefaults defaults;\n+    Border outer;\n+\n+    defaults = UIManager.getLookAndFeelDefaults();\n+\n+    /* The keys for UIDefaults have been determined by writing a\n+     * test program that dumps the UIDefaults to stdout; that program\n+     * was run on a JDK 1.4.1_01 for GNU/Linux. Note that in the API,\n+     * the key \"light\" is usually called \"highlight\", and \"highlight\"\n+     * is usually called \"lightHighlight\".\n+     */\n+    outer = new RadioButtonBorder(\n+      defaults.getColor(\"RadioButton.shadow\"),\n+      defaults.getColor(\"RadioButton.darkShadow\"),\n+      defaults.getColor(\"RadioButton.light\"),\n+      defaults.getColor(\"RadioButton.highlight\"));\n+\n+    /* While the inner border is shared between multiple buttons, we\n+     * do not share the outer border because RadioButtonBorders, being\n+     * ButtonBorders, store their border colors. We cannot guarantee\n+     * that the colors (which come from UIDefaults) are unchanged\n+     * between invocations of getButtonBorder. We could store the last\n+     * colors, and share the button border if the colors are the same\n+     * as in the last invocation, but it probably is not worth the\n+     * effort.\n+     */\n+    return new BorderUIResource.CompoundBorderUIResource(\n+      outer,\n+      /* inner */ getMarginBorder());\n+  }\n+\n+\n+  /**\n+   * Returns a border for drawing toggle buttons.\n+   *\n+   * <p>The colors of the border are retrieved from the\n+   * <code>UIDefaults</code> of the currently active look and feel\n+   * using the keys <code>&#x201c;ToggleButton.shadow&#x201d;</code>,\n+   * <code>&#x201c;ToggleButton.darkShadow&#x201d;</code>,\n+   * <code>&#x201c;ToggleButton.light&#x201d;</code>, and\n+   * <code>&#x201c;ToggleButton.highlight&#x201d;</code>.\n+   *\n+   * <p><img src=\"BasicBorders.ToggleButtonBorder-1.png\" width=\"270\"\n+   * height=\"135\" alt=\"[A screen shot of the returned border]\" />\n+   *\n+   * @return a {@link\n+   *         javax.swing.plaf.BorderUIResource#CompoundBorderUIResource}\n+   *         whose outer border is a {@link #ToggleButtonBorder} and whose\n+   *         inner border is a {@link #MarginBorder}.\n+   */\n+  public static Border getToggleButtonBorder()\n+  {\n+    UIDefaults defaults;\n+    Border outer;\n+\n+    defaults = UIManager.getLookAndFeelDefaults();\n+\n+    /* The keys for UIDefaults have been determined by writing a\n+     * test program that dumps the UIDefaults to stdout; that program\n+     * was run on a JDK 1.4.1_01 for GNU/Linux. Note that in the API,\n+     * the key \"light\" is usually called \"highlight\", and \"highlight\"\n+     * is usually called \"lightHighlight\".\n+     */\n+    outer = new ToggleButtonBorder(\n+      defaults.getColor(\"ToggleButton.shadow\"),\n+      defaults.getColor(\"ToggleButton.darkShadow\"),\n+      defaults.getColor(\"ToggleButton.light\"),\n+      defaults.getColor(\"ToggleButton.highlight\"));\n+\n+    /* While the inner border is shared between multiple buttons, we\n+     * do not share the outer border because ToggleButtonBorders, being\n+     * ButtonBorders, store their border colors. We cannot guarantee\n+     * that the colors (which come from UIDefaults) are unchanged\n+     * between invocations of getButtonBorder. We could store the last\n+     * colors, and share the button border if the colors are the same\n+     * as in the last invocation, but it probably is not worth the\n+     * effort.\n+     */\n+    return new BorderUIResource.CompoundBorderUIResource(\n+      outer,\n+      /* inner */ getMarginBorder());\n+  }\n+\n+\n+  /**\n+   * Returns a border for drawing a two-pixel thick separator line\n+   * below menu bars.\n+   *\n+   * <p>The colors of the border are retrieved from the\n+   * <code>UIDefaults</code> of the currently active look and feel\n+   * using the keys <code>&#x201c;MenuBar.shadow&#x201d;</code> and\n+   * <code>&#x201c;MenuBar.highlight&#x201d;</code>.\n+   *\n+   * <p><img src=\"BasicBorders.MenuBarBorder-1.png\" width=\"500\"\n+   * height=\"140\" alt=\"[A screen shot of a JMenuBar with this border]\" />\n+   *\n+   * @return a {@link #MenuBarBorder}.\n+   *\n+   * @see javax.swing.JMenuBar\n+   */\n+  public static Border getMenuBarBorder()\n+  {\n+    UIDefaults defaults;\n+\n+    defaults = UIManager.getLookAndFeelDefaults();\n+    return new MenuBarBorder(defaults.getColor(\"MenuBar.shadow\"),\n+                             defaults.getColor(\"MenuBar.highlight\"));\n+  }\n+\n+\n   /**\n    * Returns a shared MarginBorder.\n    */\n@@ -421,16 +551,317 @@ else if (c instanceof JToolBar)\n     }\n   }\n   \n-  \n+\n+  /**\n+   * A border for drawing a separator line below JMenuBar.\n+   *\n+   * <p><img src=\"BasicBorders.MenuBarBorder-1.png\" width=\"500\"\n+   * height=\"140\" alt=\"[A screen shot of a JMenuBar with this border]\" />\n+   *\n+   * @author Sascha Brawer (brawer@dandelis.ch)\n+   */\n   public static class MenuBarBorder\n+    extends AbstractBorder\n+    implements UIResource\n   {\n+    /**\n+     * Determined using the <code>serialver</code> tool\n+     * of Apple/Sun JDK 1.3.1 on MacOS X 10.1.5.\n+     */\n+    static final long serialVersionUID = -6909056571935227506L;\n+    \n+    \n+    /**\n+     * The shadow color, which is used for the upper line of the\n+     * two-pixel thick bottom edge.\n+     */\n+    private Color shadow;\n+\n+\n+    /**\n+     * The highlight color, which is used for the lower line of the\n+     * two-pixel thick bottom edge.\n+     */\n+    private Color highlight;\n+\n+\n+    /**\n+     * Constructs a new MenuBarBorder for drawing a JMenuBar in\n+     * the Basic look and feel.\n+     *\n+     * <p><img src=\"BasicBorders.MenuBarBorder-1.png\" width=\"500\"\n+     * height=\"140\" alt=\"[A screen shot of a JMenuBar with this\n+     * border]\" />\n+     *\n+     * @param shadow the shadow color, which is used for the upper\n+     *        line of the two-pixel thick bottom edge.\n+     *\n+     * @param highlight the shadow color, which is used for the lower\n+     *        line of the two-pixel thick bottom edge.\n+     */\n     public MenuBarBorder(Color shadow, Color highlight)\n     {\n+      /* These colors usually come from the UIDefaults of the current\n+       * look and feel. Use fallback values if the colors are not\n+       * supplied.  The API specification is silent about what\n+       * behavior is expected for null colors, so users should not\n+       * rely on this fallback (which is why it is not documented in\n+       * the above Javadoc).\n+       */\n+      this.shadow = (shadow != null) ? shadow : Color.gray;\n+      this.highlight = (highlight != null) ? highlight : Color.white;\n+    }\n+\n+\n+    /**\n+     * Paints the MenuBarBorder around a given component.\n+     *\n+     * @param c the component whose border is to be painted, usually\n+     *        an instance of {@link javax.swing.JMenuBar}.\n+     *\n+     * @param g the graphics for painting.\n+     * @param x the horizontal position for painting the border.\n+     * @param y the vertical position for painting the border.\n+     * @param width the width of the available area for painting the border.\n+     * @param height the height of the available area for painting the border.\n+     */\n+    public void paintBorder(Component c, Graphics  g,\n+                            int x, int y, int width, int height)\n+    {\n+      Color oldColor;\n+\n+      /* To understand this code, it might be helpful to look at the\n+       * image \"BasicBorders.MenuBarBorder-1.png\" that is included\n+       * with the JavaDoc. It is located in the \"doc-files\"\n+       * subdirectory.\n+       */\n+      oldColor = g.getColor();\n+      y = y + height - 2;\n+      try\n+      {\n+        g.setColor(shadow);\n+        g.drawLine(x, y, x + width - 2, y);\n+        g.drawLine(x, y + 1, x, y + 1);\n+        g.drawLine(x + width - 2, y + 1, x + width - 2, y + 1);\n+\n+        g.setColor(highlight);\n+        g.drawLine(x + 1, y + 1, x + width - 3, y + 1);\n+        g.drawLine(x + width - 1, y, x + width - 1, y + 1);        \n+      }\n+      finally\n+      {\n+        g.setColor(oldColor);\n+      }\n+    }\n+\n+\n+    /**\n+     * Measures the width of this border.\n+     *\n+     * @param c the component whose border is to be measured.\n+     *\n+     * @return an Insets object whose <code>left</code>,\n+     *         <code>right</code>, <code>top</code> and\n+     *         <code>bottom</code> fields indicate the width of the\n+     *         border at the respective edge.\n+     *\n+     * @see #getBorderInsets(java.awt.Component, java.awt.Insets)\n+     */\n+    public Insets getBorderInsets(Component c)\n+    {\n+      /* There is no obvious reason for overriding this method, but we\n+       * try to have exactly the same API as the Sun reference\n+       * implementation.\n+       */\n+      return getBorderInsets(c, null);\n     }\n-  } // class MenuBarBorder\n+\n+\n+    /**\n+     * Measures the width of this border, storing the results into a\n+     * pre-existing Insets object.\n+     *\n+     * @param insets an Insets object for holding the result values.\n+     *        After invoking this method, the <code>left</code>,\n+     *        <code>right</code>, <code>top</code> and\n+     *        <code>bottom</code> fields indicate the width of the\n+     *        border at the respective edge.\n+     *\n+     * @return the same object that was passed for <code>insets</code>.\n+     *\n+     * @see #getBorderInsets()\n+     */\n+    public Insets getBorderInsets(Component c, Insets insets)\n+    {\n+      /* The exact amount has been determined using a test program\n+       * that was run on the Apple/Sun JDK 1.3.1 on MacOS X, and the\n+       * Sun JDK 1.4.1_01 on GNU/Linux for x86. Both gave [0,0,2,0],\n+       * which was expected from looking at the screen shot.\n+       */\n+      if (insets == null)\n+        return new Insets(0, 0, 2, 0);\n+\n+      insets.left = insets.right = insets.top = 0;\n+      insets.bottom = 2;\n+      return insets;\n+    }\n+  }\n+\n+\n+  /**\n+   * A border for drawing radio buttons in the Basic look and feel.\n+   *\n+   * <p><img src=\"BasicBorders.RadioButtonBorder-1.png\" width=\"300\"\n+   * height=\"135\" alt=\"[A screen shot of this border]\" />\n+   *\n+   * <p>Note about the screen shot: Normally, the\n+   * <code>borderPainted</code> property is <code>false</code> for\n+   * JRadioButtons. For this screen shot, it has been set to\n+   * <code>true</code> so the borders get drawn. Also, a\n+   * concretization of the Basic look and would typically provide\n+   * icons for the various states of radio buttons.\n+   *\n+   * <p>Note that the focus rectangle is invisible If the radio button\n+   * is currently selected. While it might be debatable whether this\n+   * makes a lot of sense, this behavior can be observed in the Sun\n+   * reference implementation (in JDK 1.3.1 and 1.4.1). The Classpath\n+   * implementation tries to exactly replicate the JDK appearance.\n+   *\n+   * @see javax.swing.plaf.basic.BasicGraphicsUtils#drawBezel\n+   *\n+   * @author Sascha Brawer (brawer@dandelis.ch)\n+   */\n   public static class RadioButtonBorder\n+    extends ButtonBorder\n   {\n-  } // class RadioButtonBorder\n+    /**\n+     * Determined using the <code>serialver</code> tool\n+     * of Apple/Sun JDK 1.3.1 on MacOS X 10.1.5.\n+     */\n+    static final long serialVersionUID = 1596945751743747369L;\n+\n+\n+    /**\n+     * Constructs a new border for drawing a JRadioButton in\n+     * the Basic look and feel.\n+     *\n+     * @param shadow the shadow color.\n+     * @param darkShadow a darker variant of the shadow color.\n+     * @param highlight the highlight color.\n+     * @param lightHighlight a brighter variant of the highlight  color.\n+     */\n+    public RadioButtonBorder(Color shadow, Color darkShadow,\n+                             Color highlight, Color lightHighlight)\n+    {\n+      /* The superclass ButtonBorder substitutes null arguments\n+       * with fallback colors.\n+       */\n+      super(shadow, darkShadow, highlight, lightHighlight);\n+    }\n+\n+\n+    /**\n+     * Paints the RadioButtonBorder around a given component.\n+     *\n+     * <p>The Sun implementation always seems to draw exactly\n+     * the same border, irrespective of the state of the button.\n+     * This is rather surprising, but GNU Classpath emulates the\n+     * observable behavior.\n+     *\n+     * @param c the component whose border is to be painted.\n+     * @param g the graphics for painting.\n+     * @param x the horizontal position for painting the border.\n+     * @param y the vertical position for painting the border.\n+     * @param width the width of the available area for painting the border.\n+     * @param height the height of the available area for painting the border.\n+     *\n+     * @see javax.swing.plaf.basic.BasicGraphicsUtils#drawBezel\n+     */\n+    public void paintBorder(Component c, Graphics  g,\n+                            int x, int y, int width, int height)\n+    {\n+      AbstractButton button = null;\n+      ButtonModel bmodel = null;\n+      boolean lowered = false;\n+      boolean focused = false;\n+\n+      if (c instanceof AbstractButton)\n+      {\n+        button = (AbstractButton) c;\n+        bmodel = button.getModel();\n+      }\n+\n+      if (bmodel != null)\n+      {\n+        lowered = button.isSelected()\n+          || (/* mouse inside */ bmodel.isArmed() && bmodel.isPressed());\n+        focused = button.hasFocus() && button.isFocusPainted();        \n+      }\n+\n+      if (lowered)\n+        BasicGraphicsUtils.drawLoweredBezel(g, x, y, width, height,\n+                                            shadow, darkShadow,\n+                                            highlight, lightHighlight);\n+      else\n+        BasicGraphicsUtils.drawBezel(g, x, y, width, height,\n+                                     /* isPressed */ false,\n+                                     /* isPefault */ focused,\n+                                     shadow, darkShadow,\n+                                     highlight, lightHighlight);\n+    }\n+    \n+    \n+    /**\n+     * Measures the width of this border.\n+     *\n+     * @param c the component whose border is to be measured.\n+     *\n+     * @return an Insets object whose <code>left</code>,\n+     *         <code>right</code>, <code>top</code> and\n+     *         <code>bottom</code> fields indicate the width of the\n+     *         border at the respective edge.\n+     *\n+     * @see #getBorderInsets(java.awt.Component, java.awt.Insets) \n+     */\n+    public Insets getBorderInsets(Component c)\n+    {\n+      /* There is no obvious reason for overriding this method, but we\n+       * try to have exactly the same API as the Sun reference\n+       * implementation.\n+       */\n+      return getBorderInsets(c, null);\n+    }\n+\n+    \n+    /**\n+     * Measures the width of this border, storing the results into a\n+     * pre-existing Insets object.\n+     *\n+     * @param insets an Insets object for holding the result values.\n+     *        After invoking this method, the <code>left</code>,\n+     *        <code>right</code>, <code>top</code> and\n+     *        <code>bottom</code> fields indicate the width of the\n+     *        border at the respective edge.\n+     *\n+     * @return the same object that was passed for <code>insets</code>.\n+     *\n+     * @see #getBorderInsets()\n+     */\n+    public Insets getBorderInsets(Component c, Insets insets)\n+    {\n+      /* The exact amount has been determined using a test program\n+       * that was run on the Apple/Sun JDK 1.3.1 on MacOS X, and the\n+       * Sun JDK 1.4.1_01 on GNU/Linux for x86. Both gave [2,2,2,2].\n+       */\n+      if (insets == null)\n+        return new Insets(2, 2, 2, 2);\n+\n+      insets.left = insets.right = insets.top = insets.bottom = 2;\n+      return insets;\n+    }\n+  }\n+\n+\n   public static class RolloverButtonBorder\n   {\n   } // class RolloverButtonBorder\n@@ -440,7 +871,133 @@ public SplitPaneBorder(Color highlight, Color shadow)\n     {\n     }\n   } // class SplitPaneBorder\n+\n+\n+  /**\n+   * A border for toggle buttons in the Basic look and feel.\n+   *\n+   * <p><img src=\"BasicBorders.ToggleButtonBorder-1.png\" width=\"270\"\n+   * height=\"135\" alt=\"[A screen shot of this border]\" />\n+   *\n+   * <p>The Sun implementation always seems to draw exactly\n+   * the same border, irrespective of the state of the button.\n+   * This is rather surprising, but GNU Classpath emulates the\n+   * observable behavior.\n+   *\n+   * @see javax.swing.plaf.basic.BasicGraphicsUtils#drawBezel\n+   *\n+   * @author Sascha Brawer (brawer@dandelis.ch)\n+   */\n   public static class ToggleButtonBorder\n+    extends ButtonBorder\n   {\n-  } // class ToggleButtonBorder\n-} // class BasicBorders\n+    /**\n+     * Determined using the <code>serialver</code> tool\n+     * of Apple/Sun JDK 1.3.1 on MacOS X 10.1.5.\n+     */\n+    static final long serialVersionUID = -3528666548001058394L;\n+\n+    \n+    /**\n+     * Constructs a new border for drawing a JToggleButton in\n+     * the Basic look and feel.\n+     *\n+     * @param shadow the shadow color.\n+     * @param darkShadow a darker variant of the shadow color.\n+     * @param highlight the highlight color.\n+     * @param lightHighlight a brighter variant of the highlight  color.\n+     */\n+    public ToggleButtonBorder(Color shadow, Color darkShadow,\n+                              Color highlight, Color lightHighlight)\n+    {\n+      /* The superclass ButtonBorder substitutes null arguments\n+       * with fallback colors.\n+       */\n+      super(shadow, darkShadow, highlight, lightHighlight);\n+    }\n+\n+\n+    /**\n+     * Paints the ToggleButtonBorder around a given component.\n+     *\n+     * <p>The Sun implementation always seems to draw exactly\n+     * the same border, irrespective of the state of the button.\n+     * This is rather surprising, but GNU Classpath emulates the\n+     * observable behavior.\n+     *\n+     * @param c the component whose border is to be painted.\n+     * @param g the graphics for painting.\n+     * @param x the horizontal position for painting the border.\n+     * @param y the vertical position for painting the border.\n+     * @param width the width of the available area for painting the border.\n+     * @param height the height of the available area for painting the border.\n+     *\n+     * @see javax.swing.plaf.basic.BasicGraphicsUtils#drawBezel\n+     */\n+    public void paintBorder(Component c, Graphics  g,\n+                            int x, int y, int width, int height)\n+    {\n+      /* The author of this code tried various variants for setting\n+       * the state of the enclosed JToggleButton, but it seems that\n+       * the drawn border is always identical. Weird, because this\n+       * means that the user does not see whether the JToggleButton\n+       * is selected or not.\n+       */\n+      BasicGraphicsUtils.drawBezel(g, x, y, width, height,\n+                                   /* pressed */ false, \n+                                   /* default */ false,\n+                                   shadow, darkShadow,\n+                                   highlight, lightHighlight);\n+    }\n+\n+\n+    /**\n+     * Measures the width of this border.\n+     *\n+     * @param c the component whose border is to be measured.\n+     *\n+     * @return an Insets object whose <code>left</code>,\n+     *         <code>right</code>, <code>top</code> and\n+     *         <code>bottom</code> fields indicate the width of the\n+     *         border at the respective edge.\n+     *\n+     * @see #getBorderInsets(java.awt.Component, java.awt.Insets) \n+     */\n+    public Insets getBorderInsets(Component c)\n+    {\n+      /* There is no obvious reason for overriding this method, but we\n+       * try to have exactly the same API as the Sun reference\n+       * implementation.\n+       */\n+      return getBorderInsets(c, null);\n+    }\n+\n+    \n+    /**\n+     * Measures the width of this border, storing the results into a\n+     * pre-existing Insets object.\n+     *\n+     * @param insets an Insets object for holding the result values.\n+     *        After invoking this method, the <code>left</code>,\n+     *        <code>right</code>, <code>top</code> and\n+     *        <code>bottom</code> fields indicate the width of the\n+     *        border at the respective edge.\n+     *\n+     * @return the same object that was passed for <code>insets</code>.\n+     *\n+     * @see #getBorderInsets()\n+     */\n+    public Insets getBorderInsets(Component c, Insets insets)\n+    {\n+      /* The exact amount has been determined using a test program\n+       * that was run on the Apple/Sun JDK 1.3.1 on MacOS X, and the\n+       * Sun JDK 1.4.1_01 on GNU/Linux for x86. Both gave [2,2,2,2].\n+       */\n+      if (insets == null)\n+        return new Insets(2, 2, 2, 2);\n+\n+      insets.left = insets.right = insets.top = insets.bottom = 2;\n+      return insets;\n+    }\n+  }\n+}"}, {"sha": "13a9fa4e90f406245917b5a10be7326c4084325f", "filename": "libjava/javax/swing/plaf/basic/doc-files/BasicBorders.MenuBarBorder-1.png", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ee8128f1b139e4e1e6330acca7c014aee28abc7/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2Fdoc-files%2FBasicBorders.MenuBarBorder-1.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ee8128f1b139e4e1e6330acca7c014aee28abc7/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2Fdoc-files%2FBasicBorders.MenuBarBorder-1.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2Fdoc-files%2FBasicBorders.MenuBarBorder-1.png?ref=5ee8128f1b139e4e1e6330acca7c014aee28abc7"}, {"sha": "a6408ec7e1d1e40f1fcf71c4d27117d068392725", "filename": "libjava/javax/swing/plaf/basic/doc-files/BasicBorders.RadioButtonBorder-1.png", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ee8128f1b139e4e1e6330acca7c014aee28abc7/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2Fdoc-files%2FBasicBorders.RadioButtonBorder-1.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ee8128f1b139e4e1e6330acca7c014aee28abc7/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2Fdoc-files%2FBasicBorders.RadioButtonBorder-1.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2Fdoc-files%2FBasicBorders.RadioButtonBorder-1.png?ref=5ee8128f1b139e4e1e6330acca7c014aee28abc7"}, {"sha": "db283c29a06ce3ba2a9be2d6f87c11ba9c3a217c", "filename": "libjava/javax/swing/plaf/basic/doc-files/BasicBorders.SplitPaneBorder-1.png", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ee8128f1b139e4e1e6330acca7c014aee28abc7/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2Fdoc-files%2FBasicBorders.SplitPaneBorder-1.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ee8128f1b139e4e1e6330acca7c014aee28abc7/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2Fdoc-files%2FBasicBorders.SplitPaneBorder-1.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2Fdoc-files%2FBasicBorders.SplitPaneBorder-1.png?ref=5ee8128f1b139e4e1e6330acca7c014aee28abc7"}, {"sha": "65381bd8b4d3204aee7c3f1e32f0da3f0f997a57", "filename": "libjava/javax/swing/plaf/basic/doc-files/BasicBorders.SplitPaneBorder-2.png", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ee8128f1b139e4e1e6330acca7c014aee28abc7/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2Fdoc-files%2FBasicBorders.SplitPaneBorder-2.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ee8128f1b139e4e1e6330acca7c014aee28abc7/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2Fdoc-files%2FBasicBorders.SplitPaneBorder-2.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2Fdoc-files%2FBasicBorders.SplitPaneBorder-2.png?ref=5ee8128f1b139e4e1e6330acca7c014aee28abc7"}, {"sha": "c22763a97dfef4a3547691f59a9fe5ff68a11084", "filename": "libjava/javax/swing/plaf/basic/doc-files/BasicBorders.SplitPaneDividerBorder-1.png", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ee8128f1b139e4e1e6330acca7c014aee28abc7/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2Fdoc-files%2FBasicBorders.SplitPaneDividerBorder-1.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ee8128f1b139e4e1e6330acca7c014aee28abc7/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2Fdoc-files%2FBasicBorders.SplitPaneDividerBorder-1.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2Fdoc-files%2FBasicBorders.SplitPaneDividerBorder-1.png?ref=5ee8128f1b139e4e1e6330acca7c014aee28abc7"}, {"sha": "f898bee8fa73e5e39100ec5f88726c2e0d4447a0", "filename": "libjava/javax/swing/plaf/basic/doc-files/BasicBorders.ToggleButtonBorder-1.png", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ee8128f1b139e4e1e6330acca7c014aee28abc7/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2Fdoc-files%2FBasicBorders.ToggleButtonBorder-1.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ee8128f1b139e4e1e6330acca7c014aee28abc7/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2Fdoc-files%2FBasicBorders.ToggleButtonBorder-1.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2Fdoc-files%2FBasicBorders.ToggleButtonBorder-1.png?ref=5ee8128f1b139e4e1e6330acca7c014aee28abc7"}]}