{"sha": "fe9b4957b55b20ec031a6ae0151a9306cb847328", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmU5YjQ5NTdiNTViMjBlYzAzMWE2YWUwMTUxYTkzMDZjYjg0NzMyOA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-03-23T07:51:12Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-03-23T07:51:12Z"}, "message": "function.c: Include hash.h.\n\n\t* function.c: Include hash.h.\n\t(insns_for_mem_entry): New struct.\n\t(put_reg_into_stack): Take an optional hash-table mapping MEMs to\n\tthe INSNs that use them.\n\t(fixup_var_refs): Likewise.\n\t(put_addressof_into_stack): Likewise.\n\t(purge_addressof_1): Likewise.  Keep the hash-table up to date if\n\twe add new instructions.\n\t(fixup_var_refs_insns): Use it to avoid searching the entire\n\tinstruction chain.\n\t(insns_for_mem_newfunc): New function.\n\t(insns_for_mem_comp): Likewise.\n\t(insns_for_mem_walk): Likewise.\n\t(compute_insns_for_mem): Likewise.\n\t(pop_function_context_from): Pass NULL for the hash-table.\n\t(put_var_into_stack): Likewise.\n\t(gen_mem_addressof): Likewise.\n\t(flush_addressof): Likewise.\n\t(purge_addressof): Call compute_insns_for_mem to pre-compute the\n\thash table.\n\t* Makefile.in (OBJS): Include hash.o.\n\t(function.o): Depend on hash.h.\n\t* Makefile.in (OBJS): Don't mention hash.o.\n\t(OBJDEPS): Likewise.\n\nFrom-SVN: r25922", "tree": {"sha": "d1e714dbd231ec0afc0f5a154a1babff317b1019", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d1e714dbd231ec0afc0f5a154a1babff317b1019"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fe9b4957b55b20ec031a6ae0151a9306cb847328", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe9b4957b55b20ec031a6ae0151a9306cb847328", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe9b4957b55b20ec031a6ae0151a9306cb847328", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe9b4957b55b20ec031a6ae0151a9306cb847328/comments", "author": null, "committer": null, "parents": [{"sha": "9ee9b555021cd59c28ca989a4cdeff4cc0f9cbcc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ee9b555021cd59c28ca989a4cdeff4cc0f9cbcc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ee9b555021cd59c28ca989a4cdeff4cc0f9cbcc"}], "stats": {"total": 311, "additions": 271, "deletions": 40}, "files": [{"sha": "ea806cec02552a850fc81a212a4cc5ff3f27457d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9b4957b55b20ec031a6ae0151a9306cb847328/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9b4957b55b20ec031a6ae0151a9306cb847328/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fe9b4957b55b20ec031a6ae0151a9306cb847328", "patch": "@@ -1,3 +1,28 @@\n+Tue Mar 23 07:50:20 1999  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* function.c: Include hash.h.\n+\t(insns_for_mem_entry): New struct.\n+\t(put_reg_into_stack): Take an optional hash-table mapping MEMs to\n+\tthe INSNs that use them.\n+\t(fixup_var_refs): Likewise.\n+\t(put_addressof_into_stack): Likewise.\n+\t(purge_addressof_1): Likewise.  Keep the hash-table up to date if\n+\twe add new instructions.\n+\t(fixup_var_refs_insns): Use it to avoid searching the entire\n+\tinstruction chain.\n+\t(insns_for_mem_newfunc): New function.\n+\t(insns_for_mem_comp): Likewise.\n+\t(insns_for_mem_walk): Likewise.\n+\t(compute_insns_for_mem): Likewise.\n+\t(pop_function_context_from): Pass NULL for the hash-table.\n+\t(put_var_into_stack): Likewise.\n+\t(gen_mem_addressof): Likewise.\n+\t(flush_addressof): Likewise.\n+\t(purge_addressof): Call compute_insns_for_mem to pre-compute the\n+\thash table.\n+\t* Makefile.in (OBJS): Include hash.o.\n+\t(function.o): Depend on hash.h.\n+\t\n Tue Mar 23 00:39:14 1999  Jeffrey A Law  (law@cygnus.com)\n \n \t* crtstuff.c: Use ANSI function definitions.  Fix minor whitespace"}, {"sha": "93eef5e1ac14b999692c6232ab3a9483f2ca2a26", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9b4957b55b20ec031a6ae0151a9306cb847328/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9b4957b55b20ec031a6ae0151a9306cb847328/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=fe9b4957b55b20ec031a6ae0151a9306cb847328", "patch": "@@ -679,7 +679,7 @@ OBJS = toplev.o version.o tree.o print-tree.o stor-layout.o fold-const.o \\\n  insn-peep.o reorg.o $(SCHED_PREFIX)sched.o final.o recog.o reg-stack.o \\\n  insn-opinit.o insn-recog.o insn-extract.o insn-output.o insn-emit.o lcm.o \\\n  profile.o insn-attrtab.o $(out_object_file) getpwd.o $(EXTRA_OBJS) convert.o \\\n- mbchar.o dyn-string.o splay-tree.o graph.o sbitmap.o resource.o\n+ mbchar.o dyn-string.o splay-tree.o graph.o sbitmap.o resource.o hash.o\n \n # GEN files are listed separately, so they can be built before doing parallel\n #  makes for cc1 or cc1plus.  Otherwise sequent parallel make attempts to load\n@@ -1452,7 +1452,7 @@ varasm.o : varasm.c $(CONFIG_H) system.h $(TREE_H) $(RTL_H) flags.h \\\n    xcoffout.h output.h c-pragma.h toplev.h except.h dbxout.h sdbout.h\n function.o : function.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h \\\n    function.h insn-flags.h insn-codes.h $(EXPR_H) $(REGS_H) hard-reg-set.h \\\n-   insn-config.h $(RECOG_H) output.h toplev.h except.h\n+   insn-config.h $(RECOG_H) output.h toplev.h except.h hash.h\n stmt.o : stmt.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h function.h  \\\n    insn-flags.h insn-config.h insn-codes.h hard-reg-set.h $(EXPR_H) except.h \\\n    loop.h $(RECOG_H) toplev.h output.h varray.h"}, {"sha": "3b9dd255c9f7de9b06070d36b7c0d03c6738d814", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9b4957b55b20ec031a6ae0151a9306cb847328/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9b4957b55b20ec031a6ae0151a9306cb847328/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=fe9b4957b55b20ec031a6ae0151a9306cb847328", "patch": "@@ -1,3 +1,8 @@\n+1999-03-23  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* Makefile.in (OBJS): Don't mention hash.o.\n+\t(OBJDEPS): Likewise.\n+\n 1999-03-23  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* decl2.c (finish_file): Set at_eof to 2 after expanding ctors.\n@@ -60,6 +65,7 @@\n \t* decl.c (start_function): Suppress normal linkage heuristics\n \tfor #pragma interface under MULTIPLE_SYMBOL_SPACES.\n \n+>>>>>>> 1.947\n 1999-03-19  Alexandre Oliva  <oliva@dcc.unicamp.br>\n \n \t* Make-lang.in: ($(INTL_TARGETS)): depend on cp/parse.c"}, {"sha": "ef81437d2aefbfb73e84c5b772533dc1856365da", "filename": "gcc/cp/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9b4957b55b20ec031a6ae0151a9306cb847328/gcc%2Fcp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9b4957b55b20ec031a6ae0151a9306cb847328/gcc%2Fcp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMakefile.in?ref=fe9b4957b55b20ec031a6ae0151a9306cb847328", "patch": "@@ -191,8 +191,8 @@ CXX_OBJS = call.o decl.o errfn.o expr.o pt.o sig.o typeck2.o \\\n  repo.o @extra_cxx_objs@\n \n # Language-independent object files.\n-OBJS = `cat ../stamp-objlist` ../c-common.o ../c-pragma.o ../hash.o\n-OBJDEPS = ../stamp-objlist ../c-common.o ../c-pragma.o ../hash.o\n+OBJS = `cat ../stamp-objlist` ../c-common.o ../c-pragma.o\n+OBJDEPS = ../stamp-objlist ../c-common.o ../c-pragma.o\n \n compiler: ../cc1plus$(exeext)\n ../cc1plus$(exeext): $(P) $(OBJDEPS) $(CXX_OBJS) $(LIBDEPS)"}, {"sha": "879fe4409145259a86fa34404d3f69a8b7151122", "filename": "gcc/function.c", "status": "modified", "additions": 236, "deletions": 36, "changes": 272, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe9b4957b55b20ec031a6ae0151a9306cb847328/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe9b4957b55b20ec031a6ae0151a9306cb847328/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=fe9b4957b55b20ec031a6ae0151a9306cb847328", "patch": "@@ -56,6 +56,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"basic-block.h\"\n #include \"obstack.h\"\n #include \"toplev.h\"\n+#include \"hash.h\"\n \n #if !defined PREFERRED_STACK_BOUNDARY && defined STACK_BOUNDARY\n #define PREFERRED_STACK_BOUNDARY STACK_BOUNDARY\n@@ -451,6 +452,13 @@ struct fixup_replacement\n   struct fixup_replacement *next;\n };\n    \n+struct insns_for_mem_entry {\n+  /* The KEY in HE will be a MEM.  */\n+  struct hash_entry he;\n+  /* These are the INSNS which reference the MEM.  */\n+  rtx insns;\n+};\n+\n /* Forward declarations.  */\n \n static rtx assign_outer_stack_local PROTO ((enum machine_mode, HOST_WIDE_INT,\n@@ -460,12 +468,14 @@ static rtx assign_stack_temp_for_type PROTO ((enum machine_mode, HOST_WIDE_INT,\n static struct temp_slot *find_temp_slot_from_address  PROTO((rtx));\n static void put_reg_into_stack\tPROTO((struct function *, rtx, tree,\n \t\t\t\t       enum machine_mode, enum machine_mode,\n-\t\t\t\t       int, int, int));\n-static void fixup_var_refs\tPROTO((rtx, enum machine_mode, int));\n+\t\t\t\t       int, int, int, \n+\t\t\t\t       struct hash_table *));\n+static void fixup_var_refs\tPROTO((rtx, enum machine_mode, int, \n+\t\t\t\t       struct hash_table *));\n static struct fixup_replacement\n   *find_fixup_replacement\tPROTO((struct fixup_replacement **, rtx));\n static void fixup_var_refs_insns PROTO((rtx, enum machine_mode, int,\n-\t\t\t\t\trtx, int));\n+\t\t\t\t\trtx, int, struct hash_table *));\n static void fixup_var_refs_1\tPROTO((rtx, enum machine_mode, rtx *, rtx,\n \t\t\t\t       struct fixup_replacement **));\n static rtx fixup_memory_subreg\tPROTO((rtx, rtx, int));\n@@ -492,8 +502,17 @@ static int all_blocks\t\tPROTO((tree, tree *));\n static int *record_insns\tPROTO((rtx));\n static int contains\t\tPROTO((rtx, int *));\n #endif /* HAVE_prologue || HAVE_epilogue */\n-static void put_addressof_into_stack PROTO((rtx));\n-static void purge_addressof_1\tPROTO((rtx *, rtx, int, int));\n+static void put_addressof_into_stack PROTO((rtx, struct hash_table *));\n+static void purge_addressof_1\tPROTO((rtx *, rtx, int, int, \n+\t\t\t\t       struct hash_table *));\n+static struct hash_entry *insns_for_mem_newfunc PROTO((struct hash_entry *,\n+\t\t\t\t\t\t       struct hash_table *,\n+\t\t\t\t\t\t       hash_table_key));\n+static unsigned long insns_for_mem_hash PROTO ((hash_table_key));\n+static boolean insns_for_mem_comp PROTO ((hash_table_key, hash_table_key));\n+static int insns_for_mem_walk   PROTO ((rtx *, void *));\n+static void compute_insns_for_mem PROTO ((rtx, rtx, struct hash_table *));\n+\n \f\n /* Pointer to chain of `struct function' for containing functions.  */\n struct function *outer_function_chain;\n@@ -683,7 +702,8 @@ pop_function_context_from (context)\n   /* Finish doing put_var_into_stack for any of our variables\n      which became addressable during the nested function.  */\n   for (queue = p->fixup_var_refs_queue; queue; queue = queue->next)\n-    fixup_var_refs (queue->modified, queue->promoted_mode, queue->unsignedp);\n+    fixup_var_refs (queue->modified, queue->promoted_mode,\n+\t\t    queue->unsignedp, 0);\n \n   free (p);\n \n@@ -1569,8 +1589,8 @@ put_var_into_stack (decl)\n \tput_reg_into_stack (function, reg, TREE_TYPE (decl),\n \t\t\t    promoted_mode, decl_mode,\n \t\t\t    TREE_SIDE_EFFECTS (decl), 0,\n-\t\t\t    TREE_USED (decl)\n-\t\t\t    || DECL_INITIAL (decl) != 0);\n+\t\t\t    TREE_USED (decl) || DECL_INITIAL (decl) != 0,\n+\t\t\t    0);\n     }\n   else if (GET_CODE (reg) == CONCAT)\n     {\n@@ -1582,17 +1602,21 @@ put_var_into_stack (decl)\n       /* Since part 0 should have a lower address, do it second.  */\n       put_reg_into_stack (function, XEXP (reg, 1), part_type, part_mode,\n \t\t\t  part_mode, TREE_SIDE_EFFECTS (decl), 0,\n-\t\t\t  TREE_USED (decl) || DECL_INITIAL (decl) != 0);\n+\t\t\t  TREE_USED (decl) || DECL_INITIAL (decl) != 0,\n+\t\t\t  0);\n       put_reg_into_stack (function, XEXP (reg, 0), part_type, part_mode,\n \t\t\t  part_mode, TREE_SIDE_EFFECTS (decl), 0,\n-\t\t\t  TREE_USED (decl) || DECL_INITIAL (decl) != 0);\n+\t\t\t  TREE_USED (decl) || DECL_INITIAL (decl) != 0,\n+\t\t\t  0);\n #else\n       put_reg_into_stack (function, XEXP (reg, 0), part_type, part_mode,\n \t\t\t  part_mode, TREE_SIDE_EFFECTS (decl), 0,\n-\t\t\t  TREE_USED (decl) || DECL_INITIAL (decl) != 0);\n+\t\t\t  TREE_USED (decl) || DECL_INITIAL (decl) != 0,\n+\t\t\t  0);\n       put_reg_into_stack (function, XEXP (reg, 1), part_type, part_mode,\n \t\t\t  part_mode, TREE_SIDE_EFFECTS (decl), 0,\n-\t\t\t  TREE_USED (decl) || DECL_INITIAL (decl) != 0);\n+\t\t\t  TREE_USED (decl) || DECL_INITIAL (decl) != 0,\n+\t\t\t  0);\n #endif\n \n       /* Change the CONCAT into a combined MEM for both parts.  */\n@@ -1628,14 +1652,15 @@ put_var_into_stack (decl)\n \n static void\n put_reg_into_stack (function, reg, type, promoted_mode, decl_mode, volatile_p,\n-\t\t    original_regno, used_p)\n+\t\t    original_regno, used_p, ht)\n      struct function *function;\n      rtx reg;\n      tree type;\n      enum machine_mode promoted_mode, decl_mode;\n      int volatile_p;\n      int original_regno;\n      int used_p;\n+     struct hash_table *ht;\n {\n   rtx new = 0;\n   int regno = original_regno;\n@@ -1698,29 +1723,34 @@ put_reg_into_stack (function, reg, type, promoted_mode, decl_mode, volatile_p,\n     }\n   else if (used_p)\n     /* Variable is local; fix it up now.  */\n-    fixup_var_refs (reg, promoted_mode, TREE_UNSIGNED (type));\n+    fixup_var_refs (reg, promoted_mode, TREE_UNSIGNED (type), ht);\n }\n \f\n static void\n-fixup_var_refs (var, promoted_mode, unsignedp)\n+fixup_var_refs (var, promoted_mode, unsignedp, ht)\n      rtx var;\n      enum machine_mode promoted_mode;\n      int unsignedp;\n+     struct hash_table *ht;\n {\n   tree pending;\n   rtx first_insn = get_insns ();\n   struct sequence_stack *stack = sequence_stack;\n   tree rtl_exps = rtl_expr_chain;\n \n   /* Must scan all insns for stack-refs that exceed the limit.  */\n-  fixup_var_refs_insns (var, promoted_mode, unsignedp, first_insn, stack == 0);\n+  fixup_var_refs_insns (var, promoted_mode, unsignedp, first_insn, \n+\t\t\tstack == 0, ht);\n+  /* If there's a hash table, it must record all uses of VAR.  */\n+  if (ht)\n+    return;\n \n   /* Scan all pending sequences too.  */\n   for (; stack; stack = stack->next)\n     {\n       push_to_sequence (stack->first);\n       fixup_var_refs_insns (var, promoted_mode, unsignedp,\n-\t\t\t    stack->first, stack->next != 0);\n+\t\t\t    stack->first, stack->next != 0, 0);\n       /* Update remembered end of sequence\n \t in case we added an insn at the end.  */\n       stack->last = get_last_insn ();\n@@ -1734,14 +1764,16 @@ fixup_var_refs (var, promoted_mode, unsignedp)\n       if (seq != const0_rtx && seq != 0)\n \t{\n \t  push_to_sequence (seq);\n-\t  fixup_var_refs_insns (var, promoted_mode, unsignedp, seq, 0);\n+\t  fixup_var_refs_insns (var, promoted_mode, unsignedp, seq, 0,\n+\t\t\t\t0);\n \t  end_sequence ();\n \t}\n     }\n \n   /* Scan the catch clauses for exception handling too.  */\n   push_to_sequence (catch_clauses);\n-  fixup_var_refs_insns (var, promoted_mode, unsignedp, catch_clauses, 0);\n+  fixup_var_refs_insns (var, promoted_mode, unsignedp, catch_clauses,\n+\t\t\t0, 0);\n   end_sequence ();\n }\n \f\n@@ -1777,14 +1809,26 @@ find_fixup_replacement (replacements, x)\n    main chain of insns for the current function.  */\n \n static void\n-fixup_var_refs_insns (var, promoted_mode, unsignedp, insn, toplevel)\n+fixup_var_refs_insns (var, promoted_mode, unsignedp, insn, toplevel, ht)\n      rtx var;\n      enum machine_mode promoted_mode;\n      int unsignedp;\n      rtx insn;\n      int toplevel;\n+     struct hash_table *ht;\n {\n   rtx call_dest = 0;\n+  rtx insn_list;\n+\n+  /* If we already know which INSNs reference VAR there's no need\n+     to walk the entire instruction chain.  */\n+  if (ht)\n+    {\n+      insn_list = ((struct insns_for_mem_entry *) \n+\t\t   hash_lookup (ht, var, /*create=*/0, /*copy=*/0))->insns;\n+      insn = insn_list ? XEXP (insn_list, 0) : NULL_RTX;\n+      insn_list = XEXP (insn_list, 1);\n+    }\n \n   while (insn)\n     {\n@@ -1957,7 +2001,16 @@ fixup_var_refs_insns (var, promoted_mode, unsignedp, insn, toplevel)\n \t      XEXP (note, 0)\n \t\t= walk_fixup_memory_subreg (XEXP (note, 0), insn, 1);\n \t}\n-      insn = next;\n+\n+      if (!ht)\n+\tinsn = next;\n+      else if (insn_list)\n+\t{\n+\t  insn = XEXP (insn_list, 0);\n+\t  insn_list = XEXP (insn_list, 1);\n+\t}\n+      else\n+\tinsn = NULL_RTX;\n     }\n }\n \f\n@@ -2929,7 +2982,7 @@ gen_mem_addressof (reg, decl)\n   MEM_ALIAS_SET (reg) = get_alias_set (decl);\n \n   if (TREE_USED (decl) || DECL_INITIAL (decl) != 0)\n-    fixup_var_refs (reg, GET_MODE (reg), TREE_UNSIGNED (type));\n+    fixup_var_refs (reg, GET_MODE (reg), TREE_UNSIGNED (type), 0);\n \n   return reg;\n }\n@@ -2945,14 +2998,15 @@ flush_addressof (decl)\n       && GET_CODE (DECL_RTL (decl)) == MEM\n       && GET_CODE (XEXP (DECL_RTL (decl), 0)) == ADDRESSOF\n       && GET_CODE (XEXP (XEXP (DECL_RTL (decl), 0), 0)) == REG)\n-    put_addressof_into_stack (XEXP (DECL_RTL (decl), 0));\n+    put_addressof_into_stack (XEXP (DECL_RTL (decl), 0), 0);\n }\n \n /* Force the register pointed to by R, an ADDRESSOF rtx, into the stack.  */\n \n static void\n-put_addressof_into_stack (r)\n+put_addressof_into_stack (r, ht)\n      rtx r;\n+     struct hash_table *ht;\n {\n   tree decl = ADDRESSOF_DECL (r);\n   rtx reg = XEXP (r, 0);\n@@ -2963,7 +3017,7 @@ put_addressof_into_stack (r)\n   put_reg_into_stack (0, reg, TREE_TYPE (decl), GET_MODE (reg),\n \t\t      DECL_MODE (decl), TREE_SIDE_EFFECTS (decl),\n \t\t      ADDRESSOF_REGNO (r),\n-\t\t      TREE_USED (decl) || DECL_INITIAL (decl) != 0);\n+\t\t      TREE_USED (decl) || DECL_INITIAL (decl) != 0, ht);\n }\n \n /* List of replacements made below in purge_addressof_1 when creating\n@@ -2975,10 +3029,11 @@ static rtx purge_addressof_replacements;\n    the stack.  */\n \n static void\n-purge_addressof_1 (loc, insn, force, store)\n+purge_addressof_1 (loc, insn, force, store, ht)\n      rtx *loc;\n      rtx insn;\n      int force, store;\n+     struct hash_table *ht;\n {\n   rtx x;\n   RTX_CODE code;\n@@ -3032,7 +3087,7 @@ purge_addressof_1 (loc, insn, force, store)\n       if (GET_CODE (sub) == REG\n \t  && (MEM_VOLATILE_P (x) || GET_MODE (x) == BLKmode))\n \t{\n-\t  put_addressof_into_stack (XEXP (x, 0));\n+\t  put_addressof_into_stack (XEXP (x, 0), ht);\n \t  return;\n \t}\n       else if (GET_CODE (sub) == REG && GET_MODE (x) != GET_MODE (sub))\n@@ -3111,7 +3166,7 @@ purge_addressof_1 (loc, insn, force, store)\n \n \t      if (store)\n \t\t{\n-\t\t  rtx p;\n+\t\t  rtx p = PREV_INSN (insn);\n \n \t\t  start_sequence ();\n \t\t  val = gen_reg_rtx (GET_MODE (x));\n@@ -3125,6 +3180,8 @@ purge_addressof_1 (loc, insn, force, store)\n \t\t  seq = gen_sequence ();\n \t\t  end_sequence ();\n \t\t  emit_insn_before (seq, insn);\n+\t\t  compute_insns_for_mem (p ? NEXT_INSN (p) : get_insns (), \n+\t\t\t\t\t insn, ht);\n \t      \n \t\t  start_sequence ();\n \t\t  store_bit_field (sub, size_x, 0, GET_MODE (x),\n@@ -3143,10 +3200,16 @@ purge_addressof_1 (loc, insn, force, store)\n \n \t\t  seq = gen_sequence ();\n \t\t  end_sequence ();\n-\t\t  emit_insn_after (seq, insn);\n+\t\t  p = emit_insn_after (seq, insn);\n+\t\t  if (NEXT_INSN (insn))\n+\t\t    compute_insns_for_mem (NEXT_INSN (insn), \n+\t\t\t\t\t   p ? NEXT_INSN (p) : NULL_RTX,\n+\t\t\t\t\t   ht);\n \t\t}\n \t      else\n \t\t{\n+\t\t  rtx p = PREV_INSN (insn);\n+\n \t\t  start_sequence ();\n \t\t  val = extract_bit_field (sub, size_x, 0, 1, NULL_RTX,\n \t\t\t\t\t   GET_MODE (x), GET_MODE (x),\n@@ -3164,6 +3227,8 @@ purge_addressof_1 (loc, insn, force, store)\n \t\t  seq = gen_sequence ();\n \t\t  end_sequence ();\n \t\t  emit_insn_before (seq, insn);\n+\t\t  compute_insns_for_mem (p ? NEXT_INSN (p) : get_insns (),\n+\t\t\t\t\t insn, ht);\n \t\t}\n \n \t      /* Remember the replacement so that the same one can be done\n@@ -3192,13 +3257,13 @@ purge_addressof_1 (loc, insn, force, store)\n     }\n   else if (code == ADDRESSOF)\n     {\n-      put_addressof_into_stack (x);\n+      put_addressof_into_stack (x, ht);\n       return;\n     }\n   else if (code == SET)\n     {\n-      purge_addressof_1 (&SET_DEST (x), insn, force, 1);\n-      purge_addressof_1 (&SET_SRC (x), insn, force, 0);\n+      purge_addressof_1 (&SET_DEST (x), insn, force, 1, ht);\n+      purge_addressof_1 (&SET_SRC (x), insn, force, 0, ht);\n       return;\n     }\n \n@@ -3207,13 +3272,130 @@ purge_addressof_1 (loc, insn, force, store)\n   for (i = 0; i < GET_RTX_LENGTH (code); i++, fmt++)\n     {\n       if (*fmt == 'e')\n-\tpurge_addressof_1 (&XEXP (x, i), insn, force, 0);\n+\tpurge_addressof_1 (&XEXP (x, i), insn, force, 0, ht);\n       else if (*fmt == 'E')\n \tfor (j = 0; j < XVECLEN (x, i); j++)\n-\t  purge_addressof_1 (&XVECEXP (x, i, j), insn, force, 0);\n+\t  purge_addressof_1 (&XVECEXP (x, i, j), insn, force, 0, ht);\n     }\n }\n \n+/* Return a new hash table entry in HT.  */\n+\n+static struct hash_entry *\n+insns_for_mem_newfunc (he, ht, k)\n+     struct hash_entry *he;\n+     struct hash_table *ht;\n+     hash_table_key k ATTRIBUTE_UNUSED;\n+{\n+  struct insns_for_mem_entry *ifmhe;\n+  if (he)\n+    return he;\n+\n+  ifmhe = ((struct insns_for_mem_entry *)\n+\t   hash_allocate (ht, sizeof (struct insns_for_mem_entry)));\n+  ifmhe->insns = NULL_RTX;\n+\n+  return &ifmhe->he;\n+}\n+\n+/* Return a hash value for K, a REG.  */\n+\n+static unsigned long\n+insns_for_mem_hash (k)\n+     hash_table_key k;\n+{\n+  /* K is really a RTX.  Just use the address as the hash value.  */\n+  return (unsigned long) k;\n+}\n+\n+/* Return non-zero if K1 and K2 (two REGs) are the same.  */\n+\n+static boolean\n+insns_for_mem_comp (k1, k2)\n+     hash_table_key k1;\n+     hash_table_key k2;\n+{\n+  return k1 == k2;\n+}\n+\n+struct insns_for_mem_walk_info {\n+  /* The hash table that we are using to record which INSNs use which\n+     MEMs.  */\n+  struct hash_table *ht;\n+\n+  /* The INSN we are currently proessing.  */\n+  rtx insn;\n+\n+  /* Zero if we are walking to find ADDRESSOFs, one if we are walking\n+     to find the insns that use the REGs in the ADDRESSOFs.  */\n+  int pass;\n+};\n+\n+/* Called from compute_insns_for_mem via for_each_rtx.  If R is a REG\n+   that might be used in an ADDRESSOF expression, record this INSN in\n+   the hash table given by DATA (which is really a pointer to an\n+   insns_for_mem_walk_info structure).  */\n+\n+static int\n+insns_for_mem_walk (r, data)\n+     rtx *r;\n+     void *data;\n+{\n+  struct insns_for_mem_walk_info *ifmwi \n+    = (struct insns_for_mem_walk_info *) data;\n+\n+  if (ifmwi->pass == 0 && *r && GET_CODE (*r) == ADDRESSOF\n+      && GET_CODE (XEXP (*r, 0)) == REG)\n+    hash_lookup (ifmwi->ht, XEXP (*r, 0), /*create=*/1, /*copy=*/0);\n+  else if (ifmwi->pass == 1 && *r && GET_CODE (*r) == REG)\n+    {\n+      /* Lookup this MEM in the hashtable, creating it if necessary.  */\n+      struct insns_for_mem_entry *ifme \n+\t= (struct insns_for_mem_entry *) hash_lookup (ifmwi->ht,\n+\t\t\t\t\t\t      *r,\n+\t\t\t\t\t\t      /*create=*/0,\n+\t\t\t\t\t\t      /*copy=*/0);\n+\n+      /* If we have not already recorded this INSN, do so now.  Since\n+\t we process the INSNs in order, we know that if we have\n+\t recorded it it must be at the front of the list.  */\n+      if (ifme && (!ifme->insns || XEXP (ifme->insns, 0) != ifmwi->insn))\n+\t{\n+\t  /* We do the allocation on the same obstack as is used for\n+\t     the hash table since this memory will not be used once\n+\t     the hash table is deallocated.  */\n+\t  push_obstacks (&ifmwi->ht->memory, &ifmwi->ht->memory);\n+\t  ifme->insns = gen_rtx_EXPR_LIST (VOIDmode, ifmwi->insn, \n+\t\t\t\t\t   ifme->insns);\n+\t  pop_obstacks ();\n+\t}\n+    }\n+\n+  return 0;\n+}\n+\n+/* Walk the INSNS, until we reach LAST_INSN, recording which INSNs use\n+   which REGs in HT.  */\n+\n+static void\n+compute_insns_for_mem (insns, last_insn, ht)\n+     rtx insns;\n+     rtx last_insn;\n+     struct hash_table *ht;\n+{\n+  rtx insn;\n+  struct insns_for_mem_walk_info ifmwi;\n+  ifmwi.ht = ht;\n+\n+  for (ifmwi.pass = 0; ifmwi.pass < 2; ++ifmwi.pass)\n+    for (insn = insns; insn != last_insn; insn = NEXT_INSN (insn))\n+      if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n+\t{\n+\t  ifmwi.insn = insn;\n+\t  for_each_rtx (&insn, insns_for_mem_walk, &ifmwi);\n+\t}\n+}\n+\n /* Eliminate all occurrences of ADDRESSOF from INSNS.  Elide any remaining\n    (MEM (ADDRESSOF)) patterns, and force any needed registers into the\n    stack.  */\n@@ -3223,14 +3405,32 @@ purge_addressof (insns)\n      rtx insns;\n {\n   rtx insn;\n+  struct hash_table ht;\n+  \n+  /* When we actually purge ADDRESSOFs, we turn REGs into MEMs.  That\n+     requires a fixup pass over the instruction stream to correct\n+     INSNs that depended on the REG being a REG, and not a MEM.  But,\n+     these fixup passes are slow.  Furthermore, more MEMs are not\n+     mentioned in very many instructions.  So, we speed up the process\n+     by pre-calculating which REGs occur in which INSNs; that allows\n+     us to perform the fixup passes much more quickly.  */\n+  hash_table_init (&ht, \n+\t\t   insns_for_mem_newfunc,\n+\t\t   insns_for_mem_hash,\n+\t\t   insns_for_mem_comp);\n+  compute_insns_for_mem (insns, NULL_RTX, &ht);\n+\n   for (insn = insns; insn; insn = NEXT_INSN (insn))\n     if (GET_CODE (insn) == INSN || GET_CODE (insn) == JUMP_INSN\n \t|| GET_CODE (insn) == CALL_INSN)\n       {\n \tpurge_addressof_1 (&PATTERN (insn), insn,\n-\t\t\t   asm_noperands (PATTERN (insn)) > 0, 0);\n-\tpurge_addressof_1 (&REG_NOTES (insn), NULL_RTX, 0, 0);\n+\t\t\t   asm_noperands (PATTERN (insn)) > 0, 0, &ht);\n+\tpurge_addressof_1 (&REG_NOTES (insn), NULL_RTX, 0, 0, &ht);\n       }\n+\n+  /* Clean up.  */\n+  hash_table_free (&ht);\n   purge_addressof_replacements = 0;\n }\n \f"}]}