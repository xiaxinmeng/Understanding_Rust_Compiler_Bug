{"sha": "eceef4c97d732ccfb2f0ec79de97a7bc0dcd8cf9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWNlZWY0Yzk3ZDczMmNjZmIyZjBlYzc5ZGU5N2E3YmMwZGNkOGNmOQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@cygnus.co.uk", "date": "1999-09-12T14:54:56Z"}, "committer": {"name": "Bernd Schmidt", "email": "crux@gcc.gnu.org", "date": "1999-09-12T14:54:56Z"}, "message": "Use structures not many single arrays in reload\n\nFrom-SVN: r29361", "tree": {"sha": "c5ffa463c9210527c5739df54d4984f7c00c2592", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c5ffa463c9210527c5739df54d4984f7c00c2592"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eceef4c97d732ccfb2f0ec79de97a7bc0dcd8cf9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eceef4c97d732ccfb2f0ec79de97a7bc0dcd8cf9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eceef4c97d732ccfb2f0ec79de97a7bc0dcd8cf9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eceef4c97d732ccfb2f0ec79de97a7bc0dcd8cf9/comments", "author": null, "committer": null, "parents": [{"sha": "c2a37c55a60d12c57d149275d78418e02182fd70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2a37c55a60d12c57d149275d78418e02182fd70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2a37c55a60d12c57d149275d78418e02182fd70"}], "stats": {"total": 1801, "additions": 899, "deletions": 902}, "files": [{"sha": "456b09b5deb6155410c9506bd88107495eaae43d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eceef4c97d732ccfb2f0ec79de97a7bc0dcd8cf9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eceef4c97d732ccfb2f0ec79de97a7bc0dcd8cf9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=eceef4c97d732ccfb2f0ec79de97a7bc0dcd8cf9", "patch": "@@ -1,3 +1,26 @@\n+Sun Sep 12 15:53:20 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n+\n+\t* reload.h (reload_in, reload_out, reload_in_reg, reload_out_reg,\n+\treload_reg_class, reload_inmode, reload_outmode, reload_optional,\n+\treload_nongroup, reload_inc, reload_opnum, reload_secondary_p,\n+\treload_secondary_in_reload, reload_secondary_out_reload,\n+\treload_secondary_in_icode, reload_secondary_out_icode,\n+\treload_reg_rtx, reload_when_needed): Delete declarations.\n+\t(struct reload): New structure.\n+\t(rld): Declare new array.\n+\t* reload.c (reload_in, reload_out, reload_in_reg, reload_out_reg,\n+\treload_reg_class, reload_inmode, reload_outmode, reload_optional,\n+\treload_nongroup, reload_inc, reload_opnum, reload_secondary_p,\n+\treload_secondary_in_reload, reload_secondary_out_reload,\n+\treload_secondary_in_icode, reload_secondary_out_icode,\n+\treload_reg_rtx, reload_when_needed): Delete definitions.\n+\t(rld): New array.\n+\t(whole file): Replace uses of the deleted arrays with uses of rld.\n+\t* reload1.c (whole file): Replace uses of the deleted arrays with\n+\tuses of rld.\n+\t(choose_reload_regs): Copy in/out of save_reload_reg_rtx with\n+\texplicit loops, not with bcopy.\n+\n Sun Sep 12 05:00:24 1999  Richard Henderson  <rth@cygnus.com>\n \n \t* recog.h (insn_template, insn_outfun, insn_n_operands, insn_n_dups,"}, {"sha": "98345bf247ce15bd6d542f17efb9d2bd92372c97", "filename": "gcc/reload.c", "status": "modified", "additions": 383, "deletions": 457, "changes": 840, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eceef4c97d732ccfb2f0ec79de97a7bc0dcd8cf9/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eceef4c97d732ccfb2f0ec79de97a7bc0dcd8cf9/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=eceef4c97d732ccfb2f0ec79de97a7bc0dcd8cf9", "patch": "@@ -115,82 +115,10 @@ a register with any other reload.  */\n #define REG_MODE_OK_FOR_BASE_P(REGNO, MODE) REG_OK_FOR_BASE_P (REGNO)\n #endif\n \f\n-/* The variables set up by `find_reloads' are:\n-\n-   n_reloads\t\t  number of distinct reloads needed; max reload # + 1\n-       tables indexed by reload number\n-   reload_in\t\t  rtx for value to reload from\n-   reload_out\t\t  rtx for where to store reload-reg afterward if nec\n-\t\t\t   (often the same as reload_in)\n-   reload_reg_class\t  enum reg_class, saying what regs to reload into\n-   reload_inmode\t  enum machine_mode; mode this operand should have\n-\t\t\t   when reloaded, on input.\n-   reload_outmode\t  enum machine_mode; mode this operand should have\n-\t\t\t   when reloaded, on output.\n-   reload_optional\t  char, nonzero for an optional reload.\n-\t\t\t   Optional reloads are ignored unless the\n-\t\t\t   value is already sitting in a register.\n-   reload_nongroup\t  char, nonzero when a reload must use a register\n-\t\t\t   not already allocated to a group.\n-   reload_inc\t\t  int, positive amount to increment or decrement by if\n-\t\t\t   reload_in is a PRE_DEC, PRE_INC, POST_DEC, POST_INC.\n-\t\t\t   Ignored otherwise (don't assume it is zero).\n-   reload_in_reg\t  rtx.  A reg for which reload_in is the equivalent.\n-\t\t\t   If reload_in is a symbol_ref which came from\n-\t\t\t   reg_equiv_constant, then this is the pseudo\n-\t\t\t   which has that symbol_ref as equivalent.\n-   reload_reg_rtx\t  rtx.  This is the register to reload into.\n-\t\t\t   If it is zero when `find_reloads' returns,\n-\t\t\t   you must find a suitable register in the class\n-\t\t\t   specified by reload_reg_class, and store here\n-\t\t\t   an rtx for that register with mode from\n-\t\t\t   reload_inmode or reload_outmode.\n-   reload_nocombine\t  char, nonzero if this reload shouldn't be\n-\t\t\t   combined with another reload.\n-   reload_opnum\t\t  int, operand number being reloaded.  This is\n-\t\t\t   used to group related reloads and need not always\n-\t\t\t   be equal to the actual operand number in the insn,\n-\t\t\t   though it current will be; for in-out operands, it\n-\t\t\t   is one of the two operand numbers.\n-   reload_when_needed    enum, classifies reload as needed either for\n-\t\t\t   addressing an input reload, addressing an output,\n-\t\t\t   for addressing a non-reloaded mem ref,\n-\t\t\t   or for unspecified purposes (i.e., more than one\n-\t\t\t   of the above).\n-   reload_secondary_p\t  int, 1 if this is a secondary register for one\n-\t\t\t   or more reloads.\n-   reload_secondary_in_reload\n-   reload_secondary_out_reload\n-\t\t\t  int, gives the reload number of a secondary\n-\t\t\t   reload, when needed; otherwise -1\n-   reload_secondary_in_icode\n-   reload_secondary_out_icode\n-\t\t\t  enum insn_code, if a secondary reload is required,\n-\t\t\t   gives the INSN_CODE that uses the secondary\n-\t\t\t   reload as a scratch register, or CODE_FOR_nothing\n-\t\t\t   if the secondary reload register is to be an\n-\t\t\t   intermediate register.  */\n+/* All reloads of the current insn are recorded here.  See reload.h for\n+   comments.  */\n int n_reloads;\n-\n-rtx reload_in[MAX_RELOADS];\n-rtx reload_out[MAX_RELOADS];\n-enum reg_class reload_reg_class[MAX_RELOADS];\n-enum machine_mode reload_inmode[MAX_RELOADS];\n-enum machine_mode reload_outmode[MAX_RELOADS];\n-rtx reload_reg_rtx[MAX_RELOADS];\n-char reload_optional[MAX_RELOADS];\n-char reload_nongroup[MAX_RELOADS];\n-int reload_inc[MAX_RELOADS];\n-rtx reload_in_reg[MAX_RELOADS];\n-rtx reload_out_reg[MAX_RELOADS];\n-char reload_nocombine[MAX_RELOADS];\n-int reload_opnum[MAX_RELOADS];\n-enum reload_type reload_when_needed[MAX_RELOADS];\n-int reload_secondary_p[MAX_RELOADS];\n-int reload_secondary_in_reload[MAX_RELOADS];\n-int reload_secondary_out_reload[MAX_RELOADS];\n-enum insn_code reload_secondary_in_icode[MAX_RELOADS];\n-enum insn_code reload_secondary_out_icode[MAX_RELOADS];\n+struct reload rld[MAX_RELOADS];\n \n /* All the \"earlyclobber\" operands of the current insn\n    are recorded here.  */\n@@ -496,92 +424,92 @@ push_secondary_reload (in_p, x, opnum, optional, reload_class, reload_mode,\n   if (t_class != NO_REGS)\n     {\n       for (t_reload = 0; t_reload < n_reloads; t_reload++)\n-\tif (reload_secondary_p[t_reload]\n-\t    && (reg_class_subset_p (t_class, reload_reg_class[t_reload])\n-\t\t|| reg_class_subset_p (reload_reg_class[t_reload], t_class))\n-\t    && ((in_p && reload_inmode[t_reload] == t_mode)\n-\t\t|| (! in_p && reload_outmode[t_reload] == t_mode))\n-\t    && ((in_p && (reload_secondary_in_icode[t_reload]\n+\tif (rld[t_reload].secondary_p\n+\t    && (reg_class_subset_p (t_class, rld[t_reload].class)\n+\t\t|| reg_class_subset_p (rld[t_reload].class, t_class))\n+\t    && ((in_p && rld[t_reload].inmode == t_mode)\n+\t\t|| (! in_p && rld[t_reload].outmode == t_mode))\n+\t    && ((in_p && (rld[t_reload].secondary_in_icode\n \t\t\t  == CODE_FOR_nothing))\n-\t\t|| (! in_p &&(reload_secondary_out_icode[t_reload]\n+\t\t|| (! in_p &&(rld[t_reload].secondary_out_icode\n \t\t\t      == CODE_FOR_nothing)))\n \t    && (reg_class_size[(int) t_class] == 1 || SMALL_REGISTER_CLASSES)\n \t    && MERGABLE_RELOADS (secondary_type,\n-\t\t\t\t reload_when_needed[t_reload],\n-\t\t\t\t opnum, reload_opnum[t_reload]))\n+\t\t\t\t rld[t_reload].when_needed,\n+\t\t\t\t opnum, rld[t_reload].opnum))\n \t  {\n \t    if (in_p)\n-\t      reload_inmode[t_reload] = t_mode;\n+\t      rld[t_reload].inmode = t_mode;\n \t    if (! in_p)\n-\t      reload_outmode[t_reload] = t_mode;\n+\t      rld[t_reload].outmode = t_mode;\n \n-\t    if (reg_class_subset_p (t_class, reload_reg_class[t_reload]))\n-\t      reload_reg_class[t_reload] = t_class;\n+\t    if (reg_class_subset_p (t_class, rld[t_reload].class))\n+\t      rld[t_reload].class = t_class;\n \n-\t    reload_opnum[t_reload] = MIN (reload_opnum[t_reload], opnum);\n-\t    reload_optional[t_reload] &= optional;\n-\t    reload_secondary_p[t_reload] = 1;\n-\t    if (MERGE_TO_OTHER (secondary_type, reload_when_needed[t_reload],\n-\t\t\t\topnum, reload_opnum[t_reload]))\n-\t      reload_when_needed[t_reload] = RELOAD_OTHER;\n+\t    rld[t_reload].opnum = MIN (rld[t_reload].opnum, opnum);\n+\t    rld[t_reload].optional &= optional;\n+\t    rld[t_reload].secondary_p = 1;\n+\t    if (MERGE_TO_OTHER (secondary_type, rld[t_reload].when_needed,\n+\t\t\t\topnum, rld[t_reload].opnum))\n+\t      rld[t_reload].when_needed = RELOAD_OTHER;\n \t  }\n \n       if (t_reload == n_reloads)\n \t{\n \t  /* We need to make a new tertiary reload for this register class.  */\n-\t  reload_in[t_reload] = reload_out[t_reload] = 0;\n-\t  reload_reg_class[t_reload] = t_class;\n-\t  reload_inmode[t_reload] = in_p ? t_mode : VOIDmode;\n-\t  reload_outmode[t_reload] = ! in_p ? t_mode : VOIDmode;\n-\t  reload_reg_rtx[t_reload] = 0;\n-\t  reload_optional[t_reload] = optional;\n-\t  reload_nongroup[t_reload] = 0;\n-\t  reload_inc[t_reload] = 0;\n+\t  rld[t_reload].in = rld[t_reload].out = 0;\n+\t  rld[t_reload].class = t_class;\n+\t  rld[t_reload].inmode = in_p ? t_mode : VOIDmode;\n+\t  rld[t_reload].outmode = ! in_p ? t_mode : VOIDmode;\n+\t  rld[t_reload].reg_rtx = 0;\n+\t  rld[t_reload].optional = optional;\n+\t  rld[t_reload].nongroup = 0;\n+\t  rld[t_reload].inc = 0;\n \t  /* Maybe we could combine these, but it seems too tricky.  */\n-\t  reload_nocombine[t_reload] = 1;\n-\t  reload_in_reg[t_reload] = 0;\n-\t  reload_out_reg[t_reload] = 0;\n-\t  reload_opnum[t_reload] = opnum;\n-\t  reload_when_needed[t_reload] = secondary_type;\n-\t  reload_secondary_in_reload[t_reload] = -1;\n-\t  reload_secondary_out_reload[t_reload] = -1;\n-\t  reload_secondary_in_icode[t_reload] = CODE_FOR_nothing;\n-\t  reload_secondary_out_icode[t_reload] = CODE_FOR_nothing;\n-\t  reload_secondary_p[t_reload] = 1;\n+\t  rld[t_reload].nocombine = 1;\n+\t  rld[t_reload].in_reg = 0;\n+\t  rld[t_reload].out_reg = 0;\n+\t  rld[t_reload].opnum = opnum;\n+\t  rld[t_reload].when_needed = secondary_type;\n+\t  rld[t_reload].secondary_in_reload = -1;\n+\t  rld[t_reload].secondary_out_reload = -1;\n+\t  rld[t_reload].secondary_in_icode = CODE_FOR_nothing;\n+\t  rld[t_reload].secondary_out_icode = CODE_FOR_nothing;\n+\t  rld[t_reload].secondary_p = 1;\n \n \t  n_reloads++;\n \t}\n     }\n \n   /* See if we can reuse an existing secondary reload.  */\n   for (s_reload = 0; s_reload < n_reloads; s_reload++)\n-    if (reload_secondary_p[s_reload]\n-\t&& (reg_class_subset_p (class, reload_reg_class[s_reload])\n-\t    || reg_class_subset_p (reload_reg_class[s_reload], class))\n-\t&& ((in_p && reload_inmode[s_reload] == mode)\n-\t    || (! in_p && reload_outmode[s_reload] == mode))\n-\t&& ((in_p && reload_secondary_in_reload[s_reload] == t_reload)\n-\t    || (! in_p && reload_secondary_out_reload[s_reload] == t_reload))\n-\t&& ((in_p && reload_secondary_in_icode[s_reload] == t_icode)\n-\t    || (! in_p && reload_secondary_out_icode[s_reload] == t_icode))\n+    if (rld[s_reload].secondary_p\n+\t&& (reg_class_subset_p (class, rld[s_reload].class)\n+\t    || reg_class_subset_p (rld[s_reload].class, class))\n+\t&& ((in_p && rld[s_reload].inmode == mode)\n+\t    || (! in_p && rld[s_reload].outmode == mode))\n+\t&& ((in_p && rld[s_reload].secondary_in_reload == t_reload)\n+\t    || (! in_p && rld[s_reload].secondary_out_reload == t_reload))\n+\t&& ((in_p && rld[s_reload].secondary_in_icode == t_icode)\n+\t    || (! in_p && rld[s_reload].secondary_out_icode == t_icode))\n \t&& (reg_class_size[(int) class] == 1 || SMALL_REGISTER_CLASSES)\n-\t&& MERGABLE_RELOADS (secondary_type, reload_when_needed[s_reload],\n-\t\t\t     opnum, reload_opnum[s_reload]))\n+\t&& MERGABLE_RELOADS (secondary_type, rld[s_reload].when_needed,\n+\t\t\t     opnum, rld[s_reload].opnum))\n       {\n \tif (in_p)\n-\t  reload_inmode[s_reload] = mode;\n+\t  rld[s_reload].inmode = mode;\n \tif (! in_p)\n-\t  reload_outmode[s_reload] = mode;\n+\t  rld[s_reload].outmode = mode;\n \n-\tif (reg_class_subset_p (class, reload_reg_class[s_reload]))\n-\t  reload_reg_class[s_reload] = class;\n+\tif (reg_class_subset_p (class, rld[s_reload].class))\n+\t  rld[s_reload].class = class;\n \n-\treload_opnum[s_reload] = MIN (reload_opnum[s_reload], opnum);\n-\treload_optional[s_reload] &= optional;\n-\treload_secondary_p[s_reload] = 1;\n-\tif (MERGE_TO_OTHER (secondary_type, reload_when_needed[s_reload],\n-\t\t\t    opnum, reload_opnum[s_reload]))\n-\t  reload_when_needed[s_reload] = RELOAD_OTHER;\n+\trld[s_reload].opnum = MIN (rld[s_reload].opnum, opnum);\n+\trld[s_reload].optional &= optional;\n+\trld[s_reload].secondary_p = 1;\n+\tif (MERGE_TO_OTHER (secondary_type, rld[s_reload].when_needed,\n+\t\t\t    opnum, rld[s_reload].opnum))\n+\t  rld[s_reload].when_needed = RELOAD_OTHER;\n       }\n \n   if (s_reload == n_reloads)\n@@ -598,27 +526,27 @@ push_secondary_reload (in_p, x, opnum, optional, reload_class, reload_mode,\n #endif\n \n       /* We need to make a new secondary reload for this register class.  */\n-      reload_in[s_reload] = reload_out[s_reload] = 0;\n-      reload_reg_class[s_reload] = class;\n-\n-      reload_inmode[s_reload] = in_p ? mode : VOIDmode;\n-      reload_outmode[s_reload] = ! in_p ? mode : VOIDmode;\n-      reload_reg_rtx[s_reload] = 0;\n-      reload_optional[s_reload] = optional;\n-      reload_nongroup[s_reload] = 0;\n-      reload_inc[s_reload] = 0;\n+      rld[s_reload].in = rld[s_reload].out = 0;\n+      rld[s_reload].class = class;\n+\n+      rld[s_reload].inmode = in_p ? mode : VOIDmode;\n+      rld[s_reload].outmode = ! in_p ? mode : VOIDmode;\n+      rld[s_reload].reg_rtx = 0;\n+      rld[s_reload].optional = optional;\n+      rld[s_reload].nongroup = 0;\n+      rld[s_reload].inc = 0;\n       /* Maybe we could combine these, but it seems too tricky.  */\n-      reload_nocombine[s_reload] = 1;\n-      reload_in_reg[s_reload] = 0;\n-      reload_out_reg[s_reload] = 0;\n-      reload_opnum[s_reload] = opnum;\n-      reload_when_needed[s_reload] = secondary_type;\n-      reload_secondary_in_reload[s_reload] = in_p ? t_reload : -1;\n-      reload_secondary_out_reload[s_reload] = ! in_p ? t_reload : -1;\n-      reload_secondary_in_icode[s_reload] = in_p ? t_icode : CODE_FOR_nothing;\n-      reload_secondary_out_icode[s_reload]\n+      rld[s_reload].nocombine = 1;\n+      rld[s_reload].in_reg = 0;\n+      rld[s_reload].out_reg = 0;\n+      rld[s_reload].opnum = opnum;\n+      rld[s_reload].when_needed = secondary_type;\n+      rld[s_reload].secondary_in_reload = in_p ? t_reload : -1;\n+      rld[s_reload].secondary_out_reload = ! in_p ? t_reload : -1;\n+      rld[s_reload].secondary_in_icode = in_p ? t_icode : CODE_FOR_nothing;\n+      rld[s_reload].secondary_out_icode\n \t= ! in_p ? t_icode : CODE_FOR_nothing;\n-      reload_secondary_p[s_reload] = 1;\n+      rld[s_reload].secondary_p = 1;\n \n       n_reloads++;\n \n@@ -783,21 +711,19 @@ find_reusable_reload (p_in, out, class, type, opnum, dont_share)\n      than we otherwise would.  */\n \n   for (i = 0; i < n_reloads; i++)\n-    if ((reg_class_subset_p (class, reload_reg_class[i])\n-\t || reg_class_subset_p (reload_reg_class[i], class))\n+    if ((reg_class_subset_p (class, rld[i].class)\n+\t || reg_class_subset_p (rld[i].class, class))\n \t/* If the existing reload has a register, it must fit our class.  */\n-\t&& (reload_reg_rtx[i] == 0\n+\t&& (rld[i].reg_rtx == 0\n \t    || TEST_HARD_REG_BIT (reg_class_contents[(int) class],\n-\t\t\t\t  true_regnum (reload_reg_rtx[i])))\n-\t&& ((in != 0 && MATCHES (reload_in[i], in) && ! dont_share\n-\t     && (out == 0 || reload_out[i] == 0 || MATCHES (reload_out[i], out)))\n-\t    ||\n-\t    (out != 0 && MATCHES (reload_out[i], out)\n-\t     && (in == 0 || reload_in[i] == 0 || MATCHES (reload_in[i], in))))\n-\t&& (reload_out[i] == 0 || ! earlyclobber_operand_p (reload_out[i]))\n+\t\t\t\t  true_regnum (rld[i].reg_rtx)))\n+\t&& ((in != 0 && MATCHES (rld[i].in, in) && ! dont_share\n+\t     && (out == 0 || rld[i].out == 0 || MATCHES (rld[i].out, out)))\n+\t    || (out != 0 && MATCHES (rld[i].out, out)\n+\t\t&& (in == 0 || rld[i].in == 0 || MATCHES (rld[i].in, in))))\n+\t&& (rld[i].out == 0 || ! earlyclobber_operand_p (rld[i].out))\n \t&& (reg_class_size[(int) class] == 1 || SMALL_REGISTER_CLASSES)\n-\t&& MERGABLE_RELOADS (type, reload_when_needed[i],\n-\t\t\t     opnum, reload_opnum[i]))\n+\t&& MERGABLE_RELOADS (type, rld[i].when_needed, opnum, rld[i].opnum))\n       return i;\n \n   /* Reloading a plain reg for input can match a reload to postincrement\n@@ -806,36 +732,36 @@ find_reusable_reload (p_in, out, class, type, opnum, dont_share)\n      the preincrementation as happening before any ref in this insn\n      to that register.  */\n   for (i = 0; i < n_reloads; i++)\n-    if ((reg_class_subset_p (class, reload_reg_class[i])\n-\t || reg_class_subset_p (reload_reg_class[i], class))\n+    if ((reg_class_subset_p (class, rld[i].class)\n+\t || reg_class_subset_p (rld[i].class, class))\n \t/* If the existing reload has a register, it must fit our\n \t   class.  */\n-\t&& (reload_reg_rtx[i] == 0\n+\t&& (rld[i].reg_rtx == 0\n \t    || TEST_HARD_REG_BIT (reg_class_contents[(int) class],\n-\t\t\t\t  true_regnum (reload_reg_rtx[i])))\n-\t&& out == 0 && reload_out[i] == 0 && reload_in[i] != 0\n+\t\t\t\t  true_regnum (rld[i].reg_rtx)))\n+\t&& out == 0 && rld[i].out == 0 && rld[i].in != 0\n \t&& ((GET_CODE (in) == REG\n-\t     && (GET_CODE (reload_in[i]) == POST_INC\n-\t\t || GET_CODE (reload_in[i]) == POST_DEC\n-\t\t || GET_CODE (reload_in[i]) == PRE_INC\n-\t\t || GET_CODE (reload_in[i]) == PRE_DEC)\n-\t     && MATCHES (XEXP (reload_in[i], 0), in))\n+\t     && (GET_CODE (rld[i].in) == POST_INC\n+\t\t || GET_CODE (rld[i].in) == POST_DEC\n+\t\t || GET_CODE (rld[i].in) == PRE_INC\n+\t\t || GET_CODE (rld[i].in) == PRE_DEC)\n+\t     && MATCHES (XEXP (rld[i].in, 0), in))\n \t    ||\n-\t    (GET_CODE (reload_in[i]) == REG\n+\t    (GET_CODE (rld[i].in) == REG\n \t     && (GET_CODE (in) == POST_INC\n \t\t || GET_CODE (in) == POST_DEC\n \t\t || GET_CODE (in) == PRE_INC\n \t\t || GET_CODE (in) == PRE_DEC)\n-\t     && MATCHES (XEXP (in, 0), reload_in[i])))\n-\t&& (reload_out[i] == 0 || ! earlyclobber_operand_p (reload_out[i]))\n+\t     && MATCHES (XEXP (in, 0), rld[i].in)))\n+\t&& (rld[i].out == 0 || ! earlyclobber_operand_p (rld[i].out))\n \t&& (reg_class_size[(int) class] == 1 || SMALL_REGISTER_CLASSES)\n-\t&& MERGABLE_RELOADS (type, reload_when_needed[i],\n-\t\t\t     opnum, reload_opnum[i]))\n+\t&& MERGABLE_RELOADS (type, rld[i].when_needed,\n+\t\t\t     opnum, rld[i].opnum))\n       {\n \t/* Make sure reload_in ultimately has the increment,\n \t   not the plain register.  */\n \tif (GET_CODE (in) == REG)\n-\t  *p_in = reload_in[i];\n+\t  *p_in = rld[i].in;\n \treturn i;\n       }\n   return n_reloads;\n@@ -1311,25 +1237,25 @@ push_reload (in, out, inloc, outloc, class,\n #endif\n \n       i = n_reloads;\n-      reload_in[i] = in;\n-      reload_out[i] = out;\n-      reload_reg_class[i] = class;\n-      reload_inmode[i] = inmode;\n-      reload_outmode[i] = outmode;\n-      reload_reg_rtx[i] = 0;\n-      reload_optional[i] = optional;\n-      reload_nongroup[i] = 0;\n-      reload_inc[i] = 0;\n-      reload_nocombine[i] = 0;\n-      reload_in_reg[i] = inloc ? *inloc : 0;\n-      reload_out_reg[i] = outloc ? *outloc : 0;\n-      reload_opnum[i] = opnum;\n-      reload_when_needed[i] = type;\n-      reload_secondary_in_reload[i] = secondary_in_reload;\n-      reload_secondary_out_reload[i] = secondary_out_reload;\n-      reload_secondary_in_icode[i] = secondary_in_icode;\n-      reload_secondary_out_icode[i] = secondary_out_icode;\n-      reload_secondary_p[i] = 0;\n+      rld[i].in = in;\n+      rld[i].out = out;\n+      rld[i].class = class;\n+      rld[i].inmode = inmode;\n+      rld[i].outmode = outmode;\n+      rld[i].reg_rtx = 0;\n+      rld[i].optional = optional;\n+      rld[i].nongroup = 0;\n+      rld[i].inc = 0;\n+      rld[i].nocombine = 0;\n+      rld[i].in_reg = inloc ? *inloc : 0;\n+      rld[i].out_reg = outloc ? *outloc : 0;\n+      rld[i].opnum = opnum;\n+      rld[i].when_needed = type;\n+      rld[i].secondary_in_reload = secondary_in_reload;\n+      rld[i].secondary_out_reload = secondary_out_reload;\n+      rld[i].secondary_in_icode = secondary_in_icode;\n+      rld[i].secondary_out_icode = secondary_out_icode;\n+      rld[i].secondary_p = 0;\n \n       n_reloads++;\n \n@@ -1351,11 +1277,11 @@ push_reload (in, out, inloc, outloc, class,\n       /* The modes can be different.  If they are, we want to reload in\n \t the larger mode, so that the value is valid for both modes.  */\n       if (inmode != VOIDmode\n-\t  && GET_MODE_SIZE (inmode) > GET_MODE_SIZE (reload_inmode[i]))\n-\treload_inmode[i] = inmode;\n+\t  && GET_MODE_SIZE (inmode) > GET_MODE_SIZE (rld[i].inmode))\n+\trld[i].inmode = inmode;\n       if (outmode != VOIDmode\n-\t  && GET_MODE_SIZE (outmode) > GET_MODE_SIZE (reload_outmode[i]))\n-\treload_outmode[i] = outmode;\n+\t  && GET_MODE_SIZE (outmode) > GET_MODE_SIZE (rld[i].outmode))\n+\trld[i].outmode = outmode;\n       if (in != 0)\n \t{\n \t  rtx in_reg = inloc ? *inloc : 0;\n@@ -1373,43 +1299,43 @@ push_reload (in, out, inloc, outloc, class,\n \t     choose_reload_regs will remove the replacements for address\n \t     reloads of inherited reloads which results in the same\n \t     problem.  */\n-\t  if (reload_in[i] != in && rtx_equal_p (in, reload_in[i])\n-\t      && ! (reload_optional[i] && optional))\n+\t  if (rld[i].in != in && rtx_equal_p (in, rld[i].in)\n+\t      && ! (rld[i].optional && optional))\n \t    {\n \t      /* We must keep the address reload with the lower operand\n \t\t number alive.  */\n-\t      if (opnum > reload_opnum[i])\n+\t      if (opnum > rld[i].opnum)\n \t\t{\n \t\t  remove_address_replacements (in);\n-\t\t  in = reload_in[i];\n-\t\t  in_reg = reload_in_reg[i];\n+\t\t  in = rld[i].in;\n+\t\t  in_reg = rld[i].in_reg;\n \t\t}\n \t      else\n-\t\tremove_address_replacements (reload_in[i]);\n+\t\tremove_address_replacements (rld[i].in);\n \t    }\n-\t  reload_in[i] = in;\n-\t  reload_in_reg[i] = in_reg;\n+\t  rld[i].in = in;\n+\t  rld[i].in_reg = in_reg;\n \t}\n       if (out != 0)\n \t{\n-\t  reload_out[i] = out;\n-\t  reload_out_reg[i] = outloc ? *outloc : 0;\n+\t  rld[i].out = out;\n+\t  rld[i].out_reg = outloc ? *outloc : 0;\n \t}\n-      if (reg_class_subset_p (class, reload_reg_class[i]))\n-\treload_reg_class[i] = class;\n-      reload_optional[i] &= optional;\n-      if (MERGE_TO_OTHER (type, reload_when_needed[i],\n-\t\t\t  opnum, reload_opnum[i]))\n-\treload_when_needed[i] = RELOAD_OTHER;\n-      reload_opnum[i] = MIN (reload_opnum[i], opnum);\n+      if (reg_class_subset_p (class, rld[i].class))\n+\trld[i].class = class;\n+      rld[i].optional &= optional;\n+      if (MERGE_TO_OTHER (type, rld[i].when_needed,\n+\t\t\t  opnum, rld[i].opnum))\n+\trld[i].when_needed = RELOAD_OTHER;\n+      rld[i].opnum = MIN (rld[i].opnum, opnum);\n     }\n \n   /* If the ostensible rtx being reload differs from the rtx found\n      in the location to substitute, this reload is not safe to combine\n      because we cannot reliably tell whether it appears in the insn.  */\n \n   if (in != 0 && in != *inloc)\n-    reload_nocombine[i] = 1;\n+    rld[i].nocombine = 1;\n \n #if 0\n   /* This was replaced by changes in find_reloads_address_1 and the new\n@@ -1423,12 +1349,12 @@ push_reload (in, out, inloc, outloc, class,\n   if (out != 0 && sets_cc0_p (PATTERN (this_insn)))\n     {\n       out = 0;\n-      reload_out[i] = 0;\n-      reload_inc[i] = find_inc_amount (PATTERN (this_insn), in);\n+      rld[i].out = 0;\n+      rld[i].inc = find_inc_amount (PATTERN (this_insn), in);\n       /* If we did not find a nonzero amount-to-increment-by,\n \t that contradicts the belief that IN is being incremented\n \t in an address in this insn.  */\n-      if (reload_inc[i] == 0)\n+      if (rld[i].inc == 0)\n \tabort ();\n     }\n #endif\n@@ -1462,25 +1388,25 @@ push_reload (in, out, inloc, outloc, class,\n      supposed to be made to match, see if either one of the two\n      can serve as the place to reload into.\n \n-     If one of them is acceptable, set reload_reg_rtx[i]\n+     If one of them is acceptable, set rld[i].reg_rtx\n      to that one.  */\n \n-  if (in != 0 && out != 0 && in != out && reload_reg_rtx[i] == 0)\n+  if (in != 0 && out != 0 && in != out && rld[i].reg_rtx == 0)\n     {\n-      reload_reg_rtx[i] = find_dummy_reload (in, out, inloc, outloc,\n-\t\t\t\t\t     inmode, outmode,\n-\t\t\t\t\t     reload_reg_class[i], i,\n-\t\t\t\t\t     earlyclobber_operand_p (out));\n+      rld[i].reg_rtx = find_dummy_reload (in, out, inloc, outloc,\n+\t\t\t\t\t  inmode, outmode,\n+\t\t\t\t\t  rld[i].class, i,\n+\t\t\t\t\t  earlyclobber_operand_p (out));\n \n       /* If the outgoing register already contains the same value\n \t as the incoming one, we can dispense with loading it.\n \t The easiest way to tell the caller that is to give a phony\n \t value for the incoming operand (same as outgoing one).  */\n-      if (reload_reg_rtx[i] == out\n+      if (rld[i].reg_rtx == out\n \t  && (GET_CODE (in) == REG || CONSTANT_P (in))\n \t  && 0 != find_equiv_reg (in, this_insn, 0, REGNO (out),\n \t\t\t\t  static_reload_reg_p, i, inmode))\n-\treload_in[i] = out;\n+\trld[i].in = out;\n     }\n \n   /* If this is an input reload and the operand contains a register that\n@@ -1495,7 +1421,7 @@ push_reload (in, out, inloc, outloc, class,\n      But if there is no spilling in this block, that is OK.\n      An explicitly used hard reg cannot be a spill reg.  */\n \n-  if (reload_reg_rtx[i] == 0 && in != 0)\n+  if (rld[i].reg_rtx == 0 && in != 0)\n     {\n       rtx note;\n       int regno;\n@@ -1536,7 +1462,7 @@ push_reload (in, out, inloc, outloc, class,\n \t    && TEST_HARD_REG_BIT (reg_class_contents[(int) class], regno)\n \t    && !fixed_regs[regno])\n \t  {\n-\t    reload_reg_rtx[i] = gen_rtx_REG (inmode, regno);\n+\t    rld[i].reg_rtx = gen_rtx_REG (inmode, regno);\n \t    break;\n \t  }\n     }\n@@ -1614,8 +1540,8 @@ remove_address_replacements (in_rtx)\n       if (reload_flags[i] == 1)\n \t{\n \t  deallocate_reload_reg (i);\n-\t  remove_address_replacements (reload_in[i]);\n-\t  reload_in[i] = 0;\n+\t  remove_address_replacements (rld[i].in);\n+\t  rld[i].in = 0;\n \t  something_changed = 1;\n \t}\n     }\n@@ -1672,103 +1598,103 @@ combine_reloads ()\n      and that one is mandatory.  */\n \n   for (i = 0; i < n_reloads; i++)\n-    if (reload_out[i] != 0)\n+    if (rld[i].out != 0)\n       {\n \tif (output_reload >= 0)\n \t  return;\n \toutput_reload = i;\n       }\n \n-  if (output_reload < 0 || reload_optional[output_reload])\n+  if (output_reload < 0 || rld[output_reload].optional)\n     return;\n \n   /* An input-output reload isn't combinable.  */\n \n-  if (reload_in[output_reload] != 0)\n+  if (rld[output_reload].in != 0)\n     return;\n \n   /* If this reload is for an earlyclobber operand, we can't do anything.  */\n-  if (earlyclobber_operand_p (reload_out[output_reload]))\n+  if (earlyclobber_operand_p (rld[output_reload].out))\n     return;\n \n   /* Check each input reload; can we combine it?  */\n \n   for (i = 0; i < n_reloads; i++)\n-    if (reload_in[i] && ! reload_optional[i] && ! reload_nocombine[i]\n+    if (rld[i].in && ! rld[i].optional && ! rld[i].nocombine\n \t/* Life span of this reload must not extend past main insn.  */\n-\t&& reload_when_needed[i] != RELOAD_FOR_OUTPUT_ADDRESS\n-\t&& reload_when_needed[i] != RELOAD_FOR_OUTADDR_ADDRESS\n-\t&& reload_when_needed[i] != RELOAD_OTHER\n-\t&& (CLASS_MAX_NREGS (reload_reg_class[i], reload_inmode[i])\n-\t    == CLASS_MAX_NREGS (reload_reg_class[output_reload],\n-\t\t\t\treload_outmode[output_reload]))\n-\t&& reload_inc[i] == 0\n-\t&& reload_reg_rtx[i] == 0\n+\t&& rld[i].when_needed != RELOAD_FOR_OUTPUT_ADDRESS\n+\t&& rld[i].when_needed != RELOAD_FOR_OUTADDR_ADDRESS\n+\t&& rld[i].when_needed != RELOAD_OTHER\n+\t&& (CLASS_MAX_NREGS (rld[i].class, rld[i].inmode)\n+\t    == CLASS_MAX_NREGS (rld[output_reload].class,\n+\t\t\t\trld[output_reload].outmode))\n+\t&& rld[i].inc == 0\n+\t&& rld[i].reg_rtx == 0\n #ifdef SECONDARY_MEMORY_NEEDED\n \t/* Don't combine two reloads with different secondary\n \t   memory locations.  */\n-\t&& (secondary_memlocs_elim[(int) reload_outmode[output_reload]][reload_opnum[i]] == 0\n-\t    || secondary_memlocs_elim[(int) reload_outmode[output_reload]][reload_opnum[output_reload]] == 0\n-\t    || rtx_equal_p (secondary_memlocs_elim[(int) reload_outmode[output_reload]][reload_opnum[i]],\n-\t\t\t    secondary_memlocs_elim[(int) reload_outmode[output_reload]][reload_opnum[output_reload]]))\n+\t&& (secondary_memlocs_elim[(int) rld[output_reload].outmode][rld[i].opnum] == 0\n+\t    || secondary_memlocs_elim[(int) rld[output_reload].outmode][rld[output_reload].opnum] == 0\n+\t    || rtx_equal_p (secondary_memlocs_elim[(int) rld[output_reload].outmode][rld[i].opnum],\n+\t\t\t    secondary_memlocs_elim[(int) rld[output_reload].outmode][rld[output_reload].opnum]))\n #endif\n \t&& (SMALL_REGISTER_CLASSES\n-\t    ? (reload_reg_class[i] == reload_reg_class[output_reload])\n-\t    : (reg_class_subset_p (reload_reg_class[i],\n-\t\t\t\t   reload_reg_class[output_reload])\n-\t       || reg_class_subset_p (reload_reg_class[output_reload],\n-\t\t\t\t      reload_reg_class[i])))\n-\t&& (MATCHES (reload_in[i], reload_out[output_reload])\n+\t    ? (rld[i].class == rld[output_reload].class)\n+\t    : (reg_class_subset_p (rld[i].class,\n+\t\t\t\t   rld[output_reload].class)\n+\t       || reg_class_subset_p (rld[output_reload].class,\n+\t\t\t\t      rld[i].class)))\n+\t&& (MATCHES (rld[i].in, rld[output_reload].out)\n \t    /* Args reversed because the first arg seems to be\n \t       the one that we imagine being modified\n \t       while the second is the one that might be affected.  */\n-\t    || (! reg_overlap_mentioned_for_reload_p (reload_out[output_reload],\n-\t\t\t\t\t\t      reload_in[i])\n+\t    || (! reg_overlap_mentioned_for_reload_p (rld[output_reload].out,\n+\t\t\t\t\t\t      rld[i].in)\n \t\t/* However, if the input is a register that appears inside\n \t\t   the output, then we also can't share.\n \t\t   Imagine (set (mem (reg 69)) (plus (reg 69) ...)).\n \t\t   If the same reload reg is used for both reg 69 and the\n \t\t   result to be stored in memory, then that result\n \t\t   will clobber the address of the memory ref.  */\n-\t\t&& ! (GET_CODE (reload_in[i]) == REG\n-\t\t      && reg_overlap_mentioned_for_reload_p (reload_in[i],\n-\t\t\t\t\t\t\t     reload_out[output_reload]))))\n-\t&& (reg_class_size[(int) reload_reg_class[i]]\n+\t\t&& ! (GET_CODE (rld[i].in) == REG\n+\t\t      && reg_overlap_mentioned_for_reload_p (rld[i].in,\n+\t\t\t\t\t\t\t     rld[output_reload].out))))\n+\t&& (reg_class_size[(int) rld[i].class]\n \t    || SMALL_REGISTER_CLASSES)\n \t/* We will allow making things slightly worse by combining an\n \t   input and an output, but no worse than that.  */\n-\t&& (reload_when_needed[i] == RELOAD_FOR_INPUT\n-\t    || reload_when_needed[i] == RELOAD_FOR_OUTPUT))\n+\t&& (rld[i].when_needed == RELOAD_FOR_INPUT\n+\t    || rld[i].when_needed == RELOAD_FOR_OUTPUT))\n       {\n \tint j;\n \n \t/* We have found a reload to combine with!  */\n-\treload_out[i] = reload_out[output_reload];\n-\treload_out_reg[i] = reload_out_reg[output_reload];\n-\treload_outmode[i] = reload_outmode[output_reload];\n+\trld[i].out = rld[output_reload].out;\n+\trld[i].out_reg = rld[output_reload].out_reg;\n+\trld[i].outmode = rld[output_reload].outmode;\n \t/* Mark the old output reload as inoperative.  */\n-\treload_out[output_reload] = 0;\n+\trld[output_reload].out = 0;\n \t/* The combined reload is needed for the entire insn.  */\n-\treload_when_needed[i] = RELOAD_OTHER;\n+\trld[i].when_needed = RELOAD_OTHER;\n \t/* If the output reload had a secondary reload, copy it.  */\n-\tif (reload_secondary_out_reload[output_reload] != -1)\n+\tif (rld[output_reload].secondary_out_reload != -1)\n \t  {\n-\t    reload_secondary_out_reload[i]\n-\t      = reload_secondary_out_reload[output_reload];\n-\t    reload_secondary_out_icode[i]\n-\t      = reload_secondary_out_icode[output_reload];\n+\t    rld[i].secondary_out_reload\n+\t      = rld[output_reload].secondary_out_reload;\n+\t    rld[i].secondary_out_icode\n+\t      = rld[output_reload].secondary_out_icode;\n \t  }\n \n #ifdef SECONDARY_MEMORY_NEEDED\n \t/* Copy any secondary MEM.  */\n-\tif (secondary_memlocs_elim[(int) reload_outmode[output_reload]][reload_opnum[output_reload]] != 0)\n-\t  secondary_memlocs_elim[(int) reload_outmode[output_reload]][reload_opnum[i]]\n-\t    = secondary_memlocs_elim[(int) reload_outmode[output_reload]][reload_opnum[output_reload]];\n+\tif (secondary_memlocs_elim[(int) rld[output_reload].outmode][rld[output_reload].opnum] != 0)\n+\t  secondary_memlocs_elim[(int) rld[output_reload].outmode][rld[i].opnum]\n+\t    = secondary_memlocs_elim[(int) rld[output_reload].outmode][rld[output_reload].opnum];\n #endif\n \t/* If required, minimize the register class.  */\n-\tif (reg_class_subset_p (reload_reg_class[output_reload],\n-\t\t\t\treload_reg_class[i]))\n-\t  reload_reg_class[i] = reload_reg_class[output_reload];\n+\tif (reg_class_subset_p (rld[output_reload].class,\n+\t\t\t\trld[i].class))\n+\t  rld[i].class = rld[output_reload].class;\n \n \t/* Transfer all replacements from the old reload to the combined.  */\n \tfor (j = 0; j < n_replacements; j++)\n@@ -1799,27 +1725,27 @@ combine_reloads ()\n     if (REG_NOTE_KIND (note) == REG_DEAD\n \t&& GET_CODE (XEXP (note, 0)) == REG\n \t&& ! reg_overlap_mentioned_for_reload_p (XEXP (note, 0),\n-\t\t\t\t\t\t reload_out[output_reload])\n+\t\t\t\t\t\t rld[output_reload].out)\n \t&& REGNO (XEXP (note, 0)) < FIRST_PSEUDO_REGISTER\n-\t&& HARD_REGNO_MODE_OK (REGNO (XEXP (note, 0)), reload_outmode[output_reload])\n-\t&& TEST_HARD_REG_BIT (reg_class_contents[(int) reload_reg_class[output_reload]],\n+\t&& HARD_REGNO_MODE_OK (REGNO (XEXP (note, 0)), rld[output_reload].outmode)\n+\t&& TEST_HARD_REG_BIT (reg_class_contents[(int) rld[output_reload].class],\n \t\t\t      REGNO (XEXP (note, 0)))\n-\t&& (HARD_REGNO_NREGS (REGNO (XEXP (note, 0)), reload_outmode[output_reload])\n+\t&& (HARD_REGNO_NREGS (REGNO (XEXP (note, 0)), rld[output_reload].outmode)\n \t    <= HARD_REGNO_NREGS (REGNO (XEXP (note, 0)), GET_MODE (XEXP (note, 0))))\n \t/* Ensure that a secondary or tertiary reload for this output\n \t   won't want this register.  */\n-\t&& ((secondary_out = reload_secondary_out_reload[output_reload]) == -1\n+\t&& ((secondary_out = rld[output_reload].secondary_out_reload) == -1\n \t    || (! (TEST_HARD_REG_BIT\n-\t\t   (reg_class_contents[(int) reload_reg_class[secondary_out]],\n+\t\t   (reg_class_contents[(int) rld[secondary_out].class],\n \t\t    REGNO (XEXP (note, 0))))\n-\t\t&& ((secondary_out = reload_secondary_out_reload[secondary_out]) == -1\n+\t\t&& ((secondary_out = rld[secondary_out].secondary_out_reload) == -1\n \t\t    ||  ! (TEST_HARD_REG_BIT\n-\t\t\t   (reg_class_contents[(int) reload_reg_class[secondary_out]],\n+\t\t\t   (reg_class_contents[(int) rld[secondary_out].class],\n \t\t\t    REGNO (XEXP (note, 0)))))))\n \t&& ! fixed_regs[REGNO (XEXP (note, 0))])\n       {\n-\treload_reg_rtx[output_reload]\n-\t  = gen_rtx_REG (reload_outmode[output_reload],\n+\trld[output_reload].reg_rtx\n+\t  = gen_rtx_REG (rld[output_reload].outmode,\n \t\t\t REGNO (XEXP (note, 0)));\n \treturn;\n       }\n@@ -1835,7 +1761,7 @@ combine_reloads ()\n \n    If FOR_REAL is >= 0, it is the number of the reload,\n    and in some cases when it can be discovered that OUT doesn't need\n-   to be computed, clear out reload_out[FOR_REAL].\n+   to be computed, clear out rld[FOR_REAL].out.\n \n    If FOR_REAL is -1, this should not be done, because this call\n    is just to see if a register can be found, not to find and install it.\n@@ -1974,7 +1900,7 @@ find_dummy_reload (real_in, real_out, inloc, outloc,\n \t\t and changed our mind, it means OUT is a dummy that\n \t\t dies here.  So don't bother copying value to it.  */\n \t      if (for_real >= 0 && value == real_out)\n-\t\treload_out[for_real] = 0;\n+\t\trld[for_real].out = 0;\n \t      if (GET_CODE (real_in) == REG)\n \t\tvalue = real_in;\n \t      else\n@@ -2707,7 +2633,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t      && (set == 0 || &SET_DEST (set) != recog_data.operand_loc[i]))\n \t    {\n \t      /* Record the existing mode so that the check if constants are\n-\t\t allowed will work when operand_mode isn't specified. */\n+\t\t allowed will work when operand_mode isn't specified.  */\n \n \t      if (operand_mode[i] == VOIDmode)\n \t\toperand_mode[i] = GET_MODE (recog_data.operand[i]);\n@@ -2742,7 +2668,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n      \"no input reloads\" requirement for this insn.  */\n   if (no_input_reloads)\n     for (i = 0; i < n_reloads; i++)\n-      if (reload_in[i] != 0)\n+      if (rld[i].in != 0)\n \tabort ();\n #endif\n \n@@ -3576,10 +3502,10 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \n       for (i = 0; i < n_reloads; i++)\n \t{\n-\t  if (reload_opnum[i] == commutative)\n-\t    reload_opnum[i] = commutative + 1;\n-\t  else if (reload_opnum[i] == commutative + 1)\n-\t    reload_opnum[i] = commutative;\n+\t  if (rld[i].opnum == commutative)\n+\t    rld[i].opnum = commutative + 1;\n+\t  else if (rld[i].opnum == commutative + 1)\n+\t    rld[i].opnum = commutative;\n \t}\n     }\n \n@@ -3662,7 +3588,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t\t     BASE_REG_CLASS,\n \t\t\t     GET_MODE (XEXP (recog_data.operand[i], 0)),\n \t\t\t     VOIDmode, 0, 0, i, RELOAD_FOR_INPUT);\n-\t    reload_inc[operand_reloadnum[i]]\n+\t    rld[operand_reloadnum[i]].inc\n \t      = GET_MODE_SIZE (GET_MODE (recog_data.operand[i]));\n \n \t    /* If this operand is an output, we will have made any\n@@ -3674,13 +3600,13 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t      {\n \t\tfor (j = 0; j < n_reloads; j++)\n \t\t  {\n-\t\t    if (reload_opnum[j] == i)\n+\t\t    if (rld[j].opnum == i)\n \t\t      {\n-\t\t\tif (reload_when_needed[j] == RELOAD_FOR_OUTPUT_ADDRESS)\n-\t\t\t  reload_when_needed[j] = RELOAD_FOR_INPUT_ADDRESS;\n-\t\t\telse if (reload_when_needed[j]\n+\t\t\tif (rld[j].when_needed == RELOAD_FOR_OUTPUT_ADDRESS)\n+\t\t\t  rld[j].when_needed = RELOAD_FOR_INPUT_ADDRESS;\n+\t\t\telse if (rld[j].when_needed\n \t\t\t\t == RELOAD_FOR_OUTADDR_ADDRESS)\n-\t\t\t  reload_when_needed[j] = RELOAD_FOR_INPADDR_ADDRESS;\n+\t\t\t  rld[j].when_needed = RELOAD_FOR_INPADDR_ADDRESS;\n \t\t      }\n \t\t  }\n \t      }\n@@ -3908,18 +3834,18 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n      search for an existing equivalent reg (same value now) in the right class.\n      We can use it as long as we don't need to change its contents.  */\n   for (i = 0; i < n_reloads; i++)\n-    if (reload_reg_rtx[i] == 0\n-\t&& reload_in[i] != 0\n-\t&& GET_CODE (reload_in[i]) == REG\n-\t&& reload_out[i] == 0)\n+    if (rld[i].reg_rtx == 0\n+\t&& rld[i].in != 0\n+\t&& GET_CODE (rld[i].in) == REG\n+\t&& rld[i].out == 0)\n       {\n-\treload_reg_rtx[i]\n-\t  = find_equiv_reg (reload_in[i], insn, reload_reg_class[i], -1,\n-\t\t\t    static_reload_reg_p, 0, reload_inmode[i]);\n+\trld[i].reg_rtx\n+\t  = find_equiv_reg (rld[i].in, insn, rld[i].class, -1,\n+\t\t\t    static_reload_reg_p, 0, rld[i].inmode);\n \t/* Prevent generation of insn to load the value\n \t   because the one we found already has the value.  */\n-\tif (reload_reg_rtx[i])\n-\t  reload_in[i] = reload_reg_rtx[i];\n+\tif (rld[i].reg_rtx)\n+\t  rld[i].in = rld[i].reg_rtx;\n       }\n #endif\n \n@@ -3938,33 +3864,33 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n       int k;\n \n       for (j = i + 1; j < n_reloads; j++)\n-\tif ((reload_when_needed[i] == RELOAD_FOR_INPUT_ADDRESS\n-\t     || reload_when_needed[i] == RELOAD_FOR_OUTPUT_ADDRESS\n-\t     || reload_when_needed[i] == RELOAD_FOR_INPADDR_ADDRESS\n-\t     || reload_when_needed[i] == RELOAD_FOR_OUTADDR_ADDRESS)\n-\t    && (reload_when_needed[j] == RELOAD_FOR_INPUT_ADDRESS\n-\t\t|| reload_when_needed[j] == RELOAD_FOR_OUTPUT_ADDRESS\n-\t\t|| reload_when_needed[j] == RELOAD_FOR_INPADDR_ADDRESS\n-\t\t|| reload_when_needed[j] == RELOAD_FOR_OUTADDR_ADDRESS)\n-\t    && rtx_equal_p (reload_in[i], reload_in[j])\n-\t    && (operand_reloadnum[reload_opnum[i]] < 0\n-\t\t|| reload_optional[operand_reloadnum[reload_opnum[i]]])\n-\t    && (operand_reloadnum[reload_opnum[j]] < 0\n-\t\t|| reload_optional[operand_reloadnum[reload_opnum[j]]])\n-\t    && (goal_alternative_matches[reload_opnum[i]] == reload_opnum[j]\n-\t\t|| (goal_alternative_matches[reload_opnum[j]]\n-\t\t    == reload_opnum[i])))\n+\tif ((rld[i].when_needed == RELOAD_FOR_INPUT_ADDRESS\n+\t     || rld[i].when_needed == RELOAD_FOR_OUTPUT_ADDRESS\n+\t     || rld[i].when_needed == RELOAD_FOR_INPADDR_ADDRESS\n+\t     || rld[i].when_needed == RELOAD_FOR_OUTADDR_ADDRESS)\n+\t    && (rld[j].when_needed == RELOAD_FOR_INPUT_ADDRESS\n+\t\t|| rld[j].when_needed == RELOAD_FOR_OUTPUT_ADDRESS\n+\t\t|| rld[j].when_needed == RELOAD_FOR_INPADDR_ADDRESS\n+\t\t|| rld[j].when_needed == RELOAD_FOR_OUTADDR_ADDRESS)\n+\t    && rtx_equal_p (rld[i].in, rld[j].in)\n+\t    && (operand_reloadnum[rld[i].opnum] < 0\n+\t\t|| rld[operand_reloadnum[rld[i].opnum]].optional)\n+\t    && (operand_reloadnum[rld[j].opnum] < 0\n+\t\t|| rld[operand_reloadnum[rld[j].opnum]].optional)\n+\t    && (goal_alternative_matches[rld[i].opnum] == rld[j].opnum\n+\t\t|| (goal_alternative_matches[rld[j].opnum]\n+\t\t    == rld[i].opnum)))\n \t  {\n \t    for (k = 0; k < n_replacements; k++)\n \t      if (replacements[k].what == j)\n \t\treplacements[k].what = i;\n \n-\t    if (reload_when_needed[i] == RELOAD_FOR_INPADDR_ADDRESS\n-\t\t|| reload_when_needed[i] == RELOAD_FOR_OUTADDR_ADDRESS)\n-\t      reload_when_needed[i] = RELOAD_FOR_OPADDR_ADDR;\n+\t    if (rld[i].when_needed == RELOAD_FOR_INPADDR_ADDRESS\n+\t\t|| rld[i].when_needed == RELOAD_FOR_OUTADDR_ADDRESS)\n+\t      rld[i].when_needed = RELOAD_FOR_OPADDR_ADDR;\n \t    else\n-\t      reload_when_needed[i] = RELOAD_FOR_OPERAND_ADDRESS;\n-\t    reload_in[j] = 0;\n+\t      rld[i].when_needed = RELOAD_FOR_OPERAND_ADDRESS;\n+\t    rld[j].in = 0;\n \t  }\n     }\n \n@@ -3987,68 +3913,68 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \n   for (i = 0; i < n_reloads; i++)\n     {\n-      if (reload_secondary_p[i]\n-\t  && reload_when_needed[i] == operand_type[reload_opnum[i]])\n-\treload_when_needed[i] = address_type[reload_opnum[i]];\n-\n-      if ((reload_when_needed[i] == RELOAD_FOR_INPUT_ADDRESS\n-\t   || reload_when_needed[i] == RELOAD_FOR_OUTPUT_ADDRESS\n-\t   || reload_when_needed[i] == RELOAD_FOR_INPADDR_ADDRESS\n-\t   || reload_when_needed[i] == RELOAD_FOR_OUTADDR_ADDRESS)\n-\t  && (operand_reloadnum[reload_opnum[i]] < 0\n-\t      || reload_optional[operand_reloadnum[reload_opnum[i]]]))\n+      if (rld[i].secondary_p\n+\t  && rld[i].when_needed == operand_type[rld[i].opnum])\n+\trld[i].when_needed = address_type[rld[i].opnum];\n+\n+      if ((rld[i].when_needed == RELOAD_FOR_INPUT_ADDRESS\n+\t   || rld[i].when_needed == RELOAD_FOR_OUTPUT_ADDRESS\n+\t   || rld[i].when_needed == RELOAD_FOR_INPADDR_ADDRESS\n+\t   || rld[i].when_needed == RELOAD_FOR_OUTADDR_ADDRESS)\n+\t  && (operand_reloadnum[rld[i].opnum] < 0\n+\t      || rld[operand_reloadnum[rld[i].opnum]].optional))\n \t{\n \t  /* If we have a secondary reload to go along with this reload,\n \t     change its type to RELOAD_FOR_OPADDR_ADDR.  */\n \n-\t  if ((reload_when_needed[i] == RELOAD_FOR_INPUT_ADDRESS\n-\t       || reload_when_needed[i] == RELOAD_FOR_INPADDR_ADDRESS)\n-\t      && reload_secondary_in_reload[i] != -1)\n+\t  if ((rld[i].when_needed == RELOAD_FOR_INPUT_ADDRESS\n+\t       || rld[i].when_needed == RELOAD_FOR_INPADDR_ADDRESS)\n+\t      && rld[i].secondary_in_reload != -1)\n \t    {\n-\t      int secondary_in_reload = reload_secondary_in_reload[i];\n+\t      int secondary_in_reload = rld[i].secondary_in_reload;\n \n-\t      reload_when_needed[secondary_in_reload]\n+\t      rld[secondary_in_reload].when_needed\n \t\t= RELOAD_FOR_OPADDR_ADDR;\n \n \t      /* If there's a tertiary reload we have to change it also.  */\n \t      if (secondary_in_reload > 0\n-\t\t  && reload_secondary_in_reload[secondary_in_reload] != -1)\n-\t\treload_when_needed[reload_secondary_in_reload[secondary_in_reload]]\n+\t\t  && rld[secondary_in_reload].secondary_in_reload != -1)\n+\t\trld[rld[secondary_in_reload].secondary_in_reload].when_needed\n \t\t  = RELOAD_FOR_OPADDR_ADDR;\n \t    }\n \n-\t  if ((reload_when_needed[i] == RELOAD_FOR_OUTPUT_ADDRESS\n-\t       || reload_when_needed[i] == RELOAD_FOR_OUTADDR_ADDRESS)\n-\t      && reload_secondary_out_reload[i] != -1)\n+\t  if ((rld[i].when_needed == RELOAD_FOR_OUTPUT_ADDRESS\n+\t       || rld[i].when_needed == RELOAD_FOR_OUTADDR_ADDRESS)\n+\t      && rld[i].secondary_out_reload != -1)\n \t    {\n-\t      int secondary_out_reload = reload_secondary_out_reload[i];\n+\t      int secondary_out_reload = rld[i].secondary_out_reload;\n \n-\t      reload_when_needed[secondary_out_reload]\n+\t      rld[secondary_out_reload].when_needed\n \t\t= RELOAD_FOR_OPADDR_ADDR;\n \n \t      /* If there's a tertiary reload we have to change it also.  */\n \t      if (secondary_out_reload\n-\t\t  && reload_secondary_out_reload[secondary_out_reload] != -1)\n-\t\treload_when_needed[reload_secondary_out_reload[secondary_out_reload]]\n+\t\t  && rld[secondary_out_reload].secondary_out_reload != -1)\n+\t\trld[rld[secondary_out_reload].secondary_out_reload].when_needed\n \t\t  = RELOAD_FOR_OPADDR_ADDR;\n \t    }\n \n-\t  if (reload_when_needed[i] == RELOAD_FOR_INPADDR_ADDRESS\n-\t      || reload_when_needed[i] == RELOAD_FOR_OUTADDR_ADDRESS)\n-\t    reload_when_needed[i] = RELOAD_FOR_OPADDR_ADDR;\n+\t  if (rld[i].when_needed == RELOAD_FOR_INPADDR_ADDRESS\n+\t      || rld[i].when_needed == RELOAD_FOR_OUTADDR_ADDRESS)\n+\t    rld[i].when_needed = RELOAD_FOR_OPADDR_ADDR;\n \t  else\n-\t    reload_when_needed[i] = RELOAD_FOR_OPERAND_ADDRESS;\n+\t    rld[i].when_needed = RELOAD_FOR_OPERAND_ADDRESS;\n \t}\n \n-      if ((reload_when_needed[i] == RELOAD_FOR_INPUT_ADDRESS\n-\t   || reload_when_needed[i] == RELOAD_FOR_INPADDR_ADDRESS)\n-\t  && operand_reloadnum[reload_opnum[i]] >= 0\n-\t  && (reload_when_needed[operand_reloadnum[reload_opnum[i]]]\n+      if ((rld[i].when_needed == RELOAD_FOR_INPUT_ADDRESS\n+\t   || rld[i].when_needed == RELOAD_FOR_INPADDR_ADDRESS)\n+\t  && operand_reloadnum[rld[i].opnum] >= 0\n+\t  && (rld[operand_reloadnum[rld[i].opnum]].when_needed\n \t      == RELOAD_OTHER))\n-\treload_when_needed[i] = RELOAD_FOR_OTHER_ADDRESS;\n+\trld[i].when_needed = RELOAD_FOR_OTHER_ADDRESS;\n \n-      if (goal_alternative_matches[reload_opnum[i]] >= 0)\n-\treload_opnum[i] = goal_alternative_matches[reload_opnum[i]];\n+      if (goal_alternative_matches[rld[i].opnum] >= 0)\n+\trld[i].opnum = goal_alternative_matches[rld[i].opnum];\n     }\n \n   /* Scan all the reloads, and check for RELOAD_FOR_OPERAND_ADDRESS reloads.\n@@ -4089,7 +4015,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n       first_inpaddr_num[i] = first_outpaddr_num[i] = -2;\n     for (i = n_reloads - 1; i >= 0; i--)\n       {\n-\tswitch (reload_when_needed[i])\n+\tswitch (rld[i].when_needed)\n \t  {\n \t  case RELOAD_FOR_OPERAND_ADDRESS:\n \t    if (++first_op_addr_num >= 0)\n@@ -4099,16 +4025,16 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t      }\n \t    break;\n \t  case RELOAD_FOR_INPUT_ADDRESS:\n-\t    if (++first_inpaddr_num[reload_opnum[i]] >= 0)\n+\t    if (++first_inpaddr_num[rld[i].opnum] >= 0)\n \t      {\n-\t\tfirst_inpaddr_num[reload_opnum[i]] = i;\n+\t\tfirst_inpaddr_num[rld[i].opnum] = i;\n \t\tneed_change = 1;\n \t      }\n \t    break;\n \t  case RELOAD_FOR_OUTPUT_ADDRESS:\n-\t    if (++first_outpaddr_num[reload_opnum[i]] >= 0)\n+\t    if (++first_outpaddr_num[rld[i].opnum] >= 0)\n \t      {\n-\t\tfirst_outpaddr_num[reload_opnum[i]] = i;\n+\t\tfirst_outpaddr_num[rld[i].opnum] = i;\n \t\tneed_change = 1;\n \t      }\n \t    break;\n@@ -4123,18 +4049,18 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t  {\n \t    int first_num, type;\n \n-\t    switch (reload_when_needed[i])\n+\t    switch (rld[i].when_needed)\n \t      {\n \t      case RELOAD_FOR_OPADDR_ADDR:\n \t\tfirst_num = first_op_addr_num;\n \t\ttype = RELOAD_FOR_OPERAND_ADDRESS;\n \t\tbreak;\n \t      case RELOAD_FOR_INPADDR_ADDRESS:\n-\t\tfirst_num = first_inpaddr_num[reload_opnum[i]];\n+\t\tfirst_num = first_inpaddr_num[rld[i].opnum];\n \t\ttype = RELOAD_FOR_INPUT_ADDRESS;\n \t\tbreak;\n \t      case RELOAD_FOR_OUTADDR_ADDRESS:\n-\t\tfirst_num = first_outpaddr_num[reload_opnum[i]];\n+\t\tfirst_num = first_outpaddr_num[rld[i].opnum];\n \t\ttype = RELOAD_FOR_OUTPUT_ADDRESS;\n \t\tbreak;\n \t      default:\n@@ -4143,19 +4069,19 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t    if (first_num < 0)\n \t      continue;\n \t    else if (i > first_num)\n-\t      reload_when_needed[i] = type;\n+\t      rld[i].when_needed = type;\n \t    else\n \t      {\n \t\t/* Check if the only TYPE reload that uses reload I is\n \t\t   reload FIRST_NUM.  */\n \t\tfor (j = n_reloads - 1; j > first_num; j--)\n \t\t  {\n-\t\t    if (reload_when_needed[j] == type\n-\t\t\t&& (reload_secondary_p[i]\n-\t\t\t    ? reload_secondary_in_reload[j] == i\n-\t\t\t    : reg_mentioned_p (reload_in[i], reload_in[j])))\n+\t\t    if (rld[j].when_needed == type\n+\t\t\t&& (rld[i].secondary_p\n+\t\t\t    ? rld[j].secondary_in_reload == i\n+\t\t\t    : reg_mentioned_p (rld[i].in, rld[j].in)))\n \t\t      {\n-\t\t\treload_when_needed[i] = type;\n+\t\t\trld[i].when_needed = type;\n \t\t\tbreak;\n \t\t      }\n \t\t  }\n@@ -4170,21 +4096,21 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n      check for the most common cases.  */\n \n   for (i = 0; i < n_reloads; i++)\n-    if (reload_in[i] != 0 && reload_out[i] == 0\n-\t&& (reload_when_needed[i] == RELOAD_FOR_OPERAND_ADDRESS\n-\t    || reload_when_needed[i] == RELOAD_FOR_OPADDR_ADDR\n-\t    || reload_when_needed[i] == RELOAD_FOR_OTHER_ADDRESS))\n+    if (rld[i].in != 0 && rld[i].out == 0\n+\t&& (rld[i].when_needed == RELOAD_FOR_OPERAND_ADDRESS\n+\t    || rld[i].when_needed == RELOAD_FOR_OPADDR_ADDR\n+\t    || rld[i].when_needed == RELOAD_FOR_OTHER_ADDRESS))\n       for (j = 0; j < n_reloads; j++)\n-\tif (i != j && reload_in[j] != 0 && reload_out[j] == 0\n-\t    && reload_when_needed[j] == reload_when_needed[i]\n-\t    && MATCHES (reload_in[i], reload_in[j])\n-\t    && reload_reg_class[i] == reload_reg_class[j]\n-\t    && !reload_nocombine[i] && !reload_nocombine[j]\n-\t    && reload_reg_rtx[i] == reload_reg_rtx[j])\n+\tif (i != j && rld[j].in != 0 && rld[j].out == 0\n+\t    && rld[j].when_needed == rld[i].when_needed\n+\t    && MATCHES (rld[i].in, rld[j].in)\n+\t    && rld[i].class == rld[j].class\n+\t    && !rld[i].nocombine && !rld[j].nocombine\n+\t    && rld[i].reg_rtx == rld[j].reg_rtx)\n \t  {\n-\t    reload_opnum[i] = MIN (reload_opnum[i], reload_opnum[j]);\n+\t    rld[i].opnum = MIN (rld[i].opnum, rld[j].opnum);\n \t    transfer_replacements (i, j);\n-\t    reload_in[j] = 0;\n+\t    rld[j].in = 0;\n \t  }\n \n   /* Set which reloads must use registers not used in any group.  Start\n@@ -4194,28 +4120,28 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n   changed = 0;\n   for (i = 0; i < n_reloads; i++)\n     {\n-      enum machine_mode mode = reload_inmode[i];\n-      enum reg_class class = reload_reg_class[i];\n+      enum machine_mode mode = rld[i].inmode;\n+      enum reg_class class = rld[i].class;\n       int size;\n \n-      if (GET_MODE_SIZE (reload_outmode[i]) > GET_MODE_SIZE (mode))\n-\tmode = reload_outmode[i];\n+      if (GET_MODE_SIZE (rld[i].outmode) > GET_MODE_SIZE (mode))\n+\tmode = rld[i].outmode;\n       size = CLASS_MAX_NREGS (class, mode);\n \n       if (size == 1)\n \tfor (j = 0; j < n_reloads; j++)\n-\t  if ((CLASS_MAX_NREGS (reload_reg_class[j],\n-\t\t\t\t(GET_MODE_SIZE (reload_outmode[j])\n-\t\t\t\t > GET_MODE_SIZE (reload_inmode[j]))\n-\t\t\t\t? reload_outmode[j] : reload_inmode[j])\n+\t  if ((CLASS_MAX_NREGS (rld[j].class,\n+\t\t\t\t(GET_MODE_SIZE (rld[j].outmode)\n+\t\t\t\t > GET_MODE_SIZE (rld[j].inmode))\n+\t\t\t\t? rld[j].outmode : rld[j].inmode)\n \t       > 1)\n-\t      && !reload_optional[j]\n-\t      && (reload_in[j] != 0 || reload_out[j] != 0\n-\t\t  || reload_secondary_p[j])\n+\t      && !rld[j].optional\n+\t      && (rld[j].in != 0 || rld[j].out != 0\n+\t\t  || rld[j].secondary_p)\n \t      && reloads_conflict (i, j)\n-\t      && reg_classes_intersect_p (class, reload_reg_class[j]))\n+\t      && reg_classes_intersect_p (class, rld[j].class))\n \t    {\n-\t      reload_nongroup[i] = 1;\n+\t      rld[i].nongroup = 1;\n \t      changed = 1;\n \t      break;\n \t    }\n@@ -4227,21 +4153,21 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \n       for (i = 0; i < n_reloads; i++)\n \t{\n-\t  enum machine_mode mode = reload_inmode[i];\n-\t  enum reg_class class = reload_reg_class[i];\n+\t  enum machine_mode mode = rld[i].inmode;\n+\t  enum reg_class class = rld[i].class;\n \t  int size;\n \n-\t  if (GET_MODE_SIZE (reload_outmode[i]) > GET_MODE_SIZE (mode))\n-\t    mode = reload_outmode[i];\n+\t  if (GET_MODE_SIZE (rld[i].outmode) > GET_MODE_SIZE (mode))\n+\t    mode = rld[i].outmode;\n \t  size = CLASS_MAX_NREGS (class, mode);\n \n-\t  if (! reload_nongroup[i] && size == 1)\n+\t  if (! rld[i].nongroup && size == 1)\n \t    for (j = 0; j < n_reloads; j++)\n-\t      if (reload_nongroup[j]\n+\t      if (rld[j].nongroup\n \t\t  && reloads_conflict (i, j)\n-\t\t  && reg_classes_intersect_p (class, reload_reg_class[j]))\n+\t\t  && reg_classes_intersect_p (class, rld[j].class))\n \t\t{\n-\t\t  reload_nongroup[i] = 1;\n+\t\t  rld[i].nongroup = 1;\n \t\t  changed = 1;\n \t\t  break;\n \t\t}\n@@ -5363,7 +5289,7 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n \t\t\t\t   (context ? INDEX_REG_CLASS : BASE_REG_CLASS),\n \t\t\t\t   GET_MODE (x), GET_MODE (x), 0, 0,\n \t\t\t\t   opnum, type);\n-\t\t  reload_inc[reloadnum]\n+\t\t  rld[reloadnum].inc\n \t\t    = find_inc_amount (PATTERN (this_insn), XEXP (x_orig, 0));\n \n \t\t  value = 1;\n@@ -5388,7 +5314,7 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n \t     of an equivalent address for a pseudo that was not allocated to a\n \t     hard register.  Verify that the specified address is valid and\n \t     reload it into a register.  */\n-\t  /* Variable `tem' might or might not be used in FIND_REG_INC_NOTE. */\n+\t  /* Variable `tem' might or might not be used in FIND_REG_INC_NOTE.  */\n \t  rtx tem ATTRIBUTE_UNUSED = XEXP (x, 0);\n \t  register rtx link;\n \t  int reloadnum;\n@@ -5409,7 +5335,7 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n \t  reloadnum = push_reload (x, NULL_RTX, loc, NULL_PTR,\n \t\t\t\t   (context ? INDEX_REG_CLASS : BASE_REG_CLASS),\n \t\t\t\t   GET_MODE (x), VOIDmode, 0, 0, opnum, type);\n-\t  reload_inc[reloadnum]\n+\t  rld[reloadnum].inc\n \t    = find_inc_amount (PATTERN (this_insn), XEXP (x, 0));\n \n \t  link = FIND_REG_INC_NOTE (this_insn, tem);\n@@ -5725,7 +5651,7 @@ subst_reloads ()\n   for (i = 0; i < n_replacements; i++)\n     {\n       register struct replacement *r = &replacements[i];\n-      register rtx reloadreg = reload_reg_rtx[r->what];\n+      register rtx reloadreg = rld[r->what].reg_rtx;\n       if (reloadreg)\n \t{\n \t  /* Encapsulate RELOADREG so its machine mode matches what\n@@ -5754,7 +5680,7 @@ subst_reloads ()\n \t    *r->where = reloadreg;\n \t}\n       /* If reload got no reg and isn't optional, something's wrong.  */\n-      else if (! reload_optional[r->what])\n+      else if (! rld[r->what].optional)\n \tabort ();\n     }\n }\n@@ -5831,7 +5757,7 @@ find_replacement (loc)\n \n   for (r = &replacements[0]; r < &replacements[n_replacements]; r++)\n     {\n-      rtx reloadreg = reload_reg_rtx[r->what];\n+      rtx reloadreg = rld[r->what].reg_rtx;\n \n       if (reloadreg && r->where == loc)\n \t{\n@@ -6334,11 +6260,11 @@ find_equiv_reg (goal, insn, class, other, reload_reg_p, goalreg, mode)\n     {\n       int i;\n       for (i = 0; i < n_reloads; i++)\n-\tif (reload_reg_rtx[i] != 0 && reload_in[i])\n+\tif (rld[i].reg_rtx != 0 && rld[i].in)\n \t  {\n-\t    int regno1 = REGNO (reload_reg_rtx[i]);\n+\t    int regno1 = REGNO (rld[i].reg_rtx);\n \t    int nregs1 = HARD_REGNO_NREGS (regno1,\n-\t\t\t\t\t   GET_MODE (reload_reg_rtx[i]));\n+\t\t\t\t\t   GET_MODE (rld[i].reg_rtx));\n \t    if (regno1 < valueno + valuenregs\n \t\t&& regno1 + nregs1 > valueno)\n \t      return 0;\n@@ -6663,84 +6589,84 @@ debug_reload_to_stream (f)\n     {\n       fprintf (f, \"Reload %d: \", r);\n \n-      if (reload_in[r] != 0)\n+      if (rld[r].in != 0)\n \t{\n \t  fprintf (f, \"reload_in (%s) = \",\n-\t\t   GET_MODE_NAME (reload_inmode[r]));\n-\t  print_inline_rtx (f, reload_in[r], 24);\n+\t\t   GET_MODE_NAME (rld[r].inmode));\n+\t  print_inline_rtx (f, rld[r].in, 24);\n \t  fprintf (f, \"\\n\\t\");\n \t}\n \n-      if (reload_out[r] != 0)\n+      if (rld[r].out != 0)\n \t{\n \t  fprintf (f, \"reload_out (%s) = \",\n-\t\t   GET_MODE_NAME (reload_outmode[r]));\n-\t  print_inline_rtx (f, reload_out[r], 24);\n+\t\t   GET_MODE_NAME (rld[r].outmode));\n+\t  print_inline_rtx (f, rld[r].out, 24);\n \t  fprintf (f, \"\\n\\t\");\n \t}\n \n-      fprintf (f, \"%s, \", reg_class_names[(int) reload_reg_class[r]]);\n+      fprintf (f, \"%s, \", reg_class_names[(int) rld[r].class]);\n \n       fprintf (f, \"%s (opnum = %d)\",\n-\t       reload_when_needed_name[(int) reload_when_needed[r]],\n-\t       reload_opnum[r]);\n+\t       reload_when_needed_name[(int) rld[r].when_needed],\n+\t       rld[r].opnum);\n \n-      if (reload_optional[r])\n+      if (rld[r].optional)\n \tfprintf (f, \", optional\");\n \n-      if (reload_nongroup[r])\n+      if (rld[r].nongroup)\n \tfprintf (stderr, \", nongroup\");\n \n-      if (reload_inc[r] != 0)\n-\tfprintf (f, \", inc by %d\", reload_inc[r]);\n+      if (rld[r].inc != 0)\n+\tfprintf (f, \", inc by %d\", rld[r].inc);\n \n-      if (reload_nocombine[r])\n+      if (rld[r].nocombine)\n \tfprintf (f, \", can't combine\");\n \n-      if (reload_secondary_p[r])\n+      if (rld[r].secondary_p)\n \tfprintf (f, \", secondary_reload_p\");\n \n-      if (reload_in_reg[r] != 0)\n+      if (rld[r].in_reg != 0)\n \t{\n \t  fprintf (f, \"\\n\\treload_in_reg: \");\n-\t  print_inline_rtx (f, reload_in_reg[r], 24);\n+\t  print_inline_rtx (f, rld[r].in_reg, 24);\n \t}\n \n-      if (reload_out_reg[r] != 0)\n+      if (rld[r].out_reg != 0)\n \t{\n \t  fprintf (f, \"\\n\\treload_out_reg: \");\n-\t  print_inline_rtx (f, reload_out_reg[r], 24);\n+\t  print_inline_rtx (f, rld[r].out_reg, 24);\n \t}\n \n-      if (reload_reg_rtx[r] != 0)\n+      if (rld[r].reg_rtx != 0)\n \t{\n \t  fprintf (f, \"\\n\\treload_reg_rtx: \");\n-\t  print_inline_rtx (f, reload_reg_rtx[r], 24);\n+\t  print_inline_rtx (f, rld[r].reg_rtx, 24);\n \t}\n \n       prefix = \"\\n\\t\";\n-      if (reload_secondary_in_reload[r] != -1)\n+      if (rld[r].secondary_in_reload != -1)\n \t{\n \t  fprintf (f, \"%ssecondary_in_reload = %d\",\n-\t\t   prefix, reload_secondary_in_reload[r]);\n+\t\t   prefix, rld[r].secondary_in_reload);\n \t  prefix = \", \";\n \t}\n \n-      if (reload_secondary_out_reload[r] != -1)\n+      if (rld[r].secondary_out_reload != -1)\n \tfprintf (f, \"%ssecondary_out_reload = %d\\n\",\n-\t\t prefix, reload_secondary_out_reload[r]);\n+\t\t prefix, rld[r].secondary_out_reload);\n \n       prefix = \"\\n\\t\";\n-      if (reload_secondary_in_icode[r] != CODE_FOR_nothing)\n+      if (rld[r].secondary_in_icode != CODE_FOR_nothing)\n \t{\n \t  fprintf (stderr, \"%ssecondary_in_icode = %s\", prefix,\n-\t\t   insn_data[reload_secondary_in_icode[r]].name);\n+\t\t   insn_data[rld[r].secondary_in_icode].name);\n \t  prefix = \", \";\n \t}\n \n-      if (reload_secondary_out_icode[r] != CODE_FOR_nothing)\n+      if (rld[r].secondary_out_icode != CODE_FOR_nothing)\n \tfprintf (stderr, \"%ssecondary_out_icode = %s\", prefix,\n-\t\t insn_data[reload_secondary_out_icode[r]].name);\n+\t\t insn_data[rld[r].secondary_out_icode].name);\n \n       fprintf (f, \"\\n\");\n     }"}, {"sha": "5371362b1c021a777e2407aa7426451b921a1e39", "filename": "gcc/reload.h", "status": "modified", "additions": 75, "deletions": 25, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eceef4c97d732ccfb2f0ec79de97a7bc0dcd8cf9/gcc%2Freload.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eceef4c97d732ccfb2f0ec79de97a7bc0dcd8cf9/gcc%2Freload.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.h?ref=eceef4c97d732ccfb2f0ec79de97a7bc0dcd8cf9", "patch": "@@ -45,33 +45,9 @@ Boston, MA 02111-1307, USA.  */\n #endif\n extern int memory_move_secondary_cost PROTO ((enum machine_mode, enum reg_class, int));\n \n-/* See reload.c and reload1.c for comments on these variables.  */\n-\n /* Maximum number of reloads we can need.  */\n #define MAX_RELOADS (2 * MAX_RECOG_OPERANDS * (MAX_REGS_PER_ADDRESS + 1))\n \n-extern rtx reload_in[MAX_RELOADS];\n-extern rtx reload_out[MAX_RELOADS];\n-extern rtx reload_in_reg[MAX_RELOADS];\n-extern rtx reload_out_reg[MAX_RELOADS];\n-extern enum reg_class reload_reg_class[MAX_RELOADS];\n-extern enum machine_mode reload_inmode[MAX_RELOADS];\n-extern enum machine_mode reload_outmode[MAX_RELOADS];\n-extern char reload_optional[MAX_RELOADS];\n-extern char reload_nongroup[MAX_RELOADS];\n-extern int reload_inc[MAX_RELOADS];\n-extern int reload_opnum[MAX_RELOADS];\n-extern int reload_secondary_p[MAX_RELOADS];\n-extern int reload_secondary_in_reload[MAX_RELOADS];\n-extern int reload_secondary_out_reload[MAX_RELOADS];\n-#ifdef MAX_INSN_CODE\n-extern enum insn_code reload_secondary_in_icode[MAX_RELOADS];\n-extern enum insn_code reload_secondary_out_icode[MAX_RELOADS];\n-#endif\n-extern int n_reloads;\n-\n-extern rtx reload_reg_rtx[MAX_RELOADS];\n-\n /* Encode the usage of a reload.  The following codes are supported:\n \n    RELOAD_FOR_INPUT\t\treload of an input operand\n@@ -105,7 +81,81 @@ enum reload_type\n   RELOAD_OTHER, RELOAD_FOR_OTHER_ADDRESS\n };\n \n-extern enum reload_type reload_when_needed[MAX_RELOADS];\n+#ifdef MAX_INSN_CODE\n+/* Each reload is recorded with a structure like this.  */\n+struct reload\n+{\n+  /* The value to reload from */\n+  rtx in;\n+  /* Where to store reload-reg afterward if nec (often the same as\n+     reload_in)  */\n+  rtx out;\n+\n+  /* The class of registers to reload into.  */\n+  enum reg_class class;\n+\n+  /* The mode this operand should have when reloaded, on input.  */\n+  enum machine_mode inmode;\n+  /* The mode this operand should have when reloaded, on output.  */\n+  enum machine_mode outmode;\n+\n+  /* Positive amount to increment or decrement by if\n+     reload_in is a PRE_DEC, PRE_INC, POST_DEC, POST_INC.\n+     Ignored otherwise (don't assume it is zero).  */\n+  int inc;\n+  /* A reg for which reload_in is the equivalent.\n+     If reload_in is a symbol_ref which came from\n+     reg_equiv_constant, then this is the pseudo\n+     which has that symbol_ref as equivalent.  */\n+  rtx in_reg;\n+  rtx out_reg;\n+\n+  /* Used in find_reload_regs to record the allocated register.  */\n+  int regno;\n+  /* This is the register to reload into.  If it is zero when `find_reloads'\n+     returns, you must find a suitable register in the class specified by\n+     reload_reg_class, and store here an rtx for that register with mode from\n+     reload_inmode or reload_outmode.  */\n+  rtx reg_rtx;\n+  /* The operand number being reloaded.  This is used to group related reloads\n+     and need not always be equal to the actual operand number in the insn,\n+     though it current will be; for in-out operands, it is one of the two\n+     operand numbers.  */\n+  int opnum;\n+\n+  /* Gives the reload number of a secondary input reload, when needed;\n+     otherwise -1.  */\n+  int secondary_in_reload;\n+  /* Gives the reload number of a secondary output reload, when needed;\n+     otherwise -1.  */\n+  int secondary_out_reload;\n+  /* If a secondary input reload is required, gives the INSN_CODE that uses the\n+     secondary reload as a scratch register, or CODE_FOR_nothing if the\n+     secondary reload register is to be an intermediate register.  */\n+  enum insn_code secondary_in_icode;\n+  /* Likewise, for a secondary output reload.  */\n+  enum insn_code secondary_out_icode;\n+\n+  /* Classifies reload as needed either for addressing an input reload,\n+     addressing an output, for addressing a non-reloaded mem ref, or for\n+     unspecified purposes (i.e., more than one of the above).  */\n+  enum reload_type when_needed;\n+  \n+  /* Nonzero for an optional reload.  Optional reloads are ignored unless the\n+     value is already sitting in a register.  */\n+  unsigned int optional:1;\n+  /* nonzero if this reload shouldn't be combined with another reload.  */\n+  unsigned int nocombine:1;\n+  /* Nonzero if this is a secondary register for one or more reloads.  */\n+  unsigned int secondary_p:1;\n+  /* Nonzero if this reload must use a register not already allocated to a\n+     group.  */\n+  unsigned int nongroup:1;\n+};\n+\n+extern struct reload rld[MAX_RELOADS];\n+extern int n_reloads;\n+#endif\n \n extern rtx *reg_equiv_constant;\n extern rtx *reg_equiv_memory_loc;"}, {"sha": "22533ec66b55c5ad37c8708d27e64a2df24c8d58", "filename": "gcc/reload1.c", "status": "modified", "additions": 418, "deletions": 420, "changes": 838, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eceef4c97d732ccfb2f0ec79de97a7bc0dcd8cf9/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eceef4c97d732ccfb2f0ec79de97a7bc0dcd8cf9/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=eceef4c97d732ccfb2f0ec79de97a7bc0dcd8cf9", "patch": "@@ -1502,7 +1502,7 @@ calculate_needs (chain)\n   for (i = 0; i < n_reloads; i++)\n     {\n       register enum reg_class *p;\n-      enum reg_class class = reload_reg_class[i];\n+      enum reg_class class = rld[i].class;\n       int size;\n       enum machine_mode mode;\n       struct needs *this_needs;\n@@ -1511,19 +1511,19 @@ calculate_needs (chain)\n \t regs mentioned in the insn can be used for reloading.\n \t Don't count optional reloads.\n \t Don't count reloads that got combined with others.  */\n-      if (reload_reg_rtx[i] != 0\n-\t  || reload_optional[i] != 0\n-\t  || (reload_out[i] == 0 && reload_in[i] == 0\n-\t      && ! reload_secondary_p[i]))\n+      if (rld[i].reg_rtx != 0\n+\t  || rld[i].optional != 0\n+\t  || (rld[i].out == 0 && rld[i].in == 0\n+\t      && ! rld[i].secondary_p))\n \tcontinue;\n \n-      mode = reload_inmode[i];\n-      if (GET_MODE_SIZE (reload_outmode[i]) > GET_MODE_SIZE (mode))\n-\tmode = reload_outmode[i];\n+      mode = rld[i].inmode;\n+      if (GET_MODE_SIZE (rld[i].outmode) > GET_MODE_SIZE (mode))\n+\tmode = rld[i].outmode;\n       size = CLASS_MAX_NREGS (class, mode);\n \n       /* Decide which time-of-use to count this reload for.  */\n-      switch (reload_when_needed[i])\n+      switch (rld[i].when_needed)\n \t{\n \tcase RELOAD_OTHER:\n \t  this_needs = &insn_needs.other;\n@@ -1541,16 +1541,16 @@ calculate_needs (chain)\n \t  this_needs = &insn_needs.other_addr;\n \t  break;\n \tcase RELOAD_FOR_INPUT_ADDRESS:\n-\t  this_needs = &insn_needs.in_addr[reload_opnum[i]];\n+\t  this_needs = &insn_needs.in_addr[rld[i].opnum];\n \t  break;\n \tcase RELOAD_FOR_INPADDR_ADDRESS:\n-\t  this_needs = &insn_needs.in_addr_addr[reload_opnum[i]];\n+\t  this_needs = &insn_needs.in_addr_addr[rld[i].opnum];\n \t  break;\n \tcase RELOAD_FOR_OUTPUT_ADDRESS:\n-\t  this_needs = &insn_needs.out_addr[reload_opnum[i]];\n+\t  this_needs = &insn_needs.out_addr[rld[i].opnum];\n \t  break;\n \tcase RELOAD_FOR_OUTADDR_ADDRESS:\n-\t  this_needs = &insn_needs.out_addr_addr[reload_opnum[i]];\n+\t  this_needs = &insn_needs.out_addr_addr[rld[i].opnum];\n \t  break;\n \tcase RELOAD_FOR_OPERAND_ADDRESS:\n \t  this_needs = &insn_needs.op_addr;\n@@ -1601,10 +1601,10 @@ calculate_needs (chain)\n \t}\n       else if (size == 1)\n \t{\n-\t  this_needs->regs[(unsigned char)reload_nongroup[i]][(int) class] += 1;\n+\t  this_needs->regs[(unsigned char)rld[i].nongroup][(int) class] += 1;\n \t  p = reg_class_superclasses[(int) class];\n \t  while (*p != LIM_REG_CLASSES)\n-\t    this_needs->regs[(unsigned char)reload_nongroup[i]][(int) *p++] += 1;\n+\t    this_needs->regs[(unsigned char)rld[i].nongroup][(int) *p++] += 1;\n \t}\n       else\n \tabort ();\n@@ -4353,7 +4353,7 @@ reload_as_needed (live_known)\n \t     which have been performed by subst_reloads above.  */\n \t  for (i = n_reloads - 1; i >= 0; i--)\n \t    {\n-\t      rtx in_reg = reload_in_reg[i];\n+\t      rtx in_reg = rld[i].in_reg;\n \t      if (in_reg)\n \t\t{\n \t\t  enum rtx_code code = GET_CODE (in_reg);\n@@ -4364,14 +4364,14 @@ reload_as_needed (live_known)\n \t\t     or we can't use the reload register for inheritance.  */\n \t\t  if ((code == POST_INC || code == POST_DEC)\n \t\t      && TEST_HARD_REG_BIT (reg_reloaded_valid,\n-\t\t\t\t\t    REGNO (reload_reg_rtx[i]))\n+\t\t\t\t\t    REGNO (rld[i].reg_rtx))\n \t\t      /* Make sure it is the inc/dec pseudo, and not\n \t\t\t some other (e.g. output operand) pseudo.  */\n-\t\t      && (reg_reloaded_contents[REGNO (reload_reg_rtx[i])]\n+\t\t      && (reg_reloaded_contents[REGNO (rld[i].reg_rtx)]\n \t\t\t  == REGNO (XEXP (in_reg, 0))))\n \n \t\t    {\n-\t\t      rtx reload_reg = reload_reg_rtx[i];\n+\t\t      rtx reload_reg = rld[i].reg_rtx;\n \t\t      enum machine_mode mode = GET_MODE (reload_reg);\n \t\t      int n = 0;\n \t\t      rtx p;\n@@ -4430,14 +4430,14 @@ reload_as_needed (live_known)\n \t\t    }\n \t\t  else if ((code == PRE_INC || code == PRE_DEC)\n \t\t\t   && TEST_HARD_REG_BIT (reg_reloaded_valid,\n-\t\t\t\t\t\t REGNO (reload_reg_rtx[i]))\n+\t\t\t\t\t\t REGNO (rld[i].reg_rtx))\n \t\t\t   /* Make sure it is the inc/dec pseudo, and not\n \t\t\t      some other (e.g. output operand) pseudo.  */\n-\t\t\t   && (reg_reloaded_contents[REGNO (reload_reg_rtx[i])]\n+\t\t\t   && (reg_reloaded_contents[REGNO (rld[i].reg_rtx)]\n \t\t\t       == REGNO (XEXP (in_reg, 0))))\n \t\t    {\n \t\t      SET_HARD_REG_BIT (reg_is_output_reload,\n-\t\t\t\t\tREGNO (reload_reg_rtx[i]));\n+\t\t\t\t\tREGNO (rld[i].reg_rtx));\n \t\t      reg_has_output_reload[REGNO (XEXP (in_reg, 0))] = 1;\n \t\t    }\n \t\t}\n@@ -4452,7 +4452,7 @@ reload_as_needed (live_known)\n \t\t   If so, its last-reload info is still valid\n \t\t   because it is based on this insn's reload.  */\n \t\tfor (i = 0; i < n_reloads; i++)\n-\t\t  if (reload_out[i] == XEXP (x, 0))\n+\t\t  if (rld[i].out == XEXP (x, 0))\n \t\t    break;\n \n \t\tif (i == n_reloads)\n@@ -4559,13 +4559,13 @@ reload_reg_class_lower (r1p, r2p)\n   register int t;\n \n   /* Consider required reloads before optional ones.  */\n-  t = reload_optional[r1] - reload_optional[r2];\n+  t = rld[r1].optional - rld[r2].optional;\n   if (t != 0)\n     return t;\n \n   /* Count all solitary classes before non-solitary ones.  */\n-  t = ((reg_class_size[(int) reload_reg_class[r2]] == 1)\n-       - (reg_class_size[(int) reload_reg_class[r1]] == 1));\n+  t = ((reg_class_size[(int) rld[r2].class] == 1)\n+       - (reg_class_size[(int) rld[r1].class] == 1));\n   if (t != 0)\n     return t;\n \n@@ -4575,7 +4575,7 @@ reload_reg_class_lower (r1p, r2p)\n     return t;\n \n   /* Consider reloads in order of increasing reg-class number.  */\n-  t = (int) reload_reg_class[r1] - (int) reload_reg_class[r2];\n+  t = (int) rld[r1].class - (int) rld[r2].class;\n   if (t != 0)\n     return t;\n \n@@ -4774,11 +4774,11 @@ clear_reload_reg_in_use (regno, opnum, type, mode)\n     {\n       for (i = n_reloads - 1; i >= 0; i--)\n \t{\n-\t  if (reload_when_needed[i] == type\n-\t      && (check_any || reload_opnum[i] == opnum)\n-\t      && reload_reg_rtx[i])\n+\t  if (rld[i].when_needed == type\n+\t      && (check_any || rld[i].opnum == opnum)\n+\t      && rld[i].reg_rtx)\n \t    {\n-\t      int conflict_start = true_regnum (reload_reg_rtx[i]);\n+\t      int conflict_start = true_regnum (rld[i].reg_rtx);\n \t      int conflict_end\n \t\t= (conflict_start\n \t\t   + HARD_REGNO_NREGS (conflict_start, reload_mode[i]));\n@@ -5093,10 +5093,10 @@ int\n reloads_conflict (r1, r2)\n      int r1, r2;\n {\n-  enum reload_type r1_type = reload_when_needed[r1];\n-  enum reload_type r2_type = reload_when_needed[r2];\n-  int r1_opnum = reload_opnum[r1];\n-  int r2_opnum = reload_opnum[r2];\n+  enum reload_type r1_type = rld[r1].when_needed;\n+  enum reload_type r2_type = rld[r2].when_needed;\n+  int r1_opnum = rld[r1].opnum;\n+  int r2_opnum = rld[r2].opnum;\n \n   /* RELOAD_OTHER conflicts with everything.  */\n   if (r2_type == RELOAD_OTHER)\n@@ -5282,17 +5282,17 @@ reload_reg_free_for_value_p (regno, opnum, type, value, out, reloadnum,\n \n   for (i = 0; i < n_reloads; i++)\n     {\n-      rtx reg = reload_reg_rtx[i];\n+      rtx reg = rld[i].reg_rtx;\n       if (reg && GET_CODE (reg) == REG\n \t  && ((unsigned) regno - true_regnum (reg)\n \t      <= HARD_REGNO_NREGS (REGNO (reg), GET_MODE (reg)) - (unsigned)1)\n \t  && i != reloadnum)\n \t{\n-\t  if (! reload_in[i] || ! rtx_equal_p (reload_in[i], value)\n-\t      || reload_out[i] || out)\n+\t  if (! rld[i].in || ! rtx_equal_p (rld[i].in, value)\n+\t      || rld[i].out || out)\n \t    {\n \t      int time2;\n-\t      switch (reload_when_needed[i])\n+\t      switch (rld[i].when_needed)\n \t\t{\n \t\tcase RELOAD_FOR_OTHER_ADDRESS:\n \t\t  time2 = 0;\n@@ -5309,34 +5309,34 @@ reload_reg_free_for_value_p (regno, opnum, type, value, out, reloadnum,\n \t\t      /* Unless the RELOAD_FOR_INPUT is an auto_inc expression.\n \t\t\t Then the address address is still needed to store\n \t\t\t back the new address.  */\n-\t\t      && ! reload_out[reloadnum])\n+\t\t      && ! rld[reloadnum].out)\n \t\t    continue;\n \t\t  /* Likewise, if a RELOAD_FOR_INPUT can inherit a value, its\n \t\t     RELOAD_FOR_INPUT_ADDRESS / RELOAD_FOR_INPADDR_ADDRESS\n \t\t     reloads go away.  */\n-\t\t  if (type == RELOAD_FOR_INPUT && opnum == reload_opnum[i]\n+\t\t  if (type == RELOAD_FOR_INPUT && opnum == rld[i].opnum\n \t\t      && ignore_address_reloads\n \t\t      /* Unless we are reloading an auto_inc expression.  */\n-\t\t      && ! reload_out[reloadnum])\n+\t\t      && ! rld[reloadnum].out)\n \t\t    continue;\n-\t\t  time2 = reload_opnum[i] * 4 + 2;\n+\t\t  time2 = rld[i].opnum * 4 + 2;\n \t\t  break;\n \t\tcase RELOAD_FOR_INPUT_ADDRESS:\n-\t\t  if (type == RELOAD_FOR_INPUT && opnum == reload_opnum[i]\n+\t\t  if (type == RELOAD_FOR_INPUT && opnum == rld[i].opnum\n \t\t      && ignore_address_reloads\n-\t\t      && ! reload_out[reloadnum])\n+\t\t      && ! rld[reloadnum].out)\n \t\t    continue;\n-\t\t  time2 = reload_opnum[i] * 4 + 3;\n+\t\t  time2 = rld[i].opnum * 4 + 3;\n \t\t  break;\n \t\tcase RELOAD_FOR_INPUT:\n-\t\t  time2 = reload_opnum[i] * 4 + 4;\n+\t\t  time2 = rld[i].opnum * 4 + 4;\n \t\t  break;\n-\t\t  /* reload_opnum[i] * 4 + 4 <= (MAX_RECOG_OPERAND - 1) * 4 + 4\n+\t\t  /* rld[i].opnum * 4 + 4 <= (MAX_RECOG_OPERAND - 1) * 4 + 4\n \t\t     == MAX_RECOG_OPERAND * 4  */\n \t\tcase RELOAD_FOR_OPADDR_ADDR:\n \t\t  if (type == RELOAD_FOR_OPERAND_ADDRESS && reloadnum == i + 1\n \t\t      && ignore_address_reloads\n-\t\t      && ! reload_out[reloadnum])\n+\t\t      && ! rld[reloadnum].out)\n \t\t    continue;\n \t\t  time2 = MAX_RECOG_OPERANDS * 4 + 1;\n \t\t  break;\n@@ -5357,17 +5357,17 @@ reload_reg_free_for_value_p (regno, opnum, type, value, out, reloadnum,\n \t\tcase RELOAD_FOR_OUTADDR_ADDRESS:\n \t\t  if (type == RELOAD_FOR_OUTPUT_ADDRESS && reloadnum == i + 1\n \t\t      && ignore_address_reloads\n-\t\t      && ! reload_out[reloadnum])\n+\t\t      && ! rld[reloadnum].out)\n \t\t    continue;\n-\t\t  time2 = MAX_RECOG_OPERANDS * 4 + 4 + reload_opnum[i];\n+\t\t  time2 = MAX_RECOG_OPERANDS * 4 + 4 + rld[i].opnum;\n \t\t  break;\n \t\tcase RELOAD_FOR_OUTPUT_ADDRESS:\n-\t\t  time2 = MAX_RECOG_OPERANDS * 4 + 5 + reload_opnum[i];\n+\t\t  time2 = MAX_RECOG_OPERANDS * 4 + 5 + rld[i].opnum;\n \t\t  break;\n \t\tcase RELOAD_OTHER:\n \t\t  /* If there is no conflict in the input part, handle this\n \t\t     like an output reload.  */\n-\t\t  if (! reload_in[i] || rtx_equal_p (reload_in[i], value))\n+\t\t  if (! rld[i].in || rtx_equal_p (rld[i].in, value))\n \t\t    {\n \t\t      time2 = MAX_RECOG_OPERANDS * 4 + 4;\n \t\t      break;\n@@ -5384,9 +5384,9 @@ reload_reg_free_for_value_p (regno, opnum, type, value, out, reloadnum,\n \t\t  return 0;\n \t\t}\n \t      if ((time1 >= time2\n-\t\t   && (! reload_in[i] || reload_out[i]\n-\t\t       || ! rtx_equal_p (reload_in[i], value)))\n-\t\t  || (out && reload_out_reg[reloadnum]\n+\t\t   && (! rld[i].in || rld[i].out\n+\t\t       || ! rtx_equal_p (rld[i].in, value)))\n+\t\t  || (out && rld[reloadnum].out_reg\n \t\t      && time2 >= MAX_RECOG_OPERANDS * 4 + 3))\n \t\treturn 0;\n \t    }\n@@ -5399,7 +5399,7 @@ reload_reg_free_for_value_p (regno, opnum, type, value, out, reloadnum,\n    LAST_RELOAD is non-zero if this is the last reload for the insn being\n    processed.\n \n-   Set reload_reg_rtx[R] to the register allocated.\n+   Set rld[R].reg_rtx to the register allocated.\n \n    If NOERROR is nonzero, we return 1 if successful,\n    or 0 if we couldn't find a spill reg and we didn't change anything.  */\n@@ -5461,25 +5461,25 @@ allocate_reload_reg (chain, r, last_reload, noerror)\n \n       for (count = 0; count < n_spills; count++)\n \t{\n-\t  int class = (int) reload_reg_class[r];\n+\t  int class = (int) rld[r].class;\n \t  int regnum;\n \n \t  i++;\n \t  if (i >= n_spills)\n \t    i -= n_spills;\n \t  regnum = spill_regs[i];\n \n-\t  if ((reload_reg_free_p (regnum, reload_opnum[r],\n-\t\t\t\t  reload_when_needed[r])\n-\t       || (reload_in[r]\n+\t  if ((reload_reg_free_p (regnum, rld[r].opnum,\n+\t\t\t\t  rld[r].when_needed)\n+\t       || (rld[r].in\n \t\t   /* We check reload_reg_used to make sure we\n \t\t      don't clobber the return register.  */\n \t\t   && ! TEST_HARD_REG_BIT (reload_reg_used, regnum)\n \t\t   && reload_reg_free_for_value_p (regnum,\n-\t\t\t\t\t\t   reload_opnum[r],\n-\t\t\t\t\t\t   reload_when_needed[r],\n-\t\t\t\t\t\t   reload_in[r],\n-\t\t\t\t\t\t   reload_out[r], r, 1)))\n+\t\t\t\t\t\t   rld[r].opnum,\n+\t\t\t\t\t\t   rld[r].when_needed,\n+\t\t\t\t\t\t   rld[r].in,\n+\t\t\t\t\t\t   rld[r].out, r, 1)))\n \t      && TEST_HARD_REG_BIT (reg_class_contents[class], regnum)\n \t      && HARD_REGNO_MODE_OK (regnum, reload_mode[r])\n \t      /* Look first for regs to share, then for unshared.  But\n@@ -5496,7 +5496,7 @@ allocate_reload_reg (chain, r, last_reload, noerror)\n \t\t (on 68000) got us two FP regs.  If NR is 1,\n \t\t we would reject both of them.  */\n \t      if (force_group)\n-\t\tnr = CLASS_MAX_NREGS (reload_reg_class[r], reload_mode[r]);\n+\t\tnr = CLASS_MAX_NREGS (rld[r].class, reload_mode[r]);\n \t      /* If we need only one reg, we have already won.  */\n \t      if (nr == 1)\n \t\t{\n@@ -5515,8 +5515,8 @@ allocate_reload_reg (chain, r, last_reload, noerror)\n \t\t    regno = regnum + nr - 1;\n \t\t    if (!(TEST_HARD_REG_BIT (reg_class_contents[class], regno)\n \t\t\t  && spill_reg_order[regno] >= 0\n-\t\t\t  && reload_reg_free_p (regno, reload_opnum[r],\n-\t\t\t\t\t\treload_when_needed[r])\n+\t\t\t  && reload_reg_free_p (regno, rld[r].opnum,\n+\t\t\t\t\t\trld[r].when_needed)\n \t\t\t  && ! TEST_HARD_REG_BIT (chain->counted_for_nongroups,\n \t\t\t\t\t\t  regno)))\n \t\t      break;\n@@ -5556,28 +5556,28 @@ allocate_reload_reg (chain, r, last_reload, noerror)\n   if (HARD_REGNO_MODE_OK (regno, reload_mode[r]))\n     {\n       enum machine_mode test_mode = VOIDmode;\n-      if (reload_in[r])\n-\ttest_mode = GET_MODE (reload_in[r]);\n-      /* If reload_in[r] has VOIDmode, it means we will load it\n+      if (rld[r].in)\n+\ttest_mode = GET_MODE (rld[r].in);\n+      /* If rld[r].in has VOIDmode, it means we will load it\n \t in whatever mode the reload reg has: to wit, reload_mode[r].\n \t We have already tested that for validity.  */\n       /* Aside from that, we need to test that the expressions\n \t to reload from or into have modes which are valid for this\n \t reload register.  Otherwise the reload insns would be invalid.  */\n-      if (! (reload_in[r] != 0 && test_mode != VOIDmode\n+      if (! (rld[r].in != 0 && test_mode != VOIDmode\n \t     && ! HARD_REGNO_MODE_OK (regno, test_mode)))\n-\tif (! (reload_out[r] != 0\n-\t       && ! HARD_REGNO_MODE_OK (regno, GET_MODE (reload_out[r]))))\n+\tif (! (rld[r].out != 0\n+\t       && ! HARD_REGNO_MODE_OK (regno, GET_MODE (rld[r].out))))\n \t  {\n \t    /* The reg is OK.  */\n \t    last_spill_reg = i;\n \n \t    /* Mark as in use for this insn the reload regs we use\n \t       for this.  */\n-\t    mark_reload_reg_in_use (spill_regs[i], reload_opnum[r],\n-\t\t\t\t    reload_when_needed[r], reload_mode[r]);\n+\t    mark_reload_reg_in_use (spill_regs[i], rld[r].opnum,\n+\t\t\t\t    rld[r].when_needed, reload_mode[r]);\n \n-\t    reload_reg_rtx[r] = new;\n+\t    rld[r].reg_rtx = new;\n \t    reload_spill_index[r] = spill_regs[i];\n \t    return 1;\n \t  }\n@@ -5596,11 +5596,11 @@ allocate_reload_reg (chain, r, last_reload, noerror)\n      don't match.  Disable this reload so we don't crash in final.  */\n   error_for_asm (insn,\n \t\t \"`asm' operand constraint incompatible with operand size\");\n-  reload_in[r] = 0;\n-  reload_out[r] = 0;\n-  reload_reg_rtx[r] = 0;\n-  reload_optional[r] = 1;\n-  reload_secondary_p[r] = 1;\n+  rld[r].in = 0;\n+  rld[r].out = 0;\n+  rld[r].reg_rtx = 0;\n+  rld[r].optional = 1;\n+  rld[r].secondary_p = 1;\n \n   return 1;\n }\n@@ -5685,11 +5685,11 @@ choose_reload_regs (chain)\n   {\n     int tem = 0;\n     for (j = 0; j < n_reloads; j++)\n-      if (! reload_optional[j]\n-\t  && (reload_in[j] != 0 || reload_out[j] != 0 || reload_secondary_p[j])\n-\t  && (reload_reg_rtx[j] == 0\n-\t      || (! rtx_equal_p (reload_reg_rtx[j], reload_in[j])\n-\t\t  && ! rtx_equal_p (reload_reg_rtx[j], reload_out[j]))))\n+      if (! rld[j].optional\n+\t  && (rld[j].in != 0 || rld[j].out != 0 || rld[j].secondary_p)\n+\t  && (rld[j].reg_rtx == 0\n+\t      || (! rtx_equal_p (rld[j].reg_rtx, rld[j].in)\n+\t\t  && ! rtx_equal_p (rld[j].reg_rtx, rld[j].out))))\n \ttem++;\n     if (tem > n_spills)\n       must_reuse = 1;\n@@ -5710,32 +5710,30 @@ choose_reload_regs (chain)\n       reload_order[j] = j;\n       reload_spill_index[j] = -1;\n \n-      reload_mode[j]\n-\t= ((reload_inmode[j] == VOIDmode\n-\t   || (GET_MODE_SIZE (reload_outmode[j])\n-\t       > GET_MODE_SIZE (reload_inmode[j])))\n-\t   ? reload_outmode[j] : reload_inmode[j]);\n+      reload_mode[j] = ((rld[j].inmode == VOIDmode\n+\t\t\t || (GET_MODE_SIZE (rld[j].outmode)\n+\t\t\t     > GET_MODE_SIZE (rld[j].inmode)))\n+\t\t\t? rld[j].outmode : rld[j].inmode);\n \n-      reload_nregs[j] = CLASS_MAX_NREGS (reload_reg_class[j], reload_mode[j]);\n+      reload_nregs[j] = CLASS_MAX_NREGS (rld[j].class, reload_mode[j]);\n \n       if (reload_nregs[j] > 1)\n \t{\n \t  max_group_size = MAX (reload_nregs[j], max_group_size);\n-\t  group_class = reg_class_superunion[(int)reload_reg_class[j]][(int)group_class];\n+\t  group_class = reg_class_superunion[(int)rld[j].class][(int)group_class];\n \t}\n \n+      save_reload_reg_rtx[j] = rld[j].reg_rtx;\n       /* If we have already decided to use a certain register,\n \t don't use it in another way.  */\n-      if (reload_reg_rtx[j])\n-\tmark_reload_reg_in_use (REGNO (reload_reg_rtx[j]), reload_opnum[j],\n-\t\t\t\treload_when_needed[j], reload_mode[j]);\n+      if (rld[j].reg_rtx)\n+\tmark_reload_reg_in_use (REGNO (rld[j].reg_rtx), rld[j].opnum,\n+\t\t\t\trld[j].when_needed, reload_mode[j]);\n     }\n \n   if (n_reloads > 1)\n     qsort (reload_order, n_reloads, sizeof (short), reload_reg_class_lower);\n \n-  bcopy ((char *) reload_reg_rtx, (char *) save_reload_reg_rtx,\n-\t sizeof reload_reg_rtx);\n   bcopy (reload_inherited, save_reload_inherited, sizeof reload_inherited);\n   bcopy ((char *) reload_inheritance_insn,\n \t (char *) save_reload_inheritance_insn,\n@@ -5807,20 +5805,20 @@ choose_reload_regs (chain)\n \t  rtx search_equiv = NULL_RTX;\n \n \t  /* Ignore reloads that got marked inoperative.  */\n-\t  if (reload_out[r] == 0 && reload_in[r] == 0\n-\t      && ! reload_secondary_p[r])\n+\t  if (rld[r].out == 0 && rld[r].in == 0\n+\t      && ! rld[r].secondary_p)\n \t    continue;\n \n \t  /* If find_reloads chose to use reload_in or reload_out as a reload\n \t     register, we don't need to chose one.  Otherwise, try even if it\n \t     found one since we might save an insn if we find the value lying\n \t     around.\n \t     Try also when reload_in is a pseudo without a hard reg.  */\n-\t  if (reload_in[r] != 0 && reload_reg_rtx[r] != 0\n-\t      && (rtx_equal_p (reload_in[r], reload_reg_rtx[r])\n-\t\t  || (rtx_equal_p (reload_out[r], reload_reg_rtx[r])\n-\t\t      && GET_CODE (reload_in[r]) != MEM\n-\t\t      && true_regnum (reload_in[r]) < FIRST_PSEUDO_REGISTER)))\n+\t  if (rld[r].in != 0 && rld[r].reg_rtx != 0\n+\t      && (rtx_equal_p (rld[r].in, rld[r].reg_rtx)\n+\t\t  || (rtx_equal_p (rld[r].out, rld[r].reg_rtx)\n+\t\t      && GET_CODE (rld[r].in) != MEM\n+\t\t      && true_regnum (rld[r].in) < FIRST_PSEUDO_REGISTER)))\n \t    continue;\n \n #if 0 /* No longer needed for correct operation.\n@@ -5829,13 +5827,13 @@ choose_reload_regs (chain)\n \t     until we are sure that any non-optional reloads have been allocated.\n \t     The following code takes advantage of the fact that optional reloads\n \t     are at the end of reload_order.  */\n-\t  if (reload_optional[r] != 0)\n+\t  if (rld[r].optional != 0)\n \t    for (i = 0; i < j; i++)\n-\t      if ((reload_out[reload_order[i]] != 0\n-\t\t   || reload_in[reload_order[i]] != 0\n-\t\t   || reload_secondary_p[reload_order[i]])\n-\t\t  && ! reload_optional[reload_order[i]]\n-\t\t  && reload_reg_rtx[reload_order[i]] == 0)\n+\t      if ((rld[reload_order[i]].out != 0\n+\t\t   || rld[reload_order[i]].in != 0\n+\t\t   || rld[reload_order[i]].secondary_p)\n+\t\t  && ! rld[reload_order[i]].optional\n+\t\t  && rld[reload_order[i]].reg_rtx == 0)\n \t\tallocate_reload_reg (chain, reload_order[i], 0, inheritance);\n #endif\n \n@@ -5859,51 +5857,51 @@ choose_reload_regs (chain)\n \t      register int regno = -1;\n \t      enum machine_mode mode = VOIDmode;\n \n-\t      if (reload_in[r] == 0)\n+\t      if (rld[r].in == 0)\n \t\t;\n-\t      else if (GET_CODE (reload_in[r]) == REG)\n+\t      else if (GET_CODE (rld[r].in) == REG)\n \t\t{\n-\t\t  regno = REGNO (reload_in[r]);\n-\t\t  mode = GET_MODE (reload_in[r]);\n+\t\t  regno = REGNO (rld[r].in);\n+\t\t  mode = GET_MODE (rld[r].in);\n \t\t}\n-\t      else if (GET_CODE (reload_in_reg[r]) == REG)\n+\t      else if (GET_CODE (rld[r].in_reg) == REG)\n \t\t{\n-\t\t  regno = REGNO (reload_in_reg[r]);\n-\t\t  mode = GET_MODE (reload_in_reg[r]);\n+\t\t  regno = REGNO (rld[r].in_reg);\n+\t\t  mode = GET_MODE (rld[r].in_reg);\n \t\t}\n-\t      else if (GET_CODE (reload_in_reg[r]) == SUBREG\n-\t\t       && GET_CODE (SUBREG_REG (reload_in_reg[r])) == REG)\n+\t      else if (GET_CODE (rld[r].in_reg) == SUBREG\n+\t\t       && GET_CODE (SUBREG_REG (rld[r].in_reg)) == REG)\n \t\t{\n-\t\t  word = SUBREG_WORD (reload_in_reg[r]);\n-\t\t  regno = REGNO (SUBREG_REG (reload_in_reg[r]));\n+\t\t  word = SUBREG_WORD (rld[r].in_reg);\n+\t\t  regno = REGNO (SUBREG_REG (rld[r].in_reg));\n \t\t  if (regno < FIRST_PSEUDO_REGISTER)\n \t\t    regno += word;\n-\t\t  mode = GET_MODE (reload_in_reg[r]);\n+\t\t  mode = GET_MODE (rld[r].in_reg);\n \t\t}\n #ifdef AUTO_INC_DEC\n-\t      else if ((GET_CODE (reload_in_reg[r]) == PRE_INC\n-\t\t\t|| GET_CODE (reload_in_reg[r]) == PRE_DEC\n-\t\t\t|| GET_CODE (reload_in_reg[r]) == POST_INC\n-\t\t\t|| GET_CODE (reload_in_reg[r]) == POST_DEC)\n-\t\t       && GET_CODE (XEXP (reload_in_reg[r], 0)) == REG)\n+\t      else if ((GET_CODE (rld[r].in_reg) == PRE_INC\n+\t\t\t|| GET_CODE (rld[r].in_reg) == PRE_DEC\n+\t\t\t|| GET_CODE (rld[r].in_reg) == POST_INC\n+\t\t\t|| GET_CODE (rld[r].in_reg) == POST_DEC)\n+\t\t       && GET_CODE (XEXP (rld[r].in_reg, 0)) == REG)\n \t\t{\n-\t\t  regno = REGNO (XEXP (reload_in_reg[r], 0));\n-\t\t  mode = GET_MODE (XEXP (reload_in_reg[r], 0));\n-\t\t  reload_out[r] = reload_in[r];\n+\t\t  regno = REGNO (XEXP (rld[r].in_reg, 0));\n+\t\t  mode = GET_MODE (XEXP (rld[r].in_reg, 0));\n+\t\t  rld[r].out = rld[r].in;\n \t\t}\n #endif\n #if 0\n \t      /* This won't work, since REGNO can be a pseudo reg number.\n \t\t Also, it takes much more hair to keep track of all the things\n \t\t that can invalidate an inherited reload of part of a pseudoreg.  */\n-\t      else if (GET_CODE (reload_in[r]) == SUBREG\n-\t\t       && GET_CODE (SUBREG_REG (reload_in[r])) == REG)\n-\t\tregno = REGNO (SUBREG_REG (reload_in[r])) + SUBREG_WORD (reload_in[r]);\n+\t      else if (GET_CODE (rld[r].in) == SUBREG\n+\t\t       && GET_CODE (SUBREG_REG (rld[r].in)) == REG)\n+\t\tregno = REGNO (SUBREG_REG (rld[r].in)) + SUBREG_WORD (rld[r].in);\n #endif\n \n \t      if (regno >= 0 && reg_last_reload_reg[regno] != 0)\n \t\t{\n-\t\t  enum reg_class class = reload_reg_class[r], last_class;\n+\t\t  enum reg_class class = rld[r].class, last_class;\n \t\t  rtx last_reg = reg_last_reload_reg[regno];\n \n \t\t  i = REGNO (last_reg) + word;\n@@ -5934,9 +5932,9 @@ choose_reload_regs (chain)\n \t\t      && (reload_nregs[r] == max_group_size\n \t\t\t  || ! TEST_HARD_REG_BIT (reg_class_contents[(int) group_class],\n \t\t\t\t\t\t  i))\n-\t\t      && reload_reg_free_for_value_p (i, reload_opnum[r],\n-\t\t\t\t\t\t      reload_when_needed[r],\n-\t\t\t\t\t\t      reload_in[r],\n+\t\t      && reload_reg_free_for_value_p (i, rld[r].opnum,\n+\t\t\t\t\t\t      rld[r].when_needed,\n+\t\t\t\t\t\t      rld[r].in,\n \t\t\t\t\t\t      const0_rtx, r, 1))\n \t\t    {\n \t\t      /* If a group is needed, verify that all the subsequent\n@@ -5972,28 +5970,28 @@ choose_reload_regs (chain)\n \n \t\t\t  if (i1 != n_earlyclobbers\n \t\t\t      || ! (reload_reg_free_for_value_p\n-\t\t\t\t    (i, reload_opnum[r], reload_when_needed[r],\n-\t\t\t\t     reload_in[r], reload_out[r], r, 1))\n+\t\t\t\t    (i, rld[r].opnum, rld[r].when_needed,\n+\t\t\t\t     rld[r].in, rld[r].out, r, 1))\n \t\t\t      /* Don't use it if we'd clobber a pseudo reg.  */\n \t\t\t      || (TEST_HARD_REG_BIT (reg_used_in_insn, i)\n-\t\t\t\t  && reload_out[r]\n+\t\t\t\t  && rld[r].out\n \t\t\t\t  && ! TEST_HARD_REG_BIT (reg_reloaded_dead, i))\n \t\t\t      /* Don't clobber the frame pointer.  */\n \t\t\t      || (i == HARD_FRAME_POINTER_REGNUM\n-\t\t\t\t  && reload_out[r])\n+\t\t\t\t  && rld[r].out)\n \t\t\t      /* Don't really use the inherited spill reg\n \t\t\t\t if we need it wider than we've got it.  */\n \t\t\t      || (GET_MODE_SIZE (reload_mode[r])\n \t\t\t\t  > GET_MODE_SIZE (mode))\n-\t\t\t      || ! TEST_HARD_REG_BIT (reg_class_contents[(int) reload_reg_class[r]],\n+\t\t\t      || ! TEST_HARD_REG_BIT (reg_class_contents[(int) rld[r].class],\n \t\t\t\t\t\t      i)\n \n \t\t\t      /* If find_reloads chose reload_out as reload\n \t\t\t\t register, stay with it - that leaves the\n \t\t\t\t inherited register for subsequent reloads.  */\n-\t\t\t      || (reload_out[r] && reload_reg_rtx[r]\n-\t\t\t\t  && rtx_equal_p (reload_out[r],\n-\t\t\t\t\t\t  reload_reg_rtx[r])))\n+\t\t\t      || (rld[r].out && rld[r].reg_rtx\n+\t\t\t\t  && rtx_equal_p (rld[r].out,\n+\t\t\t\t\t\t  rld[r].reg_rtx)))\n \t\t\t    {\n \t\t\t      reload_override_in[r] = last_reg;\n \t\t\t      reload_inheritance_insn[r]\n@@ -6006,10 +6004,10 @@ choose_reload_regs (chain)\n \t\t\t      /* Mark the register as in use for this part of\n \t\t\t\t the insn.  */\n \t\t\t      mark_reload_reg_in_use (i,\n-\t\t\t\t\t\t      reload_opnum[r],\n-\t\t\t\t\t\t      reload_when_needed[r],\n+\t\t\t\t\t\t      rld[r].opnum,\n+\t\t\t\t\t\t      rld[r].when_needed,\n \t\t\t\t\t\t      reload_mode[r]);\n-\t\t\t      reload_reg_rtx[r] = last_reg;\n+\t\t\t      rld[r].reg_rtx = last_reg;\n \t\t\t      reload_inherited[r] = 1;\n \t\t\t      reload_inheritance_insn[r]\n \t\t\t\t= reg_reloaded_insn[i];\n@@ -6025,32 +6023,32 @@ choose_reload_regs (chain)\n \n \t  /* Here's another way to see if the value is already lying around.  */\n \t  if (inheritance\n-\t      && reload_in[r] != 0\n+\t      && rld[r].in != 0\n \t      && ! reload_inherited[r]\n-\t      && reload_out[r] == 0\n-\t      && (CONSTANT_P (reload_in[r])\n-\t\t  || GET_CODE (reload_in[r]) == PLUS\n-\t\t  || GET_CODE (reload_in[r]) == REG\n-\t\t  || GET_CODE (reload_in[r]) == MEM)\n+\t      && rld[r].out == 0\n+\t      && (CONSTANT_P (rld[r].in)\n+\t\t  || GET_CODE (rld[r].in) == PLUS\n+\t\t  || GET_CODE (rld[r].in) == REG\n+\t\t  || GET_CODE (rld[r].in) == MEM)\n \t      && (reload_nregs[r] == max_group_size\n-\t\t  || ! reg_classes_intersect_p (reload_reg_class[r], group_class)))\n-\t    search_equiv = reload_in[r];\n+\t\t  || ! reg_classes_intersect_p (rld[r].class, group_class)))\n+\t    search_equiv = rld[r].in;\n \t  /* If this is an output reload from a simple move insn, look\n \t     if an equivalence for the input is available.  */\n-\t  else if (inheritance && reload_in[r] == 0 && reload_out[r] != 0)\n+\t  else if (inheritance && rld[r].in == 0 && rld[r].out != 0)\n \t    {\n \t      rtx set = single_set (insn);\n \n \t      if (set\n-\t\t  && rtx_equal_p (reload_out[r], SET_DEST (set))\n+\t\t  && rtx_equal_p (rld[r].out, SET_DEST (set))\n \t\t  && CONSTANT_P (SET_SRC (set)))\n \t\tsearch_equiv = SET_SRC (set);\n \t    }\n \n \t  if (search_equiv)\n \t    {\n \t      register rtx equiv\n-\t\t= find_equiv_reg (search_equiv, insn, reload_reg_class[r],\n+\t\t= find_equiv_reg (search_equiv, insn, rld[r].class,\n \t\t\t\t  -1, NULL_PTR, 0, reload_mode[r]);\n \t      int regno;\n \n@@ -6075,11 +6073,11 @@ choose_reload_regs (chain)\n \t\t and of the desired class.  */\n \t      if (equiv != 0\n \t\t  && ((TEST_HARD_REG_BIT (reload_reg_used_at_all, regno)\n-\t\t       && ! reload_reg_free_for_value_p (regno, reload_opnum[r],\n-\t\t\t\t\t\t\t reload_when_needed[r],\n-\t\t\t\t\t\t\t reload_in[r],\n-\t\t\t\t\t\t\t reload_out[r], r, 1))\n-\t\t      || ! TEST_HARD_REG_BIT (reg_class_contents[(int) reload_reg_class[r]],\n+\t\t       && ! reload_reg_free_for_value_p (regno, rld[r].opnum,\n+\t\t\t\t\t\t\t rld[r].when_needed,\n+\t\t\t\t\t\t\t rld[r].in,\n+\t\t\t\t\t\t\t rld[r].out, r, 1))\n+\t\t      || ! TEST_HARD_REG_BIT (reg_class_contents[(int) rld[r].class],\n \t\t\t\t\t      regno)))\n \t\tequiv = 0;\n \n@@ -6109,7 +6107,7 @@ choose_reload_regs (chain)\n \n \t      if (equiv != 0 && regno_clobbered_p (regno, insn))\n \t\t{\n-\t\t  switch (reload_when_needed[r])\n+\t\t  switch (rld[r].when_needed)\n \t\t    {\n \t\t    case RELOAD_FOR_OTHER_ADDRESS:\n \t\t    case RELOAD_FOR_INPADDR_ADDRESS:\n@@ -6133,7 +6131,7 @@ choose_reload_regs (chain)\n \t\t{\n \t\t  int nr = HARD_REGNO_NREGS (regno, reload_mode[r]);\n \t\t  int k;\n-\t\t  reload_reg_rtx[r] = equiv;\n+\t\t  rld[r].reg_rtx = equiv;\n \t\t  reload_inherited[r] = 1;\n \n \t\t  /* If reg_reloaded_valid is not set for this register,\n@@ -6149,8 +6147,8 @@ choose_reload_regs (chain)\n \t\t      i = spill_reg_order[regno + k];\n \t\t      if (i >= 0)\n \t\t\t{\n-\t\t\t  mark_reload_reg_in_use (regno, reload_opnum[r],\n-\t\t\t\t\t\t  reload_when_needed[r],\n+\t\t\t  mark_reload_reg_in_use (regno, rld[r].opnum,\n+\t\t\t\t\t\t  rld[r].when_needed,\n \t\t\t\t\t\t  reload_mode[r]);\n \t\t\t  SET_HARD_REG_BIT (reload_reg_used_for_inherit,\n \t\t\t\t\t    regno + k);\n@@ -6161,7 +6159,7 @@ choose_reload_regs (chain)\n \n \t  /* If we found a register to use already, or if this is an optional\n \t     reload, we are done.  */\n-\t  if (reload_reg_rtx[r] != 0 || reload_optional[r] != 0)\n+\t  if (rld[r].reg_rtx != 0 || rld[r].optional != 0)\n \t    continue;\n \n #if 0 /* No longer needed for correct operation.  Might or might not\n@@ -6180,14 +6178,14 @@ choose_reload_regs (chain)\n \t    {\n \t      int s = reload_order[i];\n \n-\t      if ((reload_in[s] == 0 && reload_out[s] == 0\n-\t\t   && ! reload_secondary_p[s])\n-\t\t  || reload_optional[s])\n+\t      if ((rld[s].in == 0 && rld[s].out == 0\n+\t\t   && ! rld[s].secondary_p)\n+\t\t  || rld[s].optional)\n \t\tcontinue;\n \n-\t      if ((reload_reg_class[s] != reload_reg_class[r]\n-\t\t   && reg_classes_intersect_p (reload_reg_class[r],\n-\t\t\t\t\t       reload_reg_class[s]))\n+\t      if ((rld[s].class != rld[r].class\n+\t\t   && reg_classes_intersect_p (rld[r].class,\n+\t\t\t\t\t       rld[s].class))\n \t\t  || reload_nregs[s] < reload_nregs[r])\n \t\tbreak;\n \t    }\n@@ -6206,12 +6204,12 @@ choose_reload_regs (chain)\n \t  register int r = reload_order[j];\n \n \t  /* Ignore reloads that got marked inoperative.  */\n-\t  if (reload_out[r] == 0 && reload_in[r] == 0 && ! reload_secondary_p[r])\n+\t  if (rld[r].out == 0 && rld[r].in == 0 && ! rld[r].secondary_p)\n \t    continue;\n \n \t  /* Skip reloads that already have a register allocated or are\n \t     optional.  */\n-\t  if (reload_reg_rtx[r] != 0 || reload_optional[r])\n+\t  if (rld[r].reg_rtx != 0 || rld[r].optional)\n \t    continue;\n \n \t  if (! allocate_reload_reg (chain, r, j == n_reloads - 1, inheritance))\n@@ -6225,8 +6223,8 @@ choose_reload_regs (chain)\n       /* Loop around and try without any inheritance.  */\n       /* First undo everything done by the failed attempt\n \t to allocate with inheritance.  */\n-      bcopy ((char *) save_reload_reg_rtx, (char *) reload_reg_rtx,\n-\t     sizeof reload_reg_rtx);\n+      for (i = 0; i < n_reloads; i++)\n+\trld[i].reg_rtx = save_reload_reg_rtx[i];\n       bcopy ((char *) save_reload_inherited, (char *) reload_inherited,\n \t     sizeof reload_inherited);\n       bcopy ((char *) save_reload_inheritance_insn,\n@@ -6278,20 +6276,20 @@ choose_reload_regs (chain)\n \t{\n \t  register int r = reload_order[j];\n \t  rtx check_reg;\n-\t  if (reload_inherited[r] && reload_reg_rtx[r])\n-\t    check_reg = reload_reg_rtx[r];\n+\t  if (reload_inherited[r] && rld[r].reg_rtx)\n+\t    check_reg = rld[r].reg_rtx;\n \t  else if (reload_override_in[r]\n \t\t   && (GET_CODE (reload_override_in[r]) == REG\n \t\t       || GET_CODE (reload_override_in[r]) == SUBREG))\n \t    check_reg = reload_override_in[r];\n \t  else\n \t    continue;\n \t  if (! reload_reg_free_for_value_p (true_regnum (check_reg),\n-\t\t\t\t\t     reload_opnum[r],\n-\t\t\t\t\t     reload_when_needed[r],\n-\t\t\t\t\t     reload_in[r],\n+\t\t\t\t\t     rld[r].opnum,\n+\t\t\t\t\t     rld[r].when_needed,\n+\t\t\t\t\t     rld[r].in,\n \t\t\t\t\t     (reload_inherited[r]\n-\t\t\t\t\t      ? reload_out[r] : const0_rtx),\n+\t\t\t\t\t      ? rld[r].out : const0_rtx),\n \t\t\t\t\t     r, 1))\n \t    {\n \t      if (pass)\n@@ -6311,9 +6309,9 @@ choose_reload_regs (chain)\n \t     If we suceeded removing some reload and we are doing a preliminary\n \t     pass just to remove such reloads, make another pass, since the\n \t     removal of one reload might allow us to inherit another one.  */\n-\t  else if (reload_in[r]\n-\t\t   && reload_out[r] != reload_in[r]\n-\t\t   && remove_address_replacements (reload_in[r]) && pass)\n+\t  else if (rld[r].in\n+\t\t   && rld[r].out != rld[r].in\n+\t\t   && remove_address_replacements (rld[r].in) && pass)\n \t    pass = 2;\n \t}\n     }\n@@ -6322,23 +6320,23 @@ choose_reload_regs (chain)\n      actually override reload_in.  */\n   for (j = 0; j < n_reloads; j++)\n     if (reload_override_in[j])\n-      reload_in[j] = reload_override_in[j];\n+      rld[j].in = reload_override_in[j];\n \n   /* If this reload won't be done because it has been cancelled or is\n      optional and not inherited, clear reload_reg_rtx so other\n      routines (such as subst_reloads) don't get confused.  */\n   for (j = 0; j < n_reloads; j++)\n-    if (reload_reg_rtx[j] != 0\n-\t&& ((reload_optional[j] && ! reload_inherited[j])\n-\t    || (reload_in[j] == 0 && reload_out[j] == 0\n-\t\t&& ! reload_secondary_p[j])))\n+    if (rld[j].reg_rtx != 0\n+\t&& ((rld[j].optional && ! reload_inherited[j])\n+\t    || (rld[j].in == 0 && rld[j].out == 0\n+\t\t&& ! rld[j].secondary_p)))\n       {\n-\tint regno = true_regnum (reload_reg_rtx[j]);\n+\tint regno = true_regnum (rld[j].reg_rtx);\n \n \tif (spill_reg_order[regno] >= 0)\n-\t  clear_reload_reg_in_use (regno, reload_opnum[j],\n-\t\t\t\t   reload_when_needed[j], reload_mode[j]);\n-\treload_reg_rtx[j] = 0;\n+\t  clear_reload_reg_in_use (regno, rld[j].opnum,\n+\t\t\t\t   rld[j].when_needed, reload_mode[j]);\n+\trld[j].reg_rtx = 0;\n       }\n \n   /* Record which pseudos and which spill regs have output reloads.  */\n@@ -6349,12 +6347,12 @@ choose_reload_regs (chain)\n       i = reload_spill_index[r];\n \n       /* I is nonneg if this reload uses a register.\n-\t If reload_reg_rtx[r] is 0, this is an optional reload\n+\t If rld[r].reg_rtx is 0, this is an optional reload\n \t that we opted to ignore.  */\n-      if (reload_out_reg[r] != 0 && GET_CODE (reload_out_reg[r]) == REG\n-\t  && reload_reg_rtx[r] != 0)\n+      if (rld[r].out_reg != 0 && GET_CODE (rld[r].out_reg) == REG\n+\t  && rld[r].reg_rtx != 0)\n \t{\n-\t  register int nregno = REGNO (reload_out_reg[r]);\n+\t  register int nregno = REGNO (rld[r].out_reg);\n \t  int nr = 1;\n \n \t  if (nregno < FIRST_PSEUDO_REGISTER)\n@@ -6370,9 +6368,9 @@ choose_reload_regs (chain)\n \t\tSET_HARD_REG_BIT (reg_is_output_reload, i + nr);\n \t    }\n \n-\t  if (reload_when_needed[r] != RELOAD_OTHER\n-\t      && reload_when_needed[r] != RELOAD_FOR_OUTPUT\n-\t      && reload_when_needed[r] != RELOAD_FOR_INSN)\n+\t  if (rld[r].when_needed != RELOAD_OTHER\n+\t      && rld[r].when_needed != RELOAD_FOR_OUTPUT\n+\t      && rld[r].when_needed != RELOAD_FOR_INSN)\n \t    abort ();\n \t}\n     }\n@@ -6386,12 +6384,12 @@ deallocate_reload_reg (r)\n {\n   int regno;\n \n-  if (! reload_reg_rtx[r])\n+  if (! rld[r].reg_rtx)\n     return;\n-  regno = true_regnum (reload_reg_rtx[r]);\n-  reload_reg_rtx[r] = 0;\n+  regno = true_regnum (rld[r].reg_rtx);\n+  rld[r].reg_rtx = 0;\n   if (spill_reg_order[regno] >= 0)\n-    clear_reload_reg_in_use (regno, reload_opnum[r], reload_when_needed[r],\n+    clear_reload_reg_in_use (regno, rld[r].opnum, rld[r].when_needed,\n \t\t\t     reload_mode[r]);\n   reload_spill_index[r] = -1;\n }\n@@ -6425,9 +6423,9 @@ merge_assigned_reloads (insn)\n       int max_input_address_opnum = -1;\n       int min_conflicting_input_opnum = MAX_RECOG_OPERANDS;\n \n-      if (reload_in[i] == 0 || reload_when_needed[i] == RELOAD_OTHER\n-\t  || reload_out[i] != 0 || reload_reg_rtx[i] == 0\n-\t  || reg_set_p (reload_reg_rtx[i], insn))\n+      if (rld[i].in == 0 || rld[i].when_needed == RELOAD_OTHER\n+\t  || rld[i].out != 0 || rld[i].reg_rtx == 0\n+\t  || reg_set_p (rld[i].reg_rtx, insn))\n \tcontinue;\n \n       /* Look at all other reloads.  Ensure that the only use of this\n@@ -6438,32 +6436,32 @@ merge_assigned_reloads (insn)\n \n       for (j = 0; j < n_reloads; j++)\n \t{\n-\t  if (i == j || reload_reg_rtx[j] == 0\n-\t      || ! reg_overlap_mentioned_p (reload_reg_rtx[j],\n-\t\t\t\t\t    reload_reg_rtx[i]))\n+\t  if (i == j || rld[j].reg_rtx == 0\n+\t      || ! reg_overlap_mentioned_p (rld[j].reg_rtx,\n+\t\t\t\t\t    rld[i].reg_rtx))\n \t    continue;\n \n-\t  if (reload_when_needed[j] == RELOAD_FOR_INPUT_ADDRESS\n-\t      && reload_opnum[j] > max_input_address_opnum)\n-\t    max_input_address_opnum = reload_opnum[j];\n+\t  if (rld[j].when_needed == RELOAD_FOR_INPUT_ADDRESS\n+\t      && rld[j].opnum > max_input_address_opnum)\n+\t    max_input_address_opnum = rld[j].opnum;\n \n \t  /* If the reload regs aren't exactly the same (e.g, different modes)\n \t     or if the values are different, we can't merge this reload.\n \t     But if it is an input reload, we might still merge\n \t     RELOAD_FOR_INPUT_ADDRESS and RELOAD_FOR_OTHER_ADDRESS reloads.  */\n \n-\t  if (! rtx_equal_p (reload_reg_rtx[i], reload_reg_rtx[j])\n-\t      || reload_out[j] != 0 || reload_in[j] == 0\n-\t      || ! rtx_equal_p (reload_in[i], reload_in[j]))\n+\t  if (! rtx_equal_p (rld[i].reg_rtx, rld[j].reg_rtx)\n+\t      || rld[j].out != 0 || rld[j].in == 0\n+\t      || ! rtx_equal_p (rld[i].in, rld[j].in))\n \t    {\n-\t      if (reload_when_needed[j] != RELOAD_FOR_INPUT\n-\t\t  || ((reload_when_needed[i] != RELOAD_FOR_INPUT_ADDRESS\n-\t\t       || reload_opnum[i] > reload_opnum[j])\n-\t\t      && reload_when_needed[i] != RELOAD_FOR_OTHER_ADDRESS))\n+\t      if (rld[j].when_needed != RELOAD_FOR_INPUT\n+\t\t  || ((rld[i].when_needed != RELOAD_FOR_INPUT_ADDRESS\n+\t\t       || rld[i].opnum > rld[j].opnum)\n+\t\t      && rld[i].when_needed != RELOAD_FOR_OTHER_ADDRESS))\n \t\tbreak;\n \t      conflicting_input = 1;\n-\t      if (min_conflicting_input_opnum > reload_opnum[j])\n-\t\tmin_conflicting_input_opnum = reload_opnum[j];\n+\t      if (min_conflicting_input_opnum > rld[j].opnum)\n+\t\tmin_conflicting_input_opnum = rld[j].opnum;\n \t    }\n \t}\n \n@@ -6474,14 +6472,14 @@ merge_assigned_reloads (insn)\n \t  && max_input_address_opnum <= min_conflicting_input_opnum)\n \t{\n \t  for (j = 0; j < n_reloads; j++)\n-\t    if (i != j && reload_reg_rtx[j] != 0\n-\t\t&& rtx_equal_p (reload_reg_rtx[i], reload_reg_rtx[j])\n+\t    if (i != j && rld[j].reg_rtx != 0\n+\t\t&& rtx_equal_p (rld[i].reg_rtx, rld[j].reg_rtx)\n \t\t&& (! conflicting_input\n-\t\t    || reload_when_needed[j] == RELOAD_FOR_INPUT_ADDRESS\n-\t\t    || reload_when_needed[j] == RELOAD_FOR_OTHER_ADDRESS))\n+\t\t    || rld[j].when_needed == RELOAD_FOR_INPUT_ADDRESS\n+\t\t    || rld[j].when_needed == RELOAD_FOR_OTHER_ADDRESS))\n \t      {\n-\t\treload_when_needed[i] = RELOAD_OTHER;\n-\t\treload_in[j] = 0;\n+\t\trld[i].when_needed = RELOAD_OTHER;\n+\t\trld[j].in = 0;\n \t\treload_spill_index[j] = -1;\n \t\ttransfer_replacements (i, j);\n \t      }\n@@ -6492,15 +6490,15 @@ merge_assigned_reloads (insn)\n \t     this test is equivalent to looking for reloads for this operand\n \t     number.  */\n \n-\t  if (reload_when_needed[i] == RELOAD_OTHER)\n+\t  if (rld[i].when_needed == RELOAD_OTHER)\n \t    for (j = 0; j < n_reloads; j++)\n-\t      if (reload_in[j] != 0\n-\t\t  && reload_when_needed[i] != RELOAD_OTHER\n-\t\t  && reg_overlap_mentioned_for_reload_p (reload_in[j],\n-\t\t\t\t\t\t\t reload_in[i]))\n-\t\treload_when_needed[j]\n-\t\t  = ((reload_when_needed[i] == RELOAD_FOR_INPUT_ADDRESS\n-\t\t      || reload_when_needed[i] == RELOAD_FOR_INPADDR_ADDRESS)\n+\t      if (rld[j].in != 0\n+\t\t  && rld[i].when_needed != RELOAD_OTHER\n+\t\t  && reg_overlap_mentioned_for_reload_p (rld[j].in,\n+\t\t\t\t\t\t\t rld[i].in))\n+\t\trld[j].when_needed\n+\t\t  = ((rld[i].when_needed == RELOAD_FOR_INPUT_ADDRESS\n+\t\t      || rld[i].when_needed == RELOAD_FOR_INPADDR_ADDRESS)\n \t\t     ? RELOAD_FOR_OTHER_ADDRESS : RELOAD_OTHER);\n \t}\n     }\n@@ -6555,28 +6553,28 @@ emit_reload_insns (chain)\n       rtx this_reload_insn = 0;\n       int expect_occurrences = 1;\n \n-      if (reload_reg_rtx[j]\n-\t  && REGNO (reload_reg_rtx[j]) < FIRST_PSEUDO_REGISTER)\n-\tnew_spill_reg_store[REGNO (reload_reg_rtx[j])] = 0;\n+      if (rld[j].reg_rtx\n+\t  && REGNO (rld[j].reg_rtx) < FIRST_PSEUDO_REGISTER)\n+\tnew_spill_reg_store[REGNO (rld[j].reg_rtx)] = 0;\n \n-      old = (reload_in[j] && GET_CODE (reload_in[j]) == MEM\n-\t     ? reload_in_reg[j] : reload_in[j]);\n+      old = (rld[j].in && GET_CODE (rld[j].in) == MEM\n+\t     ? rld[j].in_reg : rld[j].in);\n \n       if (old != 0\n \t  /* AUTO_INC reloads need to be handled even if inherited.  We got an\n \t     AUTO_INC reload if reload_out is set but reload_out_reg isn't.  */\n-\t  && (! reload_inherited[j] || (reload_out[j] && ! reload_out_reg[j]))\n-\t  && ! rtx_equal_p (reload_reg_rtx[j], old)\n-\t  && reload_reg_rtx[j] != 0)\n+\t  && (! reload_inherited[j] || (rld[j].out && ! rld[j].out_reg))\n+\t  && ! rtx_equal_p (rld[j].reg_rtx, old)\n+\t  && rld[j].reg_rtx != 0)\n \t{\n-\t  register rtx reloadreg = reload_reg_rtx[j];\n+\t  register rtx reloadreg = rld[j].reg_rtx;\n \t  rtx oldequiv = 0;\n \t  enum machine_mode mode;\n \t  rtx *where;\n \n \t  /* Determine the mode to reload in.\n \t     This is very tricky because we have three to choose from.\n-\t     There is the mode the insn operand wants (reload_inmode[J]).\n+\t     There is the mode the insn operand wants (rld[J].inmode).\n \t     There is the mode of the reload register RELOADREG.\n \t     There is the intrinsic mode of the operand, which we could find\n \t     by stripping some SUBREGs.\n@@ -6608,20 +6606,20 @@ emit_reload_insns (chain)\n \n \t  mode = GET_MODE (old);\n \t  if (mode == VOIDmode)\n-\t    mode = reload_inmode[j];\n+\t    mode = rld[j].inmode;\n \n #ifdef SECONDARY_INPUT_RELOAD_CLASS\n \t  /* If we need a secondary register for this operation, see if\n \t     the value is already in a register in that class.  Don't\n \t     do this if the secondary register will be used as a scratch\n \t     register.  */\n \n-\t  if (reload_secondary_in_reload[j] >= 0\n-\t      && reload_secondary_in_icode[j] == CODE_FOR_nothing\n+\t  if (rld[j].secondary_in_reload >= 0\n+\t      && rld[j].secondary_in_icode == CODE_FOR_nothing\n \t      && optimize)\n \t    oldequiv\n \t      = find_equiv_reg (old, insn,\n-\t\t\t\treload_reg_class[reload_secondary_in_reload[j]],\n+\t\t\t\trld[rld[j].secondary_in_reload].class,\n \t\t\t\t-1, NULL_PTR, 0, mode);\n #endif\n \n@@ -6647,9 +6645,9 @@ emit_reload_insns (chain)\n \n \t      /* Don't use OLDEQUIV if any other reload changes it at an\n \t\t earlier stage of this insn or at this stage.  */\n-\t      if (! reload_reg_free_for_value_p (regno, reload_opnum[j],\n-\t\t\t\t\t\t reload_when_needed[j],\n-\t\t\t\t\t\t reload_in[j], const0_rtx, j,\n+\t      if (! reload_reg_free_for_value_p (regno, rld[j].opnum,\n+\t\t\t\t\t\t rld[j].when_needed,\n+\t\t\t\t\t\t rld[j].in, const0_rtx, j,\n \t\t\t\t\t\t 0))\n \t\toldequiv = 0;\n \n@@ -6659,18 +6657,18 @@ emit_reload_insns (chain)\n \t\t or memory.   */\n \n \t      if (oldequiv != 0\n-\t\t  && ((REGNO_REG_CLASS (regno) != reload_reg_class[j]\n+\t\t  && ((REGNO_REG_CLASS (regno) != rld[j].class\n \t\t       && (REGISTER_MOVE_COST (REGNO_REG_CLASS (regno),\n-\t\t\t\t\t       reload_reg_class[j])\n-\t\t\t   >= MEMORY_MOVE_COST (mode, reload_reg_class[j], 1)))\n+\t\t\t\t\t       rld[j].class)\n+\t\t\t   >= MEMORY_MOVE_COST (mode, rld[j].class, 1)))\n #ifdef SECONDARY_INPUT_RELOAD_CLASS\n-\t\t      || (SECONDARY_INPUT_RELOAD_CLASS (reload_reg_class[j],\n+\t\t      || (SECONDARY_INPUT_RELOAD_CLASS (rld[j].class,\n \t\t\t\t\t\t\tmode, oldequiv)\n \t\t\t  != NO_REGS)\n #endif\n #ifdef SECONDARY_MEMORY_NEEDED\n \t\t      || SECONDARY_MEMORY_NEEDED (REGNO_REG_CLASS (regno),\n-\t\t\t\t\t\t  reload_reg_class[j],\n+\t\t\t\t\t\t  rld[j].class,\n \t\t\t\t\t\t  mode)\n #endif\n \t\t      ))\n@@ -6683,10 +6681,10 @@ emit_reload_insns (chain)\n \t     find the pseudo in RELOAD_IN_REG.  */\n \t  if (oldequiv == 0\n \t      && reload_override_in[j]\n-\t      && GET_CODE (reload_in_reg[j]) == REG)\n+\t      && GET_CODE (rld[j].in_reg) == REG)\n \t    {\n \t      oldequiv = old;\n-\t      old = reload_in_reg[j];\n+\t      old = rld[j].in_reg;\n \t    }\n \t  if (oldequiv == 0)\n \t    oldequiv = old;\n@@ -6705,7 +6703,7 @@ emit_reload_insns (chain)\n \t      && GET_CODE (old) == REG\n \t      && (dead_or_set_p (insn, spill_reg_stored_to[REGNO (oldequiv)])\n \t\t  || rtx_equal_p (spill_reg_stored_to[REGNO (oldequiv)],\n-\t\t\t\t  reload_out_reg[j])))\n+\t\t\t\t  rld[j].out_reg)))\n \t    delete_output_reload (insn, j, REGNO (oldequiv));\n \n \t  /* Encapsulate both RELOADREG and OLDEQUIV into that mode,\n@@ -6723,25 +6721,25 @@ emit_reload_insns (chain)\n \t    oldequiv = gen_rtx_SUBREG (mode, oldequiv, 0);\n \n \t  /* Switch to the right place to emit the reload insns.  */\n-\t  switch (reload_when_needed[j])\n+\t  switch (rld[j].when_needed)\n \t    {\n \t    case RELOAD_OTHER:\n \t      where = &other_input_reload_insns;\n \t      break;\n \t    case RELOAD_FOR_INPUT:\n-\t      where = &input_reload_insns[reload_opnum[j]];\n+\t      where = &input_reload_insns[rld[j].opnum];\n \t      break;\n \t    case RELOAD_FOR_INPUT_ADDRESS:\n-\t      where = &input_address_reload_insns[reload_opnum[j]];\n+\t      where = &input_address_reload_insns[rld[j].opnum];\n \t      break;\n \t    case RELOAD_FOR_INPADDR_ADDRESS:\n-\t      where = &inpaddr_address_reload_insns[reload_opnum[j]];\n+\t      where = &inpaddr_address_reload_insns[rld[j].opnum];\n \t      break;\n \t    case RELOAD_FOR_OUTPUT_ADDRESS:\n-\t      where = &output_address_reload_insns[reload_opnum[j]];\n+\t      where = &output_address_reload_insns[rld[j].opnum];\n \t      break;\n \t    case RELOAD_FOR_OUTADDR_ADDRESS:\n-\t      where = &outaddr_address_reload_insns[reload_opnum[j]];\n+\t      where = &outaddr_address_reload_insns[rld[j].opnum];\n \t      break;\n \t    case RELOAD_FOR_OPERAND_ADDRESS:\n \t      where = &operand_reload_insns;\n@@ -6760,18 +6758,18 @@ emit_reload_insns (chain)\n \t  special = 0;\n \n \t  /* Auto-increment addresses must be reloaded in a special way.  */\n-\t  if (reload_out[j] && ! reload_out_reg[j])\n+\t  if (rld[j].out && ! rld[j].out_reg)\n \t    {\n \t      /* We are not going to bother supporting the case where a\n \t\t incremented register can't be copied directly from\n \t\t OLDEQUIV since this seems highly unlikely.  */\n-\t      if (reload_secondary_in_reload[j] >= 0)\n+\t      if (rld[j].secondary_in_reload >= 0)\n \t\tabort ();\n \n \t      if (reload_inherited[j])\n \t\toldequiv = reloadreg;\n \n-\t      old = XEXP (reload_in_reg[j], 0);\n+\t      old = XEXP (rld[j].in_reg, 0);\n \n \t      if (optimize && GET_CODE (oldequiv) == REG\n \t\t  && REGNO (oldequiv) < FIRST_PSEUDO_REGISTER\n@@ -6787,8 +6785,8 @@ emit_reload_insns (chain)\n \t      special = 1;\n \t      /* Output a special code sequence for this case.  */\n \t      new_spill_reg_store[REGNO (reloadreg)]\n-\t\t= inc_for_reload (reloadreg, oldequiv, reload_out[j],\n-\t\t\t\t  reload_inc[j]);\n+\t\t= inc_for_reload (reloadreg, oldequiv, rld[j].out,\n+\t\t\t\t  rld[j].inc);\n \t    }\n \n \t  /* If we are reloading a pseudo-register that was set by the previous\n@@ -6801,9 +6799,9 @@ emit_reload_insns (chain)\n \t\t   /* This is unsafe if some other reload\n \t\t      uses the same reg first.  */\n \t\t   && reload_reg_free_for_value_p (REGNO (reloadreg),\n-\t\t\t\t\t\t   reload_opnum[j],\n-\t\t\t\t\t\t   reload_when_needed[j],\n-\t\t\t\t\t\t   old, reload_out[j],\n+\t\t\t\t\t\t   rld[j].opnum,\n+\t\t\t\t\t\t   rld[j].when_needed,\n+\t\t\t\t\t\t   old, rld[j].out,\n \t\t\t\t\t\t   j, 0))\n \t    {\n \t      rtx temp = PREV_INSN (insn);\n@@ -6843,7 +6841,7 @@ emit_reload_insns (chain)\n \t\t  if (REG_N_DEATHS (REGNO (old)) == 1\n \t\t      && REG_N_SETS (REGNO (old)) == 1)\n \t\t    {\n-\t\t      reg_renumber[REGNO (old)] = REGNO (reload_reg_rtx[j]);\n+\t\t      reg_renumber[REGNO (old)] = REGNO (rld[j].reg_rtx);\n \t\t      alter_reg (REGNO (old), -1);\n \t\t    }\n \t\t  special = 1;\n@@ -6869,9 +6867,9 @@ emit_reload_insns (chain)\n \t\t because we don't make such reloads when both the input and\n \t\t output need secondary reload registers.  */\n \n-\t      if (reload_secondary_in_reload[j] >= 0)\n+\t      if (rld[j].secondary_in_reload >= 0)\n \t\t{\n-\t\t  int secondary_reload = reload_secondary_in_reload[j];\n+\t\t  int secondary_reload = rld[j].secondary_in_reload;\n \t\t  rtx real_oldequiv = oldequiv;\n \t\t  rtx real_old = old;\n \t\t  rtx tmp;\n@@ -6900,7 +6898,7 @@ emit_reload_insns (chain)\n \t\t      if (! reg_equiv_mem[REGNO (tmp)]\n \t\t\t  || num_not_at_initial_offset\n \t\t\t  || GET_CODE (oldequiv) == SUBREG)\n-\t\t\treal_oldequiv = reload_in[j];\n+\t\t\treal_oldequiv = rld[j].in;\n \t\t      else\n \t\t\treal_oldequiv = reg_equiv_mem[REGNO (tmp)];\n \t\t    }\n@@ -6916,19 +6914,19 @@ emit_reload_insns (chain)\n \t\t      if (! reg_equiv_mem[REGNO (tmp)]\n \t\t\t  || num_not_at_initial_offset\n \t\t\t  || GET_CODE (old) == SUBREG)\n-\t\t\treal_old = reload_in[j];\n+\t\t\treal_old = rld[j].in;\n \t\t      else\n \t\t\treal_old = reg_equiv_mem[REGNO (tmp)];\n \t\t    }\n \n-\t\t  second_reload_reg = reload_reg_rtx[secondary_reload];\n-\t\t  icode = reload_secondary_in_icode[j];\n+\t\t  second_reload_reg = rld[secondary_reload].reg_rtx;\n+\t\t  icode = rld[j].secondary_in_icode;\n \n \t\t  if ((old != oldequiv && ! rtx_equal_p (old, oldequiv))\n-\t\t      || (reload_in[j] != 0 && reload_out[j] != 0))\n+\t\t      || (rld[j].in != 0 && rld[j].out != 0))\n \t\t    {\n \t\t      enum reg_class new_class\n-\t\t\t= SECONDARY_INPUT_RELOAD_CLASS (reload_reg_class[j],\n+\t\t\t= SECONDARY_INPUT_RELOAD_CLASS (rld[j].class,\n \t\t\t\t\t\t\tmode, real_oldequiv);\n \n \t\t      if (new_class == NO_REGS)\n@@ -6992,21 +6990,21 @@ emit_reload_insns (chain)\n \t\t\t  /* See if we need a scratch register to load the\n \t\t\t     intermediate register (a tertiary reload).  */\n \t\t\t  enum insn_code tertiary_icode\n-\t\t\t    = reload_secondary_in_icode[secondary_reload];\n+\t\t\t    = rld[secondary_reload].secondary_in_icode;\n \n \t\t\t  if (tertiary_icode != CODE_FOR_nothing)\n \t\t\t    {\n \t\t\t      rtx third_reload_reg\n-\t\t\t\t= reload_reg_rtx[reload_secondary_in_reload[secondary_reload]];\n+\t\t\t\t= rld[rld[secondary_reload].secondary_in_reload].reg_rtx;\n \n \t\t\t      emit_insn ((GEN_FCN (tertiary_icode)\n \t\t\t\t\t  (second_reload_reg, real_oldequiv,\n \t\t\t\t\t   third_reload_reg)));\n \t\t\t    }\n \t\t\t  else\n \t\t\t    gen_reload (second_reload_reg, real_oldequiv,\n-\t\t\t\t\treload_opnum[j],\n-\t\t\t\t\treload_when_needed[j]);\n+\t\t\t\t\trld[j].opnum,\n+\t\t\t\t\trld[j].when_needed);\n \n \t\t\t  oldequiv = second_reload_reg;\n \t\t\t}\n@@ -7030,9 +7028,9 @@ emit_reload_insns (chain)\n \t\t\t       [REGNO (SUBREG_REG (oldequiv))] != 0)\n \t\t\t      || (reg_equiv_constant\n \t\t\t\t  [REGNO (SUBREG_REG (oldequiv))] != 0))))\n-\t\t    real_oldequiv = reload_in[j];\n-\t\t  gen_reload (reloadreg, real_oldequiv, reload_opnum[j],\n-\t\t\t      reload_when_needed[j]);\n+\t\t    real_oldequiv = rld[j].in;\n+\t\t  gen_reload (reloadreg, real_oldequiv, rld[j].opnum,\n+\t\t\t      rld[j].when_needed);\n \t\t}\n \n \t    }\n@@ -7048,18 +7046,18 @@ emit_reload_insns (chain)\n \t    reload_override_in[j] = oldequiv;\n \t}\n \n-      /* When inheriting a wider reload, we have a MEM in reload_in[j],\n+      /* When inheriting a wider reload, we have a MEM in rld[j].in,\n \t e.g. inheriting a SImode output reload for\n \t (mem:HI (plus:SI (reg:SI 14 fp) (const_int 10)))  */\n-      if (optimize && reload_inherited[j] && reload_in[j]\n-\t  && GET_CODE (reload_in[j]) == MEM\n-\t  && GET_CODE (reload_in_reg[j]) == MEM\n+      if (optimize && reload_inherited[j] && rld[j].in\n+\t  && GET_CODE (rld[j].in) == MEM\n+\t  && GET_CODE (rld[j].in_reg) == MEM\n \t  && reload_spill_index[j] >= 0\n \t  && TEST_HARD_REG_BIT (reg_reloaded_valid, reload_spill_index[j]))\n \t{\n \t  expect_occurrences\n-\t    = count_occurrences (PATTERN (insn), reload_in[j]) == 1 ? 0 : -1;\n-\t  reload_in[j]\n+\t    = count_occurrences (PATTERN (insn), rld[j].in) == 1 ? 0 : -1;\n+\t  rld[j].in\n \t    = regno_reg_rtx[reg_reloaded_contents[reload_spill_index[j]]];\n \t}\n \n@@ -7069,28 +7067,28 @@ emit_reload_insns (chain)\n \n       if (optimize\n \t  && (reload_inherited[j] || reload_override_in[j])\n-\t  && reload_reg_rtx[j]\n-\t  && GET_CODE (reload_reg_rtx[j]) == REG\n-\t  && spill_reg_store[REGNO (reload_reg_rtx[j])] != 0\n+\t  && rld[j].reg_rtx\n+\t  && GET_CODE (rld[j].reg_rtx) == REG\n+\t  && spill_reg_store[REGNO (rld[j].reg_rtx)] != 0\n #if 0\n \t  /* There doesn't seem to be any reason to restrict this to pseudos\n \t     and doing so loses in the case where we are copying from a\n \t     register of the wrong class.  */\n-\t  && (REGNO (spill_reg_stored_to[REGNO (reload_reg_rtx[j])])\n+\t  && (REGNO (spill_reg_stored_to[REGNO (rld[j].reg_rtx)])\n \t      >= FIRST_PSEUDO_REGISTER)\n #endif\n \t  /* The insn might have already some references to stackslots\n \t     replaced by MEMs, while reload_out_reg still names the\n \t     original pseudo.  */\n \t  && (dead_or_set_p (insn,\n-\t\t\t     spill_reg_stored_to[REGNO (reload_reg_rtx[j])])\n-\t      || rtx_equal_p (spill_reg_stored_to[REGNO (reload_reg_rtx[j])],\n-\t\t\t      reload_out_reg[j])))\n-\tdelete_output_reload (insn, j, REGNO (reload_reg_rtx[j]));\n+\t\t\t     spill_reg_stored_to[REGNO (rld[j].reg_rtx)])\n+\t      || rtx_equal_p (spill_reg_stored_to[REGNO (rld[j].reg_rtx)],\n+\t\t\t      rld[j].out_reg)))\n+\tdelete_output_reload (insn, j, REGNO (rld[j].reg_rtx));\n \n       /* Input-reloading is done.  Now do output-reloading,\n \t storing the value from the reload-register after the main insn\n-\t if reload_out[j] is nonzero.\n+\t if rld[j].out is nonzero.\n \n \t ??? At some point we need to support handling output reloads of\n \t JUMP_INSNs or insns that set cc0.  */\n@@ -7099,11 +7097,11 @@ emit_reload_insns (chain)\n \t not loaded in this same reload, see if we can eliminate a previous\n \t store.  */\n       {\n-\trtx pseudo = reload_out_reg[j];\n+\trtx pseudo = rld[j].out_reg;\n \n \tif (pseudo\n \t    && GET_CODE (pseudo) == REG\n-\t    && ! rtx_equal_p (reload_in_reg[j], pseudo)\n+\t    && ! rtx_equal_p (rld[j].in_reg, pseudo)\n \t    && REGNO (pseudo) >= FIRST_PSEUDO_REGISTER\n \t    && reg_last_reload_reg[REGNO (pseudo)])\n \t  {\n@@ -7120,12 +7118,12 @@ emit_reload_insns (chain)\n \t  }\n       }\n \n-      old = reload_out_reg[j];\n+      old = rld[j].out_reg;\n       if (old != 0\n-\t  && reload_reg_rtx[j] != old\n-\t  && reload_reg_rtx[j] != 0)\n+\t  && rld[j].reg_rtx != old\n+\t  && rld[j].reg_rtx != 0)\n \t{\n-\t  register rtx reloadreg = reload_reg_rtx[j];\n+\t  register rtx reloadreg = rld[j].reg_rtx;\n #ifdef SECONDARY_OUTPUT_RELOAD_CLASS\n \t  register rtx second_reloadreg = 0;\n #endif\n@@ -7139,7 +7137,7 @@ emit_reload_insns (chain)\n \t  if ((GET_CODE (old) == REG || GET_CODE (old) == SCRATCH)\n \t      && (note = find_reg_note (insn, REG_UNUSED, old)) != 0)\n \t    {\n-\t      XEXP (note, 0) = reload_reg_rtx[j];\n+\t      XEXP (note, 0) = rld[j].reg_rtx;\n \t      continue;\n \t    }\n \t  /* Likewise for a SUBREG of an operand that dies.  */\n@@ -7149,7 +7147,7 @@ emit_reload_insns (chain)\n \t\t\t\t\t\t  SUBREG_REG (old))))\n \t    {\n \t      XEXP (note, 0) = gen_lowpart_common (GET_MODE (old),\n-\t\t\t\t\t\t   reload_reg_rtx[j]);\n+\t\t\t\t\t\t   rld[j].reg_rtx);\n \t      continue;\n \t    }\n \t  else if (GET_CODE (old) == SCRATCH)\n@@ -7171,12 +7169,12 @@ emit_reload_insns (chain)\n \t  if (GET_CODE (insn) == JUMP_INSN)\n \t    abort ();\n \n-\t  if (reload_when_needed[j] == RELOAD_OTHER)\n+\t  if (rld[j].when_needed == RELOAD_OTHER)\n \t    start_sequence ();\n \t  else\n-\t    push_to_sequence (output_reload_insns[reload_opnum[j]]);\n+\t    push_to_sequence (output_reload_insns[rld[j].opnum]);\n \n-\t  old = reload_out[j];\n+\t  old = rld[j].out;\n \n \t  /* Determine the mode to reload in.\n \t     See comments above (for input reloading).  */\n@@ -7203,26 +7201,26 @@ emit_reload_insns (chain)\n \t     one, since it will be stored into OLD.  We might need a secondary\n \t     register only for an input reload, so check again here.  */\n \n-\t  if (reload_secondary_out_reload[j] >= 0)\n+\t  if (rld[j].secondary_out_reload >= 0)\n \t    {\n \t      rtx real_old = old;\n \n \t      if (GET_CODE (old) == REG && REGNO (old) >= FIRST_PSEUDO_REGISTER\n \t\t  && reg_equiv_mem[REGNO (old)] != 0)\n \t\treal_old = reg_equiv_mem[REGNO (old)];\n \n-\t      if((SECONDARY_OUTPUT_RELOAD_CLASS (reload_reg_class[j],\n+\t      if((SECONDARY_OUTPUT_RELOAD_CLASS (rld[j].class,\n \t\t\t\t\t\t mode, real_old)\n \t\t  != NO_REGS))\n \t\t{\n \t\t  second_reloadreg = reloadreg;\n-\t\t  reloadreg = reload_reg_rtx[reload_secondary_out_reload[j]];\n+\t\t  reloadreg = rld[rld[j].secondary_out_reload].reg_rtx;\n \n \t\t  /* See if RELOADREG is to be used as a scratch register\n \t\t     or as an intermediate register.  */\n-\t\t  if (reload_secondary_out_icode[j] != CODE_FOR_nothing)\n+\t\t  if (rld[j].secondary_out_icode != CODE_FOR_nothing)\n \t\t    {\n-\t\t      emit_insn ((GEN_FCN (reload_secondary_out_icode[j])\n+\t\t      emit_insn ((GEN_FCN (rld[j].secondary_out_icode)\n \t\t\t\t  (real_old, second_reloadreg, reloadreg)));\n \t\t      special = 1;\n \t\t    }\n@@ -7231,17 +7229,17 @@ emit_reload_insns (chain)\n \t\t      /* See if we need both a scratch and intermediate reload\n \t\t\t register.  */\n \n-\t\t      int secondary_reload = reload_secondary_out_reload[j];\n+\t\t      int secondary_reload = rld[j].secondary_out_reload;\n \t\t      enum insn_code tertiary_icode\n-\t\t\t= reload_secondary_out_icode[secondary_reload];\n+\t\t\t= rld[secondary_reload].secondary_out_icode;\n \n \t\t      if (GET_MODE (reloadreg) != mode)\n \t\t\treloadreg = gen_rtx_REG (mode, REGNO (reloadreg));\n \n \t\t      if (tertiary_icode != CODE_FOR_nothing)\n \t\t\t{\n \t\t\t  rtx third_reloadreg\n-\t\t\t    = reload_reg_rtx[reload_secondary_out_reload[secondary_reload]];\n+\t\t\t    = rld[rld[secondary_reload].secondary_out_reload].reg_rtx;\n \t\t\t  rtx tem;\n \n \t\t\t  /* Copy primary reload reg to secondary reload reg.\n@@ -7260,7 +7258,7 @@ emit_reload_insns (chain)\n \t\t\t    real_old = SUBREG_REG (real_old), reloadreg = tem;\n \n \t\t\t  gen_reload (reloadreg, second_reloadreg,\n-\t\t\t\t      reload_opnum[j], reload_when_needed[j]);\n+\t\t\t\t      rld[j].opnum, rld[j].when_needed);\n \t\t\t  emit_insn ((GEN_FCN (tertiary_icode)\n \t\t\t\t      (real_old, reloadreg, third_reloadreg)));\n \t\t\t  special = 1;\n@@ -7271,7 +7269,7 @@ emit_reload_insns (chain)\n \t\t\t   OUT later.  */\n \n \t\t\tgen_reload (reloadreg, second_reloadreg,\n-\t\t\t\t    reload_opnum[j], reload_when_needed[j]);\n+\t\t\t\t    rld[j].opnum, rld[j].when_needed);\n \t\t    }\n \t\t}\n \t    }\n@@ -7290,8 +7288,8 @@ emit_reload_insns (chain)\n \t\t  || rtx_equal_p (old, SET_DEST (set))\n \t\t  || !reg_mentioned_p (old, SET_SRC (set))\n \t\t  || !regno_clobbered_p (REGNO (old), insn))\n-\t\tgen_reload (old, reloadreg, reload_opnum[j],\n-\t\t\t    reload_when_needed[j]);\n+\t\tgen_reload (old, reloadreg, rld[j].opnum,\n+\t\t\t    rld[j].when_needed);\n \t    }\n \n \t  /* Look at all insns we emitted, just to be safe.  */\n@@ -7306,12 +7304,12 @@ emit_reload_insns (chain)\n \t\t   reg_has_output_reload will make this do nothing.  */\n \t\tnote_stores (pat, forget_old_reloads_1);\n \n-\t\tif (reg_mentioned_p (reload_reg_rtx[j], pat))\n+\t\tif (reg_mentioned_p (rld[j].reg_rtx, pat))\n \t\t  {\n \t\t    rtx set = single_set (insn);\n \t\t    if (reload_spill_index[j] < 0\n \t\t\t&& set\n-\t\t\t&& SET_SRC (set) == reload_reg_rtx[j])\n+\t\t\t&& SET_SRC (set) == rld[j].reg_rtx)\n \t\t      {\n \t\t\tint src = REGNO (SET_SRC (set));\n \n@@ -7320,9 +7318,9 @@ emit_reload_insns (chain)\n \t\t\tif (find_regno_note (insn, REG_DEAD, src))\n \t\t\t  SET_HARD_REG_BIT (reg_reloaded_died, src);\n \t\t      }\n-\t\t    if (REGNO (reload_reg_rtx[j]) < FIRST_PSEUDO_REGISTER)\n+\t\t    if (REGNO (rld[j].reg_rtx) < FIRST_PSEUDO_REGISTER)\n \t\t      {\n-\t\t\tint s = reload_secondary_out_reload[j];\n+\t\t\tint s = rld[j].secondary_out_reload;\n \t\t\tset = single_set (p);\n \t\t\t/* If this reload copies only to the secondary reload\n \t\t\t   register, the secondary reload does the actual\n@@ -7332,17 +7330,17 @@ emit_reload_insns (chain)\n \t\t\t       has and where the actual store to the pseudo is\n \t\t\t       made; leave new_spill_reg_store alone.  */\n \t\t\telse if (s >= 0\n-\t\t\t\t && SET_SRC (set) == reload_reg_rtx[j]\n-\t\t\t\t && SET_DEST (set) == reload_reg_rtx[s])\n+\t\t\t\t && SET_SRC (set) == rld[j].reg_rtx\n+\t\t\t\t && SET_DEST (set) == rld[s].reg_rtx)\n \t\t\t  {\n \t\t\t    /* Usually the next instruction will be the\n \t\t\t       secondary reload insn;  if we can confirm\n \t\t\t       that it is, setting new_spill_reg_store to\n \t\t\t       that insn will allow an extra optimization.  */\n-\t\t\t    rtx s_reg = reload_reg_rtx[s];\n+\t\t\t    rtx s_reg = rld[s].reg_rtx;\n \t\t\t    rtx next = NEXT_INSN (p);\n-\t\t\t    reload_out[s] = reload_out[j];\n-\t\t\t    reload_out_reg[s] = reload_out_reg[j];\n+\t\t\t    rld[s].out = rld[j].out;\n+\t\t\t    rld[s].out_reg = rld[j].out_reg;\n \t\t\t    set = single_set (next);\n \t\t\t    if (set && SET_SRC (set) == s_reg\n \t\t\t\t&& ! new_spill_reg_store[REGNO (s_reg)])\n@@ -7353,18 +7351,18 @@ emit_reload_insns (chain)\n \t\t\t      }\n \t\t\t  }\n \t\t\telse\n-\t\t\t  new_spill_reg_store[REGNO (reload_reg_rtx[j])] = p;\n+\t\t\t  new_spill_reg_store[REGNO (rld[j].reg_rtx)] = p;\n \t\t      }\n \t\t  }\n \t      }\n \n-\t  if (reload_when_needed[j] == RELOAD_OTHER)\n+\t  if (rld[j].when_needed == RELOAD_OTHER)\n \t    {\n-\t      emit_insns (other_output_reload_insns[reload_opnum[j]]);\n-\t      other_output_reload_insns[reload_opnum[j]] = get_insns ();\n+\t      emit_insns (other_output_reload_insns[rld[j].opnum]);\n+\t      other_output_reload_insns[rld[j].opnum] = get_insns ();\n \t    }\n \t  else\n-\t    output_reload_insns[reload_opnum[j]] = get_insns ();\n+\t    output_reload_insns[rld[j].opnum] = get_insns ();\n \n \t  end_sequence ();\n \t}\n@@ -7440,10 +7438,10 @@ emit_reload_insns (chain)\n \t clear any memory of a previous store to the same pseudo.  Only do\n \t something if there will not be an output reload for the pseudo\n \t being reloaded.  */\n-      if (reload_in_reg[r] != 0\n+      if (rld[r].in_reg != 0\n \t  && ! (reload_inherited[r] || reload_override_in[r]))\n \t{\n-\t  rtx reg = reload_in_reg[r];\n+\t  rtx reg = rld[r].in_reg;\n \n \t  if (GET_CODE (reg) == SUBREG)\n \t    reg = SUBREG_REG (reg);\n@@ -7465,13 +7463,13 @@ emit_reload_insns (chain)\n \t}\n \n       /* I is nonneg if this reload used a register.\n-\t If reload_reg_rtx[r] is 0, this is an optional reload\n+\t If rld[r].reg_rtx is 0, this is an optional reload\n \t that we opted to ignore.  */\n \n-      if (i >= 0 && reload_reg_rtx[r] != 0)\n+      if (i >= 0 && rld[r].reg_rtx != 0)\n \t{\n \t  int nr\n-\t    = HARD_REGNO_NREGS (i, GET_MODE (reload_reg_rtx[r]));\n+\t    = HARD_REGNO_NREGS (i, GET_MODE (rld[r].reg_rtx));\n \t  int k;\n \t  int part_reaches_end = 0;\n \t  int all_reaches_end = 1;\n@@ -7480,8 +7478,8 @@ emit_reload_insns (chain)\n \t     of the value lives to the end.  */\n \t  for (k = 0; k < nr; k++)\n \t    {\n-\t      if (reload_reg_reaches_end_p (i + k, reload_opnum[r],\n-\t\t\t\t\t    reload_when_needed[r]))\n+\t      if (reload_reg_reaches_end_p (i + k, rld[r].opnum,\n+\t\t\t\t\t    rld[r].when_needed))\n \t\tpart_reaches_end = 1;\n \t      else\n \t\tall_reaches_end = 0;\n@@ -7498,26 +7496,26 @@ emit_reload_insns (chain)\n \t\tCLEAR_HARD_REG_BIT (reg_reloaded_valid, i + k);\n \n \t      /* Maybe the spill reg contains a copy of reload_out.  */\n-\t      if (reload_out[r] != 0\n-\t\t  && (GET_CODE (reload_out[r]) == REG\n+\t      if (rld[r].out != 0\n+\t\t  && (GET_CODE (rld[r].out) == REG\n #ifdef AUTO_INC_DEC\n-\t\t      || ! reload_out_reg[r]\n+\t\t      || ! rld[r].out_reg\n #endif\n-\t\t      || GET_CODE (reload_out_reg[r]) == REG))\n+\t\t      || GET_CODE (rld[r].out_reg) == REG))\n \t\t{\n-\t\t  rtx out = (GET_CODE (reload_out[r]) == REG\n-\t\t\t     ? reload_out[r]\n-\t\t\t     : reload_out_reg[r]\n-\t\t\t     ? reload_out_reg[r]\n-/* AUTO_INC */\t\t     : XEXP (reload_in_reg[r], 0));\n+\t\t  rtx out = (GET_CODE (rld[r].out) == REG\n+\t\t\t     ? rld[r].out\n+\t\t\t     : rld[r].out_reg\n+\t\t\t     ? rld[r].out_reg\n+/* AUTO_INC */\t\t     : XEXP (rld[r].in_reg, 0));\n \t\t  register int nregno = REGNO (out);\n \t\t  int nnr = (nregno >= FIRST_PSEUDO_REGISTER ? 1\n \t\t\t     : HARD_REGNO_NREGS (nregno,\n-\t\t\t\t\t\t GET_MODE (reload_reg_rtx[r])));\n+\t\t\t\t\t\t GET_MODE (rld[r].reg_rtx)));\n \n \t\t  spill_reg_store[i] = new_spill_reg_store[i];\n \t\t  spill_reg_stored_to[i] = out;\n-\t\t  reg_last_reload_reg[nregno] = reload_reg_rtx[r];\n+\t\t  reg_last_reload_reg[nregno] = rld[r].reg_rtx;\n \n \t\t  /* If NREGNO is a hard register, it may occupy more than\n \t\t     one register.  If it does, say what is in the\n@@ -7529,8 +7527,8 @@ emit_reload_insns (chain)\n \t\t    for (k = 1; k < nnr; k++)\n \t\t      reg_last_reload_reg[nregno + k]\n \t\t\t= (nr == nnr\n-\t\t\t   ? gen_rtx_REG (reg_raw_mode[REGNO (reload_reg_rtx[r]) + k],\n-\t\t\t\t\t  REGNO (reload_reg_rtx[r]) + k)\n+\t\t\t   ? gen_rtx_REG (reg_raw_mode[REGNO (rld[r].reg_rtx) + k],\n+\t\t\t\t\t  REGNO (rld[r].reg_rtx) + k)\n \t\t\t   : 0);\n \n \t\t  /* Now do the inverse operation.  */\n@@ -7549,46 +7547,46 @@ emit_reload_insns (chain)\n \t      /* Maybe the spill reg contains a copy of reload_in.  Only do\n \t\t something if there will not be an output reload for\n \t\t the register being reloaded.  */\n-\t      else if (reload_out_reg[r] == 0\n-\t\t       && reload_in[r] != 0\n-\t\t       && ((GET_CODE (reload_in[r]) == REG\n-\t\t\t    && REGNO (reload_in[r]) >= FIRST_PSEUDO_REGISTER\n-\t\t\t    && ! reg_has_output_reload[REGNO (reload_in[r])])\n-\t\t\t   || (GET_CODE (reload_in_reg[r]) == REG\n-\t\t\t       && ! reg_has_output_reload[REGNO (reload_in_reg[r])]))\n-\t\t       && ! reg_set_p (reload_reg_rtx[r], PATTERN (insn)))\n+\t      else if (rld[r].out_reg == 0\n+\t\t       && rld[r].in != 0\n+\t\t       && ((GET_CODE (rld[r].in) == REG\n+\t\t\t    && REGNO (rld[r].in) >= FIRST_PSEUDO_REGISTER\n+\t\t\t    && ! reg_has_output_reload[REGNO (rld[r].in)])\n+\t\t\t   || (GET_CODE (rld[r].in_reg) == REG\n+\t\t\t       && ! reg_has_output_reload[REGNO (rld[r].in_reg)]))\n+\t\t       && ! reg_set_p (rld[r].reg_rtx, PATTERN (insn)))\n \t\t{\n \t\t  register int nregno;\n \t\t  int nnr;\n \n-\t\t  if (GET_CODE (reload_in[r]) == REG\n-\t\t      && REGNO (reload_in[r]) >= FIRST_PSEUDO_REGISTER)\n-\t\t    nregno = REGNO (reload_in[r]);\n-\t\t  else if (GET_CODE (reload_in_reg[r]) == REG)\n-\t\t    nregno = REGNO (reload_in_reg[r]);\n+\t\t  if (GET_CODE (rld[r].in) == REG\n+\t\t      && REGNO (rld[r].in) >= FIRST_PSEUDO_REGISTER)\n+\t\t    nregno = REGNO (rld[r].in);\n+\t\t  else if (GET_CODE (rld[r].in_reg) == REG)\n+\t\t    nregno = REGNO (rld[r].in_reg);\n \t\t  else\n-\t\t    nregno = REGNO (XEXP (reload_in_reg[r], 0));\n+\t\t    nregno = REGNO (XEXP (rld[r].in_reg, 0));\n \n \t\t  nnr = (nregno >= FIRST_PSEUDO_REGISTER ? 1\n \t\t\t : HARD_REGNO_NREGS (nregno,\n-\t\t\t\t\t     GET_MODE (reload_reg_rtx[r])));\n+\t\t\t\t\t     GET_MODE (rld[r].reg_rtx)));\n \n-\t\t  reg_last_reload_reg[nregno] = reload_reg_rtx[r];\n+\t\t  reg_last_reload_reg[nregno] = rld[r].reg_rtx;\n \n \t\t  if (nregno < FIRST_PSEUDO_REGISTER)\n \t\t    for (k = 1; k < nnr; k++)\n \t\t      reg_last_reload_reg[nregno + k]\n \t\t\t= (nr == nnr\n-\t\t\t   ? gen_rtx_REG (reg_raw_mode[REGNO (reload_reg_rtx[r]) + k],\n-\t\t\t\t\t  REGNO (reload_reg_rtx[r]) + k)\n+\t\t\t   ? gen_rtx_REG (reg_raw_mode[REGNO (rld[r].reg_rtx) + k],\n+\t\t\t\t\t  REGNO (rld[r].reg_rtx) + k)\n \t\t\t   : 0);\n \n \t\t  /* Unless we inherited this reload, show we haven't\n \t\t     recently done a store.\n \t\t     Previous stores of inherited auto_inc expressions\n \t\t     also have to be discarded.  */\n \t\t  if (! reload_inherited[r]\n-\t\t      || (reload_out[r] && ! reload_out_reg[r]))\n+\t\t      || (rld[r].out && ! rld[r].out_reg))\n \t\t    spill_reg_store[i] = 0;\n \n \t\t  for (k = 0; k < nr; k++)\n@@ -7610,8 +7608,8 @@ emit_reload_insns (chain)\n \t    {\n \t      for (k = 0; k < nr; k++)\n \t\tif (reload_reg_reaches_end_p (i + k,\n-\t\t\t\t\t      reload_opnum[r],\n-\t\t\t\t\t      reload_when_needed[r]))\n+\t\t\t\t\t      rld[r].opnum,\n+\t\t\t\t\t      rld[r].when_needed))\n \t\t  CLEAR_HARD_REG_BIT (reg_reloaded_valid, i + k);\n \t    }\n \t}\n@@ -7624,13 +7622,13 @@ emit_reload_insns (chain)\n \t that invalidates any previous reloaded copy of it.\n \t But forget_old_reloads_1 won't get to see it, because\n \t it thinks only about the original insn.  So invalidate it here.  */\n-      if (i < 0 && reload_out[r] != 0\n-\t  && (GET_CODE (reload_out[r]) == REG\n-\t      || (GET_CODE (reload_out[r]) == MEM\n-\t\t  && GET_CODE (reload_out_reg[r]) == REG)))\n+      if (i < 0 && rld[r].out != 0\n+\t  && (GET_CODE (rld[r].out) == REG\n+\t      || (GET_CODE (rld[r].out) == MEM\n+\t\t  && GET_CODE (rld[r].out_reg) == REG)))\n \t{\n-\t  rtx out = (GET_CODE (reload_out[r]) == REG\n-\t\t     ? reload_out[r] : reload_out_reg[r]);\n+\t  rtx out = (GET_CODE (rld[r].out) == REG\n+\t\t     ? rld[r].out : rld[r].out_reg);\n \t  register int nregno = REGNO (out);\n \t  if (nregno >= FIRST_PSEUDO_REGISTER)\n \t    {\n@@ -7641,24 +7639,24 @@ emit_reload_insns (chain)\n \t      /* If we can find a hard register that is stored, record\n \t\t the storing insn so that we may delete this insn with\n \t\t delete_output_reload.  */\n-\t      src_reg = reload_reg_rtx[r];\n+\t      src_reg = rld[r].reg_rtx;\n \n \t      /* If this is an optional reload, try to find the source reg\n \t\t from an input reload.  */\n \t      if (! src_reg)\n \t\t{\n \t\t  rtx set = single_set (insn);\n-\t\t  if (set && SET_DEST (set) == reload_out[r])\n+\t\t  if (set && SET_DEST (set) == rld[r].out)\n \t\t    {\n \t\t      int k;\n \n \t\t      src_reg = SET_SRC (set);\n \t\t      store_insn = insn;\n \t\t      for (k = 0; k < n_reloads; k++)\n \t\t\t{\n-\t\t\t  if (reload_in[k] == src_reg)\n+\t\t\t  if (rld[k].in == src_reg)\n \t\t\t    {\n-\t\t\t      src_reg = reload_reg_rtx[k];\n+\t\t\t      src_reg = rld[k].reg_rtx;\n \t\t\t      break;\n \t\t\t    }\n \t\t\t}\n@@ -7697,7 +7695,7 @@ emit_reload_insns (chain)\n \t    }\n \t  else\n \t    {\n-\t      int num_regs = HARD_REGNO_NREGS (nregno,GET_MODE (reload_out[r]));\n+\t      int num_regs = HARD_REGNO_NREGS (nregno,GET_MODE (rld[r].out));\n \n \t      while (num_regs-- > 0)\n \t\treg_last_reload_reg[nregno + num_regs] = 0;\n@@ -7731,9 +7729,9 @@ gen_reload (out, in, opnum, type)\n       && (tem = gen_lowpart_common (GET_MODE (SUBREG_REG (in)), out)) != 0)\n     in = SUBREG_REG (in), out = tem;\n   else if (GET_CODE (out) == SUBREG\n-      && (GET_MODE_SIZE (GET_MODE (out))\n-\t  > GET_MODE_SIZE (GET_MODE (SUBREG_REG (out))))\n-      && (tem = gen_lowpart_common (GET_MODE (SUBREG_REG (out)), in)) != 0)\n+\t   && (GET_MODE_SIZE (GET_MODE (out))\n+\t       > GET_MODE_SIZE (GET_MODE (SUBREG_REG (out))))\n+\t   && (tem = gen_lowpart_common (GET_MODE (SUBREG_REG (out)), in)) != 0)\n     out = SUBREG_REG (out), in = tem;\n \n   /* How to do this reload can get quite tricky.  Normally, we are being\n@@ -7960,14 +7958,14 @@ delete_output_reload (insn, j, last_reload_reg)\n      insn than it is inherited.  */\n   for (k = n_reloads - 1; k >= 0; k--)\n     {\n-      rtx reg2 = reload_in[k];\n+      rtx reg2 = rld[k].in;\n       if (! reg2)\n \tcontinue;\n       if (GET_CODE (reg2) == MEM || reload_override_in[k])\n-\treg2 = reload_in_reg[k];\n+\treg2 = rld[k].in_reg;\n #ifdef AUTO_INC_DEC\n-      if (reload_out[k] && ! reload_out_reg[k])\n-\treg2 = XEXP (reload_in_reg[k], 0);\n+      if (rld[k].out && ! rld[k].out_reg)\n+\treg2 = XEXP (rld[k].in_reg, 0);\n #endif\n       while (GET_CODE (reg2) == SUBREG)\n \treg2 = SUBREG_REG (reg2);\n@@ -7976,7 +7974,7 @@ delete_output_reload (insn, j, last_reload_reg)\n \t  if (reload_inherited[k] || reload_override_in[k] || k == j)\n \t    {\n \t      n_inherited++;\n-\t      reg2 = reload_out_reg[k];\n+\t      reg2 = rld[k].out_reg;\n \t      if (! reg2)\n \t\tcontinue;\n \t      while (GET_CODE (reg2) == SUBREG)\n@@ -8029,7 +8027,7 @@ delete_output_reload (insn, j, last_reload_reg)\n      See if the pseudo reg has been completely replaced\n      with reload regs.  If so, delete the store insn\n      and forget we had a stack slot for the pseudo.  */\n-  if (reload_out[j] != reload_in[j]\n+  if (rld[j].out != rld[j].in\n       && REG_N_DEATHS (REGNO (reg)) == 1\n       && REG_N_SETS (REGNO (reg)) == 1\n       && REG_BASIC_BLOCK (REGNO (reg)) >= 0\n@@ -8087,7 +8085,7 @@ delete_output_reload (insn, j, last_reload_reg)\n \n       /* For the debugging info,\n \t say the pseudo lives in this reload reg.  */\n-      reg_renumber[REGNO (reg)] = REGNO (reload_reg_rtx[j]);\n+      reg_renumber[REGNO (reg)] = REGNO (rld[j].reg_rtx);\n       alter_reg (REGNO (reg), -1);\n     }\n   delete_address_reloads (output_reload_insn, insn);\n@@ -8208,11 +8206,11 @@ delete_address_reloads_1 (dead_insn, x, current_insn)\n \t      if (i2 == current_insn)\n \t\t{\n \t\t  for (j = n_reloads - 1; j >= 0; j--)\n-\t\t    if ((reload_reg_rtx[j] == dst && reload_inherited[j])\n+\t\t    if ((rld[j].reg_rtx == dst && reload_inherited[j])\n \t\t\t|| reload_override_in[j] == dst)\n \t\t      return;\n \t\t  for (j = n_reloads - 1; j >= 0; j--)\n-\t\t    if (reload_in[j] && reload_reg_rtx[j] == dst)\n+\t\t    if (rld[j].in && rld[j].reg_rtx == dst)\n \t\t      break;\n \t\t  if (j >= 0)\n \t\t    break;\n@@ -8227,7 +8225,7 @@ delete_address_reloads_1 (dead_insn, x, current_insn)\n \t  if (i2 == current_insn)\n \t    {\n \t      for (j = n_reloads - 1; j >= 0; j--)\n-\t\tif ((reload_reg_rtx[j] == dst && reload_inherited[j])\n+\t\tif ((rld[j].reg_rtx == dst && reload_inherited[j])\n \t\t    || reload_override_in[j] == dst)\n \t\t  return;\n \t      /* ??? We can't finish the loop here, because dst might be\n@@ -9638,13 +9636,13 @@ reload_combine ()\n       reload_combine_ruid++;\n \n       /* Look for (set (REGX) (CONST_INT))\n-\t\t  (set (REGX) (PLUS (REGX) (REGY)))\n-\t\t  ...\n-\t\t  ... (MEM (REGX)) ...\n+\t (set (REGX) (PLUS (REGX) (REGY)))\n+\t ...\n+\t ... (MEM (REGX)) ...\n \t and convert it to\n-\t\t  (set (REGZ) (CONST_INT))\n-\t\t  ...\n-\t\t  ... (MEM (PLUS (REGZ) (REGY)))... .\n+\t (set (REGZ) (CONST_INT))\n+\t ...\n+\t ... (MEM (PLUS (REGZ) (REGY)))... .\n \n \t First, check that we have (set (REGX) (PLUS (REGX) (REGY)))\n \t and that we know all uses of REGX before it dies.  */"}]}