{"sha": "a2ea37fb4c8084421784c80bfd1a4e065980314c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTJlYTM3ZmI0YzgwODQ0MjE3ODRjODBiZmQxYTRlMDY1OTgwMzE0Yw==", "commit": {"author": {"name": "Andrew Burgess", "email": "andrew.burgess@embecosm.com", "date": "2016-11-16T22:10:52Z"}, "committer": {"name": "Andrew Burgess", "email": "aburgess@gcc.gnu.org", "date": "2016-11-16T22:10:52Z"}, "message": "gcc: remove unneeded global related to hot/cold partitioning\n\nThe `user_defined_section_attribute' is used as part of the condition to\ndetermine if GCC should partition blocks within a function into hot and\ncold blocks.  This global is initially false, and is set to true from\nwithin the file parse phase of GCC, as part of the attribute handling\nhook.\n\nThe `user_defined_section_attribute' is reset to false as part of the\nfinal pass of GCC.  However, the final pass is part of the optimisation\nphase of the compiler, and so if at any point during the file parse\nphase any function, or data, has a section attribute the global\n`user_defined_section_attribute' will be set to true.\n\nWhen GCC performs the block partitioning pass on the first function, if\n`user_defined_section_attribute' is true then the function will not be\npartitioned.  Notice though, that due to the above, whether we partition\nthis first function or not has nothing to do with whether the function\nhas a section attribute, instead, if any function or data in the parsed\nfile has a section attribute then we don't partition the first\nfunction.\n\nAfter performing (or not) the block partitioning pass on the first\nfunction we perform the final pass on the first function, at which point\nwe reset `user_defined_section_attribute' to false.  As parsing is\ncomplete by this point, we will never set\n`user_defined_section_attribute' to true after that, and so all of the\nfollowing functions will have the partition blocks pass performed on\nthem, even if the function has a section attribute, and will not be\npartitioned.\n\nLuckily we don't end up partitioning functions that should not be\npartitioned though.  Due to the way that functions are selected during\nthe assembler writing phase, if a function has a section attribute this\ntakes priority over any hot/cold block partitioning that has been done.\n\nWhat we see from the above then is that the\n`user_defined_section_attribute' mechanism is broken.  It was originally\ncreated when GCC parsed, optimised, and generated assembler function at\na time.  Now that we deal with the whole file in one go, we need to\nupdate the mechanism used to gate the block partitioning pass.\n\nThis patch does this by looking specifically for a section attribute on\nthe function DECL, which removes the need for a global variable, and\nwill work whether we parse the whole file in one go, or one function at\na time.\n\nA few new tests have been added.  These check for the case where a\nfunction is not partitioned when it could be.\n\ngcc/ChangeLog:\n\n\t* gcc/bb-reorder.c: Remove 'toplev.h' include.\n\t(pass_partition_blocks::gate): No longer check\n\tuser_defined_section_attribute, instead check the function decl\n\tfor a section attribute.\n\t* gcc/c-family/c-attribs.c (handle_section_attribute): No longer\n\tset user_defined_section_attribute.\n\t* gcc/final.c (rest_of_handle_final): Likewise.\n\t* gcc/toplev.c: Remove definition of user_defined_section_attribute.\n\t* gcc/toplev.h: Remove declaration of\n\tuser_defined_section_attribute.\n\ngcc/testsuiteChangeLog:\n\n\t* gcc.dg/tree-prof/section-attr-1.c: New file.\n\t* gcc.dg/tree-prof/section-attr-2.c: New file.\n\t* gcc.dg/tree-prof/section-attr-3.c: New file.\n\nFrom-SVN: r242519", "tree": {"sha": "65afad1bdb61bac43a43cff8caf2ad6b9ce66633", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/65afad1bdb61bac43a43cff8caf2ad6b9ce66633"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a2ea37fb4c8084421784c80bfd1a4e065980314c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2ea37fb4c8084421784c80bfd1a4e065980314c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2ea37fb4c8084421784c80bfd1a4e065980314c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2ea37fb4c8084421784c80bfd1a4e065980314c/comments", "author": {"login": "T-J-Teru", "id": 475372, "node_id": "MDQ6VXNlcjQ3NTM3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4", "gravatar_id": "", "url": "https://api.github.com/users/T-J-Teru", "html_url": "https://github.com/T-J-Teru", "followers_url": "https://api.github.com/users/T-J-Teru/followers", "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}", "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}", "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions", "organizations_url": "https://api.github.com/users/T-J-Teru/orgs", "repos_url": "https://api.github.com/users/T-J-Teru/repos", "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}", "received_events_url": "https://api.github.com/users/T-J-Teru/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d174eb6541dc457ada0297dfbbb904cc563b5437", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d174eb6541dc457ada0297dfbbb904cc563b5437", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d174eb6541dc457ada0297dfbbb904cc563b5437"}], "stats": {"total": 170, "additions": 154, "deletions": 16}, "files": [{"sha": "bd70d4ea54d95e0454c86d369b680bf4c694e333", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea37fb4c8084421784c80bfd1a4e065980314c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea37fb4c8084421784c80bfd1a4e065980314c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a2ea37fb4c8084421784c80bfd1a4e065980314c", "patch": "@@ -1,3 +1,16 @@\n+2016-11-16  Andrew Burgess  <andrew.burgess@embecosm.com>\n+\n+\t* gcc/bb-reorder.c: Remove 'toplev.h' include.\n+\t(pass_partition_blocks::gate): No longer check\n+\tuser_defined_section_attribute, instead check the function decl\n+\tfor a section attribute.\n+\t* gcc/c-family/c-attribs.c (handle_section_attribute): No longer\n+\tset user_defined_section_attribute.\n+\t* gcc/final.c (rest_of_handle_final): Likewise.\n+\t* gcc/toplev.c: Remove definition of user_defined_section_attribute.\n+\t* gcc/toplev.h: Remove declaration of\n+\tuser_defined_section_attribute.\n+\n 2016-11-16  Maciej W. Rozycki  <macro@imgtec.com>\n \n \t* config/mips/mips.md (casesi_internal_mips16_<mode>):"}, {"sha": "e51ec085ca01d2da6095316eb576118680f679a3", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea37fb4c8084421784c80bfd1a4e065980314c/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea37fb4c8084421784c80bfd1a4e065980314c/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=a2ea37fb4c8084421784c80bfd1a4e065980314c", "patch": "@@ -107,7 +107,6 @@\n #include \"output.h\"\n #include \"expr.h\"\n #include \"params.h\"\n-#include \"toplev.h\" /* user_defined_section_attribute */\n #include \"tree-pass.h\"\n #include \"cfgrtl.h\"\n #include \"cfganal.h\"\n@@ -2894,7 +2893,7 @@ pass_partition_blocks::gate (function *fun)\n \t     we are going to omit the reordering.  */\n \t  && optimize_function_for_speed_p (fun)\n \t  && !DECL_COMDAT_GROUP (current_function_decl)\n-\t  && !user_defined_section_attribute);\n+\t  && !lookup_attribute (\"section\", DECL_ATTRIBUTES (fun->decl)));\n }\n \n unsigned"}, {"sha": "964efe94bb7261696abcde97e99c5db9c7906a0b", "filename": "gcc/c-family/c-attribs.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea37fb4c8084421784c80bfd1a4e065980314c/gcc%2Fc-family%2Fc-attribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea37fb4c8084421784c80bfd1a4e065980314c/gcc%2Fc-family%2Fc-attribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-attribs.c?ref=a2ea37fb4c8084421784c80bfd1a4e065980314c", "patch": "@@ -1438,8 +1438,6 @@ handle_section_attribute (tree *node, tree ARG_UNUSED (name), tree args,\n       goto fail;\n     }\n \n-  user_defined_section_attribute = true;\n-\n   if (!VAR_OR_FUNCTION_DECL_P (decl))\n     {\n       error (\"section attribute not allowed for %q+D\", *node);"}, {"sha": "d3a53c3cbe6b51af9035d32f89bcb18b11221c91", "filename": "gcc/final.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea37fb4c8084421784c80bfd1a4e065980314c/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea37fb4c8084421784c80bfd1a4e065980314c/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=a2ea37fb4c8084421784c80bfd1a4e065980314c", "patch": "@@ -4484,8 +4484,6 @@ rest_of_handle_final (void)\n \n   assemble_end_function (current_function_decl, fnname);\n \n-  user_defined_section_attribute = false;\n-\n   /* Free up reg info memory.  */\n   free_reg_info ();\n "}, {"sha": "8958f86b898e556ffd1f681238a9c6cc2bc729d2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea37fb4c8084421784c80bfd1a4e065980314c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea37fb4c8084421784c80bfd1a4e065980314c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a2ea37fb4c8084421784c80bfd1a4e065980314c", "patch": "@@ -1,3 +1,9 @@\n+2016-11-16  Andrew Burgess  <andrew.burgess@embecosm.com>\n+\n+\t* gcc.dg/tree-prof/section-attr-1.c: New file.\n+\t* gcc.dg/tree-prof/section-attr-2.c: New file.\n+\t* gcc.dg/tree-prof/section-attr-3.c: New file.\n+\n 2016-11-16  Maciej W. Rozycki  <macro@imgtec.com>\n \n \t* gcc.target/mips/code-readable-4.c (dg-final): Expect `dla'"}, {"sha": "ee6662ea6e553c2d0b9f9fca4c0c386c80ee96ef", "filename": "gcc/testsuite/gcc.dg/tree-prof/section-attr-1.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea37fb4c8084421784c80bfd1a4e065980314c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fsection-attr-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea37fb4c8084421784c80bfd1a4e065980314c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fsection-attr-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fsection-attr-1.c?ref=a2ea37fb4c8084421784c80bfd1a4e065980314c", "patch": "@@ -0,0 +1,45 @@\n+/* Checks for a bug where a function with a section attribute would prevent\n+   all later functions from being partitioned into hot and cold blocks.  */\n+/* { dg-require-effective-target freorder } */\n+/* { dg-options \"-O2 -fno-profile-reorder-functions -freorder-blocks-and-partition -save-temps\" } */\n+\n+#define SIZE 10000\n+\n+#define NOINLINE __attribute__((noinline)) __attribute__ ((noclone))\n+\n+const char *sarr[SIZE];\n+const char *buf_hot;\n+const char *buf_cold;\n+\n+void foo (int path);\n+\n+__attribute__((section(\".text\")))\n+int\n+main (int argc, char *argv[])\n+{\n+  int i;\n+  buf_hot =  \"hello\";\n+  buf_cold = \"world\";\n+  for (i = 0; i < 1000000; i++)\n+    foo (argc);\n+  return 0;\n+}\n+\n+\n+void NOINLINE\n+foo (int path)\n+{\n+  int i;\n+  if (path)\n+    {\n+      for (i = 0; i < SIZE; i++)\n+\tsarr[i] = buf_hot;\n+    }\n+  else\n+    {\n+      for (i = 0; i < SIZE; i++)\n+\tsarr[i] = buf_cold;\n+    }\n+}\n+\n+/* { dg-final-use { scan-assembler \"\\.section\\[\\t \\]*\\.text\\.unlikely\\[\\\\n\\\\r\\]+\\[\\t \\]*\\.size\\[\\t \\]*foo\\.cold\\.0\" { target *-*-linux* *-*-gnu* } } } */"}, {"sha": "898a395cd7ebfb70d667920f671edaea490eac88", "filename": "gcc/testsuite/gcc.dg/tree-prof/section-attr-2.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea37fb4c8084421784c80bfd1a4e065980314c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fsection-attr-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea37fb4c8084421784c80bfd1a4e065980314c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fsection-attr-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fsection-attr-2.c?ref=a2ea37fb4c8084421784c80bfd1a4e065980314c", "patch": "@@ -0,0 +1,44 @@\n+/* Checks for a bug where static data with a section attribute within a\n+   function would stop the function being partitioned into hot and cold\n+   blocks.  */\n+/* { dg-require-effective-target freorder } */\n+/* { dg-options \"-O2 -fno-profile-reorder-functions -freorder-blocks-and-partition -save-temps\" } */\n+\n+#define SIZE 10000\n+\n+#define NOINLINE __attribute__((noinline)) __attribute__ ((noclone))\n+\n+const char *sarr[SIZE];\n+const char *buf_hot;\n+const char *buf_cold;\n+\n+void foo (int path);\n+\n+int\n+main (int argc, char *argv[])\n+{\n+  int i;\n+  buf_hot =  \"hello\";\n+  buf_cold = \"world\";\n+  for (i = 0; i < 1000000; i++)\n+    foo (argc);\n+  return 0;\n+}\n+\n+void NOINLINE\n+foo (int path)\n+{\n+  static int i __attribute__((section(\".data\")));\n+  if (path)\n+    {\n+      for (i = 0; i < SIZE; i++)\n+\tsarr[i] = buf_hot;\n+    }\n+  else\n+    {\n+      for (i = 0; i < SIZE; i++)\n+\tsarr[i] = buf_cold;\n+    }\n+}\n+\n+/* { dg-final-use { scan-assembler \"\\.section\\[\\t \\]*\\.text\\.unlikely\\[\\\\n\\\\r\\]+\\[\\t \\]*\\.size\\[\\t \\]*foo\\.cold\\.0\" { target *-*-linux* *-*-gnu* } } } */"}, {"sha": "36829dcb7a0e4590ba1a46917afbcce6843378bb", "filename": "gcc/testsuite/gcc.dg/tree-prof/section-attr-3.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea37fb4c8084421784c80bfd1a4e065980314c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fsection-attr-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea37fb4c8084421784c80bfd1a4e065980314c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fsection-attr-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fsection-attr-3.c?ref=a2ea37fb4c8084421784c80bfd1a4e065980314c", "patch": "@@ -0,0 +1,45 @@\n+/* Checks for a bug where static data with a section attribute within a\n+   function would stop the function being partitioned into hot and cold\n+   blocks.  */\n+/* { dg-require-effective-target freorder } */\n+/* { dg-options \"-O2 -fno-profile-reorder-functions -freorder-blocks-and-partition -save-temps\" } */\n+\n+#define SIZE 10000\n+\n+#define NOINLINE __attribute__((noinline)) __attribute__ ((noclone))\n+\n+const char *sarr[SIZE];\n+const char *buf_hot __attribute__ ((section (\".data\")));\n+const char *buf_cold;\n+\n+void foo (int path);\n+\n+int\n+main (int argc, char *argv[])\n+{\n+  int i;\n+  buf_hot =  \"hello\";\n+  buf_cold = \"world\";\n+  for (i = 0; i < 1000000; i++)\n+    foo (argc);\n+  return 0;\n+}\n+\n+\n+void NOINLINE\n+foo (int path)\n+{\n+  int i;\n+  if (path)\n+    {\n+      for (i = 0; i < SIZE; i++)\n+\tsarr[i] = buf_hot;\n+    }\n+  else\n+    {\n+      for (i = 0; i < SIZE; i++)\n+\tsarr[i] = buf_cold;\n+    }\n+}\n+\n+/* { dg-final-use { scan-assembler \"\\.section\\[\\t \\]*\\.text\\.unlikely\\[\\\\n\\\\r\\]+\\[\\t \\]*\\.size\\[\\t \\]*foo\\.cold\\.0\" { target *-*-linux* *-*-gnu* } } } */"}, {"sha": "d43234a65c1d86aed729a1703f6a02f675a6c777", "filename": "gcc/toplev.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea37fb4c8084421784c80bfd1a4e065980314c/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea37fb4c8084421784c80bfd1a4e065980314c/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=a2ea37fb4c8084421784c80bfd1a4e065980314c", "patch": "@@ -151,11 +151,6 @@ HOST_WIDE_INT random_seed;\n    the support provided depends on the backend.  */\n rtx stack_limit_rtx;\n \n-/* True if the user has tagged the function with the 'section'\n-   attribute.  */\n-\n-bool user_defined_section_attribute = false;\n-\n struct target_flag_state default_target_flag_state;\n #if SWITCHABLE_TARGET\n struct target_flag_state *this_target_flag_state = &default_target_flag_state;"}, {"sha": "f62a172cc52ee2471384953e8d43a8bd1bfaa359", "filename": "gcc/toplev.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea37fb4c8084421784c80bfd1a4e065980314c/gcc%2Ftoplev.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea37fb4c8084421784c80bfd1a4e065980314c/gcc%2Ftoplev.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.h?ref=a2ea37fb4c8084421784c80bfd1a4e065980314c", "patch": "@@ -74,11 +74,6 @@ extern void target_reinit (void);\n /* A unique local time stamp, might be zero if none is available.  */\n extern unsigned local_tick;\n \n-/* True if the user has tagged the function with the 'section'\n-   attribute.  */\n-\n-extern bool user_defined_section_attribute;\n-\n /* See toplev.c.  */\n extern int flag_rerun_cse_after_global_opts;\n "}]}