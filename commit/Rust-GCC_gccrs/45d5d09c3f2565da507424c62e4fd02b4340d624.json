{"sha": "45d5d09c3f2565da507424c62e4fd02b4340d624", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDVkNWQwOWMzZjI1NjVkYTUwNzQyNGM2MmU0ZmQwMmI0MzQwZDYyNA==", "commit": {"author": {"name": "Hans-Peter Nilsson", "email": "hp@gcc.gnu.org", "date": "2007-12-15T21:38:19Z"}, "committer": {"name": "Hans-Peter Nilsson", "email": "hp@gcc.gnu.org", "date": "2007-12-15T21:38:19Z"}, "message": "cris.md: Group related constants together, with comments local.\n\n\t* gcc/config/cris/cris.md: Group related constants together, with\n\tcomments local.\n\t(CRIS_UNSPEC_PLT_GOTREL, CRIS_UNSPEC_PLT_PCREL, CRIS_UNSPEC_PCREL)\n\t(CRIS_UNSPEC_CASESI): New constants.\n\t(CRIS_UNSPEC_PLT): Remove constant.\n\t(CRIS_ACR_REGNUM): New constant.\n\t(\"slottable\"): New attr alternatives \"has_return_slot\" and\n\t\"has_call_slot\".\n\t(\"cc\"): New attr alternatives \"noov32\" and \"rev\".\n\t((eq_attr \"slottable\" \"has_call_slot\"))\n\t((eq_attr \"slottable\" \"has_return_slot\")): New define_delays.\n\t(\"movdi\", \"movsi\"): Adjust operands for CRIS v32.\n\t(\"tstdi\", \"cmpdi\", \"adddi3\", \"subdi3\", \"uminsi3\")\n\t(\"indirect_jump\"): Ditto.  Make define_expand.\n\t(\"*tstdi_non_v32\", \"*tstdi_v32\", \"*tst<mode>_cmp\")\n\t(\"*tst<mode>_non_cmp\", \"*cmpdi_non_v32\", \"*cmpdi_v32\")\n\t(\"*movdi_v32\", \"*adddi3_non_v32\", \"*adddi3_v32\")\n\t(\"*addsi3_non_v32\", \"*addsi3_v32\", \"*addhi3_non_v32\")\n\t(\"*addhi3_v32\", \"*addqi3_non_v32\", \"*addqi3_v32\")\n\t(\"*subdi3_non_v32\", \"*subdi3_v32\", \"*subsi3_non_v32\")\n\t(\"*subsi3_v32\", \"*sub<mode>3_nonv32\", \"*sub<mode>3_v32\")\n\t(\"*andqi3_non_v32\", \"*andqi3_v32\", \"*iorsi3_non_v32\")\n\t(\"*iorsi3_v32\", \"*iorhi3_non_v32\", \"*iorhi3_v32\")\n\t(\"*iorqi3_non_v32\", \"*iorqi3_v32\", \"*uminsi3_non_v32\")\n\t(\"*uminsi3_v32\", \"*indirect_jump_non_v32\", \"*indirect_jump_v32\")\n\t(\"*expanded_call_v32\", \"*expanded_call_value_v32\"): New patterns,\n\tfor the corresponding standard name.\n\t(\"tst<mode>\"): Limit to BW and make define_expand.\n\t(\"tstsi\"): Make separate insn, adjusting for CRIS v32.\n\t(\"*cmp_swapext<mode>\"): Adjust for v32.  Specify \"rev\" for attr \"cc\".\n\t(\"cmpsi\", \"cmp<mode>\"): Remove special cases for zero.  Specify\n\tattr \"cc\".\n\t(\"*btst\"): Don't match for TARGET_CCINIT.  Replace test of\n\tregister with compatible \"cmpq 0\".  Specify attr \"cc\".\n\t(\"*movdi_insn_non_v32\"): New pattern, replacing \"*movdi_insn\" and\n\tdefine_split.\n\t(define_split for DI move): Match CRIS v32 only.\n\t(\"*movsi_got_load\", \"*movsi_internal\", \"*addi\"): Adjust for CRIS\n\tv32.\n\t(\"load_multiple\", \"store_multiple\", \"*addsbw_v32\", \"*addubw_v32\")\n\t(\"*adds<mode>_v32\", \"*addu<mode>_v32\", \"*bound<mode>_v32\")\n\t(\"*casesi_jump_v32\", \"*expanded_andsi_v32\", \"*expanded_andhi_v32\")\n\t(\"*extop<mode>si_v32\", \"*extopqihi_v32\", \"*andhi_lowpart_v32\")\n\t(\"*andqi_lowpart_v32\", \"cris_casesi_v32\"): New patterns. \n\t(\"add<mode>3\"): Make addsi3, addhi3 and addqi3 define_expand.\n\t(\"sub<mode>3\"): Ditto subsi3, subhi3 and subqi3.\n\t(\"ior<mode>3\"): Ditto iorsi3, iorhi3 and iorqi3.\n\t(\"*extopqihi_non_v32\"): Replace \"*extopqihi\".\n\t(\"*extop<mode>si_non_v32\"): Replace \"*extop<mode>si\".\n\t(\"*addxqihi_swap_non_v32\"): Rename from \"*extopqihi_swap\", make\n\tnon-v32 only.\n\t(\"*extop<mode>si_swap_non_v32\"): Ditto \"*extop<mode>si_swap\".\n\t(\"*expanded_andsi_non_v32\"): Ditto \"*expanded_andsi\".\n\t(\"*expanded_andhi_non_v32\"): Ditto \"*expanded_andhi\".\n\t(\"*andhi_lowpart_non_v32\"): Ditto \"*andhi_lowpart\".\n\t(\"*andqi_lowpart_non_v32\"): Ditto \"*andqi_lowpart\".\n\t(\"*expanded_call_non_v32\"): Ditto \"*expanded_call\".  Change from\n\t\"cris_general_operand_or_plt_symbol\" to \"general_operand\".\n\t(\"*expanded_call_value_non_v32\") Ditto \"*expanded_call_value\".\n\t(\"*casesi_adds_w\", \"mstep_shift\", \"mstep_mul\")\n\t(\"*expanded_call_side\", \"*expanded_call_value_side\")\n\t(op-extend-split, op-extend-split-rx=rz, op-extend-split-swapped)\n\t(op-extend-split-swapped-rx=rz, op-extend, op-split-rx=rz)\n\t(op-split-swapped, op-split-swapped-rx=rz): Make non-v32 only.\n\t(\"dstep_mul\", \"xorsi3\", \"one_cmplsi2\", \"<shlr>si3\")\n\t(\"*expanded_<shlr><mode>\", \"*<shlr><mode>_lowpart\", \"ashl<mode>3\")\n\t(\"*ashl<mode>_lowpart\", \"abssi2\", \"clzsi2\", \"bswapsi2\", \"cris_swap_bits\"): Specify \"noov32\" for\n\tattr \"cc\".\n\t(\"<su>mulsi3_highpart\"): Ditto.  Correct operand 0 to\n\tregister_operand.\n\t(\"andqi3\"): Make define_expand.\n\t(\"*return_expanded\"): For attr \"slottable\", change from \"has_slot\"\n\tto \"has_return_slot\".\n\t(\"cris_casesi_non_v32\"): New pattern, old contents of \"casesi\".\n\t(\"casesi\"): Divert into \"cris_casesi_v32\" and\n\t\"cris_casesi_non_v32\".\n\t(moversideqi, movemsideqi, mover2side): Require\n\tTARGET_SIDE_EFFECT_PREFIXES.\n\t(gotplt-to-plt, gotplt-to-plt-side): Change from CRIS_UNSPEC_PLT\n\tto CRIS_UNSPEC_PLT_GOTREL.\n\nFrom-SVN: r130971", "tree": {"sha": "30c057120ba690b9448ed4332162de5ed449aaab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/30c057120ba690b9448ed4332162de5ed449aaab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/45d5d09c3f2565da507424c62e4fd02b4340d624", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45d5d09c3f2565da507424c62e4fd02b4340d624", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45d5d09c3f2565da507424c62e4fd02b4340d624", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45d5d09c3f2565da507424c62e4fd02b4340d624/comments", "author": null, "committer": null, "parents": [{"sha": "6725c4029dc1436d1c8e734d67c6518c96556a4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6725c4029dc1436d1c8e734d67c6518c96556a4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6725c4029dc1436d1c8e734d67c6518c96556a4b"}], "stats": {"total": 1230, "additions": 1044, "deletions": 186}, "files": [{"sha": "1200a2283cb9d962d972c839efdad3466bbd47e0", "filename": "gcc/config/cris/cris.md", "status": "modified", "additions": 1044, "deletions": 186, "changes": 1230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45d5d09c3f2565da507424c62e4fd02b4340d624/gcc%2Fconfig%2Fcris%2Fcris.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45d5d09c3f2565da507424c62e4fd02b4340d624/gcc%2Fconfig%2Fcris%2Fcris.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.md?ref=45d5d09c3f2565da507424c62e4fd02b4340d624", "patch": "@@ -54,30 +54,56 @@\n ;; [rX=gotless_symbol].\n ;; The movsi for a gotless symbol could be split (post reload).\n \f\n-;; UNSPEC Usage:\n-;; 0 PLT reference from call expansion: operand 0 is the address,\n-;;   the mode is VOIDmode.  Always wrapped in CONST.\n-;; 1 Stack frame deallocation barrier.\n-;; 2 The address of the global offset table as a source operand.\n-;; 3 The address of a global-offset-table-relative symbol + offset.\n-;; 4 The offset within GOT of a symbol.\n-;; 5 The offset within GOT of a symbol that has a PLT.\n-\n-(define_constants ; FIXME: reorder sanely.\n-  [(CRIS_UNSPEC_PLT 0)\n-   (CRIS_UNSPEC_FRAME_DEALLOC 1)\n+\n+(define_constants\n+  [\n+   ;; PLT reference from call expansion: operand 0 is the address,\n+   ;; the mode is VOIDmode.  Always wrapped in CONST.\n+   ;; The value is relative to the GOT.\n+   (CRIS_UNSPEC_PLT_GOTREL 0)\n+\n+   ;; PLT reference from call expansion: operand 0 is the address,\n+   ;; the mode is VOIDmode.  Always wrapped in CONST.\n+   ;; The value is relative to the PC.  It's arch-dependent whether\n+   ;; the offset counts from the start or the end of the current item.\n+   (CRIS_UNSPEC_PLT_PCREL 1)\n+\n+   ;; The address of the global offset table as a source operand.\n    (CRIS_UNSPEC_GOT 2)\n+\n+   ;; The offset from the global offset table to the operand.\n    (CRIS_UNSPEC_GOTREL 3)\n-   (CRIS_UNSPEC_GOTREAD 4)\n-   (CRIS_UNSPEC_PLTGOTREAD 5)\n-   (CRIS_UNSPEC_SWAP_BITS 6)])\n+\n+   ;; The PC-relative offset to the operand.  It's arch-dependent whether\n+   ;; the offset counts from the start or the end of the current item.\n+   (CRIS_UNSPEC_PCREL 4)\n+\n+   ;; The index into the global offset table of a symbol, while\n+   ;; also generating a GOT entry for the symbol.\n+   (CRIS_UNSPEC_GOTREAD 5)\n+\n+   ;; Similar to CRIS_UNSPEC_GOTREAD, but also generating a PLT entry.\n+   (CRIS_UNSPEC_PLTGOTREAD 6)\n+\n+   ;; Condition for v32 casesi jump, since it needs to have if_then_else\n+   ;; form with register as one branch and default label as other.\n+   ;; Operand 0 is const_int 0.\n+   (CRIS_UNSPEC_CASESI 7)\n+\n+   ;; Stack frame deallocation barrier.\n+   (CRIS_UNSPEC_FRAME_DEALLOC 8)\n+\n+   ;; Swap all 32 bits of the operand; 31 <=> 0, 30 <=> 1...\n+   (CRIS_UNSPEC_SWAP_BITS 9)\n+  ])\n \n ;; Register numbers.\n (define_constants\n   [(CRIS_GOT_REGNUM 0)\n    (CRIS_STATIC_CHAIN_REGNUM 7)\n    (CRIS_FP_REGNUM 8)\n    (CRIS_SP_REGNUM 14)\n+   (CRIS_ACR_REGNUM 15)\n    (CRIS_SRP_REGNUM 16)\n    (CRIS_MOF_REGNUM 17)\n    (CRIS_AP_REGNUM 18)\n@@ -100,14 +126,21 @@\n ;; In short, any \"slottable\" instruction must be 16 bit and not refer\n ;; to pc, or alter it.\n ;;\n-;; The possible values are \"yes\", \"no\" and \"has_slot\".  Yes/no means if\n-;; the insn is slottable or not.  Has_slot means that the insn is a\n-;; return insn or branch insn (which are not considered slottable since\n-;; that is generally true).  Having the seemingly illogical value\n-;; \"has_slot\" means we do not have to add another attribute just to say\n-;; that an insn has a delay-slot, since it also infers that it is not\n-;; slottable.  Better names for the attribute were found to be longer and\n-;; not add readability to the machine description.\n+;; The possible values are \"yes\", \"no\", \"has_slot\", \"has_return_slot\"\n+;; and \"has_call_slot\".\n+;; Yes/no tells whether the insn is slottable or not.  Has_call_slot means\n+;; that the insn is a call insn, which for CRIS v32 has a delay-slot.\n+;; Of special concern is that no RTX_FRAME_RELATED insn must go in that\n+;; call delay slot, as it's located in the address *after* the call insn,\n+;; and the unwind machinery doesn't know about delay slots.\n+;; Has_slot means that the insn is a branch insn (which are\n+;; not considered slottable since that is generally true).  Having the\n+;; seemingly illogical value \"has_slot\" means we do not have to add\n+;; another attribute just to say that an insn has a delay-slot, since it\n+;; also infers that it is not slottable.  Better names for the attribute\n+;; were found to be longer and not add readability to the machine\n+;; description.\n+;; Has_return_slot is similar, for the return insn.\n ;;\n ;; The default that is defined here for this attribute is \"no\", not\n ;; slottable, not having a delay-slot, so there's no need to worry about\n@@ -125,19 +158,20 @@\n ;; constraint pattern for the slottable pattern.  An alternative using\n ;; only \"r\" constraints is most often slottable.\n \n-(define_attr \"slottable\" \"no,yes,has_slot\" (const_string \"no\"))\n+(define_attr \"slottable\" \"no,yes,has_slot,has_return_slot,has_call_slot\"\n+  (const_string \"no\"))\n \n ;; We also need attributes to sanely determine the condition code\n ;; state.  See cris_notice_update_cc for how this is used.\n \n-(define_attr \"cc\" \"none,clobber,normal\" (const_string \"normal\"))\n+(define_attr \"cc\" \"none,clobber,normal,noov32,rev\" (const_string \"normal\"))\n \n ;; At the moment, this attribute is just used to help bb-reorder do its\n ;; work; the default 0 doesn't help it.  Many insns have other lengths,\n ;; though none are shorter.\n (define_attr \"length\" \"\" (const_int 2))\n \n-;; A branch or return has one delay-slot.  The instruction in the\n+;; A branch has one delay-slot.  The instruction in the\n ;; delay-slot is always executed, independent of whether the branch is\n ;; taken or not.  Note that besides setting \"slottable\" to \"has_slot\",\n ;; there also has to be a \"%#\" at the end of a \"delayed\" instruction\n@@ -147,6 +181,33 @@\n \n (define_delay (eq_attr \"slottable\" \"has_slot\")\n   [(eq_attr \"slottable\" \"yes\") (nil) (nil)])\n+\n+;; We can't put prologue insns in call-insn delay-slots when\n+;; DWARF2 unwind info is emitted, because the unwinder matches the\n+;; address after the insn.  It must see the return address of a call at\n+;; a position at least *one byte after* the insn, or it'll think that\n+;; the insn hasn't been executed.  If the insn is in a delay-slot of a\n+;; call, it's just *exactly* after the insn.\n+\n+(define_delay (eq_attr \"slottable\" \"has_call_slot\")\n+  [(and (eq_attr \"slottable\" \"yes\")\n+\t(ior (eq (symbol_ref \"RTX_FRAME_RELATED_P (insn)\")\n+\t\t (const_int 0))\n+\t     (eq (symbol_ref \"flag_exceptions\")\n+\t\t (const_int 0))))\n+   (nil) (nil)])\n+\n+;; The insn in the return insn slot must not be the\n+;; return-address-register restore.  FIXME: Use has_slot and express\n+;; as a parallel with a use of the return-address-register (currently\n+;; only SRP).  However, this requires an amount of fixing tests for\n+;; naked RETURN in middle-end.\n+(define_delay (eq_attr \"slottable\" \"has_return_slot\")\n+  [(and (eq_attr \"slottable\" \"yes\")\n+\t(eq (symbol_ref \"dead_or_set_regno_p (insn, CRIS_SRP_REGNUM)\")\n+\t    (const_int 0)))\n+   (nil) (nil)])\n+\n \f\n ;; Iterator definitions.\n \n@@ -192,26 +253,70 @@\n ;; Allow register and offsettable mem operands only; post-increment is\n ;; not worth the trouble.\n \n-(define_insn \"tstdi\"\n+(define_expand \"tstdi\"\n+  [(set (cc0) (match_operand:DI 0 \"nonimmediate_operand\"))]\n+  \"\"\n+{\n+  if (TARGET_V32 && MEM_P (operands[0]))\n+    operands[0] = force_reg (DImode, operands[0]);\n+})\n+\n+(define_insn \"*tstdi_non_v32\"\n   [(set (cc0)\n \t(match_operand:DI 0 \"nonimmediate_operand\" \"r,o\"))]\n-  \"\"\n+  \"!TARGET_V32\"\n   \"test.d %M0\\;ax\\;test.d %H0\")\n \n+(define_insn \"*tstdi_v32\"\n+  [(set (cc0)\n+\t(match_operand:DI 0 \"register_operand\" \"r\"))]\n+  \"TARGET_V32\"\n+  \"cmpq 0,%M0\\;ax\\;cmpq 0,%H0\")\n+\n ;; No test insns with side-effect on the mem addressing.\n ;;\n ;; See note on cmp-insns with side-effects (or lack of them)\n \n ;; Normal named test patterns from SI on.\n-;; FIXME: Seems they should change to be in order smallest..largest.\n \n-(define_insn \"tst<mode>\"\n+(define_insn \"tstsi\"\n   [(set (cc0)\n-\t(match_operand:BWD 0 \"nonimmediate_operand\" \"r,Q>,m\"))]\n+\t(match_operand:SI 0 \"nonimmediate_operand\" \"r,Q>,m\"))]\n   \"\"\n-  \"test<m> %0\"\n+{\n+  if (which_alternative == 0 && TARGET_V32)\n+    return \"cmpq 0,%0\";\n+  return \"test.d %0\";\n+}\n   [(set_attr \"slottable\" \"yes,yes,no\")])\n \n+(define_expand \"tst<mode>\"\n+  [(set (cc0)\n+\t(match_operand:BW 0 \"nonimmediate_operand\"))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"*tst<mode>_cmp\"\n+  [(set (cc0)\n+\t(match_operand:BW 0 \"nonimmediate_operand\" \"r,Q>,m\"))]\n+  \"cris_cc0_user_requires_cmp (insn)\"\n+  \"@\n+   cmp<m> 0,%0\n+   test<m> %0\n+   test<m> %0\"\n+  [(set_attr \"slottable\" \"no,yes,no\")])\n+\n+(define_insn \"*tst<mode>_non_cmp\"\n+  [(set (cc0)\n+\t(match_operand:BW 0 \"nonimmediate_operand\" \"r,Q>,m\"))]\n+  \"!cris_cc0_user_requires_cmp (insn)\"\n+  \"@\n+   move<m> %0,%0\n+   test<m> %0\n+   test<m> %0\"\n+  [(set_attr \"slottable\" \"yes,yes,no\")\n+   (set_attr \"cc\" \"noov32,*,*\")])\n+\n ;; It seems that the position of the sign-bit and the fact that 0.0 is\n ;; all 0-bits would make \"tstsf\" a straight-forward implementation;\n ;; either \"test.d\" it for positive/negative or \"btstq 30,r\" it for\n@@ -227,11 +332,23 @@\n ;; DImode for anything else but a structure/block-mode.  Just do the\n ;; obvious stuff for the straight-forward constraint letters.\n \n-(define_insn \"cmpdi\"\n+(define_expand \"cmpdi\"\n+  [(set (cc0)\n+\t(compare (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n+\t\t (match_operand:DI 1 \"general_operand\" \"\")))]\n+  \"\"\n+{\n+  if (TARGET_V32 && !REG_P (operands[0]))\n+    operands[0] = force_reg (DImode, operands[0]);\n+  if (TARGET_V32 && MEM_P (operands[1]))\n+    operands[1] = force_reg (DImode, operands[1]);\n+})\n+\n+(define_insn \"*cmpdi_non_v32\"\n   [(set (cc0)\n \t(compare (match_operand:DI 0 \"nonimmediate_operand\" \"r,r,r,r,r,r,o\")\n \t\t (match_operand:DI 1 \"general_operand\" \"K,I,P,n,r,o,r\")))]\n-  \"\"\n+  \"!TARGET_V32\"\n   \"@\n    cmpq %1,%M0\\;ax\\;cmpq 0,%H0\n    cmpq %1,%M0\\;ax\\;cmpq -1,%H0\n@@ -241,6 +358,18 @@\n    cmp.d %M1,%M0\\;ax\\;cmp.d %H1,%H0\n    cmp.d %M0,%M1\\;ax\\;cmp.d %H0,%H1\")\n \n+(define_insn \"*cmpdi_v32\"\n+  [(set (cc0)\n+\t(compare (match_operand:DI 0 \"register_operand\"  \"r,r,r,r,r\")\n+\t\t (match_operand:DI 1 \"nonmemory_operand\" \"K,I,P,n,r\")))]\n+  \"TARGET_V32\"\n+  \"@\n+   cmpq %1,%M0\\;ax\\;cmpq 0,%H0\n+   cmpq %1,%M0\\;ax\\;cmpq -1,%H0\n+   cmp%e1.%z1 %1,%M0\\;ax\\;cmpq %H1,%H0\n+   cmp.d %M1,%M0\\;ax\\;cmp.d %H1,%H0\n+   cmp.d %M1,%M0\\;ax\\;cmp.d %H1,%H0\")\n+\n ;; Note that compare insns with side effect addressing mode (e.g.):\n ;;\n ;; cmp.S [rx=ry+i],rz;\n@@ -281,47 +410,43 @@\n \t\t\t    [(match_operand:BW 0 \"memory_operand\" \"Q>,m\")])\n \t (match_operand:SI 1 \"register_operand\" \"r,r\")))]\n   \"\"\n-  \"cmp%e2<m> %0,%1\" ; The function cris_notice_update_cc knows about\n-\t\t     ; swapped operands to compares.\n-  [(set_attr \"slottable\" \"yes,no\")])\n+  \"cmp%e2<m> %0,%1\"\n+  [(set_attr \"slottable\" \"yes,no\")\n+   (set_attr \"cc\" \"rev\")])\n \f\n-;; The \"normal\" compare patterns, from SI on.\n+;; The \"normal\" compare patterns, from SI on.  Special-cases with zero\n+;; should not happen.\n \n (define_insn \"cmpsi\"\n   [(set (cc0)\n \t(compare\n-\t (match_operand:SI 0 \"nonimmediate_operand\" \"r,r,r, r,Q>,Q>,r,r,m,m\")\n-\t (match_operand:SI 1 \"general_operand\"\t    \"I,r,Q>,M,M, r, P,g,M,r\")))]\n+\t (match_operand:SI 0 \"nonimmediate_operand\" \"r,r,r, Q>,r,r,m\")\n+\t (match_operand:SI 1 \"general_operand\"\t    \"I,r,Q>,r, P,g,r\")))]\n   \"\"\n   \"@\n    cmpq %1,%0\n    cmp.d %1,%0\n    cmp.d %1,%0\n-   test.d %0\n-   test.d %0\n    cmp.d %0,%1\n    cmp%e1.%z1 %1,%0\n    cmp.d %1,%0\n-   test.d %0\n    cmp.d %0,%1\"\n-  [(set_attr \"slottable\" \"yes,yes,yes,yes,yes,yes,no,no,no,no\")])\n+  [(set_attr \"slottable\" \"yes,yes,yes,yes,no,no,no\")\n+   (set_attr \"cc\" \"normal,normal,normal,rev,normal,normal,rev\")])\n \n (define_insn \"cmp<mode>\"\n   [(set (cc0)\n-\t(compare\n-\t (match_operand:BW 0 \"nonimmediate_operand\" \"r,r, r,Q>,Q>,r,m,m\")\n-\t (match_operand:BW 1 \"general_operand\"\t    \"r,Q>,M,M, r, g,M,r\")))]\n+\t(compare (match_operand:BW 0 \"nonimmediate_operand\" \"r,r, Q>,r,m\")\n+\t\t (match_operand:BW 1 \"general_operand\"\t    \"r,Q>,r, g,r\")))]\n   \"\"\n   \"@\n    cmp<m> %1,%0\n    cmp<m> %1,%0\n-   test<m> %0\n-   test<m> %0\n    cmp<m> %0,%1\n    cmp<m> %1,%0\n-   test<m> %0\n    cmp<m> %0,%1\"\n-  [(set_attr \"slottable\" \"yes,yes,yes,yes,yes,no,no,no\")])\n+  [(set_attr \"slottable\" \"yes,yes,yes,no,no\")\n+   (set_attr \"cc\" \"normal,normal,rev,normal,rev\")])\n \f\n ;; Pattern matching the BTST insn.\n ;; It is useful for \"if (i & val)\" constructs, where val is an exact\n@@ -337,15 +462,17 @@\n \t (match_operand:SI 1 \"const_int_operand\" \"K,n,K,n,K,n,n\")\n \t (match_operand:SI 2 \"nonmemory_operand\" \"M,M,K,n,r,r,r\")))]\n   ;; Either it is a single bit, or consecutive ones starting at 0.\n+  ;; The btst ones depend on stuff in NOTICE_UPDATE_CC.\n   \"CONST_INT_P (operands[1])\n    && (operands[1] == const1_rtx || operands[2] == const0_rtx)\n    && (REG_S_P (operands[0])\n        || (operands[1] == const1_rtx\n \t   && REG_S_P (operands[2])\n \t   && CONST_INT_P (operands[0])\n-\t   && exact_log2 (INTVAL (operands[0])) >= 0))\"\n+\t   && exact_log2 (INTVAL (operands[0])) >= 0))\n+   && !TARGET_CCINIT\"\n \n-;; The last \"&&\" condition above should be caught by some kind of\n+;; The next-to-last \"&&\" condition above should be caught by some kind of\n ;; canonicalization in gcc, but we can easily help with it here.\n ;;  It results from expressions of the type\n ;; \"power_of_2_value & (1 << y)\".\n@@ -357,13 +484,14 @@\n \n   \"@\n    btstq (%1-1),%0\n-   test.d %0\n+   cmpq 0,%0\n    btstq %2,%0\n    clearf nz\n    btst %2,%0\n    clearf nz\n    cmpq %p0,%2\"\n- [(set_attr \"slottable\" \"yes\")])\n+ [(set_attr \"slottable\" \"yes\")\n+  (set_attr \"cc\" \"noov32\")])\n \f\n ;; Move insns.\n \n@@ -409,7 +537,9 @@\n \t(match_operand:DI 1 \"general_operand\" \"\"))]\n   \"\"\n {\n-  if (MEM_P (operands[0]) && operands[1] != const0_rtx)\n+  if (MEM_P (operands[0])\n+      && operands[1] != const0_rtx\n+      && (!TARGET_V32 || (!REG_P (operands[1]) && can_create_pseudo_p ())))\n     operands[1] = copy_to_mode_reg (DImode, operands[1]);\n \n   /* Some other ports (as of 2001-09-10 for example mcore and romp) also\n@@ -441,18 +571,64 @@\n     }\n })\n \n-(define_insn \"*movdi_insn\"\n+(define_insn_and_split \"*movdi_insn_non_v32\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,rx,m\")\n-\t(match_operand:DI 1 \"general_operand\" \"rx,g,rxM\"))]\n-  \"register_operand (operands[0], DImode)\n-   || register_operand (operands[1], DImode)\n-   || operands[1] == const0_rtx\"\n-  \"#\")\n+\t(match_operand:DI 1 \"general_operand\"\t   \"rx,g,rxM\"))]\n+  \"(register_operand (operands[0], DImode)\n+    || register_operand (operands[1], DImode)\n+    || operands[1] == const0_rtx)\n+   && !TARGET_V32\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(match_dup 2)]\n+  \"operands[2] = cris_split_movdx (operands);\")\n \n+;; Overlapping (but non-identical) source memory address and destination\n+;; register would be a compiler bug, so we don't have to specify that.\n+(define_insn \"*movdi_v32\"\n+  [(set\n+    (match_operand:DI 0 \"nonimmediate_operand\" \"=r,rx,&r,>, m,r,x,m\")\n+    (match_operand:DI 1 \"general_operand\"     \"rxi,r>,m, rx,r,m,m,x\"))]\n+  \"TARGET_V32\"\n+{\n+  switch (which_alternative)\n+    {\n+      /* FIXME: 1) Use autoincrement where possible.  2) Have peephole2,\n+\t particularly for cases where the address register is dead.  */\n+    case 5:\n+      if (REGNO (operands[0]) == REGNO (XEXP (operands[1], 0)))\n+\treturn \"addq 4,%L1\\;move.d %1,%H0\\;subq 4,%L1\\;move.d %1,%M0\";\n+      gcc_assert (REGNO (operands[0]) + 1 == REGNO (XEXP (operands[1], 0)));\n+      return \"move.d [%L1+],%M0\\;move.d [%L1],%H0\";\n+    case 2:\n+      /* We could do away with the addq if we knew the address-register\n+\t isn't ACR.  If we knew the address-register is dead, we could do\n+\t away with the subq too.  */\n+      return \"move.d [%L1],%M0\\;addq 4,%L1\\;move.d [%L1],%H0\\;subq 4,%L1\";\n+    case 4:\n+      return \"move.d %M1,[%L0]\\;addq 4,%L0\\;move.d %H1,[%L0]\\;subq 4,%L0\";\n+    case 6:\n+      return \"move [%L1],%M0\\;addq 4,%L1\\;move [%L1],%H0\\;subq 4,%L1\";\n+    case 7:\n+      return \"move %M1,[%L0]\\;addq 4,%L0\\;move %H1,[%L0]\\;subq 4,%L0\";\n+\n+    default:\n+      return \"#\";\n+    }\n+}\n+  ;; The non-split cases clobber cc0 because of their adds and subs.\n+  ;; Beware that NOTICE_UPDATE_CC is called before the forced split happens.\n+  [(set_attr \"cc\" \"*,*,clobber,*,clobber,clobber,*,*\")])\n+\n+;; Much like \"*movdi_insn_non_v32\".  Overlapping registers and constants\n+;; is handled so much better in cris_split_movdx.\n (define_split\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n \t(match_operand:DI 1 \"general_operand\" \"\"))]\n-  \"reload_completed\"\n+  \"TARGET_V32\n+   && reload_completed\n+   && (!MEM_P (operands[0]) || !REG_P (XEXP (operands[0], 0)))\n+   && (!MEM_P (operands[1]) || !REG_P (XEXP (operands[1], 0)))\"\n   [(match_dup 2)]\n   \"operands[2] = cris_split_movdx (operands);\")\n \f\n@@ -462,6 +638,7 @@\n ;;\n ;; move.S1 [rx=ry+rz.S],rw avoiding when rx is ry, or rw is rx\n ;; FIXME: These could have anonymous mode for operand 0.\n+;; FIXME: Special registers' alternatives too.\n \n (define_insn \"*mov_side<mode>_biap\"\n   [(set (match_operand:BW 0 \"register_operand\" \"=r,r\")\n@@ -800,7 +977,7 @@\n      offset?  */\n     if (flag_pic\n \t&& CONSTANT_ADDRESS_P (operands[1])\n-\t&& !cris_valid_pic_const (operands[1]))\n+\t&& !cris_valid_pic_const (operands[1], false))\n       {\n \tenum cris_pic_symbol_type t = cris_pic_symbol_type_of (operands[1]);\n \n@@ -819,26 +996,46 @@\n \t       destination register for the symbol.  It might not be\n \t       worth it.  Measure.  */\n \t    current_function_uses_pic_offset_table = 1;\n-\t    if (t == cris_gotrel_symbol)\n+\t    if (t == cris_rel_symbol)\n \t      {\n \t\t/* Change a \"move.d sym(+offs),rN\" into (allocate register rM)\n+\t\t   for pre-v32:\n+\t\t   \"move.d (const (plus (unspec [sym]\n+\t\t    CRIS_UNSPEC_GOTREL) offs)),rM\" \"add.d rPIC,rM,rN\"\n+\t\t   and for v32:\n \t\t   \"move.d (const (plus (unspec [sym]\n-\t\t    CRIS_UNSPEC_GOTREL) offs)),rM\" \"add.d rPIC,rM,rN\"  */\n+\t\t    CRIS_UNSPEC_PCREL) offs)),rN\".  */\n \t\trtx tem, rm, rn = operands[0];\n \t\trtx sym = GET_CODE (operands[1]) != CONST\n \t\t  ? operands[1] : get_related_value (operands[1]);\n \t\tHOST_WIDE_INT offs = get_integer_term (operands[1]);\n \n \t\tgcc_assert (can_create_pseudo_p ());\n-\t\ttem = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, sym),\n-\t\t\t\t      CRIS_UNSPEC_GOTREL);\n-\t\tif (offs != 0)\n-\t\t  tem = plus_constant (tem, offs);\n-\t\trm = gen_reg_rtx (Pmode);\n-\t\temit_move_insn (rm, gen_rtx_CONST (Pmode, tem));\n-\t        if (expand_binop (Pmode, add_optab, rm, pic_offset_table_rtx,\n-\t\t\t\t  rn, 0, OPTAB_LIB_WIDEN) != rn)\n-\t\t  internal_error (\"expand_binop failed in movsi gotrel\");\n+\n+\t\tif (TARGET_V32)\n+\t\t  {\n+\t\t    tem = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, sym),\n+\t\t\t\t\t  CRIS_UNSPEC_PCREL);\n+\t\t    if (offs != 0)\n+\t\t      tem = plus_constant (tem, offs);\n+\t\t    rm = rn;\n+\t\t    emit_move_insn (rm, gen_rtx_CONST (Pmode, tem));\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    /* We still uses GOT-relative addressing for\n+\t\t       pre-v32.\t */\n+\t\t    current_function_uses_pic_offset_table = 1;\n+\t\t    tem = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, sym),\n+\t\t\t\t\t  CRIS_UNSPEC_GOTREL);\n+\t\t    if (offs != 0)\n+\t\t      tem = plus_constant (tem, offs);\n+\t\t    rm = gen_reg_rtx (Pmode);\n+\t\t    emit_move_insn (rm, gen_rtx_CONST (Pmode, tem));\n+\t\t    if (expand_binop (Pmode, add_optab, rm, pic_offset_table_rtx,\n+\t\t\t\t      rn, 0, OPTAB_LIB_WIDEN) != rn)\n+\t\t      internal_error (\"expand_binop failed in movsi gotrel\");\n+\t\t  }\n \t\tDONE;\n \t      }\n \t    else if (t == cris_got_symbol)\n@@ -863,6 +1060,12 @@\n \t\t   aliases other same symbols is unimportant.  */\n \t\tset_mem_alias_set (mem, new_alias_set ());\n \t\tMEM_NOTRAP_P (mem) = 1;\n+\n+\t\t/* We can set the GOT memory read of a non-called symbol\n+\t\t   to readonly, but not that of a call symbol, as those\n+\t\t   are subject to lazy evaluation and usually have the value\n+\t\t   changed from the first call to the second (but\n+\t\t   constant thereafter).  */\n \t\tMEM_READONLY_P (mem) = 1;\n \t\temit_move_insn (rn, mem);\n \t\tDONE;\n@@ -897,26 +1100,53 @@\n (define_insn \"*movsi_got_load\"\n   [(set (reg:SI CRIS_GOT_REGNUM) (unspec:SI [(const_int 0)] CRIS_UNSPEC_GOT))]\n   \"flag_pic\"\n-  \"move.d $pc,%:\\;sub.d .:GOTOFF,%:\"\n+{\n+  return TARGET_V32\n+    ? \"lapc _GLOBAL_OFFSET_TABLE_,%:\"\n+    : \"move.d $pc,%:\\;sub.d .:GOTOFF,%:\";\n+}\n   [(set_attr \"cc\" \"clobber\")])\n \n (define_insn \"*movsi_internal\"\n   [(set\n-    (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r, r,Q>,r,Q>,g,r,r, r,g,rQ>,x,  m,x\")\n+    (match_operand:SI 0 \"nonimmediate_operand\"\n+\t\t      \"=r,r, r,Q>,r,Q>,g,r,r, r,g,rQ>,x,  m,x\")\n+    (match_operand:SI 1 \"cris_general_operand_or_pic_source\"\n+\t\t       \"r,Q>,M,M, I,r, M,n,!S,g,r,x,  rQ>,x,gi\"))]\n     ;; Note that we prefer not to use the S alternative (if for some reason\n-    ;; it competes with others), but g matches S.\n-    (match_operand:SI 1 \"general_operand\"\t\"r,Q>,M,M, I,r, M,n,!S,g,r,x,  rQ>,x,gi\"))]\n+    ;; it competes with others) above, but g matches S.\n   \"\"\n {\n   /* Better to have c-switch here; it is worth it to optimize the size of\n      move insns.  The alternative would be to try to find more constraint\n      letters.  FIXME: Check again.  It seems this could shrink a bit.  */\n   switch (which_alternative)\n     {\n+    case 9:\n+      if (TARGET_V32)\n+       {\n+\t if (!flag_pic\n+\t     && (GET_CODE (operands[1]) == SYMBOL_REF\n+\t\t || GET_CODE (operands[1]) == LABEL_REF\n+\t\t || GET_CODE (operands[1]) == CONST))\n+\t   {\n+\t     /* FIXME: Express this through (set_attr cc none) instead,\n+\t\tsince we can't express the ``none'' at this point.  FIXME:\n+\t\tUse lapc for everything except const_int and when next cc0\n+\t\tuser would want the flag setting.  */\n+\t     CC_STATUS_INIT;\n+\t     return \"lapc %1,%0\";\n+\t   }\n+\t if (flag_pic == 1\n+\t     && GET_CODE (operands[1]) == CONST\n+\t     && GET_CODE (XEXP (operands[1], 0)) == UNSPEC\n+\t     && XINT (XEXP (operands[1], 0), 1) == CRIS_UNSPEC_GOTREAD)\n+\t   return \"movu.w %1,%0\";\n+       }\n+       /* FALLTHROUGH */\n     case 0:\n     case 1:\n     case 5:\n-    case 9:\n     case 10:\n       return \"move.d %1,%0\";\n \n@@ -958,7 +1188,8 @@\n \ttem = XEXP (tem, 0);\n \tif (GET_CODE (tem) == PLUS\n \t    && GET_CODE (XEXP (tem, 0)) == UNSPEC\n-\t    && XINT (XEXP (tem, 0), 1) == CRIS_UNSPEC_GOTREL\n+\t    && (XINT (XEXP (tem, 0), 1) == CRIS_UNSPEC_GOTREL\n+\t\t|| XINT (XEXP (tem, 0), 1) == CRIS_UNSPEC_PCREL)\n \t    && CONST_INT_P (XEXP (tem, 1)))\n \t  tem = XEXP (tem, 0);\n \tgcc_assert (GET_CODE (tem) == UNSPEC);\n@@ -970,10 +1201,18 @@\n \t       indexed addressing mode.  */\n \t    if (flag_pic == 1)\n \t      return \"movs.w %1,%0\";\n+\t    return \"move.d %1,%0\";\n+\n \t  case CRIS_UNSPEC_GOTREL:\n-\t  case CRIS_UNSPEC_PLT:\n+\t  case CRIS_UNSPEC_PLT_GOTREL:\n+\t    gcc_assert (!TARGET_V32);\n \t    return \"move.d %1,%0\";\n \n+\t  case CRIS_UNSPEC_PCREL:\n+\t  case CRIS_UNSPEC_PLT_PCREL:\n+\t    gcc_assert (TARGET_V32);\n+\t    return \"lapc %1,%0\";\n+\n \t  default:\n \t    gcc_unreachable ();\n \t  }\n@@ -1218,9 +1457,69 @@\n    move %1,%0\n    move %1,%0\"\n   [(set_attr \"slottable\" \"yes,yes,yes,yes,yes,no,no,no,yes,yes,yes,no,yes,no\")])\n+\f\n+;; Movem patterns.  Primarily for use in function prologue and epilogue.\n+;; The V32 variants have an ordering matching the expectations of the\n+;; standard names \"load_multiple\" and \"store_multiple\"; pre-v32 movem\n+;; store R0 in the highest memory location.\n+\n+(define_expand \"load_multiple\"\n+  [(match_operand:SI 0 \"register_operand\" \"\")\n+   (match_operand:SI 1 \"memory_operand\" \"\")\n+   (match_operand:SI 2 \"const_int_operand\" \"\")]\n+  \"TARGET_V32\"\n+{\n+  rtx indreg;\n+\n+  /* Apparently the predicate isn't checked, so we need to do so\n+     manually.  Once happened for libstdc++-v3 locale_facets.tcc.  */\n+  if (!MEM_P (operands[1]))\n+    FAIL;\n+\n+  indreg = XEXP (operands[1], 0);\n+\n+  if (GET_CODE (indreg) == POST_INC)\n+    indreg = XEXP (indreg, 0);\n+  if (!REG_P (indreg)\n+      || GET_CODE (operands[2]) != CONST_INT\n+      || !REG_P (operands[0])\n+      || REGNO (operands[0]) != 0\n+      || INTVAL (operands[2]) > CRIS_SP_REGNUM\n+      || (int) REGNO (indreg) < INTVAL (operands[2]))\n+    FAIL;\n+  gcc_unreachable ();\n+  emit_insn (cris_gen_movem_load (operands[1], operands[2], 0));\n+  DONE;\n+})\n+\n+(define_expand \"store_multiple\"\n+  [(match_operand:SI 0 \"memory_operand\" \"\")\n+   (match_operand:SI 1 \"register_operand\" \"\")\n+   (match_operand:SI 2 \"const_int_operand\" \"\")]\n+  \"TARGET_V32\"\n+{\n+  rtx indreg;\n+\n+  /* See load_multiple.  */\n+  if (!MEM_P (operands[0]))\n+    FAIL;\n+\n+  indreg = XEXP (operands[0], 0);\n+\n+  if (GET_CODE (indreg) == POST_INC)\n+    indreg = XEXP (indreg, 0);\n+  if (!REG_P (indreg)\n+      || GET_CODE (operands[2]) != CONST_INT\n+      || !REG_P (operands[1])\n+      || REGNO (operands[1]) != 0\n+      || INTVAL (operands[2]) > CRIS_SP_REGNUM\n+      || (int) REGNO (indreg) < INTVAL (operands[2]))\n+    FAIL;\n+  gcc_unreachable ();\n+  cris_emit_movem_store (operands[0], operands[2], 0, false);\n+  DONE;\n+})\n \n-;; Note that the memory layout of the registers is the reverse of that\n-;; of the standard patterns \"load_multiple\" and \"store_multiple\".\n (define_insn \"*cris_load_multiple\"\n   [(match_parallel 0 \"cris_load_multiple_op\"\n \t\t   [(set (match_operand:SI 1 \"register_operand\" \"=r,r\")\n@@ -1421,19 +1720,51 @@\n ;; Note that for the 'P' constraint, the high part can be -1 or 0.  We\n ;; output the insn through the 'A' output modifier as \"adds.w\" and \"addq\",\n ;; respectively.\n-(define_insn \"adddi3\"\n+(define_expand \"adddi3\"\n+  [(set (match_operand:DI 0 \"register_operand\")\n+\t(plus:DI (match_operand:DI 1 \"register_operand\")\n+\t\t (match_operand:DI 2 \"general_operand\")))]\n+  \"\"\n+{\n+  if (MEM_P (operands[2]) && TARGET_V32)\n+    operands[2] = force_reg (DImode, operands[2]);\n+})\n+\n+(define_insn \"*adddi3_non_v32\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r,r,r,&r,&r\")\n \t(plus:DI (match_operand:DI 1 \"register_operand\" \"%0,0,0,0,r\")\n \t\t (match_operand:DI 2 \"general_operand\" \"J,N,P,g,!To\")))]\n-  \"\"\n+  \"!TARGET_V32\"\n   \"@\n    addq %2,%M0\\;ax\\;addq 0,%H0\n    subq %n2,%M0\\;ax\\;subq 0,%H0\n    add%e2.%z2 %2,%M0\\;ax\\;%A2 %H2,%H0\n    add.d %M2,%M0\\;ax\\;add.d %H2,%H0\n    add.d %M2,%M1,%M0\\;ax\\;add.d %H2,%H1,%H0\")\n \n-(define_insn \"addsi3\"\n+; It seems no use allowing a memory operand for this one, because we'd\n+; need a scratch register for incrementing the address.\n+(define_insn \"*adddi3_v32\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r,r,r,r\")\n+       (plus:DI (match_operand:DI 1 \"register_operand\" \"%0,0,0,0,0\")\n+                (match_operand:DI 2 \"nonmemory_operand\" \"J,N,P,r,n\")))]\n+  \"TARGET_V32\"\n+  \"@\n+   addq %2,%M0\\;addc 0,%H0\n+   subq %n2,%M0\\;ax\\;subq 0,%H0\n+   add%e2.%z2 %2,%M0\\;addc %H2,%H0\n+   add.d %M2,%M0\\;addc %H2,%H0\n+   add.d %M2,%M0\\;addc %H2,%H0\")\n+\n+(define_expand \"add<mode>3\"\n+  [(set (match_operand:BWD 0 \"register_operand\")\n+\t(plus:BWD\n+\t (match_operand:BWD 1 \"register_operand\")\n+\t (match_operand:BWD 2 \"general_operand\")))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"*addsi3_non_v32\"\n   [(set (match_operand:SI 0 \"register_operand\"  \"=r,r, r,r,r,r, r,r,  r\")\n \t(plus:SI\n \t (match_operand:SI 1 \"register_operand\" \"%0,0, 0,0,0,0, 0,r,  r\")\n@@ -1444,7 +1775,7 @@\n ;; register as in destination.  This will happen after insn splitting.\n ;; gcc <= 2.7.2.  FIXME: Check for gcc-2.9x\n \n- \"\"\n+ \"!TARGET_V32\"\n {\n   switch (which_alternative)\n     {\n@@ -1480,6 +1811,8 @@\n \ttem = XEXP (tem, 0);\n \tif (GET_CODE (tem) == PLUS\n \t    && GET_CODE (XEXP (tem, 0)) == UNSPEC\n+\t    /* We don't allow CRIS_UNSPEC_PCREL here; we can't have a\n+\t       pc-relative operand in an add insn.  */\n \t    && XINT (XEXP (tem, 0), 1) == CRIS_UNSPEC_GOTREL\n \t    && CONST_INT_P (XEXP (tem, 1)))\n \t  tem = XEXP (tem, 0);\n@@ -1492,16 +1825,17 @@\n \t       indexed addressing mode.  */\n \t    if (flag_pic == 1)\n \t      return \"adds.w %2,%0\";\n-\t    /* Fall through.  */\n-\t  case CRIS_UNSPEC_PLT:\n+\t    return \"add.d %2,%0\";\n+\n+\t  case CRIS_UNSPEC_PLT_GOTREL:\n \t  case CRIS_UNSPEC_GOTREL:\n \t    return \"add.d %2,%0\";\n \t  default:\n \t    gcc_unreachable ();\n \t  }\n       }\n     case 6:\n-      return \"add.d %2,%0\";\n+      return \"add%u2 %2,%0\";\n     case 7:\n       return \"add.d %2,%1,%0\";\n     case 8:\n@@ -1511,12 +1845,38 @@\n     }\n }\n  [(set_attr \"slottable\" \"yes,yes,yes,yes,no,no,no,no,yes\")])\n+\n+; FIXME: Check what's best: having the three-operand ACR alternative\n+; before or after the corresponding-operand2 alternative.  Check for\n+; *all* insns.  FIXME: constant constraint letter for -128..127.\n+(define_insn \"*addsi3_v32\"\n+  [(set (match_operand:SI 0 \"register_operand\"  \"=r,!a,r,!a, r,r,!a,r,!a,r,r,r,!a\")\n+\t(plus:SI\n+\t (match_operand:SI 1 \"register_operand\" \"%0,r, 0, r, 0,0,r, 0,r, 0,0,0,r\")\n+\t (match_operand:SI 2 \"general_operand\"  \"r, r, Q>,Q>,J,N,NJ,L,L, P,n,g,g\")))]\n+  \"TARGET_V32\"\n+  \"@\n+   add.d %2,%0\n+   addi %2.b,%1,%0\n+   add.d %2,%0\n+   addo.d %2,%1,%0\n+   addq %2,%0\n+   subq %n2,%0\n+   addoq %2,%1,%0\n+   adds.w %2,%0\n+   addo %2,%1,%0\n+   addu.w %2,%0\n+   add.d %2,%0\n+   add%u2 %2,%0\n+   addo.%Z2 %2,%1,%0\"\n+  [(set_attr \"slottable\" \"yes,yes,yes,yes,yes,yes,yes,no,no,no,no,no,no\")\n+   (set_attr \"cc\" \"*,none,*,none,*,*,none,*,*,*,*,*,none\")])\n \f\n-(define_insn \"addhi3\"\n+(define_insn \"*addhi3_non_v32\"\n   [(set (match_operand:HI 0 \"register_operand\"\t\t\"=r,r, r,r,r,r\")\n \t(plus:HI (match_operand:HI 1 \"register_operand\" \"%0,0, 0,0,0,r\")\n \t\t (match_operand:HI 2 \"general_operand\"   \"r,Q>,J,N,g,!To\")))]\n-  \"\"\n+  \"!TARGET_V32\"\n   \"@\n    add.w %2,%0\n    add.w %2,%0\n@@ -1527,11 +1887,30 @@\n   [(set_attr \"slottable\" \"yes,yes,yes,yes,no,no\")\n    (set_attr \"cc\" \"normal,normal,clobber,clobber,normal,normal\")])\n \n-(define_insn \"addqi3\"\n+(define_insn \"*addhi3_v32\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r, !a,r,!a, r,r,!a,r,!a\")\n+\t(plus:HI\n+\t (match_operand:HI 1 \"register_operand\" \"%0,r, 0, r, 0,0,r, 0,r\")\n+\t (match_operand:HI 2 \"general_operand\"  \"r, r, Q>,Q>,J,N,NJ,g,g\")))]\n+  \"TARGET_V32\"\n+  \"@\n+   add.w %2,%0\n+   addi %2.b,%1,%0\n+   add.w %2,%0\n+   addo.w %2,%1,%0\n+   addq %2,%0\n+   subq %n2,%0\n+   addoq %2,%1,%0\n+   add.w %2,%0\n+   addo.w %2,%1,%0\"\n+  [(set_attr \"slottable\" \"yes,yes,yes,yes,yes,yes,yes,no,no\")\n+   (set_attr \"cc\" \"*,none,*,none,clobber,clobber,none,*,none\")])\n+\n+(define_insn \"*addqi3_non_v32\"\n   [(set (match_operand:QI 0 \"register_operand\"\t\t\"=r,r, r,r,r,r,r\")\n \t(plus:QI (match_operand:QI 1 \"register_operand\" \"%0,0, 0,0,0,0,r\")\n \t\t (match_operand:QI 2 \"general_operand\"\t \"r,Q>,J,N,O,g,!To\")))]\n-  \"\"\n+  \"!TARGET_V32\"\n   \"@\n    add.b %2,%0\n    add.b %2,%0\n@@ -1542,6 +1921,26 @@\n    add.b %2,%1,%0\"\n   [(set_attr \"slottable\" \"yes,yes,yes,yes,yes,no,no\")\n    (set_attr \"cc\" \"normal,normal,clobber,clobber,clobber,normal,normal\")])\n+\n+(define_insn \"*addqi3_v32\"\n+  [(set (match_operand:QI 0 \"register_operand\"  \"=r,!a,r,!a, r,r,!a,r,r,!a\")\n+\t(plus:QI\n+\t (match_operand:QI 1 \"register_operand\" \"%0,r, 0, r, 0,0,r, 0,0,r\")\n+\t (match_operand:QI 2 \"general_operand\"   \"r,r, Q>,Q>,J,N,NJ,O,g,g\")))]\n+  \"TARGET_V32\"\n+  \"@\n+   add.b %2,%0\n+   addi %2.b,%1,%0\n+   add.b %2,%0\n+   addo.b %2,%1,%0\n+   addq %2,%0\n+   subq %n2,%0\n+   addoq %2,%1,%0\n+   subQ -%b2,%0\n+   add.b %2,%0\n+   addo.b %2,%1,%0\"\n+  [(set_attr \"slottable\" \"yes,yes,yes,yes,yes,yes,yes,yes,no,no\")\n+   (set_attr \"cc\" \"*,none,*,none,clobber,clobber,none,clobber,*,none\")])\n \f\n ;; Subtract.\n ;;\n@@ -1551,24 +1950,53 @@\n ;; Note that for the 'P' constraint, the high part can be -1 or 0.  We\n ;; output the insn through the 'D' output modifier as \"subs.w\" and \"subq\",\n ;; respectively.\n-(define_insn \"subdi3\"\n+(define_expand \"subdi3\"\n+  [(set (match_operand:DI 0 \"register_operand\")\n+\t(minus:DI (match_operand:DI 1 \"register_operand\")\n+\t\t  (match_operand:DI 2 \"general_operand\")))]\n+  \"\"\n+{\n+  if (TARGET_V32 && MEM_P (operands[2]))\n+    operands[2] = force_reg (DImode, operands[2]);\n+})\n+\n+(define_insn \"*subdi3_non_v32\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r,r,r,&r,&r\")\n \t(minus:DI (match_operand:DI 1 \"register_operand\" \"0,0,0,0,r\")\n \t\t  (match_operand:DI 2 \"general_operand\" \"J,N,P,g,!To\")))]\n-  \"\"\n+  \"!TARGET_V32\"\n   \"@\n    subq %2,%M0\\;ax\\;subq 0,%H0\n    addq %n2,%M0\\;ax\\;addq 0,%H0\n    sub%e2.%z2 %2,%M0\\;ax\\;%D2 %H2,%H0\n    sub.d %M2,%M0\\;ax\\;sub.d %H2,%H0\n    sub.d %M2,%M1,%M0\\;ax\\;sub.d %H2,%H1,%H0\")\n \n-(define_insn \"subsi3\"\n+(define_insn \"*subdi3_v32\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r,r,&r\")\n+\t(minus:DI (match_operand:DI 1 \"register_operand\" \"0,0,0,0\")\n+\t\t  (match_operand:DI 2 \"nonmemory_operand\" \"J,N,P,r\")))]\n+  \"TARGET_V32\"\n+  \"@\n+   subq %2,%M0\\;ax\\;subq 0,%H0\n+   addq %n2,%M0\\;ax\\;addq 0,%H0\n+   sub%e2.%z2 %2,%M0\\;ax\\;%D2 %H2,%H0\n+   sub.d %M2,%M0\\;ax\\;sub.d %H2,%H0\")\n+\n+(define_expand \"sub<mode>3\"\n+  [(set (match_operand:BWD 0 \"register_operand\")\n+\t(minus:BWD\n+\t (match_operand:BWD 1 \"register_operand\")\n+\t (match_operand:BWD 2 \"general_operand\")))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"*subsi3_non_v32\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r, r,r,r,r,r,r\")\n \t(minus:SI\n \t (match_operand:SI 1 \"register_operand\" \"0,0, 0,0,0,0,0,r\")\n \t (match_operand:SI 2 \"general_operand\"\t\"r,Q>,J,N,P,n,g,!To\")))]\n-  \"\"\n+  \"!TARGET_V32\"\n \n ;; This does not do the optimal: \"addu.w 65535,r0\" when %2 is negative.\n ;; But then again, %2 should not be negative.\n@@ -1583,12 +2011,28 @@\n    sub.d %2,%0\n    sub.d %2,%1,%0\"\n   [(set_attr \"slottable\" \"yes,yes,yes,yes,no,no,no,no\")])\n+\n+(define_insn \"*subsi3_v32\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r,r,r,r,r\")\n+       (minus:SI\n+        (match_operand:SI 1 \"register_operand\" \"0,0,0,0,0,0,0\")\n+        (match_operand:SI 2 \"general_operand\" \"r,Q>,J,N,P,n,g\")))]\n+  \"TARGET_V32\"\n+  \"@\n+   sub.d %2,%0\n+   sub.d %2,%0\n+   subq %2,%0\n+   addq %n2,%0\n+   sub%e2.%z2 %2,%0\n+   sub.d %2,%0\n+   sub.d %2,%0\"\n+  [(set_attr \"slottable\" \"yes,yes,yes,yes,no,no,no\")])\n \f\n-(define_insn \"sub<mode>3\"\n+(define_insn \"*sub<mode>3_nonv32\"\n   [(set (match_operand:BW 0 \"register_operand\"\t\t\"=r,r, r,r,r,r\")\n \t(minus:BW (match_operand:BW 1 \"register_operand\" \"0,0, 0,0,0,r\")\n \t\t  (match_operand:BW 2 \"general_operand\"  \"r,Q>,J,N,g,!To\")))]\n-  \"\"\n+  \"!TARGET_V32\"\n   \"@\n    sub<m> %2,%0\n    sub<m> %2,%0\n@@ -1598,6 +2042,20 @@\n    sub<m> %2,%1,%0\"\n   [(set_attr \"slottable\" \"yes,yes,yes,yes,no,no\")\n    (set_attr \"cc\" \"normal,normal,clobber,clobber,normal,normal\")])\n+\n+(define_insn \"*sub<mode>3_v32\"\n+  [(set (match_operand:BW 0 \"register_operand\" \"=r,r,r,r,r\")\n+\t(minus:BW (match_operand:BW 1 \"register_operand\" \"0,0,0,0,0\")\n+\t\t  (match_operand:BW 2 \"general_operand\" \"r,Q>,J,N,g\")))]\n+  \"TARGET_V32\"\n+  \"@\n+   sub<m> %2,%0\n+   sub<m> %2,%0\n+   subq %2,%0\n+   addq %n2,%0\n+   sub<m> %2,%0\"\n+  [(set_attr \"slottable\" \"yes,yes,yes,yes,no\")\n+   (set_attr \"cc\" \"normal,normal,clobber,clobber,normal\")])\n \f\n ;; CRIS has some add/sub-with-sign/zero-extend instructions.\n ;;  Although these perform sign/zero-extension to SImode, they are\n@@ -1720,7 +2178,7 @@\n \f\n \n ;; As with op.S we may have to add special pattern to match commuted\n-;; operands to adds/addu  and bound\n+;; operands to adds/addu and bound\n ;;\n ;; adds/addu/bound [rx=ry+rz.S]\n \n@@ -1831,15 +2289,15 @@\n ;; QImode to HImode\n ;; FIXME: GCC should widen.\n \n-(define_insn \"*extopqihi\"\n+(define_insn \"*extopqihi_non_v32\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r,r,r,r\")\n \t(match_operator:HI\n \t 3 \"cris_additive_operand_extend_operator\"\n \t [(match_operand:HI 1 \"register_operand\" \"0,0,0,r\")\n \t  (match_operator:HI\n \t   4 \"cris_extend_operator\"\n \t   [(match_operand:QI 2 \"nonimmediate_operand\" \"r,Q>,m,!To\")])]))]\n-  \"GET_MODE_SIZE (GET_MODE (operands[0])) <= UNITS_PER_WORD\n+  \"!TARGET_V32 && GET_MODE_SIZE (GET_MODE (operands[0])) <= UNITS_PER_WORD\n    && (operands[1] != frame_pointer_rtx || GET_CODE (operands[3]) != PLUS)\"\n   \"@\n    %x3%E4.%m4 %2,%0\n@@ -1849,17 +2307,31 @@\n   [(set_attr \"slottable\" \"yes,yes,no,no\")\n    (set_attr \"cc\" \"clobber\")])\n \n+(define_insn \"*extopqihi_v32\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n+\t(match_operator:HI\n+\t 3 \"cris_additive_operand_extend_operator\"\n+\t [(match_operand:HI 1 \"register_operand\" \"0,0\")\n+\t  (match_operator:HI\n+\t   4 \"cris_extend_operator\"\n+\t   [(match_operand:QI 2 \"nonimmediate_operand\" \"r,m\")])]))]\n+  \"TARGET_V32\"\n+  \"%x3%e4.%m4 %2,%0\"\n+  [(set_attr \"slottable\" \"yes\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n ;; QImode to SImode\n \n-(define_insn \"*extop<mode>si\"\n+(define_insn \"*extop<mode>si_non_v32\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r,r\")\n \t(match_operator:SI\n \t 3 \"cris_operand_extend_operator\"\n \t [(match_operand:SI 1 \"register_operand\" \"0,0,0,r\")\n \t  (match_operator:SI\n \t   4 \"cris_extend_operator\"\n \t   [(match_operand:BW 2 \"nonimmediate_operand\" \"r,Q>,m,!To\")])]))]\n-  \"(GET_CODE (operands[3]) != UMIN || GET_CODE (operands[4]) == ZERO_EXTEND)\n+  \"!TARGET_V32\n+   && (GET_CODE (operands[3]) != UMIN || GET_CODE (operands[4]) == ZERO_EXTEND)\n    && GET_MODE_SIZE (GET_MODE (operands[0])) <= UNITS_PER_WORD\n    && (operands[1] != frame_pointer_rtx || GET_CODE (operands[3]) != PLUS)\"\n   \"@\n@@ -1868,21 +2340,32 @@\n    %x3%E4<m> %2,%0\n    %x3%E4<m> %2,%1,%0\"\n   [(set_attr \"slottable\" \"yes,yes,no,no\")])\n-\f\n \n+(define_insn \"*extop<mode>si_v32\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(match_operator:SI\n+\t 3 \"cris_additive_operand_extend_operator\"\n+\t [(match_operand:SI 1 \"register_operand\" \"0,0\")\n+\t  (match_operator:SI\n+\t   4 \"cris_extend_operator\"\n+\t   [(match_operand:BW 2 \"nonimmediate_operand\" \"r,m\")])]))]\n+  \"TARGET_V32\"\n+  \"%x3%e4.%m4 %2,%0\"\n+  [(set_attr \"slottable\" \"yes\")])\n+\f\n ;; As with the side-effect patterns, may have to have swapped operands for add.\n-;; FIXME: *should* be redundant to gcc.\n+;; For commutative operands, these are the canonical forms.\n \n ;; QImode to HImode\n \n-(define_insn \"*extopqihi_swap\"\n+(define_insn \"*addxqihi_swap_non_v32\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r,r,r,r\")\n \t(plus:HI\n \t (match_operator:HI\n \t  3 \"cris_extend_operator\"\n \t  [(match_operand:QI 2 \"nonimmediate_operand\" \"r,Q>,m,!To\")])\n \t (match_operand:HI 1 \"register_operand\" \"0,0,0,r\")))]\n-  \"operands[1] != frame_pointer_rtx\"\n+  \"!TARGET_V32 && operands[1] != frame_pointer_rtx\"\n   \"@\n    add%e3.b %2,%0\n    add%e3.b %2,%0\n@@ -1891,22 +2374,85 @@\n   [(set_attr \"slottable\" \"yes,yes,no,no\")\n    (set_attr \"cc\" \"clobber\")])\n \n-(define_insn \"*extop<mode>si_swap\"\n+;; A case for v32, to catch the \"addo\" insn in addition to \"adds\".  We\n+;; only care to match the canonical form; there should be no other.\n+\n+(define_insn \"*addsbw_v32\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r,!a\")\n+\t(plus:HI\n+\t (sign_extend:HI\n+\t  (match_operand:QI 2 \"nonimmediate_operand\" \"r,m,m\"))\n+\t (match_operand:HI 1 \"register_operand\" \"0,0,r\")))]\n+  \"TARGET_V32\"\n+  \"@\n+   adds.b %2,%0\n+   adds.b %2,%0\n+   addo.b %2,%1,%0\"\n+  [(set_attr \"slottable\" \"yes\")\n+   (set_attr \"cc\" \"clobber,clobber,none\")])\n+\n+(define_insn \"*addubw_v32\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n+\t(plus:HI\n+\t (zero_extend:HI\n+\t  (match_operand:QI 2 \"nonimmediate_operand\" \"r,m\"))\n+\t (match_operand:HI 1 \"register_operand\" \"0,0\")))]\n+  \"TARGET_V32\"\n+  \"addu.b %2,%0\"\n+  [(set_attr \"slottable\" \"yes\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"*extop<mode>si_swap_non_v32\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r,r\")\n \t(match_operator:SI\n \t 4 \"cris_plus_or_bound_operator\"\n \t [(match_operator:SI\n \t   3 \"cris_extend_operator\"\n \t   [(match_operand:BW 2 \"nonimmediate_operand\" \"r,Q>,m,!To\")])\n \t  (match_operand:SI 1 \"register_operand\" \"0,0,0,r\")]))]\n-  \"(GET_CODE (operands[4]) != UMIN || GET_CODE (operands[3]) == ZERO_EXTEND)\n+  \"!TARGET_V32\n+   && (GET_CODE (operands[4]) != UMIN || GET_CODE (operands[3]) == ZERO_EXTEND)\n    && operands[1] != frame_pointer_rtx\"\n   \"@\n    %x4%E3<m> %2,%0\n    %x4%E3<m> %2,%0\n    %x4%E3<m> %2,%0\n    %x4%E3<m> %2,%1,%0\"\n   [(set_attr \"slottable\" \"yes,yes,no,no\")])\n+\n+(define_insn \"*adds<mode>_v32\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,!a\")\n+\t(plus:SI\n+\t (sign_extend:SI\n+\t  (match_operand:BW 2 \"nonimmediate_operand\" \"r,m,m\"))\n+\t (match_operand:SI 1 \"register_operand\" \"0,0,r\")))]\n+  \"TARGET_V32\"\n+  \"@\n+   adds<m> %2,%0\n+   adds<m> %2,%0\n+   addo<m> %2,%1,%0\"\n+  [(set_attr \"slottable\" \"yes\")\n+   (set_attr \"cc\" \"*,*,none\")])\n+\n+(define_insn \"*addu<mode>_v32\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+       (plus:SI\n+        (zero_extend:SI\n+          (match_operand:BW 2 \"nonimmediate_operand\" \"r,m\"))\n+        (match_operand:SI 1 \"register_operand\" \"0,0\")))]\n+  \"TARGET_V32 && operands[1] != frame_pointer_rtx\"\n+  \"addu<m> %2,%0\"\n+  [(set_attr \"slottable\" \"yes\")])\n+\n+(define_insn \"*bound<mode>_v32\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+       (umin:SI\n+        (zero_extend:SI\n+         (match_operand:BW 2 \"register_operand\" \"r\"))\n+        (match_operand:SI 1 \"register_operand\" \"0\")))]\n+  \"TARGET_V32 && operands[1] != frame_pointer_rtx\"\n+  \"bound<m> %2,%0\"\n+  [(set_attr \"slottable\" \"yes\")])\n \f\n ;; This is the special case when we use what corresponds to the\n ;; instruction above in \"casesi\".  Do *not* change it to use the generic\n@@ -1940,11 +2486,29 @@\n \t\t  (pc))\n \t (label_ref (match_operand 2 \"\" \"\"))))\n    (use (label_ref (match_operand 3 \"\" \"\")))]\n-\n-  \"operands[0] != frame_pointer_rtx\"\n-\n+  \"!TARGET_V32 && operands[0] != frame_pointer_rtx\"\n   \"adds.w [$pc+%0.w],$pc\"\n   [(set_attr \"cc\" \"clobber\")])\n+\n+;; For V32, we just have a jump, but we need to mark the table as used,\n+;; and the jump insn must have the if_then_else form expected by core\n+;; GCC.  Since we don't want to prolong the lifetime of the original\n+;; index value, we compare against \"unspec 0\".  It's a pity we have to\n+;; jump through to get the default label in place and to keep the jump\n+;; table around.  FIXME: Look into it some time.\n+\n+(define_insn \"*casesi_jump_v32\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (ltu (unspec [(const_int 0)] CRIS_UNSPEC_CASESI)\n+\t      (match_operand:SI 0 \"const_int_operand\" \"n\"))\n+\t (match_operand:SI 1 \"register_operand\" \"r\")\n+\t (label_ref (match_operand 2 \"\" \"\"))))\n+   (use (label_ref (match_operand 3 \"\" \"\")))]\n+  \"TARGET_V32\"\n+  \"jump %1%#\"\n+  [(set_attr \"cc\" \"clobber\")\n+   (set_attr \"slottable\" \"has_slot\")])\n \f\n ;; Multiply instructions.\n \n@@ -1984,18 +2548,24 @@\n \n ;; The addi insn as it is normally used.\n \n+;; Make the the ACR alternative taste bad enough to not choose it as a\n+;; preference to avoid spilling problems (unwind-dw2-fde.c at build).\n+;; FIXME: Revisit for new register allocator.\n+\n (define_insn \"*addi\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,!a\")\n \t(plus:SI\n-\t (mult:SI (match_operand:SI 2 \"register_operand\" \"r\")\n-\t\t  (match_operand:SI 3 \"const_int_operand\" \"n\"))\n-\t (match_operand:SI 1 \"register_operand\" \"0\")))]\n+\t (mult:SI (match_operand:SI 2 \"register_operand\" \"r,r\")\n+\t\t  (match_operand:SI 3 \"const_int_operand\" \"n,n\"))\n+\t (match_operand:SI 1 \"register_operand\" \"0,r\")))]\n   \"operands[0] != frame_pointer_rtx\n    && operands[1] != frame_pointer_rtx\n    && CONST_INT_P (operands[3])\n    && (INTVAL (operands[3]) == 1\n        || INTVAL (operands[3]) == 2 || INTVAL (operands[3]) == 4)\"\n-  \"addi %2%T3,%0\"\n+  \"@\n+   addi %2%T3,%0\n+   addi %2%T3,%1,%0\"\n   [(set_attr \"slottable\" \"yes\")\n    (set_attr \"cc\" \"none\")])\n \n@@ -2012,7 +2582,7 @@\n \t\t  (match_operand:SI 2 \"register_operand\" \"r\"))\n \t (ashift:SI (match_operand:SI 3 \"register_operand\" \"0\")\n \t\t    (const_int 1))))]\n-  \"\"\n+  \"!TARGET_V32\"\n   \"mstep %2,%0\"\n   [(set_attr \"slottable\" \"yes\")])\n \n@@ -2030,7 +2600,8 @@\n \t\t  (match_operand:SI 2 \"register_operand\" \"r\"))\n \t (mult:SI (match_operand:SI 3 \"register_operand\" \"0\")\n \t\t  (const_int 2))))]\n-  \"operands[0] != frame_pointer_rtx\n+  \"!TARGET_V32\n+   && operands[0] != frame_pointer_rtx\n    && operands[1] != frame_pointer_rtx\n    && operands[2] != frame_pointer_rtx\n    && operands[3] != frame_pointer_rtx\"\n@@ -2107,7 +2678,7 @@\n ;; a / 1000;}\" and unsigned.  FIXME: Comment above was for 3.2, revisit.\n \n (define_insn \"<su>mulsi3_highpart\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=h,h,?r,?r\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"=h,h,?r,?r\")\n \t(truncate:SI\n \t (lshiftrt:DI\n \t  (mult:DI\n@@ -2139,7 +2710,8 @@\n \t\t\t(const_int 1))))]\n   \"\"\n   \"dstep %2,%0\"\n-  [(set_attr \"slottable\" \"yes\")])\n+  [(set_attr \"slottable\" \"yes\")\n+   (set_attr \"cc\" \"noov32\")])\n \n ;; Here's a variant with mult instead of ashift.\n ;;\n@@ -2161,7 +2733,8 @@\n    && operands[2] != frame_pointer_rtx\n    && operands[3] != frame_pointer_rtx\"\n   \"dstep %2,%0\"\n-  [(set_attr \"slottable\" \"yes\")])\n+  [(set_attr \"slottable\" \"yes\")\n+   (set_attr \"cc\" \"noov32\")])\n \f\n ;; Logical operators.\n \n@@ -2256,18 +2829,31 @@\n ;; pressure (worse code).  That will hopefully change with an\n ;; improved reload pass.\n \n-(define_insn \"*expanded_andsi\"\n+(define_insn \"*expanded_andsi_non_v32\"\n   [(set (match_operand:SI 0 \"register_operand\"\t       \"=r,r,r, r,r\")\n \t(and:SI (match_operand:SI 1 \"register_operand\" \"%0,0,0, 0,r\")\n \t\t(match_operand:SI 2 \"general_operand\"   \"I,r,Q>,g,!To\")))]\n-  \"\"\n+  \"!TARGET_V32\"\n   \"@\n    andq %2,%0\n    and.d %2,%0\n    and.d %2,%0\n    and.d %2,%0\n    and.d %2,%1,%0\"\n   [(set_attr \"slottable\" \"yes,yes,yes,no,no\")])\n+\n+(define_insn \"*expanded_andsi_v32\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r,r\")\n+\t(and:SI (match_operand:SI 1 \"register_operand\" \"%0,0,0,0\")\n+\t\t(match_operand:SI 2 \"general_operand\" \"I,r,Q>,g\")))]\n+  \"TARGET_V32\"\n+  \"@\n+   andq %2,%0\n+   and.d %2,%0\n+   and.d %2,%0\n+   and.d %2,%0\"\n+  [(set_attr \"slottable\" \"yes,yes,yes,no\")\n+   (set_attr \"cc\" \"noov32\")])\n \f\n ;; For both QI and HI we may use the quick patterns.  This results in\n ;; useless condition codes, but that is used rarely enough for it to\n@@ -2331,7 +2917,7 @@\n \n ;; Catch-all andhi3 pattern.\n \n-(define_insn \"*expanded_andhi\"\n+(define_insn \"*expanded_andhi_non_v32\"\n   [(set (match_operand:HI 0 \"register_operand\"\t       \"=r,r,r, r,r,r,r\")\n \t(and:HI (match_operand:HI 1 \"register_operand\" \"%0,0,0, 0,0,0,r\")\n \t\t(match_operand:HI 2 \"general_operand\"   \"I,r,Q>,L,O,g,!To\")))]\n@@ -2341,7 +2927,7 @@\n ;; pressure (worse code).  That will hopefully change with an\n ;; improved reload pass.\n \n-  \"\"\n+  \"!TARGET_V32\"\n   \"@\n    andq %2,%0\n    and.w %2,%0\n@@ -2353,14 +2939,29 @@\n   [(set_attr \"slottable\" \"yes,yes,yes,no,yes,no,no\")\n    (set_attr \"cc\" \"clobber,normal,normal,normal,clobber,normal,normal\")])\n \n+(define_insn \"*expanded_andhi_v32\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r,r,r,r,r\")\n+       (and:HI (match_operand:HI 1 \"register_operand\" \"%0,0,0,0,0,0\")\n+               (match_operand:HI 2 \"general_operand\" \"I,r,Q>,L,O,g\")))]\n+  \"TARGET_V32\"\n+  \"@\n+   andq %2,%0\n+   and.w %2,%0\n+   and.w %2,%0\n+   and.w %2,%0\n+   anDq %b2,%0\n+   and.w %2,%0\"\n+  [(set_attr \"slottable\" \"yes,yes,yes,no,yes,no\")\n+   (set_attr \"cc\" \"clobber,noov32,noov32,noov32,clobber,noov32\")])\n+\n ;; A strict_low_part pattern.\n \n-(define_insn \"*andhi_lowpart\"\n+(define_insn \"*andhi_lowpart_non_v32\"\n   [(set (strict_low_part\n \t (match_operand:HI 0 \"register_operand\"\t       \"=r,r, r,r,r,r\"))\n \t(and:HI (match_operand:HI 1 \"register_operand\" \"%0,0, 0,0,0,r\")\n \t\t(match_operand:HI 2 \"general_operand\"   \"r,Q>,L,O,g,!To\")))]\n-  \"\"\n+  \"!TARGET_V32\"\n   \"@\n    and.w %2,%0\n    and.w %2,%0\n@@ -2370,12 +2971,34 @@\n    and.w %2,%1,%0\"\n   [(set_attr \"slottable\" \"yes,yes,no,yes,no,no\")\n    (set_attr \"cc\" \"normal,normal,normal,clobber,normal,normal\")])\n+\n+(define_insn \"*andhi_lowpart_v32\"\n+  [(set (strict_low_part\n+\t (match_operand:HI 0 \"register_operand\" \"=r,r,r,r,r\"))\n+\t(and:HI (match_operand:HI 1 \"register_operand\" \"%0,0,0,0,0\")\n+\t\t(match_operand:HI 2 \"general_operand\" \"r,Q>,L,O,g\")))]\n+  \"TARGET_V32\"\n+  \"@\n+   and.w %2,%0\n+   and.w %2,%0\n+   and.w %2,%0\n+   anDq %b2,%0\n+   and.w %2,%0\"\n+  [(set_attr \"slottable\" \"yes,yes,no,yes,no\")\n+   (set_attr \"cc\" \"noov32,noov32,noov32,clobber,noov32\")])\n \f\n-(define_insn \"andqi3\"\n+(define_expand \"andqi3\"\n+  [(set (match_operand:QI 0 \"register_operand\")\n+\t(and:QI (match_operand:QI 1 \"register_operand\")\n+               (match_operand:QI 2 \"general_operand\")))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"*andqi3_non_v32\"\n   [(set (match_operand:QI 0 \"register_operand\"\t       \"=r,r,r, r,r,r\")\n \t(and:QI (match_operand:QI 1 \"register_operand\" \"%0,0,0, 0,0,r\")\n \t\t(match_operand:QI 2 \"general_operand\"   \"I,r,Q>,O,g,!To\")))]\n-  \"\"\n+  \"!TARGET_V32\"\n   \"@\n    andq %2,%0\n    and.b %2,%0\n@@ -2386,12 +3009,26 @@\n   [(set_attr \"slottable\" \"yes,yes,yes,yes,no,no\")\n    (set_attr \"cc\" \"clobber,normal,normal,clobber,normal,normal\")])\n \n-(define_insn \"*andqi_lowpart\"\n+(define_insn \"*andqi3_v32\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r,r,r,r,r\")\n+\t(and:QI (match_operand:QI 1 \"register_operand\" \"%0,0,0,0,0\")\n+\t\t(match_operand:QI 2 \"general_operand\" \"I,r,Q>,O,g\")))]\n+  \"TARGET_V32\"\n+  \"@\n+   andq %2,%0\n+   and.b %2,%0\n+   and.b %2,%0\n+   andQ %b2,%0\n+   and.b %2,%0\"\n+  [(set_attr \"slottable\" \"yes,yes,yes,yes,no\")\n+   (set_attr \"cc\" \"clobber,noov32,noov32,clobber,noov32\")])\n+\n+(define_insn \"*andqi_lowpart_non_v32\"\n   [(set (strict_low_part\n \t (match_operand:QI 0 \"register_operand\"\t       \"=r,r, r,r,r\"))\n \t(and:QI (match_operand:QI 1 \"register_operand\" \"%0,0, 0,0,r\")\n \t\t(match_operand:QI 2 \"general_operand\"   \"r,Q>,O,g,!To\")))]\n-  \"\"\n+  \"!TARGET_V32\"\n   \"@\n    and.b %2,%0\n    and.b %2,%0\n@@ -2400,6 +3037,20 @@\n    and.b %2,%1,%0\"\n   [(set_attr \"slottable\" \"yes,yes,yes,no,no\")\n    (set_attr \"cc\" \"normal,normal,clobber,normal,normal\")])\n+\n+(define_insn \"*andqi_lowpart_v32\"\n+  [(set (strict_low_part\n+\t (match_operand:QI 0 \"register_operand\" \"=r,r,r,r\"))\n+\t(and:QI (match_operand:QI 1 \"register_operand\" \"%0,0,0,0\")\n+\t\t(match_operand:QI 2 \"general_operand\" \"r,Q>,O,g\")))]\n+  \"TARGET_V32\"\n+  \"@\n+   and.b %2,%0\n+   and.b %2,%0\n+   andQ %b2,%0\n+   and.b %2,%0\"\n+  [(set_attr \"slottable\" \"yes,yes,yes,no\")\n+   (set_attr \"cc\" \"noov32,noov32,clobber,noov32\")])\n \f\n ;; Bitwise or.\n \n@@ -2408,11 +3059,18 @@\n ;; It seems there's no need to jump through hoops to get good code such as\n ;; with andsi3.\n \n-(define_insn \"iorsi3\"\n+(define_expand \"ior<mode>3\"\n+  [(set (match_operand:BWD 0 \"register_operand\")\n+\t(ior:BWD (match_operand:BWD 1 \"register_operand\")\n+\t\t (match_operand:BWD 2 \"general_operand\")))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"*iorsi3_non_v32\"\n   [(set (match_operand:SI 0 \"register_operand\"\t       \"=r,r,r, r,r,r\")\n \t(ior:SI (match_operand:SI 1 \"register_operand\" \"%0,0,0, 0,0,r\")\n \t\t(match_operand:SI 2 \"general_operand\"  \"I, r,Q>,n,g,!To\")))]\n-  \"\"\n+  \"!TARGET_V32\"\n   \"@\n    orq %2,%0\n    or.d %2,%0\n@@ -2423,11 +3081,25 @@\n   [(set_attr \"slottable\" \"yes,yes,yes,no,no,no\")\n    (set_attr \"cc\" \"normal,normal,normal,clobber,normal,normal\")])\n \n-(define_insn \"iorhi3\"\n+(define_insn \"*iorsi3_v32\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r,r,r\")\n+\t(ior:SI (match_operand:SI 1 \"register_operand\" \"%0,0,0,0,0\")\n+\t\t(match_operand:SI 2 \"general_operand\" \"I,r,Q>,n,g\")))]\n+  \"TARGET_V32\"\n+  \"@\n+   orq %2,%0\n+   or.d %2,%0\n+   or.d %2,%0\n+   oR.%s2 %2,%0\n+   or.d %2,%0\"\n+  [(set_attr \"slottable\" \"yes,yes,yes,no,no\")\n+   (set_attr \"cc\" \"noov32,noov32,noov32,clobber,noov32\")])\n+\n+(define_insn \"*iorhi3_non_v32\"\n   [(set (match_operand:HI 0 \"register_operand\"\t       \"=r,r,r, r,r,r,r\")\n \t(ior:HI (match_operand:HI 1 \"register_operand\" \"%0,0,0, 0,0,0,r\")\n \t\t(match_operand:HI 2 \"general_operand\"   \"I,r,Q>,L,O,g,!To\")))]\n-  \"\"\n+  \"!TARGET_V32\"\n   \"@\n    orq %2,%0\n    or.w %2,%0\n@@ -2439,11 +3111,26 @@\n   [(set_attr \"slottable\" \"yes,yes,yes,no,yes,no,no\")\n    (set_attr \"cc\" \"clobber,normal,normal,normal,clobber,normal,normal\")])\n \n-(define_insn \"iorqi3\"\n+(define_insn \"*iorhi3_v32\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r,r,r,r,r\")\n+\t(ior:HI (match_operand:HI 1 \"register_operand\" \"%0,0,0,0,0,0\")\n+\t\t(match_operand:HI 2 \"general_operand\" \"I,r,Q>,L,O,g\")))]\n+  \"TARGET_V32\"\n+  \"@\n+   orq %2,%0\n+   or.w %2,%0\n+   or.w %2,%0\n+   or.w %2,%0\n+   oRq %b2,%0\n+   or.w %2,%0\"\n+  [(set_attr \"slottable\" \"yes,yes,yes,no,yes,no\")\n+   (set_attr \"cc\" \"clobber,noov32,noov32,noov32,clobber,noov32\")])\n+\n+(define_insn \"*iorqi3_non_v32\"\n   [(set (match_operand:QI 0 \"register_operand\"\t       \"=r,r,r, r,r,r\")\n \t(ior:QI (match_operand:QI 1 \"register_operand\" \"%0,0,0, 0,0,r\")\n \t\t(match_operand:QI 2 \"general_operand\"   \"I,r,Q>,O,g,!To\")))]\n-  \"\"\n+  \"!TARGET_V32\"\n   \"@\n    orq %2,%0\n    or.b %2,%0\n@@ -2453,6 +3140,20 @@\n    or.b %2,%1,%0\"\n   [(set_attr \"slottable\" \"yes,yes,yes,yes,no,no\")\n    (set_attr \"cc\" \"clobber,normal,normal,clobber,normal,normal\")])\n+\n+(define_insn \"*iorqi3_v32\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r,r,r,r,r\")\n+\t(ior:QI (match_operand:QI 1 \"register_operand\" \"%0,0,0,0,0\")\n+\t\t(match_operand:QI 2 \"general_operand\" \"I,r,Q>,O,g\")))]\n+  \"TARGET_V32\"\n+  \"@\n+   orq %2,%0\n+   or.b %2,%0\n+   or.b %2,%0\n+   orQ %b2,%0\n+   or.b %2,%0\"\n+  [(set_attr \"slottable\" \"yes,yes,yes,yes,no\")\n+   (set_attr \"cc\" \"clobber,noov32,noov32,clobber,noov32\")])\n \f\n ;; Exclusive-or\n \n@@ -2465,7 +3166,8 @@\n \t\t(match_operand:SI 2 \"register_operand\" \"r\")))]\n   \"\"\n   \"xor %2,%0\"\n-  [(set_attr \"slottable\" \"yes\")])\n+  [(set_attr \"slottable\" \"yes\")\n+   (set_attr \"cc\" \"noov32\")])\n \n (define_insn \"xor<mode>3\"\n   [(set (match_operand:BW 0 \"register_operand\" \"=r\")\n@@ -2522,7 +3224,8 @@\n \t(not:SI (match_operand:SI 1 \"register_operand\" \"0\")))]\n   \"\"\n   \"not %0\"\n-  [(set_attr \"slottable\" \"yes\")])\n+  [(set_attr \"slottable\" \"yes\")\n+   (set_attr \"cc\" \"noov32\")])\n \n (define_insn \"one_cmpl<mode>2\"\n   [(set (match_operand:BW 0 \"register_operand\" \"=r\")\n@@ -2545,7 +3248,8 @@\n \n   return \"<slr>q %2,%0\";\n }\n-  [(set_attr \"slottable\" \"yes\")])\n+  [(set_attr \"slottable\" \"yes\")\n+   (set_attr \"cc\" \"noov32\")])\n \n ;; Since gcc gets lost, and forgets to zero-extend the source (or mask\n ;; the destination) when it changes shifts of lower modes into SImode,\n@@ -2595,15 +3299,17 @@\n \t\t    (match_operand:BW 2 \"register_operand\" \"r\")))]\n   \"\"\n   \"<slr><m> %2,%0\"\n-  [(set_attr \"slottable\" \"yes\")])\n+  [(set_attr \"slottable\" \"yes\")\n+   (set_attr \"cc\" \"noov32\")])\n \n (define_insn \"*<shlr><mode>_lowpart\"\n   [(set (strict_low_part (match_operand:BW 0 \"register_operand\" \"+r\"))\n \t(shiftrt:BW (match_dup 0)\n \t\t    (match_operand:BW 1 \"register_operand\" \"r\")))]\n   \"\"\n   \"<slr><m> %1,%0\"\n-  [(set_attr \"slottable\" \"yes\")])\n+  [(set_attr \"slottable\" \"yes\")\n+   (set_attr \"cc\" \"noov32\")])\n \f\n ;; Arithmetic/logical shift left.\n \n@@ -2624,7 +3330,7 @@\n        ? \"lslq %2,%0\" : \"lsl<m> %2,%0\");\n }\n   [(set_attr \"slottable\" \"yes\")\n-   (set_attr \"cc\" \"normal,clobber\")])\n+   (set_attr \"cc\" \"noov32,clobber\")])\n \n ;; A strict_low_part matcher.\n \n@@ -2634,7 +3340,8 @@\n \t\t   (match_operand:HI 1 \"register_operand\" \"r\")))]\n   \"\"\n   \"lsl<m> %1,%0\"\n-  [(set_attr \"slottable\" \"yes\")])\n+  [(set_attr \"slottable\" \"yes\")\n+   (set_attr \"cc\" \"noov32\")])\n \f\n ;; Various strange insns that gcc likes.\n \n@@ -2652,7 +3359,8 @@\n \t(abs:SI (match_operand:SI 1 \"register_operand\" \"r\")))]\n   \"\"\n   \"abs %1,%0\"\n-  [(set_attr \"slottable\" \"yes\")])\n+  [(set_attr \"slottable\" \"yes\")\n+   (set_attr \"cc\" \"noov32\")])\n \n ;; FIXME: GCC should be able to do these expansions itself.\n \n@@ -2670,14 +3378,16 @@\n \t(clz:SI (match_operand:SI 1 \"register_operand\" \"r\")))]\n   \"TARGET_HAS_LZ\"\n   \"lz %1,%0\"\n-  [(set_attr \"slottable\" \"yes\")])\n+  [(set_attr \"slottable\" \"yes\")\n+   (set_attr \"cc\" \"noov32\")])\n \n (define_insn \"bswapsi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n         (bswap:SI (match_operand:SI 1 \"register_operand\" \"0\")))]\n   \"TARGET_HAS_SWAP\"\n   \"swapwb %0\"\n-  [(set_attr \"slottable\" \"yes\")])\n+  [(set_attr \"slottable\" \"yes\")\n+   (set_attr \"cc\" \"noov32\")])\n \n ;; This instruction swaps all bits in a register.\n ;; That means that the most significant bit is put in the place\n@@ -2689,7 +3399,8 @@\n \t\t   CRIS_UNSPEC_SWAP_BITS))]\n   \"TARGET_HAS_SWAP\"\n   \"swapwbr %0\"\n-  [(set_attr \"slottable\" \"yes\")])\n+  [(set_attr \"slottable\" \"yes\")\n+   (set_attr \"cc\" \"noov32\")])\n \n ;; Implement ctz using two instructions, one for bit swap and one for clz.\n ;; Defines a scratch register to avoid clobbering input.\n@@ -2708,11 +3419,21 @@\n ;; operation supported by gcc.  Used in casesi, but used now and then in\n ;; normal code too.\n \n-(define_insn \"uminsi3\"\n+(define_expand \"uminsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(umin:SI  (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t  (match_operand:SI 2 \"general_operand\" \"\")))]\n+  \"\"\n+{\n+  if (MEM_P (operands[2]) && TARGET_V32)\n+    operands[2] = force_reg (SImode, operands[2]);\n+})\n+\n+(define_insn \"*uminsi3_non_v32\"\n   [(set (match_operand:SI 0 \"register_operand\"\t\t \"=r,r, r,r\")\n \t(umin:SI  (match_operand:SI 1 \"register_operand\" \"%0,0, 0,r\")\n \t\t  (match_operand:SI 2 \"general_operand\"   \"r,Q>,g,!To\")))]\n-  \"\"\n+  \"!TARGET_V32\"\n {\n   if (CONST_INT_P (operands[2]))\n     {\n@@ -2733,6 +3454,30 @@\n   return \"bound.d %2,%0\";\n }\n  [(set_attr \"slottable\" \"yes,yes,no,no\")])\n+\n+(define_insn \"*uminsi3_v32\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(umin:SI  (match_operand:SI 1 \"register_operand\" \"%0,0\")\n+\t\t  (match_operand:SI 2 \"nonmemory_operand\" \"r,i\")))]\n+  \"TARGET_V32\"\n+{\n+  if (GET_CODE (operands[2]) == CONST_INT)\n+    {\n+      /* Constant operands are zero-extended, so only 32-bit operands\n+\t may be negative.  */\n+      if (INTVAL (operands[2]) >= 0)\n+\t{\n+\t  if (INTVAL (operands[2]) < 256)\n+\t    return \"bound.b %2,%0\";\n+\n+\t  if (INTVAL (operands[2]) < 65536)\n+\t    return \"bound.w %2,%0\";\n+\t}\n+    }\n+\n+  return \"bound.d %2,%0\";\n+}\n+ [(set_attr \"slottable\" \"yes,no\")])\n \f\n ;; Jump and branch insns.\n \n@@ -2748,11 +3493,25 @@\n ;; jmp_uses_reg_or_mem used by computed_jump_p.  Perhaps it is a kludge to\n ;; change from general_operand to nonimmediate_operand (at least the docs\n ;; should be changed), but then again the pattern is called indirect_jump.\n-(define_insn \"indirect_jump\"\n-  [(set (pc) (match_operand:SI 0 \"nonimmediate_operand\" \"rm\"))]\n+(define_expand \"indirect_jump\"\n+  [(set (pc) (match_operand:SI 0 \"nonimmediate_operand\"))]\n   \"\"\n+{\n+  if (TARGET_V32 && MEM_P (operands[0]))\n+    operands[0] = force_reg (SImode, operands[0]);\n+})\n+\n+(define_insn \"*indirect_jump_non_v32\"\n+  [(set (pc) (match_operand:SI 0 \"nonimmediate_operand\" \"rm\"))]\n+  \"!TARGET_V32\"\n   \"jump %0\")\n \n+(define_insn \"*indirect_jump_v32\"\n+  [(set (pc) (match_operand:SI 0 \"register_operand\" \"r\"))]\n+  \"TARGET_V32\"\n+  \"jump %0%#\"\n+  [(set_attr \"slottable\" \"has_slot\")])\n+\n ;; Return insn.  Used whenever the epilogue is very simple; if it is only\n ;; a single ret or jump [sp+].  No allocated stack space or saved\n ;; registers are allowed.\n@@ -2777,7 +3536,7 @@\n \t      \"(cris_return_address_on_stack_for_return ())\")\n  \t     (const_int 0))\n  \t (const_string \"no\")\n-\t (const_string \"has_slot\")))])\n+\t (const_string \"has_return_slot\")))])\n \n (define_expand \"prologue\"\n   [(const_int 0)]\n@@ -2935,14 +3694,27 @@\n ;; Accept *anything* as operand 1.  Accept operands for operand 0 in\n ;; order of preference.\n \n-(define_insn \"*expanded_call\"\n-  [(call (mem:QI (match_operand:SI\n-\t\t  0 \"cris_general_operand_or_plt_symbol\" \"r,Q>,g\"))\n+(define_insn \"*expanded_call_non_v32\"\n+  [(call (mem:QI (match_operand:SI 0 \"general_operand\" \"r,Q>,g\"))\n \t (match_operand 1 \"\" \"\"))\n    (clobber (reg:SI CRIS_SRP_REGNUM))]\n-  \"\"\n+  \"!TARGET_V32\"\n   \"jsr %0\")\n \n+(define_insn \"*expanded_call_v32\"\n+  [(call\n+    (mem:QI\n+     (match_operand:SI 0 \"cris_nonmemory_operand_or_callable_symbol\" \"n,r,U,i\"))\n+    (match_operand 1 \"\" \"\"))\n+   (clobber (reg:SI CRIS_SRP_REGNUM))]\n+  \"TARGET_V32\"\n+  \"@\n+   jsr %0%#\n+   jsr %0%#\n+   bsr %0%#\n+   bsr %0%#\"\n+  [(set_attr \"slottable\" \"has_call_slot\")])\n+\n ;; Parallel when calculating and reusing address of indirect pointer\n ;; with simple offset.  (Makes most sense with PIC.)  It looks a bit\n ;; wrong not to have the clobber last, but that's the way combine\n@@ -2958,7 +3730,7 @@\n    (set (match_operand:SI 3 \"register_operand\" \"=*0,r,r\")\n \t(plus:SI (match_dup 0)\n \t\t (match_dup 1)))]\n-  \"! TARGET_AVOID_GOTPLT\"\n+  \"!TARGET_AVOID_GOTPLT && !TARGET_V32\"\n   \"jsr [%3=%0%S1]\")\n \n (define_expand \"call_value\"\n@@ -2979,13 +3751,12 @@\n ;;  We also accept a PLT symbol.  We output it as [rPIC+sym:GOTPLT] rather\n ;; than requiring getting rPIC + sym:PLT into a register.\n \n-(define_insn \"*expanded_call_value\"\n+(define_insn \"*expanded_call_value_non_v32\"\n   [(set (match_operand 0 \"nonimmediate_operand\" \"=g,g,g\")\n-\t(call (mem:QI (match_operand:SI\n-\t\t       1 \"cris_general_operand_or_plt_symbol\" \"r,Q>,g\"))\n+\t(call (mem:QI (match_operand:SI 1 \"general_operand\" \"r,Q>,g\"))\n \t      (match_operand 2 \"\" \"\")))\n    (clobber (reg:SI CRIS_SRP_REGNUM))]\n-  \"\"\n+  \"!TARGET_V32\"\n   \"Jsr %1\"\n   [(set_attr \"cc\" \"clobber\")])\n \n@@ -3002,10 +3773,27 @@\n    (set (match_operand:SI 4 \"register_operand\" \"=*1,r,r\")\n \t(plus:SI (match_dup 1)\n \t\t (match_dup 2)))]\n-  \"! TARGET_AVOID_GOTPLT\"\n+  \"!TARGET_AVOID_GOTPLT && !TARGET_V32\"\n   \"Jsr [%4=%1%S2]\"\n   [(set_attr \"cc\" \"clobber\")])\n \n+(define_insn \"*expanded_call_value_v32\"\n+  [(set\n+    (match_operand 0 \"nonimmediate_operand\" \"=g,g,g,g\")\n+    (call\n+     (mem:QI\n+      (match_operand:SI 1 \"cris_nonmemory_operand_or_callable_symbol\" \"n,r,U,i\"))\n+     (match_operand 2 \"\" \"\")))\n+   (clobber (reg:SI 16))]\n+  \"TARGET_V32\"\n+  \"@\n+   Jsr %1%#\n+   Jsr %1%#\n+   Bsr %1%#\n+   Bsr %1%#\"\n+  [(set_attr \"cc\" \"clobber\")\n+   (set_attr \"slottable\" \"has_call_slot\")])\n+\n ;; Used in debugging.  No use for the direct pattern; unfilled\n ;; delayed-branches are taken care of by other means.\n \n@@ -3036,7 +3824,7 @@\n ;; this expansion, you must change the macro ASM_OUTPUT_CASE_END\n ;; accordingly, to add the default case at the end of the jump-table.\n \n-(define_expand \"casesi\"\n+(define_expand \"cris_casesi_non_v32\"\n   [(set (match_dup 5) (match_operand:SI 0 \"general_operand\" \"\"))\n    (set (match_dup 6)\n \t(minus:SI (match_dup 5)\n@@ -3062,6 +3850,62 @@\n   operands[6] = gen_reg_rtx (SImode);\n   operands[7] = gen_reg_rtx (SImode);\n })\n+\n+;; FIXME: Check effect of not JUMP_TABLES_IN_TEXT_SECTION.\n+(define_expand \"cris_casesi_v32\"\n+  [(set (match_dup 5) (match_operand:SI 0 \"general_operand\"))\n+   (set (match_dup 6)\n+       (minus:SI (match_dup 5)\n+\t\t (match_operand:SI 1 \"const_int_operand\")))\n+   (set (match_dup 7)\n+       (umin:SI (match_dup 6)\n+\t\t(match_operand:SI 2 \"const_int_operand\")))\n+   (set (match_dup 8) (match_dup 11))\n+   (set (match_dup 9)\n+       (plus:SI (mult:SI (match_dup 7) (const_int 2))\n+\t\t(match_dup 8)))\n+   (set (match_dup 10)\n+       (plus:SI (sign_extend:SI (mem:HI (match_dup 9)))\n+\t\t(match_dup 9)))\n+   (parallel\n+    [(set (pc)\n+\t (if_then_else\n+\t  (ltu (unspec [(const_int 0)] CRIS_UNSPEC_CASESI) (match_dup 2))\n+\t  (match_dup 10)\n+\t  (label_ref (match_operand 4 \"\" \"\"))))\n+     (use (label_ref (match_dup 3)))])]\n+  \"TARGET_V32\"\n+{\n+  int i;\n+  rtx xlabel = gen_rtx_LABEL_REF (VOIDmode, operands[3]);\n+  for (i = 5; i <= 10; i++)\n+    operands[i] = gen_reg_rtx (SImode);\n+  operands[2] = plus_constant (operands[2], 1);\n+\n+  /* Don't forget to decorate labels too, for PIC.  */\n+  operands[11] = flag_pic\n+    ? gen_rtx_CONST (Pmode,\n+\t\t    gen_rtx_UNSPEC (Pmode, gen_rtvec (1, xlabel),\n+\t\t\t\t    CRIS_UNSPEC_PCREL))\n+    : xlabel;\n+})\n+\n+(define_expand \"casesi\"\n+  [(match_operand:SI 0 \"general_operand\")\n+   (match_operand:SI 1 \"const_int_operand\")\n+   (match_operand:SI 2 \"const_int_operand\")\n+   (match_operand 3 \"\" \"\")\n+   (match_operand 4 \"\" \"\")]\n+  \"\"\n+{\n+  if (TARGET_V32)\n+    emit_insn (gen_cris_casesi_v32 (operands[0], operands[1], operands[2],\n+\t\t\t\t    operands[3], operands[4]));\n+  else\n+    emit_insn (gen_cris_casesi_non_v32 (operands[0], operands[1], operands[2],\n+\t\t\t\t\toperands[3], operands[4]));\n+  DONE;\n+})\n \f\n ;; Split-patterns.  Some of them have modes unspecified.  This\n ;; should always be ok; if for no other reason sparc.md has it as\n@@ -3081,7 +3925,9 @@\n ;;  move ry,rz\n ;;  op [rx],rz\n ;; Lose if rz=ry or rx=rz.\n-;; Call this op-extend-split\n+;; Call this op-extend-split.\n+;; Do not match for V32; the addo and addi shouldn't be split\n+;; up.\n \n (define_split\n   [(set (match_operand 0 \"register_operand\" \"\")\n@@ -3091,7 +3937,8 @@\n \t  (match_operator\n \t   3 \"cris_extend_operator\"\n \t   [(match_operand 2 \"memory_operand\" \"\")])]))]\n-  \"REG_P (operands[0])\n+  \"!TARGET_V32\n+   && REG_P (operands[0])\n    && REG_P (operands[1])\n    && REGNO (operands[1]) != REGNO (operands[0])\n    && GET_MODE_SIZE (GET_MODE (operands[0])) <= UNITS_PER_WORD\n@@ -3120,7 +3967,8 @@\n \t  (match_operator\n \t   3 \"cris_extend_operator\"\n \t   [(match_operand 2 \"memory_operand\" \"\")])]))]\n-  \"REG_P (operands[0])\n+  \"!TARGET_V32\n+   && REG_P (operands[0])\n    && REG_P (operands[1])\n    && REGNO (operands[1]) != REGNO (operands[0])\n    && GET_MODE_SIZE (GET_MODE (operands[0])) <= UNITS_PER_WORD\n@@ -3147,7 +3995,8 @@\n \t   3 \"cris_extend_operator\"\n \t   [(match_operand 2 \"memory_operand\" \"\")])\n \t  (match_operand 1 \"register_operand\" \"\")]))]\n-  \"REG_P (operands[0])\n+  \"!TARGET_V32\n+   && REG_P (operands[0])\n    && REG_P (operands[1])\n    && REGNO (operands[1]) != REGNO (operands[0])\n    && GET_MODE_SIZE (GET_MODE (operands[0])) <= UNITS_PER_WORD\n@@ -3172,7 +4021,8 @@\n \t   3 \"cris_extend_operator\"\n \t   [(match_operand 2 \"memory_operand\" \"\")])\n \t  (match_operand 1 \"register_operand\" \"\")]))]\n-  \"REG_P (operands[0])\n+  \"!TARGET_V32\n+   && REG_P (operands[0])\n    && REG_P (operands[1])\n    && REGNO (operands[1]) != REGNO (operands[0])\n    && GET_MODE_SIZE (GET_MODE (operands[0])) <= UNITS_PER_WORD\n@@ -3200,7 +4050,8 @@\n \t 3 \"cris_orthogonal_operator\"\n \t [(match_operand 1 \"register_operand\" \"\")\n \t  (match_operand 2 \"memory_operand\" \"\")]))]\n-  \"REG_P (operands[0])\n+  \"!TARGET_V32\n+   && REG_P (operands[0])\n    && REG_P (operands[1])\n    && REGNO (operands[1]) != REGNO (operands[0])\n    && GET_MODE_SIZE (GET_MODE (operands[0])) <= UNITS_PER_WORD\n@@ -3223,7 +4074,8 @@\n \t 3 \"cris_commutative_orth_op\"\n \t [(match_operand 2 \"memory_operand\" \"\")\n \t  (match_operand 1 \"register_operand\" \"\")]))]\n-  \"REG_P (operands[0])\n+  \"!TARGET_V32\n+   && REG_P (operands[0])\n    && REG_P (operands[1])\n    && REGNO (operands[1]) != REGNO (operands[0])\n    && GET_MODE_SIZE (GET_MODE (operands[0])) <= UNITS_PER_WORD\n@@ -3246,7 +4098,8 @@\n \t 3 \"cris_commutative_orth_op\"\n \t [(match_operand 1 \"register_operand\" \"\")\n \t  (match_operand 2 \"memory_operand\" \"\")]))]\n-  \"REG_P (operands[0]) && REG_P (operands[1])\n+  \"!TARGET_V32\n+   && REG_P (operands[0]) && REG_P (operands[1])\n    && REGNO (operands[1]) != REGNO (operands[0])\n    && GET_MODE_SIZE (GET_MODE (operands[0])) <= UNITS_PER_WORD\n    && REG_P (XEXP (operands[2], 0))\n@@ -3268,7 +4121,8 @@\n \t 3 \"cris_orthogonal_operator\"\n \t [(match_operand 2 \"memory_operand\" \"\")\n \t  (match_operand 1 \"register_operand\" \"\")]))]\n-  \"REG_P (operands[0]) && REG_P (operands[1])\n+  \"!TARGET_V32\n+   && REG_P (operands[0]) && REG_P (operands[1])\n    && REGNO (operands[1]) != REGNO (operands[0])\n    && GET_MODE_SIZE (GET_MODE (operands[0])) <= UNITS_PER_WORD\n    && REG_P (XEXP (operands[2], 0))\n@@ -3818,7 +4672,8 @@\n    && (BASE_P (operands[1]) || BASE_P (operands[2]))\n    && ! CONST_OK_FOR_LETTER_P (INTVAL (operands[2]), 'J')\n    && ! CONST_OK_FOR_LETTER_P (INTVAL (operands[2]), 'N')\n-   && (INTVAL (operands[2]) >= -128 && INTVAL (operands[2]) < 128)\"\n+   && (INTVAL (operands[2]) >= -128 && INTVAL (operands[2]) < 128)\n+   && TARGET_SIDE_EFFECT_PREFIXES\"\n   [(parallel\n     [(set (match_dup 3) (match_dup 5))\n      (set (match_dup 0) (plus:SI (match_dup 1) (match_dup 2)))])]\n@@ -3853,7 +4708,8 @@\n    && (BASE_P (operands[1]) || BASE_P (operands[2]))\n    && ! CONST_OK_FOR_LETTER_P (INTVAL (operands[2]), 'J')\n    && ! CONST_OK_FOR_LETTER_P (INTVAL (operands[2]), 'N')\n-   && (INTVAL (operands[2]) >= -128 && INTVAL (operands[2]) < 128)\"\n+   && (INTVAL (operands[2]) >= -128 && INTVAL (operands[2]) < 128)\n+   && TARGET_SIDE_EFFECT_PREFIXES\"\n   [(parallel\n     [(set (match_dup 5) (match_dup 4))\n      (set (match_dup 0) (plus:SI (match_dup 1) (match_dup 2)))])]\n@@ -3891,7 +4747,8 @@\n    && ! CONST_OK_FOR_LETTER_P (INTVAL (operands[2]), 'J')\n    && ! CONST_OK_FOR_LETTER_P (INTVAL (operands[2]), 'N')\n    && INTVAL (operands[2]) >= -128\n-   && INTVAL (operands[2]) <= 127\"\n+   && INTVAL (operands[2]) <= 127\n+   && TARGET_SIDE_EFFECT_PREFIXES\"\n   [(parallel\n     [(set (match_dup 3) (match_op_dup 4 [(match_dup 3) (match_dup 6)]))\n      (set (match_dup 0) (plus:SI (match_dup 1) (match_dup 2)))])]\n@@ -4121,9 +4978,9 @@\n \t(unspec:SI [(match_operand:SI 2 \"cris_general_operand_or_symbol\" \"\")]\n \t\t   CRIS_UNSPEC_PLTGOTREAD)))]))]\n   \"flag_pic\n-   && cris_valid_pic_const (XEXP (XEXP (operands[1], 0), 1))\n+   && cris_valid_pic_const (XEXP (XEXP (operands[1], 0), 1), true)\n    && REGNO_REG_CLASS (REGNO (operands[0])) == REGNO_REG_CLASS (0)\"\n-  [(set (match_dup 0) (const:SI (unspec:SI [(match_dup 2)] CRIS_UNSPEC_PLT)))\n+  [(set (match_dup 0) (const:SI (unspec:SI [(match_dup 2)] CRIS_UNSPEC_PLT_GOTREL)))\n    (set (match_dup 0) (plus:SI (match_dup 0) (reg:SI CRIS_GOT_REGNUM)))]\n   \"\")\n \n@@ -4150,7 +5007,7 @@\n \t\t    (match_operand 4 \"\" \"\"))\n \t      (clobber (reg:SI CRIS_SRP_REGNUM))])]\n   \"flag_pic\n-   && cris_valid_pic_const (XEXP (XEXP (operands[1], 0), 1))\n+   && cris_valid_pic_const (XEXP (XEXP (operands[1], 0), 1), true)\n    && peep2_reg_dead_p (2, operands[0])\"\n   [(parallel [(call (mem:QI (match_dup 1))\n \t\t    (match_dup 4))\n@@ -4183,7 +5040,7 @@\n \t\t\t (match_operand 4 \"\" \"\")))\n \t      (clobber (reg:SI CRIS_SRP_REGNUM))])]\n   \"flag_pic\n-   && cris_valid_pic_const (XEXP (XEXP (operands[1], 0), 1))\n+   && cris_valid_pic_const (XEXP (XEXP (operands[1], 0), 1), true)\n    && peep2_reg_dead_p (2, operands[0])\"\n   [(parallel [(set (match_dup 5)\n \t\t   (call (mem:QI (match_dup 1))\n@@ -4213,12 +5070,13 @@\n \t\t   (const:SI\n \t\t    (unspec:SI [(match_dup 2)] CRIS_UNSPEC_PLTGOTREAD))))])]\n   \"flag_pic\n-   && cris_valid_pic_const (XEXP (XEXP (operands[1], 0), 1))\n+   && cris_valid_pic_const (XEXP (XEXP (operands[1], 0), 1), true)\n    && REGNO_REG_CLASS (REGNO (operands[0])) == REGNO_REG_CLASS (0)\"\n   [(set (match_dup 3)\n \t(const:SI (unspec:SI [(match_dup 2)] CRIS_UNSPEC_PLTGOTREAD)))\n    (set (match_dup 3) (plus:SI (match_dup 3) (reg:SI CRIS_GOT_REGNUM)))\n-   (set (match_dup 0) (const:SI (unspec:SI [(match_dup 2)] CRIS_UNSPEC_PLT)))\n+   (set (match_dup 0)\n+\t(const:SI (unspec:SI [(match_dup 2)] CRIS_UNSPEC_PLT_GOTREL)))\n    (set (match_dup 0) (plus:SI (match_dup 0) (reg:SI CRIS_GOT_REGNUM)))]\n   \"\")\n \f"}]}