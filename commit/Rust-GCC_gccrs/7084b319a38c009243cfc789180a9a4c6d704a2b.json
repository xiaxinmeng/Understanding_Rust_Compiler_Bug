{"sha": "7084b319a38c009243cfc789180a9a4c6d704a2b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzA4NGIzMTlhMzhjMDA5MjQzY2ZjNzg5MTgwYTlhNGM2ZDcwNGEyYg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-03-15T12:57:06Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-03-15T12:57:06Z"}, "message": "(class_add_method_list): Check for the +load method when adding a methods list to a class.\n\n(class_add_method_list): Check for the +load method when adding a\nmethods list to a class.\n(__objc_install_methods_in_dtable): New function.\n(class_add_method_list): Don't check anymore for duplicate methods.\n\nFrom-SVN: r13711", "tree": {"sha": "e0ef17f7080bdac946fc093cba6781c1116611c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e0ef17f7080bdac946fc093cba6781c1116611c5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7084b319a38c009243cfc789180a9a4c6d704a2b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7084b319a38c009243cfc789180a9a4c6d704a2b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7084b319a38c009243cfc789180a9a4c6d704a2b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7084b319a38c009243cfc789180a9a4c6d704a2b/comments", "author": null, "committer": null, "parents": [{"sha": "e29e95701bf95580492271e38fc2fe89f9ff9f8f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e29e95701bf95580492271e38fc2fe89f9ff9f8f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e29e95701bf95580492271e38fc2fe89f9ff9f8f"}], "stats": {"total": 63, "additions": 33, "deletions": 30}, "files": [{"sha": "904a3c4ef2bd93ec351f48c7113f022a1ad75c64", "filename": "gcc/objc/sendmsg.c", "status": "modified", "additions": 33, "deletions": 30, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7084b319a38c009243cfc789180a9a4c6d704a2b/gcc%2Fobjc%2Fsendmsg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7084b319a38c009243cfc789180a9a4c6d704a2b/gcc%2Fobjc%2Fsendmsg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fsendmsg.c?ref=7084b319a38c009243cfc789180a9a4c6d704a2b", "patch": "@@ -263,7 +263,8 @@ static void __objc_send_initialize(Class class)\n \n \t    for (i=0;i<method_list->method_count;i++) {\n \t      method = &(method_list->method_list[i]);\n-\t      if (method->method_name->sel_id == op->sel_id) {\n+\t      if (method->method_name\n+\t\t  && method->method_name->sel_id == op->sel_id) {\n \t        imp = method->method_imp;\n \t        break;\n \t      }\n@@ -280,14 +281,39 @@ static void __objc_send_initialize(Class class)\n \t\t\n       }\n     }\n-}  \n+}\n+\n+/* Walk on the methods list of class and install the methods in the reverse\n+   order of the lists. Since methods added by categories are before the methods\n+   of class in the methods list, this allows categories to substitute methods\n+   declared in class. However if more than one category replace the same method\n+   nothing is guarranteed about what method will be used.\n+   Assumes that __objc_runtime_mutex is locked down. */\n+static void\n+__objc_install_methods_in_dtable (Class class, MethodList_t method_list)\n+{\n+  int i;\n+\n+  if (!method_list)\n+    return;\n+\n+  if (method_list->method_next)\n+    __objc_install_methods_in_dtable (class, method_list->method_next);\n+\n+  for (i = 0; i < method_list->method_count; i++)\n+    {\n+      Method_t method = &(method_list->method_list[i]);\n+      sarray_at_put_safe (class->dtable,\n+\t\t\t  (sidx) method->method_name->sel_id,\n+\t\t\t  method->method_imp);\n+    }\n+}\n \n /* Assumes that __objc_runtime_mutex is locked down. */\n static void\n __objc_install_dispatch_table_for_class (Class class)\n {\n   Class super;\n-  MethodList_t mlist;\n   int counter;\n \n   /* If the class has not yet had it's class links resolved, we must \n@@ -310,18 +336,7 @@ __objc_install_dispatch_table_for_class (Class class)\n   else\n     class->dtable = sarray_lazy_copy (super->dtable);\n \n-  for (mlist = class->methods; mlist; mlist = mlist->method_next)\n-    {\n-      counter = mlist->method_count - 1;\n-      while (counter >= 0)\n-        {\n-          Method_t method = &(mlist->method_list[counter]);\n-\t  sarray_at_put_safe (class->dtable,\n-\t\t\t      (sidx) method->method_name->sel_id,\n-\t\t\t      method->method_imp);\n-          counter -= 1;\n-        }\n-    }\n+  __objc_install_methods_in_dtable (class, class->methods);\n }\n \n void __objc_update_dispatch_table_for_class (Class class)\n@@ -361,10 +376,6 @@ void\n class_add_method_list (Class class, MethodList_t list)\n {\n   int i;\n-  static SEL initialize_sel = 0;                /* !T:SAFE2 */\n-\n-  if (!initialize_sel)\n-    initialize_sel = sel_register_name (\"initialize\");\n \n   /* Passing of a linked list is not allowed.  Do multiple calls.  */\n   assert (!list->method_next);\n@@ -380,24 +391,16 @@ class_add_method_list (Class class, MethodList_t list)\n \t  method->method_name = \n \t    sel_register_typed_name ((const char*)method->method_name,\n \t\t\t\t     method->method_types);\n-\n-\t  if (search_for_method_in_list (class->methods, method->method_name)\n-\t      && method->method_name->sel_id != initialize_sel->sel_id)\n-\t    {\n-\t      /* Duplication. Print a error message an change the method name\n-\t\t to NULL. */\n-\t      fprintf (stderr, \"attempt to add a existing method: %s\\n\",\n-\t\t       sel_get_name(method->method_name));\n-\t      method->method_name = 0;\n-\t    }\n \t}\n     }\n \n   /* Add the methods to the class's method list.  */\n   list->method_next = class->methods;\n   class->methods = list;\n-}\n \n+  /* Update the dispatch table of class */\n+  __objc_update_dispatch_table_for_class (class);\n+}\n \n Method_t\n class_get_instance_method(Class class, SEL op)"}]}