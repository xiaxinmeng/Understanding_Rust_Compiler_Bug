{"sha": "e67e39c2b5d1cbd37d9d3cd8821794fe2d45b97b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTY3ZTM5YzJiNWQxY2JkMzdkOWQzY2Q4ODIxNzk0ZmUyZDQ1Yjk3Yg==", "commit": {"author": {"name": "H.J. Lu", "email": "hongjiu.lu@intel.com", "date": "2011-05-31T13:02:40Z"}, "committer": {"name": "Dodji Seketeli", "email": "dodji@gcc.gnu.org", "date": "2011-05-31T13:02:40Z"}, "message": "Revert accidental svn commit r174473\n\nFrom-SVN: r174480", "tree": {"sha": "4fa9d97f5218f181ac98f29a03a79c2bc912d0b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4fa9d97f5218f181ac98f29a03a79c2bc912d0b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e67e39c2b5d1cbd37d9d3cd8821794fe2d45b97b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e67e39c2b5d1cbd37d9d3cd8821794fe2d45b97b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e67e39c2b5d1cbd37d9d3cd8821794fe2d45b97b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e67e39c2b5d1cbd37d9d3cd8821794fe2d45b97b/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cea8c6deef9e4b39260a8c21091238c85eedc1eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cea8c6deef9e4b39260a8c21091238c85eedc1eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cea8c6deef9e4b39260a8c21091238c85eedc1eb"}], "stats": {"total": 152, "additions": 34, "deletions": 118}, "files": [{"sha": "4ca6cf4c4e0e7f446899cddae1bbb49cde7f1b17", "filename": "libjava/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67e39c2b5d1cbd37d9d3cd8821794fe2d45b97b/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67e39c2b5d1cbd37d9d3cd8821794fe2d45b97b/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=e67e39c2b5d1cbd37d9d3cd8821794fe2d45b97b", "patch": "@@ -1,3 +1,14 @@\n+2011-05-31  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\tPR libgcj/49193\n+\t* configure.host (sysdeps_dir): Set to i386 for x86_64.\n+\n+\t* sysdep/i386/locks.h (compare_and_swap): Call\n+\t__sync_bool_compare_and_swap.\n+\t(release_set): Call write_barrier ().\n+\n+\t* sysdep/x86-64/locks.h: Removed.\n+\n 2011-04-24  Gerald Pfeifer  <gerald@pfeifer.com>\n \n \t* README: Refer to our generic bug reporting page."}, {"sha": "9d4f2b6a1db816dbf4f37ee2f7272dd96145ab70", "filename": "libjava/configure.host", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67e39c2b5d1cbd37d9d3cd8821794fe2d45b97b/libjava%2Fconfigure.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67e39c2b5d1cbd37d9d3cd8821794fe2d45b97b/libjava%2Fconfigure.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fconfigure.host?ref=e67e39c2b5d1cbd37d9d3cd8821794fe2d45b97b", "patch": "@@ -132,7 +132,7 @@ case \"${host}\" in\n \tslow_pthread_self=yes\n \t;;\n   x86_64-*)\n-\tsysdeps_dir=x86-64\n+\tsysdeps_dir=i386\n \t# For 64-bit we always use SSE registers for arithmetic,\n \t# which doesn't have the extra precision problems of the fpu.\n \t# But be careful about 32-bit multilibs.\n@@ -279,7 +279,7 @@ EOF\n         slow_pthread_self=\n         ;;\n   i[34567]86-*-solaris2.1[0-9]* )\n-\tsysdeps_dir=x86-64\n+\tsysdeps_dir=i386\n \tDIVIDESPEC=-f%{m32:no-}%{!m32:%{!m64:no-}}%{m64:}use-divide-subroutine\n \t;;\n   mips-sgi-irix6* )"}, {"sha": "7b99f0bd7816dd2173f34a21cc2f49465a1a9546", "filename": "libjava/sysdep/i386/locks.h", "status": "modified", "additions": 21, "deletions": 33, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67e39c2b5d1cbd37d9d3cd8821794fe2d45b97b/libjava%2Fsysdep%2Fi386%2Flocks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67e39c2b5d1cbd37d9d3cd8821794fe2d45b97b/libjava%2Fsysdep%2Fi386%2Flocks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fsysdep%2Fi386%2Flocks.h?ref=e67e39c2b5d1cbd37d9d3cd8821794fe2d45b97b", "patch": "@@ -1,6 +1,6 @@\n /* locks.h - Thread synchronization primitives. X86/x86-64 implementation.\n \n-   Copyright (C) 2002  Free Software Foundation\n+   Copyright (C) 2002, 2011  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -23,19 +23,25 @@ compare_and_swap(volatile obj_addr_t *addr,\n \t\t obj_addr_t old,\n \t\t obj_addr_t new_val)\n {\n-  char result;\n-#ifdef __x86_64__\n-  __asm__ __volatile__(\"lock; cmpxchgq %2, %0; setz %1\"\n-\t      : \"=m\"(*(addr)), \"=q\"(result)\n-\t      : \"r\" (new_val), \"a\"(old), \"m\"(*addr)\n-\t      : \"memory\");\n-#else\n-  __asm__ __volatile__(\"lock; cmpxchgl %2, %0; setz %1\"\n-\t\t       : \"=m\"(*addr), \"=q\"(result)\n-\t\t       : \"r\" (new_val), \"a\"(old), \"m\"(*addr)\n-\t\t       : \"memory\");\n-#endif\n-  return (bool) result;\n+  return __sync_bool_compare_and_swap (addr, old, new_val);\n+}\n+\n+// Ensure that subsequent instructions do not execute on stale\n+// data that was loaded from memory before the barrier.\n+// On X86/x86-64, the hardware ensures that reads are properly ordered.\n+inline static void\n+read_barrier()\n+{\n+}\n+\n+// Ensure that prior stores to memory are completed with respect to other\n+// processors.\n+inline static void\n+write_barrier()\n+{\n+  /* x86-64/X86 does not reorder writes. We just need to ensure that\n+     gcc also doesn't.  */\n+  __asm__ __volatile__(\" \" : : : \"memory\");\n }\n \n // Set *addr to new_val with release semantics, i.e. making sure\n@@ -46,7 +52,7 @@ compare_and_swap(volatile obj_addr_t *addr,\n inline static void\n release_set(volatile obj_addr_t *addr, obj_addr_t new_val)\n {\n-  __asm__ __volatile__(\" \" : : : \"memory\");\n+  write_barrier ();\n   *(addr) = new_val;\n }\n \n@@ -60,22 +66,4 @@ compare_and_swap_release(volatile obj_addr_t *addr,\n {\n   return compare_and_swap(addr, old, new_val);\n }\n-\n-// Ensure that subsequent instructions do not execute on stale\n-// data that was loaded from memory before the barrier.\n-// On X86/x86-64, the hardware ensures that reads are properly ordered.\n-inline static void\n-read_barrier()\n-{\n-}\n-\n-// Ensure that prior stores to memory are completed with respect to other\n-// processors.\n-inline static void\n-write_barrier()\n-{\n-  /* x86-64/X86 does not reorder writes. We just need to ensure that\n-     gcc also doesn't.  */\n-  __asm__ __volatile__(\" \" : : : \"memory\");\n-}\n #endif"}, {"sha": "fdc0a3efb82594162c633d3fb316f12588a03036", "filename": "libjava/sysdep/x86-64/locks.h", "status": "removed", "additions": 0, "deletions": 83, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cea8c6deef9e4b39260a8c21091238c85eedc1eb/libjava%2Fsysdep%2Fx86-64%2Flocks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cea8c6deef9e4b39260a8c21091238c85eedc1eb/libjava%2Fsysdep%2Fx86-64%2Flocks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fsysdep%2Fx86-64%2Flocks.h?ref=cea8c6deef9e4b39260a8c21091238c85eedc1eb", "patch": "@@ -1,83 +0,0 @@\n-/* locks.h - Thread synchronization primitives. X86/x86-64 implementation.\n-\n-   Copyright (C) 2002  Free Software Foundation\n-\n-   Contributed by Bo Thorsen <bo@suse.de>.\n-\n-   This file is part of libgcj.\n-\n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n-\n-#ifndef __SYSDEP_LOCKS_H__\n-#define __SYSDEP_LOCKS_H__\n-\n-typedef size_t obj_addr_t;\t/* Integer type big enough for object\t*/\n-\t\t\t\t/* address.\t\t\t\t*/\n-\n-// Atomically replace *addr by new_val if it was initially equal to old.\n-// Return true if the comparison succeeded.\n-// Assumed to have acquire semantics, i.e. later memory operations\n-// cannot execute before the compare_and_swap finishes.\n-inline static bool\n-compare_and_swap(volatile obj_addr_t *addr,\n-\t\t obj_addr_t old,\n-\t\t obj_addr_t new_val)\n-{\n-  char result;\n-#ifdef __x86_64__\n-  __asm__ __volatile__(\"lock; cmpxchgq %2, %0; setz %1\"\n-\t      : \"=m\"(*(addr)), \"=q\"(result)\n-\t      : \"r\" (new_val), \"a\"(old), \"m\"(*addr)\n-\t      : \"memory\");\n-#else\n-  __asm__ __volatile__(\"lock; cmpxchgl %2, %0; setz %1\"\n-\t\t       : \"=m\"(*addr), \"=q\"(result)\n-\t\t       : \"r\" (new_val), \"a\"(old), \"m\"(*addr)\n-\t\t       : \"memory\");\n-#endif\n-  return (bool) result;\n-}\n-\n-// Set *addr to new_val with release semantics, i.e. making sure\n-// that prior loads and stores complete before this\n-// assignment.\n-// On X86/x86-64, the hardware shouldn't reorder reads and writes,\n-// so we just have to convince gcc not to do it either.\n-inline static void\n-release_set(volatile obj_addr_t *addr, obj_addr_t new_val)\n-{\n-  __asm__ __volatile__(\" \" : : : \"memory\");\n-  *(addr) = new_val;\n-}\n-\n-// Compare_and_swap with release semantics instead of acquire semantics.\n-// On many architecture, the operation makes both guarantees, so the\n-// implementation can be the same.\n-inline static bool\n-compare_and_swap_release(volatile obj_addr_t *addr,\n-\t\t\t obj_addr_t old,\n-\t\t\t obj_addr_t new_val)\n-{\n-  return compare_and_swap(addr, old, new_val);\n-}\n-\n-// Ensure that subsequent instructions do not execute on stale\n-// data that was loaded from memory before the barrier.\n-// On X86/x86-64, the hardware ensures that reads are properly ordered.\n-inline static void\n-read_barrier()\n-{\n-}\n-\n-// Ensure that prior stores to memory are completed with respect to other\n-// processors.\n-inline static void\n-write_barrier()\n-{\n-  /* x86-64/X86 does not reorder writes. We just need to ensure that\n-     gcc also doesn't.  */\n-  __asm__ __volatile__(\" \" : : : \"memory\");\n-}\n-#endif"}]}