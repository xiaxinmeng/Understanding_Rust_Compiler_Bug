{"sha": "5e90dd7193a80566748d8681500984b53d9b957c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWU5MGRkNzE5M2E4MDU2Njc0OGQ4NjgxNTAwOTg0YjUzZDliOTU3Yw==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2000-11-20T21:13:45Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2000-11-20T21:13:45Z"}, "message": "std_complex.h: Tweaks, include cmath for abs overloads.\n\n\n2000-11-20  Benjamin Kosnik  <bkoz@redhat.com>\n\n\t* include/bits/std_complex.h: Tweaks, include cmath for abs overloads.\n\t* src/complex.cc: Remove cmath include, formatting tweaks, remove\n\tdead code.\n\t* include/c/bits/std_cmath.h: Formatting tweaks.\n\t* testsuite/26_numerics/complex_value.cc: New file, for catching\n\tbits gleaned from libstdc++/106.\n\n\t* testsuite/23_containers/vector_ctor.cc (test02): Add test from\n\tlibstdc++/102.\n\nFrom-SVN: r37591", "tree": {"sha": "ea301f62702cdc86a4c1af0c31b53cef08dd9f7b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ea301f62702cdc86a4c1af0c31b53cef08dd9f7b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e90dd7193a80566748d8681500984b53d9b957c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e90dd7193a80566748d8681500984b53d9b957c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e90dd7193a80566748d8681500984b53d9b957c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e90dd7193a80566748d8681500984b53d9b957c/comments", "author": null, "committer": null, "parents": [{"sha": "250333d0e00e17db505275183cb330900938a476", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/250333d0e00e17db505275183cb330900938a476", "html_url": "https://github.com/Rust-GCC/gccrs/commit/250333d0e00e17db505275183cb330900938a476"}], "stats": {"total": 1414, "additions": 698, "deletions": 716}, "files": [{"sha": "fff54a6cf0c1e7e7c172f19bc13073759bf104e7", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e90dd7193a80566748d8681500984b53d9b957c/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e90dd7193a80566748d8681500984b53d9b957c/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=5e90dd7193a80566748d8681500984b53d9b957c", "patch": "@@ -1,3 +1,17 @@\n+2000-11-20  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\t* include/bits/std_complex.h: Tweaks, include cmath for abs overloads.\n+\t* src/complex.cc: Remove cmath include, formatting tweaks, remove\n+\tdead code.\n+\t* include/c/bits/std_cmath.h: Formatting tweaks.\n+\t* testsuite/26_numerics/complex_value.cc: New file, for catching\n+\tbits gleaned from libstdc++/106.\n+\n+\t* testsuite/23_containers/vector_ctor.cc (test02): Add test from\n+\tlibstdc++/102.\n+\n+\t* src/string-inst.cc: Tweaks.\n+\t\n 2000-11-20  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* include/bits/c++config, include/bits/ios_base.h,"}, {"sha": "35ca37890e3861d9c4e6c5e58fd49a69c9a4b266", "filename": "libstdc++-v3/include/bits/std_complex.h", "status": "modified", "additions": 607, "deletions": 643, "changes": 1250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e90dd7193a80566748d8681500984b53d9b957c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_complex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e90dd7193a80566748d8681500984b53d9b957c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_complex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_complex.h?ref=5e90dd7193a80566748d8681500984b53d9b957c", "patch": "@@ -28,7 +28,7 @@\n // the GNU General Public License.\n \n //\n-// ISO 14882/26.2.1\n+// ISO C++ 14882: 26.2  Complex Numbers\n // Note: this is not a conforming implementation.\n // Initially implemented by Ulrich Drepper <drepper@cygnus.com>\n // Improved by Gabriel Dos Reis <dosreis@cmla.ens-cachan.fr>\n@@ -38,6 +38,7 @@\n #define _CPP_COMPLEX\t1\n \n #include <bits/c++config.h>\n+#include <bits/std_cmath.h>\n #include <bits/std_iosfwd.h>\n \n namespace std\n@@ -50,21 +51,21 @@ namespace std\n   template<> class complex<long double>;\n \n   template<typename _Tp> _Tp abs(const complex<_Tp>&);\n-  template<typename _Tp>  _Tp arg(const complex<_Tp>&);\n+  template<typename _Tp> _Tp arg(const complex<_Tp>&);\n   template<typename _Tp> _Tp norm(const complex<_Tp>&);\n \n   template<typename _Tp> complex<_Tp> conj(const complex<_Tp>&);\n   template<typename _Tp> complex<_Tp> polar(const _Tp&, const _Tp&);\n \n-    // Transcendentals:\n+  // Transcendentals:\n   template<typename _Tp> complex<_Tp> cos(const complex<_Tp>&);\n   template<typename _Tp> complex<_Tp> cosh(const complex<_Tp>&);\n   template<typename _Tp> complex<_Tp> exp(const complex<_Tp>&);\n   template<typename _Tp> complex<_Tp> log(const complex<_Tp>&);\n   template<typename _Tp> complex<_Tp> log10(const complex<_Tp>&);\n   template<typename _Tp> complex<_Tp> pow(const complex<_Tp>&, int);\n   template<typename _Tp> complex<_Tp> pow(const complex<_Tp>&, const _Tp&);\n-  template<typename _Tp> complex<_Tp> pow (const complex<_Tp>&,\n+  template<typename _Tp> complex<_Tp> pow(const complex<_Tp>&, \n \t\t\t\t\t   const complex<_Tp>&);\n   template<typename _Tp> complex<_Tp> pow(const _Tp&, const complex<_Tp>&);\n   template<typename _Tp> complex<_Tp> sin(const complex<_Tp>&);\n@@ -74,10 +75,8 @@ namespace std\n   template<typename _Tp> complex<_Tp> tanh(const complex<_Tp>&);\n     \n     \n-  //\n   // 26.2.2  Primary template class complex\n-  //\n-  template <typename _Tp>\n+  template<typename _Tp>\n     class complex\n     {\n     public:\n@@ -87,7 +86,7 @@ namespace std\n \n       // Let's the compiler synthetize the copy constructor   \n       // complex (const complex<_Tp>&);\n-      template <typename _Up>\n+      template<typename _Up>\n         complex(const complex<_Up>&);\n         \n       _Tp real() const;\n@@ -102,15 +101,15 @@ namespace std\n       // Let's the compiler synthetize the\n       // copy and assignment operator\n       // complex<_Tp>& operator= (const complex<_Tp>&);\n-      template <typename _Up>\n+      template<typename _Up>\n         complex<_Tp>& operator=(const complex<_Up>&);\n-      template <typename _Up>\n+      template<typename _Up>\n         complex<_Tp>& operator+=(const complex<_Up>&);\n-      template <typename _Up>\n+      template<typename _Up>\n         complex<_Tp>& operator-=(const complex<_Up>&);\n-      template <typename _Up>\n+      template<typename _Up>\n         complex<_Tp>& operator*=(const complex<_Up>&);\n-      template <typename _Up>\n+      template<typename _Up>\n         complex<_Tp>& operator/=(const complex<_Up>&);\n \n     private:\n@@ -125,327 +124,403 @@ namespace std\n     inline _Tp\n     complex<_Tp>::imag() const { return _M_imag; }\n \n-    \n-  //\n-  // 26.2.3  complex specializations\n-  //\n-\n-  //\n-  // complex<float> specialization\n-  //\n-  template<> class complex<float>\n-  {\n-  public:\n-    typedef float value_type;\n-    \n-    complex(float = 0.0f, float = 0.0f);\n-#ifdef _GLIBCPP_BUGGY_COMPLEX\n-    complex(const complex& __z) : _M_value(__z._M_value) { }\n-#endif\n-    explicit complex(const complex<double>&);\n-    explicit complex(const complex<long double>&);\n-\n-    float real() const;\n-    float imag() const;\n+  template<typename _Tp>\n+    inline \n+    complex<_Tp>::complex(const _Tp& __r, const _Tp& __i)\n+    : _M_real(__r), _M_imag(__i) { }\n \n-    complex<float>& operator=(float);\n-    complex<float>& operator+=(float);\n-    complex<float>& operator-=(float);\n-    complex<float>& operator*=(float);\n-    complex<float>& operator/=(float);\n+  template<typename _Tp>\n+    template<typename _Up>\n+    inline \n+    complex<_Tp>::complex(const complex<_Up>& __z)\n+    : _M_real(__z.real()), _M_imag(__z.imag()) { }\n         \n-    // Let's the compiler synthetize the copy and assignment\n-    // operator.  It always does a pretty good job.\n-    // complex& operator= (const complex&);\n-    template <typename _Tp>\n-      complex<float>&operator=(const complex<_Tp>&);\n-    template <typename _Tp>\n-      complex<float>& operator+=(const complex<_Tp>&);\n-    template <class _Tp>\n-      complex<float>& operator-=(const complex<_Tp>&);\n-    template <class _Tp>\n-      complex<float>& operator*=(const complex<_Tp>&);\n-    template <class _Tp>\n-      complex<float>&operator/=(const complex<_Tp>&);\n-\n-  private:\n-    typedef __complex__ float _ComplexT;\n-    _ComplexT _M_value;\n+  template<typename _Tp>\n+    complex<_Tp>&\n+    complex<_Tp>::operator=(const _Tp& __t)\n+    {\n+     _M_real = __t;\n+     _M_imag = _Tp();\n+     return *this;\n+    } \n \n-    complex(_ComplexT __z) : _M_value(__z) { }\n-        \n-    friend class complex<double>;\n-    friend class complex<long double>;\n+  // 26.2.5/1\n+  template<typename _Tp>\n+    inline complex<_Tp>&\n+    complex<_Tp>::operator+=(const _Tp& __t)\n+    {\n+      _M_real += __t;\n+      return *this;\n+    }\n \n-    friend complex<float> pow<>(const complex<float>&, int);\n-    friend complex<float> pow<>(const complex<float>&, const float&);\n-    friend complex<float> pow<>(const complex<float>&,\n-\t\t\t\tconst complex<float>&);\n-    friend complex<float> pow<>(const float&, const complex<float>&);\n-    friend complex<float> sqrt<>(const complex<float>&);\n-    friend complex<float> tan<>(const complex<float>&);\n-    friend complex<float> tanh<>(const complex<float>&);\n-  };\n+  // 26.2.5/3\n+  template<typename _Tp>\n+    inline complex<_Tp>&\n+    complex<_Tp>::operator-=(const _Tp& __t)\n+    {\n+      _M_real -= __t;\n+      return *this;\n+    }\n \n-  inline float\n-  complex<float>::real() const\n-  { return __real__ _M_value; }\n+  // 26.2.5/5\n+  template<typename _Tp>\n+    complex<_Tp>&\n+    complex<_Tp>::operator*=(const _Tp& __t)\n+    {\n+      _M_real *= __t;\n+      _M_imag *= __t;\n+      return *this;\n+    }\n \n-  inline float\n-  complex<float>::imag() const\n-  { return __imag__ _M_value; }\n+  // 26.2.5/7\n+  template<typename _Tp>\n+    complex<_Tp>&\n+    complex<_Tp>::operator/=(const _Tp& __t)\n+    {\n+      _M_real /= __t;\n+      _M_imag /= __t;\n+      return *this;\n+    }\n \n+  template<typename _Tp>\n+    template<typename _Up>\n+    complex<_Tp>&\n+    complex<_Tp>::operator=(const complex<_Up>& __z)\n+    {\n+      _M_real = __z.real();\n+      _M_imag = __z.imag();\n+      return *this;\n+    }\n \n-  //\n-  // complex<double> specialization\n-  //\n-  template<> class complex<double>\n-  {\n-  public:\n-    typedef double value_type;\n+  // 26.2.5/9\n+  template<typename _Tp>\n+    template<typename _Up>\n+    complex<_Tp>&\n+    complex<_Tp>::operator+=(const complex<_Up>& __z)\n+    {\n+      _M_real += __z.real();\n+      _M_imag += __z.imag();\n+      return *this;\n+    }\n \n-    complex(double  =0.0, double =0.0);\n-#ifdef _GLIBCPP_BUGGY_COMPLEX\n-    complex(const complex& __z) : _M_value(__z._M_value) { }\n-#endif\n-    complex(const complex<float>&);\n-    explicit complex(const complex<long double>&);\n-        \n-    double real() const;\n-    double imag() const;\n-        \n-    complex<double>& operator=(double);\n-    complex<double>& operator+=(double);\n-    complex<double>& operator-=(double);\n-    complex<double>& operator*=(double);\n-    complex<double>& operator/=(double);\n+  // 26.2.5/11\n+  template<typename _Tp>\n+    template<typename _Up>\n+    complex<_Tp>&\n+    complex<_Tp>::operator-=(const complex<_Up>& __z)\n+    {\n+      _M_real -= __z.real();\n+      _M_imag -= __z.imag();\n+      return *this;\n+    }\n \n-    // The compiler will synthetize this, efficiently.\n-    // complex& operator= (const complex&);\n-    template <typename _Tp>\n-      complex<double>& operator=(const complex<_Tp>&);\n-    template <typename _Tp>\n-      complex<double>& operator+=(const complex<_Tp>&);\n-    template <typename _Tp>\n-      complex<double>& operator-=(const complex<_Tp>&);\n-    template <typename _Tp>\n-      complex<double>& operator*=(const complex<_Tp>&);\n-    template <typename _Tp>\n-      complex<double>& operator/=(const complex<_Tp>&);\n+  // 26.2.5/13\n+  // XXX: This is a grammar school implementation.\n+  template<typename _Tp>\n+    template<typename _Up>\n+    complex<_Tp>&\n+    complex<_Tp>::operator*=(const complex<_Up>& __z)\n+    {\n+      const _Tp __r = _M_real * __z.real() - _M_imag * __z.imag();\n+      _M_imag = _M_real * __z.imag() + _M_imag * __z.real();\n+      _M_real = __r;\n+      return *this;\n+    }\n \n-  private:\n-    typedef __complex__ double _ComplexT;\n-    _ComplexT _M_value;\n+  // 26.2.5/15\n+  // XXX: This is a grammar school implementation.\n+  template<typename _Tp>\n+    template<typename _Up>\n+    complex<_Tp>&\n+    complex<_Tp>::operator/=(const complex<_Up>& __z)\n+    {\n+      const _Tp __r =  _M_real * __z.real() + _M_imag * __z.imag();\n+      const _Tp __n = norm(__z);\n+      _M_imag = (_M_real * __z.imag() - _M_imag * __z.real()) / __n;\n+      _M_real = __r / __n;\n+      return *this;\n+    }\n+    \n+  // Operators:\n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    operator+(const complex<_Tp>& __x, const complex<_Tp>& __y)\n+    { return complex<_Tp> (__x) += __y; }\n \n-    complex(_ComplexT __z) : _M_value(__z) { }\n-        \n-    friend class complex<float>;\n-    friend class complex<long double>;\n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    operator+(const complex<_Tp>& __x, const _Tp& __y)\n+    { return complex<_Tp> (__x) += __y; }\n \n-    friend complex<double> pow<>(const complex<double>&, int);\n-    friend complex<double> pow<>(const complex<double>&, const double&);\n-    friend complex<double> pow<>(const complex<double>&,\n-\t\t\t\t const complex<double>&);\n-    friend complex<double> pow<>(const double&, const complex<double>&);\n-    friend complex<double> sqrt<>(const complex<double>&);\n-    friend complex<double> tan<>(const complex<double>&);\n-    friend complex<double> tanh<>(const complex<double>&);\n-  };\n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    operator+(const _Tp& __x, const complex<_Tp>& __y)\n+    { return complex<_Tp> (__y) += __x; }\n \n-  inline double\n-  complex<double>::real() const\n-  { return __real__ _M_value; }\n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    operator-(const complex<_Tp>& __x, const complex<_Tp>& __y)\n+    { return complex<_Tp> (__x) -= __y; }\n+    \n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    operator-(const complex<_Tp>& __x, const _Tp& __y)\n+    { return complex<_Tp> (__x) -= __y; }\n \n-  inline double\n-  complex<double>::imag() const\n-  { return __imag__ _M_value; }\n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    operator-(const _Tp& __x, const complex<_Tp>& __y)\n+    { return complex<_Tp> (__x) -= __y; }\n \n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    operator*(const complex<_Tp>& __x, const complex<_Tp>& __y)\n+    { return complex<_Tp> (__x) *= __y; }\n \n-  //\n-  // complex<long double> specialization\n-  //\n-  template<> class complex<long double>\n-  {\n-  public:\n-    typedef long double value_type;\n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    operator*(const complex<_Tp>& __x, const _Tp& __y)\n+    { return complex<_Tp> (__x) *= __y; }\n \n-    complex(long double = 0.0L, long double = 0.0L);\n-#ifdef _GLIBCPP_BUGGY_COMPLEX\n-    complex(const complex& __z) : _M_value(__z._M_value) { }\n-#endif\n-    complex(const complex<float>&);\n-    complex(const complex<double>&);\n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    operator*(const _Tp& __x, const complex<_Tp>& __y)\n+    { return complex<_Tp> (__y) *= __x; }\n \n-    long double real() const;\n-    long double imag() const;\n-\n-    complex<long double>& operator= (long double);\n-    complex<long double>& operator+= (long double);\n-    complex<long double>& operator-= (long double);\n-    complex<long double>& operator*= (long double);\n-    complex<long double>& operator/= (long double);\n-\n-    // The compiler knows how to do this efficiently\n-    // complex& operator= (const complex&);\n-\n-    template<typename _Tp>\n-      complex<long double>& operator=(const complex<_Tp>&);\n-    template<typename _Tp>\n-      complex<long double>& operator+=(const complex<_Tp>&);\n-    template<typename _Tp>\n-      complex<long double>& operator-=(const complex<_Tp>&);\n-    template<typename _Tp>\n-      complex<long double>& operator*=(const complex<_Tp>&);\n-    template<typename _Tp>\n-      complex<long double>& operator/=(const complex<_Tp>&);\n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    operator/(const complex<_Tp>& __x, const complex<_Tp>& __y)\n+    { return complex<_Tp> (__x) /= __y; }\n+    \n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    operator/(const complex<_Tp>& __x, const _Tp& __y)\n+    { return complex<_Tp> (__x) /= __y; }\n \n-  private:\n-    typedef __complex__ long double _ComplexT;\n-    _ComplexT _M_value;\n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    operator/(const _Tp& __x, const complex<_Tp>& __y)\n+    { return complex<_Tp> (__x) /= __y; }\n \n-    complex(_ComplexT __z) : _M_value(__z) { }\n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    operator+(const complex<_Tp>& __x)\n+    { return __x; }\n \n-    friend class complex<float>;\n-    friend class complex<double>;\n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    operator-(const complex<_Tp>& __x)\n+    {  return complex<_Tp>(-__x.real(), -__x.imag()); }\n \n-    friend complex<long double> pow<>(const complex<long double>&, int);\n-    friend complex<long double> pow<>(const complex<long double>&,\n-\t\t\t\t      const long double&);\n-    friend complex<long double> pow<>(const complex<long double>&,\n-\t\t\t\t      const complex<long double>&);\n-    friend complex<long double> pow<>(const long double&,\n-\t\t\t\t      const complex<long double>&);\n-    friend complex<long double> sqrt<>(const complex<long double>&);\n-    friend complex<long double> tan<>(const complex<long double>&);\n-    friend complex<long double> tanh<>(const complex<long double>&);\n-  };\n+  template<typename _Tp>\n+    inline bool\n+    operator==(const complex<_Tp>& __x, const complex<_Tp>& __y)\n+    { return __x.real() == __y.real() && __x.imag() == __y.imag(); }\n \n-  inline\n-  complex<long double>::complex(long double __r, long double __i)\n-  {\n-    __real__ _M_value = __r;\n-    __imag__ _M_value = __i;\n-  }\n+  template<typename _Tp>\n+    inline bool\n+    operator==(const complex<_Tp>& __x, const _Tp& __y)\n+    { return __x.real() == __y && __x.imag() == _Tp(); }\n \n-  inline\n-  complex<long double>::complex(const complex<float>& __z)\n-  : _M_value(_ComplexT(__z._M_value)) { }\n+  template<typename _Tp>\n+    inline bool\n+    operator==(const _Tp& __x, const complex<_Tp>& __y)\n+    { return __x == __y.real() && _Tp() == __y.imag(); }\n \n-  inline\n-  complex<long double>::complex(const complex<double>& __z)\n-  : _M_value(_ComplexT(__z._M_value)) { }\n+  template<typename _Tp>\n+    inline bool\n+    operator!=(const complex<_Tp>& __x, const complex<_Tp>& __y)\n+    { return __x.real() != __y.real() || __x.imag() != __y.imag(); }\n \n-  inline long double\n-  complex<long double>::real() const\n-  { return __real__ _M_value; }\n+  template<typename _Tp>\n+    inline bool\n+    operator!=(const complex<_Tp>& __x, const _Tp& __y)\n+    { return __x.real() != __y || __x.imag() != _Tp(); }\n \n-  inline long double\n-  complex<long double>::imag() const\n-  { return __imag__ _M_value; }\n+  template<typename _Tp>\n+    inline bool\n+    operator!=(const _Tp& __x, const complex<_Tp>& __y)\n+    { return __x != __y.real() || _Tp() != __y.imag(); }\n \n-  inline complex<long double>&   \n-  complex<long double>::operator=(long double __r)\n-  {\n-    __real__ _M_value = __r;\n-    __imag__ _M_value = 0.0L;\n-    return *this;\n-  }\n+  template<typename _Tp, typename _CharT, class _Traits>\n+    basic_istream<_CharT, _Traits>&\n+    operator>>(basic_istream<_CharT, _Traits>&, complex<_Tp>&);\n \n-  inline complex<long double>&\n-  complex<long double>::operator+=(long double __r)\n-  {\n-    __real__ _M_value += __r;\n-    return *this;\n-  }\n+  template<typename _Tp, typename _CharT, class _Traits>\n+    basic_ostream<_CharT, _Traits>&\n+    operator<<(basic_ostream<_CharT, _Traits>&, const complex<_Tp>&);\n \n-  inline complex<long double>&\n-  complex<long double>::operator-=(long double __r)\n-  {\n-    __real__ _M_value -= __r;\n-    return *this;\n-  }\n+  // Values\n+  template<typename _Tp>\n+    inline _Tp\n+    real(const complex<_Tp>& __z)\n+    { return __z.real(); }\n+    \n+  template<typename _Tp>\n+    inline _Tp\n+    imag(const complex<_Tp>& __z)\n+    { return __z.imag(); }\n \n-  inline complex<long double>&\n-  complex<long double>::operator*=(long double __r)\n-  {\n-    __real__ _M_value *= __r;\n-    return *this;\n-  }\n+  template<typename _Tp>\n+    inline _Tp\n+    abs(const complex<_Tp>& __z)\n+    {\n+      _Tp __x = __z.real();\n+      _Tp __y = __z.imag();\n+      const _Tp __s = abs(__x) + abs(__y);\n+      if (__s == _Tp())  // well ...\n+        return __s;\n+      __x /= __s; \n+      __y /= __s;\n+      return __s * sqrt(__x * __x + __y * __y);\n+    }\n \n-  inline complex<long double>&\n-  complex<long double>::operator/=(long double __r)\n-  {\n-    __real__ _M_value /= __r;\n-    return *this;\n-  }\n+  template<typename _Tp>\n+    inline _Tp\n+    arg(const complex<_Tp>& __z)\n+    { return atan2(__z.imag(), __z.real()); }\n \n   template<typename _Tp>\n-    inline complex<long double>&\n-    complex<long double>::operator=(const complex<_Tp>& __z)\n+    inline _Tp\n+    norm(const complex<_Tp>& __z)\n     {\n-      __real__ _M_value = __z.real();\n-      __imag__ _M_value = __z.imag();\n-      return *this;\n+      _Tp __res = abs(__z);\n+      return __res * __res;\n     }\n \n   template<typename _Tp>\n-    inline complex<long double>&\n-    complex<long double>::operator+=(const complex<_Tp>& __z)\n+    inline complex<_Tp>\n+    polar(const _Tp& __rho, const _Tp& __theta)\n+    { return complex<_Tp>(__rho * cos(__theta), __rho * sin(__theta)); }\n+\n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    conj(const complex<_Tp>& __z)\n+    { return complex<_Tp>(__z.real(), -__z.imag()); }\n+  \n+  // Transcendentals\n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    cos(const complex<_Tp>& __z)\n     {\n-      __real__ _M_value += __z.real();\n-      __imag__ _M_value += __z.imag();\n-      return *this;\n+      const _Tp __x = __z.real();\n+      const _Tp __y = __z.imag();\n+      return complex<_Tp>(cos(__x) * cosh(__y), -sin(__x) * sinh(__y));\n     }\n \n   template<typename _Tp>\n-    inline complex<long double>&\n-    complex<long double>::operator-=(const complex<_Tp>& __z)\n+    inline complex<_Tp>\n+    cosh(const complex<_Tp>& __z)\n     {\n-      __real__ _M_value -= __z.real();\n-      __imag__ _M_value -= __z.imag();\n-      return *this;\n+      const _Tp __x = __z.real();\n+      const _Tp __y = __z.imag();\n+      return complex<_Tp>(cosh(__x) * cos(__y), sinh(__x) * sin(__y));\n     }\n-    \n+\n   template<typename _Tp>\n-    inline complex<long double>&\n-    complex<long double>::operator*=(const complex<_Tp>& __z)\n+    inline complex<_Tp>\n+    exp(const complex<_Tp>& __z)\n+    { return polar(exp(__z.real()), __z.imag()); }\n+\n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    log(const complex<_Tp>& __z)\n+    { return complex<_Tp>(log(abs(__z)), arg(__z)); }\n+\n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    log10(const complex<_Tp>& __z)\n+    { return log(__z) / log(_Tp(10.0)); }\n+\n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    sin(const complex<_Tp>& __z)\n     {\n-      _ComplexT __t;\n-      __real__ __t = __z.real();\n-      __imag__ __t = __z.imag();\n-      _M_value *= __t;\n-      return *this;\n+      const _Tp __x = __z.real();\n+      const _Tp __y = __z.imag();\n+      return complex<_Tp>(sin(__x) * cosh(__y), cos(__x) * sinh(__y)); \n     }\n \n   template<typename _Tp>\n-    inline complex<long double>&\n-    complex<long double>::operator/=(const complex<_Tp>& __z)\n+    inline complex<_Tp>\n+    sinh(const complex<_Tp>& __z)\n     {\n-      _ComplexT __t;\n-      __real__ __t = __z.real();\n-      __imag__ __t = __z.imag();\n-      _M_value /= __t;\n-      return *this;\n+      const _Tp __x = __z.real();\n+      const _Tp  __y = __z.imag();\n+      return complex<_Tp>(sinh(__x) * cos(__y), cosh(__x) * sin(__y));\n     }\n \n-  //\n-  // complex<float> continued.\n-  //\n+  // 26.2.3  complex specializations\n+  // complex<float> specialization\n+  template<> class complex<float>\n+  {\n+  public:\n+    typedef float value_type;\n+    \n+    complex(float = 0.0f, float = 0.0f);\n+#ifdef _GLIBCPP_BUGGY_COMPLEX\n+    complex(const complex& __z) : _M_value(__z._M_value) { }\n+#endif\n+    explicit complex(const complex<double>&);\n+    explicit complex(const complex<long double>&);\n+\n+    float real() const;\n+    float imag() const;\n+\n+    complex<float>& operator=(float);\n+    complex<float>& operator+=(float);\n+    complex<float>& operator-=(float);\n+    complex<float>& operator*=(float);\n+    complex<float>& operator/=(float);\n+        \n+    // Let's the compiler synthetize the copy and assignment\n+    // operator.  It always does a pretty good job.\n+    // complex& operator= (const complex&);\n+    template<typename _Tp>\n+      complex<float>&operator=(const complex<_Tp>&);\n+    template<typename _Tp>\n+      complex<float>& operator+=(const complex<_Tp>&);\n+    template<class _Tp>\n+      complex<float>& operator-=(const complex<_Tp>&);\n+    template<class _Tp>\n+      complex<float>& operator*=(const complex<_Tp>&);\n+    template<class _Tp>\n+      complex<float>&operator/=(const complex<_Tp>&);\n+\n+  private:\n+    typedef __complex__ float _ComplexT;\n+    _ComplexT _M_value;\n+\n+    complex(_ComplexT __z) : _M_value(__z) { }\n+        \n+    friend class complex<double>;\n+    friend class complex<long double>;\n+\n+    friend complex<float> pow<>(const complex<float>&, int);\n+    friend complex<float> pow<>(const complex<float>&, const float&);\n+    friend complex<float> pow<>(const complex<float>&,\n+\t\t\t\tconst complex<float>&);\n+    friend complex<float> pow<>(const float&, const complex<float>&);\n+    friend complex<float> sqrt<>(const complex<float>&);\n+    friend complex<float> tan<>(const complex<float>&);\n+    friend complex<float> tanh<>(const complex<float>&);\n+  };\n+\n+  inline float\n+  complex<float>::real() const\n+  { return __real__ _M_value; }\n+\n+  inline float\n+  complex<float>::imag() const\n+  { return __imag__ _M_value; }\n+\n   inline\n   complex<float>::complex(float r, float i)\n   {\n     __real__ _M_value = r;\n     __imag__ _M_value = i;\n   }\n \n-  inline\n-  complex<float>::complex(const complex<double>& __z)\n-  : _M_value(_ComplexT(__z._M_value)) { }\n-\n-  inline\n-  complex<float>::complex(const complex<long double>& __z)\n-  : _M_value(_ComplexT(__z._M_value)) { }\n-\n   inline complex<float>&\n   complex<float>::operator=(float __f)\n   {\n@@ -491,68 +566,116 @@ namespace std\n     return *this;\n   }\n \n-  template<typename _Tp>\n-  inline complex<float>&\n-  complex<float>::operator+=(const complex<_Tp>& __z)\n-  {\n-    __real__ _M_value += __z.real();\n-    __imag__ _M_value += __z.imag();\n-    return *this;\n-  }\n-    \n-  template<typename _Tp>\n-    inline complex<float>&\n-    complex<float>::operator-=(const complex<_Tp>& __z)\n-    {\n-     __real__ _M_value -= __z.real();\n-     __imag__ _M_value -= __z.real();\n-     return *this;\n-    } \n+  template<typename _Tp>\n+  inline complex<float>&\n+  complex<float>::operator+=(const complex<_Tp>& __z)\n+  {\n+    __real__ _M_value += __z.real();\n+    __imag__ _M_value += __z.imag();\n+    return *this;\n+  }\n+    \n+  template<typename _Tp>\n+    inline complex<float>&\n+    complex<float>::operator-=(const complex<_Tp>& __z)\n+    {\n+     __real__ _M_value -= __z.real();\n+     __imag__ _M_value -= __z.real();\n+     return *this;\n+    } \n+\n+  template<typename _Tp>\n+    inline complex<float>&\n+    complex<float>::operator*=(const complex<_Tp>& __z)\n+    {\n+      _ComplexT __t;\n+      __real__ __t = __z.real();\n+      __imag__ __t = __z.imag();\n+      _M_value *= __t;\n+      return *this;\n+    }\n+\n+  template<typename _Tp>\n+    inline complex<float>&\n+    complex<float>::operator/=(const complex<_Tp>& __z)\n+    {\n+      _ComplexT __t;\n+      __real__ __t = __z.real();\n+      __imag__ __t = __z.imag();\n+      _M_value /= __t;\n+      return *this;\n+    }\n+\n+  // 26.2.3  complex specializations\n+  // complex<double> specialization\n+  template<> class complex<double>\n+  {\n+  public:\n+    typedef double value_type;\n+\n+    complex(double  =0.0, double =0.0);\n+#ifdef _GLIBCPP_BUGGY_COMPLEX\n+    complex(const complex& __z) : _M_value(__z._M_value) { }\n+#endif\n+    explicit complex(const complex<float>&);\n+    explicit complex(const complex<long double>&);\n+        \n+    double real() const;\n+    double imag() const;\n+        \n+    complex<double>& operator=(double);\n+    complex<double>& operator+=(double);\n+    complex<double>& operator-=(double);\n+    complex<double>& operator*=(double);\n+    complex<double>& operator/=(double);\n+\n+    // The compiler will synthetize this, efficiently.\n+    // complex& operator= (const complex&);\n+    template<typename _Tp>\n+      complex<double>& operator=(const complex<_Tp>&);\n+    template<typename _Tp>\n+      complex<double>& operator+=(const complex<_Tp>&);\n+    template<typename _Tp>\n+      complex<double>& operator-=(const complex<_Tp>&);\n+    template<typename _Tp>\n+      complex<double>& operator*=(const complex<_Tp>&);\n+    template<typename _Tp>\n+      complex<double>& operator/=(const complex<_Tp>&);\n+\n+  private:\n+    typedef __complex__ double _ComplexT;\n+    _ComplexT _M_value;\n+\n+    complex(_ComplexT __z) : _M_value(__z) { }\n+        \n+    friend class complex<float>;\n+    friend class complex<long double>;\n \n-  template<typename _Tp>\n-    inline complex<float>&\n-    complex<float>::operator*=(const complex<_Tp>& __z)\n-    {\n-      _ComplexT __t;\n-      __real__ __t = __z.real();\n-      __imag__ __t = __z.imag();\n-      _M_value *= __t;\n-      return *this;\n-    }\n+    friend complex<double> pow<>(const complex<double>&, int);\n+    friend complex<double> pow<>(const complex<double>&, const double&);\n+    friend complex<double> pow<>(const complex<double>&,\n+\t\t\t\t const complex<double>&);\n+    friend complex<double> pow<>(const double&, const complex<double>&);\n+    friend complex<double> sqrt<>(const complex<double>&);\n+    friend complex<double> tan<>(const complex<double>&);\n+    friend complex<double> tanh<>(const complex<double>&);\n+  };\n \n-  template<typename _Tp>\n-    inline complex<float>&\n-    complex<float>::operator/=(const complex<_Tp>& __z)\n-    {\n-      _ComplexT __t;\n-      __real__ __t = __z.real();\n-      __imag__ __t = __z.imag();\n-      _M_value /= __t;\n-      return *this;\n-    }\n+  inline double\n+  complex<double>::real() const\n+  { return __real__ _M_value; }\n \n+  inline double\n+  complex<double>::imag() const\n+  { return __imag__ _M_value; }\n \n-  //\n-  // complex<double> continued.\n-  //\n   inline\n   complex<double>::complex(double __r, double __i)\n   {\n     __real__ _M_value = __r;\n     __imag__ _M_value = __i;\n   }\n \n-  inline\n-  complex<double>::complex(const complex<float>& __z) \n-  : _M_value(_ComplexT(__z._M_value)) { }\n-\n-  inline\n-  complex<double>::complex(const complex<long double>& __z)\n-  {\n-    __real__ _M_value = __z.real();\n-    __imag__ _M_value = __z.imag();\n-  }\n-\n   inline complex<double>&\n   complex<double>::operator=(double __d)\n   {\n@@ -636,357 +759,198 @@ namespace std\n       __imag__ __t = __z.imag();\n       _M_value /= __t;\n       return *this;\n-    }\n-\n-  //\n-  // Primary template class complex continued.\n-  //\n-  // 26.2.4\n-  template<typename _Tp>\n-    inline \n-    complex<_Tp>::complex(const _Tp& __r, const _Tp& __i)\n-    : _M_real(__r), _M_imag(__i) { }\n-\n-  template<typename _Tp>\n-    template<typename _Up>\n-    inline \n-    complex<_Tp>::complex(const complex<_Up>& __z)\n-    : _M_real(__z.real()), _M_imag(__z.imag()) { }\n-\n-  // 26.2.7/4\n-  template<typename _Tp>\n-    inline _Tp\n-    norm(const complex<_Tp>& __z)\n-    {\n-      // XXX: Grammar school computation\n-      return __z.real() * __z.real() + __z.imag() * __z.imag();\n-    }\n-        \n-  template<typename _Tp>\n-    complex<_Tp>&\n-    complex<_Tp>::operator=(const _Tp& __t)\n-    {\n-     _M_real = __t;\n-     _M_imag = _Tp();\n-     return *this;\n-    } \n-\n-  // 26.2.5/1\n-  template<typename _Tp>\n-    inline complex<_Tp>&\n-    complex<_Tp>::operator+=(const _Tp& __t)\n-    {\n-      _M_real += __t;\n-      return *this;\n-    }\n-\n-  // 26.2.5/3\n-  template<typename _Tp>\n-    inline complex<_Tp>&\n-    complex<_Tp>::operator-=(const _Tp& __t)\n-    {\n-      _M_real -= __t;\n-      return *this;\n-    }\n-\n-  // 26.2.5/5\n-  template<typename _Tp>\n-    complex<_Tp>&\n-    complex<_Tp>::operator*=(const _Tp& __t)\n-    {\n-      _M_real *= __t;\n-      _M_imag *= __t;\n-      return *this;\n-    }\n-\n-  // 26.2.5/7\n-  template<typename _Tp>\n-    complex<_Tp>&\n-    complex<_Tp>::operator/=(const _Tp& __t)\n-    {\n-      _M_real /= __t;\n-      _M_imag /= __t;\n-      return *this;\n-    }\n-\n-  template<typename _Tp>\n-    template<typename _Up>\n-    complex<_Tp>&\n-    complex<_Tp>::operator=(const complex<_Up>& __z)\n-    {\n-      _M_real = __z.real();\n-      _M_imag = __z.imag();\n-      return *this;\n-    }\n-\n-  // 26.2.5/9\n-  template<typename _Tp>\n-    template<typename _Up>\n-    complex<_Tp>&\n-    complex<_Tp>::operator+=(const complex<_Up>& __z)\n-    {\n-      _M_real += __z.real();\n-      _M_imag += __z.imag();\n-      return *this;\n-    }\n-\n-  // 26.2.5/11\n-  template<typename _Tp>\n-    template<typename _Up>\n-    complex<_Tp>&\n-    complex<_Tp>::operator-=(const complex<_Up>& __z)\n-    {\n-      _M_real -= __z.real();\n-      _M_imag -= __z.imag();\n-      return *this;\n-    }\n-\n-  // 26.2.5/13\n-  // XXX: this is a grammar school implementation.\n-  template<typename _Tp>\n-    template<typename _Up>\n-    complex<_Tp>&\n-    complex<_Tp>::operator*=(const complex<_Up>& __z)\n-    {\n-      const _Tp __r = _M_real * __z.real() - _M_imag * __z.imag();\n-      _M_imag = _M_real * __z.imag() + _M_imag * __z.real();\n-      _M_real = __r;\n-      return *this;\n-    }\n-\n-  // 26.2.5/15\n-  // XXX: this is a grammar school implementation.\n-  template<typename _Tp>\n-    template<typename _Up>\n-    complex<_Tp>&\n-    complex<_Tp>::operator/=(const complex<_Up>& __z)\n-    {\n-      const _Tp __r =  _M_real * __z.real() + _M_imag * __z.imag();\n-      const _Tp __n = norm(__z);\n-      _M_imag = (_M_real * __z.imag() - _M_imag * __z.real()) / __n;\n-      _M_real = __r / __n;\n-      return *this;\n-    }\n-    \n-  // Operators:\n-  template<typename _Tp>\n-    inline complex<_Tp>\n-    operator+(const complex<_Tp>& __x, const complex<_Tp>& __y)\n-    { return complex<_Tp> (__x) += __y; }\n-\n-  template<typename _Tp>\n-    inline complex<_Tp>\n-    operator+(const complex<_Tp>& __x, const _Tp& __y)\n-    { return complex<_Tp> (__x) += __y; }\n-\n-  template<typename _Tp>\n-    inline complex<_Tp>\n-    operator+(const _Tp& __x, const complex<_Tp>& __y)\n-    { return complex<_Tp> (__y) += __x; }\n-\n-  template<typename _Tp>\n-    inline complex<_Tp>\n-    operator-(const complex<_Tp>& __x, const complex<_Tp>& __y)\n-    { return complex<_Tp> (__x) -= __y; }\n-    \n-  template<typename _Tp>\n-    inline complex<_Tp>\n-    operator-(const complex<_Tp>& __x, const _Tp& __y)\n-    { return complex<_Tp> (__x) -= __y; }\n-\n-  template<typename _Tp>\n-    inline complex<_Tp>\n-    operator-(const _Tp& __x, const complex<_Tp>& __y)\n-    { return complex<_Tp> (__x) -= __y; }\n-\n-  template<typename _Tp>\n-    inline complex<_Tp>\n-    operator*(const complex<_Tp>& __x, const complex<_Tp>& __y)\n-    { return complex<_Tp> (__x) *= __y; }\n-\n-  template<typename _Tp>\n-    inline complex<_Tp>\n-    operator*(const complex<_Tp>& __x, const _Tp& __y)\n-    { return complex<_Tp> (__x) *= __y; }\n-\n-  template<typename _Tp>\n-    inline complex<_Tp>\n-    operator*(const _Tp& __x, const complex<_Tp>& __y)\n-    { return complex<_Tp> (__y) *= __x; }\n-\n-  template<typename _Tp>\n-    inline complex<_Tp>\n-    operator/(const complex<_Tp>& __x, const complex<_Tp>& __y)\n-    { return complex<_Tp> (__x) /= __y; }\n-    \n-  template<typename _Tp>\n-    inline complex<_Tp>\n-    operator/(const complex<_Tp>& __x, const _Tp& __y)\n-    { return complex<_Tp> (__x) /= __y; }\n-\n-  template<typename _Tp>\n-    inline complex<_Tp>\n-    operator/(const _Tp& __x, const complex<_Tp>& __y)\n-    { return complex<_Tp> (__x) /= __y; }\n-\n-  template<typename _Tp>\n-    inline complex<_Tp>\n-    operator+(const complex<_Tp>& __x)\n-    { return __x; }\n+    }\n \n-  template<typename _Tp>\n-    inline complex<_Tp>\n-    operator-(const complex<_Tp>& __x)\n-    {  return complex<_Tp>(-__x.real(), -__x.imag()); }\n+  // 26.2.3  complex specializations\n+  // complex<long double> specialization\n+  template<> class complex<long double>\n+  {\n+  public:\n+    typedef long double value_type;\n \n-  template<typename _Tp>\n-    inline bool\n-    operator==(const complex<_Tp>& __x, const complex<_Tp>& __y)\n-    { return __x.real() == __y.real() && __x.imag() == __y.imag(); }\n+    complex(long double = 0.0L, long double = 0.0L);\n+#ifdef _GLIBCPP_BUGGY_COMPLEX\n+    complex(const complex& __z) : _M_value(__z._M_value) { }\n+#endif\n+    explicit complex(const complex<float>&);\n+    explicit complex(const complex<double>&);\n \n-  template<typename _Tp>\n-    inline bool\n-    operator==(const complex<_Tp>& __x, const _Tp& __y)\n-    { return __x.real() == __y && __x.imag() == _Tp(); }\n+    long double real() const;\n+    long double imag() const;\n \n-  template<typename _Tp>\n-    inline bool\n-    operator==(const _Tp& __x, const complex<_Tp>& __y)\n-    { return __x == __y.real() && _Tp() == __y.imag(); }\n+    complex<long double>& operator= (long double);\n+    complex<long double>& operator+= (long double);\n+    complex<long double>& operator-= (long double);\n+    complex<long double>& operator*= (long double);\n+    complex<long double>& operator/= (long double);\n \n-  template<typename _Tp>\n-    inline bool\n-    operator!=(const complex<_Tp>& __x, const complex<_Tp>& __y)\n-    { return __x.real() != __y.real() || __x.imag() != __y.imag(); }\n+    // The compiler knows how to do this efficiently\n+    // complex& operator= (const complex&);\n+    template<typename _Tp>\n+      complex<long double>& operator=(const complex<_Tp>&);\n+    template<typename _Tp>\n+      complex<long double>& operator+=(const complex<_Tp>&);\n+    template<typename _Tp>\n+      complex<long double>& operator-=(const complex<_Tp>&);\n+    template<typename _Tp>\n+      complex<long double>& operator*=(const complex<_Tp>&);\n+    template<typename _Tp>\n+      complex<long double>& operator/=(const complex<_Tp>&);\n \n-  template<typename _Tp>\n-    inline bool\n-    operator!=(const complex<_Tp>& __x, const _Tp& __y)\n-    { return __x.real() != __y || __x.imag() != _Tp(); }\n+  private:\n+    typedef __complex__ long double _ComplexT;\n+    _ComplexT _M_value;\n \n-  template<typename _Tp>\n-    inline bool\n-    operator!=(const _Tp& __x, const complex<_Tp>& __y)\n-    { return __x != __y.real() || _Tp() != __y.imag(); }\n+    complex(_ComplexT __z) : _M_value(__z) { }\n \n-  template<typename _Tp, typename _CharT, class _Traits>\n-    basic_istream<_CharT, _Traits>&\n-    operator>>(basic_istream<_CharT, _Traits>&, complex<_Tp>&);\n+    friend class complex<float>;\n+    friend class complex<double>;\n \n-  template<typename _Tp, typename _CharT, class _Traits>\n-    basic_ostream<_CharT, _Traits>&\n-    operator<<(basic_ostream<_CharT, _Traits>&, const complex<_Tp>&);\n+    friend complex<long double> pow<>(const complex<long double>&, int);\n+    friend complex<long double> pow<>(const complex<long double>&,\n+\t\t\t\t      const long double&);\n+    friend complex<long double> pow<>(const complex<long double>&,\n+\t\t\t\t      const complex<long double>&);\n+    friend complex<long double> pow<>(const long double&,\n+\t\t\t\t      const complex<long double>&);\n+    friend complex<long double> sqrt<>(const complex<long double>&);\n+    friend complex<long double> tan<>(const complex<long double>&);\n+    friend complex<long double> tanh<>(const complex<long double>&);\n+  };\n \n+  inline\n+  complex<long double>::complex(long double __r, long double __i)\n+  {\n+    __real__ _M_value = __r;\n+    __imag__ _M_value = __i;\n+  }\n \n-  // Values:\n-  template <typename _Tp>\n-    inline _Tp\n-    real(const complex<_Tp>& __z)\n-    { return __z.real(); }\n-    \n-  template <typename _Tp>\n-    inline _Tp\n-    imag(const complex<_Tp>& __z)\n-    { return __z.imag(); }\n+  inline long double\n+  complex<long double>::real() const\n+  { return __real__ _M_value; }\n \n-  template<typename _Tp>\n-    inline _Tp\n-    abs(const complex<_Tp>& __z)\n-    {\n-      _Tp __x = __z.real();\n-      _Tp __y = __z.imag();\n-      const _Tp __s = abs(__x) + abs(__y);\n-      if (__s == _Tp())  // well ...\n-        return __s;\n-      __x /= __s; __y /= __s;\n-      return __s * sqrt(__x * __x + __y * __y);\n-    }\n+  inline long double\n+  complex<long double>::imag() const\n+  { return __imag__ _M_value; }\n \n-  template<typename _Tp>\n-    inline _Tp\n-    arg(const complex<_Tp>& __z)\n-    { return atan2(__z.imag(), __z.real()); }\n+  inline complex<long double>&   \n+  complex<long double>::operator=(long double __r)\n+  {\n+    __real__ _M_value = __r;\n+    __imag__ _M_value = 0.0L;\n+    return *this;\n+  }\n+\n+  inline complex<long double>&\n+  complex<long double>::operator+=(long double __r)\n+  {\n+    __real__ _M_value += __r;\n+    return *this;\n+  }\n \n+  inline complex<long double>&\n+  complex<long double>::operator-=(long double __r)\n+  {\n+    __real__ _M_value -= __r;\n+    return *this;\n+  }\n \n-  template<typename _Tp>\n-    inline complex<_Tp>\n-    polar(const _Tp& __rho, const _Tp& __theta)\n-    { return complex<_Tp>(__rho * cos(__theta), __rho * sin(__theta)); }\n+  inline complex<long double>&\n+  complex<long double>::operator*=(long double __r)\n+  {\n+    __real__ _M_value *= __r;\n+    return *this;\n+  }\n \n-  template<typename _Tp>\n-    inline complex<_Tp>\n-    conj(const complex<_Tp>& __z)\n-    { return complex<_Tp>(__z.real(), -__z.imag()); }\n-  \n-//    // We use here a few more specializations.\n-//    template<>\n-//      inline complex<float>\n-//      conj(const complex<float> &__x)\n-//  #ifdef _GLIBCPP_BUGGY_FLOAT_COMPLEX\n-//      {\n-//        complex<float> __tmpf(~__x._M_value);\n-//        return __tmpf;\n-//      }\n-//  #else\n-//    { return complex<float>(~__x._M_value); }\n-//  #endif\n-\n-//    template<>\n-//      inline complex<double>\n-//      conj(const complex<double> &__x)\n-//      {  return complex<double> (~__x._M_value); }\n+  inline complex<long double>&\n+  complex<long double>::operator/=(long double __r)\n+  {\n+    __real__ _M_value /= __r;\n+    return *this;\n+  }\n \n-  // Transcendentals:\n   template<typename _Tp>\n-    inline complex<_Tp>\n-    cos(const complex<_Tp>& __z)\n+    inline complex<long double>&\n+    complex<long double>::operator=(const complex<_Tp>& __z)\n     {\n-      const _Tp __x = __z.real();\n-      const _Tp __y = __z.imag();\n-      return complex<_Tp>(cos(__x) * cosh(__y), -sin(__x) * sinh(__y));\n+      __real__ _M_value = __z.real();\n+      __imag__ _M_value = __z.imag();\n+      return *this;\n     }\n \n   template<typename _Tp>\n-    inline complex<_Tp>\n-    cosh(const complex<_Tp>& __z)\n+    inline complex<long double>&\n+    complex<long double>::operator+=(const complex<_Tp>& __z)\n     {\n-      const _Tp __x = __z.real();\n-      const _Tp __y = __z.imag();\n-      return complex<_Tp>(cosh(__x) * cos(__y), sinh(__x) * sin(__y));\n+      __real__ _M_value += __z.real();\n+      __imag__ _M_value += __z.imag();\n+      return *this;\n     }\n \n   template<typename _Tp>\n-    inline complex<_Tp>\n-    exp(const complex<_Tp>& __z)\n-    { return polar(exp(__z.real()), __z.imag()); }\n-\n-  template<typename _Tp>\n-    inline complex<_Tp>\n-    log(const complex<_Tp>& __z)\n-    { return complex<_Tp>(log(abs(__z)), arg(__z)); }\n-\n-  template<typename _Tp>\n-    inline complex<_Tp>\n-    log10(const complex<_Tp>& __z)\n-    { return log(__z) / log(_Tp(10.0)); }\n-\n+    inline complex<long double>&\n+    complex<long double>::operator-=(const complex<_Tp>& __z)\n+    {\n+      __real__ _M_value -= __z.real();\n+      __imag__ _M_value -= __z.imag();\n+      return *this;\n+    }\n+    \n   template<typename _Tp>\n-    inline complex<_Tp>\n-    sin(const complex<_Tp>& __z)\n+    inline complex<long double>&\n+    complex<long double>::operator*=(const complex<_Tp>& __z)\n     {\n-      const _Tp __x = __z.real();\n-      const _Tp __y = __z.imag();\n-      return complex<_Tp>(sin(__x) * cosh(__y), cos(__x) * sinh(__y)); \n+      _ComplexT __t;\n+      __real__ __t = __z.real();\n+      __imag__ __t = __z.imag();\n+      _M_value *= __t;\n+      return *this;\n     }\n \n   template<typename _Tp>\n-    inline complex<_Tp>\n-    sinh(const complex<_Tp>& __z)\n+    inline complex<long double>&\n+    complex<long double>::operator/=(const complex<_Tp>& __z)\n     {\n-      const _Tp __x = __z.real();\n-      const _Tp  __y = __z.imag();\n-      return complex<_Tp>(sinh(__x) * cos(__y), cosh(__x) * sin(__y));\n+      _ComplexT __t;\n+      __real__ __t = __z.real();\n+      __imag__ __t = __z.imag();\n+      _M_value /= __t;\n+      return *this;\n     }\n+\n+  // These bits have to be at the end of this file, so that the\n+  // specializations have all been defined.\n+  inline\n+  complex<float>::complex(const complex<double>& __z)\n+  : _M_value(_ComplexT(__z._M_value)) { }\n+\n+  inline\n+  complex<float>::complex(const complex<long double>& __z)\n+  : _M_value(_ComplexT(__z._M_value)) { }\n+\n+  inline\n+  complex<double>::complex(const complex<float>& __z) \n+  : _M_value(_ComplexT(__z._M_value)) { }\n+\n+  inline\n+  complex<double>::complex(const complex<long double>& __z)\n+  {\n+    __real__ _M_value = __z.real();\n+    __imag__ _M_value = __z.imag();\n+  }\n+\n+  inline\n+  complex<long double>::complex(const complex<float>& __z)\n+  : _M_value(_ComplexT(__z._M_value)) { }\n+\n+  inline\n+  complex<long double>::complex(const complex<double>& __z)\n+  : _M_value(_ComplexT(__z._M_value)) { }\n } // namespace std\n \n #endif\t/* _CPP_COMPLEX */\n+\n+\n+\n+\n+"}, {"sha": "307f618adecc32573c6d1e86dbbcfd47559c56b2", "filename": "libstdc++-v3/include/c/bits/std_cmath.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e90dd7193a80566748d8681500984b53d9b957c/libstdc%2B%2B-v3%2Finclude%2Fc%2Fbits%2Fstd_cmath.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e90dd7193a80566748d8681500984b53d9b957c/libstdc%2B%2B-v3%2Finclude%2Fc%2Fbits%2Fstd_cmath.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc%2Fbits%2Fstd_cmath.h?ref=5e90dd7193a80566748d8681500984b53d9b957c", "patch": "@@ -296,7 +296,7 @@ namespace std\n   abs(double __x) { return __builtin_fabs(__x); }\n #else\n   inline double\n-  abs(double __x) { return fabs (__x); }\n+  abs(double __x) { return fabs(__x); }\n #endif\n \n   extern \"C\" double floor(double __x);"}, {"sha": "33280e5670d79bc71b54216798a5c1a7122d6f94", "filename": "libstdc++-v3/src/complex.cc", "status": "modified", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e90dd7193a80566748d8681500984b53d9b957c/libstdc%2B%2B-v3%2Fsrc%2Fcomplex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e90dd7193a80566748d8681500984b53d9b957c/libstdc%2B%2B-v3%2Fsrc%2Fcomplex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fcomplex.cc?ref=5e90dd7193a80566748d8681500984b53d9b957c", "patch": "@@ -27,7 +27,6 @@\n // invalidate any other reasons why the executable file might be covered by\n // the GNU General Public License.\n \n-#include <bits/std_cmath.h>\n #include <bits/std_complex.h>\n \n // This is a ISO C 9X header.\n@@ -45,62 +44,6 @@\n \n namespace std\n {\n-//    template<>\n-//    FLT\n-//    abs(const complex<FLT>& __x)\n-//    { \n-//      // We don't use cabs here because some systems (IRIX 6.5, for\n-//      // example) define their own incompatible version.\n-//      return hypot (__real__ __x._M_value, __imag__ __x._M_value); \n-//    }\n-\n-//    template<>\n-//    FLT\n-//    arg(const complex<FLT>& __x)\n-//    { return carg(__x._M_value); }\n-\n-//    template<>\n-//    complex<FLT>\n-//    polar(const FLT& __rho, const FLT& __theta)\n-//    {\n-//  #if 0\n-//  // XXX\n-//  // defined(_GLIBCPP_HAVE_SINCOS) && !defined(__osf__)\n-//      // Although sincos does exist on OSF3.2 and OSF4.0 we cannot use it\n-//      // since the necessary types are not defined in the headers.\n-//      FLT __sinx, __cosx;\n-//      sincos(__theta, &__sinx, &__cosx);\n-//      return complex<FLT>(__rho * __cosx, __rho * __sinx);\n-//  #else\n-//      return complex<FLT>(__rho * cos(__theta), __rho * sin(__theta));\n-//  #endif\n-//    }\n-\n-//    template<>\n-//    complex<FLT>\n-//    cos(const complex<FLT>& __x)\n-//    { return complex<FLT>(ccos(__x._M_value)); }\n-\n-//    template<>\n-//    complex<FLT>\n-//    cosh(const complex<FLT>& __x)\n-//    { return complex<FLT>(ccosh(__x._M_value)); }\n-\n-//    template<>\n-//    complex<FLT>\n-//    exp(const complex<FLT>& __x)\n-//    { return complex<FLT>(cexp(__x._M_value)); }\n-\n-//    template<>\n-//    complex<FLT>\n-//    log(const complex<FLT>& __x)\n-//    { return complex<FLT>(c_log(__x._M_value)); }\n-\n-//    template<>\n-//    complex<FLT>\n-//    log10(const complex<FLT>& __x)\n-//    { return complex<FLT>(clog10(__x._M_value)); }\n-  \n   template<>\n   complex<FLT>\n   pow(const complex<FLT>& __x, int __n)\n@@ -121,16 +64,6 @@ namespace std\n   pow(const FLT& __x, const complex<FLT>& __y)\n   { return complex<FLT>(cexp(__y._M_value * log(__x))); }\n \n-//    template<>\n-//    complex<FLT>\n-//    sin(const complex<FLT>& __x)\n-//    { return complex<FLT>(csin(__x._M_value)); }\n-\n-//    template<>\n-//    complex<FLT>\n-//    sinh(const complex<FLT>& __x)\n-//    { return complex<FLT>(csinh(__x._M_value)); }\n-  \n   template<>\n   complex<FLT>\n   sqrt(const complex<FLT>& __x)"}, {"sha": "02f9bdf181e93d00f4ac7669484a4ce3a72bef62", "filename": "libstdc++-v3/testsuite/23_containers/vector_ctor.cc", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e90dd7193a80566748d8681500984b53d9b957c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector_ctor.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e90dd7193a80566748d8681500984b53d9b957c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector_ctor.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector_ctor.cc?ref=5e90dd7193a80566748d8681500984b53d9b957c", "patch": "@@ -1,7 +1,7 @@\n // 1999-06-29\n // bkoz \n \n-// Copyright (C) 1999 Free Software Foundation, Inc.\n+// Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -29,7 +29,7 @@ template<typename T>\n \n struct B { };\n \n-bool test01()\n+void test01()\n {\n \n   // 1\n@@ -43,18 +43,25 @@ bool test01()\n #ifdef DEBUG_ASSERT\n   assert(test);\n #endif\n-  \n-  return test;\n }\n \n // 2\n template class std::vector<double>;\n template class std::vector< A<B> >;\n \n+\n+// libstdc++/102\n+void test02\n+{\n+  std::vector<int> v1;\n+  std::vector<int> v2 (v1);\n+}\n+\n+\n int main()\n {\n   test01();\n-\n+  test02(); \n   return 0;\n }\n "}, {"sha": "c6105c36f6d7cc095306e93e50a58eb0d34c2b61", "filename": "libstdc++-v3/testsuite/26_numerics/complex_value.cc", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e90dd7193a80566748d8681500984b53d9b957c/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fcomplex_value.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e90dd7193a80566748d8681500984b53d9b957c/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fcomplex_value.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fcomplex_value.cc?ref=5e90dd7193a80566748d8681500984b53d9b957c", "patch": "@@ -0,0 +1,64 @@\n+// 2000-11-20\n+// Benjamin Kosnik bkoz@redhat.com\n+\n+// Copyright (C) 2000 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+#include <complex>\n+#include <debug_assert.h>\n+\n+void test01()\n+{\n+ using namespace std;\n+ bool test = true;\n+ typedef complex<double> complex_type;\n+ const double cd1 = -11.451;\n+ const double cd2 = -442.1533;\n+\n+ complex_type a(cd1, cd2);\n+ double d;\n+ d = a.real();\n+ VERIFY( d == cd1);\n+\n+ d = a.imag();\n+ VERIFY(d == cd2);\n+\n+ complex_type c(cd1, cd2);\n+ double d6 = abs(c);\n+ VERIFY( d6 >= 0);\n+\n+ double d7 = arg(c);\n+ double d8 = atan2(c.imag(), c.real());\n+ VERIFY( d7 == d8);\n+\n+ double d9 = norm(c);\n+ double d10 = d6 * d6;\n+ VERIFY(d9 - d10 == 0);\n+\n+ complex_type e = conj(c);\n+ \n+ complex_type f = polar(c.imag(), 0.0);\n+ VERIFY(f.real() != 0);\n+}\n+\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}]}