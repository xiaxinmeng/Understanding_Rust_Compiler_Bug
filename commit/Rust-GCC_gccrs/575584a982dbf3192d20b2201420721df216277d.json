{"sha": "575584a982dbf3192d20b2201420721df216277d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTc1NTg0YTk4MmRiZjMxOTJkMjBiMjIwMTQyMDcyMWRmMjE2Mjc3ZA==", "commit": {"author": {"name": "Nicola Pero", "email": "nicola.pero@meta-innovation.com", "date": "2010-12-18T12:22:59Z"}, "committer": {"name": "Nicola Pero", "email": "nicola@gcc.gnu.org", "date": "2010-12-18T12:22:59Z"}, "message": "In libobjc/: 2010-12-18 Nicola Pero <nicola.pero@meta-innovation.com>\n\nIn libobjc/:\n2010-12-18  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n\t* class.c: Tidied up comments and indentation.  No code changes.\n\t* error.c: Same.\n\t* exception.c: Same.\n\t* init.c: Same.\n\t* ivars.c: Same.\n\t* memory.c: Same.\n\t* objc-foreach.c: Same.\n\t* objc-sync.c: Same.\n\t* objects.c: Same.\n\t* protocols.c: Same.\n\t* sarray.c: Same.\n\t* thr.c: Same.\n\nFrom-SVN: r168022", "tree": {"sha": "d7fb79bd88b2a0bfec5d8db79632971970a6eea6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d7fb79bd88b2a0bfec5d8db79632971970a6eea6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/575584a982dbf3192d20b2201420721df216277d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/575584a982dbf3192d20b2201420721df216277d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/575584a982dbf3192d20b2201420721df216277d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/575584a982dbf3192d20b2201420721df216277d/comments", "author": {"login": "Nico-31415", "id": 94470564, "node_id": "U_kgDOBaGBpA", "avatar_url": "https://avatars.githubusercontent.com/u/94470564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nico-31415", "html_url": "https://github.com/Nico-31415", "followers_url": "https://api.github.com/users/Nico-31415/followers", "following_url": "https://api.github.com/users/Nico-31415/following{/other_user}", "gists_url": "https://api.github.com/users/Nico-31415/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nico-31415/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nico-31415/subscriptions", "organizations_url": "https://api.github.com/users/Nico-31415/orgs", "repos_url": "https://api.github.com/users/Nico-31415/repos", "events_url": "https://api.github.com/users/Nico-31415/events{/privacy}", "received_events_url": "https://api.github.com/users/Nico-31415/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f21fe68470f435870bcc4f0ff1bdc52f1c013103", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f21fe68470f435870bcc4f0ff1bdc52f1c013103", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f21fe68470f435870bcc4f0ff1bdc52f1c013103"}], "stats": {"total": 1115, "additions": 504, "deletions": 611}, "files": [{"sha": "793b002c4cf85b37bb8f64007f97d2e089016ab2", "filename": "libobjc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/575584a982dbf3192d20b2201420721df216277d/libobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/575584a982dbf3192d20b2201420721df216277d/libobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FChangeLog?ref=575584a982dbf3192d20b2201420721df216277d", "patch": "@@ -1,3 +1,18 @@\n+2010-12-18  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* class.c: Tidied up comments and indentation.  No code changes.\n+\t* error.c: Same.\n+\t* exception.c: Same.\n+\t* init.c: Same.\n+\t* ivars.c: Same.\n+\t* memory.c: Same.\n+\t* objc-foreach.c: Same.\n+\t* objc-sync.c: Same.\n+\t* objects.c: Same.\n+\t* protocols.c: Same.\n+\t* sarray.c: Same.\n+\t* thr.c: Same.\n+\n 2010-12-17  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* init.c: Include objc/runtime.h and objc-private/module-abi-8.h"}, {"sha": "d606a350fbeccd3d6d9a5f22831ce1bbcb2bc47f", "filename": "libobjc/class.c", "status": "modified", "additions": 31, "deletions": 47, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/575584a982dbf3192d20b2201420721df216277d/libobjc%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/575584a982dbf3192d20b2201420721df216277d/libobjc%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fclass.c?ref=575584a982dbf3192d20b2201420721df216277d", "patch": "@@ -26,11 +26,9 @@ a copy of the GCC Runtime Library Exception along with this program;\n see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n-/*\n-  The code in this file critically affects class method invocation\n+/* The code in this file critically affects class method invocation\n   speed.  This long preamble comment explains why, and the issues\n-  involved.  \n-\n+  involved.\n \n   One of the traditional weaknesses of the GNU Objective-C runtime is\n   that class method invocations are slow.  The reason is that when you\n@@ -44,7 +42,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n   \n   objc_get_class returns the class pointer corresponding to the string\n   `NSArray'; and because of the lookup, the operation is more\n-  complicated and slow than a simple instance method invocation.  \n+  complicated and slow than a simple instance method invocation.\n   \n   Most high performance Objective-C code (using the GNU Objc runtime)\n   I had the opportunity to read (or write) work around this problem by\n@@ -61,7 +59,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n   In this case, you always perform a class lookup (the first one), but\n   then all the [arrayClass new] methods run exactly as fast as an\n   instance method invocation.  It helps if you have many class method\n-  invocations to the same class.  \n+  invocations to the same class.\n   \n   The long-term solution to this problem would be to modify the\n   compiler to output tables of class pointers corresponding to all the\n@@ -70,14 +68,14 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n   to perform precisely as fast as instance method invocations, because\n   no class lookup would be involved.  I think the Apple Objective-C\n   runtime uses this technique.  Doing this involves synchronized\n-  modifications in the runtime and in the compiler.  \n+  modifications in the runtime and in the compiler.\n   \n   As a first medicine to the problem, I [NP] have redesigned and\n   rewritten the way the runtime is performing class lookup.  This\n   doesn't give as much speed as the other (definitive) approach, but\n   at least a class method invocation now takes approximately 4.5 times\n   an instance method invocation on my machine (it would take approx 12\n-  times before the rewriting), which is a lot better.  \n+  times before the rewriting), which is a lot better.\n \n   One of the main reason the new class lookup is so faster is because\n   I implemented it in a way that can safely run multithreaded without\n@@ -97,11 +95,11 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include <string.h>                     /* For memset */\n \n /* We use a table which maps a class name to the corresponding class\n- * pointer.  The first part of this file defines this table, and\n- * functions to do basic operations on the table.  The second part of\n- * the file implements some higher level Objective-C functionality for\n- * classes by using the functions provided in the first part to manage\n- * the table. */\n+   pointer.  The first part of this file defines this table, and\n+   functions to do basic operations on the table.  The second part of\n+   the file implements some higher level Objective-C functionality for\n+   classes by using the functions provided in the first part to manage\n+   the table. */\n \n /**\n  ** Class Table Internals\n@@ -145,7 +143,7 @@ static class_node_ptr class_table_array[CLASS_TABLE_SIZE];\n static objc_mutex_t __class_table_lock = NULL;\n \n /* CLASS_TABLE_HASH is how we compute the hash of a class name.  It is\n-   a macro - *not* a function - arguments *are* modified directly.  \n+   a macro - *not* a function - arguments *are* modified directly.\n \n    INDEX should be a variable holding an int;\n    HASH should be a variable holding an int;\n@@ -176,7 +174,8 @@ class_table_setup (void)\n }\n \n \n-/* Insert a class in the table (used when a new class is registered).  */\n+/* Insert a class in the table (used when a new class is\n+   registered).  */\n static void \n class_table_insert (const char *class_name, Class class_pointer)\n {\n@@ -221,18 +220,15 @@ class_table_replace (Class old_class_pointer, Class new_class_pointer)\n         {\n           hash++;\n           if (hash < CLASS_TABLE_SIZE)\n-            {\n-              node = class_table_array[hash];\n-            }\n+\t    node = class_table_array[hash];\n         }\n       else\n         {\n           Class class1 = node->pointer;\n \n           if (class1 == old_class_pointer)\n-            {\n-              node->pointer = new_class_pointer;\n-            }\n+\t    node->pointer = new_class_pointer;\n+\n           node = node->next;\n         }\n     }\n@@ -267,9 +263,7 @@ class_table_get_safe (const char *class_name)\n               for (i = 0; i < length; i++)\n                 {\n                   if ((node->name)[i] != class_name[i]) \n-                    {\n-                      break;\n-                    }\n+\t\t    break;\n                 }\n               \n               if (i == length)\n@@ -309,9 +303,7 @@ class_table_next (struct class_table_enumerator **e)\n       next = class_table_array[enumerator->hash];\n     }\n   else\n-    {\n-      next = enumerator->node->next;\n-    }\n+    next = enumerator->node->next;\n   \n   if (next != NULL)\n     {\n@@ -385,18 +377,16 @@ class_table_print_histogram (void)\n         {\n           printf (\"%4d:\", i + 1);\n           for (j = 0; j < counter; j++)\n-            {\n-              printf (\"X\");\n-            }\n+\t    printf (\"X\");\n+\n           printf (\"\\n\");\n           counter = 0;\n         }\n     }\n   printf (\"%4d:\", i + 1);\n   for (j = 0; j < counter; j++)\n-    {\n-      printf (\"X\");\n-    }\n+    printf (\"X\");\n+\n   printf (\"\\n\");\n }\n #endif /* DEBUGGING FUNCTIONS */\n@@ -409,7 +399,7 @@ class_table_print_histogram (void)\n    should be via the class_table_* functions.  */\n \n /* This is a hook which is called by objc_get_class and\n-   objc_lookup_class if the runtime is not able to find the class.  \n+   objc_lookup_class if the runtime is not able to find the class.\n    This may e.g. try to load in the class using dynamic loading.\n \n    This hook was a public, global variable in the Traditional GNU\n@@ -558,9 +548,7 @@ objc_getClassList (Class *returnValue, int maxNumberOfClassesToReturn)\n \t      if (count < maxNumberOfClassesToReturn)\n \t\treturnValue[count] = node->pointer;\n \t      else\n-\t\t{\n-\t\t  return count;\n-\t\t}\n+\t\treturn count;\n \t    }\n \t  count++;\n \t  node = node->next;\n@@ -869,20 +857,16 @@ __objc_update_classes_with_methods (struct objc_method *method_a, struct objc_me\n \t\t  /* If the method is one of the ones we are looking\n \t\t     for, update the implementation.  */\n \t\t  if (method == method_a)\n-\t\t    {\n-\t\t      sarray_at_put_safe (class->dtable,\n-\t\t\t\t\t  (sidx) method_a->method_name->sel_id,\n-\t\t\t\t\t  method_a->method_imp);\n-\t\t    }\n+\t\t    sarray_at_put_safe (class->dtable,\n+\t\t\t\t\t(sidx) method_a->method_name->sel_id,\n+\t\t\t\t\tmethod_a->method_imp);\n \n \t\t  if (method == method_b)\n \t\t    {\n \t\t      if (method_b != NULL)\n-\t\t\t{\n-\t\t\t  sarray_at_put_safe (class->dtable,\n-\t\t\t\t\t      (sidx) method_b->method_name->sel_id,\n-\t\t\t\t\t      method_b->method_imp);\n-\t\t\t}\n+\t\t\tsarray_at_put_safe (class->dtable,\n+\t\t\t\t\t    (sidx) method_b->method_name->sel_id,\n+\t\t\t\t\t    method_b->method_imp);\n \t\t    }\n \t\t}\n \t  "}, {"sha": "1dae36594f238883f2ca55d403360c85fbf7df64", "filename": "libobjc/error.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/575584a982dbf3192d20b2201420721df216277d/libobjc%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/575584a982dbf3192d20b2201420721df216277d/libobjc%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Ferror.c?ref=575584a982dbf3192d20b2201420721df216277d", "patch": "@@ -28,8 +28,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n /* __USE_FIXED_PROTOTYPES__ used to be required to get prototypes for\n    malloc, free, etc. on some platforms.  It is unclear if we still\n-   need it, but it can't hurt.\n-*/\n+   need it, but it can't hurt.  */\n #define __USE_FIXED_PROTOTYPES__\n #include <stdlib.h>\n #include <stdio.h>"}, {"sha": "1ffb80b5352d0f33b2772583c2d17c467f32399b", "filename": "libobjc/exception.c", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/575584a982dbf3192d20b2201420721df216277d/libobjc%2Fexception.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/575584a982dbf3192d20b2201420721df216277d/libobjc%2Fexception.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fexception.c?ref=575584a982dbf3192d20b2201420721df216277d", "patch": "@@ -33,25 +33,22 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n /* This hook allows libraries to sepecify special actions when an\n    exception is thrown without a handler in place.  This is deprecated\n-   in favour of objc_set_uncaught_exception_handler ().\n- */\n+   in favour of objc_set_uncaught_exception_handler ().  */\n void (*_objc_unexpected_exception) (id exception); /* !T:SAFE */\n \n \n /* 'is_kind_of_exception_matcher' is our default exception matcher -\n    it determines if the object 'exception' is of class 'catch_class',\n-   or of a subclass.\n-*/\n+   or of a subclass.  */\n static int\n is_kind_of_exception_matcher (Class catch_class, id exception)\n {\n   /* NULL catch_class is catch-all (eg, @catch (id object)).  */\n   if (catch_class == Nil)\n     return 1;\n \n-  /* If exception is nil (eg, @throw nil;), then it can only be catched\n-   * by a catch-all (eg, @catch (id object)).\n-   */\n+  /* If exception is nil (eg, @throw nil;), then it can only be\n+     catched by a catch-all (eg, @catch (id object)).  */\n   if (exception != nil)\n     {\n       Class c;\n@@ -114,19 +111,18 @@ static const _Unwind_Exception_Class __objc_exception_class\n \n /* This is the object that is passed around by the Objective C runtime\n    to represent the exception in flight.  */\n-\n struct ObjcException\n {\n   /* This bit is needed in order to interact with the unwind runtime.  */\n   struct _Unwind_Exception base;\n \n-  /* The actual object we want to throw. Note: must come immediately after\n-     unwind header.  */\n+  /* The actual object we want to throw. Note: must come immediately\n+     after unwind header.  */\n   id value;\n \n #ifdef __ARM_EABI_UNWINDER__\n-  /* Note: we use the barrier cache defined in the unwind control block for\n-     ARM EABI.  */\n+  /* Note: we use the barrier cache defined in the unwind control\n+     block for ARM EABI.  */\n #else\n   /* Cache some internal unwind data between phase 1 and phase 2.  */\n   _Unwind_Ptr landingPad;\n@@ -156,14 +152,16 @@ parse_lsda_header (struct _Unwind_Context *context, const unsigned char *p,\n \n   info->Start = (context ? _Unwind_GetRegionStart (context) : 0);\n \n-  /* Find @LPStart, the base to which landing pad offsets are relative.  */\n+  /* Find @LPStart, the base to which landing pad offsets are\n+     relative.  */\n   lpstart_encoding = *p++;\n   if (lpstart_encoding != DW_EH_PE_omit)\n     p = read_encoded_value (context, lpstart_encoding, p, &info->LPStart);\n   else\n     info->LPStart = info->Start;\n \n-  /* Find @TType, the base of the handler and exception spec type data.  */\n+  /* Find @TType, the base of the handler and exception spec type\n+     data.  */\n   info->ttype_encoding = *p++;\n   if (info->ttype_encoding != DW_EH_PE_omit)\n     {\n@@ -222,7 +220,8 @@ get_ttype_entry (struct lsda_header_info *info, _Unwind_Word i)\n #endif\n \n /* Using a different personality function name causes link failures\n-   when trying to mix code using different exception handling models.  */\n+   when trying to mix code using different exception handling\n+   models.  */\n #ifdef SJLJ_EXCEPTIONS\n #define PERSONALITY_FUNCTION\t__gnu_objc_personality_sj0\n #define __builtin_eh_return_data_regno(x) x\n@@ -294,14 +293,14 @@ PERSONALITY_FUNCTION (int version,\n     }\n   actions |= state & _US_FORCE_UNWIND;\n \n-  /* TODO: Foreign exceptions need some attention (e.g. rethrowing doesn't\n-     work).  */\n+  /* TODO: Foreign exceptions need some attention (e.g. rethrowing\n+     doesn't work).  */\n   foreign_exception = 0;\n \n-  /* The dwarf unwinder assumes the context structure holds things like the\n-     function and LSDA pointers.  The ARM implementation caches these in\n-     the exception header (UCB).  To avoid rewriting everything we make the\n-     virtual IP register point at the UCB.  */\n+  /* The dwarf unwinder assumes the context structure holds things\n+     like the function and LSDA pointers.  The ARM implementation\n+     caches these in the exception header (UCB).  To avoid rewriting\n+     everything we make the virtual IP register point at the UCB.  */\n   ip = (_Unwind_Ptr) ue_header;\n   _Unwind_SetGR (context, 12, ip);\n \n@@ -351,8 +350,8 @@ PERSONALITY_FUNCTION (int version,\n #ifdef SJLJ_EXCEPTIONS\n   /* The given \"IP\" is an index into the call-site table, with two\n      exceptions -- -1 means no-action, and 0 means terminate.  But\n-     since we're using uleb128 values, we've not got random access\n-     to the array.  */\n+     since we're using uleb128 values, we've not got random access to\n+     the array.  */\n   if ((int) ip < 0)\n     return _URC_CONTINUE_UNWIND;\n   else\n@@ -373,13 +372,15 @@ PERSONALITY_FUNCTION (int version,\n       goto found_something;\n     }\n #else\n-  /* Search the call-site table for the action associated with this IP.  */\n+  /* Search the call-site table for the action associated with this\n+     IP.  */\n   while (p < info.action_table)\n     {\n       _Unwind_Ptr cs_start, cs_len, cs_lp;\n       _uleb128_t cs_action;\n \n-      /* Note that all call-site encodings are \"absolute\" displacements.  */\n+      /* Note that all call-site encodings are \"absolute\"\n+\t displacements.  */\n       p = read_encoded_value (0, info.call_site_encoding, p, &cs_start);\n       p = read_encoded_value (0, info.call_site_encoding, p, &cs_len);\n       p = read_encoded_value (0, info.call_site_encoding, p, &cs_lp);\n@@ -400,8 +401,8 @@ PERSONALITY_FUNCTION (int version,\n #endif /* SJLJ_EXCEPTIONS  */\n \n   /* If ip is not present in the table, C++ would call terminate.  */\n-  /* ??? As with Java, it's perhaps better to tweek the LSDA to\n-     that no-action is mapped to no-entry.  */\n+  /* ??? As with Java, it's perhaps better to tweek the LSDA to that\n+     no-action is mapped to no-entry.  */\n   CONTINUE_UNWINDING;\n \n  found_something:\n@@ -410,8 +411,8 @@ PERSONALITY_FUNCTION (int version,\n \n   if (landing_pad == 0)\n     {\n-      /* If ip is present, and has a null landing pad, there are\n-\t no cleanups or handlers to be run.  */\n+      /* If ip is present, and has a null landing pad, there are no\n+\t cleanups or handlers to be run.  */\n     }\n   else if (action_record == 0)\n     {\n@@ -438,14 +439,14 @@ PERSONALITY_FUNCTION (int version,\n \t    }\n \n \t  /* During forced unwinding, we only run cleanups.  With a\n-\t     foreign exception class, we have no class info to match.  */\n+\t     foreign exception class, we have no class info to\n+\t     match.  */\n \t  else if ((actions & _UA_FORCE_UNWIND) || foreign_exception)\n \t    ;\n \n \t  else if (ar_filter > 0)\n \t    {\n \t      /* Positive filter values are handlers.  */\n-\n \t      Class catch_type = get_ttype_entry (&info, ar_filter);\n \n \t      if ((*__objc_exception_matcher) (catch_type, xh->value))\n@@ -476,7 +477,8 @@ PERSONALITY_FUNCTION (int version,\n       if (!saw_handler)\n \tCONTINUE_UNWINDING;\n \n-      /* For domestic exceptions, we cache data from phase 1 for phase 2.  */\n+      /* For domestic exceptions, we cache data from phase 1 for phase\n+\t 2.  */\n       if (!foreign_exception)\n         {\n #ifdef __ARM_EABI_UNWINDER__\n@@ -531,16 +533,14 @@ objc_exception_throw (id exception)\n #endif\n \n   /* No exception handler was installed.  Call the uncaught exception\n-     handler if any is defined.\n-   */\n+     handler if any is defined.  */\n   if (__objc_uncaught_exception_handler != 0)\n     {\n       (*__objc_uncaught_exception_handler) (exception);\n     }\n \n   /* As a last resort support the old, deprecated way of setting an\n-     uncaught exception handler.\n-  */\n+     uncaught exception handler.  */\n   if (_objc_unexpected_exception != 0)\n     {\n       (*_objc_unexpected_exception) (exception);"}, {"sha": "ff47f8103f9b9dc8e098a30d6af97d2e1c17c4cf", "filename": "libobjc/init.c", "status": "modified", "additions": 54, "deletions": 61, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/575584a982dbf3192d20b2201420721df216277d/libobjc%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/575584a982dbf3192d20b2201420721df216277d/libobjc%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Finit.c?ref=575584a982dbf3192d20b2201420721df216277d", "patch": "@@ -38,15 +38,17 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \t\t\t\t       __objc_protocols_register_selectors() */\n #include \"objc-private/accessors.h\" /* For __objc_accessors_init() */\n \n-/* The version number of this runtime.  This must match the number \n+/* The version number of this runtime.  This must match the number\n    defined in gcc (objc-act.c).  */\n #define OBJC_VERSION 8\n #define PROTOCOL_VERSION 2\n \n-/* This list contains all modules currently loaded into the runtime.  */\n+/* This list contains all modules currently loaded into the\n+   runtime.  */\n static struct objc_list *__objc_module_list = 0; \t/* !T:MUTEX */\n \n-/* This list contains all proto_list's not yet assigned class links.  */\n+/* This list contains all proto_list's not yet assigned class\n+   links.  */\n static struct objc_list *unclaimed_proto_list = 0; \t/* !T:MUTEX */\n \n /* List of unresolved static instances.  */\n@@ -95,7 +97,8 @@ extern SEL\n __sel_register_typed_name (const char *name, const char *types, \n \t\t\t   struct objc_selector *orig, BOOL is_const);\n \n-/* Sends +load to all classes and categories in certain situations.  */\n+/* Sends +load to all classes and categories in certain\n+   situations.  */\n static void objc_send_load (void);\n \n /* Inserts all the classes defined in module in a tree of classes that\n@@ -145,20 +148,19 @@ static cache_ptr __objc_load_methods = NULL;\n \n    This function returns the superclass of a class in both cases, and\n    can be used to build the determine the class relationships while\n-   building the tree.\n-*/\n+   building the tree.  */\n static Class  class_superclass_of_class (Class class)\n {\n   char *super_class_name;\n \n   /* If the class links have been resolved, use the resolved\n-   * links.  */\n+     links.  */\n   if (CLS_ISRESOLV (class))\n     return class->super_class;\n   \n   /* Else, 'class' has not yet been resolved.  This means that its\n-   * super_class pointer is really the name of the super class (rather\n-   * than a pointer to the actual superclass).  */\n+     super_class pointer is really the name of the super class (rather\n+     than a pointer to the actual superclass).  */\n   super_class_name = (char *)class->super_class;\n \n   /* Return Nil for a root class.  */\n@@ -175,7 +177,6 @@ static Class  class_superclass_of_class (Class class)\n    `bottom_class'. The classes in this tree are super classes of\n    `bottom_class'. `subclasses' member of each tree node point to the\n    next subclass tree node.  */\n-\n static objc_class_tree *\n create_tree_of_subclasses_inherited_from (Class bottom_class, Class upper)\n {\n@@ -213,7 +214,6 @@ create_tree_of_subclasses_inherited_from (Class bottom_class, Class upper)\n    part of the classes hierarchy described by `tree'. This function is\n    private to objc_tree_insert_class (), you should not call it\n    directly.  */\n-\n static objc_class_tree *\n __objc_tree_insert_class (objc_class_tree *tree, Class class)\n {\n@@ -224,15 +224,15 @@ __objc_tree_insert_class (objc_class_tree *tree, Class class)\n     return create_tree_of_subclasses_inherited_from (class, NULL);\n   else if (class == tree->class)\n     {\n-      /* `class' has been already inserted */\n+      /* `class' has been already inserted.  */\n       DEBUG_PRINTF (\"1. class %s was previously inserted\\n\", class->name);\n       return tree;\n     }\n   else if (class_superclass_of_class (class) == tree->class)\n     {\n-      /* If class is a direct subclass of tree->class then add class to the\n-\t list of subclasses. First check to see if it wasn't already\n-\t inserted.  */\n+      /* If class is a direct subclass of tree->class then add class\n+\t to the list of subclasses. First check to see if it wasn't\n+\t already inserted.  */\n       struct objc_list *list = tree->subclasses;\n       objc_class_tree *node;\n \n@@ -249,7 +249,8 @@ __objc_tree_insert_class (objc_class_tree *tree, Class class)\n \t  list = list->tail;\n \t}\n \n-      /* Create a new node class and insert it into the list of subclasses */\n+      /* Create a new node class and insert it into the list of\n+\t subclasses.  */\n       node = objc_calloc (1, sizeof (objc_class_tree));\n       node->class = class;\n       tree->subclasses = list_cons (node, tree->subclasses);\n@@ -258,8 +259,8 @@ __objc_tree_insert_class (objc_class_tree *tree, Class class)\n     }\n   else\n     {\n-      /* The class is not a direct subclass of tree->class. Search for\n-         class's superclasses in the list of subclasses.  */\n+      /* The class is not a direct subclass of tree->class.  Search\n+         for class's superclasses in the list of subclasses.  */\n       struct objc_list *subclasses = tree->subclasses;\n \n       /* Precondition: the class must be a subclass of tree->class;\n@@ -298,7 +299,6 @@ __objc_tree_insert_class (objc_class_tree *tree, Class class)\n }\n \n /* This function inserts `class' in the right tree hierarchy classes.  */\n-\n static void\n objc_tree_insert_class (Class class)\n {\n@@ -328,7 +328,6 @@ objc_tree_insert_class (Class class)\n }\n \n /* Traverse tree in preorder. Used to send +load.  */\n-\n static void\n objc_preorder_traverse (objc_class_tree *tree,\n \t\t\tint level,\n@@ -342,7 +341,6 @@ objc_preorder_traverse (objc_class_tree *tree,\n }\n \n /* Traverse tree in postorder. Used to destroy a tree.  */\n-\n static void\n objc_postorder_traverse (objc_class_tree *tree,\n \t\t\t int level,\n@@ -356,7 +354,6 @@ objc_postorder_traverse (objc_class_tree *tree,\n }\n \n /* Used to print a tree class hierarchy.  */\n-\n #ifdef DEBUG\n static void\n __objc_tree_print (objc_class_tree *tree, int level)\n@@ -374,7 +371,6 @@ __objc_tree_print (objc_class_tree *tree, int level)\n    reverse order assures the +load of class is executed first and then\n    +load of categories because of the way in which categories are\n    added to the class methods.  */\n-\n static void\n __objc_send_message_in_list (struct objc_method_list *method_list, Class class, SEL op)\n {\n@@ -383,7 +379,7 @@ __objc_send_message_in_list (struct objc_method_list *method_list, Class class,\n   if (! method_list)\n     return;\n \n-  /* First execute the `op' message in the following method lists */\n+  /* First execute the `op' message in the following method lists.  */\n   __objc_send_message_in_list (method_list->method_next, class, op);\n \n   /* Search the method list.  */\n@@ -394,13 +390,13 @@ __objc_send_message_in_list (struct objc_method_list *method_list, Class class,\n       if (mth->method_name && sel_eq (mth->method_name, op)\n \t  && ! objc_hash_is_key_in_hash (__objc_load_methods, mth->method_imp))\n \t{\n-\t  /* Add this method into the +load hash table */\n+\t  /* Add this method into the +load hash table.  */\n \t  objc_hash_add (&__objc_load_methods,\n \t\t\t mth->method_imp,\n \t\t\t mth->method_imp);\n-\n+\t  \n \t  DEBUG_PRINTF (\"sending +load in class: %s\\n\", class->name);\n-\n+\t  \n \t  /* The method was found and wasn't previously executed.  */\n \t  (*mth->method_imp) ((id)class, mth->method_name);\n \n@@ -432,7 +428,6 @@ __objc_destroy_class_tree_node (objc_class_tree *tree,\n \n /* This is used to check if the relationship between two classes\n    before the runtime completely installs the classes.  */\n-\n static BOOL\n class_is_subclass_of_class (Class class, Class superclass)\n {\n@@ -451,7 +446,6 @@ class_is_subclass_of_class (Class class, Class superclass)\n static struct objc_list *unresolved_classes = 0;\n \n /* Extern function used to reference the Object class.  */\n-\n extern void __objc_force_linking (void);\n \n void\n@@ -463,7 +457,6 @@ __objc_force_linking (void)\n \n /* Run through the statics list, removing modules as soon as all its\n    statics have been initialized.  */\n-\n static void\n objc_init_statics (void)\n {\n@@ -516,8 +509,9 @@ objc_init_statics (void)\n \t\t}\n \t      else\n \t\t{\n-\t\t  /* Other static instances (typically constant strings) are\n-\t\t     easier as we just fix up their class pointers.  */\n+\t\t  /* Other static instances (typically constant\n+\t\t     strings) are easier as we just fix up their class\n+\t\t     pointers.  */\n \t\t  for (inst = &statics->instances[0]; *inst; inst++)\t\t  \n \t\t    (*inst)->class_pointer = class;\n \t\t}\n@@ -535,7 +529,7 @@ objc_init_statics (void)\n     }\n \n   objc_mutex_unlock (__objc_runtime_mutex);\n-} /* objc_init_statics */\n+}\n \n /* This function is called by constructor functions generated for each\n    module compiled.  (_GLOBAL_$I$...) The purpose of this function is\n@@ -565,18 +559,18 @@ __objc_exec_class (struct objc_module *module)\n   /* The table of selector references for this module.  */\n   SEL selectors = symtab->refs; \n \n-  /* dummy counter.  */\n   int i;\n \n   DEBUG_PRINTF (\"received module: %s\\n\", module->name);\n \n-  /* check gcc version */\n+  /* Check gcc version.  */\n   init_check_module_version (module);\n \n-  /* On the first call of this routine, initialize some data structures.  */\n+  /* On the first call of this routine, initialize some data\n+     structures.  */\n   if (! previous_constructors)\n     {\n-\t/* Initialize thread-safe system */\n+\t/* Initialize thread-safe system.  */\n       __objc_init_thread_system ();\n       __objc_runtime_threads_alive = 1;\n       __objc_runtime_mutex = objc_mutex_allocate ();\n@@ -594,7 +588,8 @@ __objc_exec_class (struct objc_module *module)\n       previous_constructors = 1;\n     }\n \n-  /* Save the module pointer for later processing. (not currently used) */\n+  /* Save the module pointer for later processing. (not currently\n+     used).  */\n   objc_mutex_lock (__objc_runtime_mutex);\n   __objc_module_list = list_cons (module, __objc_module_list);\n \n@@ -606,15 +601,17 @@ __objc_exec_class (struct objc_module *module)\n \t  const char *name, *type;\n \t  name = (char *) selectors[i].sel_id;\n \t  type = (char *) selectors[i].sel_types;\n-\t  /* Constructors are constant static data so we can safely store\n-\t     pointers to them in the runtime structures. is_const == YES */\n+\t  /* Constructors are constant static data so we can safely\n+\t     store pointers to them in the runtime\n+\t     structures. is_const == YES.  */\n \t  __sel_register_typed_name (name, type, \n \t\t\t\t     (struct objc_selector *) &(selectors[i]),\n \t\t\t\t     YES);\n \t}\n     }\n \n-  /* Parse the classes in the load module and gather selector information.  */\n+  /* Parse the classes in the load module and gather selector\n+     information.  */\n   DEBUG_PRINTF (\"gathering selectors from module: %s\\n\", module->name);\n   for (i = 0; i < symtab->cls_def_cnt; ++i)\n     {\n@@ -626,14 +623,14 @@ __objc_exec_class (struct objc_module *module)\n       assert (CLS_ISMETA (class->class_pointer));\n       DEBUG_PRINTF (\"phase 1, processing class: %s\\n\", class->name);\n \n-      /* Initialize the subclass list to be NULL.\n-\t In some cases it isn't and this crashes the program.  */\n+      /* Initialize the subclass list to be NULL.  In some cases it\n+\t isn't and this crashes the program.  */\n       class->subclass_list = NULL;\n \n       __objc_init_class (class);\n \n-      /* Check to see if the superclass is known in this point. If it's not\n-\t add the class to the unresolved_classes list.  */\n+      /* Check to see if the superclass is known in this point. If\n+\t it's not add the class to the unresolved_classes list.  */\n       if (superclass && ! objc_getClass (superclass))\n \tunresolved_classes = list_cons (class, unresolved_classes);\n    }\n@@ -644,7 +641,8 @@ __objc_exec_class (struct objc_module *module)\n       struct objc_category *category = symtab->defs[i + symtab->cls_def_cnt];\n       Class class = objc_getClass (category->class_name);\n       \n-      /* If the class for the category exists then append its methods.  */\n+      /* If the class for the category exists then append its\n+\t methods.  */\n       if (class)\n \t{\n \n@@ -673,8 +671,8 @@ __objc_exec_class (struct objc_module *module)\n \t}\n       else\n \t{\n-\t  /* The object to which the category methods belong can't be found.\n-\t     Save the information.  */\n+\t  /* The object to which the category methods belong can't be\n+\t     found.  Save the information.  */\n \t  unclaimed_categories = list_cons (category, unclaimed_categories);\n \t}\n     }\n@@ -684,8 +682,8 @@ __objc_exec_class (struct objc_module *module)\n   if (uninitialized_statics)\n     objc_init_statics ();\n \n-  /* Scan the unclaimed category hash.  Attempt to attach any unclaimed\n-     categories to objects.  */\n+  /* Scan the unclaimed category hash.  Attempt to attach any\n+     unclaimed categories to objects.  */\n   for (cell = &unclaimed_categories; *cell; )\n     {\n       struct objc_category *category = (*cell)->head;\n@@ -794,8 +792,7 @@ objc_send_load (void)\n static void\n __objc_create_classes_tree (struct objc_module *module)\n {\n-  /* The runtime mutex is locked in this point */\n-\n+  /* The runtime mutex is locked at this point */\n   struct objc_symtab *symtab = module->symtab;\n   int i;\n \n@@ -812,8 +809,7 @@ __objc_create_classes_tree (struct objc_module *module)\n static void\n __objc_call_callback (struct objc_module *module)\n {\n-  /* The runtime mutex is locked in this point.  */\n-\n+  /* The runtime mutex is locked at this point.  */\n   struct objc_symtab *symtab = module->symtab;\n   int i;\n \n@@ -842,7 +838,6 @@ __objc_call_callback (struct objc_module *module)\n }\n \n /* Sanity check the version of gcc used to compile `module'.  */\n-\n static void\n init_check_module_version (struct objc_module *module)\n {\n@@ -864,7 +859,7 @@ __objc_init_class (Class class)\n   __objc_register_selectors_from_class (class);\n   __objc_register_selectors_from_class ((Class) class->class_pointer);\n \n-  /* Install the fake dispatch tables */\n+  /* Install the fake dispatch tables.  */\n   __objc_install_premature_dtable (class);\n   __objc_install_premature_dtable (class->class_pointer);\n \n@@ -888,7 +883,7 @@ __objc_init_protocol (struct objc_protocol *protocol)\n \n   if (((size_t)protocol->class_pointer) == PROTOCOL_VERSION)\n     {\n-      /* Assign class pointer */\n+      /* Assign class pointer.  */\n       protocol->class_pointer = proto_class;\n       \n       /* Register all the selectors in the protocol with the runtime.\n@@ -907,7 +902,7 @@ __objc_init_protocol (struct objc_protocol *protocol)\n \t name.  */\n       __objc_protocols_add_protocol (protocol->protocol_name, protocol);\n       \n-      /* Init super protocols */\n+      /* Init super protocols.  */\n       __objc_init_protocols (protocol->protocol_list);\n     }\n   else if (protocol->class_pointer != proto_class)\n@@ -941,7 +936,7 @@ __objc_init_protocols (struct objc_protocol_list *protos)\n     }\n \n #if 0\n-  assert (protos->next == 0);\t/* only single ones allowed */\n+  assert (protos->next == 0); /* Only single ones allowed.  */\n #endif\n \n   for (i = 0; i < protos->count; i++)\n@@ -956,11 +951,9 @@ __objc_init_protocols (struct objc_protocol_list *protos)\n static void\n __objc_class_add_protocols (Class class, struct objc_protocol_list *protos)\n {\n-  /* Well...  */\n   if (! protos)\n     return;\n \n-  /* Add it...  */\n   protos->next = class->protocols;\n   class->protocols = protos;\n }"}, {"sha": "7527df804d2505c3da8422e825b7da61eca9e10d", "filename": "libobjc/ivars.c", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/575584a982dbf3192d20b2201420721df216277d/libobjc%2Fivars.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/575584a982dbf3192d20b2201420721df216277d/libobjc%2Fivars.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fivars.c?ref=575584a982dbf3192d20b2201420721df216277d", "patch": "@@ -47,9 +47,7 @@ class_getInstanceVariable (Class class_, const char *name)\n \t\t  struct objc_ivar *ivar = &(ivars->ivar_list[i]);\n \t\t  \n \t\t  if (!strcmp (ivar->ivar_name, name))\n-\t\t    {\n-\t\t      return ivar;\n-\t\t    }\n+\t\t    return ivar;\n \t\t}\n \t    }\n \t  class_ = class_getSuperclass (class_);\n@@ -83,10 +81,8 @@ object_getIndexedIvars (id object)\n   if (object == nil)\n     return NULL;\n   else\n-    {\n-      return (void *)(((char *)object) \n-\t\t      + object->class_pointer->instance_size);\n-    }\n+    return (void *)(((char *)object) \n+\t\t    + object->class_pointer->instance_size);\n }\n \n struct objc_ivar *\n@@ -203,9 +199,7 @@ struct objc_ivar ** class_copyIvarList (Class class_, unsigned int *numberOfRetu\n       \n       /* Copy the ivars.  */\n       for (i = 0; i < count; i++)\n-\t{\n-\t  returnValue[i] = &(ivar_list->ivar_list[i]);\n-\t}\n+\treturnValue[i] = &(ivar_list->ivar_list[i]);\n       \n       returnValue[i] = NULL;\n     }\n@@ -243,9 +237,7 @@ class_addIvar (Class class_, const char * ivar_name, size_t size,\n \t  struct objc_ivar *ivar = &(ivars->ivar_list[i]);\n \t  \n \t  if (strcmp (ivar->ivar_name, ivar_name) == 0)\n-\t    {\n-\t      return NO;\n-\t    }\n+\t    return NO;\n \t}\n     }\n "}, {"sha": "b0519fc87a1a60e153937384059b93dfa49949b8", "filename": "libobjc/memory.c", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/575584a982dbf3192d20b2201420721df216277d/libobjc%2Fmemory.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/575584a982dbf3192d20b2201420721df216277d/libobjc%2Fmemory.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fmemory.c?ref=575584a982dbf3192d20b2201420721df216277d", "patch": "@@ -24,11 +24,9 @@ a copy of the GCC Runtime Library Exception along with this program;\n see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n-/*\n-  This file includes the standard functions for memory allocation and\n-  disposal.  Users should use these functions in their ObjC programs\n-  so that they work properly with garbage collectors.\n-*/\n+/* This file includes the standard functions for memory allocation and\n+   disposal.  Users should use these functions in their ObjC programs\n+   so that they work properly with garbage collectors.  */\n \n /* TODO: Turn these into macros or inline functions.  */\n \n@@ -37,8 +35,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n /* __USE_FIXED_PROTOTYPES__ used to be required to get prototypes for\n    malloc, free, etc. on some platforms.  It is unclear if we still\n-   need it, but it can't hurt.\n-*/\n+   need it, but it can't hurt.  */\n #define __USE_FIXED_PROTOTYPES__\n #include <stdlib.h>\n \n@@ -163,11 +160,8 @@ objc_valloc (size_t size)\n \n #endif\t/* !OBJC_WITH_GC */\n \n-/*\n-  Hook functions for memory allocation and disposal.  Deprecated\n-  and currently unused.\n-*/\n-\n+/* Hook functions for memory allocation and disposal.  Deprecated and\n+   currently unused.  */\n void *(*_objc_malloc) (size_t) = malloc;\n void *(*_objc_atomic_malloc) (size_t) = malloc;\n void *(*_objc_valloc) (size_t) = malloc;"}, {"sha": "911206118cbca9f43feb08825b9530d00979653c", "filename": "libobjc/objc-foreach.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/575584a982dbf3192d20b2201420721df216277d/libobjc%2Fobjc-foreach.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/575584a982dbf3192d20b2201420721df216277d/libobjc%2Fobjc-foreach.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fobjc-foreach.c?ref=575584a982dbf3192d20b2201420721df216277d", "patch": "@@ -22,11 +22,9 @@ a copy of the GCC Runtime Library Exception along with this program;\n see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n-/*\n-  This file implements objc_enumeration_mutation() and\n-  objc_set_enumeration_mutation_handler(), the two functions required\n-  to handle mutations during a fast enumeration.\n-*/\n+/* This file implements objc_enumeration_mutation() and\n+   objc_set_enumeration_mutation_handler(), the two functions required\n+   to handle mutations during a fast enumeration.  */\n #include \"objc-private/common.h\"\n #include \"objc-private/error.h\"     /* For _objc_abort() */\n #include \"objc/runtime.h\"           /* For objc_enumerationMutation() and objc_set_enumeration_mutation_handler() */"}, {"sha": "d685a359641d3859329428ff06c9e925409a7834", "filename": "libobjc/objc-sync.c", "status": "modified", "additions": 36, "deletions": 69, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/575584a982dbf3192d20b2201420721df216277d/libobjc%2Fobjc-sync.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/575584a982dbf3192d20b2201420721df216277d/libobjc%2Fobjc-sync.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fobjc-sync.c?ref=575584a982dbf3192d20b2201420721df216277d", "patch": "@@ -22,16 +22,14 @@ a copy of the GCC Runtime Library Exception along with this program;\n see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n-/*\n-  This file implements objc_sync_enter() and objc_sync_exit(), the\n-  two functions required to support @synchronized().\n+/* This file implements objc_sync_enter() and objc_sync_exit(), the\n+   two functions required to support @synchronized().\n \n-  objc_sync_enter(object) needs to get a recursive lock associated\n-  with 'object', and lock it.\n-\n-  objc_sync_exit(object) needs to get the recursive lock associated\n-  with 'object', and unlock it.\n- */\n+   objc_sync_enter(object) needs to get a recursive lock associated\n+   with 'object', and lock it.\n+   \n+   objc_sync_exit(object) needs to get the recursive lock associated\n+   with 'object', and unlock it.  */\n \n /* To avoid the overhead of continuously allocating and deallocating\n    locks, we implement a pool of locks.  When a lock is needed for an\n@@ -61,18 +59,15 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n    which is already held by the current thread without having to use\n    any protection lock or synchronization mechanism.  It can so detect\n    recursive locks/unlocks, and transform them into no-ops that\n-   require no actual locking or synchronization mechanisms at all.\n-*/\n+   require no actual locking or synchronization mechanisms at all.  */\n \n /* You can disable the thread-local cache (most likely to benchmark\n    the code with and without it) by compiling with\n-   -DSYNC_CACHE_DISABLE, or commenting out the following line.\n- */\n+   -DSYNC_CACHE_DISABLE, or commenting out the following line.  */\n /* #define SYNC_CACHE_DISABLE */\n \n /* If thread-local storage is not available, automatically disable the\n-   cache.\n-*/\n+   cache.  */\n #ifndef HAVE_TLS\n # define SYNC_CACHE_DISABLE\n #endif\n@@ -85,13 +80,11 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n /* We have 32 pools of locks, each of them protected by its own\n    protection lock.  It's tempting to increase this number to reduce\n-   contention; but in our tests it is high enough.\n- */\n+   contention; but in our tests it is high enough.  */\n #define SYNC_NUMBER_OF_POOLS 32\n \n /* Given an object, it determines which pool contains the associated\n-   lock.\n- */\n+   lock.  */\n #define SYNC_OBJECT_HASH(OBJECT) ((((size_t)OBJECT >> 8) ^ (size_t)OBJECT) & (SYNC_NUMBER_OF_POOLS - 1))\n \n /* The locks protecting each pool.  */\n@@ -126,8 +119,8 @@ typedef struct lock_node\n      because in that case you know that node->usage_count can't get to\n      zero until you release the lock.  It is valid to have usage_count\n      == 0 and object != nil; in that case, the lock is not currently\n-     being used, but is still currently associated with the object.\n-   */\n+     being used, but is still currently associated with the\n+     object.  */\n   id object;\n \n   /* This is a counter reserved for use by the thread currently\n@@ -143,21 +136,18 @@ typedef struct lock_node\n      require any synchronization with other threads, since it's\n      protected by the node->lock itself) instead of the usage_count\n      (which requires locking the pool protection lock).  And it can\n-     skip the call to objc_mutex_lock/unlock too.\n-   */\n+     skip the call to objc_mutex_lock/unlock too.  */\n   unsigned int recursive_usage_count;\n } *lock_node_ptr;\n \n \n /* The pools of locks.  Each of them is a linked list of lock_nodes.\n-   In the list we keep both unlocked and locked nodes.\n- */\n+   In the list we keep both unlocked and locked nodes.  */\n static lock_node_ptr sync_pool_array[SYNC_NUMBER_OF_POOLS];\n \n #ifndef SYNC_CACHE_DISABLE\n /* We store a cache of locks acquired by each thread in thread-local\n-   storage.\n-*/\n+   storage.  */\n static __thread lock_node_ptr *lock_cache = NULL;\n \n /* This is a conservative implementation that uses a static array of\n@@ -176,8 +166,7 @@ static __thread lock_node_ptr *lock_cache = NULL;\n    first 8 get the speed benefits of the cache, but the cache remains\n    always small, fast and predictable.\n  \n-   SYNC_CACHE_SIZE is the size of the lock cache for each thread.\n- */\n+   SYNC_CACHE_SIZE is the size of the lock cache for each thread.  */\n #define SYNC_CACHE_SIZE 8\n #endif /* SYNC_CACHE_DISABLE */\n \n@@ -217,23 +206,20 @@ objc_sync_enter (id object)\n   lock_node_ptr unused_node;\n \n   if (object == nil)\n-    {\n-      return OBJC_SYNC_SUCCESS;\n-    }\n+    return OBJC_SYNC_SUCCESS;\n \n #ifndef SYNC_CACHE_DISABLE\n   if (lock_cache == NULL)\n     {\n       /* Note that this calloc only happen only once per thread, the\n-\t very first time a thread does a objc_sync_enter().\n-       */\n+\t very first time a thread does a objc_sync_enter().  */\n       lock_cache = objc_calloc (SYNC_CACHE_SIZE, sizeof (lock_node_ptr));\n     }\n \n   /* Check the cache to see if we have a record of having already\n      locked the lock corresponding to this object.  While doing so,\n-     keep track of the first free cache node in case we need it later.\n-   */ \n+     keep track of the first free cache node in case we need it\n+     later.  */ \n   node = NULL;\n   free_cache_slot = -1;\n \n@@ -246,9 +232,7 @@ objc_sync_enter (id object)\n \tif (locked_node == NULL)\n \t  {\n \t    if (free_cache_slot == -1)\n-\t      {\n-\t\tfree_cache_slot = i;\n-\t      }\n+\t      free_cache_slot = i;\n \t  }\n \telse if (locked_node->object == object)\n \t  {\n@@ -261,26 +245,22 @@ objc_sync_enter (id object)\n   if (node != NULL)\n     {\n       /* We found the lock.  Increase recursive_usage_count, which is\n-\t protected by node->lock, which we already hold.\n-       */\n+\t protected by node->lock, which we already hold.  */\n       node->recursive_usage_count++;\n       \n       /* There is no need to actually lock anything, since we already\n \t hold the lock.  Correspondingly, objc_sync_exit() will just\n-\t decrease recursive_usage_count and do nothing to unlock.\n-       */\n+\t decrease recursive_usage_count and do nothing to unlock.  */\n       return OBJC_SYNC_SUCCESS;\n     }\n #endif /* SYNC_CACHE_DISABLE */\n \n   /* The following is the standard lookup for the lock in the standard\n-     pool lock.  It requires a pool protection lock.\n-   */\n+     pool lock.  It requires a pool protection lock.  */\n   hash = SYNC_OBJECT_HASH(object);\n \n   /* Search for an existing lock for 'object'.  While searching, make\n-     note of any unused lock if we find any.\n-   */\n+     note of any unused lock if we find any.  */\n   unused_node = NULL;\n \n   objc_mutex_lock (sync_pool_protection_locks[hash]);\n@@ -298,9 +278,7 @@ objc_sync_enter (id object)\n #ifndef SYNC_CACHE_DISABLE\n \t  /* Put it in the cache.  */\n \t  if (free_cache_slot != -1)\n-\t    {\n-\t      lock_cache[free_cache_slot] = node;\n-\t    }\n+\t    lock_cache[free_cache_slot] = node;\n #endif\n \n \t  /* Lock it.  */\n@@ -329,9 +307,7 @@ objc_sync_enter (id object)\n \n #ifndef SYNC_CACHE_DISABLE\n       if (free_cache_slot != -1)\n-\t{\n-\t  lock_cache[free_cache_slot] = unused_node;\n-\t}\n+\tlock_cache[free_cache_slot] = unused_node;\n #endif\n \n       objc_mutex_lock (unused_node->lock);\n@@ -357,9 +333,7 @@ objc_sync_enter (id object)\n \n #ifndef SYNC_CACHE_DISABLE\n       if (free_cache_slot != -1)\n-\t{\n-\t  lock_cache[free_cache_slot] = new_node;\n-\t}\n+\tlock_cache[free_cache_slot] = new_node;\n #endif\n \n       objc_mutex_lock (new_node->lock);\n@@ -375,9 +349,7 @@ objc_sync_exit (id object)\n   lock_node_ptr node;\n \n   if (object == nil)\n-    {\n-      return OBJC_SYNC_SUCCESS;\n-    }\n+    return OBJC_SYNC_SUCCESS;\n   \n #ifndef SYNC_CACHE_DISABLE\n   if (lock_cache != NULL)\n@@ -399,7 +371,6 @@ objc_sync_exit (id object)\n       /* Note that, if a node was found in the cache, the variable i\n \t now holds the index where it was found, which will be used to\n \t remove it from the cache.  */\n-\n       if (node != NULL)\n \t{\n \t  if (node->recursive_usage_count > 0)\n@@ -413,8 +384,8 @@ objc_sync_exit (id object)\n \t      hash = SYNC_OBJECT_HASH(object);\n \t      \n \t      /* TODO: If we had atomic increase/decrease operations\n-\t\t with memory barriers, we could avoid the lock here!\n-\t      */\n+\t\t with memory barriers, we could avoid the lock\n+\t\t here!  */\n \t      objc_mutex_lock (sync_pool_protection_locks[hash]);\n \t      node->usage_count--;\n \t      /* Normally, we do not reset object to nil here.  We'll\n@@ -430,8 +401,7 @@ objc_sync_exit (id object)\n \t\t object from being released.  In that case, we remove\n \t\t it (TODO: maybe we should avoid using the garbage\n \t\t collector at all ?  Nothing is ever deallocated in\n-\t\t this file).\n-\t      */\n+\t\t this file).  */\n #if OBJC_WITH_GC\n \t      node->object = nil;\n #endif\n@@ -442,8 +412,7 @@ objc_sync_exit (id object)\n \t\t objc_mutex_unlock (node->lock), the pool is unlocked\n \t\t so other threads may allocate this same lock to\n \t\t another object (!).  This is not a problem, but it is\n-\t\t curious.\n-\t      */\n+\t\t curious.  */\n \t      objc_mutex_unlock (node->lock);\n \t      \n \t      /* Remove the node from the cache.  */\n@@ -476,9 +445,7 @@ objc_sync_exit (id object)\n \t  objc_mutex_unlock (node->lock);\n \n \t  /* No need to remove the node from the cache, since it\n-\t     wasn't found in the cache when we looked for it!\n-\t   */\n-\n+\t     wasn't found in the cache when we looked for it!  */\n \t  return OBJC_SYNC_SUCCESS;\n \t}\n       "}, {"sha": "75eea2d5a058fc4953b362184380fe010444e7db", "filename": "libobjc/objects.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/575584a982dbf3192d20b2201420721df216277d/libobjc%2Fobjects.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/575584a982dbf3192d20b2201420721df216277d/libobjc%2Fobjects.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fobjects.c?ref=575584a982dbf3192d20b2201420721df216277d", "patch": "@@ -123,11 +123,8 @@ object_setClass (id object, Class class_)\n     }\n }\n \n-/*\n-  Hook functions for memory allocation and disposal.  Deprecated\n-  and currently unused.\n-*/\n-\n+/* Hook functions for memory allocation and disposal.  Deprecated and\n+   currently unused.  */\n id (*_objc_object_alloc) (Class)   = 0;\n id (*_objc_object_dispose) (id)    = 0;\n id (*_objc_object_copy) (id)       = 0;"}, {"sha": "cc694c4a72e3caef466a5bdd5e35b85e1e636d5e", "filename": "libobjc/protocols.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/575584a982dbf3192d20b2201420721df216277d/libobjc%2Fprotocols.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/575584a982dbf3192d20b2201420721df216277d/libobjc%2Fprotocols.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fprotocols.c?ref=575584a982dbf3192d20b2201420721df216277d", "patch": "@@ -69,9 +69,7 @@ __objc_protocols_add_protocol (const char *name, Protocol *object)\n      Objective-C programs while trying to catch a problem that has\n      never been seen in practice, so we don't do it.  */\n   if (! objc_hash_is_key_in_hash (__protocols_hashtable, name))\n-    {\n-      objc_hash_add (&__protocols_hashtable, name, object);\n-    }\n+    objc_hash_add (&__protocols_hashtable, name, object);\n \n   objc_mutex_unlock (__protocols_hashtable_lock);\n }"}, {"sha": "96f1497b9c2a9583361531bde6ea146060b23007", "filename": "libobjc/sarray.c", "status": "modified", "additions": 149, "deletions": 147, "changes": 296, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/575584a982dbf3192d20b2201420721df216277d/libobjc%2Fsarray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/575584a982dbf3192d20b2201420721df216277d/libobjc%2Fsarray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fsarray.c?ref=575584a982dbf3192d20b2201420721df216277d", "patch": "@@ -59,38 +59,41 @@ sarray_remove_garbage (void)\n   vp = first_free_data;\n   first_free_data = NULL;\n \n-  while (vp) {\n-    np = *vp;\n-    objc_free (vp);\n-    vp = np;\n-  }\n+  while (vp)\n+    {\n+      np = *vp;\n+      objc_free (vp);\n+      vp = np;\n+    }\n   \n   objc_mutex_unlock (__objc_runtime_mutex);\n }\n \n-/* Free a block of dynamically allocated memory.  If we are in multi-threaded\n-   mode, it is ok to free it.  If not, we add it to the garbage heap to be\n-   freed later. */\n-\n+/* Free a block of dynamically allocated memory.  If we are in\n+   multi-threaded mode, it is ok to free it.  If not, we add it to the\n+   garbage heap to be freed later. */\n static void\n sarray_free_garbage (void *vp)\n {\n   objc_mutex_lock (__objc_runtime_mutex);\n   \n-  if (__objc_runtime_threads_alive == 1) {\n-    objc_free (vp);\n-    if (first_free_data)\n-      sarray_remove_garbage ();\n-  }\n-  else {\n-    *(void **)vp = first_free_data;\n-    first_free_data = vp;\n-  }\n-      \n+  if (__objc_runtime_threads_alive == 1)\n+    {\n+      objc_free (vp);\n+      if (first_free_data)\n+\tsarray_remove_garbage ();\n+    }\n+  else\n+    {\n+      *(void **)vp = first_free_data;\n+      first_free_data = vp;\n+    }\n+\n   objc_mutex_unlock (__objc_runtime_mutex);\n }\n \n-/* sarray_at_put : copies data in such a way as to be thread reader safe. */\n+/* sarray_at_put copies data in such a way as to be thread reader\n+   safe.  */\n void\n sarray_at_put (struct sarray *array, sidx index, void *element)\n {\n@@ -134,63 +137,63 @@ sarray_at_put (struct sarray *array, sidx index, void *element)\n #endif\n   \n   if ((*the_bucket)->elems[eoffset] == element)\n-    return;\t\t/* great! we just avoided a lazy copy */\n+    return;\t\t/* Great! we just avoided a lazy copy.  */\n \n #ifdef OBJC_SPARSE3\n \n-  /* First, perform lazy copy/allocation of index if needed */\n-\n-  if ((*the_index) == array->empty_index) {\n-\n-    /* The index was previously empty, allocate a new */\n-    new_index = (struct sindex *) objc_malloc (sizeof (struct sindex));\n-    memcpy (new_index, array->empty_index, sizeof (struct sindex));\n-    new_index->version.version = array->version.version;\n-    *the_index = new_index;                     /* Prepared for install. */\n-    the_bucket = &((*the_index)->buckets[boffset]);\n-    \n-    nindices += 1;\n-  } else if ((*the_index)->version.version != array->version.version) {\n-\n-    /* This index must be lazy copied */\n-    struct sindex *old_index = *the_index;\n-    new_index = (struct sindex *) objc_malloc (sizeof (struct sindex));\n-    memcpy (new_index, old_index, sizeof (struct sindex));\n-    new_index->version.version = array->version.version;\n-    *the_index = new_index;                     /* Prepared for install. */\n-    the_bucket = &((*the_index)->buckets[boffset]);\n-    \n-    nindices += 1;\n-  }\n+  /* First, perform lazy copy/allocation of index if needed.  */\n \n+  if ((*the_index) == array->empty_index)\n+    {\n+      /* The index was previously empty, allocate a new.  */\n+      new_index = (struct sindex *) objc_malloc (sizeof (struct sindex));\n+      memcpy (new_index, array->empty_index, sizeof (struct sindex));\n+      new_index->version.version = array->version.version;\n+      *the_index = new_index;                     /* Prepared for install. */\n+      the_bucket = &((*the_index)->buckets[boffset]);\n+      \n+      nindices += 1;\n+    }\n+  else if ((*the_index)->version.version != array->version.version)\n+    {\n+      /* This index must be lazy copied.  */\n+      struct sindex *old_index = *the_index;\n+      new_index = (struct sindex *) objc_malloc (sizeof (struct sindex));\n+      memcpy (new_index, old_index, sizeof (struct sindex));\n+      new_index->version.version = array->version.version;\n+      *the_index = new_index;                     /* Prepared for install. */\n+      the_bucket = &((*the_index)->buckets[boffset]);\n+      \n+      nindices += 1;\n+    }\n+  \n #endif /* OBJC_SPARSE3 */\n-\n-  /* next, perform lazy allocation/copy of the bucket if needed */\n-\n-  if ((*the_bucket) == array->empty_bucket) {\n-\n-    /* The bucket was previously empty (or something like that), */\n-    /* allocate a new.  This is the effect of `lazy' allocation */  \n-    new_bucket = (struct sbucket *) objc_malloc (sizeof (struct sbucket));\n-    memcpy ((void *) new_bucket, (const void *) array->empty_bucket, \n-\t    sizeof (struct sbucket));\n-    new_bucket->version.version = array->version.version;\n-    *the_bucket = new_bucket;                   /* Prepared for install. */\n-    \n-    nbuckets += 1;\n-\n-  } else if ((*the_bucket)->version.version != array->version.version) {\n-\n-    /* Perform lazy copy. */\n-    struct sbucket *old_bucket = *the_bucket;\n-    new_bucket = (struct sbucket *) objc_malloc (sizeof (struct sbucket));\n-    memcpy (new_bucket, old_bucket, sizeof (struct sbucket));\n-    new_bucket->version.version = array->version.version;\n-    *the_bucket = new_bucket;                   /* Prepared for install. */\n-    \n-    nbuckets += 1;\n-\n-  }\n+  \n+  /* Next, perform lazy allocation/copy of the bucket if needed.  */\n+  if ((*the_bucket) == array->empty_bucket)\n+    {\n+      /* The bucket was previously empty (or something like that),\n+\t allocate a new.  This is the effect of `lazy' allocation.  */  \n+      new_bucket = (struct sbucket *) objc_malloc (sizeof (struct sbucket));\n+      memcpy ((void *) new_bucket, (const void *) array->empty_bucket, \n+\t      sizeof (struct sbucket));\n+      new_bucket->version.version = array->version.version;\n+      *the_bucket = new_bucket;                   /* Prepared for install. */\n+      \n+      nbuckets += 1;\n+      \n+    }\n+  else if ((*the_bucket)->version.version != array->version.version)\n+    {\n+      /* Perform lazy copy.  */\n+      struct sbucket *old_bucket = *the_bucket;\n+      new_bucket = (struct sbucket *) objc_malloc (sizeof (struct sbucket));\n+      memcpy (new_bucket, old_bucket, sizeof (struct sbucket));\n+      new_bucket->version.version = array->version.version;\n+      *the_bucket = new_bucket;                   /* Prepared for install. */\n+      \n+      nbuckets += 1;\n+    }\n   (*the_bucket)->elems[eoffset] = element;\n }\n \n@@ -217,16 +220,16 @@ sarray_new (int size, void *default_element)\n \n   assert (size > 0);\n \n-  /* Allocate core array */\n+  /* Allocate core array.  */\n   arr = (struct sarray *) objc_malloc (sizeof (struct sarray));\n   arr->version.version = 0;\n   \n-  /* Initialize members */\n+  /* Initialize members.  */\n #ifdef OBJC_SPARSE3\n   arr->capacity = num_indices*INDEX_CAPACITY;\n   new_indices = (struct sindex **) \n     objc_malloc (sizeof (struct sindex *) * num_indices);\n-\n+  \n   arr->empty_index = (struct sindex *) objc_malloc (sizeof (struct sindex));\n   arr->empty_index->version.version = 0;\n   \n@@ -279,10 +282,9 @@ sarray_new (int size, void *default_element)\n }\n \f\n \n-/* Reallocate the sparse array to hold `newsize' entries\n-   Note: We really allocate and then free.  We have to do this to ensure that\n-   any concurrent readers notice the update. */\n-\n+/* Reallocate the sparse array to hold `newsize' entries Note: We\n+   really allocate and then free.  We have to do this to ensure that\n+   any concurrent readers notice the update.  */\n void \n sarray_realloc (struct sarray *array, int newsize)\n {\n@@ -308,31 +310,29 @@ sarray_realloc (struct sarray *array, int newsize)\n \n   assert (newsize > 0);\n \n-  /* The size is the same, just ignore the request */\n+  /* The size is the same, just ignore the request.  */\n   if (rounded_size <= array->capacity)\n     return;\n \n   assert (array->ref_count == 1);\t/* stop if lazy copied... */\n \n-  /* We are asked to extend the array -- allocate new bucket table, */\n-  /* and insert empty_bucket in newly allocated places. */\n+  /* We are asked to extend the array -- allocate new bucket table,\n+     and insert empty_bucket in newly allocated places.  */\n   if (rounded_size > array->capacity) \n     {\n-\n #ifdef OBJC_SPARSE3\n       new_max_index += 4;\n       rounded_size = (new_max_index + 1) * INDEX_CAPACITY;\n-      \n #else /* OBJC_SPARSE2 */\n       new_max_index += 4;\n       rounded_size = (new_max_index + 1) * BUCKET_SIZE;\n #endif\n       \n-      /* update capacity */\n+      /* Update capacity.  */\n       array->capacity = rounded_size;\n \n #ifdef OBJC_SPARSE3\n-      /* alloc to force re-read by any concurrent readers. */\n+      /* Alloc to force re-read by any concurrent readers.  */\n       old_indices = array->indices;\n       new_indices = (struct sindex **)\n \tobjc_malloc ((new_max_index + 1) * sizeof (struct sindex *));\n@@ -342,34 +342,35 @@ sarray_realloc (struct sarray *array, int newsize)\n \tobjc_malloc ((new_max_index + 1) * sizeof (struct sbucket *));\n #endif\n \n-      /* copy buckets below old_max_index (they are still valid) */\n-      for (counter = 0; counter <= old_max_index; counter++ ) {\n+      /* Copy buckets below old_max_index (they are still valid).  */\n+      for (counter = 0; counter <= old_max_index; counter++ )\n+\t{\n #ifdef OBJC_SPARSE3\n-\tnew_indices[counter] = old_indices[counter];\n+\t  new_indices[counter] = old_indices[counter];\n #else /* OBJC_SPARSE2 */\n-\tnew_buckets[counter] = old_buckets[counter];\n+\t  new_buckets[counter] = old_buckets[counter];\n #endif\n-      }\n+\t}\n \n #ifdef OBJC_SPARSE3\n-      /* reset entries above old_max_index to empty_bucket */\n+      /* Reset entries above old_max_index to empty_bucket.  */\n       for (counter = old_max_index + 1; counter <= new_max_index; counter++)\n \tnew_indices[counter] = array->empty_index;\n #else /* OBJC_SPARSE2 */\n-      /* reset entries above old_max_index to empty_bucket */\n+      /* Reset entries above old_max_index to empty_bucket.  */\n       for (counter = old_max_index + 1; counter <= new_max_index; counter++)\n \tnew_buckets[counter] = array->empty_bucket;\n #endif\n       \n #ifdef OBJC_SPARSE3\n-      /* install the new indices */\n+      /* Install the new indices.  */\n       array->indices = new_indices;\n #else /* OBJC_SPARSE2 */\n       array->buckets = new_buckets;\n #endif\n \n #ifdef OBJC_SPARSE3\n-      /* free the old indices */\n+      /* Free the old indices.  */\n       sarray_free_garbage (old_indices);\n #else /* OBJC_SPARSE2 */\n       sarray_free_garbage (old_buckets);\n@@ -382,7 +383,6 @@ sarray_realloc (struct sarray *array, int newsize)\n \f\n \n /* Free a sparse array allocated with sarray_new */\n-\n void \n sarray_free (struct sarray *array) {\n #ifdef OBJC_SPARSE3\n@@ -405,75 +405,77 @@ sarray_free (struct sarray *array) {\n   old_buckets = array->buckets;\n #endif\n \n-  /* Free all entries that do not point to empty_bucket */\n-  for (counter = 0; counter <= old_max_index; counter++ ) {\n+  /* Free all entries that do not point to empty_bucket.  */\n+  for (counter = 0; counter <= old_max_index; counter++ )\n+    {\n #ifdef OBJC_SPARSE3\n-    struct sindex *idx = old_indices[counter];\n-    if ((idx != array->empty_index) &&\n-       (idx->version.version == array->version.version)) {\n-      int c2; \n-      for (c2 = 0; c2 < INDEX_SIZE; c2++) {\n-\tstruct sbucket *bkt = idx->buckets[c2];\n-\tif ((bkt != array->empty_bucket) &&\n-\t   (bkt->version.version == array->version.version))\n-\t  {\n-\t    sarray_free_garbage (bkt);\n-\t    nbuckets -= 1;\n-\t  }\n-      }\n-      sarray_free_garbage (idx);\n-      nindices -= 1;\n-    }\n+      struct sindex *idx = old_indices[counter];\n+      if ((idx != array->empty_index)\n+\t  && (idx->version.version == array->version.version))\n+\t{\n+\t  int c2; \n+\t  for (c2 = 0; c2 < INDEX_SIZE; c2++)\n+\t    {\n+\t      struct sbucket *bkt = idx->buckets[c2];\n+\t      if ((bkt != array->empty_bucket)\n+\t\t  && (bkt->version.version == array->version.version))\n+\t\t{\n+\t\t  sarray_free_garbage (bkt);\n+\t\t  nbuckets -= 1;\n+\t\t}\n+\t    }\n+\t  sarray_free_garbage (idx);\n+\t  nindices -= 1;\n+\t}\n #else /* OBJC_SPARSE2 */\n-    struct sbucket *bkt = old_buckets[counter];\n-    if ((bkt != array->empty_bucket) &&\n-\t(bkt->version.version == array->version.version))\n-      {\n-\tsarray_free_garbage (bkt);\n-\tnbuckets -= 1;\n-      }\n+      struct sbucket *bkt = old_buckets[counter];\n+      if ((bkt != array->empty_bucket)\n+\t  && (bkt->version.version == array->version.version))\n+\t{\n+\t  sarray_free_garbage (bkt);\n+\t  nbuckets -= 1;\n+\t}\n #endif\n-  }\n-\t\n+    }\n+  \n #ifdef OBJC_SPARSE3  \n-  /* free empty_index */\n-  if (array->empty_index->version.version == array->version.version) {\n-    sarray_free_garbage (array->empty_index);\n-    nindices -= 1;\n-  }\n+  /* Free empty_index.  */\n+  if (array->empty_index->version.version == array->version.version)\n+    {\n+      sarray_free_garbage (array->empty_index);\n+      nindices -= 1;\n+    }\n #endif\n \n-  /* free empty_bucket */\n-  if (array->empty_bucket->version.version == array->version.version) {\n-    sarray_free_garbage (array->empty_bucket);\n-    nbuckets -= 1;\n-  }\n+  /* Free empty_bucket.  */\n+  if (array->empty_bucket->version.version == array->version.version)\n+    {\n+      sarray_free_garbage (array->empty_bucket);\n+      nbuckets -= 1;\n+    }\n   idxsize -= (old_max_index + 1);\n   narrays -= 1;\n-\n+  \n #ifdef OBJC_SPARSE3\n-  /* free bucket table */\n+  /* Free bucket table.  */\n   sarray_free_garbage (array->indices);\n-\n #else\n-  /* free bucket table */\n+  /* Free bucket table.  */\n   sarray_free_garbage (array->buckets);\n-\n #endif\n   \n   /* If this is a copy of another array, we free it (which might just\n-   * decrement its reference count so it will be freed when no longer in use).\n-   */\n+     decrement its reference count so it will be freed when no longer\n+     in use).  */\n   if (array->is_copy_of)\n     sarray_free (array->is_copy_of);\n \n-  /* free array */\n+  /* Free array.  */\n   sarray_free_garbage (array);\n }\n \n-/* This is a lazy copy.  Only the core of the structure is actually */\n-/* copied.   */\n-\n+/* This is a lazy copy.  Only the core of the structure is actually\n+   copied.  */\n struct sarray *\n sarray_lazy_copy (struct sarray *oarr)\n {\n@@ -487,7 +489,7 @@ sarray_lazy_copy (struct sarray *oarr)\n   struct sbucket **new_buckets;\n #endif\n \n-  /* Allocate core array */\n+  /* Allocate core array.  */\n   arr = (struct sarray *) objc_malloc (sizeof (struct sarray)); /* !!! */\n   arr->version.version = oarr->version.version + 1;\n #ifdef OBJC_SPARSE3\n@@ -500,13 +502,13 @@ sarray_lazy_copy (struct sarray *oarr)\n   arr->capacity = oarr->capacity;\n   \n #ifdef OBJC_SPARSE3\n-  /* Copy bucket table */\n+  /* Copy bucket table.  */\n   new_indices = (struct sindex **) \n     objc_malloc (sizeof (struct sindex *) * num_indices);\n   memcpy (new_indices, oarr->indices, sizeof (struct sindex *) * num_indices);\n   arr->indices = new_indices;\n #else \n-  /* Copy bucket table */\n+  /* Copy bucket table.  */\n   new_buckets = (struct sbucket **) \n     objc_malloc (sizeof (struct sbucket *) * num_indices);\n   memcpy (new_buckets, oarr->buckets, sizeof (struct sbucket *) * num_indices);"}, {"sha": "b1fde3db920bdb55ffd71a93bfc73a4b25b663d0", "filename": "libobjc/thr.c", "status": "modified", "additions": 165, "deletions": 211, "changes": 376, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/575584a982dbf3192d20b2201420721df216277d/libobjc%2Fthr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/575584a982dbf3192d20b2201420721df216277d/libobjc%2Fthr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fthr.c?ref=575584a982dbf3192d20b2201420721df216277d", "patch": "@@ -47,51 +47,46 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n /* Global exit status. */\n int __objc_thread_exit_status = 0;\n \n-/* Flag which lets us know if we ever became multi threaded */\n+/* Flag which lets us know if we ever became multi threaded.  */\n int __objc_is_multi_threaded = 0;\n \n-/* The hook function called when the runtime becomes multi threaded */\n+/* The hook function called when the runtime becomes multi\n+   threaded.  */\n objc_thread_callback _objc_became_multi_threaded = NULL;\n \n-/*\n-  Use this to set the hook function that will be called when the \n-  runtime initially becomes multi threaded.\n-  The hook function is only called once, meaning only when the \n-  2nd thread is spawned, not for each and every thread.\n+/* Use this to set the hook function that will be called when the\n+   runtime initially becomes multi threaded.  The hook function is\n+   only called once, meaning only when the 2nd thread is spawned, not\n+   for each and every thread.\n \n-  It returns the previous hook function or NULL if there is none.\n+   It returns the previous hook function or NULL if there is none.\n \n-  A program outside of the runtime could set this to some function so\n-  it can be informed; for example, the GNUstep Base Library sets it \n-  so it can implement the NSBecomingMultiThreaded notification.\n-  */\n+   A program outside of the runtime could set this to some function so\n+   it can be informed; for example, the GNUstep Base Library sets it\n+   so it can implement the NSBecomingMultiThreaded notification.  */\n objc_thread_callback objc_set_thread_callback (objc_thread_callback func)\n {\n   objc_thread_callback temp = _objc_became_multi_threaded;\n   _objc_became_multi_threaded = func;\n   return temp;\n }\n \n-/*\n-  Private functions\n+/* Private functions.\n+   \n+   These functions are utilized by the runtime, but they are not\n+   considered part of the public interface.  */\n \n-  These functions are utilized by the frontend, but they are not\n-  considered part of the public interface.\n-  */\n-\n-/* Initialize the threads subsystem. */\n+/* Initialize the threads subsystem.  */\n int\n __objc_init_thread_system(void)\n {\n   return __gthread_objc_init_thread_system ();\n }\n \n-/*\n-  First function called in a thread, starts everything else.\n+/* First function called in a thread, starts everything else.\n \n-  This function is passed to the backend by objc_thread_detach\n-  as the starting function for a new thread.\n- */\n+   This function is passed to the backend by objc_thread_detach as the\n+   starting function for a new thread.  */\n struct __objc_thread_start_state\n {\n   SEL selector;\n@@ -103,459 +98,419 @@ static void __attribute__((noreturn))\n __objc_thread_detach_function (struct __objc_thread_start_state *istate) \n {\n   /* Valid state? */\n-  if (istate) {\n-    id (*imp) (id, SEL, id);\n-    SEL selector = istate->selector;\n-    id object   = istate->object;\n-    id argument = istate->argument;\n-\n-    /* Don't need anymore so free it */\n-    objc_free (istate);\n-\n-    /* Clear out the thread local storage */\n-    objc_thread_set_data (NULL);\n-\n-    /* Check to see if we just became multi threaded */\n-    if (! __objc_is_multi_threaded)\n-      {\n-\t__objc_is_multi_threaded = 1;\n-\n-\t/* Call the hook function */\n-\tif (_objc_became_multi_threaded != NULL)\n-\t  (*_objc_became_multi_threaded) ();\n-      }\n-\n-    /* Call the method */\n-    if ((imp = (id (*) (id, SEL, id))objc_msg_lookup (object, selector)))\n+  if (istate)\n+    {\n+      id (*imp) (id, SEL, id);\n+      SEL selector = istate->selector;\n+      id object   = istate->object;\n+      id argument = istate->argument;\n+      \n+      /* Don't need anymore so free it.  */\n+      objc_free (istate);\n+\n+      /* Clear out the thread local storage.  */\n+      objc_thread_set_data (NULL);\n+      \n+      /* Check to see if we just became multi threaded. */\n+      if (! __objc_is_multi_threaded)\n+\t{\n+\t  __objc_is_multi_threaded = 1;\n+\t  \n+\t  /* Call the hook function.  */\n+\t  if (_objc_became_multi_threaded != NULL)\n+\t    (*_objc_became_multi_threaded) ();\n+\t}\n+      \n+      /* Call the method.  */\n+      if ((imp = (id (*) (id, SEL, id))objc_msg_lookup (object, selector)))\n \t(*imp) (object, selector, argument);\n-    else\n-      {\n-\t/* FIXME: Should we abort here ? */\n-\t_objc_abort (\"objc_thread_detach called with bad selector.\\n\");\n-      }\n-  }\n+      else\n+\t{\n+\t  /* FIXME: Should we abort here ? */\n+\t  _objc_abort (\"objc_thread_detach called with bad selector.\\n\");\n+\t}\n+    }\n   else\n     {\n       /* FIXME: Should we abort here ? */\n       _objc_abort (\"objc_thread_detach called with NULL state.\\n\");\n     }\n-\n-  /* Exit the thread */\n+  \n+  /* Exit the thread.  */\n   objc_thread_exit ();\n   \n   /* Make sure compiler detects no return.  */\n   __builtin_trap ();\n }\n \n-/*\n-  Frontend functions\n-\n-  These functions constitute the public interface to the Objective-C thread\n-  and mutex functionality.\n-  */\n+/* Public functions.\n \n-/* Frontend thread functions */\n+   These functions constitute the public interface to the Objective-C\n+   thread and mutex functionality.  */\n \n-/*\n-  Detach a new thread of execution and return its id.  Returns NULL if fails.\n-  Thread is started by sending message with selector to object.  Message\n-  takes a single argument.\n-  */\n+/* Detach a new thread of execution and return its id.  Returns NULL\n+   if fails.  Thread is started by sending message with selector to\n+   object.  Message takes a single argument.  */\n objc_thread_t\n objc_thread_detach (SEL selector, id object, id argument)\n {\n   struct __objc_thread_start_state *istate;\n   objc_thread_t        thread_id = NULL;\n \n-  /* Allocate the state structure */\n-  if (! (istate = (struct __objc_thread_start_state *)\n-\t objc_malloc (sizeof (*istate))))\n+  /* Allocate the state structure.  */\n+  if (!(istate = (struct __objc_thread_start_state *)objc_malloc\n+\t(sizeof (*istate))))\n     return NULL;\n-\n-  /* Initialize the state structure */\n+  \n+  /* Initialize the state structure.  */\n   istate->selector = selector;\n   istate->object = object;\n   istate->argument = argument;\n \n-  /* lock access */\n+  /* Lock access.  */\n   objc_mutex_lock (__objc_runtime_mutex);\n \n-  /* Call the backend to spawn the thread */\n+  /* Call the backend to spawn the thread.  */\n   if ((thread_id = __gthread_objc_thread_detach ((void *)__objc_thread_detach_function,\n \t\t\t\t\t\t istate)) == NULL)\n     {\n-      /* failed! */\n+      /* Failed!  */\n       objc_mutex_unlock (__objc_runtime_mutex);\n       objc_free (istate);\n       return NULL;\n     }\n \n-  /* Increment our thread counter */\n+  /* Increment our thread counter.  */\n   __objc_runtime_threads_alive++;\n   objc_mutex_unlock (__objc_runtime_mutex);\n \n   return thread_id;\n }\n \n-/* Set the current thread's priority. */\n+/* Set the current thread's priority.  */\n int\n objc_thread_set_priority (int priority)\n {\n-  /* Call the backend */\n   return __gthread_objc_thread_set_priority (priority);\n }\n \n-/* Return the current thread's priority. */\n+/* Return the current thread's priority.  */\n int\n objc_thread_get_priority (void)\n {\n-  /* Call the backend */\n   return __gthread_objc_thread_get_priority ();\n }\n \n-/*\n-  Yield our process time to another thread.  Any BUSY waiting that is done\n-  by a thread should use this function to make sure that other threads can\n-  make progress even on a lazy uniprocessor system.\n-  */\n+/* Yield our process time to another thread.  Any BUSY waiting that is\n+   done by a thread should use this function to make sure that other\n+   threads can make progress even on a lazy uniprocessor system.  */\n void\n objc_thread_yield (void)\n {\n-  /* Call the backend */\n   __gthread_objc_thread_yield ();\n }\n \n-/*\n-  Terminate the current tread.  Doesn't return.\n-  Actually, if it failed returns -1.\n-  */\n+/* Terminate the current tread.  Doesn't return.  Actually, if it\n+   failed returns -1.  */\n int\n objc_thread_exit (void)\n {\n-  /* Decrement our counter of the number of threads alive */\n+  /* Decrement our counter of the number of threads alive.  */\n   objc_mutex_lock (__objc_runtime_mutex);\n   __objc_runtime_threads_alive--;\n   objc_mutex_unlock (__objc_runtime_mutex);\n \n-  /* Call the backend to terminate the thread */\n+  /* Call the backend to terminate the thread.  */\n   return __gthread_objc_thread_exit ();\n }\n \n-/*\n-  Returns an integer value which uniquely describes a thread.  Must not be\n-  NULL which is reserved as a marker for \"no thread\".\n-  */\n+/* Returns an integer value which uniquely describes a thread.  Must\n+   not be NULL which is reserved as a marker for \"no thread\".  */\n objc_thread_t\n objc_thread_id (void)\n {\n-  /* Call the backend */\n   return __gthread_objc_thread_id ();\n }\n \n-/*\n-  Sets the thread's local storage pointer. \n-  Returns 0 if successful or -1 if failed.\n-  */\n+/* Sets the thread's local storage pointer.  Returns 0 if successful\n+   or -1 if failed.  */\n int\n objc_thread_set_data (void *value)\n {\n-  /* Call the backend */\n   return __gthread_objc_thread_set_data (value);\n }\n \n-/*\n-  Returns the thread's local storage pointer.  Returns NULL on failure.\n-  */\n+/* Returns the thread's local storage pointer.  Returns NULL on\n+   failure.  */\n void *\n objc_thread_get_data (void)\n {\n-  /* Call the backend */\n   return __gthread_objc_thread_get_data ();\n }\n \n-/* Frontend mutex functions */\n+/* Public mutex functions */\n \n-/*\n-  Allocate a mutex.  Return the mutex pointer if successful or NULL if the\n-  allocation failed for any reason.\n-  */\n+/* Allocate a mutex.  Return the mutex pointer if successful or NULL\n+   if the allocation failed for any reason.  */\n objc_mutex_t\n objc_mutex_allocate (void)\n {\n   objc_mutex_t mutex;\n \n-  /* Allocate the mutex structure */\n+  /* Allocate the mutex structure.  */\n   if (! (mutex = (objc_mutex_t)objc_malloc (sizeof (struct objc_mutex))))\n     return NULL;\n \n-  /* Call backend to create the mutex */\n+  /* Call backend to create the mutex.  */\n   if (__gthread_objc_mutex_allocate (mutex))\n     {\n-      /* failed! */\n+      /* Failed!  */\n       objc_free (mutex);\n       return NULL;\n     }\n \n-  /* Initialize mutex */\n+  /* Initialize mutex.  */\n   mutex->owner = NULL;\n   mutex->depth = 0;\n   return mutex;\n }\n \n-/*\n-  Deallocate a mutex.  Note that this includes an implicit mutex_lock to\n-  insure that no one else is using the lock.  It is legal to deallocate\n-  a lock if we have a lock on it, but illegal to deallocate a lock held\n-  by anyone else.\n-  Returns the number of locks on the thread.  (1 for deallocate).\n-  */\n+/* Deallocate a mutex.  Note that this includes an implicit mutex_lock\n+   to insure that no one else is using the lock.  It is legal to\n+   deallocate a lock if we have a lock on it, but illegal to\n+   deallocate a lock held by anyone else.  Returns the number of locks\n+   on the thread.  (1 for deallocate).  */\n int\n objc_mutex_deallocate (objc_mutex_t mutex)\n {\n   int depth;\n \n-  /* Valid mutex? */\n+  /* Valid mutex?  */\n   if (! mutex)\n     return -1;\n \n-  /* Acquire lock on mutex */\n+  /* Acquire lock on mutex.  */\n   depth = objc_mutex_lock (mutex);\n \n-  /* Call backend to destroy mutex */\n+  /* Call backend to destroy mutex.  */\n   if (__gthread_objc_mutex_deallocate (mutex))\n     return -1;\n \n-  /* Free the mutex structure */\n+  /* Free the mutex structure.  */\n   objc_free (mutex);\n \n-  /* Return last depth */\n+  /* Return last depth.  */\n   return depth;\n }\n \n-/*\n-  Grab a lock on a mutex.  If this thread already has a lock on this mutex\n-  then we increment the lock count.  If another thread has a lock on the \n-  mutex we block and wait for the thread to release the lock.\n-  Returns the lock count on the mutex held by this thread.\n-  */\n+/* Grab a lock on a mutex.  If this thread already has a lock on this\n+   mutex then we increment the lock count.  If another thread has a\n+   lock on the mutex we block and wait for the thread to release the\n+   lock.  Returns the lock count on the mutex held by this thread.  */\n int\n objc_mutex_lock (objc_mutex_t mutex)\n {\n   objc_thread_t thread_id;\n   int status;\n \n-  /* Valid mutex? */\n+  /* Valid mutex?  */\n   if (! mutex)\n     return -1;\n \n-  /* If we already own the lock then increment depth */\n+  /* If we already own the lock then increment depth.  */\n   thread_id = __gthread_objc_thread_id ();\n   if (mutex->owner == thread_id)\n     return ++mutex->depth;\n \n-  /* Call the backend to lock the mutex */\n+  /* Call the backend to lock the mutex.  */\n   status = __gthread_objc_mutex_lock (mutex);\n \n-  /* Failed? */\n+  /* Failed?  */\n   if (status)\n     return status;\n \n-  /* Successfully locked the thread */\n+  /* Successfully locked the thread.  */\n   mutex->owner = thread_id;\n   return mutex->depth = 1;\n }\n \n-/*\n-  Try to grab a lock on a mutex.  If this thread already has a lock on\n-  this mutex then we increment the lock count and return it.  If another\n-  thread has a lock on the mutex returns -1.\n-  */\n+/* Try to grab a lock on a mutex.  If this thread already has a lock\n+   on this mutex then we increment the lock count and return it.  If\n+   another thread has a lock on the mutex returns -1.  */\n int\n objc_mutex_trylock (objc_mutex_t mutex)\n {\n   objc_thread_t thread_id;\n   int status;\n \n-  /* Valid mutex? */\n+  /* Valid mutex?  */\n   if (! mutex)\n     return -1;\n \n-  /* If we already own the lock then increment depth */ \n+  /* If we already own the lock then increment depth.  */\n   thread_id = __gthread_objc_thread_id ();\n   if (mutex->owner == thread_id)\n     return ++mutex->depth;\n     \n-  /* Call the backend to try to lock the mutex */\n+  /* Call the backend to try to lock the mutex.  */\n   status = __gthread_objc_mutex_trylock (mutex);\n \n-  /* Failed? */\n+  /* Failed?  */\n   if (status)\n     return status;\n \n-  /* Successfully locked the thread */\n+  /* Successfully locked the thread.  */\n   mutex->owner = thread_id;\n   return mutex->depth = 1;\n }\n \n-/* \n-  Unlocks the mutex by one level.\n-  Decrements the lock count on this mutex by one.\n-  If the lock count reaches zero, release the lock on the mutex.\n-  Returns the lock count on the mutex.\n-  It is an error to attempt to unlock a mutex which this thread \n-  doesn't hold in which case return -1 and the mutex is unaffected.\n-  */\n+/* Unlocks the mutex by one level.  Decrements the lock count on this\n+   mutex by one.  If the lock count reaches zero, release the lock on\n+   the mutex.  Returns the lock count on the mutex.  It is an error to\n+   attempt to unlock a mutex which this thread doesn't hold in which\n+   case return -1 and the mutex is unaffected.  */\n int\n objc_mutex_unlock (objc_mutex_t mutex)\n {\n   objc_thread_t thread_id;\n   int status;\n \n-  /* Valid mutex? */\n+  /* Valid mutex?  */\n   if (! mutex)\n     return -1;\n \n-  /* If another thread owns the lock then abort */\n+  /* If another thread owns the lock then abort.  */\n   thread_id = __gthread_objc_thread_id ();\n   if (mutex->owner != thread_id)\n     return -1;\n \n-  /* Decrement depth and return */\n+  /* Decrement depth and return.  */\n   if (mutex->depth > 1)\n     return --mutex->depth;\n \n-  /* Depth down to zero so we are no longer the owner */\n+  /* Depth down to zero so we are no longer the owner.  */\n   mutex->depth = 0;\n   mutex->owner = NULL;\n \n-  /* Have the backend unlock the mutex */\n+  /* Have the backend unlock the mutex.  */\n   status = __gthread_objc_mutex_unlock (mutex);\n \n-  /* Failed? */\n+  /* Failed?  */\n   if (status)\n     return status;\n \n   return 0;\n }\n \n-/* Frontend condition mutex functions */\n+/* Public condition mutex functions */\n \n-/*\n-  Allocate a condition.  Return the condition pointer if successful or NULL\n-  if the allocation failed for any reason.\n-  */\n+/* Allocate a condition.  Return the condition pointer if successful\n+   or NULL if the allocation failed for any reason.  */\n objc_condition_t \n objc_condition_allocate (void)\n {\n   objc_condition_t condition;\n     \n-  /* Allocate the condition mutex structure */\n+  /* Allocate the condition mutex structure.  */\n   if (! (condition = \n \t (objc_condition_t) objc_malloc (sizeof (struct objc_condition))))\n     return NULL;\n \n-  /* Call the backend to create the condition mutex */\n+  /* Call the backend to create the condition mutex.  */\n   if (__gthread_objc_condition_allocate (condition))\n     {\n-      /* failed! */\n+      /* Failed!  */\n       objc_free (condition);\n       return NULL;\n     }\n \n-  /* Success! */\n+  /* Success!  */\n   return condition;\n }\n \n-/*\n-  Deallocate a condition. Note that this includes an implicit \n-  condition_broadcast to insure that waiting threads have the opportunity\n-  to wake.  It is legal to dealloc a condition only if no other\n-  thread is/will be using it. Here we do NOT check for other threads\n-  waiting but just wake them up.\n-  */\n+/* Deallocate a condition. Note that this includes an implicit\n+   condition_broadcast to insure that waiting threads have the\n+   opportunity to wake.  It is legal to dealloc a condition only if no\n+   other thread is/will be using it. Here we do NOT check for other\n+   threads waiting but just wake them up.  */\n int\n objc_condition_deallocate (objc_condition_t condition)\n {\n-  /* Broadcast the condition */\n+  /* Broadcast the condition.  */\n   if (objc_condition_broadcast (condition))\n     return -1;\n \n-  /* Call the backend to destroy */\n+  /* Call the backend to destroy.  */\n   if (__gthread_objc_condition_deallocate (condition))\n     return -1;\n \n-  /* Free the condition mutex structure */\n+  /* Free the condition mutex structure.  */\n   objc_free (condition);\n \n   return 0;\n }\n \n-/*\n-  Wait on the condition unlocking the mutex until objc_condition_signal ()\n-  or objc_condition_broadcast () are called for the same condition. The\n-  given mutex *must* have the depth set to 1 so that it can be unlocked\n-  here, so that someone else can lock it and signal/broadcast the condition.\n-  The mutex is used to lock access to the shared data that make up the\n-  \"condition\" predicate.\n-  */\n+/* Wait on the condition unlocking the mutex until\n+   objc_condition_signal () or objc_condition_broadcast () are called\n+   for the same condition. The given mutex *must* have the depth set\n+   to 1 so that it can be unlocked here, so that someone else can lock\n+   it and signal/broadcast the condition.  The mutex is used to lock\n+   access to the shared data that make up the \"condition\"\n+   predicate.  */\n int\n objc_condition_wait (objc_condition_t condition, objc_mutex_t mutex)\n {\n   objc_thread_t thread_id;\n \n-  /* Valid arguments? */\n+  /* Valid arguments?  */\n   if (! mutex || ! condition)\n     return -1;\n \n-  /* Make sure we are owner of mutex */\n+  /* Make sure we are owner of mutex.  */\n   thread_id = __gthread_objc_thread_id ();\n   if (mutex->owner != thread_id)\n     return -1;\n \n-  /* Cannot be locked more than once */\n+  /* Cannot be locked more than once.  */\n   if (mutex->depth > 1)\n     return -1;\n \n-  /* Virtually unlock the mutex */\n+  /* Virtually unlock the mutex.  */\n   mutex->depth = 0;\n   mutex->owner = (objc_thread_t)NULL;\n \n-  /* Call the backend to wait */\n+  /* Call the backend to wait.  */\n   __gthread_objc_condition_wait (condition, mutex);\n \n-  /* Make ourselves owner of the mutex */\n+  /* Make ourselves owner of the mutex.  */\n   mutex->owner = thread_id;\n   mutex->depth = 1;\n \n   return 0;\n }\n \n-/*\n-  Wake up all threads waiting on this condition. It is recommended that \n-  the called would lock the same mutex as the threads in objc_condition_wait\n-  before changing the \"condition predicate\" and make this call and unlock it\n-  right away after this call.\n-  */\n+/* Wake up all threads waiting on this condition. It is recommended\n+   that the called would lock the same mutex as the threads in\n+   objc_condition_wait before changing the \"condition predicate\" and\n+   make this call and unlock it right away after this call.  */\n int\n objc_condition_broadcast (objc_condition_t condition)\n {\n-  /* Valid condition mutex? */\n+  /* Valid condition mutex?  */\n   if (! condition)\n     return -1;\n \n   return __gthread_objc_condition_broadcast (condition);\n }\n \n-/*\n-  Wake up one thread waiting on this condition. It is recommended that \n-  the called would lock the same mutex as the threads in objc_condition_wait\n-  before changing the \"condition predicate\" and make this call and unlock it\n-  right away after this call.\n-  */\n+/* Wake up one thread waiting on this condition. It is recommended\n+   that the called would lock the same mutex as the threads in\n+   objc_condition_wait before changing the \"condition predicate\" and\n+   make this call and unlock it right away after this call.  */\n int\n objc_condition_signal (objc_condition_t condition)\n {\n-  /* Valid condition mutex? */\n+  /* Valid condition mutex?  */\n   if (! condition)\n     return -1;\n \n@@ -591,4 +546,3 @@ objc_thread_remove (void)\n   objc_mutex_unlock (__objc_runtime_mutex);  \n }\n \n-/* End of File */"}]}