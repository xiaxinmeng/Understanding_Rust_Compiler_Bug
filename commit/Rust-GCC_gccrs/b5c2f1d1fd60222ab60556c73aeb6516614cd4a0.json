{"sha": "b5c2f1d1fd60222ab60556c73aeb6516614cd4a0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjVjMmYxZDFmZDYwMjIyYWI2MDU1NmM3M2FlYjY1MTY2MTRjZDRhMA==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@codesourcery.com", "date": "2004-08-24T16:49:54Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2004-08-24T16:49:54Z"}, "message": "rtl.def: Reorganize, placing all codes used only in machine descriptions at the end.\n\n\t* rtl.def: Reorganize, placing all codes used only in machine\n\tdescriptions at the end.\n\nFrom-SVN: r86496", "tree": {"sha": "2bfe6e85e8dfc00e5169f48265bd040f77ae8d7e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2bfe6e85e8dfc00e5169f48265bd040f77ae8d7e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b5c2f1d1fd60222ab60556c73aeb6516614cd4a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5c2f1d1fd60222ab60556c73aeb6516614cd4a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5c2f1d1fd60222ab60556c73aeb6516614cd4a0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5c2f1d1fd60222ab60556c73aeb6516614cd4a0/comments", "author": null, "committer": null, "parents": [{"sha": "076c7ab896de2d7f85e2b8b5771c599b7d01dea2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/076c7ab896de2d7f85e2b8b5771c599b7d01dea2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/076c7ab896de2d7f85e2b8b5771c599b7d01dea2"}], "stats": {"total": 1768, "additions": 879, "deletions": 889}, "files": [{"sha": "c2d984bc888f0f1f0d4c119b35ef2de6a445075f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5c2f1d1fd60222ab60556c73aeb6516614cd4a0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5c2f1d1fd60222ab60556c73aeb6516614cd4a0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b5c2f1d1fd60222ab60556c73aeb6516614cd4a0", "patch": "@@ -1,3 +1,8 @@\n+2004-08-24  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* rtl.def: Reorganize, placing all codes used only in machine\n+\tdescriptions at the end.\n+\n 2004-08-24  Zack Weinberg  <zack@codesourcery.com>\n \n \t* basic-block.h (struct basic_block_def): Reorder fields to"}, {"sha": "5038514e711eef5446e42974cf25b054880e1ae9", "filename": "gcc/rtl.def", "status": "modified", "additions": 874, "deletions": 889, "changes": 1763, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5c2f1d1fd60222ab60556c73aeb6516614cd4a0/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5c2f1d1fd60222ab60556c73aeb6516614cd4a0/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=b5c2f1d1fd60222ab60556c73aeb6516614cd4a0", "patch": "@@ -73,21 +73,14 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n          an rtx code for autoincrement addressing modes (e.g. POST_DEC)\n      RTX_EXTRA\n          everything else\n-     \n-   */\n \n-/* ---------------------------------------------------------------------\n-   Expressions (and \"meta\" expressions) used for structuring the\n-   rtl representation of a program.\n-   --------------------------------------------------------------------- */\n+   All of the expressions that appear only in machine descriptions,\n+   not in RTL used by the compiler itself, are at the end of the file.  */\n \n-/* an expression code name unknown to the reader */\n+/* Unknown, or no such operation; the enumeration constant should have\n+   value zero.  */\n DEF_RTL_EXPR(UNKNOWN, \"UnKnown\", \"*\", RTX_EXTRA)\n \n-/* include a file */\n-\n-DEF_RTL_EXPR(INCLUDE, \"include\", \"s\", RTX_EXTRA)\n-\n /* ---------------------------------------------------------------------\n    Expressions used in constructing lists.\n    --------------------------------------------------------------------- */\n@@ -99,1082 +92,1074 @@ DEF_RTL_EXPR(EXPR_LIST, \"expr_list\", \"ee\", RTX_EXTRA)\n    The insns are represented in print by their uids.  */\n DEF_RTL_EXPR(INSN_LIST, \"insn_list\", \"ue\", RTX_EXTRA)\n \n-/* ----------------------------------------------------------------------\n-   Expression types for machine descriptions.\n-   These do not appear in actual rtl code in the compiler.\n-   ---------------------------------------------------------------------- */\n+/* SEQUENCE appears in the result of a `gen_...' function\n+   for a DEFINE_EXPAND that wants to make several insns.\n+   Its elements are the bodies of the insns that should be made.\n+   `emit_insn' takes the SEQUENCE apart and makes separate insns.  */\n+DEF_RTL_EXPR(SEQUENCE, \"sequence\", \"E\", RTX_EXTRA)\n \n-/* Appears only in machine descriptions.\n-   Means use the function named by the second arg (the string)\n-   as a predicate; if matched, store the structure that was matched\n-   in the operand table at index specified by the first arg (the integer).\n-   If the second arg is the null string, the structure is just stored.\n+/* Refers to the address of its argument.  This is only used in alias.c.  */\n+DEF_RTL_EXPR(ADDRESS, \"address\", \"e\", RTX_MATCH)\n \n-   A third string argument indicates to the register allocator restrictions\n-   on where the operand can be allocated.\n+/* ----------------------------------------------------------------------\n+   Expression types used for things in the instruction chain.\n \n-   If the target needs no restriction on any instruction this field should\n-   be the null string.\n+   All formats must start with \"iuu\" to handle the chain.\n+   Each insn expression holds an rtl instruction and its semantics\n+   during back-end processing.\n+   See macros's in \"rtl.h\" for the meaning of each rtx->u.fld[].\n \n-   The string is prepended by:\n-   '=' to indicate the operand is only written to.\n-   '+' to indicate the operand is both read and written to.\n+   ---------------------------------------------------------------------- */\n \n-   Each character in the string represents an allocable class for an operand.\n-   'g' indicates the operand can be any valid class.\n-   'i' indicates the operand can be immediate (in the instruction) data.\n-   'r' indicates the operand can be in a register.\n-   'm' indicates the operand can be in memory.\n-   'o' a subset of the 'm' class.  Those memory addressing modes that\n-       can be offset at compile time (have a constant added to them).\n+/* An instruction that cannot jump.  */\n+DEF_RTL_EXPR(INSN, \"insn\", \"iuuBieiee\", RTX_INSN)\n \n-   Other characters indicate target dependent operand classes and\n-   are described in each target's machine description.\n+/* An instruction that can possibly jump.\n+   Fields ( rtx->u.fld[] ) have exact same meaning as INSN's.  */\n+DEF_RTL_EXPR(JUMP_INSN, \"jump_insn\", \"iuuBieiee0\", RTX_INSN)\n \n-   For instructions with more than one operand, sets of classes can be\n-   separated by a comma to indicate the appropriate multi-operand constraints.\n-   There must be a 1 to 1 correspondence between these sets of classes in\n-   all operands for an instruction.\n-   */\n-DEF_RTL_EXPR(MATCH_OPERAND, \"match_operand\", \"iss\", RTX_MATCH)\n+/* An instruction that can possibly call a subroutine\n+   but which will not change which instruction comes next\n+   in the current function.\n+   Field ( rtx->u.fld[9] ) is CALL_INSN_FUNCTION_USAGE.\n+   All other fields ( rtx->u.fld[] ) have exact same meaning as INSN's.  */\n+DEF_RTL_EXPR(CALL_INSN, \"call_insn\", \"iuuBieieee\", RTX_INSN)\n \n-/* Appears only in machine descriptions.\n-   Means match a SCRATCH or a register.  When used to generate rtl, a\n-   SCRATCH is generated.  As for MATCH_OPERAND, the mode specifies\n-   the desired mode and the first argument is the operand number.\n-   The second argument is the constraint.  */\n-DEF_RTL_EXPR(MATCH_SCRATCH, \"match_scratch\", \"is\", RTX_MATCH)\n+/* A marker that indicates that control will not flow through.  */\n+DEF_RTL_EXPR(BARRIER, \"barrier\", \"iuu000000\", RTX_EXTRA)\n \n-/* Appears only in machine descriptions.\n-   Means match only something equal to what is stored in the operand table\n-   at the index specified by the argument.  */\n-DEF_RTL_EXPR(MATCH_DUP, \"match_dup\", \"i\", RTX_MATCH)\n+/* Holds a label that is followed by instructions.\n+   Operand:\n+   4: is used in jump.c for the use-count of the label.\n+   5: is used in flow.c to point to the chain of label_ref's to this label.\n+   6: is a number that is unique in the entire compilation.\n+   7: is the user-given name of the label, if any.  */\n+DEF_RTL_EXPR(CODE_LABEL, \"code_label\", \"iuuB00is\", RTX_EXTRA)\n \n-/* Appears only in machine descriptions.\n-   Means apply a predicate, AND match recursively the operands of the rtx.\n-   Operand 0 is the operand-number, as in match_operand.\n-   Operand 1 is a predicate to apply (as a string, a function name).\n-   Operand 2 is a vector of expressions, each of which must match\n-   one subexpression of the rtx this construct is matching.  */\n-DEF_RTL_EXPR(MATCH_OPERATOR, \"match_operator\", \"isE\", RTX_MATCH)\n+#ifdef USE_MAPPED_LOCATION\n+/* Say where in the code a source line starts, for symbol table's sake.\n+   Operand:\n+   4: unused if line number > 0, note-specific data otherwise.\n+   5: line number if > 0, enum note_insn otherwise.\n+   6: CODE_LABEL_NUMBER if line number == NOTE_INSN_DELETED_LABEL.  */\n+#else\n+/* Say where in the code a source line starts, for symbol table's sake.\n+   Operand:\n+   4: filename, if line number > 0, note-specific data otherwise.\n+   5: line number if > 0, enum note_insn otherwise.\n+   6: unique number if line number == note_insn_deleted_label.  */\n+#endif\n+DEF_RTL_EXPR(NOTE, \"note\", \"iuuB0ni\", RTX_EXTRA)\n \n-/* Appears only in machine descriptions.\n-   Means to match a PARALLEL of arbitrary length.  The predicate is applied\n-   to the PARALLEL and the initial expressions in the PARALLEL are matched.\n-   Operand 0 is the operand-number, as in match_operand.\n-   Operand 1 is a predicate to apply to the PARALLEL.\n-   Operand 2 is a vector of expressions, each of which must match the \n-   corresponding element in the PARALLEL.  */\n-DEF_RTL_EXPR(MATCH_PARALLEL, \"match_parallel\", \"isE\", RTX_MATCH)\n+/* ----------------------------------------------------------------------\n+   Top level constituents of INSN, JUMP_INSN and CALL_INSN.\n+   ---------------------------------------------------------------------- */\n+   \n+/* Conditionally execute code.\n+   Operand 0 is the condition that if true, the code is executed.\n+   Operand 1 is the code to be executed (typically a SET). \n \n-/* Appears only in machine descriptions.\n-   Means match only something equal to what is stored in the operand table\n-   at the index specified by the argument.  For MATCH_OPERATOR.  */\n-DEF_RTL_EXPR(MATCH_OP_DUP, \"match_op_dup\", \"iE\", RTX_MATCH)\n+   Semantics are that there are no side effects if the condition\n+   is false.  This pattern is created automatically by the if_convert\n+   pass run after reload or by target-specific splitters.  */\n+DEF_RTL_EXPR(COND_EXEC, \"cond_exec\", \"ee\", RTX_EXTRA)\n \n-/* Appears only in machine descriptions.\n-   Means match only something equal to what is stored in the operand table\n-   at the index specified by the argument.  For MATCH_PARALLEL.  */\n-DEF_RTL_EXPR(MATCH_PAR_DUP, \"match_par_dup\", \"iE\", RTX_MATCH)\n+/* Several operations to be done in parallel (perhaps under COND_EXEC).  */\n+DEF_RTL_EXPR(PARALLEL, \"parallel\", \"E\", RTX_EXTRA)\n \n-/* Appears only in define_predicate/define_special predicate\n-   expressions in a machine description.  Evaluates true only if the\n-   operand has an RTX code from the set given by the argument (a\n-   comma-separated list).  */\n-DEF_RTL_EXPR(MATCH_CODE, \"match_code\", \"s\", RTX_MATCH)\n+/* A string that is passed through to the assembler as input.\n+     One can obviously pass comments through by using the\n+     assembler comment syntax.\n+     These occur in an insn all by themselves as the PATTERN.\n+     They also appear inside an ASM_OPERANDS\n+     as a convenient way to hold a string.  */\n+DEF_RTL_EXPR(ASM_INPUT, \"asm_input\", \"s\", RTX_EXTRA)\n \n-/* Appears only in define_predicate/define_special_predicate expressions\n-   in a machine description.  The argument is a C expression to be injected\n-   at this point in the predicate formula.  */\n-DEF_RTL_EXPR(MATCH_TEST, \"match_test\", \"s\", RTX_MATCH)\n+#ifdef USE_MAPPED_LOCATION\n+/* An assembler instruction with operands.\n+   1st operand is the instruction template.\n+   2nd operand is the constraint for the output.\n+   3rd operand is the number of the output this expression refers to.\n+     When an insn stores more than one value, a separate ASM_OPERANDS\n+     is made for each output; this integer distinguishes them.\n+   4th is a vector of values of input operands.\n+   5th is a vector of modes and constraints for the input operands.\n+     Each element is an ASM_INPUT containing a constraint string\n+     and whose mode indicates the mode of the input operand.\n+   6th is the source line number.  */\n+DEF_RTL_EXPR(ASM_OPERANDS, \"asm_operands\", \"ssiEEi\", RTX_EXTRA)\n+#else\n+/* An assembler instruction with operands.\n+   1st operand is the instruction template.\n+   2nd operand is the constraint for the output.\n+   3rd operand is the number of the output this expression refers to.\n+     When an insn stores more than one value, a separate ASM_OPERANDS\n+     is made for each output; this integer distinguishes them.\n+   4th is a vector of values of input operands.\n+   5th is a vector of modes and constraints for the input operands.\n+     Each element is an ASM_INPUT containing a constraint string\n+     and whose mode indicates the mode of the input operand.\n+   6th is the name of the containing source file.\n+   7th is the source line number.  */\n+DEF_RTL_EXPR(ASM_OPERANDS, \"asm_operands\", \"ssiEEsi\", RTX_EXTRA)\n+#endif\n \n-/* Appears only in machine descriptions.\n-   Defines the pattern for one kind of instruction.\n-   Operand:\n-   0: names this instruction.\n-      If the name is the null string, the instruction is in the\n-      machine description just to be recognized, and will never be emitted by\n-      the tree to rtl expander.\n-   1: is the pattern.\n-   2: is a string which is a C expression\n-      giving an additional condition for recognizing this pattern.\n-      A null string means no extra condition.\n-   3: is the action to execute if this pattern is matched.\n-      If this assembler code template starts with a * then it is a fragment of\n-      C code to run to decide on a template to use.  Otherwise, it is the\n-      template to use.\n-   4: optionally, a vector of attributes for this insn.\n-     */\n-DEF_RTL_EXPR(DEFINE_INSN, \"define_insn\", \"sEsTV\", RTX_EXTRA)\n+/* A machine-specific operation.\n+   1st operand is a vector of operands being used by the operation so that\n+     any needed reloads can be done.\n+   2nd operand is a unique value saying which of a number of machine-specific\n+     operations is to be performed.\n+   (Note that the vector must be the first operand because of the way that\n+   genrecog.c record positions within an insn.)\n+   This can occur all by itself in a PATTERN, as a component of a PARALLEL,\n+   or inside an expression.  */\n+DEF_RTL_EXPR(UNSPEC, \"unspec\", \"Ei\", RTX_EXTRA)\n \n-/* Definition of a peephole optimization.\n-   1st operand: vector of insn patterns to match\n-   2nd operand: C expression that must be true\n-   3rd operand: template or C code to produce assembler output.\n-   4: optionally, a vector of attributes for this insn.\n-     */\n-DEF_RTL_EXPR(DEFINE_PEEPHOLE, \"define_peephole\", \"EsTV\", RTX_EXTRA)\n+/* Similar, but a volatile operation and one which may trap.  */\n+DEF_RTL_EXPR(UNSPEC_VOLATILE, \"unspec_volatile\", \"Ei\", RTX_EXTRA)\n \n-/* Definition of a split operation.\n-   1st operand: insn pattern to match\n-   2nd operand: C expression that must be true\n-   3rd operand: vector of insn patterns to place into a SEQUENCE\n-   4th operand: optionally, some C code to execute before generating the\n-\tinsns.  This might, for example, create some RTX's and store them in\n-\telements of `recog_data.operand' for use by the vector of\n-\tinsn-patterns.\n-\t(`operands' is an alias here for `recog_data.operand').  */\n-DEF_RTL_EXPR(DEFINE_SPLIT, \"define_split\", \"EsES\", RTX_EXTRA)\n+/* Vector of addresses, stored as full words.  */\n+/* Each element is a LABEL_REF to a CODE_LABEL whose address we want.  */\n+DEF_RTL_EXPR(ADDR_VEC, \"addr_vec\", \"E\", RTX_EXTRA)\n \n-/* Definition of an insn and associated split.\n-   This is the concatenation, with a few modifications, of a define_insn\n-   and a define_split which share the same pattern.\n-   Operand:\n-   0: names this instruction.\n-      If the name is the null string, the instruction is in the\n-      machine description just to be recognized, and will never be emitted by\n-      the tree to rtl expander.\n-   1: is the pattern.\n-   2: is a string which is a C expression\n-      giving an additional condition for recognizing this pattern.\n-      A null string means no extra condition.\n-   3: is the action to execute if this pattern is matched.\n-      If this assembler code template starts with a * then it is a fragment of\n-      C code to run to decide on a template to use.  Otherwise, it is the\n-      template to use.\n-   4: C expression that must be true for split.  This may start with \"&&\"\n-      in which case the split condition is the logical and of the insn \n-      condition and what follows the \"&&\" of this operand.\n-   5: vector of insn patterns to place into a SEQUENCE\n-   6: optionally, some C code to execute before generating the\n-\tinsns.  This might, for example, create some RTX's and store them in\n-\telements of `recog_data.operand' for use by the vector of\n-\tinsn-patterns.\n-\t(`operands' is an alias here for `recog_data.operand').  \n-   7: optionally, a vector of attributes for this insn.  */\n-DEF_RTL_EXPR(DEFINE_INSN_AND_SPLIT, \"define_insn_and_split\", \"sEsTsESV\", RTX_EXTRA)\n+/* Vector of address differences X0 - BASE, X1 - BASE, ...\n+   First operand is BASE; the vector contains the X's.\n+   The machine mode of this rtx says how much space to leave\n+   for each difference and is adjusted by branch shortening if\n+   CASE_VECTOR_SHORTEN_MODE is defined.\n+   The third and fourth operands store the target labels with the\n+   minimum and maximum addresses respectively.\n+   The fifth operand stores flags for use by branch shortening.\n+  Set at the start of shorten_branches:\n+   min_align: the minimum alignment for any of the target labels.\n+   base_after_vec: true iff BASE is after the ADDR_DIFF_VEC.\n+   min_after_vec: true iff minimum addr target label is after the ADDR_DIFF_VEC.\n+   max_after_vec: true iff maximum addr target label is after the ADDR_DIFF_VEC.\n+   min_after_base: true iff minimum address target label is after BASE.\n+   max_after_base: true iff maximum address target label is after BASE.\n+  Set by the actual branch shortening process:\n+   offset_unsigned: true iff offsets have to be treated as unsigned.\n+   scale: scaling that is necessary to make offsets fit into the mode.\n \n-/* Definition of an RTL peephole operation.\n-   Follows the same arguments as define_split.  */\n-DEF_RTL_EXPR(DEFINE_PEEPHOLE2, \"define_peephole2\", \"EsES\", RTX_EXTRA)\n+   The third, fourth and fifth operands are only valid when\n+   CASE_VECTOR_SHORTEN_MODE is defined, and only in an optimizing\n+   compilations.  */\n+     \n+DEF_RTL_EXPR(ADDR_DIFF_VEC, \"addr_diff_vec\", \"eEee0\", RTX_EXTRA)\n \n-/* Define how to generate multiple insns for a standard insn name.\n-   1st operand: the insn name.\n-   2nd operand: vector of insn-patterns.\n-\tUse match_operand to substitute an element of `recog_data.operand'.\n-   3rd operand: C expression that must be true for this to be available.\n-\tThis may not test any operands.\n-   4th operand: Extra C code to execute before generating the insns.\n-\tThis might, for example, create some RTX's and store them in\n-\telements of `recog_data.operand' for use by the vector of\n-\tinsn-patterns.\n-\t(`operands' is an alias here for `recog_data.operand').  */\n-DEF_RTL_EXPR(DEFINE_EXPAND, \"define_expand\", \"sEss\", RTX_EXTRA)\n-   \n-/* Define a requirement for delay slots.\n-   1st operand: Condition involving insn attributes that, if true,\n-\t        indicates that the insn requires the number of delay slots\n-\t\tshown.\n-   2nd operand: Vector whose length is the three times the number of delay\n-\t\tslots required.\n-\t        Each entry gives three conditions, each involving attributes.\n-\t\tThe first must be true for an insn to occupy that delay slot\n-\t\tlocation.  The second is true for all insns that can be\n-\t\tannulled if the branch is true and the third is true for all\n-\t\tinsns that can be annulled if the branch is false. \n+/* Memory prefetch, with attributes supported on some targets.\n+   Operand 1 is the address of the memory to fetch.\n+   Operand 2 is 1 for a write access, 0 otherwise.\n+   Operand 3 is the level of temporal locality; 0 means there is no\n+   temporal locality and 1, 2, and 3 are for increasing levels of temporal\n+   locality.\n \n-   Multiple DEFINE_DELAYs may be present.  They indicate differing\n-   requirements for delay slots.  */\n-DEF_RTL_EXPR(DEFINE_DELAY, \"define_delay\", \"eE\", RTX_EXTRA)\n+   The attributes specified by operands 2 and 3 are ignored for targets\n+   whose prefetch instructions do not support them.  */\n+DEF_RTL_EXPR(PREFETCH, \"prefetch\", \"eee\", RTX_EXTRA)\n \n-/* Define attribute computation for `asm' instructions.  */\n-DEF_RTL_EXPR(DEFINE_ASM_ATTRIBUTES, \"define_asm_attributes\", \"V\", RTX_EXTRA)\n+/* ----------------------------------------------------------------------\n+   At the top level of an instruction (perhaps under PARALLEL).\n+   ---------------------------------------------------------------------- */\n \n-/* Definition of a conditional execution meta operation.  Automatically\n-   generates new instances of DEFINE_INSN, selected by having attribute\n-   \"predicable\" true.  The new pattern will contain a COND_EXEC and the\n-   predicate at top-level.\n+/* Assignment.\n+   Operand 1 is the location (REG, MEM, PC, CC0 or whatever) assigned to.\n+   Operand 2 is the value stored there.\n+   ALL assignment must use SET.\n+   Instructions that do multiple assignments must use multiple SET,\n+   under PARALLEL.  */\n+DEF_RTL_EXPR(SET, \"set\", \"ee\", RTX_EXTRA)\n \n-   Operand:\n-   0: The predicate pattern.  The top-level form should match a\n-      relational operator.  Operands should have only one alternative.\n-   1: A C expression giving an additional condition for recognizing\n-      the generated pattern.\n-   2: A template or C code to produce assembler output.  */\n-DEF_RTL_EXPR(DEFINE_COND_EXEC, \"define_cond_exec\", \"Ess\", RTX_EXTRA)\n+/* Indicate something is used in a way that we don't want to explain.\n+   For example, subroutine calls will use the register\n+   in which the static chain is passed.  */\n+DEF_RTL_EXPR(USE, \"use\", \"e\", RTX_EXTRA)\n \n-/* Definition of an operand predicate.  The difference between\n-   DEFINE_PREDICATE and DEFINE_SPECIAL_PREDICATE is that genrecog will\n-   not warn about a match_operand with no mode if it has a predicate\n-   defined with DEFINE_SPECIAL_PREDICATE.\n+/* Indicate something is clobbered in a way that we don't want to explain.\n+   For example, subroutine calls will clobber some physical registers\n+   (the ones that are by convention not saved).  */\n+DEF_RTL_EXPR(CLOBBER, \"clobber\", \"e\", RTX_EXTRA)\n \n-   Operand:\n-   0: The name of the predicate.\n-   1: A boolean expression which computes whether or not the predicate\n-      matches.  This expression can use IOR, AND, NOT, MATCH_OPERAND,\n-      MATCH_CODE, and MATCH_TEST.  It must be specific enough that genrecog\n-      can calculate the set of RTX codes that can possibly match.\n-   2: A C function body which must return true for the predicate to match.\n-      Optional.  Use this when the test is too complicated to fit into a\n-      match_test expression.  */\n-DEF_RTL_EXPR(DEFINE_PREDICATE, \"define_predicate\", \"ses\", RTX_EXTRA)\n-DEF_RTL_EXPR(DEFINE_SPECIAL_PREDICATE, \"define_special_predicate\", \"ses\", RTX_EXTRA)\n+/* Call a subroutine.\n+   Operand 1 is the address to call.\n+   Operand 2 is the number of arguments.  */\n \n-/* SEQUENCE appears in the result of a `gen_...' function\n-   for a DEFINE_EXPAND that wants to make several insns.\n-   Its elements are the bodies of the insns that should be made.\n-   `emit_insn' takes the SEQUENCE apart and makes separate insns.  */\n-DEF_RTL_EXPR(SEQUENCE, \"sequence\", \"E\", RTX_EXTRA)\n+DEF_RTL_EXPR(CALL, \"call\", \"ee\", RTX_EXTRA)\n \n-/* Refers to the address of its argument.  This is only used in alias.c.  */\n-DEF_RTL_EXPR(ADDRESS, \"address\", \"e\", RTX_MATCH)\n+/* Return from a subroutine.  */\n+\n+DEF_RTL_EXPR(RETURN, \"return\", \"\", RTX_EXTRA)\n+\n+/* Conditional trap.\n+   Operand 1 is the condition.\n+   Operand 2 is the trap code.\n+   For an unconditional trap, make the condition (const_int 1).  */\n+DEF_RTL_EXPR(TRAP_IF, \"trap_if\", \"ee\", RTX_EXTRA)\n+\n+/* Placeholder for _Unwind_Resume before we know if a function call\n+   or a branch is needed.  Operand 1 is the exception region from\n+   which control is flowing.  */\n+DEF_RTL_EXPR(RESX, \"resx\", \"i\", RTX_EXTRA)\n \n /* ----------------------------------------------------------------------\n-   Constructions for CPU pipeline description described by NDFAs.\n-   These do not appear in actual rtl code in the compiler.\n+   Primitive values for use in expressions.\n    ---------------------------------------------------------------------- */\n \n-/* (define_cpu_unit string [string]) describes cpu functional\n-   units (separated by comma).\n+/* numeric integer constant */\n+DEF_RTL_EXPR(CONST_INT, \"const_int\", \"w\", RTX_CONST_OBJ)\n \n-   1st operand: Names of cpu functional units.\n-   2nd operand: Name of automaton (see comments for DEFINE_AUTOMATON).\n+/* numeric floating point constant.\n+   Operands hold the value.  They are all 'w' and there may be from 2 to 6;\n+   see real.h.  */\n+DEF_RTL_EXPR(CONST_DOUBLE, \"const_double\", CONST_DOUBLE_FORMAT, RTX_CONST_OBJ)\n \n-   All define_reservations, define_cpu_units, and\n-   define_query_cpu_units should have unique names which may not be\n-   \"nothing\".  */\n-DEF_RTL_EXPR(DEFINE_CPU_UNIT, \"define_cpu_unit\", \"sS\", RTX_EXTRA)\n+/* Describes a vector constant.  */\n+DEF_RTL_EXPR(CONST_VECTOR, \"const_vector\", \"E\", RTX_EXTRA)\n \n-/* (define_query_cpu_unit string [string]) describes cpu functional\n-   units analogously to define_cpu_unit.  The reservation of such\n-   units can be queried for automaton state.  */\n-DEF_RTL_EXPR(DEFINE_QUERY_CPU_UNIT, \"define_query_cpu_unit\", \"sS\", RTX_EXTRA)\n+/* String constant.  Used for attributes in machine descriptions and\n+   for special cases in DWARF2 debug output.  NOT used for source-\n+   language string constants.  */\n+DEF_RTL_EXPR(CONST_STRING, \"const_string\", \"s\", RTX_OBJ)\n \n-/* (exclusion_set string string) means that each CPU functional unit\n-   in the first string can not be reserved simultaneously with any\n-   unit whose name is in the second string and vise versa.  CPU units\n-   in the string are separated by commas.  For example, it is useful\n-   for description CPU with fully pipelined floating point functional\n-   unit which can execute simultaneously only single floating point\n-   insns or only double floating point insns.  All CPU functional\n-   units in a set should belong to the same automaton.  */\n-DEF_RTL_EXPR(EXCLUSION_SET, \"exclusion_set\", \"ss\", RTX_EXTRA)\n+/* This is used to encapsulate an expression whose value is constant\n+   (such as the sum of a SYMBOL_REF and a CONST_INT) so that it will be\n+   recognized as a constant operand rather than by arithmetic instructions.  */\n \n-/* (presence_set string string) means that each CPU functional unit in\n-   the first string can not be reserved unless at least one of pattern\n-   of units whose names are in the second string is reserved.  This is\n-   an asymmetric relation.  CPU units or unit patterns in the strings\n-   are separated by commas.  Pattern is one unit name or unit names\n-   separated by white-spaces.\n- \n-   For example, it is useful for description that slot1 is reserved\n-   after slot0 reservation for a VLIW processor.  We could describe it\n-   by the following construction\n+DEF_RTL_EXPR(CONST, \"const\", \"e\", RTX_CONST_OBJ)\n \n-      (presence_set \"slot1\" \"slot0\")\n+/* program counter.  Ordinary jumps are represented\n+   by a SET whose first operand is (PC).  */\n+DEF_RTL_EXPR(PC, \"pc\", \"\", RTX_OBJ)\n \n-   Or slot1 is reserved only after slot0 and unit b0 reservation.  In\n-   this case we could write\n+/* Used in the cselib routines to describe a value.  */\n+DEF_RTL_EXPR(VALUE, \"value\", \"0\", RTX_OBJ)\n \n-      (presence_set \"slot1\" \"slot0 b0\")\n+/* A register.  The \"operand\" is the register number, accessed with\n+   the REGNO macro.  If this number is less than FIRST_PSEUDO_REGISTER\n+   than a hardware register is being referred to.  The second operand\n+   holds the original register number - this will be different for a\n+   pseudo register that got turned into a hard register.\n+   This rtx needs to have as many (or more) fields as a MEM, since we\n+   can change REG rtx's into MEMs during reload.  */\n+DEF_RTL_EXPR(REG, \"reg\", \"i00\", RTX_OBJ)\n \n-   All CPU functional units in a set should belong to the same\n-   automaton.  */\n-DEF_RTL_EXPR(PRESENCE_SET, \"presence_set\", \"ss\", RTX_EXTRA)\n+/* A scratch register.  This represents a register used only within a\n+   single insn.  It will be turned into a REG during register allocation\n+   or reload unless the constraint indicates that the register won't be\n+   needed, in which case it can remain a SCRATCH.  This code is\n+   marked as having one operand so it can be turned into a REG.  */\n+DEF_RTL_EXPR(SCRATCH, \"scratch\", \"0\", RTX_OBJ)\n \n-/* (final_presence_set string string) is analogous to `presence_set'.\n-   The difference between them is when checking is done.  When an\n-   instruction is issued in given automaton state reflecting all\n-   current and planned unit reservations, the automaton state is\n-   changed.  The first state is a source state, the second one is a\n-   result state.  Checking for `presence_set' is done on the source\n-   state reservation, checking for `final_presence_set' is done on the\n-   result reservation.  This construction is useful to describe a\n-   reservation which is actually two subsequent reservations.  For\n-   example, if we use \n+/* One word of a multi-word value.\n+   The first operand is the complete value; the second says which word.\n+   The WORDS_BIG_ENDIAN flag controls whether word number 0\n+   (as numbered in a SUBREG) is the most or least significant word.\n \n-      (presence_set \"slot1\" \"slot0\")\n+   This is also used to refer to a value in a different machine mode.\n+   For example, it can be used to refer to a SImode value as if it were\n+   Qimode, or vice versa.  Then the word number is always 0.  */\n+DEF_RTL_EXPR(SUBREG, \"subreg\", \"ei\", RTX_EXTRA)\n \n-   the following insn will be never issued (because slot1 requires\n-   slot0 which is absent in the source state).\n+/* This one-argument rtx is used for move instructions\n+   that are guaranteed to alter only the low part of a destination.\n+   Thus, (SET (SUBREG:HI (REG...)) (MEM:HI ...))\n+   has an unspecified effect on the high part of REG,\n+   but (SET (STRICT_LOW_PART (SUBREG:HI (REG...))) (MEM:HI ...))\n+   is guaranteed to alter only the bits of REG that are in HImode.\n \n-      (define_reservation \"insn_and_nop\" \"slot0 + slot1\")\n+   The actual instruction used is probably the same in both cases,\n+   but the register constraints may be tighter when STRICT_LOW_PART\n+   is in use.  */\n \n-   but it can be issued if we use analogous `final_presence_set'.  */\n-DEF_RTL_EXPR(FINAL_PRESENCE_SET, \"final_presence_set\", \"ss\", RTX_EXTRA)\n+DEF_RTL_EXPR(STRICT_LOW_PART, \"strict_low_part\", \"e\", RTX_EXTRA)\n \n-/* (absence_set string string) means that each CPU functional unit in\n-   the first string can be reserved only if each pattern of units\n-   whose names are in the second string is not reserved.  This is an\n-   asymmetric relation (actually exclusion set is analogous to this\n-   one but it is symmetric).  CPU units or unit patterns in the string\n-   are separated by commas.  Pattern is one unit name or unit names\n-   separated by white-spaces.\n+/* (CONCAT a b) represents the virtual concatenation of a and b\n+   to make a value that has as many bits as a and b put together.\n+   This is used for complex values.  Normally it appears only\n+   in DECL_RTLs and during RTL generation, but not in the insn chain.  */\n+DEF_RTL_EXPR(CONCAT, \"concat\", \"ee\", RTX_OBJ)\n \n-   For example, it is useful for description that slot0 can not be\n-   reserved after slot1 or slot2 reservation for a VLIW processor.  We\n-   could describe it by the following construction\n+/* A memory location; operand is the address.  The second operand is the\n+   alias set to which this MEM belongs.  We use `0' instead of `w' for this\n+   field so that the field need not be specified in machine descriptions.  */\n+DEF_RTL_EXPR(MEM, \"mem\", \"e0\", RTX_OBJ)\n \n-      (absence_set \"slot2\" \"slot0, slot1\")\n+/* Reference to an assembler label in the code for this function.\n+   The operand is a CODE_LABEL found in the insn chain.\n+   The unprinted fields 1 and 2 are used in flow.c for the\n+   LABEL_NEXTREF and CONTAINING_INSN.  */\n+DEF_RTL_EXPR(LABEL_REF, \"label_ref\", \"u00\", RTX_CONST_OBJ)\n \n-   Or slot2 can not be reserved if slot0 and unit b0 are reserved or\n-   slot1 and unit b1 are reserved .  In this case we could write\n+/* Reference to a named label: \n+   Operand 0: label name\n+   Operand 1: flags (see SYMBOL_FLAG_* in rtl.h)\n+   Operand 2: tree from which this symbol is derived, or null.\n+   This is either a DECL node, or some kind of constant.  */\n+DEF_RTL_EXPR(SYMBOL_REF, \"symbol_ref\", \"s00\", RTX_CONST_OBJ)\n \n-      (absence_set \"slot2\" \"slot0 b0, slot1 b1\")\n+/* The condition code register is represented, in our imagination,\n+   as a register holding a value that can be compared to zero.\n+   In fact, the machine has already compared them and recorded the\n+   results; but instructions that look at the condition code\n+   pretend to be looking at the entire value and comparing it.  */\n+DEF_RTL_EXPR(CC0, \"cc0\", \"\", RTX_OBJ)\n \n-   All CPU functional units in a set should to belong the same\n-   automaton.  */\n-DEF_RTL_EXPR(ABSENCE_SET, \"absence_set\", \"ss\", RTX_EXTRA)\n+/* ----------------------------------------------------------------------\n+   Expressions for operators in an rtl pattern\n+   ---------------------------------------------------------------------- */\n \n-/* (final_absence_set string string) is analogous to `absence_set' but\n-   checking is done on the result (state) reservation.  See comments\n-   for `final_presence_set'.  */\n-DEF_RTL_EXPR(FINAL_ABSENCE_SET, \"final_absence_set\", \"ss\", RTX_EXTRA)\n-\n-/* (define_bypass number out_insn_names in_insn_names) names bypass\n-   with given latency (the first number) from insns given by the first\n-   string (see define_insn_reservation) into insns given by the second\n-   string.  Insn names in the strings are separated by commas.  The\n-   third operand is optional name of function which is additional\n-   guard for the bypass.  The function will get the two insns as\n-   parameters.  If the function returns zero the bypass will be\n-   ignored for this case.  Additional guard is necessary to recognize\n-   complicated bypasses, e.g. when consumer is load address.  */\n-DEF_RTL_EXPR(DEFINE_BYPASS, \"define_bypass\", \"issS\", RTX_EXTRA)\n-\n-/* (define_automaton string) describes names of automata generated and\n-   used for pipeline hazards recognition.  The names are separated by\n-   comma.  Actually it is possibly to generate the single automaton\n-   but unfortunately it can be very large.  If we use more one\n-   automata, the summary size of the automata usually is less than the\n-   single one.  The automaton name is used in define_cpu_unit and\n-   define_query_cpu_unit.  All automata should have unique names.  */\n-DEF_RTL_EXPR(DEFINE_AUTOMATON, \"define_automaton\", \"s\", RTX_EXTRA)\n+/* if_then_else.  This is used in representing ordinary\n+   conditional jump instructions.\n+     Operand:\n+     0:  condition\n+     1:  then expr\n+     2:  else expr */\n+DEF_RTL_EXPR(IF_THEN_ELSE, \"if_then_else\", \"eee\", RTX_TERNARY)\n \n-/* (automata_option string) describes option for generation of\n-   automata.  Currently there are the following options:\n+/* Comparison, produces a condition code result.  */\n+DEF_RTL_EXPR(COMPARE, \"compare\", \"ee\", RTX_BIN_ARITH)\n \n-   o \"no-minimization\" which makes no minimization of automata.  This\n-     is only worth to do when we are debugging the description and\n-     need to look more accurately at reservations of states.\n+/* plus */\n+DEF_RTL_EXPR(PLUS, \"plus\", \"ee\", RTX_COMM_ARITH)\n \n-   o \"time\" which means printing additional time statistics about\n-      generation of automata.\n-  \n-   o \"v\" which means generation of file describing the result\n-     automata.  The file has suffix `.dfa' and can be used for the\n-     description verification and debugging.\n+/* Operand 0 minus operand 1.  */\n+DEF_RTL_EXPR(MINUS, \"minus\", \"ee\", RTX_BIN_ARITH)\n \n-   o \"w\" which means generation of warning instead of error for\n-     non-critical errors.\n+/* Minus operand 0.  */\n+DEF_RTL_EXPR(NEG, \"neg\", \"e\", RTX_UNARY)\n \n-   o \"ndfa\" which makes nondeterministic finite state automata.\n+DEF_RTL_EXPR(MULT, \"mult\", \"ee\", RTX_COMM_ARITH)\n \n-   o \"progress\" which means output of a progress bar showing how many\n-     states were generated so far for automaton being processed.  */\n-DEF_RTL_EXPR(AUTOMATA_OPTION, \"automata_option\", \"s\", RTX_EXTRA)\n+/* Operand 0 divided by operand 1.  */\n+DEF_RTL_EXPR(DIV, \"div\", \"ee\", RTX_BIN_ARITH)\n+/* Remainder of operand 0 divided by operand 1.  */\n+DEF_RTL_EXPR(MOD, \"mod\", \"ee\", RTX_BIN_ARITH)\n \n-/* (define_reservation string string) names reservation (the first\n-   string) of cpu functional units (the 2nd string).  Sometimes unit\n-   reservations for different insns contain common parts.  In such\n-   case, you can describe common part and use its name (the 1st\n-   parameter) in regular expression in define_insn_reservation.  All\n-   define_reservations, define_cpu_units, and define_query_cpu_units\n-   should have unique names which may not be \"nothing\".  */\n-DEF_RTL_EXPR(DEFINE_RESERVATION, \"define_reservation\", \"ss\", RTX_EXTRA)\n+/* Unsigned divide and remainder.  */\n+DEF_RTL_EXPR(UDIV, \"udiv\", \"ee\", RTX_BIN_ARITH)\n+DEF_RTL_EXPR(UMOD, \"umod\", \"ee\", RTX_BIN_ARITH)\n \n-/* (define_insn_reservation name default_latency condition regexpr)\n-   describes reservation of cpu functional units (the 3nd operand) for\n-   instruction which is selected by the condition (the 2nd parameter).\n-   The first parameter is used for output of debugging information.\n-   The reservations are described by a regular expression according\n-   the following syntax:\n+/* Bitwise operations.  */\n+DEF_RTL_EXPR(AND, \"and\", \"ee\", RTX_COMM_ARITH)\n \n-       regexp = regexp \",\" oneof\n-              | oneof\n+DEF_RTL_EXPR(IOR, \"ior\", \"ee\", RTX_COMM_ARITH)\n \n-       oneof = oneof \"|\" allof\n-             | allof\n+DEF_RTL_EXPR(XOR, \"xor\", \"ee\", RTX_COMM_ARITH)\n \n-       allof = allof \"+\" repeat\n-             | repeat\n- \n-       repeat = element \"*\" number\n-              | element\n+DEF_RTL_EXPR(NOT, \"not\", \"e\", RTX_UNARY)\n \n-       element = cpu_function_unit_name\n-               | reservation_name\n-               | result_name\n-               | \"nothing\"\n-               | \"(\" regexp \")\"\n+/* Operand:\n+     0:  value to be shifted.\n+     1:  number of bits.  */\n+DEF_RTL_EXPR(ASHIFT, \"ashift\", \"ee\", RTX_BIN_ARITH) /* shift left */\n+DEF_RTL_EXPR(ROTATE, \"rotate\", \"ee\", RTX_BIN_ARITH) /* rotate left */\n+DEF_RTL_EXPR(ASHIFTRT, \"ashiftrt\", \"ee\", RTX_BIN_ARITH) /* arithmetic shift right */\n+DEF_RTL_EXPR(LSHIFTRT, \"lshiftrt\", \"ee\", RTX_BIN_ARITH) /* logical shift right */\n+DEF_RTL_EXPR(ROTATERT, \"rotatert\", \"ee\", RTX_BIN_ARITH) /* rotate right */\n \n-       1. \",\" is used for describing start of the next cycle in\n-       reservation.\n+/* Minimum and maximum values of two operands.  We need both signed and\n+   unsigned forms.  (We cannot use MIN for SMIN because it conflicts\n+   with a macro of the same name.) */\n \n-       2. \"|\" is used for describing the reservation described by the\n-       first regular expression *or* the reservation described by the\n-       second regular expression *or* etc.\n+DEF_RTL_EXPR(SMIN, \"smin\", \"ee\", RTX_COMM_ARITH)\n+DEF_RTL_EXPR(SMAX, \"smax\", \"ee\", RTX_COMM_ARITH)\n+DEF_RTL_EXPR(UMIN, \"umin\", \"ee\", RTX_COMM_ARITH)\n+DEF_RTL_EXPR(UMAX, \"umax\", \"ee\", RTX_COMM_ARITH)\n \n-       3. \"+\" is used for describing the reservation described by the\n-       first regular expression *and* the reservation described by the\n-       second regular expression *and* etc.\n+/* These unary operations are used to represent incrementation\n+   and decrementation as they occur in memory addresses.\n+   The amount of increment or decrement are not represented\n+   because they can be understood from the machine-mode of the\n+   containing MEM.  These operations exist in only two cases:\n+   1. pushes onto the stack.\n+   2. created automatically by the life_analysis pass in flow.c.  */\n+DEF_RTL_EXPR(PRE_DEC, \"pre_dec\", \"e\", RTX_AUTOINC)\n+DEF_RTL_EXPR(PRE_INC, \"pre_inc\", \"e\", RTX_AUTOINC)\n+DEF_RTL_EXPR(POST_DEC, \"post_dec\", \"e\", RTX_AUTOINC)\n+DEF_RTL_EXPR(POST_INC, \"post_inc\", \"e\", RTX_AUTOINC)\n \n-       4. \"*\" is used for convenience and simply means sequence in\n-       which the regular expression are repeated NUMBER times with\n-       cycle advancing (see \",\").\n+/* These binary operations are used to represent generic address\n+   side-effects in memory addresses, except for simple incrementation\n+   or decrementation which use the above operations.  They are\n+   created automatically by the life_analysis pass in flow.c.\n+   The first operand is a REG which is used as the address.\n+   The second operand is an expression that is assigned to the\n+   register, either before (PRE_MODIFY) or after (POST_MODIFY)\n+   evaluating the address.\n+   Currently, the compiler can only handle second operands of the\n+   form (plus (reg) (reg)) and (plus (reg) (const_int)), where\n+   the first operand of the PLUS has to be the same register as\n+   the first operand of the *_MODIFY.  */\n+DEF_RTL_EXPR(PRE_MODIFY, \"pre_modify\", \"ee\", RTX_AUTOINC)\n+DEF_RTL_EXPR(POST_MODIFY, \"post_modify\", \"ee\", RTX_AUTOINC)\n \n-       5. cpu functional unit name which means its reservation.\n+/* Comparison operations.  The ordered comparisons exist in two\n+   flavors, signed and unsigned.  */\n+DEF_RTL_EXPR(NE, \"ne\", \"ee\", RTX_COMM_COMPARE)\n+DEF_RTL_EXPR(EQ, \"eq\", \"ee\", RTX_COMM_COMPARE)\n+DEF_RTL_EXPR(GE, \"ge\", \"ee\", RTX_COMPARE)\n+DEF_RTL_EXPR(GT, \"gt\", \"ee\", RTX_COMPARE)\n+DEF_RTL_EXPR(LE, \"le\", \"ee\", RTX_COMPARE)\n+DEF_RTL_EXPR(LT, \"lt\", \"ee\", RTX_COMPARE)\n+DEF_RTL_EXPR(GEU, \"geu\", \"ee\", RTX_COMPARE)\n+DEF_RTL_EXPR(GTU, \"gtu\", \"ee\", RTX_COMPARE)\n+DEF_RTL_EXPR(LEU, \"leu\", \"ee\", RTX_COMPARE)\n+DEF_RTL_EXPR(LTU, \"ltu\", \"ee\", RTX_COMPARE)\n \n-       6. reservation name -- see define_reservation.\n+/* Additional floating point unordered comparison flavors.  */\n+DEF_RTL_EXPR(UNORDERED, \"unordered\", \"ee\", RTX_COMM_COMPARE)\n+DEF_RTL_EXPR(ORDERED, \"ordered\", \"ee\", RTX_COMM_COMPARE)\n \n-       7. string \"nothing\" means no units reservation.  */\n+/* These are equivalent to unordered or ...  */\n+DEF_RTL_EXPR(UNEQ, \"uneq\", \"ee\", RTX_COMM_COMPARE)\n+DEF_RTL_EXPR(UNGE, \"unge\", \"ee\", RTX_COMPARE)\n+DEF_RTL_EXPR(UNGT, \"ungt\", \"ee\", RTX_COMPARE)\n+DEF_RTL_EXPR(UNLE, \"unle\", \"ee\", RTX_COMPARE)\n+DEF_RTL_EXPR(UNLT, \"unlt\", \"ee\", RTX_COMPARE)\n \n-DEF_RTL_EXPR(DEFINE_INSN_RESERVATION, \"define_insn_reservation\", \"sies\", RTX_EXTRA)\n+/* This is an ordered NE, ie !UNEQ, ie false for NaN.  */\n+DEF_RTL_EXPR(LTGT, \"ltgt\", \"ee\", RTX_COMM_COMPARE)\n \n-/* ----------------------------------------------------------------------\n-   Expressions used for insn attributes.  These also do not appear in\n-   actual rtl code in the compiler.\n-   ---------------------------------------------------------------------- */\n+/* Represents the result of sign-extending the sole operand.\n+   The machine modes of the operand and of the SIGN_EXTEND expression\n+   determine how much sign-extension is going on.  */\n+DEF_RTL_EXPR(SIGN_EXTEND, \"sign_extend\", \"e\", RTX_UNARY)\n \n-/* Definition of an insn attribute.\n-   1st operand: name of the attribute\n-   2nd operand: comma-separated list of possible attribute values\n-   3rd operand: expression for the default value of the attribute.  */\n-DEF_RTL_EXPR(DEFINE_ATTR, \"define_attr\", \"sse\", RTX_EXTRA)\n+/* Similar for zero-extension (such as unsigned short to int).  */\n+DEF_RTL_EXPR(ZERO_EXTEND, \"zero_extend\", \"e\", RTX_UNARY)\n \n-/* Marker for the name of an attribute.  */\n-DEF_RTL_EXPR(ATTR, \"attr\", \"s\", RTX_EXTRA)\n+/* Similar but here the operand has a wider mode.  */\n+DEF_RTL_EXPR(TRUNCATE, \"truncate\", \"e\", RTX_UNARY)\n \n-/* For use in the last (optional) operand of DEFINE_INSN or DEFINE_PEEPHOLE and\n-   in DEFINE_ASM_INSN to specify an attribute to assign to insns matching that\n-   pattern.\n+/* Similar for extending floating-point values (such as SFmode to DFmode).  */\n+DEF_RTL_EXPR(FLOAT_EXTEND, \"float_extend\", \"e\", RTX_UNARY)\n+DEF_RTL_EXPR(FLOAT_TRUNCATE, \"float_truncate\", \"e\", RTX_UNARY)\n \n-   (set_attr \"name\" \"value\") is equivalent to\n-   (set (attr \"name\") (const_string \"value\"))  */\n-DEF_RTL_EXPR(SET_ATTR, \"set_attr\", \"ss\", RTX_EXTRA)\n+/* Conversion of fixed point operand to floating point value.  */\n+DEF_RTL_EXPR(FLOAT, \"float\", \"e\", RTX_UNARY)\n \n-/* In the last operand of DEFINE_INSN and DEFINE_PEEPHOLE, this can be used to\n-   specify that attribute values are to be assigned according to the\n-   alternative matched.\n+/* With fixed-point machine mode:\n+   Conversion of floating point operand to fixed point value.\n+   Value is defined only when the operand's value is an integer.\n+   With floating-point machine mode (and operand with same mode):\n+   Operand is rounded toward zero to produce an integer value\n+   represented in floating point.  */\n+DEF_RTL_EXPR(FIX, \"fix\", \"e\", RTX_UNARY)\n \n-   The following three expressions are equivalent:\n+/* Conversion of unsigned fixed point operand to floating point value.  */\n+DEF_RTL_EXPR(UNSIGNED_FLOAT, \"unsigned_float\", \"e\", RTX_UNARY)\n \n-   (set (attr \"att\") (cond [(eq_attrq \"alternative\" \"1\") (const_string \"a1\")\n-\t\t\t    (eq_attrq \"alternative\" \"2\") (const_string \"a2\")]\n-\t\t\t   (const_string \"a3\")))\n-   (set_attr_alternative \"att\" [(const_string \"a1\") (const_string \"a2\")\n-\t\t\t\t (const_string \"a3\")])\n-   (set_attr \"att\" \"a1,a2,a3\")\n- */\n-DEF_RTL_EXPR(SET_ATTR_ALTERNATIVE, \"set_attr_alternative\", \"sE\", RTX_EXTRA)\n+/* With fixed-point machine mode:\n+   Conversion of floating point operand to *unsigned* fixed point value.\n+   Value is defined only when the operand's value is an integer.  */\n+DEF_RTL_EXPR(UNSIGNED_FIX, \"unsigned_fix\", \"e\", RTX_UNARY)\n \n-/* A conditional expression true if the value of the specified attribute of\n-   the current insn equals the specified value.  The first operand is the\n-   attribute name and the second is the comparison value.  */\n-DEF_RTL_EXPR(EQ_ATTR, \"eq_attr\", \"ss\", RTX_EXTRA)\n+/* Absolute value */\n+DEF_RTL_EXPR(ABS, \"abs\", \"e\", RTX_UNARY)\n \n-/* A special case of the above representing a set of alternatives.  The first\n-   operand is bitmap of the set, the second one is the default value.  */\n-DEF_RTL_EXPR(EQ_ATTR_ALT, \"eq_attr_alt\", \"ii\", RTX_EXTRA)\n+/* Square root */\n+DEF_RTL_EXPR(SQRT, \"sqrt\", \"e\", RTX_UNARY)\n \n-/* A conditional expression which is true if the specified flag is\n-   true for the insn being scheduled in reorg.\n+/* Find first bit that is set.\n+   Value is 1 + number of trailing zeros in the arg.,\n+   or 0 if arg is 0.  */\n+DEF_RTL_EXPR(FFS, \"ffs\", \"e\", RTX_UNARY)\n \n-   genattr.c defines the following flags which can be tested by\n-   (attr_flag \"foo\") expressions in eligible_for_delay.\n+/* Count leading zeros.  */\n+DEF_RTL_EXPR(CLZ, \"clz\", \"e\", RTX_UNARY)\n \n-   forward, backward, very_likely, likely, very_unlikely, and unlikely.  */\n+/* Count trailing zeros.  */\n+DEF_RTL_EXPR(CTZ, \"ctz\", \"e\", RTX_UNARY)\n \n-DEF_RTL_EXPR (ATTR_FLAG, \"attr_flag\", \"s\", RTX_EXTRA)\n+/* Population count (number of 1 bits).  */\n+DEF_RTL_EXPR(POPCOUNT, \"popcount\", \"e\", RTX_UNARY)\n \n-/* ----------------------------------------------------------------------\n-   Expression types used for things in the instruction chain.\n+/* Population parity (number of 1 bits modulo 2).  */\n+DEF_RTL_EXPR(PARITY, \"parity\", \"e\", RTX_UNARY)\n \n-   All formats must start with \"iuu\" to handle the chain.\n-   Each insn expression holds an rtl instruction and its semantics\n-   during back-end processing.\n-   See macros's in \"rtl.h\" for the meaning of each rtx->u.fld[].\n+/* Reference to a signed bit-field of specified size and position.\n+   Operand 0 is the memory unit (usually SImode or QImode) which\n+   contains the field's first bit.  Operand 1 is the width, in bits.\n+   Operand 2 is the number of bits in the memory unit before the\n+   first bit of this field.\n+   If BITS_BIG_ENDIAN is defined, the first bit is the msb and\n+   operand 2 counts from the msb of the memory unit.\n+   Otherwise, the first bit is the lsb and operand 2 counts from\n+   the lsb of the memory unit.  */\n+DEF_RTL_EXPR(SIGN_EXTRACT, \"sign_extract\", \"eee\", RTX_BITFIELD_OPS)\n \n-   ---------------------------------------------------------------------- */\n+/* Similar for unsigned bit-field.  */\n+DEF_RTL_EXPR(ZERO_EXTRACT, \"zero_extract\", \"eee\", RTX_BITFIELD_OPS)\n \n-/* An instruction that cannot jump.  */\n-DEF_RTL_EXPR(INSN, \"insn\", \"iuuBieiee\", RTX_INSN)\n+/* For RISC machines.  These save memory when splitting insns.  */\n \n-/* An instruction that can possibly jump.\n-   Fields ( rtx->u.fld[] ) have exact same meaning as INSN's.  */\n-DEF_RTL_EXPR(JUMP_INSN, \"jump_insn\", \"iuuBieiee0\", RTX_INSN)\n+/* HIGH are the high-order bits of a constant expression.  */\n+DEF_RTL_EXPR(HIGH, \"high\", \"e\", RTX_CONST_OBJ)\n \n-/* An instruction that can possibly call a subroutine\n-   but which will not change which instruction comes next\n-   in the current function.\n-   Field ( rtx->u.fld[9] ) is CALL_INSN_FUNCTION_USAGE.\n-   All other fields ( rtx->u.fld[] ) have exact same meaning as INSN's.  */\n-DEF_RTL_EXPR(CALL_INSN, \"call_insn\", \"iuuBieieee\", RTX_INSN)\n+/* LO_SUM is the sum of a register and the low-order bits\n+   of a constant expression.  */\n+DEF_RTL_EXPR(LO_SUM, \"lo_sum\", \"ee\", RTX_OBJ)\n \n-/* A marker that indicates that control will not flow through.  */\n-DEF_RTL_EXPR(BARRIER, \"barrier\", \"iuu000000\", RTX_EXTRA)\n+/* Header for range information.  Operand 0 is the NOTE_INSN_RANGE_BEG insn.\n+   Operand 1 is the NOTE_INSN_RANGE_END insn.  Operand 2 is a vector of all of\n+   the registers that can be substituted within this range.  Operand 3 is the\n+   number of calls in the range.  Operand 4 is the number of insns in the\n+   range.  Operand 5 is the unique range number for this range.  Operand 6 is\n+   the basic block # of the start of the live range.  Operand 7 is the basic\n+   block # of the end of the live range.  Operand 8 is the loop depth.  Operand\n+   9 is a bitmap of the registers live at the start of the range.  Operand 10\n+   is a bitmap of the registers live at the end of the range.  Operand 11 is\n+   marker number for the start of the range.  Operand 12 is the marker number\n+   for the end of the range.  */\n+DEF_RTL_EXPR(RANGE_INFO, \"range_info\", \"uuEiiiiiibbii\", RTX_EXTRA)\n \n-/* Holds a label that is followed by instructions.\n-   Operand:\n-   4: is used in jump.c for the use-count of the label.\n-   5: is used in flow.c to point to the chain of label_ref's to this label.\n-   6: is a number that is unique in the entire compilation.\n-   7: is the user-given name of the label, if any.  */\n-DEF_RTL_EXPR(CODE_LABEL, \"code_label\", \"iuuB00is\", RTX_EXTRA)\n+/* Registers that can be substituted within the range.  Operand 0 is the\n+   original pseudo register number.  Operand 1 will be filled in with the\n+   pseudo register the value is copied for the duration of the range.  Operand\n+   2 is the number of references within the range to the register.  Operand 3\n+   is the number of sets or clobbers of the register in the range.  Operand 4\n+   is the number of deaths the register has.  Operand 5 is the copy flags that\n+   give the status of whether a copy is needed from the original register to\n+   the new register at the beginning of the range, or whether a copy from the\n+   new register back to the original at the end of the range.  Operand 6 is the\n+   live length.  Operand 7 is the number of calls that this register is live\n+   across.  Operand 8 is the symbol node of the variable if the register is a\n+   user variable.  Operand 9 is the block node that the variable is declared\n+   in if the register is a user variable.  */\n+DEF_RTL_EXPR(RANGE_REG, \"range_reg\", \"iiiiiiiitt\", RTX_EXTRA)\n \n-#ifdef USE_MAPPED_LOCATION\n-/* Say where in the code a source line starts, for symbol table's sake.\n-   Operand:\n-   4: unused if line number > 0, note-specific data otherwise.\n-   5: line number if > 0, enum note_insn otherwise.\n-   6: CODE_LABEL_NUMBER if line number == NOTE_INSN_DELETED_LABEL.  */\n-#else\n-/* Say where in the code a source line starts, for symbol table's sake.\n-   Operand:\n-   4: filename, if line number > 0, note-specific data otherwise.\n-   5: line number if > 0, enum note_insn otherwise.\n-   6: unique number if line number == note_insn_deleted_label.  */\n-#endif\n-DEF_RTL_EXPR(NOTE, \"note\", \"iuuB0ni\", RTX_EXTRA)\n+/* Information about a local variable's ranges.  Operand 0 is an EXPR_LIST of\n+   the different ranges a variable is in where it is copied to a different\n+   pseudo register.  Operand 1 is the block that the variable is declared in.\n+   Operand 2 is the number of distinct ranges.  */\n+DEF_RTL_EXPR(RANGE_VAR, \"range_var\", \"eti\", RTX_EXTRA)\n \n-/* ----------------------------------------------------------------------\n-   Top level constituents of INSN, JUMP_INSN and CALL_INSN.\n-   ---------------------------------------------------------------------- */\n-   \n-/* Conditionally execute code.\n-   Operand 0 is the condition that if true, the code is executed.\n-   Operand 1 is the code to be executed (typically a SET). \n+/* Information about the registers that are live at the current point.  Operand\n+   0 is the live bitmap.  Operand 1 is the original block number.  */\n+DEF_RTL_EXPR(RANGE_LIVE, \"range_live\", \"bi\", RTX_EXTRA)\n \n-   Semantics are that there are no side effects if the condition\n-   is false.  This pattern is created automatically by the if_convert\n-   pass run after reload or by target-specific splitters.  */\n-DEF_RTL_EXPR(COND_EXEC, \"cond_exec\", \"ee\", RTX_EXTRA)\n+/* Describes a merge operation between two vector values.\n+   Operands 0 and 1 are the vectors to be merged, operand 2 is a bitmask\n+   that specifies where the parts of the result are taken from.  Set bits\n+   indicate operand 0, clear bits indicate operand 1.  The parts are defined\n+   by the mode of the vectors.  */\n+DEF_RTL_EXPR(VEC_MERGE, \"vec_merge\", \"eee\", RTX_TERNARY)\n \n-/* Several operations to be done in parallel (perhaps under COND_EXEC).  */\n-DEF_RTL_EXPR(PARALLEL, \"parallel\", \"E\", RTX_EXTRA)\n+/* Describes an operation that selects parts of a vector.\n+   Operands 0 is the source vector, operand 1 is a PARALLEL that contains\n+   a CONST_INT for each of the subparts of the result vector, giving the\n+   number of the source subpart that should be stored into it.  */\n+DEF_RTL_EXPR(VEC_SELECT, \"vec_select\", \"ee\", RTX_BIN_ARITH)\n \n-/* A string that is passed through to the assembler as input.\n-     One can obviously pass comments through by using the\n-     assembler comment syntax.\n-     These occur in an insn all by themselves as the PATTERN.\n-     They also appear inside an ASM_OPERANDS\n-     as a convenient way to hold a string.  */\n-DEF_RTL_EXPR(ASM_INPUT, \"asm_input\", \"s\", RTX_EXTRA)\n+/* Describes a vector concat operation.  Operands 0 and 1 are the source\n+   vectors, the result is a vector that is as long as operands 0 and 1\n+   combined and is the concatenation of the two source vectors.  */\n+DEF_RTL_EXPR(VEC_CONCAT, \"vec_concat\", \"ee\", RTX_BIN_ARITH)\n \n-#ifdef USE_MAPPED_LOCATION\n-/* An assembler instruction with operands.\n-   1st operand is the instruction template.\n-   2nd operand is the constraint for the output.\n-   3rd operand is the number of the output this expression refers to.\n-     When an insn stores more than one value, a separate ASM_OPERANDS\n-     is made for each output; this integer distinguishes them.\n-   4th is a vector of values of input operands.\n-   5th is a vector of modes and constraints for the input operands.\n-     Each element is an ASM_INPUT containing a constraint string\n-     and whose mode indicates the mode of the input operand.\n-   6th is the source line number.  */\n-DEF_RTL_EXPR(ASM_OPERANDS, \"asm_operands\", \"ssiEEi\", RTX_EXTRA)\n-#else\n-/* An assembler instruction with operands.\n-   1st operand is the instruction template.\n-   2nd operand is the constraint for the output.\n-   3rd operand is the number of the output this expression refers to.\n-     When an insn stores more than one value, a separate ASM_OPERANDS\n-     is made for each output; this integer distinguishes them.\n-   4th is a vector of values of input operands.\n-   5th is a vector of modes and constraints for the input operands.\n-     Each element is an ASM_INPUT containing a constraint string\n-     and whose mode indicates the mode of the input operand.\n-   6th is the name of the containing source file.\n-   7th is the source line number.  */\n-DEF_RTL_EXPR(ASM_OPERANDS, \"asm_operands\", \"ssiEEsi\", RTX_EXTRA)\n-#endif\n+/* Describes an operation that converts a small vector into a larger one by\n+   duplicating the input values.  The output vector mode must have the same\n+   submodes as the input vector mode, and the number of output parts must be\n+   an integer multiple of the number of input parts.  */\n+DEF_RTL_EXPR(VEC_DUPLICATE, \"vec_duplicate\", \"e\", RTX_UNARY)\n+     \n+/* Addition with signed saturation */\n+DEF_RTL_EXPR(SS_PLUS, \"ss_plus\", \"ee\", RTX_COMM_ARITH)\n \n-/* A machine-specific operation.\n-   1st operand is a vector of operands being used by the operation so that\n-     any needed reloads can be done.\n-   2nd operand is a unique value saying which of a number of machine-specific\n-     operations is to be performed.\n-   (Note that the vector must be the first operand because of the way that\n-   genrecog.c record positions within an insn.)\n-   This can occur all by itself in a PATTERN, as a component of a PARALLEL,\n-   or inside an expression.  */\n-DEF_RTL_EXPR(UNSPEC, \"unspec\", \"Ei\", RTX_EXTRA)\n+/* Addition with unsigned saturation */\n+DEF_RTL_EXPR(US_PLUS, \"us_plus\", \"ee\", RTX_COMM_ARITH)\n \n-/* Similar, but a volatile operation and one which may trap.  */\n-DEF_RTL_EXPR(UNSPEC_VOLATILE, \"unspec_volatile\", \"Ei\", RTX_EXTRA)\n+/* Operand 0 minus operand 1, with signed saturation.  */\n+DEF_RTL_EXPR(SS_MINUS, \"ss_minus\", \"ee\", RTX_BIN_ARITH)\n \n-/* Vector of addresses, stored as full words.  */\n-/* Each element is a LABEL_REF to a CODE_LABEL whose address we want.  */\n-DEF_RTL_EXPR(ADDR_VEC, \"addr_vec\", \"E\", RTX_EXTRA)\n+/* Operand 0 minus operand 1, with unsigned saturation.  */\n+DEF_RTL_EXPR(US_MINUS, \"us_minus\", \"ee\", RTX_BIN_ARITH)\n \n-/* Vector of address differences X0 - BASE, X1 - BASE, ...\n-   First operand is BASE; the vector contains the X's.\n-   The machine mode of this rtx says how much space to leave\n-   for each difference and is adjusted by branch shortening if\n-   CASE_VECTOR_SHORTEN_MODE is defined.\n-   The third and fourth operands store the target labels with the\n-   minimum and maximum addresses respectively.\n-   The fifth operand stores flags for use by branch shortening.\n-  Set at the start of shorten_branches:\n-   min_align: the minimum alignment for any of the target labels.\n-   base_after_vec: true iff BASE is after the ADDR_DIFF_VEC.\n-   min_after_vec: true iff minimum addr target label is after the ADDR_DIFF_VEC.\n-   max_after_vec: true iff maximum addr target label is after the ADDR_DIFF_VEC.\n-   min_after_base: true iff minimum address target label is after BASE.\n-   max_after_base: true iff maximum address target label is after BASE.\n-  Set by the actual branch shortening process:\n-   offset_unsigned: true iff offsets have to be treated as unsigned.\n-   scale: scaling that is necessary to make offsets fit into the mode.\n+/* Signed saturating truncate.  */\n+DEF_RTL_EXPR(SS_TRUNCATE, \"ss_truncate\", \"e\", RTX_UNARY)\n \n-   The third, fourth and fifth operands are only valid when\n-   CASE_VECTOR_SHORTEN_MODE is defined, and only in an optimizing\n-   compilations.  */\n-     \n-DEF_RTL_EXPR(ADDR_DIFF_VEC, \"addr_diff_vec\", \"eEee0\", RTX_EXTRA)\n+/* Unsigned saturating truncate.  */\n+DEF_RTL_EXPR(US_TRUNCATE, \"us_truncate\", \"e\", RTX_UNARY)\n \n-/* Memory prefetch, with attributes supported on some targets.\n-   Operand 1 is the address of the memory to fetch.\n-   Operand 2 is 1 for a write access, 0 otherwise.\n-   Operand 3 is the level of temporal locality; 0 means there is no\n-   temporal locality and 1, 2, and 3 are for increasing levels of temporal\n-   locality.\n+/* Information about the variable and its location.  */\n+DEF_RTL_EXPR(VAR_LOCATION, \"var_location\", \"te\", RTX_EXTRA)\n \n-   The attributes specified by operands 2 and 3 are ignored for targets\n-   whose prefetch instructions do not support them.  */\n-DEF_RTL_EXPR(PREFETCH, \"prefetch\", \"eee\", RTX_EXTRA)\n+/* All expressions from this point forward appear only in machine\n+   descriptions.  */\n \n-/* ----------------------------------------------------------------------\n-   At the top level of an instruction (perhaps under PARALLEL).\n-   ---------------------------------------------------------------------- */\n+/* Include a secondary machine-description file at this point.  */\n+DEF_RTL_EXPR(INCLUDE, \"include\", \"s\", RTX_EXTRA)\n \n-/* Assignment.\n-   Operand 1 is the location (REG, MEM, PC, CC0 or whatever) assigned to.\n-   Operand 2 is the value stored there.\n-   ALL assignment must use SET.\n-   Instructions that do multiple assignments must use multiple SET,\n-   under PARALLEL.  */\n-DEF_RTL_EXPR(SET, \"set\", \"ee\", RTX_EXTRA)\n+/* Pattern-matching operators:  */\n \n-/* Indicate something is used in a way that we don't want to explain.\n-   For example, subroutine calls will use the register\n-   in which the static chain is passed.  */\n-DEF_RTL_EXPR(USE, \"use\", \"e\", RTX_EXTRA)\n+/* Use the function named by the second arg (the string)\n+   as a predicate; if matched, store the structure that was matched\n+   in the operand table at index specified by the first arg (the integer).\n+   If the second arg is the null string, the structure is just stored.\n \n-/* Indicate something is clobbered in a way that we don't want to explain.\n-   For example, subroutine calls will clobber some physical registers\n-   (the ones that are by convention not saved).  */\n-DEF_RTL_EXPR(CLOBBER, \"clobber\", \"e\", RTX_EXTRA)\n+   A third string argument indicates to the register allocator restrictions\n+   on where the operand can be allocated.\n \n-/* Call a subroutine.\n-   Operand 1 is the address to call.\n-   Operand 2 is the number of arguments.  */\n+   If the target needs no restriction on any instruction this field should\n+   be the null string.\n \n-DEF_RTL_EXPR(CALL, \"call\", \"ee\", RTX_EXTRA)\n+   The string is prepended by:\n+   '=' to indicate the operand is only written to.\n+   '+' to indicate the operand is both read and written to.\n \n-/* Return from a subroutine.  */\n+   Each character in the string represents an allocable class for an operand.\n+   'g' indicates the operand can be any valid class.\n+   'i' indicates the operand can be immediate (in the instruction) data.\n+   'r' indicates the operand can be in a register.\n+   'm' indicates the operand can be in memory.\n+   'o' a subset of the 'm' class.  Those memory addressing modes that\n+       can be offset at compile time (have a constant added to them).\n \n-DEF_RTL_EXPR(RETURN, \"return\", \"\", RTX_EXTRA)\n+   Other characters indicate target dependent operand classes and\n+   are described in each target's machine description.\n \n-/* Conditional trap.\n-   Operand 1 is the condition.\n-   Operand 2 is the trap code.\n-   For an unconditional trap, make the condition (const_int 1).  */\n-DEF_RTL_EXPR(TRAP_IF, \"trap_if\", \"ee\", RTX_EXTRA)\n+   For instructions with more than one operand, sets of classes can be\n+   separated by a comma to indicate the appropriate multi-operand constraints.\n+   There must be a 1 to 1 correspondence between these sets of classes in\n+   all operands for an instruction.\n+   */\n+DEF_RTL_EXPR(MATCH_OPERAND, \"match_operand\", \"iss\", RTX_MATCH)\n \n-/* Placeholder for _Unwind_Resume before we know if a function call\n-   or a branch is needed.  Operand 1 is the exception region from\n-   which control is flowing.  */\n-DEF_RTL_EXPR(RESX, \"resx\", \"i\", RTX_EXTRA)\n+/* Match a SCRATCH or a register.  When used to generate rtl, a\n+   SCRATCH is generated.  As for MATCH_OPERAND, the mode specifies\n+   the desired mode and the first argument is the operand number.\n+   The second argument is the constraint.  */\n+DEF_RTL_EXPR(MATCH_SCRATCH, \"match_scratch\", \"is\", RTX_MATCH)\n \n-/* ----------------------------------------------------------------------\n-   Primitive values for use in expressions.\n-   ---------------------------------------------------------------------- */\n+/* Apply a predicate, AND match recursively the operands of the rtx.\n+   Operand 0 is the operand-number, as in match_operand.\n+   Operand 1 is a predicate to apply (as a string, a function name).\n+   Operand 2 is a vector of expressions, each of which must match\n+   one subexpression of the rtx this construct is matching.  */\n+DEF_RTL_EXPR(MATCH_OPERATOR, \"match_operator\", \"isE\", RTX_MATCH)\n \n-/* numeric integer constant */\n-DEF_RTL_EXPR(CONST_INT, \"const_int\", \"w\", RTX_CONST_OBJ)\n+/* Match a PARALLEL of arbitrary length.  The predicate is applied\n+   to the PARALLEL and the initial expressions in the PARALLEL are matched.\n+   Operand 0 is the operand-number, as in match_operand.\n+   Operand 1 is a predicate to apply to the PARALLEL.\n+   Operand 2 is a vector of expressions, each of which must match the \n+   corresponding element in the PARALLEL.  */\n+DEF_RTL_EXPR(MATCH_PARALLEL, \"match_parallel\", \"isE\", RTX_MATCH)\n \n-/* numeric floating point constant.\n-   Operands hold the value.  They are all 'w' and there may be from 2 to 6;\n-   see real.h.  */\n-DEF_RTL_EXPR(CONST_DOUBLE, \"const_double\", CONST_DOUBLE_FORMAT, RTX_CONST_OBJ)\n+/* Match only something equal to what is stored in the operand table\n+   at the index specified by the argument.  Use with MATCH_OPERAND.  */\n+DEF_RTL_EXPR(MATCH_DUP, \"match_dup\", \"i\", RTX_MATCH)\n \n-/* Describes a vector constant.  */\n-DEF_RTL_EXPR(CONST_VECTOR, \"const_vector\", \"E\", RTX_EXTRA)\n+/* Match only something equal to what is stored in the operand table\n+   at the index specified by the argument.  Use with MATCH_OPERATOR.  */\n+DEF_RTL_EXPR(MATCH_OP_DUP, \"match_op_dup\", \"iE\", RTX_MATCH)\n \n-/* String constant.  Used only for attributes right now.  */\n-DEF_RTL_EXPR(CONST_STRING, \"const_string\", \"s\", RTX_OBJ)\n+/* Match only something equal to what is stored in the operand table\n+   at the index specified by the argument.  Use with MATCH_PARALLEL.  */\n+DEF_RTL_EXPR(MATCH_PAR_DUP, \"match_par_dup\", \"iE\", RTX_MATCH)\n \n-/* This is used to encapsulate an expression whose value is constant\n-   (such as the sum of a SYMBOL_REF and a CONST_INT) so that it will be\n-   recognized as a constant operand rather than by arithmetic instructions.  */\n+/* Appears only in define_predicate/define_special_predicate\n+   expressions.  Evaluates true only if the operand has an RTX code\n+   from the set given by the argument (a comma-separated list).  */\n+DEF_RTL_EXPR(MATCH_CODE, \"match_code\", \"s\", RTX_MATCH)\n \n-DEF_RTL_EXPR(CONST, \"const\", \"e\", RTX_CONST_OBJ)\n+/* Appears only in define_predicate/define_special_predicate\n+    expressions.  The argument is a C expression to be injected at this\n+    point in the predicate formula.  */\n+DEF_RTL_EXPR(MATCH_TEST, \"match_test\", \"s\", RTX_MATCH)\n \n-/* program counter.  Ordinary jumps are represented\n-   by a SET whose first operand is (PC).  */\n-DEF_RTL_EXPR(PC, \"pc\", \"\", RTX_OBJ)\n+/* Insn (and related) definitions.  */\n \n-/* Used in the cselib routines to describe a value.  */\n-DEF_RTL_EXPR(VALUE, \"value\", \"0\", RTX_OBJ)\n+/* Definition of the pattern for one kind of instruction.\n+   Operand:\n+   0: names this instruction.\n+      If the name is the null string, the instruction is in the\n+      machine description just to be recognized, and will never be emitted by\n+      the tree to rtl expander.\n+   1: is the pattern.\n+   2: is a string which is a C expression\n+      giving an additional condition for recognizing this pattern.\n+      A null string means no extra condition.\n+   3: is the action to execute if this pattern is matched.\n+      If this assembler code template starts with a * then it is a fragment of\n+      C code to run to decide on a template to use.  Otherwise, it is the\n+      template to use.\n+   4: optionally, a vector of attributes for this insn.\n+     */\n+DEF_RTL_EXPR(DEFINE_INSN, \"define_insn\", \"sEsTV\", RTX_EXTRA)\n \n-/* A register.  The \"operand\" is the register number, accessed with\n-   the REGNO macro.  If this number is less than FIRST_PSEUDO_REGISTER\n-   than a hardware register is being referred to.  The second operand\n-   holds the original register number - this will be different for a\n-   pseudo register that got turned into a hard register.\n-   This rtx needs to have as many (or more) fields as a MEM, since we\n-   can change REG rtx's into MEMs during reload.  */\n-DEF_RTL_EXPR(REG, \"reg\", \"i00\", RTX_OBJ)\n+/* Definition of a peephole optimization.\n+   1st operand: vector of insn patterns to match\n+   2nd operand: C expression that must be true\n+   3rd operand: template or C code to produce assembler output.\n+   4: optionally, a vector of attributes for this insn.\n \n-/* A scratch register.  This represents a register used only within a\n-   single insn.  It will be turned into a REG during register allocation\n-   or reload unless the constraint indicates that the register won't be\n-   needed, in which case it can remain a SCRATCH.  This code is\n-   marked as having one operand so it can be turned into a REG.  */\n-DEF_RTL_EXPR(SCRATCH, \"scratch\", \"0\", RTX_OBJ)\n+   This form is deprecated; use define_peephole2 instead.  */\n+DEF_RTL_EXPR(DEFINE_PEEPHOLE, \"define_peephole\", \"EsTV\", RTX_EXTRA)\n \n-/* One word of a multi-word value.\n-   The first operand is the complete value; the second says which word.\n-   The WORDS_BIG_ENDIAN flag controls whether word number 0\n-   (as numbered in a SUBREG) is the most or least significant word.\n+/* Definition of a split operation.\n+   1st operand: insn pattern to match\n+   2nd operand: C expression that must be true\n+   3rd operand: vector of insn patterns to place into a SEQUENCE\n+   4th operand: optionally, some C code to execute before generating the\n+\tinsns.  This might, for example, create some RTX's and store them in\n+\telements of `recog_data.operand' for use by the vector of\n+\tinsn-patterns.\n+\t(`operands' is an alias here for `recog_data.operand').  */\n+DEF_RTL_EXPR(DEFINE_SPLIT, \"define_split\", \"EsES\", RTX_EXTRA)\n+\n+/* Definition of an insn and associated split.\n+   This is the concatenation, with a few modifications, of a define_insn\n+   and a define_split which share the same pattern.\n+   Operand:\n+   0: names this instruction.\n+      If the name is the null string, the instruction is in the\n+      machine description just to be recognized, and will never be emitted by\n+      the tree to rtl expander.\n+   1: is the pattern.\n+   2: is a string which is a C expression\n+      giving an additional condition for recognizing this pattern.\n+      A null string means no extra condition.\n+   3: is the action to execute if this pattern is matched.\n+      If this assembler code template starts with a * then it is a fragment of\n+      C code to run to decide on a template to use.  Otherwise, it is the\n+      template to use.\n+   4: C expression that must be true for split.  This may start with \"&&\"\n+      in which case the split condition is the logical and of the insn \n+      condition and what follows the \"&&\" of this operand.\n+   5: vector of insn patterns to place into a SEQUENCE\n+   6: optionally, some C code to execute before generating the\n+\tinsns.  This might, for example, create some RTX's and store them in\n+\telements of `recog_data.operand' for use by the vector of\n+\tinsn-patterns.\n+\t(`operands' is an alias here for `recog_data.operand').  \n+   7: optionally, a vector of attributes for this insn.  */\n+DEF_RTL_EXPR(DEFINE_INSN_AND_SPLIT, \"define_insn_and_split\", \"sEsTsESV\", RTX_EXTRA)\n+\n+/* Definition of an RTL peephole operation.\n+   Follows the same arguments as define_split.  */\n+DEF_RTL_EXPR(DEFINE_PEEPHOLE2, \"define_peephole2\", \"EsES\", RTX_EXTRA)\n+\n+/* Define how to generate multiple insns for a standard insn name.\n+   1st operand: the insn name.\n+   2nd operand: vector of insn-patterns.\n+\tUse match_operand to substitute an element of `recog_data.operand'.\n+   3rd operand: C expression that must be true for this to be available.\n+\tThis may not test any operands.\n+   4th operand: Extra C code to execute before generating the insns.\n+\tThis might, for example, create some RTX's and store them in\n+\telements of `recog_data.operand' for use by the vector of\n+\tinsn-patterns.\n+\t(`operands' is an alias here for `recog_data.operand').  */\n+DEF_RTL_EXPR(DEFINE_EXPAND, \"define_expand\", \"sEss\", RTX_EXTRA)\n+   \n+/* Define a requirement for delay slots.\n+   1st operand: Condition involving insn attributes that, if true,\n+\t        indicates that the insn requires the number of delay slots\n+\t\tshown.\n+   2nd operand: Vector whose length is the three times the number of delay\n+\t\tslots required.\n+\t        Each entry gives three conditions, each involving attributes.\n+\t\tThe first must be true for an insn to occupy that delay slot\n+\t\tlocation.  The second is true for all insns that can be\n+\t\tannulled if the branch is true and the third is true for all\n+\t\tinsns that can be annulled if the branch is false. \n \n-   This is also used to refer to a value in a different machine mode.\n-   For example, it can be used to refer to a SImode value as if it were\n-   Qimode, or vice versa.  Then the word number is always 0.  */\n-DEF_RTL_EXPR(SUBREG, \"subreg\", \"ei\", RTX_EXTRA)\n+   Multiple DEFINE_DELAYs may be present.  They indicate differing\n+   requirements for delay slots.  */\n+DEF_RTL_EXPR(DEFINE_DELAY, \"define_delay\", \"eE\", RTX_EXTRA)\n \n-/* This one-argument rtx is used for move instructions\n-   that are guaranteed to alter only the low part of a destination.\n-   Thus, (SET (SUBREG:HI (REG...)) (MEM:HI ...))\n-   has an unspecified effect on the high part of REG,\n-   but (SET (STRICT_LOW_PART (SUBREG:HI (REG...))) (MEM:HI ...))\n-   is guaranteed to alter only the bits of REG that are in HImode.\n+/* Define attribute computation for `asm' instructions.  */\n+DEF_RTL_EXPR(DEFINE_ASM_ATTRIBUTES, \"define_asm_attributes\", \"V\", RTX_EXTRA)\n \n-   The actual instruction used is probably the same in both cases,\n-   but the register constraints may be tighter when STRICT_LOW_PART\n-   is in use.  */\n+/* Definition of a conditional execution meta operation.  Automatically\n+   generates new instances of DEFINE_INSN, selected by having attribute\n+   \"predicable\" true.  The new pattern will contain a COND_EXEC and the\n+   predicate at top-level.\n \n-DEF_RTL_EXPR(STRICT_LOW_PART, \"strict_low_part\", \"e\", RTX_EXTRA)\n+   Operand:\n+   0: The predicate pattern.  The top-level form should match a\n+      relational operator.  Operands should have only one alternative.\n+   1: A C expression giving an additional condition for recognizing\n+      the generated pattern.\n+   2: A template or C code to produce assembler output.  */\n+DEF_RTL_EXPR(DEFINE_COND_EXEC, \"define_cond_exec\", \"Ess\", RTX_EXTRA)\n \n-/* (CONCAT a b) represents the virtual concatenation of a and b\n-   to make a value that has as many bits as a and b put together.\n-   This is used for complex values.  Normally it appears only\n-   in DECL_RTLs and during RTL generation, but not in the insn chain.  */\n-DEF_RTL_EXPR(CONCAT, \"concat\", \"ee\", RTX_OBJ)\n+/* Definition of an operand predicate.  The difference between\n+   DEFINE_PREDICATE and DEFINE_SPECIAL_PREDICATE is that genrecog will\n+   not warn about a match_operand with no mode if it has a predicate\n+   defined with DEFINE_SPECIAL_PREDICATE.\n \n-/* A memory location; operand is the address.  The second operand is the\n-   alias set to which this MEM belongs.  We use `0' instead of `w' for this\n-   field so that the field need not be specified in machine descriptions.  */\n-DEF_RTL_EXPR(MEM, \"mem\", \"e0\", RTX_OBJ)\n+   Operand:\n+   0: The name of the predicate.\n+   1: A boolean expression which computes whether or not the predicate\n+      matches.  This expression can use IOR, AND, NOT, MATCH_OPERAND,\n+      MATCH_CODE, and MATCH_TEST.  It must be specific enough that genrecog\n+      can calculate the set of RTX codes that can possibly match.\n+   2: A C function body which must return true for the predicate to match.\n+      Optional.  Use this when the test is too complicated to fit into a\n+      match_test expression.  */\n+DEF_RTL_EXPR(DEFINE_PREDICATE, \"define_predicate\", \"ses\", RTX_EXTRA)\n+DEF_RTL_EXPR(DEFINE_SPECIAL_PREDICATE, \"define_special_predicate\", \"ses\", RTX_EXTRA)\n \n-/* Reference to an assembler label in the code for this function.\n-   The operand is a CODE_LABEL found in the insn chain.\n-   The unprinted fields 1 and 2 are used in flow.c for the\n-   LABEL_NEXTREF and CONTAINING_INSN.  */\n-DEF_RTL_EXPR(LABEL_REF, \"label_ref\", \"u00\", RTX_CONST_OBJ)\n+/* Constructions for CPU pipeline description described by NDFAs.  */\n \n-/* Reference to a named label: \n-   Operand 0: label name\n-   Operand 1: flags (see SYMBOL_FLAG_* in rtl.h)\n-   Operand 2: tree from which this symbol is derived, or null.\n-   This is either a DECL node, or some kind of constant.  */\n-DEF_RTL_EXPR(SYMBOL_REF, \"symbol_ref\", \"s00\", RTX_CONST_OBJ)\n+/* (define_cpu_unit string [string]) describes cpu functional\n+   units (separated by comma).\n \n-/* The condition code register is represented, in our imagination,\n-   as a register holding a value that can be compared to zero.\n-   In fact, the machine has already compared them and recorded the\n-   results; but instructions that look at the condition code\n-   pretend to be looking at the entire value and comparing it.  */\n-DEF_RTL_EXPR(CC0, \"cc0\", \"\", RTX_OBJ)\n+   1st operand: Names of cpu functional units.\n+   2nd operand: Name of automaton (see comments for DEFINE_AUTOMATON).\n \n-/* ----------------------------------------------------------------------\n-   Expressions for operators in an rtl pattern\n-   ---------------------------------------------------------------------- */\n+   All define_reservations, define_cpu_units, and\n+   define_query_cpu_units should have unique names which may not be\n+   \"nothing\".  */\n+DEF_RTL_EXPR(DEFINE_CPU_UNIT, \"define_cpu_unit\", \"sS\", RTX_EXTRA)\n \n-/* if_then_else.  This is used in representing ordinary\n-   conditional jump instructions.\n-     Operand:\n-     0:  condition\n-     1:  then expr\n-     2:  else expr */\n-DEF_RTL_EXPR(IF_THEN_ELSE, \"if_then_else\", \"eee\", RTX_TERNARY)\n+/* (define_query_cpu_unit string [string]) describes cpu functional\n+   units analogously to define_cpu_unit.  The reservation of such\n+   units can be queried for automaton state.  */\n+DEF_RTL_EXPR(DEFINE_QUERY_CPU_UNIT, \"define_query_cpu_unit\", \"sS\", RTX_EXTRA)\n \n-/* General conditional. The first operand is a vector composed of pairs of\n-   expressions.  The first element of each pair is evaluated, in turn.\n-   The value of the conditional is the second expression of the first pair\n-   whose first expression evaluates nonzero.  If none of the expressions is\n-   true, the second operand will be used as the value of the conditional.\n+/* (exclusion_set string string) means that each CPU functional unit\n+   in the first string can not be reserved simultaneously with any\n+   unit whose name is in the second string and vise versa.  CPU units\n+   in the string are separated by commas.  For example, it is useful\n+   for description CPU with fully pipelined floating point functional\n+   unit which can execute simultaneously only single floating point\n+   insns or only double floating point insns.  All CPU functional\n+   units in a set should belong to the same automaton.  */\n+DEF_RTL_EXPR(EXCLUSION_SET, \"exclusion_set\", \"ss\", RTX_EXTRA)\n \n-   This should be replaced with use of IF_THEN_ELSE.  */\n-DEF_RTL_EXPR(COND, \"cond\", \"Ee\", RTX_EXTRA)\n+/* (presence_set string string) means that each CPU functional unit in\n+   the first string can not be reserved unless at least one of pattern\n+   of units whose names are in the second string is reserved.  This is\n+   an asymmetric relation.  CPU units or unit patterns in the strings\n+   are separated by commas.  Pattern is one unit name or unit names\n+   separated by white-spaces.\n+ \n+   For example, it is useful for description that slot1 is reserved\n+   after slot0 reservation for a VLIW processor.  We could describe it\n+   by the following construction\n \n-/* Comparison, produces a condition code result.  */\n-DEF_RTL_EXPR(COMPARE, \"compare\", \"ee\", RTX_BIN_ARITH)\n+      (presence_set \"slot1\" \"slot0\")\n \n-/* plus */\n-DEF_RTL_EXPR(PLUS, \"plus\", \"ee\", RTX_COMM_ARITH)\n+   Or slot1 is reserved only after slot0 and unit b0 reservation.  In\n+   this case we could write\n \n-/* Operand 0 minus operand 1.  */\n-DEF_RTL_EXPR(MINUS, \"minus\", \"ee\", RTX_BIN_ARITH)\n+      (presence_set \"slot1\" \"slot0 b0\")\n \n-/* Minus operand 0.  */\n-DEF_RTL_EXPR(NEG, \"neg\", \"e\", RTX_UNARY)\n+   All CPU functional units in a set should belong to the same\n+   automaton.  */\n+DEF_RTL_EXPR(PRESENCE_SET, \"presence_set\", \"ss\", RTX_EXTRA)\n \n-DEF_RTL_EXPR(MULT, \"mult\", \"ee\", RTX_COMM_ARITH)\n+/* (final_presence_set string string) is analogous to `presence_set'.\n+   The difference between them is when checking is done.  When an\n+   instruction is issued in given automaton state reflecting all\n+   current and planned unit reservations, the automaton state is\n+   changed.  The first state is a source state, the second one is a\n+   result state.  Checking for `presence_set' is done on the source\n+   state reservation, checking for `final_presence_set' is done on the\n+   result reservation.  This construction is useful to describe a\n+   reservation which is actually two subsequent reservations.  For\n+   example, if we use \n \n-/* Operand 0 divided by operand 1.  */\n-DEF_RTL_EXPR(DIV, \"div\", \"ee\", RTX_BIN_ARITH)\n-/* Remainder of operand 0 divided by operand 1.  */\n-DEF_RTL_EXPR(MOD, \"mod\", \"ee\", RTX_BIN_ARITH)\n+      (presence_set \"slot1\" \"slot0\")\n \n-/* Unsigned divide and remainder.  */\n-DEF_RTL_EXPR(UDIV, \"udiv\", \"ee\", RTX_BIN_ARITH)\n-DEF_RTL_EXPR(UMOD, \"umod\", \"ee\", RTX_BIN_ARITH)\n+   the following insn will be never issued (because slot1 requires\n+   slot0 which is absent in the source state).\n \n-/* Bitwise operations.  */\n-DEF_RTL_EXPR(AND, \"and\", \"ee\", RTX_COMM_ARITH)\n+      (define_reservation \"insn_and_nop\" \"slot0 + slot1\")\n \n-DEF_RTL_EXPR(IOR, \"ior\", \"ee\", RTX_COMM_ARITH)\n+   but it can be issued if we use analogous `final_presence_set'.  */\n+DEF_RTL_EXPR(FINAL_PRESENCE_SET, \"final_presence_set\", \"ss\", RTX_EXTRA)\n \n-DEF_RTL_EXPR(XOR, \"xor\", \"ee\", RTX_COMM_ARITH)\n+/* (absence_set string string) means that each CPU functional unit in\n+   the first string can be reserved only if each pattern of units\n+   whose names are in the second string is not reserved.  This is an\n+   asymmetric relation (actually exclusion set is analogous to this\n+   one but it is symmetric).  CPU units or unit patterns in the string\n+   are separated by commas.  Pattern is one unit name or unit names\n+   separated by white-spaces.\n \n-DEF_RTL_EXPR(NOT, \"not\", \"e\", RTX_UNARY)\n+   For example, it is useful for description that slot0 can not be\n+   reserved after slot1 or slot2 reservation for a VLIW processor.  We\n+   could describe it by the following construction\n \n-/* Operand:\n-     0:  value to be shifted.\n-     1:  number of bits.  */\n-DEF_RTL_EXPR(ASHIFT, \"ashift\", \"ee\", RTX_BIN_ARITH) /* shift left */\n-DEF_RTL_EXPR(ROTATE, \"rotate\", \"ee\", RTX_BIN_ARITH) /* rotate left */\n-DEF_RTL_EXPR(ASHIFTRT, \"ashiftrt\", \"ee\", RTX_BIN_ARITH) /* arithmetic shift right */\n-DEF_RTL_EXPR(LSHIFTRT, \"lshiftrt\", \"ee\", RTX_BIN_ARITH) /* logical shift right */\n-DEF_RTL_EXPR(ROTATERT, \"rotatert\", \"ee\", RTX_BIN_ARITH) /* rotate right */\n+      (absence_set \"slot2\" \"slot0, slot1\")\n \n-/* Minimum and maximum values of two operands.  We need both signed and\n-   unsigned forms.  (We cannot use MIN for SMIN because it conflicts\n-   with a macro of the same name.) */\n+   Or slot2 can not be reserved if slot0 and unit b0 are reserved or\n+   slot1 and unit b1 are reserved .  In this case we could write\n \n-DEF_RTL_EXPR(SMIN, \"smin\", \"ee\", RTX_COMM_ARITH)\n-DEF_RTL_EXPR(SMAX, \"smax\", \"ee\", RTX_COMM_ARITH)\n-DEF_RTL_EXPR(UMIN, \"umin\", \"ee\", RTX_COMM_ARITH)\n-DEF_RTL_EXPR(UMAX, \"umax\", \"ee\", RTX_COMM_ARITH)\n+      (absence_set \"slot2\" \"slot0 b0, slot1 b1\")\n \n-/* These unary operations are used to represent incrementation\n-   and decrementation as they occur in memory addresses.\n-   The amount of increment or decrement are not represented\n-   because they can be understood from the machine-mode of the\n-   containing MEM.  These operations exist in only two cases:\n-   1. pushes onto the stack.\n-   2. created automatically by the life_analysis pass in flow.c.  */\n-DEF_RTL_EXPR(PRE_DEC, \"pre_dec\", \"e\", RTX_AUTOINC)\n-DEF_RTL_EXPR(PRE_INC, \"pre_inc\", \"e\", RTX_AUTOINC)\n-DEF_RTL_EXPR(POST_DEC, \"post_dec\", \"e\", RTX_AUTOINC)\n-DEF_RTL_EXPR(POST_INC, \"post_inc\", \"e\", RTX_AUTOINC)\n+   All CPU functional units in a set should to belong the same\n+   automaton.  */\n+DEF_RTL_EXPR(ABSENCE_SET, \"absence_set\", \"ss\", RTX_EXTRA)\n \n-/* These binary operations are used to represent generic address\n-   side-effects in memory addresses, except for simple incrementation\n-   or decrementation which use the above operations.  They are\n-   created automatically by the life_analysis pass in flow.c.\n-   The first operand is a REG which is used as the address.\n-   The second operand is an expression that is assigned to the\n-   register, either before (PRE_MODIFY) or after (POST_MODIFY)\n-   evaluating the address.\n-   Currently, the compiler can only handle second operands of the\n-   form (plus (reg) (reg)) and (plus (reg) (const_int)), where\n-   the first operand of the PLUS has to be the same register as\n-   the first operand of the *_MODIFY.  */\n-DEF_RTL_EXPR(PRE_MODIFY, \"pre_modify\", \"ee\", RTX_AUTOINC)\n-DEF_RTL_EXPR(POST_MODIFY, \"post_modify\", \"ee\", RTX_AUTOINC)\n+/* (final_absence_set string string) is analogous to `absence_set' but\n+   checking is done on the result (state) reservation.  See comments\n+   for `final_presence_set'.  */\n+DEF_RTL_EXPR(FINAL_ABSENCE_SET, \"final_absence_set\", \"ss\", RTX_EXTRA)\n \n-/* Comparison operations.  The ordered comparisons exist in two\n-   flavors, signed and unsigned.  */\n-DEF_RTL_EXPR(NE, \"ne\", \"ee\", RTX_COMM_COMPARE)\n-DEF_RTL_EXPR(EQ, \"eq\", \"ee\", RTX_COMM_COMPARE)\n-DEF_RTL_EXPR(GE, \"ge\", \"ee\", RTX_COMPARE)\n-DEF_RTL_EXPR(GT, \"gt\", \"ee\", RTX_COMPARE)\n-DEF_RTL_EXPR(LE, \"le\", \"ee\", RTX_COMPARE)\n-DEF_RTL_EXPR(LT, \"lt\", \"ee\", RTX_COMPARE)\n-DEF_RTL_EXPR(GEU, \"geu\", \"ee\", RTX_COMPARE)\n-DEF_RTL_EXPR(GTU, \"gtu\", \"ee\", RTX_COMPARE)\n-DEF_RTL_EXPR(LEU, \"leu\", \"ee\", RTX_COMPARE)\n-DEF_RTL_EXPR(LTU, \"ltu\", \"ee\", RTX_COMPARE)\n+/* (define_bypass number out_insn_names in_insn_names) names bypass\n+   with given latency (the first number) from insns given by the first\n+   string (see define_insn_reservation) into insns given by the second\n+   string.  Insn names in the strings are separated by commas.  The\n+   third operand is optional name of function which is additional\n+   guard for the bypass.  The function will get the two insns as\n+   parameters.  If the function returns zero the bypass will be\n+   ignored for this case.  Additional guard is necessary to recognize\n+   complicated bypasses, e.g. when consumer is load address.  */\n+DEF_RTL_EXPR(DEFINE_BYPASS, \"define_bypass\", \"issS\", RTX_EXTRA)\n \n-/* Additional floating point unordered comparison flavors.  */\n-DEF_RTL_EXPR(UNORDERED, \"unordered\", \"ee\", RTX_COMM_COMPARE)\n-DEF_RTL_EXPR(ORDERED, \"ordered\", \"ee\", RTX_COMM_COMPARE)\n+/* (define_automaton string) describes names of automata generated and\n+   used for pipeline hazards recognition.  The names are separated by\n+   comma.  Actually it is possibly to generate the single automaton\n+   but unfortunately it can be very large.  If we use more one\n+   automata, the summary size of the automata usually is less than the\n+   single one.  The automaton name is used in define_cpu_unit and\n+   define_query_cpu_unit.  All automata should have unique names.  */\n+DEF_RTL_EXPR(DEFINE_AUTOMATON, \"define_automaton\", \"s\", RTX_EXTRA)\n \n-/* These are equivalent to unordered or ...  */\n-DEF_RTL_EXPR(UNEQ, \"uneq\", \"ee\", RTX_COMM_COMPARE)\n-DEF_RTL_EXPR(UNGE, \"unge\", \"ee\", RTX_COMPARE)\n-DEF_RTL_EXPR(UNGT, \"ungt\", \"ee\", RTX_COMPARE)\n-DEF_RTL_EXPR(UNLE, \"unle\", \"ee\", RTX_COMPARE)\n-DEF_RTL_EXPR(UNLT, \"unlt\", \"ee\", RTX_COMPARE)\n+/* (automata_option string) describes option for generation of\n+   automata.  Currently there are the following options:\n \n-/* This is an ordered NE, ie !UNEQ, ie false for NaN.  */\n-DEF_RTL_EXPR(LTGT, \"ltgt\", \"ee\", RTX_COMM_COMPARE)\n+   o \"no-minimization\" which makes no minimization of automata.  This\n+     is only worth to do when we are debugging the description and\n+     need to look more accurately at reservations of states.\n \n-/* Represents the result of sign-extending the sole operand.\n-   The machine modes of the operand and of the SIGN_EXTEND expression\n-   determine how much sign-extension is going on.  */\n-DEF_RTL_EXPR(SIGN_EXTEND, \"sign_extend\", \"e\", RTX_UNARY)\n+   o \"time\" which means printing additional time statistics about\n+      generation of automata.\n+  \n+   o \"v\" which means generation of file describing the result\n+     automata.  The file has suffix `.dfa' and can be used for the\n+     description verification and debugging.\n \n-/* Similar for zero-extension (such as unsigned short to int).  */\n-DEF_RTL_EXPR(ZERO_EXTEND, \"zero_extend\", \"e\", RTX_UNARY)\n+   o \"w\" which means generation of warning instead of error for\n+     non-critical errors.\n \n-/* Similar but here the operand has a wider mode.  */\n-DEF_RTL_EXPR(TRUNCATE, \"truncate\", \"e\", RTX_UNARY)\n+   o \"ndfa\" which makes nondeterministic finite state automata.\n \n-/* Similar for extending floating-point values (such as SFmode to DFmode).  */\n-DEF_RTL_EXPR(FLOAT_EXTEND, \"float_extend\", \"e\", RTX_UNARY)\n-DEF_RTL_EXPR(FLOAT_TRUNCATE, \"float_truncate\", \"e\", RTX_UNARY)\n+   o \"progress\" which means output of a progress bar showing how many\n+     states were generated so far for automaton being processed.  */\n+DEF_RTL_EXPR(AUTOMATA_OPTION, \"automata_option\", \"s\", RTX_EXTRA)\n \n-/* Conversion of fixed point operand to floating point value.  */\n-DEF_RTL_EXPR(FLOAT, \"float\", \"e\", RTX_UNARY)\n+/* (define_reservation string string) names reservation (the first\n+   string) of cpu functional units (the 2nd string).  Sometimes unit\n+   reservations for different insns contain common parts.  In such\n+   case, you can describe common part and use its name (the 1st\n+   parameter) in regular expression in define_insn_reservation.  All\n+   define_reservations, define_cpu_units, and define_query_cpu_units\n+   should have unique names which may not be \"nothing\".  */\n+DEF_RTL_EXPR(DEFINE_RESERVATION, \"define_reservation\", \"ss\", RTX_EXTRA)\n \n-/* With fixed-point machine mode:\n-   Conversion of floating point operand to fixed point value.\n-   Value is defined only when the operand's value is an integer.\n-   With floating-point machine mode (and operand with same mode):\n-   Operand is rounded toward zero to produce an integer value\n-   represented in floating point.  */\n-DEF_RTL_EXPR(FIX, \"fix\", \"e\", RTX_UNARY)\n+/* (define_insn_reservation name default_latency condition regexpr)\n+   describes reservation of cpu functional units (the 3nd operand) for\n+   instruction which is selected by the condition (the 2nd parameter).\n+   The first parameter is used for output of debugging information.\n+   The reservations are described by a regular expression according\n+   the following syntax:\n \n-/* Conversion of unsigned fixed point operand to floating point value.  */\n-DEF_RTL_EXPR(UNSIGNED_FLOAT, \"unsigned_float\", \"e\", RTX_UNARY)\n+       regexp = regexp \",\" oneof\n+              | oneof\n \n-/* With fixed-point machine mode:\n-   Conversion of floating point operand to *unsigned* fixed point value.\n-   Value is defined only when the operand's value is an integer.  */\n-DEF_RTL_EXPR(UNSIGNED_FIX, \"unsigned_fix\", \"e\", RTX_UNARY)\n+       oneof = oneof \"|\" allof\n+             | allof\n \n-/* Absolute value */\n-DEF_RTL_EXPR(ABS, \"abs\", \"e\", RTX_UNARY)\n+       allof = allof \"+\" repeat\n+             | repeat\n+ \n+       repeat = element \"*\" number\n+              | element\n \n-/* Square root */\n-DEF_RTL_EXPR(SQRT, \"sqrt\", \"e\", RTX_UNARY)\n+       element = cpu_function_unit_name\n+               | reservation_name\n+               | result_name\n+               | \"nothing\"\n+               | \"(\" regexp \")\"\n \n-/* Find first bit that is set.\n-   Value is 1 + number of trailing zeros in the arg.,\n-   or 0 if arg is 0.  */\n-DEF_RTL_EXPR(FFS, \"ffs\", \"e\", RTX_UNARY)\n+       1. \",\" is used for describing start of the next cycle in\n+       reservation.\n \n-/* Count leading zeros.  */\n-DEF_RTL_EXPR(CLZ, \"clz\", \"e\", RTX_UNARY)\n+       2. \"|\" is used for describing the reservation described by the\n+       first regular expression *or* the reservation described by the\n+       second regular expression *or* etc.\n \n-/* Count trailing zeros.  */\n-DEF_RTL_EXPR(CTZ, \"ctz\", \"e\", RTX_UNARY)\n+       3. \"+\" is used for describing the reservation described by the\n+       first regular expression *and* the reservation described by the\n+       second regular expression *and* etc.\n \n-/* Population count (number of 1 bits).  */\n-DEF_RTL_EXPR(POPCOUNT, \"popcount\", \"e\", RTX_UNARY)\n+       4. \"*\" is used for convenience and simply means sequence in\n+       which the regular expression are repeated NUMBER times with\n+       cycle advancing (see \",\").\n \n-/* Population parity (number of 1 bits modulo 2).  */\n-DEF_RTL_EXPR(PARITY, \"parity\", \"e\", RTX_UNARY)\n+       5. cpu functional unit name which means its reservation.\n \n-/* Reference to a signed bit-field of specified size and position.\n-   Operand 0 is the memory unit (usually SImode or QImode) which\n-   contains the field's first bit.  Operand 1 is the width, in bits.\n-   Operand 2 is the number of bits in the memory unit before the\n-   first bit of this field.\n-   If BITS_BIG_ENDIAN is defined, the first bit is the msb and\n-   operand 2 counts from the msb of the memory unit.\n-   Otherwise, the first bit is the lsb and operand 2 counts from\n-   the lsb of the memory unit.  */\n-DEF_RTL_EXPR(SIGN_EXTRACT, \"sign_extract\", \"eee\", RTX_BITFIELD_OPS)\n+       6. reservation name -- see define_reservation.\n \n-/* Similar for unsigned bit-field.  */\n-DEF_RTL_EXPR(ZERO_EXTRACT, \"zero_extract\", \"eee\", RTX_BITFIELD_OPS)\n+       7. string \"nothing\" means no units reservation.  */\n \n-/* For RISC machines.  These save memory when splitting insns.  */\n+DEF_RTL_EXPR(DEFINE_INSN_RESERVATION, \"define_insn_reservation\", \"sies\", RTX_EXTRA)\n \n-/* HIGH are the high-order bits of a constant expression.  */\n-DEF_RTL_EXPR(HIGH, \"high\", \"e\", RTX_CONST_OBJ)\n+/* Expressions used for insn attributes.  */\n \n-/* LO_SUM is the sum of a register and the low-order bits\n-   of a constant expression.  */\n-DEF_RTL_EXPR(LO_SUM, \"lo_sum\", \"ee\", RTX_OBJ)\n+/* Definition of an insn attribute.\n+   1st operand: name of the attribute\n+   2nd operand: comma-separated list of possible attribute values\n+   3rd operand: expression for the default value of the attribute.  */\n+DEF_RTL_EXPR(DEFINE_ATTR, \"define_attr\", \"sse\", RTX_EXTRA)\n \n-/* Header for range information.  Operand 0 is the NOTE_INSN_RANGE_BEG insn.\n-   Operand 1 is the NOTE_INSN_RANGE_END insn.  Operand 2 is a vector of all of\n-   the registers that can be substituted within this range.  Operand 3 is the\n-   number of calls in the range.  Operand 4 is the number of insns in the\n-   range.  Operand 5 is the unique range number for this range.  Operand 6 is\n-   the basic block # of the start of the live range.  Operand 7 is the basic\n-   block # of the end of the live range.  Operand 8 is the loop depth.  Operand\n-   9 is a bitmap of the registers live at the start of the range.  Operand 10\n-   is a bitmap of the registers live at the end of the range.  Operand 11 is\n-   marker number for the start of the range.  Operand 12 is the marker number\n-   for the end of the range.  */\n-DEF_RTL_EXPR(RANGE_INFO, \"range_info\", \"uuEiiiiiibbii\", RTX_EXTRA)\n+/* Marker for the name of an attribute.  */\n+DEF_RTL_EXPR(ATTR, \"attr\", \"s\", RTX_EXTRA)\n \n-/* Registers that can be substituted within the range.  Operand 0 is the\n-   original pseudo register number.  Operand 1 will be filled in with the\n-   pseudo register the value is copied for the duration of the range.  Operand\n-   2 is the number of references within the range to the register.  Operand 3\n-   is the number of sets or clobbers of the register in the range.  Operand 4\n-   is the number of deaths the register has.  Operand 5 is the copy flags that\n-   give the status of whether a copy is needed from the original register to\n-   the new register at the beginning of the range, or whether a copy from the\n-   new register back to the original at the end of the range.  Operand 6 is the\n-   live length.  Operand 7 is the number of calls that this register is live\n-   across.  Operand 8 is the symbol node of the variable if the register is a\n-   user variable.  Operand 9 is the block node that the variable is declared\n-   in if the register is a user variable.  */\n-DEF_RTL_EXPR(RANGE_REG, \"range_reg\", \"iiiiiiiitt\", RTX_EXTRA)\n+/* For use in the last (optional) operand of DEFINE_INSN or DEFINE_PEEPHOLE and\n+   in DEFINE_ASM_INSN to specify an attribute to assign to insns matching that\n+   pattern.\n \n-/* Information about a local variable's ranges.  Operand 0 is an EXPR_LIST of\n-   the different ranges a variable is in where it is copied to a different\n-   pseudo register.  Operand 1 is the block that the variable is declared in.\n-   Operand 2 is the number of distinct ranges.  */\n-DEF_RTL_EXPR(RANGE_VAR, \"range_var\", \"eti\", RTX_EXTRA)\n+   (set_attr \"name\" \"value\") is equivalent to\n+   (set (attr \"name\") (const_string \"value\"))  */\n+DEF_RTL_EXPR(SET_ATTR, \"set_attr\", \"ss\", RTX_EXTRA)\n \n-/* Information about the registers that are live at the current point.  Operand\n-   0 is the live bitmap.  Operand 1 is the original block number.  */\n-DEF_RTL_EXPR(RANGE_LIVE, \"range_live\", \"bi\", RTX_EXTRA)\n+/* In the last operand of DEFINE_INSN and DEFINE_PEEPHOLE, this can be used to\n+   specify that attribute values are to be assigned according to the\n+   alternative matched.\n \n-/* Describes a merge operation between two vector values.\n-   Operands 0 and 1 are the vectors to be merged, operand 2 is a bitmask\n-   that specifies where the parts of the result are taken from.  Set bits\n-   indicate operand 0, clear bits indicate operand 1.  The parts are defined\n-   by the mode of the vectors.  */\n-DEF_RTL_EXPR(VEC_MERGE, \"vec_merge\", \"eee\", RTX_TERNARY)\n+   The following three expressions are equivalent:\n \n-/* Describes an operation that selects parts of a vector.\n-   Operands 0 is the source vector, operand 1 is a PARALLEL that contains\n-   a CONST_INT for each of the subparts of the result vector, giving the\n-   number of the source subpart that should be stored into it.  */\n-DEF_RTL_EXPR(VEC_SELECT, \"vec_select\", \"ee\", RTX_BIN_ARITH)\n+   (set (attr \"att\") (cond [(eq_attrq \"alternative\" \"1\") (const_string \"a1\")\n+\t\t\t    (eq_attrq \"alternative\" \"2\") (const_string \"a2\")]\n+\t\t\t   (const_string \"a3\")))\n+   (set_attr_alternative \"att\" [(const_string \"a1\") (const_string \"a2\")\n+\t\t\t\t (const_string \"a3\")])\n+   (set_attr \"att\" \"a1,a2,a3\")\n+ */\n+DEF_RTL_EXPR(SET_ATTR_ALTERNATIVE, \"set_attr_alternative\", \"sE\", RTX_EXTRA)\n \n-/* Describes a vector concat operation.  Operands 0 and 1 are the source\n-   vectors, the result is a vector that is as long as operands 0 and 1\n-   combined and is the concatenation of the two source vectors.  */\n-DEF_RTL_EXPR(VEC_CONCAT, \"vec_concat\", \"ee\", RTX_BIN_ARITH)\n+/* A conditional expression true if the value of the specified attribute of\n+   the current insn equals the specified value.  The first operand is the\n+   attribute name and the second is the comparison value.  */\n+DEF_RTL_EXPR(EQ_ATTR, \"eq_attr\", \"ss\", RTX_EXTRA)\n \n-/* Describes an operation that converts a small vector into a larger one by\n-   duplicating the input values.  The output vector mode must have the same\n-   submodes as the input vector mode, and the number of output parts must be\n-   an integer multiple of the number of input parts.  */\n-DEF_RTL_EXPR(VEC_DUPLICATE, \"vec_duplicate\", \"e\", RTX_UNARY)\n-     \n-/* Addition with signed saturation */\n-DEF_RTL_EXPR(SS_PLUS, \"ss_plus\", \"ee\", RTX_COMM_ARITH)\n+/* A special case of the above representing a set of alternatives.  The first\n+   operand is bitmap of the set, the second one is the default value.  */\n+DEF_RTL_EXPR(EQ_ATTR_ALT, \"eq_attr_alt\", \"ii\", RTX_EXTRA)\n \n-/* Addition with unsigned saturation */\n-DEF_RTL_EXPR(US_PLUS, \"us_plus\", \"ee\", RTX_COMM_ARITH)\n+/* A conditional expression which is true if the specified flag is\n+   true for the insn being scheduled in reorg.\n \n-/* Operand 0 minus operand 1, with signed saturation.  */\n-DEF_RTL_EXPR(SS_MINUS, \"ss_minus\", \"ee\", RTX_BIN_ARITH)\n+   genattr.c defines the following flags which can be tested by\n+   (attr_flag \"foo\") expressions in eligible_for_delay.\n \n-/* Operand 0 minus operand 1, with unsigned saturation.  */\n-DEF_RTL_EXPR(US_MINUS, \"us_minus\", \"ee\", RTX_BIN_ARITH)\n+   forward, backward, very_likely, likely, very_unlikely, and unlikely.  */\n \n-/* Signed saturating truncate.  */\n-DEF_RTL_EXPR(SS_TRUNCATE, \"ss_truncate\", \"e\", RTX_UNARY)\n+DEF_RTL_EXPR (ATTR_FLAG, \"attr_flag\", \"s\", RTX_EXTRA)\n \n-/* Unsigned saturating truncate.  */\n-DEF_RTL_EXPR(US_TRUNCATE, \"us_truncate\", \"e\", RTX_UNARY)\n+/* General conditional. The first operand is a vector composed of pairs of\n+   expressions.  The first element of each pair is evaluated, in turn.\n+   The value of the conditional is the second expression of the first pair\n+   whose first expression evaluates nonzero.  If none of the expressions is\n+   true, the second operand will be used as the value of the conditional.  */\n+DEF_RTL_EXPR(COND, \"cond\", \"Ee\", RTX_EXTRA)\n \n-/* Information about the variable and its location.  */\n-DEF_RTL_EXPR(VAR_LOCATION, \"var_location\", \"te\", RTX_EXTRA)\n \n /*\n Local variables:"}]}