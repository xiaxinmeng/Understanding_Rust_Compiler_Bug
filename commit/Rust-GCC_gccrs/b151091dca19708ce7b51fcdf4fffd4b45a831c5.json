{"sha": "b151091dca19708ce7b51fcdf4fffd4b45a831c5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjE1MTA5MWRjYTE5NzA4Y2U3YjUxZmNkZjRmZmZkNGI0NWE4MzFjNQ==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2015-01-19T22:35:53Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2015-01-19T22:35:53Z"}, "message": "re PR target/53988 ([SH] tst Rm,Rn not used for QI/HImode)\n\ngcc/\n\tPR target/53988\n\t* config/sh/sh-protos.h (sh_find_set_of_reg): Make sure not to return\n\tnullptr for insn when reaching the first insn.\n\t* config/sh/sh.c (sh_unspec_insn_p): Rewrite using subrtx_iterator.\n\t(sh_insn_operands_modified_between_p): Add nullptr check.\n\t(sh_find_extending_set_of_reg): Fix log message.  Don't accept\n\tsign extending mem load if the insn contains any UNSPEC or\n\tUNSPEC_VOLATILE.\n\nFrom-SVN: r219864", "tree": {"sha": "c20067725481e97853bfe41791791d544357c352", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c20067725481e97853bfe41791791d544357c352"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b151091dca19708ce7b51fcdf4fffd4b45a831c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b151091dca19708ce7b51fcdf4fffd4b45a831c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b151091dca19708ce7b51fcdf4fffd4b45a831c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b151091dca19708ce7b51fcdf4fffd4b45a831c5/comments", "author": null, "committer": null, "parents": [{"sha": "c2db720467067f3e811de25875b2bbe7fa06f7a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2db720467067f3e811de25875b2bbe7fa06f7a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2db720467067f3e811de25875b2bbe7fa06f7a6"}], "stats": {"total": 59, "additions": 38, "deletions": 21}, "files": [{"sha": "7078d40cfa9705b5e19f717c9e1831dfb8760761", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b151091dca19708ce7b51fcdf4fffd4b45a831c5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b151091dca19708ce7b51fcdf4fffd4b45a831c5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b151091dca19708ce7b51fcdf4fffd4b45a831c5", "patch": "@@ -1,3 +1,14 @@\n+2015-01-19  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/53988\n+\t* config/sh/sh-protos.h (sh_find_set_of_reg): Make sure not to return\n+\tnullptr for insn when reaching the first insn.\n+\t* config/sh/sh.c (sh_unspec_insn_p): Rewrite using subrtx_iterator.\n+\t(sh_insn_operands_modified_between_p): Add nullptr check.\n+\t(sh_find_extending_set_of_reg): Fix log message.  Don't accept\n+\tsign extending mem load if the insn contains any UNSPEC or\n+\tUNSPEC_VOLATILE.\n+\n 2015-01-19  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* params.def (inline-unit-growth): Drop to 15%."}, {"sha": "bc2b3b30667cafbaea3232631e6c78e7f6ae9ea9", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b151091dca19708ce7b51fcdf4fffd4b45a831c5/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b151091dca19708ce7b51fcdf4fffd4b45a831c5/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=b151091dca19708ce7b51fcdf4fffd4b45a831c5", "patch": "@@ -192,19 +192,21 @@ sh_find_set_of_reg (rtx reg, rtx_insn* insn, F stepfunc,\n   if (!REG_P (reg) || insn == NULL_RTX)\n     return result;\n \n+  rtx_insn* previnsn = insn;\n+\n   for (result.insn = stepfunc (insn); result.insn != NULL_RTX;\n-       result.insn = stepfunc (result.insn))\n+       previnsn = result.insn, result.insn = stepfunc (result.insn))\n     {\n       if (BARRIER_P (result.insn))\n-\treturn result;\n+\tbreak;\n       if (!NONJUMP_INSN_P (result.insn))\n \tcontinue;\n       if (reg_set_p (reg, result.insn))\n \t{\n \t  result.set_rtx = set_of (reg, result.insn);\n \n \t  if (result.set_rtx == NULL_RTX || GET_CODE (result.set_rtx) != SET)\n-\t    return result;\n+\t    break;\n \n \t  result.set_src = XEXP (result.set_rtx, 1);\n \n@@ -220,10 +222,19 @@ sh_find_set_of_reg (rtx reg, rtx_insn* insn, F stepfunc,\n \t      continue;\n \t    }\n \n-\t  return result;\n+\t  break;\n \t}\n     }\n \n+  /* If the loop above stopped at the first insn in the list,\n+     result.insn will be null.  Use the insn from the previous iteration\n+     in this case.  */\n+  if (result.insn == NULL)\n+    result.insn = previnsn;\n+\n+  if (result.set_src != NULL)\n+    gcc_assert (result.insn != NULL && result.set_rtx != NULL);\n+\n   return result;\n }\n "}, {"sha": "bde95f6a587e45e010a43904ff98d21c543ebca4", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b151091dca19708ce7b51fcdf4fffd4b45a831c5/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b151091dca19708ce7b51fcdf4fffd4b45a831c5/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=b151091dca19708ce7b51fcdf4fffd4b45a831c5", "patch": "@@ -13738,22 +13738,15 @@ sh_find_equiv_gbr_addr (rtx_insn* insn, rtx mem)\n /* Return true if the specified insn contains any UNSPECs or\n    UNSPEC_VOLATILEs.  */\n static bool\n-sh_unspec_insn_p (rtx_insn* insn)\n+sh_unspec_insn_p (rtx x)\n {\n-  bool result = false;\n-\n-  struct note_uses_func\n-  {\n-    static void\n-    func (rtx* x, void* data)\n-    {\n-      if (GET_CODE (*x) == UNSPEC || GET_CODE (*x) == UNSPEC_VOLATILE)\n-\t*(static_cast<bool*> (data)) = true;\n-    }\n-  };\n+  subrtx_iterator::array_type array;\n+  FOR_EACH_SUBRTX (i, array, x, ALL)\n+    if (*i != NULL\n+\t&& (GET_CODE (*i) == UNSPEC || GET_CODE (*i) == UNSPEC_VOLATILE))\n+      return true;\n \n-  note_uses (&PATTERN (insn), note_uses_func::func, &result);\n-  return result;\n+  return false;\n }\n \n /* Return true if the register operands of the specified insn are modified\n@@ -13770,7 +13763,8 @@ sh_insn_operands_modified_between_p (rtx_insn* operands_insn,\n \n   subrtx_iterator::array_type array;\n   FOR_EACH_SUBRTX (i, array, SET_SRC (s), ALL)\n-    if ((REG_P (*i) || SUBREG_P (*i)) && reg_set_between_p (*i, from, to))\n+    if (*i != NULL &&\n+\t((REG_P (*i) || SUBREG_P (*i)) && reg_set_between_p (*i, from, to)))\n       return true;\n \n   return false;\n@@ -13927,15 +13921,16 @@ sh_find_extending_set_of_reg (rtx reg, rtx_insn* curr_insn)\n \t  || GET_CODE (result.set_src) == ZERO_EXTEND)\n \t{\n \t  if (dump_file)\n-\t    fprintf (dump_file, \"sh_find_szexnteded_reg: reg %d is \"\n+\t    fprintf (dump_file, \"sh_find_extending_set_of_reg: reg %d is \"\n \t\t\t\t\"explicitly sign/zero extended in insn %d\\n\",\n \t\t\t\tREGNO (reg), INSN_UID (result.insn));\n \t  result.from_mode = GET_MODE (XEXP (result.set_src, 0));\n \t  result.ext_code = GET_CODE (result.set_src);\n \t}\n       else if (MEM_P (result.set_src)\n \t       && (GET_MODE (result.set_src) == QImode\n-\t\t   || GET_MODE (result.set_src) == HImode))\n+\t\t   || GET_MODE (result.set_src) == HImode)\n+\t       && !sh_unspec_insn_p (result.insn))\n \t{\n \t  /* On SH QIHImode memory loads always sign extend.  However, in\n \t     some cases where it seems that the higher bits are not"}]}