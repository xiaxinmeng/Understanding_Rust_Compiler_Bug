{"sha": "dd63bba0c8dc3a6ae06cfdc084bca7c68b8bbd39", "node_id": "C_kwDOANBUbNoAKGRkNjNiYmEwYzhkYzNhNmFlMDZjZmRjMDg0YmNhN2M2OGI4YmJkMzk", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2023-03-24T15:21:20Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2023-03-28T13:32:40Z"}, "message": "Fix compute_operand when op1 == op2 symbolically.\n\nFirst, class value_relation should not sanitize records. just create\nwhat is asked.\n\nSecond., if there is not a relation record, compute_operand was\ncreating one for op1 == op2 if op1 and op2 were the same symbol.   This\nis not the correct way to communicate the information, as that record\nwill continue to be passed along the GORI unwind chain.\n\nInstead, simply pass that information locally to the opX_range routine\nfor only the current statement.\n\n\tPR tree-optimization/109265\n\tPR tree-optimization/109274\n\tgcc/\n\t* gimple-range-gori.cc (gori_compute::compute_operand_range): Do\n\tnot create a relation record is op1 and op2 are the same symbol.\n\t(gori_compute::compute_operand1_range): Pass op1 == op2 to the\n\thandler for this stmt, but create a new record only if this statement\n\tgenerates a relation based on the ranges.\n\t(gori_compute::compute_operand2_range): Ditto.\n\t* value-relation.h (value_relation::set_relation): Always create the\n\trecord that is requested.\n\n\tgcc/testsuite/\n\t* gcc.dg/pr109274.c: New.\n\t* gfortran.dg/pr109265.f90: New.", "tree": {"sha": "82687825d14c3850b6bcb16dba5a7e3bb17243cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/82687825d14c3850b6bcb16dba5a7e3bb17243cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dd63bba0c8dc3a6ae06cfdc084bca7c68b8bbd39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd63bba0c8dc3a6ae06cfdc084bca7c68b8bbd39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd63bba0c8dc3a6ae06cfdc084bca7c68b8bbd39", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd63bba0c8dc3a6ae06cfdc084bca7c68b8bbd39/comments", "author": null, "committer": null, "parents": [{"sha": "2b9d76c1af189b918a9970f471e6d2e2c08f7e7d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b9d76c1af189b918a9970f471e6d2e2c08f7e7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b9d76c1af189b918a9970f471e6d2e2c08f7e7d"}], "stats": {"total": 115, "additions": 92, "deletions": 23}, "files": [{"sha": "b9c3ba1a314e7b36e8fd54ddc4632307a5e51057", "filename": "gcc/gimple-range-gori.cc", "status": "modified", "additions": 37, "deletions": 16, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd63bba0c8dc3a6ae06cfdc084bca7c68b8bbd39/gcc%2Fgimple-range-gori.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd63bba0c8dc3a6ae06cfdc084bca7c68b8bbd39/gcc%2Fgimple-range-gori.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-gori.cc?ref=dd63bba0c8dc3a6ae06cfdc084bca7c68b8bbd39", "patch": "@@ -623,21 +623,6 @@ gori_compute::compute_operand_range (vrange &r, gimple *stmt,\n   tree op1 = gimple_range_ssa_p (handler.operand1 ());\n   tree op2 = gimple_range_ssa_p (handler.operand2 ());\n \n-  // If there is a relation, use it instead of any passed in.  This will allow\n-  // multiple relations to be processed in compound logicals.\n-  if (op1 && op2)\n-    {\n-      relation_kind k = handler.op1_op2_relation (lhs);\n-      // If there is no relation, and op1 == op2, create a relation.\n-      if (!vrel_ptr && k == VREL_VARYING && op1 == op2)\n-\tk = VREL_EQ;\n-      if (k != VREL_VARYING)\n-       {\n-\t vrel.set_relation (k, op1, op2);\n-\t vrel_ptr = &vrel;\n-       }\n-    }\n-\n   // Handle end of lookup first.\n   if (op1 == name)\n     return compute_operand1_range (r, handler, lhs, name, src, vrel_ptr);\n@@ -1093,6 +1078,7 @@ gori_compute::compute_operand1_range (vrange &r,\n \t\t\t\t      const vrange &lhs, tree name,\n \t\t\t\t      fur_source &src, value_relation *rel)\n {\n+  value_relation local_rel;\n   gimple *stmt = handler.stmt ();\n   tree op1 = handler.operand1 ();\n   tree op2 = handler.operand2 ();\n@@ -1101,6 +1087,7 @@ gori_compute::compute_operand1_range (vrange &r,\n   relation_trio trio;\n   if (rel)\n     trio = rel->create_trio (lhs_name, op1, op2);\n+  relation_kind op_op = trio.op1_op2 ();\n \n   Value_Range op1_range (TREE_TYPE (op1));\n   Value_Range tmp (TREE_TYPE (op1));\n@@ -1113,10 +1100,26 @@ gori_compute::compute_operand1_range (vrange &r,\n   if (op2)\n     {\n       src.get_operand (op2_range, op2);\n-      relation_kind op_op = trio.op1_op2 ();\n+\n+      // If there is a relation betwen op1 and op2, use it instead.\n+      // This allows multiple relations to be processed in compound logicals.\n+      if (gimple_range_ssa_p (op1) && gimple_range_ssa_p (op2))\n+\t{\n+\t  relation_kind k = handler.op1_op2_relation (lhs);\n+\t  if (k != VREL_VARYING)\n+\t    {\n+\t      op_op = k;\n+\t      local_rel.set_relation (op_op, op1, op2);\n+\t      rel = &local_rel;\n+\t    }\n+\t}\n+\n       if (op_op != VREL_VARYING)\n \trefine_using_relation (op1, op1_range, op2, op2_range, src, op_op);\n \n+      // If op1 == op2, create a new trio for just this call.\n+      if (op1 == op2 && gimple_range_ssa_p (op1))\n+\ttrio = relation_trio (trio.lhs_op1 (), trio.lhs_op2 (), VREL_EQ);\n       if (!handler.calc_op1 (tmp, lhs, op2_range, trio))\n \treturn false;\n     }\n@@ -1185,6 +1188,7 @@ gori_compute::compute_operand2_range (vrange &r,\n \t\t\t\t      const vrange &lhs, tree name,\n \t\t\t\t      fur_source &src, value_relation *rel)\n {\n+  value_relation local_rel;\n   gimple *stmt = handler.stmt ();\n   tree op1 = handler.operand1 ();\n   tree op2 = handler.operand2 ();\n@@ -1201,9 +1205,26 @@ gori_compute::compute_operand2_range (vrange &r,\n   if (rel)\n     trio = rel->create_trio (lhs_name, op1, op2);\n   relation_kind op_op = trio.op1_op2 ();\n+\n+  // If there is a relation betwen op1 and op2, use it instead.\n+  // This allows multiple relations to be processed in compound logicals.\n+  if (gimple_range_ssa_p (op1) && gimple_range_ssa_p (op2))\n+    {\n+      relation_kind k = handler.op1_op2_relation (lhs);\n+      if (k != VREL_VARYING)\n+\t{\n+\t  op_op = k;\n+\t  local_rel.set_relation (op_op, op1, op2);\n+\t  rel = &local_rel;\n+\t}\n+    }\n+\n   if (op_op != VREL_VARYING)\n     refine_using_relation (op1, op1_range, op2, op2_range, src, op_op);\n \n+  // If op1 == op2, create a new trio for this stmt.\n+  if (op1 == op2 && gimple_range_ssa_p (op1))\n+    trio = relation_trio (trio.lhs_op1 (), trio.lhs_op2 (), VREL_EQ);\n   // Intersect with range for op2 based on lhs and op1.\n   if (!handler.calc_op2 (tmp, lhs, op1_range, trio))\n     return false;"}, {"sha": "5dbc0232f8ec97cd3e2387534b13291cb344691f", "filename": "gcc/testsuite/gcc.dg/pr109274.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd63bba0c8dc3a6ae06cfdc084bca7c68b8bbd39/gcc%2Ftestsuite%2Fgcc.dg%2Fpr109274.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd63bba0c8dc3a6ae06cfdc084bca7c68b8bbd39/gcc%2Ftestsuite%2Fgcc.dg%2Fpr109274.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr109274.c?ref=dd63bba0c8dc3a6ae06cfdc084bca7c68b8bbd39", "patch": "@@ -0,0 +1,16 @@\n+/* PR tree-optimization/109274 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 \" } */\n+\n+float a, b, c;\n+int d;\n+float bar (void);\n+\n+void\n+foo (void)\n+{\n+  a = 0 * -(2.0f * c);\n+  d = a != a ? 0 : bar ();\n+  b = c;\n+}\n+"}, {"sha": "0d7124c7741fcb59f45bf52ca5ab7763986b0e06", "filename": "gcc/testsuite/gfortran.dg/pr109265.f90", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd63bba0c8dc3a6ae06cfdc084bca7c68b8bbd39/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr109265.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd63bba0c8dc3a6ae06cfdc084bca7c68b8bbd39/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr109265.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr109265.f90?ref=dd63bba0c8dc3a6ae06cfdc084bca7c68b8bbd39", "patch": "@@ -0,0 +1,39 @@\n+! PR tree-optimization/109265\n+! { dg-do compile }\n+! { dg-options \"-O3 -w\" }\n+\n+module pr109265\n+  integer, parameter :: r8 = selected_real_kind (12)\n+contains\n+  subroutine foo (b, c, d, e, f)\n+    implicit none\n+    logical :: b\n+    real (kind = r8) :: c, d, e, f, i\n+    if (b) then\n+      c = bar (c * d, e)\n+      i = bar (f, c)\n+      call baz (i)\n+      call baz (-i)\n+    end if\n+  end subroutine foo\n+  function bar (a, b)\n+    implicit none\n+    real (kind = r8) :: bar\n+    real (kind = r8) :: a, b\n+    bar = a + b\n+  end function bar\n+  subroutine baz (b)\n+    implicit none\n+    real (kind = r8) :: b, d, e, f, g, h, i\n+    d = b\n+    i = 0\n+    e = d\n+    f = d\n+    g = d\n+  10 continue\n+    if ((e.eq.d) .and. (f.eq.d) .and. (g.eq.d) .and. (h.eq.d)) then\n+      h = i\n+      goto 10\n+    end if\n+  end subroutine baz\n+end module pr109265"}, {"sha": "3177ecb1ad0b0e9d0d4337168796df2fcca3ce2c", "filename": "gcc/value-relation.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd63bba0c8dc3a6ae06cfdc084bca7c68b8bbd39/gcc%2Fvalue-relation.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd63bba0c8dc3a6ae06cfdc084bca7c68b8bbd39/gcc%2Fvalue-relation.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-relation.h?ref=dd63bba0c8dc3a6ae06cfdc084bca7c68b8bbd39", "patch": "@@ -445,13 +445,6 @@ value_relation::set_relation (relation_kind r, tree n1, tree n2)\n {\n   gcc_checking_assert (TREE_CODE (n1) == SSA_NAME\n \t\t       && TREE_CODE (n2) == SSA_NAME);\n-  if (n1 == n2 && r != VREL_EQ)\n-    {\n-      related = VREL_VARYING;\n-      name1 = NULL_TREE;\n-      name2 = NULL_TREE;\n-      return;\n-    }\n   related = r;\n   name1 = n1;\n   name2 = n2;"}]}