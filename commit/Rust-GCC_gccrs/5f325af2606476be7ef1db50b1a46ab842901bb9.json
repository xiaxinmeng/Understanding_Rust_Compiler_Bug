{"sha": "5f325af2606476be7ef1db50b1a46ab842901bb9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWYzMjVhZjI2MDY0NzZiZTdlZjFkYjUwYjFhNDZhYjg0MjkwMWJiOQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-01-12T13:30:20Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-01-12T13:30:20Z"}, "message": "[multiple changes]\n\n2017-01-12  Yannick Moy  <moy@adacore.com>\n\n\t* exp_spark.adb (Expand_SPARK_Potential_Renaming): Fix sloc of copied\n\tsubtree.\n\n2017-01-12  Justin Squirek  <squirek@adacore.com>\n\n\t* exp_attr.adb (Expand_N_Attribute_Reference):\n\tFix Finalization_Size case by properly resolving the type after\n\trewritting the node.\n\n2017-01-12  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_util.adb (Build_DIC_Procedure_Body): Semi-insert the body into\n\tthe tree.\n\t(Build_DIC_Procedure_Declaration): Semi-insert the body into the tree.\n\t* binde.adb, exp_ch5.adb, sem_type.adb, sem.ads, sem_res.adb,\n\texp_sel.ads: Minor reformatting.\n\n2017-01-12  Justin Squirek  <squirek@adacore.com>\n\n\t* exp_ch6.adb (Expand_Call): Add guard to prevent\n\tinvariant checks from being created for internally generated\n\tsubprograms.\n\n2017-01-12  Bob Duff  <duff@adacore.com>\n\n\t* lib-writ.ads: Remove incorrect comment.\n\n2017-01-12  Javier Miranda  <miranda@adacore.com>\n\n\t* debug.adb (-gnatd.K): Enable generation of contract-only\n\tprocedures in CodePeer mode.\n\t* contracts.adb (Build_And_Analyze_Contract_Only_Subprograms):\n\tNew subprogram.\n\t(Analyze_Contracts): Generate contract-only procedures if -gnatdK is\n\tset.\n\t* scil_ll.ads, scil_ll.adb (Get_Contract_Only_Body_Name): New\n\tsubprogram.\n\t(Get_Contract_Only_Missing_Body_Name): New subprogram.\n\t(Get_Contract_Only_Body): New subprogram.\n\t(Set_Contract_Only_Body): New subprogram.\n\t(Is_Contract_Only_Body): New subprogram.\n\t(Set_Is_Contract_Only_Body): New subprogram.\n\t(SCIL_Nodes): Replace table by hash-table.\n\nFrom-SVN: r244356", "tree": {"sha": "1eb80eba1ca449f68eb93ecacde316fd096aa023", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1eb80eba1ca449f68eb93ecacde316fd096aa023"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5f325af2606476be7ef1db50b1a46ab842901bb9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f325af2606476be7ef1db50b1a46ab842901bb9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f325af2606476be7ef1db50b1a46ab842901bb9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f325af2606476be7ef1db50b1a46ab842901bb9/comments", "author": null, "committer": null, "parents": [{"sha": "10c2c151f1204439e8b2698bf3369b8d2c29efbf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10c2c151f1204439e8b2698bf3369b8d2c29efbf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10c2c151f1204439e8b2698bf3369b8d2c29efbf"}], "stats": {"total": 974, "additions": 873, "deletions": 101}, "files": [{"sha": "048b975af9e3a2b5b44477ef0df814a6095c26de", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f325af2606476be7ef1db50b1a46ab842901bb9/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f325af2606476be7ef1db50b1a46ab842901bb9/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=5f325af2606476be7ef1db50b1a46ab842901bb9", "patch": "@@ -1,3 +1,49 @@\n+2017-01-12  Yannick Moy  <moy@adacore.com>\n+\n+\t* exp_spark.adb (Expand_SPARK_Potential_Renaming): Fix sloc of copied\n+\tsubtree.\n+\n+2017-01-12  Justin Squirek  <squirek@adacore.com>\n+\n+\t* exp_attr.adb (Expand_N_Attribute_Reference):\n+\tFix Finalization_Size case by properly resolving the type after\n+\trewritting the node.\n+\n+2017-01-12  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_util.adb (Build_DIC_Procedure_Body): Semi-insert the body into\n+\tthe tree.\n+\t(Build_DIC_Procedure_Declaration): Semi-insert the body into the tree.\n+\t* binde.adb, exp_ch5.adb, sem_type.adb, sem.ads, sem_res.adb,\n+\texp_sel.ads: Minor reformatting.\n+\n+2017-01-12  Justin Squirek  <squirek@adacore.com>\n+\n+\t* exp_ch6.adb (Expand_Call): Add guard to prevent\n+\tinvariant checks from being created for internally generated\n+\tsubprograms.\n+\n+2017-01-12  Bob Duff  <duff@adacore.com>\n+\n+\t* lib-writ.ads: Remove incorrect comment.\n+\n+2017-01-12  Javier Miranda  <miranda@adacore.com>\n+\n+\t* debug.adb (-gnatd.K): Enable generation of contract-only\n+\tprocedures in CodePeer mode.\n+\t* contracts.adb (Build_And_Analyze_Contract_Only_Subprograms):\n+\tNew subprogram.\n+\t(Analyze_Contracts): Generate contract-only procedures if -gnatdK is\n+\tset.\n+\t* scil_ll.ads, scil_ll.adb (Get_Contract_Only_Body_Name): New\n+\tsubprogram.\n+\t(Get_Contract_Only_Missing_Body_Name): New subprogram.\n+\t(Get_Contract_Only_Body): New subprogram.\n+\t(Set_Contract_Only_Body): New subprogram.\n+\t(Is_Contract_Only_Body): New subprogram.\n+\t(Set_Is_Contract_Only_Body): New subprogram.\n+\t(SCIL_Nodes): Replace table by hash-table.\n+\n 2017-01-12  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* exp_ch6.adb: Minor reformatting."}, {"sha": "f655bf2f2cf5521ab7c77ee687ca473e66d3832e", "filename": "gcc/ada/binde.adb", "status": "modified", "additions": 34, "deletions": 15, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f325af2606476be7ef1db50b1a46ab842901bb9/gcc%2Fada%2Fbinde.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f325af2606476be7ef1db50b1a46ab842901bb9/gcc%2Fada%2Fbinde.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbinde.adb?ref=5f325af2606476be7ef1db50b1a46ab842901bb9", "patch": "@@ -1211,14 +1211,18 @@ package body Binde is\n       --  There is a lot of fiddly string manipulation below, because we don't\n       --  want to depend on misc utility packages like Ada.Characters.Handling.\n \n-      function Read_File (Name : String) return String_Ptr;\n-      --  Read the entire contents of the named file\n-\n       function Get_Line return String;\n       --  Read the next line from the file content read by Read_File. Strip\n       --  leading and trailing blanks. Convert \"(spec)\" or \"(body)\" to\n       --  \"%s\"/\"%b\". Remove comments (Ada style; \"--\" to end of line).\n \n+      function Read_File (Name : String) return String_Ptr;\n+      --  Read the entire contents of the named file\n+\n+      ---------------\n+      -- Read_File --\n+      ---------------\n+\n       function Read_File (Name : String) return String_Ptr is\n          --  All of the following calls should succeed, because we checked the\n          --  file in Switch.B, but we double check and raise Program_Error on\n@@ -1232,9 +1236,11 @@ package body Binde is\n          end if;\n \n          declare\n-            Len : constant Natural := Natural (File_Length (F));\n-            Result : constant String_Ptr := new String (1 .. Len);\n-            Len_Read : constant Natural := Read (F, Result (1)'Address, Len);\n+            Len      : constant Natural    := Natural (File_Length (F));\n+            Result   : constant String_Ptr := new String (1 .. Len);\n+            Len_Read : constant Natural    :=\n+                         Read (F, Result (1)'Address, Len);\n+\n             Status : Boolean;\n \n          begin\n@@ -1252,12 +1258,17 @@ package body Binde is\n          end;\n       end Read_File;\n \n-      S : String_Ptr := Read_File (Force_Elab_Order_File.all);\n-      Cur : Positive := 1;\n+      Cur : Positive   := 1;\n+      S   : String_Ptr := Read_File (Force_Elab_Order_File.all);\n+\n+      --------------\n+      -- Get_Line --\n+      --------------\n \n       function Get_Line return String is\n          First : Positive := Cur;\n-         Last : Natural;\n+         Last  : Natural;\n+\n       begin\n          --  Skip to end of line\n \n@@ -1293,12 +1304,16 @@ package body Binde is\n          --  again.\n \n          declare\n+            Body_String : constant String   := \"(body)\";\n+            BL          : constant Positive := Body_String'Length;\n+            Spec_String : constant String   := \"(spec)\";\n+            SL          : constant Positive := Spec_String'Length;\n+\n             Line : String renames S (First .. Last);\n-            Spec_String : constant String := \"(spec)\";\n-            SL : constant Positive := Spec_String'Length;\n-            Body_String : constant String := \"(body)\";\n-            BL : constant Positive := Body_String'Length;\n-            Is_Spec, Is_Body : Boolean := False;\n+\n+            Is_Body : Boolean := False;\n+            Is_Spec : Boolean := False;\n+\n          begin\n             if Line'Length >= SL\n               and then Line (Last - SL + 1 .. Last) = Spec_String\n@@ -1336,8 +1351,12 @@ package body Binde is\n          end;\n       end Get_Line;\n \n+      --  Local variables\n+\n       Empty_Name : constant Unit_Name_Type := Name_Find (\"\");\n-      Prev_Unit : Unit_Id := No_Unit_Id;\n+      Prev_Unit  : Unit_Id := No_Unit_Id;\n+\n+   --  Start of processing for Force_Elab_Order\n \n    begin\n       --  Loop through the file content, and build a dependency link for each"}, {"sha": "e4e25bf06344399f2a7b6fe6765918b160048117", "filename": "gcc/ada/contracts.adb", "status": "modified", "additions": 574, "deletions": 1, "changes": 575, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f325af2606476be7ef1db50b1a46ab842901bb9/gcc%2Fada%2Fcontracts.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f325af2606476be7ef1db50b1a46ab842901bb9/gcc%2Fada%2Fcontracts.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcontracts.adb?ref=5f325af2606476be7ef1db50b1a46ab842901bb9", "patch": "@@ -25,6 +25,7 @@\n \n with Aspects;  use Aspects;\n with Atree;    use Atree;\n+with Debug;    use Debug;\n with Einfo;    use Einfo;\n with Elists;   use Elists;\n with Errout;   use Errout;\n@@ -47,10 +48,16 @@ with Sem_Util; use Sem_Util;\n with Sinfo;    use Sinfo;\n with Snames;   use Snames;\n with Stringt;  use Stringt;\n+with SCIL_LL;  use SCIL_LL;\n with Tbuild;   use Tbuild;\n \n package body Contracts is\n \n+   procedure Build_And_Analyze_Contract_Only_Subprograms (L : List_Id);\n+   --  (CodePeer): Subsidiary procedure to Analyze_Contracts which builds the\n+   --  contract-only subprogram body of eligible subprograms found in L, adds\n+   --  them to their corresponding list of declarations, and analyzes them.\n+\n    procedure Analyze_Contracts\n      (L          : List_Id;\n       Freeze_Nod : Node_Id;\n@@ -345,6 +352,10 @@ package body Contracts is\n \n    procedure Analyze_Contracts (L : List_Id) is\n    begin\n+      if CodePeer_Mode and then Debug_Flag_Dot_KK then\n+         Build_And_Analyze_Contract_Only_Subprograms (L);\n+      end if;\n+\n       Analyze_Contracts (L, Freeze_Nod => Empty, Freeze_Id => Empty);\n    end Analyze_Contracts;\n \n@@ -389,7 +400,7 @@ package body Contracts is\n               (Obj_Id    => Defining_Entity (Decl),\n                Freeze_Id => Freeze_Id);\n \n-         --  Protected untis\n+         --  Protected units\n \n          elsif Nkind_In (Decl, N_Protected_Type_Declaration,\n                                N_Single_Protected_Declaration)\n@@ -2643,4 +2654,566 @@ package body Contracts is\n       Pop_Scope;\n    end Save_Global_References_In_Contract;\n \n+   -------------------------------------------------\n+   -- Build_And_Analyze_Contract_Only_Subprograms --\n+   -------------------------------------------------\n+\n+   procedure Build_And_Analyze_Contract_Only_Subprograms (L : List_Id) is\n+      procedure Analyze_Contract_Only_Subprograms (L : List_Id);\n+      --  Analyze the contract-only subprograms of L\n+\n+      procedure Append_Contract_Only_Subprograms (Subp_List : List_Id);\n+      --  Append the contract-only bodies of Subp_List to its declarations list\n+\n+      function Build_Contract_Only_Subprogram (E : Entity_Id) return Node_Id;\n+      --  If E is an entity for a non-imported subprogram specification with\n+      --  pre/postconditions and we are compiling with CodePeer mode, then this\n+      --  procedure will create a wrapper to help Gnat2scil process its\n+      --  contracts. Return Empty if the wrapper cannot be built.\n+\n+      function Build_Contract_Only_Subprograms (L : List_Id) return List_Id;\n+      --  Build the contract-only subprograms of all eligible subprograms found\n+      --  in list L.\n+\n+      function Has_Private_Declarations (N : Node_Id) return Boolean;\n+      --  Return True for package specs, task definitions, and protected type\n+      --  definitions whose list of private declarations is not empty.\n+\n+      ---------------------------------------\n+      -- Analyze_Contract_Only_Subprograms --\n+      ---------------------------------------\n+\n+      procedure Analyze_Contract_Only_Subprograms (L : List_Id) is\n+         procedure Analyze_Contract_Only_Bodies;\n+         --  Analyze all the contract-only bodies of L\n+\n+         ----------------------------------\n+         -- Analyze_Contract_Only_Bodies --\n+         ----------------------------------\n+\n+         procedure Analyze_Contract_Only_Bodies is\n+            Decl : Node_Id;\n+\n+         begin\n+            Decl := First (L);\n+            while Present (Decl) loop\n+               if Nkind (Decl) = N_Subprogram_Body\n+                 and then Is_Contract_Only_Body\n+                            (Defining_Unit_Name (Specification (Decl)))\n+               then\n+                  Analyze (Decl);\n+               end if;\n+\n+               Next (Decl);\n+            end loop;\n+         end Analyze_Contract_Only_Bodies;\n+\n+      --  Start of processing for Analyze_Contract_Only_Subprograms\n+\n+      begin\n+         if Ekind (Current_Scope) /= E_Package then\n+            Analyze_Contract_Only_Bodies;\n+\n+         else\n+            declare\n+               Pkg_Spec : constant Node_Id :=\n+                            Package_Specification (Current_Scope);\n+\n+            begin\n+               if not Has_Private_Declarations (Pkg_Spec) then\n+                  Analyze_Contract_Only_Bodies;\n+\n+               --  For packages with private declarations, the contract-only\n+               --  bodies of subprograms defined in the visible part of the\n+               --  package are added to its private declarations (to ensure\n+               --  that they do not cause premature freezing of types and also\n+               --  that they are analyzed with proper visibility). Hence they\n+               --  will be analyzed later.\n+\n+               elsif Visible_Declarations (Pkg_Spec) = L then\n+                  null;\n+\n+               elsif Private_Declarations (Pkg_Spec) = L then\n+                  Analyze_Contract_Only_Bodies;\n+               end if;\n+            end;\n+         end if;\n+      end Analyze_Contract_Only_Subprograms;\n+\n+      --------------------------------------\n+      -- Append_Contract_Only_Subprograms --\n+      --------------------------------------\n+\n+      procedure Append_Contract_Only_Subprograms (Subp_List : List_Id) is\n+      begin\n+         if No (Subp_List) then\n+            return;\n+         end if;\n+\n+         if Ekind (Current_Scope) /= E_Package then\n+            Append_List (Subp_List, To => L);\n+\n+         else\n+            declare\n+               Pkg_Spec : constant Node_Id :=\n+                            Package_Specification (Current_Scope);\n+\n+            begin\n+               if not Has_Private_Declarations (Pkg_Spec) then\n+                  Append_List (Subp_List, To => L);\n+\n+               --  If the package has private declarations then append them to\n+               --  its private declarations; they will be analyzed when the\n+               --  contracts of its private declarations are analyzed.\n+\n+               else\n+                  Append_List\n+                    (List => Subp_List,\n+                     To   => Private_Declarations (Pkg_Spec));\n+               end if;\n+            end;\n+         end if;\n+      end Append_Contract_Only_Subprograms;\n+\n+      ------------------------------------\n+      -- Build_Contract_Only_Subprogram --\n+      ------------------------------------\n+\n+      --  This procedure takes care of building a wrapper to generate better\n+      --  analysis results in the case of a call to a subprogram whose body\n+      --  is unavailable to CodePeer but whose specification includes Pre/Post\n+      --  conditions. The body might be unavailable for any of a number or\n+      --  reasons (it is imported, the .adb file is simply missing, or the\n+      --  subprogram might be subject to an Annotate (CodePeer, Skip_Analysis)\n+      --  pragma). The built subprogram has the following contents:\n+      --    * check preconditions\n+      --    * call the subprogram\n+      --    * check postconditions\n+\n+      function Build_Contract_Only_Subprogram (E : Entity_Id) return Node_Id is\n+         Loc : constant Source_Ptr := Sloc (E);\n+\n+         function Build_Missing_Body_Decls return List_Id;\n+         --  Build the declaration of the missing body subprogram and its\n+         --  corresponding pragma Import.\n+\n+         function Build_Missing_Body_Subprogram_Call return Node_Id;\n+         --  Build the call to the missing body subprogram\n+\n+         function Copy_Original_Specification\n+           (Loc  : Source_Ptr;\n+            Spec : Node_Id) return Node_Id;\n+         --  Build a copy of the original specification of the given subprogram\n+         --  specification.\n+\n+         function Skip_Contract_Only_Subprogram (E : Entity_Id) return Boolean;\n+         --  Return True if E is a subprogram declared in a nested package that\n+         --  has some formal or return type depending on a private type defined\n+         --  in an enclosing package.\n+\n+         ------------------------------\n+         -- Build_Missing_Body_Decls --\n+         ------------------------------\n+\n+         function Build_Missing_Body_Decls return List_Id is\n+            Name : constant Name_Id := Get_Contract_Only_Missing_Body_Name (E);\n+            Spec : constant Node_Id := Declaration_Node (E);\n+            Decl : Node_Id;\n+            Prag : Node_Id;\n+\n+         begin\n+            Decl := Make_Subprogram_Declaration (Loc,\n+                      Copy_Original_Specification (Loc, Spec));\n+            Set_Chars (Defining_Unit_Name (Specification (Decl)), Name);\n+\n+            Prag :=\n+              Make_Pragma (Loc,\n+                Chars => Name_Import,\n+                Pragma_Argument_Associations => New_List (\n+                  Make_Pragma_Argument_Association (Loc,\n+                    Expression => Make_Identifier (Loc, Name_Ada)),\n+\n+                  Make_Pragma_Argument_Association (Loc,\n+                    Expression => Make_Identifier (Loc, Name))));\n+\n+            return New_List (Decl, Prag);\n+         end Build_Missing_Body_Decls;\n+\n+         ----------------------------------------\n+         -- Build_Missing_Body_Subprogram_Call --\n+         ----------------------------------------\n+\n+         function Build_Missing_Body_Subprogram_Call return Node_Id is\n+            Forml : Entity_Id;\n+            Parms : List_Id;\n+\n+         begin\n+            --  Build parameter list that we need\n+\n+            Parms := New_List;\n+            Forml := First_Formal (E);\n+            while Present (Forml) loop\n+               Append_To (Parms, Make_Identifier (Loc, Chars (Forml)));\n+               Next_Formal (Forml);\n+            end loop;\n+\n+            --  Build the call to the missing body subprogram\n+\n+            if Ekind_In (E, E_Function, E_Generic_Function) then\n+               return\n+                 Make_Simple_Return_Statement (Loc,\n+                   Expression =>\n+                     Make_Function_Call (Loc,\n+                       Name => Make_Identifier (Loc,\n+                                 Get_Contract_Only_Missing_Body_Name (E)),\n+                       Parameter_Associations => Parms));\n+\n+            else\n+               return\n+                 Make_Procedure_Call_Statement (Loc,\n+                   Name => Make_Identifier (Loc,\n+                             Get_Contract_Only_Missing_Body_Name (E)),\n+                   Parameter_Associations => Parms);\n+            end if;\n+         end Build_Missing_Body_Subprogram_Call;\n+\n+         ---------------------------------\n+         -- Copy_Original_Specification --\n+         ---------------------------------\n+\n+         function Copy_Original_Specification\n+           (Loc  : Source_Ptr;\n+            Spec : Node_Id) return Node_Id\n+         is\n+            function Copy_Original_Type (N : Node_Id) return Node_Id;\n+            --  Duplicate the original type of a given formal or function\n+            --  result type.\n+\n+            function Copy_Original_Type (N : Node_Id) return Node_Id is\n+            begin\n+               --  For expanded names located in instantiations, copy them with\n+               --  semantic information (avoids visibility problems).\n+\n+               if In_Instance\n+                 and then Nkind (N) = N_Expanded_Name\n+               then\n+                  return New_Copy_Tree (N);\n+               else\n+                  return Copy_Separate_Tree (Original_Node (N));\n+               end if;\n+            end Copy_Original_Type;\n+\n+            --  Local variables\n+\n+            Current_Parameter  : Node_Id;\n+            Current_Identifier : Entity_Id;\n+            Current_Type       : Node_Id;\n+            New_Identifier     : Entity_Id;\n+            Parameters         : List_Id := No_List;\n+\n+         --  Start of processing for Copy_Original_Specification\n+\n+         begin\n+            if Present (Parameter_Specifications (Spec)) then\n+               Parameters        := New_List;\n+               Current_Parameter := First (Parameter_Specifications (Spec));\n+               while Present (Current_Parameter) loop\n+                  Current_Identifier :=\n+                    Defining_Identifier (Current_Parameter);\n+                  Current_Type :=\n+                    Copy_Original_Type (Parameter_Type (Current_Parameter));\n+\n+                  New_Identifier := Make_Defining_Identifier (Loc,\n+                    Chars (Current_Identifier));\n+\n+                  Append_To (Parameters,\n+                    Make_Parameter_Specification (Loc,\n+                      Defining_Identifier => New_Identifier,\n+                      Parameter_Type      => Current_Type,\n+                      In_Present          => In_Present (Current_Parameter),\n+                      Out_Present         => Out_Present (Current_Parameter),\n+                      Expression          =>\n+                        Copy_Separate_Tree (Expression (Current_Parameter))));\n+\n+                  Next (Current_Parameter);\n+               end loop;\n+            end if;\n+\n+            case Nkind (Spec) is\n+\n+               when N_Function_Specification =>\n+                  return\n+                    Make_Function_Specification (Loc,\n+                      Defining_Unit_Name       =>\n+                        Make_Defining_Identifier (Loc,\n+                          Chars => Chars (Defining_Unit_Name (Spec))),\n+                      Parameter_Specifications => Parameters,\n+                      Result_Definition        =>\n+                        Copy_Original_Type (Result_Definition (Spec)));\n+\n+               when N_Procedure_Specification =>\n+                  return\n+                    Make_Procedure_Specification (Loc,\n+                      Defining_Unit_Name       =>\n+                        Make_Defining_Identifier (Loc,\n+                          Chars => Chars (Defining_Unit_Name (Spec))),\n+                      Parameter_Specifications => Parameters);\n+\n+               when others =>\n+                  raise Program_Error;\n+            end case;\n+         end Copy_Original_Specification;\n+\n+         -----------------------------------\n+         -- Skip_Contract_Only_Subprogram --\n+         -----------------------------------\n+\n+         function Skip_Contract_Only_Subprogram (E : Entity_Id) return Boolean\n+         is\n+            function Depends_On_Enclosing_Private_Type return Boolean;\n+            --  Return True if some formal of E (or its return type) are\n+            --  private types defined in an enclosing package.\n+\n+            function Some_Enclosing_Package_Has_Private_Decls return Boolean;\n+            --  Return True if some enclosing package of the current scope has\n+            --  private declarations.\n+\n+            ---------------------------------------\n+            -- Depends_On_Enclosing_Private_Type --\n+            ---------------------------------------\n+\n+            function Depends_On_Enclosing_Private_Type return Boolean is\n+\n+               function Defined_In_Enclosing_Package\n+                  (Typ : Entity_Id) return Boolean;\n+               --  Return True if Typ is an entity defined in an enclosing\n+               --  package of the current scope.\n+\n+               ----------------------------------\n+               -- Defined_In_Enclosing_Package --\n+               ----------------------------------\n+\n+               function Defined_In_Enclosing_Package\n+                  (Typ : Entity_Id) return Boolean\n+               is\n+                  Scop : Entity_Id := Scope (Current_Scope);\n+\n+               begin\n+                  while Scop /= Scope (Typ)\n+                     and then not Is_Compilation_Unit (Scop)\n+                  loop\n+                     Scop := Scope (Scop);\n+                  end loop;\n+\n+                  return Scop = Scope (Typ);\n+               end Defined_In_Enclosing_Package;\n+\n+               --  Local variables\n+\n+               Param_E : Entity_Id;\n+               Typ     : Entity_Id;\n+            begin\n+               Param_E := First_Entity (E);\n+               while Present (Param_E) loop\n+                  Typ := Etype (Param_E);\n+\n+                  if Is_Private_Type (Typ)\n+                    and then Defined_In_Enclosing_Package (Typ)\n+                  then\n+                     return True;\n+                  end if;\n+\n+                  Next_Entity (Param_E);\n+               end loop;\n+\n+               return Ekind (E) = E_Function\n+                 and then Is_Private_Type (Etype (E))\n+                 and then Defined_In_Enclosing_Package (Etype (E));\n+            end Depends_On_Enclosing_Private_Type;\n+\n+            ----------------------------------------------\n+            -- Some_Enclosing_Package_Has_Private_Decls --\n+            ----------------------------------------------\n+\n+            function Some_Enclosing_Package_Has_Private_Decls return Boolean is\n+               Scop     : Entity_Id := Current_Scope;\n+               Pkg_Spec : Node_Id   := Package_Specification (Scop);\n+\n+            begin\n+               loop\n+                  if Ekind (Scop) = E_Package\n+                    and then\n+                      Has_Private_Declarations (Package_Specification (Scop))\n+                  then\n+                     Pkg_Spec := Package_Specification (Scop);\n+                  end if;\n+\n+                  exit when Is_Compilation_Unit (Scop);\n+                  Scop := Scope (Scop);\n+               end loop;\n+\n+               return Pkg_Spec /= Package_Specification (Current_Scope);\n+            end Some_Enclosing_Package_Has_Private_Decls;\n+\n+         --  Start of processing for Skip_Contract_Only_Subprogram\n+\n+         begin\n+            if Ekind (Current_Scope) = E_Package\n+              and then Some_Enclosing_Package_Has_Private_Decls\n+              and then Depends_On_Enclosing_Private_Type\n+            then\n+               if Debug_Flag_Dot_KK then\n+                  declare\n+                     Saved_Mode : constant Warning_Mode_Type := Warning_Mode;\n+\n+                  begin\n+                     --  Warnings are disabled by default under CodePeer_Mode\n+                     --  (see switch-c). Enable them temporarily.\n+\n+                     Warning_Mode := Normal;\n+                     Error_Msg_N\n+                       (\"cannot generate contract-only subprogram?\", E);\n+                     Warning_Mode := Saved_Mode;\n+                  end;\n+               end if;\n+\n+               return True;\n+            end if;\n+\n+            return False;\n+         end Skip_Contract_Only_Subprogram;\n+\n+      --  Start of processing for Build_Contract_Only_Subprogram\n+\n+      begin\n+         --  Test cases where the wrapper is not needed and cases where we\n+         --  cannot build the wrapper.\n+\n+         if not CodePeer_Mode\n+           or else Inside_A_Generic\n+           or else not Is_Subprogram (E)\n+           or else Is_Abstract_Subprogram (E)\n+           or else Is_Imported (E)\n+           or else No (Contract (E))\n+           or else No (Pre_Post_Conditions (Contract (E)))\n+           or else Is_Contract_Only_Body (E)\n+           or else Skip_Contract_Only_Subprogram (E)\n+           or else Convention (E) = Convention_Protected\n+         then\n+            return Empty;\n+         end if;\n+\n+         --  Note on calls to Copy_Separate_Tree. The trees we are copying\n+         --  here are fully analyzed, but we definitely want fully syntactic\n+         --  unanalyzed trees in the body we construct, so that the analysis\n+         --  generates the right visibility, and that is exactly what the\n+         --  calls to Copy_Separate_Tree give us.\n+\n+         declare\n+            Name : constant Name_Id := Get_Contract_Only_Body_Name (E);\n+            Id   : Entity_Id;\n+            Bod  : Node_Id;\n+\n+         begin\n+            Bod :=\n+              Make_Subprogram_Body (Loc,\n+                Specification              =>\n+                  Copy_Original_Specification (Loc, Declaration_Node (E)),\n+                Declarations               =>\n+                  Build_Missing_Body_Decls,\n+                Handled_Statement_Sequence =>\n+                  Make_Handled_Sequence_Of_Statements (Loc,\n+                    Statements => New_List (\n+                                    Build_Missing_Body_Subprogram_Call),\n+                    End_Label  => Make_Identifier (Loc, Name)));\n+\n+            Id := Defining_Unit_Name (Specification (Bod));\n+\n+            --  Copy only the pre/postconditions of the original contract\n+            --  since it is what we need, but also because pragmas stored in\n+            --  the other fields have N_Pragmas with N_Aspect_Specifications\n+            --  that reference their associated pragma (thus causing an endless\n+            --  loop when trying to copy the subtree).\n+\n+            declare\n+               New_Contract : constant Node_Id := Make_Contract (Sloc (E));\n+\n+            begin\n+               Set_Pre_Post_Conditions (New_Contract,\n+                 Copy_Separate_Tree (Pre_Post_Conditions (Contract (E))));\n+               Set_Contract (Id, New_Contract);\n+            end;\n+\n+            --  Fix the name of this new subprogram and link the original\n+            --  subprogram with its Contract_Only_Body subprogram.\n+\n+            Set_Chars (Id, Name);\n+            Set_Is_Contract_Only_Body (Id);\n+            Set_Contract_Only_Body (E, Id);\n+\n+            return Bod;\n+         end;\n+      end Build_Contract_Only_Subprogram;\n+\n+      -------------------------------------\n+      -- Build_Contract_Only_Subprograms --\n+      -------------------------------------\n+\n+      function Build_Contract_Only_Subprograms (L : List_Id) return List_Id is\n+         Decl     : Node_Id;\n+         Subp_Id  : Entity_Id;\n+         New_Subp : Node_Id;\n+         Result   : List_Id := No_List;\n+\n+      begin\n+         Decl := First (L);\n+         while Present (Decl) loop\n+            if Nkind (Decl) = N_Subprogram_Declaration then\n+               Subp_Id  := Defining_Unit_Name (Specification (Decl));\n+               New_Subp := Build_Contract_Only_Subprogram (Subp_Id);\n+\n+               if Present (New_Subp) then\n+                  if No (Result) then\n+                     Result := New_List;\n+                  end if;\n+\n+                  Append_To (Result, New_Subp);\n+               end if;\n+            end if;\n+\n+            Next (Decl);\n+         end loop;\n+\n+         return Result;\n+      end Build_Contract_Only_Subprograms;\n+\n+      ------------------------------\n+      -- Has_Private_Declarations --\n+      ------------------------------\n+\n+      function Has_Private_Declarations (N : Node_Id) return Boolean is\n+      begin\n+         if not Nkind_In (N, N_Package_Specification,\n+                             N_Task_Definition,\n+                             N_Protected_Definition)\n+         then\n+            return False;\n+         else\n+            return Present (Private_Declarations (N))\n+               and then Is_Non_Empty_List (Private_Declarations (N));\n+         end if;\n+      end Has_Private_Declarations;\n+\n+      --  Local variables\n+\n+      Subp_List : List_Id;\n+\n+   --  Start of processing for Build_And_Analyze_Contract_Only_Subprograms\n+\n+   begin\n+      Subp_List := Build_Contract_Only_Subprograms (L);\n+      Append_Contract_Only_Subprograms (Subp_List);\n+      Analyze_Contract_Only_Subprograms (L);\n+   end Build_And_Analyze_Contract_Only_Subprograms;\n+\n end Contracts;"}, {"sha": "a045a7b63bd9b55d07d5be946bca0163f75e0a01", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f325af2606476be7ef1db50b1a46ab842901bb9/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f325af2606476be7ef1db50b1a46ab842901bb9/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=5f325af2606476be7ef1db50b1a46ab842901bb9", "patch": "@@ -128,7 +128,7 @@ package body Debug is\n    --  d.H  GNSA mode for ASIS\n    --  d.I  Do not ignore enum representation clauses in CodePeer mode\n    --  d.J  Disable parallel SCIL generation mode\n-   --  d.K\n+   --  d.K  Enable generation of contract-only procedures in CodePeer mode\n    --  d.L  Depend on back end for limited types in if and case expressions\n    --  d.M  Relaxed RM semantics\n    --  d.N  Add node to all entities\n@@ -646,6 +646,13 @@ package body Debug is\n    --       done in parallel to speed processing. This switch disables this\n    --       behavior.\n \n+   --  d.K  Enable generation of contract-only procedures in CodePeer mode and\n+   --       report a warning on subprograms for which the contract-only body\n+   --       cannot be built. Currently reported on subprograms defined in\n+   --       nested package specs that have some formal (or return type) whose\n+   --       type is a private type defined in some enclosing package and that\n+   --       have pre/postconditions.\n+\n    --  d.L  Normally the front end generates special expansion for conditional\n    --       expressions of a limited type. This debug flag removes this special\n    --       case expansion, leaving it up to the back end to handle conditional"}, {"sha": "074a5b1a6cf2e8b31a71de36449af75aba997269", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f325af2606476be7ef1db50b1a46ab842901bb9/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f325af2606476be7ef1db50b1a46ab842901bb9/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=5f325af2606476be7ef1db50b1a46ab842901bb9", "patch": "@@ -3244,7 +3244,11 @@ package body Exp_Attr is\n             Rewrite (N, Make_Integer_Literal (Loc, 0));\n          end if;\n \n-         Analyze (N);\n+         --  Due to cases where the entity type of the attribute is already\n+         --  resolved the rewritten N must get re-resolved to its appropriate\n+         --  type.\n+\n+         Analyze_And_Resolve (N, Typ);\n       end Finalization_Size;\n \n       -----------"}, {"sha": "ed3703a19e8c96ba0edab9fbf74476093acab808", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f325af2606476be7ef1db50b1a46ab842901bb9/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f325af2606476be7ef1db50b1a46ab842901bb9/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=5f325af2606476be7ef1db50b1a46ab842901bb9", "patch": "@@ -2939,7 +2939,7 @@ package body Exp_Ch5 is\n       --  For an element iterator, the Element aspect must be present,\n       --  (this is checked during analysis) and the expansion takes the form:\n \n-      --    Cursor : Cursor_type := First (Container);\n+      --    Cursor : Cursor_Type := First (Container);\n       --    Elmt : Element_Type;\n       --    while Has_Element (Cursor, Container) loop\n       --       Elmt := Element (Container, Cursor);\n@@ -2951,10 +2951,10 @@ package body Exp_Ch5 is\n       --   In that case we create a block to hold a variable declaration\n       --   initialized with a call to Element, and generate:\n \n-      --    Cursor : Cursor_type := First (Container);\n+      --    Cursor : Cursor_Type := First (Container);\n       --    while Has_Element (Cursor, Container) loop\n       --       declare\n-      --          Elmt : Element-Type := Element (Container, Cursor);\n+      --          Elmt : Element_Type := Element (Container, Cursor);\n       --       begin\n       --          <original loop statements>\n       --          Cursor := Next (Container, Cursor);\n@@ -2968,7 +2968,7 @@ package body Exp_Ch5 is\n       Set_Ekind (Cursor, E_Variable);\n       Insert_Action (N, Init);\n \n-      --  Declaration for Element.\n+      --  Declaration for Element\n \n       Elmt_Decl :=\n         Make_Object_Declaration (Loc,"}, {"sha": "7b7e1351b9f345c1a32627159f8a2a27e6e290ee", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f325af2606476be7ef1db50b1a46ab842901bb9/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f325af2606476be7ef1db50b1a46ab842901bb9/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=5f325af2606476be7ef1db50b1a46ab842901bb9", "patch": "@@ -2264,7 +2264,9 @@ package body Exp_Ch6 is\n       --  expression for the value of the actual, EF is the entity for the\n       --  extra formal.\n \n-      procedure Check_View_Conversion (Formal : Entity_Id; Actual : Node_Id);\n+      procedure Add_View_Conversion_Invariants\n+        (Formal : Entity_Id;\n+         Actual : Node_Id);\n       --  Adds invariant checks for every intermediate type between the range\n       --  of a view converted argument to its ancestor (from parent to child).\n \n@@ -2354,11 +2356,14 @@ package body Exp_Ch6 is\n          end if;\n       end Add_Extra_Actual;\n \n-      ---------------------------\n-      -- Check_View_Conversion --\n-      ---------------------------\n+      ------------------------------------\n+      -- Add_View_Conversion_Invariants --\n+      ------------------------------------\n \n-      procedure Check_View_Conversion (Formal : Entity_Id; Actual : Node_Id) is\n+      procedure Add_View_Conversion_Invariants\n+        (Formal : Entity_Id;\n+         Actual : Node_Id)\n+      is\n          Arg        : Entity_Id;\n          Curr_Typ   : Entity_Id;\n          Inv_Checks : List_Id;\n@@ -2407,7 +2412,7 @@ package body Exp_Ch6 is\n          if not Is_Empty_List (Inv_Checks) then\n             Insert_Actions_After (N, Inv_Checks);\n          end if;\n-      end Check_View_Conversion;\n+      end Add_View_Conversion_Invariants;\n \n       ---------------------------\n       -- Inherited_From_Formal --\n@@ -3292,15 +3297,18 @@ package body Exp_Ch6 is\n                 Duplicate_Subexpr_Move_Checks (Actual)));\n          end if;\n \n-         --  Invariant checks are performed for every intermediate type between\n-         --  the range of a view converted argument to its ancestor (from\n-         --  parent to child) if it is passed as an \"out\" or \"in out\" parameter\n-         --  after executing the call (RM 7.3.2 (12/3, 13/3, 14/3)).\n+         --  Perform invariant checks for all intermediate types in a view\n+         --  conversion after successful return from a call that passes the\n+         --  view conversion as an IN OUT or OUT parameter (RM 7.3.2 (12/3,\n+         --  13/3, 14/3)). Consider only source conversion in order to avoid\n+         --  generating spurious checks on complex expansion such as object\n+         --  initialization through an extension aggregate.\n \n-         if Ekind (Formal) /= E_In_Parameter\n+         if Comes_From_Source (N)\n+           and then Ekind (Formal) /= E_In_Parameter\n            and then Nkind (Actual) = N_Type_Conversion\n          then\n-            Check_View_Conversion (Formal, Actual);\n+            Add_View_Conversion_Invariants (Formal, Actual);\n          end if;\n \n          --  This label is required when skipping extra actual generation for"}, {"sha": "0ba76698884f7c52f685412c3960fc59d8230253", "filename": "gcc/ada/exp_sel.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f325af2606476be7ef1db50b1a46ab842901bb9/gcc%2Fada%2Fexp_sel.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f325af2606476be7ef1db50b1a46ab842901bb9/gcc%2Fada%2Fexp_sel.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_sel.ads?ref=5f325af2606476be7ef1db50b1a46ab842901bb9", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -48,7 +48,7 @@ package Exp_Sel is\n    function Build_Abort_Block_Handler (Loc : Source_Ptr) return Node_Id;\n    --  Generate if front-end exception:\n    --    when others =>\n-   --      Abort_Under;\n+   --      Abort_Undefer;\n    --  or if back-end exception:\n    --    when others =>\n    --      null;"}, {"sha": "a0721f6b62452a56dae54b696e4967ab38351240", "filename": "gcc/ada/exp_spark.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f325af2606476be7ef1db50b1a46ab842901bb9/gcc%2Fada%2Fexp_spark.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f325af2606476be7ef1db50b1a46ab842901bb9/gcc%2Fada%2Fexp_spark.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_spark.adb?ref=5f325af2606476be7ef1db50b1a46ab842901bb9", "patch": "@@ -140,7 +140,7 @@ package body Exp_SPARK is\n             --  Otherwise the renamed object denotes a name\n \n             else\n-               Rewrite (N, New_Copy_Tree (Obj_Id));\n+               Rewrite (N, New_Copy_Tree (Obj_Id, New_Sloc => Loc));\n                Reset_Analyzed_Flags (N);\n             end if;\n "}, {"sha": "f19b6e3224f3f005eb5260bb5564ed328edfbd8d", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f325af2606476be7ef1db50b1a46ab842901bb9/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f325af2606476be7ef1db50b1a46ab842901bb9/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=5f325af2606476be7ef1db50b1a46ab842901bb9", "patch": "@@ -1897,13 +1897,19 @@ package body Exp_Util is\n       Set_Corresponding_Spec (Proc_Body, Proc_Id);\n \n       --  The body should not be inserted into the tree when the context is\n-      --  ASIS, GNATprove or a generic unit because it is not part of the\n-      --  template. Note that the body must still be generated in order to\n-      --  resolve the DIC assertion expression.\n+      --  ASIS or a generic unit because it is not part of the template. Note\n+      --  that the body must still be generated in order to resolve the DIC\n+      --  assertion expression.\n \n-      if ASIS_Mode or GNATprove_Mode or Inside_A_Generic then\n+      if ASIS_Mode or Inside_A_Generic then\n          null;\n \n+      --  Semi-insert the body into the tree for GNATprove by setting its\n+      --  Parent field. This allows for proper upstream tree traversals.\n+\n+      elsif GNATprove_Mode then\n+         Set_Parent (Proc_Body, Parent (Declaration_Node (Work_Typ)));\n+\n       --  Otherwise the body is part of the freezing actions of the working\n       --  type.\n \n@@ -2083,16 +2089,20 @@ package body Exp_Util is\n                     New_Occurrence_Of (Work_Typ, Loc)))));\n \n       --  The declaration should not be inserted into the tree when the context\n-      --  is ASIS, GNATprove, or a generic unit because it is not part of the\n-      --  template.\n+      --  is ASIS or a generic unit because it is not part of the template.\n \n-      if ASIS_Mode or GNATprove_Mode or Inside_A_Generic then\n+      if ASIS_Mode or Inside_A_Generic then\n          null;\n \n+      --  Semi-insert the declaration into the tree for GNATprove by setting\n+      --  its Parent field. This allows for proper upstream tree traversals.\n+\n+      elsif GNATprove_Mode then\n+         Set_Parent (Proc_Decl, Parent (Typ_Decl));\n+\n       --  Otherwise insert the declaration\n \n       else\n-         pragma Assert (Present (Typ_Decl));\n          Insert_After_And_Analyze (Typ_Decl, Proc_Decl);\n       end if;\n "}, {"sha": "0060c9e1869ea37df777b925f5990f15e5d096ee", "filename": "gcc/ada/lib-writ.ads", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f325af2606476be7ef1db50b1a46ab842901bb9/gcc%2Fada%2Flib-writ.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f325af2606476be7ef1db50b1a46ab842901bb9/gcc%2Fada%2Flib-writ.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.ads?ref=5f325af2606476be7ef1db50b1a46ab842901bb9", "patch": "@@ -649,10 +649,8 @@ package Lib.Writ is\n    --        AD  Elaborate_All_Desirable set for this unit, which means that\n    --            there is no Elaborate_All, but the analysis suggests that\n    --            Program_Error may be raised if the Elaborate_All conditions\n-   --            cannot be satisfied. In dynamic elaboration mode, the binder\n-   --            will attempt to treat AD as EA if it can. In static\n-   --            elaboration mode, the binder will treat AD as EA, even if it\n-   --            introduces cycles.\n+   --            cannot be satisfied. The binder will attempt to treat AD as\n+   --            EA if it can.\n \n    --      The parameter source-name and lib-name are omitted for the case of a\n    --      generic unit compiled with earlier versions of GNAT which did not"}, {"sha": "eed0d1a5b42d260f58d95cacc8718406b9e1b8d9", "filename": "gcc/ada/scil_ll.adb", "status": "modified", "additions": 134, "deletions": 44, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f325af2606476be7ef1db50b1a46ab842901bb9/gcc%2Fada%2Fscil_ll.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f325af2606476be7ef1db50b1a46ab842901bb9/gcc%2Fada%2Fscil_ll.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscil_ll.adb?ref=5f325af2606476be7ef1db50b1a46ab842901bb9", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2010-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2010-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,63 +29,105 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Alloc; use Alloc;\n-with Atree; use Atree;\n-with Opt;   use Opt;\n-with Sinfo; use Sinfo;\n-with Table;\n+with Atree;         use Atree;\n+with Opt;           use Opt;\n+with Sinfo;         use Sinfo;\n+with System.HTable; use System.HTable;\n \n package body SCIL_LL is\n+   Contract_Only_Body_Suffix : constant String := \"__contract_only\";\n+   --  Suffix of Contract_Only_Body subprograms internally built only under\n+   --  CodePeer mode\n+\n+   Contract_Only_Missing_Body_Suffix : constant String := \"__missing_body\";\n+   --  Suffix of Contract_Only_Missing_Body subprograms internally built only\n+   --  under CodePeer mode\n \n    procedure Copy_SCIL_Node (Target : Node_Id; Source : Node_Id);\n    --  Copy the SCIL field from Source to Target (it is used as the argument\n    --  for a call to Set_Reporting_Proc in package atree).\n \n-   function SCIL_Nodes_Table_Size return Pos;\n-   --  Used to initialize the table of SCIL nodes because we do not want\n-   --  to consume memory for this table if it is not required.\n+   type Header_Num is range 1 .. 4096;\n+\n+   function Hash (N : Node_Id) return Header_Num;\n+   --  Hash function for Node_Ids\n+\n+   --------------------------\n+   -- Internal Hash Tables --\n+   --------------------------\n+\n+   package Contract_Only_Body_Flag is new Simple_HTable\n+     (Header_Num => Header_Num,\n+      Element    => Boolean,\n+      No_Element => False,\n+      Key        => Node_Id,\n+      Hash       => Hash,\n+      Equal      => \"=\");\n+   --  This table records the value of flag Is_Contract_Only_Flag of tree nodes\n+\n+   package Contract_Only_Body_Nodes is new Simple_HTable\n+     (Header_Num => Header_Num,\n+      Element    => Node_Id,\n+      No_Element => Empty,\n+      Key        => Node_Id,\n+      Hash       => Hash,\n+      Equal      => \"=\");\n+   --  This table records the value of attribute Contract_Only_Body of tree\n+   --  nodes.\n+\n+   package SCIL_Nodes is new Simple_HTable\n+     (Header_Num => Header_Num,\n+      Element    => Node_Id,\n+      No_Element => Empty,\n+      Key        => Node_Id,\n+      Hash       => Hash,\n+      Equal      => \"=\");\n+   --  This table records the value of attribute SCIL_Node of tree nodes.\n+\n+   --------------------\n+   -- Copy_SCIL_Node --\n+   --------------------\n+\n+   procedure Copy_SCIL_Node (Target : Node_Id; Source : Node_Id) is\n+   begin\n+      Set_SCIL_Node (Target, Get_SCIL_Node (Source));\n+   end Copy_SCIL_Node;\n \n    ----------------------------\n-   --  SCIL_Nodes_Table_Size --\n+   -- Get_Contract_Only_Body --\n    ----------------------------\n \n-   function SCIL_Nodes_Table_Size return Pos is\n+   function Get_Contract_Only_Body (N : Node_Id) return Node_Id is\n    begin\n-      if Generate_SCIL then\n-         return Alloc.Orig_Nodes_Initial;\n+      if CodePeer_Mode\n+        and then Present (N)\n+      then\n+         return Contract_Only_Body_Nodes.Get (N);\n       else\n-         return 1;\n+         return Empty;\n       end if;\n-   end SCIL_Nodes_Table_Size;\n-\n-   package SCIL_Nodes is new Table.Table (\n-      Table_Component_Type => Node_Id,\n-      Table_Index_Type     => Node_Id'Base,\n-      Table_Low_Bound      => First_Node_Id,\n-      Table_Initial        => SCIL_Nodes_Table_Size,\n-      Table_Increment      => Alloc.Orig_Nodes_Increment,\n-      Table_Name           => \"SCIL_Nodes\");\n-   --  This table records the value of attribute SCIL_Node of all the\n-   --  tree nodes.\n+   end Get_Contract_Only_Body;\n \n-   --------------------\n-   -- Copy_SCIL_Node --\n-   --------------------\n+   ---------------------------------\n+   -- Get_Contract_Only_Body_Name --\n+   ---------------------------------\n \n-   procedure Copy_SCIL_Node (Target : Node_Id; Source : Node_Id) is\n+   function Get_Contract_Only_Body_Name (E : Entity_Id) return Name_Id is\n    begin\n-      Set_SCIL_Node (Target, Get_SCIL_Node (Source));\n-   end Copy_SCIL_Node;\n+      return Name_Find (Get_Name_String (Chars (E)) &\n+                          Contract_Only_Body_Suffix);\n+   end Get_Contract_Only_Body_Name;\n \n-   ----------------\n-   -- Initialize --\n-   ----------------\n+   -----------------------------------------\n+   -- Get_Contract_Only_Missing_Body_Name --\n+   -----------------------------------------\n \n-   procedure Initialize is\n+   function Get_Contract_Only_Missing_Body_Name (E : Entity_Id)\n+      return Name_Id is\n    begin\n-      SCIL_Nodes.Init;\n-      Set_Reporting_Proc (Copy_SCIL_Node'Access);\n-   end Initialize;\n+      return Name_Find (Get_Name_String (Chars (E)) &\n+                          Contract_Only_Missing_Body_Suffix);\n+   end Get_Contract_Only_Missing_Body_Name;\n \n    -------------------\n    -- Get_SCIL_Node --\n@@ -96,12 +138,64 @@ package body SCIL_LL is\n       if Generate_SCIL\n         and then Present (N)\n       then\n-         return SCIL_Nodes.Table (N);\n+         return SCIL_Nodes.Get (N);\n       else\n          return Empty;\n       end if;\n    end Get_SCIL_Node;\n \n+   ----------\n+   -- Hash --\n+   ----------\n+\n+   function Hash (N : Node_Id) return Header_Num is\n+   begin\n+      return Header_Num (1 + N mod Node_Id (Header_Num'Last));\n+   end Hash;\n+\n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   procedure Initialize is\n+   begin\n+      SCIL_Nodes.Reset;\n+      Contract_Only_Body_Nodes.Reset;\n+      Contract_Only_Body_Flag.Reset;\n+      Set_Reporting_Proc (Copy_SCIL_Node'Access);\n+   end Initialize;\n+\n+   ---------------------------\n+   -- Is_Contract_Only_Body --\n+   ---------------------------\n+\n+   function Is_Contract_Only_Body (E : Entity_Id) return Boolean is\n+   begin\n+      return Contract_Only_Body_Flag.Get (E);\n+   end Is_Contract_Only_Body;\n+\n+   ----------------------------\n+   -- Set_Contract_Only_Body --\n+   ----------------------------\n+\n+   procedure Set_Contract_Only_Body (N : Node_Id; Value : Node_Id) is\n+   begin\n+      pragma Assert (CodePeer_Mode\n+        and then Present (N)\n+        and then Is_Contract_Only_Body (Value));\n+\n+      Contract_Only_Body_Nodes.Set (N, Value);\n+   end Set_Contract_Only_Body;\n+\n+   -------------------------------\n+   -- Set_Is_Contract_Only_Body --\n+   -------------------------------\n+\n+   procedure Set_Is_Contract_Only_Body (E : Entity_Id) is\n+   begin\n+      Contract_Only_Body_Flag.Set (E, True);\n+   end Set_Is_Contract_Only_Body;\n+\n    -------------------\n    -- Set_SCIL_Node --\n    -------------------\n@@ -133,11 +227,7 @@ package body SCIL_LL is\n          end case;\n       end if;\n \n-      if Atree.Last_Node_Id > SCIL_Nodes.Last then\n-         SCIL_Nodes.Set_Last (Atree.Last_Node_Id);\n-      end if;\n-\n-      SCIL_Nodes.Set_Item (N, Value);\n+      SCIL_Nodes.Set (N, Value);\n    end Set_SCIL_Node;\n \n end SCIL_LL;"}, {"sha": "bfac1a05e4d0b34c36cfeb1719a235b91677ba6c", "filename": "gcc/ada/scil_ll.ads", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f325af2606476be7ef1db50b1a46ab842901bb9/gcc%2Fada%2Fscil_ll.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f325af2606476be7ef1db50b1a46ab842901bb9/gcc%2Fada%2Fscil_ll.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscil_ll.ads?ref=5f325af2606476be7ef1db50b1a46ab842901bb9", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---             Copyright (C) 2010, Free Software Foundation, Inc.           --\n+--          Copyright (C) 2010-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,20 +29,39 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This package extends the tree nodes with a field that is used to reference\n---  the SCIL node.\n+--  This package extends the tree nodes with fields that are used to reference\n+--  the SCIL node and the Contract_Only_Body of a subprogram with aspects.\n \n+with Namet; use Namet;\n with Types; use Types;\n \n package SCIL_LL is\n \n+   function Get_Contract_Only_Body_Name (E : Entity_Id) return Name_Id;\n+   --  Return the name of the Contract_Only_Body subprogram of E\n+\n+   function Get_Contract_Only_Missing_Body_Name (E : Entity_Id) return Name_Id;\n+   --  Return the name of the Contract_Only_Missing_Body subprogram of E\n+\n+   function Get_Contract_Only_Body (N : Node_Id) return Node_Id;\n+   --  Read the value of attribute Contract_Only_Body\n+\n    function Get_SCIL_Node (N : Node_Id) return Node_Id;\n    --  Read the value of attribute SCIL node\n \n+   procedure Set_Contract_Only_Body (N : Node_Id; Value : Node_Id);\n+   --  Set the value of attribute Contract_Only_Body\n+\n    procedure Set_SCIL_Node (N : Node_Id; Value : Node_Id);\n    --  Set the value of attribute SCIL node\n \n    procedure Initialize;\n    --  Initialize the table of SCIL nodes\n \n+   function Is_Contract_Only_Body (E : Entity_Id) return Boolean;\n+   --  Return True if E is a Contract_Only_Body subprogram\n+\n+   procedure Set_Is_Contract_Only_Body (E : Entity_Id);\n+   --  Set E as Contract_Only_Body subprogram\n+\n end SCIL_LL;"}, {"sha": "6cd050e7fb6d4591898389ba23292cdfde9df23a", "filename": "gcc/ada/sem.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f325af2606476be7ef1db50b1a46ab842901bb9/gcc%2Fada%2Fsem.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f325af2606476be7ef1db50b1a46ab842901bb9/gcc%2Fada%2Fsem.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem.ads?ref=5f325af2606476be7ef1db50b1a46ab842901bb9", "patch": "@@ -523,8 +523,8 @@ package Sem is\n       --  See Sem_Ch10 (Install_Parents, Remove_Parents).\n \n       Node_To_Be_Wrapped : Node_Id;\n-      --  Only used in transient scopes. Records the node which will\n-      --  be wrapped by the transient block.\n+      --  Only used in transient scopes. Records the node which will be wrapped\n+      --  by the transient block.\n \n       Actions_To_Be_Wrapped : Scope_Actions;\n       --  Actions that have to be inserted at the start, at the end, or as"}, {"sha": "1c5fe4cb056bdcc181ef162661de5e662fb651b9", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f325af2606476be7ef1db50b1a46ab842901bb9/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f325af2606476be7ef1db50b1a46ab842901bb9/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=5f325af2606476be7ef1db50b1a46ab842901bb9", "patch": "@@ -11810,8 +11810,7 @@ package body Sem_Res is\n       -- Valid_Array_Conversion --\n       ----------------------------\n \n-      function Valid_Array_Conversion return Boolean\n-      is\n+      function Valid_Array_Conversion return Boolean is\n          Opnd_Comp_Type : constant Entity_Id := Component_Type (Opnd_Type);\n          Opnd_Comp_Base : constant Entity_Id := Base_Type (Opnd_Comp_Type);\n "}, {"sha": "555184a392810ea44ae1f3ec10dafaf921e769f6", "filename": "gcc/ada/sem_type.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f325af2606476be7ef1db50b1a46ab842901bb9/gcc%2Fada%2Fsem_type.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f325af2606476be7ef1db50b1a46ab842901bb9/gcc%2Fada%2Fsem_type.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_type.adb?ref=5f325af2606476be7ef1db50b1a46ab842901bb9", "patch": "@@ -307,7 +307,6 @@ package body Sem_Type is\n             else\n                Get_Next_Interp (I, It);\n             end if;\n-\n          end loop;\n \n          All_Interp.Table (All_Interp.Last) := (Name, Typ, Abstr_Op);"}]}