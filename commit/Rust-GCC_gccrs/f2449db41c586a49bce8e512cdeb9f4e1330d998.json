{"sha": "f2449db41c586a49bce8e512cdeb9f4e1330d998", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjI0NDlkYjQxYzU4NmE0OWJjZThlNTEyY2RlYjlmNGUxMzMwZDk5OA==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2007-09-02T17:44:37Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2007-09-02T17:44:37Z"}, "message": "decl.c (match_string_p): New helper function to explicitly match a string of characters.\n\n\n\t* decl.c (match_string_p): New helper function to explicitly match\n\ta string of characters.\n\t(match_attr_spec): Remove no longer needed DECL_COLON from decl_types.\n\tDelete decls array and peek_char.  Rewrite decl attribute parser to\n\tavoid calling gfc_match_strings.\n\t* match.c (gfc_match_strings): Delete unused function.\n\t* match.h (gfc_match_strings): Delete prototype.\n\nFrom-SVN: r128028", "tree": {"sha": "55128b82c7e60dce137d947dba21f608c81bbff0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/55128b82c7e60dce137d947dba21f608c81bbff0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f2449db41c586a49bce8e512cdeb9f4e1330d998", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2449db41c586a49bce8e512cdeb9f4e1330d998", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2449db41c586a49bce8e512cdeb9f4e1330d998", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2449db41c586a49bce8e512cdeb9f4e1330d998/comments", "author": null, "committer": null, "parents": [{"sha": "b35c5f019f9dcbee023c54f25be644d90a5a76ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b35c5f019f9dcbee023c54f25be644d90a5a76ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b35c5f019f9dcbee023c54f25be644d90a5a76ac"}], "stats": {"total": 309, "additions": 180, "deletions": 129}, "files": [{"sha": "b0cb8c9a2ad93cab0ff865734a69ee61a0b77dff", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2449db41c586a49bce8e512cdeb9f4e1330d998/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2449db41c586a49bce8e512cdeb9f4e1330d998/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=f2449db41c586a49bce8e512cdeb9f4e1330d998", "patch": "@@ -1,3 +1,13 @@\n+2007-09-02  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* decl.c (match_string_p): New helper function to explicitly match\n+\ta string of characters.\n+\t(match_attr_spec): Remove no longer needed DECL_COLON from decl_types.\n+\tDelete decls array and peek_char.  Rewrite decl attribute parser to\n+\tavoid calling gfc_match_strings.\n+\t* match.c (gfc_match_strings): Delete unused function.\n+\t* match.h (gfc_match_strings): Delete prototype.\n+\n 2007-09-02  Tobias Schl\ufffduter  <tobi@gcc.gnu.org>\n \n \t* dump-parse-tree.c (show_char_const): New function."}, {"sha": "b1f4f35d94a633374fa98de3ff2b25aa3fba8531", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 170, "deletions": 44, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2449db41c586a49bce8e512cdeb9f4e1330d998/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2449db41c586a49bce8e512cdeb9f4e1330d998/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=f2449db41c586a49bce8e512cdeb9f4e1330d998", "patch": "@@ -2468,6 +2468,21 @@ gfc_match_import (void)\n }\n \n \n+/* A minimal implementation of gfc_match without whitespace, escape\n+   characters or variable arguments.  Returns true if the next\n+   characters match the TARGET template exactly.  */\n+\n+static bool\n+match_string_p (const char *target)\n+{\n+  const char *p;\n+\n+  for (p = target; *p; p++)\n+    if (gfc_next_char () != *p)\n+      return false;\n+  return true;\n+}\n+\n /* Matches an attribute specification including array specs.  If\n    successful, leaves the variables current_attr and current_as\n    holding the specification.  Also sets the colon_seen variable for\n@@ -2488,43 +2503,20 @@ match_attr_spec (void)\n     DECL_IN, DECL_OUT, DECL_INOUT, DECL_INTRINSIC, DECL_OPTIONAL,\n     DECL_PARAMETER, DECL_POINTER, DECL_PROTECTED, DECL_PRIVATE,\n     DECL_PUBLIC, DECL_SAVE, DECL_TARGET, DECL_VALUE, DECL_VOLATILE,\n-    DECL_IS_BIND_C, DECL_COLON, DECL_NONE,\n+    DECL_IS_BIND_C, DECL_NONE,\n     GFC_DECL_END /* Sentinel */\n   }\n   decl_types;\n \n /* GFC_DECL_END is the sentinel, index starts at 0.  */\n #define NUM_DECL GFC_DECL_END\n \n-  static mstring decls[] = {\n-    minit (\", allocatable\", DECL_ALLOCATABLE),\n-    minit (\", dimension\", DECL_DIMENSION),\n-    minit (\", external\", DECL_EXTERNAL),\n-    minit (\", intent ( in )\", DECL_IN),\n-    minit (\", intent ( out )\", DECL_OUT),\n-    minit (\", intent ( in out )\", DECL_INOUT),\n-    minit (\", intrinsic\", DECL_INTRINSIC),\n-    minit (\", optional\", DECL_OPTIONAL),\n-    minit (\", parameter\", DECL_PARAMETER),\n-    minit (\", pointer\", DECL_POINTER),\n-    minit (\", protected\", DECL_PROTECTED),\n-    minit (\", private\", DECL_PRIVATE),\n-    minit (\", public\", DECL_PUBLIC),\n-    minit (\", save\", DECL_SAVE),\n-    minit (\", target\", DECL_TARGET),\n-    minit (\", value\", DECL_VALUE),\n-    minit (\", volatile\", DECL_VOLATILE),\n-    minit (\"::\", DECL_COLON),\n-    minit (NULL, DECL_NONE)\n-  };\n-\n   locus start, seen_at[NUM_DECL];\n   int seen[NUM_DECL];\n   decl_types d;\n   const char *attr;\n   match m;\n   try t;\n-  char peek_char;\n \n   gfc_clear_attr (&current_attr);\n   start = gfc_current_locus;\n@@ -2538,29 +2530,171 @@ match_attr_spec (void)\n \n   for (;;)\n     {\n-      d = (decl_types) gfc_match_strings (decls);\n+      int ch;\n \n-      if (d == DECL_NONE)\n+      d = DECL_NONE;\n+      gfc_gobble_whitespace ();\n+\n+      ch = gfc_next_char ();\n+      if (ch == ':')\n+\t{\n+\t  /* This is the successful exit condition for the loop.  */\n+\t  if (gfc_next_char () == ':')\n+\t    break;\n+\t}\n+      else if (ch == ',')\n \t{\n-\t  /* See if we can find the bind(c) since all else failed. \n-\t     We need to skip over any whitespace and stop on the ','.  */\n \t  gfc_gobble_whitespace ();\n-\t  peek_char = gfc_peek_char ();\n-\t  if (peek_char == ',')\n+\t  switch (gfc_peek_char ())\n \t    {\n-\t      /* Chomp the comma.  */\n-\t      peek_char = gfc_next_char ();\n+\t    case 'a':\n+\t      if (match_string_p (\"allocatable\"))\n+\t\td = DECL_ALLOCATABLE;\n+\t      break;\n+\n+\t    case 'b':\n \t      /* Try and match the bind(c).  */\n \t      m = gfc_match_bind_c (NULL);\n \t      if (m == MATCH_YES)\n \t\td = DECL_IS_BIND_C;\n \t      else if (m == MATCH_ERROR)\n \t\tgoto cleanup;\n+\t      break;\n+\n+\t    case 'd':\n+\t      if (match_string_p (\"dimension\"))\n+\t\td = DECL_DIMENSION;\n+\t      break;\n+\n+\t    case 'e':\n+\t      if (match_string_p (\"external\"))\n+\t\td = DECL_EXTERNAL;\n+\t      break;\n+\n+\t    case 'i':\n+\t      if (match_string_p (\"int\"))\n+\t\t{\n+\t\t  ch = gfc_next_char ();\n+\t\t  if (ch == 'e')\n+\t\t    {\n+\t\t      if (match_string_p (\"nt\"))\n+\t\t\t{\n+\t\t\t  /* Matched \"intent\".  */\n+\t\t\t  /* TODO: Call match_intent_spec from here.  */\n+\t\t\t  if (gfc_match (\" ( in out )\") == MATCH_YES)\n+\t\t\t    d = DECL_INOUT;\n+\t\t\t  else if (gfc_match (\" ( in )\") == MATCH_YES)\n+\t\t\t    d = DECL_IN;\n+\t\t\t  else if (gfc_match (\" ( out )\") == MATCH_YES)\n+\t\t\t    d = DECL_OUT;\n+\t\t\t}\n+\t\t    }\n+\t\t  else if (ch == 'r')\n+\t\t    {\n+\t\t      if (match_string_p (\"insic\"))\n+\t\t\t{\n+\t\t\t  /* Matched \"intrinsic\".  */\n+\t\t\t  d = DECL_INTRINSIC;\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t      break;\n+\n+\t    case 'o':\n+\t      if (match_string_p (\"optional\"))\n+\t\td = DECL_OPTIONAL;\n+\t      break;\n+\n+\t    case 'p':\n+\t      gfc_next_char ();\n+\t      switch (gfc_next_char ())\n+\t\t{\n+\t\tcase 'a':\n+\t\t  if (match_string_p (\"rameter\"))\n+\t\t    {\n+\t\t      /* Matched \"parameter\".  */\n+\t\t      d = DECL_PARAMETER;\n+\t\t    }\n+\t\t  break;\n+\n+\t\tcase 'o':\n+\t\t  if (match_string_p (\"inter\"))\n+\t\t    {\n+\t\t      /* Matched \"pointer\".  */\n+\t\t      d = DECL_POINTER;\n+\t\t    }\n+\t\t  break;\n+\n+\t\tcase 'r':\n+\t\t  ch = gfc_next_char ();\n+\t\t  if (ch == 'i')\n+\t\t    {\n+\t\t      if (match_string_p (\"vate\"))\n+\t\t\t{\n+\t\t\t  /* Matched \"private\".  */\n+\t\t\t  d = DECL_PRIVATE;\n+\t\t\t}\n+\t\t    }\n+\t\t  else if (ch == 'o')\n+\t\t    {\n+\t\t      if (match_string_p (\"tected\"))\n+\t\t\t{\n+\t\t\t  /* Matched \"protected\".  */\n+\t\t\t  d = DECL_PROTECTED;\n+\t\t\t}\n+\t\t    }\n+\t\t  break;\n+\n+\t\tcase 'u':\n+\t\t  if (match_string_p (\"blic\"))\n+\t\t    {\n+\t\t      /* Matched \"public\".  */\n+\t\t      d = DECL_PUBLIC;\n+\t\t    }\n+\t\t  break;\n+\t\t}\n+\t      break;\n+\n+\t    case 's':\n+\t      if (match_string_p (\"save\"))\n+\t\td = DECL_SAVE;\n+\t      break;\n+\n+\t    case 't':\n+\t      if (match_string_p (\"target\"))\n+\t\td = DECL_TARGET;\n+\t      break;\n+\n+\t    case 'v':\n+\t      gfc_next_char ();\n+\t      ch = gfc_next_char ();\n+\t      if (ch == 'a')\n+\t\t{\n+\t\t  if (match_string_p (\"lue\"))\n+\t\t    {\n+\t\t      /* Matched \"value\".  */\n+\t\t      d = DECL_VALUE;\n+\t\t    }\n+\t\t}\n+\t      else if (ch == 'o')\n+\t\t{\n+\t\t  if (match_string_p (\"latile\"))\n+\t\t    {\n+\t\t      /* Matched \"volatile\".  */\n+\t\t      d = DECL_VOLATILE;\n+\t\t    }\n+\t\t}\n+\t      break;\n \t    }\n \t}\n \n-      if (d == DECL_NONE || d == DECL_COLON)\n-\tbreak;\n+      /* No double colon and no recognizable decl_type, so assume that\n+\t we've been looking at something else the whole time.  */\n+      if (d == DECL_NONE)\n+\t{\n+\t  m = MATCH_NO;\n+\t  goto cleanup;\n+\t}\n \n       seen[d]++;\n       seen_at[d] = gfc_current_locus;\n@@ -2580,14 +2714,6 @@ match_attr_spec (void)\n \t}\n     }\n \n-  /* No double colon, so assume that we've been looking at something\n-     else the whole time.  */\n-  if (d == DECL_NONE)\n-    {\n-      m = MATCH_NO;\n-      goto cleanup;\n-    }\n-\n   /* Since we've seen a double colon, we have to be looking at an\n      attr-spec.  This means that we can now issue errors.  */\n   for (d = GFC_DECL_BEGIN; d != GFC_DECL_END; d++)\n@@ -2667,8 +2793,8 @@ match_attr_spec (void)\n \n       if (gfc_current_state () == COMP_DERIVED\n \t  && d != DECL_DIMENSION && d != DECL_POINTER\n-\t  && d != DECL_COLON     && d != DECL_PRIVATE\n-\t  && d != DECL_PUBLIC    && d != DECL_NONE)\n+\t  && d != DECL_PRIVATE   && d != DECL_PUBLIC\n+\t  && d != DECL_NONE)\n \t{\n \t  if (d == DECL_ALLOCATABLE)\n \t    {"}, {"sha": "83b887372cb56b2cac935c3cd34d391e1bae9dfc", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 0, "deletions": 84, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2449db41c586a49bce8e512cdeb9f4e1330d998/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2449db41c586a49bce8e512cdeb9f4e1330d998/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=f2449db41c586a49bce8e512cdeb9f4e1330d998", "patch": "@@ -417,90 +417,6 @@ gfc_match_label (void)\n }\n \n \n-/* Try and match the input against an array of possibilities.  If one\n-   potential matching string is a substring of another, the longest\n-   match takes precedence.  Spaces in the target strings are optional\n-   spaces that do not necessarily have to be found in the input\n-   stream.  In fixed mode, spaces never appear.  If whitespace is\n-   matched, it matches unlimited whitespace in the input.  For this\n-   reason, the 'mp' member of the mstring structure is used to track\n-   the progress of each potential match.\n-\n-   If there is no match we return the tag associated with the\n-   terminating NULL mstring structure and leave the locus pointer\n-   where it started.  If there is a match we return the tag member of\n-   the matched mstring and leave the locus pointer after the matched\n-   character.\n-\n-   A '%' character is a mandatory space.  */\n-\n-int\n-gfc_match_strings (mstring *a)\n-{\n-  mstring *p, *best_match;\n-  int no_match, c, possibles;\n-  locus match_loc;\n-\n-  possibles = 0;\n-\n-  for (p = a; p->string != NULL; p++)\n-    {\n-      p->mp = p->string;\n-      possibles++;\n-    }\n-\n-  no_match = p->tag;\n-\n-  best_match = NULL;\n-  match_loc = gfc_current_locus;\n-\n-  gfc_gobble_whitespace ();\n-\n-  while (possibles > 0)\n-    {\n-      c = gfc_next_char ();\n-\n-      /* Apply the next character to the current possibilities.  */\n-      for (p = a; p->string != NULL; p++)\n-\t{\n-\t  if (p->mp == NULL)\n-\t    continue;\n-\n-\t  if (*p->mp == ' ')\n-\t    {\n-\t      /* Space matches 1+ whitespace(s).  */\n-\t      if ((gfc_current_form == FORM_FREE) && gfc_is_whitespace (c))\n-\t\tcontinue;\n-\n-\t      p->mp++;\n-\t    }\n-\n-\t  if (*p->mp != c)\n-\t    {\n-\t      /* Match failed.  */\n-\t      p->mp = NULL;\n-\t      possibles--;\n-\t      continue;\n-\t    }\n-\n-\t  p->mp++;\n-\t  if (*p->mp == '\\0')\n-\t    {\n-\t      /* Found a match.  */\n-\t      match_loc = gfc_current_locus;\n-\t      best_match = p;\n-\t      possibles--;\n-\t      p->mp = NULL;\n-\t    }\n-\t}\n-    }\n-\n-  gfc_current_locus = match_loc;\n-\n-  return (best_match == NULL) ? no_match : best_match->tag;\n-}\n-\n-\n /* See if the current input looks like a name of some sort.  Modifies\n    the passed buffer which must be GFC_MAX_SYMBOL_LEN+1 bytes long.\n    Note that options.c restricts max_identifier_length to not more"}, {"sha": "0909617e242eaabcbe92760b8a08ed3d3f8f09e8", "filename": "gcc/fortran/match.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2449db41c586a49bce8e512cdeb9f4e1330d998/gcc%2Ffortran%2Fmatch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2449db41c586a49bce8e512cdeb9f4e1330d998/gcc%2Ffortran%2Fmatch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.h?ref=f2449db41c586a49bce8e512cdeb9f4e1330d998", "patch": "@@ -46,7 +46,6 @@ match gfc_match_st_label (gfc_st_label **);\n match gfc_match_label (void);\n match gfc_match_small_int (int *);\n match gfc_match_small_int_expr (int *, gfc_expr **);\n-int gfc_match_strings (mstring *);\n match gfc_match_name (char *);\n match gfc_match_name_C (char *buffer);\n match gfc_match_symbol (gfc_symbol **, int);"}]}