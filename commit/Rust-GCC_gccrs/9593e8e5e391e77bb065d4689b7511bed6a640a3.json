{"sha": "9593e8e5e391e77bb065d4689b7511bed6a640a3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTU5M2U4ZTVlMzkxZTc3YmIwNjVkNDY4OWI3NTExYmVkNmE2NDBhMw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2019-09-26T13:52:45Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2019-09-26T13:52:45Z"}, "message": "tree-vect-loop.c (vect_analyze_loop_operations): Also call vectorizable_reduction for vect_double_reduction_def.\n\n2019-09-26  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vect-loop.c (vect_analyze_loop_operations): Also call\n\tvectorizable_reduction for vect_double_reduction_def.\n\t(vect_transform_loop): Likewise.\n\t(vect_create_epilog_for_reduction): Move double-reduction\n\tPHI creation and preheader argument setting of PHIs ...\n\t(vectorizable_reduction): ... here.  Also process\n\tvect_double_reduction_def PHIs, creating the vectorized\n\tPHI nodes, remembering the scalar adjustment computed for\n\tthe epilogue in STMT_VINFO_REDUC_EPILOGUE_ADJUSTMENT.\n\tRemember the original reduction code in STMT_VINFO_REDUC_CODE.\n\t* tree-vectorizer.c (vec_info::new_stmt_vec_info):\n\tInitialize STMT_VINFO_REDUC_CODE.\n\t* tree-vectorizer.h (_stmt_vec_info::reduc_epilogue_adjustment): New.\n\t(_stmt_vec_info::reduc_code): Likewise.\n\t(STMT_VINFO_REDUC_EPILOGUE_ADJUSTMENT): Likewise.\n\t(STMT_VINFO_REDUC_CODE): Likewise.\n\nFrom-SVN: r276150", "tree": {"sha": "73df2b834a28480303022eeaf3979ef2da64e536", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/73df2b834a28480303022eeaf3979ef2da64e536"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9593e8e5e391e77bb065d4689b7511bed6a640a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9593e8e5e391e77bb065d4689b7511bed6a640a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9593e8e5e391e77bb065d4689b7511bed6a640a3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9593e8e5e391e77bb065d4689b7511bed6a640a3/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5fdd1d33524c94783eadbf9dcd2c900d65baee72", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fdd1d33524c94783eadbf9dcd2c900d65baee72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5fdd1d33524c94783eadbf9dcd2c900d65baee72"}], "stats": {"total": 347, "additions": 198, "deletions": 149}, "files": [{"sha": "19892af07c06dde646a81625cf6cf7a142bc2abc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9593e8e5e391e77bb065d4689b7511bed6a640a3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9593e8e5e391e77bb065d4689b7511bed6a640a3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9593e8e5e391e77bb065d4689b7511bed6a640a3", "patch": "@@ -1,3 +1,22 @@\n+2019-09-26  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vect-loop.c (vect_analyze_loop_operations): Also call\n+\tvectorizable_reduction for vect_double_reduction_def.\n+\t(vect_transform_loop): Likewise.\n+\t(vect_create_epilog_for_reduction): Move double-reduction\n+\tPHI creation and preheader argument setting of PHIs ...\n+\t(vectorizable_reduction): ... here.  Also process\n+\tvect_double_reduction_def PHIs, creating the vectorized\n+\tPHI nodes, remembering the scalar adjustment computed for\n+\tthe epilogue in STMT_VINFO_REDUC_EPILOGUE_ADJUSTMENT.\n+\tRemember the original reduction code in STMT_VINFO_REDUC_CODE.\n+\t* tree-vectorizer.c (vec_info::new_stmt_vec_info):\n+\tInitialize STMT_VINFO_REDUC_CODE.\n+\t* tree-vectorizer.h (_stmt_vec_info::reduc_epilogue_adjustment): New.\n+\t(_stmt_vec_info::reduc_code): Likewise.\n+\t(STMT_VINFO_REDUC_EPILOGUE_ADJUSTMENT): Likewise.\n+\t(STMT_VINFO_REDUC_CODE): Likewise.\n+\n 2019-09-26  Matt Turner  <mattst88@gmail.com>\n \n \tPR driver/69471"}, {"sha": "1a561f9d16f28a16046daa7daeffb0f412384ab2", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 170, "deletions": 149, "changes": 319, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9593e8e5e391e77bb065d4689b7511bed6a640a3/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9593e8e5e391e77bb065d4689b7511bed6a640a3/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=9593e8e5e391e77bb065d4689b7511bed6a640a3", "patch": "@@ -1548,6 +1548,8 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo)\n \t\tok = vectorizable_induction (stmt_info, NULL, NULL, NULL,\n \t\t\t\t\t     &cost_vec);\n \t      else if ((STMT_VINFO_DEF_TYPE (stmt_info) == vect_reduction_def\n+\t\t\t|| (STMT_VINFO_DEF_TYPE (stmt_info)\n+\t\t\t    == vect_double_reduction_def)\n \t\t\t|| STMT_VINFO_DEF_TYPE (stmt_info) == vect_nested_cycle)\n \t\t       && ! PURE_SLP_STMT (stmt_info))\n \t\tok = vectorizable_reduction (stmt_info, NULL, NULL, NULL, NULL,\n@@ -4299,20 +4301,17 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs,\n   gimple *exit_phi;\n   tree bitsize;\n   tree adjustment_def = NULL;\n-  tree vec_initial_def = NULL;\n   tree expr, def, initial_def = NULL;\n   tree orig_name, scalar_result;\n   imm_use_iterator imm_iter, phi_imm_iter;\n   use_operand_p use_p, phi_use_p;\n   gimple *use_stmt;\n-  stmt_vec_info reduction_phi_info = NULL;\n   bool nested_in_vect_loop = false;\n   auto_vec<gimple *> new_phis;\n   auto_vec<stmt_vec_info> inner_phis;\n   int j, i;\n   auto_vec<tree> scalar_results;\n   unsigned int group_size = 1, k, ratio;\n-  auto_vec<tree> vec_initial_defs;\n   auto_vec<gimple *> phis;\n   bool slp_reduc = false;\n   bool direct_slp_reduc;\n@@ -4336,10 +4335,10 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs,\n   mode = TYPE_MODE (vectype);\n \n   /* 1. Create the reduction def-use cycle:\n-     Set the arguments of REDUCTION_PHIS, i.e., transform\n+     Set the backedge argument of REDUCTION_PHIS, i.e., transform\n \n         loop:\n-          vec_def = phi <null, null>            # REDUCTION_PHI\n+          vec_def = phi <vec_init, null>        # REDUCTION_PHI\n           VECT_DEF = vector_stmt                # vectorized form of STMT\n           ...\n \n@@ -4350,18 +4349,10 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs,\n           VECT_DEF = vector_stmt                # vectorized form of STMT\n           ...\n \n-     (in case of SLP, do it for all the phis). */\n+     (in case of SLP, do it for all the phis).  */\n \n-  /* Get the loop-entry arguments.  */\n   if (slp_node)\n-    {\n-      unsigned vec_num = SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node);\n-      vec_initial_defs.reserve (vec_num);\n-      get_initial_defs_for_reduction (slp_node_instance->reduc_phis,\n-\t\t\t\t      &vec_initial_defs, vec_num,\n-\t\t\t\t      REDUC_GROUP_FIRST_ELEMENT (stmt_info),\n-\t\t\t\t      neutral_op);\n-    }\n+    ;\n   else\n     {\n       /* Get at the scalar def before the loop, that defines the initial value\n@@ -4373,64 +4364,29 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs,\n \t for REDUC_MIN and initial_def larger than the base.  */\n       if (STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info)\n \t  == INTEGER_INDUC_COND_REDUCTION)\n-\t{\n-\t  induc_val = STMT_VINFO_VEC_INDUC_COND_INITIAL_VAL (stmt_info);\n-\t  if (TREE_CODE (initial_def) == INTEGER_CST\n-\t      && (STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info)\n-\t\t  == INTEGER_INDUC_COND_REDUCTION)\n-\t      && !integer_zerop (induc_val)\n-\t      && ((code == MAX_EXPR\n-\t\t   && tree_int_cst_lt (initial_def, induc_val))\n-\t\t  || (code == MIN_EXPR\n-\t\t      && tree_int_cst_lt (induc_val, initial_def))))\n-\t    induc_val = initial_def;\n-\t  vec_initial_def = build_vector_from_val (vectype, induc_val);\n-\t}\n+\tinduc_val = STMT_VINFO_VEC_INDUC_COND_INITIAL_VAL (stmt_info);\n       else if (double_reduc)\n-\t/* In case of double reduction we only create a vector variable\n-\t   to be put in the reduction phi node.  The actual statement\n-\t   creation is done later in this function.  */\n-\tvec_initial_def = vect_create_destination_var (initial_def, vectype);\n+\t;\n       else if (nested_in_vect_loop)\n-\t{\n-\t  /* Do not use an adjustment def as that case is not supported\n-\t     correctly if ncopies is not one.  */\n-\t  vec_initial_def = vect_get_vec_def_for_operand (initial_def,\n-\t\t\t\t\t\t\t  stmt_info);\n-\t}\n+\t;\n       else\n-\tvec_initial_def\n-\t  = get_initial_def_for_reduction (stmt_info, code, initial_def,\n-\t\t\t\t\t   &adjustment_def);\n-      vec_initial_defs.create (1);\n-      vec_initial_defs.quick_push (vec_initial_def);\n+\tadjustment_def = STMT_VINFO_REDUC_EPILOGUE_ADJUSTMENT (stmt_info);\n     }\n \n-  /* Set phi nodes arguments.  */\n+  /* Set phi nodes latch arguments.  */\n   FOR_EACH_VEC_ELT (reduction_phis, i, phi_info)\n     {\n-      tree vec_init_def = vec_initial_defs[i];\n       tree def = vect_defs[i];\n       for (j = 0; j < ncopies; j++)\n         {\n+          /* Set the loop-latch arg for the reduction-phi.  */\n \t  if (j != 0)\n \t    {\n \t      phi_info = STMT_VINFO_RELATED_STMT (phi_info);\n-\t      if (nested_in_vect_loop)\n-\t\tvec_init_def\n-\t\t  = vect_get_vec_def_for_stmt_copy (loop_vinfo, vec_init_def);\n+\t      def = vect_get_vec_def_for_stmt_copy (loop_vinfo, def);\n \t    }\n \n-\t  /* Set the loop-entry arg of the reduction-phi.  */\n-\n \t  gphi *phi = as_a <gphi *> (phi_info->stmt);\n-\t  add_phi_arg (phi, vec_init_def, loop_preheader_edge (loop),\n-\t\t       UNKNOWN_LOCATION);\n-\n-          /* Set the loop-latch arg for the reduction-phi.  */\n-          if (j > 0)\n-\t    def = vect_get_vec_def_for_stmt_copy (loop_vinfo, def);\n-\n \t  add_phi_arg (phi, def, loop_latch_edge (loop), UNKNOWN_LOCATION);\n \n           if (dump_enabled_p ())\n@@ -4934,7 +4890,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs,\n \n       if ((STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info)\n \t   == INTEGER_INDUC_COND_REDUCTION)\n-\t  && !operand_equal_p (initial_def, induc_val, 0))\n+\t  && induc_val)\n \t{\n \t  /* Earlier we set the initial value to be a vector if induc_val\n \t     values.  Check the result and if it is induc_val then replace\n@@ -5297,7 +5253,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs,\n \n       if ((STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info)\n \t   == INTEGER_INDUC_COND_REDUCTION)\n-\t  && !operand_equal_p (initial_def, induc_val, 0))\n+\t  && induc_val)\n \t{\n \t  /* Earlier we set the initial value to be a vector if induc_val\n \t     values.  Check the result and if it is induc_val then replace\n@@ -5420,7 +5376,6 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs,\n       if (k % ratio == 0)\n         {\n \t  epilog_stmt_info = loop_vinfo->lookup_stmt (new_phis[k / ratio]);\n-\t  reduction_phi_info = reduction_phis[k / ratio];\n \t  if (double_reduc)\n \t    inner_phi = inner_phis[k / ratio];\n         }\n@@ -5435,6 +5390,8 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs,\n \t  scalar_dest = gimple_assign_lhs (scalar_stmt_info->stmt);\n         }\n \n+      if (outer_loop)\n+\t{\n       phis.create (3);\n       /* Find the loop-closed-use at the loop exit of the original scalar\n          result.  (The reduction result is expected to have two immediate uses -\n@@ -5449,8 +5406,6 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs,\n \n       FOR_EACH_VEC_ELT (phis, i, exit_phi)\n         {\n-          if (outer_loop)\n-            {\n \t      stmt_vec_info exit_phi_vinfo\n \t\t= loop_vinfo->lookup_stmt (exit_phi);\n               gphi *vect_phi;\n@@ -5482,7 +5437,6 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs,\n               FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, orig_name)\n                 {\n                   stmt_vec_info use_stmt_vinfo;\n-                  tree vect_phi_init, preheader_arg, vect_phi_res;\n                   basic_block bb = gimple_bb (use_stmt);\n \n                   /* Check that USE_STMT is really double reduction phi\n@@ -5497,53 +5451,23 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs,\n                           != vect_double_reduction_def)\n \t\t    continue;\n \n-                  /* Create vector phi node for double reduction:\n-                     vs1 = phi <vs0, vs2>\n-                     vs1 was created previously in this function by a call to\n-                       vect_get_vec_def_for_operand and is stored in\n-                       vec_initial_def;\n-                     vs2 is defined by INNER_PHI, the vectorized EXIT_PHI;\n-                     vs0 is created here.  */\n-\n-                  /* Create vector phi node.  */\n-                  vect_phi = create_phi_node (vec_initial_def, bb);\n-\t\t  loop_vec_info_for_loop (outer_loop)->add_stmt (vect_phi);\n-\n-                  /* Create vs0 - initial def of the double reduction phi.  */\n-                  preheader_arg = PHI_ARG_DEF_FROM_EDGE (use_stmt,\n-                                             loop_preheader_edge (outer_loop));\n-                  vect_phi_init = get_initial_def_for_reduction\n-\t\t    (stmt_info, code, preheader_arg, NULL);\n-\n-                  /* Update phi node arguments with vs0 and vs2.  */\n-                  add_phi_arg (vect_phi, vect_phi_init,\n-                               loop_preheader_edge (outer_loop),\n-                               UNKNOWN_LOCATION);\n+                  /* Set the outer loop vector phi args.  The PHI node\n+\t\t     itself was created in vectorizable_reduction.  */\n+\t\t  vect_phi = as_a <gphi *>\n+\t\t\t\t(STMT_VINFO_VEC_STMT (use_stmt_vinfo)->stmt);\n+\n+                  /* Update phi node argument with vs2.  */\n \t\t  add_phi_arg (vect_phi, PHI_RESULT (inner_phi->stmt),\n \t\t\t       loop_latch_edge (outer_loop), UNKNOWN_LOCATION);\n                   if (dump_enabled_p ())\n \t\t    dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t\t     \"created double reduction phi node: %G\",\n \t\t\t\t     vect_phi);\n-\n-                  vect_phi_res = PHI_RESULT (vect_phi);\n-\n-                  /* Replace the use, i.e., set the correct vs1 in the regular\n-                     reduction phi node.  FORNOW, NCOPIES is always 1, so the\n-                     loop is redundant.  */\n-\t\t  stmt_vec_info use_info = reduction_phi_info;\n-\t\t  for (j = 0; j < ncopies; j++)\n-\t\t    {\n-\t\t      edge pr_edge = loop_preheader_edge (loop);\n-\t\t      SET_PHI_ARG_DEF (as_a <gphi *> (use_info->stmt),\n-\t\t\t\t       pr_edge->dest_idx, vect_phi_res);\n-\t\t      use_info = STMT_VINFO_RELATED_STMT (use_info);\n-\t\t    }\n                 }\n-            }\n         }\n-\n       phis.release ();\n+\t}\n+\n       if (nested_in_vect_loop)\n         {\n           if (double_reduc)\n@@ -6027,6 +5951,7 @@ vectorizable_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \n   /* Make sure it was already recognized as a reduction computation.  */\n   if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_reduction_def\n+      && STMT_VINFO_DEF_TYPE (stmt_info) != vect_double_reduction_def\n       && STMT_VINFO_DEF_TYPE (stmt_info) != vect_nested_cycle)\n     return false;\n \n@@ -6067,82 +5992,176 @@ vectorizable_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t/* Leave the scalar phi in place.  */\n \treturn true;\n \n-      gassign *reduc_stmt = as_a <gassign *> (reduc_stmt_info->stmt);\n-      code = gimple_assign_rhs_code (reduc_stmt);\n-      for (unsigned k = 1; k < gimple_num_ops (reduc_stmt); ++k)\n-\t{\n-\t  tree op = gimple_op (reduc_stmt, k);\n-\t  if (op == phi_result)\n-\t    continue;\n-\t  if (k == 1 && code == COND_EXPR)\n-\t    continue;\n-\t  bool is_simple_use = vect_is_simple_use (op, loop_vinfo, &dt);\n-\t  gcc_assert (is_simple_use);\n-\t  if (dt == vect_constant_def || dt == vect_external_def)\n-\t    continue;\n-\t  if (!vectype_in\n-\t      || (GET_MODE_SIZE (SCALAR_TYPE_MODE (TREE_TYPE (vectype_in)))\n-\t\t  < GET_MODE_SIZE (SCALAR_TYPE_MODE (TREE_TYPE (op)))))\n-\t    vectype_in = get_vectype_for_scalar_type (TREE_TYPE (op));\n-\t  break;\n-\t}\n+      if (gassign *reduc_stmt = dyn_cast <gassign *> (reduc_stmt_info->stmt))\n+\tfor (unsigned k = 1; k < gimple_num_ops (reduc_stmt); ++k)\n+\t  {\n+\t    tree op = gimple_op (reduc_stmt, k);\n+\t    if (op == phi_result)\n+\t      continue;\n+\t    if (k == 1 && gimple_assign_rhs_code (reduc_stmt) == COND_EXPR)\n+\t      continue;\n+\t    bool is_simple_use = vect_is_simple_use (op, loop_vinfo, &dt);\n+\t    gcc_assert (is_simple_use);\n+\t    if (dt == vect_constant_def || dt == vect_external_def)\n+\t      continue;\n+\t    if (!vectype_in\n+\t\t|| (GET_MODE_SIZE (SCALAR_TYPE_MODE (TREE_TYPE (vectype_in)))\n+\t\t    < GET_MODE_SIZE (SCALAR_TYPE_MODE (TREE_TYPE (op)))))\n+\t      vectype_in = get_vectype_for_scalar_type (TREE_TYPE (op));\n+\t    break;\n+\t  }\n       /* For a nested cycle we might end up with an operation like\n          phi_result * phi_result.  */\n       if (!vectype_in)\n \tvectype_in = STMT_VINFO_VECTYPE (stmt_info);\n       gcc_assert (vectype_in);\n \n       if (slp_node)\n-\tncopies = 1;\n+\t{\n+\t  /* The size vect_schedule_slp_instance computes is off for us.  */\n+\t  vec_num = vect_get_num_vectors\n+\t      (LOOP_VINFO_VECT_FACTOR (loop_vinfo)\n+\t       * SLP_TREE_SCALAR_STMTS (slp_node).length (), vectype_in);\n+\t  ncopies = 1;\n+\t}\n       else\n-\tncopies = vect_get_num_copies (loop_vinfo, vectype_in);\n+\t{\n+\t  vec_num = 1;\n+\t  ncopies = vect_get_num_copies (loop_vinfo, vectype_in);\n+\t}\n \n+      /* Check whether we can use a single PHI node and accumulate\n+         vectors to one before the backedge.  */\n       stmt_vec_info use_stmt_info;\n       if (ncopies > 1\n \t  && STMT_VINFO_RELEVANT (reduc_stmt_info) <= vect_used_only_live\n \t  && (use_stmt_info = loop_vinfo->lookup_single_use (phi_result))\n \t  && (!STMT_VINFO_IN_PATTERN_P (use_stmt_info)\n \t      || !STMT_VINFO_PATTERN_DEF_SEQ (use_stmt_info))\n \t  && vect_stmt_to_vectorize (use_stmt_info) == reduc_stmt_info)\n-\tsingle_defuse_cycle = true;\n+\t{\n+\t  single_defuse_cycle = true;\n+\t  ncopies = 1;\n+\t}\n \n       /* Create the destination vector  */\n-      scalar_dest = gimple_assign_lhs (reduc_stmt);\n-      vec_dest = vect_create_destination_var (scalar_dest, vectype_out);\n+      vec_dest = vect_create_destination_var (phi_result, vectype_out);\n \n+      /* Get the loop-entry arguments.  */\n+      tree vec_initial_def;\n+      auto_vec<tree> vec_initial_defs;\n       if (slp_node)\n-\t/* The size vect_schedule_slp_instance computes is off for us.  */\n-\tvec_num = vect_get_num_vectors\n-\t  (LOOP_VINFO_VECT_FACTOR (loop_vinfo)\n-\t   * SLP_TREE_SCALAR_STMTS (slp_node).length (),\n-\t   vectype_in);\n+\t{\n+\t  vec_initial_defs.reserve (vec_num);\n+\t  gcc_assert (slp_node == slp_node_instance->reduc_phis);\n+\t  stmt_vec_info first = REDUC_GROUP_FIRST_ELEMENT (reduc_stmt_info);\n+\t  tree neutral_op\n+\t      = neutral_op_for_slp_reduction (slp_node,\n+\t\t\t\t\t      STMT_VINFO_REDUC_CODE\n+\t\t\t\t\t      (first ? first : reduc_stmt_info),\n+\t\t\t\t\t      first != NULL);\n+\t  get_initial_defs_for_reduction (slp_node_instance->reduc_phis,\n+\t\t\t\t\t  &vec_initial_defs, vec_num,\n+\t\t\t\t\t  first != NULL, neutral_op);\n+\t}\n       else\n-\tvec_num = 1;\n+\t{\n+\t  /* Get at the scalar def before the loop, that defines the initial\n+\t     value of the reduction variable.  */\n+\t  tree initial_def = PHI_ARG_DEF_FROM_EDGE (phi,\n+\t\t\t\t\t\t    loop_preheader_edge (loop));\n+\t  /* Optimize: if initial_def is for REDUC_MAX smaller than the base\n+\t     and we can't use zero for induc_val, use initial_def.  Similarly\n+\t     for REDUC_MIN and initial_def larger than the base.  */\n+\t  if (STMT_VINFO_VEC_REDUCTION_TYPE (reduc_stmt_info)\n+\t      == INTEGER_INDUC_COND_REDUCTION)\n+\t    {\n+\t      tree induc_val\n+\t\t= STMT_VINFO_VEC_INDUC_COND_INITIAL_VAL (reduc_stmt_info);\n+\t      if (TREE_CODE (initial_def) == INTEGER_CST\n+\t\t  && (STMT_VINFO_VEC_REDUCTION_TYPE (reduc_stmt_info)\n+\t\t      == INTEGER_INDUC_COND_REDUCTION)\n+\t\t  && !integer_zerop (induc_val)\n+\t\t  && (((STMT_VINFO_VEC_COND_REDUC_CODE (reduc_stmt_info)\n+\t\t\t== MAX_EXPR)\n+\t\t       && tree_int_cst_lt (initial_def, induc_val))\n+\t\t      || ((STMT_VINFO_VEC_COND_REDUC_CODE (reduc_stmt_info)\n+\t\t\t   == MIN_EXPR)\n+\t\t\t  && tree_int_cst_lt (induc_val, initial_def))))\n+\t\t{\n+\t\t  induc_val = initial_def;\n+\t\t  /* Communicate we used the initial_def to epilouge\n+\t\t     generation.  */\n+\t\t  STMT_VINFO_VEC_INDUC_COND_INITIAL_VAL (reduc_stmt_info)\n+\t\t    = NULL_TREE;\n+\t\t}\n+\t      vec_initial_def = build_vector_from_val (vectype_out, induc_val);\n+\t    }\n+\t  else if (nested_cycle)\n+\t    {\n+\t      /* Do not use an adjustment def as that case is not supported\n+\t\t correctly if ncopies is not one.  */\n+\t      vec_initial_def = vect_get_vec_def_for_operand (initial_def,\n+\t\t\t\t\t\t\t      reduc_stmt_info);\n+\t    }\n+\t  else\n+\t    {\n+\t      tree adjustment_def = NULL_TREE;\n+\t      tree *adjustment_defp = &adjustment_def;\n+\t      enum tree_code code = STMT_VINFO_REDUC_CODE (reduc_stmt_info);\n+\t      /* ???  For the outer loop PHI we have to do a bit of searching\n+\t\t to find the stmt with the code.  reduc_stmt_info here is the\n+\t\t loop-closed PHI of the inner reduction which means we can look\n+\t\t at its single-arg def.  */\n+\t      if (STMT_VINFO_DEF_TYPE (stmt_info) == vect_double_reduction_def)\n+\t\t{\n+\t\t  tree def = gimple_phi_arg_def\n+\t\t\t\t(as_a <gphi *> (reduc_stmt_info->stmt), 0);\n+\t\t  code = STMT_VINFO_REDUC_CODE\n+\t\t      (vect_stmt_to_vectorize (loop_vinfo->lookup_def (def)));\n+\t\t  adjustment_defp = NULL;\n+\t\t}\n+\t      vec_initial_def\n+\t\t= get_initial_def_for_reduction (reduc_stmt_info, code,\n+\t\t\t\t\t\t initial_def, adjustment_defp);\n+\t      STMT_VINFO_REDUC_EPILOGUE_ADJUSTMENT (reduc_stmt_info)\n+\t\t= adjustment_def;\n+\t    }\n+\t  vec_initial_defs.create (1);\n+\t  vec_initial_defs.quick_push (vec_initial_def);\n+\t}\n \n       /* Generate the reduction PHIs upfront.  */\n       prev_phi_info = NULL;\n-      for (j = 0; j < ncopies; j++)\n+      for (i = 0; i < vec_num; i++)\n \t{\n-\t  if (j == 0 || !single_defuse_cycle)\n+\t  tree vec_init_def = vec_initial_defs[i];\n+\t  for (j = 0; j < ncopies; j++)\n \t    {\n-\t      for (i = 0; i < vec_num; i++)\n+\t      /* Create the reduction-phi that defines the reduction\n+\t\t operand.  */\n+\t      gphi *new_phi = create_phi_node (vec_dest, loop->header);\n+\t      stmt_vec_info new_phi_info = loop_vinfo->add_stmt (new_phi);\n+\n+\t      /* Set the loop-entry arg of the reduction-phi.  */\n+\t      if (j != 0 && nested_cycle)\n+\t\tvec_init_def = vect_get_vec_def_for_stmt_copy (loop_vinfo,\n+\t\t\t\t\t\t\t       vec_init_def);\n+\t      add_phi_arg (new_phi, vec_init_def, loop_preheader_edge (loop),\n+\t\t\t   UNKNOWN_LOCATION);\n+\n+\t      /* The loop-latch arg is set in epilogue processing.  */\n+\n+\t      if (slp_node)\n+\t\tSLP_TREE_VEC_STMTS (slp_node).quick_push (new_phi_info);\n+\t      else\n \t\t{\n-\t\t  /* Create the reduction-phi that defines the reduction\n-\t\t     operand.  */\n-\t\t  gimple *new_phi = create_phi_node (vec_dest, loop->header);\n-\t\t  stmt_vec_info new_phi_info = loop_vinfo->add_stmt (new_phi);\n-\n-\t\t  if (slp_node)\n-\t\t    SLP_TREE_VEC_STMTS (slp_node).quick_push (new_phi_info);\n+\t\t  if (j == 0)\n+\t\t    STMT_VINFO_VEC_STMT (stmt_info)\n+\t\t\t= *vec_stmt = new_phi_info;\n \t\t  else\n-\t\t    {\n-\t\t      if (j == 0)\n-\t\t\tSTMT_VINFO_VEC_STMT (stmt_info)\n-\t\t\t  = *vec_stmt = new_phi_info;\n-\t\t      else\n-\t\t\tSTMT_VINFO_RELATED_STMT (prev_phi_info) = new_phi_info;\n-\t\t      prev_phi_info = new_phi_info;\n-\t\t    }\n+\t\t    STMT_VINFO_RELATED_STMT (prev_phi_info) = new_phi_info;\n+\t\t  prev_phi_info = new_phi_info;\n \t\t}\n \t    }\n \t}\n@@ -6633,6 +6652,7 @@ vectorizable_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t  gcc_assert (orig_code == MAX_EXPR || orig_code == MIN_EXPR);\n \t}\n     }\n+  STMT_VINFO_REDUC_CODE (stmt_info) = orig_code;\n \n   reduc_fn = IFN_LAST;\n \n@@ -8378,6 +8398,7 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \n \t  if ((STMT_VINFO_DEF_TYPE (stmt_info) == vect_induction_def\n \t       || STMT_VINFO_DEF_TYPE (stmt_info) == vect_reduction_def\n+\t       || STMT_VINFO_DEF_TYPE (stmt_info) == vect_double_reduction_def\n \t       || STMT_VINFO_DEF_TYPE (stmt_info) == vect_nested_cycle)\n \t      && ! PURE_SLP_STMT (stmt_info))\n \t    {"}, {"sha": "50d508db7cdbd0194db0647a46b48edbfdf5709c", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9593e8e5e391e77bb065d4689b7511bed6a640a3/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9593e8e5e391e77bb065d4689b7511bed6a640a3/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=9593e8e5e391e77bb065d4689b7511bed6a640a3", "patch": "@@ -639,6 +639,7 @@ vec_info::new_stmt_vec_info (gimple *stmt)\n   STMT_VINFO_VECTORIZABLE (res) = true;\n   STMT_VINFO_VEC_REDUCTION_TYPE (res) = TREE_CODE_REDUCTION;\n   STMT_VINFO_VEC_COND_REDUC_CODE (res) = ERROR_MARK;\n+  STMT_VINFO_REDUC_CODE (res) = ERROR_MARK;\n   STMT_VINFO_REDUC_IDX (res) = -1;\n   STMT_VINFO_SLP_VECT_ONLY (res) = false;\n "}, {"sha": "f140405bbd627e3e34336a3d504174b6a724e955", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9593e8e5e391e77bb065d4689b7511bed6a640a3/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9593e8e5e391e77bb065d4689b7511bed6a640a3/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=9593e8e5e391e77bb065d4689b7511bed6a640a3", "patch": "@@ -941,10 +941,16 @@ class _stmt_vec_info {\n   /* For INTEGER_INDUC_COND_REDUCTION, the initial value to be used.  */\n   tree induc_cond_initial_val;\n \n+  /* If not NULL the value to be added to compute final reduction value.  */\n+  tree reduc_epilogue_adjustment;\n+\n   /* On a reduction PHI the reduction type as detected by\n      vect_force_simple_reduction.  */\n   enum vect_reduction_type reduc_type;\n \n+  /* The original reduction code, to be used in the epilogue.  */\n+  enum tree_code reduc_code;\n+\n   /* On a stmt participating in the reduction the index of the operand\n      on the reduction SSA cycle.  */\n   int reduc_idx;\n@@ -1039,6 +1045,7 @@ STMT_VINFO_BB_VINFO (stmt_vec_info stmt_vinfo)\n #define STMT_VINFO_VEC_REDUCTION_TYPE(S)   (S)->v_reduc_type\n #define STMT_VINFO_VEC_COND_REDUC_CODE(S)  (S)->cond_reduc_code\n #define STMT_VINFO_VEC_INDUC_COND_INITIAL_VAL(S) (S)->induc_cond_initial_val\n+#define STMT_VINFO_REDUC_EPILOGUE_ADJUSTMENT(S) (S)->reduc_epilogue_adjustment\n #define STMT_VINFO_REDUC_IDX(S)\t\t   (S)->reduc_idx\n \n #define STMT_VINFO_DR_WRT_VEC_LOOP(S)      (S)->dr_wrt_vec_loop\n@@ -1070,6 +1077,7 @@ STMT_VINFO_BB_VINFO (stmt_vec_info stmt_vinfo)\n #define STMT_VINFO_MIN_NEG_DIST(S)\t(S)->min_neg_dist\n #define STMT_VINFO_NUM_SLP_USES(S)\t(S)->num_slp_uses\n #define STMT_VINFO_REDUC_TYPE(S)\t(S)->reduc_type\n+#define STMT_VINFO_REDUC_CODE(S)\t(S)->reduc_code\n #define STMT_VINFO_REDUC_DEF(S)\t\t(S)->reduc_def\n #define STMT_VINFO_SLP_VECT_ONLY(S)     (S)->slp_vect_only_p\n "}]}