{"sha": "87ed109f1f7fab7afc05afca460523a2493c0f43", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODdlZDEwOWYxZjdmYWI3YWZjMDVhZmNhNDYwNTIzYTI0OTNjMGY0Mw==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2002-04-28T19:42:54Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2002-04-28T19:42:54Z"}, "message": "cppexp.c (lex): Update to use state.skip_eval.\n\n\t* cppexp.c (lex): Update to use state.skip_eval.\n\t(struct op): Remove prio and flags members.\n\t(FLAG_BITS, FLAG_MASK, PRIO_SHIFT, EXTRACT_PRIO, EXTRACT_FLAGS,\n\tSHORT_CIRCUIT, RIGHT_ASSOC, ..._PRIO, op_to_prio): Remove.\n\t(LEFT_ASSOC): New macro.\n\t(optab): New table of operator priorities and flags.\n\t(SHIFT): Update.\n\t(_cpp_parse_expr): Clean up logic.  Return bool.  Use a\n\tmalloc-ed parser stack.\n\t(reduce): New; reduce the operator stack.\n\t(_cpp_expand_op_stack): Expand the operator stack as necessary.\n\t* cpphash.h (struct op): Predeclare.\n\t(struct cpp_reader): New members op_stack, op_limit.\n\t(struct lexer_state): New member skip_eval.\n\t(_cpp_parse_expr): Update.\n\t(_cpp_expand_op_stack): New.\n\t* cpplib.c (do_if): Update.\n\t* cppinit.c (cpp_create_reader): Create op stack.\n\t(cpp_destroy): And destroy it.\n\t* cpplib.h (CPP_LAST_CPP_OP): Correct.\n\t(TTYPE_TABLE): Correct.\ntestsuite:\n\t* gcc.dg/cpp/if-mop.c: Update.\n\t* gcc.dg/cpp/if-mpar.c: Add test.\n\t* gcc.dg/cpp/if-oppr.c: Update.\n\nFrom-SVN: r52853", "tree": {"sha": "c4adc85edfa9fa27de90af625624219e92a87257", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c4adc85edfa9fa27de90af625624219e92a87257"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/87ed109f1f7fab7afc05afca460523a2493c0f43", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87ed109f1f7fab7afc05afca460523a2493c0f43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87ed109f1f7fab7afc05afca460523a2493c0f43", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87ed109f1f7fab7afc05afca460523a2493c0f43/comments", "author": null, "committer": null, "parents": [{"sha": "14dbfa70082438ba474626d210d4f151354e10d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14dbfa70082438ba474626d210d4f151354e10d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14dbfa70082438ba474626d210d4f151354e10d0"}], "stats": {"total": 696, "additions": 358, "deletions": 338}, "files": [{"sha": "728e9ff7510a958fc7276e1e71d83571176cbed6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87ed109f1f7fab7afc05afca460523a2493c0f43/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87ed109f1f7fab7afc05afca460523a2493c0f43/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=87ed109f1f7fab7afc05afca460523a2493c0f43", "patch": "@@ -1,3 +1,27 @@\n+2002-04-28  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* cppexp.c (lex): Update to use state.skip_eval.\n+\t(struct op): Remove prio and flags members.\n+\t(FLAG_BITS, FLAG_MASK, PRIO_SHIFT, EXTRACT_PRIO, EXTRACT_FLAGS,\n+\tSHORT_CIRCUIT, RIGHT_ASSOC, ..._PRIO, op_to_prio): Remove.\n+\t(LEFT_ASSOC): New macro.\n+\t(optab): New table of operator priorities and flags.\n+\t(SHIFT): Update.\n+\t(_cpp_parse_expr): Clean up logic.  Return bool.  Use a\n+\tmalloc-ed parser stack.\n+\t(reduce): New; reduce the operator stack.\n+\t(_cpp_expand_op_stack): Expand the operator stack as necessary.\n+\t* cpphash.h (struct op): Predeclare.\n+\t(struct cpp_reader): New members op_stack, op_limit.\n+\t(struct lexer_state): New member skip_eval.\n+\t(_cpp_parse_expr): Update.\n+\t(_cpp_expand_op_stack): New.\n+\t* cpplib.c (do_if): Update.\n+\t* cppinit.c (cpp_create_reader): Create op stack.\n+\t(cpp_destroy): And destroy it.\n+\t* cpplib.h (CPP_LAST_CPP_OP): Correct.\n+\t(TTYPE_TABLE): Correct.\n+\n 2002-04-28  Franz Sirl  <Franz.Sirl-kernel@lauterbach.com>\n \n \tPR c/6343"}, {"sha": "29a261105e8b6862167d609e631cdf7a7ad10558", "filename": "gcc/cppexp.c", "status": "modified", "additions": 306, "deletions": 331, "changes": 637, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87ed109f1f7fab7afc05afca460523a2493c0f43/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87ed109f1f7fab7afc05afca460523a2493c0f43/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=87ed109f1f7fab7afc05afca460523a2493c0f43", "patch": "@@ -36,14 +36,13 @@ static HOST_WIDEST_INT right_shift PARAMS ((cpp_reader *, HOST_WIDEST_INT,\n \t\t\t\t\t    unsigned HOST_WIDEST_INT));\n static struct op parse_number PARAMS ((cpp_reader *, const cpp_token *));\n static struct op parse_defined PARAMS ((cpp_reader *));\n-static struct op lex PARAMS ((cpp_reader *, int));\n+static struct op lex PARAMS ((cpp_reader *));\n static const unsigned char *op_as_text PARAMS ((cpp_reader *, enum cpp_ttype));\n+static struct op *reduce PARAMS ((cpp_reader *, struct op *, enum cpp_ttype));\n \n struct op\n {\n   enum cpp_ttype op;\n-  uchar prio;         /* Priority of op.  */\n-  uchar flags;\n   uchar unsignedp;    /* True if value should be treated as unsigned.  */\n   HOST_WIDEST_INT value; /* The value logically \"right\" of op.  */\n };\n@@ -281,9 +280,8 @@ parse_defined (pfile)\n    result of the \"defined\" or \"#\" operators), CPP_ERROR on error,\n    CPP_EOF, or the type of an operator token.  */\n static struct op\n-lex (pfile, skip_evaluation)\n+lex (pfile)\n      cpp_reader *pfile;\n-     int skip_evaluation;\n {\n   struct op op;\n   const cpp_token *token = cpp_get_token (pfile);\n@@ -343,7 +341,7 @@ lex (pfile, skip_evaluation)\n \t  op.unsignedp = 0;\n \t  op.value = 0;\n \n-\t  if (CPP_OPTION (pfile, warn_undef) && !skip_evaluation)\n+\t  if (CPP_OPTION (pfile, warn_undef) && !pfile->state.skip_eval)\n \t    cpp_error (pfile, DL_WARNING, \"\\\"%s\\\" is not defined\",\n \t\t       NODE_NAME (token->val.node));\n \t  return op;\n@@ -363,8 +361,7 @@ lex (pfile, skip_evaluation)\n \n     default:\n       if (((int) token->type > (int) CPP_EQ\n-\t   && (int) token->type < (int) CPP_PLUS_EQ)\n-\t  || token->type == CPP_EOF)\n+\t   && (int) token->type < (int) CPP_PLUS_EQ))\n \t{\n \t  op.op = token->type;\n \t  return op;\n@@ -435,100 +432,69 @@ right_shift (pfile, a, unsignedp, b)\n /* Operator precedence and flags table.\n \n After an operator is returned from the lexer, if it has priority less\n-than or equal to the operator on the top of the stack, we reduce the\n-stack by one operator and repeat the test.  Since equal priorities\n-reduce, this is naturally left-associative.\n-\n-We handle right-associative operators by clearing the lower bit of all\n-left-associative operators, and setting it for right-associative ones.\n-After the reduction phase of a new operator, just before it is pushed\n-onto the stack, its RIGHT_ASSOC bit is cleared.  The effect is that\n-during the reduction phase, the current right-associative operator has\n-a priority one greater than any other operator of otherwise equal\n-precedence that has been pushed on the top of the stack.  This avoids\n-a reduction pass, and effectively makes the logic right-associative.\n+than the operator on the top of the stack, we reduce the stack by one\n+operator and repeat the test.  Since equal priorities do not reduce,\n+this is naturally right-associative.\n+\n+We handle left-associative operators by decrementing the priority of\n+just-lexed operators by one, but retaining the priority of operators\n+already on the stack.\n \n The remaining cases are '(' and ')'.  We handle '(' by skipping the\n reduction phase completely.  ')' is given lower priority than\n everything else, including '(', effectively forcing a reduction of the\n-parenthesised expression.  If there is no matching '(', the stack will\n-be reduced all the way to the beginning, exiting the parser in the\n-same way as the ultra-low priority end-of-expression dummy operator.\n-The exit code checks to see if the operator that caused it is ')', and\n-if so outputs an appropriate error message.\n+parenthesised expression.  If there is a matching '(', the routine\n+reduce() exits immediately.  If the normal exit route sees a ')', then\n+there cannot have been a matching '(' and an error message is output.\n \n The parser assumes all shifted operators require a left operand unless\n the flag NO_L_OPERAND is set.  These semantics are automatic; any\n extra semantics need to be handled with operator-specific code.  */\n \n-#define FLAG_BITS  8\n-#define FLAG_MASK ((1 << FLAG_BITS) - 1)\n-#define PRIO_SHIFT (FLAG_BITS + 1)\n-#define EXTRACT_PRIO(CNST) ((CNST) >> FLAG_BITS)\n-#define EXTRACT_FLAGS(CNST) ((CNST) & FLAG_MASK)\n-\n /* Flags.  */\n-#define NO_L_OPERAND   (1 << 0)\n-#define SHORT_CIRCUIT  (1 << 1)\n-\n-/* Priority and flag combinations.  */\n-#define RIGHT_ASSOC         (1 << FLAG_BITS)\n-#define FORCE_REDUCE_PRIO   (0 << PRIO_SHIFT)\n-#define CLOSE_PAREN_PRIO    (1 << PRIO_SHIFT)\n-#define OPEN_PAREN_PRIO    ((2 << PRIO_SHIFT) | NO_L_OPERAND)\n-#define COMMA_PRIO          (3 << PRIO_SHIFT)\n-#define COND_PRIO          ((4 << PRIO_SHIFT) | RIGHT_ASSOC | SHORT_CIRCUIT)\n-#define COLON_PRIO         ((5 << PRIO_SHIFT) | SHORT_CIRCUIT)\n-#define OROR_PRIO          ((6 << PRIO_SHIFT) | SHORT_CIRCUIT)\n-#define ANDAND_PRIO        ((7 << PRIO_SHIFT) | SHORT_CIRCUIT)\n-#define OR_PRIO             (8 << PRIO_SHIFT)\n-#define XOR_PRIO            (9 << PRIO_SHIFT)\n-#define AND_PRIO           (10 << PRIO_SHIFT)\n-#define MINMAX_PRIO\t   (11 << PRIO_SHIFT)\n-#define EQUAL_PRIO         (12 << PRIO_SHIFT)\n-#define LESS_PRIO          (13 << PRIO_SHIFT)\n-#define SHIFT_PRIO         (14 << PRIO_SHIFT)\n-#define PLUS_PRIO          (15 << PRIO_SHIFT)\n-#define MUL_PRIO           (16 << PRIO_SHIFT)\n-#define UNARY_PRIO        ((17 << PRIO_SHIFT) | RIGHT_ASSOC | NO_L_OPERAND)\n+#define NO_L_OPERAND\t(1 << 0)\n+#define LEFT_ASSOC\t(1 << 1)\n \n /* Operator to priority map.  Must be in the same order as the first\n    N entries of enum cpp_ttype.  */\n-static const short\n-op_to_prio[] =\n+static const struct operator\n+{\n+  uchar prio;\t\t\t/* Priorities are even.  */\n+  uchar flags;\n+} optab[] =\n {\n-  /* EQ */\t\t0,\t\t/* dummy entry - can't happen */\n-  /* NOT */\t\tUNARY_PRIO,\n-  /* GREATER */\t\tLESS_PRIO,\n-  /* LESS */\t\tLESS_PRIO,\n-  /* PLUS */\t\tPLUS_PRIO,\n-  /* MINUS */\t\tPLUS_PRIO,\n-  /* MULT */\t\tMUL_PRIO,\n-  /* DIV */\t\tMUL_PRIO,\n-  /* MOD */\t\tMUL_PRIO,\n-  /* AND */\t\tAND_PRIO,\n-  /* OR */\t\tOR_PRIO,\n-  /* XOR */\t\tXOR_PRIO,\n-  /* RSHIFT */\t\tSHIFT_PRIO,\n-  /* LSHIFT */\t\tSHIFT_PRIO,\n-  /* MIN */\t\tMINMAX_PRIO,\t/* C++ specific */\n-  /* MAX */\t\tMINMAX_PRIO,\t/* extensions */\n-\n-  /* COMPL */\t\tUNARY_PRIO,\n-  /* AND_AND */\t\tANDAND_PRIO,\n-  /* OR_OR */\t\tOROR_PRIO,\n-  /* QUERY */\t\tCOND_PRIO,\n-  /* COLON */\t\tCOLON_PRIO,\n-  /* COMMA */\t\tCOMMA_PRIO,\n-  /* OPEN_PAREN */\tOPEN_PAREN_PRIO,\n-  /* CLOSE_PAREN */\tCLOSE_PAREN_PRIO,\n-  /* EQ_EQ */\t\tEQUAL_PRIO,\n-  /* NOT_EQ */\t\tEQUAL_PRIO,\n-  /* GREATER_EQ */\tLESS_PRIO,\n-  /* LESS_EQ */\t\tLESS_PRIO,\n-  /* EOF */\t\tFORCE_REDUCE_PRIO,\n-  /* UPLUS */\t\tUNARY_PRIO,\n-  /* UMINUS */\t\tUNARY_PRIO\n+  /* EQ */\t\t{0, 0},\t\t/* Shouldn't happen.  */\n+  /* NOT */\t\t{16, NO_L_OPERAND},\n+  /* GREATER */\t\t{12, LEFT_ASSOC},\n+  /* LESS */\t\t{12, LEFT_ASSOC},\n+  /* PLUS */\t\t{14, LEFT_ASSOC},\n+  /* MINUS */\t\t{14, LEFT_ASSOC},\n+  /* MULT */\t\t{15, LEFT_ASSOC},\n+  /* DIV */\t\t{15, LEFT_ASSOC},\n+  /* MOD */\t\t{15, LEFT_ASSOC},\n+  /* AND */\t\t{9, LEFT_ASSOC},\n+  /* OR */\t\t{7, LEFT_ASSOC},\n+  /* XOR */\t\t{8, LEFT_ASSOC},\n+  /* RSHIFT */\t\t{13, LEFT_ASSOC},\n+  /* LSHIFT */\t\t{13, LEFT_ASSOC},\n+  /* MIN */\t\t{10, LEFT_ASSOC},\t/* C++ specific */\n+  /* MAX */\t\t{10, LEFT_ASSOC},\t/* extensions */\n+\n+  /* COMPL */\t\t{16, NO_L_OPERAND},\n+  /* AND_AND */\t\t{6, LEFT_ASSOC},\n+  /* OR_OR */\t\t{5, LEFT_ASSOC},\n+  /* QUERY */\t\t{3, 0},\n+  /* COLON */\t\t{4, LEFT_ASSOC},\n+  /* COMMA */\t\t{2, LEFT_ASSOC},\n+  /* OPEN_PAREN */\t{1, NO_L_OPERAND},\n+  /* CLOSE_PAREN */\t{0, 0},\n+  /* EOF */\t\t{0, 0},\n+  /* EQ_EQ */\t\t{11, LEFT_ASSOC},\n+  /* NOT_EQ */\t\t{11, LEFT_ASSOC},\n+  /* GREATER_EQ */\t{12, LEFT_ASSOC},\n+  /* LESS_EQ */\t\t{12, LEFT_ASSOC},\n+  /* UPLUS */\t\t{16, NO_L_OPERAND},\n+  /* UMINUS */\t\t{16, NO_L_OPERAND}\n };\n \n #define COMPARE(OP) \\\n@@ -549,7 +515,7 @@ op_to_prio[] =\n   top->value = OP v2; \\\n   top->unsignedp = unsigned2;\n #define SHIFT(PSH, MSH) \\\n-  if (skip_evaluation)  \\\n+  if (pfile->state.skip_eval)  \\\n     break;\t\t\\\n   top->unsignedp = unsigned1; \\\n   if (v2 < 0 && ! unsigned2)  \\\n@@ -558,54 +524,42 @@ op_to_prio[] =\n     top->value = PSH (pfile, v1, unsigned1, v2);\n \n /* Parse and evaluate a C expression, reading from PFILE.\n-   Returns the truth value of the expression.  */\n-int\n+   Returns the truth value of the expression.  \n+\n+   The implementation is an operator precedence parser, i.e. a\n+   bottom-up parser, using a stack for not-yet-reduced tokens.\n+\n+   The stack base is op_stack, and the current stack pointer is 'top'.\n+   There is a stack element for each operator (only), and the most\n+   recently pushed operator is 'top->op'.  An operand (value) is\n+   stored in the 'value' field of the stack element of the operator\n+   that precedes it.  */\n+bool\n _cpp_parse_expr (pfile)\n      cpp_reader *pfile;\n {\n-  /* The implementation is an operator precedence parser, i.e. a\n-     bottom-up parser, using a stack for not-yet-reduced tokens.\n-\n-     The stack base is 'stack', and the current stack pointer is 'top'.\n-     There is a stack element for each operator (only),\n-     and the most recently pushed operator is 'top->op'.\n-     An operand (value) is stored in the 'value' field of the stack\n-     element of the operator that precedes it.  */\n-\n-#define INIT_STACK_SIZE 20\n-  struct op init_stack[INIT_STACK_SIZE];\n-  struct op *stack = init_stack;\n-  struct op *limit = stack + INIT_STACK_SIZE;\n-  struct op *top = stack + 1;\n-  int skip_evaluation = 0;\n-  int result;\n-  unsigned int lex_count, saw_leading_not;\n-  bool want_value = true;\n+  struct op *top = pfile->op_stack;\n+  unsigned int lex_count;\n+  bool saw_leading_not, want_value = true;\n+\n+  pfile->state.skip_eval = 0;\n \n   /* Set up detection of #if ! defined().  */\n   pfile->mi_ind_cmacro = 0;\n-  saw_leading_not = 0;\n+  saw_leading_not = false;\n   lex_count = 0;\n \n-  /* We've finished when we try to reduce this.  */\n+  /* Lowest priority operator prevents further reductions.  */\n   top->op = CPP_EOF;\n-  /* Nifty way to catch missing '('.  */\n-  top->prio = EXTRACT_PRIO(CLOSE_PAREN_PRIO);\n \n   for (;;)\n     {\n-      unsigned int prio;\n-      unsigned int flags;\n       struct op op;\n \n       /* Read a token */\n-      op = lex (pfile, skip_evaluation);\n+      op = lex (pfile);\n       lex_count++;\n \n-      /* If the token is an operand, push its value and get next\n-\t token.  If it is an operator, handle some special cases, get\n-\t its priority and flags, and try to reduce the expression on\n-\t the stack.  */\n       switch (op.op)\n \t{\n \tcase CPP_ERROR:\n@@ -614,7 +568,6 @@ _cpp_parse_expr (pfile)\n \t  /* Push a value onto the stack.  */\n \t  if (!want_value)\n \t    SYNTAX_ERROR (\"missing binary operator\");\n-\tpush_immediate:\n \t  want_value = false;\n \t  top->value = op.value;\n \t  top->unsignedp = op.unsignedp;\n@@ -635,244 +588,266 @@ _cpp_parse_expr (pfile)\n \t  break;\n \t}\n \n-      flags = EXTRACT_FLAGS (op_to_prio[op.op]);\n-      prio = EXTRACT_PRIO (op_to_prio[op.op]);\n-      if (prio == EXTRACT_PRIO (OPEN_PAREN_PRIO))\n-\tgoto skip_reduction;\n-\n-      /* Check for reductions.  Then push the operator.  */\n-      while (prio <= top->prio)\n+      /* Check we have a value or operator as appropriate.  */\n+      if (optab[op.op].flags & NO_L_OPERAND)\n \t{\n-\t  HOST_WIDEST_INT v1, v2;\n-\t  unsigned int unsigned1, unsigned2;\n-\t  \n-\t  /* Most operators that can appear on the stack require a\n-\t     right operand.  Check this before trying to reduce.  */\n-\t  if (want_value)\n+\t  if (!want_value)\n+\t    SYNTAX_ERROR2 (\"missing binary operator before '%s'\",\n+\t\t\t   op_as_text (pfile, op.op));\n+\t}\n+      else if (want_value)\n+\t{\n+\t  if (op.op == CPP_CLOSE_PAREN)\n \t    {\n \t      if (top->op == CPP_OPEN_PAREN)\n \t\tSYNTAX_ERROR (\"void expression between '(' and ')'\");\n-\t      else if (top->op != CPP_EOF)\n-\t\tSYNTAX_ERROR2 (\"operator '%s' has no right operand\",\n-\t\t\t       op_as_text (pfile, top->op));\n-\t      else if (op.op != CPP_CLOSE_PAREN)\n-\t\tSYNTAX_ERROR (\"#if with no expression\");\n-\t    }\n-\n-\t  unsigned2 = top->unsignedp, v2 = top->value;\n-\t  top--;\n-\t  unsigned1 = top->unsignedp, v1 = top->value;\n-\n-\t  /* Now set top->value = (top[1].op)(v1, v2); */\n-\t  switch (top[1].op)\n-\t    {\n-\t    default:\n-\t      cpp_error (pfile, DL_ICE, \"impossible operator '%s'\",\n-\t\t\t op_as_text (pfile, top[1].op));\n-\t      goto syntax_error;\n-\n-\t    case CPP_NOT:\t UNARY(!);\tbreak;\n-\t    case CPP_COMPL:\t UNARY(~);\tbreak;\n-\t    case CPP_LESS:  \t COMPARE(<);\tbreak;\n-\t    case CPP_GREATER:\t COMPARE(>);\tbreak;\n-\t    case CPP_LESS_EQ:\t COMPARE(<=);\tbreak;\n-\t    case CPP_GREATER_EQ: COMPARE(>=);\tbreak;\n-\t    case CPP_EQ_EQ:\t EQUALITY(==);\tbreak;\n-\t    case CPP_NOT_EQ:\t EQUALITY(!=);\tbreak;\n-\t    case CPP_AND:\t BITWISE(&);\tbreak;\n-\t    case CPP_XOR:\t BITWISE(^);\tbreak;\n-\t    case CPP_OR:\t BITWISE(|);\tbreak;\n-\t    case CPP_LSHIFT:\t SHIFT(left_shift, right_shift); break;\n-\t    case CPP_RSHIFT:\t SHIFT(right_shift, left_shift); break;\n-\t    case CPP_MIN:\t MINMAX(<);\tbreak;\n-\t    case CPP_MAX:\t MINMAX(>);\tbreak;\n-\n-\t    case CPP_UPLUS:\n-\t      /* Can't use UNARY(+) because K+R C did not have unary\n-\t\t plus.  Can't use UNARY() because some compilers object\n-\t\t to the empty argument.  */\n-\t      top->value = v2;\n-\t      top->unsignedp = unsigned2;\n-\t      if (CPP_WTRADITIONAL (pfile))\n-\t\tcpp_error (pfile, DL_WARNING,\n-\t\t\t   \"traditional C rejects the unary plus operator\");\n-\t      break;\n-\t    case CPP_UMINUS:\n-\t      UNARY(-);\n-\t      if (!skip_evaluation && (top->value & v2) < 0 && !unsigned2)\n-\t\tinteger_overflow (pfile);\n-\t      break;\n-\n-\t    case CPP_PLUS:\n-\t      top->value = v1 + v2;\n-\t      top->unsignedp = unsigned1 | unsigned2;\n-\t      if (! top->unsignedp && ! skip_evaluation\n-\t\t  && ! possible_sum_sign (v1, v2, top->value))\n-\t\tinteger_overflow (pfile);\n-\t      break;\n-\t    case CPP_MINUS:\n-\t      top->value = v1 - v2;\n-\t      top->unsignedp = unsigned1 | unsigned2;\n-\t      if (! top->unsignedp && ! skip_evaluation\n-\t\t  && ! possible_sum_sign (top->value, v2, v1))\n-\t\tinteger_overflow (pfile);\n-\t      break;\n-\t    case CPP_MULT:\n-\t      top->unsignedp = unsigned1 | unsigned2;\n-\t      if (top->unsignedp)\n-\t\ttop->value = (unsigned HOST_WIDEST_INT) v1 * v2;\n-\t      else if (!skip_evaluation)\n-\t\t{\n-\t\t  top->value = v1 * v2;\n-\t\t  if (v1 && (top->value / v1 != v2\n-\t\t             || (top->value & v1 & v2) < 0))\n-\t\t    integer_overflow (pfile);\n-\t\t}\n-\t      break;\n-\t    case CPP_DIV:\n-\t    case CPP_MOD:\n-\t      if (skip_evaluation)\n-\t\tbreak;\n-\t      if (v2 == 0)\n-\t\tSYNTAX_ERROR (\"division by zero in #if\");\n-\t      top->unsignedp = unsigned1 | unsigned2;\n-\t      if (top[1].op == CPP_DIV)\n-\t\t{\n-\t\t  if (top->unsignedp)\n-\t\t    top->value = (unsigned HOST_WIDEST_INT) v1 / v2;\n-\t\t  else\n-\t\t    {\n-\t\t      top->value = v1 / v2;\n-\t\t      if ((top->value & v1 & v2) < 0)\n-\t\t\tinteger_overflow (pfile);\n-\t\t    }\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  if (top->unsignedp)\n-\t\t    top->value = (unsigned HOST_WIDEST_INT) v1 % v2;\n-\t\t  else\n-\t\t    top->value = v1 % v2;\n-\t\t}\n-\t      break;\n-\n-\t    case CPP_OR_OR:\n-\t      top->value = v1 || v2;\n-\t      top->unsignedp = 0;\n-\t      if (v1) skip_evaluation--;\n-\t      break;\n-\t    case CPP_AND_AND:\n-\t      top->value = v1 && v2;\n-\t      top->unsignedp = 0;\n-\t      if (!v1) skip_evaluation--;\n-\t      break;\n-\t    case CPP_COMMA:\n-\t      if (CPP_PEDANTIC (pfile))\n-\t\tcpp_error (pfile, DL_PEDWARN,\n-\t\t\t   \"comma operator in operand of #if\");\n-\t      top->value = v2;\n-\t      top->unsignedp = unsigned2;\n-\t      break;\n-\t    case CPP_QUERY:\n-\t      SYNTAX_ERROR (\"syntax error '?' without following ':'\");\n-\t    case CPP_COLON:\n-\t      if (top[0].op != CPP_QUERY)\n-\t\tSYNTAX_ERROR (\"syntax error ':' without preceding '?'\");\n-\t      top--;\n-\t      if (top->value) skip_evaluation--;\n-\t      top->value = top->value ? v1 : v2;\n-\t      top->unsignedp = unsigned1 | unsigned2;\n-\t      break;\n-\t    case CPP_OPEN_PAREN:\n-\t      if (op.op != CPP_CLOSE_PAREN)\n-\t\tSYNTAX_ERROR (\"missing ')' in expression\");\n-\t      op.value = v2;\n-\t      op.unsignedp = unsigned2;\n-\t      goto push_immediate;\n-\t    case CPP_EOF:\n-\t      /* Reducing this dummy operator indicates we've finished.  */\n-\t      if (op.op == CPP_CLOSE_PAREN)\n-\t\tSYNTAX_ERROR (\"missing '(' in expression\");\n-\t      goto done;\n \t    }\n+\t  else if (top->op == CPP_EOF)\n+\t    SYNTAX_ERROR (\"#if with no expression\");\n+\t  if (top->op != CPP_EOF && top->op != CPP_OPEN_PAREN)\n+\t    SYNTAX_ERROR2 (\"operator '%s' has no right operand\",\n+\t\t\t   op_as_text (pfile, top->op));\n \t}\n \n-      /* Handle short-circuit evaluations.  */\n-      if (flags & SHORT_CIRCUIT)\n-\tswitch (op.op)\n-\t  {\n-\t  case CPP_OR_OR:    if (top->value) skip_evaluation++; break;\n-\t  case CPP_AND_AND:\n-\t  case CPP_QUERY:    if (!top->value) skip_evaluation++; break;\n-\t  case CPP_COLON:\n-\t    if (top[-1].value) /* Was '?' condition true?  */\n-\t      skip_evaluation++;\n-\t    else\n-\t      skip_evaluation--;\n-\t  default:\n-\t    break;\n-\t  }\n+      top = reduce (pfile, top, op.op);\n+      if (!top)\n+\tgoto syntax_error;\n \n-    skip_reduction:\n-      /* Check we have a left operand iff we need one.  */\n-      if (flags & NO_L_OPERAND)\n-\t{\n-\t  if (!want_value)\n-\t    SYNTAX_ERROR2 (\"missing binary operator before '%s'\",\n-\t\t\t   op_as_text (pfile, op.op));\n-\t}\n-      else\n+      switch (op.op)\n \t{\n-\t  if (want_value)\n-\t    SYNTAX_ERROR2 (\"operator '%s' has no left operand\",\n-\t\t\t   op_as_text (pfile, op.op));\n+\tcase CPP_CLOSE_PAREN:\n+\t  continue;\n+\tcase CPP_EOF:\n+\t  goto done;\n+\tcase CPP_OR_OR:\n+\t  if (top->value)\n+\t    pfile->state.skip_eval++;\n+\t  break;\n+\tcase CPP_AND_AND:\n+\tcase CPP_QUERY:\n+\t  if (!top->value)\n+\t    pfile->state.skip_eval++;\n+\t  break;\n+\tcase CPP_COLON:\n+\t  if (top[-1].value) /* Was '?' condition true?  */\n+\t    pfile->state.skip_eval++;\n+\t  else\n+\t    pfile->state.skip_eval--;\n+\tdefault:\n+\t  break;\n \t}\n+\n       want_value = true;\n \n       /* Check for and handle stack overflow.  */\n-      top++;\n-      if (top == limit)\n-\t{\n-\t  struct op *new_stack;\n-\t  int old_size = (char *) limit - (char *) stack;\n-\t  int new_size = 2 * old_size;\n-\t  if (stack != init_stack)\n-\t    new_stack = (struct op *) xrealloc (stack, new_size);\n-\t  else\n-\t    {\n-\t      new_stack = (struct op *) xmalloc (new_size);\n-\t      memcpy (new_stack, stack, old_size);\n-\t    }\n-\t  stack = new_stack;\n-\t  top = (struct op *) ((char *) new_stack + old_size);\n-\t  limit = (struct op *) ((char *) new_stack + new_size);\n-\t}\n+      if (++top == pfile->op_limit)\n+\ttop = _cpp_expand_op_stack (pfile);\n       \n-      top->flags = flags;\n-      top->prio = prio & ~EXTRACT_PRIO(RIGHT_ASSOC);\n       top->op = op.op;\n     }\n \n- done:\n+done:\n   /* The controlling macro expression is only valid if we called lex 3\n      times: <!> <defined expression> and <EOF>.  push_conditional ()\n      checks that we are at top-of-file.  */\n   if (pfile->mi_ind_cmacro && !(saw_leading_not && lex_count == 3))\n     pfile->mi_ind_cmacro = 0;\n \n-  result = (top[1].value != 0);\n-\n-  if (top != stack)\n+  if (top != pfile->op_stack)\n     {\n       cpp_error (pfile, DL_ICE, \"unbalanced stack in #if\");\n     syntax_error:\n-      result = 0;  /* Return 0 on syntax error.  */\n+      return false;  /* Return false on syntax error.  */\n     }\n \n-  /* Free dynamic stack if we allocated one.  */\n-  if (stack != init_stack)\n-    free (stack);\n-  return result;\n+  return top->value != 0;\n+}\n+\n+/* Reduce the operator / value stack if possible, in preparation for\n+   pushing operator OP.  Returns NULL on error, otherwise the top of\n+   the stack.  */\n+static struct op *\n+reduce (pfile, top, op)\n+     cpp_reader *pfile;\n+     struct op *top;\n+     enum cpp_ttype op;\n+{\n+  unsigned int prio;\n+\n+  if (op == CPP_OPEN_PAREN)\n+    return top;\n+\n+  /* Decrement the priority of left-associative operators to force a\n+     reduction with operators of otherwise equal priority.  */\n+  prio = optab[op].prio - ((optab[op].flags & LEFT_ASSOC) != 0);\n+  while (prio < optab[top->op].prio)\n+    {\n+      HOST_WIDEST_INT v1, v2;\n+      unsigned int unsigned1, unsigned2;\n+\n+      unsigned2 = top->unsignedp, v2 = top->value;\n+      top--;\n+      unsigned1 = top->unsignedp, v1 = top->value;\n+\n+      /* Now set top->value = (top[1].op)(v1, v2); */\n+      switch (top[1].op)\n+\t{\n+\tdefault:\n+\t  cpp_error (pfile, DL_ICE, \"impossible operator '%s'\",\n+\t\t     op_as_text (pfile, top[1].op));\n+\t  return 0;\n+\n+\tcase CPP_NOT:\t UNARY(!);\tbreak;\n+\tcase CPP_COMPL:\t UNARY(~);\tbreak;\n+\tcase CPP_LESS: \t COMPARE(<);\tbreak;\n+\tcase CPP_GREATER: COMPARE(>);\tbreak;\n+\tcase CPP_LESS_EQ: COMPARE(<=);\tbreak;\n+\tcase CPP_GREATER_EQ: COMPARE(>=); break;\n+\tcase CPP_EQ_EQ:\t EQUALITY(==);\tbreak;\n+\tcase CPP_NOT_EQ: EQUALITY(!=);\tbreak;\n+\tcase CPP_AND:\t BITWISE(&);\tbreak;\n+\tcase CPP_XOR:\t BITWISE(^);\tbreak;\n+\tcase CPP_OR:\t BITWISE(|);\tbreak;\n+\tcase CPP_LSHIFT: SHIFT(left_shift, right_shift); break;\n+\tcase CPP_RSHIFT: SHIFT(right_shift, left_shift); break;\n+\tcase CPP_MIN:\t MINMAX(<);\tbreak;\n+\tcase CPP_MAX:\t MINMAX(>);\tbreak;\n+\n+\tcase CPP_UPLUS:\n+\t  /* Can't use UNARY(+) because K+R C did not have unary\n+\t     plus.  Can't use UNARY() because some compilers object\n+\t     to the empty argument.  */\n+\t  top->value = v2;\n+\t  top->unsignedp = unsigned2;\n+\t  if (CPP_WTRADITIONAL (pfile))\n+\t    cpp_error (pfile, DL_WARNING,\n+\t\t       \"traditional C rejects the unary plus operator\");\n+\t  break;\n+\tcase CPP_UMINUS:\n+\t  UNARY(-);\n+\t  if (!pfile->state.skip_eval && (top->value & v2) < 0 && !unsigned2)\n+\t    integer_overflow (pfile);\n+\t  break;\n+\n+\tcase CPP_PLUS:\n+\t  top->value = v1 + v2;\n+\t  top->unsignedp = unsigned1 | unsigned2;\n+\t  if (! top->unsignedp && ! pfile->state.skip_eval\n+\t      && ! possible_sum_sign (v1, v2, top->value))\n+\t    integer_overflow (pfile);\n+\t  break;\n+\tcase CPP_MINUS:\n+\t  top->value = v1 - v2;\n+\t  top->unsignedp = unsigned1 | unsigned2;\n+\t  if (! top->unsignedp && ! pfile->state.skip_eval\n+\t      && ! possible_sum_sign (top->value, v2, v1))\n+\t    integer_overflow (pfile);\n+\t  break;\n+\tcase CPP_MULT:\n+\t  top->unsignedp = unsigned1 | unsigned2;\n+\t  if (top->unsignedp)\n+\t    top->value = (unsigned HOST_WIDEST_INT) v1 * v2;\n+\t  else if (!pfile->state.skip_eval)\n+\t    {\n+\t      top->value = v1 * v2;\n+\t      if (v1 && (top->value / v1 != v2\n+\t\t\t || (top->value & v1 & v2) < 0))\n+\t\tinteger_overflow (pfile);\n+\t    }\n+\t  break;\n+\tcase CPP_DIV:\n+\tcase CPP_MOD:\n+\t  if (pfile->state.skip_eval)\n+\t    break;\n+\t  if (v2 == 0)\n+\t    {\n+\t      cpp_error (pfile, DL_ERROR, \"division by zero in #if\");\n+\t      return 0;\n+\t    }\n+\t  top->unsignedp = unsigned1 | unsigned2;\n+\t  if (top[1].op == CPP_DIV)\n+\t    {\n+\t      if (top->unsignedp)\n+\t\ttop->value = (unsigned HOST_WIDEST_INT) v1 / v2;\n+\t      else\n+\t\t{\n+\t\t  top->value = v1 / v2;\n+\t\t  if ((top->value & v1 & v2) < 0)\n+\t\t    integer_overflow (pfile);\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      if (top->unsignedp)\n+\t\ttop->value = (unsigned HOST_WIDEST_INT) v1 % v2;\n+\t      else\n+\t\ttop->value = v1 % v2;\n+\t    }\n+\t  break;\n+\n+\tcase CPP_OR_OR:\n+\t  top->value = v1 || v2;\n+\t  top->unsignedp = 0;\n+\t  if (v1) pfile->state.skip_eval--;\n+\t  break;\n+\tcase CPP_AND_AND:\n+\t  top->value = v1 && v2;\n+\t  top->unsignedp = 0;\n+\t  if (!v1) pfile->state.skip_eval--;\n+\t  break;\n+\tcase CPP_COMMA:\n+\t  if (CPP_PEDANTIC (pfile))\n+\t    cpp_error (pfile, DL_PEDWARN,\n+\t\t       \"comma operator in operand of #if\");\n+\t  top->value = v2;\n+\t  top->unsignedp = unsigned2;\n+\t  break;\n+\tcase CPP_QUERY:\n+\t  cpp_error (pfile, DL_ERROR, \"'?' without following ':'\");\n+\t  return 0;\n+\tcase CPP_COLON:\n+\t  if (top->op != CPP_QUERY)\n+\t    {\n+\t      cpp_error (pfile, DL_ERROR, \" ':' without preceding '?'\");\n+\t      return 0;\n+\t    }\n+\t  top--;\n+\t  if (top->value) pfile->state.skip_eval--;\n+\t  top->value = top->value ? v1 : v2;\n+\t  top->unsignedp = unsigned1 | unsigned2;\n+\t  break;\n+\tcase CPP_OPEN_PAREN:\n+\t  if (op != CPP_CLOSE_PAREN)\n+\t    {\n+\t      cpp_error (pfile, DL_ERROR, \"missing ')' in expression\");\n+\t      return 0;\n+\t    }\n+\t  top->value = v2;\n+\t  top->unsignedp = unsigned2;\n+\t  return top;\n+\t}\n+    }\n+\n+  if (op == CPP_CLOSE_PAREN)\n+    {\n+      cpp_error (pfile, DL_ERROR, \"missing '(' in expression\");\n+      return 0;\n+    }\n+\n+  return top;\n+}\n+\n+/* Returns the position of the old top of stack after expansion.  */\n+struct op *\n+_cpp_expand_op_stack (pfile)\n+     cpp_reader *pfile;\n+{\n+  size_t n = (size_t) (pfile->op_limit - pfile->op_stack);\n+\n+  pfile->op_stack = (struct op *) xrealloc (pfile->op_stack,\n+\t\t\t\t\t    (n * 2 + 20) * sizeof (struct op));\n+\n+  return pfile->op_stack + n;\n }\n \n /* Output OP as text for diagnostics.  */"}, {"sha": "743feeae89c9575ac5927dd97ef46f2da5eb8cb7", "filename": "gcc/cpphash.h", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87ed109f1f7fab7afc05afca460523a2493c0f43/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87ed109f1f7fab7afc05afca460523a2493c0f43/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=87ed109f1f7fab7afc05afca460523a2493c0f43", "patch": "@@ -27,6 +27,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n \n struct directive;\t\t/* Deliberately incomplete.  */\n struct pending_option;\n+struct op;\n \n /* Test if a sign is valid within a preprocessing number.  */\n #define VALID_SIGN(c, prevc) \\\n@@ -153,6 +154,9 @@ struct lexer_state\n \n   /* Nonzero when parsing arguments to a function-like macro.  */\n   unsigned char parsing_args;\n+\n+  /* Nonzero to skip evaluating part of an expression.  */\n+  unsigned int skip_eval;\n };\n \n /* Special nodes - identifiers with predefined significance.  */\n@@ -312,6 +316,9 @@ struct cpp_reader\n   /* Identifier hash table.  */ \n   struct ht *hash_table;\n \n+  /* Expression parser stack.  */\n+  struct op *op_stack, *op_limit;\n+\n   /* User visible options.  */\n   struct cpp_options opts;\n \n@@ -391,7 +398,8 @@ extern void _cpp_pop_file_buffer\tPARAMS ((cpp_reader *,\n \t\t\t\t\t\t struct include_file *));\n \n /* In cppexp.c */\n-extern int _cpp_parse_expr\t\tPARAMS ((cpp_reader *));\n+extern bool _cpp_parse_expr\t\tPARAMS ((cpp_reader *));\n+extern struct op *_cpp_expand_op_stack\tPARAMS ((cpp_reader *));\n \n /* In cpplex.c */\n extern cpp_token *_cpp_temp_token\tPARAMS ((cpp_reader *));"}, {"sha": "c4f594234b51dced1b61f2f25ab2e8f7016b8243", "filename": "gcc/cppinit.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87ed109f1f7fab7afc05afca460523a2493c0f43/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87ed109f1f7fab7afc05afca460523a2493c0f43/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=87ed109f1f7fab7afc05afca460523a2493c0f43", "patch": "@@ -535,6 +535,9 @@ cpp_create_reader (lang)\n   pfile->a_buff = _cpp_get_buff (pfile, 0);\n   pfile->u_buff = _cpp_get_buff (pfile, 0);\n \n+  /* The expression parser stack.  */\n+  _cpp_expand_op_stack (pfile);\n+\n   /* Initialise the buffer obstack.  */\n   gcc_obstack_init (&pfile->buffer_ob);\n \n@@ -556,6 +559,7 @@ cpp_destroy (pfile)\n \n   free_chain (CPP_OPTION (pfile, pending)->include_head);\n   free (CPP_OPTION (pfile, pending));\n+  free (pfile->op_stack);\n \n   while (CPP_BUFFER (pfile) != NULL)\n     _cpp_pop_buffer (pfile);"}, {"sha": "a579873c701bdba79ceb32406fd6afe61fe87529", "filename": "gcc/cpplib.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87ed109f1f7fab7afc05afca460523a2493c0f43/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87ed109f1f7fab7afc05afca460523a2493c0f43/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=87ed109f1f7fab7afc05afca460523a2493c0f43", "patch": "@@ -1366,7 +1366,7 @@ do_if (pfile)\n   int skip = 1;\n \n   if (! pfile->state.skipping)\n-    skip = _cpp_parse_expr (pfile) == 0;\n+    skip = _cpp_parse_expr (pfile) == false;\n \n   push_conditional (pfile, skip, T_IF, pfile->mi_ind_cmacro);\n }"}, {"sha": "bbf272be2027affb4449826f1efd76be600d80ab", "filename": "gcc/cpplib.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87ed109f1f7fab7afc05afca460523a2493c0f43/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87ed109f1f7fab7afc05afca460523a2493c0f43/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=87ed109f1f7fab7afc05afca460523a2493c0f43", "patch": "@@ -58,7 +58,7 @@ struct file_name_map_list;\n #define CPP_LAST_EQ CPP_MAX\n #define CPP_FIRST_DIGRAPH CPP_HASH\n #define CPP_LAST_PUNCTUATOR CPP_DOT_STAR\n-#define CPP_LAST_CPP_OP CPP_EOF\n+#define CPP_LAST_CPP_OP CPP_LESS_EQ\n \n #define TTYPE_TABLE\t\t\t\t\\\n   OP(CPP_EQ = 0,\t\"=\")\t\t\t\\\n@@ -86,13 +86,13 @@ struct file_name_map_list;\n   OP(CPP_COMMA,\t\t\",\")\t/* grouping */\t\\\n   OP(CPP_OPEN_PAREN,\t\"(\")\t\t\t\\\n   OP(CPP_CLOSE_PAREN,\t\")\")\t\t\t\\\n+  TK(CPP_EOF,\t\tSPELL_NONE)\t\t\\\n   OP(CPP_EQ_EQ,\t\t\"==\")\t/* compare */\t\\\n   OP(CPP_NOT_EQ,\t\"!=\")\t\t\t\\\n   OP(CPP_GREATER_EQ,\t\">=\")\t\t\t\\\n   OP(CPP_LESS_EQ,\t\"<=\")\t\t\t\\\n \\\n-  /* These 3 are special in preprocessor expressions.  */ \\\n-  TK(CPP_EOF,\t\tSPELL_NONE)\t\t\\\n+  /* These two are unary + / - in preprocessor expressions.  */ \\\n   OP(CPP_PLUS_EQ,\t\"+=\")\t/* math */\t\\\n   OP(CPP_MINUS_EQ,\t\"-=\")\t\t\t\\\n \\"}, {"sha": "1ae710f08c3bfb741b1d154fed71c6b2765fa8a9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87ed109f1f7fab7afc05afca460523a2493c0f43/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87ed109f1f7fab7afc05afca460523a2493c0f43/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=87ed109f1f7fab7afc05afca460523a2493c0f43", "patch": "@@ -1,3 +1,9 @@\n+2002-04-28  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* gcc.dg/cpp/if-mop.c: Update.\n+\t* gcc.dg/cpp/if-mpar.c: Add test.\n+\t* gcc.dg/cpp/if-oppr.c: Update.\n+\n 2002-04-28  Franz Sirl  <Franz.Sirl-kernel@lauterbach.com>\n \n \tPR c/6343"}, {"sha": "9202740e6b1246992ecbfa743bc8e5cdb2ca3c6a", "filename": "gcc/testsuite/gcc.dg/cpp/if-mop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87ed109f1f7fab7afc05afca460523a2493c0f43/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fif-mop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87ed109f1f7fab7afc05afca460523a2493c0f43/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fif-mop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fif-mop.c?ref=87ed109f1f7fab7afc05afca460523a2493c0f43", "patch": "@@ -12,7 +12,7 @@\n #if ~\t\t/* { dg-error \"no right op\" \"no unary operand\" } */\n #endif\n \n-#if 3 + * 6 + 4  /* { dg-error \"no left op\" \"no left operand\" } */\n+#if 3 + * 6 + 4  /* { dg-error \"no right op\" \"no right operand\" } */\n #endif\n \n #if 2 ~2\t/* { dg-error \"missing bin\" \"no binary operator\" } */"}, {"sha": "df200bbbab4615b31d6caca258f9a874d59a8edd", "filename": "gcc/testsuite/gcc.dg/cpp/if-mpar.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87ed109f1f7fab7afc05afca460523a2493c0f43/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fif-mpar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87ed109f1f7fab7afc05afca460523a2493c0f43/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fif-mpar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fif-mpar.c?ref=87ed109f1f7fab7afc05afca460523a2493c0f43", "patch": "@@ -19,3 +19,6 @@\n \n #if 4)\t\t/* { dg-error \"missing '\\\\('\" \"missing '(' no. 3\" } */\n #endif\n+\n+#if (\t\t/* { dg-error \"missing '\\\\)'\" \"missing ')' no. 3\" } */\n+#endif"}, {"sha": "9c4910f6a20759d132fe3217962a68113860576f", "filename": "gcc/testsuite/gcc.dg/cpp/if-oppr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87ed109f1f7fab7afc05afca460523a2493c0f43/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fif-oppr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87ed109f1f7fab7afc05afca460523a2493c0f43/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fif-oppr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fif-oppr.c?ref=87ed109f1f7fab7afc05afca460523a2493c0f43", "patch": "@@ -20,7 +20,7 @@\n #endif\n \n /* , not higher than ?.  This is not a syntax error if it is.  */\n-#if 1 ? 0, 1: 1\t/* { dg-error \"syntax\" \"? higher precedence than ,\" } */\n+#if 1 ? 0, 1: 1\t/* { dg-error \"without\" \"? higher precedence than ,\" } */\n #error\n #endif\n "}]}