{"sha": "299f79b5a0748924f00ea910999fc4b7fcc64f3b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjk5Zjc5YjVhMDc0ODkyNGYwMGVhOTEwOTk5ZmM0YjdmY2M2NGYzYg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2003-04-20T11:57:38Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2003-04-20T11:57:38Z"}, "message": "cpplex.c (_cpp_lex_direct): Set BOL for CPP_EOF tokens.\n\n.:\t* cpplex.c (_cpp_lex_direct): Set BOL for CPP_EOF tokens.\n\t* gcov.c (output_lines): Don't be so fussy about going past EOF.\ncp:\n\t* cp/decl2.c (start_static_storage_duration_function): Take count\n\targ, don't check if it wraps round.\n\t(generate_ctor_or_dtor_function): Add locus arg, use it.\n\t(generate_ctor_and_dtor_functions_for_priority): Data arg is a\n\tlocus.\n\t(finish_file): Set line numbers to past EOF for synthesized\n\tfunctions.\n\nFrom-SVN: r65847", "tree": {"sha": "6df1380397d5413a13bae6c8718beff0cc10f10f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6df1380397d5413a13bae6c8718beff0cc10f10f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/299f79b5a0748924f00ea910999fc4b7fcc64f3b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/299f79b5a0748924f00ea910999fc4b7fcc64f3b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/299f79b5a0748924f00ea910999fc4b7fcc64f3b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/299f79b5a0748924f00ea910999fc4b7fcc64f3b/comments", "author": null, "committer": null, "parents": [{"sha": "de0c0e694f430d942db00e60e6218d9e1715f119", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de0c0e694f430d942db00e60e6218d9e1715f119", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de0c0e694f430d942db00e60e6218d9e1715f119"}], "stats": {"total": 86, "additions": 58, "deletions": 28}, "files": [{"sha": "b73ad6d9bc1cd67676b6fa64fcb2f6dd7314b2d3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/299f79b5a0748924f00ea910999fc4b7fcc64f3b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/299f79b5a0748924f00ea910999fc4b7fcc64f3b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=299f79b5a0748924f00ea910999fc4b7fcc64f3b", "patch": "@@ -1,3 +1,8 @@\n+2003-04-20  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* cpplex.c (_cpp_lex_direct): Set BOL for CPP_EOF tokens.\n+\t* gcov.c (output_lines): Don't be so fussy about going past EOF.\n+\n 2003-04-20  Neil Booth  <neil@daikokuya.co.uk>\n \n \t* Makefile.in (LIBCPP_OBJS): Add cppcharset.o."}, {"sha": "8ea634fb439837aeac7460124b71c169f775242c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/299f79b5a0748924f00ea910999fc4b7fcc64f3b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/299f79b5a0748924f00ea910999fc4b7fcc64f3b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=299f79b5a0748924f00ea910999fc4b7fcc64f3b", "patch": "@@ -1,4 +1,14 @@\n-2003-04-19  Nathan Sidwell  <nathan@codesourcery.com>\n+2003-04-20  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* cp/decl2.c (start_static_storage_duration_function): Take count\n+\targ, don't check if it wraps round.\n+\t(generate_ctor_or_dtor_function): Add locus arg, use it.\n+\t(generate_ctor_and_dtor_functions_for_priority): Data arg is a\n+\tlocus.\n+\t(finish_file): Set line numbers to past EOF for synthesized\n+\tfunctions.\n+\n+2003-04-20  Nathan Sidwell  <nathan@codesourcery.com>\n \n \tPR c++/10405\n \t* search.c (lookup_field_1): Final scan goes backwards for"}, {"sha": "7b7dd471be5f85a3f26f72a741e52e27926fdb0c", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 34, "deletions": 22, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/299f79b5a0748924f00ea910999fc4b7fcc64f3b/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/299f79b5a0748924f00ea910999fc4b7fcc64f3b/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=299f79b5a0748924f00ea910999fc4b7fcc64f3b", "patch": "@@ -73,14 +73,14 @@ static tree merge_functions (tree, tree);\n static tree decl_namespace (tree);\n static tree validate_nonmember_using_decl (tree, tree *, tree *);\n static void do_nonmember_using_decl (tree, tree, tree, tree, tree *, tree *);\n-static tree start_static_storage_duration_function (void);\n+static tree start_static_storage_duration_function (unsigned);\n static void finish_static_storage_duration_function (tree);\n static priority_info get_priority_info (int);\n static void do_static_initialization (tree, tree);\n static void do_static_destruction (tree);\n static tree start_static_initialization_or_destruction (tree, int);\n static void finish_static_initialization_or_destruction (tree);\n-static void generate_ctor_or_dtor_function (bool, int);\n+static void generate_ctor_or_dtor_function (bool, int, location_t *);\n static int generate_ctor_and_dtor_functions_for_priority (splay_tree_node,\n                                                           void *);\n static tree prune_vars_needing_no_initialization (tree *);\n@@ -2076,25 +2076,16 @@ static splay_tree priority_info_map;\n    translation unit.  */\n \n static tree\n-start_static_storage_duration_function (void)\n+start_static_storage_duration_function (unsigned count)\n {\n-  static unsigned ssdf_number;\n-\n   tree parm_types;\n   tree type;\n   tree body;\n   char id[sizeof (SSDF_IDENTIFIER) + 1 /* '\\0' */ + 32];\n \n   /* Create the identifier for this function.  It will be of the form\n      SSDF_IDENTIFIER_<number>.  */\n-  sprintf (id, \"%s_%u\", SSDF_IDENTIFIER, ssdf_number++);\n-  if (ssdf_number == 0)\n-    {\n-      /* Overflow occurred.  That means there are at least 4 billion\n-\t initialization functions.  */\n-      sorry (\"too many initialization functions required\");\n-      abort ();\n-    }\n+  sprintf (id, \"%s_%u\", SSDF_IDENTIFIER, count);\n \n   /* Create the parameters.  */\n   parm_types = void_list_node;\n@@ -2475,13 +2466,17 @@ write_out_vars (tree vars)\n    storage duration having the indicated PRIORITY.  */\n \n static void\n-generate_ctor_or_dtor_function (bool constructor_p, int priority)\n+generate_ctor_or_dtor_function (bool constructor_p, int priority,\n+\t\t\t\tlocation_t *locus)\n {\n   char function_key;\n   tree arguments;\n   tree body;\n   size_t i;\n \n+  input_filename = locus->file;\n+  lineno = locus->line++;\n+  \n   /* We use `I' to indicate initialization and `D' to indicate\n      destruction.  */\n   if (constructor_p)\n@@ -2526,20 +2521,20 @@ generate_ctor_or_dtor_function (bool constructor_p, int priority)\n    indicated by N.  */\n \n static int\n-generate_ctor_and_dtor_functions_for_priority (splay_tree_node n,\n-                                               void * data ATTRIBUTE_UNUSED)\n+generate_ctor_and_dtor_functions_for_priority (splay_tree_node n, void * data)\n {\n+  location_t *locus = data;\n   int priority = (int) n->key;\n   priority_info pi = (priority_info) n->value;\n \n   /* Generate the functions themselves, but only if they are really\n      needed.  */\n   if (pi->initializations_p\n       || (priority == DEFAULT_INIT_PRIORITY && static_ctors))\n-    generate_ctor_or_dtor_function (/*constructor_p=*/true, priority);\n+    generate_ctor_or_dtor_function (/*constructor_p=*/true, priority, locus);\n   if (pi->destructions_p\n       || (priority == DEFAULT_INIT_PRIORITY && static_dtors))\n-    generate_ctor_or_dtor_function (/*constructor_p=*/false, priority);\n+    generate_ctor_or_dtor_function (/*constructor_p=*/false, priority, locus);\n \n   /* Keep iterating.  */\n   return 0;\n@@ -2556,7 +2551,11 @@ finish_file ()\n   tree vars;\n   bool reconsider;\n   size_t i;\n+  location_t locus;\n+  unsigned ssdf_count = 0;\n \n+  locus.file = input_filename;\n+  locus.line = lineno;\n   at_eof = 1;\n \n   /* Bad parse errors.  Just forget about it.  */\n@@ -2683,7 +2682,13 @@ finish_file ()\n \t     out.  That's a deficiency in the back-end.  When this is\n \t     fixed, these initialization functions could all become\n \t     inline, with resulting performance improvements.  */\n-\t  tree ssdf_body = start_static_storage_duration_function ();\n+\t  tree ssdf_body;\n+\n+\t  /* Set the line and file, so that it is obviously not from\n+\t     the source file.  */\n+\t  input_filename = locus.file;\n+\t  lineno = locus.line;\n+\t  ssdf_body = start_static_storage_duration_function (ssdf_count);\n \n \t  /* Make sure the back end knows about all the variables.  */\n \t  write_out_vars (vars);\n@@ -2710,12 +2715,16 @@ finish_file ()\n \n \t  /* Finish up the static storage duration function for this\n \t     round.  */\n+\t  input_filename = locus.file;\n+\t  lineno = locus.line;\n \t  finish_static_storage_duration_function (ssdf_body);\n \n \t  /* All those initializations and finalizations might cause\n \t     us to need more inline functions, more template\n \t     instantiations, etc.  */\n \t  reconsider = true;\n+\t  ssdf_count++;\n+\t  locus.line++;\n \t}\n       \n       for (i = 0; i < deferred_fns_used; ++i)\n@@ -2838,15 +2847,16 @@ finish_file ()\n   if (priority_info_map)\n     splay_tree_foreach (priority_info_map, \n \t\t\tgenerate_ctor_and_dtor_functions_for_priority,\n-\t\t\t/*data=*/0);\n+\t\t\t/*data=*/&locus);\n   else\n     {\n+      \n       if (static_ctors)\n \tgenerate_ctor_or_dtor_function (/*constructor_p=*/true,\n-\t\t\t\t\tDEFAULT_INIT_PRIORITY);\n+\t\t\t\t\tDEFAULT_INIT_PRIORITY, &locus);\n       if (static_dtors)\n \tgenerate_ctor_or_dtor_function (/*constructor_p=*/false,\n-\t\t\t\t\tDEFAULT_INIT_PRIORITY);\n+\t\t\t\t\tDEFAULT_INIT_PRIORITY, &locus);\n     }\n \n   /* We're done with the splay-tree now.  */\n@@ -2886,6 +2896,8 @@ finish_file ()\n       dump_tree_statistics ();\n       dump_time_statistics ();\n     }\n+  input_filename = locus.file;\n+  lineno = locus.line;\n }\n \n /* T is the parse tree for an expression.  Return the expression after"}, {"sha": "efb5c06f9a9ae6e85fe4f83d5eec31c4ec8c49d0", "filename": "gcc/cpplex.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/299f79b5a0748924f00ea910999fc4b7fcc64f3b/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/299f79b5a0748924f00ea910999fc4b7fcc64f3b/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=299f79b5a0748924f00ea910999fc4b7fcc64f3b", "patch": "@@ -767,6 +767,12 @@ _cpp_lex_direct (pfile)\n       if (!_cpp_get_fresh_line (pfile))\n \t{\n \t  result->type = CPP_EOF;\n+\t  if (!pfile->state.in_directive)\n+\t    {\n+\t      /* Tell the compiler the line number of the EOF token.  */\n+\t      result->line = pfile->line;\n+\t      result->flags = BOL;\n+\t    }\n \t  return result;\n \t}\n       if (!pfile->keep_tokens)"}, {"sha": "d24979fc6fdc986606cb3d403f781970de8cdf0e", "filename": "gcc/gcov.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/299f79b5a0748924f00ea910999fc4b7fcc64f3b/gcc%2Fgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/299f79b5a0748924f00ea910999fc4b7fcc64f3b/gcc%2Fgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov.c?ref=299f79b5a0748924f00ea910999fc4b7fcc64f3b", "patch": "@@ -1862,16 +1862,13 @@ output_lines (gcov_file, src)\n \t    {\n \t      retval = fgets (string, STRING_SIZE, source_file);\n \t      if (!retval)\n-\t\t{\n-\t\t  fnotice (stderr, \"%s:unexpected EOF\\n\", src->name);\n-\t\t  break;\n-\t\t}\n+\t\tbreak;\n \t      fputs (retval, gcov_file);\n \t    }\n \t  while (!retval[0] || retval[strlen (retval) - 1] != '\\n');\n \t}\n       if (!retval)\n-\tfputs (\"??\\n\", gcov_file);\n+\tfputs (\"/*EOF*/\\n\", gcov_file);\n \n       if (flag_all_blocks)\n \t{"}]}