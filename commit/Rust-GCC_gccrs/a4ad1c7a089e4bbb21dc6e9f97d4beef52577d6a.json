{"sha": "a4ad1c7a089e4bbb21dc6e9f97d4beef52577d6a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTRhZDFjN2EwODllNGJiYjIxZGM2ZTlmOTdkNGJlZWY1MjU3N2Q2YQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2010-12-17T06:42:06Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2010-12-17T06:42:06Z"}, "message": "Rework locking code to split stack much less.\n\nFrom-SVN: r167973", "tree": {"sha": "668c072e9d31643ee62b14c735517b3a4114f61d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/668c072e9d31643ee62b14c735517b3a4114f61d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a4ad1c7a089e4bbb21dc6e9f97d4beef52577d6a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4ad1c7a089e4bbb21dc6e9f97d4beef52577d6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4ad1c7a089e4bbb21dc6e9f97d4beef52577d6a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4ad1c7a089e4bbb21dc6e9f97d4beef52577d6a/comments", "author": null, "committer": null, "parents": [{"sha": "785e11cc211af0d7c57b56bb063b44ced381d078", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/785e11cc211af0d7c57b56bb063b44ced381d078", "html_url": "https://github.com/Rust-GCC/gccrs/commit/785e11cc211af0d7c57b56bb063b44ced381d078"}], "stats": {"total": 114, "additions": 83, "deletions": 31}, "files": [{"sha": "7d6af6f3a0ba888683aec1c5050a348d74e9c205", "filename": "libgo/runtime/malloc.goc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4ad1c7a089e4bbb21dc6e9f97d4beef52577d6a/libgo%2Fruntime%2Fmalloc.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4ad1c7a089e4bbb21dc6e9f97d4beef52577d6a/libgo%2Fruntime%2Fmalloc.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmalloc.goc?ref=a4ad1c7a089e4bbb21dc6e9f97d4beef52577d6a", "patch": "@@ -270,6 +270,9 @@ runtime_allocmcache(void)\n void\n runtime_mallocinit(void)\n {\n+\truntime_initfintab();\n+\truntime_Mprof_Init();\n+\n \truntime_SysMemInit();\n \truntime_InitSizes();\n \truntime_MHeap_Init(&runtime_mheap, runtime_SysAlloc);"}, {"sha": "585996e6dca0d6a7c89d7ea3cc8ad56772523d39", "filename": "libgo/runtime/malloc.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4ad1c7a089e4bbb21dc6e9f97d4beef52577d6a/libgo%2Fruntime%2Fmalloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4ad1c7a089e4bbb21dc6e9f97d4beef52577d6a/libgo%2Fruntime%2Fmalloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmalloc.h?ref=a4ad1c7a089e4bbb21dc6e9f97d4beef52577d6a", "patch": "@@ -375,6 +375,7 @@ enum\n \tRefFlags = 0xFFFF0000U,\n };\n \n+void\truntime_Mprof_Init(void);\n void\truntime_MProf_Malloc(void*, uintptr);\n void\truntime_MProf_Free(void*, uintptr);\n void\truntime_MProf_Mark(void (*scan)(byte *, int64));"}, {"sha": "5d32721e696a146b5c3f3ca37b77c2d1020a3e29", "filename": "libgo/runtime/mfinal.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4ad1c7a089e4bbb21dc6e9f97d4beef52577d6a/libgo%2Fruntime%2Fmfinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4ad1c7a089e4bbb21dc6e9f97d4beef52577d6a/libgo%2Fruntime%2Fmfinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmfinal.c?ref=a4ad1c7a089e4bbb21dc6e9f97d4beef52577d6a", "patch": "@@ -5,7 +5,13 @@\n #include \"runtime.h\"\n #include \"malloc.h\"\n \n-static Lock finlock = LOCK_INITIALIZER;\n+static Lock finlock;\n+\n+void\n+runtime_initfintab()\n+{\n+\truntime_initlock(&finlock);\n+}\n \n // Finalizer hash table.  Direct hash, linear scan, at most 3/4 full.\n // Table size is power of 3 so that hash can be key % max."}, {"sha": "1a1a5ace834bc2769fb69468195d395cf9e6f784", "filename": "libgo/runtime/mgc0.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4ad1c7a089e4bbb21dc6e9f97d4beef52577d6a/libgo%2Fruntime%2Fmgc0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4ad1c7a089e4bbb21dc6e9f97d4beef52577d6a/libgo%2Fruntime%2Fmgc0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmgc0.c?ref=a4ad1c7a089e4bbb21dc6e9f97d4beef52577d6a", "patch": "@@ -27,7 +27,7 @@ struct BlockList\n };\n \n static bool finstarted;\n-static Lock finqlock = LOCK_INITIALIZER;\n+static pthread_mutex_t finqlock = PTHREAD_MUTEX_INITIALIZER;\n static pthread_cond_t finqcond = PTHREAD_COND_INITIALIZER;\n static Finalizer *finq;\n static int32 fingwait;\n@@ -284,7 +284,7 @@ sweep(void)\n \t\t\tsweepspan(s);\n }\n \n-static Lock gcsema = LOCK_INITIALIZER;\n+static pthread_mutex_t gcsema = PTHREAD_MUTEX_INITIALIZER;\n \n // Initialized from $GOGC.  GOGC=off means no gc.\n //\n@@ -327,8 +327,8 @@ runtime_gc(int32 force __attribute__ ((unused)))\n \tif(gcpercent < 0)\n \t\treturn;\n \n-\truntime_lock(&finqlock);\n-\truntime_lock(&gcsema);\n+\tpthread_mutex_lock(&finqlock);\n+\tpthread_mutex_lock(&gcsema);\n \tm->locks++;\t// disable gc during the mallocs in newproc\n \tt0 = runtime_nanotime();\n \truntime_stoptheworld();\n@@ -345,7 +345,7 @@ runtime_gc(int32 force __attribute__ ((unused)))\n \tmstats.pause_ns += t1 - t0;\n \tif(mstats.debuggc)\n \t\truntime_printf(\"pause %llu\\n\", (unsigned long long)t1-t0);\n-\truntime_unlock(&gcsema);\n+\tpthread_mutex_unlock(&gcsema);\n \truntime_starttheworld();\n \n \t// finqlock is still held.\n@@ -362,7 +362,7 @@ runtime_gc(int32 force __attribute__ ((unused)))\n \t\t}\n \t}\n \tm->locks--;\n-\truntime_unlock(&finqlock);\n+\tpthread_mutex_unlock(&finqlock);\n }\n \n static void\n@@ -373,16 +373,16 @@ runfinq(void* dummy)\n \tUSED(dummy);\n \n \tfor(;;) {\n-\t\truntime_lock(&finqlock);\n+\t\tpthread_mutex_lock(&finqlock);\n \t\tf = finq;\n \t\tfinq = nil;\n \t\tif(f == nil) {\n \t\t\tfingwait = 1;\n-\t\t\tpthread_cond_wait(&finqcond, &finqlock.mutex);\n-\t\t\truntime_unlock(&finqlock);\n+\t\t\tpthread_cond_wait(&finqcond, &finqlock);\n+\t\t\tpthread_mutex_unlock(&finqlock);\n \t\t\tcontinue;\n \t\t}\n-\t\truntime_unlock(&finqlock);\n+\t\tpthread_mutex_unlock(&finqlock);\n \t\tfor(; f; f=next) {\n \t\t\tvoid *params[1];\n "}, {"sha": "6bd4ef72724487be84ced77c99df0e5a2b7364ab", "filename": "libgo/runtime/mprof.goc", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4ad1c7a089e4bbb21dc6e9f97d4beef52577d6a/libgo%2Fruntime%2Fmprof.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4ad1c7a089e4bbb21dc6e9f97d4beef52577d6a/libgo%2Fruntime%2Fmprof.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmprof.goc?ref=a4ad1c7a089e4bbb21dc6e9f97d4beef52577d6a", "patch": "@@ -14,7 +14,7 @@ package runtime\n typedef struct __go_open_array Slice;\n \n // NOTE(rsc): Everything here could use cas if contention became an issue.\n-static Lock proflock = LOCK_INITIALIZER;\n+static Lock proflock;\n \n // Per-call-stack allocation information.\n // Lookup by hashing call stack into a linked-list hash table.\n@@ -185,6 +185,12 @@ found:\n \treturn nil;\n }\n \n+void\n+runtime_Mprof_Init()\n+{\n+\truntime_initlock(&proflock);\n+}\n+\n // Called by malloc to record a profiled block.\n void\n runtime_MProf_Malloc(void *p, uintptr size)"}, {"sha": "3027f0c42d26fcb959dde2a10370da4e7d408139", "filename": "libgo/runtime/runtime.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4ad1c7a089e4bbb21dc6e9f97d4beef52577d6a/libgo%2Fruntime%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4ad1c7a089e4bbb21dc6e9f97d4beef52577d6a/libgo%2Fruntime%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.h?ref=a4ad1c7a089e4bbb21dc6e9f97d4beef52577d6a", "patch": "@@ -13,6 +13,7 @@\n #include <stdlib.h>\n #include <string.h>\n #include <pthread.h>\n+#include <semaphore.h>\n \n #ifdef HAVE_SYS_MMAN_H\n #include <sys/mman.h>\n@@ -53,7 +54,8 @@ typedef\tstruct\tLock\t\tLock;\n \n struct\tLock\n {\n-\tpthread_mutex_t\tmutex;\n+\tuint32 key;\n+\tsem_t sem;\n };\n \n /* A Note.  */\n@@ -119,6 +121,7 @@ struct\tM\n \n void*\truntime_mal(uintptr);\n void\truntime_mallocinit(void);\n+void\truntime_initfintab(void);\n void\tsiginit(void);\n bool\t__go_sigsend(int32 sig);\n int64\truntime_nanotime(void);\n@@ -138,12 +141,10 @@ void\t__go_cachestats(void);\n  * as fast as spin locks (just a few user-level instructions),\n  * but on the contention path they sleep in the kernel.\n  */\n-#define\tLOCK_INITIALIZER\t{ PTHREAD_MUTEX_INITIALIZER }\n void\truntime_initlock(Lock*);\n void\truntime_lock(Lock*);\n void\truntime_unlock(Lock*);\n void\truntime_destroylock(Lock*);\n-bool\truntime_trylock(Lock*);\n \n void semacquire (uint32 *) asm (\"libgo_runtime.runtime.Semacquire\");\n void semrelease (uint32 *) asm (\"libgo_runtime.runtime.Semrelease\");\n@@ -178,7 +179,7 @@ void\truntime_addfinalizer(void*, void(*fn)(void*), const struct __go_func_type *\n void\truntime_walkfintab(void (*fn)(void*), void (*scan)(byte *, int64));\n #define runtime_mmap mmap\n #define runtime_munmap(p, s) munmap((p), (s))\n-#define cas(pval, old, new) __sync_bool_compare_and_swap (pval, old, new)\n+#define runtime_cas(pval, old, new) __sync_bool_compare_and_swap (pval, old, new)\n \n struct __go_func_type;\n void reflect_call(const struct __go_func_type *, const void *, _Bool, void **,"}, {"sha": "b5f2954bc8e045317338938e422315c2896ba60b", "filename": "libgo/runtime/sigqueue.goc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4ad1c7a089e4bbb21dc6e9f97d4beef52577d6a/libgo%2Fruntime%2Fsigqueue.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4ad1c7a089e4bbb21dc6e9f97d4beef52577d6a/libgo%2Fruntime%2Fsigqueue.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fsigqueue.goc?ref=a4ad1c7a089e4bbb21dc6e9f97d4beef52577d6a", "patch": "@@ -67,7 +67,7 @@ __go_sigsend(int32 s)\n \t\tmask = sig.mask;\n \t\tif(mask & bit)\n \t\t\tbreak;\t\t// signal already in queue\n-\t\tif(cas(&sig.mask, mask, mask|bit)) {\n+\t\tif(runtime_cas(&sig.mask, mask, mask|bit)) {\n \t\t\t// Added to queue.\n \t\t\t// Only send a wakeup for the first signal in each round.\n \t\t\tif(mask == 0)\n@@ -86,7 +86,7 @@ func Sigrecv() (m uint32) {\n \tnoteclear(&sig);\n \tfor(;;) {\n \t\tm = sig.mask;\n-\t\tif(cas(&sig.mask, m, 0))\n+\t\tif(runtime_cas(&sig.mask, m, 0))\n \t\t\tbreak;\n \t}\n }"}, {"sha": "99a0d68f03b575818fa2652912486fcd2b036302", "filename": "libgo/runtime/thread.c", "status": "modified", "additions": 48, "deletions": 13, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4ad1c7a089e4bbb21dc6e9f97d4beef52577d6a/libgo%2Fruntime%2Fthread.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4ad1c7a089e4bbb21dc6e9f97d4beef52577d6a/libgo%2Fruntime%2Fthread.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fthread.c?ref=a4ad1c7a089e4bbb21dc6e9f97d4beef52577d6a", "patch": "@@ -7,32 +7,67 @@\n void\n runtime_initlock(Lock *l)\n {\n-\tif(pthread_mutex_init(&l->mutex, NULL) != 0)\n-\t\truntime_throw(\"pthread_mutex_init failed\");\n+\tl->key = 0;\n+\tif(sem_init(&l->sem, 0, 0) != 0)\n+\t\truntime_throw(\"sem_init failed\");\n+}\n+\n+static uint32\n+runtime_xadd(uint32 volatile *val, int32 delta)\n+{\n+\tuint32 oval, nval;\n+\n+\tfor(;;){\n+\t\toval = *val;\n+\t\tnval = oval + delta;\n+\t\tif(runtime_cas(val, oval, nval))\n+\t\t\treturn nval;\n+\t}\n+}\n+\n+// noinline so that runtime_lock doesn't have to split the stack.\n+static void runtime_lock_full(Lock *l) __attribute__ ((noinline));\n+\n+static void\n+runtime_lock_full(Lock *l)\n+{\n+\tif(sem_wait(&l->sem) != 0)\n+\t\truntime_throw(\"sem_wait failed\");\n }\n \n void\n runtime_lock(Lock *l)\n {\n-\tif(pthread_mutex_lock(&l->mutex) != 0)\n-\t\truntime_throw(\"lock failed\");\n+\tif(m->locks < 0)\n+\t\truntime_throw(\"lock count\");\n+\tm->locks++;\n+\n+\tif(runtime_xadd(&l->key, 1) > 1)\t// someone else has it; wait\n+\t\truntime_lock_full(l);\n }\n \n-void\n-runtime_unlock(Lock *l)\n+static void runtime_unlock_full(Lock *l) __attribute__ ((noinline));\n+\n+static void\n+runtime_unlock_full(Lock *l)\n {\n-\tif(pthread_mutex_unlock(&l->mutex) != 0)\n-\t\truntime_throw(\"unlock failed\");\n+\tif(sem_post(&l->sem) != 0)\n+\t\truntime_throw(\"sem_post failed\");\n }\n \n void\n-runtime_destroylock(Lock *l)\n+runtime_unlock(Lock *l)\n {\n-\tpthread_mutex_destroy(&l->mutex);\n+\tm->locks--;\n+\tif(m->locks < 0)\n+\t\truntime_throw(\"lock count\");\n+\n+\tif(runtime_xadd(&l->key, -1) > 0)\t// someone else is waiting\n+\t\truntime_unlock_full(l);\n }\n \n-bool\n-runtime_trylock(Lock *l)\n+void\n+runtime_destroylock(Lock *l)\n {\n-\treturn pthread_mutex_trylock(&l->mutex) == 0;\n+\tsem_destroy(&l->sem);\n }"}]}