{"sha": "605b64251c78f29da32ed807413971339f27d13b", "node_id": "C_kwDOANBUbNoAKDYwNWI2NDI1MWM3OGYyOWRhMzJlZDgwNzQxMzk3MTMzOWYyN2QxM2I", "commit": {"author": {"name": "liuhongt", "email": "hongtao.liu@intel.com", "date": "2022-07-07T06:33:32Z"}, "committer": {"name": "liuhongt", "email": "hongtao.liu@intel.com", "date": "2022-07-22T01:39:16Z"}, "message": "Extend 16/32-bit vector bit_op patterns with (m,0,i) alternative.\n\nAnd split it after reload.\n\ngcc/ChangeLog:\n\n\tPR target/106038\n\t* config/i386/mmx.md (<code><mode>3): New define_expand, it's\n\toriginal \"<code><mode>3\".\n\t(*<code><mode>3): New define_insn, it's original\n\t\"<code><mode>3\" be extended to handle memory and immediate\n\toperand with ix86_binary_operator_ok. Also adjust define_split\n\tafter it.\n\t(mmxinsnmode): New mode attribute.\n\t(*mov<mode>_imm): Refactor with mmxinsnmode.\n\t* config/i386/predicates.md\n\t(register_or_x86_64_const_vector_operand): New predicate.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/i386/pr106038-1.c: New test.", "tree": {"sha": "5f7418720a0ffc3fe3767ff17d500eeac95ae67d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f7418720a0ffc3fe3767ff17d500eeac95ae67d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/605b64251c78f29da32ed807413971339f27d13b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/605b64251c78f29da32ed807413971339f27d13b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/605b64251c78f29da32ed807413971339f27d13b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/605b64251c78f29da32ed807413971339f27d13b/comments", "author": {"login": "algebra84", "id": 22926165, "node_id": "MDQ6VXNlcjIyOTI2MTY1", "avatar_url": "https://avatars.githubusercontent.com/u/22926165?v=4", "gravatar_id": "", "url": "https://api.github.com/users/algebra84", "html_url": "https://github.com/algebra84", "followers_url": "https://api.github.com/users/algebra84/followers", "following_url": "https://api.github.com/users/algebra84/following{/other_user}", "gists_url": "https://api.github.com/users/algebra84/gists{/gist_id}", "starred_url": "https://api.github.com/users/algebra84/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/algebra84/subscriptions", "organizations_url": "https://api.github.com/users/algebra84/orgs", "repos_url": "https://api.github.com/users/algebra84/repos", "events_url": "https://api.github.com/users/algebra84/events{/privacy}", "received_events_url": "https://api.github.com/users/algebra84/received_events", "type": "User", "site_admin": false}, "committer": {"login": "algebra84", "id": 22926165, "node_id": "MDQ6VXNlcjIyOTI2MTY1", "avatar_url": "https://avatars.githubusercontent.com/u/22926165?v=4", "gravatar_id": "", "url": "https://api.github.com/users/algebra84", "html_url": "https://github.com/algebra84", "followers_url": "https://api.github.com/users/algebra84/followers", "following_url": "https://api.github.com/users/algebra84/following{/other_user}", "gists_url": "https://api.github.com/users/algebra84/gists{/gist_id}", "starred_url": "https://api.github.com/users/algebra84/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/algebra84/subscriptions", "organizations_url": "https://api.github.com/users/algebra84/orgs", "repos_url": "https://api.github.com/users/algebra84/repos", "events_url": "https://api.github.com/users/algebra84/events{/privacy}", "received_events_url": "https://api.github.com/users/algebra84/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "45e0683d99cf5396b2e8232c3986767cfbb0dd34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45e0683d99cf5396b2e8232c3986767cfbb0dd34", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45e0683d99cf5396b2e8232c3986767cfbb0dd34"}], "stats": {"total": 101, "additions": 70, "deletions": 31}, "files": [{"sha": "dda4b43f5c1d37119f85431ee1fe08e73661f735", "filename": "gcc/config/i386/mmx.md", "status": "modified", "additions": 39, "deletions": 31, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/605b64251c78f29da32ed807413971339f27d13b/gcc%2Fconfig%2Fi386%2Fmmx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/605b64251c78f29da32ed807413971339f27d13b/gcc%2Fconfig%2Fi386%2Fmmx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fmmx.md?ref=605b64251c78f29da32ed807413971339f27d13b", "patch": "@@ -86,6 +86,14 @@\n   [(V8QI \"b\") (V4QI \"b\") (V2QI \"b\")\n    (V4HI \"w\") (V2HI \"w\") (V2SI \"d\") (V1DI \"q\")])\n \n+;; Mapping to same size integral mode.\n+(define_mode_attr mmxinsnmode\n+  [(V8QI \"DI\") (V4QI \"SI\") (V2QI \"HI\")\n+   (V4HI \"DI\") (V2HI \"SI\")\n+   (V2SI \"DI\")\n+   (V4HF \"DI\") (V2HF \"SI\")\n+   (V2SF \"DI\")])\n+\n (define_mode_attr mmxdoublemode\n   [(V8QI \"V8HI\") (V4HI \"V4SI\")])\n \n@@ -350,22 +358,7 @@\n   HOST_WIDE_INT val = ix86_convert_const_vector_to_integer (operands[1],\n \t\t\t\t\t\t\t    <MODE>mode);\n   operands[1] = GEN_INT (val);\n-  machine_mode mode;\n-  switch (GET_MODE_SIZE (<MODE>mode))\n-    {\n-    case 2:\n-      mode = HImode;\n-      break;\n-    case 4:\n-      mode = SImode;\n-      break;\n-    case 8:\n-      mode = DImode;\n-      break;\n-    default:\n-      gcc_unreachable ();\n-    }\n-  operands[0] = lowpart_subreg (mode, operands[0], <MODE>mode);\n+  operands[0] = lowpart_subreg (<mmxinsnmode>mode, operands[0], <MODE>mode);\n })\n \n ;; For TARGET_64BIT we always round up to 8 bytes.\n@@ -2974,33 +2967,48 @@\n    (set_attr \"type\" \"mmxadd,sselog,sselog,sselog\")\n    (set_attr \"mode\" \"DI,TI,TI,TI\")])\n \n-(define_insn \"<code><mode>3\"\n-  [(set (match_operand:VI_16_32 0 \"register_operand\" \"=?r,x,x,v\")\n+(define_expand \"<code><mode>3\"\n+  [(set (match_operand:VI_16_32 0 \"nonimmediate_operand\")\n         (any_logic:VI_16_32\n-\t  (match_operand:VI_16_32 1 \"register_operand\" \"%0,0,x,v\")\n-\t  (match_operand:VI_16_32 2 \"register_operand\" \"r,x,x,v\")))\n-   (clobber (reg:CC FLAGS_REG))]\n+\t  (match_operand:VI_16_32 1 \"nonimmediate_operand\")\n+\t  (match_operand:VI_16_32 2 \"nonimmediate_or_x86_64_const_vector_operand\")))]\n   \"\"\n+  \"ix86_expand_binary_operator (<CODE>, <MODE>mode, operands); DONE;\")\n+\n+(define_insn \"*<code><mode>3\"\n+  [(set (match_operand:VI_16_32 0 \"nonimmediate_operand\" \"=?r,m,x,x,v\")\n+        (any_logic:VI_16_32\n+\t  (match_operand:VI_16_32 1 \"nonimmediate_operand\" \"%0,0,0,x,v\")\n+\t  (match_operand:VI_16_32 2 \"nonimmediate_or_x86_64_const_vector_operand\" \"r,i,x,x,v\")))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"ix86_binary_operator_ok (<CODE>, <MODE>mode, operands)\"\n   \"#\"\n-  [(set_attr \"isa\" \"*,sse2_noavx,avx,avx512vl\")\n-   (set_attr \"type\" \"alu,sselog,sselog,sselog\")\n-   (set_attr \"mode\" \"SI,TI,TI,TI\")])\n+  [(set_attr \"isa\" \"*,*,sse2_noavx,avx,avx512vl\")\n+   (set_attr \"type\" \"alu,alu,sselog,sselog,sselog\")\n+   (set_attr \"mode\" \"SI,SI,TI,TI,TI\")])\n \n (define_split\n-  [(set (match_operand:VI_16_32 0 \"general_reg_operand\")\n+  [(set (match_operand:VI_16_32 0 \"nonimmediate_gr_operand\")\n         (any_logic:VI_16_32\n-\t  (match_operand:VI_16_32 1 \"general_reg_operand\")\n-\t  (match_operand:VI_16_32 2 \"general_reg_operand\")))\n+\t  (match_operand:VI_16_32 1 \"nonimmediate_gr_operand\")\n+\t  (match_operand:VI_16_32 2 \"reg_or_const_vector_operand\")))\n    (clobber (reg:CC FLAGS_REG))]\n   \"reload_completed\"\n   [(parallel\n      [(set (match_dup 0)\n-\t   (any_logic:SI (match_dup 1) (match_dup 2)))\n+\t   (any_logic:<mmxinsnmode> (match_dup 1) (match_dup 2)))\n       (clobber (reg:CC FLAGS_REG))])]\n {\n-  operands[2] = lowpart_subreg (SImode, operands[2], <MODE>mode);\n-  operands[1] = lowpart_subreg (SImode, operands[1], <MODE>mode);\n-  operands[0] = lowpart_subreg (SImode, operands[0], <MODE>mode);\n+  if (!register_operand (operands[2], <MODE>mode))\n+    {\n+      HOST_WIDE_INT val = ix86_convert_const_vector_to_integer (operands[2],\n+\t\t\t\t\t\t\t\t<MODE>mode);\n+      operands[2] = GEN_INT (val);\n+    }\n+  else\n+    operands[2] = lowpart_subreg (<mmxinsnmode>mode, operands[2], <MODE>mode);\n+  operands[1] = lowpart_subreg (<mmxinsnmode>mode, operands[1], <MODE>mode);\n+  operands[0] = lowpart_subreg (<mmxinsnmode>mode, operands[0], <MODE>mode);\n })\n \n (define_split"}, {"sha": "064596d9594dd01aa0d757ccad860aae0cf8303f", "filename": "gcc/config/i386/predicates.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/605b64251c78f29da32ed807413971339f27d13b/gcc%2Fconfig%2Fi386%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/605b64251c78f29da32ed807413971339f27d13b/gcc%2Fconfig%2Fi386%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpredicates.md?ref=605b64251c78f29da32ed807413971339f27d13b", "patch": "@@ -1209,6 +1209,10 @@\n   return trunc_int_for_mode (val, SImode) == val;\n })\n \n+(define_predicate \"nonimmediate_or_x86_64_const_vector_operand\"\n+  (ior (match_operand 0 \"nonimmediate_operand\")\n+       (match_operand 0 \"x86_64_const_vector_operand\")))\n+\n ;; Return true when OP is nonimmediate or standard SSE constant.\n (define_predicate \"nonimmediate_or_sse_const_operand\"\n   (ior (match_operand 0 \"nonimmediate_operand\")"}, {"sha": "bb52385c8a5ee74cf639506e899a7879f4a71adf", "filename": "gcc/testsuite/gcc.target/i386/pr106038-1.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/605b64251c78f29da32ed807413971339f27d13b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr106038-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/605b64251c78f29da32ed807413971339f27d13b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr106038-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr106038-1.c?ref=605b64251c78f29da32ed807413971339f27d13b", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-msse2 -O2\" } */\n+/* { dg-final { scan-assembler-not \"xmm\" } } */\n+\n+void\n+foo3 (char* a, char* __restrict b)\n+{\n+  a[0] &= 1;\n+  a[1] &= 2;\n+  a[2] &= 3;\n+  a[3] &= 3;\n+}\n+\n+void\n+foo4 (char* a, char* __restrict b)\n+{\n+  a[0] &= 1;\n+  a[1] &= 2;\n+}\n+\n+\n+void\n+foo1 (short* a, short* __restrict b)\n+{\n+  a[0] &= 1;\n+  a[1] &= 2;\n+}"}]}