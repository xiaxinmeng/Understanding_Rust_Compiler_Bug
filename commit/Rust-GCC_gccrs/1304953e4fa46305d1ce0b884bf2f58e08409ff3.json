{"sha": "1304953e4fa46305d1ce0b884bf2f58e08409ff3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTMwNDk1M2U0ZmE0NjMwNWQxY2UwYjg4NGJmMmY1OGUwODQwOWZmMw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2014-11-12T12:28:06Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2014-11-12T12:28:06Z"}, "message": "re PR c/59708 (clang-compatible checked arithmetic builtins)\n\n\tPR c/59708\n\t* builtin-attrs.def (ATTR_NOTHROW_TYPEGENERIC_LEAF): New attribute.\n\t* builtins.c (fold_builtin_arith_overflow): New function.\n\t(fold_builtin_3): Use it.\n\t* builtins.def (BUILT_IN_ADD_OVERFLOW, BUILT_IN_SUB_OVERFLOW,\n\tBUILT_IN_MUL_OVERFLOW, BUILT_IN_SADD_OVERFLOW, BUILT_IN_SADDL_OVERFLOW,\n\tBUILT_IN_SADDLL_OVERFLOW, BUILT_IN_SSUB_OVERFLOW,\n\tBUILT_IN_SSUBL_OVERFLOW, BUILT_IN_SSUBLL_OVERFLOW,\n\tBUILT_IN_SMUL_OVERFLOW, BUILT_IN_SMULL_OVERFLOW,\n\tBUILT_IN_SMULLL_OVERFLOW, BUILT_IN_UADDL_OVERFLOW,\n\tBUILT_IN_UADDLL_OVERFLOW, BUILT_IN_USUB_OVERFLOW,\n\tBUILT_IN_USUBL_OVERFLOW, BUILT_IN_USUBLL_OVERFLOW,\n\tBUILT_IN_UMUL_OVERFLOW, BUILT_IN_UMULL_OVERFLOW,\n\tBUILT_IN_UMULLL_OVERFLOW): New built-in functions.\n\t* builtin-types.def (BT_PTR_UINT, BT_PTR_ULONG, BT_PTR_LONGLONG,\n\tBT_FN_BOOL_INT_INT_INTPTR, BT_FN_BOOL_LONG_LONG_LONGPTR,\n\tBT_FN_BOOL_LONGLONG_LONGLONG_LONGLONGPTR, BT_FN_BOOL_UINT_UINT_UINTPTR,\n\tBT_FN_BOOL_ULONG_ULONG_ULONGPTR,\n\tBT_FN_BOOL_ULONGLONG_ULONGLONG_ULONGLONGPTR, BT_FN_BOOL_VAR): New.\n\t* expr.c (write_complex_part): Remove prototype, no longer static.\n\t* expr.h (write_complex_part): New prototype.\n\t* function.c (aggregate_value_p): For internal functions return 0.\n\t* gimple-fold.c (arith_overflowed_p): New functions.\n\t(gimple_fold_call): Fold {ADD,SUB,MUL}_OVERFLOW internal calls.\n\t* gimple-fold.h (arith_overflowed_p): New prototype.\n\t* tree-ssa-dce.c: Include tree-ssa-propagate.h and gimple-fold.h.\n\t(find_non_realpart_uses, maybe_optimize_arith_overflow): New\n\tfunctions.\n\t(eliminate_unnecessary_stmts): Transform {ADD,SUB,MUL}_OVERFLOW\n\tinto COMPLEX_CST/COMPLEX_EXPR if IMAGPART_EXPR of the result is\n\tnever used.\n\t* gimplify.c (gimplify_call_expr): Handle gimplification of\n\tinternal calls with lhs.\n\t* internal-fn.c (get_range_pos_neg, get_min_precision,\n\texpand_arith_overflow_result_store): New functions.\n\t(ubsan_expand_si_overflow_addsub_check): Renamed to ...\n\t(expand_addsub_overflow): ... this.  Add LOC, LHS, ARG0, ARG1,\n\tUNSR_P, UNS0_P, UNS1_P, IS_UBSAN arguments, remove STMT argument.\n\tHandle ADD_OVERFLOW and SUB_OVERFLOW expansion.\n\t(ubsan_expand_si_overflow_neg_check): Renamed to ...\n\t(expand_neg_overflow): ... this.  Add LOC, LHS, ARG1, IS_UBSAN\n\targuments, remove STMT argument.  Handle SUB_OVERFLOW with\n\t0 as first argument expansion.\n\t(ubsan_expand_si_overflow_mul_check): Renamed to ...\n\t(expand_mul_overflow): ... this.  Add LOC, LHS, ARG0, ARG1,\n\tUNSR_P, UNS0_P, UNS1_P, IS_UBSAN arguments, remove STMT argument.\n\tHandle MUL_OVERFLOW expansion.\n\t(expand_UBSAN_CHECK_ADD): Use expand_addsub_overflow, prepare\n\targuments for it.\n\t(expand_UBSAN_CHECK_SUB): Use expand_addsub_overflow or\n\texpand_neg_overflow, prepare arguments for it.\n\t(expand_UBSAN_CHECK_MUL): Use expand_mul_overflow, prepare arguments\n\tfor it.\n\t(expand_arith_overflow, expand_ADD_OVERFLOW, expand_SUB_OVERFLOW,\n\texpand_MUL_OVERFLOW): New functions.\n\t* internal-fn.def (ADD_OVERFLOW, SUB_OVERFLOW, MUL_OVERFLOW): New\n\tinternal functions.\n\t* tree-vrp.c (check_for_binary_op_overflow): New function.\n\t(extract_range_basic): Handle {REAL,IMAG}PART_EXPR if the operand\n\tis SSA_NAME set by {ADD,SUB,MUL}_OVERFLOW internal functions.\n\t(simplify_internal_call_using_ranges): Handle {ADD,SUB,MUL}_OVERFLOW\n\tinternal functions.\n\t* optabs.def (umulv4_optab): New optab.\n\t* config/i386/i386.md (umulv<mode>4, <u>mulvqi4): New define_expands.\n\t(*umulv<mode>4, *<u>mulvqi4): New define_insns.\n\t* doc/extend.texi (Integer Overflow Builtins): Document\n\t__builtin_*_overflow.\nc-family/\n\t* c-common.c (check_builtin_function_arguments): Handle\n\tBUILT_IN_{ADD,SUB,MUL}_OVERFLOW.\ntestsuite/\n\t* c-c++-common/builtin-arith-overflow-1.c: New test.\n\t* c-c++-common/torture/builtin-arith-overflow-10.c: New test.\n\t* c-c++-common/torture/builtin-arith-overflow-11.c: New test.\n\t* c-c++-common/torture/builtin-arith-overflow-12.c: New test.\n\t* c-c++-common/torture/builtin-arith-overflow-12.h: New file.\n\t* c-c++-common/torture/builtin-arith-overflow-13.c: New test.\n\t* c-c++-common/torture/builtin-arith-overflow-14.c: New test.\n\t* c-c++-common/torture/builtin-arith-overflow-15.c: New test.\n\t* c-c++-common/torture/builtin-arith-overflow-16.c: New test.\n\t* c-c++-common/torture/builtin-arith-overflow-17.c: New test.\n\t* c-c++-common/torture/builtin-arith-overflow-18.c: New test.\n\t* c-c++-common/torture/builtin-arith-overflow-1.c: New test.\n\t* c-c++-common/torture/builtin-arith-overflow-1.h: New file.\n\t* c-c++-common/torture/builtin-arith-overflow-2.c: New test.\n\t* c-c++-common/torture/builtin-arith-overflow-3.c: New test.\n\t* c-c++-common/torture/builtin-arith-overflow-4.c: New test.\n\t* c-c++-common/torture/builtin-arith-overflow-5.c: New test.\n\t* c-c++-common/torture/builtin-arith-overflow-6.c: New test.\n\t* c-c++-common/torture/builtin-arith-overflow-7.c: New test.\n\t* c-c++-common/torture/builtin-arith-overflow-8.c: New test.\n\t* c-c++-common/torture/builtin-arith-overflow-9.c: New test.\n\t* c-c++-common/torture/builtin-arith-overflow.h: New file.\n\t* gcc.dg/builtin-arith-overflow-1.c: New test.\n\t* gcc.dg/builtin-arith-overflow-2.c: New test.\n\nFrom-SVN: r217415", "tree": {"sha": "551c242f138ac032ded6f0171ee39700e6ea032e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/551c242f138ac032ded6f0171ee39700e6ea032e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1304953e4fa46305d1ce0b884bf2f58e08409ff3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1304953e4fa46305d1ce0b884bf2f58e08409ff3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1304953e4fa46305d1ce0b884bf2f58e08409ff3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1304953e4fa46305d1ce0b884bf2f58e08409ff3/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6a3cbe90926bbe62fcbce85dc735cbf077fd0f0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a3cbe90926bbe62fcbce85dc735cbf077fd0f0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a3cbe90926bbe62fcbce85dc735cbf077fd0f0b"}], "stats": {"total": 3401, "additions": 3082, "deletions": 319}, "files": [{"sha": "dab57d8420ad1422574db2432a0209183ead2d50", "filename": "gcc/ChangeLog", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1304953e4fa46305d1ce0b884bf2f58e08409ff3", "patch": "@@ -1,3 +1,73 @@\n+2014-11-12  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c/59708\n+\t* builtin-attrs.def (ATTR_NOTHROW_TYPEGENERIC_LEAF): New attribute.\n+\t* builtins.c (fold_builtin_arith_overflow): New function.\n+\t(fold_builtin_3): Use it.\n+\t* builtins.def (BUILT_IN_ADD_OVERFLOW, BUILT_IN_SUB_OVERFLOW,\n+\tBUILT_IN_MUL_OVERFLOW, BUILT_IN_SADD_OVERFLOW, BUILT_IN_SADDL_OVERFLOW,\n+\tBUILT_IN_SADDLL_OVERFLOW, BUILT_IN_SSUB_OVERFLOW,\n+\tBUILT_IN_SSUBL_OVERFLOW, BUILT_IN_SSUBLL_OVERFLOW,\n+\tBUILT_IN_SMUL_OVERFLOW, BUILT_IN_SMULL_OVERFLOW,\n+\tBUILT_IN_SMULLL_OVERFLOW, BUILT_IN_UADDL_OVERFLOW,\n+\tBUILT_IN_UADDLL_OVERFLOW, BUILT_IN_USUB_OVERFLOW,\n+\tBUILT_IN_USUBL_OVERFLOW, BUILT_IN_USUBLL_OVERFLOW,\n+\tBUILT_IN_UMUL_OVERFLOW, BUILT_IN_UMULL_OVERFLOW,\n+\tBUILT_IN_UMULLL_OVERFLOW): New built-in functions.\n+\t* builtin-types.def (BT_PTR_UINT, BT_PTR_ULONG, BT_PTR_LONGLONG,\n+\tBT_FN_BOOL_INT_INT_INTPTR, BT_FN_BOOL_LONG_LONG_LONGPTR,\n+\tBT_FN_BOOL_LONGLONG_LONGLONG_LONGLONGPTR, BT_FN_BOOL_UINT_UINT_UINTPTR,\n+\tBT_FN_BOOL_ULONG_ULONG_ULONGPTR,\n+\tBT_FN_BOOL_ULONGLONG_ULONGLONG_ULONGLONGPTR, BT_FN_BOOL_VAR): New.\n+\t* expr.c (write_complex_part): Remove prototype, no longer static.\n+\t* expr.h (write_complex_part): New prototype.\n+\t* function.c (aggregate_value_p): For internal functions return 0.\n+\t* gimple-fold.c (arith_overflowed_p): New functions.\n+\t(gimple_fold_call): Fold {ADD,SUB,MUL}_OVERFLOW internal calls.\n+\t* gimple-fold.h (arith_overflowed_p): New prototype.\n+\t* tree-ssa-dce.c: Include tree-ssa-propagate.h and gimple-fold.h.\n+\t(find_non_realpart_uses, maybe_optimize_arith_overflow): New\n+\tfunctions.\n+\t(eliminate_unnecessary_stmts): Transform {ADD,SUB,MUL}_OVERFLOW\n+\tinto COMPLEX_CST/COMPLEX_EXPR if IMAGPART_EXPR of the result is\n+\tnever used.\n+\t* gimplify.c (gimplify_call_expr): Handle gimplification of\n+\tinternal calls with lhs.\n+\t* internal-fn.c (get_range_pos_neg, get_min_precision,\n+\texpand_arith_overflow_result_store): New functions.\n+\t(ubsan_expand_si_overflow_addsub_check): Renamed to ...\n+\t(expand_addsub_overflow): ... this.  Add LOC, LHS, ARG0, ARG1,\n+\tUNSR_P, UNS0_P, UNS1_P, IS_UBSAN arguments, remove STMT argument.\n+\tHandle ADD_OVERFLOW and SUB_OVERFLOW expansion.\n+\t(ubsan_expand_si_overflow_neg_check): Renamed to ...\n+\t(expand_neg_overflow): ... this.  Add LOC, LHS, ARG1, IS_UBSAN\n+\targuments, remove STMT argument.  Handle SUB_OVERFLOW with\n+\t0 as first argument expansion.\n+\t(ubsan_expand_si_overflow_mul_check): Renamed to ...\n+\t(expand_mul_overflow): ... this.  Add LOC, LHS, ARG0, ARG1,\n+\tUNSR_P, UNS0_P, UNS1_P, IS_UBSAN arguments, remove STMT argument.\n+\tHandle MUL_OVERFLOW expansion.\n+\t(expand_UBSAN_CHECK_ADD): Use expand_addsub_overflow, prepare\n+\targuments for it.\n+\t(expand_UBSAN_CHECK_SUB): Use expand_addsub_overflow or\n+\texpand_neg_overflow, prepare arguments for it.\n+\t(expand_UBSAN_CHECK_MUL): Use expand_mul_overflow, prepare arguments\n+\tfor it.\n+\t(expand_arith_overflow, expand_ADD_OVERFLOW, expand_SUB_OVERFLOW,\n+\texpand_MUL_OVERFLOW): New functions.\n+\t* internal-fn.def (ADD_OVERFLOW, SUB_OVERFLOW, MUL_OVERFLOW): New\n+\tinternal functions.\n+\t* tree-vrp.c (check_for_binary_op_overflow): New function.\n+\t(extract_range_basic): Handle {REAL,IMAG}PART_EXPR if the operand\n+\tis SSA_NAME set by {ADD,SUB,MUL}_OVERFLOW internal functions.\n+\t(simplify_internal_call_using_ranges): Handle {ADD,SUB,MUL}_OVERFLOW\n+\tinternal functions.\n+\t* optabs.def (umulv4_optab): New optab.\n+\t* config/i386/i386.md (umulv<mode>4, <u>mulvqi4): New define_expands.\n+\t(*umulv<mode>4, *<u>mulvqi4): New define_insns.\n+\t* doc/extend.texi (Integer Overflow Builtins): Document\n+\t__builtin_*_overflow.\n+\n 2014-11-12  Richard Biener  <rguenther@suse.de>\n \n \t* genmatch.c (capture_info::capture_info): Add missing"}, {"sha": "9c05a949039a6baf6207e4b2b677f2c164600a3f", "filename": "gcc/builtin-attrs.def", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Fbuiltin-attrs.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Fbuiltin-attrs.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltin-attrs.def?ref=1304953e4fa46305d1ce0b884bf2f58e08409ff3", "patch": "@@ -178,6 +178,9 @@ DEF_ATTR_TREE_LIST (ATTR_NOTHROW_NONNULL_4, ATTR_NONNULL, ATTR_LIST_4, \\\n /* Nothrow functions whose fifth parameter is a nonnull pointer.  */\n DEF_ATTR_TREE_LIST (ATTR_NOTHROW_NONNULL_5, ATTR_NONNULL, ATTR_LIST_5, \\\n \t\t\tATTR_NOTHROW_LIST)\n+/* Nothrow leaf functions which are type-generic.  */\n+DEF_ATTR_TREE_LIST (ATTR_NOTHROW_TYPEGENERIC_LEAF, ATTR_TYPEGENERIC, ATTR_NULL, \\\n+\t\t\tATTR_NOTHROW_LEAF_LIST)\n /* Nothrow const functions whose pointer parameter(s) are all nonnull.  */\n DEF_ATTR_TREE_LIST (ATTR_CONST_NOTHROW_NONNULL, ATTR_CONST, ATTR_NULL, \\\n \t\t\tATTR_NOTHROW_NONNULL)"}, {"sha": "a8ba0ba12e0cd75fb0db609b30f126140dcfac8d", "filename": "gcc/builtin-types.def", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Fbuiltin-types.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Fbuiltin-types.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltin-types.def?ref=1304953e4fa46305d1ce0b884bf2f58e08409ff3", "patch": "@@ -126,7 +126,10 @@ DEF_PRIMITIVE_TYPE (BT_I16, builtin_type_for_size (BITS_PER_UNIT*16, 1))\n DEF_PRIMITIVE_TYPE (BT_BND, pointer_bounds_type_node)\n \n DEF_POINTER_TYPE (BT_PTR_CONST_STRING, BT_CONST_STRING)\n+DEF_POINTER_TYPE (BT_PTR_UINT, BT_UINT)\n DEF_POINTER_TYPE (BT_PTR_LONG, BT_LONG)\n+DEF_POINTER_TYPE (BT_PTR_ULONG, BT_ULONG)\n+DEF_POINTER_TYPE (BT_PTR_LONGLONG, BT_LONGLONG)\n DEF_POINTER_TYPE (BT_PTR_ULONGLONG, BT_ULONGLONG)\n DEF_POINTER_TYPE (BT_PTR_PTR, BT_PTR)\n \n@@ -435,6 +438,18 @@ DEF_FUNCTION_TYPE_3 (BT_FN_VOID_VPTR_I16_INT, BT_VOID, BT_VOLATILE_PTR, BT_I16,\n DEF_FUNCTION_TYPE_3 (BT_FN_INT_PTRPTR_SIZE_SIZE, BT_INT, BT_PTR_PTR, BT_SIZE, BT_SIZE)\n DEF_FUNCTION_TYPE_3 (BT_FN_PTR_CONST_PTR_CONST_PTR_SIZE, BT_PTR, BT_CONST_PTR, BT_CONST_PTR, BT_SIZE)\n DEF_FUNCTION_TYPE_3 (BT_FN_VOID_CONST_PTR_BND_CONST_PTR, BT_VOID, BT_CONST_PTR, BT_BND, BT_CONST_PTR)\n+DEF_FUNCTION_TYPE_3 (BT_FN_BOOL_INT_INT_INTPTR, BT_BOOL, BT_INT, BT_INT,\n+\t\t     BT_INT_PTR)\n+DEF_FUNCTION_TYPE_3 (BT_FN_BOOL_LONG_LONG_LONGPTR, BT_BOOL, BT_LONG, BT_LONG,\n+\t\t     BT_PTR_LONG)\n+DEF_FUNCTION_TYPE_3 (BT_FN_BOOL_LONGLONG_LONGLONG_LONGLONGPTR, BT_BOOL,\n+\t\t     BT_LONGLONG, BT_LONGLONG, BT_PTR_LONGLONG)\n+DEF_FUNCTION_TYPE_3 (BT_FN_BOOL_UINT_UINT_UINTPTR, BT_BOOL, BT_UINT, BT_UINT,\n+\t\t     BT_PTR_UINT)\n+DEF_FUNCTION_TYPE_3 (BT_FN_BOOL_ULONG_ULONG_ULONGPTR, BT_BOOL, BT_ULONG,\n+\t\t     BT_ULONG, BT_PTR_ULONG)\n+DEF_FUNCTION_TYPE_3 (BT_FN_BOOL_ULONGLONG_ULONGLONG_ULONGLONGPTR, BT_BOOL,\n+\t\t     BT_ULONGLONG, BT_ULONGLONG, BT_PTR_ULONGLONG)\n \n DEF_FUNCTION_TYPE_4 (BT_FN_SIZE_CONST_PTR_SIZE_SIZE_FILEPTR,\n \t\t     BT_SIZE, BT_CONST_PTR, BT_SIZE, BT_SIZE, BT_FILEPTR)\n@@ -532,6 +547,7 @@ DEF_FUNCTION_TYPE_8 (BT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_BOOL_UINT_PTR,\n DEF_FUNCTION_TYPE_VAR_0 (BT_FN_VOID_VAR, BT_VOID)\n DEF_FUNCTION_TYPE_VAR_0 (BT_FN_INT_VAR, BT_INT)\n DEF_FUNCTION_TYPE_VAR_0 (BT_FN_PTR_VAR, BT_PTR)\n+DEF_FUNCTION_TYPE_VAR_0 (BT_FN_BOOL_VAR, BT_BOOL)\n \n DEF_FUNCTION_TYPE_VAR_1 (BT_FN_VOID_VALIST_REF_VAR,\n \t\t\t BT_VOID, BT_VALIST_REF)"}, {"sha": "1cd65edb194198f17e1c5005dbe4444140694086", "filename": "gcc/builtins.c", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=1304953e4fa46305d1ce0b884bf2f58e08409ff3", "patch": "@@ -9724,6 +9724,62 @@ fold_builtin_unordered_cmp (location_t loc, tree fndecl, tree arg0, tree arg1,\n \t\t      fold_build2_loc (loc, code, type, arg0, arg1));\n }\n \n+/* Fold __builtin_{,s,u}{add,sub,mul}{,l,ll}_overflow, either into normal\n+   arithmetics if it can never overflow, or into internal functions that\n+   return both result of arithmetics and overflowed boolean flag in\n+   a complex integer result, or some other check for overflow.  */\n+\n+static tree\n+fold_builtin_arith_overflow (location_t loc, enum built_in_function fcode,\n+\t\t\t     tree arg0, tree arg1, tree arg2)\n+{\n+  enum internal_fn ifn = IFN_LAST;\n+  tree type = TREE_TYPE (TREE_TYPE (arg2));\n+  tree mem_arg2 = build_fold_indirect_ref_loc (loc, arg2);\n+  switch (fcode)\n+    {\n+    case BUILT_IN_ADD_OVERFLOW:\n+    case BUILT_IN_SADD_OVERFLOW:\n+    case BUILT_IN_SADDL_OVERFLOW:\n+    case BUILT_IN_SADDLL_OVERFLOW:\n+    case BUILT_IN_UADD_OVERFLOW:\n+    case BUILT_IN_UADDL_OVERFLOW:\n+    case BUILT_IN_UADDLL_OVERFLOW:\n+      ifn = IFN_ADD_OVERFLOW;\n+      break;\n+    case BUILT_IN_SUB_OVERFLOW:\n+    case BUILT_IN_SSUB_OVERFLOW:\n+    case BUILT_IN_SSUBL_OVERFLOW:\n+    case BUILT_IN_SSUBLL_OVERFLOW:\n+    case BUILT_IN_USUB_OVERFLOW:\n+    case BUILT_IN_USUBL_OVERFLOW:\n+    case BUILT_IN_USUBLL_OVERFLOW:\n+      ifn = IFN_SUB_OVERFLOW;\n+      break;\n+    case BUILT_IN_MUL_OVERFLOW:\n+    case BUILT_IN_SMUL_OVERFLOW:\n+    case BUILT_IN_SMULL_OVERFLOW:\n+    case BUILT_IN_SMULLL_OVERFLOW:\n+    case BUILT_IN_UMUL_OVERFLOW:\n+    case BUILT_IN_UMULL_OVERFLOW:\n+    case BUILT_IN_UMULLL_OVERFLOW:\n+      ifn = IFN_MUL_OVERFLOW;\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+  tree ctype = build_complex_type (type);\n+  tree call = build_call_expr_internal_loc (loc, ifn, ctype,\n+\t\t\t\t\t    2, arg0, arg1);\n+  tree tgt = save_expr (call);\n+  tree intres = build1_loc (loc, REALPART_EXPR, type, tgt);\n+  tree ovfres = build1_loc (loc, IMAGPART_EXPR, type, tgt);\n+  ovfres = fold_convert_loc (loc, boolean_type_node, ovfres);\n+  tree store\n+    = fold_build2_loc (loc, MODIFY_EXPR, void_type_node, mem_arg2, intres);\n+  return build2_loc (loc, COMPOUND_EXPR, boolean_type_node, store, ovfres);\n+}\n+\n /* Fold a call to built-in function FNDECL with 0 arguments.\n    IGNORE is true if the result of the function call is ignored.  This\n    function returns NULL_TREE if no simplification was possible.  */\n@@ -10431,6 +10487,29 @@ fold_builtin_3 (location_t loc, tree fndecl,\n     case BUILT_IN_EXPECT:\n       return fold_builtin_expect (loc, arg0, arg1, arg2);\n \n+    case BUILT_IN_ADD_OVERFLOW:\n+    case BUILT_IN_SUB_OVERFLOW:\n+    case BUILT_IN_MUL_OVERFLOW:\n+    case BUILT_IN_SADD_OVERFLOW:\n+    case BUILT_IN_SADDL_OVERFLOW:\n+    case BUILT_IN_SADDLL_OVERFLOW:\n+    case BUILT_IN_SSUB_OVERFLOW:\n+    case BUILT_IN_SSUBL_OVERFLOW:\n+    case BUILT_IN_SSUBLL_OVERFLOW:\n+    case BUILT_IN_SMUL_OVERFLOW:\n+    case BUILT_IN_SMULL_OVERFLOW:\n+    case BUILT_IN_SMULLL_OVERFLOW:\n+    case BUILT_IN_UADD_OVERFLOW:\n+    case BUILT_IN_UADDL_OVERFLOW:\n+    case BUILT_IN_UADDLL_OVERFLOW:\n+    case BUILT_IN_USUB_OVERFLOW:\n+    case BUILT_IN_USUBL_OVERFLOW:\n+    case BUILT_IN_USUBLL_OVERFLOW:\n+    case BUILT_IN_UMUL_OVERFLOW:\n+    case BUILT_IN_UMULL_OVERFLOW:\n+    case BUILT_IN_UMULLL_OVERFLOW:\n+      return fold_builtin_arith_overflow (loc, fcode, arg0, arg1, arg2);\n+\n     default:\n       break;\n     }"}, {"sha": "040601677c78d27a8c6c46eed70f79bf470d5ddb", "filename": "gcc/builtins.def", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.def?ref=1304953e4fa46305d1ce0b884bf2f58e08409ff3", "patch": "@@ -671,6 +671,30 @@ DEF_C94_BUILTIN        (BUILT_IN_ISWXDIGIT, \"iswxdigit\", BT_FN_INT_WINT, ATTR_PU\n DEF_C94_BUILTIN        (BUILT_IN_TOWLOWER, \"towlower\", BT_FN_WINT_WINT, ATTR_PURE_NOTHROW_LEAF_LIST)\n DEF_C94_BUILTIN        (BUILT_IN_TOWUPPER, \"towupper\", BT_FN_WINT_WINT, ATTR_PURE_NOTHROW_LEAF_LIST)\n \n+/* Category: integer overflow checking builtins.  */\n+DEF_GCC_BUILTIN        (BUILT_IN_ADD_OVERFLOW, \"add_overflow\", BT_FN_BOOL_VAR, ATTR_NOTHROW_TYPEGENERIC_LEAF)\n+DEF_GCC_BUILTIN        (BUILT_IN_SUB_OVERFLOW, \"sub_overflow\", BT_FN_BOOL_VAR, ATTR_NOTHROW_TYPEGENERIC_LEAF)\n+DEF_GCC_BUILTIN        (BUILT_IN_MUL_OVERFLOW, \"mul_overflow\", BT_FN_BOOL_VAR, ATTR_NOTHROW_TYPEGENERIC_LEAF)\n+/* Clang compatibility.  */\n+DEF_GCC_BUILTIN        (BUILT_IN_SADD_OVERFLOW, \"sadd_overflow\", BT_FN_BOOL_INT_INT_INTPTR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_GCC_BUILTIN        (BUILT_IN_SADDL_OVERFLOW, \"saddl_overflow\", BT_FN_BOOL_LONG_LONG_LONGPTR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_GCC_BUILTIN        (BUILT_IN_SADDLL_OVERFLOW, \"saddll_overflow\", BT_FN_BOOL_LONGLONG_LONGLONG_LONGLONGPTR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_GCC_BUILTIN        (BUILT_IN_SSUB_OVERFLOW, \"ssub_overflow\", BT_FN_BOOL_INT_INT_INTPTR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_GCC_BUILTIN        (BUILT_IN_SSUBL_OVERFLOW, \"ssubl_overflow\", BT_FN_BOOL_LONG_LONG_LONGPTR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_GCC_BUILTIN        (BUILT_IN_SSUBLL_OVERFLOW, \"ssubll_overflow\", BT_FN_BOOL_LONGLONG_LONGLONG_LONGLONGPTR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_GCC_BUILTIN        (BUILT_IN_SMUL_OVERFLOW, \"smul_overflow\", BT_FN_BOOL_INT_INT_INTPTR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_GCC_BUILTIN        (BUILT_IN_SMULL_OVERFLOW, \"smull_overflow\", BT_FN_BOOL_LONG_LONG_LONGPTR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_GCC_BUILTIN        (BUILT_IN_SMULLL_OVERFLOW, \"smulll_overflow\", BT_FN_BOOL_LONGLONG_LONGLONG_LONGLONGPTR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_GCC_BUILTIN        (BUILT_IN_UADD_OVERFLOW, \"uadd_overflow\", BT_FN_BOOL_UINT_UINT_UINTPTR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_GCC_BUILTIN        (BUILT_IN_UADDL_OVERFLOW, \"uaddl_overflow\", BT_FN_BOOL_ULONG_ULONG_ULONGPTR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_GCC_BUILTIN        (BUILT_IN_UADDLL_OVERFLOW, \"uaddll_overflow\", BT_FN_BOOL_ULONGLONG_ULONGLONG_ULONGLONGPTR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_GCC_BUILTIN        (BUILT_IN_USUB_OVERFLOW, \"usub_overflow\", BT_FN_BOOL_UINT_UINT_UINTPTR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_GCC_BUILTIN        (BUILT_IN_USUBL_OVERFLOW, \"usubl_overflow\", BT_FN_BOOL_ULONG_ULONG_ULONGPTR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_GCC_BUILTIN        (BUILT_IN_USUBLL_OVERFLOW, \"usubll_overflow\", BT_FN_BOOL_ULONGLONG_ULONGLONG_ULONGLONGPTR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_GCC_BUILTIN        (BUILT_IN_UMUL_OVERFLOW, \"umul_overflow\", BT_FN_BOOL_UINT_UINT_UINTPTR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_GCC_BUILTIN        (BUILT_IN_UMULL_OVERFLOW, \"umull_overflow\", BT_FN_BOOL_ULONG_ULONG_ULONGPTR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_GCC_BUILTIN        (BUILT_IN_UMULLL_OVERFLOW, \"umulll_overflow\", BT_FN_BOOL_ULONGLONG_ULONGLONG_ULONGLONGPTR, ATTR_NOTHROW_LEAF_LIST)\n+\n /* Category: miscellaneous builtins.  */\n DEF_LIB_BUILTIN        (BUILT_IN_ABORT, \"abort\", BT_FN_VOID, ATTR_NORETURN_NOTHROW_LEAF_LIST)\n DEF_LIB_BUILTIN        (BUILT_IN_ABS, \"abs\", BT_FN_INT_INT, ATTR_CONST_NOTHROW_LEAF_LIST)"}, {"sha": "7feda0f185d2ac9d9c970caad384d087f9a26490", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=1304953e4fa46305d1ce0b884bf2f58e08409ff3", "patch": "@@ -1,3 +1,9 @@\n+2014-11-12  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c/59708\n+\t* c-common.c (check_builtin_function_arguments): Handle\n+\tBUILT_IN_{ADD,SUB,MUL}_OVERFLOW.\n+\n 2014-11-10  Andi Kleen  <ak@linux.intel.com>\n \n \tPR c/60804"}, {"sha": "839111a2122790e650e23bc75abfcfd823b242d0", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=1304953e4fa46305d1ce0b884bf2f58e08409ff3", "patch": "@@ -9649,6 +9649,30 @@ check_builtin_function_arguments (tree fndecl, int nargs, tree *args)\n \t}\n       return false;\n \n+    case BUILT_IN_ADD_OVERFLOW:\n+    case BUILT_IN_SUB_OVERFLOW:\n+    case BUILT_IN_MUL_OVERFLOW:\n+      if (builtin_function_validate_nargs (fndecl, nargs, 3))\n+\t{\n+\t  unsigned i;\n+\t  for (i = 0; i < 2; i++)\n+\t    if (!INTEGRAL_TYPE_P (TREE_TYPE (args[i])))\n+\t      {\n+\t\terror (\"argument %u in call to function %qE does not have \"\n+\t\t       \"integral type\", i + 1, fndecl);\n+\t\treturn false;\n+\t      }\n+\t  if (TREE_CODE (TREE_TYPE (args[2])) != POINTER_TYPE\n+\t      || TREE_CODE (TREE_TYPE (TREE_TYPE (args[2]))) != INTEGER_TYPE)\n+\t    {\n+\t      error (\"argument 3 in call to function %qE does not have \"\n+\t\t     \"pointer to integer type\", fndecl);\n+\t      return false;\n+\t    }\n+\t  return true;\n+\t}\n+      return false;\n+\n     default:\n       return true;\n     }"}, {"sha": "203db11ff06364f34b8d9154649fe160aa77d5fa", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=1304953e4fa46305d1ce0b884bf2f58e08409ff3", "patch": "@@ -6663,6 +6663,99 @@\n \t\t  (const_string \"4\")]\n \t      (const_string \"<MODE_SIZE>\")))])\n \n+(define_expand \"umulv<mode>4\"\n+  [(parallel [(set (reg:CCO FLAGS_REG)\n+\t\t   (eq:CCO (mult:<DWI>\n+\t\t\t      (zero_extend:<DWI>\n+\t\t\t\t (match_operand:SWI48 1\n+\t\t\t\t\t\t      \"nonimmediate_operand\"))\n+\t\t\t      (zero_extend:<DWI>\n+\t\t\t\t (match_operand:SWI48 2\n+\t\t\t\t\t\t      \"nonimmediate_operand\")))\n+\t\t\t   (zero_extend:<DWI>\n+\t\t\t      (mult:SWI48 (match_dup 1) (match_dup 2)))))\n+\t      (set (match_operand:SWI48 0 \"register_operand\")\n+\t\t   (mult:SWI48 (match_dup 1) (match_dup 2)))\n+\t      (clobber (match_scratch:SWI48 4))])\n+   (set (pc) (if_then_else\n+\t       (eq (reg:CCO FLAGS_REG) (const_int 0))\n+\t       (label_ref (match_operand 3))\n+\t       (pc)))]\n+  \"\"\n+{\n+  if (MEM_P (operands[1]) && MEM_P (operands[2]))\n+    operands[1] = force_reg (<MODE>mode, operands[1]);\n+})\n+\n+(define_insn \"*umulv<mode>4\"\n+  [(set (reg:CCO FLAGS_REG)\n+\t(eq:CCO (mult:<DWI>\n+\t\t   (zero_extend:<DWI>\n+\t\t      (match_operand:SWI48 1 \"nonimmediate_operand\" \"%0\"))\n+\t\t   (zero_extend:<DWI>\n+\t\t      (match_operand:SWI48 2 \"nonimmediate_operand\" \"rm\")))\n+\t\t(zero_extend:<DWI>\n+\t\t   (mult:SWI48 (match_dup 1) (match_dup 2)))))\n+   (set (match_operand:SWI48 0 \"register_operand\" \"=a\")\n+\t(mult:SWI48 (match_dup 1) (match_dup 2)))\n+   (clobber (match_scratch:SWI48 3 \"=d\"))]\n+  \"!(MEM_P (operands[1]) && MEM_P (operands[2]))\"\n+  \"mul{<imodesuffix>}\\t%2\"\n+  [(set_attr \"type\" \"imul\")\n+   (set_attr \"length_immediate\" \"0\")\n+   (set (attr \"athlon_decode\")\n+     (if_then_else (eq_attr \"cpu\" \"athlon\")\n+       (const_string \"vector\")\n+       (const_string \"double\")))\n+   (set_attr \"amdfam10_decode\" \"double\")\n+   (set_attr \"bdver1_decode\" \"direct\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_expand \"<u>mulvqi4\"\n+  [(parallel [(set (reg:CCO FLAGS_REG)\n+\t\t   (eq:CCO (mult:HI\n+\t\t\t      (any_extend:HI\n+\t\t\t\t (match_operand:QI 1 \"nonimmediate_operand\"))\n+\t\t\t      (any_extend:HI\n+\t\t\t\t (match_operand:QI 2 \"nonimmediate_operand\")))\n+\t\t\t   (any_extend:HI\n+\t\t\t      (mult:QI (match_dup 1) (match_dup 2)))))\n+\t      (set (match_operand:QI 0 \"register_operand\")\n+\t\t   (mult:QI (match_dup 1) (match_dup 2)))])\n+   (set (pc) (if_then_else\n+\t       (eq (reg:CCO FLAGS_REG) (const_int 0))\n+\t       (label_ref (match_operand 3))\n+\t       (pc)))]\n+  \"TARGET_QIMODE_MATH\"\n+{\n+  if (MEM_P (operands[1]) && MEM_P (operands[2]))\n+    operands[1] = force_reg (QImode, operands[1]);\n+})\n+\n+(define_insn \"*<u>mulvqi4\"\n+  [(set (reg:CCO FLAGS_REG)\n+\t(eq:CCO (mult:HI\n+\t\t   (any_extend:HI\n+\t\t      (match_operand:QI 1 \"nonimmediate_operand\" \"%0\"))\n+\t\t   (any_extend:HI\n+\t\t      (match_operand:QI 2 \"nonimmediate_operand\" \"qm\")))\n+\t\t(any_extend:HI\n+\t\t   (mult:QI (match_dup 1) (match_dup 2)))))\n+   (set (match_operand:QI 0 \"register_operand\" \"=a\")\n+\t(mult:QI (match_dup 1) (match_dup 2)))]\n+  \"TARGET_QIMODE_MATH\n+   && !(MEM_P (operands[1]) && MEM_P (operands[2]))\"\n+  \"<sgnprefix>mul{b}\\t%2\"\n+  [(set_attr \"type\" \"imul\")\n+   (set_attr \"length_immediate\" \"0\")\n+   (set (attr \"athlon_decode\")\n+     (if_then_else (eq_attr \"cpu\" \"athlon\")\n+\t(const_string \"vector\")\n+\t(const_string \"direct\")))\n+   (set_attr \"amdfam10_decode\" \"direct\")\n+   (set_attr \"bdver1_decode\" \"direct\")\n+   (set_attr \"mode\" \"QI\")])\n+\n (define_expand \"<u>mul<mode><dwi>3\"\n   [(parallel [(set (match_operand:<DWI> 0 \"register_operand\")\n \t\t   (mult:<DWI>"}, {"sha": "d10a815a977ffee504241ea0e47c4137c7daf357", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=1304953e4fa46305d1ce0b884bf2f58e08409ff3", "patch": "@@ -76,6 +76,8 @@ extensions, accepted by GCC in C90 mode and in C++.\n * Offsetof::            Special syntax for implementing @code{offsetof}.\n * __sync Builtins::     Legacy built-in functions for atomic memory access.\n * __atomic Builtins::   Atomic built-in functions with memory model.\n+* Integer Overflow Builtins:: Built-in functions to perform arithmetics and\n+                        arithmetic overflow checking.\n * x86 specific memory model extensions for transactional memory:: x86 memory models.\n * Object Size Checking:: Built-in functions for limited buffer overflow\n                         checking.\n@@ -8487,6 +8489,65 @@ alignment.  A value of 0 indicates typical alignment should be used.  The\n compiler may also ignore this parameter.\n @end deftypefn\n \n+@node Integer Overflow Builtins\n+@section Built-in functions to perform arithmetics and arithmetic overflow checking.\n+\n+The following built-in functions allow performing simple arithmetic operations\n+together with checking whether the operations overflowed.\n+\n+@deftypefn {Built-in Function} bool __builtin_add_overflow (@var{type1} a, @var{type2} b, @var{type3} *res)\n+@deftypefnx {Built-in Function} bool __builtin_sadd_overflow (int a, int b, int *res)\n+@deftypefnx {Built-in Function} bool __builtin_saddl_overflow (long int a, long int b, long int *res)\n+@deftypefnx {Built-in Function} bool __builtin_saddll_overflow (long long int a, long long int b, long int *res)\n+@deftypefnx {Built-in Function} bool __builtin_uadd_overflow (unsigned int a, unsigned int b, unsigned int *res)\n+@deftypefnx {Built-in Function} bool __builtin_uaddl_overflow (unsigned long int a, unsigned long int b, unsigned long int *res)\n+@deftypefnx {Built-in Function} bool __builtin_uaddll_overflow (unsigned long long int a, unsigned long long int b, unsigned long int *res)\n+\n+These built-in functions promote the first two operands into infinite precision signed\n+type and perform addition on those promoted operands.  The result is then\n+cast to the type the third pointer argument points to and stored there.\n+If the stored result is equal to the infinite precision result, the built-in\n+functions return false, otherwise they return true.  As the addition is\n+performed in infinite signed precision, these built-in functions have fully defined\n+behavior for all argument values.\n+\n+The first built-in function allows arbitrary integral types for operands and\n+the result type must be pointer to some integer type, the rest of the built-in\n+functions have explicit integer types.\n+\n+The compiler will attempt to use hardware instructions to implement\n+these built-in functions where possible, like conditional jump on overflow\n+after addition, conditional jump on carry etc.\n+\n+@end deftypefn\n+\n+@deftypefn {Built-in Function} bool __builtin_sub_overflow (@var{type1} a, @var{type2} b, @var{type3} *res)\n+@deftypefnx {Built-in Function} bool __builtin_ssub_overflow (int a, int b, int *res)\n+@deftypefnx {Built-in Function} bool __builtin_ssubl_overflow (long int a, long int b, long int *res)\n+@deftypefnx {Built-in Function} bool __builtin_ssubll_overflow (long long int a, long long int b, long int *res)\n+@deftypefnx {Built-in Function} bool __builtin_usub_overflow (unsigned int a, unsigned int b, unsigned int *res)\n+@deftypefnx {Built-in Function} bool __builtin_usubl_overflow (unsigned long int a, unsigned long int b, unsigned long int *res)\n+@deftypefnx {Built-in Function} bool __builtin_usubll_overflow (unsigned long long int a, unsigned long long int b, unsigned long int *res)\n+\n+These built-in functions are similar to the add overflow checking built-in\n+functions above, except they perform subtraction, subtract the second argument\n+from the first one, instead of addition.\n+\n+@end deftypefn\n+\n+@deftypefn {Built-in Function} bool __builtin_mul_overflow (@var{type1} a, @var{type2} b, @var{type3} *res)\n+@deftypefnx {Built-in Function} bool __builtin_smul_overflow (int a, int b, int *res)\n+@deftypefnx {Built-in Function} bool __builtin_smull_overflow (long int a, long int b, long int *res)\n+@deftypefnx {Built-in Function} bool __builtin_smulll_overflow (long long int a, long long int b, long int *res)\n+@deftypefnx {Built-in Function} bool __builtin_umul_overflow (unsigned int a, unsigned int b, unsigned int *res)\n+@deftypefnx {Built-in Function} bool __builtin_umull_overflow (unsigned long int a, unsigned long int b, unsigned long int *res)\n+@deftypefnx {Built-in Function} bool __builtin_umulll_overflow (unsigned long long int a, unsigned long long int b, unsigned long int *res)\n+\n+These built-in functions are similar to the add overflow checking built-in\n+functions above, except they perform multiplication, instead of addition.\n+\n+@end deftypefn\n+\n @node x86 specific memory model extensions for transactional memory\n @section x86 specific memory model extensions for transactional memory\n "}, {"sha": "2e7f839f31602b25c30ed034b072e06a072c7ae2", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=1304953e4fa46305d1ce0b884bf2f58e08409ff3", "patch": "@@ -168,7 +168,6 @@ static void emit_single_push_insn (machine_mode, rtx, tree);\n #endif\n static void do_tablejump (rtx, machine_mode, rtx, rtx, rtx, int);\n static rtx const_vector_from_tree (tree);\n-static void write_complex_part (rtx, rtx, bool);\n \n \f\n /* This is run to set up which modes can be used\n@@ -2995,7 +2994,7 @@ set_storage_via_setmem (rtx object, rtx size, rtx val, unsigned int align,\n /* Write to one of the components of the complex value CPLX.  Write VAL to\n    the real part if IMAG_P is false, and the imaginary part if its true.  */\n \n-static void\n+void\n write_complex_part (rtx cplx, rtx val, bool imag_p)\n {\n   machine_mode cmode;"}, {"sha": "02cce0f0807d8b5c6dadf2c441506404ed1427af", "filename": "gcc/expr.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=1304953e4fa46305d1ce0b884bf2f58e08409ff3", "patch": "@@ -255,6 +255,7 @@ extern rtx_insn *emit_move_insn_1 (rtx, rtx);\n \n extern rtx_insn *emit_move_complex_push (machine_mode, rtx, rtx);\n extern rtx_insn *emit_move_complex_parts (rtx, rtx);\n+extern void write_complex_part (rtx, rtx, bool);\n extern rtx emit_move_resolve_push (machine_mode, rtx);\n \n /* Push a block of length SIZE (perhaps variable)"}, {"sha": "ef9809159096392d04c1896cd9a6972ad9ac9145", "filename": "gcc/function.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=1304953e4fa46305d1ce0b884bf2f58e08409ff3", "patch": "@@ -2020,9 +2020,14 @@ aggregate_value_p (const_tree exp, const_tree fntype)\n       case CALL_EXPR:\n \t{\n \t  tree fndecl = get_callee_fndecl (fntype);\n-\t  fntype = (fndecl\n-\t\t    ? TREE_TYPE (fndecl)\n-\t\t    : TREE_TYPE (TREE_TYPE (CALL_EXPR_FN (fntype))));\n+\t  if (fndecl)\n+\t    fntype = TREE_TYPE (fndecl);\n+\t  else if (CALL_EXPR_FN (fntype))\n+\t    fntype = TREE_TYPE (TREE_TYPE (CALL_EXPR_FN (fntype)));\n+\t  else\n+\t    /* For internal functions, assume nothing needs to be\n+\t       returned in memory.  */\n+\t    return 0;\n \t}\n \tbreak;\n       case FUNCTION_DECL:"}, {"sha": "aeb180370d8185903cca2676e046462de1eb37ad", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 112, "deletions": 13, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=1304953e4fa46305d1ce0b884bf2f58e08409ff3", "patch": "@@ -2586,6 +2586,33 @@ gimple_fold_builtin (gimple_stmt_iterator *gsi)\n   return false;\n }\n \n+/* Return true if ARG0 CODE ARG1 in infinite signed precision operation\n+   doesn't fit into TYPE.  The test for overflow should be regardless of\n+   -fwrapv, and even for unsigned types.  */\n+\n+bool\n+arith_overflowed_p (enum tree_code code, const_tree type,\n+\t\t    const_tree arg0, const_tree arg1)\n+{\n+  typedef FIXED_WIDE_INT (WIDE_INT_MAX_PRECISION * 2) widest2_int;\n+  typedef generic_wide_int <wi::extended_tree <WIDE_INT_MAX_PRECISION * 2> >\n+    widest2_int_cst;\n+  widest2_int warg0 = widest2_int_cst (arg0);\n+  widest2_int warg1 = widest2_int_cst (arg1);\n+  widest2_int wres;\n+  switch (code)\n+    {\n+    case PLUS_EXPR: wres = wi::add (warg0, warg1); break;\n+    case MINUS_EXPR: wres = wi::sub (warg0, warg1); break;\n+    case MULT_EXPR: wres = wi::mul (warg0, warg1); break;\n+    default: gcc_unreachable ();\n+    }\n+  signop sign = TYPE_SIGN (type);\n+  if (sign == UNSIGNED && wi::neg_p (wres))\n+    return true;\n+  return wi::min_precision (wres, sign) > TYPE_PRECISION (type);\n+}\n+\n /* Attempt to fold a call statement referenced by the statement iterator GSI.\n    The statement may be replaced by another statement, e.g., if the call\n    simplifies to a constant value. Return true if any changes were made.\n@@ -2714,6 +2741,8 @@ gimple_fold_call (gimple_stmt_iterator *gsi, bool inplace)\n     {\n       enum tree_code subcode = ERROR_MARK;\n       tree result = NULL_TREE;\n+      bool cplx_result = false;\n+      tree overflow = NULL_TREE;\n       switch (gimple_call_internal_fn (stmt))\n \t{\n \tcase IFN_BUILTIN_EXPECT:\n@@ -2744,37 +2773,107 @@ gimple_fold_call (gimple_stmt_iterator *gsi, bool inplace)\n \tcase IFN_UBSAN_CHECK_MUL:\n \t  subcode = MULT_EXPR;\n \t  break;\n+\tcase IFN_ADD_OVERFLOW:\n+\t  subcode = PLUS_EXPR;\n+\t  cplx_result = true;\n+\t  break;\n+\tcase IFN_SUB_OVERFLOW:\n+\t  subcode = MINUS_EXPR;\n+\t  cplx_result = true;\n+\t  break;\n+\tcase IFN_MUL_OVERFLOW:\n+\t  subcode = MULT_EXPR;\n+\t  cplx_result = true;\n+\t  break;\n \tdefault:\n \t  break;\n \t}\n       if (subcode != ERROR_MARK)\n \t{\n \t  tree arg0 = gimple_call_arg (stmt, 0);\n \t  tree arg1 = gimple_call_arg (stmt, 1);\n+\t  tree type = TREE_TYPE (arg0);\n+\t  if (cplx_result)\n+\t    {\n+\t      tree lhs = gimple_call_lhs (stmt);\n+\t      if (lhs == NULL_TREE)\n+\t\ttype = NULL_TREE;\n+\t      else\n+\t\ttype = TREE_TYPE (TREE_TYPE (lhs));\n+\t    }\n+\t  if (type == NULL_TREE)\n+\t    ;\n \t  /* x = y + 0; x = y - 0; x = y * 0; */\n-\t  if (integer_zerop (arg1))\n-\t    result = subcode == MULT_EXPR\n-\t\t     ? build_zero_cst (TREE_TYPE (arg0))\n-\t\t     : arg0;\n+\t  else if (integer_zerop (arg1))\n+\t    result = subcode == MULT_EXPR ? integer_zero_node : arg0;\n \t  /* x = 0 + y; x = 0 * y; */\n \t  else if (subcode != MINUS_EXPR && integer_zerop (arg0))\n-\t    result = subcode == MULT_EXPR\n-\t\t     ? build_zero_cst (TREE_TYPE (arg0))\n-\t\t     : arg1;\n+\t    result = subcode == MULT_EXPR ? integer_zero_node : arg1;\n \t  /* x = y - y; */\n \t  else if (subcode == MINUS_EXPR && operand_equal_p (arg0, arg1, 0))\n-\t    result = build_zero_cst (TREE_TYPE (arg0));\n+\t    result = integer_zero_node;\n \t  /* x = y * 1; x = 1 * y; */\n-\t  else if (subcode == MULT_EXPR)\n+\t  else if (subcode == MULT_EXPR && integer_onep (arg1))\n+\t    result = arg0;\n+\t  else if (subcode == MULT_EXPR && integer_onep (arg0))\n+\t    result = arg1;\n+\t  else if (TREE_CODE (arg0) == INTEGER_CST\n+\t\t   && TREE_CODE (arg1) == INTEGER_CST)\n+\t    {\n+\t      if (cplx_result)\n+\t\tresult = int_const_binop (subcode, fold_convert (type, arg0),\n+\t\t\t\t\t  fold_convert (type, arg1));\n+\t      else\n+\t\tresult = int_const_binop (subcode, arg0, arg1);\n+\t      if (result && arith_overflowed_p (subcode, type, arg0, arg1))\n+\t\t{\n+\t\t  if (cplx_result)\n+\t\t    overflow = build_one_cst (type);\n+\t\t  else\n+\t\t    result = NULL_TREE;\n+\t\t}\n+\t    }\n+\t  if (result)\n \t    {\n-\t      if (integer_onep (arg1))\n-\t\tresult = arg0;\n-\t      else if (integer_onep (arg0))\n-\t\tresult = arg1;\n+\t      if (result == integer_zero_node)\n+\t\tresult = build_zero_cst (type);\n+\t      else if (cplx_result && TREE_TYPE (result) != type)\n+\t\t{\n+\t\t  if (TREE_CODE (result) == INTEGER_CST)\n+\t\t    {\n+\t\t      if (arith_overflowed_p (PLUS_EXPR, type, result,\n+\t\t\t\t\t      integer_zero_node))\n+\t\t\toverflow = build_one_cst (type);\n+\t\t    }\n+\t\t  else if ((!TYPE_UNSIGNED (TREE_TYPE (result))\n+\t\t\t    && TYPE_UNSIGNED (type))\n+\t\t\t   || (TYPE_PRECISION (type)\n+\t\t\t       < (TYPE_PRECISION (TREE_TYPE (result))\n+\t\t\t\t  + (TYPE_UNSIGNED (TREE_TYPE (result))\n+\t\t\t\t     && !TYPE_UNSIGNED (type)))))\n+\t\t    result = NULL_TREE;\n+\t\t  if (result)\n+\t\t    result = fold_convert (type, result);\n+\t\t}\n \t    }\n \t}\n+\n       if (result)\n \t{\n+\t  if (TREE_CODE (result) == INTEGER_CST && TREE_OVERFLOW (result))\n+\t    result = drop_tree_overflow (result);\n+\t  if (cplx_result)\n+\t    {\n+\t      if (overflow == NULL_TREE)\n+\t\toverflow = build_zero_cst (TREE_TYPE (result));\n+\t      tree ctype = build_complex_type (TREE_TYPE (result));\n+\t      if (TREE_CODE (result) == INTEGER_CST\n+\t\t  && TREE_CODE (overflow) == INTEGER_CST)\n+\t\tresult = build_complex (ctype, result, overflow);\n+\t      else\n+\t\tresult = build2_loc (gimple_location (stmt), COMPLEX_EXPR,\n+\t\t\t\t     ctype, result, overflow);\n+\t    }\n \t  if (!update_call_from_tree (gsi, result))\n \t    gimplify_and_update_call_from_tree (gsi, result);\n \t  changed = true;"}, {"sha": "f42ff0264e34177e46e62dfb87fc42d25eba380d", "filename": "gcc/gimple-fold.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Fgimple-fold.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Fgimple-fold.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.h?ref=1304953e4fa46305d1ce0b884bf2f58e08409ff3", "patch": "@@ -32,6 +32,8 @@ extern tree maybe_fold_and_comparisons (enum tree_code, tree, tree,\n \t\t\t\t\tenum tree_code, tree, tree);\n extern tree maybe_fold_or_comparisons (enum tree_code, tree, tree,\n \t\t\t\t       enum tree_code, tree, tree);\n+extern bool arith_overflowed_p (enum tree_code, const_tree, const_tree,\n+\t\t\t\tconst_tree);\n extern tree no_follow_ssa_edges (tree);\n extern tree follow_single_use_edges (tree);\n extern tree gimple_fold_stmt_to_constant_1 (gimple, tree (*) (tree));"}, {"sha": "93c06debda500d8f59dcfaf55ebbf6abd3d83f92", "filename": "gcc/gimplify.c", "status": "modified", "additions": 36, "deletions": 14, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=1304953e4fa46305d1ce0b884bf2f58e08409ff3", "patch": "@@ -2281,6 +2281,9 @@ gimplify_call_expr (tree *expr_p, gimple_seq *pre_p, bool want_value)\n   /* Gimplify internal functions created in the FEs.  */\n   if (CALL_EXPR_FN (*expr_p) == NULL_TREE)\n     {\n+      if (want_value)\n+\treturn GS_ALL_DONE;\n+\n       nargs = call_expr_nargs (*expr_p);\n       enum internal_fn ifn = CALL_EXPR_IFN (*expr_p);\n       auto_vec<tree> vargs (nargs);\n@@ -4644,22 +4647,41 @@ gimplify_modify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n     {\n       /* Since the RHS is a CALL_EXPR, we need to create a GIMPLE_CALL\n \t instead of a GIMPLE_ASSIGN.  */\n-      tree fnptrtype = TREE_TYPE (CALL_EXPR_FN (*from_p));\n-      CALL_EXPR_FN (*from_p) = TREE_OPERAND (CALL_EXPR_FN (*from_p), 0);\n-      STRIP_USELESS_TYPE_CONVERSION (CALL_EXPR_FN (*from_p));\n-      tree fndecl = get_callee_fndecl (*from_p);\n-      if (fndecl\n-\t  && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL\n-\t  && DECL_FUNCTION_CODE (fndecl) == BUILT_IN_EXPECT\n-\t  && call_expr_nargs (*from_p) == 3)\n-\tassign = gimple_build_call_internal (IFN_BUILTIN_EXPECT, 3,\n-\t\t\t\t\t     CALL_EXPR_ARG (*from_p, 0),\n-\t\t\t\t\t     CALL_EXPR_ARG (*from_p, 1),\n-\t\t\t\t\t     CALL_EXPR_ARG (*from_p, 2));\n+      if (CALL_EXPR_FN (*from_p) == NULL_TREE)\n+\t{\n+\t  /* Gimplify internal functions created in the FEs.  */\n+\t  int nargs = call_expr_nargs (*from_p), i;\n+\t  enum internal_fn ifn = CALL_EXPR_IFN (*from_p);\n+\t  auto_vec<tree> vargs (nargs);\n+\n+\t  for (i = 0; i < nargs; i++)\n+\t    {\n+\t      gimplify_arg (&CALL_EXPR_ARG (*from_p, i), pre_p,\n+\t\t\t    EXPR_LOCATION (*from_p));\n+\t      vargs.quick_push (CALL_EXPR_ARG (*from_p, i));\n+\t    }\n+\t  assign = gimple_build_call_internal_vec (ifn, vargs);\n+\t  gimple_set_location (assign, EXPR_LOCATION (*expr_p));\n+\t}\n       else\n \t{\n-\t  assign = gimple_build_call_from_tree (*from_p);\n-\t  gimple_call_set_fntype (assign, TREE_TYPE (fnptrtype));\n+\t  tree fnptrtype = TREE_TYPE (CALL_EXPR_FN (*from_p));\n+\t  CALL_EXPR_FN (*from_p) = TREE_OPERAND (CALL_EXPR_FN (*from_p), 0);\n+\t  STRIP_USELESS_TYPE_CONVERSION (CALL_EXPR_FN (*from_p));\n+\t  tree fndecl = get_callee_fndecl (*from_p);\n+\t  if (fndecl\n+\t      && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL\n+\t      && DECL_FUNCTION_CODE (fndecl) == BUILT_IN_EXPECT\n+\t      && call_expr_nargs (*from_p) == 3)\n+\t    assign = gimple_build_call_internal (IFN_BUILTIN_EXPECT, 3,\n+\t\t\t\t\t\t CALL_EXPR_ARG (*from_p, 0),\n+\t\t\t\t\t\t CALL_EXPR_ARG (*from_p, 1),\n+\t\t\t\t\t\t CALL_EXPR_ARG (*from_p, 2));\n+\t  else\n+\t    {\n+\t      assign = gimple_build_call_from_tree (*from_p);\n+\t      gimple_call_set_fntype (assign, TREE_TYPE (fnptrtype));\n+\t    }\n \t}\n       notice_special_calls (assign);\n       if (!gimple_call_noreturn_p (assign))"}, {"sha": "073d941d8ce5d3de6613e2ca2b8893ec76346f00", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 1204, "deletions": 226, "changes": 1430, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=1304953e4fa46305d1ce0b884bf2f58e08409ff3", "patch": "@@ -208,32 +208,494 @@ expand_ASAN_CHECK (gimple stmt ATTRIBUTE_UNUSED)\n   gcc_unreachable ();\n }\n \n+/* Helper function for expand_addsub_overflow.  Return 1\n+   if ARG interpreted as signed in its precision is known to be always\n+   positive or 2 if ARG is known to be always negative, or 3 if ARG may\n+   be positive or negative.  */\n+\n+static int\n+get_range_pos_neg (tree arg)\n+{\n+  if (arg == error_mark_node)\n+    return 3;\n+\n+  int prec = TYPE_PRECISION (TREE_TYPE (arg));\n+  int cnt = 0;\n+  if (TREE_CODE (arg) == INTEGER_CST)\n+    {\n+      wide_int w = wi::sext (arg, prec);\n+      if (wi::neg_p (w))\n+\treturn 2;\n+      else\n+\treturn 1;\n+    }\n+  while (CONVERT_EXPR_P (arg)\n+\t && INTEGRAL_TYPE_P (TREE_TYPE (TREE_OPERAND (arg, 0)))\n+\t && TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (arg, 0))) <= prec)\n+    {\n+      arg = TREE_OPERAND (arg, 0);\n+      /* Narrower value zero extended into wider type\n+\t will always result in positive values.  */\n+      if (TYPE_UNSIGNED (TREE_TYPE (arg))\n+\t  && TYPE_PRECISION (TREE_TYPE (arg)) < prec)\n+\treturn 1;\n+      prec = TYPE_PRECISION (TREE_TYPE (arg));\n+      if (++cnt > 30)\n+\treturn 3;\n+    }\n+\n+  if (TREE_CODE (arg) != SSA_NAME)\n+    return 3;\n+  wide_int arg_min, arg_max;\n+  while (get_range_info (arg, &arg_min, &arg_max) != VR_RANGE)\n+    {\n+      gimple g = SSA_NAME_DEF_STMT (arg);\n+      if (is_gimple_assign (g)\n+\t  && CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (g)))\n+\t{\n+\t  tree t = gimple_assign_rhs1 (g);\n+\t  if (INTEGRAL_TYPE_P (TREE_TYPE (t))\n+\t      && TYPE_PRECISION (TREE_TYPE (t)) <= prec)\n+\t    {\n+\t      if (TYPE_UNSIGNED (TREE_TYPE (t))\n+\t\t  && TYPE_PRECISION (TREE_TYPE (t)) < prec)\n+\t\treturn 1;\n+\t      prec = TYPE_PRECISION (TREE_TYPE (t));\n+\t      arg = t;\n+\t      if (++cnt > 30)\n+\t\treturn 3;\n+\t      continue;\n+\t    }\n+\t}\n+      return 3;\n+    }\n+  if (TYPE_UNSIGNED (TREE_TYPE (arg)))\n+    {\n+      /* For unsigned values, the \"positive\" range comes\n+\t below the \"negative\" range.  */\n+      if (!wi::neg_p (wi::sext (arg_max, prec), SIGNED))\n+\treturn 1;\n+      if (wi::neg_p (wi::sext (arg_min, prec), SIGNED))\n+\treturn 2;\n+    }\n+  else\n+    {\n+      if (!wi::neg_p (wi::sext (arg_min, prec), SIGNED))\n+\treturn 1;\n+      if (wi::neg_p (wi::sext (arg_max, prec), SIGNED))\n+\treturn 2;\n+    }\n+  return 3;\n+}\n+\n+/* Return minimum precision needed to represent all values\n+   of ARG in SIGNed integral type.  */\n+\n+static int\n+get_min_precision (tree arg, signop sign)\n+{\n+  int prec = TYPE_PRECISION (TREE_TYPE (arg));\n+  int cnt = 0;\n+  signop orig_sign = sign;\n+  if (TREE_CODE (arg) == INTEGER_CST)\n+    {\n+      int p;\n+      if (TYPE_SIGN (TREE_TYPE (arg)) != sign)\n+\t{\n+\t  widest_int w = wi::to_widest (arg);\n+\t  w = wi::ext (w, prec, sign);\n+\t  p = wi::min_precision (w, sign);\n+\t}\n+      else\n+\tp = wi::min_precision (arg, sign);\n+      return MIN (p, prec);\n+    }\n+  while (CONVERT_EXPR_P (arg)\n+\t && INTEGRAL_TYPE_P (TREE_TYPE (TREE_OPERAND (arg, 0)))\n+\t && TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (arg, 0))) <= prec)\n+    {\n+      arg = TREE_OPERAND (arg, 0);\n+      if (TYPE_PRECISION (TREE_TYPE (arg)) < prec)\n+\t{\n+\t  if (TYPE_UNSIGNED (TREE_TYPE (arg)))\n+\t    sign = UNSIGNED;\n+\t  else if (sign == UNSIGNED && get_range_pos_neg (arg) != 1)\n+\t    return prec + (orig_sign != sign);\n+\t  prec = TYPE_PRECISION (TREE_TYPE (arg));\n+\t}\n+      if (++cnt > 30)\n+\treturn prec + (orig_sign != sign);\n+    }\n+  if (TREE_CODE (arg) != SSA_NAME)\n+    return prec + (orig_sign != sign);\n+  wide_int arg_min, arg_max;\n+  while (get_range_info (arg, &arg_min, &arg_max) != VR_RANGE)\n+    {\n+      gimple g = SSA_NAME_DEF_STMT (arg);\n+      if (is_gimple_assign (g)\n+\t  && CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (g)))\n+\t{\n+\t  tree t = gimple_assign_rhs1 (g);\n+\t  if (INTEGRAL_TYPE_P (TREE_TYPE (t))\n+\t      && TYPE_PRECISION (TREE_TYPE (t)) <= prec)\n+\t    {\n+\t      arg = t;\n+\t      if (TYPE_PRECISION (TREE_TYPE (arg)) < prec)\n+\t\t{\n+\t\t  if (TYPE_UNSIGNED (TREE_TYPE (arg)))\n+\t\t    sign = UNSIGNED;\n+\t\t  else if (sign == UNSIGNED && get_range_pos_neg (arg) != 1)\n+\t\t    return prec + (orig_sign != sign);\n+\t\t  prec = TYPE_PRECISION (TREE_TYPE (arg));\n+\t\t}\n+\t      if (++cnt > 30)\n+\t\treturn prec + (orig_sign != sign);\n+\t      continue;\n+\t    }\n+\t}\n+      return prec + (orig_sign != sign);\n+    }\n+  if (sign == TYPE_SIGN (TREE_TYPE (arg)))\n+    {\n+      int p1 = wi::min_precision (arg_min, sign);\n+      int p2 = wi::min_precision (arg_max, sign);\n+      p1 = MAX (p1, p2);\n+      prec = MIN (prec, p1);\n+    }\n+  else if (sign == UNSIGNED && !wi::neg_p (arg_min, SIGNED))\n+    {\n+      int p = wi::min_precision (arg_max, SIGNED);\n+      prec = MIN (prec, p);\n+    }\n+  return prec + (orig_sign != sign);\n+}\n+\n+/* Helper for expand_*_overflow.  Store RES into the __real__ part\n+   of TARGET.  If RES has larger MODE than __real__ part of TARGET,\n+   set the __imag__ part to 1 if RES doesn't fit into it.  */\n+\n+static void\n+expand_arith_overflow_result_store (tree lhs, rtx target,\n+\t\t\t\t    machine_mode mode, rtx res)\n+{\n+  machine_mode tgtmode = GET_MODE_INNER (GET_MODE (target));\n+  rtx lres = res;\n+  if (tgtmode != mode)\n+    {\n+      rtx_code_label *done_label = gen_label_rtx ();\n+      int uns = TYPE_UNSIGNED (TREE_TYPE (TREE_TYPE (lhs)));\n+      lres = convert_modes (tgtmode, mode, res, uns);\n+      gcc_assert (GET_MODE_PRECISION (tgtmode) < GET_MODE_PRECISION (mode));\n+      emit_cmp_and_jump_insns (res, convert_modes (mode, tgtmode, lres, uns),\n+\t\t\t       EQ, NULL_RTX, mode, false, done_label,\n+\t\t\t       PROB_VERY_LIKELY);\n+      write_complex_part (target, const1_rtx, true);\n+      emit_label (done_label);\n+    }\n+  write_complex_part (target, lres, false);\n+}\n+\n /* Add sub/add overflow checking to the statement STMT.\n    CODE says whether the operation is +, or -.  */\n \n-void\n-ubsan_expand_si_overflow_addsub_check (tree_code code, gimple stmt)\n+static void\n+expand_addsub_overflow (location_t loc, tree_code code, tree lhs,\n+\t\t\ttree arg0, tree arg1, bool unsr_p, bool uns0_p,\n+\t\t\tbool uns1_p, bool is_ubsan)\n {\n-  rtx res, op0, op1;\n-  tree lhs, fn, arg0, arg1;\n-  rtx_code_label *done_label, *do_error;\n-  rtx target = NULL_RTX;\n-\n-  lhs = gimple_call_lhs (stmt);\n-  arg0 = gimple_call_arg (stmt, 0);\n-  arg1 = gimple_call_arg (stmt, 1);\n-  done_label = gen_label_rtx ();\n-  do_error = gen_label_rtx ();\n+  rtx res, target = NULL_RTX;\n+  tree fn;\n+  rtx_code_label *done_label = gen_label_rtx ();\n+  rtx_code_label *do_error = gen_label_rtx ();\n   do_pending_stack_adjust ();\n-  op0 = expand_normal (arg0);\n-  op1 = expand_normal (arg1);\n-\n+  rtx op0 = expand_normal (arg0);\n+  rtx op1 = expand_normal (arg1);\n   machine_mode mode = TYPE_MODE (TREE_TYPE (arg0));\n+  int prec = GET_MODE_PRECISION (mode);\n+  rtx sgn = immed_wide_int_const (wi::min_value (prec, SIGNED), mode);\n+  bool do_xor = false;\n+\n+  if (is_ubsan)\n+    gcc_assert (!unsr_p && !uns0_p && !uns1_p);\n+\n   if (lhs)\n-    target = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n+    {\n+      target = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n+      if (!is_ubsan)\n+\twrite_complex_part (target, const0_rtx, true);\n+    }\n+\n+  /* We assume both operands and result have the same precision\n+     here (GET_MODE_BITSIZE (mode)), S stands for signed type\n+     with that precision, U for unsigned type with that precision,\n+     sgn for unsigned most significant bit in that precision.\n+     s1 is signed first operand, u1 is unsigned first operand,\n+     s2 is signed second operand, u2 is unsigned second operand,\n+     sr is signed result, ur is unsigned result and the following\n+     rules say how to compute result (which is always result of\n+     the operands as if both were unsigned, cast to the right\n+     signedness) and how to compute whether operation overflowed.\n+\n+     s1 + s2 -> sr\n+\tres = (S) ((U) s1 + (U) s2)\n+\tovf = s2 < 0 ? res > s1 : res < s1 (or jump on overflow)\n+     s1 - s2 -> sr\n+\tres = (S) ((U) s1 - (U) s2)\n+\tovf = s2 < 0 ? res < s1 : res > s2 (or jump on overflow)\n+     u1 + u2 -> ur\n+\tres = u1 + u2\n+\tovf = res < u1 (or jump on carry, but RTL opts will handle it)\n+     u1 - u2 -> ur\n+\tres = u1 - u2\n+\tovf = res > u1 (or jump on carry, but RTL opts will handle it)\n+     s1 + u2 -> sr\n+\tres = (S) ((U) s1 + u2)\n+\tovf = ((U) res ^ sgn) < u2\n+     s1 + u2 -> ur\n+\tt1 = (S) (u2 ^ sgn)\n+\tt2 = s1 + t1\n+\tres = (U) t2 ^ sgn\n+\tovf = t1 < 0 ? t2 > s1 : t2 < s1 (or jump on overflow)\n+     s1 - u2 -> sr\n+\tres = (S) ((U) s1 - u2)\n+\tovf = u2 > ((U) s1 ^ sgn)\n+     s1 - u2 -> ur\n+\tres = (U) s1 - u2\n+\tovf = s1 < 0 || u2 > (U) s1\n+     u1 - s2 -> sr\n+\tres = u1 - (U) s2\n+ \tovf = u1 >= ((U) s2 ^ sgn)\n+     u1 - s2 -> ur\n+\tt1 = u1 ^ sgn\n+\tt2 = t1 - (U) s2\n+\tres = t2 ^ sgn\n+\tovf = s2 < 0 ? (S) t2 < (S) t1 : (S) t2 > (S) t1 (or jump on overflow)\n+     s1 + s2 -> ur\n+\tres = (U) s1 + (U) s2\n+\tovf = s2 < 0 ? (s1 | (S) res) < 0) : (s1 & (S) res) < 0)\n+     u1 + u2 -> sr\n+\tres = (S) (u1 + u2)\n+\tovf = (U) res < u2 || res < 0\n+     u1 - u2 -> sr\n+\tres = (S) (u1 - u2)\n+\tovf = u1 >= u2 ? res < 0 : res >= 0\n+     s1 - s2 -> ur\n+\tres = (U) s1 - (U) s2\n+\tovf = s2 >= 0 ? ((s1 | (S) res) < 0) : ((s1 & (S) res) < 0)  */\n+\n+  if (code == PLUS_EXPR && uns0_p && !uns1_p)\n+    {\n+      /* PLUS_EXPR is commutative, if operand signedness differs,\n+\t canonicalize to the first operand being signed and second\n+\t unsigned to simplify following code.  */\n+      rtx tem = op1;\n+      op1 = op0;\n+      op0 = tem;\n+      tree t = arg1;\n+      arg1 = arg0;\n+      arg0 = t;\n+      uns0_p = 0;\n+      uns1_p = 1;\n+    }\n+\n+  /* u1 +- u2 -> ur  */\n+  if (uns0_p && uns1_p && unsr_p)\n+    {\n+      /* Compute the operation.  On RTL level, the addition is always\n+\t unsigned.  */\n+      res = expand_binop (mode, code == PLUS_EXPR ? add_optab : sub_optab,\n+\t\t\t  op0, op1, NULL_RTX, false, OPTAB_LIB_WIDEN);\n+      rtx tem = op0;\n+      /* For PLUS_EXPR, the operation is commutative, so we can pick\n+\t operand to compare against.  For prec <= BITS_PER_WORD, I think\n+\t preferring REG operand is better over CONST_INT, because\n+\t the CONST_INT might enlarge the instruction or CSE would need\n+\t to figure out we'd already loaded it into a register before.\n+\t For prec > BITS_PER_WORD, I think CONST_INT might be more beneficial,\n+\t as then the multi-word comparison can be perhaps simplified.  */\n+      if (code == PLUS_EXPR\n+\t  && (prec <= BITS_PER_WORD\n+\t      ? (CONST_SCALAR_INT_P (op0) && REG_P (op1))\n+\t      : CONST_SCALAR_INT_P (op1)))\n+\ttem = op1;\n+      emit_cmp_and_jump_insns (res, tem, code == PLUS_EXPR ? GEU : LEU,\n+\t\t\t       NULL_RTX, mode, false, done_label,\n+\t\t\t       PROB_VERY_LIKELY);\n+      goto do_error_label;\n+    }\n+\n+  /* s1 +- u2 -> sr  */\n+  if (!uns0_p && uns1_p && !unsr_p)\n+    {\n+      /* Compute the operation.  On RTL level, the addition is always\n+\t unsigned.  */\n+      res = expand_binop (mode, code == PLUS_EXPR ? add_optab : sub_optab,\n+\t\t\t  op0, op1, NULL_RTX, false, OPTAB_LIB_WIDEN);\n+      rtx tem = expand_binop (mode, add_optab,\n+\t\t\t      code == PLUS_EXPR ? res : op0, sgn,\n+\t\t\t      NULL_RTX, false, OPTAB_LIB_WIDEN);\n+      emit_cmp_and_jump_insns (tem, op1, GEU, NULL_RTX, mode, false,\n+\t\t\t       done_label, PROB_VERY_LIKELY);\n+      goto do_error_label;\n+    }\n+\n+  /* s1 + u2 -> ur  */\n+  if (code == PLUS_EXPR && !uns0_p && uns1_p && unsr_p)\n+    {\n+      op1 = expand_binop (mode, add_optab, op1, sgn, NULL_RTX, false,\n+\t\t\t  OPTAB_LIB_WIDEN);\n+      /* As we've changed op1, we have to avoid using the value range\n+\t for the original argument.  */\n+      arg1 = error_mark_node;\n+      do_xor = true;\n+      goto do_signed;\n+    }\n+\n+  /* u1 - s2 -> ur  */\n+  if (code == MINUS_EXPR && uns0_p && !uns1_p && unsr_p)\n+    {\n+      op0 = expand_binop (mode, add_optab, op0, sgn, NULL_RTX, false,\n+\t\t\t  OPTAB_LIB_WIDEN);\n+      /* As we've changed op0, we have to avoid using the value range\n+\t for the original argument.  */\n+      arg0 = error_mark_node;\n+      do_xor = true;\n+      goto do_signed;\n+    }\n+\n+  /* s1 - u2 -> ur  */\n+  if (code == MINUS_EXPR && !uns0_p && uns1_p && unsr_p)\n+    {\n+      /* Compute the operation.  On RTL level, the addition is always\n+\t unsigned.  */\n+      res = expand_binop (mode, sub_optab, op0, op1, NULL_RTX, false,\n+\t\t\t  OPTAB_LIB_WIDEN);\n+      int pos_neg = get_range_pos_neg (arg0);\n+      if (pos_neg == 2)\n+\t/* If ARG0 is known to be always negative, this is always overflow.  */\n+\temit_jump (do_error);\n+      else if (pos_neg == 3)\n+\t/* If ARG0 is not known to be always positive, check at runtime.  */\n+\temit_cmp_and_jump_insns (op0, const0_rtx, LT, NULL_RTX, mode, false,\n+\t\t\t\t do_error, PROB_VERY_UNLIKELY);\n+      emit_cmp_and_jump_insns (op1, op0, LEU, NULL_RTX, mode, false,\n+\t\t\t       done_label, PROB_VERY_LIKELY);\n+      goto do_error_label;\n+    }\n+\n+  /* u1 - s2 -> sr  */\n+  if (code == MINUS_EXPR && uns0_p && !uns1_p && !unsr_p)\n+    {\n+      /* Compute the operation.  On RTL level, the addition is always\n+\t unsigned.  */\n+      res = expand_binop (mode, sub_optab, op0, op1, NULL_RTX, false,\n+\t\t\t  OPTAB_LIB_WIDEN);\n+      rtx tem = expand_binop (mode, add_optab, op1, sgn, NULL_RTX, false,\n+\t\t\t      OPTAB_LIB_WIDEN);\n+      emit_cmp_and_jump_insns (op0, tem, LTU, NULL_RTX, mode, false,\n+\t\t\t       done_label, PROB_VERY_LIKELY);\n+      goto do_error_label;\n+    }\n+\n+  /* u1 + u2 -> sr  */\n+  if (code == PLUS_EXPR && uns0_p && uns1_p && !unsr_p)\n+    {\n+      /* Compute the operation.  On RTL level, the addition is always\n+\t unsigned.  */\n+      res = expand_binop (mode, add_optab, op0, op1, NULL_RTX, false,\n+\t\t\t  OPTAB_LIB_WIDEN);\n+      emit_cmp_and_jump_insns (res, const0_rtx, LT, NULL_RTX, mode, false,\n+\t\t\t       do_error, PROB_VERY_UNLIKELY);\n+      rtx tem = op1;\n+      /* The operation is commutative, so we can pick operand to compare\n+\t against.  For prec <= BITS_PER_WORD, I think preferring REG operand\n+\t is better over CONST_INT, because the CONST_INT might enlarge the\n+\t instruction or CSE would need to figure out we'd already loaded it\n+\t into a register before.  For prec > BITS_PER_WORD, I think CONST_INT\n+\t might be more beneficial, as then the multi-word comparison can be\n+\t perhaps simplified.  */\n+      if (prec <= BITS_PER_WORD\n+\t  ? (CONST_SCALAR_INT_P (op1) && REG_P (op0))\n+\t  : CONST_SCALAR_INT_P (op0))\n+\ttem = op0;\n+      emit_cmp_and_jump_insns (res, tem, GEU, NULL_RTX, mode, false,\n+\t\t\t       done_label, PROB_VERY_LIKELY);\n+      goto do_error_label;\n+    }\n+\n+  /* s1 +- s2 -> ur  */\n+  if (!uns0_p && !uns1_p && unsr_p)\n+    {\n+      /* Compute the operation.  On RTL level, the addition is always\n+\t unsigned.  */\n+      res = expand_binop (mode, code == PLUS_EXPR ? add_optab : sub_optab,\n+\t\t\t  op0, op1, NULL_RTX, false, OPTAB_LIB_WIDEN);\n+      int pos_neg = get_range_pos_neg (arg1);\n+      if (code == PLUS_EXPR)\n+\t{\n+\t  int pos_neg0 = get_range_pos_neg (arg0);\n+\t  if (pos_neg0 != 3 && pos_neg == 3)\n+\t    {\n+\t      rtx tem = op1;\n+\t      op1 = op0;\n+\t      op0 = tem;\n+\t      pos_neg = pos_neg0;\n+\t    }\n+\t}\n+      rtx tem;\n+      if (pos_neg != 3)\n+\t{\n+\t  tem = expand_binop (mode, ((pos_neg == 1) ^ (code == MINUS_EXPR))\n+\t\t\t\t    ? and_optab : ior_optab,\n+\t\t\t      op0, res, NULL_RTX, false, OPTAB_LIB_WIDEN);\n+\t  emit_cmp_and_jump_insns (tem, const0_rtx, GE, NULL_RTX, mode, false,\n+\t\t\t\t   done_label, PROB_VERY_LIKELY);\n+\t}\n+      else\n+\t{\n+\t  rtx_code_label *do_ior_label = gen_label_rtx ();\n+\t  emit_cmp_and_jump_insns (op1, const0_rtx,\n+\t\t\t\t   code == MINUS_EXPR ? GE : LT, NULL_RTX,\n+\t\t\t\t   mode, false, do_ior_label, PROB_EVEN);\n+\t  tem = expand_binop (mode, and_optab, op0, res, NULL_RTX, false,\n+\t\t\t      OPTAB_LIB_WIDEN);\n+\t  emit_cmp_and_jump_insns (tem, const0_rtx, GE, NULL_RTX, mode, false,\n+\t\t\t\t   done_label, PROB_VERY_LIKELY);\n+\t  emit_jump (do_error);\n+\t  emit_label (do_ior_label);\n+\t  tem = expand_binop (mode, ior_optab, op0, res, NULL_RTX, false,\n+\t\t\t      OPTAB_LIB_WIDEN);\n+\t  emit_cmp_and_jump_insns (tem, const0_rtx, GE, NULL_RTX, mode, false,\n+\t\t\t\t   done_label, PROB_VERY_LIKELY);\n+\t}\n+      goto do_error_label;\n+    }\n+\n+  /* u1 - u2 -> sr  */\n+  if (code == MINUS_EXPR && uns0_p && uns1_p && !unsr_p)\n+    {\n+      /* Compute the operation.  On RTL level, the addition is always\n+\t unsigned.  */\n+      res = expand_binop (mode, sub_optab, op0, op1, NULL_RTX, false,\n+\t\t\t  OPTAB_LIB_WIDEN);\n+      rtx_code_label *op0_geu_op1 = gen_label_rtx ();\n+      emit_cmp_and_jump_insns (op0, op1, GEU, NULL_RTX, mode, false,\n+\t\t\t       op0_geu_op1, PROB_EVEN);\n+      emit_cmp_and_jump_insns (res, const0_rtx, LT, NULL_RTX, mode, false,\n+\t\t\t       done_label, PROB_VERY_LIKELY);\n+      emit_jump (do_error);\n+      emit_label (op0_geu_op1);\n+      emit_cmp_and_jump_insns (res, const0_rtx, GE, NULL_RTX, mode, false,\n+\t\t\t       done_label, PROB_VERY_LIKELY);\n+      goto do_error_label;\n+    }\n \n-  enum insn_code icode\n-    = optab_handler (code == PLUS_EXPR ? addv4_optab : subv4_optab, mode);\n+  gcc_assert (!uns0_p && !uns1_p && !unsr_p);\n+\n+  /* s1 +- s2 -> sr  */\n+ do_signed: ;\n+  enum insn_code icode;\n+  icode = optab_handler (code == PLUS_EXPR ? addv4_optab : subv4_optab, mode);\n   if (icode != CODE_FOR_nothing)\n     {\n       struct expand_operand ops[4];\n@@ -289,14 +751,7 @@ ubsan_expand_si_overflow_addsub_check (tree_code code, gimple stmt)\n \t;\n       else if (code == PLUS_EXPR && TREE_CODE (arg0) == SSA_NAME)\n \t{\n-\t  wide_int arg0_min, arg0_max;\n-\t  if (get_range_info (arg0, &arg0_min, &arg0_max) == VR_RANGE)\n-\t    {\n-\t      if (!wi::neg_p (arg0_min, TYPE_SIGN (TREE_TYPE (arg0))))\n-\t\tpos_neg = 1;\n-\t      else if (wi::neg_p (arg0_max, TYPE_SIGN (TREE_TYPE (arg0))))\n-\t\tpos_neg = 2;\n-\t    }\n+\t  pos_neg = get_range_pos_neg (arg0);\n \t  if (pos_neg != 3)\n \t    {\n \t      rtx tem = op0;\n@@ -305,16 +760,7 @@ ubsan_expand_si_overflow_addsub_check (tree_code code, gimple stmt)\n \t    }\n \t}\n       if (pos_neg == 3 && !CONST_INT_P (op1) && TREE_CODE (arg1) == SSA_NAME)\n-\t{\n-\t  wide_int arg1_min, arg1_max;\n-\t  if (get_range_info (arg1, &arg1_min, &arg1_max) == VR_RANGE)\n-\t    {\n-\t      if (!wi::neg_p (arg1_min, TYPE_SIGN (TREE_TYPE (arg1))))\n-\t\tpos_neg = 1;\n-\t      else if (wi::neg_p (arg1_max, TYPE_SIGN (TREE_TYPE (arg1))))\n-\t\tpos_neg = 2;\n-\t    }\n-\t}\n+\tpos_neg = get_range_pos_neg (arg1);\n \n       /* If the op1 is negative, we have to use a different check.  */\n       if (pos_neg == 3)\n@@ -342,34 +788,49 @@ ubsan_expand_si_overflow_addsub_check (tree_code code, gimple stmt)\n \t\t\t\t PROB_VERY_LIKELY);\n     }\n \n+ do_error_label:\n   emit_label (do_error);\n-  /* Expand the ubsan builtin call.  */\n-  push_temp_slots ();\n-  fn = ubsan_build_overflow_builtin (code, gimple_location (stmt),\n-\t\t\t\t     TREE_TYPE (arg0), arg0, arg1);\n-  expand_normal (fn);\n-  pop_temp_slots ();\n-  do_pending_stack_adjust ();\n+  if (is_ubsan)\n+    {\n+      /* Expand the ubsan builtin call.  */\n+      push_temp_slots ();\n+      fn = ubsan_build_overflow_builtin (code, loc, TREE_TYPE (arg0),\n+\t\t\t\t\t arg0, arg1);\n+      expand_normal (fn);\n+      pop_temp_slots ();\n+      do_pending_stack_adjust ();\n+    }\n+  else if (lhs)\n+    write_complex_part (target, const1_rtx, true);\n \n   /* We're done.  */\n   emit_label (done_label);\n \n   if (lhs)\n-    emit_move_insn (target, res);\n+    {\n+      if (is_ubsan)\n+\temit_move_insn (target, res);\n+      else\n+\t{\n+\t  if (do_xor)\n+\t    res = expand_binop (mode, add_optab, res, sgn, NULL_RTX, false,\n+\t\t\t\tOPTAB_LIB_WIDEN);\n+\n+\t  expand_arith_overflow_result_store (lhs, target, mode, res);\n+\t}\n+    }\n }\n \n /* Add negate overflow checking to the statement STMT.  */\n \n-void\n-ubsan_expand_si_overflow_neg_check (gimple stmt)\n+static void\n+expand_neg_overflow (location_t loc, tree lhs, tree arg1, bool is_ubsan)\n {\n   rtx res, op1;\n-  tree lhs, fn, arg1;\n+  tree fn;\n   rtx_code_label *done_label, *do_error;\n   rtx target = NULL_RTX;\n \n-  lhs = gimple_call_lhs (stmt);\n-  arg1 = gimple_call_arg (stmt, 1);\n   done_label = gen_label_rtx ();\n   do_error = gen_label_rtx ();\n \n@@ -378,7 +839,11 @@ ubsan_expand_si_overflow_neg_check (gimple stmt)\n \n   machine_mode mode = TYPE_MODE (TREE_TYPE (arg1));\n   if (lhs)\n-    target = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n+    {\n+      target = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n+      if (!is_ubsan)\n+\twrite_complex_part (target, const0_rtx, true);\n+    }\n \n   enum insn_code icode = optab_handler (negv3_optab, mode);\n   if (icode != CODE_FOR_nothing)\n@@ -420,34 +885,44 @@ ubsan_expand_si_overflow_neg_check (gimple stmt)\n     }\n \n   emit_label (do_error);\n-  /* Expand the ubsan builtin call.  */\n-  push_temp_slots ();\n-  fn = ubsan_build_overflow_builtin (NEGATE_EXPR, gimple_location (stmt),\n-\t\t\t\t     TREE_TYPE (arg1), arg1, NULL_TREE);\n-  expand_normal (fn);\n-  pop_temp_slots ();\n-  do_pending_stack_adjust ();\n+  if (is_ubsan)\n+    {\n+      /* Expand the ubsan builtin call.  */\n+      push_temp_slots ();\n+      fn = ubsan_build_overflow_builtin (NEGATE_EXPR, loc, TREE_TYPE (arg1),\n+\t\t\t\t\t arg1, NULL_TREE);\n+      expand_normal (fn);\n+      pop_temp_slots ();\n+      do_pending_stack_adjust ();\n+    }\n+  else if (lhs)\n+    write_complex_part (target, const1_rtx, true);\n \n   /* We're done.  */\n   emit_label (done_label);\n \n   if (lhs)\n-    emit_move_insn (target, res);\n+    {\n+      if (is_ubsan)\n+\temit_move_insn (target, res);\n+      else\n+\texpand_arith_overflow_result_store (lhs, target, mode, res);\n+    }\n }\n \n /* Add mul overflow checking to the statement STMT.  */\n \n-void\n-ubsan_expand_si_overflow_mul_check (gimple stmt)\n+static void\n+expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n+\t\t     bool unsr_p, bool uns0_p, bool uns1_p, bool is_ubsan)\n {\n   rtx res, op0, op1;\n-  tree lhs, fn, arg0, arg1;\n+  tree fn, type;\n   rtx_code_label *done_label, *do_error;\n   rtx target = NULL_RTX;\n+  signop sign;\n+  enum insn_code icode;\n \n-  lhs = gimple_call_lhs (stmt);\n-  arg0 = gimple_call_arg (stmt, 0);\n-  arg1 = gimple_call_arg (stmt, 1);\n   done_label = gen_label_rtx ();\n   do_error = gen_label_rtx ();\n \n@@ -456,10 +931,243 @@ ubsan_expand_si_overflow_mul_check (gimple stmt)\n   op1 = expand_normal (arg1);\n \n   machine_mode mode = TYPE_MODE (TREE_TYPE (arg0));\n+  bool uns = unsr_p;\n   if (lhs)\n-    target = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n+    {\n+      target = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n+      if (!is_ubsan)\n+\twrite_complex_part (target, const0_rtx, true);\n+    }\n+\n+  if (is_ubsan)\n+    gcc_assert (!unsr_p && !uns0_p && !uns1_p);\n+\n+  /* We assume both operands and result have the same precision\n+     here (GET_MODE_BITSIZE (mode)), S stands for signed type\n+     with that precision, U for unsigned type with that precision,\n+     sgn for unsigned most significant bit in that precision.\n+     s1 is signed first operand, u1 is unsigned first operand,\n+     s2 is signed second operand, u2 is unsigned second operand,\n+     sr is signed result, ur is unsigned result and the following\n+     rules say how to compute result (which is always result of\n+     the operands as if both were unsigned, cast to the right\n+     signedness) and how to compute whether operation overflowed.\n+     main_ovf (false) stands for jump on signed multiplication\n+     overflow or the main algorithm with uns == false.\n+     main_ovf (true) stands for jump on unsigned multiplication\n+     overflow or the main algorithm with uns == true.\n+\n+     s1 * s2 -> sr\n+\tres = (S) ((U) s1 * (U) s2)\n+\tovf = main_ovf (false)\n+     u1 * u2 -> ur\n+\tres = u1 * u2\n+\tovf = main_ovf (true)\n+     s1 * u2 -> ur\n+\tres = (U) s1 * u2\n+\tovf = (s1 < 0 && u2) || main_ovf (true)\n+     u1 * u2 -> sr\n+\tres = (S) (u1 * u2)\n+\tovf = res < 0 || main_ovf (true)\n+     s1 * u2 -> sr\n+\tres = (S) ((U) s1 * u2)\n+\tovf = (S) u2 >= 0 ? main_ovf (false)\n+\t\t\t  : (s1 != 0 && (s1 != -1 || u2 != (U) res))\n+     s1 * s2 -> ur\n+\tt1 = (s1 & s2) < 0 ? (-(U) s1) : ((U) s1)\n+\tt2 = (s1 & s2) < 0 ? (-(U) s2) : ((U) s2)\n+\tres = t1 * t2\n+\tovf = (s1 ^ s2) < 0 ? (s1 && s2) : main_ovf (true)  */\n+\n+  if (uns0_p && !uns1_p)\n+    {\n+      /* Multiplication is commutative, if operand signedness differs,\n+\t canonicalize to the first operand being signed and second\n+\t unsigned to simplify following code.  */\n+      rtx tem = op1;\n+      op1 = op0;\n+      op0 = tem;\n+      tree t = arg1;\n+      arg1 = arg0;\n+      arg0 = t;\n+      uns0_p = 0;\n+      uns1_p = 1;\n+    }\n+\n+  int pos_neg0 = get_range_pos_neg (arg0);\n+  int pos_neg1 = get_range_pos_neg (arg1);\n+\n+  /* s1 * u2 -> ur  */\n+  if (!uns0_p && uns1_p && unsr_p)\n+    {\n+      switch (pos_neg0)\n+\t{\n+\tcase 1:\n+\t  /* If s1 is non-negative, just perform normal u1 * u2 -> ur.  */\n+\t  goto do_main;\n+\tcase 2:\n+\t  /* If s1 is negative, avoid the main code, just multiply and\n+\t     signal overflow if op1 is not 0.  */\n+\t  struct separate_ops ops;\n+\t  ops.code = MULT_EXPR;\n+\t  ops.type = TREE_TYPE (arg1);\n+\t  ops.op0 = make_tree (ops.type, op0);\n+\t  ops.op1 = make_tree (ops.type, op1);\n+\t  ops.op2 = NULL_TREE;\n+\t  ops.location = loc;\n+\t  res = expand_expr_real_2 (&ops, NULL_RTX, mode, EXPAND_NORMAL);\n+\t  emit_cmp_and_jump_insns (op1, const0_rtx, EQ, NULL_RTX, mode,\n+\t\t\t\t   false, done_label, PROB_VERY_LIKELY);\n+\t  goto do_error_label;\n+\tcase 3:\n+\t  rtx_code_label *do_main_label;\n+\t  do_main_label = gen_label_rtx ();\n+\t  emit_cmp_and_jump_insns (op0, const0_rtx, GE, NULL_RTX, mode,\n+\t\t\t\t   false, do_main_label, PROB_VERY_LIKELY);\n+\t  emit_cmp_and_jump_insns (op1, const0_rtx, EQ, NULL_RTX, mode,\n+\t\t\t\t   false, do_main_label, PROB_VERY_LIKELY);\n+\t  write_complex_part (target, const1_rtx, true);\n+\t  emit_label (do_main_label);\n+\t  goto do_main;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+\n+  /* u1 * u2 -> sr  */\n+  if (uns0_p && uns1_p && !unsr_p)\n+    {\n+      uns = true;\n+      /* Rest of handling of this case after res is computed.  */\n+      goto do_main;\n+    }\n+\n+  /* s1 * u2 -> sr  */\n+  if (!uns0_p && uns1_p && !unsr_p)\n+    {\n+      switch (pos_neg1)\n+\t{\n+\tcase 1:\n+\t  goto do_main;\n+\tcase 2:\n+\t  /* If (S) u2 is negative (i.e. u2 is larger than maximum of S,\n+\t     avoid the main code, just multiply and signal overflow\n+\t     unless 0 * u2 or -1 * ((U) Smin).  */\n+\t  struct separate_ops ops;\n+\t  ops.code = MULT_EXPR;\n+\t  ops.type = TREE_TYPE (arg1);\n+\t  ops.op0 = make_tree (ops.type, op0);\n+\t  ops.op1 = make_tree (ops.type, op1);\n+\t  ops.op2 = NULL_TREE;\n+\t  ops.location = loc;\n+\t  res = expand_expr_real_2 (&ops, NULL_RTX, mode, EXPAND_NORMAL);\n+\t  emit_cmp_and_jump_insns (op0, const0_rtx, EQ, NULL_RTX, mode,\n+\t\t\t\t   false, done_label, PROB_VERY_LIKELY);\n+\t  emit_cmp_and_jump_insns (op0, constm1_rtx, NE, NULL_RTX, mode,\n+\t\t\t\t   false, do_error, PROB_VERY_UNLIKELY);\n+\t  int prec;\n+\t  prec = GET_MODE_PRECISION (mode);\n+\t  rtx sgn;\n+\t  sgn = immed_wide_int_const (wi::min_value (prec, SIGNED), mode);\n+\t  emit_cmp_and_jump_insns (op1, sgn, EQ, NULL_RTX, mode,\n+\t\t\t\t   false, done_label, PROB_VERY_LIKELY);\n+\t  goto do_error_label;\n+\tcase 3:\n+\t  /* Rest of handling of this case after res is computed.  */\n+\t  goto do_main;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+\n+  /* s1 * s2 -> ur  */\n+  if (!uns0_p && !uns1_p && unsr_p)\n+    {\n+      rtx tem, tem2;\n+      switch (pos_neg0 | pos_neg1)\n+\t{\n+\tcase 1: /* Both operands known to be non-negative.  */\n+\t  goto do_main;\n+\tcase 2: /* Both operands known to be negative.  */\n+\t  op0 = expand_unop (mode, neg_optab, op0, NULL_RTX, false);\n+\t  op1 = expand_unop (mode, neg_optab, op1, NULL_RTX, false);\n+\t  /* Avoid looking at arg0/arg1 ranges, as we've changed\n+\t     the arguments.  */\n+\t  arg0 = error_mark_node;\n+\t  arg1 = error_mark_node;\n+\t  goto do_main;\n+\tcase 3:\n+\t  if ((pos_neg0 ^ pos_neg1) == 3)\n+\t    {\n+\t      /* If one operand is known to be negative and the other\n+\t\t non-negative, this overflows always, unless the non-negative\n+\t\t one is 0.  Just do normal multiply and set overflow\n+\t\t unless one of the operands is 0.  */\n+\t      struct separate_ops ops;\n+\t      ops.code = MULT_EXPR;\n+\t      ops.type\n+\t\t= build_nonstandard_integer_type (GET_MODE_PRECISION (mode),\n+\t\t\t\t\t\t  1);\n+\t      ops.op0 = make_tree (ops.type, op0);\n+\t      ops.op1 = make_tree (ops.type, op1);\n+\t      ops.op2 = NULL_TREE;\n+\t      ops.location = loc;\n+\t      res = expand_expr_real_2 (&ops, NULL_RTX, mode, EXPAND_NORMAL);\n+\t      tem = expand_binop (mode, and_optab, op0, op1, NULL_RTX, false,\n+\t\t\t\t  OPTAB_LIB_WIDEN);\n+\t      emit_cmp_and_jump_insns (tem, const0_rtx, EQ, NULL_RTX, mode,\n+\t\t\t\t       false, done_label, PROB_VERY_LIKELY);\n+\t      goto do_error_label;\n+\t    }\n+\t  /* The general case, do all the needed comparisons at runtime.  */\n+\t  rtx_code_label *do_main_label, *after_negate_label;\n+\t  rtx rop0, rop1;\n+\t  rop0 = gen_reg_rtx (mode);\n+\t  rop1 = gen_reg_rtx (mode);\n+\t  emit_move_insn (rop0, op0);\n+\t  emit_move_insn (rop1, op1);\n+\t  op0 = rop0;\n+\t  op1 = rop1;\n+\t  do_main_label = gen_label_rtx ();\n+\t  after_negate_label = gen_label_rtx ();\n+\t  tem = expand_binop (mode, and_optab, op0, op1, NULL_RTX, false,\n+\t\t\t      OPTAB_LIB_WIDEN);\n+\t  emit_cmp_and_jump_insns (tem, const0_rtx, GE, NULL_RTX, mode, false,\n+\t\t\t\t   after_negate_label, PROB_VERY_LIKELY);\n+\t  /* Both arguments negative here, negate them and continue with\n+\t     normal unsigned overflow checking multiplication.  */\n+\t  emit_move_insn (op0, expand_unop (mode, neg_optab, op0,\n+\t\t\t\t\t    NULL_RTX, false));\n+\t  emit_move_insn (op1, expand_unop (mode, neg_optab, op1,\n+\t\t\t\t\t    NULL_RTX, false));\n+\t  /* Avoid looking at arg0/arg1 ranges, as we might have changed\n+\t     the arguments.  */\n+\t  arg0 = error_mark_node;\n+\t  arg1 = error_mark_node;\n+\t  emit_jump (do_main_label);\n+\t  emit_label (after_negate_label);\n+\t  tem2 = expand_binop (mode, xor_optab, op0, op1, NULL_RTX, false,\n+\t\t\t       OPTAB_LIB_WIDEN);\n+\t  emit_cmp_and_jump_insns (tem2, const0_rtx, GE, NULL_RTX, mode, false,\n+\t\t\t\t   do_main_label, PROB_VERY_LIKELY);\n+\t  /* One argument is negative here, the other positive.  This\n+\t     overflows always, unless one of the arguments is 0.  But\n+\t     if e.g. s2 is 0, (U) s1 * 0 doesn't overflow, whatever s1\n+\t     is, thus we can keep do_main code oring in overflow as is.  */\n+\t  emit_cmp_and_jump_insns (tem, const0_rtx, EQ, NULL_RTX, mode, false,\n+\t\t\t\t   do_main_label, PROB_VERY_LIKELY);\n+\t  write_complex_part (target, const1_rtx, true);\n+\t  emit_label (do_main_label);\n+\t  goto do_main;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    }\n \n-  enum insn_code icode = optab_handler (mulv4_optab, mode);\n+ do_main:\n+  type = build_nonstandard_integer_type (GET_MODE_PRECISION (mode), uns);\n+  sign = uns ? UNSIGNED : SIGNED;\n+  icode = optab_handler (uns ? umulv4_optab : mulv4_optab, mode);\n   if (icode != CODE_FOR_nothing)\n     {\n       struct expand_operand ops[4];\n@@ -490,59 +1198,69 @@ ubsan_expand_si_overflow_mul_check (gimple stmt)\n   if (icode == CODE_FOR_nothing)\n     {\n       struct separate_ops ops;\n-      machine_mode hmode\n-\t= mode_for_size (GET_MODE_PRECISION (mode) / 2, MODE_INT, 1);\n-      ops.op0 = arg0;\n-      ops.op1 = arg1;\n+      int prec = GET_MODE_PRECISION (mode);\n+      machine_mode hmode = mode_for_size (prec / 2, MODE_INT, 1);\n+      ops.op0 = make_tree (type, op0);\n+      ops.op1 = make_tree (type, op1);\n       ops.op2 = NULL_TREE;\n-      ops.location = gimple_location (stmt);\n+      ops.location = loc;\n       if (GET_MODE_2XWIDER_MODE (mode) != VOIDmode\n \t  && targetm.scalar_mode_supported_p (GET_MODE_2XWIDER_MODE (mode)))\n \t{\n \t  machine_mode wmode = GET_MODE_2XWIDER_MODE (mode);\n \t  ops.code = WIDEN_MULT_EXPR;\n \t  ops.type\n-\t    = build_nonstandard_integer_type (GET_MODE_PRECISION (wmode), 0);\n+\t    = build_nonstandard_integer_type (GET_MODE_PRECISION (wmode), uns);\n \n \t  res = expand_expr_real_2 (&ops, NULL_RTX, wmode, EXPAND_NORMAL);\n-\t  rtx hipart = expand_shift (RSHIFT_EXPR, wmode, res,\n-\t\t\t\t     GET_MODE_PRECISION (mode), NULL_RTX, 0);\n+\t  rtx hipart = expand_shift (RSHIFT_EXPR, wmode, res, prec,\n+\t\t\t\t     NULL_RTX, uns);\n \t  hipart = gen_lowpart (mode, hipart);\n \t  res = gen_lowpart (mode, res);\n-\t  rtx signbit = expand_shift (RSHIFT_EXPR, mode, res,\n-\t\t\t\t      GET_MODE_PRECISION (mode) - 1,\n-\t\t\t\t      NULL_RTX, 0);\n-\t  /* RES is low half of the double width result, HIPART\n-\t     the high half.  There was overflow if\n-\t     HIPART is different from RES < 0 ? -1 : 0.  */\n-\t  emit_cmp_and_jump_insns (signbit, hipart, EQ, NULL_RTX, mode,\n-\t\t\t\t   false, done_label, PROB_VERY_LIKELY);\n+\t  if (uns)\n+\t    /* For the unsigned multiplication, there was overflow if\n+\t       HIPART is non-zero.  */\n+\t    emit_cmp_and_jump_insns (hipart, const0_rtx, EQ, NULL_RTX, mode,\n+\t\t\t\t     false, done_label, PROB_VERY_LIKELY);\n+\t  else\n+\t    {\n+\t      rtx signbit = expand_shift (RSHIFT_EXPR, mode, res, prec - 1,\n+\t\t\t\t\t  NULL_RTX, 0);\n+\t      /* RES is low half of the double width result, HIPART\n+\t\t the high half.  There was overflow if\n+\t\t HIPART is different from RES < 0 ? -1 : 0.  */\n+\t      emit_cmp_and_jump_insns (signbit, hipart, EQ, NULL_RTX, mode,\n+\t\t\t\t       false, done_label, PROB_VERY_LIKELY);\n+\t    }\n \t}\n-      else if (hmode != BLKmode\n-\t       && 2 * GET_MODE_PRECISION (hmode) == GET_MODE_PRECISION (mode))\n+      else if (hmode != BLKmode && 2 * GET_MODE_PRECISION (hmode) == prec)\n \t{\n \t  rtx_code_label *large_op0 = gen_label_rtx ();\n \t  rtx_code_label *small_op0_large_op1 = gen_label_rtx ();\n \t  rtx_code_label *one_small_one_large = gen_label_rtx ();\n \t  rtx_code_label *both_ops_large = gen_label_rtx ();\n-\t  rtx_code_label *after_hipart_neg = gen_label_rtx ();\n-\t  rtx_code_label *after_lopart_neg = gen_label_rtx ();\n+\t  rtx_code_label *after_hipart_neg = uns ? NULL : gen_label_rtx ();\n+\t  rtx_code_label *after_lopart_neg = uns ? NULL : gen_label_rtx ();\n \t  rtx_code_label *do_overflow = gen_label_rtx ();\n-\t  rtx_code_label *hipart_different = gen_label_rtx ();\n+\t  rtx_code_label *hipart_different = uns ? NULL : gen_label_rtx ();\n \n \t  unsigned int hprec = GET_MODE_PRECISION (hmode);\n \t  rtx hipart0 = expand_shift (RSHIFT_EXPR, mode, op0, hprec,\n-\t\t\t\t      NULL_RTX, 0);\n+\t\t\t\t      NULL_RTX, uns);\n \t  hipart0 = gen_lowpart (hmode, hipart0);\n \t  rtx lopart0 = gen_lowpart (hmode, op0);\n-\t  rtx signbit0 = expand_shift (RSHIFT_EXPR, hmode, lopart0, hprec - 1,\n-\t\t\t\t       NULL_RTX, 0);\n+\t  rtx signbit0 = const0_rtx;\n+\t  if (!uns)\n+\t    signbit0 = expand_shift (RSHIFT_EXPR, hmode, lopart0, hprec - 1,\n+\t\t\t\t     NULL_RTX, 0);\n \t  rtx hipart1 = expand_shift (RSHIFT_EXPR, mode, op1, hprec,\n-\t\t\t\t      NULL_RTX, 0);\n+\t\t\t\t      NULL_RTX, uns);\n \t  hipart1 = gen_lowpart (hmode, hipart1);\n \t  rtx lopart1 = gen_lowpart (hmode, op1);\n-\t  rtx signbit1 = expand_shift (RSHIFT_EXPR, hmode, lopart1, hprec - 1,\n-\t\t\t\t       NULL_RTX, 0);\n+\t  rtx signbit1 = const0_rtx;\n+\t  if (!uns)\n+\t    signbit1 = expand_shift (RSHIFT_EXPR, hmode, lopart1, hprec - 1,\n+\t\t\t\t     NULL_RTX, 0);\n \n \t  res = gen_reg_rtx (mode);\n \n@@ -560,40 +1278,29 @@ ubsan_expand_si_overflow_mul_check (gimple stmt)\n \t  int op0_sign = 1;\n \t  int op1_sign = 1;\n \n-\t  if (TREE_CODE (arg0) == SSA_NAME)\n-\t    {\n-\t      wide_int arg0_min, arg0_max;\n-\t      if (get_range_info (arg0, &arg0_min, &arg0_max) == VR_RANGE)\n-\t\t{\n-\t\t  unsigned int mprec0 = wi::min_precision (arg0_min, SIGNED);\n-\t\t  unsigned int mprec1 = wi::min_precision (arg0_max, SIGNED);\n-\t\t  if (mprec0 <= hprec && mprec1 <= hprec)\n-\t\t    op0_small_p = true;\n-\t\t  else if (mprec0 <= hprec + 1 && mprec1 <= hprec + 1)\n-\t\t    op0_medium_p = true;\n-\t\t  if (!wi::neg_p (arg0_min, TYPE_SIGN (TREE_TYPE (arg0))))\n-\t\t    op0_sign = 0;\n-\t\t  else if (wi::neg_p (arg0_max, TYPE_SIGN (TREE_TYPE (arg0))))\n-\t\t    op0_sign = -1;\n-\t\t}\n-\t    }\n-\t  if (TREE_CODE (arg1) == SSA_NAME)\n-\t    {\n-\t      wide_int arg1_min, arg1_max;\n-\t      if (get_range_info (arg1, &arg1_min, &arg1_max) == VR_RANGE)\n-\t\t{\n-\t\t  unsigned int mprec0 = wi::min_precision (arg1_min, SIGNED);\n-\t\t  unsigned int mprec1 = wi::min_precision (arg1_max, SIGNED);\n-\t\t  if (mprec0 <= hprec && mprec1 <= hprec)\n-\t\t    op1_small_p = true;\n-\t\t  else if (mprec0 <= hprec + 1 && mprec1 <= hprec + 1)\n-\t\t    op1_medium_p = true;\n-\t\t  if (!wi::neg_p (arg1_min, TYPE_SIGN (TREE_TYPE (arg1))))\n-\t\t    op1_sign = 0;\n-\t\t  else if (wi::neg_p (arg1_max, TYPE_SIGN (TREE_TYPE (arg1))))\n-\t\t    op1_sign = -1;\n-\t\t}\n-\t    }\n+\t  if (pos_neg0 == 1)\n+\t    op0_sign = 0;\n+\t  else if (pos_neg0 == 2)\n+\t    op0_sign = -1;\n+\t  if (pos_neg1 == 1)\n+\t    op1_sign = 0;\n+\t  else if (pos_neg1 == 2)\n+\t    op1_sign = -1;\n+\n+\t  unsigned int mprec0 = prec;\n+\t  if (arg0 != error_mark_node)\n+\t    mprec0 = get_min_precision (arg0, sign);\n+\t  if (mprec0 <= hprec)\n+\t    op0_small_p = true;\n+\t  else if (!uns && mprec0 <= hprec + 1)\n+\t    op0_medium_p = true;\n+\t  unsigned int mprec1 = prec;\n+\t  if (arg1 != error_mark_node)\n+\t    mprec1 = get_min_precision (arg1, sign);\n+\t  if (mprec1 <= hprec)\n+\t    op1_small_p = true;\n+\t  else if (!uns && mprec1 <= hprec + 1)\n+\t    op1_medium_p = true;\n \n \t  int smaller_sign = 1;\n \t  int larger_sign = 1;\n@@ -622,34 +1329,37 @@ ubsan_expand_si_overflow_mul_check (gimple stmt)\n \t\t\t\t     false, small_op0_large_op1,\n \t\t\t\t     PROB_UNLIKELY);\n \n-\t  /* If both op0 and op1 are sign extended from hmode to mode,\n-\t     the multiplication will never overflow.  We can do just one\n-\t     hmode x hmode => mode widening multiplication.  */\n+\t  /* If both op0 and op1 are sign (!uns) or zero (uns) extended from\n+\t     hmode to mode, the multiplication will never overflow.  We can\n+\t     do just one hmode x hmode => mode widening multiplication.  */\n+\t  rtx lopart0s = lopart0, lopart1s = lopart1;\n \t  if (GET_CODE (lopart0) == SUBREG)\n \t    {\n-\t      SUBREG_PROMOTED_VAR_P (lopart0) = 1;\n-\t      SUBREG_PROMOTED_SET (lopart0, 0);\n+\t      lopart0s = shallow_copy_rtx (lopart0);\n+\t      SUBREG_PROMOTED_VAR_P (lopart0s) = 1;\n+\t      SUBREG_PROMOTED_SET (lopart0s, uns ? SRP_UNSIGNED : SRP_SIGNED);\n \t    }\n \t  if (GET_CODE (lopart1) == SUBREG)\n \t    {\n-\t      SUBREG_PROMOTED_VAR_P (lopart1) = 1;\n-\t      SUBREG_PROMOTED_SET (lopart1, 0);\n+\t      lopart1s = shallow_copy_rtx (lopart1);\n+\t      SUBREG_PROMOTED_VAR_P (lopart1s) = 1;\n+\t      SUBREG_PROMOTED_SET (lopart1s, uns ? SRP_UNSIGNED : SRP_SIGNED);\n \t    }\n-\t  tree halfstype = build_nonstandard_integer_type (hprec, 0);\n-\t  ops.op0 = make_tree (halfstype, lopart0);\n-\t  ops.op1 = make_tree (halfstype, lopart1);\n+\t  tree halfstype = build_nonstandard_integer_type (hprec, uns);\n+\t  ops.op0 = make_tree (halfstype, lopart0s);\n+\t  ops.op1 = make_tree (halfstype, lopart1s);\n \t  ops.code = WIDEN_MULT_EXPR;\n-\t  ops.type = TREE_TYPE (arg0);\n+\t  ops.type = type;\n \t  rtx thisres\n \t    = expand_expr_real_2 (&ops, NULL_RTX, mode, EXPAND_NORMAL);\n \t  emit_move_insn (res, thisres);\n \t  emit_jump (done_label);\n \n \t  emit_label (small_op0_large_op1);\n \n-\t  /* If op0 is sign extended from hmode to mode, but op1 is not,\n-\t     just swap the arguments and handle it as op1 sign extended,\n-\t     op0 not.  */\n+\t  /* If op0 is sign (!uns) or zero (uns) extended from hmode to mode,\n+\t     but op1 is not, just swap the arguments and handle it as op1\n+\t     sign/zero extended, op0 not.  */\n \t  rtx larger = gen_reg_rtx (mode);\n \t  rtx hipart = gen_reg_rtx (hmode);\n \t  rtx lopart = gen_reg_rtx (hmode);\n@@ -664,9 +1374,9 @@ ubsan_expand_si_overflow_mul_check (gimple stmt)\n \t    emit_cmp_and_jump_insns (signbit1, hipart1, NE, NULL_RTX, hmode,\n \t\t\t\t     false, both_ops_large, PROB_UNLIKELY);\n \n-\t  /* If op1 is sign extended from hmode to mode, but op0 is not,\n-\t     prepare larger, hipart and lopart pseudos and handle it together\n-\t     with small_op0_large_op1.  */\n+\t  /* If op1 is sign (!uns) or zero (uns) extended from hmode to mode,\n+\t     but op0 is not, prepare larger, hipart and lopart pseudos and\n+\t     handle it together with small_op0_large_op1.  */\n \t  emit_move_insn (larger, op0);\n \t  emit_move_insn (hipart, hipart0);\n \t  emit_move_insn (lopart, lopart1);\n@@ -691,33 +1401,38 @@ ubsan_expand_si_overflow_mul_check (gimple stmt)\n \t  rtx tem = expand_expr_real_2 (&ops, NULL_RTX, mode, EXPAND_NORMAL);\n \t  emit_move_insn (loxhi, tem);\n \n-\t  /* if (hipart < 0) loxhi -= lopart << (bitsize / 2);  */\n-\t  if (larger_sign == 0)\n-\t    emit_jump (after_hipart_neg);\n-\t  else if (larger_sign != -1)\n-\t    emit_cmp_and_jump_insns (hipart, const0_rtx, GE, NULL_RTX, hmode,\n-\t\t\t\t     false, after_hipart_neg, PROB_EVEN);\n-\n-\t  tem = convert_modes (mode, hmode, lopart, 1);\n-\t  tem = expand_shift (LSHIFT_EXPR, mode, tem, hprec, NULL_RTX, 1);\n-\t  tem = expand_simple_binop (mode, MINUS, loxhi, tem, NULL_RTX,\n-\t\t\t\t     1, OPTAB_DIRECT);\n-\t  emit_move_insn (loxhi, tem);\n-\n-\t  emit_label (after_hipart_neg);\n-\n-\t  /* if (lopart < 0) loxhi -= larger;  */\n-\t  if (smaller_sign == 0)\n-\t    emit_jump (after_lopart_neg);\n-\t  else if (smaller_sign != -1)\n-\t    emit_cmp_and_jump_insns (lopart, const0_rtx, GE, NULL_RTX, hmode,\n-\t\t\t\t     false, after_lopart_neg, PROB_EVEN);\n-\n-\t  tem = expand_simple_binop (mode, MINUS, loxhi, larger, NULL_RTX,\n-\t\t\t\t     1, OPTAB_DIRECT);\n-\t  emit_move_insn (loxhi, tem);\n-\n-\t  emit_label (after_lopart_neg);\n+\t  if (!uns)\n+\t    {\n+\t      /* if (hipart < 0) loxhi -= lopart << (bitsize / 2);  */\n+\t      if (larger_sign == 0)\n+\t\temit_jump (after_hipart_neg);\n+\t      else if (larger_sign != -1)\n+\t\temit_cmp_and_jump_insns (hipart, const0_rtx, GE, NULL_RTX,\n+\t\t\t\t\t hmode, false, after_hipart_neg,\n+\t\t\t\t\t PROB_EVEN);\n+\n+\t      tem = convert_modes (mode, hmode, lopart, 1);\n+\t      tem = expand_shift (LSHIFT_EXPR, mode, tem, hprec, NULL_RTX, 1);\n+\t      tem = expand_simple_binop (mode, MINUS, loxhi, tem, NULL_RTX,\n+\t\t\t\t\t 1, OPTAB_DIRECT);\n+\t      emit_move_insn (loxhi, tem);\n+\n+\t      emit_label (after_hipart_neg);\n+\n+\t      /* if (lopart < 0) loxhi -= larger;  */\n+\t      if (smaller_sign == 0)\n+\t\temit_jump (after_lopart_neg);\n+\t      else if (smaller_sign != -1)\n+\t\temit_cmp_and_jump_insns (lopart, const0_rtx, GE, NULL_RTX,\n+\t\t\t\t\t hmode, false, after_lopart_neg,\n+\t\t\t\t\t PROB_EVEN);\n+\n+\t      tem = expand_simple_binop (mode, MINUS, loxhi, larger, NULL_RTX,\n+\t\t\t\t\t 1, OPTAB_DIRECT);\n+\t      emit_move_insn (loxhi, tem);\n+\n+\t      emit_label (after_lopart_neg);\n+\t    }\n \n \t  /* loxhi += (uns) lo0xlo1 >> (bitsize / 2);  */\n \t  tem = expand_shift (RSHIFT_EXPR, mode, lo0xlo1, hprec, NULL_RTX, 1);\n@@ -726,13 +1441,16 @@ ubsan_expand_si_overflow_mul_check (gimple stmt)\n \t  emit_move_insn (loxhi, tem);\n \n \t  /* if (loxhi >> (bitsize / 2)\n-\t\t == (hmode) loxhi >> (bitsize / 2 - 1))  */\n+\t\t == (hmode) loxhi >> (bitsize / 2 - 1))  (if !uns)\n+\t     if (loxhi >> (bitsize / 2) == 0\t\t (if uns).  */\n \t  rtx hipartloxhi = expand_shift (RSHIFT_EXPR, mode, loxhi, hprec,\n \t\t\t\t\t  NULL_RTX, 0);\n \t  hipartloxhi = gen_lowpart (hmode, hipartloxhi);\n-\t  rtx lopartloxhi = gen_lowpart (hmode, loxhi);\n-\t  rtx signbitloxhi = expand_shift (RSHIFT_EXPR, hmode, lopartloxhi,\n-\t\t\t\t\t   hprec - 1, NULL_RTX, 0);\n+\t  rtx signbitloxhi = const0_rtx;\n+\t  if (!uns)\n+\t    signbitloxhi = expand_shift (RSHIFT_EXPR, hmode,\n+\t\t\t\t\t gen_lowpart (hmode, loxhi),\n+\t\t\t\t\t hprec - 1, NULL_RTX, 0);\n \n \t  emit_cmp_and_jump_insns (signbitloxhi, hipartloxhi, NE, NULL_RTX,\n \t\t\t\t   hmode, false, do_overflow,\n@@ -751,109 +1469,369 @@ ubsan_expand_si_overflow_mul_check (gimple stmt)\n \n \t  emit_label (both_ops_large);\n \n-\t  /* If both operands are large (not sign extended from hmode),\n-\t     then perform the full multiplication which will be the result\n-\t     of the operation.  The only cases which don't overflow are\n-\t     some cases where both hipart0 and highpart1 are 0 or -1.  */\n+\t  /* If both operands are large (not sign (!uns) or zero (uns)\n+\t     extended from hmode), then perform the full multiplication\n+\t     which will be the result of the operation.\n+\t     The only cases which don't overflow are for signed multiplication\n+\t     some cases where both hipart0 and highpart1 are 0 or -1.\n+\t     For unsigned multiplication when high parts are both non-zero\n+\t     this overflows always.  */\n \t  ops.code = MULT_EXPR;\n-\t  ops.op0 = make_tree (TREE_TYPE (arg0), op0);\n-\t  ops.op1 = make_tree (TREE_TYPE (arg0), op1);\n+\t  ops.op0 = make_tree (type, op0);\n+\t  ops.op1 = make_tree (type, op1);\n \t  tem = expand_expr_real_2 (&ops, NULL_RTX, mode, EXPAND_NORMAL);\n \t  emit_move_insn (res, tem);\n \n-\t  if (!op0_medium_p)\n+\t  if (!uns)\n \t    {\n-\t      tem = expand_simple_binop (hmode, PLUS, hipart0, const1_rtx,\n-\t\t\t\t\t NULL_RTX, 1, OPTAB_DIRECT);\n-\t      emit_cmp_and_jump_insns (tem, const1_rtx, GTU, NULL_RTX, hmode,\n-\t\t\t\t       true, do_error, PROB_VERY_UNLIKELY);\n-\t    }\n+\t      if (!op0_medium_p)\n+\t\t{\n+\t\t  tem = expand_simple_binop (hmode, PLUS, hipart0, const1_rtx,\n+\t\t\t\t\t     NULL_RTX, 1, OPTAB_DIRECT);\n+\t\t  emit_cmp_and_jump_insns (tem, const1_rtx, GTU, NULL_RTX,\n+\t\t\t\t\t   hmode, true, do_error,\n+\t\t\t\t\t   PROB_VERY_UNLIKELY);\n+\t\t}\n \n-\t  if (!op1_medium_p)\n-\t    {\n-\t      tem = expand_simple_binop (hmode, PLUS, hipart1, const1_rtx,\n-\t\t\t\t\t NULL_RTX, 1, OPTAB_DIRECT);\n-\t      emit_cmp_and_jump_insns (tem, const1_rtx, GTU, NULL_RTX, hmode,\n-\t\t\t\t       true, do_error, PROB_VERY_UNLIKELY);\n-\t    }\n+\t      if (!op1_medium_p)\n+\t\t{\n+\t\t  tem = expand_simple_binop (hmode, PLUS, hipart1, const1_rtx,\n+\t\t\t\t\t     NULL_RTX, 1, OPTAB_DIRECT);\n+\t\t  emit_cmp_and_jump_insns (tem, const1_rtx, GTU, NULL_RTX,\n+\t\t\t\t\t   hmode, true, do_error,\n+\t\t\t\t\t   PROB_VERY_UNLIKELY);\n+\t\t}\n \n-\t  /* At this point hipart{0,1} are both in [-1, 0].  If they are the\n-\t     same, overflow happened if res is negative, if they are different,\n-\t     overflow happened if res is positive.  */\n-\t  if (op0_sign != 1 && op1_sign != 1 && op0_sign != op1_sign)\n-\t    emit_jump (hipart_different);\n-\t  else if (op0_sign == 1 || op1_sign == 1)\n-\t    emit_cmp_and_jump_insns (hipart0, hipart1, NE, NULL_RTX, hmode,\n-\t\t\t\t     true, hipart_different, PROB_EVEN);\n-\n-\t  emit_cmp_and_jump_insns (res, const0_rtx, LT, NULL_RTX, mode, false,\n-\t\t\t\t   do_error, PROB_VERY_UNLIKELY);\n-\t  emit_jump (done_label);\n+\t      /* At this point hipart{0,1} are both in [-1, 0].  If they are\n+\t\t the same, overflow happened if res is negative, if they are\n+\t\t different, overflow happened if res is positive.  */\n+\t      if (op0_sign != 1 && op1_sign != 1 && op0_sign != op1_sign)\n+\t\temit_jump (hipart_different);\n+\t      else if (op0_sign == 1 || op1_sign == 1)\n+\t\temit_cmp_and_jump_insns (hipart0, hipart1, NE, NULL_RTX, hmode,\n+\t\t\t\t\t true, hipart_different, PROB_EVEN);\n \n-\t  emit_label (hipart_different);\n+\t      emit_cmp_and_jump_insns (res, const0_rtx, LT, NULL_RTX, mode,\n+\t\t\t\t       false, do_error, PROB_VERY_UNLIKELY);\n+\t      emit_jump (done_label);\n \n-\t  emit_cmp_and_jump_insns (res, const0_rtx, GE, NULL_RTX, mode, false,\n-\t\t\t\t   do_error, PROB_VERY_UNLIKELY);\n-\t  emit_jump (done_label);\n+\t      emit_label (hipart_different);\n+\n+\t      emit_cmp_and_jump_insns (res, const0_rtx, GE, NULL_RTX, mode,\n+\t\t\t\t       false, do_error, PROB_VERY_UNLIKELY);\n+\t      emit_jump (done_label);\n+\t    }\n \n \t  emit_label (do_overflow);\n \n \t  /* Overflow, do full multiplication and fallthru into do_error.  */\n-\t  ops.op0 = make_tree (TREE_TYPE (arg0), op0);\n-\t  ops.op1 = make_tree (TREE_TYPE (arg0), op1);\n+\t  ops.op0 = make_tree (type, op0);\n+\t  ops.op1 = make_tree (type, op1);\n \t  tem = expand_expr_real_2 (&ops, NULL_RTX, mode, EXPAND_NORMAL);\n \t  emit_move_insn (res, tem);\n \t}\n       else\n \t{\n+\t  gcc_assert (!is_ubsan);\n \t  ops.code = MULT_EXPR;\n-\t  ops.type = TREE_TYPE (arg0);\n+\t  ops.type = type;\n \t  res = expand_expr_real_2 (&ops, NULL_RTX, mode, EXPAND_NORMAL);\n \t  emit_jump (done_label);\n \t}\n     }\n \n+ do_error_label:\n   emit_label (do_error);\n-  /* Expand the ubsan builtin call.  */\n-  push_temp_slots ();\n-  fn = ubsan_build_overflow_builtin (MULT_EXPR, gimple_location (stmt),\n-\t\t\t\t     TREE_TYPE (arg0), arg0, arg1);\n-  expand_normal (fn);\n-  pop_temp_slots ();\n-  do_pending_stack_adjust ();\n+  if (is_ubsan)\n+    {\n+      /* Expand the ubsan builtin call.  */\n+      push_temp_slots ();\n+      fn = ubsan_build_overflow_builtin (MULT_EXPR, loc, TREE_TYPE (arg0),\n+\t\t\t\t\t arg0, arg1);\n+      expand_normal (fn);\n+      pop_temp_slots ();\n+      do_pending_stack_adjust ();\n+    }\n+  else if (lhs)\n+    write_complex_part (target, const1_rtx, true);\n \n   /* We're done.  */\n   emit_label (done_label);\n \n+  /* u1 * u2 -> sr  */\n+  if (uns0_p && uns1_p && !unsr_p)\n+    {\n+      rtx_code_label *all_done_label = gen_label_rtx ();\n+      emit_cmp_and_jump_insns (res, const0_rtx, GE, NULL_RTX, mode,\n+\t\t\t       false, all_done_label, PROB_VERY_LIKELY);\n+      write_complex_part (target, const1_rtx, true);\n+      emit_label (all_done_label);\n+    }\n+\n+  /* s1 * u2 -> sr  */\n+  if (!uns0_p && uns1_p && !unsr_p && pos_neg1 == 3)\n+    {\n+      rtx_code_label *all_done_label = gen_label_rtx ();\n+      rtx_code_label *set_noovf = gen_label_rtx ();\n+      emit_cmp_and_jump_insns (op1, const0_rtx, GE, NULL_RTX, mode,\n+\t\t\t       false, all_done_label, PROB_VERY_LIKELY);\n+      write_complex_part (target, const1_rtx, true);\n+      emit_cmp_and_jump_insns (op0, const0_rtx, EQ, NULL_RTX, mode,\n+\t\t\t       false, set_noovf, PROB_VERY_LIKELY);\n+      emit_cmp_and_jump_insns (op0, constm1_rtx, NE, NULL_RTX, mode,\n+\t\t\t       false, all_done_label, PROB_VERY_UNLIKELY);\n+      emit_cmp_and_jump_insns (op1, res, NE, NULL_RTX, mode,\n+\t\t\t       false, all_done_label, PROB_VERY_UNLIKELY);\n+      emit_label (set_noovf);\n+      write_complex_part (target, const0_rtx, true);\n+      emit_label (all_done_label);\n+    }\n+\n   if (lhs)\n-    emit_move_insn (target, res);\n+    {\n+      if (is_ubsan)\n+\temit_move_insn (target, res);\n+      else\n+\texpand_arith_overflow_result_store (lhs, target, mode, res);\n+    }\n }\n \n /* Expand UBSAN_CHECK_ADD call STMT.  */\n \n static void\n expand_UBSAN_CHECK_ADD (gimple stmt)\n {\n-  ubsan_expand_si_overflow_addsub_check (PLUS_EXPR, stmt);\n+  location_t loc = gimple_location (stmt);\n+  tree lhs = gimple_call_lhs (stmt);\n+  tree arg0 = gimple_call_arg (stmt, 0);\n+  tree arg1 = gimple_call_arg (stmt, 1);\n+  expand_addsub_overflow (loc, PLUS_EXPR, lhs, arg0, arg1,\n+\t\t\t  false, false, false, true);\n }\n \n /* Expand UBSAN_CHECK_SUB call STMT.  */\n \n static void\n expand_UBSAN_CHECK_SUB (gimple stmt)\n {\n-  if (integer_zerop (gimple_call_arg (stmt, 0)))\n-    ubsan_expand_si_overflow_neg_check (stmt);\n+  location_t loc = gimple_location (stmt);\n+  tree lhs = gimple_call_lhs (stmt);\n+  tree arg0 = gimple_call_arg (stmt, 0);\n+  tree arg1 = gimple_call_arg (stmt, 1);\n+  if (integer_zerop (arg0))\n+    expand_neg_overflow (loc, lhs, arg1, true);\n   else\n-    ubsan_expand_si_overflow_addsub_check (MINUS_EXPR, stmt);\n+    expand_addsub_overflow (loc, MINUS_EXPR, lhs, arg0, arg1,\n+\t\t\t    false, false, false, true);\n }\n \n /* Expand UBSAN_CHECK_MUL call STMT.  */\n \n static void\n expand_UBSAN_CHECK_MUL (gimple stmt)\n {\n-  ubsan_expand_si_overflow_mul_check (stmt);\n+  location_t loc = gimple_location (stmt);\n+  tree lhs = gimple_call_lhs (stmt);\n+  tree arg0 = gimple_call_arg (stmt, 0);\n+  tree arg1 = gimple_call_arg (stmt, 1);\n+  expand_mul_overflow (loc, lhs, arg0, arg1, false, false, false, true);\n+}\n+\n+/* Helper function for {ADD,SUB,MUL}_OVERFLOW call stmt expansion.  */\n+\n+static void\n+expand_arith_overflow (enum tree_code code, gimple stmt)\n+{\n+  tree lhs = gimple_call_lhs (stmt);\n+  if (lhs == NULL_TREE)\n+    return;\n+  tree arg0 = gimple_call_arg (stmt, 0);\n+  tree arg1 = gimple_call_arg (stmt, 1);\n+  tree type = TREE_TYPE (TREE_TYPE (lhs));\n+  int uns0_p = TYPE_UNSIGNED (TREE_TYPE (arg0));\n+  int uns1_p = TYPE_UNSIGNED (TREE_TYPE (arg1));\n+  int unsr_p = TYPE_UNSIGNED (type);\n+  int prec0 = TYPE_PRECISION (TREE_TYPE (arg0));\n+  int prec1 = TYPE_PRECISION (TREE_TYPE (arg1));\n+  int precres = TYPE_PRECISION (type);\n+  location_t loc = gimple_location (stmt);\n+  if (!uns0_p && get_range_pos_neg (arg0) == 1)\n+    uns0_p = true;\n+  if (!uns1_p && get_range_pos_neg (arg1) == 1)\n+    uns1_p = true;\n+  int pr = get_min_precision (arg0, uns0_p ? UNSIGNED : SIGNED);\n+  prec0 = MIN (prec0, pr);\n+  pr = get_min_precision (arg1, uns1_p ? UNSIGNED : SIGNED);\n+  prec1 = MIN (prec1, pr);\n+\n+  /* If uns0_p && uns1_p, precop is minimum needed precision\n+     of unsigned type to hold the exact result, otherwise\n+     precop is minimum needed precision of signed type to\n+     hold the exact result.  */\n+  int precop;\n+  if (code == MULT_EXPR)\n+    precop = prec0 + prec1 + (uns0_p != uns1_p);\n+  else\n+    {\n+      if (uns0_p == uns1_p)\n+\tprecop = MAX (prec0, prec1) + 1;\n+      else if (uns0_p)\n+\tprecop = MAX (prec0 + 1, prec1) + 1;\n+      else\n+\tprecop = MAX (prec0, prec1 + 1) + 1;\n+    }\n+  int orig_precres = precres;\n+\n+  do\n+    {\n+      if ((uns0_p && uns1_p)\n+\t  ? ((precop + !unsr_p) <= precres\n+\t     /* u1 - u2 -> ur can overflow, no matter what precision\n+\t\tthe result has.  */\n+\t     && (code != MINUS_EXPR || !unsr_p))\n+\t  : (!unsr_p && precop <= precres))\n+\t{\n+\t  /* The infinity precision result will always fit into result.  */\n+\t  rtx target = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n+\t  write_complex_part (target, const0_rtx, true);\n+\t  enum machine_mode mode = TYPE_MODE (type);\n+\t  struct separate_ops ops;\n+\t  ops.code = code;\n+\t  ops.type = type;\n+\t  ops.op0 = fold_convert_loc (loc, type, arg0);\n+\t  ops.op1 = fold_convert_loc (loc, type, arg1);\n+\t  ops.op2 = NULL_TREE;\n+\t  ops.location = loc;\n+\t  rtx tem = expand_expr_real_2 (&ops, NULL_RTX, mode, EXPAND_NORMAL);\n+\t  expand_arith_overflow_result_store (lhs, target, mode, tem);\n+\t  return;\n+\t}\n+\n+#ifdef WORD_REGISTER_OPERATIONS\n+      /* For sub-word operations, if target doesn't have them, start\n+\t with precres widening right away, otherwise do it only\n+\t if the most simple cases can't be used.  */\n+      if (orig_precres == precres && precres < BITS_PER_WORD)\n+\t;\n+      else\n+#endif\n+      if ((uns0_p && uns1_p && unsr_p && prec0 <= precres && prec1 <= precres)\n+\t  || ((!uns0_p || !uns1_p) && !unsr_p\n+\t      && prec0 + uns0_p <= precres\n+\t      && prec1 + uns1_p <= precres))\n+\t{\n+\t  arg0 = fold_convert_loc (loc, type, arg0);\n+\t  arg1 = fold_convert_loc (loc, type, arg1);\n+\t  switch (code)\n+\t    {\n+\t    case MINUS_EXPR:\n+\t      if (integer_zerop (arg0) && !unsr_p)\n+\t\texpand_neg_overflow (loc, lhs, arg1, false);\n+\t      /* FALLTHRU */\n+\t    case PLUS_EXPR:\n+\t      expand_addsub_overflow (loc, code, lhs, arg0, arg1,\n+\t\t\t\t      unsr_p, unsr_p, unsr_p, false);\n+\t      return;\n+\t    case MULT_EXPR:\n+\t      expand_mul_overflow (loc, lhs, arg0, arg1,\n+\t\t\t\t   unsr_p, unsr_p, unsr_p, false);\n+\t      return;\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\t}\n+\n+      /* For sub-word operations, retry with a wider type first.  */\n+      if (orig_precres == precres && precop <= BITS_PER_WORD)\n+\t{\n+#ifdef WORD_REGISTER_OPERATIONS\n+\t  int p = BITS_PER_WORD;\n+#else\n+\t  int p = precop;\n+#endif\n+\t  enum machine_mode m = smallest_mode_for_size (p, MODE_INT);\n+\t  tree optype = build_nonstandard_integer_type (GET_MODE_PRECISION (m),\n+\t\t\t\t\t\t\tuns0_p && uns1_p\n+\t\t\t\t\t\t\t&& unsr_p);\n+\t  p = TYPE_PRECISION (optype);\n+\t  if (p > precres)\n+\t    {\n+\t      precres = p;\n+\t      unsr_p = TYPE_UNSIGNED (optype);\n+\t      type = optype;\n+\t      continue;\n+\t    }\n+\t}\n+\n+      if (prec0 <= precres && prec1 <= precres)\n+\t{\n+\t  tree types[2];\n+\t  if (unsr_p)\n+\t    {\n+\t      types[0] = build_nonstandard_integer_type (precres, 0);\n+\t      types[1] = type;\n+\t    }\n+\t  else\n+\t    {\n+\t      types[0] = type;\n+\t      types[1] = build_nonstandard_integer_type (precres, 1);\n+\t    }\n+\t  arg0 = fold_convert_loc (loc, types[uns0_p], arg0);\n+\t  arg1 = fold_convert_loc (loc, types[uns1_p], arg1);\n+\t  if (code != MULT_EXPR)\n+\t    expand_addsub_overflow (loc, code, lhs, arg0, arg1, unsr_p,\n+\t\t\t\t    uns0_p, uns1_p, false);\n+\t  else\n+\t    expand_mul_overflow (loc, lhs, arg0, arg1, unsr_p,\n+\t\t\t\t uns0_p, uns1_p, false);\n+\t  return;\n+\t}\n+\n+      /* Retry with a wider type.  */\n+      if (orig_precres == precres)\n+\t{\n+\t  int p = MAX (prec0, prec1);\n+\t  enum machine_mode m = smallest_mode_for_size (p, MODE_INT);\n+\t  tree optype = build_nonstandard_integer_type (GET_MODE_PRECISION (m),\n+\t\t\t\t\t\t\tuns0_p && uns1_p\n+\t\t\t\t\t\t\t&& unsr_p);\n+\t  p = TYPE_PRECISION (optype);\n+\t  if (p > precres)\n+\t    {\n+\t      precres = p;\n+\t      unsr_p = TYPE_UNSIGNED (optype);\n+\t      type = optype;\n+\t      continue;\n+\t    }\n+\t}\n+\n+      gcc_unreachable ();\n+    }\n+  while (1);\n+}\n+\n+/* Expand ADD_OVERFLOW STMT.  */\n+\n+static void\n+expand_ADD_OVERFLOW (gimple stmt)\n+{\n+  expand_arith_overflow (PLUS_EXPR, stmt);\n+}\n+\n+/* Expand SUB_OVERFLOW STMT.  */\n+\n+static void\n+expand_SUB_OVERFLOW (gimple stmt)\n+{\n+  expand_arith_overflow (MINUS_EXPR, stmt);\n+}\n+\n+/* Expand MUL_OVERFLOW STMT.  */\n+\n+static void\n+expand_MUL_OVERFLOW (gimple stmt)\n+{\n+  expand_arith_overflow (MULT_EXPR, stmt);\n }\n \n /* This should get folded in tree-vectorizer.c.  */"}, {"sha": "b966c721d74d9e0394ddffcb048fb0d4e53ae2f5", "filename": "gcc/internal-fn.def", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=1304953e4fa46305d1ce0b884bf2f58e08409ff3", "patch": "@@ -57,3 +57,6 @@ DEF_INTERNAL_FN (UBSAN_OBJECT_SIZE, ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (ABNORMAL_DISPATCHER, ECF_NORETURN, NULL)\n DEF_INTERNAL_FN (BUILTIN_EXPECT, ECF_CONST | ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (ASAN_CHECK, ECF_TM_PURE | ECF_LEAF | ECF_NOTHROW, \".W...\")\n+DEF_INTERNAL_FN (ADD_OVERFLOW, ECF_CONST | ECF_LEAF | ECF_NOTHROW, NULL)\n+DEF_INTERNAL_FN (SUB_OVERFLOW, ECF_CONST | ECF_LEAF | ECF_NOTHROW, NULL)\n+DEF_INTERNAL_FN (MUL_OVERFLOW, ECF_CONST | ECF_LEAF | ECF_NOTHROW, NULL)"}, {"sha": "ed054e2b96df7dd2a676d0c090757ca32286624a", "filename": "gcc/optabs.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Foptabs.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Foptabs.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.def?ref=1304953e4fa46305d1ce0b884bf2f58e08409ff3", "patch": "@@ -190,6 +190,7 @@ OPTAB_D (ctrap_optab, \"ctrap$a4\")\n OPTAB_D (addv4_optab, \"addv$I$a4\")\n OPTAB_D (subv4_optab, \"subv$I$a4\")\n OPTAB_D (mulv4_optab, \"mulv$I$a4\")\n+OPTAB_D (umulv4_optab, \"umulv$I$a4\")\n OPTAB_D (negv3_optab, \"negv$I$a3\")\n OPTAB_D (addptr3_optab, \"addptr$a3\")\n "}, {"sha": "9ec99af67cbe699ca055cd53f7fb60ec0406d1d2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1304953e4fa46305d1ce0b884bf2f58e08409ff3", "patch": "@@ -1,3 +1,31 @@\n+2014-11-12  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c/59708\n+\t* c-c++-common/builtin-arith-overflow-1.c: New test.\n+\t* c-c++-common/torture/builtin-arith-overflow-10.c: New test.\n+\t* c-c++-common/torture/builtin-arith-overflow-11.c: New test.\n+\t* c-c++-common/torture/builtin-arith-overflow-12.c: New test.\n+\t* c-c++-common/torture/builtin-arith-overflow-12.h: New file.\n+\t* c-c++-common/torture/builtin-arith-overflow-13.c: New test.\n+\t* c-c++-common/torture/builtin-arith-overflow-14.c: New test.\n+\t* c-c++-common/torture/builtin-arith-overflow-15.c: New test.\n+\t* c-c++-common/torture/builtin-arith-overflow-16.c: New test.\n+\t* c-c++-common/torture/builtin-arith-overflow-17.c: New test.\n+\t* c-c++-common/torture/builtin-arith-overflow-18.c: New test.\n+\t* c-c++-common/torture/builtin-arith-overflow-1.c: New test.\n+\t* c-c++-common/torture/builtin-arith-overflow-1.h: New file.\n+\t* c-c++-common/torture/builtin-arith-overflow-2.c: New test.\n+\t* c-c++-common/torture/builtin-arith-overflow-3.c: New test.\n+\t* c-c++-common/torture/builtin-arith-overflow-4.c: New test.\n+\t* c-c++-common/torture/builtin-arith-overflow-5.c: New test.\n+\t* c-c++-common/torture/builtin-arith-overflow-6.c: New test.\n+\t* c-c++-common/torture/builtin-arith-overflow-7.c: New test.\n+\t* c-c++-common/torture/builtin-arith-overflow-8.c: New test.\n+\t* c-c++-common/torture/builtin-arith-overflow-9.c: New test.\n+\t* c-c++-common/torture/builtin-arith-overflow.h: New file.\n+\t* gcc.dg/builtin-arith-overflow-1.c: New test.\n+\t* gcc.dg/builtin-arith-overflow-2.c: New test.\n+\n 2014-11-12  Richard Biener  <rguenther@suse.de>\n \n \tPR middle-end/63821"}, {"sha": "69b508386d5de3d6866c7489cd049232b4be9936", "filename": "gcc/testsuite/c-c++-common/builtin-arith-overflow-1.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fbuiltin-arith-overflow-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fbuiltin-arith-overflow-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fbuiltin-arith-overflow-1.c?ref=1304953e4fa46305d1ce0b884bf2f58e08409ff3", "patch": "@@ -0,0 +1,49 @@\n+/* { dg-do compile } */\n+\n+int\n+f1 (void)\n+{\n+  int x = __builtin_add_overflow ();\t/* { dg-error \"not enough arguments to function\" } */\n+  x += __builtin_sub_overflow ();\t/* { dg-error \"not enough arguments to function\" } */\n+  x += __builtin_mul_overflow ();\t/* { dg-error \"not enough arguments to function\" } */\n+  return x;\n+}\n+\n+int\n+f2 (int a, int b, int *c, int d)\n+{\n+  int x = __builtin_add_overflow (a, b, c, d);\t/* { dg-error \"too many arguments to function\" } */\n+  x += __builtin_sub_overflow (a, b, c, d, d, d);\t/* { dg-error \"too many arguments to function\" } */\n+  x += __builtin_mul_overflow (a, b, c, d);\t/* { dg-error \"too many arguments to function\" } */\n+  return x;\n+}\n+\n+enum E { e0 = 0, e1 = 1 };\n+\n+#ifndef __cplusplus\n+#define bool _Bool\n+#endif\n+\n+int\n+f3 (float fa, int a, _Complex long int ca, double fb, void *pb, int b, enum E eb, bool bb, int *c)\n+{\n+  int x = __builtin_add_overflow (fa, b, c);\t/* { dg-error \"argument 1 in call to function\\[^\\n\\r]*does not have integral type\" } */\n+  x += __builtin_sub_overflow (ca, b, c);\t/* { dg-error \"argument 1 in call to function\\[^\\n\\r]*does not have integral type\" } */\n+  x += __builtin_mul_overflow (a, fb, c);\t/* { dg-error \"argument 2 in call to function\\[^\\n\\r]*does not have integral type\" } */\n+  x += __builtin_add_overflow (a, pb, c);\t/* { dg-error \"argument 2 in call to function\\[^\\n\\r]*does not have integral type\" } */\n+  x += __builtin_sub_overflow (a, eb, c);\n+  x += __builtin_mul_overflow (a, bb, c);\n+  return x;\n+}\n+\n+int\n+f4 (float *fp, double *dp, _Complex int *cp, enum E *ep, bool *bp, long long int *llp)\n+{\n+  int x = __builtin_add_overflow (1, 2, fp);\t/* { dg-error \"argument 3 in call to function\\[^\\n\\r]*does not have pointer to integer type\" } */\n+  x += __builtin_sub_overflow (1, 2, dp);\t/* { dg-error \"argument 3 in call to function\\[^\\n\\r]*does not have pointer to integer type\" } */\n+  x += __builtin_mul_overflow (1, 2, cp);\t/* { dg-error \"argument 3 in call to function\\[^\\n\\r]*does not have pointer to integer type\" } */\n+  x += __builtin_add_overflow (1, 2, ep);\t/* { dg-error \"argument 3 in call to function\\[^\\n\\r]*does not have pointer to integer type\" } */\n+  x += __builtin_sub_overflow (1, 2, bp);\t/* { dg-error \"argument 3 in call to function\\[^\\n\\r]*does not have pointer to integer type\" } */\n+  x += __builtin_mul_overflow (1, 2, llp);\n+  return x;\n+}"}, {"sha": "4d90ba5e1dbc94412727996555f185c42e7bdd63", "filename": "gcc/testsuite/c-c++-common/torture/builtin-arith-overflow-1.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-arith-overflow-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-arith-overflow-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-arith-overflow-1.c?ref=1304953e4fa46305d1ce0b884bf2f58e08409ff3", "patch": "@@ -0,0 +1,24 @@\n+/* Test __builtin_{add,sub,mul,{s,u}add,{s,u}sub,{s,u}mul}_overflow.  */\n+/* { dg-do run } */\n+/* { dg-skip-if \"\" { ! run_expensive_tests }  { \"*\" } { \"-O0\" \"-O2\" } } */\n+\n+#include \"builtin-arith-overflow-1.h\"\n+\n+#define U(s, op) s##op\n+TESTS (int, INT_MIN, INT_MAX)\n+#undef U\n+#define U(s, op) op\n+TESTS (int, INT_MIN, INT_MAX)\n+\n+#undef T\n+#define T(n, t1, t2, tr, v1, v2, vr, b, o) t##n##b ();\n+\n+int\n+main ()\n+{\n+  TESTS (int, INT_MIN, INT_MAX)\n+#undef U\n+#define U(s, op) s##op\n+  TESTS (int, INT_MIN, INT_MAX)\n+  return 0;\n+}"}, {"sha": "b7ae82ea85ba5efccfc276461673800c6235296a", "filename": "gcc/testsuite/c-c++-common/torture/builtin-arith-overflow-1.h", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-arith-overflow-1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-arith-overflow-1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-arith-overflow-1.h?ref=1304953e4fa46305d1ce0b884bf2f58e08409ff3", "patch": "@@ -0,0 +1,37 @@\n+#include \"builtin-arith-overflow.h\"\n+\n+#define TESTS(type, min, max) \\\n+ST (100, signed type, 2, 3, 5, U(s, add), 0) \\\n+ST (101, signed type, max, -1, max - 1, U(s, add), 0) \\\n+ST (102, signed type, max, 0, max, U(s, add), 0) \\\n+ST (103, signed type, 1, max, min, U(s, add), 1) \\\n+ST (104, signed type, 0, min, min, U(s, sub), 1) \\\n+ST (110, signed type, 2, 3, -1, U(s, sub), 0) \\\n+ST (111, signed type, max, -1, min, U(s, sub), 1) \\\n+ST (112, signed type, max, 0, max, U(s, sub), 0) \\\n+ST (113, signed type, 1, max, min + 2, U(s, sub), 0) \\\n+ST (114, signed type, max, -1, min, U(s, sub), 1) \\\n+ST (120, signed type, 2, 3, 6, U(s, mul), 0) \\\n+ST (122, signed type, min, -1, min, U(s, mul), 1) \\\n+ST (123, signed type, max, 0, 0, U(s, mul), 0) \\\n+ST (124, signed type, 1, max, max, U(s, mul), 0) \\\n+ST (125, signed type, max, 2, -2, U(s, mul), 1) \\\n+ST (126, signed type, max / 25, 25, max / 25 * 25, U(s, mul), 0) \\\n+ST (127, signed type, max / 25 + 1, 25, max / 25 * 25 + (unsigned type) 25, U(s, mul), 1) \\\n+ST (150, unsigned type, 2, 3, 5, U(u, add), 0) \\\n+ST (151, unsigned type, -1, -1, -2, U(u, add), 1) \\\n+ST (152, unsigned type, -1, 0, -1, U(u, add), 0) \\\n+ST (153, unsigned type, 1, -1, 0, U(u, add), 1) \\\n+ST (154, unsigned type, 0, min, min, U(u, sub), 1) \\\n+ST (160, unsigned type, 2, 3, -1, U(u, sub), 1) \\\n+ST (161, unsigned type, -1, -1, 0, U(u, sub), 0) \\\n+ST (162, unsigned type, -1, 0, -1, U(u, sub), 0) \\\n+ST (163, unsigned type, 1, -1, 2, U(u, sub), 1) \\\n+ST (164, unsigned type, 15, 14, 1, U(u, sub), 0) \\\n+ST (170, unsigned type, 2, 3, 6, U(u, mul), 0) \\\n+ST (171, unsigned type, max, 3, 3 * (unsigned type) max, U(u, mul), 1) \\\n+ST (172, unsigned type, -1, 0, 0, U(u, mul), 0) \\\n+ST (173, unsigned type, 1, -1, -1, U(u, mul), 0) \\\n+ST (174, unsigned type, -1, 2, -2, U(u, mul), 1) \\\n+ST (175, unsigned type, ((unsigned type) -1) / 25, 25, ((unsigned type) -1) / 25 * 25, U(u, mul), 0) \\\n+ST (176, unsigned type, ((unsigned type) -1) / 25 + 1, 25, ((unsigned type) -1) / 25 * 25 + (unsigned type) 25, U(u, mul), 1)"}, {"sha": "6b1c427c91caee11b9acd714042b0a2427aa1e32", "filename": "gcc/testsuite/c-c++-common/torture/builtin-arith-overflow-10.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-arith-overflow-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-arith-overflow-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-arith-overflow-10.c?ref=1304953e4fa46305d1ce0b884bf2f58e08409ff3", "patch": "@@ -0,0 +1,19 @@\n+/* Test __builtin_{add,sub}_overflow on {,un}signed long int.  */\n+/* { dg-do run } */\n+/* { dg-skip-if \"\" { ! run_expensive_tests }  { \"*\" } { \"-O0\" \"-O2\" } } */\n+\n+typedef signed long int S;\n+typedef unsigned long int U;\n+#define COND 1\n+#define SHIFT ((__SIZEOF_LONG__ - 1) * __CHAR_BIT__)\n+#define S_MAX __LONG_MAX__\n+#define S_MIN (-__LONG_MAX__ - 1)\n+#if __SIZEOF_LONG_LONG__ > __SIZEOF_LONG__\n+typedef long long int W;\n+#elif __SIZEOF_INT128__ > __SIZEOF_LONG__\n+typedef __int128 W;\n+#else\n+#undef COND\n+#define COND 0\n+#endif\n+#include \"builtin-arith-overflow-7.c\""}, {"sha": "1e7d4ae34246e238c7d6cdacbcf1c4468bb694b7", "filename": "gcc/testsuite/c-c++-common/torture/builtin-arith-overflow-11.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-arith-overflow-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-arith-overflow-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-arith-overflow-11.c?ref=1304953e4fa46305d1ce0b884bf2f58e08409ff3", "patch": "@@ -0,0 +1,17 @@\n+/* Test __builtin_{add,sub}_overflow on {,un}signed long long int.  */\n+/* { dg-do run } */\n+/* { dg-skip-if \"\" { ! run_expensive_tests }  { \"*\" } { \"-O0\" \"-O2\" } } */\n+\n+typedef signed long long int S;\n+typedef unsigned long long int U;\n+#define COND 1\n+#define SHIFT ((__SIZEOF_LONG_LONG__ - 1) * __CHAR_BIT__)\n+#define S_MAX __LONG_LONG_MAX__\n+#define S_MIN (-__LONG_LONG_MAX__ - 1)\n+#if __SIZEOF_INT128__ > __SIZEOF_LONG_LONG__\n+typedef __int128 W;\n+#else\n+#undef COND\n+#define COND 0\n+#endif\n+#include \"builtin-arith-overflow-7.c\""}, {"sha": "a37d817205be974fae2e9f746f3c67b08653613c", "filename": "gcc/testsuite/c-c++-common/torture/builtin-arith-overflow-12.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-arith-overflow-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-arith-overflow-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-arith-overflow-12.c?ref=1304953e4fa46305d1ce0b884bf2f58e08409ff3", "patch": "@@ -0,0 +1,17 @@\n+/* Test __builtin_{add,sub,mul_overflow.  */\n+/* { dg-do run } */\n+/* { dg-skip-if \"\" { ! run_expensive_tests }  { \"*\" } { \"-O0\" \"-O2\" } } */\n+\n+#include \"builtin-arith-overflow-12.h\"\n+\n+TESTS (int, INT_MIN, INT_MAX)\n+\n+#undef T\n+#define T(n, t1, t2, tr, v1, v2, vr, b, o) t##n##b ();\n+\n+int\n+main ()\n+{\n+  TESTS (int, INT_MIN, INT_MAX)\n+  return 0;\n+}"}, {"sha": "1e48456dd6492828576243f598d4325edca277f1", "filename": "gcc/testsuite/c-c++-common/torture/builtin-arith-overflow-12.h", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-arith-overflow-12.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-arith-overflow-12.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-arith-overflow-12.h?ref=1304953e4fa46305d1ce0b884bf2f58e08409ff3", "patch": "@@ -0,0 +1,80 @@\n+#include \"builtin-arith-overflow.h\"\n+\n+#define TESTS(type, min, max) \\\n+T (100, signed type, unsigned type, unsigned type, -1, 0, 0, mul, 0) \\\n+T (101, signed type, unsigned type, unsigned type, -1, 1, (unsigned type) -1, mul, 1) \\\n+T (102, unsigned type, signed type, unsigned type, 12, -3, (unsigned type) -36, mul, 1) \\\n+T (103, signed type, unsigned type, unsigned type, 3, 4, 12, mul, 0) \\\n+T (104, unsigned type, signed type, unsigned type, (unsigned type) -1 / 12, 12, (unsigned type) -1 / 12 * 12, mul, 0) \\\n+T (105, unsigned type, signed type, unsigned type, (unsigned type) -1 / 12, 13, (unsigned type) -1 / 12 * 13, mul, 1) \\\n+T (106, unsigned type, unsigned type, signed type, 0, 0, 0, mul, 0) \\\n+T (107, unsigned type, unsigned type, signed type, max / 31, 31, (signed type) ((unsigned type) max / 31 * 31), mul, 0) \\\n+T (108, unsigned type, unsigned type, signed type, max / 31, 32, (signed type) ((unsigned type) max / 31 * 32), mul, 1) \\\n+T (109, unsigned type, unsigned type, signed type, max / 31, 65, (signed type) ((unsigned type) max / 31 * 65), mul, 1) \\\n+T (110, signed type, unsigned type, signed type, -1, 7, -7, mul, 0) \\\n+T (111, unsigned type, signed type, signed type, 2, min / 2, min, mul, 0) \\\n+T (112, signed type, unsigned type, signed type, max / 12, 13, (signed type) ((unsigned type) max / 12 * 13), mul, 1) \\\n+T (113, unsigned type, signed type, signed type, (unsigned type) max + 19, 0, 0, mul, 0) \\\n+T (114, signed type, unsigned type, signed type, 0, (unsigned type) max + 1, 0, mul, 0) \\\n+T (115, unsigned type, signed type, signed type, (unsigned type) max + 1, -1, min, mul, 0) \\\n+T (116, signed type, unsigned type, signed type, -1, (unsigned type) max + 2, max, mul, 1) \\\n+T (117, signed type, signed type, unsigned type, min / 64, -64, (unsigned type) min, mul, 0) \\\n+T (118, signed type, signed type, unsigned type, min / 32, -33, ((unsigned type) max + 1) / 32 * 33, mul, 0) \\\n+T (119, signed type, signed type, unsigned type, min / 32, -65, ((unsigned type) max + 1) / 32 * 65, mul, 1) \\\n+T (120, signed type, signed type, unsigned type, -1, -1, 1, mul, 0) \\\n+T (121, signed type, signed type, unsigned type, 0, 0, 0, mul, 0) \\\n+T (122, signed type, signed type, unsigned type, 0, -6, 0, mul, 0) \\\n+T (123, signed type, signed type, unsigned type, -15, 0, 0, mul, 0) \\\n+T (124, signed type, signed type, unsigned type, -1, 1, ~(unsigned type) 0, mul, 1) \\\n+T (125, signed type, signed type, unsigned type, -17, 5, (unsigned type) -17 * 5, mul, 1) \\\n+T (126, signed type, signed type, unsigned type, 7, max / 7, max / 7 * 7, mul, 0) \\\n+T (127, signed type, signed type, unsigned type, max / 7, 8, (unsigned type) max / 7 * 8, mul, 0) \\\n+T (128, signed type, signed type, unsigned type, 15, max / 7, (unsigned type) max / 7 * 15, mul, 1) \\\n+T (129, signed type, unsigned type, signed type, min, 5, min + 5, add, 0) \\\n+T (130, unsigned type, signed type, signed type, ~(unsigned type) 0, min, max, add, 0) \\\n+T (131, signed type, unsigned type, signed type, max, 1, min, add, 1) \\\n+T (132, unsigned type, signed type, signed type, max / 2, max / 2 + 1, max, add, 0) \\\n+T (133, signed type, unsigned type, signed type, max / 2 + 1, max / 2 + 1, min, add, 1) \\\n+T (134, signed type, unsigned type, unsigned type, min, ~(unsigned type) 0, max, add, 0) \\\n+T (135, unsigned type, signed type, unsigned type, ~(unsigned type) 0, min + 1, (unsigned type) max + 1, add, 0) \\\n+T (136, signed type, unsigned type, unsigned type, 1, ~(unsigned type) 0, 0, add, 1) \\\n+T (137, unsigned type, signed type, unsigned type, 2, -3, ~(unsigned type) 0, add, 1) \\\n+T (138, signed type, unsigned type, signed type, min, 1, max, sub, 1) \\\n+T (139, signed type, unsigned type, signed type, min + 1, 1, min, sub, 0) \\\n+T (140, signed type, unsigned type, signed type, max, (unsigned type) max + 1, -1, sub, 0) \\\n+T (141, signed type, unsigned type, signed type, max, ~(unsigned type) 0, min, sub, 0) \\\n+T (142, signed type, unsigned type, signed type, max - 1, ~(unsigned type) 0, max, sub, 1) \\\n+T (143, signed type, unsigned type, unsigned type, -1, 0, ~(unsigned type) 0, sub, 1) \\\n+T (144, signed type, unsigned type, unsigned type, -1, ~(unsigned type) 0, 0, sub, 1) \\\n+T (145, signed type, unsigned type, unsigned type, min, 0, min, sub, 1) \\\n+T (146, signed type, unsigned type, unsigned type, max, max, 0, sub, 0) \\\n+T (147, signed type, unsigned type, unsigned type, max, (unsigned type) max + 1, -1, sub, 1) \\\n+T (148, signed type, unsigned type, unsigned type, max - 1, max, -1, sub, 1) \\\n+T (149, unsigned type, signed type, signed type, 0, max, -max, sub, 0) \\\n+T (150, unsigned type, signed type, signed type, (unsigned type) max + 1, 0, min, sub, 1) \\\n+T (151, unsigned type, signed type, signed type, (unsigned type) max + 1, 1, max, sub, 0) \\\n+T (152, unsigned type, unsigned type, signed type, 0, (unsigned type) max + 1, min, add, 1) \\\n+T (153, signed type, signed type, unsigned type, -1, 0, -1, add, 1) \\\n+T (154, unsigned type, signed type, unsigned type, 5, 6, -1, sub, 1) \\\n+T (155, unsigned type, signed type, unsigned type, ~(unsigned type) 0, max, (unsigned type) max + 1, sub, 0) \\\n+T (156, unsigned type, signed type, unsigned type, (unsigned type) max + 1, min, 0, sub, 1) \\\n+T (157, signed type, signed type, unsigned type, 3, -2, 1, add, 0) \\\n+T (158, signed type, signed type, unsigned type, 3, -4, -1, add, 1) \\\n+T (159, signed type, signed type, unsigned type, -3, -4, -7, add, 1) \\\n+T (160, signed type, signed type, unsigned type, -5, 4, -1, add, 1) \\\n+T (161, signed type, signed type, unsigned type, -5, 5, 0, add, 0) \\\n+T (162, signed type, signed type, unsigned type, min, 1, min + 1, add, 1) \\\n+T (163, unsigned type, unsigned type, signed type, max, 1, min, add, 1) \\\n+T (164, unsigned type, unsigned type, signed type, max - 1, 1, max, add, 0) \\\n+T (165, unsigned type, unsigned type, signed type, ~(unsigned type) 0, ~(unsigned type) 0, ~(unsigned type) 0 - 1, add, 1) \\\n+T (166, unsigned type, unsigned type, signed type, (unsigned type) max + 3, 2, min, sub, 1) \\\n+T (167, unsigned type, unsigned type, signed type, (unsigned type) max + 2, 2, max, sub, 0) \\\n+T (168, unsigned type, unsigned type, signed type, (unsigned type) max + 2, (unsigned type) max + 3, -1, sub, 0) \\\n+T (169, unsigned type, unsigned type, signed type, 0, (unsigned type) max + 1, min, sub, 0) \\\n+T (170, unsigned type, unsigned type, signed type, 0, (unsigned type) max + 2, max, sub, 1) \\\n+T (171, signed type, signed type, unsigned type, 3, 2, 1, sub, 0) \\\n+T (172, signed type, signed type, unsigned type, 3, 4, -1, sub, 1) \\\n+T (173, signed type, signed type, unsigned type, -3, 4, -7, sub, 1) \\\n+T (174, signed type, signed type, unsigned type, -5, -4, -1, sub, 1) \\\n+T (175, signed type, signed type, unsigned type, -5, -5, 0, sub, 0) \\\n+T (176, signed type, signed type, unsigned type, min, -1, min + 1, sub, 1)"}, {"sha": "730b6d964af6a47283d4ce2f57fca6b2eeff6653", "filename": "gcc/testsuite/c-c++-common/torture/builtin-arith-overflow-13.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-arith-overflow-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-arith-overflow-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-arith-overflow-13.c?ref=1304953e4fa46305d1ce0b884bf2f58e08409ff3", "patch": "@@ -0,0 +1,17 @@\n+/* Test __builtin_{add,sub,mul}_overflow.  */\n+/* { dg-do run } */\n+/* { dg-skip-if \"\" { ! run_expensive_tests }  { \"*\" } { \"-O0\" \"-O2\" } } */\n+\n+#include \"builtin-arith-overflow-12.h\"\n+\n+TESTS (long, LONG_MIN, LONG_MAX)\n+\n+#undef T\n+#define T(n, t1, t2, tr, v1, v2, vr, b, o) t##n##b ();\n+\n+int\n+main ()\n+{\n+  TESTS (long, LONG_MIN, LONG_MAX)\n+  return 0;\n+}"}, {"sha": "6f03cf71949069fba7a5708a15228059f71fd3f5", "filename": "gcc/testsuite/c-c++-common/torture/builtin-arith-overflow-14.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-arith-overflow-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-arith-overflow-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-arith-overflow-14.c?ref=1304953e4fa46305d1ce0b884bf2f58e08409ff3", "patch": "@@ -0,0 +1,17 @@\n+/* Test __builtin_{add,sub,mul}_overflow.  */\n+/* { dg-do run } */\n+/* { dg-skip-if \"\" { ! run_expensive_tests }  { \"*\" } { \"-O0\" \"-O2\" } } */\n+\n+#include \"builtin-arith-overflow-12.h\"\n+\n+TESTS (long long, LLONG_MIN, LLONG_MAX)\n+\n+#undef T\n+#define T(n, t1, t2, tr, v1, v2, vr, b, o) t##n##b ();\n+\n+int\n+main ()\n+{\n+  TESTS (long long, LLONG_MIN, LLONG_MAX)\n+  return 0;\n+}"}, {"sha": "3d78994d7dd0eefd9f79cc44ee91cf64bdf395bb", "filename": "gcc/testsuite/c-c++-common/torture/builtin-arith-overflow-15.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-arith-overflow-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-arith-overflow-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-arith-overflow-15.c?ref=1304953e4fa46305d1ce0b884bf2f58e08409ff3", "patch": "@@ -0,0 +1,17 @@\n+/* Test __builtin_{add,sub,mul}_overflow.  */\n+/* { dg-do run } */\n+/* { dg-skip-if \"\" { ! run_expensive_tests }  { \"*\" } { \"-O0\" \"-O2\" } } */\n+\n+#include \"builtin-arith-overflow-12.h\"\n+\n+TESTS (char, SCHAR_MIN, SCHAR_MAX)\n+\n+#undef T\n+#define T(n, t1, t2, tr, v1, v2, vr, b, o) t##n##b ();\n+\n+int\n+main ()\n+{\n+  TESTS (char, SCHAR_MIN, SCHAR_MAX)\n+  return 0;\n+}"}, {"sha": "d148be6507e0fc66c6e68ad18d1492bde158f400", "filename": "gcc/testsuite/c-c++-common/torture/builtin-arith-overflow-16.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-arith-overflow-16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-arith-overflow-16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-arith-overflow-16.c?ref=1304953e4fa46305d1ce0b884bf2f58e08409ff3", "patch": "@@ -0,0 +1,17 @@\n+/* Test __builtin_{add,sub,mul}_overflow.  */\n+/* { dg-do run } */\n+/* { dg-skip-if \"\" { ! run_expensive_tests }  { \"*\" } { \"-O0\" \"-O2\" } } */\n+\n+#include \"builtin-arith-overflow-12.h\"\n+\n+TESTS (short, SHRT_MIN, SHRT_MAX)\n+\n+#undef T\n+#define T(n, t1, t2, tr, v1, v2, vr, b, o) t##n##b ();\n+\n+int\n+main ()\n+{\n+  TESTS (short, SHRT_MIN, SHRT_MAX)\n+  return 0;\n+}"}, {"sha": "3b33e49220c866792dff9042a0e2b2c8a498b607", "filename": "gcc/testsuite/c-c++-common/torture/builtin-arith-overflow-17.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-arith-overflow-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-arith-overflow-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-arith-overflow-17.c?ref=1304953e4fa46305d1ce0b884bf2f58e08409ff3", "patch": "@@ -0,0 +1,20 @@\n+/* Test __builtin_{add,sub,mul}_overflow.  */\n+/* { dg-do run { target int128 } } */\n+/* { dg-skip-if \"\" { ! run_expensive_tests }  { \"*\" } { \"-O0\" \"-O2\" } } */\n+\n+#include \"builtin-arith-overflow-12.h\"\n+\n+#define INT128_MAX ((signed __int128) (((unsigned __int128) 1 << (__SIZEOF_INT128__ * __CHAR_BIT__ - 1)) - 1))\n+#define INT128_MIN (-INT128_MAX - 1)\n+\n+TESTS (__int128, INT128_MIN, INT128_MAX)\n+\n+#undef T\n+#define T(n, t1, t2, tr, v1, v2, vr, b, o) t##n##b ();\n+\n+int\n+main ()\n+{\n+  TESTS (__int128, INT128_MIN, INT128_MAX)\n+  return 0;\n+}"}, {"sha": "cce5b11b7cf7062f7dd2441a12b2a405c9160d72", "filename": "gcc/testsuite/c-c++-common/torture/builtin-arith-overflow-18.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-arith-overflow-18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-arith-overflow-18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-arith-overflow-18.c?ref=1304953e4fa46305d1ce0b884bf2f58e08409ff3", "patch": "@@ -0,0 +1,36 @@\n+/* Test __builtin_{add,sub,mul}_overflow.  */\n+/* { dg-do run } */\n+/* { dg-skip-if \"\" { ! run_expensive_tests }  { \"*\" } { \"-O0\" \"-O2\" } } */\n+\n+#include \"builtin-arith-overflow.h\"\n+\n+#ifdef __SIZEOF_INT128__\n+#define WTYPE __int128\n+#else\n+#define WTYPE long long int\n+#endif\n+\n+#define TESTS \\\n+T (100, signed char, signed char, unsigned WTYPE, -1, 0, -1, add, 1) \\\n+T (101, unsigned char, unsigned char, unsigned WTYPE, 5, 5, 10, add, 0) \\\n+T (102, signed char, unsigned short, unsigned WTYPE, 5, 5, 0, sub, 0) \\\n+T (103, signed char, unsigned short, unsigned WTYPE, 5, 6, -1, sub, 1) \\\n+T (104, signed char, signed char, unsigned WTYPE, -1, -1, 1, mul, 0) \\\n+T (105, unsigned char, signed char, unsigned WTYPE, 17, -2, -34, mul, 1) \\\n+T (106, unsigned WTYPE, signed WTYPE, signed char, 5, -2, -10, mul, 0) \\\n+T (107, long long int, long long int, unsigned char, -3, 5, 2, add, 0) \\\n+T (108, long long int, int, unsigned char, -5, 3, -2, add, 1) \\\n+T (109, int, WTYPE, unsigned char, -3, 5, 2, add, 0) \\\n+T (110, unsigned char, unsigned char, unsigned WTYPE, SCHAR_MAX - 1, (unsigned char) SCHAR_MAX + 4, -5, sub, 1)\n+\n+TESTS\n+\n+#undef T\n+#define T(n, t1, t2, tr, v1, v2, vr, b, o) t##n##b ();\n+\n+int\n+main ()\n+{\n+  TESTS\n+  return 0;\n+}"}, {"sha": "4b51d9eaa04824b5e4e674f09ffb2082f0b3e4a2", "filename": "gcc/testsuite/c-c++-common/torture/builtin-arith-overflow-2.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-arith-overflow-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-arith-overflow-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-arith-overflow-2.c?ref=1304953e4fa46305d1ce0b884bf2f58e08409ff3", "patch": "@@ -0,0 +1,24 @@\n+/* Test __builtin_{add,sub,mul,{s,u}addl,{s,u}subl,{s,u}mull}_overflow.  */\n+/* { dg-do run } */\n+/* { dg-skip-if \"\" { ! run_expensive_tests }  { \"*\" } { \"-O0\" \"-O2\" } } */\n+\n+#include \"builtin-arith-overflow-1.h\"\n+\n+#define U(s, op) s##op##l\n+TESTS (long, LONG_MIN, LONG_MAX)\n+#undef U\n+#define U(s, op) op\n+TESTS (long, LONG_MIN, LONG_MAX)\n+\n+#undef T\n+#define T(n, t1, t2, tr, v1, v2, vr, b, o) t##n##b ();\n+\n+int\n+main ()\n+{\n+  TESTS (long, LONG_MIN, LONG_MAX)\n+#undef U\n+#define U(s, op) s##op##l\n+  TESTS (long, LONG_MIN, LONG_MAX)\n+  return 0;\n+}"}, {"sha": "cc1a44117ad070e4117dee0027bb024818159ef3", "filename": "gcc/testsuite/c-c++-common/torture/builtin-arith-overflow-3.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-arith-overflow-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-arith-overflow-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-arith-overflow-3.c?ref=1304953e4fa46305d1ce0b884bf2f58e08409ff3", "patch": "@@ -0,0 +1,24 @@\n+/* Test __builtin_{add,sub,mul,{s,u}addll,{s,u}subll,{s,u}mulll}_overflow.  */\n+/* { dg-do run } */\n+/* { dg-skip-if \"\" { ! run_expensive_tests }  { \"*\" } { \"-O0\" \"-O2\" } } */\n+\n+#include \"builtin-arith-overflow-1.h\"\n+\n+#define U(s, op) s##op##ll\n+TESTS (long long, LLONG_MIN, LLONG_MAX)\n+#undef U\n+#define U(s, op) op\n+TESTS (long long, LLONG_MIN, LLONG_MAX)\n+\n+#undef T\n+#define T(n, t1, t2, tr, v1, v2, vr, b, o) t##n##b ();\n+\n+int\n+main ()\n+{\n+  TESTS (long long, LLONG_MIN, LLONG_MAX)\n+#undef U\n+#define U(s, op) s##op##ll\n+  TESTS (long long, LLONG_MIN, LLONG_MAX)\n+  return 0;\n+}"}, {"sha": "6d35aa1ae153410a9248cbdc24d7e5d2cb738350", "filename": "gcc/testsuite/c-c++-common/torture/builtin-arith-overflow-4.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-arith-overflow-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-arith-overflow-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-arith-overflow-4.c?ref=1304953e4fa46305d1ce0b884bf2f58e08409ff3", "patch": "@@ -0,0 +1,18 @@\n+/* Test __builtin_{add,sub,mul}_overflow.  */\n+/* { dg-do run } */\n+/* { dg-skip-if \"\" { ! run_expensive_tests }  { \"*\" } { \"-O0\" \"-O2\" } } */\n+\n+#include \"builtin-arith-overflow-1.h\"\n+\n+#define U(s, op) op\n+TESTS (char, SCHAR_MIN, SCHAR_MAX)\n+\n+#undef T\n+#define T(n, t1, t2, tr, v1, v2, vr, b, o) t##n##b ();\n+\n+int\n+main ()\n+{\n+  TESTS (char, SCHAR_MIN, SCHAR_MAX)\n+  return 0;\n+}"}, {"sha": "fd5c7c981c4aa3f44158c479751e67dfd53e5815", "filename": "gcc/testsuite/c-c++-common/torture/builtin-arith-overflow-5.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-arith-overflow-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-arith-overflow-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-arith-overflow-5.c?ref=1304953e4fa46305d1ce0b884bf2f58e08409ff3", "patch": "@@ -0,0 +1,18 @@\n+/* Test __builtin_{add,sub,mul}_overflow.  */\n+/* { dg-do run } */\n+/* { dg-skip-if \"\" { ! run_expensive_tests }  { \"*\" } { \"-O0\" \"-O2\" } } */\n+\n+#include \"builtin-arith-overflow-1.h\"\n+\n+#define U(s, op) op\n+TESTS (short, SHRT_MIN, SHRT_MAX)\n+\n+#undef T\n+#define T(n, t1, t2, tr, v1, v2, vr, b, o) t##n##b ();\n+\n+int\n+main ()\n+{\n+  TESTS (short, SHRT_MIN, SHRT_MAX)\n+  return 0;\n+}"}, {"sha": "e2661e771491ce87ffa306b356867941e2089ce9", "filename": "gcc/testsuite/c-c++-common/torture/builtin-arith-overflow-6.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-arith-overflow-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-arith-overflow-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-arith-overflow-6.c?ref=1304953e4fa46305d1ce0b884bf2f58e08409ff3", "patch": "@@ -0,0 +1,21 @@\n+/* Test __builtin_{add,sub,mul}_overflow.  */\n+/* { dg-do run { target int128 } } */\n+/* { dg-skip-if \"\" { ! run_expensive_tests }  { \"*\" } { \"-O0\" \"-O2\" } } */\n+\n+#include \"builtin-arith-overflow-1.h\"\n+\n+#define INT128_MAX ((signed __int128) (((unsigned __int128) 1 << (__SIZEOF_INT128__ * __CHAR_BIT__ - 1)) - 1))\n+#define INT128_MIN (-INT128_MAX - 1)\n+\n+#define U(s, op) op\n+TESTS (__int128, INT128_MIN, INT128_MAX)\n+\n+#undef T\n+#define T(n, t1, t2, tr, v1, v2, vr, b, o) t##n##b ();\n+\n+int\n+main ()\n+{\n+  TESTS (__int128, INT128_MIN, INT128_MAX)\n+  return 0;\n+}"}, {"sha": "6f61d7c553c3511e2cbcf11298042c2c830b1561", "filename": "gcc/testsuite/c-c++-common/torture/builtin-arith-overflow-7.c", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-arith-overflow-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-arith-overflow-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-arith-overflow-7.c?ref=1304953e4fa46305d1ce0b884bf2f58e08409ff3", "patch": "@@ -0,0 +1,80 @@\n+/* Test __builtin_{add,sub}_overflow on {,un}signed char.  */\n+/* { dg-do run } */\n+/* { dg-skip-if \"\" { ! run_expensive_tests }  { \"*\" } { \"-O0\" \"-O2\" } } */\n+\n+#define UCHAR_MAX ((unsigned char) ~0)\n+#ifndef SHIFT\n+typedef signed char S;\n+typedef unsigned char U;\n+typedef int W;\n+#define SHIFT 0\n+#define S_MAX __SCHAR_MAX__\n+#define S_MIN (-__SCHAR_MAX__ - 1)\n+#define COND (__SIZEOF_INT__ > 1)\n+#endif\n+\n+#define F(n, t1, t2, tr, b) \\\n+__attribute__((noinline, noclone)) tr\t\t\\\n+n (t1 x, t2 y, int *ovf)\t\t\t\\\n+{\t\t\t\t\t\t\\\n+  tr res;\t\t\t\t\t\\\n+  *ovf = __builtin_##b##_overflow (x, y, &res);\t\\\n+  return res;\t\t\t\t\t\\\n+}\n+\n+F (spses, S, S, S, add)\n+F (upueu, U, U, U, add)\n+F (spseu, S, S, U, add)\n+F (upues, U, U, S, add)\n+F (spues, S, U, S, add)\n+F (upses, U, S, S, add)\n+F (spueu, S, U, U, add)\n+F (upseu, U, S, U, add)\n+F (ssses, S, S, S, sub)\n+F (usueu, U, U, U, sub)\n+F (ssseu, S, S, U, sub)\n+F (usues, U, U, S, sub)\n+F (ssues, S, U, S, sub)\n+F (usses, U, S, S, sub)\n+F (ssueu, S, U, U, sub)\n+F (usseu, U, S, U, sub)\n+\n+int\n+main ()\n+{\n+#if COND\n+  int i, j;\n+  for (i = 0; i < UCHAR_MAX; i++)\n+    for (j = 0; j < UCHAR_MAX; j++)\n+      {\n+\tS s1 = ((W) i << SHIFT) + S_MIN;\n+\tU u1 = ((W) i << SHIFT);\n+\tS s2 = ((W) j << SHIFT) + S_MIN;\n+\tU u2 = ((W) j << SHIFT);\n+\tW w;\n+\tint ovf;\n+#define T(n, t1, t2, tr, op) \\\n+\tw = ((W) t1##1) op ((W) t2##2);\t\t\\\n+\tif (n (t1##1, t2##2, &ovf) != (tr) w\t\\\n+\t    || ovf != (w != (tr) w))\t\t\\\n+\t  __builtin_abort ();\n+\tT (spses, s, s, S, +)\n+\tT (upueu, u, u, U, +)\n+\tT (spseu, s, s, U, +)\n+\tT (upues, u, u, S, +)\n+\tT (spues, s, u, S, +)\n+\tT (upses, u, s, S, +)\n+\tT (spueu, s, u, U, +)\n+\tT (upseu, u, s, U, +)\n+\tT (ssses, s, s, S, -)\n+\tT (usueu, u, u, U, -)\n+\tT (ssseu, s, s, U, -)\n+\tT (usues, u, u, S, -)\n+\tT (ssues, s, u, S, -)\n+\tT (usses, u, s, S, -)\n+\tT (ssueu, s, u, U, -)\n+\tT (usseu, u, s, U, -)\n+      }\n+#endif\n+  return 0;\n+}"}, {"sha": "9e1754fed30ddfd0eb979668f3afa1f98856ca78", "filename": "gcc/testsuite/c-c++-common/torture/builtin-arith-overflow-8.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-arith-overflow-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-arith-overflow-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-arith-overflow-8.c?ref=1304953e4fa46305d1ce0b884bf2f58e08409ff3", "patch": "@@ -0,0 +1,23 @@\n+/* Test __builtin_{add,sub}_overflow on {,un}signed short.  */\n+/* { dg-do run } */\n+/* { dg-skip-if \"\" { ! run_expensive_tests }  { \"*\" } { \"-O0\" \"-O2\" } } */\n+\n+typedef signed short int S;\n+typedef unsigned short int U;\n+#define COND 1\n+#define SHIFT ((__SIZEOF_SHORT__ - 1) * __CHAR_BIT__)\n+#define S_MAX __SHRT_MAX__\n+#define S_MIN (-__SHRT_MAX__ - 1)\n+#if __SIZEOF_INT__ > __SIZEOF_SHORT__\n+typedef int W;\n+#elif __SIZEOF_LONG__ > __SIZEOF_SHORT__\n+typedef long int W;\n+#elif __SIZEOF_LONG_LONG__ > __SIZEOF_SHORT__\n+typedef long long int W;\n+#elif __SIZEOF_INT128__ > __SIZEOF_SHORT__\n+typedef __int128 W;\n+#else\n+#undef COND\n+#define COND 0\n+#endif\n+#include \"builtin-arith-overflow-7.c\""}, {"sha": "80549069718ec96ec704ece018cfb61e1576e9d0", "filename": "gcc/testsuite/c-c++-common/torture/builtin-arith-overflow-9.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-arith-overflow-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-arith-overflow-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-arith-overflow-9.c?ref=1304953e4fa46305d1ce0b884bf2f58e08409ff3", "patch": "@@ -0,0 +1,21 @@\n+/* Test __builtin_{add,sub}_overflow on {,un}signed int.  */\n+/* { dg-do run } */\n+/* { dg-skip-if \"\" { ! run_expensive_tests }  { \"*\" } { \"-O0\" \"-O2\" } } */\n+\n+typedef signed int S;\n+typedef unsigned int U;\n+#define COND 1\n+#define SHIFT ((__SIZEOF_INT__ - 1) * __CHAR_BIT__)\n+#define S_MAX __INT_MAX__\n+#define S_MIN (-__INT_MAX__ - 1)\n+#if __SIZEOF_LONG__ > __SIZEOF_INT__\n+typedef long int W;\n+#elif __SIZEOF_LONG_LONG__ > __SIZEOF_INT__\n+typedef long long int W;\n+#elif __SIZEOF_INT128__ > __SIZEOF_INT__\n+typedef __int128 W;\n+#else\n+#undef COND\n+#define COND 0\n+#endif\n+#include \"builtin-arith-overflow-7.c\""}, {"sha": "9bf3ecf1f212b8426b8d5fc376fa6370486a456e", "filename": "gcc/testsuite/c-c++-common/torture/builtin-arith-overflow.h", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-arith-overflow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-arith-overflow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-arith-overflow.h?ref=1304953e4fa46305d1ce0b884bf2f58e08409ff3", "patch": "@@ -0,0 +1,94 @@\n+#define SCHAR_MAX __SCHAR_MAX__\n+#define SCHAR_MIN (-__SCHAR_MAX__ - 1)\n+#define SHRT_MAX __SHRT_MAX__\n+#define SHRT_MIN (-__SHRT_MAX__ - 1)\n+#define INT_MAX __INT_MAX__\n+#define INT_MIN (-__INT_MAX__ - 1)\n+#define LONG_MAX __LONG_MAX__\n+#define LONG_MIN (-__LONG_MAX__ - 1)\n+#define LLONG_MAX __LONG_LONG_MAX__\n+#define LLONG_MIN (-__LONG_LONG_MAX__ - 1)\n+\n+int v;\n+\n+__attribute__((noinline, noclone)) void\n+bar (void)\n+{\n+  v++;\n+}\n+\n+#define T(n, t1, t2, tr, v1, v2, vr, b, o) \\\n+__attribute__((noinline, noclone)) tr\t\t\\\n+t##n##_1##b (t1 x, t2 y)\t\t\t\\\n+{\t\t\t\t\t\t\\\n+  tr r;\t\t\t\t\t\t\\\n+  if (__builtin_##b##_overflow (x, y, &r))\t\\\n+    bar ();\t\t\t\t\t\\\n+  return r;\t\t\t\t\t\\\n+}\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\\\n+__attribute__((noinline, noclone)) tr\t\t\\\n+t##n##_2##b (t2 y)\t\t\t\t\\\n+{\t\t\t\t\t\t\\\n+  t1 x = (v1);\t\t\t\t\t\\\n+  tr r;\t\t\t\t\t\t\\\n+  if (__builtin_##b##_overflow (x, y, &r))\t\\\n+    bar ();\t\t\t\t\t\\\n+  return r;\t\t\t\t\t\\\n+}\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\\\n+__attribute__((noinline, noclone)) tr\t\t\\\n+t##n##_3##b (t2 y)\t\t\t\t\\\n+{\t\t\t\t\t\t\\\n+  tr r;\t\t\t\t\t\t\\\n+  if (__builtin_##b##_overflow ((t1) (v1), y,\t\\\n+\t\t\t\t&r))\t\t\\\n+    bar ();\t\t\t\t\t\\\n+  return r;\t\t\t\t\t\\\n+}\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\\\n+__attribute__((noinline, noclone)) tr\t\t\\\n+t##n##_4##b (t1 x)\t\t\t\t\\\n+{\t\t\t\t\t\t\\\n+  t2 y = (v2);\t\t\t\t\t\\\n+  tr r;\t\t\t\t\t\t\\\n+  if (__builtin_##b##_overflow (x, y, &r))\t\\\n+    bar ();\t\t\t\t\t\\\n+  return r;\t\t\t\t\t\\\n+}\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\\\n+__attribute__((noinline, noclone)) tr\t\t\\\n+t##n##_5##b (t1 x)\t\t\t\t\\\n+{\t\t\t\t\t\t\\\n+  tr r;\t\t\t\t\t\t\\\n+  if (__builtin_##b##_overflow (x, (t2) (v2),\t\\\n+\t\t\t\t&r))\t\t\\\n+    bar ();\t\t\t\t\t\\\n+  return r;\t\t\t\t\t\\\n+}\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\\\n+__attribute__((noinline, noclone)) void\t\t\\\n+t##n##b (void)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\\\n+  t1 x = (v1);\t\t\t\t\t\\\n+  t2 y = (v2);\t\t\t\t\t\\\n+  tr r1, r2;\t\t\t\t\t\\\n+  v = 0;\t\t\t\t\t\\\n+  if (t##n##_1##b (x, y) != (tr) (vr)\t\t\\\n+      || t##n##_2##b (y) != (tr) (vr)\t\t\\\n+      || t##n##_3##b (y) != (tr) (vr)\t\t\\\n+      || t##n##_4##b (x) != (tr) (vr)\t\t\\\n+      || t##n##_5##b (x) != (tr) (vr))\t\t\\\n+    __builtin_abort ();\t\t\t\t\\\n+  if (__builtin_##b##_overflow (x, y, &r1))\t\\\n+    bar ();\t\t\t\t\t\\\n+  if (r1 != (tr) (vr))\t\t\t\t\\\n+    __builtin_abort ();\t\t\t\t\\\n+  if (__builtin_##b##_overflow ((t1) (v1),\t\\\n+\t\t\t\t(t2) (v2), &r2))\\\n+    bar ();\t\t\t\t\t\\\n+  if (r2 != (tr) (vr) || v != 7 * o)\t\t\\\n+    __builtin_abort ();\t\t\t\t\\\n+}\n+#define ST(n, t, v1, v2, vr, b, o) \\\n+T (n, t, t, t, v1, v2, vr, b, o)"}, {"sha": "b9c1517310eb90c580abc809206a586d42b1fd00", "filename": "gcc/testsuite/gcc.dg/builtin-arith-overflow-1.c", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-arith-overflow-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-arith-overflow-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-arith-overflow-1.c?ref=1304953e4fa46305d1ce0b884bf2f58e08409ff3", "patch": "@@ -0,0 +1,132 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fdump-tree-optimized -g\" } */\n+\n+/* SUB_OVERFLOW should be folded into unsigned subtraction,\n+   because ovf is never used.  */\n+__attribute__((noinline, noclone)) int\n+fn1 (int x, unsigned int y)\n+{\n+  int res;\n+  int ovf = __builtin_sub_overflow (x, y, &res);\n+  int res2 = res;\n+  int res3 = res2 - 2;\n+  (void) ovf;\n+  return res;\n+}\n+\n+/* MUL_OVERFLOW should be folded into unsigned multiplication,\n+   because ovf is never used.  */\n+__attribute__((noinline, noclone)) int\n+fn2 (char x, long int y)\n+{\n+  short int res;\n+  int ovf = __builtin_mul_overflow (x, y, &res);\n+  int res2 = res;\n+  int res3 = res2 - 2;\n+  (void) ovf;\n+  return res;\n+}\n+\n+#if __SIZEOF_INT__ > __SIZEOF_SHORT__ && __SIZEOF_INT__ > 1\n+/* ADD_OVERFLOW should be folded into unsigned addition,\n+   because it never overflows.  */\n+__attribute__((noinline, noclone)) int\n+fn3 (char x, unsigned short y, int *ovf)\n+{\n+  int res;\n+  *ovf = __builtin_add_overflow (x, y, &res);\n+  return res;\n+}\n+#endif\n+\n+/* MUL_OVERFLOW should be folded into unsigned multiplication,\n+   because it never overflows.  */\n+__attribute__((noinline, noclone)) long int\n+fn4 (long int x, long int y, int *ovf)\n+{\n+  long int res;\n+  x &= 65535;\n+  y = (y & 65535) - 32768;\n+  *ovf = __builtin_mul_overflow (x, y, &res);\n+  return res;\n+}\n+\n+#if __SIZEOF_INT__ > 1\n+/* MUL_OVERFLOW should be folded into unsigned multiplication,\n+   because it always overflows.  */\n+__attribute__((noinline, noclone)) signed char\n+fn5 (long int x, long int y, int *ovf)\n+{\n+  signed char res;\n+  x = (x & 63) + (__SCHAR_MAX__ / 4);\n+  y = (y & 3) + 5;\n+  *ovf = __builtin_mul_overflow (x, y, &res);\n+  return res;\n+}\n+#endif\n+\n+/* ADD_OVERFLOW should be folded into unsigned additrion,\n+   because it never overflows.  */\n+__attribute__((noinline, noclone)) unsigned char\n+fn6 (unsigned char x, unsigned char y, int *ovf)\n+{\n+  unsigned char res;\n+  x = (x & 63) + ((unsigned char) ~0 - 66);\n+  y = (y & 3);\n+  *ovf = __builtin_add_overflow (x, y, &res);\n+  return res;\n+}\n+\n+/* ADD_OVERFLOW should be folded into unsigned additrion,\n+   because it always overflows.  */\n+__attribute__((noinline, noclone)) unsigned char\n+fn7 (unsigned char x, unsigned char y, int *ovf)\n+{\n+  unsigned char res;\n+  x = (x & 15) + ((unsigned char) ~0 - 15);\n+  y = (y & 3) + 16;\n+  *ovf = __builtin_add_overflow (x, y, &res);\n+  return res;\n+}\n+\n+int\n+main ()\n+{\n+  int ovf;\n+  if (fn1 (-10, __INT_MAX__) != (int) (-10U - __INT_MAX__)\n+      || fn2 (0, 0) != 0\n+      || fn2 (32, 16383) != (short int) 524256ULL)\n+    __builtin_abort ();\n+#if __SIZEOF_INT__ > __SIZEOF_SHORT__ && __SIZEOF_INT__ > 1\n+  if (fn3 (__SCHAR_MAX__, (unsigned short) ~0, &ovf) != (int) (__SCHAR_MAX__ + (unsigned short) ~0)\n+      || ovf\n+      || fn3 (-__SCHAR_MAX__ - 1, 0, &ovf) != (int) (-__SCHAR_MAX__ - 1)\n+      || ovf)\n+    __builtin_abort ();\n+#endif\n+  if (fn4 (65535, 0, &ovf) != 65535L * -32768 || ovf)\n+    __builtin_abort ();\n+#if __SIZEOF_INT__ > 1\n+  if (fn5 (0, 0, &ovf) != (signed char) (__SCHAR_MAX__ / 4 * 5)\n+      || !ovf\n+      || fn5 (63, 3, &ovf) != (signed char) ((__SCHAR_MAX__ / 4 + 63) * 8)\n+      || !ovf)\n+    __builtin_abort ();\n+#endif\n+  if (fn6 (0, 0, &ovf) != (unsigned char) ~0 - 66\n+      || ovf\n+      || fn6 (63, 3, &ovf) != (unsigned char) ~0\n+      || ovf)\n+    __builtin_abort ();\n+  if (fn7 (0, 0, &ovf) != 0\n+      || !ovf\n+      || fn7 (63, 3, &ovf) != 18\n+      || !ovf)\n+    __builtin_abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"ADD_OVERFLOW\" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-not \"SUB_OVERFLOW\" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-not \"MUL_OVERFLOW\" \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "e64a400d389e42d417f09e4111dde623232f08da", "filename": "gcc/testsuite/gcc.dg/builtin-arith-overflow-2.c", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-arith-overflow-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-arith-overflow-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-arith-overflow-2.c?ref=1304953e4fa46305d1ce0b884bf2f58e08409ff3", "patch": "@@ -0,0 +1,110 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+/* MUL_OVERFLOW should not be folded into unsigned multiplication,\n+   because it sometimes overflows and sometimes does not.  */\n+__attribute__((noinline, noclone)) long int\n+fn1 (long int x, long int y, int *ovf)\n+{\n+  long int res;\n+  x &= 65535;\n+  y = (y & 65535) - (__LONG_MAX__ / 65535 + 32768);\n+  *ovf = __builtin_mul_overflow (x, y, &res);\n+  return res;\n+}\n+\n+/* MUL_OVERFLOW should not be folded into unsigned multiplication,\n+   because it sometimes overflows and sometimes does not.  */\n+__attribute__((noinline, noclone)) signed char\n+fn2 (long int x, long int y, int *ovf)\n+{\n+  signed char res;\n+  x = (x & 63) + (__SCHAR_MAX__ / 4);\n+  y = (y & 3) + 4;\n+  *ovf = __builtin_mul_overflow (x, y, &res);\n+  return res;\n+}\n+\n+/* ADD_OVERFLOW should be folded into unsigned additrion,\n+   because it sometimes overflows and sometimes does not.  */\n+__attribute__((noinline, noclone)) unsigned char\n+fn3 (unsigned char x, unsigned char y, int *ovf)\n+{\n+  unsigned char res;\n+  x = (x & 63) + ((unsigned char) ~0 - 65);\n+  y = (y & 3);\n+  *ovf = __builtin_add_overflow (x, y, &res);\n+  return res;\n+}\n+\n+/* ADD_OVERFLOW should be folded into unsigned additrion,\n+   because it sometimes overflows and sometimes does not.  */\n+__attribute__((noinline, noclone)) unsigned char\n+fn4 (unsigned char x, unsigned char y, int *ovf)\n+{\n+  unsigned char res;\n+  x = (x & 15) + ((unsigned char) ~0 - 16);\n+  y = (y & 3) + 16;\n+  *ovf = __builtin_add_overflow (x, y, &res);\n+  return res;\n+}\n+\n+/* MUL_OVERFLOW should not be folded into unsigned multiplication,\n+   because it sometimes overflows and sometimes does not.  */\n+__attribute__((noinline, noclone)) long int\n+fn5 (long int x, unsigned long int y, int *ovf)\n+{\n+  long int res;\n+  y = -65536UL + (y & 65535);\n+  *ovf = __builtin_mul_overflow (x, y, &res);\n+  return res;\n+}\n+\n+int\n+main ()\n+{\n+  int ovf;\n+  if (fn1 (0, 0, &ovf) != 0\n+      || ovf\n+      || fn1 (65535, 0, &ovf) != (long int) ((__LONG_MAX__ / 65535 + 32768UL) * -65535UL)\n+      || !ovf)\n+    __builtin_abort ();\n+  if (fn2 (0, 0, &ovf) != (signed char) (__SCHAR_MAX__ / 4 * 4U)\n+      || ovf\n+      || fn2 (0, 1, &ovf) != (signed char) (__SCHAR_MAX__ / 4 * 5U)\n+      || !ovf)\n+    __builtin_abort ();\n+  if (fn3 (0, 0, &ovf) != (unsigned char) ~0 - 65\n+      || ovf\n+      || fn3 (63, 2, &ovf) != (unsigned char) ~0\n+      || ovf\n+      || fn3 (62, 3, &ovf) != (unsigned char) ~0\n+      || ovf\n+      || fn3 (63, 3, &ovf) != 0\n+      || !ovf)\n+    __builtin_abort ();\n+  if (fn4 (0, 0, &ovf) != (unsigned char) ~0\n+      || ovf\n+      || fn4 (1, 0, &ovf) != 0\n+      || !ovf\n+      || fn4 (0, 1, &ovf) != 0\n+      || !ovf\n+      || fn4 (63, 3, &ovf) != 17\n+      || !ovf)\n+    __builtin_abort ();\n+  if (fn5 (0, 0, &ovf) != 0\n+      || ovf\n+      || fn5 (1, 0, &ovf) != -65536L\n+      || !ovf\n+      || fn5 (2, 32768, &ovf) != -65536L\n+      || !ovf\n+      || fn5 (4, 32768 + 16384 + 8192, &ovf) != -32768L\n+      || !ovf)\n+    __builtin_abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"ADD_OVERFLOW\" 2 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"SUB_OVERFLOW\" 0 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"MUL_OVERFLOW\" 3 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "6543dc7d26add40a10e3ab31a73f6d88a0d06e3a", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=1304953e4fa46305d1ce0b884bf2f58e08409ff3", "patch": "@@ -85,6 +85,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfgloop.h\"\n #include \"tree-scalar-evolution.h\"\n #include \"tree-chkp.h\"\n+#include \"tree-ssa-propagate.h\"\n+#include \"gimple-fold.h\"\n \n static struct stmt_stats\n {\n@@ -1162,6 +1164,109 @@ remove_dead_stmt (gimple_stmt_iterator *i, basic_block bb)\n   release_defs (stmt);\n }\n \n+/* Helper for maybe_optimize_arith_overflow.  Find in *TP if there are any\n+   uses of data (SSA_NAME) other than REALPART_EXPR referencing it.  */\n+\n+static tree\n+find_non_realpart_uses (tree *tp, int *walk_subtrees, void *data)\n+{\n+  if (TYPE_P (*tp) || TREE_CODE (*tp) == REALPART_EXPR)\n+    *walk_subtrees = 0;\n+  if (*tp == (tree) data)\n+    return *tp;\n+  return NULL_TREE;\n+}\n+\n+/* If the IMAGPART_EXPR of the {ADD,SUB,MUL}_OVERFLOW result is never used,\n+   but REALPART_EXPR is, optimize the {ADD,SUB,MUL}_OVERFLOW internal calls\n+   into plain unsigned {PLUS,MINUS,MULT}_EXPR, and if needed reset debug\n+   uses.  */\n+\n+static void\n+maybe_optimize_arith_overflow (gimple_stmt_iterator *gsi,\n+\t\t\t       enum tree_code subcode)\n+{\n+  gimple stmt = gsi_stmt (*gsi);\n+  tree lhs = gimple_call_lhs (stmt);\n+\n+  if (lhs == NULL || TREE_CODE (lhs) != SSA_NAME)\n+    return;\n+\n+  imm_use_iterator imm_iter;\n+  use_operand_p use_p;\n+  bool has_debug_uses = false;\n+  bool has_realpart_uses = false;\n+  bool has_other_uses = false;\n+  FOR_EACH_IMM_USE_FAST (use_p, imm_iter, lhs)\n+    {\n+      gimple use_stmt = USE_STMT (use_p);\n+      if (is_gimple_debug (use_stmt))\n+\thas_debug_uses = true;\n+      else if (is_gimple_assign (use_stmt)\n+\t       && gimple_assign_rhs_code (use_stmt) == REALPART_EXPR\n+\t       && TREE_OPERAND (gimple_assign_rhs1 (use_stmt), 0) == lhs)\n+\thas_realpart_uses = true;\n+      else\n+\t{\n+\t  has_other_uses = true;\n+\t  break;\n+\t}\n+    }\n+\n+  if (!has_realpart_uses || has_other_uses)\n+    return;\n+\n+  tree arg0 = gimple_call_arg (stmt, 0);\n+  tree arg1 = gimple_call_arg (stmt, 1);\n+  location_t loc = gimple_location (stmt);\n+  tree type = TREE_TYPE (TREE_TYPE (lhs));\n+  tree utype = type;\n+  if (!TYPE_UNSIGNED (type))\n+    utype = build_nonstandard_integer_type (TYPE_PRECISION (type), 1);\n+  tree result = fold_build2_loc (loc, subcode, utype,\n+\t\t\t\t fold_convert_loc (loc, utype, arg0),\n+\t\t\t\t fold_convert_loc (loc, utype, arg1));\n+  result = fold_convert_loc (loc, type, result);\n+\n+  if (has_debug_uses)\n+    {\n+      gimple use_stmt;\n+      FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, lhs)\n+\t{\n+\t  if (!gimple_debug_bind_p (use_stmt))\n+\t    continue;\n+\t  tree v = gimple_debug_bind_get_value (use_stmt);\n+\t  if (walk_tree (&v, find_non_realpart_uses, lhs, NULL))\n+\t    {\n+\t      gimple_debug_bind_reset_value (use_stmt);\n+\t      update_stmt (use_stmt);\n+\t    }\n+\t}\n+    }\n+\n+  if (TREE_CODE (result) == INTEGER_CST && TREE_OVERFLOW (result))\n+    result = drop_tree_overflow (result);\n+  tree overflow = build_zero_cst (type);\n+  tree ctype = build_complex_type (type);\n+  if (TREE_CODE (result) == INTEGER_CST)\n+    result = build_complex (ctype, result, overflow);\n+  else\n+    result = build2_loc (gimple_location (stmt), COMPLEX_EXPR,\n+\t\t\t ctype, result, overflow);\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"Transforming call: \");\n+      print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n+      fprintf (dump_file, \"because the overflow result is never used into: \");\n+      print_generic_stmt (dump_file, result, TDF_SLIM);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+\n+  if (!update_call_from_tree (gsi, result))\n+    gimplify_and_update_call_from_tree (gsi, result);\n+}\n+\n /* Eliminate unnecessary statements. Any instruction not marked as necessary\n    contributes nothing to the program, and can be deleted.  */\n \n@@ -1298,6 +1403,21 @@ eliminate_unnecessary_stmts (void)\n \t\t  update_stmt (stmt);\n \t\t  release_ssa_name (name);\n \t\t}\n+\t      else if (gimple_call_internal_p (stmt))\n+\t\tswitch (gimple_call_internal_fn (stmt))\n+\t\t  {\n+\t\t  case IFN_ADD_OVERFLOW:\n+\t\t    maybe_optimize_arith_overflow (&gsi, PLUS_EXPR);\n+\t\t    break;\n+\t\t  case IFN_SUB_OVERFLOW:\n+\t\t    maybe_optimize_arith_overflow (&gsi, MINUS_EXPR);\n+\t\t    break;\n+\t\t  case IFN_MUL_OVERFLOW:\n+\t\t    maybe_optimize_arith_overflow (&gsi, MULT_EXPR);\n+\t\t    break;\n+\t\t  default:\n+\t\t    break;\n+\t\t  }\n \t    }\n \t}\n     }"}, {"sha": "b2872828334b86aedc05c1eb904b94e3de86cc7d", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 258, "deletions": 61, "changes": 319, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1304953e4fa46305d1ce0b884bf2f58e08409ff3/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=1304953e4fa46305d1ce0b884bf2f58e08409ff3", "patch": "@@ -3754,6 +3754,113 @@ extract_range_from_comparison (value_range_t *vr, enum tree_code code,\n     set_value_range_to_truthvalue (vr, type);\n }\n \n+/* Helper function for simplify_internal_call_using_ranges and\n+   extract_range_basic.  Return true if OP0 SUBCODE OP1 for\n+   SUBCODE {PLUS,MINUS,MULT}_EXPR is known to never overflow or\n+   always overflow.  Set *OVF to true if it is known to always\n+   overflow.  */\n+\n+static bool\n+check_for_binary_op_overflow (enum tree_code subcode, tree type,\n+\t\t\t      tree op0, tree op1, bool *ovf)\n+{\n+  value_range_t vr0 = VR_INITIALIZER;\n+  value_range_t vr1 = VR_INITIALIZER;\n+  if (TREE_CODE (op0) == SSA_NAME)\n+    vr0 = *get_value_range (op0);\n+  else if (TREE_CODE (op0) == INTEGER_CST)\n+    set_value_range_to_value (&vr0, op0, NULL);\n+  else\n+    set_value_range_to_varying (&vr0);\n+\n+  if (TREE_CODE (op1) == SSA_NAME)\n+    vr1 = *get_value_range (op1);\n+  else if (TREE_CODE (op1) == INTEGER_CST)\n+    set_value_range_to_value (&vr1, op1, NULL);\n+  else\n+    set_value_range_to_varying (&vr1);\n+\n+  if (!range_int_cst_p (&vr0)\n+      || TREE_OVERFLOW (vr0.min)\n+      || TREE_OVERFLOW (vr0.max))\n+    {\n+      vr0.min = vrp_val_min (TREE_TYPE (op0));\n+      vr0.max = vrp_val_max (TREE_TYPE (op0));\n+    }\n+  if (!range_int_cst_p (&vr1)\n+      || TREE_OVERFLOW (vr1.min)\n+      || TREE_OVERFLOW (vr1.max))\n+    {\n+      vr1.min = vrp_val_min (TREE_TYPE (op1));\n+      vr1.max = vrp_val_max (TREE_TYPE (op1));\n+    }\n+  *ovf = arith_overflowed_p (subcode, type, vr0.min,\n+\t\t\t     subcode == MINUS_EXPR ? vr1.max : vr1.min);\n+  if (arith_overflowed_p (subcode, type, vr0.max,\n+\t\t\t  subcode == MINUS_EXPR ? vr1.min : vr1.max) != *ovf)\n+    return false;\n+  if (subcode == MULT_EXPR)\n+    {\n+      if (arith_overflowed_p (subcode, type, vr0.min, vr1.max) != *ovf\n+\t  || arith_overflowed_p (subcode, type, vr0.max, vr1.min) != *ovf)\n+\treturn false;\n+    }\n+  if (*ovf)\n+    {\n+      /* So far we found that there is an overflow on the boundaries.\n+\t That doesn't prove that there is an overflow even for all values\n+\t in between the boundaries.  For that compute widest_int range\n+\t of the result and see if it doesn't overlap the range of\n+\t type.  */\n+      widest_int wmin, wmax;\n+      widest_int w[4];\n+      int i;\n+      w[0] = wi::to_widest (vr0.min);\n+      w[1] = wi::to_widest (vr0.max);\n+      w[2] = wi::to_widest (vr1.min);\n+      w[3] = wi::to_widest (vr1.max);\n+      for (i = 0; i < 4; i++)\n+\t{\n+\t  widest_int wt;\n+\t  switch (subcode)\n+\t    {\n+\t    case PLUS_EXPR:\n+\t      wt = wi::add (w[i & 1], w[2 + (i & 2) / 2]);\n+\t      break;\n+\t    case MINUS_EXPR:\n+\t      wt = wi::sub (w[i & 1], w[2 + (i & 2) / 2]);\n+\t      break;\n+\t    case MULT_EXPR:\n+\t      wt = wi::mul (w[i & 1], w[2 + (i & 2) / 2]);\n+\t      break;\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\t  if (i == 0)\n+\t    {\n+\t      wmin = wt;\n+\t      wmax = wt;\n+\t    }\n+\t  else\n+\t    {\n+\t      wmin = wi::smin (wmin, wt);\n+\t      wmax = wi::smax (wmax, wt);\n+\t    }\n+\t}\n+      /* The result of op0 CODE op1 is known to be in range\n+\t [wmin, wmax].  */\n+      widest_int wtmin = wi::to_widest (vrp_val_min (type));\n+      widest_int wtmax = wi::to_widest (vrp_val_max (type));\n+      /* If all values in [wmin, wmax] are smaller than\n+\t [wtmin, wtmax] or all are larger than [wtmin, wtmax],\n+\t the arithmetic operation will always overflow.  */\n+      if (wi::lts_p (wmax, wtmin) || wi::gts_p (wmin, wtmax))\n+\treturn true;\n+      return false;\n+    }\n+  return true;\n+}\n+\n /* Try to derive a nonnegative or nonzero range out of STMT relying\n    primarily on generic routines in fold in conjunction with range data.\n    Store the result in *VR */\n@@ -3943,8 +4050,7 @@ extract_range_basic (value_range_t *vr, gimple stmt)\n \t  break;\n \t}\n     }\n-  else if (is_gimple_call (stmt)\n-\t   && gimple_call_internal_p (stmt))\n+  else if (is_gimple_call (stmt) && gimple_call_internal_p (stmt))\n     {\n       enum tree_code subcode = ERROR_MARK;\n       switch (gimple_call_internal_fn (stmt))\n@@ -3984,6 +4090,84 @@ extract_range_basic (value_range_t *vr, gimple stmt)\n \t  return;\n \t}\n     }\n+  /* Handle extraction of the two results (result of arithmetics and\n+     a flag whether arithmetics overflowed) from {ADD,SUB,MUL}_OVERFLOW\n+     internal function.  */\n+  else if (is_gimple_assign (stmt)\n+\t   && (gimple_assign_rhs_code (stmt) == REALPART_EXPR\n+\t       || gimple_assign_rhs_code (stmt) == IMAGPART_EXPR)\n+\t   && INTEGRAL_TYPE_P (type))\n+    {\n+      enum tree_code code = gimple_assign_rhs_code (stmt);\n+      tree op = gimple_assign_rhs1 (stmt);\n+      if (TREE_CODE (op) == code && TREE_CODE (TREE_OPERAND (op, 0)) == SSA_NAME)\n+\t{\n+\t  gimple g = SSA_NAME_DEF_STMT (TREE_OPERAND (op, 0));\n+\t  if (is_gimple_call (g) && gimple_call_internal_p (g))\n+\t    {\n+\t      enum tree_code subcode = ERROR_MARK;\n+\t      switch (gimple_call_internal_fn (g))\n+\t\t{\n+\t\tcase IFN_ADD_OVERFLOW:\n+\t\t  subcode = PLUS_EXPR;\n+\t\t  break;\n+\t\tcase IFN_SUB_OVERFLOW:\n+\t\t  subcode = MINUS_EXPR;\n+\t\t  break;\n+\t\tcase IFN_MUL_OVERFLOW:\n+\t\t  subcode = MULT_EXPR;\n+\t\t  break;\n+\t\tdefault:\n+\t\t  break;\n+\t\t}\n+\t      if (subcode != ERROR_MARK)\n+\t\t{\n+\t\t  tree op0 = gimple_call_arg (g, 0);\n+\t\t  tree op1 = gimple_call_arg (g, 1);\n+\t\t  if (code == IMAGPART_EXPR)\n+\t\t    {\n+\t\t      bool ovf = false;\n+\t\t      if (check_for_binary_op_overflow (subcode, type,\n+\t\t\t\t\t\t\top0, op1, &ovf))\n+\t\t\tset_value_range_to_value (vr,\n+\t\t\t\t\t\t  build_int_cst (type, ovf),\n+\t\t\t\t\t\t  NULL);\n+\t\t      else\n+\t\t\tset_value_range (vr, VR_RANGE, build_int_cst (type, 0),\n+\t\t\t\t\t build_int_cst (type, 1), NULL);\n+\t\t    }\n+\t\t  else if (types_compatible_p (type, TREE_TYPE (op0))\n+\t\t\t   && types_compatible_p (type, TREE_TYPE (op1)))\n+\t\t    {\n+\t\t      bool saved_flag_wrapv = flag_wrapv;\n+\t\t      /* Pretend the arithmetics is wrapping.  If there is\n+\t\t\t any overflow, IMAGPART_EXPR will be set.  */\n+\t\t      flag_wrapv = 1;\n+\t\t      extract_range_from_binary_expr (vr, subcode, type,\n+\t\t\t\t\t\t      op0, op1);\n+\t\t      flag_wrapv = saved_flag_wrapv;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      value_range_t vr0 = VR_INITIALIZER;\n+\t\t      value_range_t vr1 = VR_INITIALIZER;\n+\t\t      bool saved_flag_wrapv = flag_wrapv;\n+\t\t      /* Pretend the arithmetics is wrapping.  If there is\n+\t\t\t any overflow, IMAGPART_EXPR will be set.  */\n+\t\t      flag_wrapv = 1;\n+\t\t      extract_range_from_unary_expr (&vr0, NOP_EXPR,\n+\t\t\t\t\t\t     type, op0);\n+\t\t      extract_range_from_unary_expr (&vr1, NOP_EXPR,\n+\t\t\t\t\t\t     type, op1);\n+\t\t      extract_range_from_binary_expr_1 (vr, subcode, type,\n+\t\t\t\t\t\t\t&vr0, &vr1);\n+\t\t      flag_wrapv = saved_flag_wrapv;\n+\t\t    }\n+\t\t  return;\n+\t\t}\n+\t    }\n+\t}\n+    }\n   if (INTEGRAL_TYPE_P (type)\n       && gimple_stmt_nonnegative_warnv_p (stmt, &sop))\n     set_value_range_to_nonnegative (vr, type,\n@@ -9419,87 +9603,100 @@ static bool\n simplify_internal_call_using_ranges (gimple_stmt_iterator *gsi, gimple stmt)\n {\n   enum tree_code subcode;\n+  bool is_ubsan = false;\n+  bool ovf = false;\n   switch (gimple_call_internal_fn (stmt))\n     {\n     case IFN_UBSAN_CHECK_ADD:\n       subcode = PLUS_EXPR;\n+      is_ubsan = true;\n       break;\n     case IFN_UBSAN_CHECK_SUB:\n       subcode = MINUS_EXPR;\n+      is_ubsan = true;\n       break;\n     case IFN_UBSAN_CHECK_MUL:\n+      subcode = MULT_EXPR;\n+      is_ubsan = true;\n+      break;\n+    case IFN_ADD_OVERFLOW:\n+      subcode = PLUS_EXPR;\n+      break;\n+    case IFN_SUB_OVERFLOW:\n+      subcode = MINUS_EXPR;\n+      break;\n+    case IFN_MUL_OVERFLOW:\n       subcode = MULT_EXPR;\n       break;\n     default:\n       return false;\n     }\n \n-  value_range_t vr0 = VR_INITIALIZER;\n-  value_range_t vr1 = VR_INITIALIZER;\n   tree op0 = gimple_call_arg (stmt, 0);\n   tree op1 = gimple_call_arg (stmt, 1);\n-\n-  if (TREE_CODE (op0) == SSA_NAME)\n-    vr0 = *get_value_range (op0);\n-  else if (TREE_CODE (op0) == INTEGER_CST)\n-    set_value_range_to_value (&vr0, op0, NULL);\n-  else\n-    set_value_range_to_varying (&vr0);\n-\n-  if (TREE_CODE (op1) == SSA_NAME)\n-    vr1 = *get_value_range (op1);\n-  else if (TREE_CODE (op1) == INTEGER_CST)\n-    set_value_range_to_value (&vr1, op1, NULL);\n+  tree type;\n+  if (is_ubsan)\n+    type = TREE_TYPE (op0);\n+  else if (gimple_call_lhs (stmt) == NULL_TREE)\n+    return false;\n   else\n-    set_value_range_to_varying (&vr1);\n+    type = TREE_TYPE (TREE_TYPE (gimple_call_lhs (stmt)));\n+  if (!check_for_binary_op_overflow (subcode, type, op0, op1, &ovf)\n+      || (is_ubsan && ovf))\n+    return false;\n \n-  if (!range_int_cst_p (&vr0))\n-    {\n-      /* If one range is VR_ANTI_RANGE, VR_VARYING etc.,\n-\t optimize at least x = y + 0; x = y - 0; x = y * 0;\n-\t and x = y * 1; which never overflow.  */\n-      if (!range_int_cst_p (&vr1))\n-\treturn false;\n-      if (tree_int_cst_sgn (vr1.min) == -1)\n-\treturn false;\n-      if (compare_tree_int (vr1.max, subcode == MULT_EXPR) == 1)\n-\treturn false;\n-    }\n-  else if (!range_int_cst_p (&vr1))\n-    {\n-      /* If one range is VR_ANTI_RANGE, VR_VARYING etc.,\n-\t optimize at least x = 0 + y; x = 0 * y; and x = 1 * y;\n-\t which never overflow.  */\n-      if (subcode == MINUS_EXPR)\n-\treturn false;\n-      if (!range_int_cst_p (&vr0))\n-\treturn false;\n-      if (tree_int_cst_sgn (vr0.min) == -1)\n-\treturn false;\n-      if (compare_tree_int (vr0.max, subcode == MULT_EXPR) == 1)\n-\treturn false;\n-    }\n+  gimple g;\n+  location_t loc = gimple_location (stmt);\n+  if (is_ubsan)\n+    g = gimple_build_assign_with_ops (subcode, gimple_call_lhs (stmt),\n+\t\t\t\t      op0, op1);\n   else\n     {\n-      tree r1 = int_const_binop (subcode, vr0.min,\n-\t\t\t\t subcode == MINUS_EXPR ? vr1.max : vr1.min);\n-      tree r2 = int_const_binop (subcode, vr0.max,\n-\t\t\t\t subcode == MINUS_EXPR ? vr1.min : vr1.max);\n-      if (r1 == NULL_TREE || TREE_OVERFLOW (r1)\n-\t  || r2 == NULL_TREE || TREE_OVERFLOW (r2))\n-\treturn false;\n-      if (subcode == MULT_EXPR)\n-\t{\n-\t  tree r3 = int_const_binop (subcode, vr0.min, vr1.max);\n-\t  tree r4 = int_const_binop (subcode, vr0.max, vr1.min);\n-\t  if (r3 == NULL_TREE || TREE_OVERFLOW (r3)\n-\t      || r4 == NULL_TREE || TREE_OVERFLOW (r4))\n-\t    return false;\n+      int prec = TYPE_PRECISION (type);\n+      tree utype = type;\n+      if (ovf\n+\t  || !useless_type_conversion_p (type, TREE_TYPE (op0))\n+\t  || !useless_type_conversion_p (type, TREE_TYPE (op1)))\n+\tutype = build_nonstandard_integer_type (prec, 1);\n+      if (TREE_CODE (op0) == INTEGER_CST)\n+\top0 = fold_convert (utype, op0);\n+      else if (!useless_type_conversion_p (utype, TREE_TYPE (op0)))\n+\t{\n+\t  g = gimple_build_assign_with_ops (NOP_EXPR,\n+\t\t\t\t\t    make_ssa_name (utype, NULL),\n+\t\t\t\t\t    op0, NULL_TREE);\n+\t  gimple_set_location (g, loc);\n+\t  gsi_insert_before (gsi, g, GSI_SAME_STMT);\n+\t  op0 = gimple_assign_lhs (g);\n \t}\n-    }\n-\n-  gimple g = gimple_build_assign_with_ops (subcode, gimple_call_lhs (stmt),\n-\t\t\t\t\t   op0, op1);\n+      if (TREE_CODE (op1) == INTEGER_CST)\n+\top1 = fold_convert (utype, op1);\n+      else if (!useless_type_conversion_p (utype, TREE_TYPE (op1)))\n+\t{\n+\t  g = gimple_build_assign_with_ops (NOP_EXPR,\n+\t\t\t\t\t    make_ssa_name (utype, NULL),\n+\t\t\t\t\t    op1, NULL_TREE);\n+\t  gimple_set_location (g, loc);\n+\t  gsi_insert_before (gsi, g, GSI_SAME_STMT);\n+\t  op1 = gimple_assign_lhs (g);\n+\t}\n+      g = gimple_build_assign_with_ops (subcode, make_ssa_name (utype, NULL),\n+\t\t\t\t\top0, op1);\n+      gimple_set_location (g, loc);\n+      gsi_insert_before (gsi, g, GSI_SAME_STMT);\n+      if (utype != type)\n+\t{\n+\t  g = gimple_build_assign_with_ops (NOP_EXPR,\n+\t\t\t\t\t    make_ssa_name (type, NULL),\n+\t\t\t\t\t    gimple_assign_lhs (g), NULL_TREE);\n+\t  gimple_set_location (g, loc);\n+\t  gsi_insert_before (gsi, g, GSI_SAME_STMT);\n+\t}\n+      g = gimple_build_assign_with_ops (COMPLEX_EXPR, gimple_call_lhs (stmt),\n+\t\t\t\t\tgimple_assign_lhs (g),\n+\t\t\t\t\tbuild_int_cst (type, ovf));\n+    }\n+  gimple_set_location (g, loc);\n   gsi_replace (gsi, g, false);\n   return true;\n }"}]}