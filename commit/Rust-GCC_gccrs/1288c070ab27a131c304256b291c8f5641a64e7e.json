{"sha": "1288c070ab27a131c304256b291c8f5641a64e7e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTI4OGMwNzBhYjI3YTEzMWMzMDQyNTZiMjkxYzhmNTY0MWE2NGU3ZQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2000-11-10T02:03:28Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-11-10T02:03:28Z"}, "message": "flow.c (invalidate_mems_from_set): Split out from ...\n\n        * flow.c (invalidate_mems_from_set): Split out from ...\n        (mark_set_1): ... here.\n        (try_pre_increment_1): Use it.  Use propagate_block_delete_insn\n        instead of turning insn into a NOTE_INSN_DELETED.\n\nFrom-SVN: r37356", "tree": {"sha": "9de3ef66ac4e93fdad7eb783e02a98b8399876a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9de3ef66ac4e93fdad7eb783e02a98b8399876a5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1288c070ab27a131c304256b291c8f5641a64e7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1288c070ab27a131c304256b291c8f5641a64e7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1288c070ab27a131c304256b291c8f5641a64e7e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1288c070ab27a131c304256b291c8f5641a64e7e/comments", "author": null, "committer": null, "parents": [{"sha": "01702459369ac68d5fbfd7e642ee6c4c71e32091", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01702459369ac68d5fbfd7e642ee6c4c71e32091", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01702459369ac68d5fbfd7e642ee6c4c71e32091"}], "stats": {"total": 90, "additions": 55, "deletions": 35}, "files": [{"sha": "c6825b16bfcba3057eba5cc8da18e7abcf60a7ae", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1288c070ab27a131c304256b291c8f5641a64e7e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1288c070ab27a131c304256b291c8f5641a64e7e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1288c070ab27a131c304256b291c8f5641a64e7e", "patch": "@@ -1,3 +1,10 @@\n+2000-11-09  Richard Henderson  <rth@redhat.com>\n+\n+\t* flow.c (invalidate_mems_from_set): Split out from ...\n+\t(mark_set_1): ... here.\n+\t(try_pre_increment_1): Use it.  Use propagate_block_delete_insn\n+\tinstead of turning insn into a NOTE_INSN_DELETED.\n+\n 2000-11-10  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* extend.texi, invoke.texi: Move documentation of builtin versions"}, {"sha": "4fc8ac3ab1ac486a22f6b93a63e14af9b8e95566", "filename": "gcc/flow.c", "status": "modified", "additions": 48, "deletions": 35, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1288c070ab27a131c304256b291c8f5641a64e7e/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1288c070ab27a131c304256b291c8f5641a64e7e/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=1288c070ab27a131c304256b291c8f5641a64e7e", "patch": "@@ -408,6 +408,8 @@ static void dump_edge_info\t\tPARAMS ((FILE *, edge, int));\n \n static void invalidate_mems_from_autoinc PARAMS ((struct propagate_block_info *,\n \t\t\t\t\t\t  rtx));\n+static void invalidate_mems_from_set\tPARAMS ((struct propagate_block_info *,\n+\t\t\t\t\t\t rtx));\n static void remove_fake_successors\tPARAMS ((basic_block));\n static void flow_nodes_print\t\tPARAMS ((const char *, const sbitmap, \n \t\t\t\t\t\t FILE *));\n@@ -4352,6 +4354,39 @@ invalidate_mems_from_autoinc (pbi, insn)\n     }\n }\n \n+/* EXP is either a MEM or a REG.  Remove any dependant entries\n+   from pbi->mem_set_list.  */\n+\n+static void\n+invalidate_mems_from_set (pbi, exp)\n+     struct propagate_block_info *pbi;\n+     rtx exp;\n+{\n+  rtx temp = pbi->mem_set_list;\n+  rtx prev = NULL_RTX;\n+  rtx next;\n+\n+  while (temp)\n+    {\n+      next = XEXP (temp, 1);\n+      if ((GET_CODE (exp) == MEM\n+\t   && output_dependence (XEXP (temp, 0), exp))\n+\t  || (GET_CODE (exp) == REG\n+\t      && reg_overlap_mentioned_p (exp, XEXP (temp, 0))))\n+\t{\n+\t  /* Splice this entry out of the list.  */\n+\t  if (prev)\n+\t    XEXP (prev, 1) = next;\n+\t  else\n+\t    pbi->mem_set_list = next;\n+\t  free_EXPR_LIST_node (temp);\n+\t}\n+      else\n+\tprev = temp;\n+      temp = next;\n+    }\n+}\n+\n /* Process the registers that are set within X.  Their bits are set to\n    1 in the regset DEAD, because they are dead prior to this insn.\n \n@@ -4533,31 +4568,7 @@ mark_set_1 (pbi, code, reg, cond, insn, flags)\n   if (optimize && (flags & PROP_SCAN_DEAD_CODE))\n     {\n       if (GET_CODE (reg) == MEM || GET_CODE (reg) == REG)\n-\t{\n-\t  rtx temp = pbi->mem_set_list;\n-\t  rtx prev = NULL_RTX;\n-\t  rtx next;\n-\n-\t  while (temp)\n-\t    {\n-\t      next = XEXP (temp, 1);\n-\t      if ((GET_CODE (reg) == MEM\n-\t\t   && output_dependence (XEXP (temp, 0), reg))\n-\t\t  || (GET_CODE (reg) == REG\n-\t\t      && reg_overlap_mentioned_p (reg, XEXP (temp, 0))))\n-\t\t{\n-\t\t  /* Splice this entry out of the list.  */\n-\t\t  if (prev)\n-\t\t    XEXP (prev, 1) = next;\n-\t\t  else\n-\t\t    pbi->mem_set_list = next;\n-\t\t  free_EXPR_LIST_node (temp);\n-\t\t}\n-\t      else\n-\t\tprev = temp;\n-\t      temp = next;\n-\t    }\n-\t}\n+\tinvalidate_mems_from_set (pbi, reg);\n \n       /* If the memory reference had embedded side effects (autoincrement\n \t address modes.  Then we may need to kill some entries on the\n@@ -5763,22 +5774,24 @@ try_pre_increment_1 (pbi, insn)\n       && ! dead_or_set_p (y, SET_DEST (x))\n       && try_pre_increment (y, SET_DEST (x), amount))\n     {\n-      /* We have found a suitable auto-increment\n-\t and already changed insn Y to do it.\n-\t So flush this increment-instruction.  */\n-      PUT_CODE (insn, NOTE);\n-      NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n-      NOTE_SOURCE_FILE (insn) = 0;\n-      /* Count a reference to this reg for the increment\n-\t insn we are deleting.  When a reg is incremented.\n-\t spilling it is worse, so we want to make that\n-\t less likely.  */\n+      /* We have found a suitable auto-increment and already changed\n+\t insn Y to do it.  So flush this increment instruction.  */\n+      propagate_block_delete_insn (pbi->bb, insn);\n+\n+      /* Count a reference to this reg for the increment insn we are\n+\t deleting.  When a reg is incremented, spilling it is worse,\n+\t so we want to make that less likely.  */\n       if (regno >= FIRST_PSEUDO_REGISTER)\n \t{\n \t  REG_N_REFS (regno) += (optimize_size ? 1\n \t\t\t\t : pbi->bb->loop_depth + 1);\n \t  REG_N_SETS (regno)++;\n \t}\n+\n+      /* Flush any remembered memories depending on the value of\n+\t the incremented register.  */\n+      invalidate_mems_from_set (pbi, SET_DEST (x));\n+\n       return 1;\n     }\n   return 0;"}]}