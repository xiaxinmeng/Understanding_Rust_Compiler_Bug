{"sha": "6e03b280b00030909b9b8204d6b151ad8060d77e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmUwM2IyODBiMDAwMzA5MDliOWI4MjA0ZDZiMTUxYWQ4MDYwZDc3ZQ==", "commit": {"author": {"name": "Ollie Wild", "email": "aaw@google.com", "date": "2007-08-31T04:41:52Z"}, "committer": {"name": "Ollie Wild", "email": "aaw@gcc.gnu.org", "date": "2007-08-31T04:41:52Z"}, "message": "cvt.c (cp_convert_to_pointer): Remove force parameter.\n\n\tgcc/cp/\n\t* cvt.c (cp_convert_to_pointer): Remove force parameter. Call\n\tconvert_ptrmem for pointer to member conversions.\n\t(convert_to_pointer_force): Update cp_convert_to_pointer call.\n\t(ocp_convert): Update cp_convert_to_pointer call.\n\t* typeck.c (convert_ptrmem): Add conditional for null pointers to\n\tmembers.\n\t(build_static_cast_1): Check can_convert for conversions in either\n\tdirection.\n\t(get_delta_difference_1): New function.\n\t(get_delta_difference): Refactor to call get_delta_difference_1.\n\n\tgcc/testsuite/\n\tg++.dg/conversion/ptrmem2.C: New test.\n\tg++.dg/conversion/ptrmem3.C: New test.\n\tg++.dg/conversion/ptrmem4.C: New test.\n\tg++.dg/conversion/ptrmem5.C: New test.\n\tg++.dg/conversion/ptrmem6.C: New test.\n\tg++.dg/conversion/ptrmem7.C: New test.\n\tg++.dg/conversion/ptrmem8.C: New test.\n\nFrom-SVN: r127953", "tree": {"sha": "af96dea76799906789882358f9345fac9ddcc51a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/af96dea76799906789882358f9345fac9ddcc51a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e03b280b00030909b9b8204d6b151ad8060d77e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e03b280b00030909b9b8204d6b151ad8060d77e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e03b280b00030909b9b8204d6b151ad8060d77e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e03b280b00030909b9b8204d6b151ad8060d77e/comments", "author": {"login": "olliewild", "id": 11523068, "node_id": "MDQ6VXNlcjExNTIzMDY4", "avatar_url": "https://avatars.githubusercontent.com/u/11523068?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olliewild", "html_url": "https://github.com/olliewild", "followers_url": "https://api.github.com/users/olliewild/followers", "following_url": "https://api.github.com/users/olliewild/following{/other_user}", "gists_url": "https://api.github.com/users/olliewild/gists{/gist_id}", "starred_url": "https://api.github.com/users/olliewild/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olliewild/subscriptions", "organizations_url": "https://api.github.com/users/olliewild/orgs", "repos_url": "https://api.github.com/users/olliewild/repos", "events_url": "https://api.github.com/users/olliewild/events{/privacy}", "received_events_url": "https://api.github.com/users/olliewild/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2710d6d70d29b63208de5a8234f1a90dc42c3404", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2710d6d70d29b63208de5a8234f1a90dc42c3404", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2710d6d70d29b63208de5a8234f1a90dc42c3404"}], "stats": {"total": 454, "additions": 347, "deletions": 107}, "files": [{"sha": "8f64db42fec833efc86023ce7630a6814338c8dc", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e03b280b00030909b9b8204d6b151ad8060d77e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e03b280b00030909b9b8204d6b151ad8060d77e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=6e03b280b00030909b9b8204d6b151ad8060d77e", "patch": "@@ -1,3 +1,16 @@\n+2007-08-30  Ollie Wild  <aaw@google.com>\n+\n+\t* cvt.c (cp_convert_to_pointer): Remove force parameter. Call\n+\tconvert_ptrmem for pointer to member conversions.\n+\t(convert_to_pointer_force): Update cp_convert_to_pointer call.\n+\t(ocp_convert): Update cp_convert_to_pointer call.\n+\t* typeck.c (convert_ptrmem): Add conditional for null pointers to\n+\tmembers.\n+\t(build_static_cast_1): Check can_convert for conversions in either\n+\tdirection.\n+\t(get_delta_difference_1): New function.\n+\t(get_delta_difference): Refactor to call get_delta_difference_1.\n+\n 2007-08-28  Paolo Carlini  <pcarlini@suse.de>\n \n \tPR c++/33209"}, {"sha": "ebfc7d05d98bdd2f2ed92e6eadba1fc3ef638e98", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 10, "deletions": 56, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e03b280b00030909b9b8204d6b151ad8060d77e/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e03b280b00030909b9b8204d6b151ad8060d77e/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=6e03b280b00030909b9b8204d6b151ad8060d77e", "patch": "@@ -38,7 +38,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"decl.h\"\n #include \"target.h\"\n \n-static tree cp_convert_to_pointer (tree, tree, bool);\n+static tree cp_convert_to_pointer (tree, tree);\n static tree convert_to_pointer_force (tree, tree);\n static tree build_type_conversion (tree, tree);\n static tree build_up_reference (tree, tree, int, tree);\n@@ -71,12 +71,10 @@ static void warn_ref_binding (tree, tree, tree);\n      else if dealing with method pointers, delegate\n      else convert blindly\n    else if converting class, pass off to build_type_conversion\n-   else try C-style pointer conversion.  If FORCE is true then allow\n-   conversions via virtual bases (these are permitted by reinterpret_cast,\n-   but not static_cast).  */\n+   else try C-style pointer conversion.  */\n \n static tree\n-cp_convert_to_pointer (tree type, tree expr, bool force)\n+cp_convert_to_pointer (tree type, tree expr)\n {\n   tree intype = TREE_TYPE (expr);\n   enum tree_code form;\n@@ -174,61 +172,17 @@ cp_convert_to_pointer (tree type, tree expr, bool force)\n \n       return build_nop (type, expr);\n     }\n-  else if (TYPE_PTRMEM_P (type) && TYPE_PTRMEM_P (intype))\n-    {\n-      tree b1;\n-      tree b2;\n-      tree binfo;\n-      enum tree_code code = PLUS_EXPR;\n-      base_kind bk;\n-\n-      b1 = TYPE_PTRMEM_CLASS_TYPE (type);\n-      b2 = TYPE_PTRMEM_CLASS_TYPE (intype);\n-      binfo = lookup_base (b1, b2, ba_check, &bk);\n-      if (!binfo)\n-\t{\n-\t  binfo = lookup_base (b2, b1, ba_check, &bk);\n-\t  code = MINUS_EXPR;\n-\t}\n-      if (binfo == error_mark_node)\n-\treturn error_mark_node;\n-\n-      if (bk == bk_via_virtual)\n-\t{\n-\t  if (force)\n-\t    warning (0, \"pointer to member cast from %qT to %qT is via\"\n-\t\t     \" virtual base\", intype, type);\n-\t  else\n-\t    {\n-\t      error (\"pointer to member cast from %qT to %qT is\"\n-\t\t     \" via virtual base\", intype, type);\n-\t      return error_mark_node;\n-\t    }\n-\t  /* This is a reinterpret cast, whose result is unspecified.\n-\t     We choose to do nothing.  */\n-\t  return build1 (NOP_EXPR, type, expr);\n-\t}\n-\n-      if (TREE_CODE (expr) == PTRMEM_CST)\n-\texpr = cplus_expand_constant (expr);\n-\n-      if (binfo && !integer_zerop (BINFO_OFFSET (binfo)))\n-\texpr = size_binop (code,\n-\t\t\t   build_nop (sizetype, expr),\n-\t\t\t   BINFO_OFFSET (binfo));\n-      return build_nop (type, expr);\n-    }\n-  else if (TYPE_PTRMEMFUNC_P (type) && TYPE_PTRMEMFUNC_P (intype))\n-    return build_ptrmemfunc (TYPE_PTRMEMFUNC_FN_TYPE (type), expr, 0,\n-\t\t\t     /*c_cast_p=*/false);\n+  else if ((TYPE_PTRMEM_P (type) && TYPE_PTRMEM_P (intype))\n+\t   || (TYPE_PTRMEMFUNC_P (type) && TYPE_PTRMEMFUNC_P (intype)))\n+    return convert_ptrmem (type, expr, /*allow_inverse_p=*/false,\n+\t\t\t   /*c_cast_p=*/false);\n   else if (TYPE_PTRMEMFUNC_P (intype))\n     {\n       if (!warn_pmf2ptr)\n \t{\n \t  if (TREE_CODE (expr) == PTRMEM_CST)\n \t    return cp_convert_to_pointer (type,\n-\t\t\t\t\t  PTRMEM_CST_MEMBER (expr),\n-\t\t\t\t\t  force);\n+\t\t\t\t\t  PTRMEM_CST_MEMBER (expr));\n \t  else if (TREE_CODE (expr) == OFFSET_REF)\n \t    {\n \t      tree object = TREE_OPERAND (expr, 0);\n@@ -333,7 +287,7 @@ convert_to_pointer_force (tree type, tree expr)\n \t}\n     }\n \n-  return cp_convert_to_pointer (type, expr, true);\n+  return cp_convert_to_pointer (type, expr);\n }\n \n /* We are passing something to a function which requires a reference.\n@@ -720,7 +674,7 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n       return fold_if_not_in_template (convert_to_integer (type, e));\n     }\n   if (POINTER_TYPE_P (type) || TYPE_PTR_TO_MEMBER_P (type))\n-    return fold_if_not_in_template (cp_convert_to_pointer (type, e, false));\n+    return fold_if_not_in_template (cp_convert_to_pointer (type, e));\n   if (code == VECTOR_TYPE)\n     {\n       tree in_vtype = TREE_TYPE (e);"}, {"sha": "87044be6b04b0411e04d918f1acead1d5ebdecda", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 77, "deletions": 51, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e03b280b00030909b9b8204d6b151ad8060d77e/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e03b280b00030909b9b8204d6b151ad8060d77e/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=6e03b280b00030909b9b8204d6b151ad8060d77e", "patch": "@@ -4868,9 +4868,19 @@ convert_ptrmem (tree type, tree expr, bool allow_inverse_p,\n \t\t\t\t    allow_inverse_p,\n \t\t\t\t    c_cast_p);\n       if (!integer_zerop (delta))\n-\texpr = cp_build_binary_op (PLUS_EXPR,\n-\t\t\t\t   build_nop (ptrdiff_type_node, expr),\n-\t\t\t\t   delta);\n+\t{\n+\t  tree cond, op1, op2;\n+\n+\t  cond = cp_build_binary_op (EQ_EXPR,\n+\t\t\t\t     expr,\n+\t\t\t\t     build_int_cst (TREE_TYPE (expr), -1));\n+\t  op1 = build_nop (ptrdiff_type_node, expr);\n+\t  op2 = cp_build_binary_op (PLUS_EXPR, op1, delta);\n+\n+\t  expr = fold_build3 (COND_EXPR, ptrdiff_type_node, cond, op1, op2);\n+\t\t\t \n+\t}\n+\n       return build_nop (type, expr);\n     }\n   else\n@@ -5101,7 +5111,7 @@ build_static_cast_1 (tree type, tree expr, bool c_cast_p,\n \t  t1 = intype;\n \t  t2 = type;\n \t}\n-      if (can_convert (t1, t2))\n+      if (can_convert (t1, t2) || can_convert (t2, t1))\n \t{\n \t  if (!c_cast_p)\n \t    check_for_casting_away_constness (intype, type, diag_fn,\n@@ -5967,7 +5977,43 @@ build_x_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n   return build_modify_expr (lhs, modifycode, rhs);\n }\n \n-\f\n+/* Helper function for get_delta_difference which assumes FROM is a base\n+   class of TO.  Returns a delta for the conversion of pointer-to-member\n+   of FROM to pointer-to-member of TO.  If the conversion is invalid,\n+   returns zero.  If FROM is not a base class of TO, returns NULL_TREE.\n+   If C_CAST_P is true, this conversion is taking place as part of a C-style\n+   cast.  */\n+\n+static tree\n+get_delta_difference_1 (tree from, tree to, bool c_cast_p)\n+{\n+  tree binfo;\n+  base_kind kind;\n+\n+  binfo = lookup_base (to, from, c_cast_p ? ba_unique : ba_check, &kind);\n+  if (kind == bk_inaccessible || kind == bk_ambig)\n+    {\n+      error (\"   in pointer to member function conversion\");\n+      return size_zero_node;\n+    }\n+  else if (binfo)\n+    {\n+      if (kind != bk_via_virtual)\n+\treturn BINFO_OFFSET (binfo);\n+      else\n+\t/* FROM is a virtual base class of TO.  Issue an error or warning\n+\t   depending on whether or not this is a reinterpret cast.  */\n+\t{\n+\t  error (\"pointer to member conversion via virtual base %qT\",\n+\t\t BINFO_TYPE (binfo_from_vbase (binfo)));\n+\n+\t  return size_zero_node;\n+\t}\n+      }\n+    else\n+      return NULL_TREE;\n+}\n+\n /* Get difference in deltas for different pointer to member function\n    types.  Returns an integer constant of type PTRDIFF_TYPE_NODE.  If\n    the conversion is invalid, the constant is zero.  If\n@@ -5985,56 +6031,36 @@ get_delta_difference (tree from, tree to,\n \t\t      bool allow_inverse_p,\n \t\t      bool c_cast_p)\n {\n-  tree binfo;\n-  base_kind kind;\n   tree result;\n \n-  /* Assume no conversion is required.  */\n-  result = integer_zero_node;\n-  binfo = lookup_base (to, from, c_cast_p ? ba_unique : ba_check, &kind);\n-  if (kind == bk_inaccessible || kind == bk_ambig)\n-    error (\"   in pointer to member function conversion\");\n-  else if (binfo)\n-    {\n-      if (kind != bk_via_virtual)\n-\tresult = BINFO_OFFSET (binfo);\n-      else\n-\t{\n-\t  tree virt_binfo = binfo_from_vbase (binfo);\n-\n-\t  /* This is a reinterpret cast, we choose to do nothing.  */\n-\t  if (allow_inverse_p)\n-\t    warning (0, \"pointer to member cast via virtual base %qT\",\n-\t\t     BINFO_TYPE (virt_binfo));\n-\t  else\n-\t    error (\"pointer to member conversion via virtual base %qT\",\n-\t\t   BINFO_TYPE (virt_binfo));\n-\t}\n-    }\n-  else if (same_type_ignoring_top_level_qualifiers_p (from, to))\n-    /* Pointer to member of incomplete class is permitted*/;\n-  else if (!allow_inverse_p)\n-    {\n-      error_not_base_type (from, to);\n-      error (\"   in pointer to member conversion\");\n-    }\n+  if (same_type_ignoring_top_level_qualifiers_p (from, to))\n+    /* Pointer to member of incomplete class is permitted*/\n+    result = size_zero_node;\n   else\n-    {\n-      binfo = lookup_base (from, to, c_cast_p ? ba_unique : ba_check, &kind);\n-      if (binfo)\n-\t{\n-\t  if (kind != bk_via_virtual)\n-\t    result = size_diffop (size_zero_node, BINFO_OFFSET (binfo));\n-\t  else\n-\t    {\n-\t      /* This is a reinterpret cast, we choose to do nothing.  */\n-\t      tree virt_binfo = binfo_from_vbase (binfo);\n+    result = get_delta_difference_1 (from, to, c_cast_p);\n \n-\t      warning (0, \"pointer to member cast via virtual base %qT\",\n-\t\t       BINFO_TYPE (virt_binfo));\n-\t    }\n-\t}\n-    }\n+  if (!result)\n+  {\n+    if (!allow_inverse_p)\n+      {\n+\terror_not_base_type (from, to);\n+\terror (\"   in pointer to member conversion\");\n+\tresult = size_zero_node;\n+      }\n+    else\n+      {\n+\tresult = get_delta_difference_1 (to, from, c_cast_p);\n+\n+\tif (result)\n+\t  result = size_diffop (size_zero_node, result);\n+\telse\n+\t  {\n+\t    error_not_base_type (from, to);\n+\t    error (\"   in pointer to member conversion\");\n+\t    result = size_zero_node;\n+\t  }\n+      }\n+  }\n \n   return fold_if_not_in_template (convert_to_integer (ptrdiff_type_node,\n \t\t\t\t\t\t      result));"}, {"sha": "80f20333b7007c03325a432da608f5d56e599925", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e03b280b00030909b9b8204d6b151ad8060d77e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e03b280b00030909b9b8204d6b151ad8060d77e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6e03b280b00030909b9b8204d6b151ad8060d77e", "patch": "@@ -1,3 +1,13 @@\n+2007-08-30  Ollie Wild  <aaw@google.com>\n+\n+\tg++.dg/conversion/ptrmem2.C: New test.\n+\tg++.dg/conversion/ptrmem3.C: New test.\n+\tg++.dg/conversion/ptrmem4.C: New test.\n+\tg++.dg/conversion/ptrmem5.C: New test.\n+\tg++.dg/conversion/ptrmem6.C: New test.\n+\tg++.dg/conversion/ptrmem7.C: New test.\n+\tg++.dg/conversion/ptrmem8.C: New test.\n+\n 2007-08-31  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/31879"}, {"sha": "db39fc0345778b0956b7a6c2fe978aa8e2f62905", "filename": "gcc/testsuite/g++.dg/conversion/ptrmem2.C", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e03b280b00030909b9b8204d6b151ad8060d77e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fptrmem2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e03b280b00030909b9b8204d6b151ad8060d77e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fptrmem2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fptrmem2.C?ref=6e03b280b00030909b9b8204d6b151ad8060d77e", "patch": "@@ -0,0 +1,39 @@\n+// Copyright (C) 2007 Free Software Foundation\n+// Contributed by Ollie Wild <aaw@google.com>\n+// { dg-do compile }\n+\n+// Assorted pointer to data member static cast tests.\n+\n+struct A { int x; };\n+struct B : A { int x; };\n+struct P : A { int x; };\n+struct V { int x; };\n+struct D : B, virtual V, private P { int x; };\n+\n+// Valid static casts.\n+int B::*p1 = static_cast<int B::*>(&D::x);\n+int D::*p2 = static_cast<int D::*>(&B::x);\n+\n+// Virtual base class.\n+int V::*p3 = static_cast<int V::*>(&D::x);  // { dg-error \"\" }\n+int D::*p4 = static_cast<int D::*>(&V::x);  // { dg-error \"\" }\n+\n+// Inaccessible base class.\n+int P::*p5 = static_cast<int P::*>(&D::x);  // { dg-error \"\" }\n+int D::*p6 = static_cast<int D::*>(&P::x);  // { dg-error \"\" }\n+\n+// Ambiguous base class.\n+int A::*p7 = static_cast<int A::*>(&D::x);  // { dg-error \"\" }\n+int D::*p8 = static_cast<int D::*>(&A::x);  // { dg-error \"\" }\n+\n+// Valid conversions which increase cv-qualification.\n+const int B::*p9 = static_cast<const int B::*>(&D::x);\n+const int D::*p10 = static_cast<const int D::*>(&B::x);\n+\n+// Invalid conversions which decrease cv-qualification.\n+int B::*p11 = static_cast<int B::*>(p10); // { dg-error \"casts away constness\" }\n+int D::*p12 = static_cast<int D::*>(p9);  // { dg-error \"casts away constness\" }\n+\n+// Attempts to change member type.\n+float B::*p13 = static_cast<float B::*>(&D::x); // { dg-error \"\" }\n+float D::*p14 = static_cast<float D::*>(&B::x); // { dg-error \"\" }"}, {"sha": "13005e4298e09a2911251a9ca7e85fa69e04278e", "filename": "gcc/testsuite/g++.dg/conversion/ptrmem3.C", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e03b280b00030909b9b8204d6b151ad8060d77e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fptrmem3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e03b280b00030909b9b8204d6b151ad8060d77e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fptrmem3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fptrmem3.C?ref=6e03b280b00030909b9b8204d6b151ad8060d77e", "patch": "@@ -0,0 +1,31 @@\n+// Copyright (C) 2007 Free Software Foundation\n+// Contributed by Ollie Wild <aaw@google.com>\n+// { dg-do compile }\n+\n+// Assorted pointer to member function static cast tests.\n+\n+struct A { int f (); };\n+struct B : A { int f (); };\n+struct P : A { int f (); };\n+struct V { int f (); };\n+struct D : B, virtual V, private P { int f (); };\n+\n+// Valid static casts.\n+int (B::*p1)() = static_cast<int (B::*)()>(&D::f);\n+int (D::*p2)() = static_cast<int (D::*)()>(&B::f);\n+\n+// Virtual base class.\n+int (V::*p3)() = static_cast<int (V::*)()>(&D::f);  // { dg-error \"\" }\n+int (D::*p4)() = static_cast<int (D::*)()>(&V::f);  // { dg-error \"\" }\n+\n+// Inaccessible base class.\n+int (P::*p5)() = static_cast<int (P::*)()>(&D::f);  // { dg-error \"\" }\n+int (D::*p6)() = static_cast<int (D::*)()>(&P::f);  // { dg-error \"\" }\n+\n+// Ambiguous base class.\n+int (A::*p7)() = static_cast<int (A::*)()>(&D::f);  // { dg-error \"\" }\n+int (D::*p8)() = static_cast<int (D::*)()>(&A::f);  // { dg-error \"\" }\n+\n+// Attempts to change member type.\n+float (B::*p13)() = static_cast<float (B::*)()>(&D::f); // { dg-error \"\" }\n+float (D::*p14)() = static_cast<float (D::*)()>(&B::f); // { dg-error \"\" }"}, {"sha": "fd260df648a2b9252d7e716cf306cf4749b62d38", "filename": "gcc/testsuite/g++.dg/conversion/ptrmem4.C", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e03b280b00030909b9b8204d6b151ad8060d77e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fptrmem4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e03b280b00030909b9b8204d6b151ad8060d77e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fptrmem4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fptrmem4.C?ref=6e03b280b00030909b9b8204d6b151ad8060d77e", "patch": "@@ -0,0 +1,43 @@\n+// Copyright (C) 2007 Free Software Foundation\n+// Contributed by Ollie Wild <aaw@google.com>\n+// { dg-do compile }\n+\n+// Assorted pointer to data member c-style cast tests.\n+\n+struct X {};\n+struct A { int x; };\n+struct B : A { int x; };\n+struct P : A { int x; };\n+struct V { int x; };\n+struct D : B, virtual V, private P { int x; };\n+\n+// Accessible, non-virtual, non-ambiguous base clas.\n+int B::*p1 = (int B::*)&D::x;\n+int D::*p2 = (int D::*)&B::x;\n+\n+// Virtual base class.\n+int V::*p3 = (int V::*)&D::x;  // { dg-error \"\" }\n+int D::*p4 = (int D::*)&V::x;  // { dg-error \"\" }\n+\n+// Inaccessible base class.\n+int P::*p5 = (int P::*)&D::x;\n+int D::*p6 = (int D::*)&P::x;\n+\n+// Ambiguous base class.\n+int A::*p7 = (int A::*)&D::x;  // { dg-error \"\" }\n+int D::*p8 = (int D::*)&A::x;  // { dg-error \"\" }\n+\n+// Valid conversions which increase cv-qualification.\n+const int B::*p9 = (const int B::*)&D::x;\n+const int D::*p10 = (const int D::*)&B::x;\n+\n+// Valid conversions which decrease cv-qualification.\n+int B::*p11 = (int B::*)p10;\n+int D::*p12 = (int D::*)p9;\n+\n+// Attempts to change member type allowed via reinterpret_cast.\n+float B::*p13 = (float B::*)&D::x;\n+float D::*p14 = (float D::*)&B::x;\n+\n+// Conversion via unrelated classes allwed via reinterpret_cast.\n+int X::*p15 = (int X::*)&D::x;"}, {"sha": "6f06badd79f1c013b749e4deffc2a20b08f25305", "filename": "gcc/testsuite/g++.dg/conversion/ptrmem5.C", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e03b280b00030909b9b8204d6b151ad8060d77e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fptrmem5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e03b280b00030909b9b8204d6b151ad8060d77e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fptrmem5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fptrmem5.C?ref=6e03b280b00030909b9b8204d6b151ad8060d77e", "patch": "@@ -0,0 +1,35 @@\n+// Copyright (C) 2007 Free Software Foundation\n+// Contributed by Ollie Wild <aaw@google.com>\n+// { dg-do compile }\n+\n+// Assorted pointer to member function c-style cast tests.\n+\n+struct X {};\n+struct A { int f (); };\n+struct B : A { int f (); };\n+struct P : A { int f (); };\n+struct V { int f (); };\n+struct D : B, virtual V, private P { int f (); };\n+\n+// Accessible, non-virtual, non-ambiguous base clas.\n+int (B::*p1)() = (int (B::*)())&D::f;\n+int (D::*p2)() = (int (D::*)())&B::f;\n+\n+// Virtual base class.\n+int (V::*p3)() = (int (V::*)())&D::f;  // { dg-error \"\" }\n+int (D::*p4)() = (int (D::*)())&V::f;  // { dg-error \"\" }\n+\n+// Inaccessible base class.\n+int (P::*p5)() = (int (P::*)())&D::f;\n+int (D::*p6)() = (int (D::*)())&P::f;\n+\n+// Ambiguous base class.\n+int (A::*p7)() = (int (A::*)())&D::f;  // { dg-error \"\" }\n+int (D::*p8)() = (int (D::*)())&A::f;  // { dg-error \"\" }\n+\n+// Attempts to change member type allowed via reinterpret_cast.\n+float (B::*p13)() = (float (B::*)())&D::f;\n+float (D::*p14)() = (float (D::*)())&B::f;\n+\n+// Conversion via unrelated classes allwed via reinterpret_cast.\n+int (X::*p15)() = (int (X::*)())&D::f;"}, {"sha": "a3c0c966cefb30da1793c17300d5bb987e99c22c", "filename": "gcc/testsuite/g++.dg/conversion/ptrmem6.C", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e03b280b00030909b9b8204d6b151ad8060d77e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fptrmem6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e03b280b00030909b9b8204d6b151ad8060d77e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fptrmem6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fptrmem6.C?ref=6e03b280b00030909b9b8204d6b151ad8060d77e", "patch": "@@ -0,0 +1,35 @@\n+// Copyright (C) 2007 Free Software Foundation\n+// Contributed by Ollie Wild <aaw@google.com>\n+// { dg-do compile }\n+\n+// Assorted pointer to data member implicit cast tests.\n+\n+struct A { int x; };\n+struct B : A { int x; };\n+struct P : A { int x; };\n+struct V { int x; };\n+struct D : B, virtual V, private P { int x; };\n+\n+// Valid.\n+int D::*p1 = &B::x;\n+\n+// Derived class.\n+int B::*p2 = &D::x; // { dg-error \"\" }\n+\n+// Virtual base class.\n+int D::*p3 = &V::x; // { dg-error \"\" }\n+\n+// Inaccessible base class.\n+int D::*p4 = &P::x; // { dg-error \"\" }\n+\n+// Ambiguous base class.\n+int D::*p5 = &A::x;  // { dg-error \"\" }\n+\n+// Increases cv-qualification.\n+const int D::*p6 = &B::x;\n+\n+// Decreases cv-qualification.\n+int D::*p7 = static_cast<const int D::*>(&D::x); // { dg-error \"\" }\n+\n+// Different member type.\n+float D::*p8 = &B::x;  // { dg-error \"\" }"}, {"sha": "ad75a52bc5e35e402bdbdd9f796083ec78d3add0", "filename": "gcc/testsuite/g++.dg/conversion/ptrmem7.C", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e03b280b00030909b9b8204d6b151ad8060d77e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fptrmem7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e03b280b00030909b9b8204d6b151ad8060d77e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fptrmem7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fptrmem7.C?ref=6e03b280b00030909b9b8204d6b151ad8060d77e", "patch": "@@ -0,0 +1,29 @@\n+// Copyright (C) 2007 Free Software Foundation\n+// Contributed by Ollie Wild <aaw@google.com>\n+// { dg-do compile }\n+\n+// Assorted pointer to member function implicit cast tests.\n+\n+struct A { int f (); };\n+struct B : A { int f (); };\n+struct P : A { int f (); };\n+struct V { int f (); };\n+struct D : B, virtual V, private P { int f (); };\n+\n+// Valid.\n+int (D::*p1)() = &B::f;\n+\n+// Derived class.\n+int (B::*p2)() = &D::f; // { dg-error \"\" }\n+\n+// Virtual base class.\n+int (D::*p3)() = &V::f; // { dg-error \"\" }\n+\n+// Inaccessible base class.\n+int (D::*p4)() = &P::f; // { dg-error \"\" }\n+\n+// Ambiguous base class.\n+int (D::*p5)() = &A::f;  // { dg-error \"\" }\n+\n+// Different member type.\n+float (D::*p6)() = &B::f;  // { dg-error \"\" }"}, {"sha": "95d902fa9e7315d45a16442919138c455677abec", "filename": "gcc/testsuite/g++.dg/conversion/ptrmem8.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e03b280b00030909b9b8204d6b151ad8060d77e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fptrmem8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e03b280b00030909b9b8204d6b151ad8060d77e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fptrmem8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fptrmem8.C?ref=6e03b280b00030909b9b8204d6b151ad8060d77e", "patch": "@@ -0,0 +1,25 @@\n+// Copyright (C) 2007 Free Software Foundation\n+// Contributed by Ollie Wild <aaw@google.com>\n+// { dg-do run }\n+\n+// Test for proper conversion of null pointers to data members.\n+\n+struct B1 {\n+  int x;\n+};\n+\n+struct B2 {\n+  int x;\n+};\n+\n+struct D : B1, B2 {\n+  int x;\n+};\n+\n+int main ()\n+{\n+  int D::*pd = 0;\n+  int B2::*pb2 = 0;\n+\n+  return pd != pb2;\n+}"}]}