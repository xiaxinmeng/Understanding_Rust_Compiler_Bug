{"sha": "5b0e6852b1c277ca2e74ba50de7704fb740a2e5e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWIwZTY4NTJiMWMyNzdjYTJlNzRiYTUwZGU3NzA0ZmI3NDBhMmU1ZQ==", "commit": {"author": {"name": "Bob Duff", "email": "duff@adacore.com", "date": "2014-01-31T15:43:41Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-01-31T15:43:41Z"}, "message": "s-taskin.ads: Minor comment fix.\n\n2014-01-31  Bob Duff  <duff@adacore.com>\n\n\t* s-taskin.ads: Minor comment fix.\n\t* s-tassta.adb (Abort_Dependents): Don't abort all dependents;\n\tjust direct dependents. If this is actually an abort, each task\n\twill take care of aborting its dependents, so all dependents will\n\tget aborted, as before. However, when this is called the second\n\ttime from Vulnerable_Complete_Master \"for convenience\" (i.e. to\n\tkill off tasks waiting at terminate alternatives), aborting\n\tindirect dependents is wrong, because it causes some unrelated\n\ttasks to get aborted.\n\nFrom-SVN: r207350", "tree": {"sha": "c02aaddd6a80c0a096bc5d45fcc49a67da8d7606", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c02aaddd6a80c0a096bc5d45fcc49a67da8d7606"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5b0e6852b1c277ca2e74ba50de7704fb740a2e5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b0e6852b1c277ca2e74ba50de7704fb740a2e5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b0e6852b1c277ca2e74ba50de7704fb740a2e5e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b0e6852b1c277ca2e74ba50de7704fb740a2e5e/comments", "author": {"login": "bobduff", "id": 29099567, "node_id": "MDQ6VXNlcjI5MDk5NTY3", "avatar_url": "https://avatars.githubusercontent.com/u/29099567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobduff", "html_url": "https://github.com/bobduff", "followers_url": "https://api.github.com/users/bobduff/followers", "following_url": "https://api.github.com/users/bobduff/following{/other_user}", "gists_url": "https://api.github.com/users/bobduff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobduff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobduff/subscriptions", "organizations_url": "https://api.github.com/users/bobduff/orgs", "repos_url": "https://api.github.com/users/bobduff/repos", "events_url": "https://api.github.com/users/bobduff/events{/privacy}", "received_events_url": "https://api.github.com/users/bobduff/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a54ffd6cb9056b98ec4f188122b370e29ddd30d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a54ffd6cb9056b98ec4f188122b370e29ddd30d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a54ffd6cb9056b98ec4f188122b370e29ddd30d0"}], "stats": {"total": 58, "additions": 40, "deletions": 18}, "files": [{"sha": "82247a059d6b472fa5a16d225f48ca14d1100c2d", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b0e6852b1c277ca2e74ba50de7704fb740a2e5e/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b0e6852b1c277ca2e74ba50de7704fb740a2e5e/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=5b0e6852b1c277ca2e74ba50de7704fb740a2e5e", "patch": "@@ -1,3 +1,15 @@\n+2014-01-31  Bob Duff  <duff@adacore.com>\n+\n+\t* s-taskin.ads: Minor comment fix.\n+\t* s-tassta.adb (Abort_Dependents): Don't abort all dependents;\n+\tjust direct dependents. If this is actually an abort, each task\n+\twill take care of aborting its dependents, so all dependents will\n+\tget aborted, as before. However, when this is called the second\n+\ttime from Vulnerable_Complete_Master \"for convenience\" (i.e. to\n+\tkill off tasks waiting at terminate alternatives), aborting\n+\tindirect dependents is wrong, because it causes some unrelated\n+\ttasks to get aborted.\n+\n 2014-01-31  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_ch4.adb: Minor reformatting."}, {"sha": "8f1bb05feb0541b1b1f3fbf503c500279cb622dc", "filename": "gcc/ada/s-taskin.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b0e6852b1c277ca2e74ba50de7704fb740a2e5e/gcc%2Fada%2Fs-taskin.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b0e6852b1c277ca2e74ba50de7704fb740a2e5e/gcc%2Fada%2Fs-taskin.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taskin.ads?ref=5b0e6852b1c277ca2e74ba50de7704fb740a2e5e", "patch": "@@ -754,7 +754,7 @@ package System.Tasking is\n    subtype Master_ID is Master_Level;\n \n    --  Normally, a task starts out with internal master nesting level one\n-   --  larger than external master nesting level. It is incremented to one by\n+   --  larger than external master nesting level. It is incremented by one by\n    --  Enter_Master, which is called in the task body only if the compiler\n    --  thinks the task may have dependent tasks. It is set to 1 for the\n    --  environment task, the level 2 is reserved for server tasks of the"}, {"sha": "4925906b026803829300ebcf4274d5ec7257c8e3", "filename": "gcc/ada/s-tassta.adb", "status": "modified", "additions": 27, "deletions": 17, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b0e6852b1c277ca2e74ba50de7704fb740a2e5e/gcc%2Fada%2Fs-tassta.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b0e6852b1c277ca2e74ba50de7704fb740a2e5e/gcc%2Fada%2Fs-tassta.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tassta.adb?ref=5b0e6852b1c277ca2e74ba50de7704fb740a2e5e", "patch": "@@ -150,27 +150,28 @@ package body System.Tasking.Stages is\n       C : Task_Id;\n       P : Task_Id;\n \n+      --  Each task C will take care of its own dependents, so there is no need\n+      --  to worry about them here. In fact, it would be wrong to abort\n+      --  indirect dependents here, because we can't distinguish between\n+      --  duplicate master ids. For example, suppose we have three nested task\n+      --  bodies T1,T2,T3. And suppose T1 also calls P which calls Q (and both\n+      --  P and Q are task masters). Q will have the same master id as\n+      --  Master_of_Task of T3. Previous versions of this would abort T3 when Q\n+      --  calls Complete_Master, which was completely wrong.\n+\n    begin\n       C := All_Tasks_List;\n       while C /= null loop\n          P := C.Common.Parent;\n-         while P /= null loop\n-            if P = Self_ID then\n-\n-               --  ??? C is supposed to take care of its own dependents, so\n-               --  there should be no need to worry about them. Need to double\n-               --  check this.\n-\n-               if C.Master_of_Task = Self_ID.Master_Within then\n-                  Utilities.Abort_One_Task (Self_ID, C);\n-                  C.Dependents_Aborted := True;\n-               end if;\n \n-               exit;\n+         if P = Self_ID then\n+            if C.Master_of_Task = Self_ID.Master_Within then\n+               pragma Debug\n+                 (Debug.Trace (Self_ID, \"Aborting\", 'X', C));\n+               Utilities.Abort_One_Task (Self_ID, C);\n+               C.Dependents_Aborted := True;\n             end if;\n-\n-            P := P.Common.Parent;\n-         end loop;\n+         end if;\n \n          C := C.Common.All_Tasks_Link;\n       end loop;\n@@ -715,6 +716,10 @@ package body System.Tasking.Stages is\n       if Runtime_Traces then\n          Send_Trace_Info (T_Create, T);\n       end if;\n+\n+      pragma Debug\n+        (Debug.Trace\n+           (Self_ID, \"Created task in \" & T.Master_of_Task'Img, 'C', T));\n    end Create_Task;\n \n    --------------------\n@@ -734,6 +739,9 @@ package body System.Tasking.Stages is\n       Self_ID : constant Task_Id := STPO.Self;\n    begin\n       Self_ID.Master_Within := Self_ID.Master_Within + 1;\n+      pragma Debug\n+        (Debug.Trace\n+           (Self_ID, \"Enter_Master ->\" & Self_ID.Master_Within'Img, 'M'));\n    end Enter_Master;\n \n    -------------------------------\n@@ -1669,7 +1677,7 @@ package body System.Tasking.Stages is\n \n    begin\n       pragma Debug\n-        (Debug.Trace (Self_ID, \"V_Complete_Master\", 'C'));\n+        (Debug.Trace (Self_ID, \"V_Complete_Master(\" & CM'Img & \")\", 'C'));\n \n       pragma Assert (Self_ID.Common.Wait_Count = 0);\n       pragma Assert\n@@ -1712,7 +1720,7 @@ package body System.Tasking.Stages is\n             Unlock (C);\n          end if;\n \n-         --  Count it if dependent on this master\n+         --  Count it if directly dependent on this master\n \n          if C.Common.Parent = Self_ID and then C.Master_of_Task = CM then\n             Write_Lock (C);\n@@ -1759,6 +1767,8 @@ package body System.Tasking.Stages is\n                Write_Lock (Self_ID);\n             end if;\n          else\n+            pragma Debug\n+              (Debug.Trace (Self_ID, \"master_completion_sleep\", 'C'));\n             Sleep (Self_ID, Master_Completion_Sleep);\n          end if;\n       end loop;"}]}