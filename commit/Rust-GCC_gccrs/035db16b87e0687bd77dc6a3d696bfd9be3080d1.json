{"sha": "035db16b87e0687bd77dc6a3d696bfd9be3080d1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDM1ZGIxNmI4N2UwNjg3YmQ3N2RjNmEzZDY5NmJmZDliZTMwODBkMQ==", "commit": {"author": {"name": "Mark Wielaard", "email": "mark@gcc.gnu.org", "date": "2005-11-17T14:03:22Z"}, "committer": {"name": "Mark Wielaard", "email": "mark@gcc.gnu.org", "date": "2005-11-17T14:03:22Z"}, "message": "[multiple changes]\n\n2005-11-17  Mark Wielaard  <mark@klomp.org>\n\n       * java/text/SimpleDateFormat.java: Removed, fully merged now.\n       * sources.am: Regenerated.\n       * Makefile.in: Regenerated.\n\n2005-11-17  Sven de Marothy  <sven@physto.se>\n\n       * java/text/SimpleDateFormat.java\n       (computeOffset): Allow timezone to be first in the parsed String.\n\n2005-11-17  Mark Wielaard  <mark@klomp.org>\n\n       * java/text/SimpleDateFormat.java (field, size): Make package private.\n\n2005-11-17  Tom Tromey  <tromey@redhat.com>\n\n       * java/text/SimpleDateFormat.java (compileFormat): Correctly\n       handle quoted single quotes.  PR classspath/23183.\n\n2005-11-17  Tom Tromey  <tromey@redhat.com>\n\n       * java/text/SimpleDateFormat.java (compileFormat): Reformatted.\n\n2005-11-17  Tom Tromey  <tromey@redhat.com>\n\n       * java/text/DateFormat.java (serialVersionUID): New field.\n\n2005-11-17  Mark Wielaard  <mark@klomp.org>\n\n       * java/text/DateFormat.java (equals): Reimplement.\n\n2005-11-17  David Gilbert  <david.gilbert@object-refinery.com>\n\n       * java/text/Collator.java: API doc fixes,\n       * java/text/DateFormat.java: likewise,\n       * java/text/DecimalFormatSymbols.java: likewise,\n       * java/text/DateFormatSymbols.java: likewise,\n       * java/text/SimpleDateFormat.java: likewise.\n\n2005-11-17  Jeroen Frijters  <jeroen@frijters.net>\n\n       * java/text/Collator.java (getInstance(Locale)):\n       Added default collation pattern to handle case when resource\n       is missing and throw InternalError instead of returning null\n       should parsing fail.\n\nFrom-SVN: r107121", "tree": {"sha": "dca7ce5d29bcd7be1f57fe3c21942d0a3b28f0da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dca7ce5d29bcd7be1f57fe3c21942d0a3b28f0da"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/035db16b87e0687bd77dc6a3d696bfd9be3080d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/035db16b87e0687bd77dc6a3d696bfd9be3080d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/035db16b87e0687bd77dc6a3d696bfd9be3080d1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/035db16b87e0687bd77dc6a3d696bfd9be3080d1/comments", "author": null, "committer": null, "parents": [{"sha": "b424a57253aafe26c07a50fecfd2a61999b06475", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b424a57253aafe26c07a50fecfd2a61999b06475", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b424a57253aafe26c07a50fecfd2a61999b06475"}], "stats": {"total": 1427, "additions": 133, "deletions": 1294}, "files": [{"sha": "f6e0c24465b6e06c7a0fd186d60fb4360804ee52", "filename": "libjava/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/035db16b87e0687bd77dc6a3d696bfd9be3080d1/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/035db16b87e0687bd77dc6a3d696bfd9be3080d1/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=035db16b87e0687bd77dc6a3d696bfd9be3080d1", "patch": "@@ -1,3 +1,50 @@\n+2005-11-17  Mark Wielaard  <mark@klomp.org>\n+\n+\t* java/text/SimpleDateFormat.java: Removed, fully merged now.\n+\t* sources.am: Regenerated.\n+\t* Makefile.in: Regenerated.\n+\n+2005-11-17  Sven de Marothy  <sven@physto.se>\n+\n+\t* java/text/SimpleDateFormat.java\n+\t(computeOffset): Allow timezone to be first in the parsed String.\n+\n+2005-11-17  Mark Wielaard  <mark@klomp.org>\n+\n+\t* java/text/SimpleDateFormat.java (field, size): Make package private.\n+\n+2005-11-17  Tom Tromey  <tromey@redhat.com>\n+\n+\t* java/text/SimpleDateFormat.java (compileFormat): Correctly\n+\thandle quoted single quotes.  PR classspath/23183.\n+\n+2005-11-17  Tom Tromey  <tromey@redhat.com>\n+\n+\t* java/text/SimpleDateFormat.java (compileFormat): Reformatted.\n+\n+2005-11-17  Tom Tromey  <tromey@redhat.com>\n+\n+\t* java/text/DateFormat.java (serialVersionUID): New field.\n+\n+2005-11-17  Mark Wielaard  <mark@klomp.org>\n+\n+\t* java/text/DateFormat.java (equals): Reimplement.\n+\n+2005-11-17  David Gilbert  <david.gilbert@object-refinery.com>\n+\n+\t* java/text/Collator.java: API doc fixes,\n+\t* java/text/DateFormat.java: likewise,\n+\t* java/text/DecimalFormatSymbols.java: likewise,\n+\t* java/text/DateFormatSymbols.java: likewise,\n+\t* java/text/SimpleDateFormat.java: likewise.\n+\n+2005-11-17  Jeroen Frijters  <jeroen@frijters.net>\n+\n+\t* java/text/Collator.java (getInstance(Locale)):\n+\tAdded default collation pattern to handle case when resource\n+\tis missing and throw InternalError instead of returning null\n+\tshould parsing fail.\n+\n 2005-11-15  Mark Wielaard  <mark@klomp.org>\n \n \t* java/util/zip/ZipEntry.java: Removed, fully merged now."}, {"sha": "6daf7a39bedaf2e802ed91ecf9ea403def2f23a1", "filename": "libjava/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/035db16b87e0687bd77dc6a3d696bfd9be3080d1/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/035db16b87e0687bd77dc6a3d696bfd9be3080d1/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=035db16b87e0687bd77dc6a3d696bfd9be3080d1", "patch": "@@ -3217,7 +3217,7 @@ classpath/java/text/NumberFormat.java \\\n classpath/java/text/ParseException.java \\\n classpath/java/text/ParsePosition.java \\\n classpath/java/text/RuleBasedCollator.java \\\n-java/text/SimpleDateFormat.java \\\n+classpath/java/text/SimpleDateFormat.java \\\n classpath/java/text/StringCharacterIterator.java\n \n java_text_header_files = $(patsubst classpath/%,%,$(patsubst %.java,%.h,$(java_text_source_files)))"}, {"sha": "c1ba87e93b996429590e830eeff941c1999cdb84", "filename": "libjava/java/text/Collator.java", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/035db16b87e0687bd77dc6a3d696bfd9be3080d1/libjava%2Fjava%2Ftext%2FCollator.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/035db16b87e0687bd77dc6a3d696bfd9be3080d1/libjava%2Fjava%2Ftext%2FCollator.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FCollator.java?ref=035db16b87e0687bd77dc6a3d696bfd9be3080d1", "patch": "@@ -150,8 +150,8 @@ protected Collator ()\n    * <code>Collator</code> and the strength and decomposition rules in\n    * effect.\n    *\n-   * @param str1 The first object to compare\n-   * @param str2 The second object to compare\n+   * @param source The first object to compare\n+   * @param target The second object to compare\n    *\n    * @return A negative integer if str1 &lt; str2, 0 if str1 == str2, or\n    * a positive integer if str1 &gt; str2. \n@@ -164,8 +164,8 @@ protected Collator ()\n    * equal to, or greater than the second argument.  These two objects\n    * must be <code>String</code>'s or an exception will be thrown.\n    *\n-   * @param obj1 The first object to compare\n-   * @param obj2 The second object to compare\n+   * @param o1 The first object to compare\n+   * @param o2 The second object to compare\n    *\n    * @return A negative integer if obj1 &lt; obj2, 0 if obj1 == obj2, or\n    * a positive integer if obj1 &gt; obj2. \n@@ -208,8 +208,8 @@ public boolean equals (Object obj)\n    * according to the collation rules for the locale of this object and\n    * the current strength and decomposition settings.\n    *\n-   * @param str1 The first <code>String</code> to compare\n-   * @param str2 The second <code>String</code> to compare\n+   * @param source The first <code>String</code> to compare\n+   * @param target The second <code>String</code> to compare\n    *\n    * @return <code>true</code> if the two strings are equal,\n    * <code>false</code> otherwise. \n@@ -256,7 +256,7 @@ public static synchronized Locale[] getAvailableLocales ()\n    * comparisons against a string might be performed multiple times, such\n    * as during a sort operation.\n    *\n-   * @param str The <code>String</code> to convert.\n+   * @param source The <code>String</code> to convert.\n    *\n    * @return A <code>CollationKey</code> for the specified <code>String</code>.\n    */\n@@ -292,7 +292,7 @@ public static Collator getInstance ()\n    * specified locale.  If no <code>Collator</code> exists for the desired\n    * locale, a <code>Collator</code> for the default locale will be returned.\n    *\n-   * @param locale The desired localed to load a <code>Collator</code> for.\n+   * @param loc The desired localed to load a <code>Collator</code> for.\n    *\n    * @return A <code>Collator</code> for the requested locale\n    */\n@@ -308,15 +308,16 @@ public static Collator getInstance (Locale loc)\n       }\n     catch (MissingResourceException x)\n       {\n-\treturn null;\n+\tpattern = \"<0<1<2<3<4<5<6<7<8<9<A,a<b,B<c,C<d,D<e,E<f,F<g,G<h,H<i,I<j,J<k,K\" +\n+\t\t\"<l,L<m,M<n,N<o,O<p,P<q,Q<r,R<s,S<t,T<u,U<v,V<w,W<x,X<y,Y<z,Z\";\n       }\n     try\n       {\n \treturn new RuleBasedCollator (pattern);\n       }\n     catch (ParseException x)\n       {\n-\treturn null;\n+\tthrow (InternalError)new InternalError().initCause(x);\n       }\n   }\n \n@@ -346,7 +347,7 @@ public synchronized int getStrength ()\n    * exception will be thrown.  See the documentation for those\n    * contants for an explanation of this setting.\n    *\n-   * @param decmp The new decomposition setting.\n+   * @param mode The new decomposition setting.\n    *\n    * @exception IllegalArgumentException If the requested\n    * decomposition setting is not valid."}, {"sha": "c94d9845b3004262487e9666a0a9b7b4166dfe35", "filename": "libjava/java/text/DateFormat.java", "status": "modified", "additions": 42, "deletions": 13, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/035db16b87e0687bd77dc6a3d696bfd9be3080d1/libjava%2Fjava%2Ftext%2FDateFormat.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/035db16b87e0687bd77dc6a3d696bfd9be3080d1/libjava%2Fjava%2Ftext%2FDateFormat.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FDateFormat.java?ref=035db16b87e0687bd77dc6a3d696bfd9be3080d1", "patch": "@@ -58,6 +58,9 @@\n \n public abstract class DateFormat extends Format implements Cloneable\n {\n+  private static final long serialVersionUID = 7218322306649953788L;\n+\n+  // Names fixed by serialization spec.\n   protected Calendar calendar;\n   protected NumberFormat numberFormat;\n \n@@ -405,8 +408,18 @@ protected DateFormat ()\n    * <ul>\n    * <li>Is not <code>null</code>.</li>\n    * <li>Is an instance of <code>DateFormat</code>.</li>\n-   * <li>Has the same numberFormat field value as this object.</li>\n+   * <li>Has equal numberFormat field as this object.</li>\n+   * <li>Has equal (Calendar) TimeZone rules as this object.</li>\n+   * <li>Has equal (Calendar) isLenient results.</li> \n+   * <li>Has equal Calendar first day of week and minimal days in week\n+   * values.</li>\n    * </ul>\n+   * Note that not all properties of the Calendar are relevant for a\n+   * DateFormat. For formatting only the fact whether or not the\n+   * TimeZone has the same rules and whether the calendar is lenient\n+   * and has the same week rules is compared for this implementation\n+   * of equals. Other properties of the Calendar (such as the time)\n+   * are not taken into account.\n    *\n    * @param obj The object to test for equality against.\n    * \n@@ -419,8 +432,24 @@ public boolean equals (Object obj)\n       return false;\n \n     DateFormat d = (DateFormat) obj;\n-\n-    return numberFormat.equals(d.numberFormat);\n+    TimeZone tz = getTimeZone();\n+    TimeZone tzd = d.getTimeZone();\n+    if (tz.hasSameRules(tzd))\n+      if (isLenient() == d.isLenient())\n+\t{\n+\t  Calendar c = getCalendar();\n+\t  Calendar cd = d.getCalendar();\n+\t  if ((c == null && cd == null)\n+\t      ||\n+\t      (c.getFirstDayOfWeek() == cd.getFirstDayOfWeek()\n+\t       &&\n+\t       c.getMinimalDaysInFirstWeek()\n+\t       == cd.getMinimalDaysInFirstWeek()))\n+\t    return ((numberFormat == null && d.numberFormat == null)\n+\t\t    || numberFormat.equals(d.numberFormat));\n+\t}\n+\n+    return false;\n   }\n \n   /**\n@@ -442,9 +471,9 @@ public Object clone ()\n    * thrown.\n    *\n    * @param obj The <code>Object</code> to format.\n-   * @param toAppendTo The <code>StringBuffer</code> to append the resultant\n+   * @param buf The <code>StringBuffer</code> to append the resultant\n    * <code>String</code> to.\n-   * @param fieldPosition Is updated to the start and end index of the\n+   * @param pos Is updated to the start and end index of the\n    * specified field.\n    *\n    * @return The <code>StringBuffer</code> supplied on input, with the\n@@ -479,9 +508,9 @@ public final String format (Date date)\n    * to the specified <code>StringBuffer</code>.\n    *\n    * @param date The <code>Date</code> value to format.\n-   * @param toAppendTo The <code>StringBuffer</code> to append the resultant\n+   * @param buf The <code>StringBuffer</code> to append the resultant\n    * <code>String</code> to.\n-   * @param fieldPosition Is updated to the start and end index of the\n+   * @param pos Is updated to the start and end index of the\n    * specified field.\n    *\n    * @return The <code>StringBuffer</code> supplied on input, with the\n@@ -646,7 +675,7 @@ public static final DateFormat getDateInstance (int style)\n    * localed will be used in place of the default.\n    *\n    * @param style The type of formatting to perform. \n-   * @param aLocale The desired locale.\n+   * @param loc The desired locale.\n    * \n    * @return A new <code>DateFormat</code> instance.\n    */\n@@ -747,7 +776,7 @@ public static final DateFormat getTimeInstance (int style)\n    * localed will be used in place of the default.\n    *\n    * @param style The type of formatting to perform. \n-   * @param aLocale The desired locale.\n+   * @param loc The desired locale.\n    * \n    * @return A new <code>DateFormat</code> instance.\n    */\n@@ -821,7 +850,7 @@ public Date parse (String source) throws ParseException\n    * starting parse position on method entry and the ending parse\n    * position on method exit.\n    *\n-   * @param text The string to parse.\n+   * @param source The string to parse.\n    * @param pos The starting parse position in entry, the ending parse\n    * position on exit.\n    *\n@@ -851,7 +880,7 @@ public Object parseObject (String source, ParsePosition pos)\n    * This method specified the <code>Calendar</code> that should be used \n    * by this object to parse/format datetimes.\n    *\n-   * @param The new <code>Calendar</code> for this object.\n+   * @param calendar The new <code>Calendar</code> for this object.\n    *\n    * @see java.util.Calendar\n    */\n@@ -876,7 +905,7 @@ public void setLenient (boolean lenient)\n    * This method specifies the <code>NumberFormat</code> object that should\n    * be used by this object to parse/format times.\n    *\n-   * @param The <code>NumberFormat</code> in use by this object.\n+   * @param numberFormat The <code>NumberFormat</code> in use by this object.\n    */\n   public void setNumberFormat (NumberFormat numberFormat)\n   {\n@@ -886,7 +915,7 @@ public void setNumberFormat (NumberFormat numberFormat)\n   /**\n    * This method sets the time zone that should be used by this object.\n    *\n-   * @param The new time zone.\n+   * @param timeZone The new time zone.\n    */\n   public void setTimeZone (TimeZone timeZone)\n   {"}, {"sha": "27a806df1b6f499d9e79ce7f3e33230f200186c0", "filename": "libjava/java/text/DateFormatSymbols.java", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/035db16b87e0687bd77dc6a3d696bfd9be3080d1/libjava%2Fjava%2Ftext%2FDateFormatSymbols.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/035db16b87e0687bd77dc6a3d696bfd9be3080d1/libjava%2Fjava%2Ftext%2FDateFormatSymbols.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FDateFormatSymbols.java?ref=035db16b87e0687bd77dc6a3d696bfd9be3080d1", "patch": "@@ -266,7 +266,7 @@ public String[] getWeekdays ()\n    * This is a two element <code>String</code> array indexed by\n    * <code>Calendar.AM</code> and <code>Calendar.PM</code>\n    *\n-   * @param ampms The new list of AM/PM display strings.\n+   * @param value The new list of AM/PM display strings.\n    */\n   public void setAmPmStrings (String[] value)\n   {\n@@ -279,11 +279,11 @@ public void setAmPmStrings (String[] value)\n    * This is a two element <code>String</code>\n    * array indexed by <code>Calendar.BC</code> and <code>Calendar.AD</code>.\n    *\n-   * @param eras The new list of era disply strings.\n+   * @param labels The new list of era display strings.\n    */\n-  public void setEras (String[] value)\n+  public void setEras (String[] labels)\n   {\n-    eras = value;\n+    eras = labels;\n   }\n \n   /**\n@@ -317,11 +317,11 @@ public void setEras (String[] value)\n     * <li>17 - time zone (z)</li>\n     * </ul>\n     *\n-    * @param localPatternChars The new format patter characters\n+    * @param chars The new format pattern characters\n     */\n-  public void setLocalPatternChars (String value)\n+  public void setLocalPatternChars (String chars)\n   {\n-    localPatternChars = value;\n+    localPatternChars = chars;\n   }\n \n   /**\n@@ -331,11 +331,11 @@ public void setLocalPatternChars (String value)\n     * <code>Calendar.UNDECEMBER</code>.  Note that there are thirteen\n     * elements because some calendars have thriteen months.\n     *\n-    * @param months The list of month display strings.\n+    * @param labels The list of month display strings.\n     */\n-  public void setMonths (String[] value)\n+  public void setMonths (String[] labels)\n   {\n-    months = value;\n+    months = labels;\n   }\n \n   /**\n@@ -346,11 +346,11 @@ public void setMonths (String[] value)\n    * through <code>Calendar.UNDECEMBER</code>.  Note that there are thirteen\n    * elements because some calendars have thirteen months.\n    *\n-   * @param shortMonths The new list of abbreviated month display strings.\n+   * @param labels The new list of abbreviated month display strings.\n    */\n-  public void setShortMonths (String[] value)\n+  public void setShortMonths (String[] labels)\n   {\n-    shortMonths = value;\n+    shortMonths = labels;\n   }\n \n   /**\n@@ -361,11 +361,11 @@ public void setShortMonths (String[] value)\n    * through <code>Calendar.SATURDAY</code>.  Note that the first element\n    * of this array is ignored.\n    *\n-   * @param shortWeekdays This list of abbreviated weekday display strings.\n+   * @param labels This list of abbreviated weekday display strings.\n    */\n-  public void setShortWeekdays (String[] value)\n+  public void setShortWeekdays (String[] labels)\n   {\n-    shortWeekdays = value;\n+    shortWeekdays = labels;\n   }\n \n   /**\n@@ -375,11 +375,11 @@ public void setShortWeekdays (String[] value)\n    * through <code>Calendar.SATURDAY</code>.  Note that the first element\n    * of this array is ignored.\n    *\n-   * @param weekdays This list of weekday display strings.\n+   * @param labels This list of weekday display strings.\n    */\n-  public void setWeekdays (String[] value)\n+  public void setWeekdays (String[] labels)\n   {\n-    weekdays = value;\n+    weekdays = labels;\n   }\n \n   /**\n@@ -395,11 +395,11 @@ public void setWeekdays (String[] value)\n    * <li>4 - the short name of the time zone (daylight savings time).</li>\n    * </ul>\n    *\n-   * @return The list of time zone display strings.\n+   * @params zones The list of time zone display strings.\n    */\n-  public void setZoneStrings (String[][] value)\n+  public void setZoneStrings (String[][] zones)\n   {\n-    zoneStrings = value;\n+    zoneStrings = zones;\n   }\n \n   /* Does a \"deep\" equality test - recurses into arrays. */\n@@ -469,7 +469,7 @@ && equals(weekdays, other.weekdays)\n   /**\n    * Returns a new copy of this object.\n    *\n-   * @param A copy of this object\n+   * @return A copy of this object\n    */\n   public Object clone ()\n   {"}, {"sha": "c58530fc5442fe755662823f482fd34c29a8c7e6", "filename": "libjava/java/text/DecimalFormatSymbols.java", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/035db16b87e0687bd77dc6a3d696bfd9be3080d1/libjava%2Fjava%2Ftext%2FDecimalFormatSymbols.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/035db16b87e0687bd77dc6a3d696bfd9be3080d1/libjava%2Fjava%2Ftext%2FDecimalFormatSymbols.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FDecimalFormatSymbols.java?ref=035db16b87e0687bd77dc6a3d696bfd9be3080d1", "patch": "@@ -122,7 +122,7 @@ private char safeGetChar(ResourceBundle bundle,\n    * This method initializes a new instance of\n    * <code>DecimalFormatSymbols</code> for the specified locale.\n    *\n-   * @param locale The local to load symbols for.\n+   * @param loc The local to load symbols for.\n    */\n   public DecimalFormatSymbols (Locale loc)\n   {\n@@ -380,7 +380,7 @@ public void setCurrency (Currency currency)\n   /**\n    * This method sets the currency symbol to the specified value.\n    *\n-   * @param currencySymbol The new currency symbol\n+   * @param currency The new currency symbol\n    */\n   public void setCurrencySymbol (String currency)\n   {\n@@ -390,7 +390,7 @@ public void setCurrencySymbol (String currency)\n   /**\n    * This method sets the decimal point character to the specified value.\n    *\n-   * @param decimalSeparator The new decimal point character\n+   * @param decimalSep The new decimal point character\n    */\n   public void setDecimalSeparator (char decimalSep)\n   {\n@@ -417,7 +417,7 @@ void setExponential (char exp)\n   /**\n    * This method sets the character used to separate groups of digits.\n    *\n-   * @param groupingSeparator The character used to separate groups of digits.\n+   * @param groupSep The character used to separate groups of digits.\n    */\n   public void setGroupingSeparator (char groupSep)\n   {\n@@ -459,8 +459,7 @@ public void setMinusSign (char minusSign)\n    * This method sets the character used for the decimal point in currency\n    * values.\n    *\n-   * @param monetarySeparator The decimal point character used in\n-   *                          currency values. \n+   * @param decimalSep The decimal point character used in currency values. \n    */\n   public void setMonetaryDecimalSeparator (char decimalSep)\n   {\n@@ -471,7 +470,7 @@ public void setMonetaryDecimalSeparator (char decimalSep)\n    * This method sets the string used to represent the NaN (not a\n    * number) value. \n    *\n-   * @param NaN The string used to represent NaN\n+   * @param nan The string used to represent NaN\n    */\n   public void setNaN (String nan)\n   {\n@@ -482,7 +481,7 @@ public void setNaN (String nan)\n    * This method sets the character used to separate positive and negative\n    * subpatterns in a format pattern.\n    *\n-   * @param patternSeparator The character used to separate positive and\n+   * @param patternSep The character used to separate positive and\n    * negative subpatterns in a format pattern.\n    */\n   public void setPatternSeparator (char patternSep)"}, {"sha": "8a93b9f256dc984440c5580a714f99497a423040", "filename": "libjava/java/text/SimpleDateFormat.java", "status": "removed", "additions": 0, "deletions": 1237, "changes": 1237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b424a57253aafe26c07a50fecfd2a61999b06475/libjava%2Fjava%2Ftext%2FSimpleDateFormat.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b424a57253aafe26c07a50fecfd2a61999b06475/libjava%2Fjava%2Ftext%2FSimpleDateFormat.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FSimpleDateFormat.java?ref=b424a57253aafe26c07a50fecfd2a61999b06475", "patch": "@@ -1,1237 +0,0 @@\n-/* SimpleDateFormat.java -- A class for parsing/formating simple \n-   date constructs\n-   Copyright (C) 1998, 1999, 2000, 2001, 2003, 2004, 2005\n-   Free Software Foundation, Inc.\n-\n-This file is part of GNU Classpath.\n-\n-GNU Classpath is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n- \n-GNU Classpath is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Classpath; see the file COPYING.  If not, write to the\n-Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n-02110-1301 USA.\n-\n-Linking this library statically or dynamically with other modules is\n-making a combined work based on this library.  Thus, the terms and\n-conditions of the GNU General Public License cover the whole\n-combination.\n-\n-As a special exception, the copyright holders of this library give you\n-permission to link this library with independent modules to produce an\n-executable, regardless of the license terms of these independent\n-modules, and to copy and distribute the resulting executable under\n-terms of your choice, provided that you also meet, for each linked\n-independent module, the terms and conditions of the license of that\n-module.  An independent module is a module which is not derived from\n-or based on this library.  If you modify this library, you may extend\n-this exception to your version of the library, but you are not\n-obligated to do so.  If you do not wish to do so, delete this\n-exception statement from your version. */\n-\n-\n-package java.text;\n-\n-import gnu.java.text.AttributedFormatBuffer;\n-import gnu.java.text.FormatBuffer;\n-import gnu.java.text.FormatCharacterIterator;\n-import gnu.java.text.StringFormatBuffer;\n-\n-import java.io.IOException;\n-import java.io.InvalidObjectException;\n-import java.io.ObjectInputStream;\n-import java.util.ArrayList;\n-import java.util.Calendar;\n-import java.util.Date;\n-import java.util.GregorianCalendar;\n-import java.util.Iterator;\n-import java.util.Locale;\n-import java.util.TimeZone;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-\n-/**\n- * SimpleDateFormat provides convenient methods for parsing and formatting\n- * dates using Gregorian calendars (see java.util.GregorianCalendar). \n- */\n-public class SimpleDateFormat extends DateFormat \n-{\n-  /** \n-   * This class is used by <code>SimpleDateFormat</code> as a\n-   * compiled representation of a format string.  The field\n-   * ID, size, and character used are stored for each sequence\n-   * of pattern characters.\n-   */\n-  private class CompiledField\n-  {\n-    /**\n-     * The ID of the field within the local pattern characters,\n-     */\n-    private int field;\n-\n-    /**\n-     * The size of the character sequence.\n-     */\n-    private int size;\n-\n-    /**\n-     * The character used.\n-     */\n-    private char character;\n-\n-    /** \n-     * Constructs a compiled field using the\n-     * the given field ID, size and character\n-     * values.\n-     *\n-     * @param f the field ID.\n-     * @param s the size of the field.\n-     * @param c the character used.\n-     */\n-    public CompiledField(int f, int s, char c)\n-    {\n-      field = f;\n-      size = s;\n-      character = c;\n-    }\n-\n-    /**\n-     * Retrieves the ID of the field relative to\n-     * the local pattern characters.\n-     */\n-    public int getField()\n-    {\n-      return field;\n-    }\n-\n-    /**\n-     * Retrieves the size of the character sequence.\n-     */\n-    public int getSize()\n-    {\n-      return size;\n-    }\n-\n-    /**\n-     * Retrieves the character used in the sequence.\n-     */\n-    public char getCharacter()\n-    {\n-      return character;\n-    }\n-\n-    /**\n-     * Returns a <code>String</code> representation\n-     * of the compiled field, primarily for debugging\n-     * purposes.\n-     *\n-     * @return a <code>String</code> representation.\n-     */\n-    public String toString()\n-    {\n-      StringBuffer builder;\n-\n-      builder = new StringBuffer(getClass().getName());\n-      builder.append(\"[field=\");\n-      builder.append(field);\n-      builder.append(\", size=\");\n-      builder.append(size);\n-      builder.append(\", character=\");\n-      builder.append(character);\n-      builder.append(\"]\");\n-\n-      return builder.toString();\n-    }\n-  }\n-\n-  /**\n-   * A list of <code>CompiledField</code>s,\n-   * representing the compiled version of the pattern.\n-   *\n-   * @see CompiledField\n-   * @serial Ignored.\n-   */\n-  private transient ArrayList tokens;\n-\n-  /**\n-   * The localised data used in formatting,\n-   * such as the day and month names in the local\n-   * language, and the localized pattern characters.\n-   *\n-   * @see DateFormatSymbols\n-   * @serial The localisation data.  May not be null.\n-   */\n-  private DateFormatSymbols formatData;\n-\n-  /**\n-   * The date representing the start of the century\n-   * used for interpreting two digit years.  For\n-   * example, 24/10/2004 would cause two digit\n-   * years to be interpreted as representing\n-   * the years between 2004 and 2104.\n-   *\n-   * @see get2DigitYearStart()\n-   * @see set2DigitYearStart(java.util.Date)\n-   * @see Date\n-   * @serial The start date of the century for parsing two digit years.\n-   *         May not be null.\n-   */\n-  private Date defaultCenturyStart;\n-\n-  /**\n-   * The year at which interpretation of two\n-   * digit years starts.\n-   *\n-   * @see get2DigitYearStart()\n-   * @see set2DigitYearStart(java.util.Date)\n-   * @serial Ignored.\n-   */\n-  private transient int defaultCentury;\n-\n-  /**\n-   * The non-localized pattern string.  This\n-   * only ever contains the pattern characters\n-   * stored in standardChars.  Localized patterns\n-   * are translated to this form.\n-   *\n-   * @see applyPattern(String)\n-   * @see applyLocalizedPattern(String)\n-   * @see toPattern()\n-   * @see toLocalizedPattern()\n-   * @serial The non-localized pattern string.  May not be null.\n-   */\n-  private String pattern;\n-\n-  /**\n-   * The version of serialized data used by this class.\n-   * Version 0 only includes the pattern and formatting\n-   * data.  Version 1 adds the start date for interpreting\n-   * two digit years.\n-   *\n-   * @serial This specifies the version of the data being serialized.\n-   *         Version 0 (or no version) specifies just <code>pattern</code>\n-   *         and <code>formatData</code>.  Version 1 adds\n-   *         the <code>defaultCenturyStart</code>.  This implementation\n-   *         always writes out version 1 data.\n-   */\n-  private int serialVersionOnStream = 1; // 0 indicates JDK1.1.3 or earlier\n-\n-  /**\n-   * For compatability.\n-   */\n-  private static final long serialVersionUID = 4774881970558875024L;\n-\n-  // This string is specified in the root of the CLDR.  We set it here\n-  // rather than doing a DateFormatSymbols(Locale.US).getLocalPatternChars()\n-  // since someone could theoretically change those values (though unlikely).\n-  private static final String standardChars = \"GyMdkHmsSEDFwWahKzYeugAZ\";\n-\n-  /**\n-   * Reads the serialized version of this object.\n-   * If the serialized data is only version 0,\n-   * then the date for the start of the century\n-   * for interpreting two digit years is computed.\n-   * The pattern is parsed and compiled following the process\n-   * of reading in the serialized data.\n-   *\n-   * @param stream the object stream to read the data from.\n-   * @throws IOException if an I/O error occurs.\n-   * @throws ClassNotFoundException if the class of the serialized data\n-   *         could not be found.\n-   * @throws InvalidObjectException if the pattern is invalid.\n-   */ \n-  private void readObject(ObjectInputStream stream)\n-    throws IOException, ClassNotFoundException\n-  {\n-    stream.defaultReadObject();\n-    if (serialVersionOnStream < 1)\n-      {\n-        computeCenturyStart ();\n-\tserialVersionOnStream = 1;\n-      }\n-    else\n-      // Ensure that defaultCentury gets set.\n-      set2DigitYearStart(defaultCenturyStart);\n-\n-    // Set up items normally taken care of by the constructor.\n-    tokens = new ArrayList();\n-    try\n-      {\n-\tcompileFormat(pattern);\n-      }\n-    catch (IllegalArgumentException e)\n-      {\n-\tthrow new InvalidObjectException(\"The stream pattern was invalid.\");\n-      }\n-  }\n-\n-  /**\n-   * Compiles the supplied non-localized pattern into a form\n-   * from which formatting and parsing can be performed.\n-   * This also detects errors in the pattern, which will\n-   * be raised on later use of the compiled data.\n-   *\n-   * @param pattern the non-localized pattern to compile.\n-   * @throws IllegalArgumentException if the pattern is invalid.\n-   */\n-  private void compileFormat(String pattern) \n-  {\n-    // Any alphabetical characters are treated as pattern characters\n-    // unless enclosed in single quotes.\n-\n-    char thisChar;\n-    int pos;\n-    int field;\n-    CompiledField current = null;\n-\n-    for (int i=0; i<pattern.length(); i++) {\n-      thisChar = pattern.charAt(i);\n-      field = standardChars.indexOf(thisChar);\n-      if (field == -1) {\n-\tcurrent = null;\n-\tif ((thisChar >= 'A' && thisChar <= 'Z')\n-\t    || (thisChar >= 'a' && thisChar <= 'z')) {\n- \t  // Not a valid letter\n-\t  throw new IllegalArgumentException(\"Invalid letter \" + thisChar +\n-\t\t\t\t\t     \"encountered at character \" + i\n-\t\t\t\t\t     + \".\");\n-\t} else if (thisChar == '\\'') {\n-\t  // Quoted text section; skip to next single quote\n-\t  pos = pattern.indexOf('\\'',i+1);\n-\t  if (pos == -1) {\n-\t    throw new IllegalArgumentException(\"Quotes starting at character \"\n-\t\t\t\t\t       + i + \" not closed.\");\n-\t  }\n-\t  if ((pos+1 < pattern.length()) && (pattern.charAt(pos+1) == '\\'')) {\n-\t    tokens.add(pattern.substring(i+1,pos+1));\n-\t  } else {\n-\t    tokens.add(pattern.substring(i+1,pos));\n-\t  }\n-\t  i = pos;\n-\t} else {\n-\t  // A special character\n-\t  tokens.add(new Character(thisChar));\n-\t}\n-      } else {\n-\t// A valid field\n-\tif ((current != null) && (field == current.field)) {\n-\t  current.size++;\n-\t} else {\n-\t  current = new CompiledField(field,1,thisChar);\n-\t  tokens.add(current);\n-\t}\n-      }\n-    }\n-  }\n-\n-  /**\n-   * Returns a string representation of this\n-   * class.\n-   *\n-   * @return a string representation of the <code>SimpleDateFormat</code>\n-   *         instance.\n-   */\n-  public String toString() \n-  {\n-    StringBuffer output = new StringBuffer(getClass().getName());\n-    output.append(\"[tokens=\");\n-    output.append(tokens);\n-    output.append(\", formatData=\");\n-    output.append(formatData);\n-    output.append(\", defaultCenturyStart=\");\n-    output.append(defaultCenturyStart);\n-    output.append(\", defaultCentury=\");\n-    output.append(defaultCentury);\n-    output.append(\", pattern=\");\n-    output.append(pattern);\n-    output.append(\", serialVersionOnStream=\");\n-    output.append(serialVersionOnStream);\n-    output.append(\", standardChars=\");\n-    output.append(standardChars);\n-    output.append(\"]\");\n-    return output.toString();\n-  }\n-\n-  /**\n-   * Constructs a SimpleDateFormat using the default pattern for\n-   * the default locale.\n-   */\n-  public SimpleDateFormat() \n-  {\n-    /*\n-     * There does not appear to be a standard API for determining \n-     * what the default pattern for a locale is, so use package-scope\n-     * variables in DateFormatSymbols to encapsulate this.\n-     */\n-    super();\n-    Locale locale = Locale.getDefault();\n-    calendar = new GregorianCalendar(locale);\n-    computeCenturyStart();\n-    tokens = new ArrayList();\n-    formatData = new DateFormatSymbols(locale);\n-    pattern = (formatData.dateFormats[DEFAULT] + ' '\n-\t       + formatData.timeFormats[DEFAULT]);\n-    compileFormat(pattern);\n-    numberFormat = NumberFormat.getInstance(locale);\n-    numberFormat.setGroupingUsed (false);\n-    numberFormat.setParseIntegerOnly (true);\n-    numberFormat.setMaximumFractionDigits (0);\n-  }\n-  \n-  /**\n-   * Creates a date formatter using the specified non-localized pattern,\n-   * with the default DateFormatSymbols for the default locale.\n-   *\n-   * @param pattern the pattern to use.\n-   * @throws NullPointerException if the pattern is null.\n-   * @throws IllegalArgumentException if the pattern is invalid.\n-   */\n-  public SimpleDateFormat(String pattern) \n-  {\n-    this(pattern, Locale.getDefault());\n-  }\n-\n-  /**\n-   * Creates a date formatter using the specified non-localized pattern,\n-   * with the default DateFormatSymbols for the given locale.\n-   *\n-   * @param pattern the non-localized pattern to use.\n-   * @param locale the locale to use for the formatting symbols.\n-   * @throws NullPointerException if the pattern is null.\n-   * @throws IllegalArgumentException if the pattern is invalid.\n-   */\n-  public SimpleDateFormat(String pattern, Locale locale) \n-  {\n-    super();\n-    calendar = new GregorianCalendar(locale);\n-    computeCenturyStart();\n-    tokens = new ArrayList();\n-    formatData = new DateFormatSymbols(locale);\n-    compileFormat(pattern);\n-    this.pattern = pattern;\n-    numberFormat = NumberFormat.getInstance(locale);\n-    numberFormat.setGroupingUsed (false);\n-    numberFormat.setParseIntegerOnly (true);\n-    numberFormat.setMaximumFractionDigits (0);\n-  }\n-\n-  /**\n-   * Creates a date formatter using the specified non-localized\n-   * pattern. The specified DateFormatSymbols will be used when\n-   * formatting.\n-   *\n-   * @param pattern the non-localized pattern to use.\n-   * @param formatData the formatting symbols to use.\n-   * @throws NullPointerException if the pattern or formatData is null.\n-   * @throws IllegalArgumentException if the pattern is invalid.\n-   */\n-  public SimpleDateFormat(String pattern, DateFormatSymbols formatData)\n-  {\n-    super();\n-    calendar = new GregorianCalendar();\n-    computeCenturyStart ();\n-    tokens = new ArrayList();\n-    if (formatData == null)\n-      throw new NullPointerException(\"formatData\");\n-    this.formatData = formatData;\n-    compileFormat(pattern);\n-    this.pattern = pattern;\n-    numberFormat = NumberFormat.getInstance();\n-    numberFormat.setGroupingUsed (false);\n-    numberFormat.setParseIntegerOnly (true);\n-    numberFormat.setMaximumFractionDigits (0);\n-  }\n-\n-  /**\n-   * This method returns a string with the formatting pattern being used\n-   * by this object.  This string is unlocalized.\n-   *\n-   * @return The format string.\n-   */\n-  public String toPattern()\n-  {\n-    return pattern;\n-  }\n-\n-  /**\n-   * This method returns a string with the formatting pattern being used\n-   * by this object.  This string is localized.\n-   *\n-   * @return The format string.\n-   */\n-  public String toLocalizedPattern()\n-  {\n-    String localChars = formatData.getLocalPatternChars();\n-    return translateLocalizedPattern(pattern, standardChars, localChars);\n-  }\n-\n-  /**\n-   * This method sets the formatting pattern that should be used by this\n-   * object.  This string is not localized.\n-   *\n-   * @param pattern The new format pattern.\n-   * @throws NullPointerException if the pattern is null.\n-   * @throws IllegalArgumentException if the pattern is invalid.\n-   */\n-  public void applyPattern(String pattern)\n-  {\n-    tokens = new ArrayList();\n-    compileFormat(pattern);\n-    this.pattern = pattern;\n-  }\n-\n-  /**\n-   * This method sets the formatting pattern that should be used by this\n-   * object.  This string is localized.\n-   *\n-   * @param pattern The new format pattern.\n-   * @throws NullPointerException if the pattern is null.\n-   * @throws IllegalArgumentException if the pattern is invalid.\n-   */\n-  public void applyLocalizedPattern(String pattern)\n-  {\n-    String localChars = formatData.getLocalPatternChars();\n-    pattern = translateLocalizedPattern(pattern, localChars, standardChars);\n-    applyPattern(pattern);\n-  }\n-\n-  /**\n-   * Translates either from or to a localized variant of the pattern\n-   * string.  For example, in the German locale, 't' (for 'tag') is\n-   * used instead of 'd' (for 'date').  This method translates\n-   * a localized pattern (such as 'ttt') to a non-localized pattern\n-   * (such as 'ddd'), or vice versa.  Non-localized patterns use\n-   * a standard set of characters, which match those of the U.S. English\n-   * locale.\n-   *\n-   * @param pattern the pattern to translate.\n-   * @param oldChars the old set of characters (used in the pattern).\n-   * @param newChars the new set of characters (which will be used in the\n-   *                 pattern).\n-   * @return a version of the pattern using the characters in\n-   *         <code>newChars</code>.\n-   */\n-  private String translateLocalizedPattern(String pattern,\n-\t\t\t\t\t   String oldChars, String newChars)\n-  {\n-    int len = pattern.length();\n-    StringBuffer buf = new StringBuffer(len);\n-    boolean quoted = false;\n-    for (int i = 0;  i < len;  i++)\n-      {\n-\tchar ch = pattern.charAt(i);\n-\tif (ch == '\\'')\n-\t  quoted = ! quoted;\n-\tif (! quoted)\n-\t  {\n-\t    int j = oldChars.indexOf(ch);\n-\t    if (j >= 0)\n-\t      ch = newChars.charAt(j);\n-\t  }\n-\tbuf.append(ch);\n-      }\n-    return buf.toString();\n-  }\n-\n-  /** \n-   * Returns the start of the century used for two digit years.\n-   *\n-   * @return A <code>Date</code> representing the start of the century\n-   * for two digit years.\n-   */\n-  public Date get2DigitYearStart()\n-  {\n-    return defaultCenturyStart;\n-  }\n-\n-  /**\n-   * Sets the start of the century used for two digit years.\n-   *\n-   * @param date A <code>Date</code> representing the start of the century for\n-   * two digit years.\n-   */\n-  public void set2DigitYearStart(Date date)\n-  {\n-    defaultCenturyStart = date;\n-    calendar.clear();\n-    calendar.setTime(date);\n-    int year = calendar.get(Calendar.YEAR);\n-    defaultCentury = year - (year % 100);\n-  }\n-\n-  /**\n-   * This method returns a copy of the format symbol information used\n-   * for parsing and formatting dates.\n-   *\n-   * @return a copy of the date format symbols.\n-   */\n-  public DateFormatSymbols getDateFormatSymbols()\n-  {\n-    return (DateFormatSymbols) formatData.clone();\n-  }\n-\n-  /**\n-   * This method sets the format symbols information used for parsing\n-   * and formatting dates.\n-   *\n-   * @param formatData The date format symbols.\n-   * @throws NullPointerException if <code>formatData</code> is null.\n-   */\n-   public void setDateFormatSymbols(DateFormatSymbols formatData)\n-   {\n-     if (formatData == null)\n-       {\n-\t throw new\n-\t   NullPointerException(\"The supplied format data was null.\");\n-       }\n-     this.formatData = formatData;\n-   }\n-\n-  /**\n-   * This methods tests whether the specified object is equal to this\n-   * object.  This will be true if and only if the specified object:\n-   * <p>\n-   * <ul>\n-   * <li>Is not <code>null</code>.</li>\n-   * <li>Is an instance of <code>SimpleDateFormat</code>.</li>\n-   * <li>Is equal to this object at the superclass (i.e., <code>DateFormat</code>)\n-   *     level.</li>\n-   * <li>Has the same formatting pattern.</li>\n-   * <li>Is using the same formatting symbols.</li>\n-   * <li>Is using the same century for two digit years.</li>\n-   * </ul>\n-   *\n-   * @param obj The object to compare for equality against.\n-   *\n-   * @return <code>true</code> if the specified object is equal to this object,\n-   * <code>false</code> otherwise.\n-   */\n-  public boolean equals(Object o)\n-  {\n-    if (!super.equals(o))\n-      return false;\n-\n-    if (!(o instanceof SimpleDateFormat))\n-      return false;\n-\n-    SimpleDateFormat sdf = (SimpleDateFormat)o;\n-\n-    if (defaultCentury != sdf.defaultCentury)\n-      return false;\n-\n-    if (!toPattern().equals(sdf.toPattern()))\n-      return false;\n-\n-    if (!getDateFormatSymbols().equals(sdf.getDateFormatSymbols()))\n-      return false;\n-\n-    return true;\n-  }\n-\n-  /**\n-   * This method returns a hash value for this object.\n-   *\n-   * @return A hash value for this object.\n-   */\n-  public int hashCode()\n-  {\n-    return super.hashCode() ^ toPattern().hashCode() ^ defaultCentury ^\n-      getDateFormatSymbols().hashCode();\n-  }\n-\n-\n-  /**\n-   * Formats the date input according to the format string in use,\n-   * appending to the specified StringBuffer.  The input StringBuffer\n-   * is returned as output for convenience.\n-   */\n-  private void formatWithAttribute(Date date, FormatBuffer buffer, FieldPosition pos)\n-  {\n-    String temp;\n-    AttributedCharacterIterator.Attribute attribute;\n-    calendar.setTime(date);\n-\n-    // go through vector, filling in fields where applicable, else toString\n-    Iterator iter = tokens.iterator();\n-    while (iter.hasNext())\n-      {\n-\tObject o = iter.next();\n-\tif (o instanceof CompiledField)\n-\t  {\n-\t    CompiledField cf = (CompiledField) o;\n-\t    int beginIndex = buffer.length();\n-\t    \n-\t    switch (cf.getField())\n-\t      {\n-\t      case ERA_FIELD:\n-\t\tbuffer.append (formatData.eras[calendar.get (Calendar.ERA)], DateFormat.Field.ERA);\n-\t\tbreak;\n-\t      case YEAR_FIELD:\n-\t\t// If we have two digits, then we truncate.  Otherwise, we\n-\t\t// use the size of the pattern, and zero pad.\n-\t\tbuffer.setDefaultAttribute (DateFormat.Field.YEAR);\n-\t\tif (cf.getSize() == 2)\n-\t\t  {\n-\t\t    temp = \"00\"+String.valueOf (calendar.get (Calendar.YEAR));\n-\t\t    buffer.append (temp.substring (temp.length() - 2));\n-\t\t  }\n-\t\telse\n-\t\t  withLeadingZeros (calendar.get (Calendar.YEAR), cf.getSize(), buffer);\n-\t\tbreak;\n-\t      case MONTH_FIELD:\n-\t\tbuffer.setDefaultAttribute (DateFormat.Field.MONTH);\n-\t\tif (cf.getSize() < 3)\n-\t\t  withLeadingZeros (calendar.get (Calendar.MONTH) + 1, cf.getSize(), buffer);\n-\t\telse if (cf.getSize() < 4)\n-\t\t  buffer.append (formatData.shortMonths[calendar.get (Calendar.MONTH)]);\n-\t\telse\n-\t\t  buffer.append (formatData.months[calendar.get (Calendar.MONTH)]);\n-\t\tbreak;\n-\t      case DATE_FIELD:\n-\t\tbuffer.setDefaultAttribute (DateFormat.Field.DAY_OF_MONTH);\n-\t\twithLeadingZeros (calendar.get (Calendar.DATE), cf.getSize(), buffer);\n-\t\tbreak;\n-\t      case HOUR_OF_DAY1_FIELD: // 1-24\n-\t\tbuffer.setDefaultAttribute(DateFormat.Field.HOUR_OF_DAY1);\n-\t\twithLeadingZeros ( ((calendar.get (Calendar.HOUR_OF_DAY) + 23) % 24) + 1, \n-\t\t\t\t   cf.getSize(), buffer);\n-\t\tbreak;\n-\t      case HOUR_OF_DAY0_FIELD: // 0-23\n-\t\tbuffer.setDefaultAttribute (DateFormat.Field.HOUR_OF_DAY0);\n-\t\twithLeadingZeros (calendar.get (Calendar.HOUR_OF_DAY), cf.getSize(), buffer);\n-\t\tbreak;\n-\t      case MINUTE_FIELD:\n-\t\tbuffer.setDefaultAttribute (DateFormat.Field.MINUTE);\n-\t\twithLeadingZeros (calendar.get (Calendar.MINUTE),\n-\t\t\t\t  cf.getSize(), buffer);\n-\t\tbreak;\n-\t      case SECOND_FIELD:\n-\t\tbuffer.setDefaultAttribute (DateFormat.Field.SECOND);\n-\t\twithLeadingZeros(calendar.get (Calendar.SECOND), \n-\t\t\t\t cf.getSize(), buffer);\n-\t\tbreak;\n-\t      case MILLISECOND_FIELD:\n-\t\tbuffer.setDefaultAttribute (DateFormat.Field.MILLISECOND);\n-\t\twithLeadingZeros (calendar.get (Calendar.MILLISECOND), cf.getSize(), buffer);\n-\t\tbreak;\n-\t      case DAY_OF_WEEK_FIELD:\n-\t\tbuffer.setDefaultAttribute (DateFormat.Field.DAY_OF_WEEK);\n-\t\tif (cf.getSize() < 4)\n-\t\t  buffer.append (formatData.shortWeekdays[calendar.get (Calendar.DAY_OF_WEEK)]);\n-\t\telse\n-\t\t  buffer.append (formatData.weekdays[calendar.get (Calendar.DAY_OF_WEEK)]);\n-\t\tbreak;\n-\t      case DAY_OF_YEAR_FIELD:\n-\t\tbuffer.setDefaultAttribute (DateFormat.Field.DAY_OF_YEAR);\n-\t\twithLeadingZeros (calendar.get (Calendar.DAY_OF_YEAR), cf.getSize(), buffer);\n-\t\tbreak;\n-\t      case DAY_OF_WEEK_IN_MONTH_FIELD:\n-\t\tbuffer.setDefaultAttribute (DateFormat.Field.DAY_OF_WEEK_IN_MONTH);\n-\t\twithLeadingZeros (calendar.get (Calendar.DAY_OF_WEEK_IN_MONTH), \n-\t\t\t\t cf.getSize(), buffer);\n-\t\tbreak;\n-\t      case WEEK_OF_YEAR_FIELD:\n-\t\tbuffer.setDefaultAttribute (DateFormat.Field.WEEK_OF_YEAR);\n-\t\twithLeadingZeros (calendar.get (Calendar.WEEK_OF_YEAR),\n-\t\t\t\t  cf.getSize(), buffer);\n-\t\tbreak;\n-\t      case WEEK_OF_MONTH_FIELD:\n-\t\tbuffer.setDefaultAttribute (DateFormat.Field.WEEK_OF_MONTH);\n-\t\twithLeadingZeros (calendar.get (Calendar.WEEK_OF_MONTH),\n-\t\t\t\t  cf.getSize(), buffer);\n-\t\tbreak;\n-\t      case AM_PM_FIELD:\n-\t\tbuffer.setDefaultAttribute (DateFormat.Field.AM_PM);\n-\t\tbuffer.append (formatData.ampms[calendar.get (Calendar.AM_PM)]);\n-\t\tbreak;\n-\t      case HOUR1_FIELD: // 1-12\n-\t\tbuffer.setDefaultAttribute (DateFormat.Field.HOUR1);\n-\t\twithLeadingZeros (((calendar.get (Calendar.HOUR) + 11) % 12) + 1,\n-\t\t\t\t  cf.getSize(), buffer);\n-\t\tbreak;\n-\t      case HOUR0_FIELD: // 0-11\n-\t\tbuffer.setDefaultAttribute (DateFormat.Field.HOUR0);\n-\t\twithLeadingZeros (calendar.get (Calendar.HOUR), cf.getSize(), buffer);\n-\t\tbreak;\n-\t      case TIMEZONE_FIELD:\n-\t\tbuffer.setDefaultAttribute (DateFormat.Field.TIME_ZONE);\n-\t\tTimeZone zone = calendar.getTimeZone();\n-\t\tboolean isDST = calendar.get (Calendar.DST_OFFSET) != 0;\n-\t\t// FIXME: XXX: This should be a localized time zone.\n-\t\tString zoneID = zone.getDisplayName\n-\t\t  (isDST, cf.getSize() > 3 ? TimeZone.LONG : TimeZone.SHORT);\n-\t\tbuffer.append (zoneID);\n-\t\tbreak;\n-\t      case RFC822_TIMEZONE_FIELD:\n-\t\tbuffer.setDefaultAttribute(DateFormat.Field.RFC822_TIME_ZONE);\n-\t\tint pureMinutes = (calendar.get(Calendar.ZONE_OFFSET) +\n-\t\t\t\t   calendar.get(Calendar.DST_OFFSET)) / (1000 * 60);\n-\t\tString sign = (pureMinutes < 0) ? \"-\" : \"+\";\t  \n-\t\tint hours = pureMinutes / 60;\n-\t\tint minutes = pureMinutes % 60;\n-\t\tbuffer.append(sign);\n-\t\twithLeadingZeros(hours, 2, buffer);\n-\t\twithLeadingZeros(minutes, 2, buffer);\n-\t\tbreak;\n-\t      default:\n-\t\tthrow new IllegalArgumentException (\"Illegal pattern character \" +\n-\t\t\t\t\t\t    cf.getCharacter());\n-\t      }\n-\t    if (pos != null && (buffer.getDefaultAttribute() == pos.getFieldAttribute()\n-\t\t\t\t|| cf.getField() == pos.getField()))\n-\t      {\n-\t\tpos.setBeginIndex(beginIndex);\n-\t\tpos.setEndIndex(buffer.length());\n-\t      }\n-\t  } \n-      else\n-\t{  \n-\t  buffer.append(o.toString(), null);\n-\t}\n-      }\n-  }\n-  \n-  public StringBuffer format(Date date, StringBuffer buffer, FieldPosition pos)\n-  {\n-    formatWithAttribute(date, new StringFormatBuffer (buffer), pos);\n-\n-    return buffer;\n-  }\n-\n-  public AttributedCharacterIterator formatToCharacterIterator(Object date)\n-    throws IllegalArgumentException\n-  {\n-    if (date == null)\n-      throw new NullPointerException(\"null argument\");\n-    if (!(date instanceof Date))\n-      throw new IllegalArgumentException(\"argument should be an instance of java.util.Date\");\n-\n-    AttributedFormatBuffer buf = new AttributedFormatBuffer();\n-    formatWithAttribute((Date)date, buf,\n-\t\t\tnull);\n-    buf.sync();\n-        \n-    return new FormatCharacterIterator(buf.getBuffer().toString(),\n-\t\t\t\t       buf.getRanges(),\n-\t\t\t\t       buf.getAttributes());\n-  }\n-\n-  private void withLeadingZeros(int value, int length, FormatBuffer buffer) \n-  {\n-    String valStr = String.valueOf(value);\n-    for (length -= valStr.length(); length > 0; length--)\n-      buffer.append('0');\n-    buffer.append(valStr);\n-  }\n-\n-  private boolean expect(String source, ParsePosition pos, char ch)\n-  {\n-    int x = pos.getIndex();\n-    boolean r = x < source.length() && source.charAt(x) == ch;\n-    if (r)\n-      pos.setIndex(x + 1);\n-    else\n-      pos.setErrorIndex(x);\n-    return r;\n-  }\n-\n-  /**\n-   * This method parses the specified string into a date.\n-   * \n-   * @param dateStr The date string to parse.\n-   * @param pos The input and output parse position\n-   *\n-   * @return The parsed date, or <code>null</code> if the string cannot be\n-   * parsed.\n-   */\n-  public Date parse (String dateStr, ParsePosition pos)\n-  {\n-    int fmt_index = 0;\n-    int fmt_max = pattern.length();\n-\n-    calendar.clear();\n-    boolean saw_timezone = false;\n-    int quote_start = -1;\n-    boolean is2DigitYear = false;\n-    try\n-      {\n-\tfor (; fmt_index < fmt_max; ++fmt_index)\n-\t  {\n-\t    char ch = pattern.charAt(fmt_index);\n-\t    if (ch == '\\'')\n-\t      {\n-\t\tint index = pos.getIndex();\n-\t\tif (fmt_index < fmt_max - 1\n-\t\t    && pattern.charAt(fmt_index + 1) == '\\'')\n-\t\t  {\n-\t\t    if (! expect (dateStr, pos, ch))\n-\t\t      return null;\n-\t\t    ++fmt_index;\n-\t\t  }\n-\t\telse\n-\t\t  quote_start = quote_start < 0 ? fmt_index : -1;\n-\t\tcontinue;\n-\t      }\n-\t    \n-\t    if (quote_start != -1\n-\t\t|| ((ch < 'a' || ch > 'z')\n-\t\t    && (ch < 'A' || ch > 'Z')))\n-\t      {\n-\t\tif (! expect (dateStr, pos, ch))\n-\t\t  return null;\n-\t\tcontinue;\n-\t      }\n-\t    \n-\t    // We've arrived at a potential pattern character in the\n-\t    // pattern.\n-\t    int fmt_count = 1;\n-\t    while (++fmt_index < fmt_max && pattern.charAt(fmt_index) == ch)\n-\t      {\n-\t\t++fmt_count;\n-\t      }\n-\t    \n-\t    // We might need to limit the number of digits to parse in\n-\t    // some cases.  We look to the next pattern character to\n-\t    // decide.\n-\t    boolean limit_digits = false;\n-\t    if (fmt_index < fmt_max\n-\t\t&& standardChars.indexOf(pattern.charAt(fmt_index)) >= 0)\n-\t      limit_digits = true;\n-\t    --fmt_index;\n-\t    \n-\t    // We can handle most fields automatically: most either are\n-\t    // numeric or are looked up in a string vector.  In some cases\n-\t    // we need an offset.  When numeric, `offset' is added to the\n-\t    // resulting value.  When doing a string lookup, offset is the\n-\t    // initial index into the string array.\n-\t    int calendar_field;\n-\t    boolean is_numeric = true;\n-\t    int offset = 0;\n-\t    boolean maybe2DigitYear = false;\n-\t    boolean oneBasedHour = false;\n-\t    boolean oneBasedHourOfDay = false;\n-\t    Integer simpleOffset;\n-\t    String[] set1 = null;\n-\t    String[] set2 = null;\n-\t    switch (ch)\n-\t      {\n-\t      case 'd':\n-\t\tcalendar_field = Calendar.DATE;\n-\t\tbreak;\n-\t      case 'D':\n-\t\tcalendar_field = Calendar.DAY_OF_YEAR;\n-\t\tbreak;\n-\t      case 'F':\n-\t\tcalendar_field = Calendar.DAY_OF_WEEK_IN_MONTH;\n-\t\tbreak;\n-\t      case 'E':\n-\t\tis_numeric = false;\n-\t\toffset = 1;\n-\t\tcalendar_field = Calendar.DAY_OF_WEEK;\n-\t\tset1 = formatData.getWeekdays();\n-\t\tset2 = formatData.getShortWeekdays();\n-\t\tbreak;\n-\t      case 'w':\n-\t\tcalendar_field = Calendar.WEEK_OF_YEAR;\n-\t\tbreak;\n-\t      case 'W':\n-\t\tcalendar_field = Calendar.WEEK_OF_MONTH;\n-\t\tbreak;\n-\t      case 'M':\n-\t\tcalendar_field = Calendar.MONTH;\n-\t\tif (fmt_count <= 2)\n-\t\t  offset = -1;\n-\t\telse\n-\t\t  {\n-\t\t    is_numeric = false;\n-\t\t    set1 = formatData.getMonths();\n-\t\t    set2 = formatData.getShortMonths();\n-\t\t  }\n-\t\tbreak;\n-\t      case 'y':\n-\t\tcalendar_field = Calendar.YEAR;\n-\t\tif (fmt_count <= 2)\n-\t\t  maybe2DigitYear = true;\n-\t\tbreak;\n-\t      case 'K':\n-\t\tcalendar_field = Calendar.HOUR;\n-\t\tbreak;\n-\t      case 'h':\n-\t\tcalendar_field = Calendar.HOUR;\n-\t\toneBasedHour = true;\n-\t\tbreak;\n-\t      case 'H':\n-\t\tcalendar_field = Calendar.HOUR_OF_DAY;\n-\t\tbreak;\n-\t      case 'k':\n-\t\tcalendar_field = Calendar.HOUR_OF_DAY;\n-\t\toneBasedHourOfDay = true;\n-\t\tbreak;\n-\t      case 'm':\n-\t\tcalendar_field = Calendar.MINUTE;\n-\t\tbreak;\n-\t      case 's':\n-\t\tcalendar_field = Calendar.SECOND;\n-\t\tbreak;\n-\t      case 'S':\n-\t\tcalendar_field = Calendar.MILLISECOND;\n-\t\tbreak;\n-\t      case 'a':\n-\t\tis_numeric = false;\n-\t\tcalendar_field = Calendar.AM_PM;\n-\t\tset1 = formatData.getAmPmStrings();\n-\t\tbreak;\n-\t      case 'z':\n-\t      case 'Z':\n-\t\t// We need a special case for the timezone, because it\n-\t\t// uses a different data structure than the other cases.\n-\t\tis_numeric = false;\n-\t\tcalendar_field = Calendar.ZONE_OFFSET;\n-\t\tString[][] zoneStrings = formatData.getZoneStrings();\n-\t\tint zoneCount = zoneStrings.length;\n-\t\tint index = pos.getIndex();\n-\t\tboolean found_zone = false;\n-\t\tsimpleOffset = computeOffset(dateStr.substring(index));\n-\t\tif (simpleOffset != null)\n-\t\t  {\n-\t\t    found_zone = true;\n-\t\t    saw_timezone = true;\n-\t\t    calendar.set(Calendar.DST_OFFSET, 0);\n-\t\t    offset = simpleOffset.intValue();\n-\t\t  }\n-\t\telse\n-\t\t  {\n-\t\t    for (int j = 0;  j < zoneCount;  j++)\n-\t\t      {\n-\t\t\tString[] strings = zoneStrings[j];\n-\t\t\tint k;\n-\t\t\tfor (k = 0; k < strings.length; ++k)\n-\t\t\t  {\n-\t\t\t    if (dateStr.startsWith(strings[k], index))\n-\t\t\t      break;\n-\t\t\t  }\n-\t\t\tif (k != strings.length)\n-\t\t\t  {\n-\t\t\t    found_zone = true;\n-\t\t\t    saw_timezone = true;\n-\t\t\t    TimeZone tz = TimeZone.getTimeZone (strings[0]);\n-\t\t\t    // Check if it's a DST zone or ordinary \n-\t\t\t    if(k == 3 || k == 4)\n-\t\t\t      calendar.set (Calendar.DST_OFFSET, tz.getDSTSavings());\n-\t\t\t    else\n-\t\t\t      calendar.set (Calendar.DST_OFFSET, 0);\n-                            offset = tz.getRawOffset ();\n-\t\t\t    pos.setIndex(index + strings[k].length());\n-\t\t\t    break;\n-\t\t\t  }\n-\t\t      }\n-\t\t  }\n-\t\tif (! found_zone)\n-\t\t  {\n-\t\t\tpos.setErrorIndex(pos.getIndex());\n-\t\t\treturn null;\n-\t\t  }\n-\t\tbreak;\n-\t      default:\n-\t\tpos.setErrorIndex(pos.getIndex());\n-\t\treturn null;\n-\t      }\n-      \n-\t    // Compute the value we should assign to the field.\n-\t    int value;\n-\t    int index = -1;\n-\t    if (is_numeric)\n-\t      {\n-\t\tnumberFormat.setMinimumIntegerDigits(fmt_count);\n-\t\tif (limit_digits)\n-\t\t  numberFormat.setMaximumIntegerDigits(fmt_count);\n-\t\tif (maybe2DigitYear)\n-\t\t  index = pos.getIndex();\n-\t\tNumber n = numberFormat.parse(dateStr, pos);\n-\t\tif (pos == null || ! (n instanceof Long))\n-\t\t  return null;\n-\t\tvalue = n.intValue() + offset;\n-\t      }\n-\t    else if (set1 != null)\n-\t      {\n-\t\tindex = pos.getIndex();\n-\t\tint i;\n-\t\tboolean found = false;\n-\t\tfor (i = offset; i < set1.length; ++i)\n-\t\t  {\n-\t\t    if (set1[i] != null)\n-\t\t      if (dateStr.toUpperCase().startsWith(set1[i].toUpperCase(),\n-\t\t\t\t\t\t\t   index))\n-\t\t\t{\n-\t\t\t  found = true;\n-\t\t\t  pos.setIndex(index + set1[i].length());\n-\t\t\t  break;\n-\t\t\t}\n-\t\t  }\n-\t\tif (!found && set2 != null)\n-\t\t  {\n-\t\t    for (i = offset; i < set2.length; ++i)\n-\t\t      {\n-\t\t\tif (set2[i] != null)\n-\t\t\t  if (dateStr.toUpperCase().startsWith(set2[i].toUpperCase(),\n-\t\t\t\t\t\t\t       index))\n-\t\t\t    {\n-\t\t\t      found = true;\n-\t\t\t      pos.setIndex(index + set2[i].length());\n-\t\t\t      break;\n-\t\t\t    }\n-\t\t      }\n-\t\t  }\n-\t\tif (!found)\n-\t\t  {\n-\t\t    pos.setErrorIndex(index);\n-\t\t    return null;\n-\t\t  }\n-\t\tvalue = i;\n-\t      }\n-\t    else\n-\t      value = offset;\n-\t  \n-\t    if (maybe2DigitYear)\n-\t      {\n-\t\t// Parse into default century if the numeric year string has \n-\t\t// exactly 2 digits.\n-\t\tint digit_count = pos.getIndex() - index;\n-\t\tif (digit_count == 2)\n-\t\t  {\n-\t\t    is2DigitYear = true;\n-\t\t    value += defaultCentury;\n-\t\t  }\n-\t      }\n-\t    \n-\t    // Calendar uses 0-based hours. \n-\t    // I.e. 00:00 AM is midnight, not 12 AM or 24:00\n-\t    if (oneBasedHour && value == 12)\n-\t      value = 0;\n-\n-\t    if (oneBasedHourOfDay && value == 24)\n-\t      value = 0;\n-\t    \n-\t    // Assign the value and move on.\n-\t    calendar.set(calendar_field, value);\n-\t  }\n-    \n-\tif (is2DigitYear)\n-\t  {\n-\t    // Apply the 80-20 heuristic to dermine the full year based on \n-\t    // defaultCenturyStart. \n-\t    int year = calendar.get(Calendar.YEAR);\n-\t    if (calendar.getTime().compareTo(defaultCenturyStart) < 0)\n-\t      calendar.set(Calendar.YEAR, year + 100);      \n-\t  }\n-\tif (! saw_timezone)\n-\t  {\n-\t    // Use the real rules to determine whether or not this\n-\t    // particular time is in daylight savings.\n-\t    calendar.clear (Calendar.DST_OFFSET);\n-\t    calendar.clear (Calendar.ZONE_OFFSET);\n-\t  }\n-        return calendar.getTime();\n-      }\n-    catch (IllegalArgumentException x)\n-      {\n-        pos.setErrorIndex(pos.getIndex());\n-\treturn null;\n-      }\n-      }\n-\n-  /**\n-   * <p>\n-   * Computes the time zone offset in milliseconds\n-   * relative to GMT, based on the supplied\n-   * <code>String</code> representation.\n-   * </p>\n-   * <p>\n-   * The supplied <code>String</code> must be a three\n-   * or four digit signed number, with an optional 'GMT'\n-   * prefix.  The first one or two digits represents the hours,\n-   * while the last two represent the minutes.  The\n-   * two sets of digits can optionally be separated by\n-   * ':'.  The mandatory sign prefix (either '+' or '-')\n-   * indicates the direction of the offset from GMT.\n-   * </p>\n-   * <p>\n-   * For example, 'GMT+0200' specifies 2 hours after\n-   * GMT, while '-05:00' specifies 5 hours prior to\n-   * GMT.  The special case of 'GMT' alone can be used\n-   * to represent the offset, 0.\n-   * </p>\n-   * <p>\n-   * If the <code>String</code> can not be parsed,\n-   * the result will be null.  The resulting offset\n-   * is wrapped in an <code>Integer</code> object, in\n-   * order to allow such failure to be represented.\n-   * </p>\n-   *\n-   * @param zoneString a string in the form \n-   *        (GMT)? sign hours : minutes\n-   *        where sign = '+' or '-', hours\n-   *        is a one or two digits representing\n-   *        a number between 0 and 23, and\n-   *        minutes is two digits representing\n-   *        a number between 0 and 59.\n-   * @return the parsed offset, or null if parsing\n-   *         failed.\n-   */\n-  private Integer computeOffset(String zoneString)\n-  {\n-    Pattern pattern =\n-      Pattern.compile(\"(GMT)?([+-])([012])?([0-9]):?([0-9]{2})\");\n-    Matcher matcher = pattern.matcher(zoneString);\n-    if (matcher.matches())\n-      {\n-\tint sign = matcher.group(2).equals(\"+\") ? 1 : -1;\n-\tint hour = (Integer.parseInt(matcher.group(3)) * 10)\n-\t  + Integer.parseInt(matcher.group(4));\n-\tint minutes = Integer.parseInt(matcher.group(5));\n-\n-\tif (hour > 23)\n-\t  return null;\n-\n-\tint offset = sign * ((hour * 60) + minutes) * 60000;\n-\treturn new Integer(offset);\n-      }\n-    else if (zoneString.startsWith(\"GMT\"))\n-      {\n-\treturn new Integer(0);\n-      }\n-    return null;\n-  }\n-\n-  // Compute the start of the current century as defined by\n-  // get2DigitYearStart.\n-  private void computeCenturyStart()\n-  {\n-    int year = calendar.get(Calendar.YEAR);\n-    calendar.set(Calendar.YEAR, year - 80);\n-    set2DigitYearStart(calendar.getTime());\n-  }\n-\n-  /**\n-   * Returns a copy of this instance of\n-   * <code>SimpleDateFormat</code>.  The copy contains\n-   * clones of the formatting symbols and the 2-digit\n-   * year century start date.\n-   */\n-  public Object clone()\n-  {\n-    SimpleDateFormat clone = (SimpleDateFormat) super.clone();\n-    clone.setDateFormatSymbols((DateFormatSymbols) formatData.clone());\n-    clone.set2DigitYearStart((Date) defaultCenturyStart.clone());\n-    return clone;\n-  }\n-\n-}"}, {"sha": "c78c9869a870ee4b43d16d96f54977b546bdbf85", "filename": "libjava/sources.am", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/035db16b87e0687bd77dc6a3d696bfd9be3080d1/libjava%2Fsources.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/035db16b87e0687bd77dc6a3d696bfd9be3080d1/libjava%2Fsources.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fsources.am?ref=035db16b87e0687bd77dc6a3d696bfd9be3080d1", "patch": "@@ -3629,7 +3629,7 @@ classpath/java/text/NumberFormat.java \\\n classpath/java/text/ParseException.java \\\n classpath/java/text/ParsePosition.java \\\n classpath/java/text/RuleBasedCollator.java \\\n-java/text/SimpleDateFormat.java \\\n+classpath/java/text/SimpleDateFormat.java \\\n classpath/java/text/StringCharacterIterator.java\n \n java_text_header_files = $(patsubst classpath/%,%,$(patsubst %.java,%.h,$(java_text_source_files)))"}]}