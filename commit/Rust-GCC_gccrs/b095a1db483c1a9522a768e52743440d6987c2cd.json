{"sha": "b095a1db483c1a9522a768e52743440d6987c2cd", "node_id": "C_kwDOANBUbNoAKGIwOTVhMWRiNDgzYzFhOTUyMmE3NjhlNTI3NDM0NDBkNjk4N2MyY2Q", "commit": {"author": {"name": "Takayuki 'January June' Suwa", "email": "jjsuwa_sys3175@yahoo.co.jp", "date": "2023-01-07T02:55:11Z"}, "committer": {"name": "Max Filippov", "email": "jcmvbkbc@gmail.com", "date": "2023-01-07T20:21:55Z"}, "message": "xtensa: Optimize stack frame adjustment more\n\nThis patch introduces a convenient helper function for integer immediate\naddition with scratch register as needed, that splits and emits either\nup to two ADDI/ADDMI machine instructions or an addition by register\nfollowing an integer immediate load (which may later be transformed by\nconstantsynth).\n\nBy using the helper function, it makes stack frame adjustment logic\nsimplified and instruction count less in some cases.\n\ngcc/ChangeLog:\n\n\t* config/xtensa/xtensa.cc\n\t(xtensa_split_imm_two_addends, xtensa_emit_add_imm):\n\tNew helper functions.\n\t(xtensa_set_return_address, xtensa_output_mi_thunk):\n\tChange to use the helper function.\n\t(xtensa_emit_adjust_stack_ptr): Ditto.\n\tAnd also change to try reusing the content of scratch register\n\tA9 if the register is not modified in the function body.", "tree": {"sha": "7a9a26ee432c3cd090e2ed6ada0750761313209c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7a9a26ee432c3cd090e2ed6ada0750761313209c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b095a1db483c1a9522a768e52743440d6987c2cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b095a1db483c1a9522a768e52743440d6987c2cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b095a1db483c1a9522a768e52743440d6987c2cd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b095a1db483c1a9522a768e52743440d6987c2cd/comments", "author": {"login": "jjsuwa-sys3175", "id": 73290592, "node_id": "MDQ6VXNlcjczMjkwNTky", "avatar_url": "https://avatars.githubusercontent.com/u/73290592?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jjsuwa-sys3175", "html_url": "https://github.com/jjsuwa-sys3175", "followers_url": "https://api.github.com/users/jjsuwa-sys3175/followers", "following_url": "https://api.github.com/users/jjsuwa-sys3175/following{/other_user}", "gists_url": "https://api.github.com/users/jjsuwa-sys3175/gists{/gist_id}", "starred_url": "https://api.github.com/users/jjsuwa-sys3175/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jjsuwa-sys3175/subscriptions", "organizations_url": "https://api.github.com/users/jjsuwa-sys3175/orgs", "repos_url": "https://api.github.com/users/jjsuwa-sys3175/repos", "events_url": "https://api.github.com/users/jjsuwa-sys3175/events{/privacy}", "received_events_url": "https://api.github.com/users/jjsuwa-sys3175/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jcmvbkbc", "id": 166731, "node_id": "MDQ6VXNlcjE2NjczMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/166731?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jcmvbkbc", "html_url": "https://github.com/jcmvbkbc", "followers_url": "https://api.github.com/users/jcmvbkbc/followers", "following_url": "https://api.github.com/users/jcmvbkbc/following{/other_user}", "gists_url": "https://api.github.com/users/jcmvbkbc/gists{/gist_id}", "starred_url": "https://api.github.com/users/jcmvbkbc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jcmvbkbc/subscriptions", "organizations_url": "https://api.github.com/users/jcmvbkbc/orgs", "repos_url": "https://api.github.com/users/jcmvbkbc/repos", "events_url": "https://api.github.com/users/jcmvbkbc/events{/privacy}", "received_events_url": "https://api.github.com/users/jcmvbkbc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2d2edf108026b7e2591900f995bc558ce8d45c6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d2edf108026b7e2591900f995bc558ce8d45c6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d2edf108026b7e2591900f995bc558ce8d45c6d"}], "stats": {"total": 151, "additions": 106, "deletions": 45}, "files": [{"sha": "a1f184950ae09cfaf28b11bd6d980c1887e0669c", "filename": "gcc/config/xtensa/xtensa.cc", "status": "modified", "additions": 106, "deletions": 45, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b095a1db483c1a9522a768e52743440d6987c2cd/gcc%2Fconfig%2Fxtensa%2Fxtensa.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b095a1db483c1a9522a768e52743440d6987c2cd/gcc%2Fconfig%2Fxtensa%2Fxtensa.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.cc?ref=b095a1db483c1a9522a768e52743440d6987c2cd", "patch": "@@ -104,6 +104,7 @@ struct GTY(()) machine_function\n   bool frame_laid_out;\n   bool epilogue_done;\n   bool inhibit_logues_a1_adjusts;\n+  rtx last_logues_a9_content;\n };\n \n /* Vector, indexed by hard register number, which contains 1 for a\n@@ -2518,6 +2519,86 @@ xtensa_split_DI_reg_imm (rtx *operands)\n }\n \n \n+/* Try to split an integer value into what are suitable for two consecutive\n+   immediate addition instructions, ADDI or ADDMI.  */\n+\n+static bool\n+xtensa_split_imm_two_addends (HOST_WIDE_INT imm, HOST_WIDE_INT v[2])\n+{\n+  HOST_WIDE_INT v0, v1;\n+\n+  if (imm < -32768)\n+    v0 = -32768, v1 = imm + 32768;\n+  else if (imm > 32512)\n+    v0 = 32512, v1 = imm - 32512;\n+  else if (TARGET_DENSITY && xtensa_simm12b (imm))\n+    /* A pair of MOVI(.N) and ADD.N is one or two bytes less than two\n+       immediate additions if TARGET_DENSITY.  */\n+    return false;\n+  else\n+    v0 = (imm + 128) & ~255L, v1 = imm - v0;\n+\n+  if (xtensa_simm8 (v1) || xtensa_simm8x256 (v1))\n+    {\n+      v[0] = v0, v[1] = v1;\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n+\n+/* Helper function for integer immediate addition with scratch register\n+   as needed, that splits and emits either up to two ADDI/ADDMI machine\n+   instructions or an addition by register following an integer immediate\n+   load (which may later be transformed by constantsynth).\n+\n+   If 'scratch' is NULL_RTX but still needed, a new pseudo-register will\n+   be allocated.  Thus, after the reload/LRA pass, the specified scratch\n+   register must be a hard one.  */\n+\n+static bool\n+xtensa_emit_add_imm (rtx dst, rtx src, HOST_WIDE_INT imm, rtx scratch,\n+\t\t     bool need_note)\n+{\n+  bool retval = false;\n+  HOST_WIDE_INT v[2];\n+  rtx_insn *insn;\n+\n+  if (imm == 0)\n+    return false;\n+\n+  if (xtensa_simm8 (imm) || xtensa_simm8x256 (imm))\n+    insn = emit_insn (gen_addsi3 (dst, src, GEN_INT (imm)));\n+  else if (xtensa_split_imm_two_addends (imm, v))\n+    {\n+      if (!scratch)\n+\tscratch = gen_reg_rtx (SImode);\n+      emit_insn (gen_addsi3 (scratch, src, GEN_INT (v[0])));\n+      insn = emit_insn (gen_addsi3 (dst, scratch, GEN_INT (v[1])));\n+    }\n+  else\n+    {\n+      if (scratch)\n+\temit_move_insn (scratch, GEN_INT (imm));\n+      else\n+\tscratch = force_reg (SImode, GEN_INT (imm));\n+      retval = true;\n+      insn = emit_insn (gen_addsi3 (dst, src, scratch));\n+    }\n+\n+  if (need_note)\n+    {\n+      rtx note_rtx = gen_rtx_SET (dst, plus_constant (Pmode, src, imm));\n+\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+      add_reg_note (insn, REG_FRAME_RELATED_EXPR, note_rtx);\n+    }\n+\n+  return retval;\n+}\n+\n+\n /* Implement TARGET_CANNOT_FORCE_CONST_MEM.  */\n \n static bool\n@@ -3245,41 +3326,33 @@ xtensa_initial_elimination_offset (int from, int to ATTRIBUTE_UNUSED)\n static void\n xtensa_emit_adjust_stack_ptr (HOST_WIDE_INT offset, int flags)\n {\n+  rtx src, scratch;\n   rtx_insn *insn;\n-  rtx ptr = (flags & ADJUST_SP_FRAME_PTR) ? hard_frame_pointer_rtx\n-\t\t\t\t\t  : stack_pointer_rtx;\n \n   if (cfun->machine->inhibit_logues_a1_adjusts)\n     return;\n \n-  if (xtensa_simm8 (offset)\n-      || xtensa_simm8x256 (offset))\n-    insn = emit_insn (gen_addsi3 (stack_pointer_rtx, ptr, GEN_INT (offset)));\n-  else\n-    {\n-      rtx tmp_reg = gen_rtx_REG (Pmode, A9_REG);\n+  src = (flags & ADJUST_SP_FRAME_PTR)\n+\t ? hard_frame_pointer_rtx : stack_pointer_rtx;\n+  scratch = gen_rtx_REG (Pmode, A9_REG);\n \n-      if (offset < 0)\n-\t{\n-\t  emit_move_insn (tmp_reg, GEN_INT (-offset));\n-\t  insn = emit_insn (gen_subsi3 (stack_pointer_rtx, ptr, tmp_reg));\n-\t}\n-      else\n-\t{\n-\t  emit_move_insn (tmp_reg, GEN_INT (offset));\n-\t  insn = emit_insn (gen_addsi3 (stack_pointer_rtx, ptr,\ttmp_reg));\n-\t}\n-    }\n-\n-  if (flags & ADJUST_SP_NEED_NOTE)\n+  if (df && DF_REG_DEF_COUNT (A9_REG) == 0\n+      && cfun->machine->last_logues_a9_content\n+      && -INTVAL (cfun->machine->last_logues_a9_content) == offset)\n     {\n-      rtx note_rtx = gen_rtx_SET (stack_pointer_rtx,\n-\t\t\t\t  plus_constant (Pmode, stack_pointer_rtx,\n-\t\t\t\t\t\t offset));\n+      insn = emit_insn (gen_subsi3 (stack_pointer_rtx, src, scratch));\n+      if (flags & ADJUST_SP_NEED_NOTE)\n+\t{\n+\t  rtx note_rtx = gen_rtx_SET (stack_pointer_rtx,\n+\t\t\t\t      plus_constant (Pmode, src, offset));\n \n-      RTX_FRAME_RELATED_P (insn) = 1;\n-      add_reg_note (insn, REG_FRAME_RELATED_EXPR, note_rtx);\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t  add_reg_note (insn, REG_FRAME_RELATED_EXPR, note_rtx);\n+\t}\n     }\n+  else if (xtensa_emit_add_imm (stack_pointer_rtx, src, offset, scratch,\n+\t\t\t\t(flags & ADJUST_SP_NEED_NOTE)))\n+    cfun->machine->last_logues_a9_content = GEN_INT (offset);\n }\n \n /* minimum frame = reg save area (4 words) plus static chain (1 word)\n@@ -3307,8 +3380,9 @@ xtensa_expand_prologue (void)\n \t  /* Use a8 as a temporary since a0-a7 may be live.  */\n \t  rtx tmp_reg = gen_rtx_REG (Pmode, A8_REG);\n \t  emit_insn (gen_entry (GEN_INT (MIN_FRAME_SIZE)));\n-\t  emit_move_insn (tmp_reg, GEN_INT (total_size - MIN_FRAME_SIZE));\n-\t  emit_insn (gen_subsi3 (tmp_reg, stack_pointer_rtx, tmp_reg));\n+\t  xtensa_emit_add_imm (tmp_reg, stack_pointer_rtx,\n+\t\t\t       MIN_FRAME_SIZE - total_size,\n+\t\t\t       tmp_reg, false);\n \t  insn = emit_insn (gen_movsi (stack_pointer_rtx, tmp_reg));\n \t}\n     }\n@@ -3540,8 +3614,8 @@ xtensa_set_return_address (rtx address, rtx scratch)\n \n   if (total_size > 1024)\n     {\n-      emit_move_insn (scratch, GEN_INT (total_size - UNITS_PER_WORD));\n-      emit_insn (gen_addsi3 (scratch, frame, scratch));\n+      xtensa_emit_add_imm (scratch, frame, total_size - UNITS_PER_WORD,\n+\t\t\t   scratch, false);\n       a0_addr = scratch;\n     }\n \n@@ -5101,15 +5175,7 @@ xtensa_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n   this_rtx = gen_rtx_REG (Pmode, A0_REG + this_reg_no);\n \n   if (delta)\n-    {\n-      if (xtensa_simm8 (delta))\n-\temit_insn (gen_addsi3 (this_rtx, this_rtx, GEN_INT (delta)));\n-      else\n-\t{\n-\t  emit_move_insn (temp0, GEN_INT (delta));\n-\t  emit_insn (gen_addsi3 (this_rtx, this_rtx, temp0));\n-\t}\n-    }\n+    xtensa_emit_add_imm (this_rtx, this_rtx, delta, temp0, false);\n \n   if (vcall_offset)\n     {\n@@ -5119,13 +5185,8 @@ xtensa_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n       emit_move_insn (temp0, gen_rtx_MEM (Pmode, this_rtx));\n       if (xtensa_uimm8x4 (vcall_offset))\n \taddr = plus_constant (Pmode, temp0, vcall_offset);\n-      else if (xtensa_simm8 (vcall_offset))\n-\temit_insn (gen_addsi3 (temp1, temp0, GEN_INT (vcall_offset)));\n       else\n-\t{\n-\t  emit_move_insn (temp1, GEN_INT (vcall_offset));\n-\t  emit_insn (gen_addsi3 (temp1, temp0, temp1));\n-\t}\n+\txtensa_emit_add_imm (temp1, temp0, vcall_offset, temp1, false);\n       emit_move_insn (temp1, gen_rtx_MEM (Pmode, addr));\n       emit_insn (gen_add2_insn (this_rtx, temp1));\n     }"}]}