{"sha": "8a6b509ea857a07be12738d10403d3ab0f647ffe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGE2YjUwOWVhODU3YTA3YmUxMjczOGQxMDQwM2QzYWIwZjY0N2ZmZQ==", "commit": {"author": {"name": "Andreas Tobler", "email": "andreast@gcc.gnu.org", "date": "2003-09-04T14:49:22Z"}, "committer": {"name": "Andreas Tobler", "email": "andreast@gcc.gnu.org", "date": "2003-09-04T14:49:22Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r71069", "tree": {"sha": "864061fb5d14971ea20a6bca207ddced6dc8f374", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/864061fb5d14971ea20a6bca207ddced6dc8f374"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8a6b509ea857a07be12738d10403d3ab0f647ffe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a6b509ea857a07be12738d10403d3ab0f647ffe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a6b509ea857a07be12738d10403d3ab0f647ffe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a6b509ea857a07be12738d10403d3ab0f647ffe/comments", "author": null, "committer": null, "parents": [{"sha": "bbf3057bf97696d4c5ba5c624c26ea0a9b1e04fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbf3057bf97696d4c5ba5c624c26ea0a9b1e04fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bbf3057bf97696d4c5ba5c624c26ea0a9b1e04fa"}], "stats": {"total": 4385, "additions": 4385, "deletions": 0}, "files": [{"sha": "f94ca00bc62550311edf0a4829e33e3d7e5b7842", "filename": "libffi/testsuite/Makefile.am", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2FMakefile.am?ref=8a6b509ea857a07be12738d10403d3ab0f647ffe", "patch": "@@ -0,0 +1,16 @@\n+## Process this file with automake to produce Makefile.in.\n+\n+AUTOMAKE_OPTIONS = foreign dejagnu\n+\n+# Setup the testing framework, if you have one\n+EXPECT = `if [ -f $(top_builddir)/../expect/expect ] ; then \\\n+            echo $(top_builddir)/../expect/expect ; \\\n+          else echo expect ; fi`\n+\n+RUNTEST = `if [ -f $(top_srcdir)/../dejagnu/runtest ] ; then \\\n+\t       echo $(top_srcdir)/../dejagnu/runtest ; \\\n+\t    else echo runtest; fi`\n+\n+AM_RUNTESTFLAGS =\n+\n+CLEANFILES = *.exe core* *.log *.sum"}, {"sha": "01f4bbd5f60e193084b30d8fe215a4de3c517040", "filename": "libffi/testsuite/Makefile.in", "status": "added", "additions": 250, "deletions": 0, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2FMakefile.in?ref=8a6b509ea857a07be12738d10403d3ab0f647ffe", "patch": "@@ -0,0 +1,250 @@\n+# Makefile.in generated automatically by automake 1.4 from Makefile.am\n+\n+# Copyright (C) 1994, 1995-8, 1999 Free Software Foundation, Inc.\n+# This Makefile.in is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n+# PARTICULAR PURPOSE.\n+\n+\n+SHELL = @SHELL@\n+\n+srcdir = @srcdir@\n+top_srcdir = @top_srcdir@\n+VPATH = @srcdir@\n+prefix = @prefix@\n+exec_prefix = @exec_prefix@\n+\n+bindir = @bindir@\n+sbindir = @sbindir@\n+libexecdir = @libexecdir@\n+datadir = @datadir@\n+sysconfdir = @sysconfdir@\n+sharedstatedir = @sharedstatedir@\n+localstatedir = @localstatedir@\n+libdir = @libdir@\n+infodir = @infodir@\n+mandir = @mandir@\n+includedir = @includedir@\n+oldincludedir = /usr/include\n+\n+DESTDIR =\n+\n+pkgdatadir = $(datadir)/@PACKAGE@\n+pkglibdir = $(libdir)/@PACKAGE@\n+pkgincludedir = $(includedir)/@PACKAGE@\n+\n+top_builddir = ..\n+\n+ACLOCAL = @ACLOCAL@\n+AUTOCONF = @AUTOCONF@\n+AUTOMAKE = @AUTOMAKE@\n+AUTOHEADER = @AUTOHEADER@\n+\n+INSTALL = @INSTALL@\n+INSTALL_PROGRAM = @INSTALL_PROGRAM@ $(AM_INSTALL_PROGRAM_FLAGS)\n+INSTALL_DATA = @INSTALL_DATA@\n+INSTALL_SCRIPT = @INSTALL_SCRIPT@\n+transform = @program_transform_name@\n+\n+NORMAL_INSTALL = :\n+PRE_INSTALL = :\n+POST_INSTALL = :\n+NORMAL_UNINSTALL = :\n+PRE_UNINSTALL = :\n+POST_UNINSTALL = :\n+build_alias = @build_alias@\n+build_triplet = @build@\n+host_alias = @host_alias@\n+host_triplet = @host@\n+target_alias = @target_alias@\n+target_triplet = @target@\n+AS = @AS@\n+CC = @CC@\n+CXX = @CXX@\n+CXXCPP = @CXXCPP@\n+DLLTOOL = @DLLTOOL@\n+EXEEXT = @EXEEXT@\n+GCJ = @GCJ@\n+GCJFLAGS = @GCJFLAGS@\n+LIBTOOL = @LIBTOOL@\n+LN_S = @LN_S@\n+MAINT = @MAINT@\n+MAKEINFO = @MAKEINFO@\n+OBJDUMP = @OBJDUMP@\n+OBJEXT = @OBJEXT@\n+PACKAGE = @PACKAGE@\n+RANLIB = @RANLIB@\n+SHELL = @SHELL@\n+STRIP = @STRIP@\n+TARGET = @TARGET@\n+TARGETDIR = @TARGETDIR@\n+VERSION = @VERSION@\n+libffi_basedir = @libffi_basedir@\n+toolexecdir = @toolexecdir@\n+toolexeclibdir = @toolexeclibdir@\n+\n+AUTOMAKE_OPTIONS = foreign dejagnu\n+\n+# Setup the testing framework, if you have one\n+EXPECT = `if [ -f $(top_builddir)/../expect/expect ] ; then \\\n+            echo $(top_builddir)/../expect/expect ; \\\n+          else echo expect ; fi`\n+\n+\n+RUNTEST = `if [ -f $(top_srcdir)/../dejagnu/runtest ] ; then \\\n+\t       echo $(top_srcdir)/../dejagnu/runtest ; \\\n+\t    else echo runtest; fi`\n+\n+\n+AM_RUNTESTFLAGS = \n+\n+CLEANFILES = *.exe core* *.log *.sum\n+mkinstalldirs = $(SHELL) $(top_srcdir)/${libffi_basedir}../mkinstalldirs\n+CONFIG_HEADER = ../fficonfig.h\n+CONFIG_CLEAN_FILES = \n+DIST_COMMON =  Makefile.am Makefile.in\n+\n+\n+DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)\n+\n+TAR = gnutar\n+GZIP_ENV = --best\n+all: all-redirect\n+.SUFFIXES:\n+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ Makefile.am $(top_srcdir)/configure.in $(ACLOCAL_M4) \n+\tcd $(top_srcdir) && $(AUTOMAKE) --foreign testsuite/Makefile\n+\n+Makefile: $(srcdir)/Makefile.in  $(top_builddir)/config.status $(BUILT_SOURCES)\n+\tcd $(top_builddir) \\\n+\t  && CONFIG_FILES=$(subdir)/$@ CONFIG_HEADERS= $(SHELL) ./config.status\n+\n+tags: TAGS\n+TAGS:\n+\n+\n+distdir = $(top_builddir)/$(PACKAGE)-$(VERSION)/$(subdir)\n+\n+subdir = testsuite\n+\n+distdir: $(DISTFILES)\n+\there=`cd $(top_builddir) && pwd`; \\\n+\ttop_distdir=`cd $(top_distdir) && pwd`; \\\n+\tdistdir=`cd $(distdir) && pwd`; \\\n+\tcd $(top_srcdir) \\\n+\t  && $(AUTOMAKE) --include-deps --build-dir=$$here --srcdir-name=$(top_srcdir) --output-dir=$$top_distdir --foreign testsuite/Makefile\n+\t@for file in $(DISTFILES); do \\\n+\t  d=$(srcdir); \\\n+\t  if test -d $$d/$$file; then \\\n+\t    cp -pr $$d/$$file $(distdir)/$$file; \\\n+\t  else \\\n+\t    test -f $(distdir)/$$file \\\n+\t    || ln $$d/$$file $(distdir)/$$file 2> /dev/null \\\n+\t    || cp -p $$d/$$file $(distdir)/$$file || :; \\\n+\t  fi; \\\n+\tdone\n+\n+RUNTESTFLAGS =\n+\n+DEJATOOL = $(PACKAGE)\n+\n+RUNTESTDEFAULTFLAGS = --tool $(DEJATOOL) --srcdir $$srcdir\n+\n+check-DEJAGNU: site.exp\n+\tsrcdir=`cd $(srcdir) && pwd`; export srcdir; \\\n+\tEXPECT=$(EXPECT); export EXPECT; \\\n+\truntest=$(RUNTEST); \\\n+\tif $(SHELL) -c \"$$runtest --version\" > /dev/null 2>&1; then \\\n+\t  $$runtest $(RUNTESTDEFAULTFLAGS) $(RUNTESTFLAGS); \\\n+\telse echo \"WARNING: could not find \\`runtest'\" 1>&2; :;\\\n+\tfi\n+site.exp: Makefile\n+\t@echo 'Making a new site.exp file...'\n+\t@test ! -f site.bak || rm -f site.bak\n+\t@echo '## these variables are automatically generated by make ##' > $@-t\n+\t@echo '# Do not edit here.  If you wish to override these values' >> $@-t\n+\t@echo '# edit the last section' >> $@-t\n+\t@echo 'set tool $(DEJATOOL)' >> $@-t\n+\t@echo 'set srcdir $(srcdir)' >> $@-t\n+\t@echo 'set objdir' `pwd` >> $@-t\n+\t@echo 'set host_alias $(host_alias)' >> $@-t\n+\t@echo 'set host_triplet $(host_triplet)' >> $@-t\n+\t@echo 'set target_alias $(target_alias)' >> $@-t\n+\t@echo 'set target_triplet $(target_triplet)' >> $@-t\n+\t@echo 'set build_alias $(build_alias)' >> $@-t\n+\t@echo 'set build_triplet $(build_triplet)' >> $@-t\n+\t@echo '## All variables above are generated by configure. Do Not Edit ##' >> $@-t\n+\t@test ! -f site.exp || sed '1,/^## All variables above are.*##/ d' site.exp >> $@-t\n+\t@test ! -f site.exp || mv site.exp site.bak\n+\t@mv $@-t site.exp\n+info-am:\n+info: info-am\n+dvi-am:\n+dvi: dvi-am\n+check-am: all-am\n+\t$(MAKE) $(AM_MAKEFLAGS) check-DEJAGNU\n+check: check-am\n+installcheck-am:\n+installcheck: installcheck-am\n+install-exec-am:\n+install-exec: install-exec-am\n+\n+install-data-am:\n+install-data: install-data-am\n+\n+install-am: all-am\n+\t@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am\n+install: install-am\n+uninstall-am:\n+uninstall: uninstall-am\n+all-am: Makefile\n+all-redirect: all-am\n+install-strip:\n+\t$(MAKE) $(AM_MAKEFLAGS) AM_INSTALL_PROGRAM_FLAGS=-s install\n+installdirs:\n+\n+\n+mostlyclean-generic:\n+\n+clean-generic:\n+\t-test -z \"$(CLEANFILES)\" || rm -f $(CLEANFILES)\n+\n+distclean-generic:\n+\t-rm -f Makefile $(CONFIG_CLEAN_FILES)\n+\t-rm -f config.cache config.log stamp-h stamp-h[0-9]*\n+\n+maintainer-clean-generic:\n+mostlyclean-am:  mostlyclean-generic\n+\n+mostlyclean: mostlyclean-am\n+\n+clean-am:  clean-generic mostlyclean-am\n+\n+clean: clean-am\n+\n+distclean-am:  distclean-generic clean-am\n+\t-rm -f libtool\n+\n+distclean: distclean-am\n+\n+maintainer-clean-am:  maintainer-clean-generic distclean-am\n+\t@echo \"This command is intended for maintainers to use;\"\n+\t@echo \"it deletes files that may require special tools to rebuild.\"\n+\n+maintainer-clean: maintainer-clean-am\n+\n+.PHONY: tags distdir check-DEJAGNU info-am info dvi-am dvi check \\\n+check-am installcheck-am installcheck install-exec-am install-exec \\\n+install-data-am install-data install-am install uninstall-am uninstall \\\n+all-redirect all-am all installdirs mostlyclean-generic \\\n+distclean-generic clean-generic maintainer-clean-generic clean \\\n+mostlyclean distclean maintainer-clean\n+\n+\n+# Tell versions [3.59,3.63) of GNU make to not export all variables.\n+# Otherwise a system limit (for SysV at least) may be exceeded.\n+.NOEXPORT:"}, {"sha": "90967cccc18afeb470c705244f4cb9e44f15eb0d", "filename": "libffi/testsuite/config/default.exp", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Fconfig%2Fdefault.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Fconfig%2Fdefault.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Fconfig%2Fdefault.exp?ref=8a6b509ea857a07be12738d10403d3ab0f647ffe", "patch": "@@ -0,0 +1 @@\n+load_lib \"standard.exp\""}, {"sha": "2ecd5e886070f2f0f45b5ebb16dae019da6ea946", "filename": "libffi/testsuite/lib/libffi-dg.exp", "status": "added", "additions": 256, "deletions": 0, "changes": 256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flib%2Flibffi-dg.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flib%2Flibffi-dg.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flib%2Flibffi-dg.exp?ref=8a6b509ea857a07be12738d10403d3ab0f647ffe", "patch": "@@ -0,0 +1,256 @@\n+#   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 2 of the License, or\n+# (at your option) any later version.\n+# \n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with this program; if not, write to the Free Software\n+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  \n+\n+load_lib dg.exp\n+load_lib libgloss.exp\n+\n+# Define libffi callbacks for dg.exp.\n+\n+proc libffi-dg-test-1 { target_compile prog do_what extra_tool_flags } {\n+    # Set up the compiler flags, based on what we're going to do.\n+\n+    set options [list]\n+    switch $do_what {\n+\t\"compile\" {\n+\t    set compile_type \"assembly\"\n+\t    set output_file \"[file rootname [file tail $prog]].s\"\n+\t}\n+\t\"link\" {\n+\t    set compile_type \"executable\"\n+\t    set output_file \"[file rootname [file tail $prog]].exe\"\n+\t    # The following line is needed for targets like the i960 where\n+\t    # the default output file is b.out.  Sigh.\n+\t}\n+\t\"run\" {\n+\t    set compile_type \"executable\"\n+\t    # FIXME: \"./\" is to cope with \".\" not being in $PATH.\n+\t    # Should this be handled elsewhere?\n+\t    # YES.\n+\t    set output_file \"./[file rootname [file tail $prog]].exe\"\n+\t    # This is the only place where we care if an executable was\n+\t    # created or not.  If it was, dg.exp will try to run it.\n+\t    remote_file build delete $output_file;\n+\t}\n+\tdefault {\n+\t    perror \"$do_what: not a valid dg-do keyword\"\n+\t    return \"\"\n+\t}\n+    }\n+\n+    if { $extra_tool_flags != \"\" } {\n+\tlappend options \"additional_flags=$extra_tool_flags\"\n+    }\n+\n+    set comp_output [libffi_target_compile \"$prog\" \"$output_file\" \"$compile_type\" $options];\n+\n+\n+    return [list $comp_output $output_file]\n+}\n+\n+\n+proc libffi-dg-test { prog do_what extra_tool_flags } {\n+    return [libffi-dg-test-1 target_compile $prog $do_what $extra_tool_flags]\n+}\n+\n+proc libffi-init { args } {\n+    global gluefile wrap_flags;\n+    global srcdir\n+    global blddirffi\n+    global blddircxx\n+    global TOOL_OPTIONS\n+    global ld_library_path\n+    global libffi_include\n+    global libffi_link_flags \n+    global tool_root_dir\n+\n+    set blddirffi [lookfor_file [get_multilibs] libffi]\n+    verbose \"libffi $blddirffi\"\n+    set blddircxx [lookfor_file [get_multilibs] libstdc++-v3]\n+    verbose \"libstdc++ $blddircxx\"\n+\n+    set gccdir [lookfor_file $tool_root_dir gcc/libgcc.a]\n+    if {$gccdir != \"\"} {\n+        set gccdir [file dirname $gccdir]\n+    }\n+    verbose \"gccdir $gccdir\"\n+\n+    set ld_library_path \".\"\n+    append ld_library_path \":${gccdir}\"\n+\n+    set compiler \"${gccdir}/xgcc\"\n+    if { [is_remote host] == 0 && [which $compiler] != 0 } {\n+\tforeach i \"[exec $compiler --print-multi-lib]\" {\n+\t    set mldir \"\"\n+\t    regexp -- \"\\[a-z0-9=/\\.-\\]*;\" $i mldir\n+\t    set mldir [string trimright $mldir \"\\;@\"]\n+\t    if { \"$mldir\" == \".\" } {\n+\t\tcontinue\n+\t    }\n+\t    if { [llength [glob -nocomplain ${gccdir}/${mldir}/libgcc_s*.so.*]] == 1 } {\n+\t\tappend ld_library_path \":${gccdir}/${mldir}\"\n+\t    }\n+\t}\n+    }\n+    # add the library path for libffi.\n+    append ld_library_path \":${blddirffi}/.libs\"\n+    # add the library path for libstdc++ as well. \n+    append ld_library_path \":${blddircxx}/src/.libs\"\n+\n+    verbose \"ld_library_path: $ld_library_path\"\n+\n+    # Point to the Libffi headers in libffi.\n+    set libffi_include \"${blddirffi}/include\"\n+    verbose \"libffi_include $libffi_include\"\n+    \n+    set libffi_dir  \"${blddirffi}/.libs\"\n+    verbose \"libffi_dir $libffi_dir\"\n+    if { $libffi_dir != \"\" } {\n+\tset libffi_dir [file dirname ${libffi_dir}]\n+\tset libffi_link_flags \"-L${libffi_dir}/.libs\"\n+\tlappend libffi_link_flags \"-L${blddircxx}/src/.libs\"\n+    }\n+   \n+    # On IRIX 6, we have to set variables akin to LD_LIBRARY_PATH, but\n+    # called LD_LIBRARYN32_PATH (for the N32 ABI) and LD_LIBRARY64_PATH\n+    # (for the 64-bit ABI).  The right way to do this would be to modify\n+    # unix.exp -- but that's not an option since it's part of DejaGNU\n+    # proper, so we do it here.  We really only need to do \n+    # this on IRIX, but it shouldn't hurt to do it anywhere else.\n+    setenv  LD_LIBRARY_PATH     $ld_library_path\n+    setenv  SHLIB_PATH          $ld_library_path\n+    setenv  LD_LIBRARYN32_PATH  $ld_library_path\n+    setenv  LD_LIBRARY64_PATH   $ld_library_path\n+}\n+\n+proc libffi_target_compile { source dest type options } {\n+    global gluefile wrap_flags;\n+    global srcdir\n+    global blddirffi\n+    global TOOL_OPTIONS\n+    global ld_library_path\n+    global libffi_link_flags\n+    global libffi_include\n+    \n+\n+    if { [target_info needs_status_wrapper]!=\"\" && [info exists gluefile] } {\n+\tlappend options \"libs=${gluefile}\"\n+\tlappend options \"ldflags=$wrap_flags\"\n+    }\n+\n+    # TOOL_OPTIONS must come first, so that it doesn't override testcase\n+    # specific options.\n+    if [info exists TOOL_OPTIONS] {\n+\tlappend  options [concat \"additional_flags=$TOOL_OPTIONS\" $options];\n+    }\n+\n+    lappend options \"additional_flags=-I${libffi_include}\"\n+    lappend options \"additional_flags=${libffi_link_flags}\"\n+    lappend options \"libs= -lffi\"\n+    verbose \"options: $options\"\n+    return [target_compile $source $dest $type $options]\n+}\n+\n+# Utility routines.\n+\n+#\n+# search_for -- looks for a string match in a file\n+#\n+proc search_for { file pattern } {\n+    set fd [open $file r]\n+    while { [gets $fd cur_line]>=0 } {\n+\tif [string match \"*$pattern*\" $cur_line] then {\n+\t    close $fd\n+\t    return 1\n+\t}\n+    }\n+    close $fd\n+    return 0\n+}\n+\n+# Modified dg-runtest that can cycle through a list of optimization options\n+# as c-torture does.\n+proc libffi-dg-runtest { testcases default-extra-flags } {\n+    global runtests\n+\n+    foreach test $testcases {\n+\t# If we're only testing specific files and this isn't one of \n+\t# them, skip it.\n+\tif ![runtest_file_p $runtests $test] {\n+\t    continue\n+        }\n+\n+\t# Look for a loop within the source code - if we don't find one,\n+\t# don't pass -funroll[-all]-loops.\n+\tglobal torture_with_loops torture_without_loops\n+\tif [expr [search_for $test \"for*(\"]+[search_for $test \"while*(\"]] {\n+\t    set option_list $torture_with_loops\n+\t} else {\n+\t    set option_list $torture_without_loops\n+\t}\n+\n+\tset nshort [file tail [file dirname $test]]/[file tail $test]\n+\n+\tforeach flags $option_list {\n+\t    verbose \"Testing $nshort, $flags\" 1\n+\t    dg-test $test $flags ${default-extra-flags}\n+\t}\n+    }\n+}\n+\n+\n+# Like check_conditional_xfail, but callable from a dg test.\n+\n+proc dg-xfail-if { args } {\n+    set args [lreplace $args 0 0]\n+    set selector \"target [join [lindex $args 1]]\"\n+    if { [dg-process-target $selector] == \"S\" } {\n+\tglobal compiler_conditional_xfail_data\n+\tset compiler_conditional_xfail_data $args\n+    }\n+}\n+\n+\n+# We need to make sure that additional_files and additional_sources\n+# are both cleared out after every test.  It is not enough to clear\n+# them out *before* the next test run because gcc-target-compile gets\n+# run directly from some .exp files (outside of any test).  (Those\n+# uses should eventually be eliminated.) \n+\n+# Because the DG framework doesn't provide a hook that is run at the\n+# end of a test, we must replace dg-test with a wrapper.\n+\n+if { [info procs saved-dg-test] == [list] } {\n+    rename dg-test saved-dg-test\n+\n+    proc dg-test { args } {\n+\tglobal additional_files\n+\tglobal additional_sources\n+\tglobal errorInfo\n+\n+\tif { [ catch { eval saved-dg-test $args } errmsg ] } {\n+\t    set saved_info $errorInfo\n+\t    set additional_files \"\"\n+\t    set additional_sources \"\"\n+\t    error $errmsg $saved_info\n+\t}\n+\tset additional_files \"\"\n+\tset additional_sources \"\"\n+    }\n+}\n+\n+# Local Variables:\n+# tcl-indent-level:4\n+# End:\n\\ No newline at end of file"}, {"sha": "3b0bd32fa65303abef4dcaf7c92061fbe9b2ddd1", "filename": "libffi/testsuite/libffi.call/call.exp", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fcall.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fcall.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcall.exp?ref=8a6b509ea857a07be12738d10403d3ab0f647ffe", "patch": "@@ -0,0 +1,32 @@\n+#   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 2 of the License, or\n+# (at your option) any later version.\n+# \n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with this program; if not, write to the Free Software\n+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  \n+\n+# libffi testsuite that uses the 'dg.exp' driver.\n+\n+load_lib libffi-dg.exp\n+\n+dg-init\n+libffi-init\n+\n+global srcdir subdir\n+\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.\\[cS\\]]] \"\" \"\" \n+\n+dg-finish\n+\n+# Local Variables:\n+# tcl-indent-level:4\n+# End:"}, {"sha": "5413d9e78c3289b84f989561401b16c15db655d8", "filename": "libffi/testsuite/libffi.call/closure_fn0.c", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_fn0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_fn0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_fn0.c?ref=8a6b509ea857a07be12738d10403d3ab0f647ffe", "patch": "@@ -0,0 +1,82 @@\n+/* Area:\tclosure_call\n+   Purpose:\tCheck multiple values passing from different type.\n+\t\tAlso, exceed the limit of gpr and fpr registers on PowerPC \n+\t\tDarwin.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\t<andreast@gcc.gnu.org> 20030828\t */\n+\t\n+/* { dg-do run } */\n+#include \"ffitest.h\"\n+\n+static void\n+closure_test_fn0(ffi_cif* cif,void* resp,void** args, void* userdata)\n+{\n+  *(ffi_arg*)resp =\n+    (int)*(unsigned long long *)args[0] + (int)(*(int *)args[1]) +\n+    (int)(*(unsigned long long *)args[2]) + (int)*(int *)args[3] +\n+    (int)(*(signed short *)args[4]) +\n+    (int)(*(unsigned long long *)args[5]) +\n+    (int)*(int *)args[6] + (int)(*(int *)args[7]) +\n+    (int)(*(double *)args[8]) + (int)*(int *)args[9] +\n+    (int)(*(int *)args[10]) + (int)(*(float *)args[11]) +\n+    (int)*(int *)args[12] + (int)(*(int *)args[13]) +\n+    (int)(*(int *)args[14]) +  *(int *)args[15] + (int)(long)userdata;\n+\n+  printf(\"%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d: %d\\n\",\n+\t (int)*(unsigned long long *)args[0], (int)(*(int *)args[1]), \n+\t (int)(*(unsigned long long *)args[2]),\n+\t (int)*(int *)args[3], (int)(*(signed short *)args[4]), \n+\t (int)(*(unsigned long long *)args[5]),\n+\t (int)*(int *)args[6], (int)(*(int *)args[7]), \n+\t (int)(*(double *)args[8]), (int)*(int *)args[9],\n+\t (int)(*(int *)args[10]), (int)(*(float *)args[11]),\n+\t (int)*(int *)args[12], (int)(*(int *)args[13]), \n+\t (int)(*(int *)args[14]),*(int *)args[15],\n+\t (int)(long)userdata, (int)*(ffi_arg *)resp);\n+  \n+}\n+\n+typedef int (*closure_test_type0)(unsigned long long, int, unsigned long long, \n+\t\t\t\t  int, signed short, unsigned long long, int, \n+\t\t\t\t  int, double, int, int, float, int, int, \n+\t\t\t\t  int, int);\n+\n+int main (void)\n+{ \n+  ffi_cif cif;\n+  static ffi_closure cl;\n+  ffi_closure *pcl = &cl;\n+  ffi_type * cl_arg_types[17];\n+  \n+  cl_arg_types[0] = &ffi_type_uint64;\n+  cl_arg_types[1] = &ffi_type_uint;\n+  cl_arg_types[2] = &ffi_type_uint64;\n+  cl_arg_types[3] = &ffi_type_uint;\n+  cl_arg_types[4] = &ffi_type_sshort;\n+  cl_arg_types[5] = &ffi_type_uint64;\n+  cl_arg_types[6] = &ffi_type_uint;\n+  cl_arg_types[7] = &ffi_type_uint;\n+  cl_arg_types[8] = &ffi_type_double;\n+  cl_arg_types[9] = &ffi_type_uint;\n+  cl_arg_types[10] = &ffi_type_uint;\n+  cl_arg_types[11] = &ffi_type_float;\n+  cl_arg_types[12] = &ffi_type_uint;\n+  cl_arg_types[13] = &ffi_type_uint;\n+  cl_arg_types[14] = &ffi_type_uint;\n+  cl_arg_types[15] = &ffi_type_uint;\n+  cl_arg_types[16] = NULL;   \n+  \n+  /* Initialize the cif */\n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,\n+\t\t     &ffi_type_sint, cl_arg_types) == FFI_OK);\n+  \n+  CHECK(ffi_prep_closure(pcl, &cif, closure_test_fn0,\n+\t\t\t (void *) 3 /* userdata */) == FFI_OK);\n+     \n+  (*((closure_test_type0)pcl))\n+\t(1LL, 2, 3LL, 4, 127, 429LL, 7, 8, 9.5, 10, 11, 12, 13, \n+\t 19, 21, 1);\n+  /* { dg-output \"1 2 3 4 127 429 7 8 9 10 11 12 13 19 21 1 3: 680\" } */\n+     exit(0);\n+}"}, {"sha": "9180d95e851e8580c3f332880fc17b22eab6b0e4", "filename": "libffi/testsuite/libffi.call/closure_fn1.c", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_fn1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_fn1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_fn1.c?ref=8a6b509ea857a07be12738d10403d3ab0f647ffe", "patch": "@@ -0,0 +1,77 @@\n+/* Area:\tclosure_call.\n+   Purpose:\tCheck multiple values passing from different type.\n+\t\tAlso, exceed the limit of gpr and fpr registers on PowerPC \n+\t\tDarwin.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\t<andreast@gcc.gnu.org> 20030828\t */\n+\n+/* { dg-do run } */\n+#include \"ffitest.h\"\n+\n+static void closure_test_fn1(ffi_cif* cif,void* resp,void** args, \n+\t\t\t     void* userdata)\n+{\n+  *(ffi_arg*)resp =\n+    (int)*(float *)args[0] +(int)(*(float *)args[1]) + \n+    (int)(*(float *)args[2]) + (int)*(float *)args[3] +\n+    (int)(*(signed short *)args[4]) + (int)(*(float *)args[5]) +\n+    (int)*(float *)args[6] + (int)(*(int *)args[7]) + \n+    (int)(*(double*)args[8]) + (int)*(int *)args[9] + \n+    (int)(*(int *)args[10]) + (int)(*(float *)args[11]) + \n+    (int)*(int *)args[12] + (int)(*(int *)args[13]) + \n+    (int)(*(int *)args[14]) + *(int *)args[15] + (int)(long)userdata;\n+\n+  printf(\"%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d: %d\\n\",\n+\t (int)*(float *)args[0], (int)(*(float *)args[1]), \n+\t (int)(*(float *)args[2]), (int)*(float *)args[3], \n+\t (int)(*(signed short *)args[4]), (int)(*(float *)args[5]),\n+\t (int)*(float *)args[6], (int)(*(int *)args[7]),\n+\t (int)(*(double *)args[8]), (int)*(int *)args[9],\n+\t (int)(*(int *)args[10]), (int)(*(float *)args[11]),\n+\t (int)*(int *)args[12], (int)(*(int *)args[13]),\n+\t (int)(*(int *)args[14]), *(int *)args[15],\n+\t (int)(long)userdata, (int)*(ffi_arg *)resp);\n+}\n+\n+typedef int (*closure_test_type1)(float, float, float, float, signed short, \n+\t\t\t\t  float, float, int, double, int, int, float,\n+\t\t\t\t  int, int, int, int);\n+int main (void)\n+{\n+  ffi_cif cif;\n+  static ffi_closure cl;\n+  ffi_closure *pcl = &cl;\n+  ffi_type * cl_arg_types[17];\n+  \n+  cl_arg_types[0] = &ffi_type_float;\n+  cl_arg_types[1] = &ffi_type_float;\n+  cl_arg_types[2] = &ffi_type_float;\n+  cl_arg_types[3] = &ffi_type_float;\n+  cl_arg_types[4] = &ffi_type_sshort;\n+  cl_arg_types[5] = &ffi_type_float;\n+  cl_arg_types[6] = &ffi_type_float;\n+  cl_arg_types[7] = &ffi_type_uint;\n+  cl_arg_types[8] = &ffi_type_double;\n+  cl_arg_types[9] = &ffi_type_uint;\n+  cl_arg_types[10] = &ffi_type_uint;\n+  cl_arg_types[11] = &ffi_type_float;\n+  cl_arg_types[12] = &ffi_type_uint;\n+  cl_arg_types[13] = &ffi_type_uint;\n+  cl_arg_types[14] = &ffi_type_uint;\n+  cl_arg_types[15] = &ffi_type_uint;\n+  cl_arg_types[16] = NULL;\n+  \n+  /* Initialize the cif */\n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,\n+\t\t     &ffi_type_sint, cl_arg_types) == FFI_OK);\n+  \n+  CHECK(ffi_prep_closure(pcl, &cif, closure_test_fn1,\n+\t\t\t (void *) 3 /* userdata */)  == FFI_OK);\n+  \n+  (*((closure_test_type1)pcl))\n+\t(1.1, 2.2, 3.3, 4.4, 127, 5.5, 6.6, 8, 9, 10, 11, 12.0, 13,\n+\t 19, 21, 1);\n+  /* { dg-output \"1 2 3 4 127 5 6 8 9 10 11 12 13 19 21 1 3: 255\" } */\n+  exit(0);\n+}"}, {"sha": "ea3684e4e1e3c58566b20cbb608743bc6ed0d917", "filename": "libffi/testsuite/libffi.call/closure_fn2.c", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_fn2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_fn2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_fn2.c?ref=8a6b509ea857a07be12738d10403d3ab0f647ffe", "patch": "@@ -0,0 +1,78 @@\n+/* Area:\tclosure_call\n+   Purpose:\tCheck multiple values passing from different type.\n+\t\tAlso, exceed the limit of gpr and fpr registers on PowerPC \n+\t\tDarwin.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\t<andreast@gcc.gnu.org> 20030828\t */\n+\n+/* { dg-do run } */\n+#include \"ffitest.h\"\n+\n+static void closure_test_fn2(ffi_cif* cif,void* resp,void** args, \n+\t\t\t     void* userdata)\n+{\n+  *(ffi_arg*)resp =\n+    (int)*(double *)args[0] +(int)(*(double *)args[1]) + \n+    (int)(*(double *)args[2]) + (int)*(double *)args[3] +\n+    (int)(*(signed short *)args[4]) + (int)(*(double *)args[5]) +\n+    (int)*(double *)args[6] + (int)(*(int *)args[7]) + \n+    (int)(*(double *)args[8]) + (int)*(int *)args[9] +\n+    (int)(*(int *)args[10]) + (int)(*(float *)args[11]) + \n+    (int)*(int *)args[12] + (int)(*(float *)args[13]) +\n+    (int)(*(int *)args[14]) + *(int *)args[15] + (int)(long)userdata;\n+\n+  printf(\"%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d: %d\\n\",\n+\t (int)*(double *)args[0], (int)(*(double *)args[1]), \n+\t (int)(*(double *)args[2]), (int)*(double *)args[3], \n+\t (int)(*(signed short *)args[4]), (int)(*(double *)args[5]),\n+\t (int)*(double *)args[6], (int)(*(int *)args[7]), \n+\t (int)(*(double*)args[8]), (int)*(int *)args[9], \n+\t (int)(*(int *)args[10]), (int)(*(float *)args[11]),\n+\t (int)*(int *)args[12], (int)(*(float *)args[13]), \n+\t (int)(*(int *)args[14]), *(int *)args[15], (int)(long)userdata, \n+\t (int)*(ffi_arg *)resp);\n+}\n+\n+typedef int (*closure_test_type2)(double, double, double, double, signed short,\n+\t\t\t\t  double, double, int, double, int, int, float,\n+\t\t\t\t  int, float, int, int);\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  static ffi_closure cl;\n+  ffi_closure *pcl = &cl;\n+  ffi_type * cl_arg_types[17];\n+  \n+  cl_arg_types[0] = &ffi_type_double;\n+  cl_arg_types[1] = &ffi_type_double;\n+  cl_arg_types[2] = &ffi_type_double;\n+  cl_arg_types[3] = &ffi_type_double;\n+  cl_arg_types[4] = &ffi_type_sshort;\n+  cl_arg_types[5] = &ffi_type_double;\n+  cl_arg_types[6] = &ffi_type_double;\n+  cl_arg_types[7] = &ffi_type_uint;\n+  cl_arg_types[8] = &ffi_type_double;\n+  cl_arg_types[9] = &ffi_type_uint;\n+  cl_arg_types[10] = &ffi_type_uint;\n+  cl_arg_types[11] = &ffi_type_float;\n+  cl_arg_types[12] = &ffi_type_uint;\n+  cl_arg_types[13] = &ffi_type_float;\n+  cl_arg_types[14] = &ffi_type_uint;\n+  cl_arg_types[15] = &ffi_type_uint;\n+  cl_arg_types[16] = NULL;\n+  \n+  /* Initialize the cif */\n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,\n+\t\t     &ffi_type_sint, cl_arg_types) == FFI_OK);\n+  \n+  CHECK(ffi_prep_closure(pcl, &cif, closure_test_fn2,\n+\t\t\t (void *) 3 /* userdata */) == FFI_OK);\n+  \n+  (*((closure_test_type2)pcl))\n+\t(1, 2, 3, 4, 127, 5, 6, 8, 9, 10, 11, 12.0, 13,\n+\t 19.0, 21, 1);\n+  /* { dg-output \"1 2 3 4 127 5 6 8 9 10 11 12 13 19 21 1 3: 255\" } */\n+  exit(0);  \n+}"}, {"sha": "b9f13f925235c99182bc5fd6c0d8f4919d5f8f1f", "filename": "libffi/testsuite/libffi.call/closure_fn3.c", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_fn3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_fn3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_fn3.c?ref=8a6b509ea857a07be12738d10403d3ab0f647ffe", "patch": "@@ -0,0 +1,80 @@\n+/* Area:\tclosure_call\n+   Purpose:\tCheck multiple values passing from different type.\n+\t\tAlso, exceed the limit of gpr and fpr registers on PowerPC \n+\t\tDarwin.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\t<andreast@gcc.gnu.org> 20030828\t */\n+\n+/* { dg-do run } */\n+#include \"ffitest.h\"\n+\n+static void closure_test_fn3(ffi_cif* cif,void* resp,void** args,\n+\t\t\t     void* userdata)\n+ {\n+   *(ffi_arg*)resp =\n+     (int)*(float *)args[0] +(int)(*(float *)args[1]) + \n+     (int)(*(float *)args[2]) + (int)*(float *)args[3] +\n+     (int)(*(float *)args[4]) + (int)(*(float *)args[5]) +\n+     (int)*(float *)args[6] + (int)(*(float *)args[7]) + \n+     (int)(*(double *)args[8]) + (int)*(int *)args[9] +\n+     (int)(*(float *)args[10]) + (int)(*(float *)args[11]) + \n+     (int)*(int *)args[12] + (int)(*(float *)args[13]) +\n+     (int)(*(float *)args[14]) +  *(int *)args[15] + (int)(long)userdata;\n+\n+   printf(\"%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d: %d\\n\",\n+\t  (int)*(float *)args[0], (int)(*(float *)args[1]), \n+\t  (int)(*(float *)args[2]), (int)*(float *)args[3], \n+\t  (int)(*(float *)args[4]), (int)(*(float *)args[5]),\n+\t  (int)*(float *)args[6], (int)(*(float *)args[7]), \n+\t  (int)(*(double *)args[8]), (int)*(int *)args[9], \n+\t  (int)(*(float *)args[10]), (int)(*(float *)args[11]),\n+\t  (int)*(int *)args[12], (int)(*(float *)args[13]), \n+\t  (int)(*(float *)args[14]), *(int *)args[15], (int)(long)userdata,\n+\t  (int)*(ffi_arg *)resp);\n+   \n+ }\n+\n+typedef int (*closure_test_type3)(float, float, float, float, float, float,\n+\t\t\t\t  float, float, double, int, float, float, int,\n+\t\t\t\t  float, float, int);\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  static ffi_closure cl;\n+  ffi_closure *pcl = &cl;\n+  ffi_type * cl_arg_types[17];\n+  \n+  \n+  cl_arg_types[0] = &ffi_type_float;\n+  cl_arg_types[1] = &ffi_type_float;\n+  cl_arg_types[2] = &ffi_type_float;\n+  cl_arg_types[3] = &ffi_type_float;\n+  cl_arg_types[4] = &ffi_type_float;\n+  cl_arg_types[5] = &ffi_type_float;\n+  cl_arg_types[6] = &ffi_type_float;\n+  cl_arg_types[7] = &ffi_type_float;\n+  cl_arg_types[8] = &ffi_type_double;\n+  cl_arg_types[9] = &ffi_type_uint;\n+  cl_arg_types[10] = &ffi_type_float;\n+  cl_arg_types[11] = &ffi_type_float;\n+  cl_arg_types[12] = &ffi_type_uint;\n+  cl_arg_types[13] = &ffi_type_float;\n+  cl_arg_types[14] = &ffi_type_float;\n+  cl_arg_types[15] = &ffi_type_uint;\n+  cl_arg_types[16] = NULL;\n+  \n+  /* Initialize the cif */\n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,\n+\t\t     &ffi_type_sint, cl_arg_types) == FFI_OK);\n+  \n+  CHECK(ffi_prep_closure(pcl, &cif, closure_test_fn3,\n+\t\t\t (void *) 3 /* userdata */)  == FFI_OK);\n+  \n+  (*((closure_test_type3)pcl))\n+\t(1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9, 10, 11.11, 12.0, 13,\n+\t 19.19, 21.21, 1);\n+  /* { dg-output \"1 2 3 4 5 6 7 8 9 10 11 12 13 19 21 1 3: 135\" } */\n+  exit(0);  \n+}"}, {"sha": "ef5eee283f39fd2bddc4375f93d833c013b1259a", "filename": "libffi/testsuite/libffi.call/cls_12byte.c", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fcls_12byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fcls_12byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_12byte.c?ref=8a6b509ea857a07be12738d10403d3ab0f647ffe", "patch": "@@ -0,0 +1,91 @@\n+/* Area:\tffi_call, closure_call\n+   Purpose:\tCheck structure passing with different structure size.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\t<andreast@gcc.gnu.org> 20030828\t */\n+\n+/* { dg-do run } */\n+#include \"ffitest.h\"\n+\n+typedef struct cls_struct_12byte {\n+  int a;\n+  int b;\n+  int c;\n+} cls_struct_12byte;\n+\n+cls_struct_12byte cls_struct_12byte_fn(struct cls_struct_12byte b1,\n+\t\t\t    struct cls_struct_12byte b2)\n+{\n+  struct cls_struct_12byte result;\n+\n+  result.a = b1.a + b2.a;\n+  result.b = b1.b + b2.b;\n+  result.c = b1.c + b2.c;\n+\n+  printf(\"%d %d %d %d %d %d: %d %d %d\\n\", b1.a, b1.b, b1.c, b2.a, b2.b, b2.c,\n+\t result.a, result.b, result.c);\n+\n+  return result;\n+}\n+\n+static void cls_struct_12byte_gn(ffi_cif* cif, void* resp, void** args, void* userdata)\n+{   \n+  struct cls_struct_12byte b1, b2;\n+  \n+  b1 = *(struct cls_struct_12byte*)(args[0]);\n+  b2 = *(struct cls_struct_12byte*)(args[1]);\n+  \n+  *(cls_struct_12byte*)resp = cls_struct_12byte_fn(b1, b2);\n+}\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  static ffi_closure cl;\n+  ffi_closure *pcl = &cl;\n+  void* args_dbl[5];\n+  ffi_type* cls_struct_fields[4];\n+  ffi_type cls_struct_type;\n+  ffi_type* dbl_arg_types[5];\n+\n+  cls_struct_type.size = 0;\n+  cls_struct_type.alignment = 0;\n+  cls_struct_type.type = FFI_TYPE_STRUCT;\n+  cls_struct_type.elements = cls_struct_fields;\n+  \n+  struct cls_struct_12byte h_dbl = { 7, 4, 9 };\n+  struct cls_struct_12byte j_dbl = { 1, 5, 3 };\n+  struct cls_struct_12byte res_dbl;\n+  \n+  cls_struct_fields[0] = &ffi_type_uint32;\n+  cls_struct_fields[1] = &ffi_type_uint32;\n+  cls_struct_fields[2] = &ffi_type_uint32;\n+  cls_struct_fields[3] = NULL;\n+  \n+  dbl_arg_types[0] = &cls_struct_type;\n+  dbl_arg_types[1] = &cls_struct_type;\n+  dbl_arg_types[2] = NULL;\n+  \n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type, \n+\t\t     dbl_arg_types) == FFI_OK);\n+  \n+  args_dbl[0] = &h_dbl;\n+  args_dbl[1] = &j_dbl;\n+  args_dbl[2] = NULL;\n+\n+  ffi_call(&cif, FFI_FN(cls_struct_12byte_fn), &res_dbl, args_dbl);\n+  /* { dg-output \"7 4 9 1 5 3: 8 9 12\" } */\n+  CHECK( res_dbl.a == (h_dbl.a + j_dbl.a));\n+  CHECK( res_dbl.b == (h_dbl.b + j_dbl.b));\n+  CHECK( res_dbl.c == (h_dbl.c + j_dbl.c));\n+ \n+  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_12byte_gn, NULL) == FFI_OK);\n+  \n+  res_dbl = ((cls_struct_12byte(*)(cls_struct_12byte, cls_struct_12byte))(pcl))(h_dbl, j_dbl);\n+  /* { dg-output \"\\n7 4 9 1 5 3: 8 9 12\" } */\n+  CHECK( res_dbl.a == (h_dbl.a + j_dbl.a));\n+  CHECK( res_dbl.b == (h_dbl.b + j_dbl.b));\n+  CHECK( res_dbl.c == (h_dbl.c + j_dbl.c));\n+\n+  exit(0);\n+}  "}, {"sha": "e4fdeb86be097c18c16a559d08136aceaa6022de", "filename": "libffi/testsuite/libffi.call/cls_16byte.c", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fcls_16byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fcls_16byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_16byte.c?ref=8a6b509ea857a07be12738d10403d3ab0f647ffe", "patch": "@@ -0,0 +1,92 @@\n+/* Area:\tffi_call, closure_call\n+   Purpose:\tCheck structure passing with different structure size.\n+\t\tDepending on the ABI. Check overlapping.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\t<andreast@gcc.gnu.org> 20030828\t */\n+\n+/* { dg-do run } */\n+#include \"ffitest.h\"\n+\n+typedef struct cls_struct_16byte {\n+  int a;\n+  double b;\n+  int c;\n+} cls_struct_16byte;\n+\n+cls_struct_16byte cls_struct_16byte_fn(struct cls_struct_16byte b1,\n+\t\t\t    struct cls_struct_16byte b2)\n+{\n+  struct cls_struct_16byte result;\n+\n+  result.a = b1.a + b2.a;\n+  result.b = b1.b + b2.b;\n+  result.c = b1.c + b2.c;\n+\n+  printf(\"%d %g %d %d %g %d: %d %g %d\\n\", b1.a, b1.b, b1.c, b2.a, b2.b, b2.c,\n+\t result.a, result.b, result.c);\n+\n+  return result;\n+}\n+\n+static void cls_struct_16byte_gn(ffi_cif* cif, void* resp, void** args, void* userdata)\n+{   \n+  struct cls_struct_16byte b1, b2;\n+  \n+  b1 = *(struct cls_struct_16byte*)(args[0]);\n+  b2 = *(struct cls_struct_16byte*)(args[1]);\n+  \n+  *(cls_struct_16byte*)resp = cls_struct_16byte_fn(b1, b2);\n+}\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  static ffi_closure cl;\n+  ffi_closure *pcl = &cl;\n+  void* args_dbl[5];\n+  ffi_type* cls_struct_fields[4];\n+  ffi_type cls_struct_type;\n+  ffi_type* dbl_arg_types[5];\n+\n+  cls_struct_type.size = 0;\n+  cls_struct_type.alignment = 0;\n+  cls_struct_type.type = FFI_TYPE_STRUCT;\n+  cls_struct_type.elements = cls_struct_fields;\n+  \n+  struct cls_struct_16byte h_dbl = { 7, 8.0, 9 };\n+  struct cls_struct_16byte j_dbl = { 1, 9.0, 3 };\n+  struct cls_struct_16byte res_dbl;\n+  \n+  cls_struct_fields[0] = &ffi_type_uint32;\n+  cls_struct_fields[1] = &ffi_type_double;\n+  cls_struct_fields[2] = &ffi_type_uint32;\n+  cls_struct_fields[3] = NULL;\n+  \n+  dbl_arg_types[0] = &cls_struct_type;\n+  dbl_arg_types[1] = &cls_struct_type;\n+  dbl_arg_types[2] = NULL;\n+  \n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type, \n+\t\t     dbl_arg_types) == FFI_OK);\n+  \n+  args_dbl[0] = &h_dbl;\n+  args_dbl[1] = &j_dbl;\n+  args_dbl[2] = NULL;\n+\n+  ffi_call(&cif, FFI_FN(cls_struct_16byte_fn), &res_dbl, args_dbl);\n+  /* { dg-output \"7 8 9 1 9 3: 8 17 12\" } */\n+  CHECK( res_dbl.a == (h_dbl.a + j_dbl.a));\n+  CHECK( res_dbl.b == (h_dbl.b + j_dbl.b));\n+  CHECK( res_dbl.c == (h_dbl.c + j_dbl.c));\n+  \n+  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_16byte_gn, NULL) == FFI_OK);\n+  \n+  res_dbl = ((cls_struct_16byte(*)(cls_struct_16byte, cls_struct_16byte))(pcl))(h_dbl, j_dbl);\n+  /* { dg-output \"\\n7 8 9 1 9 3: 8 17 12\" } */\n+  CHECK( res_dbl.a == (h_dbl.a + j_dbl.a));\n+  CHECK( res_dbl.b == (h_dbl.b + j_dbl.b));\n+  CHECK( res_dbl.c == (h_dbl.c + j_dbl.c));\n+\n+  exit(0);\n+}  "}, {"sha": "0344c60c687f8246f555c22b53aa4b40dc102a74", "filename": "libffi/testsuite/libffi.call/cls_1_1byte.c", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fcls_1_1byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fcls_1_1byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_1_1byte.c?ref=8a6b509ea857a07be12738d10403d3ab0f647ffe", "patch": "@@ -0,0 +1,84 @@\n+/* Area:\tffi_call, closure_call\n+   Purpose:\tCheck structure passing with different structure size.\n+\t\tEspecially with small structures which may fit in one\n+\t\tregister. Depending on the ABI.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\t<andreast@gcc.gnu.org> 20030902\t */\n+\n+/* { dg-do run } */\n+#include \"ffitest.h\"\n+\n+typedef struct cls_struct_1_1byte {\n+  unsigned char a;\n+} cls_struct_1_1byte;\n+\n+cls_struct_1_1byte cls_struct_1_1byte_fn(struct cls_struct_1_1byte a1,\n+\t\t\t    struct cls_struct_1_1byte a2)\n+{\n+  struct cls_struct_1_1byte result;\n+\n+  result.a = a1.a + a2.a;\n+\n+  printf(\"%d %d: %d\\n\", a1.a, a2.a, result.a);\n+\n+  return  result;\n+}\n+\n+static void \n+cls_struct_1_1byte_gn(ffi_cif* cif, void* resp, void** args, void* userdata)\n+{   \n+  \n+  struct cls_struct_1_1byte a1, a2;\n+\n+  a1 = *(struct cls_struct_1_1byte*)(args[0]);\n+  a2 = *(struct cls_struct_1_1byte*)(args[1]);\n+\n+  *(cls_struct_1_1byte*)resp = cls_struct_1_1byte_fn(a1, a2);\n+}\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  static ffi_closure cl;\n+  ffi_closure *pcl = &cl;\n+  void* args_dbl[5];\n+  ffi_type* cls_struct_fields[2];\n+  ffi_type cls_struct_type;\n+  ffi_type* dbl_arg_types[5];\n+\n+  cls_struct_type.size = 0;\n+  cls_struct_type.alignment = 0;\n+  cls_struct_type.type = FFI_TYPE_STRUCT;\n+  cls_struct_type.elements = cls_struct_fields;\n+\n+  struct cls_struct_1_1byte g_dbl = { 12 };\n+  struct cls_struct_1_1byte f_dbl = { 178 };\n+  struct cls_struct_1_1byte res_dbl;\n+  \n+  cls_struct_fields[0] = &ffi_type_uchar;\n+  cls_struct_fields[1] = NULL;\n+  \n+  dbl_arg_types[0] = &cls_struct_type;\n+  dbl_arg_types[1] = &cls_struct_type;\n+  dbl_arg_types[2] = NULL;\n+  \n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type, \n+\t\t     dbl_arg_types) == FFI_OK);\n+\n+  args_dbl[0] = &g_dbl;\n+  args_dbl[1] = &f_dbl;\n+  args_dbl[2] = NULL;\n+\n+  ffi_call(&cif, FFI_FN(cls_struct_1_1byte_fn), &res_dbl, args_dbl);\n+  /* { dg-output \"12 178: 190\" } */\n+  CHECK( res_dbl.a == (g_dbl.a + f_dbl.a));\n+\n+  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_1_1byte_gn, NULL) == FFI_OK);\n+  \n+  res_dbl = ((cls_struct_1_1byte(*)(cls_struct_1_1byte, cls_struct_1_1byte))(pcl))(g_dbl, f_dbl);\n+  /* { dg-output \"\\n12 178: 190\" } */\n+  CHECK( res_dbl.a == (g_dbl.a + f_dbl.a));\n+\n+  exit(0);\n+}"}, {"sha": "1ccac69f77cc2fda72c4e15aa78bdc2e8baf14cb", "filename": "libffi/testsuite/libffi.call/cls_20byte.c", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fcls_20byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fcls_20byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_20byte.c?ref=8a6b509ea857a07be12738d10403d3ab0f647ffe", "patch": "@@ -0,0 +1,92 @@\n+/* Area:\tffi_call, closure_call\n+   Purpose:\tCheck structure passing with different structure size.\n+\t\tDepending on the ABI. Check overlapping.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\t<andreast@gcc.gnu.org> 20030828\t */\n+\n+/* { dg-do run } */\n+#include \"ffitest.h\"\n+\n+typedef struct cls_struct_20byte {\n+  double a;\n+  double b;\n+  int c;\n+} cls_struct_20byte;\n+\n+cls_struct_20byte cls_struct_20byte_fn(struct cls_struct_20byte a1,\n+\t\t\t    struct cls_struct_20byte a2)\n+{\n+  struct cls_struct_20byte result;\n+\n+  result.a = a1.a + a2.a;\n+  result.b = a1.b + a2.b;\n+  result.c = a1.c + a2.c;\n+  \n+  printf(\"%g %g %d %g %g %d: %g %g %d\\n\", a1.a, a1.b, a1.c, a2.a, a2.b, a2.c,\n+\t result.a, result.b, result.c);\n+  return result;\n+}\n+\n+static void \n+cls_struct_20byte_gn(ffi_cif* cif, void* resp, void** args, void* userdata)\n+{   \n+  struct cls_struct_20byte a1, a2;\n+  \n+  a1 = *(struct cls_struct_20byte*)(args[0]);\n+  a2 = *(struct cls_struct_20byte*)(args[1]);\n+  \n+  *(cls_struct_20byte*)resp = cls_struct_20byte_fn(a1, a2);\n+}\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  static ffi_closure cl;\n+  ffi_closure *pcl = &cl;\n+  void* args_dbl[5];\n+  ffi_type* cls_struct_fields[4];\n+  ffi_type cls_struct_type;\n+  ffi_type* dbl_arg_types[5];\n+\n+  cls_struct_type.size = 0;\n+  cls_struct_type.alignment = 0;\n+  cls_struct_type.type = FFI_TYPE_STRUCT;\n+  cls_struct_type.elements = cls_struct_fields;\n+  \n+  struct cls_struct_20byte g_dbl = { 1.0, 2.0, 3 };\n+  struct cls_struct_20byte f_dbl = { 4.0, 5.0, 7 };\n+  struct cls_struct_20byte res_dbl;\n+  \n+  cls_struct_fields[0] = &ffi_type_double;\n+  cls_struct_fields[1] = &ffi_type_double;\n+  cls_struct_fields[2] = &ffi_type_uint32;\n+  cls_struct_fields[3] = NULL;\n+  \n+  dbl_arg_types[0] = &cls_struct_type;\n+  dbl_arg_types[1] = &cls_struct_type;\n+  dbl_arg_types[2] = NULL;\n+  \n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type, \n+\t\t     dbl_arg_types) == FFI_OK);\n+\n+  args_dbl[0] = &g_dbl;\n+  args_dbl[1] = &f_dbl;\n+  args_dbl[2] = NULL;\n+\n+  ffi_call(&cif, FFI_FN(cls_struct_20byte_fn), &res_dbl, args_dbl);\n+  /* { dg-output \"1 2 3 4 5 7: 5 7 10\" } */\n+  CHECK( res_dbl.a == (g_dbl.a + f_dbl.a));\n+  CHECK( res_dbl.b == (g_dbl.b + f_dbl.b));\n+  CHECK( res_dbl.c == (g_dbl.c + f_dbl.c));\n+\n+  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_20byte_gn, NULL) == FFI_OK);\n+  \n+  res_dbl = ((cls_struct_20byte(*)(cls_struct_20byte, cls_struct_20byte))(pcl))(g_dbl, f_dbl);\n+  /* { dg-output \"\\n1 2 3 4 5 7: 5 7 10\" } */\n+  CHECK( res_dbl.a == (g_dbl.a + f_dbl.a));\n+  CHECK( res_dbl.b == (g_dbl.b + f_dbl.b));\n+  CHECK( res_dbl.c == (g_dbl.c + f_dbl.c));\n+\n+  exit(0);\n+} "}, {"sha": "419bb4cdb4192d46e949b4724f116b2b470a52fb", "filename": "libffi/testsuite/libffi.call/cls_24byte.c", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fcls_24byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fcls_24byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_24byte.c?ref=8a6b509ea857a07be12738d10403d3ab0f647ffe", "patch": "@@ -0,0 +1,115 @@\n+/* Area:\tffi_call, closure_call\n+   Purpose:\tCheck structure passing with different structure size.\n+\t\tDepending on the ABI. Check overlapping.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\t<andreast@gcc.gnu.org> 20030828\t */\n+\n+/* { dg-do run } */\n+#include \"ffitest.h\"\n+\n+typedef struct cls_struct_24byte {\n+  double a;\n+  double b;\n+  int c;\n+  float d;\n+} cls_struct_24byte;\n+\n+cls_struct_24byte cls_struct_24byte_fn(struct cls_struct_24byte b0,\n+\t\t\t    struct cls_struct_24byte b1,\n+\t\t\t    struct cls_struct_24byte b2,\n+\t\t\t    struct cls_struct_24byte b3)\n+{\n+  struct cls_struct_24byte result;\n+\n+  result.a = b0.a + b1.a + b2.a + b3.a;\n+  result.b = b0.b + b1.b + b2.b + b3.b;\n+  result.c = b0.c + b1.c + b2.c + b3.c;\n+  result.d = b0.d + b1.d + b2.d + b3.d;\n+\n+  printf(\"%g %g %d %g %g %g %d %g %g %g %d %g %g %g %d %g: %g %g %d %g\\n\", \n+\t b0.a, b0.b, b0.c, b0.d,\n+\t b1.a, b1.b, b1.c, b1.d,\n+\t b2.a, b2.b, b2.c, b2.d,\n+\t b3.a, b3.b, b3.c, b2.d,\n+\t result.a, result.b, result.c, result.d);\n+\n+  return result;\n+}\n+\n+static void \n+cls_struct_24byte_gn(ffi_cif* cif, void* resp, void** args, void* userdata)\n+{   \n+  struct cls_struct_24byte b0, b1, b2, b3;\n+  \n+  b0 = *(struct cls_struct_24byte*)(args[0]);\n+  b1 = *(struct cls_struct_24byte*)(args[1]);\n+  b2 = *(struct cls_struct_24byte*)(args[2]);\n+  b3 = *(struct cls_struct_24byte*)(args[3]);\n+  \n+  *(cls_struct_24byte*)resp = cls_struct_24byte_fn(b0, b1, b2, b3);\n+}\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  static ffi_closure cl;\n+  ffi_closure *pcl = &cl;\n+  void* args_dbl[5];\n+  ffi_type* cls_struct_fields[5];\n+  ffi_type cls_struct_type;\n+  ffi_type* dbl_arg_types[5];\n+  \n+  cls_struct_type.size = 0;\n+  cls_struct_type.alignment = 0;\n+  cls_struct_type.type = FFI_TYPE_STRUCT;\n+  cls_struct_type.elements = cls_struct_fields;\n+  \n+  struct cls_struct_24byte e_dbl = { 9.0, 2.0, 6, 5.0 };\n+  struct cls_struct_24byte f_dbl = { 1.0, 2.0, 3, 7.0 };\n+  struct cls_struct_24byte g_dbl = { 4.0, 5.0, 7, 9.0 };\n+  struct cls_struct_24byte h_dbl = { 8.0, 6.0, 1, 4.0 };\n+  struct cls_struct_24byte res_dbl;\n+  \n+  cls_struct_fields[0] = &ffi_type_double;\n+  cls_struct_fields[1] = &ffi_type_double;\n+  cls_struct_fields[2] = &ffi_type_uint32;\n+  cls_struct_fields[3] = &ffi_type_float;\n+  cls_struct_fields[4] = NULL;\n+  \n+  dbl_arg_types[0] = &cls_struct_type;\n+  dbl_arg_types[1] = &cls_struct_type;\n+  dbl_arg_types[2] = &cls_struct_type;\n+  dbl_arg_types[3] = &cls_struct_type;\n+  dbl_arg_types[4] = NULL;\n+  \n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 4, &cls_struct_type, \n+\t\t     dbl_arg_types) == FFI_OK);\n+\n+  args_dbl[0] = &e_dbl;\n+  args_dbl[1] = &f_dbl;\n+  args_dbl[2] = &g_dbl;\n+  args_dbl[3] = &h_dbl;\n+  args_dbl[4] = NULL;\n+\n+  ffi_call(&cif, FFI_FN(cls_struct_24byte_fn), &res_dbl, args_dbl);\n+  /* { dg-output \"9 2 6 5 1 2 3 7 4 5 7 9 8 6 1 9: 22 15 17 25\" } */\n+  CHECK( res_dbl.a == (e_dbl.a + f_dbl.a + g_dbl.a + h_dbl.a));\n+  CHECK( res_dbl.b == (e_dbl.b + f_dbl.b + g_dbl.b + h_dbl.b));\n+  CHECK( res_dbl.c == (e_dbl.c + f_dbl.c + g_dbl.c + h_dbl.c));\n+  CHECK( res_dbl.d == (e_dbl.d + f_dbl.d + g_dbl.d + h_dbl.d));\n+\n+  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_24byte_gn, NULL) == FFI_OK);\n+  \n+  res_dbl = ((cls_struct_24byte(*)(cls_struct_24byte, \n+\t\t\t\t     cls_struct_24byte,\n+\t\t\t\t     cls_struct_24byte, \n+\t\t\t\t     cls_struct_24byte))\n+\t     (pcl))(e_dbl, f_dbl, g_dbl, h_dbl);\n+  /* { dg-output \"\\n9 2 6 5 1 2 3 7 4 5 7 9 8 6 1 9: 22 15 17 25\" } */\n+  CHECK( res_dbl.a == (e_dbl.a + f_dbl.a + g_dbl.a + h_dbl.a));\n+  CHECK( res_dbl.b == (e_dbl.b + f_dbl.b + g_dbl.b + h_dbl.b));\n+  CHECK( res_dbl.c == (e_dbl.c + f_dbl.c + g_dbl.c + h_dbl.c));\n+  CHECK( res_dbl.d == (e_dbl.d + f_dbl.d + g_dbl.d + h_dbl.d));\n+  exit(0);\n+}   "}, {"sha": "512952cc0c2abd683f09a1d4da36dd1074e07602", "filename": "libffi/testsuite/libffi.call/cls_2byte.c", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fcls_2byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fcls_2byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_2byte.c?ref=8a6b509ea857a07be12738d10403d3ab0f647ffe", "patch": "@@ -0,0 +1,89 @@\n+/* Area:\tffi_call, closure_call\n+   Purpose:\tCheck structure passing with different structure size.\n+\t\tEspecially with small structures which may fit in one\n+\t\tregister. Depending on the ABI.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\t<andreast@gcc.gnu.org> 20030828\t */\n+\n+/* { dg-do run } */\n+#include \"ffitest.h\"\n+\n+typedef struct cls_struct_2byte {\n+  unsigned char a;\n+  unsigned char b;\n+} cls_struct_2byte;\n+\n+cls_struct_2byte cls_struct_2byte_fn(struct cls_struct_2byte a1,\n+\t\t\t    struct cls_struct_2byte a2)\n+{\n+  struct cls_struct_2byte result;\n+\n+  result.a = a1.a + a2.a;\n+  result.b = a1.b + a2.b;\n+\n+  printf(\"%d %d %d %d: %d %d\\n\", a1.a, a1.b, a2.a, a2.b, result.a, result.b);\n+\n+  return  result;\n+}\n+\n+static void \n+cls_struct_2byte_gn(ffi_cif* cif, void* resp, void** args, void* userdata)\n+{   \n+  \n+  struct cls_struct_2byte a1, a2;\n+\n+  a1 = *(struct cls_struct_2byte*)(args[0]);\n+  a2 = *(struct cls_struct_2byte*)(args[1]);\n+\n+  *(cls_struct_2byte*)resp = cls_struct_2byte_fn(a1, a2);\n+}\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  static ffi_closure cl;\n+  ffi_closure *pcl = &cl;\n+  void* args_dbl[5];\n+  ffi_type* cls_struct_fields[4];\n+  ffi_type cls_struct_type;\n+  ffi_type* dbl_arg_types[5];\n+\n+  cls_struct_type.size = 0;\n+  cls_struct_type.alignment = 0;\n+  cls_struct_type.type = FFI_TYPE_STRUCT;\n+  cls_struct_type.elements = cls_struct_fields;\n+\n+  struct cls_struct_2byte g_dbl = { 12, 127 };\n+  struct cls_struct_2byte f_dbl = { 1, 13 };\n+  struct cls_struct_2byte res_dbl;\n+  \n+  cls_struct_fields[0] = &ffi_type_uchar;\n+  cls_struct_fields[1] = &ffi_type_uchar;\n+  cls_struct_fields[2] = NULL;\n+  \n+  dbl_arg_types[0] = &cls_struct_type;\n+  dbl_arg_types[1] = &cls_struct_type;\n+  dbl_arg_types[2] = NULL;\n+  \n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type, \n+\t\t     dbl_arg_types) == FFI_OK);\n+\n+  args_dbl[0] = &g_dbl;\n+  args_dbl[1] = &f_dbl;\n+  args_dbl[2] = NULL;\n+\n+  ffi_call(&cif, FFI_FN(cls_struct_2byte_fn), &res_dbl, args_dbl);\n+  /* { dg-output \"12 127 1 13: 13 140\" } */\n+  CHECK( res_dbl.a == (g_dbl.a + f_dbl.a));\n+  CHECK( res_dbl.b == (g_dbl.b + f_dbl.b));\n+\n+  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_2byte_gn, NULL) == FFI_OK);\n+  \n+  res_dbl = ((cls_struct_2byte(*)(cls_struct_2byte, cls_struct_2byte))(pcl))(g_dbl, f_dbl);\n+  /* { dg-output \"\\n12 127 1 13: 13 140\" } */\n+  CHECK( res_dbl.a == (g_dbl.a + f_dbl.a));\n+  CHECK( res_dbl.b == (g_dbl.b + f_dbl.b));\n+\n+  exit(0);\n+}"}, {"sha": "b8dad5b67ff03b43a69556689cf145a6362a9b5c", "filename": "libffi/testsuite/libffi.call/cls_3_1byte.c", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fcls_3_1byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fcls_3_1byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_3_1byte.c?ref=8a6b509ea857a07be12738d10403d3ab0f647ffe", "patch": "@@ -0,0 +1,98 @@\n+/* Area:\tffi_call, closure_call\n+   Purpose:\tCheck structure passing with different structure size.\n+\t\tEspecially with small structures which may fit in one\n+\t\tregister. Depending on the ABI.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\t<andreast@gcc.gnu.org> 20030902\t */\n+\n+/* { dg-do run } */\n+#include \"ffitest.h\"\n+\n+typedef struct cls_struct_3_1byte {\n+  unsigned char a;\n+  unsigned char b;\n+  unsigned char c;\n+} cls_struct_3_1byte;\n+\n+cls_struct_3_1byte cls_struct_3_1byte_fn(struct cls_struct_3_1byte a1,\n+\t\t\t    struct cls_struct_3_1byte a2)\n+{\n+  struct cls_struct_3_1byte result;\n+\n+  result.a = a1.a + a2.a;\n+  result.b = a1.b + a2.b;\n+  result.c = a1.c + a2.c;\n+\n+  printf(\"%d %d %d %d %d %d: %d %d %d\\n\", a1.a, a1.b, a1.c,\n+\t a2.a, a2.b, a2.c,\n+\t result.a, result.b, result.c);\n+\n+  return  result;\n+}\n+\n+static void \n+cls_struct_3_1byte_gn(ffi_cif* cif, void* resp, void** args, void* userdata)\n+{   \n+  \n+  struct cls_struct_3_1byte a1, a2;\n+\n+  a1 = *(struct cls_struct_3_1byte*)(args[0]);\n+  a2 = *(struct cls_struct_3_1byte*)(args[1]);\n+\n+  *(cls_struct_3_1byte*)resp = cls_struct_3_1byte_fn(a1, a2);\n+}\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  static ffi_closure cl;\n+  ffi_closure *pcl = &cl;\n+  void* args_dbl[5];\n+  ffi_type* cls_struct_fields[4];\n+  ffi_type cls_struct_type;\n+  ffi_type* dbl_arg_types[5];\n+\n+  cls_struct_type.size = 0;\n+  cls_struct_type.alignment = 0;\n+  cls_struct_type.type = FFI_TYPE_STRUCT;\n+  cls_struct_type.elements = cls_struct_fields;\n+\n+  struct cls_struct_3_1byte g_dbl = { 12, 13, 14 };\n+  struct cls_struct_3_1byte f_dbl = { 178, 179, 180 };\n+  struct cls_struct_3_1byte res_dbl;\n+  \n+  cls_struct_fields[0] = &ffi_type_uchar;\n+  cls_struct_fields[1] = &ffi_type_uchar;\n+  cls_struct_fields[2] = &ffi_type_uchar;\n+  cls_struct_fields[3] = NULL;\n+  \n+  dbl_arg_types[0] = &cls_struct_type;\n+  dbl_arg_types[1] = &cls_struct_type;\n+  dbl_arg_types[2] = NULL;\n+  \n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type, \n+\t\t     dbl_arg_types) == FFI_OK);\n+\n+  args_dbl[0] = &g_dbl;\n+  args_dbl[1] = &f_dbl;\n+  args_dbl[2] = NULL;\n+\n+  ffi_call(&cif, FFI_FN(cls_struct_3_1byte_fn), &res_dbl, args_dbl);\n+  /* { dg-output \"12 13 14 178 179 180: 190 192 194\" } */\n+  CHECK( res_dbl.a == (g_dbl.a + f_dbl.a));\n+  CHECK( res_dbl.b == (g_dbl.b + f_dbl.b));\n+  CHECK( res_dbl.c == (g_dbl.c + f_dbl.c));\n+\n+\n+  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_3_1byte_gn, NULL) == FFI_OK);\n+  \n+  res_dbl = ((cls_struct_3_1byte(*)(cls_struct_3_1byte, cls_struct_3_1byte))(pcl))(g_dbl, f_dbl);\n+  /* { dg-output \"\\n12 13 14 178 179 180: 190 192 194\" } */\n+  CHECK( res_dbl.a == (g_dbl.a + f_dbl.a));\n+  CHECK( res_dbl.b == (g_dbl.b + f_dbl.b));\n+  CHECK( res_dbl.c == (g_dbl.c + f_dbl.c));\n+\n+\n+  exit(0);\n+}"}, {"sha": "44f9f457242e6642ea5ca2b8abf3d8e9690e25c7", "filename": "libffi/testsuite/libffi.call/cls_3byte1.c", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fcls_3byte1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fcls_3byte1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_3byte1.c?ref=8a6b509ea857a07be12738d10403d3ab0f647ffe", "patch": "@@ -0,0 +1,89 @@\n+/* Area:\tffi_call, closure_call\n+   Purpose:\tCheck structure passing with different structure size.\n+\t\tEspecially with small structures which may fit in one\n+\t\tregister. Depending on the ABI. Check overlapping.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\t<andreast@gcc.gnu.org> 20030828\t */\n+\n+/* { dg-do run } */\n+#include \"ffitest.h\"\n+\n+typedef struct cls_struct_3byte {\n+  unsigned short a;\n+  unsigned char b;\n+} cls_struct_3byte;\n+\n+cls_struct_3byte cls_struct_3byte_fn(struct cls_struct_3byte a1,\n+\t\t\t    struct cls_struct_3byte a2)\n+{\n+  struct cls_struct_3byte result;\n+\n+  result.a = a1.a + a2.a;\n+  result.b = a1.b + a2.b;\n+\n+  printf(\"%d %d %d %d: %d %d\\n\", a1.a, a1.b, a2.a, a2.b, result.a, result.b);\n+\n+  return  result;\n+}\n+\n+static void \n+cls_struct_3byte_gn(ffi_cif* cif, void* resp, void** args, void* userdata)\n+{   \n+  \n+  struct cls_struct_3byte a1, a2;\n+\n+  a1 = *(struct cls_struct_3byte*)(args[0]);\n+  a2 = *(struct cls_struct_3byte*)(args[1]);\n+\n+  *(cls_struct_3byte*)resp = cls_struct_3byte_fn(a1, a2);\n+}\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  static ffi_closure cl;\n+  ffi_closure *pcl = &cl;\n+  void* args_dbl[5];\n+  ffi_type* cls_struct_fields[4];\n+  ffi_type cls_struct_type;\n+  ffi_type* dbl_arg_types[5];\n+\n+  cls_struct_type.size = 0;\n+  cls_struct_type.alignment = 0;\n+  cls_struct_type.type = FFI_TYPE_STRUCT;\n+  cls_struct_type.elements = cls_struct_fields;\n+\n+  struct cls_struct_3byte g_dbl = { 12, 119 };\n+  struct cls_struct_3byte f_dbl = { 1, 15 };\n+  struct cls_struct_3byte res_dbl;\n+  \n+  cls_struct_fields[0] = &ffi_type_ushort;\n+  cls_struct_fields[1] = &ffi_type_uchar;\n+  cls_struct_fields[2] = NULL;\n+  \n+  dbl_arg_types[0] = &cls_struct_type;\n+  dbl_arg_types[1] = &cls_struct_type;\n+  dbl_arg_types[2] = NULL;\n+  \n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type, \n+\t\t     dbl_arg_types) == FFI_OK);\n+\n+  args_dbl[0] = &g_dbl;\n+  args_dbl[1] = &f_dbl;\n+  args_dbl[2] = NULL;\n+\n+  ffi_call(&cif, FFI_FN(cls_struct_3byte_fn), &res_dbl, args_dbl);\n+  /* { dg-output \"12 119 1 15: 13 134\" } */\n+  CHECK( res_dbl.a == (g_dbl.a + f_dbl.a));\n+  CHECK( res_dbl.b == (g_dbl.b + f_dbl.b));\n+\n+  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_3byte_gn, NULL) == FFI_OK);\n+  \n+  res_dbl = ((cls_struct_3byte(*)(cls_struct_3byte, cls_struct_3byte))(pcl))(g_dbl, f_dbl);\n+  /* { dg-output \"\\n12 119 1 15: 13 134\" } */\n+  CHECK( res_dbl.a == (g_dbl.a + f_dbl.a));\n+  CHECK( res_dbl.b == (g_dbl.b + f_dbl.b));\n+\n+  exit(0);\n+}"}, {"sha": "5d3b50f84726aec663284b238bef475898b5ed5d", "filename": "libffi/testsuite/libffi.call/cls_3byte2.c", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fcls_3byte2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fcls_3byte2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_3byte2.c?ref=8a6b509ea857a07be12738d10403d3ab0f647ffe", "patch": "@@ -0,0 +1,89 @@\n+/* Area:\tffi_call, closure_call\n+   Purpose:\tCheck structure passing with different structure size.\n+\t\tEspecially with small structures which may fit in one\n+\t\tregister. Depending on the ABI. Check overlapping.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\t<andreast@gcc.gnu.org> 20030828\t */\n+\n+/* { dg-do run } */\n+#include \"ffitest.h\"\n+\n+typedef struct cls_struct_3byte_1 {\n+  unsigned char a;\n+  unsigned short b;\n+} cls_struct_3byte_1;\n+\n+cls_struct_3byte_1 cls_struct_3byte_fn1(struct cls_struct_3byte_1 a1,\n+\t\t\t    struct cls_struct_3byte_1 a2)\n+{\n+  struct cls_struct_3byte_1 result;\n+\n+  result.a = a1.a + a2.a;\n+  result.b = a1.b + a2.b;\n+\n+  printf(\"%d %d %d %d: %d %d\\n\", a1.a, a1.b, a2.a, a2.b, result.a, result.b);\n+\n+  return  result;\n+}\n+\n+static void \n+cls_struct_3byte_gn1(ffi_cif* cif, void* resp, void** args, void* userdata)\n+{   \n+  \n+  struct cls_struct_3byte_1 a1, a2;\n+\n+  a1 = *(struct cls_struct_3byte_1*)(args[0]);\n+  a2 = *(struct cls_struct_3byte_1*)(args[1]);\n+\n+  *(cls_struct_3byte_1*)resp = cls_struct_3byte_fn1(a1, a2);\n+}\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  static ffi_closure cl;\n+  ffi_closure *pcl = &cl;\n+  void* args_dbl[5];\n+  ffi_type* cls_struct_fields[4];\n+  ffi_type cls_struct_type;\n+  ffi_type* dbl_arg_types[5];\n+\n+  cls_struct_type.size = 0;\n+  cls_struct_type.alignment = 0;\n+  cls_struct_type.type = FFI_TYPE_STRUCT;\n+  cls_struct_type.elements = cls_struct_fields;\n+\n+  struct cls_struct_3byte_1 g_dbl = { 15, 125 };\n+  struct cls_struct_3byte_1 f_dbl = { 9, 19 };\n+  struct cls_struct_3byte_1 res_dbl;\n+  \n+  cls_struct_fields[0] = &ffi_type_uchar;\n+  cls_struct_fields[1] = &ffi_type_ushort;\n+  cls_struct_fields[2] = NULL;\n+  \n+  dbl_arg_types[0] = &cls_struct_type;\n+  dbl_arg_types[1] = &cls_struct_type;\n+  dbl_arg_types[2] = NULL;\n+  \n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type, \n+\t\t     dbl_arg_types) == FFI_OK);\n+\n+  args_dbl[0] = &g_dbl;\n+  args_dbl[1] = &f_dbl;\n+  args_dbl[2] = NULL;\n+\n+  ffi_call(&cif, FFI_FN(cls_struct_3byte_fn1), &res_dbl, args_dbl);\n+  /* { dg-output \"15 125 9 19: 24 144\" } */\n+  CHECK( res_dbl.a == (g_dbl.a + f_dbl.a));\n+  CHECK( res_dbl.b == (g_dbl.b + f_dbl.b));\n+\n+  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_3byte_gn1, NULL) == FFI_OK);\n+  \n+  res_dbl = ((cls_struct_3byte_1(*)(cls_struct_3byte_1, cls_struct_3byte_1))(pcl))(g_dbl, f_dbl);\n+  /* { dg-output \"\\n15 125 9 19: 24 144\" } */\n+  CHECK( res_dbl.a == (g_dbl.a + f_dbl.a));\n+  CHECK( res_dbl.b == (g_dbl.b + f_dbl.b));\n+\n+  exit(0);\n+}"}, {"sha": "292081ca4a2a51de0fc88d867f8a9e23bc125bf8", "filename": "libffi/testsuite/libffi.call/cls_4_1byte.c", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fcls_4_1byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fcls_4_1byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_4_1byte.c?ref=8a6b509ea857a07be12738d10403d3ab0f647ffe", "patch": "@@ -0,0 +1,101 @@\n+/* Area:\tffi_call, closure_call\n+   Purpose:\tCheck structure passing with different structure size.\n+\t\tEspecially with small structures which may fit in one\n+\t\tregister. Depending on the ABI.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\t<andreast@gcc.gnu.org> 20030902\t */\n+\n+/* { dg-do run } */\n+#include \"ffitest.h\"\n+\n+typedef struct cls_struct_4_1byte {\n+  unsigned char a;\n+  unsigned char b;\n+  unsigned char c;\n+  unsigned char d;\n+} cls_struct_4_1byte;\n+\n+cls_struct_4_1byte cls_struct_4_1byte_fn(struct cls_struct_4_1byte a1,\n+\t\t\t    struct cls_struct_4_1byte a2)\n+{\n+  struct cls_struct_4_1byte result;\n+\n+  result.a = a1.a + a2.a;\n+  result.b = a1.b + a2.b;\n+  result.c = a1.c + a2.c;\n+  result.d = a1.d + a2.d;\n+\n+  printf(\"%d %d %d %d %d %d %d %d: %d %d %d %d\\n\", a1.a, a1.b, a1.c, a1.d,\n+\t a2.a, a2.b, a2.c, a2.d,\n+\t result.a, result.b, result.c, result.d);\n+\n+  return  result;\n+}\n+\n+static void \n+cls_struct_4_1byte_gn(ffi_cif* cif, void* resp, void** args, void* userdata)\n+{   \n+  \n+  struct cls_struct_4_1byte a1, a2;\n+\n+  a1 = *(struct cls_struct_4_1byte*)(args[0]);\n+  a2 = *(struct cls_struct_4_1byte*)(args[1]);\n+\n+  *(cls_struct_4_1byte*)resp = cls_struct_4_1byte_fn(a1, a2);\n+}\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  static ffi_closure cl;\n+  ffi_closure *pcl = &cl;\n+  void* args_dbl[5];\n+  ffi_type* cls_struct_fields[5];\n+  ffi_type cls_struct_type;\n+  ffi_type* dbl_arg_types[5];\n+\n+  cls_struct_type.size = 0;\n+  cls_struct_type.alignment = 0;\n+  cls_struct_type.type = FFI_TYPE_STRUCT;\n+  cls_struct_type.elements = cls_struct_fields;\n+\n+  struct cls_struct_4_1byte g_dbl = { 12, 13, 14, 15 };\n+  struct cls_struct_4_1byte f_dbl = { 178, 179, 180, 181 };\n+  struct cls_struct_4_1byte res_dbl;\n+  \n+  cls_struct_fields[0] = &ffi_type_uchar;\n+  cls_struct_fields[1] = &ffi_type_uchar;\n+  cls_struct_fields[2] = &ffi_type_uchar;\n+  cls_struct_fields[3] = &ffi_type_uchar;\n+  cls_struct_fields[4] = NULL;\n+  \n+  dbl_arg_types[0] = &cls_struct_type;\n+  dbl_arg_types[1] = &cls_struct_type;\n+  dbl_arg_types[2] = NULL;\n+  \n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type, \n+\t\t     dbl_arg_types) == FFI_OK);\n+\n+  args_dbl[0] = &g_dbl;\n+  args_dbl[1] = &f_dbl;\n+  args_dbl[2] = NULL;\n+\n+  ffi_call(&cif, FFI_FN(cls_struct_4_1byte_fn), &res_dbl, args_dbl);\n+  /* { dg-output \"12 13 14 15 178 179 180 181: 190 192 194 196\" } */\n+  CHECK( res_dbl.a == (g_dbl.a + f_dbl.a));\n+  CHECK( res_dbl.b == (g_dbl.b + f_dbl.b));\n+  CHECK( res_dbl.c == (g_dbl.c + f_dbl.c));\n+  CHECK( res_dbl.d == (g_dbl.d + f_dbl.d));\n+\n+  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_4_1byte_gn, NULL) == FFI_OK);\n+  \n+  res_dbl = ((cls_struct_4_1byte(*)(cls_struct_4_1byte, cls_struct_4_1byte))(pcl))(g_dbl, f_dbl);\n+  /* { dg-output \"\\n12 13 14 15 178 179 180 181: 190 192 194 196\" } */\n+  CHECK( res_dbl.a == (g_dbl.a + f_dbl.a));\n+  CHECK( res_dbl.b == (g_dbl.b + f_dbl.b));\n+  CHECK( res_dbl.c == (g_dbl.c + f_dbl.c));\n+  CHECK( res_dbl.d == (g_dbl.d + f_dbl.d));\n+\n+  exit(0);\n+}"}, {"sha": "f31811aa530e5cd72560955891e5f76a2f700eee", "filename": "libffi/testsuite/libffi.call/cls_4byte.c", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fcls_4byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fcls_4byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_4byte.c?ref=8a6b509ea857a07be12738d10403d3ab0f647ffe", "patch": "@@ -0,0 +1,89 @@\n+/* Area:\tffi_call, closure_call\n+   Purpose:\tCheck structure passing with different structure size.\n+\t\tDepending on the ABI. Check overlapping.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\t<andreast@gcc.gnu.org> 20030828\t */\n+\n+/* { dg-do run } */\n+\n+#include \"ffitest.h\"\n+\n+typedef struct cls_struct_4byte {\n+  unsigned short a;\n+  unsigned short b;\n+} cls_struct_4byte;\n+\n+cls_struct_4byte cls_struct_4byte_fn(struct cls_struct_4byte a1,\n+\t\t\t    struct cls_struct_4byte a2)\n+{\n+  struct cls_struct_4byte result;\n+\n+  result.a = a1.a + a2.a;\n+  result.b = a1.b + a2.b;\n+\n+  printf(\"%d %d %d %d: %d %d\\n\", a1.a, a1.b, a2.a, a2.b, result.a, result.b);\n+\n+  return  result;\n+}\n+\n+static void \n+cls_struct_4byte_gn(ffi_cif* cif, void* resp, void** args, void* userdata)\n+{   \n+  \n+  struct cls_struct_4byte a1, a2;\n+\n+  a1 = *(struct cls_struct_4byte*)(args[0]);\n+  a2 = *(struct cls_struct_4byte*)(args[1]);\n+\n+  *(cls_struct_4byte*)resp = cls_struct_4byte_fn(a1, a2);\n+}\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  static ffi_closure cl;\n+  ffi_closure *pcl = &cl;\n+  void* args_dbl[5];\n+  ffi_type* cls_struct_fields[4];\n+  ffi_type cls_struct_type;\n+  ffi_type* dbl_arg_types[5];\n+\n+  cls_struct_type.size = 0;\n+  cls_struct_type.alignment = 0;\n+  cls_struct_type.type = FFI_TYPE_STRUCT;\n+  cls_struct_type.elements = cls_struct_fields;\n+\n+  struct cls_struct_4byte g_dbl = { 127, 120 };\n+  struct cls_struct_4byte f_dbl = { 12, 128 };\n+  struct cls_struct_4byte res_dbl;\n+  \n+  cls_struct_fields[0] = &ffi_type_ushort;\n+  cls_struct_fields[1] = &ffi_type_ushort;\n+  cls_struct_fields[2] = NULL;\n+  \n+  dbl_arg_types[0] = &cls_struct_type;\n+  dbl_arg_types[1] = &cls_struct_type;\n+  dbl_arg_types[2] = NULL;\n+  \n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type, \n+\t\t     dbl_arg_types) == FFI_OK);\n+\n+  args_dbl[0] = &g_dbl;\n+  args_dbl[1] = &f_dbl;\n+  args_dbl[2] = NULL;\n+\n+  ffi_call(&cif, FFI_FN(cls_struct_4byte_fn), &res_dbl, args_dbl);\n+  /* { dg-output \"127 120 12 128: 139 248\" } */\n+  CHECK( res_dbl.a == (g_dbl.a + f_dbl.a));\n+  CHECK( res_dbl.b == (g_dbl.b + f_dbl.b));\n+\n+  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_4byte_gn, NULL) == FFI_OK);\n+  \n+  res_dbl = ((cls_struct_4byte(*)(cls_struct_4byte, cls_struct_4byte))(pcl))(g_dbl, f_dbl);\n+  /* { dg-output \"\\n127 120 12 128: 139 248\" } */\n+  CHECK( res_dbl.a == (g_dbl.a + f_dbl.a));\n+  CHECK( res_dbl.b == (g_dbl.b + f_dbl.b));\n+\n+  exit(0);\n+}"}, {"sha": "5b28dc1ab7f853d0152a3e72dad9c40a448fe70f", "filename": "libffi/testsuite/libffi.call/cls_5byte.c", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fcls_5byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fcls_5byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_5byte.c?ref=8a6b509ea857a07be12738d10403d3ab0f647ffe", "patch": "@@ -0,0 +1,95 @@\n+/* Area:\tffi_call, closure_call\n+   Purpose:\tCheck structure passing with different structure size.\n+\t\tDepending on the ABI. Check overlapping.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\t<andreast@gcc.gnu.org> 20030828\t */\n+\n+/* { dg-do run } */\n+#include \"ffitest.h\"\n+\n+typedef struct cls_struct_5byte {\n+  unsigned short a;\n+  unsigned short b;\n+  unsigned char c;\n+} cls_struct_5byte;\n+\n+cls_struct_5byte cls_struct_5byte_fn(struct cls_struct_5byte a1,\n+\t\t\t    struct cls_struct_5byte a2)\n+{\n+  struct cls_struct_5byte result;\n+\n+  result.a = a1.a + a2.a;\n+  result.b = a1.b + a2.b;\n+  result.c = a1.c + a2.c;\n+\n+  printf(\"%d %d %d %d %d %d: %d %d %d\\n\", a1.a, a1.b, a1.c,\n+\t a2.a, a2.b, a2.c, \n+\t result.a, result.b, result.c);\n+\n+  return  result;\n+}\n+\n+static void \n+cls_struct_5byte_gn(ffi_cif* cif, void* resp, void** args, void* userdata)\n+{   \n+  \n+  struct cls_struct_5byte a1, a2;\n+\n+  a1 = *(struct cls_struct_5byte*)(args[0]);\n+  a2 = *(struct cls_struct_5byte*)(args[1]);\n+\n+  *(cls_struct_5byte*)resp = cls_struct_5byte_fn(a1, a2);\n+}\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  static ffi_closure cl;\n+  ffi_closure *pcl = &cl;\n+  void* args_dbl[5];\n+  ffi_type* cls_struct_fields[4];\n+  ffi_type cls_struct_type;\n+  ffi_type* dbl_arg_types[5];\n+\n+  cls_struct_type.size = 0;\n+  cls_struct_type.alignment = 0;\n+  cls_struct_type.type = FFI_TYPE_STRUCT;\n+  cls_struct_type.elements = cls_struct_fields;\n+\n+  struct cls_struct_5byte g_dbl = { 127, 120, 1 };\n+  struct cls_struct_5byte f_dbl = { 12, 128, 9 };\n+  struct cls_struct_5byte res_dbl;\n+  \n+  cls_struct_fields[0] = &ffi_type_ushort;\n+  cls_struct_fields[1] = &ffi_type_ushort;\n+  cls_struct_fields[2] = &ffi_type_uchar;\n+  cls_struct_fields[3] = NULL;\n+  \n+  dbl_arg_types[0] = &cls_struct_type;\n+  dbl_arg_types[1] = &cls_struct_type;\n+  dbl_arg_types[2] = NULL;\n+  \n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type, \n+\t\t     dbl_arg_types) == FFI_OK);\n+\n+  args_dbl[0] = &g_dbl;\n+  args_dbl[1] = &f_dbl;\n+  args_dbl[2] = NULL;\n+\n+  ffi_call(&cif, FFI_FN(cls_struct_5byte_fn), &res_dbl, args_dbl);\n+  /* { dg-output \"127 120 1 12 128 9: 139 248 10\" } */\n+  CHECK( res_dbl.a == (g_dbl.a + f_dbl.a));\n+  CHECK( res_dbl.b == (g_dbl.b + f_dbl.b));\n+  CHECK( res_dbl.c == (g_dbl.c + f_dbl.c));\n+\n+  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_5byte_gn, NULL) == FFI_OK);\n+  \n+  res_dbl = ((cls_struct_5byte(*)(cls_struct_5byte, cls_struct_5byte))(pcl))(g_dbl, f_dbl);\n+  /* { dg-output \"\\n127 120 1 12 128 9: 139 248 10\" } */\n+  CHECK( res_dbl.a == (g_dbl.a + f_dbl.a));\n+  CHECK( res_dbl.b == (g_dbl.b + f_dbl.b));\n+  CHECK( res_dbl.c == (g_dbl.c + f_dbl.c));\n+\n+  exit(0);\n+}"}, {"sha": "3728c3925d617b5d4686a739e459457399e010d8", "filename": "libffi/testsuite/libffi.call/cls_6byte.c", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fcls_6byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fcls_6byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_6byte.c?ref=8a6b509ea857a07be12738d10403d3ab0f647ffe", "patch": "@@ -0,0 +1,100 @@\n+/* Area:\tffi_call, closure_call\n+   Purpose:\tCheck structure passing with different structure size.\n+\t\tDepending on the ABI. Check overlapping.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\t<andreast@gcc.gnu.org> 20030828\t */\n+\n+/* { dg-do run } */\n+#include \"ffitest.h\"\n+\n+typedef struct cls_struct_6byte {\n+  unsigned short a;\n+  unsigned short b;\n+  unsigned char c;\n+  unsigned char d;\n+} cls_struct_6byte;\n+\n+cls_struct_6byte cls_struct_6byte_fn(struct cls_struct_6byte a1,\n+\t\t\t    struct cls_struct_6byte a2)\n+{\n+  struct cls_struct_6byte result;\n+\n+  result.a = a1.a + a2.a;\n+  result.b = a1.b + a2.b;\n+  result.c = a1.c + a2.c;\n+  result.d = a1.d + a2.d;\n+\n+  printf(\"%d %d %d %d %d %d %d %d: %d %d %d %d\\n\", a1.a, a1.b, a1.c, a1.d,\n+\t a2.a, a2.b, a2.c, a2.d, \n+\t result.a, result.b, result.c, result.d);\n+\n+  return  result;\n+}\n+\n+static void \n+cls_struct_6byte_gn(ffi_cif* cif, void* resp, void** args, void* userdata)\n+{   \n+  \n+  struct cls_struct_6byte a1, a2;\n+\n+  a1 = *(struct cls_struct_6byte*)(args[0]);\n+  a2 = *(struct cls_struct_6byte*)(args[1]);\n+\n+  *(cls_struct_6byte*)resp = cls_struct_6byte_fn(a1, a2);\n+}\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  static ffi_closure cl;\n+  ffi_closure *pcl = &cl;\n+  void* args_dbl[5];\n+  ffi_type* cls_struct_fields[5];\n+  ffi_type cls_struct_type;\n+  ffi_type* dbl_arg_types[5];\n+\n+  cls_struct_type.size = 0;\n+  cls_struct_type.alignment = 0;\n+  cls_struct_type.type = FFI_TYPE_STRUCT;\n+  cls_struct_type.elements = cls_struct_fields;\n+\n+  struct cls_struct_6byte g_dbl = { 127, 120, 1, 128 };\n+  struct cls_struct_6byte f_dbl = { 12, 128, 9, 127 };\n+  struct cls_struct_6byte res_dbl;\n+  \n+  cls_struct_fields[0] = &ffi_type_ushort;\n+  cls_struct_fields[1] = &ffi_type_ushort;\n+  cls_struct_fields[2] = &ffi_type_uchar;\n+  cls_struct_fields[3] = &ffi_type_uchar;\n+  cls_struct_fields[4] = NULL;\n+  \n+  dbl_arg_types[0] = &cls_struct_type;\n+  dbl_arg_types[1] = &cls_struct_type;\n+  dbl_arg_types[2] = NULL;\n+  \n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type, \n+\t\t     dbl_arg_types) == FFI_OK);\n+\n+  args_dbl[0] = &g_dbl;\n+  args_dbl[1] = &f_dbl;\n+  args_dbl[2] = NULL;\n+\n+  ffi_call(&cif, FFI_FN(cls_struct_6byte_fn), &res_dbl, args_dbl);\n+  /* { dg-output \"127 120 1 128 12 128 9 127: 139 248 10 255\" } */\n+  CHECK( res_dbl.a == (g_dbl.a + f_dbl.a));\n+  CHECK( res_dbl.b == (g_dbl.b + f_dbl.b));\n+  CHECK( res_dbl.c == (g_dbl.c + f_dbl.c));\n+  CHECK( res_dbl.d == (g_dbl.d + f_dbl.d));\n+\n+  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_6byte_gn, NULL) == FFI_OK);\n+  \n+  res_dbl = ((cls_struct_6byte(*)(cls_struct_6byte, cls_struct_6byte))(pcl))(g_dbl, f_dbl);\n+  /* { dg-output \"\\n127 120 1 128 12 128 9 127: 139 248 10 255\" } */\n+  CHECK( res_dbl.a == (g_dbl.a + f_dbl.a));\n+  CHECK( res_dbl.b == (g_dbl.b + f_dbl.b));\n+  CHECK( res_dbl.c == (g_dbl.c + f_dbl.c));\n+  CHECK( res_dbl.d == (g_dbl.d + f_dbl.d));\n+\n+  exit(0);\n+}"}, {"sha": "ee59cf21ea7be966592438ae9179d724c7dd2821", "filename": "libffi/testsuite/libffi.call/cls_7byte.c", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fcls_7byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fcls_7byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_7byte.c?ref=8a6b509ea857a07be12738d10403d3ab0f647ffe", "patch": "@@ -0,0 +1,100 @@\n+/* Area:\tffi_call, closure_call\n+   Purpose:\tCheck structure passing with different structure size.\n+\t\tDepending on the ABI. Check overlapping.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\t<andreast@gcc.gnu.org> 20030828\t */\n+\n+/* { dg-do run } */\n+#include \"ffitest.h\"\n+\n+typedef struct cls_struct_7byte {\n+  unsigned short a;\n+  unsigned short b;\n+  unsigned char c;\n+  unsigned short d;\n+} cls_struct_7byte;\n+\n+cls_struct_7byte cls_struct_7byte_fn(struct cls_struct_7byte a1,\n+\t\t\t    struct cls_struct_7byte a2)\n+{\n+  struct cls_struct_7byte result;\n+\n+  result.a = a1.a + a2.a;\n+  result.b = a1.b + a2.b;\n+  result.c = a1.c + a2.c;\n+  result.d = a1.d + a2.d;\n+\n+  printf(\"%d %d %d %d %d %d %d %d: %d %d %d %d\\n\", a1.a, a1.b, a1.c, a1.d,\n+\t a2.a, a2.b, a2.c, a2.d, \n+\t result.a, result.b, result.c, result.d);\n+\n+  return  result;\n+}\n+\n+static void \n+cls_struct_7byte_gn(ffi_cif* cif, void* resp, void** args, void* userdata)\n+{   \n+  \n+  struct cls_struct_7byte a1, a2;\n+\n+  a1 = *(struct cls_struct_7byte*)(args[0]);\n+  a2 = *(struct cls_struct_7byte*)(args[1]);\n+\n+  *(cls_struct_7byte*)resp = cls_struct_7byte_fn(a1, a2);\n+}\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  static ffi_closure cl;\n+  ffi_closure *pcl = &cl;\n+  void* args_dbl[5];\n+  ffi_type* cls_struct_fields[5];\n+  ffi_type cls_struct_type;\n+  ffi_type* dbl_arg_types[5];\n+\n+  cls_struct_type.size = 0;\n+  cls_struct_type.alignment = 0;\n+  cls_struct_type.type = FFI_TYPE_STRUCT;\n+  cls_struct_type.elements = cls_struct_fields;\n+\n+  struct cls_struct_7byte g_dbl = { 127, 120, 1, 254 };\n+  struct cls_struct_7byte f_dbl = { 12, 128, 9, 255 };\n+  struct cls_struct_7byte res_dbl;\n+  \n+  cls_struct_fields[0] = &ffi_type_ushort;\n+  cls_struct_fields[1] = &ffi_type_ushort;\n+  cls_struct_fields[2] = &ffi_type_uchar;\n+  cls_struct_fields[3] = &ffi_type_ushort;\n+  cls_struct_fields[4] = NULL;\n+  \n+  dbl_arg_types[0] = &cls_struct_type;\n+  dbl_arg_types[1] = &cls_struct_type;\n+  dbl_arg_types[2] = NULL;\n+  \n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type, \n+\t\t     dbl_arg_types) == FFI_OK);\n+\n+  args_dbl[0] = &g_dbl;\n+  args_dbl[1] = &f_dbl;\n+  args_dbl[2] = NULL;\n+  \n+  ffi_call(&cif, FFI_FN(cls_struct_7byte_fn), &res_dbl, args_dbl);\n+  /* { dg-output \"127 120 1 254 12 128 9 255: 139 248 10 509\" } */\n+  CHECK( res_dbl.a == (g_dbl.a + f_dbl.a));\n+  CHECK( res_dbl.b == (g_dbl.b + f_dbl.b));\n+  CHECK( res_dbl.c == (g_dbl.c + f_dbl.c));\n+  CHECK( res_dbl.d == (g_dbl.d + f_dbl.d));\n+\n+  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_7byte_gn, NULL) == FFI_OK);\n+  \n+  res_dbl = ((cls_struct_7byte(*)(cls_struct_7byte, cls_struct_7byte))(pcl))(g_dbl, f_dbl);\n+  /* { dg-output \"\\n127 120 1 254 12 128 9 255: 139 248 10 509\" } */\n+  CHECK( res_dbl.a == (g_dbl.a + f_dbl.a));\n+  CHECK( res_dbl.b == (g_dbl.b + f_dbl.b));\n+  CHECK( res_dbl.c == (g_dbl.c + f_dbl.c));\n+  CHECK( res_dbl.d == (g_dbl.d + f_dbl.d));\n+\n+  exit(0);\n+}"}, {"sha": "24f4629216d15772b57a019f311cb2ad37b622ee", "filename": "libffi/testsuite/libffi.call/cls_8byte.c", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fcls_8byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fcls_8byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_8byte.c?ref=8a6b509ea857a07be12738d10403d3ab0f647ffe", "patch": "@@ -0,0 +1,88 @@\n+/* Area:\tffi_call, closure_call\n+   Purpose:\tCheck structure passing with different structure size.\n+\t\tDepending on the ABI. Check overlapping.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\t<andreast@gcc.gnu.org> 20030828\t */\n+\n+/* { dg-do run } */\n+#include \"ffitest.h\"\n+\n+typedef struct cls_struct_8byte {\n+  int a;\n+  float b;\n+} cls_struct_8byte;\n+\n+cls_struct_8byte cls_struct_8byte_fn(struct cls_struct_8byte a1,\n+\t\t\t    struct cls_struct_8byte a2)\n+{\n+  struct cls_struct_8byte result;\n+\n+  result.a = a1.a + a2.a;\n+  result.b = a1.b + a2.b;\n+\n+  printf(\"%d %g %d %g: %d %g\\n\", a1.a, a1.b, a2.a, a2.b, result.a, result.b);\n+\n+  return  result;\n+}\n+\n+static void \n+cls_struct_8byte_gn(ffi_cif* cif, void* resp, void** args, void* userdata)\n+{   \n+  \n+  struct cls_struct_8byte a1, a2;\n+\n+  a1 = *(struct cls_struct_8byte*)(args[0]);\n+  a2 = *(struct cls_struct_8byte*)(args[1]);\n+\n+  *(cls_struct_8byte*)resp = cls_struct_8byte_fn(a1, a2);\n+}\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  static ffi_closure cl;\n+  ffi_closure *pcl = &cl;\n+  void* args_dbl[5];\n+  ffi_type* cls_struct_fields[4];\n+  ffi_type cls_struct_type;\n+  ffi_type* dbl_arg_types[5];\n+\n+  cls_struct_type.size = 0;\n+  cls_struct_type.alignment = 0;\n+  cls_struct_type.type = FFI_TYPE_STRUCT;\n+  cls_struct_type.elements = cls_struct_fields;\n+\n+  struct cls_struct_8byte g_dbl = { 1, 2.0 };\n+  struct cls_struct_8byte f_dbl = { 4, 5.0 };\n+  struct cls_struct_8byte res_dbl;\n+  \n+  cls_struct_fields[0] = &ffi_type_uint32;\n+  cls_struct_fields[1] = &ffi_type_float;\n+  cls_struct_fields[2] = NULL;\n+  \n+  dbl_arg_types[0] = &cls_struct_type;\n+  dbl_arg_types[1] = &cls_struct_type;\n+  dbl_arg_types[2] = NULL;\n+  \n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type, \n+\t\t     dbl_arg_types) == FFI_OK);\n+\n+  args_dbl[0] = &g_dbl;\n+  args_dbl[1] = &f_dbl;\n+  args_dbl[2] = NULL;\n+\n+  ffi_call(&cif, FFI_FN(cls_struct_8byte_fn), &res_dbl, args_dbl);\n+  /* { dg-output \"1 2 4 5: 5 7\" } */\n+  CHECK( res_dbl.a == (g_dbl.a + f_dbl.a));\n+  CHECK( res_dbl.b == (g_dbl.b + f_dbl.b));\n+\n+  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_8byte_gn, NULL) == FFI_OK);\n+  \n+  res_dbl = ((cls_struct_8byte(*)(cls_struct_8byte, cls_struct_8byte))(pcl))(g_dbl, f_dbl);\n+  /* { dg-output \"\\n1 2 4 5: 5 7\" } */\n+  CHECK( res_dbl.a == (g_dbl.a + f_dbl.a));\n+  CHECK( res_dbl.b == (g_dbl.b + f_dbl.b));\n+\n+  exit(0);\n+} "}, {"sha": "c92ca1c681f2f382470559e93eecacca8ea8630d", "filename": "libffi/testsuite/libffi.call/cls_double.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fcls_double.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fcls_double.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_double.c?ref=8a6b509ea857a07be12738d10403d3ab0f647ffe", "patch": "@@ -0,0 +1,40 @@\n+/* Area:\tclosure_call\n+   Purpose:\tCheck return value double.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\t<andreast@gcc.gnu.org> 20030828\t */\n+\n+/* { dg-do run } */\n+#include \"ffitest.h\"\n+\n+static void cls_ret_double_fn(ffi_cif* cif,void* resp,void** args,\n+\t\t\t     void* userdata)\n+ {\n+   *(double *)resp = *(double *)args[0];\n+   \n+   printf(\"%f: %f\\n\",*(double *)args[0], \n+\t  *(double *)resp);\n+ }\n+typedef double (*cls_ret_double)(double);\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  static ffi_closure cl;\n+  ffi_closure *pcl = &cl;\n+  ffi_type * cl_arg_types[2];\n+  \n+  \n+  cl_arg_types[0] = &ffi_type_double;\n+  cl_arg_types[1] = NULL;\n+  \n+  /* Initialize the cif */\n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,\n+\t\t     &ffi_type_double, cl_arg_types) == FFI_OK);\n+  \n+  CHECK(ffi_prep_closure(pcl, &cif, cls_ret_double_fn, NULL)  == FFI_OK);\n+  \n+  (*((cls_ret_double)pcl))(21474.789);\n+  /* { dg-output \"21474.789000: 21474.789000\" } */\n+  exit(0);  \n+}"}, {"sha": "d20d78ac1ddf25263eb6458503e5c9d9eeb55563", "filename": "libffi/testsuite/libffi.call/cls_float.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fcls_float.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fcls_float.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_float.c?ref=8a6b509ea857a07be12738d10403d3ab0f647ffe", "patch": "@@ -0,0 +1,43 @@\n+/* Area:\tclosure_call\n+   Purpose:\tCheck return value float.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\t<andreast@gcc.gnu.org> 20030828\t */\n+\n+/* { dg-do run } */\n+#include \"ffitest.h\"\n+\n+static void cls_ret_float_fn(ffi_cif* cif,void* resp,void** args,\n+\t\t\t     void* userdata)\n+ {\n+   *(float *)resp = *(float *)args[0];\n+   \n+   printf(\"%g: %g\\n\",*(float *)args[0], \n+\t  *(float *)resp);\n+ }\n+\n+typedef float (*cls_ret_float)(float);\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  static ffi_closure cl;\n+  ffi_closure *pcl = &cl;\n+  ffi_type * cl_arg_types[2];\n+  \n+  \n+  cl_arg_types[0] = &ffi_type_float;\n+  cl_arg_types[1] = NULL;\n+  \n+  /* Initialize the cif */\n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,\n+\t\t     &ffi_type_float, cl_arg_types) == FFI_OK);\n+  \n+  CHECK(ffi_prep_closure(pcl, &cif, cls_ret_float_fn, NULL)  == FFI_OK);\n+  ((((cls_ret_float)pcl)(-2122.12)));\n+  /* { dg-output \"\\\\-2122.12: \\\\-2122.12\\n\" } */\n+  printf(\"%f \\n\",(((cls_ret_float)pcl)(-2122.12)));\n+  /* { dg-output \"\\\\-2122.12: \\\\-2122.12\" } */\n+  /* { dg-output \"\\n\\-2122.120117\" } */\n+  exit(0);  \n+}"}, {"sha": "94ca323c3cc19982850a6a68f57cc55445995da6", "filename": "libffi/testsuite/libffi.call/cls_uchar.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fcls_uchar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fcls_uchar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_uchar.c?ref=8a6b509ea857a07be12738d10403d3ab0f647ffe", "patch": "@@ -0,0 +1,40 @@\n+/* Area:\tclosure_call\n+   Purpose:\tCheck return value uchar.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\t<andreast@gcc.gnu.org> 20030828\t */\n+\n+/* { dg-do run } */\n+#include \"ffitest.h\"\n+\n+static void cls_ret_uchar_fn(ffi_cif* cif,void* resp,void** args,\n+\t\t\t     void* userdata)\n+{\n+  *(ffi_arg*)resp = *(unsigned char *)args[0];\n+  printf(\"%d: %d\\n\",*(unsigned char *)args[0], \n+\t *(ffi_arg*)resp);\n+}\n+typedef unsigned char (*cls_ret_uchar)(unsigned char);\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  static ffi_closure cl;\n+  ffi_closure *pcl = &cl;\n+  ffi_type * cl_arg_types[2];\n+  \n+  \n+  cl_arg_types[0] = &ffi_type_uchar;\n+  cl_arg_types[1] = NULL;\n+  \n+  /* Initialize the cif */\n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,\n+\t\t     &ffi_type_uchar, cl_arg_types) == FFI_OK);\n+  \n+  CHECK(ffi_prep_closure(pcl, &cif, cls_ret_uchar_fn, NULL)  == FFI_OK);\n+  \n+  (*((cls_ret_uchar)pcl))(127);\n+  /* { dg-output \"127: 127\" } */\n+\n+  exit(0);  \n+}"}, {"sha": "0a77aa8c970e9f2d547efcac99c50974412714f6", "filename": "libffi/testsuite/libffi.call/cls_uint.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fcls_uint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fcls_uint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_uint.c?ref=8a6b509ea857a07be12738d10403d3ab0f647ffe", "patch": "@@ -0,0 +1,41 @@\n+/* Area:\tclosure_call\n+   Purpose:\tCheck return value uint.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\t<andreast@gcc.gnu.org> 20030828\t */\n+\n+/* { dg-do run } */\n+#include \"ffitest.h\"\n+\n+static void cls_ret_uint_fn(ffi_cif* cif,void* resp,void** args,\n+\t\t\t     void* userdata)\n+ {\n+   *(unsigned int*)resp = *(unsigned int *)args[0];\n+   \n+   printf(\"%d: %d\\n\",*(unsigned int *)args[0], \n+\t  *(unsigned int *)resp);\n+ }\n+typedef unsigned int (*cls_ret_uint)(unsigned int);\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  static ffi_closure cl;\n+  ffi_closure *pcl = &cl;\n+  ffi_type * cl_arg_types[2];\n+  \n+  \n+  cl_arg_types[0] = &ffi_type_uint32;\n+  cl_arg_types[1] = NULL;\n+  \n+  /* Initialize the cif */\n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,\n+\t\t     &ffi_type_uint32, cl_arg_types) == FFI_OK);\n+  \n+  CHECK(ffi_prep_closure(pcl, &cif, cls_ret_uint_fn, NULL)  == FFI_OK);\n+  \n+  (*((cls_ret_uint)pcl))(2147483647);\n+  /* { dg-output \"2147483647: 2147483647\" } */\n+\n+  exit(0);  \n+}"}, {"sha": "90f2ce229f19b418beb7c3f415ac82bddeb4ac94", "filename": "libffi/testsuite/libffi.call/cls_ulonglong.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fcls_ulonglong.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fcls_ulonglong.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_ulonglong.c?ref=8a6b509ea857a07be12738d10403d3ab0f647ffe", "patch": "@@ -0,0 +1,40 @@\n+/* Area:\tclosure_call\n+   Purpose:\tCheck return value long long.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\t<andreast@gcc.gnu.org> 20030828\t */\n+\n+/* { dg-do run } */\n+#include \"ffitest.h\"\n+\n+static void cls_ret_ulonglong_fn(ffi_cif* cif,void* resp,void** args,\n+\t\t\t     void* userdata)\n+ {\n+   *(unsigned long long *)resp=  *(unsigned long long *)args[0];\n+  \n+   printf(\"%llu: %llu\\n\",*(unsigned long long *)args[0], \n+\t  *(unsigned long long *)resp);\n+ }\n+typedef unsigned long long (*cls_ret_ulonglong)(unsigned long long);\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  static ffi_closure cl;\n+  ffi_closure *pcl = &cl;\n+  ffi_type * cl_arg_types[2];\n+  \n+  cl_arg_types[0] = &ffi_type_uint64;\n+  cl_arg_types[1] = NULL;\n+  \n+  /* Initialize the cif */\n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,\n+\t\t     &ffi_type_uint64, cl_arg_types) == FFI_OK);\n+  CHECK(ffi_prep_closure(pcl, &cif, cls_ret_ulonglong_fn, NULL)  == FFI_OK);\n+  (*((cls_ret_ulonglong)pcl))(214LL);\n+  /* { dg-output \"214: 214\" } */\n+  (*((cls_ret_ulonglong)pcl))(9223372035854775808LL);\n+  /* { dg-output \"\\n9223372035854775808: 9223372035854775808\" } */\n+  \n+  exit(0);  \n+}"}, {"sha": "5e89ee9cd2899e0abc5532ff5af00ba48a7fa5c9", "filename": "libffi/testsuite/libffi.call/cls_ushort.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fcls_ushort.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fcls_ushort.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_ushort.c?ref=8a6b509ea857a07be12738d10403d3ab0f647ffe", "patch": "@@ -0,0 +1,41 @@\n+/* Area:\tclosure_call\n+   Purpose:\tCheck return value ushort.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\t<andreast@gcc.gnu.org> 20030828\t */\n+\n+/* { dg-do run } */\n+#include \"ffitest.h\"\n+\n+static void cls_ret_ushort_fn(ffi_cif* cif,void* resp,void** args,\n+\t\t\t     void* userdata)\n+ {\n+   *(ffi_arg*)resp = *(unsigned short *)args[0];\n+   \n+   printf(\"%d: %d\\n\",*(unsigned short *)args[0], \n+\t  *(ffi_arg*)resp);\n+ }\n+typedef unsigned short (*cls_ret_ushort)(unsigned short);\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  static ffi_closure cl;\n+  ffi_closure *pcl = &cl;\n+  ffi_type * cl_arg_types[2];\n+  \n+  \n+  cl_arg_types[0] = &ffi_type_ushort;\n+  cl_arg_types[1] = NULL;\n+  \n+  /* Initialize the cif */\n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,\n+\t\t     &ffi_type_ushort, cl_arg_types) == FFI_OK);\n+  \n+  CHECK(ffi_prep_closure(pcl, &cif, cls_ret_ushort_fn, NULL)  == FFI_OK);\n+  \n+  (*((cls_ret_ushort)pcl))(65535);\n+  /* { dg-output \"65535: 65535\" } */\n+\n+  exit(0);  \n+}"}, {"sha": "7856405d2f5f3d3e2b984576778d1c8813a23c0f", "filename": "libffi/testsuite/libffi.call/ffitest.h", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fffitest.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fffitest.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fffitest.h?ref=8a6b509ea857a07be12738d10403d3ab0f647ffe", "patch": "@@ -0,0 +1,9 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <string.h>\n+#include <ffi.h>\n+\n+#define MAX_ARGS 256\n+\n+#define CHECK(x) !(x) ? abort() : 0 \n+"}, {"sha": "e5ee05b1464692014723b4acd1618c59bbe794cf", "filename": "libffi/testsuite/libffi.call/float.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Ffloat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Ffloat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Ffloat.c?ref=8a6b509ea857a07be12738d10403d3ab0f647ffe", "patch": "@@ -0,0 +1,65 @@\n+/* Area:\tffi_call\n+   Purpose:\tCheck return value float.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\tFrom the original ffitest.c  */\n+\n+/* { dg-do run } */\n+#include \"ffitest.h\"\n+\n+static int floating(int a, float b, double c, long double d, int e)\n+{\n+  int i;\n+\n+  i = (int) ((float)a/b + ((float)c/(float)d));\n+\n+  return i;\n+}\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  ffi_type *args[MAX_ARGS];\n+  void *values[MAX_ARGS];\n+  ffi_arg rint;\n+\n+  float f;\n+  signed int si1;\n+  double d;\n+  long double ld;\n+  signed int si2;\n+  \n+\n+\n+  args[0] = &ffi_type_sint;\n+  values[0] = &si1;\n+  args[1] = &ffi_type_float;\n+  values[1] = &f;\n+  args[2] = &ffi_type_double;\n+  values[2] = &d;\n+  args[3] = &ffi_type_longdouble;\n+  values[3] = &ld;\n+  args[4] = &ffi_type_sint;\n+  values[4] = &si2;\n+    \n+  /* Initialize the cif */\n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 5,\n+\t\t     &ffi_type_sint, args) == FFI_OK);\n+\n+  si1 = 6;\n+  f = 3.14159;\n+  d = (double)1.0/(double)3.0;\n+  ld = 2.71828182846L;\n+  si2 = 10;\n+  \n+  floating (si1, f, d, ld, si2);\n+  \n+  ffi_call(&cif, FFI_FN(floating), &rint, values);\n+  \n+  printf (\"%d vs %d\\n\", (int)rint, floating (si1, f, d, ld, si2));\n+  \n+  CHECK(rint == floating(si1, f, d, ld, si2));\n+  \n+  exit (0);\n+}\n+  "}, {"sha": "94636a230ed89b40643cdc73d9d098a8b3fb0618", "filename": "libffi/testsuite/libffi.call/float1.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Ffloat1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Ffloat1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Ffloat1.c?ref=8a6b509ea857a07be12738d10403d3ab0f647ffe", "patch": "@@ -0,0 +1,42 @@\n+/* Area:\tffi_call\n+   Purpose:\tCheck return value double.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\tFrom the original ffitest.c  */\n+\n+/* { dg-do run } */\n+#include \"ffitest.h\"\n+#include \"float.h\"\n+\n+static double dblit(float f)\n+{\n+  return f/3.0;\n+}\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  ffi_type *args[MAX_ARGS];\n+  void *values[MAX_ARGS];\n+  float f;\n+  double d;\n+\n+\n+  args[0] = &ffi_type_float;\n+  values[0] = &f;\n+  \n+  /* Initialize the cif */\n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, \n+\t\t     &ffi_type_double, args) == FFI_OK);\n+  \n+  f = 3.14159;\n+  \n+  ffi_call(&cif, FFI_FN(dblit), &d, values);\n+  \n+  /* These are not always the same!! Check for a reasonable delta */\n+ \n+  CHECK(d - dblit(f) < DBL_EPSILON);\n+\n+  exit(0);\n+\n+}"}, {"sha": "413521280a334cb62115ba7a8896d316ba4b49ec", "filename": "libffi/testsuite/libffi.call/float2.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Ffloat2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Ffloat2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Ffloat2.c?ref=8a6b509ea857a07be12738d10403d3ab0f647ffe", "patch": "@@ -0,0 +1,58 @@\n+/* Area:\tffi_call\n+   Purpose:\tCheck return value long double.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\tFrom the original ffitest.c  */\n+\n+/* { dg-do run } */\n+#include \"ffitest.h\"\n+#include \"float.h\"\n+\n+static long double ldblit(float f)\n+{\n+  return (long double) (((long double) f)/ (long double) 3.0);\n+}\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  ffi_type *args[MAX_ARGS];\n+  void *values[MAX_ARGS];\n+  float f;\n+  long double ld;\n+\n+  args[0] = &ffi_type_float;\n+  values[0] = &f;\n+  \n+  /* Initialize the cif */\n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, \n+\t\t     &ffi_type_longdouble, args) == FFI_OK);\n+  \n+  f = 3.14159;\n+  \n+#if 1 \n+  /* This is ifdef'd out for now. long double support under SunOS/gcc\n+     is pretty much non-existent.  You'll get the odd bus error in library\n+     routines like printf().  */\n+  printf (\"%Lf\\n\", ldblit(f));\n+#endif\n+  ld = 666;\n+  ffi_call(&cif, FFI_FN(ldblit), &ld, values);\n+  \n+#if 1 \n+  /* This is ifdef'd out for now. long double support under SunOS/gcc\n+     is pretty much non-existent.  You'll get the odd bus error in library\n+     routines like printf().  */\n+  printf (\"%Lf, %Lf, %Lf, %Lf\\n\", ld, ldblit(f), ld - ldblit(f), LDBL_EPSILON);\n+#endif\n+  \n+  /* These are not always the same!! Check for a reasonable delta */\n+  /*@-realcompare@*/\n+  if (ld - ldblit(f) < LDBL_EPSILON)\n+    /*@=realcompare@*/\n+    puts(\"long double return value tests ok!\");\n+  else\n+    CHECK(0);\n+\n+  exit(0);\n+}"}, {"sha": "4869ba9dde077da9bfee8d5607e4ee7727744947", "filename": "libffi/testsuite/libffi.call/many.c", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fmany.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fmany.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fmany.c?ref=8a6b509ea857a07be12738d10403d3ab0f647ffe", "patch": "@@ -0,0 +1,69 @@\n+/* Area:\tffi_call\n+   Purpose:\tCheck return value float, with many arguments\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\tFrom the original ffitest.c  */\n+\n+/* { dg-do run } */\n+#include \"ffitest.h\"\n+\n+#include <float.h>\n+\n+static float many(float f1,\n+\t\t  float f2,\n+\t\t  float f3,\n+\t\t  float f4,\n+\t\t  float f5,\n+\t\t  float f6,\n+\t\t  float f7,\n+\t\t  float f8,\n+\t\t  float f9,\n+\t\t  float f10,\n+\t\t  float f11,\n+\t\t  float f12,\n+\t\t  float f13)\n+{\n+#if 0\n+  printf(\"%f %f %f %f %f %f %f %f %f %f %f %f %f\\n\",\n+\t (double) f1, (double) f2, (double) f3, (double) f4, (double) f5, \n+\t (double) f6, (double) f7, (double) f8, (double) f9, (double) f10,\n+\t (double) f11, (double) f12, (double) f13);\n+#endif\n+\n+  return ((f1/f2+f3/f4+f5/f6+f7/f8+f9/f10+f11/f12) * f13);\n+}\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  ffi_type *args[13];\n+  void *values[13];\n+  float fa[13];\n+  float f, ff;\n+  int i;\n+\n+  for (i = 0; i < 13; i++)\n+    {\n+      args[i] = &ffi_type_float;\n+      values[i] = &fa[i];\n+      fa[i] = (float) i;\n+    }\n+\n+    /* Initialize the cif */\n+    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 13, \n+\t\t       &ffi_type_float, args) == FFI_OK);\n+\n+    ffi_call(&cif, FFI_FN(many), &f, values);\n+\n+    ff =  many(fa[0], fa[1],\n+\t       fa[2], fa[3],\n+\t       fa[4], fa[5],\n+\t       fa[6], fa[7],\n+\t       fa[8], fa[9],\n+\t       fa[10],fa[11],fa[12]);\n+\n+    if (f - ff < FLT_EPSILON)\n+      exit(0);\n+    else\n+      abort();\n+}"}, {"sha": "79be6d632dd9632b3219149426b06eaebcec4ddd", "filename": "libffi/testsuite/libffi.call/many_win32.c", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fmany_win32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fmany_win32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fmany_win32.c?ref=8a6b509ea857a07be12738d10403d3ab0f647ffe", "patch": "@@ -0,0 +1,62 @@\n+/* Area:\tffi_call\n+   Purpose:\tCheck stdcall many call on X86_WIN32 systems.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\tFrom the original ffitest.c  */\n+\n+/* { dg-do run { target i?86-*-cygwin* i?86-*-mingw* } } */\n+\n+#include \"ffitest.h\"\n+\n+static float __attribute__((stdcall)) stdcall_many(float f1,\n+\t\t\t\t\t\t   float f2,\n+\t\t\t\t\t\t   float f3,\n+\t\t\t\t\t\t   float f4,\n+\t\t\t\t\t\t   float f5,\n+\t\t\t\t\t\t   float f6,\n+\t\t\t\t\t\t   float f7,\n+\t\t\t\t\t\t   float f8,\n+\t\t\t\t\t\t   float f9,\n+\t\t\t\t\t\t   float f10,\n+\t\t\t\t\t\t   float f11,\n+\t\t\t\t\t\t   float f12,\n+\t\t\t\t\t\t   float f13)\n+{\n+  return ((f1/f2+f3/f4+f5/f6+f7/f8+f9/f10+f11/f12) * f13);\n+}\n+\n+int main (void) \n+{\n+  ffi_cif cif;\n+  ffi_type *args[13];\n+  void *values[13];\n+  float fa[13];\n+  float f, ff;\n+  int i;\n+  \n+  for (ul = 0; ul < 13; ul++)\n+    {\n+      args[ul] = &ffi_type_float;\n+      values[ul] = &fa[ul];\n+\tfa[ul] = (float) ul;\n+    }\n+  \n+  /* Initialize the cif */\n+  CHECK(ffi_prep_cif(&cif, FFI_STDCALL, 13,\n+\t\t     &ffi_type_float, args) == FFI_OK);\n+  \n+  ff =  stdcall_many(fa[0], fa[1],\t\n+\t\t     fa[2], fa[3],\t\n+\t\t     fa[4], fa[5],\t\n+\t\t     fa[6], fa[7],\n+\t\t     fa[8], fa[9],\t\t\t\n+\t\t     fa[10], fa[11], fa[12]);\n+\n+  ffi_call(&cif, FFI_FN(stdcall_many), &f, values);\n+  \n+  if (f - ff < FLT_EPSILON)\n+    printf(\"stdcall many arg tests ok!\\n\");\n+  else\n+    CHECK(0);\t\n+  exit(0);\t\n+}"}, {"sha": "cfbc3d225c92cc57e2281a28791921a536c658d1", "filename": "libffi/testsuite/libffi.call/nested_struct.c", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct.c?ref=8a6b509ea857a07be12738d10403d3ab0f647ffe", "patch": "@@ -0,0 +1,151 @@\n+/* Area:\tffi_call, closure_call\n+   Purpose:\tCheck structure passing with different structure size.\n+\t\tContains structs as parameter of the struct itself.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\t<andreast@gcc.gnu.org> 20030828\t */\n+\n+/* { dg-do run } */\n+#include \"ffitest.h\"\n+\n+typedef struct cls_struct_16byte1 {\n+  double a;\n+  float b;\n+  int c;\n+} cls_struct_16byte1;\n+\n+typedef struct cls_struct_16byte2 {\n+  int ii;\n+  double dd;\n+  float ff;\n+} cls_struct_16byte2;\n+\n+typedef struct cls_struct_combined {\n+  cls_struct_16byte1 d;\n+  cls_struct_16byte2 e;\n+} cls_struct_combined;\n+\n+cls_struct_combined cls_struct_combined_fn(struct cls_struct_16byte1 b0,\n+\t\t\t    struct cls_struct_16byte2 b1,\n+\t\t\t    struct cls_struct_combined b2)\n+{\n+  struct cls_struct_combined result;\n+\n+  result.d.a = b0.a + b1.dd + b2.d.a;\n+  result.d.b = b0.b + b1.ff + b2.d.b;\n+  result.d.c = b0.c + b1.ii + b2.d.c;\n+  result.e.ii = b0.c + b1.ii + b2.e.ii;\n+  result.e.dd = b0.a + b1.dd + b2.e.dd;\n+  result.e.ff = b0.b + b1.ff + b2.e.ff;\n+\n+  printf(\"%g %g %d %d %g %g %g %g %d %d %g %g: %g %g %d %d %g %g\\n\", \n+\t b0.a, b0.b, b0.c,\n+\t b1.ii, b1.dd, b1.ff,\n+\t b2.d.a, b2.d.b, b2.d.c,\n+\t b2.e.ii, b2.e.dd, b2.e.ff, \n+\t result.d.a, result.d.b, result.d.c,\n+\t result.e.ii, result.e.dd, result.e.ff);\n+\n+  return result;\n+}\n+\n+static void \n+cls_struct_combined_gn(ffi_cif* cif, void* resp, void** args, void* userdata)\n+{   \n+  struct cls_struct_16byte1 b0;\n+  struct cls_struct_16byte2 b1;\n+  struct cls_struct_combined b2;\n+  \n+  b0 = *(struct cls_struct_16byte1*)(args[0]);\n+  b1 = *(struct cls_struct_16byte2*)(args[1]);\n+  b2 = *(struct cls_struct_combined*)(args[2]);\n+\n+  \n+  *(cls_struct_combined*)resp = cls_struct_combined_fn(b0, b1, b2);\n+}\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  static ffi_closure cl;\n+  ffi_closure *pcl = &cl;\n+  void* args_dbl[5];\n+  ffi_type* cls_struct_fields[5];\n+  ffi_type* cls_struct_fields1[5];\n+  ffi_type* cls_struct_fields2[5];\n+  ffi_type cls_struct_type, cls_struct_type1, cls_struct_type2;\n+  ffi_type* dbl_arg_types[5];\n+  \n+  cls_struct_type.size = 0;\n+  cls_struct_type.alignment = 0;\n+  cls_struct_type.type = FFI_TYPE_STRUCT;\n+  cls_struct_type.elements = cls_struct_fields;\n+\n+  cls_struct_type1.size = 0;\n+  cls_struct_type1.alignment = 0;\n+  cls_struct_type1.type = FFI_TYPE_STRUCT;\n+  cls_struct_type1.elements = cls_struct_fields1;\n+  \n+  cls_struct_type2.size = 0;\n+  cls_struct_type2.alignment = 0;\n+  cls_struct_type2.type = FFI_TYPE_STRUCT;\n+  cls_struct_type2.elements = cls_struct_fields2;\n+  \n+  struct cls_struct_16byte1 e_dbl = { 9.0, 2.0, 6};\n+  struct cls_struct_16byte2 f_dbl = { 1, 2.0, 3.0};\n+  struct cls_struct_combined g_dbl = {{4.0, 5.0, 6}, \n+\t\t\t\t      {3, 1.0, 8.0}};\n+  struct cls_struct_combined res_dbl;\n+    \n+  cls_struct_fields[0] = &ffi_type_double;\n+  cls_struct_fields[1] = &ffi_type_float;\n+  cls_struct_fields[2] = &ffi_type_uint32;\n+  cls_struct_fields[3] = NULL;\n+\n+  cls_struct_fields1[0] = &ffi_type_uint32;\n+  cls_struct_fields1[1] = &ffi_type_double;\n+  cls_struct_fields1[2] = &ffi_type_float;\n+  cls_struct_fields1[3] = NULL;\n+\n+  cls_struct_fields2[0] = &cls_struct_type;\n+  cls_struct_fields2[1] = &cls_struct_type1;\n+  cls_struct_fields2[2] = NULL;\n+  \n+  \n+  dbl_arg_types[0] = &cls_struct_type;\n+  dbl_arg_types[1] = &cls_struct_type1;\n+  dbl_arg_types[2] = &cls_struct_type2;\n+  dbl_arg_types[3] = NULL;\n+  \n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 3, &cls_struct_type2, \n+\t\t     dbl_arg_types) == FFI_OK);\n+\n+  args_dbl[0] = &e_dbl;\n+  args_dbl[1] = &f_dbl;\n+  args_dbl[2] = &g_dbl;\n+  args_dbl[3] = NULL;\n+\n+  ffi_call(&cif, FFI_FN(cls_struct_combined_fn), &res_dbl, args_dbl);\n+  /* { dg-output \"9 2 6 1 2 3 4 5 6 3 1 8: 15 10 13 10 12 13\" } */\n+  CHECK( res_dbl.d.a == (e_dbl.a + f_dbl.dd + g_dbl.d.a));\n+  CHECK( res_dbl.d.b == (e_dbl.b + f_dbl.ff + g_dbl.d.b));\n+  CHECK( res_dbl.d.c == (e_dbl.c + f_dbl.ii + g_dbl.d.c));\n+  CHECK( res_dbl.e.ii == (e_dbl.c + f_dbl.ii + g_dbl.e.ii));\n+  CHECK( res_dbl.e.dd == (e_dbl.a + f_dbl.dd + g_dbl.e.dd));\n+  CHECK( res_dbl.e.ff == (e_dbl.b + f_dbl.ff + g_dbl.e.ff));\n+\n+  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_combined_gn, NULL) == FFI_OK);\n+  \n+  res_dbl = ((cls_struct_combined(*)(cls_struct_16byte1, \n+\t\t\t\t     cls_struct_16byte2,\n+\t\t\t\t     cls_struct_combined))\n+\t     (pcl))(e_dbl, f_dbl, g_dbl);\n+  /* { dg-output \"\\n9 2 6 1 2 3 4 5 6 3 1 8: 15 10 13 10 12 13\" } */\n+  CHECK( res_dbl.d.a == (e_dbl.a + f_dbl.dd + g_dbl.d.a));\n+  CHECK( res_dbl.d.b == (e_dbl.b + f_dbl.ff + g_dbl.d.b));\n+  CHECK( res_dbl.d.c == (e_dbl.c + f_dbl.ii + g_dbl.d.c));\n+  CHECK( res_dbl.e.ii == (e_dbl.c + f_dbl.ii + g_dbl.e.ii));\n+  CHECK( res_dbl.e.dd == (e_dbl.a + f_dbl.dd + g_dbl.e.dd));\n+  CHECK( res_dbl.e.ff == (e_dbl.b + f_dbl.ff + g_dbl.e.ff));\n+  exit(0);\n+}   "}, {"sha": "2524c308745f432981272e4b9bb01b0d4497a243", "filename": "libffi/testsuite/libffi.call/nested_struct1.c", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct1.c?ref=8a6b509ea857a07be12738d10403d3ab0f647ffe", "patch": "@@ -0,0 +1,160 @@\n+/* Area:\tffi_call, closure_call\n+   Purpose:\tCheck structure passing with different structure size.\n+\t\tContains structs as parameter of the struct itself.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\t<andreast@gcc.gnu.org> 20030828\t */\n+\n+/* { dg-do run } */\n+#include \"ffitest.h\"\n+\n+typedef struct cls_struct_16byte1 {\n+  double a;\n+  float b;\n+  int c;\n+} cls_struct_16byte1;\n+\n+typedef struct cls_struct_16byte2 {\n+  int ii;\n+  double dd;\n+  float ff;\n+} cls_struct_16byte2;\n+\n+typedef struct cls_struct_combined {\n+  cls_struct_16byte1 d;\n+  cls_struct_16byte2 e;\n+} cls_struct_combined;\n+\n+cls_struct_combined cls_struct_combined_fn(struct cls_struct_16byte1 b0,\n+\t\t\t\t\t   struct cls_struct_16byte2 b1,\n+\t\t\t\t\t   struct cls_struct_combined b2,\n+\t\t\t\t\t   struct cls_struct_16byte1 b3)\n+{\n+  struct cls_struct_combined result;\n+\n+  result.d.a = b0.a + b1.dd + b2.d.a;\n+  result.d.b = b0.b + b1.ff + b2.d.b;\n+  result.d.c = b0.c + b1.ii + b2.d.c;\n+  result.e.ii = b0.c + b1.ii + b2.e.ii;\n+  result.e.dd = b0.a + b1.dd + b2.e.dd;\n+  result.e.ff = b0.b + b1.ff + b2.e.ff;\n+\n+  printf(\"%g %g %d %d %g %g %g %g %d %d %g %g %g %g %d: %g %g %d %d %g %g\\n\", \n+\t b0.a, b0.b, b0.c,\n+\t b1.ii, b1.dd, b1.ff,\n+\t b2.d.a, b2.d.b, b2.d.c,\n+\t b2.e.ii, b2.e.dd, b2.e.ff,\n+\t b3.a, b3.b, b3.c,\n+\t result.d.a, result.d.b, result.d.c,\n+\t result.e.ii, result.e.dd, result.e.ff);\n+\n+  return result;\n+}\n+\n+static void \n+cls_struct_combined_gn(ffi_cif* cif, void* resp, void** args, void* userdata)\n+{   \n+  struct cls_struct_16byte1 b0;\n+  struct cls_struct_16byte2 b1;\n+  struct cls_struct_combined b2;\n+  struct cls_struct_16byte1 b3;\n+  \n+  b0 = *(struct cls_struct_16byte1*)(args[0]);\n+  b1 = *(struct cls_struct_16byte2*)(args[1]);\n+  b2 = *(struct cls_struct_combined*)(args[2]);\n+  b3 = *(struct cls_struct_16byte1*)(args[3]);\n+\n+  \n+  *(cls_struct_combined*)resp = cls_struct_combined_fn(b0, b1, b2, b3);\n+}\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  static ffi_closure cl;\n+  ffi_closure *pcl = &cl;\n+  void* args_dbl[5];\n+  ffi_type* cls_struct_fields[5];\n+  ffi_type* cls_struct_fields1[5];\n+  ffi_type* cls_struct_fields2[5];\n+  ffi_type cls_struct_type, cls_struct_type1, cls_struct_type2;\n+  ffi_type* dbl_arg_types[5];\n+  \n+  cls_struct_type.size = 0;\n+  cls_struct_type.alignment = 0;\n+  cls_struct_type.type = FFI_TYPE_STRUCT;\n+  cls_struct_type.elements = cls_struct_fields;\n+\n+  cls_struct_type1.size = 0;\n+  cls_struct_type1.alignment = 0;\n+  cls_struct_type1.type = FFI_TYPE_STRUCT;\n+  cls_struct_type1.elements = cls_struct_fields1;\n+  \n+  cls_struct_type2.size = 0;\n+  cls_struct_type2.alignment = 0;\n+  cls_struct_type2.type = FFI_TYPE_STRUCT;\n+  cls_struct_type2.elements = cls_struct_fields2;\n+  \n+  struct cls_struct_16byte1 e_dbl = { 9.0, 2.0, 6};\n+  struct cls_struct_16byte2 f_dbl = { 1, 2.0, 3.0};\n+  struct cls_struct_combined g_dbl = {{4.0, 5.0, 6}, \n+\t\t\t\t      {3, 1.0, 8.0}};\n+  struct cls_struct_16byte1 h_dbl = { 3.0, 2.0, 4};\n+  struct cls_struct_combined res_dbl;\n+    \n+  cls_struct_fields[0] = &ffi_type_double;\n+  cls_struct_fields[1] = &ffi_type_float;\n+  cls_struct_fields[2] = &ffi_type_uint32;\n+  cls_struct_fields[3] = NULL;\n+\n+  cls_struct_fields1[0] = &ffi_type_uint32;\n+  cls_struct_fields1[1] = &ffi_type_double;\n+  cls_struct_fields1[2] = &ffi_type_float;\n+  cls_struct_fields1[3] = NULL;\n+\n+  cls_struct_fields2[0] = &cls_struct_type;\n+  cls_struct_fields2[1] = &cls_struct_type1;\n+  cls_struct_fields2[2] = NULL;\n+  \n+  \n+  dbl_arg_types[0] = &cls_struct_type;\n+  dbl_arg_types[1] = &cls_struct_type1;\n+  dbl_arg_types[2] = &cls_struct_type2;\n+  dbl_arg_types[3] = &cls_struct_type;\n+  dbl_arg_types[4] = NULL;\n+  \n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 4, &cls_struct_type2, \n+\t\t     dbl_arg_types) == FFI_OK);\n+\n+  args_dbl[0] = &e_dbl;\n+  args_dbl[1] = &f_dbl;\n+  args_dbl[2] = &g_dbl;\n+  args_dbl[3] = &h_dbl;\n+  args_dbl[4] = NULL;\n+\n+  ffi_call(&cif, FFI_FN(cls_struct_combined_fn), &res_dbl, args_dbl);\n+  /* { dg-output \"9 2 6 1 2 3 4 5 6 3 1 8 3 2 4: 15 10 13 10 12 13\" } */\n+  CHECK( res_dbl.d.a == (e_dbl.a + f_dbl.dd + g_dbl.d.a));\n+  CHECK( res_dbl.d.b == (e_dbl.b + f_dbl.ff + g_dbl.d.b));\n+  CHECK( res_dbl.d.c == (e_dbl.c + f_dbl.ii + g_dbl.d.c));\n+  CHECK( res_dbl.e.ii == (e_dbl.c + f_dbl.ii + g_dbl.e.ii));\n+  CHECK( res_dbl.e.dd == (e_dbl.a + f_dbl.dd + g_dbl.e.dd));\n+  CHECK( res_dbl.e.ff == (e_dbl.b + f_dbl.ff + g_dbl.e.ff));\n+\n+  CHECK(ffi_prep_closure(pcl, &cif, cls_struct_combined_gn, NULL) == FFI_OK);\n+  \n+  res_dbl = ((cls_struct_combined(*)(cls_struct_16byte1, \n+\t\t\t\t     cls_struct_16byte2,\n+\t\t\t\t     cls_struct_combined,\n+\t\t\t\t     cls_struct_16byte1))\n+\t     (pcl))(e_dbl, f_dbl, g_dbl, h_dbl);\n+  /* { dg-output \"\\n9 2 6 1 2 3 4 5 6 3 1 8 3 2 4: 15 10 13 10 12 13\" } */\n+  CHECK( res_dbl.d.a == (e_dbl.a + f_dbl.dd + g_dbl.d.a));\n+  CHECK( res_dbl.d.b == (e_dbl.b + f_dbl.ff + g_dbl.d.b));\n+  CHECK( res_dbl.d.c == (e_dbl.c + f_dbl.ii + g_dbl.d.c));\n+  CHECK( res_dbl.e.ii == (e_dbl.c + f_dbl.ii + g_dbl.e.ii));\n+  CHECK( res_dbl.e.dd == (e_dbl.a + f_dbl.dd + g_dbl.e.dd));\n+  CHECK( res_dbl.e.ff == (e_dbl.b + f_dbl.ff + g_dbl.e.ff));\n+  //  CHECK( 1 == 0);\n+  exit(0);\n+}   "}, {"sha": "6088be585c11414aba208d29e37caad7ebba5ef3", "filename": "libffi/testsuite/libffi.call/problem1.c", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fproblem1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fproblem1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fproblem1.c?ref=8a6b509ea857a07be12738d10403d3ab0f647ffe", "patch": "@@ -0,0 +1,93 @@\n+/* Area:\tffi_call, closure_call\n+   Purpose:\tCheck structure passing with different structure size.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\t<andreast@gcc.gnu.org> 20030828\t */\n+\n+/* { dg-do run } */\n+#include \"ffitest.h\"\n+\n+typedef struct my_ffi_struct {\n+  double a;\n+  double b;\n+  double c;\n+} my_ffi_struct;\n+\n+my_ffi_struct callee(struct my_ffi_struct a1, struct my_ffi_struct a2)\n+{\n+  struct my_ffi_struct result;\n+  result.a = a1.a + a2.a;\n+  result.b = a1.b + a2.b;\n+  result.c = a1.c + a2.c;\n+  \n+\n+  printf(\"%g %g %g %g %g %g: %g %g %g\\n\", a1.a, a1.b, a1.c, \n+\t a2.a, a2.b, a2.c, result.a, result.b, result.c);\n+  \n+  return result;\n+}\n+\n+void stub(ffi_cif* cif, void* resp, void** args, void* userdata)\n+{   \n+    struct my_ffi_struct a1;\n+    struct my_ffi_struct a2;\n+    \n+    a1 = *(struct my_ffi_struct*)(args[0]);\n+    a2 = *(struct my_ffi_struct*)(args[1]);\n+\n+    *(my_ffi_struct *)resp = callee(a1, a2);\n+}\n+\n+\n+int main(void)\n+{\n+    ffi_type* my_ffi_struct_fields[4];\n+    ffi_type my_ffi_struct_type;\n+    ffi_cif cif;\n+    static ffi_closure cl;\n+    ffi_closure *pcl = &cl;\n+    void* args[4];\n+    ffi_type* arg_types[3];\n+    \n+    struct my_ffi_struct g = { 1.0, 2.0, 3.0 };\n+    struct my_ffi_struct f = { 1.0, 2.0, 3.0 };\n+    struct my_ffi_struct res;\n+\n+    my_ffi_struct_type.size = 0;\n+    my_ffi_struct_type.alignment = 0;\n+    my_ffi_struct_type.type = FFI_TYPE_STRUCT;\n+    my_ffi_struct_type.elements = my_ffi_struct_fields;\n+\n+    my_ffi_struct_fields[0] = &ffi_type_double;\n+    my_ffi_struct_fields[1] = &ffi_type_double;\n+    my_ffi_struct_fields[2] = &ffi_type_double;\n+    my_ffi_struct_fields[3] = NULL;\n+\n+    arg_types[0] = &my_ffi_struct_type;\n+    arg_types[1] = &my_ffi_struct_type;\n+    arg_types[2] = NULL;\n+\n+    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &my_ffi_struct_type, \n+\t\t       arg_types) == FFI_OK);\n+\n+    args[0] = &g;\n+    args[1] = &f;\n+    args[2] = NULL;\n+    ffi_call(&cif, FFI_FN(callee), &res, args);\n+    /* { dg-output \"1 2 3 1 2 3: 2 4 6\" } */\n+\n+    CHECK(res.a == 2.0);\n+    CHECK(res.b == 4.0);\n+    CHECK(res.c == 6.0);\n+    \n+    CHECK(ffi_prep_closure(pcl, &cif, stub, NULL) == FFI_OK);\n+ \n+    res = ((my_ffi_struct(*)(struct my_ffi_struct, struct my_ffi_struct))(pcl))(g, f);\n+    /* { dg-output \"\\n1 2 3 1 2 3: 2 4 6\" } */\n+    \n+    CHECK(res.a == 2.0);\n+    CHECK(res.b == 4.0);\n+    CHECK(res.c == 6.0);\n+\n+    exit(0);;\n+} "}, {"sha": "75e842159397f6a796e4878e74004d533bda8e89", "filename": "libffi/testsuite/libffi.call/promotion.c", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fpromotion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fpromotion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fpromotion.c?ref=8a6b509ea857a07be12738d10403d3ab0f647ffe", "patch": "@@ -0,0 +1,59 @@\n+/* Area:\tffi_call\n+   Purpose:\tPromotion test.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\tFrom the original ffitest.c  */\n+\n+/* { dg-do run } */\n+#include \"ffitest.h\"\n+static int promotion(signed char sc, signed short ss, \n+\t\t     unsigned char uc, unsigned short us)\n+{\n+  int r = (int) sc + (int) ss + (int) uc + (int) us;\n+\n+  return r;\n+}\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  ffi_type *args[MAX_ARGS];\n+  void *values[MAX_ARGS];\n+  ffi_arg rint;\n+  signed char sc;\n+  unsigned char uc;\n+  signed short ss;\n+  unsigned short us;\n+  unsigned long ul;\n+\n+  args[0] = &ffi_type_schar;\n+  args[1] = &ffi_type_sshort;\n+  args[2] = &ffi_type_uchar;\n+  args[3] = &ffi_type_ushort;\n+  values[0] = &sc;\n+  values[1] = &ss;\n+  values[2] = &uc;\n+  values[3] = &us;\n+  \n+  /* Initialize the cif */\n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 4, \n+\t\t     &ffi_type_sint, args) == FFI_OK);\n+  \n+  us = 0;\n+  ul = 0;\n+  \n+  for (sc = (signed char) -127; \n+       sc <= (signed char) 120; /*@-type@*/ sc += 1 /*@=type@*/)\n+    for (ss = -30000; ss <= 30000; ss += 10000)\n+      for (uc = (unsigned char) 0; \n+\t   uc <= (unsigned char) 200; /*@-type@*/ uc += 20 /*@=type@*/)\n+\tfor (us = 0; us <= 60000; us += 10000)\n+\t  {\n+\t    ul++;\n+\t    ffi_call(&cif, FFI_FN(promotion), &rint, values);\n+\t    CHECK((int)rint == (signed char) sc + (signed short) ss +\n+\t\t  (unsigned char) uc + (unsigned short) us);\n+\t  }\n+  printf(\"%lu promotion tests run\\n\", ul);\n+  exit(0); \n+}"}, {"sha": "16041ea24f294d65504e72188144c9f31b674c5e", "filename": "libffi/testsuite/libffi.call/pyobjc-tc.c", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fpyobjc-tc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fpyobjc-tc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fpyobjc-tc.c?ref=8a6b509ea857a07be12738d10403d3ab0f647ffe", "patch": "@@ -0,0 +1,114 @@\n+/* Area:\tffi_call\n+   Purpose:\tCheck different structures.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\tRonald Oussoren <oussoren@cistron.nl> 20030824\t*/\n+\n+/* { dg-do run } */\n+#include \"ffitest.h\"\n+\n+typedef struct Point {\n+\tfloat x;\n+\tfloat y;\n+} Point;\n+\n+typedef struct Size {\n+\tfloat h;\n+\tfloat w;\n+} Size;\n+\n+typedef struct Rect {\n+\tPoint o;\n+\tSize  s;\n+} Rect;\n+\n+int doit(int o, char* s, Point p, Rect r, int last)\n+{\n+\tprintf(\"CALLED WITH %d %s {%f %f} {{%f %f} {%f %f}} %d\\n\",\n+\t\to, s, p.x, p.y, r.o.x, r.o.y, r.s.h, r.s.w, last);\n+\treturn 42;\n+}\n+\n+\n+int main(void)\n+{\n+\tffi_type point_type;\n+\tffi_type size_type;\n+\tffi_type rect_type;\n+\tffi_cif cif;\n+\tffi_type* arglist[6];\n+\tvoid* values[6];\n+\tint r;\n+\n+\t/*\n+\t *  First set up FFI types for the 3 struct types\n+\t */\n+\n+\tpoint_type.size = 0; /*sizeof(Point);*/\n+\tpoint_type.alignment = 0; /*__alignof__(Point);*/\n+\tpoint_type.type = FFI_TYPE_STRUCT;\n+\tpoint_type.elements = malloc(3 * sizeof(ffi_type*));\n+\tpoint_type.elements[0] = &ffi_type_float;\n+\tpoint_type.elements[1] = &ffi_type_float;\n+\tpoint_type.elements[2] = NULL;\n+\n+\tsize_type.size = 0;/* sizeof(Size);*/\n+\tsize_type.alignment = 0;/* __alignof__(Size);*/\n+\tsize_type.type = FFI_TYPE_STRUCT;\n+\tsize_type.elements = malloc(3 * sizeof(ffi_type*));\n+\tsize_type.elements[0] = &ffi_type_float;\n+\tsize_type.elements[1] = &ffi_type_float;\n+\tsize_type.elements[2] = NULL;\n+\n+\trect_type.size = 0;/*sizeof(Rect);*/\n+\trect_type.alignment =0;/* __alignof__(Rect);*/\n+\trect_type.type = FFI_TYPE_STRUCT;\n+\trect_type.elements = malloc(3 * sizeof(ffi_type*));\n+\trect_type.elements[0] = &point_type;\n+\trect_type.elements[1] = &size_type;\n+\trect_type.elements[2] = NULL;\n+\n+\t/*\n+\t * Create a CIF \n+\t */\n+\targlist[0] = &ffi_type_sint;\n+\targlist[1] = &ffi_type_pointer;\n+\targlist[2] = &point_type;\n+\targlist[3] = &rect_type;\n+\targlist[4] = &ffi_type_sint;\n+\targlist[5] = NULL;\n+\n+\tr = ffi_prep_cif(&cif, FFI_DEFAULT_ABI,\n+\t\t\t5, &ffi_type_sint, arglist);\n+\tif (r != FFI_OK) {\n+\t\tabort();\n+\t}\n+\n+\n+\t/* And call the function through the CIF */\n+\n+\t{\n+\tPoint p = { 1.0, 2.0 };\n+\tRect  r = { { 9.0, 10.0}, { -1.0, -2.0 } };\n+\tint   o = 0;\n+\tint   l = 42;\n+\tchar* m = \"myMethod\";\n+\tint   result;\n+\n+\tvalues[0] = &o;\n+\tvalues[1] = &m;\n+\tvalues[2] = &p;\n+\tvalues[3] = &r;\n+\tvalues[4] = &l;\n+\tvalues[5] = NULL;\n+\n+\tprintf(\"CALLING WITH %d %s {%f %f} {{%f %f} {%f %f}} %d\\n\",\n+\t\to, m, p.x, p.y, r.o.x, r.o.y, r.s.h, r.s.w, l);\n+\n+\tffi_call(&cif, FFI_FN(doit), &result, values);\n+\n+\tprintf (\"The result is %d\\n\", result);\n+\n+\t}\n+\texit(0);\n+}"}, {"sha": "b95cac4ef02e1bb0a5a35db10898b50f01d557ad", "filename": "libffi/testsuite/libffi.call/return_ll.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Freturn_ll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Freturn_ll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Freturn_ll.c?ref=8a6b509ea857a07be12738d10403d3ab0f647ffe", "patch": "@@ -0,0 +1,45 @@\n+/* Area:\tffi_call\n+   Purpose:\tCheck return value long long.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\tFrom the original ffitest.c  */\n+\n+/* { dg-do run } */\n+#include \"ffitest.h\"\n+static long long return_ll(long long ll)\n+{\n+  return ll;\n+}\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  ffi_type *args[MAX_ARGS];\n+  void *values[MAX_ARGS];\n+  long long rlonglong;\n+  long long ll;\n+  unsigned long ul;\n+  \n+ \n+  args[0] = &ffi_type_sint64;\n+  values[0] = &ll;\n+  \n+  /* Initialize the cif */\n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, \n+\t\t     &ffi_type_sint64, args) == FFI_OK);\n+  \n+  for (ll = 0LL; ll < 100LL; ll++)\n+    {\n+      ul++;\n+      ffi_call(&cif, FFI_FN(return_ll), &rlonglong, values);\n+      CHECK(rlonglong == ll);\n+    }\n+  \n+  for (ll = 55555555555000LL; ll < 55555555555100LL; ll++)\n+    {\n+      ul++;\n+      ffi_call(&cif, FFI_FN(return_ll), &rlonglong, values);\n+      CHECK(rlonglong == ll);\n+    }\n+  exit(0);\n+}"}, {"sha": "6f91ff6b4c595f2945a7b051e2de615e6cb560ba", "filename": "libffi/testsuite/libffi.call/return_sc.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Freturn_sc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Freturn_sc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Freturn_sc.c?ref=8a6b509ea857a07be12738d10403d3ab0f647ffe", "patch": "@@ -0,0 +1,38 @@\n+/* Area:\tffi_call\n+   Purpose:\tCheck return value signed char.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\tFrom the original ffitest.c  */\n+\n+/* { dg-do run } */\n+#include \"ffitest.h\"\n+\n+static signed char return_sc(signed char sc)\n+{\n+  return sc;\n+}\n+int main (void)\n+{\n+  ffi_cif cif;\n+  ffi_type *args[MAX_ARGS];\n+  void *values[MAX_ARGS];\n+  ffi_arg rint;\n+  signed char sc;\n+  unsigned long ul;\n+\n+  args[0] = &ffi_type_schar;\n+  values[0] = &sc;\n+  \n+  /* Initialize the cif */\n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, \n+\t\t     &ffi_type_schar, args) == FFI_OK);\n+  \n+  for (sc = (signed char) -127; \n+       sc < (signed char) 127; sc++)\n+    {\n+      ul++;\n+      ffi_call(&cif, FFI_FN(return_sc), &rint, values);\n+      CHECK(rint == (ffi_arg) sc);\n+    }\n+  exit(0);\n+}"}, {"sha": "c943d4801be048fbb33bc69b77d71c944898aea6", "filename": "libffi/testsuite/libffi.call/return_uc.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Freturn_uc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Freturn_uc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Freturn_uc.c?ref=8a6b509ea857a07be12738d10403d3ab0f647ffe", "patch": "@@ -0,0 +1,40 @@\n+/* Area:\tffi_call\n+   Purpose:\tCheck return value unsigned char.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\tFrom the original ffitest.c  */\n+\n+/* { dg-do run } */\n+#include \"ffitest.h\"\n+\n+static unsigned char return_uc(unsigned char uc)\n+{\n+  return uc;\n+}\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  ffi_type *args[MAX_ARGS];\n+  void *values[MAX_ARGS];\n+  ffi_arg rint;\n+\n+  unsigned char uc;\n+  unsigned long ul;\n+\n+  args[0] = &ffi_type_uchar;\n+  values[0] = &uc;\n+  \n+  /* Initialize the cif */\n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, \n+\t\t     &ffi_type_uchar, args) == FFI_OK);\n+  \n+  for (uc = (unsigned char) '\\x00'; \n+       uc < (unsigned char) '\\xff'; uc++)\n+    {\n+      ul++;\n+      ffi_call(&cif, FFI_FN(return_uc), &rint, values);\n+      CHECK(rint == (signed int) uc);\n+    }\n+  exit(0);\n+}"}, {"sha": "3de45de7aaac6ffdce3c806132ac1a7bccfe4b09", "filename": "libffi/testsuite/libffi.call/strlen.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fstrlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fstrlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fstrlen.c?ref=8a6b509ea857a07be12738d10403d3ab0f647ffe", "patch": "@@ -0,0 +1,44 @@\n+/* Area:\tffi_call\n+   Purpose:\tCheck strlen function call.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\tFrom the original ffitest.c  */\n+\n+/* { dg-do run } */\n+#include \"ffitest.h\"\n+\n+static size_t my_strlen(char *s)\n+{\n+  return (strlen(s));\n+}\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  ffi_type *args[MAX_ARGS];\n+  void *values[MAX_ARGS];\n+  ffi_arg rint;\n+  char *s;\n+\n+  args[0] = &ffi_type_pointer;\n+  values[0] = (void*) &s;\n+  \n+  /* Initialize the cif */\n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, \n+\t\t     &ffi_type_sint, args) == FFI_OK);\n+  \n+  s = \"a\";\n+  ffi_call(&cif, FFI_FN(my_strlen), &rint, values);\n+  CHECK(rint == 1);\n+  \n+  s = \"1234567\";\n+  ffi_call(&cif, FFI_FN(my_strlen), &rint, values);\n+  CHECK(rint == 7);\n+  \n+  s = \"1234567890123456789012345\";\n+  ffi_call(&cif, FFI_FN(my_strlen), &rint, values);\n+  CHECK(rint == 25);\n+  \n+  exit (0);\n+}\n+  "}, {"sha": "6fbcc87400a6c00bc2645342f08d1ab4b22e95cd", "filename": "libffi/testsuite/libffi.call/strlen_win32.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fstrlen_win32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fstrlen_win32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fstrlen_win32.c?ref=8a6b509ea857a07be12738d10403d3ab0f647ffe", "patch": "@@ -0,0 +1,44 @@\n+/* Area:\tffi_call\n+   Purpose:\tCheck stdcall strlen call on X86_WIN32 systems.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\tFrom the original ffitest.c  */\n+\n+/* { dg-do run { target i?86-*-cygwin* i?86-*-mingw* } } */\n+\n+#include \"ffitest.h\"\n+\n+static size_t __attribute__((stdcall)) my_stdcall_strlen(char *s)\n+{\n+  return (strlen(s));\n+}\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  ffi_type *args[MAX_ARGS];\n+  void *values[MAX_ARGS];\n+  ffi_arg rint;\n+  char *s;\n+  args[0] = &ffi_type_pointer;\n+  values[0] = (void*) &s;\n+  \n+  /* Initialize the cif */\n+  CHECK(ffi_prep_cif(&cif, FFI_STDCALL, 1,\n+\t\t       &ffi_type_sint, args) == FFI_OK);\n+  \n+  s = \"a\";\n+  ffi_call(&cif, FFI_FN(my_stdcall_strlen), &rint, values);\n+  CHECK(rint == 1);\n+  \n+  s = \"1234567\";\n+  ffi_call(&cif, FFI_FN(my_stdcall_strlen), &rint, values);\n+  CHECK(rint == 7);\n+  \n+  s = \"1234567890123456789012345\";\n+  ffi_call(&cif, FFI_FN(my_stdcall_strlen), &rint, values);\n+  CHECK(rint == 25);\n+  \n+  printf(\"stdcall strlen tests passed\\n\");\n+  exit(0);\n+}"}, {"sha": "99c5d3b91ac8b2d14f70fc3fbd25cdd81855af01", "filename": "libffi/testsuite/libffi.call/struct1.c", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fstruct1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fstruct1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fstruct1.c?ref=8a6b509ea857a07be12738d10403d3ab0f647ffe", "patch": "@@ -0,0 +1,67 @@\n+/* Area:\tffi_call\n+   Purpose:\tCheck structures.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\tFrom the original ffitest.c  */\n+\n+/* { dg-do run } */\n+#include \"ffitest.h\"\n+\n+typedef struct\n+{\n+  unsigned char uc;\n+  double d;\n+  unsigned int ui;\n+} test_structure_1;\n+\n+static test_structure_1 struct1(test_structure_1 ts)\n+{\n+  /*@-type@*/\n+  ts.uc++;\n+  /*@=type@*/\n+  ts.d--;\n+  ts.ui++;\n+\n+  return ts;\n+}\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  ffi_type *args[MAX_ARGS];\n+  void *values[MAX_ARGS];\n+  ffi_type ts1_type;\n+  ffi_type *ts1_type_elements[4];\n+  ts1_type.size = 0;\n+  ts1_type.alignment = 0;\n+  ts1_type.type = FFI_TYPE_STRUCT;\n+  ts1_type.elements = ts1_type_elements;\n+  ts1_type_elements[0] = &ffi_type_uchar;\n+  ts1_type_elements[1] = &ffi_type_double;\n+  ts1_type_elements[2] = &ffi_type_uint;\n+  ts1_type_elements[3] = NULL;\n+  \n+  test_structure_1 ts1_arg;\n+  /* This is a hack to get a properly aligned result buffer */\n+  test_structure_1 *ts1_result = \n+    (test_structure_1 *) malloc (sizeof(test_structure_1));\n+  \n+  args[0] = &ts1_type;\n+  values[0] = &ts1_arg;\n+  \n+  /* Initialize the cif */\n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, \n+\t\t     &ts1_type, args) == FFI_OK);\n+  \n+  ts1_arg.uc = '\\x01';\n+  ts1_arg.d = 3.14159;\n+  ts1_arg.ui = 555;\n+\n+  ffi_call(&cif, FFI_FN(struct1), ts1_result, values);\n+  \n+  CHECK(ts1_result->ui == 556);\n+  CHECK(ts1_result->d == 3.14159 - 1);\n+ \n+  free (ts1_result);\n+  exit(0);\n+}"}, {"sha": "14bc9fdc6f217b924c5ea78ab2cc905d88dff081", "filename": "libffi/testsuite/libffi.call/struct2.c", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fstruct2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fstruct2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fstruct2.c?ref=8a6b509ea857a07be12738d10403d3ab0f647ffe", "patch": "@@ -0,0 +1,67 @@\n+/* Area:\tffi_call\n+   Purpose:\tCheck structures.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\tFrom the original ffitest.c  */\n+\n+/* { dg-do run } */\n+#include \"ffitest.h\"\n+\n+typedef struct\n+{\n+  double d1;\n+  double d2;\n+} test_structure_2;\n+\n+static test_structure_2 struct2(test_structure_2 ts)\n+{\n+  ts.d1--;\n+  ts.d2--;\n+\n+  return ts;\n+}\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  ffi_type *args[MAX_ARGS];\n+  void *values[MAX_ARGS];\n+  test_structure_2 ts2_arg;\n+  ffi_type ts2_type;\n+  ffi_type *ts2_type_elements[3];\n+  ts2_type.size = 0;\n+  ts2_type.alignment = 0;\n+  ts2_type.type = FFI_TYPE_STRUCT;\n+  ts2_type.elements = ts2_type_elements;\n+  ts2_type_elements[0] = &ffi_type_double;\n+  ts2_type_elements[1] = &ffi_type_double;\n+  ts2_type_elements[2] = NULL;\n+\n+  \n+  /* This is a hack to get a properly aligned result buffer */\n+  test_structure_2 *ts2_result = \n+    (test_structure_2 *) malloc (sizeof(test_structure_2));\n+  \n+  args[0] = &ts2_type;\n+  values[0] = &ts2_arg;\n+  \n+  /* Initialize the cif */\n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, &ts2_type, args) == FFI_OK);\n+  \n+  ts2_arg.d1 = 5.55;\n+  ts2_arg.d2 = 6.66;\n+  \n+  printf (\"%g\\n\", ts2_arg.d1);\n+  printf (\"%g\\n\", ts2_arg.d2);\n+  \n+  ffi_call(&cif, FFI_FN(struct2), ts2_result, values);\n+  \n+  printf (\"%g\\n\", ts2_result->d1);\n+  printf (\"%g\\n\", ts2_result->d2);\n+  \n+  CHECK(ts2_result->d1 == 5.55 - 1);\n+  CHECK(ts2_result->d2 == 6.66 - 1);\n+  \n+  free (ts2_result);\n+  exit(0);\n+}"}, {"sha": "c994b8fa3b21af0d4e78ef57d6189adb406f8691", "filename": "libffi/testsuite/libffi.call/struct3.c", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fstruct3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fstruct3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fstruct3.c?ref=8a6b509ea857a07be12738d10403d3ab0f647ffe", "patch": "@@ -0,0 +1,59 @@\n+/* Area:\tffi_call\n+   Purpose:\tCheck structures.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\tFrom the original ffitest.c  */\n+\n+/* { dg-do run } */\n+#include \"ffitest.h\"\n+\n+typedef struct\n+{\n+  int si;\n+} test_structure_3;\n+\n+static test_structure_3 struct3(test_structure_3 ts)\n+{\n+  ts.si = -(ts.si*2);\n+\n+  return ts;\n+}\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  ffi_type *args[MAX_ARGS];\n+  void *values[MAX_ARGS];\n+  int compare_value;\n+  ffi_type ts3_type;\n+  ffi_type *ts3_type_elements[2];\n+  ts3_type.size = 0;\n+  ts3_type.alignment = 0;\n+  ts3_type.type = FFI_TYPE_STRUCT;\n+  ts3_type.elements = ts3_type_elements;\n+  ts3_type_elements[0] = &ffi_type_sint;\n+  ts3_type_elements[1] = NULL;\n+\n+  test_structure_3 ts3_arg;\n+  test_structure_3 *ts3_result = \n+    (test_structure_3 *) malloc (sizeof(test_structure_3));\n+  \n+  args[0] = &ts3_type;\n+  values[0] = &ts3_arg;\n+  \n+  /* Initialize the cif */\n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, \n+\t\t     &ts3_type, args) == FFI_OK);\n+  \n+  ts3_arg.si = -123;\n+  compare_value = ts3_arg.si;\n+  \n+  ffi_call(&cif, FFI_FN(struct3), ts3_result, values);\n+  \n+  printf (\"%d %d\\n\", ts3_result->si, -(compare_value*2));\n+  \n+  CHECK(ts3_result->si == -(ts3_arg.si*2));\n+ \n+  free (ts3_result);\n+  exit(0);\n+}"}, {"sha": "0ad0a83ba12253b9ff1bc7400c9f53a1b2b29aca", "filename": "libffi/testsuite/libffi.call/struct4.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fstruct4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fstruct4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fstruct4.c?ref=8a6b509ea857a07be12738d10403d3ab0f647ffe", "patch": "@@ -0,0 +1,63 @@\n+/* Area:\tffi_call\n+   Purpose:\tCheck structures.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\tFrom the original ffitest.c  */\n+\n+/* { dg-do run } */\n+#include \"ffitest.h\"\n+\n+typedef struct\n+{\n+  unsigned ui1;\n+  unsigned ui2;\n+  unsigned ui3;\n+} test_structure_4;\n+\n+static test_structure_4 struct4(test_structure_4 ts)\n+{\n+  ts.ui3 = ts.ui1 * ts.ui2 * ts.ui3;\n+\n+  return ts;\n+}\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  ffi_type *args[MAX_ARGS];\n+  void *values[MAX_ARGS];\n+  ffi_type ts4_type;\n+  ffi_type *ts4_type_elements[4];  \n+  ts4_type.size = 0;\n+  ts4_type.alignment = 0;\n+  ts4_type.type = FFI_TYPE_STRUCT;\n+  test_structure_4 ts4_arg;\n+  ts4_type.elements = ts4_type_elements;\n+  ts4_type_elements[0] = &ffi_type_uint;\n+  ts4_type_elements[1] = &ffi_type_uint;\n+  ts4_type_elements[2] = &ffi_type_uint;\n+  ts4_type_elements[3] = NULL;\n+\n+  \n+  /* This is a hack to get a properly aligned result buffer */\n+  test_structure_4 *ts4_result = \n+    (test_structure_4 *) malloc (sizeof(test_structure_4));\n+  \n+  args[0] = &ts4_type;\n+  values[0] = &ts4_arg;\n+  \n+  /* Initialize the cif */\n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, &ts4_type, args) == FFI_OK);\n+  \n+  ts4_arg.ui1 = 2;\n+  ts4_arg.ui2 = 3;\n+  ts4_arg.ui3 = 4;\n+  \n+  ffi_call (&cif, FFI_FN(struct4), ts4_result, values);\n+  \n+  CHECK(ts4_result->ui3 == 2U * 3U * 4U);\n+ \n+  \n+  free (ts4_result);\n+  exit(0);\n+}"}, {"sha": "c03cc97ac990bff32e84adc0d3832284cd8dff2c", "filename": "libffi/testsuite/libffi.call/struct5.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fstruct5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fstruct5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fstruct5.c?ref=8a6b509ea857a07be12738d10403d3ab0f647ffe", "patch": "@@ -0,0 +1,65 @@\n+/* Area:\tffi_call\n+   Purpose:\tCheck structures.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\tFrom the original ffitest.c  */\n+\n+/* { dg-do run } */\n+#include \"ffitest.h\"\n+typedef struct\n+{\n+  char c1;\n+  char c2;\n+} test_structure_5;\n+\n+static test_structure_5 struct5(test_structure_5 ts1, test_structure_5 ts2)\n+{\n+  ts1.c1 += ts2.c1;\n+  ts1.c2 -= ts2.c2;\n+  \n+  return ts1;\n+}\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  ffi_type *args[MAX_ARGS];\n+  void *values[MAX_ARGS];\n+  ffi_type ts5_type;\n+  ffi_type *ts5_type_elements[3];\n+  ts5_type.size = 0;\n+  ts5_type.alignment = 0;\n+  ts5_type.type = FFI_TYPE_STRUCT;\n+  ts5_type.elements = ts5_type_elements;\n+  ts5_type_elements[0] = &ffi_type_schar;\n+  ts5_type_elements[1] = &ffi_type_schar;\n+  ts5_type_elements[2] = NULL;\n+\n+  test_structure_5 ts5_arg1, ts5_arg2;\n+  \n+  /* This is a hack to get a properly aligned result buffer */\n+  test_structure_5 *ts5_result = \n+    (test_structure_5 *) malloc (sizeof(test_structure_5));\n+  \n+  args[0] = &ts5_type;\n+  args[1] = &ts5_type;\n+  values[0] = &ts5_arg1;\n+  values[1] = &ts5_arg2;\n+  \n+  /* Initialize the cif */\n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &ts5_type, args) == FFI_OK);\n+  \n+  ts5_arg1.c1 = 2;\n+  ts5_arg1.c2 = 6;\n+  ts5_arg2.c1 = 5;\n+  ts5_arg2.c2 = 3;\n+  \n+  ffi_call (&cif, FFI_FN(struct5), ts5_result, values);\n+  \n+  CHECK(ts5_result->c1 == 7); \n+  CHECK(ts5_result->c2 == 3);\n+  \n+  \n+  free (ts5_result);\n+  exit(0);\n+}"}, {"sha": "83db9afbbeecf8f8acd05dd61b8ddbeaee6ccacd", "filename": "libffi/testsuite/libffi.call/struct6.c", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fstruct6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fstruct6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fstruct6.c?ref=8a6b509ea857a07be12738d10403d3ab0f647ffe", "patch": "@@ -0,0 +1,64 @@\n+/* Area:\tffi_call\n+   Purpose:\tCheck structures.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\tFrom the original ffitest.c  */\n+\n+/* { dg-do run } */\n+#include \"ffitest.h\"\n+typedef struct\n+{\n+  float f;\n+  double d;\n+} test_structure_6;\n+\n+static test_structure_6 struct6 (test_structure_6 ts)\n+{\n+  ts.f += 1;\n+  ts.d += 1;\n+  \n+  return ts;\n+}\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  ffi_type *args[MAX_ARGS];\n+  void *values[MAX_ARGS];\n+  ffi_type ts6_type;\n+  ffi_type *ts6_type_elements[3];\n+  ts6_type.size = 0;\n+  ts6_type.alignment = 0;\n+  ts6_type.type = FFI_TYPE_STRUCT;\n+  ts6_type.elements = ts6_type_elements;\n+  ts6_type_elements[0] = &ffi_type_float;\n+  ts6_type_elements[1] = &ffi_type_double;\n+  ts6_type_elements[2] = NULL;\n+\n+\n+  test_structure_6 ts6_arg;\n+\n+  /* This is a hack to get a properly aligned result buffer */\n+  test_structure_6 *ts6_result = \n+    (test_structure_6 *) malloc (sizeof(test_structure_6));\n+  \n+  args[0] = &ts6_type;\n+  values[0] = &ts6_arg;\n+\n+  /* Initialize the cif */\n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, &ts6_type, args) == FFI_OK);\n+  \n+  ts6_arg.f = 5.55f;\n+  ts6_arg.d = 6.66;\n+  \n+  printf (\"%g\\n\", ts6_arg.f);\n+  printf (\"%g\\n\", ts6_arg.d);\n+\n+  ffi_call(&cif, FFI_FN(struct6), ts6_result, values);\n+    \n+  CHECK(ts6_result->f == 5.55f + 1);\n+  CHECK(ts6_result->d == 6.66 + 1);\n+    \n+  free (ts6_result);\n+  exit(0);\n+}"}, {"sha": "58aac4c9922e0e82a1c355b0b4ff92b3d93c55a9", "filename": "libffi/testsuite/libffi.call/struct7.c", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fstruct7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fstruct7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fstruct7.c?ref=8a6b509ea857a07be12738d10403d3ab0f647ffe", "patch": "@@ -0,0 +1,74 @@\n+/* Area:\tffi_call\n+   Purpose:\tCheck structures.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\tFrom the original ffitest.c  */\n+\n+/* { dg-do run } */\n+#include \"ffitest.h\"\n+typedef struct\n+{\n+  float f1;\n+  float f2;\n+  double d;\n+} test_structure_7;\n+\n+static test_structure_7 struct7 (test_structure_7 ts)\n+{\n+  ts.f1 += 1;\n+  ts.f2 += 1;\n+  ts.d += 1;\n+\n+  return ts;\n+}\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  ffi_type *args[MAX_ARGS];\n+  void *values[MAX_ARGS];\n+  ffi_type ts7_type;\n+  ffi_type *ts7_type_elements[4];\n+  ts7_type.size = 0;\n+  ts7_type.alignment = 0;\n+  ts7_type.type = FFI_TYPE_STRUCT;\n+  ts7_type.elements = ts7_type_elements;\n+  ts7_type_elements[0] = &ffi_type_float;\n+  ts7_type_elements[1] = &ffi_type_float;\n+  ts7_type_elements[2] = &ffi_type_double;\n+  ts7_type_elements[3] = NULL;\n+\n+\n+  test_structure_7 ts7_arg;\n+  \n+  /* This is a hack to get a properly aligned result buffer */\n+  test_structure_7 *ts7_result = \n+    (test_structure_7 *) malloc (sizeof(test_structure_7));\n+  \n+  args[0] = &ts7_type;\n+  values[0] = &ts7_arg;\n+  \n+  /* Initialize the cif */\n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, &ts7_type, args) == FFI_OK);\n+  \n+  ts7_arg.f1 = 5.55f;\n+  ts7_arg.f2 = 55.5f;\n+  ts7_arg.d = 6.66;\n+\n+  printf (\"%g\\n\", ts7_arg.f1);\n+  printf (\"%g\\n\", ts7_arg.f2);\n+  printf (\"%g\\n\", ts7_arg.d);\n+  \n+  ffi_call(&cif, FFI_FN(struct7), ts7_result, values);\n+\n+  printf (\"%g\\n\", ts7_result->f1);\n+  printf (\"%g\\n\", ts7_result->f2);\n+  printf (\"%g\\n\", ts7_result->d);\n+  \n+  CHECK(ts7_result->f1 == 5.55f + 1);\n+  CHECK(ts7_result->f2 == 55.5f + 1);\n+  CHECK(ts7_result->d == 6.66 + 1);\n+  \n+  free (ts7_result);\n+  exit(0);\n+}"}, {"sha": "c773ac7b5ac6d751878acaba7f1c914120949a74", "filename": "libffi/testsuite/libffi.call/struct8.c", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fstruct8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fstruct8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fstruct8.c?ref=8a6b509ea857a07be12738d10403d3ab0f647ffe", "patch": "@@ -0,0 +1,80 @@\n+/* Area:\tffi_call\n+   Purpose:\tCheck structures.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\tFrom the original ffitest.c  */\n+\n+/* { dg-do run } */\n+#include \"ffitest.h\"\n+typedef struct\n+{\n+  float f1;\n+  float f2;\n+  float f3;\n+  float f4;\n+} test_structure_8;\n+\n+static test_structure_8 struct8 (test_structure_8 ts)\n+{\n+  ts.f1 += 1;\n+  ts.f2 += 1;\n+  ts.f3 += 1;\n+  ts.f4 += 1;\n+\n+  return ts;\n+}\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  ffi_type *args[MAX_ARGS];\n+  void *values[MAX_ARGS];\n+  ffi_type ts8_type;\n+  ffi_type *ts8_type_elements[5];\n+  ts8_type.size = 0;\n+  ts8_type.alignment = 0;\n+  ts8_type.type = FFI_TYPE_STRUCT;\n+  ts8_type.elements = ts8_type_elements;\n+  ts8_type_elements[0] = &ffi_type_float;\n+  ts8_type_elements[1] = &ffi_type_float;\n+  ts8_type_elements[2] = &ffi_type_float;\n+  ts8_type_elements[3] = &ffi_type_float;\n+  ts8_type_elements[4] = NULL;\n+\n+  test_structure_8 ts8_arg;\n+  \n+  /* This is a hack to get a properly aligned result buffer */\n+  test_structure_8 *ts8_result = \n+    (test_structure_8 *) malloc (sizeof(test_structure_8));\n+  \n+  args[0] = &ts8_type;\n+  values[0] = &ts8_arg;\n+  \n+  /* Initialize the cif */\n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, &ts8_type, args) == FFI_OK);\n+  \n+  ts8_arg.f1 = 5.55f;\n+  ts8_arg.f2 = 55.5f;\n+  ts8_arg.f3 = -5.55f;\n+  ts8_arg.f4 = -55.5f;\n+\n+  printf (\"%g\\n\", ts8_arg.f1);\n+  printf (\"%g\\n\", ts8_arg.f2);\n+  printf (\"%g\\n\", ts8_arg.f3);\n+  printf (\"%g\\n\", ts8_arg.f4);\n+  \n+  ffi_call(&cif, FFI_FN(struct8), ts8_result, values);\n+\n+  printf (\"%g\\n\", ts8_result->f1);\n+  printf (\"%g\\n\", ts8_result->f2);\n+  printf (\"%g\\n\", ts8_result->f3);\n+  printf (\"%g\\n\", ts8_result->f4);\n+  \n+  CHECK(ts8_result->f1 == 5.55f + 1);\n+  CHECK(ts8_result->f2 == 55.5f + 1);\n+  CHECK(ts8_result->f3 == -5.55f + 1);\n+  CHECK(ts8_result->f4 == -55.5f + 1);\n+  \n+  free (ts8_result);\n+  exit(0);\n+}"}, {"sha": "f30091f54f129040ffbd8cb22534bd5e8639943a", "filename": "libffi/testsuite/libffi.call/struct9.c", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fstruct9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.call%2Fstruct9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fstruct9.c?ref=8a6b509ea857a07be12738d10403d3ab0f647ffe", "patch": "@@ -0,0 +1,67 @@\n+/* Area:\tffi_call\n+   Purpose:\tCheck structures.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\tFrom the original ffitest.c  */\n+\n+/* { dg-do run } */\n+#include \"ffitest.h\"\n+\n+typedef struct\n+{\n+  float f;\n+  int i;\n+} test_structure_9;\n+\n+static test_structure_9 struct9 (test_structure_9 ts)\n+{\n+  ts.f += 1;\n+  ts.i += 1;\n+\n+  return ts;\n+}\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  ffi_type *args[MAX_ARGS];\n+  void *values[MAX_ARGS];\n+  ffi_type ts9_type;\n+  ffi_type *ts9_type_elements[3];\n+  ts9_type.size = 0;\n+  ts9_type.alignment = 0;\n+  ts9_type.type = FFI_TYPE_STRUCT;\n+  ts9_type.elements = ts9_type_elements;\n+  ts9_type_elements[0] = &ffi_type_float;\n+  ts9_type_elements[1] = &ffi_type_sint;\n+  ts9_type_elements[2] = NULL;\n+\n+  test_structure_9 ts9_arg;\n+  \n+  /* This is a hack to get a properly aligned result buffer */\n+  test_structure_9 *ts9_result = \n+    (test_structure_9 *) malloc (sizeof(test_structure_9));\n+  \n+  args[0] = &ts9_type;\n+  values[0] = &ts9_arg;\n+  \n+  /* Initialize the cif */\n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, &ts9_type, args) == FFI_OK);\n+  \n+  ts9_arg.f = 5.55f;\n+  ts9_arg.i = 5;\n+  \n+  printf (\"%g\\n\", ts9_arg.f);\n+  printf (\"%d\\n\", ts9_arg.i);\n+  \n+  ffi_call(&cif, FFI_FN(struct9), ts9_result, values);\n+\n+  printf (\"%g\\n\", ts9_result->f);\n+  printf (\"%d\\n\", ts9_result->i);\n+  \n+  CHECK(ts9_result->f == 5.55f + 1);\n+  CHECK(ts9_result->i == 5 + 1);\n+\n+  free (ts9_result);\n+  exit(0);\n+}"}, {"sha": "fabe3057bea59183f579163276bb62e53020c9f6", "filename": "libffi/testsuite/libffi.special/ffitestcxx.h", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.special%2Fffitestcxx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.special%2Fffitestcxx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.special%2Fffitestcxx.h?ref=8a6b509ea857a07be12738d10403d3ab0f647ffe", "patch": "@@ -0,0 +1,8 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <ffi.h>\n+\n+#define MAX_ARGS 256\n+\n+#define CHECK(x) (!(x) ? abort() : (void)0)\n+"}, {"sha": "df96d03d60cac11c49eaf1deb4c5f570d89baba0", "filename": "libffi/testsuite/libffi.special/special.exp", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.special%2Fspecial.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.special%2Fspecial.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.special%2Fspecial.exp?ref=8a6b509ea857a07be12738d10403d3ab0f647ffe", "patch": "@@ -0,0 +1,36 @@\n+#   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 2 of the License, or\n+# (at your option) any later version.\n+# \n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with this program; if not, write to the Free Software\n+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  \n+\n+# libffi testsuite that uses the 'dg.exp' driver.\n+\n+load_lib libffi-dg.exp\n+\n+dg-init\n+libffi-init\n+\n+global srcdir subdir\n+\n+global cxx_options\n+\n+set cxx_options \" -lstdc++\"\n+\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.cc]] $cxx_options \"\"\n+\n+dg-finish\n+\n+# Local Variables:\n+# tcl-indent-level:4\n+# End:"}, {"sha": "97b1536b2149fc04ef7764f0aba75c6dc0cbfaea", "filename": "libffi/testsuite/libffi.special/unwindtest.cc", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.special%2Funwindtest.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a6b509ea857a07be12738d10403d3ab0f647ffe/libffi%2Ftestsuite%2Flibffi.special%2Funwindtest.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.special%2Funwindtest.cc?ref=8a6b509ea857a07be12738d10403d3ab0f647ffe", "patch": "@@ -0,0 +1,113 @@\n+/* Area:\tffi_closure, unwind info\n+   Purpose:\tCheck if the unwind information is passed correctly.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\tJeff Sturm <jsturm@one-point.com>  */\n+\n+/* { dg-do run } */\n+#include \"ffitestcxx.h\"\n+\n+void\n+closure_test_fn(ffi_cif* cif, void* resp, void** args, void* userdata)\n+{\n+  throw 9;\n+}\n+\n+typedef void (*closure_test_type)();\n+\n+void closure_test_fn1(ffi_cif* cif,void* resp,void** args, \n+\t\t\t     void* userdata)\n+ {\n+    *(ffi_arg*)resp =\n+      (int)*(float *)args[0] +(int)(*(float *)args[1]) + \n+      (int)(*(float *)args[2]) + (int)*(float *)args[3] +\n+      (int)(*(signed short *)args[4]) + (int)(*(float *)args[5]) +\n+      (int)*(float *)args[6] + (int)(*(int *)args[7]) + \n+      (int)(*(double*)args[8]) + (int)*(int *)args[9] + \n+      (int)(*(int *)args[10]) + (int)(*(float *)args[11]) + \n+      (int)*(int *)args[12] + (int)(*(int *)args[13]) + \n+      (int)(*(int *)args[14]) + *(int *)args[15] + (int)(long)userdata;\n+\n+    printf(\"%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d: %d\\n\",\n+    \t   (int)*(float *)args[0], (int)(*(float *)args[1]), \n+    \t   (int)(*(float *)args[2]), (int)*(float *)args[3], \n+    \t   (int)(*(signed short *)args[4]), (int)(*(float *)args[5]),\n+    \t   (int)*(float *)args[6], (int)(*(int *)args[7]),\n+    \t   (int)(*(double *)args[8]), (int)*(int *)args[9],\n+    \t   (int)(*(int *)args[10]), (int)(*(float *)args[11]),\n+    \t   (int)*(int *)args[12], (int)(*(int *)args[13]),\n+    \t   (int)(*(int *)args[14]), *(int *)args[15],\n+    \t   (int)(long)userdata, *(int*)resp);\n+    \n+    throw *(int*)resp;\n+}\n+\n+typedef int (*closure_test_type1)(float, float, float, float, signed short, \n+\t\t\t\t  float, float, int, double, int, int, float,\n+\t\t\t\t  int, int, int, int);\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  ffi_closure cl;\n+  ffi_type * cl_arg_types[17];\n+  {\n+    cl_arg_types[1] = NULL;\n+    \n+    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 0,\n+\t\t       &ffi_type_void, cl_arg_types) == FFI_OK);\n+    CHECK(ffi_prep_closure(&cl, &cif, closure_test_fn, NULL) == FFI_OK);\n+    \n+    try\n+      {\n+\t(*((closure_test_type)(&cl)))();\n+      } catch (int exception_code)\n+      {\n+\tCHECK(exception_code == 9);\n+      }\n+    \n+    printf(\"part one OK\\n\");\n+    /* { dg-output \"part one OK\" } */\n+    }\n+\n+    {\n+\n+      cl_arg_types[0] = &ffi_type_float;\n+      cl_arg_types[1] = &ffi_type_float;\n+      cl_arg_types[2] = &ffi_type_float;\n+      cl_arg_types[3] = &ffi_type_float;\n+      cl_arg_types[4] = &ffi_type_sshort;\n+      cl_arg_types[5] = &ffi_type_float;\n+      cl_arg_types[6] = &ffi_type_float;\n+      cl_arg_types[7] = &ffi_type_uint;\n+      cl_arg_types[8] = &ffi_type_double;\n+      cl_arg_types[9] = &ffi_type_uint;\n+      cl_arg_types[10] = &ffi_type_uint;\n+      cl_arg_types[11] = &ffi_type_float;\n+      cl_arg_types[12] = &ffi_type_uint;\n+      cl_arg_types[13] = &ffi_type_uint;\n+      cl_arg_types[14] = &ffi_type_uint;\n+      cl_arg_types[15] = &ffi_type_uint;\n+      cl_arg_types[16] = NULL;\n+      \n+      /* Initialize the cif */\n+      CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,\n+\t\t\t &ffi_type_sint, cl_arg_types) == FFI_OK);\n+\n+      CHECK(ffi_prep_closure(&cl, &cif, closure_test_fn1,\n+\t\t\t     (void *) 3 /* userdata */)  == FFI_OK);\n+      try\n+\t{\n+\t  (*((closure_test_type1)(&cl)))\n+\t    (1.1, 2.2, 3.3, 4.4, 127, 5.5, 6.6, 8, 9, 10, 11, 12.0, 13,\n+\t     19, 21, 1);\n+\t  /* { dg-output \"\\n1 2 3 4 127 5 6 8 9 10 11 12 13 19 21 1 3: 255\" } */\n+\t} catch (int exception_code)\n+\t{\n+\t  CHECK(exception_code == 255);\n+\t}      \n+      printf(\"part two OK\\n\");\n+      /* { dg-output \"\\npart two OK\" } */\n+    }\n+    exit(0);\n+}"}]}