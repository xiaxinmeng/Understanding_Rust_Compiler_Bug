{"sha": "4185f1ce1a6cfa864c49caf8252934eea0762b1d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDE4NWYxY2UxYTZjZmE4NjRjNDljYWY4MjUyOTM0ZWVhMDc2MmIxZA==", "commit": {"author": {"name": "Adam Nemet", "email": "anemet@lnxw.com", "date": "2004-08-25T20:51:19Z"}, "committer": {"name": "Adam Nemet", "email": "nemet@gcc.gnu.org", "date": "2004-08-25T20:51:19Z"}, "message": "tlink.c (initial_cwd): New variable.\n\n\t* tlink.c (initial_cwd): New variable.\n\t(tlink_init): Initialize it.\n\t(recompile_files): Use tlink_execute() instead of system().  Don't\n\tduplicate verbose output of collect_execute.  Restore initial_cwd.\n\tUpdate comment before the function.\n\nFrom-SVN: r86577", "tree": {"sha": "376e761c617dd59eb80c8d7976d9c89687cb92ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/376e761c617dd59eb80c8d7976d9c89687cb92ad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4185f1ce1a6cfa864c49caf8252934eea0762b1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4185f1ce1a6cfa864c49caf8252934eea0762b1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4185f1ce1a6cfa864c49caf8252934eea0762b1d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4185f1ce1a6cfa864c49caf8252934eea0762b1d/comments", "author": null, "committer": null, "parents": [{"sha": "d0c5c9b14da834ec8345a4aca53d45334cb5562a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0c5c9b14da834ec8345a4aca53d45334cb5562a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0c5c9b14da834ec8345a4aca53d45334cb5562a"}], "stats": {"total": 80, "additions": 65, "deletions": 15}, "files": [{"sha": "c946ef69d8696e6cf5364ec06234fe80c5c82643", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4185f1ce1a6cfa864c49caf8252934eea0762b1d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4185f1ce1a6cfa864c49caf8252934eea0762b1d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4185f1ce1a6cfa864c49caf8252934eea0762b1d", "patch": "@@ -1,3 +1,11 @@\n+2004-08-25  Adam Nemet  <anemet@lnxw.com>\n+\n+\t* tlink.c (initial_cwd): New variable.\n+\t(tlink_init): Initialize it.\n+\t(recompile_files): Use tlink_execute() instead of system().  Don't\n+\tduplicate verbose output of collect_execute.  Restore initial_cwd.\n+\tUpdate comment before the function.\n+\n 2004-08-25  Ziemowit Laski  <zlaski@apple.com>\n \n \t* c-typeck.c (build_c_cast): In ObjC, always preserve (and silently"}, {"sha": "935e309df5b3c99282a5e1fb850369a32b20c321", "filename": "gcc/tlink.c", "status": "modified", "additions": 57, "deletions": 15, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4185f1ce1a6cfa864c49caf8252934eea0762b1d/gcc%2Ftlink.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4185f1ce1a6cfa864c49caf8252934eea0762b1d/gcc%2Ftlink.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftlink.c?ref=4185f1ce1a6cfa864c49caf8252934eea0762b1d", "patch": "@@ -38,6 +38,8 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n extern int prepends_underscore;\n \n static int tlink_verbose;\n+\n+static char initial_cwd[MAXPATHLEN + 1];\n \f\n /* Hash table boilerplate for working with htab_t.  We have hash tables\n    for symbol names, file names, and demangled symbols.  */\n@@ -272,6 +274,8 @@ tlink_init (void)\n       if (debug)\n \ttlink_verbose = 3;\n     }\n+\n+  getcwd (initial_cwd, sizeof (initial_cwd));\n }\n \n static int\n@@ -432,9 +436,7 @@ maybe_tweak (char *line, file *f)\n }\n \n /* Update the repo files for each of the object files we have adjusted and\n-   recompile.\n-\n-   XXX Should this use collect_execute instead of system?  */\n+   recompile.  */\n \n static int\n recompile_files (void)\n@@ -446,7 +448,10 @@ recompile_files (void)\n \n   while ((f = file_pop ()) != NULL)\n     {\n-      char *line, *command;\n+      char *line;\n+      const char *p, *q;\n+      char **argv;\n+      struct obstack arg_stack;\n       FILE *stream = fopen (f->key, \"r\");\n       const char *const outname = frob_extension (f->key, \".rnw\");\n       FILE *output = fopen (outname, \"w\");\n@@ -465,31 +470,68 @@ recompile_files (void)\n       fclose (output);\n       rename (outname, f->key);\n \n-      obstack_grow (&temporary_obstack, \"cd \", 3);\n-      obstack_grow (&temporary_obstack, f->dir, strlen (f->dir));\n-      obstack_grow (&temporary_obstack, \"; \", 2);\n-      obstack_grow (&temporary_obstack, c_file_name, strlen (c_file_name));\n-      obstack_1grow (&temporary_obstack, ' ');\n       if (!f->args)\n \t{\n \t  error (\"repository file `%s' does not contain command-line \"\n \t\t \"arguments\", f->key);\n \t  return 0;\n \t}\n-      obstack_grow (&temporary_obstack, f->args, strlen (f->args));\n-      obstack_1grow (&temporary_obstack, ' ');\n-      command = obstack_copy0 (&temporary_obstack, f->main, strlen (f->main));\n+\n+      /* Build a null-terminated argv array suitable for\n+\t tlink_execute().  Manipulate arguments on the arg_stack while\n+\t building argv on the temporary_obstack.  */\n+\n+      obstack_init (&arg_stack);\n+      obstack_ptr_grow (&temporary_obstack, c_file_name);\n+\n+      for (p = f->args; *p != '\\0'; p = q + 1)\n+\t{\n+\t  /* Arguments are delimited by single-quotes.  Find the\n+\t     opening quote.  */\n+\t  p = strchr (p, '\\'');\n+\t  if (!p)\n+\t    goto done;\n+\n+\t  /* Find the closing quote.  */\n+\t  q = strchr (p + 1, '\\'');\n+\t  if (!q)\n+\t    goto done;\n+\n+\t  obstack_grow (&arg_stack, p + 1, q - (p + 1));\n+\n+\t  /* Replace '\\'' with '.  This is how set_collect_gcc_options\n+\t     encodes a single-quote.  */\n+\t  while (q[1] == '\\\\' && q[2] == '\\'' && q[3] == '\\'')\n+\t    {\n+\t      const char *r;\n+\n+\t      r = strchr (q + 4, '\\'');\n+\t      if (!r)\n+\t\tgoto done;\n+\n+\t      obstack_grow (&arg_stack, q + 3, r - (q + 3));\n+\t      q = r;\n+\t    }\n+\n+\t  obstack_1grow (&arg_stack, '\\0');\n+\t  obstack_ptr_grow (&temporary_obstack, obstack_finish (&arg_stack));\n+\t}\n+    done:\n+      obstack_ptr_grow (&temporary_obstack, f->main);\n+      obstack_ptr_grow (&temporary_obstack, NULL);\n+      argv = obstack_finish (&temporary_obstack);\n \n       if (tlink_verbose)\n \tfprintf (stderr, _(\"collect: recompiling %s\\n\"), f->main);\n-      if (tlink_verbose >= 3)\n-\tfprintf (stderr, \"%s\\n\", command);\n \n-      if (system (command) != 0)\n+      if (chdir (f->dir) != 0\n+\t  || tlink_execute (c_file_name, argv, NULL) != 0\n+\t  || chdir (initial_cwd) != 0)\n \treturn 0;\n \n       read_repo_file (f);\n \n+      obstack_free (&arg_stack, NULL);\n       obstack_free (&temporary_obstack, temporary_firstobj);\n     }\n   return 1;"}]}