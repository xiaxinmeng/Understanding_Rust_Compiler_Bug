{"sha": "891ad31c7b151704de655a1a2b70568830a65086", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODkxYWQzMWM3YjE1MTcwNGRlNjU1YTFhMmI3MDU2ODgzMGE2NTA4Ng==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2017-07-20T11:17:21Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2017-07-20T11:17:21Z"}, "message": "re PR tree-optimization/61171 (vectorization fails for a reduction in presence of subtraction)\n\n2017-07-20  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/61171\n\t* tree-vectorizer.h (slp_instance): Add reduc_phis member.\n\t(vect_analyze_stmt): Add slp instance parameter.\n\t(vectorizable_reduction): Likewise.\n\t* tree-vect-loop.c (vect_analyze_loop_operations): Adjust.\n\t(vect_is_simple_reduction): Deal with chains not detected\n\tas SLP reduction chain, specifically not properly associated\n\tchains containing a mix of plus/minus.\n\t(get_reduction_op): Remove.\n\t(get_initial_defs_for_reduction): Simplify, pass in whether\n\tthis is a reduction chain, pass in the SLP node for the PHIs.\n\t(vect_create_epilog_for_reduction): Get the SLP instance as\n\targ and adjust.\n\t(vectorizable_reduction): Get the SLP instance as arg.\n\tDuring analysis remember the SLP node with the PHIs in the\n\tinstance.  Simplify getting at the vectorized reduction PHIs.\n\t* tree-vect-slp.c (vect_slp_analyze_node_operations): Pass\n\tthrough SLP instance.\n\t(vect_slp_analyze_operations): Likewise.\n\t* tree-vect-stms.c (vect_analyze_stmt): Likewise.\n\t(vect_transform_stmt): Likewise.\n\n\t* g++.dg/vect/pr61171.cc: New testcase.\n\t* gfortran.dg/vect/pr61171.f: Likewise.\n\t* gcc.dg/vect/vect-reduc-11.c: Likewise.\n\nFrom-SVN: r250382", "tree": {"sha": "4f6d0ffbb5e74aa6bcb4ebf183760b0d678a438f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4f6d0ffbb5e74aa6bcb4ebf183760b0d678a438f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/891ad31c7b151704de655a1a2b70568830a65086", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/891ad31c7b151704de655a1a2b70568830a65086", "html_url": "https://github.com/Rust-GCC/gccrs/commit/891ad31c7b151704de655a1a2b70568830a65086", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/891ad31c7b151704de655a1a2b70568830a65086/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f971b2813d7ddbdba210a63290b790a175777679", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f971b2813d7ddbdba210a63290b790a175777679", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f971b2813d7ddbdba210a63290b790a175777679"}], "stats": {"total": 391, "additions": 292, "deletions": 99}, "files": [{"sha": "5bea9dd1e3e6963a66a8e33e7f1dc2d3020838ac", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/891ad31c7b151704de655a1a2b70568830a65086/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/891ad31c7b151704de655a1a2b70568830a65086/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=891ad31c7b151704de655a1a2b70568830a65086", "patch": "@@ -1,3 +1,27 @@\n+2017-07-20  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/61171\n+\t* tree-vectorizer.h (slp_instance): Add reduc_phis member.\n+\t(vect_analyze_stmt): Add slp instance parameter.\n+\t(vectorizable_reduction): Likewise.\n+\t* tree-vect-loop.c (vect_analyze_loop_operations): Adjust.\n+\t(vect_is_simple_reduction): Deal with chains not detected\n+\tas SLP reduction chain, specifically not properly associated\n+\tchains containing a mix of plus/minus.\n+\t(get_reduction_op): Remove.\n+\t(get_initial_defs_for_reduction): Simplify, pass in whether\n+\tthis is a reduction chain, pass in the SLP node for the PHIs.\n+\t(vect_create_epilog_for_reduction): Get the SLP instance as\n+\targ and adjust.\n+\t(vectorizable_reduction): Get the SLP instance as arg.\n+\tDuring analysis remember the SLP node with the PHIs in the\n+\tinstance.  Simplify getting at the vectorized reduction PHIs.\n+\t* tree-vect-slp.c (vect_slp_analyze_node_operations): Pass\n+\tthrough SLP instance.\n+\t(vect_slp_analyze_operations): Likewise.\n+\t* tree-vect-stms.c (vect_analyze_stmt): Likewise.\n+\t(vect_transform_stmt): Likewise.\n+\n 2017-07-20  Tom de Vries  <tom@codesourcery.com>\n \n \tPR tree-optimization/81489"}, {"sha": "8ff6c4f200c6e8bdd967e89e838ae6964a194ad1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/891ad31c7b151704de655a1a2b70568830a65086/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/891ad31c7b151704de655a1a2b70568830a65086/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=891ad31c7b151704de655a1a2b70568830a65086", "patch": "@@ -1,3 +1,10 @@\n+2017-07-20  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/61171\n+\t* g++.dg/vect/pr61171.cc: New testcase.\n+\t* gfortran.dg/vect/pr61171.f: Likewise.\n+\t* gcc.dg/vect/vect-reduc-11.c: Likewise.\n+\n 2017-07-20  Richard Biener  <rguenther@suse.de>\n \n \t* gcc.dg/vect/slp-43.c: Increase loop count to enable vectorization"}, {"sha": "f3e2e3e4c1302ad98393a6dc44d8b50a91ed1d43", "filename": "gcc/testsuite/g++.dg/vect/pr61171.cc", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/891ad31c7b151704de655a1a2b70568830a65086/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fpr61171.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/891ad31c7b151704de655a1a2b70568830a65086/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fpr61171.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fpr61171.cc?ref=891ad31c7b151704de655a1a2b70568830a65086", "patch": "@@ -0,0 +1,23 @@\n+// { dg-do compile }\n+// { dg-require-effective-target vect_float }\n+// { dg-additional-options \"-ffast-math\" }\n+\n+float px[1024];\n+float xx, vv;\n+unsigned int N=1024;\n+\n+void ok() {\n+    for (unsigned j=0U; j<N; ++j) {\n+\tfloat ax = px[j]-xx;\n+\tvv-=ax;\n+    }\n+}\n+\n+void noOk() {\n+    for (unsigned j=0U; j<N; ++j) {\n+\tfloat ax = xx-px[j];\n+\tvv+=ax;\n+    }\n+}\n+\n+// { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" } }"}, {"sha": "29408edcfceb3dded22325e19bb6d5cf556114fc", "filename": "gcc/testsuite/gcc.dg/vect/vect-reduc-11.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/891ad31c7b151704de655a1a2b70568830a65086/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/891ad31c7b151704de655a1a2b70568830a65086/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-11.c?ref=891ad31c7b151704de655a1a2b70568830a65086", "patch": "@@ -0,0 +1,46 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target vect_int } */\n+\n+#include \"tree-vect.h\"\n+\n+int x[1024], y[1024], z[1024];\n+\n+int __attribute__((noinline,noclone))\n+foo (int n)\n+{\n+  int sum = 0;\n+  /* Can vectorize this.  */\n+  for (int i = 0; i < n; ++i)\n+    sum = (y[i] - (x[i] - sum));\n+  return sum;\n+}\n+\n+int __attribute__((noinline,noclone))\n+bar (int n)\n+{\n+  int sum = 0;\n+  /* Cannot vectorize this, sum is negated.  */\n+  for (int i = 0; i < n; ++i)\n+    sum = z[i] - (y[i] - (x[i] - sum));\n+  return sum;\n+}\n+\n+int\n+main()\n+{\n+  check_vect ();\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      x[i] = i;\n+      y[i] = i + 1;\n+      z[i] = 0;\n+      __asm__ volatile (\"\" : : : \"memory\");\n+    }\n+  if (foo (1024) != 1024)\n+    __builtin_abort ();\n+  if (bar (1023) != -1 || bar (1024) != 0)\n+    __builtin_abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */"}, {"sha": "f94b8f312839d4c33c4f3112336483a6b64c1b75", "filename": "gcc/testsuite/gfortran.dg/vect/pr61171.f", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/891ad31c7b151704de655a1a2b70568830a65086/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fpr61171.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/891ad31c7b151704de655a1a2b70568830a65086/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fpr61171.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fpr61171.f?ref=891ad31c7b151704de655a1a2b70568830a65086", "patch": "@@ -0,0 +1,15 @@\n+! { dg-do compile }\n+! { dg-additional-options \"-Ofast\" }\n+      SUBROUTINE GAUBON(NV,PTS,PP)\n+      IMPLICIT DOUBLE PRECISION(A-H,O-Z)\n+      PARAMETER (MXSP=250)\n+      DIMENSION PTS(3,10),PP(3)\n+      COMMON /PCMPLY/ XE(MXSP),YE(MXSP),ZE(MXSP)\n+      DATA PI/3.141592653589793D+00/\n+      DATA ZERO/0.0D+00/\n+      DO I = 1, NV\n+      PP(1) = PP(1) + (PTS(1,I)-XE(NS))\n+      PP(2) = PP(2) + (PTS(2,I)-YE(NS))\n+      PP(3) = PP(3) + (PTS(3,I)-ZE(NS))\n+      ENDDO\n+      END"}, {"sha": "7bae41680afc3562d855876cb8fcb48d54ead163", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 159, "deletions": 88, "changes": 247, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/891ad31c7b151704de655a1a2b70568830a65086/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/891ad31c7b151704de655a1a2b70568830a65086/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=891ad31c7b151704de655a1a2b70568830a65086", "patch": "@@ -1781,7 +1781,7 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo)\n \t      else if ((STMT_VINFO_DEF_TYPE (stmt_info) == vect_reduction_def\n \t\t\t|| STMT_VINFO_DEF_TYPE (stmt_info) == vect_nested_cycle)\n \t\t       && ! PURE_SLP_STMT (stmt_info))\n-\t\tok = vectorizable_reduction (phi, NULL, NULL, NULL);\n+\t\tok = vectorizable_reduction (phi, NULL, NULL, NULL, NULL);\n             }\n \n \t  if (ok && STMT_VINFO_LIVE_P (stmt_info))\n@@ -1805,7 +1805,7 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo)\n         {\n \t  gimple *stmt = gsi_stmt (si);\n \t  if (!gimple_clobber_p (stmt)\n-\t      && !vect_analyze_stmt (stmt, &need_to_vectorize, NULL))\n+\t      && !vect_analyze_stmt (stmt, &need_to_vectorize, NULL, NULL))\n \t    return false;\n         }\n     } /* bbs */\n@@ -2898,9 +2898,9 @@ vect_is_simple_reduction (loop_vec_info loop_info, gimple *phi,\n      gimple instruction for the first simple tests and only do this\n      if we're allowed to change code at all.  */\n   if (code == MINUS_EXPR\n-      && (op1 = gimple_assign_rhs1 (def_stmt))\n-      && TREE_CODE (op1) == SSA_NAME\n-      && SSA_NAME_DEF_STMT (op1) == phi)\n+      && ! ((op1 = gimple_assign_rhs2 (def_stmt))\n+\t    && TREE_CODE (op1) == SSA_NAME\n+\t    && SSA_NAME_DEF_STMT (op1) == phi))\n     code = PLUS_EXPR;\n \n   if (code == COND_EXPR)\n@@ -3151,6 +3151,7 @@ vect_is_simple_reduction (loop_vec_info loop_info, gimple *phi,\n   /* Try to find SLP reduction chain.  */\n   if (! nested_in_vect_loop\n       && code != COND_EXPR\n+      && orig_code != MINUS_EXPR\n       && vect_is_slp_reduction (loop_info, phi, def_stmt))\n     {\n       if (dump_enabled_p ())\n@@ -3160,10 +3161,127 @@ vect_is_simple_reduction (loop_vec_info loop_info, gimple *phi,\n       return def_stmt;\n     }\n \n+  /* Dissolve group eventually half-built by vect_is_slp_reduction.  */\n+  gimple *first = GROUP_FIRST_ELEMENT (vinfo_for_stmt (def_stmt));\n+  while (first)\n+    {\n+      gimple *next = GROUP_NEXT_ELEMENT (vinfo_for_stmt (first));\n+      GROUP_FIRST_ELEMENT (vinfo_for_stmt (first)) = NULL;\n+      GROUP_NEXT_ELEMENT (vinfo_for_stmt (first)) = NULL;\n+      first = next;\n+    }\n+\n+  /* Look for the expression computing loop_arg from loop PHI result.  */\n+  auto_vec<std::pair<ssa_op_iter, use_operand_p> > path;\n+  auto_bitmap visited;\n+  tree lookfor = PHI_RESULT (phi);\n+  ssa_op_iter curri;\n+  use_operand_p curr = op_iter_init_phiuse (&curri, as_a <gphi *>(phi),\n+\t\t\t\t\t    SSA_OP_USE);\n+  while (USE_FROM_PTR (curr) != loop_arg)\n+    curr = op_iter_next_use (&curri);\n+  curri.i = curri.numops;\n+  do\n+    {\n+      path.safe_push (std::make_pair (curri, curr));\n+      tree use = USE_FROM_PTR (curr);\n+      if (use == lookfor)\n+\tbreak;\n+      gimple *def = SSA_NAME_DEF_STMT (use);\n+      if (gimple_nop_p (def)\n+\t  || ! flow_bb_inside_loop_p (loop, gimple_bb (def)))\n+\t{\n+pop:\n+\t  do\n+\t    {\n+\t      std::pair<ssa_op_iter, use_operand_p> x = path.pop ();\n+\t      curri = x.first;\n+\t      curr = x.second;\n+\t      do\n+\t\tcurr = op_iter_next_use (&curri);\n+\t      /* Skip already visited or non-SSA operands (from iterating\n+\t         over PHI args).  */\n+\t      while (curr != NULL_USE_OPERAND_P\n+\t\t     && (TREE_CODE (USE_FROM_PTR (curr)) != SSA_NAME\n+\t\t\t || ! bitmap_set_bit (visited,\n+\t\t\t\t\t      SSA_NAME_VERSION\n+\t\t\t\t\t        (USE_FROM_PTR (curr)))));\n+\t    }\n+\t  while (curr == NULL_USE_OPERAND_P && ! path.is_empty ());\n+\t  if (curr == NULL_USE_OPERAND_P)\n+\t    break;\n+\t}\n+      else\n+\t{\n+\t  if (gimple_code (def) == GIMPLE_PHI)\n+\t    curr = op_iter_init_phiuse (&curri, as_a <gphi *>(def), SSA_OP_USE);\n+\t  else\n+\t    curr = op_iter_init_use (&curri, def, SSA_OP_USE);\n+\t  while (curr != NULL_USE_OPERAND_P\n+\t\t && (TREE_CODE (USE_FROM_PTR (curr)) != SSA_NAME\n+\t\t     || ! bitmap_set_bit (visited,\n+\t\t\t\t\t  SSA_NAME_VERSION\n+\t\t\t\t\t    (USE_FROM_PTR (curr)))))\n+\t    curr = op_iter_next_use (&curri);\n+\t  if (curr == NULL_USE_OPERAND_P)\n+\t    goto pop;\n+\t}\n+    }\n+  while (1);\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t       \"reduction path: \");\n+      unsigned i;\n+      std::pair<ssa_op_iter, use_operand_p> *x;\n+      FOR_EACH_VEC_ELT (path, i, x)\n+\t{\n+\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, USE_FROM_PTR (x->second));\n+\t  dump_printf (MSG_NOTE, \" \");\n+\t}\n+      dump_printf (MSG_NOTE, \"\\n\");\n+    }\n+\n+  /* Check whether the reduction path detected is valid.  */\n+  bool fail = false;\n+  bool neg = false;\n+  for (unsigned i = 1; i < path.length (); ++i)\n+    {\n+      gimple *use_stmt = USE_STMT (path[i].second);\n+      tree op = USE_FROM_PTR (path[i].second);\n+      if (! has_single_use (op)\n+\t  || ! is_gimple_assign (use_stmt))\n+\t{\n+\t  fail = true;\n+\t  break;\n+\t}\n+      if (gimple_assign_rhs_code (use_stmt) != code)\n+\t{\n+\t  if (code == PLUS_EXPR\n+\t      && gimple_assign_rhs_code (use_stmt) == MINUS_EXPR)\n+\t    {\n+\t      /* Track whether we negate the reduction value each iteration.  */\n+\t      if (gimple_assign_rhs2 (use_stmt) == op)\n+\t\tneg = ! neg;\n+\t    }\n+\t  else\n+\t    {\n+\t      fail = true;\n+\t      break;\n+\t    }\n+\t}\n+    }\n+  if (! fail && ! neg)\n+    return def_stmt;\n+\n   if (dump_enabled_p ())\n-    report_vect_op (MSG_MISSED_OPTIMIZATION, def_stmt,\n-\t\t    \"reduction: unknown pattern: \");\n-       \n+    {\n+      report_vect_op (MSG_MISSED_OPTIMIZATION,\n+\t\t      SSA_NAME_DEF_STMT\n+\t\t        (USE_FROM_PTR (path[path.length ()-1].second)),\n+\t\t      \"reduction: unknown pattern: \");\n+    }\n+\n   return NULL;\n }\n \n@@ -3656,29 +3774,6 @@ have_whole_vector_shift (machine_mode mode)\n   return true;\n }\n \n-/* Return the reduction operand (with index REDUC_INDEX) of STMT.  */\n-\n-static tree\n-get_reduction_op (gimple *stmt, int reduc_index)\n-{\n-  switch (get_gimple_rhs_class (gimple_assign_rhs_code (stmt)))\n-    {\n-    case GIMPLE_SINGLE_RHS:\n-      gcc_assert (TREE_OPERAND_LENGTH (gimple_assign_rhs1 (stmt))\n-\t\t  == ternary_op);\n-      return TREE_OPERAND (gimple_assign_rhs1 (stmt), reduc_index);\n-    case GIMPLE_UNARY_RHS:\n-      return gimple_assign_rhs1 (stmt);\n-    case GIMPLE_BINARY_RHS:\n-      return (reduc_index\n-\t      ? gimple_assign_rhs2 (stmt) : gimple_assign_rhs1 (stmt));\n-    case GIMPLE_TERNARY_RHS:\n-      return gimple_op (stmt, reduc_index + 1);\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-\n /* TODO: Close dependency between vect_model_*_cost and vectorizable_*\n    functions. Design better to avoid maintenance issues.  */\n \n@@ -4043,15 +4138,14 @@ get_initial_def_for_reduction (gimple *stmt, tree init_val,\n   return init_def;\n }\n \n-/* Get at the initial defs for OP in the reduction SLP_NODE.\n-   NUMBER_OF_VECTORS is the number of vector defs to create.\n-   REDUC_INDEX is the index of the reduction operand in the statements.  */\n+/* Get at the initial defs for the reduction PHIs in SLP_NODE.\n+   NUMBER_OF_VECTORS is the number of vector defs to create.  */\n \n static void\n get_initial_defs_for_reduction (slp_tree slp_node,\n \t\t\t\tvec<tree> *vec_oprnds,\n \t\t\t\tunsigned int number_of_vectors,\n-\t\t\t\tint reduc_index, enum tree_code code)\n+\t\t\t\tenum tree_code code, bool reduc_chain)\n {\n   vec<gimple *> stmts = SLP_TREE_SCALAR_STMTS (slp_node);\n   gimple *stmt = stmts[0];\n@@ -4069,16 +4163,17 @@ get_initial_defs_for_reduction (slp_tree slp_node,\n   voprnds.create (number_of_vectors);\n   bool constant_p;\n   tree neutral_op = NULL;\n-  gimple *def_stmt;\n   struct loop *loop;\n   gimple_seq ctor_seq = NULL;\n \n   vector_type = STMT_VINFO_VECTYPE (stmt_vinfo);\n   scalar_type = TREE_TYPE (vector_type);\n   nunits = TYPE_VECTOR_SUBPARTS (vector_type);\n \n-  gcc_assert (STMT_VINFO_DEF_TYPE (stmt_vinfo) == vect_reduction_def\n-\t      && reduc_index != -1);\n+  gcc_assert (STMT_VINFO_DEF_TYPE (stmt_vinfo) == vect_reduction_def);\n+\n+  loop = (gimple_bb (stmt))->loop_father;\n+  gcc_assert (loop);\n \n   /* op is the reduction operand of the first stmt already.  */\n   /* For additional copies (see the explanation of NUMBER_OF_COPIES below)\n@@ -4109,20 +4204,15 @@ get_initial_defs_for_reduction (slp_tree slp_node,\n        a reduction chain we have to force a neutral element.  */\n     case MAX_EXPR:\n     case MIN_EXPR:\n-      if (!GROUP_FIRST_ELEMENT (stmt_vinfo))\n+      if (! reduc_chain)\n \tneutral_op = NULL;\n       else\n-\t{\n-\t  tree op = get_reduction_op (stmts[0], reduc_index);\n-\t  def_stmt = SSA_NAME_DEF_STMT (op);\n-\t  loop = (gimple_bb (stmt))->loop_father;\n-\t  neutral_op = PHI_ARG_DEF_FROM_EDGE (def_stmt,\n-\t\t\t\t\t      loop_preheader_edge (loop));\n-\t}\n+\tneutral_op = PHI_ARG_DEF_FROM_EDGE (stmt,\n+\t\t\t\t\t    loop_preheader_edge (loop));\n       break;\n \n     default:\n-      gcc_assert (!GROUP_FIRST_ELEMENT (stmt_vinfo));\n+      gcc_assert (! reduc_chain);\n       neutral_op = NULL;\n     }\n \n@@ -4151,21 +4241,15 @@ get_initial_defs_for_reduction (slp_tree slp_node,\n     {\n       for (i = group_size - 1; stmts.iterate (i, &stmt); i--)\n         {\n-\t  tree op = get_reduction_op (stmt, reduc_index);\n-\t  loop = (gimple_bb (stmt))->loop_father;\n-\t  def_stmt = SSA_NAME_DEF_STMT (op);\n-\n-\t  gcc_assert (loop);\n-\n+\t  tree op;\n \t  /* Get the def before the loop.  In reduction chain we have only\n \t     one initial value.  */\n \t  if ((j != (number_of_copies - 1)\n-\t       || (GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt))\n-\t\t   && i != 0))\n+\t       || (reduc_chain && i != 0))\n \t      && neutral_op)\n \t    op = neutral_op;\n \t  else\n-\t    op = PHI_ARG_DEF_FROM_EDGE (def_stmt,\n+\t    op = PHI_ARG_DEF_FROM_EDGE (stmt,\n \t\t\t\t\tloop_preheader_edge (loop));\n \n           /* Create 'vect_ = {op0,op1,...,opn}'.  */\n@@ -4306,8 +4390,9 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n \t\t\t\t  gimple *reduc_def_stmt,\n \t\t\t\t  int ncopies, enum tree_code reduc_code,\n \t\t\t\t  vec<gimple *> reduction_phis,\n-                                  int reduc_index, bool double_reduc, \n-\t\t\t\t  slp_tree slp_node)\n+                                  bool double_reduc, \n+\t\t\t\t  slp_tree slp_node,\n+\t\t\t\t  slp_instance slp_node_instance)\n {\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   stmt_vec_info prev_phi_info;\n@@ -4385,8 +4470,9 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n     {\n       unsigned vec_num = SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node);\n       vec_initial_defs.reserve (vec_num);\n-      get_initial_defs_for_reduction (slp_node, &vec_initial_defs,\n-\t\t\t\t      vec_num, reduc_index, code);\n+      get_initial_defs_for_reduction (slp_node_instance->reduc_phis,\n+\t\t\t\t      &vec_initial_defs, vec_num, code,\n+\t\t\t\t      GROUP_FIRST_ELEMENT (stmt_info));\n     }\n   else\n     {\n@@ -5551,7 +5637,8 @@ is_nonwrapping_integer_induction (gimple *stmt, struct loop *loop)\n \n bool\n vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n-\t\t\tgimple **vec_stmt, slp_tree slp_node)\n+\t\t\tgimple **vec_stmt, slp_tree slp_node,\n+\t\t\tslp_instance slp_node_instance)\n {\n   tree vec_dest;\n   tree scalar_dest;\n@@ -5567,7 +5654,6 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n   tree new_temp = NULL_TREE;\n   gimple *def_stmt;\n   enum vect_def_type dt, cond_reduc_dt = vect_unknown_def_type;\n-  gphi *new_phi = NULL;\n   tree scalar_type;\n   bool is_simple_use;\n   gimple *orig_stmt;\n@@ -5625,6 +5711,9 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n       /* Analysis is fully done on the reduction stmt invocation.  */\n       if (! vec_stmt)\n \t{\n+\t  if (slp_node)\n+\t    slp_node_instance->reduc_phis = slp_node;\n+\n \t  STMT_VINFO_TYPE (stmt_info) = reduc_vec_info_type;\n \t  return true;\n \t}\n@@ -5689,7 +5778,7 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n \t\t{\n \t\t  /* Create the reduction-phi that defines the reduction\n \t\t     operand.  */\n-\t\t  new_phi = create_phi_node (vec_dest, loop->header);\n+\t\t  gimple *new_phi = create_phi_node (vec_dest, loop->header);\n \t\t  set_vinfo_for_stmt (new_phi,\n \t\t\t\t      new_stmt_vec_info (new_phi, loop_vinfo));\n \n@@ -6312,31 +6401,13 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n   if (!slp_node)\n     vect_defs.quick_push (NULL_TREE);\n \n-  auto_vec<tree> vec_oprnds;\n+  if (slp_node)\n+    phis.splice (SLP_TREE_VEC_STMTS (slp_node_instance->reduc_phis));\n+  else\n+    phis.quick_push (STMT_VINFO_VEC_STMT (vinfo_for_stmt (reduc_def_stmt)));\n+\n   for (j = 0; j < ncopies; j++)\n     {\n-      if (j == 0 || !single_defuse_cycle)\n-\t{\n-          for (i = 0; i < vec_num; i++)\n-            {\n-\t      /* Get the created reduction-phi that defines the reduction\n-                 operand.  */\n-\t      tree reduc_def = gimple_phi_result (reduc_def_stmt);\n-\t      if (j == 0)\n-\t\tvect_get_vec_defs (reduc_def, NULL, stmt, &vec_oprnds, NULL,\n-\t\t\t\t   slp_node);\n-\t      else\n-\t\t{\n-\t\t  dt = vect_reduction_def;\n-\t\t  vect_get_vec_defs_for_stmt_copy (&dt,\n-\t\t\t\t\t\t   &vec_oprnds, NULL);\n-\t\t}\n-\t      new_phi = as_a <gphi *> (SSA_NAME_DEF_STMT (vec_oprnds[i]));\n-\t      if (j == 0 || slp_node)\n-\t\tphis.quick_push (new_phi);\n-            }\n-        }\n-\n       if (code == COND_EXPR)\n         {\n           gcc_assert (!slp_node);\n@@ -6450,8 +6521,8 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n \n   vect_create_epilog_for_reduction (vect_defs, stmt, reduc_def_stmt,\n \t\t\t\t    epilog_copies,\n-                                    epilog_reduc_code, phis, reduc_index,\n-\t\t\t\t    double_reduc, slp_node);\n+                                    epilog_reduc_code, phis,\n+\t\t\t\t    double_reduc, slp_node, slp_node_instance);\n \n   return true;\n }"}, {"sha": "7cfeeb989786385174d0e5c2a9908508b0438196", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/891ad31c7b151704de655a1a2b70568830a65086/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/891ad31c7b151704de655a1a2b70568830a65086/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=891ad31c7b151704de655a1a2b70568830a65086", "patch": "@@ -2439,7 +2439,7 @@ destroy_bb_vec_info (bb_vec_info bb_vinfo)\n    the subtree. Return TRUE if the operations are supported.  */\n \n static bool\n-vect_slp_analyze_node_operations (slp_tree node)\n+vect_slp_analyze_node_operations (slp_tree node, slp_instance node_instance)\n {\n   bool dummy;\n   int i, j;\n@@ -2450,7 +2450,7 @@ vect_slp_analyze_node_operations (slp_tree node)\n     return true;\n \n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n-    if (!vect_slp_analyze_node_operations (child))\n+    if (!vect_slp_analyze_node_operations (child, node_instance))\n       return false;\n \n   stmt = SLP_TREE_SCALAR_STMTS (node)[0];\n@@ -2507,7 +2507,7 @@ vect_slp_analyze_node_operations (slp_tree node)\n     if (SLP_TREE_DEF_TYPE (child) != vect_internal_def)\n       STMT_VINFO_DEF_TYPE (vinfo_for_stmt (SLP_TREE_SCALAR_STMTS (child)[0]))\n \t= SLP_TREE_DEF_TYPE (child);\n-  bool res = vect_analyze_stmt (stmt, &dummy, node);\n+  bool res = vect_analyze_stmt (stmt, &dummy, node, node_instance);\n   /* Restore def-types.  */\n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), j, child)\n     if (SLP_TREE_DEF_TYPE (child) != vect_internal_def)\n@@ -2535,7 +2535,8 @@ vect_slp_analyze_operations (vec<slp_instance> slp_instances, void *data)\n \n   for (i = 0; slp_instances.iterate (i, &instance); )\n     {\n-      if (!vect_slp_analyze_node_operations (SLP_INSTANCE_TREE (instance)))\n+      if (!vect_slp_analyze_node_operations (SLP_INSTANCE_TREE (instance),\n+\t\t\t\t\t     instance))\n         {\n \t  dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t   \"removing SLP instance operations starting from: \");"}, {"sha": "a22947d02aca84663cd972265af34e1f999a6500", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/891ad31c7b151704de655a1a2b70568830a65086/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/891ad31c7b151704de655a1a2b70568830a65086/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=891ad31c7b151704de655a1a2b70568830a65086", "patch": "@@ -8397,7 +8397,8 @@ vectorizable_comparison (gimple *stmt, gimple_stmt_iterator *gsi,\n /* Make sure the statement is vectorizable.  */\n \n bool\n-vect_analyze_stmt (gimple *stmt, bool *need_to_vectorize, slp_tree node)\n+vect_analyze_stmt (gimple *stmt, bool *need_to_vectorize, slp_tree node,\n+\t\t   slp_instance node_instance)\n {\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n@@ -8476,7 +8477,8 @@ vect_analyze_stmt (gimple *stmt, bool *need_to_vectorize, slp_tree node)\n           dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 0);\n         }\n \n-      if (!vect_analyze_stmt (pattern_stmt, need_to_vectorize, node))\n+      if (!vect_analyze_stmt (pattern_stmt, need_to_vectorize, node,\n+\t\t\t      node_instance))\n         return false;\n    }\n \n@@ -8501,7 +8503,7 @@ vect_analyze_stmt (gimple *stmt, bool *need_to_vectorize, slp_tree node)\n \t\t}\n \n \t      if (!vect_analyze_stmt (pattern_def_stmt,\n-\t\t\t\t      need_to_vectorize, node))\n+\t\t\t\t      need_to_vectorize, node, node_instance))\n \t\treturn false;\n \t    }\n \t}\n@@ -8561,7 +8563,7 @@ vect_analyze_stmt (gimple *stmt, bool *need_to_vectorize, slp_tree node)\n \t  || vectorizable_load (stmt, NULL, NULL, node, NULL)\n \t  || vectorizable_call (stmt, NULL, NULL, node)\n \t  || vectorizable_store (stmt, NULL, NULL, node)\n-\t  || vectorizable_reduction (stmt, NULL, NULL, node)\n+\t  || vectorizable_reduction (stmt, NULL, NULL, node, node_instance)\n \t  || vectorizable_induction (stmt, NULL, NULL, node)\n \t  || vectorizable_condition (stmt, NULL, NULL, NULL, 0, node)\n \t  || vectorizable_comparison (stmt, NULL, NULL, NULL, node));\n@@ -8711,7 +8713,8 @@ vect_transform_stmt (gimple *stmt, gimple_stmt_iterator *gsi,\n       break;\n \n     case reduc_vec_info_type:\n-      done = vectorizable_reduction (stmt, gsi, &vec_stmt, slp_node);\n+      done = vectorizable_reduction (stmt, gsi, &vec_stmt, slp_node,\n+\t\t\t\t     slp_node_instance);\n       gcc_assert (done);\n       break;\n "}, {"sha": "accac72324f05736528bc250351cb2cc80350f92", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/891ad31c7b151704de655a1a2b70568830a65086/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/891ad31c7b151704de655a1a2b70568830a65086/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=891ad31c7b151704de655a1a2b70568830a65086", "patch": "@@ -127,6 +127,9 @@ typedef struct _slp_instance {\n \n   /* The group of nodes that contain loads of this SLP instance.  */\n   vec<slp_tree> loads;\n+\n+  /* The SLP node containing the reduction PHIs.  */\n+  slp_tree reduc_phis;\n } *slp_instance;\n \n \n@@ -1107,7 +1110,7 @@ extern tree vect_get_vec_def_for_stmt_copy (enum vect_def_type, tree);\n extern bool vect_transform_stmt (gimple *, gimple_stmt_iterator *,\n                                  bool *, slp_tree, slp_instance);\n extern void vect_remove_stores (gimple *);\n-extern bool vect_analyze_stmt (gimple *, bool *, slp_tree);\n+extern bool vect_analyze_stmt (gimple *, bool *, slp_tree, slp_instance);\n extern bool vectorizable_condition (gimple *, gimple_stmt_iterator *,\n \t\t\t\t    gimple **, tree, int, slp_tree);\n extern void vect_get_load_cost (struct data_reference *, int, bool,\n@@ -1178,7 +1181,7 @@ extern loop_vec_info vect_analyze_loop_form (struct loop *);\n extern bool vectorizable_live_operation (gimple *, gimple_stmt_iterator *,\n \t\t\t\t\t slp_tree, int, gimple **);\n extern bool vectorizable_reduction (gimple *, gimple_stmt_iterator *,\n-\t\t\t\t    gimple **, slp_tree);\n+\t\t\t\t    gimple **, slp_tree, slp_instance);\n extern bool vectorizable_induction (gimple *, gimple_stmt_iterator *,\n \t\t\t\t    gimple **, slp_tree);\n extern tree get_initial_def_for_reduction (gimple *, tree, tree *);"}]}