{"sha": "112d4212fc57a6387e971e6c9d84cbf05bf6d865", "node_id": "C_kwDOANBUbNoAKDExMmQ0MjEyZmM1N2E2Mzg3ZTk3MWU2YzlkODRjYmYwNWJmNmQ4NjU", "commit": {"author": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-06-14T11:42:54Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-06-15T07:43:53Z"}, "message": "parser: Add base for parsing const generic parameters", "tree": {"sha": "0821987f28ff89304d816af91a1d18cdac6594b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0821987f28ff89304d816af91a1d18cdac6594b9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/112d4212fc57a6387e971e6c9d84cbf05bf6d865", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/112d4212fc57a6387e971e6c9d84cbf05bf6d865", "html_url": "https://github.com/Rust-GCC/gccrs/commit/112d4212fc57a6387e971e6c9d84cbf05bf6d865", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/112d4212fc57a6387e971e6c9d84cbf05bf6d865/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "44f2de02d478b5d3defa5f091ee6504fa5d2e2e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44f2de02d478b5d3defa5f091ee6504fa5d2e2e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44f2de02d478b5d3defa5f091ee6504fa5d2e2e6"}], "stats": {"total": 590, "additions": 350, "deletions": 240}, "files": [{"sha": "ae6ef4a959541d1721bfb2e8a7e00e64357450aa", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 328, "deletions": 240, "changes": 568, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/112d4212fc57a6387e971e6c9d84cbf05bf6d865/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/112d4212fc57a6387e971e6c9d84cbf05bf6d865/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=112d4212fc57a6387e971e6c9d84cbf05bf6d865", "patch": "@@ -2865,6 +2865,63 @@ Parser<ManagedTokenSource>::parse_generic_param (EndTokenPred is_end_token)\n \t\t\t      std::move (outer_attrs)));\n \tbreak;\n       }\n+      case CONST: {\n+\tlexer.skip_token ();\n+\n+\tauto name = expect_token (IDENTIFIER);\n+\n+\tif (!name || !expect_token (COLON))\n+\t  return nullptr;\n+\n+\tauto type = parse_type ();\n+\tif (!type)\n+\t  return nullptr;\n+\n+\t// FIXME: instantiate proper AST::ConstGeneric class here\n+\t// auto const_generic = new ...\n+\n+\t// optional default value\n+\tif (lexer.peek_token ()->get_id () == EQUAL)\n+\t  {\n+\t    lexer.skip_token ();\n+\t    auto tok = lexer.peek_token ();\n+\n+\t    switch (tok->get_id ())\n+\t      {\n+\t\tcase LEFT_CURLY: {\n+\t\t  auto block = parse_block_expr ();\n+\t\t  // pass block to `const_generic`\n+\t\t  break;\n+\t\t}\n+\t\tcase IDENTIFIER: {\n+\t\t  auto ident = tok->get_str ();\n+\t\t  // pass identifier to `const_generic`\n+\t\t  break;\n+\t\t}\n+\t      case MINUS:\n+\t      case STRING_LITERAL:\n+\t      case CHAR_LITERAL:\n+\t      case INT_LITERAL:\n+\t      case FLOAT_LITERAL:\n+\t      case TRUE_LITERAL:\n+\t\tcase FALSE_LITERAL: {\n+\t\t  auto literal = parse_literal_expr ();\n+\t\t  // pass literal to `const_generic`\n+\t\t  break;\n+\t\t}\n+\t      default:\n+\t\trust_error_at (tok->get_locus (),\n+\t\t\t       \"invalid token for start of default value for \"\n+\t\t\t       \"const generic parameter: expected %<block%>, \"\n+\t\t\t       \"%<identifier%> or %<literal%>, got %qs\",\n+\t\t\t       token_id_to_str (tok->get_id ()));\n+\t      }\n+\t  }\n+\n+\t// param = std::unique_ptr<AST::GenericParam> (const_generic)\n+\n+\tbreak;\n+      }\n     default:\n       // FIXME: Can we clean this last call with a method call?\n       rust_error_at (token->get_locus (),\n@@ -2925,8 +2982,8 @@ Parser<ManagedTokenSource>::parse_generic_params (EndTokenPred is_end_token)\n   return generic_params;\n }\n \n-/* Parses lifetime generic parameters (pointers). Will also consume any trailing\n- * comma. No extra checks for end token. */\n+/* Parses lifetime generic parameters (pointers). Will also consume any\n+ * trailing comma. No extra checks for end token. */\n template <typename ManagedTokenSource>\n std::vector<std::unique_ptr<AST::LifetimeParam>>\n Parser<ManagedTokenSource>::parse_lifetime_params ()\n@@ -2958,8 +3015,8 @@ Parser<ManagedTokenSource>::parse_lifetime_params ()\n   return lifetime_params;\n }\n \n-/* Parses lifetime generic parameters (pointers). Will also consume any trailing\n- * comma. Has extra is_end_token predicate checking. */\n+/* Parses lifetime generic parameters (pointers). Will also consume any\n+ * trailing comma. Has extra is_end_token predicate checking. */\n template <typename ManagedTokenSource>\n template <typename EndTokenPred>\n std::vector<std::unique_ptr<AST::LifetimeParam>>\n@@ -2998,8 +3055,8 @@ Parser<ManagedTokenSource>::parse_lifetime_params (EndTokenPred is_end_token)\n   return lifetime_params;\n }\n \n-/* Parses lifetime generic parameters (objects). Will also consume any trailing\n- * comma. No extra checks for end token.\n+/* Parses lifetime generic parameters (objects). Will also consume any\n+ * trailing comma. No extra checks for end token.\n  * TODO: is this best solution? implements most of the same algorithm. */\n template <typename ManagedTokenSource>\n std::vector<AST::LifetimeParam>\n@@ -3032,8 +3089,8 @@ Parser<ManagedTokenSource>::parse_lifetime_params_objs ()\n   return lifetime_params;\n }\n \n-/* Parses lifetime generic parameters (objects). Will also consume any trailing\n- * comma. Has extra is_end_token predicate checking.\n+/* Parses lifetime generic parameters (objects). Will also consume any\n+ * trailing comma. Has extra is_end_token predicate checking.\n  * TODO: is this best solution? implements most of the same algorithm. */\n template <typename ManagedTokenSource>\n template <typename EndTokenPred>\n@@ -3092,7 +3149,8 @@ Parser<ManagedTokenSource>::parse_non_ptr_sequence (\n \n       if (param.is_error ())\n \t{\n-\t  // TODO: is it worth throwing away all params just because one failed?\n+\t  // TODO: is it worth throwing away all params just because one\n+\t  // failed?\n \t  Error error (lexer.peek_token ()->get_locus (),\n \t\t       std::move (error_msg));\n \t  add_error (std::move (error));\n@@ -3130,8 +3188,8 @@ Parser<ManagedTokenSource>::parse_lifetime_param ()\n       return AST::LifetimeParam::create_error ();\n     }\n   lexer.skip_token ();\n-  /* TODO: does this always create a named lifetime? or can a different type be\n-   * made? */\n+  /* TODO: does this always create a named lifetime? or can a different type\n+   * be made? */\n   AST::Lifetime lifetime (AST::Lifetime::NAMED, lifetime_tok->get_str (),\n \t\t\t  lifetime_tok->get_locus ());\n \n@@ -3212,12 +3270,12 @@ Parser<ManagedTokenSource>::parse_type_params (EndTokenPred is_end_token)\n \n   type_params.shrink_to_fit ();\n   return type_params;\n-  /* TODO: this shares most code with parse_lifetime_params - good place to use\n-   * template (i.e. parse_non_ptr_sequence if doable) */\n+  /* TODO: this shares most code with parse_lifetime_params - good place to\n+   * use template (i.e. parse_non_ptr_sequence if doable) */\n }\n \n-/* Parses a single type (generic) parameter, not including commas. May change to\n- * return value. */\n+/* Parses a single type (generic) parameter, not including commas. May change\n+ * to return value. */\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::TypeParam>\n Parser<ManagedTokenSource>::parse_type_param ()\n@@ -3228,7 +3286,8 @@ Parser<ManagedTokenSource>::parse_type_param ()\n   const_TokenPtr identifier_tok = lexer.peek_token ();\n   if (identifier_tok->get_id () != IDENTIFIER)\n     {\n-      // return null as type param can't exist without this required identifier\n+      // return null as type param can't exist without this required\n+      // identifier\n       return nullptr;\n     }\n   // TODO: create identifier from identifier token\n@@ -3326,8 +3385,8 @@ Parser<ManagedTokenSource>::parse_function_params (EndTokenPred is_end_token)\n   return params;\n }\n \n-/* Parses a single regular (i.e. non-generic) parameter in a function or method,\n- * i.e. the \"name: type\" bit. Also handles it not existing. */\n+/* Parses a single regular (i.e. non-generic) parameter in a function or\n+ * method, i.e. the \"name: type\" bit. Also handles it not existing. */\n template <typename ManagedTokenSource>\n AST::FunctionParam\n Parser<ManagedTokenSource>::parse_function_param ()\n@@ -3380,8 +3439,8 @@ Parser<ManagedTokenSource>::parse_function_return_type ()\n   return type;\n }\n \n-/* Parses a \"where clause\" (in a function, struct, method, etc.). Also handles a\n- * where clause not existing, in which it will return\n+/* Parses a \"where clause\" (in a function, struct, method, etc.). Also handles\n+ * a where clause not existing, in which it will return\n  * WhereClause::create_empty(), which can be checked via\n  * WhereClause::is_empty(). */\n template <typename ManagedTokenSource>\n@@ -3397,8 +3456,8 @@ Parser<ManagedTokenSource>::parse_where_clause ()\n \n   lexer.skip_token ();\n \n-  /* parse where clause items - this is not a separate rule in the reference so\n-   * won't be here */\n+  /* parse where clause items - this is not a separate rule in the reference\n+   * so won't be here */\n   std::vector<std::unique_ptr<AST::WhereClauseItem>> where_clause_items;\n \n   /* HACK: where clauses end with a right curly or semicolon or equals in all\n@@ -3438,7 +3497,8 @@ template <typename ManagedTokenSource>\n std::unique_ptr<AST::WhereClauseItem>\n Parser<ManagedTokenSource>::parse_where_clause_item ()\n {\n-  // shitty cheat way of determining lifetime or type bound - test for lifetime\n+  // shitty cheat way of determining lifetime or type bound - test for\n+  // lifetime\n   const_TokenPtr t = lexer.peek_token ();\n \n   if (t->get_id () == LIFETIME)\n@@ -3509,7 +3569,8 @@ Parser<ManagedTokenSource>::parse_type_bound_where_clause_item ()\n \t\t\t\t       std::move (type_param_bounds), locus));\n }\n \n-// Parses a for lifetimes clause, including the for keyword and angle brackets.\n+// Parses a for lifetimes clause, including the for keyword and angle\n+// brackets.\n template <typename ManagedTokenSource>\n std::vector<AST::LifetimeParam>\n Parser<ManagedTokenSource>::parse_for_lifetimes ()\n@@ -3637,7 +3698,8 @@ template <typename ManagedTokenSource>\n std::unique_ptr<AST::TypeParamBound>\n Parser<ManagedTokenSource>::parse_type_param_bound ()\n {\n-  // shitty cheat way of determining lifetime or trait bound - test for lifetime\n+  // shitty cheat way of determining lifetime or trait bound - test for\n+  // lifetime\n   const_TokenPtr t = lexer.peek_token ();\n   switch (t->get_id ())\n     {\n@@ -3724,8 +3786,8 @@ Parser<ManagedTokenSource>::parse_lifetime_bounds ()\n \n       lifetime_bounds.push_back (std::move (lifetime));\n \n-      /* plus is maybe not allowed at end - spec defines it weirdly, so assuming\n-       * allowed at end */\n+      /* plus is maybe not allowed at end - spec defines it weirdly, so\n+       * assuming allowed at end */\n       if (lexer.peek_token ()->get_id () != PLUS)\n \tbreak;\n \n@@ -3761,8 +3823,8 @@ Parser<ManagedTokenSource>::parse_lifetime_bounds (EndTokenPred is_end_token)\n \n       lifetime_bounds.push_back (std::move (lifetime));\n \n-      /* plus is maybe not allowed at end - spec defines it weirdly, so assuming\n-       * allowed at end */\n+      /* plus is maybe not allowed at end - spec defines it weirdly, so\n+       * assuming allowed at end */\n       if (lexer.peek_token ()->get_id () != PLUS)\n \tbreak;\n \n@@ -3860,9 +3922,9 @@ std::unique_ptr<AST::Struct>\n Parser<ManagedTokenSource>::parse_struct (AST::Visibility vis,\n \t\t\t\t\t  AST::AttrVec outer_attrs)\n {\n-  /* TODO: determine best way to parse the proper struct vs tuple struct - share\n-   * most of initial constructs so lookahead might be impossible, and if not\n-   * probably too expensive. Best way is probably unified parsing for the\n+  /* TODO: determine best way to parse the proper struct vs tuple struct -\n+   * share most of initial constructs so lookahead might be impossible, and if\n+   * not probably too expensive. Best way is probably unified parsing for the\n    * initial parts and then pass them in as params to more derived functions.\n    * Alternatively, just parse everything in this one function - do this if\n    * function not too long. */\n@@ -3930,8 +3992,8 @@ Parser<ManagedTokenSource>::parse_struct (AST::Visibility vis,\n \t\t\t      std::move (outer_attrs), locus));\n     }\n \n-  // assume it is a proper struct being parsed and continue outside of switch -\n-  // label only here to suppress warning\n+  // assume it is a proper struct being parsed and continue outside of switch\n+  // - label only here to suppress warning\n \n   // parse where clause, which is optional\n   AST::WhereClause where_clause = parse_where_clause ();\n@@ -4059,7 +4121,8 @@ Parser<ManagedTokenSource>::parse_struct_fields (EndTokenPred is_end_tok)\n   // TODO: template if possible (parse_non_ptr_seq)\n }\n \n-// Parses a single struct field (in a struct definition). Does not parse commas.\n+// Parses a single struct field (in a struct definition). Does not parse\n+// commas.\n template <typename ManagedTokenSource>\n AST::StructField\n Parser<ManagedTokenSource>::parse_struct_field ()\n@@ -4124,8 +4187,8 @@ Parser<ManagedTokenSource>::parse_tuple_fields ()\n \n   // maybe think of a better control structure here - do-while with an initial\n   // error state? basically, loop through field list until can't find any more\n-  // params HACK: all current syntax uses of tuple fields have them ending with\n-  // a right paren token\n+  // params HACK: all current syntax uses of tuple fields have them ending\n+  // with a right paren token\n   const_TokenPtr t = lexer.peek_token ();\n   while (t->get_id () == COMMA)\n     {\n@@ -4156,7 +4219,8 @@ Parser<ManagedTokenSource>::parse_tuple_fields ()\n   fields.shrink_to_fit ();\n   return fields;\n \n-  // TODO: this shares basically all code with function params and struct fields\n+  // TODO: this shares basically all code with function params and struct\n+  // fields\n   // - templates?\n }\n \n@@ -4434,8 +4498,8 @@ Parser<ManagedTokenSource>::parse_union (AST::Visibility vis,\n       return nullptr;\n     }\n \n-  /* parse union inner items as \"struct fields\" because hey, syntax reuse. Spec\n-   * said so. */\n+  /* parse union inner items as \"struct fields\" because hey, syntax reuse.\n+   * Spec said so. */\n   std::vector<AST::StructField> union_fields\n     = parse_struct_fields ([] (TokenId id) { return id == RIGHT_CURLY; });\n \n@@ -4451,8 +4515,8 @@ Parser<ManagedTokenSource>::parse_union (AST::Visibility vis,\n \t\t    std::move (union_fields), std::move (outer_attrs), locus));\n }\n \n-/* Parses a \"constant item\" (compile-time constant to maybe \"inline\" throughout\n- * the program - like constexpr). */\n+/* Parses a \"constant item\" (compile-time constant to maybe \"inline\"\n+ * throughout the program - like constexpr). */\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::ConstantItem>\n Parser<ManagedTokenSource>::parse_const_item (AST::Visibility vis,\n@@ -4710,18 +4774,18 @@ Parser<ManagedTokenSource>::parse_trait_item ()\n \t    return nullptr;\n \t  }\n \n-\t/* now for function vs method disambiguation - method has opening \"self\"\n-\t * param */\n+\t/* now for function vs method disambiguation - method has opening\n+\t * \"self\" param */\n \tAST::SelfParam self_param = parse_self_param ();\n-\t/* FIXME: ensure that self param doesn't accidently consume tokens for a\n-\t * function */\n+\t/* FIXME: ensure that self param doesn't accidently consume tokens for\n+\t * a function */\n \tbool is_method = false;\n \tif (!self_param.is_error ())\n \t  {\n \t    is_method = true;\n \n-\t    /* skip comma so function and method regular params can be parsed in\n-\t     * same way */\n+\t    /* skip comma so function and method regular params can be parsed\n+\t     * in same way */\n \t    if (lexer.peek_token ()->get_id () == COMMA)\n \t      lexer.skip_token ();\n \t  }\n@@ -4815,8 +4879,8 @@ Parser<ManagedTokenSource>::parse_trait_item ()\n \t  {\n \t    return macro_invoc;\n \t  }\n-\t/* FIXME: macro invocations can only start with certain tokens. be more\n-\t * picky with these? */\n+\t/* FIXME: macro invocations can only start with certain tokens. be\n+\t * more picky with these? */\n       }\n     }\n }\n@@ -4905,16 +4969,16 @@ Parser<ManagedTokenSource>::parse_trait_const (AST::AttrVec outer_attrs)\n \t\t\t     locus));\n }\n \n-/* Parses a struct \"impl\" item (both inherent impl and trait impl can be parsed\n- * here), */\n+/* Parses a struct \"impl\" item (both inherent impl and trait impl can be\n+ * parsed here), */\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::Impl>\n Parser<ManagedTokenSource>::parse_impl (AST::Visibility vis,\n \t\t\t\t\tAST::AttrVec outer_attrs)\n {\n-  /* Note that only trait impls are allowed to be unsafe. So if unsafe, it must\n-   * be a trait impl. However, this isn't enough for full disambiguation, so\n-   * don't branch here. */\n+  /* Note that only trait impls are allowed to be unsafe. So if unsafe, it\n+   * must be a trait impl. However, this isn't enough for full disambiguation,\n+   * so don't branch here. */\n   Location locus = lexer.peek_token ()->get_locus ();\n   bool is_unsafe = false;\n   if (lexer.peek_token ()->get_id () == UNSAFE)\n@@ -5218,8 +5282,8 @@ Parser<ManagedTokenSource>::parse_inherent_impl_item ()\n }\n \n /* For internal use only by parse_inherent_impl_item() - splits giant method\n- * into smaller ones and prevents duplication of logic. Strictly, this parses a\n- * function or method item inside an inherent impl item block. */\n+ * into smaller ones and prevents duplication of logic. Strictly, this parses\n+ * a function or method item inside an inherent impl item block. */\n // TODO: make this a templated function with \"return type\" as type param -\n // InherentImplItem is this specialisation of the template while TraitImplItem\n // will be the other.\n@@ -5251,18 +5315,19 @@ Parser<ManagedTokenSource>::parse_inherent_impl_function_or_method (\n       return nullptr;\n     }\n \n-  // now for function vs method disambiguation - method has opening \"self\" param\n+  // now for function vs method disambiguation - method has opening \"self\"\n+  // param\n   AST::SelfParam self_param = parse_self_param ();\n   /* FIXME: ensure that self param doesn't accidently consume tokens for a\n-   * function one idea is to lookahead up to 4 tokens to see whether self is one\n-   * of them */\n+   * function one idea is to lookahead up to 4 tokens to see whether self is\n+   * one of them */\n   bool is_method = false;\n   if (!self_param.is_error ())\n     {\n       is_method = true;\n \n-      /* skip comma so function and method regular params can be parsed in same\n-       * way */\n+      /* skip comma so function and method regular params can be parsed in\n+       * same way */\n       if (lexer.peek_token ()->get_id () == COMMA)\n \tlexer.skip_token ();\n     }\n@@ -5286,10 +5351,10 @@ Parser<ManagedTokenSource>::parse_inherent_impl_function_or_method (\n   // parse function definition (in block) - semicolon not allowed\n   if (lexer.peek_token ()->get_id () == SEMICOLON)\n     {\n-      Error error (\n-\tlexer.peek_token ()->get_locus (),\n-\t\"%s declaration in inherent impl not allowed - must have a definition\",\n-\tis_method ? \"method\" : \"function\");\n+      Error error (lexer.peek_token ()->get_locus (),\n+\t\t   \"%s declaration in inherent impl not allowed - must have \"\n+\t\t   \"a definition\",\n+\t\t   is_method ? \"method\" : \"function\");\n       add_error (std::move (error));\n \n       lexer.skip_token ();\n@@ -5347,7 +5412,8 @@ Parser<ManagedTokenSource>::parse_trait_impl_item ()\n     case SELF:\n     case CRATE:\n     case DOLLAR_SIGN:\n-      // these seem to be SimplePath tokens, so this is a macro invocation semi\n+      // these seem to be SimplePath tokens, so this is a macro invocation\n+      // semi\n       return parse_macro_invocation_semi (std::move (outer_attrs));\n     case TYPE:\n       return parse_type_alias (AST::Visibility::create_private (),\n@@ -5454,7 +5520,8 @@ std::unique_ptr<AST::TraitImplItem>\n Parser<ManagedTokenSource>::parse_trait_impl_function_or_method (\n   AST::Visibility vis, AST::AttrVec outer_attrs)\n {\n-  // this shares virtually all logic with parse_inherent_impl_function_or_method\n+  // this shares virtually all logic with\n+  // parse_inherent_impl_function_or_method\n   // - template?\n   Location locus = lexer.peek_token ()->get_locus ();\n \n@@ -5489,7 +5556,8 @@ Parser<ManagedTokenSource>::parse_trait_impl_function_or_method (\n       return nullptr;\n     }\n \n-  // now for function vs method disambiguation - method has opening \"self\" param\n+  // now for function vs method disambiguation - method has opening \"self\"\n+  // param\n   AST::SelfParam self_param = parse_self_param ();\n   // FIXME: ensure that self param doesn't accidently consume tokens for a\n   // function\n@@ -5498,8 +5566,8 @@ Parser<ManagedTokenSource>::parse_trait_impl_function_or_method (\n     {\n       is_method = true;\n \n-      // skip comma so function and method regular params can be parsed in same\n-      // way\n+      // skip comma so function and method regular params can be parsed in\n+      // same way\n       if (lexer.peek_token ()->get_id () == COMMA)\n \t{\n \t  lexer.skip_token ();\n@@ -5921,8 +5989,8 @@ Parser<ManagedTokenSource>::parse_stmt (ParseRestrictions restrictions)\n \n   // parsing this will be annoying because of the many different possibilities\n   /* best may be just to copy paste in parse_item switch, and failing that try\n-   * to parse outer attributes, and then pass them in to either a let statement\n-   * or (fallback) expression statement. */\n+   * to parse outer attributes, and then pass them in to either a let\n+   * statement or (fallback) expression statement. */\n   // FIXME: think of a way to do this without such a large switch?\n   t = lexer.peek_token ();\n   switch (t->get_id ())\n@@ -5976,8 +6044,8 @@ Parser<ManagedTokenSource>::parse_stmt (ParseRestrictions restrictions)\n \t       || lexer.peek_token (1)->get_id () == EXCLAM)\n \t{\n \t  // FIXME: ensure doesn't take any expressions by mistake\n-\t  /* path (probably) or macro invocation, so probably a macro invocation\n-\t   * semi */\n+\t  /* path (probably) or macro invocation, so probably a macro\n+\t   * invocation semi */\n \t  return parse_macro_item (std::move (outer_attrs));\n \t}\n       gcc_fallthrough ();\n@@ -6262,8 +6330,8 @@ Parser<ManagedTokenSource>::parse_generic_args_binding ()\n }\n \n /* Parses a single type path segment (not including opening scope resolution,\n- * but includes any internal ones). Includes generic args or type path functions\n- * too. */\n+ * but includes any internal ones). Includes generic args or type path\n+ * functions too. */\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::TypePathSegment>\n Parser<ManagedTokenSource>::parse_type_path_segment ()\n@@ -6460,8 +6528,8 @@ Parser<ManagedTokenSource>::parse_path_expr_segment ()\n     }\n \n   // parse generic args (and turbofish), if they exist\n-  /* use lookahead to determine if they actually exist (don't want to accidently\n-   * parse over next ident segment) */\n+  /* use lookahead to determine if they actually exist (don't want to\n+   * accidently parse over next ident segment) */\n   if (lexer.peek_token ()->get_id () == SCOPE_RESOLUTION\n       && lexer.peek_token (1)->get_id () == LEFT_ANGLE)\n     {\n@@ -6478,23 +6546,23 @@ Parser<ManagedTokenSource>::parse_path_expr_segment ()\n   return AST::PathExprSegment (std::move (ident), locus);\n }\n \n-/* Parses a fully qualified path in expression (i.e. a pattern). FIXME does not\n- * parse outer attrs. */\n+/* Parses a fully qualified path in expression (i.e. a pattern). FIXME does\n+ * not parse outer attrs. */\n template <typename ManagedTokenSource>\n AST::QualifiedPathInExpression\n Parser<ManagedTokenSource>::parse_qualified_path_in_expression (\n   Location pratt_parsed_loc)\n {\n   /* Note: the Rust grammar is defined in such a way that it is impossible to\n    * determine whether a prospective qualified path is a\n-   * QualifiedPathInExpression or QualifiedPathInType in all cases by the rules\n-   * themselves (the only possible difference is a TypePathSegment with\n-   * function, and lookahead to find this is too difficult). However, as this is\n-   * a pattern and QualifiedPathInType is a type, I believe it that their\n+   * QualifiedPathInExpression or QualifiedPathInType in all cases by the\n+   * rules themselves (the only possible difference is a TypePathSegment with\n+   * function, and lookahead to find this is too difficult). However, as this\n+   * is a pattern and QualifiedPathInType is a type, I believe it that their\n    * construction will not be confused (due to rules regarding patterns vs\n    * types).\n-   * As such, this function will not attempt to minimise errors created by their\n-   * confusion. */\n+   * As such, this function will not attempt to minimise errors created by\n+   * their confusion. */\n \n   // parse the qualified path type (required)\n   AST::QualifiedPathType qual_path_type\n@@ -6568,8 +6636,8 @@ Parser<ManagedTokenSource>::parse_qualified_path_type (\n   Location pratt_parsed_loc)\n {\n   Location locus = pratt_parsed_loc;\n-  /* TODO: should this actually be error? is there anywhere where this could be\n-   * valid? */\n+  /* TODO: should this actually be error? is there anywhere where this could\n+   * be valid? */\n   if (locus == Linemap::unknown_location ())\n     {\n       locus = lexer.peek_token ()->get_locus ();\n@@ -6612,8 +6680,8 @@ Parser<ManagedTokenSource>::parse_qualified_path_type (\n \t}\n     }\n \n-  /* NOTE: should actually be a right-angle token, so skip_generics_right_angle\n-   * shouldn't be required */\n+  /* NOTE: should actually be a right-angle token, so\n+   * skip_generics_right_angle shouldn't be required */\n   if (!skip_token (RIGHT_ANGLE))\n     {\n       // skip after somewhere?\n@@ -6845,9 +6913,9 @@ Parser<ManagedTokenSource>::parse_method ()\n \n   if (!skip_token (RIGHT_PAREN))\n     {\n-      Error error (\n-\tlexer.peek_token ()->get_locus (),\n-\t\"method declaration missing closing parentheses after parameter list\");\n+      Error error (lexer.peek_token ()->get_locus (),\n+\t\t   \"method declaration missing closing parentheses after \"\n+\t\t   \"parameter list\");\n       add_error (std::move (error));\n \n       skip_after_next_block ();\n@@ -6887,15 +6955,17 @@ std::unique_ptr<AST::ExprStmt>\n Parser<ManagedTokenSource>::parse_expr_stmt (AST::AttrVec outer_attrs,\n \t\t\t\t\t     ParseRestrictions restrictions)\n {\n-  /* potential thoughts - define new virtual method \"has_block()\" on expr. parse\n-   * expr and then determine whether semicolon is needed as a result of this\n-   * method. but then this would require dynamic_cast, which is not allowed. */\n+  /* potential thoughts - define new virtual method \"has_block()\" on expr.\n+   * parse expr and then determine whether semicolon is needed as a result of\n+   * this method. but then this would require dynamic_cast, which is not\n+   * allowed. */\n \n   /* okay new thought - big switch to disambiguate exprs with blocks - either\n-   * block expr, async block expr, unsafe block expr, loop expr, if expr, if let\n-   * expr, or match expr. So all others are exprs without block. */\n-  /* new thought: possible initial tokens: 'loop', 'while', 'for', lifetime (and\n-   * then ':' and then loop), 'if', 'match', '{', 'async', 'unsafe' (and then\n+   * block expr, async block expr, unsafe block expr, loop expr, if expr, if\n+   * let expr, or match expr. So all others are exprs without block. */\n+  /* new thought: possible initial tokens: 'loop', 'while', 'for', lifetime\n+   * (and then ':' and then loop), 'if', 'match', '{', 'async', 'unsafe' (and\n+   * then\n    * '{')). This seems to have no ambiguity. */\n \n   const_TokenPtr t = lexer.peek_token ();\n@@ -6929,8 +6999,8 @@ Parser<ManagedTokenSource>::parse_expr_stmt (AST::AttrVec outer_attrs,\n \t  }\n       }\n       case UNSAFE: {\n-\t/* FIXME: are there any expressions without blocks that can have unsafe\n-\t * as their first token? Or is unsafe the only one? */\n+\t/* FIXME: are there any expressions without blocks that can have\n+\t * unsafe as their first token? Or is unsafe the only one? */\n \t// safe side for now\n \tif (lexer.peek_token (1)->get_id () == LEFT_CURLY)\n \t  {\n@@ -6944,9 +7014,9 @@ Parser<ManagedTokenSource>::parse_expr_stmt (AST::AttrVec outer_attrs,\n       }\n     default:\n       // not a parse expr with block, so must be expr without block\n-      /* TODO: if possible, be more selective about possible expr without block\n-       * initial tokens in order to prevent more syntactical errors at parse\n-       * time. */\n+      /* TODO: if possible, be more selective about possible expr without\n+       * block initial tokens in order to prevent more syntactical errors at\n+       * parse time. */\n       return parse_expr_stmt_without_block (std::move (outer_attrs),\n \t\t\t\t\t    restrictions);\n     }\n@@ -7066,8 +7136,8 @@ std::unique_ptr<AST::ExprStmtWithoutBlock>\n Parser<ManagedTokenSource>::parse_expr_stmt_without_block (\n   AST::AttrVec outer_attrs, ParseRestrictions restrictions)\n {\n-  /* TODO: maybe move more logic for expr without block in here for better error\n-   * handling */\n+  /* TODO: maybe move more logic for expr without block in here for better\n+   * error handling */\n \n   // attempt to parse via parse_expr_without_block - seems to work\n   std::unique_ptr<AST::ExprWithoutBlock> expr = nullptr;\n@@ -7118,30 +7188,32 @@ Parser<ManagedTokenSource>::parse_expr_without_block (\n    *  - await expr            expr '.' 'await'\n    *  - (array/slice) index expr  expr '[' expr ']'\n    *  - tuple expr            '(' inner_attributes tuple_elems? ')'\n-   *      note that a single elem tuple is distinguished from a grouped expr by\n-   * a trailing comma, i.e. a grouped expr is preferred over a tuple expr\n+   *      note that a single elem tuple is distinguished from a grouped expr\n+   * by a trailing comma, i.e. a grouped expr is preferred over a tuple expr\n    *  - tuple index expr      expr '.' tuple_index\n    *  - struct expr           path_in_expr (and optional other stuff)\n    *  - enum variant expr     path_in_expr (and optional other stuff)\n    *      this means that there is no syntactic difference between an enum\n    * variant and a struct\n-   *      - only name resolution can tell the difference. Thus, maybe rework AST\n-   * to take this into account (\"struct or enum\" nodes?)\n+   *      - only name resolution can tell the difference. Thus, maybe rework\n+   * AST to take this into account (\"struct or enum\" nodes?)\n    *  - (function) call expr  expr '(' call_params? ')'\n    *  - method call expr      expr '.' path_expr_segment '(' call_params? ')'\n    *  - field expr            expr '.' identifier\n    *      note that method call expr is preferred, i.e. field expr must not be\n    * followed by parenthesised expression sequence.\n-   *  - closure expr          'move'? ( '||' | '|' closure_params? '|' ) ( expr\n-   * | '->' type_no_bounds block_expr )\n+   *  - closure expr          'move'? ( '||' | '|' closure_params? '|' ) (\n+   * expr | '->' type_no_bounds block_expr )\n    *  - continue expr         'continue' labelled_lifetime?\n    *  - break expr            'break' labelled_lifetime? expr?\n-   *  - range expr            many different types but all involve '..' or '..='\n+   *  - range expr            many different types but all involve '..' or\n+   * '..='\n    *  - return expr           'return' as 1st tok\n    *  - macro invocation      identifier then :: or identifier then !\n    * (simple_path '!')\n    *\n-   * any that have rules beginning with 'expr' should probably be pratt-parsed,\n+   * any that have rules beginning with 'expr' should probably be\n+   * pratt-parsed,\n    * with parsing type to use determined by token AND lookahead. */\n \n   // ok well at least can do easy ones\n@@ -7164,8 +7236,10 @@ Parser<ManagedTokenSource>::parse_expr_without_block (\n       // array expr (creation, not index)\n       return parse_array_expr (std::move (outer_attrs));\n     case LEFT_PAREN:\n-      /* either grouped expr or tuple expr - depends on whether there is a comma\n-       * inside the parentheses - if so, tuple expr, otherwise, grouped expr. */\n+      /* either grouped expr or tuple expr - depends on whether there is a\n+       * comma\n+       * inside the parentheses - if so, tuple expr, otherwise, grouped expr.\n+       */\n       return parse_grouped_or_tuple_expr (std::move (outer_attrs));\n       default: {\n \t/* HACK: piggyback on pratt parsed expr and abuse polymorphism to\n@@ -8179,8 +8253,8 @@ Parser<ManagedTokenSource>::parse_for_loop_expr (AST::AttrVec outer_attrs,\n       return nullptr;\n     }\n \n-  /* parse iterator expression, which is required - also HACK to prevent struct\n-   * expr */\n+  /* parse iterator expression, which is required - also HACK to prevent\n+   * struct expr */\n   ParseRestrictions no_struct_expr;\n   no_struct_expr.can_be_struct_expr = false;\n   std::unique_ptr<AST::Expr> expr = parse_expr ({}, no_struct_expr);\n@@ -8219,8 +8293,8 @@ std::unique_ptr<AST::BaseLoopExpr>\n Parser<ManagedTokenSource>::parse_labelled_loop_expr (AST::AttrVec outer_attrs)\n {\n   /* TODO: decide whether it should not work if there is no label, or parse it\n-   * with no label at the moment, I will make it not work with no label because\n-   * that's the implication. */\n+   * with no label at the moment, I will make it not work with no label\n+   * because that's the implication. */\n \n   if (lexer.peek_token ()->get_id () != LIFETIME)\n     {\n@@ -8304,8 +8378,8 @@ Parser<ManagedTokenSource>::parse_match_expr (AST::AttrVec outer_attrs,\n       // skip somewhere?\n       return nullptr;\n     }\n-  /* TODO: check for scrutinee expr not being struct expr? or do so in semantic\n-   * analysis */\n+  /* TODO: check for scrutinee expr not being struct expr? or do so in\n+   * semantic analysis */\n \n   if (!skip_token (LEFT_CURLY))\n     {\n@@ -8483,9 +8557,9 @@ Parser<ManagedTokenSource>::parse_match_arm ()\n \t\t\tstd::move (guard_expr), std::move (outer_attrs));\n }\n \n-/* Parses the patterns used in a match arm. End token id is the id of the token\n- * that would exist after the patterns are done (e.g. '}' for match expr, '='\n- * for if let and while let). */\n+/* Parses the patterns used in a match arm. End token id is the id of the\n+ * token that would exist after the patterns are done (e.g. '}' for match\n+ * expr, '=' for if let and while let). */\n template <typename ManagedTokenSource>\n std::vector<std::unique_ptr<AST::Pattern>>\n Parser<ManagedTokenSource>::parse_match_arm_patterns (TokenId end_token_id)\n@@ -8494,8 +8568,8 @@ Parser<ManagedTokenSource>::parse_match_arm_patterns (TokenId end_token_id)\n   if (lexer.peek_token ()->get_id () == PIPE)\n     lexer.skip_token ();\n   /* TODO: do I even need to store the result of this? can't be used.\n-   * If semantically different, I need a wrapped \"match arm patterns\" object for\n-   * this. */\n+   * If semantically different, I need a wrapped \"match arm patterns\" object\n+   * for this. */\n \n   std::vector<std::unique_ptr<AST::Pattern>> patterns;\n \n@@ -8925,14 +8999,16 @@ Parser<ManagedTokenSource>::parse_type ()\n    *  TraitBound              '?'? ForLifetimes? TypePath | '(' '?'?\n    * ForLifetimes? TypePath ')' BareFunctionType:        ForLifetimes?\n    * FunctionQualifiers 'fn' etc. ForLifetimes (not type) 'for' '<'\n-   * LifetimeParams '>' FunctionQualifiers      ( 'async' | 'const' )? 'unsafe'?\n-   * ('extern' abi?)? QualifiedPathInType:     '<' Type ( 'as' TypePath )? '>' (\n+   * LifetimeParams '>' FunctionQualifiers      ( 'async' | 'const' )?\n+   * 'unsafe'?\n+   * ('extern' abi?)? QualifiedPathInType:     '<' Type ( 'as' TypePath )? '>'\n+   * (\n    * '::' TypePathSegment )+ TypePath:                '::'? TypePathSegment (\n    * '::' TypePathSegment)* ArrayType:               '[' Type ';' Expr ']'\n    * ReferenceType:           '&' Lifetime? 'mut'? TypeNoBounds\n    * RawPointerType:          '*' ( 'mut' | 'const' ) TypeNoBounds\n-   * TupleType:               '(' Type etc. - regular tuple stuff. Also regular\n-   * tuple vs parenthesised precedence\n+   * TupleType:               '(' Type etc. - regular tuple stuff. Also\n+   * regular tuple vs parenthesised precedence\n    *\n    * Disambiguate between macro and type path via type path being parsed, and\n    * then if '!' found, convert type path to simple path for macro. Usual\n@@ -8999,10 +9075,10 @@ Parser<ManagedTokenSource>::parse_type ()\n \t/* for parsing path component of each rule, perhaps parse it as a\n \t * typepath and attempt conversion to simplepath if a trailing '!' is\n \t * found */\n-\t/* Type path also includes TraitObjectTypeOneBound BUT if it starts with\n-\t * it, it is exactly the same as a TypePath syntactically, so this is a\n-\t * syntactical ambiguity. As such, the parser will parse it as a\n-\t * TypePath. This, however, does not prevent TraitObjectType from\n+\t/* Type path also includes TraitObjectTypeOneBound BUT if it starts\n+\t * with it, it is exactly the same as a TypePath syntactically, so\n+\t * this is a syntactical ambiguity. As such, the parser will parse it\n+\t * as a TypePath. This, however, does not prevent TraitObjectType from\n \t * starting with a typepath. */\n \n \t// parse path as type path\n@@ -9082,9 +9158,9 @@ Parser<ManagedTokenSource>::parse_type ()\n \t  }\n       }\n     case LEFT_PAREN:\n-      /* tuple type or parenthesised type - requires further disambiguation (the\n-       * usual). ok apparently can be a parenthesised TraitBound too, so could\n-       * be TraitObjectTypeOneBound or TraitObjectType */\n+      /* tuple type or parenthesised type - requires further disambiguation\n+       * (the usual). ok apparently can be a parenthesised TraitBound too, so\n+       * could be TraitObjectTypeOneBound or TraitObjectType */\n       return parse_paren_prefixed_type ();\n     case FOR:\n       // TraitObjectTypeOneBound or BareFunctionType\n@@ -9245,15 +9321,15 @@ Parser<ManagedTokenSource>::parse_type ()\n }\n \n /* Parses a type that has '(' as its first character. Returns a tuple type,\n- * parenthesised type, TraitObjectTypeOneBound, or TraitObjectType depending on\n- * following characters. */\n+ * parenthesised type, TraitObjectTypeOneBound, or TraitObjectType depending\n+ * on following characters. */\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::Type>\n Parser<ManagedTokenSource>::parse_paren_prefixed_type ()\n {\n-  /* NOTE: Syntactical ambiguity of a parenthesised trait bound is considered a\n-   * trait bound, not a parenthesised type, so that it can still be used in type\n-   * param bounds. */\n+  /* NOTE: Syntactical ambiguity of a parenthesised trait bound is considered\n+   * a trait bound, not a parenthesised type, so that it can still be used in\n+   * type param bounds. */\n \n   /* NOTE: this implementation is really shit but I couldn't think of a better\n    * one. It requires essentially breaking polymorphism and downcasting via\n@@ -9379,12 +9455,12 @@ Parser<ManagedTokenSource>::parse_paren_prefixed_type ()\n       return std::unique_ptr<AST::TupleType> (\n \tnew AST::TupleType (std::move (types), left_delim_locus));\n     }\n-  /* TODO: ensure that this ensures that dynamic dispatch for traits is not lost\n-   * somehow */\n+  /* TODO: ensure that this ensures that dynamic dispatch for traits is not\n+   * lost somehow */\n }\n \n-/* Parses a type that has 'for' as its first character. This means it has a \"for\n- * lifetimes\", so returns either a BareFunctionType, TraitObjectType, or\n+/* Parses a type that has 'for' as its first character. This means it has a\n+ * \"for lifetimes\", so returns either a BareFunctionType, TraitObjectType, or\n  * TraitObjectTypeOneBound depending on following characters. */\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::Type>\n@@ -9703,8 +9779,8 @@ Parser<ManagedTokenSource>::parse_raw_pointer_type ()\n     new AST::RawPointerType (kind, std::move (type), locus));\n }\n \n-/* Parses a slice or array type, depending on following arguments (as lookahead\n- * is not possible). */\n+/* Parses a slice or array type, depending on following arguments (as\n+ * lookahead is not possible). */\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::TypeNoBounds>\n Parser<ManagedTokenSource>::parse_slice_or_array_type ()\n@@ -9828,10 +9904,10 @@ Parser<ManagedTokenSource>::parse_type_no_bounds ()\n \t/* for parsing path component of each rule, perhaps parse it as a\n \t * typepath and attempt conversion to simplepath if a trailing '!' is\n \t * found */\n-\t/* Type path also includes TraitObjectTypeOneBound BUT if it starts with\n-\t * it, it is exactly the same as a TypePath syntactically, so this is a\n-\t * syntactical ambiguity. As such, the parser will parse it as a\n-\t * TypePath. This, however, does not prevent TraitObjectType from\n+\t/* Type path also includes TraitObjectTypeOneBound BUT if it starts\n+\t * with it, it is exactly the same as a TypePath syntactically, so\n+\t * this is a syntactical ambiguity. As such, the parser will parse it\n+\t * as a TypePath. This, however, does not prevent TraitObjectType from\n \t * starting with a typepath. */\n \n \t// parse path as type path\n@@ -9882,9 +9958,9 @@ Parser<ManagedTokenSource>::parse_type_no_bounds ()\n \t  }\n       }\n     case LEFT_PAREN:\n-      /* tuple type or parenthesised type - requires further disambiguation (the\n-       * usual). ok apparently can be a parenthesised TraitBound too, so could\n-       * be TraitObjectTypeOneBound */\n+      /* tuple type or parenthesised type - requires further disambiguation\n+       * (the usual). ok apparently can be a parenthesised TraitBound too, so\n+       * could be TraitObjectTypeOneBound */\n       return parse_paren_prefixed_type_no_bounds ();\n     case FOR:\n     case ASYNC:\n@@ -9954,8 +10030,8 @@ Parser<ManagedTokenSource>::parse_type_no_bounds ()\n \n \tif (lexer.peek_token ()->get_id () == LIFETIME)\n \t  {\n-\t    /* means that cannot be TraitObjectTypeOneBound - so here for error\n-\t     * message */\n+\t    /* means that cannot be TraitObjectTypeOneBound - so here for\n+\t     * error message */\n \t    Error error (lexer.peek_token ()->get_locus (),\n \t\t\t \"lifetime as bound in TraitObjectTypeOneBound \"\n \t\t\t \"is not allowed, so cannot be TypeNoBounds\");\n@@ -10015,8 +10091,8 @@ Parser<ManagedTokenSource>::parse_paren_prefixed_type_no_bounds ()\n    * parse_paren_prefixed_type, but I was lazy. So FIXME for future.*/\n \n   /* NOTE: again, syntactical ambiguity of a parenthesised trait bound is\n-   * considered a trait bound, not a parenthesised type, so that it can still be\n-   * used in type param bounds. */\n+   * considered a trait bound, not a parenthesised type, so that it can still\n+   * be used in type param bounds. */\n \n   Location left_paren_locus = lexer.peek_token ()->get_locus ();\n \n@@ -10105,8 +10181,8 @@ Parser<ManagedTokenSource>::parse_paren_prefixed_type_no_bounds ()\n       return std::unique_ptr<AST::TupleType> (\n \tnew AST::TupleType (std::move (types), left_paren_locus));\n     }\n-  /* TODO: ensure that this ensures that dynamic dispatch for traits is not lost\n-   * somehow */\n+  /* TODO: ensure that this ensures that dynamic dispatch for traits is not\n+   * lost somehow */\n }\n \n /* Parses a literal pattern or range pattern. Assumes that literals passed in\n@@ -10353,7 +10429,8 @@ Parser<ManagedTokenSource>::parse_pattern ()\n       return std::unique_ptr<AST::LiteralPattern> (\n \tnew AST::LiteralPattern (t->get_str (), AST::Literal::BYTE_STRING,\n \t\t\t\t t->get_locus ()));\n-    // raw string and raw byte string literals too if they are readded to lexer\n+    // raw string and raw byte string literals too if they are readded to\n+    // lexer\n     case MINUS:\n       if (lexer.peek_token (1)->get_id () == INT_LITERAL)\n \t{\n@@ -10379,9 +10456,10 @@ Parser<ManagedTokenSource>::parse_pattern ()\n     case MUT:\n       return parse_identifier_pattern ();\n     case IDENTIFIER:\n-      /* if identifier with no scope resolution afterwards, identifier pattern.\n-       * if scope resolution afterwards, path pattern (or range pattern or\n-       * struct pattern or tuple struct pattern) or macro invocation */\n+      /* if identifier with no scope resolution afterwards, identifier\n+       * pattern. if scope resolution afterwards, path pattern (or range\n+       * pattern or struct pattern or tuple struct pattern) or macro\n+       * invocation */\n       return parse_ident_leading_pattern ();\n     case AMP:\n     case LOGICAL_AND:\n@@ -10568,8 +10646,8 @@ Parser<ManagedTokenSource>::parse_reference_pattern ()\n \t\t\t       t->get_locus ()));\n }\n \n-/* Parses a grouped pattern or tuple pattern. Prefers grouped over tuple if only\n- * a single element with no commas. */\n+/* Parses a grouped pattern or tuple pattern. Prefers grouped over tuple if\n+ * only a single element with no commas. */\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::Pattern>\n Parser<ManagedTokenSource>::parse_grouped_or_tuple_pattern ()\n@@ -11357,7 +11435,8 @@ Parser<ManagedTokenSource>::parse_stmt_or_expr_with_block (\n   if (tok->get_id () == RIGHT_CURLY)\n     return ExprOrStmt (std::move (expr));\n \n-  // internal block expr must either have semicolons followed, or evaluate to ()\n+  // internal block expr must either have semicolons followed, or evaluate to\n+  // ()\n   auto locus = expr->get_locus ();\n   std::unique_ptr<AST::ExprStmtWithBlock> stmt (\n     new AST::ExprStmtWithBlock (std::move (expr), locus,\n@@ -11390,16 +11469,16 @@ Parser<ManagedTokenSource>::parse_stmt_or_expr_without_block ()\n \n   // parsing this will be annoying because of the many different possibilities\n   /* best may be just to copy paste in parse_item switch, and failing that try\n-   * to parse outer attributes, and then pass them in to either a let statement\n-   * or (fallback) expression statement. */\n+   * to parse outer attributes, and then pass them in to either a let\n+   * statement or (fallback) expression statement. */\n   // FIXME: think of a way to do this without such a large switch?\n \n   /* FIXME: for expressions at least, the only way that they can really be\n    * parsed properly in this way is if they don't support operators on them.\n    * They must be pratt-parsed otherwise. As such due to composability, only\n    * explicit statements will have special cases here. This should roughly\n-   * correspond to \"expr-with-block\", but this warning is here in case it isn't\n-   * the case. */\n+   * correspond to \"expr-with-block\", but this warning is here in case it\n+   * isn't the case. */\n   t = lexer.peek_token ();\n   switch (t->get_id ())\n     {\n@@ -11495,8 +11574,8 @@ Parser<ManagedTokenSource>::parse_stmt_or_expr_without_block ()\n       }\n       /* FIXME: this is either a macro invocation or macro invocation semi.\n        * start parsing to determine which one it is. */\n-      // FIXME: or this is another path-based thing - struct/enum or path itself\n-      // return parse_path_based_stmt_or_expr(std::move(outer_attrs));\n+      // FIXME: or this is another path-based thing - struct/enum or path\n+      // itself return parse_path_based_stmt_or_expr(std::move(outer_attrs));\n       // FIXME: old code there\n     case LOOP:\n     case WHILE:\n@@ -11560,9 +11639,9 @@ Parser<ManagedTokenSource>::parse_stmt_or_expr_without_block ()\n \t       || lexer.peek_token (1)->get_id () == EXCLAM\n \t       || lexer.peek_token (1)->get_id () == LEFT_CURLY)\n \t{\n-\t  /* path (probably) or macro invocation or struct or enum, so probably\n-\t   * a macro invocation semi decide how to parse - probably parse path\n-\t   * and then get macro from it */\n+\t  /* path (probably) or macro invocation or struct or enum, so\n+\t   * probably a macro invocation semi decide how to parse - probably\n+\t   * parse path and then get macro from it */\n \n \t  // FIXME: old code was good until composability was required\n \t  // return parse_path_based_stmt_or_expr(std::move(outer_attrs));\n@@ -11625,8 +11704,8 @@ Parser<ManagedTokenSource>::parse_path_based_stmt_or_expr (\n   switch (t2->get_id ())\n     {\n       case EXCLAM: {\n-\t/* macro invocation or macro invocation semi - depends on whether there\n-\t * is a final ';' */\n+\t/* macro invocation or macro invocation semi - depends on whether\n+\t * there is a final ';' */\n \t// convert path in expr to simple path (as that is used in macros)\n \tAST::SimplePath macro_path = path.as_simple_path ();\n \tif (macro_path.is_empty ())\n@@ -11682,11 +11761,11 @@ Parser<ManagedTokenSource>::parse_path_based_stmt_or_expr (\n \n \t    if (tree == nullptr)\n \t      {\n-\t\tError error (\n-\t\t  t3->get_locus (),\n-\t\t  \"failed to parse token tree for macro invocation (or semi) - \"\n-\t\t  \"found %qs\",\n-\t\t  t3->get_token_description ());\n+\t\tError error (t3->get_locus (),\n+\t\t\t     \"failed to parse token tree for macro \"\n+\t\t\t     \"invocation (or semi) - \"\n+\t\t\t     \"found %qs\",\n+\t\t\t     t3->get_token_description ());\n \t\tadd_error (std::move (error));\n \n \t\treturn ExprOrStmt::create_error ();\n@@ -11710,9 +11789,9 @@ Parser<ManagedTokenSource>::parse_path_based_stmt_or_expr (\n \n \t    /* with curly bracketed macros, assume it is a macro invocation\n \t     * unless a semicolon is explicitly put at the end. this is not\n-\t     * necessarily true (i.e. context-dependence) and so may have to be\n-\t     * fixed up via HACKs in semantic analysis (by checking whether it\n-\t     * is the last elem in the vector). */\n+\t     * necessarily true (i.e. context-dependence) and so may have to\n+\t     * be fixed up via HACKs in semantic analysis (by checking whether\n+\t     * it is the last elem in the vector). */\n \n \t    AST::DelimTokenTree delim_tok_tree (type, std::move (token_trees),\n \t\t\t\t\t\ttok_tree_loc);\n@@ -11767,8 +11846,8 @@ Parser<ManagedTokenSource>::parse_path_based_stmt_or_expr (\n \n \tif (not_a_block)\n \t  {\n-\t    /* assume struct expr struct (as struct-enum disambiguation requires\n-\t     * name lookup) again, make statement if final ';' */\n+\t    /* assume struct expr struct (as struct-enum disambiguation\n+\t     * requires name lookup) again, make statement if final ';' */\n \t    expr = parse_struct_expr_struct_partial (std::move (path),\n \t\t\t\t\t\t     std::move (outer_attrs));\n \t    if (expr == nullptr)\n@@ -11806,8 +11885,8 @@ Parser<ManagedTokenSource>::parse_path_based_stmt_or_expr (\n \treturn ExprOrStmt (std::move (expr));\n       }\n       case LEFT_PAREN: {\n-\t/* assume struct expr tuple (as struct-enum disambiguation requires name\n-\t * lookup) again, make statement if final ';' */\n+\t/* assume struct expr tuple (as struct-enum disambiguation requires\n+\t * name lookup) again, make statement if final ';' */\n \tstd::unique_ptr<AST::CallExpr> struct_expr\n \t  = parse_struct_expr_tuple_partial (std::move (path),\n \t\t\t\t\t     std::move (outer_attrs));\n@@ -11927,8 +12006,8 @@ Parser<ManagedTokenSource>::parse_struct_expr_field ()\n \t\t\t\t\t      t->get_locus ()));\n       }\n     case DOT_DOT:\n-      /* this is a struct base and can't be parsed here, so just return nothing\n-       * without erroring */\n+      /* this is a struct base and can't be parsed here, so just return\n+       * nothing without erroring */\n \n       return nullptr;\n     default:\n@@ -12031,8 +12110,8 @@ Parser<ManagedTokenSource>::parse_macro_invocation_maybe_semi (\n       /* with curly bracketed macros, assume it is a macro invocation unless\n        * a semicolon is explicitly put at the end. this is not necessarily\n        * true (i.e. context-dependence) and so may have to be fixed up via\n-       * HACKs in semantic analysis (by checking whether it is the last elem in\n-       * the vector). */\n+       * HACKs in semantic analysis (by checking whether it is the last elem\n+       * in the vector). */\n \n       AST::DelimTokenTree delim_tok_tree (type, std::move (token_trees),\n \t\t\t\t\t  tok_tree_loc);\n@@ -12193,8 +12272,8 @@ Parser<ManagedTokenSource>::skip_after_end_block ()\n     }\n }\n \n-/* Skips tokens until the end of the next block. i.e. assumes that the block has\n- * not been entered yet. */\n+/* Skips tokens until the end of the next block. i.e. assumes that the block\n+ * has not been entered yet. */\n template <typename ManagedTokenSource>\n void\n Parser<ManagedTokenSource>::skip_after_next_block ()\n@@ -12219,8 +12298,8 @@ Parser<ManagedTokenSource>::skip_after_next_block ()\n   // otherwise, do nothing as EOF\n }\n \n-/* Skips all tokens until ] (the end of an attribute) - does not skip the ] (as\n- * designed for attribute body use) */\n+/* Skips all tokens until ] (the end of an attribute) - does not skip the ]\n+ * (as designed for attribute body use) */\n template <typename ManagedTokenSource>\n void\n Parser<ManagedTokenSource>::skip_after_end_attribute ()\n@@ -12236,8 +12315,8 @@ Parser<ManagedTokenSource>::skip_after_end_attribute ()\n   // Don't skip the RIGHT_SQUARE token\n }\n \n-/* Pratt parser impl of parse_expr. FIXME: this is only provisional and probably\n- * will be changed.\n+/* Pratt parser impl of parse_expr. FIXME: this is only provisional and\n+ * probably will be changed.\n  * FIXME: this may only parse expressions without blocks as they are the only\n  * expressions to have precedence? */\n template <typename ManagedTokenSource>\n@@ -12469,9 +12548,9 @@ Parser<ManagedTokenSource>::null_denotation (const_TokenPtr tok,\n \t      return nullptr;\n \t  // can only apply to integer and float expressions\n \t  if (expr->get_type() != integer_type_node || expr->get_type() !=\n-      float_type_node) { rust_error_at(tok->get_locus(), \"operand of unary plus\n-      must be int or float but it is %s\", print_type(expr->get_type())); return\n-      nullptr;\n+      float_type_node) { rust_error_at(tok->get_locus(), \"operand of unary\n+      plus must be int or float but it is %s\", print_type(expr->get_type()));\n+      return nullptr;\n \t  }\n \n \t  return Tree(expr, tok->get_locus());\n@@ -12490,15 +12569,16 @@ Parser<ManagedTokenSource>::null_denotation (const_TokenPtr tok,\n \t// can only apply to integer and float expressions\n \t/*if (expr.get_type() != integer_type_node || expr.get_type() !=\n \tfloat_type_node) { rust_error_at(tok->get_locus(), \"operand of unary\n-\tminus must be int or float but it is %s\", print_type(expr.get_type()));\n-\t    return Tree::error();\n+\tminus must be int or float but it is %s\",\n+\tprint_type(expr.get_type())); return Tree::error();\n \t}*/\n \t/* FIXME: when implemented the \"get type\" method on expr, ensure it is\n \t * int or float type (except unsigned int). Actually, this would\n-\t * probably have to be done in semantic analysis (as type checking). */\n+\t * probably have to be done in semantic analysis (as type checking).\n+\t */\n \n-\t/* FIXME: allow outer attributes on these expressions by having an outer\n-\t * attrs parameter in function*/\n+\t/* FIXME: allow outer attributes on these expressions by having an\n+\t * outer attrs parameter in function*/\n \treturn std::unique_ptr<AST::NegationExpr> (\n \t  new AST::NegationExpr (std::move (expr), NegationOperator::NEGATE,\n \t\t\t\t std::move (outer_attrs), tok->get_locus ()));\n@@ -12529,8 +12609,8 @@ Parser<ManagedTokenSource>::null_denotation (const_TokenPtr tok,\n \t\t\t\t std::move (outer_attrs), tok->get_locus ()));\n       }\n       case ASTERISK: {\n-\t/* pointer dereference only - HACK: as struct expressions should always\n-\t * be value expressions, cannot be dereferenced */\n+\t/* pointer dereference only - HACK: as struct expressions should\n+\t * always be value expressions, cannot be dereferenced */\n \tParseRestrictions entered_from_unary;\n \tentered_from_unary.entered_from_unary = true;\n \tentered_from_unary.can_be_struct_expr = false;\n@@ -12620,7 +12700,8 @@ Parser<ManagedTokenSource>::null_denotation (const_TokenPtr tok,\n \t  \"token is '%s'\",\n \t  lexer.peek_token ()->get_token_description ());\n \n-\t// HACK: always make \"self\" by itself a path (regardless of next tokens)\n+\t// HACK: always make \"self\" by itself a path (regardless of next\n+\t// tokens)\n \tif (tok->get_id () == SELF && path.is_single_segment ())\n \t  {\n \t    // HACK: add outer attrs to path\n@@ -12742,8 +12823,8 @@ Parser<ManagedTokenSource>::null_denotation (const_TokenPtr tok,\n }\n \n /* Called for each token that can appear in infix (between) position. Can be\n- * operators or other punctuation. Returns a function pointer to member function\n- * that implements the left denotation for the token given. */\n+ * operators or other punctuation. Returns a function pointer to member\n+ * function that implements the left denotation for the token given. */\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::Expr>\n Parser<ManagedTokenSource>::left_denotation (const_TokenPtr tok,\n@@ -12773,7 +12854,8 @@ Parser<ManagedTokenSource>::left_denotation (const_TokenPtr tok,\n     case MINUS:\n       // difference expression - binary infix\n       /*return parse_binary_minus_expr (tok, std::move (left),\n-\t\t\t\t      std::move (outer_attrs), restrictions);*/\n+\t\t\t\t      std::move (outer_attrs),\n+\t restrictions);*/\n       return parse_arithmetic_or_logical_expr (\n \ttok, std::move (left), std::move (outer_attrs),\n \tArithmeticOrLogicalOperator::SUBTRACT, restrictions);\n@@ -12836,7 +12918,8 @@ Parser<ManagedTokenSource>::left_denotation (const_TokenPtr tok,\n     case EQUAL_EQUAL:\n       // equal to expression - binary infix (no associativity)\n       /*return parse_binary_equal_expr (tok, std::move (left),\n-\t\t\t\t      std::move (outer_attrs), restrictions);*/\n+\t\t\t\t      std::move (outer_attrs),\n+\t restrictions);*/\n       return parse_comparison_expr (tok, std::move (left),\n \t\t\t\t    std::move (outer_attrs),\n \t\t\t\t    ComparisonOperator::EQUAL, restrictions);\n@@ -12899,7 +12982,8 @@ Parser<ManagedTokenSource>::left_denotation (const_TokenPtr tok,\n       return parse_type_cast_expr (tok, std::move (left),\n \t\t\t\t   std::move (outer_attrs), restrictions);\n     case EQUAL:\n-      // assignment expression - binary infix (note right-to-left associativity)\n+      // assignment expression - binary infix (note right-to-left\n+      // associativity)\n       return parse_assig_expr (tok, std::move (left), std::move (outer_attrs),\n \t\t\t       restrictions);\n     case PLUS_EQ:\n@@ -12998,7 +13082,8 @@ Parser<ManagedTokenSource>::left_denotation (const_TokenPtr tok,\n       return parse_range_inclusive_expr (tok, std::move (left),\n \t\t\t\t\t std::move (outer_attrs), restrictions);\n     case SCOPE_RESOLUTION:\n-      // path expression - binary infix? FIXME should this even be parsed here?\n+      // path expression - binary infix? FIXME should this even be parsed\n+      // here?\n       add_error (\n \tError (tok->get_locus (),\n \t       \"found scope resolution operator in left denotation \"\n@@ -13375,8 +13460,8 @@ get_lbp_for_comparison_expr (AST::ComparisonExpr::ExprType expr_type)\n }\n \n /* Parses a ComparisonExpr of given type and LBP. TODO find a way to only\n- * specify one and have the other looked up - e.g. specify ExprType and binding\n- * power is looked up? */\n+ * specify one and have the other looked up - e.g. specify ExprType and\n+ * binding power is looked up? */\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::ComparisonExpr>\n Parser<ManagedTokenSource>::parse_comparison_expr (\n@@ -14093,8 +14178,8 @@ Parser<ManagedTokenSource>::parse_field_access_expr (\n   const_TokenPtr tok ATTRIBUTE_UNUSED, std::unique_ptr<AST::Expr> struct_expr,\n   AST::AttrVec outer_attrs, ParseRestrictions restrictions ATTRIBUTE_UNUSED)\n {\n-  /* get field name identifier (assume that this is a field access expr and not\n-   * await, for instance) */\n+  /* get field name identifier (assume that this is a field access expr and\n+   * not await, for instance) */\n   const_TokenPtr ident_tok = expect_token (IDENTIFIER);\n   if (ident_tok == nullptr)\n     return nullptr;\n@@ -14254,7 +14339,8 @@ Parser<ManagedTokenSource>::parse_macro_invocation_partial (\n     std::move (outer_attrs), macro_locus, restrictions.expr_can_be_stmt));\n }\n \n-/* Parses a struct expr struct with a path in expression already parsed (but not\n+/* Parses a struct expr struct with a path in expression already parsed (but\n+ * not\n  * '{' token). */\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::StructExprStruct>\n@@ -14387,7 +14473,8 @@ Parser<ManagedTokenSource>::parse_struct_expr_struct_partial (\n     }\n }\n \n-/* Parses a struct expr tuple with a path in expression already parsed (but not\n+/* Parses a struct expr tuple with a path in expression already parsed (but\n+ * not\n  * '(' token).\n  * FIXME: this currently outputs a call expr, as they cannot be disambiguated.\n  * A better solution would be to just get this to call that function directly.\n@@ -14413,9 +14500,8 @@ Parser<ManagedTokenSource>::parse_struct_expr_tuple_partial (\n       std::unique_ptr<AST::Expr> expr = parse_expr ();\n       if (expr == nullptr)\n \t{\n-\t  Error error (\n-\t    t->get_locus (),\n-\t    \"failed to parse expression in struct (or enum) expression tuple\");\n+\t  Error error (t->get_locus (), \"failed to parse expression in \"\n+\t\t\t\t\t\"struct (or enum) expression tuple\");\n \t  add_error (std::move (error));\n \n \t  return nullptr;\n@@ -14445,9 +14531,9 @@ Parser<ManagedTokenSource>::parse_struct_expr_tuple_partial (\n \t\t       std::move (outer_attrs), path_locus));\n }\n \n-/* Parses a path in expression with the first token passed as a parameter (as it\n- * is skipped in token stream). Note that this only parses segment-first paths,\n- * not global ones. */\n+/* Parses a path in expression with the first token passed as a parameter (as\n+ * it is skipped in token stream). Note that this only parses segment-first\n+ * paths, not global ones. */\n template <typename ManagedTokenSource>\n AST::PathInExpression\n Parser<ManagedTokenSource>::parse_path_in_expression_pratt (const_TokenPtr tok)\n@@ -14498,8 +14584,8 @@ Parser<ManagedTokenSource>::parse_path_in_expression_pratt (const_TokenPtr tok)\n   // parse required initial segment\n   AST::PathExprSegment initial_segment (initial_str, tok->get_locus ());\n   // parse generic args (and turbofish), if they exist\n-  /* use lookahead to determine if they actually exist (don't want to accidently\n-   * parse over next ident segment) */\n+  /* use lookahead to determine if they actually exist (don't want to\n+   * accidently parse over next ident segment) */\n   if (lexer.peek_token ()->get_id () == SCOPE_RESOLUTION\n       && lexer.peek_token (1)->get_id () == LEFT_ANGLE)\n     {\n@@ -14564,7 +14650,8 @@ std::unique_ptr<AST::ClosureExpr>\n Parser<ManagedTokenSource>::parse_closure_expr_pratt (const_TokenPtr tok,\n \t\t\t\t\t\t      AST::AttrVec outer_attrs)\n {\n-  // TODO: does this need pratt parsing (for precedence)? probably not, but idk\n+  // TODO: does this need pratt parsing (for precedence)? probably not, but\n+  // idk\n   Location locus = tok->get_locus ();\n   bool has_move = false;\n   if (tok->get_id () == MOVE)\n@@ -14741,10 +14828,11 @@ template <typename ManagedTokenSource>\n void\n Parser<ManagedTokenSource>::debug_dump_lex_output (std::ostream &out)\n {\n-  /* TODO: a better implementation of \"lexer dump\" (as in dump what was actually\n-   * tokenised) would actually be to \"write\" a token to a file every time\n-   * skip_token() here was called. This would reflect the parser modifications\n-   * to the token stream, such as fixing the template angle brackets. */\n+  /* TODO: a better implementation of \"lexer dump\" (as in dump what was\n+   * actually tokenised) would actually be to \"write\" a token to a file every\n+   * time skip_token() here was called. This would reflect the parser\n+   * modifications to the token stream, such as fixing the template angle\n+   * brackets. */\n \n   const_TokenPtr tok = lexer.peek_token ();\n "}, {"sha": "bcad8ee6a197cb08f399a0dfdb0574e5ce49e442", "filename": "gcc/testsuite/rust/compile/const_generics_1.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/112d4212fc57a6387e971e6c9d84cbf05bf6d865/gcc%2Ftestsuite%2Frust%2Fcompile%2Fconst_generics_1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/112d4212fc57a6387e971e6c9d84cbf05bf6d865/gcc%2Ftestsuite%2Frust%2Fcompile%2Fconst_generics_1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fconst_generics_1.rs?ref=112d4212fc57a6387e971e6c9d84cbf05bf6d865", "patch": "@@ -0,0 +1,19 @@\n+// { dg-additional-options \"-w\" }\n+\n+// There are errors about unused generic parameters, but we can't handle that yet.\n+// Still, this code is invalid Rust.\n+\n+mod sain {\n+    struct Foo<const N: usize>;\n+    struct Bar<T, const N: usize>;\n+    struct Baz<'l, T, const N: usize>;\n+}\n+\n+mod doux {\n+    struct Foo<const N: usize = 15>;\n+    struct Bar<T, const N: usize = { 14 * 2 }>;\n+\n+    const N_DEFAULT: usize = 3;\n+\n+    struct Baz<'l, T, const N: usize = N_DEFAULT>;\n+}"}, {"sha": "82d2676f7eeada3faf3b9c051c4598b447b65085", "filename": "gcc/testsuite/rust/compile/const_generics_2.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/112d4212fc57a6387e971e6c9d84cbf05bf6d865/gcc%2Ftestsuite%2Frust%2Fcompile%2Fconst_generics_2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/112d4212fc57a6387e971e6c9d84cbf05bf6d865/gcc%2Ftestsuite%2Frust%2Fcompile%2Fconst_generics_2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fconst_generics_2.rs?ref=112d4212fc57a6387e971e6c9d84cbf05bf6d865", "patch": "@@ -0,0 +1,3 @@\n+struct Foo<const N>; // { dg-error \"expecting .:. but .>. found\" }\n+struct Bar<const N: >; // { dg-error \"unrecognised token .>. in type\" }\n+struct Baz<const N: usize = >; // { dg-error \"invalid token for start of default value for const generic parameter\" }"}]}