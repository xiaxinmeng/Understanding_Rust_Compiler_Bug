{"sha": "38ae58ca9fd17ebf4fe679fe7a91472f5d6c37b1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzhhZTU4Y2E5ZmQxN2ViZjRmZTY3OWZlN2E5MTQ3MmY1ZDZjMzdiMQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2013-07-22T21:41:44Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2013-07-22T21:41:44Z"}, "message": "config.gcc (sparc*-*-*): Accept leon3 processor.\n\n\t* config.gcc (sparc*-*-*): Accept leon3 processor.\n\t(sparc-leon*-*): Merge with sparc*-*-* and add leon3 support.\n\t* doc/invoke.texi (SPARC Options): Adjust -mfix-ut699 entry.\n\t* config/sparc/sparc-opts.h (enum processor_type): Add PROCESSOR_LEON3.\n\t* config/sparc/sparc.opt (enum processor_type): Add leon3.\n\t(mfix-ut699): Adjust comment.\n\t* config/sparc/sparc.h (TARGET_CPU_leon3): New define.\n\t(CPP_CPU32_DEFAULT_SPEC): Add leon3 support.\n\t(CPP_CPU_SPEC): Likewise.\n\t(ASM_CPU_SPEC): Likewise.\n\t* config/sparc/sparc.c (leon3_cost): New constant.\n\t(sparc_option_override): Add leon3 support.\n\t(mem_ref): New function.\n\t(sparc_gate_work_around_errata): Return true if -mfix-ut699 is enabled.\n\t(sparc_do_work_around_errata): Look into the instruction in the delay\n\tslot and adjust accordingly.  Add fix for the data cache nullify issues\n\tof the UT699.  Change insertion position for the NOP.\n\t* config/sparc/leon.md (leon_fpalu, leon_fpmds, write_buf): Delete.\n\t(leon3_load): New reservation.\n\t(leon_store): Bump latency to 2.\n\t(grfpu): New automaton.\n\t(grfpu_alu): New unit.\n\t(grfpu_ds): Likewise.\n\t(leon_fp_alu): Adjust.\n\t(leon_fp_mult): Delete.\n\t(leon_fp_div): Split into leon_fp_divs and leon_fp_divd.\n\t(leon_fp_sqrt): Split into leon_fp_sqrts and leon_fp_sqrtd.\n\t* config/sparc/sparc.md (cpu): Add leon3.\n\t* config/sparc/sync.md (atomic_exchangesi): Disable if -mfix-ut699.\n\t(swapsi): Likewise.\n\t(atomic_test_and_set): Likewise.\n\t(ldstub): Likewise.\n\nFrom-SVN: r201147", "tree": {"sha": "456e7a0274b3b7a7b98769954c1ec28425700400", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/456e7a0274b3b7a7b98769954c1ec28425700400"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/38ae58ca9fd17ebf4fe679fe7a91472f5d6c37b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38ae58ca9fd17ebf4fe679fe7a91472f5d6c37b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38ae58ca9fd17ebf4fe679fe7a91472f5d6c37b1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38ae58ca9fd17ebf4fe679fe7a91472f5d6c37b1/comments", "author": null, "committer": null, "parents": [{"sha": "16a1d8fe2955c301ae61a13c4cbf8bd2c83d17f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16a1d8fe2955c301ae61a13c4cbf8bd2c83d17f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16a1d8fe2955c301ae61a13c4cbf8bd2c83d17f0"}], "stats": {"total": 303, "additions": 228, "deletions": 75}, "files": [{"sha": "6999d3f84541430e9207699ca3b16b6418c698e1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38ae58ca9fd17ebf4fe679fe7a91472f5d6c37b1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38ae58ca9fd17ebf4fe679fe7a91472f5d6c37b1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=38ae58ca9fd17ebf4fe679fe7a91472f5d6c37b1", "patch": "@@ -1,3 +1,38 @@\n+2013-07-22  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* config.gcc (sparc*-*-*): Accept leon3 processor.\n+\t(sparc-leon*-*): Merge with sparc*-*-* and add leon3 support.\n+\t* doc/invoke.texi (SPARC Options): Adjust -mfix-ut699 entry.\n+\t* config/sparc/sparc-opts.h (enum processor_type): Add PROCESSOR_LEON3.\n+\t* config/sparc/sparc.opt (enum processor_type): Add leon3.\n+\t(mfix-ut699): Adjust comment.\n+\t* config/sparc/sparc.h (TARGET_CPU_leon3): New define.\n+\t(CPP_CPU32_DEFAULT_SPEC): Add leon3 support.\n+\t(CPP_CPU_SPEC): Likewise.\n+\t(ASM_CPU_SPEC): Likewise.\n+\t* config/sparc/sparc.c (leon3_cost): New constant.\n+\t(sparc_option_override): Add leon3 support.\n+\t(mem_ref): New function.\n+\t(sparc_gate_work_around_errata): Return true if -mfix-ut699 is enabled.\n+\t(sparc_do_work_around_errata): Look into the instruction in the delay\n+\tslot and adjust accordingly.  Add fix for the data cache nullify issues\n+\tof the UT699.  Change insertion position for the NOP.\n+\t* config/sparc/leon.md (leon_fpalu, leon_fpmds, write_buf): Delete.\n+\t(leon3_load): New reservation.\n+\t(leon_store): Bump latency to 2.\n+\t(grfpu): New automaton.\n+\t(grfpu_alu): New unit.\n+\t(grfpu_ds): Likewise.\n+\t(leon_fp_alu): Adjust.\n+\t(leon_fp_mult): Delete.\n+\t(leon_fp_div): Split into leon_fp_divs and leon_fp_divd.\n+\t(leon_fp_sqrt): Split into leon_fp_sqrts and leon_fp_sqrtd.\n+\t* config/sparc/sparc.md (cpu): Add leon3.\n+\t* config/sparc/sync.md (atomic_exchangesi): Disable if -mfix-ut699.\n+\t(swapsi): Likewise.\n+\t(atomic_test_and_set): Likewise.\n+\t(ldstub): Likewise.\n+\n 2013-07-22  J\u00fcrgen Urban  <JuergenUrban@gmx.de>\n \n \t* config.gcc (mips*-*-*): Add --with-fpu support.  Make single the"}, {"sha": "94c21c04eaf715fafae503ef9109046bfea796ab", "filename": "gcc/config.gcc", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38ae58ca9fd17ebf4fe679fe7a91472f5d6c37b1/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38ae58ca9fd17ebf4fe679fe7a91472f5d6c37b1/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=38ae58ca9fd17ebf4fe679fe7a91472f5d6c37b1", "patch": "@@ -3662,7 +3662,7 @@ case \"${target}\" in\n \t\t\tcase ${val} in\n \t\t\t\"\" | sparc | sparcv9 | sparc64 \\\n \t\t\t| v7 | cypress \\\n-\t\t\t| v8 | supersparc | hypersparc | leon \\\n+\t\t\t| v8 | supersparc | hypersparc | leon | leon3 \\\n \t\t\t| sparclite | f930 | f934 | sparclite86x \\\n \t\t\t| sparclet | tsc701 \\\n \t\t\t| v9 | ultrasparc | ultrasparc3 | niagara | niagara2 \\\n@@ -3819,15 +3819,6 @@ case ${target} in\n \t\tcxx_target_objs=\"${cxx_target_objs} sh-c.o\"\n \t\t;;\n \n-\tsparc-leon*-*)\n-\t\tif test x$with_tune = x ; then\n-\t\t  with_tune=leon;\n-\t\tfi\n-\n-\t\t# The SPARC port checks this value at compile-time.\n-\t\ttarget_cpu_default2=\"TARGET_CPU_$with_cpu\"\n-\t\t;;\n-\n \tsparc*-*-*)\n \t\t# Some standard aliases.\n \t\tcase x$with_cpu in\n@@ -3839,6 +3830,17 @@ case ${target} in\n \t\t\t;;\n \t\tesac\n \n+\t\tif test x$with_tune = x ; then\n+\t\t      case ${target} in\n+\t\t      *-leon-*)\n+\t\t\t  with_tune=leon\n+\t\t\t  ;;\n+\t\t      *-leon[3-9]*)\n+\t\t\t  with_tune=leon3\n+\t\t\t  ;;\n+\t\t      esac\n+\t\tfi\n+\n \t\t# The SPARC port checks this value at compile-time.\n \t\ttarget_cpu_default2=\"TARGET_CPU_$with_cpu\"\n \t\t;;"}, {"sha": "b511397fe36546ae9c83878b8a31afcb534216e8", "filename": "gcc/config/sparc/leon.md", "status": "modified", "additions": 37, "deletions": 29, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38ae58ca9fd17ebf4fe679fe7a91472f5d6c37b1/gcc%2Fconfig%2Fsparc%2Fleon.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38ae58ca9fd17ebf4fe679fe7a91472f5d6c37b1/gcc%2Fconfig%2Fsparc%2Fleon.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fleon.md?ref=38ae58ca9fd17ebf4fe679fe7a91472f5d6c37b1", "patch": "@@ -17,40 +17,48 @@\n ;; along with GCC; see the file COPYING3.  If not see\n ;; <http://www.gnu.org/licenses/>.\n \n+;; Leon is a single-issue processor.\n \n (define_automaton \"leon\")\n \n-(define_cpu_unit \"leon_memory, leon_fpalu\" \"leon\")\n-(define_cpu_unit \"leon_fpmds\" \"leon\")\n-(define_cpu_unit \"write_buf\" \"leon\")\n+(define_cpu_unit \"leon_memory\" \"leon\")\n \n (define_insn_reservation \"leon_load\" 1\n-  (and (eq_attr \"cpu\" \"leon\")\n-    (eq_attr \"type\" \"load,sload,fpload\"))\n+  (and (eq_attr \"cpu\" \"leon\") (eq_attr \"type\" \"load,sload\"))\n   \"leon_memory\")\n \n-(define_insn_reservation \"leon_store\" 1\n-  (and (eq_attr \"cpu\" \"leon\")\n-    (eq_attr \"type\" \"store,fpstore\"))\n-  \"leon_memory+write_buf\")\n-  \n-(define_insn_reservation \"leon_fp_alu\" 1\n-  (and (eq_attr \"cpu\" \"leon\")\n-    (eq_attr \"type\" \"fp,fpmove\"))\n-  \"leon_fpalu, nothing\")\n-\n-(define_insn_reservation \"leon_fp_mult\" 1\n-  (and (eq_attr \"cpu\" \"leon\")\n-    (eq_attr \"type\" \"fpmul\"))\n-  \"leon_fpmds, nothing\")\n-\n-(define_insn_reservation \"leon_fp_div\" 16\n-  (and (eq_attr \"cpu\" \"leon\")\n-    (eq_attr \"type\" \"fpdivs,fpdivd\"))\n-  \"leon_fpmds, nothing*15\")\n-\n-(define_insn_reservation \"leon_fp_sqrt\" 23\n-  (and (eq_attr \"cpu\" \"leon\")\n-    (eq_attr \"type\" \"fpsqrts,fpsqrtd\"))\n-  \"leon_fpmds, nothing*21\")\n+;; Use a double reservation to work around the load pipeline hazard on UT699.\n+(define_insn_reservation \"leon3_load\" 1\n+  (and (eq_attr \"cpu\" \"leon3\") (eq_attr \"type\" \"load,sload\"))\n+  \"leon_memory*2\")\n \n+(define_insn_reservation \"leon_store\" 2\n+  (and (eq_attr \"cpu\" \"leon,leon3\") (eq_attr \"type\" \"store\"))\n+  \"leon_memory*2\")\n+\n+;; This describes Gaisler Research's FPU\n+\n+(define_automaton \"grfpu\")\n+\n+(define_cpu_unit \"grfpu_alu\" \"grfpu\")\n+(define_cpu_unit \"grfpu_ds\" \"grfpu\")\n+\n+(define_insn_reservation \"leon_fp_alu\" 4\n+  (and (eq_attr \"cpu\" \"leon,leon3\") (eq_attr \"type\" \"fp,fpcmp,fpmul\"))\n+  \"grfpu_alu, nothing*3\")\n+\n+(define_insn_reservation \"leon_fp_divs\" 16\n+  (and (eq_attr \"cpu\" \"leon,leon3\") (eq_attr \"type\" \"fpdivs\"))\n+  \"grfpu_ds*14, nothing*2\")\n+\n+(define_insn_reservation \"leon_fp_divd\" 17\n+  (and (eq_attr \"cpu\" \"leon,leon3\") (eq_attr \"type\" \"fpdivd\"))\n+  \"grfpu_ds*15, nothing*2\")\n+\n+(define_insn_reservation \"leon_fp_sqrts\" 24\n+  (and (eq_attr \"cpu\" \"leon,leon3\") (eq_attr \"type\" \"fpsqrts\"))\n+  \"grfpu_ds*22, nothing*2\")\n+\n+(define_insn_reservation \"leon_fp_sqrtd\" 25\n+  (and (eq_attr \"cpu\" \"leon,leon3\") (eq_attr \"type\" \"fpsqrtd\"))\n+  \"grfpu_ds*23, nothing*2\")"}, {"sha": "b5e9761af2b0314521a946a7d596caa68064e375", "filename": "gcc/config/sparc/sparc-opts.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38ae58ca9fd17ebf4fe679fe7a91472f5d6c37b1/gcc%2Fconfig%2Fsparc%2Fsparc-opts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38ae58ca9fd17ebf4fe679fe7a91472f5d6c37b1/gcc%2Fconfig%2Fsparc%2Fsparc-opts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-opts.h?ref=38ae58ca9fd17ebf4fe679fe7a91472f5d6c37b1", "patch": "@@ -30,6 +30,7 @@ enum processor_type {\n   PROCESSOR_SUPERSPARC,\n   PROCESSOR_HYPERSPARC,\n   PROCESSOR_LEON,\n+  PROCESSOR_LEON3,\n   PROCESSOR_SPARCLITE,\n   PROCESSOR_F930,\n   PROCESSOR_F934,"}, {"sha": "48c25dcd5cd92ef8475093f10aa2ce04d8221268", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 111, "deletions": 12, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38ae58ca9fd17ebf4fe679fe7a91472f5d6c37b1/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38ae58ca9fd17ebf4fe679fe7a91472f5d6c37b1/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=38ae58ca9fd17ebf4fe679fe7a91472f5d6c37b1", "patch": "@@ -226,6 +226,30 @@ struct processor_costs leon_costs = {\n   0, /* shift penalty */\n };\n \n+static const\n+struct processor_costs leon3_costs = {\n+  COSTS_N_INSNS (1), /* int load */\n+  COSTS_N_INSNS (1), /* int signed load */\n+  COSTS_N_INSNS (1), /* int zeroed load */\n+  COSTS_N_INSNS (1), /* float load */\n+  COSTS_N_INSNS (1), /* fmov, fneg, fabs */\n+  COSTS_N_INSNS (1), /* fadd, fsub */\n+  COSTS_N_INSNS (1), /* fcmp */\n+  COSTS_N_INSNS (1), /* fmov, fmovr */\n+  COSTS_N_INSNS (1), /* fmul */\n+  COSTS_N_INSNS (14), /* fdivs */\n+  COSTS_N_INSNS (15), /* fdivd */\n+  COSTS_N_INSNS (22), /* fsqrts */\n+  COSTS_N_INSNS (23), /* fsqrtd */\n+  COSTS_N_INSNS (5), /* imul */\n+  COSTS_N_INSNS (5), /* imulX */\n+  0, /* imul bit factor */\n+  COSTS_N_INSNS (35), /* idiv */\n+  COSTS_N_INSNS (35), /* idivX */\n+  COSTS_N_INSNS (1), /* movcc/movr */\n+  0, /* shift penalty */\n+};\n+\n static const\n struct processor_costs sparclet_costs = {\n   COSTS_N_INSNS (3), /* int load */\n@@ -805,32 +829,54 @@ char sparc_hard_reg_printed[8];\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \n+/* Return the memory reference contained in X if any, zero otherwise.  */\n+\n+static rtx\n+mem_ref (rtx x)\n+{\n+  if (GET_CODE (x) == SIGN_EXTEND || GET_CODE (x) == ZERO_EXTEND)\n+    x = XEXP (x, 0);\n+\n+  if (MEM_P (x))\n+    return x;\n+\n+  return NULL_RTX;\n+}\n+\n /* We use a machine specific pass to enable workarounds for errata.\n    We need to have the (essentially) final form of the insn stream in order\n    to properly detect the various hazards.  Therefore, this machine specific\n    pass runs as late as possible.  The pass is inserted in the pass pipeline\n-   at the end of sparc_options_override.  */\n+   at the end of sparc_option_override.  */\n \n static bool\n sparc_gate_work_around_errata (void)\n {\n-  /* The only erratum we handle for now is that of the AT697F processor.  */\n-  return sparc_fix_at697f != 0;\n+  /* The only errata we handle are those of the AT697F and UT699.  */\n+  return sparc_fix_at697f != 0 || sparc_fix_ut699 != 0;\n }\n \n static unsigned int\n sparc_do_work_around_errata (void)\n {\n   rtx insn, next;\n \n+  /* Force all instructions to be split into their final form.  */\n+  split_all_insns_noflow ();\n+\n   /* Now look for specific patterns in the insn stream.  */\n   for (insn = get_insns (); insn; insn = next)\n     {\n       bool insert_nop = false;\n       rtx set;\n \n+      /* Look into the instruction in a delay slot.  */\n+      if (NONJUMP_INSN_P (insn) && GET_CODE (PATTERN (insn)) == SEQUENCE)\n+\tinsn = XVECEXP (PATTERN (insn), 0, 1);\n+\n       /* Look for a single-word load into an odd-numbered FP register.  */\n-      if (NONJUMP_INSN_P (insn)\n+      if (sparc_fix_at697f\n+\t  && NONJUMP_INSN_P (insn)\n \t  && (set = single_set (insn)) != NULL_RTX\n \t  && GET_MODE_SIZE (GET_MODE (SET_SRC (set))) == 4\n \t  && MEM_P (SET_SRC (set))\n@@ -845,13 +891,13 @@ sparc_do_work_around_errata (void)\n \n \t  /* If the insn has a delay slot, then it cannot be problematic.  */\n \t  next = next_active_insn (insn);\n+\t  if (!next)\n+\t    break;\n \t  if (NONJUMP_INSN_P (next) && GET_CODE (PATTERN (next)) == SEQUENCE)\n-\t    code = -1;\n-\t  else\n-\t    {\n-\t      extract_insn (next);\n-\t      code = INSN_CODE (next);\n-\t    }\n+\t    continue;\n+\n+\t  extract_insn (next);\n+\t  code = INSN_CODE (next);\n \n \t  switch (code)\n \t    {\n@@ -897,12 +943,60 @@ sparc_do_work_around_errata (void)\n \t      break;\n \t    }\n \t}\n+\n+      /* Look for a single-word load into an integer register.  */\n+      else if (sparc_fix_ut699\n+\t       && NONJUMP_INSN_P (insn)\n+\t       && (set = single_set (insn)) != NULL_RTX\n+\t       && GET_MODE_SIZE (GET_MODE (SET_SRC (set))) <= 4\n+\t       && mem_ref (SET_SRC (set)) != NULL_RTX\n+\t       && REG_P (SET_DEST (set))\n+\t       && REGNO (SET_DEST (set)) < 32)\n+\t{\n+\t  /* There is no problem if the second memory access has a data\n+\t     dependency on the first single-cycle load.  */\n+\t  rtx x = SET_DEST (set);\n+\n+\t  /* If the insn has a delay slot, then it cannot be problematic.  */\n+\t  next = next_active_insn (insn);\n+\t  if (!next)\n+\t    break;\n+\t  if (NONJUMP_INSN_P (next) && GET_CODE (PATTERN (next)) == SEQUENCE)\n+\t    continue;\n+\n+\t  /* Look for a second memory access to/from an integer register.  */\n+\t  if ((set = single_set (next)) != NULL_RTX)\n+\t    {\n+\t      rtx src = SET_SRC (set);\n+\t      rtx dest = SET_DEST (set);\n+\t      rtx mem;\n+\n+\t      /* LDD is affected.  */\n+\t      if ((mem = mem_ref (src)) != NULL_RTX\n+\t\t  && REG_P (dest)\n+\t\t  && REGNO (dest) < 32\n+\t\t  && !reg_mentioned_p (x, XEXP (mem, 0)))\n+\t\tinsert_nop = true;\n+\n+\t      /* STD is *not* affected.  */\n+\t      else if ((mem = mem_ref (dest)) != NULL_RTX\n+\t\t       && GET_MODE_SIZE (GET_MODE (mem)) <= 4\n+\t\t       && (src == const0_rtx\n+\t\t\t   || (REG_P (src)\n+\t\t\t       && REGNO (src) < 32\n+\t\t\t       && REGNO (src) != REGNO (x)))\n+\t\t       && !reg_mentioned_p (x, XEXP (mem, 0)))\n+\t\tinsert_nop = true;\n+\t    }\n+\t}\n+\n       else\n \tnext = NEXT_INSN (insn);\n \n       if (insert_nop)\n-\temit_insn_after (gen_nop (), insn);\n+\temit_insn_before (gen_nop (), next);\n     }\n+\n   return 0;\n }\n \n@@ -1019,6 +1113,7 @@ sparc_option_override (void)\n     { TARGET_CPU_supersparc, PROCESSOR_SUPERSPARC },\n     { TARGET_CPU_hypersparc, PROCESSOR_HYPERSPARC },\n     { TARGET_CPU_leon, PROCESSOR_LEON },\n+    { TARGET_CPU_leon3, PROCESSOR_LEON3 },\n     { TARGET_CPU_sparclite, PROCESSOR_F930 },\n     { TARGET_CPU_sparclite86x, PROCESSOR_SPARCLITE86X },\n     { TARGET_CPU_sparclet, PROCESSOR_TSC701 },\n@@ -1033,7 +1128,7 @@ sparc_option_override (void)\n   };\n   const struct cpu_default *def;\n   /* Table of values for -m{cpu,tune}=.  This must match the order of\n-     the PROCESSOR_* enumeration.  */\n+     the enum processor_type in sparc-opts.h.  */\n   static struct cpu_table {\n     const char *const name;\n     const int disable;\n@@ -1047,6 +1142,7 @@ sparc_option_override (void)\n     { \"hypersparc\",\tMASK_ISA, MASK_V8|MASK_FPU },\n     /* LEON */\n     { \"leon\",\t\tMASK_ISA, MASK_V8|MASK_FPU },\n+    { \"leon3\",\t\tMASK_ISA, MASK_V8|MASK_FPU },\n     { \"sparclite\",\tMASK_ISA, MASK_SPARCLITE },\n     /* The Fujitsu MB86930 is the original sparclite chip, with no FPU.  */\n     { \"f930\",\t\tMASK_ISA|MASK_FPU, MASK_SPARCLITE },\n@@ -1295,6 +1391,9 @@ sparc_option_override (void)\n     case PROCESSOR_LEON:\n       sparc_costs = &leon_costs;\n       break;\n+    case PROCESSOR_LEON3:\n+      sparc_costs = &leon3_costs;\n+      break;\n     case PROCESSOR_SPARCLET:\n     case PROCESSOR_TSC701:\n       sparc_costs = &sparclet_costs;"}, {"sha": "202d23c0162187005012a09d36c6aa7225a2ecdd", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38ae58ca9fd17ebf4fe679fe7a91472f5d6c37b1/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38ae58ca9fd17ebf4fe679fe7a91472f5d6c37b1/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=38ae58ca9fd17ebf4fe679fe7a91472f5d6c37b1", "patch": "@@ -136,21 +136,22 @@ extern enum cmodel sparc_cmodel;\n #define TARGET_CPU_supersparc\t2\n #define TARGET_CPU_hypersparc\t3\n #define TARGET_CPU_leon\t\t4\n-#define TARGET_CPU_sparclite\t5\n-#define TARGET_CPU_f930\t\t5       /* alias */\n-#define TARGET_CPU_f934\t\t5       /* alias */\n-#define TARGET_CPU_sparclite86x\t6\n-#define TARGET_CPU_sparclet\t7\n-#define TARGET_CPU_tsc701\t7       /* alias */\n-#define TARGET_CPU_v9\t\t8\t/* generic v9 implementation */\n-#define TARGET_CPU_sparcv9\t8\t/* alias */\n-#define TARGET_CPU_sparc64\t8\t/* alias */\n-#define TARGET_CPU_ultrasparc\t9\n-#define TARGET_CPU_ultrasparc3\t10\n-#define TARGET_CPU_niagara\t11\n-#define TARGET_CPU_niagara2\t12\n-#define TARGET_CPU_niagara3\t13\n-#define TARGET_CPU_niagara4\t14\n+#define TARGET_CPU_leon3\t5\n+#define TARGET_CPU_sparclite\t6\n+#define TARGET_CPU_f930\t\t6       /* alias */\n+#define TARGET_CPU_f934\t\t6       /* alias */\n+#define TARGET_CPU_sparclite86x\t7\n+#define TARGET_CPU_sparclet\t8\n+#define TARGET_CPU_tsc701\t8       /* alias */\n+#define TARGET_CPU_v9\t\t9\t/* generic v9 implementation */\n+#define TARGET_CPU_sparcv9\t9\t/* alias */\n+#define TARGET_CPU_sparc64\t9\t/* alias */\n+#define TARGET_CPU_ultrasparc\t10\n+#define TARGET_CPU_ultrasparc3\t11\n+#define TARGET_CPU_niagara\t12\n+#define TARGET_CPU_niagara2\t13\n+#define TARGET_CPU_niagara3\t14\n+#define TARGET_CPU_niagara4\t15\n \n #if TARGET_CPU_DEFAULT == TARGET_CPU_v9 \\\n  || TARGET_CPU_DEFAULT == TARGET_CPU_ultrasparc \\\n@@ -232,7 +233,8 @@ extern enum cmodel sparc_cmodel;\n #define ASM_CPU32_DEFAULT_SPEC \"\"\n #endif\n \n-#if TARGET_CPU_DEFAULT == TARGET_CPU_leon\n+#if TARGET_CPU_DEFAULT == TARGET_CPU_leon \\\n+ || TARGET_CPU_DEFAULT == TARGET_CPU_leon3\n #define CPP_CPU32_DEFAULT_SPEC \"-D__leon__ -D__sparc_v8__\"\n #define ASM_CPU32_DEFAULT_SPEC \"\"\n #endif\n@@ -282,6 +284,7 @@ extern enum cmodel sparc_cmodel;\n %{mcpu=supersparc:-D__supersparc__ -D__sparc_v8__} \\\n %{mcpu=hypersparc:-D__hypersparc__ -D__sparc_v8__} \\\n %{mcpu=leon:-D__leon__ -D__sparc_v8__} \\\n+%{mcpu=leon3:-D__leon__ -D__sparc_v8__} \\\n %{mcpu=v9:-D__sparc_v9__} \\\n %{mcpu=ultrasparc:-D__sparc_v9__} \\\n %{mcpu=ultrasparc3:-D__sparc_v9__} \\\n@@ -330,6 +333,7 @@ extern enum cmodel sparc_cmodel;\n %{mcpu=supersparc:-Av8} \\\n %{mcpu=hypersparc:-Av8} \\\n %{mcpu=leon:-Av8} \\\n+%{mcpu=leon3:-Av8} \\\n %{mv8plus:-Av8plus} \\\n %{mcpu=v9:-Av9} \\\n %{mcpu=ultrasparc:%{!mv8plus:-Av9a}} \\"}, {"sha": "174a6b1ea5f93a734e9cd551d12769cf1e9276f1", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38ae58ca9fd17ebf4fe679fe7a91472f5d6c37b1/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38ae58ca9fd17ebf4fe679fe7a91472f5d6c37b1/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=38ae58ca9fd17ebf4fe679fe7a91472f5d6c37b1", "patch": "@@ -206,14 +206,15 @@\n ;; 'f' for all DF/TFmode values, including those that are specific to the v8.\n \n ;; Attribute for cpu type.\n-;; These must match the values for enum processor_type in sparc.h.\n+;; These must match the values of the enum processor_type in sparc-opts.h.\n (define_attr \"cpu\"\n   \"v7,\n    cypress,\n    v8,\n    supersparc,\n    hypersparc,\n    leon,\n+   leon3,\n    sparclite,\n    f930,\n    f934,"}, {"sha": "016e69974224a586501f1b38db39848f6182a3b8", "filename": "gcc/config/sparc/sparc.opt", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38ae58ca9fd17ebf4fe679fe7a91472f5d6c37b1/gcc%2Fconfig%2Fsparc%2Fsparc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38ae58ca9fd17ebf4fe679fe7a91472f5d6c37b1/gcc%2Fconfig%2Fsparc%2Fsparc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.opt?ref=38ae58ca9fd17ebf4fe679fe7a91472f5d6c37b1", "patch": "@@ -145,6 +145,9 @@ Enum(sparc_processor_type) String(hypersparc) Value(PROCESSOR_HYPERSPARC)\n EnumValue\n Enum(sparc_processor_type) String(leon) Value(PROCESSOR_LEON)\n \n+EnumValue\n+Enum(sparc_processor_type) String(leon3) Value(PROCESSOR_LEON3)\n+\n EnumValue\n Enum(sparc_processor_type) String(sparclite) Value(PROCESSOR_SPARCLITE)\n \n@@ -203,7 +206,7 @@ Enable workaround for single erratum of AT697F processor\n \n mfix-ut699\n Target Report RejectNegative Var(sparc_fix_ut699)\n-Enable workarounds for the FP errata of the UT699 processor\n+Enable workarounds for the errata of the UT699 processor\n \n Mask(LONG_DOUBLE_128)\n ;; Use 128-bit long double"}, {"sha": "2f21f812dc9a2fbf2becd7c4260fbf8007333785", "filename": "gcc/config/sparc/sync.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38ae58ca9fd17ebf4fe679fe7a91472f5d6c37b1/gcc%2Fconfig%2Fsparc%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38ae58ca9fd17ebf4fe679fe7a91472f5d6c37b1/gcc%2Fconfig%2Fsparc%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsync.md?ref=38ae58ca9fd17ebf4fe679fe7a91472f5d6c37b1", "patch": "@@ -220,7 +220,7 @@\n    (match_operand:SI 1 \"memory_operand\" \"\")\n    (match_operand:SI 2 \"register_operand\" \"\")\n    (match_operand:SI 3 \"const_int_operand\" \"\")]\n-  \"TARGET_V8 || TARGET_V9\"\n+  \"(TARGET_V8 || TARGET_V9) && !sparc_fix_ut699\"\n {\n   enum memmodel model = (enum memmodel) INTVAL (operands[3]);\n \n@@ -236,15 +236,15 @@\n \t\t\t    UNSPECV_SWAP))\n    (set (match_dup 1)\n \t(match_operand:SI 2 \"register_operand\" \"0\"))]\n-  \"TARGET_V8 || TARGET_V9\"\n+  \"(TARGET_V8 || TARGET_V9) && !sparc_fix_ut699\"\n   \"swap\\t%1, %0\"\n   [(set_attr \"type\" \"multi\")])\n \n (define_expand \"atomic_test_and_set\"\n   [(match_operand:QI 0 \"register_operand\" \"\")\n    (match_operand:QI 1 \"memory_operand\" \"\")\n    (match_operand:SI 2 \"const_int_operand\" \"\")]\n-  \"\"\n+  \"!sparc_fix_ut699\"\n {\n   enum memmodel model = (enum memmodel) INTVAL (operands[2]);\n   rtx ret;\n@@ -268,6 +268,6 @@\n \t(unspec_volatile:QI [(match_operand:QI 1 \"memory_operand\" \"+m\")]\n \t\t\t    UNSPECV_LDSTUB))\n    (set (match_dup 1) (const_int -1))]\n-  \"\"\n+  \"!sparc_fix_ut699\"\n   \"ldstub\\t%1, %0\"\n   [(set_attr \"type\" \"multi\")])"}, {"sha": "31553bea64ee068e1a86ec31beed0123065c1eaf", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38ae58ca9fd17ebf4fe679fe7a91472f5d6c37b1/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38ae58ca9fd17ebf4fe679fe7a91472f5d6c37b1/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=38ae58ca9fd17ebf4fe679fe7a91472f5d6c37b1", "patch": "@@ -19491,8 +19491,8 @@ processor (which corresponds to erratum #13 of the AT697E processor).\n \n @item -mfix-ut699\n @opindex mfix-ut699\n-Enable the documented workarounds for the floating-point errata of the UT699\n-processor.\n+Enable the documented workarounds for the floating-point errata and the data\n+cache nullify errata of the UT699 processor.\n @end table\n \n These @samp{-m} options are supported in addition to the above"}]}