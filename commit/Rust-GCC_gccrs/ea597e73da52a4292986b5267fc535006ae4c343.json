{"sha": "ea597e73da52a4292986b5267fc535006ae4c343", "node_id": "C_kwDOANBUbNoAKGVhNTk3ZTczZGE1MmE0MjkyOTg2YjUyNjdmYzUzNTAwNmFlNGMzNDM", "commit": {"author": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2023-05-05T18:06:37Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2023-05-08T14:53:18Z"}, "message": "gccrs: Redo how we handle unit types for the final time\n\nWe had a very inconsistant way for dealing with unit-types in gccrs we\ntried to optimize the case for a function returning unit type to be clever\nand not emit any return value for unit types. Then for other cases we would\nuse an empty constructor for an empty tuple and in others use a zero\npercsion integer. This was all just confusing and made the IR less\nconformant to Rust. In this patch I change all of this to use an empty\ntuple type for all cases so we pass around {} which maps over to Rust and\ngets optimized away in the middle end anyway.\n\nIn the patch we also remove old gccgo code which optimizes away zero\nsize types to void_type_node which is why my original attempt at doing this\ntwo years ago failed.\n\nFixes #2188\n\ngcc/rust/ChangeLog:\n\n\t* backend/rust-compile-base.cc (HIRCompileBase::compile_function_body): use unit_expression\n\t(HIRCompileBase::unit_expression): new helper\n\t* backend/rust-compile-base.h: update prototype\n\t* backend/rust-compile-block.cc (CompileBlock::visit): use unit_expression\n\t* backend/rust-compile-expr.cc (CompileExpr::visit): likewise\n\t(CompileExpr::generate_closure_function): likewise\n\t* backend/rust-compile-implitem.cc (CompileTraitItem::visit): cleanup\n\t* backend/rust-compile-item.cc (CompileItem::visit): likewise\n\t* backend/rust-compile-pattern.cc (CompilePatternLet::visit): likewise\n\t* backend/rust-compile-resolve-path.cc (ResolvePathRef::resolve): likewise\n\t* backend/rust-compile-type.cc (TyTyResolveCompile::get_unit_type): new helper\n\t(TyTyResolveCompile::visit): use new unit_type helper\n\t* backend/rust-compile-type.h: likewise\n\t* rust-backend.h: simplify the return_expression\n\t* rust-gcc.cc (Gcc_backend::function_type): likewise\n\t(Gcc_backend::return_statement): likewise\n\t* backend/rust-constexpr.cc (eval_constant_expression): remove bad assertion\n\ngcc/testsuite/ChangeLog:\n\n\t* rust/compile/issue-2188.rs: New test.\n\nSigned-off-by: Philip Herron <herron.philip@googlemail.com>", "tree": {"sha": "668fe7aa980f82a6094528255e7c85ebfcfd16c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/668fe7aa980f82a6094528255e7c85ebfcfd16c9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ea597e73da52a4292986b5267fc535006ae4c343", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea597e73da52a4292986b5267fc535006ae4c343", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea597e73da52a4292986b5267fc535006ae4c343", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea597e73da52a4292986b5267fc535006ae4c343/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a252a9c12d7cc6cb160a57b271d2c8e8840b7f55", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a252a9c12d7cc6cb160a57b271d2c8e8840b7f55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a252a9c12d7cc6cb160a57b271d2c8e8840b7f55"}], "stats": {"total": 524, "additions": 205, "deletions": 319}, "files": [{"sha": "4a7e04b644f04d70b13b33252e1fc0e6d1b0ecf3", "filename": "gcc/rust/backend/rust-compile-base.cc", "status": "modified", "additions": 57, "deletions": 46, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea597e73da52a4292986b5267fc535006ae4c343/gcc%2Frust%2Fbackend%2Frust-compile-base.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea597e73da52a4292986b5267fc535006ae4c343/gcc%2Frust%2Fbackend%2Frust-compile-base.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-base.cc?ref=ea597e73da52a4292986b5267fc535006ae4c343", "patch": "@@ -35,6 +35,7 @@\n #include \"stringpool.h\"\n #include \"attribs.h\"\n #include \"tree.h\"\n+#include \"print-tree.h\"\n \n namespace Rust {\n namespace Compile {\n@@ -466,9 +467,9 @@ HIRCompileBase::compile_locals_for_block (Context *ctx, Resolver::Rib &rib,\n }\n \n void\n-HIRCompileBase::compile_function_body (Context *ctx, tree fndecl,\n+HIRCompileBase::compile_function_body (tree fndecl,\n \t\t\t\t       HIR::BlockExpr &function_body,\n-\t\t\t\t       bool has_return_type)\n+\t\t\t\t       TyTy::BaseType *fn_return_ty)\n {\n   for (auto &s : function_body.get_statements ())\n     {\n@@ -482,40 +483,48 @@ HIRCompileBase::compile_function_body (Context *ctx, tree fndecl,\n \n   if (function_body.has_expr ())\n     {\n-      // the previous passes will ensure this is a valid return\n-      // or a valid trailing expression\n-      tree compiled_expr\n-\t= CompileExpr::Compile (function_body.expr.get (), ctx);\n+      Location locus = function_body.get_final_expr ()->get_locus ();\n+      tree return_value = CompileExpr::Compile (function_body.expr.get (), ctx);\n \n-      if (compiled_expr != nullptr)\n+      // we can only return this if non unit value return type\n+      if (!fn_return_ty->is_unit ())\n \t{\n-\t  if (has_return_type)\n-\t    {\n-\t      std::vector<tree> retstmts;\n-\t      retstmts.push_back (compiled_expr);\n-\n-\t      auto ret = ctx->get_backend ()->return_statement (\n-\t\tfndecl, retstmts,\n-\t\tfunction_body.get_final_expr ()->get_locus ());\n-\t      ctx->add_statement (ret);\n-\t    }\n-\t  else\n-\t    {\n-\t      // FIXME can this actually happen?\n-\t      ctx->add_statement (compiled_expr);\n-\t    }\n+\t  tree return_stmt\n+\t    = ctx->get_backend ()->return_statement (fndecl, return_value,\n+\t\t\t\t\t\t     locus);\n+\t  ctx->add_statement (return_stmt);\n \t}\n+      else\n+\t{\n+\t  // just add the stmt expression\n+\t  ctx->add_statement (return_value);\n+\n+\t  // now just return unit expression\n+\t  tree unit_expr = unit_expression (ctx, locus);\n+\t  tree return_stmt\n+\t    = ctx->get_backend ()->return_statement (fndecl, unit_expr, locus);\n+\t  ctx->add_statement (return_stmt);\n+\t}\n+    }\n+  else if (fn_return_ty->is_unit ())\n+    {\n+      // we can only do this if the function is of unit type otherwise other\n+      // errors should have occurred\n+      Location locus = function_body.get_locus ();\n+      tree return_value = unit_expression (ctx, locus);\n+      tree return_stmt\n+\t= ctx->get_backend ()->return_statement (fndecl, return_value, locus);\n+      ctx->add_statement (return_stmt);\n     }\n }\n \n tree\n HIRCompileBase::compile_function (\n-  Context *ctx, const std::string &fn_name, HIR::SelfParam &self_param,\n+  const std::string &fn_name, HIR::SelfParam &self_param,\n   std::vector<HIR::FunctionParam> &function_params,\n   const HIR::FunctionQualifiers &qualifiers, HIR::Visibility &visibility,\n   AST::AttrVec &outer_attrs, Location locus, HIR::BlockExpr *function_body,\n-  const Resolver::CanonicalPath *canonical_path, TyTy::FnType *fntype,\n-  bool function_has_return)\n+  const Resolver::CanonicalPath *canonical_path, TyTy::FnType *fntype)\n {\n   tree compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n   std::string ir_symbol_name\n@@ -606,24 +615,19 @@ HIRCompileBase::compile_function (\n   ctx->push_block (code_block);\n \n   Bvariable *return_address = nullptr;\n-  if (function_has_return)\n-    {\n-      tree return_type = TyTyResolveCompile::compile (ctx, tyret);\n-\n-      bool address_is_taken = false;\n-      tree ret_var_stmt = NULL_TREE;\n+  tree return_type = TyTyResolveCompile::compile (ctx, tyret);\n \n-      return_address\n-\t= ctx->get_backend ()->temporary_variable (fndecl, code_block,\n-\t\t\t\t\t\t   return_type, NULL,\n-\t\t\t\t\t\t   address_is_taken, locus,\n-\t\t\t\t\t\t   &ret_var_stmt);\n+  bool address_is_taken = false;\n+  tree ret_var_stmt = NULL_TREE;\n+  return_address\n+    = ctx->get_backend ()->temporary_variable (fndecl, code_block, return_type,\n+\t\t\t\t\t       NULL, address_is_taken, locus,\n+\t\t\t\t\t       &ret_var_stmt);\n \n-      ctx->add_statement (ret_var_stmt);\n-    }\n+  ctx->add_statement (ret_var_stmt);\n \n   ctx->push_fn (fndecl, return_address);\n-  compile_function_body (ctx, fndecl, *function_body, function_has_return);\n+  compile_function_body (fndecl, *function_body, tyret);\n   tree bind_tree = ctx->pop_block ();\n \n   gcc_assert (TREE_CODE (bind_tree) == BIND_EXPR);\n@@ -642,14 +646,13 @@ HIRCompileBase::compile_function (\n \n tree\n HIRCompileBase::compile_constant_item (\n-  Context *ctx, TyTy::BaseType *resolved_type,\n-  const Resolver::CanonicalPath *canonical_path, HIR::Expr *const_value_expr,\n-  Location locus)\n+  TyTy::BaseType *resolved_type, const Resolver::CanonicalPath *canonical_path,\n+  HIR::Expr *const_value_expr, Location locus)\n {\n   const std::string &ident = canonical_path->get ();\n+\n   tree type = TyTyResolveCompile::compile (ctx, resolved_type);\n   tree const_type = build_qualified_type (type, TYPE_QUAL_CONST);\n-\n   bool is_block_expr\n     = const_value_expr->get_expression_type () == HIR::Expr::ExprType::Block;\n \n@@ -661,7 +664,6 @@ HIRCompileBase::compile_constant_item (\n   tree compiled_fn_type = ctx->get_backend ()->function_type (\n     receiver, {}, {Backend::typed_identifier (\"_\", const_type, locus)}, NULL,\n     locus);\n-\n   tree fndecl\n     = ctx->get_backend ()->function (compiled_fn_type, ident, \"\", 0, locus);\n   TREE_READONLY (fndecl) = 1;\n@@ -703,13 +705,14 @@ HIRCompileBase::compile_constant_item (\n     {\n       HIR::BlockExpr *function_body\n \t= static_cast<HIR::BlockExpr *> (const_value_expr);\n-      compile_function_body (ctx, fndecl, *function_body, true);\n+      compile_function_body (fndecl, *function_body, resolved_type);\n     }\n   else\n     {\n       tree value = CompileExpr::Compile (const_value_expr, ctx);\n+\n       tree return_expr = ctx->get_backend ()->return_statement (\n-\tfndecl, {value}, const_value_expr->get_locus ());\n+\tfndecl, value, const_value_expr->get_locus ());\n       ctx->add_statement (return_expr);\n     }\n \n@@ -831,5 +834,13 @@ HIRCompileBase::resolve_method_address (\n   return CompileInherentImplItem::Compile (impl_item, ctx, monomorphized);\n }\n \n+tree\n+HIRCompileBase::unit_expression (Context *ctx, Location locus)\n+{\n+  tree unit_type = TyTyResolveCompile::get_unit_type (ctx);\n+  return ctx->get_backend ()->constructor_expression (unit_type, false, {}, -1,\n+\t\t\t\t\t\t      locus);\n+}\n+\n } // namespace Compile\n } // namespace Rust"}, {"sha": "d2d6a9ad75fc1a10defd2de303f450e354dc6133", "filename": "gcc/rust/backend/rust-compile-base.h", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea597e73da52a4292986b5267fc535006ae4c343/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea597e73da52a4292986b5267fc535006ae4c343/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-base.h?ref=ea597e73da52a4292986b5267fc535006ae4c343", "patch": "@@ -86,6 +86,23 @@ class HIRCompileBase\n \t\t\t       const Analysis::NodeMapping &expr_mappings,\n \t\t\t       Location expr_locus);\n \n+  void compile_function_body (tree fndecl, HIR::BlockExpr &function_body,\n+\t\t\t      TyTy::BaseType *fn_return_ty);\n+\n+  tree compile_constant_item (TyTy::BaseType *resolved_type,\n+\t\t\t      const Resolver::CanonicalPath *canonical_path,\n+\t\t\t      HIR::Expr *const_value_expr, Location locus);\n+\n+  tree compile_function (const std::string &fn_name, HIR::SelfParam &self_param,\n+\t\t\t std::vector<HIR::FunctionParam> &function_params,\n+\t\t\t const HIR::FunctionQualifiers &qualifiers,\n+\t\t\t HIR::Visibility &visibility, AST::AttrVec &outer_attrs,\n+\t\t\t Location locus, HIR::BlockExpr *function_body,\n+\t\t\t const Resolver::CanonicalPath *canonical_path,\n+\t\t\t TyTy::FnType *fntype);\n+\n+  static tree unit_expression (Context *ctx, Location locus);\n+\n   static void setup_fndecl (tree fndecl, bool is_main_entry_point,\n \t\t\t    bool is_generic_fn, HIR::Visibility &visibility,\n \t\t\t    const HIR::FunctionQualifiers &qualifiers,\n@@ -121,23 +138,6 @@ class HIRCompileBase\n   static std::vector<Bvariable *>\n   compile_locals_for_block (Context *ctx, Resolver::Rib &rib, tree fndecl);\n \n-  static void compile_function_body (Context *ctx, tree fndecl,\n-\t\t\t\t     HIR::BlockExpr &function_body,\n-\t\t\t\t     bool has_return_type);\n-\n-  static tree compile_function (\n-    Context *ctx, const std::string &fn_name, HIR::SelfParam &self_param,\n-    std::vector<HIR::FunctionParam> &function_params,\n-    const HIR::FunctionQualifiers &qualifiers, HIR::Visibility &visibility,\n-    AST::AttrVec &outer_attrs, Location locus, HIR::BlockExpr *function_body,\n-    const Resolver::CanonicalPath *canonical_path, TyTy::FnType *fntype,\n-    bool function_has_return);\n-\n-  static tree\n-  compile_constant_item (Context *ctx, TyTy::BaseType *resolved_type,\n-\t\t\t const Resolver::CanonicalPath *canonical_path,\n-\t\t\t HIR::Expr *const_value_expr, Location locus);\n-\n   static tree named_constant_expression (tree type_tree,\n \t\t\t\t\t const std::string &name,\n \t\t\t\t\t tree const_val, Location location);"}, {"sha": "12ef102be05565711ebb0c925af076528a8aaa70", "filename": "gcc/rust/backend/rust-compile-block.cc", "status": "modified", "additions": 23, "deletions": 18, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea597e73da52a4292986b5267fc535006ae4c343/gcc%2Frust%2Fbackend%2Frust-compile-block.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea597e73da52a4292986b5267fc535006ae4c343/gcc%2Frust%2Fbackend%2Frust-compile-block.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-block.cc?ref=ea597e73da52a4292986b5267fc535006ae4c343", "patch": "@@ -71,28 +71,33 @@ CompileBlock::visit (HIR::BlockExpr &expr)\n \n   if (expr.has_expr ())\n     {\n-      // the previous passes will ensure this is a valid return or\n-      // a valid trailing expression\n       tree compiled_expr = CompileExpr::Compile (expr.expr.get (), ctx);\n-      if (compiled_expr != nullptr)\n+      if (result != nullptr)\n \t{\n-\t  if (result == nullptr)\n-\t    {\n-\t      ctx->add_statement (compiled_expr);\n-\t    }\n-\t  else\n-\t    {\n-\t      tree result_reference = ctx->get_backend ()->var_expression (\n-\t\tresult, expr.get_final_expr ()->get_locus ());\n-\n-\t      tree assignment\n-\t\t= ctx->get_backend ()->assignment_statement (result_reference,\n-\t\t\t\t\t\t\t     compiled_expr,\n-\t\t\t\t\t\t\t     expr.get_locus ());\n-\t      ctx->add_statement (assignment);\n-\t    }\n+\t  Location locus = expr.get_final_expr ()->get_locus ();\n+\t  tree result_reference\n+\t    = ctx->get_backend ()->var_expression (result, locus);\n+\n+\t  tree assignment\n+\t    = ctx->get_backend ()->assignment_statement (result_reference,\n+\t\t\t\t\t\t\t compiled_expr,\n+\t\t\t\t\t\t\t expr.get_locus ());\n+\t  ctx->add_statement (assignment);\n \t}\n     }\n+  else if (result != nullptr)\n+    {\n+      Location locus = expr.get_locus ();\n+      tree compiled_expr = unit_expression (ctx, expr.get_locus ());\n+      tree result_reference\n+\t= ctx->get_backend ()->var_expression (result, locus);\n+\n+      tree assignment\n+\t= ctx->get_backend ()->assignment_statement (result_reference,\n+\t\t\t\t\t\t     compiled_expr,\n+\t\t\t\t\t\t     expr.get_locus ());\n+      ctx->add_statement (assignment);\n+    }\n \n   ctx->pop_block ();\n   translated = new_block;"}, {"sha": "96b7340b6b0e84896b487e84967aa26662207246", "filename": "gcc/rust/backend/rust-compile-expr.cc", "status": "modified", "additions": 61, "deletions": 88, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea597e73da52a4292986b5267fc535006ae4c343/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea597e73da52a4292986b5267fc535006ae4c343/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc?ref=ea597e73da52a4292986b5267fc535006ae4c343", "patch": "@@ -76,7 +76,7 @@ CompileExpr::visit (HIR::TupleExpr &expr)\n {\n   if (expr.is_unit ())\n     {\n-      translated = ctx->get_backend ()->unit_expression ();\n+      translated = unit_expression (ctx, expr.get_locus ());\n       return;\n     }\n \n@@ -110,18 +110,13 @@ CompileExpr::visit (HIR::ReturnExpr &expr)\n {\n   auto fncontext = ctx->peek_fn ();\n \n-  std::vector<tree> retstmts;\n-  if (expr.has_return_expr ())\n-    {\n-      tree compiled_expr = CompileExpr::Compile (expr.return_expr.get (), ctx);\n-      rust_assert (compiled_expr != nullptr);\n-\n-      retstmts.push_back (compiled_expr);\n-    }\n-\n-  auto s = ctx->get_backend ()->return_statement (fncontext.fndecl, retstmts,\n-\t\t\t\t\t\t  expr.get_locus ());\n-  ctx->add_statement (s);\n+  tree return_value = expr.has_return_expr ()\n+\t\t\t? CompileExpr::Compile (expr.return_expr.get (), ctx)\n+\t\t\t: unit_expression (ctx, expr.get_locus ());\n+  tree return_stmt\n+    = ctx->get_backend ()->return_statement (fncontext.fndecl, return_value,\n+\t\t\t\t\t     expr.get_locus ());\n+  ctx->add_statement (return_stmt);\n }\n \n void\n@@ -318,28 +313,23 @@ CompileExpr::visit (HIR::IfExprConseqElse &expr)\n     }\n \n   Bvariable *tmp = NULL;\n-  bool needs_temp = !if_type->is_unit ();\n-  if (needs_temp)\n-    {\n-      fncontext fnctx = ctx->peek_fn ();\n-      tree enclosing_scope = ctx->peek_enclosing_scope ();\n-      tree block_type = TyTyResolveCompile::compile (ctx, if_type);\n+  fncontext fnctx = ctx->peek_fn ();\n+  tree enclosing_scope = ctx->peek_enclosing_scope ();\n+  tree block_type = TyTyResolveCompile::compile (ctx, if_type);\n \n-      bool is_address_taken = false;\n-      tree ret_var_stmt = nullptr;\n-      tmp = ctx->get_backend ()->temporary_variable (\n-\tfnctx.fndecl, enclosing_scope, block_type, NULL, is_address_taken,\n-\texpr.get_locus (), &ret_var_stmt);\n-      ctx->add_statement (ret_var_stmt);\n-    }\n+  bool is_address_taken = false;\n+  tree ret_var_stmt = nullptr;\n+  tmp = ctx->get_backend ()->temporary_variable (fnctx.fndecl, enclosing_scope,\n+\t\t\t\t\t\t block_type, NULL,\n+\t\t\t\t\t\t is_address_taken,\n+\t\t\t\t\t\t expr.get_locus (),\n+\t\t\t\t\t\t &ret_var_stmt);\n+  ctx->add_statement (ret_var_stmt);\n \n   auto stmt = CompileConditionalBlocks::compile (&expr, ctx, tmp);\n   ctx->add_statement (stmt);\n \n-  if (tmp != NULL)\n-    {\n-      translated = ctx->get_backend ()->var_expression (tmp, expr.get_locus ());\n-    }\n+  translated = ctx->get_backend ()->var_expression (tmp, expr.get_locus ());\n }\n \n void\n@@ -354,29 +344,24 @@ CompileExpr::visit (HIR::BlockExpr &expr)\n     }\n \n   Bvariable *tmp = NULL;\n-  bool needs_temp = !block_tyty->is_unit ();\n-  if (needs_temp)\n-    {\n-      fncontext fnctx = ctx->peek_fn ();\n-      tree enclosing_scope = ctx->peek_enclosing_scope ();\n-      tree block_type = TyTyResolveCompile::compile (ctx, block_tyty);\n+  fncontext fnctx = ctx->peek_fn ();\n+  tree enclosing_scope = ctx->peek_enclosing_scope ();\n+  tree block_type = TyTyResolveCompile::compile (ctx, block_tyty);\n \n-      bool is_address_taken = false;\n-      tree ret_var_stmt = nullptr;\n-      tmp = ctx->get_backend ()->temporary_variable (\n-\tfnctx.fndecl, enclosing_scope, block_type, NULL, is_address_taken,\n-\texpr.get_locus (), &ret_var_stmt);\n-      ctx->add_statement (ret_var_stmt);\n-    }\n+  bool is_address_taken = false;\n+  tree ret_var_stmt = nullptr;\n+  tmp = ctx->get_backend ()->temporary_variable (fnctx.fndecl, enclosing_scope,\n+\t\t\t\t\t\t block_type, NULL,\n+\t\t\t\t\t\t is_address_taken,\n+\t\t\t\t\t\t expr.get_locus (),\n+\t\t\t\t\t\t &ret_var_stmt);\n+  ctx->add_statement (ret_var_stmt);\n \n   auto block_stmt = CompileBlock::compile (&expr, ctx, tmp);\n   rust_assert (TREE_CODE (block_stmt) == BIND_EXPR);\n   ctx->add_statement (block_stmt);\n \n-  if (tmp != NULL)\n-    {\n-      translated = ctx->get_backend ()->var_expression (tmp, expr.get_locus ());\n-    }\n+  translated = ctx->get_backend ()->var_expression (tmp, expr.get_locus ());\n }\n \n void\n@@ -397,7 +382,7 @@ CompileExpr::visit (HIR::StructExprStruct &struct_expr)\n     }\n \n   rust_assert (tyty->is_unit ());\n-  translated = ctx->get_backend ()->unit_expression ();\n+  translated = unit_expression (ctx, struct_expr.get_locus ());\n }\n \n void\n@@ -1318,19 +1303,17 @@ CompileExpr::visit (HIR::MatchExpr &expr)\n \n   fncontext fnctx = ctx->peek_fn ();\n   Bvariable *tmp = NULL;\n-  bool needs_temp = !expr_tyty->is_unit ();\n-  if (needs_temp)\n-    {\n-      tree enclosing_scope = ctx->peek_enclosing_scope ();\n-      tree block_type = TyTyResolveCompile::compile (ctx, expr_tyty);\n+  tree enclosing_scope = ctx->peek_enclosing_scope ();\n+  tree block_type = TyTyResolveCompile::compile (ctx, expr_tyty);\n \n-      bool is_address_taken = false;\n-      tree ret_var_stmt = nullptr;\n-      tmp = ctx->get_backend ()->temporary_variable (\n-\tfnctx.fndecl, enclosing_scope, block_type, NULL, is_address_taken,\n-\texpr.get_locus (), &ret_var_stmt);\n-      ctx->add_statement (ret_var_stmt);\n-    }\n+  bool is_address_taken = false;\n+  tree ret_var_stmt = nullptr;\n+  tmp = ctx->get_backend ()->temporary_variable (fnctx.fndecl, enclosing_scope,\n+\t\t\t\t\t\t block_type, NULL,\n+\t\t\t\t\t\t is_address_taken,\n+\t\t\t\t\t\t expr.get_locus (),\n+\t\t\t\t\t\t &ret_var_stmt);\n+  ctx->add_statement (ret_var_stmt);\n \n   // lets compile the scrutinee expression\n   tree match_scrutinee_expr\n@@ -1450,7 +1433,6 @@ CompileExpr::visit (HIR::MatchExpr &expr)\n   // setup the switch-body-block\n   Location start_location; // FIXME\n   Location end_location;   // FIXME\n-  tree enclosing_scope = ctx->peek_enclosing_scope ();\n   tree switch_body_block\n     = ctx->get_backend ()->block (fndecl, enclosing_scope, {}, start_location,\n \t\t\t\t  end_location);\n@@ -1481,16 +1463,12 @@ CompileExpr::visit (HIR::MatchExpr &expr)\n \n       // compile the expr and setup the assignment if required when tmp != NULL\n       tree kase_expr_tree = CompileExpr::Compile (kase.get_expr ().get (), ctx);\n-      if (tmp != NULL)\n-\t{\n-\t  tree result_reference\n-\t    = ctx->get_backend ()->var_expression (tmp, arm_locus);\n-\t  tree assignment\n-\t    = ctx->get_backend ()->assignment_statement (result_reference,\n-\t\t\t\t\t\t\t kase_expr_tree,\n-\t\t\t\t\t\t\t arm_locus);\n-\t  ctx->add_statement (assignment);\n-\t}\n+      tree result_reference\n+\t= ctx->get_backend ()->var_expression (tmp, arm_locus);\n+      tree assignment\n+\t= ctx->get_backend ()->assignment_statement (result_reference,\n+\t\t\t\t\t\t     kase_expr_tree, arm_locus);\n+      ctx->add_statement (assignment);\n \n       // go to end label\n       tree goto_end_label = build1_loc (arm_locus.gcc_location (), GOTO_EXPR,\n@@ -1507,10 +1485,7 @@ CompileExpr::visit (HIR::MatchExpr &expr)\n   ctx->add_statement (match_expr_stmt);\n   ctx->add_statement (end_label_decl_statement);\n \n-  if (tmp != NULL)\n-    {\n-      translated = ctx->get_backend ()->var_expression (tmp, expr.get_locus ());\n-    }\n+  translated = ctx->get_backend ()->var_expression (tmp, expr.get_locus ());\n }\n \n void\n@@ -2824,34 +2799,32 @@ CompileExpr::generate_closure_function (HIR::ClosureExpr &expr,\n   ctx->push_block (code_block);\n \n   TyTy::BaseType *tyret = &closure_tyty.get_result_type ();\n-  bool function_has_return = !closure_tyty.get_result_type ().is_unit ();\n   Bvariable *return_address = nullptr;\n-  if (function_has_return)\n-    {\n-      tree return_type = TyTyResolveCompile::compile (ctx, tyret);\n \n-      bool address_is_taken = false;\n-      tree ret_var_stmt = NULL_TREE;\n+  tree return_type = TyTyResolveCompile::compile (ctx, tyret);\n+  bool address_is_taken = false;\n+  tree ret_var_stmt = NULL_TREE;\n \n-      return_address = ctx->get_backend ()->temporary_variable (\n-\tfndecl, code_block, return_type, NULL, address_is_taken,\n-\texpr.get_locus (), &ret_var_stmt);\n+  return_address\n+    = ctx->get_backend ()->temporary_variable (fndecl, code_block, return_type,\n+\t\t\t\t\t       NULL, address_is_taken,\n+\t\t\t\t\t       expr.get_locus (),\n+\t\t\t\t\t       &ret_var_stmt);\n \n-      ctx->add_statement (ret_var_stmt);\n-    }\n+  ctx->add_statement (ret_var_stmt);\n \n   ctx->push_fn (fndecl, return_address);\n \n   if (is_block_expr)\n     {\n       HIR::BlockExpr *body = static_cast<HIR::BlockExpr *> (function_body);\n-      compile_function_body (ctx, fndecl, *body, true);\n+      compile_function_body (fndecl, *body, tyret);\n     }\n   else\n     {\n       tree value = CompileExpr::Compile (function_body, ctx);\n       tree return_expr\n-\t= ctx->get_backend ()->return_statement (fndecl, {value},\n+\t= ctx->get_backend ()->return_statement (fndecl, value,\n \t\t\t\t\t\t function_body->get_locus ());\n       ctx->add_statement (return_expr);\n     }"}, {"sha": "9f3e3345c2100dc9b95d791efa0a6cbd7ca73fbd", "filename": "gcc/rust/backend/rust-compile-implitem.cc", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea597e73da52a4292986b5267fc535006ae4c343/gcc%2Frust%2Fbackend%2Frust-compile-implitem.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea597e73da52a4292986b5267fc535006ae4c343/gcc%2Frust%2Fbackend%2Frust-compile-implitem.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-implitem.cc?ref=ea597e73da52a4292986b5267fc535006ae4c343", "patch": "@@ -17,8 +17,6 @@\n // <http://www.gnu.org/licenses/>.\n \n #include \"rust-compile-implitem.h\"\n-#include \"rust-compile-expr.h\"\n-#include \"rust-compile-fnparam.h\"\n \n namespace Rust {\n namespace Compile {\n@@ -36,8 +34,8 @@ CompileTraitItem::visit (HIR::TraitItemConst &constant)\n \n   HIR::Expr *const_value_expr = constant.get_expr ().get ();\n   tree const_expr\n-    = compile_constant_item (ctx, resolved_type, canonical_path,\n-\t\t\t     const_value_expr, constant.get_locus ());\n+    = compile_constant_item (resolved_type, canonical_path, const_value_expr,\n+\t\t\t     constant.get_locus ());\n   ctx->push_const (const_expr);\n   ctx->insert_const_decl (constant.get_mappings ().get_hirid (), const_expr);\n \n@@ -88,12 +86,11 @@ CompileTraitItem::visit (HIR::TraitItemFunc &func)\n   auto vis = HIR::Visibility (HIR::Visibility::VisType::PUBLIC);\n   HIR::TraitFunctionDecl &function = func.get_decl ();\n   tree fndecl\n-    = compile_function (ctx, function.get_function_name (),\n-\t\t\tfunction.get_self (), function.get_function_params (),\n+    = compile_function (function.get_function_name (), function.get_self (),\n+\t\t\tfunction.get_function_params (),\n \t\t\tfunction.get_qualifiers (), vis,\n \t\t\tfunc.get_outer_attrs (), func.get_locus (),\n-\t\t\tfunc.get_block_expr ().get (), canonical_path, fntype,\n-\t\t\tfunction.has_return_type ());\n+\t\t\tfunc.get_block_expr ().get (), canonical_path, fntype);\n   reference = address_expression (fndecl, ref_locus);\n }\n "}, {"sha": "4ba2956e96bde59af60a9167707b334610eaa98c", "filename": "gcc/rust/backend/rust-compile-item.cc", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea597e73da52a4292986b5267fc535006ae4c343/gcc%2Frust%2Fbackend%2Frust-compile-item.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea597e73da52a4292986b5267fc535006ae4c343/gcc%2Frust%2Fbackend%2Frust-compile-item.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-item.cc?ref=ea597e73da52a4292986b5267fc535006ae4c343", "patch": "@@ -49,7 +49,7 @@ CompileItem::visit (HIR::StaticItem &var)\n \n   HIR::Expr *const_value_expr = var.get_expr ();\n   ctx->push_const_context ();\n-  tree value = compile_constant_item (ctx, resolved_type, canonical_path,\n+  tree value = compile_constant_item (resolved_type, canonical_path,\n \t\t\t\t      const_value_expr, var.get_locus ());\n   ctx->pop_const_context ();\n \n@@ -97,8 +97,8 @@ CompileItem::visit (HIR::ConstantItem &constant)\n   HIR::Expr *const_value_expr = constant.get_expr ();\n   ctx->push_const_context ();\n   tree const_expr\n-    = compile_constant_item (ctx, resolved_type, canonical_path,\n-\t\t\t     const_value_expr, constant.get_locus ());\n+    = compile_constant_item (resolved_type, canonical_path, const_value_expr,\n+\t\t\t     constant.get_locus ());\n   ctx->pop_const_context ();\n \n   ctx->push_const (const_expr);\n@@ -161,13 +161,13 @@ CompileItem::visit (HIR::Function &function)\n     ctx->push_const_context ();\n \n   tree fndecl\n-    = compile_function (ctx, function.get_function_name (),\n+    = compile_function (function.get_function_name (),\n \t\t\tfunction.get_self_param (),\n \t\t\tfunction.get_function_params (),\n \t\t\tfunction.get_qualifiers (), function.get_visibility (),\n \t\t\tfunction.get_outer_attrs (), function.get_locus (),\n \t\t\tfunction.get_definition ().get (), canonical_path,\n-\t\t\tfntype, function.has_function_return_type ());\n+\t\t\tfntype);\n   reference = address_expression (fndecl, ref_locus);\n \n   if (function.get_qualifiers ().is_const ())"}, {"sha": "399199421fa843109abebb7d6fb74daae66e6545", "filename": "gcc/rust/backend/rust-compile-pattern.cc", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea597e73da52a4292986b5267fc535006ae4c343/gcc%2Frust%2Fbackend%2Frust-compile-pattern.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea597e73da52a4292986b5267fc535006ae4c343/gcc%2Frust%2Fbackend%2Frust-compile-pattern.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-pattern.cc?ref=ea597e73da52a4292986b5267fc535006ae4c343", "patch": "@@ -359,11 +359,7 @@ CompilePatternLet::visit (HIR::IdentifierPattern &pattern)\n     {\n       ctx->add_statement (init_expr);\n \n-      tree stmt_type = TyTyResolveCompile::compile (ctx, ty);\n-\n-      auto unit_type_init_expr\n-\t= ctx->get_backend ()->constructor_expression (stmt_type, false, {}, -1,\n-\t\t\t\t\t\t       rval_locus);\n+      auto unit_type_init_expr = unit_expression (ctx, rval_locus);\n       auto s = ctx->get_backend ()->init_statement (fnctx.fndecl, var,\n \t\t\t\t\t\t    unit_type_init_expr);\n       ctx->add_statement (s);"}, {"sha": "d4e3780950c3e463fd59eab905d80a6c670157e6", "filename": "gcc/rust/backend/rust-compile-resolve-path.cc", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea597e73da52a4292986b5267fc535006ae4c343/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea597e73da52a4292986b5267fc535006ae4c343/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc?ref=ea597e73da52a4292986b5267fc535006ae4c343", "patch": "@@ -65,12 +65,8 @@ ResolvePathRef::resolve (const HIR::PathIdentSegment &final_segment,\n \treturn error_mark_node;\n \n       TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (lookup);\n-\n-      // it might be a unit-struct\n       if (adt->is_unit ())\n-\t{\n-\t  return ctx->get_backend ()->unit_expression ();\n-\t}\n+\treturn unit_expression (ctx, expr_locus);\n \n       if (!adt->is_enum ())\n \treturn error_mark_node;"}, {"sha": "7eadb3839d4bdf1335c6c40d6eb2051452d17c8f", "filename": "gcc/rust/backend/rust-compile-type.cc", "status": "modified", "additions": 21, "deletions": 10, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea597e73da52a4292986b5267fc535006ae4c343/gcc%2Frust%2Fbackend%2Frust-compile-type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea597e73da52a4292986b5267fc535006ae4c343/gcc%2Frust%2Fbackend%2Frust-compile-type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-type.cc?ref=ea597e73da52a4292986b5267fc535006ae4c343", "patch": "@@ -86,6 +86,20 @@ TyTyResolveCompile::get_implicit_enumeral_node_type (Context *ctx)\n   return enum_node;\n }\n \n+tree\n+TyTyResolveCompile::get_unit_type (Context *ctx)\n+{\n+  static tree unit_type;\n+  if (unit_type == nullptr)\n+    {\n+      auto unit_type_node = ctx->get_backend ()->struct_type ({});\n+      unit_type\n+\t= ctx->get_backend ()->named_type (\"()\", unit_type_node,\n+\t\t\t\t\t   Linemap::predeclared_location ());\n+    }\n+  return unit_type;\n+}\n+\n void\n TyTyResolveCompile::visit (const TyTy::ErrorType &)\n {\n@@ -163,14 +177,11 @@ TyTyResolveCompile::visit (const TyTy::FnType &type)\n   std::vector<Backend::typed_identifier> parameters;\n   std::vector<Backend::typed_identifier> results;\n \n-  if (!type.get_return_type ()->is_unit ())\n-    {\n-      auto hir_type = type.get_return_type ();\n-      auto ret = TyTyResolveCompile::compile (ctx, hir_type, trait_object_mode);\n-      results.push_back (Backend::typed_identifier (\n-\t\"_\", ret,\n-\tctx->get_mappings ()->lookup_location (hir_type->get_ref ())));\n-    }\n+  auto hir_type = type.get_return_type ();\n+  auto ret = TyTyResolveCompile::compile (ctx, hir_type, trait_object_mode);\n+  Location return_type_locus\n+    = ctx->get_mappings ()->lookup_location (hir_type->get_ref ());\n+  results.push_back (Backend::typed_identifier (\"_\", ret, return_type_locus));\n \n   for (auto &param_pair : type.get_params ())\n     {\n@@ -362,7 +373,7 @@ TyTyResolveCompile::visit (const TyTy::TupleType &type)\n {\n   if (type.num_fields () == 0)\n     {\n-      translated = ctx->get_backend ()->unit_type ();\n+      translated = get_unit_type (ctx);\n       return;\n     }\n \n@@ -651,7 +662,7 @@ TyTyResolveCompile::visit (const TyTy::StrType &type)\n void\n TyTyResolveCompile::visit (const TyTy::NeverType &)\n {\n-  translated = ctx->get_backend ()->unit_type ();\n+  translated = get_unit_type (ctx);\n }\n \n void"}, {"sha": "66791f3b25acbe43c5acb3262fe81aa9d8639352", "filename": "gcc/rust/backend/rust-compile-type.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea597e73da52a4292986b5267fc535006ae4c343/gcc%2Frust%2Fbackend%2Frust-compile-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea597e73da52a4292986b5267fc535006ae4c343/gcc%2Frust%2Fbackend%2Frust-compile-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-type.h?ref=ea597e73da52a4292986b5267fc535006ae4c343", "patch": "@@ -32,6 +32,8 @@ class TyTyResolveCompile : protected TyTy::TyConstVisitor\n \n   static tree get_implicit_enumeral_node_type (Context *ctx);\n \n+  static tree get_unit_type (Context *ctx);\n+\n   void visit (const TyTy::InferType &) override;\n   void visit (const TyTy::ADTType &) override;\n   void visit (const TyTy::TupleType &) override;"}, {"sha": "34443cd12f7969837994a87acbbe79a20218891e", "filename": "gcc/rust/backend/rust-constexpr.cc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea597e73da52a4292986b5267fc535006ae4c343/gcc%2Frust%2Fbackend%2Frust-constexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea597e73da52a4292986b5267fc535006ae4c343/gcc%2Frust%2Fbackend%2Frust-constexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-constexpr.cc?ref=ea597e73da52a4292986b5267fc535006ae4c343", "patch": "@@ -2248,7 +2248,6 @@ eval_constant_expression (const constexpr_ctx *ctx, tree t, bool lval,\n \t/* Don't VERIFY_CONSTANT here.  */\n \tif (*non_constant_p)\n \t  return t;\n-\tgcc_checking_assert (TREE_CODE (op) != CONSTRUCTOR);\n \t/* This function does more aggressive folding than fold itself.  */\n \tr = build_fold_addr_expr_with_type (op, TREE_TYPE (t));\n \tif (TREE_CODE (r) == ADDR_EXPR && TREE_OPERAND (r, 0) == oldop)"}, {"sha": "42b28399f4f32cb4875eae99e598af7d91c5a2f6", "filename": "gcc/rust/rust-backend.h", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea597e73da52a4292986b5267fc535006ae4c343/gcc%2Frust%2Frust-backend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea597e73da52a4292986b5267fc535006ae4c343/gcc%2Frust%2Frust-backend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-backend.h?ref=ea597e73da52a4292986b5267fc535006ae4c343", "patch": "@@ -70,9 +70,6 @@ class Backend\n \n   // Types.\n \n-  // get unit-type\n-  virtual tree unit_type () = 0;\n-\n   // Get the unnamed boolean type.\n   virtual tree bool_type () = 0;\n \n@@ -173,8 +170,6 @@ class Backend\n   // converting nil to other types.\n   virtual tree zero_expression (tree) = 0;\n \n-  virtual tree unit_expression () = 0;\n-\n   // Create a reference to a variable.\n   virtual tree var_expression (Bvariable *var, Location) = 0;\n \n@@ -302,9 +297,9 @@ class Backend\n   // Create an assignment statement within the specified function.\n   virtual tree assignment_statement (tree lhs, tree rhs, Location) = 0;\n \n-  // Create a return statement, passing the representation of the\n-  // function and the list of values to return.\n-  virtual tree return_statement (tree, const std::vector<tree> &, Location) = 0;\n+  // Create return statement for an decl for a value (can be NULL_TREE) at a\n+  // location\n+  virtual tree return_statement (tree fndecl, tree val, Location) = 0;\n \n   // Create an if statement within a function.  ELSE_BLOCK may be NULL.\n   virtual tree if_statement (tree, tree condition, tree then_block,"}, {"sha": "47cb734101fcab2bcb320c3b9cc27d3a80a9b099", "filename": "gcc/rust/rust-gcc.cc", "status": "modified", "additions": 8, "deletions": 108, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea597e73da52a4292986b5267fc535006ae4c343/gcc%2Frust%2Frust-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea597e73da52a4292986b5267fc535006ae4c343/gcc%2Frust%2Frust-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-gcc.cc?ref=ea597e73da52a4292986b5267fc535006ae4c343", "patch": "@@ -98,19 +98,6 @@ class Gcc_backend : public Backend\n \n   // Types.\n \n-  tree unit_type ()\n-  {\n-    static tree unit_type;\n-    if (unit_type == nullptr)\n-      {\n-\tauto unit_type_node = struct_type ({});\n-\tunit_type = named_type (\"()\", unit_type_node,\n-\t\t\t\t::Linemap::predeclared_location ());\n-      }\n-\n-    return unit_type;\n-  }\n-\n   tree bool_type () { return boolean_type_node; }\n \n   tree char_type () { return char_type_node; }\n@@ -170,8 +157,6 @@ class Gcc_backend : public Backend\n \n   tree zero_expression (tree);\n \n-  tree unit_expression () { return integer_zero_node; }\n-\n   tree var_expression (Bvariable *var, Location);\n \n   tree integer_constant_expression (tree type, mpz_t val);\n@@ -236,7 +221,7 @@ class Gcc_backend : public Backend\n \n   tree assignment_statement (tree lhs, tree rhs, Location);\n \n-  tree return_statement (tree, const std::vector<tree> &, Location);\n+  tree return_statement (tree fndecl, tree val, Location locus);\n \n   tree if_statement (tree, tree condition, tree then_block, tree else_block,\n \t\t     Location);\n@@ -720,14 +705,6 @@ Gcc_backend::function_type (const typed_identifier &receiver,\n   if (result == error_mark_node)\n     return error_mark_node;\n \n-  // The libffi library cannot represent a zero-sized object.  To\n-  // avoid causing confusion on 32-bit SPARC, we treat a function that\n-  // returns a zero-sized value as returning void.  That should do no\n-  // harm since there is no actual value to be returned.  See\n-  // https://gcc.gnu.org/PR72814 for details.\n-  if (result != void_type_node && int_size_in_bytes (result) == 0)\n-    result = void_type_node;\n-\n   tree fntype = build_function_type (result, args);\n   if (fntype == error_mark_node)\n     return error_mark_node;\n@@ -776,14 +753,6 @@ Gcc_backend::function_type_varadic (\n   if (result == error_mark_node)\n     return error_mark_node;\n \n-  // The libffi library cannot represent a zero-sized object.  To\n-  // avoid causing confusion on 32-bit SPARC, we treat a function that\n-  // returns a zero-sized value as returning void.  That should do no\n-  // harm since there is no actual value to be returned.  See\n-  // https://gcc.gnu.org/PR72814 for details.\n-  if (result != void_type_node && int_size_in_bytes (result) == 0)\n-    result = void_type_node;\n-\n   tree fntype = build_varargs_function_type_array (result, n, args);\n   if (fntype == error_mark_node)\n     return error_mark_node;\n@@ -1988,90 +1957,21 @@ Gcc_backend::assignment_statement (tree lhs, tree rhs, Location location)\n // Return.\n \n tree\n-Gcc_backend::return_statement (tree fntree, const std::vector<tree> &vals,\n-\t\t\t       Location location)\n+Gcc_backend::return_statement (tree fntree, tree val, Location location)\n {\n   if (fntree == error_mark_node)\n     return error_mark_node;\n+\n   tree result = DECL_RESULT (fntree);\n   if (result == error_mark_node)\n     return error_mark_node;\n \n-  // If the result size is zero bytes, we have set the function type\n-  // to have a result type of void, so don't return anything.\n-  // See the function_type method.\n-  tree res_type = TREE_TYPE (result);\n-  if (res_type == void_type_node || int_size_in_bytes (res_type) == 0)\n-    {\n-      tree stmt_list = NULL_TREE;\n-      for (std::vector<tree>::const_iterator p = vals.begin ();\n-\t   p != vals.end (); p++)\n-\t{\n-\t  tree val = (*p);\n-\t  if (val == error_mark_node)\n-\t    return error_mark_node;\n-\t  append_to_statement_list (val, &stmt_list);\n-\t}\n-      tree ret = fold_build1_loc (location.gcc_location (), RETURN_EXPR,\n-\t\t\t\t  void_type_node, NULL_TREE);\n-      append_to_statement_list (ret, &stmt_list);\n-      return stmt_list;\n-    }\n-\n-  tree ret;\n-  if (vals.empty ())\n-    ret = fold_build1_loc (location.gcc_location (), RETURN_EXPR,\n-\t\t\t   void_type_node, NULL_TREE);\n-  else if (vals.size () == 1)\n-    {\n-      tree val = vals.front ();\n-      if (val == error_mark_node)\n-\treturn error_mark_node;\n-      tree set = fold_build2_loc (location.gcc_location (), MODIFY_EXPR,\n-\t\t\t\t  void_type_node, result, vals.front ());\n-      ret = fold_build1_loc (location.gcc_location (), RETURN_EXPR,\n-\t\t\t     void_type_node, set);\n-    }\n-  else\n-    {\n-      // To return multiple values, copy the values into a temporary\n-      // variable of the right structure type, and then assign the\n-      // temporary variable to the DECL_RESULT in the return\n-      // statement.\n-      tree stmt_list = NULL_TREE;\n-      tree rettype = TREE_TYPE (result);\n-\n-      if (DECL_STRUCT_FUNCTION (fntree) == NULL)\n-\tpush_struct_function (fntree);\n-      else\n-\tpush_cfun (DECL_STRUCT_FUNCTION (fntree));\n-      tree rettmp = create_tmp_var (rettype, \"RESULT\");\n-      pop_cfun ();\n+  if (val == error_mark_node)\n+    return error_mark_node;\n \n-      tree field = TYPE_FIELDS (rettype);\n-      for (std::vector<tree>::const_iterator p = vals.begin ();\n-\t   p != vals.end (); p++, field = DECL_CHAIN (field))\n-\t{\n-\t  gcc_assert (field != NULL_TREE);\n-\t  tree ref\n-\t    = fold_build3_loc (location.gcc_location (), COMPONENT_REF,\n-\t\t\t       TREE_TYPE (field), rettmp, field, NULL_TREE);\n-\t  tree val = (*p);\n-\t  if (val == error_mark_node)\n-\t    return error_mark_node;\n-\t  tree set = fold_build2_loc (location.gcc_location (), MODIFY_EXPR,\n-\t\t\t\t      void_type_node, ref, (*p));\n-\t  append_to_statement_list (set, &stmt_list);\n-\t}\n-      gcc_assert (field == NULL_TREE);\n-      tree set = fold_build2_loc (location.gcc_location (), MODIFY_EXPR,\n-\t\t\t\t  void_type_node, result, rettmp);\n-      tree ret_expr = fold_build1_loc (location.gcc_location (), RETURN_EXPR,\n-\t\t\t\t       void_type_node, set);\n-      append_to_statement_list (ret_expr, &stmt_list);\n-      ret = stmt_list;\n-    }\n-  return ret;\n+  auto locus = location.gcc_location ();\n+  tree set = fold_build2_loc (locus, MODIFY_EXPR, void_type_node, result, val);\n+  return fold_build1_loc (locus, RETURN_EXPR, void_type_node, set);\n }\n \n // Create a statement that attempts to execute BSTAT and calls EXCEPT_STMT if an"}, {"sha": "5f6ac852817a5ed0314ff747fd681f86a0d90649", "filename": "gcc/testsuite/rust/compile/issue-2188.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea597e73da52a4292986b5267fc535006ae4c343/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-2188.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea597e73da52a4292986b5267fc535006ae4c343/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-2188.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-2188.rs?ref=ea597e73da52a4292986b5267fc535006ae4c343", "patch": "@@ -0,0 +1 @@\n+static _V: () = {};"}]}