{"sha": "bed8af19ec83d0e51a37a55faf1a87979a85a9b9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmVkOGFmMTllYzgzZDBlNTFhMzdhNTVmYWYxYTg3OTc5YTg1YTliOQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-04T15:07:59Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-04T15:07:59Z"}, "message": "[multiple changes]\n\n2010-10-04  Vincent Celier  <celier@adacore.com>\n\n\t* a-direct.adb (Copy_File): Interpret the Form parameter and call\n\tSystem.OS_Lib.Copy_File to do the work accordingly. Raise Use_Error if\n\tthe Form parameter contains an incorrect value for field preserve= or\n\tmode=.\n\t* a-direct.ads (Create_Directory, Create_Path): Indicate that the Form\n\tparameter is ignored.\n\t(Copy_File): Indicate the interpretation of the Form parameter.\n\n2010-10-04  Vincent Celier  <celier@adacore.com>\n\n\t* make.adb (Gnatmake): When there are no foreign languages declared and\n\ta main in attribute Main of the main project does not exist or is a\n\tsource of another project, fail immediately before attempting\n\tcompilation.\n\n2010-10-04  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_disp.ads (Convert_Tag_To_Interface): New function which must be\n\tused to convert a node referencing a tag to a class-wide interface type.\n\t* exp_disp.adb (Convert_Tag_To_Interface): New function.\n\t(Expand_Interface_Conversion): Replace invocation of\n\tUnchecked_Conversion by new function Convert_Tag_To_Interface.\n\t(Write_DT): Add support for null primitives.\n\t* exp_ch3.adb (Expand_N_Object_Declaration): For tagged type objects,\n\tcleanup code that handles interface conversions and avoid unchecked\n\tconversion of referenced tag components.\n\t* exp_ch5.adb (Expand_N_Assignment_Statement): Code cleanup. Avoid\n\tunrequired conversions when generating a dispatching call to _assign.\n\t* sprint.adb (Write_Itype): Fix wrong output of not null access itypes.\n\n2010-10-04  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_ch4.adb (Expand_N_Op_Not): Handle properly both operands when the\n\tparent is a binary boolean operation and the operand is an unpacked\n\tarray.\n\t(Build_Boolean_Array_Proc_Call): If the operands are both negations, the\n\toperands of the rewritten node are the operands of the negations, not\n\tthe negations themselves.\n\nFrom-SVN: r164942", "tree": {"sha": "d86193b63a1853cbc95c49932831c817706056d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d86193b63a1853cbc95c49932831c817706056d6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bed8af19ec83d0e51a37a55faf1a87979a85a9b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bed8af19ec83d0e51a37a55faf1a87979a85a9b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bed8af19ec83d0e51a37a55faf1a87979a85a9b9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bed8af19ec83d0e51a37a55faf1a87979a85a9b9/comments", "author": null, "committer": null, "parents": [{"sha": "c452684d45087cb02bf3a9ebe973682a3b946a56", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c452684d45087cb02bf3a9ebe973682a3b946a56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c452684d45087cb02bf3a9ebe973682a3b946a56"}], "stats": {"total": 507, "additions": 382, "deletions": 125}, "files": [{"sha": "7aeb5a7cb64c1732c55fc38aedce0ddb3fa7320c", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bed8af19ec83d0e51a37a55faf1a87979a85a9b9/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bed8af19ec83d0e51a37a55faf1a87979a85a9b9/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=bed8af19ec83d0e51a37a55faf1a87979a85a9b9", "patch": "@@ -1,3 +1,44 @@\n+2010-10-04  Vincent Celier  <celier@adacore.com>\n+\n+\t* a-direct.adb (Copy_File): Interpret the Form parameter and call\n+\tSystem.OS_Lib.Copy_File to do the work accordingly. Raise Use_Error if\n+\tthe Form parameter contains an incorrect value for field preserve= or\n+\tmode=.\n+\t* a-direct.ads (Create_Directory, Create_Path): Indicate that the Form\n+\tparameter is ignored.\n+\t(Copy_File): Indicate the interpretation of the Form parameter.\n+\n+2010-10-04  Vincent Celier  <celier@adacore.com>\n+\n+\t* make.adb (Gnatmake): When there are no foreign languages declared and\n+\ta main in attribute Main of the main project does not exist or is a\n+\tsource of another project, fail immediately before attempting\n+\tcompilation.\n+\n+2010-10-04  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_disp.ads (Convert_Tag_To_Interface): New function which must be\n+\tused to convert a node referencing a tag to a class-wide interface type.\n+\t* exp_disp.adb (Convert_Tag_To_Interface): New function.\n+\t(Expand_Interface_Conversion): Replace invocation of\n+\tUnchecked_Conversion by new function Convert_Tag_To_Interface.\n+\t(Write_DT): Add support for null primitives.\n+\t* exp_ch3.adb (Expand_N_Object_Declaration): For tagged type objects,\n+\tcleanup code that handles interface conversions and avoid unchecked\n+\tconversion of referenced tag components.\n+\t* exp_ch5.adb (Expand_N_Assignment_Statement): Code cleanup. Avoid\n+\tunrequired conversions when generating a dispatching call to _assign.\n+\t* sprint.adb (Write_Itype): Fix wrong output of not null access itypes.\n+\n+2010-10-04  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_ch4.adb (Expand_N_Op_Not): Handle properly both operands when the\n+\tparent is a binary boolean operation and the operand is an unpacked\n+\tarray.\n+\t(Build_Boolean_Array_Proc_Call): If the operands are both negations, the\n+\toperands of the rewritten node are the operands of the negations, not\n+\tthe negations themselves.\n+\n 2010-10-04  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_ch13.adb (Set_Biased): New procedure, now used throughout, adds"}, {"sha": "c2c19d9142ee376f969333fbd0000013260a2c48", "filename": "gcc/ada/a-direct.adb", "status": "modified", "additions": 68, "deletions": 5, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bed8af19ec83d0e51a37a55faf1a87979a85a9b9/gcc%2Fada%2Fa-direct.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bed8af19ec83d0e51a37a55faf1a87979a85a9b9/gcc%2Fada%2Fa-direct.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-direct.adb?ref=bed8af19ec83d0e51a37a55faf1a87979a85a9b9", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -42,6 +42,7 @@ with Ada.Characters.Handling;    use Ada.Characters.Handling;\n with System.CRTL;                use System.CRTL;\n with System.OS_Lib;              use System.OS_Lib;\n with System.Regexp;              use System.Regexp;\n+with System.File_IO;             use System.File_IO;\n \n with System;\n \n@@ -301,9 +302,11 @@ package body Ada.Directories is\n       Target_Name : String;\n       Form        : String := \"\")\n    is\n-      pragma Unreferenced (Form);\n       Success : Boolean;\n \n+      Mode     : Copy_Mode := Overwrite;\n+      Preserve : Attribute := None;\n+\n    begin\n       --  First, the invalid cases\n \n@@ -322,10 +325,70 @@ package body Ada.Directories is\n          raise Use_Error with \"target \"\"\" & Target_Name & \"\"\" is a directory\";\n \n       else\n-         --  The implementation uses System.OS_Lib.Copy_File, with parameters\n-         --  suitable for all platforms.\n+         if Form'Length > 0 then\n+            declare\n+               Formstr : String (1 .. Form'Length + 1);\n+               V1, V2  : Natural;\n+\n+            begin\n+\n+               --  Acquire form string, setting required NUL terminator\n+\n+               Formstr (1 .. Form'Length) := Form;\n+               Formstr (Formstr'Last) := ASCII.NUL;\n+\n+               --  Convert form string to lower case\n+\n+               for J in Formstr'Range loop\n+                  if Formstr (J) in 'A' .. 'Z' then\n+                     Formstr (J) :=\n+                       Character'Val (Character'Pos (Formstr (J)) + 32);\n+                  end if;\n+               end loop;\n+\n+               --  Check Form\n+\n+               Form_Parameter (Formstr, \"mode\", V1, V2);\n+\n+               if V1 = 0 then\n+                  Mode := Overwrite;\n+\n+               elsif Formstr (V1 .. V2) = \"copy\" then\n+                  Mode := Copy;\n+\n+               elsif Formstr (V1 .. V2) = \"overwrite\" then\n+                  Mode := Overwrite;\n+\n+               elsif Formstr (V1 .. V2) = \"append\" then\n+                  Mode := Append;\n+\n+               else\n+                  raise Use_Error with \"invalid Form\";\n+               end if;\n+\n+               Form_Parameter (Formstr, \"preserve\", V1, V2);\n+\n+               if V1 = 0 then\n+                  Preserve := None;\n+\n+               elsif Formstr (V1 .. V2) = \"timestamps\" then\n+                  Preserve := Time_Stamps;\n+\n+               elsif Formstr (V1 .. V2) = \"all_attributes\" then\n+                  Preserve := Full;\n+\n+               elsif Formstr (V1 .. V2) = \"no_attributes\" then\n+                  Preserve := None;\n+\n+               else\n+                  raise Use_Error with \"invalid Form\";\n+               end if;\n+            end;\n+         end if;\n+\n+         --  The implementation uses System.OS_Lib.Copy_File\n \n-         Copy_File (Source_Name, Target_Name, Success, Overwrite, None);\n+         Copy_File (Source_Name, Target_Name, Success, Mode, Preserve);\n \n          if not Success then\n             raise Use_Error with \"copy of \"\"\" & Source_Name & \"\"\" failed\";"}, {"sha": "ddabed6fc337461cbc9968ebdffdba316b8f69cc", "filename": "gcc/ada/a-direct.ads", "status": "modified", "additions": 40, "deletions": 1, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bed8af19ec83d0e51a37a55faf1a87979a85a9b9/gcc%2Fada%2Fa-direct.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bed8af19ec83d0e51a37a55faf1a87979a85a9b9/gcc%2Fada%2Fa-direct.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-direct.ads?ref=bed8af19ec83d0e51a37a55faf1a87979a85a9b9", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived for use with GNAT from AI-00248,  which is --\n -- expected to be a part of a future expected revised Ada Reference Manual. --\n@@ -104,6 +104,8 @@ package Ada.Directories is\n    --  identification of a directory. The exception Use_Error is propagated if\n    --  the external environment does not support the creation of a directory\n    --  with the given name (in the absence of Name_Error) and form.\n+   --\n+   --  The Form parameter is ignored.\n \n    procedure Delete_Directory (Directory : String);\n    --  Deletes an existing empty directory with name Directory. The exception\n@@ -129,6 +131,8 @@ package Ada.Directories is\n    --  The exception Use_Error is propagated if the external environment does\n    --  not support the creation of any directories with the given name (in the\n    --  absence of Name_Error) and form.\n+   --\n+   --  The Form parameter is ignored.\n \n    procedure Delete_Tree (Directory : String);\n    --  Deletes an existing directory with name Directory. The directory and\n@@ -172,6 +176,41 @@ package Ada.Directories is\n    --  not support the creating of the file with the name given by Target_Name\n    --  and form given by Form, or copying of the file with the name given by\n    --  Source_Name (in the absence of Name_Error).\n+   --\n+   --  Interpretation of the Form parameter:\n+   --  The Form parameter is case-insensitive.\n+   --  Two fields are recognized in the Form parameter:\n+   --    preserve=<value>\n+   --    mode=<value>\n+   --  <value> starts immediatey after the character '=' and ends with the\n+   --  character immediatey preceding the next comma (',') or with the last\n+   --  character of the parameter.\n+   --  The only possible values for preserve= are:\n+   --     no_attributes: do not try to preserve any file attributes. This is\n+   --                    the default if no preserve= is found in Form.\n+   --     all_attributes: try to preserve all file attributes (timestamps,\n+   --                     access rights).\n+   --     timestamps: preserve the timestamp of the copied file, but not the\n+   --                 other file attributes.\n+   --  The only possible values for mode= are:\n+   --     copy: only do the copy if the destination file does not already\n+   --           exist. If it already exist, Copy_File fails.\n+   --     overwrite: copy the file in all cases. Overwite an aready existing\n+   --                destination file.\n+   --     append: append the original file to the destination file. If the\n+   --             destination file does not exist, the destination file is\n+   --             a copy of the source file.\n+   --             When mode=append, the field preserve=, if it exists, is not\n+   --             taken into account.\n+   --  If the Form parameter includes one or both of the fields and the value\n+   --  or values are incorrect, Copy_file fails with Use_Error.\n+   --  Examples of correct Forms:\n+   --     Form => \"preserve=no_attributes,mode=overwrite\" (the default)\n+   --     Form => \"mode=append\"\n+   --     Form => \"mode=copy, preserve=all_attributes\"\n+   --  Examples of incorrect Forms\n+   --     Form => \"preserve=junk\"\n+   --     Form => \"mode=internal, preserve=timestamps\"\n \n    ----------------------------------------\n    -- File and directory name operations --"}, {"sha": "93e1dfd02fc6554c0b5db3b6295b6a86c0c0a971", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 78, "deletions": 85, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bed8af19ec83d0e51a37a55faf1a87979a85a9b9/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bed8af19ec83d0e51a37a55faf1a87979a85a9b9/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=bed8af19ec83d0e51a37a55faf1a87979a85a9b9", "patch": "@@ -4809,20 +4809,20 @@ package body Exp_Ch3 is\n                   Iface    : constant Entity_Id := Root_Type (Typ);\n                   Expr_N   : Node_Id := Expr;\n                   Expr_Typ : Entity_Id;\n-\n-                  Decl_1   : Node_Id;\n-                  Decl_2   : Node_Id;\n                   New_Expr : Node_Id;\n+                  Obj_Id   : Entity_Id;\n+                  Tag_Comp : Node_Id;\n \n                begin\n                   --  If the original node of the expression was a conversion\n                   --  to this specific class-wide interface type then we\n-                  --  restore the original node to generate code that\n-                  --  statically displaces the pointer to the interface\n-                  --  component.\n+                  --  restore the original node because we must copy the object\n+                  --  before displacing the pointer to reference the secondary\n+                  --  tag component. This code must be kept synchronized with\n+                  --  the expansion done by routine Expand_Interface_Conversion\n \n                   if not Comes_From_Source (Expr_N)\n-                    and then Nkind (Expr_N) = N_Unchecked_Type_Conversion\n+                    and then Nkind (Expr_N) = N_Explicit_Dereference\n                     and then Nkind (Original_Node (Expr_N)) = N_Type_Conversion\n                     and then Etype (Original_Node (Expr_N)) = Typ\n                   then\n@@ -4839,6 +4839,7 @@ package body Exp_Ch3 is\n                      Set_Expression (N, Expr_N);\n                   end if;\n \n+                  Obj_Id   := Make_Temporary (Loc, 'D', Expr_N);\n                   Expr_Typ := Base_Type (Etype (Expr_N));\n \n                   if Is_Class_Wide_Type (Expr_Typ) then\n@@ -4849,122 +4850,114 @@ package body Exp_Ch3 is\n                   --     CW : I'Class := Obj;\n                   --  by\n                   --     Tmp : T := Obj;\n-                  --     CW  : I'Class renames TiC!(Tmp.I_Tag);\n+                  --     type Ityp is not null access I'Class;\n+                  --     CW  : I'Class renames Ityp(Tmp.I_Tag'Address).all;\n \n                   if Comes_From_Source (Expr_N)\n                     and then Nkind (Expr_N) = N_Identifier\n                     and then not Is_Interface (Expr_Typ)\n+                    and then Interface_Present_In_Ancestor (Expr_Typ, Typ)\n                     and then (Expr_Typ = Etype (Expr_Typ)\n                                or else not\n                               Is_Variable_Size_Record (Etype (Expr_Typ)))\n                   then\n-                     Decl_1 :=\n+                     --  Copy the object\n+\n+                     Insert_Action (N,\n                        Make_Object_Declaration (Loc,\n-                         Defining_Identifier =>\n-                           Make_Temporary (Loc, 'D', Expr_N),\n+                         Defining_Identifier => Obj_Id,\n                          Object_Definition =>\n                            New_Occurrence_Of (Expr_Typ, Loc),\n                          Expression =>\n-                           Unchecked_Convert_To (Expr_Typ,\n-                             Relocate_Node (Expr_N)));\n+                           Relocate_Node (Expr_N)));\n \n                      --  Statically reference the tag associated with the\n                      --  interface\n \n-                     Decl_2 :=\n-                       Make_Object_Renaming_Declaration (Loc,\n-                         Defining_Identifier => Make_Temporary (Loc, 'D'),\n-                         Subtype_Mark        => New_Occurrence_Of (Typ, Loc),\n-                         Name                =>\n-                           Unchecked_Convert_To (Typ,\n-                             Make_Selected_Component (Loc,\n-                               Prefix =>\n-                                 New_Occurrence_Of\n-                                   (Defining_Identifier (Decl_1), Loc),\n-                               Selector_Name =>\n-                                 New_Reference_To\n-                                   (Find_Interface_Tag (Expr_Typ, Iface),\n-                                    Loc))));\n-\n-                  --  General case:\n+                     Tag_Comp :=\n+                       Make_Selected_Component (Loc,\n+                         Prefix => New_Occurrence_Of (Obj_Id, Loc),\n+                         Selector_Name =>\n+                           New_Reference_To\n+                             (Find_Interface_Tag (Expr_Typ, Iface), Loc));\n \n                   --  Replace\n                   --     IW : I'Class := Obj;\n                   --  by\n                   --     type Equiv_Record is record ... end record;\n                   --     implicit subtype CW is <Class_Wide_Subtype>;\n-                  --     Temp : CW := CW!(Obj'Address);\n-                  --     IW : I'Class renames Displace (Temp, I'Tag);\n+                  --     Tmp : CW := CW!(Obj);\n+                  --     type Ityp is not null access I'Class;\n+                  --     IW : I'Class renames\n+                  --            Ityp!(Displace (Temp'Address, I'Tag)).all;\n \n                   else\n-                     --  Generate the equivalent record type\n+                     --  Generate the equivalent record type and update\n+                     --  the subtype indication to reference it\n \n                      Expand_Subtype_From_Expr\n                        (N             => N,\n                         Unc_Type      => Typ,\n                         Subtype_Indic => Object_Definition (N),\n-                        Exp           => Expression (N));\n+                        Exp           => Expr_N);\n+\n+                     if not Is_Interface (Etype (Expr_N)) then\n+                        New_Expr := Relocate_Node (Expr_N);\n+\n+                     --  For interface types we use 'Address which displaces\n+                     --  the pointer to the base of the object (if required)\n \n-                     if not Is_Interface (Etype (Expression (N))) then\n-                        New_Expr := Relocate_Node (Expression (N));\n                      else\n                         New_Expr :=\n-                          Make_Explicit_Dereference (Loc,\n-                            Unchecked_Convert_To (RTE (RE_Tag_Ptr),\n-                              Make_Attribute_Reference (Loc,\n-                                Prefix => Relocate_Node (Expression (N)),\n-                                Attribute_Name => Name_Address)));\n+                          Unchecked_Convert_To (Etype (Object_Definition (N)),\n+                            Make_Explicit_Dereference (Loc,\n+                              Unchecked_Convert_To (RTE (RE_Tag_Ptr),\n+                                Make_Attribute_Reference (Loc,\n+                                  Prefix => Relocate_Node (Expr_N),\n+                                  Attribute_Name => Name_Address))));\n                      end if;\n \n-                     Decl_1 :=\n+                     --  Copy the object\n+\n+                     Insert_Action (N,\n                        Make_Object_Declaration (Loc,\n-                         Defining_Identifier =>\n-                           Make_Temporary (Loc, 'D', New_Expr),\n-                         Object_Definition   =>\n+                         Defining_Identifier => Obj_Id,\n+                         Object_Definition =>\n                            New_Occurrence_Of\n-                            (Etype (Object_Definition (N)), Loc),\n-                         Expression          =>\n-                           Unchecked_Convert_To\n-                             (Etype (Object_Definition (N)), New_Expr));\n-\n-                     Decl_2 :=\n-                       Make_Object_Renaming_Declaration (Loc,\n-                         Defining_Identifier => Make_Temporary (Loc, 'D'),\n-                         Subtype_Mark        => New_Occurrence_Of (Typ, Loc),\n-                         Name                =>\n-                           Unchecked_Convert_To (Typ,\n-                             Make_Explicit_Dereference (Loc,\n-                               Unchecked_Convert_To (RTE (RE_Tag_Ptr),\n-                                 Make_Function_Call (Loc,\n-                                   Name =>\n-                                     New_Reference_To (RTE (RE_Displace), Loc),\n-                                   Parameter_Associations => New_List (\n-                                     Make_Attribute_Reference (Loc,\n-                                       Prefix =>\n-                                         New_Occurrence_Of\n-                                          (Defining_Identifier (Decl_1), Loc),\n-                                       Attribute_Name => Name_Address),\n-\n-                                     Unchecked_Convert_To (RTE (RE_Tag),\n-                                       New_Reference_To\n-                                         (Node\n-                                           (First_Elmt\n-                                             (Access_Disp_Table (Iface))),\n-                                          Loc))))))));\n+                             (Etype (Object_Definition (N)), Loc),\n+                         Expression => New_Expr));\n+\n+                     --  Dynamically reference the tag associated with the\n+                     --  interface\n+\n+                     Tag_Comp :=\n+                       Make_Function_Call (Loc,\n+                         Name => New_Reference_To (RTE (RE_Displace), Loc),\n+                         Parameter_Associations => New_List (\n+                           Make_Attribute_Reference (Loc,\n+                             Prefix => New_Occurrence_Of (Obj_Id, Loc),\n+                             Attribute_Name => Name_Address),\n+                           New_Reference_To\n+                             (Node (First_Elmt (Access_Disp_Table (Iface))),\n+                              Loc)));\n                   end if;\n \n-                  Insert_Action (N, Decl_1);\n-                  Rewrite (N, Decl_2);\n-                  Analyze (N);\n-\n-                  --  Replace internal identifier of Decl_2 by the identifier\n-                  --  found in the sources. We also have to exchange entities\n-                  --  containing their defining identifiers to ensure the\n-                  --  correct replacement of the object declaration by this\n-                  --  object renaming declaration (because such definings\n-                  --  identifier have been previously added by Enter_Name to\n-                  --  the current scope). We must preserve the homonym chain\n-                  --  of the source entity as well.\n+                  Rewrite (N,\n+                    Make_Object_Renaming_Declaration (Loc,\n+                      Defining_Identifier => Make_Temporary (Loc, 'D'),\n+                      Subtype_Mark => New_Occurrence_Of (Typ, Loc),\n+                      Name => Convert_Tag_To_Interface (Typ, Tag_Comp)));\n+\n+                  Analyze (N, Suppress => All_Checks);\n+\n+                  --  Replace internal identifier of rewriten node by the\n+                  --  identifier found in the sources. We also have to exchange\n+                  --  entities containing their defining identifiers to ensure\n+                  --  the correct replacement of the object declaration by this\n+                  --  object renaming declaration ---because these identifiers\n+                  --  were previously added by Enter_Name to the current scope.\n+                  --  We must preserve the homonym chain of the source entity\n+                  --  as well.\n \n                   Set_Chars (Defining_Identifier (N), Chars (Def_Id));\n                   Set_Homonym (Defining_Identifier (N), Homonym (Def_Id));"}, {"sha": "ec5bb320c32a14262534ce29af1c95f1e7549633", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bed8af19ec83d0e51a37a55faf1a87979a85a9b9/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bed8af19ec83d0e51a37a55faf1a87979a85a9b9/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=bed8af19ec83d0e51a37a55faf1a87979a85a9b9", "patch": "@@ -255,7 +255,7 @@ package body Exp_Ch4 is\n                       Prefix         => Name (N),\n                       Attribute_Name => Name_Address);\n \n-      Arg1      : constant Node_Id := Op1;\n+      Arg1      : Node_Id := Op1;\n       Arg2      : Node_Id := Op2;\n       Call_Node : Node_Id;\n       Proc_Name : Entity_Id;\n@@ -321,6 +321,8 @@ package body Exp_Ch4 is\n          --   X       xor (not Y)  =  not (X xor Y)  =  Nxor (X, Y)\n \n          if Nkind (Op1) = N_Op_Not then\n+            Arg1 := Right_Opnd (Op1);\n+            Arg2 := Right_Opnd (Op2);\n             if Kind = N_Op_And then\n                Proc_Name := RTE (RE_Vector_Nor);\n             elsif Kind = N_Op_Or then\n@@ -7032,6 +7034,9 @@ package body Exp_Ch4 is\n                if N = Op1 and then Nkind (Op2) = N_Op_Not then\n                   return;\n \n+               elsif N = Op2 and then Nkind (Op1) = N_Op_Not then\n+                  return;\n+\n                --  A xor (not B) can also be special-cased\n \n                elsif N = Op2 and then Nkind (Parent (N)) = N_Op_Xor then"}, {"sha": "9f7e6c7abf14c749d54c678a93be516da6328aac", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bed8af19ec83d0e51a37a55faf1a87979a85a9b9/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bed8af19ec83d0e51a37a55faf1a87979a85a9b9/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=bed8af19ec83d0e51a37a55faf1a87979a85a9b9", "patch": "@@ -1976,14 +1976,29 @@ package body Exp_Ch5 is\n                          Reason => CE_Tag_Check_Failed));\n                   end if;\n \n-                  Append_To (L,\n-                    Make_Procedure_Call_Statement (Loc,\n-                      Name => New_Reference_To (Op, Loc),\n-                      Parameter_Associations => New_List (\n-                        Unchecked_Convert_To (F_Typ,\n-                          Duplicate_Subexpr (Lhs)),\n-                        Unchecked_Convert_To (F_Typ,\n-                          Duplicate_Subexpr (Rhs)))));\n+                  declare\n+                     Left_N  : Node_Id := Duplicate_Subexpr (Lhs);\n+                     Right_N : Node_Id := Duplicate_Subexpr (Rhs);\n+\n+                  begin\n+                     --  In order to dispatch the call to _assign the type of\n+                     --  the actuals must match. Add conversion (if required).\n+\n+                     if Etype (Lhs) /= F_Typ then\n+                        Left_N := Unchecked_Convert_To (F_Typ, Left_N);\n+                     end if;\n+\n+                     if Etype (Rhs) /= F_Typ then\n+                        Right_N := Unchecked_Convert_To (F_Typ, Right_N);\n+                     end if;\n+\n+                     Append_To (L,\n+                       Make_Procedure_Call_Statement (Loc,\n+                         Name => New_Reference_To (Op, Loc),\n+                         Parameter_Associations => New_List (\n+                           Node1 => Left_N,\n+                           Node2 => Right_N)));\n+                  end;\n                end;\n \n             else"}, {"sha": "392fa7c2ebae40eee191aac2071881658933c81b", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 63, "deletions": 4, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bed8af19ec83d0e51a37a55faf1a87979a85a9b9/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bed8af19ec83d0e51a37a55faf1a87979a85a9b9/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=bed8af19ec83d0e51a37a55faf1a87979a85a9b9", "patch": "@@ -464,6 +464,57 @@ package body Exp_Disp is\n       end if;\n    end Build_Static_Dispatch_Tables;\n \n+   ------------------------------\n+   -- Convert_Tag_To_Interface --\n+   ------------------------------\n+\n+   function Convert_Tag_To_Interface\n+     (Typ  : Entity_Id;\n+      Expr : Node_Id) return Node_Id\n+   is\n+      Loc       : constant Source_Ptr := Sloc (Expr);\n+      Anon_Type : Entity_Id;\n+      Result    : Node_Id;\n+\n+   begin\n+      pragma Assert (Is_Class_Wide_Type (Typ)\n+        and then Is_Interface (Typ)\n+        and then\n+          ((Nkind (Expr) = N_Selected_Component\n+              and then Is_Tag (Entity (Selector_Name (Expr))))\n+           or else\n+           (Nkind (Expr) = N_Function_Call\n+              and then RTE_Available (RE_Displace)\n+              and then Entity (Name (Expr)) = RTE (RE_Displace))));\n+\n+      Anon_Type := Create_Itype (E_Anonymous_Access_Type, Expr);\n+      Set_Directly_Designated_Type (Anon_Type, Typ);\n+      Set_Etype (Anon_Type, Anon_Type);\n+      Set_Can_Never_Be_Null (Anon_Type);\n+\n+      --  Decorate the size and alignment attributes of the anonymous access\n+      --  type, as required by gigi.\n+\n+      Layout_Type (Anon_Type);\n+\n+      if Nkind (Expr) = N_Selected_Component\n+        and then Is_Tag (Entity (Selector_Name (Expr)))\n+      then\n+         Result :=\n+           Make_Explicit_Dereference (Loc,\n+             Unchecked_Convert_To (Anon_Type,\n+               Make_Attribute_Reference (Loc,\n+                 Prefix         => Expr,\n+                 Attribute_Name => Name_Address)));\n+      else\n+         Result :=\n+           Make_Explicit_Dereference (Loc,\n+             Unchecked_Convert_To (Anon_Type, Expr));\n+      end if;\n+\n+      return Result;\n+   end Convert_Tag_To_Interface;\n+\n    -------------------\n    -- CPP_Num_Prims --\n    -------------------\n@@ -1152,15 +1203,18 @@ package body Exp_Disp is\n       pragma Assert (Iface_Tag /= Empty);\n \n       --  Keep separate access types to interfaces because one internal\n-      --  function is used to handle the null value (see following comment)\n+      --  function is used to handle the null value (see following comments)\n \n       if not Is_Access_Type (Etype (N)) then\n+\n+         --  Statically displace the pointer to the object to reference\n+         --  the component containing the secondary dispatch table.\n+\n          Rewrite (N,\n-           Unchecked_Convert_To (Etype (N),\n+           Convert_Tag_To_Interface (Class_Wide_Type (Iface_Typ),\n              Make_Selected_Component (Loc,\n                Prefix => Relocate_Node (Expression (N)),\n-               Selector_Name =>\n-                 New_Occurrence_Of (Iface_Tag, Loc))));\n+               Selector_Name => New_Occurrence_Of (Iface_Tag, Loc))));\n \n       else\n          --  Build internal function to handle the case in which the\n@@ -7976,6 +8030,11 @@ package body Exp_Disp is\n \n             if Present (Interface_Alias (Prim)) then\n                Write_Str  (\", AI_Alias of \");\n+\n+               if Is_Null_Interface_Primitive (Interface_Alias (Prim)) then\n+                  Write_Str (\"null primitive \");\n+               end if;\n+\n                Write_Name\n                  (Chars (Find_Dispatching_Type (Interface_Alias (Prim))));\n                Write_Char (':');"}, {"sha": "823693ba4925e703794c0086022bbd2fe1155ac0", "filename": "gcc/ada/exp_disp.ads", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bed8af19ec83d0e51a37a55faf1a87979a85a9b9/gcc%2Fada%2Fexp_disp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bed8af19ec83d0e51a37a55faf1a87979a85a9b9/gcc%2Fada%2Fexp_disp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.ads?ref=bed8af19ec83d0e51a37a55faf1a87979a85a9b9", "patch": "@@ -186,6 +186,33 @@ package Exp_Disp is\n    --  bodies they are added to the end of the list of declarations of the\n    --  package body.\n \n+   function Convert_Tag_To_Interface\n+     (Typ : Entity_Id; Expr : Node_Id) return Node_Id;\n+   pragma Inline (Convert_Tag_To_Interface);\n+   --  This function is used in class-wide interface conversions; the expanded\n+   --  code generated to convert a tagged object to a class-wide interface type\n+   --  involves referencing the tag component containing the secondary dispatch\n+   --  table associated with the interface. Given the expression Expr that\n+   --  references a tag component, we cannot generate an unchecked conversion\n+   --  to leave the expression decorated with the class-wide interface type Typ\n+   --  because an unchecked conversion cannot be seen as a no-op. An unchecked\n+   --  conversion is conceptually a function call and therefore the RM allows\n+   --  the backend to obtain a copy of the value of the actual object and store\n+   --  it in some other place (like a register); in such case the interface\n+   --  conversion is not equivalent to a displacement of the pointer to the\n+   --  interface and any further displacement fails. Although the functionality\n+   --  of this function is simple and could be done directly, the purpose of\n+   --  this routine is to leave well documented in the sources these\n+   --  occurrences.\n+\n+   --  If Expr is an N_Selected_Component that references a tag generate:\n+   --     type ityp is non null access Typ;\n+   --     ityp!(Expr'Address).all\n+\n+   --  if Expr is an N_Function_Call to Ada.Tags.Displace then generate:\n+   --     type ityp is non null access Typ;\n+   --     ityp!(Expr).all\n+\n    function CPP_Num_Prims (Typ : Entity_Id) return Nat;\n    --  Return the number of primitives of the C++ part of the dispatch table.\n    --  For types that are not derivations of CPP types return 0."}, {"sha": "1df76a514534bfd3d49c852930a092f7925994fc", "filename": "gcc/ada/make.adb", "status": "modified", "additions": 31, "deletions": 19, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bed8af19ec83d0e51a37a55faf1a87979a85a9b9/gcc%2Fada%2Fmake.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bed8af19ec83d0e51a37a55faf1a87979a85a9b9/gcc%2Fada%2Fmake.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmake.adb?ref=bed8af19ec83d0e51a37a55faf1a87979a85a9b9", "patch": "@@ -4468,29 +4468,41 @@ package body Make is\n                      --  language, all the Ada mains.\n \n                      while Value /= Prj.Nil_String loop\n-                        Get_Name_String\n-                          (Project_Tree.String_Elements.Table (Value).Value);\n-\n                         --  To know if a main is an Ada main, get its project.\n                         --  It should be the project specified on the command\n                         --  line.\n \n-                        if (not Foreign_Language) or else\n-                            Prj.Env.Project_Of\n-                              (Name_Buffer (1 .. Name_Len),\n-                               Main_Project,\n-                               Project_Tree) =\n-                             Main_Project\n-                        then\n-                           At_Least_One_Main := True;\n-                           Osint.Add_File\n-                             (Get_Name_String\n-                                (Project_Tree.String_Elements.Table\n-                                   (Value).Value),\n-                              Index =>\n-                                Project_Tree.String_Elements.Table\n-                                  (Value).Index);\n-                        end if;\n+                        Get_Name_String\n+                          (Project_Tree.String_Elements.Table (Value).Value);\n+\n+                        declare\n+                           Main_Name : constant String :=\n+                              Get_Name_String\n+                               (Project_Tree.String_Elements.Table\n+                                    (Value).Value);\n+                           Proj : constant Project_Id :=\n+                             Prj.Env.Project_Of\n+                              (Main_Name, Main_Project, Project_Tree);\n+                        begin\n+\n+                           if Proj = Main_Project then\n+\n+                              At_Least_One_Main := True;\n+                              Osint.Add_File\n+                                (Get_Name_String\n+                                   (Project_Tree.String_Elements.Table\n+                                      (Value).Value),\n+                                 Index =>\n+                                   Project_Tree.String_Elements.Table\n+                                     (Value).Index);\n+\n+                           elsif not Foreign_Language then\n+                              Make_Failed\n+                                (\"\"\"\" & Main_Name &\n+                                 \"\"\" is not a source of project \" &\n+                                 Get_Name_String (Main_Project.Display_Name));\n+                           end if;\n+                        end;\n \n                         Value := Project_Tree.String_Elements.Table\n                                    (Value).Next;"}, {"sha": "c73e7e36b8a8a080fef45767ba461108e3087903", "filename": "gcc/ada/sprint.adb", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bed8af19ec83d0e51a37a55faf1a87979a85a9b9/gcc%2Fada%2Fsprint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bed8af19ec83d0e51a37a55faf1a87979a85a9b9/gcc%2Fada%2Fsprint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsprint.adb?ref=bed8af19ec83d0e51a37a55faf1a87979a85a9b9", "patch": "@@ -3760,12 +3760,15 @@ package body Sprint is\n \n                   when Access_Kind =>\n                      Write_Header (Ekind (Typ) = E_Access_Type);\n+\n+                     if Can_Never_Be_Null (Typ) then\n+                        Write_Str (\"not null \");\n+                     end if;\n+\n                      Write_Str (\"access \");\n \n                      if Is_Access_Constant (Typ) then\n                         Write_Str (\"constant \");\n-                     elsif Can_Never_Be_Null (Typ) then\n-                        Write_Str (\"not null \");\n                      end if;\n \n                      Write_Id (Directly_Designated_Type (Typ));"}]}