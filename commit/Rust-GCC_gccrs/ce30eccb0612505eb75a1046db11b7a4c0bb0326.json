{"sha": "ce30eccb0612505eb75a1046db11b7a4c0bb0326", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2UzMGVjY2IwNjEyNTA1ZWI3NWExMDQ2ZGIxMWI3YTRjMGJiMDMyNg==", "commit": {"author": {"name": "Emmanuel Briot", "email": "briot@adacore.com", "date": "2009-04-22T11:01:03Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-22T11:01:03Z"}, "message": "prj-proc.adb, [...] (Check_Naming_Schemes): split into several smaller subprograms.\n\n2009-04-22  Emmanuel Briot  <briot@adacore.com>\n\n\t* prj-proc.adb, prj-nmsc.adb (Check_Naming_Schemes): split into several\n\tsmaller subprograms.\n\tRenamed to Check_File_Naming_Schemes to avoid confusion with the\n\tother Check_Naming_Schemes functions that plays a totally different\n\trole.\n\t(Check_Unit_Based_Lang, Check_File_Based_Lang): new subprograms,\n\textracted from the above. These were partially rewritten to avoid\n\tunnecessary code and temporary variables.\n\t(Compute_Unit_Name): new subprogram, merge of Check_Unit_Based_Lang\n\tand Get_Unit (which for now still exist since they contain mode-specific\n\tcode)\n\nFrom-SVN: r146568", "tree": {"sha": "fb2480c83ad958e237c1b4d33703df690b04c8ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fb2480c83ad958e237c1b4d33703df690b04c8ac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ce30eccb0612505eb75a1046db11b7a4c0bb0326", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce30eccb0612505eb75a1046db11b7a4c0bb0326", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce30eccb0612505eb75a1046db11b7a4c0bb0326", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce30eccb0612505eb75a1046db11b7a4c0bb0326/comments", "author": {"login": "briot", "id": 42402, "node_id": "MDQ6VXNlcjQyNDAy", "avatar_url": "https://avatars.githubusercontent.com/u/42402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/briot", "html_url": "https://github.com/briot", "followers_url": "https://api.github.com/users/briot/followers", "following_url": "https://api.github.com/users/briot/following{/other_user}", "gists_url": "https://api.github.com/users/briot/gists{/gist_id}", "starred_url": "https://api.github.com/users/briot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/briot/subscriptions", "organizations_url": "https://api.github.com/users/briot/orgs", "repos_url": "https://api.github.com/users/briot/repos", "events_url": "https://api.github.com/users/briot/events{/privacy}", "received_events_url": "https://api.github.com/users/briot/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "347ab254f812eec432aede015990dd5af799ba93", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/347ab254f812eec432aede015990dd5af799ba93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/347ab254f812eec432aede015990dd5af799ba93"}], "stats": {"total": 1128, "additions": 472, "deletions": 656}, "files": [{"sha": "ea7112f020590ae6b24e5c947bbbf27b23c9a2a5", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce30eccb0612505eb75a1046db11b7a4c0bb0326/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce30eccb0612505eb75a1046db11b7a4c0bb0326/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=ce30eccb0612505eb75a1046db11b7a4c0bb0326", "patch": "@@ -1,3 +1,17 @@\n+2009-04-22  Emmanuel Briot  <briot@adacore.com>\n+\n+\t* prj-proc.adb, prj-nmsc.adb (Check_Naming_Schemes): split into several\n+\tsmaller subprograms.\n+\tRenamed to Check_File_Naming_Schemes to avoid confusion with the\n+\tother Check_Naming_Schemes functions that plays a totally different\n+\trole.\n+\t(Check_Unit_Based_Lang, Check_File_Based_Lang): new subprograms,\n+\textracted from the above. These were partially rewritten to avoid\n+\tunnecessary code and temporary variables.\n+\t(Compute_Unit_Name): new subprogram, merge of Check_Unit_Based_Lang\n+\tand Get_Unit (which for now still exist since they contain mode-specific\n+\tcode)\n+\n 2009-04-22  Emmanuel Briot  <briot@adacore.com>\n \n \t* prj.ads, prj.adb, prj-nmsc.adb, prj-proc.adb (Recursive_Process):"}, {"sha": "b274042304a9f0043694a37d6228687e8aaec61c", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 454, "deletions": 656, "changes": 1110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce30eccb0612505eb75a1046db11b7a4c0bb0326/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce30eccb0612505eb75a1046db11b7a4c0bb0326/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=ce30eccb0612505eb75a1046db11b7a4c0bb0326", "patch": "@@ -216,9 +216,9 @@ package body Prj.Nmsc is\n    --  with a file name following the naming convention.\n \n    procedure Load_Naming_Exceptions\n-     (Project     : Project_Id;\n-      In_Tree     : Project_Tree_Ref;\n-      Data        : in out Project_Data);\n+     (Project : Project_Id;\n+      In_Tree : Project_Tree_Ref;\n+      Data    : in out Project_Data);\n    --  All source files in Data.First_Source are considered as naming\n    --  exceptions, and copied into the Source_Names and Unit_Exceptions tables\n    --  as appropriate.\n@@ -254,6 +254,16 @@ package body Prj.Nmsc is\n    --  Same as Osint.Canonical_Case_File_Name but applies to Name_Id.\n    --  This alters Name_Buffer\n \n+   function Suffix_Matches\n+     (Filename : String; Suffix : File_Name_Type) return Boolean;\n+   --  True if the filename ends with the given suffix. It always returns False\n+   --  if Suffix is No_Name\n+\n+   procedure Replace_Into_Name_Buffer\n+     (Str : String; Pattern : String; Replacement : Character);\n+   --  Copy Str into Name_Buffer, replacing Pattern with Replacement.\n+   --  Str is converted to lower-case at the same time\n+\n    function ALI_File_Name (Source : String) return String;\n    --  Return the ALI file name corresponding to a source\n \n@@ -354,6 +364,13 @@ package body Prj.Nmsc is\n    --  Find the path names of the source files in the Source_Names table\n    --  in the source directories and record those that are Ada sources.\n \n+   function Get_Language_Processing_From_Lang\n+     (In_Tree : Project_Tree_Ref;\n+      Data    : Project_Data;\n+      Lang    : Name_List_Index) return Language_Index;\n+   --  Return the language_processing description associated for the given\n+   --  language.\n+\n    function Compute_Directory_Last (Dir : String) return Natural;\n    --  Return the index of the last significant character in Dir. This is used\n    --  to avoid duplicate '/' (slash) characters at the end of directory names.\n@@ -414,7 +431,7 @@ package body Prj.Nmsc is\n    --  If For_All_Sources is True, then all possible file names are analyzed\n    --  otherwise only those currently set in the Source_Names htable.\n \n-   procedure Check_Naming_Schemes\n+   procedure Check_File_Naming_Schemes\n      (In_Tree               : Project_Tree_Ref;\n       Data                  : in out Project_Data;\n       Filename              : String;\n@@ -475,6 +492,19 @@ package body Prj.Nmsc is\n    --  Lang indicates which language is being processed when in Ada_Only mode\n    --  (all languages are processed anyway when in Multi_Language mode).\n \n+   procedure Compute_Unit_Name\n+     (Filename        : String;\n+      Dot_Replacement : File_Name_Type;\n+      Separate_Suffix : File_Name_Type;\n+      Body_Suffix     : File_Name_Type;\n+      Spec_Suffix     : File_Name_Type;\n+      Casing          : Casing_Type;\n+      Kind            : out Source_Kind;\n+      Unit            : out Name_Id);\n+   --  Check whether the file matches the naming scheme. If it does,\n+   --  compute its unit name. If Unit is set to No_Name on exit, none of the\n+   --  other out parameters are relevant.\n+\n    procedure Get_Unit\n      (In_Tree             : Project_Tree_Ref;\n       Canonical_File_Name : File_Name_Type;\n@@ -593,6 +623,54 @@ package body Prj.Nmsc is\n    --  Debug print a value for a specific property. Does nothing when not in\n    --  debug mode\n \n+   ------------------------------\n+   -- Replace_Into_Name_Buffer --\n+   ------------------------------\n+\n+   procedure Replace_Into_Name_Buffer\n+     (Str : String; Pattern : String; Replacement : Character)\n+   is\n+      Max : constant Integer := Str'Last - Pattern'Length + 1;\n+      J : Positive := Str'First;\n+   begin\n+      Name_Len := 0;\n+\n+      while J <= Str'Last loop\n+         Name_Len := Name_Len + 1;\n+\n+         if J <= Max\n+           and then Str (J .. J + Pattern'Length - 1) = Pattern\n+         then\n+            Name_Buffer (Name_Len) := Replacement;\n+            J := J + Pattern'Length;\n+\n+         else\n+            Name_Buffer (Name_Len) := GNAT.Case_Util.To_Lower (Str (J));\n+            J := J + 1;\n+         end if;\n+      end loop;\n+   end Replace_Into_Name_Buffer;\n+\n+   --------------------\n+   -- Suffix_Matches --\n+   --------------------\n+\n+   function Suffix_Matches\n+     (Filename : String; Suffix : File_Name_Type) return Boolean is\n+   begin\n+      if Suffix = No_File then\n+         return False;\n+      end if;\n+\n+      declare\n+         Suf : constant String := Get_Name_String (Suffix);\n+      begin\n+         return Filename'Length > Suf'Length\n+           and then Filename\n+             (Filename'Last - Suf'Length + 1 .. Filename'Last) = Suf;\n+      end;\n+   end Suffix_Matches;\n+\n    ----------------\n    -- Write_Attr --\n    ----------------\n@@ -2833,7 +2911,7 @@ package body Prj.Nmsc is\n       --  this package.\n \n       procedure Check_Naming_Multi_Lang;\n-      --  Does Check_Naming_Schemes processing for Multi_Language mode.\n+      --  Does Check_Naming_Schemes processing for Multi_Language mode\n \n       procedure Check_Common\n         (Dot_Replacement : in out File_Name_Type;\n@@ -6574,319 +6652,242 @@ package body Prj.Nmsc is\n       end if;\n    end Get_Sources_From_File;\n \n-   --------------\n-   -- Get_Unit --\n-   --------------\n+   -----------------------\n+   -- Compute_Unit_Name --\n+   -----------------------\n \n-   procedure Get_Unit\n-     (In_Tree             : Project_Tree_Ref;\n-      Canonical_File_Name : File_Name_Type;\n-      Naming              : Naming_Data;\n-      Exception_Id        : out Ada_Naming_Exception_Id;\n-      Unit_Name           : out Name_Id;\n-      Unit_Kind           : out Spec_Or_Body;\n-      Needs_Pragma        : out Boolean)\n+   procedure Compute_Unit_Name\n+     (Filename        : String;\n+      Dot_Replacement : File_Name_Type;\n+      Separate_Suffix : File_Name_Type;\n+      Body_Suffix     : File_Name_Type;\n+      Spec_Suffix     : File_Name_Type;\n+      Casing          : Casing_Type;\n+      Kind            : out Source_Kind;\n+      Unit            : out Name_Id)\n    is\n-      Info_Id  : Ada_Naming_Exception_Id :=\n-                   Ada_Naming_Exceptions.Get (Canonical_File_Name);\n-      VMS_Name : File_Name_Type;\n-\n+      Last : Integer := Filename'Last;\n+      Sep_Len : constant Integer := Integer (Length_Of_Name (Separate_Suffix));\n+      Body_Len : constant Integer := Integer (Length_Of_Name (Body_Suffix));\n+      Spec_Len : constant Integer := Integer (Length_Of_Name (Spec_Suffix));\n+      Standard_GNAT : constant Boolean := Spec_Suffix = Default_Ada_Spec_Suffix\n+        and then Body_Suffix = Default_Ada_Body_Suffix;\n    begin\n-      if Info_Id = No_Ada_Naming_Exception then\n-         if Hostparm.OpenVMS then\n-            VMS_Name := Canonical_File_Name;\n-            Get_Name_String (VMS_Name);\n+      Unit := No_Name;\n+      Kind := Spec;\n \n-            if Name_Buffer (Name_Len) = '.' then\n-               Name_Len := Name_Len - 1;\n-               VMS_Name := Name_Find;\n-            end if;\n-\n-            Info_Id := Ada_Naming_Exceptions.Get (VMS_Name);\n+      if Dot_Replacement = No_File then\n+         if Current_Verbosity = High then\n+            Write_Line (\"  No dot_replacement specified\");\n          end if;\n-\n-      end if;\n-\n-      if Info_Id /= No_Ada_Naming_Exception then\n-         Exception_Id := Info_Id;\n-         Unit_Name := No_Name;\n-         Unit_Kind := Specification;\n-         Needs_Pragma := True;\n          return;\n       end if;\n \n-      Needs_Pragma := False;\n-      Exception_Id := No_Ada_Naming_Exception;\n-\n-      Get_Name_String (Canonical_File_Name);\n-\n-      --  How about some comments and a name for this declare block ???\n-      --  In fact the whole code below needs more comments ???\n+      --  Choose the longest suffix that matches. If there are several matches,\n+      --  give priority to specs, then bodies, then separates.\n \n-      declare\n-         File          : String := Name_Buffer (1 .. Name_Len);\n-         First         : constant Positive := File'First;\n-         Last          : Natural           := File'Last;\n-         Standard_GNAT : Boolean;\n-         Spec          : constant File_Name_Type :=\n-                           Spec_Suffix_Id_Of (In_Tree, Name_Ada, Naming);\n-         Body_Suff     : constant File_Name_Type :=\n-                           Body_Suffix_Id_Of (In_Tree, Name_Ada, Naming);\n+      if Separate_Suffix /= Body_Suffix\n+        and then Suffix_Matches (Filename, Separate_Suffix)\n+      then\n+         Last := Filename'Last - Sep_Len;\n+         Kind := Sep;\n+      end if;\n \n-      begin\n-         Standard_GNAT := Spec = Default_Ada_Spec_Suffix\n-            and then Body_Suff = Default_Ada_Body_Suffix;\n+      if Filename'Last - Body_Len <= Last\n+        and then Suffix_Matches (Filename, Body_Suffix)\n+      then\n+         Last := Natural'Min (Last, Filename'Last - Body_Len);\n+         Kind := Impl;\n+      end if;\n \n-         declare\n-            Spec_Suffix : constant String := Get_Name_String (Spec);\n-            Body_Suffix : constant String := Get_Name_String (Body_Suff);\n-            Sep_Suffix  : constant String :=\n-                            Get_Name_String (Naming.Separate_Suffix);\n+      if Filename'Last - Spec_Len <= Last\n+        and then Suffix_Matches (Filename, Spec_Suffix)\n+      then\n+         Last := Natural'Min (Last, Filename'Last - Spec_Len);\n+         Kind := Spec;\n+      end if;\n \n-            May_Be_Spec : Boolean;\n-            May_Be_Body : Boolean;\n-            May_Be_Sep  : Boolean;\n+      if Last = Filename'Last then\n+         if Current_Verbosity = High then\n+            Write_Line (\"  No matching suffix\");\n+         end if;\n+         return;\n+      end if;\n \n-         begin\n-            May_Be_Spec :=\n-              File'Length > Spec_Suffix'Length\n-              and then\n-              File (Last - Spec_Suffix'Length + 1 .. Last) = Spec_Suffix;\n-\n-            May_Be_Body :=\n-              File'Length > Body_Suffix'Length\n-              and then\n-              File (Last - Body_Suffix'Length + 1 .. Last) = Body_Suffix;\n-\n-            May_Be_Sep :=\n-              File'Length > Sep_Suffix'Length\n-              and then\n-              File (Last - Sep_Suffix'Length + 1 .. Last) = Sep_Suffix;\n-\n-            --  If two May_Be_ booleans are True, always choose the longer one\n-\n-            if May_Be_Spec then\n-               if May_Be_Body and then\n-                 Spec_Suffix'Length < Body_Suffix'Length\n-               then\n-                  Unit_Kind := Body_Part;\n+      --  Check that the casing matches\n \n-                  if May_Be_Sep and then\n-                    Body_Suffix'Length < Sep_Suffix'Length\n+      if File_Names_Case_Sensitive then\n+         case Casing is\n+            when All_Lower_Case =>\n+               for J in Filename'Range loop\n+                  if Is_Letter (Filename (J))\n+                    and then not Is_Lower (Filename (J))\n                   then\n-                     Last := Last - Sep_Suffix'Length;\n-                     May_Be_Body := False;\n-\n-                  else\n-                     Last := Last - Body_Suffix'Length;\n-                     May_Be_Sep := False;\n+                     if Current_Verbosity = High then\n+                        Write_Line (\"  Invalid casing\");\n+                     end if;\n+                     return;\n                   end if;\n+               end loop;\n \n-               elsif May_Be_Sep and then\n-                     Spec_Suffix'Length < Sep_Suffix'Length\n-               then\n-                  Unit_Kind := Body_Part;\n-                  Last := Last - Sep_Suffix'Length;\n-\n-               else\n-                  Unit_Kind := Specification;\n-                  Last := Last - Spec_Suffix'Length;\n-               end if;\n-\n-            elsif May_Be_Body then\n-               Unit_Kind := Body_Part;\n-\n-               if May_Be_Sep and then\n-                  Body_Suffix'Length < Sep_Suffix'Length\n-               then\n-                  Last := Last - Sep_Suffix'Length;\n-                  May_Be_Body := False;\n-               else\n-                  Last := Last - Body_Suffix'Length;\n-                  May_Be_Sep := False;\n-               end if;\n-\n-            elsif May_Be_Sep then\n-               Unit_Kind := Body_Part;\n-               Last := Last - Sep_Suffix'Length;\n-\n-            else\n-               Last := 0;\n-            end if;\n-\n-            if Last = 0 then\n-\n-               --  This is not a source file\n-\n-               Unit_Name := No_Name;\n-               Unit_Kind := Specification;\n-\n-               if Current_Verbosity = High then\n-                  Write_Line (\"   Not a valid file name.\");\n-               end if;\n-\n-               return;\n-\n-            elsif Current_Verbosity = High then\n-               case Unit_Kind is\n-               when Specification =>\n-                  Write_Str  (\"   Specification: \");\n-                  Write_Line (File (First .. Last + Spec_Suffix'Length));\n-\n-               when Body_Part =>\n-                  if May_Be_Body then\n-                     Write_Str  (\"   Body: \");\n-                     Write_Line (File (First .. Last + Body_Suffix'Length));\n-\n-                  else\n-                     Write_Str  (\"   Separate: \");\n-                     Write_Line (File (First .. Last + Sep_Suffix'Length));\n+            when All_Upper_Case =>\n+               for J in Filename'Range loop\n+                  if Is_Letter (Filename (J))\n+                    and then not Is_Upper (Filename (J))\n+                  then\n+                     if Current_Verbosity = High then\n+                        Write_Line (\"  Invalid casing\");\n+                     end if;\n+                     return;\n                   end if;\n-               end case;\n-            end if;\n-         end;\n-\n-         Get_Name_String (Naming.Dot_Replacement);\n-         Standard_GNAT :=\n-           Standard_GNAT and then Name_Buffer (1 .. Name_Len) = \"-\";\n+               end loop;\n \n-         if Name_Buffer (1 .. Name_Len) /= \".\" then\n+            when Mixed_Case | Unknown =>\n+               null;\n+         end case;\n+      end if;\n \n-            --  If Dot_Replacement is not a single dot, then there should not\n-            --  be any dot in the name.\n+      --  If Dot_Replacement is not a single dot, then there should not\n+      --  be any dot in the name.\n \n-            for Index in First .. Last loop\n-               if File (Index) = '.' then\n+      declare\n+         Dot_Repl : constant String := Get_Name_String (Dot_Replacement);\n+      begin\n+         if Dot_Repl /= \".\" then\n+            for Index in Filename'First .. Last loop\n+               if Filename (Index) = '.' then\n                   if Current_Verbosity = High then\n-                     Write_Line\n-                       (\"   Not a valid file name (some dot not replaced).\");\n+                     Write_Line (\"   Invalid name, contains dot\");\n                   end if;\n-\n-                  Unit_Name := No_Name;\n                   return;\n-\n                end if;\n             end loop;\n \n-            --  Replace the substring Dot_Replacement with dots\n-\n-            declare\n-               Index : Positive := First;\n-\n-            begin\n-               while Index <= Last - Name_Len + 1 loop\n-\n-                  if File (Index .. Index + Name_Len - 1) =\n-                    Name_Buffer (1 .. Name_Len)\n-                  then\n-                     File (Index) := '.';\n-\n-                     if Name_Len > 1 and then Index < Last then\n-                        File (Index + 1 .. Last - Name_Len + 1) :=\n-                          File (Index + Name_Len .. Last);\n-                     end if;\n-\n-                     Last := Last - Name_Len + 1;\n-                  end if;\n-\n-                  Index := Index + 1;\n-               end loop;\n-            end;\n+            Replace_Into_Name_Buffer\n+              (Filename (Filename'First .. Last), Dot_Repl, '.');\n+         else\n+            Name_Len := Last - Filename'First + 1;\n+            Name_Buffer (1 .. Name_Len) := Filename (Filename'First .. Last);\n+            Fixed.Translate\n+              (Source  => Name_Buffer (1 .. Name_Len),\n+               Mapping => Lower_Case_Map);\n          end if;\n+      end;\n \n-         --  Check if the file casing is right\n+      --  In the standard GNAT naming scheme, check for special cases: children\n+      --  or separates of A, G, I or S, and run time sources.\n \n+      if Standard_GNAT and then Name_Len >= 3 then\n          declare\n-            Src      : String := File (First .. Last);\n-            Src_Last : Positive := Last;\n+            S1 : constant Character := Name_Buffer (1);\n+            S2 : constant Character := Name_Buffer (2);\n+            S3 : constant Character := Name_Buffer (3);\n \n          begin\n-            --  If casing is significant, deal with upper/lower case translate\n-\n-            if File_Names_Case_Sensitive then\n-               case Naming.Casing is\n-                  when All_Lower_Case =>\n-                     Fixed.Translate\n-                       (Source  => Src,\n-                        Mapping => Lower_Case_Map);\n-\n-                  when All_Upper_Case =>\n-                     Fixed.Translate\n-                       (Source  => Src,\n-                        Mapping => Upper_Case_Map);\n-\n-                  when Mixed_Case | Unknown =>\n-                     null;\n-               end case;\n-\n-               if Src /= File (First .. Last) then\n-                  if Current_Verbosity = High then\n-                     Write_Line (\"   Not a valid file name (casing).\");\n-                  end if;\n-\n-                  Unit_Name := No_Name;\n-                  return;\n+            if S1 = 'a'\n+              or else S1 = 'g'\n+              or else S1 = 'i'\n+              or else S1 = 's'\n+            then\n+               --  Children or separates of packages A, G, I or S. These names\n+               --  are x__ ... or x~... (where x is a, g, i, or s). Both\n+               --  versions (x__... and x~...) are allowed in all platforms,\n+               --  because it is not possible to know the platform before\n+               --  processing of the project files.\n+\n+               if S2 = '_' and then S3 = '_' then\n+                  Name_Buffer (2) := '.';\n+                  Name_Buffer (3 .. Name_Len - 1) :=\n+                    Name_Buffer (4 .. Name_Len);\n+                  Name_Len := Name_Len - 1;\n+\n+               elsif S2 = '~' then\n+                  Name_Buffer (2) := '.';\n+\n+               elsif S2 = '.' then\n+                  --  If it is potentially a run time source, disable\n+                  --  filling of the mapping file to avoid warnings.\n+                  Set_Mapping_File_Initial_State_To_Empty;\n                end if;\n             end if;\n+         end;\n+      end if;\n \n-            --  Put the name in lower case\n+      --  Name_Buffer contains the name of the the unit in lower-cases. Check\n+      --  that this is a valid unit name\n \n-            Fixed.Translate\n-              (Source  => Src,\n-               Mapping => Lower_Case_Map);\n+      Check_Ada_Name (Name_Buffer (1 .. Name_Len), Unit);\n \n-            --  In the standard GNAT naming scheme, check for special cases:\n-            --  children or separates of A, G, I or S, and run time sources.\n+      if Unit /= No_Name\n+        and then Current_Verbosity = High\n+      then\n+         case Kind is\n+            when Spec => Write_Str (\"     spec of \");\n+            when Impl => Write_Str (\"     body of \");\n+            when Sep  => Write_Str (\"     sep of \");\n+         end case;\n \n-            if Standard_GNAT and then Src'Length >= 3 then\n-               declare\n-                  S1 : constant Character := Src (Src'First);\n-                  S2 : constant Character := Src (Src'First + 1);\n-                  S3 : constant Character := Src (Src'First + 2);\n+         Write_Line (Get_Name_String (Unit));\n+      end if;\n+   end Compute_Unit_Name;\n \n-               begin\n-                  if S1 = 'a' or else\n-                     S1 = 'g' or else\n-                     S1 = 'i' or else\n-                     S1 = 's'\n-                  then\n-                     --  Children or separates of packages A, G, I or S. These\n-                     --  names are x__ ... or x~... (where x is a, g, i, or s).\n-                     --  Both versions (x__... and x~...) are allowed in all\n-                     --  platforms, because it is not possible to know the\n-                     --  platform before processing of the project files.\n-\n-                     if S2 = '_' and then S3 = '_' then\n-                        Src (Src'First + 1) := '.';\n-                        Src_Last := Src_Last - 1;\n-                        Src (Src'First + 2 .. Src_Last) :=\n-                          Src (Src'First + 3 .. Src_Last + 1);\n-\n-                     elsif S2 = '~' then\n-                        Src (Src'First + 1) := '.';\n-\n-                     --  If it is potentially a run time source, disable\n-                     --  filling of the mapping file to avoid warnings.\n-\n-                     elsif S2 = '.' then\n-                        Set_Mapping_File_Initial_State_To_Empty;\n-                     end if;\n-                  end if;\n-               end;\n-            end if;\n+   --------------\n+   -- Get_Unit --\n+   --------------\n \n-            if Current_Verbosity = High then\n-               Write_Str  (\"      \");\n-               Write_Line (Src (Src'First .. Src_Last));\n+   procedure Get_Unit\n+     (In_Tree             : Project_Tree_Ref;\n+      Canonical_File_Name : File_Name_Type;\n+      Naming              : Naming_Data;\n+      Exception_Id        : out Ada_Naming_Exception_Id;\n+      Unit_Name           : out Name_Id;\n+      Unit_Kind           : out Spec_Or_Body;\n+      Needs_Pragma        : out Boolean)\n+   is\n+      Info_Id  : Ada_Naming_Exception_Id :=\n+                   Ada_Naming_Exceptions.Get (Canonical_File_Name);\n+      VMS_Name : File_Name_Type;\n+      Kind     : Source_Kind;\n+\n+   begin\n+      if Info_Id = No_Ada_Naming_Exception then\n+         if Hostparm.OpenVMS then\n+            VMS_Name := Canonical_File_Name;\n+            Get_Name_String (VMS_Name);\n+\n+            if Name_Buffer (Name_Len) = '.' then\n+               Name_Len := Name_Len - 1;\n+               VMS_Name := Name_Find;\n             end if;\n \n-            --  Now, we check if this name is a valid unit name\n+            Info_Id := Ada_Naming_Exceptions.Get (VMS_Name);\n+         end if;\n \n-            Check_Ada_Name\n-              (Name => Src (Src'First .. Src_Last), Unit => Unit_Name);\n-         end;\n+      end if;\n \n-      end;\n+      if Info_Id /= No_Ada_Naming_Exception then\n+         Exception_Id := Info_Id;\n+         Unit_Name := No_Name;\n+         Unit_Kind := Specification;\n+         Needs_Pragma := True;\n+      else\n+         Needs_Pragma := False;\n+         Exception_Id := No_Ada_Naming_Exception;\n+         Compute_Unit_Name\n+           (Filename       => Get_Name_String (Canonical_File_Name),\n+            Dot_Replacement => Naming.Dot_Replacement,\n+            Separate_Suffix => Naming.Separate_Suffix,\n+            Body_Suffix     => Body_Suffix_Id_Of (In_Tree, Name_Ada, Naming),\n+            Spec_Suffix     => Spec_Suffix_Id_Of (In_Tree, Name_Ada, Naming),\n+            Casing          => Naming.Casing,\n+            Kind            => Kind,\n+            Unit            => Unit_Name);\n+\n+         case Kind is\n+            when Spec       => Unit_Kind := Specification;\n+            when Impl | Sep => Unit_Kind := Body_Part;\n+         end case;\n+      end if;\n    end Get_Unit;\n \n    ----------\n@@ -7620,11 +7621,33 @@ package body Prj.Nmsc is\n       end loop;\n    end Get_Path_Names_And_Record_Ada_Sources;\n \n-   --------------------------\n-   -- Check_Naming_Schemes --\n-   --------------------------\n+   ---------------------------------------\n+   -- Get_Language_Processing_From_Lang --\n+   ---------------------------------------\n \n-   procedure Check_Naming_Schemes\n+   function Get_Language_Processing_From_Lang\n+     (In_Tree : Project_Tree_Ref;\n+      Data    : Project_Data;\n+      Lang    : Name_List_Index) return Language_Index\n+   is\n+      Name     : constant Name_Id := In_Tree.Name_Lists.Table (Lang).Name;\n+      Language : Language_Index := Data.First_Language_Processing;\n+   begin\n+      while Language /= No_Language_Index loop\n+         if In_Tree.Languages_Data.Table (Language).Name = Name then\n+            return Language;\n+         end if;\n+\n+         Language := In_Tree.Languages_Data.Table (Language).Next;\n+      end loop;\n+      return No_Language_Index;\n+   end Get_Language_Processing_From_Lang;\n+\n+   -------------------------------\n+   -- Check_File_Naming_Schemes --\n+   -------------------------------\n+\n+   procedure Check_File_Naming_Schemes\n      (In_Tree               : Project_Tree_Ref;\n       Data                  : in out Project_Data;\n       Filename              : String;\n@@ -7637,409 +7660,184 @@ package body Prj.Nmsc is\n       Lang_Kind             : out Language_Kind;\n       Kind                  : out Source_Kind)\n    is\n-      Last           : Positive := Filename'Last;\n       Config         : Language_Config;\n       Lang           : Name_List_Index := Data.Languages;\n+      Tmp_Lang       : Language_Index;\n+\n       Header_File    : Boolean := False;\n-      First_Language : Language_Index := No_Language_Index;\n-      OK             : Boolean;\n+      --  True if we found at least one language for which the file is a header\n+      --  In such a case, we search for all possible languages where this is\n+      --  also a header (C and C++ for instance), since the file might be used\n+      --  for several such languages.\n+\n+      procedure Check_File_Based_Lang;\n+      --  Does the naming scheme test for file-based languages. For those,\n+      --  there is no Unit. Just check if the file name has the implementation\n+      --  or, if it is specified, the template suffix of the language.\n+      --\n+      --  Returns True if the file belongs to the current language and we\n+      --  should stop searching for matching languages. Not that a given header\n+      --  file could belong to several languages (C and C++ for instance). Thus\n+      --  if we found a header we'll check whether it matches other languages\n+\n+      procedure Check_Unit_Based_Lang;\n+      --  Does the naming scheme test for unit-based languages\n \n-      Last_Spec : Natural;\n-      Last_Body : Natural;\n-      Last_Sep  : Natural;\n+      ---------------------------\n+      -- Check_File_Based_Lang --\n+      ---------------------------\n \n-   begin\n-      --  Default values\n+      procedure Check_File_Based_Lang is\n+      begin\n+         if not Header_File\n+           and then Suffix_Matches (Filename, Config.Naming_Data.Body_Suffix)\n+         then\n+            Unit     := No_Name;\n+            Kind     := Impl;\n+            Language := Tmp_Lang;\n \n-      Alternate_Languages   := No_Alternate_Language;\n-      Language              := No_Language_Index;\n-      Language_Name         := No_Name;\n-      Display_Language_Name := No_Name;\n-      Unit                  := No_Name;\n-      Lang_Kind             := File_Based;\n-      Kind                  := Spec;\n+            if Current_Verbosity = High then\n+               Write_Str (\"     implementation of language \");\n+               Write_Line (Get_Name_String (Display_Language_Name));\n+            end if;\n \n-      while Lang /= No_Name_List loop\n-         Language_Name := In_Tree.Name_Lists.Table (Lang).Name;\n-         Language      := Data.First_Language_Processing;\n+         elsif Suffix_Matches (Filename, Config.Naming_Data.Spec_Suffix) then\n+            if Current_Verbosity = High then\n+               Write_Str (\"     header of language \");\n+               Write_Line (Get_Name_String (Display_Language_Name));\n+            end if;\n \n-         if Current_Verbosity = High then\n-            Write_Line\n-              (\"     Testing language \"\n-               & Get_Name_String (Language_Name)\n-               & \" Header_File=\" & Header_File'Img);\n+            if Header_File then\n+               Alternate_Language_Table.Increment_Last (In_Tree.Alt_Langs);\n+               In_Tree.Alt_Langs.Table\n+                 (Alternate_Language_Table.Last (In_Tree.Alt_Langs)) :=\n+                 (Language => Language,\n+                  Next     => Alternate_Languages);\n+               Alternate_Languages :=\n+                 Alternate_Language_Table.Last (In_Tree.Alt_Langs);\n+            else\n+               Header_File := True;\n+               Kind        := Spec;\n+               Unit        := No_Name;\n+               Language    := Tmp_Lang;\n+            end if;\n          end if;\n+      end Check_File_Based_Lang;\n \n-         while Language /= No_Language_Index loop\n-            if In_Tree.Languages_Data.Table (Language).Name =\n-              Language_Name\n-            then\n-               Display_Language_Name :=\n-                 In_Tree.Languages_Data.Table (Language).Display_Name;\n-               Config := In_Tree.Languages_Data.Table (Language).Config;\n-               Lang_Kind := Config.Kind;\n-\n-               if Config.Kind = File_Based then\n-\n-                  --  For file based languages, there is no Unit. Just\n-                  --  check if the file name has the implementation or,\n-                  --  if it is specified, the template suffix of the\n-                  --  language.\n-\n-                  Unit := No_Name;\n-\n-                  if not Header_File\n-                    and then Config.Naming_Data.Body_Suffix /= No_File\n-                  then\n-                     declare\n-                        Impl_Suffix : constant String :=\n-                          Get_Name_String (Config.Naming_Data.Body_Suffix);\n-\n-                     begin\n-                        if Filename'Length > Impl_Suffix'Length\n-                          and then\n-                            Filename\n-                              (Last - Impl_Suffix'Length + 1 .. Last) =\n-                              Impl_Suffix\n-                        then\n-                           Kind := Impl;\n-\n-                           if Current_Verbosity = High then\n-                              Write_Str (\"     source of language \");\n-                              Write_Line\n-                                (Get_Name_String (Display_Language_Name));\n-                           end if;\n-\n-                           return;\n-                        end if;\n-                     end;\n-                  end if;\n-\n-                  if Config.Naming_Data.Spec_Suffix /= No_File then\n-                     declare\n-                        Spec_Suffix : constant String :=\n-                          Get_Name_String\n-                            (Config.Naming_Data.Spec_Suffix);\n-\n-                     begin\n-                        if Filename'Length > Spec_Suffix'Length\n-                          and then\n-                            Filename\n-                              (Last - Spec_Suffix'Length + 1 .. Last) =\n-                              Spec_Suffix\n-                        then\n-                           Kind := Spec;\n-\n-                           if Current_Verbosity = High then\n-                              Write_Str (\"     header file of language \");\n-                              Write_Line\n-                                (Get_Name_String (Display_Language_Name));\n-                           end if;\n-\n-                           if Header_File then\n-                              Alternate_Language_Table.Increment_Last\n-                                (In_Tree.Alt_Langs);\n-                              In_Tree.Alt_Langs.Table\n-                                (Alternate_Language_Table.Last\n-                                   (In_Tree.Alt_Langs)) :=\n-                                (Language => Language,\n-                                 Next     => Alternate_Languages);\n-                              Alternate_Languages :=\n-                                Alternate_Language_Table.Last\n-                                  (In_Tree.Alt_Langs);\n-                           else\n-                              Header_File    := True;\n-                              First_Language := Language;\n-                           end if;\n-                        end if;\n-                     end;\n-                  end if;\n-\n-               elsif not Header_File then\n-                  --  Unit based language\n-\n-                  OK := Config.Naming_Data.Dot_Replacement /= No_File;\n-\n-                  if OK then\n-\n-                     --  Check casing\n-                     --  ??? Are we doing this once per file in the project ?\n-                     --  It should be done only once per project.\n-\n-                     case Config.Naming_Data.Casing is\n-                        when All_Lower_Case =>\n-                           for J in Filename'Range loop\n-                              if Is_Letter (Filename (J)) then\n-                                 if not Is_Lower (Filename (J)) then\n-                                    OK := False;\n-                                    exit;\n-                                 end if;\n-                              end if;\n-                           end loop;\n-\n-                        when All_Upper_Case =>\n-                           for J in Filename'Range loop\n-                              if Is_Letter (Filename (J)) then\n-                                 if not Is_Upper (Filename (J)) then\n-                                    OK := False;\n-                                    exit;\n-                                 end if;\n-                              end if;\n-                           end loop;\n-\n-                        when Mixed_Case =>\n-                           null;\n-\n-                        when others =>\n-                           OK := False;\n-                     end case;\n-                  end if;\n-\n-                  if OK then\n-                     Last_Spec := Natural'Last;\n-                     Last_Body := Natural'Last;\n-                     Last_Sep  := Natural'Last;\n-\n-                     if Config.Naming_Data.Separate_Suffix /= No_File\n-                       and then\n-                         Config.Naming_Data.Separate_Suffix /=\n-                           Config.Naming_Data.Body_Suffix\n-                     then\n-                        declare\n-                           Suffix : constant String :=\n-                             Get_Name_String\n-                               (Config.Naming_Data.Separate_Suffix);\n-                        begin\n-                           if Filename'Length > Suffix'Length\n-                             and then\n-                               Filename\n-                                 (Last - Suffix'Length + 1 .. Last) =\n-                                 Suffix\n-                           then\n-                              Last_Sep := Last - Suffix'Length;\n-                           end if;\n-                        end;\n-                     end if;\n-\n-                     if Config.Naming_Data.Body_Suffix /= No_File then\n-                        declare\n-                           Suffix : constant String :=\n-                             Get_Name_String\n-                               (Config.Naming_Data.Body_Suffix);\n-                        begin\n-                           if Filename'Length > Suffix'Length\n-                             and then\n-                               Filename\n-                                 (Last - Suffix'Length + 1 .. Last) =\n-                                 Suffix\n-                           then\n-                              Last_Body := Last - Suffix'Length;\n-                           end if;\n-                        end;\n-                     end if;\n-\n-                     if Config.Naming_Data.Spec_Suffix /= No_File then\n-                        declare\n-                           Suffix : constant String :=\n-                             Get_Name_String\n-                               (Config.Naming_Data.Spec_Suffix);\n-                        begin\n-                           if Filename'Length > Suffix'Length\n-                             and then\n-                               Filename\n-                                 (Last - Suffix'Length + 1 .. Last) =\n-                                 Suffix\n-                           then\n-                              Last_Spec := Last - Suffix'Length;\n-                           end if;\n-                        end;\n-                     end if;\n-\n-                     declare\n-                        Last_Min : constant Natural :=\n-                                     Natural'Min (Natural'Min (Last_Spec,\n-                                                               Last_Body),\n-                                                               Last_Sep);\n+      ---------------------------\n+      -- Check_Unit_Based_Lang --\n+      ---------------------------\n \n-                     begin\n-                        OK := Last_Min < Last;\n+      procedure Check_Unit_Based_Lang is\n+         Masked      : Boolean  := False;\n+         Unit_Except : Unit_Exception;\n+      begin\n+         Compute_Unit_Name\n+           (Filename        => Filename,\n+            Dot_Replacement => Config.Naming_Data.Dot_Replacement,\n+            Separate_Suffix => Config.Naming_Data.Separate_Suffix,\n+            Body_Suffix     => Config.Naming_Data.Body_Suffix,\n+            Spec_Suffix     => Config.Naming_Data.Spec_Suffix,\n+            Casing          => Config.Naming_Data.Casing,\n+            Kind            => Kind,\n+            Unit            => Unit);\n+\n+         --  If there is a naming exception for the same unit, the file is not\n+         --  a source for the unit\n \n-                        if OK then\n-                           Last := Last_Min;\n+         if Unit /= No_Name then\n+            Unit_Except := Unit_Exceptions.Get (Unit);\n \n-                           if Last_Min = Last_Spec then\n-                              Kind := Spec;\n+            if Kind = Spec then\n+               Masked := Unit_Except.Spec /= No_File\n+                 and then Unit_Except.Spec /= File_Name;\n+            else\n+               Masked := Unit_Except.Impl /= No_File\n+                 and then Unit_Except.Impl /= File_Name;\n+            end if;\n \n-                           elsif Last_Min = Last_Body then\n-                              Kind := Impl;\n+            if Masked then\n+               if Current_Verbosity = High then\n+                  Write_Str (\"   \"\"\" & Filename & \"\"\" contains the \");\n \n-                           else\n-                              Kind := Sep;\n-                           end if;\n-                        end if;\n-                     end;\n+                  if Kind = Spec then\n+                     Write_Str (\"spec of a unit found in \"\"\");\n+                     Write_Str (Get_Name_String (Unit_Except.Spec));\n+                  else\n+                     Write_Str (\"body of a unit found in \"\"\");\n+                     Write_Str (Get_Name_String (Unit_Except.Impl));\n                   end if;\n \n-                  if OK then\n-\n-                     --  Replace dot replacements with dots\n-\n-                     Name_Len := 0;\n-\n-                     declare\n-                        J : Positive := Filename'First;\n-\n-                        Dot_Replacement : constant String :=\n-                          Get_Name_String\n-                            (Config.Naming_Data.\n-                                 Dot_Replacement);\n-\n-                        Max : constant Positive :=\n-                          Last - Dot_Replacement'Length + 1;\n-\n-                     begin\n-                        loop\n-                           Name_Len := Name_Len + 1;\n-\n-                           if J <= Max and then\n-                             Filename\n-                               (J .. J + Dot_Replacement'Length - 1) =\n-                               Dot_Replacement\n-                           then\n-                              Name_Buffer (Name_Len) := '.';\n-                              J := J + Dot_Replacement'Length;\n-\n-                           else\n-                              if Filename (J) = '.' then\n-                                 OK := False;\n-                                 exit;\n-                              end if;\n-\n-                              Name_Buffer (Name_Len) :=\n-                                GNAT.Case_Util.To_Lower (Filename (J));\n-                              J := J + 1;\n-                           end if;\n+                  Write_Line (\"\"\" (ignored)\");\n+               end if;\n \n-                           exit when J > Last;\n-                        end loop;\n-                     end;\n+            else\n+               if Current_Verbosity = High then\n+                  if Kind = Spec then\n+                     Write_Str (\"     spec of \");\n+                  else\n+                     Write_Str (\"     body of \");\n                   end if;\n \n-                  if OK then\n-\n-                     --  The name buffer should contain the name of the\n-                     --  the unit, if it is one.\n-\n-                     --  Check that this is a valid unit name\n-\n-                     Check_Ada_Name (Name_Buffer (1 .. Name_Len), Unit);\n-\n-                     if Unit /= No_Name then\n-\n-                        if Current_Verbosity = High then\n-                           if Kind = Spec then\n-                              Write_Str (\"     spec of \");\n-                           else\n-                              Write_Str (\"     body of \");\n-                           end if;\n-\n-                           Write_Str (Get_Name_String (Unit));\n-                           Write_Str (\" (language \");\n-                           Write_Str\n-                             (Get_Name_String (Display_Language_Name));\n-                           Write_Line (\")\");\n-                        end if;\n-\n-                        --  Comments required, declare block should\n-                        --  be named ???\n-\n-                        declare\n-                           Unit_Except : constant Unit_Exception :=\n-                             Unit_Exceptions.Get (Unit);\n-\n-                           procedure Masked_Unit (Spec : Boolean);\n-                           --  Indicate that there is an exception for\n-                           --  the same unit, so the file is not a\n-                           --  source for the unit.\n-\n-                           -----------------\n-                           -- Masked_Unit --\n-                           -----------------\n-\n-                           procedure Masked_Unit (Spec : Boolean) is\n-                           begin\n-                              if Current_Verbosity = High then\n-                                 Write_Str (\"   \"\"\");\n-                                 Write_Str (Filename);\n-                                 Write_Str (\"\"\" contains the \");\n-\n-                                 if Spec then\n-                                    Write_Str (\"spec\");\n-                                 else\n-                                    Write_Str (\"body\");\n-                                 end if;\n-\n-                                 Write_Str\n-                                   (\" of a unit that is found in \"\"\");\n-\n-                                 if Spec then\n-                                    Write_Str\n-                                      (Get_Name_String\n-                                         (Unit_Except.Spec));\n-                                 else\n-                                    Write_Str\n-                                      (Get_Name_String\n-                                         (Unit_Except.Impl));\n-                                 end if;\n+                  Write_Str (Get_Name_String (Unit));\n+                  Write_Str (\" language: \");\n+                  Write_Line (Get_Name_String (Display_Language_Name));\n+               end if;\n \n-                                 Write_Line (\"\"\" (ignored)\");\n-                              end if;\n+               Language    := Tmp_Lang;\n+            end if;\n+         end if;\n+      end Check_Unit_Based_Lang;\n \n-                              Language := No_Language_Index;\n-                           end Masked_Unit;\n+   begin\n+      Language              := No_Language_Index;\n+      Alternate_Languages   := No_Alternate_Language;\n+      Display_Language_Name := No_Name;\n+      Unit                  := No_Name;\n+      Lang_Kind             := File_Based;\n+      Kind                  := Spec;\n \n-                        begin\n-                           if Kind = Spec then\n-                              if Unit_Except.Spec /= No_File\n-                                and then Unit_Except.Spec /= File_Name\n-                              then\n-                                 Masked_Unit (Spec => True);\n-                              end if;\n+      while Lang /= No_Name_List loop\n+         Language_Name := In_Tree.Name_Lists.Table (Lang).Name;\n+         Tmp_Lang := Get_Language_Processing_From_Lang (In_Tree, Data, Lang);\n \n-                           else\n-                              if Unit_Except.Impl /= No_File\n-                                and then Unit_Except.Impl /= File_Name\n-                              then\n-                                 Masked_Unit (Spec => False);\n-                              end if;\n-                           end if;\n-                        end;\n+         if Current_Verbosity = High then\n+            Write_Line\n+              (\"     Testing language \"\n+               & Get_Name_String (Language_Name)\n+               & \" Header_File=\" & Header_File'Img);\n+         end if;\n \n-                        return;\n-                     end if;\n+         if Tmp_Lang /= No_Language_Index then\n+            Display_Language_Name :=\n+              In_Tree.Languages_Data.Table (Tmp_Lang).Display_Name;\n+            Config := In_Tree.Languages_Data.Table (Tmp_Lang).Config;\n+            Lang_Kind := Config.Kind;\n+\n+            case Config.Kind is\n+               when File_Based =>\n+                  Check_File_Based_Lang;\n+                  exit when Kind = Impl;\n+\n+               when Unit_Based =>\n+                  --  We know it belongs to a least a file_based language, no\n+                  --  need to check unit-based ones.\n+                  if not Header_File then\n+                     Check_Unit_Based_Lang;\n+                     exit when Language /= No_Language_Index;\n                   end if;\n-               end if;\n-            end if;\n-\n-            Language := In_Tree.Languages_Data.Table (Language).Next;\n-         end loop;\n+            end case;\n+         end if;\n \n          Lang := In_Tree.Name_Lists.Table (Lang).Next;\n       end loop;\n \n-      --  Comment needed here ???\n-\n-      if Header_File then\n-         Language := First_Language;\n-\n-      else\n-         Language := No_Language_Index;\n-\n-         if Current_Verbosity = High then\n-            Write_Line (\"     not a source of any language\");\n-         end if;\n+      if Language = No_Language_Index\n+        and then Current_Verbosity = High\n+      then\n+         Write_Line (\"     not a source of any language\");\n       end if;\n-   end Check_Naming_Schemes;\n+   end Check_File_Naming_Schemes;\n \n    ----------------\n    -- Check_File --\n@@ -8145,7 +7943,7 @@ package body Prj.Nmsc is\n       if Check_Name then\n          Other_Part := No_Source;\n \n-         Check_Naming_Schemes\n+         Check_File_Naming_Schemes\n            (In_Tree               => In_Tree,\n             Data                  => Data,\n             Filename              => Get_Name_String (File_Name),\n@@ -8425,13 +8223,13 @@ package body Prj.Nmsc is\n    ----------------------------\n \n    procedure Load_Naming_Exceptions\n-     (Project     : Project_Id;\n-      In_Tree     : Project_Tree_Ref;\n-      Data        : in out Project_Data)\n+     (Project : Project_Id;\n+      In_Tree : Project_Tree_Ref;\n+      Data    : in out Project_Data)\n    is\n-      Source   : Source_Id := Data.First_Source;\n-      File     : File_Name_Type;\n-      Unit     : Name_Id;\n+      Source : Source_Id := Data.First_Source;\n+      File   : File_Name_Type;\n+      Unit   : Name_Id;\n    begin\n       Unit_Exceptions.Reset;\n "}, {"sha": "acafb42a430392c8b594ad064fe13f0e6e96852d", "filename": "gcc/ada/prj-proc.adb", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce30eccb0612505eb75a1046db11b7a4c0bb0326/gcc%2Fada%2Fprj-proc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce30eccb0612505eb75a1046db11b7a4c0bb0326/gcc%2Fada%2Fprj-proc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-proc.adb?ref=ce30eccb0612505eb75a1046db11b7a4c0bb0326", "patch": "@@ -2527,6 +2527,10 @@ package body Prj.Proc is\n       --  only projects imported through a standard \"with\" are processed.\n       --  Imported is the id of the last imported project.\n \n+      -------------------------------\n+      -- Process_Imported_Projects --\n+      -------------------------------\n+\n       procedure Process_Imported_Projects\n         (Imported     : in out Project_List;\n          Limited_With : Boolean)"}]}