{"sha": "befe7c61462d147b408df88fe8a6f8e14e3ad877", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmVmZTdjNjE0NjJkMTQ3YjQwOGRmODhmZThhNmY4ZTE0ZTNhZDg3Nw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2001-07-31T16:12:04Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2001-07-31T16:12:04Z"}, "message": "The 3.0 ABI no longer has vbase pointer fields.\n\ncp:\n\tThe 3.0 ABI no longer has vbase pointer fields.\n\t* cp-tree.h (VBASE_NAME, VBASE_NAME_FORMAT, VBASE_NAME_P,\n\tFORMAT_VBASE_NAME): Remove.\n\t* method.c (do_build_copy_constructor): Adjust.\n\t(do_build_assign_ref): Adjust.\n\t* search.c (lookup_field_r): Adjust.\n\t* typeck.c (build_component_ref): Adjust.\n\n\tThe 3.0 ABI always has a vtable pointer at the start of every\n\tpolymorphic class.\n\t* rtti.c (build_headof_sub): Remove.\n\t(build_headof): Adjust.\n\t(get_tinfo_decl_dynamic): No need to check flag_rtti\n\there. Adjust.\n\t(create_real_tinfo_var): Explain why we need a hidden name.\n\nFrom-SVN: r44515", "tree": {"sha": "3547b7352d8bd1e1b80a28e48e5f9c9608a18e8e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3547b7352d8bd1e1b80a28e48e5f9c9608a18e8e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/befe7c61462d147b408df88fe8a6f8e14e3ad877", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/befe7c61462d147b408df88fe8a6f8e14e3ad877", "html_url": "https://github.com/Rust-GCC/gccrs/commit/befe7c61462d147b408df88fe8a6f8e14e3ad877", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/befe7c61462d147b408df88fe8a6f8e14e3ad877/comments", "author": null, "committer": null, "parents": [{"sha": "dc56ceb766a005fadcd9287e7e72be947936f01a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc56ceb766a005fadcd9287e7e72be947936f01a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc56ceb766a005fadcd9287e7e72be947936f01a"}], "stats": {"total": 101, "additions": 23, "deletions": 78}, "files": [{"sha": "39689e8cd3bf46a2984dd615e99f1e6574eab65d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/befe7c61462d147b408df88fe8a6f8e14e3ad877/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/befe7c61462d147b408df88fe8a6f8e14e3ad877/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=befe7c61462d147b408df88fe8a6f8e14e3ad877", "patch": "@@ -1,3 +1,21 @@\n+2001-07-31  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tThe 3.0 ABI no longer has vbase pointer fields.\n+\t* cp-tree.h (VBASE_NAME, VBASE_NAME_FORMAT, VBASE_NAME_P,\n+\tFORMAT_VBASE_NAME): Remove.\n+\t* method.c (do_build_copy_constructor): Adjust.\n+\t(do_build_assign_ref): Adjust.\n+\t* search.c (lookup_field_r): Adjust.\n+\t* typeck.c (build_component_ref): Adjust.\n+\n+\tThe 3.0 ABI always has a vtable pointer at the start of every\n+\tpolymorphic class.\n+\t* rtti.c (build_headof_sub): Remove.\n+\t(build_headof): Adjust.\n+\t(get_tinfo_decl_dynamic): No need to check flag_rtti\n+\there. Adjust.\n+\t(create_real_tinfo_var): Explain why we need a hidden name.\n+\n 2001-07-31  Nathan Sidwell  <nathan@codesourcery.com>\n \n \tPR c++/3631"}, {"sha": "c485c4341dad3b1748d22d0004c8f839af3f07f1", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/befe7c61462d147b408df88fe8a6f8e14e3ad877/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/befe7c61462d147b408df88fe8a6f8e14e3ad877/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=befe7c61462d147b408df88fe8a6f8e14e3ad877", "patch": "@@ -3140,8 +3140,6 @@ extern varray_type local_classes;\n #define VFIELD_BASE \"$vf\"\n #define VFIELD_NAME \"_vptr$\"\n #define VFIELD_NAME_FORMAT \"_vptr$%s\"\n-#define VBASE_NAME \"_vb$\"\n-#define VBASE_NAME_FORMAT \"_vb$%s\"\n #define STATIC_NAME_FORMAT \"_%s$%s\"\n #define ANON_AGGRNAME_FORMAT \"$_%d\"\n \n@@ -3162,8 +3160,6 @@ extern varray_type local_classes;\n #define VFIELD_BASE \".vf\"\n #define VFIELD_NAME \"_vptr.\"\n #define VFIELD_NAME_FORMAT \"_vptr.%s\"\n-#define VBASE_NAME \"_vb.\"\n-#define VBASE_NAME_FORMAT \"_vb.%s\"\n #define STATIC_NAME_FORMAT \"_%s.%s\"\n \n #define ANON_AGGRNAME_FORMAT \"._%d\"\n@@ -3197,11 +3193,6 @@ extern varray_type local_classes;\n   (!strncmp (IDENTIFIER_POINTER (ID_NODE), VFIELD_NAME, \\\n \t    sizeof (VFIELD_NAME) - 1))\n #define VFIELD_NAME_FORMAT \"_vptr_%s\"\n-#define VBASE_NAME \"__vb_\"\n-#define VBASE_NAME_P(ID_NODE) \\\n-  (!strncmp (IDENTIFIER_POINTER (ID_NODE), VBASE_NAME, \\\n-\t     sizeof (VBASE_NAME) - 1))\n-#define VBASE_NAME_FORMAT \"__vb_%s\"\n #define STATIC_NAME_FORMAT \"__static_%s_%s\"\n \n #define ANON_AGGRNAME_PREFIX \"__anon_\"\n@@ -3244,10 +3235,6 @@ extern varray_type local_classes;\n   && IDENTIFIER_POINTER (ID_NODE)[2] == 't' \\\n   && IDENTIFIER_POINTER (ID_NODE)[3] == JOINER)\n \n-#define VBASE_NAME_P(ID_NODE) (IDENTIFIER_POINTER (ID_NODE)[1] == 'v' \\\n-  && IDENTIFIER_POINTER (ID_NODE)[2] == 'b' \\\n-  && IDENTIFIER_POINTER (ID_NODE)[3] == JOINER)\n-\n #define TEMP_NAME_P(ID_NODE) (!strncmp (IDENTIFIER_POINTER (ID_NODE), AUTO_TEMP_NAME, sizeof (AUTO_TEMP_NAME)-1))\n #define VFIELD_NAME_P(ID_NODE) (!strncmp (IDENTIFIER_POINTER (ID_NODE), VFIELD_NAME, sizeof(VFIELD_NAME)-1))\n \n@@ -3261,14 +3248,6 @@ extern varray_type local_classes;\n \t\t\t\t  && IDENTIFIER_POINTER (ID_NODE)[1] <= '9')\n #endif /* !defined(NO_DOLLAR_IN_LABEL) || !defined(NO_DOT_IN_LABEL) */\n \n-/* Store the vbase pointer field name for type TYPE into pointer BUF.  */\n-#define FORMAT_VBASE_NAME(BUF,TYPE) do {\t\t\t\t\\\n-  char *wbuf = (char *) alloca (TYPE_ASSEMBLER_NAME_LENGTH (TYPE)\t\\\n-\t\t\t + sizeof (VBASE_NAME) + 1);\t\t\t\\\n-  sprintf (wbuf, VBASE_NAME_FORMAT, TYPE_ASSEMBLER_NAME_STRING (TYPE));\t\\\n-  (BUF) = wbuf;\t\t\t\t\t\t\t\t\\\n-} while (0)\n-\n /* Returns non-zero iff NODE is a declaration for the global function\n    `main'.  */\n #define DECL_MAIN_P(NODE)\t\t\t\t\\"}, {"sha": "03bf45527717f860fd585790bcde72571941feb2", "filename": "gcc/cp/method.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/befe7c61462d147b408df88fe8a6f8e14e3ad877/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/befe7c61462d147b408df88fe8a6f8e14e3ad877/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=befe7c61462d147b408df88fe8a6f8e14e3ad877", "patch": "@@ -588,8 +588,6 @@ do_build_copy_constructor (fndecl)\n \t    {\n \t      if (VFIELD_NAME_P (DECL_NAME (field)))\n \t\tcontinue;\n-\t      if (VBASE_NAME_P (DECL_NAME (field)))\n-\t\tcontinue;\n \n \t      /* True for duplicate members.  */\n \t      if (IDENTIFIER_CLASS_VALUE (DECL_NAME (field)) != field)\n@@ -678,8 +676,6 @@ do_build_assign_ref (fndecl)\n \t    {\n \t      if (VFIELD_NAME_P (DECL_NAME (field)))\n \t\tcontinue;\n-\t      if (VBASE_NAME_P (DECL_NAME (field)))\n-\t\tcontinue;\n \n \t      /* True for duplicate members.  */\n \t      if (IDENTIFIER_CLASS_VALUE (DECL_NAME (field)) != field)"}, {"sha": "da1484c931d2a6ec2ef1f601403fbcb6e8b15996", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 4, "deletions": 34, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/befe7c61462d147b408df88fe8a6f8e14e3ad877/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/befe7c61462d147b408df88fe8a6f8e14e3ad877/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=befe7c61462d147b408df88fe8a6f8e14e3ad877", "patch": "@@ -41,7 +41,6 @@ Boston, MA 02111-1307, USA.  */\n \n extern struct obstack permanent_obstack;\n \n-static tree build_headof_sub PARAMS((tree));\n static tree build_headof PARAMS((tree));\n static tree ifnonnull PARAMS((tree, tree));\n static tree tinfo_name PARAMS((tree));\n@@ -82,23 +81,6 @@ init_rtti_processing ()\n     build_qualified_type (type_info_type_node, TYPE_QUAL_CONST);\n }\n \n-/* Given a pointer to an object with at least one virtual table\n-   pointer somewhere, return a pointer to a possible sub-object that\n-   has a virtual table pointer in it that is the vtable parent for\n-   that sub-object.  */\n-\n-static tree\n-build_headof_sub (exp)\n-     tree exp;\n-{\n-  tree type = TREE_TYPE (TREE_TYPE (exp));\n-  tree basetype = CLASSTYPE_RTTI (type);\n-  tree binfo = get_binfo (basetype, type, 0);\n-\n-  exp = convert_pointer_to_real (binfo, exp);\n-  return exp;\n-}\n-\n /* Given the expression EXP of type `class *', return the head of the\n    object pointed to by EXP with type cv void*, if the class has any\n    virtual functions (TYPE_POLYMORPHIC_P), else just return the\n@@ -118,10 +100,6 @@ build_headof (exp)\n   if (!TYPE_POLYMORPHIC_P (type))\n     return exp;\n \n-  /* If we don't have rtti stuff, get to a sub-object that does.  */\n-  if (!CLASSTYPE_VFIELDS (TREE_TYPE (TREE_TYPE (exp))))\n-    exp = build_headof_sub (exp);\n-\n   /* We use this a couple of times below, protect it.  */\n   exp = save_expr (exp);\n \n@@ -204,17 +182,6 @@ get_tinfo_decl_dynamic (exp)\n       tree t;\n       tree index;\n \n-      if (! flag_rtti)\n-\terror (\"taking dynamic typeid of object with -fno-rtti\");\n-\n-      /* If we don't have rtti stuff, get to a sub-object that does.  */\n-      if (! CLASSTYPE_VFIELDS (type))\n-\t{\n-      \t  exp = build_unary_op (ADDR_EXPR, exp, 0);\n-\t  exp = build_headof_sub (exp);\n-\t  exp = build_indirect_ref (exp, NULL);\n-\t}\n-\n       /* The RTTI information is at index -1.  */\n       index = integer_minus_one_node;\n       t = build_vfn_ref (exp, index);\n@@ -1146,7 +1113,10 @@ create_real_tinfo_var (target_type, name, type, init, non_public)\n   tree decl;\n   tree hidden_name;\n   char hidden[30];\n-  \n+\n+  /* We cannot give this the name NAME, as that already is globally\n+     bound to the tinfo_decl we originally created for this type in\n+     get_tinfo_decl. */\n   sprintf (hidden, \"__ti_%d\", count++);\n   hidden_name = get_identifier (hidden);\n   "}, {"sha": "f543f0dad0eedb13e44bb7781dcf94e67883590a", "filename": "gcc/cp/search.c", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/befe7c61462d147b408df88fe8a6f8e14e3ad877/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/befe7c61462d147b408df88fe8a6f8e14e3ad877/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=befe7c61462d147b408df88fe8a6f8e14e3ad877", "patch": "@@ -1451,15 +1451,6 @@ lookup_field_r (binfo, data)\n     }\n   else\n     {\n-      /* If the thing we're looking for is a virtual base class, then\n-\t we know we've got what we want at this point; there's no way\n-\t to get an ambiguity.  */\n-      if (VBASE_NAME_P (lfi->name))\n-\t{\n-\t  lfi->rval = nval;\n-\t  return nval;\n-\t}\n-\n       if (from_dep_base_p && TREE_CODE (nval) != TYPE_DECL\n \t  /* We need to return a member template class so we can\n \t     define partial specializations.  Is there a better"}, {"sha": "e38966f701caf328d02c61040c3a5a8330f6f69b", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/befe7c61462d147b408df88fe8a6f8e14e3ad877/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/befe7c61462d147b408df88fe8a6f8e14e3ad877/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=befe7c61462d147b408df88fe8a6f8e14e3ad877", "patch": "@@ -2237,16 +2237,7 @@ build_component_ref (datum, component, basetype_path, protect)\n \t      error (\"invalid reference to NULL ptr, use ptr-to-member instead\");\n \t      return error_mark_node;\n \t    }\n-\t  if (VBASE_NAME_P (DECL_NAME (field)))\n-\t    {\n-\t      /* It doesn't matter which vbase pointer we grab, just\n-\t\t find one of them.  */\n-\t      tree binfo = get_binfo (base,\n-\t\t\t\t      TREE_TYPE (TREE_TYPE (addr)), 0);\n-\t      addr = convert_pointer_to_real (binfo, addr);\n-\t    }\n-\t  else\n-\t    addr = convert_pointer_to (base, addr);\n+\t  addr = convert_pointer_to (base, addr);\n \t  datum = build_indirect_ref (addr, NULL);\n \t  if (datum == error_mark_node)\n \t    return error_mark_node;"}]}