{"sha": "a25ce4dbf97245d64ec5f32787eebee6beafec76", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTI1Y2U0ZGJmOTcyNDVkNjRlYzVmMzI3ODdlZWJlZTZiZWFmZWM3Ng==", "commit": {"author": {"name": "Phillip Jordan", "email": "pmj@gcc.gnu.org", "date": "2006-08-22T22:34:45Z"}, "committer": {"name": "Phillip Jordan", "email": "pmj@gcc.gnu.org", "date": "2006-08-22T22:34:45Z"}, "message": "added locking policy to tr1::shared_ptr<> and related classes\n\nFrom-SVN: r116333", "tree": {"sha": "35740461464d2f666da91513eeb9766f062a9074", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/35740461464d2f666da91513eeb9766f062a9074"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a25ce4dbf97245d64ec5f32787eebee6beafec76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a25ce4dbf97245d64ec5f32787eebee6beafec76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a25ce4dbf97245d64ec5f32787eebee6beafec76", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a25ce4dbf97245d64ec5f32787eebee6beafec76/comments", "author": null, "committer": null, "parents": [{"sha": "df3e8c70fd12a8702e4b4c9e1410e27ca88c21b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df3e8c70fd12a8702e4b4c9e1410e27ca88c21b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df3e8c70fd12a8702e4b4c9e1410e27ca88c21b8"}], "stats": {"total": 1358, "additions": 976, "deletions": 382}, "files": [{"sha": "9b22bd9a5d745895eca9441be76714040faf8870", "filename": "libstdc++-v3/include/tr1/boost_shared_ptr.h", "status": "modified", "additions": 579, "deletions": 382, "changes": 961, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a25ce4dbf97245d64ec5f32787eebee6beafec76/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fboost_shared_ptr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a25ce4dbf97245d64ec5f32787eebee6beafec76/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fboost_shared_ptr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fboost_shared_ptr.h?ref=a25ce4dbf97245d64ec5f32787eebee6beafec76", "patch": "@@ -57,7 +57,25 @@\n // namespace std::tr1\n namespace std\n {\n+\n _GLIBCXX_BEGIN_NAMESPACE(tr1)\n+// TODO This should go into a separate header really.\n+enum _Lock_policy { _S_lockfree, _S_mutex, _S_single }; \n+\n+static const _Lock_policy __shared_ptr_default_lock_mode = \n+#ifdef __GTHREADS\n+// NOTE: This doesn't actually exist yet in the compiler.\n+#ifdef _GLIBCXX_ATOMIC_BUILTINS\n+  _S_lockfree;\n+#else\n+  _S_mutex;\n+#endif\n+#else\n+  _S_single;\n+#endif\n+\n+// END TODO\n+\n \n class bad_weak_ptr : public std::exception\n {\n@@ -92,111 +110,168 @@ template<typename _Tp>\n     { delete p; }\n   };\n \n+// Empty helper class except when the template argument is _S_mutex.\n+template <_Lock_policy __l>\n+  class _Mutex_base\n+  {\n+  };\n \n-class _Sp_counted_base\n-{\n-public:\n-\n-  _Sp_counted_base()\n-  : _M_use_count(1), _M_weak_count(1)\n+template <>\n+  class _Mutex_base<_S_mutex>\n   {\n-    // For the case of __GTHREAD_MUTEX_INIT we haven't initialised\n-    // the mutex yet, so do it now.\n+  public:\n+    __gnu_cxx::mutex_type _M_mutex;\n+    \n+    _Mutex_base()\n+    {\n+      // For the case of __GTHREAD_MUTEX_INIT we haven't initialised\n+      // the mutex yet, so do it now.\n #if defined(__GTHREADS) && defined(__GTHREAD_MUTEX_INIT)\n-    __gthread_mutex_t __tmp = __GTHREAD_MUTEX_INIT;\n-    _M_mutex = __tmp;\n+      __gthread_mutex_t __tmp = __GTHREAD_MUTEX_INIT;\n+      _M_mutex = __tmp;\n #endif\n-  }\n-\n-  virtual\n-  ~_Sp_counted_base() // nothrow\n-  { }\n-\n-  // dispose() is called when _M_use_count drops to zero, to release\n-  // the resources managed by *this.\n-  virtual void\n-  dispose() = 0; // nothrow\n-\n-  // destroy() is called when _M_weak_count drops to zero.\n-  virtual void\n-  destroy() // nothrow\n-  {\n-    delete this;\n-  }\n+    }\n+  };\n \n-  virtual void*\n-  get_deleter(const std::type_info&) = 0;\n \n-  void\n-  add_ref_copy()\n+template <_Lock_policy __l = __shared_ptr_default_lock_mode>\n+  class _Sp_counted_base\n+  : public _Mutex_base<__l>\n   {\n-    __gnu_cxx::__atomic_add_dispatch(&_M_use_count, 1);\n-  }\n+  public:\n+  \n+    _Sp_counted_base()\n+    : _M_use_count(1), _M_weak_count(1)\n+    {\n+    }\n+  \n+    virtual\n+    ~_Sp_counted_base() // nothrow\n+    { }\n+  \n+    // dispose() is called when _M_use_count drops to zero, to release\n+    // the resources managed by *this.\n+    virtual void\n+    dispose() = 0; // nothrow\n+  \n+    // destroy() is called when _M_weak_count drops to zero.\n+    virtual void\n+    destroy() // nothrow\n+    {\n+      delete this;\n+    }\n+  \n+    virtual void*\n+    get_deleter(const std::type_info&) = 0;\n+  \n+    void\n+    add_ref_copy()\n+    {\n+      __gnu_cxx::__atomic_add(&_M_use_count, 1);\n+    }\n+  \n+    void\n+    add_ref_lock();\n+  \n+    void\n+    release() // nothrow\n+    {\n+      if (__gnu_cxx::__exchange_and_add(&_M_use_count, -1) == 1)\n+        {\n+          dispose();\n+  #ifdef __GTHREADS\t\n+          _GLIBCXX_READ_MEM_BARRIER;\n+          _GLIBCXX_WRITE_MEM_BARRIER;\n+  #endif\n+          if (__gnu_cxx::__exchange_and_add(&_M_weak_count, -1) == 1)\n+            destroy();\n+        }\n+    }\n+  \n+    void\n+    weak_add_ref() // nothrow\n+    {\n+      __gnu_cxx::__atomic_add(&_M_weak_count, 1);\n+    }\n+  \n+    void\n+    weak_release() // nothrow\n+    {\n+      if (__gnu_cxx::__exchange_and_add(&_M_weak_count, -1) == 1)\n+        {\n+#ifdef __GTHREADS\n+          _GLIBCXX_READ_MEM_BARRIER;\n+          _GLIBCXX_WRITE_MEM_BARRIER;\n+#endif\n+          destroy();\n+        }\n+    }\n+  \n+    long\n+    use_count() const // nothrow\n+    {\n+      return _M_use_count;  // XXX is this MT safe?\n+    }\n+  \n+  private:\n+  \n+    _Sp_counted_base(_Sp_counted_base const&);\n+    _Sp_counted_base& operator=(_Sp_counted_base const&);\n+  \n+    _Atomic_word _M_use_count;        // #shared\n+    _Atomic_word _M_weak_count;       // #weak + (#shared != 0)\n+  };\n \n+template<>\n+  inline\n   void\n-  add_ref_lock()\n+  _Sp_counted_base<_S_single>::add_ref_lock()\n   {\n-    __gnu_cxx::lock lock(_M_mutex);\n-    if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, 1) == 0)\n+    if (__gnu_cxx::__exchange_and_add(&_M_use_count, 1) == 0)\n       {\n-\t_M_use_count = 0;\n-\t__throw_bad_weak_ptr();\n+        _M_use_count = 0;\n+        __throw_bad_weak_ptr();\n       }\n   }\n-\n+  \n+#ifdef __GTHREADS\n+template<>\n+  inline\n   void\n-  release() // nothrow\n+  _Sp_counted_base<_S_mutex>::add_ref_lock()\n   {\n-    if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, -1) == 1)\n+    __gnu_cxx::lock lock(_M_mutex);\n+    if (__gnu_cxx::__exchange_and_add(&_M_use_count, 1) == 0)\n       {\n-\tdispose();\n-#ifdef __GTHREADS\t\n-\t_GLIBCXX_READ_MEM_BARRIER;\n-\t_GLIBCXX_WRITE_MEM_BARRIER;\n-#endif\n-\tif (__gnu_cxx::__exchange_and_add_dispatch(&_M_weak_count, -1) == 1)\n-\t  destroy();\n+        _M_use_count = 0;\n+        __throw_bad_weak_ptr();\n       }\n   }\n-\n-  void\n-  weak_add_ref() // nothrow\n-  {\n-    __gnu_cxx::__atomic_add_dispatch(&_M_weak_count, 1);\n-  }\n-\n-  void\n-  weak_release() // nothrow\n-  {\n-    if (__gnu_cxx::__exchange_and_add_dispatch(&_M_weak_count, -1) == 1)\n-      {\n-#ifdef __GTHREADS\n-\t_GLIBCXX_READ_MEM_BARRIER;\n-\t_GLIBCXX_WRITE_MEM_BARRIER;\n #endif\n-\tdestroy();\n-      }\n-  }\n \n-  long\n-  use_count() const // nothrow\n+template<> \n+  inline\n+  void\n+  _Sp_counted_base<_S_lockfree>::add_ref_lock()\n   {\n-    return _M_use_count;  // XXX is this MT safe?\n+    // Perform lock-free add-if-not-zero operation.\n+    _Atomic_word __count;\n+    do\n+    {\n+      __count = _M_use_count;\n+      if (__count == 0)\n+        {\n+          __throw_bad_weak_ptr();\n+        }\n+      /* Replace the current counter value with the old value + 1, as long\n+       * as it's not changed meanwhile. */\n+    }\n+    while (!__sync_bool_compare_and_swap(&_M_use_count, __count, __count + 1));\n   }\n \n-private:\n-\n-  _Sp_counted_base(_Sp_counted_base const&);\n-  _Sp_counted_base& operator=(_Sp_counted_base const&);\n-\n-  _Atomic_word _M_use_count;        // #shared\n-  _Atomic_word _M_weak_count;       // #weak + (#shared != 0)\n-  __gnu_cxx::mutex_type _M_mutex;\n-};\n-\n-template<typename _Ptr, typename _Deleter>\n+template<typename _Ptr, typename _Deleter, _Lock_policy __l>\n   class _Sp_counted_base_impl\n-  : public _Sp_counted_base\n+  : public _Sp_counted_base<__l>\n   {\n   public:\n \n@@ -228,206 +303,210 @@ template<typename _Ptr, typename _Deleter>\n     _Deleter _M_del; // copy constructor must not throw\n   };\n \n-class weak_count;\n-\n-class shared_count\n-{\n-private:\n-\n-  _Sp_counted_base* _M_pi;\n-\n-  friend class weak_count;\n-\n-public:\n-\n-  shared_count()\n-  : _M_pi(0) // nothrow\n-  { }\n-\n-  template<typename _Ptr, typename _Deleter>\n-    shared_count(_Ptr __p, _Deleter __d)\n-    : _M_pi(0)\n-    {\n-      try\n-\t{\n-\t  _M_pi = new _Sp_counted_base_impl<_Ptr, _Deleter>(__p, __d);\n-\t}\n-      catch(...)\n-\t{\n-\t  __d(__p); // delete __p\n-\t  __throw_exception_again;\n-\t}\n-    }\n-\n-  // auto_ptr<_Tp> is special cased to provide the strong guarantee\n-\n-  template<typename _Tp>\n-    explicit shared_count(std::auto_ptr<_Tp>& __r)\n-    : _M_pi(new _Sp_counted_base_impl<_Tp*,\n-\t    _Sp_deleter<_Tp> >(__r.get(), _Sp_deleter<_Tp>()))\n-    { __r.release(); }\n-\n-  // throws bad_weak_ptr when __r.use_count() == 0\n-  explicit shared_count(const weak_count& __r);\n-\n-  ~shared_count() // nothrow\n-  {\n-    if (_M_pi != 0)\n-      _M_pi->release();\n-  }\n+template<_Lock_policy __l = __shared_ptr_default_lock_mode>\n+  class weak_count;\n \n-  shared_count(const shared_count& __r)\n-  : _M_pi(__r._M_pi) // nothrow\n+template<_Lock_policy __l = __shared_ptr_default_lock_mode>\n+  class shared_count\n   {\n-    if (_M_pi != 0)\n-      _M_pi->add_ref_copy();\n-  }\n-\n-  shared_count&\n-  operator=(const shared_count& __r) // nothrow\n-  {\n-    _Sp_counted_base* __tmp = __r._M_pi;\n-\n-    if(__tmp != _M_pi)\n+  private:\n+  \n+    _Sp_counted_base<__l>* _M_pi;\n+  \n+    friend class weak_count<__l>;\n+  \n+  public:\n+  \n+    shared_count()\n+    : _M_pi(0) // nothrow\n+    { }\n+  \n+    template<typename _Ptr, typename _Deleter>\n+      shared_count(_Ptr __p, _Deleter __d)\n+      : _M_pi(0)\n       {\n-\tif(__tmp != 0)\n-\t  __tmp->add_ref_copy();\n-\tif(_M_pi != 0)\n-\t  _M_pi->release();\n-\t_M_pi = __tmp;\n+        try\n+          {\n+            _M_pi = new _Sp_counted_base_impl<_Ptr, _Deleter, __l>(__p, __d);\n+          }\n+        catch(...)\n+          {\n+            __d(__p); // delete __p\n+            __throw_exception_again;\n+          }\n       }\n-    return *this;\n-  }\n-\n-  void swap(shared_count& __r) // nothrow\n-  {\n-    _Sp_counted_base* __tmp = __r._M_pi;\n-    __r._M_pi = _M_pi;\n-    _M_pi = __tmp;\n-  }\n-\n-  long\n-  use_count() const // nothrow\n-  { return _M_pi != 0 ? _M_pi->use_count() : 0; }\n-\n-  bool\n-  unique() const // nothrow\n-  { return this->use_count() == 1; }\n-\n-  friend inline bool\n-  operator==(const shared_count& __a, const shared_count& __b)\n-  { return __a._M_pi == __b._M_pi; }\n-\n-  friend inline bool\n-  operator<(const shared_count& __a, const shared_count& __b)\n-  { return std::less<_Sp_counted_base*>()(__a._M_pi, __b._M_pi); }\n-\n-  void*\n-  get_deleter(const std::type_info& __ti) const\n-  { return _M_pi ? _M_pi->get_deleter(__ti) : 0; }\n-};\n-\n-class weak_count\n-{\n-private:\n-\n-  _Sp_counted_base* _M_pi;\n-\n-  friend class shared_count;\n-\n-public:\n-\n-  weak_count()\n-  : _M_pi(0) // nothrow\n-  { }\n-\n-  weak_count(const shared_count& __r)\n-  : _M_pi(__r._M_pi) // nothrow\n-  {\n-    if (_M_pi != 0)\n-      _M_pi->weak_add_ref();\n-  }\n-\n-  weak_count(const weak_count& __r)\n-  : _M_pi(__r._M_pi) // nothrow\n-  {\n-    if (_M_pi != 0)\n-      _M_pi->weak_add_ref();\n-  }\n-\n-  ~weak_count() // nothrow\n-  {\n-    if (_M_pi != 0)\n-      _M_pi->weak_release();\n-  }\n+  \n+    // auto_ptr<_Tp> is special cased to provide the strong guarantee\n+  \n+    template<typename _Tp>\n+      explicit shared_count(std::auto_ptr<_Tp>& __r)\n+      : _M_pi(new _Sp_counted_base_impl<_Tp*,\n+              _Sp_deleter<_Tp>, __l >(__r.get(), _Sp_deleter<_Tp>()))\n+      { __r.release(); }\n+  \n+    // throws bad_weak_ptr when __r.use_count() == 0\n+    explicit shared_count(const weak_count<__l>& __r);\n+  \n+    ~shared_count() // nothrow\n+    {\n+      if (_M_pi != 0)\n+        _M_pi->release();\n+    }\n+  \n+    shared_count(const shared_count& __r)\n+    : _M_pi(__r._M_pi) // nothrow\n+    {\n+      if (_M_pi != 0)\n+        _M_pi->add_ref_copy();\n+    }\n+  \n+    shared_count&\n+    operator=(const shared_count& __r) // nothrow\n+    {\n+      _Sp_counted_base<__l>* __tmp = __r._M_pi;\n+  \n+      if(__tmp != _M_pi)\n+        {\n+          if(__tmp != 0)\n+            __tmp->add_ref_copy();\n+          if(_M_pi != 0)\n+            _M_pi->release();\n+          _M_pi = __tmp;\n+        }\n+      return *this;\n+    }\n+  \n+    void swap(shared_count& __r) // nothrow\n+    {\n+      _Sp_counted_base<__l>* __tmp = __r._M_pi;\n+      __r._M_pi = _M_pi;\n+      _M_pi = __tmp;\n+    }\n+  \n+    long\n+    use_count() const // nothrow\n+    { return _M_pi != 0 ? _M_pi->use_count() : 0; }\n+  \n+    bool\n+    unique() const // nothrow\n+    { return this->use_count() == 1; }\n+  \n+    friend inline bool\n+    operator==(const shared_count& __a, const shared_count& __b)\n+    { return __a._M_pi == __b._M_pi; }\n+  \n+    friend inline bool\n+    operator<(const shared_count& __a, const shared_count& __b)\n+    { return std::less<_Sp_counted_base<__l>*>()(__a._M_pi, __b._M_pi); }\n+  \n+    void*\n+    get_deleter(const std::type_info& __ti) const\n+    { return _M_pi ? _M_pi->get_deleter(__ti) : 0; }\n+  };\n \n-  weak_count&\n-  operator=(const shared_count& __r) // nothrow\n+template<_Lock_policy __l>\n+  class weak_count\n   {\n-    _Sp_counted_base* __tmp = __r._M_pi;\n-    if (__tmp != 0)\n-      __tmp->weak_add_ref();\n-    if (_M_pi != 0)\n-      _M_pi->weak_release();\n-    _M_pi = __tmp;\n-\n-    return *this;\n-  }\n+  private:\n+  \n+    _Sp_counted_base<__l>* _M_pi;\n+  \n+    friend class shared_count<__l>;\n+  \n+  public:\n+  \n+    weak_count()\n+    : _M_pi(0) // nothrow\n+    { }\n+  \n+    weak_count(const shared_count<__l>& __r)\n+    : _M_pi(__r._M_pi) // nothrow\n+    {\n+      if (_M_pi != 0)\n+        _M_pi->weak_add_ref();\n+    }\n+  \n+    weak_count(const weak_count<__l>& __r)\n+    : _M_pi(__r._M_pi) // nothrow\n+    {\n+      if (_M_pi != 0)\n+        _M_pi->weak_add_ref();\n+    }\n+  \n+    ~weak_count() // nothrow\n+    {\n+      if (_M_pi != 0)\n+        _M_pi->weak_release();\n+    }\n+  \n+    weak_count<__l>&\n+    operator=(const shared_count<__l>& __r) // nothrow\n+    {\n+      _Sp_counted_base<__l>* __tmp = __r._M_pi;\n+      if (__tmp != 0)\n+        __tmp->weak_add_ref();\n+      if (_M_pi != 0)\n+        _M_pi->weak_release();\n+      _M_pi = __tmp;\n+  \n+      return *this;\n+    }\n+  \n+    weak_count<__l>&\n+    operator=(const weak_count<__l>& __r) // nothrow\n+    {\n+      _Sp_counted_base<__l> * __tmp = __r._M_pi;\n+      if (__tmp != 0)\n+        __tmp->weak_add_ref();\n+      if (_M_pi != 0)\n+        _M_pi->weak_release();\n+      _M_pi = __tmp;\n+  \n+      return *this;\n+    }\n+  \n+    void\n+    swap(weak_count<__l>& __r) // nothrow\n+    {\n+      _Sp_counted_base<__l> * __tmp = __r._M_pi;\n+      __r._M_pi = _M_pi;\n+      _M_pi = __tmp;\n+    }\n+  \n+    long\n+    use_count() const // nothrow\n+    { return _M_pi != 0 ? _M_pi->use_count() : 0; }\n+  \n+    friend inline bool\n+    operator==(const weak_count<__l>& __a, const weak_count<__l>& __b)\n+    { return __a._M_pi == __b._M_pi; }\n+  \n+    friend inline bool\n+    operator<(const weak_count<__l>& __a, const weak_count<__l>& __b)\n+    { return std::less<_Sp_counted_base<__l>*>()(__a._M_pi, __b._M_pi); }\n+  };\n \n-  weak_count&\n-  operator=(const weak_count& __r) // nothrow\n+template<_Lock_policy __l>\n+  inline\n+  shared_count<__l>::shared_count(const weak_count<__l>& __r)\n+  : _M_pi(__r._M_pi)\n   {\n-    _Sp_counted_base * __tmp = __r._M_pi;\n-    if (__tmp != 0)\n-      __tmp->weak_add_ref();\n     if (_M_pi != 0)\n-      _M_pi->weak_release();\n-    _M_pi = __tmp;\n-\n-    return *this;\n-  }\n-\n-  void\n-  swap(weak_count& __r) // nothrow\n-  {\n-    _Sp_counted_base * __tmp = __r._M_pi;\n-    __r._M_pi = _M_pi;\n-    _M_pi = __tmp;\n+      _M_pi->add_ref_lock();\n+    else\n+      __throw_bad_weak_ptr();\n   }\n \n-  long\n-  use_count() const // nothrow\n-  { return _M_pi != 0 ? _M_pi->use_count() : 0; }\n-\n-  friend inline bool\n-  operator==(const weak_count& __a, const weak_count& __b)\n-  { return __a._M_pi == __b._M_pi; }\n-\n-  friend inline bool\n-  operator<(const weak_count& __a, const weak_count& __b)\n-  { return std::less<_Sp_counted_base*>()(__a._M_pi, __b._M_pi); }\n-};\n-\n-inline\n-shared_count::shared_count(const weak_count& __r)\n-: _M_pi(__r._M_pi)\n-{\n-  if (_M_pi != 0)\n-    _M_pi->add_ref_lock();\n-  else\n-    __throw_bad_weak_ptr();\n-}\n-\n \n // fwd decls\n-template<typename _Tp>\n-  class shared_ptr;\n+template<typename _Tp, _Lock_policy __l = __shared_ptr_default_lock_mode>\n+  class __shared_ptr;\n \n-template<typename _Tp>\n-  class weak_ptr;\n+template<typename _Tp, _Lock_policy __l = __shared_ptr_default_lock_mode>\n+  class __weak_ptr;\n \n-template<typename _Tp>\n-  class enable_shared_from_this;\n+template<typename _Tp, _Lock_policy __l>\n+  class __enable_shared_from_this;\n \n struct __static_cast_tag {};\n struct __const_cast_tag {};\n@@ -457,21 +536,22 @@ template<>\n \n // enable_shared_from_this support\n \n-// friend of enable_shared_from_this\n-template<typename _Tp1, typename _Tp2>\n+// friend of __enable_shared_from_this\n+template<_Lock_policy __l, typename _Tp1, typename _Tp2>\n   void\n-  __enable_shared_from_this(const shared_count& __pn,\n-                            const enable_shared_from_this<_Tp1>* __pe,\n+  __enable_shared_from_this_helper(const shared_count<__l>& __pn,\n+                            const __enable_shared_from_this<_Tp1, __l>* __pe,\n                             const _Tp2* __px );\n \n-inline void\n-__enable_shared_from_this(const shared_count&, ...)\n-{ }\n+template<_Lock_policy __l>\n+  inline void\n+  __enable_shared_from_this_helper(const shared_count<__l>&, ...)\n+  { }\n \n \n // get_deleter must be declared before friend declaration by shared_ptr.\n-template<typename _Del, typename _Tp>\n-  _Del* get_deleter(const shared_ptr<_Tp>&);\n+template<typename _Del, typename _Tp, _Lock_policy __l>\n+  _Del* get_deleter(const __shared_ptr<_Tp, __l>&);\n \n /**\n  *  @class shared_ptr <tr1/memory>\n@@ -480,83 +560,83 @@ template<typename _Del, typename _Tp>\n  *  The object pointed to is deleted when the last shared_ptr pointing to it\n  *  is destroyed or reset.\n  */\n-template<typename _Tp>\n-  class shared_ptr\n+template<typename _Tp, _Lock_policy __l>\n+  class __shared_ptr\n   {\n     typedef typename shared_ptr_traits<_Tp>::reference _Reference;\n \n   public:\n \n     typedef _Tp   element_type;\n \n-    /** @brief  Construct an empty %shared_ptr.\n+    /** @brief  Construct an empty %__shared_ptr.\n      *  @post   use_count()==0 && get()==0\n      */\n-    shared_ptr()\n+    __shared_ptr()\n     : _M_ptr(0), _M_refcount() // never throws\n     { }\n \n-    /** @brief  Construct a %shared_ptr that owns the pointer @a p.\n+    /** @brief  Construct a %__shared_ptr that owns the pointer @a p.\n      *  @param  p  A pointer that is convertible to element_type*.\n      *  @post   use_count() == 1 && get() == p\n      *  @throw  std::bad_alloc, in which case @c delete @a p is called.\n      */\n     template<typename _Tp1>\n-      explicit shared_ptr(_Tp1* __p)\n+      explicit __shared_ptr(_Tp1* __p)\n       : _M_ptr(__p), _M_refcount(__p, _Sp_deleter<_Tp1>())\n       {\n         __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n         // __glibcxx_function_requires(_CompleteConcept<_Tp1*>)\n \n-        __enable_shared_from_this( _M_refcount, __p, __p );\n+        __enable_shared_from_this_helper( _M_refcount, __p, __p );\n       }\n \n     //\n     // Requirements: D's copy constructor and destructor must not throw\n     //\n-    // shared_ptr will release p by calling d(p)\n+    // __shared_ptr will release p by calling d(p)\n     //\n-    /** @brief  Construct a %shared_ptr that owns the pointer @a p\n+    /** @brief  Construct a %__shared_ptr that owns the pointer @a p\n      *          and the deleter @a d.\n      *  @param  p  A pointer.\n      *  @param  d  A deleter.\n      *  @post   use_count() == 1 && get() == p\n      *  @throw  std::bad_alloc, in which case @a d(p) is called.\n      */\n     template<typename _Tp1, typename _Deleter>\n-      shared_ptr(_Tp1* __p, _Deleter __d)\n+      __shared_ptr(_Tp1* __p, _Deleter __d)\n       : _M_ptr(__p), _M_refcount(__p, __d)\n       {\n         __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n         // TODO requires D is CopyConstructible and d(p) well-formed\n \n-        __enable_shared_from_this( _M_refcount, __p, __p );\n+        __enable_shared_from_this_helper( _M_refcount, __p, __p );\n       }\n \n     //  generated copy constructor, assignment, destructor are fine.\n \n-    /** @brief  If @a r is empty, constructs an empty %shared_ptr; otherwise\n-     *          construct a %shared_ptr that shares ownership with @a r.\n-     *  @param  r  A %shared_ptr.\n+    /** @brief  If @a r is empty, constructs an empty %__shared_ptr; otherwise\n+     *          construct a %__shared_ptr that shares ownership with @a r.\n+     *  @param  r  A %__shared_ptr.\n      *  @post   get() == r.get() && use_count() == r.use_count()\n      *  @throw  std::bad_alloc, in which case \n      */\n     template<typename _Tp1>\n-      shared_ptr(const shared_ptr<_Tp1>& __r)\n+      __shared_ptr(const __shared_ptr<_Tp1, __l>& __r)\n       : _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount) // never throws\n       {\n         __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n       }\n \n-    /** @brief  Constructs a %shared_ptr that shares ownership with @a r\n+    /** @brief  Constructs a %__shared_ptr that shares ownership with @a r\n      *          and stores a copy of the pointer stored in @a r.\n      *  @param  r  A weak_ptr.\n      *  @post   use_count() == r.use_count()\n      *  @throw  bad_weak_ptr when r.expired(),\n      *          in which case the constructor has no effect.\n      */\n     template<typename _Tp1>\n-      explicit shared_ptr(const weak_ptr<_Tp1>& __r)\n+      explicit __shared_ptr(const __weak_ptr<_Tp1, __l>& __r)\n       : _M_refcount(__r._M_refcount) // may throw\n       {\n         __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n@@ -569,72 +649,72 @@ template<typename _Tp>\n      * @post use_count() == 1 and r.get() == 0\n      */\n     template<typename _Tp1>\n-      explicit shared_ptr(std::auto_ptr<_Tp1>& __r)\n+      explicit __shared_ptr(std::auto_ptr<_Tp1>& __r)\n       : _M_ptr(__r.get()), _M_refcount()\n       {\n         // TODO requires r.release() convertible to _Tp*, Tp1 is complete,\n         // delete r.release() well-formed\n         _Tp1 * __tmp = __r.get();\n-        _M_refcount = shared_count(__r);\n+        _M_refcount = shared_count<__l>(__r);\n \n-        __enable_shared_from_this( _M_refcount, __tmp, __tmp );\n+        __enable_shared_from_this_helper( _M_refcount, __tmp, __tmp );\n       }\n \n     template<typename _Tp1>\n-      shared_ptr(const shared_ptr<_Tp1>& __r, __static_cast_tag)\n+      __shared_ptr(const __shared_ptr<_Tp1, __l>& __r, __static_cast_tag)\n       : _M_ptr(static_cast<element_type*>(__r._M_ptr)),\n \t_M_refcount(__r._M_refcount)\n       { }\n \n     template<typename _Tp1>\n-      shared_ptr(const shared_ptr<_Tp1>& __r, __const_cast_tag)\n+      __shared_ptr(const __shared_ptr<_Tp1, __l>& __r, __const_cast_tag)\n       : _M_ptr(const_cast<element_type*>(__r._M_ptr)),\n \t_M_refcount(__r._M_refcount)\n       { }\n \n     template<typename _Tp1>\n-      shared_ptr(const shared_ptr<_Tp1>& __r, __dynamic_cast_tag)\n+      __shared_ptr(const __shared_ptr<_Tp1, __l>& __r, __dynamic_cast_tag)\n       : _M_ptr(dynamic_cast<element_type*>(__r._M_ptr)),\n \t_M_refcount(__r._M_refcount)\n       {\n         if (_M_ptr == 0) // need to allocate new counter -- the cast failed\n-          _M_refcount = shared_count();\n+          _M_refcount = shared_count<__l>();\n       }\n \n     template<typename _Tp1>\n-      shared_ptr&\n-      operator=(const shared_ptr<_Tp1>& __r) // never throws\n+      __shared_ptr&\n+      operator=(const __shared_ptr<_Tp1, __l>& __r) // never throws\n       {\n         _M_ptr = __r._M_ptr;\n         _M_refcount = __r._M_refcount; // shared_count::op= doesn't throw\n         return *this;\n       }\n \n     template<typename _Tp1>\n-      shared_ptr&\n+      __shared_ptr&\n       operator=(std::auto_ptr<_Tp1>& __r)\n       {\n-        shared_ptr(__r).swap(*this);\n+        __shared_ptr(__r).swap(*this);\n         return *this;\n       }\n \n     void\n     reset() // never throws\n-    { shared_ptr().swap(*this); }\n+    { __shared_ptr().swap(*this); }\n \n     template<typename _Tp1>\n       void\n       reset(_Tp1* __p) // _Tp1 must be complete\n       {\n         _GLIBCXX_DEBUG_ASSERT(__p == 0 || __p != _M_ptr); // catch self-reset\n \t                                                  // errors\n-        shared_ptr(__p).swap(*this);\n+        __shared_ptr(__p).swap(*this);\n       }\n \n     template<typename _Tp1, typename _Deleter>\n       void\n       reset(_Tp1 * __p, _Deleter __d)\n-      { shared_ptr(__p, __d).swap(*this); }\n+      { __shared_ptr(__p, __d).swap(*this); }\n \n     // error to instantiate if _Tp is [cv-qual] void\n     _Reference\n@@ -657,11 +737,11 @@ template<typename _Tp>\n \n     // implicit conversion to \"bool\"\n   private:\n-    typedef _Tp* shared_ptr::*__unspecified_bool_type;\n+    typedef _Tp* __shared_ptr::*__unspecified_bool_type;\n \n   public:\n     operator __unspecified_bool_type() const // never throws\n-    { return _M_ptr == 0 ? 0 : &shared_ptr::_M_ptr; }\n+    { return _M_ptr == 0 ? 0 : &__shared_ptr::_M_ptr; }\n \n     bool\n     unique() const // never throws\n@@ -672,7 +752,7 @@ template<typename _Tp>\n     { return _M_refcount.use_count(); }\n \n     void\n-    swap(shared_ptr<_Tp>& __other) // never throws\n+    swap(__shared_ptr<_Tp, __l>& __other) // never throws\n     {\n       std::swap(_M_ptr, __other._M_ptr);\n       _M_refcount.swap(__other._M_refcount);\n@@ -683,41 +763,41 @@ template<typename _Tp>\n     _M_get_deleter(const std::type_info& __ti) const\n     { return _M_refcount.get_deleter(__ti); }\n \n-    template<typename _Tp1>\n+    template<typename _Tp1, _Lock_policy __l1>\n       bool\n-      _M_less(const shared_ptr<_Tp1>& __rhs) const\n+      _M_less(const __shared_ptr<_Tp1, __l1>& __rhs) const\n       { return _M_refcount < __rhs._M_refcount; }\n \n-    template<typename _Tp1> friend class shared_ptr;\n-    template<typename _Tp1> friend class weak_ptr;\n+    template<typename _Tp1, _Lock_policy __l1> friend class __shared_ptr;\n+    template<typename _Tp1, _Lock_policy __l1> friend class __weak_ptr;\n \n-    template<typename _Del, typename _Tp1>\n-      friend _Del* get_deleter(const shared_ptr<_Tp1>&);\n+    template<typename _Del, typename _Tp1, _Lock_policy __l1>\n+      friend _Del* get_deleter(const __shared_ptr<_Tp1, __l1>&);\n \n     // friends injected into enclosing namespace and found by ADL:\n     template<typename _Tp1>\n       friend inline bool\n-      operator==(const shared_ptr& __a, const shared_ptr<_Tp1>& __b)\n+      operator==(const __shared_ptr& __a, const __shared_ptr<_Tp1, __l>& __b)\n       { return __a.get() == __b.get(); }\n \n     template<typename _Tp1>\n       friend inline bool\n-      operator!=(const shared_ptr& __a, const shared_ptr<_Tp1>& __b)\n+      operator!=(const __shared_ptr& __a, const __shared_ptr<_Tp1, __l>& __b)\n       { return __a.get() != __b.get(); }\n \n     template<typename _Tp1>\n       friend inline bool\n-      operator<(const shared_ptr& __a, const shared_ptr<_Tp1>& __b)\n+      operator<(const __shared_ptr& __a, const __shared_ptr<_Tp1, __l>& __b)\n       { return __a._M_less(__b); }\n \n     _Tp*         _M_ptr;         // contained pointer\n-    shared_count _M_refcount;    // reference counter\n-  };  // shared_ptr\n+    shared_count<__l> _M_refcount;    // reference counter\n+  };  // __shared_ptr\n \n // 2.2.3.8 shared_ptr specialized algorithms.\n-template<typename _Tp>\n+template<typename _Tp, _Lock_policy __l>\n   inline void\n-  swap(shared_ptr<_Tp>& __a, shared_ptr<_Tp>& __b)\n+  swap(__shared_ptr<_Tp, __l>& __a, __shared_ptr<_Tp, __l>& __b)\n   { __a.swap(__b); }\n \n // 2.2.3.9 shared_ptr casts\n@@ -726,61 +806,61 @@ template<typename _Tp>\n  *           will eventually result in undefined behaviour,\n  *           attempting to delete the same object twice.\n  */\n-template<typename _Tp, typename _Tp1>\n-  shared_ptr<_Tp>\n-  static_pointer_cast(const shared_ptr<_Tp1>& __r)\n+template<typename _Tp, typename _Tp1, _Lock_policy __l>\n+  __shared_ptr<_Tp, __l>\n+  static_pointer_cast(const __shared_ptr<_Tp1, __l>& __r)\n   {\n-    return shared_ptr<_Tp>(__r, __static_cast_tag());\n+    return __shared_ptr<_Tp, __l>(__r, __static_cast_tag());\n   }\n \n /** @warning The seemingly equivalent\n  *           <code>shared_ptr<T>(const_cast<T*>(r.get()))</code>\n  *           will eventually result in undefined behaviour,\n  *           attempting to delete the same object twice.\n  */\n-template<typename _Tp, typename _Tp1>\n-  shared_ptr<_Tp>\n-  const_pointer_cast(const shared_ptr<_Tp1>& __r)\n+template<typename _Tp, typename _Tp1, _Lock_policy __l>\n+  __shared_ptr<_Tp, __l>\n+  const_pointer_cast(const __shared_ptr<_Tp1, __l>& __r)\n   {\n-    return shared_ptr<_Tp>(__r, __const_cast_tag());\n+    return __shared_ptr<_Tp, __l>(__r, __const_cast_tag());\n   }\n \n /** @warning The seemingly equivalent\n  *           <code>shared_ptr<T>(dynamic_cast<T*>(r.get()))</code>\n  *           will eventually result in undefined behaviour,\n  *           attempting to delete the same object twice.\n  */\n-template<typename _Tp, typename _Tp1>\n-  shared_ptr<_Tp>\n-  dynamic_pointer_cast(const shared_ptr<_Tp1>& __r)\n+template<typename _Tp, typename _Tp1, _Lock_policy __l>\n+  __shared_ptr<_Tp, __l>\n+  dynamic_pointer_cast(const __shared_ptr<_Tp1, __l>& __r)\n   {\n-    return shared_ptr<_Tp>(__r, __dynamic_cast_tag());\n+    return __shared_ptr<_Tp, __l>(__r, __dynamic_cast_tag());\n   }\n \n // 2.2.3.7 shared_ptr I/O\n-template<typename _Ch, typename _Tr, typename _Tp>\n+template<typename _Ch, typename _Tr, typename _Tp, _Lock_policy __l>\n   std::basic_ostream<_Ch, _Tr>&\n-  operator<<(std::basic_ostream<_Ch, _Tr>& __os, const shared_ptr<_Tp>& __p)\n+  operator<<(std::basic_ostream<_Ch, _Tr>& __os, const __shared_ptr<_Tp, __l>& __p)\n   {\n     __os << __p.get();\n     return __os;\n   }\n \n // 2.2.3.10 shared_ptr get_deleter (experimental)\n-template<typename _Del, typename _Tp>\n+template<typename _Del, typename _Tp, _Lock_policy __l>\n   inline _Del*\n-  get_deleter(const shared_ptr<_Tp>& __p)\n+  get_deleter(const __shared_ptr<_Tp, __l>& __p)\n   { return static_cast<_Del*>(__p._M_get_deleter(typeid(_Del))); }\n \n \n-template<typename _Tp>\n-  class weak_ptr\n+template<typename _Tp, _Lock_policy __l>\n+  class __weak_ptr\n   {\n   public:\n \n     typedef _Tp element_type;\n \n-    weak_ptr()\n+    __weak_ptr()\n     : _M_ptr(0), _M_refcount() // never throws\n     { }\n \n@@ -790,7 +870,7 @@ template<typename _Tp>\n     //  The \"obvious\" converting constructor implementation:\n     //\n     //  template<class Y>\n-    //    weak_ptr(weak_ptr<Y> const & r)\n+    //    __weak_ptr(__weak_ptr<Y> const & r)\n     //    : _M_ptr(r._M_ptr), _M_refcount(r._M_refcount) // never throws\n     //    { }\n     //\n@@ -804,64 +884,64 @@ template<typename _Tp>\n     //\n \n     template<typename _Tp1>\n-      weak_ptr(const weak_ptr<_Tp1>& r)\n+      __weak_ptr(const __weak_ptr<_Tp1, __l>& r)\n       : _M_refcount(r._M_refcount) // never throws\n       {\n         __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n         _M_ptr = r.lock().get();\n       }\n \n     template<typename _Tp1>\n-      weak_ptr(const shared_ptr<_Tp1>& r)\n+      __weak_ptr(const __shared_ptr<_Tp1, __l>& r)\n       : _M_ptr(r._M_ptr), _M_refcount(r._M_refcount) // never throws\n       {\n         __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n       }\n \n     template<typename _Tp1>\n-      weak_ptr&\n-      operator=(const weak_ptr<_Tp1>& r) // never throws\n+      __weak_ptr&\n+      operator=(const __weak_ptr<_Tp1, __l>& r) // never throws\n       {\n         _M_ptr = r.lock().get();\n         _M_refcount = r._M_refcount;\n         return *this;\n       }\n \n     template<typename _Tp1>\n-      weak_ptr&\n-      operator=(const shared_ptr<_Tp1>& r) // never throws\n+      __weak_ptr&\n+      operator=(const __shared_ptr<_Tp1, __l>& r) // never throws\n       {\n         _M_ptr = r._M_ptr;\n         _M_refcount = r._M_refcount;\n         return *this;\n       }\n \n-    shared_ptr<_Tp>\n+    __shared_ptr<_Tp, __l>\n     lock() const // never throws\n     {\n #ifdef __GTHREADS\n \n       // optimization: avoid throw overhead\n       if (expired())\n-\treturn shared_ptr<element_type>();\n+\treturn __shared_ptr<element_type, __l>();\n       \n       try\n \t{\n-\t  return shared_ptr<element_type>(*this);\n+\t  return __shared_ptr<element_type, __l>(*this);\n \t}\n       catch (const bad_weak_ptr&)\n \t{\n \t  // Q: how can we get here?\n \t  // A: another thread may have invalidated r after the\n \t  //    use_count test above.\n-\t  return shared_ptr<element_type>();\n+\t  return __shared_ptr<element_type>();\n \t}\n \n #else\n \n       // optimization: avoid try/catch overhead when single threaded\n-      return expired() ? shared_ptr<element_type>()\n-\t               : shared_ptr<element_type>(*this);\n+      return expired() ? __shared_ptr<element_type, __l>()\n+\t               : __shared_ptr<element_type, __l>(*this);\n \n #endif\n     } // XXX MT\n@@ -876,10 +956,10 @@ template<typename _Tp>\n \n     void\n     reset() // never throws\n-    { weak_ptr().swap(*this); }\n+    { __weak_ptr().swap(*this); }\n \n     void\n-    swap(weak_ptr& __s) // never throws\n+    swap(__weak_ptr& __s) // never throws\n     {\n       std::swap(_M_ptr, __s._M_ptr);\n       _M_refcount.swap(__s._M_refcount);\n@@ -889,12 +969,12 @@ template<typename _Tp>\n \n     template<typename _Tp1>\n       bool\n-      _M_less(const weak_ptr<_Tp1>& __rhs) const\n+      _M_less(const __weak_ptr<_Tp1, __l>& __rhs) const\n       { return _M_refcount < __rhs._M_refcount; }\n \n     // used by __enable_shared_from_this\n     void\n-    _M_assign(_Tp* __ptr, const shared_count& __refcount)\n+    _M_assign(_Tp* __ptr, const shared_count<__l>& __refcount)\n     {\n       _M_ptr = __ptr;\n       _M_refcount = __refcount;\n@@ -904,76 +984,193 @@ template<typename _Tp>\n \n     template<typename _Tp1>\n       friend inline bool\n-      operator<(const weak_ptr& __lhs, const weak_ptr<_Tp1>& __rhs)\n+      operator<(const __weak_ptr& __lhs, const __weak_ptr<_Tp1, __l>& __rhs)\n       { return __lhs._M_less(__rhs); }\n \n-    template<typename _Tp1> friend class weak_ptr;\n-    template<typename _Tp1> friend class shared_ptr;\n-    friend class enable_shared_from_this<_Tp>;\n+    template<typename _Tp1, _Lock_policy __l1> friend class __weak_ptr;\n+    template<typename _Tp1, _Lock_policy __l1> friend class __shared_ptr;\n+    friend class __enable_shared_from_this<_Tp, __l>;\n \n     _Tp*       _M_ptr;           // contained pointer\n-    weak_count _M_refcount;      // reference counter\n+    weak_count<__l> _M_refcount;      // reference counter\n \n-  };  // weak_ptr\n+  };  // __weak_ptr\n \n // 2.2.4.7 weak_ptr specialized algorithms.\n-template<typename _Tp>\n+template<typename _Tp, _Lock_policy __l>\n   void\n-  swap(weak_ptr<_Tp>& __a, weak_ptr<_Tp>& __b)\n+  swap(__weak_ptr<_Tp, __l>& __a, __weak_ptr<_Tp, __l>& __b)\n   { __a.swap(__b); }\n \n \n-template<typename _Tp>\n-  class enable_shared_from_this\n+template<typename _Tp, _Lock_policy __l = __shared_ptr_default_lock_mode>\n+  class __enable_shared_from_this\n   {\n   protected:\n \n-    enable_shared_from_this()\n+    __enable_shared_from_this()\n     { }\n \n-    enable_shared_from_this(const enable_shared_from_this&)\n+    __enable_shared_from_this(const __enable_shared_from_this&)\n     { }\n \n-    enable_shared_from_this&\n-    operator=(const enable_shared_from_this&)\n+    __enable_shared_from_this&\n+    operator=(const __enable_shared_from_this&)\n     { return *this; }\n \n-    ~enable_shared_from_this()\n+    ~__enable_shared_from_this()\n     { }\n \n   public:\n \n-    shared_ptr<_Tp>\n+    __shared_ptr<_Tp, __l>\n     shared_from_this()\n     {\n-      shared_ptr<_Tp> __p(this->_M_weak_this);\n+      __shared_ptr<_Tp, __l> __p(this->_M_weak_this);\n       return __p;\n     }\n \n-    shared_ptr<const _Tp>\n+    __shared_ptr<const _Tp, __l>\n     shared_from_this() const\n     {\n-      shared_ptr<const _Tp> __p(this->_M_weak_this);\n+      __shared_ptr<const _Tp, __l> __p(this->_M_weak_this);\n       return __p;\n     }\n \n   private:\n     template<typename _Tp1>\n       void\n-      _M_weak_assign(_Tp1* __p, const shared_count& __n) const\n+      _M_weak_assign(_Tp1* __p, const shared_count<__l>& __n) const\n       { _M_weak_this._M_assign(__p, __n); }\n \n     template<typename _Tp1>\n       friend void\n-      __enable_shared_from_this(const shared_count& __pn,\n-\t\t\t\tconst enable_shared_from_this* __pe,\n-\t\t\t\tconst _Tp1* __px)\n+      __enable_shared_from_this_helper(const shared_count<__l>& __pn,\n+\t\t\t\t       const __enable_shared_from_this* __pe,\n+\t\t\t\t       const _Tp1* __px)\n       {\n         if(__pe != 0)\n           __pe->_M_weak_assign(const_cast<_Tp1*>(__px), __pn);\n       }\n \n-    mutable weak_ptr<_Tp> _M_weak_this;\n+    mutable __weak_ptr<_Tp, __l> _M_weak_this;\n+  };\n+\n+template<typename _Tp>\n+  class shared_ptr;\n+\n+// The actual TR1 weak_ptr, with forwarding constructors and assignment operators.\n+template<typename _Tp>\n+  class weak_ptr\n+  : public __weak_ptr<_Tp>\n+  {\n+  public:\n+    weak_ptr()\n+    : __weak_ptr<_Tp>()\n+    { }\n+  \n+    template<typename _Tp1>\n+      weak_ptr(const __weak_ptr<_Tp1>& r)\n+      : __weak_ptr<_Tp>(r)\n+      { }\n+    \n+    template<typename _Tp1>\n+      weak_ptr(const __shared_ptr<_Tp1>& r)\n+      : __weak_ptr<_Tp>(r)\n+      { }\n+    template<typename _Tp1>\n+      weak_ptr&\n+      operator=(const weak_ptr<_Tp1>& r) // never throws\n+      {\n+        this->__weak_ptr<_Tp>::operator=(r);\n+        return *this;\n+      }\n+\n+    template<typename _Tp1>\n+      weak_ptr&\n+      operator=(const shared_ptr<_Tp1>& r) // never throws\n+      {\n+        this->__weak_ptr<_Tp>::operator=(r);\n+        return *this;\n+      }\n+  };\n+\n+// The actual TR1 shared_ptr, with forwarding constructors and assignment operators.\n+template<typename _Tp>\n+  class shared_ptr\n+  : public __shared_ptr<_Tp>\n+  {\n+  public:\n+    shared_ptr()\n+    : __shared_ptr<_Tp>()\n+    { }\n+    \n+    template<typename _Tp1>\n+      explicit shared_ptr(_Tp1* __p)\n+      : __shared_ptr<_Tp>(__p)\n+      { }\n+    \n+    template<typename _Tp1, typename _Deleter>\n+      shared_ptr(_Tp1* __p, _Deleter __d)\n+      : __shared_ptr<_Tp>(__p, __d)\n+      { }\n+    \n+    template<typename _Tp1>\n+      shared_ptr(const __shared_ptr<_Tp1>& __r)\n+      : __shared_ptr<_Tp>(__r)\n+      { }\n+    \n+    template<typename _Tp1>\n+      explicit shared_ptr(const __weak_ptr<_Tp1>& __r)\n+      : __shared_ptr<_Tp>(__r)\n+      { }\n+    \n+    template<typename _Tp1>\n+      explicit shared_ptr(std::auto_ptr<_Tp1>& __r)\n+      : __shared_ptr<_Tp>(__r)\n+      { }\n+    template<typename _Tp1>\n+      shared_ptr(const __shared_ptr<_Tp1>& __r, __static_cast_tag)\n+      : __shared_ptr<_Tp>(__r, __static_cast_tag())\n+      { }\n+    template<typename _Tp1>\n+      shared_ptr(const __shared_ptr<_Tp1>& __r, __const_cast_tag)\n+      : __shared_ptr<_Tp>(__r, __const_cast_tag())\n+      { }\n+    \n+    template<typename _Tp1>\n+      shared_ptr(const __shared_ptr<_Tp1>& __r, __dynamic_cast_tag)\n+      : __shared_ptr<_Tp>(__r, __dynamic_cast_tag())\n+      { }\n+    // Additional non-base assignment operators to avoid excessive errors.\n+    template<typename _Tp1>\n+      shared_ptr&\n+      operator=(std::auto_ptr<_Tp1>& __r)\n+      {\n+        this->__shared_ptr<_Tp>::operator=(__r);\n+        return *this;\n+      }\n+    template<typename _Tp1>\n+      shared_ptr&\n+      operator=(const shared_ptr<_Tp1>& __r) // never throws\n+      {\n+        this->__shared_ptr<_Tp>::operator=(__r);\n+        return *this;\n+      }\n+  };\n+\n+template<typename _Tp>\n+  class enable_shared_from_this\n+  : public __enable_shared_from_this<_Tp>\n+  {\n+  protected:\n+    enable_shared_from_this()\n+    : __enable_shared_from_this<_Tp>()\n+    { }\n+    \n+    enable_shared_from_this(const enable_shared_from_this&)\n+    : __enable_shared_from_this<_Tp>(enable_shared_from_this<_Tp>())\n+    { }\n   };\n \n _GLIBCXX_END_NAMESPACE"}, {"sha": "407cc5b0bf588db365c6262f20ebbe3119dfe6fa", "filename": "libstdc++-v3/testsuite/tr1/2_general_utilities/memory/shared_ptr/assign/shared_ptr_neg.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a25ce4dbf97245d64ec5f32787eebee6beafec76/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fassign%2Fshared_ptr_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a25ce4dbf97245d64ec5f32787eebee6beafec76/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fassign%2Fshared_ptr_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fassign%2Fshared_ptr_neg.cc?ref=a25ce4dbf97245d64ec5f32787eebee6beafec76", "patch": "@@ -49,3 +49,4 @@ main()\n }\n // { dg-error \"In member function\" \"\" { target *-*-* } 0 }\n // { dg-error \"cannot convert\" \"\" { target *-*-* } 0 }\n+// { dg-error \"instantiated from\" \"\" { target *-*-* } 0 }"}, {"sha": "de749004203ef79b01dd26af7817fd9aa6403174", "filename": "libstdc++-v3/testsuite/tr1/2_general_utilities/memory/shared_ptr/thread/lockfree_weaktoshared.cc", "status": "added", "additions": 198, "deletions": 0, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a25ce4dbf97245d64ec5f32787eebee6beafec76/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fthread%2Flockfree_weaktoshared.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a25ce4dbf97245d64ec5f32787eebee6beafec76/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fthread%2Flockfree_weaktoshared.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fthread%2Flockfree_weaktoshared.cc?ref=a25ce4dbf97245d64ec5f32787eebee6beafec76", "patch": "@@ -0,0 +1,198 @@\n+// Copyright (C) 2006 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// TR1 2.2.2 Template class shared_ptr [tr.util.smartptr.shared]\n+\n+// { dg-do run { target *-*-freebsd* *-*-netbsd* *-*-linux* *-*-solaris* *-*-cygwin *-*-darwin* alpha*-*-osf* } }\n+// { dg-options \"-march=i586 -pthread\" { target { {*-*-freebsd* *-*-netbsd* *-*-linux* alpha*-*-osf*} && { *i686*-*-* *i586*-*-* *athlon*-*-* *pentium4*-*-* *opteron*-*-* *k8*-*-* } } } }\n+// { dg-options \"-pthread\" { target { {*-*-freebsd* *-*-netbsd* *-*-linux* alpha*-*-osf*} && { ! { *i686*-*-* *i586*-*-* *athlon*-*-* *pentium4*-*-* *opteron*-*-* *k8*-*-* } } } } }\n+// { dg-options \"-pthreads\" { target *-*-solaris* } }\n+\n+// Lock-free compare-and-swap is only available on newer x86 machines.\n+\n+#include <tr1/memory>\n+#include <tr1/random>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <iostream>\n+\n+#include <pthread.h>\n+\n+#ifdef _GLIBCXX_HAVE_UNISTD_H\n+#include <unistd.h>\t// To test for _POSIX_THREAD_PRIORITY_SCHEDULING\n+#endif\n+\n+/* This (brute-force) tests the atomicity and thus thread safety of the\n+ * shared_ptr <- weak_ptr\n+ * assignment operation by allocating a test object, retrieving a weak\n+ * reference to it, and letting a number of threads repeatedly create strong\n+ * references from the weak reference.\n+ * Specifically, this tests the function _Sp_counted_base<true>::add_ref_lock()\n+ */\n+\n+\n+const unsigned int HAMMER_MAX_THREADS = 10;\n+const unsigned int POOL_SIZE = 1000;\n+const unsigned long HAMMER_REPEAT = 100000;\n+const unsigned long KILL_ONE_IN = 1000;\n+\n+struct A\n+  {\n+    static _Atomic_word counter;\n+    A()\n+      {\n+\t__gnu_cxx::__atomic_add(&counter, 1);\n+      }\n+    ~A()\n+      {\n+\t__gnu_cxx::__atomic_add(&counter, -1);\n+      }\n+  };\n+\n+_Atomic_word A::counter = 0;\n+\n+using std::tr1::_S_lockfree;\n+\n+typedef std::tr1::__shared_ptr<A, _S_lockfree> sp_A_t;\n+typedef std::tr1::__weak_ptr<A, _S_lockfree> wp_A_t;\n+\n+typedef std::vector<sp_A_t> sp_vector_t;\n+typedef std::vector<wp_A_t> wp_vector_t;\n+\n+struct shared_and_weak_pools\n+{\n+  sp_vector_t& shared_pool;\n+  wp_vector_t& weak_pool;\n+  \n+  shared_and_weak_pools(sp_vector_t& _shared_pool, wp_vector_t& _weak_pool)\n+    : shared_pool(_shared_pool), weak_pool(_weak_pool)\n+    { }\n+};\n+\n+void* thread_hammer_and_kill(void* opaque_pools)\n+{\n+  shared_and_weak_pools& pools = *reinterpret_cast<shared_and_weak_pools*>(opaque_pools);\n+  // Using the same parameters as in the RNG test cases.\n+  std::tr1::mersenne_twister<\n+    unsigned long, 32, 624, 397, 31,\n+    0x9908b0dful, 11, 7,\n+    0x9d2c5680ul, 15,\n+    0xefc60000ul, 18> rng;\n+  \n+  sp_vector_t::iterator cur_shared = pools.shared_pool.begin();\n+  wp_vector_t::iterator cur_weak = pools.weak_pool.begin();\n+  \n+  for (unsigned int i = 0; i < HAMMER_REPEAT; ++i)\n+    {\n+      try\n+      {\n+        sp_A_t strong(*cur_weak);\n+      }\n+      catch (std::tr1::bad_weak_ptr& exception)\n+      {\n+        ++cur_weak;\n+        if (cur_weak == pools.weak_pool.end())\n+          break;\n+      }\n+      \n+      if (rng() % KILL_ONE_IN == 0)\n+      {\n+        cur_shared->reset();\n+        ++cur_shared;\n+      }\n+    }\n+  return 0;\n+}\n+\n+void* thread_hammer(void* opaque_weak)\n+{\n+  wp_vector_t& weak_pool = *reinterpret_cast<wp_vector_t*>(opaque_weak);\n+  // Using the same parameters as in the RNG test cases.\n+  std::tr1::mersenne_twister<\n+    unsigned long, 32, 624, 397, 31,\n+    0x9908b0dful, 11, 7,\n+    0x9d2c5680ul, 15,\n+    0xefc60000ul, 18> rng;\n+  wp_vector_t::iterator cur_weak = weak_pool.begin();\n+\n+  for (unsigned int i = 0; i < HAMMER_REPEAT; ++i)\n+    {\n+      try\n+      {\n+        sp_A_t strong(*cur_weak);\n+      }\n+      catch (std::tr1::bad_weak_ptr& exception)\n+      {\n+        ++cur_weak;\n+        if (cur_weak == weak_pool.end())\n+          break;\n+      }\n+    }\n+  return 0;\n+}\n+\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  sp_vector_t obj_pool(POOL_SIZE);\n+  \n+  for(sp_vector_t::iterator cur = obj_pool.begin(); cur != obj_pool.end(); ++cur)\n+  {\n+    cur->reset(new A);\n+  }\n+  // Obtain weak references.\n+  std::vector<wp_vector_t> weak_pool(HAMMER_MAX_THREADS, wp_vector_t(obj_pool.begin(), obj_pool.end()));\n+  \n+  // Launch threads with pointer to weak reference.\n+  pthread_t threads[HAMMER_MAX_THREADS];\n+#if defined(__sun) && defined(__svr4__) && _XOPEN_VERSION >= 500\n+  pthread_setconcurrency (HAMMER_MAX_THREADS);\n+#endif\n+  \n+  pthread_attr_t tattr;\n+  int ret = pthread_attr_init(&tattr);\n+\n+  shared_and_weak_pools pools(obj_pool, weak_pool[0]);\n+  pthread_create(threads, &tattr, thread_hammer_and_kill, reinterpret_cast<void*>(&pools));\n+  for (unsigned int worker = 1; worker < HAMMER_MAX_THREADS; worker++)\n+    {\n+      if (pthread_create(&threads[worker], &tattr,\n+\t\t\t thread_hammer, reinterpret_cast<void*>(&weak_pool[worker])))\n+\tabort();\n+    }\n+  // Wait for threads to complete, then check integrity of reference.\n+  void* status;\n+  for (unsigned int worker = 0; worker < HAMMER_MAX_THREADS; worker++)\n+    {\n+      if (pthread_join(threads[worker], &status))\n+\tabort();\n+    }\n+  obj_pool.clear();\n+  \n+  VERIFY( A::counter == 0 );\n+  \n+  return 0;\n+}\n+\n+int \n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "38fed9136904e96d3289d7c1314e6fa1f7e5dd59", "filename": "libstdc++-v3/testsuite/tr1/2_general_utilities/memory/shared_ptr/thread/mutex_weaktoshared.cc", "status": "added", "additions": 198, "deletions": 0, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a25ce4dbf97245d64ec5f32787eebee6beafec76/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fthread%2Fmutex_weaktoshared.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a25ce4dbf97245d64ec5f32787eebee6beafec76/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fthread%2Fmutex_weaktoshared.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fthread%2Fmutex_weaktoshared.cc?ref=a25ce4dbf97245d64ec5f32787eebee6beafec76", "patch": "@@ -0,0 +1,198 @@\n+// Copyright (C) 2006 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// TR1 2.2.2 Template class shared_ptr [tr.util.smartptr.shared]\n+\n+// { dg-do run { target *-*-freebsd* *-*-netbsd* *-*-linux* *-*-solaris* *-*-cygwin *-*-darwin* alpha*-*-osf* } }\n+// { dg-options \"-march=i586 -pthread\" { target { {*-*-freebsd* *-*-netbsd* *-*-linux* alpha*-*-osf*} && { *i686*-*-* *i586*-*-* *athlon*-*-* *pentium4*-*-* *opteron*-*-* *k8*-*-* } } } }\n+// { dg-options \"-pthread\" { target { {*-*-freebsd* *-*-netbsd* *-*-linux* alpha*-*-osf*} && { ! { *i686*-*-* *i586*-*-* *athlon*-*-* *pentium4*-*-* *opteron*-*-* *k8*-*-* } } } } }\n+// { dg-options \"-pthreads\" { target *-*-solaris* } }\n+\n+// Lock-free compare-and-swap is only available on newer x86 machines.\n+\n+#include <tr1/memory>\n+#include <tr1/random>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <iostream>\n+\n+#include <pthread.h>\n+\n+#ifdef _GLIBCXX_HAVE_UNISTD_H\n+#include <unistd.h>\t// To test for _POSIX_THREAD_PRIORITY_SCHEDULING\n+#endif\n+\n+/* This (brute-force) tests the atomicity and thus thread safety of the\n+ * shared_ptr <- weak_ptr\n+ * assignment operation by allocating a test object, retrieving a weak\n+ * reference to it, and letting a number of threads repeatedly create strong\n+ * references from the weak reference.\n+ * Specifically, this tests the function _Sp_counted_base<true>::add_ref_lock()\n+ */\n+\n+\n+const unsigned int HAMMER_MAX_THREADS = 10;\n+const unsigned int POOL_SIZE = 1000;\n+const unsigned long HAMMER_REPEAT = 100000;\n+const unsigned long KILL_ONE_IN = 1000;\n+\n+struct A\n+  {\n+    static _Atomic_word counter;\n+    A()\n+      {\n+\t__gnu_cxx::__atomic_add(&counter, 1);\n+      }\n+    ~A()\n+      {\n+\t__gnu_cxx::__atomic_add(&counter, -1);\n+      }\n+  };\n+\n+_Atomic_word A::counter = 0;\n+\n+using std::tr1::_S_mutex;\n+\n+typedef std::tr1::__shared_ptr<A, _S_mutex> sp_A_t;\n+typedef std::tr1::__weak_ptr<A, _S_mutex> wp_A_t;\n+\n+typedef std::vector<sp_A_t> sp_vector_t;\n+typedef std::vector<wp_A_t> wp_vector_t;\n+\n+struct shared_and_weak_pools\n+{\n+  sp_vector_t& shared_pool;\n+  wp_vector_t& weak_pool;\n+  \n+  shared_and_weak_pools(sp_vector_t& _shared_pool, wp_vector_t& _weak_pool)\n+    : shared_pool(_shared_pool), weak_pool(_weak_pool)\n+    { }\n+};\n+\n+void* thread_hammer_and_kill(void* opaque_pools)\n+{\n+  shared_and_weak_pools& pools = *reinterpret_cast<shared_and_weak_pools*>(opaque_pools);\n+  // Using the same parameters as in the RNG test cases.\n+  std::tr1::mersenne_twister<\n+    unsigned long, 32, 624, 397, 31,\n+    0x9908b0dful, 11, 7,\n+    0x9d2c5680ul, 15,\n+    0xefc60000ul, 18> rng;\n+  \n+  sp_vector_t::iterator cur_shared = pools.shared_pool.begin();\n+  wp_vector_t::iterator cur_weak = pools.weak_pool.begin();\n+  \n+  for (unsigned int i = 0; i < HAMMER_REPEAT; ++i)\n+    {\n+      try\n+      {\n+        sp_A_t strong(*cur_weak);\n+      }\n+      catch (std::tr1::bad_weak_ptr& exception)\n+      {\n+        ++cur_weak;\n+        if (cur_weak == pools.weak_pool.end())\n+          break;\n+      }\n+      \n+      if (rng() % KILL_ONE_IN == 0)\n+      {\n+        cur_shared->reset();\n+        ++cur_shared;\n+      }\n+    }\n+  return 0;\n+}\n+\n+void* thread_hammer(void* opaque_weak)\n+{\n+  wp_vector_t& weak_pool = *reinterpret_cast<wp_vector_t*>(opaque_weak);\n+  // Using the same parameters as in the RNG test cases.\n+  std::tr1::mersenne_twister<\n+    unsigned long, 32, 624, 397, 31,\n+    0x9908b0dful, 11, 7,\n+    0x9d2c5680ul, 15,\n+    0xefc60000ul, 18> rng;\n+  wp_vector_t::iterator cur_weak = weak_pool.begin();\n+\n+  for (unsigned int i = 0; i < HAMMER_REPEAT; ++i)\n+    {\n+      try\n+      {\n+        sp_A_t strong(*cur_weak);\n+      }\n+      catch (std::tr1::bad_weak_ptr& exception)\n+      {\n+        ++cur_weak;\n+        if (cur_weak == weak_pool.end())\n+          break;\n+      }\n+    }\n+  return 0;\n+}\n+\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  sp_vector_t obj_pool(POOL_SIZE);\n+  \n+  for(sp_vector_t::iterator cur = obj_pool.begin(); cur != obj_pool.end(); ++cur)\n+  {\n+    cur->reset(new A);\n+  }\n+  // Obtain weak references.\n+  std::vector<wp_vector_t> weak_pool(HAMMER_MAX_THREADS, wp_vector_t(obj_pool.begin(), obj_pool.end()));\n+  \n+  // Launch threads with pointer to weak reference.\n+  pthread_t threads[HAMMER_MAX_THREADS];\n+#if defined(__sun) && defined(__svr4__) && _XOPEN_VERSION >= 500\n+  pthread_setconcurrency (HAMMER_MAX_THREADS);\n+#endif\n+  \n+  pthread_attr_t tattr;\n+  int ret = pthread_attr_init(&tattr);\n+\n+  shared_and_weak_pools pools(obj_pool, weak_pool[0]);\n+  pthread_create(threads, &tattr, thread_hammer_and_kill, reinterpret_cast<void*>(&pools));\n+  for (unsigned int worker = 1; worker < HAMMER_MAX_THREADS; worker++)\n+    {\n+      if (pthread_create(&threads[worker], &tattr,\n+\t\t\t thread_hammer, reinterpret_cast<void*>(&weak_pool[worker])))\n+\tabort();\n+    }\n+  // Wait for threads to complete, then check integrity of reference.\n+  void* status;\n+  for (unsigned int worker = 0; worker < HAMMER_MAX_THREADS; worker++)\n+    {\n+      if (pthread_join(threads[worker], &status))\n+\tabort();\n+    }\n+  obj_pool.clear();\n+  \n+  VERIFY( A::counter == 0 );\n+  \n+  return 0;\n+}\n+\n+int \n+main()\n+{\n+  test01();\n+  return 0;\n+}"}]}