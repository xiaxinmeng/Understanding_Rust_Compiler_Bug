{"sha": "cac01ae32bfe8b2a0c868e454a3105f818745eb0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2FjMDFhZTMyYmZlOGIyYTBjODY4ZTQ1NGEzMTA1ZjgxODc0NWViMA==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2006-10-31T18:01:28Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-10-31T18:01:28Z"}, "message": "layout.adb (Layout_Record_Type): Deal with non-static subtypes of variant records\n\n2006-10-31  Robert Dewar  <dewar@adacore.com>\n\n        * layout.adb (Layout_Record_Type): Deal with non-static subtypes of\n        variant records\n        (Layout_Variant_Record): Retrieve the discriminants from the entity\n\trather than from the type definition, because in the case of a full\n\ttype for a private type we need to take the discriminants from the\n\tpartial view.\n        (Layout_Component_List): When applying the Max operator to variants with\n        a nonstatic size, check whether either operand is static and scale that\n        operand from bits to storage units before applying Max.\n\t(Layout_Type): In VMS, if a C-convention access type has no explicit\n\tsize clause (and does not inherit one in the case of a derived type),\n\tthen the size is reset to 32 from 64.\n\nFrom-SVN: r118283", "tree": {"sha": "d1570e776b06742e3b57c6e0e7ceb94a384bca91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d1570e776b06742e3b57c6e0e7ceb94a384bca91"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cac01ae32bfe8b2a0c868e454a3105f818745eb0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cac01ae32bfe8b2a0c868e454a3105f818745eb0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cac01ae32bfe8b2a0c868e454a3105f818745eb0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cac01ae32bfe8b2a0c868e454a3105f818745eb0/comments", "author": null, "committer": null, "parents": [{"sha": "2d6a1685fa6007072522a8531e204ca118854f5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d6a1685fa6007072522a8531e204ca118854f5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d6a1685fa6007072522a8531e204ca118854f5b"}], "stats": {"total": 181, "additions": 123, "deletions": 58}, "files": [{"sha": "b5b1ef97e53430f79680486a6686c24241803ea9", "filename": "gcc/ada/layout.adb", "status": "modified", "additions": 123, "deletions": 58, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cac01ae32bfe8b2a0c868e454a3105f818745eb0/gcc%2Fada%2Flayout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cac01ae32bfe8b2a0c868e454a3105f818745eb0/gcc%2Fada%2Flayout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flayout.adb?ref=cac01ae32bfe8b2a0c868e454a3105f818745eb0", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2001-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2001-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -78,26 +78,23 @@ package body Layout is\n    function Assoc_Add\n      (Loc        : Source_Ptr;\n       Left_Opnd  : Node_Id;\n-      Right_Opnd : Node_Id)\n-      return       Node_Id;\n+      Right_Opnd : Node_Id) return Node_Id;\n    --  This is like Make_Op_Add except that it optimizes some cases knowing\n    --  that associative rearrangement is allowed for constant folding if one\n    --  of the operands is a compile time known value.\n \n    function Assoc_Multiply\n      (Loc        : Source_Ptr;\n       Left_Opnd  : Node_Id;\n-      Right_Opnd : Node_Id)\n-      return       Node_Id;\n+      Right_Opnd : Node_Id) return Node_Id;\n    --  This is like Make_Op_Multiply except that it optimizes some cases\n    --  knowing that associative rearrangement is allowed for constant\n    --  folding if one of the operands is a compile time known value\n \n    function Assoc_Subtract\n      (Loc        : Source_Ptr;\n       Left_Opnd  : Node_Id;\n-      Right_Opnd : Node_Id)\n-      return       Node_Id;\n+      Right_Opnd : Node_Id) return Node_Id;\n    --  This is like Make_Op_Subtract except that it optimizes some cases\n    --  knowing that associative rearrangement is allowed for constant\n    --  folding if one of the operands is a compile time known value\n@@ -119,8 +116,7 @@ package body Layout is\n    function Expr_From_SO_Ref\n      (Loc  : Source_Ptr;\n       D    : SO_Ref;\n-      Comp : Entity_Id := Empty)\n-      return Node_Id;\n+      Comp : Entity_Id := Empty) return Node_Id;\n    --  Given a value D from a size or offset field, return an expression\n    --  representing the value stored. If the value is known at compile time,\n    --  then an N_Integer_Literal is returned with the appropriate value. If\n@@ -137,8 +133,7 @@ package body Layout is\n      (Expr      : Node_Id;\n       Ins_Type  : Entity_Id;\n       Vtype     : Entity_Id := Empty;\n-      Make_Func : Boolean   := False)\n-      return      Dynamic_SO_Ref;\n+      Make_Func : Boolean   := False) return Dynamic_SO_Ref;\n    --  This routine is used in the case where a size/offset value is dynamic\n    --  and is represented by the expression Expr. SO_Ref_From_Expr checks if\n    --  the Expr contains a reference to the identifier V, and if so builds\n@@ -307,8 +302,7 @@ package body Layout is\n    function Assoc_Add\n      (Loc        : Source_Ptr;\n       Left_Opnd  : Node_Id;\n-      Right_Opnd : Node_Id)\n-      return       Node_Id\n+      Right_Opnd : Node_Id) return Node_Id\n    is\n       L : Node_Id;\n       R : Uint;\n@@ -387,8 +381,7 @@ package body Layout is\n    function Assoc_Multiply\n      (Loc        : Source_Ptr;\n       Left_Opnd  : Node_Id;\n-      Right_Opnd : Node_Id)\n-      return       Node_Id\n+      Right_Opnd : Node_Id) return Node_Id\n    is\n       L : Node_Id;\n       R : Uint;\n@@ -446,8 +439,7 @@ package body Layout is\n    function Assoc_Subtract\n      (Loc        : Source_Ptr;\n       Left_Opnd  : Node_Id;\n-      Right_Opnd : Node_Id)\n-      return       Node_Id\n+      Right_Opnd : Node_Id) return Node_Id\n    is\n       L : Node_Id;\n       R : Uint;\n@@ -610,8 +602,7 @@ package body Layout is\n    function Expr_From_SO_Ref\n      (Loc  : Source_Ptr;\n       D    : SO_Ref;\n-      Comp : Entity_Id := Empty)\n-      return Node_Id\n+      Comp : Entity_Id := Empty) return Node_Id\n    is\n       Ent : Entity_Id;\n \n@@ -1590,12 +1581,36 @@ package body Layout is\n \n       procedure Layout_Component (Comp : Entity_Id; Prev_Comp : Entity_Id) is\n          Ctyp  : constant Entity_Id := Etype (Comp);\n+         ORC   : constant Entity_Id := Original_Record_Component (Comp);\n          Npos  : SO_Ref;\n          Fbit  : SO_Ref;\n          NPMax : SO_Ref;\n          Forc  : Boolean;\n \n       begin\n+         --  Increase alignment of record if necessary. Note that we do not\n+         --  do this for packed records, which have an alignment of one by\n+         --  default, or for records for which an explicit alignment was\n+         --  specified with an alignment clause.\n+\n+         if not Is_Packed (E)\n+           and then not Has_Alignment_Clause (E)\n+           and then Alignment (Ctyp) > Alignment (E)\n+         then\n+            Set_Alignment (E, Alignment (Ctyp));\n+         end if;\n+\n+         --  If original component set, then use same layout\n+\n+         if Present (ORC) and then ORC /= Comp then\n+            Set_Normalized_Position     (Comp, Normalized_Position     (ORC));\n+            Set_Normalized_First_Bit    (Comp, Normalized_First_Bit    (ORC));\n+            Set_Normalized_Position_Max (Comp, Normalized_Position_Max (ORC));\n+            Set_Component_Bit_Offset    (Comp, Component_Bit_Offset    (ORC));\n+            Set_Esize                   (Comp, Esize                   (ORC));\n+            return;\n+         end if;\n+\n          --  Parent field is always at start of record, this will overlap\n          --  the actual fields that are part of the parent, and that's fine\n \n@@ -1618,18 +1633,6 @@ package body Layout is\n             Layout_Type (Ctyp);\n          end if;\n \n-         --  Increase alignment of record if necessary. Note that we do not\n-         --  do this for packed records, which have an alignment of one by\n-         --  default, or for records for which an explicit alignment was\n-         --  specified with an alignment clause.\n-\n-         if not Is_Packed (E)\n-           and then not Has_Alignment_Clause (E)\n-           and then Alignment (Ctyp) > Alignment (E)\n-         then\n-            Set_Alignment (E, Alignment (Ctyp));\n-         end if;\n-\n          --  If component already laid out, then we are done\n \n          if Known_Normalized_Position (Comp) then\n@@ -1764,10 +1767,33 @@ package body Layout is\n             Esiz := Uint_0;\n             RM_Siz := Uint_0;\n \n+            --  If record subtype with non-static discriminants, then we don't\n+            --  know which variant will be the one which gets chosen. We don't\n+            --  just want to set the maximum size from the base, because the\n+            --  size should depend on the particular variant.\n+\n+            --  What we do is to use the RM_Size of the base type, which has\n+            --  the necessary conditional computation of the size, using the\n+            --  size information for the particular variant chosen. Records\n+            --  with default discriminants for example have an Esize that is\n+            --  set to the maximum of all variants, but that's not what we\n+            --  want for a constrained subtype.\n+\n+         elsif Ekind (E) = E_Record_Subtype\n+           and then not Has_Static_Discriminants (E)\n+         then\n+            declare\n+               BT : constant Node_Id := Base_Type (E);\n+            begin\n+               Esiz   := RM_Size (BT);\n+               RM_Siz := RM_Size (BT);\n+               Set_Alignment (E, Alignment (BT));\n+            end;\n+\n          else\n-            --  First the object size, for which we align past the last\n-            --  field to the alignment of the record (the object size\n-            --  is required to be a multiple of the alignment).\n+            --  First the object size, for which we align past the last field\n+            --  to the alignment of the record (the object size is required to\n+            --  be a multiple of the alignment).\n \n             Get_Next_Component_Location\n               (Prev_Comp,\n@@ -1778,10 +1804,10 @@ package body Layout is\n                Force_SU => True);\n \n             --  If the resulting normalized position is a dynamic reference,\n-            --  then the size is dynamic, and is stored in storage units.\n-            --  In this case, we set the RM_Size to the same value, it is\n-            --  simply not worth distinguishing Esize and RM_Size values in\n-            --  the dynamic case, since the RM has nothing to say about them.\n+            --  then the size is dynamic, and is stored in storage units. In\n+            --  this case, we set the RM_Size to the same value, it is simply\n+            --  not worth distinguishing Esize and RM_Size values in the\n+            --  dynamic case, since the RM has nothing to say about them.\n \n             --  Note that a size cannot have been given in this case, since\n             --  size specifications cannot be given for variable length types.\n@@ -1793,20 +1819,20 @@ package body Layout is\n                if Is_Dynamic_SO_Ref (End_Npos) then\n                   RM_Siz := End_Npos;\n \n-                  --  Set the Object_Size allowing for alignment. In the\n-                  --  dynamic case, we have to actually do the runtime\n-                  --  computation. We can skip this in the non-packed\n-                  --  record case if the last component has a smaller\n-                  --  alignment than the overall record alignment.\n+                  --  Set the Object_Size allowing for the alignment. In the\n+                  --  dynamic case, we must do the actual runtime computation.\n+                  --  We can skip this in the non-packed record case if the\n+                  --  last component has a smaller alignment than the overall\n+                  --  record alignment.\n \n                   if Is_Dynamic_SO_Ref (End_NPMax) then\n                      Esiz := End_NPMax;\n \n                      if Is_Packed (E)\n                        or else Alignment (Etype (Prev_Comp)) < Align\n                      then\n-                        --  The expression we build is\n-                        --  (expr + align - 1) / align * align\n+                        --  The expression we build is:\n+                        --    (expr + align - 1) / align * align\n \n                         Esiz :=\n                           SO_Ref_From_Expr\n@@ -1844,7 +1870,7 @@ package body Layout is\n                   --  accordingly. We also adjust the size to match the\n                   --  alignment here.\n \n-                  Esiz  := (End_NPMax + Align - 1) / Align * Align * SSU;\n+                  Esiz := (End_NPMax + Align - 1) / Align * Align * SSU;\n \n                   --  Compute the resulting Value_Size (RM_Size). For this\n                   --  purpose we do not force alignment of the record or\n@@ -1872,7 +1898,6 @@ package body Layout is\n       procedure Layout_Non_Variant_Record is\n          Esiz   : SO_Ref;\n          RM_Siz : SO_Ref;\n-\n       begin\n          Layout_Components (First_Entity (E), Last_Entity (E), Esiz, RM_Siz);\n          Set_Esize   (E, Esiz);\n@@ -1884,10 +1909,11 @@ package body Layout is\n       ---------------------------\n \n       procedure Layout_Variant_Record is\n-         Tdef   : constant Node_Id := Type_Definition (Decl);\n-         Dlist  : constant List_Id := Discriminant_Specifications (Decl);\n-         Esiz   : SO_Ref;\n-         RM_Siz : SO_Ref;\n+         Tdef        : constant Node_Id := Type_Definition (Decl);\n+         First_Discr : Entity_Id;\n+         Last_Discr  : Entity_Id;\n+         Esiz        : SO_Ref;\n+         RM_Siz      : SO_Ref;\n \n          RM_Siz_Expr : Node_Id := Empty;\n          --  Expression for the evolving RM_Siz value. This is typically a\n@@ -1953,7 +1979,7 @@ package body Layout is\n                if Is_Static_SO_Ref (RM_Siz) then\n                   RM_Siz_Expr :=\n                     Make_Integer_Literal (Loc,\n-                      Intval => RM_Siz);\n+                                          Intval => RM_Siz);\n \n                else\n                   RMS_Ent := Get_Dynamic_SO_Entity (RM_Siz);\n@@ -2019,8 +2045,19 @@ package body Layout is\n \n                      --  If either value is dynamic, then we have to generate\n                      --  an appropriate Standard_Unsigned'Max attribute call.\n+                     --  If one of the values is static then it needs to be\n+                     --  converted from bits to storage units to be compatible\n+                     --  with the dynamic value.\n \n                      else\n+                        if Is_Static_SO_Ref (Esiz) then\n+                           Esiz := (Esiz + SSU - 1) / SSU;\n+                        end if;\n+\n+                        if Is_Static_SO_Ref (EsizV) then\n+                           EsizV := (EsizV + SSU - 1) / SSU;\n+                        end if;\n+\n                         Esiz :=\n                           SO_Ref_From_Expr\n                             (Make_Attribute_Reference (Loc,\n@@ -2140,17 +2177,23 @@ package body Layout is\n \n          --  Lay out the discriminants\n \n+         First_Discr := First_Discriminant (E);\n+         Last_Discr  := First_Discr;\n+         while Present (Next_Discriminant (Last_Discr)) loop\n+            Next_Discriminant (Last_Discr);\n+         end loop;\n+\n          Layout_Components\n-           (From   => Defining_Identifier (First (Dlist)),\n-            To     => Defining_Identifier (Last  (Dlist)),\n+           (From   => First_Discr,\n+            To     => Last_Discr,\n             Esiz   => Esiz,\n             RM_Siz => RM_Siz);\n \n          --  Lay out the main component list (this will make recursive calls\n          --  to lay out all component lists nested within variants).\n \n          Layout_Component_List (Component_List (Tdef), Esiz, RM_Siz_Expr);\n-         Set_Esize   (E, Esiz);\n+         Set_Esize (E, Esiz);\n \n          --  If the RM_Size is a literal, set its value\n \n@@ -2176,7 +2219,8 @@ package body Layout is\n       --  components themselves are all shared.\n \n       if (Ekind (E) = E_Record_Subtype\n-           or else Ekind (E) = E_Class_Wide_Subtype)\n+            or else\n+          Ekind (E) = E_Class_Wide_Subtype)\n         and then Present (Cloned_Subtype (E))\n       then\n          Set_Esize     (E, Esize     (Cloned_Subtype (E)));\n@@ -2342,6 +2386,28 @@ package body Layout is\n             end;\n          end if;\n \n+         --  On VMS, reset size to 32 for convention C access type if no\n+         --  explicit size clause is given and the default size is 64. Really\n+         --  we do not know the size, since depending on options for the VMS\n+         --  compiler, the size of a pointer type can be 32 or 64, but choosing\n+         --  32 as the default improves compatibility with legacy VMS code.\n+\n+         --  Note: we do not use Has_Size_Clause in the test below, because we\n+         --  want to catch the case of a derived type inheriting a size clause.\n+         --  We want to consider this to be an explicit size clause for this\n+         --  purpose, since it would be weird not to inherit the size in this\n+         --  case.\n+\n+         if OpenVMS_On_Target\n+           and then (Convention (E) = Convention_C\n+                      or else\n+                     Convention (E) = Convention_CPP)\n+           and then No (Get_Attribute_Definition_Clause (E, Attribute_Size))\n+           and then Esize (E) = 64\n+         then\n+            Init_Size (E, 32);\n+         end if;\n+\n          Set_Elem_Alignment (E);\n \n       --  Scalar types: set size and alignment\n@@ -2936,8 +3002,7 @@ package body Layout is\n      (Expr      : Node_Id;\n       Ins_Type  : Entity_Id;\n       Vtype     : Entity_Id := Empty;\n-      Make_Func : Boolean   := False)\n-      return      Dynamic_SO_Ref\n+      Make_Func : Boolean   := False) return Dynamic_SO_Ref\n    is\n       Loc  : constant Source_Ptr := Sloc (Ins_Type);\n "}]}