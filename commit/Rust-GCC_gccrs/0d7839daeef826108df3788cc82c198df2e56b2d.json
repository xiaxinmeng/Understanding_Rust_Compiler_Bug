{"sha": "0d7839daeef826108df3788cc82c198df2e56b2d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGQ3ODM5ZGFlZWY4MjYxMDhkZjM3ODhjYzgyYzE5OGRmMmU1NmIyZA==", "commit": {"author": {"name": "Steve Ellcey", "email": "sje@cup.hp.com", "date": "2001-12-11T23:04:36Z"}, "committer": {"name": "Janis Johnson", "email": "janis@gcc.gnu.org", "date": "2001-12-11T23:04:36Z"}, "message": "tm.texi (FUNCTION_ARG_REG_LITTLE_ENDIAN): New.\n\n2001-12-11  Steve Ellcey  <sje@cup.hp.com>\n\n\t* doc/tm.texi (FUNCTION_ARG_REG_LITTLE_ENDIAN): New.\n\t* defaults.h (FUNCTION_ARG_REG_LITTLE_ENDIAN): New.\n\t* calls.c (store_unaligned_arguments_into_pseudos): Check\n\tFUNCTION_ARG_REG_LITTLE_ENDIAN to see how structures\n\tare passed/returned.\n\t* expr.c (move_block_from_reg): Ditto.\n\t(move_block_from_reg): Ditto.\n\t(copy_blkmode_from_reg): Ditto.\n\t* stmt.c (expand_return): Ditto.\n\t* stor-layout.c (compute_record_mode): If\n\tFUNCTION_ARG_REG_LITTLE_ENDIAN is set then check\n\tMEMBER_TYPE_FORCES_BLK even if mode == VOIDmode.\n\t* config/ia64/hpux.h (MEMBER_TYPE_FORCES_BLK): Set to true\n\tso that Structures of one field are still treated as structures.\n\t(FUNCTION_ARG_REG_LITTLE_ENDIAN): New, set it to true.\n\t(FUNCTION_ARG_PADDING): Set to ia64_hpux_function_arg_padding().\n\t(PAD_VARARGS_DOWN): Modify from default to not pad structures down.\n\t* config/ia64/ia64-protos.h (ia64_hpux_function_arg_padding): New.\n\t* config/ia64/ia64.c (ia64_hpux_function_arg_padding): New function\n\tto special case handling of structure padding.\n\nFrom-SVN: r47904", "tree": {"sha": "204c988a001cb54478276500f93ea95df61d9865", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/204c988a001cb54478276500f93ea95df61d9865"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0d7839daeef826108df3788cc82c198df2e56b2d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d7839daeef826108df3788cc82c198df2e56b2d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d7839daeef826108df3788cc82c198df2e56b2d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d7839daeef826108df3788cc82c198df2e56b2d/comments", "author": null, "committer": null, "parents": [{"sha": "81deb0a3e6fc4528d84b11356a470c4054b171a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81deb0a3e6fc4528d84b11356a470c4054b171a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81deb0a3e6fc4528d84b11356a470c4054b171a1"}], "stats": {"total": 138, "additions": 131, "deletions": 7}, "files": [{"sha": "919f9559a087c26481a9e169180f7c353e975b4f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d7839daeef826108df3788cc82c198df2e56b2d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d7839daeef826108df3788cc82c198df2e56b2d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0d7839daeef826108df3788cc82c198df2e56b2d", "patch": "@@ -1,3 +1,26 @@\n+2001-12-11  Steve Ellcey  <sje@cup.hp.com>\n+\n+\t* doc/tm.texi (FUNCTION_ARG_REG_LITTLE_ENDIAN): New.\n+\t* defaults.h (FUNCTION_ARG_REG_LITTLE_ENDIAN): New.\n+\t* calls.c (store_unaligned_arguments_into_pseudos): Check\n+\tFUNCTION_ARG_REG_LITTLE_ENDIAN to see how structures\n+\tare passed/returned.\n+\t* expr.c (move_block_from_reg): Ditto.\n+\t(move_block_from_reg): Ditto.\n+\t(copy_blkmode_from_reg): Ditto.\n+\t* stmt.c (expand_return): Ditto.\n+\t* stor-layout.c (compute_record_mode): If\n+\tFUNCTION_ARG_REG_LITTLE_ENDIAN is set then check \n+\tMEMBER_TYPE_FORCES_BLK even if mode == VOIDmode.\n+\t* config/ia64/hpux.h (MEMBER_TYPE_FORCES_BLK): Set to true\n+\tso that Structures of one field are still treated as structures.\n+\t(FUNCTION_ARG_REG_LITTLE_ENDIAN): New, set it to true.\n+\t(FUNCTION_ARG_PADDING): Set to ia64_hpux_function_arg_padding().\n+\t(PAD_VARARGS_DOWN): Modify from default to not pad structures down.\n+\t* config/ia64/ia64-protos.h (ia64_hpux_function_arg_padding): New.\n+\t* config/ia64/ia64.c (ia64_hpux_function_arg_padding): New function\n+\tto special case handling of structure padding.\n+\n 2001-12-11  Daniel Berlin  <dan@cgsoftware.com>\n \n \t* sched-rgn.c (CONST_BASED_ADDRESS_P): CONST_INT -> CONSTANT_P."}, {"sha": "c7f5d994cabc06b1f5036758f4a51f3d8211404d", "filename": "gcc/calls.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d7839daeef826108df3788cc82c198df2e56b2d/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d7839daeef826108df3788cc82c198df2e56b2d/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=0d7839daeef826108df3788cc82c198df2e56b2d", "patch": "@@ -1029,7 +1029,9 @@ store_unaligned_arguments_into_pseudos (args, num_actuals)\n \t   significant byte (to the right).  On a BYTES_BIG_ENDIAN machine,\n \t   this means we must skip the empty high order bytes when\n \t   calculating the bit offset.  */\n-\tif (BYTES_BIG_ENDIAN && bytes < UNITS_PER_WORD)\n+\tif (BYTES_BIG_ENDIAN\n+\t    && !FUNCTION_ARG_REG_LITTLE_ENDIAN\n+\t    && bytes < UNITS_PER_WORD)\n \t  big_endian_correction = (BITS_PER_WORD  - (bytes * BITS_PER_UNIT));\n \n \tfor (j = 0; j < args[i].n_aligned_regs; j++)"}, {"sha": "89b2902bf85665810506ea916aee70e5b4bd1ddb", "filename": "gcc/config/ia64/hpux.h", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d7839daeef826108df3788cc82c198df2e56b2d/gcc%2Fconfig%2Fia64%2Fhpux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d7839daeef826108df3788cc82c198df2e56b2d/gcc%2Fconfig%2Fia64%2Fhpux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fhpux.h?ref=0d7839daeef826108df3788cc82c198df2e56b2d", "patch": "@@ -95,3 +95,30 @@ Boston, MA 02111-1307, USA.  */\n \n #undef TARGET_DEFAULT\n #define TARGET_DEFAULT (MASK_DWARF2_ASM | MASK_BIG_ENDIAN)\n+\n+/* This needs to be set to force structure arguments with a single\n+   field to be treated as structures and not as the type of their\n+   field.  Without this a structure with a single char will be\n+   returned just like a char variable and that is wrong on HP-UX\n+   IA64.  TARGET_STRUCT_ARG_REG_LITTLE_ENDIAN triggers the special\n+   structure handling, this macro simply ensures that single field\n+   structures are always treated like structures.  */\n+\n+#define MEMBER_TYPE_FORCES_BLK(FIELD) 1\n+\n+/* Override the setting of FUNCTION_ARG_REG_LITTLE_ENDIAN in\n+   defaults.h.  Setting this to true means that we are not passing\n+   structures in registers in the \"normal\" big-endian way.  See\n+   See section 8.5 of the \"Itanium Software Conventions and Runtime\n+   Architecture\", specifically Table 8-1 and the explanation of Byte 0\n+   alignment and LSB alignment and a description of how structures\n+   are passed.  */\n+\n+#define FUNCTION_ARG_REG_LITTLE_ENDIAN 1\n+\n+#undef FUNCTION_ARG_PADDING\n+#define FUNCTION_ARG_PADDING(MODE, TYPE) \\\n+\tia64_hpux_function_arg_padding ((MODE), (TYPE))\n+\n+#undef PAD_VARARGS_DOWN\n+#define PAD_VARARGS_DOWN (!AGGREGATE_TYPE_P (type))"}, {"sha": "c543a538c5ffcd4875390a06a55c6b7fff91398d", "filename": "gcc/config/ia64/ia64-protos.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d7839daeef826108df3788cc82c198df2e56b2d/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d7839daeef826108df3788cc82c198df2e56b2d/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64-protos.h?ref=0d7839daeef826108df3788cc82c198df2e56b2d", "patch": "@@ -134,3 +134,8 @@ extern void sdata_section PARAMS ((void));\n #ifdef SBSS_SECTION_ASM_OP\n extern void sbss_section PARAMS ((void));\n #endif\n+\n+#ifdef ARGS_SIZE_RTX\n+/* expr.h defines ARGS_SIZE_RTX and `enum direction'.  */\n+extern enum direction ia64_hpux_function_arg_padding PARAMS ((enum machine_mode, tree));\n+#endif /* ARGS_SIZE_RTX */"}, {"sha": "b70f038390a2171e791665643d7454007fab3371", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d7839daeef826108df3788cc82c198df2e56b2d/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d7839daeef826108df3788cc82c198df2e56b2d/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=0d7839daeef826108df3788cc82c198df2e56b2d", "patch": "@@ -7724,3 +7724,27 @@ ia64_expand_builtin (exp, target, subtarget, mode, ignore)\n \n   return NULL_RTX;\n }\n+\n+/* For the HP-UX IA64 aggregate parameters are passed stored in the\n+   most significant bits of the stack slot.  */\n+\n+enum direction\n+ia64_hpux_function_arg_padding (mode, type)\n+     enum machine_mode mode;\n+     tree type;\n+{\n+   /* Exception to normal case for structures/unions/etc. */\n+\n+   if (type && AGGREGATE_TYPE_P (type)\n+       && int_size_in_bytes (type) < UNITS_PER_WORD)\n+     return upward;\n+\n+   /* This is the standard FUNCTION_ARG_PADDING with !BYTES_BIG_ENDIAN\n+      hardwired to be true. */\n+\n+   return((mode == BLKmode\n+       ? (type && TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST\n+          && int_size_in_bytes (type) < (PARM_BOUNDARY / BITS_PER_UNIT))\n+       : GET_MODE_BITSIZE (mode) < PARM_BOUNDARY)\n+      ? downward : upward);\n+}"}, {"sha": "ecfcedaaae2b69bedfa7ca3e117f5a649452e7ce", "filename": "gcc/defaults.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d7839daeef826108df3788cc82c198df2e56b2d/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d7839daeef826108df3788cc82c198df2e56b2d/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=0d7839daeef826108df3788cc82c198df2e56b2d", "patch": "@@ -457,4 +457,14 @@ You Lose!  You must define PREFERRED_DEBUGGING_TYPE!\n #define PREFERRED_DEBUGGING_TYPE NO_DEBUG\n #endif\n \n+/* This is set to 1 if BYTES_BIG_ENDIAN is defined but the target uses a\n+   little-endian method of passing and returning structures in registers.\n+   On the HP-UX IA64 and PA64 platforms structures are aligned differently\n+   then integral values and setting this value to 1 will allow for the\n+   special handling of structure arguments and return values in regs.  */\n+\n+#ifndef FUNCTION_ARG_REG_LITTLE_ENDIAN\n+#define FUNCTION_ARG_REG_LITTLE_ENDIAN 0\n+#endif\n+\n #endif  /* ! GCC_DEFAULTS_H */"}, {"sha": "5e97e914926da2e0ed291cf7d1a7764cbabebb27", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d7839daeef826108df3788cc82c198df2e56b2d/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d7839daeef826108df3788cc82c198df2e56b2d/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=0d7839daeef826108df3788cc82c198df2e56b2d", "patch": "@@ -3435,6 +3435,14 @@ nonzero, the caller does not make a copy.  Instead, it passes a pointer to the\n determined that the value won't be modified, it need not make a copy;\n otherwise a copy must be made.\n \n+@findex FUNCTION_ARG_REG_LITTLE_ENDIAN\n+@item FUNCTION_ARG_REG_LITTLE_ENDIAN\n+If defined TRUE on a big-endian system then structure arguments passed\n+(and returned) in registers are passed in a little-endian manner instead of\n+the big-endian manner.  On the HP-UX IA64 and PA64 platforms structures are\n+aligned differently then integral values and setting this value to true will\n+allow for the special handling of structure arguments and return values.\n+\n @findex CUMULATIVE_ARGS\n @item CUMULATIVE_ARGS\n A C type for declaring a variable that is used as the first argument of"}, {"sha": "53208057eb7901133d70eb6c63c339825df657aa", "filename": "gcc/expr.c", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d7839daeef826108df3788cc82c198df2e56b2d/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d7839daeef826108df3788cc82c198df2e56b2d/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=0d7839daeef826108df3788cc82c198df2e56b2d", "patch": "@@ -1868,7 +1868,8 @@ move_block_from_reg (regno, x, nregs, size)\n   /* If SIZE is that of a mode no bigger than a word, just use that\n      mode's store operation.  */\n   if (size <= UNITS_PER_WORD\n-      && (mode = mode_for_size (size * BITS_PER_UNIT, MODE_INT, 0)) != BLKmode)\n+      && (mode = mode_for_size (size * BITS_PER_UNIT, MODE_INT, 0)) != BLKmode\n+      && !FUNCTION_ARG_REG_LITTLE_ENDIAN)\n     {\n       emit_move_insn (adjust_address (x, mode, 0), gen_rtx_REG (mode, regno));\n       return;\n@@ -1877,7 +1878,9 @@ move_block_from_reg (regno, x, nregs, size)\n   /* Blocks smaller than a word on a BYTES_BIG_ENDIAN machine must be aligned\n      to the left before storing to memory.  Note that the previous test\n      doesn't handle all cases (e.g. SIZE == 3).  */\n-  if (size < UNITS_PER_WORD && BYTES_BIG_ENDIAN)\n+  if (size < UNITS_PER_WORD\n+      && BYTES_BIG_ENDIAN\n+      && !FUNCTION_ARG_REG_LITTLE_ENDIAN)\n     {\n       rtx tem = operand_subword (x, 0, 1, BLKmode);\n       rtx shift;\n@@ -2162,15 +2165,25 @@ copy_blkmode_from_reg (tgtblk, srcreg, type)\n \n   /* This code assumes srcreg is at least a full word.  If it isn't,\n      copy it into a new pseudo which is a full word.  */\n+\n+  /* If FUNCTION_ARG_REG_LITTLE_ENDIAN is set and convert_to_mode does\n+     a copy, the wrong part of the register gets copied so we fake\n+     a type conversion in place.  */\n+     \n   if (GET_MODE (srcreg) != BLKmode\n       && GET_MODE_SIZE (GET_MODE (srcreg)) < UNITS_PER_WORD)\n-    srcreg = convert_to_mode (word_mode, srcreg, TREE_UNSIGNED (type));\n+    if (FUNCTION_ARG_REG_LITTLE_ENDIAN)\n+       srcreg = simplify_gen_subreg (word_mode, srcreg, GET_MODE (srcreg), 0);\n+    else\n+       srcreg = convert_to_mode (word_mode, srcreg, TREE_UNSIGNED (type));\n \n   /* Structures whose size is not a multiple of a word are aligned\n      to the least significant byte (to the right).  On a BYTES_BIG_ENDIAN\n      machine, this means we must skip the empty high order bytes when\n      calculating the bit offset.  */\n-  if (BYTES_BIG_ENDIAN && bytes % UNITS_PER_WORD)\n+  if (BYTES_BIG_ENDIAN\n+      && !FUNCTION_ARG_REG_LITTLE_ENDIAN\n+      && bytes % UNITS_PER_WORD)\n     big_endian_correction\n       = (BITS_PER_WORD - ((bytes % UNITS_PER_WORD) * BITS_PER_UNIT));\n "}, {"sha": "3c4ccd1157364617f77c85b49e6f6ba295647f68", "filename": "gcc/stmt.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d7839daeef826108df3788cc82c198df2e56b2d/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d7839daeef826108df3788cc82c198df2e56b2d/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=0d7839daeef826108df3788cc82c198df2e56b2d", "patch": "@@ -3197,7 +3197,9 @@ expand_return (retval)\n \t to the least significant byte (to the right).  On a BYTES_BIG_ENDIAN\n \t machine, this means we must skip the empty high order bytes when\n \t calculating the bit offset.  */\n-      if (BYTES_BIG_ENDIAN && bytes % UNITS_PER_WORD)\n+      if (BYTES_BIG_ENDIAN\n+\t  && !FUNCTION_ARG_REG_LITTLE_ENDIAN\n+\t  && bytes % UNITS_PER_WORD)\n \tbig_endian_correction = (BITS_PER_WORD - ((bytes % UNITS_PER_WORD)\n \t\t\t\t\t\t  * BITS_PER_UNIT));\n "}, {"sha": "f657463bfd010d36bdad14368cceb62a505c6fc6", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d7839daeef826108df3788cc82c198df2e56b2d/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d7839daeef826108df3788cc82c198df2e56b2d/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=0d7839daeef826108df3788cc82c198df2e56b2d", "patch": "@@ -1149,7 +1149,17 @@ compute_record_mode (type)\n #ifdef MEMBER_TYPE_FORCES_BLK\n       /* With some targets, eg. c4x, it is sub-optimal\n \t to access an aligned BLKmode structure as a scalar.  */\n-      if (mode == VOIDmode && MEMBER_TYPE_FORCES_BLK (field))\n+\n+      /* On ia64-*-hpux we need to ensure that we don't change the\n+\t mode of a structure containing a single field or else we\n+\t will pass it incorrectly.  Since a structure with a single\n+\t field causes mode to get set above we can't allow the\n+\t check for mode == VOIDmode in this case.  Perhaps\n+\t MEMBER_TYPE_FORCES_BLK should be extended to include mode\n+\t as an argument and the check could be put in there for c4x.  */\n+\n+      if ((mode == VOIDmode || FUNCTION_ARG_REG_LITTLE_ENDIAN)\n+\t  && MEMBER_TYPE_FORCES_BLK (field))\n \treturn;\n #endif /* MEMBER_TYPE_FORCES_BLK  */\n     }"}]}