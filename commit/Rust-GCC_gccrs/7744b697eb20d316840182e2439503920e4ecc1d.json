{"sha": "7744b697eb20d316840182e2439503920e4ecc1d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzc0NGI2OTdlYjIwZDMxNjg0MDE4MmUyNDM5NTAzOTIwZTRlY2MxZA==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2010-01-21T16:18:06Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2010-01-21T16:18:06Z"}, "message": "re PR tree-optimization/42585 (SRA is not good for structure copies with one replacement any more)\n\n2010-01-21  Martin Jambor  <mjambor@suse.cz>\n\n\tPR tree-optimization/42585\n\t* tree-sra.c (struct access): New field grp_total_scalarization.\n\t(dump_access): Dump the new field.\n\t(should_scalarize_away_bitmap): New variable.\n\t(cannot_scalarize_away_bitmap): Likewise.\n\t(sra_initialize): Allocate new bitmaps.\n\t(sra_deinitialize): Free new bitmaps.\n\t(create_access_1): New function.\n\t(create_access): Parts moved to create_access_1.\n\t(type_consists_of_records_p): New function.\n\t(completely_scalarize_record): Likewise.\n\t(build_access_from_expr): Set bit in cannot_scalarize_away_bitmap.\n\t(build_accesses_from_assign): Set bits in should_scalarize_away_bitmap.\n\t(sort_and_splice_var_accesses): Hint groups with a total_scalarization\n\taccess.\n\t(analyze_all_variable_accesses): Completely scalarize small eligible\n\trecords.\n\n\t* testsuite/gcc.dg/tree-ssa/pr42585.c: New test.\n\nFrom-SVN: r156156", "tree": {"sha": "fa2d12ef06cc05f01ca96b1c3650c9f2837cca38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fa2d12ef06cc05f01ca96b1c3650c9f2837cca38"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7744b697eb20d316840182e2439503920e4ecc1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7744b697eb20d316840182e2439503920e4ecc1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7744b697eb20d316840182e2439503920e4ecc1d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7744b697eb20d316840182e2439503920e4ecc1d/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fff08961d5f1bb5758b583948c096df864a451bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fff08961d5f1bb5758b583948c096df864a451bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fff08961d5f1bb5758b583948c096df864a451bf"}], "stats": {"total": 243, "additions": 220, "deletions": 23}, "files": [{"sha": "6eb61022fe729f66f764c439322cf1e644b684e9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7744b697eb20d316840182e2439503920e4ecc1d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7744b697eb20d316840182e2439503920e4ecc1d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7744b697eb20d316840182e2439503920e4ecc1d", "patch": "@@ -1,3 +1,23 @@\n+2010-01-21  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR tree-optimization/42585\n+\t* tree-sra.c (struct access): New field grp_total_scalarization.\n+\t(dump_access): Dump the new field.\n+\t(should_scalarize_away_bitmap): New variable.\n+\t(cannot_scalarize_away_bitmap): Likewise.\n+\t(sra_initialize): Allocate new bitmaps.\n+\t(sra_deinitialize): Free new bitmaps.\n+\t(create_access_1): New function.\n+\t(create_access): Parts moved to create_access_1.\n+\t(type_consists_of_records_p): New function.\n+\t(completely_scalarize_record): Likewise.\n+\t(build_access_from_expr): Set bit in cannot_scalarize_away_bitmap.\n+\t(build_accesses_from_assign): Set bits in should_scalarize_away_bitmap.\n+\t(sort_and_splice_var_accesses): Hint groups with a total_scalarization\n+\taccess.\n+\t(analyze_all_variable_accesses): Completely scalarize small eligible\n+\trecords.\n+\n 2010-01-21  Martin Jambor  <mjambor@suse.cz>\n \n \t* tree-sra.c (build_ref_for_offset_1): Allow for zero size fields."}, {"sha": "3f6a0ce20d18d65a851804908658f006fb04f1e3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7744b697eb20d316840182e2439503920e4ecc1d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7744b697eb20d316840182e2439503920e4ecc1d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7744b697eb20d316840182e2439503920e4ecc1d", "patch": "@@ -1,3 +1,8 @@\n+2010-01-21  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR tree-optimization/42585\n+\t* gcc.dg/tree-ssa/pr42585.c: New test.\n+\n 2010-01-21  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/19988"}, {"sha": "8a4edfce068d40d249590dd57eb8a586e8edd1f6", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr42585.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7744b697eb20d316840182e2439503920e4ecc1d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr42585.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7744b697eb20d316840182e2439503920e4ecc1d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr42585.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr42585.c?ref=7744b697eb20d316840182e2439503920e4ecc1d", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -fdump-tree-optimized\" } */\n+\n+struct _fat_ptr\n+{\n+  unsigned char *curr;\n+  unsigned char *base;\n+  unsigned char *last_plus_one;\n+};\n+int Cyc_string_ungetc (int ignore, struct _fat_ptr *sptr);\n+int\n+Cyc_string_ungetc (int ignore, struct _fat_ptr *sptr)\n+{\n+  struct _fat_ptr *_T0;\n+  struct _fat_ptr *_T1;\n+  struct _fat_ptr _T2;\n+  int _T3;\n+  struct _fat_ptr _ans;\n+  int _change;\n+\n+  {\n+    _T0 = sptr;\n+    _T1 = sptr;\n+    _T2 = *sptr;\n+    _T3 = -1;\n+    _ans = _T2;\n+    _change = -1;\n+    _ans.curr += 4294967295U;\n+    *sptr = _ans;\n+    return (0);\n+  }\n+}\n+\n+/* The local aggregates . */\n+/* { dg-final { scan-tree-dump-times \"struct _fat_ptr _ans\" 0 \"optimized\"} } */\n+/* { dg-final { scan-tree-dump-times \"struct _fat_ptr _T2\" 0 \"optimized\"} } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "07658bddae9796f902f280f6b70bcf4c8a57fbbd", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 158, "deletions": 23, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7744b697eb20d316840182e2439503920e4ecc1d/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7744b697eb20d316840182e2439503920e4ecc1d/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=7744b697eb20d316840182e2439503920e4ecc1d", "patch": "@@ -166,6 +166,10 @@ struct access\n   /* Is this particular access write access? */\n   unsigned write : 1;\n \n+  /* Is this access an artificial one created to scalarize some record\n+     entirely? */\n+  unsigned total_scalarization : 1;\n+\n   /* Is this access currently in the work queue?  */\n   unsigned grp_queued : 1;\n \n@@ -244,6 +248,10 @@ static struct pointer_map_t *base_access_vec;\n /* Bitmap of candidates.  */\n static bitmap candidate_bitmap;\n \n+/* Bitmap of candidates which we should try to entirely scalarize away and\n+   those which cannot be (because they are and need be used as a whole).  */\n+static bitmap should_scalarize_away_bitmap, cannot_scalarize_away_bitmap;\n+\n /* Obstack for creation of fancy names.  */\n static struct obstack name_obstack;\n \n@@ -343,18 +351,22 @@ dump_access (FILE *f, struct access *access, bool grp)\n   fprintf (f, \", type = \");\n   print_generic_expr (f, access->type, 0);\n   if (grp)\n-    fprintf (f, \", grp_write = %d, grp_read = %d, grp_hint = %d, \"\n+    fprintf (f, \", grp_write = %d, total_scalarization = %d, \"\n+\t     \"grp_read = %d, grp_hint = %d, \"\n \t     \"grp_covered = %d, grp_unscalarizable_region = %d, \"\n \t     \"grp_unscalarized_data = %d, grp_partial_lhs = %d, \"\n \t     \"grp_to_be_replaced = %d, grp_maybe_modified = %d, \"\n \t     \"grp_not_necessarilly_dereferenced = %d\\n\",\n-\t     access->grp_write, access->grp_read, access->grp_hint,\n+\t     access->grp_write, access->total_scalarization,\n+\t     access->grp_read, access->grp_hint,\n \t     access->grp_covered, access->grp_unscalarizable_region,\n \t     access->grp_unscalarized_data, access->grp_partial_lhs,\n \t     access->grp_to_be_replaced, access->grp_maybe_modified,\n \t     access->grp_not_necessarilly_dereferenced);\n   else\n-    fprintf (f, \", write = %d, grp_partial_lhs = %d\\n\", access->write,\n+    fprintf (f, \", write = %d, total_scalarization = %d, \"\n+\t     \"grp_partial_lhs = %d\\n\",\n+\t     access->write, access->total_scalarization,\n \t     access->grp_partial_lhs);\n }\n \n@@ -546,6 +558,8 @@ static void\n sra_initialize (void)\n {\n   candidate_bitmap = BITMAP_ALLOC (NULL);\n+  should_scalarize_away_bitmap = BITMAP_ALLOC (NULL);\n+  cannot_scalarize_away_bitmap = BITMAP_ALLOC (NULL);\n   gcc_obstack_init (&name_obstack);\n   access_pool = create_alloc_pool (\"SRA accesses\", sizeof (struct access), 16);\n   link_pool = create_alloc_pool (\"SRA links\", sizeof (struct assign_link), 16);\n@@ -575,6 +589,8 @@ static void\n sra_deinitialize (void)\n {\n   BITMAP_FREE (candidate_bitmap);\n+  BITMAP_FREE (should_scalarize_away_bitmap);\n+  BITMAP_FREE (cannot_scalarize_away_bitmap);\n   free_alloc_pool (access_pool);\n   free_alloc_pool (link_pool);\n   obstack_free (&name_obstack, NULL);\n@@ -685,15 +701,44 @@ mark_parm_dereference (tree base, HOST_WIDE_INT dist, gimple stmt)\n     bb_dereferences[idx] = dist;\n }\n \n+/* Allocate an access structure for BASE, OFFSET and SIZE, clear it, fill in\n+   the three fields.  Also add it to the vector of accesses corresponding to\n+   the base.  Finally, return the new access.  */\n+\n+static struct access *\n+create_access_1 (tree base, HOST_WIDE_INT offset, HOST_WIDE_INT size)\n+{\n+  VEC (access_p, heap) *vec;\n+  struct access *access;\n+  void **slot;\n+\n+  access = (struct access *) pool_alloc (access_pool);\n+  memset (access, 0, sizeof (struct access));\n+  access->base = base;\n+  access->offset = offset;\n+  access->size = size;\n+\n+  slot = pointer_map_contains (base_access_vec, base);\n+  if (slot)\n+    vec = (VEC (access_p, heap) *) *slot;\n+  else\n+    vec = VEC_alloc (access_p, heap, 32);\n+\n+  VEC_safe_push (access_p, heap, vec, access);\n+\n+  *((struct VEC (access_p,heap) **)\n+\tpointer_map_insert (base_access_vec, base)) = vec;\n+\n+  return access;\n+}\n+\n /* Create and insert access for EXPR. Return created access, or NULL if it is\n    not possible.  */\n \n static struct access *\n create_access (tree expr, gimple stmt, bool write)\n {\n   struct access *access;\n-  void **slot;\n-  VEC (access_p,heap) *vec;\n   HOST_WIDE_INT offset, size, max_size;\n   tree base = expr;\n   bool ptr, unscalarizable_region = false;\n@@ -744,30 +789,79 @@ create_access (tree expr, gimple stmt, bool write)\n \t}\n     }\n \n-  access = (struct access *) pool_alloc (access_pool);\n-  memset (access, 0, sizeof (struct access));\n-\n-  access->base = base;\n-  access->offset = offset;\n-  access->size = size;\n+  access = create_access_1 (base, offset, size);\n   access->expr = expr;\n   access->type = TREE_TYPE (expr);\n   access->write = write;\n   access->grp_unscalarizable_region = unscalarizable_region;\n   access->stmt = stmt;\n \n-  slot = pointer_map_contains (base_access_vec, base);\n-  if (slot)\n-    vec = (VEC (access_p, heap) *) *slot;\n-  else\n-    vec = VEC_alloc (access_p, heap, 32);\n+  return access;\n+}\n \n-  VEC_safe_push (access_p, heap, vec, access);\n \n-  *((struct VEC (access_p,heap) **)\n-\tpointer_map_insert (base_access_vec, base)) = vec;\n+/* Return true iff TYPE is a RECORD_TYPE with fields that are either of gimple\n+   register types or (recursively) records with only these two kinds of\n+   fields.  */\n \n-  return access;\n+static bool\n+type_consists_of_records_p (tree type)\n+{\n+  tree fld;\n+\n+  if (TREE_CODE (type) != RECORD_TYPE)\n+    return false;\n+\n+  for (fld = TYPE_FIELDS (type); fld; fld = TREE_CHAIN (fld))\n+    if (TREE_CODE (fld) == FIELD_DECL)\n+      {\n+\ttree ft = TREE_TYPE (fld);\n+\n+\tif (!is_gimple_reg_type (ft)\n+\t    && !type_consists_of_records_p (ft))\n+\t  return false;\n+      }\n+  return true;\n+}\n+\n+/* Create total_scalarization accesses for all scalar type fields in DECL that\n+   must be of a RECORD_TYPE conforming to type_consists_of_records_p.  BASE\n+   must be the top-most VAR_DECL representing the variable, OFFSET must be the\n+   offset of DECL within BASE.  */\n+\n+static void\n+completely_scalarize_record (tree base, tree decl, HOST_WIDE_INT offset)\n+{\n+  tree fld, decl_type = TREE_TYPE (decl);\n+\n+  for (fld = TYPE_FIELDS (decl_type); fld; fld = TREE_CHAIN (fld))\n+    if (TREE_CODE (fld) == FIELD_DECL)\n+      {\n+\tHOST_WIDE_INT pos = offset + int_bit_position (fld);\n+\ttree ft = TREE_TYPE (fld);\n+\n+\tif (is_gimple_reg_type (ft))\n+\t  {\n+\t    struct access *access;\n+\t    HOST_WIDE_INT size;\n+\t    tree expr;\n+\t    bool ok;\n+\n+\t    size = tree_low_cst (DECL_SIZE (fld), 1);\n+\t    expr = base;\n+\t    ok = build_ref_for_offset (&expr, TREE_TYPE (base), pos,\n+\t\t\t\t       ft, false);\n+\t    gcc_assert (ok);\n+\n+\t    access = create_access_1 (base, pos, size);\n+\t    access->expr = expr;\n+\t    access->type = ft;\n+\t    access->total_scalarization = 1;\n+\t    /* Accesses for intraprocedural SRA can have their stmt NULL.  */\n+\t  }\n+\telse\n+\t  completely_scalarize_record (base, fld, pos);\n+      }\n }\n \n \n@@ -860,7 +954,19 @@ build_access_from_expr (tree *expr_ptr,\n \t\t\tgimple_stmt_iterator *gsi ATTRIBUTE_UNUSED, bool write,\n \t\t\tvoid *data ATTRIBUTE_UNUSED)\n {\n-  return build_access_from_expr_1 (expr_ptr, gsi_stmt (*gsi), write) != NULL;\n+  struct access *access;\n+\n+  access = build_access_from_expr_1 (expr_ptr, gsi_stmt (*gsi), write);\n+  if (access)\n+    {\n+      /* This means the aggregate is accesses as a whole in a way other than an\n+\t assign statement and thus cannot be removed even if we had a scalar\n+\t replacement for everything.  */\n+      if (cannot_scalarize_away_bitmap)\n+\tbitmap_set_bit (cannot_scalarize_away_bitmap, DECL_UID (access->base));\n+      return true;\n+    }\n+  return false;\n }\n \n /* Disqualify LHS and RHS for scalarization if STMT must end its basic block in\n@@ -916,6 +1022,9 @@ build_accesses_from_assign (gimple *stmt_ptr,\n   racc = build_access_from_expr_1 (rhs_ptr, stmt, false);\n   lacc = build_access_from_expr_1 (lhs_ptr, stmt, true);\n \n+  if (should_scalarize_away_bitmap && racc && !is_gimple_reg_type (racc->type))\n+    bitmap_set_bit (should_scalarize_away_bitmap, DECL_UID (racc->base));\n+\n   if (lacc && racc\n       && (sra_mode == SRA_MODE_EARLY_INTRA || sra_mode == SRA_MODE_INTRA)\n       && !lacc->grp_unscalarizable_region\n@@ -1460,6 +1569,7 @@ sort_and_splice_var_accesses (tree var)\n       bool grp_write = access->write;\n       bool grp_read = !access->write;\n       bool multiple_reads = false;\n+      bool total_scalarization = access->total_scalarization;\n       bool grp_partial_lhs = access->grp_partial_lhs;\n       bool first_scalar = is_gimple_reg_type (access->type);\n       bool unscalarizable_region = access->grp_unscalarizable_region;\n@@ -1493,6 +1603,7 @@ sort_and_splice_var_accesses (tree var)\n \t    }\n \t  grp_partial_lhs |= ac2->grp_partial_lhs;\n \t  unscalarizable_region |= ac2->grp_unscalarizable_region;\n+\t  total_scalarization |= ac2->total_scalarization;\n \t  relink_to_new_repr (access, ac2);\n \n \t  /* If there are both aggregate-type and scalar-type accesses with\n@@ -1508,7 +1619,7 @@ sort_and_splice_var_accesses (tree var)\n       access->group_representative = access;\n       access->grp_write = grp_write;\n       access->grp_read = grp_read;\n-      access->grp_hint = multiple_reads;\n+      access->grp_hint = multiple_reads || total_scalarization;\n       access->grp_partial_lhs = grp_partial_lhs;\n       access->grp_unscalarizable_region = unscalarizable_region;\n       if (access->first_link)\n@@ -1918,7 +2029,31 @@ analyze_all_variable_accesses (void)\n   int res = 0;\n   bitmap tmp = BITMAP_ALLOC (NULL);\n   bitmap_iterator bi;\n-  unsigned i;\n+  unsigned i, max_total_scalarization_size;\n+\n+  max_total_scalarization_size = UNITS_PER_WORD * BITS_PER_UNIT\n+    * MOVE_RATIO (optimize_function_for_speed_p (cfun));\n+\n+  EXECUTE_IF_SET_IN_BITMAP (candidate_bitmap, 0, i, bi)\n+    if (bitmap_bit_p (should_scalarize_away_bitmap, i)\n+\t&& !bitmap_bit_p (cannot_scalarize_away_bitmap, i))\n+      {\n+\ttree var = referenced_var (i);\n+\n+\tif (TREE_CODE (var) == VAR_DECL\n+\t    && ((unsigned) tree_low_cst (TYPE_SIZE (TREE_TYPE (var)), 1)\n+\t\t<= max_total_scalarization_size)\n+\t    && type_consists_of_records_p (TREE_TYPE (var)))\n+\t  {\n+\t    completely_scalarize_record (var, var, 0);\n+\t    if (dump_file && (dump_flags & TDF_DETAILS))\n+\t      {\n+\t\tfprintf (dump_file, \"Will attempt to totally scalarize \");\n+\t\tprint_generic_expr (dump_file, var, 0);\n+\t\tfprintf (dump_file, \" (UID: %u): \\n\", DECL_UID (var));\n+\t      }\n+\t  }\n+      }\n \n   bitmap_copy (tmp, candidate_bitmap);\n   EXECUTE_IF_SET_IN_BITMAP (tmp, 0, i, bi)"}]}