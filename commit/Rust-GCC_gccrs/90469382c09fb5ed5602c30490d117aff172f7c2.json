{"sha": "90469382c09fb5ed5602c30490d117aff172f7c2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTA0NjkzODJjMDlmYjVlZDU2MDJjMzA0OTBkMTE3YWZmMTcyZjdjMg==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2008-01-15T21:22:07Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2008-01-15T21:22:07Z"}, "message": "re PR libfortran/34671 (any(kind=1) and all(kind=1))\n\n2008-01-15  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR libfortran/34671\n\t* gfortran.am: Added _gfortran_all_l1, _gfortran_all_l2,\n\t_gfortran_any_l1, _gfortran_any_l2, -28,15 _gfortran_count_1_l,\n\t_gfortran_count_16_l, _gfortran_count_2_l, _gfortran_count_4_l and\n\t_gfortran_count_8_l Removed _gfortran_count_16_l16,\n\t_gfortran_count_16_l4, _gfortran_count_16_l8,\n\t_gfortran_count_4_l16, _gfortran_count_4_l4, _gfortran_count_4_l8,\n\t_gfortran_count_8_l16, _gfortran_count_8_l4 and\n\t_gfortran_count_8_l8.\n\t* Makefile.am: Added generated/any_l1.c and generated/any_l2.c to\n\ti_any_c.  Added generated/all_l1. and generated/all_l2.c to\n\ti_all_c.  Removed generated/count_4_l4.c, generated/count_8_l4.c,\n\tgenerated/count_16_l4.c, generated/count_4_l8.c,\n\tgenerated/count_8_l8.c, generated/count_16_l8.c,\n\tgenerated/count_4_l16.c, generated/count_8_l16.c, and\n\tgenerated/count_16_l16.c from i_count_c.  Added count_1_l.c,\n\tcount_2_l.c, count_4_l.c, count_8_l.c and count_16_l.c to\n\ti_count_c.  I_M4_DEPS2 depends on ifunction_logical.m4, for\n\tany of the files generated from all.m4, any.m4 and count.m4.\n\t* Makefile.in:  Regenerated.\n\t* m4/ifunction_logical.m4:  New file.  Use\n\tGFC_LOGICAL_1 pointer for access to source arrays.\n\t* m4/any.m4:  Include ifunction_logical.m4 instead of\n\tifunction.m4.  Don't check atype_name.\n\t* m4/all.m4:  Likewise.\n\t* m4/count.m4:  Likewise.\n\t* generated/any_l1.c:  New file.\n\t* generated/any_l2.c:  New file.\n\t* generated/all_l1.c:  New file.\n\t* generated/count_1_l.c:  New file.\n\t* generated/count_2_l.c:  New file.\n\t* generated/count_4_l.c:  New file.\n\t* generated/count_8_l.c:  New file.\n\t* generated/count_16_l.c:  New file.\n\t* generated/any_l4.c:  Regenerated.\n\t* generated/any_l8.c:  Regenerated.\n\t* generated/any_l16.c:  Regenerated.\n\t* generated/all_l4.c: Regenerated.\n\t* generated/all_l8.c: Regenerated.\n\t* generated/all_l16.c: Regenerated.\n\t* generated/count_4_l4.c:  Removed.\n\t* generated/count_4_l8.c:  Removed.\n\t* generated/count_4_l16.c:  Removed.\n\t* generated/count_8_l4.c:  Removed.\n\t* generated/count_8_l8.c:  Removed.\n\t* generated/count_8_l16.c:  Removed.\n\t* generated/count_16_l4.c:  Removed.\n\t* generated/count_16_l8.c:  Removed.\n\t* generated/count_16_l16.c:  Removed.\n\n2008-01-15  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR libfortran/34671\n\t* iresolve.c (gfc_resolve_all):  Call resolve_mask_arg.\n\t(gfc_resolve_any):  Likewise.\n\t(gfc_resolve_count):  Likewise.  Don't append kind of\n\targument to function name.\n\n2008-01-15  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\t\n\tPR libfortran/34671\n\t* gfortran.dg/anyallcount_1.f90:  New test.\n\nFrom-SVN: r131553", "tree": {"sha": "48e5848dd3732806515c1d1a39309fb7baba909b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/48e5848dd3732806515c1d1a39309fb7baba909b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/90469382c09fb5ed5602c30490d117aff172f7c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90469382c09fb5ed5602c30490d117aff172f7c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90469382c09fb5ed5602c30490d117aff172f7c2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90469382c09fb5ed5602c30490d117aff172f7c2/comments", "author": null, "committer": null, "parents": [{"sha": "ac90ae18fb641f365ce349efbbaf8b88a4f96b8e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac90ae18fb641f365ce349efbbaf8b88a4f96b8e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac90ae18fb641f365ce349efbbaf8b88a4f96b8e"}], "stats": {"total": 2506, "additions": 1546, "deletions": 960}, "files": [{"sha": "d9e28b51f9eb2bd8045aa8844385413cd8c79cf3", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90469382c09fb5ed5602c30490d117aff172f7c2/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90469382c09fb5ed5602c30490d117aff172f7c2/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=90469382c09fb5ed5602c30490d117aff172f7c2", "patch": "@@ -1,3 +1,11 @@\n+2008-01-15  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR libfortran/34671\n+\t* iresolve.c (gfc_resolve_all):  Call resolve_mask_arg.\n+\t(gfc_resolve_any):  Likewise.\n+\t(gfc_resolve_count):  Likewise.  Don't append kind of\n+\targument to function name.\n+\n 2008-01-13  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/34665"}, {"sha": "bdb4054fe411fa9e506a220d50a42d60a866daa8", "filename": "gcc/fortran/iresolve.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90469382c09fb5ed5602c30490d117aff172f7c2/gcc%2Ffortran%2Firesolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90469382c09fb5ed5602c30490d117aff172f7c2/gcc%2Ffortran%2Firesolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Firesolve.c?ref=90469382c09fb5ed5602c30490d117aff172f7c2", "patch": "@@ -256,6 +256,8 @@ gfc_resolve_all (gfc_expr *f, gfc_expr *mask, gfc_expr *dim)\n       f->shape = gfc_copy_shape_excluding (mask->shape, mask->rank, dim);\n     }\n \n+  resolve_mask_arg (mask);\n+\n   f->value.function.name\n     = gfc_get_string (PREFIX (\"all_%c%d\"), gfc_type_letter (mask->ts.type),\n \t\t      mask->ts.kind);\n@@ -304,6 +306,8 @@ gfc_resolve_any (gfc_expr *f, gfc_expr *mask, gfc_expr *dim)\n       f->shape = gfc_copy_shape_excluding (mask->shape, mask->rank, dim);\n     }\n \n+  resolve_mask_arg (mask);\n+\n   f->value.function.name\n     = gfc_get_string (PREFIX (\"any_%c%d\"), gfc_type_letter (mask->ts.type),\n \t\t      mask->ts.kind);\n@@ -549,9 +553,11 @@ gfc_resolve_count (gfc_expr *f, gfc_expr *mask, gfc_expr *dim, gfc_expr *kind)\n       f->shape = gfc_copy_shape_excluding (mask->shape, mask->rank, dim);\n     }\n \n+  resolve_mask_arg (mask);\n+\n   f->value.function.name\n-    = gfc_get_string (PREFIX (\"count_%d_%c%d\"), f->ts.kind,\n-\t\t      gfc_type_letter (mask->ts.type), mask->ts.kind);\n+    = gfc_get_string (PREFIX (\"count_%d_%c\"), f->ts.kind,\n+\t\t      gfc_type_letter (mask->ts.type));\n }\n \n "}, {"sha": "d0c52a2783f158ba77a5f70e5418cf94e2301eb6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90469382c09fb5ed5602c30490d117aff172f7c2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90469382c09fb5ed5602c30490d117aff172f7c2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=90469382c09fb5ed5602c30490d117aff172f7c2", "patch": "@@ -1,3 +1,8 @@\n+2008-01-15  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\t\n+\tPR libfortran/34671\n+\t* gfortran.dg/anyallcount_1.f90:  New test.\n+\n 2008-01-15  Douglas Gregor  <doug.gregor@gmail.com>\n \n \tPR c++/34399"}, {"sha": "9e8c7768b5023b2d3c836c8fd06d38c05afe9d9a", "filename": "gcc/testsuite/gfortran.dg/anyallcount_1.f90", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90469382c09fb5ed5602c30490d117aff172f7c2/gcc%2Ftestsuite%2Fgfortran.dg%2Fanyallcount_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90469382c09fb5ed5602c30490d117aff172f7c2/gcc%2Ftestsuite%2Fgfortran.dg%2Fanyallcount_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fanyallcount_1.f90?ref=90469382c09fb5ed5602c30490d117aff172f7c2", "patch": "@@ -0,0 +1,71 @@\n+! { dg-do run }\n+program main\n+   character(len=*), parameter :: f='(3L1)'\n+   character(len=*), parameter :: g='(3I1)'\n+   real, dimension(3,3) :: a\n+   logical(kind=1), dimension(3,3) :: m1\n+   logical(kind=2), dimension(3,3) :: m2\n+   logical(kind=4), dimension(3,3) :: m4\n+   logical(kind=8), dimension(3,3) :: m8\n+   character(len=3) :: res\n+   data a /-1.0, -2.0, -3.0, 2.0, 1.0, -2.1, 1.0, 2.0, 3.0 /\n+\n+   m1 = a > 0\n+   m2 = a > 0\n+   m4 = a > 0\n+   m8 = a > 0\n+\n+   write (unit=res,fmt=f) any(m1,dim=1)\n+   if (res /= 'FTT') call abort\n+   write (unit=res,fmt=f) any(m2,dim=1)\n+   if (res /= 'FTT') call abort\n+   write (unit=res,fmt=f) any(m4,dim=1)\n+   if (res /= 'FTT') call abort\n+   write (unit=res,fmt=f) any(m8,dim=1)\n+   if (res /= 'FTT') call abort\n+   write (unit=res,fmt=f) any(m1,dim=2)\n+   if (res /= 'TTT') call abort\n+   write (unit=res,fmt=f) any(m2,dim=2)\n+   if (res /= 'TTT') call abort\n+   write (unit=res,fmt=f) any(m4,dim=2)\n+   if (res /= 'TTT') call abort\n+   write (unit=res,fmt=f) any(m8,dim=2)\n+   if (res /= 'TTT') call abort\n+\n+   write (unit=res,fmt=f) all(m1,dim=1)\n+   if (res /= 'FFT') call abort\n+   write (unit=res,fmt=f) all(m2,dim=1)\n+   if (res /= 'FFT') call abort\n+   write (unit=res,fmt=f) all(m4,dim=1)\n+   if (res /= 'FFT') call abort\n+   write (unit=res,fmt=f) all(m8,dim=1)\n+   if (res /= 'FFT') call abort\n+\n+   write (unit=res,fmt=f) all(m1,dim=2)\n+   if (res /= 'FFF') call abort\n+   write (unit=res,fmt=f) all(m2,dim=2)\n+   if (res /= 'FFF') call abort\n+   write (unit=res,fmt=f) all(m4,dim=2)\n+   if (res /= 'FFF') call abort\n+   write (unit=res,fmt=f) all(m8,dim=2)\n+   if (res /= 'FFF') call abort\n+\n+   write (unit=res,fmt=g) count(m1,dim=1)\n+   if (res /= '023') call abort\n+   write (unit=res,fmt=g) count(m2,dim=1)\n+   if (res /= '023') call abort\n+   write (unit=res,fmt=g) count(m4,dim=1)\n+   if (res /= '023') call abort\n+   write (unit=res,fmt=g) count(m8,dim=1)\n+   if (res /= '023') call abort\n+\n+   write (unit=res,fmt=g) count(m1,dim=2)\n+   if (res /= '221') call abort\n+   write (unit=res,fmt=g) count(m2,dim=2)\n+   if (res /= '221') call abort\n+   write (unit=res,fmt=g) count(m4,dim=2)\n+   if (res /= '221') call abort\n+   write (unit=res,fmt=g) count(m8,dim=2)\n+   if (res /= '221') call abort\n+\n+end program main"}, {"sha": "389861a82fc1d55d33b4d8b1f6b744355477929e", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90469382c09fb5ed5602c30490d117aff172f7c2/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90469382c09fb5ed5602c30490d117aff172f7c2/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=90469382c09fb5ed5602c30490d117aff172f7c2", "patch": "@@ -1,3 +1,55 @@\n+2008-01-15  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR libfortran/34671\n+\t* gfortran.am: Added _gfortran_all_l1, _gfortran_all_l2,\n+\t_gfortran_any_l1, _gfortran_any_l2, -28,15 _gfortran_count_1_l,\n+\t_gfortran_count_16_l, _gfortran_count_2_l, _gfortran_count_4_l and\n+\t_gfortran_count_8_l Removed _gfortran_count_16_l16,\n+\t_gfortran_count_16_l4, _gfortran_count_16_l8,\n+\t_gfortran_count_4_l16, _gfortran_count_4_l4, _gfortran_count_4_l8,\n+\t_gfortran_count_8_l16, _gfortran_count_8_l4 and\n+\t_gfortran_count_8_l8.\n+\t* Makefile.am: Added generated/any_l1.c and generated/any_l2.c to\n+\ti_any_c.  Added generated/all_l1. and generated/all_l2.c to\n+\ti_all_c.  Removed generated/count_4_l4.c, generated/count_8_l4.c,\n+\tgenerated/count_16_l4.c, generated/count_4_l8.c,\n+\tgenerated/count_8_l8.c, generated/count_16_l8.c,\n+\tgenerated/count_4_l16.c, generated/count_8_l16.c, and\n+\tgenerated/count_16_l16.c from i_count_c.  Added count_1_l.c,\n+\tcount_2_l.c, count_4_l.c, count_8_l.c and count_16_l.c to\n+\ti_count_c.  I_M4_DEPS2 depends on ifunction_logical.m4, for\n+\tany of the files generated from all.m4, any.m4 and count.m4.\n+\t* Makefile.in:  Regenerated.\n+\t* m4/ifunction_logical.m4:  New file.  Use\n+\tGFC_LOGICAL_1 pointer for access to source arrays.\n+\t* m4/any.m4:  Include ifunction_logical.m4 instead of\n+\tifunction.m4.  Don't check atype_name.\n+\t* m4/all.m4:  Likewise.\n+\t* m4/count.m4:  Likewise.\n+\t* generated/any_l1.c:  New file.\n+\t* generated/any_l2.c:  New file.\n+\t* generated/all_l1.c:  New file.\n+\t* generated/count_1_l.c:  New file.\n+\t* generated/count_2_l.c:  New file.\n+\t* generated/count_4_l.c:  New file.\n+\t* generated/count_8_l.c:  New file.\n+\t* generated/count_16_l.c:  New file.\n+\t* generated/any_l4.c:  Regenerated.\n+\t* generated/any_l8.c:  Regenerated.\n+\t* generated/any_l16.c:  Regenerated.\n+\t* generated/all_l4.c: Regenerated.\n+\t* generated/all_l8.c: Regenerated.\n+\t* generated/all_l16.c: Regenerated.\n+\t* generated/count_4_l4.c:  Removed.\n+\t* generated/count_4_l8.c:  Removed.\n+\t* generated/count_4_l16.c:  Removed.\n+\t* generated/count_8_l4.c:  Removed.\n+\t* generated/count_8_l8.c:  Removed.\n+\t* generated/count_8_l16.c:  Removed.\n+\t* generated/count_16_l4.c:  Removed.\n+\t* generated/count_16_l8.c:  Removed.\n+\t* generated/count_16_l16.c:  Removed.\n+\n 2008-01-13  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR libfortran/34746"}, {"sha": "489f9ed4634698d049722931037f51acd6184a51", "filename": "libgfortran/Makefile.am", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90469382c09fb5ed5602c30490d117aff172f7c2/libgfortran%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90469382c09fb5ed5602c30490d117aff172f7c2/libgfortran%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.am?ref=90469382c09fb5ed5602c30490d117aff172f7c2", "patch": "@@ -121,25 +121,25 @@ runtime/string.c \\\n runtime/select.c\n \n i_all_c= \\\n+$(srcdir)/generated/all_l1.c \\\n+$(srcdir)/generated/all_l2.c \\\n $(srcdir)/generated/all_l4.c \\\n $(srcdir)/generated/all_l8.c \\\n $(srcdir)/generated/all_l16.c\n \n i_any_c= \\\n+$(srcdir)/generated/any_l1.c \\\n+$(srcdir)/generated/any_l2.c \\\n $(srcdir)/generated/any_l4.c \\\n $(srcdir)/generated/any_l8.c \\\n $(srcdir)/generated/any_l16.c\n \n i_count_c= \\\n-$(srcdir)/generated/count_4_l4.c \\\n-$(srcdir)/generated/count_8_l4.c \\\n-$(srcdir)/generated/count_16_l4.c \\\n-$(srcdir)/generated/count_4_l8.c \\\n-$(srcdir)/generated/count_8_l8.c \\\n-$(srcdir)/generated/count_16_l8.c \\\n-$(srcdir)/generated/count_4_l16.c \\\n-$(srcdir)/generated/count_8_l16.c \\\n-$(srcdir)/generated/count_16_l16.c\n+$(srcdir)/generated/count_1_l.c \\\n+$(srcdir)/generated/count_2_l.c \\\n+$(srcdir)/generated/count_4_l.c \\\n+$(srcdir)/generated/count_8_l.c \\\n+$(srcdir)/generated/count_16_l.c\n \n i_maxloc0_c= \\\n $(srcdir)/generated/maxloc0_4_i1.c \\\n@@ -463,7 +463,7 @@ $(srcdir)/generated/pow_c16_i16.c\n m4_files= m4/iparm.m4 m4/ifunction.m4 m4/iforeach.m4 m4/all.m4 \\\n     m4/any.m4 m4/count.m4 m4/maxloc0.m4 m4/maxloc1.m4 m4/maxval.m4 \\\n     m4/minloc0.m4 m4/minloc1.m4 m4/minval.m4 m4/product.m4 m4/sum.m4 \\\n-    m4/matmul.m4 m4/matmull.m4 \\\n+    m4/matmul.m4 m4/matmull.m4 m4/ifunction_logical.m4 \\\n     m4/ctrig.m4 m4/cexp.m4 m4/chyp.m4 m4/mtype.m4 \\\n     m4/specific.m4 m4/specific2.m4 m4/head.m4 m4/shape.m4 m4/reshape.m4 \\\n     m4/transpose.m4 m4/eoshift1.m4 m4/eoshift3.m4 m4/exponent.m4 \\\n@@ -684,6 +684,7 @@ endif\n I_M4_DEPS=m4/iparm.m4\n I_M4_DEPS0=$(I_M4_DEPS) m4/iforeach.m4\n I_M4_DEPS1=$(I_M4_DEPS) m4/ifunction.m4\n+I_M4_DEPS2=$(I_M4_DEPS) m4/ifunction_logical.m4\n \n kinds.h: $(srcdir)/mk-kinds-h.sh\n \t$(SHELL) $(srcdir)/mk-kinds-h.sh '$(FCCOMPILE)' > $@ || rm $@\n@@ -707,13 +708,13 @@ fpu-target.h: $(srcdir)/$(FPU_HOST_HEADER)\n ## so we only include them in maintainer mode\n \n if MAINTAINER_MODE\n-$(i_all_c): m4/all.m4 $(I_M4_DEPS1)\n+$(i_all_c): m4/all.m4 $(I_M4_DEPS2)\n \t$(M4) -Dfile=$@ -I$(srcdir)/m4 all.m4 > $@\n \n-$(i_any_c): m4/any.m4 $(I_M4_DEPS1)\n+$(i_any_c): m4/any.m4 $(I_M4_DEPS2)\n \t$(M4) -Dfile=$@ -I$(srcdir)/m4 any.m4 > $@\n \n-$(i_count_c): m4/count.m4 $(I_M4_DEPS1)\n+$(i_count_c): m4/count.m4 $(I_M4_DEPS2)\n \t$(M4) -Dfile=$@ -I$(srcdir)/m4 count.m4 > $@\n \n $(i_maxloc0_c): m4/maxloc0.m4 $(I_M4_DEPS0)"}, {"sha": "07feb5deddbd1740076870908153d0dc5477cd93", "filename": "libgfortran/Makefile.in", "status": "modified", "additions": 88, "deletions": 90, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90469382c09fb5ed5602c30490d117aff172f7c2/libgfortran%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90469382c09fb5ed5602c30490d117aff172f7c2/libgfortran%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.in?ref=90469382c09fb5ed5602c30490d117aff172f7c2", "patch": "@@ -80,18 +80,16 @@ am__libgfortran_la_SOURCES_DIST = runtime/backtrace.c \\\n \truntime/compile_options.c runtime/environ.c runtime/error.c \\\n \truntime/fpu.c runtime/main.c runtime/memory.c runtime/pause.c \\\n \truntime/stop.c runtime/string.c runtime/select.c \\\n+\t$(srcdir)/generated/all_l1.c $(srcdir)/generated/all_l2.c \\\n \t$(srcdir)/generated/all_l4.c $(srcdir)/generated/all_l8.c \\\n-\t$(srcdir)/generated/all_l16.c $(srcdir)/generated/any_l4.c \\\n+\t$(srcdir)/generated/all_l16.c $(srcdir)/generated/any_l1.c \\\n+\t$(srcdir)/generated/any_l2.c $(srcdir)/generated/any_l4.c \\\n \t$(srcdir)/generated/any_l8.c $(srcdir)/generated/any_l16.c \\\n-\t$(srcdir)/generated/count_4_l4.c \\\n-\t$(srcdir)/generated/count_8_l4.c \\\n-\t$(srcdir)/generated/count_16_l4.c \\\n-\t$(srcdir)/generated/count_4_l8.c \\\n-\t$(srcdir)/generated/count_8_l8.c \\\n-\t$(srcdir)/generated/count_16_l8.c \\\n-\t$(srcdir)/generated/count_4_l16.c \\\n-\t$(srcdir)/generated/count_8_l16.c \\\n-\t$(srcdir)/generated/count_16_l16.c \\\n+\t$(srcdir)/generated/count_1_l.c \\\n+\t$(srcdir)/generated/count_2_l.c \\\n+\t$(srcdir)/generated/count_4_l.c \\\n+\t$(srcdir)/generated/count_8_l.c \\\n+\t$(srcdir)/generated/count_16_l.c \\\n \t$(srcdir)/generated/maxloc0_4_i1.c \\\n \t$(srcdir)/generated/maxloc0_8_i1.c \\\n \t$(srcdir)/generated/maxloc0_16_i1.c \\\n@@ -523,11 +521,10 @@ am__libgfortran_la_SOURCES_DIST = runtime/backtrace.c \\\n \t%.c,$(prereq_SRC))\n am__objects_1 = backtrace.lo compile_options.lo environ.lo error.lo \\\n \tfpu.lo main.lo memory.lo pause.lo stop.lo string.lo select.lo\n-am__objects_2 = all_l4.lo all_l8.lo all_l16.lo\n-am__objects_3 = any_l4.lo any_l8.lo any_l16.lo\n-am__objects_4 = count_4_l4.lo count_8_l4.lo count_16_l4.lo \\\n-\tcount_4_l8.lo count_8_l8.lo count_16_l8.lo count_4_l16.lo \\\n-\tcount_8_l16.lo count_16_l16.lo\n+am__objects_2 = all_l1.lo all_l2.lo all_l4.lo all_l8.lo all_l16.lo\n+am__objects_3 = any_l1.lo any_l2.lo any_l4.lo any_l8.lo any_l16.lo\n+am__objects_4 = count_1_l.lo count_2_l.lo count_4_l.lo count_8_l.lo \\\n+\tcount_16_l.lo\n am__objects_5 = maxloc0_4_i1.lo maxloc0_8_i1.lo maxloc0_16_i1.lo \\\n \tmaxloc0_4_i2.lo maxloc0_8_i2.lo maxloc0_16_i2.lo \\\n \tmaxloc0_4_i4.lo maxloc0_8_i4.lo maxloc0_16_i4.lo \\\n@@ -960,25 +957,25 @@ runtime/string.c \\\n runtime/select.c\n \n i_all_c = \\\n+$(srcdir)/generated/all_l1.c \\\n+$(srcdir)/generated/all_l2.c \\\n $(srcdir)/generated/all_l4.c \\\n $(srcdir)/generated/all_l8.c \\\n $(srcdir)/generated/all_l16.c\n \n i_any_c = \\\n+$(srcdir)/generated/any_l1.c \\\n+$(srcdir)/generated/any_l2.c \\\n $(srcdir)/generated/any_l4.c \\\n $(srcdir)/generated/any_l8.c \\\n $(srcdir)/generated/any_l16.c\n \n i_count_c = \\\n-$(srcdir)/generated/count_4_l4.c \\\n-$(srcdir)/generated/count_8_l4.c \\\n-$(srcdir)/generated/count_16_l4.c \\\n-$(srcdir)/generated/count_4_l8.c \\\n-$(srcdir)/generated/count_8_l8.c \\\n-$(srcdir)/generated/count_16_l8.c \\\n-$(srcdir)/generated/count_4_l16.c \\\n-$(srcdir)/generated/count_8_l16.c \\\n-$(srcdir)/generated/count_16_l16.c\n+$(srcdir)/generated/count_1_l.c \\\n+$(srcdir)/generated/count_2_l.c \\\n+$(srcdir)/generated/count_4_l.c \\\n+$(srcdir)/generated/count_8_l.c \\\n+$(srcdir)/generated/count_16_l.c\n \n i_maxloc0_c = \\\n $(srcdir)/generated/maxloc0_4_i1.c \\\n@@ -1302,7 +1299,7 @@ $(srcdir)/generated/pow_c16_i16.c\n m4_files = m4/iparm.m4 m4/ifunction.m4 m4/iforeach.m4 m4/all.m4 \\\n     m4/any.m4 m4/count.m4 m4/maxloc0.m4 m4/maxloc1.m4 m4/maxval.m4 \\\n     m4/minloc0.m4 m4/minloc1.m4 m4/minval.m4 m4/product.m4 m4/sum.m4 \\\n-    m4/matmul.m4 m4/matmull.m4 \\\n+    m4/matmul.m4 m4/matmull.m4 m4/ifunction_logical.m4 \\\n     m4/ctrig.m4 m4/cexp.m4 m4/chyp.m4 m4/mtype.m4 \\\n     m4/specific.m4 m4/specific2.m4 m4/head.m4 m4/shape.m4 m4/reshape.m4 \\\n     m4/transpose.m4 m4/eoshift1.m4 m4/eoshift3.m4 m4/exponent.m4 \\\n@@ -1492,6 +1489,7 @@ prereq_SRC = $(gfor_src) $(gfor_built_src) $(gfor_io_src) \\\n I_M4_DEPS = m4/iparm.m4\n I_M4_DEPS0 = $(I_M4_DEPS) m4/iforeach.m4\n I_M4_DEPS1 = $(I_M4_DEPS) m4/ifunction.m4\n+I_M4_DEPS2 = $(I_M4_DEPS) m4/ifunction_logical.m4\n EXTRA_DIST = $(m4_files)\n all: $(BUILT_SOURCES) config.h\n \t$(MAKE) $(AM_MAKEFLAGS) all-am\n@@ -1615,10 +1613,14 @@ distclean-compile:\n \n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/abort.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/access.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/all_l1.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/all_l16.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/all_l2.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/all_l4.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/all_l8.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/any_l1.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/any_l16.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/any_l2.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/any_l4.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/any_l8.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/args.Plo@am__quote@\n@@ -1630,15 +1632,11 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/clock.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/close.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/compile_options.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/count_16_l16.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/count_16_l4.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/count_16_l8.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/count_4_l16.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/count_4_l4.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/count_4_l8.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/count_8_l16.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/count_8_l4.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/count_8_l8.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/count_16_l.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/count_1_l.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/count_2_l.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/count_4_l.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/count_8_l.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu_time.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cshift0.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cshift1_16.Plo@am__quote@\n@@ -2502,6 +2500,20 @@ select.lo: runtime/select.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o select.lo `test -f 'runtime/select.c' || echo '$(srcdir)/'`runtime/select.c\n \n+all_l1.lo: $(srcdir)/generated/all_l1.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT all_l1.lo -MD -MP -MF \"$(DEPDIR)/all_l1.Tpo\" -c -o all_l1.lo `test -f '$(srcdir)/generated/all_l1.c' || echo '$(srcdir)/'`$(srcdir)/generated/all_l1.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/all_l1.Tpo\" \"$(DEPDIR)/all_l1.Plo\"; else rm -f \"$(DEPDIR)/all_l1.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/all_l1.c' object='all_l1.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o all_l1.lo `test -f '$(srcdir)/generated/all_l1.c' || echo '$(srcdir)/'`$(srcdir)/generated/all_l1.c\n+\n+all_l2.lo: $(srcdir)/generated/all_l2.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT all_l2.lo -MD -MP -MF \"$(DEPDIR)/all_l2.Tpo\" -c -o all_l2.lo `test -f '$(srcdir)/generated/all_l2.c' || echo '$(srcdir)/'`$(srcdir)/generated/all_l2.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/all_l2.Tpo\" \"$(DEPDIR)/all_l2.Plo\"; else rm -f \"$(DEPDIR)/all_l2.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/all_l2.c' object='all_l2.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o all_l2.lo `test -f '$(srcdir)/generated/all_l2.c' || echo '$(srcdir)/'`$(srcdir)/generated/all_l2.c\n+\n all_l4.lo: $(srcdir)/generated/all_l4.c\n @am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT all_l4.lo -MD -MP -MF \"$(DEPDIR)/all_l4.Tpo\" -c -o all_l4.lo `test -f '$(srcdir)/generated/all_l4.c' || echo '$(srcdir)/'`$(srcdir)/generated/all_l4.c; \\\n @am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/all_l4.Tpo\" \"$(DEPDIR)/all_l4.Plo\"; else rm -f \"$(DEPDIR)/all_l4.Tpo\"; exit 1; fi\n@@ -2523,6 +2535,20 @@ all_l16.lo: $(srcdir)/generated/all_l16.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o all_l16.lo `test -f '$(srcdir)/generated/all_l16.c' || echo '$(srcdir)/'`$(srcdir)/generated/all_l16.c\n \n+any_l1.lo: $(srcdir)/generated/any_l1.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT any_l1.lo -MD -MP -MF \"$(DEPDIR)/any_l1.Tpo\" -c -o any_l1.lo `test -f '$(srcdir)/generated/any_l1.c' || echo '$(srcdir)/'`$(srcdir)/generated/any_l1.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/any_l1.Tpo\" \"$(DEPDIR)/any_l1.Plo\"; else rm -f \"$(DEPDIR)/any_l1.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/any_l1.c' object='any_l1.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o any_l1.lo `test -f '$(srcdir)/generated/any_l1.c' || echo '$(srcdir)/'`$(srcdir)/generated/any_l1.c\n+\n+any_l2.lo: $(srcdir)/generated/any_l2.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT any_l2.lo -MD -MP -MF \"$(DEPDIR)/any_l2.Tpo\" -c -o any_l2.lo `test -f '$(srcdir)/generated/any_l2.c' || echo '$(srcdir)/'`$(srcdir)/generated/any_l2.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/any_l2.Tpo\" \"$(DEPDIR)/any_l2.Plo\"; else rm -f \"$(DEPDIR)/any_l2.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/any_l2.c' object='any_l2.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o any_l2.lo `test -f '$(srcdir)/generated/any_l2.c' || echo '$(srcdir)/'`$(srcdir)/generated/any_l2.c\n+\n any_l4.lo: $(srcdir)/generated/any_l4.c\n @am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT any_l4.lo -MD -MP -MF \"$(DEPDIR)/any_l4.Tpo\" -c -o any_l4.lo `test -f '$(srcdir)/generated/any_l4.c' || echo '$(srcdir)/'`$(srcdir)/generated/any_l4.c; \\\n @am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/any_l4.Tpo\" \"$(DEPDIR)/any_l4.Plo\"; else rm -f \"$(DEPDIR)/any_l4.Tpo\"; exit 1; fi\n@@ -2544,68 +2570,40 @@ any_l16.lo: $(srcdir)/generated/any_l16.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o any_l16.lo `test -f '$(srcdir)/generated/any_l16.c' || echo '$(srcdir)/'`$(srcdir)/generated/any_l16.c\n \n-count_4_l4.lo: $(srcdir)/generated/count_4_l4.c\n-@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT count_4_l4.lo -MD -MP -MF \"$(DEPDIR)/count_4_l4.Tpo\" -c -o count_4_l4.lo `test -f '$(srcdir)/generated/count_4_l4.c' || echo '$(srcdir)/'`$(srcdir)/generated/count_4_l4.c; \\\n-@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/count_4_l4.Tpo\" \"$(DEPDIR)/count_4_l4.Plo\"; else rm -f \"$(DEPDIR)/count_4_l4.Tpo\"; exit 1; fi\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/count_4_l4.c' object='count_4_l4.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o count_4_l4.lo `test -f '$(srcdir)/generated/count_4_l4.c' || echo '$(srcdir)/'`$(srcdir)/generated/count_4_l4.c\n-\n-count_8_l4.lo: $(srcdir)/generated/count_8_l4.c\n-@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT count_8_l4.lo -MD -MP -MF \"$(DEPDIR)/count_8_l4.Tpo\" -c -o count_8_l4.lo `test -f '$(srcdir)/generated/count_8_l4.c' || echo '$(srcdir)/'`$(srcdir)/generated/count_8_l4.c; \\\n-@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/count_8_l4.Tpo\" \"$(DEPDIR)/count_8_l4.Plo\"; else rm -f \"$(DEPDIR)/count_8_l4.Tpo\"; exit 1; fi\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/count_8_l4.c' object='count_8_l4.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o count_8_l4.lo `test -f '$(srcdir)/generated/count_8_l4.c' || echo '$(srcdir)/'`$(srcdir)/generated/count_8_l4.c\n-\n-count_16_l4.lo: $(srcdir)/generated/count_16_l4.c\n-@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT count_16_l4.lo -MD -MP -MF \"$(DEPDIR)/count_16_l4.Tpo\" -c -o count_16_l4.lo `test -f '$(srcdir)/generated/count_16_l4.c' || echo '$(srcdir)/'`$(srcdir)/generated/count_16_l4.c; \\\n-@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/count_16_l4.Tpo\" \"$(DEPDIR)/count_16_l4.Plo\"; else rm -f \"$(DEPDIR)/count_16_l4.Tpo\"; exit 1; fi\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/count_16_l4.c' object='count_16_l4.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o count_16_l4.lo `test -f '$(srcdir)/generated/count_16_l4.c' || echo '$(srcdir)/'`$(srcdir)/generated/count_16_l4.c\n-\n-count_4_l8.lo: $(srcdir)/generated/count_4_l8.c\n-@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT count_4_l8.lo -MD -MP -MF \"$(DEPDIR)/count_4_l8.Tpo\" -c -o count_4_l8.lo `test -f '$(srcdir)/generated/count_4_l8.c' || echo '$(srcdir)/'`$(srcdir)/generated/count_4_l8.c; \\\n-@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/count_4_l8.Tpo\" \"$(DEPDIR)/count_4_l8.Plo\"; else rm -f \"$(DEPDIR)/count_4_l8.Tpo\"; exit 1; fi\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/count_4_l8.c' object='count_4_l8.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o count_4_l8.lo `test -f '$(srcdir)/generated/count_4_l8.c' || echo '$(srcdir)/'`$(srcdir)/generated/count_4_l8.c\n-\n-count_8_l8.lo: $(srcdir)/generated/count_8_l8.c\n-@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT count_8_l8.lo -MD -MP -MF \"$(DEPDIR)/count_8_l8.Tpo\" -c -o count_8_l8.lo `test -f '$(srcdir)/generated/count_8_l8.c' || echo '$(srcdir)/'`$(srcdir)/generated/count_8_l8.c; \\\n-@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/count_8_l8.Tpo\" \"$(DEPDIR)/count_8_l8.Plo\"; else rm -f \"$(DEPDIR)/count_8_l8.Tpo\"; exit 1; fi\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/count_8_l8.c' object='count_8_l8.lo' libtool=yes @AMDEPBACKSLASH@\n+count_1_l.lo: $(srcdir)/generated/count_1_l.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT count_1_l.lo -MD -MP -MF \"$(DEPDIR)/count_1_l.Tpo\" -c -o count_1_l.lo `test -f '$(srcdir)/generated/count_1_l.c' || echo '$(srcdir)/'`$(srcdir)/generated/count_1_l.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/count_1_l.Tpo\" \"$(DEPDIR)/count_1_l.Plo\"; else rm -f \"$(DEPDIR)/count_1_l.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/count_1_l.c' object='count_1_l.lo' libtool=yes @AMDEPBACKSLASH@\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o count_8_l8.lo `test -f '$(srcdir)/generated/count_8_l8.c' || echo '$(srcdir)/'`$(srcdir)/generated/count_8_l8.c\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o count_1_l.lo `test -f '$(srcdir)/generated/count_1_l.c' || echo '$(srcdir)/'`$(srcdir)/generated/count_1_l.c\n \n-count_16_l8.lo: $(srcdir)/generated/count_16_l8.c\n-@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT count_16_l8.lo -MD -MP -MF \"$(DEPDIR)/count_16_l8.Tpo\" -c -o count_16_l8.lo `test -f '$(srcdir)/generated/count_16_l8.c' || echo '$(srcdir)/'`$(srcdir)/generated/count_16_l8.c; \\\n-@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/count_16_l8.Tpo\" \"$(DEPDIR)/count_16_l8.Plo\"; else rm -f \"$(DEPDIR)/count_16_l8.Tpo\"; exit 1; fi\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/count_16_l8.c' object='count_16_l8.lo' libtool=yes @AMDEPBACKSLASH@\n+count_2_l.lo: $(srcdir)/generated/count_2_l.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT count_2_l.lo -MD -MP -MF \"$(DEPDIR)/count_2_l.Tpo\" -c -o count_2_l.lo `test -f '$(srcdir)/generated/count_2_l.c' || echo '$(srcdir)/'`$(srcdir)/generated/count_2_l.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/count_2_l.Tpo\" \"$(DEPDIR)/count_2_l.Plo\"; else rm -f \"$(DEPDIR)/count_2_l.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/count_2_l.c' object='count_2_l.lo' libtool=yes @AMDEPBACKSLASH@\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o count_16_l8.lo `test -f '$(srcdir)/generated/count_16_l8.c' || echo '$(srcdir)/'`$(srcdir)/generated/count_16_l8.c\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o count_2_l.lo `test -f '$(srcdir)/generated/count_2_l.c' || echo '$(srcdir)/'`$(srcdir)/generated/count_2_l.c\n \n-count_4_l16.lo: $(srcdir)/generated/count_4_l16.c\n-@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT count_4_l16.lo -MD -MP -MF \"$(DEPDIR)/count_4_l16.Tpo\" -c -o count_4_l16.lo `test -f '$(srcdir)/generated/count_4_l16.c' || echo '$(srcdir)/'`$(srcdir)/generated/count_4_l16.c; \\\n-@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/count_4_l16.Tpo\" \"$(DEPDIR)/count_4_l16.Plo\"; else rm -f \"$(DEPDIR)/count_4_l16.Tpo\"; exit 1; fi\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/count_4_l16.c' object='count_4_l16.lo' libtool=yes @AMDEPBACKSLASH@\n+count_4_l.lo: $(srcdir)/generated/count_4_l.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT count_4_l.lo -MD -MP -MF \"$(DEPDIR)/count_4_l.Tpo\" -c -o count_4_l.lo `test -f '$(srcdir)/generated/count_4_l.c' || echo '$(srcdir)/'`$(srcdir)/generated/count_4_l.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/count_4_l.Tpo\" \"$(DEPDIR)/count_4_l.Plo\"; else rm -f \"$(DEPDIR)/count_4_l.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/count_4_l.c' object='count_4_l.lo' libtool=yes @AMDEPBACKSLASH@\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o count_4_l16.lo `test -f '$(srcdir)/generated/count_4_l16.c' || echo '$(srcdir)/'`$(srcdir)/generated/count_4_l16.c\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o count_4_l.lo `test -f '$(srcdir)/generated/count_4_l.c' || echo '$(srcdir)/'`$(srcdir)/generated/count_4_l.c\n \n-count_8_l16.lo: $(srcdir)/generated/count_8_l16.c\n-@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT count_8_l16.lo -MD -MP -MF \"$(DEPDIR)/count_8_l16.Tpo\" -c -o count_8_l16.lo `test -f '$(srcdir)/generated/count_8_l16.c' || echo '$(srcdir)/'`$(srcdir)/generated/count_8_l16.c; \\\n-@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/count_8_l16.Tpo\" \"$(DEPDIR)/count_8_l16.Plo\"; else rm -f \"$(DEPDIR)/count_8_l16.Tpo\"; exit 1; fi\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/count_8_l16.c' object='count_8_l16.lo' libtool=yes @AMDEPBACKSLASH@\n+count_8_l.lo: $(srcdir)/generated/count_8_l.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT count_8_l.lo -MD -MP -MF \"$(DEPDIR)/count_8_l.Tpo\" -c -o count_8_l.lo `test -f '$(srcdir)/generated/count_8_l.c' || echo '$(srcdir)/'`$(srcdir)/generated/count_8_l.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/count_8_l.Tpo\" \"$(DEPDIR)/count_8_l.Plo\"; else rm -f \"$(DEPDIR)/count_8_l.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/count_8_l.c' object='count_8_l.lo' libtool=yes @AMDEPBACKSLASH@\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o count_8_l16.lo `test -f '$(srcdir)/generated/count_8_l16.c' || echo '$(srcdir)/'`$(srcdir)/generated/count_8_l16.c\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o count_8_l.lo `test -f '$(srcdir)/generated/count_8_l.c' || echo '$(srcdir)/'`$(srcdir)/generated/count_8_l.c\n \n-count_16_l16.lo: $(srcdir)/generated/count_16_l16.c\n-@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT count_16_l16.lo -MD -MP -MF \"$(DEPDIR)/count_16_l16.Tpo\" -c -o count_16_l16.lo `test -f '$(srcdir)/generated/count_16_l16.c' || echo '$(srcdir)/'`$(srcdir)/generated/count_16_l16.c; \\\n-@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/count_16_l16.Tpo\" \"$(DEPDIR)/count_16_l16.Plo\"; else rm -f \"$(DEPDIR)/count_16_l16.Tpo\"; exit 1; fi\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/count_16_l16.c' object='count_16_l16.lo' libtool=yes @AMDEPBACKSLASH@\n+count_16_l.lo: $(srcdir)/generated/count_16_l.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT count_16_l.lo -MD -MP -MF \"$(DEPDIR)/count_16_l.Tpo\" -c -o count_16_l.lo `test -f '$(srcdir)/generated/count_16_l.c' || echo '$(srcdir)/'`$(srcdir)/generated/count_16_l.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/count_16_l.Tpo\" \"$(DEPDIR)/count_16_l.Plo\"; else rm -f \"$(DEPDIR)/count_16_l.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/count_16_l.c' object='count_16_l.lo' libtool=yes @AMDEPBACKSLASH@\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o count_16_l16.lo `test -f '$(srcdir)/generated/count_16_l16.c' || echo '$(srcdir)/'`$(srcdir)/generated/count_16_l16.c\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o count_16_l.lo `test -f '$(srcdir)/generated/count_16_l.c' || echo '$(srcdir)/'`$(srcdir)/generated/count_16_l.c\n \n maxloc0_4_i1.lo: $(srcdir)/generated/maxloc0_4_i1.c\n @am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT maxloc0_4_i1.lo -MD -MP -MF \"$(DEPDIR)/maxloc0_4_i1.Tpo\" -c -o maxloc0_4_i1.lo `test -f '$(srcdir)/generated/maxloc0_4_i1.c' || echo '$(srcdir)/'`$(srcdir)/generated/maxloc0_4_i1.c; \\\n@@ -5350,13 +5348,13 @@ selected_real_kind.inc: $(srcdir)/mk-srk-inc.sh\n fpu-target.h: $(srcdir)/$(FPU_HOST_HEADER)\n \tcp $(srcdir)/$(FPU_HOST_HEADER) $@\n \n-@MAINTAINER_MODE_TRUE@$(i_all_c): m4/all.m4 $(I_M4_DEPS1)\n+@MAINTAINER_MODE_TRUE@$(i_all_c): m4/all.m4 $(I_M4_DEPS2)\n @MAINTAINER_MODE_TRUE@\t$(M4) -Dfile=$@ -I$(srcdir)/m4 all.m4 > $@\n \n-@MAINTAINER_MODE_TRUE@$(i_any_c): m4/any.m4 $(I_M4_DEPS1)\n+@MAINTAINER_MODE_TRUE@$(i_any_c): m4/any.m4 $(I_M4_DEPS2)\n @MAINTAINER_MODE_TRUE@\t$(M4) -Dfile=$@ -I$(srcdir)/m4 any.m4 > $@\n \n-@MAINTAINER_MODE_TRUE@$(i_count_c): m4/count.m4 $(I_M4_DEPS1)\n+@MAINTAINER_MODE_TRUE@$(i_count_c): m4/count.m4 $(I_M4_DEPS2)\n @MAINTAINER_MODE_TRUE@\t$(M4) -Dfile=$@ -I$(srcdir)/m4 count.m4 > $@\n \n @MAINTAINER_MODE_TRUE@$(i_maxloc0_c): m4/maxloc0.m4 $(I_M4_DEPS0)"}, {"sha": "47cf2220d339c70bf1a1dabc54003dd4a679897a", "filename": "libgfortran/generated/all_l1.c", "status": "added", "additions": 222, "deletions": 0, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90469382c09fb5ed5602c30490d117aff172f7c2/libgfortran%2Fgenerated%2Fall_l1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90469382c09fb5ed5602c30490d117aff172f7c2/libgfortran%2Fgenerated%2Fall_l1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fall_l1.c?ref=90469382c09fb5ed5602c30490d117aff172f7c2", "patch": "@@ -0,0 +1,222 @@\n+/* Implementation of the ALL intrinsic\n+   Copyright 2002, 2007 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+\n+#if defined (HAVE_GFC_LOGICAL_1)\n+\n+\n+extern void all_l1 (gfc_array_l1 * const restrict, \n+\tgfc_array_l1 * const restrict, const index_type * const restrict);\n+export_proto(all_l1);\n+\n+void\n+all_l1 (gfc_array_l1 * const restrict retarray, \n+\tgfc_array_l1 * const restrict array, \n+\tconst index_type * const restrict pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_LOGICAL_1 * restrict base;\n+  GFC_LOGICAL_1 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int src_kind;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  src_kind = GFC_DESCRIPTOR_SIZE (array);\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  delta = array->dim[dim].stride * src_kind;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride * src_kind;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride * src_kind;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_LOGICAL_1) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" ALL intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" ALL intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        len = 0;\n+    }\n+\n+  base = array->data;\n+\n+  if (src_kind == 1 || src_kind == 2 || src_kind == 4 || src_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || src_kind == 16\n+#endif\n+    )\n+    {\n+      if (base)\n+\tbase = GFOR_POINTER_TO_L1 (base, src_kind);\n+    }\n+  else\n+    internal_error (NULL, \"Funny sized logical array in ALL intrinsic\");\n+\n+  dest = retarray->data;\n+\n+  while (base)\n+    {\n+      const GFC_LOGICAL_1 * restrict src;\n+      GFC_LOGICAL_1 result;\n+      src = base;\n+      {\n+\n+  /* Return true only if all the elements are set.  */\n+  result = 1;\n+        if (len <= 0)\n+\t  *dest = 1;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+  if (! *src)\n+    {\n+      result = 0;\n+      break;\n+    }\n+          }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "ca147e7d39fcc0b26b11fd872f8c8f4f793fa54d", "filename": "libgfortran/generated/all_l16.c", "status": "modified", "additions": 28, "deletions": 13, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90469382c09fb5ed5602c30490d117aff172f7c2/libgfortran%2Fgenerated%2Fall_l16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90469382c09fb5ed5602c30490d117aff172f7c2/libgfortran%2Fgenerated%2Fall_l16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fall_l16.c?ref=90469382c09fb5ed5602c30490d117aff172f7c2", "patch": "@@ -33,48 +33,51 @@ Boston, MA 02110-1301, USA.  */\n #include <assert.h>\n \n \n-#if defined (HAVE_GFC_LOGICAL_16) && defined (HAVE_GFC_LOGICAL_16)\n+#if defined (HAVE_GFC_LOGICAL_16)\n \n \n extern void all_l16 (gfc_array_l16 * const restrict, \n-\tgfc_array_l16 * const restrict, const index_type * const restrict);\n+\tgfc_array_l1 * const restrict, const index_type * const restrict);\n export_proto(all_l16);\n \n void\n all_l16 (gfc_array_l16 * const restrict retarray, \n-\tgfc_array_l16 * const restrict array, \n+\tgfc_array_l1 * const restrict array, \n \tconst index_type * const restrict pdim)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n   index_type sstride[GFC_MAX_DIMENSIONS];\n   index_type dstride[GFC_MAX_DIMENSIONS];\n-  const GFC_LOGICAL_16 * restrict base;\n+  const GFC_LOGICAL_1 * restrict base;\n   GFC_LOGICAL_16 * restrict dest;\n   index_type rank;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type dim;\n+  int src_kind;\n \n   /* Make dim zero based to avoid confusion.  */\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n+  src_kind = GFC_DESCRIPTOR_SIZE (array);\n+\n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n-  delta = array->dim[dim].stride;\n+  delta = array->dim[dim].stride * src_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n+      sstride[n] = array->dim[n].stride * src_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n+      sstride[n] = array->dim[n + 1].stride * src_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -116,9 +119,8 @@ all_l16 (gfc_array_l16 * const restrict retarray,\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n \truntime_error (\"rank of return array incorrect in\"\n-\t\t       \" ALL intrinsic: is %ld, should be %ld\",\n-\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n-\t\t       (long int) rank);\n+\t\t       \" ALL intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n \n       if (compile_options.bounds_check)\n \t{\n@@ -130,8 +132,8 @@ all_l16 (gfc_array_l16 * const restrict retarray,\n \t\t- retarray->dim[n].lbound;\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" ALL intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       \" ALL intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n \t\t\t       (long int) ret_extent, (long int) extent[n]);\n \t    }\n \t}\n@@ -146,11 +148,24 @@ all_l16 (gfc_array_l16 * const restrict retarray,\n     }\n \n   base = array->data;\n+\n+  if (src_kind == 1 || src_kind == 2 || src_kind == 4 || src_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || src_kind == 16\n+#endif\n+    )\n+    {\n+      if (base)\n+\tbase = GFOR_POINTER_TO_L1 (base, src_kind);\n+    }\n+  else\n+    internal_error (NULL, \"Funny sized logical array in ALL intrinsic\");\n+\n   dest = retarray->data;\n \n   while (base)\n     {\n-      const GFC_LOGICAL_16 * restrict src;\n+      const GFC_LOGICAL_1 * restrict src;\n       GFC_LOGICAL_16 result;\n       src = base;\n       {"}, {"sha": "9e4ab72b30cdfab6d001b02fe3811b626dfae8cf", "filename": "libgfortran/generated/all_l2.c", "status": "added", "additions": 222, "deletions": 0, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90469382c09fb5ed5602c30490d117aff172f7c2/libgfortran%2Fgenerated%2Fall_l2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90469382c09fb5ed5602c30490d117aff172f7c2/libgfortran%2Fgenerated%2Fall_l2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fall_l2.c?ref=90469382c09fb5ed5602c30490d117aff172f7c2", "patch": "@@ -0,0 +1,222 @@\n+/* Implementation of the ALL intrinsic\n+   Copyright 2002, 2007 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+\n+#if defined (HAVE_GFC_LOGICAL_2)\n+\n+\n+extern void all_l2 (gfc_array_l2 * const restrict, \n+\tgfc_array_l1 * const restrict, const index_type * const restrict);\n+export_proto(all_l2);\n+\n+void\n+all_l2 (gfc_array_l2 * const restrict retarray, \n+\tgfc_array_l1 * const restrict array, \n+\tconst index_type * const restrict pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_LOGICAL_1 * restrict base;\n+  GFC_LOGICAL_2 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int src_kind;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  src_kind = GFC_DESCRIPTOR_SIZE (array);\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  delta = array->dim[dim].stride * src_kind;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride * src_kind;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride * src_kind;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_LOGICAL_2) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" ALL intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" ALL intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        len = 0;\n+    }\n+\n+  base = array->data;\n+\n+  if (src_kind == 1 || src_kind == 2 || src_kind == 4 || src_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || src_kind == 16\n+#endif\n+    )\n+    {\n+      if (base)\n+\tbase = GFOR_POINTER_TO_L1 (base, src_kind);\n+    }\n+  else\n+    internal_error (NULL, \"Funny sized logical array in ALL intrinsic\");\n+\n+  dest = retarray->data;\n+\n+  while (base)\n+    {\n+      const GFC_LOGICAL_1 * restrict src;\n+      GFC_LOGICAL_2 result;\n+      src = base;\n+      {\n+\n+  /* Return true only if all the elements are set.  */\n+  result = 1;\n+        if (len <= 0)\n+\t  *dest = 1;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+  if (! *src)\n+    {\n+      result = 0;\n+      break;\n+    }\n+          }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "255881b9112808d28539901e6541efd681f3315a", "filename": "libgfortran/generated/all_l4.c", "status": "modified", "additions": 28, "deletions": 13, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90469382c09fb5ed5602c30490d117aff172f7c2/libgfortran%2Fgenerated%2Fall_l4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90469382c09fb5ed5602c30490d117aff172f7c2/libgfortran%2Fgenerated%2Fall_l4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fall_l4.c?ref=90469382c09fb5ed5602c30490d117aff172f7c2", "patch": "@@ -33,48 +33,51 @@ Boston, MA 02110-1301, USA.  */\n #include <assert.h>\n \n \n-#if defined (HAVE_GFC_LOGICAL_4) && defined (HAVE_GFC_LOGICAL_4)\n+#if defined (HAVE_GFC_LOGICAL_4)\n \n \n extern void all_l4 (gfc_array_l4 * const restrict, \n-\tgfc_array_l4 * const restrict, const index_type * const restrict);\n+\tgfc_array_l1 * const restrict, const index_type * const restrict);\n export_proto(all_l4);\n \n void\n all_l4 (gfc_array_l4 * const restrict retarray, \n-\tgfc_array_l4 * const restrict array, \n+\tgfc_array_l1 * const restrict array, \n \tconst index_type * const restrict pdim)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n   index_type sstride[GFC_MAX_DIMENSIONS];\n   index_type dstride[GFC_MAX_DIMENSIONS];\n-  const GFC_LOGICAL_4 * restrict base;\n+  const GFC_LOGICAL_1 * restrict base;\n   GFC_LOGICAL_4 * restrict dest;\n   index_type rank;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type dim;\n+  int src_kind;\n \n   /* Make dim zero based to avoid confusion.  */\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n+  src_kind = GFC_DESCRIPTOR_SIZE (array);\n+\n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n-  delta = array->dim[dim].stride;\n+  delta = array->dim[dim].stride * src_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n+      sstride[n] = array->dim[n].stride * src_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n+      sstride[n] = array->dim[n + 1].stride * src_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -116,9 +119,8 @@ all_l4 (gfc_array_l4 * const restrict retarray,\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n \truntime_error (\"rank of return array incorrect in\"\n-\t\t       \" ALL intrinsic: is %ld, should be %ld\",\n-\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n-\t\t       (long int) rank);\n+\t\t       \" ALL intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n \n       if (compile_options.bounds_check)\n \t{\n@@ -130,8 +132,8 @@ all_l4 (gfc_array_l4 * const restrict retarray,\n \t\t- retarray->dim[n].lbound;\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" ALL intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       \" ALL intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n \t\t\t       (long int) ret_extent, (long int) extent[n]);\n \t    }\n \t}\n@@ -146,11 +148,24 @@ all_l4 (gfc_array_l4 * const restrict retarray,\n     }\n \n   base = array->data;\n+\n+  if (src_kind == 1 || src_kind == 2 || src_kind == 4 || src_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || src_kind == 16\n+#endif\n+    )\n+    {\n+      if (base)\n+\tbase = GFOR_POINTER_TO_L1 (base, src_kind);\n+    }\n+  else\n+    internal_error (NULL, \"Funny sized logical array in ALL intrinsic\");\n+\n   dest = retarray->data;\n \n   while (base)\n     {\n-      const GFC_LOGICAL_4 * restrict src;\n+      const GFC_LOGICAL_1 * restrict src;\n       GFC_LOGICAL_4 result;\n       src = base;\n       {"}, {"sha": "00ba59f10341b231a1455119217d9acada71261e", "filename": "libgfortran/generated/all_l8.c", "status": "modified", "additions": 28, "deletions": 13, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90469382c09fb5ed5602c30490d117aff172f7c2/libgfortran%2Fgenerated%2Fall_l8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90469382c09fb5ed5602c30490d117aff172f7c2/libgfortran%2Fgenerated%2Fall_l8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fall_l8.c?ref=90469382c09fb5ed5602c30490d117aff172f7c2", "patch": "@@ -33,48 +33,51 @@ Boston, MA 02110-1301, USA.  */\n #include <assert.h>\n \n \n-#if defined (HAVE_GFC_LOGICAL_8) && defined (HAVE_GFC_LOGICAL_8)\n+#if defined (HAVE_GFC_LOGICAL_8)\n \n \n extern void all_l8 (gfc_array_l8 * const restrict, \n-\tgfc_array_l8 * const restrict, const index_type * const restrict);\n+\tgfc_array_l1 * const restrict, const index_type * const restrict);\n export_proto(all_l8);\n \n void\n all_l8 (gfc_array_l8 * const restrict retarray, \n-\tgfc_array_l8 * const restrict array, \n+\tgfc_array_l1 * const restrict array, \n \tconst index_type * const restrict pdim)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n   index_type sstride[GFC_MAX_DIMENSIONS];\n   index_type dstride[GFC_MAX_DIMENSIONS];\n-  const GFC_LOGICAL_8 * restrict base;\n+  const GFC_LOGICAL_1 * restrict base;\n   GFC_LOGICAL_8 * restrict dest;\n   index_type rank;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type dim;\n+  int src_kind;\n \n   /* Make dim zero based to avoid confusion.  */\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n+  src_kind = GFC_DESCRIPTOR_SIZE (array);\n+\n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n-  delta = array->dim[dim].stride;\n+  delta = array->dim[dim].stride * src_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n+      sstride[n] = array->dim[n].stride * src_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n+      sstride[n] = array->dim[n + 1].stride * src_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -116,9 +119,8 @@ all_l8 (gfc_array_l8 * const restrict retarray,\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n \truntime_error (\"rank of return array incorrect in\"\n-\t\t       \" ALL intrinsic: is %ld, should be %ld\",\n-\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n-\t\t       (long int) rank);\n+\t\t       \" ALL intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n \n       if (compile_options.bounds_check)\n \t{\n@@ -130,8 +132,8 @@ all_l8 (gfc_array_l8 * const restrict retarray,\n \t\t- retarray->dim[n].lbound;\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" ALL intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       \" ALL intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n \t\t\t       (long int) ret_extent, (long int) extent[n]);\n \t    }\n \t}\n@@ -146,11 +148,24 @@ all_l8 (gfc_array_l8 * const restrict retarray,\n     }\n \n   base = array->data;\n+\n+  if (src_kind == 1 || src_kind == 2 || src_kind == 4 || src_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || src_kind == 16\n+#endif\n+    )\n+    {\n+      if (base)\n+\tbase = GFOR_POINTER_TO_L1 (base, src_kind);\n+    }\n+  else\n+    internal_error (NULL, \"Funny sized logical array in ALL intrinsic\");\n+\n   dest = retarray->data;\n \n   while (base)\n     {\n-      const GFC_LOGICAL_8 * restrict src;\n+      const GFC_LOGICAL_1 * restrict src;\n       GFC_LOGICAL_8 result;\n       src = base;\n       {"}, {"sha": "9781a43c2cbd458ae3543a3ba318ad3acfbff254", "filename": "libgfortran/generated/any_l1.c", "status": "added", "additions": 222, "deletions": 0, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90469382c09fb5ed5602c30490d117aff172f7c2/libgfortran%2Fgenerated%2Fany_l1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90469382c09fb5ed5602c30490d117aff172f7c2/libgfortran%2Fgenerated%2Fany_l1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fany_l1.c?ref=90469382c09fb5ed5602c30490d117aff172f7c2", "patch": "@@ -0,0 +1,222 @@\n+/* Implementation of the ANY intrinsic\n+   Copyright 2002, 2007 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+\n+#if defined (HAVE_GFC_LOGICAL_1)\n+\n+\n+extern void any_l1 (gfc_array_l1 * const restrict, \n+\tgfc_array_l1 * const restrict, const index_type * const restrict);\n+export_proto(any_l1);\n+\n+void\n+any_l1 (gfc_array_l1 * const restrict retarray, \n+\tgfc_array_l1 * const restrict array, \n+\tconst index_type * const restrict pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_LOGICAL_1 * restrict base;\n+  GFC_LOGICAL_1 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int src_kind;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  src_kind = GFC_DESCRIPTOR_SIZE (array);\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  delta = array->dim[dim].stride * src_kind;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride * src_kind;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride * src_kind;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_LOGICAL_1) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" ANY intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" ANY intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        len = 0;\n+    }\n+\n+  base = array->data;\n+\n+  if (src_kind == 1 || src_kind == 2 || src_kind == 4 || src_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || src_kind == 16\n+#endif\n+    )\n+    {\n+      if (base)\n+\tbase = GFOR_POINTER_TO_L1 (base, src_kind);\n+    }\n+  else\n+    internal_error (NULL, \"Funny sized logical array in ANY intrinsic\");\n+\n+  dest = retarray->data;\n+\n+  while (base)\n+    {\n+      const GFC_LOGICAL_1 * restrict src;\n+      GFC_LOGICAL_1 result;\n+      src = base;\n+      {\n+\n+  result = 0;\n+        if (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+  /* Return true if any of the elements are set.  */\n+  if (*src)\n+    {\n+      result = 1;\n+      break;\n+    }\n+          }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "b0e95a6dad6e1d0bc0b3e7179cae10de3d7a30c5", "filename": "libgfortran/generated/any_l16.c", "status": "modified", "additions": 28, "deletions": 13, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90469382c09fb5ed5602c30490d117aff172f7c2/libgfortran%2Fgenerated%2Fany_l16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90469382c09fb5ed5602c30490d117aff172f7c2/libgfortran%2Fgenerated%2Fany_l16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fany_l16.c?ref=90469382c09fb5ed5602c30490d117aff172f7c2", "patch": "@@ -33,48 +33,51 @@ Boston, MA 02110-1301, USA.  */\n #include <assert.h>\n \n \n-#if defined (HAVE_GFC_LOGICAL_16) && defined (HAVE_GFC_LOGICAL_16)\n+#if defined (HAVE_GFC_LOGICAL_16)\n \n \n extern void any_l16 (gfc_array_l16 * const restrict, \n-\tgfc_array_l16 * const restrict, const index_type * const restrict);\n+\tgfc_array_l1 * const restrict, const index_type * const restrict);\n export_proto(any_l16);\n \n void\n any_l16 (gfc_array_l16 * const restrict retarray, \n-\tgfc_array_l16 * const restrict array, \n+\tgfc_array_l1 * const restrict array, \n \tconst index_type * const restrict pdim)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n   index_type sstride[GFC_MAX_DIMENSIONS];\n   index_type dstride[GFC_MAX_DIMENSIONS];\n-  const GFC_LOGICAL_16 * restrict base;\n+  const GFC_LOGICAL_1 * restrict base;\n   GFC_LOGICAL_16 * restrict dest;\n   index_type rank;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type dim;\n+  int src_kind;\n \n   /* Make dim zero based to avoid confusion.  */\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n+  src_kind = GFC_DESCRIPTOR_SIZE (array);\n+\n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n-  delta = array->dim[dim].stride;\n+  delta = array->dim[dim].stride * src_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n+      sstride[n] = array->dim[n].stride * src_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n+      sstride[n] = array->dim[n + 1].stride * src_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -116,9 +119,8 @@ any_l16 (gfc_array_l16 * const restrict retarray,\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n \truntime_error (\"rank of return array incorrect in\"\n-\t\t       \" ANY intrinsic: is %ld, should be %ld\",\n-\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n-\t\t       (long int) rank);\n+\t\t       \" ANY intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n \n       if (compile_options.bounds_check)\n \t{\n@@ -130,8 +132,8 @@ any_l16 (gfc_array_l16 * const restrict retarray,\n \t\t- retarray->dim[n].lbound;\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" ANY intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       \" ANY intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n \t\t\t       (long int) ret_extent, (long int) extent[n]);\n \t    }\n \t}\n@@ -146,11 +148,24 @@ any_l16 (gfc_array_l16 * const restrict retarray,\n     }\n \n   base = array->data;\n+\n+  if (src_kind == 1 || src_kind == 2 || src_kind == 4 || src_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || src_kind == 16\n+#endif\n+    )\n+    {\n+      if (base)\n+\tbase = GFOR_POINTER_TO_L1 (base, src_kind);\n+    }\n+  else\n+    internal_error (NULL, \"Funny sized logical array in ANY intrinsic\");\n+\n   dest = retarray->data;\n \n   while (base)\n     {\n-      const GFC_LOGICAL_16 * restrict src;\n+      const GFC_LOGICAL_1 * restrict src;\n       GFC_LOGICAL_16 result;\n       src = base;\n       {"}, {"sha": "6a42be0fcbcf18154028be46fd3c7deec24a22ad", "filename": "libgfortran/generated/any_l2.c", "status": "added", "additions": 222, "deletions": 0, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90469382c09fb5ed5602c30490d117aff172f7c2/libgfortran%2Fgenerated%2Fany_l2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90469382c09fb5ed5602c30490d117aff172f7c2/libgfortran%2Fgenerated%2Fany_l2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fany_l2.c?ref=90469382c09fb5ed5602c30490d117aff172f7c2", "patch": "@@ -0,0 +1,222 @@\n+/* Implementation of the ANY intrinsic\n+   Copyright 2002, 2007 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+\n+#if defined (HAVE_GFC_LOGICAL_2)\n+\n+\n+extern void any_l2 (gfc_array_l2 * const restrict, \n+\tgfc_array_l1 * const restrict, const index_type * const restrict);\n+export_proto(any_l2);\n+\n+void\n+any_l2 (gfc_array_l2 * const restrict retarray, \n+\tgfc_array_l1 * const restrict array, \n+\tconst index_type * const restrict pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_LOGICAL_1 * restrict base;\n+  GFC_LOGICAL_2 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int src_kind;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  src_kind = GFC_DESCRIPTOR_SIZE (array);\n+\n+  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+  delta = array->dim[dim].stride * src_kind;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride * src_kind;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride * src_kind;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_LOGICAL_2) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" ANY intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" ANY intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+      if (extent[n] <= 0)\n+        len = 0;\n+    }\n+\n+  base = array->data;\n+\n+  if (src_kind == 1 || src_kind == 2 || src_kind == 4 || src_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || src_kind == 16\n+#endif\n+    )\n+    {\n+      if (base)\n+\tbase = GFOR_POINTER_TO_L1 (base, src_kind);\n+    }\n+  else\n+    internal_error (NULL, \"Funny sized logical array in ANY intrinsic\");\n+\n+  dest = retarray->data;\n+\n+  while (base)\n+    {\n+      const GFC_LOGICAL_1 * restrict src;\n+      GFC_LOGICAL_2 result;\n+      src = base;\n+      {\n+\n+  result = 0;\n+        if (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+  /* Return true if any of the elements are set.  */\n+  if (*src)\n+    {\n+      result = 1;\n+      break;\n+    }\n+          }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          base -= sstride[n] * extent[n];\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+            {\n+              /* Break out of the look.  */\n+              base = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              base += sstride[n];\n+              dest += dstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "eb3729690305314fd00369d4a1593ddb148e822c", "filename": "libgfortran/generated/any_l4.c", "status": "modified", "additions": 28, "deletions": 13, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90469382c09fb5ed5602c30490d117aff172f7c2/libgfortran%2Fgenerated%2Fany_l4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90469382c09fb5ed5602c30490d117aff172f7c2/libgfortran%2Fgenerated%2Fany_l4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fany_l4.c?ref=90469382c09fb5ed5602c30490d117aff172f7c2", "patch": "@@ -33,48 +33,51 @@ Boston, MA 02110-1301, USA.  */\n #include <assert.h>\n \n \n-#if defined (HAVE_GFC_LOGICAL_4) && defined (HAVE_GFC_LOGICAL_4)\n+#if defined (HAVE_GFC_LOGICAL_4)\n \n \n extern void any_l4 (gfc_array_l4 * const restrict, \n-\tgfc_array_l4 * const restrict, const index_type * const restrict);\n+\tgfc_array_l1 * const restrict, const index_type * const restrict);\n export_proto(any_l4);\n \n void\n any_l4 (gfc_array_l4 * const restrict retarray, \n-\tgfc_array_l4 * const restrict array, \n+\tgfc_array_l1 * const restrict array, \n \tconst index_type * const restrict pdim)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n   index_type sstride[GFC_MAX_DIMENSIONS];\n   index_type dstride[GFC_MAX_DIMENSIONS];\n-  const GFC_LOGICAL_4 * restrict base;\n+  const GFC_LOGICAL_1 * restrict base;\n   GFC_LOGICAL_4 * restrict dest;\n   index_type rank;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type dim;\n+  int src_kind;\n \n   /* Make dim zero based to avoid confusion.  */\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n+  src_kind = GFC_DESCRIPTOR_SIZE (array);\n+\n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n-  delta = array->dim[dim].stride;\n+  delta = array->dim[dim].stride * src_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n+      sstride[n] = array->dim[n].stride * src_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n+      sstride[n] = array->dim[n + 1].stride * src_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -116,9 +119,8 @@ any_l4 (gfc_array_l4 * const restrict retarray,\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n \truntime_error (\"rank of return array incorrect in\"\n-\t\t       \" ANY intrinsic: is %ld, should be %ld\",\n-\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n-\t\t       (long int) rank);\n+\t\t       \" ANY intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n \n       if (compile_options.bounds_check)\n \t{\n@@ -130,8 +132,8 @@ any_l4 (gfc_array_l4 * const restrict retarray,\n \t\t- retarray->dim[n].lbound;\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" ANY intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       \" ANY intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n \t\t\t       (long int) ret_extent, (long int) extent[n]);\n \t    }\n \t}\n@@ -146,11 +148,24 @@ any_l4 (gfc_array_l4 * const restrict retarray,\n     }\n \n   base = array->data;\n+\n+  if (src_kind == 1 || src_kind == 2 || src_kind == 4 || src_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || src_kind == 16\n+#endif\n+    )\n+    {\n+      if (base)\n+\tbase = GFOR_POINTER_TO_L1 (base, src_kind);\n+    }\n+  else\n+    internal_error (NULL, \"Funny sized logical array in ANY intrinsic\");\n+\n   dest = retarray->data;\n \n   while (base)\n     {\n-      const GFC_LOGICAL_4 * restrict src;\n+      const GFC_LOGICAL_1 * restrict src;\n       GFC_LOGICAL_4 result;\n       src = base;\n       {"}, {"sha": "b5b52a0b81b59f3920f2f690eb7fd069e35b614e", "filename": "libgfortran/generated/any_l8.c", "status": "modified", "additions": 28, "deletions": 13, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90469382c09fb5ed5602c30490d117aff172f7c2/libgfortran%2Fgenerated%2Fany_l8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90469382c09fb5ed5602c30490d117aff172f7c2/libgfortran%2Fgenerated%2Fany_l8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fany_l8.c?ref=90469382c09fb5ed5602c30490d117aff172f7c2", "patch": "@@ -33,48 +33,51 @@ Boston, MA 02110-1301, USA.  */\n #include <assert.h>\n \n \n-#if defined (HAVE_GFC_LOGICAL_8) && defined (HAVE_GFC_LOGICAL_8)\n+#if defined (HAVE_GFC_LOGICAL_8)\n \n \n extern void any_l8 (gfc_array_l8 * const restrict, \n-\tgfc_array_l8 * const restrict, const index_type * const restrict);\n+\tgfc_array_l1 * const restrict, const index_type * const restrict);\n export_proto(any_l8);\n \n void\n any_l8 (gfc_array_l8 * const restrict retarray, \n-\tgfc_array_l8 * const restrict array, \n+\tgfc_array_l1 * const restrict array, \n \tconst index_type * const restrict pdim)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n   index_type sstride[GFC_MAX_DIMENSIONS];\n   index_type dstride[GFC_MAX_DIMENSIONS];\n-  const GFC_LOGICAL_8 * restrict base;\n+  const GFC_LOGICAL_1 * restrict base;\n   GFC_LOGICAL_8 * restrict dest;\n   index_type rank;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type dim;\n+  int src_kind;\n \n   /* Make dim zero based to avoid confusion.  */\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n+  src_kind = GFC_DESCRIPTOR_SIZE (array);\n+\n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n-  delta = array->dim[dim].stride;\n+  delta = array->dim[dim].stride * src_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n+      sstride[n] = array->dim[n].stride * src_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n+      sstride[n] = array->dim[n + 1].stride * src_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -116,9 +119,8 @@ any_l8 (gfc_array_l8 * const restrict retarray,\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n \truntime_error (\"rank of return array incorrect in\"\n-\t\t       \" ANY intrinsic: is %ld, should be %ld\",\n-\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n-\t\t       (long int) rank);\n+\t\t       \" ANY intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n \n       if (compile_options.bounds_check)\n \t{\n@@ -130,8 +132,8 @@ any_l8 (gfc_array_l8 * const restrict retarray,\n \t\t- retarray->dim[n].lbound;\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" ANY intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       \" ANY intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n \t\t\t       (long int) ret_extent, (long int) extent[n]);\n \t    }\n \t}\n@@ -146,11 +148,24 @@ any_l8 (gfc_array_l8 * const restrict retarray,\n     }\n \n   base = array->data;\n+\n+  if (src_kind == 1 || src_kind == 2 || src_kind == 4 || src_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || src_kind == 16\n+#endif\n+    )\n+    {\n+      if (base)\n+\tbase = GFOR_POINTER_TO_L1 (base, src_kind);\n+    }\n+  else\n+    internal_error (NULL, \"Funny sized logical array in ANY intrinsic\");\n+\n   dest = retarray->data;\n \n   while (base)\n     {\n-      const GFC_LOGICAL_8 * restrict src;\n+      const GFC_LOGICAL_1 * restrict src;\n       GFC_LOGICAL_8 result;\n       src = base;\n       {"}, {"sha": "d3f15d7119d0cda4e74937f30a9787d9b22b896f", "filename": "libgfortran/generated/count_16_l.c", "status": "renamed", "additions": 31, "deletions": 16, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90469382c09fb5ed5602c30490d117aff172f7c2/libgfortran%2Fgenerated%2Fcount_16_l.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90469382c09fb5ed5602c30490d117aff172f7c2/libgfortran%2Fgenerated%2Fcount_16_l.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcount_16_l.c?ref=90469382c09fb5ed5602c30490d117aff172f7c2", "patch": "@@ -33,48 +33,51 @@ Boston, MA 02110-1301, USA.  */\n #include <assert.h>\n \n \n-#if defined (HAVE_GFC_LOGICAL_4) && defined (HAVE_GFC_INTEGER_16)\n+#if defined (HAVE_GFC_INTEGER_16)\n \n \n-extern void count_16_l4 (gfc_array_i16 * const restrict, \n-\tgfc_array_l4 * const restrict, const index_type * const restrict);\n-export_proto(count_16_l4);\n+extern void count_16_l (gfc_array_i16 * const restrict, \n+\tgfc_array_l1 * const restrict, const index_type * const restrict);\n+export_proto(count_16_l);\n \n void\n-count_16_l4 (gfc_array_i16 * const restrict retarray, \n-\tgfc_array_l4 * const restrict array, \n+count_16_l (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_l1 * const restrict array, \n \tconst index_type * const restrict pdim)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n   index_type sstride[GFC_MAX_DIMENSIONS];\n   index_type dstride[GFC_MAX_DIMENSIONS];\n-  const GFC_LOGICAL_4 * restrict base;\n+  const GFC_LOGICAL_1 * restrict base;\n   GFC_INTEGER_16 * restrict dest;\n   index_type rank;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type dim;\n+  int src_kind;\n \n   /* Make dim zero based to avoid confusion.  */\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n+  src_kind = GFC_DESCRIPTOR_SIZE (array);\n+\n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n-  delta = array->dim[dim].stride;\n+  delta = array->dim[dim].stride * src_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n+      sstride[n] = array->dim[n].stride * src_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n+      sstride[n] = array->dim[n + 1].stride * src_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -116,9 +119,8 @@ count_16_l4 (gfc_array_i16 * const restrict retarray,\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n \truntime_error (\"rank of return array incorrect in\"\n-\t\t       \" COUNT intrinsic: is %ld, should be %ld\",\n-\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n-\t\t       (long int) rank);\n+\t\t       \" COUNT intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n \n       if (compile_options.bounds_check)\n \t{\n@@ -130,8 +132,8 @@ count_16_l4 (gfc_array_i16 * const restrict retarray,\n \t\t- retarray->dim[n].lbound;\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" COUNT intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       \" COUNT intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n \t\t\t       (long int) ret_extent, (long int) extent[n]);\n \t    }\n \t}\n@@ -146,11 +148,24 @@ count_16_l4 (gfc_array_i16 * const restrict retarray,\n     }\n \n   base = array->data;\n+\n+  if (src_kind == 1 || src_kind == 2 || src_kind == 4 || src_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || src_kind == 16\n+#endif\n+    )\n+    {\n+      if (base)\n+\tbase = GFOR_POINTER_TO_L1 (base, src_kind);\n+    }\n+  else\n+    internal_error (NULL, \"Funny sized logical array in COUNT intrinsic\");\n+\n   dest = retarray->data;\n \n   while (base)\n     {\n-      const GFC_LOGICAL_4 * restrict src;\n+      const GFC_LOGICAL_1 * restrict src;\n       GFC_INTEGER_16 result;\n       src = base;\n       {", "previous_filename": "libgfortran/generated/count_16_l4.c"}, {"sha": "4f3418bd73a12c413b75efb1ef04492b6f185964", "filename": "libgfortran/generated/count_16_l16.c", "status": "removed", "additions": 0, "deletions": 203, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac90ae18fb641f365ce349efbbaf8b88a4f96b8e/libgfortran%2Fgenerated%2Fcount_16_l16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac90ae18fb641f365ce349efbbaf8b88a4f96b8e/libgfortran%2Fgenerated%2Fcount_16_l16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcount_16_l16.c?ref=ac90ae18fb641f365ce349efbbaf8b88a4f96b8e", "patch": "@@ -1,203 +0,0 @@\n-/* Implementation of the COUNT intrinsic\n-   Copyright 2002, 2007 Free Software Foundation, Inc.\n-   Contributed by Paul Brook <paul@nowt.org>\n-\n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n-\n-Libgfortran is free software; you can redistribute it and/or\n-modify it under the terms of the GNU General Public\n-License as published by the Free Software Foundation; either\n-version 2 of the License, or (at your option) any later version.\n-\n-In addition to the permissions in the GNU General Public License, the\n-Free Software Foundation gives you unlimited permission to link the\n-compiled version of this file into combinations with other programs,\n-and to distribute those combinations without any restriction coming\n-from the use of this file.  (The General Public License restrictions\n-do apply in other respects; for example, they cover modification of\n-the file, and distribution when not linked into a combine\n-executable.)\n-\n-Libgfortran is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public\n-License along with libgfortran; see the file COPYING.  If not,\n-write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n-Boston, MA 02110-1301, USA.  */\n-\n-#include \"libgfortran.h\"\n-#include <stdlib.h>\n-#include <assert.h>\n-\n-\n-#if defined (HAVE_GFC_LOGICAL_16) && defined (HAVE_GFC_INTEGER_16)\n-\n-\n-extern void count_16_l16 (gfc_array_i16 * const restrict, \n-\tgfc_array_l16 * const restrict, const index_type * const restrict);\n-export_proto(count_16_l16);\n-\n-void\n-count_16_l16 (gfc_array_i16 * const restrict retarray, \n-\tgfc_array_l16 * const restrict array, \n-\tconst index_type * const restrict pdim)\n-{\n-  index_type count[GFC_MAX_DIMENSIONS];\n-  index_type extent[GFC_MAX_DIMENSIONS];\n-  index_type sstride[GFC_MAX_DIMENSIONS];\n-  index_type dstride[GFC_MAX_DIMENSIONS];\n-  const GFC_LOGICAL_16 * restrict base;\n-  GFC_INTEGER_16 * restrict dest;\n-  index_type rank;\n-  index_type n;\n-  index_type len;\n-  index_type delta;\n-  index_type dim;\n-\n-  /* Make dim zero based to avoid confusion.  */\n-  dim = (*pdim) - 1;\n-  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-\n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n-  delta = array->dim[dim].stride;\n-\n-  for (n = 0; n < dim; n++)\n-    {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\n-      if (extent[n] < 0)\n-\textent[n] = 0;\n-    }\n-  for (n = dim; n < rank; n++)\n-    {\n-      sstride[n] = array->dim[n + 1].stride;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n-\n-      if (extent[n] < 0)\n-\textent[n] = 0;\n-    }\n-\n-  if (retarray->data == NULL)\n-    {\n-      size_t alloc_size;\n-\n-      for (n = 0; n < rank; n++)\n-        {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n-          if (n == 0)\n-            retarray->dim[n].stride = 1;\n-          else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n-        }\n-\n-      retarray->offset = 0;\n-      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n-\n-      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n-    \t\t   * extent[rank-1];\n-\n-      if (alloc_size == 0)\n-\t{\n-\t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n-\t  return;\n-\t}\n-      else\n-\tretarray->data = internal_malloc_size (alloc_size);\n-    }\n-  else\n-    {\n-      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect in\"\n-\t\t       \" COUNT intrinsic: is %ld, should be %ld\",\n-\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n-\t\t       (long int) rank);\n-\n-      if (compile_options.bounds_check)\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" COUNT intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n-    }\n-\n-  for (n = 0; n < rank; n++)\n-    {\n-      count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n-      if (extent[n] <= 0)\n-        len = 0;\n-    }\n-\n-  base = array->data;\n-  dest = retarray->data;\n-\n-  while (base)\n-    {\n-      const GFC_LOGICAL_16 * restrict src;\n-      GFC_INTEGER_16 result;\n-      src = base;\n-      {\n-\n-  result = 0;\n-        if (len <= 0)\n-\t  *dest = 0;\n-\telse\n-\t  {\n-\t    for (n = 0; n < len; n++, src += delta)\n-\t      {\n-\n-  if (*src)\n-    result++;\n-          }\n-\t    *dest = result;\n-\t  }\n-      }\n-      /* Advance to the next element.  */\n-      count[0]++;\n-      base += sstride[0];\n-      dest += dstride[0];\n-      n = 0;\n-      while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n-    }\n-}\n-\n-#endif"}, {"sha": "78d82c0ea36fe037c775c237ddf207eabb964a38", "filename": "libgfortran/generated/count_1_l.c", "status": "renamed", "additions": 34, "deletions": 19, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90469382c09fb5ed5602c30490d117aff172f7c2/libgfortran%2Fgenerated%2Fcount_1_l.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90469382c09fb5ed5602c30490d117aff172f7c2/libgfortran%2Fgenerated%2Fcount_1_l.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcount_1_l.c?ref=90469382c09fb5ed5602c30490d117aff172f7c2", "patch": "@@ -33,48 +33,51 @@ Boston, MA 02110-1301, USA.  */\n #include <assert.h>\n \n \n-#if defined (HAVE_GFC_LOGICAL_8) && defined (HAVE_GFC_INTEGER_4)\n+#if defined (HAVE_GFC_INTEGER_1)\n \n \n-extern void count_4_l8 (gfc_array_i4 * const restrict, \n-\tgfc_array_l8 * const restrict, const index_type * const restrict);\n-export_proto(count_4_l8);\n+extern void count_1_l (gfc_array_i1 * const restrict, \n+\tgfc_array_l1 * const restrict, const index_type * const restrict);\n+export_proto(count_1_l);\n \n void\n-count_4_l8 (gfc_array_i4 * const restrict retarray, \n-\tgfc_array_l8 * const restrict array, \n+count_1_l (gfc_array_i1 * const restrict retarray, \n+\tgfc_array_l1 * const restrict array, \n \tconst index_type * const restrict pdim)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n   index_type sstride[GFC_MAX_DIMENSIONS];\n   index_type dstride[GFC_MAX_DIMENSIONS];\n-  const GFC_LOGICAL_8 * restrict base;\n-  GFC_INTEGER_4 * restrict dest;\n+  const GFC_LOGICAL_1 * restrict base;\n+  GFC_INTEGER_1 * restrict dest;\n   index_type rank;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type dim;\n+  int src_kind;\n \n   /* Make dim zero based to avoid confusion.  */\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n+  src_kind = GFC_DESCRIPTOR_SIZE (array);\n+\n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n-  delta = array->dim[dim].stride;\n+  delta = array->dim[dim].stride * src_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n+      sstride[n] = array->dim[n].stride * src_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n+      sstride[n] = array->dim[n + 1].stride * src_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -99,7 +102,7 @@ count_4_l8 (gfc_array_i4 * const restrict retarray,\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_1) * retarray->dim[rank-1].stride\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n@@ -116,9 +119,8 @@ count_4_l8 (gfc_array_i4 * const restrict retarray,\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n \truntime_error (\"rank of return array incorrect in\"\n-\t\t       \" COUNT intrinsic: is %ld, should be %ld\",\n-\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n-\t\t       (long int) rank);\n+\t\t       \" COUNT intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n \n       if (compile_options.bounds_check)\n \t{\n@@ -130,8 +132,8 @@ count_4_l8 (gfc_array_i4 * const restrict retarray,\n \t\t- retarray->dim[n].lbound;\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" COUNT intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       \" COUNT intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n \t\t\t       (long int) ret_extent, (long int) extent[n]);\n \t    }\n \t}\n@@ -146,12 +148,25 @@ count_4_l8 (gfc_array_i4 * const restrict retarray,\n     }\n \n   base = array->data;\n+\n+  if (src_kind == 1 || src_kind == 2 || src_kind == 4 || src_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || src_kind == 16\n+#endif\n+    )\n+    {\n+      if (base)\n+\tbase = GFOR_POINTER_TO_L1 (base, src_kind);\n+    }\n+  else\n+    internal_error (NULL, \"Funny sized logical array in COUNT intrinsic\");\n+\n   dest = retarray->data;\n \n   while (base)\n     {\n-      const GFC_LOGICAL_8 * restrict src;\n-      GFC_INTEGER_4 result;\n+      const GFC_LOGICAL_1 * restrict src;\n+      GFC_INTEGER_1 result;\n       src = base;\n       {\n ", "previous_filename": "libgfortran/generated/count_4_l8.c"}, {"sha": "eb03c2d5c5fc381c3d3c51b85bf78f8047894ae4", "filename": "libgfortran/generated/count_2_l.c", "status": "renamed", "additions": 34, "deletions": 19, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90469382c09fb5ed5602c30490d117aff172f7c2/libgfortran%2Fgenerated%2Fcount_2_l.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90469382c09fb5ed5602c30490d117aff172f7c2/libgfortran%2Fgenerated%2Fcount_2_l.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcount_2_l.c?ref=90469382c09fb5ed5602c30490d117aff172f7c2", "patch": "@@ -33,48 +33,51 @@ Boston, MA 02110-1301, USA.  */\n #include <assert.h>\n \n \n-#if defined (HAVE_GFC_LOGICAL_4) && defined (HAVE_GFC_INTEGER_8)\n+#if defined (HAVE_GFC_INTEGER_2)\n \n \n-extern void count_8_l4 (gfc_array_i8 * const restrict, \n-\tgfc_array_l4 * const restrict, const index_type * const restrict);\n-export_proto(count_8_l4);\n+extern void count_2_l (gfc_array_i2 * const restrict, \n+\tgfc_array_l1 * const restrict, const index_type * const restrict);\n+export_proto(count_2_l);\n \n void\n-count_8_l4 (gfc_array_i8 * const restrict retarray, \n-\tgfc_array_l4 * const restrict array, \n+count_2_l (gfc_array_i2 * const restrict retarray, \n+\tgfc_array_l1 * const restrict array, \n \tconst index_type * const restrict pdim)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n   index_type sstride[GFC_MAX_DIMENSIONS];\n   index_type dstride[GFC_MAX_DIMENSIONS];\n-  const GFC_LOGICAL_4 * restrict base;\n-  GFC_INTEGER_8 * restrict dest;\n+  const GFC_LOGICAL_1 * restrict base;\n+  GFC_INTEGER_2 * restrict dest;\n   index_type rank;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type dim;\n+  int src_kind;\n \n   /* Make dim zero based to avoid confusion.  */\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n+  src_kind = GFC_DESCRIPTOR_SIZE (array);\n+\n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n-  delta = array->dim[dim].stride;\n+  delta = array->dim[dim].stride * src_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n+      sstride[n] = array->dim[n].stride * src_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n+      sstride[n] = array->dim[n + 1].stride * src_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -99,7 +102,7 @@ count_8_l4 (gfc_array_i8 * const restrict retarray,\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (GFC_INTEGER_2) * retarray->dim[rank-1].stride\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n@@ -116,9 +119,8 @@ count_8_l4 (gfc_array_i8 * const restrict retarray,\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n \truntime_error (\"rank of return array incorrect in\"\n-\t\t       \" COUNT intrinsic: is %ld, should be %ld\",\n-\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n-\t\t       (long int) rank);\n+\t\t       \" COUNT intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n \n       if (compile_options.bounds_check)\n \t{\n@@ -130,8 +132,8 @@ count_8_l4 (gfc_array_i8 * const restrict retarray,\n \t\t- retarray->dim[n].lbound;\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" COUNT intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       \" COUNT intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n \t\t\t       (long int) ret_extent, (long int) extent[n]);\n \t    }\n \t}\n@@ -146,12 +148,25 @@ count_8_l4 (gfc_array_i8 * const restrict retarray,\n     }\n \n   base = array->data;\n+\n+  if (src_kind == 1 || src_kind == 2 || src_kind == 4 || src_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || src_kind == 16\n+#endif\n+    )\n+    {\n+      if (base)\n+\tbase = GFOR_POINTER_TO_L1 (base, src_kind);\n+    }\n+  else\n+    internal_error (NULL, \"Funny sized logical array in COUNT intrinsic\");\n+\n   dest = retarray->data;\n \n   while (base)\n     {\n-      const GFC_LOGICAL_4 * restrict src;\n-      GFC_INTEGER_8 result;\n+      const GFC_LOGICAL_1 * restrict src;\n+      GFC_INTEGER_2 result;\n       src = base;\n       {\n ", "previous_filename": "libgfortran/generated/count_8_l4.c"}, {"sha": "58dcd77c731b512cf832ac97a926f08de77fc866", "filename": "libgfortran/generated/count_4_l.c", "status": "renamed", "additions": 31, "deletions": 16, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90469382c09fb5ed5602c30490d117aff172f7c2/libgfortran%2Fgenerated%2Fcount_4_l.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90469382c09fb5ed5602c30490d117aff172f7c2/libgfortran%2Fgenerated%2Fcount_4_l.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcount_4_l.c?ref=90469382c09fb5ed5602c30490d117aff172f7c2", "patch": "@@ -33,48 +33,51 @@ Boston, MA 02110-1301, USA.  */\n #include <assert.h>\n \n \n-#if defined (HAVE_GFC_LOGICAL_4) && defined (HAVE_GFC_INTEGER_4)\n+#if defined (HAVE_GFC_INTEGER_4)\n \n \n-extern void count_4_l4 (gfc_array_i4 * const restrict, \n-\tgfc_array_l4 * const restrict, const index_type * const restrict);\n-export_proto(count_4_l4);\n+extern void count_4_l (gfc_array_i4 * const restrict, \n+\tgfc_array_l1 * const restrict, const index_type * const restrict);\n+export_proto(count_4_l);\n \n void\n-count_4_l4 (gfc_array_i4 * const restrict retarray, \n-\tgfc_array_l4 * const restrict array, \n+count_4_l (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_l1 * const restrict array, \n \tconst index_type * const restrict pdim)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n   index_type sstride[GFC_MAX_DIMENSIONS];\n   index_type dstride[GFC_MAX_DIMENSIONS];\n-  const GFC_LOGICAL_4 * restrict base;\n+  const GFC_LOGICAL_1 * restrict base;\n   GFC_INTEGER_4 * restrict dest;\n   index_type rank;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type dim;\n+  int src_kind;\n \n   /* Make dim zero based to avoid confusion.  */\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n+  src_kind = GFC_DESCRIPTOR_SIZE (array);\n+\n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n-  delta = array->dim[dim].stride;\n+  delta = array->dim[dim].stride * src_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n+      sstride[n] = array->dim[n].stride * src_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n+      sstride[n] = array->dim[n + 1].stride * src_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -116,9 +119,8 @@ count_4_l4 (gfc_array_i4 * const restrict retarray,\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n \truntime_error (\"rank of return array incorrect in\"\n-\t\t       \" COUNT intrinsic: is %ld, should be %ld\",\n-\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n-\t\t       (long int) rank);\n+\t\t       \" COUNT intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n \n       if (compile_options.bounds_check)\n \t{\n@@ -130,8 +132,8 @@ count_4_l4 (gfc_array_i4 * const restrict retarray,\n \t\t- retarray->dim[n].lbound;\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" COUNT intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       \" COUNT intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n \t\t\t       (long int) ret_extent, (long int) extent[n]);\n \t    }\n \t}\n@@ -146,11 +148,24 @@ count_4_l4 (gfc_array_i4 * const restrict retarray,\n     }\n \n   base = array->data;\n+\n+  if (src_kind == 1 || src_kind == 2 || src_kind == 4 || src_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || src_kind == 16\n+#endif\n+    )\n+    {\n+      if (base)\n+\tbase = GFOR_POINTER_TO_L1 (base, src_kind);\n+    }\n+  else\n+    internal_error (NULL, \"Funny sized logical array in COUNT intrinsic\");\n+\n   dest = retarray->data;\n \n   while (base)\n     {\n-      const GFC_LOGICAL_4 * restrict src;\n+      const GFC_LOGICAL_1 * restrict src;\n       GFC_INTEGER_4 result;\n       src = base;\n       {", "previous_filename": "libgfortran/generated/count_4_l4.c"}, {"sha": "5dee5468c6486f2399c7c73e084226c9843ff362", "filename": "libgfortran/generated/count_4_l16.c", "status": "removed", "additions": 0, "deletions": 203, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac90ae18fb641f365ce349efbbaf8b88a4f96b8e/libgfortran%2Fgenerated%2Fcount_4_l16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac90ae18fb641f365ce349efbbaf8b88a4f96b8e/libgfortran%2Fgenerated%2Fcount_4_l16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcount_4_l16.c?ref=ac90ae18fb641f365ce349efbbaf8b88a4f96b8e", "patch": "@@ -1,203 +0,0 @@\n-/* Implementation of the COUNT intrinsic\n-   Copyright 2002, 2007 Free Software Foundation, Inc.\n-   Contributed by Paul Brook <paul@nowt.org>\n-\n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n-\n-Libgfortran is free software; you can redistribute it and/or\n-modify it under the terms of the GNU General Public\n-License as published by the Free Software Foundation; either\n-version 2 of the License, or (at your option) any later version.\n-\n-In addition to the permissions in the GNU General Public License, the\n-Free Software Foundation gives you unlimited permission to link the\n-compiled version of this file into combinations with other programs,\n-and to distribute those combinations without any restriction coming\n-from the use of this file.  (The General Public License restrictions\n-do apply in other respects; for example, they cover modification of\n-the file, and distribution when not linked into a combine\n-executable.)\n-\n-Libgfortran is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public\n-License along with libgfortran; see the file COPYING.  If not,\n-write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n-Boston, MA 02110-1301, USA.  */\n-\n-#include \"libgfortran.h\"\n-#include <stdlib.h>\n-#include <assert.h>\n-\n-\n-#if defined (HAVE_GFC_LOGICAL_16) && defined (HAVE_GFC_INTEGER_4)\n-\n-\n-extern void count_4_l16 (gfc_array_i4 * const restrict, \n-\tgfc_array_l16 * const restrict, const index_type * const restrict);\n-export_proto(count_4_l16);\n-\n-void\n-count_4_l16 (gfc_array_i4 * const restrict retarray, \n-\tgfc_array_l16 * const restrict array, \n-\tconst index_type * const restrict pdim)\n-{\n-  index_type count[GFC_MAX_DIMENSIONS];\n-  index_type extent[GFC_MAX_DIMENSIONS];\n-  index_type sstride[GFC_MAX_DIMENSIONS];\n-  index_type dstride[GFC_MAX_DIMENSIONS];\n-  const GFC_LOGICAL_16 * restrict base;\n-  GFC_INTEGER_4 * restrict dest;\n-  index_type rank;\n-  index_type n;\n-  index_type len;\n-  index_type delta;\n-  index_type dim;\n-\n-  /* Make dim zero based to avoid confusion.  */\n-  dim = (*pdim) - 1;\n-  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-\n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n-  delta = array->dim[dim].stride;\n-\n-  for (n = 0; n < dim; n++)\n-    {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\n-      if (extent[n] < 0)\n-\textent[n] = 0;\n-    }\n-  for (n = dim; n < rank; n++)\n-    {\n-      sstride[n] = array->dim[n + 1].stride;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n-\n-      if (extent[n] < 0)\n-\textent[n] = 0;\n-    }\n-\n-  if (retarray->data == NULL)\n-    {\n-      size_t alloc_size;\n-\n-      for (n = 0; n < rank; n++)\n-        {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n-          if (n == 0)\n-            retarray->dim[n].stride = 1;\n-          else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n-        }\n-\n-      retarray->offset = 0;\n-      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n-\n-      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n-    \t\t   * extent[rank-1];\n-\n-      if (alloc_size == 0)\n-\t{\n-\t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n-\t  return;\n-\t}\n-      else\n-\tretarray->data = internal_malloc_size (alloc_size);\n-    }\n-  else\n-    {\n-      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect in\"\n-\t\t       \" COUNT intrinsic: is %ld, should be %ld\",\n-\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n-\t\t       (long int) rank);\n-\n-      if (compile_options.bounds_check)\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" COUNT intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n-    }\n-\n-  for (n = 0; n < rank; n++)\n-    {\n-      count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n-      if (extent[n] <= 0)\n-        len = 0;\n-    }\n-\n-  base = array->data;\n-  dest = retarray->data;\n-\n-  while (base)\n-    {\n-      const GFC_LOGICAL_16 * restrict src;\n-      GFC_INTEGER_4 result;\n-      src = base;\n-      {\n-\n-  result = 0;\n-        if (len <= 0)\n-\t  *dest = 0;\n-\telse\n-\t  {\n-\t    for (n = 0; n < len; n++, src += delta)\n-\t      {\n-\n-  if (*src)\n-    result++;\n-          }\n-\t    *dest = result;\n-\t  }\n-      }\n-      /* Advance to the next element.  */\n-      count[0]++;\n-      base += sstride[0];\n-      dest += dstride[0];\n-      n = 0;\n-      while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n-    }\n-}\n-\n-#endif"}, {"sha": "b7db60e00b09eada31821cce1cf3494b3540999e", "filename": "libgfortran/generated/count_8_l.c", "status": "renamed", "additions": 31, "deletions": 16, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90469382c09fb5ed5602c30490d117aff172f7c2/libgfortran%2Fgenerated%2Fcount_8_l.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90469382c09fb5ed5602c30490d117aff172f7c2/libgfortran%2Fgenerated%2Fcount_8_l.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcount_8_l.c?ref=90469382c09fb5ed5602c30490d117aff172f7c2", "patch": "@@ -33,48 +33,51 @@ Boston, MA 02110-1301, USA.  */\n #include <assert.h>\n \n \n-#if defined (HAVE_GFC_LOGICAL_8) && defined (HAVE_GFC_INTEGER_8)\n+#if defined (HAVE_GFC_INTEGER_8)\n \n \n-extern void count_8_l8 (gfc_array_i8 * const restrict, \n-\tgfc_array_l8 * const restrict, const index_type * const restrict);\n-export_proto(count_8_l8);\n+extern void count_8_l (gfc_array_i8 * const restrict, \n+\tgfc_array_l1 * const restrict, const index_type * const restrict);\n+export_proto(count_8_l);\n \n void\n-count_8_l8 (gfc_array_i8 * const restrict retarray, \n-\tgfc_array_l8 * const restrict array, \n+count_8_l (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_l1 * const restrict array, \n \tconst index_type * const restrict pdim)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n   index_type sstride[GFC_MAX_DIMENSIONS];\n   index_type dstride[GFC_MAX_DIMENSIONS];\n-  const GFC_LOGICAL_8 * restrict base;\n+  const GFC_LOGICAL_1 * restrict base;\n   GFC_INTEGER_8 * restrict dest;\n   index_type rank;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type dim;\n+  int src_kind;\n \n   /* Make dim zero based to avoid confusion.  */\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n+  src_kind = GFC_DESCRIPTOR_SIZE (array);\n+\n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n-  delta = array->dim[dim].stride;\n+  delta = array->dim[dim].stride * src_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n+      sstride[n] = array->dim[n].stride * src_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n+      sstride[n] = array->dim[n + 1].stride * src_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -116,9 +119,8 @@ count_8_l8 (gfc_array_i8 * const restrict retarray,\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n \truntime_error (\"rank of return array incorrect in\"\n-\t\t       \" COUNT intrinsic: is %ld, should be %ld\",\n-\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n-\t\t       (long int) rank);\n+\t\t       \" COUNT intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n \n       if (compile_options.bounds_check)\n \t{\n@@ -130,8 +132,8 @@ count_8_l8 (gfc_array_i8 * const restrict retarray,\n \t\t- retarray->dim[n].lbound;\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" COUNT intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       \" COUNT intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n \t\t\t       (long int) ret_extent, (long int) extent[n]);\n \t    }\n \t}\n@@ -146,11 +148,24 @@ count_8_l8 (gfc_array_i8 * const restrict retarray,\n     }\n \n   base = array->data;\n+\n+  if (src_kind == 1 || src_kind == 2 || src_kind == 4 || src_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || src_kind == 16\n+#endif\n+    )\n+    {\n+      if (base)\n+\tbase = GFOR_POINTER_TO_L1 (base, src_kind);\n+    }\n+  else\n+    internal_error (NULL, \"Funny sized logical array in COUNT intrinsic\");\n+\n   dest = retarray->data;\n \n   while (base)\n     {\n-      const GFC_LOGICAL_8 * restrict src;\n+      const GFC_LOGICAL_1 * restrict src;\n       GFC_INTEGER_8 result;\n       src = base;\n       {", "previous_filename": "libgfortran/generated/count_8_l8.c"}, {"sha": "b0d11164fc530e9b92cfe382b2fe3953482bf355", "filename": "libgfortran/generated/count_8_l16.c", "status": "removed", "additions": 0, "deletions": 203, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac90ae18fb641f365ce349efbbaf8b88a4f96b8e/libgfortran%2Fgenerated%2Fcount_8_l16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac90ae18fb641f365ce349efbbaf8b88a4f96b8e/libgfortran%2Fgenerated%2Fcount_8_l16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcount_8_l16.c?ref=ac90ae18fb641f365ce349efbbaf8b88a4f96b8e", "patch": "@@ -1,203 +0,0 @@\n-/* Implementation of the COUNT intrinsic\n-   Copyright 2002, 2007 Free Software Foundation, Inc.\n-   Contributed by Paul Brook <paul@nowt.org>\n-\n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n-\n-Libgfortran is free software; you can redistribute it and/or\n-modify it under the terms of the GNU General Public\n-License as published by the Free Software Foundation; either\n-version 2 of the License, or (at your option) any later version.\n-\n-In addition to the permissions in the GNU General Public License, the\n-Free Software Foundation gives you unlimited permission to link the\n-compiled version of this file into combinations with other programs,\n-and to distribute those combinations without any restriction coming\n-from the use of this file.  (The General Public License restrictions\n-do apply in other respects; for example, they cover modification of\n-the file, and distribution when not linked into a combine\n-executable.)\n-\n-Libgfortran is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public\n-License along with libgfortran; see the file COPYING.  If not,\n-write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n-Boston, MA 02110-1301, USA.  */\n-\n-#include \"libgfortran.h\"\n-#include <stdlib.h>\n-#include <assert.h>\n-\n-\n-#if defined (HAVE_GFC_LOGICAL_16) && defined (HAVE_GFC_INTEGER_8)\n-\n-\n-extern void count_8_l16 (gfc_array_i8 * const restrict, \n-\tgfc_array_l16 * const restrict, const index_type * const restrict);\n-export_proto(count_8_l16);\n-\n-void\n-count_8_l16 (gfc_array_i8 * const restrict retarray, \n-\tgfc_array_l16 * const restrict array, \n-\tconst index_type * const restrict pdim)\n-{\n-  index_type count[GFC_MAX_DIMENSIONS];\n-  index_type extent[GFC_MAX_DIMENSIONS];\n-  index_type sstride[GFC_MAX_DIMENSIONS];\n-  index_type dstride[GFC_MAX_DIMENSIONS];\n-  const GFC_LOGICAL_16 * restrict base;\n-  GFC_INTEGER_8 * restrict dest;\n-  index_type rank;\n-  index_type n;\n-  index_type len;\n-  index_type delta;\n-  index_type dim;\n-\n-  /* Make dim zero based to avoid confusion.  */\n-  dim = (*pdim) - 1;\n-  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n-\n-  len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n-  delta = array->dim[dim].stride;\n-\n-  for (n = 0; n < dim; n++)\n-    {\n-      sstride[n] = array->dim[n].stride;\n-      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n-\n-      if (extent[n] < 0)\n-\textent[n] = 0;\n-    }\n-  for (n = dim; n < rank; n++)\n-    {\n-      sstride[n] = array->dim[n + 1].stride;\n-      extent[n] =\n-        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n-\n-      if (extent[n] < 0)\n-\textent[n] = 0;\n-    }\n-\n-  if (retarray->data == NULL)\n-    {\n-      size_t alloc_size;\n-\n-      for (n = 0; n < rank; n++)\n-        {\n-          retarray->dim[n].lbound = 0;\n-          retarray->dim[n].ubound = extent[n]-1;\n-          if (n == 0)\n-            retarray->dim[n].stride = 1;\n-          else\n-            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n-        }\n-\n-      retarray->offset = 0;\n-      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n-\n-      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n-    \t\t   * extent[rank-1];\n-\n-      if (alloc_size == 0)\n-\t{\n-\t  /* Make sure we have a zero-sized array.  */\n-\t  retarray->dim[0].lbound = 0;\n-\t  retarray->dim[0].ubound = -1;\n-\t  return;\n-\t}\n-      else\n-\tretarray->data = internal_malloc_size (alloc_size);\n-    }\n-  else\n-    {\n-      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n-\truntime_error (\"rank of return array incorrect in\"\n-\t\t       \" COUNT intrinsic: is %ld, should be %ld\",\n-\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n-\t\t       (long int) rank);\n-\n-      if (compile_options.bounds_check)\n-\t{\n-\t  for (n=0; n < rank; n++)\n-\t    {\n-\t      index_type ret_extent;\n-\n-\t      ret_extent = retarray->dim[n].ubound + 1\n-\t\t- retarray->dim[n].lbound;\n-\t      if (extent[n] != ret_extent)\n-\t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" COUNT intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n-\t\t\t       (long int) ret_extent, (long int) extent[n]);\n-\t    }\n-\t}\n-    }\n-\n-  for (n = 0; n < rank; n++)\n-    {\n-      count[n] = 0;\n-      dstride[n] = retarray->dim[n].stride;\n-      if (extent[n] <= 0)\n-        len = 0;\n-    }\n-\n-  base = array->data;\n-  dest = retarray->data;\n-\n-  while (base)\n-    {\n-      const GFC_LOGICAL_16 * restrict src;\n-      GFC_INTEGER_8 result;\n-      src = base;\n-      {\n-\n-  result = 0;\n-        if (len <= 0)\n-\t  *dest = 0;\n-\telse\n-\t  {\n-\t    for (n = 0; n < len; n++, src += delta)\n-\t      {\n-\n-  if (*src)\n-    result++;\n-          }\n-\t    *dest = result;\n-\t  }\n-      }\n-      /* Advance to the next element.  */\n-      count[0]++;\n-      base += sstride[0];\n-      dest += dstride[0];\n-      n = 0;\n-      while (count[n] == extent[n])\n-        {\n-          /* When we get to the end of a dimension, reset it and increment\n-             the next dimension.  */\n-          count[n] = 0;\n-          /* We could precalculate these products, but this is a less\n-             frequently used path so probably not worth it.  */\n-          base -= sstride[n] * extent[n];\n-          dest -= dstride[n] * extent[n];\n-          n++;\n-          if (n == rank)\n-            {\n-              /* Break out of the look.  */\n-              base = NULL;\n-              break;\n-            }\n-          else\n-            {\n-              count[n]++;\n-              base += sstride[n];\n-              dest += dstride[n];\n-            }\n-        }\n-    }\n-}\n-\n-#endif"}, {"sha": "7df40163606c37de1cdff4bdfc53c9985eb71595", "filename": "libgfortran/gfortran.map", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90469382c09fb5ed5602c30490d117aff172f7c2/libgfortran%2Fgfortran.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90469382c09fb5ed5602c30490d117aff172f7c2/libgfortran%2Fgfortran.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgfortran.map?ref=90469382c09fb5ed5602c30490d117aff172f7c2", "patch": "@@ -8,10 +8,14 @@ GFORTRAN_1.0 {\n     _gfortran_alarm_sub_i8;\n     _gfortran_alarm_sub_int_i4;\n     _gfortran_alarm_sub_int_i8;\n+    _gfortran_all_l1;\n     _gfortran_all_l16;\n+    _gfortran_all_l2;\n     _gfortran_all_l4;\n     _gfortran_all_l8;\n+    _gfortran_any_l1;\n     _gfortran_any_l16;\n+    _gfortran_any_l2;\n     _gfortran_any_l4;\n     _gfortran_any_l8;\n     _gfortran_arandom_r10;\n@@ -28,15 +32,11 @@ GFORTRAN_1.0 {\n     _gfortran_chmod_i8_sub;\n     _gfortran_compare_string;\n     _gfortran_concat_string;\n-    _gfortran_count_16_l16;\n-    _gfortran_count_16_l4;\n-    _gfortran_count_16_l8;\n-    _gfortran_count_4_l16;\n-    _gfortran_count_4_l4;\n-    _gfortran_count_4_l8;\n-    _gfortran_count_8_l16;\n-    _gfortran_count_8_l4;\n-    _gfortran_count_8_l8;\n+    _gfortran_count_1_l;\n+    _gfortran_count_16_l;\n+    _gfortran_count_2_l;\n+    _gfortran_count_4_l;\n+    _gfortran_count_8_l;\n     _gfortran_cpu_time_10;\n     _gfortran_cpu_time_16;\n     _gfortran_cpu_time_4;"}, {"sha": "8d4ece3d6cee88be3ac529075bbf3a7652026303", "filename": "libgfortran/m4/all.m4", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90469382c09fb5ed5602c30490d117aff172f7c2/libgfortran%2Fm4%2Fall.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90469382c09fb5ed5602c30490d117aff172f7c2/libgfortran%2Fm4%2Fall.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fall.m4?ref=90469382c09fb5ed5602c30490d117aff172f7c2", "patch": "@@ -33,9 +33,9 @@ Boston, MA 02110-1301, USA.  */\n #include <assert.h>'\n \n include(iparm.m4)dnl\n-include(ifunction.m4)dnl\n+include(ifunction_logical.m4)dnl\n \n-`#if defined (HAVE_'atype_name`) && defined (HAVE_'rtype_name`)'\n+`#if defined (HAVE_'rtype_name`)'\n \n ARRAY_FUNCTION(1,\n `  /* Return true only if all the elements are set.  */"}, {"sha": "156f6c5b8285fea76c9e0687eb924f76ce22be75", "filename": "libgfortran/m4/any.m4", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90469382c09fb5ed5602c30490d117aff172f7c2/libgfortran%2Fm4%2Fany.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90469382c09fb5ed5602c30490d117aff172f7c2/libgfortran%2Fm4%2Fany.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fany.m4?ref=90469382c09fb5ed5602c30490d117aff172f7c2", "patch": "@@ -33,9 +33,9 @@ Boston, MA 02110-1301, USA.  */\n #include <assert.h>'\n \n include(iparm.m4)dnl\n-include(ifunction.m4)dnl\n+include(ifunction_logical.m4)dnl\n \n-`#if defined (HAVE_'atype_name`) && defined (HAVE_'rtype_name`)'\n+`#if defined (HAVE_'rtype_name`)'\n \n ARRAY_FUNCTION(0,\n `  result = 0;',"}, {"sha": "48ce411b0abe5d39d2b1b228e745a100ca6081f9", "filename": "libgfortran/m4/count.m4", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90469382c09fb5ed5602c30490d117aff172f7c2/libgfortran%2Fm4%2Fcount.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90469382c09fb5ed5602c30490d117aff172f7c2/libgfortran%2Fm4%2Fcount.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fcount.m4?ref=90469382c09fb5ed5602c30490d117aff172f7c2", "patch": "@@ -33,9 +33,9 @@ Boston, MA 02110-1301, USA.  */\n #include <assert.h>'\n \n include(iparm.m4)dnl\n-include(ifunction.m4)dnl\n+include(ifunction_logical.m4)dnl\n \n-`#if defined (HAVE_'atype_name`) && defined (HAVE_'rtype_name`)'\n+`#if defined (HAVE_'rtype_name`)'\n \n ARRAY_FUNCTION(0,\n `  result = 0;',"}, {"sha": "b2acb32f1151797b97e2dc922130a2ad5be939f7", "filename": "libgfortran/m4/ifunction_logical.m4", "status": "renamed", "additions": 68, "deletions": 67, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90469382c09fb5ed5602c30490d117aff172f7c2/libgfortran%2Fm4%2Fifunction_logical.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90469382c09fb5ed5602c30490d117aff172f7c2/libgfortran%2Fm4%2Fifunction_logical.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fifunction_logical.m4?ref=90469382c09fb5ed5602c30490d117aff172f7c2", "patch": "@@ -1,80 +1,66 @@\n-/* Implementation of the COUNT intrinsic\n-   Copyright 2002, 2007 Free Software Foundation, Inc.\n-   Contributed by Paul Brook <paul@nowt.org>\n-\n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n-\n-Libgfortran is free software; you can redistribute it and/or\n-modify it under the terms of the GNU General Public\n-License as published by the Free Software Foundation; either\n-version 2 of the License, or (at your option) any later version.\n-\n-In addition to the permissions in the GNU General Public License, the\n-Free Software Foundation gives you unlimited permission to link the\n-compiled version of this file into combinations with other programs,\n-and to distribute those combinations without any restriction coming\n-from the use of this file.  (The General Public License restrictions\n-do apply in other respects; for example, they cover modification of\n-the file, and distribution when not linked into a combine\n-executable.)\n-\n-Libgfortran is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public\n-License along with libgfortran; see the file COPYING.  If not,\n-write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n-Boston, MA 02110-1301, USA.  */\n-\n-#include \"libgfortran.h\"\n-#include <stdlib.h>\n-#include <assert.h>\n-\n-\n-#if defined (HAVE_GFC_LOGICAL_8) && defined (HAVE_GFC_INTEGER_16)\n-\n-\n-extern void count_16_l8 (gfc_array_i16 * const restrict, \n-\tgfc_array_l8 * const restrict, const index_type * const restrict);\n-export_proto(count_16_l8);\n+dnl Support macro file for intrinsic functions.\n+dnl Contains the generic sections of the array functions.\n+dnl This file is part of the GNU Fortran 95 Runtime Library (libgfortran)\n+dnl Distributed under the GNU GPL with exception.  See COPYING for details.\n+dnl\n+dnl Pass the implementation for a single section as the parameter to\n+dnl {MASK_}ARRAY_FUNCTION.\n+dnl The variables base, delta, and len describe the input section.\n+dnl For masked section the mask is described by mbase and mdelta.\n+dnl These should not be modified. The result should be stored in *dest.\n+dnl The names count, extent, sstride, dstride, base, dest, rank, dim\n+dnl retarray, array, pdim and mstride should not be used.\n+dnl The variable n is declared as index_type and may be used.\n+dnl Other variable declarations may be placed at the start of the code,\n+dnl The types of the array parameter and the return value are\n+dnl atype_name and rtype_name respectively.\n+dnl Execution should be allowed to continue to the end of the block.\n+dnl You should not return or break from the inner loop of the implementation.\n+dnl Care should also be taken to avoid using the names defined in iparm.m4\n+define(START_ARRAY_FUNCTION,\n+`\n+extern void name`'rtype_qual`_'atype_code (rtype * const restrict, \n+\tgfc_array_l1 * const restrict, const index_type * const restrict);\n+export_proto(name`'rtype_qual`_'atype_code);\n \n void\n-count_16_l8 (gfc_array_i16 * const restrict retarray, \n-\tgfc_array_l8 * const restrict array, \n+name`'rtype_qual`_'atype_code (rtype * const restrict retarray, \n+\tgfc_array_l1 * const restrict array, \n \tconst index_type * const restrict pdim)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n   index_type sstride[GFC_MAX_DIMENSIONS];\n   index_type dstride[GFC_MAX_DIMENSIONS];\n-  const GFC_LOGICAL_8 * restrict base;\n-  GFC_INTEGER_16 * restrict dest;\n+  const GFC_LOGICAL_1 * restrict base;\n+  rtype_name * restrict dest;\n   index_type rank;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type dim;\n+  int src_kind;\n \n   /* Make dim zero based to avoid confusion.  */\n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n+  src_kind = GFC_DESCRIPTOR_SIZE (array);\n+\n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n-  delta = array->dim[dim].stride;\n+  delta = array->dim[dim].stride * src_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n-      sstride[n] = array->dim[n].stride;\n+      sstride[n] = array->dim[n].stride * src_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n \textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n-      sstride[n] = array->dim[n + 1].stride;\n+      sstride[n] = array->dim[n + 1].stride * src_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -99,7 +85,7 @@ count_16_l8 (gfc_array_i16 * const restrict retarray,\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n \n-      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+      alloc_size = sizeof (rtype_name) * retarray->dim[rank-1].stride\n     \t\t   * extent[rank-1];\n \n       if (alloc_size == 0)\n@@ -116,9 +102,8 @@ count_16_l8 (gfc_array_i16 * const restrict retarray,\n     {\n       if (rank != GFC_DESCRIPTOR_RANK (retarray))\n \truntime_error (\"rank of return array incorrect in\"\n-\t\t       \" COUNT intrinsic: is %ld, should be %ld\",\n-\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n-\t\t       (long int) rank);\n+\t\t       \" u_name intrinsic: is %d, should be %d\",\n+\t\t       GFC_DESCRIPTOR_RANK (retarray), rank);\n \n       if (compile_options.bounds_check)\n \t{\n@@ -130,8 +115,8 @@ count_16_l8 (gfc_array_i16 * const restrict retarray,\n \t\t- retarray->dim[n].lbound;\n \t      if (extent[n] != ret_extent)\n \t\truntime_error (\"Incorrect extent in return value of\"\n-\t\t\t       \" COUNT intrinsic in dimension %ld:\"\n-\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       \" u_name intrinsic in dimension %d:\"\n+\t\t\t       \" is %ld, should be %ld\", n + 1,\n \t\t\t       (long int) ret_extent, (long int) extent[n]);\n \t    }\n \t}\n@@ -146,26 +131,38 @@ count_16_l8 (gfc_array_i16 * const restrict retarray,\n     }\n \n   base = array->data;\n+\n+  if (src_kind == 1 || src_kind == 2 || src_kind == 4 || src_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || src_kind == 16\n+#endif\n+    )\n+    {\n+      if (base)\n+\tbase = GFOR_POINTER_TO_L1 (base, src_kind);\n+    }\n+  else\n+    internal_error (NULL, \"Funny sized logical array in u_name intrinsic\");\n+\n   dest = retarray->data;\n \n   while (base)\n     {\n-      const GFC_LOGICAL_8 * restrict src;\n-      GFC_INTEGER_16 result;\n+      const GFC_LOGICAL_1 * restrict src;\n+      rtype_name result;\n       src = base;\n       {\n-\n-  result = 0;\n-        if (len <= 0)\n-\t  *dest = 0;\n+')dnl\n+define(START_ARRAY_BLOCK,\n+`        if (len <= 0)\n+\t  *dest = '$1`;\n \telse\n \t  {\n \t    for (n = 0; n < len; n++, src += delta)\n \t      {\n-\n-  if (*src)\n-    result++;\n-          }\n+')dnl\n+define(FINISH_ARRAY_FUNCTION,\n+    `          }\n \t    *dest = result;\n \t  }\n       }\n@@ -198,6 +195,10 @@ count_16_l8 (gfc_array_i16 * const restrict retarray,\n             }\n         }\n     }\n-}\n-\n-#endif\n+}')dnl\n+define(ARRAY_FUNCTION,\n+`START_ARRAY_FUNCTION\n+$2\n+START_ARRAY_BLOCK($1)\n+$3\n+FINISH_ARRAY_FUNCTION')dnl", "previous_filename": "libgfortran/generated/count_16_l8.c"}]}