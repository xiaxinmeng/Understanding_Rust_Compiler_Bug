{"sha": "efdc7e19ca67331ae7f0061c76964299db27242d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWZkYzdlMTljYTY3MzMxYWU3ZjAwNjFjNzY5NjQyOTlkYjI3MjQyZA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2002-09-16T16:36:39Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-09-16T16:36:39Z"}, "message": "real.c, real.h: Rewrite from scratch.\n\ngcc/\n\t* real.c, real.h: Rewrite from scratch.\n\n\t* Makefile.in (simplify-rtx.o): Depend on TREE_H.\n\t(paranoia): New target.\n\t* builtins.c (fold_builtin_inf): Use new real.h interface.\n\t* c-common.c (builtin_define_with_hex_fp_value): Likewise.\n\t* c-lex.c (interpret_float): Likewise.\n\t* emit-rtl.c (gen_lowpart_common): Likewise.\n\t* optabs.c (expand_float): Use real_2expN.\n\t* config/ia64/ia64.md (divsi3, udivsi3): Likewise.\n\t* defaults.h (INTEL_EXTENDED_IEEE_FORMAT): New.\n\t(FLOAT_WORDS_BIG_ENDIAN): New.\n\t* cse.c (find_comparison_args): Don't pass FLOAT_STORE_FLAG_VALUE\n\tdirectly to REAL_VALUE_NEGATIVE.\n\t* loop.c (canonicalize_condition): Likewise.\n\t* simplify-rtx.c: Include tree.h.\n\t(simplify_unary_operation): Don't handle FIX and UNSIGNED_FIX\n\twith floating-point result modes.\n\t* toplev.c (backend_init): Call init_real_once.\n\n\t* fold-const.c (force_fit_type): Don't call CHECK_FLOAT_VALUE.\n\t* tree.c (build_real): Likewise.\n\t* config/alpha/alpha.c, config/vax/vax.c (float_strings,\n\tfloat_values, inited_float_values, check_float_value): Remove.\n\t* config/alpha/alpha.h, config/m68hc11/m68hc11.h,\n\tconfig/m88k/m88k.h, config/vax/vax.h (CHECK_FLOAT_VALUE): Remove.\n\t* doc/tm.texi (CHECK_FLOAT_VALUE): Remove.\n\ngcc/f/\n\t* target.c (ffetarget_real1): Don't pass FFETARGET_ATOF_\n\tdirectly to ffetarget_make_real1.\n\t(ffetarget_real2): Similarly.\n\t* target.h (ffetarget_cvt_r1_to_rv_, ffetarget_cvt_rv_to_r2_,\n\tffetarget_cvt_r2_to_rv_): Use new real.h interface and simplify.\n\ngcc/java/\n\t* jcf-parse.c (get_constant): Runtime check for IEEE format;\n\tuse new real.h interface.\n\t* jcf-write.c (find_constant_index): Use new real.h interface.\n\t* lex.c (IS_ZERO): Use REAL_VALUES_EQUAL.\n\ncontrib/\n\t* paranoia.cc: New file.\n\nFrom-SVN: r57198", "tree": {"sha": "e6577420306f750f19abf6c590eb0d8987ca7485", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e6577420306f750f19abf6c590eb0d8987ca7485"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/efdc7e19ca67331ae7f0061c76964299db27242d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efdc7e19ca67331ae7f0061c76964299db27242d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/efdc7e19ca67331ae7f0061c76964299db27242d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efdc7e19ca67331ae7f0061c76964299db27242d/comments", "author": null, "committer": null, "parents": [{"sha": "1f73c622253e00cd295fe09e07d6acee7c943e4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f73c622253e00cd295fe09e07d6acee7c943e4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f73c622253e00cd295fe09e07d6acee7c943e4e"}], "stats": {"total": 12898, "additions": 6272, "deletions": 6626}, "files": [{"sha": "27ad70c2e0993bebbb8f1f4507023093ba7b7b92", "filename": "contrib/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efdc7e19ca67331ae7f0061c76964299db27242d/contrib%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efdc7e19ca67331ae7f0061c76964299db27242d/contrib%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2FChangeLog?ref=efdc7e19ca67331ae7f0061c76964299db27242d", "patch": "@@ -1,3 +1,7 @@\n+2002-09-16  Richard Henderson  <rth@redhat.com>\n+\n+\t* paranoia.cc: New file.\n+\n 2002-09-04  Richard Henderson  <rth@redhat.com>\n \n \t* enquire.c: Remove."}, {"sha": "0b87da9d690616df2980101f6107a811fe9ad825", "filename": "contrib/paranoia.cc", "status": "added", "additions": 2698, "deletions": 0, "changes": 2698, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efdc7e19ca67331ae7f0061c76964299db27242d/contrib%2Fparanoia.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efdc7e19ca67331ae7f0061c76964299db27242d/contrib%2Fparanoia.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fparanoia.cc?ref=efdc7e19ca67331ae7f0061c76964299db27242d", "patch": "@@ -0,0 +1,2698 @@\n+/*\tA C version of Kahan's Floating Point Test \"Paranoia\"\n+\n+Thos Sumner, UCSF, Feb. 1985\n+David Gay, BTL, Jan. 1986\n+\n+This is a rewrite from the Pascal version by\n+\n+B. A. Wichmann, 18 Jan. 1985\n+\n+(and does NOT exhibit good C programming style).\n+\n+Adjusted to use Standard C headers 19 Jan. 1992 (dmg);\n+\n+(C) Apr 19 1983 in BASIC version by:\n+Professor W. M. Kahan,\n+567 Evans Hall\n+Electrical Engineering & Computer Science Dept.\n+University of California\n+Berkeley, California 94720\n+USA\n+\n+converted to Pascal by:\n+B. A. Wichmann\n+National Physical Laboratory\n+Teddington Middx\n+TW11 OLW\n+UK\n+\n+converted to C by:\n+\n+David M. Gay\t\tand\tThos Sumner\n+AT&T Bell Labs\t\t\tComputer Center, Rm. U-76\n+600 Mountain Avenue\t\tUniversity of California\n+Murray Hill, NJ 07974\t\tSan Francisco, CA 94143\n+USA\t\t\t\tUSA\n+\n+with simultaneous corrections to the Pascal source (reflected\n+in the Pascal source available over netlib).\n+[A couple of bug fixes from dgh = sun!dhough incorporated 31 July 1986.]\n+\n+Reports of results on various systems from all the versions\n+of Paranoia are being collected by Richard Karpinski at the\n+same address as Thos Sumner.  This includes sample outputs,\n+bug reports, and criticisms.\n+\n+You may copy this program freely if you acknowledge its source.\n+Comments on the Pascal version to NPL, please.\n+\n+The following is from the introductory commentary from Wichmann's work:\n+\n+The BASIC program of Kahan is written in Microsoft BASIC using many\n+facilities which have no exact analogy in Pascal.  The Pascal\n+version below cannot therefore be exactly the same.  Rather than be\n+a minimal transcription of the BASIC program, the Pascal coding\n+follows the conventional style of block-structured languages.  Hence\n+the Pascal version could be useful in producing versions in other\n+structured languages.\n+\n+Rather than use identifiers of minimal length (which therefore have\n+little mnemonic significance), the Pascal version uses meaningful\n+identifiers as follows [Note: A few changes have been made for C]:\n+\n+\n+BASIC   C               BASIC   C               BASIC   C\n+\n+A                       J                       S    StickyBit\n+A1   AInverse           J0   NoErrors           T\n+B    Radix                    [Failure]         T0   Underflow\n+B1   BInverse           J1   NoErrors           T2   ThirtyTwo\n+B2   RadixD2                  [SeriousDefect]   T5   OneAndHalf\n+B9   BMinusU2           J2   NoErrors           T7   TwentySeven\n+C                             [Defect]          T8   TwoForty\n+C1   CInverse           J3   NoErrors           U    OneUlp\n+D                             [Flaw]            U0   UnderflowThreshold\n+D4   FourD              K    PageNo             U1\n+E0                      L    Milestone          U2\n+E1                      M                       V\n+E2   Exp2               N                       V0\n+E3                      N1                      V8\n+E5   MinSqEr            O    Zero               V9\n+E6   SqEr               O1   One                W\n+E7   MaxSqEr            O2   Two                X\n+E8                      O3   Three              X1\n+E9                      O4   Four               X8\n+F1   MinusOne           O5   Five               X9   Random1\n+F2   Half               O8   Eight              Y\n+F3   Third              O9   Nine               Y1\n+F6                      P    Precision          Y2\n+F9                      Q                       Y9   Random2\n+G1   GMult              Q8                      Z\n+G2   GDiv               Q9                      Z0   PseudoZero\n+G3   GAddSub            R                       Z1\n+H                       R1   RMult              Z2\n+H1   HInverse           R2   RDiv               Z9\n+I                       R3   RAddSub\n+IO   NoTrials           R4   RSqrt\n+I3   IEEE               R9   Random9\n+\n+SqRWrng\n+\n+All the variables in BASIC are true variables and in consequence,\n+the program is more difficult to follow since the \"constants\" must\n+be determined (the glossary is very helpful).  The Pascal version\n+uses Real constants, but checks are added to ensure that the values\n+are correctly converted by the compiler.\n+\n+The major textual change to the Pascal version apart from the\n+identifiersis that named procedures are used, inserting parameters\n+wherehelpful.  New procedures are also introduced.  The\n+correspondence is as follows:\n+\n+\n+BASIC       Pascal\n+lines\n+\n+90- 140   Pause\n+170- 250   Instructions\n+380- 460   Heading\n+480- 670   Characteristics\n+690- 870   History\n+2940-2950   Random\n+3710-3740   NewD\n+4040-4080   DoesYequalX\n+4090-4110   PrintIfNPositive\n+4640-4850   TestPartialUnderflow\n+\n+*/\n+\n+  /* This version of paranoia has been modified to work with GCC's internal\n+     software floating point emulation library, as a sanity check of same.\n+\n+     I'm doing this in C++ so that I can do operator overloading and not\n+     have to modify so damned much of the existing code.  */\n+\n+  extern \"C\" {\n+#include <stdio.h>\n+#include <stddef.h>\n+#include <limits.h>\n+#include <string.h>\n+#include <stdlib.h>\n+#include <math.h>\n+#include <unistd.h>\n+#include <float.h>\n+\n+    /* This part is made all the more awful because many gcc headers are\n+       not prepared at all to be parsed as C++.  The biggest stickler\n+       here is const structure members.  So we include exactly the pieces\n+       that we need.  */\n+\n+#define GTY(x)\n+\n+#include \"ansidecl.h\"\n+#include \"auto-host.h\"\n+#include \"hwint.h\"\n+\n+#undef EXTRA_MODES_FILE\n+\n+    struct rtx_def;\n+    typedef struct rtx_def *rtx;\n+    struct rtvec_def;\n+    typedef struct rtvec_def *rtvec;\n+    union tree_node;\n+    typedef union tree_node *tree;\n+\n+#define DEFTREECODE(SYM, STRING, TYPE, NARGS)   SYM,\n+    enum tree_code {\n+#include \"tree.def\"\n+      LAST_AND_UNUSED_TREE_CODE\n+    };\n+#undef DEFTREECODE\n+\n+#include \"real.h\"\n+  }\n+\n+/* We never produce signals from the library.  Thus setjmp need do nothing.  */\n+#undef setjmp\n+#define setjmp(x)  (0)\n+\n+static bool verbose = false;\n+static int verbose_index = 0;\n+\n+/* ====================================================================== */\n+/* The implementation of the abstract floating point class based on gcc's\n+   real.c.  I.e. the object of this excersize.  Templated so that we can\n+   all fp sizes.  */\n+\n+template<int SIZE, enum machine_mode MODE>\n+class real_c_float\n+{\n+ private:\n+  long image[SIZE / 32];\n+\n+  void from_long(long);\n+  void from_str(const char *);\n+  void binop(int code, const real_c_float&);\n+  void unop(int code);\n+  bool cmp(int code, const real_c_float&) const;\n+\n+ public:\n+  real_c_float()\n+    { }\n+  real_c_float(long l)\n+    { from_long(l); }\n+  real_c_float(const char *s)\n+    { from_str(s); }\n+  real_c_float(const real_c_float &b)\n+    { memcpy(image, b.image, sizeof(image)); }\n+\n+  const real_c_float& operator= (long l)\n+    { from_long(l); return *this; }\n+  const real_c_float& operator= (const char *s)\n+    { from_str(s); return *this; }\n+  const real_c_float& operator= (const real_c_float &b)\n+    { memcpy(image, b.image, sizeof(image)); return *this; }\n+\n+  const real_c_float& operator+= (const real_c_float &b)\n+    { binop(PLUS_EXPR, b); return *this; }\n+  const real_c_float& operator-= (const real_c_float &b)\n+    { binop(MINUS_EXPR, b); return *this; }\n+  const real_c_float& operator*= (const real_c_float &b)\n+    { binop(MULT_EXPR, b); return *this; }\n+  const real_c_float& operator/= (const real_c_float &b)\n+    { binop(RDIV_EXPR, b); return *this; }\n+\n+  real_c_float operator- () const\n+    { real_c_float r(*this); r.unop(NEGATE_EXPR); return r; }\n+  real_c_float abs () const\n+    { real_c_float r(*this); r.unop(ABS_EXPR); return r; }\n+\n+  bool operator <  (const real_c_float &b) const { return cmp(LT_EXPR, b); }\n+  bool operator <= (const real_c_float &b) const { return cmp(LE_EXPR, b); }\n+  bool operator == (const real_c_float &b) const { return cmp(EQ_EXPR, b); }\n+  bool operator != (const real_c_float &b) const { return cmp(NE_EXPR, b); }\n+  bool operator >= (const real_c_float &b) const { return cmp(GE_EXPR, b); }\n+  bool operator >  (const real_c_float &b) const { return cmp(GT_EXPR, b); }\n+\n+  const char * str () const;\n+  const char * hex () const;\n+  long integer () const;\n+  int exp () const;\n+  void ldexp (int);\n+};\n+\n+template<int SIZE, enum machine_mode MODE>\n+void\n+real_c_float<SIZE, MODE>::from_long (long l)\n+{\n+  REAL_VALUE_TYPE f;\n+\n+  real_from_integer (&f, MODE, l, l < 0 ? -1 : 0, 0);\n+  real_to_target (image, &f, MODE);\n+}\n+\n+template<int SIZE, enum machine_mode MODE>\n+void\n+real_c_float<SIZE, MODE>::from_str (const char *s)\n+{\n+  REAL_VALUE_TYPE f;\n+  char *p = s;\n+\n+  if (*p == '-' || *p == '+')\n+    p++;\n+  if (strcasecmp(p, \"inf\") == 0)\n+    {\n+      real_inf (&f);\n+      if (*s == '-')\n+        real_arithmetic (&f, NEGATE_EXPR, &f, NULL);\n+    }\n+  else if (strcasecmp(p, \"nan\") == 0)\n+    real_nan (&f, \"\", 1, MODE);\n+  else\n+    real_from_string (&f, s);\n+\n+  real_to_target (image, &f, MODE);\n+}\n+\n+template<int SIZE, enum machine_mode MODE>\n+void\n+real_c_float<SIZE, MODE>::binop (int code, const real_c_float &b)\n+{\n+  REAL_VALUE_TYPE ai, bi, ri;\n+\n+  real_from_target (&ai, image, MODE);\n+  real_from_target (&bi, b.image, MODE);\n+  real_arithmetic (&ri, code, &ai, &bi);\n+  real_to_target (image, &ri, MODE);\n+\n+  if (verbose)\n+    {\n+      char ab[64], bb[64], rb[64];\n+      const int digits = int(SIZE / 4);\n+      char symbol_for_code;\n+\n+      real_from_target (&ri, image, MODE);\n+      real_to_hexadecimal (ab, &ai, digits);\n+      real_to_hexadecimal (bb, &bi, digits);\n+      real_to_hexadecimal (rb, &ri, digits);\n+\n+      switch (code)\n+\t{\n+\tcase PLUS_EXPR:\n+\t  symbol_for_code = '+';\n+\t  break;\n+\tcase MINUS_EXPR:\n+\t  symbol_for_code = '-';\n+\t  break;\n+\tcase MULT_EXPR:\n+\t  symbol_for_code = '*';\n+\t  break;\n+\tcase RDIV_EXPR:\n+\t  symbol_for_code = '/';\n+\t  break;\n+\tdefault:\n+\t  abort ();\n+\t}\n+\n+      fprintf (stderr, \"%6d: %s %c %s = %s\\n\", verbose_index++,\n+\t       ab, symbol_for_code, bb, rb);\n+    }\n+}\n+\n+template<int SIZE, enum machine_mode MODE>\n+void\n+real_c_float<SIZE, MODE>::unop (int code)\n+{\n+  REAL_VALUE_TYPE ai, ri;\n+\n+  real_from_target (&ai, image, MODE);\n+  real_arithmetic (&ri, code, &ai, NULL);\n+  real_to_target (image, &ri, MODE);\n+\n+  if (verbose)\n+    {\n+      char ab[64], rb[64];\n+      const int digits = int(SIZE / 4);\n+      const char *symbol_for_code;\n+\n+      real_from_target (&ri, image, MODE);\n+      real_to_hexadecimal (ab, &ai, digits);\n+      real_to_hexadecimal (rb, &ri, digits);\n+\n+      switch (code)\n+\t{\n+\tcase NEGATE_EXPR:\n+\t  symbol_for_code = \"-\";\n+\t  break;\n+\tcase ABS_EXPR:\n+\t  symbol_for_code = \"abs \";\n+\t  break;\n+\tdefault:\n+\t  abort ();\n+\t}\n+\n+      fprintf (stderr, \"%6d: %s%s = %s\\n\", verbose_index++,\n+\t       symbol_for_code, ab, rb);\n+    }\n+}\n+\n+template<int SIZE, enum machine_mode MODE>\n+bool\n+real_c_float<SIZE, MODE>::cmp (int code, const real_c_float &b) const\n+{\n+  REAL_VALUE_TYPE ai, bi;\n+  bool ret;\n+\n+  real_from_target (&ai, image, MODE);\n+  real_from_target (&bi, b.image, MODE);\n+  ret = real_compare (code, &ai, &bi);\n+\n+  if (verbose)\n+    {\n+      char ab[64], bb[64];\n+      const int digits = int(SIZE / 4);\n+      const char *symbol_for_code;\n+\n+      real_to_hexadecimal (ab, &ai, digits);\n+      real_to_hexadecimal (bb, &bi, digits);\n+\n+      switch (code)\n+\t{\n+\tcase LT_EXPR:\n+\t  symbol_for_code = \"<\";\n+\t  break;\n+\tcase LE_EXPR:\n+\t  symbol_for_code = \"<=\";\n+\t  break;\n+\tcase EQ_EXPR:\n+\t  symbol_for_code = \"==\";\n+\t  break;\n+\tcase NE_EXPR:\n+\t  symbol_for_code = \"!=\";\n+\t  break;\n+\tcase GE_EXPR:\n+\t  symbol_for_code = \">=\";\n+\t  break;\n+\tcase GT_EXPR:\n+\t  symbol_for_code = \">\";\n+\t  break;\n+\tdefault:\n+\t  abort ();\n+\t}\n+\n+      fprintf (stderr, \"%6d: %s %s %s = %s\\n\", verbose_index++,\n+\t       ab, symbol_for_code, bb, (ret ? \"true\" : \"false\"));\n+    }\n+\n+  return ret;\n+}\n+\n+template<int SIZE, enum machine_mode MODE>\n+const char *\n+real_c_float<SIZE, MODE>::str() const\n+{\n+  REAL_VALUE_TYPE f;\n+  const int digits = int(SIZE * .30102999566398119521 + 1);\n+\n+  real_from_target (&f, image, MODE);\n+  char *buf = new char[digits + 10];\n+  real_to_decimal (buf, &f, digits);\n+\n+  return buf;\n+}\n+\n+template<int SIZE, enum machine_mode MODE>\n+const char *\n+real_c_float<SIZE, MODE>::hex() const\n+{\n+  REAL_VALUE_TYPE f;\n+  const int digits = int(SIZE / 4);\n+\n+  real_from_target (&f, image, MODE);\n+  char *buf = new char[digits + 10];\n+  real_to_hexadecimal (buf, &f, digits);\n+\n+  return buf;\n+}\n+\n+template<int SIZE, enum machine_mode MODE>\n+long\n+real_c_float<SIZE, MODE>::integer() const\n+{\n+  REAL_VALUE_TYPE f;\n+  real_from_target (&f, image, MODE);\n+  return real_to_integer (&f);\n+}\n+\n+template<int SIZE, enum machine_mode MODE>\n+int\n+real_c_float<SIZE, MODE>::exp() const\n+{\n+  REAL_VALUE_TYPE f;\n+  real_from_target (&f, image, MODE);\n+  return real_exponent (&f);\n+}\n+\n+template<int SIZE, enum machine_mode MODE>\n+void\n+real_c_float<SIZE, MODE>::ldexp (int exp)\n+{\n+  REAL_VALUE_TYPE ai;\n+\n+  real_from_target (&ai, image, MODE);\n+  real_ldexp (&ai, &ai, exp);\n+  real_to_target (image, &ai, MODE);\n+}\n+\n+/* ====================================================================== */\n+/* An implementation of the abstract floating point class that uses native\n+   arithmetic.  Exists for reference and debugging.  */\n+\n+template<typename T>\n+class native_float\n+{\n+ private:\n+  // Force intermediate results back to memory.\n+  volatile T image;\n+\n+  static T from_str (const char *);\n+  static T do_abs (T);\n+  static T verbose_binop (T, char, T, T);\n+  static T verbose_unop (const char *, T, T);\n+  static bool verbose_cmp (T, const char *, T, bool);\n+\n+ public:\n+  native_float()\n+    { }\n+  native_float(long l)\n+    { image = l; }\n+  native_float(const char *s)\n+    { image = from_str(s); }\n+  native_float(const native_float &b)\n+    { image = b.image; }\n+\n+  const native_float& operator= (long l)\n+    { image = l; return *this; }\n+  const native_float& operator= (const char *s)\n+    { image = from_str(s); return *this; }\n+  const native_float& operator= (const native_float &b)\n+    { image = b.image; return *this; }\n+\n+  const native_float& operator+= (const native_float &b)\n+    {\n+      image = verbose_binop(image, '+', b.image, image + b.image);\n+      return *this;\n+    }\n+  const native_float& operator-= (const native_float &b)\n+    {\n+      image = verbose_binop(image, '-', b.image, image - b.image);\n+      return *this;\n+    }\n+  const native_float& operator*= (const native_float &b)\n+    {\n+      image = verbose_binop(image, '*', b.image, image * b.image);\n+      return *this;\n+    }\n+  const native_float& operator/= (const native_float &b)\n+    {\n+      image = verbose_binop(image, '/', b.image, image / b.image);\n+      return *this;\n+    }\n+\n+  native_float operator- () const\n+    {\n+      native_float r;\n+      r.image = verbose_unop(\"-\", image, -image);\n+      return r;\n+    }\n+  native_float abs () const\n+    {\n+      native_float r;\n+      r.image = verbose_unop(\"abs \", image, do_abs(image));\n+      return r;\n+    }\n+\n+  bool operator <  (const native_float &b) const\n+    { return verbose_cmp(image, \"<\", b.image, image <  b.image); }\n+  bool operator <= (const native_float &b) const\n+    { return verbose_cmp(image, \"<=\", b.image, image <= b.image); }\n+  bool operator == (const native_float &b) const\n+    { return verbose_cmp(image, \"==\", b.image, image == b.image); }\n+  bool operator != (const native_float &b) const\n+    { return verbose_cmp(image, \"!=\", b.image, image != b.image); }\n+  bool operator >= (const native_float &b) const\n+    { return verbose_cmp(image, \">=\", b.image, image >= b.image); }\n+  bool operator >  (const native_float &b) const\n+    { return verbose_cmp(image, \">\", b.image, image > b.image); }\n+\n+  const char * str () const;\n+  const char * hex () const;\n+  long integer () const\n+    { return long(image); }\n+  int exp () const;\n+  void ldexp (int);\n+};\n+\n+template<typename T>\n+inline T\n+native_float<T>::from_str (const char *s)\n+{\n+  return strtold (s, NULL);\n+}\n+\n+template<>\n+inline float\n+native_float<float>::from_str (const char *s)\n+{\n+  return strtof (s, NULL);\n+}\n+\n+template<>\n+inline double\n+native_float<double>::from_str (const char *s)\n+{\n+  return strtod (s, NULL);\n+}\n+\n+template<typename T>\n+inline T\n+native_float<T>::do_abs (T image)\n+{\n+  return fabsl (image);\n+}\n+\n+template<>\n+inline float\n+native_float<float>::do_abs (float image)\n+{\n+  return fabsf (image);\n+}\n+\n+template<>\n+inline double\n+native_float<double>::do_abs (double image)\n+{\n+  return fabs (image);\n+}\n+\n+template<typename T>\n+T\n+native_float<T>::verbose_binop (T a, char symbol, T b, T r)\n+{\n+  if (verbose)\n+    {\n+      const int digits = int(sizeof(T) * CHAR_BIT / 4) - 1;\n+#ifdef NO_LONG_DOUBLE\n+      fprintf (stderr, \"%6d: %.*a %c %.*a = %.*a\\n\", verbose_index++,\n+\t       digits, (double)a, symbol,\n+\t       digits, (double)b, digits, (double)r);\n+#else\n+      fprintf (stderr, \"%6d: %.*La %c %.*La = %.*La\\n\", verbose_index++,\n+\t       digits, (long double)a, symbol,\n+\t       digits, (long double)b, digits, (long double)r);\n+#endif\n+    }\n+  return r;\n+}\n+\n+template<typename T>\n+T\n+native_float<T>::verbose_unop (const char *symbol, T a, T r)\n+{\n+  if (verbose)\n+    {\n+      const int digits = int(sizeof(T) * CHAR_BIT / 4) - 1;\n+#ifdef NO_LONG_DOUBLE\n+      fprintf (stderr, \"%6d: %s%.*a = %.*a\\n\", verbose_index++,\n+\t       symbol, digits, (double)a, digits, (double)r);\n+#else\n+      fprintf (stderr, \"%6d: %s%.*La = %.*La\\n\", verbose_index++,\n+\t       symbol, digits, (long double)a, digits, (long double)r);\n+#endif\n+    }\n+  return r;\n+}\n+\n+template<typename T>\n+bool\n+native_float<T>::verbose_cmp (T a, const char *symbol, T b, bool r)\n+{\n+  if (verbose)\n+    {\n+      const int digits = int(sizeof(T) * CHAR_BIT / 4) - 1;\n+#ifndef NO_LONG_DOUBLE\n+      fprintf (stderr, \"%6d: %.*a %s %.*a = %s\\n\", verbose_index++,\n+\t       digits, (double)a, symbol,\n+\t       digits, (double)b, (r ? \"true\" : \"false\"));\n+#else\n+      fprintf (stderr, \"%6d: %.*La %s %.*La = %s\\n\", verbose_index++,\n+\t       digits, (long double)a, symbol,\n+\t       digits, (long double)b, (r ? \"true\" : \"false\"));\n+#endif\n+    }\n+  return r;\n+}\n+\n+template<typename T>\n+const char *\n+native_float<T>::str() const\n+{\n+  char *buf = new char[50];\n+  const int digits = int(sizeof(T) * CHAR_BIT * .30102999566398119521 + 1);\n+#ifndef NO_LONG_DOUBLE\n+  sprintf (buf, \"%.*e\", digits - 1, (double) image);\n+#else\n+  sprintf (buf, \"%.*Le\", digits - 1, (long double) image);\n+#endif\n+  return buf;\n+}\n+\n+template<typename T>\n+const char *\n+native_float<T>::hex() const\n+{\n+  char *buf = new char[50];\n+  const int digits = int(sizeof(T) * CHAR_BIT / 4);\n+#ifndef NO_LONG_DOUBLE\n+  sprintf (buf, \"%.*a\", digits - 1, (double) image);\n+#else\n+  sprintf (buf, \"%.*La\", digits - 1, (long double) image);\n+#endif\n+  return buf;\n+}\n+\n+template<typename T>\n+int\n+native_float<T>::exp() const\n+{\n+  int e;\n+  frexp (image, &e);\n+  return e;\n+}\n+\n+template<typename T>\n+void\n+native_float<T>::ldexp (int exp)\n+{\n+  image = ldexpl (image, exp);\n+}\n+\n+template<>\n+void\n+native_float<float>::ldexp (int exp)\n+{\n+  image = ldexpf (image, exp);\n+}\n+\n+template<>\n+void\n+native_float<double>::ldexp (int exp)\n+{\n+  image = ::ldexp (image, exp);\n+}\n+\n+/* ====================================================================== */\n+/* Some libm routines that Paranoia expects to be available.  */\n+\n+template<typename FLOAT>\n+inline FLOAT\n+FABS (const FLOAT &f)\n+{\n+  return f.abs();\n+}\n+\n+template<typename FLOAT, typename RHS>\n+inline FLOAT\n+operator+ (const FLOAT &a, const RHS &b)\n+{\n+  return FLOAT(a) += FLOAT(b);\n+}\n+\n+template<typename FLOAT, typename RHS>\n+inline FLOAT\n+operator- (const FLOAT &a, const RHS &b)\n+{\n+  return FLOAT(a) -= FLOAT(b);\n+}\n+\n+template<typename FLOAT, typename RHS>\n+inline FLOAT\n+operator* (const FLOAT &a, const RHS &b)\n+{\n+  return FLOAT(a) *= FLOAT(b);\n+}\n+\n+template<typename FLOAT, typename RHS>\n+inline FLOAT\n+operator/ (const FLOAT &a, const RHS &b)\n+{\n+  return FLOAT(a) /= FLOAT(b);\n+}\n+\n+template<typename FLOAT>\n+FLOAT\n+FLOOR (const FLOAT &f)\n+{\n+  /* ??? This is only correct when F is representable as an integer.  */\n+  long i = f.integer();\n+  FLOAT r;\n+\n+  r = i;\n+  if (i < 0 && f != r)\n+    r = i - 1;\n+\n+  return r;\n+}\n+\n+template<typename FLOAT>\n+FLOAT\n+SQRT (const FLOAT &f)\n+{\n+#if 0\n+  FLOAT zero = long(0);\n+  FLOAT two = 2;\n+  FLOAT one = 1;\n+  FLOAT diff, diff2;\n+  FLOAT z, t;\n+\n+  if (f == zero)\n+    return zero;\n+  if (f < zero)\n+    return zero / zero;\n+  if (f == one)\n+    return f;\n+\n+  z = f;\n+  z.ldexp (-f.exp() / 2);\n+\n+  diff2 = FABS (z * z - f);\n+  if (diff2 > zero)\n+    while (1)\n+      {\n+\tt = (f / (two * z)) + (z / two);\n+\tdiff = FABS (t * t - f);\n+\tif (diff >= diff2)\n+\t  break;\n+\tz = t;\n+\tdiff2 = diff;\n+      }\n+\n+  return z;\n+#elif defined(NO_LONG_DOUBLE)\n+  double d;\n+  char buf[64];\n+\n+  d = strtod (f.hex(), NULL);\n+  d = sqrt (d);\n+  sprintf(buf, \"%.35a\", d);\n+\n+  return FLOAT(buf);\n+#else\n+  long double ld;\n+  char buf[64];\n+\n+  ld = strtold (f.hex(), NULL);\n+  ld = sqrtl (ld);\n+  sprintf(buf, \"%.35La\", ld);\n+\n+  return FLOAT(buf);\n+#endif\n+}\n+\n+template<typename FLOAT>\n+FLOAT\n+LOG (FLOAT x)\n+{\n+#if 0\n+  FLOAT zero = long(0);\n+  FLOAT one = 1;\n+\n+  if (x <= zero)\n+    return zero / zero;\n+  if (x == one)\n+    return zero;\n+\n+  int exp = x.exp() - 1;\n+  x.ldexp(-exp);\n+\n+  FLOAT xm1 = x - one;\n+  FLOAT y = xm1;\n+  long n = 2;\n+\n+  FLOAT sum = xm1;\n+  while (1)\n+    {\n+      y *= xm1;\n+      FLOAT term = y / FLOAT (n);\n+      FLOAT next = sum + term;\n+      if (next == sum)\n+\tbreak;\n+      sum = next;\n+      if (++n == 1000)\n+\tbreak;\n+    }\n+\n+  if (exp)\n+    sum += FLOAT (exp) * FLOAT(\".69314718055994530941\");\n+\n+  return sum;\n+#elif defined (NO_LONG_DOUBLE)\n+  double d;\n+  char buf[64];\n+\n+  d = strtod (x.hex(), NULL);\n+  d = log (d);\n+  sprintf(buf, \"%.35a\", d);\n+\n+  return FLOAT(buf);\n+#else\n+  long double ld;\n+  char buf[64];\n+\n+  ld = strtold (x.hex(), NULL);\n+  ld = logl (ld);\n+  sprintf(buf, \"%.35La\", ld);\n+\n+  return FLOAT(buf);\n+#endif\n+}\n+\n+template<typename FLOAT>\n+FLOAT\n+EXP (const FLOAT &x)\n+{\n+  /* Cheat.  */\n+#ifdef NO_LONG_DOUBLE\n+  double d;\n+  char buf[64];\n+\n+  d = strtod (x.hex(), NULL);\n+  d = exp (d);\n+  sprintf(buf, \"%.35a\", d);\n+\n+  return FLOAT(buf);\n+#else\n+  long double ld;\n+  char buf[64];\n+\n+  ld = strtold (x.hex(), NULL);\n+  ld = expl (ld);\n+  sprintf(buf, \"%.35La\", ld);\n+\n+  return FLOAT(buf);\n+#endif\n+}\n+\n+template<typename FLOAT>\n+FLOAT\n+POW (const FLOAT &base, const FLOAT &exp)\n+{\n+  /* Cheat.  */\n+#ifdef NO_LONG_DOUBLE\n+  double d1, d2;\n+  char buf[64];\n+\n+  d1 = strtod (base.hex(), NULL);\n+  d2 = strtod (exp.hex(), NULL);\n+  d1 = pow (d1, d2);\n+  sprintf(buf, \"%.35a\", d1);\n+\n+  return FLOAT(buf);\n+#else\n+  long double ld1, ld2;\n+  char buf[64];\n+\n+  ld1 = strtold (base.hex(), NULL);\n+  ld2 = strtold (exp.hex(), NULL);\n+  ld1 = powl (ld1, ld2);\n+  sprintf(buf, \"%.35La\", ld1);\n+\n+  return FLOAT(buf);\n+#endif\n+}\n+\n+/* ====================================================================== */\n+/* Real Paranoia begins again here.  We wrap the thing in a template so\n+   that we can instantiate it for each floating point type we care for.  */\n+\n+int NoTrials = 20;\t\t/*Number of tests for commutativity. */\n+bool do_pause = false;\n+\n+enum Guard { No, Yes };\n+enum Rounding { Other, Rounded, Chopped };\n+enum Class { Failure, Serious, Defect, Flaw };\n+\n+template<typename FLOAT>\n+struct Paranoia\n+{\n+  FLOAT Radix, BInvrse, RadixD2, BMinusU2;\n+\n+  /* Small floating point constants.  */\n+  FLOAT Zero;\n+  FLOAT Half;\n+  FLOAT One;\n+  FLOAT Two;\n+  FLOAT Three;\n+  FLOAT Four;\n+  FLOAT Five;\n+  FLOAT Eight;\n+  FLOAT Nine;\n+  FLOAT TwentySeven;\n+  FLOAT ThirtyTwo;\n+  FLOAT TwoForty;\n+  FLOAT MinusOne;\n+  FLOAT OneAndHalf;\n+\n+  /* Declarations of Variables.  */\n+  int Indx;\n+  char ch[8];\n+  FLOAT AInvrse, A1;\n+  FLOAT C, CInvrse;\n+  FLOAT D, FourD;\n+  FLOAT E0, E1, Exp2, E3, MinSqEr;\n+  FLOAT SqEr, MaxSqEr, E9;\n+  FLOAT Third;\n+  FLOAT F6, F9;\n+  FLOAT H, HInvrse;\n+  int I;\n+  FLOAT StickyBit, J;\n+  FLOAT MyZero;\n+  FLOAT Precision;\n+  FLOAT Q, Q9;\n+  FLOAT R, Random9;\n+  FLOAT T, Underflow, S;\n+  FLOAT OneUlp, UfThold, U1, U2;\n+  FLOAT V, V0, V9;\n+  FLOAT W;\n+  FLOAT X, X1, X2, X8, Random1;\n+  FLOAT Y, Y1, Y2, Random2;\n+  FLOAT Z, PseudoZero, Z1, Z2, Z9;\n+  int ErrCnt[4];\n+  int Milestone;\n+  int PageNo;\n+  int M, N, N1;\n+  Guard GMult, GDiv, GAddSub;\n+  Rounding RMult, RDiv, RAddSub, RSqrt;\n+  int Break, Done, NotMonot, Monot, Anomaly, IEEE, SqRWrng, UfNGrad;\n+\n+  /* Computed constants. */\n+  /*U1  gap below 1.0, i.e, 1.0-U1 is next number below 1.0 */\n+  /*U2  gap above 1.0, i.e, 1.0+U2 is next number above 1.0 */\n+\n+  int main ();\n+\n+  FLOAT Sign (FLOAT);\n+  FLOAT Random ();\n+  void Pause ();\n+  void BadCond (int, const char *);\n+  void SqXMinX (int);\n+  void TstCond (int, int, const char *);\n+  void notify (const char *);\n+  void IsYeqX ();\n+  void NewD ();\n+  void PrintIfNPositive ();\n+  void SR3750 ();\n+  void TstPtUf ();\n+\n+  // Pretend we're bss.\n+  Paranoia() { memset(this, 0, sizeof (*this)); }\n+};\n+\n+template<typename FLOAT>\n+int\n+Paranoia<FLOAT>::main()\n+{\n+  /* First two assignments use integer right-hand sides. */\n+  Zero = long(0);\n+  One = long(1);\n+  Two = long(2);\n+  Three = long(3);\n+  Four = long(4);\n+  Five = long(5);\n+  Eight = long(8);\n+  Nine = long(9);\n+  TwentySeven = long(27);\n+  ThirtyTwo = long(32);\n+  TwoForty = long(240);\n+  MinusOne = long(-1);\n+  Half = \"0x1p-1\";\n+  OneAndHalf = \"0x3p-1\";\n+  ErrCnt[Failure] = 0;\n+  ErrCnt[Serious] = 0;\n+  ErrCnt[Defect] = 0;\n+  ErrCnt[Flaw] = 0;\n+  PageNo = 1;\n+\t/*=============================================*/\n+  Milestone = 7;\n+\t/*=============================================*/\n+  printf (\"Program is now RUNNING tests on small integers:\\n\");\n+\n+  TstCond (Failure, (Zero + Zero == Zero), \"0+0 != 0\");\n+  TstCond (Failure, (One - One == Zero), \"1-1 != 0\");\n+  TstCond (Failure, (One > Zero), \"1 <= 0\");\n+  TstCond (Failure, (One + One == Two), \"1+1 != 2\");\n+\n+  Z = -Zero;\n+  if (Z != Zero)\n+    {\n+      ErrCnt[Failure] = ErrCnt[Failure] + 1;\n+      printf (\"Comparison alleges that -0.0 is Non-zero!\\n\");\n+      U2 = \"0.001\";\n+      Radix = 1;\n+      TstPtUf ();\n+    }\n+\n+  TstCond (Failure, (Three == Two + One), \"3 != 2+1\");\n+  TstCond (Failure, (Four == Three + One), \"4 != 3+1\");\n+  TstCond (Failure, (Four + Two * (-Two) == Zero), \"4 + 2*(-2) != 0\");\n+  TstCond (Failure, (Four - Three - One == Zero), \"4-3-1 != 0\");\n+\n+  TstCond (Failure, (MinusOne == (Zero - One)), \"-1 != 0-1\");\n+  TstCond (Failure, (MinusOne + One == Zero), \"-1+1 != 0\");\n+  TstCond (Failure, (One + MinusOne == Zero), \"1+(-1) != 0\");\n+  TstCond (Failure, (MinusOne + FABS (One) == Zero), \"-1+abs(1) != 0\");\n+  TstCond (Failure, (MinusOne + MinusOne * MinusOne == Zero),\n+\t   \"-1+(-1)*(-1) != 0\");\n+\n+  TstCond (Failure, Half + MinusOne + Half == Zero, \"1/2 + (-1) + 1/2 != 0\");\n+\n+\t/*=============================================*/\n+  Milestone = 10;\n+\t/*=============================================*/\n+\n+  TstCond (Failure, (Nine == Three * Three), \"9 != 3*3\");\n+  TstCond (Failure, (TwentySeven == Nine * Three), \"27 != 9*3\");\n+  TstCond (Failure, (Eight == Four + Four), \"8 != 4+4\");\n+  TstCond (Failure, (ThirtyTwo == Eight * Four), \"32 != 8*4\");\n+  TstCond (Failure, (ThirtyTwo - TwentySeven - Four - One == Zero),\n+\t   \"32-27-4-1 != 0\");\n+\n+  TstCond (Failure, Five == Four + One, \"5 != 4+1\");\n+  TstCond (Failure, TwoForty == Four * Five * Three * Four, \"240 != 4*5*3*4\");\n+  TstCond (Failure, TwoForty / Three - Four * Four * Five == Zero,\n+\t   \"240/3 - 4*4*5 != 0\");\n+  TstCond (Failure, TwoForty / Four - Five * Three * Four == Zero,\n+\t   \"240/4 - 5*3*4 != 0\");\n+  TstCond (Failure, TwoForty / Five - Four * Three * Four == Zero,\n+\t   \"240/5 - 4*3*4 != 0\");\n+\n+  if (ErrCnt[Failure] == 0)\n+    {\n+      printf (\"-1, 0, 1/2, 1, 2, 3, 4, 5, 9, 27, 32 & 240 are O.K.\\n\");\n+      printf (\"\\n\");\n+    }\n+  printf (\"Searching for Radix and Precision.\\n\");\n+  W = One;\n+  do\n+    {\n+      W = W + W;\n+      Y = W + One;\n+      Z = Y - W;\n+      Y = Z - One;\n+    }\n+  while (MinusOne + FABS (Y) < Zero);\n+  /*.. now W is just big enough that |((W+1)-W)-1| >= 1 ... */\n+  Precision = Zero;\n+  Y = One;\n+  do\n+    {\n+      Radix = W + Y;\n+      Y = Y + Y;\n+      Radix = Radix - W;\n+    }\n+  while (Radix == Zero);\n+  if (Radix < Two)\n+    Radix = One;\n+  printf (\"Radix = %s .\\n\", Radix.str());\n+  if (Radix != One)\n+    {\n+      W = One;\n+      do\n+\t{\n+\t  Precision = Precision + One;\n+\t  W = W * Radix;\n+\t  Y = W + One;\n+\t}\n+      while ((Y - W) == One);\n+    }\n+  /*... now W == Radix^Precision is barely too big to satisfy (W+1)-W == 1\n+     ... */\n+  U1 = One / W;\n+  U2 = Radix * U1;\n+  printf (\"Closest relative separation found is U1 = %s .\\n\\n\", U1.str());\n+  printf (\"Recalculating radix and precision\\n \");\n+\n+  /*save old values */\n+  E0 = Radix;\n+  E1 = U1;\n+  E9 = U2;\n+  E3 = Precision;\n+\n+  X = Four / Three;\n+  Third = X - One;\n+  F6 = Half - Third;\n+  X = F6 + F6;\n+  X = FABS (X - Third);\n+  if (X < U2)\n+    X = U2;\n+\n+  /*... now X = (unknown no.) ulps of 1+... */\n+  do\n+    {\n+      U2 = X;\n+      Y = Half * U2 + ThirtyTwo * U2 * U2;\n+      Y = One + Y;\n+      X = Y - One;\n+    }\n+  while (!((U2 <= X) || (X <= Zero)));\n+\n+  /*... now U2 == 1 ulp of 1 + ... */\n+  X = Two / Three;\n+  F6 = X - Half;\n+  Third = F6 + F6;\n+  X = Third - Half;\n+  X = FABS (X + F6);\n+  if (X < U1)\n+    X = U1;\n+\n+  /*... now  X == (unknown no.) ulps of 1 -... */\n+  do\n+    {\n+      U1 = X;\n+      Y = Half * U1 + ThirtyTwo * U1 * U1;\n+      Y = Half - Y;\n+      X = Half + Y;\n+      Y = Half - X;\n+      X = Half + Y;\n+    }\n+  while (!((U1 <= X) || (X <= Zero)));\n+  /*... now U1 == 1 ulp of 1 - ... */\n+  if (U1 == E1)\n+    printf (\"confirms closest relative separation U1 .\\n\");\n+  else\n+    printf (\"gets better closest relative separation U1 = %s .\\n\", U1.str());\n+  W = One / U1;\n+  F9 = (Half - U1) + Half;\n+\n+  Radix = FLOOR (FLOAT (\"0.01\") + U2 / U1);\n+  if (Radix == E0)\n+    printf (\"Radix confirmed.\\n\");\n+  else\n+    printf (\"MYSTERY: recalculated Radix = %s .\\n\", Radix.str());\n+  TstCond (Defect, Radix <= Eight + Eight,\n+\t   \"Radix is too big: roundoff problems\");\n+  TstCond (Flaw, (Radix == Two) || (Radix == 10)\n+\t   || (Radix == One), \"Radix is not as good as 2 or 10\");\n+\t/*=============================================*/\n+  Milestone = 20;\n+\t/*=============================================*/\n+  TstCond (Failure, F9 - Half < Half,\n+\t   \"(1-U1)-1/2 < 1/2 is FALSE, prog. fails?\");\n+  X = F9;\n+  I = 1;\n+  Y = X - Half;\n+  Z = Y - Half;\n+  TstCond (Failure, (X != One)\n+\t   || (Z == Zero), \"Comparison is fuzzy,X=1 but X-1/2-1/2 != 0\");\n+  X = One + U2;\n+  I = 0;\n+\t/*=============================================*/\n+  Milestone = 25;\n+\t/*=============================================*/\n+  /*... BMinusU2 = nextafter(Radix, 0) */\n+  BMinusU2 = Radix - One;\n+  BMinusU2 = (BMinusU2 - U2) + One;\n+  /* Purify Integers */\n+  if (Radix != One)\n+    {\n+      X = -TwoForty * LOG (U1) / LOG (Radix);\n+      Y = FLOOR (Half + X);\n+      if (FABS (X - Y) * Four < One)\n+\tX = Y;\n+      Precision = X / TwoForty;\n+      Y = FLOOR (Half + Precision);\n+      if (FABS (Precision - Y) * TwoForty < Half)\n+\tPrecision = Y;\n+    }\n+  if ((Precision != FLOOR (Precision)) || (Radix == One))\n+    {\n+      printf (\"Precision cannot be characterized by an Integer number\\n\");\n+      printf\n+\t(\"of significant digits but, by itself, this is a minor flaw.\\n\");\n+    }\n+  if (Radix == One)\n+    printf\n+      (\"logarithmic encoding has precision characterized solely by U1.\\n\");\n+  else\n+    printf (\"The number of significant digits of the Radix is %s .\\n\",\n+\t    Precision.str());\n+  TstCond (Serious, U2 * Nine * Nine * TwoForty < One,\n+\t   \"Precision worse than 5 decimal figures  \");\n+\t/*=============================================*/\n+  Milestone = 30;\n+\t/*=============================================*/\n+  /* Test for extra-precise subexpressions */\n+  X = FABS (((Four / Three - One) - One / Four) * Three - One / Four);\n+  do\n+    {\n+      Z2 = X;\n+      X = (One + (Half * Z2 + ThirtyTwo * Z2 * Z2)) - One;\n+    }\n+  while (!((Z2 <= X) || (X <= Zero)));\n+  X = Y = Z = FABS ((Three / Four - Two / Three) * Three - One / Four);\n+  do\n+    {\n+      Z1 = Z;\n+      Z = (One / Two - ((One / Two - (Half * Z1 + ThirtyTwo * Z1 * Z1))\n+\t\t\t+ One / Two)) + One / Two;\n+    }\n+  while (!((Z1 <= Z) || (Z <= Zero)));\n+  do\n+    {\n+      do\n+\t{\n+\t  Y1 = Y;\n+\t  Y =\n+\t    (Half - ((Half - (Half * Y1 + ThirtyTwo * Y1 * Y1)) + Half)) +\n+\t    Half;\n+\t}\n+      while (!((Y1 <= Y) || (Y <= Zero)));\n+      X1 = X;\n+      X = ((Half * X1 + ThirtyTwo * X1 * X1) - F9) + F9;\n+    }\n+  while (!((X1 <= X) || (X <= Zero)));\n+  if ((X1 != Y1) || (X1 != Z1))\n+    {\n+      BadCond (Serious, \"Disagreements among the values X1, Y1, Z1,\\n\");\n+      printf (\"respectively  %s,  %s,  %s,\\n\", X1.str(), Y1.str(), Z1.str());\n+      printf (\"are symptoms of inconsistencies introduced\\n\");\n+      printf (\"by extra-precise evaluation of arithmetic subexpressions.\\n\");\n+      notify (\"Possibly some part of this\");\n+      if ((X1 == U1) || (Y1 == U1) || (Z1 == U1))\n+\tprintf (\"That feature is not tested further by this program.\\n\");\n+    }\n+  else\n+    {\n+      if ((Z1 != U1) || (Z2 != U2))\n+\t{\n+\t  if ((Z1 >= U1) || (Z2 >= U2))\n+\t    {\n+\t      BadCond (Failure, \"\");\n+\t      notify (\"Precision\");\n+\t      printf (\"\\tU1 = %s, Z1 - U1 = %s\\n\", U1.str(), (Z1 - U1).str());\n+\t      printf (\"\\tU2 = %s, Z2 - U2 = %s\\n\", U2.str(), (Z2 - U2).str());\n+\t    }\n+\t  else\n+\t    {\n+\t      if ((Z1 <= Zero) || (Z2 <= Zero))\n+\t\t{\n+\t\t  printf (\"Because of unusual Radix = %s\", Radix.str());\n+\t\t  printf (\", or exact rational arithmetic a result\\n\");\n+\t\t  printf (\"Z1 = %s, or Z2 = %s \", Z1.str(), Z2.str());\n+\t\t  notify (\"of an\\nextra-precision\");\n+\t\t}\n+\t      if (Z1 != Z2 || Z1 > Zero)\n+\t\t{\n+\t\t  X = Z1 / U1;\n+\t\t  Y = Z2 / U2;\n+\t\t  if (Y > X)\n+\t\t    X = Y;\n+\t\t  Q = -LOG (X);\n+\t\t  printf (\"Some subexpressions appear to be calculated \"\n+\t\t\t  \"extra precisely\\n\");\n+\t\t  printf (\"with about %s extra B-digits, i.e.\\n\",\n+\t\t\t  (Q / LOG (Radix)).str());\n+\t\t  printf (\"roughly %s extra significant decimals.\\n\",\n+\t\t\t  (Q / LOG (FLOAT (10))).str());\n+\t\t}\n+\t      printf\n+\t\t(\"That feature is not tested further by this program.\\n\");\n+\t    }\n+\t}\n+    }\n+  Pause ();\n+\t/*=============================================*/\n+  Milestone = 35;\n+\t/*=============================================*/\n+  if (Radix >= Two)\n+    {\n+      X = W / (Radix * Radix);\n+      Y = X + One;\n+      Z = Y - X;\n+      T = Z + U2;\n+      X = T - Z;\n+      TstCond (Failure, X == U2,\n+\t       \"Subtraction is not normalized X=Y,X+Z != Y+Z!\");\n+      if (X == U2)\n+\tprintf (\"Subtraction appears to be normalized, as it should be.\");\n+    }\n+  printf (\"\\nChecking for guard digit in *, /, and -.\\n\");\n+  Y = F9 * One;\n+  Z = One * F9;\n+  X = F9 - Half;\n+  Y = (Y - Half) - X;\n+  Z = (Z - Half) - X;\n+  X = One + U2;\n+  T = X * Radix;\n+  R = Radix * X;\n+  X = T - Radix;\n+  X = X - Radix * U2;\n+  T = R - Radix;\n+  T = T - Radix * U2;\n+  X = X * (Radix - One);\n+  T = T * (Radix - One);\n+  if ((X == Zero) && (Y == Zero) && (Z == Zero) && (T == Zero))\n+    GMult = Yes;\n+  else\n+    {\n+      GMult = No;\n+      TstCond (Serious, false, \"* lacks a Guard Digit, so 1*X != X\");\n+    }\n+  Z = Radix * U2;\n+  X = One + Z;\n+  Y = FABS ((X + Z) - X * X) - U2;\n+  X = One - U2;\n+  Z = FABS ((X - U2) - X * X) - U1;\n+  TstCond (Failure, (Y <= Zero)\n+\t   && (Z <= Zero), \"* gets too many final digits wrong.\\n\");\n+  Y = One - U2;\n+  X = One + U2;\n+  Z = One / Y;\n+  Y = Z - X;\n+  X = One / Three;\n+  Z = Three / Nine;\n+  X = X - Z;\n+  T = Nine / TwentySeven;\n+  Z = Z - T;\n+  TstCond (Defect, X == Zero && Y == Zero && Z == Zero,\n+\t   \"Division lacks a Guard Digit, so error can exceed 1 ulp\\n\"\n+\t   \"or  1/3  and  3/9  and  9/27 may disagree\");\n+  Y = F9 / One;\n+  X = F9 - Half;\n+  Y = (Y - Half) - X;\n+  X = One + U2;\n+  T = X / One;\n+  X = T - X;\n+  if ((X == Zero) && (Y == Zero) && (Z == Zero))\n+    GDiv = Yes;\n+  else\n+    {\n+      GDiv = No;\n+      TstCond (Serious, false, \"Division lacks a Guard Digit, so X/1 != X\");\n+    }\n+  X = One / (One + U2);\n+  Y = X - Half - Half;\n+  TstCond (Serious, Y < Zero, \"Computed value of 1/1.000..1 >= 1\");\n+  X = One - U2;\n+  Y = One + Radix * U2;\n+  Z = X * Radix;\n+  T = Y * Radix;\n+  R = Z / Radix;\n+  StickyBit = T / Radix;\n+  X = R - X;\n+  Y = StickyBit - Y;\n+  TstCond (Failure, X == Zero && Y == Zero,\n+\t   \"* and/or / gets too many last digits wrong\");\n+  Y = One - U1;\n+  X = One - F9;\n+  Y = One - Y;\n+  T = Radix - U2;\n+  Z = Radix - BMinusU2;\n+  T = Radix - T;\n+  if ((X == U1) && (Y == U1) && (Z == U2) && (T == U2))\n+    GAddSub = Yes;\n+  else\n+    {\n+      GAddSub = No;\n+      TstCond (Serious, false,\n+\t       \"- lacks Guard Digit, so cancellation is obscured\");\n+    }\n+  if (F9 != One && F9 - One >= Zero)\n+    {\n+      BadCond (Serious, \"comparison alleges  (1-U1) < 1  although\\n\");\n+      printf (\"  subtraction yields  (1-U1) - 1 = 0 , thereby vitiating\\n\");\n+      printf (\"  such precautions against division by zero as\\n\");\n+      printf (\"  ...  if (X == 1.0) {.....} else {.../(X-1.0)...}\\n\");\n+    }\n+  if (GMult == Yes && GDiv == Yes && GAddSub == Yes)\n+    printf\n+      (\"     *, /, and - appear to have guard digits, as they should.\\n\");\n+\t/*=============================================*/\n+  Milestone = 40;\n+\t/*=============================================*/\n+  Pause ();\n+  printf (\"Checking rounding on multiply, divide and add/subtract.\\n\");\n+  RMult = Other;\n+  RDiv = Other;\n+  RAddSub = Other;\n+  RadixD2 = Radix / Two;\n+  A1 = Two;\n+  Done = false;\n+  do\n+    {\n+      AInvrse = Radix;\n+      do\n+\t{\n+\t  X = AInvrse;\n+\t  AInvrse = AInvrse / A1;\n+\t}\n+      while (!(FLOOR (AInvrse) != AInvrse));\n+      Done = (X == One) || (A1 > Three);\n+      if (!Done)\n+\tA1 = Nine + One;\n+    }\n+  while (!(Done));\n+  if (X == One)\n+    A1 = Radix;\n+  AInvrse = One / A1;\n+  X = A1;\n+  Y = AInvrse;\n+  Done = false;\n+  do\n+    {\n+      Z = X * Y - Half;\n+      TstCond (Failure, Z == Half, \"X * (1/X) differs from 1\");\n+      Done = X == Radix;\n+      X = Radix;\n+      Y = One / X;\n+    }\n+  while (!(Done));\n+  Y2 = One + U2;\n+  Y1 = One - U2;\n+  X = OneAndHalf - U2;\n+  Y = OneAndHalf + U2;\n+  Z = (X - U2) * Y2;\n+  T = Y * Y1;\n+  Z = Z - X;\n+  T = T - X;\n+  X = X * Y2;\n+  Y = (Y + U2) * Y1;\n+  X = X - OneAndHalf;\n+  Y = Y - OneAndHalf;\n+  if ((X == Zero) && (Y == Zero) && (Z == Zero) && (T <= Zero))\n+    {\n+      X = (OneAndHalf + U2) * Y2;\n+      Y = OneAndHalf - U2 - U2;\n+      Z = OneAndHalf + U2 + U2;\n+      T = (OneAndHalf - U2) * Y1;\n+      X = X - (Z + U2);\n+      StickyBit = Y * Y1;\n+      S = Z * Y2;\n+      T = T - Y;\n+      Y = (U2 - Y) + StickyBit;\n+      Z = S - (Z + U2 + U2);\n+      StickyBit = (Y2 + U2) * Y1;\n+      Y1 = Y2 * Y1;\n+      StickyBit = StickyBit - Y2;\n+      Y1 = Y1 - Half;\n+      if ((X == Zero) && (Y == Zero) && (Z == Zero) && (T == Zero)\n+\t  && (StickyBit == Zero) && (Y1 == Half))\n+\t{\n+\t  RMult = Rounded;\n+\t  printf (\"Multiplication appears to round correctly.\\n\");\n+\t}\n+      else if ((X + U2 == Zero) && (Y < Zero) && (Z + U2 == Zero)\n+\t       && (T < Zero) && (StickyBit + U2 == Zero) && (Y1 < Half))\n+\t{\n+\t  RMult = Chopped;\n+\t  printf (\"Multiplication appears to chop.\\n\");\n+\t}\n+      else\n+\tprintf (\"* is neither chopped nor correctly rounded.\\n\");\n+      if ((RMult == Rounded) && (GMult == No))\n+\tnotify (\"Multiplication\");\n+    }\n+  else\n+    printf (\"* is neither chopped nor correctly rounded.\\n\");\n+\t/*=============================================*/\n+  Milestone = 45;\n+\t/*=============================================*/\n+  Y2 = One + U2;\n+  Y1 = One - U2;\n+  Z = OneAndHalf + U2 + U2;\n+  X = Z / Y2;\n+  T = OneAndHalf - U2 - U2;\n+  Y = (T - U2) / Y1;\n+  Z = (Z + U2) / Y2;\n+  X = X - OneAndHalf;\n+  Y = Y - T;\n+  T = T / Y1;\n+  Z = Z - (OneAndHalf + U2);\n+  T = (U2 - OneAndHalf) + T;\n+  if (!((X > Zero) || (Y > Zero) || (Z > Zero) || (T > Zero)))\n+    {\n+      X = OneAndHalf / Y2;\n+      Y = OneAndHalf - U2;\n+      Z = OneAndHalf + U2;\n+      X = X - Y;\n+      T = OneAndHalf / Y1;\n+      Y = Y / Y1;\n+      T = T - (Z + U2);\n+      Y = Y - Z;\n+      Z = Z / Y2;\n+      Y1 = (Y2 + U2) / Y2;\n+      Z = Z - OneAndHalf;\n+      Y2 = Y1 - Y2;\n+      Y1 = (F9 - U1) / F9;\n+      if ((X == Zero) && (Y == Zero) && (Z == Zero) && (T == Zero)\n+\t  && (Y2 == Zero) && (Y2 == Zero) && (Y1 - Half == F9 - Half))\n+\t{\n+\t  RDiv = Rounded;\n+\t  printf (\"Division appears to round correctly.\\n\");\n+\t  if (GDiv == No)\n+\t    notify (\"Division\");\n+\t}\n+      else if ((X < Zero) && (Y < Zero) && (Z < Zero) && (T < Zero)\n+\t       && (Y2 < Zero) && (Y1 - Half < F9 - Half))\n+\t{\n+\t  RDiv = Chopped;\n+\t  printf (\"Division appears to chop.\\n\");\n+\t}\n+    }\n+  if (RDiv == Other)\n+    printf (\"/ is neither chopped nor correctly rounded.\\n\");\n+  BInvrse = One / Radix;\n+  TstCond (Failure, (BInvrse * Radix - Half == Half),\n+\t   \"Radix * ( 1 / Radix ) differs from 1\");\n+\t/*=============================================*/\n+  Milestone = 50;\n+\t/*=============================================*/\n+  TstCond (Failure, ((F9 + U1) - Half == Half)\n+\t   && ((BMinusU2 + U2) - One == Radix - One),\n+\t   \"Incomplete carry-propagation in Addition\");\n+  X = One - U1 * U1;\n+  Y = One + U2 * (One - U2);\n+  Z = F9 - Half;\n+  X = (X - Half) - Z;\n+  Y = Y - One;\n+  if ((X == Zero) && (Y == Zero))\n+    {\n+      RAddSub = Chopped;\n+      printf (\"Add/Subtract appears to be chopped.\\n\");\n+    }\n+  if (GAddSub == Yes)\n+    {\n+      X = (Half + U2) * U2;\n+      Y = (Half - U2) * U2;\n+      X = One + X;\n+      Y = One + Y;\n+      X = (One + U2) - X;\n+      Y = One - Y;\n+      if ((X == Zero) && (Y == Zero))\n+\t{\n+\t  X = (Half + U2) * U1;\n+\t  Y = (Half - U2) * U1;\n+\t  X = One - X;\n+\t  Y = One - Y;\n+\t  X = F9 - X;\n+\t  Y = One - Y;\n+\t  if ((X == Zero) && (Y == Zero))\n+\t    {\n+\t      RAddSub = Rounded;\n+\t      printf (\"Addition/Subtraction appears to round correctly.\\n\");\n+\t      if (GAddSub == No)\n+\t\tnotify (\"Add/Subtract\");\n+\t    }\n+\t  else\n+\t    printf (\"Addition/Subtraction neither rounds nor chops.\\n\");\n+\t}\n+      else\n+\tprintf (\"Addition/Subtraction neither rounds nor chops.\\n\");\n+    }\n+  else\n+    printf (\"Addition/Subtraction neither rounds nor chops.\\n\");\n+  S = One;\n+  X = One + Half * (One + Half);\n+  Y = (One + U2) * Half;\n+  Z = X - Y;\n+  T = Y - X;\n+  StickyBit = Z + T;\n+  if (StickyBit != Zero)\n+    {\n+      S = Zero;\n+      BadCond (Flaw, \"(X - Y) + (Y - X) is non zero!\\n\");\n+    }\n+  StickyBit = Zero;\n+  if ((GMult == Yes) && (GDiv == Yes) && (GAddSub == Yes)\n+      && (RMult == Rounded) && (RDiv == Rounded)\n+      && (RAddSub == Rounded) && (FLOOR (RadixD2) == RadixD2))\n+    {\n+      printf (\"Checking for sticky bit.\\n\");\n+      X = (Half + U1) * U2;\n+      Y = Half * U2;\n+      Z = One + Y;\n+      T = One + X;\n+      if ((Z - One <= Zero) && (T - One >= U2))\n+\t{\n+\t  Z = T + Y;\n+\t  Y = Z - X;\n+\t  if ((Z - T >= U2) && (Y - T == Zero))\n+\t    {\n+\t      X = (Half + U1) * U1;\n+\t      Y = Half * U1;\n+\t      Z = One - Y;\n+\t      T = One - X;\n+\t      if ((Z - One == Zero) && (T - F9 == Zero))\n+\t\t{\n+\t\t  Z = (Half - U1) * U1;\n+\t\t  T = F9 - Z;\n+\t\t  Q = F9 - Y;\n+\t\t  if ((T - F9 == Zero) && (F9 - U1 - Q == Zero))\n+\t\t    {\n+\t\t      Z = (One + U2) * OneAndHalf;\n+\t\t      T = (OneAndHalf + U2) - Z + U2;\n+\t\t      X = One + Half / Radix;\n+\t\t      Y = One + Radix * U2;\n+\t\t      Z = X * Y;\n+\t\t      if (T == Zero && X + Radix * U2 - Z == Zero)\n+\t\t\t{\n+\t\t\t  if (Radix != Two)\n+\t\t\t    {\n+\t\t\t      X = Two + U2;\n+\t\t\t      Y = X / Two;\n+\t\t\t      if ((Y - One == Zero))\n+\t\t\t\tStickyBit = S;\n+\t\t\t    }\n+\t\t\t  else\n+\t\t\t    StickyBit = S;\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  if (StickyBit == One)\n+    printf (\"Sticky bit apparently used correctly.\\n\");\n+  else\n+    printf (\"Sticky bit used incorrectly or not at all.\\n\");\n+  TstCond (Flaw, !(GMult == No || GDiv == No || GAddSub == No ||\n+\t\t   RMult == Other || RDiv == Other || RAddSub == Other),\n+\t   \"lack(s) of guard digits or failure(s) to correctly round or chop\\n\\\n+(noted above) count as one flaw in the final tally below\");\n+\t/*=============================================*/\n+  Milestone = 60;\n+\t/*=============================================*/\n+  printf (\"\\n\");\n+  printf (\"Does Multiplication commute?  \");\n+  printf (\"Testing on %d random pairs.\\n\", NoTrials);\n+  Random9 = SQRT (FLOAT (3));\n+  Random1 = Third;\n+  I = 1;\n+  do\n+    {\n+      X = Random ();\n+      Y = Random ();\n+      Z9 = Y * X;\n+      Z = X * Y;\n+      Z9 = Z - Z9;\n+      I = I + 1;\n+    }\n+  while (!((I > NoTrials) || (Z9 != Zero)));\n+  if (I == NoTrials)\n+    {\n+      Random1 = One + Half / Three;\n+      Random2 = (U2 + U1) + One;\n+      Z = Random1 * Random2;\n+      Y = Random2 * Random1;\n+      Z9 = (One + Half / Three) * ((U2 + U1) + One) - (One + Half /\n+\t\t\t\t\t\t       Three) * ((U2 + U1) +\n+\t\t\t\t\t\t\t\t One);\n+    }\n+  if (!((I == NoTrials) || (Z9 == Zero)))\n+    BadCond (Defect, \"X * Y == Y * X trial fails.\\n\");\n+  else\n+    printf (\"     No failures found in %d integer pairs.\\n\", NoTrials);\n+\t/*=============================================*/\n+  Milestone = 70;\n+\t/*=============================================*/\n+  printf (\"\\nRunning test of square root(x).\\n\");\n+  TstCond (Failure, (Zero == SQRT (Zero))\n+\t   && (-Zero == SQRT (-Zero))\n+\t   && (One == SQRT (One)), \"Square root of 0.0, -0.0 or 1.0 wrong\");\n+  MinSqEr = Zero;\n+  MaxSqEr = Zero;\n+  J = Zero;\n+  X = Radix;\n+  OneUlp = U2;\n+  SqXMinX (Serious);\n+  X = BInvrse;\n+  OneUlp = BInvrse * U1;\n+  SqXMinX (Serious);\n+  X = U1;\n+  OneUlp = U1 * U1;\n+  SqXMinX (Serious);\n+  if (J != Zero)\n+    Pause ();\n+  printf (\"Testing if sqrt(X * X) == X for %d Integers X.\\n\", NoTrials);\n+  J = Zero;\n+  X = Two;\n+  Y = Radix;\n+  if ((Radix != One))\n+    do\n+      {\n+\tX = Y;\n+\tY = Radix * Y;\n+      }\n+    while (!((Y - X >= NoTrials)));\n+  OneUlp = X * U2;\n+  I = 1;\n+  while (I <= NoTrials)\n+    {\n+      X = X + One;\n+      SqXMinX (Defect);\n+      if (J > Zero)\n+\tbreak;\n+      I = I + 1;\n+    }\n+  printf (\"Test for sqrt monotonicity.\\n\");\n+  I = -1;\n+  X = BMinusU2;\n+  Y = Radix;\n+  Z = Radix + Radix * U2;\n+  NotMonot = false;\n+  Monot = false;\n+  while (!(NotMonot || Monot))\n+    {\n+      I = I + 1;\n+      X = SQRT (X);\n+      Q = SQRT (Y);\n+      Z = SQRT (Z);\n+      if ((X > Q) || (Q > Z))\n+\tNotMonot = true;\n+      else\n+\t{\n+\t  Q = FLOOR (Q + Half);\n+\t  if (!(I > 0 || Radix == Q * Q))\n+\t    Monot = true;\n+\t  else if (I > 0)\n+\t    {\n+\t      if (I > 1)\n+\t\tMonot = true;\n+\t      else\n+\t\t{\n+\t\t  Y = Y * BInvrse;\n+\t\t  X = Y - U1;\n+\t\t  Z = Y + U1;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      Y = Q;\n+\t      X = Y - U2;\n+\t      Z = Y + U2;\n+\t    }\n+\t}\n+    }\n+  if (Monot)\n+    printf (\"sqrt has passed a test for Monotonicity.\\n\");\n+  else\n+    {\n+      BadCond (Defect, \"\");\n+      printf (\"sqrt(X) is non-monotonic for X near %s .\\n\", Y.str());\n+    }\n+\t/*=============================================*/\n+  Milestone = 110;\n+\t/*=============================================*/\n+  printf (\"Seeking Underflow thresholds UfThold and E0.\\n\");\n+  D = U1;\n+  if (Precision != FLOOR (Precision))\n+    {\n+      D = BInvrse;\n+      X = Precision;\n+      do\n+\t{\n+\t  D = D * BInvrse;\n+\t  X = X - One;\n+\t}\n+      while (X > Zero);\n+    }\n+  Y = One;\n+  Z = D;\n+  /* ... D is power of 1/Radix < 1. */\n+  do\n+    {\n+      C = Y;\n+      Y = Z;\n+      Z = Y * Y;\n+    }\n+  while ((Y > Z) && (Z + Z > Z));\n+  Y = C;\n+  Z = Y * D;\n+  do\n+    {\n+      C = Y;\n+      Y = Z;\n+      Z = Y * D;\n+    }\n+  while ((Y > Z) && (Z + Z > Z));\n+  if (Radix < Two)\n+    HInvrse = Two;\n+  else\n+    HInvrse = Radix;\n+  H = One / HInvrse;\n+  /* ... 1/HInvrse == H == Min(1/Radix, 1/2) */\n+  CInvrse = One / C;\n+  E0 = C;\n+  Z = E0 * H;\n+  /* ...1/Radix^(BIG Integer) << 1 << CInvrse == 1/C */\n+  do\n+    {\n+      Y = E0;\n+      E0 = Z;\n+      Z = E0 * H;\n+    }\n+  while ((E0 > Z) && (Z + Z > Z));\n+  UfThold = E0;\n+  E1 = Zero;\n+  Q = Zero;\n+  E9 = U2;\n+  S = One + E9;\n+  D = C * S;\n+  if (D <= C)\n+    {\n+      E9 = Radix * U2;\n+      S = One + E9;\n+      D = C * S;\n+      if (D <= C)\n+\t{\n+\t  BadCond (Failure,\n+\t\t   \"multiplication gets too many last digits wrong.\\n\");\n+\t  Underflow = E0;\n+\t  Y1 = Zero;\n+\t  PseudoZero = Z;\n+\t  Pause ();\n+\t}\n+    }\n+  else\n+    {\n+      Underflow = D;\n+      PseudoZero = Underflow * H;\n+      UfThold = Zero;\n+      do\n+\t{\n+\t  Y1 = Underflow;\n+\t  Underflow = PseudoZero;\n+\t  if (E1 + E1 <= E1)\n+\t    {\n+\t      Y2 = Underflow * HInvrse;\n+\t      E1 = FABS (Y1 - Y2);\n+\t      Q = Y1;\n+\t      if ((UfThold == Zero) && (Y1 != Y2))\n+\t\tUfThold = Y1;\n+\t    }\n+\t  PseudoZero = PseudoZero * H;\n+\t}\n+      while ((Underflow > PseudoZero)\n+\t     && (PseudoZero + PseudoZero > PseudoZero));\n+    }\n+  /* Comment line 4530 .. 4560 */\n+  if (PseudoZero != Zero)\n+    {\n+      printf (\"\\n\");\n+      Z = PseudoZero;\n+      /* ... Test PseudoZero for \"phoney- zero\" violates */\n+      /* ... PseudoZero < Underflow or PseudoZero < PseudoZero + PseudoZero\n+         ... */\n+      if (PseudoZero <= Zero)\n+\t{\n+\t  BadCond (Failure, \"Positive expressions can underflow to an\\n\");\n+\t  printf (\"allegedly negative value\\n\");\n+\t  printf (\"PseudoZero that prints out as: %s .\\n\", PseudoZero.str());\n+\t  X = -PseudoZero;\n+\t  if (X <= Zero)\n+\t    {\n+\t      printf (\"But -PseudoZero, which should be\\n\");\n+\t      printf (\"positive, isn't; it prints out as  %s .\\n\", X.str());\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  BadCond (Flaw, \"Underflow can stick at an allegedly positive\\n\");\n+\t  printf (\"value PseudoZero that prints out as %s .\\n\",\n+\t\t  PseudoZero.str());\n+\t}\n+      TstPtUf ();\n+    }\n+\t/*=============================================*/\n+  Milestone = 120;\n+\t/*=============================================*/\n+  if (CInvrse * Y > CInvrse * Y1)\n+    {\n+      S = H * S;\n+      E0 = Underflow;\n+    }\n+  if (!((E1 == Zero) || (E1 == E0)))\n+    {\n+      BadCond (Defect, \"\");\n+      if (E1 < E0)\n+\t{\n+\t  printf (\"Products underflow at a higher\");\n+\t  printf (\" threshold than differences.\\n\");\n+\t  if (PseudoZero == Zero)\n+\t    E0 = E1;\n+\t}\n+      else\n+\t{\n+\t  printf (\"Difference underflows at a higher\");\n+\t  printf (\" threshold than products.\\n\");\n+\t}\n+    }\n+  printf (\"Smallest strictly positive number found is E0 = %s .\\n\", E0.str());\n+  Z = E0;\n+  TstPtUf ();\n+  Underflow = E0;\n+  if (N == 1)\n+    Underflow = Y;\n+  I = 4;\n+  if (E1 == Zero)\n+    I = 3;\n+  if (UfThold == Zero)\n+    I = I - 2;\n+  UfNGrad = true;\n+  switch (I)\n+    {\n+    case 1:\n+      UfThold = Underflow;\n+      if ((CInvrse * Q) != ((CInvrse * Y) * S))\n+\t{\n+\t  UfThold = Y;\n+\t  BadCond (Failure, \"Either accuracy deteriorates as numbers\\n\");\n+\t  printf (\"approach a threshold = %s\\n\", UfThold.str());\n+\t  printf (\" coming down from %s\\n\", C.str());\n+\t  printf\n+\t    (\" or else multiplication gets too many last digits wrong.\\n\");\n+\t}\n+      Pause ();\n+      break;\n+\n+    case 2:\n+      BadCond (Failure,\n+\t       \"Underflow confuses Comparison, which alleges that\\n\");\n+      printf (\"Q == Y while denying that |Q - Y| == 0; these values\\n\");\n+      printf (\"print out as Q = %s, Y = %s .\\n\", Q.str(), Y2.str());\n+      printf (\"|Q - Y| = %s .\\n\", FABS (Q - Y2).str());\n+      UfThold = Q;\n+      break;\n+\n+    case 3:\n+      X = X;\n+      break;\n+\n+    case 4:\n+      if ((Q == UfThold) && (E1 == E0) && (FABS (UfThold - E1 / E9) <= E1))\n+\t{\n+\t  UfNGrad = false;\n+\t  printf (\"Underflow is gradual; it incurs Absolute Error =\\n\");\n+\t  printf (\"(roundoff in UfThold) < E0.\\n\");\n+\t  Y = E0 * CInvrse;\n+\t  Y = Y * (OneAndHalf + U2);\n+\t  X = CInvrse * (One + U2);\n+\t  Y = Y / X;\n+\t  IEEE = (Y == E0);\n+\t}\n+    }\n+  if (UfNGrad)\n+    {\n+      printf (\"\\n\");\n+      if (setjmp (ovfl_buf))\n+\t{\n+\t  printf (\"Underflow / UfThold failed!\\n\");\n+\t  R = H + H;\n+\t}\n+      else\n+\tR = SQRT (Underflow / UfThold);\n+      if (R <= H)\n+\t{\n+\t  Z = R * UfThold;\n+\t  X = Z * (One + R * H * (One + H));\n+\t}\n+      else\n+\t{\n+\t  Z = UfThold;\n+\t  X = Z * (One + H * H * (One + H));\n+\t}\n+      if (!((X == Z) || (X - Z != Zero)))\n+\t{\n+\t  BadCond (Flaw, \"\");\n+\t  printf (\"X = %s\\n\\tis not equal to Z = %s .\\n\", X.str(), Z.str());\n+\t  Z9 = X - Z;\n+\t  printf (\"yet X - Z yields %s .\\n\", Z9.str());\n+\t  printf (\"    Should this NOT signal Underflow, \");\n+\t  printf (\"this is a SERIOUS DEFECT\\nthat causes \");\n+\t  printf (\"confusion when innocent statements like\\n\");;\n+\t  printf (\"    if (X == Z)  ...  else\");\n+\t  printf (\"  ... (f(X) - f(Z)) / (X - Z) ...\\n\");\n+\t  printf (\"encounter Division by Zero although actually\\n\");\n+\t  if (setjmp (ovfl_buf))\n+\t    printf (\"X / Z fails!\\n\");\n+\t  else\n+\t    printf (\"X / Z = 1 + %s .\\n\", ((X / Z - Half) - Half).str());\n+\t}\n+    }\n+  printf (\"The Underflow threshold is %s, below which\\n\", UfThold.str());\n+  printf (\"calculation may suffer larger Relative error than \");\n+  printf (\"merely roundoff.\\n\");\n+  Y2 = U1 * U1;\n+  Y = Y2 * Y2;\n+  Y2 = Y * U1;\n+  if (Y2 <= UfThold)\n+    {\n+      if (Y > E0)\n+\t{\n+\t  BadCond (Defect, \"\");\n+\t  I = 5;\n+\t}\n+      else\n+\t{\n+\t  BadCond (Serious, \"\");\n+\t  I = 4;\n+\t}\n+      printf (\"Range is too narrow; U1^%d Underflows.\\n\", I);\n+    }\n+\t/*=============================================*/\n+  Milestone = 130;\n+\t/*=============================================*/\n+  Y = -FLOOR (Half - TwoForty * LOG (UfThold) / LOG (HInvrse)) / TwoForty;\n+  Y2 = Y + Y;\n+  printf (\"Since underflow occurs below the threshold\\n\");\n+  printf (\"UfThold = (%s) ^ (%s)\\nonly underflow \", HInvrse.str(), Y.str());\n+  printf (\"should afflict the expression\\n\\t(%s) ^ (%s);\\n\",\n+\t  HInvrse.str(), Y2.str());\n+  printf (\"actually calculating yields:\");\n+  if (setjmp (ovfl_buf))\n+    {\n+      BadCond (Serious, \"trap on underflow.\\n\");\n+    }\n+  else\n+    {\n+      V9 = POW (HInvrse, Y2);\n+      printf (\" %s .\\n\", V9.str());\n+      if (!((V9 >= Zero) && (V9 <= (Radix + Radix + E9) * UfThold)))\n+\t{\n+\t  BadCond (Serious, \"this is not between 0 and underflow\\n\");\n+\t  printf (\"   threshold = %s .\\n\", UfThold.str());\n+\t}\n+      else if (!(V9 > UfThold * (One + E9)))\n+\tprintf (\"This computed value is O.K.\\n\");\n+      else\n+\t{\n+\t  BadCond (Defect, \"this is not between 0 and underflow\\n\");\n+\t  printf (\"   threshold = %s .\\n\", UfThold.str());\n+\t}\n+    }\n+\t/*=============================================*/\n+  Milestone = 160;\n+\t/*=============================================*/\n+  Pause ();\n+  printf (\"Searching for Overflow threshold:\\n\");\n+  printf (\"This may generate an error.\\n\");\n+  Y = -CInvrse;\n+  V9 = HInvrse * Y;\n+  if (setjmp (ovfl_buf))\n+    {\n+      I = 0;\n+      V9 = Y;\n+      goto overflow;\n+    }\n+  do\n+    {\n+      V = Y;\n+      Y = V9;\n+      V9 = HInvrse * Y;\n+    }\n+  while (V9 < Y);\n+  I = 1;\n+overflow:\n+  Z = V9;\n+  printf (\"Can `Z = -Y' overflow?\\n\");\n+  printf (\"Trying it on Y = %s .\\n\", Y.str());\n+  V9 = -Y;\n+  V0 = V9;\n+  if (V - Y == V + V0)\n+    printf (\"Seems O.K.\\n\");\n+  else\n+    {\n+      printf (\"finds a \");\n+      BadCond (Flaw, \"-(-Y) differs from Y.\\n\");\n+    }\n+  if (Z != Y)\n+    {\n+      BadCond (Serious, \"\");\n+      printf (\"overflow past %s\\n\\tshrinks to %s .\\n\", Y.str(), Z.str());\n+    }\n+  if (I)\n+    {\n+      Y = V * (HInvrse * U2 - HInvrse);\n+      Z = Y + ((One - HInvrse) * U2) * V;\n+      if (Z < V0)\n+\tY = Z;\n+      if (Y < V0)\n+\tV = Y;\n+      if (V0 - V < V0)\n+\tV = V0;\n+    }\n+  else\n+    {\n+      V = Y * (HInvrse * U2 - HInvrse);\n+      V = V + ((One - HInvrse) * U2) * Y;\n+    }\n+  printf (\"Overflow threshold is V  = %s .\\n\", V.str());\n+  if (I)\n+    printf (\"Overflow saturates at V0 = %s .\\n\", V0.str());\n+  else\n+    printf (\"There is no saturation value because \"\n+\t    \"the system traps on overflow.\\n\");\n+  V9 = V * One;\n+  printf (\"No Overflow should be signaled for V * 1 = %s\\n\", V9.str());\n+  V9 = V / One;\n+  printf (\"                           nor for V / 1 = %s.\\n\", V9.str());\n+  printf (\"Any overflow signal separating this * from the one\\n\");\n+  printf (\"above is a DEFECT.\\n\");\n+\t/*=============================================*/\n+  Milestone = 170;\n+\t/*=============================================*/\n+  if (!(-V < V && -V0 < V0 && -UfThold < V && UfThold < V))\n+    {\n+      BadCond (Failure, \"Comparisons involving \");\n+      printf (\"+-%s, +-%s\\nand +-%s are confused by Overflow.\",\n+\t      V.str(), V0.str(), UfThold.str());\n+    }\n+\t/*=============================================*/\n+  Milestone = 175;\n+\t/*=============================================*/\n+  printf (\"\\n\");\n+  for (Indx = 1; Indx <= 3; ++Indx)\n+    {\n+      switch (Indx)\n+\t{\n+\tcase 1:\n+\t  Z = UfThold;\n+\t  break;\n+\tcase 2:\n+\t  Z = E0;\n+\t  break;\n+\tcase 3:\n+\t  Z = PseudoZero;\n+\t  break;\n+\t}\n+      if (Z != Zero)\n+\t{\n+\t  V9 = SQRT (Z);\n+\t  Y = V9 * V9;\n+\t  if (Y / (One - Radix * E9) < Z || Y > (One + Radix * E9) * Z)\n+\t    {\t\t\t/* dgh: + E9 --> * E9 */\n+\t      if (V9 > U1)\n+\t\tBadCond (Serious, \"\");\n+\t      else\n+\t\tBadCond (Defect, \"\");\n+\t      printf (\"Comparison alleges that what prints as Z = %s\\n\",\n+\t\t      Z.str());\n+\t      printf (\" is too far from sqrt(Z) ^ 2 = %s .\\n\", Y.str());\n+\t    }\n+\t}\n+    }\n+\t/*=============================================*/\n+  Milestone = 180;\n+\t/*=============================================*/\n+  for (Indx = 1; Indx <= 2; ++Indx)\n+    {\n+      if (Indx == 1)\n+\tZ = V;\n+      else\n+\tZ = V0;\n+      V9 = SQRT (Z);\n+      X = (One - Radix * E9) * V9;\n+      V9 = V9 * X;\n+      if (((V9 < (One - Two * Radix * E9) * Z) || (V9 > Z)))\n+\t{\n+\t  Y = V9;\n+\t  if (X < W)\n+\t    BadCond (Serious, \"\");\n+\t  else\n+\t    BadCond (Defect, \"\");\n+\t  printf (\"Comparison alleges that Z = %s\\n\", Z.str());\n+\t  printf (\" is too far from sqrt(Z) ^ 2 (%s) .\\n\", Y.str());\n+\t}\n+    }\n+\t/*=============================================*/\n+  Milestone = 190;\n+\t/*=============================================*/\n+  Pause ();\n+  X = UfThold * V;\n+  Y = Radix * Radix;\n+  if (X * Y < One || X > Y)\n+    {\n+      if (X * Y < U1 || X > Y / U1)\n+\tBadCond (Defect, \"Badly\");\n+      else\n+\tBadCond (Flaw, \"\");\n+\n+      printf (\" unbalanced range; UfThold * V = %s\\n\\t%s\\n\",\n+\t      X.str(), \"is too far from 1.\\n\");\n+    }\n+\t/*=============================================*/\n+  Milestone = 200;\n+\t/*=============================================*/\n+  for (Indx = 1; Indx <= 5; ++Indx)\n+    {\n+      X = F9;\n+      switch (Indx)\n+\t{\n+\tcase 2:\n+\t  X = One + U2;\n+\t  break;\n+\tcase 3:\n+\t  X = V;\n+\t  break;\n+\tcase 4:\n+\t  X = UfThold;\n+\t  break;\n+\tcase 5:\n+\t  X = Radix;\n+\t}\n+      Y = X;\n+      if (setjmp (ovfl_buf))\n+\tprintf (\"  X / X  traps when X = %s\\n\", X.str());\n+      else\n+\t{\n+\t  V9 = (Y / X - Half) - Half;\n+\t  if (V9 == Zero)\n+\t    continue;\n+\t  if (V9 == -U1 && Indx < 5)\n+\t    BadCond (Flaw, \"\");\n+\t  else\n+\t    BadCond (Serious, \"\");\n+\t  printf (\"  X / X differs from 1 when X = %s\\n\", X.str());\n+\t  printf (\"  instead, X / X - 1/2 - 1/2 = %s .\\n\", V9.str());\n+\t}\n+    }\n+\t/*=============================================*/\n+  Milestone = 210;\n+\t/*=============================================*/\n+  MyZero = Zero;\n+  printf (\"\\n\");\n+  printf (\"What message and/or values does Division by Zero produce?\\n\");\n+  printf (\"    Trying to compute 1 / 0 produces ...\");\n+  if (!setjmp (ovfl_buf))\n+    printf (\"  %s .\\n\", (One / MyZero).str());\n+  printf (\"\\n    Trying to compute 0 / 0 produces ...\");\n+  if (!setjmp (ovfl_buf))\n+    printf (\"  %s .\\n\", (Zero / MyZero).str());\n+\t/*=============================================*/\n+  Milestone = 220;\n+\t/*=============================================*/\n+  Pause ();\n+  printf (\"\\n\");\n+  {\n+    static const char *msg[] = {\n+      \"FAILUREs  encountered =\",\n+      \"SERIOUS DEFECTs  discovered =\",\n+      \"DEFECTs  discovered =\",\n+      \"FLAWs  discovered =\"\n+    };\n+    int i;\n+    for (i = 0; i < 4; i++)\n+      if (ErrCnt[i])\n+\tprintf (\"The number of  %-29s %d.\\n\", msg[i], ErrCnt[i]);\n+  }\n+  printf (\"\\n\");\n+  if ((ErrCnt[Failure] + ErrCnt[Serious] + ErrCnt[Defect] + ErrCnt[Flaw]) > 0)\n+    {\n+      if ((ErrCnt[Failure] + ErrCnt[Serious] + ErrCnt[Defect] == 0)\n+\t  && (ErrCnt[Flaw] > 0))\n+\t{\n+\t  printf (\"The arithmetic diagnosed seems \");\n+\t  printf (\"Satisfactory though flawed.\\n\");\n+\t}\n+      if ((ErrCnt[Failure] + ErrCnt[Serious] == 0) && (ErrCnt[Defect] > 0))\n+\t{\n+\t  printf (\"The arithmetic diagnosed may be Acceptable\\n\");\n+\t  printf (\"despite inconvenient Defects.\\n\");\n+\t}\n+      if ((ErrCnt[Failure] + ErrCnt[Serious]) > 0)\n+\t{\n+\t  printf (\"The arithmetic diagnosed has \");\n+\t  printf (\"unacceptable Serious Defects.\\n\");\n+\t}\n+      if (ErrCnt[Failure] > 0)\n+\t{\n+\t  printf (\"Potentially fatal FAILURE may have spoiled this\");\n+\t  printf (\" program's subsequent diagnoses.\\n\");\n+\t}\n+    }\n+  else\n+    {\n+      printf (\"No failures, defects nor flaws have been discovered.\\n\");\n+      if (!((RMult == Rounded) && (RDiv == Rounded)\n+\t    && (RAddSub == Rounded) && (RSqrt == Rounded)))\n+\tprintf (\"The arithmetic diagnosed seems Satisfactory.\\n\");\n+      else\n+\t{\n+\t  if (StickyBit >= One &&\n+\t      (Radix - Two) * (Radix - Nine - One) == Zero)\n+\t    {\n+\t      printf (\"Rounding appears to conform to \");\n+\t      printf (\"the proposed IEEE standard P\");\n+\t      if ((Radix == Two) &&\n+\t\t  ((Precision - Four * Three * Two) *\n+\t\t   (Precision - TwentySeven - TwentySeven + One) == Zero))\n+\t\tprintf (\"754\");\n+\t      else\n+\t\tprintf (\"854\");\n+\t      if (IEEE)\n+\t\tprintf (\".\\n\");\n+\t      else\n+\t\t{\n+\t\t  printf (\",\\nexcept for possibly Double Rounding\");\n+\t\t  printf (\" during Gradual Underflow.\\n\");\n+\t\t}\n+\t    }\n+\t  printf (\"The arithmetic diagnosed appears to be Excellent!\\n\");\n+\t}\n+    }\n+  printf (\"END OF TEST.\\n\");\n+  return 0;\n+}\n+\n+template<typename FLOAT>\n+FLOAT\n+Paranoia<FLOAT>::Sign (FLOAT X)\n+{\n+  return X >= FLOAT (long (0)) ? 1 : -1;\n+}\n+\n+template<typename FLOAT>\n+void\n+Paranoia<FLOAT>::Pause ()\n+{\n+  if (do_pause)\n+    {\n+      fputs (\"Press return...\", stdout);\n+      fflush (stdout);\n+      getchar();\n+    }\n+  printf (\"\\nDiagnosis resumes after milestone Number %d\", Milestone);\n+  printf (\"          Page: %d\\n\\n\", PageNo);\n+  ++Milestone;\n+  ++PageNo;\n+}\n+\n+template<typename FLOAT>\n+void\n+Paranoia<FLOAT>::TstCond (int K, int Valid, const char *T)\n+{\n+  if (!Valid)\n+    {\n+      BadCond (K, T);\n+      printf (\".\\n\");\n+    }\n+}\n+\n+template<typename FLOAT>\n+void\n+Paranoia<FLOAT>::BadCond (int K, const char *T)\n+{\n+  static const char *msg[] = { \"FAILURE\", \"SERIOUS DEFECT\", \"DEFECT\", \"FLAW\" };\n+\n+  ErrCnt[K] = ErrCnt[K] + 1;\n+  printf (\"%s:  %s\", msg[K], T);\n+}\n+\n+/* Random computes\n+     X = (Random1 + Random9)^5\n+     Random1 = X - FLOOR(X) + 0.000005 * X;\n+   and returns the new value of Random1.  */\n+\n+template<typename FLOAT>\n+FLOAT\n+Paranoia<FLOAT>::Random ()\n+{\n+  FLOAT X, Y;\n+\n+  X = Random1 + Random9;\n+  Y = X * X;\n+  Y = Y * Y;\n+  X = X * Y;\n+  Y = X - FLOOR (X);\n+  Random1 = Y + X * FLOAT (\"0.000005\");\n+  return (Random1);\n+}\n+\n+template<typename FLOAT>\n+void\n+Paranoia<FLOAT>::SqXMinX (int ErrKind)\n+{\n+  FLOAT XA, XB;\n+\n+  XB = X * BInvrse;\n+  XA = X - XB;\n+  SqEr = ((SQRT (X * X) - XB) - XA) / OneUlp;\n+  if (SqEr != Zero)\n+    {\n+      if (SqEr < MinSqEr)\n+\tMinSqEr = SqEr;\n+      if (SqEr > MaxSqEr)\n+\tMaxSqEr = SqEr;\n+      J = J + 1;\n+      BadCond (ErrKind, \"\\n\");\n+      printf (\"sqrt(%s) - %s  = %s\\n\", (X * X).str(), X.str(),\n+\t      (OneUlp * SqEr).str());\n+      printf (\"\\tinstead of correct value 0 .\\n\");\n+    }\n+}\n+\n+template<typename FLOAT>\n+void\n+Paranoia<FLOAT>::NewD ()\n+{\n+  X = Z1 * Q;\n+  X = FLOOR (Half - X / Radix) * Radix + X;\n+  Q = (Q - X * Z) / Radix + X * X * (D / Radix);\n+  Z = Z - Two * X * D;\n+  if (Z <= Zero)\n+    {\n+      Z = -Z;\n+      Z1 = -Z1;\n+    }\n+  D = Radix * D;\n+}\n+\n+template<typename FLOAT>\n+void\n+Paranoia<FLOAT>::SR3750 ()\n+{\n+  if (!((X - Radix < Z2 - Radix) || (X - Z2 > W - Z2)))\n+    {\n+      I = I + 1;\n+      X2 = SQRT (X * D);\n+      Y2 = (X2 - Z2) - (Y - Z2);\n+      X2 = X8 / (Y - Half);\n+      X2 = X2 - Half * X2 * X2;\n+      SqEr = (Y2 + Half) + (Half - X2);\n+      if (SqEr < MinSqEr)\n+\tMinSqEr = SqEr;\n+      SqEr = Y2 - X2;\n+      if (SqEr > MaxSqEr)\n+\tMaxSqEr = SqEr;\n+    }\n+}\n+\n+template<typename FLOAT>\n+void\n+Paranoia<FLOAT>::IsYeqX ()\n+{\n+  if (Y != X)\n+    {\n+      if (N <= 0)\n+\t{\n+\t  if (Z == Zero && Q <= Zero)\n+\t    printf (\"WARNING:  computing\\n\");\n+\t  else\n+\t    BadCond (Defect, \"computing\\n\");\n+\t  printf (\"\\t(%s) ^ (%s)\\n\", Z.str(), Q.str());\n+\t  printf (\"\\tyielded %s;\\n\", Y.str());\n+\t  printf (\"\\twhich compared unequal to correct %s ;\\n\", X.str());\n+\t  printf (\"\\t\\tthey differ by %s .\\n\", (Y - X).str());\n+\t}\n+      N = N + 1;\t\t/* ... count discrepancies. */\n+    }\n+}\n+\n+template<typename FLOAT>\n+void\n+Paranoia<FLOAT>::PrintIfNPositive ()\n+{\n+  if (N > 0)\n+    printf (\"Similar discrepancies have occurred %d times.\\n\", N);\n+}\n+\n+template<typename FLOAT>\n+void\n+Paranoia<FLOAT>::TstPtUf ()\n+{\n+  N = 0;\n+  if (Z != Zero)\n+    {\n+      printf (\"Since comparison denies Z = 0, evaluating \");\n+      printf (\"(Z + Z) / Z should be safe.\\n\");\n+      if (setjmp (ovfl_buf))\n+\tgoto very_serious;\n+      Q9 = (Z + Z) / Z;\n+      printf (\"What the machine gets for (Z + Z) / Z is %s .\\n\", Q9.str());\n+      if (FABS (Q9 - Two) < Radix * U2)\n+\t{\n+\t  printf (\"This is O.K., provided Over/Underflow\");\n+\t  printf (\" has NOT just been signaled.\\n\");\n+\t}\n+      else\n+\t{\n+\t  if ((Q9 < One) || (Q9 > Two))\n+\t    {\n+\t    very_serious:\n+\t      N = 1;\n+\t      ErrCnt[Serious] = ErrCnt[Serious] + 1;\n+\t      printf (\"This is a VERY SERIOUS DEFECT!\\n\");\n+\t    }\n+\t  else\n+\t    {\n+\t      N = 1;\n+\t      ErrCnt[Defect] = ErrCnt[Defect] + 1;\n+\t      printf (\"This is a DEFECT!\\n\");\n+\t    }\n+\t}\n+      V9 = Z * One;\n+      Random1 = V9;\n+      V9 = One * Z;\n+      Random2 = V9;\n+      V9 = Z / One;\n+      if ((Z == Random1) && (Z == Random2) && (Z == V9))\n+\t{\n+\t  if (N > 0)\n+\t    Pause ();\n+\t}\n+      else\n+\t{\n+\t  N = 1;\n+\t  BadCond (Defect, \"What prints as Z = \");\n+\t  printf (\"%s\\n\\tcompares different from  \", Z.str());\n+\t  if (Z != Random1)\n+\t    printf (\"Z * 1 = %s \", Random1.str());\n+\t  if (!((Z == Random2) || (Random2 == Random1)))\n+\t    printf (\"1 * Z == %s\\n\", Random2.str());\n+\t  if (!(Z == V9))\n+\t    printf (\"Z / 1 = %s\\n\", V9.str());\n+\t  if (Random2 != Random1)\n+\t    {\n+\t      ErrCnt[Defect] = ErrCnt[Defect] + 1;\n+\t      BadCond (Defect, \"Multiplication does not commute!\\n\");\n+\t      printf (\"\\tComparison alleges that 1 * Z = %s\\n\", Random2.str());\n+\t      printf (\"\\tdiffers from Z * 1 = %s\\n\", Random1.str());\n+\t    }\n+\t  Pause ();\n+\t}\n+    }\n+}\n+\n+template<typename FLOAT>\n+void\n+Paranoia<FLOAT>::notify (const char *s)\n+{\n+  printf (\"%s test appears to be inconsistent...\\n\", s);\n+  printf (\"   PLEASE NOTIFY KARPINKSI!\\n\");\n+}\n+\n+/* ====================================================================== */\n+\n+int main(int ac, char **av)\n+{\n+  init_real_once ();\n+\n+  while (1)\n+    switch (getopt (ac, av, \"pvg:fdl\"))\n+      {\n+      case -1:\n+\treturn 0;\n+      case 'p':\n+\tdo_pause = true;\n+\tbreak;\n+      case 'v':\n+\tverbose = true;\n+\tbreak;\n+      case 'g':\n+\t{\n+\t  int size = strtol (optarg, 0, 0);\n+\n+\t  switch (size)\n+\t    {\n+\t    case 32:\n+\t      Paranoia< real_c_float<32, SFmode> >().main();\n+\t      break;\n+\n+\t    case 64:\n+\t      Paranoia< real_c_float<64, DFmode> >().main();\n+\t      break;\n+\n+\t    case 96:\n+\t      Paranoia< real_c_float<96, XFmode> >().main();\n+\t      break;\n+\n+\t    case 128:\n+\t      Paranoia< real_c_float<128, TFmode> >().main();\n+\t      break;\n+\n+\t    default:\n+\t      puts (\"Invalid gcc implementation size.\");\n+\t      return 1;\n+\t    }\n+\t  break;\n+\t}\n+\n+      case 'f':\n+\tParanoia < native_float<float> >().main();\n+\tbreak;\n+      case 'd':\n+\tParanoia < native_float<double> >().main();\n+\tbreak;\n+      case 'l':\n+#ifndef NO_LONG_DOUBLE\n+\tParanoia < native_float<long double> >().main();\n+#endif\n+\tbreak;\n+\n+      case '?':\n+\tputs (\"-p\\tpause between pages\");\n+\tputs (\"-g<N>\\treal.c implementation size N\");\n+\tputs (\"-f\\tnative float\");\n+\tputs (\"-d\\tnative double\");\n+\tputs (\"-l\\tnative long double\");\n+\treturn 0;\n+      }\n+}\n+\n+/* GCC stuff referenced by real.o.  */\n+\n+extern \"C\" void\n+fancy_abort ()\n+{\n+  abort ();\n+}\n+\n+int target_flags = 0;\n+\n+extern \"C\"\n+enum machine_mode\n+mode_for_size (unsigned int size, enum mode_class, int)\n+{\n+  switch (size)\n+    {\n+    case 32:\n+      return SFmode;\n+    case 64:\n+      return DFmode;\n+    case 96:\n+      return XFmode;\n+    case 128:\n+      return TFmode;\n+    }\n+  abort ();\n+}"}, {"sha": "a54214ca7ae1d5bf223e24cb7bdbb3a49a551cb5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efdc7e19ca67331ae7f0061c76964299db27242d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efdc7e19ca67331ae7f0061c76964299db27242d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=efdc7e19ca67331ae7f0061c76964299db27242d", "patch": "@@ -1,3 +1,34 @@\n+2002-09-16  Richard Henderson  <rth@redhat.com>\n+\n+\t* real.c, real.h: Rewrite from scratch.\n+\n+\t* Makefile.in (simplify-rtx.o): Depend on TREE_H.\n+\t(paranoia): New target.\n+\t* builtins.c (fold_builtin_inf): Use new real.h interface.\n+\t* c-common.c (builtin_define_with_hex_fp_value): Likewise.\n+\t* c-lex.c (interpret_float): Likewise.\n+\t* emit-rtl.c (gen_lowpart_common): Likewise.\n+\t* optabs.c (expand_float): Use real_2expN.\n+\t* config/ia64/ia64.md (divsi3, udivsi3): Likewise.\n+\t* defaults.h (INTEL_EXTENDED_IEEE_FORMAT): New.\n+\t(FLOAT_WORDS_BIG_ENDIAN): New.\n+\t* cse.c (find_comparison_args): Don't pass FLOAT_STORE_FLAG_VALUE\n+\tdirectly to REAL_VALUE_NEGATIVE.\n+\t* loop.c (canonicalize_condition): Likewise.\n+\t* simplify-rtx.c: Include tree.h.\n+\t(simplify_unary_operation): Don't handle FIX and UNSIGNED_FIX\n+\twith floating-point result modes.\n+\t* toplev.c (backend_init): Call init_real_once.\n+\n+\t* fold-const.c (force_fit_type): Don't call CHECK_FLOAT_VALUE.\n+\t* tree.c (build_real): Likewise.\n+\t* config/alpha/alpha.c, config/vax/vax.c (float_strings,\n+\tfloat_values, inited_float_values, check_float_value): Remove.\n+\t* config/alpha/alpha.h, config/m68hc11/m68hc11.h,\n+\tconfig/m88k/m88k.h, config/vax/vax.h (CHECK_FLOAT_VALUE): Remove.\n+\t* doc/tm.texi (CHECK_FLOAT_VALUE): Remove.\n+\t(VAX_HALFWORD_ORDER): Remove.\n+\n 2002-09-16  Ulrich Weigand  <uweigand@de.ibm.com>\n \n \t* config/s390/s390.c: (legitimize_la_operand): Remove, replace by ..."}, {"sha": "df9ba312cc3653bbb3af1efa39731636d12922b7", "filename": "gcc/Makefile.in", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efdc7e19ca67331ae7f0061c76964299db27242d/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efdc7e19ca67331ae7f0061c76964299db27242d/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=efdc7e19ca67331ae7f0061c76964299db27242d", "patch": "@@ -1473,7 +1473,7 @@ jump.o : jump.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) flags.h hard-reg-set.h $(REGS_H\n \n simplify-rtx.o : simplify-rtx.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(REGS_H) \\\n    hard-reg-set.h flags.h real.h insn-config.h $(RECOG_H) $(EXPR_H) toplev.h \\\n-   output.h function.h $(GGC_H) $(OBSTACK_H) $(TM_P_H)\n+   output.h function.h $(GGC_H) $(OBSTACK_H) $(TM_P_H) $(TREE_H)\n cselib.o : cselib.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(REGS_H) \\\n    hard-reg-set.h flags.h real.h insn-config.h $(RECOG_H) $(EXPR_H) toplev.h \\\n    output.h function.h cselib.h $(GGC_H) $(TM_P_H) gt-cselib.h\n@@ -3260,6 +3260,15 @@ ${QMTEST_DIR}/gpp-expected.qmr: ${QMTEST_DIR}/context\n \n .PHONY: qmtest-g++\n \n+# Run Paranoia on real.c.\n+\n+paranoia.o: $(srcdir)/../contrib/paranoia.cc $(CONFIG_H) $(SYSTEM_H) \\\n+  real.h $(TREE_H)\n+\tg++ -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $< $(OUTPUT_OPTION)\n+\n+paranoia: paranoia.o real.o $(LIBIBERTY)\n+\tg++ -o $@ paranoia.o real.o $(LIBIBERTY)\n+\n # These exist for maintenance purposes.\n \n # Update the tags table."}, {"sha": "2e7cd53323bc322f6b30e0e7c14b4c5601673a36", "filename": "gcc/builtins.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efdc7e19ca67331ae7f0061c76964299db27242d/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efdc7e19ca67331ae7f0061c76964299db27242d/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=efdc7e19ca67331ae7f0061c76964299db27242d", "patch": "@@ -4140,10 +4140,13 @@ fold_builtin_inf (type, warn)\n      tree type;\n      int warn;\n {\n+  REAL_VALUE_TYPE real;\n+\n   if (!MODE_HAS_INFINITIES (TYPE_MODE (type)) && warn)\n     warning (\"target format does not support infinity\");\n \n-  return build_real (type, ereal_inf (TYPE_MODE (type)));\n+  real_inf (&real);\n+  return build_real (type, real);\n }\n \n /* Used by constant folding to eliminate some builtin calls early.  EXP is"}, {"sha": "34941e008aeea81c6a5cc8cb0197df3b9e96991b", "filename": "gcc/c-common.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efdc7e19ca67331ae7f0061c76964299db27242d/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efdc7e19ca67331ae7f0061c76964299db27242d/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=efdc7e19ca67331ae7f0061c76964299db27242d", "patch": "@@ -5266,7 +5266,7 @@ builtin_define_with_int_value (macro, value)\n static void\n builtin_define_with_hex_fp_value (macro, type, digits, hex_str, fp_suffix)\n      const char *macro;\n-     tree type;\n+     tree type ATTRIBUTE_UNUSED;\n      int digits;\n      const char *hex_str;\n      const char *fp_suffix;\n@@ -5284,8 +5284,8 @@ builtin_define_with_hex_fp_value (macro, type, digits, hex_str, fp_suffix)\n      it's easy to get the exact correct value), parse it as a real,\n      then print it back out as decimal.  */\n \n-  real = REAL_VALUE_HTOF (hex_str, TYPE_MODE (type));\n-  REAL_VALUE_TO_DECIMAL (real, dec_str, digits);\n+  real_from_string (&real, hex_str);\n+  real_to_decimal (dec_str, &real, digits);\n \n   sprintf (buf, \"%s=%s%s\", macro, dec_str, fp_suffix);\n   cpp_define (parse_in, buf);"}, {"sha": "f2e9d5d1629e47a13fae53a2ed57159686e2b2e7", "filename": "gcc/c-lex.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efdc7e19ca67331ae7f0061c76964299db27242d/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efdc7e19ca67331ae7f0061c76964299db27242d/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=efdc7e19ca67331ae7f0061c76964299db27242d", "patch": "@@ -925,13 +925,8 @@ interpret_float (token, flags)\n   memcpy (copy, token->val.str.text, copylen);\n   copy[copylen] = '\\0';\n \n-  /* The second argument, machine_mode, of REAL_VALUE_ATOF tells the\n-     desired precision of the binary result of decimal-to-binary\n-     conversion.  */\n-  if (flags & CPP_N_HEX)\n-    real = REAL_VALUE_HTOF (copy, TYPE_MODE (type));\n-  else\n-    real = REAL_VALUE_ATOF (copy, TYPE_MODE (type));\n+  real_from_string (&real, copy);\n+  real_convert (&real, TYPE_MODE (type), &real);\n \n   /* A diagnostic is required for \"soft\" overflow by some ISO C\n      testsuites.  This is not pedwarn, because some people don't want"}, {"sha": "dcd377f63e48981d5086d725a91b7f72711b9de1", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efdc7e19ca67331ae7f0061c76964299db27242d/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efdc7e19ca67331ae7f0061c76964299db27242d/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=efdc7e19ca67331ae7f0061c76964299db27242d", "patch": "@@ -8880,83 +8880,6 @@ alpha_reorg (insns)\n     }\n }\n \f\n-/* Check a floating-point value for validity for a particular machine mode.  */\n-\n-static const char * const float_strings[] =\n-{\n-  /* These are for FLOAT_VAX.  */\n-   \"1.70141173319264430e+38\", /* 2^127 (2^24 - 1) / 2^24 */\n-  \"-1.70141173319264430e+38\",\n-   \"2.93873587705571877e-39\", /* 2^-128 */\n-  \"-2.93873587705571877e-39\",\n-  /* These are for the default broken IEEE mode, which traps\n-     on infinity or denormal numbers.  */\n-   \"3.402823466385288598117e+38\", /* 2^128 (1 - 2^-24) */\n-  \"-3.402823466385288598117e+38\",\n-   \"1.1754943508222875079687e-38\", /* 2^-126 */\n-  \"-1.1754943508222875079687e-38\",\n-};\n-\n-static REAL_VALUE_TYPE float_values[8];\n-static int inited_float_values = 0;\n-\n-int\n-check_float_value (mode, d, overflow)\n-     enum machine_mode mode;\n-     REAL_VALUE_TYPE *d;\n-     int overflow ATTRIBUTE_UNUSED;\n-{\n-\n-  if (TARGET_IEEE || TARGET_IEEE_CONFORMANT || TARGET_IEEE_WITH_INEXACT)\n-    return 0;\n-\n-  if (inited_float_values == 0)\n-    {\n-      int i;\n-      for (i = 0; i < 8; i++)\n-\tfloat_values[i] = REAL_VALUE_ATOF (float_strings[i], DFmode);\n-\n-      inited_float_values = 1;\n-    }\n-\n-  if (mode == SFmode)\n-    {\n-      REAL_VALUE_TYPE r;\n-      REAL_VALUE_TYPE *fvptr;\n-\n-      if (TARGET_FLOAT_VAX)\n-\tfvptr = &float_values[0];\n-      else\n-\tfvptr = &float_values[4];\n-\n-      memcpy (&r, d, sizeof (REAL_VALUE_TYPE));\n-      if (REAL_VALUES_LESS (fvptr[0], r))\n-\t{\n-\t  memcpy (d, &fvptr[0], sizeof (REAL_VALUE_TYPE));\n-\t  return 1;\n-\t}\n-      else if (REAL_VALUES_LESS (r, fvptr[1]))\n-\t{\n-\t  memcpy (d, &fvptr[1], sizeof (REAL_VALUE_TYPE));\n-\t  return 1;\n-\t}\n-      else if (REAL_VALUES_LESS (dconst0, r)\n-\t\t&& REAL_VALUES_LESS (r, fvptr[2]))\n-\t{\n-\t  memcpy (d, &dconst0, sizeof (REAL_VALUE_TYPE));\n-\t  return 1;\n-\t}\n-      else if (REAL_VALUES_LESS (r, dconst0)\n-\t\t&& REAL_VALUES_LESS (fvptr[3], r))\n-\t{\n-\t  memcpy (d, &dconst0, sizeof (REAL_VALUE_TYPE));\n-\t  return 1;\n-\t}\n-    }\n-\n-  return 0;\n-}\n-\f\n #ifdef OBJECT_FORMAT_ELF\n \n /* Switch to the section to which we should output X.  The only thing"}, {"sha": "4d1d1f4c5c346b4e29193abb2d4fc4e51f242955", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efdc7e19ca67331ae7f0061c76964299db27242d/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efdc7e19ca67331ae7f0061c76964299db27242d/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=efdc7e19ca67331ae7f0061c76964299db27242d", "patch": "@@ -1779,11 +1779,6 @@ do {\t\t\t\t\t\t\\\n #define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)\t\\\n   sprintf ((LABEL), \"*$%s%ld\", (PREFIX), (long)(NUM))\n \n-/* Check a floating-point value for validity for a particular machine mode.  */\n-\n-#define CHECK_FLOAT_VALUE(MODE, D, OVERFLOW) \\\n-  ((OVERFLOW) = check_float_value (MODE, &D, OVERFLOW))\n-\n /* We use the default ASCII-output routine, except that we don't write more\n    than 50 characters since the assembler doesn't support very long lines.  */\n "}, {"sha": "b58965215978747c2c15e7736b99ed1236cd1e80", "filename": "gcc/config/ia64/ia64.md", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efdc7e19ca67331ae7f0061c76964299db27242d/gcc%2Fconfig%2Fia64%2Fia64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efdc7e19ca67331ae7f0061c76964299db27242d/gcc%2Fconfig%2Fia64%2Fia64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.md?ref=efdc7e19ca67331ae7f0061c76964299db27242d", "patch": "@@ -1990,6 +1990,7 @@\n   \"INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_DIV\"\n {\n   rtx op1_tf, op2_tf, op0_tf, op0_di, twon34;\n+  REAL_VALUE_TYPE twon34_r;\n \n   op0_tf = gen_reg_rtx (TFmode);\n   op0_di = gen_reg_rtx (DImode);\n@@ -2005,14 +2006,9 @@\n   expand_float (op2_tf, operands[2], 0);\n \n   /* 2^-34 */\n-#if 0\n-  twon34 = (CONST_DOUBLE_FROM_REAL_VALUE\n-\t    (REAL_VALUE_FROM_TARGET_SINGLE (0x2e800000), TFmode));\n+  real_2expN (&twon34_r, -34);\n+  twon34 = CONST_DOUBLE_FROM_REAL_VALUE (twon34_r, TFmode);\n   twon34 = force_reg (TFmode, twon34);\n-#else\n-  twon34 = gen_reg_rtx (TFmode);\n-  convert_move (twon34, force_const_mem (SFmode, CONST_DOUBLE_FROM_REAL_VALUE (REAL_VALUE_FROM_TARGET_SINGLE (0x2e800000), SFmode)), 0);\n-#endif\n \n   emit_insn (gen_divsi3_internal (op0_tf, op1_tf, op2_tf, twon34));\n \n@@ -2051,6 +2047,7 @@\n   \"INTEL_EXTENDED_IEEE_FORMAT && TARGET_INLINE_DIV\"\n {\n   rtx op1_tf, op2_tf, op0_tf, op0_di, twon34;\n+  REAL_VALUE_TYPE twon34_r;\n \n   op0_tf = gen_reg_rtx (TFmode);\n   op0_di = gen_reg_rtx (DImode);\n@@ -2066,14 +2063,9 @@\n   expand_float (op2_tf, operands[2], 1);\n \n   /* 2^-34 */\n-#if 0\n-  twon34 = (CONST_DOUBLE_FROM_REAL_VALUE\n-\t    (REAL_VALUE_FROM_TARGET_SINGLE (0x2e800000), TFmode));\n+  real_2expN (&twon34_r, -34);\n+  twon34 = CONST_DOUBLE_FROM_REAL_VALUE (twon34_r, TFmode);\n   twon34 = force_reg (TFmode, twon34);\n-#else\n-  twon34 = gen_reg_rtx (TFmode);\n-  convert_move (twon34, force_const_mem (SFmode, CONST_DOUBLE_FROM_REAL_VALUE (REAL_VALUE_FROM_TARGET_SINGLE (0x2e800000), SFmode)), 0);\n-#endif\n \n   emit_insn (gen_divsi3_internal (op0_tf, op1_tf, op2_tf, twon34));\n "}, {"sha": "bdd3fe198f90e60d9e028faa57013f4b1754e4b2", "filename": "gcc/config/m68hc11/m68hc11.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efdc7e19ca67331ae7f0061c76964299db27242d/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efdc7e19ca67331ae7f0061c76964299db27242d/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h?ref=efdc7e19ca67331ae7f0061c76964299db27242d", "patch": "@@ -303,11 +303,6 @@ extern const struct processor_costs *m68hc11_cost;\n    this size or smaller can be used for structures and unions with the\n    appropriate sizes.  */\n #define MAX_FIXED_MODE_SIZE\t64\n-\n-/* Floats are checked in a generic way.  */\n-/* #define CHECK_FLOAT_VALUE(MODE, D, OVERFLOW) */\n-\n-\n \f\n /* target machine storage layout */\n "}, {"sha": "4cd5075832c8c7376eea8421bbf2a63b9e6d7048", "filename": "gcc/config/m88k/m88k.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efdc7e19ca67331ae7f0061c76964299db27242d/gcc%2Fconfig%2Fm88k%2Fm88k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efdc7e19ca67331ae7f0061c76964299db27242d/gcc%2Fconfig%2Fm88k%2Fm88k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.h?ref=efdc7e19ca67331ae7f0061c76964299db27242d", "patch": "@@ -389,14 +389,6 @@ extern int flag_pic;\t\t\t\t/* -fpic */\n /* Maximum size (in bits) to use for the largest integral type that\n    replaces a BLKmode type. */\n /* #define MAX_FIXED_MODE_SIZE 0 */\n-\n-/* Check a `double' value for validity for a particular machine mode.\n-   This is defined to avoid crashes outputting certain constants.\n-   Since we output the number in hex, the assembler won't choke on it.  */\n-/* #define CHECK_FLOAT_VALUE(MODE,VALUE) */\n-\n-/* A code distinguishing the floating point format of the target machine.  */\n-/* #define TARGET_FLOAT_FORMAT IEEE_FLOAT_FORMAT */\n \f\n /*** Register Usage ***/\n "}, {"sha": "705818fde0f62f87e85366e2597e858a64beca4f", "filename": "gcc/config/vax/vax.c", "status": "modified", "additions": 0, "deletions": 69, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efdc7e19ca67331ae7f0061c76964299db27242d/gcc%2Fconfig%2Fvax%2Fvax.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efdc7e19ca67331ae7f0061c76964299db27242d/gcc%2Fconfig%2Fvax%2Fvax.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.c?ref=efdc7e19ca67331ae7f0061c76964299db27242d", "patch": "@@ -696,75 +696,6 @@ vax_rtx_cost (x)\n     }\n   return c;\n }\n-\n-/* Check a `double' value for validity for a particular machine mode.  */\n-\n-static const char *const float_strings[] =\n-{\n-   \"1.70141173319264430e+38\", /* 2^127 (2^24 - 1) / 2^24 */\n-  \"-1.70141173319264430e+38\",\n-   \"2.93873587705571877e-39\", /* 2^-128 */\n-  \"-2.93873587705571877e-39\"\n-};\n-\n-static REAL_VALUE_TYPE float_values[4];\n-\n-static int inited_float_values = 0;\n-\n-\n-int\n-check_float_value (mode, d, overflow)\n-     enum machine_mode mode;\n-     REAL_VALUE_TYPE *d;\n-     int overflow;\n-{\n-  if (inited_float_values == 0)\n-    {\n-      int i;\n-      for (i = 0; i < 4; i++)\n-\t{\n-\t  float_values[i] = REAL_VALUE_ATOF (float_strings[i], DFmode);\n-\t}\n-\n-      inited_float_values = 1;\n-    }\n-\n-  if (overflow)\n-    {\n-      memcpy (d, &float_values[0], sizeof (REAL_VALUE_TYPE));\n-      return 1;\n-    }\n-\n-  if ((mode) == SFmode)\n-    {\n-      REAL_VALUE_TYPE r;\n-      memcpy (&r, d, sizeof (REAL_VALUE_TYPE));\n-      if (REAL_VALUES_LESS (float_values[0], r))\n-\t{\n-\t  memcpy (d, &float_values[0], sizeof (REAL_VALUE_TYPE));\n-\t  return 1;\n-\t}\n-      else if (REAL_VALUES_LESS (r, float_values[1]))\n-\t{\n-\t  memcpy (d, &float_values[1], sizeof (REAL_VALUE_TYPE));\n-\t  return 1;\n-\t}\n-      else if (REAL_VALUES_LESS (dconst0, r)\n-\t\t&& REAL_VALUES_LESS (r, float_values[2]))\n-\t{\n-\t  memcpy (d, &dconst0, sizeof (REAL_VALUE_TYPE));\n-\t  return 1;\n-\t}\n-      else if (REAL_VALUES_LESS (r, dconst0)\n-\t\t&& REAL_VALUES_LESS (float_values[3], r))\n-\t{\n-\t  memcpy (d, &dconst0, sizeof (REAL_VALUE_TYPE));\n-\t  return 1;\n-\t}\n-    }\n-\n-  return 0;\n-}\n \f\n #if VMS_TARGET\n /* Additional support code for VMS target.  */"}, {"sha": "fed8ac4fa12969862242f190d6a2770367debd95", "filename": "gcc/config/vax/vax.h", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efdc7e19ca67331ae7f0061c76964299db27242d/gcc%2Fconfig%2Fvax%2Fvax.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efdc7e19ca67331ae7f0061c76964299db27242d/gcc%2Fconfig%2Fvax%2Fvax.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.h?ref=efdc7e19ca67331ae7f0061c76964299db27242d", "patch": "@@ -885,32 +885,6 @@ enum reg_class { NO_REGS, ALL_REGS, LIM_REG_CLASSES };\n \n #define UDIVSI3_LIBCALL \"*udiv\"\n #define UMODSI3_LIBCALL \"*urem\"\n-\n-/* Check a `double' value for validity for a particular machine mode.  */\n-\n-/* note that it is very hard to accidentally create a number that fits in a\n-   double but not in a float, since their ranges are almost the same */\n-\n-#define CHECK_FLOAT_VALUE(MODE, D, OVERFLOW) \\\n-  ((OVERFLOW) = check_float_value (MODE, &D, OVERFLOW))\n-\n-/* For future reference:\n-   D Float: 9 bit, sign magnitude, excess 128 binary exponent\n-            normalized 56 bit fraction, redundant bit not represented\n-            approximately 16 decimal digits of precision\n-\n-   The values to use if we trust decimal to binary conversions:\n-#define MAX_D_FLOAT 1.7014118346046923e+38\n-#define MIN_D_FLOAT .29387358770557188e-38\n-\n-   G float: 12 bit, sign magnitude, excess 1024 binary exponent\n-            normalized 53 bit fraction, redundant bit not represented\n-            approximately 15 decimal digits precision\n-\n-   The values to use if we trust decimal to binary conversions:\n-#define MAX_G_FLOAT .898846567431157e+308\n-#define MIN_G_FLOAT .556268464626800e-308\n-*/\n \f\n /* Tell final.c how to eliminate redundant test instructions.  */\n "}, {"sha": "adaf20d32b4f0574bae72b685881f4e741130267", "filename": "gcc/cse.c", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efdc7e19ca67331ae7f0061c76964299db27242d/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efdc7e19ca67331ae7f0061c76964299db27242d/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=efdc7e19ca67331ae7f0061c76964299db27242d", "patch": "@@ -3147,13 +3147,17 @@ find_comparison_args (code, parg1, parg2, pmode1, pmode2)\n \n       else if (GET_RTX_CLASS (GET_CODE (arg1)) == '<')\n \t{\n+#ifdef FLOAT_STORE_FLAG_VALUE\n+\t  REAL_VALUE_TYPE fsfv;\n+#endif\n+\n \t  if (code == NE\n \t      || (GET_MODE_CLASS (GET_MODE (arg1)) == MODE_INT\n \t\t  && code == LT && STORE_FLAG_VALUE == -1)\n #ifdef FLOAT_STORE_FLAG_VALUE\n \t      || (GET_MODE_CLASS (GET_MODE (arg1)) == MODE_FLOAT\n-\t\t  && (REAL_VALUE_NEGATIVE\n-\t\t      (FLOAT_STORE_FLAG_VALUE (GET_MODE (arg1)))))\n+\t\t  && (fsfv = FLOAT_STORE_FLAG_VALUE (GET_MODE (arg1)),\n+\t\t      REAL_VALUE_NEGATIVE (fsfv)))\n #endif\n \t      )\n \t    x = arg1;\n@@ -3162,8 +3166,8 @@ find_comparison_args (code, parg1, parg2, pmode1, pmode2)\n \t\t       && code == GE && STORE_FLAG_VALUE == -1)\n #ifdef FLOAT_STORE_FLAG_VALUE\n \t\t   || (GET_MODE_CLASS (GET_MODE (arg1)) == MODE_FLOAT\n-\t\t       && (REAL_VALUE_NEGATIVE\n-\t\t\t   (FLOAT_STORE_FLAG_VALUE (GET_MODE (arg1)))))\n+\t\t       && (fsfv = FLOAT_STORE_FLAG_VALUE (GET_MODE (arg1)),\n+\t\t\t   REAL_VALUE_NEGATIVE (fsfv)))\n #endif\n \t\t   )\n \t    x = arg1, reverse_code = 1;\n@@ -3199,6 +3203,9 @@ find_comparison_args (code, parg1, parg2, pmode1, pmode2)\n       for (; p; p = p->next_same_value)\n \t{\n \t  enum machine_mode inner_mode = GET_MODE (p->exp);\n+#ifdef FLOAT_STORE_FLAG_VALUE\n+\t  REAL_VALUE_TYPE fsfv;\n+#endif\n \n \t  /* If the entry isn't valid, skip it.  */\n \t  if (! exp_equiv_p (p->exp, p->exp, 1, 0))\n@@ -3223,8 +3230,8 @@ find_comparison_args (code, parg1, parg2, pmode1, pmode2)\n #ifdef FLOAT_STORE_FLAG_VALUE\n \t\t   || (code == LT\n \t\t       && GET_MODE_CLASS (inner_mode) == MODE_FLOAT\n-\t\t       && (REAL_VALUE_NEGATIVE\n-\t\t\t   (FLOAT_STORE_FLAG_VALUE (GET_MODE (arg1)))))\n+\t\t       && (fsfv = FLOAT_STORE_FLAG_VALUE (GET_MODE (arg1)),\n+\t\t\t   REAL_VALUE_NEGATIVE (fsfv)))\n #endif\n \t\t   )\n \t\t  && GET_RTX_CLASS (GET_CODE (p->exp)) == '<'))\n@@ -3243,8 +3250,8 @@ find_comparison_args (code, parg1, parg2, pmode1, pmode2)\n #ifdef FLOAT_STORE_FLAG_VALUE\n \t\t    || (code == GE\n \t\t\t&& GET_MODE_CLASS (inner_mode) == MODE_FLOAT\n-\t\t\t&& (REAL_VALUE_NEGATIVE\n-\t\t\t    (FLOAT_STORE_FLAG_VALUE (GET_MODE (arg1)))))\n+\t\t\t&& (fsfv = FLOAT_STORE_FLAG_VALUE (GET_MODE (arg1)),\n+\t\t\t    REAL_VALUE_NEGATIVE (fsfv)))\n #endif\n \t\t    )\n \t\t   && GET_RTX_CLASS (GET_CODE (p->exp)) == '<')"}, {"sha": "17b8bf9a29e89420cb793d12bc7a31c0633f5473", "filename": "gcc/defaults.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efdc7e19ca67331ae7f0061c76964299db27242d/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efdc7e19ca67331ae7f0061c76964299db27242d/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=efdc7e19ca67331ae7f0061c76964299db27242d", "patch": "@@ -564,6 +564,17 @@ You Lose!  You must define PREFERRED_DEBUGGING_TYPE!\n    && !ROUND_TOWARDS_ZERO)\n #endif\n \n+#ifndef INTEL_EXTENDED_IEEE_FORMAT\n+#define INTEL_EXTENDED_IEEE_FORMAT 0\n+#endif\n+\n+/* If FLOAT_WORDS_BIG_ENDIAN and HOST_FLOAT_WORDS_BIG_ENDIAN are not defined\n+   in the header files, then this implies the word-endianness is the same as\n+   for integers.  */\n+#ifndef FLOAT_WORDS_BIG_ENDIAN\n+#define FLOAT_WORDS_BIG_ENDIAN WORDS_BIG_ENDIAN\n+#endif\n+\n #ifndef TARGET_FLT_EVAL_METHOD\n #define TARGET_FLT_EVAL_METHOD 0\n #endif"}, {"sha": "4629a12ca3180be3275de0b53be7db71c68bda51", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efdc7e19ca67331ae7f0061c76964299db27242d/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efdc7e19ca67331ae7f0061c76964299db27242d/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=efdc7e19ca67331ae7f0061c76964299db27242d", "patch": "@@ -1291,22 +1291,6 @@ You need not define this macro if it always returns @code{word_mode}.\n You would most commonly define this macro if the @code{allocate_stack}\n pattern needs to support both a 32- and a 64-bit mode.\n \n-@findex CHECK_FLOAT_VALUE\n-@item CHECK_FLOAT_VALUE (@var{mode}, @var{value}, @var{overflow})\n-A C statement to validate the value @var{value} (of type\n-@code{double}) for mode @var{mode}.  This means that you check whether\n-@var{value} fits within the possible range of values for mode\n-@var{mode} on this target machine.  The mode @var{mode} is always\n-a mode of class @code{MODE_FLOAT}.  @var{overflow} is nonzero if\n-the value is already known to be out of range.\n-\n-If @var{value} is not valid or if @var{overflow} is nonzero, you should\n-set @var{overflow} to 1 and then assign some valid value to @var{value}.\n-Allowing an invalid value to go through the compiler can produce\n-incorrect assembler code which may even cause Unix assemblers to crash.\n-\n-This macro need not be defined if there is no work for it to do.\n-\n @findex TARGET_FLOAT_FORMAT\n @item TARGET_FLOAT_FORMAT\n A code distinguishing the floating point format of the target machine.\n@@ -1343,13 +1327,6 @@ defined for them.\n The ordering of the component words of floating point values stored in\n memory is controlled by @code{FLOAT_WORDS_BIG_ENDIAN}.\n \n-@findex VAX_HALFWORD_ORDER\n-@item VAX_HALFWORD_ORDER\n-This macro is only used if @code{TARGET_FLOAT_FORMAT} is\n-@code{VAX_FLOAT_FORMAT}.  If defaulted or defined as 1, the halfwords of\n-the generated floating point data are in the order used by the VAX.  If\n-defined as 0, they are reversed, which is used by the PDP-11 target.\n-\n @findex MODE_HAS_NANS\n @item MODE_HAS_NANS (@var{mode})\n When defined, this macro should be true if @var{mode} has a NaN"}, {"sha": "70a1228450ea5b8d1b30259a70c1c7ada36c7a5c", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efdc7e19ca67331ae7f0061c76964299db27242d/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efdc7e19ca67331ae7f0061c76964299db27242d/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=efdc7e19ca67331ae7f0061c76964299db27242d", "patch": "@@ -1042,10 +1042,9 @@ gen_lowpart_common (mode, x)\n \t   && GET_CODE (x) == CONST_INT)\n     {\n       REAL_VALUE_TYPE r;\n-      HOST_WIDE_INT i;\n+      long i = INTVAL (x);\n \n-      i = INTVAL (x);\n-      r = REAL_VALUE_FROM_TARGET_SINGLE (i);\n+      real_from_target (&r, &i, mode);\n       return CONST_DOUBLE_FROM_REAL_VALUE (r, mode);\n     }\n   else if (GET_MODE_CLASS (mode) == MODE_FLOAT\n@@ -1054,8 +1053,8 @@ gen_lowpart_common (mode, x)\n \t   && GET_MODE (x) == VOIDmode)\n     {\n       REAL_VALUE_TYPE r;\n-      HOST_WIDE_INT i[2];\n       HOST_WIDE_INT low, high;\n+      long i[2];\n \n       if (GET_CODE (x) == CONST_INT)\n \t{\n@@ -1068,18 +1067,17 @@ gen_lowpart_common (mode, x)\n \t  high = CONST_DOUBLE_HIGH (x);\n \t}\n \n-#if HOST_BITS_PER_WIDE_INT == 32\n+      if (HOST_BITS_PER_WIDE_INT > 32)\n+\thigh = low >> 31 >> 1;\n+\n       /* REAL_VALUE_TARGET_DOUBLE takes the addressing order of the\n \t target machine.  */\n       if (WORDS_BIG_ENDIAN)\n \ti[0] = high, i[1] = low;\n       else\n \ti[0] = low, i[1] = high;\n-#else\n-      i[0] = low;\n-#endif\n \n-      r = REAL_VALUE_FROM_TARGET_DOUBLE (i);\n+      real_from_target (&r, i, mode);\n       return CONST_DOUBLE_FROM_REAL_VALUE (r, mode);\n     }\n   else if ((GET_MODE_CLASS (mode) == MODE_INT"}, {"sha": "658babde4cb7df2562ed558ff5127d44a47a7965", "filename": "gcc/f/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efdc7e19ca67331ae7f0061c76964299db27242d/gcc%2Ff%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efdc7e19ca67331ae7f0061c76964299db27242d/gcc%2Ff%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2FChangeLog?ref=efdc7e19ca67331ae7f0061c76964299db27242d", "patch": "@@ -1,3 +1,11 @@\n+2002-09-16  Richard Henderson  <rth@redhat.com>\n+\n+\t* target.c (ffetarget_real1): Don't pass FFETARGET_ATOF_\n+\tdirectly to ffetarget_make_real1.\n+\t(ffetarget_real2): Similarly.\n+\t* target.h (ffetarget_cvt_r1_to_rv_, ffetarget_cvt_rv_to_r2_,\n+\tffetarget_cvt_r2_to_rv_): Use new real.h interface and simplify.\n+\n 2002-09-15  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* intdoc.texi: Regenerate."}, {"sha": "82ae955ebec94afa52547d3f68e92e9322d352d3", "filename": "gcc/f/target.c", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efdc7e19ca67331ae7f0061c76964299db27242d/gcc%2Ff%2Ftarget.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efdc7e19ca67331ae7f0061c76964299db27242d/gcc%2Ff%2Ftarget.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Ftarget.c?ref=efdc7e19ca67331ae7f0061c76964299db27242d", "patch": "@@ -2277,9 +2277,11 @@ ffetarget_real1 (ffetargetReal1 *value, ffelexToken integer,\n \n   *p = '\\0';\n \n-  ffetarget_make_real1 (value,\n-\t\t\tFFETARGET_ATOF_ (ptr,\n-\t\t\t\t\t SFmode));\n+  {\n+    REAL_VALUE_TYPE rv;\n+    rv = FFETARGET_ATOF_ (ptr, SFmode);\n+    ffetarget_make_real1 (value, rv);\n+  }\n \n   if (sz > ARRAY_SIZE (ffetarget_string_))\n     malloc_kill_ks (malloc_pool_image (), ptr, sz);\n@@ -2363,9 +2365,11 @@ ffetarget_real2 (ffetargetReal2 *value, ffelexToken integer,\n \n   *p = '\\0';\n \n-  ffetarget_make_real2 (value,\n-\t\t\tFFETARGET_ATOF_ (ptr,\n-\t\t\t\t\t DFmode));\n+  {\n+    REAL_VALUE_TYPE rv;\n+    rv = FFETARGET_ATOF_ (ptr, DFmode);\n+    ffetarget_make_real2 (value, rv);\n+  }\n \n   if (sz > ARRAY_SIZE (ffetarget_string_))\n     malloc_kill_ks (malloc_pool_image (), ptr, sz);"}, {"sha": "2716a7b559fd658dfbc9c188503b5e1ca1d8d4d7", "filename": "gcc/f/target.h", "status": "modified", "additions": 13, "deletions": 37, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efdc7e19ca67331ae7f0061c76964299db27242d/gcc%2Ff%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efdc7e19ca67331ae7f0061c76964299db27242d/gcc%2Ff%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Ftarget.h?ref=efdc7e19ca67331ae7f0061c76964299db27242d", "patch": "@@ -331,54 +331,30 @@ typedef ? ffetargetLogical8;\n ?\n #endif\n #if FFETARGET_okREAL1\n-#ifdef FFETARGET_32bit_longs\n-typedef long int ffetargetReal1;\n-#define ffetargetReal1_f \"l\"\n-#define ffetarget_cvt_r1_to_rv_ REAL_VALUE_UNTO_TARGET_SINGLE\n-#define ffetarget_cvt_rv_to_r1_ REAL_VALUE_TO_TARGET_SINGLE\n-#else\n typedef int ffetargetReal1;\n #define ffetargetReal1_f \"\"\n-#define ffetarget_cvt_r1_to_rv_(in) \\\n-  ({ REAL_VALUE_TYPE _rv; \\\n-     _rv = REAL_VALUE_UNTO_TARGET_SINGLE ((long) (in)); \\\n+#define ffetarget_cvt_r1_to_rv_(in)\t\t\t\t\t\\\n+  ({ REAL_VALUE_TYPE _rv;\t\t\t\t\t\t\\\n+     long _in = (in);\t\t\t\t\t\t\t\\\n+     real_from_target (&_rv, &_in, mode_for_size (32, MODE_FLOAT, 0));\t\\\n      _rv; })\n #define ffetarget_cvt_rv_to_r1_(in, out) \\\n   ({ long _tmp; \\\n      REAL_VALUE_TO_TARGET_SINGLE ((in), _tmp); \\\n      (out) = (ffetargetReal1) _tmp; })\n #endif\n-#endif\n #if FFETARGET_okREAL2\n-#ifdef FFETARGET_32bit_longs\n-typedef struct\n-  {\n-    long int v[2];\n-  }\n-ffetargetReal2;\n-#define ffetargetReal2_f \"l\"\n-#define ffetarget_cvt_r2_to_rv_ REAL_VALUE_UNTO_TARGET_DOUBLE\n-#define ffetarget_cvt_rv_to_r2_ REAL_VALUE_TO_TARGET_DOUBLE\n-#else\n-typedef struct\n-  {\n-    int v[2];\n-  }\n-ffetargetReal2;\n+typedef struct { int v[2]; } ffetargetReal2;\n #define ffetargetReal2_f \"\"\n-#define ffetarget_cvt_r2_to_rv_(in) \\\n-  ({ REAL_VALUE_TYPE _rv; \\\n-     long _tmp[2]; \\\n-     _tmp[0] = (in)[0]; \\\n-     _tmp[1] = (in)[1]; \\\n-     _rv = REAL_VALUE_UNTO_TARGET_DOUBLE (_tmp); \\\n+#define ffetarget_cvt_r2_to_rv_(in)\t\t\t\t\t\\\n+  ({ REAL_VALUE_TYPE _rv; long _tmp[2];\t\t\t\t\t\\\n+     _tmp[0] = (in)[0]; _tmp[1] = (in)[1];\t\t\t\t\\\n+     real_from_target (&_rv, _tmp, mode_for_size (64, MODE_FLOAT, 0));\t\\\n      _rv; })\n-#define ffetarget_cvt_rv_to_r2_(in, out) \\\n-  ({ long _tmp[2]; \\\n-     REAL_VALUE_TO_TARGET_DOUBLE ((in), _tmp); \\\n-     (out)[0] = (int) (_tmp[0]); \\\n-     (out)[1] = (int) (_tmp[1]); })\n-#endif\n+#define ffetarget_cvt_rv_to_r2_(in, out)\t\t\t\t\\\n+  ({ long _tmp[2];\t\t\t\t\t\t\t\\\n+     REAL_VALUE_TO_TARGET_DOUBLE ((in), _tmp);\t\t\t\t\\\n+     (out)[0] = (int)_tmp[0]; (out)[1] = (int)_tmp[1]; })\n #endif\n #if FFETARGET_okREAL3\n typedef long ffetargetReal3[?];"}, {"sha": "c1ea09d7a5a1b4af83208b1144e25fbece7c3e05", "filename": "gcc/fold-const.c", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efdc7e19ca67331ae7f0061c76964299db27242d/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efdc7e19ca67331ae7f0061c76964299db27242d/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=efdc7e19ca67331ae7f0061c76964299db27242d", "patch": "@@ -178,10 +178,7 @@ decode (words, low, hi)\n \n    Return 1 if a signed overflow occurs, 0 otherwise.  If OVERFLOW is\n    nonzero, a signed overflow has already occurred in calculating T, so\n-   propagate it.\n-\n-   Make the real constant T valid for its type by calling CHECK_FLOAT_VALUE,\n-   if it exists.  */\n+   propagate it.  */\n \n int\n force_fit_type (t, overflow)\n@@ -194,10 +191,8 @@ force_fit_type (t, overflow)\n \n   if (TREE_CODE (t) == REAL_CST)\n     {\n-#ifdef CHECK_FLOAT_VALUE\n-      CHECK_FLOAT_VALUE (TYPE_MODE (TREE_TYPE (t)), TREE_REAL_CST (t),\n-\t\t\t overflow);\n-#endif\n+      /* ??? Used to check for overflow here via CHECK_FLOAT_TYPE.\n+\t Consider doing it via real_convert now.  */\n       return overflow;\n     }\n "}, {"sha": "ac1b565950fa4dab8b9af3ae24f3cf8c12c84659", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efdc7e19ca67331ae7f0061c76964299db27242d/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efdc7e19ca67331ae7f0061c76964299db27242d/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=efdc7e19ca67331ae7f0061c76964299db27242d", "patch": "@@ -1,3 +1,10 @@\n+2002-09-16  Richard Henderson  <rth@redhat.com>\n+\n+\t* jcf-parse.c (get_constant): Runtime check for IEEE format;\n+\tuse new real.h interface.\n+\t* jcf-write.c (find_constant_index): Use new real.h interface.\n+\t* lex.c (IS_ZERO): Use REAL_VALUES_EQUAL.\n+\n 2002-09-15  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* lang.c: Follow spelling conventions."}, {"sha": "29ccf6328df71a6996af47e261980f19205aa01a", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 36, "deletions": 39, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efdc7e19ca67331ae7f0061c76964299db27242d/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efdc7e19ca67331ae7f0061c76964299db27242d/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=efdc7e19ca67331ae7f0061c76964299db27242d", "patch": "@@ -290,47 +290,44 @@ get_constant (jcf, index)\n \tforce_fit_type (value, 0);\n \tbreak;\n       }\n-#if TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT\n+\n     case CONSTANT_Float:\n-      {\n-\tjint num = JPOOL_INT(jcf, index);\n-\tREAL_VALUE_TYPE d;\n-\td = REAL_VALUE_FROM_TARGET_SINGLE (num);\n-\tvalue = build_real (float_type_node, d);\n-\tbreak;\n-      }\n+      /* ??? Even more ideal would be to import the number using the\n+\t IEEE decode routines, then use whatever format the target\n+\t actually uses.  This would enable Java on VAX to kind work.  */\n+      if (TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT)\n+\t{\n+\t  jint num = JPOOL_INT(jcf, index);\n+\t  long buf = num;\n+\t  REAL_VALUE_TYPE d;\n+\t  real_from_target (&d, &buf, SFmode);\n+\t  value = build_real (float_type_node, d);\n+\t  break;\n+\t}\n+      else\n+\tgoto bad;\n+\n     case CONSTANT_Double:\n-      {\n-\tHOST_WIDE_INT num[2];\n-\tREAL_VALUE_TYPE d;\n-\tHOST_WIDE_INT lo, hi;\n-\tnum[0] = JPOOL_UINT (jcf, index);\n-\tlshift_double (num[0], 0, 32, 64, &lo, &hi, 0);\n-\tnum[0] = JPOOL_UINT (jcf, index+1);\n-\tadd_double (lo, hi, num[0], 0, &lo, &hi);\n-\n-\t/* Since ereal_from_double expects an array of HOST_WIDE_INT\n-\t   in the target's format, we swap the elements for big endian\n-\t   targets, unless HOST_WIDE_INT is sufficiently large to\n-\t   contain a target double, in which case the 2nd element\n-\t   is ignored.\n-\n-\t   FIXME: Is this always right for cross targets? */\n-\tif (FLOAT_WORDS_BIG_ENDIAN && sizeof(num[0]) < 8)\n-\t  {\n-\t    num[0] = hi;\n-\t    num[1] = lo;\n-\t  }\n-\telse\n-\t  {\n-\t    num[0] = lo;\n-\t    num[1] = hi;\n-\t  }\n-\td = REAL_VALUE_FROM_TARGET_DOUBLE (num);\n-\tvalue = build_real (double_type_node, d);\n-\tbreak;\n-      }\n-#endif /* TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT */\n+      if (TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT)\n+\t{\n+\t  long buf[2], lo, hi;\n+\t  REAL_VALUE_TYPE d;\n+\n+\t  hi = JPOOL_UINT (jcf, index);\n+\t  lo = JPOOL_UINT (jcf, index+1);\n+\n+\t  if (FLOAT_WORDS_BIG_ENDIAN)\n+\t    buf[0] = hi, buf[1] = lo;\n+\t  else\n+\t    buf[0] = lo, buf[1] = hi;\n+\n+\t  real_from_target (&d, buf, DFmode);\n+\t  value = build_real (double_type_node, d);\n+\t  break;\n+\t}\n+      else\n+\tgoto bad;\n+\n     case CONSTANT_String:\n       {\n \ttree name = get_name_constant (jcf, JPOOL_USHORT1 (jcf, index));"}, {"sha": "1a9f1075e232c4770dd76d1e950e814f46287f05", "filename": "gcc/java/jcf-write.c", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efdc7e19ca67331ae7f0061c76964299db27242d/gcc%2Fjava%2Fjcf-write.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efdc7e19ca67331ae7f0061c76964299db27242d/gcc%2Fjava%2Fjcf-write.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-write.c?ref=efdc7e19ca67331ae7f0061c76964299db27242d", "patch": "@@ -826,21 +826,18 @@ find_constant_index (value, state)\n   else if (TREE_CODE (value) == REAL_CST)\n     {\n       long words[2];\n+\n+      real_to_target (words, &TREE_REAL_CST (value),\n+\t\t      TYPE_MODE (TREE_TYPE (value)));\n+      words[0] &= 0xffffffff;\n+      words[1] &= 0xffffffff;\n+\n       if (TYPE_PRECISION (TREE_TYPE (value)) == 32)\n-\t{\n-\t  words[0] = etarsingle (TREE_REAL_CST (value)) & 0xFFFFFFFF;\n-\t  return find_constant1 (&state->cpool, CONSTANT_Float, \n-\t\t\t\t (jword)words[0]);\n-\t}\n+\treturn find_constant1 (&state->cpool, CONSTANT_Float, (jword)words[0]);\n       else\n-\t{\n-\t  etardouble (TREE_REAL_CST (value), words);\n-\t  return find_constant2 (&state->cpool, CONSTANT_Double,\n-\t\t\t\t (jword)(words[1-FLOAT_WORDS_BIG_ENDIAN] & \n-\t\t\t\t\t 0xFFFFFFFF),\n-\t\t\t\t (jword)(words[FLOAT_WORDS_BIG_ENDIAN] & \n-\t\t\t\t\t 0xFFFFFFFF));\n-\t}\n+\treturn find_constant2 (&state->cpool, CONSTANT_Double,\n+\t\t\t       (jword)words[1-FLOAT_WORDS_BIG_ENDIAN],\n+\t\t\t       (jword)words[FLOAT_WORDS_BIG_ENDIAN]);\n     }\n   else if (TREE_CODE (value) == STRING_CST)\n     return find_string_constant (&state->cpool, value);"}, {"sha": "026d3cacbd6994c8e3e0a818f399d3c505543075", "filename": "gcc/java/lex.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efdc7e19ca67331ae7f0061c76964299db27242d/gcc%2Fjava%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efdc7e19ca67331ae7f0061c76964299db27242d/gcc%2Fjava%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flex.c?ref=efdc7e19ca67331ae7f0061c76964299db27242d", "patch": "@@ -834,7 +834,7 @@ java_parse_escape_sequence ()\n }\n \n #ifndef JC1_LITE\n-#define IS_ZERO(X) (ereal_cmp (X, dconst0) == 0)\n+#define IS_ZERO(X) REAL_VALUES_EQUAL (X, dconst0)\n \n /* Subroutine of java_lex: converts floating-point literals to tree\n    nodes.  LITERAL_TOKEN is the input literal, JAVA_LVAL is where to"}, {"sha": "1e2709f8aaef7e4158f357c27d9bccdc4ceb460f", "filename": "gcc/loop.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efdc7e19ca67331ae7f0061c76964299db27242d/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efdc7e19ca67331ae7f0061c76964299db27242d/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=efdc7e19ca67331ae7f0061c76964299db27242d", "patch": "@@ -9292,6 +9292,9 @@ canonicalize_condition (insn, cond, reverse, earliest, want_reg)\n       if (set)\n \t{\n \t  enum machine_mode inner_mode = GET_MODE (SET_DEST (set));\n+#ifdef FLOAT_STORE_FLAG_VALUE\n+\t  REAL_VALUE_TYPE fsfv;\n+#endif\n \n \t  /* ??? We may not combine comparisons done in a CCmode with\n \t     comparisons not done in a CCmode.  This is to aid targets\n@@ -9319,8 +9322,8 @@ canonicalize_condition (insn, cond, reverse, earliest, want_reg)\n #ifdef FLOAT_STORE_FLAG_VALUE\n \t\t     || (code == LT\n \t\t\t && GET_MODE_CLASS (inner_mode) == MODE_FLOAT\n-\t\t\t && (REAL_VALUE_NEGATIVE\n-\t\t\t     (FLOAT_STORE_FLAG_VALUE (inner_mode))))\n+\t\t\t && (fsfv = FLOAT_STORE_FLAG_VALUE (inner_mode),\n+\t\t\t     REAL_VALUE_NEGATIVE (fsfv)))\n #endif\n \t\t     ))\n \t\t   && GET_RTX_CLASS (GET_CODE (SET_SRC (set))) == '<'))\n@@ -9339,8 +9342,8 @@ canonicalize_condition (insn, cond, reverse, earliest, want_reg)\n #ifdef FLOAT_STORE_FLAG_VALUE\n \t\t     || (code == GE\n \t\t\t && GET_MODE_CLASS (inner_mode) == MODE_FLOAT\n-\t\t\t && (REAL_VALUE_NEGATIVE\n-\t\t\t     (FLOAT_STORE_FLAG_VALUE (inner_mode))))\n+\t\t\t && (fsfv = FLOAT_STORE_FLAG_VALUE (inner_mode),\n+\t\t\t     REAL_VALUE_NEGATIVE (fsfv)))\n #endif\n \t\t     ))\n \t\t   && GET_RTX_CLASS (GET_CODE (SET_SRC (set))) == '<'"}, {"sha": "01121714692d8e93b55a1655837d51dc37304150", "filename": "gcc/optabs.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efdc7e19ca67331ae7f0061c76964299db27242d/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efdc7e19ca67331ae7f0061c76964299db27242d/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=efdc7e19ca67331ae7f0061c76964299db27242d", "patch": "@@ -4626,10 +4626,8 @@ expand_float (to, from, unsignedp)\n       emit_cmp_and_jump_insns (from, const0_rtx, GE, NULL_RTX, GET_MODE (from),\n \t\t\t       0, label);\n \n-      /* On SCO 3.2.1, ldexp rejects values outside [0.5, 1).\n-\t Rather than setting up a dconst_dot_5, let's hope SCO\n-\t fixes the bug.  */\n-      offset = REAL_VALUE_LDEXP (dconst1, GET_MODE_BITSIZE (GET_MODE (from)));\n+      \n+      real_2expN (&offset, GET_MODE_BITSIZE (GET_MODE (from)));\n       temp = expand_binop (fmode, add_optab, target,\n \t\t\t   CONST_DOUBLE_FROM_REAL_VALUE (offset, fmode),\n \t\t\t   target, 0, OPTAB_LIB_WIDEN);\n@@ -4812,7 +4810,7 @@ expand_fix (to, from, unsignedp)\n \t  rtx limit, lab1, lab2, insn;\n \n \t  bitsize = GET_MODE_BITSIZE (GET_MODE (to));\n-\t  offset = REAL_VALUE_LDEXP (dconst1, bitsize - 1);\n+\t  real_2expN (&offset, bitsize - 1);\n \t  limit = CONST_DOUBLE_FROM_REAL_VALUE (offset, fmode);\n \t  lab1 = gen_label_rtx ();\n \t  lab2 = gen_label_rtx ();"}, {"sha": "61ab02ce6a917387671efb12ec2c1b0580852538", "filename": "gcc/real.c", "status": "modified", "additions": 3205, "deletions": 6057, "changes": 9262, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efdc7e19ca67331ae7f0061c76964299db27242d/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efdc7e19ca67331ae7f0061c76964299db27242d/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=efdc7e19ca67331ae7f0061c76964299db27242d"}, {"sha": "31fa56140a9de10c53f0d863290ad3c97b71c1fc", "filename": "gcc/real.h", "status": "modified", "additions": 171, "deletions": 192, "changes": 363, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efdc7e19ca67331ae7f0061c76964299db27242d/gcc%2Freal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efdc7e19ca67331ae7f0061c76964299db27242d/gcc%2Freal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.h?ref=efdc7e19ca67331ae7f0061c76964299db27242d", "patch": "@@ -2,104 +2,52 @@\n    Copyright (C) 1989, 1991, 1994, 1996, 1997, 1998,\n    1999, 2000, 2002 Free Software Foundation, Inc.\n \n-This file is part of GCC.\n+   This file is part of GCC.\n \n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 2, or (at your option) any later\n-version.\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 2, or (at your option) any later\n+   version.\n \n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n \n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n-02111-1307, USA.  */\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the Free\n+   Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+   02111-1307, USA.  */\n \n #ifndef GCC_REAL_H\n #define GCC_REAL_H\n \n #include \"machmode.h\"\n \n-/* Define codes for all the float formats that we know of.  */\n-#define UNKNOWN_FLOAT_FORMAT 0\n-#define IEEE_FLOAT_FORMAT 1\n-#define VAX_FLOAT_FORMAT 2\n-#define IBM_FLOAT_FORMAT 3\n-#define C4X_FLOAT_FORMAT 4\n-\n-/* Default to IEEE float if not specified.  Nearly all machines use it.  */\n-\n-#ifndef TARGET_FLOAT_FORMAT\n-#define\tTARGET_FLOAT_FORMAT\tIEEE_FLOAT_FORMAT\n-#endif\n-\n-#ifndef HOST_FLOAT_FORMAT\n-#define\tHOST_FLOAT_FORMAT\tIEEE_FLOAT_FORMAT\n-#endif\n-\n-#ifndef INTEL_EXTENDED_IEEE_FORMAT\n-#define INTEL_EXTENDED_IEEE_FORMAT 0\n-#endif\n-\n-/* If FLOAT_WORDS_BIG_ENDIAN and HOST_FLOAT_WORDS_BIG_ENDIAN are not defined\n-   in the header files, then this implies the word-endianness is the same as\n-   for integers.  */\n-\n-/* This is defined 0 or 1, like WORDS_BIG_ENDIAN.  */\n-#ifndef FLOAT_WORDS_BIG_ENDIAN\n-#define FLOAT_WORDS_BIG_ENDIAN WORDS_BIG_ENDIAN\n-#endif\n-\n-/* This is defined 0 or 1, unlike HOST_WORDS_BIG_ENDIAN.  */\n-#ifndef HOST_FLOAT_WORDS_BIG_ENDIAN\n-#ifdef HOST_WORDS_BIG_ENDIAN\n-#define HOST_FLOAT_WORDS_BIG_ENDIAN 1\n-#else\n-#define HOST_FLOAT_WORDS_BIG_ENDIAN 0\n-#endif\n-#endif\n-\n-#ifndef LONG_DOUBLE_TYPE_SIZE\n-#define LONG_DOUBLE_TYPE_SIZE 64\n-#endif\n-/* MAX_LONG_DOUBLE_TYPE_SIZE is a constant tested by #if.\n-   LONG_DOUBLE_TYPE_SIZE can vary at compiler run time.\n-   So long as macros like REAL_VALUE_TO_TARGET_LONG_DOUBLE cannot\n-   vary too, however, then XFmode and TFmode long double\n-   cannot both be supported at the same time.  */\n-#ifndef MAX_LONG_DOUBLE_TYPE_SIZE\n-#define MAX_LONG_DOUBLE_TYPE_SIZE LONG_DOUBLE_TYPE_SIZE\n-#endif\n+/* REAL_VALUE_TYPE is an array of the minimum number of HOST_WIDE_INTs\n+   required to hold a 128-bit floating point type.  This is true even\n+   if the maximum precision floating point type on the target is smaller.\n \n-/* **** Start of software floating point emulator interface macros **** */\n+   The extra 32 bits are for storing the mode of the float.  Ideally\n+   we'd keep this elsewhere, but that's too drastic a change all at once.  */\n \n-/* REAL_VALUE_TYPE is an array of the minimum number of HOST_WIDE_INTs\n-   required to hold either a 96- or 160-bit extended precision floating\n-   point type.  This is true even if the maximum precision floating\n-   point type on the target is smaller.  */\n-#if MAX_LONG_DOUBLE_TYPE_SIZE == 128 && !INTEL_EXTENDED_IEEE_FORMAT\n-#define REAL_VALUE_TYPE_SIZE 160\n-#else\n-#define REAL_VALUE_TYPE_SIZE 96\n-#endif\n+#define REAL_VALUE_TYPE_SIZE (128 + 32)\n #define REAL_WIDTH \\\n   (REAL_VALUE_TYPE_SIZE/HOST_BITS_PER_WIDE_INT \\\n    + (REAL_VALUE_TYPE_SIZE%HOST_BITS_PER_WIDE_INT ? 1 : 0)) /* round up */\n+\n struct realvaluetype GTY(()) {\n   HOST_WIDE_INT r[REAL_WIDTH];\n };\n+\n /* Various headers condition prototypes on #ifdef REAL_VALUE_TYPE, so it needs\n    to be a macro.  realvaluetype cannot be a typedef as this interferes with\n    other headers declaring opaque pointers to it.  */\n #define REAL_VALUE_TYPE struct realvaluetype\n \n /* Calculate the format for CONST_DOUBLE.  We need as many slots as\n    are necessary to overlay a REAL_VALUE_TYPE on them.  This could be\n-   as many as five (32-bit HOST_WIDE_INT, 160-bit REAL_VALUE_TYPE).\n+   as many as four (32-bit HOST_WIDE_INT, 128-bit REAL_VALUE_TYPE).\n \n    A number of places assume that there are always at least two 'w'\n    slots in a CONST_DOUBLE, so we provide them even if one would suffice.  */\n@@ -126,134 +74,177 @@ struct realvaluetype GTY(()) {\n # endif\n #endif\n \n-extern unsigned int significand_size\tPARAMS ((enum machine_mode));\n+/* Declare functions in real.c.  */\n \n-#define REAL_ARITHMETIC(value, code, d1, d2) \\\n-  earith (&(value), (code), &(d1), &(d2))\n+/* Initialize the emulator.  */\n+extern void init_real_once\tPARAMS ((void));\n \n-/* Declare functions in real.c.  */\n-extern void earith\t\tPARAMS ((REAL_VALUE_TYPE *, int,\n-\t\t\t\t       REAL_VALUE_TYPE *, REAL_VALUE_TYPE *));\n-extern REAL_VALUE_TYPE etrunci\tPARAMS ((REAL_VALUE_TYPE));\n-extern REAL_VALUE_TYPE etruncui\tPARAMS ((REAL_VALUE_TYPE));\n-extern REAL_VALUE_TYPE ereal_negate PARAMS ((REAL_VALUE_TYPE));\n-extern HOST_WIDE_INT efixi\tPARAMS ((REAL_VALUE_TYPE));\n-extern unsigned HOST_WIDE_INT efixui PARAMS ((REAL_VALUE_TYPE));\n-extern void ereal_from_int\tPARAMS ((REAL_VALUE_TYPE *,\n-\t\t\t\t       HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t\t\t       enum machine_mode));\n-extern void ereal_from_uint\tPARAMS ((REAL_VALUE_TYPE *,\n-\t\t\t\t       unsigned HOST_WIDE_INT,\n-\t\t\t\t       unsigned HOST_WIDE_INT,\n-\t\t\t\t       enum machine_mode));\n-extern void ereal_to_int\tPARAMS ((HOST_WIDE_INT *, HOST_WIDE_INT *,\n-\t\t\t\t       REAL_VALUE_TYPE));\n-extern REAL_VALUE_TYPE ereal_ldexp PARAMS ((REAL_VALUE_TYPE, int));\n-\n-extern void etartdouble\t\tPARAMS ((REAL_VALUE_TYPE, long *));\n-extern void etarldouble\t\tPARAMS ((REAL_VALUE_TYPE, long *));\n-extern void etardouble\t\tPARAMS ((REAL_VALUE_TYPE, long *));\n-extern long etarsingle\t\tPARAMS ((REAL_VALUE_TYPE));\n-extern void ereal_to_decimal\tPARAMS ((REAL_VALUE_TYPE, char *, int));\n-extern int ereal_cmp\t\tPARAMS ((REAL_VALUE_TYPE, REAL_VALUE_TYPE));\n-extern int ereal_isneg\t\tPARAMS ((REAL_VALUE_TYPE));\n-extern REAL_VALUE_TYPE ereal_unto_float PARAMS ((long));\n-extern REAL_VALUE_TYPE ereal_unto_double PARAMS ((long *));\n-extern REAL_VALUE_TYPE ereal_from_float PARAMS ((HOST_WIDE_INT));\n-extern REAL_VALUE_TYPE ereal_from_double PARAMS ((HOST_WIDE_INT *));\n-\n-#define REAL_VALUES_EQUAL(x, y) (ereal_cmp ((x), (y)) == 0)\n-/* true if x < y : */\n-#define REAL_VALUES_LESS(x, y) (ereal_cmp ((x), (y)) == -1)\n-#define REAL_VALUE_LDEXP(x, n) ereal_ldexp (x, n)\n-\n-/* Compare two floating-point objects for bitwise identity.\n-   This is not the same as comparing for equality on IEEE hosts:\n-   -0.0 equals 0.0 but they are not identical, and conversely\n-   two NaNs might be identical but they cannot be equal.  */\n-#define REAL_VALUES_IDENTICAL(x, y) \\\n-  (!memcmp ((char *) &(x), (char *) &(y), sizeof (REAL_VALUE_TYPE)))\n-\n-/* These return REAL_VALUE_TYPE: */\n-#define REAL_VALUE_RNDZINT(x) (etrunci (x))\n-#define REAL_VALUE_UNSIGNED_RNDZINT(x) (etruncui (x))\n-\n-/* Truncate the floating-point value X to mode MODE.  */\n-#define REAL_VALUE_TRUNCATE(mode, x)  real_value_truncate (mode, x)\n-extern REAL_VALUE_TYPE real_value_truncate PARAMS ((enum machine_mode,\n-                                                 REAL_VALUE_TYPE));\n+/* Binary or unary arithmetic on tree_code.  */\n+extern void real_arithmetic\tPARAMS ((REAL_VALUE_TYPE *, int,\n+\t\t\t\t\t const REAL_VALUE_TYPE *,\n+\t\t\t\t\t const REAL_VALUE_TYPE *));\n+\n+/* Compare reals by tree_code.  */\n+extern bool real_compare\tPARAMS ((int, const REAL_VALUE_TYPE *,\n+\t\t\t\t\t const REAL_VALUE_TYPE *));\n+\n+/* Determine whether a floating-point value X is infinite.  */\n+extern bool real_isinf\t\tPARAMS ((const REAL_VALUE_TYPE *));\n+\n+/* Determine whether a floating-point value X is a NaN.  */\n+extern bool real_isnan\t\tPARAMS ((const REAL_VALUE_TYPE *));\n+\n+/* Determine whether a floating-point value X is negative.  */\n+extern bool real_isneg\t\tPARAMS ((const REAL_VALUE_TYPE *));\n+\n+/* Determine whether a floating-point value X is minus zero.  */\n+extern bool real_isnegzero\tPARAMS ((const REAL_VALUE_TYPE *));\n+\n+/* Compare two floating-point objects for bitwise identity.  */\n+extern bool real_identical\tPARAMS ((const REAL_VALUE_TYPE *,\n+\t\t\t\t\t const REAL_VALUE_TYPE *));\n \n-/* Expansion of REAL_VALUE_TRUNCATE.\n-   The result is in floating point, rounded to nearest or even.  */\n+/* Extend or truncate to a new mode.  */\n+extern void real_convert\tPARAMS ((REAL_VALUE_TYPE *,\n+\t\t\t\t\t enum machine_mode,\n+\t\t\t\t\t const REAL_VALUE_TYPE *));\n+\n+/* Return true if truncating to NEW is exact.  */\n extern bool exact_real_truncate PARAMS ((enum machine_mode,\n-\t\t\t\t\t REAL_VALUE_TYPE *));\n+\t\t\t\t\t const REAL_VALUE_TYPE *));\n+\n+/* Render R as a decimal floating point constant.  */\n+extern void real_to_decimal\tPARAMS ((char *, const REAL_VALUE_TYPE *,\n+\t\t\t\t\t int));\n+\n+/* Render R as a hexadecimal floating point constant.  */\n+extern void real_to_hexadecimal\tPARAMS ((char *, const REAL_VALUE_TYPE *,\n+\t\t\t\t\t int));\n+\n+/* Render R as an integer.  */\n+extern HOST_WIDE_INT real_to_integer PARAMS ((const REAL_VALUE_TYPE *));\n+extern void real_to_integer2 PARAMS ((HOST_WIDE_INT *, HOST_WIDE_INT *,\n+\t\t\t\t      const REAL_VALUE_TYPE *));\n+\n+/* Initialize R from a decimal or hexadecimal string.  */\n+extern void real_from_string\tPARAMS ((REAL_VALUE_TYPE *, const char *));\n+\n+/* Initialize R from an integer pair HIGH/LOW.  */\n+extern void real_from_integer\tPARAMS ((REAL_VALUE_TYPE *,\n+\t\t\t\t\t enum machine_mode,\n+\t\t\t\t\t unsigned HOST_WIDE_INT,\n+\t\t\t\t\t HOST_WIDE_INT, int));\n \n-/* These return HOST_WIDE_INT: */\n-/* Convert a floating-point value to integer, rounding toward zero.  */\n-#define REAL_VALUE_FIX(x) (efixi (x))\n-/* Convert a floating-point value to unsigned integer, rounding\n-   toward zero.  */\n-#define REAL_VALUE_UNSIGNED_FIX(x) (efixui (x))\n+extern long real_to_target\tPARAMS ((long *, const REAL_VALUE_TYPE *,\n+\t\t\t\t\t enum machine_mode));\n \n-/* Convert ASCII string S to floating point in mode M.\n-   Decimal input uses ATOF.  Hexadecimal uses HTOF.  */\n-#define REAL_VALUE_ATOF(s,m) ereal_atof(s,m)\n-#define REAL_VALUE_HTOF(s,m) ereal_atof(s,m)\n+extern void real_from_target\tPARAMS ((REAL_VALUE_TYPE *, const long *,\n+\t\t\t\t\t enum machine_mode));\n \n-#define REAL_VALUE_NEGATE ereal_negate\n+extern void real_inf\t\tPARAMS ((REAL_VALUE_TYPE *));\n \n-/* Compute the absolute value of a floating-point value X.  */\n-#define REAL_VALUE_ABS(x) \\\n-   (REAL_VALUE_NEGATIVE (x) ? REAL_VALUE_NEGATE (x) : (x))\n+extern void real_nan\t\tPARAMS ((REAL_VALUE_TYPE *, const char *,\n+\t\t\t\t\t int, enum machine_mode));\n+\n+extern void real_2expN\t\tPARAMS ((REAL_VALUE_TYPE *, int));\n+\n+/* ====================================================================== */\n+/* Crap.  */\n+\n+/* Define codes for all the float formats that we know of.  */\n+#define UNKNOWN_FLOAT_FORMAT 0\n+#define IEEE_FLOAT_FORMAT 1\n+#define VAX_FLOAT_FORMAT 2\n+#define IBM_FLOAT_FORMAT 3\n+#define C4X_FLOAT_FORMAT 4\n+\n+/* Default to IEEE float if not specified.  Nearly all machines use it.  */\n+\n+#ifndef TARGET_FLOAT_FORMAT\n+#define\tTARGET_FLOAT_FORMAT\tIEEE_FLOAT_FORMAT\n+#endif\n+\n+#define REAL_ARITHMETIC(value, code, d1, d2) \\\n+  real_arithmetic (&(value), code, &(d1), &(d2))\n+\n+#define REAL_VALUES_IDENTICAL(x, y)\treal_identical (&(x), &(y))\n+#define REAL_VALUES_EQUAL(x, y)\t\treal_compare (EQ_EXPR, &(x), &(y))\n+#define REAL_VALUES_LESS(x, y)\t\treal_compare (LT_EXPR, &(x), &(y))\n \n /* Determine whether a floating-point value X is infinite.  */\n-#define REAL_VALUE_ISINF(x) (target_isinf (x))\n+#define REAL_VALUE_ISINF(x)\t\treal_isinf (&(x))\n \n /* Determine whether a floating-point value X is a NaN.  */\n-#define REAL_VALUE_ISNAN(x) (target_isnan (x))\n+#define REAL_VALUE_ISNAN(x)\t\treal_isnan (&(x))\n \n /* Determine whether a floating-point value X is negative.  */\n-#define REAL_VALUE_NEGATIVE(x) (target_negative (x))\n+#define REAL_VALUE_NEGATIVE(x)\t\treal_isneg (&(x))\n \n /* Determine whether a floating-point value X is minus zero.  */\n-#define REAL_VALUE_MINUS_ZERO(x) \\\n- ((ereal_cmp (x, dconst0) == 0) && (ereal_isneg (x) != 0 ))\n+#define REAL_VALUE_MINUS_ZERO(x)\treal_isnegzero (&(x))\n+\n+/* IN is a REAL_VALUE_TYPE.  OUT is an array of longs.  */\n+#define REAL_VALUE_TO_TARGET_LONG_DOUBLE(IN, OUT)\t\t\t\\\n+  real_to_target (OUT, &(IN),\t\t\t\t\t\t\\\n+\t\t  mode_for_size (LONG_DOUBLE_TYPE_SIZE, MODE_FLOAT, 0))\n \n-#define REAL_VALUE_TO_INT ereal_to_int\n+#define REAL_VALUE_TO_TARGET_DOUBLE(IN, OUT) \\\n+  real_to_target (OUT, &(IN), mode_for_size (64, MODE_FLOAT, 0))\n \n-/* Here the cast to HOST_WIDE_INT sign-extends arguments such as ~0.  */\n-#define REAL_VALUE_FROM_INT(d, lo, hi, mode) \\\n-  ereal_from_int (&d, (HOST_WIDE_INT) (lo), (HOST_WIDE_INT) (hi), mode)\n+/* IN is a REAL_VALUE_TYPE.  OUT is a long.  */\n+#define REAL_VALUE_TO_TARGET_SINGLE(IN, OUT) \\\n+  ((OUT) = real_to_target (NULL, &(IN), mode_for_size (32, MODE_FLOAT, 0)))\n \n-#define REAL_VALUE_FROM_UNSIGNED_INT(d, lo, hi, mode) \\\n-  ereal_from_uint (&d, lo, hi, mode)\n+#define REAL_VALUE_TO_DECIMAL(r, s, dig) \\\n+  real_to_decimal (s, &(r), dig)\n \n-/* IN is a REAL_VALUE_TYPE.  OUT is an array of longs.  */\n-#define REAL_VALUE_TO_TARGET_LONG_DOUBLE(IN, OUT) \t\t\\\n-   (LONG_DOUBLE_TYPE_SIZE == 64 ? etardouble ((IN), (OUT))\t\\\n-    : LONG_DOUBLE_TYPE_SIZE == 96 ? etarldouble ((IN), (OUT))\t\\\n-    : LONG_DOUBLE_TYPE_SIZE == 128 ? etartdouble ((IN), (OUT))  \\\n-    : abort ())\n-#define REAL_VALUE_TO_TARGET_DOUBLE(IN, OUT) (etardouble ((IN), (OUT)))\n+#define REAL_VALUE_FROM_INT(r, lo, hi, mode) \\\n+  real_from_integer (&(r), mode, lo, hi, 0)\n \n-/* IN is a REAL_VALUE_TYPE.  OUT is a long.  */\n-#define REAL_VALUE_TO_TARGET_SINGLE(IN, OUT) ((OUT) = etarsingle ((IN)))\n+#define REAL_VALUE_FROM_UNSIGNED_INT(r, lo, hi, mode) \\\n+  real_from_integer (&(r), mode, lo, hi, 1)\n+\n+extern REAL_VALUE_TYPE real_value_truncate PARAMS ((enum machine_mode,\n+\t\t\t\t\t\t    REAL_VALUE_TYPE));\n+\n+#define REAL_VALUE_TO_INT(plow, phigh, r) \\\n+  real_to_integer2 (plow, phigh, &(r))\n+\n+extern REAL_VALUE_TYPE real_arithmetic2 PARAMS ((int, const REAL_VALUE_TYPE *,\n+\t\t\t\t\t\t const REAL_VALUE_TYPE *));\n+\n+#define REAL_VALUE_NEGATE(X) \\\n+  real_arithmetic2 (NEGATE_EXPR, &(X), NULL)\n \n-/* Inverse of REAL_VALUE_TO_TARGET_DOUBLE.  */\n-#define REAL_VALUE_UNTO_TARGET_DOUBLE(d)  (ereal_unto_double (d))\n+#define REAL_VALUE_ABS(X) \\\n+  real_arithmetic2 (ABS_EXPR, &(X), NULL)\n \n-/* Inverse of REAL_VALUE_TO_TARGET_SINGLE.  */\n-#define REAL_VALUE_UNTO_TARGET_SINGLE(f)  (ereal_unto_float (f))\n+extern int significand_size PARAMS ((enum machine_mode));\n \n-/* d is an array of HOST_WIDE_INT that holds a double precision\n-   value in the target computer's floating point format.  */\n-#define REAL_VALUE_FROM_TARGET_DOUBLE(d)  (ereal_from_double (d))\n+extern REAL_VALUE_TYPE real_from_string2 PARAMS ((const char *,\n+\t\t\t\t\t\t  enum machine_mode));\n \n-/* f is a HOST_WIDE_INT containing a single precision target float value.  */\n-#define REAL_VALUE_FROM_TARGET_SINGLE(f)  (ereal_from_float (f))\n+#define REAL_VALUE_ATOF(s, m) \\\n+  real_from_string2 (s, m)\n \n-/* Conversions to decimal ASCII string.  */\n-#define REAL_VALUE_TO_DECIMAL(r, s, dig) (ereal_to_decimal (r, s, dig))\n+#define CONST_DOUBLE_ATOF(s, m) \\\n+  CONST_DOUBLE_FROM_REAL_VALUE (real_from_string2 (s, m), m)\n+\n+#define REAL_VALUE_FIX(r) \\\n+  real_to_integer (&(r))\n+\n+/* ??? Not quite right.  */\n+#define REAL_VALUE_UNSIGNED_FIX(r) \\\n+  real_to_integer (&(r))\n+\n+/* ??? These were added for Paranoia support.  */\n+\n+/* Return floor log2(R).  */\n+extern int real_exponent\tPARAMS ((const REAL_VALUE_TYPE *));\n+\n+/* R = A * 2**EXP.  */\n+extern void real_ldexp\t\tPARAMS ((REAL_VALUE_TYPE *,\n+\t\t\t\t\t const REAL_VALUE_TYPE *, int));\n \n /* **** End of software floating point emulator interface macros **** */\n \f\n@@ -264,35 +255,23 @@ extern REAL_VALUE_TYPE dconst1;\n extern REAL_VALUE_TYPE dconst2;\n extern REAL_VALUE_TYPE dconstm1;\n \n-/* Given a CONST_DOUBLE in FROM, store into TO the value it represents.  */\n /* Function to return a real value (not a tree node)\n    from a given integer constant.  */\n-union tree_node;\n REAL_VALUE_TYPE real_value_from_int_cst\tPARAMS ((union tree_node *,\n-\t\t\t\t\t\tunion tree_node *));\n+\t\t\t\t\t\t union tree_node *));\n \n-#define REAL_VALUE_FROM_CONST_DOUBLE(to, from)\t\t\\\n+/* Given a CONST_DOUBLE in FROM, store into TO the value it represents.  */\n+#define REAL_VALUE_FROM_CONST_DOUBLE(to, from) \\\n   memcpy (&(to), &CONST_DOUBLE_LOW ((from)), sizeof (REAL_VALUE_TYPE))\n \n /* Return a CONST_DOUBLE with value R and mode M.  */\n-\n #define CONST_DOUBLE_FROM_REAL_VALUE(r, m) \\\n   const_double_from_real_value (r, m)\n extern rtx const_double_from_real_value PARAMS ((REAL_VALUE_TYPE,\n \t\t\t\t\t\t enum machine_mode));\n \n-/* Shorthand; can be handy in machine descriptions.  */\n-#define CONST_DOUBLE_ATOF(s, m) \\\n-  CONST_DOUBLE_FROM_REAL_VALUE (REAL_VALUE_ATOF (s, m), m)\n-\n /* Replace R by 1/R in the given machine mode, if the result is exact.  */\n-extern int exact_real_inverse\tPARAMS ((enum machine_mode, REAL_VALUE_TYPE *));\n-extern int target_isnan\t\tPARAMS ((REAL_VALUE_TYPE));\n-extern int target_isinf\t\tPARAMS ((REAL_VALUE_TYPE));\n-extern int target_negative\tPARAMS ((REAL_VALUE_TYPE));\n-extern void debug_real\t\tPARAMS ((REAL_VALUE_TYPE));\n-extern REAL_VALUE_TYPE ereal_atof PARAMS ((const char *, enum machine_mode));\n-extern REAL_VALUE_TYPE ereal_inf PARAMS ((enum machine_mode));\n+extern bool exact_real_inverse\tPARAMS ((enum machine_mode, REAL_VALUE_TYPE *));\n \n /* In tree.c: wrap up a REAL_VALUE_TYPE in a tree node.  */\n extern tree build_real\t\t\tPARAMS ((tree, REAL_VALUE_TYPE));"}, {"sha": "555646cccd569fa61dd783a014412ef46cc5ab4e", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efdc7e19ca67331ae7f0061c76964299db27242d/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efdc7e19ca67331ae7f0061c76964299db27242d/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=efdc7e19ca67331ae7f0061c76964299db27242d", "patch": "@@ -22,8 +22,8 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n #include \"config.h\"\n #include \"system.h\"\n-\n #include \"rtl.h\"\n+#include \"tree.h\"\n #include \"tm_p.h\"\n #include \"regs.h\"\n #include \"hard-reg-set.h\"\n@@ -603,8 +603,6 @@ simplify_unary_operation (code, mode, op, op_mode)\n \tcase NEG:\t      d = REAL_VALUE_NEGATE (d);\t\tbreak;\n \tcase FLOAT_TRUNCATE:  d = real_value_truncate (mode, d);\tbreak;\n \tcase FLOAT_EXTEND:    /* All this does is change the mode.  */  break;\n-\tcase FIX:\t      d = REAL_VALUE_RNDZINT (d);\t\tbreak;\n-\tcase UNSIGNED_FIX:    d = REAL_VALUE_UNSIGNED_RNDZINT (d);\tbreak;\n \tdefault:\n \t  abort ();\n \t}"}, {"sha": "595eefc624a8d99ea97215eda60c3b8a5255dab1", "filename": "gcc/toplev.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efdc7e19ca67331ae7f0061c76964299db27242d/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efdc7e19ca67331ae7f0061c76964299db27242d/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=efdc7e19ca67331ae7f0061c76964299db27242d", "patch": "@@ -66,6 +66,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"reload.h\"\n #include \"dwarf2asm.h\"\n #include \"integrate.h\"\n+#include \"real.h\"\n #include \"debug.h\"\n #include \"target.h\"\n #include \"langhooks.h\"\n@@ -5155,6 +5156,9 @@ backend_init ()\n   /* init_emit_once uses reg_raw_mode and therefore must be called\n      after init_regs which initialized reg_raw_mode.  */\n   init_regs ();\n+  /* Similarly, init_emit_once uses floating point numbers, and\n+     thus must follow init_real_once.  */\n+  init_real_once ();\n   init_emit_once (debug_info_level == DINFO_LEVEL_NORMAL\n \t\t  || debug_info_level == DINFO_LEVEL_VERBOSE\n #ifdef VMS_DEBUGGING_INFO"}, {"sha": "1d0da06aa5a2f703c3cde58994a534e2b6fcdd8e", "filename": "gcc/tree.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efdc7e19ca67331ae7f0061c76964299db27242d/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efdc7e19ca67331ae7f0061c76964299db27242d/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=efdc7e19ca67331ae7f0061c76964299db27242d", "patch": "@@ -474,11 +474,8 @@ build_real (type, d)\n   REAL_VALUE_TYPE *dp;\n   int overflow = 0;\n \n-  /* Check for valid float value for this type on this target machine;\n-     if not, can print error message and store a valid value in D.  */\n-#ifdef CHECK_FLOAT_VALUE\n-  CHECK_FLOAT_VALUE (TYPE_MODE (type), d, overflow);\n-#endif\n+  /* ??? Used to check for overflow here via CHECK_FLOAT_TYPE.\n+     Consider doing it via real_convert now.  */\n \n   v = make_node (REAL_CST);\n   dp = ggc_alloc (sizeof (REAL_VALUE_TYPE));"}]}