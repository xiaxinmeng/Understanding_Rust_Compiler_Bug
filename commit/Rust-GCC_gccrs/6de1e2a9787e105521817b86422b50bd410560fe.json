{"sha": "6de1e2a9787e105521817b86422b50bd410560fe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmRlMWUyYTk3ODdlMTA1NTIxODE3Yjg2NDIyYjUwYmQ0MTA1NjBmZQ==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@rabi.columbia.edu", "date": "1999-02-18T15:35:49Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "1999-02-18T15:35:49Z"}, "message": "cpplib.c: Kill define of STDC_VALUE.\n\n1999-02-18 18:32 -0500  Zack Weinberg  <zack@rabi.columbia.edu>\n\t* cpplib.c: Kill define of STDC_VALUE.  Don't include output.h\n          or prefix.h. Change CPP_IS_MACRO_BUFFER to not refer to\n          macro_cleanup.\n\t  (GET_ENV_PATH_LIST, PATH_SEPARATOR, STANDARD_INCLUDE_DIR,\n          predefs, SIZE_TYPE, PTRDIFF_TYPE, WCHAR_TYPE,\n          CPP_WCHAR_TYPE, USER_LABEL_PREFIX, REGISTER_PREFIX, struct\n          cpp_pending, version_string, struct default_include,\n          include_defaults_array, path_include, cpp_options_init,\n          dump_special_to_buffer, initialize_builtins, cpp_start_read,\n          cpp_reader_init, nreverse_pending, push_pending, print_help,\n          cpp_handle_option, cpp_handle_options, cpp_finish,\n          cpp_cleanup): Move to cppinit.c.\n\t  (macro_cleanup, struct arglist, collect_expansion,\n\t  create_definition, compare_defs, comp_def_part, ARG_BASE,\n\t  struct argdata, macarg, change_newlines, timestamp,\n\t  monthnames, special_symbol, unsafe_chars, macroexpand,\n\t  push_macro_expansion): Move to cpphash.c.\n\t  (quote_string, check_macro_name, cpp_expand_to_buffer,\n\t  output_line_command, cpp_undef): Export.\n\t  (null_underflow, null_cleanup, handle_directive): Make static.\n\t* cpplib.h: Prototype now-exported functions.  Adjust decls of\n          syntax tables so we can include cpplib.h in cppinit.c.\n\t* cpphash.h: Prototype all functions exported by cpphash.c.\n\t* cppinit.c: Make syntax tables initialized data if possible\n          (uses GCC designated-initializer extension).\n\t* cppexp.c:  Make cpp_lex static.\n\t* Makefile.in: Move -D switches for the various include dirs\n          from cpplib.o rule to cppinit.o rule.  Adjust dependencies.\n\nFrom-SVN: r25287", "tree": {"sha": "755ff3010888b5791d0cc4946b458010353a6f78", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/755ff3010888b5791d0cc4946b458010353a6f78"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6de1e2a9787e105521817b86422b50bd410560fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6de1e2a9787e105521817b86422b50bd410560fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6de1e2a9787e105521817b86422b50bd410560fe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6de1e2a9787e105521817b86422b50bd410560fe/comments", "author": null, "committer": null, "parents": [{"sha": "43c5ec700f4a849d3b49324f1789e2aee41b6dbf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43c5ec700f4a849d3b49324f1789e2aee41b6dbf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43c5ec700f4a849d3b49324f1789e2aee41b6dbf"}], "stats": {"total": 6596, "additions": 3391, "deletions": 3205}, "files": [{"sha": "d8a8c016751015d068c35e291541b5ada3ddd133", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de1e2a9787e105521817b86422b50bd410560fe/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de1e2a9787e105521817b86422b50bd410560fe/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6de1e2a9787e105521817b86422b50bd410560fe", "patch": "@@ -1,3 +1,35 @@\n+1999-02-18 18:32 -0500  Zack Weinberg  <zack@rabi.columbia.edu>\n+\n+\t* cpplib.c: Kill define of STDC_VALUE.  Don't include output.h\n+          or prefix.h. Change CPP_IS_MACRO_BUFFER to not refer to\n+          macro_cleanup.\n+\t  (GET_ENV_PATH_LIST, PATH_SEPARATOR, STANDARD_INCLUDE_DIR,\n+          predefs, SIZE_TYPE, PTRDIFF_TYPE, WCHAR_TYPE,\n+          CPP_WCHAR_TYPE, USER_LABEL_PREFIX, REGISTER_PREFIX, struct\n+          cpp_pending, version_string, struct default_include,\n+          include_defaults_array, path_include, cpp_options_init,\n+          dump_special_to_buffer, initialize_builtins, cpp_start_read,\n+          cpp_reader_init, nreverse_pending, push_pending, print_help,\n+          cpp_handle_option, cpp_handle_options, cpp_finish,\n+          cpp_cleanup): Move to cppinit.c.\n+\t  (macro_cleanup, struct arglist, collect_expansion,\n+\t  create_definition, compare_defs, comp_def_part, ARG_BASE,\n+\t  struct argdata, macarg, change_newlines, timestamp,\n+\t  monthnames, special_symbol, unsafe_chars, macroexpand,\n+\t  push_macro_expansion): Move to cpphash.c.\n+\t  (quote_string, check_macro_name, cpp_expand_to_buffer,\n+\t  output_line_command, cpp_undef): Export.\n+\t  (null_underflow, null_cleanup, handle_directive): Make static.\n+\n+\t* cpplib.h: Prototype now-exported functions.  Adjust decls of\n+          syntax tables so we can include cpplib.h in cppinit.c.\n+\t* cpphash.h: Prototype all functions exported by cpphash.c.\n+\t* cppinit.c: Make syntax tables initialized data if possible\n+          (uses GCC designated-initializer extension).\n+\t* cppexp.c:  Make cpp_lex static.\n+\t* Makefile.in: Move -D switches for the various include dirs\n+          from cpplib.o rule to cppinit.o rule.  Adjust dependencies.\n+\n Thu Feb 18 13:15:56 1999  Marc Espie <espie@cvs.openbsd.org>\n \n \t* alpha/openbsd.h: New file."}, {"sha": "f42fcad3932ef534a834668ed603be636b35f456", "filename": "gcc/Makefile.in", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de1e2a9787e105521817b86422b50bd410560fe/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de1e2a9787e105521817b86422b50bd410560fe/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=6de1e2a9787e105521817b86422b50bd410560fe", "patch": "@@ -1970,23 +1970,23 @@ cppmain$(exeext): cppmain.o libcpp.a $(LIBDEPS)\n \n cppmain.o: cppmain.c $(CONFIG_H) cpplib.h intl.h machmode.h system.h\n \n-cpplib.o: cpplib.c $(CONFIG_H) cpplib.h intl.h machmode.h system.h cpphash.h \\\n-\t\tprefix.h output.h Makefile\n+cppulp.o:  cppulp.c  $(CONFIG_H) system.h output.h\n+cpplib.o:  cpplib.c  $(CONFIG_H) cpplib.h intl.h machmode.h system.h cpphash.h\n+cpphash.o: cpphash.c $(CONFIG_H) cpplib.h intl.h machmode.h system.h cpphash.h\n+cppalloc.o: cppalloc.c $(CONFIG_H) cpplib.h intl.h machmode.h system.h\n+cpperror.o: cpperror.c $(CONFIG_H) cpplib.h intl.h machmode.h system.h\n+cppexp.o:   cppexp.c   $(CONFIG_H) cpplib.h intl.h machmode.h system.h\n+cppfiles.o: cppfiles.c $(CONFIG_H) cpplib.h intl.h machmode.h system.h\n+\n+cppinit.o:  cppalloc.c $(CONFIG_H) cpplib.h intl.h machmode.h system.h \\\n+\t\tcpphash.h prefix.h output.h Makefile\n \t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n \t  -DGCC_INCLUDE_DIR=\\\"$(libsubdir)/include\\\" \\\n \t  -DGPLUSPLUS_INCLUDE_DIR=\\\"$(gxx_include_dir)\\\" \\\n \t  -DLOCAL_INCLUDE_DIR=\\\"$(includedir)\\\" \\\n \t  -DCROSS_INCLUDE_DIR=\\\"$(gcc_tooldir)/sys-include\\\" \\\n \t  -DTOOL_INCLUDE_DIR=\\\"$(gcc_tooldir)/include\\\" \\\n-\t  -c `echo $(srcdir)/cpplib.c | sed 's,^\\./,,'`\n-\n-cppulp.o: cppulp.c $(CONFIG_H) system.h output.h\n-cpphash.o: cpphash.c $(CONFIG_H) cpplib.h intl.h machmode.h system.h cpphash.h\n-cppalloc.o: cppalloc.c $(CONFIG_H) cpplib.h intl.h machmode.h system.h\n-cpperror.o: cpperror.c $(CONFIG_H) cpplib.h intl.h machmode.h system.h\n-cppexp.o:   cppexp.c   $(CONFIG_H) cpplib.h intl.h machmode.h system.h\n-cppfiles.o: cppfiles.c $(CONFIG_H) cpplib.h intl.h machmode.h system.h\n-cppinit.o:  cppalloc.c $(CONFIG_H) cpplib.h intl.h machmode.h system.h\n+\t  -c `echo $(srcdir)/cppinit.c | sed 's,^\\./,,'`\n \n # Note for the stamp targets, we run the program `true' instead of\n # having an empty command (nothing following the semicolon)."}, {"sha": "3b146d2531b5e6b9feba8a98b2b9fd2e02244a93", "filename": "gcc/cppexp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de1e2a9787e105521817b86422b50bd410560fe/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de1e2a9787e105521817b86422b50bd410560fe/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=6de1e2a9787e105521817b86422b50bd410560fe", "patch": "@@ -376,7 +376,7 @@ static struct token tokentab2[] = {\n \n /* Read one token.  */\n \n-struct operation\n+static struct operation\n cpp_lex (pfile, skip_evaluation)\n      cpp_reader *pfile;\n      int skip_evaluation;"}, {"sha": "a9061a9a5d26537254eb0dd2b1c1c95521544f41", "filename": "gcc/cpphash.c", "status": "modified", "additions": 1490, "deletions": 14, "changes": 1504, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de1e2a9787e105521817b86422b50bd410560fe/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de1e2a9787e105521817b86422b50bd410560fe/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=6de1e2a9787e105521817b86422b50bd410560fe", "patch": "@@ -1,4 +1,4 @@\n-/* Part of CPP library.  (Macro hash table support.)\n+/* Part of CPP library.  (Macro handling.)\n    Copyright (C) 1986, 87, 89, 92-95, 1996, 1998 Free Software Foundation, Inc.\n    Written by Per Bothner, 1994.\n    Based on CCCP program by Paul Rubin, June 1986\n@@ -29,6 +29,63 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n \n static HASHNODE *hashtab[HASHSIZE];\n \n+static int comp_def_part\t PARAMS ((int, U_CHAR *, int, U_CHAR *,\n+\t\t\t\t\t  int, int));\n+static int change_newlines\t PARAMS ((U_CHAR *, int));\n+static void push_macro_expansion PARAMS ((cpp_reader *,\n+\t\t\t\t\t  U_CHAR *, int, HASHNODE *));\n+static int unsafe_chars\t\t PARAMS ((int, int));\n+\n+#define SKIP_WHITE_SPACE(p) do { while (is_hor_space[*p]) p++; } while (0)\n+#define CPP_IS_MACRO_BUFFER(PBUF) ((PBUF)->data != NULL)\n+#define FORWARD(N) CPP_FORWARD (CPP_BUFFER (pfile), (N))\n+\n+extern char *version_string;\n+\n+/* The arglist structure is built by create_definition to tell\n+   collect_expansion where the argument names begin.  That\n+   is, for a define like \"#define f(x,y,z) foo+x-bar*y\", the arglist\n+   would contain pointers to the strings x, y, and z.\n+   collect_expansion would then build a DEFINITION node,\n+   with reflist nodes pointing to the places x, y, and z had\n+   appeared.  So the arglist is just convenience data passed\n+   between these two routines.  It is not kept around after\n+   the current #define has been processed and entered into the\n+   hash table.  */\n+\n+struct arglist\n+{\n+  struct arglist *next;\n+  U_CHAR *name;\n+  int length;\n+  int argno;\n+  char rest_args;\n+};\n+\n+/* This structure represents one parsed argument in a macro call.\n+   `raw' points to the argument text as written (`raw_length' is its length).\n+   `expanded' points to the argument's macro-expansion\n+   (its length is `expand_length').\n+   `stringified_length' is the length the argument would have\n+   if stringified.\n+   `use_count' is the number of times this macro arg is substituted\n+   into the macro.  If the actual use count exceeds 10, \n+   the value stored is 10.  */\n+\n+/* raw and expanded are relative to ARG_BASE */\n+#define ARG_BASE ((pfile)->token_buffer)\n+\n+struct argdata\n+{\n+  /* Strings relative to pfile->token_buffer */\n+  long raw, expanded, stringified;\n+  int raw_length, expand_length;\n+  int stringified_length;\n+  char newlines;\n+  char use_count;\n+};\n+\n+\n /* Return hash function on name.  must be compatible with the one\n    computed a step at a time, elsewhere  */\n \n@@ -67,19 +124,20 @@ cpp_lookup (pfile, name, len, hash)\n \n   if (len < 0)\n     {\n-      for (bp = name; is_idchar[*bp]; bp++) ;\n+      for (bp = name; is_idchar[*bp]; bp++);\n       len = bp - name;\n     }\n \n   if (hash < 0)\n     hash = hashf (name, len, HASHSIZE);\n \n   bucket = hashtab[hash];\n-  while (bucket) {\n-    if (bucket->length == len && strncmp (bucket->name, name, len) == 0)\n-      return bucket;\n-    bucket = bucket->next;\n-  }\n+  while (bucket)\n+    {\n+      if (bucket->length == len && strncmp (bucket->name, name, len) == 0)\n+\treturn bucket;\n+      bucket = bucket->next;\n+    }\n   return (HASHNODE *) 0;\n }\n \n@@ -155,12 +213,13 @@ install (name, len, type, value, hash)\n   register int i, bucket;\n   register U_CHAR *p;\n \n-  if (len < 0) {\n-    p = name;\n-    while (is_idchar[*p])\n-      p++;\n-    len = p - name;\n-  }\n+  if (len < 0)\n+    {\n+      p = name;\n+      while (is_idchar[*p])\n+\tp++;\n+      len = p - name;\n+    }\n \n   if (hash < 0)\n     hash = hashf (name, len, HASHSIZE);\n@@ -188,9 +247,1426 @@ cpp_hash_cleanup (pfile)\n      cpp_reader *pfile ATTRIBUTE_UNUSED;\n {\n   register int i;\n-  for (i = HASHSIZE; --i >= 0; )\n+  for (i = HASHSIZE; --i >= 0;)\n     {\n       while (hashtab[i])\n \tdelete_macro (hashtab[i]);\n     }\n }\n+\n+static int\n+macro_cleanup (pbuf, pfile)\n+     cpp_buffer *pbuf;\n+     cpp_reader *pfile ATTRIBUTE_UNUSED;\n+{\n+  HASHNODE *macro = (HASHNODE *) pbuf->data;\n+  if (macro->type == T_DISABLED)\n+    macro->type = T_MACRO;\n+  if (macro->type != T_MACRO || pbuf->buf != macro->value.defn->expansion)\n+    free (pbuf->buf);\n+  return 0;\n+}\n+\n+\n+/* Read a replacement list for a macro with parameters.\n+   Build the DEFINITION structure.\n+   Reads characters of text starting at BUF until END.\n+   ARGLIST specifies the formal parameters to look for\n+   in the text of the definition; NARGS is the number of args\n+   in that list, or -1 for a macro name that wants no argument list.\n+   MACRONAME is the macro name itself (so we can avoid recursive expansion)\n+   and NAMELEN is its length in characters.\n+   \n+   Note that comments, backslash-newlines, and leading white space\n+   have already been deleted from the argument.  */\n+\n+static DEFINITION *\n+collect_expansion (pfile, buf, limit, nargs, arglist)\n+     cpp_reader *pfile;\n+     U_CHAR *buf, *limit;\n+     int nargs;\n+     struct arglist *arglist;\n+{\n+  DEFINITION *defn;\n+  register U_CHAR *p, *lastp, *exp_p;\n+  struct reflist *endpat = NULL;\n+  /* Pointer to first nonspace after last ## seen.  */\n+  U_CHAR *concat = 0;\n+  /* Pointer to first nonspace after last single-# seen.  */\n+  U_CHAR *stringify = 0;\n+  int maxsize;\n+  int expected_delimiter = '\\0';\n+\n+  /* Scan thru the replacement list, ignoring comments and quoted\n+     strings, picking up on the macro calls.  It does a linear search\n+     thru the arg list on every potential symbol.  Profiling might say\n+     that something smarter should happen.  */\n+\n+  if (limit < buf)\n+    abort ();\n+\n+  /* Find the beginning of the trailing whitespace.  */\n+  p = buf;\n+  while (p < limit && is_space[limit[-1]])\n+    limit--;\n+\n+  /* Allocate space for the text in the macro definition.\n+     Leading and trailing whitespace chars need 2 bytes each.\n+     Each other input char may or may not need 1 byte,\n+     so this is an upper bound.  The extra 5 are for invented\n+     leading and trailing newline-marker and final null.  */\n+  maxsize = (sizeof (DEFINITION)\n+\t     + (limit - p) + 5);\n+  /* Occurrences of '@' get doubled, so allocate extra space for them.  */\n+  while (p < limit)\n+    if (*p++ == '@')\n+      maxsize++;\n+  defn = (DEFINITION *) xcalloc (1, maxsize);\n+\n+  defn->nargs = nargs;\n+  exp_p = defn->expansion = (U_CHAR *) defn + sizeof (DEFINITION);\n+  lastp = exp_p;\n+\n+  p = buf;\n+\n+  /* Add one initial space escape-marker to prevent accidental\n+     token-pasting (often removed by macroexpand).  */\n+  *exp_p++ = '@';\n+  *exp_p++ = ' ';\n+\n+  if (limit - p >= 2 && p[0] == '#' && p[1] == '#')\n+    {\n+      cpp_error (pfile, \"`##' at start of macro definition\");\n+      p += 2;\n+    }\n+\n+  /* Process the main body of the definition.  */\n+  while (p < limit)\n+    {\n+      int skipped_arg = 0;\n+      register U_CHAR c = *p++;\n+\n+      *exp_p++ = c;\n+\n+      if (!CPP_TRADITIONAL (pfile))\n+\t{\n+\t  switch (c)\n+\t    {\n+\t    case '\\'':\n+\t    case '\\\"':\n+\t      if (expected_delimiter != '\\0')\n+\t\t{\n+\t\t  if (c == expected_delimiter)\n+\t\t    expected_delimiter = '\\0';\n+\t\t}\n+\t      else\n+\t\texpected_delimiter = c;\n+\t      break;\n+\n+\t    case '\\\\':\n+\t      if (p < limit && expected_delimiter)\n+\t\t{\n+\t\t  /* In a string, backslash goes through\n+\t\t     and makes next char ordinary.  */\n+\t\t  *exp_p++ = *p++;\n+\t\t}\n+\t      break;\n+\n+\t    case '@':\n+\t      /* An '@' in a string or character constant stands for itself,\n+\t         and does not need to be escaped.  */\n+\t      if (!expected_delimiter)\n+\t\t*exp_p++ = c;\n+\t      break;\n+\n+\t    case '#':\n+\t      /* # is ordinary inside a string.  */\n+\t      if (expected_delimiter)\n+\t\tbreak;\n+\t      if (p < limit && *p == '#')\n+\t\t{\n+\t\t  /* ##: concatenate preceding and following tokens.  */\n+\t\t  /* Take out the first #, discard preceding whitespace.  */\n+\t\t  exp_p--;\n+\t\t  while (exp_p > lastp && is_hor_space[exp_p[-1]])\n+\t\t    --exp_p;\n+\t\t  /* Skip the second #.  */\n+\t\t  p++;\n+\t\t  /* Discard following whitespace.  */\n+\t\t  SKIP_WHITE_SPACE (p);\n+\t\t  concat = p;\n+\t\t  if (p == limit)\n+\t\t    cpp_error (pfile, \"`##' at end of macro definition\");\n+\t\t}\n+\t      else if (nargs >= 0)\n+\t\t{\n+\t\t  /* Single #: stringify following argument ref.\n+\t\t     Don't leave the # in the expansion.  */\n+\t\t  exp_p--;\n+\t\t  SKIP_WHITE_SPACE (p);\n+\t\t  if (p == limit || !is_idstart[*p]\n+\t\t      || (*p == 'L' && p + 1 < limit && (p[1] == '\\'' ||\n+\t\t\t\t\t\t\t p[1] == '\"')))\n+\t\t    cpp_error (pfile,\n+\t\t\"`#' operator is not followed by a macro argument name\");\n+\t\t  else\n+\t\t    stringify = p;\n+\t\t}\n+\t      break;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* In -traditional mode, recognize arguments inside strings and\n+\t     character constants, and ignore special properties of #.\n+\t     Arguments inside strings are considered \"stringified\", but no\n+\t     extra quote marks are supplied.  */\n+\t  switch (c)\n+\t    {\n+\t    case '\\'':\n+\t    case '\\\"':\n+\t      if (expected_delimiter != '\\0')\n+\t\t{\n+\t\t  if (c == expected_delimiter)\n+\t\t    expected_delimiter = '\\0';\n+\t\t}\n+\t      else\n+\t\texpected_delimiter = c;\n+\t      break;\n+\n+\t    case '\\\\':\n+\t      /* Backslash quotes delimiters and itself,\n+\t\t but not macro args.  */\n+\t      if (expected_delimiter != 0 && p < limit\n+\t\t  && (*p == expected_delimiter || *p == '\\\\'))\n+\t\t{\n+\t\t  *exp_p++ = *p++;\n+\t\t  continue;\n+\t\t}\n+\t      break;\n+\n+\t    case '/':\n+\t      if (expected_delimiter != '\\0')\n+\t\t/* No comments inside strings.  */\n+\t\tbreak;\n+\t      if (*p == '*')\n+\t\t{\n+\t\t  /* If we find a comment that wasn't removed by\n+\t\t     handle_directive, this must be -traditional.\n+\t\t     So replace the comment with nothing at all.  */\n+\t\t  exp_p--;\n+\t\t  p += 1;\n+\t\t  while (p < limit && !(p[-2] == '*' && p[-1] == '/'))\n+\t\t    p++;\n+#if 0\n+\t\t  /* Mark this as a concatenation-point,\n+\t\t     as if it had been ##.  */\n+\t\t  concat = p;\n+#endif\n+\t\t}\n+\t      break;\n+\t    }\n+\t}\n+\n+      /* Handle the start of a symbol.  */\n+      if (is_idchar[c] && nargs > 0)\n+\t{\n+\t  U_CHAR *id_beg = p - 1;\n+\t  int id_len;\n+\n+\t  --exp_p;\n+\t  while (p != limit && is_idchar[*p])\n+\t    p++;\n+\t  id_len = p - id_beg;\n+\n+\t  if (is_idstart[c]\n+\t      && !(id_len == 1 && c == 'L' && (*p == '\\'' || *p == '\"')))\n+\t    {\n+\t      register struct arglist *arg;\n+\n+\t      for (arg = arglist; arg != NULL; arg = arg->next)\n+\t\t{\n+\t\t  struct reflist *tpat;\n+\n+\t\t  if (arg->name[0] == c\n+\t\t      && arg->length == id_len\n+\t\t      && strncmp (arg->name, id_beg, id_len) == 0)\n+\t\t    {\n+\t\t      if (expected_delimiter && CPP_OPTIONS\n+\t\t\t(pfile)->warn_stringify)\n+\t\t\t{\n+\t\t\t  if (CPP_TRADITIONAL (pfile))\n+\t\t\t    {\n+\t\t\t      cpp_warning (pfile,\n+\t\t\t\t       \"macro argument `%.*s' is stringified.\",\n+\t\t\t\t\t   id_len, arg->name);\n+\t\t\t    }\n+\t\t\t  else\n+\t\t\t    {\n+\t\t\t      cpp_warning (pfile,\n+\t\t    \"macro arg `%.*s' would be stringified with -traditional.\",\n+\t\t\t\t\t   id_len, arg->name);\n+\t\t\t    }\n+\t\t\t}\n+\t\t      /* If ANSI, don't actually substitute\n+\t\t\t inside a string.  */\n+\t\t      if (!CPP_TRADITIONAL (pfile) && expected_delimiter)\n+\t\t\tbreak;\n+\t\t      /* make a pat node for this arg and append it\n+\t\t\t to the end of the pat list */\n+\t\t      tpat = (struct reflist *)\n+\t\t\txmalloc (sizeof (struct reflist));\n+\t\t      tpat->next = NULL;\n+\t\t      tpat->raw_before = concat == id_beg;\n+\t\t      tpat->raw_after = 0;\n+\t\t      tpat->rest_args = arg->rest_args;\n+\t\t      tpat->stringify = (CPP_TRADITIONAL (pfile)\n+\t\t\t\t\t ? expected_delimiter != '\\0'\n+\t\t\t\t\t : stringify == id_beg);\n+\n+\t\t      if (endpat == NULL)\n+\t\t\tdefn->pattern = tpat;\n+\t\t      else\n+\t\t\tendpat->next = tpat;\n+\t\t      endpat = tpat;\n+\n+\t\t      tpat->argno = arg->argno;\n+\t\t      tpat->nchars = exp_p - lastp;\n+\t\t      {\n+\t\t\tregister U_CHAR *p1 = p;\n+\t\t\tSKIP_WHITE_SPACE (p1);\n+\t\t\tif (p1 + 2 <= limit && p1[0] == '#' && p1[1] == '#')\n+\t\t\t  tpat->raw_after = 1;\n+\t\t      }\n+\t\t      lastp = exp_p;\n+\t\t      skipped_arg = 1;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t    }\n+\n+\t  /* If this was not a macro arg, copy it into the expansion.  */\n+\t  if (!skipped_arg)\n+\t    {\n+\t      register U_CHAR *lim1 = p;\n+\t      p = id_beg;\n+\t      while (p != lim1)\n+\t\t*exp_p++ = *p++;\n+\t      if (stringify == id_beg)\n+\t\tcpp_error (pfile,\n+\t\t\"`#' operator should be followed by a macro argument name\");\n+\t    }\n+\t}\n+    }\n+\n+  if (!CPP_TRADITIONAL (pfile) && expected_delimiter == 0)\n+    {\n+      /* If ANSI, put in a \"@ \" marker to prevent token pasting.\n+         But not if \"inside a string\" (which in ANSI mode\n+         happens only for -D option).  */\n+      *exp_p++ = '@';\n+      *exp_p++ = ' ';\n+    }\n+\n+  *exp_p = '\\0';\n+\n+  defn->length = exp_p - defn->expansion;\n+\n+  /* Crash now if we overrun the allocated size.  */\n+  if (defn->length + 1 > maxsize)\n+    abort ();\n+\n+#if 0\n+/* This isn't worth the time it takes.  */\n+  /* give back excess storage */\n+  defn->expansion = (U_CHAR *) xrealloc (defn->expansion, defn->length + 1);\n+#endif\n+\n+  return defn;\n+}\n+\n+/*\n+ * special extension string that can be added to the last macro argument to \n+ * allow it to absorb the \"rest\" of the arguments when expanded.  Ex:\n+ * \t\t#define wow(a, b...)\t\tprocess (b, a, b)\n+ *\t\t{ wow (1, 2, 3); }\t->\t{ process (2, 3, 1, 2, 3); }\n+ *\t\t{ wow (one, two); }\t->\t{ process (two, one, two); }\n+ * if this \"rest_arg\" is used with the concat token '##' and if it is not\n+ * supplied then the token attached to with ## will not be outputted.  Ex:\n+ * \t\t#define wow (a, b...)\t\tprocess (b ## , a, ## b)\n+ *\t\t{ wow (1, 2); }\t\t->\t{ process (2, 1, 2); }\n+ *\t\t{ wow (one); }\t\t->\t{ process (one); {\n+ */\n+static char rest_extension[] = \"...\";\n+#define REST_EXTENSION_LENGTH\t(sizeof (rest_extension) - 1)\n+\n+/* Create a DEFINITION node from a #define directive.  Arguments are \n+   as for do_define.  */\n+\n+MACRODEF\n+create_definition (buf, limit, pfile, predefinition)\n+     U_CHAR *buf, *limit;\n+     cpp_reader *pfile;\n+     int predefinition;\n+{\n+  U_CHAR *bp;\t\t\t/* temp ptr into input buffer */\n+  U_CHAR *symname;\t\t/* remember where symbol name starts */\n+  int sym_length;\t\t/* and how long it is */\n+  int rest_args = 0;\n+  long line, col;\n+  char *file = CPP_BUFFER (pfile) ? CPP_BUFFER (pfile)->nominal_fname : \"\";\n+  DEFINITION *defn;\n+  int arglengths = 0;\t\t/* Accumulate lengths of arg names\n+\t\t\t\t   plus number of args.  */\n+  MACRODEF mdef;\n+  cpp_buf_line_and_col (CPP_BUFFER (pfile), &line, &col);\n+\n+  bp = buf;\n+\n+  while (is_hor_space[*bp])\n+    bp++;\n+\n+  symname = bp;\t\t\t/* remember where it starts */\n+\n+  sym_length = check_macro_name (pfile, bp, 0);\n+  bp += sym_length;\n+\n+  /* Lossage will occur if identifiers or control keywords are broken\n+     across lines using backslash.  This is not the right place to take\n+     care of that.  */\n+\n+  if (*bp == '(')\n+    {\n+      struct arglist *arg_ptrs = NULL;\n+      int argno = 0;\n+\n+      bp++;\t\t\t/* skip '(' */\n+      SKIP_WHITE_SPACE (bp);\n+\n+      /* Loop over macro argument names.  */\n+      while (*bp != ')')\n+\t{\n+\t  struct arglist *temp;\n+\n+\t  temp = (struct arglist *) alloca (sizeof (struct arglist));\n+\t  temp->name = bp;\n+\t  temp->next = arg_ptrs;\n+\t  temp->argno = argno++;\n+\t  temp->rest_args = 0;\n+\t  arg_ptrs = temp;\n+\n+\t  if (rest_args)\n+\t    cpp_pedwarn (pfile, \"another parameter follows `%s'\",\n+\t\t\t rest_extension);\n+\n+\t  if (!is_idstart[*bp])\n+\t    cpp_pedwarn (pfile, \"invalid character in macro parameter name\");\n+\n+\t  /* Find the end of the arg name.  */\n+\t  while (is_idchar[*bp])\n+\t    {\n+\t      bp++;\n+\t      /* do we have a \"special\" rest-args extension here? */\n+\t      if ((size_t) (limit - bp) > REST_EXTENSION_LENGTH\n+\t\t  && !strncmp (rest_extension, bp, REST_EXTENSION_LENGTH))\n+\t\t{\n+\t\t  rest_args = 1;\n+\t\t  temp->rest_args = 1;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t  temp->length = bp - temp->name;\n+\t  if (rest_args == 1)\n+\t    bp += REST_EXTENSION_LENGTH;\n+\t  arglengths += temp->length + 2;\n+\t  SKIP_WHITE_SPACE (bp);\n+\t  if (temp->length == 0 || (*bp != ',' && *bp != ')'))\n+\t    {\n+\t      cpp_error (pfile,\n+\t\t\t \"badly punctuated parameter list in `#define'\");\n+\t      goto nope;\n+\t    }\n+\t  if (*bp == ',')\n+\t    {\n+\t      bp++;\n+\t      SKIP_WHITE_SPACE (bp);\n+\t    }\n+\t  if (bp >= limit)\n+\t    {\n+\t      cpp_error (pfile, \"unterminated parameter list in `#define'\");\n+\t      goto nope;\n+\t    }\n+\t  {\n+\t    struct arglist *otemp;\n+\n+\t    for (otemp = temp->next; otemp != NULL; otemp = otemp->next)\n+\t      if (temp->length == otemp->length\n+\t\t  && strncmp (temp->name, otemp->name, temp->length) == 0)\n+\t\t{\n+\t\t  U_CHAR *name;\n+\n+\t\t  name = (U_CHAR *) alloca (temp->length + 1);\n+\t\t  (void) strncpy (name, temp->name, temp->length);\n+\t\t  name[temp->length] = '\\0';\n+\t\t  cpp_error (pfile,\n+\t\t\t     \"duplicate argument name `%s' in `#define'\",\n+\t\t\t     name);\n+\t\t  goto nope;\n+\t\t}\n+\t  }\n+\t}\n+\n+      ++bp;\t\t\t/* skip paren */\n+      SKIP_WHITE_SPACE (bp);\n+      /* now everything from bp before limit is the definition.  */\n+      defn = collect_expansion (pfile, bp, limit, argno, arg_ptrs);\n+      defn->rest_args = rest_args;\n+\n+      /* Now set defn->args.argnames to the result of concatenating\n+         the argument names in reverse order\n+         with comma-space between them.  */\n+      defn->args.argnames = (U_CHAR *) xmalloc (arglengths + 1);\n+      {\n+\tstruct arglist *temp;\n+\tint i = 0;\n+\tfor (temp = arg_ptrs; temp; temp = temp->next)\n+\t  {\n+\t    bcopy (temp->name, &defn->args.argnames[i], temp->length);\n+\t    i += temp->length;\n+\t    if (temp->next != 0)\n+\t      {\n+\t\tdefn->args.argnames[i++] = ',';\n+\t\tdefn->args.argnames[i++] = ' ';\n+\t      }\n+\t  }\n+\tdefn->args.argnames[i] = 0;\n+      }\n+    }\n+  else\n+    {\n+      /* Simple expansion or empty definition.  */\n+\n+      if (bp < limit)\n+\t{\n+\t  if (is_hor_space[*bp])\n+\t    {\n+\t      bp++;\n+\t      SKIP_WHITE_SPACE (bp);\n+\t    }\n+\t  else\n+\t    /* Per C9x, missing white space after the name in a #define\n+\t       of an object-like macro is always a constraint violation. */\n+\t    cpp_pedwarn (pfile,\n+\t\t\t \"missing white space after `#define %.*s'\",\n+\t\t\t sym_length, symname);\n+\t}\n+      /* now everything from bp before limit is the definition.  */\n+      defn = collect_expansion (pfile, bp, limit, -1, NULL_PTR);\n+      defn->args.argnames = (U_CHAR *) \"\";\n+    }\n+\n+  defn->line = line;\n+  defn->file = file;\n+\n+  /* OP is null if this is a predefinition */\n+  defn->predefined = predefinition;\n+  mdef.defn = defn;\n+  mdef.symnam = symname;\n+  mdef.symlen = sym_length;\n+\n+  return mdef;\n+\n+nope:\n+  mdef.defn = 0;\n+  return mdef;\n+}\n+\n+/*\n+ * Parse a macro argument and append the info on PFILE's token_buffer.\n+ * REST_ARGS means to absorb the rest of the args.\n+ * Return nonzero to indicate a syntax error.\n+ */\n+\n+static enum cpp_token\n+macarg (pfile, rest_args)\n+     cpp_reader *pfile;\n+     int rest_args;\n+{\n+  int paren = 0;\n+  enum cpp_token token;\n+  char save_put_out_comments = CPP_OPTIONS (pfile)->put_out_comments;\n+  CPP_OPTIONS (pfile)->put_out_comments = 0;\n+\n+  /* Try to parse as much of the argument as exists at this\n+     input stack level.  */\n+  pfile->no_macro_expand++;\n+  for (;;)\n+    {\n+      token = cpp_get_token (pfile);\n+      switch (token)\n+\t{\n+\tcase CPP_EOF:\n+\t  goto done;\n+\tcase CPP_POP:\n+\t  /* If we've hit end of file, it's an error (reported by caller).\n+\t     Ditto if it's the end of cpp_expand_to_buffer text.\n+\t     If we've hit end of macro, just continue.  */\n+\t  if (!CPP_IS_MACRO_BUFFER (CPP_BUFFER (pfile)))\n+\t    goto done;\n+\t  break;\n+\tcase CPP_LPAREN:\n+\t  paren++;\n+\t  break;\n+\tcase CPP_RPAREN:\n+\t  if (--paren < 0)\n+\t    goto found;\n+\t  break;\n+\tcase CPP_COMMA:\n+\t  /* if we've returned to lowest level and\n+\t     we aren't absorbing all args */\n+\t  if (paren == 0 && rest_args == 0)\n+\t    goto found;\n+\t  break;\n+\tfound:\n+\t  /* Remove ',' or ')' from argument buffer.  */\n+\t  CPP_ADJUST_WRITTEN (pfile, -1);\n+\t  goto done;\n+\tdefault:;\n+\t}\n+    }\n+\n+done:\n+  CPP_OPTIONS (pfile)->put_out_comments = save_put_out_comments;\n+  pfile->no_macro_expand--;\n+\n+  return token;\n+}\n+\f\n+/* Turn newlines to spaces in the string of length LENGTH at START,\n+   except inside of string constants.\n+   The string is copied into itself with its beginning staying fixed.  */\n+\n+static int\n+change_newlines (start, length)\n+     U_CHAR *start;\n+     int length;\n+{\n+  register U_CHAR *ibp;\n+  register U_CHAR *obp;\n+  register U_CHAR *limit;\n+  register int c;\n+\n+  ibp = start;\n+  limit = start + length;\n+  obp = start;\n+\n+  while (ibp < limit)\n+    {\n+      *obp++ = c = *ibp++;\n+      switch (c)\n+\t{\n+\n+\tcase '\\'':\n+\tcase '\\\"':\n+\t  /* Notice and skip strings, so that we don't\n+\t     delete newlines in them.  */\n+\t  {\n+\t    int quotec = c;\n+\t    while (ibp < limit)\n+\t      {\n+\t\t*obp++ = c = *ibp++;\n+\t\tif (c == quotec)\n+\t\t  break;\n+\t\tif (c == '\\n' && quotec == '\\'')\n+\t\t  break;\n+\t      }\n+\t  }\n+\t  break;\n+\t}\n+    }\n+\n+  return obp - start;\n+}\n+\f\n+\n+static struct tm *\n+timestamp (pfile)\n+     cpp_reader *pfile;\n+{\n+  if (!pfile->timebuf)\n+    {\n+      time_t t = time ((time_t *) 0);\n+      pfile->timebuf = localtime (&t);\n+    }\n+  return pfile->timebuf;\n+}\n+\n+static char *monthnames[] =\n+{\n+  \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n+  \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\",\n+};\n+\n+/*\n+ * expand things like __FILE__.  Place the expansion into the output\n+ * buffer *without* rescanning.\n+ */\n+\n+static void\n+special_symbol (hp, pfile)\n+     HASHNODE *hp;\n+     cpp_reader *pfile;\n+{\n+  const char *buf;\n+  int len;\n+  cpp_buffer *ip;\n+\n+  switch (hp->type)\n+    {\n+    case T_FILE:\n+    case T_BASE_FILE:\n+      {\n+\tip = CPP_BUFFER (pfile);\n+\tif (hp->type == T_BASE_FILE)\n+\t  {\n+\t    while (CPP_PREV_BUFFER (ip) != CPP_NULL_BUFFER (pfile))\n+\t      ip = CPP_PREV_BUFFER (ip);\n+\t  }\n+\telse\n+\t  {\n+\t    ip = CPP_BUFFER (pfile);\n+\t    while (!ip->nominal_fname && ip != CPP_NULL_BUFFER (pfile))\n+\t      ip = CPP_PREV_BUFFER (ip);\n+\t  }\n+\n+\tbuf = ip->nominal_fname;\n+\n+\tif (!buf)\n+\t  buf = \"\";\n+\tCPP_RESERVE (pfile, 3 + 4 * strlen (buf));\n+\tquote_string (pfile, buf);\n+\treturn;\n+      }\n+\n+    case T_INCLUDE_LEVEL:\n+      {\n+\tint true_indepth = 0;\n+\tip = CPP_BUFFER (pfile);\n+\tfor (; ip != CPP_NULL_BUFFER (pfile); ip = CPP_PREV_BUFFER (ip))\n+\t  if (ip->fname != NULL)\n+\t    true_indepth++;\n+\n+\tCPP_RESERVE (pfile, 10);\n+\tsprintf (CPP_PWRITTEN (pfile), \"%d\", true_indepth);\n+\tCPP_ADJUST_WRITTEN (pfile, strlen (CPP_PWRITTEN (pfile)));\n+\treturn;\n+      }\n+\n+    case T_VERSION:\n+      len = strlen (version_string);\n+      CPP_RESERVE (pfile, 3 + len);\n+      CPP_PUTC_Q (pfile, '\"');\n+      CPP_PUTS_Q (pfile, version_string, len);\n+      CPP_PUTC_Q (pfile, '\"');\n+      CPP_NUL_TERMINATE_Q (pfile);\n+      return;\n+\n+    case T_CONST:\n+      buf = hp->value.cpval;\n+      if (!buf)\n+\treturn;\n+      if (*buf == '\\0')\n+\tbuf = \"@ \";\n+\n+      len = strlen (buf);\n+      CPP_RESERVE (pfile, len + 1);\n+      CPP_PUTS_Q (pfile, buf, len);\n+      CPP_NUL_TERMINATE_Q (pfile);\n+      return;\n+\n+    case T_STDC:\n+      CPP_RESERVE (pfile, 2);\n+#ifdef STDC_0_IN_SYSTEM_HEADERS\n+      ip = CPP_BUFFER (pfile);\n+      while (!ip->nominal_fname && ip != CPP_NULL_BUFFER (pfile))\n+\tip = CPP_PREV_BUFFER (ip);\n+      if (ip->system_header_p\n+\t  && !cpp_lookup (pfile, (U_CHAR *) \"__STRICT_ANSI__\", 15, -1))\n+\tCPP_PUTC_Q (pfile, '0');\n+      else\n+#endif\n+\tCPP_PUTC_Q (pfile, '1');\n+      CPP_NUL_TERMINATE_Q (pfile);\n+      return;\n+\n+    case T_SPECLINE:\n+      {\n+\tlong line;\n+\tcpp_buf_line_and_col (CPP_BUFFER (pfile), &line, NULL);\n+\n+\tCPP_RESERVE (pfile, 10);\n+\tsprintf (CPP_PWRITTEN (pfile), \"%ld\", line);\n+\tCPP_ADJUST_WRITTEN (pfile, strlen (CPP_PWRITTEN (pfile)));\n+\treturn;\n+      }\n+\n+    case T_DATE:\n+    case T_TIME:\n+      {\n+\tstruct tm *timebuf;\n+\n+\tCPP_RESERVE (pfile, 20);\n+\ttimebuf = timestamp (pfile);\n+\tif (hp->type == T_DATE)\n+\t  sprintf (CPP_PWRITTEN (pfile), \"\\\"%s %2d %4d\\\"\",\n+\t\t   monthnames[timebuf->tm_mon],\n+\t\t   timebuf->tm_mday, timebuf->tm_year + 1900);\n+\telse\n+\t  sprintf (CPP_PWRITTEN (pfile), \"\\\"%02d:%02d:%02d\\\"\",\n+\t\t   timebuf->tm_hour, timebuf->tm_min, timebuf->tm_sec);\n+\n+\tCPP_ADJUST_WRITTEN (pfile, strlen (CPP_PWRITTEN (pfile)));\n+\treturn;\n+      }\n+\n+    default:\n+      cpp_fatal (pfile, \"cpplib internal error: invalid special hash type\");\n+      return;\n+    }\n+\n+  /* This point should be unreachable. */\n+  abort ();\n+}\n+\n+/* Expand a macro call.\n+   HP points to the symbol that is the macro being called.\n+   Put the result of expansion onto the input stack\n+   so that subsequent input by our caller will use it.\n+\n+   If macro wants arguments, caller has already verified that\n+   an argument list follows; arguments come from the input stack.  */\n+\n+void\n+macroexpand (pfile, hp)\n+     cpp_reader *pfile;\n+     HASHNODE *hp;\n+{\n+  int nargs;\n+  DEFINITION *defn;\n+  register U_CHAR *xbuf;\n+  long start_line, start_column;\n+  int xbuf_len;\n+  struct argdata *args;\n+  long old_written = CPP_WRITTEN (pfile);\n+#if 0\n+  int start_line = instack[indepth].lineno;\n+#endif\n+  int rest_args, rest_zero;\n+  register int i;\n+\n+#if 0\n+  /* This macro is being used inside a #if, which means it must be */\n+  /* recorded as a precondition.  */\n+  if (pcp_inside_if && pcp_outfile && defn->predefined)\n+    dump_single_macro (hp, pcp_outfile);\n+#endif\n+\n+  cpp_buf_line_and_col (cpp_file_buffer (pfile), &start_line, &start_column);\n+\n+  /* Check for and handle special symbols. */\n+  if (hp->type != T_MACRO)\n+    {\n+      special_symbol (hp, pfile);\n+      xbuf_len = CPP_WRITTEN (pfile) - old_written;\n+      xbuf = (U_CHAR *) xmalloc (xbuf_len + 1);\n+      CPP_SET_WRITTEN (pfile, old_written);\n+      bcopy (CPP_PWRITTEN (pfile), xbuf, xbuf_len + 1);\n+      push_macro_expansion (pfile, xbuf, xbuf_len, hp);\n+      CPP_BUFFER (pfile)->has_escapes = 1;\n+      return;\n+    }\n+\n+  defn = hp->value.defn;\n+  nargs = defn->nargs;\n+  pfile->output_escapes++;\n+\n+  if (nargs >= 0)\n+    {\n+      enum cpp_token token;\n+\n+      args = (struct argdata *) alloca ((nargs + 1) * sizeof (struct argdata));\n+\n+      for (i = 0; i < nargs; i++)\n+\t{\n+\t  args[i].raw = args[i].expanded = 0;\n+\t  args[i].raw_length = 0;\n+\t  args[i].expand_length = args[i].stringified_length = -1;\n+\t  args[i].use_count = 0;\n+\t}\n+\n+      /* Parse all the macro args that are supplied.  I counts them.\n+         The first NARGS args are stored in ARGS.\n+         The rest are discarded.  If rest_args is set then we assume\n+         macarg absorbed the rest of the args.  */\n+      i = 0;\n+      rest_args = 0;\n+      rest_args = 0;\n+      FORWARD (1);\t/* Discard open-parenthesis before first arg.  */\n+      do\n+\t{\n+\t  if (rest_args)\n+\t    continue;\n+\t  if (i < nargs || (nargs == 0 && i == 0))\n+\t    {\n+\t      /* if we are working on last arg which absorbs rest of args... */\n+\t      if (i == nargs - 1 && defn->rest_args)\n+\t\trest_args = 1;\n+\t      args[i].raw = CPP_WRITTEN (pfile);\n+\t      token = macarg (pfile, rest_args);\n+\t      args[i].raw_length = CPP_WRITTEN (pfile) - args[i].raw;\n+\t      args[i].newlines = 0;\t/* FIXME */\n+\t    }\n+\t  else\n+\t    token = macarg (pfile, 0);\n+\t  if (token == CPP_EOF || token == CPP_POP)\n+\t    {\n+\t      cpp_error_with_line (pfile, start_line, start_column,\n+\t\t\t\t   \"unterminated macro call\");\n+\t      return;\n+\t    }\n+\t  i++;\n+\t}\n+      while (token == CPP_COMMA);\n+\n+      /* If we got one arg but it was just whitespace, call that 0 args.  */\n+      if (i == 1)\n+\t{\n+\t  register U_CHAR *bp = ARG_BASE + args[0].raw;\n+\t  register U_CHAR *lim = bp + args[0].raw_length;\n+\t  /* cpp.texi says for foo ( ) we provide one argument.\n+\t     However, if foo wants just 0 arguments, treat this as 0.  */\n+\t  if (nargs == 0)\n+\t    while (bp != lim && is_space[*bp])\n+\t      bp++;\n+\t  if (bp == lim)\n+\t    i = 0;\n+\t}\n+\n+      /* Don't output an error message if we have already output one for\n+         a parse error above.  */\n+      rest_zero = 0;\n+      if (nargs == 0 && i > 0)\n+\t{\n+\t  cpp_error (pfile, \"arguments given to macro `%s'\", hp->name);\n+\t}\n+      else if (i < nargs)\n+\t{\n+\t  /* traditional C allows foo() if foo wants one argument.  */\n+\t  if (nargs == 1 && i == 0 && CPP_TRADITIONAL (pfile))\n+\t    ;\n+\t  /* the rest args token is allowed to absorb 0 tokens */\n+\t  else if (i == nargs - 1 && defn->rest_args)\n+\t    rest_zero = 1;\n+\t  else if (i == 0)\n+\t    cpp_error (pfile, \"macro `%s' used without args\", hp->name);\n+\t  else if (i == 1)\n+\t    cpp_error (pfile, \"macro `%s' used with just one arg\", hp->name);\n+\t  else\n+\t    cpp_error (pfile, \"macro `%s' used with only %d args\",\n+\t\t       hp->name, i);\n+\t}\n+      else if (i > nargs)\n+\t{\n+\t  cpp_error (pfile,\n+\t\t     \"macro `%s' used with too many (%d) args\", hp->name, i);\n+\t}\n+    }\n+\n+  /* If macro wants zero args, we parsed the arglist for checking only.\n+     Read directly from the macro definition.  */\n+  if (nargs <= 0)\n+    {\n+      xbuf = defn->expansion;\n+      xbuf_len = defn->length;\n+    }\n+  else\n+    {\n+      register U_CHAR *exp = defn->expansion;\n+      register int offset;\t/* offset in expansion,\n+\t\t\t\t   copied a piece at a time */\n+      register int totlen;\t/* total amount of exp buffer filled so far */\n+\n+      register struct reflist *ap, *last_ap;\n+\n+      /* Macro really takes args.  Compute the expansion of this call.  */\n+\n+      /* Compute length in characters of the macro's expansion.\n+         Also count number of times each arg is used.  */\n+      xbuf_len = defn->length;\n+      for (ap = defn->pattern; ap != NULL; ap = ap->next)\n+\t{\n+\t  if (ap->stringify)\n+\t    {\n+\t      register struct argdata *arg = &args[ap->argno];\n+\t      /* Stringify if it hasn't already been */\n+\t      if (arg->stringified_length < 0)\n+\t\t{\n+\t\t  int arglen = arg->raw_length;\n+\t\t  int escaped = 0;\n+\t\t  int in_string = 0;\n+\t\t  int c;\n+\t\t  /* Initially need_space is -1.  Otherwise, 1 means the\n+\t\t     previous character was a space, but we suppressed it;\n+\t\t     0 means the previous character was a non-space.  */\n+\t\t  int need_space = -1;\n+\t\t  i = 0;\n+\t\t  arg->stringified = CPP_WRITTEN (pfile);\n+\t\t  if (!CPP_TRADITIONAL (pfile))\n+\t\t    CPP_PUTC (pfile, '\\\"');\t/* insert beginning quote */\n+\t\t  for (; i < arglen; i++)\n+\t\t    {\n+\t\t      c = (ARG_BASE + arg->raw)[i];\n+\n+\t\t      if (!in_string)\n+\t\t\t{\n+\t\t\t  /* Internal sequences of whitespace are\n+\t\t\t     replaced by one space except within\n+\t\t\t     a string or char token. */\n+\t\t\t  if (is_space[c])\n+\t\t\t    {\n+\t\t\t      if (CPP_WRITTEN (pfile) > (unsigned) arg->stringified\n+\t\t\t\t  && (CPP_PWRITTEN (pfile))[-1] == '@')\n+\t\t\t\t{\n+\t\t\t\t  /* \"@ \" escape markers are removed */\n+\t\t\t\t  CPP_ADJUST_WRITTEN (pfile, -1);\n+\t\t\t\t  continue;\n+\t\t\t\t}\n+\t\t\t      if (need_space == 0)\n+\t\t\t\tneed_space = 1;\n+\t\t\t      continue;\n+\t\t\t    }\n+\t\t\t  else if (need_space > 0)\n+\t\t\t    CPP_PUTC (pfile, ' ');\n+\t\t\t  need_space = 0;\n+\t\t\t}\n+\n+\t\t      if (escaped)\n+\t\t\tescaped = 0;\n+\t\t      else\n+\t\t\t{\n+\t\t\t  if (c == '\\\\')\n+\t\t\t    escaped = 1;\n+\t\t\t  if (in_string)\n+\t\t\t    {\n+\t\t\t      if (c == in_string)\n+\t\t\t\tin_string = 0;\n+\t\t\t    }\n+\t\t\t  else if (c == '\\\"' || c == '\\'')\n+\t\t\t    in_string = c;\n+\t\t\t}\n+\n+\t\t      /* Escape these chars */\n+\t\t      if (c == '\\\"' || (in_string && c == '\\\\'))\n+\t\t\tCPP_PUTC (pfile, '\\\\');\n+\t\t      if (ISPRINT (c))\n+\t\t\tCPP_PUTC (pfile, c);\n+\t\t      else\n+\t\t\t{\n+\t\t\t  CPP_RESERVE (pfile, 4);\n+\t\t\t  sprintf ((char *) CPP_PWRITTEN (pfile), \"\\\\%03o\",\n+\t\t\t\t   (unsigned int) c);\n+\t\t\t  CPP_ADJUST_WRITTEN (pfile, 4);\n+\t\t\t}\n+\t\t    }\n+\t\t  if (!CPP_TRADITIONAL (pfile))\n+\t\t    CPP_PUTC (pfile, '\\\"');\t/* insert ending quote */\n+\t\t  arg->stringified_length\n+\t\t    = CPP_WRITTEN (pfile) - arg->stringified;\n+\t\t}\n+\t      xbuf_len += args[ap->argno].stringified_length;\n+\t    }\n+\t  else if (ap->raw_before || ap->raw_after || CPP_TRADITIONAL (pfile))\n+\t    /* Add 4 for two newline-space markers to prevent\n+\t       token concatenation.  */\n+\t    xbuf_len += args[ap->argno].raw_length + 4;\n+\t  else\n+\t    {\n+\t      /* We have an ordinary (expanded) occurrence of the arg.\n+\t         So compute its expansion, if we have not already.  */\n+\t      if (args[ap->argno].expand_length < 0)\n+\t\t{\n+\t\t  args[ap->argno].expanded = CPP_WRITTEN (pfile);\n+\t\t  cpp_expand_to_buffer (pfile,\n+\t\t\t\t\tARG_BASE + args[ap->argno].raw,\n+\t\t\t\t\targs[ap->argno].raw_length);\n+\n+\t\t  args[ap->argno].expand_length\n+\t\t    = CPP_WRITTEN (pfile) - args[ap->argno].expanded;\n+\t\t}\n+\n+\t      /* Add 4 for two newline-space markers to prevent\n+\t         token concatenation.  */\n+\t      xbuf_len += args[ap->argno].expand_length + 4;\n+\t    }\n+\t  if (args[ap->argno].use_count < 10)\n+\t    args[ap->argno].use_count++;\n+\t}\n+\n+      xbuf = (U_CHAR *) xmalloc (xbuf_len + 1);\n+\n+      /* Generate in XBUF the complete expansion\n+         with arguments substituted in.\n+         TOTLEN is the total size generated so far.\n+         OFFSET is the index in the definition\n+         of where we are copying from.  */\n+      offset = totlen = 0;\n+      for (last_ap = NULL, ap = defn->pattern; ap != NULL;\n+\t   last_ap = ap, ap = ap->next)\n+\t{\n+\t  register struct argdata *arg = &args[ap->argno];\n+\t  int count_before = totlen;\n+\n+\t  /* Add chars to XBUF.  */\n+\t  for (i = 0; i < ap->nchars; i++, offset++)\n+\t    xbuf[totlen++] = exp[offset];\n+\n+\t  /* If followed by an empty rest arg with concatenation,\n+\t     delete the last run of nonwhite chars.  */\n+\t  if (rest_zero && totlen > count_before\n+\t      && ((ap->rest_args && ap->raw_before)\n+\t\t  || (last_ap != NULL && last_ap->rest_args\n+\t\t      && last_ap->raw_after)))\n+\t    {\n+\t      /* Delete final whitespace.  */\n+\t      while (totlen > count_before && is_space[xbuf[totlen - 1]])\n+\t\ttotlen--;\n+\n+\t      /* Delete the nonwhites before them.  */\n+\t      while (totlen > count_before && !is_space[xbuf[totlen - 1]])\n+\t\ttotlen--;\n+\t    }\n+\n+\t  if (ap->stringify != 0)\n+\t    {\n+\t      bcopy (ARG_BASE + arg->stringified,\n+\t\t     xbuf + totlen, arg->stringified_length);\n+\t      totlen += arg->stringified_length;\n+\t    }\n+\t  else if (ap->raw_before || ap->raw_after || CPP_TRADITIONAL (pfile))\n+\t    {\n+\t      U_CHAR *p1 = ARG_BASE + arg->raw;\n+\t      U_CHAR *l1 = p1 + arg->raw_length;\n+\t      if (ap->raw_before)\n+\t\t{\n+\t\t  while (p1 != l1 && is_space[*p1])\n+\t\t    p1++;\n+\t\t  while (p1 != l1 && is_idchar[*p1])\n+\t\t    xbuf[totlen++] = *p1++;\n+\t\t}\n+\t      if (ap->raw_after)\n+\t\t{\n+\t\t  /* Arg is concatenated after: delete trailing whitespace,\n+\t\t     whitespace markers, and no-reexpansion markers.  */\n+\t\t  while (p1 != l1)\n+\t\t    {\n+\t\t      if (is_space[l1[-1]])\n+\t\t\tl1--;\n+\t\t      else if (l1[-1] == '@')\n+\t\t\t{\n+\t\t\t  U_CHAR *p2 = l1 - 1;\n+\t\t\t  /* If whitespace is preceded by an odd number\n+\t\t\t     of `@' signs, the last `@' was a whitespace\n+\t\t\t     marker; drop it too. */\n+\t\t\t  while (p2 != p1 && p2[0] == '@')\n+\t\t\t    p2--;\n+\t\t\t  if ((l1 - p2) & 1)\n+\t\t\t    l1--;\n+\t\t\t  break;\n+\t\t\t}\n+\t\t      else if (l1[-1] == '-')\n+\t\t\t{\n+\t\t\t  U_CHAR *p2 = l1 - 1;\n+\t\t\t  /* If a `-' is preceded by an odd number of\n+\t\t\t     `@' signs then it and the last `@' are\n+\t\t\t     a no-reexpansion marker.  */\n+\t\t\t  while (p2 != p1 && p2[0] == '@')\n+\t\t\t    p2--;\n+\t\t\t  if ((l1 - p2) & 1)\n+\t\t\t    l1 -= 2;\n+\t\t\t  else\n+\t\t\t    break;\n+\t\t\t}\n+\t\t      else\n+\t\t\tbreak;\n+\t\t    }\n+\t\t}\n+\n+\t      /* Delete any no-reexpansion marker that precedes\n+\t         an identifier at the beginning of the argument. */\n+\t      if (p1[0] == '@' && p1[1] == '-')\n+\t\tp1 += 2;\n+\n+\t      bcopy (p1, xbuf + totlen, l1 - p1);\n+\t      totlen += l1 - p1;\n+\t    }\n+\t  else\n+\t    {\n+\t      U_CHAR *expanded = ARG_BASE + arg->expanded;\n+\t      if (!ap->raw_before && totlen > 0 && arg->expand_length\n+\t\t  && !CPP_TRADITIONAL (pfile)\n+\t\t  && unsafe_chars (xbuf[totlen - 1], expanded[0]))\n+\t\t{\n+\t\t  xbuf[totlen++] = '@';\n+\t\t  xbuf[totlen++] = ' ';\n+\t\t}\n+\n+\t      bcopy (expanded, xbuf + totlen, arg->expand_length);\n+\t      totlen += arg->expand_length;\n+\n+\t      if (!ap->raw_after && totlen > 0 && offset < defn->length\n+\t\t  && !CPP_TRADITIONAL (pfile)\n+\t\t  && unsafe_chars (xbuf[totlen - 1], exp[offset]))\n+\t\t{\n+\t\t  xbuf[totlen++] = '@';\n+\t\t  xbuf[totlen++] = ' ';\n+\t\t}\n+\n+\t      /* If a macro argument with newlines is used multiple times,\n+\t         then only expand the newlines once.  This avoids creating\n+\t         output lines which don't correspond to any input line,\n+\t         which confuses gdb and gcov.  */\n+\t      if (arg->use_count > 1 && arg->newlines > 0)\n+\t\t{\n+\t\t  /* Don't bother doing change_newlines for subsequent\n+\t\t     uses of arg.  */\n+\t\t  arg->use_count = 1;\n+\t\t  arg->expand_length\n+\t\t    = change_newlines (expanded, arg->expand_length);\n+\t\t}\n+\t    }\n+\n+\t  if (totlen > xbuf_len)\n+\t    abort ();\n+\t}\n+\n+      /* if there is anything left of the definition\n+         after handling the arg list, copy that in too.  */\n+\n+      for (i = offset; i < defn->length; i++)\n+\t{\n+\t  /* if we've reached the end of the macro */\n+\t  if (exp[i] == ')')\n+\t    rest_zero = 0;\n+\t  if (!(rest_zero && last_ap != NULL && last_ap->rest_args\n+\t\t&& last_ap->raw_after))\n+\t    xbuf[totlen++] = exp[i];\n+\t}\n+\n+      xbuf[totlen] = 0;\n+      xbuf_len = totlen;\n+\n+    }\n+\n+  pfile->output_escapes--;\n+\n+  /* Now put the expansion on the input stack\n+     so our caller will commence reading from it.  */\n+  push_macro_expansion (pfile, xbuf, xbuf_len, hp);\n+  CPP_BUFFER (pfile)->has_escapes = 1;\n+\n+  /* Pop the space we've used in the token_buffer for argument expansion.  */\n+  CPP_SET_WRITTEN (pfile, old_written);\n+\n+  /* Recursive macro use sometimes works traditionally.\n+     #define foo(x,y) bar (x (y,0), y)\n+     foo (foo, baz)  */\n+\n+  if (!CPP_TRADITIONAL (pfile))\n+    hp->type = T_DISABLED;\n+}\n+\n+/* Return 1 iff a token ending in C1 followed directly by a token C2\n+   could cause mis-tokenization.  */\n+\n+static int\n+unsafe_chars (c1, c2)\n+     int c1, c2;\n+{\n+  switch (c1)\n+    {\n+    case '+':\n+    case '-':\n+      if (c2 == c1 || c2 == '=')\n+\treturn 1;\n+      goto letter;\n+\n+    case '.':    case '0':    case '1':    case '2':    case '3':\n+    case '4':    case '5':    case '6':    case '7':    case '8':\n+    case '9':    case 'e':    case 'E':    case 'p':    case 'P':\n+      if (c2 == '-' || c2 == '+')\n+\treturn 1;\t\t/* could extend a pre-processing number */\n+      goto letter;\n+\n+    case 'L':\n+      if (c2 == '\\'' || c2 == '\\\"')\n+\treturn 1;\t\t/* Could turn into L\"xxx\" or L'xxx'.  */\n+      goto letter;\n+\n+    case '_':  case 'a':  case 'b':  case 'c':  case 'd':  case 'f':\n+    case 'g':  case 'h':  case 'i':  case 'j':  case 'k':  case 'l':\n+    case 'm':  case 'n':  case 'o':  case 'q':  case 'r':  case 's':\n+    case 't':  case 'u':  case 'v':  case 'w':  case 'x':  case 'y':\n+    case 'z':  case 'A':  case 'B':  case 'C':  case 'D':  case 'F':\n+    case 'G':  case 'H':  case 'I':  case 'J':  case 'K':  case 'M':\n+    case 'N':  case 'O':  case 'Q':  case 'R':  case 'S':  case 'T':\n+    case 'U':  case 'V':  case 'W':  case 'X':  case 'Y':  case 'Z':\n+    letter:\n+    /* We're in the middle of either a name or a pre-processing number.  */\n+      return (is_idchar[c2] || c2 == '.');\n+\n+    case '<':  case '>':  case '!':  case '%':  case '#':  case ':':\n+    case '^':  case '&':  case '|':  case '*':  case '/':  case '=':\n+      return (c2 == c1 || c2 == '=');\n+    }\n+  return 0;\n+}\n+\n+static void\n+push_macro_expansion (pfile, xbuf, xbuf_len, hp)\n+     cpp_reader *pfile;\n+     register U_CHAR *xbuf;\n+     int xbuf_len;\n+     HASHNODE *hp;\n+{\n+  register cpp_buffer *mbuf = cpp_push_buffer (pfile, xbuf, xbuf_len);\n+  if (mbuf == NULL)\n+    return;\n+  mbuf->cleanup = macro_cleanup;\n+  mbuf->data = hp;\n+\n+  /* The first chars of the expansion should be a \"@ \" added by\n+     collect_expansion.  This is to prevent accidental token-pasting\n+     between the text preceding the macro invocation, and the macro\n+     expansion text.\n+\n+     We would like to avoid adding unneeded spaces (for the sake of\n+     tools that use cpp, such as imake).  In some common cases we can\n+     tell that it is safe to omit the space.\n+\n+     The character before the macro invocation cannot have been an\n+     idchar (or else it would have been pasted with the idchars of\n+     the macro name).  Therefore, if the first non-space character\n+     of the expansion is an idchar, we do not need the extra space\n+     to prevent token pasting.\n+\n+     Also, we don't need the extra space if the first char is '(',\n+     or some other (less common) characters.  */\n+\n+  if (xbuf[0] == '@' && xbuf[1] == ' '\n+      && (is_idchar[xbuf[2]] || xbuf[2] == '(' || xbuf[2] == '\\''\n+\t  || xbuf[2] == '\\\"'))\n+    mbuf->cur += 2;\n+\n+  /* Likewise, avoid the extra space at the end of the macro expansion\n+     if this is safe.  We can do a better job here since we can know\n+     what the next char will be.  */\n+  if (xbuf_len >= 3\n+      && mbuf->rlimit[-2] == '@'\n+      && mbuf->rlimit[-1] == ' ')\n+    {\n+      int c1 = mbuf->rlimit[-3];\n+      int c2 = CPP_BUF_PEEK (CPP_PREV_BUFFER (CPP_BUFFER (pfile)));\n+      if (c2 == EOF || !unsafe_chars (c1, c2))\n+\tmbuf->rlimit -= 2;\n+    }\n+}\n+\n+/* Return zero if two DEFINITIONs are isomorphic.  */\n+\n+int\n+compare_defs (pfile, d1, d2)\n+     cpp_reader *pfile;\n+     DEFINITION *d1, *d2;\n+{\n+  register struct reflist *a1, *a2;\n+  register U_CHAR *p1 = d1->expansion;\n+  register U_CHAR *p2 = d2->expansion;\n+  int first = 1;\n+\n+  if (d1->nargs != d2->nargs)\n+    return 1;\n+  if (CPP_PEDANTIC (pfile)\n+      && strcmp ((char *) d1->args.argnames, (char *) d2->args.argnames))\n+    return 1;\n+  for (a1 = d1->pattern, a2 = d2->pattern; a1 && a2;\n+       a1 = a1->next, a2 = a2->next)\n+    {\n+      if (!((a1->nchars == a2->nchars && !strncmp (p1, p2, a1->nchars))\n+\t    || !comp_def_part (first, p1, a1->nchars, p2, a2->nchars, 0))\n+\t  || a1->argno != a2->argno\n+\t  || a1->stringify != a2->stringify\n+\t  || a1->raw_before != a2->raw_before\n+\t  || a1->raw_after != a2->raw_after)\n+\treturn 1;\n+      first = 0;\n+      p1 += a1->nchars;\n+      p2 += a2->nchars;\n+    }\n+  if (a1 != a2)\n+    return 1;\n+\n+  return comp_def_part (first, p1, d1->length - (p1 - d1->expansion),\n+\t\t\tp2, d2->length - (p2 - d2->expansion), 1);\n+}\n+\n+/* Return 1 if two parts of two macro definitions are effectively different.\n+   One of the parts starts at BEG1 and has LEN1 chars;\n+   the other has LEN2 chars at BEG2.\n+   Any sequence of whitespace matches any other sequence of whitespace.\n+   FIRST means these parts are the first of a macro definition;\n+    so ignore leading whitespace entirely.\n+   LAST means these parts are the last of a macro definition;\n+    so ignore trailing whitespace entirely.  */\n+\n+static int\n+comp_def_part (first, beg1, len1, beg2, len2, last)\n+     int first;\n+     U_CHAR *beg1, *beg2;\n+     int len1, len2;\n+     int last;\n+{\n+  register U_CHAR *end1 = beg1 + len1;\n+  register U_CHAR *end2 = beg2 + len2;\n+  if (first)\n+    {\n+      while (beg1 != end1 && is_space[*beg1])\n+\tbeg1++;\n+      while (beg2 != end2 && is_space[*beg2])\n+\tbeg2++;\n+    }\n+  if (last)\n+    {\n+      while (beg1 != end1 && is_space[end1[-1]])\n+\tend1--;\n+      while (beg2 != end2 && is_space[end2[-1]])\n+\tend2--;\n+    }\n+  while (beg1 != end1 && beg2 != end2)\n+    {\n+      if (is_space[*beg1] && is_space[*beg2])\n+\t{\n+\t  while (beg1 != end1 && is_space[*beg1])\n+\t    beg1++;\n+\t  while (beg2 != end2 && is_space[*beg2])\n+\t    beg2++;\n+\t}\n+      else if (*beg1 == *beg2)\n+\t{\n+\t  beg1++;\n+\t  beg2++;\n+\t}\n+      else\n+\tbreak;\n+    }\n+  return (beg1 != end1) || (beg2 != end2);\n+}"}, {"sha": "7f7f7d67d99e82de8cf93fdc4be91c8998a7682f", "filename": "gcc/cpphash.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de1e2a9787e105521817b86422b50bd410560fe/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de1e2a9787e105521817b86422b50bd410560fe/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=6de1e2a9787e105521817b86422b50bd410560fe", "patch": "@@ -53,3 +53,10 @@ extern HASHNODE *install PARAMS ((U_CHAR *, int, enum node_type,\n \t\t\t\t  const char *, int));\n extern int hashf PARAMS ((const U_CHAR *, int, int));\n extern void delete_macro PARAMS ((HASHNODE *));\n+\n+extern MACRODEF create_definition PARAMS ((U_CHAR *, U_CHAR *,\n+\t\t\t\t\t   cpp_reader *, int));\n+extern int compare_defs\t\t  PARAMS ((cpp_reader *, DEFINITION *,\n+\t\t\t\t\t   DEFINITION *));\n+extern void macroexpand\t\t  PARAMS ((cpp_reader *, HASHNODE *));\n+extern void cpp_hash_cleanup\t  PARAMS ((cpp_reader *));"}, {"sha": "817190330e0aa0b897310e277eb72ce8df6c7686", "filename": "gcc/cppinit.c", "status": "modified", "additions": 1580, "deletions": 17, "changes": 1597, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de1e2a9787e105521817b86422b50bd410560fe/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de1e2a9787e105521817b86422b50bd410560fe/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=6de1e2a9787e105521817b86422b50bd410560fe", "patch": "@@ -18,24 +18,206 @@ You should have received a copy of the GNU General Public License\n along with this program; if not, write to the Free Software\n Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n \n-/* This file will have more stuff in it eventually, but right now\n-   we just have one hack: we move all the is_* table initialization\n-   in here, and we can declare them const in cpplib.h, which improves\n-   code a bit. */\n-\n #include \"config.h\"\n #include \"system.h\"\n \n-typedef unsigned char U_CHAR;\n+#define FAKE_CONST\n+#include \"cpplib.h\"\n+#include \"cpphash.h\"\n+#include \"output.h\"\n+#include \"prefix.h\"\n+#include \"intl.h\"\n \n-/* table to tell if char can be part of a C identifier.  */\n-U_CHAR is_idchar[256] = { 0 };\n-/* table to tell if char can be first char of a c identifier.  */\n-U_CHAR is_idstart[256] = { 0 };\n-/* table to tell if c is horizontal space.  */\n-U_CHAR is_hor_space[256] = { 0 };\n-/* table to tell if c is horizontal or vertical space.  */\n-U_CHAR is_space[256] = { 0 };\n+/* XXX Should be in a header file. */\n+extern char *version_string;\n+\n+/* Predefined symbols, built-in macros, and the default include path. */\n+\n+#ifndef GET_ENV_PATH_LIST\n+#define GET_ENV_PATH_LIST(VAR,NAME)\tdo { (VAR) = getenv (NAME); } while (0)\n+#endif\n+\n+/* By default, colon separates directories in a path.  */\n+#ifndef PATH_SEPARATOR\n+#define PATH_SEPARATOR ':'\n+#endif\n+\n+#ifndef STANDARD_INCLUDE_DIR\n+#define STANDARD_INCLUDE_DIR \"/usr/include\"\n+#endif\n+\n+/* Symbols to predefine.  */\n+\n+#ifdef CPP_PREDEFINES\n+static char *predefs = CPP_PREDEFINES;\n+#else\n+static char *predefs = \"\";\n+#endif\n+\n+/* We let tm.h override the types used here, to handle trivial differences\n+   such as the choice of unsigned int or long unsigned int for size_t.\n+   When machines start needing nontrivial differences in the size type,\n+   it would be best to do something here to figure out automatically\n+   from other information what type to use.  */\n+\n+/* The string value for __SIZE_TYPE__.  */\n+\n+#ifndef SIZE_TYPE\n+#define SIZE_TYPE \"long unsigned int\"\n+#endif\n+\n+/* The string value for __PTRDIFF_TYPE__.  */\n+\n+#ifndef PTRDIFF_TYPE\n+#define PTRDIFF_TYPE \"long int\"\n+#endif\n+\n+/* The string value for __WCHAR_TYPE__.  */\n+\n+#ifndef WCHAR_TYPE\n+#define WCHAR_TYPE \"int\"\n+#endif\n+#define CPP_WCHAR_TYPE(PFILE) \\\n+\t(CPP_OPTIONS (PFILE)->cplusplus ? \"__wchar_t\" : WCHAR_TYPE)\n+\n+/* The string value for __USER_LABEL_PREFIX__ */\n+\n+#ifndef USER_LABEL_PREFIX\n+#define USER_LABEL_PREFIX \"\"\n+#endif\n+\n+/* The string value for __REGISTER_PREFIX__ */\n+\n+#ifndef REGISTER_PREFIX\n+#define REGISTER_PREFIX \"\"\n+#endif\n+\n+/* #include \"file\" looks in source file dir, then stack.  */\n+/* #include <file> just looks in the stack.  */\n+/* -I directories are added to the end, then the defaults are added.  */\n+/* The */\n+static struct default_include {\n+  char *fname;\t\t\t/* The name of the directory.  */\n+  char *component;\t\t/* The component containing the directory */\n+  int cplusplus;\t\t/* Only look here if we're compiling C++.  */\n+  int cxx_aware;\t\t/* Includes in this directory don't need to\n+\t\t\t\t   be wrapped in extern \"C\" when compiling\n+\t\t\t\t   C++.  */\n+} include_defaults_array[]\n+#ifdef INCLUDE_DEFAULTS\n+  = INCLUDE_DEFAULTS;\n+#else\n+  = {\n+    /* Pick up GNU C++ specific include files.  */\n+    { GPLUSPLUS_INCLUDE_DIR, \"G++\", 1, 1 },\n+#ifdef CROSS_COMPILE\n+    /* This is the dir for fixincludes.  Put it just before\n+       the files that we fix.  */\n+    { GCC_INCLUDE_DIR, \"GCC\", 0, 0 },\n+    /* For cross-compilation, this dir name is generated\n+       automatically in Makefile.in.  */\n+    { CROSS_INCLUDE_DIR, \"GCC\",0, 0 },\n+#ifdef TOOL_INCLUDE_DIR\n+    /* This is another place that the target system's headers might be.  */\n+    { TOOL_INCLUDE_DIR, \"BINUTILS\", 0, 1 },\n+#endif\n+#else /* not CROSS_COMPILE */\n+#ifdef LOCAL_INCLUDE_DIR\n+    /* This should be /usr/local/include and should come before\n+       the fixincludes-fixed header files.  */\n+    { LOCAL_INCLUDE_DIR, 0, 0, 1 },\n+#endif\n+#ifdef TOOL_INCLUDE_DIR\n+    /* This is here ahead of GCC_INCLUDE_DIR because assert.h goes here.\n+       Likewise, behind LOCAL_INCLUDE_DIR, where glibc puts its assert.h.  */\n+    { TOOL_INCLUDE_DIR, \"BINUTILS\", 0, 1 },\n+#endif\n+    /* This is the dir for fixincludes.  Put it just before\n+       the files that we fix.  */\n+    { GCC_INCLUDE_DIR, \"GCC\", 0, 0 },\n+    /* Some systems have an extra dir of include files.  */\n+#ifdef SYSTEM_INCLUDE_DIR\n+    { SYSTEM_INCLUDE_DIR, 0, 0, 0 },\n+#endif\n+#ifndef STANDARD_INCLUDE_COMPONENT\n+#define STANDARD_INCLUDE_COMPONENT 0\n+#endif\n+    { STANDARD_INCLUDE_DIR, STANDARD_INCLUDE_COMPONENT, 0, 0 },\n+#endif /* not CROSS_COMPILE */\n+    { 0, 0, 0, 0 }\n+    };\n+#endif /* no INCLUDE_DEFAULTS */\n+\n+/* Internal structures and prototypes. */\n+\n+struct cpp_pending\n+{\n+  struct cpp_pending *next;\n+  char *cmd;\n+  char *arg;\n+};\n+static struct cpp_pending *nreverse_pending PARAMS ((struct cpp_pending *));\n+\n+static void initialize_char_syntax\tPARAMS ((int));\n+static void print_help                  PARAMS ((void));\n+static void path_include\t\tPARAMS ((cpp_reader *, char *));\n+static void initialize_builtins\t\tPARAMS ((cpp_reader *));\n+\n+\n+/* If gcc is in use (stage2/stage3) we can make these tables initialized\n+   data. */\n+#if defined __GNUC__ && __GNUC__ >= 2\n+/* Table to tell if a character is legal as the second or later character\n+   of a C identifier. */\n+U_CHAR is_idchar[256] =\n+{\n+  ['a'] = 1, ['b'] = 1, ['c'] = 1,  ['d'] = 1, ['e'] = 1, ['f'] = 1,\n+  ['g'] = 1, ['h'] = 1, ['i'] = 1,  ['j'] = 1, ['k'] = 1, ['l'] = 1,\n+  ['m'] = 1, ['n'] = 1, ['o'] = 1,  ['p'] = 1, ['q'] = 1, ['r'] = 1,\n+  ['s'] = 1, ['t'] = 1, ['u'] = 1,  ['v'] = 1, ['w'] = 1, ['x'] = 1,\n+  ['y'] = 1, ['z'] = 1,\n+\n+  ['A'] = 1, ['B'] = 1, ['C'] = 1,  ['D'] = 1, ['E'] = 1, ['F'] = 1,\n+  ['G'] = 1, ['H'] = 1, ['I'] = 1,  ['J'] = 1, ['K'] = 1, ['L'] = 1,\n+  ['M'] = 1, ['N'] = 1, ['O'] = 1,  ['P'] = 1, ['Q'] = 1, ['R'] = 1,\n+  ['S'] = 1, ['T'] = 1, ['U'] = 1,  ['V'] = 1, ['W'] = 1, ['X'] = 1,\n+  ['Y'] = 1, ['Z'] = 1,\n+\n+  ['1'] = 1, ['2'] = 1, ['3'] = 1,  ['4'] = 1, ['5'] = 1, ['6'] = 1,\n+  ['7'] = 1, ['8'] = 1, ['9'] = 1,  ['0'] = 1,\n+\n+  ['_']  = 1,\n+};\n+\n+/* Table to tell if a character is legal as the first character of\n+   a C identifier. */\n+U_CHAR is_idstart[256] =\n+{\n+  ['a'] = 1, ['b'] = 1, ['c'] = 1,  ['d'] = 1, ['e'] = 1, ['f'] = 1,\n+  ['g'] = 1, ['h'] = 1, ['i'] = 1,  ['j'] = 1, ['k'] = 1, ['l'] = 1,\n+  ['m'] = 1, ['n'] = 1, ['o'] = 1,  ['p'] = 1, ['q'] = 1, ['r'] = 1,\n+  ['s'] = 1, ['t'] = 1, ['u'] = 1,  ['v'] = 1, ['w'] = 1, ['x'] = 1,\n+  ['y'] = 1, ['z'] = 1,\n+\n+  ['A'] = 1, ['B'] = 1, ['C'] = 1,  ['D'] = 1, ['E'] = 1, ['F'] = 1,\n+  ['G'] = 1, ['H'] = 1, ['I'] = 1,  ['J'] = 1, ['K'] = 1, ['L'] = 1,\n+  ['M'] = 1, ['N'] = 1, ['O'] = 1,  ['P'] = 1, ['Q'] = 1, ['R'] = 1,\n+  ['S'] = 1, ['T'] = 1, ['U'] = 1,  ['V'] = 1, ['W'] = 1, ['X'] = 1,\n+  ['Y'] = 1, ['Z'] = 1,\n+\n+  ['_']  = 1,\n+};\n+\n+/* Table to tell if a character is horizontal space. */\n+U_CHAR is_hor_space[256] =\n+{\n+  [' '] = 1, ['\\t'] = 1, ['\\v'] = 1, ['\\f'] = 1, ['\\r'] = 1\n+};\n+/* table to tell if a character is horizontal or vertical space.  */\n+U_CHAR is_space[256] =\n+{\n+  [' '] = 1, ['\\t'] = 1, ['\\v'] = 1, ['\\f'] = 1, ['\\r'] = 1, ['\\n'] = 1,\n+};\n /* Table to handle trigraph conversion, which occurs before all other\n    processing, everywhere in the file.  (This is necessary since one\n    of the trigraphs encodes backslash.)  Note it's off by default.\n@@ -47,10 +229,32 @@ U_CHAR is_space[256] = { 0 };\n \n    There is not a space between the ?? and the third char.  I put spaces\n    there to avoid warnings when compiling this file. */\n+U_CHAR trigraph_table[256] =\n+{\n+  ['='] = '#',  [')'] = ']',  ['!'] = '|',\n+  ['('] = '[',  ['\\''] = '^', ['>'] = '}',\n+  ['/'] = '\\\\', ['<'] = '{',  ['-'] = '~',\n+};\n+\n+/* This function will be entirely removed soon. */\n+static inline void\n+initialize_char_syntax (dollar_in_ident)\n+     int dollar_in_ident;\n+{\n+  is_idchar['$'] = dollar_in_ident;\n+  is_idstart['$'] = dollar_in_ident;\n+}\n+\n+#else /* Not GCC. */\n+\n+U_CHAR is_idchar[256] = { 0 };\n+U_CHAR is_idstart[256] = { 0 };\n+U_CHAR is_hor_space[256] = { 0 };\n+U_CHAR is_space[256] = { 0 };\n U_CHAR trigraph_table[256] = { 0 };\n \n /* Initialize syntactic classifications of characters. */\n-void\n+static void\n initialize_char_syntax (dollar_in_ident)\n      int dollar_in_ident;\n {\n@@ -103,11 +307,10 @@ initialize_char_syntax (dollar_in_ident)\n \n   is_idchar['_']  = 1;\n \n-  /* These will be reset later if -$ is in effect. */\n   is_idchar['$']  = dollar_in_ident;\n   is_idstart['$'] = dollar_in_ident;\n \n-  /* horizontal space table */\n+  /* white space tables */\n   is_hor_space[' '] = 1;\n   is_hor_space['\\t'] = 1;\n   is_hor_space['\\v'] = 1;\n@@ -128,3 +331,1363 @@ initialize_char_syntax (dollar_in_ident)\n   trigraph_table['/'] = '\\\\'; trigraph_table['<'] = '{';\n   trigraph_table['-'] = '~';\n }\n+\n+#endif /* Not GCC. */\n+\n+/* Given a colon-separated list of file names PATH,\n+   add all the names to the search path for include files.  */\n+\n+static void\n+path_include (pfile, path)\n+     cpp_reader *pfile;\n+     char *path;\n+{\n+  char *p;\n+\n+  p = path;\n+\n+  if (*p)\n+    while (1) {\n+      char *q = p;\n+      char *name;\n+\n+      /* Find the end of this name.  */\n+      while (*q != 0 && *q != PATH_SEPARATOR) q++;\n+      if (p == q) {\n+\t/* An empty name in the path stands for the current directory.  */\n+\tname = (char *) xmalloc (2);\n+\tname[0] = '.';\n+\tname[1] = 0;\n+      } else {\n+\t/* Otherwise use the directory that is named.  */\n+\tname = (char *) xmalloc (q - p + 1);\n+\tbcopy (p, name, q - p);\n+\tname[q - p] = 0;\n+      }\n+\n+      append_include_chain (pfile,\n+\t\t\t    &(CPP_OPTIONS (pfile)->bracket_include), name, 0);\n+\n+      /* Advance past this name.  */\n+      p = q;\n+      if (*p == 0)\n+\tbreak;\n+      /* Skip the colon.  */\n+      p++;\n+    }\n+}\n+\n+/* Write out a #define command for the special named MACRO_NAME\n+   to PFILE's token_buffer.  */\n+\n+static void\n+dump_special_to_buffer (pfile, macro_name)\n+     cpp_reader *pfile;\n+     char *macro_name;\n+{\n+  static char define_directive[] = \"#define \";\n+  int macro_name_length = strlen (macro_name);\n+  output_line_command (pfile, 0, same_file);\n+  CPP_RESERVE (pfile, sizeof(define_directive) + macro_name_length);\n+  CPP_PUTS_Q (pfile, define_directive, sizeof(define_directive)-1);\n+  CPP_PUTS_Q (pfile, macro_name, macro_name_length);\n+  CPP_PUTC_Q (pfile, ' ');\n+  cpp_expand_to_buffer (pfile, macro_name, macro_name_length);\n+  CPP_PUTC (pfile, '\\n');\n+}\n+\n+/* Pending-list utility routines.  Will go away soon.  */\n+static struct cpp_pending *\n+nreverse_pending (list)\n+     struct cpp_pending *list;\n+     \n+{\n+  register struct cpp_pending *prev = 0, *next, *pend;\n+  for (pend = list;  pend;  pend = next)\n+    {\n+      next = pend->next;\n+      pend->next = prev;\n+      prev = pend;\n+    }\n+  return prev;\n+}\n+\n+static void\n+push_pending (pfile, cmd, arg)\n+     cpp_reader *pfile;\n+     char *cmd;\n+     char *arg;\n+{\n+  struct cpp_pending *pend\n+    = (struct cpp_pending *) xmalloc (sizeof (struct cpp_pending));\n+  pend->cmd = cmd;\n+  pend->arg = arg;\n+  pend->next = CPP_OPTIONS (pfile)->pending;\n+  CPP_OPTIONS (pfile)->pending = pend;\n+}\n+\n+\n+/* Initialize a cpp_options structure. */\n+void\n+cpp_options_init (opts)\n+     cpp_options *opts;\n+{\n+  bzero ((char *) opts, sizeof *opts);\n+\n+  opts->dollars_in_ident = 1;\n+  opts->cplusplus_comments = 1;\n+  opts->warn_import = 1;\n+}\n+\n+/* Initialize a cpp_reader structure. */\n+void\n+cpp_reader_init (pfile)\n+     cpp_reader *pfile;\n+{\n+  bzero ((char *) pfile, sizeof (cpp_reader));\n+#if 0\n+  pfile->get_token = cpp_get_token;\n+#endif\n+\n+  pfile->token_buffer_size = 200;\n+  pfile->token_buffer = (U_CHAR *) xmalloc (pfile->token_buffer_size);\n+  CPP_SET_WRITTEN (pfile, 0);\n+}\n+\n+/* Free resources used by PFILE.\n+   This is the cpp_reader 'finalizer' or 'destructor' (in C++ terminology).  */\n+void\n+cpp_cleanup (pfile)\n+     cpp_reader *pfile;\n+{\n+  int i;\n+  while (CPP_BUFFER (pfile) != CPP_NULL_BUFFER (pfile))\n+    cpp_pop_buffer (pfile);\n+\n+  if (pfile->token_buffer)\n+    {\n+      free (pfile->token_buffer);\n+      pfile->token_buffer = NULL;\n+    }\n+\n+  if (pfile->deps_buffer)\n+    {\n+      free (pfile->deps_buffer);\n+      pfile->deps_buffer = NULL;\n+      pfile->deps_allocated_size = 0;\n+    }\n+\n+  while (pfile->if_stack)\n+    {\n+      IF_STACK_FRAME *temp = pfile->if_stack;\n+      pfile->if_stack = temp->next;\n+      free (temp);\n+    }\n+\n+  for (i = ALL_INCLUDE_HASHSIZE; --i >= 0; )\n+    {\n+      struct include_hash *imp = pfile->all_include_files[i];\n+      while (imp)\n+\t{\n+\t  struct include_hash *next = imp->next;\n+#if 0\n+\t  /* This gets freed elsewhere - I think. */\n+\t  free (imp->name);\n+#endif\n+\t  free (imp);\n+\t  imp = next;\n+\t}\n+      pfile->all_include_files[i] = 0;\n+    }\n+\n+  cpp_hash_cleanup (pfile);\n+}\n+\n+\n+/* Initialize the built-in macros.  */\n+static void\n+initialize_builtins (pfile)\n+     cpp_reader *pfile;\n+{\n+#define NAME(str) (U_CHAR *)str, sizeof str - 1\n+  install (NAME(\"__TIME__\"),\t\t  T_TIME,\t0, -1);\n+  install (NAME(\"__DATE__\"),\t\t  T_DATE,\t0, -1);\n+  install (NAME(\"__FILE__\"),\t\t  T_FILE,\t0, -1);\n+  install (NAME(\"__BASE_FILE__\"),\t  T_BASE_FILE,\t0, -1);\n+  install (NAME(\"__LINE__\"),\t\t  T_SPECLINE,\t0, -1);\n+  install (NAME(\"__INCLUDE_LEVEL__\"),\t  T_INCLUDE_LEVEL, 0, -1);\n+  install (NAME(\"__VERSION__\"),\t\t  T_VERSION,\t0, -1);\n+#ifndef NO_BUILTIN_SIZE_TYPE\n+  install (NAME(\"__SIZE_TYPE__\"),\t  T_CONST, SIZE_TYPE, -1);\n+#endif\n+#ifndef NO_BUILTIN_PTRDIFF_TYPE\n+  install (NAME(\"__PTRDIFF_TYPE__ \"),\t  T_CONST, PTRDIFF_TYPE, -1);\n+#endif\n+  install (NAME(\"__WCHAR_TYPE__\"),\t  T_CONST, WCHAR_TYPE, -1);\n+  install (NAME(\"__USER_LABEL_PREFIX__\"), T_CONST, user_label_prefix, -1);\n+  install (NAME(\"__REGISTER_PREFIX__\"),\t  T_CONST, REGISTER_PREFIX, -1);\n+  if (!CPP_TRADITIONAL (pfile))\n+    {\n+      install (NAME(\"__STDC__\"),\t  T_STDC,  0, -1);\n+#if 0\n+      if (CPP_OPTIONS (pfile)->c9x)\n+\tinstall (NAME(\"__STDC_VERSION__\"),T_CONST, \"199909L\", -1);\n+      else\n+#endif\n+\tinstall (NAME(\"__STDC_VERSION__\"),T_CONST, \"199409L\", -1);\n+    }\n+#undef NAME\n+\n+  if (CPP_OPTIONS (pfile)->debug_output)\n+    {\n+      dump_special_to_buffer (pfile, \"__BASE_FILE__\");\n+      dump_special_to_buffer (pfile, \"__VERSION__\");\n+#ifndef NO_BUILTIN_SIZE_TYPE\n+      dump_special_to_buffer (pfile, \"__SIZE_TYPE__\");\n+#endif\n+#ifndef NO_BUILTIN_PTRDIFF_TYPE\n+      dump_special_to_buffer (pfile, \"__PTRDIFF_TYPE__\");\n+#endif\n+      dump_special_to_buffer (pfile, \"__WCHAR_TYPE__\");\n+      dump_special_to_buffer (pfile, \"__DATE__\");\n+      dump_special_to_buffer (pfile, \"__TIME__\");\n+      if (!CPP_TRADITIONAL (pfile))\n+\tdump_special_to_buffer (pfile, \"__STDC__\");\n+    }\n+}\n+\n+/* This is called after options have been processed.\n+ * Check options for consistency, and setup for processing input\n+ * from the file named FNAME.  (Use standard input if FNAME==NULL.)\n+ * Return 1 on success, 0 on failure.\n+ */\n+\n+int\n+cpp_start_read (pfile, fname)\n+     cpp_reader *pfile;\n+     char *fname;\n+{\n+  struct cpp_options *opts = CPP_OPTIONS (pfile);\n+  struct cpp_pending *pend;\n+  char *p;\n+  int f;\n+  cpp_buffer *fp;\n+  struct include_hash *ih_fake;\n+\n+  /* The code looks at the defaults through this pointer, rather than\n+     through the constant structure above.  This pointer gets changed\n+     if an environment variable specifies other defaults.  */\n+  struct default_include *include_defaults = include_defaults_array;\n+\n+  /* Now that we know dollars_in_ident, we can initialize the syntax\n+     tables. */\n+  initialize_char_syntax (opts->dollars_in_ident);\n+  \n+  /* Add dirs from CPATH after dirs from -I.  */\n+  /* There seems to be confusion about what CPATH should do,\n+     so for the moment it is not documented.  */\n+  /* Some people say that CPATH should replace the standard include\n+     dirs, but that seems pointless: it comes before them, so it\n+     overrides them anyway.  */\n+  GET_ENV_PATH_LIST (p, \"CPATH\");\n+  if (p != 0 && ! opts->no_standard_includes)\n+    path_include (pfile, p);\n+\n+  /* Do partial setup of input buffer for the sake of generating\n+     early #line directives (when -g is in effect).  */\n+  fp = cpp_push_buffer (pfile, NULL, 0);\n+  if (!fp)\n+    return 0;\n+  if (opts->in_fname == NULL || *opts->in_fname == 0)\n+    {\n+      opts->in_fname = fname;\n+      if (opts->in_fname == NULL)\n+\topts->in_fname = \"\";\n+    }\n+  fp->nominal_fname = fp->fname = opts->in_fname;\n+  fp->lineno = 0;\n+\n+  /* Install __LINE__, etc.  Must follow initialize_char_syntax\n+     and option processing.  */\n+  initialize_builtins (pfile);\n+\n+  /* Do standard #defines and assertions\n+     that identify system and machine type.  */\n+\n+  if (!opts->inhibit_predefs) {\n+    char *p = (char *) alloca (strlen (predefs) + 1);\n+    strcpy (p, predefs);\n+    while (*p) {\n+      char *q;\n+      while (*p == ' ' || *p == '\\t')\n+\tp++;\n+      /* Handle -D options.  */ \n+      if (p[0] == '-' && p[1] == 'D') {\n+\tq = &p[2];\n+\twhile (*p && *p != ' ' && *p != '\\t')\n+\t  p++;\n+\tif (*p != 0)\n+\t  *p++= 0;\n+\tif (opts->debug_output)\n+\t  output_line_command (pfile, 0, same_file);\n+\tcpp_define (pfile, q);\n+\twhile (*p == ' ' || *p == '\\t')\n+\t  p++;\n+      } else if (p[0] == '-' && p[1] == 'A') {\n+\t/* Handle -A options (assertions).  */ \n+\tchar *assertion;\n+\tchar *past_name;\n+\tchar *value;\n+\tchar *past_value;\n+\tchar *termination;\n+\tint save_char;\n+\n+\tassertion = &p[2];\n+\tpast_name = assertion;\n+\t/* Locate end of name.  */\n+\twhile (*past_name && *past_name != ' '\n+\t       && *past_name != '\\t' && *past_name != '(')\n+\t  past_name++;\n+\t/* Locate `(' at start of value.  */\n+\tvalue = past_name;\n+\twhile (*value && (*value == ' ' || *value == '\\t'))\n+\t  value++;\n+\tif (*value++ != '(')\n+\t  abort ();\n+\twhile (*value && (*value == ' ' || *value == '\\t'))\n+\t  value++;\n+\tpast_value = value;\n+\t/* Locate end of value.  */\n+\twhile (*past_value && *past_value != ' '\n+\t       && *past_value != '\\t' && *past_value != ')')\n+\t  past_value++;\n+\ttermination = past_value;\n+\twhile (*termination && (*termination == ' ' || *termination == '\\t'))\n+\t  termination++;\n+\tif (*termination++ != ')')\n+\t  abort ();\n+\tif (*termination && *termination != ' ' && *termination != '\\t')\n+\t  abort ();\n+\t/* Temporarily null-terminate the value.  */\n+\tsave_char = *termination;\n+\t*termination = '\\0';\n+\t/* Install the assertion.  */\n+\tcpp_assert (pfile, assertion);\n+\t*termination = (char) save_char;\n+\tp = termination;\n+\twhile (*p == ' ' || *p == '\\t')\n+\t  p++;\n+      } else {\n+\tabort ();\n+      }\n+    }\n+  }\n+\n+  /* Now handle the command line options.  */\n+\n+  /* Do -U's, -D's and -A's in the order they were seen.  */\n+  /* First reverse the list.  */\n+  opts->pending = nreverse_pending (opts->pending);\n+\n+  for (pend = opts->pending;  pend;  pend = pend->next)\n+    {\n+      if (pend->cmd != NULL && pend->cmd[0] == '-')\n+\t{\n+\t  switch (pend->cmd[1])\n+\t    {\n+\t    case 'U':\n+\t      if (opts->debug_output)\n+\t\toutput_line_command (pfile, 0, same_file);\n+\t      cpp_undef (pfile, pend->arg);\n+\t      break;\n+\t    case 'D':\n+\t      if (opts->debug_output)\n+\t\toutput_line_command (pfile, 0, same_file);\n+\t      cpp_define (pfile, pend->arg);\n+\t      break;\n+\t    case 'A':\n+\t      cpp_assert (pfile, pend->arg);\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  opts->done_initializing = 1;\n+\n+  { /* Read the appropriate environment variable and if it exists\n+       replace include_defaults with the listed path.  */\n+    char *epath = 0;\n+    switch ((opts->objc << 1) + opts->cplusplus)\n+      {\n+      case 0:\n+\tGET_ENV_PATH_LIST (epath, \"C_INCLUDE_PATH\");\n+\tbreak;\n+      case 1:\n+\tGET_ENV_PATH_LIST (epath, \"CPLUS_INCLUDE_PATH\");\n+\tbreak;\n+      case 2:\n+\tGET_ENV_PATH_LIST (epath, \"OBJC_INCLUDE_PATH\");\n+\tbreak;\n+      case 3:\n+\tGET_ENV_PATH_LIST (epath, \"OBJCPLUS_INCLUDE_PATH\");\n+\tbreak;\n+      }\n+    /* If the environment var for this language is set,\n+       add to the default list of include directories.  */\n+    if (epath) {\n+      char *nstore = (char *) alloca (strlen (epath) + 2);\n+      int num_dirs;\n+      char *startp, *endp;\n+\n+      for (num_dirs = 1, startp = epath; *startp; startp++)\n+\tif (*startp == PATH_SEPARATOR)\n+\t  num_dirs++;\n+      include_defaults\n+\t= (struct default_include *) xmalloc ((num_dirs\n+\t\t\t\t\t       * sizeof (struct default_include))\n+\t\t\t\t\t      + sizeof (include_defaults_array));\n+      startp = endp = epath;\n+      num_dirs = 0;\n+      while (1) {\n+        /* Handle cases like c:/usr/lib:d:/gcc/lib */\n+        if ((*endp == PATH_SEPARATOR)\n+            || *endp == 0) {\n+\t  strncpy (nstore, startp, endp-startp);\n+\t  if (endp == startp)\n+\t    strcpy (nstore, \".\");\n+\t  else\n+\t    nstore[endp-startp] = '\\0';\n+\n+\t  include_defaults[num_dirs].fname = xstrdup (nstore);\n+\t  include_defaults[num_dirs].component = 0;\n+\t  include_defaults[num_dirs].cplusplus = opts->cplusplus;\n+\t  include_defaults[num_dirs].cxx_aware = 1;\n+\t  num_dirs++;\n+\t  if (*endp == '\\0')\n+\t    break;\n+\t  endp = startp = endp + 1;\n+\t} else\n+\t  endp++;\n+      }\n+      /* Put the usual defaults back in at the end.  */\n+      bcopy ((char *) include_defaults_array,\n+\t     (char *) &include_defaults[num_dirs],\n+\t     sizeof (include_defaults_array));\n+    }\n+  }\n+\n+  /* Unless -fnostdinc,\n+     tack on the standard include file dirs to the specified list */\n+  if (!opts->no_standard_includes) {\n+    struct default_include *p = include_defaults;\n+    char *specd_prefix = opts->include_prefix;\n+    char *default_prefix = xstrdup (GCC_INCLUDE_DIR);\n+    int default_len = 0;\n+    /* Remove the `include' from /usr/local/lib/gcc.../include.  */\n+    if (!strcmp (default_prefix + strlen (default_prefix) - 8, \"/include\")) {\n+      default_len = strlen (default_prefix) - 7;\n+      default_prefix[default_len] = 0;\n+    }\n+    /* Search \"translated\" versions of GNU directories.\n+       These have /usr/local/lib/gcc... replaced by specd_prefix.  */\n+    if (specd_prefix != 0 && default_len != 0)\n+      for (p = include_defaults; p->fname; p++) {\n+\t/* Some standard dirs are only for C++.  */\n+\tif (!p->cplusplus\n+\t    || (opts->cplusplus && !opts->no_standard_cplusplus_includes)) {\n+\t  /* Does this dir start with the prefix?  */\n+\t  if (!strncmp (p->fname, default_prefix, default_len)) {\n+\t    /* Yes; change prefix and add to search list.  */\n+\t    int this_len = strlen (specd_prefix)\n+\t\t\t   + strlen (p->fname) - default_len;\n+\t    char *str = (char *) xmalloc (this_len + 1);\n+\t    strcpy (str, specd_prefix);\n+\t    strcat (str, p->fname + default_len);\n+\n+\t    append_include_chain (pfile, &opts->system_include,\n+\t\t\t\t  str, !p->cxx_aware);\n+\t  }\n+\t}\n+      }\n+    /* Search ordinary names for GNU include directories.  */\n+    for (p = include_defaults; p->fname; p++) {\n+      /* Some standard dirs are only for C++.  */\n+      if (!p->cplusplus\n+\t  || (opts->cplusplus && !opts->no_standard_cplusplus_includes)) {\n+\tconst char *str = update_path (p->fname, p->component);\n+\tappend_include_chain (pfile, &opts->system_include,\n+\t\t\t      str, !p->cxx_aware);\n+      }\n+    }\n+  }\n+\n+  merge_include_chains (opts);\n+\n+  /* With -v, print the list of dirs to search.  */\n+  if (opts->verbose) {\n+    struct file_name_list *p;\n+    cpp_notice (\"#include \\\"...\\\" search starts here:\\n\");\n+    for (p = opts->quote_include; p; p = p->next) {\n+      if (p == opts->bracket_include)\n+\tcpp_notice (\"#include <...> search starts here:\\n\");\n+      fprintf (stderr, \" %s\\n\", p->name);\n+    }\n+    cpp_notice (\"End of search list.\\n\");\n+  }\n+\n+  /* Copy the entire contents of the main input file into\n+     the stacked input buffer previously allocated for it.  */\n+  if (fname == NULL || *fname == 0) {\n+    fname = \"\";\n+    f = 0;\n+  } else if ((f = open (fname, O_RDONLY|O_NONBLOCK|O_NOCTTY, 0666)) < 0)\n+    cpp_pfatal_with_name (pfile, fname);\n+\n+  /* -MG doesn't select the form of output and must be specified with one of\n+     -M or -MM.  -MG doesn't make sense with -MD or -MMD since they don't\n+     inhibit compilation.  */\n+  if (opts->print_deps_missing_files\n+      && (opts->print_deps == 0 || !opts->no_output))\n+    {\n+      cpp_fatal (pfile, \"-MG must be specified with one of -M or -MM\");\n+      return 0;\n+    }\n+\n+  /* Either of two environment variables can specify output of deps.\n+     Its value is either \"OUTPUT_FILE\" or \"OUTPUT_FILE DEPS_TARGET\",\n+     where OUTPUT_FILE is the file to write deps info to\n+     and DEPS_TARGET is the target to mention in the deps.  */\n+\n+  if (opts->print_deps == 0\n+      && (getenv (\"SUNPRO_DEPENDENCIES\") != 0\n+\t  || getenv (\"DEPENDENCIES_OUTPUT\") != 0)) {\n+    char *spec = getenv (\"DEPENDENCIES_OUTPUT\");\n+    char *s;\n+    char *output_file;\n+\n+    if (spec == 0)\n+      {\n+\tspec = getenv (\"SUNPRO_DEPENDENCIES\");\n+\topts->print_deps = 2;\n+      }\n+    else\n+      opts->print_deps = 1;\n+\n+    s = spec;\n+    /* Find the space before the DEPS_TARGET, if there is one.  */\n+    /* This should use index.  (mrs) */\n+    while (*s != 0 && *s != ' ') s++;\n+    if (*s != 0)\n+      {\n+\topts->deps_target = s + 1;\n+\toutput_file = (char *) xmalloc (s - spec + 1);\n+\tbcopy (spec, output_file, s - spec);\n+\toutput_file[s - spec] = 0;\n+      }\n+    else\n+      {\n+\topts->deps_target = 0;\n+\toutput_file = spec;\n+      }\n+\n+    opts->deps_file = output_file;\n+    opts->print_deps_append = 1;\n+  }\n+\n+  /* For -M, print the expected object file name\n+     as the target of this Make-rule.  */\n+  if (opts->print_deps)\n+    {\n+      pfile->deps_allocated_size = 200;\n+      pfile->deps_buffer = (char *) xmalloc (pfile->deps_allocated_size);\n+      pfile->deps_buffer[0] = 0;\n+      pfile->deps_size = 0;\n+      pfile->deps_column = 0;\n+\n+      if (opts->deps_target)\n+\tdeps_output (pfile, opts->deps_target, ':');\n+      else if (*opts->in_fname == 0)\n+\tdeps_output (pfile, \"-\", ':');\n+      else\n+\t{\n+\t  char *p, *q, *r;\n+\t  int len, x;\n+\t  static char *known_suffixes[] = { \".c\", \".C\", \".s\", \".S\", \".m\",\n+\t\t\t\t     \".cc\", \".cxx\", \".cpp\", \".cp\",\n+\t\t\t\t     \".c++\", 0\n+\t\t\t\t   };\n+\n+\t  /* Discard all directory prefixes from filename.  */\n+\t  if ((q = rindex (opts->in_fname, '/')) != NULL\n+#ifdef DIR_SEPARATOR\n+\t      && (q = rindex (opts->in_fname, DIR_SEPARATOR)) != NULL\n+#endif\n+\t      )\n+\t    ++q;\n+\t  else\n+\t    q = opts->in_fname;\n+\n+\t  /* Copy remainder to mungable area.  */\n+\t  p = (char *) alloca (strlen(q) + 8);\n+\t  strcpy (p, q);\n+\n+\t  /* Output P, but remove known suffixes.  */\n+\t  len = strlen (p);\n+\t  q = p + len;\n+\t  /* Point to the filename suffix.  */\n+\t  r = rindex (p, '.');\n+\t  /* Compare against the known suffixes.  */\n+\t  x = 0;\n+\t  while (known_suffixes[x] != 0)\n+\t    {\n+\t      if (strncmp (known_suffixes[x], r, q - r) == 0)\n+\t\t{\n+\t\t  /* Make q point to the bit we're going to overwrite\n+\t\t     with an object suffix.  */\n+\t\t  q = r;\n+\t\t  break;\n+\t\t}\n+\t      x++;\n+\t    }\n+\n+\t  /* Supply our own suffix.  */\n+#ifndef VMS\n+\t  strcpy (q, \".o\");\n+#else\n+\t  strcpy (q, \".obj\");\n+#endif\n+\n+\t  deps_output (pfile, p, ':');\n+\t  deps_output (pfile, opts->in_fname, ' ');\n+\t}\n+    }\n+\n+  /* Must call finclude() on the main input before processing\n+     -include switches; otherwise the -included text winds up\n+     after the main input. */\n+  ih_fake = (struct include_hash *) xmalloc (sizeof (struct include_hash));\n+  ih_fake->next = 0;\n+  ih_fake->next_this_file = 0;\n+  ih_fake->foundhere = ABSOLUTE_PATH;  /* well sort of ... */\n+  ih_fake->name = fname;\n+  ih_fake->control_macro = 0;\n+  ih_fake->buf = (char *)-1;\n+  ih_fake->limit = 0;\n+  if (!finclude (pfile, f, ih_fake))\n+    return 0;\n+  output_line_command (pfile, 0, same_file);\n+  pfile->only_seen_white = 2;\n+\n+  /* The -imacros files can be scanned now, but the -include files\n+     have to be pushed onto the include stack and processed later,\n+     in the main loop calling cpp_get_token.  That means the -include\n+     files have to be processed in reverse order of the pending list,\n+     which means the pending list has to be reversed again, which\n+     means the -imacros files have to be done separately and first. */\n+  \n+  pfile->no_record_file++;\n+  opts->no_output++;\n+  for (pend = opts->pending; pend; pend = pend->next)\n+    {\n+      if (pend->cmd != NULL)\n+        {\n+\t  if (strcmp (pend->cmd, \"-imacros\") == 0)\n+\t    {\n+\t      int fd = open (pend->arg, O_RDONLY|O_NONBLOCK|O_NOCTTY, 0666);\n+\t      if (fd < 0)\n+\t        {\n+\t          cpp_perror_with_name (pfile, pend->arg);\n+\t          return 0;\n+\t        }\n+\t      if (!cpp_push_buffer (pfile, NULL, 0))\n+\t        return 0;\n+\n+\t      ih_fake = (struct include_hash *)\n+\t\t  xmalloc (sizeof (struct include_hash));\n+\t      ih_fake->next = 0;\n+\t      ih_fake->next_this_file = 0;\n+\t      ih_fake->foundhere = ABSOLUTE_PATH;  /* well sort of ... */\n+\t      ih_fake->name = pend->arg;\n+\t      ih_fake->control_macro = 0;\n+\t      ih_fake->buf = (char *)-1;\n+\t      ih_fake->limit = 0;\n+\t      if (!finclude (pfile, fd, ih_fake))\n+\t\tcpp_scan_buffer (pfile);\n+\t      free (ih_fake);\n+\t    }\n+\t}\n+    }\n+  opts->no_output--;\n+  opts->pending = nreverse_pending (opts->pending);\n+  for (pend = opts->pending; pend; pend = pend->next)\n+    {\n+      if (pend->cmd != NULL)\n+        {\n+\t  if (strcmp (pend->cmd, \"-include\") == 0)\n+\t    {\n+\t      int fd = open (pend->arg, O_RDONLY|O_NONBLOCK|O_NOCTTY, 0666);\n+\t      if (fd < 0)\n+\t        {\n+\t          cpp_perror_with_name (pfile, pend->arg);\n+\t          return 0;\n+\t        }\n+\t      if (!cpp_push_buffer (pfile, NULL, 0))\n+\t        return 0;\n+\n+\t      ih_fake = (struct include_hash *)\n+\t\t  xmalloc (sizeof (struct include_hash));\n+\t      ih_fake->next = 0;\n+\t      ih_fake->next_this_file = 0;\n+\t      ih_fake->foundhere = ABSOLUTE_PATH;  /* well sort of ... */\n+\t      ih_fake->name = pend->arg;\n+\t      ih_fake->control_macro = 0;\n+\t      ih_fake->buf = (char *)-1;\n+\t      ih_fake->limit = 0;\n+\t      if (finclude (pfile, fd, ih_fake))\n+\t        output_line_command (pfile, 0, enter_file);\n+\t    }\n+\t}\n+    }\n+  pfile->no_record_file--;\n+\n+  /* Free the pending list.  */\n+  for (pend = opts->pending;  pend; )\n+    {\n+      struct cpp_pending *next = pend->next;\n+      free (pend);\n+      pend = next;\n+    }\n+  opts->pending = NULL;\n+\n+  return 1;\n+}\n+\n+/* This is called at the end of preprocessing.  It pops the\n+   last buffer and writes dependency output.  It should also\n+   clear macro definitions, such that you could call cpp_start_read\n+   with a new filename to restart processing. */\n+void\n+cpp_finish (pfile)\n+     cpp_reader *pfile;\n+{\n+  struct cpp_options *opts = CPP_OPTIONS (pfile);\n+\n+  if (CPP_PREV_BUFFER (CPP_BUFFER (pfile)) != CPP_NULL_BUFFER (pfile))\n+    cpp_fatal (pfile,\n+\t       \"cpplib internal error: buffers still stacked in cpp_finish\");\n+  cpp_pop_buffer (pfile);\n+  \n+  if (opts->print_deps)\n+    {\n+      /* Stream on which to print the dependency information.  */\n+      FILE *deps_stream;\n+\n+      /* Don't actually write the deps file if compilation has failed.  */\n+      if (pfile->errors == 0)\n+\t{\n+\t  char *deps_mode = opts->print_deps_append ? \"a\" : \"w\";\n+\t  if (opts->deps_file == 0)\n+\t    deps_stream = stdout;\n+\t  else if ((deps_stream = fopen (opts->deps_file, deps_mode)) == 0)\n+\t    cpp_pfatal_with_name (pfile, opts->deps_file);\n+\t  fputs (pfile->deps_buffer, deps_stream);\n+\t  putc ('\\n', deps_stream);\n+\t  if (opts->deps_file)\n+\t    {\n+\t      if (ferror (deps_stream) || fclose (deps_stream) != 0)\n+\t\tcpp_fatal (pfile, \"I/O error on output\");\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* Handle one command-line option in (argc, argv).\n+   Can be called multiple times, to handle multiple sets of options.\n+   Returns number of strings consumed.  */\n+int\n+cpp_handle_option (pfile, argc, argv)\n+     cpp_reader *pfile;\n+     int argc;\n+     char **argv;\n+{\n+  struct cpp_options *opts = CPP_OPTIONS (pfile);\n+  int i = 0;\n+\n+  if (user_label_prefix == NULL)\n+    user_label_prefix = USER_LABEL_PREFIX;\n+\n+  if (argv[i][0] != '-') {\n+    if (opts->out_fname != NULL)\n+      {\n+\tprint_help ();\n+\tcpp_fatal (pfile, \"Too many arguments\");\n+      }\n+    else if (opts->in_fname != NULL)\n+      opts->out_fname = argv[i];\n+    else\n+      opts->in_fname = argv[i];\n+  } else {\n+    switch (argv[i][1]) {\n+      \n+    missing_filename:\n+      cpp_fatal (pfile, \"Filename missing after `%s' option\", argv[i]);\n+      return argc;\n+    missing_dirname:\n+      cpp_fatal (pfile, \"Directory name missing after `%s' option\", argv[i]);\n+      return argc;\n+      \n+    case 'f':\n+      if (!strcmp (argv[i], \"-fleading-underscore\"))\n+ \tuser_label_prefix = \"_\";\n+      else if (!strcmp (argv[i], \"-fno-leading-underscore\"))\n+ \tuser_label_prefix = \"\";\n+      break;\n+\n+    case 'I':\t\t\t/* Add directory to path for includes.  */\n+      if (!strcmp (argv[i] + 2, \"-\"))\n+        {\n+\t  if (! opts->ignore_srcdir)\n+\t    {\n+\t      opts->ignore_srcdir = 1;\n+\t      /* Don't use any preceding -I directories for #include <...>. */\n+\t      opts->quote_include = opts->bracket_include;\n+\t      opts->bracket_include = 0;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  char *fname;\n+\t  if (argv[i][2] != 0)\n+\t    fname = argv[i] + 2;\n+\t  else if (i + 1 == argc)\n+\t    goto missing_dirname;\n+\t  else\n+\t    fname = argv[++i];\n+\t  append_include_chain (pfile, &opts->bracket_include, fname, 0);\n+\t}\n+      break;\n+\n+    case 'i':\n+      /* Add directory to beginning of system include path, as a system\n+\t include directory. */\n+      if (!strcmp (argv[i], \"-isystem\"))\n+        {\n+\t  if (i + 1 == argc)\n+\t    goto missing_filename;\n+\t  append_include_chain (pfile, &opts->system_include, argv[++i], 1);\n+\t}\n+      /* Add directory to end of path for includes,\n+\t with the default prefix at the front of its name.  */\n+      else if (!strcmp (argv[i], \"-iwithprefix\"))\n+        {\n+\t  char *fname;\n+\t  if (i + 1 == argc)\n+\t    goto missing_dirname;\n+\t  ++i;\n+\n+\t  if (opts->include_prefix != 0)\n+\t    {\n+\t      fname = xmalloc (strlen (opts->include_prefix)\n+\t\t\t       + strlen (argv[i]) + 1);\n+\t      strcpy (fname, opts->include_prefix);\n+\t      strcat (fname, argv[i]);\n+\t    }\n+\t  else\n+\t    {\n+\t      fname = xmalloc (strlen (GCC_INCLUDE_DIR)\n+\t\t\t       + strlen (argv[i]) + 1);\n+\t      strcpy (fname, GCC_INCLUDE_DIR);\n+\t      /* Remove the `include' from /usr/local/lib/gcc.../include.  */\n+\t      if (!strcmp (fname + strlen (fname) - 8, \"/include\"))\n+\t\tfname[strlen (fname) - 7] = 0;\n+\t      strcat (fname, argv[i]);\n+\t    }\n+\t  \n+\t  append_include_chain (pfile, &opts->system_include, fname, 0);\n+      }\n+      /* Add directory to main path for includes,\n+\t with the default prefix at the front of its name.  */\n+      else if (!strcmp (argv[i], \"-iwithprefix\"))\n+        {\n+\t  char *fname;\n+\t  if (i + 1 == argc)\n+\t    goto missing_dirname;\n+\t  ++i;\n+\n+\t  if (opts->include_prefix != 0)\n+\t    {\n+\t      fname = xmalloc (strlen (opts->include_prefix)\n+\t\t\t       + strlen (argv[i]) + 1);\n+\t      strcpy (fname, opts->include_prefix);\n+\t      strcat (fname, argv[i]);\n+\t    }\n+\t  else\n+\t    {\n+\t      fname = xmalloc (strlen (GCC_INCLUDE_DIR)\n+\t\t\t       + strlen (argv[i]) + 1);\n+\t      strcpy (fname, GCC_INCLUDE_DIR);\n+\t      /* Remove the `include' from /usr/local/lib/gcc.../include.  */\n+\t      if (!strcmp (fname + strlen (fname) - 8, \"/include\"))\n+\t\tfname[strlen (fname) - 7] = 0;\n+\t      strcat (fname, argv[i]);\n+\t    }\n+\t  \n+\t  append_include_chain (pfile, &opts->bracket_include, fname, 0);\n+        }\n+      /* Add directory to end of path for includes.  */\n+      else if (!strcmp (argv[i], \"-idirafter\"))\n+        {\n+\t  if (i + 1 == argc)\n+\t    goto missing_dirname;\n+\t  append_include_chain (pfile, &opts->after_include, argv[++i], 0);\n+\t}\n+      else if (!strcmp (argv[i], \"-include\") || !strcmp (argv[i], \"-imacros\"))\n+        {\n+\t  if (i + 1 == argc)\n+\t    goto missing_filename;\n+\t  else\n+\t    push_pending (pfile, argv[i], argv[i+1]), i++;\n+        }\n+      else if (!strcmp (argv[i], \"-iprefix\"))\n+        {\n+\t  if (i + 1 == argc)\n+\t    goto missing_filename;\n+\t  else\n+\t      opts->include_prefix = argv[++i];\n+\t}\n+      else if (!strcmp (argv[i], \"-ifoutput\"))\n+\topts->output_conditionals = 1;\n+\n+      break;\n+      \n+    case 'o':\n+      if (opts->out_fname != NULL)\n+\t{\n+\t  cpp_fatal (pfile, \"Output filename specified twice\");\n+\t  return argc;\n+\t}\n+      if (i + 1 == argc)\n+\tgoto missing_filename;\n+      opts->out_fname = argv[++i];\n+      if (!strcmp (opts->out_fname, \"-\"))\n+\topts->out_fname = \"\";\n+      break;\n+      \n+    case 'p':\n+      if (!strcmp (argv[i], \"-pedantic\"))\n+\tCPP_PEDANTIC (pfile) = 1;\n+      else if (!strcmp (argv[i], \"-pedantic-errors\")) {\n+\tCPP_PEDANTIC (pfile) = 1;\n+\topts->pedantic_errors = 1;\n+      }\n+#if 0\n+      else if (!strcmp (argv[i], \"-pcp\")) {\n+\tchar *pcp_fname = argv[++i];\n+\tpcp_outfile = ((pcp_fname[0] != '-' || pcp_fname[1] != '\\0')\n+\t\t       ? fopen (pcp_fname, \"w\")\n+\t\t       : fdopen (dup (fileno (stdout)), \"w\"));\n+\tif (pcp_outfile == 0)\n+\t  cpp_pfatal_with_name (pfile, pcp_fname);\n+\tno_precomp = 1;\n+      }\n+#endif\n+      break;\n+      \n+    case 't':\n+      if (!strcmp (argv[i], \"-traditional\")) {\n+\topts->traditional = 1;\n+\topts->cplusplus_comments = 0;\n+      } else if (!strcmp (argv[i], \"-trigraphs\")) {\n+\tif (!opts->chill)\n+\t  opts->trigraphs = 1;\n+      }\n+      break;\n+      \n+    case 'l':\n+      if (! strcmp (argv[i], \"-lang-c\"))\n+\topts->cplusplus = 0, opts->cplusplus_comments = 1, opts->c89 = 0,\n+\t  opts->c9x = 1, opts->objc = 0;\n+      if (! strcmp (argv[i], \"-lang-c89\"))\n+\topts->cplusplus = 0, opts->cplusplus_comments = 0, opts->c89 = 1,\n+\t  opts->c9x = 0, opts->objc = 0;\n+      if (! strcmp (argv[i], \"-lang-c++\"))\n+\topts->cplusplus = 1, opts->cplusplus_comments = 1, opts->c89 = 0,\n+\t  opts->c9x = 0, opts->objc = 0;\n+      if (! strcmp (argv[i], \"-lang-objc\"))\n+\topts->cplusplus = 0, opts->cplusplus_comments = 1, opts->c89 = 0,\n+\t  opts->c9x = 0, opts->objc = 1;\n+      if (! strcmp (argv[i], \"-lang-objc++\"))\n+\topts->cplusplus = 1, opts->cplusplus_comments = 1, opts->c89 = 0,\n+\t  opts->c9x = 0, opts->objc = 1;\n+      if (! strcmp (argv[i], \"-lang-asm\"))\n+\topts->lang_asm = 1;\n+      if (! strcmp (argv[i], \"-lint\"))\n+\topts->for_lint = 1;\n+      if (! strcmp (argv[i], \"-lang-chill\"))\n+\topts->objc = 0, opts->cplusplus = 0, opts->chill = 1,\n+\t  opts->traditional = 1, opts->trigraphs = 0;\n+      break;\n+      \n+    case '+':\n+      opts->cplusplus = 1, opts->cplusplus_comments = 1;\n+      break;\n+\n+    case 's':\n+      if (!strcmp (argv[i], \"-std=iso9899:1990\")\n+\t  || !strcmp (argv[i], \"-std=iso9899:199409\")\n+\t  || !strcmp (argv[i], \"-std=c89\")\n+\t  || !strcmp (argv[i], \"-std=gnu89\"))\n+\t  opts->cplusplus = 0, opts->cplusplus_comments = 0,\n+\t    opts->c89 = 1, opts->c9x = 0, opts->objc = 0;\n+      else if (!strcmp (argv[i], \"-std=iso9899:199x\")\n+\t       || !strcmp (argv[i], \"-std=c9x\")\n+\t       || !strcmp (argv[i], \"-std=gnu9x\"))\n+\topts->cplusplus = 0, opts->cplusplus_comments = 1, opts->c89 = 0,\n+\t  opts->c9x = 1, opts->objc = 0;\n+      break;\n+\n+    case 'w':\n+      opts->inhibit_warnings = 1;\n+      break;\n+      \n+    case 'W':\n+      if (!strcmp (argv[i], \"-Wtrigraphs\"))\n+\topts->warn_trigraphs = 1;\n+      else if (!strcmp (argv[i], \"-Wno-trigraphs\"))\n+\topts->warn_trigraphs = 0;\n+      else if (!strcmp (argv[i], \"-Wcomment\"))\n+\topts->warn_comments = 1;\n+      else if (!strcmp (argv[i], \"-Wno-comment\"))\n+\topts->warn_comments = 0;\n+      else if (!strcmp (argv[i], \"-Wcomments\"))\n+\topts->warn_comments = 1;\n+      else if (!strcmp (argv[i], \"-Wno-comments\"))\n+\topts->warn_comments = 0;\n+      else if (!strcmp (argv[i], \"-Wtraditional\"))\n+\topts->warn_stringify = 1;\n+      else if (!strcmp (argv[i], \"-Wno-traditional\"))\n+\topts->warn_stringify = 0;\n+      else if (!strcmp (argv[i], \"-Wundef\"))\n+\topts->warn_undef = 1;\n+      else if (!strcmp (argv[i], \"-Wno-undef\"))\n+\topts->warn_undef = 0;\n+      else if (!strcmp (argv[i], \"-Wimport\"))\n+\topts->warn_import = 1;\n+      else if (!strcmp (argv[i], \"-Wno-import\"))\n+\topts->warn_import = 0;\n+      else if (!strcmp (argv[i], \"-Werror\"))\n+\topts->warnings_are_errors = 1;\n+      else if (!strcmp (argv[i], \"-Wno-error\"))\n+\topts->warnings_are_errors = 0;\n+      else if (!strcmp (argv[i], \"-Wall\"))\n+\t{\n+\t  opts->warn_trigraphs = 1;\n+\t  opts->warn_comments = 1;\n+\t}\n+      break;\n+      \n+    case 'M':\n+      /* The style of the choices here is a bit mixed.\n+\t The chosen scheme is a hybrid of keeping all options in one string\n+\t and specifying each option in a separate argument:\n+\t -M|-MM|-MD file|-MMD file [-MG].  An alternative is:\n+\t -M|-MM|-MD file|-MMD file|-MG|-MMG; or more concisely:\n+\t -M[M][G][D file].  This is awkward to handle in specs, and is not\n+\t as extensible.  */\n+      /* ??? -MG must be specified in addition to one of -M or -MM.\n+\t This can be relaxed in the future without breaking anything.\n+\t The converse isn't true.  */\n+      \n+      /* -MG isn't valid with -MD or -MMD.  This is checked for later.  */\n+      if (!strcmp (argv[i], \"-MG\"))\n+\t{\n+\t  opts->print_deps_missing_files = 1;\n+\t  break;\n+\t}\n+      if (!strcmp (argv[i], \"-M\"))\n+\topts->print_deps = 2;\n+      else if (!strcmp (argv[i], \"-MM\"))\n+\topts->print_deps = 1;\n+      else if (!strcmp (argv[i], \"-MD\"))\n+\topts->print_deps = 2;\n+      else if (!strcmp (argv[i], \"-MMD\"))\n+\topts->print_deps = 1;\n+      /* For -MD and -MMD options, write deps on file named by next arg.  */\n+      if (!strcmp (argv[i], \"-MD\") || !strcmp (argv[i], \"-MMD\"))\n+\t{\n+\t  if (i+1 == argc)\n+\t    goto missing_filename;\n+\t  opts->deps_file = argv[++i];\n+\t}\n+      else\n+\t{\n+\t  /* For -M and -MM, write deps on standard output\n+\t     and suppress the usual output.  */\n+\t  opts->no_output = 1;\n+\t}\t  \n+      break;\n+      \n+    case 'd':\n+      {\n+\tchar *p = argv[i] + 2;\n+\tchar c;\n+\twhile ((c = *p++) != 0) {\n+\t  /* Arg to -d specifies what parts of macros to dump */\n+\t  switch (c) {\n+\t  case 'M':\n+\t    opts->dump_macros = dump_only;\n+\t    opts->no_output = 1;\n+\t    break;\n+\t  case 'N':\n+\t    opts->dump_macros = dump_names;\n+\t    break;\n+\t  case 'D':\n+\t    opts->dump_macros = dump_definitions;\n+\t    break;\n+\t  case 'I':\n+\t    opts->dump_includes = 1;\n+\t    break;\n+\t  }\n+\t}\n+      }\n+    break;\n+    \n+    case 'g':\n+      if (argv[i][2] == '3')\n+\topts->debug_output = 1;\n+      break;\n+      \n+    case '-':\n+      if (strcmp (argv[i], \"--help\") != 0)\n+\treturn i;\n+      print_help ();\n+      break;\n+\t\n+    case 'v':\n+      cpp_notice (\"GNU CPP version %s\", version_string);\n+#ifdef TARGET_VERSION\n+      TARGET_VERSION;\n+#endif\n+      fprintf (stderr, \"\\n\");\n+      opts->verbose = 1;\n+      break;\n+      \n+    case 'H':\n+      opts->print_include_names = 1;\n+      break;\n+      \n+    case 'D':\n+      if (argv[i][2] != 0)\n+\tpush_pending (pfile, \"-D\", argv[i] + 2);\n+      else if (i + 1 == argc)\n+\t{\n+\t  cpp_fatal (pfile, \"Macro name missing after -D option\");\n+\t  return argc;\n+\t}\n+      else\n+\ti++, push_pending (pfile, \"-D\", argv[i]);\n+      break;\n+      \n+    case 'A':\n+      {\n+\tchar *p;\n+\t\n+\tif (argv[i][2] != 0)\n+\t  p = argv[i] + 2;\n+\telse if (i + 1 == argc)\n+\t  {\n+\t    cpp_fatal (pfile, \"Assertion missing after -A option\");\n+\t    return argc;\n+\t  }\n+\telse\n+\t  p = argv[++i];\n+\t\n+\tif (!strcmp (p, \"-\")) {\n+\t  struct cpp_pending **ptr;\n+\t  /* -A- eliminates all predefined macros and assertions.\n+\t     Let's include also any that were specified earlier\n+\t     on the command line.  That way we can get rid of any\n+\t     that were passed automatically in from GCC.  */\n+\t  opts->inhibit_predefs = 1;\n+\t  for (ptr = &opts->pending; *ptr != NULL; )\n+\t    {\n+\t      struct cpp_pending *pend = *ptr;\n+\t      if (pend->cmd && pend->cmd[0] == '-'\n+\t\t  && (pend->cmd[1] == 'D' || pend->cmd[1] == 'A'))\n+\t\t{\n+\t\t  *ptr = pend->next;\n+\t\t  free (pend);\n+\t\t}\n+\t      else\n+\t\tptr = &pend->next;\n+\t    }\n+\t} else {\n+\t  push_pending (pfile, \"-A\", p);\n+\t}\n+      }\n+    break;\n+    \n+    case 'U':\t\t/* JF #undef something */\n+      if (argv[i][2] != 0)\n+\tpush_pending (pfile, \"-U\", argv[i] + 2);\n+      else if (i + 1 == argc)\n+\t{\n+\t  cpp_fatal (pfile, \"Macro name missing after -U option\");\n+\t  return argc;\n+\t}\n+      else\n+\tpush_pending (pfile, \"-U\", argv[i+1]), i++;\n+      break;\n+      \n+    case 'C':\n+      opts->put_out_comments = 1;\n+      break;\n+      \n+    case 'E':\t\t\t/* -E comes from cc -E; ignore it.  */\n+      break;\n+      \n+    case 'P':\n+      opts->no_line_commands = 1;\n+      break;\n+      \n+    case '$':\t\t\t/* Don't include $ in identifiers.  */\n+      opts->dollars_in_ident = 0;\n+      break;\n+      \n+    case 'n':\n+      if (!strcmp (argv[i], \"-nostdinc\"))\n+\t/* -nostdinc causes no default include directories.\n+\t   You must specify all include-file directories with -I.  */\n+\topts->no_standard_includes = 1;\n+      else if (!strcmp (argv[i], \"-nostdinc++\"))\n+\t/* -nostdinc++ causes no default C++-specific include directories. */\n+\topts->no_standard_cplusplus_includes = 1;\n+#if 0\n+      else if (!strcmp (argv[i], \"-noprecomp\"))\n+\tno_precomp = 1;\n+#endif\n+      break;\n+      \n+    case 'r':\n+      if (!strcmp (argv[i], \"-remap\"))\n+\topts->remap = 1;\n+      break;\n+      \n+    case 'u':\n+      /* Sun compiler passes undocumented switch \"-undef\".\n+\t Let's assume it means to inhibit the predefined symbols.  */\n+      opts->inhibit_predefs = 1;\n+      break;\n+      \n+    case '\\0': /* JF handle '-' as file name meaning stdin or stdout */\n+      if (opts->in_fname == NULL) {\n+\topts->in_fname = \"\";\n+\tbreak;\n+      } else if (opts->out_fname == NULL) {\n+\topts->out_fname = \"\";\n+\tbreak;\n+      }\t/* else fall through into error */\n+\n+    default:\n+      return i;\n+    }\n+  }\n+\n+  return i + 1;\n+}\n+\n+/* Handle command-line options in (argc, argv).\n+   Can be called multiple times, to handle multiple sets of options.\n+   Returns if an unrecognized option is seen.\n+   Returns number of strings consumed.  */\n+\n+int\n+cpp_handle_options (pfile, argc, argv)\n+     cpp_reader *pfile;\n+     int argc;\n+     char **argv;\n+{\n+  int i;\n+  int strings_processed;\n+  for (i = 0; i < argc; i += strings_processed)\n+    {\n+      strings_processed = cpp_handle_option (pfile, argc - i, argv + i);\n+      if (strings_processed == 0)\n+\tbreak;\n+    }\n+  return i;\n+}\n+\n+static void\n+print_help ()\n+{\n+  cpp_notice (\"Usage: %s [switches] input output\\n\", progname);\n+  fputs (_(\"\\\n+Switches:\\n\\\n+  -include <file>           Include the contents of <file> before other files\\n\\\n+  -imacros <file>           Accept definition of macros in <file>\\n\\\n+  -iprefix <path>           Specify <path> as a prefix for next two options\\n\\\n+  -iwithprefix <dir>        Add <dir> to the end of the system include path\\n\\\n+  -iwithprefixbefore <dir>  Add <dir> to the end of the main include path\\n\\\n+  -isystem <dir>            Add <dir> to the start of the system include path\\n\\\n+  -idirafter <dir>          Add <dir> to the end of the system include path\\n\\\n+  -I <dir>                  Add <dir> to the end of the main include path\\n\\\n+  -nostdinc                 Do not search system include directories\\n\\\n+                             (dirs specified with -isystem will still be used)\\n\\\n+  -nostdinc++               Do not search system include directories for C++\\n\\\n+  -o <file>                 Put output into <file>\\n\\\n+  -pedantic                 Issue all warnings demanded by strict ANSI C\\n\\\n+  -traditional              Follow K&R pre-processor behaviour\\n\\\n+  -trigraphs                Support ANSI C trigraphs\\n\\\n+  -lang-c                   Assume that the input sources are in C\\n\\\n+  -lang-c89                 Assume that the input sources are in C89\\n\\\n+  -lang-c++                 Assume that the input sources are in C++\\n\\\n+  -lang-objc                Assume that the input sources are in ObjectiveC\\n\\\n+  -lang-objc++              Assume that the input sources are in ObjectiveC++\\n\\\n+  -lang-asm                 Assume that the input sources are in assembler\\n\\\n+  -lang-chill               Assume that the input sources are in Chill\\n\\\n+  -std=<std name>           Specify the conformance standard; one of:\\n\\\n+                            gnu89, gnu9x, c89, c9x, iso9899:1990,\\n\\\n+                            iso9899:199409, iso9899:199x\\n\\\n+\n+  -+                        Allow parsing of C++ style features\\n\\\n+  -w                        Inhibit warning messages\\n\\\n+  -Wtrigraphs               Warn if trigraphs are encountered\\n\\\n+  -Wno-trigraphs            Do not warn about trigraphs\\n\\\n+  -Wcomment{s}              Warn if one comment starts inside another\\n\\\n+  -Wno-comment{s}           Do not warn about comments\\n\\\n+  -Wtraditional             Warn if a macro argument is/would be turned into\\n\\\n+                             a string if -traditional is specified\\n\\\n+  -Wno-traditional          Do not warn about stringification\\n\\\n+  -Wundef                   Warn if an undefined macro is used by #if\\n\\\n+  -Wno-undef                Do not warn about testing undefined macros\\n\\\n+  -Wimport                  Warn about the use of the #import directive\\n\\\n+  -Wno-import               Do not warn about the use of #import\\n\\\n+  -Werror                   Treat all warnings as errors\\n\\\n+  -Wno-error                Do not treat warnings as errors\\n\\\n+  -Wall                     Enable all preprocessor warnings\\n\\\n+  -M                        Generate make dependencies\\n\\\n+  -MM                       As -M, but ignore system header files\\n\\\n+  -MD                       As -M, but put output in a .d file\\n\\\n+  -MMD                      As -MD, but ignore system header files\\n\\\n+  -MG                       Treat missing header file as generated files\\n\\\n+  -g                        Include #define and #undef directives in the output\\n\\\n+  -D<macro>                 Define a <macro> with string '1' as its value\\n\\\n+  -D<macro>=<val>           Define a <macro> with <val> as its value\\n\\\n+  -A<question> (<answer>)   Assert the <answer> to <question>\\n\\\n+  -U<macro>                 Undefine <macro> \\n\\\n+  -u or -undef              Do not predefine any macros\\n\\\n+  -v                        Display the version number\\n\\\n+  -H                        Print the name of header files as they are used\\n\\\n+  -C                        Do not discard comments\\n\\\n+  -dM                       Display a list of macro definitions active at end\\n\\\n+  -dD                       Preserve macro definitions in output\\n\\\n+  -dN                       As -dD except that only the names are preserved\\n\\\n+  -dI                       Include #include directives in the output\\n\\\n+  -ifoutput                 Describe skipped code blocks in output \\n\\\n+  -P                        Do not generate #line directives\\n\\\n+  -$                        Do not allow '$' in identifiers\\n\\\n+  -remap                    Remap file names when including files.\\n\\\n+  -h or --help              Display this information\\n\\\n+\"), stdout);\n+}"}, {"sha": "d7499ddfe603626ef82f1623bebd71e00df39a39", "filename": "gcc/cpplib.c", "status": "modified", "additions": 245, "deletions": 3153, "changes": 3398, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de1e2a9787e105521817b86422b50bd410560fe/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de1e2a9787e105521817b86422b50bd410560fe/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=6de1e2a9787e105521817b86422b50bd410560fe"}, {"sha": "a943939829f1532677f9aa638c1b06cfe3d27457", "filename": "gcc/cpplib.h", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de1e2a9787e105521817b86422b50bd410560fe/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de1e2a9787e105521817b86422b50bd410560fe/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=6de1e2a9787e105521817b86422b50bd410560fe", "patch": "@@ -637,11 +637,19 @@ struct definition {\n   } args;\n };\n \n-extern const unsigned char is_idstart[256];\n-extern const unsigned char is_idchar[256];\n-extern const unsigned char is_hor_space[256];\n-extern const unsigned char is_space[256];\n-extern const unsigned char trigraph_table[256];\n+/* These tables are not really `const', but they are only modified at\n+   initialization time, in a separate translation unit from the rest\n+   of the library.  We let the rest of the library think they are `const'\n+   to get better code and some additional sanity checks.  */\n+#ifndef FAKE_CONST\n+#define FAKE_CONST const\n+#endif\n+extern FAKE_CONST unsigned char is_idstart[256];\n+extern FAKE_CONST unsigned char is_idchar[256];\n+extern FAKE_CONST unsigned char is_hor_space[256];\n+extern FAKE_CONST unsigned char is_space[256];\n+extern FAKE_CONST unsigned char trigraph_table[256];\n+#undef FAKE_CONST\n \n /* Stack of conditionals currently in progress\n    (including both successful and failing conditionals).  */\n@@ -667,8 +675,9 @@ typedef struct if_stack IF_STACK_FRAME;\n \n extern void cpp_buf_line_and_col PARAMS((cpp_buffer *, long *, long *));\n extern cpp_buffer* cpp_file_buffer PARAMS((cpp_reader *));\n-extern void cpp_define PARAMS ((cpp_reader*, unsigned char *));\n+extern void cpp_define PARAMS ((cpp_reader *, unsigned char *));\n extern void cpp_assert PARAMS ((cpp_reader *, unsigned char *));\n+extern void cpp_undef  PARAMS ((cpp_reader *, unsigned char *));\n \n extern void cpp_error PVPROTO ((cpp_reader *, const char *, ...))\n   ATTRIBUTE_PRINTF_2;\n@@ -705,6 +714,16 @@ extern int scan_decls PARAMS ((cpp_reader *, int, char **));\n extern void skip_rest_of_line PARAMS ((cpp_reader *));\n extern void cpp_finish PARAMS ((cpp_reader *));\n \n+extern void quote_string\t\tPARAMS ((cpp_reader *, const char *));\n+extern void cpp_expand_to_buffer\tPARAMS ((cpp_reader *, U_CHAR *, int));\n+extern void cpp_scan_buffer\t\tPARAMS ((cpp_reader *));\n+extern int check_macro_name\t\tPARAMS ((cpp_reader *, U_CHAR *, int));\n+\n+/* Last arg to output_line_command.  */\n+enum file_change_code {same_file, enter_file, leave_file};\n+extern void output_line_command\t\tPARAMS ((cpp_reader *, int,\n+\t\t\t\t\t\t enum file_change_code));\n+\n /* From cpperror.c */\n extern void cpp_fatal PVPROTO ((cpp_reader *, const char *, ...))\n   ATTRIBUTE_PRINTF_2;\n@@ -729,9 +748,6 @@ extern int finclude\t\t\tPROTO ((cpp_reader *, int,\n extern void deps_output\t\t\tPROTO ((cpp_reader *, char *, int));\n extern struct include_hash *include_hash PROTO ((cpp_reader *, char *, int));\n \n-/* cppinit.c */\n-extern void initialize_char_syntax\tPROTO ((int));\n-\n #ifndef INCLUDE_LEN_FUDGE\n #define INCLUDE_LEN_FUDGE 0\n #endif"}]}