{"sha": "50ba28bb635a2a4d451efc108634f9ae0cb8b0a4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTBiYTI4YmI2MzVhMmE0ZDQ1MWVmYzEwODYzNGY5YWUwY2I4YjBhNA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2010-12-15T19:47:44Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2010-12-15T19:47:44Z"}, "message": "Push hash table identity check down to subtypes.\n\nFrom-SVN: r167870", "tree": {"sha": "278e70b28a30a4e05150de239588bc1ab89e273f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/278e70b28a30a4e05150de239588bc1ab89e273f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/50ba28bb635a2a4d451efc108634f9ae0cb8b0a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50ba28bb635a2a4d451efc108634f9ae0cb8b0a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50ba28bb635a2a4d451efc108634f9ae0cb8b0a4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50ba28bb635a2a4d451efc108634f9ae0cb8b0a4/comments", "author": null, "committer": null, "parents": [{"sha": "53f672caaac6f94342d74119d927c790bfca9e9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53f672caaac6f94342d74119d927c790bfca9e9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/53f672caaac6f94342d74119d927c790bfca9e9d"}], "stats": {"total": 169, "additions": 81, "deletions": 88}, "files": [{"sha": "18a9182ce24d7c06c2e3d59b6d511aa2a22df81a", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ba28bb635a2a4d451efc108634f9ae0cb8b0a4/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ba28bb635a2a4d451efc108634f9ae0cb8b0a4/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=50ba28bb635a2a4d451efc108634f9ae0cb8b0a4", "patch": "@@ -6172,7 +6172,7 @@ Bound_method_expression::do_check_types(Gogo*)\n \t\t     ? this->expr_type_\n \t\t     : this->expr_->type());\n       etype = etype->deref();\n-      if (!Type::are_identical(rtype, etype, NULL))\n+      if (!Type::are_identical(rtype, etype, true, NULL))\n \tthis->report_error(_(\"method type does not match object type\"));\n     }\n }\n@@ -6849,7 +6849,7 @@ Builtin_call_expression::do_complex_constant_value(mpfr_t real, mpfr_t imag,\n       bool ret = false;\n       Type* itype;\n       if (args->back()->float_constant_value(i, &itype)\n-\t  && Type::are_identical(rtype, itype, NULL))\n+\t  && Type::are_identical(rtype, itype, false, NULL))\n \t{\n \t  mpfr_set(real, r, GMP_RNDN);\n \t  mpfr_set(imag, i, GMP_RNDN);\n@@ -7228,7 +7228,7 @@ Builtin_call_expression::do_check_types(Gogo*)\n \t    break;\n \t  }\n \n-\tif (!Type::are_identical(e1, e2, NULL))\n+\tif (!Type::are_identical(e1, e2, true, NULL))\n \t  this->report_error(_(\"element types must be the same\"));\n       }\n       break;\n@@ -7282,7 +7282,7 @@ Builtin_call_expression::do_check_types(Gogo*)\n \t\t || args->back()->type()->is_error_type())\n \t  this->set_is_error();\n \telse if (!Type::are_identical(args->front()->type(),\n-\t\t\t\t      args->back()->type(), NULL))\n+\t\t\t\t      args->back()->type(), true, NULL))\n \t  this->report_error(_(\"cmplx arguments must have identical types\"));\n \telse if (args->front()->type()->float_type() == NULL)\n \t  this->report_error(_(\"cmplx arguments must have \"\n@@ -8085,7 +8085,7 @@ Call_expression::is_compatible_varargs_argument(Named_object* function,\n   Array_type* param_at = param_type->array_type();\n   if (param_at != NULL\n       && Type::are_identical(var_at->element_type(),\n-\t\t\t     param_at->element_type(), NULL))\n+\t\t\t     param_at->element_type(), true, NULL))\n     return true;\n   error_at(arg->location(), \"... mismatch: passing ...T as ...\");\n   *issued_error = true;"}, {"sha": "4faae853ea1335109f4e4776842ec05903059c86", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 64, "deletions": 68, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ba28bb635a2a4d451efc108634f9ae0cb8b0a4/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ba28bb635a2a4d451efc108634f9ae0cb8b0a4/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=50ba28bb635a2a4d451efc108634f9ae0cb8b0a4", "patch": "@@ -301,16 +301,19 @@ Type::do_traverse(Traverse*)\n   return TRAVERSE_CONTINUE;\n }\n \n-// Return whether two types are identical.  If REASON is not NULL,\n-// optionally set *REASON to the reason the types are not identical.\n+// Return whether two types are identical.  If ERRORS_ARE_IDENTICAL,\n+// then return true for all erroneous types; this is used to avoid\n+// cascading errors.  If REASON is not NULL, optionally set *REASON to\n+// the reason the types are not identical.\n \n bool\n-Type::are_identical(const Type* t1, const Type* t2, std::string* reason)\n+Type::are_identical(const Type* t1, const Type* t2, bool errors_are_identical,\n+\t\t    std::string* reason)\n {\n   if (t1 == NULL || t2 == NULL)\n     {\n-      // Something is wrong.  Return true to avoid cascading errors.\n-      return true;\n+      // Something is wrong.\n+      return errors_are_identical ? true : t1 == t2;\n     }\n \n   // Skip defined forward declarations.\n@@ -320,15 +323,18 @@ Type::are_identical(const Type* t1, const Type* t2, std::string* reason)\n   if (t1 == t2)\n     return true;\n \n-  // An undefined forward declaration is an error, so we return true\n-  // to avoid cascading errors.\n+  // An undefined forward declaration is an error.\n   if (t1->forward_declaration_type() != NULL\n       || t2->forward_declaration_type() != NULL)\n-    return true;\n+    return errors_are_identical;\n \n   // Avoid cascading errors with error types.\n   if (t1->is_error_type() || t2->is_error_type())\n-    return true;\n+    {\n+      if (errors_are_identical)\n+\treturn true;\n+      return t1->is_error_type() && t2->is_error_type();\n+    }\n \n   // Get a good reason for the sink type.  Note that the sink type on\n   // the left hand side of an assignment is handled in are_assignable.\n@@ -368,70 +374,45 @@ Type::are_identical(const Type* t1, const Type* t2, std::string* reason)\n     case TYPE_FUNCTION:\n       return t1->function_type()->is_identical(t2->function_type(),\n \t\t\t\t\t       false,\n+\t\t\t\t\t       errors_are_identical,\n \t\t\t\t\t       reason);\n \n     case TYPE_POINTER:\n-      return Type::are_identical(t1->points_to(), t2->points_to(), reason);\n+      return Type::are_identical(t1->points_to(), t2->points_to(),\n+\t\t\t\t errors_are_identical, reason);\n \n     case TYPE_STRUCT:\n-      return t1->struct_type()->is_identical(t2->struct_type());\n+      return t1->struct_type()->is_identical(t2->struct_type(),\n+\t\t\t\t\t     errors_are_identical);\n \n     case TYPE_ARRAY:\n-      return t1->array_type()->is_identical(t2->array_type());\n+      return t1->array_type()->is_identical(t2->array_type(),\n+\t\t\t\t\t    errors_are_identical);\n \n     case TYPE_MAP:\n-      return t1->map_type()->is_identical(t2->map_type());\n+      return t1->map_type()->is_identical(t2->map_type(),\n+\t\t\t\t\t  errors_are_identical);\n \n     case TYPE_CHANNEL:\n-      return t1->channel_type()->is_identical(t2->channel_type());\n+      return t1->channel_type()->is_identical(t2->channel_type(),\n+\t\t\t\t\t      errors_are_identical);\n \n     case TYPE_INTERFACE:\n-      return t1->interface_type()->is_identical(t2->interface_type());\n+      return t1->interface_type()->is_identical(t2->interface_type(),\n+\t\t\t\t\t\terrors_are_identical);\n \n     default:\n       gcc_unreachable();\n     }\n }\n \n-// Return true if two types are identical when it comes to storing\n-// them in a hash table.  This differs from Type::are_identical with\n-// regard to how we handle error types.  We want to treat error types\n-// as identical to other types when it comes to reporting\n-// compatibility errors, but we want to treat them as different when\n-// it comes to storing them in a hash table.\n-\n-bool\n-Type::are_identical_for_hash_table(const Type* t1, const Type *t2)\n-{\n-  if (t1 == NULL || t2 == NULL)\n-    return t1 == t2;\n-\n-  t1 = t1->forwarded();\n-  t2 = t2->forwarded();\n-\n-  if (t1 == t2)\n-    return true;\n-\n-  // Undefined forward declarations are only equal to themselves.\n-  if (t1->forward_declaration_type() != NULL\n-      || t2->forward_declaration_type() != NULL)\n-    return false;\n-\n-  // The error type is only equal to the error type.\n-  if (t1->is_error_type() || t2->is_error_type())\n-    return t1->is_error_type() && t2->is_error_type();\n-\n-  // Otherwise we can use the usual identity check.\n-  return Type::are_identical(t1, t2, NULL);\n-}\n-\n // Return true if it's OK to have a binary operation with types LHS\n // and RHS.  This is not used for shifts or comparisons.\n \n bool\n Type::are_compatible_for_binop(const Type* lhs, const Type* rhs)\n {\n-  if (Type::are_identical(lhs, rhs, NULL))\n+  if (Type::are_identical(lhs, rhs, true, NULL))\n     return true;\n \n   // A constant of abstract bool type may be mixed with any bool type.\n@@ -513,14 +494,14 @@ Type::are_assignable(const Type* lhs, const Type* rhs, std::string* reason)\n     }\n \n   // Identical types are assignable.\n-  if (Type::are_identical(lhs, rhs, reason))\n+  if (Type::are_identical(lhs, rhs, true, reason))\n     return true;\n \n   // The types are assignable if they have identical underlying types\n   // and either LHS or RHS is not a named type.\n   if (((lhs->named_type() != NULL && rhs->named_type() == NULL)\n        || (rhs->named_type() != NULL && lhs->named_type() == NULL))\n-      && Type::are_identical(lhs->base(), rhs->base(), reason))\n+      && Type::are_identical(lhs->base(), rhs->base(), true, reason))\n     return true;\n \n   // The types are assignable if LHS is an interface type and RHS\n@@ -547,6 +528,7 @@ Type::are_assignable(const Type* lhs, const Type* rhs, std::string* reason)\n       && (lhs->named_type() == NULL || rhs->named_type() == NULL)\n       && Type::are_identical(lhs->channel_type()->element_type(),\n \t\t\t     rhs->channel_type()->element_type(),\n+\t\t\t     true,\n \t\t\t     reason))\n     return true;\n \n@@ -609,7 +591,7 @@ Type::are_convertible(const Type* lhs, const Type* rhs, std::string* reason)\n   // The types are convertible if they have identical underlying\n   // types.\n   if ((lhs->named_type() != NULL || rhs->named_type() != NULL)\n-      && Type::are_identical(lhs->base(), rhs->base(), reason))\n+      && Type::are_identical(lhs->base(), rhs->base(), true, reason))\n     return true;\n \n   // The types are convertible if they are both unnamed pointer types\n@@ -622,6 +604,7 @@ Type::are_convertible(const Type* lhs, const Type* rhs, std::string* reason)\n \t  || rhs->points_to()->named_type() != NULL)\n       && Type::are_identical(lhs->points_to()->base(),\n \t\t\t     rhs->points_to()->base(),\n+\t\t\t     true,\n \t\t\t     reason))\n     return true;\n \n@@ -2352,7 +2335,7 @@ bool\n Function_type::is_valid_redeclaration(const Function_type* t,\n \t\t\t\t      std::string* reason) const\n {\n-  if (!this->is_identical(t, false, reason))\n+  if (!this->is_identical(t, false, true, reason))\n     return false;\n \n   // A redeclaration of a function is required to use the same names\n@@ -2436,6 +2419,7 @@ Function_type::is_valid_redeclaration(const Function_type* t,\n \n bool\n Function_type::is_identical(const Function_type* t, bool ignore_receiver,\n+\t\t\t    bool errors_are_identical,\n \t\t\t    std::string* reason) const\n {\n   if (!ignore_receiver)\n@@ -2450,7 +2434,8 @@ Function_type::is_identical(const Function_type* t, bool ignore_receiver,\n \t}\n       if (r1 != NULL)\n \t{\n-\t  if (!Type::are_identical(r1->type(), r2->type(), reason))\n+\t  if (!Type::are_identical(r1->type(), r2->type(), errors_are_identical,\n+\t\t\t\t   reason))\n \t    {\n \t      if (reason != NULL && !reason->empty())\n \t\t*reason = \"receiver: \" + *reason;\n@@ -2481,7 +2466,8 @@ Function_type::is_identical(const Function_type* t, bool ignore_receiver,\n \t      return false;\n \t    }\n \n-\t  if (!Type::are_identical(p1->type(), p2->type(), NULL))\n+\t  if (!Type::are_identical(p1->type(), p2->type(),\n+\t\t\t\t   errors_are_identical, NULL))\n \t    {\n \t      if (reason != NULL)\n \t\t*reason = _(\"different parameter types\");\n@@ -2525,7 +2511,8 @@ Function_type::is_identical(const Function_type* t, bool ignore_receiver,\n \t      return false;\n \t    }\n \n-\t  if (!Type::are_identical(res1->type(), res2->type(), NULL))\n+\t  if (!Type::are_identical(res1->type(), res2->type(),\n+\t\t\t\t   errors_are_identical, NULL))\n \t    {\n \t      if (reason != NULL)\n \t\t*reason = _(\"different result types\");\n@@ -3445,7 +3432,8 @@ Struct_type::do_has_pointer() const\n // Whether this type is identical to T.\n \n bool\n-Struct_type::is_identical(const Struct_type* t) const\n+Struct_type::is_identical(const Struct_type* t,\n+\t\t\t  bool errors_are_identical) const\n {\n   const Struct_field_list* fields1 = this->fields();\n   const Struct_field_list* fields2 = t->fields();\n@@ -3461,7 +3449,8 @@ Struct_type::is_identical(const Struct_type* t) const\n       if (pf1->field_name() != pf2->field_name())\n \treturn false;\n       if (pf1->is_anonymous() != pf2->is_anonymous()\n-\t  || !Type::are_identical(pf1->type(), pf2->type(), NULL))\n+\t  || !Type::are_identical(pf1->type(), pf2->type(),\n+\t\t\t\t  errors_are_identical, NULL))\n \treturn false;\n       if (!pf1->has_tag())\n \t{\n@@ -4142,9 +4131,10 @@ Type::make_struct_type(Struct_field_list* fields,\n // Whether two array types are identical.\n \n bool\n-Array_type::is_identical(const Array_type* t) const\n+Array_type::is_identical(const Array_type* t, bool errors_are_identical) const\n {\n-  if (!Type::are_identical(this->element_type(), t->element_type(), NULL))\n+  if (!Type::are_identical(this->element_type(), t->element_type(),\n+\t\t\t   errors_are_identical, NULL))\n     return false;\n \n   Expression* l1 = this->length();\n@@ -4960,10 +4950,12 @@ Map_type::do_verify()\n // Whether two map types are identical.\n \n bool\n-Map_type::is_identical(const Map_type* t) const\n+Map_type::is_identical(const Map_type* t, bool errors_are_identical) const\n {\n-  return (Type::are_identical(this->key_type(), t->key_type(), NULL)\n-\t  && Type::are_identical(this->val_type(), t->val_type(), NULL));\n+  return (Type::are_identical(this->key_type(), t->key_type(),\n+\t\t\t      errors_are_identical, NULL)\n+\t  && Type::are_identical(this->val_type(), t->val_type(),\n+\t\t\t\t errors_are_identical, NULL));\n }\n \n // Hash code.\n@@ -5248,9 +5240,11 @@ Channel_type::do_hash_for_method(Gogo* gogo) const\n // Whether this type is the same as T.\n \n bool\n-Channel_type::is_identical(const Channel_type* t) const\n+Channel_type::is_identical(const Channel_type* t,\n+\t\t\t   bool errors_are_identical) const\n {\n-  if (!Type::are_identical(this->element_type(), t->element_type(), NULL))\n+  if (!Type::are_identical(this->element_type(), t->element_type(),\n+\t\t\t   errors_are_identical, NULL))\n     return false;\n   return (this->may_send_ == t->may_send_\n \t  && this->may_receive_ == t->may_receive_);\n@@ -5666,7 +5660,8 @@ Interface_type::is_unexported_method(Gogo* gogo, const std::string& name) const\n // Whether this type is identical with T.\n \n bool\n-Interface_type::is_identical(const Interface_type* t) const\n+Interface_type::is_identical(const Interface_type* t,\n+\t\t\t     bool errors_are_identical) const\n {\n   // We require the same methods with the same types.  The methods\n   // have already been sorted.\n@@ -5681,7 +5676,8 @@ Interface_type::is_identical(const Interface_type* t) const\n       if (p1 == this->methods()->end())\n \treturn false;\n       if (p1->name() != p2->name()\n-\t  || !Type::are_identical(p1->type(), p2->type(), NULL))\n+\t  || !Type::are_identical(p1->type(), p2->type(),\n+\t\t\t\t  errors_are_identical, NULL))\n \treturn false;\n     }\n   if (p1 != this->methods()->end())\n@@ -5720,7 +5716,7 @@ Interface_type::is_compatible_for_assign(const Interface_type* t,\n \t}\n \n       std::string subreason;\n-      if (!Type::are_identical(p->type(), m->type(), &subreason))\n+      if (!Type::are_identical(p->type(), m->type(), true, &subreason))\n \t{\n \t  if (reason != NULL)\n \t    {\n@@ -5855,7 +5851,7 @@ Interface_type::implements_interface(const Type* t, std::string* reason) const\n       Function_type* m_fn_type = m->type()->function_type();\n       gcc_assert(p_fn_type != NULL && m_fn_type != NULL);\n       std::string subreason;\n-      if (!p_fn_type->is_identical(m_fn_type, true, &subreason))\n+      if (!p_fn_type->is_identical(m_fn_type, true, true, &subreason))\n \t{\n \t  if (reason != NULL)\n \t    {"}, {"sha": "2a713b067d4a68fa09fb1eb85fb3f922270690a2", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ba28bb635a2a4d451efc108634f9ae0cb8b0a4/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ba28bb635a2a4d451efc108634f9ae0cb8b0a4/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=50ba28bb635a2a4d451efc108634f9ae0cb8b0a4", "patch": "@@ -503,16 +503,13 @@ class Type\n   verify()\n   { return this->do_verify(); }\n \n-  // Return true if two types are identical.  If this returns false,\n+  // Return true if two types are identical.  If ERRORS_ARE_IDENTICAL,\n+  // returns that an erroneous type is identical to any other type;\n+  // this is used to avoid cascading errors.  If this returns false,\n   // and REASON is not NULL, it may set *REASON.\n   static bool\n-  are_identical(const Type* lhs, const Type* rhs, std::string* reason);\n-\n-  // Return true if two types are identical when it comes to putting\n-  // them in a hash table.  This differs from are_identical only in\n-  // how error types are handled.\n-  static bool\n-  are_identical_for_hash_table(const Type*, const Type*);\n+  are_identical(const Type* lhs, const Type* rhs, bool errors_are_identical,\n+\t\tstd::string* reason);\n \n   // Return true if two types are compatible for use in a binary\n   // operation, other than a shift, comparison, or channel send.  This\n@@ -1110,7 +1107,7 @@ class Type_identical\n  public:\n   bool\n   operator()(const Type* t1, const Type* t2) const\n-  { return Type::are_identical_for_hash_table(t1, t2); }\n+  { return Type::are_identical(t1, t2, false, NULL); }\n };\n \n // An identifier with a type.\n@@ -1583,7 +1580,7 @@ class Function_type : public Type\n   // Whether this type is the same as T.\n   bool\n   is_identical(const Function_type* t, bool ignore_receiver,\n-\t       std::string*) const;\n+\t       bool errors_are_identical, std::string*) const;\n \n   // Record that this is a varargs function.\n   void\n@@ -1890,7 +1887,7 @@ class Struct_type : public Type\n \n   // Whether this type is identical with T.\n   bool\n-  is_identical(const Struct_type* t) const;\n+  is_identical(const Struct_type* t, bool errors_are_identical) const;\n \n   // Whether this struct type has any hidden fields.  This returns\n   // true if any fields have hidden names, or if any non-pointer\n@@ -2009,7 +2006,7 @@ class Array_type : public Type\n \n   // Whether this type is identical with T.\n   bool\n-  is_identical(const Array_type* t) const;\n+  is_identical(const Array_type* t, bool errors_are_identical) const;\n \n   // Whether this type has any hidden fields.\n   bool\n@@ -2126,7 +2123,7 @@ class Map_type : public Type\n \n   // Whether this type is identical with T.\n   bool\n-  is_identical(const Map_type* t) const;\n+  is_identical(const Map_type* t, bool errors_are_identical) const;\n \n   // Import a map type.\n   static Map_type*\n@@ -2212,7 +2209,7 @@ class Channel_type : public Type\n \n   // Whether this type is identical with T.\n   bool\n-  is_identical(const Channel_type* t) const;\n+  is_identical(const Channel_type* t, bool errors_are_identical) const;\n \n   // Import a channel type.\n   static Channel_type*\n@@ -2315,7 +2312,7 @@ class Interface_type : public Type\n   // Whether this type is identical with T.  REASON is as in\n   // implements_interface.\n   bool\n-  is_identical(const Interface_type* t) const;\n+  is_identical(const Interface_type* t, bool errors_are_identical) const;\n \n   // Whether we can assign T to this type.  is_identical is known to\n   // be false."}]}