{"sha": "22e9174f5416123df52503b2dc2248de0f4ca27e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjJlOTE3NGY1NDE2MTIzZGY1MjUwM2IyZGMyMjQ4ZGUwZjRjYTI3ZQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-08-20T22:07:22Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-08-20T22:07:22Z"}, "message": "semantics.c (finish_stmt_expr): Fix typo in comment.\n\n\t* semantics.c (finish_stmt_expr): Fix typo in comment.\n\t* tree.c (search_tree): Handle EXIT_EXPR, LOOP_EXPR.\n\t(mapcar): Likewise.\n\t* init.c (build_vec_delete_1): Make the children of a permanent\n\tBIND_EXPR permanent.\n\t* pt.c (register_specialization): Don't register a specialization\n\tmore than once.\n\nFrom-SVN: r28781", "tree": {"sha": "dfbbd22a6059f25bb2e777e3a7ab7bdd17945040", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dfbbd22a6059f25bb2e777e3a7ab7bdd17945040"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/22e9174f5416123df52503b2dc2248de0f4ca27e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22e9174f5416123df52503b2dc2248de0f4ca27e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22e9174f5416123df52503b2dc2248de0f4ca27e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22e9174f5416123df52503b2dc2248de0f4ca27e/comments", "author": null, "committer": null, "parents": [{"sha": "b61148dd4f5b244381b91b86dd7e921698f92687", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b61148dd4f5b244381b91b86dd7e921698f92687", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b61148dd4f5b244381b91b86dd7e921698f92687"}], "stats": {"total": 175, "additions": 122, "deletions": 53}, "files": [{"sha": "527783ddbc87cb30c990fd26c7ff31674f330783", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22e9174f5416123df52503b2dc2248de0f4ca27e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22e9174f5416123df52503b2dc2248de0f4ca27e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=22e9174f5416123df52503b2dc2248de0f4ca27e", "patch": "@@ -1,3 +1,13 @@\n+1999-08-20  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* semantics.c (finish_stmt_expr): Fix typo in comment.\n+\t* tree.c (search_tree): Handle EXIT_EXPR, LOOP_EXPR.\n+\t(mapcar): Likewise.\n+\t* init.c (build_vec_delete_1): Make the children of a permanent\n+\tBIND_EXPR permanent.\n+\t* pt.c (register_specialization): Don't register a specialization\n+\tmore than once.\n+\t\n 1999-08-18  Andrew Haley  <aph@cygnus.com>\n \n \t* method.c (process_overload_item): Call build_mangled_C9x_name ()"}, {"sha": "ac962f6032a07255a2687f5814d9f65949c26b81", "filename": "gcc/cp/init.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22e9174f5416123df52503b2dc2248de0f4ca27e/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22e9174f5416123df52503b2dc2248de0f4ca27e/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=22e9174f5416123df52503b2dc2248de0f4ca27e", "patch": "@@ -2673,6 +2673,15 @@ build_vec_delete_1 (base, maxindex, type, auto_delete_vec, auto_delete,\n \n   if (controller)\n     {\n+      /* The CONTROLLER is a BIND_EXPR.  Such things are always\n+\t allocated on at least the saveable obstack.  Since we may\n+\t need to copy this expression to the permanent obstack, we\n+\t must make sure that the operand is on the same obstack as the\n+\t BIND_EXPR.  Otherwise, copy_to_permanent will not copy the\n+\t operand, since it will assume that anything under a permanent\n+\t node is permanent.  */\n+      if (TREE_PERMANENT (controller))\n+\tbody = copy_to_permanent (body);\n       TREE_OPERAND (controller, 1) = body;\n       return controller;\n     }"}, {"sha": "b62dc752885427c0d5cd17295a343e41f89a28b5", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 61, "deletions": 52, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22e9174f5416123df52503b2dc2248de0f4ca27e/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22e9174f5416123df52503b2dc2248de0f4ca27e/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=22e9174f5416123df52503b2dc2248de0f4ca27e", "patch": "@@ -842,59 +842,68 @@ register_specialization (spec, tmpl, args)\n   for (s = DECL_TEMPLATE_SPECIALIZATIONS (tmpl);\n        s != NULL_TREE;\n        s = TREE_CHAIN (s))\n-    if (comp_template_args (TREE_PURPOSE (s), args))\n-      {\n-\ttree fn = TREE_VALUE (s);\n+    {\n+      tree fn = TREE_VALUE (s);\n \n-\tif (DECL_TEMPLATE_SPECIALIZATION (spec))\n-\t  {\n-\t    if (DECL_TEMPLATE_INSTANTIATION (fn))\n-\t      {\n-\t\tif (TREE_USED (fn) \n-\t\t    || DECL_EXPLICIT_INSTANTIATION (fn))\n-\t\t  {\n-\t\t    cp_error (\"specialization of %D after instantiation\",\n-\t\t\t      fn);\n-\t\t    return spec;\n-\t\t  }\n-\t\telse\n-\t\t  {\n-\t\t    /* This situation should occur only if the first\n-\t\t       specialization is an implicit instantiation,\n-\t\t       the second is an explicit specialization, and\n-\t\t       the implicit instantiation has not yet been\n-\t\t       used.  That situation can occur if we have\n-\t\t       implicitly instantiated a member function and\n-\t\t       then specialized it later.\n-\n-\t\t       We can also wind up here if a friend\n-\t\t       declaration that looked like an instantiation\n-\t\t       turns out to be a specialization:\n-\n-\t\t         template <class T> void foo(T);\n-\t\t\t class S { friend void foo<>(int) };\n-\t\t\t template <> void foo(int);  \n-\n-\t\t       We transform the existing DECL in place so that\n-\t\t       any pointers to it become pointers to the\n-\t\t       updated declaration.  \n-\n-\t\t       If there was a definition for the template, but\n-\t\t       not for the specialization, we want this to\n-\t\t       look as if there is no definition, and vice\n-\t\t       versa.  */\n-\t\t    DECL_INITIAL (fn) = NULL_TREE;\n-\t\t    duplicate_decls (spec, fn);\n-\n-\t\t    return fn;\n-\t\t  }\n-\t      }\n-\t    else if (DECL_TEMPLATE_SPECIALIZATION (fn))\n-\t      {\n-\t\tduplicate_decls (spec, fn);\n-\t\treturn fn;\n-\t      }\n-\t  }\n+      /* We can sometimes try to re-register a specialization that we've\n+\t already got.  In particular, regenerate_decl_from_template\n+\t calls duplicate_decls which will update the specialization\n+\t list.  But, we'll still get called again here anyhow.  It's\n+\t more convenient to simply allow this than to try to prevent it.  */\n+      if (fn == spec)\n+\treturn spec;\n+      else if (comp_template_args (TREE_PURPOSE (s), args))\n+\t{\n+\t  if (DECL_TEMPLATE_SPECIALIZATION (spec))\n+\t    {\n+\t      if (DECL_TEMPLATE_INSTANTIATION (fn))\n+\t\t{\n+\t\t  if (TREE_USED (fn) \n+\t\t      || DECL_EXPLICIT_INSTANTIATION (fn))\n+\t\t    {\n+\t\t      cp_error (\"specialization of %D after instantiation\",\n+\t\t\t\tfn);\n+\t\t      return spec;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      /* This situation should occur only if the first\n+\t\t\t specialization is an implicit instantiation,\n+\t\t\t the second is an explicit specialization, and\n+\t\t\t the implicit instantiation has not yet been\n+\t\t\t used.  That situation can occur if we have\n+\t\t\t implicitly instantiated a member function and\n+\t\t\t then specialized it later.\n+\n+\t\t\t We can also wind up here if a friend\n+\t\t\t declaration that looked like an instantiation\n+\t\t\t turns out to be a specialization:\n+\n+\t\t\t   template <class T> void foo(T);\n+\t\t\t   class S { friend void foo<>(int) };\n+\t\t\t   template <> void foo(int);  \n+\n+\t\t\t We transform the existing DECL in place so that\n+\t\t\t any pointers to it become pointers to the\n+\t\t\t updated declaration.  \n+\n+\t\t\t If there was a definition for the template, but\n+\t\t\t not for the specialization, we want this to\n+\t\t\t look as if there is no definition, and vice\n+\t\t\t versa.  */\n+\t\t      DECL_INITIAL (fn) = NULL_TREE;\n+\t\t      duplicate_decls (spec, fn);\n+\n+\t\t      return fn;\n+\t\t    }\n+\t\t}\n+\t      else if (DECL_TEMPLATE_SPECIALIZATION (fn))\n+\t\t{\n+\t\t  duplicate_decls (spec, fn);\n+\t\t  return fn;\n+\t\t}\n+\t    }\n+\t}\n       }\n \n   DECL_TEMPLATE_SPECIALIZATIONS (tmpl)"}, {"sha": "d11bb9058322ce064094015c68f632ff3318f9eb", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22e9174f5416123df52503b2dc2248de0f4ca27e/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22e9174f5416123df52503b2dc2248de0f4ca27e/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=22e9174f5416123df52503b2dc2248de0f4ca27e", "patch": "@@ -1057,7 +1057,7 @@ finish_stmt_expr (rtl_expr, expr)\n \n   if (TREE_CODE (expr) == BLOCK)\n     {\n-      /* Make a CP_BIND_EXPR for the BLOCK already made.  */\n+      /* Make a BIND_EXPR for the BLOCK already made.  */\n       if (building_stmt_tree ())\n \t{\n \t  result = build_min (STMT_EXPR, last_expr_type, last_tree);"}, {"sha": "808e829e8c0b1bb3e2cd48194343c9ecc155d5aa", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22e9174f5416123df52503b2dc2248de0f4ca27e/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22e9174f5416123df52503b2dc2248de0f4ca27e/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=22e9174f5416123df52503b2dc2248de0f4ca27e", "patch": "@@ -1668,6 +1668,8 @@ search_tree (t, func)\n     case CLEANUP_POINT_EXPR:\n     case LOOKUP_EXPR:\n     case THROW_EXPR:\n+    case EXIT_EXPR:\n+    case LOOP_EXPR:\n       TRY (TREE_OPERAND (t, 0));\n       break;\n \n@@ -2001,6 +2003,8 @@ mapcar (t, func)\n       return t;\n \n     case LOOKUP_EXPR:\n+    case EXIT_EXPR:\n+    case LOOP_EXPR:\n       t = copy_node (t);\n       TREE_OPERAND (t, 0) = mapcar (TREE_OPERAND (t, 0), func);\n       return t;"}, {"sha": "b9f7801e9ff42f8c6008bf63fd467c69ec862318", "filename": "gcc/testsuite/g++.old-deja/g++.pt/crash49.C", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22e9174f5416123df52503b2dc2248de0f4ca27e/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash49.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22e9174f5416123df52503b2dc2248de0f4ca27e/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash49.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash49.C?ref=22e9174f5416123df52503b2dc2248de0f4ca27e", "patch": "@@ -0,0 +1,37 @@\n+// Build don't link:\n+// Origin: Loring Holden <lsh@cs.brown.edu> \n+\n+template <class T>\n+class REFptr {\n+   public:\n+      virtual ~REFptr();\n+      REFptr<T> &operator =  (const REFptr<T>& p);\n+};\n+\n+class STR { };\n+class str_ptr : public REFptr<STR> { };\n+\n+template <class T>\n+class ARRAY {\n+ protected:\n+   T      *_array; \n+   int     _num;   \n+   int     _max;  \n+ public:\n+   virtual void realloc(int new_max) {\n+       _max = new_max;\n+       T *tmp = new T [_max];\n+       if (tmp == 0) return;\n+       for (int i=0; i<_num; i++) {\n+          tmp[i] = _array[i];\n+       }\n+       delete [] _array;\n+       _array = tmp;\n+   }\n+};\n+\n+int\n+main()\n+{\n+   ARRAY<str_ptr> tags;\n+}"}]}