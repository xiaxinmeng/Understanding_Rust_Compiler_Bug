{"sha": "26f391e8067e96e4fba7b531eda9fb80023f2fd2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjZmMzkxZTgwNjdlOTZlNGZiYTdiNTMxZWRhOWZiODAwMjNmMmZkMg==", "commit": {"author": {"name": "Andre Vehreschild", "email": "vehre@gcc.gnu.org", "date": "2016-09-30T10:20:59Z"}, "committer": {"name": "Andre Vehreschild", "email": "vehre@gcc.gnu.org", "date": "2016-09-30T10:20:59Z"}, "message": "trans-array.c (gfc_array_allocate): Use the token from coarray's .token member.\n\ngcc/fortran/ChangeLog:\n\n2016-09-30  Andre Vehreschild  <vehre@gcc.gnu.org>\n\n\t* trans-array.c (gfc_array_allocate): Use the token from coarray's\n\t.token member.\n\t* trans-intrinsic.c (conv_expr_ref_to_caf_ref): Only generate\n\tcaf-reference chains from the first coarray references on.\n\t* trans-types.c (gfc_get_derived_type): Switch on mandatory .token\n\tmember generation for allocatable arrays in coarrays in derived types.\n\ngcc/testsuite/ChangeLog:\n\n2016-09-30  Andre Vehreschild  <vehre@gcc.gnu.org>\n\n\t* gfortran.dg/coarray_allocate_10.f08: New test.\n\t* gfortran.dg/coindexed_1.f90: Above fixes allow execution.\n\nFrom-SVN: r240650", "tree": {"sha": "2a9fff47c877e59328ae314ee6f4aa5be68ce12a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2a9fff47c877e59328ae314ee6f4aa5be68ce12a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/26f391e8067e96e4fba7b531eda9fb80023f2fd2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26f391e8067e96e4fba7b531eda9fb80023f2fd2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26f391e8067e96e4fba7b531eda9fb80023f2fd2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26f391e8067e96e4fba7b531eda9fb80023f2fd2/comments", "author": null, "committer": null, "parents": [{"sha": "fa16a27195c8862806f1483026fa1fbba8315afb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa16a27195c8862806f1483026fa1fbba8315afb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa16a27195c8862806f1483026fa1fbba8315afb"}], "stats": {"total": 98, "additions": 84, "deletions": 14}, "files": [{"sha": "ea28ae55f9387d79b6af40083add45adcf2b9047", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26f391e8067e96e4fba7b531eda9fb80023f2fd2/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26f391e8067e96e4fba7b531eda9fb80023f2fd2/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=26f391e8067e96e4fba7b531eda9fb80023f2fd2", "patch": "@@ -1,3 +1,12 @@\n+2016-09-30  Andre Vehreschild  <vehre@gcc.gnu.org>\n+\n+\t* trans-array.c (gfc_array_allocate): Use the token from coarray's\n+\t.token member.\n+\t* trans-intrinsic.c (conv_expr_ref_to_caf_ref): Only generate\n+\tcaf-reference chains from the first coarray references on.\n+\t* trans-types.c (gfc_get_derived_type): Switch on mandatory .token\n+\tmember generation for allocatable arrays in coarrays in derived types.\n+\n 2016-09-29  James Greenhalgh  <james.greenhalgh@arm.com>\n \n \t* options.c (gfc_post_options): Remove special case for"}, {"sha": "50312fed3074f01a6ff5dd4bcdf84e5d96ed58d9", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26f391e8067e96e4fba7b531eda9fb80023f2fd2/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26f391e8067e96e4fba7b531eda9fb80023f2fd2/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=26f391e8067e96e4fba7b531eda9fb80023f2fd2", "patch": "@@ -5406,7 +5406,6 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree status, tree errmsg,\n   gfc_expr **lower;\n   gfc_expr **upper;\n   gfc_ref *ref, *prev_ref = NULL, *coref;\n-  gfc_se caf_se;\n   bool allocatable, coarray, dimension, alloc_w_e3_arr_spec = false;\n \n   ref = expr->ref;\n@@ -5531,7 +5530,6 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree status, tree errmsg,\n \t}\n     }\n \n-  gfc_init_se (&caf_se, NULL);\n   gfc_start_block (&elseblock);\n \n   /* Allocate memory to store the data.  */\n@@ -5543,9 +5541,7 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree status, tree errmsg,\n \n   if (coarray && flag_coarray == GFC_FCOARRAY_LIB)\n     {\n-      tmp = gfc_get_tree_for_caf_expr (expr);\n-      gfc_get_caf_token_offset (&caf_se, &token, NULL, tmp, NULL_TREE, expr);\n-      gfc_add_block_to_block (&elseblock, &caf_se.pre);\n+      token = gfc_conv_descriptor_token (se->expr);\n       token = gfc_build_addr_expr (NULL_TREE, token);\n     }\n \n@@ -5557,7 +5553,6 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree status, tree errmsg,\n   else\n     gfc_allocate_using_malloc (&elseblock, pointer, size, status);\n \n-  gfc_add_block_to_block (&elseblock, &caf_se.post);\n   if (dimension)\n     {\n       cond = gfc_unlikely (fold_build2_loc (input_location, NE_EXPR,"}, {"sha": "a499c3273865481945b993d5cff64db0e6edfeb6", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26f391e8067e96e4fba7b531eda9fb80023f2fd2/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26f391e8067e96e4fba7b531eda9fb80023f2fd2/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=26f391e8067e96e4fba7b531eda9fb80023f2fd2", "patch": "@@ -1110,7 +1110,7 @@ compute_component_offset (tree field, tree type)\n static tree\n conv_expr_ref_to_caf_ref (stmtblock_t *block, gfc_expr *expr)\n {\n-  gfc_ref *ref = expr->ref;\n+  gfc_ref *ref = expr->ref, *last_comp_ref;\n   tree caf_ref = NULL_TREE, prev_caf_ref = NULL_TREE, reference_type, tmp, tmp2,\n       field, last_type, inner_struct, mode, mode_rhs, dim_array, dim, dim_type,\n       start, end, stride, vector, nvec;\n@@ -1127,8 +1127,29 @@ conv_expr_ref_to_caf_ref (stmtblock_t *block, gfc_expr *expr)\n \n   /* Prevent uninit-warning.  */\n   reference_type = NULL_TREE;\n-  last_type = gfc_typenode_for_spec (&expr->symtree->n.sym->ts);\n-  last_type_n = expr->symtree->n.sym->ts.type;\n+\n+  /* Skip refs upto the first coarray-ref.  */\n+  last_comp_ref = NULL;\n+  while (ref && (ref->type != REF_ARRAY || ref->u.ar.codimen == 0))\n+    {\n+      /* Remember the type of components skipped.  */\n+      if (ref->type == REF_COMPONENT)\n+\tlast_comp_ref = ref;\n+      ref = ref->next;\n+    }\n+  /* When a component was skipped, get the type information of the last\n+     component ref, else get the type from the symbol.  */\n+  if (last_comp_ref)\n+    {\n+      last_type = gfc_typenode_for_spec (&last_comp_ref->u.c.component->ts);\n+      last_type_n = last_comp_ref->u.c.component->ts.type;\n+    }\n+  else\n+    {\n+      last_type = gfc_typenode_for_spec (&expr->symtree->n.sym->ts);\n+      last_type_n = expr->symtree->n.sym->ts.type;\n+    }\n+\n   while (ref)\n     {\n       if (ref->type == REF_ARRAY && ref->u.ar.codimen > 0"}, {"sha": "05122d90616134ed704d572a447830cd2562be6d", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26f391e8067e96e4fba7b531eda9fb80023f2fd2/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26f391e8067e96e4fba7b531eda9fb80023f2fd2/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=26f391e8067e96e4fba7b531eda9fb80023f2fd2", "patch": "@@ -2565,7 +2565,8 @@ gfc_get_derived_type (gfc_symbol * derived, bool in_coarray)\n       if ((!c->attr.pointer && !c->attr.proc_pointer)\n \t  || c->ts.u.derived->backend_decl == NULL)\n \tc->ts.u.derived->backend_decl = gfc_get_derived_type (c->ts.u.derived,\n-\t\t\t\t\t\t\t      in_coarray);\n+\t\t\t\t\t\t\t      in_coarray\n+\t\t\t\t\t\t\t|| c->attr.codimension);\n \n       if (c->ts.u.derived->attr.is_iso_c)\n         {"}, {"sha": "9e8204174bc97c0dd3f99a70ff591e4b916b1c01", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26f391e8067e96e4fba7b531eda9fb80023f2fd2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26f391e8067e96e4fba7b531eda9fb80023f2fd2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=26f391e8067e96e4fba7b531eda9fb80023f2fd2", "patch": "@@ -1,3 +1,8 @@\n+2016-09-30  Andre Vehreschild  <vehre@gcc.gnu.org>\n+\n+\t* gfortran.dg/coarray_allocate_10.f08: New test.\n+\t* gfortran.dg/coindexed_1.f90: Above fixes allow execution.\n+\n 2016-09-30  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* gcc.target/aarch64/ifcvt_avoid_const_materialization_1.c: New test."}, {"sha": "30ee216af04ff8f7c19fd823252b6d662790c8a2", "filename": "gcc/testsuite/gfortran.dg/coarray_allocate_10.f08", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26f391e8067e96e4fba7b531eda9fb80023f2fd2/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_allocate_10.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26f391e8067e96e4fba7b531eda9fb80023f2fd2/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_allocate_10.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_allocate_10.f08?ref=26f391e8067e96e4fba7b531eda9fb80023f2fd2", "patch": "@@ -0,0 +1,39 @@\n+! { dg-do run }\n+! { dg-options \"-fcoarray=lib -lcaf_single\" }\n+\n+program alloc_comp\n+  implicit none\n+\n+  type coords\n+    integer,allocatable :: x(:)\n+  end type\n+\n+  type outerT\n+    type(coords),allocatable :: coo[:]\n+  end type\n+  integer :: me,np,n,i\n+  type(outerT) :: o\n+\n+  ! with caf_single num_images is always == 1\n+  me = this_image(); np = num_images()\n+  n = 100\n+\n+  allocate(o%coo[*])\n+  allocate(o%coo%x(n))\n+\n+  o%coo%x = me\n+\n+  do i=1, n\n+        o%coo%x(i) = o%coo%x(i) + i\n+  end do\n+\n+  sync all\n+\n+  if(me == 1 .and. o%coo[np]%x(10) /= 11 ) call abort()\n+\n+  ! Check the whole array is correct.\n+  if (me == 1 .and. any( o%coo[np]%x /= [(i, i=2, 101)] ) ) call abort()\n+\n+  deallocate(o%coo%x)\n+\n+end program"}, {"sha": "932442c4b3229438b6a40f7aa40f92705e33f958", "filename": "gcc/testsuite/gfortran.dg/coindexed_1.f90", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26f391e8067e96e4fba7b531eda9fb80023f2fd2/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoindexed_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26f391e8067e96e4fba7b531eda9fb80023f2fd2/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoindexed_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoindexed_1.f90?ref=26f391e8067e96e4fba7b531eda9fb80023f2fd2", "patch": "@@ -1,5 +1,5 @@\n-! { dg-do compile }\n-! { dg-options \"-fcoarray=lib\" }\n+! { dg-do run }\n+! { dg-options \"-fcoarray=lib -lcaf_single\" }\n !\n ! Contributed by Reinhold Bader\n !\n@@ -14,7 +14,7 @@ program pmup\n   integer :: ii\n \n   !! --- ONE --- \n-  allocate(real :: a(3)[*]) ! { dg-error \"Sorry, coindexed access to an unlimited polymorphic object at\" }\n+  allocate(real :: a(3)[*])\n   IF (this_image() == num_images()) THEN\n     SELECT TYPE (a)\n       TYPE IS (real)\n@@ -43,7 +43,7 @@ program pmup\n \n   !! --- TWO --- \n   deallocate(a)\n-  allocate(t :: a(3)[*]) ! { dg-error \"Sorry, coindexed access to an unlimited polymorphic object at\" }\n+  allocate(t :: a(3)[*])\n   IF (this_image() == num_images()) THEN\n     SELECT TYPE (a)\n       TYPE IS (t)"}]}