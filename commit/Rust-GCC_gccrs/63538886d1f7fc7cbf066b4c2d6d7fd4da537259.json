{"sha": "63538886d1f7fc7cbf066b4c2d6d7fd4da537259", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjM1Mzg4ODZkMWY3ZmM3Y2JmMDY2YjRjMmQ2ZDdmZDRkYTUzNzI1OQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-02-05T08:54:00Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-02-05T13:03:00Z"}, "message": "tree-optimization/98855 - redo BB vectorization costing\n\nThe following attempts to account for the fact that BB vectorization\nregions now can span multiple loop levels and that an unprofitable\ninner loop vectorization shouldn't be offsetted by a profitable\nouter loop vectorization to make it overall profitable.\n\nFor now I've implemented a heuristic based on the premise that\nvectorization should be profitable even if loops may not be entered\nor if they iterate any number of times.  Especially the first\nassumption then requires that stmts directly belonging to loop A\nneed to be costed separately from stmts belonging to another loop\nwhich also simplifies the implementation.\n\nOn x86 the added testcase has in the outer loop\n\nt.c:38:20: note: Cost model analysis for part in loop 1:\n  Vector cost: 56\n  Scalar cost: 192\n\nand the inner loop\n\nt.c:38:20: note: Cost model analysis for part in loop 2:\n  Vector cost: 132\n  Scalar cost: 48\n\nand thus the vectorization is considered not profitable\n(note the same would happen in case the 2nd cost were for\na loop outer to the 1st costing).\n\nFuture enhancements may consider static knowledge of whether\na loop is always entered which would allow some inefficiency\nin the vectorization of its loop header.  Likewise stmts only\nreachable from a loop exit can be treated this way.\n\n2021-02-05  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/98855\n\t* tree-vectorizer.h (add_stmt_cost): New overload.\n\t* tree-vect-slp.c (li_cost_vec_cmp): New.\n\t(vect_bb_slp_scalar_cost): Cost individual loop regions\n\tseparately.  Account for the scalar instance root stmt.\n\n\t* g++.dg/vect/slp-pr98855.cc: New testcase.", "tree": {"sha": "0890b535b876a493d6284ea5a6132a0a0e4da400", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0890b535b876a493d6284ea5a6132a0a0e4da400"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/63538886d1f7fc7cbf066b4c2d6d7fd4da537259", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63538886d1f7fc7cbf066b4c2d6d7fd4da537259", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63538886d1f7fc7cbf066b4c2d6d7fd4da537259", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63538886d1f7fc7cbf066b4c2d6d7fd4da537259/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4ede02a5f2af1205434f0e05aaaeff762b24e329", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ede02a5f2af1205434f0e05aaaeff762b24e329", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ede02a5f2af1205434f0e05aaaeff762b24e329"}], "stats": {"total": 266, "additions": 232, "deletions": 34}, "files": [{"sha": "0b4e479b51305398f491d0bd5a23fb0eed34b2c6", "filename": "gcc/testsuite/g++.dg/vect/slp-pr98855.cc", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63538886d1f7fc7cbf066b4c2d6d7fd4da537259/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fslp-pr98855.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63538886d1f7fc7cbf066b4c2d6d7fd4da537259/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fslp-pr98855.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fslp-pr98855.cc?ref=63538886d1f7fc7cbf066b4c2d6d7fd4da537259", "patch": "@@ -0,0 +1,84 @@\n+// { dg-do compile }\n+// { dg-additional-options \"-fvect-cost-model=cheap\" }\n+// { dg-additional-options \"-mavx2\" { target x86_64-*-* i?86-*-* } }\n+\n+#include <stdint.h>\n+#include <stdlib.h>\n+\n+inline uint32_t make_uint32(uint8_t i0, uint8_t i1, uint8_t i2, uint8_t i3)\n+{\n+  return ((static_cast<uint32_t>(i0) << 24) |\n+\t  (static_cast<uint32_t>(i1) << 16) |\n+\t  (static_cast<uint32_t>(i2) <<  8) |\n+\t  (static_cast<uint32_t>(i3)));\n+}\n+\n+inline uint32_t load_be(const uint8_t in[], size_t off)\n+{\n+  in += off * sizeof(uint32_t);\n+  return make_uint32(in[0], in[1], in[2], in[3]);\n+}\n+\n+template<typename T>\n+inline void load_be(const uint8_t in[],\n+\t\t    T& x0, T& x1, T& x2, T& x3,\n+\t\t    T& x4, T& x5, T& x6, T& x7)\n+{\n+  x0 = load_be(in, 0);\n+  x1 = load_be(in, 1);\n+  x2 = load_be(in, 2);\n+  x3 = load_be(in, 3);\n+  x4 = load_be(in, 4);\n+  x5 = load_be(in, 5);\n+  x6 = load_be(in, 6);\n+  x7 = load_be(in, 7);\n+}\n+\n+inline void store_be(uint32_t in, uint8_t out[4])\n+{\n+  uint32_t o = __builtin_bswap32 (in);\n+  __builtin_memcpy (out, &o, sizeof (uint32_t));\n+}\n+\n+template<typename T>\n+inline void store_be(uint8_t out[], T x0, T x1, T x2, T x3,\n+\t\t     T x4, T x5, T x6, T x7)\n+{\n+  store_be(x0, out + (0 * sizeof(T)));\n+  store_be(x1, out + (1 * sizeof(T)));\n+  store_be(x2, out + (2 * sizeof(T)));\n+  store_be(x3, out + (3 * sizeof(T)));\n+  store_be(x4, out + (4 * sizeof(T)));\n+  store_be(x5, out + (5 * sizeof(T)));\n+  store_be(x6, out + (6 * sizeof(T)));\n+  store_be(x7, out + (7 * sizeof(T)));\n+}\n+\n+#define BLOCK_SIZE 8\n+void encrypt_n(const uint8_t in[], uint8_t out[], size_t blocks, uint32_t *EK)\n+{\n+  const size_t blocks4 = blocks / 4;\n+\n+  for (size_t i = 0; i < blocks4; i++)\n+    {\n+      uint32_t L0, R0, L1, R1, L2, R2, L3, R3;\n+      load_be(in + 4*BLOCK_SIZE*i, L0, R0, L1, R1, L2, R2, L3, R3);\n+\n+      for(size_t r = 0; r != 32; ++r)\n+\t{\n+\t  L0 += (((R0 << 4) ^ (R0 >> 5)) + R0) ^ EK[2*r];\n+\t  L1 += (((R1 << 4) ^ (R1 >> 5)) + R1) ^ EK[2*r];\n+\t  L2 += (((R2 << 4) ^ (R2 >> 5)) + R2) ^ EK[2*r];\n+\t  L3 += (((R3 << 4) ^ (R3 >> 5)) + R3) ^ EK[2*r];\n+\n+\t  R0 += (((L0 << 4) ^ (L0 >> 5)) + L0) ^ EK[2*r+1];\n+\t  R1 += (((L1 << 4) ^ (L1 >> 5)) + L1) ^ EK[2*r+1];\n+\t  R2 += (((L2 << 4) ^ (L2 >> 5)) + L2) ^ EK[2*r+1];\n+\t  R3 += (((L3 << 4) ^ (L3 >> 5)) + L3) ^ EK[2*r+1];\n+\t}\n+\n+      store_be(out + 4*BLOCK_SIZE*i, L0, R0, L1, R1, L2, R2, L3, R3);\n+    }\n+}\n+\n+// { dg-final { scan-tree-dump-times \"not vectorized: vectorization is not profitable\" 2 \"slp1\" { target x86_64-*-* i?86-*-* } } }"}, {"sha": "b9f12c30fb834afc6f00cc6ac050d40a1cbd88ed", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 139, "deletions": 34, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63538886d1f7fc7cbf066b4c2d6d7fd4da537259/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63538886d1f7fc7cbf066b4c2d6d7fd4da537259/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=63538886d1f7fc7cbf066b4c2d6d7fd4da537259", "patch": "@@ -4340,6 +4340,20 @@ vect_bb_slp_scalar_cost (vec_info *vinfo,\n     }\n }\n \n+/* Comparator for the loop-index sorted cost vectors.  */\n+\n+static int\n+li_cost_vec_cmp (const void *a_, const void *b_)\n+{\n+  auto *a = (const std::pair<unsigned, stmt_info_for_cost *> *)a_;\n+  auto *b = (const std::pair<unsigned, stmt_info_for_cost *> *)b_;\n+  if (a->first < b->first)\n+    return -1;\n+  else if (a->first == b->first)\n+    return 0;\n+  return 1;\n+}\n+\n /* Check if vectorization of the basic block is profitable for the\n    subgraph denoted by SLP_INSTANCES.  */\n \n@@ -4352,61 +4366,152 @@ vect_bb_vectorization_profitable_p (bb_vec_info bb_vinfo,\n   unsigned int vec_inside_cost = 0, vec_outside_cost = 0, scalar_cost = 0;\n   unsigned int vec_prologue_cost = 0, vec_epilogue_cost = 0;\n \n-  void *vect_target_cost_data = init_cost (NULL);\n-\n   /* Calculate scalar cost and sum the cost for the vector stmts\n      previously collected.  */\n-  stmt_vector_for_cost scalar_costs;\n-  scalar_costs.create (0);\n+  stmt_vector_for_cost scalar_costs = vNULL;\n+  stmt_vector_for_cost vector_costs = vNULL;\n   hash_set<slp_tree> visited;\n   FOR_EACH_VEC_ELT (slp_instances, i, instance)\n     {\n       auto_vec<bool, 20> life;\n       life.safe_grow_cleared (SLP_TREE_LANES (SLP_INSTANCE_TREE (instance)),\n \t\t\t      true);\n+      if (SLP_INSTANCE_ROOT_STMT (instance))\n+\trecord_stmt_cost (&scalar_costs, 1, scalar_stmt,\n+\t\t\t  SLP_INSTANCE_ROOT_STMT (instance), 0, vect_body);\n       vect_bb_slp_scalar_cost (bb_vinfo,\n \t\t\t       SLP_INSTANCE_TREE (instance),\n \t\t\t       &life, &scalar_costs, visited);\n-      add_stmt_costs (bb_vinfo, vect_target_cost_data, &instance->cost_vec);\n+      vector_costs.safe_splice (instance->cost_vec);\n       instance->cost_vec.release ();\n     }\n   /* Unset visited flag.  */\n-  stmt_info_for_cost *si;\n-  FOR_EACH_VEC_ELT (scalar_costs, i, si)\n-    gimple_set_visited  (si->stmt_info->stmt, false);\n+  stmt_info_for_cost *cost;\n+  FOR_EACH_VEC_ELT (scalar_costs, i, cost)\n+    gimple_set_visited  (cost->stmt_info->stmt, false);\n \n-  void *scalar_target_cost_data = init_cost (NULL);\n-  add_stmt_costs (bb_vinfo, scalar_target_cost_data, &scalar_costs);\n-  scalar_costs.release ();\n-  unsigned dummy;\n-  finish_cost (scalar_target_cost_data, &dummy, &scalar_cost, &dummy);\n-  destroy_cost_data (scalar_target_cost_data);\n+  if (dump_enabled_p ())\n+    dump_printf_loc (MSG_NOTE, vect_location, \"Cost model analysis: \\n\");\n+\n+  /* When costing non-loop vectorization we need to consider each covered\n+     loop independently and make sure vectorization is profitable.  For\n+     now we assume a loop may be not entered or executed an arbitrary\n+     number of iterations (???  static information can provide more\n+     precise info here) which means we can simply cost each containing\n+     loops stmts separately.  */\n+\n+  /* First produce cost vectors sorted by loop index.  */\n+  auto_vec<std::pair<unsigned, stmt_info_for_cost *> >\n+    li_scalar_costs (scalar_costs.length ());\n+  auto_vec<std::pair<unsigned, stmt_info_for_cost *> >\n+    li_vector_costs (vector_costs.length ());\n+  FOR_EACH_VEC_ELT (scalar_costs, i, cost)\n+    {\n+      unsigned l = gimple_bb (cost->stmt_info->stmt)->loop_father->num;\n+      li_scalar_costs.quick_push (std::make_pair (l, cost));\n+    }\n+  /* Use a random used loop as fallback in case the first vector_costs\n+     entry does not have a stmt_info associated with it.  */\n+  unsigned l = li_scalar_costs[0].first;\n+  FOR_EACH_VEC_ELT (vector_costs, i, cost)\n+    {\n+      /* We inherit from the previous COST, invariants, externals and\n+\t extracts immediately follow the cost for the related stmt.  */\n+      if (cost->stmt_info)\n+\tl = gimple_bb (cost->stmt_info->stmt)->loop_father->num;\n+      li_vector_costs.quick_push (std::make_pair (l, cost));\n+    }\n+  li_scalar_costs.qsort (li_cost_vec_cmp);\n+  li_vector_costs.qsort (li_cost_vec_cmp);\n+\n+  /* Now cost the portions individually.  */\n+  unsigned vi = 0;\n+  unsigned si = 0;\n+  do\n+    {\n+      unsigned sl = li_scalar_costs[si].first;\n+      unsigned vl = li_vector_costs[vi].first;\n+      if (sl != vl)\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"Scalar %d and vector %d loop part do not \"\n+\t\t\t     \"match up, skipping scalar part\\n\", sl, vl);\n+\t  /* Skip the scalar part, assuming zero cost on the vector side.  */\n+\t  do\n+\t    {\n+\t      si++;\n+\t    }\n+\t  while (si < li_scalar_costs.length ()\n+\t\t && li_scalar_costs[si].first == sl);\n+\t  continue;\n+\t}\n \n-  /* Complete the target-specific vector cost calculation.  */\n-  finish_cost (vect_target_cost_data, &vec_prologue_cost,\n-\t       &vec_inside_cost, &vec_epilogue_cost);\n-  destroy_cost_data (vect_target_cost_data);\n+      void *scalar_target_cost_data = init_cost (NULL);\n+      do\n+\t{\n+\t  add_stmt_cost (bb_vinfo, scalar_target_cost_data,\n+\t\t\t li_scalar_costs[si].second);\n+\t  si++;\n+\t}\n+      while (si < li_scalar_costs.length ()\n+\t     && li_scalar_costs[si].first == sl);\n+      unsigned dummy;\n+      finish_cost (scalar_target_cost_data, &dummy, &scalar_cost, &dummy);\n+      destroy_cost_data (scalar_target_cost_data);\n+\n+      /* Complete the target-specific vector cost calculation.  */\n+      void *vect_target_cost_data = init_cost (NULL);\n+      do\n+\t{\n+\t  add_stmt_cost (bb_vinfo, vect_target_cost_data,\n+\t\t\t li_vector_costs[vi].second);\n+\t  vi++;\n+\t}\n+      while (vi < li_vector_costs.length ()\n+\t     && li_vector_costs[vi].first == vl);\n+      finish_cost (vect_target_cost_data, &vec_prologue_cost,\n+\t\t   &vec_inside_cost, &vec_epilogue_cost);\n+      destroy_cost_data (vect_target_cost_data);\n \n-  vec_outside_cost = vec_prologue_cost + vec_epilogue_cost;\n+      vec_outside_cost = vec_prologue_cost + vec_epilogue_cost;\n \n-  if (dump_enabled_p ())\n+      if (dump_enabled_p ())\n+\t{\n+\t  dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t   \"Cost model analysis for part in loop %d:\\n\", sl);\n+\t  dump_printf (MSG_NOTE, \"  Vector cost: %d\\n\",\n+\t\t       vec_inside_cost + vec_outside_cost);\n+\t  dump_printf (MSG_NOTE, \"  Scalar cost: %d\\n\", scalar_cost);\n+\t}\n+\n+      /* Vectorization is profitable if its cost is more than the cost of scalar\n+\t version.  Note that we err on the vector side for equal cost because\n+\t the cost estimate is otherwise quite pessimistic (constant uses are\n+\t free on the scalar side but cost a load on the vector side for\n+\t example).  */\n+      if (vec_outside_cost + vec_inside_cost > scalar_cost)\n+\t{\n+\t  scalar_costs.release ();\n+\t  vector_costs.release ();\n+\t  return false;\n+\t}\n+    }\n+  while (si < li_scalar_costs.length ()\n+\t && vi < li_vector_costs.length ());\n+  if (vi < li_vector_costs.length ())\n     {\n-      dump_printf_loc (MSG_NOTE, vect_location, \"Cost model analysis: \\n\");\n-      dump_printf (MSG_NOTE, \"  Vector inside of basic block cost: %d\\n\",\n-\t\t   vec_inside_cost);\n-      dump_printf (MSG_NOTE, \"  Vector prologue cost: %d\\n\", vec_prologue_cost);\n-      dump_printf (MSG_NOTE, \"  Vector epilogue cost: %d\\n\", vec_epilogue_cost);\n-      dump_printf (MSG_NOTE, \"  Scalar cost of basic block: %d\\n\", scalar_cost);\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"Excess vector cost for part in loop %d:\\n\",\n+\t\t\t li_vector_costs[vi].first);\n+      scalar_costs.release ();\n+      vector_costs.release ();\n+      return false;\n     }\n \n-  /* Vectorization is profitable if its cost is more than the cost of scalar\n-     version.  Note that we err on the vector side for equal cost because\n-     the cost estimate is otherwise quite pessimistic (constant uses are\n-     free on the scalar side but cost a load on the vector side for\n-     example).  */\n-  if (vec_outside_cost + vec_inside_cost > scalar_cost)\n-    return false;\n-\n+  scalar_costs.release ();\n+  vector_costs.release ();\n   return true;\n }\n "}, {"sha": "b861c97ab3aef179ba9b2900701cf09e75a847a5", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63538886d1f7fc7cbf066b4c2d6d7fd4da537259/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63538886d1f7fc7cbf066b4c2d6d7fd4da537259/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=63538886d1f7fc7cbf066b4c2d6d7fd4da537259", "patch": "@@ -1481,6 +1481,15 @@ add_stmt_cost (vec_info *vinfo, void *data, int count,\n   return cost;\n }\n \n+/* Alias targetm.vectorize.add_stmt_cost.  */\n+\n+static inline unsigned\n+add_stmt_cost (vec_info *vinfo, void *data, stmt_info_for_cost *i)\n+{\n+  return add_stmt_cost (vinfo, data, i->count, i->kind, i->stmt_info,\n+\t\t\ti->vectype, i->misalign, i->where);\n+}\n+\n /* Alias targetm.vectorize.finish_cost.  */\n \n static inline void"}]}