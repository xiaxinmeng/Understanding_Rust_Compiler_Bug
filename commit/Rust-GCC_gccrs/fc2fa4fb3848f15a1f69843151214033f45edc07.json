{"sha": "fc2fa4fb3848f15a1f69843151214033f45edc07", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmMyZmE0ZmIzODQ4ZjE1YTFmNjk4NDMxNTEyMTQwMzNmNDVlZGMwNw==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2011-02-15T21:21:59Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2011-02-15T21:21:59Z"}, "message": "Revert\n\t2011-01-25  Jeff Law  <law@redhat.com>\n\n\tPR rtl-optimization/37273\n\t* ira-costs.c (scan_one_insn): Detect constants living in memory and\n\thandle them like argument loads from stack slots.  Do not double\n\tcount memory for memory constants and argument loads from stack slots.\n\nFrom-SVN: r170199", "tree": {"sha": "7c28c5110a66983cfc6dd2dfaefced152d6c2824", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7c28c5110a66983cfc6dd2dfaefced152d6c2824"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fc2fa4fb3848f15a1f69843151214033f45edc07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc2fa4fb3848f15a1f69843151214033f45edc07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc2fa4fb3848f15a1f69843151214033f45edc07", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc2fa4fb3848f15a1f69843151214033f45edc07/comments", "author": null, "committer": null, "parents": [{"sha": "158559dec972855ee988113db67e60334da2d479", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/158559dec972855ee988113db67e60334da2d479", "html_url": "https://github.com/Rust-GCC/gccrs/commit/158559dec972855ee988113db67e60334da2d479"}], "stats": {"total": 31, "additions": 14, "deletions": 17}, "files": [{"sha": "8af5e8747500c09dad9ac7d0bd2d8e9ad57680a3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc2fa4fb3848f15a1f69843151214033f45edc07/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc2fa4fb3848f15a1f69843151214033f45edc07/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fc2fa4fb3848f15a1f69843151214033f45edc07", "patch": "@@ -1,3 +1,13 @@\n+2011-02-15  Jeff Law  <law@redhat.com>\n+\n+\tRevert\n+\t2011-01-25  Jeff Law  <law@redhat.com>\n+\n+\tPR rtl-optimization/37273\n+\t* ira-costs.c (scan_one_insn): Detect constants living in memory and\n+\thandle them like argument loads from stack slots.  Do not double\n+\tcount memory for memory constants and argument loads from stack slots.\n+\n 2011-02-15  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR middle-end/47725"}, {"sha": "2329613ffa8d614ddfb9e0927a43bc90ea04f987", "filename": "gcc/ira-costs.c", "status": "modified", "additions": 4, "deletions": 17, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc2fa4fb3848f15a1f69843151214033f45edc07/gcc%2Fira-costs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc2fa4fb3848f15a1f69843151214033f45edc07/gcc%2Fira-costs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-costs.c?ref=fc2fa4fb3848f15a1f69843151214033f45edc07", "patch": "@@ -1,5 +1,5 @@\n /* IRA hard register and memory cost calculation for allocnos or pseudos.\n-   Copyright (C) 2006, 2007, 2008, 2009, 2010, 2011\n+   Copyright (C) 2006, 2007, 2008, 2009, 2010\n    Free Software Foundation, Inc.\n    Contributed by Vladimir Makarov <vmakarov@redhat.com>.\n \n@@ -1009,7 +1009,6 @@ scan_one_insn (rtx insn)\n   enum rtx_code pat_code;\n   rtx set, note;\n   int i, k;\n-  bool counted_mem;\n \n   if (!NONDEBUG_INSN_P (insn))\n     return insn;\n@@ -1019,23 +1018,15 @@ scan_one_insn (rtx insn)\n       || pat_code == ADDR_VEC || pat_code == ADDR_DIFF_VEC)\n     return insn;\n \n-  counted_mem = false;\n   set = single_set (insn);\n   extract_insn (insn);\n \n   /* If this insn loads a parameter from its stack slot, then it\n      represents a savings, rather than a cost, if the parameter is\n-     stored in memory.  Record this fact. \n-\n-     Similarly if we're loading other constants from memory (constant\n-     pool, TOC references, small data areas, etc) and this is the only\n-     assignment to the destination pseudo.  */\n+     stored in memory.  Record this fact.  */\n   if (set != 0 && REG_P (SET_DEST (set)) && MEM_P (SET_SRC (set))\n       && (note = find_reg_note (insn, REG_EQUIV, NULL_RTX)) != NULL_RTX\n-      && ((MEM_P (XEXP (note, 0)))\n-\t  || (CONSTANT_P (XEXP (note, 0))\n-\t      && LEGITIMATE_CONSTANT_P (XEXP (note, 0))\n-\t      && REG_N_SETS (REGNO (SET_DEST (set))) == 1)))\n+      && MEM_P (XEXP (note, 0)))\n     {\n       enum reg_class cl = GENERAL_REGS;\n       rtx reg = SET_DEST (set);\n@@ -1047,7 +1038,6 @@ scan_one_insn (rtx insn)\n \t-= ira_memory_move_cost[GET_MODE (reg)][cl][1] * frequency;\n       record_address_regs (GET_MODE (SET_SRC (set)), XEXP (SET_SRC (set), 0),\n \t\t\t   0, MEM, SCRATCH, frequency * 2);\n-      counted_mem = true;\n     }\n \n   record_operand_costs (insn, pref);\n@@ -1062,10 +1052,7 @@ scan_one_insn (rtx insn)\n \tstruct costs *p = COSTS (costs, COST_INDEX (regno));\n \tstruct costs *q = op_costs[i];\n \n-\t/* If the already accounted for the memory \"cost\" above, don't\n-\t   do so again.  */\n-\tif (!counted_mem)\n-\t  p->mem_cost += q->mem_cost;\n+\tp->mem_cost += q->mem_cost;\n \tfor (k = 0; k < cost_classes_num; k++)\n \t  p->cost[k] += q->cost[k];\n       }"}]}