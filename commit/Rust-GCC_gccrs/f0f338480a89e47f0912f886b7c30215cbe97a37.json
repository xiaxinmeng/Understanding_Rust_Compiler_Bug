{"sha": "f0f338480a89e47f0912f886b7c30215cbe97a37", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjBmMzM4NDgwYTg5ZTQ3ZjA5MTJmODg2YjdjMzAyMTVjYmU5N2EzNw==", "commit": {"author": {"name": "Alex Samuel", "email": "samuel@codesourcery.com", "date": "2000-08-28T05:22:30Z"}, "committer": {"name": "Alex Samuel", "email": "samuel@gcc.gnu.org", "date": "2000-08-28T05:22:30Z"}, "message": "mangle.c (CLASSTYPE_TEMPLATE_ID_P): Remove unexplained voodoo.\n\n\t* mangle.c (CLASSTYPE_TEMPLATE_ID_P): Remove unexplained voodoo.\n\t(write_encoding): Pass another argument to write_name.\n\t(write_name): Add ignore_local_scope parameter.  Fix handling of\n\tlocal names.\n\t(write_nested_name): Use write_unqualified_name.\n\t(write_prefix): Likewise.  Skip out on FUNCTION_DECLs.\n\t(write_template_prefix): Use write_unqualified_name.\n\t(write_component): Remove.\n\t(write_local_name): Add parameter.  Use direct local entity to\n\tdiscriminator calculation.\n\t(write_class_enum_type): Pass another argument to write_name.\n\t(write_template_template_arg): Likewise.\n\t(make_guard_variable): Likewise.\n\nFrom-SVN: r36013", "tree": {"sha": "46cdc0703dc539e8dc782a194dc350d2700e9e73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/46cdc0703dc539e8dc782a194dc350d2700e9e73"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f0f338480a89e47f0912f886b7c30215cbe97a37", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0f338480a89e47f0912f886b7c30215cbe97a37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0f338480a89e47f0912f886b7c30215cbe97a37", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0f338480a89e47f0912f886b7c30215cbe97a37/comments", "author": null, "committer": null, "parents": [{"sha": "edb4c415dc1288c0137de8fa0cbb8a36376223c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/edb4c415dc1288c0137de8fa0cbb8a36376223c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/edb4c415dc1288c0137de8fa0cbb8a36376223c3"}], "stats": {"total": 149, "additions": 93, "deletions": 56}, "files": [{"sha": "8f0617f4fcb9e6493e7730fd515ab91f0849ae8b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0f338480a89e47f0912f886b7c30215cbe97a37/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0f338480a89e47f0912f886b7c30215cbe97a37/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f0f338480a89e47f0912f886b7c30215cbe97a37", "patch": "@@ -1,3 +1,19 @@\n+2000-08-27  Alex Samuel  <samuel@codesourcery.com>\n+\n+\t* mangle.c (CLASSTYPE_TEMPLATE_ID_P): Remove unexplained voodoo.\n+\t(write_encoding): Pass another argument to write_name.\n+\t(write_name): Add ignore_local_scope parameter.  Fix handling of\n+\tlocal names.\n+\t(write_nested_name): Use write_unqualified_name.\n+\t(write_prefix): Likewise.  Skip out on FUNCTION_DECLs.\n+\t(write_template_prefix): Use write_unqualified_name.\n+\t(write_component): Remove.\n+\t(write_local_name): Add parameter.  Use direct local entity to\n+\tdiscriminator calculation.\n+\t(write_class_enum_type): Pass another argument to write_name.\t\n+\t(write_template_template_arg): Likewise.\n+\t(make_guard_variable): Likewise.\n+\t\n 2000-08-27  Jason Merrill  <jason@redhat.com>\n \n \t* decl.c (pushdecl): Matching decls for local externs are found in"}, {"sha": "98f59ab6c5fc49f645bce695b66c281106a679df", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 77, "deletions": 56, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0f338480a89e47f0912f886b7c30215cbe97a37/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0f338480a89e47f0912f886b7c30215cbe97a37/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=f0f338480a89e47f0912f886b7c30215cbe97a37", "patch": "@@ -78,14 +78,11 @@\n    CLASSTYPE_USE_TEMPLATE here because of tricky bugs in the parser\n    that hard to distinguish A<T> from A, where A<T> is the type as\n    instantiated outside of the template, and A is the type used\n-   without parameters inside the template.  The logic here is\n-   historical magic that apparently produces the right result.  */\n+   without parameters inside the template.  */\n #define CLASSTYPE_TEMPLATE_ID_P(NODE)\t\t\t\t      \\\n   (TYPE_LANG_SPECIFIC (NODE) != NULL \t\t\t\t      \\\n    && CLASSTYPE_TEMPLATE_INFO (NODE) != NULL                          \\\n-   && (PRIMARY_TEMPLATE_P (CLASSTYPE_TI_TEMPLATE (NODE))              \\\n-       || (TREE_CODE (CP_DECL_CONTEXT (CLASSTYPE_TI_TEMPLATE (NODE))) \\\n-           == FUNCTION_DECL)))\n+   && (PRIMARY_TEMPLATE_P (CLASSTYPE_TI_TEMPLATE (NODE))))\n \n /* Things we only need one of.  This module is not reentrant.  */\n static struct globals\n@@ -148,13 +145,12 @@ static int find_substitution PARAMS ((tree));\n \n static void write_mangled_name PARAMS ((tree));\n static void write_encoding PARAMS ((tree));\n-static void write_name PARAMS ((tree));\n+static void write_name PARAMS ((tree, int));\n static void write_unscoped_name PARAMS ((tree));\n static void write_unscoped_template_name PARAMS ((tree));\n static void write_nested_name PARAMS ((tree));\n static void write_prefix PARAMS ((tree));\n static void write_template_prefix PARAMS ((tree));\n-static void write_component PARAMS ((tree));\n static void write_unqualified_name PARAMS ((tree));\n static void write_source_name PARAMS ((tree));\n static void write_number PARAMS ((unsigned HOST_WIDE_INT, int,\n@@ -183,7 +179,7 @@ static void write_substitution PARAMS ((int));\n static int discriminator_for_local_entity PARAMS ((tree));\n static int discriminator_for_string_literal PARAMS ((tree, tree));\n static void write_discriminator PARAMS ((int));\n-static void write_local_name PARAMS ((tree, tree));\n+static void write_local_name PARAMS ((tree, tree, tree));\n static void dump_substitution_candidates PARAMS ((void));\n static const char *mangle_decl_string PARAMS ((tree));\n \n@@ -630,7 +626,7 @@ write_encoding (decl)\n       return;\n     }\n \n-  write_name (decl);\n+  write_name (decl, /*ignore_local_scope=*/0);\n   if (TREE_CODE (decl) == FUNCTION_DECL)\n     {\n       tree fn_type;\n@@ -651,11 +647,18 @@ write_encoding (decl)\n /* <name> ::= <unscoped-name>\n           ::= <unscoped-template-name> <template-args>\n \t  ::= <nested-name>\n-\t  ::= <local-name>  */\n+\t  ::= <local-name>  \n+\n+   If IGNORE_LOCAL_SCOPE is non-zero, this production of <name> is\n+   called from <local-name>, which mangles the enclosing scope\n+   elsewhere and then uses this function to mangle just the part\n+   underneath the function scope.  So don't use the <local-name>\n+   production, to avoid an infinite recursion.  */\n \n static void\n-write_name (decl)\n+write_name (decl, ignore_local_scope)\n      tree decl;\n+     int ignore_local_scope;\n {\n   tree context;\n \n@@ -688,12 +691,44 @@ write_name (decl)\n \t/* Everything else gets an <unqualified-name>.  */\n \twrite_unscoped_name (decl);\n     }\n-  /* Handle local names.  */\n-  else if (TREE_CODE (context) == FUNCTION_DECL)\n-    write_local_name (context, decl);\n-  /* Other decls get a <nested-name> to encode their scope.  */\n   else\n-    write_nested_name (decl);\n+    {\n+      /* Handle local names, unless we asked not to (that is, invoked\n+         under <local-name>, to handle only the part of the name under\n+         the local scope).  */\n+      if (!ignore_local_scope)\n+        {\n+\t  /* Scan up the list of scope context, looking for a\n+\t     function.  If we find one, this entity is in local\n+\t     function scope.  local_entity tracks context one scope\n+\t     level down, so it will contain the element that's\n+\t     directly in that function's scope, either decl or one of\n+\t     its enclosing scopes.  */\n+\t  tree local_entity = decl;\n+\t  while (context != NULL && context != global_namespace)\n+\t    {\n+\t      /* Make sure we're always dealing with decls.  */\n+\t      if (context != NULL && TYPE_P (context))\n+\t\tcontext = TYPE_NAME (context);\n+\t      /* Is this a function?  */\n+\t      if (TREE_CODE (context) == FUNCTION_DECL)\n+\t\t{\n+\t\t  /* Yes, we have local scope.  Use the <local-name>\n+\t\t     production for the innermost function scope.  */\n+\t\t  write_local_name (context, local_entity, decl);\n+\t\t  return;\n+\t\t}\n+\t      /* Up one scope level.  */\n+\t      local_entity = context;\n+\t      context = CP_DECL_CONTEXT (context);\n+\t    }\n+\n+\t  /* No local scope found?  Fall through to <nested-name>.  */\n+\t}\n+\n+      /* Other decls get a <nested-name> to encode their scope.  */\n+      write_nested_name (decl);\n+    }\n }\n \n /* <unscoped-name> ::= <unqualified-name>\n@@ -737,7 +772,7 @@ write_unscoped_template_name (decl)\n \n /* Write the nested name, including CV-qualifiers, of DECL.\n \n-   <nested-name> ::= N [<CV-qualifiers>] <prefix> <component> E  \n+   <nested-name> ::= N [<CV-qualifiers>] <prefix> <unqualified-name> E  \n                  ::= N [<CV-qualifiers>] <template-prefix> <template-args> E\n \n    <CV-qualifiers> ::= [r] [V] [K]  */\n@@ -773,12 +808,12 @@ write_nested_name (decl)\n     {\n       /* No, just use <prefix>  */\n       write_prefix (DECL_CONTEXT (decl));\n-      write_component (decl);\n+      write_unqualified_name (decl);\n     }\n   write_char ('E');\n }\n \n-/* <prefix> ::= <prefix> <component>\n+/* <prefix> ::= <prefix> <unqualified-name>>\n             ::= <template-prefix> <template-args>\n \t    ::= # empty\n \t    ::= <substitution>  */\n@@ -803,6 +838,14 @@ write_prefix (node)\n   if (DECL_P (node))\n     /* Node is a decl.  */\n     {\n+      /* If this is a function decl, that means we've hit function\n+\t scope, so this prefix must be for a local name.  In this\n+\t case, we're under the <local-name> production, which encodes\n+\t the enclosing function scope elsewhere.  So don't continue\n+\t here.  */\n+      if (TREE_CODE (node) == FUNCTION_DECL)\n+\treturn;\n+\n       decl = node;\n       decl_is_template_id (decl, &template_info);\n     }\n@@ -824,7 +867,7 @@ write_prefix (node)\n     /* Not templated.  */\n     {\n       write_prefix (CP_DECL_CONTEXT (decl));\n-      write_component (decl);\n+      write_unqualified_name (decl);\n     }\n \n   add_substitution (node);\n@@ -886,39 +929,11 @@ write_template_prefix (node)\n     return;\n \n   write_prefix (context);\n-  write_component (decl);\n+  write_unqualified_name (decl);\n \n   add_substitution (substitution);\n }\n \n-/* <component> ::= <unqualified-name>\n-               ::= <local-name> */\n-\n-static void\n-write_component (decl)\n-     tree decl;\n-{\n-  MANGLE_TRACE_TREE (\"component\", decl);\n-\n-  switch (TREE_CODE (decl))\n-    {\n-    case TEMPLATE_DECL:\n-    case NAMESPACE_DECL:\n-    case VAR_DECL:\n-    case TYPE_DECL:\n-    case FUNCTION_DECL:\n-    case FIELD_DECL:\n-      if (TREE_CODE (CP_DECL_CONTEXT (decl)) == FUNCTION_DECL)\n-\twrite_local_name (CP_DECL_CONTEXT (decl), decl);\n-      else\n-\twrite_unqualified_name (decl);\n-      break;\n-\n-    default:\n-      my_friendly_abort (2000509);\n-    }\n-}\n-\n /* We don't need to handle thunks, vtables, or VTTs here.  Those are\n    mangled through special entry points.  \n \n@@ -1160,14 +1175,17 @@ write_discriminator (discriminator)\n \n /* Mangle the name of a function-scope entity.  FUNCTION is the\n    FUNCTION_DECL for the enclosing function.  ENTITY is the decl for\n-   the entity itself.\n+   the entity itself.  LOCAL_ENTITY is the entity that's directly\n+   scoped in FUNCTION_DECL, either ENTITY itself or an enclosing scope\n+   of ENTITY.\n \n      <local-name> := Z <function encoding> E <entity name> [<discriminator>]\n                   := Z <function encoding> E s [<discriminator>]  */\n \n static void\n-write_local_name (function, entity)\n+write_local_name (function, local_entity, entity)\n      tree function;\n+     tree local_entity;\n      tree entity;\n {\n   MANGLE_TRACE_TREE (\"local-name\", entity);\n@@ -1183,8 +1201,11 @@ write_local_name (function, entity)\n     }\n   else\n     {\n-      write_unqualified_name (entity);\n-      write_discriminator (discriminator_for_local_entity (entity));\n+      /* Now the <entity name>.  Let write_name know its being called\n+\t from <local-name>, so it doesn't try to process the enclosing\n+\t function scope again.  */\n+      write_name (entity, /*ignore_local_scope=*/1);\n+      write_discriminator (discriminator_for_local_entity (local_entity));\n     }\n }\n \n@@ -1540,7 +1561,7 @@ static void\n write_class_enum_type (type)\n      tree type;\n {\n-  write_name (TYPE_NAME (type));\n+  write_name (TYPE_NAME (type), /*ignore_local_scope=*/0);\n }\n \n /* Non-terminal <template-args>.  ARGS is a TREE_VEC of template\n@@ -1785,7 +1806,7 @@ write_template_template_arg (tree decl)\n \n   if (find_substitution (decl))\n     return;\n-  write_name (decl);\n+  write_name (decl, /*ignore_local_scope=*/0);\n   add_substitution (decl);\n }\n \n@@ -2219,6 +2240,6 @@ mangle_guard_variable (variable)\n {\n   start_mangling ();\n   write_string (\"_ZGV\");\n-  write_name (variable);\n+  write_name (variable, /*ignore_local_scope=*/0);\n   return get_identifier (finish_mangling ());\n }"}]}