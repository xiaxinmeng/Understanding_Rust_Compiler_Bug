{"sha": "7a1c3d48ab726eba42466131a41ba02615f306ad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2ExYzNkNDhhYjcyNmViYTQyNDY2MTMxYTQxYmEwMjYxNWYzMDZhZA==", "commit": {"author": {"name": "Bryce McKinlay", "email": "mckinlay@redhat.com", "date": "2004-07-13T01:04:47Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2004-07-13T01:04:47Z"}, "message": "re PR libgcj/15713 (compile interpret.cc with -fno-strict-aliasing)\n\n2004-07-12  Bryce McKinlay  <mckinlay@redhat.com>\n\n\tPR libgcj/15713\n\t* include/jvm.h (_Jv_value): New union type.\n\t* gcj/field.h (_Jv_Field): Add new _addr union field variants\n\t* interperet.cc (run): Use _Jv_value union type and *_addr _Jv_Field\n\tunion members.\n\nFrom-SVN: r84596", "tree": {"sha": "0284d7f8df8ee0213b5a149265daf403a862738c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0284d7f8df8ee0213b5a149265daf403a862738c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7a1c3d48ab726eba42466131a41ba02615f306ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a1c3d48ab726eba42466131a41ba02615f306ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a1c3d48ab726eba42466131a41ba02615f306ad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a1c3d48ab726eba42466131a41ba02615f306ad/comments", "author": null, "committer": null, "parents": [{"sha": "066a03440a9bc7cbe8cbd364ee43ed8704561b25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/066a03440a9bc7cbe8cbd364ee43ed8704561b25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/066a03440a9bc7cbe8cbd364ee43ed8704561b25"}], "stats": {"total": 93, "additions": 57, "deletions": 36}, "files": [{"sha": "3c0b041b0ec05fd500011438f44cec227825bad9", "filename": "libjava/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a1c3d48ab726eba42466131a41ba02615f306ad/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a1c3d48ab726eba42466131a41ba02615f306ad/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=7a1c3d48ab726eba42466131a41ba02615f306ad", "patch": "@@ -1,3 +1,11 @@\n+2004-07-12  Bryce McKinlay  <mckinlay@redhat.com>\n+\n+\tPR libgcj/15713\n+\t* include/jvm.h (_Jv_value): New union type.\n+\t* gcj/field.h (_Jv_Field): Add new _addr union field variants \n+\t* interperet.cc (run): Use _Jv_value union type and *_addr _Jv_Field \n+\tunion members.\n+\n 2004-07-12  Scott Gilbertson  <scottg@mantatest.com>\n \n \t* gnu/awt/xlib/XCanvasPeer.java (createImage): Implement."}, {"sha": "70c5901417b492ada8d08e590d7b35e9cdae0af2", "filename": "libjava/gcj/field.h", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a1c3d48ab726eba42466131a41ba02615f306ad/libjava%2Fgcj%2Ffield.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a1c3d48ab726eba42466131a41ba02615f306ad/libjava%2Fgcj%2Ffield.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgcj%2Ffield.h?ref=7a1c3d48ab726eba42466131a41ba02615f306ad", "patch": "@@ -39,7 +39,16 @@ struct _Jv_Field\n \n   union {\n     jint\t\tboffset;  /* offset in bytes for instance field */\n-    void*\t\taddr;  /* address of static field */\n+    char*\t\taddr;  /* address of static field */\n+    \n+    jobject* object_addr;  /* address of static object field... etc */\n+    jbyte* byte_addr;\n+    jshort* short_addr;\n+    jchar* char_addr;\n+    jint* int_addr;\n+    jlong* long_addr;\n+    jfloat* float_addr;\n+    jdouble* double_addr;\n   } u;\n \n #ifdef __cplusplus"}, {"sha": "7b5e9842c27b20744833c4f8991c6d07c2371e9e", "filename": "libjava/include/jvm.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a1c3d48ab726eba42466131a41ba02615f306ad/libjava%2Finclude%2Fjvm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a1c3d48ab726eba42466131a41ba02615f306ad/libjava%2Finclude%2Fjvm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjvm.h?ref=7a1c3d48ab726eba42466131a41ba02615f306ad", "patch": "@@ -114,6 +114,18 @@ union _Jv_word2\n   jdouble d;\n };                              \n \n+union _Jv_value\n+{\n+  jbyte byte_value;\n+  jshort short_value;\n+  jchar char_value;\n+  jint int_value;\n+  jlong long_value;\n+  jfloat float_value;\n+  jdouble double_value;\n+  jobject object_value;\n+};\n+\n // An instance of this type is used to represent a single frame in a\n // backtrace.  If the interpreter has been built, we also include\n // information about the interpreted method."}, {"sha": "7ec83a23c44d14e2a6bdb5a2e992c6deafba5fe6", "filename": "libjava/interpret.cc", "status": "modified", "additions": 27, "deletions": 35, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a1c3d48ab726eba42466131a41ba02615f306ad/libjava%2Finterpret.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a1c3d48ab726eba42466131a41ba02615f306ad/libjava%2Finterpret.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finterpret.cc?ref=7a1c3d48ab726eba42466131a41ba02615f306ad", "patch": "@@ -1156,7 +1156,7 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args)\n \tffi_cif *cif = &rmeth->cif;\n \tffi_raw *raw = (ffi_raw*) sp;\n \n-\tjdouble rvalue;\n+\t_Jv_value rvalue;\n \n #if FFI_NATIVE_RAW_API\n \t/* We assume that this is only implemented if it's correct\t*/\n@@ -1172,11 +1172,11 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args)\n \t * so those are checked before the switch */\n \tif (rtype == FFI_TYPE_POINTER)\n \t  {\n-\t    PUSHA (*(jobject*)&rvalue);\n+\t    PUSHA (rvalue.object_value);\n \t  }\n \telse if (rtype == FFI_TYPE_SINT32)\n \t  {\n-\t    PUSHI (*(jint*)&rvalue);\n+\t    PUSHI (rvalue.int_value);\n \t  }\n \telse if (rtype == FFI_TYPE_VOID)\n \t  {\n@@ -1187,36 +1187,27 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args)\n \t    switch (rtype)\n \t      {\n \t      case FFI_TYPE_SINT8:\n-\t\t{\n-\t\t  jbyte value = (*(jint*)&rvalue) & 0xff;\n-\t\t  PUSHI (value);\n-\t\t}\n+\t\tPUSHI (rvalue.byte_value);\n \t\tbreak;\n \n \t      case FFI_TYPE_SINT16:\n-\t\t{\n-\t\t  jshort value = (*(jint*)&rvalue) & 0xffff;\n-\t\t  PUSHI (value);\n-\t\t}\n+\t\tPUSHI (rvalue.short_value);\n \t\tbreak;\n \n \t      case FFI_TYPE_UINT16:\n-\t\t{\n-\t\t  jint value = (*(jint*)&rvalue) & 0xffff;\n-\t\t  PUSHI (value);\n-\t\t}\n+\t\tPUSHI (rvalue.char_value);\n \t\tbreak;\n \n \t      case FFI_TYPE_FLOAT:\n-\t\tPUSHF (*(jfloat*)&rvalue);\n+\t        PUSHF (rvalue.float_value);\n \t\tbreak;\n \n \t      case FFI_TYPE_DOUBLE:\n-\t\tPUSHD (rvalue);\n+\t        PUSHD (rvalue.double_value);\n \t\tbreak;\n \n \t      case FFI_TYPE_SINT64:\n-\t\tPUSHL (*(jlong*)&rvalue);\n+\t        PUSHL (rvalue.long_value);\n \t\tbreak;\n \n \t      default:\n@@ -2408,37 +2399,37 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args)\n \t    switch (type->size_in_bytes)\n \t      {\n \t      case 1:\n-\t\tPUSHI (*(jbyte*) (field->u.addr));\n+\t\tPUSHI (*field->u.byte_addr);\n \t\tnewinsn = AMPAMP (getstatic_resolved_1);\n \t\tbreak;\n \n \t      case 2:\n \t\tif (type == JvPrimClass (char))\n \t\t  {\n-\t\t    PUSHI(*(jchar*) (field->u.addr));\n+\t\t    PUSHI (*field->u.char_addr);\n \t\t    newinsn = AMPAMP (getstatic_resolved_char);\n \t\t  }\n \t\telse\n \t\t  {\n-\t\t    PUSHI(*(jshort*) (field->u.addr));\n+\t\t    PUSHI (*field->u.short_addr);\n \t\t    newinsn = AMPAMP (getstatic_resolved_short);\n \t\t  }\n \t\tbreak;\n \n \t      case 4:\n-\t\tPUSHI(*(jint*) (field->u.addr));\n+\t        PUSHI(*field->u.int_addr);\n \t\tnewinsn = AMPAMP (getstatic_resolved_4);\n \t\tbreak;\n \n \t      case 8:\n-\t\tPUSHL(*(jlong*) (field->u.addr));\n+\t        PUSHL(*field->u.long_addr);\n \t\tnewinsn = AMPAMP (getstatic_resolved_8);\n \t\tbreak;\n \t      }\n \t  }\n \telse\n \t  {\n-\t    PUSHA(*(jobject*) (field->u.addr));\n+\t    PUSHA(*field->u.object_addr);\n \t    newinsn = AMPAMP (getstatic_resolved_obj);\n \t  }\n \n@@ -2494,42 +2485,43 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args)\n \tNULLCHECK(obj);\n \n \tvoid *newinsn = NULL;\n+\t_Jv_value *val = (_Jv_value *) ((char *)obj + field_offset);\n \tif (type->isPrimitive ())\n \t  {\n \t    switch (type->size_in_bytes)\n \t      {\n \t      case 1:\n-\t\tPUSHI (*(jbyte*) ((char*)obj + field_offset));\n+\t        PUSHI (val->byte_value);\n \t\tnewinsn = AMPAMP (getfield_resolved_1);\n \t\tbreak;\n \n \t      case 2:\n \t\tif (type == JvPrimClass (char))\n \t\t  {\n-\t\t    PUSHI (*(jchar*) ((char*)obj + field_offset));\n+\t\t    PUSHI (val->char_value);\n \t\t    newinsn = AMPAMP (getfield_resolved_char);\n \t\t  }\n \t\telse\n \t\t  {\n-\t\t    PUSHI (*(jshort*) ((char*)obj + field_offset));\n+\t\t    PUSHI (val->short_value);\n \t\t    newinsn = AMPAMP (getfield_resolved_short);\n \t\t  }\n \t\tbreak;\n \n \t      case 4:\n-\t\tPUSHI (*(jint*) ((char*)obj + field_offset));\n+\t\tPUSHI (val->int_value);\n \t\tnewinsn = AMPAMP (getfield_resolved_4);\n \t\tbreak;\n \n \t      case 8:\n-\t\tPUSHL(*(jlong*) ((char*)obj + field_offset));\n+\t        PUSHL (val->long_value);\n \t\tnewinsn = AMPAMP (getfield_resolved_8);\n \t\tbreak;\n \t      }\n \t  }\n \telse\n \t  {\n-\t    PUSHA(*(jobject*) ((char*)obj + field_offset));\n+\t    PUSHA (val->object_value);\n \t    newinsn = AMPAMP (getfield_resolved_obj);\n \t  }\n \n@@ -2611,31 +2603,31 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args)\n \t      case 1:\n \t\t{\n \t\t  jint value = POPI();\n-\t\t  *(jbyte*) (field->u.addr) = value;\n+\t\t  *field->u.byte_addr = value;\n \t\t  newinsn = AMPAMP (putstatic_resolved_1);\n \t\t  break;\n \t\t}\n \n \t      case 2:\n \t\t{\n \t\t  jint value = POPI();\n-\t\t  *(jchar*) (field->u.addr) = value;\n+\t\t  *field->u.char_addr = value;\n \t\t  newinsn = AMPAMP (putstatic_resolved_2);\n \t\t  break;\n \t\t}\n \n \t      case 4:\n \t\t{\n \t\t  jint value = POPI();\n-\t\t  *(jint*) (field->u.addr) = value;\n+\t\t  *field->u.int_addr = value;\n \t\t  newinsn = AMPAMP (putstatic_resolved_4);\n \t\t  break;\n \t\t}\n \n \t      case 8:\n \t\t{\n \t\t  jlong value = POPL();\n-\t\t  *(jlong*) (field->u.addr) = value;\n+\t\t  *field->u.long_addr = value;\n \t\t  newinsn = AMPAMP (putstatic_resolved_8);\n \t\t  break;\n \t\t}\n@@ -2644,7 +2636,7 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args)\n \telse\n \t  {\n \t    jobject value = POPA();\n-\t    *(jobject*) (field->u.addr) = value;\n+\t    *field->u.object_addr = value;\n \t    newinsn = AMPAMP (putstatic_resolved_obj);\n \t  }\n "}]}