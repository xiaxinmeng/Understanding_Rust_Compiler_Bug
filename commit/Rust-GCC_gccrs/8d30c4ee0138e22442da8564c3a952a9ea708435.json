{"sha": "8d30c4ee0138e22442da8564c3a952a9ea708435", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGQzMGM0ZWUwMTM4ZTIyNDQyZGE4NTY0YzNhOTUyYTllYTcwODQzNQ==", "commit": {"author": {"name": "Franz Sirl", "email": "Franz.Sirl-kernel@lauterbach.com", "date": "1999-06-09T16:01:51Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-06-09T16:01:51Z"}, "message": "Franz Sirl <Franz.Sirl-kernel@lauterbach.com>\n\nFranz Sirl  <Franz.Sirl-kernel@lauterbach.com>\n        * rs6000.md (movsi_got_internal_mem): Delete.\n        * rs6000.h (CONDITIONAL_REGISTER_USAGE): Mark PIC_OFFSET_TABLE_REGNUM.\n        (GOT_TOC_REGNUM): Delete.\n        (PIC_OFFSET_TABLE_REGNUM): Define.\n        (FINALIZE_PIC): Disable.\n        * rs6000.c (rs6000_got_register): New code for fixed pic register.\n        (rs6000_replace_regno): Delete.\n        (rs6000_finalize_pic): Likewise.\n        (output_prolog): Handle PIC_OFFSET_TABLE_REGNUM.\n\nFrom-SVN: r27457", "tree": {"sha": "1dfc2e26383f798fa83af1b5ae9306cd93e1833e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1dfc2e26383f798fa83af1b5ae9306cd93e1833e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d30c4ee0138e22442da8564c3a952a9ea708435", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d30c4ee0138e22442da8564c3a952a9ea708435", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d30c4ee0138e22442da8564c3a952a9ea708435", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d30c4ee0138e22442da8564c3a952a9ea708435/comments", "author": {"login": "jinkama-san", "id": 1462162, "node_id": "MDQ6VXNlcjE0NjIxNjI=", "avatar_url": "https://avatars.githubusercontent.com/u/1462162?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jinkama-san", "html_url": "https://github.com/jinkama-san", "followers_url": "https://api.github.com/users/jinkama-san/followers", "following_url": "https://api.github.com/users/jinkama-san/following{/other_user}", "gists_url": "https://api.github.com/users/jinkama-san/gists{/gist_id}", "starred_url": "https://api.github.com/users/jinkama-san/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jinkama-san/subscriptions", "organizations_url": "https://api.github.com/users/jinkama-san/orgs", "repos_url": "https://api.github.com/users/jinkama-san/repos", "events_url": "https://api.github.com/users/jinkama-san/events{/privacy}", "received_events_url": "https://api.github.com/users/jinkama-san/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6deb8ad89245a63621496a88b0fba2a96296dd7d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6deb8ad89245a63621496a88b0fba2a96296dd7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6deb8ad89245a63621496a88b0fba2a96296dd7d"}], "stats": {"total": 227, "additions": 56, "deletions": 171}, "files": [{"sha": "fa0a0fb4845db5eea56781997ac1e84bda48361a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d30c4ee0138e22442da8564c3a952a9ea708435/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d30c4ee0138e22442da8564c3a952a9ea708435/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8d30c4ee0138e22442da8564c3a952a9ea708435", "patch": "@@ -1,3 +1,15 @@\n+Wed Jun  9 15:57:57 1999  Franz Sirl  <Franz.Sirl-kernel@lauterbach.com>\n+\n+\t* rs6000.md (movsi_got_internal_mem): Delete.\n+\t* rs6000.h (CONDITIONAL_REGISTER_USAGE): Mark PIC_OFFSET_TABLE_REGNUM.\n+\t(GOT_TOC_REGNUM): Delete.\n+\t(PIC_OFFSET_TABLE_REGNUM): Define.\n+\t(FINALIZE_PIC): Disable.\n+\t* rs6000.c (rs6000_got_register): New code for fixed pic register.\n+\t(rs6000_replace_regno): Delete.\n+\t(rs6000_finalize_pic): Likewise.\n+\t(output_prolog): Handle PIC_OFFSET_TABLE_REGNUM.\n+\n Wed Jun  9 19:44:26 1999  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \n \t* loop.c (loop_insn_first_p): Don't compare LUIDs when P"}, {"sha": "21a81f30dc0b337299130fb6dc334b958d2df663", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 29, "deletions": 139, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d30c4ee0138e22442da8564c3a952a9ea708435/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d30c4ee0138e22442da8564c3a952a9ea708435/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=8d30c4ee0138e22442da8564c3a952a9ea708435", "patch": "@@ -2391,156 +2391,36 @@ ccr_bit (op, scc_p)\n     }\n }\n \f\n-/* Return the GOT register, creating it if needed.  */\n+/* Return the GOT register.  */\n \n struct rtx_def *\n rs6000_got_register (value)\n      rtx value;\n {\n-  if (! current_function_uses_pic_offset_table || ! pic_offset_table_rtx)\n-    {\n-      if (no_new_pseudos)\n-\tfatal_insn (\"internal error -- needed new GOT register during reload phase to load:\",\n-\t\t    value);\n-\n-      current_function_uses_pic_offset_table = 1;\n-      pic_offset_table_rtx = gen_rtx_REG (Pmode, GOT_TOC_REGNUM);\n-    }\n+  /* The second flow pass currently (June 1999) can't update regs_ever_live\n+     without disturbing other parts of the compiler, so update it here to\n+     make the prolog/epilogue code happy. */\n+  if (no_new_pseudos && !regs_ever_live[PIC_OFFSET_TABLE_REGNUM])\n+    regs_ever_live[PIC_OFFSET_TABLE_REGNUM] = 1;\n \n+  current_function_uses_pic_offset_table = 1;\n   return pic_offset_table_rtx;\n }\n \n-\f\n-/* Replace all occurrences of register FROM with an new pseudo register in an insn X.\n-   Store the pseudo register used in REG.\n-   This is only safe during FINALIZE_PIC, since the registers haven't been setup\n-   yet.  */\n-\n-static rtx\n-rs6000_replace_regno (x, from, reg)\n-     rtx x;\n-     int from;\n-     rtx *reg;\n-{\n-  register int i, j;\n-  register const char *fmt;\n-\n-  /* Allow this function to make replacements in EXPR_LISTs.  */\n-  if (!x)\n-    return x;\n-\n-  switch (GET_CODE (x))\n-    {\n-    case SCRATCH:\n-    case PC:\n-    case CC0:\n-    case CONST_INT:\n-    case CONST_DOUBLE:\n-    case CONST:\n-    case SYMBOL_REF:\n-    case LABEL_REF:\n-      return x;\n-\n-    case REG:\n-      if (REGNO (x) == from)\n-\t{\n-\t  if (! *reg)\n-\t    *reg = pic_offset_table_rtx = gen_reg_rtx (Pmode);\n-\n-\t  return *reg;\n-\t}\n-\n-      return x;\n-\n-    default:\n-      break;\n-    }\n-\n-  fmt = GET_RTX_FORMAT (GET_CODE (x));\n-  for (i = GET_RTX_LENGTH (GET_CODE (x)) - 1; i >= 0; i--)\n-    {\n-      if (fmt[i] == 'e')\n-\tXEXP (x, i) = rs6000_replace_regno (XEXP (x, i), from, reg);\n-      else if (fmt[i] == 'E')\n-\tfor (j = XVECLEN (x, i) - 1; j >= 0; j--)\n-\t  XVECEXP (x, i, j) = rs6000_replace_regno (XVECEXP (x, i, j), from, reg);\n-    }\n-\n-  return x;\n-}  \n-\n-\f\n-/* By generating position-independent code, when two different\n-   programs (A and B) share a common library (libC.a), the text of\n-   the library can be shared whether or not the library is linked at\n-   the same address for both programs.  In some of these\n-   environments, position-independent code requires not only the use\n-   of different addressing modes, but also special code to enable the\n-   use of these addressing modes.\n-\n-   The `FINALIZE_PIC' macro serves as a hook to emit these special\n-   codes once the function is being compiled into assembly code, but\n-   not before.  (It is not done before, because in the case of\n-   compiling an inline function, it would lead to multiple PIC\n-   prologues being included in functions which used inline functions\n-   and were compiled to assembly language.)  */\n-\n-void\n-rs6000_finalize_pic ()\n-{\n-  /* Loop through all of the insns, replacing the special GOT_TOC_REGNUM\n-     with an appropriate pseudo register.  If we find we need GOT/TOC,\n-     add the appropriate init code.  */\n-  if (flag_pic && (DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_SOLARIS))\n-    {\n-      rtx insn = get_insns ();\n-      rtx reg = NULL_RTX;\n-      rtx first_insn;\n-      rtx last_insn = NULL_RTX;\n-\n-      if (GET_CODE (insn) == NOTE)\n-\tinsn = next_nonnote_insn (insn);\n-\n-      first_insn = insn;\n-      for ( ; insn != NULL_RTX; insn = NEXT_INSN (insn))\n-\t{\n-\t  if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n-\t    {\n-\t      PATTERN (insn) = rs6000_replace_regno (PATTERN (insn),\n-\t\t\t\t\t\t     GOT_TOC_REGNUM,\n-\t\t\t\t\t\t     &reg);\n-\n-\t      if (REG_NOTES (insn))\n-\t\tREG_NOTES (insn) = rs6000_replace_regno (REG_NOTES (insn),\n-\t\t\t\t\t\t\t GOT_TOC_REGNUM,\n-\t\t\t\t\t\t\t &reg);\n-\t    }\n-\n-\t  if (GET_CODE (insn) != NOTE)\n-\t    last_insn = insn;\n-\t}\n-\n-      if (reg)\n-\t{\n-\t  rtx init = gen_init_v4_pic (reg);\n-\t  emit_insn_before (init, first_insn);\n-\t  if (!optimize && last_insn)\n-\t    emit_insn_after (gen_rtx_USE (VOIDmode, reg), last_insn);\n-\t}\n-    }\n-}\n-\n-\f\n /* Search for any occurrence of the GOT_TOC register marker that should\n-   have been eliminated, but may have crept back in.  */\n+   have been eliminated, but may have crept back in.\n+\n+   This function could completely go away now (June 1999), but we leave it \n+   in for a while until all the possible issues with the new -fpic handling \n+   are resolved. */\n \n void\n rs6000_reorg (insn)\n      rtx insn;\n {\n   if (flag_pic && (DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_SOLARIS))\n     {\n-      rtx got_reg = gen_rtx_REG (Pmode, GOT_TOC_REGNUM);\n+      rtx got_reg = gen_rtx_REG (Pmode, 2);\n       for ( ; insn != NULL_RTX; insn = NEXT_INSN (insn))\n \tif (GET_RTX_CLASS (GET_CODE (insn)) == 'i'\n \t    && reg_mentioned_p (got_reg, PATTERN (insn)))\n@@ -2556,7 +2436,6 @@ struct machine_function\n   int save_toc_p;\n   int fpmem_size;\n   int fpmem_offset;\n-  rtx pic_offset_table_rtx;\n };\n \n /* Functions to save and restore rs6000_fpmem_size.\n@@ -2574,7 +2453,6 @@ rs6000_save_machine_status (p)\n   machine->sysv_varargs_p = rs6000_sysv_varargs_p;\n   machine->fpmem_size     = rs6000_fpmem_size;\n   machine->fpmem_offset   = rs6000_fpmem_offset;\n-  machine->pic_offset_table_rtx = pic_offset_table_rtx;\n }\n \n void\n@@ -2586,7 +2464,6 @@ rs6000_restore_machine_status (p)\n   rs6000_sysv_varargs_p = machine->sysv_varargs_p;\n   rs6000_fpmem_size     = machine->fpmem_size;\n   rs6000_fpmem_offset   = machine->fpmem_offset;\n-  pic_offset_table_rtx  = machine->pic_offset_table_rtx;\n \n   free (machine);\n   p->machine = (struct machine_function *)0;\n@@ -2601,7 +2478,6 @@ rs6000_init_expanders ()\n   rs6000_sysv_varargs_p = 0;\n   rs6000_fpmem_size = 0;\n   rs6000_fpmem_offset = 0;\n-  pic_offset_table_rtx = (rtx)0;\n \n   /* Arrange to save and restore machine status around nested functions.  */\n   save_machine_status = rs6000_save_machine_status;\n@@ -2646,7 +2522,7 @@ print_operand (file, x, code)\n \n     case '*':\n       /* Write the register number of the TOC register.  */\n-      fputs (TARGET_MINIMAL_TOC ? reg_names[30] : reg_names[2], file);\n+      fputs (TARGET_MINIMAL_TOC ? reg_names[30] : reg_names[2 /* PIC_OFFSET_TABLE_REGNUM? */ ], file);\n       return;\n \n     case '$':\n@@ -3252,7 +3128,7 @@ print_operand_address (file, x)\n \t;\n #endif\n       else\n-\tfprintf (file, \"(%s)\", reg_names[ TARGET_MINIMAL_TOC ? 30 : 2 ]);\n+\tfprintf (file, \"(%s)\", reg_names[ TARGET_MINIMAL_TOC ? 30 : 2 /* PIC_OFFSET_TABLE_REGNUM? */ ]);\n     }\n   else if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 1)) == REG)\n     {\n@@ -4121,6 +3997,20 @@ output_prolog (file, size)\n \t\t     reg_names[sp_reg]);\n     }\n \n+  /* If we need PIC_OFFSET_TABLE_REGNUM, initialize it now */\n+  if ((DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_SOLARIS) \n+      && flag_pic == 1 && regs_ever_live[PIC_OFFSET_TABLE_REGNUM])\n+    {\n+      if (!info->lr_save_p)\n+\tasm_fprintf (file, \"\\tmflr %s\\n\", reg_names[0]);\n+\n+      fputs (\"\\tbl _GLOBAL_OFFSET_TABLE_@local-4\\n\", file);\n+      asm_fprintf (file, \"\\tmflr %s\\n\", reg_names[PIC_OFFSET_TABLE_REGNUM]);\n+\n+      if (!info->lr_save_p)\n+\tasm_fprintf (file, \"\\tmtlr %s\\n\", reg_names[0]);\n+    }\n+\n   /* NT needs us to probe the stack frame every 4k pages for large frames, so\n      do it here.  */\n   if (DEFAULT_ABI == ABI_NT && info->total_size > 4096)"}, {"sha": "08ac9fd22450969914f649a15df5af6a9eda42f9", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d30c4ee0138e22442da8564c3a952a9ea708435/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d30c4ee0138e22442da8564c3a952a9ea708435/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=8d30c4ee0138e22442da8564c3a952a9ea708435", "patch": "@@ -884,15 +884,19 @@ extern int rs6000_debug_arg;\t\t/* debug argument handling */\n    64-bit AIX reserves GPR13 for thread-private data.\n    Conditionally disable FPRs.  */\n \n-#define CONDITIONAL_REGISTER_USAGE\t\\\n-{\t\t\t\t\t\\\n-  if (! TARGET_POWER)\t\t\t\\\n-    fixed_regs[64] = 1;\t\t\t\\\n-  if (TARGET_64BIT)\t\t\t\\\n-    fixed_regs[13] = call_used_regs[13] = 1; \\\n-  if (TARGET_SOFT_FLOAT)\t\t\\\n-    for (i = 32; i < 64; i++)\t\t\\\n-      fixed_regs[i] = call_used_regs[i] = 1; \\\n+#define CONDITIONAL_REGISTER_USAGE\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (! TARGET_POWER)\t\t\t\t\t\t\t\\\n+    fixed_regs[64] = 1;\t\t\t\t\t\t\t\\\n+  if (TARGET_64BIT)\t\t\t\t\t\t\t\\\n+    fixed_regs[13] = call_used_regs[13] = 1; \t\t\t\t\\\n+  if (TARGET_SOFT_FLOAT)\t\t\t\t\t\t\\\n+    for (i = 32; i < 64; i++)\t\t\t\t\t\t\\\n+      fixed_regs[i] = call_used_regs[i] = 1; \t\t\t\t\\\n+  if ((DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_SOLARIS)\t\t\\\n+      && flag_pic == 1)\t\t\t\t\t\t\t\\\n+    fixed_regs[PIC_OFFSET_TABLE_REGNUM]\t\t\t\t\t\\\n+      = call_used_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\t\t\\\n }\n \n /* Specify the registers used for certain standard purposes.\n@@ -925,12 +929,6 @@ extern int rs6000_debug_arg;\t\t/* debug argument handling */\n /* Special register that represents memory, used for float/int conversions.  */\n #define FPMEM_REGNUM 76\n \n-/* Register to use as a placeholder for the GOT/allocated TOC register.\n-   FINALIZE_PIC will change all uses of this register to a an appropriate\n-   pseudo register when it adds the code to setup the GOT.  We use r2\n-   because it is a reserved register in all of the ABI's.  */\n-#define GOT_TOC_REGNUM 2\n-\n /* Place that structure value return address is placed.\n \n    On the RS/6000, it is passed as an extra parameter.  */\n@@ -2105,7 +2103,7 @@ do {                                                                    \\\n    this macro is not defined, it is up to the machine-dependent files\n    to allocate such a register (if necessary).  */\n \n-/* #define PIC_OFFSET_TABLE_REGNUM */\n+#define PIC_OFFSET_TABLE_REGNUM 30\n \n /* Define this macro if the register defined by\n    `PIC_OFFSET_TABLE_REGNUM' is clobbered by calls.  Do not define\n@@ -2128,7 +2126,7 @@ do {                                                                    \\\n    prologues being included in functions which used inline functions\n    and were compiled to assembly language.)  */\n \n-#define FINALIZE_PIC rs6000_finalize_pic ()\n+/* #define FINALIZE_PIC */\n \n /* A C expression that is nonzero if X is a legitimate immediate\n    operand on the target machine when generating position independent"}, {"sha": "e8338634d82c4f45b79a5d35eed80c6324f8f959", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d30c4ee0138e22442da8564c3a952a9ea708435/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d30c4ee0138e22442da8564c3a952a9ea708435/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=8d30c4ee0138e22442da8564c3a952a9ea708435", "patch": "@@ -5809,21 +5809,6 @@\n   \"{l|lwz} %0,%a1@got(%2)\"\n   [(set_attr \"type\" \"load\")])\n \n-;; Sometimes, though, the GOT `register' will be on the stack. Deal with\n-;; this case specially.\n-;; Force final to split this insn (if it hasn't been split already) to\n-;; avoid having to create a suitable output template.\n-(define_insn \"*movsi_got_internal_mem\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(unspec [(match_operand:SI 1 \"got_no_const_operand\" \"\")\n-\t\t (match_operand:SI 2 \"memory_operand\" \"m\")] 8))]\n-  \"(DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_SOLARIS)\n-    && flag_pic == 1\n-    && (reload_in_progress || reload_completed)\"\n-  \"#\"\n-  [(set_attr \"type\" \"load\")\n-   (set_attr \"length\" \"8\")])\n-\n ;; Used by sched, shorten_branches and final when the GOT pseudo reg\n ;; didn't get allocated to a hard register.\n (define_split "}]}