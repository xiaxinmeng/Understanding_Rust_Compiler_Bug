{"sha": "06f4e019e245e05883b43893b9c15d75ab72a303", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDZmNGUwMTllMjQ1ZTA1ODgzYjQzODkzYjljMTVkNzVhYjcyYTMwMw==", "commit": {"author": {"name": "David Edelsohn", "email": "edelsohn@gnu.org", "date": "2001-11-20T16:13:07Z"}, "committer": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "2001-11-20T16:13:07Z"}, "message": "rs6000.c (rs6000_emit_eh_toc_restore): Remove ALIGN parm.\n\n        * rs6000.c (rs6000_emit_eh_toc_restore): Remove ALIGN parm.\n\n        * rs6000.c (rs6000_emit_move): Add TFmode case.\n        * sysv4.h (MASK_LONG_DOUBLE_128, TARGET_LONG_DOUBLE_128,\n        LONG_DOUBLE_TYPE_SIZE, MAX_LONG_DOUBLE_TYPE_SIZE,\n        LIBGCC2_LONG_DOUBLE_TYPE_SIZE): Move from here...\n        * rs6000.h: ... to here.\n        * rs6000.md (movtf, extenddftf2, extendsftf2, trunctfdf2,\n        trunctfsf2, floatditf2, floatsitf2, fix_trunctfdi2,\n        fix_trunctfsi2, negtf2, abstf2, nabstf2): New patterns.\n\nFrom-SVN: r47218", "tree": {"sha": "ee2cc1d937887e46e2754ea726b21c7af59ce925", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ee2cc1d937887e46e2754ea726b21c7af59ce925"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/06f4e019e245e05883b43893b9c15d75ab72a303", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06f4e019e245e05883b43893b9c15d75ab72a303", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06f4e019e245e05883b43893b9c15d75ab72a303", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06f4e019e245e05883b43893b9c15d75ab72a303/comments", "author": null, "committer": null, "parents": [{"sha": "ca34930415ad53674071f3d0280d775ea6d57ef0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca34930415ad53674071f3d0280d775ea6d57ef0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca34930415ad53674071f3d0280d775ea6d57ef0"}], "stats": {"total": 240, "additions": 214, "deletions": 26}, "files": [{"sha": "96e01267ac94d5daf8353ebd5581c0041b2a16a0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06f4e019e245e05883b43893b9c15d75ab72a303/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06f4e019e245e05883b43893b9c15d75ab72a303/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=06f4e019e245e05883b43893b9c15d75ab72a303", "patch": "@@ -1,3 +1,16 @@\n+2001-11-20  David Edelsohn  <edelsohn@gnu.org>\n+\n+\t* rs6000.c (rs6000_emit_eh_toc_restore): Remove ALIGN parm.\n+\n+\t* rs6000.c (rs6000_emit_move): Add TFmode case.\n+\t* sysv4.h (MASK_LONG_DOUBLE_128, TARGET_LONG_DOUBLE_128,\n+\tLONG_DOUBLE_TYPE_SIZE, MAX_LONG_DOUBLE_TYPE_SIZE,\n+\tLIBGCC2_LONG_DOUBLE_TYPE_SIZE): Move from here...\n+\t* rs6000.h: ... to here.\n+\t* rs6000.md (movtf, extenddftf2, extendsftf2, trunctfdf2,\n+\ttrunctfsf2, floatditf2, floatsitf2, fix_trunctfdi2,\n+\tfix_trunctfsi2, negtf2, abstf2, nabstf2): New patterns.\n+\n Tue Nov 20 06:41:38 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* emit-rtl.c (get_mem_attrs): Fix typo."}, {"sha": "d9b3e0902ec42096fc407e1b1d7c56fb33dd06f1", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06f4e019e245e05883b43893b9c15d75ab72a303/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06f4e019e245e05883b43893b9c15d75ab72a303/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=06f4e019e245e05883b43893b9c15d75ab72a303", "patch": "@@ -1935,6 +1935,7 @@ rs6000_emit_move (dest, source, mode)\n \toperands[1] = force_const_mem (mode, operands[1]);\n       break;\n \n+    case TFmode:\n     case DFmode:\n     case SFmode:\n       if (CONSTANT_P (operands[1]) \n@@ -6594,7 +6595,7 @@ rs6000_emit_eh_toc_restore (stacksize)\n   emit_label (loop_start);\n   \n   do_compare_rtx_and_jump (opcode, tocompare, NE, 1,\n-\t\t\t   SImode, NULL_RTX, 0, NULL_RTX,\n+\t\t\t   SImode, NULL_RTX, NULL_RTX,\n \t\t\t   no_toc_restore_needed);\n   \n   mem = gen_rtx_MEM (Pmode, \n@@ -6604,7 +6605,7 @@ rs6000_emit_eh_toc_restore (stacksize)\n \n   emit_label (no_toc_restore_needed);\n   do_compare_rtx_and_jump (top_of_stack, bottom_of_stack, EQ, 1,\n-\t\t\t   Pmode, NULL_RTX, 0, NULL_RTX,\n+\t\t\t   Pmode, NULL_RTX, NULL_RTX,\n \t\t\t   loop_exit);\n \n   mem = gen_rtx_MEM (Pmode, bottom_of_stack);"}, {"sha": "94aa09e8b9382b228f5400b677a366109b15cb55", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06f4e019e245e05883b43893b9c15d75ab72a303/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06f4e019e245e05883b43893b9c15d75ab72a303/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=06f4e019e245e05883b43893b9c15d75ab72a303", "patch": "@@ -217,6 +217,9 @@ extern int target_flags;\n /* Enhance the current ABI with AltiVec extensions.  */\n #define MASK_ALTIVEC_ABI\t0x00100000\n \n+/* Use 128-bit long double.  */\n+#define MASK_LONG_DOUBLE_128\t0x00200000\n+\n #define TARGET_POWER\t\t(target_flags & MASK_POWER)\n #define TARGET_POWER2\t\t(target_flags & MASK_POWER2)\n #define TARGET_POWERPC\t\t(target_flags & MASK_POWERPC)\n@@ -237,6 +240,7 @@ extern int target_flags;\n #define TARGET_SCHED_PROLOG\t(target_flags & MASK_SCHED_PROLOG)\n #define TARGET_ALTIVEC\t\t(target_flags & MASK_ALTIVEC)\n #define TARGET_ALTIVEC_ABI\t(target_flags & MASK_ALTIVEC_ABI)\n+#define TARGET_LONG_DOUBLE_128\t(target_flags & MASK_LONG_DOUBLE_128)\n \n #define TARGET_32BIT\t\t(! TARGET_64BIT)\n #define TARGET_HARD_FLOAT\t(! TARGET_SOFT_FLOAT)\n@@ -341,6 +345,10 @@ extern int target_flags;\n \t\t\tN_(\"Generate fused multiply/add instructions\")},\\\n   {\"no-fused-madd\",\tMASK_NO_FUSED_MADD,\t\t\t\t\\\n \t\t\tN_(\"Don't generate fused multiply/add instructions\")},\\\n+  {\"long-double-64\",\t-MASK_LONG_DOUBLE_128,\t\t\t\t\\\n+\t\t\tN_(\"Use 64 bit long doubles\") },\t\t\\\n+  {\"long-double-128\",\t MASK_LONG_DOUBLE_128, \t\t\t\t\\\n+\t\t\tN_(\"Use 128 bit long doubles\") },\t\t\\\n   {\"sched-prolog\",      MASK_SCHED_PROLOG,                              \\\n \t\t\t\"\"},\t\t\t\t\t\t\\\n   {\"no-sched-prolog\",   -MASK_SCHED_PROLOG,                             \\\n@@ -576,7 +584,18 @@ extern int rs6000_debug_arg;\t\t/* debug argument handling */\n /* A C expression for the size in bits of the type `long double' on\n    the target machine.  If you don't define this, the default is two\n    words.  */\n-#define LONG_DOUBLE_TYPE_SIZE 64\n+#define LONG_DOUBLE_TYPE_SIZE (TARGET_LONG_DOUBLE_128 ? 128 : 64)\n+\n+/* Constant which presents upper bound of the above value.  */\n+#define MAX_LONG_DOUBLE_TYPE_SIZE 128\n+\n+/* Define this to set long double type size to use in libgcc2.c, which can\n+   not depend on target_flags.  */\n+#ifdef __LONG_DOUBLE_128__\n+#define LIBGCC2_LONG_DOUBLE_TYPE_SIZE 128\n+#else\n+#define LIBGCC2_LONG_DOUBLE_TYPE_SIZE 64\n+#endif\n \n /* Width in bits of a pointer.\n    See also the macro `Pmode' defined below.  */"}, {"sha": "0292c57ec452e01f95549af5db4e24628ac791b2", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 177, "deletions": 0, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06f4e019e245e05883b43893b9c15d75ab72a303/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06f4e019e245e05883b43893b9c15d75ab72a303/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=06f4e019e245e05883b43893b9c15d75ab72a303", "patch": "@@ -7906,6 +7906,183 @@\n   [(set_attr \"type\" \"*,load,store,*,*,*\")\n    (set_attr \"length\" \"*,*,*,8,12,16\")])\n \f\n+(define_expand \"movtf\"\n+  [(set (match_operand:TF 0 \"general_operand\" \"\")\n+\t(match_operand:TF 1 \"any_operand\" \"\"))]\n+  \"DEFAULT_ABI == ABI_AIX && TARGET_HARD_FLOAT && TARGET_LONG_DOUBLE_128\"\n+  \"{ rs6000_emit_move (operands[0], operands[1], TFmode); DONE; }\")\n+\n+(define_insn \"*movtf_internal\"\n+  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=f,f,m,!r,!r,!r\")\n+\t(match_operand:TF 1 \"input_operand\" \"f,m,f,G,H,F\"))]\n+  \"DEFAULT_ABI == ABI_AIX && TARGET_HARD_FLOAT && TARGET_LONG_DOUBLE_128\n+   && (gpc_reg_operand (operands[0], TFmode)\n+       || gpc_reg_operand (operands[1], TFmode))\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    default:\n+      abort ();\n+    case 0:\n+      /* We normally copy the low-numbered register first.  However, if\n+\t the first register operand 0 is the same as the second register of\n+\t operand 1, we must copy in the opposite order.  */\n+      if (REGNO (operands[0]) == REGNO (operands[1]) + 1)\n+\treturn \\\"fmr %L0,%L1\\;fmr %0,%1\\\";\n+      else\n+\treturn \\\"fmr %0,%1\\;fmr %L0,%L1\\\";\n+    case 1:\n+      return \\\"lfd %0,%1\\;lfd %L0,%L1\\\";\n+    case 2:\n+      return \\\"stfd %1,%0\\;stfd %L1,%L0\\\";\n+    case 3:\n+    case 4:\n+    case 5:\n+      return \\\"#\\\";\n+    }\n+}\"\n+  [(set_attr \"type\" \"fp,fpload,fpstore,*,*,*\")\n+   (set_attr \"length\" \"8,8,8,12,16,20\")])\n+\n+(define_split\n+  [(set (match_operand:TF 0 \"gpc_reg_operand\" \"\")\n+\t(match_operand:TF 1 \"const_double_operand\" \"\"))]\n+  \"DEFAULT_ABI == ABI_AIX && TARGET_HARD_FLOAT && TARGET_LONG_DOUBLE_128\"\n+  [(set (match_dup 3) (match_dup 1))\n+   (set (match_dup 0)\n+\t(float_extend:TF (match_dup 3)))]\n+  \"\n+{\n+  operands[2] = operand_subword (operands[1], 0, 0, DFmode);\n+  operands[3] = gen_reg_rtx (DFmode);\n+}\")\n+\n+(define_insn_and_split \"extenddftf2\"\n+  [(set (match_operand:TF 0 \"gpc_reg_operand\" \"=f\")\n+\t(float_extend:TF (match_operand:DF 1 \"gpc_reg_operand\" \"f\")))]\n+  \"DEFAULT_ABI == ABI_AIX && TARGET_HARD_FLOAT && TARGET_LONG_DOUBLE_128\"\n+  \"#\"\n+  \"\"\n+  [(set (match_dup 2) (match_dup 3))]\n+  \"\n+{\n+  operands[2] = gen_rtx_REG (DFmode, REGNO (operands[0] + 1));\n+  operands[3] = CONST0_RTX (DFmode);\n+}\")\n+\n+(define_insn_and_split \"extendsftf2\"\n+  [(set (match_operand:TF 0 \"gpc_reg_operand\" \"=f\")\n+\t(float_extend:TF (match_operand:SF 1 \"gpc_reg_operand\" \"f\")))]\n+  \"DEFAULT_ABI == ABI_AIX && TARGET_HARD_FLOAT && TARGET_LONG_DOUBLE_128\"\n+  \"#\"\n+  \"\"\n+  [(set (match_dup 2) (match_dup 3))]\n+  \"\n+{\n+  operands[2] = gen_rtx_REG (SFmode, REGNO (operands[0] + 1));\n+  operands[3] = CONST0_RTX (SFmode);\n+}\")\n+\n+(define_insn \"trunctfdf2\"\n+  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=f\")\n+\t(float_truncate:DF (match_operand:TF 1 \"gpc_reg_operand\" \"f\")))]\n+  \"DEFAULT_ABI == ABI_AIX && TARGET_HARD_FLOAT && TARGET_LONG_DOUBLE_128\"\n+  \"fadd %0,%1,%L1\"\n+  [(set_attr \"type\" \"fp\")\n+   (set_attr \"length\" \"8\")])\n+\n+(define_insn_and_split \"trunctfsf2\"\n+  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n+\t(float_truncate:SF (match_operand:TF 1 \"gpc_reg_operand\" \"f\")))]\n+  \"DEFAULT_ABI == ABI_AIX && TARGET_HARD_FLOAT && TARGET_LONG_DOUBLE_128\"\n+  \"#\"\n+  \"\"\n+  [(set (match_dup 2)\n+\t(float_truncate:DF (match_dup 1)))\n+   (set (match_dup 0)\n+\t(float_truncate:SF (match_dup 2)))]\n+  \"\n+{\n+  operands[2] = gen_reg_rtx (DFmode);\n+}\")\n+\n+(define_expand \"floatditf2\"\n+  [(set (match_dup 2)\n+\t(float:DF (match_operand:DI 1 \"gpc_reg_operand\" \"\")))\n+   (set (match_operand:TF 0 \"gpc_reg_operand\" \"\")\n+\t(float_extend:TF (match_dup 2)))]\n+  \"DEFAULT_ABI == ABI_AIX && TARGET_POWERPC64\n+   && TARGET_HARD_FLOAT && TARGET_LONG_DOUBLE_128\"\n+  \"{ operands[2] = gen_reg_rtx (DFmode); }\")\n+\n+(define_expand \"floatsitf2\"\n+  [(set (match_dup 2)\n+\t(float:DF (match_operand:SI 1 \"gpc_reg_operand\" \"\")))\n+   (set (match_operand:TF 0 \"gpc_reg_operand\" \"\")\n+\t(float_extend:TF (match_dup 2)))]\n+  \"DEFAULT_ABI == ABI_AIX && TARGET_HARD_FLOAT && TARGET_LONG_DOUBLE_128\"\n+  \"{ operands[2] = gen_reg_rtx (DFmode); }\")\n+\n+(define_expand \"fix_trunctfdi2\"\n+  [(set (match_dup 2)\n+\t(float_truncate:DF (match_operand:TF 1 \"gpc_reg_operand\" \"\")))\n+   (set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n+\t(fix:SI (match_dup 2)))]\n+  \"DEFAULT_ABI == ABI_AIX && TARGET_POWERPC64\n+   && TARGET_HARD_FLOAT && TARGET_LONG_DOUBLE_128\"\n+  \"{ operands[2] = gen_reg_rtx (DFmode); }\")\n+\n+(define_expand \"fix_trunctfsi2\"\n+  [(set (match_dup 2)\n+\t(float_truncate:DF (match_operand:TF 1 \"gpc_reg_operand\" \"\")))\n+   (set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n+\t(fix:SI (match_dup 2)))]\n+  \"DEFAULT_ABI == ABI_AIX && TARGET_HARD_FLOAT && TARGET_LONG_DOUBLE_128\"\n+  \"{ operands[2] = gen_reg_rtx (DFmode); }\")\n+\n+(define_insn \"negtf2\"\n+  [(set (match_operand:TF 0 \"gpc_reg_operand\" \"=f\")\n+\t(neg:TF (match_operand:TF 1 \"gpc_reg_operand\" \"f\")))]\n+  \"DEFAULT_ABI == ABI_AIX && TARGET_HARD_FLOAT && TARGET_LONG_DOUBLE_128\"\n+  \"*\n+{\n+  if (REGNO (operands[0]) == REGNO (operands[1]) + 1)\n+    return \\\"fneg %L0,%L1\\;fneg %0,%1\\\";\n+  else\n+    return \\\"fneg %0,%1\\;fneg %L0,%L1\\\";\n+}\"\n+  [(set_attr \"type\" \"fp\")\n+   (set_attr \"length\" \"8\")])\n+\n+(define_insn \"abstf2\"\n+  [(set (match_operand:TF 0 \"gpc_reg_operand\" \"=f\")\n+\t(abs:TF (match_operand:TF 1 \"gpc_reg_operand\" \"f\")))]\n+  \"DEFAULT_ABI == ABI_AIX && TARGET_HARD_FLOAT && TARGET_LONG_DOUBLE_128\"\n+  \"*\n+{\n+  if (REGNO (operands[0]) == REGNO (operands[1]) + 1)\n+    return \\\"fabs %L0,%L1\\;fabs %0,%1\\\";\n+  else\n+    return \\\"fabs %0,%1\\;fabs %L0,%L1\\\";\n+}\"\n+  [(set_attr \"type\" \"fp\")\n+   (set_attr \"length\" \"8\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:TF 0 \"gpc_reg_operand\" \"=f\")\n+\t(neg:TF (abs:TF (match_operand:TF 1 \"gpc_reg_operand\" \"f\"))))]\n+  \"DEFAULT_ABI == ABI_AIX && TARGET_HARD_FLOAT && TARGET_LONG_DOUBLE_128\"\n+  \"*\n+{\n+  if (REGNO (operands[0]) == REGNO (operands[1]) + 1)\n+    return \\\"fnabs %L0,%L1\\;fnabs %0,%1\\\";\n+  else\n+    return \\\"fnabs %0,%1\\;fnabs %L0,%L1\\\";\n+}\"\n+  [(set_attr \"type\" \"fp\")\n+   (set_attr \"length\" \"8\")])\n+\f\n ;; Next come the multi-word integer load and store and the load and store\n ;; multiple insns.\n (define_expand \"movdi\""}, {"sha": "99e4c27ba036ec0457c7af22d4e0f55171eaa96e", "filename": "gcc/config/rs6000/sysv4.h", "status": "modified", "additions": 1, "deletions": 23, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06f4e019e245e05883b43893b9c15d75ab72a303/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06f4e019e245e05883b43893b9c15d75ab72a303/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fsysv4.h?ref=06f4e019e245e05883b43893b9c15d75ab72a303", "patch": "@@ -56,8 +56,7 @@ extern enum rs6000_sdata_type rs6000_sdata;\n #define\tMASK_LITTLE_ENDIAN\t0x04000000\t/* Target is little endian.  */\n #define\tMASK_REGNAMES\t\t0x02000000\t/* Use alternate register names.  */\n #define\tMASK_PROTOTYPE\t\t0x01000000\t/* Only prototyped fcns pass variable args.  */\n-#define MASK_LONG_DOUBLE_128\t0x00800000\t/* Use IEEE quad long double.  */\n-#define MASK_NO_BITFIELD_WORD\t0x00400000\t/* Bitfields cannot cross word boundaries */\n+#define MASK_NO_BITFIELD_WORD\t0x00800000\t/* Bitfields cannot cross word boundaries */\n \n #define\tTARGET_NO_BITFIELD_TYPE\t(target_flags & MASK_NO_BITFIELD_TYPE)\n #define\tTARGET_STRICT_ALIGN\t(target_flags & MASK_STRICT_ALIGN)\n@@ -66,7 +65,6 @@ extern enum rs6000_sdata_type rs6000_sdata;\n #define\tTARGET_LITTLE_ENDIAN\t(target_flags & MASK_LITTLE_ENDIAN)\n #define\tTARGET_REGNAMES\t\t(target_flags & MASK_REGNAMES)\n #define\tTARGET_PROTOTYPE\t(target_flags & MASK_PROTOTYPE)\n-#define TARGET_LONG_DOUBLE_128\t(target_flags & MASK_LONG_DOUBLE_128)\n #define TARGET_NO_BITFIELD_WORD\t(target_flags & MASK_NO_BITFIELD_WORD)\n #define\tTARGET_TOC\t\t((target_flags & MASK_64BIT)\t\t\\\n \t\t\t\t || ((target_flags & (MASK_RELOCATABLE\t\\\n@@ -126,10 +124,6 @@ extern int g_switch_set;\t\t/* Whether -G xx was passed.  */\n     N_(\"Produce big endian code.\") },\t\t\t\t\t\\\n   { \"big\",\t\t-MASK_LITTLE_ENDIAN,\t\t\t\t\\\n     N_(\"Produce big endian code.\") },\t\t\t\t\t\\\n-  { \"long-double-64\",\t-MASK_LONG_DOUBLE_128,\t\t\t\t\\\n-    N_(\"Use 64 bit long doubles\") },\t\t\t\t\t\\\n-  { \"long-double-128\",\t MASK_LONG_DOUBLE_128, \t\t\t\t\\\n-    N_(\"Use 128 bit long doubles\") },\t\t\t\t\t\\\n   { \"no-toc\",\t\t 0, N_(\"no description yet\") },\t\t\t\\\n   { \"toc\",\t\t MASK_MINIMAL_TOC, N_(\"no description yet\") },\t\\\n   { \"full-toc\",\t\t MASK_MINIMAL_TOC, N_(\"no description yet\") },\t\\\n@@ -366,22 +360,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n #undef\tWCHAR_TYPE_SIZE\n #define WCHAR_TYPE_SIZE 32\n \n-/* Define for support of TFmode long double and REAL_ARITHMETIC.\n-   PowerPC SVR4 ABI says that long double is 4 words.  */\n-#undef LONG_DOUBLE_TYPE_SIZE\n-#define LONG_DOUBLE_TYPE_SIZE (TARGET_LONG_DOUBLE_128 ? 128 : 64)\n-\n-/* Constant which presents upper bound of the above value.  */\n-#define MAX_LONG_DOUBLE_TYPE_SIZE 128\n-\n-/* Define this to set long double type size to use in libgcc2.c, which can\n-   not depend on target_flags.  */\n-#ifdef __LONG_DOUBLE_128__\n-#define LIBGCC2_LONG_DOUBLE_TYPE_SIZE 128\n-#else\n-#define LIBGCC2_LONG_DOUBLE_TYPE_SIZE 64\n-#endif\n-\n /* Make int foo : 8 not cause structures to be aligned to an int boundary.  */\n /* Override elfos.h definition.  */\n #undef\tPCC_BITFIELD_TYPE_MATTERS"}]}