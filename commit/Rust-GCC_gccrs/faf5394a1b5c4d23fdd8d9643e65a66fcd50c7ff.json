{"sha": "faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmFmNTM5NGExYjVjNGQyM2ZkZDhkOTY0M2U2NWE2NmZjZDUwYzdmZg==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-12-18T01:44:21Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-12-18T01:44:21Z"}, "message": "90th Cygnus<->FSF quick merge\n\nFrom-SVN: r13319", "tree": {"sha": "6bf6bd88d6fea39998ce4671f792fa0f2090aad5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6bf6bd88d6fea39998ce4671f792fa0f2090aad5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff/comments", "author": null, "committer": null, "parents": [{"sha": "a2f2ce96f8cb7b7a067a124de2eb3b1a4b9aa8fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2f2ce96f8cb7b7a067a124de2eb3b1a4b9aa8fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2f2ce96f8cb7b7a067a124de2eb3b1a4b9aa8fb"}], "stats": {"total": 762, "additions": 506, "deletions": 256}, "files": [{"sha": "1a2aaee49ff0752fec64421ee6aa6cf372ab06d1", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 159, "deletions": 4, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff", "patch": "@@ -1,9 +1,164 @@\n-Tue Nov 12 08:39:17 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+Mon Nov 25 15:16:41 1996  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n-        * decl.c (cp_finish_decl): In MINIMAL_PARSE_MODE, only try to use\n-        the DECL_VINDEX of DECL if it's set.\n+\t* Make-lang.in (c++.stage[1234]): Depend upon stage[1-4]-start, so\n+\tthat make -j3 bootstrap works better.\n \n-        * tree.c (mapcar): Handle RTL_EXPR.\n+Sun Nov 24 02:09:39 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* decl.c (pushtag): Do pushdecl for anon tags.\n+\n+Thu Nov 21 16:30:24 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* typeck.c (c_expand_return): Fix logic.\n+\t(unary_complex_lvalue): Avoid unused warning on address of INIT_EXPR.\n+\n+\t* decl.c (grokfndecl): Also note_debug_info_needed on ctype here.\n+\n+Wed Nov 20 18:47:31 1996  Bob Manson  <manson@charmed.cygnus.com>\n+\n+\t* g++.c (main): Make sure arglist has a final NULL entry.  Add\n+ \tPEXECUTE_LAST to the flags passed to pexecute, as otherwise\n+ \tstdin/stdout of the invoked program are redirected to\n+ \tnowheresville.\n+\n+Tue Nov 19 16:12:44 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* decl.c (implicitly_declare): Set DECL_ARTIFICIAL.\n+\n+Tue Nov 19 15:48:19 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* init.c (resolve_offset_ref): Handle obj.vfn better.\n+\t* typeck.c (build_component_ref): Set TREE_TYPE on result from\n+\tbuild_vfn_ref.\n+\n+Tue Nov 19 13:14:33 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* typeck.c (convert_for_assignment): Also handle anachronistic\n+\timplicit conversions from (::*)() to cv void*.\n+\t* cvt.c (cp_convert_to_pointer): Likewise.\n+\n+Mon Nov 18 17:05:26 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* lex.c (handle_cp_pragma): Fix bogus warning.\n+\n+Mon Nov 18 16:10:43 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* cvt.c (cp_convert_to_pointer): Avoid thinking a POINTER_TYPE\n+ \t(METHOD_TYPE) is a TYPE_PTRMEMFUNC_P.\n+\n+Thu Nov 14 23:18:17 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* class.c (finish_struct_1): Support DWARF2_DEBUG.\n+\t* search.c (dfs_debug_mark): Likewise.\n+\t* decl2.c (finish_vtable_vardecl): Likewise.\n+\t* decl.c (pushtag, finish_enum): Likewise.\n+\t* lex.c (check_newline): Use debug_* instead of calling *out\n+ \tfunctions directly.\n+\n+Thu Nov 14 15:21:46 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* Make-lang.in (cplib2.ready): Add else clause to avoid problems\n+\ton some picky hosts.\n+\n+Wed Nov 13 12:32:07 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* class.c (finish_struct_1): A class has a non-trivial copy\n+ \tconstructor if it has virtual functions.\n+\n+\t* cvt.c (cp_convert): Always call a constructor.\n+\n+\t* call.c (reference_binding): Still tack on a REF_BIND\n+ \tfor bad conversions.\n+\t(build_user_type_conversion_1): Propagate ICS_BAD_FLAG.\n+\n+\t* typeck.c (convert_arguments): Pass LOOKUP_ONLYCONVERTING.\n+\t(c_expand_return): Likewise.\n+\t* typeck2.c (digest_init): Likewise for { }.\n+\t* init.c (expand_aggr_init_1): Keep the CONSTRUCTOR handling.\n+\t* cvt.c (cp_convert): Handle failure better.\n+\n+Wed Nov 13 11:51:20 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* g++.c (main): Also set PEXECUTE_SEARCH, to make the invocation\n+\tof GCC be path-relative. \n+\n+Wed Nov 13 11:27:16 1996  Michael Meissner  <meissner@tiktok.cygnus.com>\n+\n+\t* Make-lang.in (g++-cross): G++-cross doesn't need version.o, but\n+\tit does need choose-temp.o and pexecute.o.\n+\n+Wed Nov 13 07:53:38 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* g++.c (error) [!HAVE_VPRINTF]: Put error back for the only time\n+\tthat we still use it.\n+\t(P_tmpdir, R_OK, W_OK, X_OK) [__MSDOS__]: Delete unnecessary macros.\n+\n+Wed Nov 13 02:00:26 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* init.c (expand_default_init): Avoid calling constructors to \n+\tinitialize reference temps.\n+\n+\t* cvt.c (convert_to_reference): Fix.\n+\n+Tue Nov 12 19:10:07 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* cvt.c (cp_convert): Simplify for flag_ansi_overloading.\n+\t(convert_to_reference): Likewise.\n+\t* typeck.c (convert_for_initialization): Likewise.\n+\t* init.c (expand_default_init): Likewise.\n+\t(expand_aggr_init_1): Likewise.\n+\t* cp-tree.h (CONV_NONCONVERTING): Lose.\n+\t* typeck.c (build_c_cast): Lose allow_nonconverting parm.\n+\t* *.c: Adjust.\n+\t* call.c (build_user_type_conversion_1): Assume LOOKUP_ONLYCONVERTING.\n+\n+Tue Nov 12 16:29:04 1996  Brendan Kehoe  <brendan@canuck.cygnus.com>\n+\n+\t* pt.c (tsubst_expr): Reverse args to expand_start_catch_block.\n+\n+Tue Nov 12 15:26:17 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* init.c (expand_aggr_init_1): Don't crash on non-constructor\n+\tTARGET_EXPR.\n+\n+Tue Nov 12 14:00:50 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* g++.c: Include gansidecl.h.\n+\t(VPROTO, PVPROTO, VA_START): Delete.\n+\t(choose_temp_base_try, choose_temp_base, perror_exec,\n+\trun_dos) [__MSDOS__]: Delete fns.\n+\t(pfatal_with_name): Delete fn.\n+\t(temp_filename): Declare like in gcc.c.\n+\t(pexecute, pwait, choose_temp_base): Declare from gcc.c.\n+\t(error_count, signal_count): Define.\n+\t(error): Delete both definitions.\n+\t(PEXECUTE_{FIRST,LAST,SEARCH,VERBOSE}): Define from gcc.c.\n+\t(pfatal_pexecute): Add fn from gcc.c.\n+\t(main): Rename local VERBOSE var to VERBOSE_FLAG.  Rewrite the\n+\tcode to use the pexecute stuff also used by gcc.c.\n+\t(MIN_FATAL_STATUS): Define.\n+\t* Make-lang.in (g++): Add dependency on and linking with\n+\tchoose-temp.o and pexecute.o.\n+\n+\t* cp-tree.h: Include gansidecl.h.\n+\t(STDIO_PROTO): Delete #undef/#define.\n+\t* cvt.c (NULL): Delete #undef/#define.\n+\t* expr.c (NULL): Likewise.\n+\t* init.c (NULL): Likewise.\n+\t* rtti.c (NULL): Likewise.\n+\t* xref.c (NULL): Likewise.\n+\n+\t* cp-tree.h (build_user_type_conversion): Add prototype.\n+\t* call.c (build_user_type_conversion): Delete prototype.  Correct\n+\tdecl of FLAGS arg to be an int.\n+\t* cvt.c (build_user_type_conversion): Likewise.\n+\n+Tue Nov 12 12:16:20 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* cp-tree.def: Add TRY_BLOCK and HANDLER.\n+\t* except.c (expand_start_catch_block): Support templates.\n+\t* parse.y (try_block, handler_seq): Likewise.\n+\t* pt.c (tsubst_expr): Support TRY_BLOCK and HANDLER.\n \n Mon Nov 11 13:57:31 1996  Jason Merrill  <jason@yorick.cygnus.com>\n "}, {"sha": "45037eb0f7106afa141bd6c56616f2cd7b1ebeeb", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff", "patch": "@@ -72,13 +72,13 @@ C++ c++: cc1plus\n .PHONY: C++ c++\n \n # Create the compiler driver for g++.\n-g++: $(srcdir)/cp/g++.c $(CONFIG_H) $(LIBDEPS)\n-\t$(CC) $(ALL_CFLAGS) $(INCLUDES) $(LDFLAGS) -o $@ $(srcdir)/cp/g++.c $(LIBS)\n+g++: $(srcdir)/cp/g++.c $(CONFIG_H) choose-temp.o pexecute.o $(LIBDEPS)\n+\t$(CC) $(ALL_CFLAGS) $(INCLUDES) $(LDFLAGS) -o $@ $(srcdir)/cp/g++.c choose-temp.o pexecute.o $(LIBS)\n \n # Create a version of the g++ driver which calls the cross-compiler.\n-g++-cross: $(srcdir)/cp/g++.c version.o $(LIBDEPS)\n+g++-cross: $(srcdir)/cp/g++.c choose-temp.o pexecute.o $(LIBDEPS)\n \t$(CC) $(ALL_CFLAGS) $(INCLUDES) $(LDFLAGS) -o $@ \\\n-\t   -DGCC_NAME=\\\"$(GCC_CROSS_NAME)\\\" $(srcdir)/cp/g++.c version.o $(LIBS)\n+\t   -DGCC_NAME=\\\"$(GCC_CROSS_NAME)\\\" $(srcdir)/cp/g++.c choose-temp.o pexecute.o $(LIBS)\n \n cxxmain.o: cplus-dem.c demangle.h\n \trm -f cxxmain.c\n@@ -150,6 +150,7 @@ cplib2.ready: $(GCC_PASSES) $(LIBGCC2_DEPS) stmp-int-hdrs\n \t    touch cplib2.ready; \\\n \t  fi; \\\n \t  rm -f cplib2.new; \\\n+\telse true ; \\\n \tfi\n \t@if [ -f cplib2.ready ]; then true; else \\\n \t  touch cplib2.ready; \\\n@@ -225,13 +226,13 @@ c++.maintainer-clean:\n # Stage hooks:\n # The main makefile has already created stage?/cp.\n \n-c++.stage1:\n+c++.stage1: stage1-start\n \t-mv cp/*$(objext) stage1/cp\n-c++.stage2:\n+c++.stage2: stage2-start\n \t-mv cp/*$(objext) stage2/cp\n-c++.stage3:\n+c++.stage3: stage3-start\n \t-mv cp/*$(objext) stage3/cp\n-c++.stage4:\n+c++.stage4: stage4-start\n \t-mv cp/*$(objext) stage4/cp\n \f\n # Maintenance hooks:"}, {"sha": "dc86dc3824261da930b747203e4da4697ceea0c3", "filename": "gcc/cp/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff/gcc%2Fcp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff/gcc%2Fcp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMakefile.in?ref=faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff", "patch": "@@ -242,7 +242,7 @@ except.o : except.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h $(RTL_H) $(sr\n expr.o : expr.c $(CONFIG_H) $(CXX_TREE_H) $(RTL_H) $(srcdir)/../flags.h \\\n   $(srcdir)/../expr.h ../insn-codes.h\n xref.o : xref.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../input.h\n-pt.o : pt.c $(CONFIG_H) $(CXX_TREE_H) decl.h $(PARSE_H)\n+pt.o : pt.c $(CONFIG_H) $(CXX_TREE_H) decl.h $(PARSE_H) lex.h\n error.o : error.c $(CONFIG_H) $(CXX_TREE_H)\n errfn.o : errfn.c $(CONFIG_H) $(CXX_TREE_H)\n sig.o : sig.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h"}, {"sha": "d1adc3ab4cc7d2748094dd40f0c2b16a4d06df58", "filename": "gcc/cp/call.c", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff", "patch": "@@ -3179,8 +3179,7 @@ reference_binding (rto, from, expr, flags)\n   else\n     conv = NULL_TREE;\n \n-  if (! conv && TYPE_READONLY (to) && ! TYPE_VOLATILE (to)\n-      && (flags & LOOKUP_NO_TEMP_BIND) == 0)\n+  if (! conv)\n     {\n       conv = standard_conversion\n \t(TYPE_MAIN_VARIANT (to), strip_top_quals (from), expr);\n@@ -3192,15 +3191,10 @@ reference_binding (rto, from, expr, flags)\n \t  if (TREE_CODE (TREE_OPERAND (conv, 0)) == BASE_CONV)\n \t    TREE_OPERAND (conv, 0) = TREE_OPERAND (TREE_OPERAND (conv, 0), 0);\n \t}\n-    }\n-\n-  if (! conv)\n-    {\n-      conv = standard_conversion\n-\t(TYPE_MAIN_VARIANT (to), strip_top_quals (from), expr);\n-      if (conv)\n+      if (conv && ! (TYPE_READONLY (to) && ! TYPE_VOLATILE (to)\n+\t\t     && (flags & LOOKUP_NO_TEMP_BIND) == 0))\n \tICS_BAD_FLAG (conv) = 1;\n-    }\t\n+    }\n \n   return conv;\n }\n@@ -4149,7 +4143,7 @@ print_z_candidates (candidates)\n \t}\n       else\n \tcp_error_at (\"%s %+D%s\", str, candidates->fn,\n-\t\t     candidates->viable == -1 ? \" <bad>\" : \"\");\n+\t\t     candidates->viable == -1 ? \" <near match>\" : \"\");\n       str = \"               \"; \n     }\n }\n@@ -4189,7 +4183,7 @@ build_user_type_conversion_1 (totype, expr, flags)\n     }\n   for (; ctors; ctors = DECL_CHAIN (ctors))\n     {\n-      if ((flags & LOOKUP_ONLYCONVERTING) && DECL_NONCONVERTING_P (ctors))\n+      if (DECL_NONCONVERTING_P (ctors))\n \tcontinue;\n \n       candidates = add_function_candidate (candidates, ctors, args, flags);\n@@ -4259,13 +4253,16 @@ build_user_type_conversion_1 (totype, expr, flags)\n       ? totype : non_reference (TREE_TYPE (TREE_TYPE (cand->fn)))),\n      NULL_TREE, cand->fn, cand->convs, cand->basetype_path);\n   ICS_USER_FLAG (cand->second_conv) = 1;\n+  if (cand->viable == -1)\n+    ICS_BAD_FLAG (cand->second_conv) = 1;\n \n   return cand;\n }\n \n tree\n build_user_type_conversion (totype, expr, flags)\n-     tree totype, expr, flags;\n+     tree totype, expr;\n+     int flags;\n {\n   struct z_candidate *cand\n     = build_user_type_conversion_1 (totype, expr, flags);\n@@ -5237,7 +5234,7 @@ build_new_method_call (instance, name, args, basetype_path, flags)\n       mem_args = tree_cons (NULL_TREE, instance_ptr, args);\n       for (; t; t = DECL_CHAIN (t))\n \t{\n-\t  /* XXX copy-init should go through build_user_type_conversion.  */\n+\t  /* We can end up here for copy-init of same or base class.  */\n \t  if (name == ctor_identifier\n \t      && (flags & LOOKUP_ONLYCONVERTING)\n \t      && DECL_NONCONVERTING_P (t))"}, {"sha": "67498ee6c9dd3d6c1dde645521e742cc75327d6f", "filename": "gcc/cp/class.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff", "patch": "@@ -3593,10 +3593,10 @@ finish_struct_1 (t, warn_anon)\n \n   TYPE_HAS_COMPLEX_INIT_REF (t)\n     |= (TYPE_HAS_INIT_REF (t) || TYPE_USES_VIRTUAL_BASECLASSES (t)\n-\t|| any_default_members);\n+\t|| has_virtual || any_default_members);\n   TYPE_NEEDS_CONSTRUCTING (t)\n     |= (TYPE_HAS_CONSTRUCTOR (t) || TYPE_USES_VIRTUAL_BASECLASSES (t)\n-\t|| has_virtual || any_default_members || first_vfn_base_index >= 0);\n+\t|| has_virtual || any_default_members);\n   if (! IS_SIGNATURE (t))\n     CLASSTYPE_NON_AGGREGATE (t)\n       = ! aggregate || has_virtual || TYPE_HAS_CONSTRUCTOR (t);\n@@ -4180,7 +4180,7 @@ finish_struct_1 (t, warn_anon)\n     }\n #endif\n \n-  if (write_symbols != DWARF_DEBUG)\n+  if (write_symbols != DWARF_DEBUG && write_symbols != DWARF2_DEBUG)\n     {\n       /* If the type has methods, we want to think about cutting down\n \t the amount of symbol table stuff we output.  The value stored in"}, {"sha": "be97b02ca95e08cac98201eb0ddf59a0f906cc7c", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff", "patch": "@@ -138,6 +138,8 @@ DEFTREECODE (GOTO_STMT, \"goto_stmt\", \"e\", 1)\n DEFTREECODE (CTOR_INITIALIZER, \"ctor_initializer\", \"e\", 2)\n DEFTREECODE (CASE_LABEL, \"case_label\", \"e\", 2)\n DEFTREECODE (RETURN_INIT, \"return_init\", \"e\", 2)\n+DEFTREECODE (TRY_BLOCK, \"try_stmt\", \"e\", 2)\n+DEFTREECODE (HANDLER, \"catch_stmt\", \"e\", 2)\n \n DEFTREECODE (IDENTITY_CONV, \"identity_conv\", \"e\", 1)\n DEFTREECODE (LVALUE_CONV, \"lvalue_conv\", \"e\", 1)"}, {"sha": "528f1b7f42b6acb07d5e2e9572ad03077784bcc7", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff", "patch": "@@ -22,17 +22,7 @@ Boston, MA 02111-1307, USA.  */\n #ifndef _CP_TREE_H\n #define _CP_TREE_H\n \n-/* Borrow everything that is C from c-tree.h,\n-   but do so by copy, not by inclusion, since c-tree.h defines\n-   lang_identifier.  */\n-\n-#ifndef STDIO_PROTO\n-#ifdef BUFSIZ\n-#define STDIO_PROTO(ARGS) PROTO(ARGS)\n-#else\n-#define STDIO_PROTO(ARGS) ()\n-#endif\n-#endif\n+#include \"gansidecl.h\"\n \n /* Language-dependent contents of an identifier.  */\n \n@@ -1881,7 +1871,6 @@ extern tree current_class_type;\t/* _TYPE: the type of the current class */\n    CONV_CONST      :  Perform the explicit conversions for const_cast.\n    CONV_REINTERPRET:  Perform the explicit conversions for reinterpret_cast.\n    CONV_PRIVATE    :  Perform upcasts to private bases.\n-   CONV_NONCONVERTING : Allow non-converting constructors to be used.\n    CONV_FORCE_TEMP :  Require a new temporary when converting to the same\n    \t\t      aggregate type.  */\n \n@@ -1890,7 +1879,7 @@ extern tree current_class_type;\t/* _TYPE: the type of the current class */\n #define CONV_CONST       4\n #define CONV_REINTERPRET 8\n #define CONV_PRIVATE\t 16\n-#define CONV_NONCONVERTING 32\n+/* #define CONV_NONCONVERTING 32 */\n #define CONV_FORCE_TEMP  64\n #define CONV_STATIC_CAST (CONV_IMPLICIT | CONV_STATIC | CONV_FORCE_TEMP)\n #define CONV_OLD_CONVERT (CONV_IMPLICIT | CONV_STATIC | CONV_CONST \\\n@@ -1938,7 +1927,7 @@ extern void overflow_warning\t\t\tPROTO((tree));\n extern void unsigned_conversion_warning\t\tPROTO((tree, tree));\n \n /* in call.c */\n-extern struct candidate *ansi_c_bullshit;\n+extern struct candidate *ansi_c_filler;\n \n extern int rank_for_overload\t\t\tPROTO((struct candidate *, struct candidate *));\n extern int can_convert\t\t\t\tPROTO((tree, tree));\n@@ -1955,6 +1944,7 @@ extern tree build_method_call\t\t\tPROTO((tree, tree, tree, tree, int));\n extern tree build_overload_call_real\t\tPROTO((tree, tree, int, struct candidate *, int));\n extern tree build_overload_call\t\t\tPROTO((tree, tree, int));\n extern tree build_new_method_call\t\tPROTO((tree, tree, tree, tree, int));\n+extern tree build_user_type_conversion\t\tPROTO((tree, tree, int));\n extern tree build_new_function_call\t\tPROTO((tree, tree, tree));\n extern tree build_new_op\t\t\tPROTO((enum tree_code, int, tree, tree, tree));\n \n@@ -2471,7 +2461,7 @@ extern tree build_compound_expr\t\t\tPROTO((tree));\n extern tree build_static_cast\t\t\tPROTO((tree, tree));\n extern tree build_reinterpret_cast\t\tPROTO((tree, tree));\n extern tree build_const_cast\t\t\tPROTO((tree, tree));\n-extern tree build_c_cast\t\t\tPROTO((tree, tree, int));\n+extern tree build_c_cast\t\t\tPROTO((tree, tree));\n extern tree build_x_modify_expr\t\t\tPROTO((tree, enum tree_code, tree));\n extern tree build_modify_expr\t\t\tPROTO((tree, enum tree_code, tree));\n extern int language_lvalue_valid\t\tPROTO((tree));"}, {"sha": "410a34b00c71c361162f6e5d0b6bd14e96d26562", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 80, "deletions": 55, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff", "patch": "@@ -32,10 +32,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"class.h\"\n #include \"convert.h\"\n \n-#undef NULL\n-#define NULL (char *)0\n-\n-tree build_user_type_conversion ();\n+extern tree static_aggregates;\n \n /* Change of width--truncation and extension of integers or reals--\n    is represented with NOP_EXPR.  Proper functioning of many things\n@@ -151,21 +148,18 @@ cp_convert_to_pointer (type, expr)\n \n   if (TYPE_PTRMEMFUNC_P (type))\n     type = TYPE_PTRMEMFUNC_FN_TYPE (type);\n-  if (TYPE_PTRMEMFUNC_P (intype))\n-    intype = TYPE_PTRMEMFUNC_FN_TYPE (intype);\n \n-  /* Handle anachronistic conversions from (::*)() to void* or (*)().  */\n+  /* Handle anachronistic conversions from (::*)() to cv void* or (*)().  */\n   if (TREE_CODE (type) == POINTER_TYPE\n       && (TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE\n-\t  || TREE_TYPE (type) == void_type_node))\n+\t  || TYPE_MAIN_VARIANT (TREE_TYPE (type)) == void_type_node))\n     {\n       /* Allow an implicit this pointer for pointer to member\n \t functions.  */\n-      if (TREE_CODE (intype) == POINTER_TYPE\n-\t  && TREE_CODE (TREE_TYPE (intype)) == METHOD_TYPE)\n+      if (TYPE_PTRMEMFUNC_P (intype))\n \t{\n \t  tree decl, basebinfo;\n-\t  tree fntype = TREE_TYPE (intype);\n+\t  tree fntype = TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (intype));\n \t  tree t = TYPE_METHOD_BASETYPE (fntype);\n \n \t  if (current_class_type == 0\n@@ -198,6 +192,9 @@ cp_convert_to_pointer (type, expr)\n       intype = TREE_TYPE (expr);\n     }\n \n+  if (TYPE_PTRMEMFUNC_P (intype))\n+    intype = TYPE_PTRMEMFUNC_FN_TYPE (intype);\n+\n   form = TREE_CODE (intype);\n \n   if (form == POINTER_TYPE || form == REFERENCE_TYPE)\n@@ -589,7 +586,7 @@ build_up_reference (type, arg, flags, checkconst)\n       break;\n     }\n \n-  if ((flags&DIRECT_BIND)\n+  if ((flags & DIRECT_BIND)\n       && ! real_lvalue_p (targ))\n     {\n       if (toplevel_bindings_p ())\n@@ -605,7 +602,7 @@ build_up_reference (type, arg, flags, checkconst)\n       DECL_INITIAL (arg) = targ;\n       cp_finish_decl (arg, targ, NULL_TREE, 0, LOOKUP_ONLYCONVERTING);\n     }\n-  else if (TREE_ADDRESSABLE (targ) == 0 && !(flags&DIRECT_BIND))\n+  else if (TREE_ADDRESSABLE (targ) == 0 && !(flags & DIRECT_BIND))\n     {\n       tree slot = build_decl (VAR_DECL, NULL_TREE, argtype);\n       arg = build (TARGET_EXPR, argtype, slot, arg, NULL_TREE, NULL_TREE);\n@@ -737,7 +734,19 @@ convert_to_reference (reftype, expr, convtype, flags, decl)\n       if (rval != error_mark_node)\n \trval = build1 (NOP_EXPR, reftype, rval);\n     }\n-  else if (decl)\n+  else if (flag_ansi_overloading)\n+    {\n+      rval = convert_for_initialization (NULL_TREE, type, expr, flags,\n+\t\t\t\t\t \"converting\", 0, 0);\n+      if (rval == error_mark_node)\n+\treturn error_mark_node;\n+      rval = build_up_reference (reftype, rval, flags, 1);\n+\n+      if (rval && ! TYPE_READONLY (TREE_TYPE (reftype)))\n+\tcp_pedwarn (\"initializing non-const `%T' with `%T' will use a temporary\",\n+\t\t    reftype, intype);\n+    }\n+  else\n     {\n       tree rval_as_ctor = NULL_TREE;\n       \n@@ -766,7 +775,6 @@ convert_to_reference (reftype, expr, convtype, flags, decl)\n \n \t  if (toplevel_bindings_p ())\n \t    {\n-\t      extern tree static_aggregates;\n \t      tree t = get_temp_name (type, toplevel_bindings_p ());\n \t      init = build_method_call (t, ctor_identifier,\n \t\t\t\t\tbuild_tree_list (NULL_TREE, expr),\n@@ -1274,50 +1282,67 @@ cp_convert (type, expr, convtype, flags)\n \t There may be some ambiguity between using a constructor\n \t vs. using a type conversion operator when both apply.  */\n \n-      if (IS_AGGR_TYPE (dtype) && ! DERIVED_FROM_P (type, dtype)\n-\t  && TYPE_HAS_CONVERSION (dtype))\n-\tconversion = build_type_conversion (CONVERT_EXPR, type, e, 1);\n-\n-      if (conversion == error_mark_node)\n+      if (flag_ansi_overloading)\n \t{\n-\t  if (flags & LOOKUP_COMPLAIN)\n-\t    error (\"ambiguous pointer conversion\");\n-\t  return conversion;\n+\t  ctor = e;\n+\t  \n+\t  if ((flags & LOOKUP_ONLYCONVERTING)\n+\t      && ! (IS_AGGR_TYPE (dtype) && DERIVED_FROM_P (type, dtype)))\n+\t    ctor = build_user_type_conversion (type, ctor, flags);\n+\t  if (ctor)\n+\t    ctor = build_method_call (NULL_TREE, ctor_identifier,\n+\t\t\t\t      build_tree_list (NULL_TREE, ctor),\n+\t\t\t\t      TYPE_BINFO (type), flags);\n+\t  if (ctor)\n+\t    return build_cplus_new (type, ctor);\n \t}\n-\n-      if (TYPE_HAS_CONSTRUCTOR (complete_type (type))\n-\t  && (! flag_ansi_overloading || ! conversion))\n-\tctor = build_method_call (NULL_TREE, ctor_identifier,\n-\t\t\t\t  build_tree_list (NULL_TREE, e),\n-\t\t\t\t  TYPE_BINFO (type),\n-\t\t\t\t  (flags & LOOKUP_NORMAL) | LOOKUP_SPECULATIVELY\n-\t\t\t\t  | (convtype & CONV_NONCONVERTING ? 0 : LOOKUP_ONLYCONVERTING)\n-\t\t\t\t  | (flags & LOOKUP_NO_CONVERSION)\n-\t\t\t\t  | (conversion ? LOOKUP_NO_CONVERSION : 0));\n-\n-      if (ctor == error_mark_node)\n+      else\n \t{\n-\t  if (flags & LOOKUP_COMPLAIN)\n-\t    cp_error (\"in conversion to type `%T'\", type);\n-\t  if (flags & LOOKUP_SPECULATIVELY)\n-\t    return NULL_TREE;\n-\t  return error_mark_node;\n-\t}\n+\t  if (IS_AGGR_TYPE (dtype) && ! DERIVED_FROM_P (type, dtype)\n+\t      && TYPE_HAS_CONVERSION (dtype))\n+\t    conversion = build_type_conversion (CONVERT_EXPR, type, e, 1);\n+\n+\t  if (conversion == error_mark_node)\n+\t    {\n+\t      if (flags & LOOKUP_COMPLAIN)\n+\t\terror (\"ambiguous pointer conversion\");\n+\t      return conversion;\n+\t    }\n+\n+\t  if (TYPE_HAS_CONSTRUCTOR (complete_type (type)))\n+\t    ctor = build_method_call (NULL_TREE, ctor_identifier,\n+\t\t\t\t      build_tree_list (NULL_TREE, e),\n+\t\t\t\t      TYPE_BINFO (type),\n+\t\t\t\t      (flags & LOOKUP_NORMAL)\n+\t\t\t\t      | LOOKUP_SPECULATIVELY\n+\t\t\t\t      | (flags & LOOKUP_ONLYCONVERTING)\n+\t\t\t\t      | (flags & LOOKUP_NO_CONVERSION)\n+\t\t\t\t      | (conversion ? LOOKUP_NO_CONVERSION : 0));\n+\n+\t  if (ctor == error_mark_node)\n+\t    {\n+\t      if (flags & LOOKUP_COMPLAIN)\n+\t\tcp_error (\"in conversion to type `%T'\", type);\n+\t      if (flags & LOOKUP_SPECULATIVELY)\n+\t\treturn NULL_TREE;\n+\t      return error_mark_node;\n+\t    }\n       \n-      if (conversion && ctor)\n-\t{\n-\t  if (flags & LOOKUP_COMPLAIN)\n-\t    error (\"both constructor and type conversion operator apply\");\n-\t  if (flags & LOOKUP_SPECULATIVELY)\n-\t    return NULL_TREE;\n-\t  return error_mark_node;\n-\t}\n-      else if (conversion)\n-\treturn conversion;\n-      else if (ctor)\n-\t{\n-\t  ctor = build_cplus_new (type, ctor);\n-\t  return ctor;\n+\t  if (conversion && ctor)\n+\t    {\n+\t      if (flags & LOOKUP_COMPLAIN)\n+\t\terror (\"both constructor and type conversion operator apply\");\n+\t      if (flags & LOOKUP_SPECULATIVELY)\n+\t\treturn NULL_TREE;\n+\t      return error_mark_node;\n+\t    }\n+\t  else if (conversion)\n+\t    return conversion;\n+\t  else if (ctor)\n+\t    {\n+\t      ctor = build_cplus_new (type, ctor);\n+\t      return ctor;\n+\t    }\n \t}\n     }\n "}, {"sha": "ebfc6b45a1b848794c2111dde28e9c2b9ccaa288", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff", "patch": "@@ -2077,15 +2077,10 @@ pushtag (name, type, globalize)\n \t      if (! globalize && processing_template_decl && IS_AGGR_TYPE (type))\n \t\tpush_template_decl (d);\n \n-\t      /* If it is anonymous, then we are called from pushdecl,\n-\t\t and we don't want to infinitely recurse.  */\n-\t      if (! ANON_AGGRNAME_P (name))\n-\t\t{\n-\t\t  if (b->parm_flag == 2)\n-\t\t    d = pushdecl_class_level (d);\n-\t\t  else\n-\t\t    d = pushdecl_with_scope (d, b);\n-\t\t}\n+\t      if (b->parm_flag == 2)\n+\t\td = pushdecl_class_level (d);\n+\t      else\n+\t\td = pushdecl_with_scope (d, b);\n \t    }\n \t  else\n \t    {\n@@ -2102,7 +2097,7 @@ pushtag (name, type, globalize)\n \t    }\n \t  if (newdecl)\n \t    {\n-\t      if (write_symbols != DWARF_DEBUG)\n+\t      if (write_symbols != DWARF_DEBUG && write_symbols != DWARF2_DEBUG)\n \t\t{\n \t\t  if (ANON_AGGRNAME_P (name))\n \t\t    DECL_IGNORED_P (d) = 1;\n@@ -3589,6 +3584,7 @@ implicitly_declare (functionid)\n \n   DECL_EXTERNAL (decl) = 1;\n   TREE_PUBLIC (decl) = 1;\n+  DECL_ARTIFICIAL (decl) = 1;\n \n   /* ANSI standard says implicit declarations are in the innermost block.\n      So we record the decl in the standard fashion.  */\n@@ -6211,8 +6207,7 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n     {\n       if (init && DECL_INITIAL (decl))\n \tDECL_INITIAL (decl) = init;\n-      if (minimal_parse_mode && ! DECL_ARTIFICIAL (decl)\n-\t  && DECL_VINDEX (decl))\n+      if (minimal_parse_mode && ! DECL_ARTIFICIAL (decl))\n \t{\n \t  tree stmt = DECL_VINDEX (decl);\n \t  DECL_VINDEX (decl) = NULL_TREE;\n@@ -7129,7 +7124,15 @@ grokfndecl (ctype, type, declarator, virtualp, flags, quals,\n     return decl;\n \n   if (check && funcdef_flag)\n-    DECL_INITIAL (decl) = error_mark_node;\n+    {\n+      /* Do this before the decl is actually defined so that the DWARF debug\n+\t info for the class reflects the declaration, rather than the\n+\t definition, of this decl.  */\n+      if (ctype)\n+\tnote_debug_info_needed (ctype);\n+\n+      DECL_INITIAL (decl) = error_mark_node;\n+    }\n \n   if (flags == NO_SPECIAL && ctype && constructor_name (cname) == declarator)\n     {\n@@ -10716,7 +10719,7 @@ finish_enum (enumtype, values)\n   }\n \n   /* Finish debugging output for this type.  */\n-  if (write_symbols != DWARF_DEBUG)\n+  if (write_symbols != DWARF_DEBUG && write_symbols != DWARF2_DEBUG)\n     rest_of_type_compilation (enumtype, global_bindings_p ());\n \n   return enumtype;"}, {"sha": "a2d73c4bf25d637506f20421d698636b8a0cb985", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff", "patch": "@@ -2423,8 +2423,7 @@ finish_vtable_vardecl (prev, vars)\n       if (TREE_TYPE (DECL_INITIAL (vars)) == 0)\n \tstore_init_value (vars, DECL_INITIAL (vars));\n \n-#ifdef DWARF_DEBUGGING_INFO\n-      if (write_symbols == DWARF_DEBUG)\n+      if (write_symbols == DWARF_DEBUG || write_symbols == DWARF2_DEBUG)\n \t{\n \t  /* Mark the VAR_DECL node representing the vtable itself as a\n \t     \"gratuitous\" one, thereby forcing dwarfout.c to ignore it.\n@@ -2449,7 +2448,6 @@ finish_vtable_vardecl (prev, vars)\n \n \t  DECL_IGNORED_P (vars) = 1;\n \t}\n-#endif /* DWARF_DEBUGGING_INFO */\n \n       rest_of_decl_compilation (vars, NULL_PTR, 1, 1);\n       return 1;\n@@ -3190,7 +3188,7 @@ reparse_absdcl_as_casts (decl, expr)\n     {\n       type = groktypename (TREE_VALUE (TREE_OPERAND (decl, 1)));\n       decl = TREE_OPERAND (decl, 0);\n-      expr = build_c_cast (type, expr, 0);\n+      expr = build_c_cast (type, expr);\n     }\n \n   return expr;"}, {"sha": "21522508fc5c608612e8535c415ab839e64bcff6", "filename": "gcc/cp/except.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff", "patch": "@@ -425,6 +425,21 @@ expand_start_catch_block (declspecs, declarator)\n   tree decl = NULL_TREE;\n   tree init;\n \n+  if (processing_template_decl)\n+    {\n+      if (declspecs)\n+\t{\n+\t  decl = grokdeclarator (declarator, declspecs, CATCHPARM,\n+\t\t\t\t 1, NULL_TREE);\n+\t  pushdecl (decl);\n+\t  decl = build_min_nt (DECL_STMT, copy_to_permanent (declarator),\n+\t\t\t       copy_to_permanent (declspecs),\n+\t\t\t       NULL_TREE);\n+\t  add_tree (decl);\n+\t}\n+      return;\n+    }\n+\n   if (! doing_eh (1))\n     return;\n "}, {"sha": "8aa142d12ff270165950e18c5c42230a4341a25f", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff", "patch": "@@ -27,9 +27,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"expr.h\"\n #include \"cp-tree.h\"\n \n-#undef NULL\n-#define NULL 0\n-\n /* Hook used by expand_expr to expand language-specific tree codes.  */\n \n rtx"}, {"sha": "154ab8068fc2d071e54ac70b2b24653beab6271e", "filename": "gcc/cp/init.c", "status": "modified", "additions": 56, "deletions": 30, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff", "patch": "@@ -29,9 +29,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"flags.h\"\n #include \"output.h\"\n \n-#undef NULL\n-#define NULL 0\n-\n /* In C++, structures with well-defined constructors are initialized by\n    those constructors, unasked.  CURRENT_BASE_INIT_LIST\n    holds a list of stmts for a BASE_INIT term in the grammar.\n@@ -1269,14 +1266,36 @@ expand_default_init (binfo, true_exp, exp, init, alias_this, flags)\n   tree rval;\n   tree parms;\n \n+  if (flag_ansi_overloading && init && TREE_CODE (init) != TREE_LIST\n+      && (flags & LOOKUP_ONLYCONVERTING))\n+    {\n+      /* Base subobjects should only get direct-initialization.  */\n+      if (true_exp != exp)\n+\tabort ();\n+\n+      /* We special-case TARGET_EXPRs here to avoid an error about\n+\t private copy constructors for temporaries bound to reference vars.\n+\t If the TARGET_EXPR represents a call to a function that has\n+\t permission to create such objects, a reference can bind directly\n+\t to the return value.  An object variable must be initialized\n+\t via the copy constructor, even if the call is elided.  */\n+      if (! (TREE_CODE (exp) == VAR_DECL && DECL_ARTIFICIAL (exp)\n+\t     && TREE_CODE (init) == TARGET_EXPR && TREE_TYPE (init) == type))\n+\tinit = cp_convert (type, init, CONV_IMPLICIT|CONV_FORCE_TEMP, flags);\n+\n+      expand_assignment (exp, init, 0, 0);\n+      return;\n+    }\n+\n   if (init == NULL_TREE\n       || (TREE_CODE (init) == TREE_LIST && ! TREE_TYPE (init)))\n     {\n       parms = init;\n       if (parms)\n \tinit = TREE_VALUE (parms);\n     }\n-  else if (TREE_CODE (init) == INDIRECT_REF && TREE_HAS_CONSTRUCTOR (init)\n+  else if (! flag_ansi_overloading\n+\t   && TREE_CODE (init) == INDIRECT_REF && TREE_HAS_CONSTRUCTOR (init)\n \t   && TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (TREE_TYPE (init)))\n     {\n       rval = convert_for_initialization (exp, type, init, 0, 0, 0, 0);\n@@ -1296,6 +1315,14 @@ expand_default_init (binfo, true_exp, exp, init, alias_this, flags)\n       flags |= LOOKUP_HAS_IN_CHARGE;\n     }\n \n+  if (flag_ansi_overloading)\n+    {\n+      rval = build_method_call (exp, ctor_identifier,\n+\t\t\t\tparms, binfo, flags);\n+      expand_expr_stmt (rval);\n+      return;\n+    }\n+\n   if (init && TREE_CHAIN (parms) == NULL_TREE\n       && TYPE_HAS_TRIVIAL_INIT_REF (type)\n       && TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (TREE_TYPE (init)))\n@@ -1376,7 +1403,24 @@ expand_aggr_init_1 (binfo, true_exp, exp, init, alias_this, flags)\n      NULL_TREE, know that it was meant for us--just slide exp on\n      in and expand the constructor.  Constructors now come\n      as TARGET_EXPRs.  */\n-  if (init)\n+\n+  if (init && TREE_CODE (exp) == VAR_DECL\n+      && TREE_CODE (init) == CONSTRUCTOR\n+      && TREE_HAS_CONSTRUCTOR (init))\n+    {\n+      tree t = store_init_value (exp, init);\n+      if (!t)\n+\t{\n+\t  expand_decl_init (exp);\n+\t  return;\n+\t}\n+      t = build (INIT_EXPR, type, exp, init);\n+      TREE_SIDE_EFFECTS (t) = 1;\n+      expand_expr_stmt (t);\n+      return;\n+    }\n+\n+  if (init && ! flag_ansi_overloading)\n     {\n       tree init_list = NULL_TREE;\n \n@@ -1457,7 +1501,7 @@ expand_aggr_init_1 (binfo, true_exp, exp, init, alias_this, flags)\n \t{\n \t  tree tmp = TREE_OPERAND (TREE_OPERAND (init, 1), 1);\n \n-\t  if (TREE_CODE (TREE_VALUE (tmp)) == NOP_EXPR\n+\t  if (tmp && TREE_CODE (TREE_VALUE (tmp)) == NOP_EXPR\n \t      && TREE_OPERAND (TREE_VALUE (tmp), 0) == integer_zero_node)\n \t    {\n \t      /* In order for this to work for RESULT_DECLs, if their\n@@ -1487,22 +1531,6 @@ expand_aggr_init_1 (binfo, true_exp, exp, init, alias_this, flags)\n \t    }\n \t}\n \n-      if (TREE_CODE (exp) == VAR_DECL\n-\t  && TREE_CODE (init) == CONSTRUCTOR\n-\t  && TREE_HAS_CONSTRUCTOR (init))\n-\t{\n-\t  tree t = store_init_value (exp, init);\n-\t  if (!t)\n-\t    {\n-\t      expand_decl_init (exp);\n-\t      return;\n-\t    }\n-\t  t = build (INIT_EXPR, type, exp, init);\n-\t  TREE_SIDE_EFFECTS (t) = 1;\n-\t  expand_expr_stmt (t);\n-\t  return;\n-\t}\n-\n       /* Handle this case: when calling a constructor: xyzzy foo(bar);\n \t which really means:  xyzzy foo = bar; Ugh!\n \n@@ -1534,13 +1562,7 @@ expand_aggr_init_1 (binfo, true_exp, exp, init, alias_this, flags)\n \t    {\n \t      tree rval = build_type_conversion (CONVERT_EXPR, type, init, 1);\n \n-\t      if (flag_ansi_overloading && rval)\n-\t\t{\n-\t\t  if (rval != error_mark_node)\n-\t\t    expand_aggr_init_1 (binfo, true_exp, exp, rval, alias_this, flags);\n-\t\t  return;\n-\t\t}\n-\t      else if (rval)\n+\t      if (rval)\n \t\t{\n \t\t  /* See if there is a constructor for``type'' that takes a\n \t\t     ``ttype''-typed object.  */\n@@ -2028,6 +2050,10 @@ resolve_offset_ref (exp)\n       return member;\n     }\n \n+  if (TREE_CODE (TREE_TYPE (member)) == POINTER_TYPE\n+      && TREE_CODE (TREE_TYPE (TREE_TYPE (member))) == METHOD_TYPE)\n+    return member;\n+\n   /* Syntax error can cause a member which should\n      have been seen as static to be grok'd as non-static.  */\n   if (TREE_CODE (member) == FIELD_DECL && current_class_ref == NULL_TREE)\n@@ -3078,7 +3104,7 @@ build_new (placement, decl, init, use_global_new)\n   if (rval && TREE_TYPE (rval) != build_pointer_type (type))\n     {\n       /* The type of new int [3][3] is not int *, but int [3] * */\n-      rval = build_c_cast (build_pointer_type (type), rval, 0);\n+      rval = build_c_cast (build_pointer_type (type), rval);\n     }\n \n   if (pending_sizes)"}, {"sha": "448cb1f2e037da8695f1935afbbd50af148293ea", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 10, "deletions": 48, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff", "patch": "@@ -1974,11 +1974,7 @@ check_newline ()\n \t      && getch () == 'e'\n \t      && ((c = getch ()) == ' ' || c == '\\t'))\n \t    {\n-#ifdef DWARF_DEBUGGING_INFO\n-\t      if ((debug_info_level == DINFO_LEVEL_VERBOSE)\n-\t\t  && (write_symbols == DWARF_DEBUG))\n-\t        dwarfout_define (lineno, get_directive_line (finput));\n-#endif /* DWARF_DEBUGGING_INFO */\n+\t      debug_define (lineno, get_directive_line (finput));\n \t      goto skipline;\n \t    }\n \t}\n@@ -1990,11 +1986,7 @@ check_newline ()\n \t      && getch () == 'f'\n \t      && ((c = getch ()) == ' ' || c == '\\t'))\n \t    {\n-#ifdef DWARF_DEBUGGING_INFO\n-\t      if ((debug_info_level == DINFO_LEVEL_VERBOSE)\n-\t\t  && (write_symbols == DWARF_DEBUG))\n-\t        dwarfout_undef (lineno, get_directive_line (finput));\n-#endif /* DWARF_DEBUGGING_INFO */\n+\t      debug_undef (lineno, get_directive_line (finput));\n \t      goto skipline;\n \t    }\n \t}\n@@ -2233,15 +2225,7 @@ check_newline ()\n \t      p->name = input_filename;\n \t      input_file_stack = p;\n \t      input_file_stack_tick++;\n-#ifdef DBX_DEBUGGING_INFO\n-\t      if (write_symbols == DBX_DEBUG)\n-\t\tdbxout_start_new_source_file (input_filename);\n-#endif\n-#ifdef DWARF_DEBUGGING_INFO\n-\t      if (debug_info_level == DINFO_LEVEL_VERBOSE\n-\t\t  && write_symbols == DWARF_DEBUG)\n-\t\tdwarfout_start_new_source_file (input_filename);\n-#endif /* DWARF_DEBUGGING_INFO */\n+\t      debug_start_source_file (input_filename);\n \t      in_system_header = entering_system_header;\n \t      if (c_header_level)\n \t\t++c_header_level;\n@@ -2270,15 +2254,7 @@ check_newline ()\n \t\t  input_file_stack = p->next;\n \t\t  free (p);\n \t\t  input_file_stack_tick++;\n-#ifdef DBX_DEBUGGING_INFO\n-\t\t  if (write_symbols == DBX_DEBUG)\n-\t\t    dbxout_resume_previous_source_file ();\n-#endif\n-#ifdef DWARF_DEBUGGING_INFO\n-\t\t  if (debug_info_level == DINFO_LEVEL_VERBOSE\n-\t\t      && write_symbols == DWARF_DEBUG)\n-\t\t    dwarfout_resume_previous_source_file (input_file_stack->line);\n-#endif /* DWARF_DEBUGGING_INFO */\n+\t\t  debug_end_source_file (input_file_stack->line);\n \t\t}\n \t      else\n \t\terror (\"#-lines for entering and leaving files don't match\");\n@@ -4332,7 +4308,6 @@ handle_cp_pragma (pname)\n   else if (! strcmp (pname, \"interface\"))\n     {\n       tree fileinfo = IDENTIFIER_CLASS_VALUE (get_time_identifier (input_filename));\n-      int warned_already = 0;\n       char *main_filename = input_filename;\n \n       main_filename = FILE_NAME_NONDIRECTORY (main_filename);\n@@ -4348,18 +4323,12 @@ handle_cp_pragma (pname)\n \t      return -1;\n \t    }\n \t  main_filename = TREE_STRING_POINTER (yylval.ttype);\n-\t}\n-\n-      while (token != END_OF_LINE)\n-\t{\n-\t  if (!warned_already && extra_warnings)\n-\t    {\n-\t      warning (\"garbage after `#pragma interface' ignored\");\n-\t      warned_already = 1;\n-\t    }\n \t  token = real_yylex ();\n \t}\n \n+      if (token != END_OF_LINE)\n+\twarning (\"garbage after `#pragma interface' ignored\");\n+\n #ifndef NO_LINKAGE_HEURISTICS\n       write_virtuals = 3;\n \n@@ -4394,7 +4363,6 @@ handle_cp_pragma (pname)\n   else if (! strcmp (pname, \"implementation\"))\n     {\n       tree fileinfo = IDENTIFIER_CLASS_VALUE (get_time_identifier (input_filename));\n-      int warned_already = 0;\n       char *main_filename = main_input_filename ? main_input_filename : input_filename;\n \n       main_filename = FILE_NAME_NONDIRECTORY (main_filename);\n@@ -4408,18 +4376,12 @@ handle_cp_pragma (pname)\n \t      return -1;\n \t    }\n \t  main_filename = TREE_STRING_POINTER (yylval.ttype);\n-\t}\n-\n-      while (token != END_OF_LINE)\n-\t{\n-\t  if (!warned_already && extra_warnings)\n-\t    {\n-\t      warning (\"garbage after `#pragma implementation' ignored\");\n-\t      warned_already = 1;\n-\t    }\n \t  token = real_yylex ();\n \t}\n \n+      if (token != END_OF_LINE)\n+\twarning (\"garbage after `#pragma implementation' ignored\");\n+\n #ifndef NO_LINKAGE_HEURISTICS\n       if (write_virtuals == 3)\n \t{"}, {"sha": "2a751420dc17ac43aa54e0244c4b960d88be7913", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 65, "deletions": 8, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff", "patch": "@@ -1224,7 +1224,7 @@ expr_no_commas:\n \t\t{ $$ = build_m_component_ref ($$, build_x_unary_op ($2, $3)); }\n \t| object '(' type_id ')' expr_no_commas  %prec UNARY\n \t\t{ tree type = groktypename ($3.t);\n-\t\t  $$ = build_m_component_ref ($$, build_c_cast (type, $5, 0)); }\n+\t\t  $$ = build_m_component_ref ($$, build_c_cast (type, $5)); }\n \t| object primary_no_id  %prec UNARY\n \t\t{ $$ = build_m_component_ref ($$, $2); }\n */\n@@ -1421,7 +1421,7 @@ primary:\n \t\t        }\n #endif\n \t\t      else my_friendly_abort (79);\n-\t\t      $$ = build_c_cast (type, build_compound_expr ($3), 1);\n+\t\t      $$ = build_c_cast (type, build_compound_expr ($3));\n \t\t    }\n \t\t}\n \t| functional_cast\n@@ -3678,18 +3678,75 @@ function_try_block:\n \n try_block:\n \t  TRY\n-\t\t{ expand_start_try_stmts (); }\n+\t\t{\n+\t\t  if (processing_template_decl)\n+\t\t    {\n+\t\t      $<ttype>$ = build_min_nt (TRY_BLOCK, NULL_TREE,\n+\t\t\t\t\t\tNULL_TREE);\n+\t\t      add_tree ($<ttype>$);\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      emit_line_note (input_filename, lineno);\n+\t\t      expand_start_try_stmts ();\n+\t\t    }\n+\t\t}\n \t  compstmt\n-\t\t{ expand_start_all_catch (); }\n+\t\t{\n+\t\t  if (processing_template_decl)\n+\t\t    {\n+\t\t      TREE_OPERAND ($<ttype>2, 0) = TREE_CHAIN ($<ttype>2);\n+\t\t      TREE_CHAIN ($<ttype>2) = NULL_TREE;\n+\t\t      last_tree = $<ttype>2;\n+\t\t    }\n+\t\t  else\n+\t\t    expand_start_all_catch ();\n+\t\t}\n \t  handler_seq\n-\t\t{ expand_end_all_catch (); }\n+\t\t{\n+\t\t  if (processing_template_decl)\n+\t\t    {\n+\t\t      TREE_OPERAND ($<ttype>2, 1) = TREE_CHAIN ($<ttype>2);\n+\t\t      TREE_CHAIN ($<ttype>2) = NULL_TREE;\n+\t\t      last_tree = $<ttype>2;\n+\t\t    }\n+\t\t  else\n+\t\t    expand_end_all_catch ();\n+\t\t}\n \t;\n \n handler_seq:\n \t  /* empty */\n-\t| handler_seq CATCH .pushlevel handler_args compstmt\n-\t\t{ expand_end_catch_block (); }\n-\t  .poplevel\n+\t| handler_seq CATCH\n+\t\t{\n+\t\t  if (processing_template_decl)\n+\t\t    {\n+\t\t      $<ttype>$ = build_min_nt (HANDLER, NULL_TREE,\n+\t\t\t\t\t\tNULL_TREE);\n+\t\t      add_tree ($<ttype>$);\n+\t\t    }\n+\t\t}\n+\t.pushlevel handler_args\n+\t\t{\n+\t\t  if (processing_template_decl)\n+\t\t    {\n+\t\t      TREE_OPERAND ($<ttype>3, 0) = TREE_CHAIN ($<ttype>3);\n+\t\t      TREE_CHAIN ($<ttype>3) = NULL_TREE;\n+\t\t      last_tree = $<ttype>3;\n+\t\t    }\n+\t\t}\t  \n+\tcompstmt\n+\t\t{\n+\t\t  if (processing_template_decl)\n+\t\t    {\n+\t\t      TREE_OPERAND ($<ttype>3, 1) = TREE_CHAIN ($<ttype>3);\n+\t\t      TREE_CHAIN ($<ttype>3) = NULL_TREE;\n+\t\t      last_tree = $<ttype>3;\n+\t\t    }\n+\t\t  else\n+\t\t    expand_end_catch_block ();\n+\t\t}\t  \n+\t.poplevel\n \t;\n \n type_specifier_seq:"}, {"sha": "9c4f42fad6c343adfe5b9e03cb2acb59bd8505c7", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff", "patch": "@@ -2427,7 +2427,38 @@ tsubst_expr (t, args, nargs, in_decl)\n \texpand_computed_goto\n \t  (tsubst_expr (TREE_OPERAND (t, 0), args, nargs, in_decl));\n       break;\n-\t  \n+\n+    case TRY_BLOCK:\n+      lineno = TREE_COMPLEXITY (t);\n+      emit_line_note (input_filename, lineno);\n+      expand_start_try_stmts ();\n+      tsubst_expr (TREE_OPERAND (t, 0), args, nargs, in_decl);\n+      expand_start_all_catch ();\n+      {\n+\ttree handler = TREE_OPERAND (t, 1);\n+\tfor (; handler; handler = TREE_CHAIN (handler))\n+\t  tsubst_expr (handler, args, nargs, in_decl);\n+      }\n+      expand_end_all_catch ();\n+      break;\n+\n+    case HANDLER:\n+      lineno = TREE_COMPLEXITY (t);\n+      do_pushlevel ();\n+      if (TREE_OPERAND (t, 0))\n+\t{\n+\t  tree d = TREE_OPERAND (t, 0);\n+\t  expand_start_catch_block\n+\t    (tsubst (TREE_OPERAND (d, 1), args, nargs, in_decl),\n+\t     tsubst (TREE_OPERAND (d, 0), args, nargs, in_decl));\n+\t}\n+      else\n+\texpand_start_catch_block (NULL_TREE, NULL_TREE);\n+      tsubst_expr (TREE_OPERAND (t, 1), args, nargs, in_decl);\n+      expand_end_catch_block ();\n+      do_poplevel ();\n+      break;\n+\n     default:\n       return build_expr_from_tree (tsubst_copy (t, args, nargs, in_decl));\n     }"}, {"sha": "ebf5c0245912f12788c20544efbd5a7630a095ab", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff", "patch": "@@ -27,9 +27,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"output.h\"\n #include \"assert.h\"\n \n-#undef NULL\n-#define NULL 0\n-\n #ifndef INT_TYPE_SIZE\n #define INT_TYPE_SIZE BITS_PER_WORD\n #endif\n@@ -1364,7 +1361,7 @@ build_m_desc (decl)\n \t\ttree_cons (NULL_TREE, vcontext,\n \t\t   tree_cons (NULL_TREE, build_t_desc (TREE_TYPE (TREE_TYPE (decl)),\n \t\t\t\t\t\t       ! IS_AGGR_TYPE (taggr)),\n-\t\t      tree_cons (NULL_TREE, build_c_cast (build_pointer_type (default_function_type), build_unary_op (ADDR_EXPR, decl, 0), 0),\n+\t\t      tree_cons (NULL_TREE, build_c_cast (build_pointer_type (default_function_type), build_unary_op (ADDR_EXPR, decl, 0)),\n \t\t\t tree_cons (NULL_TREE, parm_count,\n \t\t\t    tree_cons (NULL_TREE, req_count,\n \t\t\t       build_tree_list (NULL_TREE, build_unary_op (ADDR_EXPR, parm_types, 0)))))))));"}, {"sha": "b503d7849c1b1ce3d6c63b2523f68d9dbbcb3ed8", "filename": "gcc/cp/search.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff", "patch": "@@ -2543,8 +2543,11 @@ dfs_debug_mark (binfo)\n     return;\n \n   /* We can't do the TYPE_DECL_SUPPRESS_DEBUG thing with DWARF, which\n-     does not support name references between translation units.  */\n-  if (write_symbols == DWARF_DEBUG)\n+     does not support name references between translation units.  Well, we\n+     could, but that would mean putting global labels in the debug output\n+     before each exported type and each of its functions and static data\n+     members.  */\n+  if (write_symbols == DWARF_DEBUG || write_symbols == DWARF2_DEBUG)\n     {\n       rest_of_type_compilation (t, global_bindings_p ());\n       return;"}, {"sha": "0d0dc05318eddebf077f6f6f2dffa783a30345aa", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff", "patch": "@@ -1592,16 +1592,6 @@ mapcar (t, func)\n       TREE_OPERAND (t, 0) = mapcar (TREE_OPERAND (t, 0), func);\n       TREE_OPERAND (t, 1) = mapcar (TREE_OPERAND (t, 1), func);\n       return t;\n-      break;\n-\n-    case RTL_EXPR:\n-      t = copy_node (t);\n-      if (RTL_EXPR_SEQUENCE (t))\n-\tRTL_EXPR_SEQUENCE (t) = copy_rtx (RTL_EXPR_SEQUENCE (t));\n-      if (RTL_EXPR_RTL (t))\n-\tRTL_EXPR_RTL (t) = copy_rtx (RTL_EXPR_RTL (t));\n-      return t;\n-      break;\n \n     case CONVERT_EXPR:\n     case ADDR_EXPR:"}, {"sha": "146cf07bfc89925af675b86af913903dc3f6e4a6", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff", "patch": "@@ -1837,10 +1837,13 @@ build_component_ref (datum, component, basetype_path, protect)\n \t\t\t  && ! resolves_to_fixed_type_p (datum, 0))\n \t\t\t{\n \t\t\t  tree addr = build_unary_op (ADDR_EXPR, datum, 0);\n+\t\t\t  tree fntype = TREE_TYPE (fndecl);\n+\n \t\t\t  addr = convert_pointer_to (DECL_CONTEXT (fndecl), addr);\n \t\t\t  datum = build_indirect_ref (addr, NULL_PTR);\n \t\t\t  my_friendly_assert (datum != error_mark_node, 310);\n \t\t\t  fndecl = build_vfn_ref (&addr, datum, DECL_VINDEX (fndecl));\n+\t\t\t  TREE_TYPE (fndecl) = build_pointer_type (fntype);\n \t\t\t}\n \t\t      mark_used (fndecl);\n \t\t      return build (OFFSET_REF, TREE_TYPE (fndecl), datum, fndecl);\n@@ -2436,7 +2439,7 @@ build_x_function_call (function, params, decl)\n \t  decl = convert_pointer_to (TREE_TYPE (ctypeptr), decl);\n \t}\n       else\n-\tdecl = build_c_cast (ctypeptr, decl, 0);\n+\tdecl = build_c_cast (ctypeptr, decl);\n       params = tree_cons (NULL_TREE, decl, params);\n     }\n \n@@ -2716,6 +2719,9 @@ convert_arguments (return_loc, typelist, values, fndecl, flags)\n   if (! flag_elide_constructors)\n     return_loc = 0;\n \n+  /* Argument passing is always copy-initialization.  */\n+  flags |= LOOKUP_ONLYCONVERTING;\n+\n   if (fndecl)\n     {\n       if (TREE_CODE (TREE_TYPE (fndecl)) == METHOD_TYPE)\n@@ -4490,7 +4496,9 @@ unary_complex_lvalue (code, arg)\n       || TREE_CODE (arg) == INIT_EXPR)\n     {\n       tree real_result = build_unary_op (code, TREE_OPERAND (arg, 0), 0);\n-      return build (COMPOUND_EXPR, TREE_TYPE (real_result), arg, real_result);\n+      arg = build (COMPOUND_EXPR, TREE_TYPE (real_result), arg, real_result);\n+      TREE_NO_UNUSED_WARNING (arg) = 1;\n+      return arg;\n     }\n \n   if (TREE_CODE (TREE_TYPE (arg)) == FUNCTION_TYPE\n@@ -5188,7 +5196,7 @@ build_static_cast (type, expr)\n     ok = 1;\n \n   if (ok)\n-    return build_c_cast (type, expr, 0);\n+    return build_c_cast (type, expr);\n \n   cp_error (\"static_cast from `%T' to `%T'\", intype, type);\n   return error_mark_node;\n@@ -5354,10 +5362,9 @@ build_const_cast (type, expr)\n    when doing the cast.  */\n \n tree\n-build_c_cast (type, expr, allow_nonconverting)\n+build_c_cast (type, expr)\n      register tree type;\n      tree expr;\n-     int allow_nonconverting;\n {\n   register tree value = expr;\n \n@@ -5485,11 +5492,9 @@ build_c_cast (type, expr, allow_nonconverting)\n \twarning (\"cast to pointer from integer of different size\");\n #endif\n \n-      flag = allow_nonconverting ? CONV_NONCONVERTING : 0;\n-\n       if (TREE_CODE (type) == REFERENCE_TYPE)\n \tvalue = (convert_from_reference\n-\t\t (convert_to_reference (type, value, CONV_OLD_CONVERT|flag,\n+\t\t (convert_to_reference (type, value, CONV_C_CAST,\n \t\t\t\t\tLOOKUP_COMPLAIN, NULL_TREE)));\n       else\n \t{\n@@ -6267,7 +6272,7 @@ build_ptrmemfunc (type, pfn, force)\n   /* Handle null pointer to member function conversions.  */\n   if (integer_zerop (pfn))\n     {\n-      pfn = build_c_cast (type, integer_zero_node, 0);\n+      pfn = build_c_cast (type, integer_zero_node);\n       return build_ptrmemfunc1 (TYPE_GET_PTRMEMFUNC_TYPE (type),\n \t\t\t\tinteger_zero_node, integer_zero_node,\n \t\t\t\tpfn, NULL_TREE);\n@@ -6761,10 +6766,10 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n     }\n   else if (TYPE_HAS_CONSTRUCTOR (type) || IS_AGGR_TYPE (TREE_TYPE (rhs)))\n     return convert (type, rhs);\n-  /* Handle anachronistic conversions from (::*)() to void* or (*)().  */\n+  /* Handle anachronistic conversions from (::*)() to cv void* or (*)().  */\n   else if (TREE_CODE (type) == POINTER_TYPE\n \t   && (TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE\n-\t       || TREE_TYPE (type) == void_type_node)\n+\t       || TYPE_MAIN_VARIANT (TREE_TYPE (type)) == void_type_node)\n \t   && TREE_TYPE (rhs)\n \t   && TYPE_PTRMEMFUNC_P (TREE_TYPE (rhs)))\n     return convert (type, rhs);\n@@ -6886,6 +6891,9 @@ convert_for_initialization (exp, type, rhs, flags, errtype, fndecl, parmnum)\n   if (IS_AGGR_TYPE (type)\n       && (TYPE_NEEDS_CONSTRUCTING (type) || TREE_HAS_CONSTRUCTOR (rhs)))\n     {\n+      if (flag_ansi_overloading)\n+\treturn cp_convert (type, rhs, CONV_IMPLICIT|CONV_FORCE_TEMP, flags);\n+\n       if (TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (rhstype))\n \t{\n \t  /* This is sufficient to perform initialization.  No need,\n@@ -7130,9 +7138,9 @@ c_expand_return (retval)\n \n       /* convert to reference now, so we can give error if we\n \t return an reference to a non-lvalue.  */\n-      retval = convert_for_initialization (tmp_result, valtype, retval,\n-\t\t\t\t\t   LOOKUP_NORMAL, \"return\",\n-\t\t\t\t\t   NULL_TREE, 0);\n+      retval = convert_for_initialization\n+\t(tmp_result, valtype, retval, LOOKUP_NORMAL|LOOKUP_ONLYCONVERTING,\n+\t \"return\", NULL_TREE, 0);\n \n       /* Sort through common things to see what it is\n \t we are returning.  */\n@@ -7207,14 +7215,14 @@ c_expand_return (retval)\n     {\n       /* We already did this above for refs, don't do it again.  */\n       if (TREE_CODE (valtype) != REFERENCE_TYPE)\n-\tretval = convert_for_initialization (NULL_TREE, valtype, retval,\n-\t\t\t\t\t     LOOKUP_NORMAL,\n-\t\t\t\t\t     \"return\", NULL_TREE, 0);\n+\tretval = convert_for_initialization\n+\t  (NULL_TREE, valtype, retval, LOOKUP_NORMAL|LOOKUP_ONLYCONVERTING,\n+\t   \"return\", NULL_TREE, 0);\n \n       /* We can't initialize a register from a NEW_EXPR.  */\n       if (! current_function_returns_struct\n \t  && TREE_CODE (retval) == TARGET_EXPR\n-\t  && TREE_CODE (TREE_OPERAND (retval, 0)) == NEW_EXPR)\n+\t  && TREE_CODE (TREE_OPERAND (retval, 1)) == NEW_EXPR)\n \tretval = build (COMPOUND_EXPR, TREE_TYPE (retval), retval,\n \t\t\tTREE_OPERAND (retval, 0));\n "}, {"sha": "8c7604f8d871b7b8817809d0bd802c6197c6927c", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff", "patch": "@@ -865,16 +865,12 @@ digest_init (type, init, tail)\n \treturn process_init_constructor (type, init, (tree *)0);\n       else if (TYPE_NON_AGGREGATE_CLASS (type))\n \t{\n-#if 0\n-\t  /* This isn't true.  */\n-\t  /* This can only be reached when caller is initializing\n-\t     ARRAY_TYPE.  In that case, we don't want to convert\n-\t     INIT to TYPE.  We will let `expand_vec_init' do it.  */\n-\t  return init;\n-#else\n-\t  return convert_for_initialization (0, type, init, LOOKUP_NORMAL,\n+\t  int flags = LOOKUP_NORMAL;\n+\t  /* Initialization from { } is copy-initialization.  */\n+\t  if (tail)\n+\t    flags |= LOOKUP_ONLYCONVERTING;\n+\t  return convert_for_initialization (0, type, init, flags,\n \t\t\t\t\t     \"initialization\", NULL_TREE, 0);\n-#endif\n \t}\n       else if (tail != 0)\n \t{\n@@ -1442,7 +1438,7 @@ build_functional_cast (exp, parms)\n \t  parms = build_compound_expr (parms);\n \t}\n \n-      return build_c_cast (type, parms, 1);\n+      return build_c_cast (type, parms);\n     }\n \n   /* Prepare to evaluate as a call to a constructor.  If this expression\n@@ -1459,7 +1455,7 @@ build_functional_cast (exp, parms)\n     }\n \n   if (parms && TREE_CHAIN (parms) == NULL_TREE)\n-    return build_c_cast (type, TREE_VALUE (parms), 1);\n+    return build_c_cast (type, TREE_VALUE (parms));\n \n   exp = build_method_call (NULL_TREE, ctor_identifier, parms,\n \t\t\t   TYPE_BINFO (type), LOOKUP_NORMAL);"}, {"sha": "a09ab7ff29583677b127fced518627666cb029ed", "filename": "gcc/cp/xref.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff/gcc%2Fcp%2Fxref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff/gcc%2Fcp%2Fxref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fxref.c?ref=faf5394a1b5c4d23fdd8d9643e65a66fcd50c7ff", "patch": "@@ -61,9 +61,6 @@ int flag_gnu_xref;\n #ifndef FALSE\n #define FALSE 0\n #endif\n-#ifndef NULL\n-#define NULL 0\n-#endif\n \n #define PALLOC(typ) ((typ *) calloc(1,sizeof(typ)))\n "}]}