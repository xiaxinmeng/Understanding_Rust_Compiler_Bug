{"sha": "5d7fc9412c6ff2d2278cd1b684d0ec2b3f7e0100", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWQ3ZmM5NDEyYzZmZjJkMjI3OGNkMWI2ODRkMGVjMmIzZjdlMDEwMA==", "commit": {"author": {"name": "David Edelsohn", "email": "edelsohn@gnu.org", "date": "2009-12-05T21:48:58Z"}, "committer": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "2009-12-05T21:48:58Z"}, "message": "aix.S: Update AIX32 code to be consistent with AIX64 code.\n\n        * src/powerpc/aix.S: Update AIX32 code to be consistent with AIX64\n        code.\n        * src/powerpc/aix_closure.s: Same.\n\nFrom-SVN: r155016", "tree": {"sha": "fe8702816da1bf6befb8480c5db78518130a374b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fe8702816da1bf6befb8480c5db78518130a374b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d7fc9412c6ff2d2278cd1b684d0ec2b3f7e0100", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d7fc9412c6ff2d2278cd1b684d0ec2b3f7e0100", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d7fc9412c6ff2d2278cd1b684d0ec2b3f7e0100", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d7fc9412c6ff2d2278cd1b684d0ec2b3f7e0100/comments", "author": null, "committer": null, "parents": [{"sha": "6a790a69809ba41915575baff46d8c4316129526", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a790a69809ba41915575baff46d8c4316129526", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a790a69809ba41915575baff46d8c4316129526"}], "stats": {"total": 365, "additions": 191, "deletions": 174}, "files": [{"sha": "966b3d8c8f9d809aabd72cc26af723105307405e", "filename": "libffi/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d7fc9412c6ff2d2278cd1b684d0ec2b3f7e0100/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d7fc9412c6ff2d2278cd1b684d0ec2b3f7e0100/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=5d7fc9412c6ff2d2278cd1b684d0ec2b3f7e0100", "patch": "@@ -1,3 +1,9 @@\n+2009-12-05  David Edelsohn  <edelsohn@gnu.org>\n+\n+\t* src/powerpc/aix.S: Update AIX32 code to be consistent with AIX64\n+\tcode.\n+\t* src/powerpc/aix_closure.s: Same.\n+\t\n 2009-12-05  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n \n \t* Makefile.in: Regenerate."}, {"sha": "c6f87644d9423c4586727454b409e333ef601ed0", "filename": "libffi/src/powerpc/aix.S", "status": "modified", "additions": 47, "deletions": 58, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d7fc9412c6ff2d2278cd1b684d0ec2b3f7e0100/libffi%2Fsrc%2Fpowerpc%2Faix.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d7fc9412c6ff2d2278cd1b684d0ec2b3f7e0100/libffi%2Fsrc%2Fpowerpc%2Faix.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Faix.S?ref=5d7fc9412c6ff2d2278cd1b684d0ec2b3f7e0100", "patch": "@@ -124,11 +124,12 @@ ffi_call_AIX:\n \n \t/* Call ffi_prep_args.  */\n \tmr\tr4, r1\n-\tbl .ffi_prep_args\n+\tbl\t.ffi_prep_args\n \n \t/* Now do the call.  */\n \tld\tr0, 0(r29)\n \tld\tr2, 8(r29)\n+\tld\tr11, 16(r29)\n \t/* Set up cr1 with bits 4-7 of the flags.  */\n \tmtcrf\t0x40, r31\n \tmtctr\tr0\n@@ -182,69 +183,57 @@ L(done_return_value):\n \t/* Restore the registers we used and return.  */\n \tmr\tr1, r28\n \tld\tr0, 16(r28)\n-\tld\tr28,-32(r1)\n+\tld\tr28, -32(r1)\n \tmtlr\tr0\n-\tld\tr29,-24(r1)\n-\tld\tr30,-16(r1)\n-\tld\tr31,-8(r1)\n+\tld\tr29, -24(r1)\n+\tld\tr30, -16(r1)\n+\tld\tr31, -8(r1)\n \tblr\n \n L(fp_return_value):\n-\tbf\t28,L(float_return_value)\n-\tstfd\tf1,0(r30)\n-\tbf\t31,L(done_return_value)\n-\tstfd\tf2,8(r30)\n+\tbf\t28, L(float_return_value)\n+\tstfd\tf1, 0(r30)\n+\tbf\t31, L(done_return_value)\n+\tstfd\tf2, 8(r30)\n \tb\tL(done_return_value)\n L(float_return_value):\n-\tstfs\tf1,0(r30)\n+\tstfs\tf1, 0(r30)\n \tb\tL(done_return_value)\n \n #else /* ! __64BIT__ */\n \t\n \t.long .ffi_call_AIX, TOC[tc0], 0\n \t.csect .text[PR]\n .ffi_call_AIX:\n-\tmr\tr12,r8 // We only need r12 until the call, so it doesn't have to be saved...\n-\t/* Save the old stack pointer as AP.  */\n-\tmr\tr8,r1\n-\n-\t/* Allocate the stack space we need.  */\n-\tstwux\tr1,r1,r4\n-\n \t/* Save registers we use.  */\n-\tmflr\tr9\n+\tmflr\tr0\n \n-\tstw\tr28,-16(r8)\n-\tstw\tr29,-12(r8)\n-\tstw\tr30, -8(r8)\n-\tstw\tr31, -4(r8)\n+\tstw\tr28,-16(r1)\n+\tstw\tr29,-12(r1)\n+\tstw\tr30, -8(r1)\n+\tstw\tr31, -4(r1)\n \n-\tstw\tr9,  8(r8)\n-\tstw\tr2, 20(r1)\n+\tstw\tr0, 8(r1)\n+\tmr\tr28, r1\t\t/* out AP.  */\n+\tstwux\tr1, r1, r4\n \n \t/* Save arguments over call...  */\n-\tmr\tr31,r5\t/* flags, */\n-\tmr\tr30,r6\t/* rvalue, */\n-\tmr\tr29,r7\t/* function address, */\n-\tmr\tr28,r8\t/* our AP. */\n+\tmr\tr31, r5\t/* flags, */\n+\tmr\tr30, r6\t/* rvalue, */\n+\tmr\tr29, r7\t/* function address, */\n+\tstw\tr2, 20(r1)\n \n \t/* Call ffi_prep_args.  */\n-\tmr\tr4,r1\n-\tli\tr9,0\n-\n-\tlwz\tr2,4(r12)\n-\tlwz\tr12,0(r12)\n-\tmtctr\tr12 // r12 holds address of _ffi_prep_args\n-\tbctrl\n-\tlwz     r2,20(r1)\n+\tmr\tr4, r1\n+\tbl\t.ffi_prep_args\n \n \t/* Now do the call.  */\n-\tlwz\tr12,0(r29)\n+\tlwz\tr0, 0(r29)\n+\tlwz\tr2, 4(r29)\n+\tlwz\tr11, 8(r29)\n \t/* Set up cr1 with bits 4-7 of the flags.  */\n-\tmtcrf\t0x40,r31\n-\tstw\tr2,20(r1)\n-\tmtctr\tr12\n-\tlwz\tr2,4(r29)\n+\tmtcrf\t0x40, r31\n+\tmtctr\tr0\n \t/* Load all those argument registers.  */\n \t// We have set up a nice stack frame, just load it into registers.\n \tlwz\tr3, 20+(1*4)(r1)\n@@ -280,36 +269,36 @@ L1:\n L2:\n \t/* Make the call.  */\n \tbctrl\n-\tlwz\tr2,20(r1)\n+\tlwz\tr2, 20(r1)\n \n \t/* Now, deal with the return value.  */\n-\tmtcrf\t0x01,r31\n+\tmtcrf\t0x01, r31\n \n-\tbt\t30,L(done_return_value)\n-\tbt\t29,L(fp_return_value)\n-\tstw\tr3,0(r30)\n-\tbf\t28,L(done_return_value)\n-\tstw\tr4,4(r30)\n+\tbt\t30, L(done_return_value)\n+\tbt\t29, L(fp_return_value)\n+\tstw\tr3, 0(r30)\n+\tbf\t28, L(done_return_value)\n+\tstw\tr4, 4(r30)\n \n \t/* Fall through...  */\n \n L(done_return_value):\n \t/* Restore the registers we used and return.  */\n-\tlwz\tr9,8(r28)\n-\tlwz\tr31,-4(r28)\n-\tmtlr\tr9\n-\tlwz\tr30, -8(r28)\n-\tlwz\tr29,-12(r28)\n-\tlwz\tr28,-16(r28)\n-\tlwz\tr1,0(r1)\n+\tmr\tr1, r28\n+\tlwz\tr0, 8(r28)\n+\tlwz\tr28,-16(r1)\n+\tmtlr\tr0\n+\tlwz\tr29,-12(r1)\n+\tlwz\tr30, -8(r1)\n+\tlwz\tr31, -4(r1)\n \tblr\n \n L(fp_return_value):\n-\tbf\t28,L(float_return_value)\n-\tstfd\tf1,0(r30)\n+\tbf\t28, L(float_return_value)\n+\tstfd\tf1, 0(r30)\n \tb\tL(done_return_value)\n L(float_return_value):\n-\tstfs\tf1,0(r30)\n+\tstfs\tf1, 0(r30)\n \tb\tL(done_return_value)\n #endif\n \t.long 0"}, {"sha": "7fe5c83cdd83723a4dbd829abdbb8818d30f58c0", "filename": "libffi/src/powerpc/aix_closure.S", "status": "modified", "additions": 138, "deletions": 116, "changes": 254, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d7fc9412c6ff2d2278cd1b684d0ec2b3f7e0100/libffi%2Fsrc%2Fpowerpc%2Faix_closure.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d7fc9412c6ff2d2278cd1b684d0ec2b3f7e0100/libffi%2Fsrc%2Fpowerpc%2Faix_closure.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Faix_closure.S?ref=5d7fc9412c6ff2d2278cd1b684d0ec2b3f7e0100", "patch": "@@ -165,11 +165,11 @@ ffi_closure_ASM:\n \n \t/* look up the proper starting point in table  */\n \t/* by using return type as offset */\n-\tld r4, LC..60(2)\t\t/* get address of jump table */\n-\tsldi r3, r3, 4\t\t/* now multiply return type by 16 */\n-\tld r0, 240+16(r1)\t/* load return address */\n-\tadd r3,r3,r4\t\t/* add contents of table to table address */\n-\tmtctr r3\n+\tld\tr4, LC..60(2)\t/* get address of jump table */\n+\tsldi\tr3, r3, 4\t/* now multiply return type by 16 */\n+\tld\tr0, 240+16(r1)\t/* load return address */\n+\tadd\tr3, r3, r4\t/* add contents of table to table address */\n+\tmtctr\tr3\n \tbctr\t\t\t/* jump to it */\n \n /* Each fragment must be exactly 16 bytes long (4 instructions).\n@@ -273,60 +273,59 @@ L..finish:\n \t.long .ffi_closure_ASM, TOC[tc0], 0\n \t.csect .text[PR]\n .ffi_closure_ASM:\n+/* we want to build up an area for the parameters passed */\n+/* in registers (both floating point and integer) */\n+\n+\t/* we store gpr 3 to gpr 10 (aligned to 4)\n+\tin the parents outgoing area  */\n+\tstw   r3, 24+(0*4)(r1)\n+\tstw   r4, 24+(1*4)(r1)\n+\tstw   r5, 24+(2*4)(r1)\n+\tstw   r6, 24+(3*4)(r1)\n+\tmflr  r0\n \n-\tmflr r0\t\t\t/* extract return address */\n-\tstw r0, 8(r1)\t\t/* save the return address */\n+\tstw   r7, 24+(4*4)(r1)\n+\tstw   r8, 24+(5*4)(r1)\n+\tstw   r9, 24+(6*4)(r1)\n+\tstw   r10, 24+(7*4)(r1)\n+\tstw   r0, 8(r1)\n \n \t/* 24 Bytes (Linkage Area) */\n \t/* 32 Bytes (params) */\n-\t/* 104 Bytes (13*8 from FPR) */\n \t/* 16  Bytes (result) */\n+\t/* 104 Bytes (13*8 from FPR) */\n \t/* 176 Bytes */\n \n-\tstwu r1,-176(r1)\t/* skip over caller save area\n-\t\t\t\tkeep stack aligned to 16  */\n-\n-/* we want to build up an area for the parameters passed */\n-/* in registers (both floating point and integer) */\n-\n-\t/* we store gpr 3 to gpr 10 (aligned to 4)\n-\tin the parents outgoing area  */\n-\tstw   r3, 200(r1)\n-\tstw   r4, 204(r1)\n-\tstw   r5, 208(r1)\n-\tstw   r6, 212(r1)\n-\tstw   r7, 216(r1)\n-\tstw   r8, 220(r1)\n-\tstw   r9, 224(r1)\n-\tstw   r10, 228(r1)\n+\tstwu  r1, -176(r1)\t/* skip over caller save area\n+\t\t\t\t   keep stack aligned to 16  */\n \n \t/* next save fpr 1 to fpr 13 (aligned to 8) */\n-\tstfd  f1, 56(r1)\n-\tstfd  f2, 64(r1)\n-\tstfd  f3, 72(r1)\n-\tstfd  f4, 80(r1)\n-\tstfd  f5, 88(r1)\n-\tstfd  f6, 96(r1)\n-\tstfd  f7, 104(r1)\n-\tstfd  f8, 112(r1)\n-\tstfd  f9, 120(r1)\n-\tstfd  f10, 128(r1)\n-\tstfd  f11, 136(r1)\n-\tstfd  f12, 144(r1)\n-\tstfd  f13, 152(r1)\n+\tstfd  f1, 72+(0*8)(r1)\n+\tstfd  f2, 72+(1*8)(r1)\n+\tstfd  f3, 72+(2*8)(r1)\n+\tstfd  f4, 72+(3*8)(r1)\n+\tstfd  f5, 72+(4*8)(r1)\n+\tstfd  f6, 72+(5*8)(r1)\n+\tstfd  f7, 72+(6*8)(r1)\n+\tstfd  f8, 72+(7*8)(r1)\n+\tstfd  f9, 72+(8*8)(r1)\n+\tstfd  f10, 72+(9*8)(r1)\n+\tstfd  f11, 72+(10*8)(r1)\n+\tstfd  f12, 72+(11*8)(r1)\n+\tstfd  f13, 72+(12*8)(r1)\n \n \t/* set up registers for the routine that actually does the work */\n \t/* get the context pointer from the trampoline */\n-\tmr r3,r11\n+\tmr r3, r11\n \n \t/* now load up the pointer to the result storage */\n-\taddi r4,r1,160\n+\taddi r4, r1, 56\n \n \t/* now load up the pointer to the saved gpr registers */\n-\taddi r5,r1,200\n+\taddi r5, r1, 200\n \n \t/* now load up the pointer to the saved fpr registers */\n-\taddi r6,r1,56\n+\taddi r6, r1, 72\n \n \t/* make the call */\n \tbl .ffi_closure_helper_DARWIN\n@@ -338,84 +337,107 @@ L..finish:\n \n \t/* look up the proper starting point in table  */\n \t/* by using return type as offset */\n-\taddi r5,r1,160\t\t/* get pointer to results area */\n-\tlwz r4,LC..60(2)\t/* get address of jump table */\n-\tslwi r3,r3,2\t\t/* now multiply return type by 4 */\n-\tlwzx r3,r4,r3\t\t/* get the contents of that table value */\n-\tadd r3,r3,r4\t\t/* add contents of table to table address */\n-\tmtctr r3\n+\tlwz\tr4, LC..60(2)\t/* get address of jump table */\n+\tslwi\tr3, r3, 4\t/* now multiply return type by 4 */\n+\tlwz\tr0, 176+8(r1)\t/* load return address */\n+\tlwzx\tr3, r4, r3\t/* get the contents of that table value */\n+\tmtctr\tr3\n \tbctr\t\t\t/* jump to it */\n \n+/* Each fragment must be exactly 16 bytes long (4 instructions).\n+   Align to 16 byte boundary for cache and dispatch efficiency.  */\n+\t.align 4\n+\n L..60:\n-\t.long L..44-L..60    /* FFI_TYPE_VOID */\n-\t.long L..50-L..60    /* FFI_TYPE_INT */\n-\t.long L..47-L..60    /* FFI_TYPE_FLOAT */\n-\t.long L..46-L..60    /* FFI_TYPE_DOUBLE */\n-\t.long L..45-L..60    /* FFI_TYPE_LONGDOUBLE */\n-\t.long L..56-L..60    /* FFI_TYPE_UINT8 */\n-\t.long L..55-L..60    /* FFI_TYPE_SINT8 */\n-\t.long L..58-L..60    /* FFI_TYPE_UINT16 */\n-\t.long L..57-L..60    /* FFI_TYPE_SINT16 */\n-\t.long L..50-L..60    /* FFI_TYPE_UINT32 */\n-\t.long L..50-L..60    /* FFI_TYPE_SINT32 */\n-\t.long L..48-L..60    /* FFI_TYPE_UINT64 */\n-\t.long L..48-L..60    /* FFI_TYPE_SINT64 */\n-\t.long L..44-L..60    /* FFI_TYPE_STRUCT */\n-\t.long L..50-L..60    /* FFI_TYPE_POINTER */\n-\n-\n-/* case long double */\n-L..45:\n-\tlfd f1,0(r5)\n-\tlfd f2,8(r5)\n-\tb L..44\n-\n-/* case double */\n-L..46:\n-\tlfd f1,0(r5)\n-\tb L..44\n-\n-/* case float */\n-L..47:\n-\tlfs f1,0(r5)\n-\tb L..44\n-\n-/* case long long */\n-L..48:\n-\tlwz r3,0(r5)\n-\tlwz r4,4(r5)\n-\tb L..44\n-\n-/* case default / int32 / pointer */\n-L..50:\n-\tlwz r3,0(r5)\n-\tb L..44\n-\n-/* case signed int8 */\n-L..55:\n-\tlbz r3,3(r5)\n-\textsb r3,r3\n-\tb L..44\n-\n-/* case unsigned int8 */\n-L..56:\n-\tlbz r3,3(r5)\n-\tb L..44\n-\n-/* case signed int16 */\n-L..57:\n-\tlha r3,2(r5)\n-\tb L..44\n-\n-/* case unsigned int16 */\n-L..58:\n-\tlhz r3,2(r5)\n-\n-/* case void / done\t */\n-L..44:\n-\taddi r1,r1,176\t\t/* restore stack pointer */\n-\tlwz r0,8(r1)\t\t/* get return address */\n-\tmtlr r0\t\t\t/* reset link register */\n+/* case FFI_TYPE_VOID */\n+\tmtlr r0\n+\taddi r1, r1, 176\n+\tblr\n+\tnop\n+\n+/* case FFI_TYPE_INT */\n+\tlwz r3, 56+0(r1)\n+\tmtlr r0\n+\taddi r1, r1, 176\n+\tblr\n+\n+/* case FFI_TYPE_FLOAT */\n+\tlfs f1, 56+0(r1)\n+\tmtlr r0\n+\taddi r1, r1, 176\n+\tblr\n+\n+/* case FFI_TYPE_DOUBLE */\n+\tlfd f1, 56+0(r1)\n+\tmtlr r0\n+\taddi r1, r1, 176\n+\tblr\n+\n+/* case FFI_TYPE_LONGDOUBLE */\n+\tlfd f1, 56+0(r1)\n+\tmtlr r0\n+\tlfd f2, 56+8(r1)\n+\tb L..finish\n+\n+/* case FFI_TYPE_UINT8 */\n+\tlbz r3, 56+3(r1)\n+\tmtlr r0\n+\taddi r1, r1, 176\n+\tblr\n+\n+/* case FFI_TYPE_SINT8 */\n+\tlbz r3, 56+3(r1)\n+\tmtlr r0\n+\textsb r3, r3\n+\tb L..finish\n+\n+/* case FFI_TYPE_UINT16 */\n+\tlhz r3, 56+2(r1)\n+\tmtlr r0\n+\taddi r1, r1, 176\n+\tblr\n+\n+/* case FFI_TYPE_SINT16 */\n+\tlha r3, 56+2(r1)\n+\tmtlr r0\n+\taddi r1, r1, 176\n+\tblr\n+\n+/* case FFI_TYPE_UINT32 */\n+\tlwz r3, 56+0(r1)\n+\tmtlr r0\n+\taddi r1, r1, 176\n+\tblr\n+\n+/* case FFI_TYPE_SINT32 */\n+\tlwz r3, 56+0(r1)\n+\tmtlr r0\n+\taddi r1, r1, 176\n+\tblr\n+\n+/* case FFI_TYPE_UINT64 */\n+\tlwz r3, 56+0(r1)\n+\tmtlr r0\n+\tlwz r4, 56+4(r1)\n+\tb L..finish\n+\n+/* case FFI_TYPE_SINT64 */\n+\tlwz r3, 56+0(r1)\n+\tmtlr r0\n+\tlwz r4, 56+4(r1)\n+\tb L..finish\n+\n+/* case FFI_TYPE_STRUCT */\n+\tmtlr r0\n+\taddi r1, r1, 176\n+\tblr\n+\tnop\n+\n+/* case FFI_TYPE_POINTER */\n+\tlwz r3, 56+0(r1)\n+\tmtlr r0\n+L..finish:\n+\taddi r1, r1, 176\n \tblr\n #endif\n /* END(ffi_closure_ASM) */"}]}