{"sha": "ceb1d26880ef6ccf4528f8e11ba611c0ff886933", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2ViMWQyNjg4MGVmNmNjZjQ1MjhmOGUxMWJhNjExYzBmZjg4NjkzMw==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1994-08-05T16:29:21Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1994-08-05T16:29:21Z"}, "message": "(expand_mult): Accept DImode for synth_mult only if CONST_DOUBLE_HIGH is zero.\n\n(expand_mult): Accept DImode for synth_mult only if\nCONST_DOUBLE_HIGH is zero.  Reject negative values for synth_mult\nif the mode is larger than HOST_BITS_PER_INT.  Don't do the\nnegate_variant if the mode is larger than HOST_BITS_PER_INT.\n\nFrom-SVN: r7860", "tree": {"sha": "20dac1162c756f8be897ccfe4f72b9b331490c2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/20dac1162c756f8be897ccfe4f72b9b331490c2f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ceb1d26880ef6ccf4528f8e11ba611c0ff886933", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ceb1d26880ef6ccf4528f8e11ba611c0ff886933", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ceb1d26880ef6ccf4528f8e11ba611c0ff886933", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ceb1d26880ef6ccf4528f8e11ba611c0ff886933/comments", "author": null, "committer": null, "parents": [{"sha": "976ef4f727499247c733bf00b357efba0ffaa288", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/976ef4f727499247c733bf00b357efba0ffaa288", "html_url": "https://github.com/Rust-GCC/gccrs/commit/976ef4f727499247c733bf00b357efba0ffaa288"}], "stats": {"total": 36, "additions": 25, "deletions": 11}, "files": [{"sha": "ab685eafcadc1c922fd48c5e08e38f0ebcc9f538", "filename": "gcc/expmed.c", "status": "modified", "additions": 25, "deletions": 11, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceb1d26880ef6ccf4528f8e11ba611c0ff886933/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceb1d26880ef6ccf4528f8e11ba611c0ff886933/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=ceb1d26880ef6ccf4528f8e11ba611c0ff886933", "patch": "@@ -2062,23 +2062,31 @@ expand_mult (mode, op0, op1, target, unsignedp)\n {\n   rtx const_op1 = op1;\n \n+  /* synth_mult does an `unsigned int' multiply.  As long as the mode is\n+     less than or equal in size to `unsigned int' this doesn't matter.\n+     If the mode is larger than `unsigned int', then synth_mult works only\n+     if the constant value exactly fits in an `unsigned int' without any\n+     truncation.  This means that multiplying by negative values does\n+     not work; results are off by 2^32 on a 32 bit machine.  */\n+\n   /* If we are multiplying in DImode, it may still be a win\n      to try to work with shifts and adds.  */\n   if (GET_CODE (op1) == CONST_DOUBLE\n       && GET_MODE_CLASS (GET_MODE (op1)) == MODE_INT\n-      && HOST_BITS_PER_INT <= BITS_PER_WORD)\n-    {\n-      if ((CONST_DOUBLE_HIGH (op1) == 0 && CONST_DOUBLE_LOW (op1) >= 0)\n-\t  || (CONST_DOUBLE_HIGH (op1) == -1 && CONST_DOUBLE_LOW (op1) < 0))\n-\tconst_op1 = GEN_INT (CONST_DOUBLE_LOW (op1));\n-    }\n+      && HOST_BITS_PER_INT >= BITS_PER_WORD\n+      && CONST_DOUBLE_HIGH (op1) == 0)\n+    const_op1 = GEN_INT (CONST_DOUBLE_LOW (op1));\n+  else if (HOST_BITS_PER_INT < GET_MODE_BITSIZE (mode)\n+\t   && GET_CODE (op1) == CONST_INT\n+\t   && INTVAL (op1) < 0)\n+    const_op1 = 0;\n \n   /* We used to test optimize here, on the grounds that it's better to\n      produce a smaller program when -O is not used.\n      But this causes such a terrible slowdown sometimes\n      that it seems better to use synth_mult always.  */\n \n-  if (GET_CODE (const_op1) == CONST_INT)\n+  if (const_op1 && GET_CODE (const_op1) == CONST_INT)\n     {\n       struct algorithm alg;\n       struct algorithm alg2;\n@@ -2096,10 +2104,16 @@ expand_mult (mode, op0, op1, target, unsignedp)\n       mult_cost = MIN (12 * add_cost, mult_cost);\n \n       synth_mult (&alg, val, mult_cost);\n-      synth_mult (&alg2, - val,\n-\t\t  (alg.cost < mult_cost ? alg.cost : mult_cost) - negate_cost);\n-      if (alg2.cost + negate_cost < alg.cost)\n-\talg = alg2, variant = negate_variant;\n+\n+      /* This works only if the inverted value actually fits in an\n+\t `unsigned int' */\n+      if (HOST_BITS_PER_INT >= GET_MODE_BITSIZE (mode))\n+\t{\n+\t  synth_mult (&alg2, - val,\n+\t\t      (alg.cost < mult_cost ? alg.cost : mult_cost) - negate_cost);\n+\t  if (alg2.cost + negate_cost < alg.cost)\n+\t    alg = alg2, variant = negate_variant;\n+\t}\n \n       /* This proves very useful for division-by-constant.  */\n       synth_mult (&alg2, val - 1,"}]}