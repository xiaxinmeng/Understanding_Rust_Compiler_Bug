{"sha": "829bdd4b09d2e84d6a2ec28aa7d4dfb847760ac2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODI5YmRkNGIwOWQyZTg0ZDZhMmVjMjhhYTdkNGRmYjg0Nzc2MGFjMg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-07-23T20:49:33Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-07-23T20:49:33Z"}, "message": "dwarf2cfi: Generate and connect traces.\n\nThis kinda-sorta corresponds to Bernd's 007-dw2cfi patch.  Certainly\nthe same concepts of splitting the instruction stream into extended\nbasic blocks is the same.  This patch does a bit better job with the\ndocumentation.  Also, I'm a bit more explicit about matching things\nup with the similar code from the regular CFG routines.\n\nWhat's missing at this point is any attempt to use DW_CFA_remember_state.\nI've deferred that for the moment because it's easy to test the state\nchange code across epilogues, whereas the shrink-wrapping code is not\nin this tree and section switching is difficult to force.\n\n        * dwarf2cfi.c: Include basic-block.h.\n        (dw_label_info): Remove.\n        (trace_work_list, trace_index): New.\n        (remember_row, emit_cfa_remember): Remove.\n        (dw_trace_info_hash, dw_trace_info_eq): New.\n        (get_trace_index, get_trace_info): New.\n        (save_point_p): New.\n        (free_cfi_row): Remove.\n        (add_cfi): Do not emit DW_CFA_remember_state.\n        (cfa_row_equal_p): New.\n        (barrier_args_size): Remove.\n        (compute_barrier_args_size_1, compute_barrier_args_size): Remove.\n        (dwarf2out_notice_stack_adjust): Don't compute_barrier_args_size.\n        (maybe_record_trace_start, create_trace_edges, scan_trace): New.\n        (dwarf2out_cfi_begin_epilogue): Remove.\n        (dwarf2out_frame_debug_restore_state): Remove.\n        (connect_traces, create_pseudo_cfg): New.\n        (create_cfi_notes, execute_dwarf2_frame): Rewrite using traces.\n        * Makefile.in (dwarf2cfi.o): Update.\n\nFrom-SVN: r176705", "tree": {"sha": "ebcf19a72c92a542f709e09f40a0598278e6db58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ebcf19a72c92a542f709e09f40a0598278e6db58"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/829bdd4b09d2e84d6a2ec28aa7d4dfb847760ac2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/829bdd4b09d2e84d6a2ec28aa7d4dfb847760ac2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/829bdd4b09d2e84d6a2ec28aa7d4dfb847760ac2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/829bdd4b09d2e84d6a2ec28aa7d4dfb847760ac2/comments", "author": null, "committer": null, "parents": [{"sha": "43215a89ecd2c8cfcc00b1a6f9a493b011d437ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43215a89ecd2c8cfcc00b1a6f9a493b011d437ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43215a89ecd2c8cfcc00b1a6f9a493b011d437ff"}], "stats": {"total": 854, "additions": 446, "deletions": 408}, "files": [{"sha": "5913e219dd8d311dd99395f50da9a8268acb463d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/829bdd4b09d2e84d6a2ec28aa7d4dfb847760ac2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/829bdd4b09d2e84d6a2ec28aa7d4dfb847760ac2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=829bdd4b09d2e84d6a2ec28aa7d4dfb847760ac2", "patch": "@@ -1,3 +1,25 @@\n+2011-07-23  Richard Henderson  <rth@redhat.com>\n+\n+\t* dwarf2cfi.c: Include basic-block.h.\n+\t(dw_label_info): Remove.\n+\t(trace_work_list, trace_index): New.\n+\t(remember_row, emit_cfa_remember): Remove.\n+\t(dw_trace_info_hash, dw_trace_info_eq): New.\n+\t(get_trace_index, get_trace_info): New.\n+\t(save_point_p): New.\n+\t(free_cfi_row): Remove.\n+\t(add_cfi): Do not emit DW_CFA_remember_state.\n+\t(cfa_row_equal_p): New.\n+\t(barrier_args_size): Remove.\n+\t(compute_barrier_args_size_1, compute_barrier_args_size): Remove.\n+\t(dwarf2out_notice_stack_adjust): Don't compute_barrier_args_size.\n+\t(maybe_record_trace_start, create_trace_edges, scan_trace): New.\n+\t(dwarf2out_cfi_begin_epilogue): Remove.\n+\t(dwarf2out_frame_debug_restore_state): Remove.\n+\t(connect_traces, create_pseudo_cfg): New.\n+\t(create_cfi_notes, execute_dwarf2_frame): Rewrite using traces.\n+\t* Makefile.in (dwarf2cfi.o): Update.\n+\n 2011-07-23  Richard Henderson  <rth@redhat.com>\n \n \t* dwarf2cfi.c (dw_trace_info): New."}, {"sha": "b215cd669afc3ec200f3ca469caeb3841472f8c7", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/829bdd4b09d2e84d6a2ec28aa7d4dfb847760ac2/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/829bdd4b09d2e84d6a2ec28aa7d4dfb847760ac2/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=829bdd4b09d2e84d6a2ec28aa7d4dfb847760ac2", "patch": "@@ -2957,7 +2957,7 @@ dwarf2out.o : dwarf2out.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    tree-pretty-print.h $(COMMON_TARGET_H) $(OPTS_H)\n dwarf2cfi.o : dwarf2cfi.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    version.h $(RTL_H) $(FUNCTION_H) $(DWARF2_H) dwarf2asm.h dwarf2out.h \\\n-   $(GGC_H) $(TM_P_H) $(TARGET_H) $(TREE_PASS_H)\n+   $(GGC_H) $(TM_P_H) $(TARGET_H) $(TREE_PASS_H) $(BASIC_BLOCK_H)\n dwarf2asm.o : dwarf2asm.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(FLAGS_H) $(RTL_H) $(TREE_H) output.h dwarf2asm.h $(TM_P_H) $(GGC_H) \\\n    gt-dwarf2asm.h $(DWARF2_H) $(SPLAY_TREE_H) $(TARGET_H)"}, {"sha": "3ff4c612411cac5fb899f6c38176467b1f87f4bf", "filename": "gcc/dwarf2cfi.c", "status": "modified", "additions": 423, "deletions": 407, "changes": 830, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/829bdd4b09d2e84d6a2ec28aa7d4dfb847760ac2/gcc%2Fdwarf2cfi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/829bdd4b09d2e84d6a2ec28aa7d4dfb847760ac2/gcc%2Fdwarf2cfi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2cfi.c?ref=829bdd4b09d2e84d6a2ec28aa7d4dfb847760ac2", "patch": "@@ -27,6 +27,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"flags.h\"\n #include \"rtl.h\"\n #include \"function.h\"\n+#include \"basic-block.h\"\n #include \"dwarf2.h\"\n #include \"dwarf2out.h\"\n #include \"dwarf2asm.h\"\n@@ -86,34 +87,30 @@ DEF_VEC_ALLOC_O (reg_saved_in_data, heap);\n /* Since we no longer have a proper CFG, we're going to create a facsimile\n    of one on the fly while processing the frame-related insns.\n \n-   We create dw_trace structures for each instruction trace beginning at\n-   at a label following a barrier (or beginning of the function), and\n-   ending at a barrier (or the end of the function).\n+   We create dw_trace_info structures for each extended basic block beginning\n+   and ending at a \"save point\".  Save points are labels, barriers, certain\n+   notes, and of course the beginning and end of the function.\n \n    As we encounter control transfer insns, we propagate the \"current\"\n-   row state across the edges to the starts of traces.  If an edge goes\n-   to a label that is not the start of a trace, we ignore it.  This\n-   assumes that previous compiler transformations were correct, and that\n-   we will reach the same row state from any source.  (We can perform some\n-   limited validation of this assumption, but without the full CFG we\n-   cannot be sure of full validation coverage.  It is expensive, so we\n-   only do so with checking enabled.)\n+   row state across the edges to the starts of traces.  When checking is\n+   enabled, we validate that we propagate the same data from all sources.\n \n    All traces are members of the TRACE_INFO array, in the order in which\n    they appear in the instruction stream.\n \n-   All labels are given an LUID that indexes the LABEL_INFO array.  If\n-   the label is the start of a trace, the TRACE pointer will be non-NULL\n-   and point into the TRACE_INFO array.  */\n+   All save points are present in the TRACE_INDEX hash, mapping the insn\n+   starting a trace to the dw_trace_info describing the trace.  */\n \n typedef struct\n {\n-  /* The label that begins the trace.  This will be NULL for the first\n-     trace beginning at function entry.  */\n-  rtx label;\n+  /* The insn that begins the trace.  */\n+  rtx head;\n \n   /* The row state at the beginning and end of the trace.  */\n-  dw_cfi_row *enter_row, *exit_row;\n+  dw_cfi_row *beg_row, *end_row;\n+\n+  /* True if this trace immediately follows NOTE_INSN_SWITCH_TEXT_SECTIONS.  */\n+  bool switch_sections;\n \n   /* The following variables contain data used in interpreting frame related\n      expressions.  These are not part of the \"real\" row state as defined by\n@@ -147,24 +144,15 @@ typedef struct\n DEF_VEC_O (dw_trace_info);\n DEF_VEC_ALLOC_O (dw_trace_info, heap);\n \n-typedef struct\n-{\n-  dw_trace_info *trace;\n-\n-#ifdef ENABLE_CHECKING\n-  dw_cfi_row *check_row;\n-#endif\n-} dw_label_info;\n+typedef dw_trace_info *dw_trace_info_ref;\n \n-DEF_VEC_O (dw_label_info);\n-DEF_VEC_ALLOC_O (dw_label_info, heap);\n+DEF_VEC_P (dw_trace_info_ref);\n+DEF_VEC_ALLOC_P (dw_trace_info_ref, heap);\n \n /* The variables making up the pseudo-cfg, as described above.  */\n-#if 0\n-static VEC (int, heap) *uid_luid;\n-static VEC (dw_label_info, heap) *label_info;\n static VEC (dw_trace_info, heap) *trace_info;\n-#endif\n+static VEC (dw_trace_info_ref, heap) *trace_work_list;\n+static htab_t trace_index;\n \n /* A vector of call frame insns for the CIE.  */\n cfi_vec cie_cfi_vec;\n@@ -189,9 +177,6 @@ static dw_trace_info *cur_trace;\n /* The current, i.e. most recently generated, row of the CFI table.  */\n static dw_cfi_row *cur_row;\n \n-/* The row state from a preceeding DW_CFA_remember_state.  */\n-static dw_cfi_row *remember_row;\n-\n /* We delay emitting a register save until either (a) we reach the end\n    of the prologue or (b) the register is clobbered.  This clusters\n    register saves so that there are fewer pc advances.  */\n@@ -211,20 +196,12 @@ static VEC(queued_reg_save, heap) *queued_reg_saves;\n    emitting this data, i.e. updating CUR_ROW, without async unwind.  */\n static HOST_WIDE_INT queued_args_size;\n \n-/* True if remember_state should be emitted before following CFI directive.  */\n-static bool emit_cfa_remember;\n-\n /* True if any CFI directives were emitted at the current insn.  */\n static bool any_cfis_emitted;\n \n /* Short-hand for commonly used register numbers.  */\n static unsigned dw_stack_pointer_regnum;\n static unsigned dw_frame_pointer_regnum;\n-\f\n-\n-static void dwarf2out_cfi_begin_epilogue (rtx insn);\n-static void dwarf2out_frame_debug_restore_state (void);\n-\n \f\n /* Hook used by __throw.  */\n \n@@ -295,6 +272,59 @@ expand_builtin_init_dwarf_reg_sizes (tree address)\n   targetm.init_dwarf_reg_sizes_extra (address);\n }\n \n+\f\n+static hashval_t\n+dw_trace_info_hash (const void *ptr)\n+{\n+  const dw_trace_info *ti = (const dw_trace_info *) ptr;\n+  return INSN_UID (ti->head);\n+}\n+\n+static int\n+dw_trace_info_eq (const void *ptr_a, const void *ptr_b)\n+{\n+  const dw_trace_info *a = (const dw_trace_info *) ptr_a;\n+  const dw_trace_info *b = (const dw_trace_info *) ptr_b;\n+  return a->head == b->head;\n+}\n+\n+static unsigned\n+get_trace_index (dw_trace_info *trace)\n+{\n+  return trace - VEC_address (dw_trace_info, trace_info);\n+}\n+\n+static dw_trace_info *\n+get_trace_info (rtx insn)\n+{\n+  dw_trace_info dummy;\n+  dummy.head = insn;\n+  return (dw_trace_info *)\n+    htab_find_with_hash (trace_index, &dummy, INSN_UID (insn));\n+}\n+\n+static bool\n+save_point_p (rtx insn)\n+{\n+  /* Labels, except those that are really jump tables.  */\n+  if (LABEL_P (insn))\n+    return inside_basic_block_p (insn);\n+\n+  /* We split traces at the prologue/epilogue notes because those\n+     are points at which the unwind info is usually stable.  This\n+     makes it easier to find spots with identical unwind info so\n+     that we can use remember/restore_state opcodes.  */\n+  if (NOTE_P (insn))\n+    switch (NOTE_KIND (insn))\n+      {\n+      case NOTE_INSN_PROLOGUE_END:\n+      case NOTE_INSN_EPILOGUE_BEG:\n+\treturn true;\n+      }\n+\n+  return false;\n+}\n+\n /* Divide OFF by DWARF_CIE_DATA_ALIGNMENT, asserting no remainder.  */\n \n static inline HOST_WIDE_INT\n@@ -352,18 +382,6 @@ copy_cfi_row (dw_cfi_row *src)\n   return dst;\n }\n \n-/* Free an allocated CFI row.  */\n-\n-static void\n-free_cfi_row (dw_cfi_row *row)\n-{\n-  if (row != NULL)\n-    {\n-      VEC_free (dw_cfi_ref, gc, row->reg_save);\n-      ggc_free (row);\n-    }\n-}\n-\n /* Generate a new label for the CFI info to refer to.  */\n \n static char *\n@@ -382,17 +400,6 @@ dwarf2out_cfi_label (void)\n static void\n add_cfi (dw_cfi_ref cfi)\n {\n-  if (emit_cfa_remember)\n-    {\n-      dw_cfi_ref cfi_remember;\n-\n-      /* Emit the state save.  */\n-      emit_cfa_remember = false;\n-      cfi_remember = new_cfi ();\n-      cfi_remember->dw_cfi_opc = DW_CFA_remember_state;\n-      add_cfi (cfi_remember);\n-    }\n-\n   any_cfis_emitted = true;\n \n   if (add_cfi_insn != NULL)\n@@ -645,6 +652,44 @@ cfi_equal_p (dw_cfi_ref a, dw_cfi_ref b)\n \t\t\t\t&a->dw_cfi_oprnd2, &b->dw_cfi_oprnd2));\n }\n \n+/* Determine if two CFI_ROW structures are identical.  */\n+\n+static bool\n+cfi_row_equal_p (dw_cfi_row *a, dw_cfi_row *b)\n+{\n+  size_t i, n_a, n_b, n_max;\n+\n+  if (a->cfa_cfi)\n+    {\n+      if (!cfi_equal_p (a->cfa_cfi, b->cfa_cfi))\n+\treturn false;\n+    }\n+  else if (!cfa_equal_p (&a->cfa, &b->cfa))\n+    return false;\n+\n+  if (a->args_size != b->args_size)\n+    return false;\n+\n+  n_a = VEC_length (dw_cfi_ref, a->reg_save);\n+  n_b = VEC_length (dw_cfi_ref, b->reg_save);\n+  n_max = MAX (n_a, n_b);\n+\n+  for (i = 0; i < n_max; ++i)\n+    {\n+      dw_cfi_ref r_a = NULL, r_b = NULL;\n+\n+      if (i < n_a)\n+\tr_a = VEC_index (dw_cfi_ref, a->reg_save, i);\n+      if (i < n_b)\n+\tr_b = VEC_index (dw_cfi_ref, b->reg_save, i);\n+\n+      if (!cfi_equal_p (r_a, r_b))\n+        return false;\n+    }\n+\n+  return true;\n+}\n+\n /* The CFA is now calculated from NEW_CFA.  Consider OLD_CFA in determining\n    what opcode to emit.  Returns the CFI opcode to effect the change, or\n    NULL if NEW_CFA == OLD_CFA.  */\n@@ -878,179 +923,6 @@ stack_adjust_offset (const_rtx pattern, HOST_WIDE_INT cur_args_size,\n   return offset;\n }\n \n-/* Precomputed args_size for CODE_LABELs and BARRIERs preceeding them,\n-   indexed by INSN_UID.  */\n-\n-static HOST_WIDE_INT *barrier_args_size;\n-\n-/* Helper function for compute_barrier_args_size.  Handle one insn.  */\n-\n-static HOST_WIDE_INT\n-compute_barrier_args_size_1 (rtx insn, HOST_WIDE_INT cur_args_size,\n-\t\t\t     VEC (rtx, heap) **next)\n-{\n-  HOST_WIDE_INT offset = 0;\n-  int i;\n-\n-  if (! RTX_FRAME_RELATED_P (insn))\n-    {\n-      if (prologue_epilogue_contains (insn))\n-\t/* Nothing */;\n-      else if (GET_CODE (PATTERN (insn)) == SET)\n-\toffset = stack_adjust_offset (PATTERN (insn), cur_args_size, 0);\n-      else if (GET_CODE (PATTERN (insn)) == PARALLEL\n-\t       || GET_CODE (PATTERN (insn)) == SEQUENCE)\n-\t{\n-\t  /* There may be stack adjustments inside compound insns.  Search\n-\t     for them.  */\n-\t  for (i = XVECLEN (PATTERN (insn), 0) - 1; i >= 0; i--)\n-\t    if (GET_CODE (XVECEXP (PATTERN (insn), 0, i)) == SET)\n-\t      offset += stack_adjust_offset (XVECEXP (PATTERN (insn), 0, i),\n-\t\t\t\t\t     cur_args_size, offset);\n-\t}\n-    }\n-  else\n-    {\n-      rtx expr = find_reg_note (insn, REG_FRAME_RELATED_EXPR, NULL_RTX);\n-\n-      if (expr)\n-\t{\n-\t  expr = XEXP (expr, 0);\n-\t  if (GET_CODE (expr) == PARALLEL\n-\t      || GET_CODE (expr) == SEQUENCE)\n-\t    for (i = 1; i < XVECLEN (expr, 0); i++)\n-\t      {\n-\t\trtx elem = XVECEXP (expr, 0, i);\n-\n-\t\tif (GET_CODE (elem) == SET && !RTX_FRAME_RELATED_P (elem))\n-\t\t  offset += stack_adjust_offset (elem, cur_args_size, offset);\n-\t      }\n-\t}\n-    }\n-\n-#ifndef STACK_GROWS_DOWNWARD\n-  offset = -offset;\n-#endif\n-\n-  cur_args_size += offset;\n-  if (cur_args_size < 0)\n-    cur_args_size = 0;\n-\n-  if (JUMP_P (insn))\n-    {\n-      rtx dest = JUMP_LABEL (insn);\n-\n-      if (dest)\n-\t{\n-\t  if (barrier_args_size [INSN_UID (dest)] < 0)\n-\t    {\n-\t      barrier_args_size [INSN_UID (dest)] = cur_args_size;\n-\t      VEC_safe_push (rtx, heap, *next, dest);\n-\t    }\n-\t}\n-    }\n-\n-  return cur_args_size;\n-}\n-\n-/* Walk the whole function and compute args_size on BARRIERs.  */\n-\n-static void\n-compute_barrier_args_size (void)\n-{\n-  int max_uid = get_max_uid (), i;\n-  rtx insn;\n-  VEC (rtx, heap) *worklist, *next, *tmp;\n-\n-  barrier_args_size = XNEWVEC (HOST_WIDE_INT, max_uid);\n-  for (i = 0; i < max_uid; i++)\n-    barrier_args_size[i] = -1;\n-\n-  worklist = VEC_alloc (rtx, heap, 20);\n-  next = VEC_alloc (rtx, heap, 20);\n-  insn = get_insns ();\n-  barrier_args_size[INSN_UID (insn)] = 0;\n-  VEC_quick_push (rtx, worklist, insn);\n-  for (;;)\n-    {\n-      while (!VEC_empty (rtx, worklist))\n-\t{\n-\t  rtx prev, body, first_insn;\n-\t  HOST_WIDE_INT cur_args_size;\n-\n-\t  first_insn = insn = VEC_pop (rtx, worklist);\n-\t  cur_args_size = barrier_args_size[INSN_UID (insn)];\n-\t  prev = prev_nonnote_insn (insn);\n-\t  if (prev && BARRIER_P (prev))\n-\t    barrier_args_size[INSN_UID (prev)] = cur_args_size;\n-\n-\t  for (; insn; insn = NEXT_INSN (insn))\n-\t    {\n-\t      if (INSN_DELETED_P (insn) || NOTE_P (insn))\n-\t\tcontinue;\n-\t      if (BARRIER_P (insn))\n-\t\tbreak;\n-\n-\t      if (LABEL_P (insn))\n-\t\t{\n-\t\t  if (insn == first_insn)\n-\t\t    continue;\n-\t\t  else if (barrier_args_size[INSN_UID (insn)] < 0)\n-\t\t    {\n-\t\t      barrier_args_size[INSN_UID (insn)] = cur_args_size;\n-\t\t      continue;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      /* The insns starting with this label have been\n-\t\t\t already scanned or are in the worklist.  */\n-\t\t      break;\n-\t\t    }\n-\t\t}\n-\n-\t      body = PATTERN (insn);\n-\t      if (GET_CODE (body) == SEQUENCE)\n-\t\t{\n-\t\t  HOST_WIDE_INT dest_args_size = cur_args_size;\n-\t\t  for (i = 1; i < XVECLEN (body, 0); i++)\n-\t\t    if (INSN_ANNULLED_BRANCH_P (XVECEXP (body, 0, 0))\n-\t\t\t&& INSN_FROM_TARGET_P (XVECEXP (body, 0, i)))\n-\t\t      dest_args_size\n-\t\t\t= compute_barrier_args_size_1 (XVECEXP (body, 0, i),\n-\t\t\t\t\t\t       dest_args_size, &next);\n-\t\t    else\n-\t\t      cur_args_size\n-\t\t\t= compute_barrier_args_size_1 (XVECEXP (body, 0, i),\n-\t\t\t\t\t\t       cur_args_size, &next);\n-\n-\t\t  if (INSN_ANNULLED_BRANCH_P (XVECEXP (body, 0, 0)))\n-\t\t    compute_barrier_args_size_1 (XVECEXP (body, 0, 0),\n-\t\t\t\t\t\t dest_args_size, &next);\n-\t\t  else\n-\t\t    cur_args_size\n-\t\t      = compute_barrier_args_size_1 (XVECEXP (body, 0, 0),\n-\t\t\t\t\t\t     cur_args_size, &next);\n-\t\t}\n-\t      else\n-\t\tcur_args_size\n-\t\t  = compute_barrier_args_size_1 (insn, cur_args_size, &next);\n-\t    }\n-\t}\n-\n-      if (VEC_empty (rtx, next))\n-\tbreak;\n-\n-      /* Swap WORKLIST with NEXT and truncate NEXT for next iteration.  */\n-      tmp = next;\n-      next = worklist;\n-      worklist = tmp;\n-      VEC_truncate (rtx, next, 0);\n-    }\n-\n-  VEC_free (rtx, heap, worklist);\n-  VEC_free (rtx, heap, next);\n-}\n-\n /* Add a CFI to update the running total of the size of arguments\n    pushed onto the stack.  */\n \n@@ -1150,25 +1022,7 @@ dwarf2out_notice_stack_adjust (rtx insn, bool after_p)\n       return;\n     }\n   else if (BARRIER_P (insn))\n-    {\n-      /* Don't call compute_barrier_args_size () if the only\n-\t BARRIER is at the end of function.  */\n-      if (barrier_args_size == NULL && next_nonnote_insn (insn))\n-\tcompute_barrier_args_size ();\n-      if (barrier_args_size == NULL)\n-\toffset = 0;\n-      else\n-\t{\n-\t  offset = barrier_args_size[INSN_UID (insn)];\n-\t  if (offset < 0)\n-\t    offset = 0;\n-\t}\n-\n-      offset -= queued_args_size;\n-#ifndef STACK_GROWS_DOWNWARD\n-      offset = -offset;\n-#endif\n-    }\n+    return;\n   else if (GET_CODE (PATTERN (insn)) == SET)\n     offset = stack_adjust_offset (PATTERN (insn), queued_args_size, 0);\n   else if (GET_CODE (PATTERN (insn)) == PARALLEL\n@@ -2531,184 +2385,357 @@ add_cfis_to_fde (void)\n     }\n }\n \n-/* Scan the function and create the initial set of CFI notes.  */\n+/* If LABEL is the start of a trace, then initialize the state of that\n+   trace from CUR_TRACE and CUR_ROW.  */\n \n static void\n-create_cfi_notes (void)\n+maybe_record_trace_start (rtx start, rtx origin)\n {\n-  rtx insn;\n+  dw_trace_info *ti;\n+\n+  /* Sync queued data before propagating to a destination,\n+     lest we propagate out-of-date data.  */\n+  dwarf2out_flush_queued_reg_saves ();\n+  dwarf2out_args_size (queued_args_size);\n+\n+  ti = get_trace_info (start);\n+  gcc_assert (ti != NULL);\n \n-  for (insn = get_insns (); insn ; insn = NEXT_INSN (insn))\n+  if (dump_file)\n     {\n-      rtx pat;\n+      fprintf (dump_file, \"   saw edge from trace %u to %u (via %s %d)\\n\",\n+\t       get_trace_index (cur_trace), get_trace_index (ti),\n+\t       (origin ? rtx_name[(int) GET_CODE (origin)] : \"fallthru\"),\n+\t       (origin ? INSN_UID (origin) : 0));\n+    }\n \n-      add_cfi_insn = PREV_INSN (insn);\n+  if (ti->beg_row == NULL)\n+    {\n+      /* This is the first time we've encountered this trace.  Propagate\n+\t state across the edge and push the trace onto the work list.  */\n+      ti->beg_row = copy_cfi_row (cur_row);\n+      ti->cfa_store = cur_trace->cfa_store;\n+      ti->cfa_temp = cur_trace->cfa_temp;\n+      ti->regs_saved_in_regs = VEC_copy (reg_saved_in_data, heap,\n+\t\t\t\t\t cur_trace->regs_saved_in_regs);\n+\n+      VEC_safe_push (dw_trace_info_ref, heap, trace_work_list, ti);\n+\n+      if (dump_file)\n+\tfprintf (dump_file, \"\\tpush trace %u to worklist\\n\",\n+\t\t get_trace_index (ti));\n+    }\n+  else\n+    {\n+      /* We ought to have the same state incoming to a given trace no\n+\t matter how we arrive at the trace.  Anything else means we've\n+\t got some kind of optimization error.  */\n+      gcc_checking_assert (cfi_row_equal_p (cur_row, ti->beg_row));\n+    }\n+}\n \n-      if (BARRIER_P (insn))\n+/* Propagate CUR_TRACE state to the destinations implied by INSN.  */\n+/* ??? Sadly, this is in large part a duplicate of make_edges.  */\n+\n+static void\n+create_trace_edges (rtx insn)\n+{\n+  rtx tmp, lab;\n+  int i, n;\n+\n+  if (JUMP_P (insn))\n+    {\n+      if (find_reg_note (insn, REG_NON_LOCAL_GOTO, NULL_RTX))\n+\t;\n+      else if (tablejump_p (insn, NULL, &tmp))\n \t{\n-\t  dwarf2out_frame_debug (insn, false);\n-\t  continue;\n-        }\n+\t  rtvec vec;\n \n-      if (NOTE_P (insn))\n+\t  tmp = PATTERN (tmp);\n+\t  vec = XVEC (tmp, GET_CODE (tmp) == ADDR_DIFF_VEC);\n+\n+\t  n = GET_NUM_ELEM (vec);\n+\t  for (i = 0; i < n; ++i)\n+\t    {\n+\t      lab = XEXP (RTVEC_ELT (vec, i), 0);\n+\t      maybe_record_trace_start (lab, insn);\n+\t    }\n+\t}\n+      else if (computed_jump_p (insn))\n \t{\n-\t  switch (NOTE_KIND (insn))\n+\t  for (lab = forced_labels; lab; lab = XEXP (lab, 1))\n+\t    maybe_record_trace_start (XEXP (lab, 0), insn);\n+\t}\n+      else if (returnjump_p (insn))\n+\t;\n+      else if ((tmp = extract_asm_operands (PATTERN (insn))) != NULL)\n+\t{\n+\t  n = ASM_OPERANDS_LABEL_LENGTH (tmp);\n+\t  for (i = 0; i < n; ++i)\n \t    {\n-\t    case NOTE_INSN_PROLOGUE_END:\n-\t      dwarf2out_flush_queued_reg_saves ();\n-\t      break;\n+\t      lab = XEXP (ASM_OPERANDS_LABEL (tmp, i), 0);\n+\t      maybe_record_trace_start (lab, insn);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  lab = JUMP_LABEL (insn);\n+\t  gcc_assert (lab != NULL);\n+\t  maybe_record_trace_start (lab, insn);\n+\t}\n+    }\n+  else if (CALL_P (insn))\n+    {\n+      /* Sibling calls don't have edges inside this function.  */\n+      if (SIBLING_CALL_P (insn))\n+\treturn;\n \n-\t    case NOTE_INSN_EPILOGUE_BEG:\n-#if defined(HAVE_epilogue)\n-\t      dwarf2out_cfi_begin_epilogue (insn);\n-#endif\n-\t      break;\n+      /* Process non-local goto edges.  */\n+      if (can_nonlocal_goto (insn))\n+\tfor (lab = nonlocal_goto_handler_labels; lab; lab = XEXP (lab, 1))\n+\t  maybe_record_trace_start (XEXP (lab, 0), insn);\n+    }\n \n-\t    case NOTE_INSN_CFA_RESTORE_STATE:\n-\t      add_cfi_insn = insn;\n-\t      dwarf2out_frame_debug_restore_state ();\n-\t      break;\n+  /* Process EH edges.  */\n+  if (CALL_P (insn) || cfun->can_throw_non_call_exceptions)\n+    {\n+      eh_landing_pad lp = get_eh_landing_pad_from_rtx (insn);\n+      if (lp)\n+\tmaybe_record_trace_start (lp->landing_pad, insn);\n+    }\n+}\n \n-\t    case NOTE_INSN_SWITCH_TEXT_SECTIONS:\n-\t      /* In dwarf2out_switch_text_section, we'll begin a new FDE\n-\t\t for the portion of the function in the alternate text\n-\t\t section.  The row state at the very beginning of that\n-\t\t new FDE will be exactly the row state from the CIE.\n-\t\t Emit whatever CFIs are necessary to make CUR_ROW current.  */\n-\t      add_cfi_insn = insn;\n-\t      change_cfi_row (cie_cfi_row, cur_row);\n-\t      break;\n-\t    }\n-\t  continue;\n+/* Scan the trace beginning at INSN and create the CFI notes for the\n+   instructions therein.  */\n+\n+static void\n+scan_trace (dw_trace_info *trace)\n+{\n+  rtx insn = trace->head;\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"Processing trace %u : start at %s %d\\n\",\n+\t     get_trace_index (trace), rtx_name[(int) GET_CODE (insn)],\n+\t     INSN_UID (insn));\n+\n+  trace->end_row = copy_cfi_row (trace->beg_row);\n+\n+  cur_trace = trace;\n+  cur_row = trace->end_row;\n+  queued_args_size = cur_row->args_size;\n+\n+  for (insn = NEXT_INSN (insn); insn ; insn = NEXT_INSN (insn))\n+    {\n+      rtx pat;\n+\n+      add_cfi_insn = PREV_INSN (insn);\n+\n+      /* Notice the end of a trace.  */\n+      if (BARRIER_P (insn) || save_point_p (insn))\n+\t{\n+\t  dwarf2out_flush_queued_reg_saves ();\n+\t  dwarf2out_args_size (queued_args_size);\n+\n+\t  /* Propagate across fallthru edges.  */\n+\t  if (!BARRIER_P (insn))\n+\t    maybe_record_trace_start (insn, NULL);\n+\t  break;\n \t}\n \n-      if (!NONDEBUG_INSN_P (insn))\n+      if (DEBUG_INSN_P (insn) || !inside_basic_block_p (insn))\n \tcontinue;\n \n       pat = PATTERN (insn);\n       if (asm_noperands (pat) >= 0)\n \t{\n \t  dwarf2out_frame_debug (insn, false);\n-\t  continue;\n+\t  add_cfi_insn = insn;\n \t}\n-\n-      if (GET_CODE (pat) == SEQUENCE)\n+      else\n \t{\n-\t  int i, n = XVECLEN (pat, 0);\n-\t  for (i = 1; i < n; ++i)\n-\t    dwarf2out_frame_debug (XVECEXP (pat, 0, i), false);\n-\t}\n+\t  if (GET_CODE (pat) == SEQUENCE)\n+\t    {\n+\t      int i, n = XVECLEN (pat, 0);\n+\t      for (i = 1; i < n; ++i)\n+\t\tdwarf2out_frame_debug (XVECEXP (pat, 0, i), false);\n+\t    }\n+\n+          if (CALL_P (insn))\n+\t    dwarf2out_frame_debug (insn, false);\n+          else if (find_reg_note (insn, REG_CFA_FLUSH_QUEUE, NULL)\n+\t\t   || (cfun->can_throw_non_call_exceptions\n+\t\t       && can_throw_internal (insn)))\n+\t    dwarf2out_flush_queued_reg_saves ();\n \n-      if (CALL_P (insn)\n-\t  || find_reg_note (insn, REG_CFA_FLUSH_QUEUE, NULL))\n-\tdwarf2out_frame_debug (insn, false);\n+\t  /* Do not separate tablejump insns from their ADDR_DIFF_VEC.\n+\t     Putting the note after the VEC should be ok.  */\n+\t  if (!tablejump_p (insn, NULL, &add_cfi_insn))\n+\t    add_cfi_insn = insn;\n \n-      /* Do not separate tablejump insns from their ADDR_DIFF_VEC.\n-\t Putting the note after the VEC should be ok.  */\n-      if (!tablejump_p (insn, NULL, &add_cfi_insn))\n-\tadd_cfi_insn = insn;\n+\t  dwarf2out_frame_debug (insn, true);\n+\t}\n \n-      dwarf2out_frame_debug (insn, true);\n+      /* Note that a test for control_flow_insn_p does exactly the\n+\t same tests as are done to actually create the edges.  So\n+\t always call the routine and let it not create edges for\n+\t non-control-flow insns.  */\n+      create_trace_edges (insn);\n     }\n \n   add_cfi_insn = NULL;\n+  cur_row = NULL;\n+  cur_trace = NULL;\n }\n \n-/* Determine if we need to save and restore CFI information around this\n-   epilogue.  If SIBCALL is true, then this is a sibcall epilogue.  If\n-   we do need to save/restore, then emit the save now, and insert a\n-   NOTE_INSN_CFA_RESTORE_STATE at the appropriate place in the stream.  */\n+/* Scan the function and create the initial set of CFI notes.  */\n \n static void\n-dwarf2out_cfi_begin_epilogue (rtx insn)\n+create_cfi_notes (void)\n {\n-  bool saw_frp = false;\n-  rtx i;\n+  dw_trace_info *ti;\n \n-  /* Scan forward to the return insn, noticing if there are possible\n-     frame related insns.  */\n-  for (i = NEXT_INSN (insn); i ; i = NEXT_INSN (i))\n-    {\n-      if (!INSN_P (i))\n-\tcontinue;\n-\n-      /* Look for both regular and sibcalls to end the block.  */\n-      if (returnjump_p (i))\n-\tbreak;\n-      if (CALL_P (i) && SIBLING_CALL_P (i))\n-\tbreak;\n+  gcc_checking_assert (queued_reg_saves == NULL);\n+  gcc_checking_assert (trace_work_list == NULL);\n \n-      if (GET_CODE (PATTERN (i)) == SEQUENCE)\n-\t{\n-\t  int idx;\n-\t  rtx seq = PATTERN (i);\n-\n-\t  if (returnjump_p (XVECEXP (seq, 0, 0)))\n-\t    break;\n-\t  if (CALL_P (XVECEXP (seq, 0, 0))\n-\t      && SIBLING_CALL_P (XVECEXP (seq, 0, 0)))\n-\t    break;\n-\n-\t  for (idx = 0; idx < XVECLEN (seq, 0); idx++)\n-\t    if (RTX_FRAME_RELATED_P (XVECEXP (seq, 0, idx)))\n-\t      saw_frp = true;\n-\t}\n+  /* Always begin at the entry trace.  */\n+  ti = VEC_index (dw_trace_info, trace_info, 0);\n+  scan_trace (ti);\n \n-      if (RTX_FRAME_RELATED_P (i))\n-\tsaw_frp = true;\n+  while (!VEC_empty (dw_trace_info_ref, trace_work_list))\n+    {\n+      ti = VEC_pop (dw_trace_info_ref, trace_work_list);\n+      scan_trace (ti);\n     }\n \n-  /* If the port doesn't emit epilogue unwind info, we don't need a\n-     save/restore pair.  */\n-  if (!saw_frp)\n-    return;\n+  VEC_free (queued_reg_save, heap, queued_reg_saves);\n+  VEC_free (dw_trace_info_ref, heap, trace_work_list);\n+}\n \n-  /* Otherwise, search forward to see if the return insn was the last\n-     basic block of the function.  If so, we don't need save/restore.  */\n-  gcc_assert (i != NULL);\n-  i = next_real_insn (i);\n-  if (i == NULL)\n-    return;\n+/* Insert CFI notes between traces to properly change state between them.  */\n+/* ??? TODO: Make use of remember/restore_state.  */\n \n-  /* Insert the restore before that next real insn in the stream, and before\n-     a potential NOTE_INSN_EPILOGUE_BEG -- we do need these notes to be\n-     properly nested.  This should be after any label or alignment.  This\n-     will be pushed into the CFI stream by the function below.  */\n-  while (1)\n+static void\n+connect_traces (void)\n+{\n+  unsigned i, n = VEC_length (dw_trace_info, trace_info);\n+  dw_trace_info *prev_ti, *ti;\n+\n+  prev_ti = VEC_index (dw_trace_info, trace_info, 0);\n+\n+  for (i = 1; i < n; ++i, prev_ti = ti)\n     {\n-      rtx p = PREV_INSN (i);\n-      if (!NOTE_P (p))\n-\tbreak;\n-      if (NOTE_KIND (p) == NOTE_INSN_BASIC_BLOCK)\n-\tbreak;\n-      i = p;\n-    }\n-  emit_note_before (NOTE_INSN_CFA_RESTORE_STATE, i);\n+      dw_cfi_row *old_row;\n \n-  emit_cfa_remember = true;\n+      ti = VEC_index (dw_trace_info, trace_info, i);\n \n-  /* And emulate the state save.  */\n-  gcc_assert (remember_row == NULL);\n-  remember_row = copy_cfi_row (cur_row);\n+      /* We must have both queued and processed every trace.  */\n+      gcc_assert (ti->beg_row && ti->end_row);\n+\n+      /* In dwarf2out_switch_text_section, we'll begin a new FDE\n+\t for the portion of the function in the alternate text\n+\t section.  The row state at the very beginning of that\n+\t new FDE will be exactly the row state from the CIE.  */\n+      if (ti->switch_sections)\n+\told_row = cie_cfi_row;\n+      else\n+\told_row = prev_ti->end_row;\n+\n+      add_cfi_insn = ti->head;\n+      change_cfi_row (old_row, ti->beg_row);\n+\n+      if (dump_file && add_cfi_insn != ti->head)\n+\t{\n+\t  rtx note;\n+\n+\t  fprintf (dump_file, \"Fixup between trace %u and %u:\\n\", i - 1, i);\n+\n+\t  note = ti->head;\n+\t  do\n+\t    {\n+\t      note = NEXT_INSN (note);\n+\t      gcc_assert (NOTE_P (note) && NOTE_KIND (note) == NOTE_INSN_CFI);\n+\t      output_cfi_directive (dump_file, NOTE_CFI (note));\n+\t    }\n+\t  while (note != add_cfi_insn);\n+\t}\n+    }\n }\n \n-/* A \"subroutine\" of dwarf2out_cfi_begin_epilogue.  Emit the restore\n-   required.  */\n+/* Set up the pseudo-cfg of instruction traces, as described at the\n+   block comment at the top of the file.  */\n \n static void\n-dwarf2out_frame_debug_restore_state (void)\n+create_pseudo_cfg (void)\n {\n-  dw_cfi_ref cfi = new_cfi ();\n+  bool saw_barrier, switch_sections;\n+  dw_trace_info *ti;\n+  rtx insn;\n+  unsigned i;\n+\n+  /* The first trace begins at the start of the function,\n+     and begins with the CIE row state.  */\n+  trace_info = VEC_alloc (dw_trace_info, heap, 16);\n+  ti = VEC_quick_push (dw_trace_info, trace_info, NULL);\n+\n+  memset (ti, 0, sizeof (*ti));\n+  ti->head = get_insns ();\n+  ti->beg_row = cie_cfi_row;\n+  ti->cfa_store = cie_cfi_row->cfa;\n+  ti->cfa_temp.reg = INVALID_REGNUM;\n+  if (cie_return_save)\n+    VEC_safe_push (reg_saved_in_data, heap,\n+\t\t   ti->regs_saved_in_regs, cie_return_save);\n \n-  cfi->dw_cfi_opc = DW_CFA_restore_state;\n-  add_cfi (cfi);\n+  /* Walk all the insns, collecting start of trace locations.  */\n+  saw_barrier = false;\n+  switch_sections = false;\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+    {\n+      if (BARRIER_P (insn))\n+\tsaw_barrier = true;\n+      else if (NOTE_P (insn)\n+\t       && NOTE_KIND (insn) == NOTE_INSN_SWITCH_TEXT_SECTIONS)\n+\t{\n+\t  /* We should have just seen a barrier.  */\n+\t  gcc_assert (saw_barrier);\n+\t  switch_sections = true;\n+\t}\n+      /* Watch out for save_point notes between basic blocks.\n+\t In particular, a note after a barrier.  Do not record these,\n+\t delaying trace creation until the label.  */\n+      else if (save_point_p (insn)\n+\t       && (LABEL_P (insn) || !saw_barrier))\n+\t{\n+\t  ti = VEC_safe_push (dw_trace_info, heap, trace_info, NULL);\n+\t  memset (ti, 0, sizeof (*ti));\n+\t  ti->head = insn;\n+\t  ti->switch_sections = switch_sections;\n+\n+\t  saw_barrier = false;\n+\t  switch_sections = false;\n+\t}\n+    }\n+\n+  /* Create the trace index after we've finished building trace_info,\n+     avoiding stale pointer problems due to reallocation.  */\n+  trace_index = htab_create (VEC_length (dw_trace_info, trace_info),\n+\t\t\t     dw_trace_info_hash, dw_trace_info_eq, NULL);\n+  FOR_EACH_VEC_ELT (dw_trace_info, trace_info, i, ti)\n+    {\n+      void **slot;\n \n-  gcc_assert (remember_row != NULL);\n-  free_cfi_row (cur_row);\n-  cur_row = remember_row;\n-  remember_row = NULL;\n+      if (dump_file)\n+\tfprintf (dump_file, \"Creating trace %u : start at %s %d%s\\n\", i,\n+\t\t rtx_name[(int) GET_CODE (ti->head)], INSN_UID (ti->head),\n+\t\t ti->switch_sections ? \" (section switch)\" : \"\");\n+\n+      slot = htab_find_slot_with_hash (trace_index, ti,\n+\t\t\t\t       INSN_UID (ti->head), INSERT);\n+      gcc_assert (*slot == NULL);\n+      *slot = (void *) ti;\n+    }\n }\n-\f\n+\n /* Record the initial position of the return address.  RTL is\n    INCOMING_RETURN_ADDR_RTX.  */\n \n@@ -2832,42 +2859,31 @@ create_cie_data (void)\n static unsigned int\n execute_dwarf2_frame (void)\n {\n-  dw_trace_info dummy_trace;\n-\n-  gcc_checking_assert (queued_reg_saves == NULL);\n-\n   /* The first time we're called, compute the incoming frame state.  */\n   if (cie_cfi_vec == NULL)\n     create_cie_data ();\n \n-  memset (&dummy_trace, 0, sizeof(dummy_trace));\n-  cur_trace = &dummy_trace;\n-\n-  /* Set up state for generating call frame debug info.  */\n-  cur_row = copy_cfi_row (cie_cfi_row);\n-  if (cie_return_save)\n-    VEC_safe_push (reg_saved_in_data, heap,\n-\t\t   cur_trace->regs_saved_in_regs, cie_return_save);\n-\n-  cur_trace->cfa_store = cur_row->cfa;\n-  cur_trace->cfa_temp.reg = INVALID_REGNUM;\n-  queued_args_size = 0;\n-\n   dwarf2out_alloc_current_fde ();\n \n+  create_pseudo_cfg ();\n+\n   /* Do the work.  */\n   create_cfi_notes ();\n+  connect_traces ();\n   add_cfis_to_fde ();\n \n-  /* Reset all function-specific information, particularly for GC.  */\n-  XDELETEVEC (barrier_args_size);\n-  barrier_args_size = NULL;\n-  VEC_free (reg_saved_in_data, heap, cur_trace->regs_saved_in_regs);\n-  VEC_free (queued_reg_save, heap, queued_reg_saves);\n+  /* Free all the data we allocated.  */\n+  {\n+    size_t i;\n+    dw_trace_info *ti;\n \n-  free_cfi_row (cur_row);\n-  cur_row = NULL;\n-  cur_trace = NULL;\n+    FOR_EACH_VEC_ELT (dw_trace_info, trace_info, i, ti)\n+      VEC_free (reg_saved_in_data, heap, ti->regs_saved_in_regs);\n+  }\n+  VEC_free (dw_trace_info, heap, trace_info);\n+\n+  htab_delete (trace_index);\n+  trace_index = NULL;\n \n   return 0;\n }"}]}