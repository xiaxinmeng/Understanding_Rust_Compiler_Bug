{"sha": "e3d1fd3263e5c0c5aa66bef848d829139029dc77", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTNkMWZkMzI2M2U1YzBjNWFhNjZiZWY4NDhkODI5MTM5MDI5ZGM3Nw==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1997-07-29T22:40:30Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1997-07-29T22:40:30Z"}, "message": "Patches to use cpplib with cc1 #if USE_CPPLIB.\n\nFrom-SVN: r14557", "tree": {"sha": "f72535174d01e86fc9e15923b22fdb881128d053", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f72535174d01e86fc9e15923b22fdb881128d053"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e3d1fd3263e5c0c5aa66bef848d829139029dc77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3d1fd3263e5c0c5aa66bef848d829139029dc77", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3d1fd3263e5c0c5aa66bef848d829139029dc77", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3d1fd3263e5c0c5aa66bef848d829139029dc77/comments", "author": null, "committer": null, "parents": [{"sha": "b4294351090fb3fd736b6f1b8cb0861971818079", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4294351090fb3fd736b6f1b8cb0861971818079", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4294351090fb3fd736b6f1b8cb0861971818079"}], "stats": {"total": 379, "additions": 278, "deletions": 101}, "files": [{"sha": "c3c4d0e9d1cb8a6c815c26b5e14f9ffe847629d1", "filename": "gcc/c-lex.c", "status": "modified", "additions": 266, "deletions": 100, "changes": 366, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3d1fd3263e5c0c5aa66bef848d829139029dc77/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3d1fd3263e5c0c5aa66bef848d829139029dc77/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=e3d1fd3263e5c0c5aa66bef848d829139029dc77", "patch": "@@ -44,6 +44,13 @@ Boston, MA 02111-1307, USA.  */\n extern int errno;\n #endif\n \n+#if USE_CPPLIB\n+#include \"cpplib.h\"\n+cpp_reader parse_in;\n+cpp_options parse_options;\n+static enum cpp_token cpp_token;\n+#endif\n+\n /* The elements of `ridpointers' are identifier nodes\n    for the reserved type names and storage classes.\n    It is indexed by a RID_... value.  */\n@@ -52,6 +59,32 @@ tree ridpointers[(int) RID_MAX];\n /* Cause the `yydebug' variable to be defined.  */\n #define YYDEBUG 1\n \n+#if USE_CPPLIB\n+static unsigned char *yy_cur, *yy_lim;\n+\n+int\n+yy_get_token ()\n+{\n+  for (;;)\n+    {\n+      parse_in.limit = parse_in.token_buffer;\n+      cpp_token = cpp_get_token (&parse_in);\n+      if (cpp_token == CPP_EOF)\n+\treturn -1;\n+      yy_lim = CPP_PWRITTEN (&parse_in);\n+      yy_cur = parse_in.token_buffer;\n+      if (yy_cur < yy_lim)\n+\treturn *yy_cur++;\n+    }\n+}\n+\n+#define GETC() (yy_cur < yy_lim ? *yy_cur++ : yy_get_token ())\n+#define UNGETC(c) ((c), yy_cur--)\n+#else\n+#define GETC() getc (finput)\n+#define UNGETC(c) ungetc (c, finput)\n+#endif\n+\n /* the declaration found for the last IDENTIFIER token read in.\n    yylex must look this up to detect typedefs, which get token type TYPENAME,\n    so it is left around in case the identifier is not a typedef but is\n@@ -88,8 +121,10 @@ char *token_buffer;\t/* Pointer to token buffer.\n /* Nonzero if end-of-file has been seen on input.  */\n static int end_of_file;\n \n+#if !USE_CPPLIB\n /* Buffered-back input character; faster than using ungetc.  */\n static int nextchar = -1;\n+#endif\n \n int check_newline ();\n \f\n@@ -142,6 +177,31 @@ remember_protocol_qualifiers ()\n       wordlist[i].name = \"oneway\";   \n }\n \f\n+#if USE_CPPLIB\n+void\n+init_parse (filename)\n+     char *filename;\n+{\n+  init_lex ();\n+  yy_cur = \"\\n\";\n+  yy_lim = yy_cur+1;\n+\n+  cpp_reader_init (&parse_in);\n+  parse_in.data = &parse_options;\n+  cpp_options_init (&parse_options);\n+  cpp_handle_options (&parse_in, 0, NULL); /* FIXME */\n+  parse_in.show_column = 1;\n+  if (! cpp_start_read (&parse_in, filename))\n+    abort ();\n+}\n+\n+void\n+finish_parse ()\n+{\n+  cpp_finish (&parse_in);\n+}\n+#endif\n+\n void\n init_lex ()\n {\n@@ -289,7 +349,7 @@ skip_white_space (c)\n \tcase '\\f':\n \tcase '\\v':\n \tcase '\\b':\n-\t  c = getc (finput);\n+\t  c = GETC();\n \t  break;\n \n \tcase '\\r':\n@@ -301,16 +361,16 @@ skip_white_space (c)\n \t      warning (\"(we only warn about the first carriage return)\");\n \t      newline_warning = 1;\n \t    }\n-\t  c = getc (finput);\n+\t  c = GETC();\n \t  break;\n \n \tcase '\\\\':\n-\t  c = getc (finput);\n+\t  c = GETC();\n \t  if (c == '\\n')\n \t    lineno++;\n \t  else\n \t    error (\"stray '\\\\' in program\");\n-\t  c = getc (finput);\n+\t  c = GETC();\n \t  break;\n \n \tdefault:\n@@ -327,12 +387,14 @@ position_after_white_space ()\n {\n   register int c;\n \n+#if !USE_CPPLIB\n   if (nextchar != -1)\n     c = nextchar, nextchar = -1;\n   else\n-    c = getc (finput);\n+#endif\n+    c = GETC();\n \n-  ungetc (skip_white_space (c), finput);\n+  UNGETC (skip_white_space (c));\n }\n \n /* Make the token buffer longer, preserving the data in it.\n@@ -351,6 +413,89 @@ extend_token_buffer (p)\n \n   return token_buffer + offset;\n }\n+\n+\f\n+#if !USE_CPPLIB\n+#define GET_DIRECTIVE_LINE() get_directive_line (finput)\n+#else /* USE_CPPLIB */\n+/* Read the rest of a #-directive from input stream FINPUT.\n+   In normal use, the directive name and the white space after it\n+   have already been read, so they won't be included in the result.\n+   We allow for the fact that the directive line may contain\n+   a newline embedded within a character or string literal which forms\n+   a part of the directive.\n+\n+   The value is a string in a reusable buffer.  It remains valid\n+   only until the next time this function is called.  */\n+\n+static char *\n+GET_DIRECTIVE_LINE ()\n+{\n+  static char *directive_buffer = NULL;\n+  static unsigned buffer_length = 0;\n+  register char *p;\n+  register char *buffer_limit;\n+  register int looking_for = 0;\n+  register int char_escaped = 0;\n+\n+  if (buffer_length == 0)\n+    {\n+      directive_buffer = (char *)xmalloc (128);\n+      buffer_length = 128;\n+    }\n+\n+  buffer_limit = &directive_buffer[buffer_length];\n+\n+  for (p = directive_buffer; ; )\n+    {\n+      int c;\n+\n+      /* Make buffer bigger if it is full.  */\n+      if (p >= buffer_limit)\n+        {\n+\t  register unsigned bytes_used = (p - directive_buffer);\n+\n+\t  buffer_length *= 2;\n+\t  directive_buffer\n+\t    = (char *)xrealloc (directive_buffer, buffer_length);\n+\t  p = &directive_buffer[bytes_used];\n+\t  buffer_limit = &directive_buffer[buffer_length];\n+        }\n+\n+      c = GETC ();\n+\n+      /* Discard initial whitespace.  */\n+      if ((c == ' ' || c == '\\t') && p == directive_buffer)\n+\tcontinue;\n+\n+      /* Detect the end of the directive.  */\n+      if (c == '\\n' && looking_for == 0)\n+\t{\n+          UNGETC (c);\n+\t  c = '\\0';\n+\t}\n+\n+      *p++ = c;\n+\n+      if (c == 0)\n+\treturn directive_buffer;\n+\n+      /* Handle string and character constant syntax.  */\n+      if (looking_for)\n+\t{\n+\t  if (looking_for == c && !char_escaped)\n+\t    looking_for = 0;\t/* Found terminator... stop looking.  */\n+\t}\n+      else\n+        if (c == '\\'' || c == '\"')\n+\t  looking_for = c;\t/* Don't stop buffering until we see another\n+\t\t\t\t   another one of these (or an EOF).  */\n+\n+      /* Handle backslash.  */\n+      char_escaped = (c == '\\\\' && ! char_escaped);\n+    }\n+}\n+#endif /* USE_CPPLIB */\n \f\n /* At the beginning of a line, increment the line number\n    and process any #-directive on this line.\n@@ -367,9 +512,9 @@ check_newline ()\n \n   /* Read first nonwhite char on the line.  */\n \n-  c = getc (finput);\n+  c = GETC();\n   while (c == ' ' || c == '\\t')\n-    c = getc (finput);\n+    c = GETC();\n \n   if (c != '#')\n     {\n@@ -379,9 +524,9 @@ check_newline ()\n \n   /* Read first nonwhite char after the `#'.  */\n \n-  c = getc (finput);\n+  c = GETC();\n   while (c == ' ' || c == '\\t')\n-    c = getc (finput);\n+    c = GETC();\n \n   /* If a letter follows, then if the word here is `line', skip\n      it and ignore it; otherwise, ignore the line, with an error\n@@ -391,34 +536,38 @@ check_newline ()\n     {\n       if (c == 'p')\n \t{\n-\t  if (getc (finput) == 'r'\n-\t      && getc (finput) == 'a'\n-\t      && getc (finput) == 'g'\n-\t      && getc (finput) == 'm'\n-\t      && getc (finput) == 'a'\n-\t      && ((c = getc (finput)) == ' ' || c == '\\t' || c == '\\n'))\n+\t  if (GETC() == 'r'\n+\t      && GETC() == 'a'\n+\t      && GETC() == 'g'\n+\t      && GETC() == 'm'\n+\t      && GETC() == 'a'\n+\t      && ((c = GETC()) == ' ' || c == '\\t' || c == '\\n'))\n \t    {\n \t      while (c == ' ' || c == '\\t')\n-\t\tc = getc (finput);\n+\t\tc = GETC ();\n \t      if (c == '\\n')\n \t\treturn c;\n #ifdef HANDLE_SYSV_PRAGMA\n-\t      ungetc (c, finput);\n+\t      UNGETC (c);\n \t      token = yylex ();\n \t      if (token != IDENTIFIER)\n \t\tgoto skipline;\n-\t      return handle_sysv_pragma (finput, token);\n+\t      return handle_sysv_pragma (token);\n #else /* !HANDLE_SYSV_PRAGMA */\n #ifdef HANDLE_PRAGMA\n-\t      ungetc (c, finput);\n+#if !USE_CPPLIB\n+\t      UNGETC (c);\n \t      token = yylex ();\n \t      if (token != IDENTIFIER)\n \t\tgoto skipline;\n-\t      if (HANDLE_PRAGMA (finput, yylval.ttype))\n+\t      if (HANDLE_PRAGMA (yylval.ttype))\n \t\t{\n-\t\t  c = getc (finput);\n+\t\t  c = GETC ();\n \t\t  return c;\n \t\t}\n+#else\n+\t      ??? do not know what to do ???;\n+#endif /* !USE_CPPLIB */\n #endif /* HANDLE_PRAGMA */\n #endif /* !HANDLE_SYSV_PRAGMA */\n \t      goto skipline;\n@@ -427,60 +576,60 @@ check_newline ()\n \n       else if (c == 'd')\n \t{\n-\t  if (getc (finput) == 'e'\n-\t      && getc (finput) == 'f'\n-\t      && getc (finput) == 'i'\n-\t      && getc (finput) == 'n'\n-\t      && getc (finput) == 'e'\n-\t      && ((c = getc (finput)) == ' ' || c == '\\t' || c == '\\n'))\n+\t  if (GETC() == 'e'\n+\t      && GETC() == 'f'\n+\t      && GETC() == 'i'\n+\t      && GETC() == 'n'\n+\t      && GETC() == 'e'\n+\t      && ((c = GETC()) == ' ' || c == '\\t' || c == '\\n'))\n \t    {\n \t      if (c != '\\n')\n-\t\tdebug_define (lineno, get_directive_line (finput));\n+\t\tdebug_define (lineno, GET_DIRECTIVE_LINE ());\n \t      goto skipline;\n \t    }\n \t}\n       else if (c == 'u')\n \t{\n-\t  if (getc (finput) == 'n'\n-\t      && getc (finput) == 'd'\n-\t      && getc (finput) == 'e'\n-\t      && getc (finput) == 'f'\n-\t      && ((c = getc (finput)) == ' ' || c == '\\t' || c == '\\n'))\n+\t  if (GETC() == 'n'\n+\t      && GETC() == 'd'\n+\t      && GETC() == 'e'\n+\t      && GETC() == 'f'\n+\t      && ((c = GETC()) == ' ' || c == '\\t' || c == '\\n'))\n \t    {\n \t      if (c != '\\n')\n-\t\tdebug_undef (lineno, get_directive_line (finput));\n+\t\tdebug_undef (lineno, GET_DIRECTIVE_LINE ());\n \t      goto skipline;\n \t    }\n \t}\n       else if (c == 'l')\n \t{\n-\t  if (getc (finput) == 'i'\n-\t      && getc (finput) == 'n'\n-\t      && getc (finput) == 'e'\n-\t      && ((c = getc (finput)) == ' ' || c == '\\t'))\n+\t  if (GETC() == 'i'\n+\t      && GETC() == 'n'\n+\t      && GETC() == 'e'\n+\t      && ((c = GETC()) == ' ' || c == '\\t'))\n \t    goto linenum;\n \t}\n       else if (c == 'i')\n \t{\n-\t  if (getc (finput) == 'd'\n-\t      && getc (finput) == 'e'\n-\t      && getc (finput) == 'n'\n-\t      && getc (finput) == 't'\n-\t      && ((c = getc (finput)) == ' ' || c == '\\t'))\n+\t  if (GETC() == 'd'\n+\t      && GETC() == 'e'\n+\t      && GETC() == 'n'\n+\t      && GETC() == 't'\n+\t      && ((c = GETC()) == ' ' || c == '\\t'))\n \t    {\n \t      /* #ident.  The pedantic warning is now in cccp.c.  */\n \n \t      /* Here we have just seen `#ident '.\n \t\t A string constant should follow.  */\n \n \t      while (c == ' ' || c == '\\t')\n-\t\tc = getc (finput);\n+\t\tc = GETC();\n \n \t      /* If no argument, ignore the line.  */\n \t      if (c == '\\n')\n \t\treturn c;\n \n-\t      ungetc (c, finput);\n+\t      UNGETC (c);\n \t      token = yylex ();\n \t      if (token != STRING\n \t\t  || TREE_CODE (yylval.ttype) != STRING_CST)\n@@ -510,7 +659,7 @@ check_newline ()\n      In either case, it should be a line number; a digit should follow.  */\n \n   while (c == ' ' || c == '\\t')\n-    c = getc (finput);\n+    c = GETC();\n \n   /* If the # is the only nonwhite char on the line,\n      just ignore it.  Check the new newline.  */\n@@ -519,7 +668,7 @@ check_newline ()\n \n   /* Something follows the #; read a token.  */\n \n-  ungetc (c, finput);\n+  UNGETC (c);\n   token = yylex ();\n \n   if (token == CONSTANT\n@@ -533,16 +682,16 @@ check_newline ()\n       int l = TREE_INT_CST_LOW (yylval.ttype) - 1;\n \n       /* Is this the last nonwhite stuff on the line?  */\n-      c = getc (finput);\n+      c = GETC();\n       while (c == ' ' || c == '\\t')\n-\tc = getc (finput);\n+\tc = GETC();\n       if (c == '\\n')\n \t{\n \t  /* No more: store the line number and check following line.  */\n \t  lineno = l;\n \t  return c;\n \t}\n-      ungetc (c, finput);\n+      UNGETC (c);\n \n       /* More follows: it must be a string constant (filename).  */\n \n@@ -568,9 +717,9 @@ check_newline ()\n \tmain_input_filename = input_filename;\n \n       /* Is this the last nonwhite stuff on the line?  */\n-      c = getc (finput);\n+      c = GETC();\n       while (c == ' ' || c == '\\t')\n-\tc = getc (finput);\n+\tc = GETC();\n       if (c == '\\n')\n \t{\n \t  /* Update the name in the top element of input_file_stack.  */\n@@ -579,7 +728,7 @@ check_newline ()\n \n \t  return c;\n \t}\n-      ungetc (c, finput);\n+      UNGETC (c);\n \n       token = yylex ();\n       used_up = 0;\n@@ -631,12 +780,12 @@ check_newline ()\n       if (used_up)\n \t{\n \t  /* Is this the last nonwhite stuff on the line?  */\n-\t  c = getc (finput);\n+\t  c = GETC();\n \t  while (c == ' ' || c == '\\t')\n-\t    c = getc (finput);\n+\t    c = GETC();\n \t  if (c == '\\n')\n \t    return c;\n-\t  ungetc (c, finput);\n+\t  UNGETC (c);\n \n \t  token = yylex ();\n \t  used_up = 0;\n@@ -652,12 +801,12 @@ check_newline ()\n       if (used_up)\n \t{\n \t  /* Is this the last nonwhite stuff on the line?  */\n-\t  c = getc (finput);\n+\t  c = GETC();\n \t  while (c == ' ' || c == '\\t')\n-\t    c = getc (finput);\n+\t    c = GETC();\n \t  if (c == '\\n')\n \t    return c;\n-\t  ungetc (c, finput);\n+\t  UNGETC (c);\n \t}\n \n       warning (\"unrecognized text at end of #line\");\n@@ -668,22 +817,32 @@ check_newline ()\n   /* skip the rest of this line.  */\n  skipline:\n   while (c != '\\n' && c != EOF)\n-    c = getc (finput);\n+    c = GETC();\n   return c;\n }\n+\n+void\n+lang_init ()\n+{\n+#if !USE_CPPLIB\n+  /* the beginning of the file is a new line; check for # */\n+  /* With luck, we discover the real source file's name from that\n+     and put it in input_filename.  */\n+  UNGETC (check_newline ());\n+#endif\n+}\n \f\n #ifdef HANDLE_SYSV_PRAGMA\n \n-/* Handle a #pragma directive.  INPUT is the current input stream,\n-   and TOKEN is the token we read after `#pragma'.  Processes the entire input\n+/* Handle a #pragma directive.\n+   TOKEN is the token we read after `#pragma'.  Processes the entire input\n    line and returns a character for the caller to reread: either \\n or EOF.  */\n \n /* This function has to be in this file, in order to get at\n    the token types.  */\n \n int\n-handle_sysv_pragma (input, token)\n-     FILE *input;\n+handle_sysv_pragma (token)\n      register int token;\n {\n   register int c;\n@@ -701,20 +860,21 @@ handle_sysv_pragma (input, token)\n \tdefault:\n \t  handle_pragma_token (token_buffer, 0);\n \t}\n-\n+#if !USE_CPPLIB\n       if (nextchar >= 0)\n \tc = nextchar, nextchar = -1;\n       else\n-\tc = getc (input);\n+#endif\n+\tc = GETC ();\n \n       while (c == ' ' || c == '\\t')\n-\tc = getc (input);\n+\tc = GETC ();\n       if (c == '\\n' || c == EOF)\n \t{\n \t  handle_pragma_token (0, 0);\n \t  return c;\n \t}\n-      ungetc (c, input);\n+      UNGETC (c);\n       token = yylex ();\n     }\n }\n@@ -730,7 +890,7 @@ static int\n readescape (ignore_ptr)\n      int *ignore_ptr;\n {\n-  register int c = getc (finput);\n+  register int c = GETC();\n   register int code;\n   register unsigned count;\n   unsigned firstdig = 0;\n@@ -750,12 +910,12 @@ readescape (ignore_ptr)\n       nonnull = 0;\n       while (1)\n \t{\n-\t  c = getc (finput);\n+\t  c = GETC();\n \t  if (!(c >= 'a' && c <= 'f')\n \t      && !(c >= 'A' && c <= 'F')\n \t      && !(c >= '0' && c <= '9'))\n \t    {\n-\t      ungetc (c, finput);\n+\t      UNGETC (c);\n \t      break;\n \t    }\n \t  code *= 16;\n@@ -792,9 +952,9 @@ readescape (ignore_ptr)\n       while ((c <= '7') && (c >= '0') && (count++ < 3))\n \t{\n \t  code = (code * 8) + (c - '0');\n-\t  c = getc (finput);\n+\t  c = GETC();\n \t}\n-      ungetc (c, finput);\n+      UNGETC (c);\n       return code;\n \n     case '\\\\': case '\\'': case '\"':\n@@ -918,10 +1078,12 @@ yylex ()\n   int wide_flag = 0;\n   int objc_flag = 0;\n \n+#if !USE_CPPLIB\n   if (nextchar >= 0)\n     c = nextchar, nextchar = -1;\n   else\n-    c = getc (finput);\n+#endif\n+    c = GETC();\n \n   /* Effectively do c = skip_white_space (c)\n      but do it faster in the usual cases.  */\n@@ -933,7 +1095,7 @@ yylex ()\n       case '\\f':\n       case '\\v':\n       case '\\b':\n-\tc = getc (finput);\n+\tc = GETC();\n \tbreak;\n \n       case '\\r':\n@@ -964,7 +1126,7 @@ yylex ()\n     case 'L':\n       /* Capital L may start a wide-string or wide-character constant.  */\n       {\n-\tregister int c = getc (finput);\n+\tregister int c = GETC();\n \tif (c == '\\'')\n \t  {\n \t    wide_flag = 1;\n@@ -975,7 +1137,7 @@ yylex ()\n \t    wide_flag = 1;\n \t    goto string_constant;\n \t  }\n-\tungetc (c, finput);\n+\tUNGETC (c);\n       }\n       goto letter;\n \n@@ -988,13 +1150,13 @@ yylex ()\n       else\n \t{\n \t  /* '@' may start a constant string object.  */\n-\t  register int c = getc(finput);\n+\t  register int c = GETC ();\n \t  if (c == '\"')\n \t    {\n \t      objc_flag = 1;\n \t      goto string_constant;\n \t    }\n-\t  ungetc(c, finput);\n+\t  UNGETC (c);\n \t  /* Fall through to treat '@' as the start of an identifier.  */\n \t}\n \n@@ -1031,11 +1193,15 @@ yylex ()\n \t    p = extend_token_buffer (p);\n \n \t  *p++ = c;\n-\t  c = getc (finput);\n+\t  c = GETC();\n \t}\n \n       *p = 0;\n+#if USE_CPPLIB\n+      UNGETC (c);\n+#else\n       nextchar = c;\n+#endif\n \n       value = IDENTIFIER;\n       yylval.itype = 0;\n@@ -1120,8 +1286,8 @@ yylex ()\n \tint next_c;\n \t/* Check first for common special case:  single-digit 0 or 1.  */\n \n-\tnext_c = getc (finput);\n-\tungetc (next_c, finput);\t/* Always undo this lookahead.  */\n+\tnext_c = GETC ();\n+\tUNGETC (next_c);\t/* Always undo this lookahead.  */\n \tif (!isalnum (next_c) && next_c != '.')\n \t  {\n \t    token_buffer[0] = (char)c,  token_buffer[1] = '\\0';\n@@ -1160,11 +1326,11 @@ yylex ()\n \n \tif (c == '0')\n \t  {\n-\t    *p++ = (c = getc (finput));\n+\t    *p++ = (c = GETC());\n \t    if ((c == 'x') || (c == 'X'))\n \t      {\n \t\tbase = 16;\n-\t\t*p++ = (c = getc (finput));\n+\t\t*p++ = (c = GETC());\n \t      }\n \t    /* Leading 0 forces octal unless the 0 is the only digit.  */\n \t    else if (c >= '0' && c <= '9')\n@@ -1203,7 +1369,7 @@ yylex ()\n \t\t  floatflag = AFTER_POINT;\n \n \t\tbase = 10;\n-\t\t*p++ = c = getc (finput);\n+\t\t*p++ = c = GETC();\n \t\t/* Accept '.' as the start of a floating-point number\n \t\t   only when it is followed by a digit.\n \t\t   Otherwise, unread the following non-digit\n@@ -1212,7 +1378,7 @@ yylex ()\n \t\t  {\n \t\t    if (c == '.')\n \t\t      {\n-\t\t\tc = getc (finput);\n+\t\t\tc = GETC();\n \t\t\tif (c == '.')\n \t\t\t  {\n \t\t\t    *p++ = c;\n@@ -1221,7 +1387,7 @@ yylex ()\n \t\t\t  }\n \t\t\terror (\"parse error at `..'\");\n \t\t      }\n-\t\t    ungetc (c, finput);\n+\t\t    UNGETC (c);\n \t\t    token_buffer[1] = 0;\n \t\t    value = '.';\n \t\t    goto done;\n@@ -1280,7 +1446,7 @@ yylex ()\n \n \t\tif (p >= token_buffer + maxtoken - 3)\n \t\t  p = extend_token_buffer (p);\n-\t\t*p++ = (c = getc (finput));\n+\t\t*p++ = (c = GETC());\n \t      }\n \t  }\n \n@@ -1308,11 +1474,11 @@ yylex ()\n \t\tif (p >= token_buffer + maxtoken - 3)\n \t\t  p = extend_token_buffer (p);\n \t\t*p++ = c;\n-\t\tc = getc (finput);\n+\t\tc = GETC();\n \t\tif ((c == '+') || (c == '-'))\n \t\t  {\n \t\t    *p++ = c;\n-\t\t    c = getc (finput);\n+\t\t    c = GETC();\n \t\t  }\n \t\tif (! isdigit (c))\n \t\t  error (\"floating constant exponent has no digits\");\n@@ -1321,7 +1487,7 @@ yylex ()\n \t\t    if (p >= token_buffer + maxtoken - 3)\n \t\t      p = extend_token_buffer (p);\n \t\t    *p++ = c;\n-\t\t    c = getc (finput);\n+\t\t    c = GETC();\n \t\t  }\n \t      }\n \n@@ -1383,7 +1549,7 @@ yylex ()\n \t\t      p = extend_token_buffer (p);\n \t\t    *p++ = c;\n \t\t    *p = 0;\n-\t\t    c = getc (finput);\n+\t\t    c = GETC();\n \t\t  }\n \n \t\t/* The second argument, machine_mode, of REAL_VALUE_ATOF\n@@ -1490,7 +1656,7 @@ yylex ()\n \t\tif (p >= token_buffer + maxtoken - 3)\n \t\t  p = extend_token_buffer (p);\n \t\t*p++ = c;\n-\t\tc = getc (finput);\n+\t\tc = GETC();\n \t      }\n \n \t    /* If the constant is not long long and it won't fit in an\n@@ -1631,7 +1797,7 @@ yylex ()\n \t      TREE_TYPE (yylval.ttype) = type;\n \t  }\n \n-\tungetc (c, finput);\n+\tUNGETC (c);\n \t*p = 0;\n \n \tif (isalnum (c) || c == '.' || c == '_' || c == '$'\n@@ -1666,7 +1832,7 @@ yylex ()\n \t  {\n \t  tryagain:\n \n-\t    c = getc (finput);\n+\t    c = GETC();\n \n \t    if (c == '\\'' || c == EOF)\n \t      break;\n@@ -1776,7 +1942,7 @@ yylex ()\n     case '\"':\n     string_constant:\n       {\n-\tc = getc (finput);\n+\tc = GETC();\n \tp = token_buffer + 1;\n \n \twhile (c != '\"' && c >= 0)\n@@ -1804,7 +1970,7 @@ yylex ()\n \t    *p++ = c;\n \n \t  skipnewline:\n-\t    c = getc (finput);\n+\t    c = GETC();\n \t  }\n \t*p = 0;\n \n@@ -1918,7 +2084,7 @@ yylex ()\n \t    yylval.code = GT_EXPR; break;\n \t  }\n \n-\ttoken_buffer[1] = c1 = getc (finput);\n+\ttoken_buffer[1] = c1 = GETC();\n \ttoken_buffer[2] = 0;\n \n \tif (c1 == '=')\n@@ -1976,7 +2142,7 @@ yylex ()\n \t\t{ value = '}'; goto done; }\n \t      break;\n \t    }\n-\tungetc (c1, finput);\n+\tUNGETC (c1);\n \ttoken_buffer[1] = 0;\n \n \tif ((c == '<') || (c == '>'))"}, {"sha": "cb11ab46d0d6fe404dbc239f6fd9f33ab373bce5", "filename": "gcc/toplev.c", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3d1fd3263e5c0c5aa66bef848d829139029dc77/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3d1fd3263e5c0c5aa66bef848d829139029dc77/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=e3d1fd3263e5c0c5aa66bef848d829139029dc77", "patch": "@@ -209,9 +209,10 @@ char *input_filename;\n \n char *main_input_filename;\n \n+#if !USE_CPPLIB\n /* Stream for reading from the input file.  */\n-\n FILE *finput;\n+#endif\n \n /* Current line number in real source file.  */\n \n@@ -2123,6 +2124,7 @@ compile_file (name)\n   symout_time = 0;\n   dump_time = 0;\n \n+#if !USE_CPPLIB\n   /* Open input file.  */\n \n   if (name == 0 || !strcmp (name, \"-\"))\n@@ -2138,12 +2140,17 @@ compile_file (name)\n #ifdef IO_BUFFER_SIZE\n   setvbuf (finput, (char *) xmalloc (IO_BUFFER_SIZE), _IOFBF, IO_BUFFER_SIZE);\n #endif\n+#endif /* !USE_CPPLIB */\n \n   /* Initialize data in various passes.  */\n \n   init_obstacks ();\n   init_tree_codes ();\n+#if USE_CPPLIB\n+  init_parse (name);\n+#else\n   init_lex ();\n+#endif\n   /* Some of these really don't need to be called when generating bytecode,\n      but the options would have to be parsed first to know that. -bson */\n   init_rtl ();\n@@ -2722,7 +2729,11 @@ compile_file (name)\n      whether fclose returns an error, since the pages might still be on the\n      buffer chain while the file is open.  */\n \n+#if USE_CPPLIB\n+  finish_parse ();\n+#else\n   fclose (finput);\n+#endif\n   if (ferror (asm_out_file) != 0 || fclose (asm_out_file) != 0)\n     fatal_io_error (asm_file_name);\n "}]}