{"sha": "f2d5f0cca244fc70acb45fbe557bd22411175f1b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjJkNWYwY2NhMjQ0ZmM3MGFjYjQ1ZmJlNTU3YmQyMjQxMTE3NWYxYg==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@wolery.cumb.org", "date": "2000-04-14T23:29:45Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-04-14T23:29:45Z"}, "message": "cpplex.c (cpp_output_tokens, [...]): New public interfaces.\n\n\t* cpplex.c (cpp_output_tokens, cpp_scan_buffer_nooutput): New public\n\tinterfaces.\n\t(safe_fwrite, output_line_command): New static functions.\n\t(cpp_expand_to_buffer): Now private to cpplib.\n\t(cpp_scan_buffer): Take a printer.\n\n\t* cpphash.h: Update prototypes.\n\t* cpplib.h: Update prototypes.\n\t(cpp_printer): New.\n\t(cpp_buffer): Remove last_nominal_fname.\n\t(cpp_reader): Remove lineno.\n\n\t* cppmain.c: Use a cpp_printer.\n\t* fix-header.c: No need to inhibit line commands.  Call\n\tcpp_start_read with no printer.\n\n\t* cpperror.c (cpp_notice_from_errno): Provide default name.\n\t* cppfiles.c (make_IHASH, _cpp_fake_ihash): New functions.\n\t(find_include_file, cpp_read_file): Use make_IHASH.\n\t(file_cleanup): Set control_macro and clear\n\tinput_stack_listing_current here.\n\t(_cpp_execute_include): Don't output entering-file marker.\n\t* cpphash.c (special_symbol): Look for the line number in the\n\tbuffer, not the reader.\n\t(_cpp_macroexpand): No need to disable line commands.\n\t(_cpp_dump_definition): No need to generate line commands.\n\t(dump_hash_helper): Remove excess newline from output.\n\t* cppinit.c (dump_special_to_buffer): No need to generate line\n\tcommands.\n\t(cpp_printer_init): New.\n\t(cpp_start_read): Take a printer, and start it up if it's not\n\tNULL.  No need to generate line commands.\n\t(cpp_finish): Expect no buffers stacked at all.  Take a\n\tprinter argument, and flush the output buffer if it's not\n\tNULL.\n\t* cpplex.c (_cpp_lex_token): Return EOF if there's no buffer.\n\tDon't put two hashes at the beginning of an assertion.\n\t(cpp_get_token): Don't increment pfile->lineno or emit line\n\tcommands here.  Return EOF if there's no buffer when we get\n\tEOF.\n\t* cpplib.c (do_define, skip_if_group):\n\tNo need to disable line commands.\n\t(_cpp_output_line_command): Delete function.\n\t(do_line): Don't emit line commands here, but set things up so\n\tthey will be emitted if necessary.  Use _cpp_fake_ihash to\n\tmake unique nominal_fnames if necessary.\n\t(do_elif, do_else, _cpp_handle_eof): Call cpp_error_with_line\n\twith 0 for column, not -1.\n\t(_cpp_handle_eof): Don't set the control macro here.  Don't\n\tclear input_stack_listing_current here.  Don't emit line\n\tcommands.\n\nFrom-SVN: r33159", "tree": {"sha": "c91bee0467728e26a3ab2b06fce2d27db8e99983", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c91bee0467728e26a3ab2b06fce2d27db8e99983"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f2d5f0cca244fc70acb45fbe557bd22411175f1b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2d5f0cca244fc70acb45fbe557bd22411175f1b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2d5f0cca244fc70acb45fbe557bd22411175f1b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2d5f0cca244fc70acb45fbe557bd22411175f1b/comments", "author": null, "committer": null, "parents": [{"sha": "362c63a5e8b5aacfff3e5af0911e42ba7c775042", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/362c63a5e8b5aacfff3e5af0911e42ba7c775042", "html_url": "https://github.com/Rust-GCC/gccrs/commit/362c63a5e8b5aacfff3e5af0911e42ba7c775042"}], "stats": {"total": 816, "additions": 450, "deletions": 366}, "files": [{"sha": "11e30c7968b73efdf0247a8bf687240db96a11b1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2d5f0cca244fc70acb45fbe557bd22411175f1b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2d5f0cca244fc70acb45fbe557bd22411175f1b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f2d5f0cca244fc70acb45fbe557bd22411175f1b", "patch": "@@ -1,3 +1,57 @@\n+2000-04-14  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\t* cpplex.c (cpp_output_tokens, cpp_scan_buffer_nooutput): New public\n+\tinterfaces.\n+\t(safe_fwrite, output_line_command): New static functions.\n+\t(cpp_expand_to_buffer): Now private to cpplib.\n+\t(cpp_scan_buffer): Take a printer.\n+\n+\t* cpphash.h: Update prototypes.\n+\t* cpplib.h: Update prototypes.\n+\t(cpp_printer): New.\n+\t(cpp_buffer): Remove last_nominal_fname.\n+\t(cpp_reader): Remove lineno.\n+\n+\t* cppmain.c: Use a cpp_printer.\n+\t* fix-header.c: No need to inhibit line commands.  Call\n+\tcpp_start_read with no printer.\n+\n+\t* cpperror.c (cpp_notice_from_errno): Provide default name.\n+\t* cppfiles.c (make_IHASH, _cpp_fake_ihash): New functions.\n+\t(find_include_file, cpp_read_file): Use make_IHASH.\n+\t(file_cleanup): Set control_macro and clear\n+\tinput_stack_listing_current here.\n+\t(_cpp_execute_include): Don't output entering-file marker.\n+\t* cpphash.c (special_symbol): Look for the line number in the\n+\tbuffer, not the reader.\n+\t(_cpp_macroexpand): No need to disable line commands.\n+\t(_cpp_dump_definition): No need to generate line commands.\n+\t(dump_hash_helper): Remove excess newline from output.\n+\t* cppinit.c (dump_special_to_buffer): No need to generate line\n+\tcommands.\n+\t(cpp_printer_init): New.\n+\t(cpp_start_read): Take a printer, and start it up if it's not\n+\tNULL.  No need to generate line commands.\n+\t(cpp_finish): Expect no buffers stacked at all.  Take a\n+\tprinter argument, and flush the output buffer if it's not\n+\tNULL.\n+\t* cpplex.c (_cpp_lex_token): Return EOF if there's no buffer.\n+\tDon't put two hashes at the beginning of an assertion.\n+\t(cpp_get_token): Don't increment pfile->lineno or emit line\n+\tcommands here.  Return EOF if there's no buffer when we get\n+\tEOF.\n+\t* cpplib.c (do_define, skip_if_group): \n+\tNo need to disable line commands.\n+\t(_cpp_output_line_command): Delete function.\n+\t(do_line): Don't emit line commands here, but set things up so\n+\tthey will be emitted if necessary.  Use _cpp_fake_ihash to\n+\tmake unique nominal_fnames if necessary.\n+\t(do_elif, do_else, _cpp_handle_eof): Call cpp_error_with_line\n+\twith 0 for column, not -1.\n+\t(_cpp_handle_eof): Don't set the control macro here.  Don't\n+\tclear input_stack_listing_current here.  Don't emit line\n+\tcommands.\n+\n 2000-04-14  Geoff Keating  <geoffk@cygnus.com>\n \n \t* config/rs6000/sysv4.h (LINK_START_SOLARIS_SPEC): Define to empty"}, {"sha": "0e8afc4ffa9a7fe1277cb7fc5caa254cf91bce30", "filename": "gcc/cpperror.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2d5f0cca244fc70acb45fbe557bd22411175f1b/gcc%2Fcpperror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2d5f0cca244fc70acb45fbe557bd22411175f1b/gcc%2Fcpperror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpperror.c?ref=f2d5f0cca244fc70acb45fbe557bd22411175f1b", "patch": "@@ -440,5 +440,7 @@ cpp_notice_from_errno (pfile, name)\n      cpp_reader *pfile;\n      const char *name;\n {\n+  if (name[0] == '\\0')\n+    name = \"stdout\";\n   cpp_notice (pfile, \"%s: %s\", name, xstrerror (errno));\n }"}, {"sha": "59ee7c76f0361e4c5d3479d42c1a7ea69bcd769d", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 74, "deletions": 44, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2d5f0cca244fc70acb45fbe557bd22411175f1b/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2d5f0cca244fc70acb45fbe557bd22411175f1b/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=f2d5f0cca244fc70acb45fbe557bd22411175f1b", "patch": "@@ -34,6 +34,9 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n \n static IHASH *redundant_include_p PARAMS ((cpp_reader *, IHASH *,\n \t\t\t\t\t   struct file_name_list *));\n+static IHASH *make_IHASH\tPARAMS ((const char *, const char *,\n+\t\t\t\t\t struct file_name_list *,\n+\t\t\t\t\t unsigned int, IHASH **));\n static struct file_name_map *read_name_map\n \t\t\t\tPARAMS ((cpp_reader *, const char *));\n static char *read_filename_string PARAMS ((int, FILE *));\n@@ -154,6 +157,46 @@ cpp_included (pfile, fname)\n   return (ptr != NULL);\n }\n \n+/* Create an IHASH entry and insert it in SLOT.  */\n+static IHASH *\n+make_IHASH (name, fname, path, hash, slot)\n+     const char *name, *fname;\n+     struct file_name_list *path;\n+     unsigned int hash;\n+     IHASH **slot;\n+{\n+  IHASH *ih;\n+  if (path == ABSOLUTE_PATH)\n+    {\n+      ih = (IHASH *) xmalloc (sizeof (IHASH) + strlen (name));\n+      ih->nshort = ih->name;\n+    }\n+  else\n+    {\n+      char *s;\n+      \n+      if ((s = strstr (name, fname)) != NULL)\n+\t{\n+\t  ih = (IHASH *) xmalloc (sizeof (IHASH) + strlen (name));\n+\t  ih->nshort = ih->name + (s - name);\n+\t}\n+      else\n+\t{\n+\t  ih = (IHASH *) xmalloc (sizeof (IHASH) + strlen (name)\n+\t\t\t\t  + strlen (fname) + 1);\n+\t  ih->nshort = ih->name + strlen (name) + 1;\n+\t  strcpy ((char *)ih->nshort, fname);\n+\t}\n+    }\n+  strcpy ((char *)ih->name, name);\n+  ih->foundhere = path;\n+  ih->control_macro = NULL;\n+  ih->hash = hash;\n+  ih->next_this_file = *slot;\n+  *slot = ih;\n+  return ih;\n+}\n+\n static int\n file_cleanup (pbuf, pfile)\n      cpp_buffer *pbuf;\n@@ -163,6 +206,12 @@ file_cleanup (pbuf, pfile)\n     free ((PTR) pbuf->buf);\n   if (pfile->system_include_depth)\n     pfile->system_include_depth--;\n+  if (pfile->potential_control_macro)\n+    {\n+      pbuf->ihash->control_macro = pfile->potential_control_macro;\n+      pfile->potential_control_macro = 0;\n+    }\n+  pfile->input_stack_listing_current = 0;\n   return 0;\n }\n \n@@ -265,41 +314,34 @@ find_include_file (pfile, fname, search_start, ihash, before)\n   if (f == -1)\n     return -1;\n \n-  if (path == ABSOLUTE_PATH)\n-    {\n-      ih = (IHASH *) xmalloc (sizeof (IHASH) + strlen (name));\n-      ih->nshort = ih->name;\n-    }\n-  else\n-    {\n-      char *s;\n-      \n-      if ((s = strstr (name, fname)) != NULL)\n-\t{\n-\t  ih = (IHASH *) xmalloc (sizeof (IHASH) + strlen (name));\n-\t  ih->nshort = ih->name + (s - name);\n-\t}\n-      else\n-\t{\n-\t  ih = (IHASH *) xmalloc (sizeof (IHASH) + strlen (name)\n-\t\t\t\t  + strlen (fname) + 1);\n-\t  ih->nshort = ih->name + strlen (name) + 1;\n-\t  strcpy ((char *)ih->nshort, fname);\n-\t}\n-    }\n-  strcpy ((char *)ih->name, name);\n-  ih->foundhere = path;\n-  ih->control_macro = NULL;\n-  ih->hash = dummy.hash;\n-\n-  ih->next_this_file = *slot;\n-  *slot = ih;\n-\n+  ih = make_IHASH (name, fname, path, dummy.hash, slot);\n   *before = 0;\n   *ihash = ih;\n   return f;\n }\n \n+/* Create a dummy IHASH entry for FNAME, and return its name pointer.\n+   This is used by #line.  */\n+const char *\n+_cpp_fake_ihash (pfile, fname)\n+     cpp_reader *pfile;\n+     const char *fname;\n+{\n+  IHASH *ih, **slot;\n+  IHASH dummy;\n+\n+  dummy.nshort = fname;\n+  dummy.hash = _cpp_calc_hash (fname, strlen (fname));\n+  slot = (IHASH **) htab_find_slot_with_hash (pfile->all_include_files,\n+\t\t\t\t\t      (const void *)&dummy,\n+\t\t\t\t\t      dummy.hash, 1);\n+  if (*slot)\n+    return (*slot)->name;\n+  ih = make_IHASH (fname, 0, ABSOLUTE_PATH, dummy.hash, slot);\n+  return ih->name;\n+}\n+\n+\n /* The file_name_map structure holds a mapping of file names for a\n    particular directory.  This mapping is read from the file named\n    FILE_NAME_MAP_FILE in that directory.  Such a file can be used to\n@@ -594,14 +636,12 @@ _cpp_execute_include (pfile, fname, len, no_reinclude, search_start)\n       fprintf (stderr, \" %s\\n\", ihash->name);\n     }\n \n-  /* Actually process the file */\n-\n+  /* Actually process the file.  */\n   if (no_reinclude)\n     ihash->control_macro = (const U_CHAR *) \"\";\n   \n   if (read_include_file (pfile, fd, ihash))\n     {\n-      _cpp_output_line_command (pfile, enter_file);\n       if (angle_brackets)\n \tpfile->system_include_depth++;   /* Decremented in file_cleanup. */\n     }\n@@ -637,17 +677,7 @@ cpp_read_file (pfile, fname)\n \treturn 1;  /* Already included.  */\n     }\n   else\n-    {\n-      ih = (IHASH *) xmalloc (sizeof (IHASH) + strlen (fname));\n-      ih->control_macro = 0;\n-      ih->foundhere = ABSOLUTE_PATH;  /* well sort of ... */\n-      ih->hash = dummy.hash;\n-      strcpy ((char *)ih->name, fname);\n-      ih->nshort = ih->name;\n-\n-      ih->next_this_file = *slot;\n-      *slot = ih;\n-    }\n+    ih = make_IHASH (fname, 0, ABSOLUTE_PATH, dummy.hash, slot);\n \n   if (*fname == '\\0')\n     f = 0;"}, {"sha": "bead2140c062e10671c58b61b8800871ff8fb192", "filename": "gcc/cpphash.c", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2d5f0cca244fc70acb45fbe557bd22411175f1b/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2d5f0cca244fc70acb45fbe557bd22411175f1b/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=f2d5f0cca244fc70acb45fbe557bd22411175f1b", "patch": "@@ -911,7 +911,7 @@ special_symbol (hp, pfile)\n     case T_SPECLINE:\n       ip = cpp_file_buffer (pfile);\n       CPP_RESERVE (pfile, 10);\n-      sprintf (CPP_PWRITTEN (pfile), \"%u\", CPP_BUF_LINE (pfile));\n+      sprintf (CPP_PWRITTEN (pfile), \"%u\", CPP_BUF_LINE (ip));\n       CPP_ADJUST_WRITTEN (pfile, strlen (CPP_PWRITTEN (pfile)));\n       return;\n \n@@ -1025,7 +1025,6 @@ _cpp_macroexpand (pfile, hp)\n \n       /* Skip over the opening parenthesis.  */\n       CPP_OPTION (pfile, discard_comments)++;\n-      CPP_OPTION (pfile, no_line_commands)++;\n       pfile->no_macro_expand++;\n       pfile->no_directives++;\n \n@@ -1058,7 +1057,6 @@ _cpp_macroexpand (pfile, hp)\n \t}\n       while (token == CPP_COMMA);\n       CPP_OPTION (pfile, discard_comments)--;\n-      CPP_OPTION (pfile, no_line_commands)--;\n       pfile->no_macro_expand--;\n       pfile->no_directives--;\n       if (token != CPP_RPAREN)\n@@ -1221,9 +1219,9 @@ _cpp_macroexpand (pfile, hp)\n \t      if (args[ap->argno].expand_length < 0)\n \t\t{\n \t\t  args[ap->argno].expanded = CPP_WRITTEN (pfile);\n-\t\t  cpp_expand_to_buffer (pfile,\n-\t\t\t\t\tARG_BASE + args[ap->argno].raw,\n-\t\t\t\t\targs[ap->argno].raw_length);\n+\t\t  _cpp_expand_to_buffer (pfile,\n+\t\t\t\t\t ARG_BASE + args[ap->argno].raw,\n+\t\t\t\t\t args[ap->argno].raw_length);\n \n \t\t  args[ap->argno].expand_length\n \t\t    = CPP_WRITTEN (pfile) - args[ap->argno].expanded;\n@@ -1611,9 +1609,6 @@ _cpp_dump_definition (pfile, sym, len, defn)\n      long len;\n      DEFINITION *defn;\n {\n-  if (pfile->lineno == 0)\n-    _cpp_output_line_command (pfile, same_file);\n-\n   CPP_RESERVE (pfile, len + sizeof \"#define \");\n   CPP_PUTS_Q (pfile, \"#define \", sizeof \"#define \" -1);\n   CPP_PUTS_Q (pfile, sym, len);\n@@ -1691,7 +1686,7 @@ _cpp_dump_definition (pfile, sym, len, defn)\n       if (*x == '\\r') x += 2, i -= 2;\n       if (i > 0) CPP_PUTS (pfile, x, i);\n     }\n-  if (pfile->lineno == 0)\n+  if (CPP_BUFFER (pfile) == 0 || ! pfile->done_initializing)\n     CPP_PUTC (pfile, '\\n');\n   CPP_NUL_TERMINATE (pfile);\n }\n@@ -1706,10 +1701,7 @@ dump_hash_helper (h, p)\n   cpp_reader *pfile = (cpp_reader *)p;\n \n   if (hp->type == T_MACRO)\n-    {\n-      _cpp_dump_definition (pfile, hp->name, hp->length, hp->value.defn);\n-      CPP_PUTC (pfile, '\\n');\n-    }\n+    _cpp_dump_definition (pfile, hp->name, hp->length, hp->value.defn);\n   return 1;\n }\n "}, {"sha": "99e45fb0c7162be16b9e7648b2280f60eeec3a33", "filename": "gcc/cpphash.h", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2d5f0cca244fc70acb45fbe557bd22411175f1b/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2d5f0cca244fc70acb45fbe557bd22411175f1b/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=f2d5f0cca244fc70acb45fbe557bd22411175f1b", "patch": "@@ -263,9 +263,6 @@ extern unsigned char _cpp_IStable[256];\n #define ADJACENT_TO_MARK(PFILE) \\\n  (CPP_BUFFER(PFILE)->cur - CPP_BUFFER(PFILE)->mark == 1)\n \n-/* Last arg to output_line_command.  */\n-enum file_change_code {same_file, rename_file, enter_file, leave_file};\n-\n /* In cpphash.c */\n extern HASHNODE *_cpp_make_hashnode\tPARAMS ((const U_CHAR *, size_t,\n \t\t\t\t\t\t enum node_type,\n@@ -293,6 +290,7 @@ extern void _cpp_execute_include\tPARAMS ((cpp_reader *, char *,\n \t\t\t\t\t\t unsigned int, int,\n \t\t\t\t\t\t struct file_name_list *));\n extern void _cpp_init_include_hash\tPARAMS ((cpp_reader *));\n+extern const char *_cpp_fake_ihash\tPARAMS ((cpp_reader *, const char *));\n \n /* In cppexp.c */\n extern int _cpp_parse_expr\t\tPARAMS ((cpp_reader *));\n@@ -301,6 +299,8 @@ extern int _cpp_parse_expr\t\tPARAMS ((cpp_reader *));\n extern void _cpp_parse_name\t\tPARAMS ((cpp_reader *, int));\n extern void _cpp_skip_rest_of_line\tPARAMS ((cpp_reader *));\n extern void _cpp_skip_hspace\t\tPARAMS ((cpp_reader *));\n+extern void _cpp_expand_to_buffer\tPARAMS ((cpp_reader *,\n+\t\t\t\t\t\t const unsigned char *, int));\n extern int _cpp_parse_assertion\t\tPARAMS ((cpp_reader *));\n extern enum cpp_ttype _cpp_lex_token\tPARAMS ((cpp_reader *));\n extern long _cpp_read_and_prescan\tPARAMS ((cpp_reader *, cpp_buffer *,\n@@ -315,8 +315,5 @@ extern enum cpp_ttype _cpp_get_define_token\n /* In cpplib.c */\n extern int _cpp_handle_directive\tPARAMS ((cpp_reader *));\n extern void _cpp_handle_eof\t\tPARAMS ((cpp_reader *));\n-extern void _cpp_output_line_command\tPARAMS ((cpp_reader *,\n-\t\t\t\t\t\t enum file_change_code));\n-\n \n #endif"}, {"sha": "5174da8d5bfe7b1edbdd46ea7c28c885f6dcb755", "filename": "gcc/cppinit.c", "status": "modified", "additions": 59, "deletions": 25, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2d5f0cca244fc70acb45fbe557bd22411175f1b/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2d5f0cca244fc70acb45fbe557bd22411175f1b/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=f2d5f0cca244fc70acb45fbe557bd22411175f1b", "patch": "@@ -521,12 +521,11 @@ dump_special_to_buffer (pfile, macro_name)\n {\n   static const char define_directive[] = \"#define \";\n   int macro_name_length = strlen (macro_name);\n-  _cpp_output_line_command (pfile, same_file);\n   CPP_RESERVE (pfile, sizeof(define_directive) + macro_name_length);\n   CPP_PUTS_Q (pfile, define_directive, sizeof(define_directive)-1);\n   CPP_PUTS_Q (pfile, macro_name, macro_name_length);\n   CPP_PUTC_Q (pfile, ' ');\n-  cpp_expand_to_buffer (pfile, macro_name, macro_name_length);\n+  _cpp_expand_to_buffer (pfile, macro_name, macro_name_length);\n   CPP_PUTC (pfile, '\\n');\n }\n \n@@ -554,6 +553,31 @@ cpp_reader_init (pfile)\n   _cpp_init_include_hash (pfile);\n }\n \n+/* Initialize a cpp_printer structure.  As a side effect, open the\n+   output file.  */\n+cpp_printer *\n+cpp_printer_init (pfile, print)\n+     cpp_reader *pfile;\n+     cpp_printer *print;\n+{\n+  memset (print, '\\0', sizeof (cpp_printer));\n+  if (CPP_OPTION (pfile, out_fname) == NULL)\n+    CPP_OPTION (pfile, out_fname) = \"\";\n+  \n+  if (CPP_OPTION (pfile, out_fname)[0] == '\\0')\n+    print->outf = stdout;\n+  else\n+    {\n+      print->outf = fopen (CPP_OPTION (pfile, out_fname), \"w\");\n+      if (! print->outf)\n+\t{\n+\t  cpp_notice_from_errno (pfile, CPP_OPTION (pfile, out_fname));\n+\t  return NULL;\n+\t}\n+    }\n+  return print;\n+}\n+\n /* Free resources used by PFILE.\n    This is the cpp_reader 'finalizer' or 'destructor' (in C++ terminology).  */\n void\n@@ -829,8 +853,9 @@ initialize_standard_includes (pfile)\n  */\n \n int\n-cpp_start_read (pfile, fname)\n+cpp_start_read (pfile, print, fname)\n      cpp_reader *pfile;\n+     cpp_printer *print;\n      const char *fname;\n {\n   struct pending_option *p, *q;\n@@ -915,6 +940,14 @@ cpp_start_read (pfile, fname)\n \n   CPP_BUFFER (pfile)->lineno = 0;\n \n+  if (print)\n+    {\n+      print->lineno = 0;\n+      print->last_fname = CPP_BUFFER (pfile)->nominal_fname;\n+      print->last_bsd = pfile->buffer_stack_depth;\n+      print->written = CPP_WRITTEN (pfile);\n+    }\n+\n   /* Install __LINE__, etc.  */\n   initialize_builtins (pfile);\n \n@@ -927,42 +960,32 @@ cpp_start_read (pfile, fname)\n       free (p);\n       p = q;\n     }\n-\n   pfile->done_initializing = 1;\n-  CPP_BUFFER (pfile)->lineno = 1;\n-\n-  if (CPP_OPTION (pfile, preprocessed))\n-    /* If we've already processed this code, we want to trust the #line\n-       directives in the input.  But we still need to update our line\n-       counter accordingly.  */\n-    pfile->lineno = CPP_BUFFER (pfile)->lineno;\n-  else\n-    _cpp_output_line_command (pfile, same_file);\n   pfile->only_seen_white = 2;\n+  CPP_BUFFER (pfile)->lineno = 1;\n+  if (print && ! CPP_OPTION (pfile, no_output))\n+    cpp_output_tokens (pfile, print);\n \n   /* The -imacros files can be scanned now, but the -include files\n      have to be pushed onto the include stack and processed later,\n      in the main loop calling cpp_get_token.  */\n \n-  CPP_OPTION (pfile, no_output)++;\n   p = CPP_OPTION (pfile, pending)->imacros_head;\n   while (p)\n     {\n       if (cpp_read_file (pfile, p->arg))\n-\tcpp_scan_buffer (pfile);\n-\n+\tcpp_scan_buffer_nooutput (pfile);\n       q = p->next;\n       free (p);\n       p = q;\n     }\n-  CPP_OPTION (pfile, no_output)--;\n \n   p = CPP_OPTION (pfile, pending)->include_head;\n   while (p)\n     {\n-      if (cpp_read_file (pfile, p->arg))\n-\t_cpp_output_line_command (pfile, enter_file);\n-\n+      if (cpp_read_file (pfile, p->arg)\n+\t  && print && ! CPP_OPTION (pfile, no_output))\n+\tcpp_output_tokens (pfile, print);\n       q = p->next;\n       free (p);\n       p = q;\n@@ -979,13 +1002,16 @@ cpp_start_read (pfile, fname)\n    clear macro definitions, such that you could call cpp_start_read\n    with a new filename to restart processing. */\n void\n-cpp_finish (pfile)\n+cpp_finish (pfile, print)\n      cpp_reader *pfile;\n+     cpp_printer *print;\n {\n-  if (CPP_PREV_BUFFER (CPP_BUFFER (pfile)))\n-    cpp_ice (pfile, \"buffers still stacked in cpp_finish\");\n-  while (CPP_BUFFER (pfile))\n-    cpp_pop_buffer (pfile);\n+  if (CPP_BUFFER (pfile))\n+    {\n+      cpp_ice (pfile, \"buffers still stacked in cpp_finish\");\n+      while (CPP_BUFFER (pfile))\n+\tcpp_pop_buffer (pfile);\n+    }\n \n   /* Don't write the deps file if preprocessing has failed.  */\n   if (CPP_OPTION (pfile, print_deps) && pfile->errors == 0)\n@@ -1015,6 +1041,14 @@ cpp_finish (pfile)\n \n   if (CPP_OPTION (pfile, dump_macros) == dump_only)\n     _cpp_dump_macro_hash (pfile);\n+\n+  /* Flush any pending output.  */\n+  if (print)\n+    {\n+      cpp_output_tokens (pfile, print);\n+      if (ferror (print->outf) || fclose (print->outf))\n+\tcpp_notice_from_errno (pfile, CPP_OPTION (pfile, out_fname));\n+    }\n }\n \n static void"}, {"sha": "08133595a71265360ffdf84708038a8bb4c14eb5", "filename": "gcc/cpplex.c", "status": "modified", "additions": 189, "deletions": 68, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2d5f0cca244fc70acb45fbe557bd22411175f1b/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2d5f0cca244fc70acb45fbe557bd22411175f1b/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=f2d5f0cca244fc70acb45fbe557bd22411175f1b", "patch": "@@ -47,6 +47,10 @@ static U_CHAR *find_position\tPARAMS ((U_CHAR *, U_CHAR *, unsigned long *));\n static int null_cleanup\t\tPARAMS ((cpp_buffer *, cpp_reader *));\n static void null_warning        PARAMS ((cpp_reader *, unsigned int));\n \n+static void safe_fwrite\t\tPARAMS ((cpp_reader *, const U_CHAR *,\n+\t\t\t\t\t size_t, FILE *));\n+static void output_line_command\tPARAMS ((cpp_reader *, cpp_printer *));\n+\n /* Re-allocates PFILE->token_buffer so it will hold at least N more chars.  */\n \n void\n@@ -116,70 +120,131 @@ cpp_pop_buffer (pfile)\n   return CPP_BUFFER (pfile);\n }\n \n-/* Scan until CPP_BUFFER (PFILE) is exhausted into PFILE->token_buffer.\n-   Pop the buffer when done.  */\n+/* Deal with the annoying semantics of fwrite.  */\n+static void\n+safe_fwrite (pfile, buf, len, fp)\n+     cpp_reader *pfile;\n+     const U_CHAR *buf;\n+     size_t len;\n+     FILE *fp;\n+{\n+  size_t count;\n \n-void\n-cpp_scan_buffer (pfile)\n+  while (len)\n+    {\n+      count = fwrite (buf, 1, len, fp);\n+      if (count == 0)\n+\tgoto error;\n+      len -= count;\n+      buf += count;\n+    }\n+  return;\n+\n+ error:\n+  cpp_notice_from_errno (pfile, CPP_OPTION (pfile, out_fname));\n+}\n+\n+/* Notify the compiler proper that the current line number has jumped,\n+   or the current file name has changed.  */\n+\n+static void\n+output_line_command (pfile, print)\n      cpp_reader *pfile;\n+     cpp_printer *print;\n {\n-  cpp_buffer *buffer = CPP_BUFFER (pfile);\n-  enum cpp_ttype token;\n-  if (CPP_OPTION (pfile, no_output))\n+  unsigned int line;\n+  cpp_buffer *ip;\n+  enum { same = 0, enter, leave, rname } change;\n+  static const char * const codes[] = { \"\", \" 1\", \" 2\", \"\" };\n+\n+  if (CPP_OPTION (pfile, no_line_commands))\n+    return;\n+\n+  ip = cpp_file_buffer (pfile);\n+  if (ip == NULL)\n+    return;\n+  line = CPP_BUF_LINE (ip);\n+\n+  //  fprintf (print->outf, \"[%u %u\", print->lineno, line);\n+\n+  /* Determine whether the current filename has changed, and if so,\n+     how.  'nominal_fname' values are unique, so they can be compared\n+     by comparing pointers.  */\n+  if (ip->nominal_fname == print->last_fname)\n+    change = same;\n+  else\n     {\n-      long old_written = CPP_WRITTEN (pfile);\n-      /* In no-output mode, we can ignore everything but directives.  */\n-      for (;;)\n+      if (pfile->buffer_stack_depth == print->last_bsd)\n+\tchange = rname;\n+      else\n \t{\n-\t  if (! pfile->only_seen_white)\n-\t    _cpp_skip_rest_of_line (pfile);\n-\t  token = cpp_get_token (pfile);\n-\t  if (token == CPP_EOF) /* Should not happen ...  */\n-\t    break;\n-\t  if (token == CPP_POP && CPP_BUFFER (pfile) == buffer)\n-\t    {\n-\t      if (CPP_PREV_BUFFER (CPP_BUFFER (pfile)) != NULL)\n-\t\tcpp_pop_buffer (pfile);\n-\t      break;\n-\t    }\n+\t  if (pfile->buffer_stack_depth > print->last_bsd)\n+\t    change = enter;\n+\t  else\n+\t    change = leave;\n+\t  print->last_bsd = pfile->buffer_stack_depth;\n \t}\n-      CPP_SET_WRITTEN (pfile, old_written);\n+      print->last_fname = ip->nominal_fname;\n     }\n-  else\n+  /* If the current file has not changed, we can output a few newlines\n+     instead if we want to increase the line number by a small amount.\n+     We cannot do this if print->lineno is zero, because that means we\n+     haven't output any line commands yet.  (The very first line\n+     command output is a `same_file' command.)  */\n+  if (change == same && print->lineno != 0\n+      && line >= print->lineno && line < print->lineno + 8)\n     {\n-      for (;;)\n+      while (line > print->lineno)\n \t{\n-\t  token = cpp_get_token (pfile);\n-\t  if (token == CPP_EOF) /* Should not happen ...  */\n-\t    break;\n-\t  if (token == CPP_POP && CPP_BUFFER (pfile) == buffer)\n-\t    {\n-\t      if (CPP_PREV_BUFFER (CPP_BUFFER (pfile)) != NULL)\n-\t\tcpp_pop_buffer (pfile);\n-\t      break;\n-\t    }\n+\t  putc ('\\n', print->outf);\n+\t  print->lineno++;\n \t}\n+      //      putc(']', print->outf);\n+      return;\n     }\n+\n+#ifndef NO_IMPLICIT_EXTERN_C\n+  if (CPP_OPTION (pfile, cplusplus))\n+    fprintf (print->outf, \"# %u \\\"%s\\\"%s%s%s\\n\", line, ip->nominal_fname,\n+\t     codes[change],\n+\t     ip->system_header_p ? \" 3\" : \"\",\n+\t     (ip->system_header_p == 2) ? \" 4\" : \"\");\n+  else\n+#endif\n+    fprintf (print->outf, \"# %u \\\"%s\\\"%s%s\\n\", line, ip->nominal_fname,\n+\t     codes[change],\n+\t     ip->system_header_p ? \" 3\" : \"\");\n+  print->lineno = line;\n+}\n+\n+/* Write the contents of the token_buffer to the output stream, and\n+   clear the token_buffer.  Also handles generating line commands and\n+   keeping track of file transitions.  */\n+\n+void\n+cpp_output_tokens (pfile, print)\n+     cpp_reader *pfile;\n+     cpp_printer *print;\n+{\n+  if (CPP_PWRITTEN (pfile)[-1] == '\\n' && print->lineno)\n+    print->lineno++;\n+  safe_fwrite (pfile, pfile->token_buffer,\n+\t       CPP_WRITTEN (pfile) - print->written, print->outf);\n+  output_line_command (pfile, print);\n+  CPP_SET_WRITTEN (pfile, print->written);\n }\n \n-/*\n- * Rescan a string (which may have escape marks) into pfile's buffer.\n- * Place the result in pfile->token_buffer.\n- *\n- * The input is copied before it is scanned, so it is safe to pass\n- * it something from the token_buffer that will get overwritten\n- * (because it follows CPP_WRITTEN).  This is used by do_include.\n- */\n+/* Scan a string (which may have escape marks), perform macro expansion,\n+   and write the result to the token_buffer.  */\n \n void\n-cpp_expand_to_buffer (pfile, buf, length)\n+_cpp_expand_to_buffer (pfile, buf, length)\n      cpp_reader *pfile;\n      const U_CHAR *buf;\n      int length;\n {\n-  register cpp_buffer *ip;\n-  U_CHAR *buf1;\n-  int save_no_output;\n+  cpp_buffer *ip;\n+  enum cpp_ttype token;\n \n   if (length < 0)\n     {\n@@ -188,27 +253,85 @@ cpp_expand_to_buffer (pfile, buf, length)\n     }\n \n   /* Set up the input on the input stack.  */\n-\n-  buf1 = (U_CHAR *) alloca (length + 1);\n-  memcpy (buf1, buf, length);\n-  buf1[length] = 0;\n-\n-  ip = cpp_push_buffer (pfile, buf1, length);\n+  ip = cpp_push_buffer (pfile, buf, length);\n   if (ip == NULL)\n     return;\n   ip->has_escapes = 1;\n \n   /* Scan the input, create the output.  */\n-  save_no_output = CPP_OPTION (pfile, no_output);\n-  CPP_OPTION (pfile, no_output) = 0;\n-  CPP_OPTION (pfile, no_line_commands)++;\n-  cpp_scan_buffer (pfile);\n-  CPP_OPTION (pfile, no_line_commands)--;\n-  CPP_OPTION (pfile, no_output) = save_no_output;\n-\n+  for (;;)\n+    {\n+      token = cpp_get_token (pfile);\n+      if (token == CPP_EOF)\n+\tbreak;\n+      if (token == CPP_POP && CPP_BUFFER (pfile) == ip)\n+\t{\n+\t  cpp_pop_buffer (pfile);\n+\t  break;\n+\t}\n+    }\n   CPP_NUL_TERMINATE (pfile);\n }\n \n+/* Scan until CPP_BUFFER (PFILE) is exhausted, discarding output.\n+   Then pop the buffer.  */\n+\n+void\n+cpp_scan_buffer_nooutput (pfile)\n+     cpp_reader *pfile;\n+{\n+  cpp_buffer *buffer = CPP_BUFFER (pfile);\n+  enum cpp_ttype token;\n+  unsigned int old_written = CPP_WRITTEN (pfile);\n+  /* In no-output mode, we can ignore everything but directives.  */\n+  for (;;)\n+    {\n+      if (! pfile->only_seen_white)\n+\t_cpp_skip_rest_of_line (pfile);\n+      token = cpp_get_token (pfile);\n+      if (token == CPP_EOF)\n+\tbreak;\n+      if (token == CPP_POP && CPP_BUFFER (pfile) == buffer)\n+\t{\n+\t  cpp_pop_buffer (pfile);\n+\t  break;\n+\t}\n+    }\n+  CPP_SET_WRITTEN (pfile, old_written);\n+}\n+\n+/* Scan until CPP_BUFFER (pfile) is exhausted, writing output to PRINT.\n+   Then pop the buffer.  */\n+\n+void\n+cpp_scan_buffer (pfile, print)\n+     cpp_reader *pfile;\n+     cpp_printer *print;\n+{\n+  cpp_buffer *buffer = CPP_BUFFER (pfile);\n+  enum cpp_ttype token;\n+\n+  for (;;)\n+    {\n+      token = cpp_get_token (pfile);\n+      if ((token == CPP_POP && !CPP_IS_MACRO_BUFFER (CPP_BUFFER (pfile)))\n+\t  || token == CPP_EOF || token == CPP_VSPACE\n+\t  /* XXX Temporary kluge - force flush after #include only */\n+\t  || (token == CPP_DIRECTIVE\n+\t      && CPP_BUFFER (pfile)->nominal_fname != print->last_fname))\n+\t{\n+\t  cpp_output_tokens (pfile, print);\n+\t  if (token == CPP_EOF)\n+\t    return;\n+\t  if (token == CPP_POP && CPP_BUFFER (pfile) == buffer)\n+\t    {\n+\t      cpp_pop_buffer (pfile);\n+\t      return;\n+\t    }\n+\t}\n+    }\n+}\n+\n /* Return the topmost cpp_buffer that corresponds to a file (not a macro).  */\n \n cpp_buffer *\n@@ -706,6 +829,9 @@ _cpp_lex_token (pfile)\n   register int c, c2;\n   enum cpp_ttype token;\n \n+  if (CPP_BUFFER (pfile) == NULL)\n+    return CPP_EOF;\n+\n  get_next:\n   c = GETC();\n   switch (c)\n@@ -749,6 +875,7 @@ _cpp_lex_token (pfile)\n     hash:\n       if (pfile->parsing_if_directive)\n \t{\n+\t  CPP_ADJUST_WRITTEN (pfile, -1);\n \t  if (_cpp_parse_assertion (pfile))\n \t    return CPP_ASSERTION;\n \t  return CPP_OTHER;\n@@ -1227,12 +1354,6 @@ cpp_get_token (pfile)\n       if (pfile->only_seen_white == 0)\n \tpfile->only_seen_white = 1;\n       CPP_BUMP_LINE (pfile);\n-      if (! CPP_OPTION (pfile, no_line_commands))\n-\t{\n-\t  pfile->lineno++;\n-\t  if (CPP_BUFFER (pfile)->lineno != pfile->lineno)\n-\t    _cpp_output_line_command (pfile, same_file);\n-\t}\n       return token;\n \n     case CPP_HSPACE:\n@@ -1256,15 +1377,15 @@ cpp_get_token (pfile)\n       return CPP_NAME;\n \n     case CPP_EOF:\n+      if (CPP_BUFFER (pfile) == NULL)\n+\treturn CPP_EOF;\n       if (CPP_BUFFER (pfile)->manual_pop)\n \t/* If we've been reading from redirected input, the\n \t   frontend will pop the buffer.  */\n \treturn CPP_EOF;\n-      else if (CPP_BUFFER (pfile)->seen_eof)\n-\t{\n-\t  if (CPP_PREV_BUFFER (CPP_BUFFER (pfile)) == NULL)\n-\t    return CPP_EOF;\n \n+      if (CPP_BUFFER (pfile)->seen_eof)\n+\t{\n \t  cpp_pop_buffer (pfile);\n \t  goto get_next;\n \t}"}, {"sha": "3549bed8f740550259d429524965e1e05f60131c", "filename": "gcc/cpplib.c", "status": "modified", "additions": 13, "deletions": 133, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2d5f0cca244fc70acb45fbe557bd22411175f1b/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2d5f0cca244fc70acb45fbe557bd22411175f1b/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=f2d5f0cca244fc70acb45fbe557bd22411175f1b", "patch": "@@ -352,7 +352,6 @@ do_define (pfile)\n   pfile->no_macro_expand++;\n   pfile->parsing_define_directive++;\n   CPP_OPTION (pfile, discard_comments)++;\n-  CPP_OPTION (pfile, no_line_commands)++;\n \n   here = CPP_WRITTEN (pfile);\n   len = get_macro_name (pfile);\n@@ -453,85 +452,9 @@ do_define (pfile)\n   pfile->no_macro_expand--;\n   pfile->parsing_define_directive--;\n   CPP_OPTION (pfile, discard_comments)--;\n-  CPP_OPTION (pfile, no_line_commands)--;\n   return 0;\n }\n \n-/*\n- * write out a #line command, for instance, after an #include file.\n- * FILE_CHANGE says whether we are entering a file, leaving, or neither.\n- */\n-\n-void\n-_cpp_output_line_command (pfile, file_change)\n-     cpp_reader *pfile;\n-     enum file_change_code file_change;\n-{\n-  unsigned int line;\n-  cpp_buffer *ip;\n-\n-  if (CPP_OPTION (pfile, no_line_commands)\n-      || CPP_OPTION (pfile, no_output))\n-    return;\n-\n-  ip = cpp_file_buffer (pfile);\n-  line = ip->lineno;\n-\n-  /* If the current file has not changed, we omit the #line if it would\n-     appear to be a no-op, and we output a few newlines instead\n-     if we want to increase the line number by a small amount.\n-     We cannot do this if pfile->lineno is zero, because that means we\n-     haven't output any line commands yet.  (The very first line command\n-     output is a `same_file' command.)  */\n-  if (file_change == same_file && pfile->lineno != 0)\n-    {\n-      if (line == pfile->lineno)\n-\treturn;\n-\n-      /* If the inherited line number is a little too small,\n-\t output some newlines instead of a #line command.  */\n-      if (line > pfile->lineno && line < pfile->lineno + 8)\n-\t{\n-\t  CPP_RESERVE (pfile, 20);\n-\t  while (line > pfile->lineno)\n-\t    {\n-\t      CPP_PUTC_Q (pfile, '\\n');\n-\t      pfile->lineno++;\n-\t    }\n-\t  return;\n-\t}\n-    }\n-\n-  CPP_RESERVE (pfile, 4 * strlen (ip->nominal_fname) + 50);\n-  CPP_PUTS_Q (pfile, \"# \", 2);\n-\n-  sprintf ((char *) CPP_PWRITTEN (pfile), \"%u \", line);\n-  CPP_ADJUST_WRITTEN (pfile, strlen (CPP_PWRITTEN (pfile)));\n-\n-  _cpp_quote_string (pfile, ip->nominal_fname); \n-  if (file_change != same_file && file_change != rename_file)\n-    {\n-      CPP_PUTC_Q (pfile, ' ');\n-      CPP_PUTC_Q (pfile, file_change == enter_file ? '1' : '2');\n-    }\n-  /* Tell cc1 if following text comes from a system header file.  */\n-  if (ip->system_header_p)\n-    {\n-      CPP_PUTC_Q (pfile, ' ');\n-      CPP_PUTC_Q (pfile, '3');\n-    }\n-#ifndef NO_IMPLICIT_EXTERN_C\n-  /* Tell cc1plus if following text should be treated as C.  */\n-  if (ip->system_header_p == 2 && CPP_OPTION (pfile, cplusplus))\n-    {\n-      CPP_PUTC_Q (pfile, ' ');\n-      CPP_PUTC_Q (pfile, '4');\n-    }\n-#endif\n-  CPP_PUTC_Q (pfile, '\\n');\n-  pfile->lineno = line;\n-}\n-\n /* Handle #include and #import.  */\n \n static unsigned int\n@@ -713,9 +636,8 @@ do_line (pfile)\n      cpp_reader *pfile;\n {\n   cpp_buffer *ip = CPP_BUFFER (pfile);\n-  int new_lineno;\n+  unsigned int new_lineno;\n   long old_written = CPP_WRITTEN (pfile);\n-  enum file_change_code file_change = same_file;\n   enum cpp_ttype token;\n   char *x;\n \n@@ -727,7 +649,7 @@ do_line (pfile)\n       goto bad_line_directive;\n     }\n \n-  new_lineno = strtol (pfile->token_buffer + old_written, &x, 10);\n+  new_lineno = strtoul (pfile->token_buffer + old_written, &x, 10);\n   if (x[0] != '\\0')\n     {\n       cpp_error (pfile, \"token after `#line' is not an integer\");\n@@ -746,21 +668,22 @@ do_line (pfile)\n       U_CHAR *end_name = CPP_PWRITTEN (pfile) - 1;\n       int action_number = 0;\n \n-      file_change = rename_file;\n-\n       if (read_line_number (pfile, &action_number))\n \t{\n \t  if (CPP_PEDANTIC (pfile))\n \t    cpp_pedwarn (pfile, \"garbage at end of `#line' command\");\n \n+\t  /* This is somewhat questionable: change the buffer stack\n+\t     depth so that output_line_command thinks we've stacked\n+\t     another buffer. */\n \t  if (action_number == 1)\n \t    {\n-\t      file_change = enter_file;\n+\t      pfile->buffer_stack_depth++;\n \t      read_line_number (pfile, &action_number);\n \t    }\n \t  else if (action_number == 2)\n \t    {\n-\t      file_change = leave_file;\n+\t      pfile->buffer_stack_depth--;\n \t      read_line_number (pfile, &action_number);\n \t    }\n \t  if (action_number == 3)\n@@ -779,29 +702,11 @@ do_line (pfile)\n       \n       if (strcmp (fname, ip->nominal_fname))\n \t{\n-\t  const char *newname, *oldname;\n \t  if (!strcmp (fname, ip->ihash->name))\n-\t    newname = ip->ihash->name;\n-\t  else if (ip->last_nominal_fname\n-\t\t   && !strcmp (fname, ip->last_nominal_fname))\n-\t    newname = ip->last_nominal_fname;\n+\t    ip->nominal_fname = ip->ihash->name;\n \t  else\n-\t    newname = xstrdup (fname);\n-\n-\t  oldname = ip->nominal_fname;\n-\t  ip->nominal_fname = newname;\n-\n-\t  if (ip->last_nominal_fname\n-\t      && ip->last_nominal_fname != oldname\n-\t      && ip->last_nominal_fname != newname\n-\t      && ip->last_nominal_fname != ip->ihash->name)\n-\t    free ((void *) ip->last_nominal_fname);\n-\n-\t  if (newname == ip->ihash->name)\n-\t    ip->last_nominal_fname = NULL;\n-\t  else\n-\t    ip->last_nominal_fname = oldname;\n-\t} \n+\t    ip->nominal_fname = _cpp_fake_ihash (pfile, fname);\n+\t}\n     }\n   else if (token != CPP_VSPACE && token != CPP_EOF)\n     {\n@@ -814,7 +719,6 @@ do_line (pfile)\n      we must store a line number now that is one less.  */\n   ip->lineno = new_lineno - 1;\n   CPP_SET_WRITTEN (pfile, old_written);\n-  _cpp_output_line_command (pfile, file_change);\n   return 0;\n \n  bad_line_directive:\n@@ -1259,7 +1163,7 @@ do_elif (pfile)\n       if (pfile->if_stack->type == T_ELSE)\n \t{\n \t  cpp_error (pfile, \"`#elif' after `#else'\");\n-\t  cpp_error_with_line (pfile, pfile->if_stack->lineno, -1,\n+\t  cpp_error_with_line (pfile, pfile->if_stack->lineno, 0,\n \t\t\t       \"the conditional began here\");\n \t}\n       pfile->if_stack->type = T_ELIF;\n@@ -1506,15 +1410,13 @@ skip_if_group (pfile)\n \n   old_written = CPP_WRITTEN (pfile);\n   pfile->no_macro_expand++;\n-  CPP_OPTION (pfile, no_line_commands)++;\n   for (;;)\n     {\n       /* We are at the end of a line.  Only cpp_get_token knows how to\n \t advance the line number correctly.  */\n       token = cpp_get_token (pfile);\n       if (token == CPP_POP)\n \tbreak;  /* Caller will issue error.  */\n-      \n       else if (token != CPP_VSPACE)\n \tcpp_ice (pfile, \"cpp_get_token returned %d in skip_if_group\", token);\n       CPP_SET_WRITTEN (pfile, old_written);\n@@ -1533,7 +1435,6 @@ skip_if_group (pfile)\n     }\n   CPP_SET_WRITTEN (pfile, old_written);\n   pfile->no_macro_expand--;\n-  CPP_OPTION (pfile, no_line_commands)--;\n   return ret;\n }\n \n@@ -1565,7 +1466,7 @@ do_else (pfile)\n       if (pfile->if_stack->type == T_ELSE)\n \t{\n \t  cpp_error (pfile, \"`#else' after `#else'\");\n-\t  cpp_error_with_line (pfile, pfile->if_stack->lineno, -1,\n+\t  cpp_error_with_line (pfile, pfile->if_stack->lineno, 0,\n \t\t\t       \"the conditional began here\");\n \t}\n       pfile->if_stack->type = T_ELSE;\n@@ -1628,42 +1529,21 @@ void\n _cpp_handle_eof (pfile)\n      cpp_reader *pfile;\n {\n-  cpp_buffer *next_buf = CPP_PREV_BUFFER (CPP_BUFFER (pfile));\n   struct if_stack *ifs, *nifs;\n \n   /* Unwind the conditional stack and generate error messages.  */\n   for (ifs = pfile->if_stack;\n        ifs != CPP_BUFFER (pfile)->if_stack;\n        ifs = nifs)\n     {\n-      cpp_error_with_line (pfile, ifs->lineno, -1,\n+      cpp_error_with_line (pfile, ifs->lineno, 0,\n \t\t\t   \"unterminated `#%s' conditional\",\n \t\t\t   dtable[ifs->type].name);\n \n       nifs = ifs->next;\n       free (ifs);\n     }\n   pfile->if_stack = ifs;\n-\n-  if (pfile->potential_control_macro)\n-    {\n-      CPP_BUFFER (pfile)->ihash->control_macro\n-\t= pfile->potential_control_macro;\n-      pfile->potential_control_macro = 0;\n-    }\n-\n-  if (CPP_BUFFER (pfile)->nominal_fname && next_buf != NULL)\n-    {\n-      /* We're about to return from an #include file.\n-\t Emit #line information now (as part of the CPP_POP) result.\n-\t But the #line refers to the file we will pop to.  */\n-      cpp_buffer *cur_buffer = CPP_BUFFER (pfile);\n-      CPP_BUFFER (pfile) = next_buf;\n-      pfile->input_stack_listing_current = 0;\n-      _cpp_output_line_command (pfile, leave_file);\n-      CPP_BUFFER (pfile) = cur_buffer;\n-    }\n-\n   CPP_BUFFER (pfile)->seen_eof = 1;\n }\n "}, {"sha": "366196d686a58ef50fbcd4b30ec3b4ea5a22b9b4", "filename": "gcc/cpplib.h", "status": "modified", "additions": 33, "deletions": 17, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2d5f0cca244fc70acb45fbe557bd22411175f1b/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2d5f0cca244fc70acb45fbe557bd22411175f1b/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=f2d5f0cca244fc70acb45fbe557bd22411175f1b", "patch": "@@ -31,6 +31,7 @@ extern \"C\" {\n typedef struct cpp_reader cpp_reader;\n typedef struct cpp_buffer cpp_buffer;\n typedef struct cpp_options cpp_options;\n+typedef struct cpp_printer cpp_printer;\n \n enum cpp_ttype\n {\n@@ -74,8 +75,6 @@ struct cpp_buffer\n \n   /* Filename specified with #line command.  */\n   const char *nominal_fname;\n-  /* Last filename specified with #line command.  */\n-  const char *last_nominal_fname;\n   /* Actual directory of this file, used only for \"\" includes */\n   struct file_name_list *actual_dir;\n \n@@ -98,6 +97,8 @@ struct cpp_buffer\n \n   /* True if this is a header file included using <FILENAME>.  */\n   char system_header_p;\n+\n+  /* True if end-of-file has already been hit once in this buffer.  */\n   char seen_eof;\n \n   /* True if buffer contains escape sequences.\n@@ -352,8 +353,6 @@ struct cpp_reader\n   struct if_stack *if_stack;\n   const unsigned char *potential_control_macro;\n \n-  unsigned int lineno;\n-\n   /* Buffer of -M output.  */\n   struct deps *deps;\n \n@@ -402,6 +401,19 @@ struct cpp_reader\n   unsigned char done_initializing;\n };\n \n+/* struct cpp_printer encapsulates state used to convert the stream of\n+   tokens coming from cpp_get_token back into a text file.  Not\n+   everyone wants to do that, hence we separate the function.  */\n+\n+struct cpp_printer\n+{\n+  FILE *outf;\t\t\t/* stream to write to */\n+  const char *last_fname;\t/* previous file name */\n+  unsigned int last_bsd;\t/* did we just push? */\n+  unsigned int lineno;\t\t/* line currently being written */\n+  unsigned int written;\t\t/* low water mark in token buffer */\n+};\n+\n #define CPP_FATAL_LIMIT 1000\n /* True if we have seen a \"fatal\" error. */\n #define CPP_FATAL_ERRORS(READER) ((READER)->errors >= CPP_FATAL_LIMIT)\n@@ -427,9 +439,11 @@ extern enum cpp_ttype cpp_get_token PARAMS ((cpp_reader *));\n extern enum cpp_ttype cpp_get_non_space_token PARAMS ((cpp_reader *));\n \n extern void cpp_reader_init PARAMS ((cpp_reader *));\n-extern int cpp_start_read PARAMS ((cpp_reader *, const char *));\n-extern void cpp_finish PARAMS ((cpp_reader *));\n-extern void cpp_cleanup PARAMS ((cpp_reader *PFILE));\n+extern cpp_printer *cpp_printer_init PARAMS ((cpp_reader *, cpp_printer *));\n+extern int cpp_start_read PARAMS ((cpp_reader *, cpp_printer *, const char *));\n+extern void cpp_output_tokens PARAMS ((cpp_reader *, cpp_printer *));\n+extern void cpp_finish PARAMS ((cpp_reader *, cpp_printer *));\n+extern void cpp_cleanup PARAMS ((cpp_reader *));\n \n extern cpp_buffer *cpp_file_buffer PARAMS((cpp_reader *));\n extern void cpp_define PARAMS ((cpp_reader *, const char *));\n@@ -463,17 +477,19 @@ extern void cpp_pedwarn_with_line PARAMS ((cpp_reader *, int, int, const char *m\n   ATTRIBUTE_PRINTF_4;\n extern void cpp_pedwarn_with_file_and_line PARAMS ((cpp_reader *, const char *, int, int, const char *msgid, ...))\n   ATTRIBUTE_PRINTF_5;\n-extern void cpp_error_from_errno PARAMS ((cpp_reader *, const char *));\n-extern void cpp_notice_from_errno PARAMS ((cpp_reader *, const char *));\n-\n-extern cpp_buffer *cpp_push_buffer PARAMS ((cpp_reader *,\n-\t\t\t\t\t    const unsigned char *, long));\n-extern cpp_buffer *cpp_pop_buffer PARAMS ((cpp_reader *));\n-extern int cpp_defined PARAMS ((cpp_reader *, const unsigned char *, int));\n-\n-extern void cpp_expand_to_buffer\tPARAMS ((cpp_reader *,\n+extern void cpp_error_from_errno\tPARAMS ((cpp_reader *, const char *));\n+extern void cpp_notice_from_errno\tPARAMS ((cpp_reader *, const char *));\n+\n+/* In cpplex.c */\n+extern cpp_buffer *cpp_push_buffer\tPARAMS ((cpp_reader *,\n+\t\t\t\t\t\t const unsigned char *, long));\n+extern cpp_buffer *cpp_pop_buffer\tPARAMS ((cpp_reader *));\n+extern void cpp_scan_buffer\t\tPARAMS ((cpp_reader *, cpp_printer *));\n+extern void cpp_scan_buffer_nooutput\tPARAMS ((cpp_reader *));\n+\n+/* In cpphash.c */\n+extern int cpp_defined\t\t\tPARAMS ((cpp_reader *,\n \t\t\t\t\t\t const unsigned char *, int));\n-extern void cpp_scan_buffer\t\tPARAMS ((cpp_reader *));\n \n /* In cppfiles.c */\n extern int cpp_included\t\t\tPARAMS ((cpp_reader *, const char *));"}, {"sha": "ef636cbe02540a62b3f47dc09a41d9dbd900ff49", "filename": "gcc/cppmain.c", "status": "modified", "additions": 16, "deletions": 57, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2d5f0cca244fc70acb45fbe557bd22411175f1b/gcc%2Fcppmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2d5f0cca244fc70acb45fbe557bd22411175f1b/gcc%2Fcppmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmain.c?ref=f2d5f0cca244fc70acb45fbe557bd22411175f1b", "patch": "@@ -28,6 +28,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n const char *progname;\n \n cpp_reader parse_in;\n+cpp_printer parse_out;\n \n \f\n extern int main\t\t\t\tPARAMS ((int, char **));\n@@ -38,10 +39,8 @@ main (argc, argv)\n {\n   char *p;\n   cpp_reader *pfile = &parse_in;\n+  cpp_printer *print;\n   int argi = 1;  /* Next argument to handle.  */\n-  enum cpp_ttype kind;\n-  FILE *out;\n-  const char *out_fname;\n \n   p = argv[0] + strlen (argv[0]);\n   while (p != argv[0] && p[-1] != '/') --p;\n@@ -63,64 +62,24 @@ main (argc, argv)\n   if (CPP_FATAL_ERRORS (pfile))\n     return (FATAL_EXIT_CODE);\n \n-  if (! cpp_start_read (pfile, CPP_OPTION (pfile, in_fname)))\n+  /* Open the output now.  We must do so even if no_output is on,\n+     because there may be other output than from the actual\n+     preprocessing (e.g. from -dM).  */\n+  print = cpp_printer_init (pfile, &parse_out);\n+  if (! print)\n     return (FATAL_EXIT_CODE);\n \n-  /* Now that we know the input file is valid, open the output.  */\n-  out_fname = CPP_OPTION (pfile, out_fname);\n-  if (*out_fname == '\\0')\n-    {\n-      out_fname = \"stdout\";\n-      out = stdout;\n-    }\n-  else\n-    {\n-      out = fopen (out_fname, \"w\");\n-      if (!out)\n-\t{\n-\t  cpp_notice_from_errno (pfile, CPP_OPTION (pfile, out_fname));\n-\t  return (FATAL_EXIT_CODE);\n-\t}\n-    }\n-\n-  if (! CPP_OPTION (pfile, no_output))\n-    {\n-      do\n-\t{\n-\t  kind = cpp_get_token (pfile);\n-\t  if (CPP_WRITTEN (pfile) >= BUFSIZ || kind == CPP_EOF)\n-\t    {\n-\t      size_t rem, count = CPP_WRITTEN (pfile);\n-\n-\t      rem = fwrite (parse_in.token_buffer, 1, count, out);\n-\t      if (rem < count)\n-\t\t/* Write error. */\n-\t\tcpp_notice_from_errno (pfile, CPP_OPTION (pfile, out_fname));\n-\n-\t      CPP_SET_WRITTEN (pfile, 0);\n-\t    }\n-\t}\n-      while (kind != CPP_EOF);\n-    }\n+  if (! cpp_start_read (pfile, print, CPP_OPTION (pfile, in_fname)))\n+    return (FATAL_EXIT_CODE);\n+\n+  if (CPP_OPTION (pfile, no_output))\n+    while (CPP_BUFFER (pfile) != NULL)\n+      cpp_scan_buffer_nooutput (pfile);\n   else\n-    {\n-      do\n-\t{\n-\t  cpp_scan_buffer (pfile);\n-\t  kind = cpp_get_token (pfile);\n-\t}\n-      while (kind != CPP_EOF);\n-      CPP_SET_WRITTEN (pfile, 0);\n-    }\n-\n-  cpp_finish (pfile);\n-  if (fwrite (parse_in.token_buffer, 1, CPP_WRITTEN (pfile), out)\n-      < CPP_WRITTEN (pfile))\n-    cpp_notice_from_errno (pfile, CPP_OPTION (pfile, out_fname));\n-\n-  if (ferror (out) || fclose (out))\n-    cpp_notice_from_errno (pfile, CPP_OPTION (pfile, out_fname));\n+    while (CPP_BUFFER (pfile) != NULL)\n+      cpp_scan_buffer (pfile, print);\n \n+  cpp_finish (pfile, print);\n   cpp_cleanup (pfile);\n \n   if (parse_in.errors)"}, {"sha": "73e7bb6a6b7163e4a4b91c801f43dfe3d3b4d6d3", "filename": "gcc/fix-header.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2d5f0cca244fc70acb45fbe557bd22411175f1b/gcc%2Ffix-header.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2d5f0cca244fc70acb45fbe557bd22411175f1b/gcc%2Ffix-header.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffix-header.c?ref=f2d5f0cca244fc70acb45fbe557bd22411175f1b", "patch": "@@ -628,14 +628,13 @@ read_scan_file (in_fname, argc, argv)\n      so ignore warnings and errors.  */\n   CPP_OPTION (&scan_in, inhibit_warnings) = 1;\n   CPP_OPTION (&scan_in, inhibit_errors) = 1;\n-  CPP_OPTION (&scan_in, no_line_commands) = 1;\n   i = cpp_handle_options (&scan_in, argc, argv);\n   if (i < argc && ! CPP_FATAL_ERRORS (&scan_in))\n     cpp_fatal (&scan_in, \"Invalid option `%s'\", argv[i]);\n   if (CPP_FATAL_ERRORS (&scan_in))\n     exit (FATAL_EXIT_CODE);\n \n-  if (! cpp_start_read (&scan_in, in_fname))\n+  if (! cpp_start_read (&scan_in, 0, in_fname))\n     exit (FATAL_EXIT_CODE);\n \n   scan_decls (&scan_in, argc, argv);"}]}