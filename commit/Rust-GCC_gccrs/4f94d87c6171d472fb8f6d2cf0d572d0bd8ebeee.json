{"sha": "4f94d87c6171d472fb8f6d2cf0d572d0bd8ebeee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGY5NGQ4N2M2MTcxZDQ3MmZiOGY2ZDJjZjBkNTcyZDBiZDhlYmVlZQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2013-11-05T13:24:13Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2013-11-05T13:24:13Z"}, "message": "re PR middle-end/58941 (value modification on zero-length array optimized away)\n\n2013-11-05  Richard Biener  <rguenther@suse.de>\n\n\tPR middle-end/58941\n\t* tree-dfa.c (get_ref_base_and_extent): Merge common code\n\tin MEM_REF and TARGET_MEM_REF handling.  Make sure to\n\tprocess trailing array detection before diving into the\n\tview-converted object (and possibly apply some extra offset).\n\n\t* gcc.dg/torture/pr58941.c: New testcase.\n\nFrom-SVN: r204391", "tree": {"sha": "cae52e40ed9babcd4e8a4c09c518982dba93ab3b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cae52e40ed9babcd4e8a4c09c518982dba93ab3b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4f94d87c6171d472fb8f6d2cf0d572d0bd8ebeee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f94d87c6171d472fb8f6d2cf0d572d0bd8ebeee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f94d87c6171d472fb8f6d2cf0d572d0bd8ebeee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f94d87c6171d472fb8f6d2cf0d572d0bd8ebeee/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "254a0760a191f53494e0416dadf9607c71b1844f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/254a0760a191f53494e0416dadf9607c71b1844f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/254a0760a191f53494e0416dadf9607c71b1844f"}], "stats": {"total": 141, "additions": 88, "deletions": 53}, "files": [{"sha": "757eded9a1422eefa346e85b9dd556d1f5344056", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f94d87c6171d472fb8f6d2cf0d572d0bd8ebeee/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f94d87c6171d472fb8f6d2cf0d572d0bd8ebeee/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4f94d87c6171d472fb8f6d2cf0d572d0bd8ebeee", "patch": "@@ -1,3 +1,11 @@\n+2013-11-05  Richard Biener  <rguenther@suse.de>\n+\n+\tPR middle-end/58941\n+\t* tree-dfa.c (get_ref_base_and_extent): Merge common code\n+\tin MEM_REF and TARGET_MEM_REF handling.  Make sure to\n+\tprocess trailing array detection before diving into the\n+\tview-converted object (and possibly apply some extra offset).\n+\n 2013-11-05  Joseph Myers  <joseph@codesourcery.com>\n \n \t* config/i386/i386.c (ix86_float_exceptions_rounding_supported_p):"}, {"sha": "75abe6d1711525420a90d527d76ddc18c34dbc0f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f94d87c6171d472fb8f6d2cf0d572d0bd8ebeee/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f94d87c6171d472fb8f6d2cf0d572d0bd8ebeee/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4f94d87c6171d472fb8f6d2cf0d572d0bd8ebeee", "patch": "@@ -1,3 +1,8 @@\n+2013-11-05  Richard Biener  <rguenther@suse.de>\n+\n+\tPR middle-end/58941\n+\t* gcc.dg/torture/pr58941.c: New testcase.\n+\n 2013-11-05  Marc Glisse  <marc.glisse@inria.fr>\n \n \tPR tree-optimization/58958"}, {"sha": "c0eea073165cf3f9969a397894d90eec381caf4c", "filename": "gcc/testsuite/gcc.dg/torture/pr58941.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f94d87c6171d472fb8f6d2cf0d572d0bd8ebeee/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr58941.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f94d87c6171d472fb8f6d2cf0d572d0bd8ebeee/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr58941.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr58941.c?ref=4f94d87c6171d472fb8f6d2cf0d572d0bd8ebeee", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do run } */\n+\n+extern void abort (void);\n+\n+typedef struct {\n+    int msgLength;\n+    unsigned char data[1000];\n+} SMsg;\n+\n+typedef struct {\n+    int dummy;\n+    int d[0];\n+} SData;\n+\n+int condition = 3;\n+\n+int main()\n+{\n+  SMsg msg;\n+  SData *pData = (SData*)(msg.data);\n+  unsigned int i = 0;\n+  for (i = 0; i < 1; i++)\n+    {\n+      pData->d[i] = 0;\n+      if(condition & 1)\n+\tpData->d[i] |= 0x55;\n+      if(condition & 2)\n+\tpData->d[i] |= 0xaa;\n+    }\n+  if (pData->d[0] != 0xff)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "c8b257ea2903638c72f9e4e7ac8174eb8554f5da", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 42, "deletions": 53, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f94d87c6171d472fb8f6d2cf0d572d0bd8ebeee/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f94d87c6171d472fb8f6d2cf0d572d0bd8ebeee/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=4f94d87c6171d472fb8f6d2cf0d572d0bd8ebeee", "patch": "@@ -389,7 +389,6 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n   double_int bit_offset = double_int_zero;\n   HOST_WIDE_INT hbit_offset;\n   bool seen_variable_array_ref = false;\n-  tree base_type;\n \n   /* First get the final access size from just the outermost expression.  */\n   if (TREE_CODE (exp) == COMPONENT_REF)\n@@ -420,8 +419,6 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n      and find the ultimate containing object.  */\n   while (1)\n     {\n-      base_type = TREE_TYPE (exp);\n-\n       switch (TREE_CODE (exp))\n \t{\n \tcase BIT_FIELD_REF:\n@@ -544,42 +541,43 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n \tcase VIEW_CONVERT_EXPR:\n \t  break;\n \n+\tcase TARGET_MEM_REF:\n+\t  /* Via the variable index or index2 we can reach the\n+\t     whole object.  Still hand back the decl here.  */\n+\t  if (TREE_CODE (TMR_BASE (exp)) == ADDR_EXPR\n+\t      && (TMR_INDEX (exp) || TMR_INDEX2 (exp)))\n+\t    {\n+\t      exp = TREE_OPERAND (TMR_BASE (exp), 0);\n+\t      bit_offset = double_int_zero;\n+\t      maxsize = -1;\n+\t      goto done;\n+\t    }\n+\t  /* Fallthru.  */\n \tcase MEM_REF:\n+\t  /* We need to deal with variable arrays ending structures such as\n+\t     struct { int length; int a[1]; } x;           x.a[d]\n+\t     struct { struct { int a; int b; } a[1]; } x;  x.a[d].a\n+\t     struct { struct { int a[1]; } a[1]; } x;      x.a[0][d], x.a[d][0]\n+\t     struct { int len; union { int a[1]; struct X x; } u; } x; x.u.a[d]\n+\t     where we do not know maxsize for variable index accesses to\n+\t     the array.  The simplest way to conservatively deal with this\n+\t     is to punt in the case that offset + maxsize reaches the\n+\t     base type boundary.  This needs to include possible trailing\n+\t     padding that is there for alignment purposes.  */\n+\t  if (seen_variable_array_ref\n+\t      && maxsize != -1\n+\t      && (!bit_offset.fits_shwi ()\n+\t\t  || !host_integerp (TYPE_SIZE (TREE_TYPE (exp)), 1)\n+\t\t  || (bit_offset.to_shwi () + maxsize\n+\t\t      == (signed) TREE_INT_CST_LOW\n+\t\t            (TYPE_SIZE (TREE_TYPE (exp))))))\n+\t    maxsize = -1;\n+\n \t  /* Hand back the decl for MEM[&decl, off].  */\n \t  if (TREE_CODE (TREE_OPERAND (exp, 0)) == ADDR_EXPR)\n \t    {\n \t      if (integer_zerop (TREE_OPERAND (exp, 1)))\n \t\texp = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n-\t      else\n-\t\t{\n-\t\t  double_int off = mem_ref_offset (exp);\n-\t\t  off = off.lshift (BITS_PER_UNIT == 8\n-\t\t\t\t    ? 3 : exact_log2 (BITS_PER_UNIT));\n-\t\t  off = off + bit_offset;\n-\t\t  if (off.fits_shwi ())\n-\t\t    {\n-\t\t      bit_offset = off;\n-\t\t      exp = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n-\t\t    }\n-\t\t}\n-\t    }\n-\t  goto done;\n-\n-\tcase TARGET_MEM_REF:\n-\t  /* Hand back the decl for MEM[&decl, off].  */\n-\t  if (TREE_CODE (TMR_BASE (exp)) == ADDR_EXPR)\n-\t    {\n-\t      /* Via the variable index or index2 we can reach the\n-\t\t whole object.  */\n-\t      if (TMR_INDEX (exp) || TMR_INDEX2 (exp))\n-\t\t{\n-\t\t  exp = TREE_OPERAND (TMR_BASE (exp), 0);\n-\t\t  bit_offset = double_int_zero;\n-\t\t  maxsize = -1;\n-\t\t  goto done;\n-\t\t}\n-\t      if (integer_zerop (TMR_OFFSET (exp)))\n-\t\texp = TREE_OPERAND (TMR_BASE (exp), 0);\n \t      else\n \t\t{\n \t\t  double_int off = mem_ref_offset (exp);\n@@ -589,7 +587,7 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n \t\t  if (off.fits_shwi ())\n \t\t    {\n \t\t      bit_offset = off;\n-\t\t      exp = TREE_OPERAND (TMR_BASE (exp), 0);\n+\t\t      exp = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n \t\t    }\n \t\t}\n \t    }\n@@ -601,8 +599,17 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n \n       exp = TREE_OPERAND (exp, 0);\n     }\n- done:\n \n+  /* We need to deal with variable arrays ending structures.  */\n+  if (seen_variable_array_ref\n+      && maxsize != -1\n+      && (!bit_offset.fits_shwi ()\n+\t  || !host_integerp (TYPE_SIZE (TREE_TYPE (exp)), 1)\n+\t  || (bit_offset.to_shwi () + maxsize\n+\t      == (signed) TREE_INT_CST_LOW (TYPE_SIZE (TREE_TYPE (exp))))))\n+    maxsize = -1;\n+\n+ done:\n   if (!bit_offset.fits_shwi ())\n     {\n       *poffset = 0;\n@@ -614,24 +621,6 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n \n   hbit_offset = bit_offset.to_shwi ();\n \n-  /* We need to deal with variable arrays ending structures such as\n-       struct { int length; int a[1]; } x;           x.a[d]\n-       struct { struct { int a; int b; } a[1]; } x;  x.a[d].a\n-       struct { struct { int a[1]; } a[1]; } x;      x.a[0][d], x.a[d][0]\n-       struct { int len; union { int a[1]; struct X x; } u; } x; x.u.a[d]\n-     where we do not know maxsize for variable index accesses to\n-     the array.  The simplest way to conservatively deal with this\n-     is to punt in the case that offset + maxsize reaches the\n-     base type boundary.  This needs to include possible trailing padding\n-     that is there for alignment purposes.  */\n-\n-  if (seen_variable_array_ref\n-      && maxsize != -1\n-      && (!host_integerp (TYPE_SIZE (base_type), 1)\n-\t  || (hbit_offset + maxsize\n-\t      == (signed) TREE_INT_CST_LOW (TYPE_SIZE (base_type)))))\n-    maxsize = -1;\n-\n   /* In case of a decl or constant base object we can do better.  */\n \n   if (DECL_P (exp))"}]}