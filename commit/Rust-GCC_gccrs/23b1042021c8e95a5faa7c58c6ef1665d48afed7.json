{"sha": "23b1042021c8e95a5faa7c58c6ef1665d48afed7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjNiMTA0MjAyMWM4ZTk1YTVmYWE3YzU4YzZlZjE2NjVkNDhhZmVkNw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2010-07-15T07:50:04Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2010-07-15T07:50:04Z"}, "message": "trans.h (gfc_build_compare_string): Add CODE argument.\n\n\t* trans.h (gfc_build_compare_string): Add CODE argument.\n\t* trans-intrinsic.c (gfc_conv_intrinsic_strcmp): Pass OP to\n\tgfc_build_compare_string.\n\t* trans-expr.c (gfc_conv_expr_op): Pass CODE to\n\tgfc_build_compare_string.\n\t(string_to_single_character): Rename len variable to length.\n\t(gfc_optimize_len_trim): New function.\n\t(gfc_build_compare_string): Add CODE argument.  If it is EQ_EXPR\n\tor NE_EXPR and one of the strings is string literal with LEN_TRIM\n\tbigger than the length of the other string, they compare unequal.\n\nFrom-SVN: r162208", "tree": {"sha": "8dfb9081ba43c121a442439a830b02ebb771f680", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8dfb9081ba43c121a442439a830b02ebb771f680"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/23b1042021c8e95a5faa7c58c6ef1665d48afed7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23b1042021c8e95a5faa7c58c6ef1665d48afed7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23b1042021c8e95a5faa7c58c6ef1665d48afed7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23b1042021c8e95a5faa7c58c6ef1665d48afed7/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "53f00dde262894c19844a94404d7f7510f182e97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53f00dde262894c19844a94404d7f7510f182e97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/53f00dde262894c19844a94404d7f7510f182e97"}], "stats": {"total": 103, "additions": 81, "deletions": 22}, "files": [{"sha": "ea1a501b4976ea606afb432da61714b04b812eca", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23b1042021c8e95a5faa7c58c6ef1665d48afed7/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23b1042021c8e95a5faa7c58c6ef1665d48afed7/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=23b1042021c8e95a5faa7c58c6ef1665d48afed7", "patch": "@@ -1,3 +1,16 @@\n+2010-07-15  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* trans.h (gfc_build_compare_string): Add CODE argument.\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_strcmp): Pass OP to\n+\tgfc_build_compare_string.\n+\t* trans-expr.c (gfc_conv_expr_op): Pass CODE to\n+\tgfc_build_compare_string.\n+\t(string_to_single_character): Rename len variable to length.\n+\t(gfc_optimize_len_trim): New function.\n+\t(gfc_build_compare_string): Add CODE argument.  If it is EQ_EXPR\n+\tor NE_EXPR and one of the strings is string literal with LEN_TRIM\n+\tbigger than the length of the other string, they compare unequal.\n+\n 2010-07-14  Mikael Morin  <mikael@gcc.gnu.org>\n \n \t* trans-array.c (gfc_conv_section_upper_bound): Remove"}, {"sha": "02cc241802bac5ff60bab8825a74ee9a7e219e3b", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 65, "deletions": 20, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23b1042021c8e95a5faa7c58c6ef1665d48afed7/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23b1042021c8e95a5faa7c58c6ef1665d48afed7/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=23b1042021c8e95a5faa7c58c6ef1665d48afed7", "patch": "@@ -1365,7 +1365,8 @@ gfc_conv_expr_op (gfc_se * se, gfc_expr * expr)\n \n       lse.expr = gfc_build_compare_string (lse.string_length, lse.expr,\n \t\t\t\t\t   rse.string_length, rse.expr,\n-\t\t\t\t\t   expr->value.op.op1->ts.kind);\n+\t\t\t\t\t   expr->value.op.op1->ts.kind,\n+\t\t\t\t\t   code);\n       rse.expr = build_int_cst (TREE_TYPE (lse.expr), 0);\n       gfc_add_block_to_block (&lse.post, &rse.post);\n     }\n@@ -1418,10 +1419,10 @@ string_to_single_character (tree len, tree str, int kind)\n       if (TREE_CODE (ret) == INTEGER_CST)\n \t{\n \t  tree string_cst = TREE_OPERAND (TREE_OPERAND (str, 0), 0);\n-\t  int i, len = TREE_STRING_LENGTH (string_cst);\n+\t  int i, length = TREE_STRING_LENGTH (string_cst);\n \t  const char *ptr = TREE_STRING_POINTER (string_cst);\n \n-\t  for (i = 1; i < len; i++)\n+\t  for (i = 1; i < length; i++)\n \t    if (ptr[i] != ' ')\n \t      return NULL_TREE;\n \n@@ -1494,16 +1495,51 @@ gfc_conv_scalar_char_value (gfc_symbol *sym, gfc_se *se, gfc_expr **expr)\n     }\n }\n \n+/* Helper function for gfc_build_compare_string.  Return LEN_TRIM value\n+   if STR is a string literal, otherwise return -1.  */\n+\n+static int\n+gfc_optimize_len_trim (tree len, tree str, int kind)\n+{\n+  if (kind == 1\n+      && TREE_CODE (str) == ADDR_EXPR\n+      && TREE_CODE (TREE_OPERAND (str, 0)) == ARRAY_REF\n+      && TREE_CODE (TREE_OPERAND (TREE_OPERAND (str, 0), 0)) == STRING_CST\n+      && array_ref_low_bound (TREE_OPERAND (str, 0))\n+\t == TREE_OPERAND (TREE_OPERAND (str, 0), 1)\n+      && TREE_INT_CST_LOW (len) >= 1\n+      && TREE_INT_CST_LOW (len)\n+\t == (unsigned HOST_WIDE_INT)\n+\t    TREE_STRING_LENGTH (TREE_OPERAND (TREE_OPERAND (str, 0), 0)))\n+    {\n+      tree folded = fold_convert (gfc_get_pchar_type (kind), str);\n+      folded = build_fold_indirect_ref_loc (input_location, folded);\n+      if (TREE_CODE (folded) == INTEGER_CST)\n+\t{\n+\t  tree string_cst = TREE_OPERAND (TREE_OPERAND (str, 0), 0);\n+\t  int length = TREE_STRING_LENGTH (string_cst);\n+\t  const char *ptr = TREE_STRING_POINTER (string_cst);\n+\n+\t  for (; length > 0; length--)\n+\t    if (ptr[length - 1] != ' ')\n+\t      break;\n+\n+\t  return length;\n+\t}\n+    }\n+  return -1;\n+}\n \n /* Compare two strings. If they are all single characters, the result is the\n    subtraction of them. Otherwise, we build a library call.  */\n \n tree\n-gfc_build_compare_string (tree len1, tree str1, tree len2, tree str2, int kind)\n+gfc_build_compare_string (tree len1, tree str1, tree len2, tree str2, int kind,\n+\t\t\t  enum tree_code code)\n {\n   tree sc1;\n   tree sc2;\n-  tree tmp;\n+  tree fndecl;\n \n   gcc_assert (POINTER_TYPE_P (TREE_TYPE (str1)));\n   gcc_assert (POINTER_TYPE_P (TREE_TYPE (str2)));\n@@ -1516,25 +1552,34 @@ gfc_build_compare_string (tree len1, tree str1, tree len2, tree str2, int kind)\n       /* Deal with single character specially.  */\n       sc1 = fold_convert (integer_type_node, sc1);\n       sc2 = fold_convert (integer_type_node, sc2);\n-      tmp = fold_build2 (MINUS_EXPR, integer_type_node, sc1, sc2);\n+      return fold_build2 (MINUS_EXPR, integer_type_node, sc1, sc2);\n     }\n-  else\n-    {\n-      /* Build a call for the comparison.  */\n-      tree fndecl;\n \n-      if (kind == 1)\n-\tfndecl = gfor_fndecl_compare_string;\n-      else if (kind == 4)\n-\tfndecl = gfor_fndecl_compare_string_char4;\n-      else\n-\tgcc_unreachable ();\n-\n-      tmp = build_call_expr_loc (input_location,\n-\t\t\t     fndecl, 4, len1, str1, len2, str2);\n+  if ((code == EQ_EXPR || code == NE_EXPR)\n+      && optimize\n+      && INTEGER_CST_P (len1) && INTEGER_CST_P (len2))\n+    {\n+      /* If one string is a string literal with LEN_TRIM longer\n+\t than the length of the second string, the strings\n+\t compare unequal.  */\n+      int len = gfc_optimize_len_trim (len1, str1, kind);\n+      if (len > 0 && compare_tree_int (len2, len) < 0)\n+\treturn integer_one_node;\n+      len = gfc_optimize_len_trim (len2, str2, kind);\n+      if (len > 0 && compare_tree_int (len1, len) < 0)\n+\treturn integer_one_node;\n     }\n \n-  return tmp;\n+  /* Build a call for the comparison.  */\n+  if (kind == 1)\n+    fndecl = gfor_fndecl_compare_string;\n+  else if (kind == 4)\n+    fndecl = gfor_fndecl_compare_string_char4;\n+  else\n+    gcc_unreachable ();\n+\n+  return build_call_expr_loc (input_location, fndecl, 4,\n+\t\t\t      len1, str1, len2, str2);\n }\n \n "}, {"sha": "c277e8e6376f6c0b0f82ca95e9999fceac793a51", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23b1042021c8e95a5faa7c58c6ef1665d48afed7/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23b1042021c8e95a5faa7c58c6ef1665d48afed7/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=23b1042021c8e95a5faa7c58c6ef1665d48afed7", "patch": "@@ -3998,7 +3998,8 @@ gfc_conv_intrinsic_strcmp (gfc_se * se, gfc_expr * expr, enum tree_code op)\n \n   se->expr\n     = gfc_build_compare_string (args[0], args[1], args[2], args[3],\n-\t\t\t\texpr->value.function.actual->expr->ts.kind);\n+\t\t\t\texpr->value.function.actual->expr->ts.kind,\n+\t\t\t\top);\n   se->expr = fold_build2 (op, gfc_typenode_for_spec (&expr->ts), se->expr,\n \t\t\t  build_int_cst (TREE_TYPE (se->expr), 0));\n }"}, {"sha": "c30d3b826cf317355be9cf98cb2b36ade4410a95", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23b1042021c8e95a5faa7c58c6ef1665d48afed7/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23b1042021c8e95a5faa7c58c6ef1665d48afed7/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=23b1042021c8e95a5faa7c58c6ef1665d48afed7", "patch": "@@ -279,7 +279,7 @@ void gfc_make_safe_expr (gfc_se * se);\n void gfc_conv_string_parameter (gfc_se * se);\n \n /* Compare two strings.  */\n-tree gfc_build_compare_string (tree, tree, tree, tree, int);\n+tree gfc_build_compare_string (tree, tree, tree, tree, int, enum tree_code);\n \n /* Add an item to the end of TREE_LIST.  */\n tree gfc_chainon_list (tree, tree);"}]}