{"sha": "b9c83e7789f7eec9871e370739baa55fd70be4cf", "node_id": "C_kwDOANBUbNoAKGI5YzgzZTc3ODlmN2VlYzk4NzFlMzcwNzM5YmFhNTVmZDcwYmU0Y2Y", "commit": {"author": {"name": "Gaius Mulley", "email": "gaiusmod2@gmail.com", "date": "2023-02-19T22:08:31Z"}, "committer": {"name": "Gaius Mulley", "email": "gaiusmod2@gmail.com", "date": "2023-02-19T22:08:31Z"}, "message": "libgm2/libm2iso/RTco.cc (re-implementation) Bugfix for [PR108835]\n\nThis is a re-implementation of RTco.cc which fixes the race hazzard\nseen occasionally when running testtransfer and coroutines from the\nmodula2 testsuite.\n\nlibgm2/ChangeLog:\n\n\tPR testsuite/108835\n\t* libm2iso/RTco.cc: Re-implementation using a single lock\n\tmutex and inlined wait/signal implementation within\n\ttransfer.\n\nSigned-off-by: Gaius Mulley <gaiusmod2@gmail.com>", "tree": {"sha": "b0cd96e3d2e217c87732dd3186560d0857835d3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b0cd96e3d2e217c87732dd3186560d0857835d3c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b9c83e7789f7eec9871e370739baa55fd70be4cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9c83e7789f7eec9871e370739baa55fd70be4cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9c83e7789f7eec9871e370739baa55fd70be4cf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9c83e7789f7eec9871e370739baa55fd70be4cf/comments", "author": null, "committer": null, "parents": [{"sha": "0263e9d5d84b4abbb53e73fbc8d72fd233764fc8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0263e9d5d84b4abbb53e73fbc8d72fd233764fc8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0263e9d5d84b4abbb53e73fbc8d72fd233764fc8"}], "stats": {"total": 303, "additions": 176, "deletions": 127}, "files": [{"sha": "8b8a4dcea6dd153c4b9ea63964947b95d3f2d027", "filename": "libgm2/libm2iso/RTco.cc", "status": "modified", "additions": 176, "deletions": 127, "changes": 303, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9c83e7789f7eec9871e370739baa55fd70be4cf/libgm2%2Flibm2iso%2FRTco.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9c83e7789f7eec9871e370739baa55fd70be4cf/libgm2%2Flibm2iso%2FRTco.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgm2%2Flibm2iso%2FRTco.cc?ref=b9c83e7789f7eec9871e370739baa55fd70be4cf", "patch": "@@ -1,4 +1,4 @@\n-/* RTco.c provides minimal access to thread primitives.\n+/* RTco.cc provides minimal access to thread primitives.\n \n Copyright (C) 2019-2022 Free Software Foundation, Inc.\n Contributed by Gaius Mulley <gaius.mulley@southwales.ac.uk>.\n@@ -30,8 +30,19 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include <sys/select.h>\n #include <stdlib.h>\n #include <m2rts.h>\n+#include <cstdio>\n \n-// #define TRACEON\n+#define EXPORT(FUNC) RTco_ ## FUNC\n+#define M2EXPORT(FUNC) _M2_RTco_ ## FUNC\n+\n+/* This implementation of RTco.cc uses a single lock for mutex across\n+   the whole module.  It also forces context switching between threads\n+   in transfer by combining an implementation of wait and signal.\n+\n+   All semaphores are implemented using the same mutex lock and\n+   separate condition variables.  */\n+\n+#undef TRACEON\n \n #define POOL\n #define SEM_POOL 10000\n@@ -63,19 +74,22 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #define tprintf(...)\n #endif\n \n+\n typedef struct threadCB_s\n {\n   void (*proc) (void);\n-  int execution;\n   pthread_t p;\n-  int tid;\n+  int tid;   /* The thread id.  */\n   unsigned int interruptLevel;\n+  __gthread_cond_t run_counter;  /* Used to block the thread and force\n+\t\t\t\t    a context switch.  */\n+  int value;    /* Count 0 or 1.  */\n+  bool waiting; /* Is this thread waiting on the run_counter?  */\n } threadCB;\n \n \n typedef struct threadSem_s\n {\n-  __gthread_mutex_t mutex;\n   __gthread_cond_t counter;\n   int waiting;\n   int sem_value;\n@@ -87,25 +101,27 @@ static unsigned int nSemaphores = 0;\n static threadSem **semArray = NULL;\n \n /* These are used to lock the above module data structures.  */\n-static threadSem lock;\n+static __gthread_mutex_t lock;  /* This is the only mutex for\n+\t\t\t\t   the whole module.  */\n static int initialized = FALSE;\n+static int currentThread = 0;\n \n \n-extern \"C\" int RTco_init (void);\n+extern \"C\" int EXPORT(init) (void);\n \n \n extern \"C\" void\n-_M2_RTco_dep (void)\n+M2EXPORT(dep) (void)\n {\n }\n \n extern \"C\" void\n-_M2_RTco_init (int argc, char *argv[], char *envp[])\n+M2EXPORT(init) (int argc, char *argv[], char *envp[])\n {\n }\n \n extern \"C\" void\n-_M2_RTco_fini (int argc, char *argv[], char *envp[])\n+M2EXPORT(fini) (int argc, char *argv[], char *envp[])\n {\n }\n \n@@ -114,51 +130,48 @@ static void\n initSem (threadSem *sem, int value)\n {\n   __GTHREAD_COND_INIT_FUNCTION (&sem->counter);\n-  __GTHREAD_MUTEX_INIT_FUNCTION (&sem->mutex);\n   sem->waiting = FALSE;\n   sem->sem_value = value;\n }\n \n static void\n waitSem (threadSem *sem)\n {\n-  __gthread_mutex_lock (&sem->mutex);\n+  __gthread_mutex_lock (&lock);\n   if (sem->sem_value == 0)\n     {\n       sem->waiting = TRUE;\n-      __gthread_cond_wait (&sem->counter, &sem->mutex);\n+      __gthread_cond_wait (&sem->counter, &lock);\n       sem->waiting = FALSE;\n     }\n   else\n     sem->sem_value--;\n-  __gthread_mutex_unlock (&sem->mutex);\n+  __gthread_mutex_unlock (&lock);\n }\n \n static void\n signalSem (threadSem *sem)\n {\n-  __gthread_mutex_unlock (&sem->mutex);\n+  __gthread_mutex_lock (&lock);\n   if (sem->waiting)\n     __gthread_cond_signal (&sem->counter);\n   else\n     sem->sem_value++;\n-  __gthread_mutex_unlock (&sem->mutex);\n+  __gthread_mutex_unlock (&lock);\n }\n \n-void stop (void) {}\n-\n extern \"C\" void\n-RTco_wait (int sid)\n+EXPORT(wait) (int sid)\n {\n-  RTco_init ();\n+  EXPORT(init) ();\n   tprintf (\"wait %d\\n\", sid);\n   waitSem (semArray[sid]);\n }\n \n extern \"C\" void\n-RTco_signal (int sid)\n+EXPORT(signal) (int sid)\n {\n-  RTco_init ();\n+  EXPORT(init) ();\n   tprintf (\"signal %d\\n\", sid);\n   signalSem (semArray[sid]);\n }\n@@ -207,90 +220,58 @@ initSemaphore (int value)\n }\n \n extern \"C\" int\n-RTco_initSemaphore (int value)\n+EXPORT(initSemaphore) (int value)\n {\n   int sid;\n \n-  RTco_init ();\n-  waitSem (&lock);\n+  tprintf (\"initSemaphore (%d) called\\n\", value);\n+  EXPORT(init) ();\n+  tprintf (\"about to access lock\\n\");\n+  __gthread_mutex_lock (&lock);\n   sid = initSemaphore (value);\n-  signalSem (&lock);\n+  __gthread_mutex_unlock (&lock);\n   return sid;\n }\n \n-/* signalThread signal the semaphore associated with thread tid.  */\n-\n-extern \"C\" void\n-RTco_signalThread (int tid)\n-{\n-  int sem;\n-  RTco_init ();\n-  tprintf (\"signalThread %d\\n\", tid);\n-  waitSem (&lock);\n-  sem = threadArray[tid].execution;\n-  signalSem (&lock);\n-  RTco_signal (sem);\n-}\n-\n-/* waitThread wait on the semaphore associated with thread tid.  */\n-\n-extern \"C\" void\n-RTco_waitThread (int tid)\n-{\n-  RTco_init ();\n-  tprintf (\"waitThread %d\\n\", tid);\n-  RTco_wait (threadArray[tid].execution);\n-}\n-\n-extern \"C\" int\n-currentThread (void)\n-{\n-  int tid;\n-\n-  for (tid = 0; tid < nThreads; tid++)\n-    if (pthread_self () == threadArray[tid].p)\n-      return tid;\n-  M2RTS_HaltC (__FILE__, __LINE__, __FUNCTION__,\n-\t       \"failed to find currentThread\");\n-}\n-\n extern \"C\" int\n-RTco_currentThread (void)\n+EXPORT(currentThread) (void)\n {\n   int tid;\n \n-  RTco_init ();\n-  waitSem (&lock);\n-  tid = currentThread ();\n+  EXPORT(init) ();\n+  __gthread_mutex_lock (&lock);\n+  tid = currentThread;\n   tprintf (\"currentThread %d\\n\", tid);\n-  signalSem (&lock);\n+  __gthread_mutex_unlock (&lock);\n   return tid;\n }\n \n /* currentInterruptLevel returns the interrupt level of the current thread.  */\n \n extern \"C\" unsigned int\n-RTco_currentInterruptLevel (void)\n+EXPORT(currentInterruptLevel) (void)\n {\n-  RTco_init ();\n+  EXPORT(init) ();\n+  __gthread_mutex_lock (&lock);\n   tprintf (\"currentInterruptLevel %d\\n\",\n-           threadArray[RTco_currentThread ()].interruptLevel);\n-  return threadArray[RTco_currentThread ()].interruptLevel;\n+           threadArray[currentThread].interruptLevel);\n+  int level = threadArray[currentThread].interruptLevel;\n+  __gthread_mutex_unlock (&lock);\n+  return level;\n }\n \n /* turninterrupts returns the old interrupt level and assigns the\n    interrupt level to newLevel.  */\n \n extern \"C\" unsigned int\n-RTco_turnInterrupts (unsigned int newLevel)\n+EXPORT(turnInterrupts) (unsigned int newLevel)\n {\n-  int tid = RTco_currentThread ();\n-  unsigned int old = RTco_currentInterruptLevel ();\n-\n+  EXPORT(init) ();\n+  __gthread_mutex_lock (&lock);\n+  unsigned int old = threadArray[currentThread].interruptLevel;\n   tprintf (\"turnInterrupts from %d to %d\\n\", old, newLevel);\n-  waitSem (&lock);\n-  threadArray[tid].interruptLevel = newLevel;\n-  signalSem (&lock);\n+  threadArray[currentThread].interruptLevel = newLevel;\n+  __gthread_mutex_unlock (&lock);\n   return old;\n }\n \n@@ -306,12 +287,30 @@ execThread (void *t)\n {\n   threadCB *tp = (threadCB *)t;\n \n+  tprintf (\"exec thread tid = %d coming to life\\n\", tp->tid);\n+  __gthread_mutex_lock (&lock);\n   tprintf (\"exec thread tid = %d  function = 0x%p  arg = 0x%p\\n\", tp->tid,\n            tp->proc, t);\n-  RTco_waitThread (\n-      tp->tid); /* Forcing this thread to block, waiting to be scheduled.  */\n-  tprintf (\"  exec thread [%d]  function = 0x%p  arg = 0x%p\\n\", tp->tid,\n+  /* Has the thread been signalled?  */\n+  if (tp->value == 0)\n+    {\n+      /* Not been signalled therefore we force ourselves to block.  */\n+      tprintf (\"%s: forcing thread tid = %d to wait\\n\",\n+\t       __FUNCTION__, tp->tid);\n+      tp->waiting = true;  /* We are waiting.  */\n+      __gthread_cond_wait (&tp->run_counter, &lock);\n+      tp->waiting = false; /* Running again.  */\n+    }\n+  else\n+    {\n+      /* Yes signalled, therefore just take the recorded signal and continue.  */\n+      tprintf (\"%s: no need for thread tid = %d to wait\\n\",\n+\t       __FUNCTION__, tp->tid);\n+      tp->value--;\n+    }\n+  tprintf (\"  running exec thread [%d]  function = 0x%p  arg = 0x%p\\n\", tp->tid,\n            tp->proc, t);\n+  __gthread_mutex_unlock (&lock);\n   tp->proc (); /* Now execute user procedure.  */\n #if 0\n   M2RTS_CoroutineException ( __FILE__, __LINE__, __COLUMN__, __FUNCTION__, \"coroutine finishing\");\n@@ -356,21 +355,24 @@ initThread (void (*proc) (void), unsigned int stackSize,\n \n   threadArray[tid].proc = proc;\n   threadArray[tid].tid = tid;\n-  threadArray[tid].execution = initSemaphore (0);\n+  /* Initialize the thread run_counter used to force a context switch.  */\n+  __GTHREAD_COND_INIT_FUNCTION (&threadArray[tid].run_counter);\n   threadArray[tid].interruptLevel = interrupt;\n+  threadArray[tid].waiting = false;     /* The thread is running.  */\n+  threadArray[tid].value = 0;  /* No signal has been seen yet.  */\n \n-  /* set thread creation attributes.  */\n+  /* Set thread creation attributes.  */\n   result = pthread_attr_init (&attr);\n   if (result != 0)\n     M2RTS_HaltC (__FILE__, __LINE__, __FUNCTION__,\n-                \"failed to create thread attribute\");\n+\t\t \"failed to create thread attribute\");\n \n   if (stackSize > 0)\n     {\n       result = pthread_attr_setstacksize (&attr, stackSize);\n       if (result != 0)\n         M2RTS_HaltC (__FILE__, __LINE__, __FUNCTION__,\n-                    \"failed to set stack size attribute\");\n+\t\t     \"failed to set stack size attribute\");\n     }\n \n   tprintf (\"initThread [%d]  function = 0x%p  (arg = 0x%p)\\n\", tid, proc,\n@@ -385,85 +387,132 @@ initThread (void (*proc) (void), unsigned int stackSize,\n }\n \n extern \"C\" int\n-RTco_initThread (void (*proc) (void), unsigned int stackSize,\n-                 unsigned int interrupt)\n+EXPORT(initThread) (void (*proc) (void), unsigned int stackSize,\n+\t\t    unsigned int interrupt)\n {\n   int tid;\n \n-  RTco_init ();\n-  waitSem (&lock);\n+  EXPORT(init) ();\n+  __gthread_mutex_lock (&lock);\n   tid = initThread (proc, stackSize, interrupt);\n-  signalSem (&lock);\n+  __gthread_mutex_unlock (&lock);\n   return tid;\n }\n \n /* transfer unlocks thread p2 and locks the current thread.  p1 is\n-   updated with the current thread id.  */\n+   updated with the current thread id.\n+   The implementation of transfer uses a combined wait/signal.  */\n \n extern \"C\" void\n-RTco_transfer (int *p1, int p2)\n+EXPORT(transfer) (int *p1, int p2)\n {\n-  int tid = currentThread ();\n-\n-  if (!initialized)\n-    M2RTS_HaltC (\n-        __FILE__, __LINE__, __FUNCTION__,\n-        \"cannot transfer to a process before the process has been created\");\n-  if (tid == p2)\n-    {\n-      /* error.  */\n+  __gthread_mutex_lock (&lock);\n+  {\n+    if (!initialized)\n       M2RTS_HaltC (__FILE__, __LINE__, __FUNCTION__,\n-\t\t   \"attempting to transfer to ourself\");\n-    }\n-  else\n-    {\n-      *p1 = tid;\n-      tprintf (\"start, context switching from: %d to %d\\n\", tid, p2);\n-      RTco_signalThread (p2);\n-      RTco_waitThread (tid);\n-      tprintf (\"end, context back to %d\\n\", tid);\n+\t\t   \"cannot transfer to a process before the process has been created\");\n+    if (currentThread == p2)\n+      {\n+\t/* Error.  */\n+\tM2RTS_HaltC (__FILE__, __LINE__, __FUNCTION__,\n+\t\t     \"attempting to transfer to ourself\");\n     }\n+    else\n+      {\n+\t*p1 = currentThread;\n+\tint old = currentThread;\n+\ttprintf (\"start, context switching from: %d to %d\\n\", currentThread, p2);\n+\t/* Perform signal (p2 sem).  Without the mutex lock as we have\n+\t   already obtained it above.  */\n+\tif (threadArray[p2].waiting)\n+\t  {\n+\t    /* p2 is blocked on the condition variable, release it.  */\n+\t    tprintf (\"p1 = %d cond_signal to p2 (%d)\\n\", currentThread, p2);\n+\t  __gthread_cond_signal (&threadArray[p2].run_counter);\n+\t  tprintf (\"after p1 = %d cond_signal to p2 (%d)\\n\", currentThread, p2);\n+\t  }\n+\telse\n+\t  {\n+\t    /* p2 hasn't reached the condition variable, so bump value\n+\t       ready for p2 to test.  */\n+\t    tprintf (\"no need for thread %d to cond_signal - bump %d value (pre) = %d\\n\",\n+\t\t     currentThread, p2, threadArray[p2].value);\n+\t    threadArray[p2].value++;\n+\t  }\n+\t/* Perform wait (old sem).  Again without obtaining mutex as\n+\t   we've already claimed it.  */\n+\tif (threadArray[old].value == 0)\n+\t  {\n+\t    currentThread = p2;\n+\t    /* Record we are about to wait on the condition variable.  */\n+\t    threadArray[old].waiting = true;\n+\t    __gthread_cond_wait (&threadArray[old].run_counter, &lock);\n+\t    threadArray[old].waiting = false;\n+\t    /* We are running again.  */\n+\t    currentThread = old;\n+\t  }\n+\telse\n+\t  {\n+\t    tprintf (\"(currentThread = %d) no need for thread %d to cond_wait - taking value (pre) = %d\\n\",\n+\t\t     currentThread, old, threadArray[old].value);\n+\t    /* No need to block as we have been told a signal has\n+               effectively already been recorded.  We remove the signal\n+               notification without blocking.  */\n+\t    threadArray[old].value--;\n+\t  }\n+\ttprintf (\"end, context back to %d\\n\", currentThread);\n+\tif (currentThread != old)\n+\t  M2RTS_HaltC (__FILE__, __LINE__, __FUNCTION__,\n+\t\t       \"wrong process id\");\n+      }\n+  }\n+  __gthread_mutex_unlock (&lock);\n }\n \n extern \"C\" int\n-RTco_select (int p1, fd_set *p2, fd_set *p3, fd_set *p4, const timespec *p5)\n+EXPORT(select) (int p1, fd_set *p2, fd_set *p3, fd_set *p4, const timespec *p5)\n {\n-  RTco_init ();\n+  EXPORT(init) ();\n   tprintf (\"[%x]  RTco.select (...)\\n\", pthread_self ());\n   return pselect (p1, p2, p3, p4, p5, NULL);\n }\n \n extern \"C\" int\n-RTco_init (void)\n+EXPORT(init) (void)\n {\n+  tprintf (\"checking init\\n\");\n   if (! initialized)\n     {\n-      int tid;\n+      initialized = TRUE;\n \n       tprintf (\"RTco initialized\\n\");\n-      initSem (&lock, 0);\n+      __GTHREAD_MUTEX_INIT_FUNCTION (&lock);\n+      __gthread_mutex_lock (&lock);\n       /* Create initial thread container.  */\n #if defined(POOL)\n       threadArray = (threadCB *)malloc (sizeof (threadCB) * THREAD_POOL);\n       semArray = (threadSem **)malloc (sizeof (threadSem *) * SEM_POOL);\n #endif\n-      tid = newThread ();  /* For the current initial thread.  */\n-      threadArray[tid].tid = tid;\n-      threadArray[tid].execution = initSemaphore (0);\n-      threadArray[tid].p = pthread_self ();\n-      threadArray[tid].interruptLevel = 0;\n-      threadArray[tid].proc\n-          = never;  /* This shouldn't happen as we are already running.  */\n-      initialized = TRUE;\n+      /* Create a thread control block for the main program (or process).  */\n+      currentThread = newThread ();  /* For the current initial thread.  */\n+      threadArray[currentThread].p = pthread_self ();\n+      threadArray[currentThread].tid = currentThread;\n+      __GTHREAD_COND_INIT_FUNCTION (&threadArray[currentThread].run_counter);\n+      threadArray[currentThread].interruptLevel = 0;\n+      /* The line below shouldn't be necessary as we are already running.  */\n+      threadArray[currentThread].proc = never;\n+      threadArray[currentThread].waiting = false;   /* We are running.  */\n+      threadArray[currentThread].value = 0;   /* No signal from anyone yet.  */\n       tprintf (\"RTco initialized completed\\n\");\n-      signalSem (&lock);\n+      __gthread_mutex_unlock (&lock);\n     }\n   return 0;\n }\n \n extern \"C\" void __attribute__((__constructor__))\n-_M2_RTco_ctor (void)\n+M2EXPORT(ctor) (void)\n {\n-  M2RTS_RegisterModule (\"RTco\", _M2_RTco_init, _M2_RTco_fini,\n-\t\t\t_M2_RTco_dep);\n+  M2RTS_RegisterModule (\"RTco\",\n+\t\t\tM2EXPORT(init), M2EXPORT(fini),\n+\t\t\tM2EXPORT(dep));\n }"}]}