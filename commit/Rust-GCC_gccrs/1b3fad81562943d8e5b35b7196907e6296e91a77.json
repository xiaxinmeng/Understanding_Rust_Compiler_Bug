{"sha": "1b3fad81562943d8e5b35b7196907e6296e91a77", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWIzZmFkODE1NjI5NDNkOGU1YjM1YjcxOTY5MDdlNjI5NmU5MWE3Nw==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely.gcc@gmail.com", "date": "2010-10-08T00:44:12Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2010-10-08T00:44:12Z"}, "message": "re PR libstdc++/45893 ([C++0x] [DR 817] Finish updating std::bind to rvalue refs)\n\n2010-10-08  Jonathan Wakely  <jwakely.gcc@gmail.com>\n\n\tPR libstdc++/45893\n\t* include/std/functional (bind): Implement DR 817 and add support\n\tfor volatile-qualified call wrappers.\n\t* include/std/mutex (call_once): Implement DR 891.\n\t* include/std/thread (thread::thread): Implement DR 929.\n\t* include/std/future: Optimise use of std::bind.\n\t* testsuite/20_util/bind/cv_quals.cc: Test volatile-qualification.\n\t* testsuite/20_util/bind/move.cc: New.\n\nFrom-SVN: r165144", "tree": {"sha": "223378819d65a4a1a8fd8097258e549d4a14ed6f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/223378819d65a4a1a8fd8097258e549d4a14ed6f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1b3fad81562943d8e5b35b7196907e6296e91a77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b3fad81562943d8e5b35b7196907e6296e91a77", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b3fad81562943d8e5b35b7196907e6296e91a77", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b3fad81562943d8e5b35b7196907e6296e91a77/comments", "author": null, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "65d09bfe2ad0f2035ab1091dea82ca4649818695", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65d09bfe2ad0f2035ab1091dea82ca4649818695", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65d09bfe2ad0f2035ab1091dea82ca4649818695"}], "stats": {"total": 375, "additions": 277, "deletions": 98}, "files": [{"sha": "1b8e8aa3521b1668d2c31a52eb1abadeb34d1e1d", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b3fad81562943d8e5b35b7196907e6296e91a77/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b3fad81562943d8e5b35b7196907e6296e91a77/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=1b3fad81562943d8e5b35b7196907e6296e91a77", "patch": "@@ -1,3 +1,14 @@\n+2010-10-08  Jonathan Wakely  <jwakely.gcc@gmail.com>\n+\n+\tPR libstdc++/45893\n+\t* include/std/functional (bind): Implement DR 817 and add support\n+\tfor volatile-qualified call wrappers.\n+\t* include/std/mutex (call_once): Implement DR 891.\n+\t* include/std/thread (thread::thread): Implement DR 929.\n+\t* include/std/future: Optimise use of std::bind.\n+\t* testsuite/20_util/bind/cv_quals.cc: Test volatile-qualification.\n+\t* testsuite/20_util/bind/move.cc: New.\n+\n 2010-10-07  Hans-Peter Nilsson  <hp@axis.com>\n \n \tPR libstdc++/45841"}, {"sha": "51054ac2da606f1385aa2f8e42e6850738f4e039", "filename": "libstdc++-v3/include/std/functional", "status": "modified", "additions": 123, "deletions": 78, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b3fad81562943d8e5b35b7196907e6296e91a77/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b3fad81562943d8e5b35b7196907e6296e91a77/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional?ref=1b3fad81562943d8e5b35b7196907e6296e91a77", "patch": "@@ -957,7 +957,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n        */\n       template<typename _CVRef, typename _Tuple>\n         result_type\n-        operator()(_CVRef& __arg, _Tuple&&) const volatile\n+        operator()(_CVRef& __arg, _Tuple&) const volatile\n         { return __arg.get(); }\n     };\n \n@@ -970,33 +970,26 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n     class _Mu<_Arg, true, false>\n     {\n     public:\n-      template<typename _Signature> class result;\n-\n-      // Determine the result type when we pass the arguments along. This\n-      // involves passing along the cv-qualifiers placed on _Mu and\n-      // unwrapping the argument bundle.\n-      template<typename _CVMu, typename _CVArg, typename... _Args>\n-        class result<_CVMu(_CVArg, tuple<_Args...>)>\n-\t: public result_of<_CVArg(_Args...)> { };\n-\n       template<typename _CVArg, typename... _Args>\n-        typename result_of<_CVArg(_Args...)>::type\n+        auto\n         operator()(_CVArg& __arg,\n-\t\t   tuple<_Args...>&& __tuple) const volatile\n+\t\t   tuple<_Args...>& __tuple) const volatile\n+        -> decltype(__arg(declval<_Args>()...))\n         {\n \t  // Construct an index tuple and forward to __call\n \t  typedef typename _Build_index_tuple<sizeof...(_Args)>::__type\n \t    _Indexes;\n-\t  return this->__call(__arg, std::move(__tuple), _Indexes());\n+\t  return this->__call(__arg, __tuple, _Indexes());\n \t}\n \n     private:\n       // Invokes the underlying function object __arg by unpacking all\n       // of the arguments in the tuple. \n       template<typename _CVArg, typename... _Args, int... _Indexes>\n-        typename result_of<_CVArg(_Args...)>::type\n-        __call(_CVArg& __arg, tuple<_Args...>&& __tuple,\n+        auto\n+        __call(_CVArg& __arg, tuple<_Args...>& __tuple,\n \t       const _Index_tuple<_Indexes...>&) const volatile\n+        -> decltype(__arg(declval<_Args>()...))\n         {\n \t  return __arg(std::forward<_Args>(get<_Indexes>(__tuple))...);\n \t}\n@@ -1029,7 +1022,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n \n       template<typename _Tuple>\n         typename result<_Mu(_Arg, _Tuple)>::type\n-        operator()(const volatile _Arg&, _Tuple&& __tuple) const volatile\n+        operator()(const volatile _Arg&, _Tuple& __tuple) const volatile\n         {\n \t  return std::forward<typename result<_Mu(_Arg, _Tuple)>::type>(\n               ::std::get<(is_placeholder<_Arg>::value - 1)>(__tuple));\n@@ -1056,7 +1049,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n       // Pick up the cv-qualifiers of the argument\n       template<typename _CVArg, typename _Tuple>\n         _CVArg&&\n-        operator()(_CVArg&& __arg, _Tuple&&) const volatile\n+        operator()(_CVArg&& __arg, _Tuple&) const volatile\n         { return std::forward<_CVArg>(__arg); }\n     };\n \n@@ -1069,10 +1062,14 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n     struct _Maybe_wrap_member_pointer\n     {\n       typedef _Tp type;\n-      \n+\n       static const _Tp&\n       __do_wrap(const _Tp& __x)\n       { return __x; }\n+\n+      static _Tp&&\n+      __do_wrap(_Tp&& __x)\n+      { return static_cast<_Tp&&>(__x); }\n     };\n \n   /**\n@@ -1100,6 +1097,20 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n       typedef void type;\n     };\n \n+  // std::get<I> for volatile-qualified tuples\n+  template<size_t _Ind, typename... _Tp>\n+    inline auto\n+    __volget(volatile tuple<_Tp...>& __tuple)\n+    -> typename tuple_element<_Ind, tuple<_Tp...>>::type volatile&\n+    { return std::get<_Ind>(const_cast<tuple<_Tp...>&>(__tuple)); }\n+\n+  // std::get<I> for const-volatile-qualified tuples\n+  template<size_t _Ind, typename... _Tp>\n+    inline auto\n+    __volget(const volatile tuple<_Tp...>& __tuple)\n+    -> typename tuple_element<_Ind, tuple<_Tp...>>::type const volatile&\n+    { return std::get<_Ind>(const_cast<const tuple<_Tp...>&>(__tuple)); }\n+\n   /// Type of the function object returned from bind().\n   template<typename _Signature>\n     struct _Bind;\n@@ -1109,7 +1120,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n     : public _Weak_result_type<_Functor>\n     {\n       typedef _Bind __self_type;\n-      typedef typename _Build_index_tuple<sizeof...(_Bound_args)>::__type \n+      typedef typename _Build_index_tuple<sizeof...(_Bound_args)>::__type\n         _Bound_indexes;\n \n       _Functor _M_f;\n@@ -1121,7 +1132,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n         __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>)\n         {\n           return _M_f(_Mu<_Bound_args>()\n-                      (get<_Indexes>(_M_bound_args), std::move(__args))...);\n+                      (get<_Indexes>(_M_bound_args), __args)...);\n         }\n \n       // Call as const\n@@ -1130,18 +1141,17 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n         __call_c(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>) const\n         {\n           return _M_f(_Mu<_Bound_args>()\n-                      (get<_Indexes>(_M_bound_args), std::move(__args))...);\n+                      (get<_Indexes>(_M_bound_args), __args)...);\n         }\n \n-#if 0\n       // Call as volatile\n       template<typename _Result, typename... _Args, int... _Indexes>\n         _Result\n         __call_v(tuple<_Args...>&& __args, \n \t\t _Index_tuple<_Indexes...>) volatile\n         {\n           return _M_f(_Mu<_Bound_args>()\n-                      (get<_Indexes>(_M_bound_args), std::move(__args))...);\n+                      (__volget<_Indexes>(_M_bound_args), __args)...);\n         }\n \n       // Call as const volatile\n@@ -1151,69 +1161,77 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n \t\t   _Index_tuple<_Indexes...>) const volatile\n         {\n           return _M_f(_Mu<_Bound_args>()\n-                      (get<_Indexes>(_M_bound_args), std::move(__args))...);\n+                      (__volget<_Indexes>(_M_bound_args), __args)...);\n         }\n-#endif\n \n      public:\n-      explicit _Bind(_Functor __f, _Bound_args... __bound_args)\n-      : _M_f(std::forward<_Functor>(__f)),\n-\t_M_bound_args(std::forward<_Bound_args>(__bound_args)...)\n+      template<typename... _Args>\n+        explicit _Bind(const _Functor& __f, _Args&&... __args)\n+        : _M_f(__f), _M_bound_args(std::forward<_Args>(__args)...)\n+        { }\n+\n+      template<typename... _Args>\n+        explicit _Bind(_Functor&& __f, _Args&&... __args)\n+        : _M_f(std::move(__f)), _M_bound_args(std::forward<_Args>(__args)...)\n+        { }\n+\n+      _Bind(const _Bind&) = default;\n+\n+      _Bind(_Bind&& __b)\n+      : _M_f(std::move(__b._M_f)), _M_bound_args(std::move(__b._M_bound_args))\n       { }\n \n       // Call unqualified\n       template<typename... _Args, typename _Result\n         = decltype( std::declval<_Functor>()(\n               _Mu<_Bound_args>()( std::declval<_Bound_args&>(),\n-\t\t\t\t  std::declval<tuple<_Args...>&&>() )... ) )>\n+\t\t\t\t  std::declval<tuple<_Args...>&>() )... ) )>\n         _Result\n         operator()(_Args&&... __args)\n         {\n-          return this->__call<_Result>(tuple<_Args...>\n-\t\t\t\t       (std::forward<_Args>(__args)...),\n-                                       _Bound_indexes());\n+          return this->__call<_Result>(\n+              std::forward_as_tuple(std::forward<_Args>(__args)...),\n+              _Bound_indexes());\n         }\n \n       // Call as const\n       template<typename... _Args, typename _Result\n         = decltype( std::declval<const _Functor>()(\n \t      _Mu<_Bound_args>()( std::declval<const _Bound_args&>(),\n-\t\t\t\t  std::declval<tuple<_Args...>&&>() )... ) )>\n+\t\t\t\t  std::declval<tuple<_Args...>&>() )... ) )>\n         _Result\n         operator()(_Args&&... __args) const\n         {\n-          return this->__call_c<_Result>(tuple<_Args...>\n-                                         (std::forward<_Args>(__args)...),\n-                                         _Bound_indexes());\n+          return this->__call_c<_Result>(\n+              std::forward_as_tuple(std::forward<_Args>(__args)...),\n+              _Bound_indexes());\n         }\n \n-#if 0\n       // Call as volatile\n       template<typename... _Args, typename _Result\n         = decltype( std::declval<volatile _Functor>()(\n               _Mu<_Bound_args>()( std::declval<volatile _Bound_args&>(),\n-                                  std::declval<tuple<_Args...>&&>() )... ) )>\n+                                  std::declval<tuple<_Args...>&>() )... ) )>\n         _Result\n         operator()(_Args&&... __args) volatile\n         {\n-          return this->__call_v<_Result>(tuple<_Args...>\n-                                         (std::forward<_Args>(__args)...),\n-                                         _Bound_indexes());\n+          return this->__call_v<_Result>(\n+              std::forward_as_tuple(std::forward<_Args>(__args)...),\n+              _Bound_indexes());\n         }\n \n       // Call as const volatile\n       template<typename... _Args, typename _Result\n         = decltype( std::declval<const volatile _Functor>()(\n               _Mu<_Bound_args>()( std::declval<const volatile _Bound_args&>(),\n-                                  std::declval<tuple<_Args...>&&>() )... ) )>\n+                                  std::declval<tuple<_Args...>&>() )... ) )>\n         _Result\n         operator()(_Args&&... __args) const volatile\n         {\n-          return this->__call_c_v<_Result>(tuple<_Args...>\n-                                           (std::forward<_Args>(__args)...),\n-                                           _Bound_indexes());\n+          return this->__call_c_v<_Result>(\n+              std::forward_as_tuple(std::forward<_Args>(__args)...),\n+              _Bound_indexes());\n         }\n-#endif\n     };\n \n   /// Type of the function object returned from bind<R>().\n@@ -1243,7 +1261,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n             typename __disable_if_void<_Res>::type = 0)\n         {\n           return _M_f(_Mu<_Bound_args>()\n-                      (get<_Indexes>(_M_bound_args), std::move(__args))...);\n+                      (get<_Indexes>(_M_bound_args), __args)...);\n         }\n \n       // Call unqualified, return void\n@@ -1253,7 +1271,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n             typename __enable_if_void<_Res>::type = 0)\n         {\n           _M_f(_Mu<_Bound_args>()\n-\t       (get<_Indexes>(_M_bound_args), std::move(__args))...);\n+\t       (get<_Indexes>(_M_bound_args), __args)...);\n         }\n \n       // Call as const\n@@ -1263,7 +1281,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n             typename __disable_if_void<_Res>::type = 0) const\n         {\n           return _M_f(_Mu<_Bound_args>()\n-                      (get<_Indexes>(_M_bound_args), std::move(__args))...);\n+                      (get<_Indexes>(_M_bound_args), __args)...);\n         }\n \n       // Call as const, return void\n@@ -1273,7 +1291,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n             typename __enable_if_void<_Res>::type = 0) const\n         {\n           _M_f(_Mu<_Bound_args>()\n-\t       (get<_Indexes>(_M_bound_args),  std::move(__args))...);\n+\t       (get<_Indexes>(_M_bound_args),  __args)...);\n         }\n \n       // Call as volatile\n@@ -1283,7 +1301,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n             typename __disable_if_void<_Res>::type = 0) volatile\n         {\n           return _M_f(_Mu<_Bound_args>()\n-                      (get<_Indexes>(_M_bound_args), std::move(__args))...);\n+                      (__volget<_Indexes>(_M_bound_args), __args)...);\n         }\n \n       // Call as volatile, return void\n@@ -1293,7 +1311,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n             typename __enable_if_void<_Res>::type = 0) volatile\n         {\n           _M_f(_Mu<_Bound_args>()\n-\t       (get<_Indexes>(_M_bound_args), std::move(__args))...);\n+\t       (__volget<_Indexes>(_M_bound_args), __args)...);\n         }\n \n       // Call as const volatile\n@@ -1303,7 +1321,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n             typename __disable_if_void<_Res>::type = 0) const volatile\n         {\n           return _M_f(_Mu<_Bound_args>()\n-                      (get<_Indexes>(_M_bound_args), std::move(__args))...);\n+                      (__volget<_Indexes>(_M_bound_args), __args)...);\n         }\n \n       // Call as const volatile, return void\n@@ -1314,16 +1332,26 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n             typename __enable_if_void<_Res>::type = 0) const volatile\n         {\n           _M_f(_Mu<_Bound_args>()\n-\t       (get<_Indexes>(_M_bound_args), std::move(__args))...);\n+\t       (__volget<_Indexes>(_M_bound_args), __args)...);\n         }\n \n     public:\n       typedef _Result result_type;\n \n-      explicit\n-      _Bind_result(_Functor __f, _Bound_args... __bound_args)\n-      : _M_f(std::forward<_Functor>(__f)),\n-\t_M_bound_args(std::forward<_Bound_args>(__bound_args)...)\n+      template<typename... _Args>\n+        explicit _Bind_result(const _Functor& __f, _Args&&... __args)\n+        : _M_f(__f), _M_bound_args(std::forward<_Args>(__args)...)\n+        { }\n+\n+      template<typename... _Args>\n+        explicit _Bind_result(_Functor&& __f, _Args&&... __args)\n+        : _M_f(std::move(__f)), _M_bound_args(std::forward<_Args>(__args)...)\n+        { }\n+\n+      _Bind_result(const _Bind_result&) = default;\n+\n+      _Bind_result(_Bind_result&& __b)\n+      : _M_f(std::move(__b._M_f)), _M_bound_args(std::move(__b._M_bound_args))\n       { }\n \n       // Call unqualified\n@@ -1332,7 +1360,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n         operator()(_Args&&... __args)\n         {\n           return this->__call<_Result>(\n-              tuple<_Args...>(std::forward<_Args>(__args)...),\n+              std::forward_as_tuple(std::forward<_Args>(__args)...),\n               _Bound_indexes());\n         }\n \n@@ -1342,7 +1370,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n         operator()(_Args&&... __args) const\n         {\n           return this->__call<_Result>(\n-              tuple<_Args...>(std::forward<_Args>(__args)...),\n+              std::forward_as_tuple(std::forward<_Args>(__args)...),\n               _Bound_indexes());\n         }\n \n@@ -1352,7 +1380,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n         operator()(_Args&&... __args) volatile\n         {\n           return this->__call<_Result>(\n-              tuple<_Args...>(std::forward<_Args>(__args)...),\n+              std::forward_as_tuple(std::forward<_Args>(__args)...),\n               _Bound_indexes());\n         }\n \n@@ -1362,7 +1390,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n         operator()(_Args&&... __args) const volatile\n         {\n           return this->__call<_Result>(\n-              tuple<_Args...>(std::forward<_Args>(__args)...),\n+              std::forward_as_tuple(std::forward<_Args>(__args)...),\n               _Bound_indexes());\n         }\n     };\n@@ -1383,38 +1411,55 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n     struct is_bind_expression<_Bind_result<_Result, _Signature> >\n     : public true_type { };\n \n+  template<typename _Functor, typename... _ArgTypes>\n+    struct _Bind_helper\n+    {\n+      typedef _Maybe_wrap_member_pointer<typename decay<_Functor>::type>\n+        __maybe_type;\n+      typedef typename __maybe_type::type __functor_type;\n+      typedef _Bind<__functor_type(typename decay<_ArgTypes>::type...)> type;\n+    };\n+\n   /**\n    *  @brief Function template for std::bind.\n    *  @ingroup binders\n    */\n   template<typename _Functor, typename... _ArgTypes>\n     inline\n-    _Bind<typename _Maybe_wrap_member_pointer<_Functor>::type(_ArgTypes...)>\n-    bind(_Functor __f, _ArgTypes... __args)\n+    typename _Bind_helper<_Functor, _ArgTypes...>::type\n+    bind(_Functor&& __f, _ArgTypes&&... __args)\n     {\n-      typedef _Maybe_wrap_member_pointer<_Functor> __maybe_type;\n-      typedef typename __maybe_type::type __functor_type;\n-      typedef _Bind<__functor_type(_ArgTypes...)> __result_type;\n-      return __result_type(__maybe_type::__do_wrap(__f),\n+      typedef _Bind_helper<_Functor, _ArgTypes...> __helper_type;\n+      typedef typename __helper_type::__maybe_type __maybe_type;\n+      typedef typename __helper_type::type __result_type;\n+      return __result_type(__maybe_type::__do_wrap(std::forward<_Functor>(__f)),\n                            std::forward<_ArgTypes>(__args)...);\n     } \n \n+  template<typename _Result, typename _Functor, typename... _ArgTypes>\n+    struct _Bindres_helper\n+    {\n+      typedef _Maybe_wrap_member_pointer<typename decay<_Functor>::type>\n+        __maybe_type;\n+      typedef typename __maybe_type::type __functor_type;\n+      typedef _Bind_result<_Result,\n+                           __functor_type(typename decay<_ArgTypes>::type...)>\n+        type;\n+    };\n+\n   /**\n-   *  @brief Function template for std::bind.\n+   *  @brief Function template for std::bind<R>.\n    *  @ingroup binders\n    */\n   template<typename _Result, typename _Functor, typename... _ArgTypes>\n     inline\n-    _Bind_result<_Result,\n-\t\t typename _Maybe_wrap_member_pointer<_Functor>::type\n-                            (_ArgTypes...)>\n-    bind(_Functor __f, _ArgTypes... __args)\n+    typename _Bindres_helper<_Result, _Functor, _ArgTypes...>::type\n+    bind(_Functor&& __f, _ArgTypes&&... __args)\n     {\n-      typedef _Maybe_wrap_member_pointer<_Functor> __maybe_type;\n-      typedef typename __maybe_type::type __functor_type;\n-      typedef _Bind_result<_Result, __functor_type(_ArgTypes...)>\n-\t__result_type;\n-      return __result_type(__maybe_type::__do_wrap(__f),\n+      typedef _Bindres_helper<_Result, _Functor, _ArgTypes...> __helper_type;\n+      typedef typename __helper_type::__maybe_type __maybe_type;\n+      typedef typename __helper_type::type __result_type;\n+      return __result_type(__maybe_type::__do_wrap(std::forward<_Functor>(__f)),\n                            std::forward<_ArgTypes>(__args)...);\n     }\n "}, {"sha": "803c912294eb0eeecae1338905494d84f940b349", "filename": "libstdc++-v3/include/std/future", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b3fad81562943d8e5b35b7196907e6296e91a77/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b3fad81562943d8e5b35b7196907e6296e91a77/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture?ref=1b3fad81562943d8e5b35b7196907e6296e91a77", "patch": "@@ -309,7 +309,7 @@ namespace std\n         bool __set = __ignore_failure;\n         // all calls to this function are serialized,\n         // side-effects of invoking __res only happen once\n-        call_once(_M_once, mem_fn(&_State::_M_do_set), this, ref(__res),\n+        call_once(_M_once, &_State::_M_do_set, this, ref(__res),\n             ref(__set));\n         if (!__set)\n           __throw_future_error(int(future_errc::promise_already_satisfied));\n@@ -1155,7 +1155,7 @@ namespace std\n       _M_run(_Args... __args)\n       {\n         // bound arguments decay so wrap lvalue references\n-        auto __bound = std::bind<_Res>(_M_task,\n+        auto __bound = std::bind<_Res>(std::ref(_M_task),\n             _S_maybe_wrap_ref(std::forward<_Args>(__args))...);\n         _Task_setter<_Task_state> __setter{ this, std::move(__bound) };\n         _M_set_result(std::move(__setter));"}, {"sha": "c11ddd44668ae6ca8397e2ed14626b89cdf856cc", "filename": "libstdc++-v3/include/std/mutex", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b3fad81562943d8e5b35b7196907e6296e91a77/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmutex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b3fad81562943d8e5b35b7196907e6296e91a77/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmutex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmutex?ref=1b3fad81562943d8e5b35b7196907e6296e91a77", "patch": "@@ -690,7 +690,7 @@ namespace std\n \n     template<typename _Callable, typename... _Args>\n       friend void\n-      call_once(once_flag& __once, _Callable __f, _Args&&... __args);\n+      call_once(once_flag& __once, _Callable&& __f, _Args&&... __args);\n   };\n \n #ifdef _GLIBCXX_HAVE_TLS\n@@ -718,15 +718,17 @@ namespace std\n   /// call_once\n   template<typename _Callable, typename... _Args>\n     void\n-    call_once(once_flag& __once, _Callable __f, _Args&&... __args)\n+    call_once(once_flag& __once, _Callable&& __f, _Args&&... __args)\n     {\n #ifdef _GLIBCXX_HAVE_TLS\n-      auto __bound_functor = std::bind<void>(__f, __args...);\n+      auto __bound_functor = std::bind<void>(std::forward<_Callable>(__f),\n+          std::forward<_Args>(__args)...);\n       __once_callable = &__bound_functor;\n       __once_call = &__once_call_impl<decltype(__bound_functor)>;\n #else\n       unique_lock<mutex> __functor_lock(__get_once_mutex());\n-      __once_functor = std::bind<void>(__f, __args...);\n+      __once_functor = std::bind<void>(std::forward<_Callable>(__f),\n+          std::forward<_Args>(__args)...);\n       __set_once_functor_lock_ptr(&__functor_lock);\n #endif\n "}, {"sha": "4a3818e7278d7c7d4a7c6a19421ba3f5dc0426ba", "filename": "libstdc++-v3/include/std/thread", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b3fad81562943d8e5b35b7196907e6296e91a77/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fthread", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b3fad81562943d8e5b35b7196907e6296e91a77/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fthread", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fthread?ref=1b3fad81562943d8e5b35b7196907e6296e91a77", "patch": "@@ -126,16 +126,14 @@ namespace std\n     thread(thread&& __t)\n     { swap(__t); }\n \n-    template<typename _Callable>\n-      explicit thread(_Callable __f)\n-      {\n-\t_M_start_thread(_M_make_routine<_Callable>\n-\t\t\t(std::forward<_Callable>(__f)));\n-      }\n-\n     template<typename _Callable, typename... _Args>\n+      explicit \n       thread(_Callable&& __f, _Args&&... __args)\n-      { _M_start_thread(_M_make_routine(std::bind(__f, __args...))); }\n+      {\n+        _M_start_thread(_M_make_routine(std::bind<void>(\n+                std::forward<_Callable>(__f),\n+                std::forward<_Args>(__args)...)));\n+      }\n \n     ~thread()\n     {"}, {"sha": "d597a56fd951a0c6ecc6ae5e0b1ba99b189ef444", "filename": "libstdc++-v3/testsuite/20_util/bind/cv_quals.cc", "status": "modified", "additions": 71, "deletions": 6, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b3fad81562943d8e5b35b7196907e6296e91a77/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2Fcv_quals.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b3fad81562943d8e5b35b7196907e6296e91a77/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2Fcv_quals.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2Fcv_quals.cc?ref=1b3fad81562943d8e5b35b7196907e6296e91a77", "patch": "@@ -22,14 +22,24 @@\n #include <functional>\n #include <testsuite_hooks.h>\n \n+// target must be invoked with cv-quals of call wrapper\n+\n struct X\n {\n   int operator()() { return 0; }\n   int operator()() const { return 1; }\n-  // int operator()() volatile { return 2; }\n-  // int operator()() const volatile { return 3; }\n+  int operator()() volatile { return 2; }\n+  int operator()() const volatile { return 3; }\n+\n+  int operator()(int, int, int) { return 0; }\n+  int operator()(int, int, int) const { return 1; }\n+  int operator()(int, int, int) volatile { return 2; }\n+  int operator()(int, int, int) const volatile { return 3; }\n };\n \n+using std::placeholders::_1;\n+using std::placeholders::_2;\n+\n void test01()\n {\n   bool test __attribute__((unused)) = true;\n@@ -40,15 +50,70 @@ void test01()\n   const auto b1 = std::bind(X());\n   VERIFY( b1() == 1 );\n \n-  // volatile auto b2 = std::bind(X());\n-  // VERIFY( b2() == 2 );\n+  volatile auto b2 = std::bind(X());\n+  VERIFY( b2() == 2 );\n+\n+  const volatile auto b3 = std::bind(X());\n+  VERIFY( b3() == 3 );\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  auto b0 = std::bind<int>(X());\n+  VERIFY( b0() == 0 );\n+\n+  const auto b1 = std::bind<int>(X());\n+  VERIFY( b1() == 1 );\n+\n+  volatile auto b2 = std::bind<int>(X());\n+  VERIFY( b2() == 2 );\n+\n+  const volatile auto b3 = std::bind<int>(X());\n+  VERIFY( b3() == 3 );\n+}\n+\n+void test03()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  auto b0 = std::bind(X(), 0, _1, _2);\n+  VERIFY( b0(0, 0) == 0 );\n \n-  // const volatile auto b3 = std::bind(X());\n-  // VERIFY( b3() == 3 );\n+  const auto b1 = std::bind(X(), _1, 0, _2);\n+  VERIFY( b1(0, 0) == 1 );\n+\n+  volatile auto b2 = std::bind(X(), _1, _2, 0);\n+  VERIFY( b2(0, 0) == 2 );\n+\n+  const volatile auto b3 = std::bind(X(), _1, 0, _2);\n+  VERIFY( b3(0, 0) == 3 );\n }\n \n+void test04()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  auto b0 = std::bind<int>(X(), 0, _1, _2);\n+  VERIFY( b0(0, 0) == 0 );\n+\n+  const auto b1 = std::bind<int>(X(), _1, 0, _2);\n+  VERIFY( b1(0, 0) == 1 );\n+\n+  volatile auto b2 = std::bind<int>(X(), _1, _2, 0);\n+  VERIFY( b2(0, 0) == 2 );\n+\n+  const volatile auto b3 = std::bind<int>(X(), _1, 0, _2);\n+  VERIFY( b3(0, 0) == 3 );\n+}\n+\n+\n int main()\n {\n   test01();\n+  test02();\n+  test03();\n+  test04();\n   return 0;\n }"}, {"sha": "d9485ad3156a7e37c1e33759a7f76ddbd2e0cba8", "filename": "libstdc++-v3/testsuite/20_util/bind/move.cc", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b3fad81562943d8e5b35b7196907e6296e91a77/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2Fmove.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b3fad81562943d8e5b35b7196907e6296e91a77/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2Fmove.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2Fmove.cc?ref=1b3fad81562943d8e5b35b7196907e6296e91a77", "patch": "@@ -0,0 +1,58 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <functional>\n+#include <testsuite_hooks.h>\n+\n+// PR libstdc++/45924\n+\n+struct f\n+{\n+  f() : i(0) { }\n+  f(f&& r) : i(1) { r.i = -1; }\n+  f(const f&) = delete;\n+  int operator()() { return i; }\n+  int i;\n+};\n+\n+void test01()\n+{\n+  auto b = std::bind(f());\n+  VERIFY( b() == 1 );\n+  auto bc(std::move(b));\n+  VERIFY( bc() == 1 );\n+  VERIFY( b() == -1 );\n+}\n+\n+void test02()\n+{\n+  auto b = std::bind<int>(f());\n+  VERIFY( b() == 1 );\n+  auto bc(std::move(b));\n+  VERIFY( bc() == 1 );\n+  VERIFY( b() == -1 );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}\n+"}]}