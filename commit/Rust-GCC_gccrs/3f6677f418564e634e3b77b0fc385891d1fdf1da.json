{"sha": "3f6677f418564e634e3b77b0fc385891d1fdf1da", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Y2Njc3ZjQxODU2NGU2MzRlM2I3N2IwZmMzODU4OTFkMWZkZjFkYQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2018-08-16T13:51:38Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2018-08-16T13:51:38Z"}, "message": "[PATCH] CPP Macro predicates\n\nhttps://gcc.gnu.org/ml/gcc-patches/2018-08/msg00897.html\n\tlibcpp/\n\t* include/cpplib.h (cpp_user_macro_p, cpp_builtin_macro_p)\n\t(cpp_macro_p): New inlines.\n\t* directives.c (do_pragma_poison): Use cpp_macro_p.\n\t(do_ifdef, do_ifndef): Likewise.  Use _cpp_maybe_notify_macro_use.\n\t(cpp_pop_definition): Use cpp_macro_p.  Move _cpp_free_definition\n\tearlier.  Don't zap node directly.\n\t* expr.c (parse_defined): Use _cpp_maybe_notify_macro_use &\n\tcpp_macro_p.\n\t* files.c (should_stack_file): Use cpp_macro_p.\n\t* identifiers.c (cpp_defined): Likewise.\n\t* internal.h (_cpp_mark_macro): Use cpp_user_macro_p.\n\t(_cpp_notify_macro_use): Declare.\n\t(_cpp_maybe_notify_macro_use): New inline.\n\t* lex.c (is_macro): Use cpp_macro_p.\n\t* macro.c (_cpp_warn_if_unused_macro): Use cpp_user_macro_p.\n\t(enter_macro_context): Likewise.\n\t(_cpp_create_definition): Use cpp_builtin_macro_p,\n\tcpp_user_macro_p.  Move _cpp_free_definition earlier.\n\t(_cpp_notify_macro_use): New, broken out of multiple call sites.\n\t* traditional.c (fun_like_macro_p): Use cpp_builtin_macro_p.\n\t(maybe_start_funlike, _cpp_scan_out_logical_line)\n\t(push_replacement_text): Likewise.\n\tgcc/c-family/\n\t* c-ada-spec.c (count_ada_macro): Use cpp_user_macro_p.\n\t(store_ada_macro): Likewise.\n\t* c-ppoutput.c (cb_used_define, dump_macro): Likewise.\n\t* c-spellcheck.cc (should-suggest_as_macro_p): Likewise,\n\tgcc/\n\t* config/rs6000/rs6000-c.c (rs6000_macro_to_expend): Use cpp_macro_p.\n\t* config/powerpcspc/powerpcspe-c.c (rs6000_macro_to_expend): Likewise.\n\tgcc/cp/\n\t* name-lookup.c (lookup_name_fuzzy): Likewise.\n\tgcc/fortran/\n\t* cpp.c (dump_macro): Use cpp_user_macro_p.\n\nFrom-SVN: r263587", "tree": {"sha": "fee267b2fd8d26f1c657aea624e05d02e0f67a17", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fee267b2fd8d26f1c657aea624e05d02e0f67a17"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3f6677f418564e634e3b77b0fc385891d1fdf1da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f6677f418564e634e3b77b0fc385891d1fdf1da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f6677f418564e634e3b77b0fc385891d1fdf1da", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f6677f418564e634e3b77b0fc385891d1fdf1da/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ba9d634f417a95d7efb875408573872c883f710a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba9d634f417a95d7efb875408573872c883f710a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba9d634f417a95d7efb875408573872c883f710a"}], "stats": {"total": 298, "additions": 166, "deletions": 132}, "files": [{"sha": "fdac7e758c9b3d528c09bace397d620a0c121d29", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f6677f418564e634e3b77b0fc385891d1fdf1da/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f6677f418564e634e3b77b0fc385891d1fdf1da/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3f6677f418564e634e3b77b0fc385891d1fdf1da", "patch": "@@ -1,3 +1,8 @@\n+2018-08-16  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* config/rs6000/rs6000-c.c (rs6000_macro_to_expend): Use cpp_macro_p.\n+\t* config/powerpcspc/powerpcspe-c.c (rs6000_macro_to_expend): Likewise.\n+\n 2018-08-16  Tamar Christina  <tamar.christina@arm.com>\n \n \tPR target/84711"}, {"sha": "d293d990b17ebd130346e63a7927f2083dc7fa01", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f6677f418564e634e3b77b0fc385891d1fdf1da/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f6677f418564e634e3b77b0fc385891d1fdf1da/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=3f6677f418564e634e3b77b0fc385891d1fdf1da", "patch": "@@ -1,3 +1,10 @@\n+2018-08-16  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* c-ada-spec.c (count_ada_macro): Use cpp_user_macro_p.\n+\t(store_ada_macro): Likewise.\n+\t* c-ppoutput.c (cb_used_define, dump_macro): Likewise.\n+\t* c-spellcheck.cc (should-suggest_as_macro_p): Likewise,\n+\n 2018-08-15  David Malcolm  <dmalcolm@redhat.com>\n \n \t* c-format.c: Include \"selftest-diagnostic.h\" and"}, {"sha": "c6447ab01c991e6e0ca09366a79a3d320d638764", "filename": "gcc/c-family/c-ada-spec.c", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f6677f418564e634e3b77b0fc385891d1fdf1da/gcc%2Fc-family%2Fc-ada-spec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f6677f418564e634e3b77b0fc385891d1fdf1da/gcc%2Fc-family%2Fc-ada-spec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-ada-spec.c?ref=3f6677f418564e634e3b77b0fc385891d1fdf1da", "patch": "@@ -171,13 +171,12 @@ static int\n count_ada_macro (cpp_reader *pfile ATTRIBUTE_UNUSED, cpp_hashnode *node,\n \t\t void *v ATTRIBUTE_UNUSED)\n {\n-  const cpp_macro *macro = node->value.macro;\n-\n-  if (node->type == NT_MACRO && !(node->flags & NODE_BUILTIN)\n-      && macro->count\n-      && *NODE_NAME (node) != '_'\n-      && LOCATION_FILE (macro->line) == macro_source_file)\n-    max_ada_macros++;\n+  if (cpp_user_macro_p (node) && *NODE_NAME (node) != '_')\n+    {\n+      const cpp_macro *macro = node->value.macro;\n+      if (macro->count && LOCATION_FILE (macro->line) == macro_source_file)\n+\tmax_ada_macros++;\n+    }\n \n   return 1;\n }\n@@ -190,15 +189,13 @@ static int\n store_ada_macro (cpp_reader *pfile ATTRIBUTE_UNUSED,\n \t\t cpp_hashnode *node, void *macros)\n {\n-  const cpp_macro *macro = node->value.macro;\n-\n-  if (node->type == NT_MACRO\n-      && !(node->flags & NODE_BUILTIN)\n-      && macro->count\n-      && *NODE_NAME (node) != '_'\n-      && LOCATION_FILE (macro->line) == macro_source_file)\n-    ((cpp_hashnode **) macros)[store_ada_macro_index++] = node;\n-\n+  if (cpp_user_macro_p (node) && *NODE_NAME (node) != '_')\n+    {\n+      const cpp_macro *macro = node->value.macro;\n+      if (macro->count\n+\t  && LOCATION_FILE (macro->line) == macro_source_file)\n+\t((cpp_hashnode **) macros)[store_ada_macro_index++] = node;\n+    }\n   return 1;\n }\n "}, {"sha": "2e5a44ed72731f10bcf3ca44388bd65a869e1bfa", "filename": "gcc/c-family/c-ppoutput.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f6677f418564e634e3b77b0fc385891d1fdf1da/gcc%2Fc-family%2Fc-ppoutput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f6677f418564e634e3b77b0fc385891d1fdf1da/gcc%2Fc-family%2Fc-ppoutput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-ppoutput.c?ref=3f6677f418564e634e3b77b0fc385891d1fdf1da", "patch": "@@ -532,13 +532,14 @@ static void\n cb_used_define (cpp_reader *pfile, source_location line ATTRIBUTE_UNUSED,\n \t\tcpp_hashnode *node)\n {\n-  macro_queue *q;\n-  if (node->flags & NODE_BUILTIN)\n-    return;\n-  q = XNEW (macro_queue);\n-  q->macro = xstrdup ((const char *) cpp_macro_definition (pfile, node));\n-  q->next = define_queue;\n-  define_queue = q;\n+  if (cpp_user_macro_p (node))\n+    {\n+      macro_queue *q;\n+      q = XNEW (macro_queue);\n+      q->macro = xstrdup ((const char *) cpp_macro_definition (pfile, node));\n+      q->next = define_queue;\n+      define_queue = q;\n+    }\n }\n \n static void\n@@ -688,7 +689,7 @@ cb_def_pragma (cpp_reader *pfile, source_location line)\n static int\n dump_macro (cpp_reader *pfile, cpp_hashnode *node, void *v ATTRIBUTE_UNUSED)\n {\n-  if (node->type == NT_MACRO && !(node->flags & NODE_BUILTIN))\n+  if (cpp_user_macro_p (node))\n     {\n       fputs (\"#define \", print.outf);\n       fputs ((const char *) cpp_macro_definition (pfile, node),"}, {"sha": "85fd278f4ac9ac92c93013fdd239856b0abf0c45", "filename": "gcc/c-family/c-spellcheck.cc", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f6677f418564e634e3b77b0fc385891d1fdf1da/gcc%2Fc-family%2Fc-spellcheck.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f6677f418564e634e3b77b0fc385891d1fdf1da/gcc%2Fc-family%2Fc-spellcheck.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-spellcheck.cc?ref=3f6677f418564e634e3b77b0fc385891d1fdf1da", "patch": "@@ -45,13 +45,13 @@ name_reserved_for_implementation_p (const char *str)\n static bool\n should_suggest_as_macro_p (cpp_hashnode *hashnode)\n {\n-  if (hashnode->type != NT_MACRO)\n+  if (!cpp_macro_p (hashnode))\n     return false;\n \n-  /* Don't suggest names reserved for the implementation, but do suggest the builtin\n-     macros such as __FILE__, __LINE__ etc.  */\n-  if (name_reserved_for_implementation_p ((const char *)hashnode->ident.str)\n-      && !(hashnode->flags & NODE_BUILTIN))\n+  /* Don't suggest names reserved for the implementation, but do\n+     suggest the builtin macros such as __FILE__, __LINE__ etc.  */\n+  if (cpp_user_macro_p (hashnode)\n+      && name_reserved_for_implementation_p ((const char *)hashnode->ident.str))\n     return false;\n \n   return true;"}, {"sha": "0e69ebb994f11757a3a86696e0be1d2b166b826b", "filename": "gcc/config/powerpcspe/powerpcspe-c.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f6677f418564e634e3b77b0fc385891d1fdf1da/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f6677f418564e634e3b77b0fc385891d1fdf1da/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe-c.c?ref=3f6677f418564e634e3b77b0fc385891d1fdf1da", "patch": "@@ -220,21 +220,22 @@ rs6000_macro_to_expand (cpp_reader *pfile, const cpp_token *tok)\n       else if (ident && (ident != C_CPP_HASHNODE (__vector_keyword)))\n \t{\n \t  enum rid rid_code = (enum rid)(ident->rid_code);\n-\t  enum node_type itype = ident->type;\n+\t  bool is_macro = cpp_macro_p (ident);\n+\n \t  /* If there is a function-like macro, check if it is going to be\n \t     invoked with or without arguments.  Without following ( treat\n \t     it like non-macro, otherwise the following cpp_get_token eats\n \t     what should be preserved.  */\n-\t  if (itype == NT_MACRO && cpp_fun_like_macro_p (ident))\n+\t  if (is_macro && cpp_fun_like_macro_p (ident))\n \t    {\n \t      int idx2 = idx;\n \t      do\n \t\ttok = cpp_peek_token (pfile, idx2++);\n \t      while (tok->type == CPP_PADDING);\n \t      if (tok->type != CPP_OPEN_PAREN)\n-\t\titype = NT_VOID;\n+\t\tis_macro = false;\n \t    }\n-\t  if (itype == NT_MACRO)\n+\t  if (is_macro)\n \t    {\n \t      do\n \t\t(void) cpp_get_token (pfile);"}, {"sha": "4d5e3c226abb39ce3ef823bcf0adad4c6869688c", "filename": "gcc/config/rs6000/rs6000-c.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f6677f418564e634e3b77b0fc385891d1fdf1da/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f6677f418564e634e3b77b0fc385891d1fdf1da/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-c.c?ref=3f6677f418564e634e3b77b0fc385891d1fdf1da", "patch": "@@ -220,21 +220,23 @@ rs6000_macro_to_expand (cpp_reader *pfile, const cpp_token *tok)\n       else if (ident && (ident != C_CPP_HASHNODE (__vector_keyword)))\n \t{\n \t  enum rid rid_code = (enum rid)(ident->rid_code);\n-\t  enum node_type itype = ident->type;\n+\t  bool is_macro = cpp_macro_p (ident);\n+\n \t  /* If there is a function-like macro, check if it is going to be\n \t     invoked with or without arguments.  Without following ( treat\n \t     it like non-macro, otherwise the following cpp_get_token eats\n \t     what should be preserved.  */\n-\t  if (itype == NT_MACRO && cpp_fun_like_macro_p (ident))\n+\t  if (is_macro && cpp_fun_like_macro_p (ident))\n \t    {\n \t      int idx2 = idx;\n \t      do\n \t\ttok = cpp_peek_token (pfile, idx2++);\n \t      while (tok->type == CPP_PADDING);\n \t      if (tok->type != CPP_OPEN_PAREN)\n-\t\titype = NT_VOID;\n+\t\tis_macro = false;\n \t    }\n-\t  if (itype == NT_MACRO)\n+\n+\t  if (is_macro)\n \t    {\n \t      do\n \t\t(void) cpp_get_token (pfile);"}, {"sha": "3ba76447f98cacbd2c2477a7260861ebffefffcb", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f6677f418564e634e3b77b0fc385891d1fdf1da/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f6677f418564e634e3b77b0fc385891d1fdf1da/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=3f6677f418564e634e3b77b0fc385891d1fdf1da", "patch": "@@ -5954,10 +5954,10 @@ lookup_name_fuzzy (tree name, enum lookup_name_fuzzy_kind kind, location_t loc)\n       /* If we have an exact match for a macro name, then either the\n \t macro was used with the wrong argument count, or the macro\n \t has been used before it was defined.  */\n-      cpp_hashnode *macro = bmm.blithely_get_best_candidate ();\n-      if (macro && (macro->flags & NODE_BUILTIN) == 0)\n-\treturn name_hint (NULL,\n-\t\t\t  macro_use_before_def::maybe_make (loc, macro));\n+      if (cpp_hashnode *macro = bmm.blithely_get_best_candidate ())\n+\tif (cpp_user_macro_p (macro))\n+\t  return name_hint (NULL,\n+\t\t\t    macro_use_before_def::maybe_make (loc, macro));\n     }\n \n   /* Try the \"starts_decl_specifier_p\" keywords to detect"}, {"sha": "dc4aa1acf745017223d8516d045361702d4cccd0", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f6677f418564e634e3b77b0fc385891d1fdf1da/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f6677f418564e634e3b77b0fc385891d1fdf1da/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=3f6677f418564e634e3b77b0fc385891d1fdf1da", "patch": "@@ -1,3 +1,7 @@\n+2018-08-16  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* cpp.c (dump_macro): Use cpp_user_macro_p.\n+\n 2018-08-14  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/86116"}, {"sha": "0b3de42e8325244860bae2cc85d74607cd0fe141", "filename": "gcc/fortran/cpp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f6677f418564e634e3b77b0fc385891d1fdf1da/gcc%2Ffortran%2Fcpp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f6677f418564e634e3b77b0fc385891d1fdf1da/gcc%2Ffortran%2Fcpp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcpp.c?ref=3f6677f418564e634e3b77b0fc385891d1fdf1da", "patch": "@@ -990,7 +990,7 @@ cb_include (cpp_reader *pfile ATTRIBUTE_UNUSED, source_location line,\n static int\n dump_macro (cpp_reader *pfile, cpp_hashnode *node, void *v ATTRIBUTE_UNUSED)\n {\n-  if (node->type == NT_MACRO && !(node->flags & NODE_BUILTIN))\n+  if (cpp_user_macro_p (node))\n     {\n       fputs (\"#define \", print.outf);\n       fputs ((const char *) cpp_macro_definition (pfile, node),"}, {"sha": "2bab8a72b595f17e40fc6b9df8de43638901cf41", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f6677f418564e634e3b77b0fc385891d1fdf1da/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f6677f418564e634e3b77b0fc385891d1fdf1da/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=3f6677f418564e634e3b77b0fc385891d1fdf1da", "patch": "@@ -1,3 +1,29 @@\n+2018-08-16  Nathan Sidwell  <nathan@acm.org>\n+\n+\tlibcpp/\n+\t* include/cpplib.h (cpp_user_macro_p, cpp_builtin_macro_p)\n+\t(cpp_macro_p): New inlines.\n+\t* directives.c (do_pragma_poison): Use cpp_macro_p.\n+\t(do_ifdef, do_ifndef): Likewise.  Use _cpp_maybe_notify_macro_use.\n+\t(cpp_pop_definition): Use cpp_macro_p.  Move _cpp_free_definition\n+\tearlier.  Don't zap node directly.\n+\t* expr.c (parse_defined): Use _cpp_maybe_notify_macro_use &\n+\tcpp_macro_p.\n+\t* files.c (should_stack_file): Use cpp_macro_p.\n+\t* identifiers.c (cpp_defined): Likewise.\n+\t* internal.h (_cpp_mark_macro): Use cpp_user_macro_p.\n+\t(_cpp_notify_macro_use): Declare.\n+\t(_cpp_maybe_notify_macro_use): New inline.\n+\t* lex.c (is_macro): Use cpp_macro_p.\n+\t* macro.c (_cpp_warn_if_unused_macro): Use cpp_user_macro_p.\n+\t(enter_macro_context): Likewise.\n+\t(_cpp_create_definition): Use cpp_builtin_macro_p,\n+\tcpp_user_macro_p.  Move _cpp_free_definition earlier.\n+\t(_cpp_notify_macro_use): New, broken out of multiple call sites.\n+\t* traditional.c (fun_like_macro_p): Use cpp_builtin_macro_p.\n+\t(maybe_start_funlike, _cpp_scan_out_logical_line)\n+\t(push_replacement_text): Likewise.\n+\n 2018-08-15  David Malcolm  <dmalcolm@redhat.com>\n \n \t* include/line-map.h (struct location_range): Add \"m_label\" field."}, {"sha": "6ddfce6778f45d3995ad66ce353f35cdc0c4ee2a", "filename": "libcpp/directives.c", "status": "modified", "additions": 9, "deletions": 44, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f6677f418564e634e3b77b0fc385891d1fdf1da/libcpp%2Fdirectives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f6677f418564e634e3b77b0fc385891d1fdf1da/libcpp%2Fdirectives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fdirectives.c?ref=3f6677f418564e634e3b77b0fc385891d1fdf1da", "patch": "@@ -1666,7 +1666,7 @@ do_pragma_poison (cpp_reader *pfile)\n       if (hp->flags & NODE_POISONED)\n \tcontinue;\n \n-      if (hp->type == NT_MACRO)\n+      if (cpp_macro_p (hp))\n \tcpp_error (pfile, CPP_DL_WARNING, \"poisoning existing macro \\\"%s\\\"\",\n \t\t   NODE_NAME (hp));\n       _cpp_free_definition (hp);\n@@ -1960,26 +1960,9 @@ do_ifdef (cpp_reader *pfile)\n \t     the powerpc and spu ports using conditional macros for 'vector',\n \t     'bool', and 'pixel' to act as conditional keywords.  This messes\n \t     up tests like #ifndef bool.  */\n-\t  skip = (node->type != NT_MACRO\n-\t\t  || ((node->flags & NODE_CONDITIONAL) != 0));\n+\t  skip = !cpp_macro_p (node) || (node->flags & NODE_CONDITIONAL);\n \t  _cpp_mark_macro_used (node);\n-\t  if (!(node->flags & NODE_USED))\n-\t    {\n-\t      node->flags |= NODE_USED;\n-\t      if (node->type == NT_MACRO)\n-\t\t{\n-\t\t  if ((node->flags & NODE_BUILTIN)\n-\t\t      && pfile->cb.user_builtin_macro)\n-\t\t    pfile->cb.user_builtin_macro (pfile, node);\n-\t\t  if (pfile->cb.used_define)\n-\t\t    pfile->cb.used_define (pfile, pfile->directive_line, node);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  if (pfile->cb.used_undef)\n-\t\t    pfile->cb.used_undef (pfile, pfile->directive_line, node);\n-\t\t}\n-\t    }\n+\t  _cpp_maybe_notify_macro_use (pfile, node);\n \t  if (pfile->cb.used)\n \t    pfile->cb.used (pfile, pfile->directive_line, node);\n \t  check_eol (pfile, false);\n@@ -2006,26 +1989,10 @@ do_ifndef (cpp_reader *pfile)\n \t     the powerpc and spu ports using conditional macros for 'vector',\n \t     'bool', and 'pixel' to act as conditional keywords.  This messes\n \t     up tests like #ifndef bool.  */\n-\t  skip = (node->type == NT_MACRO\n-\t\t  && ((node->flags & NODE_CONDITIONAL) == 0));\n+\t  skip = (cpp_macro_p (node)\n+\t\t  && !(node->flags & NODE_CONDITIONAL));\n \t  _cpp_mark_macro_used (node);\n-\t  if (!(node->flags & NODE_USED))\n-\t    {\n-\t      node->flags |= NODE_USED;\n-\t      if (node->type == NT_MACRO)\n-\t\t{\n-\t\t  if ((node->flags & NODE_BUILTIN)\n-\t\t      && pfile->cb.user_builtin_macro)\n-\t\t    pfile->cb.user_builtin_macro (pfile, node);\n-\t\t  if (pfile->cb.used_define)\n-\t\t    pfile->cb.used_define (pfile, pfile->directive_line, node);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  if (pfile->cb.used_undef)\n-\t\t    pfile->cb.used_undef (pfile, pfile->directive_line, node);\n-\t\t}\n-\t    }\n+\t  _cpp_maybe_notify_macro_use (pfile, node);\n \t  if (pfile->cb.used)\n \t    pfile->cb.used (pfile, pfile->directive_line, node);\n \t  check_eol (pfile, false);\n@@ -2508,18 +2475,18 @@ cpp_pop_definition (cpp_reader *pfile, struct def_pragma_macro *c)\n   if (pfile->cb.before_define)\n     pfile->cb.before_define (pfile);\n \n-  if (node->type == NT_MACRO)\n+  if (cpp_macro_p (node))\n     {\n       if (pfile->cb.undef)\n \tpfile->cb.undef (pfile, pfile->directive_line, node);\n       if (CPP_OPTION (pfile, warn_unused_macros))\n \t_cpp_warn_if_unused_macro (pfile, node, NULL);\n+      _cpp_free_definition (node);\n     }\n-  if (node->type != NT_VOID)\n-    _cpp_free_definition (node);\n \n   if (c->is_undef)\n     return;\n+\n   {\n     size_t namelen;\n     const uchar *dn;\n@@ -2530,8 +2497,6 @@ cpp_pop_definition (cpp_reader *pfile, struct def_pragma_macro *c)\n     h = cpp_lookup (pfile, c->definition, namelen);\n     dn = c->definition + namelen;\n \n-    h->type = NT_VOID;\n-    h->flags &= ~(NODE_POISONED|NODE_BUILTIN|NODE_DISABLED|NODE_USED);\n     nbuf = cpp_push_buffer (pfile, dn, ustrchr (dn, '\\n') - dn, true);\n     if (nbuf != NULL)\n       {"}, {"sha": "201a6197bcd3a7ef08b0d9b1fa4873a7fb31a719", "filename": "libcpp/expr.c", "status": "modified", "additions": 3, "deletions": 19, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f6677f418564e634e3b77b0fc385891d1fdf1da/libcpp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f6677f418564e634e3b77b0fc385891d1fdf1da/libcpp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fexpr.c?ref=3f6677f418564e634e3b77b0fc385891d1fdf1da", "patch": "@@ -1065,23 +1065,7 @@ parse_defined (cpp_reader *pfile)\n \t\t        \"this use of \\\"defined\\\" may not be portable\");\n \n       _cpp_mark_macro_used (node);\n-      if (!(node->flags & NODE_USED))\n-\t{\n-\t  node->flags |= NODE_USED;\n-\t  if (node->type == NT_MACRO)\n-\t    {\n-\t      if ((node->flags & NODE_BUILTIN)\n-\t\t  && pfile->cb.user_builtin_macro)\n-\t\tpfile->cb.user_builtin_macro (pfile, node);\n-\t      if (pfile->cb.used_define)\n-\t\tpfile->cb.used_define (pfile, pfile->directive_line, node);\n-\t    }\n-\t  else\n-\t    {\n-\t      if (pfile->cb.used_undef)\n-\t\tpfile->cb.used_undef (pfile, pfile->directive_line, node);\n-\t    }\n-\t}\n+      _cpp_maybe_notify_macro_use (pfile, node);\n \n       /* A possible controlling macro of the form #if !defined ().\n \t _cpp_parse_expr checks there was no other junk on the line.  */\n@@ -1097,8 +1081,8 @@ parse_defined (cpp_reader *pfile)\n   result.unsignedp = false;\n   result.high = 0;\n   result.overflow = false;\n-  result.low = (node && node->type == NT_MACRO\n-\t\t&& (node->flags & NODE_CONDITIONAL) == 0);\n+  result.low = (node && cpp_macro_p (node)\n+\t\t&& !(node->flags & NODE_CONDITIONAL));\n   return result;\n }\n "}, {"sha": "08b7c647c91406bfac0bf3d8ba55e8ada65be6f7", "filename": "libcpp/files.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f6677f418564e634e3b77b0fc385891d1fdf1da/libcpp%2Ffiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f6677f418564e634e3b77b0fc385891d1fdf1da/libcpp%2Ffiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Ffiles.c?ref=3f6677f418564e634e3b77b0fc385891d1fdf1da", "patch": "@@ -805,7 +805,7 @@ should_stack_file (cpp_reader *pfile, _cpp_file *file, bool import,\n \n   /* Skip if the file had a header guard and the macro is defined.\n      PCH relies on this appearing before the PCH handler below.  */\n-  if (file->cmacro && file->cmacro->type == NT_MACRO)\n+  if (file->cmacro && cpp_macro_p (file->cmacro))\n     return false;\n \n   /* Handle PCH files immediately; don't stack them.  */"}, {"sha": "3d42d1a6b8d0a63d9baf289d08b118fea2294be6", "filename": "libcpp/identifiers.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f6677f418564e634e3b77b0fc385891d1fdf1da/libcpp%2Fidentifiers.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f6677f418564e634e3b77b0fc385891d1fdf1da/libcpp%2Fidentifiers.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fidentifiers.c?ref=3f6677f418564e634e3b77b0fc385891d1fdf1da", "patch": "@@ -104,8 +104,8 @@ cpp_defined (cpp_reader *pfile, const unsigned char *str, int len)\n \n   node = CPP_HASHNODE (ht_lookup (pfile->hash_table, str, len, HT_NO_INSERT));\n \n-  /* If it's of type NT_MACRO, it cannot be poisoned.  */\n-  return node && node->type == NT_MACRO;\n+  /* If it's a macro, it cannot have been poisoned.  */\n+  return node && cpp_macro_p (node);\n }\n \n /* We don't need a proxy since the hash table's identifier comes first"}, {"sha": "99992a280ba64ee28cb919175eafaa2a9967207a", "filename": "libcpp/include/cpplib.h", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f6677f418564e634e3b77b0fc385891d1fdf1da/libcpp%2Finclude%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f6677f418564e634e3b77b0fc385891d1fdf1da/libcpp%2Finclude%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fcpplib.h?ref=3f6677f418564e634e3b77b0fc385891d1fdf1da", "patch": "@@ -890,7 +890,21 @@ extern int cpp_avoid_paste (cpp_reader *, const cpp_token *,\n extern const cpp_token *cpp_get_token (cpp_reader *);\n extern const cpp_token *cpp_get_token_with_location (cpp_reader *,\n \t\t\t\t\t\t     source_location *);\n-extern bool cpp_fun_like_macro_p (cpp_hashnode *);\n+inline bool cpp_user_macro_p (const cpp_hashnode *node)\n+{\n+  return node->type == NT_MACRO && !(node->flags & NODE_BUILTIN);\n+}\n+inline bool cpp_builtin_macro_p (const cpp_hashnode *node)\n+{\n+  return node->flags & NODE_BUILTIN;\n+}\n+inline bool cpp_macro_p (const cpp_hashnode *node)\n+{\n+  return node->type == NT_MACRO;\n+}\n+/* Returns true if NODE is a function-like user macro.  */\n+extern bool cpp_fun_like_macro_p (cpp_hashnode *node);\n+\n extern const unsigned char *cpp_macro_definition (cpp_reader *,\n \t\t\t\t\t\t  cpp_hashnode *);\n extern source_location cpp_macro_definition_location (cpp_hashnode *);"}, {"sha": "dd145ab57c67a3c89d20da1723685015da8fe637", "filename": "libcpp/internal.h", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f6677f418564e634e3b77b0fc385891d1fdf1da/libcpp%2Finternal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f6677f418564e634e3b77b0fc385891d1fdf1da/libcpp%2Finternal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finternal.h?ref=3f6677f418564e634e3b77b0fc385891d1fdf1da", "patch": "@@ -93,9 +93,8 @@ struct dummy\n #define CPP_ALIGN2(size, align) (((size) + ((align) - 1)) & ~((align) - 1))\n #define CPP_ALIGN(size) CPP_ALIGN2 (size, DEFAULT_ALIGNMENT)\n \n-#define _cpp_mark_macro_used(NODE) do {\t\t\t\t\t\\\n-  if ((NODE)->type == NT_MACRO && !((NODE)->flags & NODE_BUILTIN))\t\\\n-    (NODE)->value.macro->used = 1; } while (0)\n+#define _cpp_mark_macro_used(NODE) \t\t\t\t\t\\\n+  (cpp_user_macro_p (NODE) ? (NODE)->value.macro->used = 1 : 0)\n \n /* A generic memory buffer, and operations on it.  */\n typedef struct _cpp_buff _cpp_buff;\n@@ -622,6 +621,12 @@ cpp_in_primary_file (cpp_reader *pfile)\n }\n \n /* In macro.c */\n+extern void _cpp_notify_macro_use (cpp_reader *pfile, cpp_hashnode *node);\n+inline void _cpp_maybe_notify_macro_use (cpp_reader *pfile, cpp_hashnode *node)\n+{\n+  if (!(node->flags & NODE_USED))\n+    _cpp_notify_macro_use (pfile, node);\n+}\n extern void _cpp_free_definition (cpp_hashnode *);\n extern bool _cpp_create_definition (cpp_reader *, cpp_hashnode *);\n extern void _cpp_pop_context (cpp_reader *);"}, {"sha": "fa465beadb025e58492bbf9947f4cf8411fceb95", "filename": "libcpp/lex.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f6677f418564e634e3b77b0fc385891d1fdf1da/libcpp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f6677f418564e634e3b77b0fc385891d1fdf1da/libcpp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Flex.c?ref=3f6677f418564e634e3b77b0fc385891d1fdf1da", "patch": "@@ -1627,7 +1627,7 @@ is_macro(cpp_reader *pfile, const uchar *base)\n   cpp_hashnode *result = CPP_HASHNODE (ht_lookup_with_hash (pfile->hash_table,\n \t\t\t\t\tbase, cur - base, hash, HT_NO_INSERT));\n \n-  return !result ? false : (result->type == NT_MACRO);\n+  return result && cpp_macro_p (result);\n }\n \n /* Returns true if a literal suffix does not have the expected form"}, {"sha": "5d4cd7838ff5afb99e8dfe124621a6a478211710", "filename": "libcpp/macro.c", "status": "modified", "additions": 37, "deletions": 14, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f6677f418564e634e3b77b0fc385891d1fdf1da/libcpp%2Fmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f6677f418564e634e3b77b0fc385891d1fdf1da/libcpp%2Fmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fmacro.c?ref=3f6677f418564e634e3b77b0fc385891d1fdf1da", "patch": "@@ -342,7 +342,7 @@ int\n _cpp_warn_if_unused_macro (cpp_reader *pfile, cpp_hashnode *node,\n \t\t\t   void *v ATTRIBUTE_UNUSED)\n {\n-  if (node->type == NT_MACRO && !(node->flags & NODE_BUILTIN))\n+  if (cpp_user_macro_p (node))\n     {\n       cpp_macro *macro = node->value.macro;\n \n@@ -1282,8 +1282,7 @@ enter_macro_context (cpp_reader *pfile, cpp_hashnode *node,\n \tpfile->cb.used_define (pfile, pfile->directive_line, node);\n     }\n \n-  /* Handle standard macros.  */\n-  if (! (node->flags & NODE_BUILTIN))\n+  if (cpp_user_macro_p (node))\n     {\n       cpp_macro *macro = node->value.macro;\n       _cpp_buff *pragma_buff = NULL;\n@@ -1413,10 +1412,8 @@ enter_macro_context (cpp_reader *pfile, cpp_hashnode *node,\n     source_location expand_loc;\n \n     if (/* The top-level macro invocation that triggered the expansion\n-\t   we are looking at is with a standard macro ...  */\n-\t!(pfile->top_most_macro_node->flags & NODE_BUILTIN)\n-\t/* ... and it's a function-like macro invocation,  */\n-\t&& pfile->top_most_macro_node->value.macro->fun_like\n+\t   we are looking at is with a function-like user macro ...  */\n+\tcpp_fun_like_macro_p (pfile->top_most_macro_node)\n \t/* ... and we are tracking the macro expansion.  */\n \t&& CPP_OPTION (pfile, track_macro_expansion))\n       /* Then the location of the end of the macro invocation is the\n@@ -3505,25 +3502,23 @@ _cpp_create_definition (cpp_reader *pfile, cpp_hashnode *node)\n \n       if (warn_of_redefinition (pfile, node, macro))\n \t{\n-          const int reason = ((node->flags & NODE_BUILTIN)\n-\t\t\t      && !(node->flags & NODE_WARN))\n-                             ? CPP_W_BUILTIN_MACRO_REDEFINED : CPP_W_NONE;\n+          const int reason\n+\t    = (cpp_builtin_macro_p (node) && !(node->flags & NODE_WARN))\n+\t    ? CPP_W_BUILTIN_MACRO_REDEFINED : CPP_W_NONE;\n \n \t  bool warned = \n \t    cpp_pedwarning_with_line (pfile, reason,\n \t\t\t\t      pfile->directive_line, 0,\n \t\t\t\t      \"\\\"%s\\\" redefined\", NODE_NAME (node));\n \n-\t  if (warned && node->type == NT_MACRO && !(node->flags & NODE_BUILTIN))\n+\t  if (warned && cpp_user_macro_p (node))\n \t    cpp_error_with_line (pfile, CPP_DL_NOTE,\n \t\t\t\t node->value.macro->line, 0,\n \t\t\t \"this is the location of the previous definition\");\n \t}\n+      _cpp_free_definition (node);\n     }\n \n-  if (node->type != NT_VOID)\n-    _cpp_free_definition (node);\n-\n   /* Enter definition in hash table.  */\n   node->type = NT_MACRO;\n   node->value.macro = macro;\n@@ -3544,6 +3539,34 @@ _cpp_create_definition (cpp_reader *pfile, cpp_hashnode *node)\n   return ok;\n }\n \n+/* Notify the use of NODE in a macro-aware context (i.e. expanding it,\n+   or testing its existance).  Also applies any lazy definition.  */\n+\n+extern void\n+_cpp_notify_macro_use (cpp_reader *pfile, cpp_hashnode *node)\n+{\n+  node->flags |= NODE_USED;\n+  switch (node->type)\n+    {\n+    case NT_MACRO:\n+      if ((node->flags & NODE_BUILTIN)\n+\t  && pfile->cb.user_builtin_macro)\n+\tpfile->cb.user_builtin_macro (pfile, node);\n+\n+      if (pfile->cb.used_define)\n+\tpfile->cb.used_define (pfile, pfile->directive_line, node);\n+      break;\n+\n+    case NT_VOID:\n+      if (pfile->cb.used_undef)\n+\tpfile->cb.used_undef (pfile, pfile->directive_line, node);\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+}\n+\n /* Warn if a token in STRING matches one of a function-like MACRO's\n    parameters.  */\n static void"}, {"sha": "aa38ea4426d7fb8d8b661f32e6edffdddeef9a1b", "filename": "libcpp/traditional.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f6677f418564e634e3b77b0fc385891d1fdf1da/libcpp%2Ftraditional.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f6677f418564e634e3b77b0fc385891d1fdf1da/libcpp%2Ftraditional.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Ftraditional.c?ref=3f6677f418564e634e3b77b0fc385891d1fdf1da", "patch": "@@ -325,7 +325,7 @@ _cpp_read_logical_line_trad (cpp_reader *pfile)\n static inline bool\n fun_like_macro (cpp_hashnode *node)\n {\n-  if (node->flags & NODE_BUILTIN)\n+  if (cpp_builtin_macro_p (node))\n     return node->value.builtin == BT_HAS_ATTRIBUTE;\n   else\n     return node->value.macro->fun_like;\n@@ -338,7 +338,7 @@ maybe_start_funlike (cpp_reader *pfile, cpp_hashnode *node, const uchar *start,\n \t\t     struct fun_macro *macro)\n {\n   unsigned int n;\n-  if (node->flags & NODE_BUILTIN)\n+  if (cpp_builtin_macro_p (node))\n     n = 1;\n   else\n     n = node->value.macro->paramc;\n@@ -521,7 +521,7 @@ _cpp_scan_out_logical_line (cpp_reader *pfile, cpp_macro *macro,\n \t      out = pfile->out.cur;\n \t      cur = CUR (context);\n \n-\t      if (node->type == NT_MACRO\n+\t      if (cpp_macro_p (node)\n \t\t  /* Should we expand for ls_answer?  */\n \t\t  && (lex_state == ls_none || lex_state == ls_fun_open)\n \t\t  && !pfile->state.prevent_expansion)\n@@ -610,7 +610,7 @@ _cpp_scan_out_logical_line (cpp_reader *pfile, cpp_macro *macro,\n \t      paren_depth--;\n \t      if (lex_state == ls_fun_close && paren_depth == 0)\n \t\t{\n-\t\t  if (fmacro.node->flags & NODE_BUILTIN)\n+\t\t  if (cpp_builtin_macro_p (fmacro.node))\n \t\t    {\n \t\t      /* Handle builtin function-like macros like\n \t\t\t __has_attribute.  The already parsed arguments\n@@ -839,7 +839,7 @@ push_replacement_text (cpp_reader *pfile, cpp_hashnode *node)\n   const uchar *text;\n   uchar *buf;\n \n-  if (node->flags & NODE_BUILTIN)\n+  if (cpp_builtin_macro_p (node))\n     {\n       text = _cpp_builtin_macro_text (pfile, node);\n       len = ustrlen (text);"}]}