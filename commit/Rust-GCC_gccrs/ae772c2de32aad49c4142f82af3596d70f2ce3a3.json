{"sha": "ae772c2de32aad49c4142f82af3596d70f2ce3a3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWU3NzJjMmRlMzJhYWQ0OWM0MTQyZjgyYWYzNTk2ZDcwZjJjZTNhMw==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2008-05-16T21:12:04Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2008-05-16T21:12:04Z"}, "message": "re PR fortran/35756 (incorrect WHERE for functions in ELSEWHERE and overlaps)\n\n2008-05-16  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/35756\n\tPR fortran/35759\n\t* trans-stmt.c (gfc_trans_where): Tighten up the dependency\n\tcheck for calling gfc_trans_where_3.\n\n\tPR fortran/35743\n\t* trans-stmt.c (gfc_trans_where_2): Set the mask size to zero\n\tif it is calculated to be negative.\n\n\tPR fortran/35745\n\t* trans-stmt.c (gfc_trans_where_3, gfc_trans_where_assign): Set\n\tss->where for scalar right hand sides.\n\t* trans-array.c (gfc_add_loop_ss_code): If ss->where is set do\n\tnot evaluate scalars outside the loop.  Clean up whitespace.\n\t* trans.h : Add a bitfield 'where' to gfc_ss.\n\n2008-05-16  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/35756\n\tPR fortran/35759\n\t* gfortran.dg/where_1.f90: New test.\n\n\tPR fortran/35743\n\tPR fortran/35745\n\t* gfortran.dg/where_2.f90: New test.\n\nFrom-SVN: r135443", "tree": {"sha": "1093b61ac07227cf4b57472af9c0dc65b46ec8a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1093b61ac07227cf4b57472af9c0dc65b46ec8a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ae772c2de32aad49c4142f82af3596d70f2ce3a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae772c2de32aad49c4142f82af3596d70f2ce3a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae772c2de32aad49c4142f82af3596d70f2ce3a3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae772c2de32aad49c4142f82af3596d70f2ce3a3/comments", "author": null, "committer": null, "parents": [{"sha": "a4cd1610eacd66049c22244a1d38e024d57af989", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4cd1610eacd66049c22244a1d38e024d57af989", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4cd1610eacd66049c22244a1d38e024d57af989"}], "stats": {"total": 190, "additions": 170, "deletions": 20}, "files": [{"sha": "0762a6446f34889db1047a8977d821c6a26d65c5", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae772c2de32aad49c4142f82af3596d70f2ce3a3/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae772c2de32aad49c4142f82af3596d70f2ce3a3/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=ae772c2de32aad49c4142f82af3596d70f2ce3a3", "patch": "@@ -1,3 +1,21 @@\n+2008-05-16  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/35756\n+\tPR fortran/35759\n+\t* trans-stmt.c (gfc_trans_where): Tighten up the dependency\n+\tcheck for calling gfc_trans_where_3.\n+\n+\tPR fortran/35743\n+\t* trans-stmt.c (gfc_trans_where_2): Set the mask size to zero\n+\tif it is calculated to be negative.\n+\n+\tPR fortran/35745\n+\t* trans-stmt.c (gfc_trans_where_3, gfc_trans_where_assign): Set\n+\tss->where for scalar right hand sides.\n+\t* trans-array.c (gfc_add_loop_ss_code): If ss->where is set do\n+\tnot evaluate scalars outside the loop.  Clean up whitespace.\n+\t* trans.h : Add a bitfield 'where' to gfc_ss.\n+\n 2008-05-16  Tobias Burnus  <burnus@net-b.de>\n \n \t* libgfortran.h: Increase GFC_MAX_DIMENSIONS to 15."}, {"sha": "784f1bc40d013735582a854bc3e900bd18c3d4fc", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae772c2de32aad49c4142f82af3596d70f2ce3a3/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae772c2de32aad49c4142f82af3596d70f2ce3a3/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=ae772c2de32aad49c4142f82af3596d70f2ce3a3", "patch": "@@ -1900,20 +1900,21 @@ gfc_add_loop_ss_code (gfc_loopinfo * loop, gfc_ss * ss, bool subscript)\n \t  /* Scalar expression.  Evaluate this now.  This includes elemental\n \t     dimension indices, but not array section bounds.  */\n \t  gfc_init_se (&se, NULL);\n-          gfc_conv_expr (&se, ss->expr);\n-          gfc_add_block_to_block (&loop->pre, &se.pre);\n+\t  gfc_conv_expr (&se, ss->expr);\n+\t  gfc_add_block_to_block (&loop->pre, &se.pre);\n \n-          if (ss->expr->ts.type != BT_CHARACTER)\n-            {\n-              /* Move the evaluation of scalar expressions outside the\n-                 scalarization loop.  */\n-              if (subscript)\n-                se.expr = convert(gfc_array_index_type, se.expr);\n-              se.expr = gfc_evaluate_now (se.expr, &loop->pre);\n-              gfc_add_block_to_block (&loop->pre, &se.post);\n-            }\n-          else\n-            gfc_add_block_to_block (&loop->post, &se.post);\n+\t  if (ss->expr->ts.type != BT_CHARACTER)\n+\t    {\n+\t      /* Move the evaluation of scalar expressions outside the\n+\t\t scalarization loop, except for WHERE assignments.  */\n+\t      if (subscript)\n+\t\tse.expr = convert(gfc_array_index_type, se.expr);\n+\t      if (!ss->where)\n+\t\tse.expr = gfc_evaluate_now (se.expr, &loop->pre);\n+\t      gfc_add_block_to_block (&loop->pre, &se.post);\n+\t    }\n+\t  else\n+\t    gfc_add_block_to_block (&loop->post, &se.post);\n \n \t  ss->data.scalar.expr = se.expr;\n \t  ss->string_length = se.string_length;"}, {"sha": "64829e370c1fe8d20437a5fa458f4939df971f48", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae772c2de32aad49c4142f82af3596d70f2ce3a3/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae772c2de32aad49c4142f82af3596d70f2ce3a3/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=ae772c2de32aad49c4142f82af3596d70f2ce3a3", "patch": "@@ -3150,6 +3150,7 @@ gfc_trans_where_assign (gfc_expr *expr1, gfc_expr *expr2,\n    {\n      /* The rhs is scalar.  Add a ss for the expression.  */\n      rss = gfc_get_ss ();\n+     rss->where = 1;\n      rss->next = gfc_ss_terminator;\n      rss->type = GFC_SS_SCALAR;\n      rss->expr = expr2;\n@@ -3312,6 +3313,7 @@ gfc_trans_where_2 (gfc_code * code, tree mask, bool invert,\n   gfc_code *cblock;\n   gfc_code *cnext;\n   tree tmp;\n+  tree cond;\n   tree count1, count2;\n   bool need_cmask;\n   bool need_pmask;\n@@ -3377,6 +3379,13 @@ gfc_trans_where_2 (gfc_code * code, tree mask, bool invert,\n       size = compute_overall_iter_number (nested_forall_info, inner_size,\n \t\t\t\t\t  &inner_size_body, block);\n \n+      /* Check whether the size is negative.  */\n+      cond = fold_build2 (LE_EXPR, boolean_type_node, size,\n+\t\t\t  gfc_index_zero_node);\n+      size = fold_build3 (COND_EXPR, gfc_array_index_type, cond,\n+\t\t\t  gfc_index_zero_node, size);\n+      size = gfc_evaluate_now (size, block);\n+\n       /* Allocate temporary for WHERE mask if needed.  */\n       if (need_cmask)\n \tcmask = allocate_temp_for_forall_nest_1 (mask_type, size, block,\n@@ -3578,6 +3587,7 @@ gfc_trans_where_3 (gfc_code * cblock, gfc_code * eblock)\n   if (tsss == gfc_ss_terminator)\n     {\n       tsss = gfc_get_ss ();\n+      tsss->where = 1;\n       tsss->next = gfc_ss_terminator;\n       tsss->type = GFC_SS_SCALAR;\n       tsss->expr = tsrc;\n@@ -3595,6 +3605,7 @@ gfc_trans_where_3 (gfc_code * cblock, gfc_code * eblock)\n       if (esss == gfc_ss_terminator)\n \t{\n \t  esss = gfc_get_ss ();\n+\t  esss->where = 1;\n \t  esss->next = gfc_ss_terminator;\n \t  esss->type = GFC_SS_SCALAR;\n \t  esss->expr = esrc;\n@@ -3709,19 +3720,28 @@ gfc_trans_where (gfc_code * code)\n \t     block is dependence free if cond is not dependent on writes\n \t     to x1 and x2, y1 is not dependent on writes to x2, and y2\n \t     is not dependent on writes to x1, and both y's are not\n-\t     dependent upon their own x's.  */\n+\t     dependent upon their own x's.  In addition to this, the\n+\t     final two dependency checks below exclude all but the same\n+\t     array reference if the where and elswhere destinations\n+\t     are the same.  In short, this is VERY conservative and this\n+\t     is needed because the two loops, required by the standard\n+\t     are coalesced in gfc_trans_where_3.  */\n \t  if (!gfc_check_dependency(cblock->next->expr,\n \t\t\t\t    cblock->expr, 0)\n \t      && !gfc_check_dependency(eblock->next->expr,\n \t\t\t\t       cblock->expr, 0)\n \t      && !gfc_check_dependency(cblock->next->expr,\n-\t\t\t\t       eblock->next->expr2, 0)\n+\t\t\t\t       eblock->next->expr2, 1)\n+\t      && !gfc_check_dependency(eblock->next->expr,\n+\t\t\t\t       cblock->next->expr2, 1)\n+\t      && !gfc_check_dependency(cblock->next->expr,\n+\t\t\t\t       cblock->next->expr2, 1)\n \t      && !gfc_check_dependency(eblock->next->expr,\n-\t\t\t\t       cblock->next->expr2, 0)\n+\t\t\t\t       eblock->next->expr2, 1)\n \t      && !gfc_check_dependency(cblock->next->expr,\n-\t\t\t\t       cblock->next->expr2, 0)\n+\t\t\t\t       eblock->next->expr, 0)\n \t      && !gfc_check_dependency(eblock->next->expr,\n-\t\t\t\t       eblock->next->expr2, 0))\n+\t\t\t\t       cblock->next->expr, 0))\n \t    return gfc_trans_where_3 (cblock, eblock);\n \t}\n     }"}, {"sha": "ffd1b84c875cc63798c124f1743f1269a2249434", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae772c2de32aad49c4142f82af3596d70f2ce3a3/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae772c2de32aad49c4142f82af3596d70f2ce3a3/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=ae772c2de32aad49c4142f82af3596d70f2ce3a3", "patch": "@@ -201,8 +201,9 @@ typedef struct gfc_ss\n \n   /* This is used by assignments requiring temporaries. The bits specify which\n      loops the terms appear in.  This will be 1 for the RHS expressions,\n-     2 for the LHS expressions, and 3(=1|2) for the temporary.  */\n-  unsigned useflags:2;\n+     2 for the LHS expressions, and 3(=1|2) for the temporary.  The bit\n+     'where' suppresses precalculation of scalars in WHERE assignments.  */\n+  unsigned useflags:2, where:1;\n }\n gfc_ss;\n #define gfc_get_ss() gfc_getmem(sizeof(gfc_ss))"}, {"sha": "7bed29c77bca44b808c9554ef965625bae7a02b2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae772c2de32aad49c4142f82af3596d70f2ce3a3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae772c2de32aad49c4142f82af3596d70f2ce3a3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ae772c2de32aad49c4142f82af3596d70f2ce3a3", "patch": "@@ -1,3 +1,13 @@\n+2008-05-16  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/35756\n+\tPR fortran/35759\n+\t* gfortran.dg/where_1.f90: New test.\n+\n+\tPR fortran/35743\n+\tPR fortran/35745\n+\t* gfortran.dg/where_2.f90: New test.\n+\n 2008-05-16  Tobias Burnus  <burnus@net-b.de>\n \n \t* gfortran.dg/rank_1.f90"}, {"sha": "0f5b5e77b75a3b5209d2eae40e83d5ae75f27322", "filename": "gcc/testsuite/gfortran.dg/where_1.f90", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae772c2de32aad49c4142f82af3596d70f2ce3a3/gcc%2Ftestsuite%2Fgfortran.dg%2Fwhere_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae772c2de32aad49c4142f82af3596d70f2ce3a3/gcc%2Ftestsuite%2Fgfortran.dg%2Fwhere_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fwhere_1.f90?ref=ae772c2de32aad49c4142f82af3596d70f2ce3a3", "patch": "@@ -0,0 +1,64 @@\n+! { dg-do run }\n+! Tests the fix for PR35759 and PR35756 in which the dependencies\n+! led to an incorrect use of the \"simple where\", gfc_trans_where_3.\n+!\n+! Contributed by Dick Hendrickson <dick.hendrickson@gmail.com>\n+!\n+  logical :: la(6) = (/(2*(i/2) /= i, i = 1, 6)/), lb(6)\n+  CALL PR35759\n+  CALL PR35756\n+!\n+! The first version of the fix caused this to regress as pointed\n+! out by Dominique d'Humieres\n+!\n+  lb = la\n+  where(la)\n+    la = .false.\n+  elsewhere\n+    la = .true.\n+  end where\n+  if (any(la .eqv. lb)) call abort()\n+CONTAINS\n+  subroutine PR35759\n+    integer UDA1L(6)\n+    integer ::  UDA1R(6), expected(6) = (/2,0,5,0,3,0/)\n+    LOGICAL LDA(5)\n+    UDA1L(1:6) = 0\n+    uda1r = (/1,2,3,4,5,6/)\n+    lda = (/ (i/2*2 .ne. I, i=1,5) /)\n+    WHERE (LDA)\n+      UDA1L(1:5) = UDA1R(2:6)\n+    ELSEWHERE\n+      UDA1L(2:6) = UDA1R(6:2:-1)\n+    ENDWHERE\n+    if (any (expected /= uda1l)) call abort\n+  END subroutine\n+\n+  SUBROUTINE PR35756\n+    INTEGER  ILA(10), CLA(10)\n+    LOGICAL  LDA(10)\n+    ILA = (/ (I, i=1,10) /)\n+    LDA = (/ (i/2*2 .ne. I, i=1,10) /)\n+    WHERE(LDA)\n+      CLA = 10\n+    ELSEWHERE\n+      CLA = 2\n+    ENDWHERE\n+    WHERE(LDA)\n+      ILA = R_MY_MAX_I(ILA)\n+    ELSEWHERE\n+      ILA = R_MY_MIN_I(ILA)\n+    ENDWHERE\n+    IF (any (CLA /= ILA)) call abort\n+  end subroutine\n+\n+  INTEGER FUNCTION R_MY_MAX_I(A)\n+    INTEGER  ::  A(:)\n+    R_MY_MAX_I = MAXVAL(A)\n+  END FUNCTION R_MY_MAX_I\n+\n+  INTEGER FUNCTION R_MY_MIN_I(A)\n+    INTEGER  ::  A(:)\n+    R_MY_MIN_I = MINVAL(A)\n+  END FUNCTION R_MY_MIN_I\n+END"}, {"sha": "b6e952b2034a64f94c726cfdd0a10d8c6cba5b6f", "filename": "gcc/testsuite/gfortran.dg/where_2.f90", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae772c2de32aad49c4142f82af3596d70f2ce3a3/gcc%2Ftestsuite%2Fgfortran.dg%2Fwhere_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae772c2de32aad49c4142f82af3596d70f2ce3a3/gcc%2Ftestsuite%2Fgfortran.dg%2Fwhere_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fwhere_2.f90?ref=ae772c2de32aad49c4142f82af3596d70f2ce3a3", "patch": "@@ -0,0 +1,36 @@\n+! { dg-do run }\n+! Tests the fix for PR35743 and PR35745.\n+!\n+! Contributed by Dick Hendrickson <dick.hendrickson@gmail.com>\n+!\n+program try_rg0025\n+  logical lda(5)\n+  lda = (/(i/2*2 .ne. I, i=1,5)/)\n+  call PR35743 (lda,  1,  2,  3,  5,  6, -1, -2)\n+  CALL PR34745\n+end program\n+\n+! Previously, the negative mask size would not be detected.\n+SUBROUTINE PR35743 (LDA,nf1,nf2,nf3,nf5,nf6,mf1,mf2)\n+  type unseq\n+    real  r\n+  end type unseq\n+  TYPE(UNSEQ) TDA1L(6)\n+  LOGICAL LDA(NF5)\n+  TDA1L(1:6)%r = 1.0\n+  WHERE (LDA(NF6:NF3))\n+    TDA1L(MF1:NF5:MF1) = TDA1L(NF6:NF2)\n+  ENDWHERE\n+END SUBROUTINE\n+\n+! Previously, the expression in the WHERE block would be evaluated\n+! ouside the loop generated by the where.\n+SUBROUTINE PR34745\n+  INTEGER IDA(10)\n+  REAL RDA(10)\n+  RDA    = 1.0\n+  nf0 = 0\n+  WHERE (RDA < -15.0)\n+    IDA = 1/NF0 + 2\n+  ENDWHERE\n+END SUBROUTINE"}]}