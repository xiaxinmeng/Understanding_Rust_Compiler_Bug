{"sha": "161c12b0bf44568bd062d6b9309973bd3901065f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTYxYzEyYjBiZjQ0NTY4YmQwNjJkNmI5MzA5OTczYmQzOTAxMDY1Zg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1998-11-21T05:42:20Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-11-21T05:42:20Z"}, "message": "Handle specifying template args to member function templates.\n\n\t* tree.c (build_overload): Always create an OVERLOAD for a template.\n\t* search.c (add_conversions): Handle finding an OVERLOAD.\n\t* decl2.c (check_classfn): Likewise.\n\t* lex.c (identifier_type): See through a baselink.\n\t* parse.y (do_id): Don't call do_identifier if we got a baselink.\n\t* class.c (instantiate_type, case TREE_LIST): Recurse.\n\t* decl.c (grokdeclarator): Allow a boolean constant for array\n\tbounds, odd as that sounds.\n\t* pt.c (unify): Be more strict about non-type parms, except for\n\tarray bounds.\n\t(UNIFY_ALLOW_INTEGER): New macro.\n\nFrom-SVN: r23740", "tree": {"sha": "18dd11cb735a685056e90a54e5a93e5ccd074973", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/18dd11cb735a685056e90a54e5a93e5ccd074973"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/161c12b0bf44568bd062d6b9309973bd3901065f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/161c12b0bf44568bd062d6b9309973bd3901065f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/161c12b0bf44568bd062d6b9309973bd3901065f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/161c12b0bf44568bd062d6b9309973bd3901065f/comments", "author": null, "committer": null, "parents": [{"sha": "e42e5028955eb799abbbaa7cdcf813d936782226", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e42e5028955eb799abbbaa7cdcf813d936782226", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e42e5028955eb799abbbaa7cdcf813d936782226"}], "stats": {"total": 1236, "additions": 636, "deletions": 600}, "files": [{"sha": "a4b51e9f8401dbf2af8588af709bfb16876d97b4", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/161c12b0bf44568bd062d6b9309973bd3901065f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/161c12b0bf44568bd062d6b9309973bd3901065f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=161c12b0bf44568bd062d6b9309973bd3901065f", "patch": "@@ -1,3 +1,20 @@\n+1998-11-21  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\tHandle specifying template args to member function templates.\n+\t* tree.c (build_overload): Always create an OVERLOAD for a template.\n+\t* search.c (add_conversions): Handle finding an OVERLOAD.\n+\t* decl2.c (check_classfn): Likewise.\n+\t* lex.c (identifier_type): See through a baselink.\n+\t* parse.y (do_id): Don't call do_identifier if we got a baselink.\n+\t* class.c (instantiate_type, case TREE_LIST): Recurse.\n+\n+\t* decl.c (grokdeclarator): Allow a boolean constant for array\n+\tbounds, odd as that sounds.\n+\n+\t* pt.c (unify): Be more strict about non-type parms, except for\n+\tarray bounds.\n+\t(UNIFY_ALLOW_INTEGER): New macro.\n+\n 1998-11-19  Manfred Hollstein  <manfred@s-direktnet.de>\n \n \t* Make-lang.in (mandir): Replace all uses of $(mandir) by $(man1dir)."}, {"sha": "6e89ce538c9d6221508f035ca1d3358ad619a29a", "filename": "gcc/cp/class.c", "status": "modified", "additions": 1, "deletions": 32, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/161c12b0bf44568bd062d6b9309973bd3901065f/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/161c12b0bf44568bd062d6b9309973bd3901065f/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=161c12b0bf44568bd062d6b9309973bd3901065f", "patch": "@@ -5227,8 +5227,6 @@ instantiate_type (lhstype, rhs, complain)\n \n     case TREE_LIST:\n       {\n-\ttree elem, baselink, name = NULL_TREE;\n-\n \tif (TREE_PURPOSE (rhs) == error_mark_node)\n \t  {\n \t    /* Make sure we don't drop the non-local flag, as the old code\n@@ -5242,41 +5240,12 @@ instantiate_type (lhstype, rhs, complain)\n \t/* Now we should have a baselink. */\n \tmy_friendly_assert (TREE_CODE (TREE_PURPOSE (rhs)) == TREE_VEC,\n \t\t\t    980331);\n-\t/* First look for an exact match.  Search member functions.\n-\t   May have to undo what `default_conversion' might do to\n-\t   lhstype.  */\n-\n-\tlhstype = validate_lhs (lhstype, complain);\n-\tif (lhstype == error_mark_node)\n-\t  return lhstype;\n-\n \tmy_friendly_assert (TREE_CHAIN (rhs) == NULL_TREE, 181);\n \tmy_friendly_assert (TREE_CODE (TREE_VALUE (rhs)) == FUNCTION_DECL\n \t\t\t    || TREE_CODE (TREE_VALUE (rhs)) == OVERLOAD,\n \t\t\t    182);\n \n-\tfor (baselink = rhs; baselink;\n-\t     baselink = next_baselink (baselink))\n-\t  {\n-\t    elem = TREE_VALUE (baselink);\n-\t    while (elem)\n-\t      if (same_type_p (lhstype, TREE_TYPE (OVL_CURRENT (elem))))\n-\t\t{\n-\t\t  mark_used (OVL_CURRENT (elem));\n-\t\t  return OVL_CURRENT (elem);\n-\t\t}\n-\t      else\n-\t\telem = OVL_NEXT (elem);\n-\t  }\n-\n-\tname = rhs;\n-\twhile (TREE_CODE (name) == TREE_LIST)\n-\t  name = TREE_VALUE (name);\n-\tname = DECL_NAME (OVL_CURRENT (name));\n-\n-\tif (complain)\n-\t  cp_error (\"no compatible member functions named `%D'\", name);\n-\treturn error_mark_node;\n+\treturn instantiate_type (lhstype, TREE_VALUE (rhs), complain);\n       }\n \n     case CALL_EXPR:"}, {"sha": "8640364ea4193a46edee0a28a11b9485aa5fdee8", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/161c12b0bf44568bd062d6b9309973bd3901065f/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/161c12b0bf44568bd062d6b9309973bd3901065f/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=161c12b0bf44568bd062d6b9309973bd3901065f", "patch": "@@ -9692,7 +9692,8 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\t  }\n \n \t\tif (TREE_CODE (TREE_TYPE (size)) != INTEGER_TYPE\n-\t\t    && TREE_CODE (TREE_TYPE (size)) != ENUMERAL_TYPE)\n+\t\t    && TREE_CODE (TREE_TYPE (size)) != ENUMERAL_TYPE\n+\t\t    && TREE_CODE (TREE_TYPE (size)) != BOOLEAN_TYPE)\n \t\t  {\n \t\t    cp_error (\"size of array `%D' has non-integer type\",\n \t\t\t      dname);"}, {"sha": "21ea1c1226e9b0f7b1b076b446eef7993ea07e03", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/161c12b0bf44568bd062d6b9309973bd3901065f/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/161c12b0bf44568bd062d6b9309973bd3901065f/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=161c12b0bf44568bd062d6b9309973bd3901065f", "patch": "@@ -1425,8 +1425,8 @@ check_classfn (ctype, function)\n \t\t}\n \t      break;\t\t/* loser */\n \t    }\n-\t  else if (TREE_CODE (fndecl) == TEMPLATE_DECL \n-\t\t   && DECL_CONV_FN_P (fndecl)\n+\t  else if (TREE_CODE (OVL_CURRENT (fndecl)) == TEMPLATE_DECL \n+\t\t   && DECL_CONV_FN_P (OVL_CURRENT (fndecl))\n \t\t   && DECL_CONV_FN_P (function))\n \t    /* The method in the class is a member template\n \t       conversion operator.  We are declaring another"}, {"sha": "d20a44d9f280ba9771adf13951384621bf58192d", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/161c12b0bf44568bd062d6b9309973bd3901065f/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/161c12b0bf44568bd062d6b9309973bd3901065f/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=161c12b0bf44568bd062d6b9309973bd3901065f", "patch": "@@ -2809,6 +2809,10 @@ identifier_type (decl)\n     }\n   if (looking_for_template && really_overloaded_fn (decl))\n     {\n+      /* See through a baselink.  */\n+      if (TREE_CODE (decl) == TREE_LIST)\n+\tdecl = TREE_VALUE (decl);\n+\n       for (t = decl; t != NULL_TREE; t = OVL_CHAIN (t))\n \tif (DECL_FUNCTION_TEMPLATE_P (OVL_FUNCTION (t))) \n \t  return PFUNCNAME;"}, {"sha": "a9b00202663930918e768359f04dfda82d22f92f", "filename": "gcc/cp/parse.c", "status": "modified", "additions": 566, "deletions": 557, "changes": 1123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/161c12b0bf44568bd062d6b9309973bd3901065f/gcc%2Fcp%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/161c12b0bf44568bd062d6b9309973bd3901065f/gcc%2Fcp%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.c?ref=161c12b0bf44568bd062d6b9309973bd3901065f"}, {"sha": "35016259c9b7bb40554be282ed69e4723e496adf", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/161c12b0bf44568bd062d6b9309973bd3901065f/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/161c12b0bf44568bd062d6b9309973bd3901065f/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=161c12b0bf44568bd062d6b9309973bd3901065f", "patch": "@@ -1316,7 +1316,16 @@ notype_unqualified_id:\n \t;\n \n do_id:\n-\t\t{ $$ = do_identifier ($<ttype>-1, 1, NULL_TREE); }\n+\t\t{\n+\t\t  /* If lastiddecl is a TREE_LIST, it's a baselink, which\n+\t\t     means that we're in an expression like S::f<int>, so\n+\t\t     don't do_identifier; we only do that for unqualified\n+\t\t     identifiers.  */\n+\t\t  if (lastiddecl && TREE_CODE (lastiddecl) != TREE_LIST)\n+\t\t    $$ = do_identifier ($<ttype>-1, 1, NULL_TREE);\n+\t\t  else\n+\t\t    $$ = $<ttype>-1;\n+\t\t}\n \n template_id:\n           PFUNCNAME '<' do_id template_arg_list_opt template_close_bracket "}, {"sha": "0b9ba9ab694a43e52a099db3583098c97e7dd526", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/161c12b0bf44568bd062d6b9309973bd3901065f/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/161c12b0bf44568bd062d6b9309973bd3901065f/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=161c12b0bf44568bd062d6b9309973bd3901065f", "patch": "@@ -75,6 +75,7 @@ static tree saved_trees;\n #define UNIFY_ALLOW_MORE_CV_QUAL 1\n #define UNIFY_ALLOW_LESS_CV_QUAL 2\n #define UNIFY_ALLOW_DERIVED 4\n+#define UNIFY_ALLOW_INTEGER 8\n \n static int unify PROTO((tree, tree, tree, tree, int, int*));\n static int resolve_overloaded_unification PROTO((tree, tree, tree, tree,\n@@ -7304,7 +7305,10 @@ check_cv_quals_for_unify (strict, arg, parm)\n      UNIFY_ALLOW_DERIVED:\n        Allow the deduced ARG to be a template base class of ARG,\n        or a pointer to a template base class of the type pointed to by\n-       ARG.  */\n+       ARG.\n+     UNIFY_ALLOW_INTEGER:\n+       Allow any integral type to be deduced.  See the TEMPLATE_PARM_INDEX\n+       case for more information.  */\n \n int\n unify (tparms, targs, parm, arg, strict, explicit_mask)\n@@ -7487,6 +7491,22 @@ unify (tparms, targs, parm, arg, strict, explicit_mask)\n \t    my_friendly_abort (42);\n \t}\n \n+      /* [temp.deduct.type] If, in the declaration of a function template\n+\t with a non-type template-parameter, the non-type\n+\t template-parameter is used in an expression in the function\n+\t parameter-list and, if the corresponding template-argument is\n+\t deduced, the template-argument type shall match the type of the\n+\t template-parameter exactly, except that a template-argument\n+\t deduced from an array bound may be of any integral type.  */\n+      if (same_type_p (TREE_TYPE (arg), TREE_TYPE (parm)))\n+\t/* OK */;\n+      else if ((strict & UNIFY_ALLOW_INTEGER)\n+\t       && (TREE_CODE (TREE_TYPE (parm)) == INTEGER_TYPE\n+\t\t   || TREE_CODE (TREE_TYPE (parm)) == BOOLEAN_TYPE))\n+\t/* OK */;\n+      else\n+\treturn 1;\n+\n       TREE_VEC_ELT (targs, idx) = copy_to_permanent (arg);\n       return 0;\n \n@@ -7560,11 +7580,13 @@ unify (tparms, targs, parm, arg, strict, explicit_mask)\n \t{\n \t  if (TYPE_MIN_VALUE (parm) && TYPE_MIN_VALUE (arg)\n \t      && unify (tparms, targs, TYPE_MIN_VALUE (parm),\n-\t\t\tTYPE_MIN_VALUE (arg), UNIFY_ALLOW_NONE, explicit_mask))\n+\t\t\tTYPE_MIN_VALUE (arg), UNIFY_ALLOW_INTEGER,\n+\t\t\texplicit_mask))\n \t    return 1;\n \t  if (TYPE_MAX_VALUE (parm) && TYPE_MAX_VALUE (arg)\n \t      && unify (tparms, targs, TYPE_MAX_VALUE (parm),\n-\t\t\tTYPE_MAX_VALUE (arg), UNIFY_ALLOW_NONE, explicit_mask))\n+\t\t\tTYPE_MAX_VALUE (arg), UNIFY_ALLOW_INTEGER,\n+\t\t\texplicit_mask))\n \t    return 1;\n \t}\n       /* We use the TYPE_MAIN_VARIANT since we have already\n@@ -7695,8 +7717,7 @@ unify (tparms, targs, parm, arg, strict, explicit_mask)\n \t\t\t\t\t     integer_type_node,\n \t\t\t\t\t     arg, t2));\n \n-\t  return unify (tparms, targs, t1, t, UNIFY_ALLOW_NONE,\n-\t\t\texplicit_mask);\n+\t  return unify (tparms, targs, t1, t, strict, explicit_mask);\n \t}\n       /* else fall through */\n "}, {"sha": "021559520072689a3697c35e862f45264db037af", "filename": "gcc/cp/search.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/161c12b0bf44568bd062d6b9309973bd3901065f/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/161c12b0bf44568bd062d6b9309973bd3901065f/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=161c12b0bf44568bd062d6b9309973bd3901065f", "patch": "@@ -3311,6 +3311,12 @@ add_conversions (binfo)\n       if (!tmp || ! DECL_CONV_FN_P (OVL_CURRENT (tmp)))\n \tbreak;\n \n+      if (TREE_CODE (tmp) == OVERLOAD)\n+\t{\n+\t  my_friendly_assert (TREE_CHAIN (tmp) == NULL_TREE, 981121);\n+\t  tmp = OVL_FUNCTION (tmp);\n+\t}\n+\n       /* We don't want to mark 'name' until we've seen all the overloads\n \t in this class; we could be overloading on the quals of 'this'.  */\n       if (name && name != DECL_NAME (tmp))"}, {"sha": "8be0f987aca7db5bd688f4534ecff85a11ad2abe", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/161c12b0bf44568bd062d6b9309973bd3901065f/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/161c12b0bf44568bd062d6b9309973bd3901065f/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=161c12b0bf44568bd062d6b9309973bd3901065f", "patch": "@@ -1370,9 +1370,9 @@ build_overload (decl, chain)\n      tree decl;\n      tree chain;\n {\n-  if (!chain)\n+  if (! chain && TREE_CODE (decl) != TEMPLATE_DECL)\n     return decl;\n-  if (TREE_CODE (chain) != OVERLOAD)\n+  if (chain && TREE_CODE (chain) != OVERLOAD)\n     chain = ovl_cons (chain, NULL_TREE);\n   return ovl_cons (decl, chain);\n }"}]}