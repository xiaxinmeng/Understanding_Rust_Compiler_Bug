{"sha": "c718078fad945f5ccfc00ed41b86a3da65a4dc55", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzcxODA3OGZhZDk0NWY1Y2NmYzAwZWQ0MWI4NmEzZGE2NWE0ZGM1NQ==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1997-05-06T22:43:11Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1997-05-06T22:43:11Z"}, "message": "entered into RCS\n\nFrom-SVN: r14022", "tree": {"sha": "97c60de5d1bf8d127fc09bfb7d31634e5d0cf416", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/97c60de5d1bf8d127fc09bfb7d31634e5d0cf416"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c718078fad945f5ccfc00ed41b86a3da65a4dc55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c718078fad945f5ccfc00ed41b86a3da65a4dc55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c718078fad945f5ccfc00ed41b86a3da65a4dc55", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c718078fad945f5ccfc00ed41b86a3da65a4dc55/comments", "author": null, "committer": null, "parents": [{"sha": "beb53fb84a96ecfc7b5f207df6ed13014ec23a9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/beb53fb84a96ecfc7b5f207df6ed13014ec23a9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/beb53fb84a96ecfc7b5f207df6ed13014ec23a9d"}], "stats": {"total": 360, "additions": 360, "deletions": 0}, "files": [{"sha": "ad553df7e8c3d62b6ed075f63b67ab777537b263", "filename": "gcc/doschk.c", "status": "added", "additions": 360, "deletions": 0, "changes": 360, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c718078fad945f5ccfc00ed41b86a3da65a4dc55/gcc%2Fdoschk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c718078fad945f5ccfc00ed41b86a3da65a4dc55/gcc%2Fdoschk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoschk.c?ref=c718078fad945f5ccfc00ed41b86a3da65a4dc55", "patch": "@@ -0,0 +1,360 @@\n+/*\n+**  DosFCheck - check file names for DOS consistency\n+**\n+**  Distribute freely, it only encourages DOS compatibility!\n+**  - DJ Delorie\n+*/\n+\n+/* This file is not part of GCC.  */\n+\n+#include <stdio.h>\n+#ifdef __MSDOS__\n+#include <alloc.h>\n+#else\n+#include <malloc.h>\n+#endif\n+#include <ctype.h>\n+#include <string.h>\n+\n+typedef struct ENT\n+{\n+  struct ENT *next;\n+  char *dos_name;\n+  char *full_name;\n+  char *path;\n+  int tagged;\n+} ENT;\n+\n+ENT *eroot = 0;\n+\n+int first_inv = 1;\n+int first_msg = 1;\n+\n+/****************************************************************\\\n+ *  Utility routines\t\t\t\t\t\t*\n+\\****************************************************************/\n+\n+void\n+invalid_msg ()\n+{\n+  if (first_inv)\n+    {\n+      if (first_msg)\n+\tfirst_msg = 0;\n+      else\n+\tputchar ('\\n');\n+      printf (\"The following files are not valid DOS file names:\\n\");\n+      first_inv = 0;\n+    }\n+}\n+\n+ENT *\n+alloc_ent ()\n+{\n+  ENT *rv = (ENT *)malloc (sizeof (ENT));\n+  if (rv == 0)\n+    {\n+      fprintf (stderr, \"Unable to allocate memory for an ENT\\n\");\n+      exit (1);\n+    }\n+  memset (rv, 0, sizeof (ENT));\n+  return rv;\n+}\n+\n+void\n+fill_ent (ent, path)\n+ENT *ent;\n+char *path;\n+{\n+  char *first = path;\n+  char *null = path+strlen (path);\n+  char *last_slash = strrchr (path, '/');\n+  char *cp, *dp;\n+  int dots_seen, chars_seen;\n+  \n+  if (last_slash+1 == null)\n+    {\n+      * --null = '\\0';\n+      last_slash = strrchr (path, '/');\n+    }\n+  \n+  if (!last_slash)\n+    {\n+      last_slash = first-1;\n+    }\n+\n+  if (null-last_slash < 13)\n+    ent->dos_name = (char *)malloc (null-last_slash);\n+  else\n+    ent->dos_name = (char *)malloc (13);\n+  ent->full_name = (char *)malloc (null-last_slash);\n+  ent->path = (char *)malloc (last_slash-first+1);\n+\n+  strcpy (ent->full_name, last_slash+1);\n+  if (last_slash > first)\n+    {\n+      strncpy (ent->path, first, last_slash-first);\n+      ent->path[last_slash-first] = '\\0';\n+    }\n+  else\n+    *ent->path = '\\0';\n+\n+  cp = last_slash+1;\n+  dp = ent->dos_name;\n+  dots_seen = 0;\n+  chars_seen = 0;\n+  while (1)\n+    {\n+      if (! *cp)\n+\tbreak;\n+      switch (*cp)\n+\t{\n+\tcase '.':\n+\t  if (cp == last_slash+1 && strcmp (last_slash+1, \".\"))\n+\t    {\n+\t      invalid_msg ();\n+\t      printf (\"%s - file name cannot start with dot\\n\", path);\n+\t      *dp = 0;\n+\t      break;\n+\t    }\n+\t  if (dots_seen == 1)\n+\t    {\n+\t      invalid_msg ();\n+\t      printf (\"%s - too many dots\\n\", path);\n+\t      *dp = '\\0';\n+\t      break;\n+\t    }\n+\t  *dp++ = '.';\n+\t  chars_seen = 0;\n+\t  dots_seen++;\n+\t  break;\n+\tcase '\"':\n+\tcase '*':\n+\tcase '+':\n+\tcase ',':\n+\tcase ';':\n+\tcase '<':\n+\tcase '=':\n+\tcase '>':\n+\tcase '?':\n+\tcase '[':\n+\tcase '\\\\':\n+\tcase ']':\n+\tcase '|':\n+\t  invalid_msg ();\n+\t  printf (\"%s - invalid character `%c'\\n\", path, *cp);\n+\t  *dp++ = '?';\n+\t  chars_seen++;\n+\t  break;\n+\tdefault:\n+\t  if (dots_seen)\n+\t    {\n+\t      if (chars_seen >= 3)\n+\t\tbreak;\n+\t    }\n+\t  else\n+\t    if (chars_seen >= 8)\n+\t      break;\n+\t  if ((*cp <= ' ') || (*cp >= 0x7f))\n+\t    {\n+\t      invalid_msg ();\n+\t      printf (\"%s - invalid character `%c'\\n\", path, *cp);\n+\t      *dp++ = '?';\n+\t      chars_seen++;\n+\t      break;\n+\t    }\n+\t  if (islower (*cp))\n+\t    *dp++ = toupper (*cp);\n+\t  else\n+\t    *dp++ = *cp;\n+\t  chars_seen++;\n+\t  break;\n+\t}\n+      cp++;\n+    }\n+  *dp++ = '\\0';\n+}\n+\n+int\n+compare_ent_dosname (e1, e2)\n+ENT **e1;\n+ENT **e2;\n+{\n+  int r = strcmp ((*e1)->dos_name, (*e2)->dos_name);\n+  if (r == 0)\n+    r = strcmp ((*e1)->path, (*e2)->path);\n+  if (r == 0)\n+    r = strcmp ((*e1)->full_name, (*e2)->full_name);\n+  return r;\n+}\n+\n+int\n+compare_ent_fullname (e1, e2)\n+ENT **e1;\n+ENT **e2;\n+{\n+  int r = strncmp ((*e1)->full_name, (*e2)->full_name, 14);\n+  if (r == 0)\n+    r = strcmp ((*e1)->path, (*e2)->path);\n+  if (r == 0)\n+    r = strcmp ((*e1)->full_name, (*e2)->full_name);\n+  return r;\n+}\n+\n+char *\n+mpath (ent)\n+ENT *ent;\n+{\n+  static char buf[500];\n+  if (ent->path && ent->path[0])\n+    sprintf (buf, \"%s/%s\", ent->path, ent->full_name);\n+  else\n+    return ent->full_name;\n+  return buf;\n+}\n+\n+/****************************************************************\\\n+ *  List handling routines\t\t\t\t\t*\n+\\****************************************************************/\n+\n+void\n+add_ent (ent)\n+ENT *ent;\n+{\n+  ent->next = eroot;\n+  eroot = ent;\n+}\n+\n+void\n+handle_input (line)\n+char *line;\n+{\n+  ENT *ent = alloc_ent ();\n+  fill_ent (ent, line);\n+  add_ent (ent);\n+}\n+\n+void\n+display_problems ()\n+{\n+  ENT **elist, *ent;\n+  int ecount, i, first, first_err;\n+  \n+  for (ecount=0, ent=eroot; ent; ent=ent->next, ecount++);\n+  elist = (ENT **)malloc (sizeof (ENT *) * ecount);\n+  for (ecount=0, ent=eroot; ent; ent=ent->next, ecount++)\n+    elist[ecount] = ent;\n+\n+  qsort (elist, ecount, sizeof (ENT *), compare_ent_dosname);\n+\n+  first = 1;\n+  first_err = 1;\n+  for (i=0; i<ecount-1; i++)\n+    {\n+      if ((strcmp (elist[i]->dos_name, elist[i+1]->dos_name) == 0)\n+\t  && (strcmp (elist[i]->path, elist[i+1]->path) == 0))\n+\t{\n+\t  if (first_err)\n+\t    {\n+\t      if (first_msg)\n+\t\tfirst_msg = 0;\n+\t      else\n+\t\tputchar ('\\n');\n+\t      printf (\"The following resolve to the same DOS file names:\\n\");\n+\t      first_err = 0;\n+\t    }\n+\t  if (first)\n+\t    {\n+\t      printf (\"%14s : %s\\n\", elist[i]->dos_name, mpath (elist[i]));\n+\t      first = 0;\n+\t    }\n+\t  printf (\"\\t\\t %s\\n\", mpath (elist[i+1]));\n+\t}\n+      else\n+\tfirst = 1;\n+    }\n+\n+  qsort (elist, ecount, sizeof (ENT *), compare_ent_fullname);\n+\n+  first = 1;\n+  first_err = 1;\n+  for (i=0; i<ecount-1; i++)\n+    {\n+      if ((strncmp (elist[i]->full_name, elist[i+1]->full_name, 14) == 0)\n+\t  && (strcmp (elist[i]->path, elist[i+1]->path) == 0))\n+\t{\n+\t  if (first_err)\n+\t    {\n+\t      if (first_msg)\n+\t\tfirst_msg = 0;\n+\t      else\n+\t\tputchar ('\\n');\n+\t      printf (\"The following resolve to the same SysV file names:\\n\");\n+\t      first_err = 0;\n+\t    }\n+\t  if (first)\n+\t    {\n+\t      printf (\"%.14s : %s\\n\", elist[i]->full_name, mpath (elist[i]));\n+\t      first = 0;\n+\t      elist[i]->tagged = 1;\n+\t    }\n+\t  printf (\"\\t\\t %s\\n\", mpath (elist[i+1]));\n+\t  elist[i+1]->tagged = 1;\n+\t}\n+      else\n+\tfirst = 1;\n+    }\n+\n+  first_err = 1;\n+  for (i=0; i<ecount; i++)\n+    {\n+      if ((strlen (elist[i]->full_name) > 14) && !elist[i]->tagged)\n+\t{\n+\t  if (first_err)\n+\t    {\n+\t      if (first_msg)\n+\t\tfirst_msg = 0;\n+\t      else\n+\t\tputchar ('\\n');\n+\t      printf (\"The following file names are too long for SysV:\\n\");\n+\t      first_err = 0;\n+\t    }\n+\t  printf (\"%.14s : %s\\n\", elist[i]->full_name, mpath (elist[i]));\n+\t}\n+    }\n+}\n+\n+/****************************************************************\\\n+ *  Main entry point\t\t\t\t\t\t*\n+\\****************************************************************/\n+\n+main (argc, argv)\n+int argc;\n+char **argv;\n+{\n+  FILE *input = stdin;\n+  if (argc > 1)\n+    {\n+      input = fopen (argv[1], \"r\");\n+      if (!input)\n+\t{\n+\t  perror (argv[1]);\n+\t  exit (1);\n+\t}\n+    }\n+  while (1)\n+    {\n+      char line[500];\n+      char *lp;\n+      fgets (line, 500, input);\n+      if (feof (input))\n+\tbreak;\n+      lp = line+strlen (line);\n+      while ((lp != line) && (*lp <= ' '))\n+\tlp--;\n+      lp[1] = 0;\n+      handle_input (line);\n+    }\n+  display_problems ();\n+}\n+"}]}