{"sha": "fa57ac97e9e50108ba984a0a6bfe3d54d339f059", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmE1N2FjOTdlOWU1MDEwOGJhOTg0YTBhNmJmZTNkNTRkMzM5ZjA1OQ==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2007-08-14T08:41:44Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-08-14T08:41:44Z"}, "message": "exp_aggr.ads, [...] (Convert_Aggr_In_Allocator): Use Insert_Actions to place expanded aggregate code before allocator...\n\n2007-08-14  Ed Schonberg  <schonberg@adacore.com>\n\t    Gary Dismukes  <dismukes@adacore.com>\n\n\t* exp_aggr.ads, \n\texp_aggr.adb (Convert_Aggr_In_Allocator): Use Insert_Actions to place\n\texpanded aggregate code before allocator, and ahead of declaration for\n\ttemporary, to prevent access before elaboration when the allocator is\n\tan actual for an access parameter.\n\t(Is_Static_Dispatch_Table_Aggregate): Handle aggregates initializing\n\tthe TSD and the table of interfaces.\n\t(Convert_To_Assignments): Augment the test for delaying aggregate\n\texpansion for limited return statements to include the case of extended\n\treturns, to prevent creation of an unwanted transient scope.\n\t(Is_Static_Dispatch_Table_Aggregate): New subprogram.\n\t(Expand_Array_Aggregate): Handle aggregates associated with\n\tstatically allocated dispatch tables.\n\t(Expand_Record_Aggregate): Handle aggregates associated with\n\tstatically allocated dispatch tables.\n\t(Gen_Ctrl_Actions_For_Aggr): Generate a finalization list for allocators\n\tof anonymous access type.\n\nFrom-SVN: r127429", "tree": {"sha": "7ea896bb4b8bad0b372cd54653b5c14306238718", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7ea896bb4b8bad0b372cd54653b5c14306238718"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fa57ac97e9e50108ba984a0a6bfe3d54d339f059", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa57ac97e9e50108ba984a0a6bfe3d54d339f059", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa57ac97e9e50108ba984a0a6bfe3d54d339f059", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa57ac97e9e50108ba984a0a6bfe3d54d339f059/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "dc0961329fdc886ce02cda642873705e76b2ccaa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc0961329fdc886ce02cda642873705e76b2ccaa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc0961329fdc886ce02cda642873705e76b2ccaa"}], "stats": {"total": 167, "additions": 125, "deletions": 42}, "files": [{"sha": "f79f0e26be2fa9228930e20a7dd886ac9475afa7", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 116, "deletions": 37, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa57ac97e9e50108ba984a0a6bfe3d54d339f059/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa57ac97e9e50108ba984a0a6bfe3d54d339f059/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=fa57ac97e9e50108ba984a0a6bfe3d54d339f059", "patch": "@@ -93,6 +93,10 @@ package body Exp_Aggr is\n    --  N is an aggregate (record or array). Checks the presence of default\n    --  initialization (<>) in any component (Ada 2005: AI-287)\n \n+   function Is_Static_Dispatch_Table_Aggregate (N : Node_Id) return Boolean;\n+   --  Returns true if N is an aggregate used to initialize the components\n+   --  of an statically allocated dispatch table.\n+\n    ------------------------------------------------------\n    -- Local subprograms for Record Aggregate Expansion --\n    ------------------------------------------------------\n@@ -115,9 +119,10 @@ package body Exp_Aggr is\n    --      aggregate\n \n    procedure Convert_To_Assignments (N : Node_Id; Typ : Entity_Id);\n-   --  N is an N_Aggregate or an N_Extension_Aggregate. Typ is the type of\n-   --  the aggregate. Transform the given aggregate into a sequence of\n-   --  assignments component per component.\n+   --  N is an N_Aggregate or an N_Extension_Aggregate. Typ is the type of the\n+   --  aggregate (which can only be a record type, this procedure is only used\n+   --  for record types). Transform the given aggregate into a sequence of\n+   --  assignments performed component by component.\n \n    function Build_Record_Aggr_Code\n      (N                             : Node_Id;\n@@ -2059,11 +2064,14 @@ package body Exp_Aggr is\n \n          if Controlled_Type (Typ) then\n \n-            --  The current aggregate belongs to an allocator which acts as\n-            --  the root of a coextension chain.\n+            --  The current aggregate belongs to an allocator which creates\n+            --  an object through an anonymous access type or acts as the root\n+            --  of a coextension chain.\n \n             if Present (Alloc)\n-              and then Is_Coextension_Root (Alloc)\n+              and then\n+                (Is_Coextension_Root (Alloc)\n+                   or else Ekind (Etype (Alloc)) = E_Anonymous_Access_Type)\n             then\n                if No (Associated_Final_Chain (Etype (Alloc))) then\n                   Build_Final_List (Alloc, Etype (Alloc));\n@@ -2116,7 +2124,7 @@ package body Exp_Aggr is\n                --  aggregate to its coextension chain.\n \n                if Present (Alloc)\n-                 and then Is_Coextension (Alloc)\n+                 and then Is_Dynamic_Coextension (Alloc)\n                then\n                   if No (Coextensions (Alloc)) then\n                      Set_Coextensions (Alloc, New_Elmt_List);\n@@ -3024,7 +3032,11 @@ package body Exp_Aggr is\n    -- Convert_Aggr_In_Allocator --\n    -------------------------------\n \n-   procedure Convert_Aggr_In_Allocator (Decl, Aggr : Node_Id) is\n+   procedure Convert_Aggr_In_Allocator\n+     (Alloc :  Node_Id;\n+      Decl  :  Node_Id;\n+      Aggr  :  Node_Id)\n+   is\n       Loc  : constant Source_Ptr := Sloc (Aggr);\n       Typ  : constant Entity_Id  := Etype (Aggr);\n       Temp : constant Entity_Id  := Defining_Identifier (Decl);\n@@ -3045,6 +3057,14 @@ package body Exp_Aggr is\n       --  the access discriminant is itself placed on the stack. Otherwise,\n       --  some other finalization list is used (see exp_ch4.adb).\n \n+      --  Decl has been inserted in the code ahead of the allocator, using\n+      --  Insert_Actions. We use Insert_Actions below as well, to ensure that\n+      --  subsequent insertions are done in the proper order. Using (for\n+      --  example) Insert_Actions_After to place the expanded aggregate\n+      --  immediately after Decl may lead to out-of-order references if the\n+      --  allocator has generated a finalization list, as when the designated\n+      --  object is controlled and there is an open transient scope.\n+\n       if Ekind (Access_Type) = E_Anonymous_Access_Type\n         and then Nkind (Associated_Node_For_Itype (Access_Type)) =\n                                               N_Discriminant_Specification\n@@ -3074,14 +3094,14 @@ package body Exp_Aggr is\n \n             if Has_Task (Typ) then\n                Build_Task_Allocate_Block_With_Init_Stmts (L, Aggr, Init_Stmts);\n-               Insert_Actions_After (Decl, L);\n+               Insert_Actions (Alloc, L);\n             else\n-               Insert_Actions_After (Decl, Init_Stmts);\n+               Insert_Actions (Alloc, Init_Stmts);\n             end if;\n          end;\n \n       else\n-         Insert_Actions_After (Decl,\n+         Insert_Actions (Alloc,\n            Late_Expansion\n              (Aggr, Typ, Occ, Flist,\n               Associated_Final_Chain (Base_Type (Access_Type))));\n@@ -3269,6 +3289,9 @@ package body Exp_Aggr is\n       Parent_Node : Node_Id;\n \n    begin\n+      pragma Assert (not Is_Static_Dispatch_Table_Aggregate (N));\n+      pragma Assert (Is_Record_Type (Typ));\n+\n       Parent_Node := Parent (N);\n       Parent_Kind := Nkind (Parent_Node);\n \n@@ -3293,34 +3316,47 @@ package body Exp_Aggr is\n          end;\n       end if;\n \n-      --  Just set the Delay flag in the following cases where the\n-      --  transformation will be done top down from above:\n+      --  Just set the Delay flag in the cases where the transformation\n+      --  will be done top down from above.\n \n-      --    - internal aggregate (transformed when expanding the parent)\n+      if False\n \n-      --    - allocators  (see Convert_Aggr_In_Allocator)\n+         --  Internal aggregate (transformed when expanding the parent)\n \n-      --    - object decl (see Convert_Aggr_In_Object_Decl)\n+         or else Parent_Kind = N_Aggregate\n+         or else Parent_Kind = N_Extension_Aggregate\n+         or else Parent_Kind = N_Component_Association\n \n-      --    - safe assignments (see Convert_Aggr_Assignments)\n-      --      so far only the assignments in the init procs are taken\n-      --      into account\n+         --  Allocator (see Convert_Aggr_In_Allocator)\n \n-      --    - (Ada 2005) A limited type in a return statement, which will\n-      --       be rewritten as an extended return and may have its own\n-      --       finalization machinery.\n+         or else Parent_Kind = N_Allocator\n \n-      if Parent_Kind = N_Aggregate\n-        or else Parent_Kind = N_Extension_Aggregate\n-        or else Parent_Kind = N_Component_Association\n-        or else Parent_Kind = N_Allocator\n-        or else (Parent_Kind = N_Object_Declaration and then not Unc_Decl)\n-        or else (Parent_Kind = N_Assignment_Statement\n-                  and then Inside_Init_Proc)\n-        or else\n-          (Is_Limited_Record (Typ)\n-            and then Present (Parent (Parent (N)))\n-            and then Nkind (Parent (Parent (N))) = N_Return_Statement)\n+         --  Object declaration (see Convert_Aggr_In_Object_Decl)\n+\n+         or else (Parent_Kind = N_Object_Declaration and then not Unc_Decl)\n+\n+         --  Safe assignment (see Convert_Aggr_Assignments). So far only the\n+         --  assignments in init procs are taken into account.\n+\n+         or else (Parent_Kind = N_Assignment_Statement\n+                   and then Inside_Init_Proc)\n+\n+         --  (Ada 2005) An inherently limited type in a return statement,\n+         --  which will be handled in a build-in-place fashion, and may be\n+         --  rewritten as an extended return and have its own finalization\n+         --  machinery. In the case of a simple return, the aggregate needs\n+         --  to be delayed until the scope for the return statement has been\n+         --  created, so that any finalization chain will be associated with\n+         --  that scope. For extended returns, we delay expansion to avoid the\n+         --  creation of an unwanted transient scope that could result in\n+         --  premature finalization of the return object (which is built in\n+         --  in place within the caller's scope).\n+\n+         or else\n+          (Is_Inherently_Limited_Type (Typ)\n+            and then\n+              (Nkind (Parent (Parent_Node)) = N_Extended_Return_Statement\n+                or else Nkind (Parent_Node) = N_Simple_Return_Statement))\n       then\n          Set_Expansion_Delayed (N);\n          return;\n@@ -4710,10 +4746,14 @@ package body Exp_Aggr is\n          return;\n       end if;\n \n-      --  If all aggregate components are compile-time known and\n-      --  the aggregate has been flattened, nothing left to do.\n+      --  If all aggregate components are compile-time known and the aggregate\n+      --  has been flattened, nothing left to do. The same occurs if the\n+      --  aggregate is used to initialize the components of an statically\n+      --  allocated dispatch table.\n \n-      if Compile_Time_Known_Aggregate (N) then\n+      if Compile_Time_Known_Aggregate (N)\n+        or else Is_Static_Dispatch_Table_Aggregate (N)\n+      then\n          Set_Expansion_Delayed (N, False);\n          return;\n       end if;\n@@ -5165,6 +5205,12 @@ package body Exp_Aggr is\n       then\n          Expand_Atomic_Aggregate (N, Typ);\n          return;\n+\n+      --  No special management required for aggregates used to initialize\n+      --  statically allocated dispatch tables\n+\n+      elsif Is_Static_Dispatch_Table_Aggregate (N) then\n+         return;\n       end if;\n \n       --  Ada 2005 (AI-318-2): We need to convert to assignments if components\n@@ -5607,6 +5653,39 @@ package body Exp_Aggr is\n       end if;\n    end Is_Delayed_Aggregate;\n \n+   ----------------------------------------\n+   -- Is_Static_Dispatch_Table_Aggregate --\n+   ----------------------------------------\n+\n+   function Is_Static_Dispatch_Table_Aggregate (N : Node_Id) return Boolean is\n+      Typ : constant Entity_Id := Base_Type (Etype (N));\n+\n+   begin\n+      return Static_Dispatch_Tables\n+        and then VM_Target = No_VM\n+        and then RTU_Loaded (Ada_Tags)\n+\n+         --  Avoid circularity when rebuilding the compiler\n+\n+        and then Cunit_Entity (Get_Source_Unit (N)) /= RTU_Entity (Ada_Tags)\n+        and then (Typ = RTE (RE_Dispatch_Table_Wrapper)\n+                    or else\n+                  Typ = RTE (RE_Address_Array)\n+                    or else\n+                  Typ = RTE (RE_Type_Specific_Data)\n+                    or else\n+                  Typ = RTE (RE_Tag_Table)\n+                    or else\n+                  (RTE_Available (RE_Interface_Data)\n+                     and then Typ = RTE (RE_Interface_Data))\n+                    or else\n+                  (RTE_Available (RE_Interfaces_Array)\n+                     and then Typ = RTE (RE_Interfaces_Array))\n+                    or else\n+                  (RTE_Available (RE_Interface_Data_Element)\n+                     and then Typ = RTE (RE_Interface_Data_Element)));\n+   end Is_Static_Dispatch_Table_Aggregate;\n+\n    --------------------\n    -- Late_Expansion --\n    --------------------\n@@ -6131,7 +6210,7 @@ package body Exp_Aggr is\n \n          if No (Component_Associations (N)) then\n \n-            --  Verify that all components are static integers.\n+            --  Verify that all components are static integers\n \n             Expr := First (Expressions (N));\n             while Present (Expr) loop"}, {"sha": "cb393287ea5b9313dd13381cef1548924de98929", "filename": "gcc/ada/exp_aggr.ads", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa57ac97e9e50108ba984a0a6bfe3d54d339f059/gcc%2Fada%2Fexp_aggr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa57ac97e9e50108ba984a0a6bfe3d54d339f059/gcc%2Fada%2Fexp_aggr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.ads?ref=fa57ac97e9e50108ba984a0a6bfe3d54d339f059", "patch": "@@ -40,11 +40,15 @@ package Exp_Aggr is\n    --  an N_Aggregate or N_Extension_Aggregate with Expansion_Delayed\n    --  This procedure performs in-place aggregate assignment.\n \n-   procedure Convert_Aggr_In_Allocator (Decl, Aggr : Node_Id);\n-   --  Decl is an access N_Object_Declaration (produced during\n-   --  allocator expansion), Aggr is the initial expression aggregate\n-   --  of an allocator. This procedure perform in-place aggregate\n-   --  assignment in the newly allocated object.\n+   procedure Convert_Aggr_In_Allocator\n+     (Alloc :  Node_Id;\n+      Decl  :  Node_Id;\n+      Aggr  :  Node_Id);\n+   --  Alloc is the allocator whose expression is the aggregate Aggr.\n+   --  Decl is an N_Object_Declaration created during allocator expansion.\n+   --  This procedure perform in-place aggregate assignment into the\n+   --  temporary declared in Decl, and the allocator becomes an access to\n+   --  that temporary.\n \n    procedure Convert_Aggr_In_Assignment (N : Node_Id);\n    --  If the right-hand side of an assignment is an aggregate, expand the"}]}