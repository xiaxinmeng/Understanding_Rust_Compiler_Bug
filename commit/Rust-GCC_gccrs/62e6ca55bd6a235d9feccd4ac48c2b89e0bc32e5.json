{"sha": "62e6ca55bd6a235d9feccd4ac48c2b89e0bc32e5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjJlNmNhNTViZDZhMjM1ZDlmZWNjZDRhYzQ4YzJiODllMGJjMzJlNQ==", "commit": {"author": {"name": "Janis Johnson", "email": "janis187@us.ibm.com", "date": "2002-05-16T18:37:06Z"}, "committer": {"name": "Janis Johnson", "email": "janis@gcc.gnu.org", "date": "2002-05-16T18:37:06Z"}, "message": "loop.h (struct loop_info): Add member has_prefetch.\n\n\t* loop.h (struct loop_info): Add member has_prefetch.\n\t* loop.c (PREFETCH_CONDITIONAL): Change default to 1.\n\t(prescan_loop): Initialize has_prefetch.\n\t(struct prefetch_info): Change prefetch_in_loop and\n\tprefetch_before_loop from bit fields to ints.\n\t(emit_prefetch_instructions): Several small fixes.\n\t(check_dbra_loop): Don't reverse loop that uses prefetch.\n\nFrom-SVN: r53524", "tree": {"sha": "809cab32b29980a57c931b62a5e25b8142a82b84", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/809cab32b29980a57c931b62a5e25b8142a82b84"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/62e6ca55bd6a235d9feccd4ac48c2b89e0bc32e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62e6ca55bd6a235d9feccd4ac48c2b89e0bc32e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62e6ca55bd6a235d9feccd4ac48c2b89e0bc32e5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62e6ca55bd6a235d9feccd4ac48c2b89e0bc32e5/comments", "author": null, "committer": null, "parents": [{"sha": "1e6347d8b985c539ddce9bce71b3483ace55ec74", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e6347d8b985c539ddce9bce71b3483ace55ec74", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e6347d8b985c539ddce9bce71b3483ace55ec74"}], "stats": {"total": 233, "additions": 142, "deletions": 91}, "files": [{"sha": "acbf227b20866dec4bf4db9e3ff5bb951e3982f8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e6ca55bd6a235d9feccd4ac48c2b89e0bc32e5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e6ca55bd6a235d9feccd4ac48c2b89e0bc32e5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=62e6ca55bd6a235d9feccd4ac48c2b89e0bc32e5", "patch": "@@ -1,3 +1,13 @@\n+2002-05-16  Janis Johnson  <janis187@us.ibm.com>\n+\n+\t* loop.h (struct loop_info): Add member has_prefetch.\n+\t* loop.c (PREFETCH_CONDITIONAL): Change default to 1.\n+\t(prescan_loop): Initialize has_prefetch.\n+\t(struct prefetch_info): Change prefetch_in_loop and\n+\tprefetch_before_loop from bit fields to ints.\n+\t(emit_prefetch_instructions): Several small fixes.\n+\t(check_dbra_loop): Don't reverse loop that uses prefetch.\n+\n 2002-05-16  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>\n \n \t* Makefile.in: Allow for PWDCMD to override hardcoded pwd."}, {"sha": "7a5b1a4499f94ae5a6aeacb08ac4987c873c7ea6", "filename": "gcc/loop.c", "status": "modified", "additions": 130, "deletions": 91, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e6ca55bd6a235d9feccd4ac48c2b89e0bc32e5/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e6ca55bd6a235d9feccd4ac48c2b89e0bc32e5/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=62e6ca55bd6a235d9feccd4ac48c2b89e0bc32e5", "patch": "@@ -143,7 +143,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n /* Prefetch even if the GIV is in conditional code.  */\n #ifndef PREFETCH_CONDITIONAL\n-#define PREFETCH_CONDITIONAL 0\n+#define PREFETCH_CONDITIONAL 1\n #endif\n \n /* If the loop requires more prefetches than the target can process in\n@@ -2462,6 +2462,7 @@ prescan_loop (loop)\n   loop_info->pre_header_has_call = 0;\n   loop_info->has_call = 0;\n   loop_info->has_nonconst_call = 0;\n+  loop_info->has_prefetch = 0;\n   loop_info->has_volatile = 0;\n   loop_info->has_tablejump = 0;\n   loop_info->has_multiple_exit_targets = 0;\n@@ -3587,11 +3588,9 @@ struct prefetch_info\n \t\t\t\t   This is set only for loops with known\n \t\t\t\t   iteration counts and is 0xffffffff\n \t\t\t\t   otherwise.  */\n+  int prefetch_in_loop;\t\t/* Number of prefetch insns in loop.  */\n+  int prefetch_before_loop;\t/* Number of prefetch insns before loop.  */\n   unsigned int write : 1;\t/* 1 for read/write prefetches.  */\n-  unsigned int prefetch_in_loop : 1;\n-  \t\t\t\t/* 1 for those chosen for prefetching.  */\n-  unsigned int prefetch_before_loop : 1;\n-  \t\t\t\t/* 1 for those chosen for prefetching.  */\n };\n \n /* Data used by check_store function.  */\n@@ -3778,7 +3777,9 @@ emit_prefetch_instructions (loop)\n   int num_prefetches = 0;\n   int num_real_prefetches = 0;\n   int num_real_write_prefetches = 0;\n-  int ahead;\n+  int num_prefetches_before = 0;\n+  int num_write_prefetches_before = 0;\n+  int ahead = 0;\n   int i;\n   struct iv_class *bl;\n   struct induction *iv;\n@@ -3886,29 +3887,29 @@ emit_prefetch_instructions (loop)\n \t    {\n \t      stride = INTVAL (iv->mult_val) * basestride;\n \t      if (stride < 0)\n-\t        {\n+\t\t{\n \t\t  stride = -stride;\n \t\t  stride_sign = -1;\n-\t        }\n+\t\t}\n \n \t      /* On some targets, reversed order prefetches are not\n-\t         worthwhile.  */\n+\t\t worthwhile.  */\n \t      if (PREFETCH_NO_REVERSE_ORDER && stride_sign < 0)\n \t\tignore_reason = \"reversed order stride\";\n \n \t      /* Prefetch of accesses with an extreme stride might not be\n-\t         worthwhile, either.  */\n+\t\t worthwhile, either.  */\n \t      else if (PREFETCH_NO_EXTREME_STRIDE\n \t\t       && stride > PREFETCH_EXTREME_STRIDE)\n \t\tignore_reason = \"extreme stride\";\n \n \t      /* Ignore GIVs with varying add values; we can't predict the\n-\t         value for the next iteration.  */\n+\t\t value for the next iteration.  */\n \t      else if (!loop_invariant_p (loop, iv->add_val))\n \t\tignore_reason = \"giv has varying add value\";\n \n \t      /* Ignore GIVs in the nested loops; they ought to have been\n-\t         handled already.  */\n+\t\t handled already.  */\n \t      else if (iv->maybe_multiple)\n \t\tignore_reason = \"giv is in nested loop\";\n \t    }\n@@ -3930,14 +3931,20 @@ emit_prefetch_instructions (loop)\n \t  address = simplify_gen_binary (PLUS, Pmode, temp, address);\n \t  index = remove_constant_addition (&address);\n \n-\t  index += size;\n \t  d.mem_write = 0;\n \t  d.mem_address = *iv->location;\n \n \t  /* When the GIV is not always executed, we might be better off by\n \t     not dirtying the cache pages.  */\n \t  if (PREFETCH_CONDITIONAL || iv->always_executed)\n \t    note_stores (PATTERN (iv->insn), check_store, &d);\n+\t  else\n+\t    {\n+\t      if (loop_dump_stream)\n+\t\tfprintf (loop_dump_stream, \"Prefetch: Ignoring giv at %d: %s\\n\",\n+\t\t\t INSN_UID (iv->insn), \"in conditional code.\");\n+\t      continue;\n+\t    }\n \n \t  /* Attempt to find another prefetch to the same array and see if we\n \t     can merge this one.  */\n@@ -4004,7 +4011,7 @@ emit_prefetch_instructions (loop)\n       /* Attempt to calculate the total number of bytes fetched by all\n \t iterations of the loop.  Avoid overflow.  */\n       if (LOOP_INFO (loop)->n_iterations\n-          && ((unsigned HOST_WIDE_INT) (0xffffffff / info[i].stride)\n+\t  && ((unsigned HOST_WIDE_INT) (0xffffffff / info[i].stride)\n \t      >= LOOP_INFO (loop)->n_iterations))\n \tinfo[i].total_bytes = info[i].stride * LOOP_INFO (loop)->n_iterations;\n       else\n@@ -4016,14 +4023,14 @@ emit_prefetch_instructions (loop)\n       if (PREFETCH_ONLY_DENSE_MEM)\n \tif (density * 256 > PREFETCH_DENSE_MEM * 100\n \t    && (info[i].total_bytes / PREFETCH_BLOCK\n-\t        >= PREFETCH_BLOCKS_BEFORE_LOOP_MIN))\n+\t\t>= PREFETCH_BLOCKS_BEFORE_LOOP_MIN))\n \t  {\n \t    info[i].prefetch_before_loop = 1;\n \t    info[i].prefetch_in_loop\n \t      = (info[i].total_bytes / PREFETCH_BLOCK\n-\t         > PREFETCH_BLOCKS_BEFORE_LOOP_MAX);\n+\t\t > PREFETCH_BLOCKS_BEFORE_LOOP_MAX);\n \t  }\n-        else\n+\telse\n \t  {\n \t    info[i].prefetch_in_loop = 0, info[i].prefetch_before_loop = 0;\n \t    if (loop_dump_stream)\n@@ -4034,29 +4041,64 @@ emit_prefetch_instructions (loop)\n       else\n \tinfo[i].prefetch_in_loop = 1, info[i].prefetch_before_loop = 1;\n \n-      if (info[i].prefetch_in_loop)\n+      /* Find how many prefetch instructions we'll use within the loop.  */\n+      if (info[i].prefetch_in_loop != 0)\n \t{\n-\t  num_real_prefetches += ((info[i].stride + PREFETCH_BLOCK - 1)\n+\t  info[i].prefetch_in_loop = ((info[i].stride + PREFETCH_BLOCK - 1)\n \t\t\t\t  / PREFETCH_BLOCK);\n+\t  num_real_prefetches += info[i].prefetch_in_loop;\n \t  if (info[i].write)\n-\t    num_real_write_prefetches\n-\t      += (info[i].stride + PREFETCH_BLOCK - 1) / PREFETCH_BLOCK;\n+\t    num_real_write_prefetches += info[i].prefetch_in_loop;\n \t}\n     }\n \n-  if (loop_dump_stream)\n+  /* Determine how many iterations ahead to prefetch within the loop, based\n+     on how many prefetches we currently expect to do within the loop.  */\n+  if (num_real_prefetches != 0)\n+    {\n+      if ((ahead = SIMULTANEOUS_PREFETCHES / num_real_prefetches) == 0)\n+\t{\n+\t  if (loop_dump_stream)\n+\t    fprintf (loop_dump_stream,\n+\t\t     \"Prefetch: ignoring prefetches within loop: ahead is zero; %d < %d\\n\",\n+\t\t     SIMULTANEOUS_PREFETCHES, num_real_prefetches);\n+\t  num_real_prefetches = 0, num_real_write_prefetches = 0;\n+\t}\n+    }\n+  /* We'll also use AHEAD to determine how many prefetch instructions to\n+     emit before a loop, so don't leave it zero.  */\n+  if (ahead == 0)\n+    ahead = PREFETCH_BLOCKS_BEFORE_LOOP_MAX;\n+\n+  for (i = 0; i < num_prefetches; i++)\n     {\n-      for (i = 0; i < num_prefetches; i++)\n+      /* Update if we've decided not to prefetch anything within the loop.  */\n+      if (num_real_prefetches == 0)\n+\tinfo[i].prefetch_in_loop = 0;\n+\n+      /* Find how many prefetch instructions we'll use before the loop.  */\n+      if (info[i].prefetch_before_loop != 0)\n+\t{\n+\t  int n = info[i].total_bytes / PREFETCH_BLOCK;\n+\t  if (n > ahead)\n+\t    n = ahead;\n+\t  info[i].prefetch_before_loop = n;\n+\t  num_prefetches_before += n;\n+\t  if (info[i].write)\n+\t    num_write_prefetches_before += n;\n+\t}\n+\n+      if (loop_dump_stream)\n \t{\n \t  if (info[i].prefetch_in_loop == 0\n \t      && info[i].prefetch_before_loop == 0)\n \t    continue;\n \t  fprintf (loop_dump_stream, \"Prefetch insn: %d\",\n \t\t   INSN_UID (info[i].giv->insn));\n \t  fprintf (loop_dump_stream,\n-\t\t   \"; in loop: %s; before: %s; %s\\n\",\n-\t\t   info[i].prefetch_in_loop ? \"yes\" : \"no\",\n-\t\t   info[i].prefetch_before_loop ? \"yes\" : \"no\",\n+\t\t   \"; in loop: %d; before: %d; %s\\n\",\n+\t\t   info[i].prefetch_in_loop,\n+\t\t   info[i].prefetch_before_loop,\n \t\t   info[i].write ? \"read/write\" : \"read only\");\n \t  fprintf (loop_dump_stream,\n \t\t   \" density: %d%%; bytes_accessed: %u; total_bytes: %u\\n\",\n@@ -4070,93 +4112,89 @@ emit_prefetch_instructions (loop)\n \t  print_rtl (loop_dump_stream, info[i].base_address);\n \t  fprintf (loop_dump_stream, \"\\n\");\n \t}\n-\n-      fprintf (loop_dump_stream, \"Real prefetches needed: %d (write: %d)\\n\",\n-\t       num_real_prefetches, num_real_write_prefetches);\n     }\n \n-  if (!num_real_prefetches)\n-    return;\n-\n-  ahead = SIMULTANEOUS_PREFETCHES / num_real_prefetches;\n-\n-  if (ahead == 0)\n+  if (num_real_prefetches + num_prefetches_before > 0)\n     {\n+      /* Record that this loop uses prefetch instructions.  */\n+      LOOP_INFO (loop)->has_prefetch = 1;\n+\n       if (loop_dump_stream)\n-\tfprintf (loop_dump_stream,\n-\t\t \"Prefetch: ignoring loop: ahead is zero; %d < %d\\n\",\n-\t\t SIMULTANEOUS_PREFETCHES, num_real_prefetches);\n-      return;\n+\t{\n+\t  fprintf (loop_dump_stream, \"Real prefetches needed within loop: %d (write: %d)\\n\",\n+\t\t   num_real_prefetches, num_real_write_prefetches);\n+\t  fprintf (loop_dump_stream, \"Real prefetches needed before loop: %d (write: %d)\\n\",\n+\t\t   num_prefetches_before, num_write_prefetches_before);\n+\t}\n     }\n \n   for (i = 0; i < num_prefetches; i++)\n     {\n-      if (info[i].prefetch_in_loop)\n-\t{\n-\t  int y;\n+      int y;\n \n-\t  for (y = 0; y < ((info[i].stride + PREFETCH_BLOCK - 1)\n-\t\t\t   / PREFETCH_BLOCK); y++)\n+      for (y = 0; y < info[i].prefetch_in_loop; y++)\n+\t{\n+\t  rtx loc = copy_rtx (*info[i].giv->location);\n+\t  rtx insn;\n+\t  int bytes_ahead = PREFETCH_BLOCK * (ahead + y);\n+\t  rtx before_insn = info[i].giv->insn;\n+\t  rtx prev_insn = PREV_INSN (info[i].giv->insn);\n+\n+\t  /* We can save some effort by offsetting the address on\n+\t     architectures with offsettable memory references.  */\n+\t  if (offsettable_address_p (0, VOIDmode, loc))\n+\t    loc = plus_constant (loc, bytes_ahead);\n+\t  else\n \t    {\n-\t      rtx loc = copy_rtx (*info[i].giv->location);\n-\t      rtx insn;\n-\t      int bytes_ahead = PREFETCH_BLOCK * (ahead + y);\n-\t      rtx before_insn = info[i].giv->insn;\n-\t      rtx prev_insn = PREV_INSN (info[i].giv->insn);\n-\n-\t      /* We can save some effort by offsetting the address on\n-\t\t architectures with offsettable memory references.  */\n-\t      if (offsettable_address_p (0, VOIDmode, loc))\n-\t\tloc = plus_constant (loc, bytes_ahead);\n-\t      else\n-\t\t{\n-\t\t  rtx reg = gen_reg_rtx (Pmode);\n-\t\t  loop_iv_add_mult_emit_before (loop, loc, const1_rtx,\n-\t\t      \t\t\t\tGEN_INT (bytes_ahead), reg,\n-\t\t\t\t  \t\t0, before_insn);\n-\t\t  loc = reg;\n-\t\t}\n+\t      rtx reg = gen_reg_rtx (Pmode);\n+\t      loop_iv_add_mult_emit_before (loop, loc, const1_rtx,\n+\t\t      \t\t\t    GEN_INT (bytes_ahead), reg,\n+\t\t\t\t  \t    0, before_insn);\n+\t      loc = reg;\n+\t    }\n \n-\t      /* Make sure the address operand is valid for prefetch.  */\n-\t      if (! (*insn_data[(int)CODE_FOR_prefetch].operand[0].predicate)\n-\t\t    (loc,\n-\t\t     insn_data[(int)CODE_FOR_prefetch].operand[0].mode))\n-\t\tloc = force_reg (Pmode, loc);\n-\t      emit_insn_before (gen_prefetch (loc, GEN_INT (info[i].write),\n-\t\t                              GEN_INT (3)),\n-\t\t\t\tbefore_insn);\n-\n-\t      /* Check all insns emitted and record the new GIV\n-\t\t information.  */\n-\t      insn = NEXT_INSN (prev_insn);\n-\t      while (insn != before_insn)\n-\t\t{\n-\t\t  insn = check_insn_for_givs (loop, insn,\n-\t\t\t\t\t      info[i].giv->always_executed,\n-\t\t\t\t\t      info[i].giv->maybe_multiple);\n-\t\t  insn = NEXT_INSN (insn);\n-\t\t}\n+\t  /* Make sure the address operand is valid for prefetch.  */\n+\t  if (! (*insn_data[(int)CODE_FOR_prefetch].operand[0].predicate)\n+\t\t  (loc, insn_data[(int)CODE_FOR_prefetch].operand[0].mode))\n+\t    loc = force_reg (Pmode, loc);\n+\t  emit_insn_before (gen_prefetch (loc, GEN_INT (info[i].write),\n+\t\t\t\t\t  GEN_INT (3)),\n+\t\t\t    before_insn);\n+\n+\t  /* Check all insns emitted and record the new GIV\n+\t     information.  */\n+\t  insn = NEXT_INSN (prev_insn);\n+\t  while (insn != before_insn)\n+\t    {\n+\t      insn = check_insn_for_givs (loop, insn,\n+\t\t\t\t\t  info[i].giv->always_executed,\n+\t\t\t\t\t  info[i].giv->maybe_multiple);\n+\t      insn = NEXT_INSN (insn);\n \t    }\n \t}\n \n-      if (PREFETCH_BEFORE_LOOP && info[i].prefetch_before_loop)\n+      if (PREFETCH_BEFORE_LOOP)\n \t{\n-\t  int y;\n-\n-\t  /* Emit INSNs before the loop to fetch the first cache lines.  */\n-\t  for (y = 0;\n-\t       (!info[i].prefetch_in_loop || y < ahead)\n-\t       && y * PREFETCH_BLOCK < (int) info[i].total_bytes; y ++)\n+\t  /* Emit insns before the loop to fetch the first cache lines or,\n+\t     if we're not prefetching within the loop, everything we expect\n+\t     to need.  */\n+\t  for (y = 0; y < info[i].prefetch_before_loop; y++)\n \t    {\n \t      rtx reg = gen_reg_rtx (Pmode);\n \t      rtx loop_start = loop->start;\n+\t      rtx init_val = info[i].class->initial_value;\n \t      rtx add_val = simplify_gen_binary (PLUS, Pmode,\n \t\t\t\t\t\t info[i].giv->add_val,\n \t\t\t\t\t\t GEN_INT (y * PREFETCH_BLOCK));\n \n-\t      loop_iv_add_mult_emit_before (loop, info[i].class->initial_value,\n+\t      /* Functions called by LOOP_IV_ADD_EMIT_BEFORE expect a\n+\t\t non-constant INIT_VAL to have the same mode as REG, which\n+\t\t in this case we know to be Pmode.  */\n+\t      if (GET_MODE (init_val) != Pmode && !CONSTANT_P (init_val))\n+\t\tinit_val = convert_to_mode (Pmode, init_val, 0);\n+\t      loop_iv_add_mult_emit_before (loop, init_val,\n \t\t\t\t\t    info[i].giv->mult_val,\n-\t\t\t\t            add_val, reg, 0, loop_start);\n+\t\t\t\t\t    add_val, reg, 0, loop_start);\n \t      emit_insn_before (gen_prefetch (reg, GEN_INT (info[i].write),\n \t\t\t\t\t      GEN_INT (3)),\n \t\t\t\tloop_start);\n@@ -8195,12 +8233,13 @@ check_dbra_loop (loop, insn_count)\n \n       if ((num_nonfixed_reads <= 1\n \t   && ! loop_info->has_nonconst_call\n+\t   && ! loop_info->has_prefetch\n \t   && ! loop_info->has_volatile\n \t   && reversible_mem_store\n \t   && (bl->giv_count + bl->biv_count + loop_info->num_mem_sets\n \t       + num_unmoved_movables (loop) + compare_and_branch == insn_count)\n \t   && (bl == ivs->list && bl->next == 0))\n-\t  || no_use_except_counting)\n+\t  || (no_use_except_counting && ! loop_info->has_prefetch))\n \t{\n \t  rtx tem;\n "}, {"sha": "3df9cfc33fcc50cbdc7bc64ed967466b8ff88ff9", "filename": "gcc/loop.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e6ca55bd6a235d9feccd4ac48c2b89e0bc32e5/gcc%2Floop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e6ca55bd6a235d9feccd4ac48c2b89e0bc32e5/gcc%2Floop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.h?ref=62e6ca55bd6a235d9feccd4ac48c2b89e0bc32e5", "patch": "@@ -304,6 +304,8 @@ struct loop_info\n   int has_libcall;\n   /* Nonzero if there is a non constant call in the current loop.  */\n   int has_nonconst_call;\n+  /* Nonzero if there is a prefetch instruction in the current loop.  */\n+  int has_prefetch;\n   /* Nonzero if there is a volatile memory reference in the current\n      loop.  */\n   int has_volatile;"}]}