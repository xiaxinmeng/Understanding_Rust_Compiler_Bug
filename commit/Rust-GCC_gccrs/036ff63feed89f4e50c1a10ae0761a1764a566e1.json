{"sha": "036ff63feed89f4e50c1a10ae0761a1764a566e1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDM2ZmY2M2ZlZWQ4OWY0ZTUwYzFhMTBhZTA3NjFhMTc2NGE1NjZlMQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2004-12-10T16:33:25Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2004-12-10T16:33:25Z"}, "message": "frv-modes.def: Fix comment typos.\n\n\t* config/frv/frv-modes.def: Fix comment typos.\n\t(CC_NZ): Define new mode.\n\t* config/frv/frv-protos.h (frv_select_cc_mode): Declare.\n\t(condexec_intop_cmp_operator): Delete.\n\t* config/frv/frv.c (comparison_string): New function.\n\t(frv_print_operand): Use it to handle 'c' and 'C'.\n\t(relational_operator): Redefine in terms of integer_relational_operator\n\tand float_relational_operator.\n\t(signed_relational_operator, unsigned_relational_operator): Delete.\n\t(integer_relational_operator): New predicate, combining the above.\n\tCheck the mode of the first operand but leave frv.md to check the rest.\n\t(float_relational_operator): Just check the mode of the first operand\n\tand leave frv.md to check the rest.\n\t(intop_compare_operator): Assume the result is compared with zero\n\tin mode CC_NZmode.  Allow PLUS and MINUS.  Leave frv.md to check\n\tthe operand predicates.\n\t(condexec_intop_cmp_operator): Delete.\n\t(frv_ifcvt_modify_tests, frv_ifcvt_modify_multiple_tests)\n\t(frv_hard_regno_mode_ok): Handle CC_NZmode.\n\t(frv_select_cc_mode): New function.\n\t* config/frv/frv.h (SELECT_CC_MODE): Use frv_select_cc_mode.\n\t(REVERSIBLE_CC_MODE): Include CC_NZmode.\n\t(PREDICATE_CODES): Replace entries for signed_relational_operand and\n\tunsigned_relational_operator with one for integer_relational_operator.\n\tDelete entry for condexec_intop_cmp_operator.\n\t* config/frv/frv.md (movcc_nz, *internal_movcc_nz, reload_incc_nz)\n\t(reload_outcc_nz, *cmpsi_cc_nz, *cond_exec_cmpsi_cc_nz): New patterns.\n\t(*combo_intop_compare2, *combo_intop_compare4): Delete.\n\t(*combo_intop_compare1): Change mode to CC_NZ.\n\t(*combo_intop_compare2): Likewise.  Renamed from *combo_intop_compare3.\n\t(branch_{un,}signed_true, branch_{un,}signed_false)\n\t(*scc_{un,}signed, *scc_neg1_{un,}signed, *ck_{un,}signed)\n\t(*movqicc_internal1_{un,}signed, *movqicc_internal2_{un,}signed)\n\t(*movhicc_internal1_{un,}signed, *movhicc_internal2_{un,}signed)\n\t(*movsicc_internal1_{un,}signed, *movsicc_internal2_{un,}signed)\n\t(*movsfcc_has_fprs_{un,}signed, *movsfcc_no_fprs_{un,}signed)\n\t(*return_{unsigned_,}true, *return_{unsigned_,}false): Merge these\n\tpattern pairs.  Use integer_relational_operator.  Remove mode from\n\ticc_operand.\n\nFrom-SVN: r91997", "tree": {"sha": "dc34f9cef9a1ac5207f699c12b14ce9d1b79440c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dc34f9cef9a1ac5207f699c12b14ce9d1b79440c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/036ff63feed89f4e50c1a10ae0761a1764a566e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/036ff63feed89f4e50c1a10ae0761a1764a566e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/036ff63feed89f4e50c1a10ae0761a1764a566e1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/036ff63feed89f4e50c1a10ae0761a1764a566e1/comments", "author": null, "committer": null, "parents": [{"sha": "2742a1edf52524ccaf6d406327695912a198bb65", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2742a1edf52524ccaf6d406327695912a198bb65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2742a1edf52524ccaf6d406327695912a198bb65"}], "stats": {"total": 879, "additions": 322, "deletions": 557}, "files": [{"sha": "fa08cb45122dbf41778c2c2b38ef35982665276d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/036ff63feed89f4e50c1a10ae0761a1764a566e1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/036ff63feed89f4e50c1a10ae0761a1764a566e1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=036ff63feed89f4e50c1a10ae0761a1764a566e1", "patch": "@@ -1,3 +1,45 @@\n+2004-12-10  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* config/frv/frv-modes.def: Fix comment typos.\n+\t(CC_NZ): Define new mode.\n+\t* config/frv/frv-protos.h (frv_select_cc_mode): Declare.\n+\t(condexec_intop_cmp_operator): Delete.\n+\t* config/frv/frv.c (comparison_string): New function.\n+\t(frv_print_operand): Use it to handle 'c' and 'C'.\n+\t(relational_operator): Redefine in terms of integer_relational_operator\n+\tand float_relational_operator.\n+\t(signed_relational_operator, unsigned_relational_operator): Delete.\n+\t(integer_relational_operator): New predicate, combining the above.\n+\tCheck the mode of the first operand but leave frv.md to check the rest.\n+\t(float_relational_operator): Just check the mode of the first operand\n+\tand leave frv.md to check the rest.\n+\t(intop_compare_operator): Assume the result is compared with zero\n+\tin mode CC_NZmode.  Allow PLUS and MINUS.  Leave frv.md to check\n+\tthe operand predicates.\n+\t(condexec_intop_cmp_operator): Delete.\n+\t(frv_ifcvt_modify_tests, frv_ifcvt_modify_multiple_tests)\n+\t(frv_hard_regno_mode_ok): Handle CC_NZmode.\n+\t(frv_select_cc_mode): New function.\n+\t* config/frv/frv.h (SELECT_CC_MODE): Use frv_select_cc_mode.\n+\t(REVERSIBLE_CC_MODE): Include CC_NZmode.\n+\t(PREDICATE_CODES): Replace entries for signed_relational_operand and\n+\tunsigned_relational_operator with one for integer_relational_operator.\n+\tDelete entry for condexec_intop_cmp_operator.\n+\t* config/frv/frv.md (movcc_nz, *internal_movcc_nz, reload_incc_nz)\n+\t(reload_outcc_nz, *cmpsi_cc_nz, *cond_exec_cmpsi_cc_nz): New patterns.\n+\t(*combo_intop_compare2, *combo_intop_compare4): Delete.\n+\t(*combo_intop_compare1): Change mode to CC_NZ.\n+\t(*combo_intop_compare2): Likewise.  Renamed from *combo_intop_compare3.\n+\t(branch_{un,}signed_true, branch_{un,}signed_false)\n+\t(*scc_{un,}signed, *scc_neg1_{un,}signed, *ck_{un,}signed)\n+\t(*movqicc_internal1_{un,}signed, *movqicc_internal2_{un,}signed)\n+\t(*movhicc_internal1_{un,}signed, *movhicc_internal2_{un,}signed)\n+\t(*movsicc_internal1_{un,}signed, *movsicc_internal2_{un,}signed)\n+\t(*movsfcc_has_fprs_{un,}signed, *movsfcc_no_fprs_{un,}signed)\n+\t(*return_{unsigned_,}true, *return_{unsigned_,}false): Merge these\n+\tpattern pairs.  Use integer_relational_operator.  Remove mode from\n+\ticc_operand.\n+\n 2004-12-10  Mark Dettinger  <dettinge@de.ibm.com>\n \n \t* config/s390/s390.c (struct processor_costs): New fields ml,"}, {"sha": "cab8c16837ff3d96024dbc7d239a6f17b50657ee", "filename": "gcc/config/frv/frv-modes.def", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/036ff63feed89f4e50c1a10ae0761a1764a566e1/gcc%2Fconfig%2Ffrv%2Ffrv-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/036ff63feed89f4e50c1a10ae0761a1764a566e1/gcc%2Fconfig%2Ffrv%2Ffrv-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv-modes.def?ref=036ff63feed89f4e50c1a10ae0761a1764a566e1", "patch": "@@ -20,12 +20,14 @@ Boston, MA 02111-1307, USA.  */\n \n /* On the FRV, the CC modes used are:\n \n-   CCmode\tset ICC's from comparing signed integers\n-   CC_UNSmode\tset ICC's from comparing unsigned integers\n-   CC_FPmode\tset FCC's from comparing floating point\n-   CC_CCRmode\tset CCR's to do conditional execution */\n+   CCmode\tset ICCs from comparing signed integers\n+   CC_UNSmode\tset ICCs from comparing unsigned integers\n+   CC_NZmode\tset ICCs for comparisons that just need the Z and N flags\n+   CC_FPmode\tset FCCs from comparing floating point\n+   CC_CCRmode\tset CCRs to do conditional execution */\n \n CC_MODE (CC_UNS);\n+CC_MODE (CC_NZ);\n CC_MODE (CC_FP);\n CC_MODE (CC_CCR);\n "}, {"sha": "6b7bd14138834289ad1568ef99a161edec5b592e", "filename": "gcc/config/frv/frv-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/036ff63feed89f4e50c1a10ae0761a1764a566e1/gcc%2Fconfig%2Ffrv%2Ffrv-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/036ff63feed89f4e50c1a10ae0761a1764a566e1/gcc%2Fconfig%2Ffrv%2Ffrv-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv-protos.h?ref=036ff63feed89f4e50c1a10ae0761a1764a566e1", "patch": "@@ -138,6 +138,7 @@ extern int frv_hard_regno_nregs\t\t(int, enum machine_mode);\n extern int frv_class_max_nregs\t\t(enum reg_class class,\n \t\t\t\t\t enum machine_mode mode);\n extern int frv_legitimate_constant_p\t(rtx);\n+extern enum machine_mode frv_select_cc_mode (enum rtx_code, rtx, rtx);\n #endif\t/* RTX_CODE */\n \n extern int direct_return_p\t\t(void);\n@@ -217,7 +218,6 @@ extern int condexec_sf_conv_operator\t(rtx, enum machine_mode);\n extern int condexec_sf_add_operator\t(rtx, enum machine_mode);\n extern int condexec_memory_operand\t(rtx, enum machine_mode);\n extern int intop_compare_operator\t(rtx, enum machine_mode);\n-extern int condexec_intop_cmp_operator\t(rtx, enum machine_mode);\n extern int acc_operand\t\t\t(rtx, enum machine_mode);\n extern int even_acc_operand\t\t(rtx, enum machine_mode);\n extern int quad_acc_operand\t\t(rtx, enum machine_mode);"}, {"sha": "bef28f58a8ef1c1dc67b5663fa928202f61eaf6d", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 83, "deletions": 225, "changes": 308, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/036ff63feed89f4e50c1a10ae0761a1764a566e1/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/036ff63feed89f4e50c1a10ae0761a1764a566e1/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=036ff63feed89f4e50c1a10ae0761a1764a566e1", "patch": "@@ -276,6 +276,7 @@ static void frv_print_operand_memory_reference_reg\n \t\t\t\t\t\t(FILE *, rtx);\n static void frv_print_operand_memory_reference\t(FILE *, rtx, int);\n static int frv_print_operand_jump_hint\t\t(rtx);\n+static const char *comparison_string\t\t(enum rtx_code, rtx);\n static FRV_INLINE int frv_regno_ok_for_base_p\t(int, int);\n static rtx single_set_pattern\t\t\t(rtx);\n static int frv_function_contains_far_jump\t(void);\n@@ -2683,6 +2684,29 @@ frv_print_operand_jump_hint (rtx insn)\n }\n \n \f\n+/* Return the comparison operator to use for CODE given that the ICC\n+   register is OP0.  */\n+\n+static const char *\n+comparison_string (enum rtx_code code, rtx op0)\n+{\n+  bool is_nz_p = GET_MODE (op0) == CC_NZmode;\n+  switch (code)\n+    {\n+    default:  output_operand_lossage (\"bad condition code\");\n+    case EQ:  return \"eq\";\n+    case NE:  return \"ne\";\n+    case LT:  return is_nz_p ? \"n\" : \"lt\";\n+    case LE:  return \"le\";\n+    case GT:  return \"gt\";\n+    case GE:  return is_nz_p ? \"p\" : \"ge\";\n+    case LTU: return is_nz_p ? \"no\" : \"c\";\n+    case LEU: return is_nz_p ? \"eq\" : \"ls\";\n+    case GTU: return is_nz_p ? \"ne\" : \"hi\";\n+    case GEU: return is_nz_p ? \"ra\" : \"nc\";\n+    }\n+}\n+\n /* Print an operand to an assembler instruction.\n \n    `%' followed by a letter and a digit says to output an operand in an\n@@ -2786,45 +2810,13 @@ frv_print_operand (FILE * file, rtx x, int code)\n \n     case 'C':\n       /* Print appropriate test for integer branch false operation.  */\n-      switch (GET_CODE (x))\n-\t{\n-\tdefault:\n-\t  fatal_insn (\"Bad insn to frv_print_operand, 'C' modifier:\", x);\n-\n-\tcase EQ:  fputs (\"ne\", file); break;\n-\tcase NE:  fputs (\"eq\", file); break;\n-\tcase LT:  fputs (\"ge\", file); break;\n-\tcase LE:  fputs (\"gt\", file); break;\n-\tcase GT:  fputs (\"le\", file); break;\n-\tcase GE:  fputs (\"lt\", file); break;\n-\tcase LTU: fputs (\"nc\", file); break;\n-\tcase LEU: fputs (\"hi\", file); break;\n-\tcase GTU: fputs (\"ls\", file); break;\n-\tcase GEU: fputs (\"c\",  file); break;\n-\t}\n+      fputs (comparison_string (reverse_condition (GET_CODE (x)),\n+\t\t\t\tXEXP (x, 0)), file);\n       break;\n \n-    /* case 'c': print a constant without the constant prefix.  If\n-       CONSTANT_ADDRESS_P(x) is not true, PRINT_OPERAND is called.  */\n-\n     case 'c':\n       /* Print appropriate test for integer branch true operation.  */\n-      switch (GET_CODE (x))\n-\t{\n-\tdefault:\n-\t  fatal_insn (\"Bad insn to frv_print_operand, 'c' modifier:\", x);\n-\n-\tcase EQ:  fputs (\"eq\", file); break;\n-\tcase NE:  fputs (\"ne\", file); break;\n-\tcase LT:  fputs (\"lt\", file); break;\n-\tcase LE:  fputs (\"le\", file); break;\n-\tcase GT:  fputs (\"gt\", file); break;\n-\tcase GE:  fputs (\"ge\", file); break;\n-\tcase LTU: fputs (\"c\",  file); break;\n-\tcase LEU: fputs (\"ls\", file); break;\n-\tcase GTU: fputs (\"hi\", file); break;\n-\tcase GEU: fputs (\"nc\", file); break;\n-\t}\n+      fputs (comparison_string (GET_CODE (x), XEXP (x, 0)), file);\n       break;\n \n     case 'e':\n@@ -4801,154 +4793,50 @@ sibcall_operand (rtx op, enum machine_mode mode)\n int\n relational_operator (rtx op, enum machine_mode mode)\n {\n-  rtx op0;\n-  rtx op1;\n-  int regno;\n-\n-  if (mode != VOIDmode && mode != GET_MODE (op))\n-    return FALSE;\n-\n-  switch (GET_CODE (op))\n-    {\n-    default:\n-      return FALSE;\n-\n-    case EQ:\n-    case NE:\n-    case LE:\n-    case LT:\n-    case GE:\n-    case GT:\n-    case LEU:\n-    case LTU:\n-    case GEU:\n-    case GTU:\n-      break;\n-    }\n-\n-  op1 = XEXP (op, 1);\n-  if (op1 != const0_rtx)\n-    return FALSE;\n-\n-  op0 = XEXP (op, 0);\n-  if (GET_CODE (op0) != REG)\n-    return FALSE;\n-\n-  regno = REGNO (op0);\n-  switch (GET_MODE (op0))\n-    {\n-    default:\n-      break;\n-\n-    case CCmode:\n-    case CC_UNSmode:\n-      return ICC_OR_PSEUDO_P (regno);\n-\n-    case CC_FPmode:\n-      return FCC_OR_PSEUDO_P (regno);\n-\n-    case CC_CCRmode:\n-      return CR_OR_PSEUDO_P (regno);\n-    }\n-\n-  return FALSE;\n+  return (integer_relational_operator (op, mode)\n+\t  || float_relational_operator (op, mode));\n }\n \n-/* Return true if operator is a signed integer relational operator.  */\n+/* Return true if OP is a relational operator suitable for CCmode,\n+   CC_UNSmode or CC_NZmode.  */\n \n int\n-signed_relational_operator (rtx op, enum machine_mode mode)\n+integer_relational_operator (rtx op, enum machine_mode mode)\n {\n-  rtx op0;\n-  rtx op1;\n-  int regno;\n-\n   if (mode != VOIDmode && mode != GET_MODE (op))\n     return FALSE;\n \n+  /* The allowable relations depend on the mode of the ICC register.  */\n   switch (GET_CODE (op))\n     {\n     default:\n       return FALSE;\n \n     case EQ:\n     case NE:\n-    case LE:\n     case LT:\n     case GE:\n-    case GT:\n-      break;\n-    }\n+      return (GET_MODE (XEXP (op, 0)) == CC_NZmode\n+\t      || GET_MODE (XEXP (op, 0)) == CCmode);\n \n-  op1 = XEXP (op, 1);\n-  if (op1 != const0_rtx)\n-    return FALSE;\n-\n-  op0 = XEXP (op, 0);\n-  if (GET_CODE (op0) != REG)\n-    return FALSE;\n-\n-  regno = REGNO (op0);\n-  if (GET_MODE (op0) == CCmode && ICC_OR_PSEUDO_P (regno))\n-    return TRUE;\n-\n-  if (GET_MODE (op0) == CC_CCRmode && CR_OR_PSEUDO_P (regno))\n-    return TRUE;\n-\n-  return FALSE;\n-}\n-\n-/* Return true if operator is a signed integer relational operator.  */\n-\n-int\n-unsigned_relational_operator (rtx op, enum machine_mode mode)\n-{\n-  rtx op0;\n-  rtx op1;\n-  int regno;\n-\n-  if (mode != VOIDmode && mode != GET_MODE (op))\n-    return FALSE;\n-\n-  switch (GET_CODE (op))\n-    {\n-    default:\n-      return FALSE;\n+    case LE:\n+    case GT:\n+      return GET_MODE (XEXP (op, 0)) == CCmode;\n \n-    case LEU:\n-    case LTU:\n-    case GEU:\n     case GTU:\n-      break;\n+    case GEU:\n+    case LTU:\n+    case LEU:\n+      return (GET_MODE (XEXP (op, 0)) == CC_NZmode\n+\t      || GET_MODE (XEXP (op, 0)) == CC_UNSmode);\n     }\n-\n-  op1 = XEXP (op, 1);\n-  if (op1 != const0_rtx)\n-    return FALSE;\n-\n-  op0 = XEXP (op, 0);\n-  if (GET_CODE (op0) != REG)\n-    return FALSE;\n-\n-  regno = REGNO (op0);\n-  if (GET_MODE (op0) == CC_UNSmode && ICC_OR_PSEUDO_P (regno))\n-    return TRUE;\n-\n-  if (GET_MODE (op0) == CC_CCRmode && CR_OR_PSEUDO_P (regno))\n-    return TRUE;\n-\n-  return FALSE;\n }\n \n /* Return true if operator is a floating point relational operator.  */\n \n int\n float_relational_operator (rtx op, enum machine_mode mode)\n {\n-  rtx op0;\n-  rtx op1;\n-  int regno;\n-\n   if (mode != VOIDmode && mode != GET_MODE (op))\n     return FALSE;\n \n@@ -4967,25 +4855,8 @@ float_relational_operator (rtx op, enum machine_mode mode)\n     case ORDERED:\n     case UNORDERED:\n #endif\n-      break;\n+      return GET_MODE (XEXP (op, 0)) == CC_FPmode;\n     }\n-\n-  op1 = XEXP (op, 1);\n-  if (op1 != const0_rtx)\n-    return FALSE;\n-\n-  op0 = XEXP (op, 0);\n-  if (GET_CODE (op0) != REG)\n-    return FALSE;\n-\n-  regno = REGNO (op0);\n-  if (GET_MODE (op0) == CC_FPmode && FCC_OR_PSEUDO_P (regno))\n-    return TRUE;\n-\n-  if (GET_MODE (op0) == CC_CCRmode && CR_OR_PSEUDO_P (regno))\n-    return TRUE;\n-\n-  return FALSE;\n }\n \n /* Return true if operator is EQ/NE of a conditional execution register.  */\n@@ -5227,73 +5098,29 @@ condexec_memory_operand (rtx op, enum machine_mode mode)\n   return frv_legitimate_address_p (mode, addr, reload_completed, TRUE, FALSE);\n }\n \n-/* Return true if operator is an integer binary operator that can be combined\n-   with a setcc operation.  Do not allow the arithmetic operations that could\n-   potentially overflow since the FR-V sets the condition code based on the\n-   \"true\" value of the result, not the result after truncating to a 32-bit\n-   register.  */\n+/* Return true if OP is an integer binary operator that can be combined\n+   with a (set ... (compare:CC_NZ ...)) pattern.  */\n \n int\n intop_compare_operator (rtx op, enum machine_mode mode)\n {\n-  enum machine_mode op_mode = GET_MODE (op);\n-\n-  if (mode != VOIDmode && op_mode != mode)\n-    return FALSE;\n-\n-  switch (GET_CODE (op))\n-    {\n-    default:\n-      return FALSE;\n-\n-    case AND:\n-    case IOR:\n-    case XOR:\n-    case ASHIFTRT:\n-    case LSHIFTRT:\n-      break;\n-    }\n-\n-  if (! integer_register_operand (XEXP (op, 0), SImode))\n-    return FALSE;\n-\n-  if (! gpr_or_int10_operand (XEXP (op, 1), SImode))\n-    return FALSE;\n-\n-  return TRUE;\n-}\n-\n-/* Return true if operator is an integer binary operator that can be combined\n-   with a setcc operation inside of a conditional execution.  */\n-\n-int\n-condexec_intop_cmp_operator (rtx op, enum machine_mode mode)\n-{\n-  enum machine_mode op_mode = GET_MODE (op);\n-\n-  if (mode != VOIDmode && op_mode != mode)\n+  if (mode != VOIDmode && GET_MODE (op) != mode)\n     return FALSE;\n \n   switch (GET_CODE (op))\n     {\n     default:\n       return FALSE;\n \n+    case PLUS:\n+    case MINUS:\n     case AND:\n     case IOR:\n     case XOR:\n     case ASHIFTRT:\n     case LSHIFTRT:\n-      break;\n+      return GET_MODE (op) == SImode;\n     }\n-\n-  if (! integer_register_operand (XEXP (op, 0), SImode))\n-    return FALSE;\n-\n-  if (! integer_register_operand (XEXP (op, 1), SImode))\n-    return FALSE;\n-\n-  return TRUE;\n }\n \n /* Return 1 if operand is a valid ACC register number.  */\n@@ -6895,7 +6722,7 @@ frv_ifcvt_modify_tests (ce_if_block_t *ce_info, rtx *p_true, rtx *p_false)\n   /* Allocate the appropriate temporary condition code register.  Try to\n      allocate the ICR/FCR register that corresponds to the ICC/FCC register so\n      that conditional cmp's can be done.  */\n-  if (mode == CCmode || mode == CC_UNSmode)\n+  if (mode == CCmode || mode == CC_UNSmode || mode == CC_NZmode)\n     {\n       cr_class = ICR_REGS;\n       cc_class = ICC_REGS;\n@@ -7050,7 +6877,7 @@ frv_ifcvt_modify_multiple_tests (ce_if_block_t *ce_info,\n   if (GET_CODE (cr) != REG)\n     goto fail;\n \n-  if (mode == CCmode || mode == CC_UNSmode)\n+  if (mode == CCmode || mode == CC_UNSmode || mode == CC_NZmode)\n     {\n       cr_class = ICR_REGS;\n       p_new_cr = &frv_ifcvt.extra_int_cr;\n@@ -8010,6 +7837,7 @@ frv_hard_regno_mode_ok (int regno, enum machine_mode mode)\n     {\n     case CCmode:\n     case CC_UNSmode:\n+    case CC_NZmode:\n       return ICC_P (regno) || GPR_P (regno);\n \n     case CC_CCRmode:\n@@ -8164,6 +7992,36 @@ frv_legitimate_constant_p (rtx x)\n   /* Otherwise store the constant away and do a load.  */\n   return FALSE;\n }\n+\n+/* Implement SELECT_CC_MODE.  Choose CC_FP for floating-point comparisons,\n+   CC_NZ for comparisons against zero in which a single Z or N flag test\n+   is enough, CC_UNS for other unsigned comparisons, and CC for other\n+   signed comparisons.  */\n+\n+enum machine_mode\n+frv_select_cc_mode (enum rtx_code code, rtx x, rtx y)\n+{\n+  if (GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT)\n+    return CC_FPmode;\n+\n+  switch (code)\n+    {\n+    case EQ:\n+    case NE:\n+    case LT:\n+    case GE:\n+      return y == const0_rtx ? CC_NZmode : CCmode;\n+\n+    case GTU:\n+    case GEU:\n+    case LTU:\n+    case LEU:\n+      return y == const0_rtx ? CC_NZmode : CC_UNSmode;\n+\n+    default:\n+      return CCmode;\n+    }\n+}\n \f\n /* A C expression for the cost of moving data from a register in class FROM to\n    one in class TO.  The classes are expressed using the enumeration values"}, {"sha": "16220185c80301cf596e6d409c8a88b0124572d6", "filename": "gcc/config/frv/frv.h", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/036ff63feed89f4e50c1a10ae0761a1764a566e1/gcc%2Fconfig%2Ffrv%2Ffrv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/036ff63feed89f4e50c1a10ae0761a1764a566e1/gcc%2Fconfig%2Ffrv%2Ffrv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.h?ref=036ff63feed89f4e50c1a10ae0761a1764a566e1", "patch": "@@ -2384,12 +2384,7 @@ do {\t\t\t\t\t\t\t\\\n               ? CC_NOOVmode : CCmode))\n \n    You need not define this macro if `EXTRA_CC_MODES' is not defined.  */\n-#define SELECT_CC_MODE(OP, X, Y)\t\t\t\t\t\\\n-  (GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT\t\t\t\t\\\n-   ? CC_FPmode\t\t\t\t\t\t\t\t\\\n-   : (((OP) == LEU || (OP) == GTU || (OP) == LTU || (OP) == GEU)\t\\\n-      ? CC_UNSmode\t\t\t\t\t\t\t\\\n-      : CCmode))\n+#define SELECT_CC_MODE frv_select_cc_mode\n \n /* A C expression whose value is one if it is always safe to reverse a\n    comparison whose mode is MODE.  If `SELECT_CC_MODE' can ever return MODE for\n@@ -2405,7 +2400,8 @@ do {\t\t\t\t\t\t\t\\\n \n /* On frv, don't consider floating point comparisons to be reversible.  In\n    theory, fp equality comparisons can be reversible.  */\n-#define REVERSIBLE_CC_MODE(MODE) ((MODE) == CCmode || (MODE) == CC_UNSmode)\n+#define REVERSIBLE_CC_MODE(MODE) \\\n+  ((MODE) == CCmode || (MODE) == CC_UNSmode || (MODE) == CC_NZmode)\n \n /* Frv CCR_MODE's are not reversible.  */\n #define REVERSE_CONDEXEC_PREDICATES_P(x,y)      0\n@@ -3051,8 +3047,8 @@ do {                                                                    \\\n   { \"uint16_operand\",\t\t\t{ CONST_INT }},\t\t\t\\\n   { \"relational_operator\",\t\t{ EQ, NE, LE, LT, GE, GT,\t\\\n \t\t\t\t\t  LEU, LTU, GEU, GTU }},\t\\\n-  { \"signed_relational_operator\",\t{ EQ, NE, LE, LT, GE, GT }},\t\\\n-  { \"unsigned_relational_operator\",\t{ LEU, LTU, GEU, GTU }},\t\\\n+  { \"integer_relational_operator\",\t{ EQ, NE, LE, LT, GE, GT,\t\\\n+\t\t\t\t\t  LEU, LTU, GEU, GTU }},\t\\\n   { \"float_relational_operator\",\t{ EQ, NE, LE, LT, GE, GT }},\t\\\n   { \"ccr_eqne_operator\",\t\t{ EQ, NE }},\t\t\t\\\n   { \"minmax_operator\",\t\t\t{ SMIN, SMAX, UMIN, UMAX }},\t\\\n@@ -3065,8 +3061,6 @@ do {                                                                    \\\n   { \"condexec_sf_conv_operator\",\t{ ABS, NEG }},\t\t\t\\\n   { \"intop_compare_operator\",\t\t{ PLUS, MINUS, AND, IOR, XOR,\t\\\n \t\t\t\t\t  ASHIFT, ASHIFTRT, LSHIFTRT }}, \\\n-  { \"condexec_intop_cmp_operator\",\t{ PLUS, MINUS, AND, IOR, XOR,\t\\\n-\t\t\t\t\t  ASHIFT, ASHIFTRT, LSHIFTRT }}, \\\n   { \"fpr_or_int6_operand\",\t\t{ REG, SUBREG, CONST_INT }},\t\\\n   { \"int6_operand\",\t\t\t{ CONST_INT }},\t\t\t\\\n   { \"int5_operand\",\t\t\t{ CONST_INT }},\t\t\t\\"}, {"sha": "269de036fef26bf6ffa01a95e2cc9f922adc1620", "filename": "gcc/config/frv/frv.md", "status": "modified", "additions": 167, "deletions": 316, "changes": 483, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/036ff63feed89f4e50c1a10ae0761a1764a566e1/gcc%2Fconfig%2Ffrv%2Ffrv.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/036ff63feed89f4e50c1a10ae0761a1764a566e1/gcc%2Fconfig%2Ffrv%2Ffrv.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.md?ref=036ff63feed89f4e50c1a10ae0761a1764a566e1", "patch": "@@ -2308,6 +2308,86 @@\n   \"\"\n   \"operands[3] = gen_rtx_REG (CC_CCRmode, ICR_TEMP);\")\n \n+;; Reload CC_NZmode.  This is mostly the same as the CCmode and CC_UNSmode\n+;; handling, but it uses different sequences for moving between GPRs and ICCs.\n+\n+(define_expand \"movcc_nz\"\n+  [(parallel [(set (match_operand:CC_NZ 0 \"move_destination_operand\" \"\")\n+\t\t   (match_operand:CC_NZ 1 \"move_source_operand\" \"\"))\n+\t      (clobber (match_dup 2))])]\n+  \"\"\n+  \"\n+{\n+  if (!reload_in_progress && !reload_completed)\n+    FAIL;\n+  operands[2] = gen_rtx_REG (CC_CCRmode, ICR_TEMP);\n+}\")\n+\n+(define_insn \"*internal_movcc_nz\"\n+  [(set (match_operand:CC_NZ 0 \"move_destination_operand\" \"=t,d,d,m,d\")\n+\t(match_operand:CC_NZ 1 \"move_source_operand\" \"d,d,m,d,t\"))\n+   (clobber (match_scratch:CC_CCR 2 \"=X,X,X,X,&v\"))]\n+  \"reload_in_progress || reload_completed\"\n+  \"@\n+   cmpi %1, #0, %0\n+   mov %1, %0\n+   ld%I1%U1 %M1, %0\n+   st%I0%U0 %1, %M0\n+   #\"\n+  [(set_attr \"length\" \"4,4,4,4,20\")\n+   (set_attr \"type\" \"int,int,gload,gstore,multi\")])\n+\n+;; Set the destination to a value that, when compared with zero, will\n+;; restore the value of the Z and N flags.  The values of the other\n+;; flags don't matter.  The sequence is:\n+;;\n+;;     setlos op0,#-1\n+;;     ckp op1,op2\n+;;     csub gr0,op0,op0,op2\n+;;     ckeq op1,op2\n+;;     cmov gr0,op0,op2\n+(define_split\n+  [(set (match_operand:CC_NZ 0 \"integer_register_operand\" \"\")\n+\t(match_operand:CC_NZ 1 \"icc_operand\" \"\"))\n+   (clobber (match_operand:CC_CCR 2 \"icr_operand\" \"\"))]\n+  \"reload_in_progress || reload_completed\"\n+  [(set (match_dup 3)\n+\t(const_int -1))\n+   (set (match_dup 2)\n+\t(ge:CC_CCR (match_dup 1)\n+\t\t   (const_int 0)))\n+   (cond_exec (ne:CC_CCR (match_dup 2)\n+\t\t\t (const_int 0))\n+\t      (set (match_dup 3)\n+\t\t   (neg:SI (match_dup 3))))\n+   (set (match_dup 2)\n+\t(eq:CC_CCR (match_dup 1)\n+\t\t   (const_int 0)))\n+   (cond_exec (ne:CC_CCR (match_dup 2)\n+\t\t\t (const_int 0))\n+\t      (set (match_dup 3) (const_int 0)))]\n+  \"operands[3] = simplify_gen_subreg (SImode, operands[0], CC_NZmode, 0);\")\n+\n+(define_expand \"reload_incc_nz\"\n+  [(parallel [(set (match_operand:CC_NZ 2 \"integer_register_operand\" \"=&d\")\n+\t\t   (match_operand:CC_NZ 1 \"memory_operand\" \"m\"))\n+\t      (clobber (match_scratch:CC_CCR 3 \"\"))])\n+   (parallel [(set (match_operand:CC_NZ 0 \"icc_operand\" \"=t\")\n+\t\t   (match_dup 2))\n+\t      (clobber (match_scratch:CC_CCR 4 \"\"))])]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"reload_outcc_nz\"\n+  [(parallel [(set (match_operand:CC_NZ 2 \"integer_register_operand\" \"=&d\")\n+\t\t   (match_operand:CC_NZ 1 \"icc_operand\" \"t\"))\n+\t      (clobber (match_dup 3))])\n+   (parallel [(set (match_operand:CC_NZ 0 \"memory_operand\" \"=m\")\n+\t\t   (match_dup 2))\n+\t      (clobber (match_scratch:CC_CCR 4 \"\"))])]\n+  \"\"\n+  \"operands[3] = gen_rtx_REG (CC_CCRmode, ICR_TEMP);\")\n+\n ;; Reload CC_FPmode for floating point comparisons\n ;; We use a define_expand here so that cse/gcse/combine can't accidentally\n ;; create movcc insns.  If this was a named define_insn, we would not be able\n@@ -3596,48 +3676,24 @@\n ;; ::::::::::::::::::::\n \n (define_insn \"*combo_intop_compare1\"\n-  [(set (match_operand:CC 0 \"icc_operand\" \"=t\")\n-\t(compare:CC (match_operator:SI 1 \"intop_compare_operator\"\n-\t\t\t\t       [(match_operand:SI 2 \"integer_register_operand\" \"d\")\n-\t\t\t\t\t(match_operand:SI 3 \"gpr_or_int10_operand\" \"dJ\")])\n-\t\t    (const_int 0)))]\n+  [(set (match_operand:CC_NZ 0 \"icc_operand\" \"=t\")\n+\t(compare:CC_NZ\n+\t (match_operator:SI 1 \"intop_compare_operator\"\n+\t\t       [(match_operand:SI 2 \"integer_register_operand\" \"d\")\n+\t\t\t(match_operand:SI 3 \"gpr_or_int10_operand\" \"dJ\")])\n+\t (const_int 0)))]\n   \"\"\n   \"%O1%I3cc %2, %3, %., %0\"\n   [(set_attr \"type\" \"int\")\n    (set_attr \"length\" \"4\")])\n \n (define_insn \"*combo_intop_compare2\"\n-  [(set (match_operand:CC_UNS 0 \"icc_operand\" \"=t\")\n-\t(compare:CC_UNS (match_operator:SI 1 \"intop_compare_operator\"\n-\t\t\t\t\t   [(match_operand:SI 2 \"integer_register_operand\" \"d\")\n-\t\t\t\t\t    (match_operand:SI 3 \"gpr_or_int10_operand\" \"dJ\")])\n-\t\t\t(const_int 0)))]\n-  \"\"\n-  \"%O1%I3cc %2, %3, %., %0\"\n-  [(set_attr \"type\" \"int\")\n-   (set_attr \"length\" \"4\")])\n-\n-(define_insn \"*combo_intop_compare3\"\n-  [(set (match_operand:CC 0 \"icc_operand\" \"=t\")\n-\t(compare:CC (match_operator:SI 1 \"intop_compare_operator\"\n-\t\t\t\t       [(match_operand:SI 2 \"integer_register_operand\" \"d\")\n-\t\t\t\t\t(match_operand:SI 3 \"gpr_or_int10_operand\" \"dJ\")])\n-\t\t    (const_int 0)))\n-   (set (match_operand:SI 4 \"integer_register_operand\" \"=d\")\n-\t(match_operator:SI 5 \"intop_compare_operator\"\n-\t\t\t   [(match_dup 2)\n-\t\t\t    (match_dup 3)]))]\n-  \"GET_CODE (operands[1]) == GET_CODE (operands[5])\"\n-  \"%O1%I3cc %2, %3, %4, %0\"\n-  [(set_attr \"type\" \"int\")\n-   (set_attr \"length\" \"4\")])\n-\n-(define_insn \"*combo_intop_compare4\"\n-  [(set (match_operand:CC_UNS 0 \"icc_operand\" \"=t\")\n-\t(compare:CC_UNS (match_operator:SI 1 \"intop_compare_operator\"\n-\t\t\t\t\t   [(match_operand:SI 2 \"integer_register_operand\" \"d\")\n-\t\t\t\t\t    (match_operand:SI 3 \"gpr_or_int10_operand\" \"dJ\")])\n-\t\t    (const_int 0)))\n+  [(set (match_operand:CC_NZ 0 \"icc_operand\" \"=t\")\n+\t(compare:CC_NZ\n+\t (match_operator:SI 1 \"intop_compare_operator\"\n+\t\t\t[(match_operand:SI 2 \"integer_register_operand\" \"d\")\n+\t\t\t (match_operand:SI 3 \"gpr_or_int10_operand\" \"dJ\")])\n+\t (const_int 0)))\n    (set (match_operand:SI 4 \"integer_register_operand\" \"=d\")\n \t(match_operator:SI 5 \"intop_compare_operator\"\n \t\t\t   [(match_dup 2)\n@@ -3646,7 +3702,6 @@\n   \"%O1%I3cc %2, %3, %4, %0\"\n   [(set_attr \"type\" \"int\")\n    (set_attr \"length\" \"4\")])\n-\n \f\n ;; ::::::::::::::::::::\n ;; ::\n@@ -3726,6 +3781,21 @@\n   [(set_attr \"length\" \"4\")\n    (set_attr \"type\" \"int\")])\n \n+;; The only requirement for a CC_NZmode GPR or memory value is that\n+;; comparing it against zero must set the Z and N flags appropriately.\n+;; The source operand is therefore a valid CC_NZmode value.\n+(define_insn \"*cmpsi_cc_nz\"\n+  [(set (match_operand:CC_NZ 0 \"nonimmediate_operand\" \"=t,d,m\")\n+\t(compare:CC_NZ (match_operand:SI 1 \"integer_register_operand\" \"d,d,d\")\n+\t\t       (const_int 0)))]\n+  \"\"\n+  \"@\n+   cmpi %1, #0, %0\n+   mov %1, %0\n+   st%I0%U0 %1, %M0\"\n+  [(set_attr \"length\" \"4,4,4\")\n+   (set_attr \"type\" \"int,int,gstore\")])\n+\n (define_insn \"*cmpsf_cc_fp\"\n   [(set (match_operand:CC_FP 0 \"fcc_operand\" \"=u\")\n \t(compare:CC_FP (match_operand:SF 1 \"fpr_operand\" \"f\")\n@@ -3909,75 +3979,11 @@\n ;; In the above example the %B is a directive to frv_print_operand()\n ;; to decode and print the correct branch mnemonic.\n \n-(define_insn \"*branch_signed_true\"\n-  [(set (pc)\n-\t(if_then_else (match_operator:CC 0 \"signed_relational_operator\"\n-\t\t\t\t\t [(match_operand 1 \"icc_operand\" \"t\")\n-\t\t\t\t\t  (const_int 0)])\n-\t\t      (label_ref (match_operand 2 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"*\n-{\n-  if (get_attr_length (insn) == 4)\n-    return \\\"b%c0 %1,%#,%l2\\\";\n-  else\n-    return \\\"b%C0 %1,%#,1f\\;call %l2\\\\n1:\\\";\n-}\"\n-  [(set (attr \"length\")\n-\t(if_then_else\n-\t    (and (ge (minus (match_dup 2) (pc)) (const_int -32768))\n-\t\t (le (minus (match_dup 2) (pc)) (const_int 32764)))\n-\t    (const_int 4)\n-\t    (const_int 8)))\n-   (set (attr \"far_jump\")\n-        (if_then_else\n-\t    (eq_attr \"length\" \"4\")\n-\t    (const_string \"no\")\n-\t    (const_string \"yes\")))\n-   (set (attr \"type\")\n-\t(if_then_else\n-\t    (eq_attr \"length\" \"4\")\n-\t    (const_string \"branch\")\n-\t    (const_string \"multi\")))])\n-\n-(define_insn \"*branch_signed_false\"\n-  [(set (pc)\n-\t(if_then_else (match_operator:CC 0 \"signed_relational_operator\"\n-\t\t\t\t\t [(match_operand 1 \"icc_operand\" \"t\")\n-\t\t\t\t\t  (const_int 0)])\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 2 \"\" \"\"))))]\n-  \"\"\n-  \"*\n-{\n-  if (get_attr_length (insn) == 4)\n-    return \\\"b%C0 %1,%#,%l2\\\";\n-  else\n-    return \\\"b%c0 %1,%#,1f\\;call %l2\\\\n1:\\\";\n-}\"\n-  [(set (attr \"length\")\n-\t(if_then_else\n-\t    (and (ge (minus (match_dup 2) (pc)) (const_int -32768))\n-\t\t (le (minus (match_dup 2) (pc)) (const_int 32764)))\n-\t    (const_int 4)\n-\t    (const_int 8)))\n-   (set (attr \"far_jump\")\n-        (if_then_else\n-\t    (eq_attr \"length\" \"4\")\n-\t    (const_string \"no\")\n-\t    (const_string \"yes\")))\n-   (set (attr \"type\")\n-\t(if_then_else\n-\t    (eq_attr \"length\" \"4\")\n-\t    (const_string \"branch\")\n-\t    (const_string \"multi\")))])\n-\n-(define_insn \"*branch_unsigned_true\"\n+(define_insn \"*branch_int_true\"\n   [(set (pc)\n-\t(if_then_else (match_operator:CC_UNS 0 \"unsigned_relational_operator\"\n-\t\t\t\t\t     [(match_operand 1 \"icc_operand\" \"t\")\n-\t\t\t\t\t      (const_int 0)])\n+\t(if_then_else (match_operator 0 \"integer_relational_operator\"\n+\t\t\t\t      [(match_operand 1 \"icc_operand\" \"t\")\n+\t\t\t\t       (const_int 0)])\n \t\t      (label_ref (match_operand 2 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n@@ -4005,11 +4011,11 @@\n \t    (const_string \"branch\")\n \t    (const_string \"multi\")))])\n \n-(define_insn \"*branch_unsigned_false\"\n+(define_insn \"*branch_int_false\"\n   [(set (pc)\n-\t(if_then_else (match_operator:CC_UNS 0 \"unsigned_relational_operator\"\n-\t\t\t\t\t     [(match_operand 1 \"icc_operand\" \"t\")\n-\t\t\t\t\t      (const_int 0)])\n+\t(if_then_else (match_operator 0 \"integer_relational_operator\"\n+\t\t\t\t      [(match_operand 1 \"icc_operand\" \"t\")\n+\t\t\t\t       (const_int 0)])\n \t\t      (pc)\n \t\t      (label_ref (match_operand 2 \"\" \"\"))))]\n   \"\"\n@@ -4221,21 +4227,10 @@\n   DONE;\n }\")\n \n-(define_insn \"*scc_signed\"\n-  [(set (match_operand:SI 0 \"integer_register_operand\" \"=d\")\n-\t(match_operator:SI 1 \"signed_relational_operator\"\n-\t\t\t   [(match_operand:CC 2 \"icc_operand\" \"t\")\n-\t\t\t    (const_int 0)]))\n-   (clobber (match_operand:CC_CCR 3 \"icr_operand\" \"=v\"))]\n-  \"\"\n-  \"#\"\n-  [(set_attr \"length\" \"12\")\n-   (set_attr \"type\" \"multi\")])\n-\n-(define_insn \"*scc_unsigned\"\n+(define_insn \"*scc_int\"\n   [(set (match_operand:SI 0 \"integer_register_operand\" \"=d\")\n-\t(match_operator:SI 1 \"unsigned_relational_operator\"\n-\t\t\t   [(match_operand:CC_UNS 2 \"icc_operand\" \"t\")\n+\t(match_operator:SI 1 \"integer_relational_operator\"\n+\t\t\t   [(match_operand 2 \"icc_operand\" \"t\")\n \t\t\t    (const_int 0)]))\n    (clobber (match_operand:CC_CCR 3 \"icr_operand\" \"=v\"))]\n   \"\"\n@@ -4267,21 +4262,10 @@\n   \"operands[4] = frv_split_scc (operands[0], operands[1], operands[2],\n \t\t\t\toperands[3], (HOST_WIDE_INT) 1);\")\n \n-(define_insn \"*scc_neg1_signed\"\n+(define_insn \"*scc_neg1_int\"\n   [(set (match_operand:SI 0 \"integer_register_operand\" \"=d\")\n-\t(neg:SI (match_operator:SI 1 \"signed_relational_operator\"\n-\t\t\t\t   [(match_operand:CC 2 \"icc_operand\" \"t\")\n-\t\t\t\t    (const_int 0)])))\n-   (clobber (match_operand:CC_CCR 3 \"icr_operand\" \"=v\"))]\n-  \"\"\n-  \"#\"\n-  [(set_attr \"length\" \"12\")\n-   (set_attr \"type\" \"multi\")])\n-\n-(define_insn \"*scc_neg1_unsigned\"\n-  [(set (match_operand:SI 0 \"integer_register_operand\" \"=d\")\n-\t(neg:SI (match_operator:SI 1 \"unsigned_relational_operator\"\n-\t\t\t\t   [(match_operand:CC_UNS 2 \"icc_operand\" \"t\")\n+\t(neg:SI (match_operator:SI 1 \"integer_relational_operator\"\n+\t\t\t\t   [(match_operand 2 \"icc_operand\" \"t\")\n \t\t\t\t    (const_int 0)])))\n    (clobber (match_operand:CC_CCR 3 \"icr_operand\" \"=v\"))]\n   \"\"\n@@ -4321,18 +4305,8 @@\n ;; Convert ICC/FCC comparison into CCR bits so we can do conditional execution\n (define_insn \"*ck_signed\"\n   [(set (match_operand:CC_CCR 0 \"icr_operand\" \"=v\")\n-\t(match_operator:CC_CCR 1 \"signed_relational_operator\"\n-\t\t\t       [(match_operand:CC 2 \"icc_operand\" \"t\")\n-\t\t\t\t(const_int 0)]))]\n-  \"\"\n-  \"ck%c1 %2, %0\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"ccr\")])\n-\n-(define_insn \"*ck_unsigned\"\n-  [(set (match_operand:CC_CCR 0 \"icr_operand\" \"=v\")\n-\t(match_operator:CC_CCR 1 \"unsigned_relational_operator\"\n-\t\t\t       [(match_operand:CC_UNS 2 \"icc_operand\" \"t\")\n+\t(match_operator:CC_CCR 1 \"integer_relational_operator\"\n+\t\t\t       [(match_operand 2 \"icc_operand\" \"t\")\n \t\t\t\t(const_int 0)]))]\n   \"\"\n   \"ck%c1 %2, %0\"\n@@ -4582,6 +4556,20 @@\n   [(set_attr \"length\" \"4\")\n    (set_attr \"type\" \"int\")])\n \n+(define_insn \"*cond_exec_cmpsi_cc_nz\"\n+  [(cond_exec\n+    (match_operator 0 \"ccr_eqne_operator\"\n+\t\t    [(match_operand 1 \"cr_operand\" \"C\")\n+\t\t     (const_int 0)])\n+    (set (match_operand:CC_NZ 2 \"icc_operand\" \"=t\")\n+\t (compare:CC_NZ (match_operand:SI 3 \"integer_register_operand\" \"d\")\n+\t\t\t(const_int 0))))]\n+  \"reload_completed\n+   && REGNO (operands[1]) == REGNO (operands[2]) - ICC_FIRST + ICR_FIRST\"\n+  \"ccmp %3, %., %1, %e0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"int\")])\n+\n (define_insn \"*cond_exec_sf_conv\"\n   [(cond_exec\n     (match_operator 0 \"ccr_eqne_operator\"\n@@ -4825,23 +4813,10 @@\n   DONE;\n }\")\n \n-(define_insn \"*movqicc_internal1_signed\"\n-  [(set (match_operand:QI 0 \"integer_register_operand\" \"=d,d,d\")\n-\t(if_then_else:QI (match_operator:CC 1 \"signed_relational_operator\"\n-\t\t\t     [(match_operand:CC 2 \"icc_operand\" \"t,t,t\")\n-\t\t\t      (const_int 0)])\n-\t\t\t (match_operand:QI 3 \"reg_or_0_operand\" \"0,dO,dO\")\n-\t\t\t (match_operand:QI 4 \"reg_or_0_operand\" \"dO,0,dO\")))\n-   (clobber (match_operand:CC_CCR 5 \"icr_operand\" \"=v,v,v\"))]\n-  \"\"\n-  \"#\"\n-  [(set_attr \"length\" \"8,8,12\")\n-   (set_attr \"type\" \"multi\")])\n-\n-(define_insn \"*movqicc_internal1_unsigned\"\n+(define_insn \"*movqicc_internal1_int\"\n   [(set (match_operand:QI 0 \"integer_register_operand\" \"=d,d,d\")\n-\t(if_then_else:QI (match_operator:CC_UNS 1 \"unsigned_relational_operator\"\n-\t\t\t     [(match_operand:CC_UNS 2 \"icc_operand\" \"t,t,t\")\n+\t(if_then_else:QI (match_operator 1 \"integer_relational_operator\"\n+\t\t\t     [(match_operand 2 \"icc_operand\" \"t,t,t\")\n \t\t\t      (const_int 0)])\n \t\t\t (match_operand:QI 3 \"reg_or_0_operand\" \"0,dO,dO\")\n \t\t\t (match_operand:QI 4 \"reg_or_0_operand\" \"dO,0,dO\")))\n@@ -4864,26 +4839,10 @@\n   [(set_attr \"length\" \"8,8,12\")\n    (set_attr \"type\" \"multi\")])\n \n-(define_insn \"*movqicc_internal2_signed\"\n-  [(set (match_operand:QI 0 \"integer_register_operand\" \"=d,d,d,d,d\")\n-\t(if_then_else:QI (match_operator:CC 1 \"signed_relational_operator\"\n-\t\t\t     [(match_operand:CC 2 \"icc_operand\" \"t,t,t,t,t\")\n-\t\t\t      (const_int 0)])\n-\t\t\t (match_operand:QI 3 \"const_int_operand\" \"O,O,L,n,n\")\n-\t\t\t (match_operand:QI 4 \"const_int_operand\" \"L,n,O,O,n\")))\n-   (clobber (match_operand:CC_CCR 5 \"icr_operand\" \"=v,v,v,v,v\"))]\n-  \"(INTVAL (operands[3]) == 0\n-    || INTVAL (operands[4]) == 0\n-    || (IN_RANGE_P (INTVAL (operands[3]), -2048, 2047)\n-        && IN_RANGE_P (INTVAL (operands[4]) - INTVAL (operands[3]), -2048, 2047)))\"\n-  \"#\"\n-  [(set_attr \"length\" \"8,12,8,12,12\")\n-   (set_attr \"type\" \"multi\")])\n-\n-(define_insn \"*movqicc_internal2_unsigned\"\n+(define_insn \"*movqicc_internal2_int\"\n   [(set (match_operand:QI 0 \"integer_register_operand\" \"=d,d,d,d,d\")\n-\t(if_then_else:QI (match_operator:CC_UNS 1 \"unsigned_relational_operator\"\n-\t\t\t     [(match_operand:CC_UNS 2 \"icc_operand\" \"t,t,t,t,t\")\n+\t(if_then_else:QI (match_operator 1 \"integer_relational_operator\"\n+\t\t\t     [(match_operand 2 \"icc_operand\" \"t,t,t,t,t\")\n \t\t\t      (const_int 0)])\n \t\t\t (match_operand:QI 3 \"const_int_operand\" \"O,O,L,n,n\")\n \t\t\t (match_operand:QI 4 \"const_int_operand\" \"L,n,O,O,n\")))\n@@ -4939,23 +4898,10 @@\n   DONE;\n }\")\n \n-(define_insn \"*movhicc_internal1_signed\"\n-  [(set (match_operand:HI 0 \"integer_register_operand\" \"=d,d,d\")\n-\t(if_then_else:HI (match_operator:CC 1 \"signed_relational_operator\"\n-\t\t\t     [(match_operand:CC 2 \"icc_operand\" \"t,t,t\")\n-\t\t\t      (const_int 0)])\n-\t\t\t (match_operand:HI 3 \"reg_or_0_operand\" \"0,dO,dO\")\n-\t\t\t (match_operand:HI 4 \"reg_or_0_operand\" \"dO,0,dO\")))\n-   (clobber (match_operand:CC_CCR 5 \"icr_operand\" \"=v,v,v\"))]\n-  \"\"\n-  \"#\"\n-  [(set_attr \"length\" \"8,8,12\")\n-   (set_attr \"type\" \"multi\")])\n-\n-(define_insn \"*movhicc_internal1_unsigned\"\n+(define_insn \"*movhicc_internal1_int\"\n   [(set (match_operand:HI 0 \"integer_register_operand\" \"=d,d,d\")\n-\t(if_then_else:HI (match_operator:CC_UNS 1 \"unsigned_relational_operator\"\n-\t\t\t     [(match_operand:CC_UNS 2 \"icc_operand\" \"t,t,t\")\n+\t(if_then_else:HI (match_operator 1 \"integer_relational_operator\"\n+\t\t\t     [(match_operand 2 \"icc_operand\" \"t,t,t\")\n \t\t\t      (const_int 0)])\n \t\t\t (match_operand:HI 3 \"reg_or_0_operand\" \"0,dO,dO\")\n \t\t\t (match_operand:HI 4 \"reg_or_0_operand\" \"dO,0,dO\")))\n@@ -4978,26 +4924,10 @@\n   [(set_attr \"length\" \"8,8,12\")\n    (set_attr \"type\" \"multi\")])\n \n-(define_insn \"*movhicc_internal2_signed\"\n+(define_insn \"*movhicc_internal2_int\"\n   [(set (match_operand:HI 0 \"integer_register_operand\" \"=d,d,d,d,d\")\n-\t(if_then_else:HI (match_operator:CC 1 \"signed_relational_operator\"\n-\t\t\t     [(match_operand:CC 2 \"icc_operand\" \"t,t,t,t,t\")\n-\t\t\t      (const_int 0)])\n-\t\t\t (match_operand:HI 3 \"const_int_operand\" \"O,O,L,n,n\")\n-\t\t\t (match_operand:HI 4 \"const_int_operand\" \"L,n,O,O,n\")))\n-   (clobber (match_operand:CC_CCR 5 \"icr_operand\" \"=v,v,v,v,v\"))]\n-  \"(INTVAL (operands[3]) == 0\n-    || INTVAL (operands[4]) == 0\n-    || (IN_RANGE_P (INTVAL (operands[3]), -2048, 2047)\n-        && IN_RANGE_P (INTVAL (operands[4]) - INTVAL (operands[3]), -2048, 2047)))\"\n-  \"#\"\n-  [(set_attr \"length\" \"8,12,8,12,12\")\n-   (set_attr \"type\" \"multi\")])\n-\n-(define_insn \"*movhicc_internal2_unsigned\"\n-  [(set (match_operand:HI 0 \"integer_register_operand\" \"=d,d,d,d,d\")\n-\t(if_then_else:HI (match_operator:CC_UNS 1 \"unsigned_relational_operator\"\n-\t\t\t     [(match_operand:CC_UNS 2 \"icc_operand\" \"t,t,t,t,t\")\n+\t(if_then_else:HI (match_operator 1 \"integer_relational_operator\"\n+\t\t\t     [(match_operand 2 \"icc_operand\" \"t,t,t,t,t\")\n \t\t\t      (const_int 0)])\n \t\t\t (match_operand:HI 3 \"const_int_operand\" \"O,O,L,n,n\")\n \t\t\t (match_operand:HI 4 \"const_int_operand\" \"L,n,O,O,n\")))\n@@ -5053,23 +4983,10 @@\n   DONE;\n }\")\n \n-(define_insn \"*movsicc_internal1_signed\"\n-  [(set (match_operand:SI 0 \"integer_register_operand\" \"=d,d,d\")\n-\t(if_then_else:SI (match_operator:CC 1 \"signed_relational_operator\"\n-\t\t\t     [(match_operand:CC 2 \"icc_operand\" \"t,t,t\")\n-\t\t\t      (const_int 0)])\n-\t\t\t (match_operand:SI 3 \"reg_or_0_operand\" \"0,dO,dO\")\n-\t\t\t (match_operand:SI 4 \"reg_or_0_operand\" \"dO,0,dO\")))\n-   (clobber (match_operand:CC_CCR 5 \"icr_operand\" \"=v,v,v\"))]\n-  \"\"\n-  \"#\"\n-  [(set_attr \"length\" \"8,8,12\")\n-   (set_attr \"type\" \"multi\")])\n-\n-(define_insn \"*movsicc_internal1_unsigned\"\n+(define_insn \"*movsicc_internal1_int\"\n   [(set (match_operand:SI 0 \"integer_register_operand\" \"=d,d,d\")\n-\t(if_then_else:SI (match_operator:CC_UNS 1 \"unsigned_relational_operator\"\n-\t\t\t     [(match_operand:CC_UNS 2 \"icc_operand\" \"t,t,t\")\n+\t(if_then_else:SI (match_operator 1 \"integer_relational_operator\"\n+\t\t\t     [(match_operand 2 \"icc_operand\" \"t,t,t\")\n \t\t\t      (const_int 0)])\n \t\t\t (match_operand:SI 3 \"reg_or_0_operand\" \"0,dO,dO\")\n \t\t\t (match_operand:SI 4 \"reg_or_0_operand\" \"dO,0,dO\")))\n@@ -5092,26 +5009,10 @@\n   [(set_attr \"length\" \"8,8,12\")\n    (set_attr \"type\" \"multi\")])\n \n-(define_insn \"*movsicc_internal2_signed\"\n-  [(set (match_operand:SI 0 \"integer_register_operand\" \"=d,d,d,d,d\")\n-\t(if_then_else:SI (match_operator:CC 1 \"signed_relational_operator\"\n-\t\t\t     [(match_operand:CC 2 \"icc_operand\" \"t,t,t,t,t\")\n-\t\t\t      (const_int 0)])\n-\t\t\t (match_operand:SI 3 \"const_int_operand\" \"O,O,L,n,n\")\n-\t\t\t (match_operand:SI 4 \"const_int_operand\" \"L,n,O,O,n\")))\n-   (clobber (match_operand:CC_CCR 5 \"icr_operand\" \"=v,v,v,v,v\"))]\n-  \"(INTVAL (operands[3]) == 0\n-    || INTVAL (operands[4]) == 0\n-    || (IN_RANGE_P (INTVAL (operands[3]), -2048, 2047)\n-        && IN_RANGE_P (INTVAL (operands[4]) - INTVAL (operands[3]), -2048, 2047)))\"\n-  \"#\"\n-  [(set_attr \"length\" \"8,12,8,12,12\")\n-   (set_attr \"type\" \"multi\")])\n-\n-(define_insn \"*movsicc_internal2_unsigned\"\n+(define_insn \"*movsicc_internal2_int\"\n   [(set (match_operand:SI 0 \"integer_register_operand\" \"=d,d,d,d,d\")\n-\t(if_then_else:SI (match_operator:CC_UNS 1 \"unsigned_relational_operator\"\n-\t\t\t     [(match_operand:CC_UNS 2 \"icc_operand\" \"t,t,t,t,t\")\n+\t(if_then_else:SI (match_operator 1 \"integer_relational_operator\"\n+\t\t\t     [(match_operand 2 \"icc_operand\" \"t,t,t,t,t\")\n \t\t\t      (const_int 0)])\n \t\t\t (match_operand:SI 3 \"const_int_operand\" \"O,O,L,n,n\")\n \t\t\t (match_operand:SI 4 \"const_int_operand\" \"L,n,O,O,n\")))\n@@ -5167,23 +5068,10 @@\n   DONE;\n }\")\n \n-(define_insn \"*movsfcc_has_fprs_signed\"\n+(define_insn \"*movsfcc_has_fprs_int\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f,f,f,?f,?f,?d\")\n-\t(if_then_else:SF (match_operator:CC 1 \"signed_relational_operator\"\n-\t\t\t     [(match_operand:CC 2 \"icc_operand\" \"t,t,t,t,t,t\")\n-\t\t\t      (const_int 0)])\n-\t\t\t (match_operand:SF 3 \"register_operand\" \"0,f,f,f,d,fd\")\n-\t\t\t (match_operand:SF 4 \"register_operand\" \"f,0,f,d,fd,fd\")))\n-   (clobber (match_operand:CC_CCR 5 \"icr_operand\" \"=v,v,v,v,v,v\"))]\n-  \"TARGET_HAS_FPRS\"\n-  \"#\"\n-  [(set_attr \"length\" \"8,8,12,12,12,12\")\n-   (set_attr \"type\" \"multi\")])\n-\n-(define_insn \"*movsfcc_has_fprs_unsigned\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=f,f,f,?f,?f,?d\")\n-\t(if_then_else:SF (match_operator:CC_UNS 1 \"unsigned_relational_operator\"\n-\t\t\t     [(match_operand:CC_UNS 2 \"icc_operand\" \"t,t,t,t,t,t\")\n+\t(if_then_else:SF (match_operator 1 \"integer_relational_operator\"\n+\t\t\t     [(match_operand 2 \"icc_operand\" \"t,t,t,t,t,t\")\n \t\t\t      (const_int 0)])\n \t\t\t (match_operand:SF 3 \"register_operand\" \"0,f,f,f,d,fd\")\n \t\t\t (match_operand:SF 4 \"register_operand\" \"f,0,f,d,fd,fd\")))\n@@ -5206,23 +5094,10 @@\n   [(set_attr \"length\" \"8,8,12,12,12,12\")\n    (set_attr \"type\" \"multi\")])\n \n-(define_insn \"*movsfcc_no_fprs_signed\"\n-  [(set (match_operand:SF 0 \"integer_register_operand\" \"=d,d,d\")\n-\t(if_then_else:SF (match_operator:CC 1 \"signed_relational_operator\"\n-\t\t\t     [(match_operand:CC 2 \"icc_operand\" \"t,t,t\")\n-\t\t\t      (const_int 0)])\n-\t\t\t (match_operand:SF 3 \"integer_register_operand\" \"0,d,d\")\n-\t\t\t (match_operand:SF 4 \"integer_register_operand\" \"d,0,d\")))\n-   (clobber (match_operand:CC_CCR 5 \"icr_operand\" \"=v,v,v\"))]\n-  \"! TARGET_HAS_FPRS\"\n-  \"#\"\n-  [(set_attr \"length\" \"8,8,12\")\n-   (set_attr \"type\" \"multi\")])\n-\n-(define_insn \"*movsfcc_no_fprs_unsigned\"\n+(define_insn \"*movsfcc_no_fprs_int\"\n   [(set (match_operand:SF 0 \"integer_register_operand\" \"=d,d,d\")\n-\t(if_then_else:SF (match_operator:CC_UNS 1 \"unsigned_relational_operator\"\n-\t\t\t     [(match_operand:CC_UNS 2 \"icc_operand\" \"t,t,t\")\n+\t(if_then_else:SF (match_operator 1 \"integer_relational_operator\"\n+\t\t\t     [(match_operand 2 \"icc_operand\" \"t,t,t\")\n \t\t\t      (const_int 0)])\n \t\t\t (match_operand:SF 3 \"integer_register_operand\" \"0,d,d\")\n \t\t\t (match_operand:SF 4 \"integer_register_operand\" \"d,0,d\")))\n@@ -5767,9 +5642,9 @@\n \n (define_insn \"*return_true\"\n   [(set (pc)\n-\t(if_then_else (match_operator:CC 0 \"signed_relational_operator\"\n-\t\t\t\t\t [(match_operand 1 \"icc_operand\" \"t\")\n-\t\t\t\t\t  (const_int 0)])\n+\t(if_then_else (match_operator 0 \"integer_relational_operator\"\n+\t\t\t\t      [(match_operand 1 \"icc_operand\" \"t\")\n+\t\t\t\t       (const_int 0)])\n \t\t      (return)\n \t\t      (pc)))]\n   \"direct_return_p ()\"\n@@ -5779,33 +5654,9 @@\n \n (define_insn \"*return_false\"\n   [(set (pc)\n-\t(if_then_else (match_operator:CC 0 \"signed_relational_operator\"\n-\t\t\t\t\t [(match_operand 1 \"icc_operand\" \"t\")\n-\t\t\t\t\t  (const_int 0)])\n-\t\t      (pc)\n-\t\t      (return)))]\n-  \"direct_return_p ()\"\n-  \"b%C0lr %1,%#\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"jump\")])\n-\n-(define_insn \"*return_unsigned_true\"\n-  [(set (pc)\n-\t(if_then_else (match_operator:CC_UNS 0 \"unsigned_relational_operator\"\n-\t\t\t\t\t     [(match_operand 1 \"icc_operand\" \"t\")\n-\t\t\t\t\t      (const_int 0)])\n-\t\t      (return)\n-\t\t      (pc)))]\n-  \"direct_return_p ()\"\n-  \"b%c0lr %1,%#\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"jump\")])\n-\n-(define_insn \"*return_unsigned_false\"\n-  [(set (pc)\n-\t(if_then_else (match_operator:CC_UNS 0 \"unsigned_relational_operator\"\n-\t\t\t\t\t     [(match_operand 1 \"icc_operand\" \"t\")\n-\t\t\t\t\t      (const_int 0)])\n+\t(if_then_else (match_operator 0 \"integer_relational_operator\"\n+\t\t\t\t      [(match_operand 1 \"icc_operand\" \"t\")\n+\t\t\t\t       (const_int 0)])\n \t\t      (pc)\n \t\t      (return)))]\n   \"direct_return_p ()\""}, {"sha": "04f3abb62ac3cdd8178684b15780c2477eda98f6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/036ff63feed89f4e50c1a10ae0761a1764a566e1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/036ff63feed89f4e50c1a10ae0761a1764a566e1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=036ff63feed89f4e50c1a10ae0761a1764a566e1", "patch": "@@ -1,3 +1,7 @@\n+2004-12-10  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* gcc.c-torture/execute/20041210-1.c: New test.\n+\n 2004-12-10  Volker Reichelt  <reichelt@igpm.rwth-aachen.de>\n \n \tPR c++/18731"}, {"sha": "ef266a0a2e83dd7aa252e40f93e40e6df4ce4ba2", "filename": "gcc/testsuite/gcc.c-torture/execute/20041210-1.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/036ff63feed89f4e50c1a10ae0761a1764a566e1/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20041210-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/036ff63feed89f4e50c1a10ae0761a1764a566e1/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20041210-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20041210-1.c?ref=036ff63feed89f4e50c1a10ae0761a1764a566e1", "patch": "@@ -0,0 +1,14 @@\n+/* The FR-V port used to fail this test because the andcc patterns\n+   wrongly claimed to set the C and V flags.  */\n+#include <limits.h>\n+\n+int x[4] = { INT_MIN / 2, INT_MAX, 2, 4 };\n+\n+int\n+main ()\n+{\n+  if (x[0] < x[1])\n+    if ((x[2] & x[3]) < 0)\n+      abort ();\n+  exit (0);\n+}"}]}