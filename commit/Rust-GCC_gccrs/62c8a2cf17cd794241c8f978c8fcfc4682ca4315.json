{"sha": "62c8a2cf17cd794241c8f978c8fcfc4682ca4315", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjJjOGEyY2YxN2NkNzk0MjQxYzhmOTc4YzhmY2ZjNDY4MmNhNDMxNQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-08-04T10:42:53Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-08-04T10:42:53Z"}, "message": "Pool alignment information for common bases\n\nThis patch is a follow-on to the fix for PR81136.  The testcase for that\nPR shows that we can (correctly) calculate different base alignments\nfor two data_references but still tell that their misalignments wrt the\nvector size are equal.  This is because we calculate the base alignments\nfor each dr individually, without looking at the other drs, and in\ngeneral the alignment we calculate is only guaranteed if the dr's DR_REF\nactually occurs.\n\nThis is working as designed, but it does expose a missed opportunity.\nWe know that if a vectorised loop is reached, all statements in that\nloop execute at least once, so it should be safe to pool the alignment\ninformation for all the statements we're vectorising.  The only catch is\nthat DR_REFs for masked loads and stores only occur if the mask value is\nnonzero.  For example, in:\n\n    struct s __attribute__((aligned(32))) {\n      int misaligner;\n      int array[N];\n    };\n\n    int *ptr;\n    for (int i = 0; i < n; ++i)\n      ptr[i] = c[i] ? ((struct s *) (ptr - 1))->array[i] : 0;\n\nwe can only guarantee that ptr points to a \"struct s\" if at least\none c[i] is true.\n\nThis patch adds a DR_IS_CONDITIONAL_IN_STMT flag to record whether\nthe DR_REF is guaranteed to occur every time that the statement\nexecutes to completion.  It then pools the alignment information\nfor references that aren't conditional in this sense.\n\n2017-08-04  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\tPR tree-optimization/81136\n\t* tree-vectorizer.h: Include tree-hash-traits.h.\n\t(vec_base_alignments): New typedef.\n\t(vec_info): Add a base_alignments field.\n\t(vect_record_base_alignments): Declare.\n\t* tree-data-ref.h (data_reference): Add an is_conditional_in_stmt\n\tfield.\n\t(DR_IS_CONDITIONAL_IN_STMT): New macro.\n\t(create_data_ref): Add an is_conditional_in_stmt argument.\n\t* tree-data-ref.c (create_data_ref): Likewise.  Use it to initialize\n\tthe is_conditional_in_stmt field.\n\t(data_ref_loc): Add an is_conditional_in_stmt field.\n\t(get_references_in_stmt): Set the is_conditional_in_stmt field.\n\t(find_data_references_in_stmt): Update call to create_data_ref.\n\t(graphite_find_data_references_in_stmt): Likewise.\n\t* tree-ssa-loop-prefetch.c (determine_loop_nest_reuse): Likewise.\n\t* tree-vect-data-refs.c (vect_analyze_data_refs): Likewise.\n\t(vect_record_base_alignment): New function.\n\t(vect_record_base_alignments): Likewise.\n\t(vect_compute_data_ref_alignment): Adjust base_addr and aligned_to\n\tfor nested statements even if we fail to compute a misalignment.\n\tUse pooled base alignments for unconditional references.\n\t(vect_find_same_alignment_drs): Compare base addresses instead\n\tof base objects.\n\t(vect_analyze_data_refs_alignment): Call vect_record_base_alignments.\n\t* tree-vect-slp.c (vect_slp_analyze_bb_1): Likewise.\n\ngcc/testsuite/\n\tPR tree-optimization/81136\n\t* gcc.dg/vect/pr81136.c: Add scan test.\n\nFrom-SVN: r250870", "tree": {"sha": "52a7de7b09fb0528bcb735d67d552670ecb519f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/52a7de7b09fb0528bcb735d67d552670ecb519f3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/62c8a2cf17cd794241c8f978c8fcfc4682ca4315", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62c8a2cf17cd794241c8f978c8fcfc4682ca4315", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62c8a2cf17cd794241c8f978c8fcfc4682ca4315", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62c8a2cf17cd794241c8f978c8fcfc4682ca4315/comments", "author": null, "committer": null, "parents": [{"sha": "2c515559f9dbe8bace5f68e2fec7600a9edc7c42", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c515559f9dbe8bace5f68e2fec7600a9edc7c42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c515559f9dbe8bace5f68e2fec7600a9edc7c42"}], "stats": {"total": 173, "additions": 159, "deletions": 14}, "files": [{"sha": "c0d747dbcf2bcde77e7fbd8cb5a4e16c6f0835ee", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62c8a2cf17cd794241c8f978c8fcfc4682ca4315/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62c8a2cf17cd794241c8f978c8fcfc4682ca4315/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=62c8a2cf17cd794241c8f978c8fcfc4682ca4315", "patch": "@@ -1,3 +1,32 @@\n+2017-08-04  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\tPR tree-optimization/81136\n+\t* tree-vectorizer.h: Include tree-hash-traits.h.\n+\t(vec_base_alignments): New typedef.\n+\t(vec_info): Add a base_alignments field.\n+\t(vect_record_base_alignments): Declare.\n+\t* tree-data-ref.h (data_reference): Add an is_conditional_in_stmt\n+\tfield.\n+\t(DR_IS_CONDITIONAL_IN_STMT): New macro.\n+\t(create_data_ref): Add an is_conditional_in_stmt argument.\n+\t* tree-data-ref.c (create_data_ref): Likewise.  Use it to initialize\n+\tthe is_conditional_in_stmt field.\n+\t(data_ref_loc): Add an is_conditional_in_stmt field.\n+\t(get_references_in_stmt): Set the is_conditional_in_stmt field.\n+\t(find_data_references_in_stmt): Update call to create_data_ref.\n+\t(graphite_find_data_references_in_stmt): Likewise.\n+\t* tree-ssa-loop-prefetch.c (determine_loop_nest_reuse): Likewise.\n+\t* tree-vect-data-refs.c (vect_analyze_data_refs): Likewise.\n+\t(vect_record_base_alignment): New function.\n+\t(vect_record_base_alignments): Likewise.\n+\t(vect_compute_data_ref_alignment): Adjust base_addr and aligned_to\n+\tfor nested statements even if we fail to compute a misalignment.\n+\tUse pooled base alignments for unconditional references.\n+\t(vect_find_same_alignment_drs): Compare base addresses instead\n+\tof base objects.\n+\t(vect_analyze_data_refs_alignment): Call vect_record_base_alignments.\n+\t* tree-vect-slp.c (vect_slp_analyze_bb_1): Likewise.\n+\n 2017-08-04  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* tree-vectorizer.h (vec_info): Add a constructor and destructor."}, {"sha": "23f9c8fd16606e4fc4fbad0dabc33089badbad1f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62c8a2cf17cd794241c8f978c8fcfc4682ca4315/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62c8a2cf17cd794241c8f978c8fcfc4682ca4315/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=62c8a2cf17cd794241c8f978c8fcfc4682ca4315", "patch": "@@ -1,3 +1,8 @@\n+2017-08-04  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\tPR tree-optimization/81136\n+\t* gcc.dg/vect/pr81136.c: Add scan test.\n+\n 2017-08-04  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* gcc.dg/vect/vect-alias-check-3.c: New test."}, {"sha": "c67357684dfedf4c0282f5dbb1a135bcfbf5fca9", "filename": "gcc/testsuite/gcc.dg/vect/pr81136.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62c8a2cf17cd794241c8f978c8fcfc4682ca4315/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr81136.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62c8a2cf17cd794241c8f978c8fcfc4682ca4315/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr81136.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr81136.c?ref=62c8a2cf17cd794241c8f978c8fcfc4682ca4315", "patch": "@@ -14,3 +14,5 @@ fn1 (int n)\n   for (int i = 0; i < n; i++)\n     a->bar[i] = b[i];\n }\n+\n+/* { dg-final { scan-tree-dump-not \"Unknown misalignment\" \"vect\" } } */"}, {"sha": "26387f86b873cdd687aaa447e79a362c4d6e2412", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62c8a2cf17cd794241c8f978c8fcfc4682ca4315/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62c8a2cf17cd794241c8f978c8fcfc4682ca4315/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=62c8a2cf17cd794241c8f978c8fcfc4682ca4315", "patch": "@@ -1125,15 +1125,19 @@ free_data_ref (data_reference_p dr)\n   free (dr);\n }\n \n-/* Analyzes memory reference MEMREF accessed in STMT.  The reference\n-   is read if IS_READ is true, write otherwise.  Returns the\n-   data_reference description of MEMREF.  NEST is the outermost loop\n-   in which the reference should be instantiated, LOOP is the loop in\n-   which the data reference should be analyzed.  */\n+/* Analyze memory reference MEMREF, which is accessed in STMT.\n+   The reference is a read if IS_READ is true, otherwise it is a write.\n+   IS_CONDITIONAL_IN_STMT indicates that the reference is conditional\n+   within STMT, i.e. that it might not occur even if STMT is executed\n+   and runs to completion.\n+\n+   Return the data_reference description of MEMREF.  NEST is the outermost\n+   loop in which the reference should be instantiated, LOOP is the loop\n+   in which the data reference should be analyzed.  */\n \n struct data_reference *\n create_data_ref (loop_p nest, loop_p loop, tree memref, gimple *stmt,\n-\t\t bool is_read)\n+\t\t bool is_read, bool is_conditional_in_stmt)\n {\n   struct data_reference *dr;\n \n@@ -1148,6 +1152,7 @@ create_data_ref (loop_p nest, loop_p loop, tree memref, gimple *stmt,\n   DR_STMT (dr) = stmt;\n   DR_REF (dr) = memref;\n   DR_IS_READ (dr) = is_read;\n+  DR_IS_CONDITIONAL_IN_STMT (dr) = is_conditional_in_stmt;\n \n   dr_analyze_innermost (&DR_INNERMOST (dr), memref,\n \t\t\tnest != NULL ? loop : NULL);\n@@ -4774,6 +4779,11 @@ struct data_ref_loc\n \n   /* True if the memory reference is read.  */\n   bool is_read;\n+\n+  /* True if the data reference is conditional within the containing\n+     statement, i.e. if it might not occur even when the statement\n+     is executed and runs to completion.  */\n+  bool is_conditional_in_stmt;\n };\n \n \n@@ -4840,6 +4850,7 @@ get_references_in_stmt (gimple *stmt, vec<data_ref_loc, va_heap> *references)\n \t{\n \t  ref.ref = op1;\n \t  ref.is_read = true;\n+\t  ref.is_conditional_in_stmt = false;\n \t  references->safe_push (ref);\n \t}\n     }\n@@ -4867,6 +4878,7 @@ get_references_in_stmt (gimple *stmt, vec<data_ref_loc, va_heap> *references)\n \t      type = TREE_TYPE (gimple_call_arg (stmt, 3));\n \t    if (TYPE_ALIGN (type) != align)\n \t      type = build_aligned_type (type, align);\n+\t    ref.is_conditional_in_stmt = true;\n \t    ref.ref = fold_build2 (MEM_REF, type, gimple_call_arg (stmt, 0),\n \t\t\t\t   ptr);\n \t    references->safe_push (ref);\n@@ -4886,6 +4898,7 @@ get_references_in_stmt (gimple *stmt, vec<data_ref_loc, va_heap> *references)\n \t    {\n \t      ref.ref = op1;\n \t      ref.is_read = true;\n+\t      ref.is_conditional_in_stmt = false;\n \t      references->safe_push (ref);\n \t    }\n \t}\n@@ -4899,6 +4912,7 @@ get_references_in_stmt (gimple *stmt, vec<data_ref_loc, va_heap> *references)\n     {\n       ref.ref = op0;\n       ref.is_read = false;\n+      ref.is_conditional_in_stmt = false;\n       references->safe_push (ref);\n     }\n   return clobbers_memory;\n@@ -4963,8 +4977,8 @@ find_data_references_in_stmt (struct loop *nest, gimple *stmt,\n \n   FOR_EACH_VEC_ELT (references, i, ref)\n     {\n-      dr = create_data_ref (nest, loop_containing_stmt (stmt),\n-\t\t\t    ref->ref, stmt, ref->is_read);\n+      dr = create_data_ref (nest, loop_containing_stmt (stmt), ref->ref,\n+\t\t\t    stmt, ref->is_read, ref->is_conditional_in_stmt);\n       gcc_assert (dr != NULL);\n       datarefs->safe_push (dr);\n     }\n@@ -4993,7 +5007,8 @@ graphite_find_data_references_in_stmt (loop_p nest, loop_p loop, gimple *stmt,\n \n   FOR_EACH_VEC_ELT (references, i, ref)\n     {\n-      dr = create_data_ref (nest, loop, ref->ref, stmt, ref->is_read);\n+      dr = create_data_ref (nest, loop, ref->ref, stmt, ref->is_read,\n+\t\t\t    ref->is_conditional_in_stmt);\n       gcc_assert (dr != NULL);\n       datarefs->safe_push (dr);\n     }"}, {"sha": "a66d335f4a0ee5a655446c8164e8c090d9d3eab6", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62c8a2cf17cd794241c8f978c8fcfc4682ca4315/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62c8a2cf17cd794241c8f978c8fcfc4682ca4315/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=62c8a2cf17cd794241c8f978c8fcfc4682ca4315", "patch": "@@ -159,6 +159,11 @@ struct data_reference\n   /* True when the data reference is in RHS of a stmt.  */\n   bool is_read;\n \n+  /* True when the data reference is conditional within STMT,\n+     i.e. if it might not occur even when the statement is executed\n+     and runs to completion.  */\n+  bool is_conditional_in_stmt;\n+\n   /* Behavior of the memory reference in the innermost loop.  */\n   struct innermost_loop_behavior innermost;\n \n@@ -178,6 +183,7 @@ struct data_reference\n #define DR_NUM_DIMENSIONS(DR)      DR_ACCESS_FNS (DR).length ()\n #define DR_IS_READ(DR)             (DR)->is_read\n #define DR_IS_WRITE(DR)            (!DR_IS_READ (DR))\n+#define DR_IS_CONDITIONAL_IN_STMT(DR) (DR)->is_conditional_in_stmt\n #define DR_BASE_ADDRESS(DR)        (DR)->innermost.base_address\n #define DR_OFFSET(DR)              (DR)->innermost.offset\n #define DR_INIT(DR)                (DR)->innermost.init\n@@ -434,7 +440,8 @@ extern bool graphite_find_data_references_in_stmt (loop_p, loop_p, gimple *,\n \t\t\t\t\t\t   vec<data_reference_p> *);\n tree find_data_references_in_loop (struct loop *, vec<data_reference_p> *);\n bool loop_nest_has_data_refs (loop_p loop);\n-struct data_reference *create_data_ref (loop_p, loop_p, tree, gimple *, bool);\n+struct data_reference *create_data_ref (loop_p, loop_p, tree, gimple *, bool,\n+\t\t\t\t\tbool);\n extern bool find_loop_nest (struct loop *, vec<loop_p> *);\n extern struct data_dependence_relation *initialize_data_dependence_relation\n      (struct data_reference *, struct data_reference *, vec<loop_p>);"}, {"sha": "ecf14d108fe3b4141f770f5ffabb6452de7038d9", "filename": "gcc/tree-ssa-loop-prefetch.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62c8a2cf17cd794241c8f978c8fcfc4682ca4315/gcc%2Ftree-ssa-loop-prefetch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62c8a2cf17cd794241c8f978c8fcfc4682ca4315/gcc%2Ftree-ssa-loop-prefetch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-prefetch.c?ref=62c8a2cf17cd794241c8f978c8fcfc4682ca4315", "patch": "@@ -1633,7 +1633,7 @@ determine_loop_nest_reuse (struct loop *loop, struct mem_ref_group *refs,\n     for (ref = gr->refs; ref; ref = ref->next)\n       {\n \tdr = create_data_ref (nest, loop_containing_stmt (ref->stmt),\n-\t\t\t      ref->mem, ref->stmt, !ref->write_p);\n+\t\t\t      ref->mem, ref->stmt, !ref->write_p, false);\n \n \tif (dr)\n \t  {"}, {"sha": "60f2539b3c082176e9335ed72db28fd3f3895c16", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 77, "deletions": 3, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62c8a2cf17cd794241c8f978c8fcfc4682ca4315/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62c8a2cf17cd794241c8f978c8fcfc4682ca4315/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=62c8a2cf17cd794241c8f978c8fcfc4682ca4315", "patch": "@@ -708,6 +708,69 @@ vect_slp_analyze_instance_dependence (slp_instance instance)\n   return res;\n }\n \n+/* Record in VINFO the base alignment guarantee given by DRB.  STMT is\n+   the statement that contains DRB, which is useful for recording in the\n+   dump file.  */\n+\n+static void\n+vect_record_base_alignment (vec_info *vinfo, gimple *stmt,\n+\t\t\t    innermost_loop_behavior *drb)\n+{\n+  bool existed;\n+  innermost_loop_behavior *&entry\n+    = vinfo->base_alignments.get_or_insert (drb->base_address, &existed);\n+  if (!existed || entry->base_alignment < drb->base_alignment)\n+    {\n+      entry = drb;\n+      if (dump_enabled_p ())\n+\t{\n+\t  dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t   \"recording new base alignment for \");\n+\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, drb->base_address);\n+\t  dump_printf (MSG_NOTE, \"\\n\");\n+\t  dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t   \"  alignment:    %d\\n\", drb->base_alignment);\n+\t  dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t   \"  misalignment: %d\\n\", drb->base_misalignment);\n+\t  dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t   \"  based on:     \");\n+\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 0);\n+\t}\n+    }\n+}\n+\n+/* If the region we're going to vectorize is reached, all unconditional\n+   data references occur at least once.  We can therefore pool the base\n+   alignment guarantees from each unconditional reference.  Do this by\n+   going through all the data references in VINFO and checking whether\n+   the containing statement makes the reference unconditionally.  If so,\n+   record the alignment of the base address in VINFO so that it can be\n+   used for all other references with the same base.  */\n+\n+void\n+vect_record_base_alignments (vec_info *vinfo)\n+{\n+  loop_vec_info loop_vinfo = dyn_cast <loop_vec_info> (vinfo);\n+  struct loop *loop = loop_vinfo ? LOOP_VINFO_LOOP (loop_vinfo) : NULL;\n+  data_reference *dr;\n+  unsigned int i;\n+  FOR_EACH_VEC_ELT (vinfo->datarefs, i, dr)\n+    if (!DR_IS_CONDITIONAL_IN_STMT (dr))\n+      {\n+\tgimple *stmt = DR_STMT (dr);\n+\tvect_record_base_alignment (vinfo, stmt, &DR_INNERMOST (dr));\n+\n+\t/* If DR is nested in the loop that is being vectorized, we can also\n+\t   record the alignment of the base wrt the outer loop.  */\n+\tif (loop && nested_in_vect_loop_p (loop, stmt))\n+\t  {\n+\t    stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+\t    vect_record_base_alignment\n+\t      (vinfo, stmt, &STMT_VINFO_DR_WRT_VEC_LOOP (stmt_info));\n+\t  }\n+      }\n+}\n+\n /* Function vect_compute_data_ref_alignment\n \n    Compute the misalignment of the data reference DR.\n@@ -725,6 +788,7 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n {\n   gimple *stmt = DR_STMT (dr);\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  vec_base_alignments *base_alignments = &stmt_info->vinfo->base_alignments;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   struct loop *loop = NULL;\n   tree ref = DR_REF (dr);\n@@ -793,6 +857,15 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n   unsigned int base_misalignment = drb->base_misalignment;\n   unsigned HOST_WIDE_INT vector_alignment = TYPE_ALIGN_UNIT (vectype);\n \n+  /* Calculate the maximum of the pooled base address alignment and the\n+     alignment that we can compute for DR itself.  */\n+  innermost_loop_behavior **entry = base_alignments->get (drb->base_address);\n+  if (entry && base_alignment < (*entry)->base_alignment)\n+    {\n+      base_alignment = (*entry)->base_alignment;\n+      base_misalignment = (*entry)->base_misalignment;\n+    }\n+\n   if (drb->offset_alignment < vector_alignment\n       || !step_preserves_misalignment_p\n       /* We need to know whether the step wrt the vectorized loop is\n@@ -2113,8 +2186,7 @@ vect_find_same_alignment_drs (struct data_dependence_relation *ddr)\n   if (dra == drb)\n     return;\n \n-  if (!operand_equal_p (DR_BASE_OBJECT (dra), DR_BASE_OBJECT (drb),\n-\t\t\tOEP_ADDRESS_OF)\n+  if (!operand_equal_p (DR_BASE_ADDRESS (dra), DR_BASE_ADDRESS (drb), 0)\n       || !operand_equal_p (DR_OFFSET (dra), DR_OFFSET (drb), 0)\n       || !operand_equal_p (DR_STEP (dra), DR_STEP (drb), 0))\n     return;\n@@ -2172,6 +2244,7 @@ vect_analyze_data_refs_alignment (loop_vec_info vinfo)\n   vec<data_reference_p> datarefs = vinfo->datarefs;\n   struct data_reference *dr;\n \n+  vect_record_base_alignments (vinfo);\n   FOR_EACH_VEC_ELT (datarefs, i, dr)\n     {\n       stmt_vec_info stmt_info = vinfo_for_stmt (DR_STMT (dr));\n@@ -3437,7 +3510,8 @@ vect_analyze_data_refs (vec_info *vinfo, int *min_vf)\n \t    {\n \t      struct data_reference *newdr\n \t\t= create_data_ref (NULL, loop_containing_stmt (stmt),\n-\t\t\t\t   DR_REF (dr), stmt, maybe_scatter ? false : true);\n+\t\t\t\t   DR_REF (dr), stmt, !maybe_scatter,\n+\t\t\t\t   DR_IS_CONDITIONAL_IN_STMT (dr));\n \t      gcc_assert (newdr != NULL && DR_REF (newdr));\n \t      if (DR_BASE_ADDRESS (newdr)\n \t\t  && DR_OFFSET (newdr)"}, {"sha": "1334df30350eebf03b18a219993bc8541fb44a37", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62c8a2cf17cd794241c8f978c8fcfc4682ca4315/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62c8a2cf17cd794241c8f978c8fcfc4682ca4315/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=62c8a2cf17cd794241c8f978c8fcfc4682ca4315", "patch": "@@ -2780,6 +2780,8 @@ vect_slp_analyze_bb_1 (gimple_stmt_iterator region_begin,\n       return NULL;\n     }\n \n+  vect_record_base_alignments (bb_vinfo);\n+\n   /* Analyze and verify the alignment of data references and the\n      dependence in the SLP instances.  */\n   for (i = 0; BB_VINFO_SLP_INSTANCES (bb_vinfo).iterate (i, &instance); )"}, {"sha": "4ee3c3fbcd7d24ff2f6e8f47aa5cef093c92ecbf", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62c8a2cf17cd794241c8f978c8fcfc4682ca4315/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62c8a2cf17cd794241c8f978c8fcfc4682ca4315/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=62c8a2cf17cd794241c8f978c8fcfc4682ca4315", "patch": "@@ -22,6 +22,7 @@ along with GCC; see the file COPYING3.  If not see\n #define GCC_TREE_VECTORIZER_H\n \n #include \"tree-data-ref.h\"\n+#include \"tree-hash-traits.h\"\n #include \"target.h\"\n \n /* Used for naming of new temporaries.  */\n@@ -84,6 +85,11 @@ struct stmt_info_for_cost {\n \n typedef vec<stmt_info_for_cost> stmt_vector_for_cost;\n \n+/* Maps base addresses to an innermost_loop_behavior that gives the maximum\n+   known alignment for that base.  */\n+typedef hash_map<tree_operand_hash,\n+\t\t innermost_loop_behavior *> vec_base_alignments;\n+\n /************************************************************************\n   SLP\n  ************************************************************************/\n@@ -169,6 +175,10 @@ struct vec_info {\n   /* All data references.  Freed by free_data_refs, so not an auto_vec.  */\n   vec<data_reference_p> datarefs;\n \n+  /* Maps base addresses to an innermost_loop_behavior that gives the maximum\n+     known alignment for that base.  */\n+  vec_base_alignments base_alignments;\n+\n   /* All data dependences.  Freed by free_dependence_relations, so not\n      an auto_vec.  */\n   vec<ddr_p> ddrs;\n@@ -1162,6 +1172,7 @@ extern bool vect_prune_runtime_alias_test_list (loop_vec_info);\n extern bool vect_check_gather_scatter (gimple *, loop_vec_info,\n \t\t\t\t       gather_scatter_info *);\n extern bool vect_analyze_data_refs (vec_info *, int *);\n+extern void vect_record_base_alignments (vec_info *);\n extern tree vect_create_data_ref_ptr (gimple *, tree, struct loop *, tree,\n \t\t\t\t      tree *, gimple_stmt_iterator *,\n \t\t\t\t      gimple **, bool, bool *,"}]}