{"sha": "c6c3dba931548987c78719180e30ebc863404b89", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzZjM2RiYTkzMTU0ODk4N2M3ODcxOTE4MGUzMGViYzg2MzQwNGI4OQ==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2009-05-14T13:42:45Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2009-05-14T13:42:45Z"}, "message": "tm.texi (TARGET_LEGITIMATE_ADDRESS_P): Refer mainly to this in the former documentation of...\n\n2009-05-14  Paolo Bonzini  <bonzini@gnu.org>\n\n\t* doc/tm.texi (TARGET_LEGITIMATE_ADDRESS_P): Refer mainly to this\n\tin the former documentation of...\n\t(GO_IF_LEGITIMATE_ADDRESS): ... this.\n\t* ira-conflicts.c (get_dup_num): Use address_operand.\n\t* targhooks.c (default_legitimate_address_p): New.\n\t* targhooks.h (default_legitimate_address_p): New.\n\t* reload.c (strict_memory_address_p) [!GO_IF_LEGITIMATE_ADDRESS]:\n\tCall hook.\n\t* recog.c (memory_address_p) [!GO_IF_LEGITIMATE_ADDRESS]: Call hook.\n\t* target.h (struct target): Add legitimate_address_p.\n\t* target-def.h (TARGET_LEGITIMATE_ADDRESS_P): New.\n\t(TARGET_INITIALIZER): Include it.\n\n\t* config/alpha/alpha.h (GO_IF_LEGITIMATE_ADDRESS): Delete.\n\t* config/alpha/alpha-protos.h (alpha_legitimate_address_p): Remove.\n\t* config/alpha/alpha.c (alpha_legitimate_address_p): Make static.\n\t(TARGET_LEGITIMATE_ADDRESS_P): New.\n\n\t* config/frv/frv.h (GO_IF_LEGITIMATE_ADDRESS): Delete.\n\t(REG_OK_STRICT_P): Delete.\n\t* config/frv/frv-protos.h (frv_legitimate_address_p): Rename to...\n\t(frv_legitimate_address_p_1): ... this.\n\t* config/frv/frv.c (frv_legitimate_address_p): Forward to...\n\t(frv_legitimate_address_p_1): ... the renamed old\n\tfrv_legitimate_address_p.\n\t* config/frv/predicates.md: Adjust calls to frv_legitimate_address_p.\n\t(TARGET_LEGITIMATE_ADDRESS_P): New.\n\n\t* config/s390/s390.h (GO_IF_LEGITIMATE_ADDRESS): Delete.\n\t* config/s390/s390-protos.h (legitimate_address_p): Remove.\n\t* config/s390/s390.c (legitimate_address_p): Rename to...\n\t(s390_legitimate_address_p): ... this, make static.\n\t(legitimize_address): Adjust call.\n\t(TARGET_LEGITIMATE_ADDRESS_P): New.\n\t* config/s390/constraints.md (\"e\"): Call strict_memory_address_p.\n\n\t* config/m32c/m32c.h (GO_IF_LEGITIMATE_ADDRESS): Delete.\n\t* config/m32c/m32c-protos.h (m32c_legitimate_address_p): Remove.\n\t* config/m32c/m32c.c (m32c_legitimate_address_p): Make static.\n\t(TARGET_LEGITIMATE_ADDRESS_P): New.\n\n\t* config/spu/spu.h (GO_IF_LEGITIMATE_ADDRESS): Delete.\n\t* config/spu/spu-protos.h (spu_legitimate_address): Remove.\n\t* config/spu/spu.c (spu_legitimate_address): Rename to...\n\t(spu_legitimate_address_p): ... this, make static.\n\t(TARGET_LEGITIMATE_ADDRESS_P): New.\n\n\t* config/sparc/sparc.h (GO_IF_LEGITIMATE_ADDRESS): Delete.\n\t* config/sparc/sparc-protos.h (legitimate_address_p): Remove.\n\t* config/sparc/sparc.c (legitimate_address_p): Rename to...\n\t(sparc_legitimate_address_p): ... this, make static and return bool.\n\t(legitimize_address): Adjust call.\n\t(TARGET_LEGITIMATE_ADDRESS_P): New.\n\n\t* config/i386/i386.h (GO_IF_LEGITIMATE_ADDRESS): Delete.\n\t* config/i386/i386-protos.h (legitimate_address_p): Remove.\n\t* config/i386/i386.c (legitimate_address_p): Rename to...\n\t(ix86_legitimate_address_p): ... this, make static.\n\t(constant_address_p): Move after it, adjust call.\n\t(TARGET_LEGITIMATE_ADDRESS_P): New.\n\n\t* config/avr/avr.h (GO_IF_LEGITIMATE_ADDRESS): Delete.\n\t* config/avr/avr-protos.h (legitimate_address_p): Remove.\n\t* config/avr/avr.c (legitimate_address_p): Rename to...\n\t(avr_legitimate_address_p): ... this, make static.\n\t(legitimize_address): Adjust call.\n\t(TARGET_LEGITIMATE_ADDRESS_P): New.\n\n\t* config/crx/crx.h (GO_IF_LEGITIMATE_ADDRESS): Delete.\n\t* config/crx/crx-protos.h (crx_legitimate_address_p): Remove.\n\t* config/crx/crx.c (crx_legitimate_address_p): Make static.\n\t(TARGET_LEGITIMATE_ADDRESS_P): New.\n\n\t* config/xtensa/xtensa.h (GO_IF_LEGITIMATE_ADDRESS): Delete.\n\t* config/xtensa/xtensa-protos.h (xtensa_legitimate_address_p): Remove.\n\t* config/xtensa/xtensa.c (xtensa_legitimate_address_p): Make static.\n\t(TARGET_LEGITIMATE_ADDRESS_P): New.\n\n\t* config/stormy16/stormy16.h (GO_IF_LEGITIMATE_ADDRESS): Delete.\n\t* config/stormy16/stormy16-protos.h (xstormy16_legitimate_address_p):\n\tRemove.\n\t* config/stormy16/stormy16.c (xstormy16_legitimate_address_p):\n\tMake static.\n\t(TARGET_LEGITIMATE_ADDRESS_P): New.\n\n\t* config/m68hc11/m68hc11.h (GO_IF_LEGITIMATE_ADDRESS): Delete.\n\t* config/m68hc11/m68hc11-protos.h (m68hc11_go_if_legitimate_address):\n\tRemove.\n\t* config/m68hc11/m68hc11.c (m68hc11_go_if_legitimate_address):\n\tRename to...\n\t(m68hc11_legitimate_address_p): ... this, make static.\n\t(go_if_legitimate_address_internal): Rename to...\n\t(m68hc11_legitimate_address_p_1): ... this.\n\t(legitimize_address): Adjust call.\n\t(TARGET_LEGITIMATE_ADDRESS_P): New.\n\n\t* config/iq2000/iq2000.h (GO_IF_LEGITIMATE_ADDRESS): Delete.\n\t* config/iq2000/iq2000-protos.h (iq2000_legitimate_address_p):\n\tRemove.\n\t* config/iq2000/iq2000.c (iq2000_legitimate_address_p):\n\tMake static.\n\t(TARGET_LEGITIMATE_ADDRESS_P): New.\n\n\t* config/mn10300/mn10300.h (GO_IF_LEGITIMATE_ADDRESS): Delete.\n\t* config/mn10300/mn10300-protos.h (legitimate_address_p): Remove.\n\t* config/mn10300/mn10300.c (legitimate_address_p): Rename to...\n\t(mn10300_legitimate_address_p): ... this, make static.\n\t(TARGET_LEGITIMATE_ADDRESS_P): New.\n\n\t* config/m68k/m68k.h (GO_IF_LEGITIMATE_ADDRESS): Delete.\n\t* config/m68k/m68k-protos.h (m68k_legitimate_address_p): Remove.\n\t* config/m68k/m68k.c (m68k_legitimate_address_p): Make static.\n\t(TARGET_LEGITIMATE_ADDRESS_P): New.\n\n\t* config/rs6000/rs6000.h (GO_IF_LEGITIMATE_ADDRESS): Delete.\n\t(REG_OK_STRICT_FLAG, REG_OK_FOR_BASE_P, REG_OK_FOR_INDEX_P): Delete.\n\t(INT_REG_OK_FOR_BASE_P, INT_REG_OK_FOR_INDEX_P): Move above.\n\t* config/rs6000/rs6000.h (GO_IF_LEGITIMATE_ADDRESS): Delete.\n\t* config/rs6000/rs6000-protos.h (rs6000_legitimate_address): Remove.\n\t* config/rs6000/rs6000.c (rs6000_legitimate_address): Rename to...\n\t(rs6000_legitimate_address_p): ... this, make static.\n\t(TARGET_LEGITIMATE_ADDRESS_P): New.\n\t(REG_MODE_OK_FOR_BASE_P): Delete.\n\t(rs6000_legitimize_reload_address): Use INT_REG_OK_FOR_BASE_P.\n\n\t* config/picochip/picochip.h (GO_IF_LEGITIMATE_ADDRESS): Delete.\n\t* config/picochip/picochip-protos.h (picochip_legitimate_address_p):\n\tDelete.\n\t* config/picochip/picochip.c (picochip_legitimate_address_p): Make\n\tstatic, adjust types.\n\t(TARGET_LEGITIMATE_ADDRESS_P): New.\n\n\t* config/score/score.h (GO_IF_LEGITIMATE_ADDRESS): Delete.\n\t* config/score/score.c (score_address_p): Rename to...\n\t(score_legitimate_address_p): ... this.\n\t(TARGET_LEGITIMATE_ADDRESS_P): New.\n\t* config/score/score3.c (score3_address_p): Rename to...\n\t(score3_legitimate_address_p): ... this.\n\t* config/score/score7.c (score7_address_p): Rename to...\n\t(score7_legitimate_address_p): ... this.\n\n\t* config/arm/arm.h (ARM_GO_IF_LEGITIMATE_ADDRESS,\n\tTHUMB2_GO_IF_LEGITIMATE_ADDRESS, THUMB1_GO_IF_LEGITIMATE_ADDRESS,\n\tGO_IF_LEGITIMATE_ADDRESS): Delete.\n\t* config/arm/arm-protos.h (thumb1_legitimate_address_p,\n\tthumb2_legitimate_address_p): Delete.\n\t(arm_legitimate_address_p): Rename to...\n\t(arm_legitimate_address_outer_p): ... this.\n\t* config/arm/constraints.md (\"Uq\"): Adjust call.\n\t* config/arm/predicates.md (arm_extendqisi_mem_op): Likewise.\n\t* config/arm/arm.c (arm_legitimate_address_p): New, rename old one to...\n\t(arm_legitimate_address_outer_p): ... this.\n\t(thumb1_legitimate_address_p, thumb2_legitimate_address_p): Make static.\n\t(TARGET_LEGITIMATE_ADDRESS_P): New.\n\n\t* config/mips/mips.h (GO_IF_LEGITIMATE_ADDRESS): Delete.\n\t* config/mips/mips-protos.h (mips_legitimate_address_p): Remove.\n\t* config/mips/mips.c (mips_legitimate_address_p): ... Make static.\n\t(TARGET_LEGITIMATE_ADDRESS_P): New.\n\n\t* config/vax/vax.h (GO_IF_LEGITIMATE_ADDRESS): Delete.\n\t* config/vax/vax-protos.h (legitimate_address_p): Remove.\n\t* config/vax/vax.c (legitimate_address_p): Rename to...\n\t(vax_legitimate_address_p): ... this, make static.\n\t(TARGET_LEGITIMATE_ADDRESS_P): New.\n\n\t* config/h8300/h8300.h (GO_IF_LEGITIMATE_ADDRESS): Delete.\n\t* config/h8300/h8300-protos.h (h8300_legitimate_address_p): Remove.\n\t* config/h8300/h8300.c (h8300_legitimate_address_p): ... Make static.\n\t(TARGET_LEGITIMATE_ADDRESS_P): New.\n\n\t* config/mmix/mmix.h (GO_IF_LEGITIMATE_ADDRESS): Delete.\n\t* config/mmix/mmix-protos.h (mmix_legitimize_address): Remove.\n\t* config/mmix/mmix.c (mmix_legitimate_address): Rename to...\n\t(mmix_legitimate_address_p): ... this, make static.\n\t(TARGET_LEGITIMATE_ADDRESS_P): New.\n\n\t* config/bfin/bfin.h (GO_IF_LEGITIMATE_ADDRESS): Delete.\n\t* config/bfin/bfin-protos.h (bfin_legitimate_address_p): Remove.\n\t* config/bfin/bfin.c (bfin_legitimate_address_p): ... Make static.\n\t(TARGET_LEGITIMATE_ADDRESS_P): New.\n\nFrom-SVN: r147534", "tree": {"sha": "853684f5dcdb1b047d381ddfad61e48c9feee6e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/853684f5dcdb1b047d381ddfad61e48c9feee6e6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c6c3dba931548987c78719180e30ebc863404b89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6c3dba931548987c78719180e30ebc863404b89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6c3dba931548987c78719180e30ebc863404b89", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6c3dba931548987c78719180e30ebc863404b89/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3bd0d9c861f3600eb76397e600358f4e8bc3ada2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bd0d9c861f3600eb76397e600358f4e8bc3ada2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3bd0d9c861f3600eb76397e600358f4e8bc3ada2"}], "stats": {"total": 1180, "additions": 533, "deletions": 647}, "files": [{"sha": "36e48a223ccc46cdcd445c7b633bd1b04b4e2fd7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -1,3 +1,187 @@\n+2009-05-14  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\t* doc/tm.texi (TARGET_LEGITIMATE_ADDRESS_P): Refer mainly to this\n+\tin the former documentation of...\n+\t(GO_IF_LEGITIMATE_ADDRESS): ... this.\n+\t* ira-conflicts.c (get_dup_num): Use address_operand.\n+\t* targhooks.c (default_legitimate_address_p): New.\n+\t* targhooks.h (default_legitimate_address_p): New.\n+\t* reload.c (strict_memory_address_p) [!GO_IF_LEGITIMATE_ADDRESS]:\n+\tCall hook.\n+\t* recog.c (memory_address_p) [!GO_IF_LEGITIMATE_ADDRESS]: Call hook.\n+\t* target.h (struct target): Add legitimate_address_p.\n+\t* target-def.h (TARGET_LEGITIMATE_ADDRESS_P): New.\n+\t(TARGET_INITIALIZER): Include it.\n+\n+\t* config/alpha/alpha.h (GO_IF_LEGITIMATE_ADDRESS): Delete.\n+\t* config/alpha/alpha-protos.h (alpha_legitimate_address_p): Remove.\n+\t* config/alpha/alpha.c (alpha_legitimate_address_p): Make static.\n+\t(TARGET_LEGITIMATE_ADDRESS_P): New.\n+\n+\t* config/frv/frv.h (GO_IF_LEGITIMATE_ADDRESS): Delete.\n+\t(REG_OK_STRICT_P): Delete.\n+\t* config/frv/frv-protos.h (frv_legitimate_address_p): Rename to...\n+\t(frv_legitimate_address_p_1): ... this.\n+\t* config/frv/frv.c (frv_legitimate_address_p): Forward to...\n+\t(frv_legitimate_address_p_1): ... the renamed old\n+\tfrv_legitimate_address_p.\n+\t* config/frv/predicates.md: Adjust calls to frv_legitimate_address_p.\n+\t(TARGET_LEGITIMATE_ADDRESS_P): New.\n+\n+\t* config/s390/s390.h (GO_IF_LEGITIMATE_ADDRESS): Delete.\n+\t* config/s390/s390-protos.h (legitimate_address_p): Remove.\n+\t* config/s390/s390.c (legitimate_address_p): Rename to...\n+\t(s390_legitimate_address_p): ... this, make static.\n+\t(legitimize_address): Adjust call.\n+\t(TARGET_LEGITIMATE_ADDRESS_P): New.\n+\t* config/s390/constraints.md (\"e\"): Call strict_memory_address_p.\n+\n+\t* config/m32c/m32c.h (GO_IF_LEGITIMATE_ADDRESS): Delete.\n+\t* config/m32c/m32c-protos.h (m32c_legitimate_address_p): Remove.\n+\t* config/m32c/m32c.c (m32c_legitimate_address_p): Make static.\n+\t(TARGET_LEGITIMATE_ADDRESS_P): New.\n+\n+\t* config/spu/spu.h (GO_IF_LEGITIMATE_ADDRESS): Delete.\n+\t* config/spu/spu-protos.h (spu_legitimate_address): Remove.\n+\t* config/spu/spu.c (spu_legitimate_address): Rename to...\n+\t(spu_legitimate_address_p): ... this, make static.\n+\t(TARGET_LEGITIMATE_ADDRESS_P): New.\n+\n+\t* config/sparc/sparc.h (GO_IF_LEGITIMATE_ADDRESS): Delete.\n+\t* config/sparc/sparc-protos.h (legitimate_address_p): Remove.\n+\t* config/sparc/sparc.c (legitimate_address_p): Rename to...\n+\t(sparc_legitimate_address_p): ... this, make static and return bool.\n+\t(legitimize_address): Adjust call.\n+\t(TARGET_LEGITIMATE_ADDRESS_P): New.\n+\n+\t* config/i386/i386.h (GO_IF_LEGITIMATE_ADDRESS): Delete.\n+\t* config/i386/i386-protos.h (legitimate_address_p): Remove.\n+\t* config/i386/i386.c (legitimate_address_p): Rename to...\n+\t(ix86_legitimate_address_p): ... this, make static.\n+\t(constant_address_p): Move after it, adjust call.\n+\t(TARGET_LEGITIMATE_ADDRESS_P): New.\n+\n+\t* config/avr/avr.h (GO_IF_LEGITIMATE_ADDRESS): Delete.\n+\t* config/avr/avr-protos.h (legitimate_address_p): Remove.\n+\t* config/avr/avr.c (legitimate_address_p): Rename to...\n+\t(avr_legitimate_address_p): ... this, make static.\n+\t(legitimize_address): Adjust call.\n+\t(TARGET_LEGITIMATE_ADDRESS_P): New.\n+\n+\t* config/crx/crx.h (GO_IF_LEGITIMATE_ADDRESS): Delete.\n+\t* config/crx/crx-protos.h (crx_legitimate_address_p): Remove.\n+\t* config/crx/crx.c (crx_legitimate_address_p): Make static.\n+\t(TARGET_LEGITIMATE_ADDRESS_P): New.\n+\n+\t* config/xtensa/xtensa.h (GO_IF_LEGITIMATE_ADDRESS): Delete.\n+\t* config/xtensa/xtensa-protos.h (xtensa_legitimate_address_p): Remove.\n+\t* config/xtensa/xtensa.c (xtensa_legitimate_address_p): Make static.\n+\t(TARGET_LEGITIMATE_ADDRESS_P): New.\n+\n+\t* config/stormy16/stormy16.h (GO_IF_LEGITIMATE_ADDRESS): Delete.\n+\t* config/stormy16/stormy16-protos.h (xstormy16_legitimate_address_p):\n+\tRemove.\n+\t* config/stormy16/stormy16.c (xstormy16_legitimate_address_p):\n+\tMake static.\n+\t(TARGET_LEGITIMATE_ADDRESS_P): New.\n+\n+\t* config/m68hc11/m68hc11.h (GO_IF_LEGITIMATE_ADDRESS): Delete.\n+\t* config/m68hc11/m68hc11-protos.h (m68hc11_go_if_legitimate_address):\n+\tRemove.\n+\t* config/m68hc11/m68hc11.c (m68hc11_go_if_legitimate_address):\n+\tRename to...\n+\t(m68hc11_legitimate_address_p): ... this, make static.\n+\t(go_if_legitimate_address_internal): Rename to...\n+\t(m68hc11_legitimate_address_p_1): ... this.\n+\t(legitimize_address): Adjust call.\n+\t(TARGET_LEGITIMATE_ADDRESS_P): New.\n+\n+\t* config/iq2000/iq2000.h (GO_IF_LEGITIMATE_ADDRESS): Delete.\n+\t* config/iq2000/iq2000-protos.h (iq2000_legitimate_address_p):\n+\tRemove.\n+\t* config/iq2000/iq2000.c (iq2000_legitimate_address_p):\n+\tMake static.\n+\t(TARGET_LEGITIMATE_ADDRESS_P): New.\n+\n+\t* config/mn10300/mn10300.h (GO_IF_LEGITIMATE_ADDRESS): Delete.\n+\t* config/mn10300/mn10300-protos.h (legitimate_address_p): Remove.\n+\t* config/mn10300/mn10300.c (legitimate_address_p): Rename to...\n+\t(mn10300_legitimate_address_p): ... this, make static.\n+\t(TARGET_LEGITIMATE_ADDRESS_P): New.\n+\n+\t* config/m68k/m68k.h (GO_IF_LEGITIMATE_ADDRESS): Delete.\n+\t* config/m68k/m68k-protos.h (m68k_legitimate_address_p): Remove.\n+\t* config/m68k/m68k.c (m68k_legitimate_address_p): Make static.\n+\t(TARGET_LEGITIMATE_ADDRESS_P): New.\n+\n+\t* config/rs6000/rs6000.h (GO_IF_LEGITIMATE_ADDRESS): Delete.\n+\t(REG_OK_STRICT_FLAG, REG_OK_FOR_BASE_P, REG_OK_FOR_INDEX_P): Delete.\n+\t(INT_REG_OK_FOR_BASE_P, INT_REG_OK_FOR_INDEX_P): Move above.\n+\t* config/rs6000/rs6000.h (GO_IF_LEGITIMATE_ADDRESS): Delete.\n+\t* config/rs6000/rs6000-protos.h (rs6000_legitimate_address): Remove.\n+\t* config/rs6000/rs6000.c (rs6000_legitimate_address): Rename to...\n+\t(rs6000_legitimate_address_p): ... this, make static.\n+\t(TARGET_LEGITIMATE_ADDRESS_P): New.\n+\t(REG_MODE_OK_FOR_BASE_P): Delete.\n+\t(rs6000_legitimize_reload_address): Use INT_REG_OK_FOR_BASE_P.\n+\n+\t* config/picochip/picochip.h (GO_IF_LEGITIMATE_ADDRESS): Delete.\n+\t* config/picochip/picochip-protos.h (picochip_legitimate_address_p):\n+\tDelete.\n+\t* config/picochip/picochip.c (picochip_legitimate_address_p): Make\n+\tstatic, adjust types.\n+\t(TARGET_LEGITIMATE_ADDRESS_P): New.\n+\n+\t* config/score/score.h (GO_IF_LEGITIMATE_ADDRESS): Delete.\n+\t* config/score/score.c (score_address_p): Rename to...\n+\t(score_legitimate_address_p): ... this.\n+\t(TARGET_LEGITIMATE_ADDRESS_P): New.\n+\t* config/score/score3.c (score3_address_p): Rename to...\n+\t(score3_legitimate_address_p): ... this.\n+\t* config/score/score7.c (score7_address_p): Rename to...\n+\t(score7_legitimate_address_p): ... this.\n+\n+\t* config/arm/arm.h (ARM_GO_IF_LEGITIMATE_ADDRESS,\n+\tTHUMB2_GO_IF_LEGITIMATE_ADDRESS, THUMB1_GO_IF_LEGITIMATE_ADDRESS,\n+\tGO_IF_LEGITIMATE_ADDRESS): Delete.\n+\t* config/arm/arm-protos.h (thumb1_legitimate_address_p,\n+\tthumb2_legitimate_address_p): Delete.\n+\t(arm_legitimate_address_p): Rename to...\n+\t(arm_legitimate_address_outer_p): ... this.\n+\t* config/arm/constraints.md (\"Uq\"): Adjust call.\n+\t* config/arm/predicates.md (arm_extendqisi_mem_op): Likewise.\n+\t* config/arm/arm.c (arm_legitimate_address_p): New, rename old one to...\n+\t(arm_legitimate_address_outer_p): ... this.\n+\t(thumb1_legitimate_address_p, thumb2_legitimate_address_p): Make static.\n+\t(TARGET_LEGITIMATE_ADDRESS_P): New.\n+\n+\t* config/mips/mips.h (GO_IF_LEGITIMATE_ADDRESS): Delete.\n+\t* config/mips/mips-protos.h (mips_legitimate_address_p): Remove.\n+\t* config/mips/mips.c (mips_legitimate_address_p): ... Make static.\n+\t(TARGET_LEGITIMATE_ADDRESS_P): New.\n+\n+\t* config/vax/vax.h (GO_IF_LEGITIMATE_ADDRESS): Delete.\n+\t* config/vax/vax-protos.h (legitimate_address_p): Remove.\n+\t* config/vax/vax.c (legitimate_address_p): Rename to...\n+\t(vax_legitimate_address_p): ... this, make static.\n+\t(TARGET_LEGITIMATE_ADDRESS_P): New.\n+\n+\t* config/h8300/h8300.h (GO_IF_LEGITIMATE_ADDRESS): Delete.\n+\t* config/h8300/h8300-protos.h (h8300_legitimate_address_p): Remove.\n+\t* config/h8300/h8300.c (h8300_legitimate_address_p): ... Make static.\n+\t(TARGET_LEGITIMATE_ADDRESS_P): New.\n+\n+\t* config/mmix/mmix.h (GO_IF_LEGITIMATE_ADDRESS): Delete.\n+\t* config/mmix/mmix-protos.h (mmix_legitimize_address): Remove.\n+\t* config/mmix/mmix.c (mmix_legitimate_address): Rename to...\n+\t(mmix_legitimate_address_p): ... this, make static.\n+\t(TARGET_LEGITIMATE_ADDRESS_P): New.\n+\n+\t* config/bfin/bfin.h (GO_IF_LEGITIMATE_ADDRESS): Delete.\n+\t* config/bfin/bfin-protos.h (bfin_legitimate_address_p): Remove.\n+\t* config/bfin/bfin.c (bfin_legitimate_address_p): ... Make static.\n+\t(TARGET_LEGITIMATE_ADDRESS_P): New.\n+\n 2009-05-14  Paolo Bonzini  <bonzini@gnu.org>\n \n \t* config/arm/arm.h (PROMOTE_FUNCTION_MODE): Remove handling"}, {"sha": "80c1e4f8f63181ffb409572fb8118958c1fe129e", "filename": "gcc/config/alpha/alpha-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha-protos.h?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -38,7 +38,6 @@ extern rtx alpha_tablejump_addr_vec (rtx);\n extern rtx alpha_tablejump_best_label (rtx);\n \n extern bool alpha_legitimate_constant_p (rtx);\n-extern bool alpha_legitimate_address_p (enum machine_mode, rtx, int);\n extern rtx alpha_legitimize_reload_address (rtx, enum machine_mode,\n \t\t\t\t\t    int, int, int);\n "}, {"sha": "368ef507995d91f3885414c3066960dc424be3ec", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -801,8 +801,8 @@ alpha_linkage_symbol_p (const char *symname)\n    any of those forms can be surrounded with an AND that clear the\n    low-order three bits; this is an \"unaligned\" access.  */\n \n-bool\n-alpha_legitimate_address_p (enum machine_mode mode, rtx x, int strict)\n+static bool\n+alpha_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n {\n   /* If this is an ldq_u type address, discard the outer AND.  */\n   if (mode == DImode\n@@ -10839,6 +10839,9 @@ alpha_init_libfuncs (void)\n #define TARGET_MANGLE_TYPE alpha_mangle_type\n #endif\n \n+#undef TARGET_LEGITIMATE_ADDRESS_P\n+#define TARGET_LEGITIMATE_ADDRESS_P alpha_legitimate_address_p\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n \f"}, {"sha": "3bfbd50e89e42d2661f0b2ec63524e91382c5941", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -974,23 +974,6 @@ do {\t\t\t\t\t\t\\\n #define REG_OK_FOR_BASE_P(X)\tNONSTRICT_REG_OK_FOR_BASE_P (X)\n #endif\n \f\n-/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression that is a\n-   valid memory address for an instruction.  */\n-\n-#ifdef REG_OK_STRICT\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, WIN)\t\\\n-do {\t\t\t\t\t\t\\\n-  if (alpha_legitimate_address_p (MODE, X, 1))\t\\\n-    goto WIN;\t\t\t\t\t\\\n-} while (0)\n-#else\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, WIN)\t\\\n-do {\t\t\t\t\t\t\\\n-  if (alpha_legitimate_address_p (MODE, X, 0))\t\\\n-    goto WIN;\t\t\t\t\t\\\n-} while (0)\n-#endif\n-\n /* Try a machine-dependent way of reloading an illegitimate address\n    operand.  If we find one, push the reload and jump to WIN.  This\n    macro is used in only one place: `find_reloads_address' in reload.c.  */"}, {"sha": "3b7ba794fa452c1a4b30656cf365923021fe1cbf", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -54,9 +54,7 @@ extern RTX_CODE arm_canonicalize_comparison (RTX_CODE, enum machine_mode,\n extern int legitimate_pic_operand_p (rtx);\n extern rtx legitimize_pic_address (rtx, enum machine_mode, rtx);\n extern rtx legitimize_tls_address (rtx, rtx);\n-extern int arm_legitimate_address_p  (enum machine_mode, rtx, RTX_CODE, int);\n-extern int thumb1_legitimate_address_p (enum machine_mode, rtx, int);\n-extern int thumb2_legitimate_address_p  (enum machine_mode, rtx, int);\n+extern int arm_legitimate_address_outer_p (enum machine_mode, rtx, RTX_CODE, int);\n extern int thumb_legitimate_offset_p (enum machine_mode, HOST_WIDE_INT);\n extern rtx thumb_legitimize_reload_address (rtx *, enum machine_mode, int, int,\n \t\t\t\t\t    int);"}, {"sha": "464bba577206708e2041b7d17cd625b36838f6ff", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -76,6 +76,7 @@ static int thumb1_base_register_rtx_p (rtx, enum machine_mode, int);\n static rtx arm_legitimize_address (rtx, rtx, enum machine_mode);\n static rtx thumb_legitimize_address (rtx, rtx, enum machine_mode);\n inline static int thumb1_index_register_rtx_p (rtx, int);\n+static bool arm_legitimate_address_p (enum machine_mode, rtx, bool);\n static int thumb_far_jump_used_p (void);\n static bool thumb_force_lr_save (void);\n static int const_ok_for_op (HOST_WIDE_INT, enum rtx_code);\n@@ -403,6 +404,9 @@ static bool arm_allocate_stack_slots_for_args (void);\n #define TARGET_ASM_OUTPUT_DWARF_DTPREL arm_output_dwarf_dtprel\n #endif\n \n+#undef TARGET_LEGITIMATE_ADDRESS_P\n+#define TARGET_LEGITIMATE_ADDRESS_P\tarm_legitimate_address_p\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Obstack for minipool constant handling.  */\n@@ -3914,8 +3918,8 @@ pcrel_constant_p (rtx x)\n \n /* Return nonzero if X is a valid ARM state address operand.  */\n int\n-arm_legitimate_address_p (enum machine_mode mode, rtx x, RTX_CODE outer,\n-\t\t\t  int strict_p)\n+arm_legitimate_address_outer_p (enum machine_mode mode, rtx x, RTX_CODE outer,\n+\t\t\t        int strict_p)\n {\n   bool use_ldrd;\n   enum rtx_code code = GET_CODE (x);\n@@ -3999,7 +4003,7 @@ arm_legitimate_address_p (enum machine_mode mode, rtx x, RTX_CODE outer,\n }\n \n /* Return nonzero if X is a valid Thumb-2 address operand.  */\n-int\n+static int\n thumb2_legitimate_address_p (enum machine_mode mode, rtx x, int strict_p)\n {\n   bool use_ldrd;\n@@ -4305,7 +4309,7 @@ thumb1_index_register_rtx_p (rtx x, int strict_p)\n    addresses based on the frame pointer or arg pointer until the\n    reload pass starts.  This is so that eliminating such addresses\n    into stack based ones won't produce impossible code.  */\n-int\n+static int\n thumb1_legitimate_address_p (enum machine_mode mode, rtx x, int strict_p)\n {\n   /* ??? Not clear if this is right.  Experiment.  */\n@@ -4419,6 +4423,17 @@ thumb_legitimate_offset_p (enum machine_mode mode, HOST_WIDE_INT val)\n     }\n }\n \n+bool\n+arm_legitimate_address_p (enum machine_mode mode, rtx x, bool strict_p)\n+{\n+  if (TARGET_ARM)\n+    return arm_legitimate_address_outer_p (mode, x, SET, strict_p);\n+  else if (TARGET_THUMB2)\n+    return thumb2_legitimate_address_p (mode, x, strict_p);\n+  else /* if (TARGET_THUMB1) */\n+    return thumb1_legitimate_address_p (mode, x, strict_p);\n+}\n+\n /* Build the SYMBOL_REF for __tls_get_addr.  */\n \n static GTY(()) rtx tls_get_addr_libfunc;\n@@ -4654,7 +4669,7 @@ arm_legitimize_address (rtx x, rtx orig_x, enum machine_mode mode)\n     }\n \n   /* XXX We don't allow MINUS any more -- see comment in\n-     arm_legitimate_address_p ().  */\n+     arm_legitimate_address_outer_p ().  */\n   else if (GET_CODE (x) == MINUS)\n     {\n       rtx xop0 = XEXP (x, 0);"}, {"sha": "ee0eee694d244f813a72d193d2b8019913ed77e0", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -2161,43 +2161,11 @@ typedef struct\n #define REG_MODE_OK_FOR_REG_BASE_P(X, MODE)\t\\\n   REG_OK_FOR_INDEX_P (X)\n \f\n-/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n-   that is a valid memory address for an instruction.\n-   The MODE argument is the machine mode for the MEM expression\n-   that wants to use this address.  */\n-\n #define ARM_BASE_REGISTER_RTX_P(X)  \\\n   (GET_CODE (X) == REG && ARM_REG_OK_FOR_BASE_P (X))\n \n #define ARM_INDEX_REGISTER_RTX_P(X)  \\\n   (GET_CODE (X) == REG && ARM_REG_OK_FOR_INDEX_P (X))\n-\n-#define ARM_GO_IF_LEGITIMATE_ADDRESS(MODE,X,WIN)\t\t\\\n-  {\t\t\t\t\t\t\t\t\\\n-    if (arm_legitimate_address_p (MODE, X, SET, REG_STRICT_P))\t\\\n-      goto WIN;\t\t\t\t\t\t\t\\\n-  }\n-\n-#define THUMB2_GO_IF_LEGITIMATE_ADDRESS(MODE,X,WIN)\t\t\\\n-  {\t\t\t\t\t\t\t\t\\\n-    if (thumb2_legitimate_address_p (MODE, X, REG_STRICT_P))\t\\\n-      goto WIN;\t\t\t\t\t\t\t\\\n-  }\n-\n-#define THUMB1_GO_IF_LEGITIMATE_ADDRESS(MODE,X,WIN)\t\t\\\n-  {\t\t\t\t\t\t\t\t\\\n-    if (thumb1_legitimate_address_p (MODE, X, REG_STRICT_P))\t\\\n-      goto WIN;\t\t\t\t\t\t\t\\\n-  }\n-\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, WIN)\t\t\t\t\\\n-  if (TARGET_ARM)\t\t\t\t\t\t\t\\\n-    ARM_GO_IF_LEGITIMATE_ADDRESS (MODE, X, WIN)  \t\t\t\\\n-  else if (TARGET_THUMB2)\t\t\t\t\t\t\\\n-    THUMB2_GO_IF_LEGITIMATE_ADDRESS (MODE, X, WIN)  \t\t\t\\\n-  else /* if (TARGET_THUMB1) */\t\t\t\t\t\t\\\n-    THUMB1_GO_IF_LEGITIMATE_ADDRESS (MODE, X, WIN)\n-\n \f\n /* Define this for compatibility reasons. */\n #define HANDLE_PRAGMA_PACK_PUSH_POP"}, {"sha": "b5ade5ce1f323d7069a882cb9b5d9b69e696c0ec", "filename": "gcc/config/arm/constraints.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Farm%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Farm%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fconstraints.md?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -231,8 +231,8 @@\n   In ARM state an address valid in ldrsb instructions.\"\n  (and (match_code \"mem\")\n       (match_test \"TARGET_ARM\n-\t\t   && arm_legitimate_address_p (GET_MODE (op), XEXP (op, 0),\n-\t\t\t\t\t\tSIGN_EXTEND, 0)\")))\n+\t\t   && arm_legitimate_address_outer_p (GET_MODE (op), XEXP (op, 0),\n+\t\t\t\t\t\t      SIGN_EXTEND, 0)\")))\n \n (define_memory_constraint \"Q\"\n  \"@internal"}, {"sha": "7997cc94cf5ec311ef7560f531ca3e7be42f945a", "filename": "gcc/config/arm/predicates.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Farm%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Farm%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fpredicates.md?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -235,8 +235,8 @@\n \n (define_special_predicate \"arm_extendqisi_mem_op\"\n   (and (match_operand 0 \"memory_operand\")\n-       (match_test \"arm_legitimate_address_p (mode, XEXP (op, 0), SIGN_EXTEND,\n-\t\t\t\t\t      0)\")))\n+       (match_test \"arm_legitimate_address_outer_p (mode, XEXP (op, 0),\n+\t\t\t\t\t\t    SIGN_EXTEND, 0)\")))\n \n (define_special_predicate \"arm_reg_or_extendqisi_mem_op\"\n   (ior (match_operand 0 \"arm_extendqisi_mem_op\")"}, {"sha": "03b84c00049865b0de0e2220a3c906da2cc69f2d", "filename": "gcc/config/avr/avr-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Favr%2Favr-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Favr%2Favr-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-protos.h?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -61,7 +61,6 @@ extern void function_arg_advance (CUMULATIVE_ARGS *cum,\n \n #ifdef RTX_CODE\n extern void asm_output_external_libcall (FILE *file, rtx symref);\n-extern int legitimate_address_p (enum machine_mode mode, rtx x,\tint strict);\n extern int compare_diff_p (rtx insn);\n extern const char *output_movqi (rtx insn, rtx operands[], int *l);\n extern const char *output_movhi (rtx insn, rtx operands[], int *l);"}, {"sha": "ed668b674951c05b472b21d6086273ba579f31dc", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -71,6 +71,7 @@ const struct attribute_spec avr_attribute_table[];\n static bool avr_assemble_integer (rtx, unsigned int, int);\n static void avr_file_start (void);\n static void avr_file_end (void);\n+static bool avr_legitimate_address_p (enum machine_mode, rtx, bool);\n static void avr_asm_function_end_prologue (FILE *);\n static void avr_asm_function_begin_epilogue (FILE *);\n static rtx avr_function_value (const_tree, const_tree, bool);\n@@ -367,6 +368,9 @@ static const struct mcu_type_s avr_mcu_types[] = {\n #undef TARGET_CASE_VALUES_THRESHOLD\n #define TARGET_CASE_VALUES_THRESHOLD avr_case_values_threshold\n \n+#undef TARGET_LEGITIMATE_ADDRESS_P\n+#define TARGET_LEGITIMATE_ADDRESS_P avr_legitimate_address_p\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n void\n@@ -1099,8 +1103,8 @@ avr_asm_function_begin_epilogue (FILE *file)\n /* Return nonzero if X (an RTX) is a legitimate memory address on the target\n    machine for a memory operand of mode MODE.  */\n \n-int\n-legitimate_address_p (enum machine_mode mode, rtx x, int strict)\n+bool\n+avr_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n {\n   enum reg_class r = NO_REGS;\n   "}, {"sha": "d431790a647fb150b7f86cda788c6bb2bda0500d", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -408,20 +408,6 @@ extern int avr_reg_order[];\n \n #define MAX_REGS_PER_ADDRESS 1\n \n-#ifdef REG_OK_STRICT\n-#  define GO_IF_LEGITIMATE_ADDRESS(mode, operand, ADDR)\t\\\n-{\t\t\t\t\t\t\t\\\n-  if (legitimate_address_p (mode, operand, 1))\t\t\\\n-    goto ADDR;\t\t\t\t\t\t\\\n-}\n-#  else\n-#  define GO_IF_LEGITIMATE_ADDRESS(mode, operand, ADDR)\t\\\n-{\t\t\t\t\t\t\t\\\n-  if (legitimate_address_p (mode, operand, 0))\t\t\\\n-    goto ADDR;\t\t\t\t\t\t\\\n-}\n-#endif\n-\n #define REG_OK_FOR_BASE_NOSTRICT_P(X) \\\n   (REGNO (X) >= FIRST_PSEUDO_REGISTER || REG_OK_FOR_BASE_STRICT_P(X))\n "}, {"sha": "13542411221cea0b5898e2aa080cf252419694a5", "filename": "gcc/config/bfin/bfin-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fbfin%2Fbfin-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fbfin%2Fbfin-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin-protos.h?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -146,7 +146,6 @@ extern rtx bfin_gen_compare (rtx, Mmode);\n \n extern int bfin_local_alignment (tree, int);\n extern void initialize_trampoline (rtx, rtx, rtx);\n-extern bool bfin_legitimate_address_p (Mmode, rtx, int);\n extern rtx bfin_va_arg (tree, tree);\n \n extern void bfin_expand_prologue (void);"}, {"sha": "f4a8c4dc3d45607a73ee2cb5c7a54cd0d1a3a6e5", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -2895,8 +2895,26 @@ bfin_valid_reg_p (unsigned int regno, int strict, enum machine_mode mode,\n     return REGNO_OK_FOR_BASE_NONSTRICT_P (regno, mode, outer_code, SCRATCH);\n }\n \n-bool\n-bfin_legitimate_address_p (enum machine_mode mode, rtx x, int strict)\n+/* Recognize an RTL expression that is a valid memory address for an\n+   instruction.  The MODE argument is the machine mode for the MEM expression\n+   that wants to use this address. \n+\n+   Blackfin addressing modes are as follows:\n+\n+      [preg]\n+      [preg + imm16]\n+\n+      B [ Preg + uimm15 ]\n+      W [ Preg + uimm16m2 ]\n+      [ Preg + uimm17m4 ] \n+\n+      [preg++]\n+      [preg--]\n+      [--sp]\n+*/\n+\n+static bool\n+bfin_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n {\n   switch (GET_CODE (x)) {\n   case REG:\n@@ -6318,4 +6336,7 @@ bfin_expand_builtin (tree exp, rtx target ATTRIBUTE_UNUSED,\n #undef TARGET_RETURN_IN_MEMORY\n #define TARGET_RETURN_IN_MEMORY bfin_return_in_memory\n \n+#undef TARGET_LEGITIMATE_ADDRESS_P\n+#define TARGET_LEGITIMATE_ADDRESS_P\tbfin_legitimate_address_p\n+\n struct gcc_target targetm = TARGET_INITIALIZER;"}, {"sha": "7cd6756309bd225c777441be3af7601fc2fc9c61", "filename": "gcc/config/bfin/bfin.h", "status": "modified", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fbfin%2Fbfin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fbfin%2Fbfin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.h?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -912,42 +912,9 @@ typedef struct {\n      would ever accept. */\n #define MAX_REGS_PER_ADDRESS 1\n \n-/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n-   that is a valid memory address for an instruction.\n-   The MODE argument is the machine mode for the MEM expression\n-   that wants to use this address. \n-\n-   Blackfin addressing modes are as follows:\n-\n-      [preg]\n-      [preg + imm16]\n-\n-      B [ Preg + uimm15 ]\n-      W [ Preg + uimm16m2 ]\n-      [ Preg + uimm17m4 ] \n-\n-      [preg++]\n-      [preg--]\n-      [--sp]\n-*/\n-\n #define LEGITIMATE_MODE_FOR_AUTOINC_P(MODE) \\\n       (GET_MODE_SIZE (MODE) <= 4 || (MODE) == PDImode)\n \n-#ifdef REG_OK_STRICT\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, WIN)\t\t\\\n-  do {\t\t\t\t\t\t\t\\\n-    if (bfin_legitimate_address_p (MODE, X, 1))\t\t\\\n-      goto WIN;\t\t\t\t\t\t\\\n-  } while (0);\n-#else\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, WIN)\t\t\\\n-  do {\t\t\t\t\t\t\t\\\n-    if (bfin_legitimate_address_p (MODE, X, 0))\t\t\\\n-      goto WIN;\t\t\t\t\t\t\\\n-  } while (0);\n-#endif\n-\n #define HAVE_POST_INCREMENT 1\n #define HAVE_POST_DECREMENT 1\n #define HAVE_PRE_DECREMENT  1"}, {"sha": "b35051d99f5dfb047183203f04e0f8fc888f5e8e", "filename": "gcc/config/crx/crx-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fcrx%2Fcrx-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fcrx%2Fcrx-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcrx%2Fcrx-protos.h?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -53,7 +53,6 @@ enum crx_addrtype\n };\n \n extern enum crx_addrtype crx_decompose_address (rtx addr, struct crx_address *out);\n-extern int crx_legitimate_address_p (enum machine_mode, rtx, int);\n \n extern int crx_const_double_ok (rtx op);\n "}, {"sha": "c45189eb0d36ad2ef03bc1eacc74d239b24edcb2", "filename": "gcc/config/crx/crx.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fcrx%2Fcrx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fcrx%2Fcrx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcrx%2Fcrx.c?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -133,6 +133,14 @@ static rtx crx_struct_value_rtx (tree fntype ATTRIBUTE_UNUSED,\n \t\t\t\t int incoming ATTRIBUTE_UNUSED);\n static bool crx_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED);\n static int crx_address_cost (rtx, bool);\n+static bool crx_legitimate_address_p (enum machine_mode, rtx, bool);\n+\n+/*****************************************************************************/\n+/* RTL VALIDITY\t\t\t\t\t\t\t\t     */\n+/*****************************************************************************/\n+\n+#undef TARGET_LEGITIMATE_ADDRESS_P\n+#define TARGET_LEGITIMATE_ADDRESS_P\tcrx_legitimate_address_p\n \n /*****************************************************************************/\n /* STACK LAYOUT AND CALLING CONVENTIONS\t\t\t\t\t     */\n@@ -722,9 +730,9 @@ crx_decompose_address (rtx addr, struct crx_address *out)\n   return retval;\n }\n \n-int\n+bool\n crx_legitimate_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t\t  rtx addr, int strict)\n+\t\t\t  rtx addr, bool strict)\n {\n   enum crx_addrtype addrtype;\n   struct crx_address address;"}, {"sha": "d22db7da9038818d042875f66eb14ac46df2c8ba", "filename": "gcc/config/crx/crx.h", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fcrx%2Fcrx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fcrx%2Fcrx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcrx%2Fcrx.h?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -404,20 +404,6 @@ struct cumulative_args\n #define REG_OK_FOR_INDEX_P(X)\t1\n #endif /* REG_OK_STRICT */\n \n-#ifdef REG_OK_STRICT\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, LABEL)\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  if (crx_legitimate_address_p (MODE, X, 1))\t\t\t\t\\\n-      goto LABEL;\t\t\t\t\t\t\t\\\n-}\n-#else\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, LABEL)\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  if (crx_legitimate_address_p (MODE, X, 0))\t\t\t\t\\\n-      goto LABEL;\t\t\t\t\t\t\t\\\n-}\n-#endif /* REG_OK_STRICT */\n-\n #define LEGITIMATE_CONSTANT_P(X)  1\n \n /*****************************************************************************/"}, {"sha": "56f424396402799d263e7df5621815d7cb13d5eb", "filename": "gcc/config/frv/frv-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Ffrv%2Ffrv-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Ffrv%2Ffrv-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv-protos.h?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -47,7 +47,7 @@ extern int frv_frame_pointer_required\t\t(void);\n extern int frv_initial_elimination_offset\t(int, int);\n \n #ifdef RTX_CODE\n-extern int frv_legitimate_address_p\t\t(enum machine_mode, rtx,\n+extern int frv_legitimate_address_p_1\t\t(enum machine_mode, rtx,\n \t\t\t\t\t\t int, int, int);\n extern rtx frv_find_base_term\t\t\t(rtx);\n "}, {"sha": "1db3496b5be70396d5f832c0d8c56166f05c9b63", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -264,6 +264,7 @@ frv_cpu_t frv_cpu_type = CPU_TYPE;\t/* value of -mcpu= */\n /* Forward references */\n \n static bool frv_handle_option\t\t\t(size_t, const char *, int);\n+static bool frv_legitimate_address_p\t\t(enum machine_mode, rtx, bool);\n static int frv_default_flags_for_cpu\t\t(void);\n static int frv_string_begins_with\t\t(const_tree, const char *);\n static FRV_INLINE bool frv_small_data_reloc_p\t(rtx, int);\n@@ -467,6 +468,9 @@ static bool frv_secondary_reload                (bool, rtx, enum reg_class,\n #undef  TARGET_SECONDARY_RELOAD\n #define TARGET_SECONDARY_RELOAD frv_secondary_reload\n \n+#undef TARGET_LEGITIMATE_ADDRESS_P\n+#define TARGET_LEGITIMATE_ADDRESS_P frv_legitimate_address_p\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n #define FRV_SYMBOL_REF_TLS_P(RTX) \\\n@@ -2532,7 +2536,7 @@ frv_return_addr_rtx (int count, rtx frame)\n    MEMREF has already happened.\n \n    MEMREF must be a legitimate operand for modes larger than SImode.\n-   GO_IF_LEGITIMATE_ADDRESS forbids register+register addresses, which\n+   frv_legitimate_address_p forbids register+register addresses, which\n    this function cannot handle.  */\n rtx\n frv_index_memory (rtx memref, enum machine_mode mode, int index)\n@@ -3358,11 +3362,11 @@ frv_regno_ok_for_base_p (int regno, int strict_p)\n    `PRINT_OPERAND_ADDRESS'.  */\n \n int\n-frv_legitimate_address_p (enum machine_mode mode,\n-                          rtx x,\n-                          int strict_p,\n-                          int condexec_p,\n-\t\t\t  int allow_double_reg_p)\n+frv_legitimate_address_p_1 (enum machine_mode mode,\n+                            rtx x,\n+                            int strict_p,\n+                            int condexec_p,\n+\t\t\t    int allow_double_reg_p)\n {\n   rtx x0, x1;\n   int ret = 0;\n@@ -3489,6 +3493,12 @@ frv_legitimate_address_p (enum machine_mode mode,\n   return ret;\n }\n \n+bool\n+frv_legitimate_address_p (enum machine_mode mode, rtx x, bool strict_p)\n+{\n+  return frv_legitimate_address_p_1 (mode, x, strict_p, FALSE, FALSE);\n+}\n+\n /* Given an ADDR, generate code to inline the PLT.  */\n static rtx\n gen_inlined_tls_plt (rtx addr)\n@@ -3783,8 +3793,8 @@ frv_legitimate_memory_operand (rtx op, enum machine_mode mode, int condexec_p)\n {\n   return ((GET_MODE (op) == mode || mode == VOIDmode)\n \t  && GET_CODE (op) == MEM\n-\t  && frv_legitimate_address_p (mode, XEXP (op, 0),\n-\t\t\t\t       reload_completed, condexec_p, FALSE));\n+\t  && frv_legitimate_address_p_1 (mode, XEXP (op, 0),\n+\t\t\t\t         reload_completed, condexec_p, FALSE));\n }\n \n void\n@@ -3944,7 +3954,7 @@ condexec_memory_operand (rtx op, enum machine_mode mode)\n     return FALSE;\n \n   addr = XEXP (op, 0);\n-  return frv_legitimate_address_p (mode, addr, reload_completed, TRUE, FALSE);\n+  return frv_legitimate_address_p_1 (mode, addr, reload_completed, TRUE, FALSE);\n }\n \f\n /* Return true if the bare return instruction can be used outside of the\n@@ -5846,7 +5856,7 @@ frv_ifcvt_rewrite_mem (rtx mem, enum machine_mode mode, rtx insn)\n {\n   rtx addr = XEXP (mem, 0);\n \n-  if (!frv_legitimate_address_p (mode, addr, reload_completed, TRUE, FALSE))\n+  if (!frv_legitimate_address_p_1 (mode, addr, reload_completed, TRUE, FALSE))\n     {\n       if (GET_CODE (addr) == PLUS)\n \t{"}, {"sha": "e605bb21a8e8a7e70b04e07633c6946126b8fc04", "filename": "gcc/config/frv/frv.h", "status": "modified", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Ffrv%2Ffrv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Ffrv%2Ffrv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.h?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -2025,77 +2025,6 @@ __asm__(\"\\n\"\t\t\t\t\t\t\t\t\\\n    number that `GO_IF_LEGITIMATE_ADDRESS' would ever accept.  */\n #define MAX_REGS_PER_ADDRESS 2\n \n-/* A C compound statement with a conditional `goto LABEL;' executed if X (an\n-   RTX) is a legitimate memory address on the target machine for a memory\n-   operand of mode MODE.\n-\n-   It usually pays to define several simpler macros to serve as subroutines for\n-   this one.  Otherwise it may be too complicated to understand.\n-\n-   This macro must exist in two variants: a strict variant and a non-strict\n-   one.  The strict variant is used in the reload pass.  It must be defined so\n-   that any pseudo-register that has not been allocated a hard register is\n-   considered a memory reference.  In contexts where some kind of register is\n-   required, a pseudo-register with no hard register must be rejected.\n-\n-   The non-strict variant is used in other passes.  It must be defined to\n-   accept all pseudo-registers in every context where some kind of register is\n-   required.\n-\n-   Compiler source files that want to use the strict variant of this macro\n-   define the macro `REG_OK_STRICT'.  You should use an `#ifdef REG_OK_STRICT'\n-   conditional to define the strict variant in that case and the non-strict\n-   variant otherwise.\n-\n-   Subroutines to check for acceptable registers for various purposes (one for\n-   base registers, one for index registers, and so on) are typically among the\n-   subroutines used to define `GO_IF_LEGITIMATE_ADDRESS'.  Then only these\n-   subroutine macros need have two variants; the higher levels of macros may be\n-   the same whether strict or not.\n-\n-   Normally, constant addresses which are the sum of a `symbol_ref' and an\n-   integer are stored inside a `const' RTX to mark them as constant.\n-   Therefore, there is no need to recognize such sums specifically as\n-   legitimate addresses.  Normally you would simply recognize any `const' as\n-   legitimate.\n-\n-   Usually `PRINT_OPERAND_ADDRESS' is not prepared to handle constant sums that\n-   are not marked with `const'.  It assumes that a naked `plus' indicates\n-   indexing.  If so, then you *must* reject such naked constant sums as\n-   illegitimate addresses, so that none of them will be given to\n-   `PRINT_OPERAND_ADDRESS'.\n-\n-   On some machines, whether a symbolic address is legitimate depends on the\n-   section that the address refers to.  On these machines, define the macro\n-   `ENCODE_SECTION_INFO' to store the information into the `symbol_ref', and\n-   then check for it here.  When you see a `const', you will have to look\n-   inside it to find the `symbol_ref' in order to determine the section.\n-\n-   The best way to modify the name string is by adding text to the beginning,\n-   with suitable punctuation to prevent any ambiguity.  Allocate the new name\n-   in `saveable_obstack'.  You will have to modify `ASM_OUTPUT_LABELREF' to\n-   remove and decode the added text and output the name accordingly, and define\n-   `(* targetm.strip_name_encoding)' to access the original name string.\n-\n-   You can check the information stored here into the `symbol_ref' in the\n-   definitions of the macros `GO_IF_LEGITIMATE_ADDRESS' and\n-   `PRINT_OPERAND_ADDRESS'.  */\n-\n-#ifdef REG_OK_STRICT\n-#define REG_OK_STRICT_P 1\n-#else\n-#define REG_OK_STRICT_P 0\n-#endif\n-\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, LABEL)\t\t\t\\\n-  do\t\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      if (frv_legitimate_address_p (MODE, X, REG_OK_STRICT_P,\t\t\\\n- \t\t\t\t    FALSE, FALSE))\t\t\t\\\n-\tgoto LABEL;\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  while (0)\n-\n /* A C expression that is nonzero if X (assumed to be a `reg' RTX) is valid for\n    use as a base register.  For hard registers, it should always accept those\n    which the hardware permits and reject the others.  Whether the macro accepts"}, {"sha": "4ecfa9aed45947bc21bfb944c4e55d669d51a846", "filename": "gcc/config/frv/predicates.md", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Ffrv%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Ffrv%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Fpredicates.md?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -239,8 +239,8 @@\n       subreg = SUBREG_REG (op);\n       code = GET_CODE (subreg);\n       if (code == MEM)\n-\treturn frv_legitimate_address_p (mode, XEXP (subreg, 0),\n-\t\t\t\t\t reload_completed, FALSE, FALSE);\n+\treturn frv_legitimate_address_p_1 (mode, XEXP (subreg, 0),\n+\t\t\t\t\t   reload_completed, FALSE, FALSE);\n \n       return (code == REG);\n \n@@ -278,8 +278,8 @@\n       subreg = SUBREG_REG (op);\n       code = GET_CODE (subreg);\n       if (code == MEM)\n-\treturn frv_legitimate_address_p (mode, XEXP (subreg, 0),\n-\t\t\t\t\t reload_completed, FALSE, FALSE);\n+\treturn frv_legitimate_address_p_1 (mode, XEXP (subreg, 0),\n+\t\t\t\t\t   reload_completed, FALSE, FALSE);\n \n       return (code == REG);\n \n@@ -334,8 +334,8 @@\n       subreg = SUBREG_REG (op);\n       code = GET_CODE (subreg);\n       if (code == MEM)\n-\treturn frv_legitimate_address_p (mode, XEXP (subreg, 0),\n-\t\t\t\t\t reload_completed, TRUE, FALSE);\n+\treturn frv_legitimate_address_p_1 (mode, XEXP (subreg, 0),\n+\t\t\t\t\t   reload_completed, TRUE, FALSE);\n \n       return (code == REG);\n \n@@ -373,8 +373,8 @@\n       subreg = SUBREG_REG (op);\n       code = GET_CODE (subreg);\n       if (code == MEM)\n-\treturn frv_legitimate_address_p (mode, XEXP (subreg, 0),\n-\t\t\t\t\t reload_completed, TRUE, FALSE);\n+\treturn frv_legitimate_address_p_1 (mode, XEXP (subreg, 0),\n+\t\t\t\t\t   reload_completed, TRUE, FALSE);\n \n       return (code == REG);\n \n@@ -599,7 +599,7 @@\n   if (GET_MODE (op) != mode && GET_MODE (op) != VOIDmode)\n     return FALSE;\n \n-  return frv_legitimate_address_p (DImode, op, reload_completed, FALSE, TRUE);\n+  return frv_legitimate_address_p_1 (DImode, op, reload_completed, FALSE, TRUE);\n })\n \n ;; TODO: Add a comment here."}, {"sha": "35023c6236de53a43b5ed3f2e0ec68e475ce3739", "filename": "gcc/config/h8300/h8300-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -60,7 +60,6 @@ extern int same_cmp_preceding_p (rtx);\n extern int same_cmp_following_p (rtx);\n \n extern int h8300_legitimate_constant_p (rtx);\n-extern int h8300_legitimate_address_p (enum machine_mode, rtx, int);\n \n /* Used in builtins.c */\n extern rtx h8300_return_addr_rtx (int, rtx);"}, {"sha": "8630823ca85b092b7118f1e2dee80bb17f7a0bf7", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -5686,8 +5686,8 @@ h8300_rtx_ok_for_base_p (rtx x, int strict)\n    legitimate address has the form REG, REG+CONSTANT_ADDRESS or\n    CONSTANT_ADDRESS.  */\n \n-int\n-h8300_legitimate_address_p (enum machine_mode mode, rtx x, int strict)\n+static bool\n+h8300_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n {\n   /* The register indirect addresses like @er0 is always valid.  */\n   if (h8300_rtx_ok_for_base_p (x, strict))\n@@ -5795,6 +5795,9 @@ h8300_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)\n #undef TARGET_HARD_REGNO_SCRATCH_OK\n #define TARGET_HARD_REGNO_SCRATCH_OK h8300_hard_regno_scratch_ok\n \n+#undef TARGET_LEGITIMATE_ADDRESS_P\n+#define TARGET_LEGITIMATE_ADDRESS_P\th8300_legitimate_address_p\n+\n #undef TARGET_DEFAULT_TARGET_FLAGS\n #define TARGET_DEFAULT_TARGET_FLAGS TARGET_DEFAULT\n "}, {"sha": "dd95ed7253d8eb57d6843eb6d149b98249fe7b78", "filename": "gcc/config/h8300/h8300.h", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fh8300%2Fh8300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fh8300%2Fh8300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.h?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -920,24 +920,6 @@ struct cum_arg\n #define EXTRA_MEMORY_CONSTRAINT(C, STR) \\\n   ((C) == 'W')\n \n-\f\n-#ifndef REG_OK_STRICT\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\\\n-  do\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-      if (h8300_legitimate_address_p ((MODE), (X), 0))\t\\\n-\tgoto ADDR;\t\t\t\t\\\n-    }\t\t\t\t\t\t\\\n-  while (0)\n-#else\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\\\n-  do\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-      if (h8300_legitimate_address_p ((MODE), (X), 1))\t\\\n-\tgoto ADDR;\t\t\t\t\\\n-    }\t\t\t\t\t\t\\\n-  while (0)\n-#endif\n \f\n /* Go to LABEL if ADDR (a legitimate address expression)\n    has an effect that depends on the machine mode it is used for."}, {"sha": "8ae5bd66b2697e7453ee1a2147c1b430cc797082", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -56,7 +56,6 @@ extern bool legitimate_constant_p (rtx);\n extern bool constant_address_p (rtx);\n extern bool legitimate_pic_operand_p (rtx);\n extern int legitimate_pic_address_disp_p (rtx);\n-extern int legitimate_address_p (enum machine_mode, rtx, int);\n \n extern void print_reg (rtx, int, FILE*);\n extern void print_operand (FILE*, rtx, int);"}, {"sha": "593ea84ffa65d507ce0e83c29371bab414d8d2ed", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -9090,13 +9090,6 @@ ix86_cannot_force_const_mem (rtx x)\n   return !legitimate_constant_p (x);\n }\n \n-/* Determine if a given RTX is a valid constant address.  */\n-\n-bool\n-constant_address_p (rtx x)\n-{\n-  return CONSTANT_P (x) && legitimate_address_p (Pmode, x, 1);\n-}\n \n /* Nonzero if the constant value X is a legitimate general operand\n    when generating PIC code.  It is given that flag_pic is on and\n@@ -9273,9 +9266,9 @@ legitimate_pic_address_disp_p (rtx disp)\n    convert common non-canonical forms to canonical form so that they will\n    be recognized.  */\n \n-int\n-legitimate_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t      rtx addr, int strict)\n+static bool\n+ix86_legitimate_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t           rtx addr, bool strict)\n {\n   struct ix86_address parts;\n   rtx base, index, disp;\n@@ -9499,6 +9492,14 @@ legitimate_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n  report_error:\n   return FALSE;\n }\n+\n+/* Determine if a given RTX is a valid constant address.  */\n+\n+bool\n+constant_address_p (rtx x)\n+{\n+  return CONSTANT_P (x) && ix86_legitimate_address_p (Pmode, x, 1);\n+}\n \f\n /* Return a unique alias set for the GOT.  */\n \n@@ -10154,7 +10155,7 @@ ix86_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n \t    }\n \t}\n \n-      if (changed && legitimate_address_p (mode, x, FALSE))\n+      if (changed && ix86_legitimate_address_p (mode, x, FALSE))\n \treturn x;\n \n       if (GET_CODE (XEXP (x, 0)) == MULT)\n@@ -10180,7 +10181,7 @@ ix86_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n \t  x = legitimize_pic_address (x, 0);\n \t}\n \n-      if (changed && legitimate_address_p (mode, x, FALSE))\n+      if (changed && ix86_legitimate_address_p (mode, x, FALSE))\n \treturn x;\n \n       if (REG_P (XEXP (x, 0)))\n@@ -30267,6 +30268,9 @@ ix86_enum_va_list (int idx, const char **pname, tree *ptree)\n #undef TARGET_EXPAND_TO_RTL_HOOK\n #define TARGET_EXPAND_TO_RTL_HOOK ix86_maybe_switch_abi\n \n+#undef TARGET_LEGITIMATE_ADDRESS_P\n+#define TARGET_LEGITIMATE_ADDRESS_P ix86_legitimate_address_p\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n #include \"gt-i386.h\""}, {"sha": "0a9e8a667329ba85a1b61a3ee4b36efa7dd5fb42", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -1823,22 +1823,6 @@ typedef struct ix86_args {\n \n #define LEGITIMATE_CONSTANT_P(X)  legitimate_constant_p (X)\n \n-#ifdef REG_OK_STRICT\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  if (legitimate_address_p ((MODE), (X), 1))\t\t\t\t\\\n-    goto ADDR;\t\t\t\t\t\t\t\t\\\n-} while (0)\n-\n-#else\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  if (legitimate_address_p ((MODE), (X), 0))\t\t\t\t\\\n-    goto ADDR;\t\t\t\t\t\t\t\t\\\n-} while (0)\n-\n-#endif\n-\n /* If defined, a C expression to determine the base term of address X.\n    This macro is used in only one place: `find_base_term' in alias.c.\n "}, {"sha": "0e4dba77eb4c8e4b3fd15ff76e8007bee4862c87", "filename": "gcc/config/iq2000/iq2000-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fiq2000%2Fiq2000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fiq2000%2Fiq2000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000-protos.h?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -22,7 +22,6 @@\n \n extern int              iq2000_check_split (rtx, enum machine_mode);\n extern int              iq2000_reg_mode_ok_for_base_p (rtx, enum machine_mode, int);\n-extern int              iq2000_legitimate_address_p (enum machine_mode, rtx, int);\n extern const char *     iq2000_fill_delay_slot (const char *, enum delay_type, rtx *, rtx);\n extern const char *     iq2000_move_1word (rtx *, rtx, int);\n extern void             override_options (void);"}, {"sha": "d61ec3f7192fdb2051f847a86a7ab9b60e11e628", "filename": "gcc/config/iq2000/iq2000.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.c?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -164,6 +164,7 @@ static bool iq2000_pass_by_reference  (CUMULATIVE_ARGS *, enum machine_mode,\n static int  iq2000_arg_partial_bytes  (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t       tree, bool);\n static void iq2000_va_start\t      (tree, rtx);\n+static bool iq2000_legitimate_address_p (enum machine_mode, rtx, bool);\n \n #undef  TARGET_INIT_BUILTINS\n #define TARGET_INIT_BUILTINS \t\tiq2000_init_builtins\n@@ -212,6 +213,9 @@ static void iq2000_va_start\t      (tree, rtx);\n #undef\tTARGET_EXPAND_BUILTIN_VA_START\n #define\tTARGET_EXPAND_BUILTIN_VA_START\tiq2000_va_start\n \n+#undef TARGET_LEGITIMATE_ADDRESS_P\n+#define TARGET_LEGITIMATE_ADDRESS_P\tiq2000_legitimate_address_p\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Return nonzero if we split the address into high and low parts.  */\n@@ -249,8 +253,8 @@ iq2000_reg_mode_ok_for_base_p (rtx reg,\n    memory operand of the indicated MODE.  STRICT is nonzero if this\n    function is called during reload.  */\n \n-int\n-iq2000_legitimate_address_p (enum machine_mode mode, rtx xinsn, int strict)\n+bool\n+iq2000_legitimate_address_p (enum machine_mode mode, rtx xinsn, bool strict)\n {\n   if (TARGET_DEBUG_A_MODE)\n     {\n@@ -311,7 +315,7 @@ iq2000_legitimate_address_p (enum machine_mode mode, rtx xinsn, int strict)\n     }\n \n   if (TARGET_DEBUG_A_MODE)\n-    GO_PRINTF (\"Not a legitimate address\\n\");\n+    GO_PRINTF (\"Not a enum machine_mode mode, legitimate address\\n\");\n \n   /* The address was not legitimate.  */\n   return 0;"}, {"sha": "c1506a4a1f127dce760be66325d6dfc9a61cb043", "filename": "gcc/config/iq2000/iq2000.h", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fiq2000%2Fiq2000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fiq2000%2Fiq2000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.h?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -528,20 +528,6 @@ typedef struct iq2000_args\n \n #define MAX_REGS_PER_ADDRESS 1\n \n-#ifdef REG_OK_STRICT\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\\\n-  {\t\t\t\t\t\t\t\\\n-    if (iq2000_legitimate_address_p (MODE, X, 1))\t\\\n-      goto ADDR;\t\t\t\t\t\\\n-  }\n-#else\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\\\n-  {\t\t\t\t\t\t\t\\\n-    if (iq2000_legitimate_address_p (MODE, X, 0))\t\\\n-      goto ADDR;\t\t\t\t\t\\\n-  }\n-#endif\n-\n #define REG_OK_FOR_INDEX_P(X) 0\n \n #define LEGITIMATE_CONSTANT_P(X) (1)"}, {"sha": "d332475784fab6e0a76d0baf0d183c45bef1d113", "filename": "gcc/config/m32c/m32c-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fm32c%2Fm32c-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fm32c%2Fm32c-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c-protos.h?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -74,7 +74,6 @@ bool m32c_illegal_subreg_p (rtx);\n bool m32c_immd_dbl_mov (rtx *, MM);\n rtx  m32c_incoming_return_addr_rtx (void);\n void m32c_initialize_trampoline (rtx, rtx, rtx);\n-int  m32c_legitimate_address_p (MM, rtx, int);\n int  m32c_legitimate_constant_p (rtx);\n int  m32c_legitimize_reload_address (rtx *, MM, int, int, int);\n rtx  m32c_libcall_value (MM);"}, {"sha": "989f823df92192a2f67d58316358167e1e457b5f", "filename": "gcc/config/m32c/m32c.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fm32c%2Fm32c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fm32c%2Fm32c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.c?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -68,6 +68,7 @@ static int m32c_comp_type_attributes (const_tree, const_tree);\n static bool m32c_fixed_condition_code_regs (unsigned int *, unsigned int *);\n static struct machine_function *m32c_init_machine_status (void);\n static void m32c_insert_attributes (tree, tree *);\n+static bool m32c_legitimate_address_p (enum machine_mode, rtx, bool);\n static bool m32c_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t    const_tree, bool);\n static bool m32c_promote_prototypes (const_tree);\n@@ -1760,13 +1761,14 @@ m32c_init_libfuncs (void)\n \n /* Addressing Modes */\n \n-/* Used by GO_IF_LEGITIMATE_ADDRESS.  The r8c/m32c family supports a\n-   wide range of non-orthogonal addressing modes, including the\n-   ability to double-indirect on *some* of them.  Not all insns\n-   support all modes, either, but we rely on predicates and\n-   constraints to deal with that.  */\n-int\n-m32c_legitimate_address_p (enum machine_mode mode, rtx x, int strict)\n+/* The r8c/m32c family supports a wide range of non-orthogonal\n+   addressing modes, including the ability to double-indirect on *some*\n+   of them.  Not all insns support all modes, either, but we rely on\n+   predicates and constraints to deal with that.  */\n+#undef TARGET_LEGITIMATE_ADDRESS_P\n+#define TARGET_LEGITIMATE_ADDRESS_P m32c_legitimate_address_p\n+bool\n+m32c_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n {\n   int mode_adjust;\n   if (CONSTANT_P (x))"}, {"sha": "5c3130534a496c0a85755152a803ab0c118a61e1", "filename": "gcc/config/m32c/m32c.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fm32c%2Fm32c.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fm32c%2Fm32c.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.h?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -578,10 +578,6 @@ typedef struct m32c_cumulative_args\n #define REG_OK_STRICT_V 0\n #endif\n \n-#define GO_IF_LEGITIMATE_ADDRESS(MODE,X,LABEL) \\\n-\tif (m32c_legitimate_address_p (MODE, X, REG_OK_STRICT_V)) \\\n-\t  goto LABEL;\n-\n #define REG_OK_FOR_BASE_P(X) m32c_reg_ok_for_base_p (X, REG_OK_STRICT_V)\n #define REG_OK_FOR_INDEX_P(X) 0\n "}, {"sha": "2f138c724ead940bc90a87c6ca09de1680c63dff", "filename": "gcc/config/m68hc11/m68hc11-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fm68hc11%2Fm68hc11-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fm68hc11%2Fm68hc11-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11-protos.h?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -48,8 +48,6 @@ extern void m68hc11_initialize_trampoline (rtx, rtx, rtx);\n extern rtx m68hc11_expand_compare_and_branch (enum rtx_code, rtx, rtx, rtx);\n extern enum reg_class preferred_reload_class (rtx, enum reg_class);\n \n-extern int m68hc11_go_if_legitimate_address (rtx, enum machine_mode, int);\n-\n extern void m68hc11_notice_update_cc (rtx, rtx);\n extern void m68hc11_notice_keep_cc (rtx);\n "}, {"sha": "ae4f7057c76b6eef8b3a1fea9ff74f7a6953b45d", "filename": "gcc/config/m68hc11/m68hc11.c", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -64,7 +64,8 @@ static void emit_move_after_reload (rtx, rtx, rtx);\n static rtx simplify_logical (enum machine_mode, int, rtx, rtx *);\n static void m68hc11_emit_logical (enum machine_mode, int, rtx *);\n static void m68hc11_reorg (void);\n-static int go_if_legitimate_address_internal (rtx, enum machine_mode, int);\n+static bool m68hc11_legitimate_address_p_1 (enum machine_mode, rtx, bool);\n+static bool m68hc11_legitimate_address_p (enum machine_mode, rtx, bool);\n static rtx m68hc11_expand_compare (enum rtx_code, rtx, rtx);\n static int must_parenthesize (rtx);\n static int m68hc11_address_cost (rtx, bool);\n@@ -260,6 +261,9 @@ static const struct processor_costs m6812_cost = {\n #undef TARGET_STRIP_NAME_ENCODING\n #define TARGET_STRIP_NAME_ENCODING m68hc11_strip_name_encoding\n \n+#undef TARGET_LEGITIMATE_ADDRESS_P\n+#define TARGET_LEGITIMATE_ADDRESS_P\tm68hc11_legitimate_address_p\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n int\n@@ -721,9 +725,9 @@ m68hc11_register_indirect_p (rtx operand, enum machine_mode mode)\n   return m68hc11_valid_addressing_p (operand, mode, addr_mode);\n }\n \n-static int\n-go_if_legitimate_address_internal (rtx operand, enum machine_mode mode,\n-                                   int strict)\n+static bool\n+m68hc11_legitimate_address_p_1  (enum machine_mode mode, rtx operand,\n+                                 bool strict)\n {\n   int addr_mode;\n \n@@ -752,9 +756,9 @@ go_if_legitimate_address_internal (rtx operand, enum machine_mode mode,\n   return 0;\n }\n \n-int\n-m68hc11_go_if_legitimate_address (rtx operand, enum machine_mode mode,\n-                                  int strict)\n+bool\n+m68hc11_legitimate_address_p (enum machine_mode mode, rtx operand,\n+                              bool strict)\n {\n   int result;\n \n@@ -765,7 +769,7 @@ m68hc11_go_if_legitimate_address (rtx operand, enum machine_mode mode,\n       debug_rtx (operand);\n     }\n \n-  result = go_if_legitimate_address_internal (operand, mode, strict);\n+  result = m68hc11_legitimate_address_p_1 (mode, operand, strict);\n \n   if (debug_m6811)\n     {"}, {"sha": "a394403752a8cd117c56f2d1a17f86b9cb6d333a", "filename": "gcc/config/m68hc11/m68hc11.h", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -1169,19 +1169,6 @@ extern unsigned char m68hc11_reg_valid_for_index[FIRST_PSEUDO_REGISTER];\n   (((GET_CODE (X) == PRE_DEC) || (GET_CODE (X) == POST_INC)) \\\n \t&& SP_REG_P (XEXP (X, 0)))\n \n-/* Go to ADDR if X is a valid address.  */\n-#ifndef REG_OK_STRICT\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR) \\\n-{ \\\n-  if (m68hc11_go_if_legitimate_address ((X), (MODE), 0)) goto ADDR; \\\n-}\n-#else\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t \\\n-{\t\t\t\t\t\t\t \\\n-  if (m68hc11_go_if_legitimate_address ((X), (MODE), 1)) goto ADDR; \\\n-}\n-#endif\n-\n /* The macros REG_OK_FOR..._P assume that the arg is a REG rtx and check its\n    validity for a certain class.  We have two alternate definitions for each\n    of them.  The usual definition accepts all pseudo regs; the other rejects"}, {"sha": "1b91709e45d7ade84fbfc4be5f3a845e3969e49c", "filename": "gcc/config/m68k/m68k-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -56,7 +56,6 @@ extern void notice_update_cc (rtx, rtx);\n extern bool m68k_legitimate_base_reg_p (rtx, bool);\n extern bool m68k_legitimate_index_reg_p (rtx, bool);\n extern bool m68k_illegitimate_symbolic_constant_p (rtx);\n-extern bool m68k_legitimate_address_p (enum machine_mode, rtx, bool);\n extern bool m68k_matches_q_p (rtx);\n extern bool m68k_matches_u_p (rtx);\n extern rtx legitimize_pic_address (rtx, enum machine_mode, rtx);"}, {"sha": "ce028a02a6608ef0fb638d434a86e4a158a7fa81", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -131,6 +131,7 @@ static void m68k_sched_dfa_pre_advance_cycle (void);\n static void m68k_sched_dfa_post_advance_cycle (void);\n static int m68k_sched_first_cycle_multipass_dfa_lookahead (void);\n \n+static bool m68k_legitimate_address_p (enum machine_mode, rtx, bool);\n static bool m68k_handle_option (size_t, const char *, int);\n static rtx find_addr_reg (rtx);\n static const char *singlemove_string (rtx *);\n@@ -248,6 +249,9 @@ const char *m68k_library_id_string = \"_current_shared_library_a5_offset_\";\n #define TARGET_RETURN_IN_MEMORY m68k_return_in_memory\n #endif\n \n+#undef TARGET_LEGITIMATE_ADDRESS_P\n+#define TARGET_LEGITIMATE_ADDRESS_P\tm68k_legitimate_address_p\n+\n static const struct attribute_spec m68k_attribute_table[] =\n {\n   /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */"}, {"sha": "e91ab00fcc9b20fc39de2946299f15366bb98f84", "filename": "gcc/config/m68k/m68k.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fm68k%2Fm68k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fm68k%2Fm68k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.h?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -758,14 +758,6 @@ __transfer_from_trampoline ()\t\t\t\t\t\\\n #define REG_OK_FOR_INDEX_P(X) \\\n   m68k_legitimate_index_reg_p (X, REG_STRICT_P)\n \n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\t\t\\\n-  do\t\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      if (m68k_legitimate_address_p (MODE, X, REG_STRICT_P))\t\t\\\n-        goto ADDR;\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  while (0)\n-\n \f\n /* This address is OK as it stands.  */\n #define PIC_CASE_VECTOR_ADDRESS(index) index"}, {"sha": "bbae18a13a538c89b6cba7bad1a2f977ce3a852f", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -184,7 +184,6 @@ enum mips_call_type {\n extern bool mips_symbolic_constant_p (rtx, enum mips_symbol_context,\n \t\t\t\t      enum mips_symbol_type *);\n extern int mips_regno_mode_ok_for_base_p (int, enum machine_mode, bool);\n-extern bool mips_legitimate_address_p (enum machine_mode, rtx, bool);\n extern bool mips_stack_address_p (rtx, enum machine_mode);\n extern int mips_address_insns (rtx, enum machine_mode, bool);\n extern int mips_const_insns (rtx);"}, {"sha": "36521ca8ceba9695e576ec1ec56d8049daeb7163", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -2116,10 +2116,9 @@ mips_classify_address (struct mips_address_info *info, rtx x,\n     }\n }\n \n-/* Return true if X is a legitimate address for a memory operand of mode\n-   MODE.  STRICT_P is true if REG_OK_STRICT is in effect.  */\n+/* Implement TARGET_LEGITIMATE_ADDRESS_P.  */\n \n-bool\n+static bool\n mips_legitimate_address_p (enum machine_mode mode, rtx x, bool strict_p)\n {\n   struct mips_address_info addr;\n@@ -14915,6 +14914,9 @@ mips_final_postscan_insn (FILE *file, rtx insn, rtx *opvec, int noperands)\n #undef TARGET_ASM_FINAL_POSTSCAN_INSN\n #define TARGET_ASM_FINAL_POSTSCAN_INSN mips_final_postscan_insn\n \n+#undef TARGET_LEGITIMATE_ADDRESS_P\n+#define TARGET_LEGITIMATE_ADDRESS_P\tmips_legitimate_address_p\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n #include \"gt-mips.h\""}, {"sha": "5b64346fef6f2e0730d7a667926541a2903cd03b", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -2504,25 +2504,11 @@ typedef struct mips_args {\n \n #define MAX_REGS_PER_ADDRESS 1\n \n-#ifdef REG_OK_STRICT\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\\\n-{\t\t\t\t\t\t\\\n-  if (mips_legitimate_address_p (MODE, X, 1))\t\\\n-    goto ADDR;\t\t\t\t\t\\\n-}\n-#else\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\\\n-{\t\t\t\t\t\t\\\n-  if (mips_legitimate_address_p (MODE, X, 0))\t\\\n-    goto ADDR;\t\t\t\t\t\\\n-}\n-#endif\n-\n /* Check for constness inline but use mips_legitimate_address_p\n    to check whether a constant really is an address.  */\n \n #define CONSTANT_ADDRESS_P(X) \\\n-  (CONSTANT_P (X) && mips_legitimate_address_p (SImode, X, 0))\n+  (CONSTANT_P (X) && memory_address_p (SImode, X))\n \n #define LEGITIMATE_CONSTANT_P(X) (mips_const_insns (X) > 0)\n "}, {"sha": "e839d864697a12022aa35f497aa2d274fa2d5c0f", "filename": "gcc/config/mmix/mmix-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fmmix%2Fmmix-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fmmix%2Fmmix-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix-protos.h?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -82,7 +82,6 @@ extern rtx mmix_eh_return_stackadj_rtx (void);\n extern rtx mmix_eh_return_handler_rtx (void);\n extern void mmix_initialize_trampoline (rtx, rtx, rtx);\n extern int mmix_constant_address_p (rtx);\n-extern int mmix_legitimate_address (enum machine_mode, rtx, int);\n extern int mmix_legitimate_constant_p (rtx);\n extern void mmix_print_operand (FILE *, rtx, int);\n extern void mmix_print_operand_address (FILE *, rtx);"}, {"sha": "d2115a5d70311345ef0c00cc5daef7c1a223772d", "filename": "gcc/config/mmix/mmix.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fmmix%2Fmmix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fmmix%2Fmmix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.c?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -125,6 +125,7 @@ static void mmix_emit_sp_add (HOST_WIDE_INT offset);\n static void mmix_target_asm_function_prologue (FILE *, HOST_WIDE_INT);\n static void mmix_target_asm_function_end_prologue (FILE *);\n static void mmix_target_asm_function_epilogue (FILE *, HOST_WIDE_INT);\n+static bool mmix_legitimate_address_p (enum machine_mode, rtx, bool);\n static void mmix_reorg (void);\n static void mmix_asm_output_mi_thunk\n   (FILE *, tree, HOST_WIDE_INT, HOST_WIDE_INT, tree);\n@@ -206,6 +207,9 @@ static bool mmix_pass_by_reference (CUMULATIVE_ARGS *,\n #undef TARGET_DEFAULT_TARGET_FLAGS\n #define TARGET_DEFAULT_TARGET_FLAGS TARGET_DEFAULT\n \n+#undef TARGET_LEGITIMATE_ADDRESS_P\n+#define TARGET_LEGITIMATE_ADDRESS_P\tmmix_legitimate_address_p\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n /* Functions that are expansions for target macros.\n@@ -985,13 +989,12 @@ mmix_constant_address_p (rtx x)\n   return constant_ok || (addend & 3) == 0;\n }\n \n-/* Return 1 if the address is OK, otherwise 0.\n-   Used by GO_IF_LEGITIMATE_ADDRESS.  */\n+/* Return 1 if the address is OK, otherwise 0.  */\n \n-int\n-mmix_legitimate_address (enum machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t\t rtx x,\n-\t\t\t int strict_checking)\n+bool\n+mmix_legitimate_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t   rtx x,\n+\t\t\t   bool strict_checking)\n {\n #define MMIX_REG_OK(X)\t\t\t\t\t\t\t\\\n   ((strict_checking\t\t\t\t\t\t\t\\"}, {"sha": "fb3d3019b29e986454632e82977f8a519504dee3", "filename": "gcc/config/mmix/mmix.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fmmix%2Fmmix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fmmix%2Fmmix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.h?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -690,10 +690,6 @@ typedef struct { int regs; int lib; } CUMULATIVE_ARGS;\n \n #define MAX_REGS_PER_ADDRESS 2\n \n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, LABEL)\t\t\\\n- if (mmix_legitimate_address (MODE, X, MMIX_REG_OK_STRICT))\t\\\n-   goto LABEL\n-\n #ifndef REG_OK_STRICT\n # define REG_OK_FOR_BASE_P(X)\t\t\t\\\n   (REGNO (X) <= MMIX_LAST_GENERAL_REGISTER\t\\"}, {"sha": "ae4728ae0cba0b6b39e03ced6b958d57967b52f6", "filename": "gcc/config/mn10300/mn10300-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fmn10300%2Fmn10300-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fmn10300%2Fmn10300-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300-protos.h?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -23,7 +23,6 @@ along with GCC; see the file COPYING3.  If not see\n extern void mn10300_override_options (void);\n extern rtx legitimize_pic_address (rtx, rtx);\n extern int legitimate_pic_operand_p (rtx);\n-extern bool legitimate_address_p (enum machine_mode, rtx, int);\n extern void print_operand (FILE *, rtx, int);\n extern void print_operand_address (FILE *, rtx);\n extern void mn10300_print_reg_list (FILE *, int);"}, {"sha": "e32f3766d646f6e0e24ef7b7769884b9bfc7f4df", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -69,6 +69,7 @@ enum processor_type mn10300_processor = PROCESSOR_DEFAULT;\n \n \n static bool mn10300_handle_option (size_t, const char *, int);\n+static bool mn10300_legitimate_address_p (enum machine_mode, rtx, bool);\n static int mn10300_address_cost_1 (rtx, int *);\n static int mn10300_address_cost (rtx, bool);\n static bool mn10300_rtx_costs (rtx, int, int, int *, bool);\n@@ -127,6 +128,9 @@ static unsigned int mn10300_case_values_threshold (void);\n #undef TARGET_CASE_VALUES_THRESHOLD\n #define TARGET_CASE_VALUES_THRESHOLD mn10300_case_values_threshold\n \n+#undef TARGET_LEGITIMATE_ADDRESS_P\n+#define TARGET_LEGITIMATE_ADDRESS_P\tmn10300_legitimate_address_p\n+\n static void mn10300_encode_section_info (tree, rtx, int);\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n@@ -1900,9 +1904,21 @@ legitimate_pic_operand_p (rtx x)\n }\n \n /* Return TRUE if the address X, taken from a (MEM:MODE X) rtx, is\n-   legitimate, and FALSE otherwise.  */\n+   legitimate, and FALSE otherwise.\n+\n+   On the mn10300, the value in the address register must be\n+   in the same memory space/segment as the effective address.\n+\n+   This is problematical for reload since it does not understand\n+   that base+index != index+base in a memory reference.\n+\n+   Note it is still possible to use reg+reg addressing modes,\n+   it's just much more difficult.  For a discussion of a possible\n+   workaround and solution, see the comments in pa.c before the\n+   function record_unscaled_index_insn_codes.  */\n+\n bool\n-legitimate_address_p (enum machine_mode mode, rtx x, int strict)\n+mn10300_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n {\n   if (CONSTANT_ADDRESS_P (x)\n       && (! flag_pic || legitimate_pic_operand_p (x)))"}, {"sha": "77be9962907c00837b36673b9b9921c1d0cb5e26", "filename": "gcc/config/mn10300/mn10300.h", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.h?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -655,26 +655,6 @@ struct cum_arg {int nbytes; };\n \f\n #define HAVE_POST_INCREMENT (TARGET_AM33)\n \n-/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n-   that is a valid memory address for an instruction.\n-   The MODE argument is the machine mode for the MEM expression\n-   that wants to use this address.\n-\n-   The other macros defined here are used only in GO_IF_LEGITIMATE_ADDRESS,\n-   except for CONSTANT_ADDRESS_P which is actually\n-   machine-independent.\n-\n-   On the mn10300, the value in the address register must be\n-   in the same memory space/segment as the effective address.\n-\n-   This is problematical for reload since it does not understand\n-   that base+index != index+base in a memory reference.\n-\n-   Note it is still possible to use reg+reg addressing modes,\n-   it's just much more difficult.  For a discussion of a possible\n-   workaround and solution, see the comments in pa.c before the\n-   function record_unscaled_index_insn_codes.  */\n-\n /* Accept either REG or SUBREG where a register is valid.  */\n \n #define RTX_OK_FOR_BASE_P(X, strict)\t\t\t\t\\\n@@ -684,14 +664,6 @@ struct cum_arg {int nbytes; };\n        && REGNO_STRICT_OK_FOR_BASE_P (REGNO (SUBREG_REG (X)),\t\\\n  \t\t\t\t      (strict))))\n \n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)    \t\\\n-do\t\t\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\\\n-    if (legitimate_address_p ((MODE), (X), REG_STRICT))\t\\\n-      goto ADDR;\t\t\t\t\t\\\n-  }\t\t\t\t\t\t\t\\\n-while (0)\n-\n \f\n \n /* Nonzero if the constant value X is a legitimate general operand."}, {"sha": "7a2a07b98fa63a2f6726728b5a2847dbe7fce3b4", "filename": "gcc/config/picochip/picochip-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fpicochip%2Fpicochip-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fpicochip%2Fpicochip-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpicochip%2Fpicochip-protos.h?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -26,7 +26,6 @@ extern void picochip_function_prologue (FILE *, HOST_WIDE_INT);\n extern void picochip_function_epilogue (FILE *, HOST_WIDE_INT);\n \n extern enum reg_class picochip_reg_class_from_letter (unsigned);\n-extern int picochip_legitimate_address_p (int, struct rtx_def *, unsigned);\n extern int picochip_const_ok_for_letter_p (unsigned HOST_WIDE_INT value, unsigned c);\n \n #ifdef RTX_CODE\t\t\t/* inside TREE_CODE */"}, {"sha": "56c58a83056a4601de8d2496b20600aee4096621", "filename": "gcc/config/picochip/picochip.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fpicochip%2Fpicochip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fpicochip%2Fpicochip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpicochip%2Fpicochip.c?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -95,6 +95,7 @@ rtx picochip_expand_builtin (tree, rtx, rtx, enum machine_mode, int);\n bool picochip_rtx_costs (rtx x, int code, int outer_code, int* total);\n bool picochip_return_in_memory(const_tree type,\n                               const_tree fntype ATTRIBUTE_UNUSED);\n+bool picochip_legitimate_address_p (enum machine_mode, rtx, bool);\n \n rtx picochip_struct_value_rtx(tree fntype ATTRIBUTE_UNUSED, int incoming ATTRIBUTE_UNUSED);\n rtx picochip_function_value (const_tree valtype, const_tree func ATTRIBUTE_UNUSED,\n@@ -275,6 +276,9 @@ static char picochip_get_vliw_alu_id (void);\n #define TARGET_LIBGCC_CMP_RETURN_MODE picochip_libgcc_cmp_return_mode\n */\n \n+#undef TARGET_LEGITIMATE_ADDRESS_P\n+#define TARGET_LEGITIMATE_ADDRESS_P picochip_legitimate_address_p\n+\n /* Loading and storing QImode values to and from memory\n    usually requires a scratch register. */\n #undef TARGET_SECONDARY_RELOAD\n@@ -1249,8 +1253,8 @@ picochip_const_ok_for_base (enum machine_mode mode, int regno, int offset)\n /* Determine whether a given rtx is a legitimate address for machine_mode\n    MODE.  STRICT is non-zero if we're being strict - any pseudo that\n    is not a hard register must be a memory reference.  */\n-int\n-picochip_legitimate_address_p (int mode, rtx x, unsigned strict)\n+bool\n+picochip_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n {\n   int valid = 0;\n "}, {"sha": "04400016da2c1ff15e06d41ebdcac091b0ec3e25", "filename": "gcc/config/picochip/picochip.h", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fpicochip%2Fpicochip.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fpicochip%2Fpicochip.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpicochip%2Fpicochip.h?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -492,18 +492,6 @@ extern const enum reg_class picochip_regno_reg_class[FIRST_PSEUDO_REGISTER];\n \n #define MAX_REGS_PER_ADDRESS 1\n \n-#ifdef REG_OK_STRICT\n-\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, LABEL) \t\t\t\\\n- if (picochip_legitimate_address_p (MODE, X, 1)) goto LABEL;\n-\n-#else /* REG_OK_STRICT */\n-\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, LABEL) \t\t\t\\\n-  if (picochip_legitimate_address_p (MODE, X, 0)) goto LABEL;\n-\n-#endif /* !REG_OK_STRICT */\n-\n /* Legitimize reload address tries machine dependent means of\n    reloading addresses.  There seems to be a strange error in gcc,\n    which necessitates this macro.  Consider:"}, {"sha": "c080e60c84597a61c94225a197d560dc4e7cd7af", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -109,7 +109,6 @@ extern void rs6000_emit_move (rtx, rtx, enum machine_mode);\n extern rtx rs6000_secondary_memory_needed_rtx (enum machine_mode);\n extern rtx rs6000_legitimize_reload_address (rtx, enum machine_mode,\n \t\t\t\t\t     int, int, int, int *);\n-extern int rs6000_legitimate_address (enum machine_mode, rtx, int);\n extern bool rs6000_legitimate_offset_address_p (enum machine_mode, rtx, int);\n extern bool rs6000_mode_dependent_address (rtx);\n extern rtx rs6000_find_base_term (rtx);"}, {"sha": "a308731b291c5112ca2977e0e30371696997d4eb", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -747,6 +747,7 @@ struct processor_costs power6_cost = {\n \f\n static bool rs6000_function_ok_for_sibcall (tree, tree);\n static const char *rs6000_invalid_within_doloop (const_rtx);\n+static bool rs6000_legitimate_address_p (enum machine_mode, rtx, bool);\n static rtx rs6000_generate_compare (rtx, enum machine_mode);\n static void rs6000_emit_stack_tie (void);\n static void rs6000_frame_related (rtx, rtx, HOST_WIDE_INT, rtx, rtx);\n@@ -1291,6 +1292,9 @@ static const char alt_reg_names[][8] =\n #undef TARGET_INSTANTIATE_DECLS\n #define TARGET_INSTANTIATE_DECLS rs6000_instantiate_decls\n \n+#undef TARGET_LEGITIMATE_ADDRESS_P\n+#define TARGET_LEGITIMATE_ADDRESS_P rs6000_legitimate_address_p\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n \n@@ -3556,7 +3560,7 @@ gpr_or_gpr_p (rtx op0, rtx op1)\n }\n \n \f\n-/* Subroutines of rs6000_legitimize_address and rs6000_legitimate_address.  */\n+/* Subroutines of rs6000_legitimize_address and rs6000_legitimate_address_p.  */\n \n static bool\n constant_pool_expr_p (rtx op)\n@@ -4208,13 +4212,6 @@ rs6000_tls_symbol_ref_1 (rtx *x, void *data ATTRIBUTE_UNUSED)\n   return RS6000_SYMBOL_REF_TLS_P (*x);\n }\n \n-/* The convention appears to be to define this wherever it is used.\n-   With legitimize_reload_address now defined here, REG_MODE_OK_FOR_BASE_P\n-   is now used here.  */\n-#ifndef REG_MODE_OK_FOR_BASE_P\n-#define REG_MODE_OK_FOR_BASE_P(REGNO, MODE) REG_OK_FOR_BASE_P (REGNO)\n-#endif\n-\n /* Our implementation of LEGITIMIZE_RELOAD_ADDRESS.  Returns a value to\n    replace the input X, or the original X if no replacement is called for.\n    The output parameter *WIN is 1 if the calling macro should goto WIN,\n@@ -4271,7 +4268,7 @@ rs6000_legitimize_reload_address (rtx x, enum machine_mode mode,\n   if (GET_CODE (x) == PLUS\n       && GET_CODE (XEXP (x, 0)) == REG\n       && REGNO (XEXP (x, 0)) < 32\n-      && REG_MODE_OK_FOR_BASE_P (XEXP (x, 0), mode)\n+      && INT_REG_OK_FOR_BASE_P (XEXP (x, 0), 1)\n       && GET_CODE (XEXP (x, 1)) == CONST_INT\n       && (INTVAL (XEXP (x, 1)) & 3) != 0\n       && !ALTIVEC_VECTOR_MODE (mode)\n@@ -4289,7 +4286,7 @@ rs6000_legitimize_reload_address (rtx x, enum machine_mode mode,\n   if (GET_CODE (x) == PLUS\n       && GET_CODE (XEXP (x, 0)) == REG\n       && REGNO (XEXP (x, 0)) < FIRST_PSEUDO_REGISTER\n-      && REG_MODE_OK_FOR_BASE_P (XEXP (x, 0), mode)\n+      && INT_REG_OK_FOR_BASE_P (XEXP (x, 0), 1)\n       && GET_CODE (XEXP (x, 1)) == CONST_INT\n       && !SPE_VECTOR_MODE (mode)\n       && !(TARGET_E500_DOUBLE && (mode == DFmode || mode == TFmode\n@@ -4410,8 +4407,8 @@ rs6000_legitimize_reload_address (rtx x, enum machine_mode mode,\n    32-bit DImode, TImode, TFmode, TDmode), indexed addressing cannot be used\n    because adjacent memory cells are accessed by adding word-sized offsets\n    during assembly output.  */\n-int\n-rs6000_legitimate_address (enum machine_mode mode, rtx x, int reg_ok_strict)\n+bool\n+rs6000_legitimate_address_p (enum machine_mode mode, rtx x, bool reg_ok_strict)\n {\n   /* If this is an unaligned stvx/ldvx type address, discard the outer AND.  */\n   if (TARGET_ALTIVEC"}, {"sha": "c50060026c5b7b6f5f8cc4534b4c638f85eb4422", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 13, "deletions": 56, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -1722,6 +1722,19 @@ typedef struct rs6000_args\n  : (reg_renumber[REGNO] > 0\t\t\t\t\t\\\n     && (reg_renumber[REGNO] <= 31 || reg_renumber[REGNO] == 67\t\\\n \t|| reg_renumber[REGNO] == FRAME_POINTER_REGNUM)))\n+\n+/* Nonzero if X is a hard reg that can be used as an index\n+   or if it is a pseudo reg in the non-strict case.  */\n+#define INT_REG_OK_FOR_INDEX_P(X, STRICT)\t\t\t\\\n+  ((!(STRICT) && REGNO (X) >= FIRST_PSEUDO_REGISTER)\t\t\\\n+   || REGNO_OK_FOR_INDEX_P (REGNO (X)))\n+\n+/* Nonzero if X is a hard reg that can be used as a base reg\n+   or if it is a pseudo reg in the non-strict case.  */\n+#define INT_REG_OK_FOR_BASE_P(X, STRICT)\t\t\t\\\n+  ((!(STRICT) && REGNO (X) >= FIRST_PSEUDO_REGISTER)\t\t\\\n+   || REGNO_OK_FOR_BASE_P (REGNO (X)))\n+\n \f\n /* Maximum number of registers that can appear in a valid memory address.  */\n \n@@ -1755,62 +1768,6 @@ typedef struct rs6000_args\n \t\t\t\t    && EASY_VECTOR_15((n) >> 1) \\\n \t\t\t\t    && ((n) & 1) == 0)\n \n-/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n-   and check its validity for a certain class.\n-   We have two alternate definitions for each of them.\n-   The usual definition accepts all pseudo regs; the other rejects\n-   them unless they have been allocated suitable hard regs.\n-   The symbol REG_OK_STRICT causes the latter definition to be used.\n-\n-   Most source files want to accept pseudo regs in the hope that\n-   they will get allocated to the class that the insn wants them to be in.\n-   Source files for reload pass need to be strict.\n-   After reload, it makes no difference, since pseudo regs have\n-   been eliminated by then.  */\n-\n-#ifdef REG_OK_STRICT\n-# define REG_OK_STRICT_FLAG 1\n-#else\n-# define REG_OK_STRICT_FLAG 0\n-#endif\n-\n-/* Nonzero if X is a hard reg that can be used as an index\n-   or if it is a pseudo reg in the non-strict case.  */\n-#define INT_REG_OK_FOR_INDEX_P(X, STRICT)\t\t\t\\\n-  ((!(STRICT) && REGNO (X) >= FIRST_PSEUDO_REGISTER)\t\t\\\n-   || REGNO_OK_FOR_INDEX_P (REGNO (X)))\n-\n-/* Nonzero if X is a hard reg that can be used as a base reg\n-   or if it is a pseudo reg in the non-strict case.  */\n-#define INT_REG_OK_FOR_BASE_P(X, STRICT)\t\t\t\\\n-  ((!(STRICT) && REGNO (X) >= FIRST_PSEUDO_REGISTER)\t\t\\\n-   || REGNO_OK_FOR_BASE_P (REGNO (X)))\n-\n-#define REG_OK_FOR_INDEX_P(X) INT_REG_OK_FOR_INDEX_P (X, REG_OK_STRICT_FLAG)\n-#define REG_OK_FOR_BASE_P(X)  INT_REG_OK_FOR_BASE_P (X, REG_OK_STRICT_FLAG)\n-\f\n-/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n-   that is a valid memory address for an instruction.\n-   The MODE argument is the machine mode for the MEM expression\n-   that wants to use this address.\n-\n-   On the RS/6000, there are four valid addresses: a SYMBOL_REF that\n-   refers to a constant pool entry of an address (or the sum of it\n-   plus a constant), a short (16-bit signed) constant plus a register,\n-   the sum of two registers, or a register indirect, possibly with an\n-   auto-increment.  For DFmode, DDmode and DImode with a constant plus\n-   register, we must ensure that both words are addressable or PowerPC64\n-   with offset word aligned.\n-\n-   For modes spanning multiple registers (DFmode and DDmode in 32-bit GPRs,\n-   32-bit DImode, TImode), indexed addressing cannot be used because\n-   adjacent memory cells are accessed by adding word-sized offsets\n-   during assembly output.  */\n-\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\t\\\n-{ if (rs6000_legitimate_address (MODE, X, REG_OK_STRICT_FLAG))\t\\\n-    goto ADDR;\t\t\t\t\t\t\t\\\n-}\n \f\n /* Try a machine-dependent way of reloading an illegitimate address\n    operand.  If we find one, push the reload and jump to WIN.  This"}, {"sha": "6cc33d1cf8a71bc133d53ae884c6c26b428f6886", "filename": "gcc/config/s390/constraints.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fs390%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fs390%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fconstraints.md?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -398,7 +398,7 @@ level.  This constraint will never be used and using it in an inline\n assembly is *always* a bug since there is no instruction accepting all\n those addresses.  It just serves as a placeholder for a generic memory\n constraint.\"\n-  (match_test \"legitimate_address_p (GET_MODE (op), op, 1)\"))\n+  (match_test \"strict_memory_address_p (GET_MODE (op), op)\"))\n \n ; This defines 'm' as normal memory constraint.  This is only possible\n ; since the standard memory constraint is re-defined in s390.h using"}, {"sha": "b410de538d0760b1d2e1df2554400049f1e88ec9", "filename": "gcc/config/s390/s390-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-protos.h?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -72,7 +72,6 @@ extern bool preferred_la_operand_p (rtx, rtx);\n extern int legitimate_pic_operand_p (rtx);\n extern int legitimate_constant_p (rtx);\n extern bool legitimate_reload_constant_p (rtx);\n-extern bool legitimate_address_p (enum machine_mode, rtx, int);\n extern rtx legitimize_pic_address (rtx, rtx);\n extern rtx legitimize_reload_address (rtx, enum machine_mode, int, int);\n extern enum reg_class s390_preferred_reload_class (rtx, enum reg_class);"}, {"sha": "7f9dd132fe236fb2b7e9b619afcca5ee218b1288", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -3080,8 +3080,8 @@ s390_expand_plus_operand (rtx target, rtx src,\n /* Return true if ADDR is a valid memory address.\n    STRICT specifies whether strict register checking applies.  */\n \n-bool\n-legitimate_address_p (enum machine_mode mode, rtx addr, int strict)\n+static bool\n+s390_legitimate_address_p (enum machine_mode mode, rtx addr, bool strict)\n {\n   struct s390_address ad;\n \n@@ -3739,7 +3739,7 @@ s390_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n     {\n       x = legitimize_tls_address (x, 0);\n \n-      if (legitimate_address_p (mode, x, FALSE))\n+      if (s390_legitimate_address_p (mode, x, FALSE))\n \treturn x;\n     }\n   else if (GET_CODE (x) == PLUS\n@@ -3756,7 +3756,7 @@ s390_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n                   || SYMBOLIC_CONST (XEXP (x, 1)))))\n \t  x = legitimize_pic_address (x, 0);\n \n-      if (legitimate_address_p (mode, x, FALSE))\n+      if (s390_legitimate_address_p (mode, x, FALSE))\n \treturn x;\n     }\n \n@@ -9984,6 +9984,9 @@ s390_reorg (void)\n #undef TARGET_LIBGCC_SHIFT_COUNT_MODE\n #define TARGET_LIBGCC_SHIFT_COUNT_MODE s390_libgcc_shift_count_mode\n \n+#undef TARGET_LEGITIMATE_ADDRESS_P\n+#define TARGET_LEGITIMATE_ADDRESS_P s390_legitimate_address_p\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n #include \"gt-s390.h\""}, {"sha": "26bdd9e7493a657f37c9356088f6e400e84c6e75", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 4, "deletions": 22, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -740,30 +740,12 @@ CUMULATIVE_ARGS;\n #define MAX_REGS_PER_ADDRESS 2\n \n /* This definition replaces the formerly used 'm' constraint with a\n-different constraint letter in order to avoid changing semantics of\n-the 'm' constraint when accepting new address formats in\n-legitimate_address_p.  The constraint letter defined here must not be\n-used in insn definitions or inline assemblies.  */\n+   different constraint letter in order to avoid changing semantics of\n+   the 'm' constraint when accepting new address formats in\n+   TARGET_LEGITIMATE_ADDRESS_P.  The constraint letter defined here\n+   must not be used in insn definitions or inline assemblies.  */\n #define TARGET_MEM_CONSTRAINT 'e'\n \n-/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression that is a\n-   valid memory address for an instruction.\n-   The MODE argument is the machine mode for the MEM expression\n-   that wants to use this address.  */\n-#ifdef REG_OK_STRICT\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)                         \\\n-{                                                                       \\\n-  if (legitimate_address_p (MODE, X, 1))                                \\\n-    goto ADDR;                                                          \\\n-}\n-#else\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)                         \\\n-{                                                                       \\\n-  if (legitimate_address_p (MODE, X, 0))                                \\\n-    goto ADDR;                                                          \\\n-}\n-#endif\n-\n /* Try a machine-dependent way of reloading an illegitimate address\n    operand.  If we find one, push the reload and jump to WIN.  This\n    macro is used in only one place: `find_reloads_address' in reload.c.  */"}, {"sha": "0b737459765a36876ed5741a04910f232d2cf3ad", "filename": "gcc/config/score/score.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fscore%2Fscore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fscore%2Fscore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore.c?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -116,6 +116,9 @@\n #undef TARGET_ADDRESS_COST\n #define TARGET_ADDRESS_COST             score_address_cost\n \n+#undef TARGET_LEGITIMATE_ADDRESS_P\n+#define TARGET_LEGITIMATE_ADDRESS_P\tscore_legitimate_address_p\n+\n struct extern_list *extern_head = 0;\n \n /* default 0 = NO_REGS  */\n@@ -531,13 +534,13 @@ score_regno_mode_ok_for_base_p (int regno, int strict)\n }\n \n /* Implement GO_IF_LEGITIMATE_ADDRESS macro.  */\n-int\n-score_address_p (enum machine_mode mode, rtx x, int strict)\n+bool\n+score_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n {\n   if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n-    return score7_address_p (mode, x, strict);\n+    return score7_legitimate_address_p (mode, x, strict);\n   else if (TARGET_SCORE3)\n-    return score3_address_p (mode, x, strict);\n+    return score3_legitimate_address_p (mode, x, strict);\n \n   gcc_unreachable ();\n }"}, {"sha": "e6c8b7504ba49b5c48aa57c8a262bae4d583f4f1", "filename": "gcc/config/score/score.h", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fscore%2Fscore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fscore%2Fscore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore.h?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -748,16 +748,6 @@ typedef struct score_args\n /* Maximum number of registers that can appear in a valid memory address.  */\n #define MAX_REGS_PER_ADDRESS            1\n \n-#ifdef REG_OK_STRICT\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, LABEL)   \\\n-  if (score_address_p (MODE, X, 1))                \\\n-    goto LABEL;\n-#else\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, LABEL)   \\\n-  if (score_address_p (MODE, X, 0))                \\\n-    goto LABEL;\n-#endif\n-\n /* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n    and check its validity for a certain class.\n    We have two alternate definitions for each of them."}, {"sha": "4ac7e60d88cb3120009405faa96d5206bb557c42", "filename": "gcc/config/score/score3.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fscore%2Fscore3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fscore%2Fscore3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore3.c?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -911,8 +911,8 @@ score3_regno_mode_ok_for_base_p (int regno, int strict)\n }\n \n /* Implement GO_IF_LEGITIMATE_ADDRESS macro.  */\n-int\n-score3_address_p (enum machine_mode mode, rtx x, int strict)\n+bool\n+score3_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n {\n   struct score3_address_info addr;\n "}, {"sha": "001b2f0c2ee2a57033b901838a19c9df32994c17", "filename": "gcc/config/score/score3.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fscore%2Fscore3.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fscore%2Fscore3.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore3.h?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -122,7 +122,8 @@ extern rtx score3_function_value (tree valtype,\n                                   enum machine_mode mode);\n extern void score3_initialize_trampoline (rtx ADDR, rtx FUNC, rtx CHAIN);\n extern int score3_regno_mode_ok_for_base_p (int regno, int strict);\n-extern int score3_address_p (enum machine_mode mode, rtx x, int strict);\n+extern bool score3_legitimate_address_p (enum machine_mode mode, rtx x,\n+\t\t\t\t\t bool strict);\n extern int score3_register_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n                                       enum reg_class from,\n                                       enum reg_class to);"}, {"sha": "c18d03b2675056e473c523d85a6eff310181d55c", "filename": "gcc/config/score/score7.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fscore%2Fscore7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fscore%2Fscore7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore7.c?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -902,8 +902,8 @@ score7_regno_mode_ok_for_base_p (int regno, int strict)\n }\n \n /* Implement GO_IF_LEGITIMATE_ADDRESS macro.  */\n-int\n-score7_address_p (enum machine_mode mode, rtx x, int strict)\n+bool\n+score7_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n {\n   struct score7_address_info addr;\n "}, {"sha": "ae3f4e837cb21072aec678bb4870fd76a03c1432", "filename": "gcc/config/score/score7.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fscore%2Fscore7.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fscore%2Fscore7.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore7.h?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -122,7 +122,8 @@ extern rtx score7_function_value (tree valtype,\n                                   enum machine_mode mode);\n extern void score7_initialize_trampoline (rtx ADDR, rtx FUNC, rtx CHAIN);\n extern int score7_regno_mode_ok_for_base_p (int regno, int strict);\n-extern int score7_address_p (enum machine_mode mode, rtx x, int strict);\n+extern bool score7_legitimate_address_p (enum machine_mode mode, rtx x,\n+\t\t\t\t\t bool strict);\n extern int score7_register_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n                                       enum reg_class from,\n                                       enum reg_class to);"}, {"sha": "8b3547ad9074ee604ff8a9ae1487aae7a5b7fc93", "filename": "gcc/config/sparc/sparc-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -67,7 +67,6 @@ extern void sparc64_initialize_trampoline (rtx, rtx, rtx);\n extern bool legitimate_constant_p (rtx);\n extern bool constant_address_p (rtx);\n extern bool legitimate_pic_operand_p (rtx);\n-extern int legitimate_address_p (enum machine_mode, rtx, int);\n extern rtx legitimize_pic_address (rtx, enum machine_mode, rtx);\n extern rtx legitimize_tls_address (rtx);\n extern void sparc_emit_call_insn (rtx, rtx);"}, {"sha": "d6467bdc2dd7281561422d46aef11e179dcd667a", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -357,6 +357,7 @@ static int hypersparc_adjust_cost (rtx, rtx, rtx, int);\n static void sparc_output_addr_vec (rtx);\n static void sparc_output_addr_diff_vec (rtx);\n static void sparc_output_deferred_case_vectors (void);\n+static bool sparc_legitimate_address_p (enum machine_mode, rtx, bool);\n static rtx sparc_builtin_saveregs (void);\n static int epilogue_renumber (rtx *, int);\n static bool sparc_assemble_integer (rtx, unsigned int, int);\n@@ -588,6 +589,9 @@ static bool fpu_option_set = false;\n #define TARGET_MANGLE_TYPE sparc_mangle_type\n #endif\n \n+#undef TARGET_LEGITIMATE_ADDRESS_P\n+#define TARGET_LEGITIMATE_ADDRESS_P sparc_legitimate_address_p\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n /* Implement TARGET_HANDLE_OPTION.  */\n@@ -3067,8 +3071,8 @@ legitimate_pic_operand_p (rtx x)\n /* Return nonzero if ADDR is a valid memory address.\n    STRICT specifies whether strict register checking applies.  */\n    \n-int\n-legitimate_address_p (enum machine_mode mode, rtx addr, int strict)\n+static bool\n+sparc_legitimate_address_p (enum machine_mode mode, rtx addr, bool strict)\n {\n   rtx rs1 = NULL, rs2 = NULL, imm1 = NULL;\n \n@@ -3503,7 +3507,7 @@ sparc_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n     x = gen_rtx_PLUS (Pmode, XEXP (x, 0),\n \t\t      force_operand (XEXP (x, 1), NULL_RTX));\n \n-  if (x != orig_x && legitimate_address_p (mode, x, FALSE))\n+  if (x != orig_x && sparc_legitimate_address_p (mode, x, FALSE))\n     return x;\n \n   if (SPARC_SYMBOL_REF_TLS_P (x))"}, {"sha": "1aef109b113ffb5e4626632c3032a0b69ed7a8c1", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -1875,20 +1875,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define RTX_OK_FOR_OLO10_P(X)\t\t\t\t\t\t\\\n   (GET_CODE (X) == CONST_INT && INTVAL (X) >= -0x1000 && INTVAL (X) < 0xc00 - 8)\n \n-#ifdef REG_OK_STRICT\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\\\n-{\t\t\t\t\t\t\t\\\n-  if (legitimate_address_p (MODE, X, 1))\t\t\\\n-    goto ADDR;\t\t\t\t\t\t\\\n-}\n-#else\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\\\n-{\t\t\t\t\t\t\t\\\n-  if (legitimate_address_p (MODE, X, 0))\t\t\\\n-    goto ADDR;\t\t\t\t\t\t\\\n-}\n-#endif\n-\n /* Go to LABEL if ADDR (a legitimate address expression)\n    has an effect that depends on the machine mode it is used for.\n "}, {"sha": "33951d77ea9870b3de7c1cb2cc48fb4e58a46c74", "filename": "gcc/config/spu/spu-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fspu%2Fspu-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fspu%2Fspu-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu-protos.h?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -54,8 +54,6 @@ extern bool exp2_immediate_p (rtx op, enum machine_mode mode, int low,\n \t\t\t      int high);\n extern int spu_constant_address_p (rtx x);\n extern int spu_legitimate_constant_p (rtx x);\n-extern int spu_legitimate_address (enum machine_mode mode, rtx x,\n-\t\t\t\t   int reg_ok_strict);\n extern int spu_initial_elimination_offset (int from, int to);\n extern rtx spu_function_value (const_tree type, const_tree func);\n extern rtx spu_function_arg (int cum, enum machine_mode mode, tree type,"}, {"sha": "b8e08c83ea651a7e916e2465c4395ab6f8c8d985", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -152,6 +152,7 @@ char regs_ever_allocated[FIRST_PSEUDO_REGISTER];\n static void spu_init_builtins (void);\n static unsigned char spu_scalar_mode_supported_p (enum machine_mode mode);\n static unsigned char spu_vector_mode_supported_p (enum machine_mode mode);\n+static bool spu_legitimate_address_p (enum machine_mode, rtx, bool);\n static rtx adjust_operand (rtx op, HOST_WIDE_INT * start);\n static rtx get_pic_reg (void);\n static int need_to_save_reg (int regno, int saving);\n@@ -399,6 +400,9 @@ const struct attribute_spec spu_attribute_table[];\n #undef TARGET_SECTION_TYPE_FLAGS\n #define TARGET_SECTION_TYPE_FLAGS spu_section_type_flags\n \n+#undef TARGET_LEGITIMATE_ADDRESS_P\n+#define TARGET_LEGITIMATE_ADDRESS_P spu_legitimate_address_p\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n void\n@@ -3612,9 +3616,9 @@ spu_legitimate_constant_p (rtx x)\n   The alignment matters in the reg+const case because lqd and stqd\n   ignore the 4 least significant bits of the const.  (TODO: It might be\n   preferable to allow any alignment and fix it up when splitting.) */\n-int\n-spu_legitimate_address (enum machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t\trtx x, int reg_ok_strict)\n+bool\n+spu_legitimate_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t  rtx x, bool reg_ok_strict)\n {\n   if (mode == TImode && GET_CODE (x) == AND\n       && GET_CODE (XEXP (x, 1)) == CONST_INT"}, {"sha": "f994f3709c1b264735c72b2ce0a474575f24307f", "filename": "gcc/config/spu/spu.h", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fspu%2Fspu.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fspu%2Fspu.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.h?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -416,17 +416,6 @@ targetm.resolve_overloaded_builtin = spu_resolve_overloaded_builtin;\t\\\n \n #define MAX_REGS_PER_ADDRESS 2\n \n-#ifdef REG_OK_STRICT\n-# define REG_OK_STRICT_FLAG 1\n-#else\n-# define REG_OK_STRICT_FLAG 0\n-#endif\n-\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\t\\\n-    { if (spu_legitimate_address (MODE, X, REG_OK_STRICT_FLAG))\t\\\n-\tgoto ADDR;\t\t\t\t\t\t\\\n-    }\n-\n #define LEGITIMATE_CONSTANT_P(X) spu_legitimate_constant_p(X)\n \n \f"}, {"sha": "e6fe4c0c96986c23af9009e03bdf6da1df5fa9fd", "filename": "gcc/config/stormy16/stormy16-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fstormy16%2Fstormy16-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fstormy16%2Fstormy16-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16-protos.h?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -71,7 +71,6 @@ extern int  nonimmediate_nonstack_operand (rtx, enum machine_mode);\n extern enum reg_class xstormy16_secondary_reload_class \n  (enum reg_class, enum machine_mode, rtx);\n extern enum reg_class xstormy16_preferred_reload_class (rtx, enum reg_class);\n-extern int xstormy16_legitimate_address_p (enum machine_mode, rtx, int);\n extern void xstormy16_split_move (enum machine_mode, rtx, rtx);\n extern void xstormy16_expand_move (enum machine_mode, rtx, rtx);\n extern void xstormy16_expand_arith (enum machine_mode, enum rtx_code, "}, {"sha": "16814ab4e7d462dee53fbdd37b69e6b37015bad6", "filename": "gcc/config/stormy16/stormy16.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.c?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -613,9 +613,9 @@ xstormy16_expand_andqi3 (rtx *operands)\n   && INTVAL (X) + (OFFSET) < 0x8000\t\t\t\t\t \\\n   && (INTVAL (X) + (OFFSET) < 0x100 || INTVAL (X) + (OFFSET) >= 0x7F00))\n \n-int\n+static bool\n xstormy16_legitimate_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t\t\trtx x, int strict)\n+\t\t\t\trtx x, bool strict)\n {\n   if (LEGITIMATE_ADDRESS_CONST_INT_P (x, 0))\n     return 1;\n@@ -2650,6 +2650,9 @@ xstormy16_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)\n #undef  TARGET_MACHINE_DEPENDENT_REORG\n #define TARGET_MACHINE_DEPENDENT_REORG xstormy16_reorg\n \n+#undef TARGET_LEGITIMATE_ADDRESS_P\n+#define TARGET_LEGITIMATE_ADDRESS_P\txstormy16_legitimate_address_p\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n #include \"gt-stormy16.h\""}, {"sha": "cb35a13ab6a969e17431ab90cab646324838070f", "filename": "gcc/config/stormy16/stormy16.h", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fstormy16%2Fstormy16.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fstormy16%2Fstormy16.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.h?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -536,20 +536,6 @@ enum reg_class\n \n #define MAX_REGS_PER_ADDRESS 1\n \n-#ifdef REG_OK_STRICT\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, LABEL)\t\\\n-do {\t\t\t\t\t\t\t\\\n-  if (xstormy16_legitimate_address_p (MODE, X, 1))\t\\\n-    goto LABEL;\t\t\t\t\t\t\\\n-} while (0)\n-#else\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, LABEL)\t\\\n-do {\t\t\t\t\t\t\t\\\n-  if (xstormy16_legitimate_address_p (MODE, X, 0))\t\\\n-    goto LABEL;\t\t\t\t\t\t\\\n-} while (0)\n-#endif\n-\n #ifdef REG_OK_STRICT\n #define REG_OK_FOR_BASE_P(X) \t\t\t\t\t\t   \\\n   (REGNO_OK_FOR_BASE_P (REGNO (X)) && (REGNO (X) < FIRST_PSEUDO_REGISTER))"}, {"sha": "86feccda73268f2b4b673cdb4cd222440daee758", "filename": "gcc/config/vax/vax-protos.h", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fvax%2Fvax-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fvax%2Fvax-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax-protos.h?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -19,11 +19,9 @@ along with GCC; see the file COPYING3.  If not see\n \n extern void override_options (void);\n \n-extern bool legitimate_constant_address_p (rtx);\n-extern bool legitimate_constant_p (rtx);\n-extern bool legitimate_pic_operand_p (rtx);\n-extern bool legitimate_address_p (enum machine_mode, rtx, bool);\n-extern bool vax_mode_dependent_address_p (rtx);\n+extern int legitimate_constant_address_p (rtx);\n+extern int legitimate_constant_p (rtx);\n+extern int vax_mode_dependent_address_p (rtx);\n \n #ifdef RTX_CODE\n extern const char *cond_name (rtx);"}, {"sha": "f0f6a936407c0a2e2e9378d4b2ea790a53de1c84", "filename": "gcc/config/vax/vax.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fvax%2Fvax.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fvax%2Fvax.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.c?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -46,6 +46,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"target.h\"\n #include \"target-def.h\"\n \n+static bool vax_legitimate_address_p (enum machine_mode, rtx, bool);\n static void vax_output_function_prologue (FILE *, HOST_WIDE_INT);\n static void vax_file_start (void);\n static void vax_init_libfuncs (void);\n@@ -94,6 +95,9 @@ static rtx vax_builtin_setjmp_frame_value (void);\n #undef TARGET_BUILTIN_SETJMP_FRAME_VALUE\n #define TARGET_BUILTIN_SETJMP_FRAME_VALUE vax_builtin_setjmp_frame_value\n \n+#undef TARGET_LEGITIMATE_ADDRESS_P\n+#define TARGET_LEGITIMATE_ADDRESS_P vax_legitimate_address_p\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Set global variables as needed for the options enabled.  */\n@@ -1731,7 +1735,7 @@ indexable_address_p (rtx xfoo0, rtx xfoo1, enum machine_mode mode, bool strict)\n    The MODE argument is the machine mode for the MEM expression\n    that wants to use this address.  */\n bool\n-legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n+vax_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n {\n   rtx xfoo0, xfoo1;\n "}, {"sha": "e22fbd74386ec6163dbcbf1ed3c5057eb1f4a7c5", "filename": "gcc/config/vax/vax.h", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fvax%2Fvax.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fvax%2Fvax.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.h?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -540,11 +540,6 @@ enum reg_class { NO_REGS, ALL_REGS, LIM_REG_CLASSES };\n    or if it is a pseudo reg.  */\n #define REG_OK_FOR_BASE_P(X) 1\n \n-/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n-   that is a valid memory address for an instruction.  */\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR) \\\n-  { if (legitimate_address_p ((MODE), (X), 0)) goto ADDR; }\n-\n #else\n \n /* Nonzero if X is a hard reg that can be used as an index.  */\n@@ -553,11 +548,6 @@ enum reg_class { NO_REGS, ALL_REGS, LIM_REG_CLASSES };\n /* Nonzero if X is a hard reg that can be used as a base reg.  */\n #define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n \n-/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n-   that is a valid memory address for an instruction.  */\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR) \\\n-  { if (legitimate_address_p ((MODE), (X), 1)) goto ADDR; }\n-\n #endif\n \n /* Go to LABEL if ADDR (a legitimate address expression)"}, {"sha": "c60917f07ed6e5f12d4d76e5a721d441cd35f3fc", "filename": "gcc/config/xtensa/xtensa-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -54,7 +54,6 @@ extern char *xtensa_emit_branch (bool, bool, rtx *);\n extern char *xtensa_emit_bit_branch (bool, bool, rtx *);\n extern char *xtensa_emit_movcc (bool, bool, bool, rtx *);\n extern char *xtensa_emit_call (int, rtx *);\n-extern bool xtensa_legitimate_address_p (enum machine_mode, rtx, bool);\n extern bool xtensa_tls_referenced_p (rtx);\n \n #ifdef TREE_CODE"}, {"sha": "9bdedc1814d4d152a6622ac8848d5c8b2a043e77", "filename": "gcc/config/xtensa/xtensa.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.c?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -130,6 +130,7 @@ static bool xtensa_return_in_msb (const_tree);\n static void printx (FILE *, signed int);\n static void xtensa_function_epilogue (FILE *, HOST_WIDE_INT);\n static rtx xtensa_builtin_saveregs (void);\n+static bool xtensa_legitimate_address_p (enum machine_mode, rtx, bool);\n static unsigned int xtensa_multibss_section_type_flags (tree, const char *,\n \t\t\t\t\t\t\tint) ATTRIBUTE_UNUSED;\n static section *xtensa_select_rtx_section (enum machine_mode, rtx,\n@@ -223,6 +224,9 @@ static const int reg_nonleaf_alloc_order[FIRST_PSEUDO_REGISTER] =\n #undef TARGET_CANNOT_FORCE_CONST_MEM\n #define TARGET_CANNOT_FORCE_CONST_MEM xtensa_tls_referenced_p\n \n+#undef TARGET_LEGITIMATE_ADDRESS_P\n+#define TARGET_LEGITIMATE_ADDRESS_P\txtensa_legitimate_address_p\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n \f"}, {"sha": "ec5dde1726cedd79c94182cd6cf556196ae7254a", "filename": "gcc/config/xtensa/xtensa.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.h?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -771,13 +771,6 @@ typedef struct xtensa_args\n /* Maximum number of registers that can appear in a valid memory address.  */\n #define MAX_REGS_PER_ADDRESS 1\n \n-/* Identify valid Xtensa addresses.  */\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, ADDR, LABEL)\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    if (xtensa_legitimate_address_p (MODE, ADDR, REG_OK_STRICT_FLAG))\t\\\n-      goto LABEL;\t\t\t\t\t\t\t\\\n-  } while (0)\n-\n /* A C expression that is 1 if the RTX X is a constant which is a\n    valid address.  This is defined to be the same as 'CONSTANT_P (X)',\n    but rejecting CONST_DOUBLE.  */"}, {"sha": "7f8a5d6b4c635b565826d830b7bc57e8f21c247e", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 44, "deletions": 37, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -2504,8 +2504,8 @@ added to another register (as well as added to a displacement).\n @defmac REGNO_OK_FOR_BASE_P (@var{num})\n A C expression which is nonzero if register number @var{num} is\n suitable for use as a base register in operand addresses.\n-Like @code{GO_IF_LEGITIMATE_ADDRESS}, this macro should also\n-exist in strict or non-strict variants.  Both variants behave\n+Like @code{TARGET_LEGITIMATE_ADDRESS_P}, this macro should also\n+define a strict and a non-strict variant.  Both variants behave\n the same for hard register; for pseudos, the strict variant will\n pass only those that have been allocated to a valid hard registers,\n while the non-strict variant will pass all pseudos.\n@@ -5361,42 +5361,31 @@ expressions and @code{const} arithmetic expressions, in addition to\n @defmac MAX_REGS_PER_ADDRESS\n A number, the maximum number of registers that can appear in a valid\n memory address.  Note that it is up to you to specify a value equal to\n-the maximum number that @code{GO_IF_LEGITIMATE_ADDRESS} would ever\n+the maximum number that @code{TARGET_LEGITIMATE_ADDRESS_P} would ever\n accept.\n @end defmac\n \n-@defmac GO_IF_LEGITIMATE_ADDRESS (@var{mode}, @var{x}, @var{label})\n-A C compound statement with a conditional @code{goto @var{label};}\n-executed if @var{x} (an RTX) is a legitimate memory address on the\n-target machine for a memory operand of mode @var{mode}.\n+@deftypefn {Target Hook} TARGET_LEGITIMATE_ADDRESS_P (enum machine_mode @var{mode}, rtx @var{x}, bool @var{strict})\n+A function that returns whether @var{x} (an RTX) is a legitimate memory\n+address on the target machine for a memory operand of mode @var{mode}.\n \n-It usually pays to define several simpler macros to serve as\n-subroutines for this one.  Otherwise it may be too complicated to\n-understand.\n+Legitimate addresses are defined in two variants: a strict variant and a\n+non-strict one.  The @code{strict} parameter chooses which variant is\n+desired by the caller.\n \n-This macro must exist in two variants: a strict variant and a\n-non-strict one.  The strict variant is used in the reload pass.  It\n-must be defined so that any pseudo-register that has not been\n-allocated a hard register is considered a memory reference.  In\n-contexts where some kind of register is required, a pseudo-register\n-with no hard register must be rejected.\n+The strict variant is used in the reload pass.  It must be defined so\n+that any pseudo-register that has not been allocated a hard register is\n+considered a memory reference.  This is because in contexts where some\n+kind of register is required, a pseudo-register with no hard register\n+must be rejected.  For non-hard registers, the strict variant should look\n+up the @code{reg_renumber} array; it should then proceed using the hard\n+register number in the array, or treat the pseudo as a memory reference\n+if the array holds @code{-1}.\n \n The non-strict variant is used in other passes.  It must be defined to\n accept all pseudo-registers in every context where some kind of\n register is required.\n \n-@findex REG_OK_STRICT\n-Compiler source files that want to use the strict variant of this\n-macro define the macro @code{REG_OK_STRICT}.  You should use an\n-@code{#ifdef REG_OK_STRICT} conditional to define the strict variant\n-in that case and the non-strict variant otherwise.\n-\n-Subroutines to check for acceptable registers for various purposes (one\n-for base registers, one for index registers, and so on) are typically\n-among the subroutines used to define @code{GO_IF_LEGITIMATE_ADDRESS}.\n-Then only these subroutine macros need have two variants; the higher\n-levels of macros may be the same whether strict or not.\n-\n Normally, constant addresses which are the sum of a @code{symbol_ref}\n and an integer are stored inside a @code{const} RTX to mark them as\n constant.  Therefore, there is no need to recognize such sums\n@@ -5417,13 +5406,30 @@ into the @code{symbol_ref}, and then check for it here.  When you see a\n @code{const}, you will have to look inside it to find the\n @code{symbol_ref} in order to determine the section.  @xref{Assembler\n Format}.\n-@end defmac\n+\n+@cindex @code{GO_IF_LEGITIMATE_ADDRESS}\n+Some ports are still using a deprecated legacy substitute for\n+this hook, the @code{GO_IF_LEGITIMATE_ADDRESS} macro.  This macro\n+has this syntax:\n+\n+@example\n+#define GO_IF_LEGITIMATE_ADDRESS (@var{mode}, @var{x}, @var{label})\n+@end example\n+\n+@noindent\n+and should @code{goto @var{label}} if the address @var{x} is a valid\n+address on the target machine for a memory operand of mode @var{mode}.\n+Whether the strict or non-strict variants are desired is defined by\n+the @code{REG_OK_STRICT} macro introduced earlier in this section.\n+Using the hook is usually simpler because it limits the number of\n+files that are recompiled when changes are made.\n+@end deftypefn\n \n @defmac TARGET_MEM_CONSTRAINT\n A single character to be used instead of the default @code{'m'}\n character for general memory addresses.  This defines the constraint\n letter which matches the memory addresses accepted by\n-@code{GO_IF_LEGITIMATE_ADDRESS_P}.  Define this macro if you want to\n+@code{TARGET_LEGITIMATE_ADDRESS_P}.  Define this macro if you want to\n support new address formats in your back end without changing the\n semantics of the @code{'m'} constraint.  This is necessary in order to\n preserve functionality of inline assembly constructs using the\n@@ -6957,13 +6963,14 @@ The default value is false.\n \n This section describes macros that help implement generation of position\n independent code.  Simply defining these macros is not enough to\n-generate valid PIC; you must also add support to the macros\n-@code{GO_IF_LEGITIMATE_ADDRESS} and @code{PRINT_OPERAND_ADDRESS}, as\n-well as @code{LEGITIMIZE_ADDRESS}.  You must modify the definition of\n-@samp{movsi} to do something appropriate when the source operand\n-contains a symbolic address.  You may also need to alter the handling of\n-switch statements so that they use relative addresses.\n-@c i rearranged the order of the macros above to try to force one of\n+generate valid PIC; you must also add support to the hook\n+@code{TARGET_LEGITIMATE_ADDRESS_P} and to the macro\n+@code{PRINT_OPERAND_ADDRESS}, as well as @code{LEGITIMIZE_ADDRESS}.  You\n+must modify the definition of @samp{movsi} to do something appropriate\n+when the source operand contains a symbolic address.  You may also\n+need to alter the handling of switch statements so that they use\n+relative addresses.\n+@c i rearranged the order of the macros above to try to force one of \n @c them to the next line, to eliminate an overfull hbox. --mew 10feb93\n \n @defmac PIC_OFFSET_TABLE_REGNUM"}, {"sha": "56be23b21f3aa7f8a2d6f6e3f160d1796f632de2", "filename": "gcc/ira-conflicts.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fira-conflicts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Fira-conflicts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-conflicts.c?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -248,12 +248,10 @@ get_dup_num (int op_num, bool use_commut_op_p)\n \t    break;\n \n \t  case 'p':\n-\t    GO_IF_LEGITIMATE_ADDRESS (VOIDmode, op, win_p);\n+\t    if (address_operand (op, VOIDmode))\n+\t      return -1;\n \t    break;\n-\t    \n-\t  win_p:\n-\t    return -1;\n-\t  \n+\n \t  case 'g':\n \t    return -1;\n \t    "}, {"sha": "70b0967f709e14338b9741db5f1e2ca8dca733d0", "filename": "gcc/recog.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -1253,11 +1253,15 @@ pop_operand (rtx op, enum machine_mode mode)\n int\n memory_address_p (enum machine_mode mode ATTRIBUTE_UNUSED, rtx addr)\n {\n+#ifdef GO_IF_LEGITIMATE_ADDRESS\n   GO_IF_LEGITIMATE_ADDRESS (mode, addr, win);\n   return 0;\n \n  win:\n   return 1;\n+#else\n+  return targetm.legitimate_address_p (mode, addr, 0);\n+#endif\n }\n \n /* Return 1 if OP is a valid memory reference with mode MODE,"}, {"sha": "55d00948cd1da14769318e29938b71d9da211220", "filename": "gcc/reload.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -2135,11 +2135,15 @@ hard_reg_set_here_p (unsigned int beg_regno, unsigned int end_regno, rtx x)\n int\n strict_memory_address_p (enum machine_mode mode ATTRIBUTE_UNUSED, rtx addr)\n {\n+#ifdef GO_IF_LEGITIMATE_ADDRESS\n   GO_IF_LEGITIMATE_ADDRESS (mode, addr, win);\n   return 0;\n \n  win:\n   return 1;\n+#else\n+  return targetm.legitimate_address_p (mode, addr, 1);\n+#endif\n }\n \f\n /* Like rtx_equal_p except that it allows a REG and a SUBREG to match"}, {"sha": "99c74e406f839f0b276efa79b599d739d236ee78", "filename": "gcc/target-def.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -488,6 +488,7 @@\n #define TARGET_COMMUTATIVE_P hook_bool_const_rtx_commutative_p\n #define TARGET_LEGITIMIZE_ADDRESS default_legitimize_address\n #define TARGET_DELEGITIMIZE_ADDRESS hook_rtx_rtx_identity\n+#define TARGET_LEGITIMATE_ADDRESS_P default_legitimate_address_p\n #define TARGET_USE_BLOCKS_FOR_CONSTANT_P hook_bool_mode_const_rtx_false\n #define TARGET_MIN_ANCHOR_OFFSET 0\n #define TARGET_MAX_ANCHOR_OFFSET 0\n@@ -872,6 +873,7 @@\n   TARGET_COMMUTATIVE_P,\t\t\t\t\\\n   TARGET_LEGITIMIZE_ADDRESS,\t\t\t\\\n   TARGET_DELEGITIMIZE_ADDRESS,\t\t\t\\\n+  TARGET_LEGITIMATE_ADDRESS_P,\t\t\t\\\n   TARGET_USE_BLOCKS_FOR_CONSTANT_P,\t\t\\\n   TARGET_MIN_ANCHOR_OFFSET,\t\t\t\\\n   TARGET_MAX_ANCHOR_OFFSET,\t\t\t\\"}, {"sha": "43bdfc41ada1934e0212463fb3a1ba2fd4492995", "filename": "gcc/target.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -616,6 +616,9 @@ struct gcc_target\n   /* Given an address RTX, undo the effects of LEGITIMIZE_ADDRESS.  */\n   rtx (* delegitimize_address) (rtx);\n \n+  /* Given an address RTX, say whether it is valid.  */\n+  bool (* legitimate_address_p) (enum machine_mode, rtx, bool);\n+\n   /* True if the given constant can be put into an object_block.  */\n   bool (* use_blocks_for_constant_p) (enum machine_mode, const_rtx);\n "}, {"sha": "d5c80c29aad3af415dc714d44d669e5f7ec7c6f4", "filename": "gcc/targhooks.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -68,6 +68,22 @@ along with GCC; see the file COPYING3.  If not see\n #include \"recog.h\"\n \n \n+bool\n+default_legitimate_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t      rtx addr ATTRIBUTE_UNUSED,\n+\t\t\t      bool strict ATTRIBUTE_UNUSED)\n+{\n+#ifdef GO_IF_LEGITIMATE_ADDRESS\n+  /* Defer to the old implementation using a goto.  */\n+  if (strict)\n+    return strict_memory_address_p (mode, addr);\n+  else\n+    return memory_address_p (mode, addr);\n+#else\n+  gcc_unreachable ();\n+#endif\n+}\n+\n void\n default_external_libcall (rtx fun ATTRIBUTE_UNUSED)\n {"}, {"sha": "42764f36828ef709152425bed8189e653a0af299", "filename": "gcc/targhooks.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c3dba931548987c78719180e30ebc863404b89/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=c6c3dba931548987c78719180e30ebc863404b89", "patch": "@@ -18,6 +18,8 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n+extern bool default_legitimate_address_p (enum machine_mode, rtx, bool);\n+\n extern void default_external_libcall (rtx);\n extern rtx default_legitimize_address (rtx, rtx, enum machine_mode);\n "}]}