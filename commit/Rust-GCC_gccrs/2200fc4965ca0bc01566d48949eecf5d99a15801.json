{"sha": "2200fc4965ca0bc01566d48949eecf5d99a15801", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjIwMGZjNDk2NWNhMGJjMDE1NjZkNDg5NDllZWNmNWQ5OWExNTgwMQ==", "commit": {"author": {"name": "Ira Rosen", "email": "irar@il.ibm.com", "date": "2010-07-27T12:26:31Z"}, "committer": {"name": "Ira Rosen", "email": "irar@gcc.gnu.org", "date": "2010-07-27T12:26:31Z"}, "message": "re PR tree-optimization/44152 (ICE on compiling xshow.f of xplor-nih with -O3 -ffast-math -fwhopr)\n\n\n\tPR tree-optimization/44152\n\t* tree-vect-slp.c (vect_build_slp_tree): Collect nodes with\n\tcomplex numbers for further check.\n\t(vect_supported_load_permutation_p): Check nodes with \n\tcomplex numbers.\n\nFrom-SVN: r162564", "tree": {"sha": "4d786575adf54a5e7ba627e69ddac3e1de6971f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4d786575adf54a5e7ba627e69ddac3e1de6971f2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2200fc4965ca0bc01566d48949eecf5d99a15801", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2200fc4965ca0bc01566d48949eecf5d99a15801", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2200fc4965ca0bc01566d48949eecf5d99a15801", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2200fc4965ca0bc01566d48949eecf5d99a15801/comments", "author": {"login": "irar2", "id": 16818592, "node_id": "MDQ6VXNlcjE2ODE4NTky", "avatar_url": "https://avatars.githubusercontent.com/u/16818592?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irar2", "html_url": "https://github.com/irar2", "followers_url": "https://api.github.com/users/irar2/followers", "following_url": "https://api.github.com/users/irar2/following{/other_user}", "gists_url": "https://api.github.com/users/irar2/gists{/gist_id}", "starred_url": "https://api.github.com/users/irar2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irar2/subscriptions", "organizations_url": "https://api.github.com/users/irar2/orgs", "repos_url": "https://api.github.com/users/irar2/repos", "events_url": "https://api.github.com/users/irar2/events{/privacy}", "received_events_url": "https://api.github.com/users/irar2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5a8e93d832589035a38c8a7d20cc52284565f4a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a8e93d832589035a38c8a7d20cc52284565f4a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a8e93d832589035a38c8a7d20cc52284565f4a0"}], "stats": {"total": 134, "additions": 127, "deletions": 7}, "files": [{"sha": "7dc1e0dfa937ba5b90d6822c3dc789a85f1aec46", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2200fc4965ca0bc01566d48949eecf5d99a15801/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2200fc4965ca0bc01566d48949eecf5d99a15801/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2200fc4965ca0bc01566d48949eecf5d99a15801", "patch": "@@ -1,3 +1,11 @@\n+2010-07-27  Ira Rosen  <irar@il.ibm.com>\n+\n+\tPR tree-optimization/44152\n+\t* tree-vect-slp.c (vect_build_slp_tree): Collect nodes with\n+\tcomplex numbers for further check.\n+\t(vect_supported_load_permutation_p): Check nodes with \n+\tcomplex numbers.\n+\n 2010-07-27  Joseph Myers  <joseph@codesourcery.com>\n \n \t* langhooks-def.h (lhd_init_options, LANG_HOOKS_OPTION_LANG_MASK,"}, {"sha": "ee1d1f63740f3fd35dd93fc4111b2d5d8bfe518b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2200fc4965ca0bc01566d48949eecf5d99a15801/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2200fc4965ca0bc01566d48949eecf5d99a15801/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2200fc4965ca0bc01566d48949eecf5d99a15801", "patch": "@@ -1,3 +1,8 @@\n+2010-07-27  Ira Rosen  <irar@il.ibm.com>\n+\n+\tPR tree-optimization/44152\n+\t* gcc.dg/vect/fast-math-pr44152.c: New test.\n+\n 2010-07-27  Iain Sandoe  <iains@gcc.gnu.org>\n \n \tPR ObjC/44140"}, {"sha": "ac8c138b4a826699fa0f15f1f81c6b7c5951c836", "filename": "gcc/testsuite/gcc.dg/vect/fast-math-pr44152.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2200fc4965ca0bc01566d48949eecf5d99a15801/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Ffast-math-pr44152.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2200fc4965ca0bc01566d48949eecf5d99a15801/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Ffast-math-pr44152.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Ffast-math-pr44152.c?ref=2200fc4965ca0bc01566d48949eecf5d99a15801", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_float } */\n+\n+#include <stdio.h>\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16\n+\n+_Complex float a[N]  __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__))) =\n+    { 10.0F + 20.0iF, 11.0F + 21.0iF, 12.0F + 22.0iF, 13.0F + 23.0iF,\n+      14.0F + 24.0iF, 15.0F + 25.0iF, 16.0F + 26.0iF, 17.0F + 27.0iF,\n+      18.0F + 28.0iF, 19.0F + 29.0iF, 20.0F + 30.0iF, 21.0F + 31.0iF,\n+      22.0F + 32.0iF, 23.0F + 33.0iF, 24.0F + 34.0iF, 25.0F + 35.0iF };\n+\n+_Complex float c[N] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));\n+\n+\n+__attribute__ ((noinline)) _Complex float \n+foo (int x)\n+{\n+  int i;\n+  _Complex float *p = a + x;\n+  _Complex float sum = 10.0F + 20.0iF;\n+ \n+  for (i = 0; i < N; i++)\n+   {\n+     sum += *p;\n+     p++;\n+   }\n+\n+  c[0] = sum + 66.0F + 86.0iF; \n+ \n+  return 0;\n+}\n+\n+\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "19967bc699528f4f4230767f9e5b57806e95b838", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 76, "deletions": 7, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2200fc4965ca0bc01566d48949eecf5d99a15801/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2200fc4965ca0bc01566d48949eecf5d99a15801/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=2200fc4965ca0bc01566d48949eecf5d99a15801", "patch": "@@ -318,7 +318,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n   gimple stmt = VEC_index (gimple, stmts, 0);\n   enum vect_def_type first_stmt_dt0 = vect_uninitialized_def;\n   enum vect_def_type first_stmt_dt1 = vect_uninitialized_def;\n-  enum tree_code first_stmt_code = ERROR_MARK, rhs_code;\n+  enum tree_code first_stmt_code = ERROR_MARK, rhs_code = ERROR_MARK;\n   tree first_stmt_def1_type = NULL_TREE, first_stmt_def0_type = NULL_TREE;\n   tree lhs;\n   bool stop_recursion = false, need_same_oprnds = false;\n@@ -648,6 +648,13 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n             += targetm.vectorize.builtin_vectorization_cost (vec_perm, NULL, 0) \n                * group_size;\n         }\n+      else\n+        { \n+          /* We don't check here complex numbers chains, so we keep them in\n+\t     LOADS for further check in vect_supported_load_permutation_p.  */ \n+          if (rhs_code == REALPART_EXPR || rhs_code == IMAGPART_EXPR)\n+            VEC_safe_push (slp_tree, heap, *loads, *node);\n+        }\n \n       return true;\n     }\n@@ -868,8 +875,9 @@ vect_supported_load_permutation_p (slp_instance slp_instn, int group_size,\n   int i = 0, j, prev = -1, next, k, number_of_groups;\n   bool supported, bad_permutation = false;\n   sbitmap load_index;\n-  slp_tree node;\n-  gimple stmt;\n+  slp_tree node, other_complex_node;\n+  gimple stmt, first = NULL, other_node_first;\n+  unsigned complex_numbers = 0;\n \n   /* FORNOW: permutations are only supported in SLP.  */\n   if (!slp_instn)\n@@ -893,10 +901,71 @@ vect_supported_load_permutation_p (slp_instance slp_instn, int group_size,\n   for (i = 0;\n        VEC_iterate (slp_tree, SLP_INSTANCE_LOADS (slp_instn), i, node);\n        i++)\n-    if (VEC_length (gimple, SLP_TREE_SCALAR_STMTS (node))\n-        != (unsigned) group_size)\n-      return false;\n-     \n+    {\n+      if (VEC_length (gimple, SLP_TREE_SCALAR_STMTS (node))\n+          != (unsigned) group_size)\n+        return false;\n+\n+      stmt = VEC_index (gimple, SLP_TREE_SCALAR_STMTS (node), 0);\n+      if (is_gimple_assign (stmt) \n+          && (gimple_assign_rhs_code (stmt) == REALPART_EXPR\n+              || gimple_assign_rhs_code (stmt) == IMAGPART_EXPR))\n+        complex_numbers++;\n+    }\n+\n+  /* Complex operands can be swapped as following:\n+      real_c = real_b + real_a;\n+      imag_c = imag_a + imag_b;\n+     i.e., we have {real_b, imag_a} and {real_a, imag_b} instead of \n+     {real_a, imag_a} and {real_b, imag_b}. We check here that if interleaving\n+     chains are mixed, they match the above pattern.  */\n+  if (complex_numbers)\n+    {\n+      for (i = 0;\n+           VEC_iterate (slp_tree, SLP_INSTANCE_LOADS (slp_instn), i, node);\n+           i++)\n+        {\n+          for (j = 0;\n+               VEC_iterate (gimple, SLP_TREE_SCALAR_STMTS (node), j, stmt);\n+               j++)\n+            {\n+              if (j == 0)\n+                first = stmt;\n+              else\n+                {\n+                  if (DR_GROUP_FIRST_DR (vinfo_for_stmt (stmt)) != first)\n+                    {\n+                      if (complex_numbers != 2)\n+                        return false;\n+\n+                      if (i == 0)\n+                        k = 1;\n+                      else\n+                        k = 0;\n+ \n+                      other_complex_node = VEC_index (slp_tree, \n+                                            SLP_INSTANCE_LOADS (slp_instn), k);\n+                      other_node_first = VEC_index (gimple, \n+                                SLP_TREE_SCALAR_STMTS (other_complex_node), 0);\n+\n+                      if (DR_GROUP_FIRST_DR (vinfo_for_stmt (stmt)) \n+                          != other_node_first)\n+                       return false;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+  /* We checked that this case ok, so there is no need to proceed with \n+     permutation tests.  */\n+  if (complex_numbers == 2)\n+    {\n+      VEC_free (slp_tree, heap, SLP_INSTANCE_LOADS (slp_instn));\n+      VEC_free (int, heap, SLP_INSTANCE_LOAD_PERMUTATION (slp_instn));\n+      return true;\n+    }\n+                   \n   node = SLP_INSTANCE_TREE (slp_instn);\n   stmt = VEC_index (gimple, SLP_TREE_SCALAR_STMTS (node), 0);\n   /* LOAD_PERMUTATION is a list of indices of all the loads of the SLP"}]}