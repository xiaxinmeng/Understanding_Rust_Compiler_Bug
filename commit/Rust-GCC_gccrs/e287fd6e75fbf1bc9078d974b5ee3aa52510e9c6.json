{"sha": "e287fd6e75fbf1bc9078d974b5ee3aa52510e9c6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTI4N2ZkNmU3NWZiZjFiYzkwNzhkOTc0YjVlZTNhYTUyNTEwZTljNg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-11-24T12:02:20Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-11-24T12:02:20Z"}, "message": "(expand_expr, case ADDR_EXPR): Also pass const0_rtx if necessary, to avoid multiple cleanup runs.\n\n(expand_expr, case ADDR_EXPR): Also pass const0_rtx if necessary, to\navoid multiple cleanup runs.\n(expand_expr, case WITH_CLEANUP_EXPR): Pass const0_rtx if necessary,\nto keep the recursive call from running the same cleanups twice.\n(expand_expr, case TARGET_EXPR): Don't try to add the cleanup if\nignore's non-zero, since we would have already done it.\n\nFrom-SVN: r6155", "tree": {"sha": "e53747445062648f9eec20f994c33d97c3e192c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e53747445062648f9eec20f994c33d97c3e192c0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e287fd6e75fbf1bc9078d974b5ee3aa52510e9c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e287fd6e75fbf1bc9078d974b5ee3aa52510e9c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e287fd6e75fbf1bc9078d974b5ee3aa52510e9c6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e287fd6e75fbf1bc9078d974b5ee3aa52510e9c6/comments", "author": null, "committer": null, "parents": [{"sha": "0776af7805bf15e1a3f5a25a7e0f4b43b4bd497b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0776af7805bf15e1a3f5a25a7e0f4b43b4bd497b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0776af7805bf15e1a3f5a25a7e0f4b43b4bd497b"}], "stats": {"total": 49, "additions": 24, "deletions": 25}, "files": [{"sha": "b905c6ccb14b77db2fffe3506e3314e2d5863e3d", "filename": "gcc/expr.c", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e287fd6e75fbf1bc9078d974b5ee3aa52510e9c6/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e287fd6e75fbf1bc9078d974b5ee3aa52510e9c6/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=e287fd6e75fbf1bc9078d974b5ee3aa52510e9c6", "patch": "@@ -4602,7 +4602,9 @@ expand_expr (exp, target, tmode, modifier)\n       if (RTL_EXPR_RTL (exp) == 0)\n \t{\n \t  RTL_EXPR_RTL (exp)\n-\t    = expand_expr (TREE_OPERAND (exp, 0), target, tmode, modifier);\n+\t    = expand_expr (TREE_OPERAND (exp, 0),\n+\t\t\t   target ? target : const0_rtx,\n+\t\t\t   tmode, modifier);\n \t  cleanups_this_call\n \t    = tree_cons (NULL_TREE, TREE_OPERAND (exp, 2), cleanups_this_call);\n \t  /* That's it for this cleanup.  */\n@@ -5611,29 +5613,23 @@ expand_expr (exp, target, tmode, modifier)\n \t\tDECL_RTL (slot) = target;\n \t      }\n \n-#if 0\n-\t    /* I bet this needs to be done, and I bet that it needs to\n-\t       be above, inside the else clause.  The reason is\n-\t       simple, how else is it going to get cleaned up? (mrs)\n-\n-\t       The reason is probably did not work before, and was\n-\t       commented out is because this was re-expanding already\n-\t       expanded target_exprs (target == 0 and DECL_RTL (slot)\n-\t       != 0) also cleaning them up many times as well.  :-( */\n-\n-\t    /* Since SLOT is not known to the called function\n-\t       to belong to its stack frame, we must build an explicit\n-\t       cleanup.  This case occurs when we must build up a reference\n-\t       to pass the reference as an argument.  In this case,\n-\t       it is very likely that such a reference need not be\n-\t       built here.  */\n-\n-\t    if (TREE_OPERAND (exp, 2) == 0)\n-\t      TREE_OPERAND (exp, 2) = maybe_build_cleanup (slot);\n-\t    if (TREE_OPERAND (exp, 2))\n-\t      cleanups_this_call = tree_cons (NULL_TREE, TREE_OPERAND (exp, 2),\n-\t\t\t\t\t      cleanups_this_call);\n-#endif\n+\t    /* We set IGNORE when we know that we're already\n+\t       doing this for a cleanup.  */\n+\t    if (ignore == 0)\n+\t      {\n+\t\t/* Since SLOT is not known to the called function\n+\t\t   to belong to its stack frame, we must build an explicit\n+\t\t   cleanup.  This case occurs when we must build up a reference\n+\t\t   to pass the reference as an argument.  In this case,\n+\t\t   it is very likely that such a reference need not be\n+\t\t   built here.  */\n+\n+\t\tif (TREE_OPERAND (exp, 2) == 0)\n+\t\t  TREE_OPERAND (exp, 2) = maybe_build_cleanup (slot);\n+\t\tif (TREE_OPERAND (exp, 2))\n+\t\t  cleanups_this_call = tree_cons (NULL_TREE, TREE_OPERAND (exp, 2),\n+\t\t\t\t\t\t  cleanups_this_call);\n+\t      }\n \t  }\n \telse\n \t  {\n@@ -5771,7 +5767,10 @@ expand_expr (exp, target, tmode, modifier)\n \t}\n       else\n \t{\n-\t  op0 = expand_expr (TREE_OPERAND (exp, 0), NULL_RTX, VOIDmode,\n+\t  /* We make sure to pass const0_rtx down if we came in with\n+\t     ignore set, to avoid doing the cleanups twice for something.  */\n+\t  op0 = expand_expr (TREE_OPERAND (exp, 0),\n+\t\t\t     ignore ? const0_rtx : NULL_RTX, VOIDmode,\n \t\t\t     (modifier == EXPAND_INITIALIZER\n \t\t\t      ? modifier : EXPAND_CONST_ADDRESS));\n "}]}