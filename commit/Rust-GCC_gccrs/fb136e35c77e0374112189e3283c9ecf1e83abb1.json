{"sha": "fb136e35c77e0374112189e3283c9ecf1e83abb1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmIxMzZlMzVjNzdlMDM3NDExMjE4OWUzMjgzYzllY2YxZTgzYWJiMQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2015-03-23T08:02:39Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2015-03-23T08:02:39Z"}, "message": "re PR preprocessor/65238 (__has_attribute is not handled properly with -traditional-cpp.)\n\n\tPR preprocessor/65238\n\t* internal.h (_cpp_scan_out_logical_line): Add third argument.\n\t* directives.c (prepare_directive_trad): Pass false to it.\n\t* traditional.c (_cpp_read_logical_line_trad,\n\t_cpp_create_trad_definition): Likewise.\n\t(struct fun_macro): Add paramc field.\n\t(fun_like_macro): New function.\n\t(maybe_start_funlike): Handle NODE_BUILTIN macros.  Initialize\n\tmacro->paramc field.\n\t(save_argument): Use macro->paramc instead of\n\tmacro->node->value.macro->paramc.\n\t(push_replacement_text): Formatting fix.\n\t(recursive_macro): Use fun_like_macro helper.\n\t(_cpp_scan_out_logical_line): Likewise.  Add BUILTIN_MACRO_ARG\n\targument.  Initialize fmacro.paramc field.  Handle builtin\n\tfunction-like macros.\n\n\t* c-c++-common/cpp/pr65238-1.c: New test.\n\t* gcc.dg/cpp/pr65238-2.c: New test.\n\t* gcc.dg/cpp/trad/pr65238-3.c: New test.\n\t* gcc.dg/cpp/trad/pr65238-4.c: New test.\n\nFrom-SVN: r221587", "tree": {"sha": "ca62635a383044139bfcff92d867148331a09a0f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ca62635a383044139bfcff92d867148331a09a0f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fb136e35c77e0374112189e3283c9ecf1e83abb1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb136e35c77e0374112189e3283c9ecf1e83abb1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb136e35c77e0374112189e3283c9ecf1e83abb1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb136e35c77e0374112189e3283c9ecf1e83abb1/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "30c931de07f8fcbe4ef3b550633c274fe7828975", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30c931de07f8fcbe4ef3b550633c274fe7828975", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30c931de07f8fcbe4ef3b550633c274fe7828975"}], "stats": {"total": 284, "additions": 266, "deletions": 18}, "files": [{"sha": "9b84418bc81db3c74569ce1b86261f7da1b9951d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb136e35c77e0374112189e3283c9ecf1e83abb1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb136e35c77e0374112189e3283c9ecf1e83abb1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fb136e35c77e0374112189e3283c9ecf1e83abb1", "patch": "@@ -1,3 +1,11 @@\n+2015-03-23  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR preprocessor/65238\n+\t* c-c++-common/cpp/pr65238-1.c: New test.\n+\t* gcc.dg/cpp/pr65238-2.c: New test.\n+\t* gcc.dg/cpp/trad/pr65238-3.c: New test.\n+\t* gcc.dg/cpp/trad/pr65238-4.c: New test.\n+\n 2015-03-23  Paul Thomas  <pault@gcc.gnu.org>\n \t    Mikael Morin  <mikael@gcc.gnu.org>\n "}, {"sha": "6d6346535ab8f891a37cdbe7e18a341e10149c79", "filename": "gcc/testsuite/c-c++-common/cpp/pr65238-1.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb136e35c77e0374112189e3283c9ecf1e83abb1/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fpr65238-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb136e35c77e0374112189e3283c9ecf1e83abb1/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fpr65238-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fpr65238-1.c?ref=fb136e35c77e0374112189e3283c9ecf1e83abb1", "patch": "@@ -0,0 +1,53 @@\n+/* PR preprocessor/65238 */\n+/* { dg-do run } */\n+\n+#define A unused\n+#define B A\n+#define C B\n+#define D __has_attribute(unused)\n+#define E __has_attribute(C)\n+#define F(X) __has_attribute(X)\n+#if !__has_attribute(unused)\n+#error unused attribute not supported - 1\n+#endif\n+#if !__has_attribute(C)\n+#error unused attribute not supported - 2\n+#endif\n+#if !D\n+#error unused attribute not supported - 3\n+#endif\n+#if !E\n+#error unused attribute not supported - 4\n+#endif\n+#if !F(unused)\n+#error unused attribute not supported - 5\n+#endif\n+#if !F(C)\n+#error unused attribute not supported - 6\n+#endif\n+int a = __has_attribute (unused) + __has_attribute (C) + D + E + F (unused) + F (C);\n+int b = __has_attribute (unused);\n+int c = __has_attribute (C);\n+int d = D;\n+int e = E;\n+int f = F (unused);\n+int g = F (C);\n+int h = __has_attribute (\n+  unused\n+) + __has_attribute  (\n+\n+C) + F (\n+unused\n+\n+) + F\n+(\n+C\n+);\n+\n+int\n+main ()\n+{\n+  if (a != 6 || b != 1 || c != 1 || d != 1 || e != 1 || f != 1 || g != 1 || h != 4)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "c6a7aecddebe87ea9e2abdeabaeb7a86076e8579", "filename": "gcc/testsuite/gcc.dg/cpp/pr65238-2.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb136e35c77e0374112189e3283c9ecf1e83abb1/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpr65238-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb136e35c77e0374112189e3283c9ecf1e83abb1/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpr65238-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpr65238-2.c?ref=fb136e35c77e0374112189e3283c9ecf1e83abb1", "patch": "@@ -0,0 +1,18 @@\n+/* PR preprocessor/65238 */\n+/* { dg-do preprocess } */\n+\n+#if __has_attribute(\n+#endif\n+#if __has_attribute(unused\n+#endif\n+#if __has_attribute(unused, unused)\n+#endif\n+#if __has_attribute(__has_attribute(unused))\n+#endif\n+\n+/* { dg-error \"macro .__has_attribute. requires an identifier\" \"\" {target \"*-*-*\"} 4 } */\n+/* { dg-error \"missing ... after .__has_attribute.\" \"\" {target \"*-*-*\"} 6 } */\n+/* { dg-error \"missing ... after .__has_attribute.\" \"\" {target \"*-*-*\"} 8 } */\n+/* { dg-error \"missing binary operator before token .unused.\" \"\" {target \"*-*-*\"} 8 } */\n+/* { dg-error \"macro .__has_attribute. requires an identifier\" \"\" {target \"*-*-*\"} 10 } */\n+/* { dg-error \"missing ... in expression\" \"\" {target \"*-*-*\"} 10 } */"}, {"sha": "949dc005a1fbdd5fd8bf27ef3e52d97dbaf8e951", "filename": "gcc/testsuite/gcc.dg/cpp/trad/pr65238-3.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb136e35c77e0374112189e3283c9ecf1e83abb1/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Ftrad%2Fpr65238-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb136e35c77e0374112189e3283c9ecf1e83abb1/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Ftrad%2Fpr65238-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Ftrad%2Fpr65238-3.c?ref=fb136e35c77e0374112189e3283c9ecf1e83abb1", "patch": "@@ -0,0 +1,5 @@\n+/* PR preprocessor/65238 */\n+/* { dg-do run } */\n+/* { dg-options \"-traditional-cpp\" } */\n+\n+#include \"../../../c-c++-common/cpp/pr65238-1.c\""}, {"sha": "cf2f449133c2a2d1adc4ae2e820c0f0b3ed9a4a0", "filename": "gcc/testsuite/gcc.dg/cpp/trad/pr65238-4.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb136e35c77e0374112189e3283c9ecf1e83abb1/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Ftrad%2Fpr65238-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb136e35c77e0374112189e3283c9ecf1e83abb1/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Ftrad%2Fpr65238-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Ftrad%2Fpr65238-4.c?ref=fb136e35c77e0374112189e3283c9ecf1e83abb1", "patch": "@@ -0,0 +1,19 @@\n+/* PR preprocessor/65238 */\n+/* { dg-do preprocess } */\n+/* { dg-options \"-traditional-cpp\" } */\n+\n+#if __has_attribute(\n+#endif\n+#if __has_attribute(unused\n+#endif\n+#if __has_attribute(unused, unused)\n+#endif\n+#if __has_attribute(__has_attribute(unused))\n+#endif\n+\n+/* { dg-error \"unterminated argument list invoking macro .__has_attribute.\" \"\" {target \"*-*-*\"} 5 } */\n+/* { dg-error \"#if with no expression\" \"\" {target \"*-*-*\"} 5 } */\n+/* { dg-error \"unterminated argument list invoking macro .__has_attribute.\" \"\" {target \"*-*-*\"} 7 } */\n+/* { dg-error \"macro .__has_attribute. passed 2 arguments, but takes just 1\" \"\" {target \"*-*-*\"} 9 } */\n+/* { dg-error \"missing ... in expression\" \"\" {target \"*-*-*\"} 9 } */\n+/* { dg-error \"macro .__has_attribute. requires an identifier\" \"\" {target \"*-*-*\"} 11 } */"}, {"sha": "daaa11ea1275ea2f0be4df944226521abfb6385c", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb136e35c77e0374112189e3283c9ecf1e83abb1/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb136e35c77e0374112189e3283c9ecf1e83abb1/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=fb136e35c77e0374112189e3283c9ecf1e83abb1", "patch": "@@ -1,3 +1,22 @@\n+2015-03-23  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR preprocessor/65238\n+\t* internal.h (_cpp_scan_out_logical_line): Add third argument.\n+\t* directives.c (prepare_directive_trad): Pass false to it.\n+\t* traditional.c (_cpp_read_logical_line_trad,\n+\t_cpp_create_trad_definition): Likewise.\n+\t(struct fun_macro): Add paramc field.\n+\t(fun_like_macro): New function.\n+\t(maybe_start_funlike): Handle NODE_BUILTIN macros.  Initialize\n+\tmacro->paramc field.\n+\t(save_argument): Use macro->paramc instead of\n+\tmacro->node->value.macro->paramc.\n+\t(push_replacement_text): Formatting fix.\n+\t(recursive_macro): Use fun_like_macro helper.\n+\t(_cpp_scan_out_logical_line): Likewise.  Add BUILTIN_MACRO_ARG\n+\targument.  Initialize fmacro.paramc field.  Handle builtin\n+\tfunction-like macros.\n+\n 2015-03-16  Edward Smith-Rowland  <3dw4rd@verizon.net>\n \n \tPR c++/64626"}, {"sha": "2a824e6ed3f14a05b65fb37f8631883834e50f85", "filename": "libcpp/directives.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb136e35c77e0374112189e3283c9ecf1e83abb1/libcpp%2Fdirectives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb136e35c77e0374112189e3283c9ecf1e83abb1/libcpp%2Fdirectives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fdirectives.c?ref=fb136e35c77e0374112189e3283c9ecf1e83abb1", "patch": "@@ -346,7 +346,7 @@ prepare_directive_trad (cpp_reader *pfile)\n \n       if (no_expand)\n \tpfile->state.prevent_expansion++;\n-      _cpp_scan_out_logical_line (pfile, NULL);\n+      _cpp_scan_out_logical_line (pfile, NULL, false);\n       if (no_expand)\n \tpfile->state.prevent_expansion--;\n "}, {"sha": "c2d08168945f639c24eca577d6de9b6bde120908", "filename": "libcpp/internal.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb136e35c77e0374112189e3283c9ecf1e83abb1/libcpp%2Finternal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb136e35c77e0374112189e3283c9ecf1e83abb1/libcpp%2Finternal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finternal.h?ref=fb136e35c77e0374112189e3283c9ecf1e83abb1", "patch": "@@ -708,7 +708,7 @@ extern void _cpp_preprocess_dir_only (cpp_reader *,\n \t\t\t\t      const struct _cpp_dir_only_callbacks *);\n \n /* In traditional.c.  */\n-extern bool _cpp_scan_out_logical_line (cpp_reader *, cpp_macro *);\n+extern bool _cpp_scan_out_logical_line (cpp_reader *, cpp_macro *, bool);\n extern bool _cpp_read_logical_line_trad (cpp_reader *);\n extern void _cpp_overlay_buffer (cpp_reader *pfile, const unsigned char *,\n \t\t\t\t size_t);"}, {"sha": "e96b4f947276f5f44f18d3bc31231238f142741e", "filename": "libcpp/traditional.c", "status": "modified", "additions": 142, "deletions": 16, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb136e35c77e0374112189e3283c9ecf1e83abb1/libcpp%2Ftraditional.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb136e35c77e0374112189e3283c9ecf1e83abb1/libcpp%2Ftraditional.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Ftraditional.c?ref=fb136e35c77e0374112189e3283c9ecf1e83abb1", "patch": "@@ -62,6 +62,9 @@ struct fun_macro\n   /* The line the macro name appeared on.  */\n   source_location line;\n \n+  /* Number of parameters.  */\n+  unsigned int paramc;\n+\n   /* Zero-based index of argument being currently lexed.  */\n   unsigned int argc;\n };\n@@ -304,24 +307,41 @@ _cpp_read_logical_line_trad (cpp_reader *pfile)\n       if (pfile->buffer->need_line && !_cpp_get_fresh_line (pfile))\n \treturn false;\n     }\n-  while (!_cpp_scan_out_logical_line (pfile, NULL) || pfile->state.skipping);\n+  while (!_cpp_scan_out_logical_line (pfile, NULL, false)\n+\t || pfile->state.skipping);\n \n   return pfile->buffer != NULL;\n }\n \n+/* Return true if NODE is a fun_like macro.  */\n+static inline bool\n+fun_like_macro (cpp_hashnode *node)\n+{\n+  if (node->flags & NODE_BUILTIN)\n+    return node->value.builtin == BT_HAS_ATTRIBUTE;\n+  else\n+    return node->value.macro->fun_like;\n+}\n+\n /* Set up state for finding the opening '(' of a function-like\n    macro.  */\n static void\n-maybe_start_funlike (cpp_reader *pfile, cpp_hashnode *node, const uchar *start, struct fun_macro *macro)\n+maybe_start_funlike (cpp_reader *pfile, cpp_hashnode *node, const uchar *start,\n+\t\t     struct fun_macro *macro)\n {\n-  unsigned int n = node->value.macro->paramc + 1;\n+  unsigned int n;\n+  if (node->flags & NODE_BUILTIN)\n+    n = 1;\n+  else\n+    n = node->value.macro->paramc;\n \n   if (macro->buff)\n     _cpp_release_buff (pfile, macro->buff);\n-  macro->buff = _cpp_get_buff (pfile, n * sizeof (size_t));\n+  macro->buff = _cpp_get_buff (pfile, (n + 1) * sizeof (size_t));\n   macro->args = (size_t *) BUFF_FRONT (macro->buff);\n   macro->node = node;\n   macro->offset = start - pfile->out.base;\n+  macro->paramc = n;\n   macro->argc = 0;\n }\n \n@@ -330,7 +350,7 @@ static void\n save_argument (struct fun_macro *macro, size_t offset)\n {\n   macro->argc++;\n-  if (macro->argc <= macro->node->value.macro->paramc)\n+  if (macro->argc <= macro->paramc)\n     macro->args[macro->argc] = offset;\n }\n \n@@ -340,9 +360,13 @@ save_argument (struct fun_macro *macro, size_t offset)\n \n    If MACRO is non-NULL, then we are scanning the replacement list of\n    MACRO, and we call save_replacement_text() every time we meet an\n-   argument.  */\n+   argument.\n+\n+   If BUILTIN_MACRO_ARG is true, this is called to macro expand\n+   arguments of builtin function-like macros.  */\n bool\n-_cpp_scan_out_logical_line (cpp_reader *pfile, cpp_macro *macro)\n+_cpp_scan_out_logical_line (cpp_reader *pfile, cpp_macro *macro,\n+\t\t\t    bool builtin_macro_arg)\n {\n   bool result = true;\n   cpp_context *context;\n@@ -359,14 +383,18 @@ _cpp_scan_out_logical_line (cpp_reader *pfile, cpp_macro *macro)\n   fmacro.node = NULL;\n   fmacro.offset = 0;\n   fmacro.line = 0;\n+  fmacro.paramc = 0;\n   fmacro.argc = 0;\n \n   quote = 0;\n   header_ok = pfile->state.angled_headers;\n   CUR (pfile->context) = pfile->buffer->cur;\n   RLIMIT (pfile->context) = pfile->buffer->rlimit;\n-  pfile->out.cur = pfile->out.base;\n-  pfile->out.first_line = pfile->line_table->highest_line;\n+  if (!builtin_macro_arg)\n+    {\n+      pfile->out.cur = pfile->out.base;\n+      pfile->out.first_line = pfile->line_table->highest_line;\n+    }\n   /* start_of_input_line is needed to make sure that directives really,\n      really start at the first character of the line.  */\n   start_of_input_line = pfile->buffer->cur;\n@@ -379,6 +407,7 @@ _cpp_scan_out_logical_line (cpp_reader *pfile, cpp_macro *macro)\n   for (;;)\n     {\n       if (!context->prev\n+\t  && !builtin_macro_arg\n \t  && cur >= pfile->buffer->notes[pfile->buffer->cur_note].pos)\n \t{\n \t  pfile->buffer->cur = cur;\n@@ -410,6 +439,8 @@ _cpp_scan_out_logical_line (cpp_reader *pfile, cpp_macro *macro)\n \t  /* Omit the newline from the output buffer.  */\n \t  pfile->out.cur = out - 1;\n \t  pfile->buffer->cur = cur;\n+\t  if (builtin_macro_arg)\n+\t    goto done;\n \t  pfile->buffer->need_line = true;\n \t  CPP_INCREMENT_LINE (pfile, 0);\n \n@@ -489,8 +520,7 @@ _cpp_scan_out_logical_line (cpp_reader *pfile, cpp_macro *macro)\n \t\t{\n \t\t  /* Macros invalidate MI optimization.  */\n \t\t  pfile->mi_valid = false;\n-\t\t  if (! (node->flags & NODE_BUILTIN)\n-\t\t      && node->value.macro->fun_like)\n+\t\t  if (fun_like_macro (node))\n \t\t    {\n \t\t      maybe_start_funlike (pfile, node, out_start, &fmacro);\n \t\t      lex_state = ls_fun_open;\n@@ -572,6 +602,103 @@ _cpp_scan_out_logical_line (cpp_reader *pfile, cpp_macro *macro)\n \t      paren_depth--;\n \t      if (lex_state == ls_fun_close && paren_depth == 0)\n \t\t{\n+\t\t  if (fmacro.node->flags & NODE_BUILTIN)\n+\t\t    {\n+\t\t      /* Handle builtin function-like macros like\n+\t\t\t __has_attribute.  The already parsed arguments\n+\t\t\t are put into a buffer, which is then preprocessed\n+\t\t\t and the result is fed to _cpp_push_text_context\n+\t\t\t with disabled expansion, where the ISO preprocessor\n+\t\t\t parses it.  While in traditional preprocessing\n+\t\t\t macro arguments aren't immediately expanded, they in\n+\t\t\t the end are because the macro with replaced arguments\n+\t\t\t is preprocessed again.  For the builtin function-like\n+\t\t\t macros we need the argument immediately though,\n+\t\t\t if we don't preprocess them, they would behave\n+\t\t\t very differently from ISO preprocessor handling\n+\t\t\t of those builtin macros.  So, this handling is\n+\t\t\t more similar to traditional preprocessing of\n+\t\t\t #if directives, where we also keep preprocessing\n+\t\t\t until everything is expanded, and then feed the\n+\t\t\t result with disabled expansion to ISO preprocessor\n+\t\t\t for handling the directives.  */\n+\t\t      lex_state = ls_none;\n+\t\t      save_argument (&fmacro, out - pfile->out.base);\n+\t\t      cpp_macro m;\n+\t\t      memset (&m, '\\0', sizeof (m));\n+\t\t      m.paramc = fmacro.paramc;\n+\t\t      if (_cpp_arguments_ok (pfile, &m, fmacro.node,\n+\t\t\t\t\t     fmacro.argc))\n+\t\t\t{\n+\t\t\t  size_t len = fmacro.args[1] - fmacro.args[0];\n+\t\t\t  uchar *buf;\n+\n+\t\t\t  /* Remove the macro's invocation from the\n+\t\t\t     output, and push its replacement text.  */\n+\t\t\t  pfile->out.cur = pfile->out.base + fmacro.offset;\n+\t\t\t  CUR (context) = cur;\n+\t\t\t  buf = _cpp_unaligned_alloc (pfile, len + 2);\n+\t\t\t  buf[0] = '(';\n+\t\t\t  memcpy (buf + 1, pfile->out.base + fmacro.args[0],\n+\t\t\t\t  len);\n+\t\t\t  buf[len + 1] = '\\n';\n+\n+\t\t\t  const unsigned char *ctx_rlimit = RLIMIT (context);\n+\t\t\t  const unsigned char *saved_cur = pfile->buffer->cur;\n+\t\t\t  const unsigned char *saved_rlimit\n+\t\t\t    = pfile->buffer->rlimit;\n+\t\t\t  const unsigned char *saved_line_base\n+\t\t\t    = pfile->buffer->line_base;\n+\t\t\t  bool saved_need_line = pfile->buffer->need_line;\n+\t\t\t  cpp_buffer *saved_overlaid_buffer\n+\t\t\t    = pfile->overlaid_buffer;\n+\t\t\t  pfile->buffer->cur = buf;\n+\t\t\t  pfile->buffer->line_base = buf;\n+\t\t\t  pfile->buffer->rlimit = buf + len + 1;\n+\t\t\t  pfile->buffer->need_line = false;\n+\t\t\t  pfile->overlaid_buffer = pfile->buffer;\n+\t\t\t  bool saved_in_directive = pfile->state.in_directive;\n+\t\t\t  pfile->state.in_directive = true;\n+\t\t\t  cpp_context *saved_prev_context = context->prev;\n+\t\t\t  context->prev = NULL;\n+\n+\t\t\t  _cpp_scan_out_logical_line (pfile, NULL, true);\n+\n+\t\t\t  pfile->state.in_directive = saved_in_directive;\n+\t\t\t  check_output_buffer (pfile, 1);\n+\t\t\t  *pfile->out.cur = '\\n';\n+\t\t\t  pfile->buffer->cur = pfile->out.base + fmacro.offset;\n+\t\t\t  pfile->buffer->line_base = pfile->buffer->cur;\n+\t\t\t  pfile->buffer->rlimit = pfile->out.cur;\n+\t\t\t  CUR (context) = pfile->buffer->cur;\n+\t\t\t  RLIMIT (context) = pfile->buffer->rlimit;\n+\n+\t\t\t  pfile->state.prevent_expansion++;\n+\t\t\t  const uchar *text\n+\t\t\t    = _cpp_builtin_macro_text (pfile, fmacro.node);\n+\t\t\t  pfile->state.prevent_expansion--;\n+\n+\t\t\t  context->prev = saved_prev_context;\n+\t\t\t  pfile->buffer->cur = saved_cur;\n+\t\t\t  pfile->buffer->rlimit = saved_rlimit;\n+\t\t\t  pfile->buffer->line_base = saved_line_base;\n+\t\t\t  pfile->buffer->need_line = saved_need_line;\n+\t\t\t  pfile->overlaid_buffer = saved_overlaid_buffer;\n+\t\t\t  pfile->out.cur = pfile->out.base + fmacro.offset;\n+\t\t\t  CUR (context) = cur;\n+\t\t\t  RLIMIT (context) = ctx_rlimit;\n+\t\t\t  len = ustrlen (text);\n+\t\t\t  buf = _cpp_unaligned_alloc (pfile, len + 1);\n+\t\t\t  memcpy (buf, text, len);\n+\t\t\t  buf[len] = '\\n';\n+\t\t\t  text = buf;\n+\t\t\t  _cpp_push_text_context (pfile, fmacro.node,\n+\t\t\t\t\t\t  text, len);\n+\t\t\t  goto new_context;\n+\t\t\t}\n+\t\t      break;\n+\t\t    }\n+\n \t\t  cpp_macro *m = fmacro.node->value.macro;\n \n \t\t  m->used = 1;\n@@ -588,8 +715,7 @@ _cpp_scan_out_logical_line (cpp_reader *pfile, cpp_macro *macro)\n \t\t    {\n \t\t      /* Remove the macro's invocation from the\n \t\t\t output, and push its replacement text.  */\n-\t\t      pfile->out.cur = (pfile->out.base\n-\t\t\t\t\t     + fmacro.offset);\n+\t\t      pfile->out.cur = pfile->out.base + fmacro.offset;\n \t\t      CUR (context) = cur;\n \t\t      replace_args_and_push (pfile, &fmacro);\n \t\t      goto new_context;\n@@ -711,7 +837,7 @@ push_replacement_text (cpp_reader *pfile, cpp_hashnode *node)\n       len = ustrlen (text);\n       buf = _cpp_unaligned_alloc (pfile, len + 1);\n       memcpy (buf, text, len);\n-      buf[len]='\\n';\n+      buf[len] = '\\n';\n       text = buf;\n     }\n   else\n@@ -742,7 +868,7 @@ recursive_macro (cpp_reader *pfile, cpp_hashnode *node)\n      detect true recursion; instead we assume any expansion more than\n      20 deep since the first invocation of this macro must be\n      recursing.  */\n-  if (recursing && node->value.macro->fun_like)\n+  if (recursing && fun_like_macro (node))\n     {\n       size_t depth = 0;\n       cpp_context *context = pfile->context;\n@@ -1080,7 +1206,7 @@ _cpp_create_trad_definition (cpp_reader *pfile, cpp_macro *macro)\n \t\t       CPP_OPTION (pfile, discard_comments_in_macro_exp));\n \n   pfile->state.prevent_expansion++;\n-  _cpp_scan_out_logical_line (pfile, macro);\n+  _cpp_scan_out_logical_line (pfile, macro, false);\n   pfile->state.prevent_expansion--;\n \n   if (!macro)"}]}