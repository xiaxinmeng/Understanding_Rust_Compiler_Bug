{"sha": "27312bf2148af2bea946fcec8f4c2e1231e8d63b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjczMTJiZjIxNDhhZjJiZWE5NDZmY2VjOGY0YzJlMTIzMWU4ZDYzYg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2018-05-25T13:08:28Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2018-05-25T13:08:28Z"}, "message": "tree-ssa-alias.h (refs_may_alias_p): Add tbaa_p bool parameter, defaulted to true.\n\n2018-05-25  Richard Biener  <rguenther@suse.de>\n\n\t* tree-ssa-alias.h (refs_may_alias_p): Add tbaa_p bool parameter,\n\tdefaulted to true.\n\t(ref_maybe_used_by_stmt_p): Likewise.\n\t(stmt_may_clobber_ref_p): Likewise.\n\t(stmt_may_clobber_ref_p_1): Likewise.\n\t* tree-ssa-alias.c (refs_may_alias_p): Add tbaa_p bool parameter\n\tand pass it along.\n\t(ref_maybe_used_by_stmt_p): Likewise.\n\t(stmt_may_clobber_ref_p): Likewise.\n\t(stmt_may_clobber_ref_p_1): Likewise.\n\t* tree-vect-data-refs.c (vect_slp_analyze_node_dependences): Use\n\tthe alias oracle to disambiguate DRs with stmts DR analysis\n\tcouldn't handle.\n\t(vect_analyze_data_refs): Do not give up on not analyzable\n\tDRs for BB vectorization.  Remove code truncating the dataref\n\tvector.\n\nFrom-SVN: r260757", "tree": {"sha": "f39e10cb0937194fe5afa1b80ccfc7c530de6755", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f39e10cb0937194fe5afa1b80ccfc7c530de6755"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/27312bf2148af2bea946fcec8f4c2e1231e8d63b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27312bf2148af2bea946fcec8f4c2e1231e8d63b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27312bf2148af2bea946fcec8f4c2e1231e8d63b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27312bf2148af2bea946fcec8f4c2e1231e8d63b/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b55f342bdd8bec16b727a5889c589dd85c5ca3c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b55f342bdd8bec16b727a5889c589dd85c5ca3c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b55f342bdd8bec16b727a5889c589dd85c5ca3c3"}], "stats": {"total": 111, "additions": 65, "deletions": 46}, "files": [{"sha": "7d38aeaa15b8b290a40a00cddcbd0b9bbac34e81", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27312bf2148af2bea946fcec8f4c2e1231e8d63b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27312bf2148af2bea946fcec8f4c2e1231e8d63b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=27312bf2148af2bea946fcec8f4c2e1231e8d63b", "patch": "@@ -1,3 +1,22 @@\n+2018-05-25  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-ssa-alias.h (refs_may_alias_p): Add tbaa_p bool parameter,\n+\tdefaulted to true.\n+\t(ref_maybe_used_by_stmt_p): Likewise.\n+\t(stmt_may_clobber_ref_p): Likewise.\n+\t(stmt_may_clobber_ref_p_1): Likewise.\n+\t* tree-ssa-alias.c (refs_may_alias_p): Add tbaa_p bool parameter\n+\tand pass it along.\n+\t(ref_maybe_used_by_stmt_p): Likewise.\n+\t(stmt_may_clobber_ref_p): Likewise.\n+\t(stmt_may_clobber_ref_p_1): Likewise.\n+\t* tree-vect-data-refs.c (vect_slp_analyze_node_dependences): Use\n+\tthe alias oracle to disambiguate DRs with stmts DR analysis\n+\tcouldn't handle.\n+\t(vect_analyze_data_refs): Do not give up on not analyzable\n+\tDRs for BB vectorization.  Remove code truncating the dataref\n+\tvector.\n+\n 2018-05-25  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/85832"}, {"sha": "7b25778307f900cb886ad60b5d41c0af6254de0d", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27312bf2148af2bea946fcec8f4c2e1231e8d63b/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27312bf2148af2bea946fcec8f4c2e1231e8d63b/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=27312bf2148af2bea946fcec8f4c2e1231e8d63b", "patch": "@@ -1509,21 +1509,21 @@ refs_may_alias_p_1 (ao_ref *ref1, ao_ref *ref2, bool tbaa_p)\n }\n \n static bool\n-refs_may_alias_p (tree ref1, ao_ref *ref2)\n+refs_may_alias_p (tree ref1, ao_ref *ref2, bool tbaa_p)\n {\n   ao_ref r1;\n   ao_ref_init (&r1, ref1);\n-  return refs_may_alias_p_1 (&r1, ref2, true);\n+  return refs_may_alias_p_1 (&r1, ref2, tbaa_p);\n }\n \n bool\n-refs_may_alias_p (tree ref1, tree ref2)\n+refs_may_alias_p (tree ref1, tree ref2, bool tbaa_p)\n {\n   ao_ref r1, r2;\n   bool res;\n   ao_ref_init (&r1, ref1);\n   ao_ref_init (&r2, ref2);\n-  res = refs_may_alias_p_1 (&r1, &r2, true);\n+  res = refs_may_alias_p_1 (&r1, &r2, tbaa_p);\n   if (res)\n     ++alias_stats.refs_may_alias_p_may_alias;\n   else\n@@ -1559,7 +1559,7 @@ refs_output_dependent_p (tree store1, tree store2)\n    otherwise return false.  */\n \n static bool\n-ref_maybe_used_by_call_p_1 (gcall *call, ao_ref *ref)\n+ref_maybe_used_by_call_p_1 (gcall *call, ao_ref *ref, bool tbaa_p)\n {\n   tree base, callee;\n   unsigned i;\n@@ -1860,7 +1860,7 @@ ref_maybe_used_by_call_p_1 (gcall *call, ao_ref *ref)\n \t{\n \t  ao_ref r;\n \t  ao_ref_init (&r, op);\n-\t  if (refs_may_alias_p_1 (&r, ref, true))\n+\t  if (refs_may_alias_p_1 (&r, ref, tbaa_p))\n \t    return true;\n \t}\n     }\n@@ -1869,10 +1869,10 @@ ref_maybe_used_by_call_p_1 (gcall *call, ao_ref *ref)\n }\n \n static bool\n-ref_maybe_used_by_call_p (gcall *call, ao_ref *ref)\n+ref_maybe_used_by_call_p (gcall *call, ao_ref *ref, bool tbaa_p)\n {\n   bool res;\n-  res = ref_maybe_used_by_call_p_1 (call, ref);\n+  res = ref_maybe_used_by_call_p_1 (call, ref, tbaa_p);\n   if (res)\n     ++alias_stats.ref_maybe_used_by_call_p_may_alias;\n   else\n@@ -1885,7 +1885,7 @@ ref_maybe_used_by_call_p (gcall *call, ao_ref *ref)\n    true, otherwise return false.  */\n \n bool\n-ref_maybe_used_by_stmt_p (gimple *stmt, ao_ref *ref)\n+ref_maybe_used_by_stmt_p (gimple *stmt, ao_ref *ref, bool tbaa_p)\n {\n   if (is_gimple_assign (stmt))\n     {\n@@ -1901,17 +1901,17 @@ ref_maybe_used_by_stmt_p (gimple *stmt, ao_ref *ref)\n \t  || gimple_assign_rhs_code (stmt) == CONSTRUCTOR)\n \treturn false;\n \n-      return refs_may_alias_p (rhs, ref);\n+      return refs_may_alias_p (rhs, ref, tbaa_p);\n     }\n   else if (is_gimple_call (stmt))\n-    return ref_maybe_used_by_call_p (as_a <gcall *> (stmt), ref);\n+    return ref_maybe_used_by_call_p (as_a <gcall *> (stmt), ref, tbaa_p);\n   else if (greturn *return_stmt = dyn_cast <greturn *> (stmt))\n     {\n       tree retval = gimple_return_retval (return_stmt);\n       if (retval\n \t  && TREE_CODE (retval) != SSA_NAME\n \t  && !is_gimple_min_invariant (retval)\n-\t  && refs_may_alias_p (retval, ref))\n+\t  && refs_may_alias_p (retval, ref, tbaa_p))\n \treturn true;\n       /* If ref escapes the function then the return acts as a use.  */\n       tree base = ao_ref_base (ref);\n@@ -1929,11 +1929,11 @@ ref_maybe_used_by_stmt_p (gimple *stmt, ao_ref *ref)\n }\n \n bool\n-ref_maybe_used_by_stmt_p (gimple *stmt, tree ref)\n+ref_maybe_used_by_stmt_p (gimple *stmt, tree ref, bool tbaa_p)\n {\n   ao_ref r;\n   ao_ref_init (&r, ref);\n-  return ref_maybe_used_by_stmt_p (stmt, &r);\n+  return ref_maybe_used_by_stmt_p (stmt, &r, tbaa_p);\n }\n \n /* If the call in statement CALL may clobber the memory reference REF\n@@ -2245,7 +2245,7 @@ call_may_clobber_ref_p (gcall *call, tree ref)\n    otherwise return false.  */\n \n bool\n-stmt_may_clobber_ref_p_1 (gimple *stmt, ao_ref *ref)\n+stmt_may_clobber_ref_p_1 (gimple *stmt, ao_ref *ref, bool tbaa_p)\n {\n   if (is_gimple_call (stmt))\n     {\n@@ -2255,7 +2255,7 @@ stmt_may_clobber_ref_p_1 (gimple *stmt, ao_ref *ref)\n \t{\n \t  ao_ref r;\n \t  ao_ref_init (&r, lhs);\n-\t  if (refs_may_alias_p_1 (ref, &r, true))\n+\t  if (refs_may_alias_p_1 (ref, &r, tbaa_p))\n \t    return true;\n \t}\n \n@@ -2268,7 +2268,7 @@ stmt_may_clobber_ref_p_1 (gimple *stmt, ao_ref *ref)\n \t{\n \t  ao_ref r;\n \t  ao_ref_init (&r, lhs);\n-\t  return refs_may_alias_p_1 (ref, &r, true);\n+\t  return refs_may_alias_p_1 (ref, &r, tbaa_p);\n \t}\n     }\n   else if (gimple_code (stmt) == GIMPLE_ASM)\n@@ -2278,11 +2278,11 @@ stmt_may_clobber_ref_p_1 (gimple *stmt, ao_ref *ref)\n }\n \n bool\n-stmt_may_clobber_ref_p (gimple *stmt, tree ref)\n+stmt_may_clobber_ref_p (gimple *stmt, tree ref, bool tbaa_p)\n {\n   ao_ref r;\n   ao_ref_init (&r, ref);\n-  return stmt_may_clobber_ref_p_1 (stmt, &r);\n+  return stmt_may_clobber_ref_p_1 (stmt, &r, tbaa_p);\n }\n \n /* Return true if store1 and store2 described by corresponding tuples"}, {"sha": "2ecc04d68fdaaf4423726635ecee8e84dd68a143", "filename": "gcc/tree-ssa-alias.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27312bf2148af2bea946fcec8f4c2e1231e8d63b/gcc%2Ftree-ssa-alias.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27312bf2148af2bea946fcec8f4c2e1231e8d63b/gcc%2Ftree-ssa-alias.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.h?ref=27312bf2148af2bea946fcec8f4c2e1231e8d63b", "patch": "@@ -118,15 +118,15 @@ extern bool ptr_derefs_may_alias_p (tree, tree);\n extern bool ptrs_compare_unequal (tree, tree);\n extern bool ref_may_alias_global_p (tree);\n extern bool ref_may_alias_global_p (ao_ref *);\n-extern bool refs_may_alias_p (tree, tree);\n+extern bool refs_may_alias_p (tree, tree, bool = true);\n extern bool refs_may_alias_p_1 (ao_ref *, ao_ref *, bool);\n extern bool refs_anti_dependent_p (tree, tree);\n extern bool refs_output_dependent_p (tree, tree);\n-extern bool ref_maybe_used_by_stmt_p (gimple *, tree);\n-extern bool ref_maybe_used_by_stmt_p (gimple *, ao_ref *);\n+extern bool ref_maybe_used_by_stmt_p (gimple *, tree, bool = true);\n+extern bool ref_maybe_used_by_stmt_p (gimple *, ao_ref *, bool = true);\n extern bool stmt_may_clobber_global_p (gimple *);\n-extern bool stmt_may_clobber_ref_p (gimple *, tree);\n-extern bool stmt_may_clobber_ref_p_1 (gimple *, ao_ref *);\n+extern bool stmt_may_clobber_ref_p (gimple *, tree, bool = true);\n+extern bool stmt_may_clobber_ref_p_1 (gimple *, ao_ref *, bool = true);\n extern bool call_may_clobber_ref_p (gcall *, tree);\n extern bool call_may_clobber_ref_p_1 (gcall *, ao_ref *);\n extern bool stmt_kills_ref_p (gimple *, tree);"}, {"sha": "331423af8215b864498afc44c527d85e3ce62110", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27312bf2148af2bea946fcec8f4c2e1231e8d63b/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27312bf2148af2bea946fcec8f4c2e1231e8d63b/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=27312bf2148af2bea946fcec8f4c2e1231e8d63b", "patch": "@@ -664,6 +664,8 @@ vect_slp_analyze_node_dependences (slp_instance instance, slp_tree node,\n       if (access == last_access)\n \tcontinue;\n       data_reference *dr_a = STMT_VINFO_DATA_REF (vinfo_for_stmt (access));\n+      ao_ref ref;\n+      bool ref_initialized_p = false;\n       for (gimple_stmt_iterator gsi = gsi_for_stmt (access);\n \t   gsi_stmt (gsi) != last_access; gsi_next (&gsi))\n \t{\n@@ -673,12 +675,19 @@ vect_slp_analyze_node_dependences (slp_instance instance, slp_tree node,\n \t    continue;\n \n \t  /* If we couldn't record a (single) data reference for this\n-\t     stmt we have to give up.  */\n-\t  /* ???  Here and below if dependence analysis fails we can resort\n-\t     to the alias oracle which can handle more kinds of stmts.  */\n+\t     stmt we have to resort to the alias oracle.  */\n \t  data_reference *dr_b = STMT_VINFO_DATA_REF (vinfo_for_stmt (stmt));\n \t  if (!dr_b)\n-\t    return false;\n+\t    {\n+\t      /* We are moving a store or sinking a load - this means\n+\t         we cannot use TBAA for disambiguation.  */\n+\t      if (!ref_initialized_p)\n+\t\tao_ref_init (&ref, DR_REF (dr_a));\n+\t      if (stmt_may_clobber_ref_p_1 (stmt, &ref, false)\n+\t\t  || ref_maybe_used_by_stmt_p (stmt, &ref, false))\n+\t\treturn false;\n+\t      continue;\n+\t    }\n \n \t  bool dependent = false;\n \t  /* If we run into a store of this same instance (we've just\n@@ -4183,10 +4192,13 @@ vect_analyze_data_refs (vec_info *vinfo, poly_uint64 *min_vf)\n                                    \"failed \");\n \t\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n \t\t}\n-\n \t      if (is_a <bb_vec_info> (vinfo))\n-\t\tbreak;\n-\n+\t\t{\n+\t\t  /* In BB vectorization the ref can still participate\n+\t\t     in dependence analysis, we just can't vectorize it.  */\n+\t\t  STMT_VINFO_VECTORIZABLE (stmt_info) = false;\n+\t\t  continue;\n+\t\t}\n \t      return false;\n \t    }\n         }\n@@ -4379,21 +4391,9 @@ vect_analyze_data_refs (vec_info *vinfo, poly_uint64 *min_vf)\n \t}\n     }\n \n-  /* If we stopped analysis at the first dataref we could not analyze\n-     when trying to vectorize a basic-block mark the rest of the datarefs\n-     as not vectorizable and truncate the vector of datarefs.  That\n-     avoids spending useless time in analyzing their dependence.  */\n-  if (i != datarefs.length ())\n-    {\n-      gcc_assert (is_a <bb_vec_info> (vinfo));\n-      for (unsigned j = i; j < datarefs.length (); ++j)\n-\t{\n-\t  data_reference_p dr = datarefs[j];\n-          STMT_VINFO_VECTORIZABLE (vinfo_for_stmt (DR_STMT (dr))) = false;\n-\t  free_data_ref (dr);\n-\t}\n-      datarefs.truncate (i);\n-    }\n+  /* We used to stop processing and prune the list here.  Verify we no\n+     longer need to.  */\n+  gcc_assert (i == datarefs.length ());\n \n   return true;\n }"}]}