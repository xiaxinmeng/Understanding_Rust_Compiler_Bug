{"sha": "6cf0040fff78a665db31a6a8dee60b12eef2e590", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmNmMDA0MGZmZjc4YTY2NWRiMzFhNmE4ZGVlNjBiMTJlZWYyZTU5MA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-06-21T12:35:18Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-06-21T17:29:58Z"}, "message": "libstdc++: Improve std::lock algorithm\n\nThe current std::lock algorithm is the one called \"persistent\" in Howard\nHinnant's https://howardhinnant.github.io/dining_philosophers.html post.\nWhile it tends to perform acceptably fast, it wastes a lot of CPU cycles\nby continuously locking and unlocking the uncontended mutexes.\nEffectively, it's a spin lock with no back-off.\n\nThis replaces it with the one Howard calls \"smart and polite\". It's\nsmart, because when a Mi.try_lock() call fails because mutex Mi is\ncontended, the algorithm reorders the mutexes until Mi is first, then\ncalls Mi.lock(), to block until Mi is no longer contended.  It's\npolite because it uses std::this_thread::yield() between the failed\nMi.try_lock() call and the Mi.lock() call. (In reality it uses\n__gthread_yield() directly, because using this_thread::yield() would\nrequire shuffling code around to avoid a circular dependency.)\n\nThis version of the algorithm is inspired by some hints from Howard, so\nthat it has strictly bounded stack usage. As the comment in the code\nsays:\n\n// This function can recurse up to N levels deep, for N = 1+sizeof...(L1).\n// On each recursion the lockables are rotated left one position,\n// e.g. depth 0: l0, l1, l2; depth 1: l1, l2, l0; depth 2: l2, l0, l1.\n// When a call to l_i.try_lock() fails it recurses/returns to depth=i\n// so that l_i is the first argument, and then blocks until l_i is locked.\n\nThe 'i' parameter is the desired permuation of the lockables, and the\n'depth' parameter is the depth in the call stack of the current\ninstantiation of the function template. If i == depth then the function\ncalls l0.lock() and then l1.try_lock()... for each lockable in the\nparameter pack l1.  If i > depth then the function rotates the lockables\nto the left one place, and calls itself again to go one level deeper.\nFinally, if i < depth then the function returns to a shallower depth,\nequivalent to a right rotate of the lockables.  When a call to\ntry_lock() fails, i is set to the index of the contended lockable, so\nthat the next call to l0.lock() will use the contended lockable as l0.\n\nThis commit also replaces the std::try_lock implementation details. The\nnew code is identical in behaviour, but uses a pair of constrained\nfunction templates. This avoids instantiating a class template, and is a\nlitle simpler to call where used in std::__detail::__lock_impl and\nstd::try_lock.\n\nSigned-off-by: Jonathan Wakely <jwakely@redhat.com>\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/std/mutex (__try_to_lock): Move to __detail namespace.\n\t(struct __try_lock_impl): Replace with ...\n\t(__detail::__try_lock_impl<Idx>(tuple<Lockables...>&)): New\n\tfunction templates to implement std::try_lock.\n\t(try_lock): Use new __try_lock_impl.\n\t(__detail::__lock_impl(int, int&, L0&, L1&...)): New function\n\ttemplate to implement std::lock.\n\t(lock): Use __lock_impl.", "tree": {"sha": "9594a2a491b85e5ae01cb125ba6146e0c0b87529", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9594a2a491b85e5ae01cb125ba6146e0c0b87529"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6cf0040fff78a665db31a6a8dee60b12eef2e590", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cf0040fff78a665db31a6a8dee60b12eef2e590", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6cf0040fff78a665db31a6a8dee60b12eef2e590", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cf0040fff78a665db31a6a8dee60b12eef2e590/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7232f7c4c2d727431096a7ecfcf4ad4db71dcf2a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7232f7c4c2d727431096a7ecfcf4ad4db71dcf2a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7232f7c4c2d727431096a7ecfcf4ad4db71dcf2a"}], "stats": {"total": 138, "additions": 82, "deletions": 56}, "files": [{"sha": "5f2d8f9ee7b6bb1283c8c5b10a1fdb74633b0340", "filename": "libstdc++-v3/include/std/mutex", "status": "modified", "additions": 82, "deletions": 56, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf0040fff78a665db31a6a8dee60b12eef2e590/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmutex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf0040fff78a665db31a6a8dee60b12eef2e590/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmutex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmutex?ref=6cf0040fff78a665db31a6a8dee60b12eef2e590", "patch": "@@ -512,47 +512,44 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n #endif // _GLIBCXX_HAS_GTHREADS\n \n   /// @cond undocumented\n-  template<typename _Lock>\n-    inline unique_lock<_Lock>\n-    __try_to_lock(_Lock& __l)\n-    { return unique_lock<_Lock>{__l, try_to_lock}; }\n+  namespace __detail\n+  {\n+    template<typename _Lockable>\n+      inline unique_lock<_Lockable>\n+      __try_to_lock(_Lockable& __l)\n+      { return unique_lock<_Lockable>{__l, try_to_lock}; }\n+\n+    // Lock the last element of the tuple, after all previous ones are locked.\n+    template<int _Idx, typename... _Lockables>\n+      inline __enable_if_t<_Idx + 1 == sizeof...(_Lockables), int>\n+      __try_lock_impl(tuple<_Lockables&...>& __lockables)\n+      {\n+\tif (auto __lock = __detail::__try_to_lock(std::get<_Idx>(__lockables)))\n+\t  {\n+\t    __lock.release();\n+\t    return -1;\n+\t  }\n+\telse\n+\t  return _Idx;\n+      }\n \n-  template<int _Idx, bool _Continue = true>\n-    struct __try_lock_impl\n-    {\n-      template<typename... _Lock>\n-\tstatic void\n-\t__do_try_lock(tuple<_Lock&...>& __locks, int& __idx)\n-\t{\n-          __idx = _Idx;\n-          auto __lock = std::__try_to_lock(std::get<_Idx>(__locks));\n-          if (__lock.owns_lock())\n-            {\n-\t      constexpr bool __cont = _Idx + 2 < sizeof...(_Lock);\n-\t      using __try_locker = __try_lock_impl<_Idx + 1, __cont>;\n-\t      __try_locker::__do_try_lock(__locks, __idx);\n-              if (__idx == -1)\n-                __lock.release();\n-            }\n-\t}\n-    };\n+    // Lock tuple elements starting from _Idx.\n+    template<int _Idx, typename... _Lockables>\n+      inline __enable_if_t<_Idx + 1 != sizeof...(_Lockables), int>\n+      __try_lock_impl(tuple<_Lockables&...>& __lockables)\n+      {\n+\tif (auto __lock = __detail::__try_to_lock(std::get<_Idx>(__lockables)))\n+\t  {\n+\t    int __idx = __detail::__try_lock_impl<_Idx + 1>(__lockables);\n+\t    if (__idx == -1)\n+\t      __lock.release();\n+\t    return __idx;\n+\t  }\n+\telse\n+\t  return _Idx;\n+      }\n \n-  template<int _Idx>\n-    struct __try_lock_impl<_Idx, false>\n-    {\n-      template<typename... _Lock>\n-\tstatic void\n-\t__do_try_lock(tuple<_Lock&...>& __locks, int& __idx)\n-\t{\n-          __idx = _Idx;\n-          auto __lock = std::__try_to_lock(std::get<_Idx>(__locks));\n-          if (__lock.owns_lock())\n-            {\n-              __idx = -1;\n-              __lock.release();\n-            }\n-\t}\n-    };\n+  } // namespace __detail\n   /// @endcond\n \n   /** @brief Generic try_lock.\n@@ -569,12 +566,52 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     int\n     try_lock(_Lock1& __l1, _Lock2& __l2, _Lock3&... __l3)\n     {\n-      int __idx;\n-      auto __locks = std::tie(__l1, __l2, __l3...);\n-      __try_lock_impl<0>::__do_try_lock(__locks, __idx);\n-      return __idx;\n+      auto __lockables = std::tie(__l1, __l2, __l3...);\n+      return __detail::__try_lock_impl<0>(__lockables);\n     }\n \n+  /// @cond undocumented\n+  namespace __detail\n+  {\n+    // This function can recurse up to N levels deep, for N = 1+sizeof...(L1).\n+    // On each recursion the lockables are rotated left one position,\n+    // e.g. depth 0: l0, l1, l2; depth 1: l1, l2, l0; depth 2: l2, l0, l1.\n+    // When a call to l_i.try_lock() fails it recurses/returns to depth=i\n+    // so that l_i is the first argument, and then blocks until l_i is locked.\n+    template<typename _L0, typename... _L1>\n+      void\n+      __lock_impl(int& __i, int __depth, _L0& __l0, _L1&... __l1)\n+      {\n+\twhile (__i >= __depth)\n+\t  {\n+\t    if (__i == __depth)\n+\t      {\n+\t\tint __failed = 1; // index that couldn't be locked\n+\t\t{\n+\t\t  unique_lock<_L0> __first(__l0);\n+\t\t  auto __rest = std::tie(__l1...);\n+\t\t  __failed += __detail::__try_lock_impl<0>(__rest);\n+\t\t  if (!__failed)\n+\t\t    {\n+\t\t      __i = -1; // finished\n+\t\t      __first.release();\n+\t\t      return;\n+\t\t    }\n+\t\t}\n+#ifdef _GLIBCXX_USE_SCHED_YIELD\n+\t\t__gthread_yield();\n+#endif\n+\t\tconstexpr auto __n = 1 + sizeof...(_L1);\n+\t\t__i = (__depth + __failed) % __n;\n+\t      }\n+\t    else // rotate left until l_i is first.\n+\t      __detail::__lock_impl(__i, __depth + 1, __l1..., __l0);\n+\t  }\n+      }\n+\n+  } // namespace __detail\n+  /// @endcond\n+\n   /** @brief Generic lock.\n    *  @param __l1 Meets Lockable requirements (try_lock() may throw).\n    *  @param __l2 Meets Lockable requirements (try_lock() may throw).\n@@ -590,19 +627,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     void\n     lock(_L1& __l1, _L2& __l2, _L3&... __l3)\n     {\n-      while (true)\n-        {\n-          using __try_locker = __try_lock_impl<0, sizeof...(_L3) != 0>;\n-          unique_lock<_L1> __first(__l1);\n-          int __idx;\n-          auto __locks = std::tie(__l2, __l3...);\n-          __try_locker::__do_try_lock(__locks, __idx);\n-          if (__idx == -1)\n-            {\n-              __first.release();\n-              return;\n-            }\n-        }\n+      int __i = 0;\n+      __detail::__lock_impl(__i, 0, __l1, __l2, __l3...);\n     }\n \n #if __cplusplus >= 201703L"}]}