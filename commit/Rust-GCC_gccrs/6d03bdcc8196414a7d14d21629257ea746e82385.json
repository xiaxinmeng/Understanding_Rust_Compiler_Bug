{"sha": "6d03bdcc8196414a7d14d21629257ea746e82385", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmQwM2JkY2M4MTk2NDE0YTdkMTRkMjE2MjkyNTdlYTc0NmU4MjM4NQ==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2017-03-02T11:04:01Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2017-03-02T11:04:01Z"}, "message": "re PR libfortran/78379 (Processor-specific versions for matmul)\n\n2017-03-02  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/78379\n\t* m4/matmul.m4: (matmul_'rtype_code`_avx2): Also generate for\n\treals.  Add fma to target options.\n\t(matmul_'rtype_code`):  Call AVX2 only if FMA is available.\n        * generated/matmul_c10.c: Regenerated.\n        * generated/matmul_c16.c: Regenerated.\n        * generated/matmul_c4.c: Regenerated.\n        * generated/matmul_c8.c: Regenerated.\n        * generated/matmul_i1.c: Regenerated.\n        * generated/matmul_i16.c: Regenerated.\n        * generated/matmul_i2.c: Regenerated.\n        * generated/matmul_i4.c: Regenerated.\n        * generated/matmul_i8.c: Regenerated.\n        * generated/matmul_r10.c: Regenerated.\n        * generated/matmul_r16.c: Regenerated.\n        * generated/matmul_r4.c: Regenerated.\n        * generated/matmul_r8.c: Regenerated.\n\nFrom-SVN: r245836", "tree": {"sha": "479218dbc398682ff55cd867e71940dd85a0c39e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/479218dbc398682ff55cd867e71940dd85a0c39e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6d03bdcc8196414a7d14d21629257ea746e82385", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d03bdcc8196414a7d14d21629257ea746e82385", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d03bdcc8196414a7d14d21629257ea746e82385", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d03bdcc8196414a7d14d21629257ea746e82385/comments", "author": null, "committer": null, "parents": [{"sha": "db9f7f657e035786836f8371b56d876a9bec46bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db9f7f657e035786836f8371b56d876a9bec46bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db9f7f657e035786836f8371b56d876a9bec46bc"}], "stats": {"total": 153, "additions": 62, "deletions": 91}, "files": [{"sha": "ec72c6daa84bac6c63591b4ec432dde2473d2acd", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d03bdcc8196414a7d14d21629257ea746e82385/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d03bdcc8196414a7d14d21629257ea746e82385/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=6d03bdcc8196414a7d14d21629257ea746e82385", "patch": "@@ -1,3 +1,23 @@\n+2017-03-02  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/78379\n+\t* m4/matmul.m4: (matmul_'rtype_code`_avx2): Also generate for\n+\treals.  Add fma to target options.\n+\t(matmul_'rtype_code`):  Call AVX2 only if FMA is available.\n+        * generated/matmul_c10.c: Regenerated.\n+        * generated/matmul_c16.c: Regenerated.\n+        * generated/matmul_c4.c: Regenerated.\n+        * generated/matmul_c8.c: Regenerated.\n+        * generated/matmul_i1.c: Regenerated.\n+        * generated/matmul_i16.c: Regenerated.\n+        * generated/matmul_i2.c: Regenerated.\n+        * generated/matmul_i4.c: Regenerated.\n+        * generated/matmul_i8.c: Regenerated.\n+        * generated/matmul_r10.c: Regenerated.\n+        * generated/matmul_r16.c: Regenerated.\n+        * generated/matmul_r4.c: Regenerated.\n+        * generated/matmul_r8.c: Regenerated.\n+\n 2017-02-27  Janne Blomqvist  <jb@gcc.gnu.org>\n \n \t* intrinsics/random.c (getosrandom): Don't try to use rand_s on"}, {"sha": "b333a844ea555c641692f19bd8f6fcf7ba7a3391", "filename": "libgfortran/generated/matmul_c10.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d03bdcc8196414a7d14d21629257ea746e82385/libgfortran%2Fgenerated%2Fmatmul_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d03bdcc8196414a7d14d21629257ea746e82385/libgfortran%2Fgenerated%2Fmatmul_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_c10.c?ref=6d03bdcc8196414a7d14d21629257ea746e82385", "patch": "@@ -74,9 +74,6 @@ extern void matmul_c10 (gfc_array_c10 * const restrict retarray,\n \tint blas_limit, blas_call gemm);\n export_proto(matmul_c10);\n \n-\n-\n-\n /* Put exhaustive list of possible architectures here here, ORed together.  */\n \n #if defined(HAVE_AVX) || defined(HAVE_AVX2) || defined(HAVE_AVX512F)\n@@ -628,7 +625,7 @@ matmul_c10_avx (gfc_array_c10 * const restrict retarray,\n static void\n matmul_c10_avx2 (gfc_array_c10 * const restrict retarray, \n \tgfc_array_c10 * const restrict a, gfc_array_c10 * const restrict b, int try_blas,\n-\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx2\")));\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx2,fma\")));\n static void\n matmul_c10_avx2 (gfc_array_c10 * const restrict retarray, \n \tgfc_array_c10 * const restrict a, gfc_array_c10 * const restrict b, int try_blas,\n@@ -2277,7 +2274,8 @@ void matmul_c10 (gfc_array_c10 * const restrict retarray,\n #endif  /* HAVE_AVX512F */\n \n #ifdef HAVE_AVX2\n-      \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX2))\n+      \t  if ((__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX2))\n+\t     && (__cpu_model.__cpu_features[0] & (1 << FEATURE_FMA)))\n \t    {\n \t      matmul_p = matmul_c10_avx2;\n \t      goto tailcall;"}, {"sha": "0ef66c0f4a2c167b45ad9d4e4fe01a7841d9afdc", "filename": "libgfortran/generated/matmul_c16.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d03bdcc8196414a7d14d21629257ea746e82385/libgfortran%2Fgenerated%2Fmatmul_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d03bdcc8196414a7d14d21629257ea746e82385/libgfortran%2Fgenerated%2Fmatmul_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_c16.c?ref=6d03bdcc8196414a7d14d21629257ea746e82385", "patch": "@@ -74,9 +74,6 @@ extern void matmul_c16 (gfc_array_c16 * const restrict retarray,\n \tint blas_limit, blas_call gemm);\n export_proto(matmul_c16);\n \n-\n-\n-\n /* Put exhaustive list of possible architectures here here, ORed together.  */\n \n #if defined(HAVE_AVX) || defined(HAVE_AVX2) || defined(HAVE_AVX512F)\n@@ -628,7 +625,7 @@ matmul_c16_avx (gfc_array_c16 * const restrict retarray,\n static void\n matmul_c16_avx2 (gfc_array_c16 * const restrict retarray, \n \tgfc_array_c16 * const restrict a, gfc_array_c16 * const restrict b, int try_blas,\n-\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx2\")));\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx2,fma\")));\n static void\n matmul_c16_avx2 (gfc_array_c16 * const restrict retarray, \n \tgfc_array_c16 * const restrict a, gfc_array_c16 * const restrict b, int try_blas,\n@@ -2277,7 +2274,8 @@ void matmul_c16 (gfc_array_c16 * const restrict retarray,\n #endif  /* HAVE_AVX512F */\n \n #ifdef HAVE_AVX2\n-      \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX2))\n+      \t  if ((__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX2))\n+\t     && (__cpu_model.__cpu_features[0] & (1 << FEATURE_FMA)))\n \t    {\n \t      matmul_p = matmul_c16_avx2;\n \t      goto tailcall;"}, {"sha": "b30320b37ae15a684c58aa11e29c9a84ba9c57ca", "filename": "libgfortran/generated/matmul_c4.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d03bdcc8196414a7d14d21629257ea746e82385/libgfortran%2Fgenerated%2Fmatmul_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d03bdcc8196414a7d14d21629257ea746e82385/libgfortran%2Fgenerated%2Fmatmul_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_c4.c?ref=6d03bdcc8196414a7d14d21629257ea746e82385", "patch": "@@ -74,9 +74,6 @@ extern void matmul_c4 (gfc_array_c4 * const restrict retarray,\n \tint blas_limit, blas_call gemm);\n export_proto(matmul_c4);\n \n-\n-\n-\n /* Put exhaustive list of possible architectures here here, ORed together.  */\n \n #if defined(HAVE_AVX) || defined(HAVE_AVX2) || defined(HAVE_AVX512F)\n@@ -628,7 +625,7 @@ matmul_c4_avx (gfc_array_c4 * const restrict retarray,\n static void\n matmul_c4_avx2 (gfc_array_c4 * const restrict retarray, \n \tgfc_array_c4 * const restrict a, gfc_array_c4 * const restrict b, int try_blas,\n-\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx2\")));\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx2,fma\")));\n static void\n matmul_c4_avx2 (gfc_array_c4 * const restrict retarray, \n \tgfc_array_c4 * const restrict a, gfc_array_c4 * const restrict b, int try_blas,\n@@ -2277,7 +2274,8 @@ void matmul_c4 (gfc_array_c4 * const restrict retarray,\n #endif  /* HAVE_AVX512F */\n \n #ifdef HAVE_AVX2\n-      \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX2))\n+      \t  if ((__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX2))\n+\t     && (__cpu_model.__cpu_features[0] & (1 << FEATURE_FMA)))\n \t    {\n \t      matmul_p = matmul_c4_avx2;\n \t      goto tailcall;"}, {"sha": "75b4680c3a0a77a07e54769545f1e59b12f43304", "filename": "libgfortran/generated/matmul_c8.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d03bdcc8196414a7d14d21629257ea746e82385/libgfortran%2Fgenerated%2Fmatmul_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d03bdcc8196414a7d14d21629257ea746e82385/libgfortran%2Fgenerated%2Fmatmul_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_c8.c?ref=6d03bdcc8196414a7d14d21629257ea746e82385", "patch": "@@ -74,9 +74,6 @@ extern void matmul_c8 (gfc_array_c8 * const restrict retarray,\n \tint blas_limit, blas_call gemm);\n export_proto(matmul_c8);\n \n-\n-\n-\n /* Put exhaustive list of possible architectures here here, ORed together.  */\n \n #if defined(HAVE_AVX) || defined(HAVE_AVX2) || defined(HAVE_AVX512F)\n@@ -628,7 +625,7 @@ matmul_c8_avx (gfc_array_c8 * const restrict retarray,\n static void\n matmul_c8_avx2 (gfc_array_c8 * const restrict retarray, \n \tgfc_array_c8 * const restrict a, gfc_array_c8 * const restrict b, int try_blas,\n-\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx2\")));\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx2,fma\")));\n static void\n matmul_c8_avx2 (gfc_array_c8 * const restrict retarray, \n \tgfc_array_c8 * const restrict a, gfc_array_c8 * const restrict b, int try_blas,\n@@ -2277,7 +2274,8 @@ void matmul_c8 (gfc_array_c8 * const restrict retarray,\n #endif  /* HAVE_AVX512F */\n \n #ifdef HAVE_AVX2\n-      \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX2))\n+      \t  if ((__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX2))\n+\t     && (__cpu_model.__cpu_features[0] & (1 << FEATURE_FMA)))\n \t    {\n \t      matmul_p = matmul_c8_avx2;\n \t      goto tailcall;"}, {"sha": "924826338d8d909b125f4e0f4c0da1a6ce95f3e0", "filename": "libgfortran/generated/matmul_i1.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d03bdcc8196414a7d14d21629257ea746e82385/libgfortran%2Fgenerated%2Fmatmul_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d03bdcc8196414a7d14d21629257ea746e82385/libgfortran%2Fgenerated%2Fmatmul_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_i1.c?ref=6d03bdcc8196414a7d14d21629257ea746e82385", "patch": "@@ -74,9 +74,6 @@ extern void matmul_i1 (gfc_array_i1 * const restrict retarray,\n \tint blas_limit, blas_call gemm);\n export_proto(matmul_i1);\n \n-\n-\n-\n /* Put exhaustive list of possible architectures here here, ORed together.  */\n \n #if defined(HAVE_AVX) || defined(HAVE_AVX2) || defined(HAVE_AVX512F)\n@@ -628,7 +625,7 @@ matmul_i1_avx (gfc_array_i1 * const restrict retarray,\n static void\n matmul_i1_avx2 (gfc_array_i1 * const restrict retarray, \n \tgfc_array_i1 * const restrict a, gfc_array_i1 * const restrict b, int try_blas,\n-\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx2\")));\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx2,fma\")));\n static void\n matmul_i1_avx2 (gfc_array_i1 * const restrict retarray, \n \tgfc_array_i1 * const restrict a, gfc_array_i1 * const restrict b, int try_blas,\n@@ -2277,7 +2274,8 @@ void matmul_i1 (gfc_array_i1 * const restrict retarray,\n #endif  /* HAVE_AVX512F */\n \n #ifdef HAVE_AVX2\n-      \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX2))\n+      \t  if ((__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX2))\n+\t     && (__cpu_model.__cpu_features[0] & (1 << FEATURE_FMA)))\n \t    {\n \t      matmul_p = matmul_i1_avx2;\n \t      goto tailcall;"}, {"sha": "f10540ed48a1daca20d61bf8869bb464bf9527a4", "filename": "libgfortran/generated/matmul_i16.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d03bdcc8196414a7d14d21629257ea746e82385/libgfortran%2Fgenerated%2Fmatmul_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d03bdcc8196414a7d14d21629257ea746e82385/libgfortran%2Fgenerated%2Fmatmul_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_i16.c?ref=6d03bdcc8196414a7d14d21629257ea746e82385", "patch": "@@ -74,9 +74,6 @@ extern void matmul_i16 (gfc_array_i16 * const restrict retarray,\n \tint blas_limit, blas_call gemm);\n export_proto(matmul_i16);\n \n-\n-\n-\n /* Put exhaustive list of possible architectures here here, ORed together.  */\n \n #if defined(HAVE_AVX) || defined(HAVE_AVX2) || defined(HAVE_AVX512F)\n@@ -628,7 +625,7 @@ matmul_i16_avx (gfc_array_i16 * const restrict retarray,\n static void\n matmul_i16_avx2 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i16 * const restrict a, gfc_array_i16 * const restrict b, int try_blas,\n-\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx2\")));\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx2,fma\")));\n static void\n matmul_i16_avx2 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i16 * const restrict a, gfc_array_i16 * const restrict b, int try_blas,\n@@ -2277,7 +2274,8 @@ void matmul_i16 (gfc_array_i16 * const restrict retarray,\n #endif  /* HAVE_AVX512F */\n \n #ifdef HAVE_AVX2\n-      \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX2))\n+      \t  if ((__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX2))\n+\t     && (__cpu_model.__cpu_features[0] & (1 << FEATURE_FMA)))\n \t    {\n \t      matmul_p = matmul_i16_avx2;\n \t      goto tailcall;"}, {"sha": "55ad5c614e66eee2825f1be0212a9b1b30f6cbe9", "filename": "libgfortran/generated/matmul_i2.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d03bdcc8196414a7d14d21629257ea746e82385/libgfortran%2Fgenerated%2Fmatmul_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d03bdcc8196414a7d14d21629257ea746e82385/libgfortran%2Fgenerated%2Fmatmul_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_i2.c?ref=6d03bdcc8196414a7d14d21629257ea746e82385", "patch": "@@ -74,9 +74,6 @@ extern void matmul_i2 (gfc_array_i2 * const restrict retarray,\n \tint blas_limit, blas_call gemm);\n export_proto(matmul_i2);\n \n-\n-\n-\n /* Put exhaustive list of possible architectures here here, ORed together.  */\n \n #if defined(HAVE_AVX) || defined(HAVE_AVX2) || defined(HAVE_AVX512F)\n@@ -628,7 +625,7 @@ matmul_i2_avx (gfc_array_i2 * const restrict retarray,\n static void\n matmul_i2_avx2 (gfc_array_i2 * const restrict retarray, \n \tgfc_array_i2 * const restrict a, gfc_array_i2 * const restrict b, int try_blas,\n-\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx2\")));\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx2,fma\")));\n static void\n matmul_i2_avx2 (gfc_array_i2 * const restrict retarray, \n \tgfc_array_i2 * const restrict a, gfc_array_i2 * const restrict b, int try_blas,\n@@ -2277,7 +2274,8 @@ void matmul_i2 (gfc_array_i2 * const restrict retarray,\n #endif  /* HAVE_AVX512F */\n \n #ifdef HAVE_AVX2\n-      \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX2))\n+      \t  if ((__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX2))\n+\t     && (__cpu_model.__cpu_features[0] & (1 << FEATURE_FMA)))\n \t    {\n \t      matmul_p = matmul_i2_avx2;\n \t      goto tailcall;"}, {"sha": "97b4a5b6aa0889383561aa0547d5aa8cb2432538", "filename": "libgfortran/generated/matmul_i4.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d03bdcc8196414a7d14d21629257ea746e82385/libgfortran%2Fgenerated%2Fmatmul_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d03bdcc8196414a7d14d21629257ea746e82385/libgfortran%2Fgenerated%2Fmatmul_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_i4.c?ref=6d03bdcc8196414a7d14d21629257ea746e82385", "patch": "@@ -74,9 +74,6 @@ extern void matmul_i4 (gfc_array_i4 * const restrict retarray,\n \tint blas_limit, blas_call gemm);\n export_proto(matmul_i4);\n \n-\n-\n-\n /* Put exhaustive list of possible architectures here here, ORed together.  */\n \n #if defined(HAVE_AVX) || defined(HAVE_AVX2) || defined(HAVE_AVX512F)\n@@ -628,7 +625,7 @@ matmul_i4_avx (gfc_array_i4 * const restrict retarray,\n static void\n matmul_i4_avx2 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i4 * const restrict a, gfc_array_i4 * const restrict b, int try_blas,\n-\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx2\")));\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx2,fma\")));\n static void\n matmul_i4_avx2 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i4 * const restrict a, gfc_array_i4 * const restrict b, int try_blas,\n@@ -2277,7 +2274,8 @@ void matmul_i4 (gfc_array_i4 * const restrict retarray,\n #endif  /* HAVE_AVX512F */\n \n #ifdef HAVE_AVX2\n-      \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX2))\n+      \t  if ((__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX2))\n+\t     && (__cpu_model.__cpu_features[0] & (1 << FEATURE_FMA)))\n \t    {\n \t      matmul_p = matmul_i4_avx2;\n \t      goto tailcall;"}, {"sha": "ae78ecfccb68af32deaab2aa38915d3b33d10c49", "filename": "libgfortran/generated/matmul_i8.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d03bdcc8196414a7d14d21629257ea746e82385/libgfortran%2Fgenerated%2Fmatmul_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d03bdcc8196414a7d14d21629257ea746e82385/libgfortran%2Fgenerated%2Fmatmul_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_i8.c?ref=6d03bdcc8196414a7d14d21629257ea746e82385", "patch": "@@ -74,9 +74,6 @@ extern void matmul_i8 (gfc_array_i8 * const restrict retarray,\n \tint blas_limit, blas_call gemm);\n export_proto(matmul_i8);\n \n-\n-\n-\n /* Put exhaustive list of possible architectures here here, ORed together.  */\n \n #if defined(HAVE_AVX) || defined(HAVE_AVX2) || defined(HAVE_AVX512F)\n@@ -628,7 +625,7 @@ matmul_i8_avx (gfc_array_i8 * const restrict retarray,\n static void\n matmul_i8_avx2 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i8 * const restrict a, gfc_array_i8 * const restrict b, int try_blas,\n-\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx2\")));\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx2,fma\")));\n static void\n matmul_i8_avx2 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i8 * const restrict a, gfc_array_i8 * const restrict b, int try_blas,\n@@ -2277,7 +2274,8 @@ void matmul_i8 (gfc_array_i8 * const restrict retarray,\n #endif  /* HAVE_AVX512F */\n \n #ifdef HAVE_AVX2\n-      \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX2))\n+      \t  if ((__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX2))\n+\t     && (__cpu_model.__cpu_features[0] & (1 << FEATURE_FMA)))\n \t    {\n \t      matmul_p = matmul_i8_avx2;\n \t      goto tailcall;"}, {"sha": "11d059198c92b0f1dfb0483145d040f5567bf2b9", "filename": "libgfortran/generated/matmul_r10.c", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d03bdcc8196414a7d14d21629257ea746e82385/libgfortran%2Fgenerated%2Fmatmul_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d03bdcc8196414a7d14d21629257ea746e82385/libgfortran%2Fgenerated%2Fmatmul_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_r10.c?ref=6d03bdcc8196414a7d14d21629257ea746e82385", "patch": "@@ -74,13 +74,6 @@ extern void matmul_r10 (gfc_array_r10 * const restrict retarray,\n \tint blas_limit, blas_call gemm);\n export_proto(matmul_r10);\n \n-#if defined(HAVE_AVX) && defined(HAVE_AVX2)\n-/* REAL types generate identical code for AVX and AVX2.  Only generate\n-   an AVX2 function if we are dealing with integer.  */\n-#undef HAVE_AVX2\n-#endif\n-\n-\n /* Put exhaustive list of possible architectures here here, ORed together.  */\n \n #if defined(HAVE_AVX) || defined(HAVE_AVX2) || defined(HAVE_AVX512F)\n@@ -632,7 +625,7 @@ matmul_r10_avx (gfc_array_r10 * const restrict retarray,\n static void\n matmul_r10_avx2 (gfc_array_r10 * const restrict retarray, \n \tgfc_array_r10 * const restrict a, gfc_array_r10 * const restrict b, int try_blas,\n-\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx2\")));\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx2,fma\")));\n static void\n matmul_r10_avx2 (gfc_array_r10 * const restrict retarray, \n \tgfc_array_r10 * const restrict a, gfc_array_r10 * const restrict b, int try_blas,\n@@ -2281,7 +2274,8 @@ void matmul_r10 (gfc_array_r10 * const restrict retarray,\n #endif  /* HAVE_AVX512F */\n \n #ifdef HAVE_AVX2\n-      \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX2))\n+      \t  if ((__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX2))\n+\t     && (__cpu_model.__cpu_features[0] & (1 << FEATURE_FMA)))\n \t    {\n \t      matmul_p = matmul_r10_avx2;\n \t      goto tailcall;"}, {"sha": "73e7c9877adf09c4ff13f593aa44e0c478266f49", "filename": "libgfortran/generated/matmul_r16.c", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d03bdcc8196414a7d14d21629257ea746e82385/libgfortran%2Fgenerated%2Fmatmul_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d03bdcc8196414a7d14d21629257ea746e82385/libgfortran%2Fgenerated%2Fmatmul_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_r16.c?ref=6d03bdcc8196414a7d14d21629257ea746e82385", "patch": "@@ -74,13 +74,6 @@ extern void matmul_r16 (gfc_array_r16 * const restrict retarray,\n \tint blas_limit, blas_call gemm);\n export_proto(matmul_r16);\n \n-#if defined(HAVE_AVX) && defined(HAVE_AVX2)\n-/* REAL types generate identical code for AVX and AVX2.  Only generate\n-   an AVX2 function if we are dealing with integer.  */\n-#undef HAVE_AVX2\n-#endif\n-\n-\n /* Put exhaustive list of possible architectures here here, ORed together.  */\n \n #if defined(HAVE_AVX) || defined(HAVE_AVX2) || defined(HAVE_AVX512F)\n@@ -632,7 +625,7 @@ matmul_r16_avx (gfc_array_r16 * const restrict retarray,\n static void\n matmul_r16_avx2 (gfc_array_r16 * const restrict retarray, \n \tgfc_array_r16 * const restrict a, gfc_array_r16 * const restrict b, int try_blas,\n-\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx2\")));\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx2,fma\")));\n static void\n matmul_r16_avx2 (gfc_array_r16 * const restrict retarray, \n \tgfc_array_r16 * const restrict a, gfc_array_r16 * const restrict b, int try_blas,\n@@ -2281,7 +2274,8 @@ void matmul_r16 (gfc_array_r16 * const restrict retarray,\n #endif  /* HAVE_AVX512F */\n \n #ifdef HAVE_AVX2\n-      \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX2))\n+      \t  if ((__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX2))\n+\t     && (__cpu_model.__cpu_features[0] & (1 << FEATURE_FMA)))\n \t    {\n \t      matmul_p = matmul_r16_avx2;\n \t      goto tailcall;"}, {"sha": "ac7306fe035f8830c4475b85aba2e00355c8c443", "filename": "libgfortran/generated/matmul_r4.c", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d03bdcc8196414a7d14d21629257ea746e82385/libgfortran%2Fgenerated%2Fmatmul_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d03bdcc8196414a7d14d21629257ea746e82385/libgfortran%2Fgenerated%2Fmatmul_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_r4.c?ref=6d03bdcc8196414a7d14d21629257ea746e82385", "patch": "@@ -74,13 +74,6 @@ extern void matmul_r4 (gfc_array_r4 * const restrict retarray,\n \tint blas_limit, blas_call gemm);\n export_proto(matmul_r4);\n \n-#if defined(HAVE_AVX) && defined(HAVE_AVX2)\n-/* REAL types generate identical code for AVX and AVX2.  Only generate\n-   an AVX2 function if we are dealing with integer.  */\n-#undef HAVE_AVX2\n-#endif\n-\n-\n /* Put exhaustive list of possible architectures here here, ORed together.  */\n \n #if defined(HAVE_AVX) || defined(HAVE_AVX2) || defined(HAVE_AVX512F)\n@@ -632,7 +625,7 @@ matmul_r4_avx (gfc_array_r4 * const restrict retarray,\n static void\n matmul_r4_avx2 (gfc_array_r4 * const restrict retarray, \n \tgfc_array_r4 * const restrict a, gfc_array_r4 * const restrict b, int try_blas,\n-\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx2\")));\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx2,fma\")));\n static void\n matmul_r4_avx2 (gfc_array_r4 * const restrict retarray, \n \tgfc_array_r4 * const restrict a, gfc_array_r4 * const restrict b, int try_blas,\n@@ -2281,7 +2274,8 @@ void matmul_r4 (gfc_array_r4 * const restrict retarray,\n #endif  /* HAVE_AVX512F */\n \n #ifdef HAVE_AVX2\n-      \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX2))\n+      \t  if ((__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX2))\n+\t     && (__cpu_model.__cpu_features[0] & (1 << FEATURE_FMA)))\n \t    {\n \t      matmul_p = matmul_r4_avx2;\n \t      goto tailcall;"}, {"sha": "8d2e784de60753f209e94c4c7c34211c5e56d1d4", "filename": "libgfortran/generated/matmul_r8.c", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d03bdcc8196414a7d14d21629257ea746e82385/libgfortran%2Fgenerated%2Fmatmul_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d03bdcc8196414a7d14d21629257ea746e82385/libgfortran%2Fgenerated%2Fmatmul_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_r8.c?ref=6d03bdcc8196414a7d14d21629257ea746e82385", "patch": "@@ -74,13 +74,6 @@ extern void matmul_r8 (gfc_array_r8 * const restrict retarray,\n \tint blas_limit, blas_call gemm);\n export_proto(matmul_r8);\n \n-#if defined(HAVE_AVX) && defined(HAVE_AVX2)\n-/* REAL types generate identical code for AVX and AVX2.  Only generate\n-   an AVX2 function if we are dealing with integer.  */\n-#undef HAVE_AVX2\n-#endif\n-\n-\n /* Put exhaustive list of possible architectures here here, ORed together.  */\n \n #if defined(HAVE_AVX) || defined(HAVE_AVX2) || defined(HAVE_AVX512F)\n@@ -632,7 +625,7 @@ matmul_r8_avx (gfc_array_r8 * const restrict retarray,\n static void\n matmul_r8_avx2 (gfc_array_r8 * const restrict retarray, \n \tgfc_array_r8 * const restrict a, gfc_array_r8 * const restrict b, int try_blas,\n-\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx2\")));\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx2,fma\")));\n static void\n matmul_r8_avx2 (gfc_array_r8 * const restrict retarray, \n \tgfc_array_r8 * const restrict a, gfc_array_r8 * const restrict b, int try_blas,\n@@ -2281,7 +2274,8 @@ void matmul_r8 (gfc_array_r8 * const restrict retarray,\n #endif  /* HAVE_AVX512F */\n \n #ifdef HAVE_AVX2\n-      \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX2))\n+      \t  if ((__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX2))\n+\t     && (__cpu_model.__cpu_features[0] & (1 << FEATURE_FMA)))\n \t    {\n \t      matmul_p = matmul_r8_avx2;\n \t      goto tailcall;"}, {"sha": "812a7e7e5714f2c741d051d1dfd486f61baa5327", "filename": "libgfortran/m4/matmul.m4", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d03bdcc8196414a7d14d21629257ea746e82385/libgfortran%2Fm4%2Fmatmul.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d03bdcc8196414a7d14d21629257ea746e82385/libgfortran%2Fm4%2Fmatmul.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fmatmul.m4?ref=6d03bdcc8196414a7d14d21629257ea746e82385", "patch": "@@ -75,14 +75,6 @@ extern void matmul_'rtype_code` ('rtype` * const restrict retarray,\n \tint blas_limit, blas_call gemm);\n export_proto(matmul_'rtype_code`);\n \n-'ifelse(rtype_letter,`r',dnl\n-`#if defined(HAVE_AVX) && defined(HAVE_AVX2)\n-/* REAL types generate identical code for AVX and AVX2.  Only generate\n-   an AVX2 function if we are dealing with integer.  */\n-#undef HAVE_AVX2\n-#endif')\n-`\n-\n /* Put exhaustive list of possible architectures here here, ORed together.  */\n \n #if defined(HAVE_AVX) || defined(HAVE_AVX2) || defined(HAVE_AVX512F)\n@@ -101,7 +93,7 @@ static' include(matmul_internal.m4)dnl\n `static void\n 'matmul_name` ('rtype` * const restrict retarray, \n \t'rtype` * const restrict a, 'rtype` * const restrict b, int try_blas,\n-\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx2\")));\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx2,fma\")));\n static' include(matmul_internal.m4)dnl\n `#endif /* HAVE_AVX2 */\n \n@@ -147,7 +139,8 @@ void matmul_'rtype_code` ('rtype` * const restrict retarray,\n #endif  /* HAVE_AVX512F */\n \n #ifdef HAVE_AVX2\n-      \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX2))\n+      \t  if ((__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX2))\n+\t     && (__cpu_model.__cpu_features[0] & (1 << FEATURE_FMA)))\n \t    {\n \t      matmul_p = matmul_'rtype_code`_avx2;\n \t      goto tailcall;"}]}