{"sha": "0e61db61a0d66106ef00396aa04871d94021ddef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGU2MWRiNjFhMGQ2NjEwNmVmMDAzOTZhYTA0ODcxZDk0MDIxZGRlZg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2005-04-21T18:05:34Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2005-04-21T18:05:34Z"}, "message": "lambda.h (lambda_vector_min_nz): Likewise.\n\n\t* lambda.h (lambda_vector_min_nz): Likewise.\n\t* langhooks.h (struct lang_hooks_for_types,\n\tstruct lang_hooks): Likewise.\n\t* output.h (assemble_integer, this_is_asm_operands): Likewise.\n\t* tree.h: Likewise.\n\t* vec.h: Likewise.\n\t* tree-flow-inline.h (relink_imm_use): Use gcc_assert.\n\n\t* optabs.c (prepare_cmp_insn, emit_cmp_and_jump_insns): Reword\n\tcomments to avoid 'abort'.  Use gcc_assert as necessary.\n\t* opts.c (common_handle_option): Likewise.\n\t* pretty-print.c (pp_base_format_text): Likewise.\n\t* print-rtl.c (print_rtx): Likewise.\n\t* read-rtl.c (read_rtx_filename, read_rtx_1): Likewise.\n\t* regmove.c (try_auto_increment): Likewise.\n\t* reload.c (find_valid_class, find_reloads_toplev,\n\tfind_equiv_reg): Likewise.\n\t* reload1.c (reload, forget_old_reloads_1, function_invariant_p,\n\tmerge_assigned_reloads): Likewise.\n\t* tree-inline.c (inline_forbidden_p_1,\n\testimate_num_insns_1): Likewise.\n\t* tree-optimize.c (execute_todo): Likewise.\n\t* tree-outof-ssa.c (eliminate_phi): Likewise.\n\t* tree-ssa-alias.c (add_pointed_to_expr): Likewise.\n\t* tree-ssa-ccp.c (maybe_fold_stmt_indirect): Likewise.\n\t* tree-ssa-operands.c (parse_ssa_operands,\n\tget_indirect_ref_operands, create_ssa_artficial_load_stmt): Likewise.\n\t* tree-ssa-pre.c (find_or_generate_expression): Likewise.\n\t* tree-ssanames.c (release_ssa_name): Likewise.\n\t* tree.c (int_bit_position, int_byte_position, tree_low_cst,\n\twalk_tree): Likewise.\n\n\t* tree-ssa-operands.c (verify_abort): Fold into ..\n\t(verify_imm_links): ... here.\n\nFrom-SVN: r98519", "tree": {"sha": "a6170c4a24e29bff50c537b8652482d6d413b2a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a6170c4a24e29bff50c537b8652482d6d413b2a3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e61db61a0d66106ef00396aa04871d94021ddef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e61db61a0d66106ef00396aa04871d94021ddef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e61db61a0d66106ef00396aa04871d94021ddef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e61db61a0d66106ef00396aa04871d94021ddef/comments", "author": null, "committer": null, "parents": [{"sha": "7fc785d836a38912e6c48045fa7380f6e9e1c5c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fc785d836a38912e6c48045fa7380f6e9e1c5c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7fc785d836a38912e6c48045fa7380f6e9e1c5c1"}], "stats": {"total": 316, "additions": 143, "deletions": 173}, "files": [{"sha": "811ff1deb610cf56c8bb24b87d98ed0c98706e2c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 38, "deletions": 2, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e61db61a0d66106ef00396aa04871d94021ddef/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e61db61a0d66106ef00396aa04871d94021ddef/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0e61db61a0d66106ef00396aa04871d94021ddef", "patch": "@@ -1,3 +1,41 @@\n+2005-04-21  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* cfghooks.h (struct cfg_hooks): Reword comments to avoid 'abort'.\n+\t* lambda.h (lambda_vector_min_nz): Likewise.\n+\t* langhooks.h (struct lang_hooks_for_types,\n+\tstruct lang_hooks): Likewise.\n+\t* output.h (assemble_integer, this_is_asm_operands): Likewise.\n+\t* tree.h: Likewise.\n+\t* vec.h: Likewise.\n+\t* tree-flow-inline.h (relink_imm_use): Use gcc_assert.\n+\t\n+\t* optabs.c (prepare_cmp_insn, emit_cmp_and_jump_insns): Reword\n+\tcomments to avoid 'abort'.  Use gcc_assert as necessary.\n+\t* opts.c (common_handle_option): Likewise.\n+\t* pretty-print.c (pp_base_format_text): Likewise.\n+\t* print-rtl.c (print_rtx): Likewise.\n+\t* read-rtl.c (read_rtx_filename, read_rtx_1): Likewise.\n+\t* regmove.c (try_auto_increment): Likewise.\n+\t* reload.c (find_valid_class, find_reloads_toplev,\n+\tfind_equiv_reg): Likewise.\n+\t* reload1.c (reload, forget_old_reloads_1, function_invariant_p, \n+\tmerge_assigned_reloads): Likewise.\n+\t* tree-inline.c (inline_forbidden_p_1,\n+\testimate_num_insns_1): Likewise.\n+\t* tree-optimize.c (execute_todo): Likewise.\n+\t* tree-outof-ssa.c (eliminate_phi): Likewise.\n+\t* tree-ssa-alias.c (add_pointed_to_expr): Likewise.\n+\t* tree-ssa-ccp.c (maybe_fold_stmt_indirect): Likewise.\n+\t* tree-ssa-operands.c (parse_ssa_operands,\n+\tget_indirect_ref_operands, create_ssa_artficial_load_stmt): Likewise.\n+\t* tree-ssa-pre.c (find_or_generate_expression): Likewise.\n+\t* tree-ssanames.c (release_ssa_name): Likewise.\n+\t* tree.c (int_bit_position, int_byte_position, tree_low_cst, \n+\twalk_tree): Likewise.\n+\n+\t* tree-ssa-operands.c (verify_abort): Fold into ..\n+\t(verify_imm_links): ... here.\n+\n 2005-04-21  Richard Henderson  <rth@redhat.com>\n \n \t* config/alpha/sync.md (sync_new_nand<I48MODE>): Fix constraints\n@@ -83,8 +121,6 @@\n \t(ipa_passes): Declare.\n \t* Makefile.in (cgraphunit.o): Add dependency on cgraphunit.h\n \n-2005-04-21  Nathan Sidwell  <nathan@codesourcery.com>\n-\n 2005-04-21  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* config/i386/i386.c (type_natural_mode): Use gcc_unreachable and"}, {"sha": "2a2ab3e864b46e5d4a42dd9ece476e052510f46f", "filename": "gcc/cfghooks.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e61db61a0d66106ef00396aa04871d94021ddef/gcc%2Fcfghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e61db61a0d66106ef00396aa04871d94021ddef/gcc%2Fcfghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.h?ref=0e61db61a0d66106ef00396aa04871d94021ddef", "patch": "@@ -43,8 +43,8 @@ struct cfg_hooks\n   edge (*redirect_edge_and_branch) (edge e, basic_block b);\n \n   /* Same as the above but allows redirecting of fallthru edges.  In that case\n-     newly created forwarder basic block is returned.  It aborts when called\n-     on abnormal edge.  */\n+     newly created forwarder basic block is returned.  The edge must\n+     not be abnormal.  */\n   basic_block (*redirect_edge_and_branch_force) (edge, basic_block);\n \n   /* Remove statements corresponding to a given basic block.  */"}, {"sha": "0c259d6924bda63b526fa0535c9d601b796212f2", "filename": "gcc/lambda.h", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e61db61a0d66106ef00396aa04871d94021ddef/gcc%2Flambda.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e61db61a0d66106ef00396aa04871d94021ddef/gcc%2Flambda.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda.h?ref=0e61db61a0d66106ef00396aa04871d94021ddef", "patch": "@@ -326,19 +326,15 @@ lambda_vector_min_nz (lambda_vector vec1, int n, int start)\n {\n   int j;\n   int min = -1;\n-#ifdef ENABLE_CHECKING \n-  if (start > n)\n-    abort ();\n-#endif\n+\n+  gcc_assert (start <= n);\n   for (j = start; j < n; j++)\n     {\n       if (vec1[j])\n \tif (min < 0 || vec1[j] < vec1[min])\n \t  min = j;\n     }\n-\n-  if (min < 0)\n-    abort ();\n+  gcc_assert (min >= 0);\n \n   return min;\n }"}, {"sha": "e10592c98718020d2ecf0354d0a7affc97afe02f", "filename": "gcc/langhooks.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e61db61a0d66106ef00396aa04871d94021ddef/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e61db61a0d66106ef00396aa04871d94021ddef/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=0e61db61a0d66106ef00396aa04871d94021ddef", "patch": "@@ -120,7 +120,7 @@ struct lang_hooks_for_types\n   /* Given a type, apply default promotions to unnamed function\n      arguments and return the new type.  Return the same type if no\n      change.  Required by any language that supports variadic\n-     arguments.  The default hook aborts.  */\n+     arguments.  The default hook dies.  */\n   tree (*type_promotes_to) (tree);\n \n   /* Register TYPE as a builtin type with the indicated NAME.  The\n@@ -207,7 +207,7 @@ struct lang_hooks\n \n   /* Determines the size of any language-specific tcc_constant or\n      tcc_exceptional nodes.  Since it is called from make_node, the\n-     only information available is the tree code.  Expected to abort\n+     only information available is the tree code.  Expected to die\n      on unrecognized codes.  */\n   size_t (*tree_size) (enum tree_code);\n "}, {"sha": "d67c6ce89178e235302d67329b0a80ed8c98fbdd", "filename": "gcc/optabs.c", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e61db61a0d66106ef00396aa04871d94021ddef/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e61db61a0d66106ef00396aa04871d94021ddef/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=0e61db61a0d66106ef00396aa04871d94021ddef", "patch": "@@ -3307,7 +3307,8 @@ can_compare_p (enum rtx_code code, enum machine_mode mode,\n    comparison or emitting a library call to perform the comparison if no insn\n    is available to handle it.\n    The values which are passed in through pointers can be modified; the caller\n-   should perform the comparison on the modified values.  */\n+   should perform the comparison on the modified values.  Constant\n+   comparisons must have already been folded.  */\n \n static void\n prepare_cmp_insn (rtx *px, rtx *py, enum rtx_code *pcomparison, rtx size,\n@@ -3321,11 +3322,6 @@ prepare_cmp_insn (rtx *px, rtx *py, enum rtx_code *pcomparison, rtx size,\n \n   class = GET_MODE_CLASS (mode);\n \n-  /* They could both be VOIDmode if both args are immediate constants,\n-     but we should fold that at an earlier stage.\n-     With no special code here, this will call abort,\n-     reminding the programmer to implement such folding.  */\n-\n   if (mode != BLKmode && flag_force_mem)\n     {\n       /* Load duplicate non-volatile operands once.  */\n@@ -3352,9 +3348,9 @@ prepare_cmp_insn (rtx *px, rtx *py, enum rtx_code *pcomparison, rtx size,\n     y = force_reg (mode, y);\n \n #ifdef HAVE_cc0\n-  /* Abort if we have a non-canonical comparison.  The RTL documentation\n-     states that canonical comparisons are required only for targets which\n-     have cc0.  */\n+  /* Make sure if we have a canonical comparison.  The RTL\n+     documentation states that canonical comparisons are required only\n+     for targets which have cc0.  */\n   gcc_assert (!CONSTANT_P (x) || CONSTANT_P (y));\n #endif\n \n@@ -3601,9 +3597,8 @@ emit_cmp_and_jump_insns (rtx x, rtx y, enum rtx_code comparison, rtx size,\n     }\n \n #ifdef HAVE_cc0\n-  /* If OP0 is still a constant, then both X and Y must be constants.  Force\n-     X into a register to avoid aborting in emit_cmp_insn due to non-canonical\n-     RTL.  */\n+  /* If OP0 is still a constant, then both X and Y must be constants.\n+     Force X into a register to create canonical RTL.  */\n   if (CONSTANT_P (op0))\n     op0 = force_reg (mode, op0);\n #endif"}, {"sha": "10946ffe806a7ccf120ac54a9fd0d3f9090ea7b3", "filename": "gcc/opts.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e61db61a0d66106ef00396aa04871d94021ddef/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e61db61a0d66106ef00396aa04871d94021ddef/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=0e61db61a0d66106ef00396aa04871d94021ddef", "patch": "@@ -1027,10 +1027,8 @@ common_handle_option (size_t scode, const char *arg, int value)\n     default:\n       /* If the flag was handled in a standard way, assume the lack of\n \t processing here is intentional.  */\n-      if (cl_options[scode].flag_var)\n-\tbreak;\n-\n-      abort ();\n+      gcc_assert (cl_options[scode].flag_var);\n+      break;\n     }\n \n   return 1;"}, {"sha": "d7b81399c642f5f77bd0d56341c9335d785b7dfe", "filename": "gcc/output.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e61db61a0d66106ef00396aa04871d94021ddef/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e61db61a0d66106ef00396aa04871d94021ddef/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=0e61db61a0d66106ef00396aa04871d94021ddef", "patch": "@@ -320,8 +320,8 @@ extern bool default_assemble_integer (rtx, unsigned int, int);\n \n /* Assemble the integer constant X into an object of SIZE bytes.  ALIGN is\n    the alignment of the integer in bits.  Return 1 if we were able to output\n-   the constant, otherwise 0.  If FORCE is nonzero, abort if we can't output\n-   the constant.  */\n+   the constant, otherwise 0.  If FORCE is nonzero the constant must\n+   be outputable. */\n extern bool assemble_integer (rtx, unsigned, unsigned, int);\n \n /* An interface to assemble_integer for the common case in which a value is\n@@ -425,7 +425,7 @@ extern rtx current_insn_predicate;\n extern rtx current_output_insn;\n \n /* Nonzero while outputting an `asm' with operands.\n-   This means that inconsistencies are the user's fault, so don't abort.\n+   This means that inconsistencies are the user's fault, so don't die.\n    The precise value is the insn being output, to pass to error_for_asm.  */\n extern rtx this_is_asm_operands;\n "}, {"sha": "8e071020cb55f5e4791f57f9e861b43c68613dd5", "filename": "gcc/pretty-print.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e61db61a0d66106ef00396aa04871d94021ddef/gcc%2Fpretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e61db61a0d66106ef00396aa04871d94021ddef/gcc%2Fpretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpretty-print.c?ref=0e61db61a0d66106ef00396aa04871d94021ddef", "patch": "@@ -365,14 +365,13 @@ pp_base_format_text (pretty_printer *pp, text_info *text)\n \t  break;\n \n \tdefault:\n-          if (!pp_format_decoder (pp) || !(*pp_format_decoder (pp)) (pp, text))\n-\t    {\n-\t      /* Hmmm.  The client failed to install a format translator\n-                 but called us with an unrecognized format.  Or, maybe, the\n-                 translated string just contains an invalid format, or\n-                 has formats in the wrong order.  Sorry.  */\n-\t      abort ();\n-\t    }\n+\t  {\n+\t    bool ok;\n+\t    \n+\t    gcc_assert (pp_format_decoder (pp));\n+\t    ok = pp_format_decoder (pp) (pp, text);\n+\t    gcc_assert (ok);\n+\t  }\n \t}\n       if (quoted)\n \tpp_string (pp, close_quote);"}, {"sha": "db214e9b89eabb4ce38576f02088c1039c2c0172", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e61db61a0d66106ef00396aa04871d94021ddef/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e61db61a0d66106ef00396aa04871d94021ddef/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=0e61db61a0d66106ef00396aa04871d94021ddef", "patch": "@@ -554,10 +554,7 @@ print_rtx (rtx in_rtx)\n \tbreak;\n \n       default:\n-\tfprintf (stderr,\n-\t\t \"switch format wrong in rtl.print_rtx(). format was: %c.\\n\",\n-\t\t format_ptr[-1]);\n-\tabort ();\n+\tgcc_unreachable ();\n       }\n \n   switch (GET_CODE (in_rtx))"}, {"sha": "b9e0cb5fc820744761bf65347a3d14bff21bab8e", "filename": "gcc/read-rtl.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e61db61a0d66106ef00396aa04871d94021ddef/gcc%2Fread-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e61db61a0d66106ef00396aa04871d94021ddef/gcc%2Fread-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-rtl.c?ref=0e61db61a0d66106ef00396aa04871d94021ddef", "patch": "@@ -160,7 +160,7 @@ static struct obstack joined_conditions_obstack;\n /* The current line number for the file.  */\n int read_rtx_lineno = 1;\n \n-/* The filename for aborting with file and line.  */\n+/* The filename for error reporting.  */\n const char *read_rtx_filename = \"<unknown>\";\n \n static void\n@@ -1487,11 +1487,7 @@ read_rtx_1 (FILE *infile)\n \tbreak;\n \n       default:\n-\tfprintf (stderr,\n-\t\t \"switch format wrong in rtl.read_rtx(). format was: %c.\\n\",\n-\t\t format_ptr[i]);\n-\tfprintf (stderr, \"\\tfile position: %ld\\n\", ftell (infile));\n-\tabort ();\n+\tgcc_unreachable ();\n       }\n \n   c = read_skip_spaces (infile);"}, {"sha": "ed273e211ce8d6714188a34614c150730069e0f0", "filename": "gcc/regmove.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e61db61a0d66106ef00396aa04871d94021ddef/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e61db61a0d66106ef00396aa04871d94021ddef/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=0e61db61a0d66106ef00396aa04871d94021ddef", "patch": "@@ -135,7 +135,7 @@ try_auto_increment (rtx insn, rtx inc_insn, rtx inc_insn_set, rtx reg,\n \t\t  /* If there is a REG_DEAD note on this insn, we must\n \t\t     change this not to REG_UNUSED meaning that the register\n \t\t     is set, but the value is dead.  Failure to do so will\n-\t\t     result in a sched1 abort -- when it recomputes lifetime\n+\t\t     result in a sched1 dieing -- when it recomputes lifetime\n \t\t     information, the number of REG_DEAD notes will have\n \t\t     changed.  */\n \t\t  rtx note = find_reg_note (insn, REG_DEAD, reg);"}, {"sha": "394a43014b62a7765bed08b58a4b55d0fdb0febb", "filename": "gcc/reload.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e61db61a0d66106ef00396aa04871d94021ddef/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e61db61a0d66106ef00396aa04871d94021ddef/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=0e61db61a0d66106ef00396aa04871d94021ddef", "patch": "@@ -671,7 +671,7 @@ clear_secondary_mem (void)\n /* Find the largest class which has at least one register valid in\n    mode INNER, and which for every such register, that register number\n    plus N is also valid in OUTER (if in range) and is cheap to move\n-   into REGNO.  Abort if no such class exists.  */\n+   into REGNO.  Such a class must exist.  */\n \n static enum reg_class\n find_valid_class (enum machine_mode outer ATTRIBUTE_UNUSED,\n@@ -4559,14 +4559,14 @@ find_reloads_toplev (rtx x, int opnum, enum reload_type type,\n \n   if (code == SUBREG && REG_P (SUBREG_REG (x)))\n     {\n-      /* Check for SUBREG containing a REG that's equivalent to a constant.\n-\t If the constant has a known value, truncate it right now.\n-\t Similarly if we are extracting a single-word of a multi-word\n-\t constant.  If the constant is symbolic, allow it to be substituted\n-\t normally.  push_reload will strip the subreg later.  If the\n-\t constant is VOIDmode, abort because we will lose the mode of\n-\t the register (this should never happen because one of the cases\n-\t above should handle it).  */\n+      /* Check for SUBREG containing a REG that's equivalent to a\n+\t constant.  If the constant has a known value, truncate it\n+\t right now.  Similarly if we are extracting a single-word of a\n+\t multi-word constant.  If the constant is symbolic, allow it\n+\t to be substituted normally.  push_reload will strip the\n+\t subreg later.  The constant must not be VOIDmode, because we\n+\t will lose the mode of the register (this should never happen\n+\t because one of the cases above should handle it).  */\n \n       int regno = REGNO (SUBREG_REG (x));\n       rtx tem;\n@@ -6536,7 +6536,7 @@ find_equiv_reg (rtx goal, rtx insn, enum reg_class class, int other,\n \t\t different from what they were when calculating the need for\n \t\t spills.  If we notice an input-reload insn here, we will\n \t\t reject it below, but it might hide a usable equivalent.\n-\t\t That makes bad code.  It may even abort: perhaps no reg was\n+\t\t That makes bad code.  It may even fail: perhaps no reg was\n \t\t spilled for this insn because it was assumed we would find\n \t\t that equivalent.  */\n \t      || INSN_UID (p) < reload_first_uid))"}, {"sha": "fbe491bd5aa939f9c33035e2be105576f36771e4", "filename": "gcc/reload1.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e61db61a0d66106ef00396aa04871d94021ddef/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e61db61a0d66106ef00396aa04871d94021ddef/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=0e61db61a0d66106ef00396aa04871d94021ddef", "patch": "@@ -1090,8 +1090,8 @@ reload (rtx first, int global)\n       CLEAR_REGNO_REG_SET (bb->global_live_at_start,\n \t\t\t   HARD_FRAME_POINTER_REGNUM);\n \n-  /* Come here (with failure set nonzero) if we can't get enough spill regs\n-     and we decide not to abort about it.  */\n+  /* Come here (with failure set nonzero) if we can't get enough spill\n+     regs.  */\n  failed:\n \n   CLEAR_REG_SET (&spilled_pseudos);\n@@ -4059,7 +4059,7 @@ forget_old_reloads_1 (rtx x, rtx ignored ATTRIBUTE_UNUSED,\n   unsigned int nr;\n \n   /* note_stores does give us subregs of hard regs,\n-     subreg_regno_offset will abort if it is not a hard reg.  */\n+     subreg_regno_offset requires a hard reg.  */\n   while (GET_CODE (x) == SUBREG)\n     {\n       /* We ignore the subreg offset when calculating the regno,\n@@ -4963,11 +4963,11 @@ free_for_value_p (int regno, enum machine_mode mode, int opnum,\n }\n \n /* Return nonzero if the rtx X is invariant over the current function.  */\n-/* ??? Actually, the places where we use this expect exactly what\n- * is tested here, and not everything that is function invariant.  In\n- * particular, the frame pointer and arg pointer are special cased;\n- * pic_offset_table_rtx is not, and this will cause aborts when we\n- *             go to spill these things to memory.  */\n+/* ??? Actually, the places where we use this expect exactly what is\n+   tested here, and not everything that is function invariant.  In\n+   particular, the frame pointer and arg pointer are special cased;\n+   pic_offset_table_rtx is not, and we must not spill these things to\n+   memory.  */\n \n static int\n function_invariant_p (rtx x)\n@@ -6087,10 +6087,10 @@ merge_assigned_reloads (rtx insn)\n \t\t\t|| rld[j].when_needed == RELOAD_FOR_INPADDR_ADDRESS)\n \t\t       ? RELOAD_FOR_OTHER_ADDRESS : RELOAD_OTHER);\n \n-\t\t  /* Check to see if we accidentally converted two reloads\n-\t\t     that use the same reload register with different inputs\n-\t\t     to the same type.  If so, the resulting code won't work,\n-\t\t     so abort.  */\n+\t\t  /* Check to see if we accidentally converted two\n+\t\t     reloads that use the same reload register with\n+\t\t     different inputs to the same type.  If so, the\n+\t\t     resulting code won't work.  */\n \t\t  if (rld[j].reg_rtx)\n \t\t    for (k = 0; k < j; k++)\n \t\t      gcc_assert (rld[k].in == 0 || rld[k].reg_rtx == 0"}, {"sha": "9fbf4282de15070255c3e5a786d9c6509d148f1a", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e61db61a0d66106ef00396aa04871d94021ddef/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e61db61a0d66106ef00396aa04871d94021ddef/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=0e61db61a0d66106ef00396aa04871d94021ddef", "patch": "@@ -254,11 +254,8 @@ link_imm_use_stmt (ssa_imm_use_t *linknode, tree def, tree stmt)\n static inline void\n relink_imm_use (ssa_imm_use_t *node, ssa_imm_use_t *old)\n {\n-#ifdef ENABLE_CHECKING\n   /* The node one had better be in the same list.  */\n-  if (*(old->use) != *(node->use))\n-    abort ();\n-#endif\n+  gcc_assert (*(old->use) == *(node->use));\n   node->prev = old->prev;\n   node->next = old->next;\n   if (old->prev)\n@@ -268,7 +265,6 @@ relink_imm_use (ssa_imm_use_t *node, ssa_imm_use_t *old)\n       /* Remove the old node from the list.  */\n       old->prev = NULL;\n     }\n-\n }\n \n /* Relink ssa_imm_use node LINKNODE into the chain for OLD, with use occuring "}, {"sha": "c5634fdd8f88d41a6055b04b3f22047bfcd1a0c9", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e61db61a0d66106ef00396aa04871d94021ddef/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e61db61a0d66106ef00396aa04871d94021ddef/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=0e61db61a0d66106ef00396aa04871d94021ddef", "patch": "@@ -1069,7 +1069,7 @@ inline_forbidden_p_1 (tree *nodep, int *walk_subtrees ATTRIBUTE_UNUSED,\n \t UNION_TYPE nodes, then it goes into infinite recursion on a\n \t structure containing a pointer to its own type.  If it doesn't,\n \t then the type node for S doesn't get adjusted properly when\n-\t F is inlined, and we abort in find_function_data.\n+\t F is inlined. \n \n \t ??? This is likely no longer true, but it's too late in the 4.0\n \t cycle to try to find out.  This should be checked for 4.1.  */\n@@ -1430,7 +1430,6 @@ estimate_num_insns_1 (tree *tp, int *walk_subtrees, void *data)\n \tbreak;\n       }\n     default:\n-      /* Abort here se we know we don't miss any nodes.  */\n       gcc_unreachable ();\n     }\n   return NULL;"}, {"sha": "b0b6b340bbc619ae448ecde796d1804bee45268a", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e61db61a0d66106ef00396aa04871d94021ddef/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e61db61a0d66106ef00396aa04871d94021ddef/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=0e61db61a0d66106ef00396aa04871d94021ddef", "patch": "@@ -493,7 +493,7 @@ execute_todo (struct tree_opt_pass *pass, unsigned int flags, bool use_required)\n         print_rtl (dump_file, get_insns ());\n \n       /* Flush the file.  If verification fails, we won't be able to\n-\t close the file before aborting.  */\n+\t close the file before dieing.  */\n       fflush (dump_file);\n     }\n   if ((flags & TODO_dump_cgraph)"}, {"sha": "a06a612a9b244dc2885ecdd4944b311195461857", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e61db61a0d66106ef00396aa04871d94021ddef/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e61db61a0d66106ef00396aa04871d94021ddef/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=0e61db61a0d66106ef00396aa04871d94021ddef", "patch": "@@ -493,8 +493,7 @@ eliminate_phi (edge e, elim_graph g)\n \n   gcc_assert (VARRAY_ACTIVE_SIZE (g->const_copies) == 0);\n \n-  /* Abnormal edges already have everything coalesced, or the coalescer\n-     would have aborted.  */\n+  /* Abnormal edges already have everything coalesced.  */\n   if (e->flags & EDGE_ABNORMAL)\n     return;\n "}, {"sha": "09dbbbbfec49fcf94799e8a59ad21662526705a6", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e61db61a0d66106ef00396aa04871d94021ddef/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e61db61a0d66106ef00396aa04871d94021ddef/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=0e61db61a0d66106ef00396aa04871d94021ddef", "patch": "@@ -1958,7 +1958,7 @@ add_pointed_to_expr (struct alias_info *ai, tree ptr, tree expr)\n \t}\n \n       /* Neither operand is a pointer?  VAR can be pointing anywhere.\n-\t FIXME: Shouldn't we abort here?  If we get here, we found\n+\t FIXME: Shouldn't we asserting here?  If we get here, we found\n \t PTR = INT_CST + INT_CST, which should not be a valid pointer\n \t expression.  */\n       if (!(POINTER_TYPE_P (TREE_TYPE (op0))"}, {"sha": "3ae0b1aca8b0881e136aaa416853b054b2f0149b", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e61db61a0d66106ef00396aa04871d94021ddef/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e61db61a0d66106ef00396aa04871d94021ddef/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=0e61db61a0d66106ef00396aa04871d94021ddef", "patch": "@@ -1657,7 +1657,7 @@ maybe_fold_stmt_indirect (tree expr, tree base, tree offset)\n \t  && TREE_CODE (TREE_OPERAND (t, 0)) == STRING_CST)\n \t{\n \t  /* FIXME: Except that this causes problems elsewhere with dead\n-\t     code not being deleted, and we abort in the rtl expanders \n+\t     code not being deleted, and we die in the rtl expanders \n \t     because we failed to remove some ssa_name.  In the meantime,\n \t     just return zero.  */\n \t  /* FIXME2: This condition should be signaled by"}, {"sha": "a010b3040ef6001ddb66c04d65ba3c733b4a682c", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 23, "deletions": 56, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e61db61a0d66106ef00396aa04871d94021ddef/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e61db61a0d66106ef00396aa04871d94021ddef/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=0e61db61a0d66106ef00396aa04871d94021ddef", "patch": "@@ -1084,7 +1084,7 @@ parse_ssa_operands (tree stmt)\n \n     default:\n       /* Notice that if get_expr_operands tries to use &STMT as the operand\n-\t pointer (which may only happen for USE operands), we will abort in\n+\t pointer (which may only happen for USE operands), we will fail in\n \t append_use.  This default will handle statements like empty\n \t statements, or CALL_EXPRs that may appear on the RHS of a statement\n \t or as statements themselves.  */\n@@ -1680,7 +1680,7 @@ get_indirect_ref_operands (tree stmt, tree expr, int flags)\n \n   /* Everything else *should* have been folded elsewhere, but users\n      are smarter than we in finding ways to write invalid code.  We\n-     cannot just abort here.  If we were absolutely certain that we\n+     cannot just assert here.  If we were absolutely certain that we\n      do handle all valid cases, then we could just do nothing here.\n      That seems optimistic, so attempt to do something logical... */\n   else if ((TREE_CODE (ptr) == PLUS_EXPR || TREE_CODE (ptr) == MINUS_EXPR)\n@@ -2219,29 +2219,6 @@ create_ssa_artficial_load_stmt (stmt_operands_p old_ops, tree new_stmt)\n   ann->operands.vuse_ops = finalize_ssa_vuses (&(tmp.vuse_ops), NULL);\n }\n \n-\n-\n-/* Issue immediate use error for VAR to debug file F.  */\n-static void \n-verify_abort (FILE *f, ssa_imm_use_t *var)\n-{\n-  tree stmt;\n-  stmt = var->stmt;\n-  if (stmt)\n-    {\n-      if (stmt_modified_p(stmt))\n-\t{\n-\t  fprintf (f, \" STMT MODIFIED. - <%p> \", (void *)stmt);\n-\t  print_generic_stmt (f, stmt, TDF_SLIM);\n-\t}\n-    }\n-  fprintf (f, \" IMM ERROR : (use_p : tree - %p:%p)\", (void *)var, \n-\t   (void *)var->use);\n-  print_generic_expr (f, USE_FROM_PTR (var), TDF_SLIM);\n-  fprintf(f, \"\\n\");\n-}\n-\n-\n /* Scan the immediate_use list for VAR making sure its linked properly.\n    return RTUE iof there is a problem.  */\n \n@@ -2268,58 +2245,48 @@ verify_imm_links (FILE *f, tree var)\n   for (ptr = list->next; ptr != list; )\n     {\n       if (prev != ptr->prev)\n-        {\n-\t  verify_abort (f, ptr);\n-\t  return true;\n-\t}\n-\n+\tgoto error;\n+      \n       if (ptr->use == NULL)\n-        {\n-\t  verify_abort (f, ptr); \t/* 2 roots, or SAFE guard node.  */\n-\t  return true;\n-\t}\n-      else\n-\tif (*(ptr->use) != var)\n-\t  {\n-\t    verify_abort (f, ptr);\n-\t    return true;\n-\t  }\n+\tgoto error; /* 2 roots, or SAFE guard node.  */\n+      else if (*(ptr->use) != var)\n+\tgoto error;\n \n       prev = ptr;\n       ptr = ptr->next;\n       /* Avoid infinite loops.  */\n       if (count++ > 30000)\n-\t{\n-\t  verify_abort (f, ptr);\n-\t  return true;\n-\t}\n+\tgoto error;\n     }\n \n   /* Verify list in the other direction.  */\n   prev = list;\n   for (ptr = list->prev; ptr != list; )\n     {\n       if (prev != ptr->next)\n-\t{\n-\t  verify_abort (f, ptr);\n-\t  return true;\n-\t}\n+\tgoto error;\n       prev = ptr;\n       ptr = ptr->prev;\n       if (count-- < 0)\n-\t{\n-\t  verify_abort (f, ptr);\n-\t  return true;\n-\t}\n+\tgoto error;\n     }\n \n   if (count != 0)\n-    {\n-      verify_abort (f, ptr);\n-      return true;\n-    }\n+    goto error;\n \n   return false;\n+\n+ error:\n+  if (ptr->stmt && stmt_modified_p (ptr->stmt))\n+    {\n+      fprintf (f, \" STMT MODIFIED. - <%p> \", (void *)ptr->stmt);\n+      print_generic_stmt (f, ptr->stmt, TDF_SLIM);\n+    }\n+  fprintf (f, \" IMM ERROR : (use_p : tree - %p:%p)\", (void *)ptr, \n+\t   (void *)ptr->use);\n+  print_generic_expr (f, USE_FROM_PTR (ptr), TDF_SLIM);\n+  fprintf(f, \"\\n\");\n+  return true;\n }\n \n "}, {"sha": "608e9303de26c925754a4dc162d41f61491c186b", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e61db61a0d66106ef00396aa04871d94021ddef/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e61db61a0d66106ef00396aa04871d94021ddef/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=0e61db61a0d66106ef00396aa04871d94021ddef", "patch": "@@ -1287,9 +1287,8 @@ find_or_generate_expression (basic_block block, tree expr, tree stmts)\n {\n   tree genop = bitmap_find_leader (AVAIL_OUT (block), expr);\n \n-  /* If it's still NULL, see if it is a complex expression, and if\n-     so, generate it recursively, otherwise, abort, because it's\n-     not really .  */\n+  /* If it's still NULL, it must be a complex expression, so generate\n+     it recursively.  */\n   if (genop == NULL)\n     {\n       genop = VALUE_HANDLE_EXPR_SET (expr)->head->expr;\n@@ -1309,7 +1308,7 @@ find_or_generate_expression (basic_block block, tree expr, tree stmts)\n    EXPR is the expression to insert (in value form)\n    STMTS is a statement list to append the necessary insertions into.\n \n-   This function will abort if we hit some value that shouldn't be\n+   This function will die if we hit some value that shouldn't be\n    ANTIC but is (IE there is no leader for it, or its components).\n    This function may also generate expressions that are themselves\n    partially or fully redundant.  Those that are will be either made"}, {"sha": "b0c430b8f96a0c8717009570337e6bdef1fa97ba", "filename": "gcc/tree-ssanames.c", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e61db61a0d66106ef00396aa04871d94021ddef/gcc%2Ftree-ssanames.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e61db61a0d66106ef00396aa04871d94021ddef/gcc%2Ftree-ssanames.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.c?ref=0e61db61a0d66106ef00396aa04871d94021ddef", "patch": "@@ -1,23 +1,23 @@\n /* Generic routines for manipulating SSA_NAME expressions\n    Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.\n-                                                                                \n+                                                                               \n This file is part of GCC.\n-                                                                                \n+                                                                               \n GCC is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n-                                                                                \n+                                                                               \n GCC is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n-                                                                                \n+                                                                               \n You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n-                                                                                \n+\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n@@ -260,13 +260,7 @@ release_ssa_name (tree var)\n       verify_imm_links (stderr, var);\n #endif\n       while (imm->next != imm)\n-        {\n-\t  delink_imm_use (imm->next);\n-\t}\n-#ifdef ENABLE_CHECKING\n-      if (imm->next != imm)\n-        abort();\n-#endif\n+\tdelink_imm_use (imm->next);\n \n       VARRAY_TREE (ssa_names, SSA_NAME_VERSION (var)) = NULL;\n       memset (var, 0, tree_size (var));"}, {"sha": "c8b6ea6a19642f272ec485b9c9305709cf056497", "filename": "gcc/tree.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e61db61a0d66106ef00396aa04871d94021ddef/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e61db61a0d66106ef00396aa04871d94021ddef/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=0e61db61a0d66106ef00396aa04871d94021ddef", "patch": "@@ -1496,9 +1496,9 @@ bit_position (tree field)\n \t\t       DECL_FIELD_BIT_OFFSET (field));\n }\n \n-/* Likewise, but return as an integer.  Abort if it cannot be represented\n-   in that way (since it could be a signed value, we don't have the option\n-   of returning -1 like int_size_in_byte can.  */\n+/* Likewise, but return as an integer.  It must be representable in\n+   that way (since it could be a signed value, we don't have the\n+   option of returning -1 like int_size_in_byte can.  */\n \n HOST_WIDE_INT\n int_bit_position (tree field)\n@@ -1516,9 +1516,9 @@ byte_position (tree field)\n \t\t\tDECL_FIELD_BIT_OFFSET (field));\n }\n \n-/* Likewise, but return as an integer.  Abort if it cannot be represented\n-   in that way (since it could be a signed value, we don't have the option\n-   of returning -1 like int_size_in_byte can.  */\n+/* Likewise, but return as an integer.  It must be representable in\n+   that way (since it could be a signed value, we don't have the\n+   option of returning -1 like int_size_in_byte can.  */\n \n HOST_WIDE_INT\n int_byte_position (tree field)\n@@ -3838,7 +3838,7 @@ host_integerp (tree t, int pos)\n \n /* Return the HOST_WIDE_INT least significant bits of T if it is an\n    INTEGER_CST and there is no overflow.  POS is nonzero if the result must\n-   be positive.  Abort if we cannot satisfy the above conditions.  */\n+   be positive.  We must be able to satisfy the above conditions.  */\n \n HOST_WIDE_INT\n tree_low_cst (tree t, int pos)\n@@ -6411,7 +6411,7 @@ walk_type_fields (tree type, walk_tree_fn func, void *data,\n \n /* Apply FUNC to all the sub-trees of TP in a pre-order traversal.  FUNC is\n    called with the DATA and the address of each sub-tree.  If FUNC returns a\n-   non-NULL value, the traversal is aborted, and the value returned by FUNC\n+   non-NULL value, the traversal is stopped, and the value returned by FUNC\n    is returned.  If PSET is non-NULL it is used to record the nodes visited,\n    and to avoid visiting a node more than once.  */\n "}, {"sha": "50ea50426e8d3129e69eb2483d969cd439e060da", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e61db61a0d66106ef00396aa04871d94021ddef/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e61db61a0d66106ef00396aa04871d94021ddef/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=0e61db61a0d66106ef00396aa04871d94021ddef", "patch": "@@ -443,7 +443,7 @@ struct tree_common GTY(())\n #define TREE_SET_CODE(NODE, VALUE) ((NODE)->common.code = (VALUE))\n \n /* When checking is enabled, errors will be generated if a tree node\n-   is accessed incorrectly. The macros abort with a fatal error.  */\n+   is accessed incorrectly. The macros die with a fatal error.  */\n #if defined ENABLE_TREE_CHECKING && (GCC_VERSION >= 2007)\n \n #define TREE_CHECK(T, CODE) __extension__\t\t\t\t\\"}, {"sha": "2c05fa138593452134c41312095b5908c12aa4d9", "filename": "gcc/vec.h", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e61db61a0d66106ef00396aa04871d94021ddef/gcc%2Fvec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e61db61a0d66106ef00396aa04871d94021ddef/gcc%2Fvec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.h?ref=0e61db61a0d66106ef00396aa04871d94021ddef", "patch": "@@ -61,7 +61,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    Each operation that increases the number of active elements is\n    available in 'quick' and 'safe' variants.  The former presumes that\n    there is sufficient allocated space for the operation to succeed\n-   (it aborts if there is not).  The latter will reallocate the\n+   (it dies if there is not).  The latter will reallocate the\n    vector, if needed.  Reallocation causes an exponential increase in\n    vector size.  If you know you will be adding N elements, it would\n    be more efficient to use the reserve operation before adding the\n@@ -150,16 +150,15 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    T VEC_T_last(VEC(T) *v); // Pointer\n    T *VEC_T_last(VEC(T) *v); // Object\n \n-   Return the final element.  If V is empty,  abort.  */\n+   Return the final element.  V must not be empty.  */\n \n #define VEC_last(T,V)\t(VEC_OP(T,base,last)(VEC_BASE(V) VEC_CHECK_INFO))\n \n /* Index into vector\n    T VEC_T_index(VEC(T) *v, unsigned ix); // Pointer\n    T *VEC_T_index(VEC(T) *v, unsigned ix); // Object\n \n-   Return the IX'th element.  If IX is outside the domain of V,\n-   abort.  */\n+   Return the IX'th element.  If IX must be in the domain of V.  */\n \n #define VEC_index(T,V,I) (VEC_OP(T,base,index)(VEC_BASE(V),I VEC_CHECK_INFO))\n \n@@ -234,8 +233,8 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    \n    Push a new element onto the end, returns a pointer to the slot\n    filled in. For object vectors, the new value can be NULL, in which\n-   case NO initialization is performed.  Aborts if there is\n-   insufficient space in the vector.  */\n+   case NO initialization is performed.  There must\n+   be sufficient space in the vector.  */\n \n #define VEC_quick_push(T,V,O)\t\\\n \t(VEC_OP(T,base,quick_push)(VEC_BASE(V),O VEC_CHECK_INFO))\n@@ -299,7 +298,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    Insert an element, VAL, at the IXth position of V. Return a pointer\n    to the slot created.  For vectors of object, the new value can be\n    NULL, in which case no initialization of the inserted slot takes\n-   place. Aborts if there is insufficient space.  */\n+   place. There must be sufficient space.  */\n \n #define VEC_quick_insert(T,V,I,O)\t\\\n \t(VEC_OP(T,base,quick_insert)(VEC_BASE(V),I,O VEC_CHECK_INFO))"}]}