{"sha": "3f6d1daa7cc592e13db95a9402762b525a317566", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Y2ZDFkYWE3Y2M1OTJlMTNkYjk1YTk0MDI3NjJiNTI1YTMxNzU2Ng==", "commit": {"author": {"name": "Justin Squirek", "email": "squirek@adacore.com", "date": "2018-05-24T13:06:11Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2018-05-24T13:06:11Z"}, "message": "[Ada] Quadratic compile time with tagged types\n\nThis patch is an incremental commit which focuses on the optimization of entity\nchain navigation by adding an additional field (Prev_Entity) to all nodes in\norder to greaty speed up compilation of sources making heavy use of tagged\nderivations by effectly making the entity chain from a singly-linked list into\na doubly-linked one.\n\nThis is only a performance improvement: no compilation result change\nexpected.\n\n2018-05-24  Justin Squirek  <squirek@adacore.com>\n\ngcc/ada/\n\n\t* einfo.ads, einfo.adb (Append_Entity): Modified to use Link_Entities\n\tand manage doubly-linked entity chain.\n\t(Nested_Scenarios): Removed entity field used for optimization during\n\t elaboration to make room for the new field Prev_Entity.\n\t(Link_Entities): Added to replace redundant calls to Set_Next_Entity\n\tand Set_Prev_Entity as well as centralize changes to the entity chain.\n\t(Predicated_Parent): Modified to use Node38.\n\t(Prev_Entity): Added to fetch new node field Prev_Entity in all entity\n\ttypes.\n\t(Remove_Entity): Moved from sem_util.\n\t(Set_Nested_Scenarios): Deleted.\n\t(Set_Predicated_Parent): Modified to use Node38.\n\t(Set_Prev_Entity): Added to set Prev_Entity field.\n\t(Set_Validated_Object): Modified to use Node38.\n\t(Unlink_Next_Entity): Added to process Prev_Entity when an unlinking\n\taction is required.\n\t(Validated_Object): Modified to use Node38.\n\t(Write_Field36_Name): Remove Nested_Scenarios, Validated_Object, and\n\tpredicated parent cases.\n\t(Write_Field38_Name): Add predicated parent and Validated_Object cases.\n\t* sem_ch3.adb (Process_Subtype): Add guard to protect against\n\tinappropriate marking of Predicated_Parent to non-itype subtypes.\n\t(Make_Class_Wide_Type): Preserve Prev_Entity field and set in new type.\n\t(Copy_And_Swap): Add setting of Prev_Entity.\n\t(Build_derived_Record_Type): Replace Set_Next_Entity w/ Link_Entities.\n\t* sem_ch6.adb (Analyze_Subprogram_Body_Helper): Replace Set_Next_Entity\n\tw/ Link_Entities.\n\t(New_Overloaded_Entity): Remove block created to search for previous\n\tentities in the entity chain with relevant calls to Prev_Entity as well\n\tas replace duplicated code from Remove_Entity_And_Homonym with a call\n\tto that subprogram.\n\t* sem_ch7.adb (Exchange_Declarations): Replace Set_Next_Entity w/\n\tLink_Entities.\n\t* sem_elab.adb (Find_And_Process_Nested_Scenarios): Remove global and\n\tinitial subprogram declarations related to Nested_Scenarios.\n\t(Process_Nested_Scenarios): Deleted.\n\t(Save_Scenario): Deleted.\n\t(Traverse_Body): Remove optimization for Nested_Scenarios so as to free\n\tnode space in the entity tree.\n\t* sem_util.adb, sem_util.ads (Remove_Entity): Moved to einfo.\n\t(Remove_Entity_And_Homonym): Added to separate functionality of\n\tRemove_Entity from the homonym chain directly.\n\t* exp_attr.adb (Expand_N_Attribute_Reference): Replace Set_Next_Entity\n\tw/ Link_Entities and Unlink_Next_Entity.\n\t* exp_ch3.adb (Expand_N_Object_Declaration): Replace Set_Next_Entity w/\n\tLink_Entities.\n\t* exp_ch6.adb (Replace_Renaming_Declaration_Id): Replace\n\tSet_Next_Entity w/ Link_Entities.\n\t* exp_disp.adb (Expand_Dispatching_Call): Replace Set_Next_Entity w/\n\tLink_Entities and Unlink_Next_Entity.\n\t* exp_spark.adb (Expand_SPARK_N_Object_Renaming_Declaration): Replace\n\tcall to Remove_Entity with its new incarnation.\n\t* exp_util.adb (New_Class_Wide_Subtype): Add setting of Prev_Entity.\n\t* freeze.adb (Freeze_Record_Type): Replace Set_Next_Entity w/\n\tLink_Entities.\n\nFrom-SVN: r260661", "tree": {"sha": "cc06e7dff0008b6482233ae7f508d27cdfe82524", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cc06e7dff0008b6482233ae7f508d27cdfe82524"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3f6d1daa7cc592e13db95a9402762b525a317566", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f6d1daa7cc592e13db95a9402762b525a317566", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f6d1daa7cc592e13db95a9402762b525a317566", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f6d1daa7cc592e13db95a9402762b525a317566/comments", "author": {"login": "AdaDoom3", "id": 3445599, "node_id": "MDQ6VXNlcjM0NDU1OTk=", "avatar_url": "https://avatars.githubusercontent.com/u/3445599?v=4", "gravatar_id": "", "url": "https://api.github.com/users/AdaDoom3", "html_url": "https://github.com/AdaDoom3", "followers_url": "https://api.github.com/users/AdaDoom3/followers", "following_url": "https://api.github.com/users/AdaDoom3/following{/other_user}", "gists_url": "https://api.github.com/users/AdaDoom3/gists{/gist_id}", "starred_url": "https://api.github.com/users/AdaDoom3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/AdaDoom3/subscriptions", "organizations_url": "https://api.github.com/users/AdaDoom3/orgs", "repos_url": "https://api.github.com/users/AdaDoom3/repos", "events_url": "https://api.github.com/users/AdaDoom3/events{/privacy}", "received_events_url": "https://api.github.com/users/AdaDoom3/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "dc59bed2859c3b713334e20623e47ec5aafd8f5d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc59bed2859c3b713334e20623e47ec5aafd8f5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc59bed2859c3b713334e20623e47ec5aafd8f5d"}], "stats": {"total": 853, "additions": 428, "deletions": 425}, "files": [{"sha": "b0ce1bee476974b98a5dfb6fe94e0a177d9853f5", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f6d1daa7cc592e13db95a9402762b525a317566/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f6d1daa7cc592e13db95a9402762b525a317566/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=3f6d1daa7cc592e13db95a9402762b525a317566", "patch": "@@ -1,3 +1,61 @@\n+2018-05-24  Justin Squirek  <squirek@adacore.com>\n+\n+\t* einfo.ads, einfo.adb (Append_Entity): Modified to use Link_Entities\n+\tand manage doubly-linked entity chain.\n+\t(Nested_Scenarios): Removed entity field used for optimization during\n+\t elaboration to make room for the new field Prev_Entity.\n+\t(Link_Entities): Added to replace redundant calls to Set_Next_Entity\n+\tand Set_Prev_Entity as well as centralize changes to the entity chain.\n+\t(Predicated_Parent): Modified to use Node38.\n+\t(Prev_Entity): Added to fetch new node field Prev_Entity in all entity\n+\ttypes.\n+\t(Remove_Entity): Moved from sem_util.\n+\t(Set_Nested_Scenarios): Deleted.\n+\t(Set_Predicated_Parent): Modified to use Node38.\n+\t(Set_Prev_Entity): Added to set Prev_Entity field.\n+\t(Set_Validated_Object): Modified to use Node38.\n+\t(Unlink_Next_Entity): Added to process Prev_Entity when an unlinking\n+\taction is required.\n+\t(Validated_Object): Modified to use Node38.\n+\t(Write_Field36_Name): Remove Nested_Scenarios, Validated_Object, and\n+\tpredicated parent cases.\n+\t(Write_Field38_Name): Add predicated parent and Validated_Object cases.\n+\t* sem_ch3.adb (Process_Subtype): Add guard to protect against\n+\tinappropriate marking of Predicated_Parent to non-itype subtypes.\n+\t(Make_Class_Wide_Type): Preserve Prev_Entity field and set in new type.\n+\t(Copy_And_Swap): Add setting of Prev_Entity.\n+\t(Build_derived_Record_Type): Replace Set_Next_Entity w/ Link_Entities.\n+\t* sem_ch6.adb (Analyze_Subprogram_Body_Helper): Replace Set_Next_Entity\n+\tw/ Link_Entities.\n+\t(New_Overloaded_Entity): Remove block created to search for previous\n+\tentities in the entity chain with relevant calls to Prev_Entity as well\n+\tas replace duplicated code from Remove_Entity_And_Homonym with a call\n+\tto that subprogram.\n+\t* sem_ch7.adb (Exchange_Declarations): Replace Set_Next_Entity w/\n+\tLink_Entities.\n+\t* sem_elab.adb (Find_And_Process_Nested_Scenarios): Remove global and\n+\tinitial subprogram declarations related to Nested_Scenarios.\n+\t(Process_Nested_Scenarios): Deleted.\n+\t(Save_Scenario): Deleted.\n+\t(Traverse_Body): Remove optimization for Nested_Scenarios so as to free\n+\tnode space in the entity tree.\n+\t* sem_util.adb, sem_util.ads (Remove_Entity): Moved to einfo.\n+\t(Remove_Entity_And_Homonym): Added to separate functionality of\n+\tRemove_Entity from the homonym chain directly.\n+\t* exp_attr.adb (Expand_N_Attribute_Reference): Replace Set_Next_Entity\n+\tw/ Link_Entities and Unlink_Next_Entity.\n+\t* exp_ch3.adb (Expand_N_Object_Declaration): Replace Set_Next_Entity w/\n+\tLink_Entities.\n+\t* exp_ch6.adb (Replace_Renaming_Declaration_Id): Replace\n+\tSet_Next_Entity w/ Link_Entities.\n+\t* exp_disp.adb (Expand_Dispatching_Call): Replace Set_Next_Entity w/\n+\tLink_Entities and Unlink_Next_Entity.\n+\t* exp_spark.adb (Expand_SPARK_N_Object_Renaming_Declaration): Replace\n+\tcall to Remove_Entity with its new incarnation.\n+\t* exp_util.adb (New_Class_Wide_Subtype): Add setting of Prev_Entity.\n+\t* freeze.adb (Freeze_Record_Type): Replace Set_Next_Entity w/\n+\tLink_Entities.\n+\n 2018-05-24  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* sem_ch10.adb (Expand_Limited_With_Clause): Update the call to"}, {"sha": "c0cb261acdeb000ae08401e84254ad5b73c8a6ed", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 138, "deletions": 55, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f6d1daa7cc592e13db95a9402762b525a317566/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f6d1daa7cc592e13db95a9402762b525a317566/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=3f6d1daa7cc592e13db95a9402762b525a317566", "patch": "@@ -70,6 +70,7 @@ package body Einfo is\n    --    Homonym                         Node4\n    --    First_Rep_Item                  Node6\n    --    Freeze_Node                     Node7\n+   --    Prev_Entity                     Node36\n    --    Associated_Entity               Node37\n \n    --  The usage of other fields (and the entity kinds to which it applies)\n@@ -274,10 +275,10 @@ package body Einfo is\n    --    Entry_Max_Queue_Lengths_Array   Node35\n    --    Import_Pragma                   Node35\n \n-   --    Nested_Scenarios                Elist36\n-   --    Validated_Object                Node36\n-   --    Predicated_Parent               Node36\n+   --    Prev_Entity                     Node36\n \n+   --    Validated_Object                Node38\n+   --    Predicated_Parent               Node38\n    --    Class_Wide_Clone                Node38\n \n    --    Protected_Subprogram            Node39\n@@ -2878,14 +2879,6 @@ package body Einfo is\n       return Flag22 (Id);\n    end Needs_No_Actuals;\n \n-   function Nested_Scenarios (Id : E) return L is\n-   begin\n-      pragma Assert (Ekind_In (Id, E_Function,\n-                                   E_Procedure,\n-                                   E_Subprogram_Body));\n-      return Elist36 (Id);\n-   end Nested_Scenarios;\n-\n    function Never_Set_In_Source (Id : E) return B is\n    begin\n       return Flag115 (Id);\n@@ -3085,8 +3078,10 @@ package body Einfo is\n \n    function Predicated_Parent (Id : E) return E is\n    begin\n-      pragma Assert (Is_Type (Id));\n-      return Node36 (Id);\n+      pragma Assert (Ekind_In (Id, E_Array_Subtype,\n+                                   E_Record_Subtype,\n+                                   E_Record_Subtype_With_Private));\n+      return Node38 (Id);\n    end Predicated_Parent;\n \n    function Predicates_Ignored (Id : E) return B is\n@@ -3095,6 +3090,11 @@ package body Einfo is\n       return Flag288 (Id);\n    end Predicates_Ignored;\n \n+   function Prev_Entity (Id : E) return E is\n+   begin\n+      return Node36 (Id);\n+   end Prev_Entity;\n+\n    function Prival (Id : E) return E is\n    begin\n       pragma Assert (Is_Protected_Component (Id));\n@@ -3593,7 +3593,7 @@ package body Einfo is\n    function Validated_Object (Id : E) return N is\n    begin\n       pragma Assert (Ekind (Id) = E_Variable);\n-      return Node36 (Id);\n+      return Node38 (Id);\n    end Validated_Object;\n \n    function Warnings_Off (Id : E) return B is\n@@ -6111,14 +6111,6 @@ package body Einfo is\n       Set_Flag22 (Id, V);\n    end Set_Needs_No_Actuals;\n \n-   procedure Set_Nested_Scenarios (Id : E; V : L) is\n-   begin\n-      pragma Assert (Ekind_In (Id, E_Function,\n-                                   E_Procedure,\n-                                   E_Subprogram_Body));\n-      Set_Elist36 (Id, V);\n-   end Set_Nested_Scenarios;\n-\n    procedure Set_Never_Set_In_Source (Id : E; V : B := True) is\n    begin\n       Set_Flag115 (Id, V);\n@@ -6320,8 +6312,10 @@ package body Einfo is\n \n    procedure Set_Predicated_Parent (Id : E; V : E) is\n    begin\n-      pragma Assert (Is_Type (Id));\n-      Set_Node36 (Id, V);\n+      pragma Assert (Ekind_In (Id, E_Array_Subtype,\n+                                   E_Record_Subtype,\n+                                   E_Record_Subtype_With_Private));\n+      Set_Node38 (Id, V);\n    end Set_Predicated_Parent;\n \n    procedure Set_Predicates_Ignored (Id : E; V : B) is\n@@ -6360,6 +6354,11 @@ package body Einfo is\n       Set_Node22 (Id, V);\n    end Set_Private_View;\n \n+   procedure Set_Prev_Entity (Id : E; V : E) is\n+   begin\n+      Set_Node36 (Id, V);\n+   end Set_Prev_Entity;\n+\n    procedure Set_Protected_Body_Subprogram (Id : E; V : E) is\n    begin\n       pragma Assert (Is_Subprogram (Id) or else Is_Entry (Id));\n@@ -6848,7 +6847,7 @@ package body Einfo is\n    procedure Set_Validated_Object (Id : E; V : N) is\n    begin\n       pragma Assert (Ekind (Id) = E_Variable);\n-      Set_Node36 (Id, V);\n+      Set_Node38 (Id, V);\n    end Set_Validated_Object;\n \n    procedure Set_Warnings_Off (Id : E; V : B := True) is\n@@ -7202,17 +7201,31 @@ package body Einfo is\n    -- Append_Entity --\n    -------------------\n \n-   procedure Append_Entity (Id : Entity_Id; V : Entity_Id) is\n+   procedure Append_Entity (Id : Entity_Id; Scop : Entity_Id) is\n+      Last : constant Entity_Id := Last_Entity (Scop);\n+\n    begin\n-      if Last_Entity (V) = Empty then\n-         Set_First_Entity (Id => V, V => Id);\n+      Set_Scope (Id, Scop);\n+      Set_Prev_Entity (Id, Empty);  --  Empty <-- Id\n+\n+      --  The entity chain is empty\n+\n+      if No (Last) then\n+         Set_First_Entity (Scop, Id);\n+\n+      --  Otherwise the entity chain has at least one element\n+\n       else\n-         Set_Next_Entity (Last_Entity (V), Id);\n+         Link_Entities (Last, Id);  --  Last <-- Id, Last --> Id\n       end if;\n \n-      Set_Next_Entity (Id, Empty);\n-      Set_Scope (Id, V);\n-      Set_Last_Entity (Id => V, V => Id);\n+      --  NOTE: The setting of the Next_Entity attribute of Id must happen\n+      --  here as opposed to at the beginning of the routine because doing\n+      --  so causes the binder to hang. It is not clear why ???\n+\n+      Set_Next_Entity (Id, Empty);  --  Id --> Empty\n+\n+      Set_Last_Entity (Scop, Id);\n    end Append_Entity;\n \n    ---------------\n@@ -8377,6 +8390,23 @@ package body Einfo is\n       end if;\n    end Last_Formal;\n \n+   -------------------\n+   -- Link_Entities --\n+   -------------------\n+\n+   procedure Link_Entities (First : Entity_Id; Second : Node_Id) is\n+   begin\n+      if Present (Second) then\n+         Set_Prev_Entity (Second, First);  --  First <-- Second\n+      end if;\n+\n+      Set_Next_Entity (First, Second);     --  First --> Second\n+   end Link_Entities;\n+\n+   ----------------------\n+   -- Model_Emin_Value --\n+   ----------------------\n+\n    function Model_Emin_Value (Id : E) return Uint is\n    begin\n       return Machine_Emin_Value (Id);\n@@ -8842,7 +8872,11 @@ package body Einfo is\n       then\n          Typ := Full_View (Id);\n \n-      elsif Is_Itype (Id) and then Present (Predicated_Parent (Id)) then\n+      elsif Ekind_In (Id, E_Array_Subtype,\n+                          E_Record_Subtype,\n+                          E_Record_Subtype_With_Private)\n+        and then Present (Predicated_Parent (Id))\n+      then\n          Typ := Predicated_Parent (Id);\n \n       else\n@@ -8972,6 +9006,47 @@ package body Einfo is\n       Set_First_Rep_Item (E, N);\n    end Record_Rep_Item;\n \n+   -------------------\n+   -- Remove_Entity --\n+   -------------------\n+\n+   procedure Remove_Entity (Id : Entity_Id) is\n+      Next  : constant Entity_Id := Next_Entity (Id);\n+      Prev  : constant Entity_Id := Prev_Entity (Id);\n+      Scop  : constant Entity_Id := Scope (Id);\n+      First : constant Entity_Id := First_Entity (Scop);\n+      Last  : constant Entity_Id := Last_Entity  (Scop);\n+\n+   begin\n+      --  Eliminate any existing linkages from the entity\n+\n+      Set_Prev_Entity (Id, Empty);  --  Empty <-- Id\n+      Set_Next_Entity (Id, Empty);  --  Id --> Empty\n+\n+      --  The eliminated entity was the only element in the entity chain\n+\n+      if Id = First and then Id = Last then\n+         Set_First_Entity (Scop, Empty);\n+         Set_Last_Entity  (Scop, Empty);\n+\n+      --  The eliminated entity was the head of the entity chain\n+\n+      elsif Id = First then\n+         Set_First_Entity (Scop, Next);\n+\n+      --  The eliminated entity was the tail of the entity chain\n+\n+      elsif Id = Last then\n+         Set_Last_Entity (Scop, Prev);\n+\n+      --  Otherwise the eliminated entity comes from the middle of the entity\n+      --  chain.\n+\n+      else\n+         Link_Entities (Prev, Next);  --  Prev <-- Next, Prev --> Next\n+      end if;\n+   end Remove_Entity;\n+\n    ---------------\n    -- Root_Type --\n    ---------------\n@@ -9522,6 +9597,21 @@ package body Einfo is\n       end if;\n    end Underlying_Type;\n \n+   ------------------------\n+   -- Unlink_Next_Entity --\n+   ------------------------\n+\n+   procedure Unlink_Next_Entity (Id : Entity_Id) is\n+      Next : constant Entity_Id := Next_Entity (Id);\n+\n+   begin\n+      if Present (Next) then\n+         Set_Prev_Entity (Next, Empty);  --  Empty <-- Next\n+      end if;\n+\n+      Set_Next_Entity (Id, Empty);       --  Id --> Empty\n+   end Unlink_Next_Entity;\n+\n    ------------------------\n    -- Write_Entity_Flags --\n    ------------------------\n@@ -10825,6 +10915,9 @@ package body Einfo is\n    procedure Write_Field24_Name (Id : Entity_Id) is\n    begin\n       case Ekind (Id) is\n+         when E_Package =>\n+            Write_Str (\"Incomplete_Actuals\");\n+\n          when Type_Kind\n             | E_Constant\n             | E_Variable\n@@ -10837,9 +10930,6 @@ package body Einfo is\n          =>\n             Write_Str (\"Subps_Index\");\n \n-         when E_Package =>\n-            Write_Str (\"Incomplete_Actuals\");\n-\n          when others =>\n             Write_Str (\"Field24???\");\n       end case;\n@@ -11205,25 +11295,9 @@ package body Einfo is\n    ------------------------\n \n    procedure Write_Field36_Name (Id : Entity_Id) is\n+      pragma Unreferenced (Id);\n    begin\n-      case Ekind (Id) is\n-         when E_Function\n-            | E_Procedure\n-            | E_Subprogram_Body\n-         =>\n-            Write_Str (\"Nested_Scenarios\");\n-\n-         when E_Variable =>\n-            Write_Str (\"Validated_Object\");\n-\n-         when E_Array_Subtype\n-            | E_Record_Subtype\n-         =>\n-            Write_Str (\"predicated parent\");\n-\n-         when others =>\n-            Write_Str (\"Field36??\");\n-      end case;\n+      Write_Str (\"Prev_Entity\");\n    end Write_Field36_Name;\n \n    ------------------------\n@@ -11246,7 +11320,16 @@ package body Einfo is\n          when E_Function\n             | E_Procedure\n          =>\n-            Write_Str (\"class-wide clone\");\n+            Write_Str (\"Class_Wide_Clone\");\n+\n+         when E_Array_Subtype\n+            | E_Record_Subtype\n+            | E_Record_Subtype_With_Private\n+         =>\n+            Write_Str (\"Predicated_Parent\");\n+\n+         when E_Variable =>\n+            Write_Str (\"Validated_Object\");\n \n          when others =>\n             Write_Str (\"Field38??\");"}, {"sha": "e6dea67ac314fe2b89822847bc99d6d8c3dbfeab", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 33, "deletions": 20, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f6d1daa7cc592e13db95a9402762b525a317566/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f6d1daa7cc592e13db95a9402762b525a317566/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=3f6d1daa7cc592e13db95a9402762b525a317566", "patch": "@@ -3549,14 +3549,6 @@ package Einfo is\n --       interpreted as an indexing of the result of the call. It is also\n --       used to resolve various cases of entry calls.\n \n---    Nested_Scenarios (Elist36)\n---       Present in [stand alone] subprogram bodies. The list contains all\n---       nested scenarios (see the terminology in Sem_Elab) which appear within\n---       the declarations, statements, and exception handlers of the subprogram\n---       body. The list improves the performance of the ABE Processing phase by\n---       avoiding a full tree traversal when the same subprogram body is part\n---       of several distinct paths in the elaboration graph.\n-\n --    Never_Set_In_Source (Flag115)\n --       Defined in all entities, but can be set only for variables and\n --       parameters. This flag is set if the object is never assigned a value\n@@ -3932,7 +3924,7 @@ package Einfo is\n --       is the special version created for membership tests, where if one of\n --       these raise expressions is executed, the result is to return False.\n \n---    Predicated_Parent (Node36)\n+--    Predicated_Parent (Node38)\n --       Defined on itypes created by subtype indications, when the parent\n --       subtype has predicates. The itype shares the Predicate_Function\n --       of the predicated parent, but this function may not have been built\n@@ -3945,6 +3937,11 @@ package Einfo is\n --       a context where Assertion_Policy is Ignore, in which case no checks\n --       (static or dynamic) must be generated for objects of the type.\n \n+--    Prev_Entity (Node36)\n+--       Defined in all entities. The entities of a scope are chained, and this\n+--       field is used as a backward pointer for this entity list - effectivly\n+--       making the entity chain doubly-linked.\n+\n --    Primitive_Operations (synthesized)\n --       Defined in concurrent types, tagged record types and subtypes, tagged\n --       private types and tagged incomplete types. For concurrent types whose\n@@ -4625,7 +4622,7 @@ package Einfo is\n --       in this scope and must be released on exit unless flag\n --       Sec_Stack_Needed_For_Return is set.\n \n---    Validated_Object (Node36)\n+--    Validated_Object (Node38)\n --       Defined in variables. Contains the object whose value is captured by\n --       the variable for validity check purposes.\n \n@@ -5554,6 +5551,7 @@ package Einfo is\n    --    Etype                               (Node5)\n    --    First_Rep_Item                      (Node6)\n    --    Freeze_Node                         (Node7)\n+   --    Prev_Entity                         (Node36)\n    --    Associated_Entity                   (Node37)\n \n    --    Address_Taken                       (Flag104)\n@@ -5860,6 +5858,7 @@ package Einfo is\n    --    Component_Size                      (Uint22)   (base type only)\n    --    Packed_Array_Impl_Type              (Node23)\n    --    Related_Array_Object                (Node25)\n+   --    Predicated_Parent                   (Node38)   (subtype only)\n    --    Component_Alignment                 (special)  (base type only)\n    --    Has_Component_Size_Clause           (Flag68)   (base type only)\n    --    Has_Pragma_Pack                     (Flag121)  (impl base type only)\n@@ -6157,7 +6156,6 @@ package Einfo is\n    --    Linker_Section_Pragma               (Node33)\n    --    Contract                            (Node34)\n    --    Import_Pragma                       (Node35)   (non-generic case only)\n-   --    Nested_Scenarios                    (Elist36)\n    --    Class_Wide_Clone                    (Node38)\n    --    Protected_Subprogram                (Node39)   (non-generic case only)\n    --    SPARK_Pragma                        (Node40)\n@@ -6486,7 +6484,6 @@ package Einfo is\n    --    Linker_Section_Pragma               (Node33)\n    --    Contract                            (Node34)\n    --    Import_Pragma                       (Node35)   (non-generic case only)\n-   --    Nested_Scenarios                    (Elist36)\n    --    Class_Wide_Clone                    (Node38)\n    --    Protected_Subprogram                (Node39)   (non-generic case only)\n    --    SPARK_Pragma                        (Node40)\n@@ -6597,6 +6594,7 @@ package Einfo is\n    --    Dispatch_Table_Wrappers             (Elist26)  (base type only)\n    --    Underlying_Record_View              (Node28)   (base type only)\n    --    Access_Disp_Table_Elab_Flag         (Node30)   (base type only)\n+   --    Predicated_Parent                   (Node38)   (subtype only)\n    --    Component_Alignment                 (special)  (base type only)\n    --    C_Pass_By_Copy                      (Flag125)  (base type only)\n    --    Has_Dispatch_Table                  (Flag220)  (base tagged type only)\n@@ -6631,6 +6629,7 @@ package Einfo is\n    --    Private_View                        (Node22)\n    --    Stored_Constraint                   (Elist23)\n    --    Interfaces                          (Elist25)\n+   --    Predicated_Parent                   (Node38)   (subtype only)\n    --    Has_Completion                      (Flag26)\n    --    Has_Private_Ancestor                (Flag151)\n    --    Has_Private_Extension               (Flag300)\n@@ -6681,7 +6680,6 @@ package Einfo is\n    --    Extra_Formals                       (Node28)\n    --    Anonymous_Masters                   (Elist29)\n    --    Contract                            (Node34)\n-   --    Nested_Scenarios                    (Elist36)\n    --    SPARK_Pragma                        (Node40)\n    --    Contains_Ignored_Ghost_Code         (Flag279)\n    --    SPARK_Pragma_Inherited              (Flag265)\n@@ -6764,7 +6762,7 @@ package Einfo is\n    --    Linker_Section_Pragma               (Node33)\n    --    Contract                            (Node34)\n    --    Anonymous_Designated_Type           (Node35)\n-   --    Validated_Object                    (Node36)\n+   --    Validated_Object                    (Node38)\n    --    SPARK_Pragma                        (Node40)\n    --    Has_Alignment_Clause                (Flag46)\n    --    Has_Atomic_Components               (Flag86)\n@@ -7402,7 +7400,6 @@ package Einfo is\n    function Must_Have_Preelab_Init              (Id : E) return B;\n    function Needs_Debug_Info                    (Id : E) return B;\n    function Needs_No_Actuals                    (Id : E) return B;\n-   function Nested_Scenarios                    (Id : E) return L;\n    function Never_Set_In_Source                 (Id : E) return B;\n    function Next_Inlined_Subprogram             (Id : E) return E;\n    function No_Dynamic_Predicate_On_Actual      (Id : E) return B;\n@@ -7437,6 +7434,7 @@ package Einfo is\n    function Postconditions_Proc                 (Id : E) return E;\n    function Predicated_Parent                   (Id : E) return E;\n    function Predicates_Ignored                  (Id : E) return B;\n+   function Prev_Entity                         (Id : E) return E;\n    function Prival                              (Id : E) return E;\n    function Prival_Link                         (Id : E) return E;\n    function Private_Dependents                  (Id : E) return L;\n@@ -8106,7 +8104,6 @@ package Einfo is\n    procedure Set_Must_Have_Preelab_Init          (Id : E; V : B := True);\n    procedure Set_Needs_Debug_Info                (Id : E; V : B := True);\n    procedure Set_Needs_No_Actuals                (Id : E; V : B := True);\n-   procedure Set_Nested_Scenarios                (Id : E; V : L);\n    procedure Set_Never_Set_In_Source             (Id : E; V : B := True);\n    procedure Set_Next_Inlined_Subprogram         (Id : E; V : E);\n    procedure Set_No_Dynamic_Predicate_On_Actual  (Id : E; V : B := True);\n@@ -8139,6 +8136,7 @@ package Einfo is\n    procedure Set_Partial_View_Has_Unknown_Discr  (Id : E; V : B := True);\n    procedure Set_Pending_Access_Types            (Id : E; V : L);\n    procedure Set_Postconditions_Proc             (Id : E; V : E);\n+   procedure Set_Prev_Entity                     (Id : E; V : E);\n    procedure Set_Prival                          (Id : E; V : E);\n    procedure Set_Prival_Link                     (Id : E; V : E);\n    procedure Set_Private_Dependents              (Id : E; V : L);\n@@ -8468,8 +8466,8 @@ package Einfo is\n    -- Miscellaneous Subprograms --\n    -------------------------------\n \n-   procedure Append_Entity (Id : Entity_Id; V : Entity_Id);\n-   --  Add an entity to the list of entities declared in the scope V\n+   procedure Append_Entity (Id : Entity_Id; Scop : Entity_Id);\n+   --  Add an entity to the list of entities declared in the scope Scop\n \n    function Get_Full_View (T : Entity_Id) return Entity_Id;\n    --  If T is an incomplete type and the full declaration has been seen, or\n@@ -8480,11 +8478,20 @@ package Einfo is\n    --  Test if the node N is the name of an entity (i.e. is an identifier,\n    --  expanded name, or an attribute reference that returns an entity).\n \n+   procedure Link_Entities (First : Entity_Id; Second : Entity_Id);\n+   --  Link entities First and Second in one entity chain.\n+   --\n+   --  NOTE: No updates are done to the First_Entity and Last_Entity fields\n+   --  of the scope.\n+\n    function Next_Index (Id : Node_Id) return Node_Id;\n    --  Given an index from a previous call to First_Index or Next_Index,\n    --  returns a node representing the occurrence of the next index subtype,\n    --  or Empty if there are no more index subtypes.\n \n+   procedure Remove_Entity (Id : Entity_Id);\n+   --  Remove entity Id from the entity chain of its scope\n+\n    function Scope_Depth (Id : Entity_Id) return Uint;\n    --  Returns the scope depth value of the Id, unless the Id is a record\n    --  type, in which case it returns the scope depth of the record scope.\n@@ -8496,6 +8503,9 @@ package Einfo is\n    --  is returned. If K is already a subtype kind it itself is returned. An\n    --  internal error is generated if no such correspondence exists for K.\n \n+   procedure Unlink_Next_Entity (Id : Entity_Id);\n+   --  Unchain entity Id's forward link within the entity chain of its scope\n+\n    ----------------------------------\n    -- Debugging Output Subprograms --\n    ----------------------------------\n@@ -8948,6 +8958,7 @@ package Einfo is\n    pragma Inline (Last_Assignment);\n    pragma Inline (Last_Entity);\n    pragma Inline (Limited_View);\n+   pragma Inline (Link_Entities);\n    pragma Inline (Linker_Section_Pragma);\n    pragma Inline (Lit_Indexes);\n    pragma Inline (Lit_Strings);\n@@ -8962,7 +8973,6 @@ package Einfo is\n    pragma Inline (Must_Have_Preelab_Init);\n    pragma Inline (Needs_Debug_Info);\n    pragma Inline (Needs_No_Actuals);\n-   pragma Inline (Nested_Scenarios);\n    pragma Inline (Never_Set_In_Source);\n    pragma Inline (Next_Index);\n    pragma Inline (Next_Inlined_Subprogram);\n@@ -9000,6 +9010,7 @@ package Einfo is\n    pragma Inline (Postconditions_Proc);\n    pragma Inline (Predicated_Parent);\n    pragma Inline (Predicates_Ignored);\n+   pragma Inline (Prev_Entity);\n    pragma Inline (Prival);\n    pragma Inline (Prival_Link);\n    pragma Inline (Private_Dependents);\n@@ -9020,6 +9031,7 @@ package Einfo is\n    pragma Inline (Related_Instance);\n    pragma Inline (Related_Type);\n    pragma Inline (Relative_Deadline_Variable);\n+   pragma Inline (Remove_Entity);\n    pragma Inline (Renamed_Entity);\n    pragma Inline (Renamed_In_Spec);\n    pragma Inline (Renamed_Object);\n@@ -9072,6 +9084,7 @@ package Einfo is\n    pragma Inline (Underlying_Full_View);\n    pragma Inline (Underlying_Record_View);\n    pragma Inline (Universal_Aliasing);\n+   pragma Inline (Unlink_Next_Entity);\n    pragma Inline (Unset_Reference);\n    pragma Inline (Used_As_Generic_Actual);\n    pragma Inline (Uses_Lock_Free);\n@@ -9453,7 +9466,6 @@ package Einfo is\n    pragma Inline (Set_Must_Have_Preelab_Init);\n    pragma Inline (Set_Needs_Debug_Info);\n    pragma Inline (Set_Needs_No_Actuals);\n-   pragma Inline (Set_Nested_Scenarios);\n    pragma Inline (Set_Never_Set_In_Source);\n    pragma Inline (Set_Next_Inlined_Subprogram);\n    pragma Inline (Set_No_Dynamic_Predicate_On_Actual);\n@@ -9488,6 +9500,7 @@ package Einfo is\n    pragma Inline (Set_Postconditions_Proc);\n    pragma Inline (Set_Predicated_Parent);\n    pragma Inline (Set_Predicates_Ignored);\n+   pragma Inline (Set_Prev_Entity);\n    pragma Inline (Set_Prival);\n    pragma Inline (Set_Prival_Link);\n    pragma Inline (Set_Private_Dependents);"}, {"sha": "30d66057962858d730da5619d8f670f1c8ee5c94", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f6d1daa7cc592e13db95a9402762b525a317566/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f6d1daa7cc592e13db95a9402762b525a317566/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=3f6d1daa7cc592e13db95a9402762b525a317566", "patch": "@@ -2110,12 +2110,11 @@ package body Exp_Attr is\n                            Next_Formal (Old_Formal);\n                            exit when No (Old_Formal);\n \n-                           Set_Next_Entity (New_Formal,\n-                             New_Copy (Old_Formal));\n-                           Next_Entity (New_Formal);\n+                           Link_Entities (New_Formal, New_Copy (Old_Formal));\n+                           Next_Entity   (New_Formal);\n                         end loop;\n \n-                        Set_Next_Entity (New_Formal, Empty);\n+                        Unlink_Next_Entity (New_Formal);\n                         Set_Last_Entity (Subp_Typ, Extra);\n                      end if;\n "}, {"sha": "a8e24995c465aded58d9ab823ed3903e7f9535ba", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f6d1daa7cc592e13db95a9402762b525a317566/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f6d1daa7cc592e13db95a9402762b525a317566/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=3f6d1daa7cc592e13db95a9402762b525a317566", "patch": "@@ -6785,8 +6785,8 @@ package body Exp_Ch3 is\n                                    SPARK_Pragma_Inherited (Def_Id);\n \n                   begin\n-                     Set_Next_Entity (New_Id, Next_Entity (Def_Id));\n-                     Set_Next_Entity (Def_Id, Next_Temp);\n+                     Link_Entities (New_Id, Next_Entity (Def_Id));\n+                     Link_Entities (Def_Id, Next_Temp);\n \n                      Set_Chars   (Defining_Identifier (N), Chars   (Def_Id));\n                      Set_Homonym (Defining_Identifier (N), Homonym (Def_Id));"}, {"sha": "3395c2122fb97907cf05882ef3c70c67740fab0b", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f6d1daa7cc592e13db95a9402762b525a317566/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f6d1daa7cc592e13db95a9402762b525a317566/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=3f6d1daa7cc592e13db95a9402762b525a317566", "patch": "@@ -9201,8 +9201,8 @@ package body Exp_Ch6 is\n       declare\n          Next_Id : constant Entity_Id := Next_Entity (New_Id);\n       begin\n-         Set_Next_Entity (New_Id, Next_Entity (Orig_Id));\n-         Set_Next_Entity (Orig_Id, Next_Id);\n+         Link_Entities (New_Id, Next_Entity (Orig_Id));\n+         Link_Entities (Orig_Id, Next_Id);\n       end;\n \n       Set_Homonym (New_Id, Homonym (Orig_Id));"}, {"sha": "dbccfedebe29c8bc0842629f6d178d0e19b9b062", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f6d1daa7cc592e13db95a9402762b525a317566/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f6d1daa7cc592e13db95a9402762b525a317566/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=3f6d1daa7cc592e13db95a9402762b525a317566", "patch": "@@ -1030,12 +1030,12 @@ package body Exp_Disp is\n                Next_Formal (Old_Formal);\n                exit when No (Old_Formal);\n \n-               Set_Next_Entity (New_Formal, New_Copy (Old_Formal));\n-               Next_Entity (New_Formal);\n-               Next_Actual (Param);\n+               Link_Entities (New_Formal, New_Copy (Old_Formal));\n+               Next_Entity   (New_Formal);\n+               Next_Actual   (Param);\n             end loop;\n \n-            Set_Next_Entity (New_Formal, Empty);\n+            Unlink_Next_Entity (New_Formal);\n             Set_Last_Entity (Subp_Typ, Extra);\n          end if;\n "}, {"sha": "f59e5f3874ad018f60f1a5726e34bf46cb3303f2", "filename": "gcc/ada/exp_spark.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f6d1daa7cc592e13db95a9402762b525a317566/gcc%2Fada%2Fexp_spark.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f6d1daa7cc592e13db95a9402762b525a317566/gcc%2Fada%2Fexp_spark.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_spark.adb?ref=3f6d1daa7cc592e13db95a9402762b525a317566", "patch": "@@ -386,7 +386,7 @@ package body Exp_SPARK is\n          --  Remove the entity of the renaming declaration from visibility as\n          --  the analysis of the object declaration will reintroduce it again.\n \n-         Remove_Entity (Obj_Id);\n+         Remove_Entity_And_Homonym (Obj_Id);\n          Analyze (N);\n \n       --  Otherwise unconditionally remove all side effects from the name"}, {"sha": "256f6bb9fff30b68908dad2b810fc4461a895a02", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f6d1daa7cc592e13db95a9402762b525a317566/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f6d1daa7cc592e13db95a9402762b525a317566/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=3f6d1daa7cc592e13db95a9402762b525a317566", "patch": "@@ -10613,6 +10613,7 @@ package body Exp_Util is\n       Set_Is_Itype                  (Res);\n       Set_Is_Public                 (Res, False);\n       Set_Next_Entity               (Res, Empty);\n+      Set_Prev_Entity               (Res, Empty);\n       Set_Sloc                      (Res, Sloc (N));\n \n       Set_Public_Status (Res);"}, {"sha": "a27561968bed9132b2b37ef88dff3b9440f2cb62", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f6d1daa7cc592e13db95a9402762b525a317566/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f6d1daa7cc592e13db95a9402762b525a317566/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=3f6d1daa7cc592e13db95a9402762b525a317566", "patch": "@@ -4321,7 +4321,7 @@ package body Freeze is\n \n                   else\n                      if Present (Prev) then\n-                        Set_Next_Entity (Prev, Next_Entity (Comp));\n+                        Link_Entities (Prev, Next_Entity (Comp));\n                      else\n                         Set_First_Entity (Rec, Next_Entity (Comp));\n                      end if;"}, {"sha": "f3ba0691ce59ca463867a1630bd7c9fcbdcb5626", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f6d1daa7cc592e13db95a9402762b525a317566/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f6d1daa7cc592e13db95a9402762b525a317566/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=3f6d1daa7cc592e13db95a9402762b525a317566", "patch": "@@ -6609,6 +6609,7 @@ package body Sem_Ch3 is\n                            Create_Itype (Ekind (Pbase), N, Derived_Type, 'B');\n             Svg_Chars  : constant Name_Id   := Chars (Ibase);\n             Svg_Next_E : constant Entity_Id := Next_Entity (Ibase);\n+            Svg_Prev_E : constant Entity_Id := Prev_Entity (Ibase);\n \n          begin\n             Copy_Node (Pbase, Ibase);\n@@ -6619,6 +6620,7 @@ package body Sem_Ch3 is\n             Set_Associated_Node_For_Itype (Ibase, N);\n \n             Set_Chars             (Ibase, Svg_Chars);\n+            Set_Prev_Entity       (Ibase, Svg_Prev_E);\n             Set_Next_Entity       (Ibase, Svg_Next_E);\n             Set_Sloc              (Ibase, Sloc (Derived_Type));\n             Set_Scope             (Ibase, Scope (Derived_Type));\n@@ -7042,7 +7044,7 @@ package body Sem_Ch3 is\n             if No (Next_Entity (Old_Disc))\n               or else Ekind (Next_Entity (Old_Disc)) /= E_Discriminant\n             then\n-               Set_Next_Entity\n+               Link_Entities\n                  (Last_Entity (Derived_Type), Next_Entity (Old_Disc));\n                exit;\n             end if;\n@@ -9431,8 +9433,8 @@ package body Sem_Ch3 is\n          --  Restore the fields saved prior to the New_Copy_Tree call\n          --  and compute the stored constraint.\n \n-         Set_Etype       (Derived_Type, Save_Etype);\n-         Set_Next_Entity (Derived_Type, Save_Next_Entity);\n+         Set_Etype     (Derived_Type, Save_Etype);\n+         Link_Entities (Derived_Type, Save_Next_Entity);\n \n          if Has_Discriminants (Derived_Type) then\n             Set_Discriminant_Constraint\n@@ -12324,7 +12326,7 @@ package body Sem_Ch3 is\n             Set_Sloc          (Full, Sloc (Priv));\n       end case;\n \n-      Set_Next_Entity               (Full, Save_Next_Entity);\n+      Link_Entities                 (Full, Save_Next_Entity);\n       Set_Homonym                   (Full, Save_Homonym);\n       Set_Associated_Node_For_Itype (Full, Related_Nod);\n \n@@ -14424,6 +14426,7 @@ package body Sem_Ch3 is\n       Set_Is_Volatile                (Full, Is_Volatile             (Priv));\n       Set_Treat_As_Volatile          (Full, Treat_As_Volatile       (Priv));\n       Set_Scope                      (Full, Scope                   (Priv));\n+      Set_Prev_Entity                (Full, Prev_Entity             (Priv));\n       Set_Next_Entity                (Full, Next_Entity             (Priv));\n       Set_First_Entity               (Full, First_Entity            (Priv));\n       Set_Last_Entity                (Full, Last_Entity             (Priv));\n@@ -18942,6 +18945,7 @@ package body Sem_Ch3 is\n       CW_Type : Entity_Id;\n       CW_Name : Name_Id;\n       Next_E  : Entity_Id;\n+      Prev_E  : Entity_Id;\n \n    begin\n       if Present (Class_Wide_Type (T)) then\n@@ -18974,10 +18978,12 @@ package body Sem_Ch3 is\n \n       CW_Name := Chars (CW_Type);\n       Next_E  := Next_Entity (CW_Type);\n+      Prev_E  := Prev_Entity (CW_Type);\n       Copy_Node (T, CW_Type);\n       Set_Comes_From_Source (CW_Type, False);\n       Set_Chars (CW_Type, CW_Name);\n       Set_Parent (CW_Type, Parent (T));\n+      Set_Prev_Entity (CW_Type, Prev_E);\n       Set_Next_Entity (CW_Type, Next_E);\n \n       --  Ensure we have a new freeze node for the class-wide type. The partial\n@@ -21761,7 +21767,7 @@ package body Sem_Ch3 is\n \n             --  Indicate where the predicate function may be found\n \n-            if No (Predicate_Function (Def_Id)) then\n+            if No (Predicate_Function (Def_Id)) and then Is_Itype (Def_Id) then\n                Set_Predicated_Parent (Def_Id, Subtype_Mark_Id);\n             end if;\n          end if;"}, {"sha": "5eab1e0394d2c0e738bec947e99bb56c5e7fedfb", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 128, "deletions": 168, "changes": 296, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f6d1daa7cc592e13db95a9402762b525a317566/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f6d1daa7cc592e13db95a9402762b525a317566/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=3f6d1daa7cc592e13db95a9402762b525a317566", "patch": "@@ -4516,7 +4516,7 @@ package body Sem_Ch6 is\n             --  Body entities present (formals), so chain stuff past them\n \n             else\n-               Set_Next_Entity\n+               Link_Entities\n                  (Last_Entity (Body_Id), Next_Entity (Last_Real_Spec_Entity));\n             end if;\n \n@@ -10059,9 +10059,6 @@ package body Sem_Ch6 is\n       E : Entity_Id;\n       --  Entity that S overrides\n \n-      Prev_Vis : Entity_Id := Empty;\n-      --  Predecessor of E in Homonym chain\n-\n       procedure Check_For_Primitive_Subprogram\n         (Is_Primitive  : out Boolean;\n          Is_Overriding : Boolean := False);\n@@ -11022,198 +11019,161 @@ package body Sem_Ch6 is\n \n                   Overridden_Subp := E;\n \n-                  declare\n-                     Prev : Entity_Id;\n-\n-                  begin\n-                     Prev := First_Entity (Current_Scope);\n-                     while Present (Prev) and then Next_Entity (Prev) /= E loop\n-                        Next_Entity (Prev);\n-                     end loop;\n-\n-                     --  It is possible for E to be in the current scope and\n-                     --  yet not in the entity chain. This can only occur in a\n-                     --  generic context where E is an implicit concatenation\n-                     --  in the formal part, because in a generic body the\n-                     --  entity chain starts with the formals.\n+                  --  It is possible for E to be in the current scope and\n+                  --  yet not in the entity chain. This can only occur in a\n+                  --  generic context where E is an implicit concatenation\n+                  --  in the formal part, because in a generic body the\n+                  --  entity chain starts with the formals.\n \n-                     --  In GNATprove mode, a wrapper for an operation with\n-                     --  axiomatization may be a homonym of another declaration\n-                     --  for an actual subprogram (needs refinement ???).\n+                  --  In GNATprove mode, a wrapper for an operation with\n+                  --  axiomatization may be a homonym of another declaration\n+                  --  for an actual subprogram (needs refinement ???).\n \n-                     if No (Prev) then\n-                        if In_Instance\n-                          and then GNATprove_Mode\n-                          and then\n-                            Nkind (Original_Node (Unit_Declaration_Node (S))) =\n-                                             N_Subprogram_Renaming_Declaration\n-                        then\n-                           return;\n-                        else\n-                           pragma Assert (Chars (E) = Name_Op_Concat);\n-                           null;\n-                        end if;\n+                  if No (Prev_Entity (E)) then\n+                     if In_Instance\n+                       and then GNATprove_Mode\n+                       and then\n+                         Nkind (Original_Node (Unit_Declaration_Node (S))) =\n+                                          N_Subprogram_Renaming_Declaration\n+                     then\n+                        return;\n+                     else\n+                        pragma Assert (Chars (E) = Name_Op_Concat);\n+                        null;\n                      end if;\n+                  end if;\n \n-                     --  E must be removed both from the entity_list of the\n-                     --  current scope, and from the visibility chain.\n-\n-                     if Debug_Flag_E then\n-                        Write_Str (\"Override implicit operation \");\n-                        Write_Int (Int (E));\n-                        Write_Eol;\n-                     end if;\n+                  --  E must be removed both from the entity_list of the\n+                  --  current scope, and from the visibility chain.\n \n-                     --  If E is a predefined concatenation, it stands for four\n-                     --  different operations. As a result, a single explicit\n-                     --  declaration does not hide it. In a possible ambiguous\n-                     --  situation, Disambiguate chooses the user-defined op,\n-                     --  so it is correct to retain the previous internal one.\n+                  if Debug_Flag_E then\n+                     Write_Str (\"Override implicit operation \");\n+                     Write_Int (Int (E));\n+                     Write_Eol;\n+                  end if;\n \n-                     if Chars (E) /= Name_Op_Concat\n-                       or else Ekind (E) /= E_Operator\n-                     then\n-                        --  For nondispatching derived operations that are\n-                        --  overridden by a subprogram declared in the private\n-                        --  part of a package, we retain the derived subprogram\n-                        --  but mark it as not immediately visible. If the\n-                        --  derived operation was declared in the visible part\n-                        --  then this ensures that it will still be visible\n-                        --  outside the package with the proper signature\n-                        --  (calls from outside must also be directed to this\n-                        --  version rather than the overriding one, unlike the\n-                        --  dispatching case). Calls from inside the package\n-                        --  will still resolve to the overriding subprogram\n-                        --  since the derived one is marked as not visible\n-                        --  within the package.\n-\n-                        --  If the private operation is dispatching, we achieve\n-                        --  the overriding by keeping the implicit operation\n-                        --  but setting its alias to be the overriding one. In\n-                        --  this fashion the proper body is executed in all\n-                        --  cases, but the original signature is used outside\n-                        --  of the package.\n-\n-                        --  If the overriding is not in the private part, we\n-                        --  remove the implicit operation altogether.\n-\n-                        if Is_Private_Declaration (S) then\n-                           if not Is_Dispatching_Operation (E) then\n-                              Set_Is_Immediately_Visible (E, False);\n-                           else\n-                              --  Work done in Override_Dispatching_Operation,\n-                              --  so nothing else needs to be done here.\n-\n-                              null;\n-                           end if;\n+                  --  If E is a predefined concatenation, it stands for four\n+                  --  different operations. As a result, a single explicit\n+                  --  declaration does not hide it. In a possible ambiguous\n+                  --  situation, Disambiguate chooses the user-defined op,\n+                  --  so it is correct to retain the previous internal one.\n \n+                  if Chars (E) /= Name_Op_Concat\n+                    or else Ekind (E) /= E_Operator\n+                  then\n+                     --  For nondispatching derived operations that are\n+                     --  overridden by a subprogram declared in the private\n+                     --  part of a package, we retain the derived subprogram\n+                     --  but mark it as not immediately visible. If the\n+                     --  derived operation was declared in the visible part\n+                     --  then this ensures that it will still be visible\n+                     --  outside the package with the proper signature\n+                     --  (calls from outside must also be directed to this\n+                     --  version rather than the overriding one, unlike the\n+                     --  dispatching case). Calls from inside the package\n+                     --  will still resolve to the overriding subprogram\n+                     --  since the derived one is marked as not visible\n+                     --  within the package.\n+\n+                     --  If the private operation is dispatching, we achieve\n+                     --  the overriding by keeping the implicit operation\n+                     --  but setting its alias to be the overriding one. In\n+                     --  this fashion the proper body is executed in all\n+                     --  cases, but the original signature is used outside\n+                     --  of the package.\n+\n+                     --  If the overriding is not in the private part, we\n+                     --  remove the implicit operation altogether.\n+\n+                     if Is_Private_Declaration (S) then\n+                        if not Is_Dispatching_Operation (E) then\n+                           Set_Is_Immediately_Visible (E, False);\n                         else\n-                           --  Find predecessor of E in Homonym chain\n-\n-                           if E = Current_Entity (E) then\n-                              Prev_Vis := Empty;\n-                           else\n-                              Prev_Vis := Current_Entity (E);\n-                              while Homonym (Prev_Vis) /= E loop\n-                                 Prev_Vis := Homonym (Prev_Vis);\n-                              end loop;\n-                           end if;\n-\n-                           if Prev_Vis /= Empty then\n-\n-                              --  Skip E in the visibility chain\n-\n-                              Set_Homonym (Prev_Vis, Homonym (E));\n+                           --  Work done in Override_Dispatching_Operation, so\n+                           --  nothing else needs to be done here.\n \n-                           else\n-                              Set_Name_Entity_Id (Chars (E), Homonym (E));\n-                           end if;\n-\n-                           Set_Next_Entity (Prev, Next_Entity (E));\n-\n-                           if No (Next_Entity (Prev)) then\n-                              Set_Last_Entity (Current_Scope, Prev);\n-                           end if;\n+                           null;\n                         end if;\n+\n+                     else\n+                        Remove_Entity_And_Homonym (E);\n                      end if;\n+                  end if;\n \n-                     Enter_Overloaded_Entity (S);\n+                  Enter_Overloaded_Entity (S);\n \n-                     --  For entities generated by Derive_Subprograms the\n-                     --  overridden operation is the inherited primitive\n-                     --  (which is available through the attribute alias).\n+                  --  For entities generated by Derive_Subprograms the\n+                  --  overridden operation is the inherited primitive\n+                  --  (which is available through the attribute alias).\n \n-                     if not (Comes_From_Source (E))\n-                       and then Is_Dispatching_Operation (E)\n-                       and then Find_Dispatching_Type (E) =\n-                                Find_Dispatching_Type (S)\n-                       and then Present (Alias (E))\n-                       and then Comes_From_Source (Alias (E))\n-                     then\n-                        Set_Overridden_Operation    (S, Alias (E));\n-                        Inherit_Subprogram_Contract (S, Alias (E));\n+                  if not (Comes_From_Source (E))\n+                    and then Is_Dispatching_Operation (E)\n+                    and then Find_Dispatching_Type (E) =\n+                             Find_Dispatching_Type (S)\n+                    and then Present (Alias (E))\n+                    and then Comes_From_Source (Alias (E))\n+                  then\n+                     Set_Overridden_Operation    (S, Alias (E));\n+                     Inherit_Subprogram_Contract (S, Alias (E));\n \n-                     --  Normal case of setting entity as overridden\n+                  --  Normal case of setting entity as overridden\n \n-                     --  Note: Static_Initialization and Overridden_Operation\n-                     --  attributes use the same field in subprogram entities.\n-                     --  Static_Initialization is only defined for internal\n-                     --  initialization procedures, where Overridden_Operation\n-                     --  is irrelevant. Therefore the setting of this attribute\n-                     --  must check whether the target is an init_proc.\n+                  --  Note: Static_Initialization and Overridden_Operation\n+                  --  attributes use the same field in subprogram entities.\n+                  --  Static_Initialization is only defined for internal\n+                  --  initialization procedures, where Overridden_Operation\n+                  --  is irrelevant. Therefore the setting of this attribute\n+                  --  must check whether the target is an init_proc.\n \n-                     elsif not Is_Init_Proc (S) then\n-                        Set_Overridden_Operation    (S, E);\n-                        Inherit_Subprogram_Contract (S, E);\n-                     end if;\n+                  elsif not Is_Init_Proc (S) then\n+                     Set_Overridden_Operation    (S, E);\n+                     Inherit_Subprogram_Contract (S, E);\n+                  end if;\n \n-                     Check_Overriding_Indicator (S, E, Is_Primitive => True);\n+                  Check_Overriding_Indicator (S, E, Is_Primitive => True);\n \n-                     --  The Ghost policy in effect at the point of declaration\n-                     --  of a parent subprogram and an overriding subprogram\n-                     --  must match (SPARK RM 6.9(17)).\n+                  --  The Ghost policy in effect at the point of declaration\n+                  --  of a parent subprogram and an overriding subprogram\n+                  --  must match (SPARK RM 6.9(17)).\n \n-                     Check_Ghost_Overriding (S, E);\n+                  Check_Ghost_Overriding (S, E);\n \n-                     --  If S is a user-defined subprogram or a null procedure\n-                     --  expanded to override an inherited null procedure, or a\n-                     --  predefined dispatching primitive then indicate that E\n-                     --  overrides the operation from which S is inherited.\n+                  --  If S is a user-defined subprogram or a null procedure\n+                  --  expanded to override an inherited null procedure, or a\n+                  --  predefined dispatching primitive then indicate that E\n+                  --  overrides the operation from which S is inherited.\n \n-                     if Comes_From_Source (S)\n-                       or else\n-                         (Present (Parent (S))\n-                           and then\n-                             Nkind (Parent (S)) = N_Procedure_Specification\n-                           and then\n-                             Null_Present (Parent (S)))\n-                       or else\n-                         (Present (Alias (E))\n-                           and then\n-                             Is_Predefined_Dispatching_Operation (Alias (E)))\n-                     then\n-                        if Present (Alias (E)) then\n-                           Set_Overridden_Operation    (S, Alias (E));\n-                           Inherit_Subprogram_Contract (S, Alias (E));\n-                        end if;\n+                  if Comes_From_Source (S)\n+                    or else\n+                      (Present (Parent (S))\n+                        and then Nkind (Parent (S)) = N_Procedure_Specification\n+                        and then Null_Present (Parent (S)))\n+                    or else\n+                      (Present (Alias (E))\n+                        and then\n+                          Is_Predefined_Dispatching_Operation (Alias (E)))\n+                  then\n+                     if Present (Alias (E)) then\n+                        Set_Overridden_Operation    (S, Alias (E));\n+                        Inherit_Subprogram_Contract (S, Alias (E));\n                      end if;\n+                  end if;\n \n-                     if Is_Dispatching_Operation (E) then\n+                  if Is_Dispatching_Operation (E) then\n \n-                        --  An overriding dispatching subprogram inherits the\n-                        --  convention of the overridden subprogram (AI-117).\n+                     --  An overriding dispatching subprogram inherits the\n+                     --  convention of the overridden subprogram (AI-117).\n \n-                        Set_Convention (S, Convention (E));\n-                        Check_Dispatching_Operation (S, E);\n+                     Set_Convention (S, Convention (E));\n+                     Check_Dispatching_Operation (S, E);\n \n-                     else\n-                        Check_Dispatching_Operation (S, Empty);\n-                     end if;\n+                  else\n+                     Check_Dispatching_Operation (S, Empty);\n+                  end if;\n \n-                     Check_For_Primitive_Subprogram\n-                       (Is_Primitive_Subp, Is_Overriding => True);\n-                     goto Check_Inequality;\n-                  end;\n+                  Check_For_Primitive_Subprogram\n+                    (Is_Primitive_Subp, Is_Overriding => True);\n+                  goto Check_Inequality;\n \n                --  Apparent redeclarations in instances can occur when two\n                --  formal types get the same actual type. The subprograms in"}, {"sha": "cb4b853e46a276698c9eeb8a4695f5ab866a19b8", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f6d1daa7cc592e13db95a9402762b525a317566/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f6d1daa7cc592e13db95a9402762b525a317566/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=3f6d1daa7cc592e13db95a9402762b525a317566", "patch": "@@ -2159,12 +2159,12 @@ package body Sem_Ch7 is\n \n       Exchange_Entities (Id, Full_Id);\n \n-      Set_Next_Entity (Id, Next1);\n-      Set_Homonym     (Id, H1);\n+      Link_Entities (Id, Next1);\n+      Set_Homonym   (Id, H1);\n \n-      Set_Full_View   (Full_Id, Id);\n-      Set_Next_Entity (Full_Id, Next2);\n-      Set_Homonym     (Full_Id, H2);\n+      Set_Full_View (Full_Id, Id);\n+      Link_Entities (Full_Id, Next2);\n+      Set_Homonym   (Full_Id, H2);\n    end Exchange_Declarations;\n \n    ----------------------------"}, {"sha": "9525f7f6f23aede44efbc0dc8efdf0e28fc4f8f9", "filename": "gcc/ada/sem_elab.adb", "status": "modified", "additions": 4, "deletions": 77, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f6d1daa7cc592e13db95a9402762b525a317566/gcc%2Fada%2Fsem_elab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f6d1daa7cc592e13db95a9402762b525a317566/gcc%2Fada%2Fsem_elab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.adb?ref=3f6d1daa7cc592e13db95a9402762b525a317566", "patch": "@@ -11185,32 +11185,19 @@ package body Sem_Elab is\n       procedure Find_And_Process_Nested_Scenarios;\n       pragma Inline (Find_And_Process_Nested_Scenarios);\n       --  Examine the declarations and statements of subprogram body N for\n-      --  suitable scenarios. Save each discovered scenario and process it\n-      --  accordingly.\n-\n-      procedure Process_Nested_Scenarios (Nested : Elist_Id);\n-      pragma Inline (Process_Nested_Scenarios);\n-      --  Invoke Process_Conditional_ABE on each individual scenario found in\n-      --  list Nested.\n+      --  suitable scenarios.\n \n       ---------------------------------------\n       -- Find_And_Process_Nested_Scenarios --\n       ---------------------------------------\n \n       procedure Find_And_Process_Nested_Scenarios is\n-         Body_Id : constant Entity_Id := Defining_Entity (N);\n-\n          function Is_Potential_Scenario\n            (Nod : Node_Id) return Traverse_Result;\n          --  Determine whether arbitrary node Nod denotes a suitable scenario.\n          --  If it does, save it in the Nested_Scenarios list of the subprogram\n          --  body, and process it.\n \n-         procedure Save_Scenario (Nod : Node_Id);\n-         pragma Inline (Save_Scenario);\n-         --  Save scenario Nod in the Nested_Scenarios list of the subprogram\n-         --  body.\n-\n          procedure Traverse_List (List : List_Id);\n          pragma Inline (Traverse_List);\n          --  Invoke Traverse_Potential_Scenarios on each node in list List\n@@ -11303,14 +11290,7 @@ package body Sem_Elab is\n \n             --  General case\n \n-            --  Save a suitable scenario in the Nested_Scenarios list of the\n-            --  subprogram body. As a result any subsequent traversals of the\n-            --  subprogram body started from a different top-level scenario no\n-            --  longer need to reexamine the tree.\n-\n             elsif Is_Suitable_Scenario (Nod) then\n-               Save_Scenario (Nod);\n-\n                Process_Conditional_ABE\n                  (N     => Nod,\n                   State => State);\n@@ -11319,24 +11299,6 @@ package body Sem_Elab is\n             return OK;\n          end Is_Potential_Scenario;\n \n-         -------------------\n-         -- Save_Scenario --\n-         -------------------\n-\n-         procedure Save_Scenario (Nod : Node_Id) is\n-            Nested : Elist_Id;\n-\n-         begin\n-            Nested := Nested_Scenarios (Body_Id);\n-\n-            if No (Nested) then\n-               Nested := New_Elmt_List;\n-               Set_Nested_Scenarios (Body_Id, Nested);\n-            end if;\n-\n-            Append_Elmt (Nod, Nested);\n-         end Save_Scenario;\n-\n          -------------------\n          -- Traverse_List --\n          -------------------\n@@ -11365,28 +11327,6 @@ package body Sem_Elab is\n          Traverse_Potential_Scenarios (Handled_Statement_Sequence (N));\n       end Find_And_Process_Nested_Scenarios;\n \n-      ------------------------------\n-      -- Process_Nested_Scenarios --\n-      ------------------------------\n-\n-      procedure Process_Nested_Scenarios (Nested : Elist_Id) is\n-         Nested_Elmt : Elmt_Id;\n-\n-      begin\n-         Nested_Elmt := First_Elmt (Nested);\n-         while Present (Nested_Elmt) loop\n-            Process_Conditional_ABE\n-              (N     => Node (Nested_Elmt),\n-               State => State);\n-\n-            Next_Elmt (Nested_Elmt);\n-         end loop;\n-      end Process_Nested_Scenarios;\n-\n-      --  Local variables\n-\n-      Nested : Elist_Id;\n-\n    --  Start of processing for Traverse_Body\n \n    begin\n@@ -11411,23 +11351,10 @@ package body Sem_Elab is\n          Set_Is_Visited_Body (N);\n       end if;\n \n-      Nested := Nested_Scenarios (Defining_Entity (N));\n-\n-      --  The subprogram body was already examined as part of the elaboration\n-      --  graph starting from a different top-level scenario. There is no need\n-      --  to traverse the declarations and statements again because this will\n-      --  yield the exact same scenarios. Use the nested scenarios collected\n-      --  during the first inspection of the body.\n-\n-      if Present (Nested) then\n-         Process_Nested_Scenarios (Nested);\n+      --  Examine the declarations and statements of the subprogram body for\n+      --  suitable scenarios, save and process them accordingly.\n \n-      --  Otherwise examine the declarations and statements of the subprogram\n-      --  body for suitable scenarios, save and process them accordingly.\n-\n-      else\n-         Find_And_Process_Nested_Scenarios;\n-      end if;\n+      Find_And_Process_Nested_Scenarios;\n    end Traverse_Body;\n \n    -----------------"}, {"sha": "d205e58f8dc64d99816a415ea23634413be0bd74", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 34, "deletions": 78, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f6d1daa7cc592e13db95a9402762b525a317566/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f6d1daa7cc592e13db95a9402762b525a317566/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=3f6d1daa7cc592e13db95a9402762b525a317566", "patch": "@@ -727,7 +727,7 @@ package body Sem_Util is\n         and then Scop = Current_Scope\n       then\n          --  The inherited operation is available at the earliest place after\n-         --  the derived type declaration ( RM 7.3.1 (6/1)). This is only\n+         --  the derived type declaration (RM 7.3.1 (6/1)). This is only\n          --  relevant for type extensions. If the parent operation appears\n          --  after the type extension, the operation is not visible.\n \n@@ -740,8 +740,8 @@ package body Sem_Util is\n             then\n                if Sloc (Decl) > Sloc (Par) then\n                   Next_E := Next_Entity (Par);\n-                  Set_Next_Entity (Par, S);\n-                  Set_Next_Entity (S, Next_E);\n+                  Link_Entities (Par, S);\n+                  Link_Entities (S, Next_E);\n                   return;\n \n                else\n@@ -7043,7 +7043,7 @@ package body Sem_Util is\n                   null;\n \n                else\n-                  Set_Next_Entity (Prev, Next_Entity (E));\n+                  Link_Entities (Prev, Next_Entity (E));\n \n                   if No (Next_Entity (Prev)) then\n                      Set_Last_Entity (Current_Scope, Prev);\n@@ -19996,6 +19996,13 @@ package body Sem_Util is\n             end if;\n          end if;\n \n+         --  Prev_Entity\n+\n+         Set_Prev_Entity (Id, Node_Id (\n+           Copy_Field_With_Replacement\n+             (Field    => Union_Id (Prev_Entity (Id)),\n+              Semantic => True)));\n+\n          --  Next_Entity\n \n          Set_Next_Entity (Id, Node_Id (\n@@ -22980,92 +22987,43 @@ package body Sem_Util is\n       end if;\n    end References_Generic_Formal_Type;\n \n-   -------------------\n-   -- Remove_Entity --\n-   -------------------\n-\n-   procedure Remove_Entity (Id : Entity_Id) is\n-      Scop    : constant Entity_Id := Scope (Id);\n-      Prev_Id : Entity_Id;\n+   -------------------------------\n+   -- Remove_Entity_And_Homonym --\n+   -------------------------------\n \n+   procedure Remove_Entity_And_Homonym (Id : Entity_Id) is\n    begin\n-      --  Remove the entity from the homonym chain. When the entity is the\n-      --  head of the chain, associate the entry in the name table with its\n-      --  homonym effectively making it the new head of the chain.\n-\n-      if Current_Entity (Id) = Id then\n-         Set_Name_Entity_Id (Chars (Id), Homonym (Id));\n-\n-      --  Otherwise link the previous and next homonyms\n-\n-      else\n-         Prev_Id := Current_Entity (Id);\n-         if Present (Prev_Id) then\n-            while Present (Prev_Id) and then Homonym (Prev_Id) /= Id loop\n-               Prev_Id := Homonym (Prev_Id);\n-            end loop;\n-\n-            Set_Homonym (Prev_Id, Homonym (Id));\n-         end if;\n-      end if;\n-\n-      --  Remove the entity from the scope entity chain. When the entity is\n-      --  the head of the chain, set the next entity as the new head of the\n-      --  chain.\n-\n-      if First_Entity (Scop) = Id then\n-         Prev_Id := Empty;\n-         Set_First_Entity (Scop, Next_Entity (Id));\n-\n-      --  Otherwise the entity is either in the middle of the chain or it acts\n-      --  as its tail. Traverse and link the previous and next entities.\n-\n-      else\n-         Prev_Id := First_Entity (Scop);\n-         while Present (Prev_Id) and then Next_Entity (Prev_Id) /= Id loop\n-            Next_Entity (Prev_Id);\n-         end loop;\n-\n-         if Present (Prev_Id) then\n-            Set_Next_Entity (Prev_Id, Next_Entity (Id));\n-         end if;\n-      end if;\n-\n-      --  Handle the case where the entity acts as the tail of the scope entity\n-      --  chain.\n-\n-      if Last_Entity (Scop) = Id then\n-         Set_Last_Entity (Scop, Prev_Id);\n-      end if;\n-   end Remove_Entity;\n+      Remove_Entity (Id);\n+      Remove_Homonym (Id);\n+   end Remove_Entity_And_Homonym;\n \n    --------------------\n    -- Remove_Homonym --\n    --------------------\n \n-   procedure Remove_Homonym (E : Entity_Id) is\n-      Prev  : Entity_Id := Empty;\n-      H     : Entity_Id;\n+   procedure Remove_Homonym (Id : Entity_Id) is\n+      Hom  : Entity_Id;\n+      Prev : Entity_Id := Empty;\n \n    begin\n-      if E = Current_Entity (E) then\n-         if Present (Homonym (E)) then\n-            Set_Current_Entity (Homonym (E));\n+      if Id = Current_Entity (Id) then\n+         if Present (Homonym (Id)) then\n+            Set_Current_Entity (Homonym (Id));\n          else\n-            Set_Name_Entity_Id (Chars (E), Empty);\n+            Set_Name_Entity_Id (Chars (Id), Empty);\n          end if;\n \n       else\n-         H := Current_Entity (E);\n-         while Present (H) and then H /= E loop\n-            Prev := H;\n-            H    := Homonym (H);\n+         Hom := Current_Entity (Id);\n+         while Present (Hom) and then Hom /= Id loop\n+            Prev := Hom;\n+            Hom  := Homonym (Hom);\n          end loop;\n \n-         --  If E is not on the homonym chain, nothing to do\n+         --  If Id is not on the homonym chain, nothing to do\n \n-         if Present (H) then\n-            Set_Homonym (Prev, Homonym (E));\n+         if Present (Hom) then\n+            Set_Homonym (Prev, Homonym (Id));\n          end if;\n       end if;\n    end Remove_Homonym;\n@@ -23103,9 +23061,7 @@ package body Sem_Util is\n    --  Start of processing for Remove_Overloaded_Entity\n \n    begin\n-      --  Remove the entity from both the homonym and scope chains\n-\n-      Remove_Entity (Id);\n+      Remove_Entity_And_Homonym (Id);\n \n       --  The entity denotes a primitive subprogram. Remove it from the list of\n       --  primitives of the associated controlling type.\n@@ -24656,7 +24612,7 @@ package body Sem_Util is\n          --  destination scope.\n \n          if Present (Last_Entity (To)) then\n-            Set_Next_Entity (Last_Entity (To), Id);\n+            Link_Entities (Last_Entity (To), Id);\n          else\n             Set_First_Entity (To, Id);\n          end if;"}, {"sha": "2aa7432fbcff8a007416108b703c3a348cbb5054", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f6d1daa7cc592e13db95a9402762b525a317566/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f6d1daa7cc592e13db95a9402762b525a317566/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=3f6d1daa7cc592e13db95a9402762b525a317566", "patch": "@@ -2489,14 +2489,14 @@ package Sem_Util is\n    --  Returns True if the expression Expr contains any references to a generic\n    --  type. This can only happen within a generic template.\n \n-   procedure Remove_Entity (Id : Entity_Id);\n+   procedure Remove_Entity_And_Homonym (Id : Entity_Id);\n    --  Remove arbitrary entity Id from both the homonym and scope chains. Use\n    --  Remove_Overloaded_Entity for overloadable entities. Note: the removal\n    --  performed by this routine does not affect the visibility of existing\n    --  homonyms.\n \n-   procedure Remove_Homonym (E : Entity_Id);\n-   --  Removes E from the homonym chain\n+   procedure Remove_Homonym (Id : Entity_Id);\n+   --  Removes entity Id from the homonym chain\n \n    procedure Remove_Overloaded_Entity (Id : Entity_Id);\n    --  Remove arbitrary entity Id from the homonym chain, the scope chain and"}]}