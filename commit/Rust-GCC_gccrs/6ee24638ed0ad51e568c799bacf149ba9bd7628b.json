{"sha": "6ee24638ed0ad51e568c799bacf149ba9bd7628b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmVlMjQ2MzhlZDBhZDUxZTU2OGM3OTliYWNmMTQ5YmE5YmQ3NjI4Yg==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-03-12T11:47:20Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-03-16T12:25:28Z"}, "message": "libstdc++: Revert to old std::call_once implementation [PR 99341]\n\nThe new std::call_once implementation is not backwards compatible,\ncontrary to my intention. Because std::once_flag::_M_active() doesn't\nwrite glibc's \"fork generation\" into the pthread_once_t object, it's\npossible for glibc and libstdc++ to run two active executions\nconcurrently. This violates the primary invariant of the feature!\n\nThis patch reverts std::once_flag and std::call_once to the old\nimplementation that uses pthread_once. This means PR 66146 is a problem\nagain, but glibc has been changed to solve that. A new API similar to\npthread_once but supporting failure and resetting the pthread_once_t\nwill be proposed for inclusion in glibc and other C libraries.\n\nThis change doesn't simply revert r11-4691 because I want to retain the\nnew implementation for non-ghtreads targets (which didn't previously\nsupport std::call_once at all, so there's no backwards compatibility\nconcern). This also leaves the new std::call_once::_M_activate() and\nstd::call_once::_M_finish(bool) symbols present in libstdc++.so.6 so\nthat code already compiled against GCC 11 can still use them. Those\nsymbols will be removed in a subsequent commit (which distros can choose\nto temporarily revert if needed).\n\nlibstdc++-v3/ChangeLog:\n\n\tPR libstdc++/99341\n\t* include/std/mutex [_GLIBCXX_HAVE_LINUX_FUTEX] (once_flag):\n\tRevert to pthread_once_t implementation.\n\t[_GLIBCXX_HAVE_LINUX_FUTEX] (call_once): Likewise.\n\t* src/c++11/mutex.cc [_GLIBCXX_HAVE_LINUX_FUTEX]\n\t(struct __once_flag_compat): New type matching the reverted\n\timplementation of once_flag using futexes.\n\t(once_flag::_M_activate): Remove, replace with ...\n\t(_ZNSt9once_flag11_M_activateEv): ... alias symbol.\n\t(once_flag::_M_finish): Remove, replace with ...\n\t(_ZNSt9once_flag9_M_finishEb): ... alias symbol.\n\t* testsuite/30_threads/call_once/66146.cc: Removed.", "tree": {"sha": "4066b8acc330b4f0f62fc4a1392908988306e160", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4066b8acc330b4f0f62fc4a1392908988306e160"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6ee24638ed0ad51e568c799bacf149ba9bd7628b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ee24638ed0ad51e568c799bacf149ba9bd7628b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ee24638ed0ad51e568c799bacf149ba9bd7628b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ee24638ed0ad51e568c799bacf149ba9bd7628b/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b900dca607dceaae2db372365f682a4979c7826", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b900dca607dceaae2db372365f682a4979c7826", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b900dca607dceaae2db372365f682a4979c7826"}], "stats": {"total": 332, "additions": 156, "deletions": 176}, "files": [{"sha": "b6a595237bf6f65b92a33ed71ca99d30c926155f", "filename": "libstdc++-v3/include/std/mutex", "status": "modified", "additions": 125, "deletions": 117, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ee24638ed0ad51e568c799bacf149ba9bd7628b/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmutex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ee24638ed0ad51e568c799bacf149ba9bd7628b/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmutex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmutex?ref=6ee24638ed0ad51e568c799bacf149ba9bd7628b", "patch": "@@ -669,6 +669,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     };\n #endif // C++17\n \n+#ifdef _GLIBCXX_HAS_GTHREADS\n   /// Flag type used by std::call_once\n   struct once_flag\n   {\n@@ -680,125 +681,27 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     once_flag& operator=(const once_flag&) = delete;\n \n   private:\n-    // There are two different std::once_flag interfaces, abstracting four\n-    // different implementations.\n-    // The preferred interface uses the _M_activate() and _M_finish(bool)\n-    // member functions (introduced in GCC 11), which start and finish an\n-    // active execution respectively. See [thread.once.callonce] in C++11\n-    // for the definition of active/passive/returning/exceptional executions.\n-    // This interface is supported for Linux (using atomics and futexes) and\n-    // for single-threaded targets with no gthreads support.\n-    // For other targets a pthread_once_t is used with pthread_once, but that\n-    // doesn't work correctly for exceptional executions. That interface\n-    // uses an object of type _Prepare_execution and a lambda expression.\n-#if defined _GLIBCXX_HAVE_LINUX_FUTEX || ! defined _GLIBCXX_HAS_GTHREADS\n-    enum _Bits : int { _Init = 0, _Active = 1, _Done = 2 };\n-\n-    int _M_once = _Bits::_Init;\n-\n-    // Non-blocking check to see if all executions will be passive now.\n-    bool\n-    _M_passive() const noexcept;\n-\n-    // Attempts to begin an active execution. Blocks until it either:\n-    // - returns true if an active execution has started on this thread, or\n-    // - returns false if a returning execution happens on another thread.\n-    bool _M_activate();\n-\n-    // Must be called to complete an active execution.\n-    // The argument is true if the active execution was a returning execution,\n-    // false if it was an exceptional execution.\n-    void _M_finish(bool __returning) noexcept;\n-\n-    // RAII helper to call _M_finish.\n-    struct _Active_execution\n-    {\n-      explicit _Active_execution(once_flag& __flag) : _M_flag(__flag) { }\n-\n-      ~_Active_execution() { _M_flag._M_finish(_M_returning); }\n-\n-      _Active_execution(const _Active_execution&) = delete;\n-      _Active_execution& operator=(const _Active_execution&) = delete;\n-\n-      once_flag& _M_flag;\n-      bool _M_returning = false;\n-    };\n-#else\n+    // For gthreads targets a pthread_once_t is used with pthread_once, but\n+    // for most targets this doesn't work correctly for exceptional executions.\n     __gthread_once_t _M_once = __GTHREAD_ONCE_INIT;\n \n     struct _Prepare_execution;\n-#endif // ! GTHREADS\n \n     template<typename _Callable, typename... _Args>\n       friend void\n       call_once(once_flag& __once, _Callable&& __f, _Args&&... __args);\n   };\n \n-#if ! defined _GLIBCXX_HAS_GTHREADS\n-  // Inline definitions of std::once_flag members for single-threaded targets.\n-\n-  inline bool\n-  once_flag::_M_passive() const noexcept\n-  { return _M_once == _Bits::_Done; }\n-\n-  inline bool\n-  once_flag::_M_activate()\n-  {\n-    if (_M_once == _Bits::_Init) [[__likely__]]\n-      {\n-\t_M_once = _Bits::_Active;\n-\treturn true;\n-      }\n-    else if (_M_passive()) // Caller should have checked this already.\n-      return false;\n-    else\n-      __throw_system_error(EDEADLK);\n-  }\n-\n-  inline void\n-  once_flag::_M_finish(bool __returning) noexcept\n-  { _M_once = __returning ? _Bits::_Done : _Bits::_Init; }\n-\n-#elif defined _GLIBCXX_HAVE_LINUX_FUTEX\n-\n-  // Define this inline to make passive executions fast.\n-  inline bool\n-  once_flag::_M_passive() const noexcept\n-  {\n-    if (__gnu_cxx::__is_single_threaded())\n-      return _M_once == _Bits::_Done;\n-    else\n-      return __atomic_load_n(&_M_once, __ATOMIC_ACQUIRE) == _Bits::_Done;\n-  }\n-\n-#else // GTHREADS && ! FUTEX\n-\n   /// @cond undocumented\n # ifdef _GLIBCXX_HAVE_TLS\n   // If TLS is available use thread-local state for the type-erased callable\n   // that is being run by std::call_once in the current thread.\n   extern __thread void* __once_callable;\n   extern __thread void (*__once_call)();\n-# else\n-  // Without TLS use a global std::mutex and store the callable in a\n-  // global std::function.\n-  extern function<void()> __once_functor;\n-\n-  extern void\n-  __set_once_functor_lock_ptr(unique_lock<mutex>*);\n-\n-  extern mutex&\n-  __get_once_mutex();\n-# endif\n-\n-  // This function is passed to pthread_once by std::call_once.\n-  // It runs __once_call() or __once_functor().\n-  extern \"C\" void __once_proxy(void);\n \n   // RAII type to set up state for pthread_once call.\n   struct once_flag::_Prepare_execution\n   {\n-#ifdef _GLIBCXX_HAVE_TLS\n     template<typename _Callable>\n       explicit\n       _Prepare_execution(_Callable& __c)\n@@ -815,7 +718,25 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       __once_callable = nullptr;\n       __once_call = nullptr;\n     }\n-#else // ! TLS\n+\n+    _Prepare_execution(const _Prepare_execution&) = delete;\n+    _Prepare_execution& operator=(const _Prepare_execution&) = delete;\n+  };\n+\n+# else\n+  // Without TLS use a global std::mutex and store the callable in a\n+  // global std::function.\n+  extern function<void()> __once_functor;\n+\n+  extern void\n+  __set_once_functor_lock_ptr(unique_lock<mutex>*);\n+\n+  extern mutex&\n+  __get_once_mutex();\n+\n+  // RAII type to set up state for pthread_once call.\n+  struct once_flag::_Prepare_execution\n+  {\n     template<typename _Callable>\n       explicit\n       _Prepare_execution(_Callable& __c)\n@@ -832,21 +753,120 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     }\n \n   private:\n+    // XXX This deadlocks if used recursively (PR 97949)\n     unique_lock<mutex> _M_functor_lock{__get_once_mutex()};\n-#endif // ! TLS\n \n     _Prepare_execution(const _Prepare_execution&) = delete;\n     _Prepare_execution& operator=(const _Prepare_execution&) = delete;\n   };\n+# endif\n   /// @endcond\n-#endif\n+\n+  // This function is passed to pthread_once by std::call_once.\n+  // It runs __once_call() or __once_functor().\n+  extern \"C\" void __once_proxy(void);\n \n   /// Invoke a callable and synchronize with other calls using the same flag\n   template<typename _Callable, typename... _Args>\n     void\n     call_once(once_flag& __once, _Callable&& __f, _Args&&... __args)\n     {\n-#if defined _GLIBCXX_HAVE_LINUX_FUTEX || ! defined _GLIBCXX_HAS_GTHREADS\n+      // Closure type that runs the function\n+      auto __callable = [&] {\n+\t  std::__invoke(std::forward<_Callable>(__f),\n+\t\t\tstd::forward<_Args>(__args)...);\n+      };\n+\n+      once_flag::_Prepare_execution __exec(__callable);\n+\n+      // XXX pthread_once does not reset the flag if an exception is thrown.\n+      if (int __e = __gthread_once(&__once._M_once, &__once_proxy))\n+\t__throw_system_error(__e);\n+    }\n+\n+#else // _GLIBCXX_HAS_GTHREADS\n+\n+  /// Flag type used by std::call_once\n+  struct once_flag\n+  {\n+    constexpr once_flag() noexcept = default;\n+\n+    /// Deleted copy constructor\n+    once_flag(const once_flag&) = delete;\n+    /// Deleted assignment operator\n+    once_flag& operator=(const once_flag&) = delete;\n+\n+  private:\n+    // There are two different std::once_flag interfaces, abstracting four\n+    // different implementations.\n+    // The single-threaded interface uses the _M_activate() and _M_finish(bool)\n+    // functions, which start and finish an active execution respectively.\n+    // See [thread.once.callonce] in C++11 for the definition of\n+    // active/passive/returning/exceptional executions.\n+    enum _Bits : int { _Init = 0, _Active = 1, _Done = 2 };\n+\n+    int _M_once = _Bits::_Init;\n+\n+    // Check to see if all executions will be passive now.\n+    bool\n+    _M_passive() const noexcept;\n+\n+    // Attempts to begin an active execution.\n+    bool _M_activate();\n+\n+    // Must be called to complete an active execution.\n+    // The argument is true if the active execution was a returning execution,\n+    // false if it was an exceptional execution.\n+    void _M_finish(bool __returning) noexcept;\n+\n+    // RAII helper to call _M_finish.\n+    struct _Active_execution\n+    {\n+      explicit _Active_execution(once_flag& __flag) : _M_flag(__flag) { }\n+\n+      ~_Active_execution() { _M_flag._M_finish(_M_returning); }\n+\n+      _Active_execution(const _Active_execution&) = delete;\n+      _Active_execution& operator=(const _Active_execution&) = delete;\n+\n+      once_flag& _M_flag;\n+      bool _M_returning = false;\n+    };\n+\n+    template<typename _Callable, typename... _Args>\n+      friend void\n+      call_once(once_flag& __once, _Callable&& __f, _Args&&... __args);\n+  };\n+\n+  // Inline definitions of std::once_flag members for single-threaded targets.\n+\n+  inline bool\n+  once_flag::_M_passive() const noexcept\n+  { return _M_once == _Bits::_Done; }\n+\n+  inline bool\n+  once_flag::_M_activate()\n+  {\n+    if (_M_once == _Bits::_Init) [[__likely__]]\n+      {\n+\t_M_once = _Bits::_Active;\n+\treturn true;\n+      }\n+    else if (_M_passive()) // Caller should have checked this already.\n+      return false;\n+    else\n+      __throw_system_error(EDEADLK);\n+  }\n+\n+  inline void\n+  once_flag::_M_finish(bool __returning) noexcept\n+  { _M_once = __returning ? _Bits::_Done : _Bits::_Init; }\n+\n+  /// Invoke a callable and synchronize with other calls using the same flag\n+  template<typename _Callable, typename... _Args>\n+    inline void\n+    call_once(once_flag& __once, _Callable&& __f, _Args&&... __args)\n+    {\n       if (__once._M_passive())\n \treturn;\n       else if (__once._M_activate())\n@@ -861,20 +881,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  // __f(__args...) did not throw\n \t  __exec._M_returning = true;\n \t}\n-#else\n-      // Closure type that runs the function\n-      auto __callable = [&] {\n-\t  std::__invoke(std::forward<_Callable>(__f),\n-\t\t\tstd::forward<_Args>(__args)...);\n-      };\n-\n-      once_flag::_Prepare_execution __exec(__callable);\n-\n-      // XXX pthread_once does not reset the flag if an exception is thrown.\n-      if (int __e = __gthread_once(&__once._M_once, &__once_proxy))\n-\t__throw_system_error(__e);\n-#endif\n     }\n+#endif // _GLIBCXX_HAS_GTHREADS\n \n   // @} group mutexes\n _GLIBCXX_END_NAMESPACE_VERSION"}, {"sha": "3b48998b7e41e803085c526845b6f4bb3be61304", "filename": "libstdc++-v3/src/c++11/mutex.cc", "status": "modified", "additions": 31, "deletions": 6, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ee24638ed0ad51e568c799bacf149ba9bd7628b/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fmutex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ee24638ed0ad51e568c799bacf149ba9bd7628b/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fmutex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fmutex.cc?ref=6ee24638ed0ad51e568c799bacf149ba9bd7628b", "patch": "@@ -26,13 +26,27 @@\n \n #ifdef _GLIBCXX_HAS_GTHREADS\n \n+#if defined _GLIBCXX_SHARED && ! _GLIBCXX_INLINE_VERSION\n+\n #ifdef _GLIBCXX_HAVE_LINUX_FUTEX\n-#include <syscall.h>\n-#include <unistd.h>\n-#include <limits.h>\n+# include <syscall.h>\n+# include <unistd.h>\n+# include <limits.h>\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+struct __once_flag_compat\n+{\n+  enum _Bits : int { _Init = 0, _Active = 1, _Done = 2 };\n+  int _M_once = 0;\n+  bool _M_activate();\n+  void _M_finish(bool returning) noexcept;\n+};\n \n bool\n-std::once_flag::_M_activate()\n+__once_flag_compat::_M_activate()\n {\n   if (__gnu_cxx::__is_single_threaded())\n     {\n@@ -64,7 +78,7 @@ std::once_flag::_M_activate()\n }\n \n void\n-std::once_flag::_M_finish(bool returning) noexcept\n+std::__once_flag_compat::_M_finish(bool returning) noexcept\n {\n   const int newval = returning ? _Bits::_Done : _Bits::_Init;\n   if (__gnu_cxx::__is_single_threaded())\n@@ -83,7 +97,18 @@ std::once_flag::_M_finish(bool returning) noexcept\n     }\n }\n \n-#endif // ! FUTEX\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wattribute-alias\"\n+extern \"C\" bool _ZNSt9once_flag11_M_activateEv()\n+  __attribute__((alias (\"_ZNSt18__once_flag_compat11_M_activateEv\")));\n+extern \"C\" void _ZNSt9once_flag9_M_finishEb() noexcept\n+  __attribute__((alias (\"_ZNSt18__once_flag_compat9_M_finishEb\")));\n+#pragma GCC diagnostic pop\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace std\n+#endif // FUTEX\n+#endif // ONCE_FLAG_COMPAT && SHARED && ! INLINE_VERSION\n \n namespace std _GLIBCXX_VISIBILITY(default)\n {"}, {"sha": "f5529373a0586792619fe87825671fa87e46efc6", "filename": "libstdc++-v3/testsuite/30_threads/call_once/66146.cc", "status": "removed", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b900dca607dceaae2db372365f682a4979c7826/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fcall_once%2F66146.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b900dca607dceaae2db372365f682a4979c7826/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fcall_once%2F66146.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fcall_once%2F66146.cc?ref=7b900dca607dceaae2db372365f682a4979c7826", "patch": "@@ -1,53 +0,0 @@\n-// Copyright (C) 2020-2021 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 3, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING3.  If not see\n-// <http://www.gnu.org/licenses/>.\n-\n-// { dg-do run { target c++11 } }\n-// { dg-additional-options \"-pthread\" { target pthread } }\n-\n-// Currently std::call_once is broken for gthreads targets without futexes:\n-// { dg-skip-if \"see PR 66146\" { gthreads && { ! futex } } }\n-\n-#include <mutex>\n-#include <cstdlib>\n-#include <testsuite_hooks.h>\n-\n-void\n-test01()\n-{\n-  std::once_flag once;\n-  int counter = 0;\n-  for (int i = 0; i < 10; ++i)\n-  {\n-    try\n-    {\n-      std::call_once(once, [&]{ if (i < 3) throw i; ++counter; });\n-      VERIFY(i >= 3);\n-    }\n-    catch (int ex)\n-    {\n-      VERIFY(i < 3);\n-    }\n-  }\n- VERIFY(counter == 1);\n- std::call_once(once, []{ std::abort(); });\n-}\n-\n-int\n-main()\n-{\n-  test01();\n-}"}]}