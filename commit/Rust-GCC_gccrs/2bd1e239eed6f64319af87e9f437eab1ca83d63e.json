{"sha": "2bd1e239eed6f64319af87e9f437eab1ca83d63e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmJkMWUyMzllZWQ2ZjY0MzE5YWY4N2U5ZjQzN2VhYjFjYTgzZDYzZQ==", "commit": {"author": {"name": "Steven Bosscher", "email": "stevenb@suse.de", "date": "2005-07-27T16:28:34Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2005-07-27T16:28:34Z"}, "message": "re PR rtl-optimization/17808 (Scheduler overly conservative in sched-deps)\n\n\tPR rtl-optimization/17808\n\t* sched-deps.c (sched_get_condition): Enable #if 0'ed code.\n\t(sched_insns_conditions_mutex_p): Split out from...\n\t(add_dependence): ...here.  But don't call it from here.\n\t(add_dependence_list): Check sched_insns_conditions_mutex_p\n\tbefore calling add_dependence.\n\t(add_dependence_list_and_free): Likewise.\n\t(fixup_sched_groups): Likewise.\n\t(sched_analyze_1): Likewise.\n\t(sched_analyze_2): Likewise (and replace a \"0\" with REG_DEP_TRUE).\n\t(sched_analyze): Likewise.\n\t(sched_analyze_insn): Likewise.\n\t* sched-ebb.c (add_deps_for_risky_insns): Likewise.\n\t* sched-rgn.c (add_branch_dependences): Likewise.  Also, add\n\tdependencies on all COND_EXEC insns to jumps ending basic blocks\n\twhen doing intrablock scheduling.\n\t* sched-int.h (sched_insns_conditions_mutex_p): Add prototype.\n\nFrom-SVN: r102433", "tree": {"sha": "1ce25616a076bf403e50c4f0efdf41ea5dca0507", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1ce25616a076bf403e50c4f0efdf41ea5dca0507"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2bd1e239eed6f64319af87e9f437eab1ca83d63e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bd1e239eed6f64319af87e9f437eab1ca83d63e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2bd1e239eed6f64319af87e9f437eab1ca83d63e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bd1e239eed6f64319af87e9f437eab1ca83d63e/comments", "author": null, "committer": null, "parents": [{"sha": "880031e1f9c134581537c61af91d89b7bb033dc7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/880031e1f9c134581537c61af91d89b7bb033dc7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/880031e1f9c134581537c61af91d89b7bb033dc7"}], "stats": {"total": 201, "additions": 146, "deletions": 55}, "files": [{"sha": "363c9600fb3724fb9b36d09c9e59a2a312fe4313", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bd1e239eed6f64319af87e9f437eab1ca83d63e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bd1e239eed6f64319af87e9f437eab1ca83d63e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2bd1e239eed6f64319af87e9f437eab1ca83d63e", "patch": "@@ -1,3 +1,23 @@\n+2005-07-27  Steven Bosscher  <stevenb@suse.de>\n+\n+\tPR rtl-optimization/17808\n+\t* sched-deps.c (sched_get_condition): Enable #if 0'ed code.\n+\t(sched_insns_conditions_mutex_p): Split out from...\n+\t(add_dependence): ...here.  But don't call it from here.\n+\t(add_dependence_list): Check sched_insns_conditions_mutex_p\n+\tbefore calling add_dependence.\n+\t(add_dependence_list_and_free): Likewise.\n+\t(fixup_sched_groups): Likewise.\n+\t(sched_analyze_1): Likewise.\n+\t(sched_analyze_2): Likewise (and replace a \"0\" with REG_DEP_TRUE).\n+\t(sched_analyze): Likewise.\n+\t(sched_analyze_insn): Likewise.\n+\t* sched-ebb.c (add_deps_for_risky_insns): Likewise.\n+\t* sched-rgn.c (add_branch_dependences): Likewise.  Also, add\n+\tdependencies on all COND_EXEC insns to jumps ending basic blocks\n+\twhen doing intrablock scheduling.\n+\t* sched-int.h (sched_insns_conditions_mutex_p): Add prototype.\n+\n 2005-07-27  Jeff Law  <law@redhat.com>\n \n \t* tree-vrp.c (vrp_meet): Intersect the equivalency sets when"}, {"sha": "7baad1b669e814e4ba29223f6dc71db2a137cbf8", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 66, "deletions": 52, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bd1e239eed6f64319af87e9f437eab1ca83d63e/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bd1e239eed6f64319af87e9f437eab1ca83d63e/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=2bd1e239eed6f64319af87e9f437eab1ca83d63e", "patch": "@@ -149,11 +149,7 @@ sched_get_condition (rtx insn)\n     return 0;\n \n   src = SET_SRC (pc_set (insn));\n-#if 0\n-  /* The previous code here was completely invalid and could never extract\n-     the condition from a jump.  This code does the correct thing, but that\n-     triggers latent bugs later in the scheduler on ports with conditional\n-     execution.  So this is disabled for now.  */\n+\n   if (XEXP (src, 2) == pc_rtx)\n     return XEXP (src, 0);\n   else if (XEXP (src, 1) == pc_rtx)\n@@ -166,11 +162,11 @@ sched_get_condition (rtx insn)\n       return gen_rtx_fmt_ee (revcode, GET_MODE (cond), XEXP (cond, 0),\n \t\t\t     XEXP (cond, 1));\n     }\n-#endif\n \n   return 0;\n }\n \n+\f\n /* Return nonzero if conditions COND1 and COND2 can never be both true.  */\n \n static int\n@@ -184,6 +180,32 @@ conditions_mutex_p (rtx cond1, rtx cond2)\n     return 1;\n   return 0;\n }\n+\n+/* Return true if insn1 and insn2 can never depend on one another because\n+   the conditions under which they are executed are mutually exclusive.  */\n+bool\n+sched_insns_conditions_mutex_p (rtx insn1, rtx insn2)\n+{\n+  rtx cond1, cond2;\n+\n+  /* flow.c doesn't handle conditional lifetimes entirely correctly;\n+     calls mess up the conditional lifetimes.  */\n+  if (!CALL_P (insn1) && !CALL_P (insn2))\n+    {\n+      cond1 = sched_get_condition (insn1);\n+      cond2 = sched_get_condition (insn2);\n+      if (cond1 && cond2\n+\t  && conditions_mutex_p (cond1, cond2)\n+\t  /* Make sure first instruction doesn't affect condition of second\n+\t     instruction if switched.  */\n+\t  && !modified_in_p (cond1, insn2)\n+\t  /* Make sure second instruction doesn't affect condition of first\n+\t     instruction if switched.  */\n+\t  && !modified_in_p (cond2, insn1))\n+\treturn true;\n+    }\n+  return false;\n+}\n \f\n /* Add ELEM wrapped in an INSN_LIST with reg note kind DEP_TYPE to the\n    LOG_LINKS of INSN, if not already there.  DEP_TYPE indicates the\n@@ -195,7 +217,6 @@ add_dependence (rtx insn, rtx elem, enum reg_note dep_type)\n {\n   rtx link;\n   int present_p;\n-  rtx cond1, cond2;\n \n   /* Don't depend an insn on itself.  */\n   if (insn == elem)\n@@ -207,26 +228,6 @@ add_dependence (rtx insn, rtx elem, enum reg_note dep_type)\n   if (NOTE_P (elem))\n     return 0;\n \n-  /* flow.c doesn't handle conditional lifetimes entirely correctly;\n-     calls mess up the conditional lifetimes.  */\n-  /* ??? add_dependence is the wrong place to be eliding dependencies,\n-     as that forgets that the condition expressions themselves may\n-     be dependent.  */\n-  if (!CALL_P (insn) && !CALL_P (elem))\n-    {\n-      cond1 = sched_get_condition (insn);\n-      cond2 = sched_get_condition (elem);\n-      if (cond1 && cond2\n-\t  && conditions_mutex_p (cond1, cond2)\n-\t  /* Make sure first instruction doesn't affect condition of second\n-\t     instruction if switched.  */\n-\t  && !modified_in_p (cond1, elem)\n-\t  /* Make sure second instruction doesn't affect condition of first\n-\t     instruction if switched.  */\n-\t  && !modified_in_p (cond2, insn))\n-\treturn 0;\n-    }\n-\n   present_p = 1;\n #ifdef INSN_SCHEDULING\n   /* ??? No good way to tell from here whether we're doing interblock\n@@ -348,7 +349,10 @@ static void\n add_dependence_list (rtx insn, rtx list, enum reg_note dep_type)\n {\n   for (; list; list = XEXP (list, 1))\n-    add_dependence (insn, XEXP (list, 0), dep_type);\n+    {\n+      if (! sched_insns_conditions_mutex_p (insn, XEXP (list, 0)))\n+\tadd_dependence (insn, XEXP (list, 0), dep_type);\n+    }\n }\n \n /* Similar, but free *LISTP at the same time.  */\n@@ -360,7 +364,8 @@ add_dependence_list_and_free (rtx insn, rtx *listp, enum reg_note dep_type)\n   for (list = *listp, *listp = NULL; list ; list = next)\n     {\n       next = XEXP (list, 1);\n-      add_dependence (insn, XEXP (list, 0), dep_type);\n+      if (! sched_insns_conditions_mutex_p (insn, XEXP (list, 0)))\n+\tadd_dependence (insn, XEXP (list, 0), dep_type);\n       free_INSN_LIST_node (list);\n     }\n }\n@@ -393,7 +398,7 @@ delete_all_dependences (rtx insn)\n static void\n fixup_sched_groups (rtx insn)\n {\n-  rtx link;\n+  rtx link, prev_nonnote;\n \n   for (link = LOG_LINKS (insn); link ; link = XEXP (link, 1))\n     {\n@@ -405,14 +410,17 @@ fixup_sched_groups (rtx insn)\n \t  if (XEXP (link, 0) == i)\n \t    goto next_link;\n \t} while (SCHED_GROUP_P (i));\n-      add_dependence (i, XEXP (link, 0), REG_NOTE_KIND (link));\n+      if (! sched_insns_conditions_mutex_p (i, XEXP (link, 0)))\n+\tadd_dependence (i, XEXP (link, 0), REG_NOTE_KIND (link));\n     next_link:;\n     }\n \n   delete_all_dependences (insn);\n \n-  if (BLOCK_FOR_INSN (insn) == BLOCK_FOR_INSN (prev_nonnote_insn (insn)))\n-    add_dependence (insn, prev_nonnote_insn (insn), REG_DEP_ANTI);\n+  prev_nonnote = prev_nonnote_insn (insn);\n+  if (BLOCK_FOR_INSN (insn) == BLOCK_FOR_INSN (prev_nonnote)\n+      && ! sched_insns_conditions_mutex_p (insn, prev_nonnote))\n+    add_dependence (insn, prev_nonnote, REG_DEP_ANTI);\n }\n \f\n /* Process an insn's memory dependencies.  There are four kinds of\n@@ -620,7 +628,8 @@ sched_analyze_1 (struct deps *deps, rtx x, rtx insn)\n \t  pending_mem = deps->pending_read_mems;\n \t  while (pending)\n \t    {\n-\t      if (anti_dependence (XEXP (pending_mem, 0), t))\n+\t      if (anti_dependence (XEXP (pending_mem, 0), t)\n+\t\t  && ! sched_insns_conditions_mutex_p (insn, XEXP (pending, 0)))\n \t\tadd_dependence (insn, XEXP (pending, 0), REG_DEP_ANTI);\n \n \t      pending = XEXP (pending, 1);\n@@ -631,7 +640,8 @@ sched_analyze_1 (struct deps *deps, rtx x, rtx insn)\n \t  pending_mem = deps->pending_write_mems;\n \t  while (pending)\n \t    {\n-\t      if (output_dependence (XEXP (pending_mem, 0), t))\n+\t      if (output_dependence (XEXP (pending_mem, 0), t)\n+\t\t  && ! sched_insns_conditions_mutex_p (insn, XEXP (pending, 0)))\n \t\tadd_dependence (insn, XEXP (pending, 0), REG_DEP_OUTPUT);\n \n \t      pending = XEXP (pending, 1);\n@@ -759,7 +769,8 @@ sched_analyze_2 (struct deps *deps, rtx x, rtx insn)\n \tpending_mem = deps->pending_read_mems;\n \twhile (pending)\n \t  {\n-\t    if (read_dependence (XEXP (pending_mem, 0), t))\n+\t    if (read_dependence (XEXP (pending_mem, 0), t)\n+\t\t&& ! sched_insns_conditions_mutex_p (insn, XEXP (pending, 0)))\n \t      add_dependence (insn, XEXP (pending, 0), REG_DEP_ANTI);\n \n \t    pending = XEXP (pending, 1);\n@@ -771,16 +782,17 @@ sched_analyze_2 (struct deps *deps, rtx x, rtx insn)\n \twhile (pending)\n \t  {\n \t    if (true_dependence (XEXP (pending_mem, 0), VOIDmode,\n-\t\t\t\t t, rtx_varies_p))\n-\t      add_dependence (insn, XEXP (pending, 0), 0);\n+\t\t\t\t t, rtx_varies_p)\n+\t\t&& ! sched_insns_conditions_mutex_p (insn, XEXP (pending, 0)))\n+\t      add_dependence (insn, XEXP (pending, 0), REG_DEP_TRUE);\n \n \t    pending = XEXP (pending, 1);\n \t    pending_mem = XEXP (pending_mem, 1);\n \t  }\n \n \tfor (u = deps->last_pending_memory_flush; u; u = XEXP (u, 1))\n-\t  if (!JUMP_P (XEXP (u, 0))\n-\t      || deps_may_trap_p (x))\n+\t  if ((! JUMP_P (XEXP (u, 0)) || deps_may_trap_p (x))\n+\t      && ! sched_insns_conditions_mutex_p (insn, XEXP (u, 0)))\n \t    add_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);\n \n \t/* Always add these dependencies to pending_reads, since\n@@ -966,7 +978,8 @@ sched_analyze_insn (struct deps *deps, rtx x, rtx insn, rtx loop_notes)\n \t  pending_mem = deps->pending_write_mems;\n \t  while (pending)\n \t    {\n-\t      add_dependence (insn, XEXP (pending, 0), REG_DEP_OUTPUT);\n+\t      if (! sched_insns_conditions_mutex_p (insn, XEXP (pending, 0)))\n+\t\tadd_dependence (insn, XEXP (pending, 0), REG_DEP_OUTPUT);\n \t      pending = XEXP (pending, 1);\n \t      pending_mem = XEXP (pending_mem, 1);\n \t    }\n@@ -975,7 +988,8 @@ sched_analyze_insn (struct deps *deps, rtx x, rtx insn, rtx loop_notes)\n \t  pending_mem = deps->pending_read_mems;\n \t  while (pending)\n \t    {\n-\t      if (MEM_VOLATILE_P (XEXP (pending_mem, 0)))\n+\t      if (MEM_VOLATILE_P (XEXP (pending_mem, 0))\n+\t\t  && ! sched_insns_conditions_mutex_p (insn, XEXP (pending, 0)))\n \t\tadd_dependence (insn, XEXP (pending, 0), REG_DEP_OUTPUT);\n \t      pending = XEXP (pending, 1);\n \t      pending_mem = XEXP (pending_mem, 1);\n@@ -1019,18 +1033,18 @@ sched_analyze_insn (struct deps *deps, rtx x, rtx insn, rtx loop_notes)\n     {\n       /* In the case of barrier the most added dependencies are not\n          real, so we use anti-dependence here.  */\n-      if (GET_CODE (PATTERN (insn)) == COND_EXEC)\n+      if (sched_get_condition (insn))\n \t{\n \t  EXECUTE_IF_SET_IN_REG_SET (&deps->reg_last_in_use, 0, i, rsi)\n \t    {\n \t      struct deps_reg *reg_last = &deps->reg_last[i];\n \t      add_dependence_list (insn, reg_last->uses, REG_DEP_ANTI);\n \t      add_dependence_list\n \t\t(insn, reg_last->sets,\n-\t\t reg_pending_barrier == TRUE_BARRIER ? 0 : REG_DEP_ANTI);\n+\t\t reg_pending_barrier == TRUE_BARRIER ? REG_DEP_TRUE : REG_DEP_ANTI);\n \t      add_dependence_list\n \t\t(insn, reg_last->clobbers,\n-\t\t reg_pending_barrier == TRUE_BARRIER ? 0 : REG_DEP_ANTI);\n+\t\t reg_pending_barrier == TRUE_BARRIER ? REG_DEP_TRUE : REG_DEP_ANTI);\n \t    }\n \t}\n       else\n@@ -1042,10 +1056,10 @@ sched_analyze_insn (struct deps *deps, rtx x, rtx insn, rtx loop_notes)\n \t\t\t\t\t    REG_DEP_ANTI);\n \t      add_dependence_list_and_free\n \t\t(insn, &reg_last->sets,\n-\t\t reg_pending_barrier == TRUE_BARRIER ? 0 : REG_DEP_ANTI);\n+\t\t reg_pending_barrier == TRUE_BARRIER ? REG_DEP_TRUE : REG_DEP_ANTI);\n \t      add_dependence_list_and_free\n \t\t(insn, &reg_last->clobbers,\n-\t\t reg_pending_barrier == TRUE_BARRIER ? 0 : REG_DEP_ANTI);\n+\t\t reg_pending_barrier == TRUE_BARRIER ? REG_DEP_TRUE : REG_DEP_ANTI);\n \t      reg_last->uses_length = 0;\n \t      reg_last->clobbers_length = 0;\n \t    }\n@@ -1066,13 +1080,13 @@ sched_analyze_insn (struct deps *deps, rtx x, rtx insn, rtx loop_notes)\n     {\n       /* If the current insn is conditional, we can't free any\n \t of the lists.  */\n-      if (GET_CODE (PATTERN (insn)) == COND_EXEC)\n+      if (sched_get_condition (insn))\n \t{\n \t  EXECUTE_IF_SET_IN_REG_SET (reg_pending_uses, 0, i, rsi)\n \t    {\n \t      struct deps_reg *reg_last = &deps->reg_last[i];\n-\t      add_dependence_list (insn, reg_last->sets, 0);\n-\t      add_dependence_list (insn, reg_last->clobbers, 0);\n+\t      add_dependence_list (insn, reg_last->sets, REG_DEP_TRUE);\n+\t      add_dependence_list (insn, reg_last->clobbers, REG_DEP_TRUE);\n \t      reg_last->uses = alloc_INSN_LIST (insn, reg_last->uses);\n \t      reg_last->uses_length++;\n \t    }\n@@ -1099,8 +1113,8 @@ sched_analyze_insn (struct deps *deps, rtx x, rtx insn, rtx loop_notes)\n \t  EXECUTE_IF_SET_IN_REG_SET (reg_pending_uses, 0, i, rsi)\n \t    {\n \t      struct deps_reg *reg_last = &deps->reg_last[i];\n-\t      add_dependence_list (insn, reg_last->sets, 0);\n-\t      add_dependence_list (insn, reg_last->clobbers, 0);\n+\t      add_dependence_list (insn, reg_last->sets, REG_DEP_TRUE);\n+\t      add_dependence_list (insn, reg_last->clobbers, REG_DEP_TRUE);\n \t      reg_last->uses_length++;\n \t      reg_last->uses = alloc_INSN_LIST (insn, reg_last->uses);\n \t    }"}, {"sha": "58f5d338ecd29e5b3bec5e601a400c96700df7c7", "filename": "gcc/sched-ebb.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bd1e239eed6f64319af87e9f437eab1ca83d63e/gcc%2Fsched-ebb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bd1e239eed6f64319af87e9f437eab1ca83d63e/gcc%2Fsched-ebb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-ebb.c?ref=2bd1e239eed6f64319af87e9f437eab1ca83d63e", "patch": "@@ -454,7 +454,8 @@ add_deps_for_risky_insns (rtx head, rtx tail)\n \t    /* We can not change the mode of the backward\n \t       dependency because REG_DEP_ANTI has the lowest\n \t       rank.  */\n-\t    if (add_dependence (insn, prev, REG_DEP_ANTI))\n+\t    if (! sched_insns_conditions_mutex_p (insn, prev)\n+\t\t&& add_dependence (insn, prev, REG_DEP_ANTI))\n \t      add_forward_dependence (prev, insn, REG_DEP_ANTI);\n             break;\n "}, {"sha": "46ec6e77327e3cf90acce925c25240ee650cf6e7", "filename": "gcc/sched-int.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bd1e239eed6f64319af87e9f437eab1ca83d63e/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bd1e239eed6f64319af87e9f437eab1ca83d63e/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=2bd1e239eed6f64319af87e9f437eab1ca83d63e", "patch": "@@ -331,6 +331,7 @@ enum INSN_TRAP_CLASS\n extern void print_insn (char *, rtx, int);\n \n /* Functions in sched-deps.c.  */\n+extern bool sched_insns_conditions_mutex_p (rtx, rtx);\n extern int add_dependence (rtx, rtx, enum reg_note);\n extern void sched_analyze (struct deps *, rtx, rtx);\n extern void init_deps (struct deps *);"}, {"sha": "a4c19648200ec944fed7e7ec300e148403ede6a6", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 57, "deletions": 2, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bd1e239eed6f64319af87e9f437eab1ca83d63e/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bd1e239eed6f64319af87e9f437eab1ca83d63e/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=2bd1e239eed6f64319af87e9f437eab1ca83d63e", "patch": "@@ -1883,6 +1883,8 @@ add_branch_dependences (rtx head, rtx tail)\n      cc0 setters remain at the end because they can't be moved away from\n      their cc0 user.\n \n+     COND_EXEC insns cannot be moved past a branch (see e.g. PR17808).\n+\n      Insns setting CLASS_LIKELY_SPILLED_P registers (usually return values)\n      are not moved before reload because we can wind up with register\n      allocation failures.  */\n@@ -1906,7 +1908,8 @@ add_branch_dependences (rtx head, rtx tail)\n \t{\n \t  if (last != 0 && !find_insn_list (insn, LOG_LINKS (last)))\n \t    {\n-\t      add_dependence (last, insn, REG_DEP_ANTI);\n+\t      if (! sched_insns_conditions_mutex_p (last, insn))\n+\t\tadd_dependence (last, insn, REG_DEP_ANTI);\n \t      INSN_REF_COUNT (insn)++;\n \t    }\n \n@@ -1932,9 +1935,61 @@ add_branch_dependences (rtx head, rtx tail)\n \tif (INSN_REF_COUNT (insn) != 0)\n \t  continue;\n \n-\tadd_dependence (last, insn, REG_DEP_ANTI);\n+\tif (! sched_insns_conditions_mutex_p (last, insn))\n+\t  add_dependence (last, insn, REG_DEP_ANTI);\n \tINSN_REF_COUNT (insn) = 1;\n       }\n+\n+#ifdef HAVE_conditional_execution\n+  /* Finally, if the block ends in a jump, and we are doing intra-block\n+     scheduling, make sure that the branch depends on any COND_EXEC insns\n+     inside the block to avoid moving the COND_EXECs past the branch insn.\n+\n+     We only have to do this after reload, because (1) before reload there\n+     are no COND_EXEC insns, and (2) the region scheduler is an intra-block\n+     scheduler after reload.\n+\n+     FIXME: We could in some cases move COND_EXEC insns past the branch if\n+     this scheduler would be a little smarter.  Consider this code:\n+\n+\t\tT = [addr]\n+\tC  ?\taddr += 4\n+\t!C  ?\tX += 12\n+\tC  ?\tT += 1\n+\tC ?\tjump foo\n+\n+     On a target with a one cycle stall on a memory access the optimal\n+     sequence would be:\n+\n+\t\tT = [addr]\n+\tC  ?\taddr += 4\n+\tC  ?\tT += 1\n+\tC  ?\tjump foo\n+\t!C ?\tX += 12\n+\n+     We don't want to put the 'X += 12' before the branch because it just\n+     wastes a cycle of execution time when the branch is taken.\n+\n+     Note that in the example \"!C\" will always be true.  That is another\n+     possible improvement for handling COND_EXECs in this scheduler: it\n+     could remove always-true predicates.  */\n+\n+  if (!reload_completed || ! JUMP_P (tail))\n+    return;\n+\n+  insn = PREV_INSN (tail);\n+  while (insn != head)\n+    {\n+      /* Note that we want to add this dependency even when\n+\t sched_insns_conditions_mutex_p returns true.  The whole point\n+\t is that we _want_ this dependency, even if these insns really\n+\t are independent.  */\n+      if (INSN_P (insn) && GET_CODE (PATTERN (insn)) == COND_EXEC)\n+\tadd_dependence (tail, insn, REG_DEP_ANTI);\n+\n+      insn = PREV_INSN (insn);\n+    }\n+#endif\n }\n \n /* Data structures for the computation of data dependences in a regions.  We"}]}