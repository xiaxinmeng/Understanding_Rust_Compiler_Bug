{"sha": "2eed8e37019cecd79d95b81ecfb6f8605b6361fa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmVlZDhlMzcwMTljZWNkNzlkOTViODFlY2ZiNmY4NjA1YjYzNjFmYQ==", "commit": {"author": {"name": "Bronek Kozicki", "email": "b.kozicki@gmail.com", "date": "2013-04-01T19:04:59Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2013-04-01T19:04:59Z"}, "message": "Implement N2439 (ref-qualifiers for 'this')\n\n\tImplement N2439 (ref-qualifiers for 'this')\n\t* cp-tree.h (FUNCTION_REF_QUALIFIED): New.\n\t(FUNCTION_RVALUE_QUALIFIED): New.\n\t(FUNCTION_OR_METHOD_TYPE_CHECK): New.\n\t(cpp0x_warn_str): Add CPP0X_REF_QUALIFIER.\n\t(cp_ref_qualifier): New enum.\n\t(cp_declarator): Add ref_qualifier.\n\t* parser.c (cp_parser_ref_qualifier_seq_opt): New.\n\t(cp_parser_direct_declarator): Use it.\n\t(make_call_declarator): Adjust.\n\t(cp_parser_lambda_declarator_opt): Adjust.\n\t* call.c (add_function_candidate): Handle ref-qualifier overload\n\tresolution semantics.\n\t(standard_conversion): Adjust.\n\t* class.c (add_method, same_signature_p): Compare ref-qualifiers.\n\t* decl.c (grokdeclarator): Handle ref-qualifiers.\n\t(grokfndecl): Check for invalid ref-qualifiers.\n\t(static_fn_type, revert_static_member_fn): Adjust.\n\t* decl2.c (build_memfn_type): Handle ref-qualifiers.\n\t(check_classfn): Check them.\n\t(cp_reconstruct_complex_type): Retain them.\n\t* error.c (dump_ref_qualifier): New.\n\t(dump_type_suffix, dump_function_decl): Use it.\n\t(maybe_warn_cpp0x): Handle CPP0X_REF_QUALIFIER.\n\t* pt.c (tsubst, tsubst_function_type): Instantiate ref-quals.\n\t(unify): Retain them.\n\t* tree.c (cp_check_qualified_type): New.\n\t(cp_build_qualified_type_real): Keep exception spec and ref-qual.\n\t(build_ref_qualified_type): New.\n\t(strip_typedefs, build_exception_variant): Keep ref-qualifier.\n\t(cp_build_type_attribute_variant): Keep ref-qualifier.\n\t* typeck.c (merge_types): Keep ref-qualifier.\n\t(structural_comptypes): Compare ref-qualifier.\n\t(type_memfn_rqual): New.\n\t(apply_memfn_quals): Take ref-qual argument.\n\t* typeck2.c (build_m_component_ref): Check ref-qualifier.\n\nCo-Authored-By: Jason Merrill <jason@redhat.com>\n\nFrom-SVN: r197315", "tree": {"sha": "b559fa7f7e6f0e57d15a631da9a9be7802955ac1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b559fa7f7e6f0e57d15a631da9a9be7802955ac1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2eed8e37019cecd79d95b81ecfb6f8605b6361fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2eed8e37019cecd79d95b81ecfb6f8605b6361fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2eed8e37019cecd79d95b81ecfb6f8605b6361fa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2eed8e37019cecd79d95b81ecfb6f8605b6361fa/comments", "author": {"login": "Bronek", "id": 823856, "node_id": "MDQ6VXNlcjgyMzg1Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/823856?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Bronek", "html_url": "https://github.com/Bronek", "followers_url": "https://api.github.com/users/Bronek/followers", "following_url": "https://api.github.com/users/Bronek/following{/other_user}", "gists_url": "https://api.github.com/users/Bronek/gists{/gist_id}", "starred_url": "https://api.github.com/users/Bronek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Bronek/subscriptions", "organizations_url": "https://api.github.com/users/Bronek/orgs", "repos_url": "https://api.github.com/users/Bronek/repos", "events_url": "https://api.github.com/users/Bronek/events{/privacy}", "received_events_url": "https://api.github.com/users/Bronek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5bc08e85f179b65b4e8f4bb70421216805c5c6bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bc08e85f179b65b4e8f4bb70421216805c5c6bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5bc08e85f179b65b4e8f4bb70421216805c5c6bf"}], "stats": {"total": 672, "additions": 612, "deletions": 60}, "files": [{"sha": "598c2a52ee9411eb9a55aab2ebf9bf44c1ad8189", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eed8e37019cecd79d95b81ecfb6f8605b6361fa/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eed8e37019cecd79d95b81ecfb6f8605b6361fa/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2eed8e37019cecd79d95b81ecfb6f8605b6361fa", "patch": "@@ -1,3 +1,43 @@\n+2013-04-01  Bronek Kozicki <b.kozicki@gmail.com>\n+\t    Jason Merrill  <jason@redhat.com>\n+\n+\tImplement N2439 (ref-qualifiers for 'this')\n+\t* cp-tree.h (FUNCTION_REF_QUALIFIED): New.\n+\t(FUNCTION_RVALUE_QUALIFIED): New.\n+\t(FUNCTION_OR_METHOD_TYPE_CHECK): New.\n+\t(cpp0x_warn_str): Add CPP0X_REF_QUALIFIER.\n+\t(cp_ref_qualifier): New enum.\n+\t(cp_declarator): Add ref_qualifier.\n+\t* parser.c (cp_parser_ref_qualifier_seq_opt): New.\n+\t(cp_parser_direct_declarator): Use it.\n+\t(make_call_declarator): Adjust.\n+\t(cp_parser_lambda_declarator_opt): Adjust.\n+\t* call.c (add_function_candidate): Handle ref-qualifier overload\n+\tresolution semantics.\n+\t(standard_conversion): Adjust.\n+\t* class.c (add_method, same_signature_p): Compare ref-qualifiers.\n+\t* decl.c (grokdeclarator): Handle ref-qualifiers.\n+\t(grokfndecl): Check for invalid ref-qualifiers.\n+\t(static_fn_type, revert_static_member_fn): Adjust.\n+\t* decl2.c (build_memfn_type): Handle ref-qualifiers.\n+\t(check_classfn): Check them.\n+\t(cp_reconstruct_complex_type): Retain them.\n+\t* error.c (dump_ref_qualifier): New.\n+\t(dump_type_suffix, dump_function_decl): Use it.\n+\t(maybe_warn_cpp0x): Handle CPP0X_REF_QUALIFIER.\n+\t* pt.c (tsubst, tsubst_function_type): Instantiate ref-quals.\n+\t(unify): Retain them.\n+\t* tree.c (cp_check_qualified_type): New.\n+\t(cp_build_qualified_type_real): Keep exception spec and ref-qual.\n+\t(build_ref_qualified_type): New.\n+\t(strip_typedefs, build_exception_variant): Keep ref-qualifier.\n+\t(cp_build_type_attribute_variant): Keep ref-qualifier.\n+\t* typeck.c (merge_types): Keep ref-qualifier.\n+\t(structural_comptypes): Compare ref-qualifier.\n+\t(type_memfn_rqual): New.\n+\t(apply_memfn_quals): Take ref-qual argument.\n+\t* typeck2.c (build_m_component_ref): Check ref-qualifier.\n+\n 2013-04-01  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* cp-tree.h (DECL_UNBOUND_CLASS_TEMPLATE_P): Remove."}, {"sha": "712bd17af0f3e0cbc94b8608ee70073d7a55106d", "filename": "gcc/cp/call.c", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eed8e37019cecd79d95b81ecfb6f8605b6361fa/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eed8e37019cecd79d95b81ecfb6f8605b6361fa/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=2eed8e37019cecd79d95b81ecfb6f8605b6361fa", "patch": "@@ -1276,7 +1276,10 @@ standard_conversion (tree to, tree from, tree expr, bool c_cast_p,\n \t\t\t   static_fn_type (tofn)))\n \treturn NULL;\n \n-      from = build_memfn_type (fromfn, tbase, cp_type_quals (tbase));\n+      from = build_memfn_type (fromfn,\n+                               tbase,\n+                               cp_type_quals (tbase),\n+                               type_memfn_rqual (tofn));\n       from = build_ptrmemfunc_type (build_pointer_type (from));\n       conv = build_conv (ck_pmem, from, conv);\n       conv->base_p = true;\n@@ -1950,7 +1953,17 @@ add_function_candidate (struct z_candidate **candidates,\n \t    {\n \t      parmtype = cp_build_qualified_type\n \t\t(ctype, cp_type_quals (TREE_TYPE (parmtype)));\n-\t      parmtype = build_pointer_type (parmtype);\n+\t      if (FUNCTION_REF_QUALIFIED (TREE_TYPE (fn)))\n+\t\t{\n+\t\t  /* If the function has a ref-qualifier, the implicit\n+\t\t     object parameter has reference type.  */\n+\t\t  bool rv = FUNCTION_RVALUE_QUALIFIED (TREE_TYPE (fn));\n+\t\t  parmtype = cp_build_reference_type (parmtype, rv);\n+\t\t  arg = build_fold_indirect_ref (arg);\n+\t\t  argtype = lvalue_type (arg);\n+\t\t}\n+\t      else\n+\t\tparmtype = build_pointer_type (parmtype);\n \t    }\n \n \t  /* Core issue 899: When [copy-]initializing a temporary to be bound"}, {"sha": "54180a27994966cbabee46fd1b74ecadc795559a", "filename": "gcc/cp/class.c", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eed8e37019cecd79d95b81ecfb6f8605b6361fa/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eed8e37019cecd79d95b81ecfb6f8605b6361fa/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=2eed8e37019cecd79d95b81ecfb6f8605b6361fa", "patch": "@@ -1045,6 +1045,12 @@ add_method (tree type, tree method, tree using_decl)\n \t overloaded if any of them is a static member\n \t function declaration.\n \n+\t [over.load] Member function declarations with the same name and\n+\t the same parameter-type-list as well as member function template\n+\t declarations with the same name, the same parameter-type-list, and\n+\t the same template parameter lists cannot be overloaded if any of\n+\t them, but not all, have a ref-qualifier.\n+\n \t [namespace.udecl] When a using-declaration brings names\n \t from a base class into a derived class scope, member\n \t functions in the derived class override and/or hide member\n@@ -1060,11 +1066,13 @@ add_method (tree type, tree method, tree using_decl)\n \t coming from the using class in overload resolution.  */\n       if (! DECL_STATIC_FUNCTION_P (fn)\n \t  && ! DECL_STATIC_FUNCTION_P (method)\n-\t  && TREE_TYPE (TREE_VALUE (parms1)) != error_mark_node\n-\t  && TREE_TYPE (TREE_VALUE (parms2)) != error_mark_node\n-\t  && (cp_type_quals (TREE_TYPE (TREE_VALUE (parms1)))\n-\t      != cp_type_quals (TREE_TYPE (TREE_VALUE (parms2)))))\n-\tcontinue;\n+\t  /* Either both or neither need to be ref-qualified for\n+\t     differing quals to allow overloading.  */\n+\t  && (FUNCTION_REF_QUALIFIED (fn_type)\n+\t      == FUNCTION_REF_QUALIFIED (method_type))\n+\t  && (type_memfn_quals (fn_type) != type_memfn_quals (method_type)\n+\t      || type_memfn_rqual (fn_type) != type_memfn_rqual (method_type)))\n+\t  continue;\n \n       /* For templates, the return type and template parameters\n \t must be identical.  */\n@@ -2063,6 +2071,8 @@ same_signature_p (const_tree fndecl, const_tree base_fndecl)\n       base_types = TYPE_ARG_TYPES (TREE_TYPE (base_fndecl));\n       if ((cp_type_quals (TREE_TYPE (TREE_VALUE (base_types)))\n \t   == cp_type_quals (TREE_TYPE (TREE_VALUE (types))))\n+\t  && (type_memfn_rqual (TREE_TYPE (fndecl))\n+\t      == type_memfn_rqual (TREE_TYPE (base_fndecl)))\n \t  && compparms (TREE_CHAIN (base_types), TREE_CHAIN (types)))\n \treturn 1;\n     }"}, {"sha": "74ea4e49b83b2d59dcf7e90633d51d5df6e09a5e", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 41, "deletions": 4, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eed8e37019cecd79d95b81ecfb6f8605b6361fa/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eed8e37019cecd79d95b81ecfb6f8605b6361fa/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=2eed8e37019cecd79d95b81ecfb6f8605b6361fa", "patch": "@@ -107,8 +107,10 @@ c-common.h, not after.\n \t  or FIELD_DECL).\n       IDENTIFIER_TYPENAME_P (in IDENTIFIER_NODE)\n       DECL_TINFO_P (in VAR_DECL)\n+      FUNCTION_REF_QUALIFIED (in FUNCTION_TYPE, METHOD_TYPE)\n    5: C_IS_RESERVED_WORD (in IDENTIFIER_NODE)\n       DECL_VTABLE_OR_VTT_P (in VAR_DECL)\n+      FUNCTION_RVALUE_QUALIFIED (in FUNCTION_TYPE, METHOD_TYPE)\n    6: IDENTIFIER_REPO_CHOSEN (in IDENTIFIER_NODE)\n       DECL_CONSTRUCTION_VTABLE_P (in VAR_DECL)\n       TYPE_MARKED_P (in _TYPE)\n@@ -221,6 +223,9 @@ c-common.h, not after.\n #define BOUND_TEMPLATE_TEMPLATE_PARM_TYPE_CHECK(NODE) \\\n   TREE_CHECK(NODE,BOUND_TEMPLATE_TEMPLATE_PARM)\n \n+#define FUNCTION_OR_METHOD_TYPE_CHECK(NODE) \\\n+  TREE_CHECK2(NODE,FUNCTION_TYPE,METHOD_TYPE)\n+\n #if defined ENABLE_TREE_CHECKING && (GCC_VERSION >= 2007)\n #define THUNK_FUNCTION_CHECK(NODE) __extension__\t\t\t\\\n ({  __typeof (NODE) const __t = (NODE);\t\t\t\t\t\\\n@@ -431,9 +436,11 @@ typedef enum cpp0x_warn_str\n   /* inheriting constructors */\n   CPP0X_INHERITING_CTORS,\n   /* C++11 attributes */\n-  CPP0X_ATTRIBUTES\n+  CPP0X_ATTRIBUTES,\n+  /* ref-qualified member functions */\n+  CPP0X_REF_QUALIFIER\n } cpp0x_warn_str;\n-  \n+\n /* The various kinds of operation used by composite_pointer_type. */\n \n typedef enum composite_pointer_operation\n@@ -2527,6 +2534,14 @@ struct GTY((variable_size)) lang_decl {\n /* 1 iff VAR_DECL node NODE is virtual table or VTT.  */\n #define DECL_VTABLE_OR_VTT_P(NODE) TREE_LANG_FLAG_5 (VAR_DECL_CHECK (NODE))\n \n+/* 1 iff FUNCTION_TYPE or METHOD_TYPE has a ref-qualifier (either & or &&). */\n+#define FUNCTION_REF_QUALIFIED(NODE) \\\n+  TREE_LANG_FLAG_4 (FUNCTION_OR_METHOD_TYPE_CHECK (NODE))\n+\n+/* 1 iff FUNCTION_TYPE or METHOD_TYPE has &&-ref-qualifier.  */\n+#define FUNCTION_RVALUE_QUALIFIED(NODE) \\\n+  TREE_LANG_FLAG_5 (FUNCTION_OR_METHOD_TYPE_CHECK (NODE))\n+\n /* Returns 1 iff VAR_DECL is a construction virtual table.\n    DECL_VTABLE_OR_VTT_P will be true in this case and must be checked\n    before using this macro.  */\n@@ -4691,6 +4706,23 @@ enum virt_specifier\n \n typedef int cp_virt_specifiers;\n \n+/* Wherever there is a function-cv-qual, there could also be a ref-qualifier:\n+\n+   [dcl.fct]\n+   The return type, the parameter-type-list, the ref-qualifier, and\n+   the cv-qualifier-seq, but not the default arguments or the exception\n+   specification, are part of the function type.\n+\n+   REF_QUAL_NONE    Ordinary member function with no ref-qualifier\n+   REF_QUAL_LVALUE  Member function with the &-ref-qualifier\n+   REF_QUAL_RVALUE  Member function with the &&-ref-qualifier */\n+\n+enum cp_ref_qualifier {\n+  REF_QUAL_NONE = 0,\n+  REF_QUAL_LVALUE = 1,\n+  REF_QUAL_RVALUE = 2\n+};\n+\n /* A storage class.  */\n \n typedef enum cp_storage_class {\n@@ -4852,6 +4884,8 @@ struct cp_declarator {\n       cp_cv_quals qualifiers;\n       /* The virt-specifiers for the function.  */\n       cp_virt_specifiers virt_specifiers;\n+      /* The ref-qualifier for the function.  */\n+      cp_ref_qualifier ref_qualifier;\n       /* The exception-specification for the function.  */\n       tree exception_specification;\n       /* The late-specified return type, if any.  */\n@@ -5202,7 +5236,8 @@ extern tree cxx_maybe_build_cleanup\t\t(tree, tsubst_flags_t);\n \n /* in decl2.c */\n extern bool check_java_method\t\t\t(tree);\n-extern tree build_memfn_type\t\t\t(tree, tree, cp_cv_quals);\n+extern tree build_memfn_type\t\t\t(tree, tree, cp_cv_quals, cp_ref_qualifier);\n+extern tree build_pointer_ptrmemfn_type\t(tree);\n extern tree change_return_type\t\t\t(tree, tree);\n extern void maybe_retrofit_in_chrg\t\t(tree);\n extern void maybe_make_one_only\t\t\t(tree);\n@@ -5809,6 +5844,7 @@ extern void diagnose_non_constexpr_vec_init\t(tree);\n extern tree hash_tree_cons\t\t\t(tree, tree, tree);\n extern tree hash_tree_chain\t\t\t(tree, tree);\n extern tree build_qualified_name\t\t(tree, tree, tree, bool);\n+extern tree build_ref_qualified_type\t\t(tree, cp_ref_qualifier);\n extern int is_overloaded_fn\t\t\t(tree);\n extern tree dependent_name\t\t\t(tree);\n extern tree get_fns\t\t\t\t(tree);\n@@ -5966,7 +6002,8 @@ extern tree build_ptrmemfunc\t\t\t(tree, tree, int, bool,\n \t\t\t\t\t\t tsubst_flags_t);\n extern int cp_type_quals\t\t\t(const_tree);\n extern int type_memfn_quals\t\t\t(const_tree);\n-extern tree apply_memfn_quals\t\t\t(tree, cp_cv_quals);\n+extern cp_ref_qualifier type_memfn_rqual\t(const_tree);\n+extern tree apply_memfn_quals\t\t\t(tree, cp_cv_quals, cp_ref_qualifier);\n extern bool cp_has_mutable_p\t\t\t(const_tree);\n extern bool at_least_as_qualified_p\t\t(const_tree, const_tree);\n extern void cp_apply_type_quals_to_decl\t\t(int, tree);"}, {"sha": "9e280eac9f726e5d597a6c9869e7015a03d9b270", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 64, "deletions": 24, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eed8e37019cecd79d95b81ecfb6f8605b6361fa/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eed8e37019cecd79d95b81ecfb6f8605b6361fa/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=2eed8e37019cecd79d95b81ecfb6f8605b6361fa", "patch": "@@ -7319,6 +7319,7 @@ grokfndecl (tree ctype,\n \t    int virtualp,\n \t    enum overload_flags flags,\n \t    cp_cv_quals quals,\n+\t    cp_ref_qualifier rqual,\n \t    tree raises,\n \t    int check,\n \t    int friendp,\n@@ -7335,6 +7336,8 @@ grokfndecl (tree ctype,\n   int staticp = ctype && TREE_CODE (type) == FUNCTION_TYPE;\n   tree t;\n \n+  if (rqual)\n+    type = build_ref_qualified_type (type, rqual);\n   if (raises)\n     type = build_exception_variant (type, raises);\n \n@@ -7542,13 +7545,25 @@ grokfndecl (tree ctype,\n     DECL_DECLARED_CONSTEXPR_P (decl) = true;\n \n   DECL_EXTERNAL (decl) = 1;\n-  if (quals && TREE_CODE (type) == FUNCTION_TYPE)\n+  if (TREE_CODE (type) == FUNCTION_TYPE)\n     {\n-      error (ctype\n-             ? G_(\"static member function %qD cannot have cv-qualifier\")\n-             : G_(\"non-member function %qD cannot have cv-qualifier\"),\n-\t     decl);\n-      quals = TYPE_UNQUALIFIED;\n+      if (quals)\n+\t{\n+\t  error (ctype\n+\t\t ? G_(\"static member function %qD cannot have cv-qualifier\")\n+\t\t : G_(\"non-member function %qD cannot have cv-qualifier\"),\n+\t\t decl);\n+\t  quals = TYPE_UNQUALIFIED;\n+\t}\n+\n+      if (rqual)\n+\t{\n+\t  error (ctype\n+\t\t ? G_(\"static member function %qD cannot have ref-qualifier\")\n+\t\t : G_(\"non-member function %qD cannot have ref-qualifier\"),\n+\t\t decl);\n+\t  rqual = REF_QUAL_NONE;\n+\t}\n     }\n \n   if (IDENTIFIER_OPNAME_P (DECL_NAME (decl))\n@@ -7986,7 +8001,8 @@ build_ptrmem_type (tree class_type, tree member_type)\n   if (TREE_CODE (member_type) == METHOD_TYPE)\n     {\n       cp_cv_quals quals = type_memfn_quals (member_type);\n-      member_type = build_memfn_type (member_type, class_type, quals);\n+      cp_ref_qualifier rqual = type_memfn_rqual (member_type);\n+      member_type = build_memfn_type (member_type, class_type, quals, rqual);\n       return build_ptrmemfunc_type (build_pointer_type (member_type));\n     }\n   else\n@@ -8635,6 +8651,9 @@ grokdeclarator (const cp_declarator *declarator,\n   /* virt-specifiers that apply to the declarator, for a declaration of\n      a member function.  */\n   cp_virt_specifiers virt_specifiers = VIRT_SPEC_UNSPECIFIED;\n+  /* ref-qualifier that applies to the declarator, for a declaration of\n+     a member function.  */\n+  cp_ref_qualifier rqual = REF_QUAL_NONE;\n   /* cv-qualifiers that apply to the type specified by the DECLSPECS.  */\n   int type_quals;\n   tree raises = NULL_TREE;\n@@ -9444,6 +9463,8 @@ grokdeclarator (const cp_declarator *declarator,\n \t    memfn_quals = declarator->u.function.qualifiers;\n \t    /* Pick up virt-specifiers.  */\n             virt_specifiers = declarator->u.function.virt_specifiers;\n+\t    /* And ref-qualifier, too */\n+\t    rqual = declarator->u.function.ref_qualifier;\n \t    /* Pick up the exception specifications.  */\n \t    raises = declarator->u.function.exception_specification;\n \t    /* If the exception-specification is ill-formed, let's pretend\n@@ -9511,12 +9532,13 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t   therefore returns a void type.  */\n \n \t\t/* ISO C++ 12.4/2.  A destructor may not be declared\n-\t\t   const or volatile.  A destructor may not be\n-\t\t   static.\n+\t\t   const or volatile.  A destructor may not be static.\n+\t\t   A destructor may not be declared with ref-qualifier.\n \n \t\t   ISO C++ 12.1.  A constructor may not be declared\n \t\t   const or volatile.  A constructor may not be\n-\t\t   virtual.  A constructor may not be static.  */\n+\t\t   virtual.  A constructor may not be static.\n+\t\t   A constructor may not be declared with ref-qualifier. */\n \t\tif (staticp == 2)\n \t\t  error ((flags == DTOR_FLAG)\n \t\t\t ? G_(\"destructor cannot be static member function\")\n@@ -9529,6 +9551,14 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t    memfn_quals = TYPE_UNQUALIFIED;\n \t\t  }\n \n+\t\tif (rqual)\n+\t\t  {\n+\t\t    error ((flags == DTOR_FLAG)\n+\t\t\t   ? \"destructors may not be ref-qualified\"\n+\t\t\t   : \"constructors may not be ref-qualified\");\n+\t\t    rqual = REF_QUAL_NONE;\n+\t\t  }\n+\n \t\tif (decl_context == FIELD\n \t\t    && !member_function_or_else (ctype,\n \t\t\t\t\t\t current_class_type,\n@@ -9650,14 +9680,18 @@ grokdeclarator (const cp_declarator *declarator,\n \t      memfn_quals |= type_memfn_quals (type);\n \t      type = build_memfn_type (type,\n \t\t\t\t       declarator->u.pointer.class_type,\n-\t\t\t\t       memfn_quals);\n+\t\t\t\t       memfn_quals,\n+\t\t\t\t       rqual);\n \t      if (type == error_mark_node)\n \t\treturn error_mark_node;\n+\n+\t      rqual = REF_QUAL_NONE;\n \t      memfn_quals = TYPE_UNQUALIFIED;\n \t    }\n \n \t  if (TREE_CODE (type) == FUNCTION_TYPE\n-\t      && type_memfn_quals (type) != TYPE_UNQUALIFIED)\n+\t      && (type_memfn_quals (type) != TYPE_UNQUALIFIED\n+\t\t  || type_memfn_rqual (type) != REF_QUAL_NONE))\n             error (declarator->kind == cdk_reference\n                    ? G_(\"cannot declare reference to qualified function type %qT\")\n                    : G_(\"cannot declare pointer to qualified function type %qT\"),\n@@ -10002,12 +10036,13 @@ grokdeclarator (const cp_declarator *declarator,\n \t example \"f S::*\" declares a pointer to a const-qualified\n \t member function of S.  We record the cv-qualification in the\n \t function type.  */\n-      if (memfn_quals && TREE_CODE (type) == FUNCTION_TYPE)\n+      if ((rqual || memfn_quals) && TREE_CODE (type) == FUNCTION_TYPE)\n         {\n-          type = apply_memfn_quals (type, memfn_quals);\n+          type = apply_memfn_quals (type, memfn_quals, rqual);\n           \n           /* We have now dealt with these qualifiers.  */\n           memfn_quals = TYPE_UNQUALIFIED;\n+\t  rqual = REF_QUAL_NONE;\n         }\n \n       if (type_uses_auto (type))\n@@ -10137,8 +10172,10 @@ grokdeclarator (const cp_declarator *declarator,\n       if (decl_context != TYPENAME)\n \t{\n \t  /* A cv-qualifier-seq shall only be part of the function type\n-\t     for a non-static member function. [8.3.5/4 dcl.fct] */\n-\t  if (type_memfn_quals (type) != TYPE_UNQUALIFIED\n+\t     for a non-static member function. A ref-qualifier shall only\n+\t     .... /same as above/ [dcl.fct] */\n+\t  if ((type_memfn_quals (type) != TYPE_UNQUALIFIED\n+\t       || type_memfn_rqual (type) != REF_QUAL_NONE)\n \t      && (current_class_type == NULL_TREE || staticp) )\n \t    {\n \t      error (staticp\n@@ -10152,6 +10189,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t  /* The qualifiers on the function type become the qualifiers on\n \t     the non-static member function. */\n \t  memfn_quals |= type_memfn_quals (type);\n+\t  rqual = type_memfn_rqual (type);\n \t  type_quals = TYPE_UNQUALIFIED;\n \t}\n     }\n@@ -10216,10 +10254,10 @@ grokdeclarator (const cp_declarator *declarator,\n \t    ctype = TYPE_METHOD_BASETYPE (type);\n \n \t  if (ctype)\n-\t    type = build_memfn_type (type, ctype, memfn_quals);\n+\t    type = build_memfn_type (type, ctype, memfn_quals, rqual);\n \t  /* Core issue #547: need to allow this in template type args.  */\n \t  else if (template_type_arg && TREE_CODE (type) == FUNCTION_TYPE)\n-\t    type = apply_memfn_quals (type, memfn_quals);\n+\t    type = apply_memfn_quals (type, memfn_quals, rqual);\n \t  else\n \t    error (\"invalid qualifiers on non-member function type\");\n \t}\n@@ -10288,7 +10326,7 @@ grokdeclarator (const cp_declarator *declarator,\n       cp_cv_quals real_quals = memfn_quals;\n       if (constexpr_p && sfk != sfk_constructor && sfk != sfk_destructor)\n \treal_quals |= TYPE_QUAL_CONST;\n-      type = build_memfn_type (type, ctype, real_quals);\n+      type = build_memfn_type (type, ctype, real_quals, rqual);\n     }\n \n   {\n@@ -10420,7 +10458,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t\t       ? unqualified_id : dname,\n \t\t\t       parms,\n \t\t\t       unqualified_id,\n-\t\t\t       virtualp, flags, memfn_quals, raises,\n+\t\t\t       virtualp, flags, memfn_quals, rqual, raises,\n \t\t\t       friendp ? -1 : 0, friendp, publicp,\n                                inlinep | (2 * constexpr_p),\n \t\t\t       sfk,\n@@ -10641,7 +10679,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t   || storage_class != sc_static);\n \n \tdecl = grokfndecl (ctype, type, original_name, parms, unqualified_id,\n-\t\t\t   virtualp, flags, memfn_quals, raises,\n+\t\t\t   virtualp, flags, memfn_quals, rqual, raises,\n \t\t\t   1, friendp,\n \t\t\t   publicp, inlinep | (2 * constexpr_p), sfk,\n                            funcdef_flag,\n@@ -14216,8 +14254,9 @@ static_fn_type (tree memfntype)\n     return memfntype;\n   gcc_assert (TREE_CODE (memfntype) == METHOD_TYPE);\n   args = TYPE_ARG_TYPES (memfntype);\n+  cp_ref_qualifier rqual = type_memfn_rqual (memfntype);\n   fntype = build_function_type (TREE_TYPE (memfntype), TREE_CHAIN (args));\n-  fntype = apply_memfn_quals (fntype, type_memfn_quals (memfntype));\n+  fntype = apply_memfn_quals (fntype, type_memfn_quals (memfntype), rqual);\n   fntype = (cp_build_type_attribute_variant\n \t    (fntype, TYPE_ATTRIBUTES (memfntype)));\n   fntype = (build_exception_variant\n@@ -14233,9 +14272,10 @@ revert_static_member_fn (tree decl)\n {\n   tree stype = static_fn_type (decl);\n   cp_cv_quals quals = type_memfn_quals (stype);\n+  cp_ref_qualifier rqual = type_memfn_rqual (stype);\n \n-  if (quals != TYPE_UNQUALIFIED)\n-    stype = apply_memfn_quals (stype, TYPE_UNQUALIFIED);\n+  if (quals != TYPE_UNQUALIFIED || rqual != REF_QUAL_NONE)\n+    stype = apply_memfn_quals (stype, TYPE_UNQUALIFIED, REF_QUAL_NONE);\n \n   TREE_TYPE (decl) = stype;\n "}, {"sha": "ef1f1e7d8508e71f76ac4958efebd1609c61d3f5", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eed8e37019cecd79d95b81ecfb6f8605b6361fa/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eed8e37019cecd79d95b81ecfb6f8605b6361fa/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=2eed8e37019cecd79d95b81ecfb6f8605b6361fa", "patch": "@@ -109,7 +109,8 @@ int at_eof;\n    that apply to the function).  */\n \n tree\n-build_memfn_type (tree fntype, tree ctype, cp_cv_quals quals)\n+build_memfn_type (tree fntype, tree ctype, cp_cv_quals quals,\n+\t\t  cp_ref_qualifier rqual)\n {\n   tree raises;\n   tree attrs;\n@@ -129,10 +130,12 @@ build_memfn_type (tree fntype, tree ctype, cp_cv_quals quals)\n \t\t\t\t       (TREE_CODE (fntype) == METHOD_TYPE\n \t\t\t\t\t? TREE_CHAIN (TYPE_ARG_TYPES (fntype))\n \t\t\t\t\t: TYPE_ARG_TYPES (fntype)));\n-  if (raises)\n-    fntype = build_exception_variant (fntype, raises);\n   if (attrs)\n     fntype = cp_build_type_attribute_variant (fntype, attrs);\n+  if (rqual)\n+    fntype = build_ref_qualified_type (fntype, rqual);\n+  if (raises)\n+    fntype = build_exception_variant (fntype, raises);\n \n   return fntype;\n }\n@@ -157,7 +160,9 @@ change_return_type (tree new_ret, tree fntype)\n   if (TREE_CODE (fntype) == FUNCTION_TYPE)\n     {\n       newtype = build_function_type (new_ret, args);\n-      newtype = apply_memfn_quals (newtype, type_memfn_quals (fntype));\n+      newtype = apply_memfn_quals (newtype,\n+\t\t\t\t   type_memfn_quals (fntype),\n+\t\t\t\t   type_memfn_rqual (fntype));\n     }\n   else\n     newtype = build_method_type_directly\n@@ -672,6 +677,11 @@ check_classfn (tree ctype, tree function, tree template_parms)\n \t  if (is_template != (TREE_CODE (fndecl) == TEMPLATE_DECL))\n \t    continue;\n \n+\t  /* ref-qualifier or absence of same must match.  */\n+\t  if (type_memfn_rqual (TREE_TYPE (function))\n+\t      != type_memfn_rqual (TREE_TYPE (fndecl)))\n+\t    continue;\n+\n \t  /* While finding a match, same types and params are not enough\n \t     if the function is versioned.  Also check version (\"target\")\n \t     attributes.  */\n@@ -1260,7 +1270,9 @@ cp_reconstruct_complex_type (tree type, tree bottom)\n     {\n       inner = cp_reconstruct_complex_type (TREE_TYPE (type), bottom);\n       outer = build_function_type (inner, TYPE_ARG_TYPES (type));\n-      outer = apply_memfn_quals (outer, type_memfn_quals (type));\n+      outer = apply_memfn_quals (outer,\n+\t\t\t\t type_memfn_quals (type),\n+\t\t\t\t type_memfn_rqual (type));\n     }\n   else if (TREE_CODE (type) == METHOD_TYPE)\n     {"}, {"sha": "6df8987a63f309cec0f80e693c25fb513e0585c2", "filename": "gcc/cp/error.c", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eed8e37019cecd79d95b81ecfb6f8605b6361fa/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eed8e37019cecd79d95b81ecfb6f8605b6361fa/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=2eed8e37019cecd79d95b81ecfb6f8605b6361fa", "patch": "@@ -78,6 +78,7 @@ static void dump_aggr_init_expr_args (tree, int, bool);\n static void dump_expr_list (tree, int);\n static void dump_global_iord (tree);\n static void dump_parameters (tree, int);\n+static void dump_ref_qualifier (tree, int);\n static void dump_exception_spec (tree, int);\n static void dump_template_argument (tree, int);\n static void dump_template_argument_list (tree, int);\n@@ -832,6 +833,7 @@ dump_type_suffix (tree t, int flags)\n \t  pp_cxx_cv_qualifier_seq (cxx_pp, class_of_this_parm (t));\n \telse\n \t  pp_cxx_cv_qualifier_seq (cxx_pp, t);\n+\tdump_ref_qualifier (t, flags);\n \tdump_exception_spec (TYPE_RAISES_EXCEPTIONS (t), flags);\n \tdump_type_suffix (TREE_TYPE (t), flags);\n \tbreak;\n@@ -1426,6 +1428,7 @@ dump_function_decl (tree t, int flags)\n \t{\n \t  pp_base (cxx_pp)->padding = pp_before;\n \t  pp_cxx_cv_qualifier_seq (cxx_pp, class_of_this_parm (fntype));\n+\t  dump_ref_qualifier (fntype, flags);\n \t}\n \n       if (flags & TFF_EXCEPTION_SPECIFICATION)\n@@ -1507,6 +1510,21 @@ dump_parameters (tree parmtypes, int flags)\n   pp_cxx_right_paren (cxx_pp);\n }\n \n+/* Print ref-qualifier of a FUNCTION_TYPE or METHOD_TYPE. FLAGS are ignored. */\n+\n+static void\n+dump_ref_qualifier (tree t, int flags ATTRIBUTE_UNUSED)\n+{\n+  if (FUNCTION_REF_QUALIFIED (t))\n+    {\n+      pp_base (cxx_pp)->padding = pp_before;\n+      if (FUNCTION_RVALUE_QUALIFIED (t))\n+        pp_cxx_ws_string (cxx_pp, \"&&\");\n+      else\n+        pp_cxx_ws_string (cxx_pp, \"&\");\n+    }\n+}\n+\n /* Print an exception specification. T is the exception specification.  */\n \n static void\n@@ -3408,6 +3426,11 @@ maybe_warn_cpp0x (cpp0x_warn_str str)\n \t\t \"c++11 attributes \"\n \t\t \"only available with -std=c++11 or -std=gnu++11\");\n \tbreak;\n+      case CPP0X_REF_QUALIFIER:\n+\tpedwarn (input_location, 0,\n+\t\t \"ref-qualifiers \"\n+\t\t \"only available with -std=c++0x or -std=gnu++0x\");\n+\tbreak;\n       default:\n \tgcc_unreachable ();\n       }"}, {"sha": "f29e80db7c5306c3ad589c9f0a4c83b73bca99e0", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 46, "deletions": 3, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eed8e37019cecd79d95b81ecfb6f8605b6361fa/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eed8e37019cecd79d95b81ecfb6f8605b6361fa/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=2eed8e37019cecd79d95b81ecfb6f8605b6361fa", "patch": "@@ -1234,7 +1234,7 @@ clear_decl_specs (cp_decl_specifier_seq *decl_specs)\n    VAR_DECLs or FUNCTION_DECLs) should do that directly.  */\n \n static cp_declarator *make_call_declarator\n-  (cp_declarator *, tree, cp_cv_quals, cp_virt_specifiers, tree, tree);\n+  (cp_declarator *, tree, cp_cv_quals, cp_virt_specifiers, cp_ref_qualifier, tree, tree);\n static cp_declarator *make_array_declarator\n   (cp_declarator *, tree);\n static cp_declarator *make_pointer_declarator\n@@ -1413,6 +1413,7 @@ make_call_declarator (cp_declarator *target,\n \t\t      tree parms,\n \t\t      cp_cv_quals cv_qualifiers,\n \t\t      cp_virt_specifiers virt_specifiers,\n+\t\t      cp_ref_qualifier ref_qualifier,\n \t\t      tree exception_specification,\n \t\t      tree late_return_type)\n {\n@@ -1423,6 +1424,7 @@ make_call_declarator (cp_declarator *target,\n   declarator->u.function.parameters = parms;\n   declarator->u.function.qualifiers = cv_qualifiers;\n   declarator->u.function.virt_specifiers = virt_specifiers;\n+  declarator->u.function.ref_qualifier = ref_qualifier;\n   declarator->u.function.exception_specification = exception_specification;\n   declarator->u.function.late_return_type = late_return_type;\n   if (target)\n@@ -2018,6 +2020,8 @@ static cp_cv_quals cp_parser_cv_qualifier_seq_opt\n   (cp_parser *);\n static cp_virt_specifiers cp_parser_virt_specifier_seq_opt\n   (cp_parser *);\n+static cp_ref_qualifier cp_parser_ref_qualifier_seq_opt\n+  (cp_parser *);\n static tree cp_parser_late_return_type_opt\n   (cp_parser *, cp_cv_quals);\n static tree cp_parser_declarator_id\n@@ -8640,6 +8644,7 @@ cp_parser_lambda_declarator_opt (cp_parser* parser, tree lambda_expr)\n \t     ? TYPE_UNQUALIFIED : TYPE_QUAL_CONST);\n     declarator = make_call_declarator (declarator, param_list, quals,\n \t\t\t\t       VIRT_SPEC_UNSPECIFIED,\n+                                       REF_QUAL_NONE,\n \t\t\t\t       exception_spec,\n                                        /*late_return_type=*/NULL_TREE);\n     declarator->id_loc = LAMBDA_EXPR_LOCATION (lambda_expr);\n@@ -16309,6 +16314,7 @@ cp_parser_declarator (cp_parser* parser,\n      declarator-id\n      direct-declarator ( parameter-declaration-clause )\n        cv-qualifier-seq [opt]\n+       ref-qualifier [opt]\n        exception-specification [opt]\n      direct-declarator [ constant-expression [opt] ]\n      ( declarator )\n@@ -16317,6 +16323,7 @@ cp_parser_declarator (cp_parser* parser,\n      direct-abstract-declarator [opt]\n        ( parameter-declaration-clause )\n        cv-qualifier-seq [opt]\n+       ref-qualifier [opt]\n        exception-specification [opt]\n      direct-abstract-declarator [opt] [ constant-expression [opt] ]\n      ( abstract-declarator )\n@@ -16431,12 +16438,13 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t      /* Consume the `)'.  */\n \t      cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n \n-\t      /* If all went well, parse the cv-qualifier-seq and the\n-\t\t exception-specification.  */\n+\t      /* If all went well, parse the cv-qualifier-seq,\n+\t\t ref-qualifier and the exception-specification.  */\n \t      if (member_p || cp_parser_parse_definitely (parser))\n \t\t{\n \t\t  cp_cv_quals cv_quals;\n \t\t  cp_virt_specifiers virt_specifiers;\n+\t\t  cp_ref_qualifier ref_qual;\n \t\t  tree exception_specification;\n \t\t  tree late_return;\n \t\t  tree attrs;\n@@ -16451,6 +16459,8 @@ cp_parser_direct_declarator (cp_parser* parser,\n \n \t\t  /* Parse the cv-qualifier-seq.  */\n \t\t  cv_quals = cp_parser_cv_qualifier_seq_opt (parser);\n+\t\t  /* Parse the ref-qualifier. */\n+\t\t  ref_qual = cp_parser_ref_qualifier_seq_opt (parser);\n \t\t  /* And the exception-specification.  */\n \t\t  exception_specification\n \t\t    = cp_parser_exception_specification_opt (parser);\n@@ -16468,6 +16478,7 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t\t\t\t\t\t     params,\n \t\t\t\t\t\t     cv_quals,\n \t\t\t\t\t\t     virt_specifiers,\n+\t\t\t\t\t\t     ref_qual,\n \t\t\t\t\t\t     exception_specification,\n \t\t\t\t\t\t     late_return);\n \t\t  declarator->std_attributes = attrs;\n@@ -17008,6 +17019,38 @@ cp_parser_cv_qualifier_seq_opt (cp_parser* parser)\n   return cv_quals;\n }\n \n+/* Parse an (optional) ref-qualifier\n+\n+   ref-qualifier:\n+     &\n+     &&\n+\n+   Returns cp_ref_qualifier representing ref-qualifier. */\n+\n+static cp_ref_qualifier\n+cp_parser_ref_qualifier_seq_opt (cp_parser* parser)\n+{\n+  cp_ref_qualifier ref_qual = REF_QUAL_NONE;\n+  cp_token *token = cp_lexer_peek_token (parser->lexer);\n+  switch (token->type)\n+    {\n+    case CPP_AND:\n+      ref_qual = REF_QUAL_LVALUE;\n+      break;\n+    case CPP_AND_AND:\n+      ref_qual = REF_QUAL_RVALUE;\n+      break;\n+    }\n+\n+  if (ref_qual)\n+    {\n+      maybe_warn_cpp0x (CPP0X_REF_QUALIFIER);\n+      cp_lexer_consume_token (parser->lexer);\n+    }\n+\n+  return ref_qual;\n+}\n+\n /* Parse an (optional) virt-specifier-seq.\n \n    virt-specifier-seq:"}, {"sha": "d143256b4554d3e6d7f484eddd4513a05d11a8c2", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eed8e37019cecd79d95b81ecfb6f8605b6361fa/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eed8e37019cecd79d95b81ecfb6f8605b6361fa/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=2eed8e37019cecd79d95b81ecfb6f8605b6361fa", "patch": "@@ -10955,7 +10955,9 @@ tsubst_function_type (tree t,\n   if (TREE_CODE (t) == FUNCTION_TYPE)\n     {\n       fntype = build_function_type (return_type, arg_types);\n-      fntype = apply_memfn_quals (fntype, type_memfn_quals (t));\n+      fntype = apply_memfn_quals (fntype,\n+\t\t\t\t  type_memfn_quals (t),\n+\t\t\t\t  type_memfn_rqual (t));\n     }\n   else\n     {\n@@ -10977,6 +10979,7 @@ tsubst_function_type (tree t,\n \n       fntype = build_method_type_directly (r, return_type,\n \t\t\t\t\t   TREE_CHAIN (arg_types));\n+      fntype = build_ref_qualified_type (fntype, type_memfn_rqual (t));\n     }\n   fntype = cp_build_type_attribute_variant (fntype, TYPE_ATTRIBUTES (t));\n \n@@ -11609,7 +11612,9 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t    /* The type of the implicit object parameter gets its\n \t       cv-qualifiers from the FUNCTION_TYPE. */\n \t    tree memptr;\n-\t    tree method_type = build_memfn_type (type, r, type_memfn_quals (type));\n+\t    tree method_type\n+\t      = build_memfn_type (type, r, type_memfn_quals (type),\n+\t\t\t\t  type_memfn_rqual (type));\n \t    memptr = build_ptrmemfunc_type (build_pointer_type (method_type));\n \t    return cp_build_qualified_type_real (memptr, cp_type_quals (t),\n \t\t\t\t\t\t complain);\n@@ -17097,10 +17102,12 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict,\n \t    build_function_type (TREE_TYPE (method_type),\n \t\t\t\t TREE_CHAIN (TYPE_ARG_TYPES (method_type)));\n \n-\t  /* Extract the cv-qualifiers of the member function from the\n-\t     implicit object parameter and place them on the function\n-\t     type to be restored later. */\n-\t  fntype = apply_memfn_quals (fntype, type_memfn_quals (method_type));\n+\t  /* Extract the cv-qualifiers and ref-qualifier of the member\n+\t     function from the implicit object parameter and place them\n+\t     on the function type to be restored later. */\n+\t  fntype = apply_memfn_quals (fntype,\n+\t\t\t\t      type_memfn_quals (method_type),\n+\t\t\t\t      type_memfn_rqual (method_type));\n \t  return unify (tparms, targs, TREE_TYPE (parm), fntype, strict, explain_p);\n \t}\n "}, {"sha": "ce9568c505eb17694602ba3fa2225536745590cf", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 78, "deletions": 5, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eed8e37019cecd79d95b81ecfb6f8605b6361fa/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eed8e37019cecd79d95b81ecfb6f8605b6361fa/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=2eed8e37019cecd79d95b81ecfb6f8605b6361fa", "patch": "@@ -1081,6 +1081,15 @@ cp_build_qualified_type_real (tree type,\n   /* Retrieve (or create) the appropriately qualified variant.  */\n   result = build_qualified_type (type, type_quals);\n \n+  /* Preserve exception specs and ref-qualifier since build_qualified_type\n+     doesn't know about them.  */\n+  if (TREE_CODE (result) == FUNCTION_TYPE\n+      || TREE_CODE (result) == METHOD_TYPE)\n+    {\n+      result = build_exception_variant (result, TYPE_RAISES_EXCEPTIONS (type));\n+      result = build_ref_qualified_type (result, type_memfn_rqual (type));\n+    }\n+\n   /* If this was a pointer-to-method type, and we just made a copy,\n      then we need to unshare the record that holds the cached\n      pointer-to-member-function type, because these will be distinct\n@@ -1214,7 +1223,9 @@ strip_typedefs (tree t)\n \t  {\n \t    result = build_function_type (type,\n \t\t\t\t\t  arg_types);\n-\t    result = apply_memfn_quals (result, type_memfn_quals (t));\n+\t    result = apply_memfn_quals (result,\n+\t\t\t\t\ttype_memfn_quals (t),\n+\t\t\t\t\ttype_memfn_rqual (t));\n \t  }\n \n \tif (TYPE_RAISES_EXCEPTIONS (t))\n@@ -1702,6 +1713,64 @@ build_qualified_name (tree type, tree scope, tree name, bool template_p)\n   return t;\n }\n \n+/* Like check_qualified_type, but also check ref-qualifier and exception\n+   specification.  */\n+\n+static bool\n+cp_check_qualified_type (const_tree cand, const_tree base, int type_quals,\n+\t\t\t cp_ref_qualifier rqual, tree raises)\n+{\n+  return (check_qualified_type (cand, base, type_quals)\n+\t  && comp_except_specs (raises, TYPE_RAISES_EXCEPTIONS (cand),\n+\t\t\t\tce_exact)\n+\t  && type_memfn_rqual (cand) == rqual);\n+}\n+\n+/* Build the FUNCTION_TYPE or METHOD_TYPE with the ref-qualifier RQUAL.  */\n+\n+tree\n+build_ref_qualified_type (tree type, cp_ref_qualifier rqual)\n+{\n+  tree t;\n+\n+  if (rqual == type_memfn_rqual (type))\n+    return type;\n+\n+  int type_quals = TYPE_QUALS (type);\n+  tree raises = TYPE_RAISES_EXCEPTIONS (type);\n+  for (t = TYPE_MAIN_VARIANT (type); t; t = TYPE_NEXT_VARIANT (t))\n+    if (cp_check_qualified_type (t, type, type_quals, rqual, raises))\n+      return t;\n+\n+  t = build_variant_type_copy (type);\n+  switch (rqual)\n+    {\n+    case REF_QUAL_RVALUE:\n+      FUNCTION_RVALUE_QUALIFIED (t) = 1;\n+      /* Intentional fall through */\n+    case REF_QUAL_LVALUE:\n+      FUNCTION_REF_QUALIFIED (t) = 1;\n+      break;\n+    default:\n+      FUNCTION_REF_QUALIFIED (t) = 0;\n+      break;\n+    }\n+\n+  if (TYPE_STRUCTURAL_EQUALITY_P (type))\n+    /* Propagate structural equality. */\n+    SET_TYPE_STRUCTURAL_EQUALITY (t);\n+  else if (TYPE_CANONICAL (type) != type)\n+    /* Build the underlying canonical type, since it is different\n+       from TYPE. */\n+    TYPE_CANONICAL (t) = build_ref_qualified_type (TYPE_CANONICAL (type),\n+\t\t\t\t\t\t   rqual);\n+  else\n+    /* T is its own canonical type. */\n+    TYPE_CANONICAL (t) = t;\n+\n+  return t;\n+}\n+\n /* Returns nonzero if X is an expression for a (possibly overloaded)\n    function.  If \"f\" is a function or function template, \"f\", \"c->f\",\n    \"c.f\", \"C::f\", and \"f<int>\" will all be considered possibly\n@@ -1907,9 +1976,9 @@ build_exception_variant (tree type, tree raises)\n     return type;\n \n   type_quals = TYPE_QUALS (type);\n+  cp_ref_qualifier rqual = type_memfn_rqual (type);\n   for (v = TYPE_MAIN_VARIANT (type); v; v = TYPE_NEXT_VARIANT (v))\n-    if (check_qualified_type (v, type, type_quals)\n-\t&& comp_except_specs (raises, TYPE_RAISES_EXCEPTIONS (v), ce_exact))\n+    if (cp_check_qualified_type (v, type, type_quals, rqual, raises))\n       return v;\n \n   /* Need to build a new variant.  */\n@@ -3308,8 +3377,12 @@ cp_build_type_attribute_variant (tree type, tree attributes)\n   new_type = build_type_attribute_variant (type, attributes);\n   if (TREE_CODE (new_type) == FUNCTION_TYPE\n       || TREE_CODE (new_type) == METHOD_TYPE)\n-    new_type = build_exception_variant (new_type,\n-\t\t\t\t\tTYPE_RAISES_EXCEPTIONS (type));\n+    {\n+      new_type = build_exception_variant (new_type,\n+\t\t\t\t\t  TYPE_RAISES_EXCEPTIONS (type));\n+      new_type = build_ref_qualified_type (new_type,\n+\t\t\t\t\t   type_memfn_rqual (type));\n+    }\n \n   /* Making a new main variant of a class type is broken.  */\n   gcc_assert (!CLASS_TYPE_P (type) || new_type == type);"}, {"sha": "763fc0b3b083c5cbc6f02f638afb82cc64d24177", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 34, "deletions": 5, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eed8e37019cecd79d95b81ecfb6f8605b6361fa/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eed8e37019cecd79d95b81ecfb6f8605b6361fa/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=2eed8e37019cecd79d95b81ecfb6f8605b6361fa", "patch": "@@ -832,7 +832,10 @@ merge_types (tree t1, tree t2)\n \n \trval = build_function_type (valtype, parms);\n \tgcc_assert (type_memfn_quals (t1) == type_memfn_quals (t2));\n-\trval = apply_memfn_quals (rval, type_memfn_quals (t1));\n+\tgcc_assert (type_memfn_rqual (t1) == type_memfn_rqual (t2));\n+\trval = apply_memfn_quals (rval,\n+\t\t\t\t  type_memfn_quals (t1),\n+\t\t\t\t  type_memfn_rqual (t1));\n \traises = merge_exception_specifiers (TYPE_RAISES_EXCEPTIONS (t1),\n \t\t\t\t\t     TYPE_RAISES_EXCEPTIONS (t2),\n \t\t\t\t\t     NULL_TREE);\n@@ -1184,6 +1187,12 @@ structural_comptypes (tree t1, tree t2, int strict)\n   if (TREE_CODE (t1) == FUNCTION_TYPE\n       && type_memfn_quals (t1) != type_memfn_quals (t2))\n     return false;\n+  /* Need to check this before TYPE_MAIN_VARIANT.\n+     FIXME function qualifiers should really change the main variant.  */\n+  if ((TREE_CODE (t1) == FUNCTION_TYPE\n+       || TREE_CODE (t1) == METHOD_TYPE)\n+      && type_memfn_rqual (t1) != type_memfn_rqual (t2))\n+    return false;\n   if (TYPE_FOR_JAVA (t1) != TYPE_FOR_JAVA (t2))\n     return false;\n \n@@ -8563,6 +8572,22 @@ cp_type_quals (const_tree type)\n   return quals;\n }\n \n+/* Returns the function-ref-qualifier for TYPE */\n+\n+cp_ref_qualifier\n+type_memfn_rqual (const_tree type)\n+{\n+  gcc_assert (TREE_CODE (type) == FUNCTION_TYPE\n+              || TREE_CODE (type) == METHOD_TYPE);\n+\n+  if (!FUNCTION_REF_QUALIFIED (type))\n+    return REF_QUAL_NONE;\n+  else if (FUNCTION_RVALUE_QUALIFIED (type))\n+    return REF_QUAL_RVALUE;\n+  else\n+    return REF_QUAL_LVALUE;\n+}\n+\n /* Returns the function-cv-quals for TYPE, which must be a FUNCTION_TYPE or\n    METHOD_TYPE.  */\n \n@@ -8578,18 +8603,22 @@ type_memfn_quals (const_tree type)\n }\n \n /* Returns the FUNCTION_TYPE TYPE with its function-cv-quals changed to\n-   MEMFN_QUALS.  */\n+   MEMFN_QUALS and its ref-qualifier to RQUAL. */\n \n tree\n-apply_memfn_quals (tree type, cp_cv_quals memfn_quals)\n+apply_memfn_quals (tree type, cp_cv_quals memfn_quals, cp_ref_qualifier rqual)\n {\n   /* Could handle METHOD_TYPE here if necessary.  */\n   gcc_assert (TREE_CODE (type) == FUNCTION_TYPE);\n-  if (TYPE_QUALS (type) == memfn_quals)\n+  if (TYPE_QUALS (type) == memfn_quals\n+      && type_memfn_rqual (type) == rqual)\n     return type;\n+\n   /* This should really have a different TYPE_MAIN_VARIANT, but that gets\n      complex.  */\n-  return build_qualified_type (type, memfn_quals);\n+  tree result = build_qualified_type (type, memfn_quals);\n+  result = build_exception_variant (result, TYPE_RAISES_EXCEPTIONS (type));\n+  return build_ref_qualified_type (result, rqual);\n }\n \n /* Returns nonzero if TYPE is const or volatile.  */"}, {"sha": "d9efafb851512976faf235d389c648f5c56e4a29", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eed8e37019cecd79d95b81ecfb6f8605b6361fa/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eed8e37019cecd79d95b81ecfb6f8605b6361fa/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=2eed8e37019cecd79d95b81ecfb6f8605b6361fa", "patch": "@@ -1708,7 +1708,24 @@ build_m_component_ref (tree datum, tree component, tsubst_flags_t complain)\n       return datum;\n     }\n   else\n-    return build2 (OFFSET_REF, type, datum, component);\n+    {\n+      /* 5.5/6: In a .* expression whose object expression is an rvalue, the\n+\t program is ill-formed if the second operand is a pointer to member\n+\t function with ref-qualifier &. In a .* expression whose object\n+\t expression is an lvalue, the program is ill-formed if the second\n+\t operand is a pointer to member function with ref-qualifier &&.  */\n+      if (FUNCTION_REF_QUALIFIED (type))\n+\t{\n+\t  bool lval = real_lvalue_p (datum);\n+\t  if (lval && FUNCTION_RVALUE_QUALIFIED (type))\n+\t    error (\"pointer-to-member-function type %qT requires an rvalue\",\n+\t\t   ptrmem_type);\n+\t  else if (!lval && !FUNCTION_RVALUE_QUALIFIED (type))\n+\t    error (\"pointer-to-member-function type %qT requires an lvalue\",\n+\t\t   ptrmem_type);\n+\t}\n+      return build2 (OFFSET_REF, type, datum, component);\n+    }\n }\n \n /* Return a tree node for the expression TYPENAME '(' PARMS ')'.  */"}, {"sha": "7fa826c3db43dc8fe942aaf2a494ae527b4c3a7f", "filename": "gcc/testsuite/g++.dg/cpp0x/ref-qual1.C", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eed8e37019cecd79d95b81ecfb6f8605b6361fa/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fref-qual1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eed8e37019cecd79d95b81ecfb6f8605b6361fa/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fref-qual1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fref-qual1.C?ref=2eed8e37019cecd79d95b81ecfb6f8605b6361fa", "patch": "@@ -0,0 +1,30 @@\n+// { dg-require-effective-target c++11 }\n+\n+template <class,class> struct ST;\n+template <class T> struct ST<T,T> {};\n+\n+struct A\n+{\n+  int f() &;\n+  char f() &&;\n+};\n+\n+template <class T> struct B\n+{\n+  int f() &;\n+  char f() &&;\n+};\n+\n+int main()\n+{\n+  A a;\n+  a.f();\n+  A().f();\n+  ST<decltype(a.f()), int>();\n+  ST<decltype(A().f()), char>();\n+  B<int> b;\n+  b.f();\n+  B<int>().f();\n+  ST<decltype(b.f()), int>();\n+  ST<decltype(B<int>().f()), char>();\n+}"}, {"sha": "fa09ab48a15bc8f874498e2f9a1246b20bf67b09", "filename": "gcc/testsuite/g++.dg/cpp0x/ref-qual2.C", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eed8e37019cecd79d95b81ecfb6f8605b6361fa/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fref-qual2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eed8e37019cecd79d95b81ecfb6f8605b6361fa/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fref-qual2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fref-qual2.C?ref=2eed8e37019cecd79d95b81ecfb6f8605b6361fa", "patch": "@@ -0,0 +1,75 @@\n+// In a .* expression whose object expression is an rvalue, the program is\n+// ill-formed if the second operand is a pointer to member function with\n+// ref-qualifier &. In a .* expression whose object expression is an\n+// lvalue, the program is ill-formed if the second operand is a pointer to\n+// member function with ref-qualifier &&.\n+\n+// { dg-require-effective-target c++11 }\n+\n+struct A {\n+  void f() &;\n+  void g() &&;\n+  void h();\n+};\n+\n+void one()\n+{\n+  A a;\n+\n+  void (A::*p)() & = &A::f;\n+  (a.*p)();\n+  (A().*p)();\t\t\t// { dg-error \"\" }\n+\n+  p = &A::g;\t\t\t// { dg-error \"\" }\n+  p = &A::h;\t\t\t// { dg-error \"\" }\n+\n+  void (A::*p2)() && = &A::g;\n+  (A().*p2)();\n+  (a.*p2)();\t\t\t// { dg-error \"\" }\n+  p2 = &A::f;\t\t\t// { dg-error \"\" }\n+  p2 = &A::h;\t\t\t// { dg-error \"\" }\n+\n+  void (A::*p3)() = &A::h;\n+  (a.*p3)();\n+  (A().*p3)();\n+  p3 = &A::f;\t\t\t// { dg-error \"\" }\n+  p3 = &A::g;\t\t\t// { dg-error \"\" }\n+}\n+\n+template <class T>\n+struct B {\n+  void f() &;\n+  void g() &&;\n+  void h();\n+};\n+\n+template <class T>\n+void two()\n+{\n+  B<T> a;\n+\n+  void (B<T>::*p)() & = &B<T>::f;\n+  (a.*p)();\n+  (B<T>().*p)();\t\t// { dg-error \"\" }\n+\n+  p = &B<T>::g;\t\t\t// { dg-error \"\" }\n+  p = &B<T>::h;\t\t\t// { dg-error \"\" }\n+\n+  void (B<T>::*p2)() && = &B<T>::g;\n+  (B<T>().*p2)();\n+  (a.*p2)();\t\t\t// { dg-error \"\" }\n+  p2 = &B<T>::f;\t\t// { dg-error \"\" }\n+  p2 = &B<T>::h;\t\t// { dg-error \"\" }\n+\n+  void (B<T>::*p3)() = &B<T>::h;\n+  (a.*p3)();\n+  (B<T>().*p3)();\n+  p3 = &B<T>::f;\t\t// { dg-error \"\" }\n+  p3 = &B<T>::g;\t\t// { dg-error \"\" }\n+}\n+\n+int main()\n+{\n+  one();\n+  two<int>();\n+}"}, {"sha": "1b21196321aed8d86a1826c9b763559f9f6395b9", "filename": "gcc/testsuite/g++.dg/cpp0x/ref-qual3.C", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eed8e37019cecd79d95b81ecfb6f8605b6361fa/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fref-qual3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eed8e37019cecd79d95b81ecfb6f8605b6361fa/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fref-qual3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fref-qual3.C?ref=2eed8e37019cecd79d95b81ecfb6f8605b6361fa", "patch": "@@ -0,0 +1,29 @@\n+// An explicitly defaulted function can have a ref-qualifier.\n+\n+// { dg-require-effective-target c++11 }\n+\n+struct A {\n+  A& operator=(const A&) & = default;\n+};\n+\n+template<class T>\n+struct B {\n+  B& operator=(const B&) & = default;\n+};\n+\n+template<class T>\n+void f()\n+{\n+  B<T> b;\n+  b = B<T>();\n+  B<T>() = b;\t\t\t// { dg-error \"\" }\n+}\n+\n+int main()\n+{\n+  A a;\n+  a = A();\n+  A() = a;\t\t\t// { dg-error \"\" }\n+\n+  f<int>();\n+}"}, {"sha": "5a0ee162fe5750f2d7f48c3d3e03a40f8ab05bd1", "filename": "gcc/testsuite/g++.dg/cpp0x/ref-qual4.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eed8e37019cecd79d95b81ecfb6f8605b6361fa/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fref-qual4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eed8e37019cecd79d95b81ecfb6f8605b6361fa/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fref-qual4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fref-qual4.C?ref=2eed8e37019cecd79d95b81ecfb6f8605b6361fa", "patch": "@@ -0,0 +1,14 @@\n+// 12.1: A constructor shall not be declared with a ref-qualifier.\n+// 12.4: A destructor shall not be declared with a ref-qualifier.\n+\n+// { dg-require-effective-target c++11 }\n+\n+struct A {\n+  A() & = default;\t\t// { dg-error \"constructor\" }\n+  ~A() & = default;\t\t// { dg-error \"destructor\" }\n+};\n+\n+int main()\n+{\n+  A a;\n+}"}, {"sha": "e3d26e5a78faa825e39d0246ca6abbfc97426995", "filename": "gcc/testsuite/g++.dg/cpp0x/ref-qual5.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eed8e37019cecd79d95b81ecfb6f8605b6361fa/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fref-qual5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eed8e37019cecd79d95b81ecfb6f8605b6361fa/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fref-qual5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fref-qual5.C?ref=2eed8e37019cecd79d95b81ecfb6f8605b6361fa", "patch": "@@ -0,0 +1,13 @@\n+// 13.1: ...cannot be overloaded if any of them, but not all, have a\n+// ref-qualifier.\n+\n+// { dg-require-effective-target c++11 }\n+\n+class Y {\n+  void h() &;\n+  void h() const &;\t       // OK\n+  void h() &&;\t\t       // OK, all declarations have a ref-qualifier\n+  void i() &;\t\t       // { dg-message \"\" }\n+  void i() const;\t       // { dg-error \"\" } prior declaration of i\n+\t\t\t       // has a ref-qualifier\n+};"}, {"sha": "02e3f6e683eb1f87faa68e7dcde75129638f0796", "filename": "gcc/testsuite/g++.dg/cpp0x/ref-qual6.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eed8e37019cecd79d95b81ecfb6f8605b6361fa/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fref-qual6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eed8e37019cecd79d95b81ecfb6f8605b6361fa/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fref-qual6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fref-qual6.C?ref=2eed8e37019cecd79d95b81ecfb6f8605b6361fa", "patch": "@@ -0,0 +1,15 @@\n+// Binding an rvalue to && beats binding it to const& (13.3.3.2).\n+\n+// { dg-require-effective-target c++11 }\n+\n+struct A\n+{\n+  int operator+(int) &&;\n+};\n+\n+void operator+ (const A&, int);\n+\n+int main()\n+{\n+  return A() + 42;\n+}"}, {"sha": "2430665db345355d90e551d0ea8015c3b7d2e6b3", "filename": "gcc/testsuite/g++.dg/cpp0x/ref-qual7.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eed8e37019cecd79d95b81ecfb6f8605b6361fa/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fref-qual7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eed8e37019cecd79d95b81ecfb6f8605b6361fa/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fref-qual7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fref-qual7.C?ref=2eed8e37019cecd79d95b81ecfb6f8605b6361fa", "patch": "@@ -0,0 +1,19 @@\n+// typedef test\n+// { dg-require-effective-target c++11 }\n+\n+typedef void F() &;\n+\n+F f;\t\t\t\t// { dg-error \"\" }\n+F* p;\t\t\t\t// { dg-error \"\" }\n+extern F& r;\t\t\t// { dg-error \"\" }\n+\n+struct A {\n+  F f;\n+};\n+\n+int main()\n+{\n+  A a;\n+  a.f();\n+  A().f();\t\t\t// { dg-error \"\" }\n+}"}, {"sha": "b4c972b3c3be1d1e52050ae846bac0baa85eb0c9", "filename": "gcc/testsuite/g++.dg/cpp0x/ref-qual8.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eed8e37019cecd79d95b81ecfb6f8605b6361fa/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fref-qual8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eed8e37019cecd79d95b81ecfb6f8605b6361fa/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fref-qual8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fref-qual8.C?ref=2eed8e37019cecd79d95b81ecfb6f8605b6361fa", "patch": "@@ -0,0 +1,13 @@\n+// { dg-require-effective-target c++11 }\n+\n+struct A\n+{\n+  virtual void f() & = 0;\n+};\n+\n+struct B: A\n+{\n+  void f();\t\t\t// doesn't override\n+};\n+\n+B b;\t\t\t\t// { dg-error \"abstract\" }"}]}