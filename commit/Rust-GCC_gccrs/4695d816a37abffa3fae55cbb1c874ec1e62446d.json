{"sha": "4695d816a37abffa3fae55cbb1c874ec1e62446d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDY5NWQ4MTZhMzdhYmZmYTNmYWU1NWNiYjFjODc0ZWMxZTYyNDQ2ZA==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2017-10-31T11:59:14Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2017-10-31T11:59:14Z"}, "message": "GCOV: Vector refactoring II\n\n2017-10-31  Martin Liska  <mliska@suse.cz>\n\n\t* gcov.c (struct line_info): Remove it's typedef.\n\t(line_info::line_info): Add proper ctor.\n\t(line_info::has_block): Do not use a typedef.\n\t(struct source_info): Do not use typedef.\n\t(circuit): Likewise.\n\t(get_cycles_count): Likewise.\n\t(output_intermediate_file): Iterate via vector iterator.\n\t(add_line_counts): Use std::vector methods.\n\t(accumulate_line_counts): Likewise.\n\t(output_lines): Likewise.\n\nFrom-SVN: r254261", "tree": {"sha": "7b913dbe24fde2ebfa561fb05122974f0fea7b6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7b913dbe24fde2ebfa561fb05122974f0fea7b6e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4695d816a37abffa3fae55cbb1c874ec1e62446d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4695d816a37abffa3fae55cbb1c874ec1e62446d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4695d816a37abffa3fae55cbb1c874ec1e62446d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4695d816a37abffa3fae55cbb1c874ec1e62446d/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c7432e76039d2c4fb7a00f0fbd261eec2238d42b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7432e76039d2c4fb7a00f0fbd261eec2238d42b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7432e76039d2c4fb7a00f0fbd261eec2238d42b"}], "stats": {"total": 162, "additions": 86, "deletions": 76}, "files": [{"sha": "0f6ed83a5f02dab4191e4c0cc5b7b326ab18049c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4695d816a37abffa3fae55cbb1c874ec1e62446d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4695d816a37abffa3fae55cbb1c874ec1e62446d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4695d816a37abffa3fae55cbb1c874ec1e62446d", "patch": "@@ -1,3 +1,16 @@\n+2017-10-31  Martin Liska  <mliska@suse.cz>\n+\n+\t* gcov.c (struct line_info): Remove it's typedef.\n+\t(line_info::line_info): Add proper ctor.\n+\t(line_info::has_block): Do not use a typedef.\n+\t(struct source_info): Do not use typedef.\n+\t(circuit): Likewise.\n+\t(get_cycles_count): Likewise.\n+\t(output_intermediate_file): Iterate via vector iterator.\n+\t(add_line_counts): Use std::vector methods.\n+\t(accumulate_line_counts): Likewise.\n+\t(output_lines): Likewise.\n+\n 2017-10-31  Martin Liska  <mliska@suse.cz>\n \n \t* gcov.c (struct source_info): Remove typedef."}, {"sha": "2916214cb7e448ddaa5be5792a36833fe4a310fd", "filename": "gcc/gcov.c", "status": "modified", "additions": 73, "deletions": 76, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4695d816a37abffa3fae55cbb1c874ec1e62446d/gcc%2Fgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4695d816a37abffa3fae55cbb1c874ec1e62446d/gcc%2Fgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov.c?ref=4695d816a37abffa3fae55cbb1c874ec1e62446d", "patch": "@@ -108,9 +108,6 @@ typedef struct arc_info\n   /* Loop making arc.  */\n   unsigned int cycle : 1;\n \n-  /* Next branch on line.  */\n-  struct arc_info *line_next;\n-\n   /* Links to next arc on src and dst lists.  */\n   struct arc_info *succ_next;\n   struct arc_info *pred_next;\n@@ -245,28 +242,37 @@ typedef struct coverage_info\n /* Describes a single line of source. Contains a chain of basic blocks\n    with code on it.  */\n \n-typedef struct line_info\n+struct line_info\n {\n+  /* Default constructor.  */\n+  line_info ();\n+\n   /* Return true when NEEDLE is one of basic blocks the line belongs to.  */\n   bool has_block (block_t *needle);\n \n-  gcov_type count;\t   /* execution count */\n-  arc_t *branches;\t   /* branches from blocks that end on this line.  */\n-  block_t *blocks;\t   /* blocks which start on this line.\n-\t\t\t      Used in all-blocks mode.  */\n+  /* Execution count.  */\n+  gcov_type count;\n+\n+  /* Branches from blocks that end on this line.  */\n+  vector<arc_t *> branches;\n+\n+  /* blocks which start on this line.  Used in all-blocks mode.  */\n+  vector<block_t *> blocks;\n+\n   unsigned exists : 1;\n   unsigned unexceptional : 1;\n   unsigned has_unexecuted_block : 1;\n-} line_t;\n+};\n \n-bool\n-line_t::has_block (block_t *needle)\n+line_info::line_info (): count (0), branches (), blocks (), exists (false),\n+  unexceptional (0), has_unexecuted_block (0)\n {\n-  for (block_t *n = blocks; n; n = n->chain)\n-    if (n == needle)\n-      return true;\n+}\n \n-  return false;\n+bool\n+line_info::has_block (block_t *needle)\n+{\n+  return std::find (blocks.begin (), blocks.end (), needle) != blocks.end ();\n }\n \n /* Describes a file mentioned in the block graph.  Contains an array\n@@ -282,7 +288,7 @@ struct source_info\n   time_t file_time;\n \n   /* Vector of line information.  */\n-  vector<line_t> lines;\n+  vector<line_info> lines;\n \n   coverage_t coverage;\n \n@@ -569,7 +575,7 @@ unblock (const block_t *u, block_vector_t &blocked,\n static loop_type\n circuit (block_t *v, arc_vector_t &path, block_t *start,\n \t block_vector_t &blocked, vector<block_vector_t> &block_lists,\n-\t line_t &linfo, int64_t &count)\n+\t line_info &linfo, int64_t &count)\n {\n   loop_type result = NO_LOOP;\n \n@@ -618,7 +624,7 @@ circuit (block_t *v, arc_vector_t &path, block_t *start,\n    contains a negative loop, then perform the same function once again.  */\n \n static gcov_type\n-get_cycles_count (line_t &linfo, bool handle_negative_cycles = true)\n+get_cycles_count (line_info &linfo, bool handle_negative_cycles = true)\n {\n   /* Note that this algorithm works even if blocks aren't in sorted order.\n      Each iteration of the circuit detection is completely independent\n@@ -628,12 +634,13 @@ get_cycles_count (line_t &linfo, bool handle_negative_cycles = true)\n \n   loop_type result = NO_LOOP;\n   gcov_type count = 0;\n-  for (block_t *block = linfo.blocks; block; block = block->chain)\n+  for (vector<block_t *>::iterator it = linfo.blocks.begin ();\n+       it != linfo.blocks.end (); it++)\n     {\n       arc_vector_t path;\n       block_vector_t blocked;\n       vector<block_vector_t > block_lists;\n-      result |= circuit (block, path, block, blocked, block_lists, linfo,\n+      result |= circuit (*it, path, *it, blocked, block_lists, linfo,\n \t\t\t count);\n     }\n \n@@ -866,7 +873,7 @@ static void\n output_intermediate_file (FILE *gcov_file, source_info *src)\n {\n   unsigned line_num;    /* current line number.  */\n-  const line_t *line;   /* current line info ptr.  */\n+  const line_info *line;   /* current line info ptr.  */\n   function_t *fn;       /* current function info ptr. */\n \n   fprintf (gcov_file, \"file:%s\\n\", src->name);    /* source file name */\n@@ -883,29 +890,29 @@ output_intermediate_file (FILE *gcov_file, source_info *src)\n        line_num < src->lines.size ();\n        line_num++, line++)\n     {\n-      arc_t *arc;\n       if (line->exists)\n \tfprintf (gcov_file, \"lcount:%u,%s,%d\\n\", line_num,\n \t\t format_gcov (line->count, 0, -1), line->has_unexecuted_block);\n       if (flag_branches)\n-\tfor (arc = line->branches; arc; arc = arc->line_next)\n-          {\n-            if (!arc->is_unconditional && !arc->is_call_non_return)\n-              {\n-                const char *branch_type;\n-                /* branch:<line_num>,<branch_coverage_type>\n-                   branch_coverage_type\n-                     : notexec (Branch not executed)\n-                     : taken (Branch executed and taken)\n-                     : nottaken (Branch executed, but not taken)\n-                */\n-                if (arc->src->count)\n-                  branch_type = (arc->count > 0) ? \"taken\" : \"nottaken\";\n-                else\n-                  branch_type = \"notexec\";\n-                fprintf (gcov_file, \"branch:%d,%s\\n\", line_num, branch_type);\n-              }\n-          }\n+\tfor (vector<arc_t *>::const_iterator it = line->branches.begin ();\n+\t     it != line->branches.end (); it++)\n+\t  {\n+\t    if (!(*it)->is_unconditional && !(*it)->is_call_non_return)\n+\t      {\n+\t\tconst char *branch_type;\n+\t\t/* branch:<line_num>,<branch_coverage_type>\n+\t\t   branch_coverage_type\n+\t\t     : notexec (Branch not executed)\n+\t\t     : taken (Branch executed and taken)\n+\t\t     : nottaken (Branch executed, but not taken)\n+\t\t*/\n+\t\tif ((*it)->src->count)\n+\t\t  branch_type = ((*it)->count > 0) ? \"taken\" : \"nottaken\";\n+\t\telse\n+\t\t  branch_type = \"notexec\";\n+\t\tfprintf (gcov_file, \"branch:%d,%s\\n\", line_num, branch_type);\n+\t      }\n+\t  }\n     }\n }\n \n@@ -2234,7 +2241,7 @@ add_line_counts (coverage_t *coverage, function_t *fn)\n   /* Scan each basic block.  */\n   for (unsigned ix = 0; ix != fn->blocks.size (); ix++)\n     {\n-      line_t *line = NULL;\n+      line_info *line = NULL;\n       block_t *block = &fn->blocks[ix];\n       if (block->count && ix && ix + 1 != fn->blocks.size ())\n \tfn->blocks_executed++;\n@@ -2271,17 +2278,15 @@ add_line_counts (coverage_t *coverage, function_t *fn)\n \t/* Entry or exit block */;\n       else if (line != NULL)\n \t{\n-\t  block->chain = line->blocks;\n-\t  line->blocks = block;\n+\t  line->blocks.push_back (block);\n \n \t  if (flag_branches)\n \t    {\n \t      arc_t *arc;\n \n \t      for (arc = block->succ; arc; arc = arc->succ_next)\n \t\t{\n-\t\t  arc->line_next = line->branches;\n-\t\t  line->branches = arc;\n+\t\t  line->branches.push_back (arc);\n \t\t  if (coverage && !arc->is_unconditional)\n \t\t    add_branch_counts (coverage, arc);\n \t\t}\n@@ -2309,48 +2314,39 @@ accumulate_line_counts (source_info *src)\n     }\n   src->functions = fn_p;\n \n-  for (vector<line_t>::reverse_iterator it = src->lines.rbegin ();\n+  for (vector<line_info>::reverse_iterator it = src->lines.rbegin ();\n        it != src->lines.rend (); it++)\n     {\n-      line_t *line = &(*it);\n-      if (line->blocks)\n+      line_info *line = &(*it);\n+      if (!line->blocks.empty ())\n \t{\n \t  /* The user expects the line count to be the number of times\n \t     a line has been executed. Simply summing the block count\n \t     will give an artificially high number.  The Right Thing\n \t     is to sum the entry counts to the graph of blocks on this\n \t     line, then find the elementary cycles of the local graph\n \t     and add the transition counts of those cycles.  */\n-\t  block_t *block, *block_p, *block_n;\n \t  gcov_type count = 0;\n \n-\t  /* Reverse the block information.  */\n-\t  for (block = line->blocks, block_p = NULL; block;\n-\t       block_p = block, block = block_n)\n-\t    {\n-\t      block_n = block->chain;\n-\t      block->chain = block_p;\n-\t      block->cycle.ident = ix;\n-\t    }\n-\t  line->blocks = block_p;\n-\n \t  /* Sum the entry arcs.  */\n-\t  for (block = line->blocks; block; block = block->chain)\n+\t  for (vector<block_t *>::iterator it = line->blocks.begin ();\n+\t       it != line->blocks.end (); it++)\n \t    {\n \t      arc_t *arc;\n \n-\t      for (arc = block->pred; arc; arc = arc->pred_next)\n+\t      for (arc = (*it)->pred; arc; arc = arc->pred_next)\n \t\tif (flag_branches)\n \t\t  add_branch_counts (&src->coverage, arc);\n \t    }\n \n \t  /* Cycle detection.  */\n-\t  for (block = line->blocks; block; block = block->chain)\n+\t  for (vector<block_t *>::iterator it = line->blocks.begin ();\n+\t       it != line->blocks.end (); it++)\n \t    {\n-\t      for (arc_t *arc = block->pred; arc; arc = arc->pred_next)\n+\t      for (arc_t *arc = (*it)->pred; arc; arc = arc->pred_next)\n \t\tif (!line->has_block (arc->src))\n \t\t  count += arc->count;\n-\t      for (arc_t *arc = block->succ; arc; arc = arc->succ_next)\n+\t      for (arc_t *arc = (*it)->succ; arc; arc = arc->succ_next)\n \t\tarc->cs_count = arc->count;\n \t    }\n \n@@ -2534,7 +2530,7 @@ output_lines (FILE *gcov_file, const source_info *src)\n \n   FILE *source_file;\n   unsigned line_num;\t/* current line number.  */\n-  const line_t *line;           /* current line info ptr.  */\n+  const line_info *line;  /* current line info ptr.  */\n   const char *retval = \"\";\t/* status of source file reading.  */\n   function_t *fn = NULL;\n \n@@ -2601,36 +2597,37 @@ output_lines (FILE *gcov_file, const source_info *src)\n \n       if (flag_all_blocks)\n \t{\n-\t  block_t *block;\n \t  arc_t *arc;\n \t  int ix, jx;\n \n-\t  for (ix = jx = 0, block = line->blocks; block;\n-\t       block = block->chain)\n+\t  ix = jx = 0;\n+\t  for (vector<block_t *>::const_iterator it = line->blocks.begin ();\n+\t       it != line->blocks.end (); it++)\n \t    {\n-\t      if (!block->is_call_return)\n+\t      if (!(*it)->is_call_return)\n \t\t{\n \t\t  output_line_beginning (gcov_file, line->exists,\n-\t\t\t\t\t block->exceptional, false,\n-\t\t\t\t\t block->count, line_num,\n+\t\t\t\t\t (*it)->exceptional, false,\n+\t\t\t\t\t (*it)->count, line_num,\n \t\t\t\t\t \"%%%%%\", \"$$$$$\");\n \t\t  fprintf (gcov_file, \"-block %2d\", ix++);\n \t\t  if (flag_verbose)\n-\t\t    fprintf (gcov_file, \" (BB %u)\", block->id);\n+\t\t    fprintf (gcov_file, \" (BB %u)\", (*it)->id);\n \t\t  fprintf (gcov_file, \"\\n\");\n \t\t}\n \t      if (flag_branches)\n-\t\tfor (arc = block->succ; arc; arc = arc->succ_next)\n+\t\tfor (arc = (*it)->succ; arc; arc = arc->succ_next)\n \t\t  jx += output_branch_count (gcov_file, jx, arc);\n \t    }\n \t}\n       else if (flag_branches)\n \t{\n \t  int ix;\n-\t  arc_t *arc;\n \n-\t  for (ix = 0, arc = line->branches; arc; arc = arc->line_next)\n-\t    ix += output_branch_count (gcov_file, ix, arc);\n+\t  ix = 0;\n+\t  for (vector<arc_t *>::const_iterator it = line->branches.begin ();\n+\t       it != line->branches.end (); it++)\n+\t    ix += output_branch_count (gcov_file, ix, (*it));\n \t}\n     }\n "}]}