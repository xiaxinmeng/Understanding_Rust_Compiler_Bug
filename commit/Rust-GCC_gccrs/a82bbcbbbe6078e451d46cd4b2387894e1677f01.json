{"sha": "a82bbcbbbe6078e451d46cd4b2387894e1677f01", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTgyYmJjYmJiZTYwNzhlNDUxZDQ2Y2Q0YjIzODc4OTRlMTY3N2YwMQ==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2004-10-07T06:20:34Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2004-10-07T06:20:34Z"}, "message": "re PR rtl-optimization/17791 (doloop can produce wrong code causes Ada bootstrap failure)\n\n\tPR rtl-optimization/17791\n\t* loop-doloop.c (doloop_modify): Take number of iterations as\n\targument.\n\t(doloop_optimize): Extend or shorten the number of iterations\n\twhen changing mode of counter register.\n\t* loop-iv.c (lowpart_subreg): Export.\n\t* rtl.h (lowpart_subreg): Declare.\n\nFrom-SVN: r88668", "tree": {"sha": "efc9e42c4cc8b306c06213b3eb2b7863c35140d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/efc9e42c4cc8b306c06213b3eb2b7863c35140d8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a82bbcbbbe6078e451d46cd4b2387894e1677f01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a82bbcbbbe6078e451d46cd4b2387894e1677f01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a82bbcbbbe6078e451d46cd4b2387894e1677f01", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a82bbcbbbe6078e451d46cd4b2387894e1677f01/comments", "author": null, "committer": null, "parents": [{"sha": "1313b31fbb9a19ded4de32ae8c8b5fdf5747cc15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1313b31fbb9a19ded4de32ae8c8b5fdf5747cc15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1313b31fbb9a19ded4de32ae8c8b5fdf5747cc15"}], "stats": {"total": 63, "additions": 53, "deletions": 10}, "files": [{"sha": "3b8acfbec674a92457489d1aa8f7df879402c493", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a82bbcbbbe6078e451d46cd4b2387894e1677f01/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a82bbcbbbe6078e451d46cd4b2387894e1677f01/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a82bbcbbbe6078e451d46cd4b2387894e1677f01", "patch": "@@ -1,3 +1,13 @@\n+2004-10-07  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\tPR rtl-optimization/17791\n+\t* loop-doloop.c (doloop_modify): Take number of iterations as\n+\targument.\n+\t(doloop_optimize): Extend or shorten the number of iterations\n+\twhen changing mode of counter register.\n+\t* loop-iv.c (lowpart_subreg): Export.\n+\t* rtl.h (lowpart_subreg): Declare.\n+\n 2004-10-07  Zdenek Dvorak  <dvorakz@suse.cz>\n \n \tPR tree-optimization/17806"}, {"sha": "1e56eb5cebe3c501e16ee046a0c9c6790b942eeb", "filename": "gcc/loop-doloop.c", "status": "modified", "additions": 38, "deletions": 9, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a82bbcbbbe6078e451d46cd4b2387894e1677f01/gcc%2Floop-doloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a82bbcbbbe6078e451d46cd4b2387894e1677f01/gcc%2Floop-doloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-doloop.c?ref=a82bbcbbbe6078e451d46cd4b2387894e1677f01", "patch": "@@ -257,20 +257,21 @@ add_test (rtx cond, basic_block bb, basic_block dest)\n    describes the loop, DESC describes the number of iterations of the\n    loop, and DOLOOP_INSN is the low-overhead looping insn to emit at the\n    end of the loop.  CONDITION is the condition separated from the\n-   DOLOOP_SEQ.  */\n+   DOLOOP_SEQ.  COUNT is the number of iterations of the LOOP.  */\n \n static void\n doloop_modify (struct loop *loop, struct niter_desc *desc,\n-\t       rtx doloop_seq, rtx condition)\n+\t       rtx doloop_seq, rtx condition, rtx count)\n {\n   rtx counter_reg;\n-  rtx count, tmp, noloop = NULL_RTX;\n+  rtx tmp, noloop = NULL_RTX;\n   rtx sequence;\n   rtx jump_insn;\n   rtx jump_label;\n   int nonneg = 0, irr;\n   bool increment_count;\n   basic_block loop_end = desc->out_edge->src;\n+  enum machine_mode mode;\n \n   jump_insn = BB_END (loop_end);\n \n@@ -291,8 +292,8 @@ doloop_modify (struct loop *loop, struct niter_desc *desc,\n   counter_reg = XEXP (condition, 0);\n   if (GET_CODE (counter_reg) == PLUS)\n     counter_reg = XEXP (counter_reg, 0);\n+  mode = GET_MODE (counter_reg);\n \n-  count = copy_rtx (desc->niter_expr);\n   increment_count = false;\n   switch (GET_CODE (condition))\n     {\n@@ -323,7 +324,7 @@ doloop_modify (struct loop *loop, struct niter_desc *desc,\n \t Note that the maximum value loaded is iterations_max - 1.  */\n       if (desc->niter_max\n \t  <= ((unsigned HOST_WIDEST_INT) 1\n-\t      << (GET_MODE_BITSIZE (GET_MODE (counter_reg)) - 1)))\n+\t      << (GET_MODE_BITSIZE (mode) - 1)))\n \tnonneg = 1;\n       break;\n \n@@ -333,7 +334,7 @@ doloop_modify (struct loop *loop, struct niter_desc *desc,\n     }\n \n   if (increment_count)\n-    count = simplify_gen_binary (PLUS, desc->mode, count, const1_rtx);\n+    count = simplify_gen_binary (PLUS, mode, count, const1_rtx);\n \n   /* Insert initialization of the count register into the loop header.  */\n   start_sequence ();\n@@ -438,12 +439,14 @@ doloop_optimize (struct loop *loop)\n {\n   enum machine_mode mode;\n   rtx doloop_seq, doloop_pat, doloop_reg;\n-  rtx iterations;\n+  rtx iterations, count;\n   rtx iterations_max;\n   rtx start_label;\n   rtx condition;\n   unsigned level, est_niter;\n   struct niter_desc *desc;\n+  unsigned word_mode_size;\n+  unsigned HOST_WIDE_INT word_mode_max;\n \n   if (dump_file)\n     fprintf (dump_file, \"Doloop: Processing loop %d.\\n\", loop->num);\n@@ -481,6 +484,7 @@ doloop_optimize (struct loop *loop)\n       return false;\n     }\n \n+  count = copy_rtx (desc->niter_expr);\n   iterations = desc->const_iter ? desc->niter_expr : const0_rtx;\n   iterations_max = GEN_INT (desc->niter_max);\n   level = get_loop_level (loop) + 1;\n@@ -492,8 +496,33 @@ doloop_optimize (struct loop *loop)\n   doloop_reg = gen_reg_rtx (mode);\n   doloop_seq = gen_doloop_end (doloop_reg, iterations, iterations_max,\n \t\t\t       GEN_INT (level), start_label);\n-  if (! doloop_seq && mode != word_mode)\n+\n+  word_mode_size = GET_MODE_BITSIZE (word_mode);\n+  word_mode_max\n+\t  = ((unsigned HOST_WIDE_INT) 1 << (word_mode_size - 1) << 1) - 1;\n+  if (! doloop_seq\n+      && mode != word_mode\n+      /* Before trying mode different from the one in that # of iterations is\n+\t computed, we must be sure that the number of iterations fits into\n+\t the new mode.  */\n+      && (word_mode_size >= GET_MODE_BITSIZE (mode)\n+\t  || desc->niter_max <= word_mode_max))\n     {\n+      if (word_mode_size > GET_MODE_BITSIZE (mode))\n+\t{\n+\t  count = simplify_gen_unary (ZERO_EXTEND, word_mode,\n+\t\t\t\t      iterations, mode);\n+\t  iterations = simplify_gen_unary (ZERO_EXTEND, word_mode,\n+\t\t\t\t\t   iterations, mode);\n+\t  iterations_max = simplify_gen_unary (ZERO_EXTEND, word_mode,\n+\t\t\t\t\t       iterations_max, mode);\n+\t}\n+      else\n+\t{\n+\t  count = lowpart_subreg (word_mode, count, mode);\n+\t  iterations = lowpart_subreg (word_mode, iterations, mode);\n+\t  iterations_max = lowpart_subreg (word_mode, iterations_max, mode);\n+\t}\n       PUT_MODE (doloop_reg, word_mode);\n       doloop_seq = gen_doloop_end (doloop_reg, iterations, iterations_max,\n \t\t\t\t   GEN_INT (level), start_label);\n@@ -528,7 +557,7 @@ doloop_optimize (struct loop *loop)\n       return false;\n     }\n \n-  doloop_modify (loop, desc, doloop_seq, condition);\n+  doloop_modify (loop, desc, doloop_seq, condition, count);\n   return true;\n }\n "}, {"sha": "7105aaddcbc3c228e06cdf251fbb7153a42eb856", "filename": "gcc/loop-iv.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a82bbcbbbe6078e451d46cd4b2387894e1677f01/gcc%2Floop-iv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a82bbcbbbe6078e451d46cd4b2387894e1677f01/gcc%2Floop-iv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-iv.c?ref=a82bbcbbbe6078e451d46cd4b2387894e1677f01", "patch": "@@ -156,7 +156,7 @@ assign_luids (basic_block bb)\n /* Generates a subreg to get the least significant part of EXPR (in mode\n    INNER_MODE) to OUTER_MODE.  */\n \n-static rtx\n+rtx\n lowpart_subreg (enum machine_mode outer_mode, rtx expr,\n \t\tenum machine_mode inner_mode)\n {"}, {"sha": "e0f86ee1c3df7ce991863f8ce4cb2fe76b2c9c52", "filename": "gcc/rtl.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a82bbcbbbe6078e451d46cd4b2387894e1677f01/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a82bbcbbbe6078e451d46cd4b2387894e1677f01/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=a82bbcbbbe6078e451d46cd4b2387894e1677f01", "patch": "@@ -1432,6 +1432,10 @@ extern void push_to_full_sequence (rtx, rtx);\n extern rtx immed_double_const (HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t       enum machine_mode);\n \n+/* In loop-iv.c  */\n+\n+extern rtx lowpart_subreg (enum machine_mode, rtx, enum machine_mode);\n+\n /* In varasm.c  */\n extern rtx force_const_mem (enum machine_mode, rtx);\n "}]}