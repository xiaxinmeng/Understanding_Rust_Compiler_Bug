{"sha": "e45f84a5f9cf7e31ae46c6c557f6896d0b1db5c2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTQ1Zjg0YTVmOWNmN2UzMWFlNDZjNmM1NTdmNjg5NmQwYjFkYjVjMg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2017-09-05T08:40:09Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2017-09-05T08:40:09Z"}, "message": "repinfo.ads: Document new treatment of dynamic values.\n\n\t* repinfo.ads: Document new treatment of dynamic values.\n\t(TCode): Bump upper bound to 29.\n\t(Dynamic_Val): New constant set to 29.\n\t* repinfo.adb (Print_Expr) <Dynamic_Val>: New case.\n\t(Rep_Value)  <Dynamic_Val>: Likewise.\n\t* repinfo.h (Dynamic_Val): New macro.\n\t* gcc-interface/decl.c (annotate_value): Tidy up and cache result for\n\tDECL_P nodes too.\n\t<INTEGER_CST>: Set TCODE instead of recursing.\n\t<COMPONENT_REF>: Set TCODE instead of calling Create_Node manually.\n\t<VAR_DECL>: New case.\n\t<MULT_EXPR, PLUS_EXPR>: Fold conversions into inner operations.\n\t<BIT_AND_EXPR>: Adjust.\n\t<CALL_EXPR>: Do not fall through.\n\nFrom-SVN: r251698", "tree": {"sha": "4fe408e93fafc4c7823b8629dd06e278306d24d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4fe408e93fafc4c7823b8629dd06e278306d24d7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e45f84a5f9cf7e31ae46c6c557f6896d0b1db5c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e45f84a5f9cf7e31ae46c6c557f6896d0b1db5c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e45f84a5f9cf7e31ae46c6c557f6896d0b1db5c2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e45f84a5f9cf7e31ae46c6c557f6896d0b1db5c2/comments", "author": null, "committer": null, "parents": [{"sha": "6a9db54cc1e778e99998591920471a1e2eb5d7e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a9db54cc1e778e99998591920471a1e2eb5d7e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a9db54cc1e778e99998591920471a1e2eb5d7e1"}], "stats": {"total": 169, "additions": 114, "deletions": 55}, "files": [{"sha": "40cc96557aa1a4c57f1384c407e1dc0b8ecf332a", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e45f84a5f9cf7e31ae46c6c557f6896d0b1db5c2/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e45f84a5f9cf7e31ae46c6c557f6896d0b1db5c2/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=e45f84a5f9cf7e31ae46c6c557f6896d0b1db5c2", "patch": "@@ -1,3 +1,20 @@\n+2017-09-05  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* repinfo.ads: Document new treatment of dynamic values.\n+\t(TCode): Bump upper bound to 29.\n+\t(Dynamic_Val): New constant set to 29.\n+\t* repinfo.adb (Print_Expr) <Dynamic_Val>: New case.\n+\t(Rep_Value)  <Dynamic_Val>: Likewise.\n+\t* repinfo.h (Dynamic_Val): New macro.\n+\t* gcc-interface/decl.c (annotate_value): Tidy up and cache result for\n+\tDECL_P nodes too.\n+\t<INTEGER_CST>: Set TCODE instead of recursing.\n+\t<COMPONENT_REF>: Set TCODE instead of calling Create_Node manually.\n+\t<VAR_DECL>: New case.\n+\t<MULT_EXPR, PLUS_EXPR>: Fold conversions into inner operations.\n+\t<BIT_AND_EXPR>: Adjust.\n+\t<CALL_EXPR>: Do not fall through.\n+\n 2017-09-05  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/trans.c (Call_to_gnu): If this is a function call and"}, {"sha": "0a1796a6614b17e309ab2fe9c12ae85e99f305a3", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 65, "deletions": 38, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e45f84a5f9cf7e31ae46c6c557f6896d0b1db5c2/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e45f84a5f9cf7e31ae46c6c557f6896d0b1db5c2/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=e45f84a5f9cf7e31ae46c6c557f6896d0b1db5c2", "patch": "@@ -8047,13 +8047,13 @@ components_to_record (Node_Id gnat_component_list, Entity_Id gnat_record_type,\n static Uint\n annotate_value (tree gnu_size)\n {\n+  static int var_count = 0;\n   TCode tcode;\n-  Node_Ref_Or_Val ops[3], ret, pre_op1 = No_Uint;\n+  Node_Ref_Or_Val ops[3] = { No_Uint, No_Uint, No_Uint };\n   struct tree_int_map in;\n-  int i;\n \n   /* See if we've already saved the value for this node.  */\n-  if (EXPR_P (gnu_size))\n+  if (EXPR_P (gnu_size) || DECL_P (gnu_size))\n     {\n       struct tree_int_map *e;\n \n@@ -8067,9 +8067,7 @@ annotate_value (tree gnu_size)\n     in.base.from = NULL_TREE;\n \n   /* If we do not return inside this switch, TCODE will be set to the\n-     code to use for a Create_Node operand and LEN (set above) will be\n-     the number of recursive calls for us to make.  */\n-\n+     code to be used in a call to Create_Node.  */\n   switch (TREE_CODE (gnu_size))\n     {\n     case INTEGER_CST:\n@@ -8078,38 +8076,51 @@ annotate_value (tree gnu_size)\n       if (tree_int_cst_sgn (gnu_size) < 0)\n \t{\n \t  tree t = wide_int_to_tree (sizetype, wi::neg (gnu_size));\n-\t  return annotate_value (build1 (NEGATE_EXPR, sizetype, t));\n+\t  tcode = Negate_Expr;\n+\t  ops[0] = UI_From_gnu (t);\n \t}\n-\n-      return TREE_OVERFLOW (gnu_size) ? No_Uint : UI_From_gnu (gnu_size);\n+      else\n+\treturn TREE_OVERFLOW (gnu_size) ? No_Uint : UI_From_gnu (gnu_size);\n+      break;\n \n     case COMPONENT_REF:\n       /* The only case we handle here is a simple discriminant reference.  */\n       if (DECL_DISCRIMINANT_NUMBER (TREE_OPERAND (gnu_size, 1)))\n \t{\n-\t  tree n = DECL_DISCRIMINANT_NUMBER (TREE_OPERAND (gnu_size, 1));\n+\t  tree ref = gnu_size;\n+\t  gnu_size = TREE_OPERAND (ref, 1);\n \n \t  /* Climb up the chain of successive extensions, if any.  */\n-\t  while (TREE_CODE (TREE_OPERAND (gnu_size, 0)) == COMPONENT_REF\n-\t\t && DECL_NAME (TREE_OPERAND (TREE_OPERAND (gnu_size, 0), 1))\n+\t  while (TREE_CODE (TREE_OPERAND (ref, 0)) == COMPONENT_REF\n+\t\t && DECL_NAME (TREE_OPERAND (TREE_OPERAND (ref, 0), 1))\n \t\t    == parent_name_id)\n-\t    gnu_size = TREE_OPERAND (gnu_size, 0);\n+\t    ref = TREE_OPERAND (ref, 0);\n \n-\t  if (TREE_CODE (TREE_OPERAND (gnu_size, 0)) == PLACEHOLDER_EXPR)\n-\t    return\n-\t      Create_Node (Discrim_Val, annotate_value (n), No_Uint, No_Uint);\n+\t  if (TREE_CODE (TREE_OPERAND (ref, 0)) == PLACEHOLDER_EXPR)\n+\t    {\n+\t      /* Fall through to common processing as a FIELD_DECL.  */\n+\t      tcode = Discrim_Val;\n+\t      ops[0] = UI_From_gnu (DECL_DISCRIMINANT_NUMBER (gnu_size));\n+\t    }\n+\t  else\n+\t    return No_Uint;\n \t}\n+      else\n+\treturn No_Uint;\n+      break;\n \n-      return No_Uint;\n+    case VAR_DECL:\n+      tcode = Dynamic_Val;\n+      ops[0] = UI_From_Int (++var_count);\n+      break;\n \n-    CASE_CONVERT:   case NON_LVALUE_EXPR:\n+    CASE_CONVERT:\n+    case NON_LVALUE_EXPR:\n       return annotate_value (TREE_OPERAND (gnu_size, 0));\n \n       /* Now just list the operations we handle.  */\n     case COND_EXPR:\t\ttcode = Cond_Expr; break;\n-    case PLUS_EXPR:\t\ttcode = Plus_Expr; break;\n     case MINUS_EXPR:\t\ttcode = Minus_Expr; break;\n-    case MULT_EXPR:\t\ttcode = Mult_Expr; break;\n     case TRUNC_DIV_EXPR:\ttcode = Trunc_Div_Expr; break;\n     case CEIL_DIV_EXPR:\t\ttcode = Ceil_Div_Expr; break;\n     case FLOOR_DIV_EXPR:\ttcode = Floor_Div_Expr; break;\n@@ -8134,6 +8145,30 @@ annotate_value (tree gnu_size)\n     case EQ_EXPR:\t\ttcode = Eq_Expr; break;\n     case NE_EXPR:\t\ttcode = Ne_Expr; break;\n \n+    case MULT_EXPR:\n+    case PLUS_EXPR:\n+      tcode = (TREE_CODE (gnu_size) == MULT_EXPR ? Mult_Expr : Plus_Expr);\n+      /* Fold conversions from bytes to bits into inner operations.  */\n+      if (TREE_CODE (TREE_OPERAND (gnu_size, 1)) == INTEGER_CST\n+\t  && CONVERT_EXPR_P (TREE_OPERAND (gnu_size, 0)))\n+\t{\n+\t  tree inner_op = TREE_OPERAND (TREE_OPERAND (gnu_size, 0), 0);\n+\t  if (TREE_CODE (inner_op) == TREE_CODE (gnu_size)\n+\t      && TREE_CODE (TREE_OPERAND (inner_op, 1)) == INTEGER_CST)\n+\t    {\n+\t      tree inner_op_op1 = TREE_OPERAND (inner_op, 1);\n+\t      tree gnu_size_op1 = TREE_OPERAND (gnu_size, 1);\n+\t      wide_int op1;\n+\t      if (TREE_CODE (gnu_size) == MULT_EXPR)\n+\t\top1 = wi::mul (inner_op_op1, gnu_size_op1);\n+\t      else\n+\t\top1 = wi::add (inner_op_op1, gnu_size_op1);\n+\t      ops[1] = UI_From_gnu (wide_int_to_tree (sizetype, op1));\n+\t      ops[0] = annotate_value (TREE_OPERAND (inner_op, 0));\n+\t    }\n+\t}\n+      break;\n+\n     case BIT_AND_EXPR:\n       tcode = Bit_And_Expr;\n       /* For negative values in sizetype, build NEGATE_EXPR of the opposite.\n@@ -8146,7 +8181,7 @@ annotate_value (tree gnu_size)\n \t  if (wi::neg_p (signed_op1))\n \t    {\n \t      op1 = wide_int_to_tree (sizetype, wi::neg (signed_op1));\n-\t      pre_op1 = annotate_value (build1 (NEGATE_EXPR, sizetype, op1));\n+\t      ops[1] = annotate_value (build1 (NEGATE_EXPR, sizetype, op1));\n \t    }\n \t}\n       break;\n@@ -8158,34 +8193,26 @@ annotate_value (tree gnu_size)\n       if (List_Representation_Info == 3 || type_annotate_only)\n \t{\n \t  tree t = maybe_inline_call_in_expr (gnu_size);\n-\t  if (t)\n-\t    return annotate_value (t);\n+\t  return t ? annotate_value (t) : No_Uint;\n \t}\n       else\n \treturn Uint_Minus_1;\n \n-      /* Fall through... */\n-\n     default:\n       return No_Uint;\n     }\n \n   /* Now get each of the operands that's relevant for this code.  If any\n      cannot be expressed as a repinfo node, say we can't.  */\n-  for (i = 0; i < 3; i++)\n-    ops[i] = No_Uint;\n-\n-  for (i = 0; i < TREE_CODE_LENGTH (TREE_CODE (gnu_size)); i++)\n-    {\n-      if (i == 1 && pre_op1 != No_Uint)\n-\tops[i] = pre_op1;\n-      else\n+  for (int i = 0; i < TREE_CODE_LENGTH (TREE_CODE (gnu_size)); i++)\n+    if (ops[i] == No_Uint)\n+      {\n \tops[i] = annotate_value (TREE_OPERAND (gnu_size, i));\n-      if (ops[i] == No_Uint)\n-\treturn No_Uint;\n-    }\n+\tif (ops[i] == No_Uint)\n+\t  return No_Uint;\n+      }\n \n-  ret = Create_Node (tcode, ops[0], ops[1], ops[2]);\n+  Node_Ref_Or_Val ret = Create_Node (tcode, ops[0], ops[1], ops[2]);\n \n   /* Save the result in the cache.  */\n   if (in.base.from)\n@@ -8198,7 +8225,7 @@ annotate_value (tree gnu_size)\n       h = annotate_value_cache->find_slot (&in, INSERT);\n       gcc_assert (!*h);\n       *h = ggc_alloc<tree_int_map> ();\n-      (*h)->base.from = gnu_size;\n+      (*h)->base.from = in.base.from;\n       (*h)->to = ret;\n     }\n "}, {"sha": "dbc5920566d4c7766ecd0cae6742aa2e2b348bab", "filename": "gcc/ada/repinfo.adb", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e45f84a5f9cf7e31ae46c6c557f6896d0b1db5c2/gcc%2Fada%2Frepinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e45f84a5f9cf7e31ae46c6c557f6896d0b1db5c2/gcc%2Fada%2Frepinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frepinfo.adb?ref=e45f84a5f9cf7e31ae46c6c557f6896d0b1db5c2", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1999-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1999-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -59,11 +59,11 @@ package body Repinfo is\n    --  value is assumed to be 8 for the implementation of the DDA.\n \n    ---------------------------------------\n-   -- Representation of gcc Expressions --\n+   -- Representation of GCC Expressions --\n    ---------------------------------------\n \n    --    This table is used only if Frontend_Layout_On_Target is False, so gigi\n-   --    lays out dynamic size/offset fields using encoded gcc expressions.\n+   --    lays out dynamic size/offset fields using encoded GCC expressions.\n \n    --    A table internal to this unit is used to hold the values of back\n    --    annotated expressions. This table is written out by -gnatt and read\n@@ -643,6 +643,10 @@ package body Repinfo is\n                   when Discrim_Val =>\n                      Write_Char ('#');\n                      UI_Write (Node.Op1);\n+\n+                  when Dynamic_Val =>\n+                     Write_Str (\"Var\");\n+                     UI_Write (Node.Op1);\n                end case;\n             end;\n          end if;\n@@ -1448,6 +1452,9 @@ package body Repinfo is\n                         pragma Assert (Sub in D'Range);\n                         return D (Sub);\n                      end;\n+\n+                  when Dynamic_Val =>\n+                     return No_Uint;\n                end case;\n             end;\n          end if;"}, {"sha": "3dc48a013822734f06ff854ff43cccdd5991c308", "filename": "gcc/ada/repinfo.ads", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e45f84a5f9cf7e31ae46c6c557f6896d0b1db5c2/gcc%2Fada%2Frepinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e45f84a5f9cf7e31ae46c6c557f6896d0b1db5c2/gcc%2Fada%2Frepinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frepinfo.ads?ref=e45f84a5f9cf7e31ae46c6c557f6896d0b1db5c2", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1999-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1999-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -83,7 +83,7 @@ package Repinfo is\n    --    For E_Array_Type entities, the Component_Size field\n \n    --    For all record and array types and subtypes, the Esize field,\n-   --    which contains the Size (more accurately the Object_SIze) value\n+   --    which contains the Size (more accurately the Object_Size) value\n    --    for the type or subtype.\n \n    --    For E_Component and E_Discriminant entities, the Esize (size\n@@ -96,19 +96,19 @@ package Repinfo is\n    --       by simply storing the non-negative universal integer value in\n    --       the appropriate field corresponding to this constant size.\n \n-   --    2. The value depends on variables other than discriminants of the\n-   --       current record. In this case, the value is not known, even if\n-   --       the complete data of the record is available, and gigi marks\n-   --       this situation by storing the special value No_Uint.\n-\n-   --    3. The value depends on the discriminant values for the current\n+   --    2. The value depends on the discriminant values for the current\n    --       record. In this case, gigi back annotates the field with a\n    --       representation of the expression for computing the value in\n    --       terms of the discriminants. A negative Uint value is used to\n    --       represent the value of such an expression, as explained in\n    --       the following section.\n \n-   --  Note: the extended back-annotation for the dynamic case is needed only\n+   --    3. The value depends on variables other than discriminants of the\n+   --       current record. In this case, gigi also back annotates the field\n+   --       with a representation of the expression for computing the value\n+   --       in terms of the variables represented symbolically.\n+\n+   --  Note: the extended back annotation for the dynamic case is needed only\n    --  for -gnatR3 output, and for proper operation of the ASIS DDA. Since it\n    --  can be expensive to do this back annotation (for discriminated records\n    --  with many variable length arrays), we only do the full back annotation\n@@ -136,7 +136,7 @@ package Repinfo is\n    --  Subtype used for values that can either be a Node_Ref (negative)\n    --  or a value (non-negative)\n \n-   type TCode is range 0 .. 28;\n+   type TCode is range 0 .. 29;\n    --  Type used on Ada side to represent DEFTREECODE values defined in\n    --  tree.def. Only a subset of these tree codes can actually appear.\n    --  The names are the names from tree.def in Ada casing.\n@@ -174,10 +174,17 @@ package Repinfo is\n \n    --  The following entry is used to represent a discriminant value in\n    --  the tree. It has a special tree code that does not correspond\n-   --  directly to a gcc node. The single operand is the number of the\n-   --  discriminant in the record (1 = first discriminant).\n+   --  directly to a GCC node. The single operand is the index number\n+   --  of the discriminant in the record (1 = first discriminant).\n+\n+   Discrim_Val      : constant TCode :=  0;  -- discriminant value      1\n+\n+   --  The following entry is used to represent a value not known at\n+   --  compile time in the tree, other than a discriminant value. It\n+   --  has a special tree code that does not correspond directly to\n+   --  a GCC node. The single operand is an arbitrary index number.\n \n-   Discrim_Val : constant TCode := 0;  -- discriminant value       1\n+   Dynamic_Val      : constant TCode := 29;  -- dynamic value           1\n \n    ------------------------\n    -- The gigi Interface --"}, {"sha": "7f1fdf6fd860315fe2d9d18e65540a8a208b28c1", "filename": "gcc/ada/repinfo.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e45f84a5f9cf7e31ae46c6c557f6896d0b1db5c2/gcc%2Fada%2Frepinfo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e45f84a5f9cf7e31ae46c6c557f6896d0b1db5c2/gcc%2Fada%2Frepinfo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frepinfo.h?ref=e45f84a5f9cf7e31ae46c6c557f6896d0b1db5c2", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                              C Header File                               *\n  *                                                                          *\n- *          Copyright (C) 1999-2011, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1999-2017, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -71,6 +71,7 @@ typedef char TCode;\n #define Eq_Expr          26\n #define Ne_Expr          27\n #define Bit_And_Expr     28\n+#define Dynamic_Val      29\n \n /* Creates a node using the tree code defined by Expr and from 1-3\n    operands as required (unused operands set as shown to No_Uint) Note"}]}