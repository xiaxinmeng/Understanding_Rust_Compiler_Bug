{"sha": "8c6e3b2355b0cd245b0a4f802044d8fd885ea03e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGM2ZTNiMjM1NWIwY2QyNDViMGE0ZjgwMjA0NGQ4ZmQ4ODVlYTAzZQ==", "commit": {"author": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2018-10-01T13:00:58Z"}, "committer": {"name": "Tamar Christina", "email": "tnfchris@gcc.gnu.org", "date": "2018-10-01T13:00:58Z"}, "message": "Ensure that outgoing argument size is at least 8 bytes when alloca and stack-clash.\n\nThis patch adds a requirement that the number of outgoing arguments for a\nfunction is at least 8 bytes when using stack-clash protection and alloca.\n\nBy using this condition we can avoid a check in the alloca code and so have\nsmaller and simpler code there.\n\nA simplified version of the AArch64 stack frames is:\n\n   +-----------------------+                                              \n   |                       |                                                 \n   |                       |                                              \n   |                       |                                              \n   +-----------------------+                                              \n   |LR                     |                                              \n   +-----------------------+                                              \n   |FP                     |                                              \n   +-----------------------+                                              \n   |dynamic allocations    | ----  expanding area which will push the outgoing\n   +-----------------------+       args down during each allocation.\n   |padding                |\n   +-----------------------+\n   |outgoing stack args    | ---- safety buffer of 8 bytes (aligned)\n   +-----------------------+\n\nBy always defining an outgoing argument, alloca(0) effectively is safe to probe\nat $sp due to the reserved buffer being there.  It will never corrupt the stack.\n\nThis is also safe for alloca(x) where x is 0 or x % page_size == 0.  In the\nformer it is the same case as alloca(0) while the latter is safe because any\nallocation pushes the outgoing stack args down:\n\n   |FP                     |                                              \n   +-----------------------+                                              \n   |                       |\n   |dynamic allocations    | ----  alloca (x)\n   |                       |\n   +-----------------------+\n   |padding                |\n   +-----------------------+\n   |outgoing stack args    | ---- safety buffer of 8 bytes (aligned)\n   +-----------------------+\n\nWhich means when you probe for the residual, if it's 0 you'll again just probe\nin the outgoing stack args range, which we know is non-zero (at least 8 bytes).\n\ngcc/\n\n\tPR target/86486\n\t* config/aarch64/aarch64.h (STACK_CLASH_MIN_BYTES_OUTGOING_ARGS,\n\tSTACK_DYNAMIC_OFFSET): New.\n\t* config/aarch64/aarch64.c (aarch64_layout_frame):\n\tUpdate outgoing args size.\n\t(aarch64_stack_clash_protection_alloca_probe_range,\n\tTARGET_STACK_CLASH_PROTECTION_ALLOCA_PROBE_RANGE): New.\n\ngcc/testsuite/\n\n\tPR target/86486\n\t* gcc.target/aarch64/stack-check-alloca-1.c: New.\n\t* gcc.target/aarch64/stack-check-alloca-10.c: New.\n\t* gcc.target/aarch64/stack-check-alloca-2.c: New.\n\t* gcc.target/aarch64/stack-check-alloca-3.c: New.\n\t* gcc.target/aarch64/stack-check-alloca-4.c: New.\n\t* gcc.target/aarch64/stack-check-alloca-5.c: New.\n\t* gcc.target/aarch64/stack-check-alloca-6.c: New.\n\t* gcc.target/aarch64/stack-check-alloca-7.c: New.\n\t* gcc.target/aarch64/stack-check-alloca-8.c: New.\n\t* gcc.target/aarch64/stack-check-alloca-9.c: New.\n\t* gcc.target/aarch64/stack-check-alloca.h: New.\n\t* gcc.target/aarch64/stack-check-14.c: New.\n\t* gcc.target/aarch64/stack-check-15.c: New.\n\nFrom-SVN: r264751", "tree": {"sha": "46610e0ec89a849ce9e2145563dcea5383c311a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/46610e0ec89a849ce9e2145563dcea5383c311a3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8c6e3b2355b0cd245b0a4f802044d8fd885ea03e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c6e3b2355b0cd245b0a4f802044d8fd885ea03e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c6e3b2355b0cd245b0a4f802044d8fd885ea03e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c6e3b2355b0cd245b0a4f802044d8fd885ea03e/comments", "author": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2c25083e75fa265fd6cdd749a264951dc002d90b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c25083e75fa265fd6cdd749a264951dc002d90b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c25083e75fa265fd6cdd749a264951dc002d90b"}], "stats": {"total": 235, "additions": 235, "deletions": 0}, "files": [{"sha": "a379cc4777a43f097b24caca891135d8a013c5b2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c6e3b2355b0cd245b0a4f802044d8fd885ea03e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c6e3b2355b0cd245b0a4f802044d8fd885ea03e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8c6e3b2355b0cd245b0a4f802044d8fd885ea03e", "patch": "@@ -1,3 +1,13 @@\n+2018-10-01  Tamar Christina  <tamar.christina@arm.com>\n+\n+\tPR target/86486\n+\t* config/aarch64/aarch64.h (STACK_CLASH_MIN_BYTES_OUTGOING_ARGS,\n+\tSTACK_DYNAMIC_OFFSET): New.\n+\t* config/aarch64/aarch64.c (aarch64_layout_frame):\n+\tUpdate outgoing args size.\n+\t(aarch64_stack_clash_protection_alloca_probe_range,\n+\tTARGET_STACK_CLASH_PROTECTION_ALLOCA_PROBE_RANGE): New.\n+\n 2018-10-01  Tamar Christina  <tamar.christina@arm.com>\n \n \tPR target/86486"}, {"sha": "23524072064b78a1b7b3625f05a81af59da6dc5d", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c6e3b2355b0cd245b0a4f802044d8fd885ea03e/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c6e3b2355b0cd245b0a4f802044d8fd885ea03e/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=8c6e3b2355b0cd245b0a4f802044d8fd885ea03e", "patch": "@@ -4129,6 +4129,10 @@ aarch64_layout_frame (void)\n \n   cfun->machine->frame.emit_frame_chain = aarch64_needs_frame_chain ();\n \n+  /* Adjust the outgoing arguments size if required.  Keep it in sync with what\n+     the mid-end is doing.  */\n+  crtl->outgoing_args_size = STACK_DYNAMIC_OFFSET (cfun);\n+\n #define SLOT_NOT_REQUIRED (-2)\n #define SLOT_REQUIRED     (-1)\n \n@@ -4899,6 +4903,16 @@ aarch64_set_handled_components (sbitmap components)\n       cfun->machine->reg_is_wrapped_separately[regno] = true;\n }\n \n+/* On AArch64 we have an ABI defined safe buffer.  This constant is used to\n+   determining the probe offset for alloca.  */\n+\n+static HOST_WIDE_INT\n+aarch64_stack_clash_protection_alloca_probe_range (void)\n+{\n+  return STACK_CLASH_CALLER_GUARD;\n+}\n+\n+\n /* Allocate POLY_SIZE bytes of stack space using TEMP1 and TEMP2 as scratch\n    registers.  If POLY_SIZE is not large enough to require a probe this function\n    will only adjust the stack.  When allocating the stack space\n@@ -18413,6 +18427,10 @@ aarch64_libgcc_floating_mode_supported_p\n #undef TARGET_CONSTANT_ALIGNMENT\n #define TARGET_CONSTANT_ALIGNMENT aarch64_constant_alignment\n \n+#undef TARGET_STACK_CLASH_PROTECTION_ALLOCA_PROBE_RANGE\n+#define TARGET_STACK_CLASH_PROTECTION_ALLOCA_PROBE_RANGE \\\n+  aarch64_stack_clash_protection_alloca_probe_range\n+\n #undef TARGET_COMPUTE_PRESSURE_CLASSES\n #define TARGET_COMPUTE_PRESSURE_CLASSES aarch64_compute_pressure_classes\n "}, {"sha": "fa9af26fd40fd23b1c9cd6da9b6300fd77089103", "filename": "gcc/config/aarch64/aarch64.h", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c6e3b2355b0cd245b0a4f802044d8fd885ea03e/gcc%2Fconfig%2Faarch64%2Faarch64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c6e3b2355b0cd245b0a4f802044d8fd885ea03e/gcc%2Fconfig%2Faarch64%2Faarch64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.h?ref=8c6e3b2355b0cd245b0a4f802044d8fd885ea03e", "patch": "@@ -88,6 +88,10 @@\n    before probing has to be done for stack clash protection.  */\n #define STACK_CLASH_CALLER_GUARD 1024\n \n+/* This value represents the minimum amount of bytes we expect the function's\n+   outgoing arguments to be when stack-clash is enabled.  */\n+#define STACK_CLASH_MIN_BYTES_OUTGOING_ARGS 8\n+\n /* This value controls how many pages we manually unroll the loop for when\n    generating stack clash probes.  */\n #define STACK_CLASH_MAX_UNROLL_PAGES 4\n@@ -1076,4 +1080,17 @@ extern poly_uint16 aarch64_sve_vg;\n \n #define REGMODE_NATURAL_SIZE(MODE) aarch64_regmode_natural_size (MODE)\n \n+/* Allocate a minimum of STACK_CLASH_MIN_BYTES_OUTGOING_ARGS bytes for the\n+   outgoing arguments if stack clash protection is enabled.  This is essential\n+   as the extra arg space allows us to skip a check in alloca.  */\n+#undef STACK_DYNAMIC_OFFSET\n+#define STACK_DYNAMIC_OFFSET(FUNDECL)\t\t\t   \\\n+   ((flag_stack_clash_protection\t\t\t   \\\n+     && cfun->calls_alloca\t\t\t\t   \\\n+     && known_lt (crtl->outgoing_args_size,\t\t   \\\n+\t\t  STACK_CLASH_MIN_BYTES_OUTGOING_ARGS))    \\\n+    ? ROUND_UP (STACK_CLASH_MIN_BYTES_OUTGOING_ARGS,       \\\n+\t\tSTACK_BOUNDARY / BITS_PER_UNIT)\t\t   \\\n+    : (crtl->outgoing_args_size + STACK_POINTER_OFFSET))\n+\n #endif /* GCC_AARCH64_H */"}, {"sha": "0252a1dfac97b1cd8a9148cf04d62ce5c8e14712", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c6e3b2355b0cd245b0a4f802044d8fd885ea03e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c6e3b2355b0cd245b0a4f802044d8fd885ea03e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8c6e3b2355b0cd245b0a4f802044d8fd885ea03e", "patch": "@@ -1,3 +1,20 @@\n+2018-10-01  Tamar Christina  <tamar.christina@arm.com>\n+\n+\tPR target/86486\n+\t* gcc.target/aarch64/stack-check-alloca-1.c: New.\n+\t* gcc.target/aarch64/stack-check-alloca-10.c: New.\n+\t* gcc.target/aarch64/stack-check-alloca-2.c: New.\n+\t* gcc.target/aarch64/stack-check-alloca-3.c: New.\n+\t* gcc.target/aarch64/stack-check-alloca-4.c: New.\n+\t* gcc.target/aarch64/stack-check-alloca-5.c: New.\n+\t* gcc.target/aarch64/stack-check-alloca-6.c: New.\n+\t* gcc.target/aarch64/stack-check-alloca-7.c: New.\n+\t* gcc.target/aarch64/stack-check-alloca-8.c: New.\n+\t* gcc.target/aarch64/stack-check-alloca-9.c: New.\n+\t* gcc.target/aarch64/stack-check-alloca.h: New.\n+\t* gcc.target/aarch64/stack-check-14.c: New.\n+\t* gcc.target/aarch64/stack-check-15.c: New.\n+\n 2018-10-01  Tamar Christina  <tamar.christina@arm.com>\n \n \tPR target/86486"}, {"sha": "a573d108a0ce0243e038411aa01eb65dfd81a460", "filename": "gcc/testsuite/gcc.target/aarch64/stack-check-14.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c6e3b2355b0cd245b0a4f802044d8fd885ea03e/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c6e3b2355b0cd245b0a4f802044d8fd885ea03e/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-14.c?ref=8c6e3b2355b0cd245b0a4f802044d8fd885ea03e", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fstack-clash-protection --param stack-clash-protection-guard-size=16\" } */\n+/* { dg-require-effective-target supports_stack_clash_protection } */\n+\n+int t1(int);\n+\n+int t2(int x)\n+{\n+  char *p = __builtin_alloca (4050);\n+  x = t1 (x);\n+  return p[x];\n+}\n+\n+\n+/* This test has a constant sized alloca that is smaller than the\n+   probe interval.  Only one probe is required since the value is larger\n+   than 1024 bytes but smaller than 63k.\n+\n+   The form can change quite a bit so we just check for two\n+   probes without looking at the actual address.  */\n+/* { dg-final { scan-assembler-times \"str\\\\txzr,\" 1 } } */\n+\n+\n+"}, {"sha": "497d83e6596a3cbfce898ca6cda1a65d5fe76d0b", "filename": "gcc/testsuite/gcc.target/aarch64/stack-check-15.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c6e3b2355b0cd245b0a4f802044d8fd885ea03e/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c6e3b2355b0cd245b0a4f802044d8fd885ea03e/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-15.c?ref=8c6e3b2355b0cd245b0a4f802044d8fd885ea03e", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fstack-clash-protection --param stack-clash-protection-guard-size=16\" } */\n+/* { dg-require-effective-target supports_stack_clash_protection } */\n+\n+int t1(int);\n+\n+int t2(int x)\n+{\n+  char *p = __builtin_alloca (x);\n+  x = t1 (x);\n+  return p[x];\n+}\n+\n+\n+/* This test has a variable sized alloca.  It requires 3 probes.\n+   One in the loop, one for the residual, one for when it's < 1024 and one for\n+   when it's not.\n+\n+   The form can change quite a bit so we just check for two\n+   probes without looking at the actual address.  */\n+/* { dg-final { scan-assembler-times \"str\\\\txzr,\" 3 } } */"}, {"sha": "7fc189f6210d97fe87af489f11c94a7a98c9ac94", "filename": "gcc/testsuite/gcc.target/aarch64/stack-check-alloca-1.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c6e3b2355b0cd245b0a4f802044d8fd885ea03e/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-alloca-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c6e3b2355b0cd245b0a4f802044d8fd885ea03e/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-alloca-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-alloca-1.c?ref=8c6e3b2355b0cd245b0a4f802044d8fd885ea03e", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fstack-clash-protection --param stack-clash-protection-guard-size=16\" } */\n+/* { dg-require-effective-target supports_stack_clash_protection } */\n+\n+#define SIZE y\n+#include \"stack-check-alloca.h\"\n+\n+/* { dg-final { scan-assembler-times {str\\s+xzr, \\[sp, 1024\\]} 2 } } */\n+/* { dg-final { scan-assembler-times {str\\s+xzr, \\[sp\\]} 1 } } */\n+\n+/* Dynamic alloca, expect loop, and 2 probes with 1kB offset and 1 at sp.\n+   1st probe is inside the loop for the full guard-size allocations, second\n+   probe is for the case where residual is zero and the final probe for when\n+   residiual is > 1024 bytes.  */"}, {"sha": "7c42206d3158d624815a5cc13b2e619c4a432dda", "filename": "gcc/testsuite/gcc.target/aarch64/stack-check-alloca-10.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c6e3b2355b0cd245b0a4f802044d8fd885ea03e/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-alloca-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c6e3b2355b0cd245b0a4f802044d8fd885ea03e/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-alloca-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-alloca-10.c?ref=8c6e3b2355b0cd245b0a4f802044d8fd885ea03e", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fstack-clash-protection --param stack-clash-protection-guard-size=16\" } */\n+/* { dg-require-effective-target supports_stack_clash_protection } */\n+\n+#define SIZE 127.5 * 64 * 1024\n+#include \"stack-check-alloca.h\"\n+\n+/* { dg-final { scan-assembler-times {str\\s+xzr, \\[sp, 1024\\]} 2 } } */\n+\n+/* Large alloca of an amount which isn't a multiple of a guard-size, and\n+   residiual is more than 1kB.  Loop expected with one 1Kb probe offset and\n+   one residual probe at offset 1kB.  */"}, {"sha": "69fdd16e35a296276acaf76bb0e0954ffba5a421", "filename": "gcc/testsuite/gcc.target/aarch64/stack-check-alloca-2.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c6e3b2355b0cd245b0a4f802044d8fd885ea03e/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-alloca-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c6e3b2355b0cd245b0a4f802044d8fd885ea03e/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-alloca-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-alloca-2.c?ref=8c6e3b2355b0cd245b0a4f802044d8fd885ea03e", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fstack-clash-protection --param stack-clash-protection-guard-size=16\" } */\n+/* { dg-require-effective-target supports_stack_clash_protection } */\n+\n+#define SIZE 0\n+#include \"stack-check-alloca.h\"\n+\n+/* { dg-final { scan-assembler-not {str\\s+xzr,} } } */\n+\n+/* Alloca of 0 should emit no probes, boundary condition.  */"}, {"sha": "fba3a7a25b726558d4167f3d71c9490d1c89225d", "filename": "gcc/testsuite/gcc.target/aarch64/stack-check-alloca-3.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c6e3b2355b0cd245b0a4f802044d8fd885ea03e/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-alloca-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c6e3b2355b0cd245b0a4f802044d8fd885ea03e/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-alloca-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-alloca-3.c?ref=8c6e3b2355b0cd245b0a4f802044d8fd885ea03e", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fstack-clash-protection --param stack-clash-protection-guard-size=16\" } */\n+/* { dg-require-effective-target supports_stack_clash_protection } */\n+\n+#define SIZE 100\n+#include \"stack-check-alloca.h\"\n+\n+/* { dg-final { scan-assembler-times {str\\s+xzr, \\[sp, 8\\]} 1 } } */\n+\n+/* Alloca is less than 1kB, 1 probe expected at word offset.  */"}, {"sha": "d53f30a4133b7b2af74823d87ce88ff0d2116550", "filename": "gcc/testsuite/gcc.target/aarch64/stack-check-alloca-4.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c6e3b2355b0cd245b0a4f802044d8fd885ea03e/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-alloca-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c6e3b2355b0cd245b0a4f802044d8fd885ea03e/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-alloca-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-alloca-4.c?ref=8c6e3b2355b0cd245b0a4f802044d8fd885ea03e", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fstack-clash-protection --param stack-clash-protection-guard-size=16\" } */\n+/* { dg-require-effective-target supports_stack_clash_protection } */\n+\n+#define SIZE 2 * 1024\n+#include \"stack-check-alloca.h\"\n+\n+/* { dg-final { scan-assembler-times {str\\s+xzr, \\[sp, 1024\\]} 1 } } */\n+\n+/* Alloca is more than 1kB, but less than guard-size, 1 probe expected at\n+   1kB offset.  */"}, {"sha": "e0ff99ffbe1504d28aff314eeefdcac027321c5d", "filename": "gcc/testsuite/gcc.target/aarch64/stack-check-alloca-5.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c6e3b2355b0cd245b0a4f802044d8fd885ea03e/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-alloca-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c6e3b2355b0cd245b0a4f802044d8fd885ea03e/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-alloca-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-alloca-5.c?ref=8c6e3b2355b0cd245b0a4f802044d8fd885ea03e", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fstack-clash-protection --param stack-clash-protection-guard-size=16\" } */\n+/* { dg-require-effective-target supports_stack_clash_protection } */\n+\n+#define SIZE 63 * 1024\n+#include \"stack-check-alloca.h\"\n+\n+/* { dg-final { scan-assembler-times {str\\s+xzr, \\[sp, 1024\\]} 1 } } */\n+\n+/* Alloca is more than 1kB, but less than guard-size, 1 probe expected at\n+   1kB offset.  */"}, {"sha": "c4bad9a2f46b405a7f01a71733f4534c66515742", "filename": "gcc/testsuite/gcc.target/aarch64/stack-check-alloca-6.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c6e3b2355b0cd245b0a4f802044d8fd885ea03e/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-alloca-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c6e3b2355b0cd245b0a4f802044d8fd885ea03e/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-alloca-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-alloca-6.c?ref=8c6e3b2355b0cd245b0a4f802044d8fd885ea03e", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fstack-clash-protection --param stack-clash-protection-guard-size=16\" } */\n+/* { dg-require-effective-target supports_stack_clash_protection } */\n+\n+#define SIZE 63.5 * 1024\n+#include \"stack-check-alloca.h\"\n+\n+/* { dg-final { scan-assembler-times {str\\s+xzr, \\[sp, 1024\\]} 1 } } */\n+\n+/* Alloca is more than 1kB, but less than guard-size, 1 probe expected at 1kB\n+   offset.  */"}, {"sha": "cba9ff89c1a41da1f6b439239114b25351cab1d0", "filename": "gcc/testsuite/gcc.target/aarch64/stack-check-alloca-7.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c6e3b2355b0cd245b0a4f802044d8fd885ea03e/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-alloca-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c6e3b2355b0cd245b0a4f802044d8fd885ea03e/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-alloca-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-alloca-7.c?ref=8c6e3b2355b0cd245b0a4f802044d8fd885ea03e", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fstack-clash-protection --param stack-clash-protection-guard-size=16\" } */\n+/* { dg-require-effective-target supports_stack_clash_protection } */\n+\n+#define SIZE 64 * 1024\n+#include \"stack-check-alloca.h\"\n+\n+/* { dg-final { scan-assembler-times {str\\s+xzr, \\[sp, 1024\\]} 1 } } */\n+\n+/* Alloca is exactly one guard-size, 1 probe expected at 1kB offset.\n+   Boundary condition.  */"}, {"sha": "5a35411b34483231bd05859b963a031d0011ad2b", "filename": "gcc/testsuite/gcc.target/aarch64/stack-check-alloca-8.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c6e3b2355b0cd245b0a4f802044d8fd885ea03e/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-alloca-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c6e3b2355b0cd245b0a4f802044d8fd885ea03e/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-alloca-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-alloca-8.c?ref=8c6e3b2355b0cd245b0a4f802044d8fd885ea03e", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fstack-clash-protection --param stack-clash-protection-guard-size=16\" } */\n+/* { dg-require-effective-target supports_stack_clash_protection } */\n+\n+#define SIZE 65 * 1024\n+#include \"stack-check-alloca.h\"\n+\n+/* { dg-final { scan-assembler-times {str\\s+xzr, \\[sp, 1024\\]} 1 } } */\n+/* { dg-final { scan-assembler-times {str\\s+xzr, \\[sp, 8\\]} 1 } } */\n+\n+/* Alloca is more than one guard-page, and residual is exactly 1Kb. 2 probes\n+   expected.  One at 1kB offset for the guard-size allocation and one at word\n+   offset for the residual.  */"}, {"sha": "5773d8052bc2d89842ad591b12807056a0247ac5", "filename": "gcc/testsuite/gcc.target/aarch64/stack-check-alloca-9.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c6e3b2355b0cd245b0a4f802044d8fd885ea03e/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-alloca-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c6e3b2355b0cd245b0a4f802044d8fd885ea03e/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-alloca-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-alloca-9.c?ref=8c6e3b2355b0cd245b0a4f802044d8fd885ea03e", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fstack-clash-protection --param stack-clash-protection-guard-size=16\" } */\n+/* { dg-require-effective-target supports_stack_clash_protection } */\n+\n+#define SIZE 127 * 64 * 1024\n+#include \"stack-check-alloca.h\"\n+\n+/* { dg-final { scan-assembler-times {str\\s+xzr, \\[sp, 1024\\]} 1 } } */\n+\n+/* Large alloca of a constant amount which is a multiple of a guard-size,\n+   no residiual.  Loop expected with one 1Kb probe offset and no residual probe\n+   because residual is at compile time known to be zero.  */"}, {"sha": "a4f7fa2dd351cc7b76784103fc645a066c5ba6e3", "filename": "gcc/testsuite/gcc.target/aarch64/stack-check-alloca.h", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c6e3b2355b0cd245b0a4f802044d8fd885ea03e/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-alloca.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c6e3b2355b0cd245b0a4f802044d8fd885ea03e/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-alloca.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fstack-check-alloca.h?ref=8c6e3b2355b0cd245b0a4f802044d8fd885ea03e", "patch": "@@ -0,0 +1,13 @@\n+#include <alloca.h>\n+\n+__attribute__((noinline, noipa))\n+void g (char* ptr, int y)\n+{\n+  ptr[y] = '\\0';\n+}\n+\n+void f_caller (int y)\n+{\n+  char* pStr = alloca(SIZE);\n+  g (pStr, y);\n+}\n\\ No newline at end of file"}]}