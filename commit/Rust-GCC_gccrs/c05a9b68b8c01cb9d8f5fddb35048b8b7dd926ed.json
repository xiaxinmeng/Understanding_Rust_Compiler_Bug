{"sha": "c05a9b68b8c01cb9d8f5fddb35048b8b7dd926ed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzA1YTliNjhiOGMwMWNiOWQ4ZjVmZGRiMzUwNDhiOGI3ZGQ5MjZlZA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-04-01T23:59:21Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-04-01T23:59:21Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r664", "tree": {"sha": "46b2d7e845a94ec7a95fdb45e4c35bb80a1b03c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/46b2d7e845a94ec7a95fdb45e4c35bb80a1b03c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c05a9b68b8c01cb9d8f5fddb35048b8b7dd926ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c05a9b68b8c01cb9d8f5fddb35048b8b7dd926ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c05a9b68b8c01cb9d8f5fddb35048b8b7dd926ed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c05a9b68b8c01cb9d8f5fddb35048b8b7dd926ed/comments", "author": null, "committer": null, "parents": [{"sha": "dc2a006b4084e192f0479c1112d7d56cd0d5f2f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc2a006b4084e192f0479c1112d7d56cd0d5f2f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc2a006b4084e192f0479c1112d7d56cd0d5f2f5"}], "stats": {"total": 1019, "additions": 677, "deletions": 342}, "files": [{"sha": "3801fbf8db703227315b72125a6247f0d9bdab71", "filename": "gcc/fold-const.c", "status": "modified", "additions": 677, "deletions": 342, "changes": 1019, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c05a9b68b8c01cb9d8f5fddb35048b8b7dd926ed/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c05a9b68b8c01cb9d8f5fddb35048b8b7dd926ed/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=c05a9b68b8c01cb9d8f5fddb35048b8b7dd926ed", "patch": "@@ -778,18 +778,40 @@ target_isnan (x)\n     }\n }\n \n-/* Check for minus zero in an IEEE double precision number.  */\n+/* Check for a negative IEEE double precision number.  */\n \n int\n-target_minus_zero (x)\n+target_negative (x)\n      REAL_VALUE_TYPE x;\n {\n-  REAL_VALUE_TYPE d1, d2;\n-\n-  d1 = REAL_VALUE_NEGATE (x);\n-  d2 = dconst0;\n+  /* The IEEE 64-bit double format.  */\n+  union {\n+    REAL_VALUE_TYPE d;\n+    struct {\n+      unsigned sign      :  1;\n+      unsigned exponent  : 11;\n+      unsigned mantissa1 : 20;\n+      unsigned mantissa2;\n+    } little_endian;\n+    struct {\n+      unsigned mantissa2;\n+      unsigned mantissa1 : 20;\n+      unsigned exponent  : 11;\n+      unsigned sign      :  1;\n+    } big_endian;    \n+  } u;\n \n-  return !bcmp (&d1, &d2, sizeof (d1));\n+  u.d = dconstm1;\n+  if (u.big_endian.sign == 1)\n+    {\n+      u.d = x;\n+      return u.big_endian.sign;\n+    }\n+  else\n+    {\n+      u.d = x;\n+      return u.little_endian.sign;\n+    }\n }\n #else /* Target not IEEE */\n \n@@ -812,12 +834,12 @@ target_isnan (x)\n }\n \n /* Let's assume other float formats don't have minus zero.\n-   (This can be overridden by redefining REAL_VALUE_MINUS_ZERO.)  */\n+   (This can be overridden by redefining REAL_VALUE_NEGATIVE.)  */\n \n-target_minus_zero (x)\n+target_negative (x)\n      REAL_VALUE_TYPE x;\n {\n-  return 0;\n+  return x < 0;\n }\n #endif /* Target not IEEE */\n \f\n@@ -1267,12 +1289,9 @@ size_int (number)\n     return size_table[number];\n   if (number >= 0 && number < 2*HOST_BITS_PER_INT+1)\n     {\n-      int temp = allocation_temporary_p ();\n-\n       push_obstacks_nochange ();\n       /* Make this a permanent node.  */\n-      if (temp)\n-\tend_temporary_allocation ();\n+      end_temporary_allocation ();\n       t = build_int_2 (number, 0);\n       TREE_TYPE (t) = sizetype;\n       size_table[number] = t;\n@@ -1347,10 +1366,12 @@ fold_convert (t, arg1)\n #if !defined (REAL_IS_NOT_DOUBLE) || defined (REAL_ARITHMETIC)\n       else if (TREE_CODE (arg1) == REAL_CST)\n \t{\n-\t  if (REAL_VALUES_LESS (real_value_from_int_cst (TYPE_MAX_VALUE (type)),\n-\t\t\t\tTREE_REAL_CST (arg1))\n-\t      || REAL_VALUES_LESS (TREE_REAL_CST (arg1),\n-\t\t\t\t   real_value_from_int_cst (TYPE_MIN_VALUE (type))))\n+\t  REAL_VALUE_TYPE\n+\t    l = real_value_from_int_cst (TYPE_MIN_VALUE (type)),\n+\t    x = TREE_REAL_CST (arg1),\n+\t    u = real_value_from_int_cst (TYPE_MAX_VALUE (type));\n+\t  if (! ((REAL_VALUES_LESS (l, x) || REAL_VALUES_EQUAL (l, x))\n+\t\t && (REAL_VALUES_LESS (x, u) || REAL_VALUES_EQUAL (x, u))))\n \t    {\n \t      warning (\"real constant out of range for integer conversion\");\n \t      return t;\n@@ -1419,7 +1440,59 @@ non_lvalue (x)\n   TREE_CONSTANT (result) = TREE_CONSTANT (x);\n   return result;\n }\n+\f\n+/* Given a tree comparison code, return the code that is the logical inverse\n+   of the given code.  It is not safe to do this for floating-point\n+   comparisons, except for NE_EXPR and EQ_EXPR.  */\n \n+static enum tree_code\n+invert_tree_comparison (code)\n+     enum tree_code code;\n+{\n+  switch (code)\n+    {\n+    case EQ_EXPR:\n+      return NE_EXPR;\n+    case NE_EXPR:\n+      return EQ_EXPR;\n+    case GT_EXPR:\n+      return LE_EXPR;\n+    case GE_EXPR:\n+      return LT_EXPR;\n+    case LT_EXPR:\n+      return GE_EXPR;\n+    case LE_EXPR:\n+      return GT_EXPR;\n+    default:\n+      abort ();\n+    }\n+}\n+\n+/* Similar, but return the comparison that results if the operands are\n+   swapped.  This is safe for floating-point.  */\n+\n+static enum tree_code\n+swap_tree_comparison (code)\n+     enum tree_code code;\n+{\n+  switch (code)\n+    {\n+    case EQ_EXPR:\n+    case NE_EXPR:\n+      return code;\n+    case GT_EXPR:\n+      return LT_EXPR;\n+    case GE_EXPR:\n+      return LE_EXPR;\n+    case LT_EXPR:\n+      return GT_EXPR;\n+    case LE_EXPR:\n+      return GE_EXPR;\n+    default:\n+      abort ();\n+    }\n+}\n+\f\n /* Return nonzero if two operands are necessarily equal. \n    If ONLY_CONST is non-zero, only return non-zero for constants.  */\n \n@@ -1461,7 +1534,11 @@ operand_equal_p (arg0, arg1, only_const)\n      But reject weird values because we can't be sure what to do with them.  */\n   if (TREE_CODE (arg0) == TREE_CODE (arg1)\n       && TREE_CODE (arg0) == REAL_CST\n-      && REAL_VALUES_EQUAL (TREE_REAL_CST (arg0), TREE_REAL_CST (arg1))\n+      && !bcmp (&TREE_REAL_CST (arg0), &TREE_REAL_CST (arg1),\n+\t\tsizeof (REAL_VALUE_TYPE))\n+      /* Some people say these are not necessary.\n+\t But they do little harm, and taking them out would be risky.\n+\t So leave them and let's not spend any more time on them--rms.  */\n       && !REAL_VALUE_ISINF (TREE_REAL_CST (arg0))\n       && !REAL_VALUE_ISNAN (TREE_REAL_CST (arg0)))\n     return 1;\n@@ -1525,65 +1602,220 @@ operand_equal_p (arg0, arg1, only_const)\n \n   return 0;\n }\n+\f\n+/* Similar to operand_equal_p, but see if ARG0 might have been made by\n+   shorten_compare from ARG1 when ARG1 was being compared with OTHER. \n \n-/* Return nonzero if comparing COMP1 with COMP2\n-   gives the same result as comparing OP1 with OP2.\n    When in doubt, return 0.  */\n \n static int \n-comparison_equiv_p (comp1, comp2, op1, op2)\n-     tree comp1, comp2, op1, op2;\n+operand_equal_for_comparison_p (arg0, arg1, other)\n+     tree arg0, arg1;\n+     tree other;\n {\n-  int unsignedp1, unsignedp2;\n-  tree primop1, primop2;\n+  int unsignedp1, unsignedpo;\n+  tree primarg1, primother;\n   int correct_width;\n \n-  if (operand_equal_p (comp1, op1, 0)\n-      && operand_equal_p (comp2, op2, 0))\n+  if (operand_equal_p (arg0, arg1, 0))\n     return 1;\n \n-  if (TREE_CODE (TREE_TYPE (op1)) != INTEGER_TYPE)\n-    return 0;\n-\n-  if (TREE_TYPE (op1) != TREE_TYPE (op2))\n-    return 0;\n-\n-  if (TREE_TYPE (comp1) != TREE_TYPE (comp2))\n+  if (TREE_CODE (TREE_TYPE (arg0)) != INTEGER_TYPE)\n     return 0;\n \n-  /* Duplicate what shorten_compare does to the comparison operands,\n-     and see if that gives the actual comparison operands, COMP1 and COMP2.  */\n+  /* Duplicate what shorten_compare does to ARG1 and see if that gives the\n+     actual comparison operand, ARG0.\n \n-  /* Throw away any conversions to wider types\n+     First throw away any conversions to wider types\n      already present in the operands.  */\n-  primop1 = get_narrower (op1, &unsignedp1);\n-  primop2 = get_narrower (op2, &unsignedp2);\n \n-  correct_width = TYPE_PRECISION (TREE_TYPE (op2));\n-  if (unsignedp1 == unsignedp2\n-      && TYPE_PRECISION (TREE_TYPE (primop1)) < correct_width\n-      && TYPE_PRECISION (TREE_TYPE (primop2)) < correct_width)\n+  primarg1 = get_narrower (arg1, &unsignedp1);\n+  primother = get_narrower (other, &unsignedpo);\n+\n+  correct_width = TYPE_PRECISION (TREE_TYPE (arg1));\n+  if (unsignedp1 == unsignedpo\n+      && TYPE_PRECISION (TREE_TYPE (primarg1)) < correct_width\n+      && TYPE_PRECISION (TREE_TYPE (primother)) < correct_width)\n     {\n-      tree type = TREE_TYPE (comp1);\n+      tree type = TREE_TYPE (arg0);\n \n       /* Make sure shorter operand is extended the right way\n \t to match the longer operand.  */\n-      primop1 = convert (signed_or_unsigned_type (unsignedp1, TREE_TYPE (primop1)),\n-\t\t\t primop1);\n-      primop2 = convert (signed_or_unsigned_type (unsignedp2, TREE_TYPE (primop2)),\n-\t\t\t primop2);\n+      primarg1 = convert (signed_or_unsigned_type (unsignedp1,\n+\t\t\t\t\t\t  TREE_TYPE (primarg1)),\n+\t\t\t primarg1);\n \n-      primop1 = convert (type, primop1);\n-      primop2 = convert (type, primop2);\n-\n-      if (operand_equal_p (comp1, primop1, 0)\n-\t  && operand_equal_p (comp2, primop2, 0))\n+      if (operand_equal_p (arg0, convert (type, primarg1), 0))\n \treturn 1;\n     }\n \n   return 0;\n }\n \f\n+/* See if ARG is an expression is either a comparison or is peforming\n+   arithmetic on comparisons.  The comparisons must only be comparing\n+   two different values, which will be stored in *CVAL1 and *CVAL2; if\n+   they are non-zero it means that some operands have already been found.\n+   No variables may be used anywhere else in the expression except in the\n+   comparisons.\n+\n+   If this is true, return 1.  Otherwise, return zero.  */\n+\n+static int\n+twoval_comparison_p (arg, cval1, cval2)\n+     tree arg;\n+     tree *cval1, *cval2;\n+{\n+  enum tree_code code = TREE_CODE (arg);\n+  char class = TREE_CODE_CLASS (code);\n+\n+  /* We can handle some of the 'e' cases here.  */\n+  if (class == 'e'\n+      && (code == TRUTH_NOT_EXPR\n+\t  || (code == SAVE_EXPR && SAVE_EXPR_RTL (arg) == 0)))\n+    class = '1';\n+  else if (class == 'e'\n+\t   && (code == TRUTH_ANDIF_EXPR || code == TRUTH_ORIF_EXPR\n+\t       || code == COMPOUND_EXPR))\n+    class = '2';\n+\n+  switch (class)\n+    {\n+    case '1':\n+      return twoval_comparison_p (TREE_OPERAND (arg, 0), cval1, cval2);\n+\n+    case '2':\n+      return (twoval_comparison_p (TREE_OPERAND (arg, 0), cval1, cval2)\n+\t      && twoval_comparison_p (TREE_OPERAND (arg, 1), cval1, cval2));\n+\n+    case 'c':\n+      return 1;\n+\n+    case 'e':\n+      if (code == COND_EXPR)\n+\treturn (twoval_comparison_p (TREE_OPERAND (arg, 0), cval1, cval2)\n+\t\t&& twoval_comparison_p (TREE_OPERAND (arg, 1), cval1, cval2)\n+\t\t&& twoval_comparison_p (TREE_OPERAND (arg, 2),\n+\t\t\t\t\tcval1, cval2));\n+      return 0;\n+\t  \n+    case '<':\n+      /* First see if we can handle the first operand, then the second.  For\n+\t the second operand, we know *CVAL1 can't be zero.  It must be that\n+\t one side of the comparison is each of the values; test for the\n+\t case where this isn't true by failing if the two operands\n+\t are the same.  */\n+\n+      if (operand_equal_p (TREE_OPERAND (arg, 0),\n+\t\t\t   TREE_OPERAND (arg, 1), 0))\n+\treturn 0;\n+\n+      if (*cval1 == 0)\n+\t*cval1 = TREE_OPERAND (arg, 0);\n+      else if (operand_equal_p (*cval1, TREE_OPERAND (arg, 0), 0))\n+\t;\n+      else if (*cval2 == 0)\n+\t*cval2 = TREE_OPERAND (arg, 0);\n+      else if (operand_equal_p (*cval2, TREE_OPERAND (arg, 0), 0))\n+\t;\n+      else\n+\treturn 0;\n+\n+      if (operand_equal_p (*cval1, TREE_OPERAND (arg, 1), 0))\n+\t;\n+      else if (*cval2 == 0)\n+\t*cval2 = TREE_OPERAND (arg, 1);\n+      else if (operand_equal_p (*cval2, TREE_OPERAND (arg, 1), 0))\n+\t;\n+      else\n+\treturn 0;\n+\n+      return 1;\n+    }\n+\n+  return 0;\n+}\n+\f\n+/* ARG is a tree that is known to contain just arithmetic operations and\n+   comparisons.  Evaluate the operations in the tree substituting NEW0 for\n+   any occurrance of OLD0 as an operand of a comparison and likewise for\n+   NEW1 and OLD1.  */\n+\n+static tree\n+eval_subst (arg, old0, new0, old1, new1)\n+     tree arg;\n+     tree old0, new0, old1, new1;\n+{\n+  tree type = TREE_TYPE (arg);\n+  enum tree_code code = TREE_CODE (arg);\n+  char class = TREE_CODE_CLASS (code);\n+\n+  /* We can handle some of the 'e' cases here.  */\n+  if (class == 'e' && code == TRUTH_NOT_EXPR)\n+    class = '1';\n+  else if (class == 'e'\n+\t   && (code == TRUTH_ANDIF_EXPR || code == TRUTH_ORIF_EXPR))\n+    class = '2';\n+\n+  switch (class)\n+    {\n+    case '1':\n+      return fold (build1 (code, type,\n+\t\t\t   eval_subst (TREE_OPERAND (arg, 0),\n+\t\t\t\t       old0, new0, old1, new1)));\n+\n+    case '2':\n+      return fold (build (code, type,\n+\t\t\t  eval_subst (TREE_OPERAND (arg, 0),\n+\t\t\t\t      old0, new0, old1, new1),\n+\t\t\t  eval_subst (TREE_OPERAND (arg, 1),\n+\t\t\t\t      old0, new0, old1, new1)));\n+\n+    case 'e':\n+      switch (code)\n+\t{\n+\tcase SAVE_EXPR:\n+\t  return eval_subst (TREE_OPERAND (arg, 0), old0, new0, old1, new1);\n+\n+\tcase COMPOUND_EXPR:\n+\t  return eval_subst (TREE_OPERAND (arg, 1), old0, new0, old1, new1);\n+\n+\tcase COND_EXPR:\n+\t  return fold (build (code, type,\n+\t\t\t      eval_subst (TREE_OPERAND (arg, 0),\n+\t\t\t\t\t  old0, new0, old1, new1),\n+\t\t\t      eval_subst (TREE_OPERAND (arg, 1),\n+\t\t\t\t\t  old0, new0, old1, new1),\n+\t\t\t      eval_subst (TREE_OPERAND (arg, 2),\n+\t\t\t\t\t  old0, new0, old1, new1)));\n+\t}\n+\n+    case '<':\n+      {\n+\ttree arg0 = TREE_OPERAND (arg, 0);\n+\ttree arg1 = TREE_OPERAND (arg, 1);\n+\n+\t/* We need to check both for exact equality and tree equality.  The\n+\t   former will be true if the operand has a side-effect.  In that\n+\t   case, we know the operand occurred exactly once.  */\n+\n+\tif (arg0 == old0 || operand_equal_p (arg0, old0, 0))\n+\t  arg0 = new0;\n+\telse if (arg0 == old1 || operand_equal_p (arg0, old1, 0))\n+\t  arg0 = new1;\n+\n+\tif (arg1 == old0 || operand_equal_p (arg1, old0, 0))\n+\t  arg1 = new0;\n+\telse if (arg1 == old1 || operand_equal_p (arg1, old1, 0))\n+\t  arg1 = new1;\n+\n+\treturn fold (build (code, type, arg0, arg1));\n+      }\n+    }\n+\n+  return arg;\n+}\n+\f\n /* Return a tree for the case when the result of an expression is RESULT\n    converted to TYPE and OMITTED was previously an operand of the expression\n    but is now not needed (e.g., we folded OMITTED * 0).\n@@ -1612,39 +1844,26 @@ invert_truthvalue (arg)\n      tree arg;\n {\n   tree type = TREE_TYPE (arg);\n+  enum tree_code code = TREE_CODE (arg);\n \n-  /* For floating-point comparisons, it isn't safe to invert the condition.\n-     So just enclose a TRUTH_NOT_EXPR around what we have.  */\n-  if (TREE_CODE_CLASS (TREE_CODE (arg)) == '<'\n-      && TREE_CODE (TREE_TYPE (TREE_OPERAND (arg, 0))) == REAL_TYPE)\n-    return build1 (TRUTH_NOT_EXPR, type, arg);\n+  /* If this is a comparison, we can simply invert it, except for\n+     floating-point non-equality comparisons, in which case we just\n+     enclose a TRUTH_NOT_EXPR around what we have.  */\n \n-  switch (TREE_CODE (arg))\n+  if (TREE_CODE_CLASS (code) == '<')\n     {\n-    case NE_EXPR:\n-      TREE_SET_CODE (arg, EQ_EXPR);\n-      return arg;\n-\n-    case EQ_EXPR:\n-      TREE_SET_CODE (arg, NE_EXPR);\n-      return arg;\n-\n-    case GE_EXPR:\n-      TREE_SET_CODE (arg, LT_EXPR);\n-      return arg;\n-\n-    case GT_EXPR:\n-      TREE_SET_CODE (arg, LE_EXPR);\n-      return arg;\n-\n-    case LE_EXPR:\n-      TREE_SET_CODE (arg, GT_EXPR);\n-      return arg;\n-\n-    case LT_EXPR:\n-      TREE_SET_CODE (arg, GE_EXPR);\n-      return arg;\n+      if (TREE_CODE (TREE_TYPE (TREE_OPERAND (arg, 0))) == REAL_TYPE\n+\t  && code != NE_EXPR && code != EQ_EXPR)\n+\treturn build1 (TRUTH_NOT_EXPR, type, arg);\n+      else\n+\t{\n+\t  TREE_SET_CODE (arg, invert_tree_comparison (code));\n+\t  return arg;\n+\t}\n+    }\n \n+  switch (code)\n+    {\n     case INTEGER_CST:\n       return convert (type, build_int_2 (TREE_INT_CST_LOW (arg) == 0\n \t\t\t\t\t && TREE_INT_CST_HIGH (arg) == 0, 0));\n@@ -1814,7 +2033,7 @@ optimize_bit_field_compare (code, compare_type, lhs, rhs)\n      extraction at all and so can do nothing.  */\n   linner = get_inner_reference (lhs, &lbitsize, &lbitpos, &lmode,\n \t\t\t\t&lunsignedp, &lvolatilep);\n-  if (lbitsize == GET_MODE_BITSIZE (lmode))\n+  if (lbitsize == GET_MODE_BITSIZE (lmode) || lbitsize < 0)\n     return 0;\n \n  if (!const_p)\n@@ -2003,6 +2222,8 @@ decode_field_reference (exp, pbitsize, pbitpos, pmode, punsignedp,\n \n   inner = get_inner_reference (exp, pbitsize, pbitpos, pmode,\n \t\t\t       punsignedp, pvolatilep);\n+  if (*pbitsize < 0)\n+    return 0;\n   \n   if (mask == 0)\n     {\n@@ -2311,10 +2532,12 @@ fold (expr)\n {\n   register tree t = expr;\n   tree t1 = NULL_TREE;\n+  tree tem;\n   tree type = TREE_TYPE (expr);\n   register tree arg0, arg1;\n   register enum tree_code code = TREE_CODE (t);\n   register int kind;\n+  int invert;\n \n   /* WINS will be nonzero when the switch is done\n      if all operands are constant.  */\n@@ -2368,11 +2591,10 @@ fold (expr)\n        || code == BIT_AND_EXPR)\n       && (TREE_CODE (arg0) == INTEGER_CST || TREE_CODE (arg0) == REAL_CST))\n     {\n-      tree tem = arg0;\n-      arg0 = arg1; arg1 = tem;\n+      tem = arg0; arg0 = arg1; arg1 = tem;\n \n-      TREE_OPERAND (t, 0) = arg0;\n-      TREE_OPERAND (t, 1) = arg1;\n+      tem = TREE_OPERAND (t, 0); TREE_OPERAND (t, 0) = TREE_OPERAND (t, 1);\n+      TREE_OPERAND (t, 1) = tem;\n     }\n \n   /* Now WINS is set as described above,\n@@ -2467,6 +2689,14 @@ fold (expr)\n \t    return convert (type, test);\n \t}\n     }\n+  else if (TREE_CODE_CLASS (code) == '<'\n+\t   && TREE_CODE (arg0) == COMPOUND_EXPR)\n+    return build (COMPOUND_EXPR, type, TREE_OPERAND (arg0, 0),\n+\t\t  fold (build (code, type, TREE_OPERAND (arg0, 1), arg1)));\n+  else if (TREE_CODE_CLASS (code) == '<'\n+\t   && TREE_CODE (arg1) == COMPOUND_EXPR)\n+    return build (COMPOUND_EXPR, type, TREE_OPERAND (arg1, 0),\n+\t\t  fold (build (code, type, arg0, TREE_OPERAND (arg1, 1))));\n \t  \n   switch (code)\n     {\n@@ -2599,7 +2829,7 @@ fold (expr)\n \t    }\n \t  else if (TREE_CODE (arg0) == REAL_CST)\n \t    {\n-\t      if (REAL_VALUES_LESS (TREE_REAL_CST (arg0), dconst0))\n+\t      if (REAL_VALUE_NEGATIVE (TREE_REAL_CST (arg0)))\n \t\tt = build_real (type,\n \t\t\t\tREAL_VALUE_NEGATE (TREE_REAL_CST (arg0)));\n \t    }\n@@ -2662,7 +2892,7 @@ fold (expr)\n \t The rest of the code applies to all associative operations.  */\n       if (!wins)\n \t{\n-\t  tree var, con, tem;\n+\t  tree var, con;\n \t  int varsign;\n \n \t  if (split_tree (arg0, code, &var, &con, &varsign))\n@@ -2762,12 +2992,13 @@ fold (expr)\n       /* Convert A - (-B) to A + B.  */\n       else if (TREE_CODE (arg1) == NEGATE_EXPR)\n \treturn fold (build (PLUS_EXPR, type, arg0, TREE_OPERAND (arg1, 0)));\n-      else\n+      else if (TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT)\n \t{\n+\t  /* Except with IEEE floating point, 0-x equals -x.  */\n \t  if (! wins && real_zerop (arg0))\n \t    return build1 (NEGATE_EXPR, type, arg1);\n-\t  /* In IEEE floating point, x-0 may not equal x.  */\n-\t  if (real_zerop (arg1) && TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT)\n+\t  /* Except with IEEE floating point, x-0 equals x.  */\n+\t  if (real_zerop (arg1))\n \t    return non_lvalue (convert (type, arg0));\n \t}\n       /* Fold &x - &x.  This can happen from &x.foo - &x. \n@@ -2798,13 +3029,13 @@ fold (expr)\n \t    return fold (build (LSHIFT_EXPR, type, arg1,\n \t\t\t\tTREE_OPERAND (arg0, 1)));\n \t}\n-      /* In IEEE floating point, these optimizations are not correct.  */\n       else\n \t{\n+\t  /* x*0 is 0, except for IEEE floating point.  */\n \t  if (TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT\n \t      && real_zerop (arg1))\n \t    return omit_one_operand (type, arg1, arg0);\n-\t  /* In IEEE floating point, x*1 is not equivalent to x for nans.\n+\t  /* In IEEE floating point, x*1 is not equivalent to x for snans.\n \t     However, ANSI says we can drop signals,\n \t     so we can do this anyway.  */\n \t  if (real_onep (arg1))\n@@ -2965,8 +3196,6 @@ fold (expr)\n \t rhs.  Then try to merge our lhs and rhs.  */\n       if (optimize)\n \t{\n-\t  tree tem;\n-\n \t  if (TREE_CODE (arg0) == code)\n \t    {\n \t      tem = merge_component_references (code, type,\n@@ -3013,21 +3242,7 @@ fold (expr)\n \t  TREE_OPERAND (t, 1) = arg0;\n \t  arg0 = TREE_OPERAND (t, 0);\n \t  arg1 = TREE_OPERAND (t, 1);\n-\t  switch (code)\n-\t    {\n-\t    case GT_EXPR:\n-\t      code = LT_EXPR;\n-\t      break;\n-\t    case GE_EXPR:\n-\t      code = LE_EXPR;\n-\t      break;\n-\t    case LT_EXPR:\n-\t      code = GT_EXPR;\n-\t      break;\n-\t    case LE_EXPR:\n-\t      code = GE_EXPR;\n-\t      break;\n-\t    }\n+\t  code = swap_tree_comparison (code);\n \t  TREE_SET_CODE (t, code);\n \t}\n \n@@ -3045,43 +3260,34 @@ fold (expr)\n \n \tif (constop && TREE_CODE (varop) == POSTINCREMENT_EXPR)\n \t  {\n-\t    tree newconst\n-\t      = fold (build (PLUS_EXPR, TREE_TYPE (varop),\n-\t\t\t     constop, TREE_OPERAND (varop, 1)));\n \t    /* This optimization is invalid for ordered comparisons\n \t       if CONST+INCR overflows or if foo+incr might overflow.\n+\t       This optimization is invalid for floating point due to rounding.\n \t       For pointer types we assume overflow doesn't happen.  */\n \t    if (TREE_CODE (TREE_TYPE (varop)) == POINTER_TYPE\n-\t\t|| code == EQ_EXPR || code == NE_EXPR)\n+\t\t|| (TREE_CODE (TREE_TYPE (varop)) != REAL_TYPE\n+\t\t    && (code == EQ_EXPR || code == NE_EXPR)))\n \t      {\n-\t\t/* This optimization is invalid for floating point\n-\t\t   if adding one to the constant does not change it.  */\n-\t\tif (TREE_CODE (TREE_TYPE (newconst)) != REAL_TYPE\n-\t\t    || !REAL_VALUES_EQUAL (TREE_REAL_CST (newconst),\n-\t\t\t\t\t   TREE_REAL_CST (constop)))\n-\t\t  {\n-\t\t    TREE_SET_CODE (varop, PREINCREMENT_EXPR);\n-\t\t    *constoploc = newconst;\n-\t\t    return t;\n-\t\t  }\n+\t\ttree newconst\n+\t\t  = fold (build (PLUS_EXPR, TREE_TYPE (varop),\n+\t\t\t\t constop, TREE_OPERAND (varop, 1)));\n+\t\tTREE_SET_CODE (varop, PREINCREMENT_EXPR);\n+\t\t*constoploc = newconst;\n+\t\treturn t;\n \t      }\n \t  }\n \telse if (constop && TREE_CODE (varop) == POSTDECREMENT_EXPR)\n \t  {\n-\t    tree newconst\n-\t      = fold (build (MINUS_EXPR, TREE_TYPE (varop),\n-\t\t\t     constop, TREE_OPERAND (varop, 1)));\n \t    if (TREE_CODE (TREE_TYPE (varop)) == POINTER_TYPE\n-\t\t|| code == EQ_EXPR || code == NE_EXPR)\n+\t\t|| (TREE_CODE (TREE_TYPE (varop)) != REAL_TYPE\n+\t\t    && (code == EQ_EXPR || code == NE_EXPR)))\n \t      {\n-\t\tif (TREE_CODE (TREE_TYPE (newconst)) != REAL_TYPE\n-\t\t    || !REAL_VALUES_EQUAL (TREE_REAL_CST (newconst),\n-\t\t\t\t\t   TREE_REAL_CST (constop)))\n-\t\t  {\n-\t\t    TREE_SET_CODE (varop, PREDECREMENT_EXPR);\n-\t\t    *constoploc = newconst;\n-\t\t    return t;\n-\t\t  }\n+\t\ttree newconst\n+\t\t  = fold (build (MINUS_EXPR, TREE_TYPE (varop),\n+\t\t\t\t constop, TREE_OPERAND (varop, 1)));\n+\t\tTREE_SET_CODE (varop, PREDECREMENT_EXPR);\n+\t\t*constoploc = newconst;\n+\t\treturn t;\n \t      }\n \t  }\n       }\n@@ -3108,89 +3314,6 @@ fold (expr)\n \t    }\n \t}\n \n-      /* If we are comparing the result of a comparison to a constant,\n-\t we can often simplify this, since the comparison result is known to\n-\t be either 0 or 1.  We can ignore conversions if the LHS is a\n-\t comparison.  */\n-\n-      if (TREE_CODE (arg1) == INTEGER_CST)\n-\t{\n-\t  tree comparison = arg0;\n-\n-\t  while (TREE_CODE (comparison) == NOP_EXPR\n-\t\t || TREE_CODE (comparison) == CONVERT_EXPR)\n-\t    comparison = TREE_OPERAND (comparison, 0);\n-\n-\t  if (TREE_CODE_CLASS (TREE_CODE (comparison)) == '<'\n-\t      || TREE_CODE (comparison) == TRUTH_ANDIF_EXPR\n-\t      || TREE_CODE (comparison) == TRUTH_ORIF_EXPR\n-\t      || TREE_CODE (comparison) == TRUTH_AND_EXPR\n-\t      || TREE_CODE (comparison) == TRUTH_OR_EXPR\n-\t      || TREE_CODE (comparison) == TRUTH_NOT_EXPR)\n-\t    {\n-\t      /* We do different things depending on whether the\n-\t\t constant being compared against is < 0, == 0, == 1, or > 1.\n-\t\t Each of those cases, in order, corresponds to one\n-\t\t character in a string.  The value of the character is\n-\t\t the result to return.  A '0' or '1' means return always true\n-\t\t or always false, respectively; 'c' means return the result\n-\t\t of the comparison, and 'i' means return the result of the\n-\t\t inverted comparison.  */\n-\n-\t      char *actions, action;\n-\n-\t      switch (code)\n-\t\t{\n-\t\tcase EQ_EXPR:\n-\t\t  actions = \"0ic0\";\n-\t\t  break;\n-\t\tcase NE_EXPR:\n-\t\t  actions = \"1ci1\";\n-\t\t  break;\n-\t\tcase LE_EXPR:\n-\t\t  actions = \"0i11\";\n-\t\t  break;\n-\t\tcase LT_EXPR:\n-\t\t  actions = \"00i1\";\n-\t\t  break;\n-\t\tcase GE_EXPR:\n-\t\t  actions = \"11c0\";\n-\t\t  break;\n-\t\tcase GT_EXPR:\n-\t\t  actions = \"1c00\";\n-\t\t  break;\n-\t\t}\n-\n-\t      if (tree_int_cst_lt (arg1, integer_zero_node))\n-\t\taction = actions[0];\n-\t      else if (integer_zerop (arg1))\n-\t\taction = actions[1];\n-\t      else if (integer_onep (arg1))\n-\t\taction = actions[2];\n-\t      else\n-\t\taction = actions[3];\n-\n-\t      switch (action)\n-\t\t{\n-\t\tcase '0':\n-\t\t  return omit_one_operand (type, integer_zero_node,\n-\t\t\t\t\t   comparison);\n-\n-\t\tcase '1':\n-\t\t  return omit_one_operand (type, integer_one_node, comparison);\n-\n-\t\tcase 'c':\n-\t\t  return convert (type, comparison);\n-\n-\t\tcase 'i':\n-\t\t  return convert (type, invert_truthvalue (comparison));\n-\t\t  \n-\t\tdefault:\n-\t\t  abort ();\n-\t\t}\n-\t    }\n-\t}\n-\t\t     \n       /* If this is an EQ or NE comparison with zero and ARG0 is\n \t (1 << foo) & bar, convert it to (bar >> foo) & 1.  Both require\n \t two operations, but the latter can be done in one less insn\n@@ -3241,20 +3364,30 @@ fold (expr)\n \treturn build (code == EQ_EXPR ? NE_EXPR : EQ_EXPR, type,\n \t\t      arg0, integer_zero_node);\n \n-      /* Simplify comparison of an integer with itself.\n-\t (This may not be safe with IEEE floats if they are nans.)  */\n-      if (operand_equal_p (arg0, arg1, 0)\n-\t  && TREE_CODE (TREE_TYPE (arg1)) == INTEGER_TYPE)\n+      /* Simplify comparison of something with itself.  (For IEEE\n+\t floating-point, we can only do some of these simplifications.)  */\n+      if (operand_equal_p (arg0, arg1, 0))\n \t{\n \t  switch (code)\n \t    {\n \t    case EQ_EXPR:\n \t    case GE_EXPR:\n \t    case LE_EXPR:\n-\t      t = build_int_2 (1, 0);\n-\t      TREE_TYPE (t) = type;\n-\t      return t;\n+\t      if (TREE_CODE (TREE_TYPE (arg0)) == INTEGER_TYPE)\n+\t\t{\n+\t\t  t = build_int_2 (1, 0);\n+\t\t  TREE_TYPE (t) = type;\n+\t\t  return t;\n+\t\t}\n+\t      code = EQ_EXPR;\n+\t      TREE_SET_CODE (t, code);\n+\t      break;\n+\n \t    case NE_EXPR:\n+\t      /* For NE, we can only do this simplification if integer.  */\n+\t      if (TREE_CODE (TREE_TYPE (arg0)) != INTEGER_TYPE)\n+\t\tbreak;\n+\t      /* ... fall through ... */\n \t    case GT_EXPR:\n \t    case LT_EXPR:\n \t      t = build_int_2 (0, 0);\n@@ -3272,9 +3405,11 @@ fold (expr)\n \t  switch (TREE_CODE (t))\n \t    {\n \t    case GT_EXPR:\n+\t      code = NE_EXPR;\n \t      TREE_SET_CODE (t, NE_EXPR);\n \t      break;\n \t    case LE_EXPR:\n+\t      code = EQ_EXPR;\n \t      TREE_SET_CODE (t, EQ_EXPR);\n \t      break;\n \t    case GE_EXPR:\n@@ -3286,33 +3421,155 @@ fold (expr)\n \t    }\n \t}\n \n-      /* To compute GT, swap the arguments and do LT.\n+      /* If we are comparing an expression that just has comparisons\n+\t of two integer values, arithmetic expressions of those comparisons,\n+\t and constants, we can simplify it.  There are only three cases\n+\t to check: the two values can either be equal, the first can be\n+\t greater, or the second can be greater.  Fold the expression for\n+\t those three values.  Since each value must be 0 or 1, we have\n+\t eight possibilities, each of which corresponds to the constant 0\n+\t or 1 or one of the six possible comparisons.\n+\n+\t This handles common cases like (a > b) == 0 but also handles\n+\t expressions like  ((x > y) - (y > x)) > 0, which supposedly\n+\t occur in macroized code.  */\n+\n+      if (TREE_CODE (arg1) == INTEGER_CST && TREE_CODE (arg0) != INTEGER_CST)\n+\t{\n+\t  tree cval1 = 0, cval2 = 0;\n+\n+\t  if (twoval_comparison_p (arg0, &cval1, &cval2)\n+\t      /* Don't handle degenerate cases here; they should already\n+\t\t have been handled anyway.  */\n+\t      && cval1 != 0 && cval2 != 0\n+\t      && ! (TREE_CONSTANT (cval1) && TREE_CONSTANT (cval2))\n+\t      && TREE_TYPE (cval1) == TREE_TYPE (cval2)\n+\t      && TREE_CODE (TREE_TYPE (cval1)) == INTEGER_TYPE\n+\t      && ! operand_equal_p (TYPE_MIN_VALUE (TREE_TYPE (cval1)),\n+\t\t\t\t    TYPE_MAX_VALUE (TREE_TYPE (cval2)), 0))\n+\t    {\n+\t      tree maxval = TYPE_MAX_VALUE (TREE_TYPE (cval1));\n+\t      tree minval = TYPE_MIN_VALUE (TREE_TYPE (cval1));\n+\n+\t      /* We can't just pass T to eval_subst in case cval1 or cval2\n+\t\t was the same as ARG1.  */\n+\n+\t      tree high_result\n+\t\t= fold (build (code, type,\n+\t\t\t       eval_subst (arg0, cval1, maxval, cval2, minval),\n+\t\t\t       arg1));\n+\t      tree equal_result\n+\t\t= fold (build (code, type,\n+\t\t\t       eval_subst (arg0, cval1, maxval, cval2, maxval),\n+\t\t\t       arg1));\n+\t      tree low_result\n+\t\t= fold (build (code, type,\n+\t\t\t       eval_subst (arg0, cval1, minval, cval2, maxval),\n+\t\t\t       arg1));\n+\n+\t      /* All three of these results should be 0 or 1.  Confirm they\n+\t\t are.  Then use those values to select the proper code\n+\t\t to use.  */\n+\n+\t      if ((integer_zerop (high_result)\n+\t\t   || integer_onep (high_result))\n+\t\t  && (integer_zerop (equal_result)\n+\t\t      || integer_onep (equal_result))\n+\t\t  && (integer_zerop (low_result)\n+\t\t      || integer_onep (low_result)))\n+\t\t{\n+\t\t  /* Make a 3-bit mask with the high-order bit being the\n+\t\t     value for `>', the next for '=', and the low for '<'.  */\n+\t\t  switch ((integer_onep (high_result) * 4)\n+\t\t\t  + (integer_onep (equal_result) * 2)\n+\t\t\t  + integer_onep (low_result))\n+\t\t    {\n+\t\t    case 0:\n+\t\t      /* Always false.  */\n+\t\t      return convert (type, integer_zero_node);\n+\t\t    case 1:\n+\t\t      code = LT_EXPR;\n+\t\t      break;\n+\t\t    case 2:\n+\t\t      code = EQ_EXPR;\n+\t\t      break;\n+\t\t    case 3:\n+\t\t      code = LE_EXPR;\n+\t\t      break;\n+\t\t    case 4:\n+\t\t      code = GT_EXPR;\n+\t\t      break;\n+\t\t    case 5:\n+\t\t      code = NE_EXPR;\n+\t\t      break;\n+\t\t    case 6:\n+\t\t      code = GE_EXPR;\n+\t\t      break;\n+\t\t    case 7:\n+\t\t      /* Always true.  */\n+\t\t      return convert (type, integer_one_node);\n+\t\t    }\n+\n+\t\t  return fold (build (code, type, cval1, cval2));\n+\t\t}\n+\t    }\n+\t}\n+\n+      /* If this is a comparison of a field, we may be able to simplify it.  */\n+      if ((TREE_CODE (arg0) == COMPONENT_REF\n+\t\t|| TREE_CODE (arg0) == BIT_FIELD_REF)\n+\t       && (code == EQ_EXPR || code == NE_EXPR)\n+\t       /* Handle the constant case even without -O\n+\t\t  to make sure the warnings are given.  */\n+\t       && (optimize || TREE_CODE (arg1) == INTEGER_CST))\n+\t{\n+\t  t1 = optimize_bit_field_compare (code, type, arg0, arg1);\n+\t  return t1 ? t1 : t;\n+\t}\n+\n+      /* From here on, the only cases we handle are when the result is\n+\t known to be a constant.\n+\n+\t To compute GT, swap the arguments and do LT.\n \t To compute GE, do LT and invert the result.\n \t To compute LE, swap the arguments, do LT and invert the result.\n-\t To compute NE, do EQ and invert the result.  */\n+\t To compute NE, do EQ and invert the result.\n+\n+\t Therefore, the code below must handle only EQ and LT.  */\n+\n       if (code == LE_EXPR || code == GT_EXPR)\n \t{\n-\t  register tree temp = arg0;\n-\t  arg0 = arg1;\n-\t  arg1 = temp;\n+\t  tem = arg0, arg0 = arg1, arg1 = tem;\n+\t  code = swap_tree_comparison (code);\n+\t}\n+\n+      /* Note that it is safe to invert for real values here because we\n+\t will check below in the one case that it matters.  */\n+\n+      invert = 0;\n+      if (code == NE_EXPR || code == GE_EXPR)\n+\t{\n+\t  invert = 1;\n+\t  code = invert_tree_comparison (code);\n \t}\n \n       /* Compute a result for LT or EQ if args permit;\n \t otherwise return T.  */\n-      if (TREE_CODE (arg0) == INTEGER_CST\n-\t  && TREE_CODE (arg1) == INTEGER_CST)\n+      if (TREE_CODE (arg0) == INTEGER_CST && TREE_CODE (arg1) == INTEGER_CST)\n \t{\n-\t  if (code == EQ_EXPR || code == NE_EXPR)\n-\t    t = build_int_2\n-\t      (TREE_INT_CST_LOW (arg0) == TREE_INT_CST_LOW (arg1)\n-\t       && TREE_INT_CST_HIGH (arg0) == TREE_INT_CST_HIGH (arg1),\n-\t       0);\n+\t  if (code == EQ_EXPR)\n+\t    t1 = build_int_2 ((TREE_INT_CST_LOW (arg0)\n+\t\t\t       == TREE_INT_CST_LOW (arg1))\n+\t\t\t      && (TREE_INT_CST_HIGH (arg0)\n+\t\t\t\t  == TREE_INT_CST_HIGH (arg1)),\n+\t\t\t      0);\n \t  else\n-\t    t = build_int_2 ((TREE_UNSIGNED (TREE_TYPE (arg0))\n-\t\t\t      ? INT_CST_LT_UNSIGNED (arg0, arg1)\n-\t\t\t      : INT_CST_LT (arg0, arg1)),\n-\t\t\t     0);\n+\t    t1 = build_int_2 ((TREE_UNSIGNED (TREE_TYPE (arg0))\n+\t\t\t       ? INT_CST_LT_UNSIGNED (arg0, arg1)\n+\t\t\t       : INT_CST_LT (arg0, arg1)),\n+\t\t\t      0);\n \t}\n+\n       /* Assume a nonexplicit constant cannot equal an explicit one,\n \t since such code would be undefined anyway.\n \t Exception: on sysvr4, using #pragma weak,\n@@ -3321,133 +3578,211 @@ fold (expr)\n \t       && !integer_zerop (arg1)\n \t       && TREE_CONSTANT (arg0)\n \t       && TREE_CODE (arg0) == ADDR_EXPR\n-\t       && (code == EQ_EXPR || code == NE_EXPR))\n-\t{\n-\t  t = build_int_2 (0, 0);\n-\t}\n+\t       && code == EQ_EXPR)\n+\tt1 = build_int_2 (0, 0);\n+\n       /* Two real constants can be compared explicitly.  */\n-      else if (TREE_CODE (arg0) == REAL_CST\n-\t       && TREE_CODE (arg1) == REAL_CST)\n+      else if (TREE_CODE (arg0) == REAL_CST && TREE_CODE (arg1) == REAL_CST)\n \t{\n-\t  if (code == EQ_EXPR || code == NE_EXPR)\n-\t    t = build_int_2 (REAL_VALUES_EQUAL (TREE_REAL_CST (arg0),\n-\t\t\t\t\t\tTREE_REAL_CST (arg1)),\n-\t\t\t     0);\n+\t  /* If either operand is a NaN, the result is false with two\n+\t     exceptions: First, an NE_EXPR is true on NaNs, but that case\n+\t     is already handled correctly since we will be inverting the\n+\t     result for NE_EXPR.  Second, if we had inverted a LE_EXPR\n+\t     or a GE_EXPR into a LT_EXPR, we must return true so that it\n+\t     will be inverted into false.  */\n+\n+\t  if (REAL_VALUE_ISNAN (TREE_REAL_CST (arg0))\n+\t      || REAL_VALUE_ISNAN (TREE_REAL_CST (arg1)))\n+\t    t1 = build_int_2 (invert && code == LT_EXPR, 0);\n+\n+\t  else if (code == EQ_EXPR)\n+\t    t1 = build_int_2 (REAL_VALUES_EQUAL (TREE_REAL_CST (arg0),\n+\t\t\t\t\t\t TREE_REAL_CST (arg1)),\n+\t\t\t      0);\n \t  else\n-\t    t = build_int_2 (REAL_VALUES_LESS (TREE_REAL_CST (arg0),\n-\t\t\t\t\t       TREE_REAL_CST (arg1)),\n-\t\t\t     0);\n-\t}\n-      else if ((TREE_CODE (arg0) == COMPONENT_REF\n-\t\t|| TREE_CODE (arg0) == BIT_FIELD_REF)\n-\t       && (code == EQ_EXPR || code == NE_EXPR)\n-\t       /* Handle the constant case even without -O\n-\t\t  to make sure the warnings are given.  */\n-\t       && (optimize || TREE_CODE (arg1) == INTEGER_CST))\n-\t{\n-\t  tree tem = optimize_bit_field_compare (code, type, arg0, arg1);\n-\t  return tem ? tem : t;\n+\t    t1 = build_int_2 (REAL_VALUES_LESS (TREE_REAL_CST (arg0),\n+\t\t\t\t\t\tTREE_REAL_CST (arg1)),\n+\t\t\t      0);\n \t}\n \n-      /* If what we want is other than LT or EQ, invert the result.  */\n-      if ((code == GE_EXPR || code == LE_EXPR || code == NE_EXPR)\n-\t  && TREE_CODE (t) == INTEGER_CST)\n-\tTREE_INT_CST_LOW (t) ^= 1;\n-      TREE_TYPE (t) = type;\n-      return t;\n+      if (t1 == NULL_TREE)\n+\treturn t;\n+\n+      if (invert)\n+\tTREE_INT_CST_LOW (t1) ^= 1;\n+\n+      TREE_TYPE (t1) = type;\n+      return t1;\n \n     case COND_EXPR:\n       if (TREE_CODE (arg0) == INTEGER_CST)\n \treturn TREE_OPERAND (t, (integer_zerop (arg0) ? 2 : 1));\n       else if (operand_equal_p (arg1, TREE_OPERAND (expr, 2), 0))\n \treturn omit_one_operand (type, arg1, arg0);\n-      else if (integer_onep (TREE_OPERAND (t, 1))\n-\t       && integer_zerop (TREE_OPERAND (t, 2))\n-\t       /* If we try to convert TREE_OPERAND (t, 0) to our type, the\n-\t\t  call to fold will try to move the conversion inside \n-\t\t  a COND, which will recurse.  In that case, the COND_EXPR\n-\t\t  is probably the best choice, so leave it alone.  */\n-\t       && type == TREE_TYPE (arg0))\n-\treturn arg0;\n-      else if (integer_zerop (arg1) && integer_onep (TREE_OPERAND (t, 2)))\n-\treturn convert (type, invert_truthvalue (arg0));\n-\n-      /* If we have (a >= 0 ? a : -a) or the same with \">\", this is an\n-\t absolute value expression.  */\n \n-      if ((TREE_CODE (arg0) == GE_EXPR || TREE_CODE (arg0) == GT_EXPR)\n-\t  && integer_zerop (TREE_OPERAND (arg0, 1))\n-\t  && TREE_CODE (TREE_OPERAND (t, 2)) == NEGATE_EXPR\n-\t  && operand_equal_p (TREE_OPERAND (arg0, 0), arg1, 0)\n-\t  && operand_equal_p (TREE_OPERAND (TREE_OPERAND (t, 2), 0), arg1, 0))\n-\treturn fold (build1 (ABS_EXPR, type, arg1));\n+      /* If the second operand is zero, invert the comparison and swap\n+\t the second and third operands.  Likewise if the second operand\n+\t is constant and the third is not or if the third operand is\n+\t equivalent to the first operand of the comparison.  */\n \n-      /* Similarly for (a <= 0 ? -a : a).  */\n+      if (integer_zerop (arg1)\n+\t  || (TREE_CONSTANT (arg1) && ! TREE_CONSTANT (TREE_OPERAND (t, 2)))\n+\t  || (TREE_CODE_CLASS (TREE_CODE (arg0)) == '<'\n+\t      && operand_equal_for_comparison_p (TREE_OPERAND (arg0, 0),\n+\t\t\t\t\t\t TREE_OPERAND (t, 2),\n+\t\t\t\t\t\t TREE_OPERAND (arg0, 1))))\n+\t{\n+\t  /* See if this can be inverted.  If it can't, possibly because\n+\t     it was a floating-point inequality comparison, don't do\n+\t     anything.  */\n+\t  tem = invert_truthvalue (arg0);\n \n-      if ((TREE_CODE (arg0) == LE_EXPR || TREE_CODE (arg0) == LT_EXPR)\n-\t  && integer_zerop (TREE_OPERAND (arg0, 1))\n-\t  && TREE_CODE (arg1) == NEGATE_EXPR\n-\t  && operand_equal_p (TREE_OPERAND (arg0, 0), TREE_OPERAND (t, 2), 0)\n-\t  && operand_equal_p (TREE_OPERAND (arg1, 0), TREE_OPERAND (t, 2), 0))\n-\treturn fold (build1 (ABS_EXPR, type, TREE_OPERAND (t, 2)));\n+\t  if (TREE_CODE (tem) != TRUTH_NOT_EXPR)\n+\t    {\n+\t      arg0 = TREE_OPERAND (t, 0) = tem;\n+\t      TREE_OPERAND (t, 1) = TREE_OPERAND (t, 2);\n+\t      TREE_OPERAND (t, 2) = arg1;\n+\t      arg1 = TREE_OPERAND (t, 1);\n+\t    }\n+\t}\n \n-      /* If we have a GT, GE, LT, or LE comparison, this might be a MIN or\n-\t MAX test.  If so, make a MIN_EXPR or MAX_EXPR.  */\n+      /* If we have A op B ? A : C, we may be able to convert this to a\n+\t simpler expression, depending on the operation and the values\n+\t of B and C.  */\n \n-      if (TREE_CODE (arg0) == GT_EXPR || TREE_CODE (arg0) == GE_EXPR\n-\t  || TREE_CODE (arg0) == LT_EXPR || TREE_CODE (arg0) == LE_EXPR)\n+      if (TREE_CODE_CLASS (TREE_CODE (arg0)) == '<'\n+\t  && operand_equal_for_comparison_p (TREE_OPERAND (arg0, 0),\n+\t\t\t\t\t     arg1, TREE_OPERAND (arg0, 1)))\n \t{\n-\t  tree hi_true, lo_true;\n+\t  tree arg2 = TREE_OPERAND (t, 2);\n+\t  enum tree_code comp_code = TREE_CODE (arg0);\n+\n+\t  /* If we have A op 0 ? A : -A, this is A, -A, abs (A), or abs (-A),\n+\t     depending on the comparison operation.  */\n+\t  if (integer_zerop (TREE_OPERAND (arg0, 1))\n+\t      && TREE_CODE (arg2) == NEGATE_EXPR\n+\t      && operand_equal_p (TREE_OPERAND (arg2, 0), arg1, 0))\n+\t    switch (comp_code)\n+\t      {\n+\t      case EQ_EXPR:\n+\t\treturn fold (build1 (NEGATE_EXPR, type, arg1));\n+\t      case NE_EXPR:\n+\t\treturn arg1;\n+\t      case GE_EXPR:\n+\t      case GT_EXPR:\n+\t\treturn fold (build1 (ABS_EXPR, type, arg1));\n+\t      case LE_EXPR:\n+\t      case LT_EXPR:\n+\t\treturn fold (build1 (NEGATE_EXPR, type,\n+\t\t\t\t     fold (build1 (ABS_EXPR, type, arg1))));\n+\t      }\n \n-\t  if (TREE_CODE (arg0) == GT_EXPR || TREE_CODE (arg0) == GE_EXPR)\n-\t    hi_true = TREE_OPERAND (arg0, 0), lo_true = TREE_OPERAND (arg0, 1);\n-\t  else\n-\t    hi_true = TREE_OPERAND (arg0, 1), lo_true = TREE_OPERAND (arg0, 0);\n+\t  /* If this is A != 0 ? A : 0, this is simply A.  For ==, it is\n+\t     always zero.  */\n \n-\t  if (comparison_equiv_p (hi_true, lo_true, arg1, TREE_OPERAND (t, 2)))\n-\t    /* We use arg1 and the other arg because they must have the same\n-\t       type as the intended result.\n-\t       The values being compared might have a narrower type.  */\n-\t    return fold (build (MAX_EXPR, type, arg1, TREE_OPERAND (t, 2)));\n-\t  else if (comparison_equiv_p (lo_true, hi_true,\n-\t\t\t\t       arg1, TREE_OPERAND (t, 2)))\n-\t    return fold (build (MIN_EXPR, type, arg1, TREE_OPERAND (t, 2)));\n+\t  if (integer_zerop (arg2))\n+\t    {\n+\t      if (comp_code == NE_EXPR)\n+\t\treturn arg1;\n+\t      else if (comp_code == EQ_EXPR)\n+\t\treturn convert (type, integer_zero_node);\n+\t    }\n+\n+\t  /* If this is A op B ? A : B, this is either A, B, min (A, B),\n+\t     or max (A, B), depending on the operation.  */\n+\n+\t  if (operand_equal_for_comparison_p (TREE_OPERAND (arg0, 1),\n+\t\t\t\t\t      arg2, TREE_OPERAND (arg0, 0)))\n+\t    switch (comp_code)\n+\t      {\n+\t      case EQ_EXPR:\n+\t\treturn arg2;\n+\t      case NE_EXPR:\n+\t\treturn arg1;\n+\t      case LE_EXPR:\n+\t      case LT_EXPR:\n+\t\treturn fold (build (MIN_EXPR, type, arg1, arg2));\n+\t      case GE_EXPR:\n+\t      case GT_EXPR:\n+\t\treturn fold (build (MAX_EXPR, type, arg1, arg2));\n+\t      }\n+\n+\t  /* If this is A op C1 ? A : C2 with C1 and C2 constant integers,\n+\t     we might still be able to simplify this.  For example,\n+\t     if C1 is one less or one more than C2, this might have started\n+\t     out as a MIN or MAX and been transformed by this function.  */\n+\n+\t  if (TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST\n+\t      && TREE_CODE (arg2) == INTEGER_CST)\n+\t    switch (comp_code)\n+\t      {\n+\t      case EQ_EXPR:\n+\t\t/* We can replace A with C1 in this case.  */\n+\t\targ1 = TREE_OPERAND (t, 1)\n+\t\t  = convert (type, TREE_OPERAND (arg0, 1));\n+\t\tbreak;\n+\n+\t      case LT_EXPR:\n+\t\t/* If C1 is C2 + 1, this is min(A, C2).  */\n+\t\tif (! operand_equal_p (arg2, TYPE_MAX_VALUE (type), 1)\n+\t\t    && operand_equal_p (TREE_OPERAND (arg0, 1),\n+\t\t\t\t\tconst_binop (PLUS_EXPR, arg2,\n+\t\t\t\t\t\t     integer_one_node), 1))\n+\t\t  return fold (build (MIN_EXPR, type, arg1, arg2));\n+\t\tbreak;\n+\n+\t      case LE_EXPR:\n+\t\t/* If C1 is C2 - 1, this is min(A, C2).  */\n+\t\tif (! operand_equal_p (arg2, TYPE_MIN_VALUE (type), 1)\n+\t\t    && operand_equal_p (TREE_OPERAND (arg0, 1),\n+\t\t\t\t\tconst_binop (MINUS_EXPR, arg2,\n+\t\t\t\t\t\t     integer_one_node), 1))\n+\t\t  return fold (build (MIN_EXPR, type, arg1, arg2));\n+\t\tbreak;\n+\n+\t      case GT_EXPR:\n+\t\t/* If C1 is C2 - 1, this is max(A, C2).  */\n+\t\tif (! operand_equal_p (arg2, TYPE_MIN_VALUE (type), 1)\n+\t\t    && operand_equal_p (TREE_OPERAND (arg0, 1),\n+\t\t\t\t\tconst_binop (MINUS_EXPR, arg2,\n+\t\t\t\t\t\t     integer_one_node), 1))\n+\t\t  return fold (build (MAX_EXPR, type, arg1, arg2));\n+\t\tbreak;\n+\n+\t      case GE_EXPR:\n+\t\t/* If C1 is C2 + 1, this is max(A, C2).  */\n+\t\tif (! operand_equal_p (arg2, TYPE_MAX_VALUE (type), 1)\n+\t\t    && operand_equal_p (TREE_OPERAND (arg0, 1),\n+\t\t\t\t\tconst_binop (PLUS_EXPR, arg2,\n+\t\t\t\t\t\t     integer_one_node), 1))\n+\t\t  return fold (build (MAX_EXPR, type, arg1, arg2));\n+\t\tbreak;\n+\t      }\n \t}\n \n-      /* Look for cases when we are comparing some expression A for equality\n-\t with zero and the result is to be zero if A is zero.  In that case,\n-\t check to see if the value of A is the same as the value to be\n-\t returned when A is non-zero.\n+      /* Convert A ? 1 : 0 to simply A.  */\n+      if (integer_onep (TREE_OPERAND (t, 1))\n+\t  && integer_zerop (TREE_OPERAND (t, 2))\n+\t  /* If we try to convert TREE_OPERAND (t, 0) to our type, the\n+\t     call to fold will try to move the conversion inside \n+\t     a COND, which will recurse.  In that case, the COND_EXPR\n+\t     is probably the best choice, so leave it alone.  */\n+\t  && type == TREE_TYPE (arg0))\n+\treturn arg0;\n \n-\t There are two cases:  One is where we have (A ? A : 0) and the\n-\t other is when a single bit is tested (e.g., A & 2 ? 2 : 0).\n-\t In these cases, the result of the conditional is simply A. \n \n-\t Start by setting ARG1 to be the true value and ARG0 to be the thing\n-\t compared with zero.  Then check for the two cases above.  */\n+      /* Look for expressions of the form A & 2 ? 2 : 0.  The result of this\n+\t operation is simply A & 2.  */\n \n       if (integer_zerop (TREE_OPERAND (t, 2))\n \t  && TREE_CODE (arg0) == NE_EXPR\n \t  && integer_zerop (TREE_OPERAND (arg0, 1))\n-\t  && ! TREE_SIDE_EFFECTS (arg1))\n-\t;\n-      else if (integer_zerop (arg1)\n-\t       && TREE_CODE (arg0) == EQ_EXPR\n-\t       && integer_zerop (TREE_OPERAND (arg0, 1))\n-\t       && ! TREE_SIDE_EFFECTS (TREE_OPERAND (t, 2)))\n-\targ1 = TREE_OPERAND (t, 2);\n-      else\n-\treturn t;\n+\t  && integer_pow2p (arg1)\n+\t  && TREE_CODE (TREE_OPERAND (arg0, 0)) == BIT_AND_EXPR\n+\t  && operand_equal_p (TREE_OPERAND (TREE_OPERAND (arg0, 0), 1),\n+\t\t\t      arg1, 1))\n+\treturn convert (type, TREE_OPERAND (arg0, 0));\n \n-      arg0 = TREE_OPERAND (arg0, 0);\n-\n-      STRIP_NOPS (arg1);\n-      if (operand_equal_p (arg0, arg1, 0)\n-\t  || (TREE_CODE (arg1) == INTEGER_CST\n-\t      && integer_pow2p (arg1)\n-\t      && TREE_CODE (arg0) == BIT_AND_EXPR\n-\t      && operand_equal_p (TREE_OPERAND (arg0, 1), arg1, 0)))\n-\treturn convert (type, arg0);\n       return t;\n \n     case COMPOUND_EXPR:"}]}