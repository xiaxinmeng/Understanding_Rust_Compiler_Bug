{"sha": "6576d245386e2ce52df274ef8f2ffed81cfaa1c3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjU3NmQyNDUzODZlMmNlNTJkZjI3NGVmOGYyZmZlZDgxY2ZhYTFjMw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-09-09T17:59:06Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-09-09T17:59:06Z"}, "message": "Remove COPY_HARD_REG_SET\n\nThis patch replaces \"COPY_HARD_REG_SET (x, y)\" with \"x = y\".\n\n2019-09-09  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* hard-reg-set.h (COPY_HARD_REG_SET): Delete.\n\t* caller-save.c (save_call_clobbered_regs): Use assignment instead\n\tof COPY_HARD_REG_SET.\n\t* config/epiphany/epiphany.c (epiphany_compute_frame_size): Likewise.\n\t(epiphany_conditional_register_usage): Likewise.\n\t* config/frv/frv.c (frv_ifcvt_modify_tests): Likewise.\n\t* config/gcn/gcn.c (gcn_md_reorg): Likewise.\n\t* config/ia64/ia64.c (ia64_compute_frame_size): Likewise.\n\t* config/m32c/m32c.c (m32c_register_move_cost): Likewise.\n\t* config/m68k/m68k.c (m68k_conditional_register_usage): Likewise.\n\t* config/mips/mips.c (mips_class_max_nregs): Likewise.\n\t* config/pdp11/pdp11.c (pdp11_conditional_register_usage): Likewise.\n\t* config/rs6000/rs6000.c (rs6000_register_move_cost): Likewise.\n\t* config/sh/sh.c (output_stack_adjust): Likewise.\n\t* final.c (collect_fn_hard_reg_usage): Likewise.\n\t(get_call_reg_set_usage): Likewise.\n\t* ira-build.c (ira_create_object, remove_low_level_allocnos)\n\t(ira_flattening): Likewise.\n\t* ira-color.c (add_allocno_hard_regs, add_allocno_hard_regs_to_forest)\n\t(setup_left_conflict_sizes_p, setup_profitable_hard_regs)\n\t(get_conflict_and_start_profitable_regs, allocno_reload_assign)\n\t(ira_reassign_pseudos): Likewise.\n\t* ira-conflicts.c (print_allocno_conflicts): Likewise.\n\t(ira_build_conflicts): Likewise.\n\t* ira-costs.c (restrict_cost_classes): Likewise.\n\t(setup_regno_cost_classes_by_aclass): Likewise.\n\t* ira.c (setup_class_hard_regs, setup_alloc_regs): Likewise.\n\t(setup_reg_subclasses, setup_class_subset_and_memory_move_costs)\n\t(setup_stack_reg_pressure_class, setup_pressure_classes)\n\t(setup_allocno_and_important_classes, setup_class_translate_array)\n\t(setup_reg_class_relations, setup_prohibited_class_mode_regs)\n\t(ira_setup_eliminable_regset): Likewise.\n\t* lra-assigns.c (find_hard_regno_for_1): Likewise.\n\t(setup_live_pseudos_and_spill_after_risky_transforms): Likewise.\n\t* lra-constraints.c (prohibited_class_reg_set_mode_p): Likewise.\n\t(process_alt_operands, inherit_in_ebb): Likewise.\n\t* lra-lives.c (process_bb_lives): Likewise.\n\t* lra-spills.c (assign_spill_hard_regs): Likewise.\n\t* lra.c (lra): Likewise.\n\t* mode-switching.c (new_seginfo): Likewise.\n\t* postreload.c (reload_combine): Likewise.\n\t* reg-stack.c (straighten_stack): Likewise.\n\t* reginfo.c (save_register_info, restore_register_info): Likewise.\n\t(init_reg_sets_1, record_subregs_of_mode): Likewise\n\t* regrename.c (create_new_chain, rename_chains): Likewise.\n\t* reload1.c (order_regs_for_reload, find_reg): Likewise.\n\t(find_reload_regs): Likewise.\n\t* resource.c (find_dead_or_set_registers): Likewise.\n\t(mark_target_live_regs): Likewise.\n\t* sel-sched.c (mark_unavailable_hard_regs): Likewise.\n\nFrom-SVN: r275528", "tree": {"sha": "3eae615cce59ebe35b4a188e8056c91a2d85dbca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3eae615cce59ebe35b4a188e8056c91a2d85dbca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6576d245386e2ce52df274ef8f2ffed81cfaa1c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6576d245386e2ce52df274ef8f2ffed81cfaa1c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6576d245386e2ce52df274ef8f2ffed81cfaa1c3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e8448ba5300e32917fb12f877ae40711c2b452a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8448ba5300e32917fb12f877ae40711c2b452a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8448ba5300e32917fb12f877ae40711c2b452a3"}], "stats": {"total": 320, "additions": 175, "deletions": 145}, "files": [{"sha": "a3238884c46d490fbe952643a08cd6cff079e637", "filename": "gcc/ChangeLog", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6576d245386e2ce52df274ef8f2ffed81cfaa1c3", "patch": "@@ -1,3 +1,56 @@\n+2019-09-09  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* hard-reg-set.h (COPY_HARD_REG_SET): Delete.\n+\t* caller-save.c (save_call_clobbered_regs): Use assignment instead\n+\tof COPY_HARD_REG_SET.\n+\t* config/epiphany/epiphany.c (epiphany_compute_frame_size): Likewise.\n+\t(epiphany_conditional_register_usage): Likewise.\n+\t* config/frv/frv.c (frv_ifcvt_modify_tests): Likewise.\n+\t* config/gcn/gcn.c (gcn_md_reorg): Likewise.\n+\t* config/ia64/ia64.c (ia64_compute_frame_size): Likewise.\n+\t* config/m32c/m32c.c (m32c_register_move_cost): Likewise.\n+\t* config/m68k/m68k.c (m68k_conditional_register_usage): Likewise.\n+\t* config/mips/mips.c (mips_class_max_nregs): Likewise.\n+\t* config/pdp11/pdp11.c (pdp11_conditional_register_usage): Likewise.\n+\t* config/rs6000/rs6000.c (rs6000_register_move_cost): Likewise.\n+\t* config/sh/sh.c (output_stack_adjust): Likewise.\n+\t* final.c (collect_fn_hard_reg_usage): Likewise.\n+\t(get_call_reg_set_usage): Likewise.\n+\t* ira-build.c (ira_create_object, remove_low_level_allocnos)\n+\t(ira_flattening): Likewise.\n+\t* ira-color.c (add_allocno_hard_regs, add_allocno_hard_regs_to_forest)\n+\t(setup_left_conflict_sizes_p, setup_profitable_hard_regs)\n+\t(get_conflict_and_start_profitable_regs, allocno_reload_assign)\n+\t(ira_reassign_pseudos): Likewise.\n+\t* ira-conflicts.c (print_allocno_conflicts): Likewise.\n+\t(ira_build_conflicts): Likewise.\n+\t* ira-costs.c (restrict_cost_classes): Likewise.\n+\t(setup_regno_cost_classes_by_aclass): Likewise.\n+\t* ira.c (setup_class_hard_regs, setup_alloc_regs): Likewise.\n+\t(setup_reg_subclasses, setup_class_subset_and_memory_move_costs)\n+\t(setup_stack_reg_pressure_class, setup_pressure_classes)\n+\t(setup_allocno_and_important_classes, setup_class_translate_array)\n+\t(setup_reg_class_relations, setup_prohibited_class_mode_regs)\n+\t(ira_setup_eliminable_regset): Likewise.\n+\t* lra-assigns.c (find_hard_regno_for_1): Likewise.\n+\t(setup_live_pseudos_and_spill_after_risky_transforms): Likewise.\n+\t* lra-constraints.c (prohibited_class_reg_set_mode_p): Likewise.\n+\t(process_alt_operands, inherit_in_ebb): Likewise.\n+\t* lra-lives.c (process_bb_lives): Likewise.\n+\t* lra-spills.c (assign_spill_hard_regs): Likewise.\n+\t* lra.c (lra): Likewise.\n+\t* mode-switching.c (new_seginfo): Likewise.\n+\t* postreload.c (reload_combine): Likewise.\n+\t* reg-stack.c (straighten_stack): Likewise.\n+\t* reginfo.c (save_register_info, restore_register_info): Likewise.\n+\t(init_reg_sets_1, record_subregs_of_mode): Likewise\n+\t* regrename.c (create_new_chain, rename_chains): Likewise.\n+\t* reload1.c (order_regs_for_reload, find_reg): Likewise.\n+\t(find_reload_regs): Likewise.\n+\t* resource.c (find_dead_or_set_registers): Likewise.\n+\t(mark_target_live_regs): Likewise.\n+\t* sel-sched.c (mark_unavailable_hard_regs): Likewise.\n+\n 2019-09-09  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* rtl.h (CALL_INSN_FUNCTION_USAGE): Document what SETs mean."}, {"sha": "03a9b333bdc0f4dc8603848fd677ff2dde1d2d25", "filename": "gcc/caller-save.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=6576d245386e2ce52df274ef8f2ffed81cfaa1c3", "patch": "@@ -775,7 +775,7 @@ save_call_clobbered_regs (void)\n \n \t      if (code == JUMP_INSN)\n \t\t/* Restore all registers if this is a JUMP_INSN.  */\n-\t\tCOPY_HARD_REG_SET (referenced_regs, hard_regs_saved);\n+\t\treferenced_regs = hard_regs_saved;\n \t      else\n \t\t{\n \t\t  CLEAR_HARD_REG_SET (referenced_regs);"}, {"sha": "c2e321580e2867e365e6a208651f663bb816e9c1", "filename": "gcc/config/epiphany/epiphany.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2Fconfig%2Fepiphany%2Fepiphany.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2Fconfig%2Fepiphany%2Fepiphany.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fepiphany%2Fepiphany.c?ref=6576d245386e2ce52df274ef8f2ffed81cfaa1c3", "patch": "@@ -1248,7 +1248,7 @@ epiphany_compute_frame_size (int size /* # of var. bytes allocated.  */)\n   current_frame_info.var_size     = var_size;\n   current_frame_info.args_size    = args_size;\n   current_frame_info.reg_size\t  = reg_size;\n-  COPY_HARD_REG_SET (current_frame_info.gmask, gmask);\n+  current_frame_info.gmask\t  = gmask;\n   current_frame_info.first_slot\t\t= first_slot;\n   current_frame_info.last_slot\t\t= last_slot;\n   current_frame_info.first_slot_offset\t= first_slot_offset;\n@@ -2240,8 +2240,7 @@ epiphany_conditional_register_usage (void)\n     }\n   if (!TARGET_PREFER_SHORT_INSN_REGS)\n     CLEAR_HARD_REG_SET (reg_class_contents[SHORT_INSN_REGS]);\n-  COPY_HARD_REG_SET (reg_class_contents[SIBCALL_REGS],\n-\t\t     reg_class_contents[GENERAL_REGS]);\n+  reg_class_contents[SIBCALL_REGS] = reg_class_contents[GENERAL_REGS];\n   /* It would be simpler and quicker if we could just use\n      AND_COMPL_HARD_REG_SET, alas, call_used_reg_set is yet uninitialized;\n      it is set up later by our caller.  */"}, {"sha": "7fc8068b6e4185bcb836bfb10e0ce29045dda4bb", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=6576d245386e2ce52df274ef8f2ffed81cfaa1c3", "patch": "@@ -5201,7 +5201,7 @@ frv_ifcvt_modify_tests (ce_if_block *ce_info, rtx *p_true, rtx *p_false)\n      not fixed.  However, allow the ICC/ICR temporary registers to be allocated\n      if we did not need to use them in reloading other registers.  */\n   memset (&tmp_reg->regs, 0, sizeof (tmp_reg->regs));\n-  COPY_HARD_REG_SET (tmp_reg->regs, call_used_reg_set);\n+  tmp_reg->regs = call_used_reg_set;\n   AND_COMPL_HARD_REG_SET (tmp_reg->regs, fixed_reg_set);\n   SET_HARD_REG_BIT (tmp_reg->regs, ICC_TEMP);\n   SET_HARD_REG_BIT (tmp_reg->regs, ICR_TEMP);"}, {"sha": "548ab178170152c6d90e6900fe14ebf10a45104a", "filename": "gcc/config/gcn/gcn.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2Fconfig%2Fgcn%2Fgcn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2Fconfig%2Fgcn%2Fgcn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn.c?ref=6576d245386e2ce52df274ef8f2ffed81cfaa1c3", "patch": "@@ -4553,7 +4553,7 @@ gcn_md_reorg (void)\n \t      && gcn_vmem_insn_p (itype))\n \t    {\n \t      HARD_REG_SET regs;\n-\t      COPY_HARD_REG_SET (regs, prev_insn->writes);\n+\t      regs = prev_insn->writes;\n \t      AND_HARD_REG_SET (regs, ireads);\n \t      if (hard_reg_set_intersect_p\n \t\t  (regs, reg_class_contents[(int) SGPR_REGS]))\n@@ -4583,7 +4583,7 @@ gcn_md_reorg (void)\n \t      && get_attr_laneselect (insn) == LANESELECT_YES)\n \t    {\n \t      HARD_REG_SET regs;\n-\t      COPY_HARD_REG_SET (regs, prev_insn->writes);\n+\t      regs = prev_insn->writes;\n \t      AND_HARD_REG_SET (regs, ireads);\n \t      if (hard_reg_set_intersect_p\n \t\t  (regs, reg_class_contents[(int) SGPR_REGS])\n@@ -4599,7 +4599,7 @@ gcn_md_reorg (void)\n \t      && itype == TYPE_VOP_DPP)\n \t    {\n \t      HARD_REG_SET regs;\n-\t      COPY_HARD_REG_SET (regs, prev_insn->writes);\n+\t      regs = prev_insn->writes;\n \t      AND_HARD_REG_SET (regs, ireads);\n \t      if (hard_reg_set_intersect_p\n \t\t  (regs, reg_class_contents[(int) VGPR_REGS]))\n@@ -4641,8 +4641,8 @@ gcn_md_reorg (void)\n       back[oldest].insn = insn;\n       back[oldest].unit = iunit;\n       back[oldest].delayeduse = idelayeduse;\n-      COPY_HARD_REG_SET (back[oldest].writes, iwrites);\n-      COPY_HARD_REG_SET (back[oldest].reads, ireads);\n+      back[oldest].writes = iwrites;\n+      back[oldest].reads = ireads;\n       back[oldest].age = 0;\n       oldest = (oldest + 1) % max_waits;\n "}, {"sha": "ca69656f45c5341f175a903a807a596eed5832cf", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=6576d245386e2ce52df274ef8f2ffed81cfaa1c3", "patch": "@@ -2965,7 +2965,7 @@ ia64_compute_frame_size (HOST_WIDE_INT size)\n   current_frame_info.spill_cfa_off = pretend_args_size - 16;\n   current_frame_info.spill_size = spill_size;\n   current_frame_info.extra_spill_size = extra_spill_size;\n-  COPY_HARD_REG_SET (current_frame_info.mask, mask);\n+  current_frame_info.mask = mask;\n   current_frame_info.n_spilled = n_spilled;\n   current_frame_info.initialized = reload_completed;\n }"}, {"sha": "4e1828789e937bfebe7f03827aee82e1404bac1c", "filename": "gcc/config/m32c/m32c.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2Fconfig%2Fm32c%2Fm32c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2Fconfig%2Fm32c%2Fm32c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.c?ref=6576d245386e2ce52df274ef8f2ffed81cfaa1c3", "patch": "@@ -2152,7 +2152,7 @@ m32c_register_move_cost (machine_mode mode, reg_class_t from,\n   HARD_REG_SET cc;\n \n /* FIXME: pick real values, but not 2 for now.  */\n-  COPY_HARD_REG_SET (cc, reg_class_contents[(int) from]);\n+  cc = reg_class_contents[from];\n   IOR_HARD_REG_SET (cc, reg_class_contents[(int) to]);\n \n   if (mode == QImode"}, {"sha": "fd69511ce70f551dcd7c83310fa3ccb28a2931f9", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=6576d245386e2ce52df274ef8f2ffed81cfaa1c3", "patch": "@@ -6555,7 +6555,7 @@ m68k_conditional_register_usage (void)\n   HARD_REG_SET x;\n   if (!TARGET_HARD_FLOAT)\n     {\n-      COPY_HARD_REG_SET (x, reg_class_contents[(int)FP_REGS]);\n+      x = reg_class_contents[FP_REGS];\n       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n         if (TEST_HARD_REG_BIT (x, i))\n \t  fixed_regs[i] = call_used_regs[i] = 1;"}, {"sha": "7150a79a981771d0206989f809be9cdc0c27f101", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=6576d245386e2ce52df274ef8f2ffed81cfaa1c3", "patch": "@@ -12975,7 +12975,7 @@ mips_class_max_nregs (enum reg_class rclass, machine_mode mode)\n   HARD_REG_SET left;\n \n   size = 0x8000;\n-  COPY_HARD_REG_SET (left, reg_class_contents[(int) rclass]);\n+  left = reg_class_contents[rclass];\n   if (hard_reg_set_intersect_p (left, reg_class_contents[(int) ST_REGS]))\n     {\n       if (mips_hard_regno_mode_ok (ST_REG_FIRST, mode))"}, {"sha": "2d3b94ba9ef83cc458e35e9a2167194afe076e91", "filename": "gcc/config/pdp11/pdp11.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.c?ref=6576d245386e2ce52df274ef8f2ffed81cfaa1c3", "patch": "@@ -2213,7 +2213,7 @@ pdp11_conditional_register_usage (void)\n   HARD_REG_SET x;\n   if (!TARGET_FPU)\n     {\n-      COPY_HARD_REG_SET (x, reg_class_contents[(int)FPU_REGS]);\n+      x = reg_class_contents[FPU_REGS];\n       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++ )\n        if (TEST_HARD_REG_BIT (x, i))\n \tfixed_regs[i] = call_used_regs[i] = 1;"}, {"sha": "8193c6beb2bc9f60bc4732842620252c2b27643d", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=6576d245386e2ce52df274ef8f2ffed81cfaa1c3", "patch": "@@ -21107,9 +21107,9 @@ rs6000_register_move_cost (machine_mode mode,\n      Do this first so we give best-case answers for union classes\n      containing both gprs and vsx regs.  */\n   HARD_REG_SET to_vsx, from_vsx;\n-  COPY_HARD_REG_SET (to_vsx, reg_class_contents[to]);\n+  to_vsx = reg_class_contents[to];\n   AND_HARD_REG_SET (to_vsx, reg_class_contents[VSX_REGS]);\n-  COPY_HARD_REG_SET (from_vsx, reg_class_contents[from]);\n+  from_vsx = reg_class_contents[from];\n   AND_HARD_REG_SET (from_vsx, reg_class_contents[VSX_REGS]);\n   if (!hard_reg_set_empty_p (to_vsx)\n       && !hard_reg_set_empty_p (from_vsx)"}, {"sha": "d1af58028408dbd001a0a59f351e407e66341847", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=6576d245386e2ce52df274ef8f2ffed81cfaa1c3", "patch": "@@ -6708,7 +6708,7 @@ output_stack_adjust (int size, rtx reg, int epilogue_p,\n \t  if (temp < 0 && ! current_function_interrupt && epilogue_p >= 0)\n \t    {\n \t      HARD_REG_SET temps;\n-\t      COPY_HARD_REG_SET (temps, call_used_reg_set);\n+\t      temps = call_used_reg_set;\n \t      AND_COMPL_HARD_REG_SET (temps, call_fixed_reg_set);\n \t      if (epilogue_p > 0)\n \t\t{\n@@ -6743,7 +6743,7 @@ output_stack_adjust (int size, rtx reg, int epilogue_p,\n \t    {\n \t      HARD_REG_SET temps;\n \n-\t      COPY_HARD_REG_SET (temps, *live_regs_mask);\n+\t      temps = *live_regs_mask;\n \t      CLEAR_HARD_REG_BIT (temps, REGNO (reg));\n \t      temp = scavenge_reg (&temps);\n \t    }"}, {"sha": "252b0b6105bb0781dc814af0a80887936cc70e57", "filename": "gcc/final.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=6576d245386e2ce52df274ef8f2ffed81cfaa1c3", "patch": "@@ -5036,7 +5036,7 @@ collect_fn_hard_reg_usage (void)\n   node = cgraph_node::rtl_info (current_function_decl);\n   gcc_assert (node != NULL);\n \n-  COPY_HARD_REG_SET (node->function_used_regs, function_used_regs);\n+  node->function_used_regs = function_used_regs;\n   node->function_used_regs_valid = 1;\n }\n \n@@ -5090,12 +5090,12 @@ get_call_reg_set_usage (rtx_insn *insn, HARD_REG_SET *reg_set,\n       if (node != NULL\n \t  && node->function_used_regs_valid)\n \t{\n-\t  COPY_HARD_REG_SET (*reg_set, node->function_used_regs);\n+\t  *reg_set = node->function_used_regs;\n \t  AND_HARD_REG_SET (*reg_set, default_set);\n \t  return true;\n \t}\n     }\n-  COPY_HARD_REG_SET (*reg_set, default_set);\n+  *reg_set = default_set;\n   targetm.remove_extra_call_preserved_regs (insn, reg_set);\n   return false;\n }"}, {"sha": "3d6eef22037fef49a0f8c70b857e2c9612962e24", "filename": "gcc/hard-reg-set.h", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2Fhard-reg-set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2Fhard-reg-set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhard-reg-set.h?ref=6576d245386e2ce52df274ef8f2ffed81cfaa1c3", "patch": "@@ -83,10 +83,10 @@ struct hard_reg_set_container\n    CLEAR_HARD_REG_SET and SET_HARD_REG_SET.\n    These take just one argument.\n \n-   Also define macros for copying hard reg sets:\n-   COPY_HARD_REG_SET and COMPL_HARD_REG_SET.\n-   These take two arguments TO and FROM; they read from FROM\n-   and store into TO.  COMPL_HARD_REG_SET complements each bit.\n+   Also define macros for copying the complement of a hard reg set:\n+   COMPL_HARD_REG_SET.\n+   This takes two arguments TO and FROM; it reads from FROM\n+   and stores into TO.\n \n    Also define macros for combining hard reg sets:\n    IOR_HARD_REG_SET and AND_HARD_REG_SET.\n@@ -116,7 +116,6 @@ struct hard_reg_set_container\n #define CLEAR_HARD_REG_SET(TO) ((TO) = HARD_CONST (0))\n #define SET_HARD_REG_SET(TO) ((TO) = ~ HARD_CONST (0))\n \n-#define COPY_HARD_REG_SET(TO, FROM) ((TO) = (FROM))\n #define COMPL_HARD_REG_SET(TO, FROM) ((TO) = ~(FROM))\n \n #define IOR_HARD_REG_SET(TO, FROM) ((TO) |= (FROM))\n@@ -185,12 +184,6 @@ SET_HARD_REG_SET (HARD_REG_SET &set)\n     set.elts[i] = -1;\n }\n \n-inline void\n-COPY_HARD_REG_SET (HARD_REG_SET &to, const_hard_reg_set from)\n-{\n-  to = from;\n-}\n-\n inline void\n COMPL_HARD_REG_SET (HARD_REG_SET &to, const_hard_reg_set from)\n {"}, {"sha": "1fa7a86831175750e67c043b9a177cbf575e2128", "filename": "gcc/ira-build.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2Fira-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2Fira-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-build.c?ref=6576d245386e2ce52df274ef8f2ffed81cfaa1c3", "patch": "@@ -456,8 +456,8 @@ ira_create_object (ira_allocno_t a, int subword)\n   OBJECT_CONFLICT_VEC_P (obj) = false;\n   OBJECT_CONFLICT_ARRAY (obj) = NULL;\n   OBJECT_NUM_CONFLICTS (obj) = 0;\n-  COPY_HARD_REG_SET (OBJECT_CONFLICT_HARD_REGS (obj), ira_no_alloc_regs);\n-  COPY_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj), ira_no_alloc_regs);\n+  OBJECT_CONFLICT_HARD_REGS (obj) = ira_no_alloc_regs;\n+  OBJECT_TOTAL_CONFLICT_HARD_REGS (obj) = ira_no_alloc_regs;\n   IOR_COMPL_HARD_REG_SET (OBJECT_CONFLICT_HARD_REGS (obj),\n \t\t\t  reg_class_contents[aclass]);\n   IOR_COMPL_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj),\n@@ -2569,8 +2569,8 @@ remove_low_level_allocnos (void)\n \t  ALLOCNO_NEXT_REGNO_ALLOCNO (a) = NULL;\n \t  ALLOCNO_CAP_MEMBER (a) = NULL;\n \t  FOR_EACH_ALLOCNO_OBJECT (a, obj, oi)\n-\t    COPY_HARD_REG_SET (OBJECT_CONFLICT_HARD_REGS (obj),\n-\t\t\t       OBJECT_TOTAL_CONFLICT_HARD_REGS (obj));\n+\t    OBJECT_CONFLICT_HARD_REGS (obj)\n+\t      = OBJECT_TOTAL_CONFLICT_HARD_REGS (obj);\n #ifdef STACK_REGS\n \t  if (ALLOCNO_TOTAL_NO_STACK_REG_P (a))\n \t    ALLOCNO_NO_STACK_REG_P (a) = true;\n@@ -3108,8 +3108,8 @@ ira_flattening (int max_regno_before_emit, int ira_max_point_before_emit)\n \t   flattening.  */\n \tcontinue;\n       FOR_EACH_ALLOCNO_OBJECT (a, obj, oi)\n-\tCOPY_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj),\n-\t\t\t   OBJECT_CONFLICT_HARD_REGS (obj));\n+\tOBJECT_TOTAL_CONFLICT_HARD_REGS (obj)\n+\t  = OBJECT_CONFLICT_HARD_REGS (obj);\n #ifdef STACK_REGS\n       ALLOCNO_TOTAL_NO_STACK_REG_P (a) = ALLOCNO_NO_STACK_REG_P (a);\n #endif"}, {"sha": "fab3ce7936f0de1c68d5592cdda2ec6c3284d0d4", "filename": "gcc/ira-color.c", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2Fira-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2Fira-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-color.c?ref=6576d245386e2ce52df274ef8f2ffed81cfaa1c3", "patch": "@@ -261,14 +261,14 @@ add_allocno_hard_regs (HARD_REG_SET set, int64_t cost)\n   allocno_hard_regs_t hv;\n \n   gcc_assert (! hard_reg_set_empty_p (set));\n-  COPY_HARD_REG_SET (temp.set, set);\n+  temp.set = set;\n   if ((hv = find_hard_regs (&temp)) != NULL)\n     hv->cost += cost;\n   else\n     {\n       hv = ((struct allocno_hard_regs *)\n \t    ira_allocate (sizeof (struct allocno_hard_regs)));\n-      COPY_HARD_REG_SET (hv->set, set);\n+      hv->set = set;\n       hv->cost = cost;\n       allocno_hard_regs_vec.safe_push (hv);\n       insert_hard_regs (hv);\n@@ -382,7 +382,7 @@ add_allocno_hard_regs_to_forest (allocno_hard_regs_node_t *roots,\n \thard_regs_node_vec.safe_push (node);\n       else if (hard_reg_set_intersect_p (hv->set, node->hard_regs->set))\n \t{\n-\t  COPY_HARD_REG_SET (temp_set, hv->set);\n+\t  temp_set = hv->set;\n \t  AND_HARD_REG_SET (temp_set, node->hard_regs->set);\n \t  hv2 = add_allocno_hard_regs (temp_set, hv->cost);\n \t  add_allocno_hard_regs_to_forest (&node->first, hv2);\n@@ -833,10 +833,10 @@ setup_left_conflict_sizes_p (ira_allocno_t a)\n   nobj = ALLOCNO_NUM_OBJECTS (a);\n   data = ALLOCNO_COLOR_DATA (a);\n   subnodes = allocno_hard_regs_subnodes + data->hard_regs_subnodes_start;\n-  COPY_HARD_REG_SET (profitable_hard_regs, data->profitable_hard_regs);\n+  profitable_hard_regs = data->profitable_hard_regs;\n   node = data->hard_regs_node;\n   node_preorder_num = node->preorder_num;\n-  COPY_HARD_REG_SET (node_set, node->hard_regs->set);\n+  node_set = node->hard_regs->set;\n   node_check_tick++;\n   for (k = 0; k < nobj; k++)\n     {\n@@ -859,7 +859,7 @@ setup_left_conflict_sizes_p (ira_allocno_t a)\n \t\t\t\t\t     ->profitable_hard_regs))\n \t    continue;\n \t  conflict_node = conflict_data->hard_regs_node;\n-\t  COPY_HARD_REG_SET (conflict_node_set, conflict_node->hard_regs->set);\n+\t  conflict_node_set = conflict_node->hard_regs->set;\n \t  if (hard_reg_set_subset_p (node_set, conflict_node_set))\n \t    temp_node = node;\n \t  else\n@@ -897,7 +897,7 @@ setup_left_conflict_sizes_p (ira_allocno_t a)\n \t  int j, n, hard_regno;\n \t  enum reg_class aclass;\n \t  \n-\t  COPY_HARD_REG_SET (temp_set, temp_node->hard_regs->set);\n+\t  temp_set = temp_node->hard_regs->set;\n \t  AND_HARD_REG_SET (temp_set, profitable_hard_regs);\n \t  aclass = ALLOCNO_CLASS (a);\n \t  for (n = 0, j = ira_class_hard_regs_num[aclass] - 1; j >= 0; j--)\n@@ -1042,8 +1042,8 @@ setup_profitable_hard_regs (void)\n       else\n \t{\n \t  mode = ALLOCNO_MODE (a);\n-\t  COPY_HARD_REG_SET (data->profitable_hard_regs,\n-\t\t\t     ira_useful_class_mode_regs[aclass][mode]);\n+\t  data->profitable_hard_regs\n+\t    = ira_useful_class_mode_regs[aclass][mode];\n \t  nobj = ALLOCNO_NUM_OBJECTS (a);\n \t  for (k = 0; k < nobj; k++)\n \t    {\n@@ -1589,20 +1589,17 @@ get_conflict_and_start_profitable_regs (ira_allocno_t a, bool retry_p,\n   for (i = 0; i < nwords; i++)\n     {\n       obj = ALLOCNO_OBJECT (a, i);\n-      COPY_HARD_REG_SET (conflict_regs[i],\n-\t\t\t OBJECT_TOTAL_CONFLICT_HARD_REGS (obj));\n+      conflict_regs[i] = OBJECT_TOTAL_CONFLICT_HARD_REGS (obj);\n     }\n   if (retry_p)\n     {\n-      COPY_HARD_REG_SET (*start_profitable_regs,\n-\t\t\t reg_class_contents[ALLOCNO_CLASS (a)]);\n+      *start_profitable_regs = reg_class_contents[ALLOCNO_CLASS (a)];\n       AND_COMPL_HARD_REG_SET (*start_profitable_regs,\n \t\t\t      ira_prohibited_class_mode_regs\n \t\t\t      [ALLOCNO_CLASS (a)][ALLOCNO_MODE (a)]);\n     }\n   else\n-    COPY_HARD_REG_SET (*start_profitable_regs,\n-\t\t       ALLOCNO_COLOR_DATA (a)->profitable_hard_regs);\n+    *start_profitable_regs = ALLOCNO_COLOR_DATA (a)->profitable_hard_regs;\n }\n \n /* Return true if HARD_REGNO is ok for assigning to allocno A with\n@@ -4387,7 +4384,7 @@ allocno_reload_assign (ira_allocno_t a, HARD_REG_SET forbidden_regs)\n   for (i = 0; i < n; i++)\n     {\n       ira_object_t obj = ALLOCNO_OBJECT (a, i);\n-      COPY_HARD_REG_SET (saved[i], OBJECT_TOTAL_CONFLICT_HARD_REGS (obj));\n+      saved[i] = OBJECT_TOTAL_CONFLICT_HARD_REGS (obj);\n       IOR_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj), forbidden_regs);\n       if (! flag_caller_saves && ALLOCNO_CALLS_CROSSED_NUM (a) != 0)\n \tIOR_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj),\n@@ -4434,7 +4431,7 @@ allocno_reload_assign (ira_allocno_t a, HARD_REG_SET forbidden_regs)\n   for (i = 0; i < n; i++)\n     {\n       ira_object_t obj = ALLOCNO_OBJECT (a, i);\n-      COPY_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj), saved[i]);\n+      OBJECT_TOTAL_CONFLICT_HARD_REGS (obj) = saved[i];\n     }\n   return reg_renumber[regno] >= 0;\n }\n@@ -4519,7 +4516,7 @@ ira_reassign_pseudos (int *spilled_pseudo_regs, int num,\n   for (i = 0; i < num; i++)\n     {\n       regno = spilled_pseudo_regs[i];\n-      COPY_HARD_REG_SET (forbidden_regs, bad_spill_regs);\n+      forbidden_regs = bad_spill_regs;\n       IOR_HARD_REG_SET (forbidden_regs, pseudo_forbidden_regs[regno]);\n       IOR_HARD_REG_SET (forbidden_regs, pseudo_previous_regs[regno]);\n       gcc_assert (reg_renumber[regno] < 0);"}, {"sha": "670e5260c7ade74a08f8922fee02ee1930ef3d9d", "filename": "gcc/ira-conflicts.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2Fira-conflicts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2Fira-conflicts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-conflicts.c?ref=6576d245386e2ce52df274ef8f2ffed81cfaa1c3", "patch": "@@ -660,14 +660,14 @@ print_allocno_conflicts (FILE * file, bool reg_p, ira_allocno_t a)\n \t      putc (')', file);\n \t    }\n \t}\n-      COPY_HARD_REG_SET (conflicting_hard_regs, OBJECT_TOTAL_CONFLICT_HARD_REGS (obj));\n+      conflicting_hard_regs = OBJECT_TOTAL_CONFLICT_HARD_REGS (obj);\n       AND_COMPL_HARD_REG_SET (conflicting_hard_regs, ira_no_alloc_regs);\n       AND_HARD_REG_SET (conflicting_hard_regs,\n \t\t\treg_class_contents[ALLOCNO_CLASS (a)]);\n       print_hard_reg_set (file, \"\\n;;     total conflict hard regs:\",\n \t\t\t  conflicting_hard_regs);\n \n-      COPY_HARD_REG_SET (conflicting_hard_regs, OBJECT_CONFLICT_HARD_REGS (obj));\n+      conflicting_hard_regs = OBJECT_CONFLICT_HARD_REGS (obj);\n       AND_COMPL_HARD_REG_SET (conflicting_hard_regs, ira_no_alloc_regs);\n       AND_HARD_REG_SET (conflicting_hard_regs,\n \t\t\treg_class_contents[ALLOCNO_CLASS (a)]);\n@@ -741,7 +741,7 @@ ira_build_conflicts (void)\n     CLEAR_HARD_REG_SET (temp_hard_reg_set);\n   else\n     {\n-      COPY_HARD_REG_SET (temp_hard_reg_set, reg_class_contents[base]);\n+      temp_hard_reg_set = reg_class_contents[base];\n       AND_COMPL_HARD_REG_SET (temp_hard_reg_set, ira_no_alloc_regs);\n       AND_HARD_REG_SET (temp_hard_reg_set, call_used_reg_set);\n     }"}, {"sha": "f721c64ff7f5e9c41c2b20ae83cd6df7599d3b97", "filename": "gcc/ira-costs.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2Fira-costs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2Fira-costs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-costs.c?ref=6576d245386e2ce52df274ef8f2ffed81cfaa1c3", "patch": "@@ -255,7 +255,7 @@ restrict_cost_classes (cost_classes_t full, machine_mode mode,\n       /* Calculate the set of registers in CL that belong to REGS and\n \t are valid for MODE.  */\n       HARD_REG_SET valid_for_cl;\n-      COPY_HARD_REG_SET (valid_for_cl, reg_class_contents[cl]);\n+      valid_for_cl = reg_class_contents[cl];\n       AND_HARD_REG_SET (valid_for_cl, regs);\n       AND_COMPL_HARD_REG_SET (valid_for_cl,\n \t\t\t      ira_prohibited_class_mode_regs[cl][mode]);\n@@ -343,7 +343,7 @@ setup_regno_cost_classes_by_aclass (int regno, enum reg_class aclass)\n \n   if ((classes_ptr = cost_classes_aclass_cache[aclass]) == NULL)\n     {\n-      COPY_HARD_REG_SET (temp, reg_class_contents[aclass]);\n+      temp = reg_class_contents[aclass];\n       AND_COMPL_HARD_REG_SET (temp, ira_no_alloc_regs);\n       /* We exclude classes from consideration which are subsets of\n \t ACLASS only if ACLASS is an uniform class.  */\n@@ -356,7 +356,7 @@ setup_regno_cost_classes_by_aclass (int regno, enum reg_class aclass)\n \t    {\n \t      /* Exclude non-uniform classes which are subsets of\n \t\t ACLASS.  */\n-\t      COPY_HARD_REG_SET (temp2, reg_class_contents[cl]);\n+\t      temp2 = reg_class_contents[cl];\n \t      AND_COMPL_HARD_REG_SET (temp2, ira_no_alloc_regs);\n \t      if (hard_reg_set_subset_p (temp2, temp) && cl != aclass)\n \t\tcontinue;"}, {"sha": "a2ebbabac369c68fb3e544b3ffe0f35dbb96db42", "filename": "gcc/ira.c", "status": "modified", "additions": 32, "deletions": 38, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=6576d245386e2ce52df274ef8f2ffed81cfaa1c3", "patch": "@@ -471,7 +471,7 @@ setup_class_hard_regs (void)\n   ira_assert (SHRT_MAX >= FIRST_PSEUDO_REGISTER);\n   for (cl = (int) N_REG_CLASSES - 1; cl >= 0; cl--)\n     {\n-      COPY_HARD_REG_SET (temp_hard_regset, reg_class_contents[cl]);\n+      temp_hard_regset = reg_class_contents[cl];\n       AND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n       CLEAR_HARD_REG_SET (processed_hard_reg_set);\n       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n@@ -514,7 +514,7 @@ setup_alloc_regs (bool use_hard_frame_p)\n #ifdef ADJUST_REG_ALLOC_ORDER\n   ADJUST_REG_ALLOC_ORDER;\n #endif\n-  COPY_HARD_REG_SET (no_unit_alloc_regs, fixed_nonglobal_reg_set);\n+  no_unit_alloc_regs = fixed_nonglobal_reg_set;\n   if (! use_hard_frame_p)\n     SET_HARD_REG_BIT (no_unit_alloc_regs, HARD_FRAME_POINTER_REGNUM);\n   setup_class_hard_regs ();\n@@ -541,7 +541,7 @@ setup_reg_subclasses (void)\n       if (i == (int) NO_REGS)\n \tcontinue;\n \n-      COPY_HARD_REG_SET (temp_hard_regset, reg_class_contents[i]);\n+      temp_hard_regset = reg_class_contents[i];\n       AND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n       if (hard_reg_set_empty_p (temp_hard_regset))\n \tcontinue;\n@@ -550,7 +550,7 @@ setup_reg_subclasses (void)\n \t  {\n \t    enum reg_class *p;\n \n-\t    COPY_HARD_REG_SET (temp_hard_regset2, reg_class_contents[j]);\n+\t    temp_hard_regset2 = reg_class_contents[j];\n \t    AND_COMPL_HARD_REG_SET (temp_hard_regset2, no_unit_alloc_regs);\n \t    if (! hard_reg_set_subset_p (temp_hard_regset,\n \t\t\t\t\t temp_hard_regset2))\n@@ -605,9 +605,9 @@ setup_class_subset_and_memory_move_costs (void)\n   for (cl = (int) N_REG_CLASSES - 1; cl >= 0; cl--)\n     for (cl2 = (int) N_REG_CLASSES - 1; cl2 >= 0; cl2--)\n       {\n-\tCOPY_HARD_REG_SET (temp_hard_regset, reg_class_contents[cl]);\n+\ttemp_hard_regset = reg_class_contents[cl];\n \tAND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n-\tCOPY_HARD_REG_SET (temp_hard_regset2, reg_class_contents[cl2]);\n+\ttemp_hard_regset2 = reg_class_contents[cl2];\n \tAND_COMPL_HARD_REG_SET (temp_hard_regset2, no_unit_alloc_regs);\n \tira_class_subset_p[cl][cl2]\n \t  = hard_reg_set_subset_p (temp_hard_regset, temp_hard_regset2);\n@@ -757,7 +757,7 @@ setup_stack_reg_pressure_class (void)\n     for (i = 0; i < ira_pressure_classes_num; i++)\n       {\n \tcl = ira_pressure_classes[i];\n-\tCOPY_HARD_REG_SET (temp_hard_regset2, temp_hard_regset);\n+\ttemp_hard_regset2 = temp_hard_regset;\n \tAND_HARD_REG_SET (temp_hard_regset2, reg_class_contents[cl]);\n \tsize = hard_reg_set_size (temp_hard_regset2);\n \tif (best < size)\n@@ -816,7 +816,7 @@ setup_pressure_classes (void)\n \t\t register pressure class.  */\n \t      for (m = 0; m < NUM_MACHINE_MODES; m++)\n \t\t{\n-\t\t  COPY_HARD_REG_SET (temp_hard_regset, reg_class_contents[cl]);\n+\t\t  temp_hard_regset = reg_class_contents[cl];\n \t\t  AND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n \t\t  AND_COMPL_HARD_REG_SET (temp_hard_regset,\n \t\t\t\t\t  ira_prohibited_class_mode_regs[cl][m]);\n@@ -833,7 +833,7 @@ setup_pressure_classes (void)\n \t    }\n \t  curr = 0;\n \t  insert_p = true;\n-\t  COPY_HARD_REG_SET (temp_hard_regset, reg_class_contents[cl]);\n+\t  temp_hard_regset = reg_class_contents[cl];\n \t  AND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n \t  /* Remove so far added pressure classes which are subset of the\n \t     current candidate class.  Prefer GENERAL_REGS as a pressure\n@@ -845,7 +845,7 @@ setup_pressure_classes (void)\n \t  for (i = 0; i < n; i++)\n \t    {\n \t      cl2 = pressure_classes[i];\n-\t      COPY_HARD_REG_SET (temp_hard_regset2, reg_class_contents[cl2]);\n+\t      temp_hard_regset2 = reg_class_contents[cl2];\n \t      AND_COMPL_HARD_REG_SET (temp_hard_regset2, no_unit_alloc_regs);\n \t      if (hard_reg_set_subset_p (temp_hard_regset, temp_hard_regset2)\n \t\t  && (! hard_reg_set_equal_p (temp_hard_regset,\n@@ -882,7 +882,7 @@ setup_pressure_classes (void)\n        registers available for the allocation.  */\n     CLEAR_HARD_REG_SET (temp_hard_regset);\n     CLEAR_HARD_REG_SET (temp_hard_regset2);\n-    COPY_HARD_REG_SET (ignore_hard_regs, no_unit_alloc_regs);\n+    ignore_hard_regs = no_unit_alloc_regs;\n     for (cl = 0; cl < LIM_REG_CLASSES; cl++)\n       {\n \t/* For some targets (like MIPS with MD_REGS), there are some\n@@ -1001,12 +1001,12 @@ setup_allocno_and_important_classes (void)\n      same set of hard registers.  */\n   for (i = 0; i < LIM_REG_CLASSES; i++)\n     {\n-      COPY_HARD_REG_SET (temp_hard_regset, reg_class_contents[i]);\n+      temp_hard_regset = reg_class_contents[i];\n       AND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n       for (j = 0; j < n; j++)\n \t{\n \t  cl = classes[j];\n-\t  COPY_HARD_REG_SET (temp_hard_regset2, reg_class_contents[cl]);\n+\t  temp_hard_regset2 = reg_class_contents[cl];\n \t  AND_COMPL_HARD_REG_SET (temp_hard_regset2,\n \t\t\t\t  no_unit_alloc_regs);\n \t  if (hard_reg_set_equal_p (temp_hard_regset,\n@@ -1037,13 +1037,12 @@ setup_allocno_and_important_classes (void)\n   for (cl = 0; cl < N_REG_CLASSES; cl++)\n     if (ira_class_hard_regs_num[cl] > 0)\n       {\n-\tCOPY_HARD_REG_SET (temp_hard_regset, reg_class_contents[cl]);\n+\ttemp_hard_regset = reg_class_contents[cl];\n \tAND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n \tset_p = false;\n \tfor (j = 0; j < ira_allocno_classes_num; j++)\n \t  {\n-\t    COPY_HARD_REG_SET (temp_hard_regset2,\n-\t\t\t       reg_class_contents[ira_allocno_classes[j]]);\n+\t    temp_hard_regset2 = reg_class_contents[ira_allocno_classes[j]];\n \t    AND_COMPL_HARD_REG_SET (temp_hard_regset2, no_unit_alloc_regs);\n \t    if ((enum reg_class) cl == ira_allocno_classes[j])\n \t      break;\n@@ -1118,8 +1117,7 @@ setup_class_translate_array (enum reg_class *class_translate,\n       for (i = 0; i < classes_num; i++)\n \t{\n \t  aclass = classes[i];\n-\t  COPY_HARD_REG_SET (temp_hard_regset,\n-\t\t\t     reg_class_contents[aclass]);\n+\t  temp_hard_regset = reg_class_contents[aclass];\n \t  AND_HARD_REG_SET (temp_hard_regset, reg_class_contents[cl]);\n \t  AND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n \t  if (! hard_reg_set_empty_p (temp_hard_regset))\n@@ -1223,9 +1221,9 @@ setup_reg_class_relations (void)\n \t  ira_reg_classes_intersect_p[cl1][cl2] = false;\n \t  ira_reg_class_intersect[cl1][cl2] = NO_REGS;\n \t  ira_reg_class_subset[cl1][cl2] = NO_REGS;\n-\t  COPY_HARD_REG_SET (temp_hard_regset, reg_class_contents[cl1]);\n+\t  temp_hard_regset = reg_class_contents[cl1];\n \t  AND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n-\t  COPY_HARD_REG_SET (temp_set2, reg_class_contents[cl2]);\n+\t  temp_set2 = reg_class_contents[cl2];\n \t  AND_COMPL_HARD_REG_SET (temp_set2, no_unit_alloc_regs);\n \t  if (hard_reg_set_empty_p (temp_hard_regset)\n \t      && hard_reg_set_empty_p (temp_set2))\n@@ -1264,15 +1262,15 @@ setup_reg_class_relations (void)\n \t    }\n \t  ira_reg_class_subunion[cl1][cl2] = NO_REGS;\n \t  ira_reg_class_superunion[cl1][cl2] = NO_REGS;\n-\t  COPY_HARD_REG_SET (intersection_set, reg_class_contents[cl1]);\n+\t  intersection_set = reg_class_contents[cl1];\n \t  AND_HARD_REG_SET (intersection_set, reg_class_contents[cl2]);\n \t  AND_COMPL_HARD_REG_SET (intersection_set, no_unit_alloc_regs);\n-\t  COPY_HARD_REG_SET (union_set, reg_class_contents[cl1]);\n+\t  union_set = reg_class_contents[cl1];\n \t  IOR_HARD_REG_SET (union_set, reg_class_contents[cl2]);\n \t  AND_COMPL_HARD_REG_SET (union_set, no_unit_alloc_regs);\n \t  for (cl3 = 0; cl3 < N_REG_CLASSES; cl3++)\n \t    {\n-\t      COPY_HARD_REG_SET (temp_hard_regset, reg_class_contents[cl3]);\n+\t      temp_hard_regset = reg_class_contents[cl3];\n \t      AND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n \t      if (hard_reg_set_subset_p (temp_hard_regset, intersection_set))\n \t\t{\n@@ -1281,10 +1279,9 @@ setup_reg_class_relations (void)\n \t\t     of CL1 and CL2.  */\n \t\t  if (important_class_p[cl3])\n \t\t    {\n-\t\t      COPY_HARD_REG_SET\n-\t\t\t(temp_set2,\n-\t\t\t reg_class_contents\n-\t\t\t [(int) ira_reg_class_intersect[cl1][cl2]]);\n+\t\t      temp_set2\n+\t\t\t= (reg_class_contents\n+\t\t\t   [ira_reg_class_intersect[cl1][cl2]]);\n \t\t      AND_COMPL_HARD_REG_SET (temp_set2, no_unit_alloc_regs);\n \t\t      if (! hard_reg_set_subset_p (temp_hard_regset, temp_set2)\n \t\t\t  /* If the allocatable hard register sets are\n@@ -1302,9 +1299,8 @@ setup_reg_class_relations (void)\n \t\t\t\t\t   ira_reg_class_intersect[cl1][cl2]])))))\n \t\t\tira_reg_class_intersect[cl1][cl2] = (enum reg_class) cl3;\n \t\t    }\n-\t\t  COPY_HARD_REG_SET\n-\t\t    (temp_set2,\n-\t\t     reg_class_contents[(int) ira_reg_class_subset[cl1][cl2]]);\n+\t\t  temp_set2\n+\t\t    = reg_class_contents[ira_reg_class_subset[cl1][cl2]];\n \t\t  AND_COMPL_HARD_REG_SET (temp_set2, no_unit_alloc_regs);\n \t\t  if (! hard_reg_set_subset_p (temp_hard_regset, temp_set2)\n \t\t      /* Ignore unavailable hard registers and prefer\n@@ -1322,9 +1318,8 @@ setup_reg_class_relations (void)\n \t\t  /* CL3 allocatable hard register set is inside of\n \t\t     union of allocatable hard register sets of CL1\n \t\t     and CL2.  */\n-\t\t  COPY_HARD_REG_SET\n-\t\t    (temp_set2,\n-\t\t     reg_class_contents[(int) ira_reg_class_subunion[cl1][cl2]]);\n+\t\t  temp_set2\n+\t\t    = reg_class_contents[ira_reg_class_subunion[cl1][cl2]];\n \t\t  AND_COMPL_HARD_REG_SET (temp_set2, no_unit_alloc_regs);\n \t \t  if (ira_reg_class_subunion[cl1][cl2] == NO_REGS\n \t\t      || (hard_reg_set_subset_p (temp_set2, temp_hard_regset)\n@@ -1347,9 +1342,8 @@ setup_reg_class_relations (void)\n \t\t  /* CL3 allocatable hard register set contains union\n \t\t     of allocatable hard register sets of CL1 and\n \t\t     CL2.  */\n-\t\t  COPY_HARD_REG_SET\n-\t\t    (temp_set2,\n-\t\t     reg_class_contents[(int) ira_reg_class_superunion[cl1][cl2]]);\n+\t\t  temp_set2\n+\t\t    = reg_class_contents[ira_reg_class_superunion[cl1][cl2]];\n \t\t  AND_COMPL_HARD_REG_SET (temp_set2, no_unit_alloc_regs);\n \t \t  if (ira_reg_class_superunion[cl1][cl2] == NO_REGS\n \t\t      || (hard_reg_set_subset_p (temp_hard_regset, temp_set2)\n@@ -1499,7 +1493,7 @@ setup_prohibited_class_mode_regs (void)\n \n   for (cl = (int) N_REG_CLASSES - 1; cl >= 0; cl--)\n     {\n-      COPY_HARD_REG_SET (temp_hard_regset, reg_class_contents[cl]);\n+      temp_hard_regset = reg_class_contents[cl];\n       AND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n       for (j = 0; j < NUM_MACHINE_MODES; j++)\n \t{\n@@ -2305,7 +2299,7 @@ ira_setup_eliminable_regset (void)\n   if (frame_pointer_needed)\n     df_set_regs_ever_live (HARD_FRAME_POINTER_REGNUM, true);\n     \n-  COPY_HARD_REG_SET (ira_no_alloc_regs, no_unit_alloc_regs);\n+  ira_no_alloc_regs = no_unit_alloc_regs;\n   CLEAR_HARD_REG_SET (eliminable_regset);\n \n   compute_regs_asm_clobbered ();"}, {"sha": "d5268c36ee6e35252f8f08fefacf77e24627fcdf", "filename": "gcc/lra-assigns.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2Flra-assigns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2Flra-assigns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-assigns.c?ref=6576d245386e2ce52df274ef8f2ffed81cfaa1c3", "patch": "@@ -493,7 +493,7 @@ find_hard_regno_for_1 (int regno, int *cost, int try_only_hard_regno,\n   HARD_REG_SET impossible_start_hard_regs, available_regs;\n \n   if (hard_reg_set_empty_p (regno_set))\n-    COPY_HARD_REG_SET (conflict_set, lra_no_alloc_regs);\n+    conflict_set = lra_no_alloc_regs;\n   else\n     {\n       COMPL_HARD_REG_SET (conflict_set, regno_set);\n@@ -622,7 +622,7 @@ find_hard_regno_for_1 (int regno, int *cost, int try_only_hard_regno,\n   biggest_nregs = hard_regno_nregs (hard_regno, biggest_mode);\n   nregs_diff = (biggest_nregs\n \t\t- hard_regno_nregs (hard_regno, PSEUDO_REGNO_MODE (regno)));\n-  COPY_HARD_REG_SET (available_regs, reg_class_contents[rclass]);\n+  available_regs = reg_class_contents[rclass];\n   AND_COMPL_HARD_REG_SET (available_regs, lra_no_alloc_regs);\n   for (i = 0; i < rclass_size; i++)\n     {\n@@ -1217,7 +1217,7 @@ setup_live_pseudos_and_spill_after_risky_transforms (bitmap\n \t\t  sparseset_set_bit (live_range_hard_reg_pseudos, r2->regno);\n \t    }\n \t}\n-      COPY_HARD_REG_SET (conflict_set, lra_no_alloc_regs);\n+      conflict_set = lra_no_alloc_regs;\n       IOR_HARD_REG_SET (conflict_set, lra_reg_info[regno].conflict_hard_regs);\n       val = lra_reg_info[regno].val;\n       offset = lra_reg_info[regno].offset;"}, {"sha": "9354612906651e14f02f4339dd90b04cb94738ea", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=6576d245386e2ce52df274ef8f2ffed81cfaa1c3", "patch": "@@ -1854,7 +1854,7 @@ prohibited_class_reg_set_mode_p (enum reg_class rclass,\n   HARD_REG_SET temp;\n   \n   lra_assert (hard_reg_set_subset_p (reg_class_contents[rclass], set));\n-  COPY_HARD_REG_SET (temp, set);\n+  temp = set;\n   AND_COMPL_HARD_REG_SET (temp, lra_no_alloc_regs);\n   return (hard_reg_set_subset_p\n \t  (temp, ira_prohibited_class_mode_regs[rclass][mode]));\n@@ -2288,7 +2288,7 @@ process_alt_operands (int only_alternative)\n \t\t       reloads. */\n \t\t    badop = false;\n \t\t    this_alternative = curr_alt[m];\n-\t\t    COPY_HARD_REG_SET (this_alternative_set, curr_alt_set[m]);\n+\t\t    this_alternative_set = curr_alt_set[m];\n \t\t    winreg = this_alternative != NO_REGS;\n \t\t    break;\n \t\t  }\n@@ -2517,8 +2517,7 @@ process_alt_operands (int only_alternative)\n \t\t{\n \t\t  HARD_REG_SET available_regs;\n \t\t  \n-\t\t  COPY_HARD_REG_SET (available_regs,\n-\t\t\t\t     reg_class_contents[this_alternative]);\n+\t\t  available_regs = reg_class_contents[this_alternative];\n \t\t  AND_COMPL_HARD_REG_SET\n \t\t    (available_regs,\n \t\t     ira_prohibited_class_mode_regs[this_alternative][mode]);\n@@ -2888,7 +2887,7 @@ process_alt_operands (int only_alternative)\n \t      goto fail;\n \t    }\n \t  curr_alt[nop] = this_alternative;\n-\t  COPY_HARD_REG_SET (curr_alt_set[nop], this_alternative_set);\n+\t  curr_alt_set[nop] = this_alternative_set;\n \t  curr_alt_win[nop] = this_alternative_win;\n \t  curr_alt_match_win[nop] = this_alternative_match_win;\n \t  curr_alt_offmemok[nop] = this_alternative_offmemok;\n@@ -6246,7 +6245,7 @@ inherit_in_ebb (rtx_insn *head, rtx_insn *tail)\n   bitmap_clear (&invalid_invariant_regs);\n   last_processed_bb = NULL;\n   CLEAR_HARD_REG_SET (potential_reload_hard_regs);\n-  COPY_HARD_REG_SET (live_hard_regs, eliminable_regset);\n+  live_hard_regs = eliminable_regset;\n   IOR_HARD_REG_SET (live_hard_regs, lra_no_alloc_regs);\n   /* We don't process new insns generated in the loop.\t*/\n   for (curr_insn = tail; curr_insn != PREV_INSN (head); curr_insn = prev_insn)"}, {"sha": "44038165d81302832479d8576c58fe2187155521", "filename": "gcc/lra-lives.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2Flra-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2Flra-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-lives.c?ref=6576d245386e2ce52df274ef8f2ffed81cfaa1c3", "patch": "@@ -929,7 +929,7 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n \t{\n \t  call_insn = curr_insn;\n \t  if (! flag_ipa_ra && ! targetm.return_call_with_max_clobbers)\n-\t    COPY_HARD_REG_SET(last_call_used_reg_set, call_used_reg_set);\n+\t    last_call_used_reg_set = call_used_reg_set;\n \t  else\n \t    {\n \t      HARD_REG_SET this_call_used_reg_set;\n@@ -953,7 +953,7 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n \t\t\t\t\t\t      last_call_used_reg_set,\n \t\t\t\t\t\t      last_call_insn);\n \t\t}\n-\t      COPY_HARD_REG_SET(last_call_used_reg_set, this_call_used_reg_set);\n+\t      last_call_used_reg_set = this_call_used_reg_set;\n \t      last_call_insn = call_insn;\n \t    }\n "}, {"sha": "26cb421c81a34c2945685de02c944a2675a63438", "filename": "gcc/lra-spills.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2Flra-spills.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2Flra-spills.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-spills.c?ref=6576d245386e2ce52df274ef8f2ffed81cfaa1c3", "patch": "@@ -243,7 +243,7 @@ assign_spill_hard_regs (int *pseudo_regnos, int n)\n   /* Set up reserved hard regs for every program point.\t */\n   reserved_hard_regs = XNEWVEC (HARD_REG_SET, lra_live_max_point);\n   for (p = 0; p < lra_live_max_point; p++)\n-    COPY_HARD_REG_SET (reserved_hard_regs[p], lra_no_alloc_regs);\n+    reserved_hard_regs[p] = lra_no_alloc_regs;\n   for (i = FIRST_PSEUDO_REGISTER; i < regs_num; i++)\n     if (lra_reg_info[i].nrefs != 0\n \t&& (hard_regno = lra_get_regno_hard_regno (i)) >= 0)\n@@ -274,8 +274,7 @@ assign_spill_hard_regs (int *pseudo_regnos, int n)\n \t  continue;\n \t}\n       lra_assert (spill_class != NO_REGS);\n-      COPY_HARD_REG_SET (conflict_hard_regs,\n-\t\t\t lra_reg_info[regno].conflict_hard_regs);\n+      conflict_hard_regs = lra_reg_info[regno].conflict_hard_regs;\n       for (r = lra_reg_info[regno].live_ranges; r != NULL; r = r->next)\n \tfor (p = r->start; p <= r->finish; p++)\n \t  IOR_HARD_REG_SET (conflict_hard_regs, reserved_hard_regs[p]);"}, {"sha": "886fb10815013256da1da395f2132404de4068f2", "filename": "gcc/lra.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2Flra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2Flra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.c?ref=6576d245386e2ce52df274ef8f2ffed81cfaa1c3", "patch": "@@ -2384,7 +2384,7 @@ lra (FILE *f)\n      need it.  */\n   emit_note (NOTE_INSN_DELETED);\n \n-  COPY_HARD_REG_SET (lra_no_alloc_regs, ira_no_alloc_regs);\n+  lra_no_alloc_regs = ira_no_alloc_regs;\n \n   init_reg_info ();\n   expand_reg_info ();"}, {"sha": "4a34d4a2b7c98f935d1359f63696d37f37c8edcd", "filename": "gcc/mode-switching.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2Fmode-switching.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2Fmode-switching.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmode-switching.c?ref=6576d245386e2ce52df274ef8f2ffed81cfaa1c3", "patch": "@@ -165,7 +165,7 @@ new_seginfo (int mode, rtx_insn *insn, int bb, HARD_REG_SET regs_live)\n   ptr->insn_ptr = insn;\n   ptr->bbnum = bb;\n   ptr->next = NULL;\n-  COPY_HARD_REG_SET (ptr->regs_live, regs_live);\n+  ptr->regs_live = regs_live;\n   return ptr;\n }\n "}, {"sha": "268b75b7777540cf0bf1265742554a5f1365697f", "filename": "gcc/postreload.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=6576d245386e2ce52df274ef8f2ffed81cfaa1c3", "patch": "@@ -1267,7 +1267,7 @@ reload_combine (void)\n \n \t  REG_SET_TO_HARD_REG_SET (live, live_in);\n \t  compute_use_by_pseudos (&live, live_in);\n-\t  COPY_HARD_REG_SET (LABEL_LIVE (insn), live);\n+\t  LABEL_LIVE (insn) = live;\n \t  IOR_HARD_REG_SET (ever_live_at_start, live);\n \t}\n     }"}, {"sha": "19f020acd7e910ff40597befdafbc9304c4d208e", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=6576d245386e2ce52df274ef8f2ffed81cfaa1c3", "patch": "@@ -368,7 +368,7 @@ straighten_stack (rtx_insn *insn, stack_ptr regstack)\n   if (regstack->top <= 0)\n     return;\n \n-  COPY_HARD_REG_SET (temp_stack.reg_set, regstack->reg_set);\n+  temp_stack.reg_set = regstack->reg_set;\n \n   for (top = temp_stack.top = regstack->top; top >= 0; top--)\n     temp_stack.reg[top] = FIRST_STACK_REG + temp_stack.top - top;"}, {"sha": "8268d0df71381abe62f10f9b006b5de8563226eb", "filename": "gcc/reginfo.c", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2Freginfo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2Freginfo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freginfo.c?ref=6576d245386e2ce52df274ef8f2ffed81cfaa1c3", "patch": "@@ -230,8 +230,8 @@ save_register_info (void)\n   /* And similarly for reg_names.  */\n   gcc_assert (sizeof reg_names == sizeof saved_reg_names);\n   memcpy (saved_reg_names, reg_names, sizeof reg_names);\n-  COPY_HARD_REG_SET (saved_accessible_reg_set, accessible_reg_set);\n-  COPY_HARD_REG_SET (saved_operand_reg_set, operand_reg_set);\n+  saved_accessible_reg_set = accessible_reg_set;\n+  saved_operand_reg_set = operand_reg_set;\n }\n \n /* Restore the register information.  */\n@@ -247,8 +247,8 @@ restore_register_info (void)\n #endif\n \n   memcpy (reg_names, saved_reg_names, sizeof reg_names);\n-  COPY_HARD_REG_SET (accessible_reg_set, saved_accessible_reg_set);\n-  COPY_HARD_REG_SET (operand_reg_set, saved_operand_reg_set);\n+  accessible_reg_set = saved_accessible_reg_set;\n+  operand_reg_set = saved_operand_reg_set;\n }\n \n /* After switches have been processed, which perhaps alter\n@@ -298,7 +298,7 @@ init_reg_sets_1 (void)\n \t  HARD_REG_SET c;\n \t  int k;\n \n-\t  COPY_HARD_REG_SET (c, reg_class_contents[i]);\n+\t  c = reg_class_contents[i];\n \t  IOR_HARD_REG_SET (c, reg_class_contents[j]);\n \t  for (k = 0; k < N_REG_CLASSES; k++)\n \t    if (hard_reg_set_subset_p (reg_class_contents[k], c)\n@@ -321,7 +321,7 @@ init_reg_sets_1 (void)\n \t  HARD_REG_SET c;\n \t  int k;\n \n-\t  COPY_HARD_REG_SET (c, reg_class_contents[i]);\n+\t  c = reg_class_contents[i];\n \t  IOR_HARD_REG_SET (c, reg_class_contents[j]);\n \t  for (k = 0; k < N_REG_CLASSES; k++)\n \t    if (hard_reg_set_subset_p (c, reg_class_contents[k]))\n@@ -450,8 +450,8 @@ init_reg_sets_1 (void)\n         }\n     }\n \n-  COPY_HARD_REG_SET (call_fixed_reg_set, fixed_reg_set);\n-  COPY_HARD_REG_SET (fixed_nonglobal_reg_set, fixed_reg_set);\n+  call_fixed_reg_set = fixed_reg_set;\n+  fixed_nonglobal_reg_set = fixed_reg_set;\n \n   /* Preserve global registers if called more than once.  */\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n@@ -1323,8 +1323,7 @@ record_subregs_of_mode (rtx subreg, bool partial_def)\n     {\n       valid_mode_changes[regno]\n \t= XOBNEW (&valid_mode_changes_obstack, HARD_REG_SET);\n-      COPY_HARD_REG_SET (*valid_mode_changes[regno],\n-\t\t\t simplifiable_subregs (shape));\n+      *valid_mode_changes[regno] = simplifiable_subregs (shape);\n     }\n }\n "}, {"sha": "997e884546c9800e35ea7f3e9daca3beaacc11fd", "filename": "gcc/regrename.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=6576d245386e2ce52df274ef8f2ffed81cfaa1c3", "patch": "@@ -253,7 +253,7 @@ create_new_chain (unsigned this_regno, unsigned this_nregs, rtx *loc,\n       CLEAR_HARD_REG_BIT (live_hard_regs, head->regno + nregs);\n     }\n \n-  COPY_HARD_REG_SET (head->hard_conflicts, live_hard_regs);\n+  head->hard_conflicts = live_hard_regs;\n   bitmap_set_bit (&open_chains_set, head->id);\n \n   open_chains = head;\n@@ -486,7 +486,7 @@ rename_chains (void)\n \t      && reg == FRAME_POINTER_REGNUM))\n \tcontinue;\n \n-      COPY_HARD_REG_SET (this_unavailable, unavailable);\n+      this_unavailable = unavailable;\n \n       reg_class super_class = regrename_find_superclass (this_head, &n_uses,\n \t\t\t\t\t\t\t &this_unavailable);"}, {"sha": "cadad5e1ddccbbc9874c0a4d24898a5c140568fb", "filename": "gcc/reload1.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=6576d245386e2ce52df274ef8f2ffed81cfaa1c3", "patch": "@@ -1732,7 +1732,7 @@ order_regs_for_reload (class insn_chain *chain)\n   HARD_REG_SET used_by_pseudos2;\n   reg_set_iterator rsi;\n \n-  COPY_HARD_REG_SET (bad_spill_regs, fixed_reg_set);\n+  bad_spill_regs = fixed_reg_set;\n \n   memset (spill_cost, 0, sizeof spill_cost);\n   memset (spill_add_cost, 0, sizeof spill_add_cost);\n@@ -1823,7 +1823,7 @@ find_reg (class insn_chain *chain, int order)\n   static int regno_pseudo_regs[FIRST_PSEUDO_REGISTER];\n   static int best_regno_pseudo_regs[FIRST_PSEUDO_REGISTER];\n \n-  COPY_HARD_REG_SET (not_usable, bad_spill_regs);\n+  not_usable = bad_spill_regs;\n   IOR_HARD_REG_SET (not_usable, bad_spill_regs_global);\n   IOR_COMPL_HARD_REG_SET (not_usable, reg_class_contents[rl->rclass]);\n \n@@ -2007,7 +2007,7 @@ find_reload_regs (class insn_chain *chain)\n \t  }\n     }\n \n-  COPY_HARD_REG_SET (chain->used_spill_regs, used_spill_regs_local);\n+  chain->used_spill_regs = used_spill_regs_local;\n   IOR_HARD_REG_SET (used_spill_regs, used_spill_regs_local);\n \n   memcpy (chain->rld, rld, n_reloads * sizeof (struct reload));"}, {"sha": "5b738e0fb588c77cad4f820b81f9092870780bfc", "filename": "gcc/resource.c", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=6576d245386e2ce52df274ef8f2ffed81cfaa1c3", "patch": "@@ -565,12 +565,12 @@ find_dead_or_set_registers (rtx_insn *target, struct resources *res,\n \t\t    }\n \n \t\t  target_res = *res;\n-\t\t  COPY_HARD_REG_SET (scratch, target_set.regs);\n+\t\t  scratch = target_set.regs;\n \t\t  AND_COMPL_HARD_REG_SET (scratch, needed.regs);\n \t\t  AND_COMPL_HARD_REG_SET (target_res.regs, scratch);\n \n \t\t  fallthrough_res = *res;\n-\t\t  COPY_HARD_REG_SET (scratch, set.regs);\n+\t\t  scratch = set.regs;\n \t\t  AND_COMPL_HARD_REG_SET (scratch, needed.regs);\n \t\t  AND_COMPL_HARD_REG_SET (fallthrough_res.regs, scratch);\n \n@@ -601,7 +601,7 @@ find_dead_or_set_registers (rtx_insn *target, struct resources *res,\n       mark_referenced_resources (insn, &needed, true);\n       mark_set_resources (insn, &set, 0, MARK_SRC_DEST_CALL);\n \n-      COPY_HARD_REG_SET (scratch, set.regs);\n+      scratch = set.regs;\n       AND_COMPL_HARD_REG_SET (scratch, needed.regs);\n       AND_COMPL_HARD_REG_SET (res->regs, scratch);\n     }\n@@ -960,7 +960,7 @@ mark_target_live_regs (rtx_insn *insns, rtx target_maybe_return, struct resource\n \t     update it below.  */\n \t  if (b == tinfo->block && b != -1 && tinfo->bb_tick == bb_ticks[b])\n \t    {\n-\t      COPY_HARD_REG_SET (res->regs, tinfo->live_regs);\n+\t      res->regs = tinfo->live_regs;\n \t      return;\n \t    }\n \t}\n@@ -1121,7 +1121,7 @@ mark_target_live_regs (rtx_insn *insns, rtx target_maybe_return, struct resource\n \t    IOR_HARD_REG_SET (current_live_regs, start_of_epilogue_needs.regs);\n \t}\n \n-      COPY_HARD_REG_SET (res->regs, current_live_regs);\n+      res->regs = current_live_regs;\n       if (tinfo != NULL)\n \t{\n \t  tinfo->block = b;\n@@ -1160,7 +1160,7 @@ mark_target_live_regs (rtx_insn *insns, rtx target_maybe_return, struct resource\n \t{\n \t  mark_referenced_resources (insn, &needed, true);\n \n-\t  COPY_HARD_REG_SET (scratch, needed.regs);\n+\t  scratch = needed.regs;\n \t  AND_COMPL_HARD_REG_SET (scratch, set.regs);\n \t  IOR_HARD_REG_SET (new_resources.regs, scratch);\n \n@@ -1171,9 +1171,7 @@ mark_target_live_regs (rtx_insn *insns, rtx target_maybe_return, struct resource\n     }\n \n   if (tinfo != NULL)\n-    {\n-      COPY_HARD_REG_SET (tinfo->live_regs, res->regs);\n-    }\n+    tinfo->live_regs = res->regs;\n }\n \f\n /* Initialize the resources required by mark_target_live_regs ()."}, {"sha": "ce2db8161eeabe25800a336574b6c1ce0182a8d4", "filename": "gcc/sel-sched.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2Fsel-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6576d245386e2ce52df274ef8f2ffed81cfaa1c3/gcc%2Fsel-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched.c?ref=6576d245386e2ce52df274ef8f2ffed81cfaa1c3", "patch": "@@ -1238,8 +1238,7 @@ mark_unavailable_hard_regs (def_t def, struct reg_rename *reg_rename_p,\n \n   /* Leave regs as 'available' only from the current\n      register class.  */\n-  COPY_HARD_REG_SET (reg_rename_p->available_for_renaming,\n-                     reg_class_contents[cl]);\n+  reg_rename_p->available_for_renaming = reg_class_contents[cl];\n \n   mode = GET_MODE (orig_dest);\n "}]}