{"sha": "e9e4977ef70562c6d79a089e35e3bb0b8aebf598", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTllNDk3N2VmNzA1NjJjNmQ3OWEwODllMzVlM2JiMGI4YWViZjU5OA==", "commit": {"author": {"name": "Paul Koning", "email": "ni1d@arrl.net", "date": "2010-12-02T19:10:41Z"}, "committer": {"name": "Paul Koning", "email": "pkoning@gcc.gnu.org", "date": "2010-12-02T19:10:41Z"}, "message": "pdp11.c (output_jump): Map unsigned to signed opcodes if CC_NO_OVERFLOW is set.\n\n* config/pdp11/pdp11.c (output_jump): Map unsigned to signed\nopcodes if CC_NO_OVERFLOW is set.\n(notice_update_cc_on_set): Correct setting of CC0 as a side\neffect; set CC_NO_OVERFLOW for cases where C flag is not\nmeaningful.\n\nFrom-SVN: r167383", "tree": {"sha": "6f264a89d8dd189fb1842e5d25a1239e4481c32a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6f264a89d8dd189fb1842e5d25a1239e4481c32a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e9e4977ef70562c6d79a089e35e3bb0b8aebf598", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9e4977ef70562c6d79a089e35e3bb0b8aebf598", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9e4977ef70562c6d79a089e35e3bb0b8aebf598", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9e4977ef70562c6d79a089e35e3bb0b8aebf598/comments", "author": null, "committer": null, "parents": [{"sha": "bec93d73dbbe3632a366dad2062cba051afcb944", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bec93d73dbbe3632a366dad2062cba051afcb944", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bec93d73dbbe3632a366dad2062cba051afcb944"}], "stats": {"total": 99, "additions": 44, "deletions": 55}, "files": [{"sha": "39f3e04831c854c0e0948c96000a3fd8b6bcc585", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e4977ef70562c6d79a089e35e3bb0b8aebf598/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e4977ef70562c6d79a089e35e3bb0b8aebf598/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e9e4977ef70562c6d79a089e35e3bb0b8aebf598", "patch": "@@ -1,3 +1,11 @@\n+2010-12-02  Paul Koning  <ni1d@arrl.net>\n+\n+\t* config/pdp11/pdp11.c (output_jump): Map unsigned to signed\n+\topcodes if CC_NO_OVERFLOW is set.\n+\t(notice_update_cc_on_set): Correct setting of CC0 as a side\n+\teffect; set CC_NO_OVERFLOW for cases where C flag is not\n+\tmeaningful.\n+\n 2010-12-02  Ian Lance Taylor  <iant@google.com>\n \n \t* doc/install.texi (Configuration): Update default for"}, {"sha": "682c7bcea2bf3ecc0c09d70e863d5da2f98e2337", "filename": "gcc/config/pdp11/pdp11.c", "status": "modified", "additions": 36, "deletions": 55, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e4977ef70562c6d79a089e35e3bb0b8aebf598/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e4977ef70562c6d79a089e35e3bb0b8aebf598/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.c?ref=e9e4977ef70562c6d79a089e35e3bb0b8aebf598", "patch": "@@ -1167,6 +1167,17 @@ output_jump (enum rtx_code code, int inv, int length)\n     static char buf[1000];\n     const char *pos, *neg;\n \n+    if (cc_prev_status.flags & CC_NO_OVERFLOW)\n+      {\n+\tswitch (code)\n+\t  {\n+\t  case GTU: code = GT; break;\n+\t  case LTU: code = LT; break;\n+\t  case GEU: code = GE; break;\n+\t  case LEU: code = LE; break;\n+\t  default: ;\n+\t  }\n+      }\n     switch (code)\n       {\n       case EQ: pos = \"beq\", neg = \"bne\"; break;\n@@ -1220,68 +1231,38 @@ notice_update_cc_on_set(rtx exp, rtx insn ATTRIBUTE_UNUSED)\n {\n     if (GET_CODE (SET_DEST (exp)) == CC0)\n     { \n-\tcc_status.flags = 0;\t\t\t\t\t\n-\tcc_status.value1 = SET_DEST (exp);\t\t\t\n-\tcc_status.value2 = SET_SRC (exp);\t\t\t\n-\n-/*\n-\tif (GET_MODE(SET_SRC(exp)) == DFmode)\n-\t    cc_status.flags |= CC_IN_FPU;\n-*/\t\n-    }\t\t\t\t\t\t\t\n-    else if ((GET_CODE (SET_DEST (exp)) == REG\t\t\n-\t      || GET_CODE (SET_DEST (exp)) == MEM)\t\t\n-\t     && GET_CODE (SET_SRC (exp)) != PC\t\t\n-\t     && (GET_MODE (SET_DEST(exp)) == HImode\t\t\n-\t\t || GET_MODE (SET_DEST(exp)) == QImode)\t\n-\t\t&& (GET_CODE (SET_SRC(exp)) == PLUS\t\t\n-\t\t    || GET_CODE (SET_SRC(exp)) == MINUS\t\n-\t\t    || GET_CODE (SET_SRC(exp)) == AND\t\n-\t\t    || GET_CODE (SET_SRC(exp)) == IOR\t\n-\t\t    || GET_CODE (SET_SRC(exp)) == XOR\t\n-\t\t    || GET_CODE (SET_SRC(exp)) == NOT\t\n-\t\t    || GET_CODE (SET_SRC(exp)) == NEG\t\n-\t\t\t|| GET_CODE (SET_SRC(exp)) == REG\t\n-\t\t    || GET_CODE (SET_SRC(exp)) == MEM))\t\n-    { \n-\tcc_status.flags = 0;\t\t\t\t\t\n-\tcc_status.value1 = SET_SRC (exp);   \t\t\t\n-\tcc_status.value2 = SET_DEST (exp);\t\t\t\n-\t\n-\tif (cc_status.value1 && GET_CODE (cc_status.value1) == REG\t\n-\t    && cc_status.value2\t\t\t\t\t\n-\t    && reg_overlap_mentioned_p (cc_status.value1, cc_status.value2))\n-    \t    cc_status.value2 = 0;\t\t\t\t\t\n-\tif (cc_status.value1 && GET_CODE (cc_status.value1) == MEM\t\n-\t    && cc_status.value2\t\t\t\t\t\n-\t    && GET_CODE (cc_status.value2) == MEM)\t\t\t\n-\t    cc_status.value2 = 0; \t\t\t\t\t\n+      cc_status.flags = 0;\t\t\t\t\t\n+      cc_status.value1 = SET_DEST (exp);\t\t\t\n+      cc_status.value2 = SET_SRC (exp);\t\t\t\n     }\t\t\t\t\t\t\t\n     else if (GET_CODE (SET_SRC (exp)) == CALL)\t\t\n     { \n-\tCC_STATUS_INIT; \n+      CC_STATUS_INIT; \n     }\n-    else if (GET_CODE (SET_DEST (exp)) == REG)       \t\t\n-\t/* what's this ? */\t\t\t\t\t\n-    { \n-\tif ((cc_status.value1\t\t\t\t\t\n-\t     && reg_overlap_mentioned_p (SET_DEST (exp), cc_status.value1)))\n-\t    cc_status.value1 = 0;\t\t\t\t\n-\tif ((cc_status.value2\t\t\t\t\t\n-\t     && reg_overlap_mentioned_p (SET_DEST (exp), cc_status.value2)))\n-\t    cc_status.value2 = 0;\t\t\t\t\n-    }\t\t\t\t\t\t\t\n     else if (SET_DEST(exp) == pc_rtx)\n     { \n-\t/* jump */\n-    }\n-    else /* if (GET_CODE (SET_DEST (exp)) == MEM)\t*/\t\n-    {  \n-\t/* the last else is a bit paranoiac, but since nearly all instructions \n-\t   play with condition codes, it's reasonable! */\n-\n-\tCC_STATUS_INIT; /* paranoia*/ \n+      /* jump */\n+    }\t\n+    else if (GET_MODE (SET_DEST(exp)) == HImode\t\t\n+\t     || GET_MODE (SET_DEST(exp)) == QImode)\n+    { \n+      cc_status.flags = GET_CODE (SET_SRC(exp)) == MINUS ? 0 : CC_NO_OVERFLOW;\n+      cc_status.value1 = SET_SRC (exp);   \t\t\t\n+      cc_status.value2 = SET_DEST (exp);\t\t\t\n+\t\n+      if (cc_status.value1 && GET_CODE (cc_status.value1) == REG\t\n+\t  && cc_status.value2\t\t\t\t\t\n+\t  && reg_overlap_mentioned_p (cc_status.value1, cc_status.value2))\n+\tcc_status.value2 = 0;\t\t\t\t\t\n+      if (cc_status.value1 && GET_CODE (cc_status.value1) == MEM\t\n+\t  && cc_status.value2\t\t\t\t\t\n+\t  && GET_CODE (cc_status.value2) == MEM)\t\t\t\n+\tcc_status.value2 = 0; \t\t\t\t\t\n     }\t\t        \n+    else\n+    { \n+      CC_STATUS_INIT; \n+    }\n }\n \n "}]}