{"sha": "8db47d74b34b2a2bb66e12afa6bd4eb50e02099a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGRiNDdkNzRiMzRiMmEyYmI2NmUxMmFmYTZiZDRlYjUwZTAyMDk5YQ==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@codesourcery.com", "date": "2001-02-11T06:39:14Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2001-02-11T06:39:14Z"}, "message": "valarray-inst.cc (gslice::_Indexer::_Indexer): Don't flip lengths and strides.\n\n        * src/valarray-inst.cc (gslice::_Indexer::_Indexer): Don't flip\n        lengths and strides.\n        (__gslice_to_index): Document.\n\nFrom-SVN: r39583", "tree": {"sha": "e6e80e0986c87c6db22a95a331828a982eaa9533", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e6e80e0986c87c6db22a95a331828a982eaa9533"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8db47d74b34b2a2bb66e12afa6bd4eb50e02099a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8db47d74b34b2a2bb66e12afa6bd4eb50e02099a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8db47d74b34b2a2bb66e12afa6bd4eb50e02099a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8db47d74b34b2a2bb66e12afa6bd4eb50e02099a/comments", "author": null, "committer": null, "parents": [{"sha": "7f437481f274a9cc40e2bede53c650330cafc6f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f437481f274a9cc40e2bede53c650330cafc6f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f437481f274a9cc40e2bede53c650330cafc6f2"}], "stats": {"total": 128, "additions": 79, "deletions": 49}, "files": [{"sha": "9605087219214cadb398a68b322cdd68c4ef033d", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8db47d74b34b2a2bb66e12afa6bd4eb50e02099a/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8db47d74b34b2a2bb66e12afa6bd4eb50e02099a/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=8db47d74b34b2a2bb66e12afa6bd4eb50e02099a", "patch": "@@ -1,3 +1,9 @@\n+2001-02-11  Gabriel Dos Reis  <gdr@codesourcery.com>\n+\n+\t* src/valarray-inst.cc (gslice::_Indexer::_Indexer): Don't flip \n+\tlengths and strides.\n+\t(__gslice_to_index): Document.\n+\n 2001-02-11  Gabriel Dos Reis  <gdr@codesourcery.com>\n \n \t* include/bits/char_traits.h char_traits<char>::int_type: Change"}, {"sha": "9950fbadd0bc0d77f467ef3ae952fe5027e869ff", "filename": "libstdc++-v3/src/valarray-inst.cc", "status": "modified", "additions": 73, "deletions": 49, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8db47d74b34b2a2bb66e12afa6bd4eb50e02099a/libstdc%2B%2B-v3%2Fsrc%2Fvalarray-inst.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8db47d74b34b2a2bb66e12afa6bd4eb50e02099a/libstdc%2B%2B-v3%2Fsrc%2Fvalarray-inst.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fvalarray-inst.cc?ref=8db47d74b34b2a2bb66e12afa6bd4eb50e02099a", "patch": "@@ -2,59 +2,83 @@\n \n namespace std\n {\n-    // Some explicit instanciations.\n-    template void\n-    __valarray_fill(size_t* __restrict__, size_t, const size_t&);\n+  // Some explicit instanciations.\n+  template void\n+     __valarray_fill(size_t* __restrict__, size_t, const size_t&);\n+  \n+  template void\n+     __valarray_copy(const size_t* __restrict__, size_t, size_t* __restrict__);\n+  \n+  template valarray<size_t>::valarray(size_t);\n+  template valarray<size_t>::valarray(const valarray<size_t>&);\n+  template valarray<size_t>::~valarray();\n+  template size_t valarray<size_t>::size() const;\n+  template size_t& valarray<size_t>::operator[](size_t);\n \n-    template void\n-    __valarray_copy(const size_t* __restrict__, size_t, size_t* __restrict__);\n \n-    template valarray<size_t>::valarray(size_t);\n-    template valarray<size_t>::valarray(const valarray<size_t>&);\n-    template valarray<size_t>::~valarray();\n-    template size_t valarray<size_t>::size() const;\n-    template size_t& valarray<size_t>::operator[](size_t);\n+  inline size_t\n+  __valarray_product(const valarray<size_t>& __a)\n+  {\n+    typedef const size_t* __restrict__ _Tp;\n+    const size_t __n = __a.size();\n+    // XXX: This ugly cast is necessary because\n+    //      valarray::operator[]() const return a VALUE!\n+    //      Try to get the committee to correct that gross error.\n+    valarray<size_t>& __t = const_cast<valarray<size_t>&>(__a);\n+    return __valarray_product(&__t[0], &__t[0] + __n);\n+  }\n+  \n+  // Map a gslice, described by its multidimensional LENGTHS\n+  // and corresponding STRIDES, to a linear array of INDEXES\n+  // for the purpose of indexing a flat, one-dimensional array\n+  // representation of a gslice_array.\n+  void\n+  __gslice_to_index(size_t __o, const valarray<size_t>& __l,\n+                    const valarray<size_t>& __s, valarray<size_t>& __i)\n+  {\n+    // There are as much as dimensions as there are strides.\n+    size_t __n = __l.size();\n \n+    // Get a buffer to hold current multi-index as we go through\n+    // the gslice for the purpose of computing its linear-image.\n+    size_t* const __t = static_cast<size_t*>\n+      (__builtin_alloca(__n * sizeof (size_t)));\n+    __valarray_fill(__t, __n, size_t(0));\n \n-    inline size_t\n-    __valarray_product(const valarray<size_t>& __a)\n-    {\n-        typedef const size_t* __restrict__ _Tp;\n-        const size_t __n = __a.size();\n-        // XXX: This ugly cast is necessary because\n-        //      valarray::operator[]() const return a VALUE!\n-        //      Try to get the committee to correct that gross error.\n-        valarray<size_t>& __t = const_cast<valarray<size_t>&>(__a);\n-        return __valarray_product(&__t[0], &__t[0] + __n);\n-    }\n+    // Note that this should match the product of all numbers appearing\n+    // in __l which describes the multidimensional sizes of the\n+    // the generalized slice.\n+    const size_t __z = __i.size();\n     \n-    void __gslice_to_index(size_t __o, const valarray<size_t>& __l,\n-                           const valarray<size_t>& __s,\n-                           valarray<size_t>& __i)\n-    {\n-        size_t __n = __l.size();\n-        size_t* const __t = static_cast<size_t*>\n-            (__builtin_alloca(__n*sizeof(size_t)));\n-        __valarray_fill(__t, __n, size_t(0));\n-        const size_t __z = __i.size();\n-        __valarray_fill(&__i[0], __z, __o);\n-        for (size_t __j=0; __j<__z; ++__j) {\n-            for (size_t __k=0; __k<__n; ++__k)\n-                __i[__j] += __s[__k]*__t[__k];\n-            ++__t[__n-1];\n-            for (size_t __k=__n-1; __k; --__k) {\n-                if (__t[__k] >= __l[__k]) {\n-                    __t[__k] = 0;\n-                    ++__t[__k-1];\n-                }\n-            }\n-        }\n-    }\n-    \n-    gslice::_Indexer::_Indexer(size_t __o, const valarray<size_t>& __s,\n-                               const valarray<size_t>& __l)\n-            : _M_count(1), _M_start(__o), _M_size(__s), _M_stride(__l),\n-              _M_index(__l.size() ? __valarray_product(__l) : 0)\n-    { __gslice_to_index(__o, __l, __s, _M_index); }\n+    for (size_t __j = 0; __j < __z; ++__j)\n+      {\n+        // Compute the linear-index image of (t_0, ... t_{n-1}).\n+        // Normaly, we should use inner_product<>(), but we do it the\n+        // the hard way here to avoid link-time can of worms.\n+        size_t __a = __o;\n+        for (size_t __k = 0; __k < __n; ++__k)\n+          __a += __s[__k] * __t[__k];\n+\n+        __i[__j] = __a;\n \n+        // Process the next multi-index.  The loop ought to be\n+        // backward since we're making a lexicagraphical visit.\n+        ++__t[__n-1];\n+        for (size_t __k=__n-1; __k; --__k)\n+          {\n+            if (__t[__k] >= __l[__k])\n+              {\n+                __t[__k] = 0;\n+                ++__t[__k-1];\n+              }\n+          }\n+      }\n+  }\n+  \n+  gslice::_Indexer::_Indexer(size_t __o, const valarray<size_t>& __l,\n+                             const valarray<size_t>& __s)\n+      : _M_count(1), _M_start(__o), _M_size(__l), _M_stride(__s),\n+        _M_index(__l.size() == 0 ? 0 : __valarray_product(__l))\n+  { __gslice_to_index(__o, __l, __s, _M_index); }\n+  \n }"}]}