{"sha": "f8a27aa6319931d0d5317d8cd860e24a607cd442", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjhhMjdhYTYzMTk5MzFkMGQ1MzE3ZDhjZDg2MGUyNGE2MDdjZDQ0Mg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2012-01-24T17:55:29Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2012-01-24T17:55:29Z"}, "message": "atomic: Create and use maybe_emit_atomic_test_and_set.\n\n\t* optabs.c (CODE_FOR_atomic_test_and_set): Provide default.\n\t(maybe_emit_atomic_test_and_set): New.\n\t(expand_sync_lock_test_and_set): Use it.\n\t(expand_atomic_test_and_set): Likewise.\n\t* doc/extend.texi (__atomic_test_and_set): Adjust the docs to match\n\tthe implementation; clarify implementation defined details.\n\t* doc/md.texi (atomic_test_and_set): Document.\n\nFrom-SVN: r183483", "tree": {"sha": "37935401c64c355f48100c4ca42caf17bfd2154e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/37935401c64c355f48100c4ca42caf17bfd2154e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f8a27aa6319931d0d5317d8cd860e24a607cd442", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8a27aa6319931d0d5317d8cd860e24a607cd442", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8a27aa6319931d0d5317d8cd860e24a607cd442", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8a27aa6319931d0d5317d8cd860e24a607cd442/comments", "author": null, "committer": null, "parents": [{"sha": "3b547557aade5a4f4f0d261d508a9b3d32b13a92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b547557aade5a4f4f0d261d508a9b3d32b13a92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b547557aade5a4f4f0d261d508a9b3d32b13a92"}], "stats": {"total": 105, "additions": 79, "deletions": 26}, "files": [{"sha": "9616c2bdfdbdd9174e0e227cb0b77a764cee8a12", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8a27aa6319931d0d5317d8cd860e24a607cd442/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8a27aa6319931d0d5317d8cd860e24a607cd442/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f8a27aa6319931d0d5317d8cd860e24a607cd442", "patch": "@@ -1,3 +1,13 @@\n+2012-01-25  Richard Henderson  <rth@redhat.com>\n+\n+\t* optabs.c (CODE_FOR_atomic_test_and_set): Provide default.\n+\t(maybe_emit_atomic_test_and_set): New.\n+\t(expand_sync_lock_test_and_set): Use it.\n+\t(expand_atomic_test_and_set): Likewise.\n+\t* doc/extend.texi (__atomic_test_and_set): Adjust the docs to match\n+\tthe implementation; clarify implementation defined details.\n+\t* doc/md.texi (atomic_test_and_set): Document.\n+\n 2012-01-25  Richard Henderson  <rth@redhat.com>\n \n \t* config/sparc/predicates.md (zero_or_v7_operand): Use match_code."}, {"sha": "e159736d42034c0dcaf81b4baef71af25dc3ef03", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8a27aa6319931d0d5317d8cd860e24a607cd442/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8a27aa6319931d0d5317d8cd860e24a607cd442/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=f8a27aa6319931d0d5317d8cd860e24a607cd442", "patch": "@@ -7202,11 +7202,12 @@ All memory models are valid.\n \n @end deftypefn\n \n-@deftypefn {Built-in Function} bool __atomic_test_and_set (bool *ptr, int memmodel)\n+@deftypefn {Built-in Function} bool __atomic_test_and_set (void *ptr, int memmodel)\n \n This built-in function performs an atomic test-and-set operation on\n-@code{*@var{ptr}}.  @code{*@var{ptr}} is set to the value 1 and\n-the previous contents are returned.\n+the byte at @code{*@var{ptr}}.  The byte is set to some implementation\n+defined non-zero \"set\" value and the return value is @code{true} if and only\n+if the previous contents were \"set\".\n \n All memory models are valid.\n "}, {"sha": "afdc3e3f3bbf0eb27b8d897899fd57d374e376bd", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8a27aa6319931d0d5317d8cd860e24a607cd442/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8a27aa6319931d0d5317d8cd860e24a607cd442/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=f8a27aa6319931d0d5317d8cd860e24a607cd442", "patch": "@@ -5893,6 +5893,19 @@ the operation followed by the arithmetic operation required to produce the\n result.  If none of these are available a compare-and-swap loop will be\n used.\n \n+@cindex @code{atomic_test_and_set} instruction pattern\n+@item @samp{atomic_test_and_set}\n+\n+This pattern emits code for @code{__builtin_atomic_test_and_set}.\n+Operand 0 is an output operand which is set to true if the previous\n+previous contents of the byte was \"set\", and false otherwise.  Operand 1\n+is the @code{QImode} memory to be modified.  Operand 2 is the memory\n+model to be used.\n+\n+The specific value that defines \"set\" is implementation defined, and\n+is normally based on what is performed by the native atomic test and set\n+instruction.\n+\n @cindex @code{mem_thread_fence@var{mode}} instruction pattern\n @item @samp{mem_thread_fence@var{mode}}\n This pattern emits code required to implement a thread fence with"}, {"sha": "0f6d763e59291ad7d5017d464073c02c33b1c859", "filename": "gcc/optabs.c", "status": "modified", "additions": 52, "deletions": 23, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8a27aa6319931d0d5317d8cd860e24a607cd442/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8a27aa6319931d0d5317d8cd860e24a607cd442/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=f8a27aa6319931d0d5317d8cd860e24a607cd442", "patch": "@@ -7304,11 +7304,41 @@ maybe_emit_compare_and_swap_exchange_loop (rtx target, rtx mem, rtx val)\n   return NULL_RTX;\n }\n \n+/* This function tries to implement an atomic test-and-set operation\n+   using the atomic_test_and_set instruction pattern.  A boolean value\n+   is returned from the operation, using TARGET if possible.  */\n+\n #ifndef HAVE_atomic_test_and_set\n #define HAVE_atomic_test_and_set 0\n+#define CODE_FOR_atomic_test_and_set CODE_FOR_nothing\n #define gen_atomic_test_and_set(x,y,z)  (gcc_unreachable (), NULL_RTX)\n #endif\n \n+static rtx\n+maybe_emit_atomic_test_and_set (rtx target, rtx mem, enum memmodel model)\n+{\n+  enum machine_mode pat_bool_mode;\n+  const struct insn_data_d *id;\n+\n+  if (!HAVE_atomic_test_and_set)\n+    return NULL_RTX;\n+\n+  id = &insn_data[CODE_FOR_atomic_test_and_set];\n+  pat_bool_mode = id->operand[0].mode;\n+\n+  /* ??? We only support test-and-set on single bytes at the moment.\n+     We'd have to change the builtin to allow wider memories.  */\n+  gcc_checking_assert (id->operand[1].mode == QImode);\n+  gcc_checking_assert (GET_MODE (mem) == QImode);\n+\n+  if (target == NULL || GET_MODE (target) != pat_bool_mode)\n+    target = gen_reg_rtx (pat_bool_mode);\n+\n+  emit_insn (gen_atomic_test_and_set (target, mem, GEN_INT (model)));\n+\n+  return target;\n+}\n+\n /* This function expands the legacy _sync_lock test_and_set operation which is\n    generally an atomic exchange.  Some limited targets only allow the\n    constant 1 to be stored.  This is an ACQUIRE operation. \n@@ -7323,20 +7353,21 @@ expand_sync_lock_test_and_set (rtx target, rtx mem, rtx val)\n \n   /* Try an atomic_exchange first.  */\n   ret = maybe_emit_atomic_exchange (target, mem, val, MEMMODEL_ACQUIRE);\n+  if (ret)\n+    return ret;\n \n-  if (!ret)\n-    ret = maybe_emit_sync_lock_test_and_set (target, mem, val,\n-\t\t\t\t\t     MEMMODEL_ACQUIRE);\n-  if (!ret)\n-    ret = maybe_emit_compare_and_swap_exchange_loop (target, mem, val);\n+  ret = maybe_emit_sync_lock_test_and_set (target, mem, val, MEMMODEL_ACQUIRE);\n+  if (ret)\n+    return ret;\n+\n+  ret = maybe_emit_compare_and_swap_exchange_loop (target, mem, val);\n+  if (ret)\n+    return ret;\n \n   /* If there are no other options, try atomic_test_and_set if the value\n      being stored is 1.  */\n-  if (!ret && val == const1_rtx && HAVE_atomic_test_and_set)\n-    {\n-      ret = gen_atomic_test_and_set (target, mem, GEN_INT (MEMMODEL_ACQUIRE));\n-      emit_insn (ret);\n-    }\n+  if (val == const1_rtx)\n+    ret = maybe_emit_atomic_test_and_set (target, mem, MEMMODEL_ACQUIRE);\n \n   return ret;\n }\n@@ -7351,28 +7382,26 @@ rtx\n expand_atomic_test_and_set (rtx target, rtx mem, enum memmodel model)\n {\n   enum machine_mode mode = GET_MODE (mem);\n-  rtx ret = NULL_RTX;\n+  rtx ret;\n+\n+  ret = maybe_emit_atomic_test_and_set (target, mem, model);\n+  if (ret)\n+    return ret;\n \n   if (target == NULL_RTX)\n     target = gen_reg_rtx (mode);\n \n-  if (HAVE_atomic_test_and_set)\n-    {\n-      ret = gen_atomic_test_and_set (target, mem, GEN_INT (MEMMODEL_ACQUIRE));\n-      emit_insn (ret);\n-      return ret;\n-    }\n-\n   /* If there is no test and set, try exchange, then a compare_and_swap loop,\n      then __sync_test_and_set.  */\n   ret = maybe_emit_atomic_exchange (target, mem, const1_rtx, model);\n+  if (ret)\n+    return ret;\n \n-  if (!ret)\n-    ret = maybe_emit_compare_and_swap_exchange_loop (target, mem, const1_rtx);\n-\n-  if (!ret)\n-    ret = maybe_emit_sync_lock_test_and_set (target, mem, const1_rtx, model);\n+  ret = maybe_emit_compare_and_swap_exchange_loop (target, mem, const1_rtx);\n+  if (ret)\n+    return ret;\n \n+  ret = maybe_emit_sync_lock_test_and_set (target, mem, const1_rtx, model);\n   if (ret)\n     return ret;\n "}]}