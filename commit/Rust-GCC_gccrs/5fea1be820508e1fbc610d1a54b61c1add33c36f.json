{"sha": "5fea1be820508e1fbc610d1a54b61c1add33c36f", "node_id": "C_kwDOANBUbNoAKDVmZWExYmU4MjA1MDhlMWZiYzYxMGQxYTU0YjYxYzFhZGQzM2MzNmY", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2023-02-17T20:18:10Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2023-02-17T20:18:10Z"}, "message": "c++: speculative constexpr and is_constant_evaluated [PR108243]\n\nThis PR illustrates that __builtin_is_constant_evaluated currently acts\nas an optimization barrier for our speculative constexpr evaluation,\nsince we don't want to prematurely fold the builtin to false before the\nexpression in question undergoes manifestly constant evaluation if\nappropriate (in which case the builtin must instead be folded to true).\n\nThis patch fixes this by permitting __builtin_is_constant_evaluated to\nget folded as false at appropiate points, namely during cp_fold_function\nand cp_fully_fold_init where we know we're done with manifestly constant\nevaluation.  The function cp_fold gets a flags parameter that controls\nwhether we pass mce_false or mce_unknown to maybe_constant_value when\nfolding a CALL_EXPR.\n\n\tPR c++/108243\n\tPR c++/97553\n\ngcc/cp/ChangeLog:\n\n\t* cp-gimplify.cc (enum fold_flags): Define.\n\t(fold_flags_t): Declare.\n\t(cp_fold_data::genericize): Replace this data member with ...\n\t(cp_fold_data::fold_flags): ... this.\n\t(cp_fold_r): Adjust use of cp_fold_data and calls to cp_fold.\n\t(cp_fold_function): Likewise.\n\t(cp_fold_maybe_rvalue): Add an internal overload that\n\tadditionally takes and propagates a fold_flags_t parameter, and\n\tdefine the existing public overload in terms of it.\n\t(cp_fold_rvalue): Likewise.\n\t(cp_fully_fold_init): Adjust use of cp_fold_data.\n\t(fold_cache): Replace with ...\n\t(fold_caches): ... this 2-element array of caches.\n\t(get_fold_cache): Define.\n\t(clear_fold_cache): Adjust.\n\t(cp_fold): Add fold_flags_t parameter.  Use get_fold_cache.\n\tPass flags to calls to cp_fold, cp_fold_rvalue and\n\tcp_fold_maybe_rvalue.\n\t<case CALL_EXPR>: If ff_mce_false is set, fold\n\t__builtin_is_constant_evaluated to false and pass mce_false to\n\tmaybe_constant_value.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/opt/is_constant_evaluated1.C: New test.\n\t* g++.dg/opt/is_constant_evaluated2.C: New test.", "tree": {"sha": "9f4656a0f48630eed95cba1ae8f3897bd66c6926", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f4656a0f48630eed95cba1ae8f3897bd66c6926"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5fea1be820508e1fbc610d1a54b61c1add33c36f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fea1be820508e1fbc610d1a54b61c1add33c36f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5fea1be820508e1fbc610d1a54b61c1add33c36f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fea1be820508e1fbc610d1a54b61c1add33c36f/comments", "author": null, "committer": null, "parents": [{"sha": "3a0bc47cdb670c8f1e0996e6255ee1084eb7febf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a0bc47cdb670c8f1e0996e6255ee1084eb7febf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a0bc47cdb670c8f1e0996e6255ee1084eb7febf"}], "stats": {"total": 192, "additions": 150, "deletions": 42}, "files": [{"sha": "32fe53521cc59d9877523301ad9861ddb7cc4b24", "filename": "gcc/cp/cp-gimplify.cc", "status": "modified", "additions": 98, "deletions": 42, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fea1be820508e1fbc610d1a54b61c1add33c36f/gcc%2Fcp%2Fcp-gimplify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fea1be820508e1fbc610d1a54b61c1add33c36f/gcc%2Fcp%2Fcp-gimplify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.cc?ref=5fea1be820508e1fbc610d1a54b61c1add33c36f", "patch": "@@ -43,12 +43,26 @@ along with GCC; see the file COPYING3.  If not see\n #include \"omp-general.h\"\n #include \"opts.h\"\n \n+/* Flags for cp_fold and cp_fold_r.  */\n+\n+enum fold_flags {\n+  ff_none = 0,\n+  /* Whether we're being called from cp_fold_function.  */\n+  ff_genericize = 1 << 0,\n+  /* Whether we're folding a point where we know we're\n+     definitely not in a manifestly constant-evaluated\n+     context.  */\n+  ff_mce_false = 1 << 1,\n+};\n+\n+using fold_flags_t = int;\n+\n /* Forward declarations.  */\n \n static tree cp_genericize_r (tree *, int *, void *);\n static tree cp_fold_r (tree *, int *, void *);\n static void cp_genericize_tree (tree*, bool);\n-static tree cp_fold (tree);\n+static tree cp_fold (tree, fold_flags_t);\n \n /* Genericize a TRY_BLOCK.  */\n \n@@ -1012,9 +1026,8 @@ struct cp_genericize_data\n struct cp_fold_data\n {\n   hash_set<tree> pset;\n-  bool genericize; // called from cp_fold_function?\n-\n-  cp_fold_data (bool g): genericize (g) {}\n+  fold_flags_t flags;\n+  cp_fold_data (fold_flags_t flags): flags (flags) {}\n };\n \n static tree\n@@ -1055,7 +1068,7 @@ cp_fold_r (tree *stmt_p, int *walk_subtrees, void *data_)\n       break;\n     }\n \n-  *stmt_p = stmt = cp_fold (*stmt_p);\n+  *stmt_p = stmt = cp_fold (*stmt_p, data->flags);\n \n   if (data->pset.add (stmt))\n     {\n@@ -1135,12 +1148,12 @@ cp_fold_r (tree *stmt_p, int *walk_subtrees, void *data_)\n \t here rather than in cp_genericize to avoid problems with the invisible\n \t reference transition.  */\n     case INIT_EXPR:\n-      if (data->genericize)\n+      if (data->flags & ff_genericize)\n \tcp_genericize_init_expr (stmt_p);\n       break;\n \n     case TARGET_EXPR:\n-      if (data->genericize)\n+      if (data->flags & ff_genericize)\n \tcp_genericize_target_expr (stmt_p);\n \n       /* Folding might replace e.g. a COND_EXPR with a TARGET_EXPR; in\n@@ -1173,7 +1186,10 @@ cp_fold_r (tree *stmt_p, int *walk_subtrees, void *data_)\n void\n cp_fold_function (tree fndecl)\n {\n-  cp_fold_data data (/*genericize*/true);\n+  /* By now all manifestly-constant-evaluated expressions will have\n+     been constant-evaluated already if possible, so we can safely\n+     pass ff_mce_false.  */\n+  cp_fold_data data (ff_genericize | ff_mce_false);\n   cp_walk_tree (&DECL_SAVED_TREE (fndecl), cp_fold_r, &data, NULL);\n }\n \n@@ -2386,12 +2402,12 @@ cxx_omp_disregard_value_expr (tree decl, bool shared)\n \n /* Fold expression X which is used as an rvalue if RVAL is true.  */\n \n-tree\n-cp_fold_maybe_rvalue (tree x, bool rval)\n+static tree\n+cp_fold_maybe_rvalue (tree x, bool rval, fold_flags_t flags)\n {\n   while (true)\n     {\n-      x = cp_fold (x);\n+      x = cp_fold (x, flags);\n       if (rval)\n \tx = mark_rvalue_use (x);\n       if (rval && DECL_P (x)\n@@ -2409,12 +2425,24 @@ cp_fold_maybe_rvalue (tree x, bool rval)\n   return x;\n }\n \n+tree\n+cp_fold_maybe_rvalue (tree x, bool rval)\n+{\n+  return cp_fold_maybe_rvalue (x, rval, ff_none);\n+}\n+\n /* Fold expression X which is used as an rvalue.  */\n \n+static tree\n+cp_fold_rvalue (tree x, fold_flags_t flags)\n+{\n+  return cp_fold_maybe_rvalue (x, true, flags);\n+}\n+\n tree\n cp_fold_rvalue (tree x)\n {\n-  return cp_fold_maybe_rvalue (x, true);\n+  return cp_fold_rvalue (x, ff_none);\n }\n \n /* Perform folding on expression X.  */\n@@ -2450,7 +2478,7 @@ cp_fully_fold_init (tree x)\n   if (processing_template_decl)\n     return x;\n   x = cp_fully_fold (x);\n-  cp_fold_data data (/*genericize*/false);\n+  cp_fold_data data (ff_mce_false);\n   cp_walk_tree (&x, cp_fold_r, &data, NULL);\n   return x;\n }\n@@ -2466,15 +2494,29 @@ c_fully_fold (tree x, bool /*in_init*/, bool */*maybe_const*/, bool lval)\n   return cp_fold_maybe_rvalue (x, !lval);\n }\n \n-static GTY((deletable)) hash_map<tree, tree> *fold_cache;\n+static GTY((deletable)) hash_map<tree, tree> *fold_caches[2];\n+\n+/* Subroutine of cp_fold.  Returns which fold cache to use according\n+   to the given flags.  We need multiple caches since the result of\n+   folding may depend on which flags are used.  */\n+\n+static hash_map<tree, tree> *&\n+get_fold_cache (fold_flags_t flags)\n+{\n+  if (flags & ff_mce_false)\n+    return fold_caches[1];\n+  else\n+    return fold_caches[0];\n+}\n \n /* Dispose of the whole FOLD_CACHE.  */\n \n void\n clear_fold_cache (void)\n {\n-  if (fold_cache != NULL)\n-    fold_cache->empty ();\n+  for (auto& fold_cache : fold_caches)\n+    if (fold_cache != NULL)\n+      fold_cache->empty ();\n }\n \n /*  This function tries to fold an expression X.\n@@ -2485,7 +2527,7 @@ clear_fold_cache (void)\n     Function returns X or its folded variant.  */\n \n static tree\n-cp_fold (tree x)\n+cp_fold (tree x, fold_flags_t flags)\n {\n   tree op0, op1, op2, op3;\n   tree org_x = x, r = NULL_TREE;\n@@ -2503,6 +2545,7 @@ cp_fold (tree x)\n   if (DECL_P (x) || CONSTANT_CLASS_P (x))\n     return x;\n \n+  auto& fold_cache = get_fold_cache (flags);\n   if (fold_cache == NULL)\n     fold_cache = hash_map<tree, tree>::create_ggc (101);\n \n@@ -2517,7 +2560,7 @@ cp_fold (tree x)\n     case CLEANUP_POINT_EXPR:\n       /* Strip CLEANUP_POINT_EXPR if the expression doesn't have side\n \t effects.  */\n-      r = cp_fold_rvalue (TREE_OPERAND (x, 0));\n+      r = cp_fold_rvalue (TREE_OPERAND (x, 0), flags);\n       if (!TREE_SIDE_EFFECTS (r))\n \tx = r;\n       break;\n@@ -2542,14 +2585,14 @@ cp_fold (tree x)\n \t     Don't create a new tree if op0 != TREE_OPERAND (x, 0), the\n \t     folding of the operand should be in the caches and if in cp_fold_r\n \t     it will modify it in place.  */\n-\t  op0 = cp_fold (TREE_OPERAND (x, 0));\n+\t  op0 = cp_fold (TREE_OPERAND (x, 0), flags);\n \t  if (op0 == error_mark_node)\n \t    x = error_mark_node;\n \t  break;\n \t}\n \n       loc = EXPR_LOCATION (x);\n-      op0 = cp_fold_maybe_rvalue (TREE_OPERAND (x, 0), rval_ops);\n+      op0 = cp_fold_maybe_rvalue (TREE_OPERAND (x, 0), rval_ops, flags);\n \n       if (code == CONVERT_EXPR\n \t  && SCALAR_TYPE_P (TREE_TYPE (x))\n@@ -2577,7 +2620,7 @@ cp_fold (tree x)\n       break;\n \n     case EXCESS_PRECISION_EXPR:\n-      op0 = cp_fold_maybe_rvalue (TREE_OPERAND (x, 0), rval_ops);\n+      op0 = cp_fold_maybe_rvalue (TREE_OPERAND (x, 0), rval_ops, flags);\n       x = fold_convert_loc (EXPR_LOCATION (x), TREE_TYPE (x), op0);\n       break;\n \n@@ -2587,13 +2630,13 @@ cp_fold (tree x)\n \t{\n \t  tree p = maybe_undo_parenthesized_ref (x);\n \t  if (p != x)\n-\t    return cp_fold (p);\n+\t    return cp_fold (p, flags);\n \t}\n       goto unary;\n \n     case ADDR_EXPR:\n       loc = EXPR_LOCATION (x);\n-      op0 = cp_fold_maybe_rvalue (TREE_OPERAND (x, 0), false);\n+      op0 = cp_fold_maybe_rvalue (TREE_OPERAND (x, 0), false, flags);\n \n       /* Cope with user tricks that amount to offsetof.  */\n       if (op0 != error_mark_node\n@@ -2630,7 +2673,7 @@ cp_fold (tree x)\n     unary:\n \n       loc = EXPR_LOCATION (x);\n-      op0 = cp_fold_maybe_rvalue (TREE_OPERAND (x, 0), rval_ops);\n+      op0 = cp_fold_maybe_rvalue (TREE_OPERAND (x, 0), rval_ops, flags);\n \n     finish_unary:\n       if (op0 != TREE_OPERAND (x, 0))\n@@ -2657,7 +2700,7 @@ cp_fold (tree x)\n       break;\n \n     case UNARY_PLUS_EXPR:\n-      op0 = cp_fold_rvalue (TREE_OPERAND (x, 0));\n+      op0 = cp_fold_rvalue (TREE_OPERAND (x, 0), flags);\n       if (op0 == error_mark_node)\n \tx = error_mark_node;\n       else\n@@ -2711,8 +2754,8 @@ cp_fold (tree x)\n     case RANGE_EXPR: case COMPLEX_EXPR:\n \n       loc = EXPR_LOCATION (x);\n-      op0 = cp_fold_maybe_rvalue (TREE_OPERAND (x, 0), rval_ops);\n-      op1 = cp_fold_rvalue (TREE_OPERAND (x, 1));\n+      op0 = cp_fold_maybe_rvalue (TREE_OPERAND (x, 0), rval_ops, flags);\n+      op1 = cp_fold_rvalue (TREE_OPERAND (x, 1), flags);\n \n       /* decltype(nullptr) has only one value, so optimize away all comparisons\n \t with that type right away, keeping them in the IL causes troubles for\n@@ -2778,9 +2821,9 @@ cp_fold (tree x)\n     case VEC_COND_EXPR:\n     case COND_EXPR:\n       loc = EXPR_LOCATION (x);\n-      op0 = cp_fold_rvalue (TREE_OPERAND (x, 0));\n-      op1 = cp_fold (TREE_OPERAND (x, 1));\n-      op2 = cp_fold (TREE_OPERAND (x, 2));\n+      op0 = cp_fold_rvalue (TREE_OPERAND (x, 0), flags);\n+      op1 = cp_fold (TREE_OPERAND (x, 1), flags);\n+      op2 = cp_fold (TREE_OPERAND (x, 2), flags);\n \n       if (TREE_CODE (TREE_TYPE (x)) == BOOLEAN_TYPE)\n \t{\n@@ -2870,7 +2913,7 @@ cp_fold (tree x)\n \t      {\n \t\tif (!same_type_p (TREE_TYPE (x), TREE_TYPE (r)))\n \t\t  r = build_nop (TREE_TYPE (x), r);\n-\t\tx = cp_fold (r);\n+\t\tx = cp_fold (r, flags);\n \t\tbreak;\n \t      }\n \t  }\n@@ -2888,10 +2931,15 @@ cp_fold (tree x)\n \n \tif (callee && fndecl_built_in_p (callee, BUILT_IN_FRONTEND))\n \t  {\n+\t    iloc_sentinel ils (EXPR_LOCATION (x));\n \t    switch (DECL_FE_FUNCTION_CODE (callee))\n \t      {\n-\t\t/* Defer folding __builtin_is_constant_evaluated.  */\n \t      case CP_BUILT_IN_IS_CONSTANT_EVALUATED:\n+\t\t/* Defer folding __builtin_is_constant_evaluated unless\n+\t\t   we know this isn't a manifestly constant-evaluated\n+\t\t   context.  */\n+\t\tif (flags & ff_mce_false)\n+\t\t  x = boolean_false_node;\n \t\tbreak;\n \t      case CP_BUILT_IN_SOURCE_LOCATION:\n \t\tx = fold_builtin_source_location (x);\n@@ -2924,7 +2972,7 @@ cp_fold (tree x)\n \tint m = call_expr_nargs (x);\n \tfor (int i = 0; i < m; i++)\n \t  {\n-\t    r = cp_fold (CALL_EXPR_ARG (x, i));\n+\t    r = cp_fold (CALL_EXPR_ARG (x, i), flags);\n \t    if (r != CALL_EXPR_ARG (x, i))\n \t      {\n \t\tif (r == error_mark_node)\n@@ -2947,7 +2995,7 @@ cp_fold (tree x)\n \n \tif (TREE_CODE (r) != CALL_EXPR)\n \t  {\n-\t    x = cp_fold (r);\n+\t    x = cp_fold (r, flags);\n \t    break;\n \t  }\n \n@@ -2960,7 +3008,15 @@ cp_fold (tree x)\n \t   constant, but the call followed by an INDIRECT_REF is.  */\n \tif (callee && DECL_DECLARED_CONSTEXPR_P (callee)\n \t    && !flag_no_inline)\n-\t  r = maybe_constant_value (x);\n+\t  {\n+\t    mce_value manifestly_const_eval = mce_unknown;\n+\t    if (flags & ff_mce_false)\n+\t      /* Allow folding __builtin_is_constant_evaluated to false during\n+\t\t constexpr evaluation of this call.  */\n+\t      manifestly_const_eval = mce_false;\n+\t    r = maybe_constant_value (x, /*decl=*/NULL_TREE,\n+\t\t\t\t      manifestly_const_eval);\n+\t  }\n \toptimize = sv;\n \n         if (TREE_CODE (r) != CALL_EXPR)\n@@ -2987,7 +3043,7 @@ cp_fold (tree x)\n \tvec<constructor_elt, va_gc> *nelts = NULL;\n \tFOR_EACH_VEC_SAFE_ELT (elts, i, p)\n \t  {\n-\t    tree op = cp_fold (p->value);\n+\t    tree op = cp_fold (p->value, flags);\n \t    if (op != p->value)\n \t      {\n \t\tif (op == error_mark_node)\n@@ -3018,7 +3074,7 @@ cp_fold (tree x)\n \n \tfor (int i = 0; i < n; i++)\n \t  {\n-\t    tree op = cp_fold (TREE_VEC_ELT (x, i));\n+\t    tree op = cp_fold (TREE_VEC_ELT (x, i), flags);\n \t    if (op != TREE_VEC_ELT (x, i))\n \t      {\n \t\tif (!changed)\n@@ -3035,10 +3091,10 @@ cp_fold (tree x)\n     case ARRAY_RANGE_REF:\n \n       loc = EXPR_LOCATION (x);\n-      op0 = cp_fold (TREE_OPERAND (x, 0));\n-      op1 = cp_fold (TREE_OPERAND (x, 1));\n-      op2 = cp_fold (TREE_OPERAND (x, 2));\n-      op3 = cp_fold (TREE_OPERAND (x, 3));\n+      op0 = cp_fold (TREE_OPERAND (x, 0), flags);\n+      op1 = cp_fold (TREE_OPERAND (x, 1), flags);\n+      op2 = cp_fold (TREE_OPERAND (x, 2), flags);\n+      op3 = cp_fold (TREE_OPERAND (x, 3), flags);\n \n       if (op0 != TREE_OPERAND (x, 0)\n \t  || op1 != TREE_OPERAND (x, 1)\n@@ -3066,7 +3122,7 @@ cp_fold (tree x)\n       /* A SAVE_EXPR might contain e.g. (0 * i) + (0 * j), which, after\n \t folding, evaluates to an invariant.  In that case no need to wrap\n \t this folded tree with a SAVE_EXPR.  */\n-      r = cp_fold (TREE_OPERAND (x, 0));\n+      r = cp_fold (TREE_OPERAND (x, 0), flags);\n       if (tree_invariant_p (r))\n \tx = r;\n       break;"}, {"sha": "2123f20e3e518947087fac216c5cfd387390d5d9", "filename": "gcc/testsuite/g++.dg/opt/is_constant_evaluated1.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fea1be820508e1fbc610d1a54b61c1add33c36f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fis_constant_evaluated1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fea1be820508e1fbc610d1a54b61c1add33c36f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fis_constant_evaluated1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fis_constant_evaluated1.C?ref=5fea1be820508e1fbc610d1a54b61c1add33c36f", "patch": "@@ -0,0 +1,20 @@\n+// PR c++/108243\n+// { dg-do compile { target c++11 } }\n+// { dg-additional-options \"-O -fdump-tree-original\" }\n+\n+struct A {\n+  constexpr A(int n, int m) : n(n), m(m) { }\n+  int n, m;\n+};\n+\n+constexpr int foo(int n) {\n+  return n + !__builtin_is_constant_evaluated();\n+}\n+\n+A* f(int n) {\n+  static A a = {n, foo(41)};\n+  return &a;\n+}\n+\n+// { dg-final { scan-tree-dump \"42\" \"original\" } }\n+// { dg-final { scan-tree-dump-not \"foo \\\\(41\\\\)\" \"original\" } }"}, {"sha": "ed964e20a7a78dc8c0aca624f63db45ac28d1384", "filename": "gcc/testsuite/g++.dg/opt/is_constant_evaluated2.C", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fea1be820508e1fbc610d1a54b61c1add33c36f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fis_constant_evaluated2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fea1be820508e1fbc610d1a54b61c1add33c36f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fis_constant_evaluated2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fis_constant_evaluated2.C?ref=5fea1be820508e1fbc610d1a54b61c1add33c36f", "patch": "@@ -0,0 +1,32 @@\n+// PR c++/97553\n+// { dg-do compile { target c++11 } }\n+// { dg-additional-options \"-O -fdump-tree-original\" }\n+\n+constexpr int foo() {\n+  return __builtin_is_constant_evaluated() + 1;\n+}\n+\n+#if __cpp_if_consteval\n+constexpr int bar() {\n+  if consteval {\n+    return 5;\n+  } else {\n+    return 4;\n+  }\n+}\n+#endif\n+\n+int p, q;\n+\n+int main() {\n+  p = foo();\n+#if __cpp_if_consteval\n+  q = bar();\n+#endif\n+}\n+\n+// { dg-final { scan-tree-dump \"p = 1\" \"original\" } }\n+// { dg-final { scan-tree-dump-not \"= foo\" \"original\" } }\n+\n+// { dg-final { scan-tree-dump \"q = 4\" \"original\" { target c++23 } } }\n+// { dg-final { scan-tree-dump-not \"= bar\" \"original\" { target c++23 } } }"}]}