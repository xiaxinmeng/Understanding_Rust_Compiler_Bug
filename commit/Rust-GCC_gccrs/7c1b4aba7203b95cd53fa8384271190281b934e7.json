{"sha": "7c1b4aba7203b95cd53fa8384271190281b934e7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2MxYjRhYmE3MjAzYjk1Y2Q1M2ZhODM4NDI3MTE5MDI4MWI5MzRlNw==", "commit": {"author": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2008-05-15T15:58:20Z"}, "committer": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2008-05-15T15:58:20Z"}, "message": "Add fbuf.c\n\nFrom-SVN: r135376", "tree": {"sha": "84a1877ddb36811e1e2be3ed7fa558949dda274e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/84a1877ddb36811e1e2be3ed7fa558949dda274e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7c1b4aba7203b95cd53fa8384271190281b934e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c1b4aba7203b95cd53fa8384271190281b934e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c1b4aba7203b95cd53fa8384271190281b934e7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c1b4aba7203b95cd53fa8384271190281b934e7/comments", "author": null, "committer": null, "parents": [{"sha": "f6f9ac315906dae8fbe36861f6f12b03a1795b07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6f9ac315906dae8fbe36861f6f12b03a1795b07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6f9ac315906dae8fbe36861f6f12b03a1795b07"}], "stats": {"total": 132, "additions": 132, "deletions": 0}, "files": [{"sha": "ba6f71011dd77176e363750bd1bbc3c12ffec4df", "filename": "libgfortran/io/fbuf.c", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c1b4aba7203b95cd53fa8384271190281b934e7/libgfortran%2Fio%2Ffbuf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c1b4aba7203b95cd53fa8384271190281b934e7/libgfortran%2Fio%2Ffbuf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ffbuf.c?ref=7c1b4aba7203b95cd53fa8384271190281b934e7", "patch": "@@ -0,0 +1,132 @@\n+/* Copyright (C) 2008 Free Software Foundation, Inc.\n+   Contributed by Janne Blomqvist\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with Libgfortran; see the file COPYING.  If not, write to\n+the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+\n+#include \"io.h\"\n+#include <string.h>\n+#include <stdlib.h>\n+\n+\n+void\n+fbuf_init (gfc_unit * u, size_t len)\n+{\n+  if (len == 0)\n+    len = 4096;\t\t\t/* Default size one page.  */\n+\n+  u->fbuf = get_mem (sizeof (fbuf));\n+  u->fbuf->buf = u->fbuf->ptr = get_mem (len);\n+  u->fbuf->len = len;\n+  u->fbuf->act = u->fbuf->flushed = 0;\n+}\n+\n+\n+void\n+fbuf_reset (gfc_unit * u)\n+{\n+  u->fbuf->act = u->fbuf->flushed = 0;\n+  u->fbuf->ptr = u->fbuf->buf;\n+}\n+\n+\n+void\n+fbuf_destroy (gfc_unit * u)\n+{\n+  if (u->fbuf == NULL)\n+    return;\n+  if (u->fbuf->buf)\n+    free_mem (u->fbuf->buf);\n+  free_mem (u->fbuf);\n+}\n+\n+\n+/* Return a pointer to the current position in the buffer, and increase\n+   the pointer by len. Makes sure that the buffer is big enough, \n+   reallocating if necessary.  */\n+\n+char *\n+fbuf_alloc (gfc_unit * u, size_t len)\n+{\n+  size_t newlen, ptrpos;\n+  char *dest;\n+  if (u->fbuf->ptr + len > u->fbuf->buf + u->fbuf->len)\n+    {\n+      /* Round up to nearest multiple of the current buffer length.  */\n+      ptrpos = u->fbuf->ptr - u->fbuf->buf;\n+      newlen = ((ptrpos + len) / u->fbuf->len + 1) * u->fbuf->len;\n+      dest = realloc (u->fbuf->buf, newlen);\n+      if (dest == NULL)\n+\treturn NULL;\n+      u->fbuf->buf = dest;\n+      u->fbuf->ptr = dest + ptrpos;\n+      u->fbuf->len = newlen;\n+    }\n+  dest = u->fbuf->ptr;\n+  u->fbuf->ptr += len;\n+  if ((size_t) (u->fbuf->ptr - u->fbuf->buf) > u->fbuf->act)\n+    u->fbuf->act = u->fbuf->ptr - u->fbuf->buf;\n+  return dest;\n+}\n+\n+\n+int\n+fbuf_flush (gfc_unit * u, int record_done)\n+{\n+  int status;\n+  size_t nbytes;\n+\n+  if (!u->fbuf)\n+    return 0;\n+  if (u->fbuf->act - u->fbuf->flushed != 0)\n+    {\n+      if (record_done)\n+        nbytes = u->fbuf->act - u->fbuf->flushed;\n+      else\t\n+        nbytes = u->fbuf->ptr - u->fbuf->buf - u->fbuf->flushed;\t\n+      status = swrite (u->s, u->fbuf->buf + u->fbuf->flushed, &nbytes);\n+      u->fbuf->flushed += nbytes;\n+    }\n+  else\n+    status = 0;\n+  if (record_done)\n+    fbuf_reset (u);\n+  return status;\n+}\n+\n+\n+int\n+fbuf_seek (gfc_unit * u, gfc_offset off)\n+{\n+  gfc_offset pos = u->fbuf->ptr - u->fbuf->buf + off;\n+  if (pos < 0)\n+    return -1;\n+  u->fbuf->ptr = u->fbuf->buf + pos;\n+  if (pos > u->fbuf->act)\n+    u->fbuf->act = pos;\n+  return 0;\n+}"}]}