{"sha": "cc06c01d0a29c6e1466feba98d8ae3bf20193822", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2MwNmMwMWQwYTI5YzZlMTQ2NmZlYmE5OGQ4YWUzYmYyMDE5MzgyMg==", "commit": {"author": {"name": "Georg-Johann Lay", "email": "avr@gjlay.de", "date": "2013-01-30T11:04:30Z"}, "committer": {"name": "Georg-Johann Lay", "email": "gjl@gcc.gnu.org", "date": "2013-01-30T11:04:30Z"}, "message": "re PR tree-optimization/56064 (Optimize VIEW_CONVERT_EXPR with FIXED_CST)\n\ngcc/\n\tPR tree-optimization/56064\n\t* fixed-value.c (fixed_from_double_int): New function.\n\t* fixed-value.h (fixed_from_double_int): New prototype.\n\t(const_fixed_from_double_int): New static inline function.\n\t* fold-const.c (native_interpret_fixed): New static function.\n\t(native_interpret_expr) <FIXED_POINT_TYPE>: Use it.\n\t(can_native_interpret_type_p) <FIXED_POINT_TYPE>: Return true.\n\t(native_encode_fixed): New static function.\n\t(native_encode_expr) <FIXED_CST>: Use it.\n\t(native_interpret_int): Move double_int worker code to...\n\t* double-int.c (double_int::from_buffer): ...this new static method.\n\t* double-int.h (double_int::from_buffer): Prototype it.\n\ngcc/testsuite/\n\tPR tree-optimization/56064\n\t* gcc.dg/fixed-point/view-convert.c: New test.\n\nFrom-SVN: r195574", "tree": {"sha": "7cbebdbd492e700058cfc647470eb384b37f121e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7cbebdbd492e700058cfc647470eb384b37f121e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cc06c01d0a29c6e1466feba98d8ae3bf20193822", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc06c01d0a29c6e1466feba98d8ae3bf20193822", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc06c01d0a29c6e1466feba98d8ae3bf20193822", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc06c01d0a29c6e1466feba98d8ae3bf20193822/comments", "author": null, "committer": {"login": "sprintersb", "id": 8905355, "node_id": "MDQ6VXNlcjg5MDUzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8905355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sprintersb", "html_url": "https://github.com/sprintersb", "followers_url": "https://api.github.com/users/sprintersb/followers", "following_url": "https://api.github.com/users/sprintersb/following{/other_user}", "gists_url": "https://api.github.com/users/sprintersb/gists{/gist_id}", "starred_url": "https://api.github.com/users/sprintersb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sprintersb/subscriptions", "organizations_url": "https://api.github.com/users/sprintersb/orgs", "repos_url": "https://api.github.com/users/sprintersb/repos", "events_url": "https://api.github.com/users/sprintersb/events{/privacy}", "received_events_url": "https://api.github.com/users/sprintersb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d394a308e34df7dfe56e1b3995a2622e1ed19068", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d394a308e34df7dfe56e1b3995a2622e1ed19068", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d394a308e34df7dfe56e1b3995a2622e1ed19068"}], "stats": {"total": 320, "additions": 289, "deletions": 31}, "files": [{"sha": "797fb126bc2d17a85d3c804aaa3c130941398dbc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc06c01d0a29c6e1466feba98d8ae3bf20193822/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc06c01d0a29c6e1466feba98d8ae3bf20193822/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cc06c01d0a29c6e1466feba98d8ae3bf20193822", "patch": "@@ -1,3 +1,18 @@\n+2013-01-30  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\tPR tree-optimization/56064\n+\t* fixed-value.c (fixed_from_double_int): New function.\n+\t* fixed-value.h (fixed_from_double_int): New prototype.\n+\t(const_fixed_from_double_int): New static inline function.\n+\t* fold-const.c (native_interpret_fixed): New static function.\n+\t(native_interpret_expr) <FIXED_POINT_TYPE>: Use it.\n+\t(can_native_interpret_type_p) <FIXED_POINT_TYPE>: Return true.\n+\t(native_encode_fixed): New static function.\n+\t(native_encode_expr) <FIXED_CST>: Use it.\n+\t(native_interpret_int): Move double_int worker code to...\n+\t* double-int.c (double_int::from_buffer): ...this new static method.\n+\t* double-int.h (double_int::from_buffer): Prototype it.\n+\n 2013-01-30  Richard Biener  <rguenther@suse.de>\n \n \t* tree-ssa-structalias.c (final_solutions, final_solutions_obstack):"}, {"sha": "918ce2273ecaca2952f250463c4750cd98fa5d2c", "filename": "gcc/double-int.c", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc06c01d0a29c6e1466feba98d8ae3bf20193822/gcc%2Fdouble-int.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc06c01d0a29c6e1466feba98d8ae3bf20193822/gcc%2Fdouble-int.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdouble-int.c?ref=cc06c01d0a29c6e1466feba98d8ae3bf20193822", "patch": "@@ -641,6 +641,54 @@ div_and_round_double (unsigned code, int uns,\n   return overflow;\n }\n \n+\n+/* Construct from a buffer of length LEN.  BUFFER will be read according\n+   to byte endianess and word endianess.  Only the lower LEN bytes\n+   of the result are set; the remaining high bytes are cleared.  */\n+\n+double_int\n+double_int::from_buffer (const unsigned char *buffer, int len)\n+{\n+  double_int result = double_int_zero;\n+  int words = len / UNITS_PER_WORD;\n+\n+  gcc_assert (len * BITS_PER_UNIT <= HOST_BITS_PER_DOUBLE_INT);\n+\n+  for (int byte = 0; byte < len; byte++)\n+    {\n+      int offset;\n+      int bitpos = byte * BITS_PER_UNIT;\n+      unsigned HOST_WIDE_INT value;\n+\n+      if (len > UNITS_PER_WORD)\n+\t{\n+\t  int word = byte / UNITS_PER_WORD;\n+\n+\t  if (WORDS_BIG_ENDIAN)\n+\t    word = (words - 1) - word;\n+\n+\t  offset = word * UNITS_PER_WORD;\n+\n+\t  if (BYTES_BIG_ENDIAN)\n+\t    offset += (UNITS_PER_WORD - 1) - (byte % UNITS_PER_WORD);\n+\t  else\n+\t    offset += byte % UNITS_PER_WORD;\n+\t}\n+      else\n+\toffset = BYTES_BIG_ENDIAN ? (len - 1) - byte : byte;\n+\n+      value = (unsigned HOST_WIDE_INT) buffer[offset];\n+\n+      if (bitpos < HOST_BITS_PER_WIDE_INT)\n+\tresult.low |= value << bitpos;\n+      else\n+\tresult.high |= value << (bitpos - HOST_BITS_PER_WIDE_INT);\n+    }\n+\n+  return result;\n+}\n+\n+\n /* Returns mask for PREC bits.  */\n \n double_int"}, {"sha": "5c425a84a457c72a08cfda8fad96d488420f7bf2", "filename": "gcc/double-int.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc06c01d0a29c6e1466feba98d8ae3bf20193822/gcc%2Fdouble-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc06c01d0a29c6e1466feba98d8ae3bf20193822/gcc%2Fdouble-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdouble-int.h?ref=cc06c01d0a29c6e1466feba98d8ae3bf20193822", "patch": "@@ -59,6 +59,10 @@ struct double_int\n   static double_int from_shwi (HOST_WIDE_INT cst);\n   static double_int from_pair (HOST_WIDE_INT high, unsigned HOST_WIDE_INT low);\n \n+  /* Construct from a fuffer of length LEN.  BUFFER will be read according\n+     to byte endianess and word endianess.  */\n+  static double_int from_buffer (const unsigned char *buffer, int len);\n+\n   /* No copy assignment operator or destructor to keep the type a POD.  */\n \n   /* There are some special value-creation static member functions.  */"}, {"sha": "2e97a4926193d2c5b2fb39b4e122009854b7955c", "filename": "gcc/fixed-value.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc06c01d0a29c6e1466feba98d8ae3bf20193822/gcc%2Ffixed-value.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc06c01d0a29c6e1466feba98d8ae3bf20193822/gcc%2Ffixed-value.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixed-value.c?ref=cc06c01d0a29c6e1466feba98d8ae3bf20193822", "patch": "@@ -81,6 +81,24 @@ check_real_for_fixed_mode (REAL_VALUE_TYPE *real_value, enum machine_mode mode)\n   return FIXED_OK;\n }\n \n+\n+/* Construct a CONST_FIXED from a bit payload and machine mode MODE.\n+   The bits in PAYLOAD are used verbatim.  */\n+\n+FIXED_VALUE_TYPE\n+fixed_from_double_int (double_int payload, enum machine_mode mode)\n+{\n+  FIXED_VALUE_TYPE value;\n+\n+  gcc_assert (GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_DOUBLE_INT);\n+\n+  value.data = payload;\n+  value.mode = mode;\n+\n+  return value;\n+}\n+\n+\n /* Initialize from a decimal or hexadecimal string.  */\n \n void"}, {"sha": "5ffe67ca87a4742327bb9393b78a9963ba816d2a", "filename": "gcc/fixed-value.h", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc06c01d0a29c6e1466feba98d8ae3bf20193822/gcc%2Ffixed-value.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc06c01d0a29c6e1466feba98d8ae3bf20193822/gcc%2Ffixed-value.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixed-value.h?ref=cc06c01d0a29c6e1466feba98d8ae3bf20193822", "patch": "@@ -49,6 +49,22 @@ extern FIXED_VALUE_TYPE fconst1[MAX_FCONST1];\n   const_fixed_from_fixed_value (r, m)\n extern rtx const_fixed_from_fixed_value (FIXED_VALUE_TYPE, enum machine_mode);\n \n+/* Construct a FIXED_VALUE from a bit payload and machine mode MODE.\n+   The bits in PAYLOAD are used verbatim.  */\n+extern FIXED_VALUE_TYPE fixed_from_double_int (double_int,\n+\t\t\t\t\t\t     enum machine_mode);\n+\n+/* Return a CONST_FIXED from a bit payload and machine mode MODE.\n+   The bits in PAYLOAD are used verbatim.  */\n+static inline rtx\n+const_fixed_from_double_int (double_int payload,\n+                             enum machine_mode mode)\n+{\n+  return\n+    const_fixed_from_fixed_value (fixed_from_double_int (payload, mode),\n+                                  mode);\n+}\n+\n /* Initialize from a decimal or hexadecimal string.  */\n extern void fixed_from_string (FIXED_VALUE_TYPE *, const char *,\n \t\t\t       enum machine_mode);"}, {"sha": "855f08fdf75c40779378ee1a197978d39bda697b", "filename": "gcc/fold-const.c", "status": "modified", "additions": 61, "deletions": 31, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc06c01d0a29c6e1466feba98d8ae3bf20193822/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc06c01d0a29c6e1466feba98d8ae3bf20193822/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=cc06c01d0a29c6e1466feba98d8ae3bf20193822", "patch": "@@ -7200,6 +7200,36 @@ native_encode_int (const_tree expr, unsigned char *ptr, int len)\n }\n \n \n+/* Subroutine of native_encode_expr.  Encode the FIXED_CST\n+   specified by EXPR into the buffer PTR of length LEN bytes.\n+   Return the number of bytes placed in the buffer, or zero\n+   upon failure.  */\n+\n+static int\n+native_encode_fixed (const_tree expr, unsigned char *ptr, int len)\n+{\n+  tree type = TREE_TYPE (expr);\n+  enum machine_mode mode = TYPE_MODE (type);\n+  int total_bytes = GET_MODE_SIZE (mode);\n+  FIXED_VALUE_TYPE value;\n+  tree i_value, i_type;\n+\n+  if (total_bytes * BITS_PER_UNIT > HOST_BITS_PER_DOUBLE_INT)\n+    return 0;\n+\n+  i_type = lang_hooks.types.type_for_size (GET_MODE_BITSIZE (mode), 1);\n+\n+  if (NULL_TREE == i_type\n+      || TYPE_PRECISION (i_type) != total_bytes)\n+    return 0;\n+  \n+  value = TREE_FIXED_CST (expr);\n+  i_value = double_int_to_tree (i_type, value.data);\n+\n+  return native_encode_int (i_value, ptr, len);\n+}\n+\n+\n /* Subroutine of native_encode_expr.  Encode the REAL_CST\n    specified by EXPR into the buffer PTR of length LEN bytes.\n    Return the number of bytes placed in the buffer, or zero\n@@ -7345,6 +7375,9 @@ native_encode_expr (const_tree expr, unsigned char *ptr, int len)\n     case REAL_CST:\n       return native_encode_real (expr, ptr, len);\n \n+    case FIXED_CST:\n+      return native_encode_fixed (expr, ptr, len);\n+\n     case COMPLEX_CST:\n       return native_encode_complex (expr, ptr, len);\n \n@@ -7368,44 +7401,37 @@ static tree\n native_interpret_int (tree type, const unsigned char *ptr, int len)\n {\n   int total_bytes = GET_MODE_SIZE (TYPE_MODE (type));\n-  int byte, offset, word, words;\n-  unsigned char value;\n   double_int result;\n \n-  if (total_bytes > len)\n-    return NULL_TREE;\n-  if (total_bytes * BITS_PER_UNIT > HOST_BITS_PER_DOUBLE_INT)\n+  if (total_bytes > len\n+      || total_bytes * BITS_PER_UNIT > HOST_BITS_PER_DOUBLE_INT)\n     return NULL_TREE;\n \n-  result = double_int_zero;\n-  words = total_bytes / UNITS_PER_WORD;\n+  result = double_int::from_buffer (ptr, total_bytes);\n \n-  for (byte = 0; byte < total_bytes; byte++)\n-    {\n-      int bitpos = byte * BITS_PER_UNIT;\n-      if (total_bytes > UNITS_PER_WORD)\n-\t{\n-\t  word = byte / UNITS_PER_WORD;\n-\t  if (WORDS_BIG_ENDIAN)\n-\t    word = (words - 1) - word;\n-\t  offset = word * UNITS_PER_WORD;\n-\t  if (BYTES_BIG_ENDIAN)\n-\t    offset += (UNITS_PER_WORD - 1) - (byte % UNITS_PER_WORD);\n-\t  else\n-\t    offset += byte % UNITS_PER_WORD;\n-\t}\n-      else\n-\toffset = BYTES_BIG_ENDIAN ? (total_bytes - 1) - byte : byte;\n-      value = ptr[offset];\n+  return double_int_to_tree (type, result);\n+}\n \n-      if (bitpos < HOST_BITS_PER_WIDE_INT)\n-\tresult.low |= (unsigned HOST_WIDE_INT) value << bitpos;\n-      else\n-\tresult.high |= (unsigned HOST_WIDE_INT) value\n-\t\t       << (bitpos - HOST_BITS_PER_WIDE_INT);\n-    }\n \n-  return double_int_to_tree (type, result);\n+/* Subroutine of native_interpret_expr.  Interpret the contents of\n+   the buffer PTR of length LEN as a FIXED_CST of type TYPE.\n+   If the buffer cannot be interpreted, return NULL_TREE.  */\n+\n+static tree\n+native_interpret_fixed (tree type, const unsigned char *ptr, int len)\n+{\n+  int total_bytes = GET_MODE_SIZE (TYPE_MODE (type));\n+  double_int result;\n+  FIXED_VALUE_TYPE fixed_value;\n+\n+  if (total_bytes > len\n+      || total_bytes * BITS_PER_UNIT > HOST_BITS_PER_DOUBLE_INT)\n+    return NULL_TREE;\n+\n+  result = double_int::from_buffer (ptr, total_bytes);\n+  fixed_value = fixed_from_double_int (result, TYPE_MODE (type));\n+\n+  return build_fixed (type, fixed_value);\n }\n \n \n@@ -7533,6 +7559,9 @@ native_interpret_expr (tree type, const unsigned char *ptr, int len)\n     case REAL_TYPE:\n       return native_interpret_real (type, ptr, len);\n \n+    case FIXED_POINT_TYPE:\n+      return native_interpret_fixed (type, ptr, len);\n+\n     case COMPLEX_TYPE:\n       return native_interpret_complex (type, ptr, len);\n \n@@ -7557,6 +7586,7 @@ can_native_interpret_type_p (tree type)\n     case BOOLEAN_TYPE:\n     case POINTER_TYPE:\n     case REFERENCE_TYPE:\n+    case FIXED_POINT_TYPE:\n     case REAL_TYPE:\n     case COMPLEX_TYPE:\n     case VECTOR_TYPE:"}, {"sha": "e79aebeaa2ea997271770e528dfa17f4decd298b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc06c01d0a29c6e1466feba98d8ae3bf20193822/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc06c01d0a29c6e1466feba98d8ae3bf20193822/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cc06c01d0a29c6e1466feba98d8ae3bf20193822", "patch": "@@ -1,3 +1,8 @@\n+2013-01-30  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\tPR tree-optimization/56064\n+\t* gcc.dg/fixed-point/view-convert.c: New test.\n+\n 2013-01-30  Andreas Schwab  <schwab@suse.de>\n \n \t* lib/target-supports-dg.exp (dg-process-target): Use expr to"}, {"sha": "d5d27b35e1be21118b2a0fdc9aca431cfa99c8d7", "filename": "gcc/testsuite/gcc.dg/fixed-point/view-convert.c", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc06c01d0a29c6e1466feba98d8ae3bf20193822/gcc%2Ftestsuite%2Fgcc.dg%2Ffixed-point%2Fview-convert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc06c01d0a29c6e1466feba98d8ae3bf20193822/gcc%2Ftestsuite%2Fgcc.dg%2Ffixed-point%2Fview-convert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ffixed-point%2Fview-convert.c?ref=cc06c01d0a29c6e1466feba98d8ae3bf20193822", "patch": "@@ -0,0 +1,122 @@\n+/* PR tree-optimization/56064 */\n+/* { dg-do run } */\n+/* { dg-options \"-std=gnu99 -O2 -fno-builtin-memcpy\" } */\n+\n+extern void abort (void);\n+extern void *memcpy (void*, const void*, __SIZE_TYPE__);\n+\n+#define f_pun_i(F, I, VAL)                      \\\n+  {                                             \\\n+    I i1 = VAL;                                 \\\n+    I i2 = VAL;                                 \\\n+    F q1, q2;                                   \\\n+    memcpy (&q1, &i1, sizeof (I));              \\\n+    __builtin_memcpy (&q2, &i2, sizeof (I));    \\\n+    if (q1 != q2)                               \\\n+      abort();                                  \\\n+  }\n+\n+#define i_pun_f(I, F, VAL)                      \\\n+  {                                             \\\n+    F q1 = VAL;                                 \\\n+    F q2 = VAL;                                 \\\n+    I i1, i2;                                   \\\n+    memcpy (&i1, &q1, sizeof (I));              \\\n+    __builtin_memcpy (&i2, &q2, sizeof (I));    \\\n+    if (i1 != i2)                               \\\n+      abort();                                  \\\n+  }\n+\n+\n+void __attribute__((noinline))\n+test8 (void)\n+{\n+#ifdef __INT8_TYPE__\n+  if (sizeof (__INT8_TYPE__) == sizeof (short _Fract))\n+    {\n+#define TEST(X) f_pun_i (short _Fract, __INT8_TYPE__, __INT8_C (X))\n+      TEST (123);\n+      TEST (-123);\n+#undef TEST\n+\n+#define TEST(X) i_pun_f (__INT8_TYPE__, short _Fract, X ## hr)\n+      TEST (0.1234);\n+      TEST (-0.987);\n+#undef TEST\n+    }\n+#endif /* __INT8_TYPE__ */\n+}\n+\n+\n+void __attribute__((noinline))\n+test16 (void)\n+{\n+#ifdef __INT16_TYPE__\n+\n+  if (sizeof (__INT16_TYPE__) == sizeof (_Fract))\n+    {\n+#define TEST(X) f_pun_i (_Fract, __INT16_TYPE__, __INT16_C (X))\n+      TEST (0x4321);\n+      TEST (-0x4321);\n+      TEST (0x8000);\n+#undef TEST\n+\n+#define TEST(X) i_pun_f (__INT16_TYPE__, _Fract, X ## r)\n+      TEST (0.12345);\n+      TEST (-0.98765);\n+#undef TEST\n+    }\n+#endif /* __INT16_TYPE__ */\n+}\n+\n+\n+void __attribute__((noinline))\n+test32 (void)\n+{\n+#ifdef __INT32_TYPE__\n+  if (sizeof (__INT32_TYPE__) == sizeof (_Accum))\n+    {\n+#define TEST(X) f_pun_i (_Accum, __INT32_TYPE__, __INT32_C (X))\n+      TEST (0x76543219);\n+      TEST (-0x76543219);\n+      TEST (0x80000000);\n+#undef TEST\n+\n+#define TEST(X) i_pun_f (__INT32_TYPE__, _Accum, X ## k)\n+      TEST (123.456789);\n+      TEST (-123.456789);\n+#undef TEST\n+    }\n+#endif /* __INT32_TYPE__ */\n+}\n+\n+\n+void __attribute__((noinline))\n+test64 (void)\n+{\n+#ifdef __INT64_TYPE__\n+  if (sizeof (__INT64_TYPE__) == sizeof (long _Accum))\n+    {\n+#define TEST(X) f_pun_i (long _Accum, __INT64_TYPE__, __INT64_C (X))\n+      TEST (0x12345678abcdef01);\n+      TEST (-0x12345678abcdef01);\n+      TEST (0x8000000000000000);\n+#undef TEST\n+\n+#define TEST(X) i_pun_f (__INT64_TYPE__, long _Accum, X ## lk)\n+      TEST (123.456789);\n+      TEST (-123.456789);\n+#undef TEST\n+    }\n+#endif /* __INT64_TYPE__ */\n+}\n+\n+int main()\n+{\n+  test8();\n+  test16();\n+  test32();\n+  test64();\n+  \n+  return 0;\n+}"}]}