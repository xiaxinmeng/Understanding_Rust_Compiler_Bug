{"sha": "f2ffe7a0316e8efdfdbe01bc7b4f8592ec646fcb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjJmZmU3YTAzMTZlOGVmZGZkYmUwMWJjN2I0Zjg1OTJlYzY0NmZjYg==", "commit": {"author": {"name": "Kenneth Zadeck", "email": "zadeck@gcc.gnu.org", "date": "2007-07-31T16:25:36Z"}, "committer": {"name": "Kenneth Zadeck", "email": "zadeck@gcc.gnu.org", "date": "2007-07-31T16:25:36Z"}, "message": "df.h (DF_RU, [...]): Removed.\n\n2007-07-31  Kenneth Zadeck <zadeck@naturalbridge.com>\n\n\t* df.h (DF_RU, DF_RU_BB_INFO, df_ru_bb_info, df_ru,\n\tdf_ru_add_problem, df_ru_get_bb_info): Removed.\n\t(DF_RD, DF_UREC, DF_CHAIN, DF_NOTE): Renumbered.\n\t* df-problems.c (df_ru_problem_data, df_ru_set_bb_info,\n\tdf_ru_free_bb_info, df_ru_alloc,\n\tdf_ru_bb_local_compute_process_def,\n\tdf_ru_bb_local_compute_process_use, df_ru_bb_local_compute,\n\tdf_ru_local_compute, df_ru_init_solution, df_ru_confluence_n,\n\tdf_ru_transfer_function, df_ru_free, df_ru_start_dump,\n\tdf_ru_top_dump, df_ru_bottom_dump, df_problem problem_RU,\n\tdf_ru_add_problem): Removed.\n\nFrom-SVN: r127099", "tree": {"sha": "06681fbc4aff4b3025bdc9beee338213d6803bd4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/06681fbc4aff4b3025bdc9beee338213d6803bd4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f2ffe7a0316e8efdfdbe01bc7b4f8592ec646fcb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2ffe7a0316e8efdfdbe01bc7b4f8592ec646fcb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2ffe7a0316e8efdfdbe01bc7b4f8592ec646fcb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2ffe7a0316e8efdfdbe01bc7b4f8592ec646fcb/comments", "author": null, "committer": null, "parents": [{"sha": "8328d52a4b43c9bd5701062a0c3ef11c1ebbcd56", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8328d52a4b43c9bd5701062a0c3ef11c1ebbcd56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8328d52a4b43c9bd5701062a0c3ef11c1ebbcd56"}], "stats": {"total": 591, "additions": 19, "deletions": 572}, "files": [{"sha": "b70942863c1bb49353bcb6b9b7b7fcccc7534b59", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2ffe7a0316e8efdfdbe01bc7b4f8592ec646fcb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2ffe7a0316e8efdfdbe01bc7b4f8592ec646fcb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f2ffe7a0316e8efdfdbe01bc7b4f8592ec646fcb", "patch": "@@ -1,7 +1,21 @@\n+2007-07-31  Kenneth Zadeck <zadeck@naturalbridge.com>\n+\n+\t* df.h (DF_RU, DF_RU_BB_INFO, df_ru_bb_info, df_ru,\n+\tdf_ru_add_problem, df_ru_get_bb_info): Removed.\n+\t(DF_RD, DF_UREC, DF_CHAIN, DF_NOTE): Renumbered.\n+\t* df-problems.c (df_ru_problem_data, df_ru_set_bb_info,\n+\tdf_ru_free_bb_info, df_ru_alloc,\n+\tdf_ru_bb_local_compute_process_def,\n+\tdf_ru_bb_local_compute_process_use, df_ru_bb_local_compute,\n+\tdf_ru_local_compute, df_ru_init_solution, df_ru_confluence_n,\n+\tdf_ru_transfer_function, df_ru_free, df_ru_start_dump,\n+\tdf_ru_top_dump, df_ru_bottom_dump, df_problem problem_RU,\n+\tdf_ru_add_problem): Removed.\n+\n 2007-07-31  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n \tPR target/32847\n-        * pa.md (casesi32): Use match_scratch.  Revise insn condition.\n+\t* pa.md (casesi32): Use match_scratch.  Revise insn condition.\n \t(casesi32p, casesi64p): Likewise.\n \t(casesi): Adjust for above.\n "}, {"sha": "f5ca47f785f1a72e4f2e84a825b2daeb02d6bc1f", "filename": "gcc/df-problems.c", "status": "modified", "additions": 0, "deletions": 530, "changes": 530, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2ffe7a0316e8efdfdbe01bc7b4f8592ec646fcb/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2ffe7a0316e8efdfdbe01bc7b4f8592ec646fcb/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=f2ffe7a0316e8efdfdbe01bc7b4f8592ec646fcb", "patch": "@@ -200,536 +200,6 @@ df_unset_seen (void)\n }\n \n \n-\f\n-/*----------------------------------------------------------------------------\n-   REACHING USES\n-\n-   Find the locations in the function where each use site for a pseudo\n-   can reach backwards.  In and out bitvectors are built for each basic\n-   block.  The id field in the ref is used to index into these sets.\n-   See df.h for details.\n-\n-----------------------------------------------------------------------------*/\n-\n-/* This problem plays a large number of games for the sake of\n-   efficiency.  \n-   \n-   1) The order of the bits in the bitvectors.  After the scanning\n-   phase, all of the uses are sorted.  All of the uses for the reg 0\n-   are first, followed by all uses for reg 1 and so on.\n-   \n-   2) There are two kill sets, one if the number of uses is less or\n-   equal to DF_SPARSE_THRESHOLD and another if it is greater.\n-\n-   <= : Data is built directly in the kill set.\n-\n-   > : One level of indirection is used to keep from generating long\n-   strings of 1 bits in the kill sets.  Bitvectors that are indexed\n-   by the regnum are used to represent that there is a killing def\n-   for the register.  The confluence and transfer functions use\n-   these along with the bitmap_clear_range call to remove ranges of\n-   bits without actually generating a knockout vector.\n-\n-   The kill and sparse_kill and the dense_invalidated_by_call and\n-   sparse_invalidated_by_call both play this game.  */\n-\n-/* Private data used to compute the solution for this problem.  These\n-   data structures are not accessible outside of this module.  */\n-struct df_ru_problem_data\n-{\n-  /* The set of defs to regs invalidated by call.  */\n-  bitmap sparse_invalidated_by_call;  \n-  /* The set of defs to regs invalidated by call for ru.  */  \n-  bitmap dense_invalidated_by_call;\n-  /* An obstack for the bitmaps we need for this problem.  */\n-  bitmap_obstack ru_bitmaps;\n-};\n-\n-/* Set basic block info.  */\n-\n-static void\n-df_ru_set_bb_info (unsigned int index, struct df_ru_bb_info *bb_info)\n-{\n-  gcc_assert (df_ru);\n-  gcc_assert (index < df_ru->block_info_size);\n-  df_ru->block_info[index] = bb_info;\n-}\n-\n-\n-/* Free basic block info.  */\n-\n-static void\n-df_ru_free_bb_info (basic_block bb ATTRIBUTE_UNUSED, \n-\t\t    void *vbb_info)\n-{\n-  struct df_ru_bb_info *bb_info = (struct df_ru_bb_info *) vbb_info;\n-  if (bb_info)\n-    {\n-      BITMAP_FREE (bb_info->kill);\n-      BITMAP_FREE (bb_info->sparse_kill);\n-      BITMAP_FREE (bb_info->gen);\n-      BITMAP_FREE (bb_info->in);\n-      BITMAP_FREE (bb_info->out);\n-      pool_free (df_ru->block_pool, bb_info);\n-    }\n-}\n-\n-\n-/* Allocate or reset bitmaps for DF_RU blocks. The solution bits are\n-   not touched unless the block is new.  */\n-\n-static void \n-df_ru_alloc (bitmap all_blocks)\n-{\n-  unsigned int bb_index;\n-  bitmap_iterator bi;\n-  struct df_ru_problem_data *problem_data;\n-\n-  if (!df_ru->block_pool)\n-    df_ru->block_pool = create_alloc_pool (\"df_ru_block pool\", \n-\t\t\t\t\t   sizeof (struct df_ru_bb_info), 50);\n-\n-  if (df_ru->problem_data)\n-    {\n-      problem_data = (struct df_ru_problem_data *) df_ru->problem_data;\n-      bitmap_clear (problem_data->sparse_invalidated_by_call);\n-      bitmap_clear (problem_data->dense_invalidated_by_call);\n-    }\n-  else \n-    {\n-      problem_data = XNEW (struct df_ru_problem_data);\n-      df_ru->problem_data = problem_data;\n-\n-      bitmap_obstack_initialize (&problem_data->ru_bitmaps);\n-      problem_data->sparse_invalidated_by_call\n-\t= BITMAP_ALLOC (&problem_data->ru_bitmaps);\n-      problem_data->dense_invalidated_by_call\n-\t= BITMAP_ALLOC (&problem_data->ru_bitmaps);\n-    }\n-\n-  df_grow_bb_info (df_ru);\n-\n-  /* Because of the clustering of all def sites for the same pseudo,\n-     we have to process all of the blocks before doing the\n-     analysis.  */\n-\n-  EXECUTE_IF_SET_IN_BITMAP (all_blocks, 0, bb_index, bi)\n-    {\n-      struct df_ru_bb_info *bb_info = df_ru_get_bb_info (bb_index);\n-      if (bb_info)\n-\t{ \n-\t  bitmap_clear (bb_info->kill);\n-\t  bitmap_clear (bb_info->sparse_kill);\n-\t  bitmap_clear (bb_info->gen);\n-\t}\n-      else\n-\t{ \n-\t  bb_info = (struct df_ru_bb_info *) pool_alloc (df_ru->block_pool);\n-\t  df_ru_set_bb_info (bb_index, bb_info);\n-\t  bb_info->kill = BITMAP_ALLOC (&problem_data->ru_bitmaps);\n-\t  bb_info->sparse_kill = BITMAP_ALLOC (&problem_data->ru_bitmaps);\n-\t  bb_info->gen = BITMAP_ALLOC (&problem_data->ru_bitmaps);\n-\t  bb_info->in = BITMAP_ALLOC (&problem_data->ru_bitmaps);\n-\t  bb_info->out = BITMAP_ALLOC (&problem_data->ru_bitmaps);\n-\t}\n-    }\n-  df_ru->optional_p = true;\n-}\n-\n-\n-/* Process a list of DEFs for df_ru_bb_local_compute.  */\n-\n-static void\n-df_ru_bb_local_compute_process_def (struct df_ru_bb_info *bb_info, \n-\t\t\t\t    struct df_ref **def_rec,\n-\t\t\t\t    enum df_ref_flags top_flag)\n-{\n-  while (*def_rec)\n-    {\n-      struct df_ref *def = *def_rec;\n-      if ((top_flag == (DF_REF_FLAGS (def) & DF_REF_AT_TOP))\n-\t  /* If the def is to only part of the reg, it is as if it did\n-\t     not happen, since some of the bits may get thru.  */\n-\t  && (!(DF_REF_FLAGS (def) & (DF_REF_PARTIAL | DF_REF_CONDITIONAL))))\n-\t{\n-\t  unsigned int regno = DF_REF_REGNO (def);\n-\t  unsigned int begin = DF_USES_BEGIN (regno);\n-\t  unsigned int n_uses = DF_USES_COUNT (regno);\n-\n-\t  if (!bitmap_bit_p (seen_in_block, regno))\n-\t    {\n-\t      /* The first def for regno in the insn, causes the kill\n-\t\t info to be generated.  Do not modify the gen set\n-\t\t because the only values in it are the uses from here\n-\t\t to the top of the block and this def does not effect\n-\t\t them.  */\n-\t      if (!bitmap_bit_p (seen_in_insn, regno))\n-\t\t{\n-\t\t  if (n_uses > DF_SPARSE_THRESHOLD)\n-\t\t    bitmap_set_bit (bb_info->sparse_kill, regno);\n-\t\t  else\n-\t\t    bitmap_set_range (bb_info->kill, begin, n_uses);\n-\t\t}\n-\t      bitmap_set_bit (seen_in_insn, regno);\n-\t    }\n-\t}\n-      def_rec++;\n-    }\n-}\n-\n-\n-/* Process a list of USEs for df_ru_bb_local_compute.  */\n-\n-static void\n-df_ru_bb_local_compute_process_use (struct df_ru_bb_info *bb_info, \n-\t\t\t\t    struct df_ref **use_rec,\n-\t\t\t\t    enum df_ref_flags top_flag)\n-{\n-  while (*use_rec)\n-    {\n-      struct df_ref *use = *use_rec;\n-      if (top_flag == (DF_REF_FLAGS (use) & DF_REF_AT_TOP))\n-\t{\n-\t  /* Add use to set of gens in this BB unless we have seen a\n-\t     def in a previous instruction.  */\n-\t  unsigned int regno = DF_REF_REGNO (use);\n-\t  if (!bitmap_bit_p (seen_in_block, regno))\n-\t    bitmap_set_bit (bb_info->gen, DF_REF_ID (use));\n-\t}\n-      use_rec++;\n-    }\n-}\n-\n-/* Compute local reaching use (upward exposed use) info for basic\n-   block BB.  USE_INFO->REGS[R] caches the set of uses for register R.  */\n-static void\n-df_ru_bb_local_compute (unsigned int bb_index)\n-{\n-  basic_block bb = BASIC_BLOCK (bb_index);\n-  struct df_ru_bb_info *bb_info = df_ru_get_bb_info (bb_index);\n-  rtx insn;\n-\n-  /* Set when a def for regno is seen.  */\n-  bitmap_clear (seen_in_block);\n-  bitmap_clear (seen_in_insn);\n-\n-#ifdef EH_USES\n-  /* Variables defined in the prolog that are used by the exception\n-     handler.  */\n-  df_ru_bb_local_compute_process_use (bb_info, \n-\t\t\t\t      df_get_artificial_uses (bb_index),\n-\t\t\t\t      DF_REF_AT_TOP);\n-#endif\n-  df_ru_bb_local_compute_process_def (bb_info, \n-\t\t\t\t      df_get_artificial_defs (bb_index),\n-\t\t\t\t      DF_REF_AT_TOP);\n-\n-  FOR_BB_INSNS (bb, insn)\n-    {\n-      unsigned int uid = INSN_UID (insn);\n-      if (!INSN_P (insn))\n-\tcontinue;\n-\n-      df_ru_bb_local_compute_process_use (bb_info, \n-\t\t\t\t\t  DF_INSN_UID_USES (uid), 0);\n-\n-      if (df->changeable_flags & DF_EQ_NOTES)\n-\tdf_ru_bb_local_compute_process_use (bb_info, \n-\t\t\t\t\t    DF_INSN_UID_EQ_USES (uid), 0);\n-\n-      df_ru_bb_local_compute_process_def (bb_info, \n-\t\t\t\t\t  DF_INSN_UID_DEFS (uid), 0);\n-\n-      bitmap_ior_into (seen_in_block, seen_in_insn);\n-      bitmap_clear (seen_in_insn);\n-    }\n-\n-  /* Process the hardware registers that are always live.  */\n-  df_ru_bb_local_compute_process_use (bb_info, \n-\t\t\t\t      df_get_artificial_uses (bb_index), 0);\n-\n-  df_ru_bb_local_compute_process_def (bb_info, \n-\t\t\t\t      df_get_artificial_defs (bb_index), 0);\n-}\n-\n-\n-/* Compute local reaching use (upward exposed use) info for each basic\n-   block within BLOCKS.  */\n-static void\n-df_ru_local_compute (bitmap all_blocks)\n-{\n-  unsigned int bb_index;\n-  bitmap_iterator bi;\n-  unsigned int regno;\n-  struct df_ru_problem_data *problem_data\n-    = (struct df_ru_problem_data *) df_ru->problem_data;\n-  bitmap sparse_invalidated = problem_data->sparse_invalidated_by_call;\n-  bitmap dense_invalidated = problem_data->dense_invalidated_by_call;\n-\n-  df_set_seen ();\n-\n-  df_maybe_reorganize_use_refs (df->changeable_flags & DF_EQ_NOTES ? \n-\t\t\t\tDF_REF_ORDER_BY_REG_WITH_NOTES : DF_REF_ORDER_BY_REG);\n-\n-  EXECUTE_IF_SET_IN_BITMAP (all_blocks, 0, bb_index, bi)\n-    {\n-      df_ru_bb_local_compute (bb_index);\n-    }\n-  \n-  /* Set up the knockout bit vectors to be applied across EH_EDGES.  */\n-  EXECUTE_IF_SET_IN_BITMAP (df_invalidated_by_call, 0, regno, bi)\n-    {\n-      if (DF_USES_COUNT (regno) > DF_SPARSE_THRESHOLD)\n-\tbitmap_set_bit (sparse_invalidated, regno);\n-      else\n-\tbitmap_set_range (dense_invalidated,\n-\t\t\t  DF_USES_BEGIN (regno), \n-\t\t\t  DF_USES_COUNT (regno));\n-    }\n-\n-  df_unset_seen ();\n-}\n-\n-\n-/* Initialize the solution bit vectors for problem.  */\n-\n-static void \n-df_ru_init_solution (bitmap all_blocks)\n-{\n-  unsigned int bb_index;\n-  bitmap_iterator bi;\n-\n-  EXECUTE_IF_SET_IN_BITMAP (all_blocks, 0, bb_index, bi)\n-    {\n-      struct df_ru_bb_info *bb_info = df_ru_get_bb_info (bb_index);\n-      bitmap_copy (bb_info->in, bb_info->gen);\n-      bitmap_clear (bb_info->out);\n-    }\n-}\n-\n-\n-/* Out of target gets or of in of source.  */\n-\n-static void\n-df_ru_confluence_n (edge e)\n-{\n-  bitmap op1 = df_ru_get_bb_info (e->src->index)->out;\n-  bitmap op2 = df_ru_get_bb_info (e->dest->index)->in;\n-\n-  if (e->flags & EDGE_EH)\n-    {\n-      struct df_ru_problem_data *problem_data\n-\t= (struct df_ru_problem_data *) df_ru->problem_data;\n-      bitmap sparse_invalidated = problem_data->sparse_invalidated_by_call;\n-      bitmap dense_invalidated = problem_data->dense_invalidated_by_call;\n-      bitmap_iterator bi;\n-      unsigned int regno;\n-      bitmap tmp = BITMAP_ALLOC (&df_bitmap_obstack);\n-\n-      bitmap_copy (tmp, op2);\n-      bitmap_and_compl_into (tmp, dense_invalidated);\n-\n-      EXECUTE_IF_SET_IN_BITMAP (sparse_invalidated, 0, regno, bi)\n-\t{\n- \t  bitmap_clear_range (tmp, \n- \t\t\t      DF_USES_BEGIN (regno), \n- \t\t\t      DF_USES_COUNT (regno));\n-\t}\n-      bitmap_ior_into (op1, tmp);\n-      BITMAP_FREE (tmp);\n-    }\n-  else\n-    bitmap_ior_into (op1, op2);\n-}\n-\n-\n-/* Transfer function.  */\n-\n-static bool\n-df_ru_transfer_function (int bb_index)\n-{\n-  struct df_ru_bb_info *bb_info = df_ru_get_bb_info (bb_index);\n-  unsigned int regno;\n-  bitmap_iterator bi;\n-  bitmap in = bb_info->in;\n-  bitmap out = bb_info->out;\n-  bitmap gen = bb_info->gen;\n-  bitmap kill = bb_info->kill;\n-  bitmap sparse_kill = bb_info->sparse_kill;\n-\n-  if (bitmap_empty_p (sparse_kill))\n-    return  bitmap_ior_and_compl (in, gen, out, kill);\n-  else \n-    {\n-      struct df_ru_problem_data *problem_data;\n-      bitmap tmp;\n-      bool changed = false;\n-\n-      /* Note that TMP is _not_ a temporary bitmap if we end up replacing\n-\t IN with TMP.  Therefore, allocate TMP in the RU bitmaps obstack.  */\n-      problem_data = (struct df_ru_problem_data *) df_ru->problem_data;\n-      tmp = BITMAP_ALLOC (&problem_data->ru_bitmaps);\n-\n-      bitmap_copy (tmp, out);\n-      EXECUTE_IF_SET_IN_BITMAP (sparse_kill, 0, regno, bi)\n-\t{\n-\t  bitmap_clear_range (tmp, \n- \t\t\t      DF_USES_BEGIN (regno), \n- \t\t\t      DF_USES_COUNT (regno));\n-\t}\n-      bitmap_and_compl_into (tmp, kill);\n-      bitmap_ior_into (tmp, gen);\n-      changed = !bitmap_equal_p (tmp, in);\n-      if (changed)\n-\t{\n-\t  BITMAP_FREE (in);\n-\t  bb_info->in = tmp;\n-\t}\n-      else \n-\tBITMAP_FREE (tmp);\n-      return changed;\n-    }\n-}\n-\n-\n-/* Free all storage associated with the problem.  */\n-\n-static void\n-df_ru_free (void)\n-{\n-  unsigned int i;\n-  struct df_ru_problem_data *problem_data\n-    = (struct df_ru_problem_data *) df_ru->problem_data;\n-\n-  if (problem_data)\n-    {\n-      for (i = 0; i < df_ru->block_info_size; i++)\n-\t{\n-\t  struct df_ru_bb_info *bb_info = df_ru_get_bb_info (i);\n-\t  if (bb_info)\n-\t    {\n-\t      BITMAP_FREE (bb_info->kill);\n-\t      BITMAP_FREE (bb_info->sparse_kill);\n-\t      BITMAP_FREE (bb_info->gen);\n-\t      BITMAP_FREE (bb_info->in);\n-\t      BITMAP_FREE (bb_info->out);\n-\t    }\n-\t}\n-      \n-      free_alloc_pool (df_ru->block_pool);\n-      BITMAP_FREE (problem_data->sparse_invalidated_by_call);\n-      BITMAP_FREE (problem_data->dense_invalidated_by_call);\n-      bitmap_obstack_release (&problem_data->ru_bitmaps);\n-      \n-      df_ru->block_info_size = 0;\n-      free (df_ru->block_info);\n-      free (df_ru->problem_data);\n-    }\n-  free (df_ru);\n-}\n-\n-\n-/* Debugging info.  */\n-\n-static void\n-df_ru_start_dump (FILE *file)\n-{\n-  struct df_ru_problem_data *problem_data\n-    = (struct df_ru_problem_data *) df_ru->problem_data;\n-  unsigned int m = DF_REG_SIZE(df);\n-  unsigned int regno;\n-  \n-  if (!df_ru->block_info) \n-    return;\n-\n-  fprintf (file, \";; Reaching uses:\\n\");\n-\n-  fprintf (file, \";;   sparse invalidated \\t\");\n-  dump_bitmap (file, problem_data->sparse_invalidated_by_call);\n-  fprintf (file, \" dense invalidated \\t\");\n-  dump_bitmap (file, problem_data->dense_invalidated_by_call);\n-  \n-  for (regno = 0; regno < m; regno++)\n-    if (DF_USES_COUNT (regno))\n-      fprintf (file, \"%d[%d,%d] \", regno, \n-\t       DF_USES_BEGIN (regno), \n-\t       DF_USES_COUNT (regno));\n-  fprintf (file, \"\\n\");\n-}\n-\n-\n-/* Debugging info at top of bb.  */\n-\n-static void\n-df_ru_top_dump (basic_block bb, FILE *file)\n-{\n-  struct df_ru_bb_info *bb_info = df_ru_get_bb_info (bb->index);\n-  if (!bb_info || !bb_info->in)\n-    return;\n-  \n-  fprintf (file, \";; ru  in  \\t(%d)\\n\", (int) bitmap_count_bits (bb_info->in));\n-  dump_bitmap (file, bb_info->in);\n-  fprintf (file, \";; ru  gen \\t(%d)\\n\", (int) bitmap_count_bits (bb_info->gen));\n-  dump_bitmap (file, bb_info->gen);\n-  fprintf (file, \";; ru  kill\\t(%d)\\n\", (int) bitmap_count_bits (bb_info->kill));\n-  dump_bitmap (file, bb_info->kill);\n-}  \n-\n-\n-/* Debugging info at bottom of bb.  */\n-\n-static void\n-df_ru_bottom_dump (basic_block bb, FILE *file)\n-{\n-  struct df_ru_bb_info *bb_info = df_ru_get_bb_info (bb->index);\n-  if (!bb_info || !bb_info->out)\n-    return;\n-  \n-  fprintf (file, \";; ru  out \\t(%d)\\n\", (int) bitmap_count_bits (bb_info->out));\n-  dump_bitmap (file, bb_info->out);\n-}  \n-\n-\n-/* All of the information associated with every instance of the problem.  */\n-\n-static struct df_problem problem_RU =\n-{\n-  DF_RU,                      /* Problem id.  */\n-  DF_BACKWARD,                /* Direction.  */\n-  df_ru_alloc,                /* Allocate the problem specific data.  */\n-  NULL,                       /* Reset global information.  */\n-  df_ru_free_bb_info,         /* Free basic block info.  */\n-  df_ru_local_compute,        /* Local compute function.  */\n-  df_ru_init_solution,        /* Init the solution specific data.  */\n-  df_worklist_dataflow,       /* Worklist solver.  */\n-  NULL,                       /* Confluence operator 0.  */ \n-  df_ru_confluence_n,         /* Confluence operator n.  */ \n-  df_ru_transfer_function,    /* Transfer function.  */\n-  NULL,                       /* Finalize function.  */\n-  df_ru_free,                 /* Free all of the problem information.  */\n-  df_ru_free,                 /* Remove this problem from the stack of dataflow problems.  */\n-  df_ru_start_dump,           /* Debugging.  */\n-  df_ru_top_dump,             /* Debugging start block.  */\n-  df_ru_bottom_dump,          /* Debugging end block.  */\n-  NULL,                       /* Incremental solution verify start.  */\n-  NULL,                       /* Incremental solution verify end.  */\n-  NULL,                       /* Dependent problem.  */\n-  TV_DF_RU,                   /* Timing variable.  */\n-  true                        /* Reset blocks on dropping out of blocks_to_analyze.  */\n-};\n-\n-\n-\n-/* Create a new DATAFLOW instance and add it to an existing instance\n-   of DF.  The returned structure is what is used to get at the\n-   solution.  */\n-\n-void\n-df_ru_add_problem (void)\n-{\n-  df_add_problem (&problem_RU);\n-}\n-\n \f\n /*----------------------------------------------------------------------------\n    REACHING DEFINITIONS"}, {"sha": "de8afc334842d4b06c90f79ac5458fdbf30f3516", "filename": "gcc/df.h", "status": "modified", "additions": 4, "deletions": 41, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2ffe7a0316e8efdfdbe01bc7b4f8592ec646fcb/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2ffe7a0316e8efdfdbe01bc7b4f8592ec646fcb/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=f2ffe7a0316e8efdfdbe01bc7b4f8592ec646fcb", "patch": "@@ -44,11 +44,10 @@ struct df_link;\n #define DF_LR    1      /* Live Registers backward. */\n #define DF_LIVE  2      /* Live Registers & Uninitialized Registers */\n \n-#define DF_RU    3      /* Reaching Uses. */\n-#define DF_RD    4      /* Reaching Defs. */\n-#define DF_UREC  5      /* Uninitialized Registers with Early Clobber. */\n-#define DF_CHAIN 6      /* Def-Use and/or Use-Def Chains. */\n-#define DF_NOTE  7      /* REG_DEF and REG_UNUSED notes. */\n+#define DF_RD    3      /* Reaching Defs. */\n+#define DF_UREC  4      /* Uninitialized Registers with Early Clobber. */\n+#define DF_CHAIN 5      /* Def-Use and/or Use-Def Chains. */\n+#define DF_NOTE  6      /* REG_DEF and REG_UNUSED notes. */\n \n #define DF_LAST_PROBLEM_PLUS1 (DF_NOTE + 1)\n \n@@ -541,7 +540,6 @@ struct df\n };\n \n #define DF_SCAN_BB_INFO(BB) (df_scan_get_bb_info((BB)->index))\n-#define DF_RU_BB_INFO(BB) (df_ru_get_bb_info((BB)->index))\n #define DF_RD_BB_INFO(BB) (df_rd_get_bb_info((BB)->index))\n #define DF_LR_BB_INFO(BB) (df_lr_get_bb_info((BB)->index))\n #define DF_UREC_BB_INFO(BB) (df_urec_get_bb_info((BB)->index))\n@@ -694,30 +692,6 @@ struct df_scan_bb_info\n };\n \n \n-/* Reaching uses.  All bitmaps are indexed by the id field of the ref\n-   except sparse_kill (see below).  */\n-struct df_ru_bb_info \n-{\n-  /* Local sets to describe the basic blocks.  */\n-  /* The kill set is the set of uses that are killed in this block.\n-     However, if the number of uses for this register is greater than\n-     DF_SPARSE_THRESHOLD, the sparse_kill is used instead. In\n-     sparse_kill, each register gets a slot and a 1 in this bitvector\n-     means that all of the uses of that register are killed.  This is\n-     a very useful efficiency hack in that it keeps from having push\n-     around big groups of 1s.  This is implemented by the\n-     bitmap_clear_range call.  */\n-\n-  bitmap kill;\n-  bitmap sparse_kill;\n-  bitmap gen;   /* The set of uses generated in this block.  */\n-\n-  /* The results of the dataflow problem.  */\n-  bitmap in;    /* At the top of the block.  */\n-  bitmap out;   /* At the bottom of the block.  */\n-};\n-\n-\n /* Reaching definitions.  All bitmaps are indexed by the id field of\n    the ref except sparse_kill (see above).  */\n struct df_rd_bb_info \n@@ -807,7 +781,6 @@ struct df_urec_bb_info\n    should not be used by regular code.  */ \n extern struct df *df;\n #define df_scan  (df->problems_by_index[DF_SCAN])\n-#define df_ru    (df->problems_by_index[DF_RU])\n #define df_rd    (df->problems_by_index[DF_RD])\n #define df_lr    (df->problems_by_index[DF_LR])\n #define df_live  (df->problems_by_index[DF_LIVE])\n@@ -889,7 +862,6 @@ extern bitmap df_get_live_top (basic_block);\n extern void df_grow_bb_info (struct dataflow *);\n extern void df_chain_dump (struct df_link *, FILE *);\n extern void df_print_bb_index (basic_block bb, FILE *file);\n-extern void df_ru_add_problem (void);\n extern void df_rd_add_problem (void);\n extern void df_lr_add_problem (void);\n extern void df_lr_verify_transfer_functions (void);\n@@ -954,15 +926,6 @@ df_scan_get_bb_info (unsigned int index)\n     return NULL;\n }\n \n-static inline struct df_ru_bb_info *\n-df_ru_get_bb_info (unsigned int index)\n-{\n-  if (index < df_ru->block_info_size)\n-    return (struct df_ru_bb_info *) df_ru->block_info[index];\n-  else\n-    return NULL;\n-}\n-\n static inline struct df_rd_bb_info *\n df_rd_get_bb_info (unsigned int index)\n {"}]}