{"sha": "e3281ffc9f3d39a7b6598d8105b0cd9b3df4fa05", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTMyODFmZmM5ZjNkMzlhN2I2NTk4ZDgxMDViMGNkOWIzZGY0ZmEwNQ==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@cygnus.com", "date": "1998-08-26T12:16:54Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "1998-08-26T12:16:54Z"}, "message": "Do not move register a4 into lr if lr already contains the return address.\n\n  CVS: ----------------------------------------------------------------------\n\nFrom-SVN: r22002", "tree": {"sha": "2e78d789a8394c7c2316aaa1bbe90821619aeeea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2e78d789a8394c7c2316aaa1bbe90821619aeeea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e3281ffc9f3d39a7b6598d8105b0cd9b3df4fa05", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3281ffc9f3d39a7b6598d8105b0cd9b3df4fa05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3281ffc9f3d39a7b6598d8105b0cd9b3df4fa05", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3281ffc9f3d39a7b6598d8105b0cd9b3df4fa05/comments", "author": null, "committer": null, "parents": [{"sha": "6b7e236fb6b084fbef55ae44cd35667759ffe05c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b7e236fb6b084fbef55ae44cd35667759ffe05c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b7e236fb6b084fbef55ae44cd35667759ffe05c"}], "stats": {"total": 145, "additions": 59, "deletions": 86}, "files": [{"sha": "4dd980d96a865761a3440edfa3205e6d22282802", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3281ffc9f3d39a7b6598d8105b0cd9b3df4fa05/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3281ffc9f3d39a7b6598d8105b0cd9b3df4fa05/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e3281ffc9f3d39a7b6598d8105b0cd9b3df4fa05", "patch": "@@ -1,3 +1,8 @@\n+Wed Aug 26 09:30:59 1998  Nick Clifton  <nickc@cygnus.com>\n+\n+\t* config/arm/thumb.c (thumb_exit): Do not move a4 into lr if it\n+\talready contains the return address.\n+\n Wed Aug 26 12:57:09 1998  Jeffrey A Law  (law@cygnus.com)\n \n \t* mn10300.h (RTX_COSTS): Handle UDIV and UMOD too."}, {"sha": "c7cc7a28e450ecff9cbba6e95c2ca0533ed73126", "filename": "gcc/config/arm/thumb.c", "status": "modified", "additions": 54, "deletions": 86, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3281ffc9f3d39a7b6598d8105b0cd9b3df4fa05/gcc%2Fconfig%2Farm%2Fthumb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3281ffc9f3d39a7b6598d8105b0cd9b3df4fa05/gcc%2Fconfig%2Farm%2Fthumb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fthumb.c?ref=e3281ffc9f3d39a7b6598d8105b0cd9b3df4fa05", "patch": "@@ -603,7 +603,6 @@ number_of_first_bit_set (mask)\n /* Generate code to return from a thumb function.  If\n    'reg_containing_return_addr' is -1, then the return address is\n    actually on the stack, at the stack pointer.  */\n-\n static void\n thumb_exit (f, reg_containing_return_addr)\n      FILE * f;\n@@ -620,7 +619,6 @@ thumb_exit (f, reg_containing_return_addr)\n   int restore_a4 = FALSE;\n \n   /* Compute the registers we need to pop.  */\n-\n   regs_to_pop = 0;\n   pops_needed = 0;\n   \n@@ -633,24 +631,21 @@ thumb_exit (f, reg_containing_return_addr)\n   if (TARGET_BACKTRACE)\n     {\n       /* Restore frame pointer and stack pointer.  */\n-      \n       regs_to_pop |= (1 << FRAME_POINTER) | (1 << STACK_POINTER);\n       pops_needed += 2;\n     }\n \n-  /* If there is nothing to pop then just emit the BX instruction and return.  */\n-  \n+  /* If there is nothing to pop then just emit the BX instruction and return.*/\n   if (pops_needed == 0)\n     {\n-      asm_fprintf (f, \"\\tbx\\t%s\\n\", reg_names[ reg_containing_return_addr ]);\n+      asm_fprintf (f, \"\\tbx\\t%s\\n\", reg_names [reg_containing_return_addr]);\n \n       return;\n     }\n \n   /* Otherwise if we are not supporting interworking and we have not created\n      a backtrace structure and the function was not entered in ARM mode then\n      just pop the return address straight into the PC. */\n-  \n   else if (   ! TARGET_THUMB_INTERWORK\n \t   && ! TARGET_BACKTRACE\n \t   && ! is_called_in_ARM_mode (current_function_decl))\n@@ -661,7 +656,6 @@ thumb_exit (f, reg_containing_return_addr)\n     }\n \n   /* Find out how many of the (return) argument registers we can corrupt. */\n-  \n   regs_available_for_popping = 0;\n   \n #ifdef RTX_CODE\n@@ -671,14 +665,10 @@ thumb_exit (f, reg_containing_return_addr)\n      the register is used to hold a return value.  */\n \n   if (current_function_return_rtx != 0)\n-    {\n       mode = GET_MODE (current_function_return_rtx);\n-    }\n   else\n #endif\n-    {\n       mode = DECL_MODE (DECL_RESULT (current_function_decl));\n-    }\n \n   size = GET_MODE_SIZE (mode);\n \n@@ -687,17 +677,23 @@ thumb_exit (f, reg_containing_return_addr)\n       /* In a void function we can use any argument register.\n \t In a function that returns a structure on the stack\n \t we can use the second and third argument registers.  */\n-      \n       if (mode == VOIDmode)\n-\tregs_available_for_popping = (1 << ARG_1_REGISTER) | (1 << ARG_2_REGISTER) | (1 << ARG_3_REGISTER);\n+\tregs_available_for_popping =\n+\t    (1 << ARG_1_REGISTER)\n+\t  | (1 << ARG_2_REGISTER)\n+\t  | (1 << ARG_3_REGISTER);\n       else\n-\tregs_available_for_popping = (1 << ARG_2_REGISTER) | (1 << ARG_3_REGISTER);\n+\tregs_available_for_popping =\n+\t    (1 << ARG_2_REGISTER)\n+\t  | (1 << ARG_3_REGISTER);\n     }\n-  else if (size <= 4) regs_available_for_popping = (1 << ARG_2_REGISTER) | (1 << ARG_3_REGISTER);\n-  else if (size <= 8) regs_available_for_popping = (1 << ARG_3_REGISTER);\n+  else if (size <= 4) regs_available_for_popping =\n+\t\t\t  (1 << ARG_2_REGISTER)\n+\t\t\t| (1 << ARG_3_REGISTER);\n+  else if (size <= 8) regs_available_for_popping =\n+\t\t\t(1 << ARG_3_REGISTER);\n   \n   /* Match registers to be popped with registers into which we pop them.  */\n-\n   for (available = regs_available_for_popping,\n        required  = regs_to_pop;\n        required != 0 && available != 0;\n@@ -706,173 +702,140 @@ thumb_exit (f, reg_containing_return_addr)\n     -- pops_needed;\n \n   /* If we have any popping registers left over, remove them.  */\n-\n   if (available > 0)\n     regs_available_for_popping &= ~ available;\n   \n   /* Otherwise if we need another popping register we can use\n      the fourth argument register.  */\n-  \n   else if (pops_needed)\n     {\n       /* If we have not found any free argument registers and\n \t reg a4 contains the return address, we must move it.  */\n-\n-      if (regs_available_for_popping == 0 && reg_containing_return_addr == ARG_4_REGISTER)\n+      if (regs_available_for_popping == 0\n+\t  && reg_containing_return_addr == ARG_4_REGISTER)\n \t{\n \t  asm_fprintf (f, \"\\tmov\\t%s, %s\\n\",\n-\t\t       reg_names[ LINK_REGISTER ],\n-\t\t       reg_names[ ARG_4_REGISTER ]);\n+\t\t       reg_names [LINK_REGISTER], reg_names [ARG_4_REGISTER]);\n \t  reg_containing_return_addr = LINK_REGISTER;\n \t}\n       else if (size > 12)\n \t{\n \t  /* Register a4 is being used to hold part of the return value,\n \t     but we have dire need of a free, low register.  */\n-\t  \n \t  restore_a4 = TRUE;\n \t  \n \t  asm_fprintf (f, \"\\tmov\\t%s, %s\\n\",\n-\t\t       reg_names[ IP_REGISTER ],\n-\t\t       reg_names[ ARG_4_REGISTER ]);\n+\t\t       reg_names [IP_REGISTER], reg_names [ARG_4_REGISTER]);\n \t}\n       \n       if (reg_containing_return_addr != ARG_4_REGISTER)\n \t{\n \t  /* The fourth argument register is available.  */\n-  \n \t  regs_available_for_popping |= 1 << ARG_4_REGISTER;\n \t  \n \t  -- pops_needed;\n \t}\n     }\n \n   /* Pop as many registers as we can.  */\n-  \n-  thumb_pushpop (f, regs_available_for_popping, FALSE );\n+  thumb_pushpop (f, regs_available_for_popping, FALSE);\n \n   /* Process the registers we popped.  */\n-  \n   if (reg_containing_return_addr == -1)\n     {\n       /* The return address was popped into the lowest numbered register.  */\n-\n       regs_to_pop &= ~ (1 << LINK_REGISTER);\n       \n-      reg_containing_return_addr = number_of_first_bit_set (regs_available_for_popping);\n+      reg_containing_return_addr =\n+\tnumber_of_first_bit_set (regs_available_for_popping);\n \n       /* Remove this register for the mask of available registers, so that\n          the return address will not be corrupted by futher pops.  */\n-      \n       regs_available_for_popping &= ~ (1 << reg_containing_return_addr);\n     }\n \n   /* If we popped other registers then handle them here.  */\n-\n   if (regs_available_for_popping)\n     {\n       int frame_pointer;\n       \n       /* Work out which register currently contains the frame pointer.  */\n-      \n       frame_pointer = number_of_first_bit_set (regs_available_for_popping);\n \n       /* Move it into the correct place.  */\n-      \n-      asm_fprintf (f, \"\\tmov\\tfp, %s\\n\", reg_names[ frame_pointer ]);\n+      asm_fprintf (f, \"\\tmov\\tfp, %s\\n\", reg_names [frame_pointer]);\n \n       /* (Temporarily) remove it from the mask of popped registers.  */\n-      \n       regs_available_for_popping &= ~ (1 << frame_pointer);\n       regs_to_pop &= ~ (1 << FRAME_POINTER);\n       \n       if (regs_available_for_popping)\n \t{\n \t  int stack_pointer;\n \t  \n-\t  /* We popped the stack pointer as well, find the register that contains it.  */\n-\t  \n+\t  /* We popped the stack pointer as well, find the register that\n+\t     contains it.*/\n \t  stack_pointer = number_of_first_bit_set (regs_available_for_popping);\n \n \t  /* Move it into the stack register.  */\n-\t  \n-\t  asm_fprintf (f, \"\\tmov\\tsp, %s\\n\", reg_names[ stack_pointer ]);\n+\t  asm_fprintf (f, \"\\tmov\\tsp, %s\\n\", reg_names [stack_pointer]);\n \t  \n \t  /* At this point we have popped all necessary registers, so\n \t     do not worry about restoring regs_available_for_popping\n \t     to its correct value:\n \n \t     assert (pops_needed == 0)\n-\t     assert (regs_available_for_popping == (1 << stack_frame_pointer))\n+\t     assert (regs_available_for_popping == (1 << frame_pointer))\n \t     assert (regs_to_pop == (1 << STACK_POINTER))  */\n \t}\n       else\n \t{\n \t  /* Since we have just move the popped value into the frame\n \t     pointer, the popping register is available for reuse, and\n \t     we know that we still have the stack pointer left to pop.  */\n-\t  \n \t  regs_available_for_popping |= (1 << frame_pointer);\n \t}\n     }\n   \n-  /* If we still have registers left on the stack, but we no longer\n-     have any registers into which we can pop them, then we must\n-     move the return address into the link register and make\n-     available the register that contained it.  */\n-  \n+  /* If we still have registers left on the stack, but we no longer have\n+     any registers into which we can pop them, then we must move the return\n+     address into the link register and make available the register that\n+     contained it.  */\n   if (regs_available_for_popping == 0 && pops_needed > 0)\n     {\n       regs_available_for_popping |= 1 << reg_containing_return_addr;\n       \n       asm_fprintf (f, \"\\tmov\\t%s, %s\\n\",\n-\t\t   reg_names[ LINK_REGISTER ],\n-\t\t   reg_names[ reg_containing_return_addr ]);\n+\t\t   reg_names [LINK_REGISTER],\n+\t\t   reg_names [reg_containing_return_addr]);\n       \n       reg_containing_return_addr = LINK_REGISTER;\n     }\n \n   /* If we have registers left on the stack then pop some more.\n-     We know that we will only be popping one register here for\n-     the following reasons:\n-\n-     1. We know that at most we want to pop LR, FP and SP.\n-     2. We have already popped at least one register.\n-     3. If there were 3 registers available for popping then\n-        we have already popped all three of the registers.\n-     4. If there were 2 registers available for popping then\n-        we have already popped LR and FP, so there can only\n-\tbe one register left on the stack: SP.  And since we\n-\thad two\tregisters available for popping we will have\n-\tleft the LR in one of those registers and leaving\n-\tonly one register left for popping the SP.\n-     5. If there was only 1 register available for popping\n-        then we can only be popping one register here.\t*/\n-  \n+     We know that at most we will want to pop FP and SP.  */\n   if (pops_needed > 0)\n     {\n       int  popped_into;\n       int  move_to;\n       \n       thumb_pushpop (f, regs_available_for_popping, FALSE);\n \n-      /* We have popped either FP or SP.  Move whichever one\n-\t it is into the correct register.  */\n-      \n+      /* We have popped either FP or SP.\n+\t Move whichever one it is into the correct register.  */\n       popped_into = number_of_first_bit_set (regs_available_for_popping);\n       move_to     = number_of_first_bit_set (regs_to_pop);\n \n-      asm_fprintf (f, \"\\tmov\\t%s, %s\\n\", reg_names[ move_to ], reg_names[ popped_into ]);\n+      asm_fprintf (f, \"\\tmov\\t%s, %s\\n\",\n+\t\t   reg_names [move_to], reg_names [popped_into]);\n \n       regs_to_pop &= ~ (1 << move_to);\n \n       -- pops_needed;\n     }\n-\n-  /* If we still have not popped everything then we must have\n-     only had one register available to us and we are now\n-     popping the SP.  */\n   \n+  /* If we still have not popped everything then we must have only\n+     had one register available to us and we are now popping the SP.  */\n   if (pops_needed > 0)\n     {\n       int  popped_into;\n@@ -881,7 +844,7 @@ thumb_exit (f, reg_containing_return_addr)\n \n       popped_into = number_of_first_bit_set (regs_available_for_popping);\n \n-      asm_fprintf (f, \"\\tmov\\tsp, %s\\n\", reg_names[ popped_into ]);\n+      asm_fprintf (f, \"\\tmov\\tsp, %s\\n\", reg_names [popped_into]);\n \n       /*\n \tassert (regs_to_pop == (1 << STACK_POINTER))\n@@ -892,21 +855,25 @@ thumb_exit (f, reg_containing_return_addr)\n   /* If necessary restore the a4 register.  */\n   if (restore_a4)\n     {\n-      asm_fprintf (f, \"\\tmov\\t%s, %s\\n\", reg_names[ LINK_REGISTER ], reg_names[ ARG_4_REGISTER ]);\n-      asm_fprintf (f, \"\\tmov\\t%s, %s\\n\", reg_names[ ARG_4_REGISTER ], reg_names[ IP_REGISTER ]);\n-      reg_containing_return_addr = LINK_REGISTER;\n-    }\n+      if (reg_containing_return_addr != LINK_REGISTER)\n+\t{\n+\t  asm_fprintf (f, \"\\tmov\\t%s, %s\\n\",\n+\t\t       reg_names [LINK_REGISTER], reg_names [ARG_4_REGISTER]);\n+\t  reg_containing_return_addr = LINK_REGISTER;\n+\t}\n     \n-  /* Return to caller.  */\n+      asm_fprintf (f, \"\\tmov\\t%s, %s\\n\",\n+\t\t   reg_names [ARG_4_REGISTER], reg_names [IP_REGISTER]);\n+    }\n   \n-  asm_fprintf (f, \"\\tbx\\t%s\\n\", reg_names[ reg_containing_return_addr ]);\n+  /* Return to caller.  */\n+  asm_fprintf (f, \"\\tbx\\t%s\\n\", reg_names [reg_containing_return_addr]);\n }\n \n /* Emit code to push or pop registers to or from the stack.  */\n-\n static void\n thumb_pushpop (f, mask, push)\n-     FILE *f;\n+     FILE * f;\n      int mask;\n      int push;\n {\n@@ -915,7 +882,8 @@ thumb_pushpop (f, mask, push)\n \n   if (lo_mask == 0 && ! push && (mask & (1 << 15)))\n     {\n-      /* Special case.  Do not generate a POP PC statement here, do it in thumb_exit() */\n+      /* Special case.  Do not generate a POP PC statement here, do it in\n+\t thumb_exit() */\n       \n       thumb_exit (f, -1);\n       return;"}]}