{"sha": "0bdad1238b5b49ef3302321000d8eebf103e9038", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGJkYWQxMjM4YjViNDllZjMzMDIzMjEwMDBkOGVlYmYxMDNlOTAzOA==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2016-11-30T09:28:19Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2016-11-30T09:28:19Z"}, "message": "Introduce -fdump-ipa-clones dump output\n\n\t* cgraph.c (symbol_table::initialize): Initialize\n\tipa_clones_dump_file.\n\t(cgraph_node::remove): Report to ipa_clones_dump_file.\n\t* cgraph.h: Add new argument (suffix) to cloning methods.\n\t* cgraphclones.c (dump_callgraph_transformation): New function.\n\t(cgraph_node::create_clone): New argument.\n\t(cgraph_node::create_virtual_clone): Likewise.\n\t(cgraph_node::create_version_clone): Likewise.\n\t* dumpfile.c: Add .ipa-clones dump file.\n\t* dumpfile.h (enum tree_dump_index): Add TDI_clones\n\t* ipa-inline-transform.c (clone_inlined_nodes): Report operation\n\tto dump_callgraph_transformation.\n\nFrom-SVN: r243004", "tree": {"sha": "6d721cbe91abe7323a92144b80da27b5858de8ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6d721cbe91abe7323a92144b80da27b5858de8ad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0bdad1238b5b49ef3302321000d8eebf103e9038", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bdad1238b5b49ef3302321000d8eebf103e9038", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0bdad1238b5b49ef3302321000d8eebf103e9038", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bdad1238b5b49ef3302321000d8eebf103e9038/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fb61d96cf20d5bb6db8fd72ef7b528804e9f6be4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb61d96cf20d5bb6db8fd72ef7b528804e9f6be4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb61d96cf20d5bb6db8fd72ef7b528804e9f6be4"}], "stats": {"total": 94, "additions": 84, "deletions": 10}, "files": [{"sha": "da94944da1d34050db8807f6d5e14564edf3f49d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bdad1238b5b49ef3302321000d8eebf103e9038/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bdad1238b5b49ef3302321000d8eebf103e9038/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0bdad1238b5b49ef3302321000d8eebf103e9038", "patch": "@@ -1,3 +1,18 @@\n+2016-11-30  Martin Liska  <mliska@suse.cz>\n+\n+\t* cgraph.c (symbol_table::initialize): Initialize\n+\tipa_clones_dump_file.\n+\t(cgraph_node::remove): Report to ipa_clones_dump_file.\n+\t* cgraph.h: Add new argument (suffix) to cloning methods.\n+\t* cgraphclones.c (dump_callgraph_transformation): New function.\n+\t(cgraph_node::create_clone): New argument.\n+\t(cgraph_node::create_virtual_clone): Likewise.\n+\t(cgraph_node::create_version_clone): Likewise.\n+\t* dumpfile.c: Add .ipa-clones dump file.\n+\t* dumpfile.h (enum tree_dump_index): Add TDI_clones\n+\t* ipa-inline-transform.c (clone_inlined_nodes): Report operation\n+\tto dump_callgraph_transformation.\n+\n 2016-11-30  Martin Liska  <mliska@suse.cz>\n \n \tPR sanitizer/78541"}, {"sha": "867e371a3f9a6710084cb41aa9ec20a871e77505", "filename": "gcc/cgraph.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bdad1238b5b49ef3302321000d8eebf103e9038/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bdad1238b5b49ef3302321000d8eebf103e9038/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=0bdad1238b5b49ef3302321000d8eebf103e9038", "patch": "@@ -263,6 +263,9 @@ symbol_table::initialize (void)\n {\n   if (!dump_file)\n     dump_file = dump_begin (TDI_cgraph, NULL);\n+\n+  if (!ipa_clones_dump_file)\n+    ipa_clones_dump_file = dump_begin (TDI_clones, NULL);\n }\n \n /* Allocate new callgraph node and insert it into basic data structures.  */\n@@ -1815,6 +1818,12 @@ cgraph_node::remove (void)\n   cgraph_node *n;\n   int uid = this->uid;\n \n+  if (symtab->ipa_clones_dump_file && symtab->cloned_nodes.contains (this))\n+    fprintf (symtab->ipa_clones_dump_file,\n+\t     \"Callgraph removal;%s;%d;%s;%d;%d\\n\", asm_name (), order,\n+\t     DECL_SOURCE_FILE (decl), DECL_SOURCE_LINE (decl),\n+\t     DECL_SOURCE_COLUMN (decl));\n+\n   symtab->call_cgraph_removal_hooks (this);\n   remove_callers ();\n   remove_callees ();"}, {"sha": "3feed7a8d8057b60afb7bd5ed9e4d0cba2ee2548", "filename": "gcc/cgraph.h", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bdad1238b5b49ef3302321000d8eebf103e9038/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bdad1238b5b49ef3302321000d8eebf103e9038/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=0bdad1238b5b49ef3302321000d8eebf103e9038", "patch": "@@ -906,13 +906,14 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node {\n      If the new node is being inlined into another one, NEW_INLINED_TO should be\n      the outline function the new one is (even indirectly) inlined to.\n      All hooks will see this in node's global.inlined_to, when invoked.\n-     Can be NULL if the node is not inlined.  */\n+     Can be NULL if the node is not inlined.  SUFFIX is string that is appended\n+     to the original name.  */\n   cgraph_node *create_clone (tree decl, gcov_type count, int freq,\n \t\t\t     bool update_original,\n \t\t\t     vec<cgraph_edge *> redirect_callers,\n \t\t\t     bool call_duplication_hook,\n \t\t\t     cgraph_node *new_inlined_to,\n-\t\t\t     bitmap args_to_skip);\n+\t\t\t     bitmap args_to_skip, const char *suffix = NULL);\n \n   /* Create callgraph node clone with new declaration.  The actual body will\n      be copied later at compilation stage.  */\n@@ -933,11 +934,14 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node {\n \n      If non-NULL BLOCK_TO_COPY determine what basic blocks\n      was copied to prevent duplications of calls that are dead\n-     in the clone.  */\n+     in the clone.\n+\n+     SUFFIX is string that is appended to the original name.  */\n \n   cgraph_node *create_version_clone (tree new_decl,\n \t\t\t\t    vec<cgraph_edge *> redirect_callers,\n-\t\t\t\t    bitmap bbs_to_copy);\n+\t\t\t\t    bitmap bbs_to_copy,\n+\t\t\t\t    const char *suffix = NULL);\n \n   /* Perform function versioning.\n      Function versioning includes copying of the tree and\n@@ -2223,6 +2227,10 @@ class GTY((tag (\"SYMTAB\"))) symbol_table\n   /* Return symbol used to separate symbol name from suffix.  */\n   static char symbol_suffix_separator ();\n \n+  FILE* GTY ((skip)) ipa_clones_dump_file;\n+\n+  hash_set <const cgraph_node *> GTY ((skip)) cloned_nodes;\n+\n private:\n   /* Allocate new callgraph node.  */\n   inline cgraph_node * allocate_cgraph_symbol (void);\n@@ -2313,6 +2321,10 @@ tree clone_function_name (tree decl, const char *);\n void tree_function_versioning (tree, tree, vec<ipa_replace_map *, va_gc> *,\n \t\t\t       bool, bitmap, bool, bitmap, basic_block);\n \n+void dump_callgraph_transformation (const cgraph_node *original,\n+\t\t\t\t    const cgraph_node *clone,\n+\t\t\t\t    const char *suffix);\n+\n /* In cgraphbuild.c  */\n int compute_call_stmt_bb_frequency (tree, basic_block bb);\n void record_references_in_initializer (tree, bool);"}, {"sha": "349892dab67bfee6d94f6cd65a0c145fa74f481e", "filename": "gcc/cgraphclones.c", "status": "modified", "additions": 38, "deletions": 6, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bdad1238b5b49ef3302321000d8eebf103e9038/gcc%2Fcgraphclones.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bdad1238b5b49ef3302321000d8eebf103e9038/gcc%2Fcgraphclones.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphclones.c?ref=0bdad1238b5b49ef3302321000d8eebf103e9038", "patch": "@@ -381,6 +381,28 @@ cgraph_node::expand_all_artificial_thunks ()\n       e = e->next_caller;\n }\n \n+void\n+dump_callgraph_transformation (const cgraph_node *original,\n+\t\t\t       const cgraph_node *clone,\n+\t\t\t       const char *suffix)\n+{\n+  if (symtab->ipa_clones_dump_file)\n+    {\n+      fprintf (symtab->ipa_clones_dump_file,\n+\t       \"Callgraph clone;%s;%d;%s;%d;%d;%s;%d;%s;%d;%d;%s\\n\",\n+\t       original->asm_name (), original->order,\n+\t       DECL_SOURCE_FILE (original->decl),\n+\t       DECL_SOURCE_LINE (original->decl),\n+\t       DECL_SOURCE_COLUMN (original->decl), clone->asm_name (),\n+\t       clone->order, DECL_SOURCE_FILE (clone->decl),\n+\t       DECL_SOURCE_LINE (clone->decl), DECL_SOURCE_COLUMN (clone->decl),\n+\t       suffix);\n+\n+      symtab->cloned_nodes.add (original);\n+      symtab->cloned_nodes.add (clone);\n+    }\n+}\n+\n /* Create node representing clone of N executed COUNT times.  Decrease\n    the execution counts from original node too.\n    The new clone will have decl set to DECL that may or may not be the same\n@@ -403,13 +425,16 @@ cgraph_node::create_clone (tree new_decl, gcov_type gcov_count, int freq,\n \t\t\t   vec<cgraph_edge *> redirect_callers,\n \t\t\t   bool call_duplication_hook,\n \t\t\t   cgraph_node *new_inlined_to,\n-\t\t\t   bitmap args_to_skip)\n+\t\t\t   bitmap args_to_skip, const char *suffix)\n {\n   cgraph_node *new_node = symtab->create_empty ();\n   cgraph_edge *e;\n   gcov_type count_scale;\n   unsigned i;\n \n+  if (new_inlined_to)\n+    dump_callgraph_transformation (this, new_inlined_to, \"inlining to\");\n+\n   new_node->decl = new_decl;\n   new_node->register_symbol ();\n   new_node->origin = origin;\n@@ -495,6 +520,10 @@ cgraph_node::create_clone (tree new_decl, gcov_type gcov_count, int freq,\n \n   if (call_duplication_hook)\n     symtab->call_cgraph_duplication_hooks (this, new_node);\n+\n+  if (!new_inlined_to)\n+    dump_callgraph_transformation (this, new_node, suffix);\n+\n   return new_node;\n }\n \n@@ -575,7 +604,7 @@ cgraph_node::create_virtual_clone (vec<cgraph_edge *> redirect_callers,\n   SET_DECL_RTL (new_decl, NULL);\n \n   new_node = create_clone (new_decl, count, CGRAPH_FREQ_BASE, false,\n-\t\t\t   redirect_callers, false, NULL, args_to_skip);\n+\t\t\t   redirect_callers, false, NULL, args_to_skip, suffix);\n \n   /* Update the properties.\n      Make clone visible only within this translation unit.  Make sure\n@@ -863,7 +892,8 @@ update_call_expr (cgraph_node *new_version)\n cgraph_node *\n cgraph_node::create_version_clone (tree new_decl,\n \t\t\t\t  vec<cgraph_edge *> redirect_callers,\n-\t\t\t\t  bitmap bbs_to_copy)\n+\t\t\t\t  bitmap bbs_to_copy,\n+\t\t\t\t  const char *suffix)\n  {\n    cgraph_node *new_version;\n    cgraph_edge *e;\n@@ -904,6 +934,8 @@ cgraph_node::create_version_clone (tree new_decl,\n \n    symtab->call_cgraph_duplication_hooks (this, new_version);\n \n+   dump_callgraph_transformation (this, new_version, suffix);\n+\n    return new_version;\n  }\n \n@@ -931,7 +963,7 @@ cgraph_node::create_version_clone_with_body\n   (vec<cgraph_edge *> redirect_callers,\n    vec<ipa_replace_map *, va_gc> *tree_map, bitmap args_to_skip,\n    bool skip_return, bitmap bbs_to_copy, basic_block new_entry_block,\n-   const char *clone_name)\n+   const char *suffix)\n {\n   tree old_decl = decl;\n   cgraph_node *new_version_node = NULL;\n@@ -950,7 +982,7 @@ cgraph_node::create_version_clone_with_body\n       = build_function_decl_skip_args (old_decl, args_to_skip, skip_return);\n \n   /* Generate a new name for the new version. */\n-  DECL_NAME (new_decl) = clone_function_name (old_decl, clone_name);\n+  DECL_NAME (new_decl) = clone_function_name (old_decl, suffix);\n   SET_DECL_ASSEMBLER_NAME (new_decl, DECL_NAME (new_decl));\n   SET_DECL_RTL (new_decl, NULL);\n \n@@ -961,7 +993,7 @@ cgraph_node::create_version_clone_with_body\n   /* Create the new version's call-graph node.\n      and update the edges of the new node. */\n   new_version_node = create_version_clone (new_decl, redirect_callers,\n-\t\t\t\t\t  bbs_to_copy);\n+\t\t\t\t\t  bbs_to_copy, suffix);\n \n   if (ipa_transforms_to_apply.exists ())\n     new_version_node->ipa_transforms_to_apply"}, {"sha": "291d2ef905b83ad771e9bd3634ef6a5e9403af07", "filename": "gcc/dumpfile.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bdad1238b5b49ef3302321000d8eebf103e9038/gcc%2Fdumpfile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bdad1238b5b49ef3302321000d8eebf103e9038/gcc%2Fdumpfile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdumpfile.c?ref=0bdad1238b5b49ef3302321000d8eebf103e9038", "patch": "@@ -55,6 +55,8 @@ static struct dump_file_info dump_files[TDI_end] =\n    0, 0, 0, 0, 0, false, false},\n   {\".type-inheritance\", \"ipa-type-inheritance\", NULL, NULL, NULL, NULL, NULL, TDF_IPA,\n    0, 0, 0, 0, 0, false, false},\n+  {\".ipa-clones\", \"ipa-clones\", NULL, NULL, NULL, NULL, NULL, TDF_IPA,\n+   0, 0, 0, 0, 0, false, false},\n   {\".tu\", \"translation-unit\", NULL, NULL, NULL, NULL, NULL, TDF_TREE,\n    0, 0, 0, 0, 1, false, false},\n   {\".class\", \"class-hierarchy\", NULL, NULL, NULL, NULL, NULL, TDF_TREE,"}, {"sha": "9ef457048821ce95ae0f8fc7024f14c7895716aa", "filename": "gcc/dumpfile.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bdad1238b5b49ef3302321000d8eebf103e9038/gcc%2Fdumpfile.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bdad1238b5b49ef3302321000d8eebf103e9038/gcc%2Fdumpfile.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdumpfile.h?ref=0bdad1238b5b49ef3302321000d8eebf103e9038", "patch": "@@ -29,6 +29,7 @@ enum tree_dump_index\n   TDI_none,\t\t\t/* No dump */\n   TDI_cgraph,                   /* dump function call graph.  */\n   TDI_inheritance,              /* dump type inheritance graph.  */\n+  TDI_clones,\t\t\t/* dump IPA cloning decisions.  */\n   TDI_tu,\t\t\t/* dump the whole translation unit.  */\n   TDI_class,\t\t\t/* dump class hierarchy.  */\n   TDI_original,\t\t\t/* dump each function before optimizing it */"}, {"sha": "68750800f1a700c73359040125c24f159162cd7d", "filename": "gcc/ipa-inline-transform.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bdad1238b5b49ef3302321000d8eebf103e9038/gcc%2Fipa-inline-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bdad1238b5b49ef3302321000d8eebf103e9038/gcc%2Fipa-inline-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-transform.c?ref=0bdad1238b5b49ef3302321000d8eebf103e9038", "patch": "@@ -209,6 +209,9 @@ clone_inlined_nodes (struct cgraph_edge *e, bool duplicate,\n \t  duplicate = false;\n \t  e->callee->externally_visible = false;\n           update_noncloned_frequencies (e->callee, e->frequency);\n+\n+\t  dump_callgraph_transformation (e->callee, inlining_into,\n+\t\t\t\t\t \"inlining to\");\n \t}\n       else\n \t{"}]}