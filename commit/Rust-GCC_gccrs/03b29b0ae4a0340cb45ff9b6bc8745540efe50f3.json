{"sha": "03b29b0ae4a0340cb45ff9b6bc8745540efe50f3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDNiMjliMGFlNGEwMzQwY2I0NWZmOWI2YmM4NzQ1NTQwZWZlNTBmMw==", "commit": {"author": {"name": "Georg-Johann Lay", "email": "avr@gjlay.de", "date": "2012-03-21T13:20:20Z"}, "committer": {"name": "Georg-Johann Lay", "email": "gjl@gcc.gnu.org", "date": "2012-03-21T13:20:20Z"}, "message": "re PR rtl-optimization/52543 (lower-subreg.c: code bloat of 300%-400% for multi-word memory splits)\n\n\tPR rtl-optimization/52543\n\tPR target/52461\n\t* config/avr/avr-protos.h (avr_load_lpm): New prototype.\n\t* config/avr/avr.c (avr_mode_dependent_address_p): New function.\n\t(TARGET_MODE_DEPENDENT_ADDRESS_P): New define.\n\t(avr_load_libgcc_p): Restrict to __flash loads.\n\t(avr_out_lpm): Only handle 1-byte loads from __flash.\n\t(avr_load_lpm): New function.\n\t(avr_find_unused_d_reg): Remove.\n\t(avr_out_lpm_no_lpmx): Remove.\n\t(adjust_insn_length): Handle ADJUST_LEN_LOAD_LPM.\n\t* config/avr/avr.md (unspec): Add UNSPEC_LPM.\n\t(load_<mode>_libgcc): Use UNSPEC_LPM instead of MEM.\n\t(load_<mode>, load_<mode>_clobber): New insns.\n\t(mov<mode>): For multi-byte move from non-generic\n\t16-bit address spaces: Expand to load_<mode> resp.\n\tload_<mode>_clobber.\n\t(load<mode>_libgcc): Remove expander.\n\t(split-lpmx): Remove split.\n\nFrom-SVN: r185605", "tree": {"sha": "af26d28a97ede8e5b5e739322d7f8b24e251afbe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/af26d28a97ede8e5b5e739322d7f8b24e251afbe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/03b29b0ae4a0340cb45ff9b6bc8745540efe50f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03b29b0ae4a0340cb45ff9b6bc8745540efe50f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03b29b0ae4a0340cb45ff9b6bc8745540efe50f3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03b29b0ae4a0340cb45ff9b6bc8745540efe50f3/comments", "author": null, "committer": {"login": "sprintersb", "id": 8905355, "node_id": "MDQ6VXNlcjg5MDUzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8905355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sprintersb", "html_url": "https://github.com/sprintersb", "followers_url": "https://api.github.com/users/sprintersb/followers", "following_url": "https://api.github.com/users/sprintersb/following{/other_user}", "gists_url": "https://api.github.com/users/sprintersb/gists{/gist_id}", "starred_url": "https://api.github.com/users/sprintersb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sprintersb/subscriptions", "organizations_url": "https://api.github.com/users/sprintersb/orgs", "repos_url": "https://api.github.com/users/sprintersb/repos", "events_url": "https://api.github.com/users/sprintersb/events{/privacy}", "received_events_url": "https://api.github.com/users/sprintersb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "baeecefcd2b991a9f18878006964b9ac94bbde30", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/baeecefcd2b991a9f18878006964b9ac94bbde30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/baeecefcd2b991a9f18878006964b9ac94bbde30"}], "stats": {"total": 586, "additions": 244, "deletions": 342}, "files": [{"sha": "1c9f4b6220643702cfe92b430de20e09f8fd37fb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03b29b0ae4a0340cb45ff9b6bc8745540efe50f3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03b29b0ae4a0340cb45ff9b6bc8745540efe50f3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=03b29b0ae4a0340cb45ff9b6bc8745540efe50f3", "patch": "@@ -1,3 +1,25 @@\n+2012-03-21  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\tPR rtl-optimization/52543\n+\tPR target/52461\n+\t* config/avr/avr-protos.h (avr_load_lpm): New prototype.\n+\t* config/avr/avr.c (avr_mode_dependent_address_p): New function.\n+\t(TARGET_MODE_DEPENDENT_ADDRESS_P): New define.\n+\t(avr_load_libgcc_p): Restrict to __flash loads.\n+\t(avr_out_lpm): Only handle 1-byte loads from __flash.\n+\t(avr_load_lpm): New function.\n+\t(avr_find_unused_d_reg): Remove.\n+\t(avr_out_lpm_no_lpmx): Remove.\n+\t(adjust_insn_length): Handle ADJUST_LEN_LOAD_LPM.\n+\t* config/avr/avr.md (unspec): Add UNSPEC_LPM.\n+\t(load_<mode>_libgcc): Use UNSPEC_LPM instead of MEM.\n+\t(load_<mode>, load_<mode>_clobber): New insns.\n+\t(mov<mode>): For multi-byte move from non-generic\n+\t16-bit address spaces: Expand to load_<mode> resp.\n+\tload_<mode>_clobber.\n+\t(load<mode>_libgcc): Remove expander.\n+\t(split-lpmx): Remove split.\n+\n 2012-03-21  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* neon.md (neon_vget_lanev2di): Use gen_lowpart and gen_highpart."}, {"sha": "158a7be5b3ee656447c03b66b2610568815fd850", "filename": "gcc/config/avr/avr-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03b29b0ae4a0340cb45ff9b6bc8745540efe50f3/gcc%2Fconfig%2Favr%2Favr-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03b29b0ae4a0340cb45ff9b6bc8745540efe50f3/gcc%2Fconfig%2Favr%2Favr-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-protos.h?ref=03b29b0ae4a0340cb45ff9b6bc8745540efe50f3", "patch": "@@ -75,6 +75,8 @@ extern const char *avr_out_ashlpsi3 (rtx, rtx*, int*);\n extern const char *avr_out_ashrpsi3 (rtx, rtx*, int*);\n extern const char *avr_out_lshrpsi3 (rtx, rtx*, int*);\n \n+extern const char* avr_load_lpm (rtx, rtx*, int*);\n+\n extern bool avr_rotate_bytes (rtx operands[]);\n \n extern void expand_prologue (void);"}, {"sha": "341fe9b2f85f7765002015758c1979a892494ef9", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 127, "deletions": 276, "changes": 403, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03b29b0ae4a0340cb45ff9b6bc8745540efe50f3/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03b29b0ae4a0340cb45ff9b6bc8745540efe50f3/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=03b29b0ae4a0340cb45ff9b6bc8745540efe50f3", "patch": "@@ -1457,6 +1457,22 @@ avr_cannot_modify_jumps_p (void)\n }\n \n \n+/* Implement `TARGET_MODE_DEPENDENT_ADDRESS_P'.  */\n+\n+/* FIXME:  PSImode addresses are not mode-dependent in themselves.\n+      This hook just serves to hack around PR rtl-optimization/52543 by\n+      claiming that PSImode addresses (which are used for the 24-bit\n+      address space __memx) were mode-dependent so that lower-subreg.s\n+      will skip these addresses.  See also the similar FIXME comment along\n+      with mov<mode> expanders in avr.md.  */\n+\n+static bool\n+avr_mode_dependent_address_p (const_rtx addr)\n+{\n+  return GET_MODE (addr) != Pmode;\n+}\n+\n+\n /* Helper function for `avr_legitimate_address_p'.  */\n \n static inline bool\n@@ -2469,7 +2485,8 @@ avr_load_libgcc_p (rtx op)\n         \n   return (n_bytes > 2\n           && !AVR_HAVE_LPMX\n-          && avr_mem_flash_p (op));\n+          && MEM_P (op)\n+          && MEM_ADDR_SPACE (op) == ADDR_SPACE_FLASH);\n }\n \n /* Return true if a value of mode MODE is read by __xload_* function.  */\n@@ -2484,155 +2501,6 @@ avr_xload_libgcc_p (enum machine_mode mode)\n }\n \n \n-/* Find an unused d-register to be used as scratch in INSN.\n-   EXCLUDE is either NULL_RTX or some register. In the case where EXCLUDE\n-   is a register, skip all possible return values that overlap EXCLUDE.\n-   The policy for the returned register is similar to that of\n-   `reg_unused_after', i.e. the returned register may overlap the SET_DEST\n-   of INSN.\n-\n-   Return a QImode d-register or NULL_RTX if nothing found.  */\n-\n-static rtx\n-avr_find_unused_d_reg (rtx insn, rtx exclude)\n-{\n-  int regno;\n-  bool isr_p = (interrupt_function_p (current_function_decl)\n-                || signal_function_p (current_function_decl));\n-\n-  for (regno = 16; regno < 32; regno++)\n-    {\n-      rtx reg = all_regs_rtx[regno];\n-      \n-      if ((exclude\n-           && reg_overlap_mentioned_p (exclude, reg))\n-          || fixed_regs[regno])\n-        {\n-          continue;\n-        }\n-\n-      /* Try non-live register */\n-\n-      if (!df_regs_ever_live_p (regno)\n-          && (TREE_THIS_VOLATILE (current_function_decl)\n-              || cfun->machine->is_OS_task\n-              || cfun->machine->is_OS_main\n-              || (!isr_p && call_used_regs[regno])))\n-        {\n-          return reg;\n-        }\n-\n-      /* Any live register can be used if it is unused after.\n-         Prologue/epilogue will care for it as needed.  */\n-      \n-      if (df_regs_ever_live_p (regno)\n-          && reg_unused_after (insn, reg))\n-        {\n-          return reg;\n-        }\n-    }\n-\n-  return NULL_RTX;\n-}\n-\n-\n-/* Helper function for the next function in the case where only restricted\n-   version of LPM instruction is available.  */\n-\n-static const char*\n-avr_out_lpm_no_lpmx (rtx insn, rtx *xop, int *plen)\n-{\n-  rtx dest = xop[0];\n-  rtx addr = xop[1];\n-  int n_bytes = GET_MODE_SIZE (GET_MODE (dest));\n-  int regno_dest;\n-\n-  regno_dest = REGNO (dest);\n-\n-  /* The implicit target register of LPM.  */\n-  xop[3] = lpm_reg_rtx;\n-\n-  switch (GET_CODE (addr))\n-    {\n-    default:\n-      gcc_unreachable();\n-\n-    case REG:\n-\n-      gcc_assert (REG_Z == REGNO (addr));\n-\n-      switch (n_bytes)\n-        {\n-        default:\n-          gcc_unreachable();\n-\n-        case 1:\n-          avr_asm_len (\"%4lpm\", xop, plen, 1);\n-\n-          if (regno_dest != LPM_REGNO)\n-            avr_asm_len (\"mov %0,%3\", xop, plen, 1);\n-\n-          return \"\";\n-\n-        case 2:\n-          if (REGNO (dest) == REG_Z)\n-            return avr_asm_len (\"%4lpm\"      CR_TAB\n-                                \"push %3\"    CR_TAB\n-                                \"adiw %2,1\"  CR_TAB\n-                                \"%4lpm\"      CR_TAB\n-                                \"mov %B0,%3\" CR_TAB\n-                                \"pop %A0\", xop, plen, 6);\n-          \n-          avr_asm_len (\"%4lpm\"      CR_TAB\n-                       \"mov %A0,%3\" CR_TAB\n-                       \"adiw %2,1\"  CR_TAB\n-                       \"%4lpm\"      CR_TAB\n-                       \"mov %B0,%3\", xop, plen, 5);\n-                \n-          if (!reg_unused_after (insn, addr))\n-            avr_asm_len (\"sbiw %2,1\", xop, plen, 1);\n-          \n-          break; /* 2 */\n-        }\n-      \n-      break; /* REG */\n-\n-    case POST_INC:\n-\n-      gcc_assert (REG_Z == REGNO (XEXP (addr, 0))\n-                  && n_bytes <= 4);\n-\n-      if (regno_dest == LPM_REGNO)\n-        avr_asm_len (\"%4lpm\"      CR_TAB\n-                     \"adiw %2,1\", xop, plen, 2);\n-      else\n-        avr_asm_len (\"%4lpm\"      CR_TAB\n-                     \"mov %A0,%3\" CR_TAB\n-                     \"adiw %2,1\", xop, plen, 3);\n-\n-      if (n_bytes >= 2)\n-        avr_asm_len (\"%4lpm\"      CR_TAB\n-                     \"mov %B0,%3\" CR_TAB\n-                     \"adiw %2,1\", xop, plen, 3);\n-\n-      if (n_bytes >= 3)\n-        avr_asm_len (\"%4lpm\"      CR_TAB\n-                     \"mov %C0,%3\" CR_TAB\n-                     \"adiw %2,1\", xop, plen, 3);\n-\n-      if (n_bytes >= 4)\n-        avr_asm_len (\"%4lpm\"      CR_TAB\n-                     \"mov %D0,%3\" CR_TAB\n-                     \"adiw %2,1\", xop, plen, 3);\n-\n-      break; /* POST_INC */\n-      \n-    } /* switch CODE (addr) */\n-      \n-  return \"\";\n-}\n-\n-\n /* If PLEN == NULL: Ouput instructions to load a value from a memory location\n    OP[1] in AS1 to register OP[0].\n    If PLEN != 0 set *PLEN to the length in words of the instruction sequence.\n@@ -2641,13 +2509,11 @@ avr_out_lpm_no_lpmx (rtx insn, rtx *xop, int *plen)\n static const char*\n avr_out_lpm (rtx insn, rtx *op, int *plen)\n {\n-  rtx xop[6];\n+  rtx xop[3];\n   rtx dest = op[0];\n   rtx src = SET_SRC (single_set (insn));\n   rtx addr;\n   int n_bytes = GET_MODE_SIZE (GET_MODE (dest));\n-  int regno_dest;\n-  int segment;\n   RTX_CODE code;\n   addr_space_t as = MEM_ADDR_SPACE (src);\n \n@@ -2668,136 +2534,120 @@ avr_out_lpm (rtx insn, rtx *op, int *plen)\n   gcc_assert (REG_P (dest));\n   gcc_assert (REG == code || POST_INC == code);\n \n-  xop[0] = dest;\n-  xop[1] = addr;\n-  xop[2] = lpm_addr_reg_rtx;\n-  xop[4] = xstring_empty;\n-  xop[5] = tmp_reg_rtx;\n-\n-  regno_dest = REGNO (dest);\n-\n-  segment = avr_addrspace[as].segment;\n-\n-  /* Set RAMPZ as needed.  */\n-\n-  if (segment)\n-    {\n-      xop[4] = GEN_INT (segment);\n-      \n-      if (xop[3] = avr_find_unused_d_reg (insn, lpm_addr_reg_rtx),\n-          xop[3])\n-        {\n-          avr_asm_len (\"ldi %3,%4\" CR_TAB\n-                       \"out __RAMPZ__,%3\", xop, plen, 2);\n-        }\n-      else if (segment == 1)\n-        {\n-          avr_asm_len (\"clr %5\" CR_TAB\n-                       \"inc %5\" CR_TAB\n-                       \"out __RAMPZ__,%5\", xop, plen, 3);\n-        }\n-      else\n-        {\n-          avr_asm_len (\"mov %5,%2\"         CR_TAB\n-                       \"ldi %2,%4\"         CR_TAB\n-                       \"out __RAMPZ__,%2\"  CR_TAB\n-                       \"mov %2,%5\", xop, plen, 4);\n-        }\n-      \n-      xop[4] = xstring_e;\n-\n-      if (!AVR_HAVE_ELPMX)\n-        return avr_out_lpm_no_lpmx (insn, xop, plen);\n-    }\n-  else if (!AVR_HAVE_LPMX)\n-    {\n-      return avr_out_lpm_no_lpmx (insn, xop, plen);\n-    }\n+  /* Only 1-byte moves from __flash are representes as open coded\n+     mov insns.  All other loads from flash are not handled here but\n+     by some UNSPEC instead, see respective FIXME in machine description.  */\n+  \n+  gcc_assert (as == ADDR_SPACE_FLASH);\n+  gcc_assert (n_bytes == 1);\n \n-  /* We have [E]LPMX: Output reading from Flash the comfortable way.  */\n+  xop[0] = dest;\n+  xop[1] = lpm_addr_reg_rtx;\n+  xop[2] = lpm_reg_rtx;\n \n-  switch (GET_CODE (addr))\n+  switch (code)\n     {\n     default:\n       gcc_unreachable();\n \n     case REG:\n \n       gcc_assert (REG_Z == REGNO (addr));\n+      \n+      return AVR_HAVE_LPMX\n+        ? avr_asm_len (\"lpm %0,%a1\", xop, plen, 1)\n+        : avr_asm_len (\"lpm\" CR_TAB\n+                       \"mov %0,%2\", xop, plen, 2);\n+      \n+    case POST_INC:\n+      \n+      gcc_assert (REG_Z == REGNO (XEXP (addr, 0)));\n \n-      switch (n_bytes)\n-        {\n-        default:\n-          gcc_unreachable();\n-\n-        case 1:\n-          return avr_asm_len (\"%4lpm %0,%a2\", xop, plen, 1);\n+      return AVR_HAVE_LPMX\n+        ? avr_asm_len (\"lpm %0,%a1+\", xop, plen, 1)\n+        : avr_asm_len (\"lpm\"        CR_TAB\n+                       \"adiw %1, 1\" CR_TAB\n+                       \"mov %0,%2\", xop, plen, 3);\n+    }\n \n-        case 2:\n-          if (REGNO (dest) == REG_Z)\n-            return avr_asm_len (\"%4lpm %5,%a2+\" CR_TAB\n-                                \"%4lpm %B0,%a2\" CR_TAB\n-                                \"mov %A0,%5\", xop, plen, 3);\n-          else\n-            {\n-              avr_asm_len (\"%4lpm %A0,%a2+\" CR_TAB\n-                           \"%4lpm %B0,%a2\", xop, plen, 2);\n-                \n-              if (!reg_unused_after (insn, addr))\n-                avr_asm_len (\"sbiw %2,1\", xop, plen, 1);\n-            }\n-          \n-          break; /* 2 */\n+  return \"\";\n+}\n \n-        case 3:\n \n-          avr_asm_len (\"%4lpm %A0,%a2+\" CR_TAB\n-                       \"%4lpm %B0,%a2+\" CR_TAB\n-                       \"%4lpm %C0,%a2\", xop, plen, 3);\n-                \n-          if (!reg_unused_after (insn, addr))\n-            avr_asm_len (\"sbiw %2,2\", xop, plen, 1);\n+/* If PLEN == NULL: Ouput instructions to load $0 with a value from\n+   flash address $1:Z.  If $1 = 0 we can use LPM to read, otherwise\n+   use ELPM.\n+   If PLEN != 0 set *PLEN to the length in words of the instruction sequence.\n+   Return \"\".  */\n \n-          break; /* 3 */\n+const char*\n+avr_load_lpm (rtx insn, rtx *op, int *plen)\n+{\n+  rtx xop[4];\n+  int n, n_bytes = GET_MODE_SIZE (GET_MODE (op[0]));\n+  rtx xsegment = op[1];\n+  bool clobber_z = PARALLEL == GET_CODE (PATTERN (insn));\n+  bool r30_in_tmp = false;\n+  \n+  if (plen)\n+    *plen = 0;\n+  \n+  xop[1] = lpm_addr_reg_rtx;\n+  xop[2] = lpm_reg_rtx;\n+  xop[3] = xstring_empty;\n+  \n+  /* Set RAMPZ as needed.  */\n+  \n+  if (REG_P (xsegment))\n+    {\n+      avr_asm_len (\"out __RAMPZ__,%0\", &xsegment, plen, 1);\n+      xop[3] = xstring_e;\n+    }\n+  \n+  /* Load the individual bytes from LSB to MSB.  */\n+  \n+  for (n = 0; n < n_bytes; n++)\n+    {\n+      xop[0] = all_regs_rtx[REGNO (op[0]) + n];\n       \n-        case 4:\n-\n-          avr_asm_len (\"%4lpm %A0,%a2+\" CR_TAB\n-                       \"%4lpm %B0,%a2+\", xop, plen, 2);\n-          \n-          if (REGNO (dest) == REG_Z - 2)\n-            return avr_asm_len (\"%4lpm %5,%a2+\" CR_TAB\n-                                \"%4lpm %C0,%a2\"          CR_TAB\n-                                \"mov %D0,%5\", xop, plen, 3);\n-          else\n+      if ((CONST_INT_P (xsegment) && AVR_HAVE_LPMX)\n+          || (REG_P (xsegment) && AVR_HAVE_ELPMX))\n+        {\n+          if (n == n_bytes-1)\n+            avr_asm_len (\"%3lpm %0,%a1\", xop, plen, 1);\n+          else if (REGNO (xop[0]) == REG_Z)\n             {\n-              avr_asm_len (\"%4lpm %C0,%a2+\" CR_TAB\n-                           \"%4lpm %D0,%a2\", xop, plen, 2);\n-                \n-              if (!reg_unused_after (insn, addr))\n-                avr_asm_len (\"sbiw %2,3\", xop, plen, 1);\n+              avr_asm_len (\"%3lpm %2,%a1+\", xop, plen, 1);\n+              r30_in_tmp = true;\n             }\n+          else\n+            avr_asm_len (\"%3lpm %0,%a1+\", xop, plen, 1);\n+        }\n+      else\n+        {\n+          gcc_assert (clobber_z);\n+          \n+          avr_asm_len (\"%3lpm\" CR_TAB\n+                       \"mov %0,%2\", xop, plen, 2);\n \n-          break; /* 4 */\n-        } /* n_bytes */\n-      \n-      break; /* REG */\n-\n-    case POST_INC:\n-\n-      gcc_assert (REG_Z == REGNO (XEXP (addr, 0))\n-                  && n_bytes <= 4);\n-\n-      avr_asm_len                    (\"%4lpm %A0,%a2+\", xop, plen, 1);\n-      if (n_bytes >= 2)  avr_asm_len (\"%4lpm %B0,%a2+\", xop, plen, 1);\n-      if (n_bytes >= 3)  avr_asm_len (\"%4lpm %C0,%a2+\", xop, plen, 1);\n-      if (n_bytes >= 4)  avr_asm_len (\"%4lpm %D0,%a2+\", xop, plen, 1);\n-\n-      break; /* POST_INC */\n-\n-    } /* switch CODE (addr) */\n-\n-  if (xop[4] == xstring_e && AVR_HAVE_RAMPD)\n+          if (n != n_bytes-1)\n+            avr_asm_len (\"adiw %1,1\", xop, plen, 1);\n+        }\n+    }\n+  \n+  if (r30_in_tmp)\n+    avr_asm_len (\"mov %1,%2\", xop, plen, 1);\n+  \n+  if (!clobber_z\n+      && n_bytes > 1\n+      && !reg_unused_after (insn, lpm_addr_reg_rtx)\n+      && !reg_overlap_mentioned_p (op[0], lpm_addr_reg_rtx))\n+    {\n+      xop[2] = GEN_INT (n_bytes-1);\n+      avr_asm_len (\"sbiw %1,%2\", xop, plen, 1);\n+    }\n+  \n+  if (REG_P (xsegment) && AVR_HAVE_RAMPD)\n     {\n       /* Reset RAMPZ to 0 so that EBI devices don't read garbage from RAM */\n       \n@@ -2836,24 +2686,20 @@ avr_out_xload (rtx insn ATTRIBUTE_UNUSED, rtx *op, int *plen)\n }\n \n \n-const char *\n-output_movqi (rtx insn, rtx operands[], int *l)\n+const char*\n+output_movqi (rtx insn, rtx operands[], int *real_l)\n {\n-  int dummy;\n   rtx dest = operands[0];\n   rtx src = operands[1];\n-  int *real_l = l;\n   \n   if (avr_mem_flash_p (src)\n       || avr_mem_flash_p (dest))\n     {\n       return avr_out_lpm (insn, operands, real_l);\n     }\n \n-  if (!l)\n-    l = &dummy;\n-\n-  *l = 1;\n+  if (real_l)\n+    *real_l = 1;\n   \n   if (register_operand (dest, QImode))\n     {\n@@ -2871,10 +2717,10 @@ output_movqi (rtx insn, rtx operands[], int *l)\n           output_reload_in_const (operands, NULL_RTX, real_l, false);\n           return \"\";\n         }\n-      else if (GET_CODE (src) == MEM)\n+      else if (MEM_P (src))\n \treturn out_movqi_r_mr (insn, operands, real_l); /* mov r,m */\n     }\n-  else if (GET_CODE (dest) == MEM)\n+  else if (MEM_P (dest))\n     {\n       rtx xop[2];\n \n@@ -6575,6 +6421,7 @@ adjust_insn_length (rtx insn, int len)\n     case ADJUST_LEN_MOV32: output_movsisf (insn, op, &len); break;\n     case ADJUST_LEN_MOVMEM: avr_out_movmem (insn, op, &len); break;\n     case ADJUST_LEN_XLOAD: avr_out_xload (insn, op, &len); break;\n+    case ADJUST_LEN_LOAD_LPM: avr_load_lpm (insn, op, &len); break;\n \n     case ADJUST_LEN_TSTHI: avr_out_tsthi (insn, op, &len); break;\n     case ADJUST_LEN_TSTPSI: avr_out_tstpsi (insn, op, &len); break;\n@@ -9610,7 +9457,8 @@ avr_addr_space_pointer_mode (addr_space_t as)\n static bool\n avr_reg_ok_for_pgm_addr (rtx reg, bool strict)\n {\n-  gcc_assert (REG_P (reg));\n+  if (!REG_P (reg))\n+    return false;\n \n   if (strict)\n     {\n@@ -11061,6 +10909,9 @@ avr_fold_builtin (tree fndecl, int n_args ATTRIBUTE_UNUSED, tree *arg,\n #undef  TARGET_ADDR_SPACE_LEGITIMIZE_ADDRESS\n #define TARGET_ADDR_SPACE_LEGITIMIZE_ADDRESS avr_addr_space_legitimize_address\n \n+#undef  TARGET_MODE_DEPENDENT_ADDRESS_P\n+#define TARGET_MODE_DEPENDENT_ADDRESS_P avr_mode_dependent_address_p\n+\n #undef  TARGET_PRINT_OPERAND\n #define TARGET_PRINT_OPERAND avr_print_operand\n #undef  TARGET_PRINT_OPERAND_ADDRESS"}, {"sha": "85a0f2896cff9b09934192a0ef5cdbcf4c2fb7fe", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 93, "deletions": 66, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03b29b0ae4a0340cb45ff9b6bc8745540efe50f3/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03b29b0ae4a0340cb45ff9b6bc8745540efe50f3/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=03b29b0ae4a0340cb45ff9b6bc8745540efe50f3", "patch": "@@ -63,6 +63,7 @@\n   [UNSPEC_STRLEN\n    UNSPEC_MOVMEM\n    UNSPEC_INDEX_JMP\n+   UNSPEC_LPM\n    UNSPEC_FMUL\n    UNSPEC_FMULS\n    UNSPEC_FMULSU\n@@ -140,7 +141,7 @@\n   \"out_bitop, out_plus, out_plus_noclobber, plus64, addto_sp,\n    tsthi, tstpsi, tstsi, compare, compare64, call,\n    mov8, mov16, mov24, mov32, reload_in16, reload_in24, reload_in32,\n-   xload, movmem,\n+   xload, movmem, load_lpm,\n    ashlqi, ashrqi, lshrqi,\n    ashlhi, ashrhi, lshrhi,\n    ashlsi, ashrsi, lshrsi,\n@@ -364,43 +365,60 @@\n ;;========================================================================\n ;; Move stuff around\n \n-;; \"loadqi_libgcc\"\n-;; \"loadhi_libgcc\"\n-;; \"loadpsi_libgcc\"    \n-;; \"loadsi_libgcc\"    \n-;; \"loadsf_libgcc\"    \n-(define_expand \"load<mode>_libgcc\"\n-  [(set (match_dup 3)\n-        (match_dup 2))\n-   (set (reg:MOVMODE 22)\n-        (match_operand:MOVMODE 1 \"memory_operand\" \"\"))\n-   (set (match_operand:MOVMODE 0 \"register_operand\" \"\")\n-        (reg:MOVMODE 22))]\n-  \"avr_load_libgcc_p (operands[1])\"\n-  {\n-    operands[3] = gen_rtx_REG (HImode, REG_Z);\n-    operands[2] = force_operand (XEXP (operands[1], 0), NULL_RTX);\n-    operands[1] = replace_equiv_address (operands[1], operands[3]);\n-    set_mem_addr_space (operands[1], ADDR_SPACE_FLASH);\n-  })\n+;; Represent a load from __flash that needs libgcc support as UNSPEC.\n+;; This is legal because we read from non-changing memory.\n+;; For rationale see the FIXME below.\n \n-;; \"load_qi_libgcc\"\n-;; \"load_hi_libgcc\"\n ;; \"load_psi_libgcc\"    \n ;; \"load_si_libgcc\"    \n ;; \"load_sf_libgcc\"    \n (define_insn \"load_<mode>_libgcc\"\n   [(set (reg:MOVMODE 22)\n-        (match_operand:MOVMODE 0 \"memory_operand\" \"m,m\"))]\n-  \"avr_load_libgcc_p (operands[0])\n-   && REG_P (XEXP (operands[0], 0))\n-   && REG_Z == REGNO (XEXP (operands[0], 0))\"\n+        (unspec:MOVMODE [(reg:HI REG_Z)]\n+                        UNSPEC_LPM))]\n+  \"\"\n   {\n-    operands[0] = GEN_INT (GET_MODE_SIZE (<MODE>mode));\n-    return \"%~call __load_%0\";\n+    rtx n_bytes = GEN_INT (GET_MODE_SIZE (<MODE>mode));\n+    output_asm_insn (\"%~call __load_%0\", &n_bytes);\n+    return \"\";\n   }\n-  [(set_attr \"length\" \"1,2\")\n-   (set_attr \"isa\" \"rjmp,jmp\")\n+  [(set_attr \"type\" \"xcall\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+\n+;; Similar for inline reads from flash.  We use UNSPEC instead\n+;; of MEM for the same reason as above: PR52543.\n+;; $1 contains the memory segment.\n+\n+(define_insn \"load_<mode>\"\n+  [(set (match_operand:MOVMODE 0 \"register_operand\" \"=r\")\n+        (unspec:MOVMODE [(reg:HI REG_Z)\n+                         (match_operand:QI 1 \"reg_or_0_operand\" \"rL\")]\n+                        UNSPEC_LPM))]\n+  \"(CONST_INT_P (operands[1]) && AVR_HAVE_LPMX)\n+   || (REG_P (operands[1]) && AVR_HAVE_ELPMX)\"\n+  {\n+    return avr_load_lpm (insn, operands, NULL);\n+  }\n+  [(set_attr \"adjust_len\" \"load_lpm\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+\n+;; Similar to above for the complementary situation when there is no [E]LPMx.\n+;; Clobber Z in that case.\n+\n+(define_insn \"load_<mode>_clobber\"\n+  [(set (match_operand:MOVMODE 0 \"register_operand\" \"=r\")\n+        (unspec:MOVMODE [(reg:HI REG_Z)\n+                         (match_operand:QI 1 \"reg_or_0_operand\" \"rL\")]\n+                        UNSPEC_LPM))\n+   (clobber (reg:HI REG_Z))]\n+  \"!((CONST_INT_P (operands[1]) && AVR_HAVE_LPMX)\n+     || (REG_P (operands[1]) && AVR_HAVE_ELPMX))\"\n+  {\n+    return avr_load_lpm (insn, operands, NULL);\n+  }\n+  [(set_attr \"adjust_len\" \"load_lpm\")\n    (set_attr \"cc\" \"clobber\")])\n \n \n@@ -549,12 +567,55 @@\n       DONE;\n     }\n \n+    /* For old devices without LPMx, prefer __flash loads per libcall.  */\n+\n     if (avr_load_libgcc_p (src))\n       {\n-        /* For the small devices, do loads per libgcc call.  */\n-        emit_insn (gen_load<mode>_libgcc (dest, src));\n+        emit_move_insn (gen_rtx_REG (Pmode, REG_Z),\n+                        force_reg (Pmode, XEXP (src, 0)));\n+\n+        emit_insn (gen_load_<mode>_libgcc ());\n+        emit_move_insn (dest, gen_rtx_REG (<MODE>mode, 22));\n+        DONE;\n+      }\n+\n+    /* ; FIXME:  Hack around PR rtl-optimization/52543.\n+       ; lower-subreg.c splits loads from the 16-bit address spaces which\n+       ; causes code bloat because each load need his setting of RAMPZ.\n+       ; Moreover, the split will happen in such a way that the loads don't\n+       ; take advantage of POST_INC addressing.  Thus, we use UNSPEC to\n+       ; represent these loads instead.  Notice that this is legitimate\n+       ; because the memory content does not change:  Loads from the same\n+       ; address will yield the same value.\n+       ; POST_INC addressing would make the addresses mode_dependent and could\n+       ; work around that PR, too.  However, notice that it is *not* legitimate\n+       ; to expand to POST_INC at expand time:  The following passes assert\n+       ; that pre-/post-modify addressing is introduced by .auto_inc_dec and\n+       ; does not exist before that pass.  */\n+\n+    if (avr_mem_flash_p (src)\n+        && (GET_MODE_SIZE (<MODE>mode) > 1\n+            || MEM_ADDR_SPACE (src) != ADDR_SPACE_FLASH))\n+      {\n+        rtx xsegment = GEN_INT (avr_addrspace[MEM_ADDR_SPACE (src)].segment);\n+        if (!AVR_HAVE_ELPM)\n+          xsegment = const0_rtx;\n+        if (xsegment != const0_rtx)\n+          xsegment = force_reg (QImode, xsegment);\n+\n+        emit_move_insn (gen_rtx_REG (Pmode, REG_Z),\n+                        force_reg (Pmode, XEXP (src, 0)));\n+\n+        if ((CONST_INT_P (xsegment) && AVR_HAVE_LPMX)\n+            || (REG_P (xsegment) && AVR_HAVE_ELPMX))\n+          emit_insn (gen_load_<mode> (dest, xsegment));\n+        else\n+          emit_insn (gen_load_<mode>_clobber (dest, xsegment));\n         DONE;\n       }\n+\n+    /* ; The only address-space for which we use plain MEM and reload\n+       ; machinery are 1-byte loads from __flash.  */\n   })\n \n ;;========================================================================\n@@ -694,40 +755,6 @@\n     operands[5] = gen_rtx_REG (HImode, REGNO (operands[3]));\n   })\n \n-;; For LPM loads from AS1 we split \n-;;    R = *Z\n-;; to\n-;;    R = *Z++\n-;;    Z = Z - sizeof (R)\n-;;\n-;; so that the second instruction can be optimized out.\n-\n-(define_split ; \"split-lpmx\"\n-  [(set (match_operand:HISI 0 \"register_operand\" \"\")\n-        (match_operand:HISI 1 \"memory_operand\" \"\"))]\n-  \"reload_completed\n-   && AVR_HAVE_LPMX\"\n-  [(set (match_dup 0)\n-        (match_dup 2))\n-   (set (match_dup 3)\n-        (plus:HI (match_dup 3)\n-                 (match_dup 4)))]\n-  {\n-     rtx addr = XEXP (operands[1], 0);\n-\n-     if (!avr_mem_flash_p (operands[1])\n-         || !REG_P (addr)\n-         || reg_overlap_mentioned_p (addr, operands[0]))\n-       {\n-         FAIL;\n-       }\n-\n-    operands[2] = replace_equiv_address (operands[1],\n-                                         gen_rtx_POST_INC (Pmode, addr));\n-    operands[3] = addr;\n-    operands[4] = gen_int_mode (-GET_MODE_SIZE (<MODE>mode), HImode);\n-  })\n-\n ;;==========================================================================\n ;; xpointer move (24 bit)\n   "}]}