{"sha": "d03431d0f59f5aa5c2a8e2e5ea94ea1660b240f8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDAzNDMxZDBmNTlmNWFhNWMyYThlMmU1ZWE5NGVhMTY2MGIyNDBmOA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2019-11-15T12:48:34Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2019-11-15T12:48:34Z"}, "message": "re PR tree-optimization/92324 (ICE in expand_direct_optab_fn, at internal-fn.c:2890)\n\n2019-11-15  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/92324\n\t* tree-vect-loop.c (vect_create_epilog_for_reduction): Fix\n\tsingedness of SLP reduction epilouge operations.  Also reduce\n\tthe vector width for SLP reductions before doing elementwise\n\toperations if possible.\n\n\t* gcc.dg/vect/pr92324-4.c: New testcase.\n\nFrom-SVN: r278289", "tree": {"sha": "224553aa798f2c7b6d41788fe7abd395243b11eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/224553aa798f2c7b6d41788fe7abd395243b11eb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d03431d0f59f5aa5c2a8e2e5ea94ea1660b240f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d03431d0f59f5aa5c2a8e2e5ea94ea1660b240f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d03431d0f59f5aa5c2a8e2e5ea94ea1660b240f8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d03431d0f59f5aa5c2a8e2e5ea94ea1660b240f8/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8eea62d8ab9c621b9d46926eb4c5380fe5606e4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8eea62d8ab9c621b9d46926eb4c5380fe5606e4f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8eea62d8ab9c621b9d46926eb4c5380fe5606e4f"}], "stats": {"total": 111, "additions": 81, "deletions": 30}, "files": [{"sha": "5eb21e7e4a8fd4750557c16ada2b8f0471163ccc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d03431d0f59f5aa5c2a8e2e5ea94ea1660b240f8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d03431d0f59f5aa5c2a8e2e5ea94ea1660b240f8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d03431d0f59f5aa5c2a8e2e5ea94ea1660b240f8", "patch": "@@ -1,3 +1,11 @@\n+2019-11-15  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/92324\n+\t* tree-vect-loop.c (vect_create_epilog_for_reduction): Fix\n+\tsingedness of SLP reduction epilouge operations.  Also reduce\n+\tthe vector width for SLP reductions before doing elementwise\n+\toperations if possible.\n+\n 2019-11-15  Matthew Malcomson  <matthew.malcomson@arm.com>\n \n \t* passes.c (skip_pass): Set epilogue_completed if skipping the"}, {"sha": "4377c4c38c1ca45b65652b8aa9d3fe9784eeaa1f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d03431d0f59f5aa5c2a8e2e5ea94ea1660b240f8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d03431d0f59f5aa5c2a8e2e5ea94ea1660b240f8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d03431d0f59f5aa5c2a8e2e5ea94ea1660b240f8", "patch": "@@ -1,3 +1,8 @@\n+2019-11-15  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/92324\n+\t* gcc.dg/vect/pr92324-4.c: New testcase.\n+\n 2019-11-15  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/69654"}, {"sha": "834798522336ba6909301dcc46947753b5bd6ba3", "filename": "gcc/testsuite/gcc.dg/vect/pr92324-4.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d03431d0f59f5aa5c2a8e2e5ea94ea1660b240f8/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr92324-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d03431d0f59f5aa5c2a8e2e5ea94ea1660b240f8/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr92324-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr92324-4.c?ref=d03431d0f59f5aa5c2a8e2e5ea94ea1660b240f8", "patch": "@@ -0,0 +1,30 @@\n+#include \"tree-vect.h\"\n+\n+unsigned a[1024];\n+int gres1, gres2;\n+\n+int __attribute__((noipa))\n+foo (int n)\n+{\n+  int res1 = 0;\n+  int res2 = 0;\n+  for (int i = 0; i < n; ++i)\n+    {\n+      res1 = res1 > a[2*i] ? res1 : a[2*i];\n+      res2 = res2 > a[2*i+1] ? res2 : a[2*i+1];\n+    }\n+  gres1 = res1;\n+  gres2 = res2;\n+}\n+\n+int main ()\n+{\n+  check_vect ();\n+  a[30] = (unsigned)__INT_MAX__ + 1;\n+  a[31] = (unsigned)__INT_MAX__ + 1;\n+  foo (16);\n+  if (gres1 != -__INT_MAX__ - 1\n+      || gres2 != -__INT_MAX__ - 1)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "389ef1706070298bf490eed8e138b1cec8aa0ba4", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 38, "deletions": 30, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d03431d0f59f5aa5c2a8e2e5ea94ea1660b240f8/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d03431d0f59f5aa5c2a8e2e5ea94ea1660b240f8/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=d03431d0f59f5aa5c2a8e2e5ea94ea1660b240f8", "patch": "@@ -4930,13 +4930,30 @@ vect_create_epilog_for_reduction (stmt_vec_info stmt_info,\n       bool reduce_with_shift;\n       tree vec_temp;\n \n+      gcc_assert (slp_reduc || new_phis.length () == 1);\n+\n       /* See if the target wants to do the final (shift) reduction\n \t in a vector mode of smaller size and first reduce upper/lower\n \t halves against each other.  */\n       enum machine_mode mode1 = mode;\n       tree stype = TREE_TYPE (vectype);\n       unsigned nunits = TYPE_VECTOR_SUBPARTS (vectype).to_constant ();\n       unsigned nunits1 = nunits;\n+      if ((mode1 = targetm.vectorize.split_reduction (mode)) != mode\n+\t  && new_phis.length () == 1)\n+\t{\n+\t  nunits1 = GET_MODE_NUNITS (mode1).to_constant ();\n+\t  /* For SLP reductions we have to make sure lanes match up, but\n+\t     since we're doing individual element final reduction reducing\n+\t     vector width here is even more important.\n+\t     ???  We can also separate lanes with permutes, for the common\n+\t     case of power-of-two group-size odd/even extracts would work.  */\n+\t  if (slp_reduc && nunits != nunits1)\n+\t    {\n+\t      nunits1 = least_common_multiple (nunits1, group_size);\n+\t      gcc_assert (exact_log2 (nunits1) != -1 && nunits1 <= nunits);\n+\t    }\n+\t}\n       if (!slp_reduc\n \t  && (mode1 = targetm.vectorize.split_reduction (mode)) != mode)\n \tnunits1 = GET_MODE_NUNITS (mode1).to_constant ();\n@@ -4958,7 +4975,6 @@ vect_create_epilog_for_reduction (stmt_vec_info stmt_info,\n       new_temp = new_phi_result;\n       while (nunits > nunits1)\n \t{\n-\t  gcc_assert (!slp_reduc);\n \t  nunits /= 2;\n \t  vectype1 = get_related_vectype_for_scalar_type (TYPE_MODE (vectype),\n \t\t\t\t\t\t\t  stype, nunits);\n@@ -5113,19 +5129,17 @@ vect_create_epilog_for_reduction (stmt_vec_info stmt_info,\n \n \t  int vec_size_in_bits = tree_to_uhwi (TYPE_SIZE (vectype1));\n \t  int element_bitsize = tree_to_uhwi (bitsize);\n+\t  tree compute_type = TREE_TYPE (vectype);\n+\t  gimple_seq stmts = NULL;\n           FOR_EACH_VEC_ELT (new_phis, i, new_phi)\n             {\n               int bit_offset;\n               if (gimple_code (new_phi) == GIMPLE_PHI)\n                 vec_temp = PHI_RESULT (new_phi);\n               else\n                 vec_temp = gimple_assign_lhs (new_phi);\n-              tree rhs = build3 (BIT_FIELD_REF, scalar_type, vec_temp, bitsize,\n-\t\t\t\t bitsize_zero_node);\n-              epilog_stmt = gimple_build_assign (new_scalar_dest, rhs);\n-              new_temp = make_ssa_name (new_scalar_dest, epilog_stmt);\n-              gimple_assign_set_lhs (epilog_stmt, new_temp);\n-              gsi_insert_before (&exit_gsi, epilog_stmt, GSI_SAME_STMT);\n+\t      new_temp = gimple_build (&stmts, BIT_FIELD_REF, compute_type,\n+\t\t\t\t       vec_temp, bitsize, bitsize_zero_node);\n \n               /* In SLP we don't need to apply reduction operation, so we just\n                  collect s' values in SCALAR_RESULTS.  */\n@@ -5137,14 +5151,9 @@ vect_create_epilog_for_reduction (stmt_vec_info stmt_info,\n                    bit_offset += element_bitsize)\n                 {\n                   tree bitpos = bitsize_int (bit_offset);\n-                  tree rhs = build3 (BIT_FIELD_REF, scalar_type, vec_temp,\n-                                     bitsize, bitpos);\n-\n-                  epilog_stmt = gimple_build_assign (new_scalar_dest, rhs);\n-                  new_name = make_ssa_name (new_scalar_dest, epilog_stmt);\n-                  gimple_assign_set_lhs (epilog_stmt, new_name);\n-                  gsi_insert_before (&exit_gsi, epilog_stmt, GSI_SAME_STMT);\n-\n+\t\t  new_name = gimple_build (&stmts, BIT_FIELD_REF,\n+\t\t\t\t\t   compute_type, vec_temp,\n+\t\t\t\t\t   bitsize, bitpos);\n                   if (slp_reduc)\n                     {\n                       /* In SLP we don't need to apply reduction operation, so \n@@ -5153,13 +5162,8 @@ vect_create_epilog_for_reduction (stmt_vec_info stmt_info,\n                       scalar_results.safe_push (new_name);\n                     }\n                   else\n-                    {\n-\t\t      epilog_stmt = gimple_build_assign (new_scalar_dest, code,\n-\t\t\t\t\t\t\t new_name, new_temp);\n-                      new_temp = make_ssa_name (new_scalar_dest, epilog_stmt);\n-                      gimple_assign_set_lhs (epilog_stmt, new_temp);\n-                      gsi_insert_before (&exit_gsi, epilog_stmt, GSI_SAME_STMT);\n-                    }\n+\t\t    new_temp = gimple_build (&stmts, code, compute_type,\n+\t\t\t\t\t     new_name, new_temp);\n                 }\n             }\n \n@@ -5170,24 +5174,28 @@ vect_create_epilog_for_reduction (stmt_vec_info stmt_info,\n           if (slp_reduc)\n             {\n               tree res, first_res, new_res;\n-\t      gimple *new_stmt;\n             \n               /* Reduce multiple scalar results in case of SLP unrolling.  */\n               for (j = group_size; scalar_results.iterate (j, &res);\n                    j++)\n                 {\n                   first_res = scalar_results[j % group_size];\n-\t\t  new_stmt = gimple_build_assign (new_scalar_dest, code,\n-\t\t\t\t\t\t  first_res, res);\n-                  new_res = make_ssa_name (new_scalar_dest, new_stmt);\n-                  gimple_assign_set_lhs (new_stmt, new_res);\n-                  gsi_insert_before (&exit_gsi, new_stmt, GSI_SAME_STMT);\n+\t\t  new_res = gimple_build (&stmts, code, compute_type,\n+\t\t\t\t\t  first_res, res);\n                   scalar_results[j % group_size] = new_res;\n                 }\n+\t      for (k = 0; k < group_size; k++)\n+\t\tscalar_results[k] = gimple_convert (&stmts, scalar_type,\n+\t\t\t\t\t\t    scalar_results[k]);\n             }\n           else\n-            /* Not SLP - we have one scalar to keep in SCALAR_RESULTS.  */\n-            scalar_results.safe_push (new_temp);\n+\t    {\n+\t      /* Not SLP - we have one scalar to keep in SCALAR_RESULTS.  */\n+\t      new_temp = gimple_convert (&stmts, scalar_type, new_temp);\n+\t      scalar_results.safe_push (new_temp);\n+\t    }\n+\n+\t  gsi_insert_seq_before (&exit_gsi, stmts, GSI_SAME_STMT);\n         }\n \n       if ((STMT_VINFO_REDUC_TYPE (reduc_info) == INTEGER_INDUC_COND_REDUCTION)"}]}