{"sha": "b16abbcb8530ab4601873c978c50422960d0faee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjE2YWJiY2I4NTMwYWI0NjAxODczYzk3OGM1MDQyMjk2MGQwZmFlZQ==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2014-11-14T02:32:38Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2014-11-14T02:32:38Z"}, "message": "timevar.def (TV_SCHED_FUSION): New time var.\n\n\n\t* timevar.def (TV_SCHED_FUSION): New time var.\n\t* passes.def (pass_sched_fusion): New pass.\n\t* config/arm/arm.c (TARGET_SCHED_FUSION_PRIORITY): New.\n\t(extract_base_offset_in_addr, fusion_load_store): New.\n\t(arm_sched_fusion_priority): New.\n\t(arm_option_override): Disable scheduling fusion by default\n\ton non-armv7 processors or ldrd/strd isn't preferred.\n\t* sched-int.h (struct _haifa_insn_data): New field.\n\t(INSN_FUSION_PRIORITY, FUSION_MAX_PRIORITY, sched_fusion): New.\n\t* sched-rgn.c (rest_of_handle_sched_fusion): New.\n\t(pass_data_sched_fusion, pass_sched_fusion): New.\n\t(make_pass_sched_fusion): New.\n\t* haifa-sched.c (sched_fusion): New.\n\t(insn_cost): Handle sched_fusion.\n\t(priority): Handle sched_fusion by calling target hook.\n\t(enum rfs_decision): New enum value.\n\t(rfs_str): New element for RFS_FUSION.\n\t(rank_for_schedule): Support sched_fusion.\n\t(schedule_insn, max_issue, prune_ready_list): Handle sched_fusion.\n\t(schedule_block, fix_tick_ready): Handle sched_fusion.\n\t* common.opt (flag_schedule_fusion): New.\n\t* tree-pass.h (make_pass_sched_fusion): New.\n\t* target.def (fusion_priority): New.\n\t* doc/tm.texi.in (TARGET_SCHED_FUSION_PRIORITY): New.\n\t* doc/tm.texi: Regenerated.\n\t* doc/invoke.texi (-fschedule-fusion): New.\n\n\ttestsuite:\n\t* gcc.target/arm/ldrd-strd-pair-1.c: New test.\n\t* gcc.target/arm/vfp-1.c: Improve scanning string.\n\nFrom-SVN: r217533", "tree": {"sha": "07a10a70a37299c1e153e8716e560040483d0d31", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/07a10a70a37299c1e153e8716e560040483d0d31"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b16abbcb8530ab4601873c978c50422960d0faee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b16abbcb8530ab4601873c978c50422960d0faee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b16abbcb8530ab4601873c978c50422960d0faee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b16abbcb8530ab4601873c978c50422960d0faee/comments", "author": null, "committer": null, "parents": [{"sha": "0fb3402f691447225a17f83d1ef168eb71a25ce0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fb3402f691447225a17f83d1ef168eb71a25ce0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0fb3402f691447225a17f83d1ef168eb71a25ce0"}], "stats": {"total": 507, "additions": 497, "deletions": 10}, "files": [{"sha": "1d20459bc7a8290537701bef3709c904542cd1c3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b16abbcb8530ab4601873c978c50422960d0faee/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b16abbcb8530ab4601873c978c50422960d0faee/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b16abbcb8530ab4601873c978c50422960d0faee", "patch": "@@ -1,3 +1,32 @@\n+2014-11-14  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* timevar.def (TV_SCHED_FUSION): New time var.\n+\t* passes.def (pass_sched_fusion): New pass.\n+\t* config/arm/arm.c (TARGET_SCHED_FUSION_PRIORITY): New.\n+\t(extract_base_offset_in_addr, fusion_load_store): New.\n+\t(arm_sched_fusion_priority): New.\n+\t(arm_option_override): Disable scheduling fusion by default\n+\ton non-armv7 processors or ldrd/strd isn't preferred.\n+\t* sched-int.h (struct _haifa_insn_data): New field.\n+\t(INSN_FUSION_PRIORITY, FUSION_MAX_PRIORITY, sched_fusion): New.\n+\t* sched-rgn.c (rest_of_handle_sched_fusion): New.\n+\t(pass_data_sched_fusion, pass_sched_fusion): New.\n+\t(make_pass_sched_fusion): New.\n+\t* haifa-sched.c (sched_fusion): New.\n+\t(insn_cost): Handle sched_fusion.\n+\t(priority): Handle sched_fusion by calling target hook.\n+\t(enum rfs_decision): New enum value.\n+\t(rfs_str): New element for RFS_FUSION.\n+\t(rank_for_schedule): Support sched_fusion.\n+\t(schedule_insn, max_issue, prune_ready_list): Handle sched_fusion.\n+\t(schedule_block, fix_tick_ready): Handle sched_fusion.\n+\t* common.opt (flag_schedule_fusion): New.\n+\t* tree-pass.h (make_pass_sched_fusion): New.\n+\t* target.def (fusion_priority): New.\n+\t* doc/tm.texi.in (TARGET_SCHED_FUSION_PRIORITY): New.\n+\t* doc/tm.texi: Regenerated.\n+\t* doc/invoke.texi (-fschedule-fusion): New.\n+\n 2014-11-13  Rong Xu  <xur@google.com>\n \n \tPR debug/63581"}, {"sha": "06daa43d2315fb2ac48ea94d099b541b92647ca1", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b16abbcb8530ab4601873c978c50422960d0faee/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b16abbcb8530ab4601873c978c50422960d0faee/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=b16abbcb8530ab4601873c978c50422960d0faee", "patch": "@@ -1848,6 +1848,10 @@ frename-registers\n Common Report Var(flag_rename_registers) Init(2) Optimization\n Perform a register renaming optimization pass\n \n+fschedule-fusion\n+Common Report Var(flag_schedule_fusion) Init(2) Optimization\n+Perform a target dependent instruction fusion optimization pass\n+\n freorder-blocks\n Common Report Var(flag_reorder_blocks) Optimization\n Reorder basic blocks to improve code placement"}, {"sha": "f9c98ac24ae6c1ff88c2990172926aa649af9389", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b16abbcb8530ab4601873c978c50422960d0faee/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b16abbcb8530ab4601873c978c50422960d0faee/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=b16abbcb8530ab4601873c978c50422960d0faee", "patch": "@@ -311,6 +311,8 @@ static unsigned arm_add_stmt_cost (void *data, int count,\n static void arm_canonicalize_comparison (int *code, rtx *op0, rtx *op1,\n \t\t\t\t\t bool op0_preserve_value);\n static unsigned HOST_WIDE_INT arm_asan_shadow_offset (void);\n+\n+static void arm_sched_fusion_priority (rtx_insn *, int, int *, int*);\n \f\n /* Table of machine attributes.  */\n static const struct attribute_spec arm_attribute_table[] =\n@@ -708,6 +710,9 @@ static const struct attribute_spec arm_attribute_table[] =\n #undef TARGET_CALL_FUSAGE_CONTAINS_NON_CALLEE_CLOBBERS\n #define TARGET_CALL_FUSAGE_CONTAINS_NON_CALLEE_CLOBBERS true\n \n+#undef TARGET_SCHED_FUSION_PRIORITY\n+#define TARGET_SCHED_FUSION_PRIORITY arm_sched_fusion_priority\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Obstack for minipool constant handling.  */\n@@ -3168,6 +3173,12 @@ arm_option_override (void)\n   if (TARGET_THUMB2)\n     inline_asm_unified = 1;\n \n+  /* Disable scheduling fusion by default if it's not armv7 processor\n+     or doesn't prefer ldrd/strd.  */\n+  if (flag_schedule_fusion == 2\n+      && (!arm_arch7 || !current_tune->prefer_ldrd_strd))\n+    flag_schedule_fusion = 0;\n+\n   /* Register global variables with the garbage collector.  */\n   arm_add_gc_roots ();\n }\n@@ -32350,4 +32361,124 @@ arm_is_constant_pool_ref (rtx x)\n \t  && CONSTANT_POOL_ADDRESS_P (XEXP (x, 0)));\n }\n \n+/* If MEM is in the form of [base+offset], extract the two parts\n+   of address and set to BASE and OFFSET, otherwise return false\n+   after clearing BASE and OFFSET.  */\n+\n+static bool\n+extract_base_offset_in_addr (rtx mem, rtx *base, rtx *offset)\n+{\n+  rtx addr;\n+\n+  gcc_assert (MEM_P (mem));\n+\n+  addr = XEXP (mem, 0);\n+\n+  /* Strip off const from addresses like (const (addr)).  */\n+  if (GET_CODE (addr) == CONST)\n+    addr = XEXP (addr, 0);\n+\n+  if (GET_CODE (addr) == REG)\n+    {\n+      *base = addr;\n+      *offset = const0_rtx;\n+      return true;\n+    }\n+\n+  if (GET_CODE (addr) == PLUS\n+      && GET_CODE (XEXP (addr, 0)) == REG\n+      && CONST_INT_P (XEXP (addr, 1)))\n+    {\n+      *base = XEXP (addr, 0);\n+      *offset = XEXP (addr, 1);\n+      return true;\n+    }\n+\n+  *base = NULL_RTX;\n+  *offset = NULL_RTX;\n+\n+  return false;\n+}\n+\n+/* If INSN is a load or store of address in the form of [base+offset],\n+   extract the two parts and set to BASE and OFFSET.  IS_LOAD is set\n+   to TRUE if it's a load.  Return TRUE if INSN is such an instruction,\n+   otherwise return FALSE.  */\n+\n+static bool\n+fusion_load_store (rtx_insn *insn, rtx *base, rtx *offset, bool *is_load)\n+{\n+  rtx x, dest, src;\n+\n+  gcc_assert (INSN_P (insn));\n+  x = PATTERN (insn);\n+  if (GET_CODE (x) != SET)\n+    return false;\n+\n+  src = SET_SRC (x);\n+  dest = SET_DEST (x);\n+  if (GET_CODE (src) == REG && GET_CODE (dest) == MEM)\n+    {\n+      *is_load = false;\n+      extract_base_offset_in_addr (dest, base, offset);\n+    }\n+  else if (GET_CODE (src) == MEM && GET_CODE (dest) == REG)\n+    {\n+      *is_load = true;\n+      extract_base_offset_in_addr (src, base, offset);\n+    }\n+  else\n+    return false;\n+\n+  return (*base != NULL_RTX && *offset != NULL_RTX);\n+}\n+\n+/* Implement the TARGET_SCHED_FUSION_PRIORITY hook.\n+\n+   Currently we only support to fuse ldr or str instructions, so FUSION_PRI\n+   and PRI are only calculated for these instructions.  For other instruction,\n+   FUSION_PRI and PRI are simply set to MAX_PRI.  In the future, other kind\n+   instruction fusion can be supported by returning different priorities.\n+\n+   It's important that irrelevant instructions get the largest FUSION_PRI.  */\n+\n+static void\n+arm_sched_fusion_priority (rtx_insn *insn, int max_pri,\n+\t\t\t   int *fusion_pri, int *pri)\n+{\n+  int tmp, off_val;\n+  bool is_load;\n+  rtx base, offset;\n+\n+  gcc_assert (INSN_P (insn));\n+\n+  tmp = max_pri - 1;\n+  if (!fusion_load_store (insn, &base, &offset, &is_load))\n+    {\n+      *pri = tmp;\n+      *fusion_pri = tmp;\n+      return;\n+    }\n+\n+  /* Load goes first.  */\n+  if (is_load)\n+    *fusion_pri = tmp - 1;\n+  else\n+    *fusion_pri = tmp - 2;\n+\n+  tmp /= 2;\n+\n+  /* INSN with smaller base register goes first.  */\n+  tmp -= ((REGNO (base) & 0xff) << 20);\n+\n+  /* INSN with smaller offset goes first.  */\n+  off_val = (int)(INTVAL (offset));\n+  if (off_val >= 0)\n+    tmp -= (off_val & 0xfffff);\n+  else\n+    tmp += ((- off_val) & 0xfffff);\n+\n+  *pri = tmp;\n+  return;\n+}\n #include \"gt-arm.h\""}, {"sha": "b7049d827e9fe1a7baaf635faccb4641f08fb452", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b16abbcb8530ab4601873c978c50422960d0faee/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b16abbcb8530ab4601873c978c50422960d0faee/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=b16abbcb8530ab4601873c978c50422960d0faee", "patch": "@@ -406,7 +406,7 @@ Objective-C and Objective-C++ Dialects}.\n -fprofile-correction -fprofile-dir=@var{path} -fprofile-generate @gol\n -fprofile-generate=@var{path} @gol\n -fprofile-use -fprofile-use=@var{path} -fprofile-values -fprofile-reorder-functions @gol\n--freciprocal-math -free -frename-registers -freorder-blocks @gol\n+-freciprocal-math -free -frename-registers -fschedule-fusion -freorder-blocks @gol\n -freorder-blocks-and-partition -freorder-functions @gol\n -frerun-cse-after-loop -freschedule-modulo-scheduled-loops @gol\n -frounding-math -fsched2-use-superblocks -fsched-pressure @gol\n@@ -9575,6 +9575,14 @@ a ``home register''.\n \n Enabled by default with @option{-funroll-loops} and @option{-fpeel-loops}.\n \n+@item -fschedule-fusion\n+@opindex fschedule-fusion\n+Performs a target dependent pass over the instruction stream to schedule\n+instructions of same type together because target machine can execute them\n+more efficiently if they are adjacent to each other in the instruction flow.\n+\n+Enabled at levels @option{-O2}, @option{-O3}, @option{-Os}.\n+\n @item -ftracer\n @opindex ftracer\n Perform tail duplication to enlarge superblock size.  This transformation"}, {"sha": "8d137f5cf1e2819283cb24b11ee0f37c758f78f5", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b16abbcb8530ab4601873c978c50422960d0faee/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b16abbcb8530ab4601873c978c50422960d0faee/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=b16abbcb8530ab4601873c978c50422960d0faee", "patch": "@@ -6771,6 +6771,76 @@ This hook is called by tree reassociator to determine a level of\n parallelism required in output calculations chain.\n @end deftypefn\n \n+@deftypefn {Target Hook} void TARGET_SCHED_FUSION_PRIORITY (rtx_insn *@var{insn}, int @var{max_pri}, int *@var{fusion_pri}, int *@var{pri})\n+This hook is called by scheduling fusion pass.  It calculates fusion\n+priorities for each instruction passed in by parameter.  The priorities\n+are returned via pointer parameters.\n+\n+@var{insn} is the instruction whose priorities need to be calculated.\n+@var{max_pri} is the maximum priority can be returned in any cases.\n+@var{fusion_pri} is the pointer parameter through which @var{insn}'s\n+fusion priority should be calculated and returned.\n+@var{pri} is the pointer parameter through which @var{insn}'s priority\n+should be calculated and returned.\n+\n+Same @var{fusion_pri} should be returned for instructions which should\n+be scheduled together.  Different @var{pri} should be returned for\n+instructions with same @var{fusion_pri}.  @var{fusion_pri} is the major\n+sort key, @var{pri} is the minor sort key.  All instructions will be\n+scheduled according to the two priorities.  All priorities calculated\n+should be between 0 (exclusive) and @var{max_pri} (inclusive).  To avoid\n+false dependencies, @var{fusion_pri} of instructions which need to be\n+scheduled together should be smaller than @var{fusion_pri} of irrelevant\n+instructions.\n+\n+Given below example:\n+\n+    ldr r10, [r1, 4]\n+    add r4, r4, r10\n+    ldr r15, [r2, 8]\n+    sub r5, r5, r15\n+    ldr r11, [r1, 0]\n+    add r4, r4, r11\n+    ldr r16, [r2, 12]\n+    sub r5, r5, r16\n+\n+On targets like ARM/AArch64, the two pairs of consecutive loads should be\n+merged.  Since peephole2 pass can't help in this case unless consecutive\n+loads are actually next to each other in instruction flow.  That's where\n+this scheduling fusion pass works.  This hook calculates priority for each\n+instruction based on its fustion type, like:\n+\n+    ldr r10, [r1, 4]  ; fusion_pri=99,  pri=96   \n+    add r4, r4, r10   ; fusion_pri=100, pri=100  \n+    ldr r15, [r2, 8]  ; fusion_pri=98,  pri=92   \n+    sub r5, r5, r15   ; fusion_pri=100, pri=100  \n+    ldr r11, [r1, 0]  ; fusion_pri=99,  pri=100  \n+    add r4, r4, r11   ; fusion_pri=100, pri=100  \n+    ldr r16, [r2, 12] ; fusion_pri=98,  pri=88   \n+    sub r5, r5, r16   ; fusion_pri=100, pri=100  \n+\n+Scheduling fusion pass then sorts all ready to issue instructions according\n+to the priorities.  As a result, instructions of same fusion type will be\n+pushed together in instruction flow, like:\n+\n+    ldr r11, [r1, 0]\n+    ldr r10, [r1, 4]\n+    ldr r15, [r2, 8]\n+    ldr r16, [r2, 12]\n+    add r4, r4, r10\n+    sub r5, r5, r15\n+    add r4, r4, r11\n+    sub r5, r5, r16\n+\n+Now peephole2 pass can simply merge the two pairs of loads.\n+\n+Since scheduling fusion pass relies on peephole2 to do real fusion\n+work, it is only enabled by default when peephole2 is in effect.\n+\n+This is firstly introduced on ARM/AArch64 targets, please refer to\n+the hook implementation for how different fusion types are supported.\n+@end deftypefn\n+\n @node Sections\n @section Dividing the Output into Sections (Texts, Data, @dots{})\n @c the above section title is WAY too long.  maybe cut the part between"}, {"sha": "7c58a323c6daecc219d8eeb92ca6a9f42a5d09af", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b16abbcb8530ab4601873c978c50422960d0faee/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b16abbcb8530ab4601873c978c50422960d0faee/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=b16abbcb8530ab4601873c978c50422960d0faee", "patch": "@@ -4811,6 +4811,8 @@ them: try the first ones in this list first.\n \n @hook TARGET_SCHED_REASSOCIATION_WIDTH\n \n+@hook TARGET_SCHED_FUSION_PRIORITY\n+\n @node Sections\n @section Dividing the Output into Sections (Texts, Data, @dots{})\n @c the above section title is WAY too long.  maybe cut the part between"}, {"sha": "4fb97fb69a39caa081d805e6649039225ed6ee92", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 76, "deletions": 8, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b16abbcb8530ab4601873c978c50422960d0faee/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b16abbcb8530ab4601873c978c50422960d0faee/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=b16abbcb8530ab4601873c978c50422960d0faee", "patch": "@@ -1391,6 +1391,9 @@ insn_cost (rtx_insn *insn)\n {\n   int cost;\n \n+  if (sched_fusion)\n+    return 0;\n+\n   if (sel_sched_p ())\n     {\n       if (recog_memoized (insn) < 0)\n@@ -1603,6 +1606,8 @@ dep_list_size (rtx insn, sd_list_types_def list)\n   return nodbgcount;\n }\n \n+bool sched_fusion;\n+\n /* Compute the priority number for INSN.  */\n static int\n priority (rtx_insn *insn)\n@@ -1617,7 +1622,15 @@ priority (rtx_insn *insn)\n     {\n       int this_priority = -1;\n \n-      if (dep_list_size (insn, SD_LIST_FORW) == 0)\n+      if (sched_fusion)\n+\t{\n+\t  int this_fusion_priority;\n+\n+\t  targetm.sched.fusion_priority (insn, FUSION_MAX_PRIORITY,\n+\t\t\t\t\t &this_fusion_priority, &this_priority);\n+\t  INSN_FUSION_PRIORITY (insn) = this_fusion_priority;\n+\t}\n+      else if (dep_list_size (insn, SD_LIST_FORW) == 0)\n \t/* ??? We should set INSN_PRIORITY to insn_cost when and insn has\n \t   some forward deps but all of them are ignored by\n \t   contributes_to_priority hook.  At the moment we set priority of\n@@ -2548,15 +2561,15 @@ enum rfs_decision {\n   RFS_SCHED_GROUP, RFS_PRESSURE_DELAY, RFS_PRESSURE_TICK,\n   RFS_FEEDS_BACKTRACK_INSN, RFS_PRIORITY, RFS_SPECULATION,\n   RFS_SCHED_RANK, RFS_LAST_INSN, RFS_PRESSURE_INDEX,\n-  RFS_DEP_COUNT, RFS_TIE, RFS_N };\n+  RFS_DEP_COUNT, RFS_TIE, RFS_FUSION, RFS_N };\n \n /* Corresponding strings for print outs.  */\n static const char *rfs_str[RFS_N] = {\n   \"RFS_DEBUG\", \"RFS_LIVE_RANGE_SHRINK1\", \"RFS_LIVE_RANGE_SHRINK2\",\n   \"RFS_SCHED_GROUP\", \"RFS_PRESSURE_DELAY\", \"RFS_PRESSURE_TICK\",\n   \"RFS_FEEDS_BACKTRACK_INSN\", \"RFS_PRIORITY\", \"RFS_SPECULATION\",\n   \"RFS_SCHED_RANK\", \"RFS_LAST_INSN\", \"RFS_PRESSURE_INDEX\",\n-  \"RFS_DEP_COUNT\", \"RFS_TIE\" };\n+  \"RFS_DEP_COUNT\", \"RFS_TIE\", \"RFS_FUSION\" };\n \n /* Statistical breakdown of rank_for_schedule decisions.  */\n typedef struct { unsigned stats[RFS_N]; } rank_for_schedule_stats_t;\n@@ -2627,6 +2640,55 @@ rank_for_schedule (const void *x, const void *y)\n   /* Make sure that priority of TMP and TMP2 are initialized.  */\n   gcc_assert (INSN_PRIORITY_KNOWN (tmp) && INSN_PRIORITY_KNOWN (tmp2));\n \n+  if (sched_fusion)\n+    {\n+      /* The instruction that has the same fusion priority as the last\n+\t instruction is the instruction we picked next.  If that is not\n+\t the case, we sort ready list firstly by fusion priority, then\n+\t by priority, and at last by INSN_LUID.  */\n+      int a = INSN_FUSION_PRIORITY (tmp);\n+      int b = INSN_FUSION_PRIORITY (tmp2);\n+      int last = -1;\n+\n+      if (last_nondebug_scheduled_insn\n+\t  && !NOTE_P (last_nondebug_scheduled_insn)\n+\t  && BLOCK_FOR_INSN (tmp)\n+\t       == BLOCK_FOR_INSN (last_nondebug_scheduled_insn))\n+\tlast = INSN_FUSION_PRIORITY (last_nondebug_scheduled_insn);\n+\n+      if (a != last && b != last)\n+\t{\n+\t  if (a == b)\n+\t    {\n+\t      a = INSN_PRIORITY (tmp);\n+\t      b = INSN_PRIORITY (tmp2);\n+\t    }\n+\t  if (a != b)\n+\t    return rfs_result (RFS_FUSION, b - a, tmp, tmp2);\n+\t  else\n+\t    return rfs_result (RFS_FUSION,\n+\t\t\t       INSN_LUID (tmp) - INSN_LUID (tmp2), tmp, tmp2);\n+\t}\n+      else if (a == b)\n+\t{\n+\t  gcc_assert (last_nondebug_scheduled_insn\n+\t\t      && !NOTE_P (last_nondebug_scheduled_insn));\n+\t  last = INSN_PRIORITY (last_nondebug_scheduled_insn);\n+\n+\t  a = abs (INSN_PRIORITY (tmp) - last);\n+\t  b = abs (INSN_PRIORITY (tmp2) - last);\n+\t  if (a != b)\n+\t    return rfs_result (RFS_FUSION, a - b, tmp, tmp2);\n+\t  else\n+\t    return rfs_result (RFS_FUSION,\n+\t\t\t       INSN_LUID (tmp) - INSN_LUID (tmp2), tmp, tmp2);\n+\t}\n+      else if (a == last)\n+\treturn rfs_result (RFS_FUSION, -1, tmp, tmp2);\n+      else\n+\treturn rfs_result (RFS_FUSION, 1, tmp, tmp2);\n+    }\n+\n   if (sched_pressure != SCHED_PRESSURE_NONE)\n     {\n       /* Prefer insn whose scheduling results in the smallest register\n@@ -4007,8 +4069,8 @@ schedule_insn (rtx_insn *insn)\n   gcc_assert (INSN_TICK (insn) >= MIN_TICK);\n   if (INSN_TICK (insn) > clock_var)\n     /* INSN has been prematurely moved from the queue to the ready list.\n-       This is possible only if following flag is set.  */\n-    gcc_assert (flag_sched_stalled_insns);\n+       This is possible only if following flags are set.  */\n+    gcc_assert (flag_sched_stalled_insns || sched_fusion);\n \n   /* ??? Probably, if INSN is scheduled prematurely, we should leave\n      INSN_TICK untouched.  This is a machine-dependent issue, actually.  */\n@@ -5500,6 +5562,9 @@ max_issue (struct ready_list *ready, int privileged_n, state_t state,\n   struct choice_entry *top;\n   rtx_insn *insn;\n \n+  if (sched_fusion)\n+    return 0;\n+\n   n_ready = ready->n_ready;\n   gcc_assert (dfa_lookahead >= 1 && privileged_n >= 0\n \t      && privileged_n <= n_ready);\n@@ -5848,6 +5913,9 @@ prune_ready_list (state_t temp_state, bool first_cycle_insn_p,\n   bool sched_group_found = false;\n   int min_cost_group = 1;\n \n+  if (sched_fusion)\n+    return;\n+\n   for (i = 0; i < ready.n_ready; i++)\n     {\n       rtx_insn *insn = ready_element (&ready, i);\n@@ -6059,7 +6127,7 @@ schedule_block (basic_block *target_bb, state_t init_state)\n   rtx_insn *tail = PREV_INSN (next_tail);\n \n   if ((current_sched_info->flags & DONT_BREAK_DEPENDENCIES) == 0\n-      && sched_pressure != SCHED_PRESSURE_MODEL)\n+      && sched_pressure != SCHED_PRESSURE_MODEL && !sched_fusion)\n     find_modifiable_mems (head, tail);\n \n   /* We used to have code to avoid getting parameters moved from hard\n@@ -6455,7 +6523,7 @@ schedule_block (basic_block *target_bb, state_t init_state)\n \t    {\n \t      memcpy (temp_state, curr_state, dfa_state_size);\n \t      cost = state_transition (curr_state, insn);\n-\t      if (sched_pressure != SCHED_PRESSURE_WEIGHTED)\n+\t      if (sched_pressure != SCHED_PRESSURE_WEIGHTED && !sched_fusion)\n \t\tgcc_assert (cost < 0);\n \t      if (memcmp (temp_state, curr_state, dfa_state_size) != 0)\n \t\tcycle_issued_insns++;\n@@ -7288,7 +7356,7 @@ fix_tick_ready (rtx_insn *next)\n   INSN_TICK (next) = tick;\n \n   delay = tick - clock_var;\n-  if (delay <= 0 || sched_pressure != SCHED_PRESSURE_NONE)\n+  if (delay <= 0 || sched_pressure != SCHED_PRESSURE_NONE || sched_fusion)\n     delay = QUEUE_READY;\n \n   change_queue_index (next, delay);"}, {"sha": "194e2a91925d32c0519f9e8db462ac03cc852cf7", "filename": "gcc/passes.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b16abbcb8530ab4601873c978c50422960d0faee/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b16abbcb8530ab4601873c978c50422960d0faee/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=b16abbcb8530ab4601873c978c50422960d0faee", "patch": "@@ -419,6 +419,7 @@ along with GCC; see the file COPYING3.  If not see\n \t  NEXT_PASS (pass_stack_adjustments);\n \t  NEXT_PASS (pass_jump2);\n \t  NEXT_PASS (pass_duplicate_computed_gotos);\n+\t  NEXT_PASS (pass_sched_fusion);\n \t  NEXT_PASS (pass_peephole2);\n \t  NEXT_PASS (pass_if_after_reload);\n \t  NEXT_PASS (pass_regrename);"}, {"sha": "2e156f33db7583cadd7ead2fc538b1c7ec87b291", "filename": "gcc/sched-int.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b16abbcb8530ab4601873c978c50422960d0faee/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b16abbcb8530ab4601873c978c50422960d0faee/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=b16abbcb8530ab4601873c978c50422960d0faee", "patch": "@@ -805,6 +805,9 @@ struct _haifa_insn_data\n   /* A priority for each insn.  */\n   int priority;\n \n+  /* The fusion priority for each insn.  */\n+  int fusion_priority;\n+\n   /* The minimum clock tick at which the insn becomes ready.  This is\n      used to note timing constraints for the insns in the pending list.  */\n   int tick;\n@@ -903,6 +906,7 @@ extern vec<haifa_insn_data_def> h_i_d;\n /* Accessor macros for h_i_d.  There are more in haifa-sched.c and\n    sched-rgn.c.  */\n #define INSN_PRIORITY(INSN) (HID (INSN)->priority)\n+#define INSN_FUSION_PRIORITY(INSN) (HID (INSN)->fusion_priority)\n #define INSN_REG_PRESSURE(INSN) (HID (INSN)->reg_pressure)\n #define INSN_MAX_REG_PRESSURE(INSN) (HID (INSN)->max_reg_pressure)\n #define INSN_REG_USE_LIST(INSN) (HID (INSN)->reg_use_list)\n@@ -1620,6 +1624,10 @@ extern void sd_copy_back_deps (rtx_insn *, rtx_insn *, bool);\n extern void sd_delete_dep (sd_iterator_def);\n extern void sd_debug_lists (rtx, sd_list_types_def);\n \n+/* Macros and declarations for scheduling fusion.  */\n+#define FUSION_MAX_PRIORITY (INT_MAX)\n+extern bool sched_fusion;\n+\n #endif /* INSN_SCHEDULING */\n \n #endif /* GCC_SCHED_INT_H */"}, {"sha": "2a1c18c1eded32a0a80acc9a60d288991e742865", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b16abbcb8530ab4601873c978c50422960d0faee/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b16abbcb8530ab4601873c978c50422960d0faee/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=b16abbcb8530ab4601873c978c50422960d0faee", "patch": "@@ -3658,6 +3658,17 @@ rest_of_handle_sched2 (void)\n   return 0;\n }\n \n+static unsigned int\n+rest_of_handle_sched_fusion (void)\n+{\n+#ifdef INSN_SCHEDULING\n+  sched_fusion = true;\n+  schedule_insns ();\n+  sched_fusion = false;\n+#endif\n+  return 0;\n+}\n+\n namespace {\n \n const pass_data pass_data_live_range_shrinkage =\n@@ -3800,3 +3811,55 @@ make_pass_sched2 (gcc::context *ctxt)\n {\n   return new pass_sched2 (ctxt);\n }\n+\n+namespace {\n+\n+const pass_data pass_data_sched_fusion =\n+{\n+  RTL_PASS, /* type */\n+  \"sched_fusion\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  TV_SCHED_FUSION, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_df_finish, /* todo_flags_finish */\n+};\n+\n+class pass_sched_fusion : public rtl_opt_pass\n+{\n+public:\n+  pass_sched_fusion (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_sched_fusion, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual bool gate (function *);\n+  virtual unsigned int execute (function *)\n+    {\n+      return rest_of_handle_sched_fusion ();\n+    }\n+\n+}; // class pass_sched2\n+\n+bool\n+pass_sched_fusion::gate (function *)\n+{\n+#ifdef INSN_SCHEDULING\n+  /* Scheduling fusion relies on peephole2 to do real fusion work,\n+     so only enable it if peephole2 is in effect.  */\n+  return (optimize > 0 && flag_peephole2\n+    && flag_schedule_fusion && targetm.sched.fusion_priority != NULL);\n+#else\n+  return 0;\n+#endif\n+}\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_sched_fusion (gcc::context *ctxt)\n+{\n+  return new pass_sched_fusion (ctxt);\n+}"}, {"sha": "c329b2a9632cafad35404ca4d89362c4185ca3e6", "filename": "gcc/target.def", "status": "modified", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b16abbcb8530ab4601873c978c50422960d0faee/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b16abbcb8530ab4601873c978c50422960d0faee/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=b16abbcb8530ab4601873c978c50422960d0faee", "patch": "@@ -1526,6 +1526,79 @@ parallelism required in output calculations chain.\",\n int, (unsigned int opc, machine_mode mode),\n hook_int_uint_mode_1)\n \n+/* The following member value is a function that returns priority for\n+   fusion of each instruction via pointer parameters.  */\n+DEFHOOK\n+(fusion_priority,\n+\"This hook is called by scheduling fusion pass.  It calculates fusion\\n\\\n+priorities for each instruction passed in by parameter.  The priorities\\n\\\n+are returned via pointer parameters.\\n\\\n+\\n\\\n+@var{insn} is the instruction whose priorities need to be calculated.\\n\\\n+@var{max_pri} is the maximum priority can be returned in any cases.\\n\\\n+@var{fusion_pri} is the pointer parameter through which @var{insn}'s\\n\\\n+fusion priority should be calculated and returned.\\n\\\n+@var{pri} is the pointer parameter through which @var{insn}'s priority\\n\\\n+should be calculated and returned.\\n\\\n+\\n\\\n+Same @var{fusion_pri} should be returned for instructions which should\\n\\\n+be scheduled together.  Different @var{pri} should be returned for\\n\\\n+instructions with same @var{fusion_pri}.  @var{fusion_pri} is the major\\n\\\n+sort key, @var{pri} is the minor sort key.  All instructions will be\\n\\\n+scheduled according to the two priorities.  All priorities calculated\\n\\\n+should be between 0 (exclusive) and @var{max_pri} (inclusive).  To avoid\\n\\\n+false dependencies, @var{fusion_pri} of instructions which need to be\\n\\\n+scheduled together should be smaller than @var{fusion_pri} of irrelevant\\n\\\n+instructions.\\n\\\n+\\n\\\n+Given below example:\\n\\\n+\\n\\\n+    ldr r10, [r1, 4]\\n\\\n+    add r4, r4, r10\\n\\\n+    ldr r15, [r2, 8]\\n\\\n+    sub r5, r5, r15\\n\\\n+    ldr r11, [r1, 0]\\n\\\n+    add r4, r4, r11\\n\\\n+    ldr r16, [r2, 12]\\n\\\n+    sub r5, r5, r16\\n\\\n+\\n\\\n+On targets like ARM/AArch64, the two pairs of consecutive loads should be\\n\\\n+merged.  Since peephole2 pass can't help in this case unless consecutive\\n\\\n+loads are actually next to each other in instruction flow.  That's where\\n\\\n+this scheduling fusion pass works.  This hook calculates priority for each\\n\\\n+instruction based on its fustion type, like:\\n\\\n+\\n\\\n+    ldr r10, [r1, 4]  ; fusion_pri=99,  pri=96   \\n\\\n+    add r4, r4, r10   ; fusion_pri=100, pri=100  \\n\\\n+    ldr r15, [r2, 8]  ; fusion_pri=98,  pri=92   \\n\\\n+    sub r5, r5, r15   ; fusion_pri=100, pri=100  \\n\\\n+    ldr r11, [r1, 0]  ; fusion_pri=99,  pri=100  \\n\\\n+    add r4, r4, r11   ; fusion_pri=100, pri=100  \\n\\\n+    ldr r16, [r2, 12] ; fusion_pri=98,  pri=88   \\n\\\n+    sub r5, r5, r16   ; fusion_pri=100, pri=100  \\n\\\n+\\n\\\n+Scheduling fusion pass then sorts all ready to issue instructions according\\n\\\n+to the priorities.  As a result, instructions of same fusion type will be\\n\\\n+pushed together in instruction flow, like:\\n\\\n+\\n\\\n+    ldr r11, [r1, 0]\\n\\\n+    ldr r10, [r1, 4]\\n\\\n+    ldr r15, [r2, 8]\\n\\\n+    ldr r16, [r2, 12]\\n\\\n+    add r4, r4, r10\\n\\\n+    sub r5, r5, r15\\n\\\n+    add r4, r4, r11\\n\\\n+    sub r5, r5, r16\\n\\\n+\\n\\\n+Now peephole2 pass can simply merge the two pairs of loads.\\n\\\n+\\n\\\n+Since scheduling fusion pass relies on peephole2 to do real fusion\\n\\\n+work, it is only enabled by default when peephole2 is in effect.\\n\\\n+\\n\\\n+This is firstly introduced on ARM/AArch64 targets, please refer to\\n\\\n+the hook implementation for how different fusion types are supported.\",\n+void, (rtx_insn *insn, int max_pri, int *fusion_pri, int *pri), NULL)\n+\n HOOK_VECTOR_END (sched)\n \n /* Functions relating to OpenMP and Cilk Plus SIMD clones.  */"}, {"sha": "b1e9bc39f0871156dd41171d3adbf979bec83355", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b16abbcb8530ab4601873c978c50422960d0faee/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b16abbcb8530ab4601873c978c50422960d0faee/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b16abbcb8530ab4601873c978c50422960d0faee", "patch": "@@ -1,3 +1,8 @@\n+2014-11-14  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* gcc.target/arm/ldrd-strd-pair-1.c: New test.\n+\t* gcc.target/arm/vfp-1.c: Improve scanning string.\n+\n 2014-11-13  Rong Xu  <xur@google.com>\n \n \tPR debug/63581"}, {"sha": "7a0bff5f8415d9b133f399f77bb3af582b33d5a9", "filename": "gcc/testsuite/gcc.target/arm/ldrd-strd-pair-1.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b16abbcb8530ab4601873c978c50422960d0faee/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fldrd-strd-pair-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b16abbcb8530ab4601873c978c50422960d0faee/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fldrd-strd-pair-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fldrd-strd-pair-1.c?ref=b16abbcb8530ab4601873c978c50422960d0faee", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_prefer_ldrd_strd } */\n+/* { dg-options \"-O2 -mthumb\" } */\n+\n+struct\n+{\n+  int x;\n+  int y;\n+  char c;\n+  int d;\n+}a;\n+\n+int foo(int x, int y)\n+{\n+  int c;\n+  a.x = x;\n+  c = a.x;\n+  a.d = c;\n+  a.y = y;\n+\n+  return 0;\n+}\n+/* { dg-final { scan-assembler \"strd\\t\" { target { arm_thumb2_ok } } } } */"}, {"sha": "b6bb7be9995b9009409532293be02f2329545c8c", "filename": "gcc/testsuite/gcc.target/arm/vfp-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b16abbcb8530ab4601873c978c50422960d0faee/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fvfp-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b16abbcb8530ab4601873c978c50422960d0faee/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fvfp-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fvfp-1.c?ref=b16abbcb8530ab4601873c978c50422960d0faee", "patch": "@@ -126,7 +126,7 @@ void test_convert () {\n }\n \n void test_ldst (float f[], double d[]) {\n-  /* { dg-final { scan-assembler \"vldr.32.+ \\\\\\[r0, #1020\\\\\\]\" } } */\n+  /* { dg-final { scan-assembler \"vldr.32.+ \\\\\\[r0, #-?\\[0-9\\]+\\\\\\]\" } } */\n   /* { dg-final { scan-assembler \"vldr.32.+ \\\\\\[r\\[0-9\\], #-1020\\\\\\]\" { target { arm32 && { ! arm_thumb2_ok } } } } } */\n   /* { dg-final { scan-assembler \"add.+ r0, #1024\" } } */\n   /* { dg-final { scan-assembler \"vstr.32.+ \\\\\\[r\\[0-9\\]\\\\\\]\\n\" } } */"}, {"sha": "5d8d0e769b59dfbfb89fac6a95bec2c5e5a1c7fa", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b16abbcb8530ab4601873c978c50422960d0faee/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b16abbcb8530ab4601873c978c50422960d0faee/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=b16abbcb8530ab4601873c978c50422960d0faee", "patch": "@@ -247,6 +247,7 @@ DEFTIMEVAR (TV_IFCVT2\t\t     , \"if-conversion 2\")\n DEFTIMEVAR (TV_COMBINE_STACK_ADJUST  , \"combine stack adjustments\")\n DEFTIMEVAR (TV_PEEPHOLE2             , \"peephole 2\")\n DEFTIMEVAR (TV_RENAME_REGISTERS      , \"rename registers\")\n+DEFTIMEVAR (TV_SCHED_FUSION          , \"scheduling fusion\")\n DEFTIMEVAR (TV_CPROP_REGISTERS       , \"hard reg cprop\")\n DEFTIMEVAR (TV_SCHED2                , \"scheduling 2\")\n DEFTIMEVAR (TV_MACH_DEP              , \"machine dep reorg\")"}, {"sha": "a3e1e7291241bd0422d594a72ad5b74b1c7efa83", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b16abbcb8530ab4601873c978c50422960d0faee/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b16abbcb8530ab4601873c978c50422960d0faee/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=b16abbcb8530ab4601873c978c50422960d0faee", "patch": "@@ -552,6 +552,7 @@ extern rtl_opt_pass *make_pass_branch_target_load_optimize1 (gcc::context\n extern rtl_opt_pass *make_pass_thread_prologue_and_epilogue (gcc::context\n \t\t\t\t\t\t\t     *ctxt);\n extern rtl_opt_pass *make_pass_stack_adjustments (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_sched_fusion (gcc::context *ctxt);\n extern rtl_opt_pass *make_pass_peephole2 (gcc::context *ctxt);\n extern rtl_opt_pass *make_pass_if_after_reload (gcc::context *ctxt);\n extern rtl_opt_pass *make_pass_regrename (gcc::context *ctxt);"}]}