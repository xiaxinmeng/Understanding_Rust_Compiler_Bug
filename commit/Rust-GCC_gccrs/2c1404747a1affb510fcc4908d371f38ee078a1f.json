{"sha": "2c1404747a1affb510fcc4908d371f38ee078a1f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmMxNDA0NzQ3YTFhZmZiNTEwZmNjNDkwOGQzNzFmMzhlZTA3OGExZg==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@google.com", "date": "2011-07-12T22:59:39Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2011-07-12T22:59:39Z"}, "message": "name-lookup.h (cp_binding_level): Rename from cxx_scope.\n\n\t* name-lookup.h (cp_binding_level): Rename from cxx_scope.\n\tUpdate all users.\n\t(struct cp_binding_level): Fix indentation.\n\nFrom-SVN: r176218", "tree": {"sha": "9c0d57b2b524d0afdcd6fc4965550024ea6b8cd0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c0d57b2b524d0afdcd6fc4965550024ea6b8cd0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c1404747a1affb510fcc4908d371f38ee078a1f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c1404747a1affb510fcc4908d371f38ee078a1f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c1404747a1affb510fcc4908d371f38ee078a1f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c1404747a1affb510fcc4908d371f38ee078a1f/comments", "author": {"login": "dnovillo", "id": 7295335, "node_id": "MDQ6VXNlcjcyOTUzMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/7295335?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dnovillo", "html_url": "https://github.com/dnovillo", "followers_url": "https://api.github.com/users/dnovillo/followers", "following_url": "https://api.github.com/users/dnovillo/following{/other_user}", "gists_url": "https://api.github.com/users/dnovillo/gists{/gist_id}", "starred_url": "https://api.github.com/users/dnovillo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dnovillo/subscriptions", "organizations_url": "https://api.github.com/users/dnovillo/orgs", "repos_url": "https://api.github.com/users/dnovillo/repos", "events_url": "https://api.github.com/users/dnovillo/events{/privacy}", "received_events_url": "https://api.github.com/users/dnovillo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "38ab02dbdc0bb4488a9419dfd7e3e17b799b9710", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38ab02dbdc0bb4488a9419dfd7e3e17b799b9710", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38ab02dbdc0bb4488a9419dfd7e3e17b799b9710"}], "stats": {"total": 360, "additions": 183, "deletions": 177}, "files": [{"sha": "9e55de85181de62ea376b42a5904f1713d3935ac", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c1404747a1affb510fcc4908d371f38ee078a1f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c1404747a1affb510fcc4908d371f38ee078a1f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2c1404747a1affb510fcc4908d371f38ee078a1f", "patch": "@@ -1,3 +1,9 @@\n+2011-07-12   Diego Novillo  <dnovillo@google.com>\n+\n+\t* name-lookup.h (cp_binding_level): Rename from cxx_scope.\n+\tUpdate all users.\n+\t(struct cp_binding_level): Fix indentation.\n+\n 2011-07-11  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/49672"}, {"sha": "96d9fa8e22e4c8eabbd28cc203fb3ab887483bff", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c1404747a1affb510fcc4908d371f38ee078a1f/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c1404747a1affb510fcc4908d371f38ee078a1f/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=2c1404747a1affb510fcc4908d371f38ee078a1f", "patch": "@@ -950,7 +950,7 @@ struct GTY(()) saved_scope {\n   VEC(tree,gc) *lang_base;\n   tree lang_name;\n   tree template_parms;\n-  struct cp_binding_level *x_previous_class_level;\n+  cp_binding_level *x_previous_class_level;\n   tree x_saved_tree;\n \n   /* Only used for uses of this in trailing return type.  */\n@@ -967,8 +967,8 @@ struct GTY(()) saved_scope {\n \n   struct stmt_tree_s x_stmt_tree;\n \n-  struct cp_binding_level *class_bindings;\n-  struct cp_binding_level *bindings;\n+  cp_binding_level *class_bindings;\n+  cp_binding_level *bindings;\n \n   struct saved_scope *prev;\n };\n@@ -1054,7 +1054,7 @@ struct GTY(()) language_function {\n   BOOL_BITFIELD can_throw : 1;\n \n   htab_t GTY((param_is(struct named_label_entry))) x_named_labels;\n-  struct cp_binding_level *bindings;\n+  cp_binding_level *bindings;\n   VEC(tree,gc) *x_local_names;\n   htab_t GTY((param_is (struct cxx_int_tree_map))) extern_decl_map;\n };\n@@ -1944,7 +1944,7 @@ struct GTY(()) lang_decl_fn {\n \n struct GTY(()) lang_decl_ns {\n   struct lang_decl_base base;\n-  struct cp_binding_level *level;\n+  cp_binding_level *level;\n };\n \n /* DECL_LANG_SPECIFIC for parameters.  */\n@@ -4860,7 +4860,7 @@ extern tree make_anon_name\t\t\t(void);\n extern tree pushdecl_top_level_maybe_friend\t(tree, bool);\n extern tree pushdecl_top_level_and_finish\t(tree, tree);\n extern tree check_for_out_of_scope_variable\t(tree);\n-extern void print_other_binding_stack\t\t(struct cp_binding_level *);\n+extern void print_other_binding_stack\t\t(cp_binding_level *);\n extern tree maybe_push_decl\t\t\t(tree);\n extern tree current_decl_namespace\t\t(void);\n "}, {"sha": "2742af5c2bb70f25aee5190f168d2ea1a61c3ac2", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c1404747a1affb510fcc4908d371f38ee078a1f/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c1404747a1affb510fcc4908d371f38ee078a1f/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=2c1404747a1affb510fcc4908d371f38ee078a1f", "patch": "@@ -184,7 +184,7 @@ struct GTY((chain_next (\"%h.next\"))) named_label_use_entry {\n   /* The binding level to which this entry is *currently* attached.\n      This is initially the binding level in which the goto appeared,\n      but is modified as scopes are closed.  */\n-  struct cp_binding_level *binding_level;\n+  cp_binding_level *binding_level;\n   /* The head of the names list that was current when the goto appeared,\n      or the inner scope popped.  These are the decls that will *not* be\n      skipped when jumping to the label.  */\n@@ -208,7 +208,7 @@ struct GTY(()) named_label_entry {\n   /* The binding level to which the label is *currently* attached.\n      This is initially set to the binding level in which the label\n      is defined, but is modified as scopes are closed.  */\n-  struct cp_binding_level *binding_level;\n+  cp_binding_level *binding_level;\n   /* The head of the names list that was current when the label was\n      defined, or the inner scope popped.  These are the decls that will\n      be skipped when jumping to the label.  */\n@@ -270,7 +270,7 @@ current_tmpl_spec_kind (int n_class_scopes)\n   int n_template_parm_scopes = 0;\n   int seen_specialization_p = 0;\n   int innermost_specialization_p = 0;\n-  struct cp_binding_level *b;\n+  cp_binding_level *b;\n \n   /* Scan through the template parameter scopes.  */\n   for (b = current_binding_level;\n@@ -447,7 +447,7 @@ objc_get_current_scope (void)\n void\n objc_mark_locals_volatile (void *enclosing_blk)\n {\n-  struct cp_binding_level *scope;\n+  cp_binding_level *scope;\n \n   for (scope = current_binding_level;\n        scope && scope != enclosing_blk;\n@@ -470,8 +470,8 @@ static int\n poplevel_named_label_1 (void **slot, void *data)\n {\n   struct named_label_entry *ent = (struct named_label_entry *) *slot;\n-  struct cp_binding_level *bl = (struct cp_binding_level *) data;\n-  struct cp_binding_level *obl = bl->level_chain;\n+  cp_binding_level *bl = (cp_binding_level *) data;\n+  cp_binding_level *obl = bl->level_chain;\n \n   if (ent->binding_level == bl)\n     {\n@@ -853,7 +853,7 @@ walk_namespaces (walk_namespaces_fn f, void* data)\n int\n wrapup_globals_for_namespace (tree name_space, void* data)\n {\n-  struct cp_binding_level *level = NAMESPACE_LEVEL (name_space);\n+  cp_binding_level *level = NAMESPACE_LEVEL (name_space);\n   VEC(tree,gc) *statics = level->static_decls;\n   tree *vec = VEC_address (tree, statics);\n   int len = VEC_length (tree, statics);\n@@ -2644,10 +2644,10 @@ identify_goto (tree decl, const location_t *locus)\n    true if all is well.  */\n \n static bool\n-check_previous_goto_1 (tree decl, struct cp_binding_level* level, tree names,\n+check_previous_goto_1 (tree decl, cp_binding_level* level, tree names,\n \t\t       bool exited_omp, const location_t *locus)\n {\n-  struct cp_binding_level *b;\n+  cp_binding_level *b;\n   bool identified = false, saw_eh = false, saw_omp = false;\n \n   if (exited_omp)\n@@ -2719,7 +2719,7 @@ check_previous_goto (tree decl, struct named_label_use_entry *use)\n }\n \n static bool\n-check_switch_goto (struct cp_binding_level* level)\n+check_switch_goto (cp_binding_level* level)\n {\n   return check_previous_goto_1 (NULL_TREE, level, level->names, false, NULL);\n }\n@@ -2805,7 +2805,7 @@ check_goto (tree decl)\n     error (\"  enters OpenMP structured block\");\n   else if (flag_openmp)\n     {\n-      struct cp_binding_level *b;\n+      cp_binding_level *b;\n       for (b = current_binding_level; b ; b = b->level_chain)\n \t{\n \t  if (b == ent->binding_level)\n@@ -2831,7 +2831,7 @@ check_goto (tree decl)\n bool\n check_omp_return (void)\n {\n-  struct cp_binding_level *b;\n+  cp_binding_level *b;\n   for (b = current_binding_level; b ; b = b->level_chain)\n     if (b->kind == sk_omp)\n       {\n@@ -2850,7 +2850,7 @@ static tree\n define_label_1 (location_t location, tree name)\n {\n   struct named_label_entry *ent, dummy;\n-  struct cp_binding_level *p;\n+  cp_binding_level *p;\n   tree decl;\n \n   decl = lookup_label (name);\n@@ -2909,7 +2909,7 @@ define_label (location_t location, tree name)\n \n struct cp_switch\n {\n-  struct cp_binding_level *level;\n+  cp_binding_level *level;\n   struct cp_switch *next;\n   /* The SWITCH_STMT being built.  */\n   tree switch_stmt;\n@@ -2990,7 +2990,7 @@ tree\n finish_case_label (location_t loc, tree low_value, tree high_value)\n {\n   tree cond, r;\n-  struct cp_binding_level *p;\n+  cp_binding_level *p;\n   tree type;\n \n   if (processing_template_decl)\n@@ -3758,7 +3758,7 @@ cp_make_fname_decl (location_t loc, tree id, int type_dep)\n \n   if (current_function_decl)\n     {\n-      struct cp_binding_level *b = current_binding_level;\n+      cp_binding_level *b = current_binding_level;\n       if (b->kind == sk_function_parms)\n \treturn error_mark_node;\n       while (b->level_chain->kind != sk_function_parms)\n@@ -8499,7 +8499,7 @@ grokdeclarator (const cp_declarator *declarator,\n \n   if (decl_context == NORMAL && !toplevel_bindings_p ())\n     {\n-      struct cp_binding_level *b = current_binding_level;\n+      cp_binding_level *b = current_binding_level;\n       current_binding_level = b->level_chain;\n       if (current_binding_level != 0 && toplevel_bindings_p ())\n \tdecl_context = PARM;\n@@ -12436,7 +12436,7 @@ start_preparsed_function (tree decl1, tree attrs, int flags)\n   tree fntype;\n   tree restype;\n   int doing_friend = 0;\n-  struct cp_binding_level *bl;\n+  cp_binding_level *bl;\n   tree current_function_parms;\n   struct c_fileinfo *finfo\n     = get_fileinfo (LOCATION_FILE (DECL_SOURCE_LOCATION (decl1)));"}, {"sha": "00d21d2e904f040458e292c9480f0e6686c0eafd", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 67, "deletions": 67, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c1404747a1affb510fcc4908d371f38ee078a1f/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c1404747a1affb510fcc4908d371f38ee078a1f/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=2c1404747a1affb510fcc4908d371f38ee078a1f", "patch": "@@ -43,8 +43,8 @@ struct scope_binding {\n };\n #define EMPTY_SCOPE_BINDING { NULL_TREE, NULL_TREE }\n \n-static cxx_scope *innermost_nonclass_level (void);\n-static cxx_binding *binding_for_name (cxx_scope *, tree);\n+static cp_binding_level *innermost_nonclass_level (void);\n+static cxx_binding *binding_for_name (cp_binding_level *, tree);\n static tree push_overloaded_decl (tree, int, bool);\n static bool lookup_using_namespace (tree, struct scope_binding *, tree,\n \t\t\t\t    tree, int);\n@@ -315,7 +315,7 @@ cxx_binding_free (cxx_binding *binding)\n    bindings) in the class scope indicated by SCOPE.  */\n \n static cxx_binding *\n-new_class_binding (tree name, tree value, tree type, cxx_scope *scope)\n+new_class_binding (tree name, tree value, tree type, cp_binding_level *scope)\n {\n   cp_class_binding *cb;\n   cxx_binding *binding;\n@@ -332,7 +332,7 @@ new_class_binding (tree name, tree value, tree type, cxx_scope *scope)\n    level at which this declaration is being bound.  */\n \n static void\n-push_binding (tree id, tree decl, cxx_scope* level)\n+push_binding (tree id, tree decl, cp_binding_level* level)\n {\n   cxx_binding *binding;\n \n@@ -524,7 +524,7 @@ supplement_binding (cxx_binding *binding, tree decl)\n /* Add DECL to the list of things declared in B.  */\n \n static void\n-add_decl_to_level (tree decl, cxx_scope *b)\n+add_decl_to_level (tree decl, cp_binding_level *b)\n {\n   /* We used to record virtual tables as if they were ordinary\n      variables, but no longer do so.  */\n@@ -939,7 +939,7 @@ pushdecl_maybe_friend_1 (tree x, bool is_friend)\n \t  /* Here to install a non-global value.  */\n \t  tree oldglobal = IDENTIFIER_NAMESPACE_VALUE (name);\n \t  tree oldlocal = NULL_TREE;\n-\t  cxx_scope *oldscope = NULL;\n+\t  cp_binding_level *oldscope = NULL;\n \t  cxx_binding *oldbinding = outer_binding (name, NULL, true);\n \t  if (oldbinding)\n \t    {\n@@ -1036,7 +1036,7 @@ pushdecl_maybe_friend_1 (tree x, bool is_friend)\n \t\t{\n \t\t  /* Go to where the parms should be and see if we find\n \t\t     them there.  */\n-\t\t  struct cp_binding_level *b = current_binding_level->level_chain;\n+\t\t  cp_binding_level *b = current_binding_level->level_chain;\n \n \t\t  if (FUNCTION_NEEDS_BODY_BLOCK (current_function_decl))\n \t\t    /* Skip the ctor/dtor cleanup level.  */\n@@ -1054,7 +1054,7 @@ pushdecl_maybe_friend_1 (tree x, bool is_friend)\n \t\t the containing function anyway.  */\n \t      if (DECL_CONTEXT (oldlocal) != current_function_decl)\n \t\t{\n-\t\t  cxx_scope *scope = current_binding_level;\n+\t\t  cp_binding_level *scope = current_binding_level;\n \t\t  tree context = DECL_CONTEXT (oldlocal);\n \t\t  for (; scope; scope = scope->level_chain)\n \t\t   {\n@@ -1215,7 +1215,7 @@ maybe_push_decl (tree decl)\n void\n push_local_binding (tree id, tree decl, int flags)\n {\n-  struct cp_binding_level *b;\n+  cp_binding_level *b;\n \n   /* Skip over any local classes.  This makes sense if we call\n      push_local_binding with a friend decl of a local class.  */\n@@ -1337,7 +1337,7 @@ indent (int depth)\n \n /* Return a string describing the kind of SCOPE we have.  */\n static const char *\n-cxx_scope_descriptor (cxx_scope *scope)\n+cp_binding_level_descriptor (cp_binding_level *scope)\n {\n   /* The order of this table must match the \"scope_kind\"\n      enumerators.  */\n@@ -1362,9 +1362,9 @@ cxx_scope_descriptor (cxx_scope *scope)\n /* Output a debugging information about SCOPE when performing\n    ACTION at LINE.  */\n static void\n-cxx_scope_debug (cxx_scope *scope, int line, const char *action)\n+cp_binding_level_debug (cp_binding_level *scope, int line, const char *action)\n {\n-  const char *desc = cxx_scope_descriptor (scope);\n+  const char *desc = cp_binding_level_descriptor (scope);\n   if (scope->this_entity)\n     verbatim (\"%s %s(%E) %p %d\\n\", action, desc,\n \t      scope->this_entity, (void *) scope, line);\n@@ -1389,12 +1389,12 @@ namespace_scope_ht_size (tree ns)\n \n /* A chain of binding_level structures awaiting reuse.  */\n \n-static GTY((deletable)) struct cp_binding_level *free_binding_level;\n+static GTY((deletable)) cp_binding_level *free_binding_level;\n \n /* Insert SCOPE as the innermost binding level.  */\n \n void\n-push_binding_level (struct cp_binding_level *scope)\n+push_binding_level (cp_binding_level *scope)\n {\n   /* Add it to the front of currently active scopes stack.  */\n   scope->level_chain = current_binding_level;\n@@ -1405,7 +1405,7 @@ push_binding_level (struct cp_binding_level *scope)\n     {\n       scope->binding_depth = binding_depth;\n       indent (binding_depth);\n-      cxx_scope_debug (scope, input_line, \"push\");\n+      cp_binding_level_debug (scope, input_line, \"push\");\n       binding_depth++;\n     }\n }\n@@ -1414,20 +1414,20 @@ push_binding_level (struct cp_binding_level *scope)\n    ENTITY is the scope of the associated C++ entity (namespace, class,\n    function, C++0x enumeration); it is NULL otherwise.  */\n \n-cxx_scope *\n+cp_binding_level *\n begin_scope (scope_kind kind, tree entity)\n {\n-  cxx_scope *scope;\n+  cp_binding_level *scope;\n \n   /* Reuse or create a struct for this binding level.  */\n   if (!ENABLE_SCOPE_CHECKING && free_binding_level)\n     {\n       scope = free_binding_level;\n-      memset (scope, 0, sizeof (cxx_scope));\n+      memset (scope, 0, sizeof (cp_binding_level));\n       free_binding_level = scope->level_chain;\n     }\n   else\n-    scope = ggc_alloc_cleared_cxx_scope ();\n+    scope = ggc_alloc_cleared_cp_binding_level ();\n \n   scope->this_entity = entity;\n   scope->more_cleanups_ok = true;\n@@ -1478,10 +1478,10 @@ begin_scope (scope_kind kind, tree entity)\n /* We're about to leave current scope.  Pop the top of the stack of\n    currently active scopes.  Return the enclosing scope, now active.  */\n \n-cxx_scope *\n+cp_binding_level *\n leave_scope (void)\n {\n-  cxx_scope *scope = current_binding_level;\n+  cp_binding_level *scope = current_binding_level;\n \n   if (scope->kind == sk_namespace && class_binding_level)\n     current_binding_level = class_binding_level;\n@@ -1493,7 +1493,7 @@ leave_scope (void)\n   if (ENABLE_SCOPE_CHECKING)\n     {\n       indent (--binding_depth);\n-      cxx_scope_debug (scope, input_line, \"leave\");\n+      cp_binding_level_debug (scope, input_line, \"leave\");\n     }\n \n   /* Move one nesting level up.  */\n@@ -1530,7 +1530,7 @@ leave_scope (void)\n }\n \n static void\n-resume_scope (struct cp_binding_level* b)\n+resume_scope (cp_binding_level* b)\n {\n   /* Resuming binding levels is meant only for namespaces,\n      and those cannot nest into classes.  */\n@@ -1542,17 +1542,17 @@ resume_scope (struct cp_binding_level* b)\n     {\n       b->binding_depth = binding_depth;\n       indent (binding_depth);\n-      cxx_scope_debug (b, input_line, \"resume\");\n+      cp_binding_level_debug (b, input_line, \"resume\");\n       binding_depth++;\n     }\n }\n \n /* Return the innermost binding level that is not for a class scope.  */\n \n-static cxx_scope *\n+static cp_binding_level *\n innermost_nonclass_level (void)\n {\n-  cxx_scope *b;\n+  cp_binding_level *b;\n \n   b = current_binding_level;\n   while (b->kind == sk_class)\n@@ -1594,7 +1594,7 @@ global_bindings_p (void)\n bool\n toplevel_bindings_p (void)\n {\n-  struct cp_binding_level *b = innermost_nonclass_level ();\n+  cp_binding_level *b = innermost_nonclass_level ();\n \n   return b->kind == sk_namespace || b->kind == sk_template_parms;\n }\n@@ -1606,7 +1606,7 @@ toplevel_bindings_p (void)\n bool\n namespace_bindings_p (void)\n {\n-  struct cp_binding_level *b = innermost_nonclass_level ();\n+  cp_binding_level *b = innermost_nonclass_level ();\n \n   return b->kind == sk_namespace;\n }\n@@ -1666,7 +1666,7 @@ int\n function_parm_depth (void)\n {\n   int level = 0;\n-  struct cp_binding_level *b;\n+  cp_binding_level *b;\n \n   for (b = current_binding_level;\n        b->kind == sk_function_parms;\n@@ -1681,7 +1681,7 @@ static int no_print_functions = 0;\n static int no_print_builtins = 0;\n \n static void\n-print_binding_level (struct cp_binding_level* lvl)\n+print_binding_level (cp_binding_level* lvl)\n {\n   tree t;\n   int i = 0, len;\n@@ -1743,9 +1743,9 @@ print_binding_level (struct cp_binding_level* lvl)\n }\n \n void\n-print_other_binding_stack (struct cp_binding_level *stack)\n+print_other_binding_stack (cp_binding_level *stack)\n {\n-  struct cp_binding_level *level;\n+  cp_binding_level *level;\n   for (level = stack; !global_scope_p (level); level = level->level_chain)\n     {\n       fprintf (stderr, \"binding level %p\\n\", (void *) level);\n@@ -1756,7 +1756,7 @@ print_other_binding_stack (struct cp_binding_level *stack)\n void\n print_binding_stack (void)\n {\n-  struct cp_binding_level *b;\n+  cp_binding_level *b;\n   fprintf (stderr, \"current_binding_level=%p\\n\"\n \t   \"class_binding_level=%p\\n\"\n \t   \"NAMESPACE_LEVEL (global_namespace)=%p\\n\",\n@@ -1825,7 +1825,7 @@ identifier_global_value\t(tree t)\n    the tag ID is not already defined.  */\n \n static void\n-set_identifier_type_value_with_scope (tree id, tree decl, cxx_scope *b)\n+set_identifier_type_value_with_scope (tree id, tree decl, cp_binding_level *b)\n {\n   tree type;\n \n@@ -1949,7 +1949,7 @@ make_lambda_name (void)\n /* Return (from the stack of) the BINDING, if any, established at SCOPE.  */\n \n static inline cxx_binding *\n-find_binding (cxx_scope *scope, cxx_binding *binding)\n+find_binding (cp_binding_level *scope, cxx_binding *binding)\n {\n   for (; binding != NULL; binding = binding->previous)\n     if (binding->scope == scope)\n@@ -1961,7 +1961,7 @@ find_binding (cxx_scope *scope, cxx_binding *binding)\n /* Return the binding for NAME in SCOPE, if any.  Otherwise, return NULL.  */\n \n static inline cxx_binding *\n-cxx_scope_find_binding_for_name (cxx_scope *scope, tree name)\n+cp_binding_level_find_binding_for_name (cp_binding_level *scope, tree name)\n {\n   cxx_binding *b = IDENTIFIER_NAMESPACE_BINDINGS (name);\n   if (b)\n@@ -1978,11 +1978,11 @@ cxx_scope_find_binding_for_name (cxx_scope *scope, tree name)\n    found, make a new one.  */\n \n static cxx_binding *\n-binding_for_name (cxx_scope *scope, tree name)\n+binding_for_name (cp_binding_level *scope, tree name)\n {\n   cxx_binding *result;\n \n-  result = cxx_scope_find_binding_for_name (scope, name);\n+  result = cp_binding_level_find_binding_for_name (scope, name);\n   if (result)\n     return result;\n   /* Not found, make a new one.  */\n@@ -2073,9 +2073,9 @@ push_using_decl (tree scope, tree name)\n    closer binding level than LEVEL.  */\n \n static tree\n-pushdecl_with_scope_1 (tree x, cxx_scope *level, bool is_friend)\n+pushdecl_with_scope_1 (tree x, cp_binding_level *level, bool is_friend)\n {\n-  struct cp_binding_level *b;\n+  cp_binding_level *b;\n   tree function_decl = current_function_decl;\n \n   current_function_decl = NULL_TREE;\n@@ -2100,7 +2100,7 @@ pushdecl_with_scope_1 (tree x, cxx_scope *level, bool is_friend)\n /* Wrapper for pushdecl_with_scope_1.  */\n \n tree\n-pushdecl_with_scope (tree x, cxx_scope *level, bool is_friend)\n+pushdecl_with_scope (tree x, cp_binding_level *level, bool is_friend)\n {\n   tree ret;\n   bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n@@ -2610,12 +2610,12 @@ push_inner_scope_r (tree outer, tree inner)\n     push_inner_scope_r (outer, prev);\n   if (TREE_CODE (inner) == NAMESPACE_DECL)\n     {\n-      struct cp_binding_level *save_template_parm = 0;\n+      cp_binding_level *save_template_parm = 0;\n       /* Temporary take out template parameter scopes.  They are saved\n \t in reversed order in save_template_parm.  */\n       while (current_binding_level->kind == sk_template_parms)\n \t{\n-\t  struct cp_binding_level *b = current_binding_level;\n+\t  cp_binding_level *b = current_binding_level;\n \t  current_binding_level = b->level_chain;\n \t  b->level_chain = save_template_parm;\n \t  save_template_parm = b;\n@@ -2627,7 +2627,7 @@ push_inner_scope_r (tree outer, tree inner)\n       /* Restore template parameter scopes.  */\n       while (save_template_parm)\n \t{\n-\t  struct cp_binding_level *b = save_template_parm;\n+\t  cp_binding_level *b = save_template_parm;\n \t  save_template_parm = b->level_chain;\n \t  b->level_chain = current_binding_level;\n \t  current_binding_level = b;\n@@ -2669,12 +2669,12 @@ pop_inner_scope (tree outer, tree inner)\n     {\n       if (TREE_CODE (inner) == NAMESPACE_DECL)\n \t{\n-\t  struct cp_binding_level *save_template_parm = 0;\n+\t  cp_binding_level *save_template_parm = 0;\n \t  /* Temporary take out template parameter scopes.  They are saved\n \t     in reversed order in save_template_parm.  */\n \t  while (current_binding_level->kind == sk_template_parms)\n \t    {\n-\t      struct cp_binding_level *b = current_binding_level;\n+\t      cp_binding_level *b = current_binding_level;\n \t      current_binding_level = b->level_chain;\n \t      b->level_chain = save_template_parm;\n \t      save_template_parm = b;\n@@ -2685,7 +2685,7 @@ pop_inner_scope (tree outer, tree inner)\n \t  /* Restore template parameter scopes.  */\n \t  while (save_template_parm)\n \t    {\n-\t      struct cp_binding_level *b = save_template_parm;\n+\t      cp_binding_level *b = save_template_parm;\n \t      save_template_parm = b->level_chain;\n \t      b->level_chain = current_binding_level;\n \t      current_binding_level = b;\n@@ -2711,7 +2711,7 @@ pushlevel_class (void)\n void\n poplevel_class (void)\n {\n-  struct cp_binding_level *level = class_binding_level;\n+  cp_binding_level *level = class_binding_level;\n   cp_class_binding *cb;\n   size_t i;\n   tree shadowed;\n@@ -2832,7 +2832,7 @@ pushdecl_class_level (tree x)\n    is not set, callers must set the PREVIOUS field explicitly.  */\n \n static cxx_binding *\n-get_class_binding (tree name, cxx_scope *scope)\n+get_class_binding (tree name, cp_binding_level *scope)\n {\n   tree class_type;\n   tree type_binding;\n@@ -3181,7 +3181,7 @@ namespace_binding_1 (tree name, tree scope)\n     /* Unnecessary for the global namespace because it can't be an alias. */\n     scope = ORIGINAL_NAMESPACE (scope);\n \n-  binding = cxx_scope_find_binding_for_name (NAMESPACE_LEVEL (scope), name);\n+  binding = cp_binding_level_find_binding_for_name (NAMESPACE_LEVEL (scope), name);\n \n   return binding ? binding->value : NULL_TREE;\n }\n@@ -3586,7 +3586,7 @@ do_namespace_alias (tree alias, tree name_space)\n tree\n pushdecl_namespace_level (tree x, bool is_friend)\n {\n-  struct cp_binding_level *b = current_binding_level;\n+  cp_binding_level *b = current_binding_level;\n   tree t;\n \n   bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n@@ -4078,7 +4078,7 @@ suggest_alternatives_for (location_t location, tree name)\n     {\n       tree scope = VEC_pop (tree, namespaces_to_search);\n       struct scope_binding binding = EMPTY_SCOPE_BINDING;\n-      struct cp_binding_level *level = NAMESPACE_LEVEL (scope);\n+      cp_binding_level *level = NAMESPACE_LEVEL (scope);\n \n       /* Look in this namespace.  */\n       qualified_lookup_using_namespace (name, scope, &binding, 0);\n@@ -4128,14 +4128,14 @@ unqualified_namespace_lookup_1 (tree name, int flags)\n   tree initial = current_decl_namespace ();\n   tree scope = initial;\n   tree siter;\n-  struct cp_binding_level *level;\n+  cp_binding_level *level;\n   tree val = NULL_TREE;\n \n   for (; !val; scope = CP_DECL_CONTEXT (scope))\n     {\n       struct scope_binding binding = EMPTY_SCOPE_BINDING;\n       cxx_binding *b =\n-\t cxx_scope_find_binding_for_name (NAMESPACE_LEVEL (scope), name);\n+\t cp_binding_level_find_binding_for_name (NAMESPACE_LEVEL (scope), name);\n \n       if (b)\n \tambiguous_decl (&binding, b, flags);\n@@ -4237,7 +4237,7 @@ lookup_using_namespace (tree name, struct scope_binding *val,\n       {\n \ttree used = ORIGINAL_NAMESPACE (TREE_PURPOSE (iter));\n \tcxx_binding *val1 =\n-\t  cxx_scope_find_binding_for_name (NAMESPACE_LEVEL (used), name);\n+\t  cp_binding_level_find_binding_for_name (NAMESPACE_LEVEL (used), name);\n \t/* Resolve ambiguities.  */\n \tif (val1)\n \t  ambiguous_decl (val, val1, flags);\n@@ -4306,7 +4306,7 @@ qualified_lookup_using_namespace (tree name, tree scope,\n \t  VEC_safe_push (tree, gc, seen_inline, scope);\n \n \t  binding =\n-\t    cxx_scope_find_binding_for_name (NAMESPACE_LEVEL (scope), name);\n+\t    cp_binding_level_find_binding_for_name (NAMESPACE_LEVEL (scope), name);\n \t  if (binding)\n \t    {\n \t      found_here = true;\n@@ -4350,7 +4350,7 @@ qualified_lookup_using_namespace (tree name, tree scope,\n \n static bool\n binding_to_template_parms_of_scope_p (cxx_binding *binding,\n-\t\t\t\t      cxx_scope *scope)\n+\t\t\t\t      cp_binding_level *scope)\n {\n   tree binding_value;\n \n@@ -4381,8 +4381,8 @@ outer_binding (tree name,\n \t       bool class_p)\n {\n   cxx_binding *outer;\n-  cxx_scope *scope;\n-  cxx_scope *outer_scope;\n+  cp_binding_level *scope;\n+  cp_binding_level *outer_scope;\n \n   if (binding)\n     {\n@@ -4475,7 +4475,7 @@ lookup_name_real_1 (tree name, int prefer_type, int nonclass, bool block_p,\n      operators.  */\n   if (IDENTIFIER_TYPENAME_P (name))\n     {\n-      struct cp_binding_level *level;\n+      cp_binding_level *level;\n \n       for (level = current_binding_level;\n \t   level && level->kind != sk_namespace;\n@@ -4690,7 +4690,7 @@ lookup_type_scope_1 (tree name, tag_scope scope)\n   /* Look in namespace scope.  */\n   if (!val)\n     {\n-      iter = cxx_scope_find_binding_for_name\n+      iter = cp_binding_level_find_binding_for_name\n \t       (NAMESPACE_LEVEL (current_decl_namespace ()), name);\n \n       if (iter)\n@@ -4708,7 +4708,7 @@ lookup_type_scope_1 (tree name, tag_scope scope)\n      and template parameter scopes.  */\n   if (val)\n     {\n-      struct cp_binding_level *b = current_binding_level;\n+      cp_binding_level *b = current_binding_level;\n       while (b)\n \t{\n \t  if (iter->scope == b)\n@@ -4747,7 +4747,7 @@ lookup_type_scope (tree name, tag_scope scope)\n static tree\n lookup_name_innermost_nonclass_level_1 (tree name)\n {\n-  struct cp_binding_level *b;\n+  cp_binding_level *b;\n   tree t = NULL_TREE;\n \n   b = innermost_nonclass_level ();\n@@ -4836,7 +4836,7 @@ lookup_type_current_level (tree name)\n   if (REAL_IDENTIFIER_TYPE_VALUE (name) != NULL_TREE\n       && REAL_IDENTIFIER_TYPE_VALUE (name) != global_type_node)\n     {\n-      struct cp_binding_level *b = current_binding_level;\n+      cp_binding_level *b = current_binding_level;\n       while (1)\n \t{\n \t  if (purpose_member (name, b->type_shadowed))\n@@ -5446,7 +5446,7 @@ push_using_directive (tree used)\n \n static tree\n maybe_process_template_type_declaration (tree type, int is_friend,\n-\t\t\t\t\t cxx_scope *b)\n+\t\t\t\t\t cp_binding_level *b)\n {\n   tree decl = TYPE_NAME (type);\n \n@@ -5528,7 +5528,7 @@ maybe_process_template_type_declaration (tree type, int is_friend,\n static tree\n pushtag_1 (tree name, tree type, tag_scope scope)\n {\n-  struct cp_binding_level *b;\n+  cp_binding_level *b;\n   tree decl;\n \n   b = current_binding_level;\n@@ -5745,7 +5745,7 @@ void\n push_to_top_level (void)\n {\n   struct saved_scope *s;\n-  struct cp_binding_level *b;\n+  cp_binding_level *b;\n   cxx_saved_binding *sb;\n   size_t i;\n   bool need_pop;"}, {"sha": "5974dce328813c6bda77225330718944adb6d837", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 83, "deletions": 83, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c1404747a1affb510fcc4908d371f38ee078a1f/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c1404747a1affb510fcc4908d371f38ee078a1f/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=2c1404747a1affb510fcc4908d371f38ee078a1f", "patch": "@@ -53,7 +53,7 @@ extern binding_entry binding_table_find (binding_table, tree);\n typedef struct cxx_binding cxx_binding;\n \n /* The datatype used to implement C++ scope.  */\n-typedef struct cp_binding_level cxx_scope;\n+typedef struct cp_binding_level cp_binding_level;\n \n /* Nonzero if this binding is for a local scope, as opposed to a class\n    or namespace scope.  */\n@@ -71,7 +71,7 @@ struct GTY(()) cxx_binding {\n   /* The type entity this name is bound to.  */\n   tree type;\n   /* The scope at which this binding was made.  */\n-  cxx_scope *scope;\n+  cp_binding_level *scope;\n   unsigned value_is_inherited : 1;\n   unsigned is_local : 1;\n };\n@@ -185,83 +185,83 @@ DEF_VEC_ALLOC_O(cp_label_binding,gc);\n    is duplicated in the IDENTIFIER_GLOBAL_VALUEs of all identifiers.  */\n \n struct GTY(()) cp_binding_level {\n-    /* A chain of _DECL nodes for all variables, constants, functions,\n-       and typedef types.  These are in the reverse of the order\n-       supplied.  There may be OVERLOADs on this list, too, but they\n-       are wrapped in TREE_LISTs; the TREE_VALUE is the OVERLOAD.  */\n-    tree names;\n-\n-    /* A chain of NAMESPACE_DECL nodes.  */\n-    tree namespaces;\n-\n-    /* An array of static functions and variables (for namespaces only) */\n-    VEC(tree,gc) *static_decls;\n-\n-    /* A list of USING_DECL nodes.  */\n-    tree usings;\n-\n-    /* A list of used namespaces. PURPOSE is the namespace,\n-       VALUE the common ancestor with this binding_level's namespace.  */\n-    tree using_directives;\n-\n-    /* For the binding level corresponding to a class, the entities\n-       declared in the class or its base classes.  */\n-    VEC(cp_class_binding,gc) *class_shadowed;\n-\n-    /* Similar to class_shadowed, but for IDENTIFIER_TYPE_VALUE, and\n-       is used for all binding levels. The TREE_PURPOSE is the name of\n-       the entity, the TREE_TYPE is the associated type.  In addition\n-       the TREE_VALUE is the IDENTIFIER_TYPE_VALUE before we entered\n-       the class.  */\n-    tree type_shadowed;\n-\n-    /* Similar to class_shadowed, but for IDENTIFIER_LABEL_VALUE, and\n-       used for all binding levels.  */\n-    VEC(cp_label_binding,gc) *shadowed_labels;\n-\n-    /* For each level (except not the global one),\n-       a chain of BLOCK nodes for all the levels\n-       that were entered and exited one level down.  */\n-    tree blocks;\n-\n-    /* The entity (namespace, class, function) the scope of which this\n-       binding contour corresponds to.  Otherwise NULL.  */\n-    tree this_entity;\n-\n-    /* The binding level which this one is contained in (inherits from).  */\n-    struct cp_binding_level *level_chain;\n-\n-    /* List of VAR_DECLS saved from a previous for statement.\n-       These would be dead in ISO-conforming code, but might\n-       be referenced in ARM-era code.  */\n-    VEC(tree,gc) *dead_vars_from_for;\n-\n-    /* STATEMENT_LIST for statements in this binding contour.\n-       Only used at present for SK_CLEANUP temporary bindings.  */\n-    tree statement_list;\n-\n-    /* Binding depth at which this level began.  */\n-    int binding_depth;\n-\n-    /* The kind of scope that this object represents.  However, a\n-       SK_TEMPLATE_SPEC scope is represented with KIND set to\n-       SK_TEMPLATE_PARMS and EXPLICIT_SPEC_P set to true.  */\n-    ENUM_BITFIELD (scope_kind) kind : 4;\n-\n-    /* True if this scope is an SK_TEMPLATE_SPEC scope.  This field is\n-       only valid if KIND == SK_TEMPLATE_PARMS.  */\n-    BOOL_BITFIELD explicit_spec_p : 1;\n-\n-    /* true means make a BLOCK for this level regardless of all else.  */\n-    unsigned keep : 1;\n-\n-    /* Nonzero if this level can safely have additional\n-       cleanup-needing variables added to it.  */\n-    unsigned more_cleanups_ok : 1;\n-    unsigned have_cleanups : 1;\n-\n-    /* 24 bits left to fill a 32-bit word.  */\n-  };\n+  /* A chain of _DECL nodes for all variables, constants, functions,\n+      and typedef types.  These are in the reverse of the order\n+      supplied.  There may be OVERLOADs on this list, too, but they\n+      are wrapped in TREE_LISTs; the TREE_VALUE is the OVERLOAD.  */\n+  tree names;\n+\n+  /* A chain of NAMESPACE_DECL nodes.  */\n+  tree namespaces;\n+\n+  /* An array of static functions and variables (for namespaces only) */\n+  VEC(tree,gc) *static_decls;\n+\n+  /* A list of USING_DECL nodes.  */\n+  tree usings;\n+\n+  /* A list of used namespaces. PURPOSE is the namespace,\n+      VALUE the common ancestor with this binding_level's namespace.  */\n+  tree using_directives;\n+\n+  /* For the binding level corresponding to a class, the entities\n+      declared in the class or its base classes.  */\n+  VEC(cp_class_binding,gc) *class_shadowed;\n+\n+  /* Similar to class_shadowed, but for IDENTIFIER_TYPE_VALUE, and\n+      is used for all binding levels. The TREE_PURPOSE is the name of\n+      the entity, the TREE_TYPE is the associated type.  In addition\n+      the TREE_VALUE is the IDENTIFIER_TYPE_VALUE before we entered\n+      the class.  */\n+  tree type_shadowed;\n+\n+  /* Similar to class_shadowed, but for IDENTIFIER_LABEL_VALUE, and\n+      used for all binding levels.  */\n+  VEC(cp_label_binding,gc) *shadowed_labels;\n+\n+  /* For each level (except not the global one),\n+      a chain of BLOCK nodes for all the levels\n+      that were entered and exited one level down.  */\n+  tree blocks;\n+\n+  /* The entity (namespace, class, function) the scope of which this\n+      binding contour corresponds to.  Otherwise NULL.  */\n+  tree this_entity;\n+\n+  /* The binding level which this one is contained in (inherits from).  */\n+  cp_binding_level *level_chain;\n+\n+  /* List of VAR_DECLS saved from a previous for statement.\n+      These would be dead in ISO-conforming code, but might\n+      be referenced in ARM-era code.  */\n+  VEC(tree,gc) *dead_vars_from_for;\n+\n+  /* STATEMENT_LIST for statements in this binding contour.\n+      Only used at present for SK_CLEANUP temporary bindings.  */\n+  tree statement_list;\n+\n+  /* Binding depth at which this level began.  */\n+  int binding_depth;\n+\n+  /* The kind of scope that this object represents.  However, a\n+      SK_TEMPLATE_SPEC scope is represented with KIND set to\n+      SK_TEMPLATE_PARMS and EXPLICIT_SPEC_P set to true.  */\n+  ENUM_BITFIELD (scope_kind) kind : 4;\n+\n+  /* True if this scope is an SK_TEMPLATE_SPEC scope.  This field is\n+      only valid if KIND == SK_TEMPLATE_PARMS.  */\n+  BOOL_BITFIELD explicit_spec_p : 1;\n+\n+  /* true means make a BLOCK for this level regardless of all else.  */\n+  unsigned keep : 1;\n+\n+  /* Nonzero if this level can safely have additional\n+      cleanup-needing variables added to it.  */\n+  unsigned more_cleanups_ok : 1;\n+  unsigned have_cleanups : 1;\n+\n+  /* 24 bits left to fill a 32-bit word.  */\n+};\n \n /* The binding level currently in effect.  */\n \n@@ -287,14 +287,14 @@ extern GTY(()) tree global_type_node;\n #define global_scope_p(SCOPE) \\\n   ((SCOPE) == NAMESPACE_LEVEL (global_namespace))\n \n-extern cxx_scope *leave_scope (void);\n+extern cp_binding_level *leave_scope (void);\n extern bool kept_level_p (void);\n extern bool global_bindings_p (void);\n extern bool toplevel_bindings_p\t(void);\n extern bool namespace_bindings_p (void);\n extern bool template_parm_scope_p (void);\n extern scope_kind innermost_scope_kind (void);\n-extern cxx_scope *begin_scope (scope_kind, tree);\n+extern cp_binding_level *begin_scope (scope_kind, tree);\n extern void print_binding_stack\t(void);\n extern void push_to_top_level (void);\n extern void pop_from_top_level (void);\n@@ -305,7 +305,7 @@ extern tree push_scope (tree);\n extern void pop_scope (tree);\n extern tree push_inner_scope (tree);\n extern void pop_inner_scope (tree, tree);\n-extern void push_binding_level (struct cp_binding_level *);\n+extern void push_binding_level (cp_binding_level *);\n \f\n extern void push_namespace (tree);\n extern void pop_namespace (void);\n@@ -314,7 +314,7 @@ extern void pop_nested_namespace (tree);\n extern bool handle_namespace_attrs (tree, tree);\n extern void pushlevel_class (void);\n extern void poplevel_class (void);\n-extern tree pushdecl_with_scope (tree, cxx_scope *, bool);\n+extern tree pushdecl_with_scope (tree, cp_binding_level *, bool);\n extern tree lookup_name_prefer_type (tree, int);\n extern tree lookup_name_real (tree, int, int, bool, int, int);\n extern tree lookup_type_scope (tree, tag_scope);"}, {"sha": "d50e214ddf20cd45f3b0dd6ff475ee9243bbd3ae", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c1404747a1affb510fcc4908d371f38ee078a1f/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c1404747a1affb510fcc4908d371f38ee078a1f/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=2c1404747a1affb510fcc4908d371f38ee078a1f", "patch": "@@ -1791,7 +1791,7 @@ determine_specialization (tree template_id,\n      with the signature of DECL.  */\n   tree templates = NULL_TREE;\n   int header_count;\n-  struct cp_binding_level *b;\n+  cp_binding_level *b;\n \n   *targs_out = NULL_TREE;\n "}, {"sha": "fadef4d87d0d8a472410fa84e90a59df1720f094", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c1404747a1affb510fcc4908d371f38ee078a1f/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c1404747a1affb510fcc4908d371f38ee078a1f/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=2c1404747a1affb510fcc4908d371f38ee078a1f", "patch": "@@ -8452,7 +8452,7 @@ is_normal_capture_proxy (tree decl)\n static inline void\n insert_capture_proxy (tree var)\n {\n-  cxx_scope *b;\n+  cp_binding_level *b;\n   int skip;\n   tree stmt_list;\n \n@@ -8461,7 +8461,7 @@ insert_capture_proxy (tree var)\n   b = current_binding_level;\n   for (skip = 0; ; ++skip)\n     {\n-      cxx_scope *n = b->level_chain;\n+      cp_binding_level *n = b->level_chain;\n       if (n->kind == sk_function_parms)\n \tbreak;\n       b = n;"}]}