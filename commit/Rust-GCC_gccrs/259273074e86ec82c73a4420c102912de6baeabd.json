{"sha": "259273074e86ec82c73a4420c102912de6baeabd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjU5MjczMDc0ZTg2ZWM4MmM3M2E0NDIwYzEwMjkxMmRlNmJhZWFiZA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2018-06-20T08:09:48Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-06-20T08:09:48Z"}, "message": "[6/n] PR85694: Add a vect_get_internal_def helper\n\nThis patch adds a helper for pattern code that wants to find an\ninternal (vectorisable) definition of an SSA name.\n\nA later patch will make more use of this, and alter the definition.\n\n2018-06-20  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* tree-vect-patterns.c (vect_get_internal_def): New function.\n\t(vect_recog_dot_prod_pattern, vect_recog_sad_pattern)\n\t(vect_recog_vector_vector_shift_pattern, check_bool_pattern)\n\t(search_type_for_mask_1): Use it.\n\nFrom-SVN: r261789", "tree": {"sha": "46e28807db484415db7da05edf4c7dcc3871d63b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/46e28807db484415db7da05edf4c7dcc3871d63b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/259273074e86ec82c73a4420c102912de6baeabd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/259273074e86ec82c73a4420c102912de6baeabd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/259273074e86ec82c73a4420c102912de6baeabd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/259273074e86ec82c73a4420c102912de6baeabd/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1f78617090283f22825807fcc0533e27e983dcde", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f78617090283f22825807fcc0533e27e983dcde", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f78617090283f22825807fcc0533e27e983dcde"}], "stats": {"total": 144, "additions": 68, "deletions": 76}, "files": [{"sha": "6ad807c337e2b8618db3a7443469e5161ed00c36", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/259273074e86ec82c73a4420c102912de6baeabd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/259273074e86ec82c73a4420c102912de6baeabd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=259273074e86ec82c73a4420c102912de6baeabd", "patch": "@@ -1,3 +1,10 @@\n+2018-06-20  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree-vect-patterns.c (vect_get_internal_def): New function.\n+\t(vect_recog_dot_prod_pattern, vect_recog_sad_pattern)\n+\t(vect_recog_vector_vector_shift_pattern, check_bool_pattern)\n+\t(search_type_for_mask_1): Use it.\n+\n 2018-06-20  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* tree-vect-patterns.c (vect_recog_dot_prod_pattern): Remove"}, {"sha": "71b31aca21c7e2d0d10c0a8fbb9f6c26424d6620", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 61, "deletions": 76, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/259273074e86ec82c73a4420c102912de6baeabd/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/259273074e86ec82c73a4420c102912de6baeabd/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=259273074e86ec82c73a4420c102912de6baeabd", "patch": "@@ -155,6 +155,22 @@ vect_single_imm_use (gimple *def_stmt)\n   return use_stmt;\n }\n \n+/* If OP is defined by a statement that's being considered for vectorization,\n+   return information about that statement, otherwise return NULL.  */\n+\n+static stmt_vec_info\n+vect_get_internal_def (vec_info *vinfo, tree op)\n+{\n+  vect_def_type dt;\n+  gimple *def_stmt;\n+  if (TREE_CODE (op) != SSA_NAME\n+      || !vect_is_simple_use (op, vinfo, &def_stmt, &dt)\n+      || dt != vect_internal_def)\n+    return NULL;\n+\n+  return vinfo_for_stmt (def_stmt);\n+}\n+\n /* Check whether NAME, an ssa-name used in USE_STMT,\n    is a result of a type promotion, such that:\n      DEF_STMT: NAME = NOP (name0)\n@@ -288,6 +304,7 @@ vect_recog_dot_prod_pattern (vec<gimple *> *stmts, tree *type_in,\n   tree oprnd0, oprnd1;\n   tree oprnd00, oprnd01;\n   stmt_vec_info stmt_vinfo = vinfo_for_stmt (last_stmt);\n+  vec_info *vinfo = stmt_vinfo->vinfo;\n   tree type, half_type;\n   gimple *pattern_stmt;\n   tree prod_type;\n@@ -367,51 +384,44 @@ vect_recog_dot_prod_pattern (vec<gimple *> *stmts, tree *type_in,\n     return NULL;\n \n   prod_type = half_type;\n-  stmt = SSA_NAME_DEF_STMT (oprnd0);\n-\n-  /* It could not be the dot_prod pattern if the stmt is outside the loop.  */\n-  if (!gimple_bb (stmt) || !flow_bb_inside_loop_p (loop, gimple_bb (stmt)))\n+  stmt_vec_info mult_vinfo = vect_get_internal_def (vinfo, oprnd0);\n+  if (!mult_vinfo)\n     return NULL;\n \n   /* FORNOW.  Can continue analyzing the def-use chain when this stmt in a phi\n      inside the loop (in case we are analyzing an outer-loop).  */\n-  if (!is_gimple_assign (stmt))\n+  gassign *mult = dyn_cast <gassign *> (mult_vinfo->stmt);\n+  if (!mult || gimple_assign_rhs_code (mult) != MULT_EXPR)\n     return NULL;\n-  stmt_vinfo = vinfo_for_stmt (stmt);\n-  gcc_assert (stmt_vinfo);\n-  if (STMT_VINFO_DEF_TYPE (stmt_vinfo) != vect_internal_def)\n-    return NULL;\n-  if (gimple_assign_rhs_code (stmt) != MULT_EXPR)\n-    return NULL;\n-  if (STMT_VINFO_IN_PATTERN_P (stmt_vinfo))\n+  if (STMT_VINFO_IN_PATTERN_P (mult_vinfo))\n     {\n       /* Has been detected as a widening multiplication?  */\n \n-      stmt = STMT_VINFO_RELATED_STMT (stmt_vinfo);\n-      if (gimple_assign_rhs_code (stmt) != WIDEN_MULT_EXPR)\n+      mult = dyn_cast <gassign *> (STMT_VINFO_RELATED_STMT (mult_vinfo));\n+      if (!mult || gimple_assign_rhs_code (mult) != WIDEN_MULT_EXPR)\n         return NULL;\n-      STMT_VINFO_PATTERN_DEF_SEQ (vinfo_for_stmt (last_stmt))\n-\t= STMT_VINFO_PATTERN_DEF_SEQ (stmt_vinfo);\n-      stmt_vinfo = vinfo_for_stmt (stmt);\n-      gcc_assert (stmt_vinfo);\n-      gcc_assert (STMT_VINFO_DEF_TYPE (stmt_vinfo) == vect_internal_def);\n-      oprnd00 = gimple_assign_rhs1 (stmt);\n-      oprnd01 = gimple_assign_rhs2 (stmt);\n+      STMT_VINFO_PATTERN_DEF_SEQ (stmt_vinfo)\n+\t= STMT_VINFO_PATTERN_DEF_SEQ (mult_vinfo);\n+      mult_vinfo = vinfo_for_stmt (mult);\n+      gcc_assert (mult_vinfo);\n+      gcc_assert (STMT_VINFO_DEF_TYPE (mult_vinfo) == vect_internal_def);\n+      oprnd00 = gimple_assign_rhs1 (mult);\n+      oprnd01 = gimple_assign_rhs2 (mult);\n     }\n   else\n     {\n       tree half_type0, half_type1;\n       gimple *def_stmt;\n       tree oprnd0, oprnd1;\n \n-      oprnd0 = gimple_assign_rhs1 (stmt);\n-      oprnd1 = gimple_assign_rhs2 (stmt);\n-      if (!type_conversion_p (oprnd0, stmt, true, &half_type0, &def_stmt,\n+      oprnd0 = gimple_assign_rhs1 (mult);\n+      oprnd1 = gimple_assign_rhs2 (mult);\n+      if (!type_conversion_p (oprnd0, mult, true, &half_type0, &def_stmt,\n \t\t\t      &promotion)\n \t  || !promotion)\n         return NULL;\n       oprnd00 = gimple_assign_rhs1 (def_stmt);\n-      if (!type_conversion_p (oprnd1, stmt, true, &half_type1, &def_stmt,\n+      if (!type_conversion_p (oprnd1, mult, true, &half_type1, &def_stmt,\n \t\t\t      &promotion)\n \t  || !promotion)\n         return NULL;\n@@ -488,6 +498,7 @@ vect_recog_sad_pattern (vec<gimple *> *stmts, tree *type_in,\n   gimple *last_stmt = (*stmts)[0];\n   tree sad_oprnd0, sad_oprnd1;\n   stmt_vec_info stmt_vinfo = vinfo_for_stmt (last_stmt);\n+  vec_info *vinfo = stmt_vinfo->vinfo;\n   tree half_type;\n   loop_vec_info loop_info = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n   struct loop *loop;\n@@ -567,23 +578,16 @@ vect_recog_sad_pattern (vec<gimple *> *stmts, tree *type_in,\n     return NULL;\n \n   tree abs_type = half_type;\n-  gimple *abs_stmt = SSA_NAME_DEF_STMT (plus_oprnd0);\n-\n-  /* It could not be the sad pattern if the abs_stmt is outside the loop.  */\n-  if (!gimple_bb (abs_stmt) || !flow_bb_inside_loop_p (loop, gimple_bb (abs_stmt)))\n+  stmt_vec_info abs_stmt_vinfo = vect_get_internal_def (vinfo, plus_oprnd0);\n+  if (!abs_stmt_vinfo)\n     return NULL;\n \n   /* FORNOW.  Can continue analyzing the def-use chain when this stmt in a phi\n      inside the loop (in case we are analyzing an outer-loop).  */\n-  if (!is_gimple_assign (abs_stmt))\n-    return NULL;\n-\n-  stmt_vec_info abs_stmt_vinfo = vinfo_for_stmt (abs_stmt);\n-  gcc_assert (abs_stmt_vinfo);\n-  if (STMT_VINFO_DEF_TYPE (abs_stmt_vinfo) != vect_internal_def)\n-    return NULL;\n-  if (gimple_assign_rhs_code (abs_stmt) != ABS_EXPR\n-      && gimple_assign_rhs_code (abs_stmt) != ABSU_EXPR)\n+  gassign *abs_stmt = dyn_cast <gassign *> (abs_stmt_vinfo->stmt);\n+  if (!abs_stmt\n+      || (gimple_assign_rhs_code (abs_stmt) != ABS_EXPR\n+\t  && gimple_assign_rhs_code (abs_stmt) != ABSU_EXPR))\n     return NULL;\n \n   tree abs_oprnd = gimple_assign_rhs1 (abs_stmt);\n@@ -595,23 +599,14 @@ vect_recog_sad_pattern (vec<gimple *> *stmts, tree *type_in,\n   if (TREE_CODE (abs_oprnd) != SSA_NAME)\n     return NULL;\n \n-  gimple *diff_stmt = SSA_NAME_DEF_STMT (abs_oprnd);\n-\n-  /* It could not be the sad pattern if the diff_stmt is outside the loop.  */\n-  if (!gimple_bb (diff_stmt)\n-      || !flow_bb_inside_loop_p (loop, gimple_bb (diff_stmt)))\n+  stmt_vec_info diff_stmt_vinfo = vect_get_internal_def (vinfo, abs_oprnd);\n+  if (!diff_stmt_vinfo)\n     return NULL;\n \n   /* FORNOW.  Can continue analyzing the def-use chain when this stmt in a phi\n      inside the loop (in case we are analyzing an outer-loop).  */\n-  if (!is_gimple_assign (diff_stmt))\n-    return NULL;\n-\n-  stmt_vec_info diff_stmt_vinfo = vinfo_for_stmt (diff_stmt);\n-  gcc_assert (diff_stmt_vinfo);\n-  if (STMT_VINFO_DEF_TYPE (diff_stmt_vinfo) != vect_internal_def)\n-    return NULL;\n-  if (gimple_assign_rhs_code (diff_stmt) != MINUS_EXPR)\n+  gassign *diff_stmt = dyn_cast <gassign *> (diff_stmt_vinfo->stmt);\n+  if (!diff_stmt || gimple_assign_rhs_code (diff_stmt) != MINUS_EXPR)\n     return NULL;\n \n   tree half_type0, half_type1;\n@@ -2076,11 +2071,10 @@ vect_recog_vector_vector_shift_pattern (vec<gimple *> *stmts,\n {\n   gimple *last_stmt = stmts->pop ();\n   tree oprnd0, oprnd1, lhs, var;\n-  gimple *pattern_stmt, *def_stmt;\n+  gimple *pattern_stmt;\n   enum tree_code rhs_code;\n   stmt_vec_info stmt_vinfo = vinfo_for_stmt (last_stmt);\n   vec_info *vinfo = stmt_vinfo->vinfo;\n-  enum vect_def_type dt;\n \n   if (!is_gimple_assign (last_stmt))\n     return NULL;\n@@ -2111,10 +2105,8 @@ vect_recog_vector_vector_shift_pattern (vec<gimple *> *stmts,\n \t != TYPE_PRECISION (TREE_TYPE (oprnd0)))\n     return NULL;\n \n-  if (!vect_is_simple_use (oprnd1, vinfo, &def_stmt, &dt))\n-    return NULL;\n-\n-  if (dt != vect_internal_def)\n+  stmt_vec_info def_vinfo = vect_get_internal_def (vinfo, oprnd1);\n+  if (!def_vinfo)\n     return NULL;\n \n   *type_in = get_vectype_for_scalar_type (TREE_TYPE (oprnd0));\n@@ -2123,8 +2115,10 @@ vect_recog_vector_vector_shift_pattern (vec<gimple *> *stmts,\n     return NULL;\n \n   tree def = NULL_TREE;\n-  stmt_vec_info def_vinfo = vinfo_for_stmt (def_stmt);\n-  if (!STMT_VINFO_IN_PATTERN_P (def_vinfo) && gimple_assign_cast_p (def_stmt))\n+  gassign *def_stmt = dyn_cast <gassign *> (def_vinfo->stmt);\n+  if (!STMT_VINFO_IN_PATTERN_P (def_vinfo)\n+      && def_stmt\n+      && gimple_assign_cast_p (def_stmt))\n     {\n       tree rhs1 = gimple_assign_rhs1 (def_stmt);\n       if (TYPE_MODE (TREE_TYPE (rhs1)) == TYPE_MODE (TREE_TYPE (oprnd0))\n@@ -3180,18 +3174,15 @@ vect_recog_mixed_size_cond_pattern (vec<gimple *> *stmts, tree *type_in,\n static bool\n check_bool_pattern (tree var, vec_info *vinfo, hash_set<gimple *> &stmts)\n {\n-  gimple *def_stmt;\n-  enum vect_def_type dt;\n   tree rhs1;\n   enum tree_code rhs_code;\n \n-  if (!vect_is_simple_use (var, vinfo, &def_stmt, &dt))\n-    return false;\n-\n-  if (dt != vect_internal_def)\n+  stmt_vec_info def_stmt_info = vect_get_internal_def (vinfo, var);\n+  if (!def_stmt_info)\n     return false;\n \n-  if (!is_gimple_assign (def_stmt))\n+  gassign *def_stmt = dyn_cast <gassign *> (def_stmt_info->stmt);\n+  if (!def_stmt)\n     return false;\n \n   if (stmts.contains (def_stmt))\n@@ -3512,25 +3503,19 @@ static tree\n search_type_for_mask_1 (tree var, vec_info *vinfo,\n \t\t\thash_map<gimple *, tree> &cache)\n {\n-  gimple *def_stmt;\n-  enum vect_def_type dt;\n   tree rhs1;\n   enum tree_code rhs_code;\n   tree res = NULL_TREE, res2;\n \n-  if (TREE_CODE (var) != SSA_NAME)\n-    return NULL_TREE;\n-\n   if (!VECT_SCALAR_BOOLEAN_TYPE_P (TREE_TYPE (var)))\n     return NULL_TREE;\n \n-  if (!vect_is_simple_use (var, vinfo, &def_stmt, &dt))\n-    return NULL_TREE;\n-\n-  if (dt != vect_internal_def)\n+  stmt_vec_info def_stmt_info = vect_get_internal_def (vinfo, var);\n+  if (!def_stmt_info)\n     return NULL_TREE;\n \n-  if (!is_gimple_assign (def_stmt))\n+  gassign *def_stmt = dyn_cast <gassign *> (def_stmt_info->stmt);\n+  if (!def_stmt)\n     return NULL_TREE;\n \n   tree *c = cache.get (def_stmt);"}]}