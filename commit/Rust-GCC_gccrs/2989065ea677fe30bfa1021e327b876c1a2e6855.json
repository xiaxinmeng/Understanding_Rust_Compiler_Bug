{"sha": "2989065ea677fe30bfa1021e327b876c1a2e6855", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjk4OTA2NWVhNjc3ZmUzMGJmYTEwMjFlMzI3Yjg3NmMxYTJlNjg1NQ==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2005-11-15T13:59:11Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-11-15T13:59:11Z"}, "message": "g-debpoo.adb (Set_Valid): Use Integer_Address instead of Storage_Offset to avoid wrap around causing...\n\n2005-11-14  Robert Dewar  <dewar@adacore.com>\n\n\t* g-debpoo.adb (Set_Valid): Use Integer_Address instead of\n\tStorage_Offset to avoid wrap around causing invalid results.\n\nFrom-SVN: r106981", "tree": {"sha": "82030ee3d1dcc597878bda4e8261e537d9fad763", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/82030ee3d1dcc597878bda4e8261e537d9fad763"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2989065ea677fe30bfa1021e327b876c1a2e6855", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2989065ea677fe30bfa1021e327b876c1a2e6855", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2989065ea677fe30bfa1021e327b876c1a2e6855", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2989065ea677fe30bfa1021e327b876c1a2e6855/comments", "author": null, "committer": null, "parents": [{"sha": "2edf9900de20eb260b9e7c80fe3d0355a7cf7fa1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2edf9900de20eb260b9e7c80fe3d0355a7cf7fa1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2edf9900de20eb260b9e7c80fe3d0355a7cf7fa1"}], "stats": {"total": 152, "additions": 87, "deletions": 65}, "files": [{"sha": "1854623da34f25100fa52fa6b62ec6e66f50c10c", "filename": "gcc/ada/g-debpoo.adb", "status": "modified", "additions": 87, "deletions": 65, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2989065ea677fe30bfa1021e327b876c1a2e6855/gcc%2Fada%2Fg-debpoo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2989065ea677fe30bfa1021e327b876c1a2e6855/gcc%2Fada%2Fg-debpoo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-debpoo.adb?ref=2989065ea677fe30bfa1021e327b876c1a2e6855", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -47,7 +47,7 @@ with Ada.Unchecked_Conversion;\n \n package body GNAT.Debug_Pools is\n \n-   Default_Alignment : constant Storage_Offset := Standard'Maximum_Alignment;\n+   Default_Alignment : constant := Standard'Maximum_Alignment;\n    --  Alignment used for the memory chunks returned by Allocate. Using this\n    --  value garantees that this alignment will be compatible with all types\n    --  and at the same time makes it easy to find the location of the extra\n@@ -63,14 +63,15 @@ package body GNAT.Debug_Pools is\n    --  Maximum number of levels that will be ignored in backtraces. This is so\n    --  that we still have enough significant levels in the tracebacks returned\n    --  to the user.\n+   --\n    --  The value 10 is chosen as being greater than the maximum callgraph\n    --  in this package. Its actual value is not really relevant, as long as it\n    --  is high enough to make sure we still have enough frames to return to\n    --  the user after we have hidden the frames internal to this package.\n \n-   -----------------------\n-   -- Tracebacks_Htable --\n-   -----------------------\n+   ---------------------------\n+   -- Back Trace Hash Table --\n+   ---------------------------\n \n    --  This package needs to store one set of tracebacks for each allocation\n    --  point (when was it allocated or deallocated). This would use too much\n@@ -103,19 +104,28 @@ package body GNAT.Debug_Pools is\n       Next      : Traceback_Htable_Elem_Ptr;\n    end record;\n \n+   --  Subprograms used for the Backtrace_Htable instantiation\n+\n    procedure Set_Next\n      (E    : Traceback_Htable_Elem_Ptr;\n       Next : Traceback_Htable_Elem_Ptr);\n+   pragma Inline (Set_Next);\n+\n    function Next\n-     (E    : Traceback_Htable_Elem_Ptr)\n-      return Traceback_Htable_Elem_Ptr;\n+     (E : Traceback_Htable_Elem_Ptr) return Traceback_Htable_Elem_Ptr;\n+   pragma Inline (Next);\n+\n    function Get_Key\n-     (E    : Traceback_Htable_Elem_Ptr)\n-      return Tracebacks_Array_Access;\n+     (E : Traceback_Htable_Elem_Ptr) return Tracebacks_Array_Access;\n+   pragma Inline (Get_Key);\n+\n    function Hash (T : Tracebacks_Array_Access) return Header;\n+   pragma Inline (Hash);\n+\n    function Equal (K1, K2 : Tracebacks_Array_Access) return Boolean;\n-   pragma Inline (Set_Next, Next, Get_Key, Hash);\n-   --  Subprograms required for instantiation of the htable. See GNAT.HTable.\n+   --  Why is this not inlined???\n+\n+   --  The hash table for back traces\n \n    package Backtrace_Htable is new GNAT.HTable.Static_HTable\n      (Header_Num => Header,\n@@ -136,24 +146,26 @@ package body GNAT.Debug_Pools is\n    type Allocation_Header;\n    type Allocation_Header_Access is access Allocation_Header;\n \n-   --  The following record stores extra information that needs to be\n-   --  memorized for each block allocated with the special debug pool.\n-\n    type Traceback_Ptr_Or_Address is new System.Address;\n    --  A type that acts as a C union, and is either a System.Address or a\n    --  Traceback_Htable_Elem_Ptr.\n \n+   --  The following record stores extra information that needs to be\n+   --  memorized for each block allocated with the special debug pool.\n+\n    type Allocation_Header is record\n       Allocation_Address : System.Address;\n-      --  Address of the block returned by malloc, possibly unaligned.\n+      --  Address of the block returned by malloc, possibly unaligned\n \n-      Block_Size    : Storage_Offset;\n+      Block_Size : Storage_Offset;\n       --  Needed only for advanced freeing algorithms (traverse all allocated\n       --  blocks for potential references). This value is negated when the\n       --  chunk of memory has been logically freed by the application. This\n       --  chunk has not been physically released yet.\n \n-      Alloc_Traceback   : Traceback_Htable_Elem_Ptr;\n+      Alloc_Traceback : Traceback_Htable_Elem_Ptr;\n+      --  ??? comment required\n+\n       Dealloc_Traceback : Traceback_Ptr_Or_Address;\n       --  Pointer to the traceback for the allocation (if the memory chunk is\n       --  still valid), or to the first deallocation otherwise. Make sure this\n@@ -177,37 +189,39 @@ package body GNAT.Debug_Pools is\n \n    function To_Address is new Ada.Unchecked_Conversion\n      (Traceback_Ptr_Or_Address, System.Address);\n+\n    function To_Address is new Ada.Unchecked_Conversion\n      (System.Address, Traceback_Ptr_Or_Address);\n+\n    function To_Traceback is new Ada.Unchecked_Conversion\n      (Traceback_Ptr_Or_Address, Traceback_Htable_Elem_Ptr);\n+\n    function To_Traceback is new Ada.Unchecked_Conversion\n      (Traceback_Htable_Elem_Ptr, Traceback_Ptr_Or_Address);\n \n-   Header_Offset : constant Storage_Count\n-     := Default_Alignment *\n-     ((Allocation_Header'Size / System.Storage_Unit + Default_Alignment - 1)\n-      / Default_Alignment);\n-   --  Offset of user data after allocation header.\n+   Header_Offset : constant Storage_Count :=\n+                     Default_Alignment *\n+                       ((Allocation_Header'Size / System.Storage_Unit\n+                          + Default_Alignment - 1) / Default_Alignment);\n+   --  Offset of user data after allocation header\n \n    Minimum_Allocation : constant Storage_Count :=\n-     Default_Alignment - 1\n-     + Header_Offset;\n+                          Default_Alignment - 1 + Header_Offset;\n    --  Minimal allocation: size of allocation_header rounded up to next\n    --  multiple of default alignment + worst-case padding.\n \n    -----------------------\n    -- Allocations table --\n    -----------------------\n \n-   --  This table is indexed on addresses modulo Default_Alignment, and\n-   --  for each index it indicates whether that memory block is valid.\n-   --  Its behavior is similar to GNAT.Table, except that we need to pack\n-   --  the table to save space, so we cannot reuse GNAT.Table as is.\n+   --  This table is indexed on addresses modulo Default_Alignment, and for\n+   --  each index it indicates whether that memory block is valid. Its behavior\n+   --  is similar to GNAT.Table, except that we need to pack the table to save\n+   --  space, so we cannot reuse GNAT.Table as is.\n \n-   --  This table is the reason why all alignments have to be forced to a\n-   --  common value (Default_Alignment), so that this table can be\n-   --  kept to a reasonnable size.\n+   --  This table is the reason why all alignments have to be forced to common\n+   --  value (Default_Alignment), so that this table can be kept to a\n+   --  reasonnable size.\n \n    type Byte is mod 2 ** System.Storage_Unit;\n \n@@ -242,18 +256,17 @@ package body GNAT.Debug_Pools is\n    --  These two variables represents a mapping of the currently allocated\n    --  memory. Every time the pool works on an address, we first check that the\n    --  index Address / Default_Alignment is True. If not, this means that this\n-   --  address is not under control of the debug pool, and thus this is\n-   --  probably an invalid memory access (it could also be a general access\n-   --  type).\n+   --  address is not under control of the debug pool and thus this is probably\n+   --  an invalid memory access (it could also be a general access type).\n    --\n    --  Note that in fact we never allocate the full size of Big_Table, only a\n    --  slice big enough to manage the currently allocated memory.\n \n-   Edata  : System.Address := System.Null_Address;\n+   Edata : System.Address := System.Null_Address;\n    --  Address in memory that matches the index 0 in Valid_Blocks. It is named\n    --  after the symbol _edata, which, on most systems, indicate the lowest\n-   --  possible address returned by malloc. Unfortunately, this symbol\n-   --  doesn't exist on windows, so we cannot use it instead of this variable.\n+   --  possible address returned by malloc. Unfortunately, this symbol doesn't\n+   --  exist on windows, so we cannot use it instead of this variable.\n \n    -----------------------\n    -- Local subprograms --\n@@ -264,16 +277,15 @@ package body GNAT.Debug_Pools is\n       Kind                : Traceback_Kind;\n       Size                : Storage_Count;\n       Ignored_Frame_Start : System.Address;\n-      Ignored_Frame_End   : System.Address)\n-      return                Traceback_Htable_Elem_Ptr;\n+      Ignored_Frame_End   : System.Address) return Traceback_Htable_Elem_Ptr;\n    --  Return an element matching the current traceback (omitting the frames\n    --  that are in the current package). If this traceback already existed in\n    --  the htable, a pointer to this is returned to spare memory. Null is\n    --  returned if the pool is set not to store tracebacks. If the traceback\n    --  already existed in the table, the count is incremented so that\n-   --  Dump_Tracebacks returns useful results.\n-   --  All addresses up to, and including, an address between\n-   --  Ignored_Frame_Start .. Ignored_Frame_End are ignored.\n+   --  Dump_Tracebacks returns useful results. All addresses up to, and\n+   --  including, an address between Ignored_Frame_Start .. Ignored_Frame_End\n+   --  are ignored.\n \n    procedure Put_Line\n      (Depth               : Natural;\n@@ -364,9 +376,7 @@ package body GNAT.Debug_Pools is\n    ----------\n \n    function Next\n-     (E    : Traceback_Htable_Elem_Ptr)\n-      return Traceback_Htable_Elem_Ptr\n-   is\n+     (E : Traceback_Htable_Elem_Ptr) return Traceback_Htable_Elem_Ptr is\n    begin\n       return E.Next;\n    end Next;\n@@ -386,8 +396,7 @@ package body GNAT.Debug_Pools is\n    -------------\n \n    function Get_Key\n-     (E    : Traceback_Htable_Elem_Ptr)\n-      return Tracebacks_Array_Access\n+     (E : Traceback_Htable_Elem_Ptr) return Tracebacks_Array_Access\n    is\n    begin\n       return E.Traceback;\n@@ -399,10 +408,12 @@ package body GNAT.Debug_Pools is\n \n    function Hash (T : Tracebacks_Array_Access) return Header is\n       Result : Integer_Address := 0;\n+\n    begin\n       for X in T'Range loop\n          Result := Result + To_Integer (PC_For (T (X)));\n       end loop;\n+\n       return Header (1 + Result mod Integer_Address (Header'Last));\n    end Hash;\n \n@@ -496,8 +507,7 @@ package body GNAT.Debug_Pools is\n       Kind                : Traceback_Kind;\n       Size                : Storage_Count;\n       Ignored_Frame_Start : System.Address;\n-      Ignored_Frame_End   : System.Address)\n-      return                Traceback_Htable_Elem_Ptr\n+      Ignored_Frame_End   : System.Address) return Traceback_Htable_Elem_Ptr\n    is\n    begin\n       if Pool.Stack_Trace_Depth = 0 then\n@@ -515,7 +525,7 @@ package body GNAT.Debug_Pools is\n          Skip_Levels (Pool.Stack_Trace_Depth, Trace, Start, Len,\n                       Ignored_Frame_Start, Ignored_Frame_End);\n \n-         --  Check if the traceback is already in the table.\n+         --  Check if the traceback is already in the table\n \n          Elem :=\n            Backtrace_Htable.Get (Trace (Start .. Len)'Unrestricted_Access);\n@@ -547,9 +557,7 @@ package body GNAT.Debug_Pools is\n    function Is_Valid (Storage : System.Address) return Boolean is\n       Offset : constant Storage_Offset :=\n                  (Storage - Edata) / Default_Alignment;\n-\n       Bit : constant Byte := 2 ** Natural (Offset mod System.Storage_Unit);\n-\n    begin\n       return (Storage mod Default_Alignment) = 0\n         and then Offset >= 0\n@@ -621,13 +629,27 @@ package body GNAT.Debug_Pools is\n          Valid_Blocks_Size := Valid_Blocks_Size + Bytes;\n \n          --  Take into the account the new start address\n+\n          Edata := Storage - Edata_Align + (Edata - Storage) mod Edata_Align;\n       end if;\n \n       --  Second case : the new address is outside of the current scope of\n-      --  Valid_Blocks, so we have to grow the table as appropriate\n+      --  Valid_Blocks, so we have to grow the table as appropriate.\n \n-      Offset := (Storage - Edata) / Default_Alignment;\n+      --  Note: it might seem more natural for the following statement to\n+      --  be written:\n+\n+      --      Offset := (Storage - Edata) / Default_Alignment;\n+\n+      --  but that won't work since Storage_Offset is signed, and it is\n+      --  possible to subtract a small address from a large address and\n+      --  get a negative value. This may seem strange, but it is quite\n+      --  specifically allowed in the RM, and is what most implementations\n+      --  including GNAT actually do. Hence the conversion to Integer_Address\n+      --  which is a full range modular type, not subject to this glitch.\n+\n+      Offset := Storage_Offset ((To_Integer (Storage) - To_Integer (Edata)) /\n+                                              Default_Alignment);\n \n       if Offset >= Valid_Blocks_Size * System.Storage_Unit then\n          Bytes := Valid_Blocks_Size;\n@@ -717,10 +739,12 @@ package body GNAT.Debug_Pools is\n             P := new Local_Storage_Array;\n       end;\n \n-      Storage_Address := System.Null_Address + Default_Alignment\n-        * (((P.all'Address + Default_Alignment - 1) - System.Null_Address)\n-           / Default_Alignment)\n+      Storage_Address :=\n+        System.Null_Address + Default_Alignment\n+          * (((P.all'Address + Default_Alignment - 1) - System.Null_Address)\n+             / Default_Alignment)\n         + Header_Offset;\n+\n       pragma Assert ((Storage_Address - System.Null_Address)\n                      mod Default_Alignment = 0);\n       pragma Assert (Storage_Address + Size_In_Storage_Elements\n@@ -940,7 +964,7 @@ package body GNAT.Debug_Pools is\n                System.Memory.Free (Header.Allocation_Address);\n                Set_Valid (Tmp, False);\n \n-               --  Remove this block from the list.\n+               --  Remove this block from the list\n \n                if Previous = System.Null_Address then\n                   Pool.First_Free_Block := Next;\n@@ -1038,7 +1062,6 @@ package body GNAT.Debug_Pools is\n       procedure Reset_Marks is\n          Current : System.Address := Pool.First_Free_Block;\n          Header  : Allocation_Header_Access;\n-\n       begin\n          while Current /= System.Null_Address loop\n             Header := Header_Of (Current);\n@@ -1126,7 +1149,7 @@ package body GNAT.Debug_Pools is\n          end if;\n \n       else\n-         --  Remove this block from the list of used blocks.\n+         --  Remove this block from the list of used blocks\n \n          Previous :=\n            To_Address (Header_Of (Storage_Address).Dealloc_Traceback);\n@@ -1459,7 +1482,6 @@ package body GNAT.Debug_Pools is\n \n    function Storage_Size (Pool : Debug_Pool) return Storage_Count is\n       pragma Unreferenced (Pool);\n-\n    begin\n       return Storage_Count'Last;\n    end Storage_Size;\n@@ -1535,7 +1557,6 @@ package body GNAT.Debug_Pools is\n       procedure Internal is new Print_Info\n         (Put_Line => GNAT.IO.Put_Line,\n          Put      => GNAT.IO.Put);\n-\n    begin\n       Internal (Pool, Cumulate, Display_Slots, Display_Leaks);\n    end Print_Info_Stdout;\n@@ -1594,9 +1615,10 @@ package body GNAT.Debug_Pools is\n          Tracebk := Header.Alloc_Traceback.Traceback;\n          Num_Calls := Tracebk'Length;\n \n-         --  Code taken from memtrack.adb in GNAT's sources\n-         --  Logs allocation call\n-         --  format is:\n+         --  (Code taken from memtrack.adb in GNAT's sources)\n+\n+         --  Logs allocation call using the format:\n+\n          --   'A' <mem addr> <size chunk> <len backtrace> <addr1> ... <addrn>\n \n          fputc (Character'Pos ('A'), File);"}]}