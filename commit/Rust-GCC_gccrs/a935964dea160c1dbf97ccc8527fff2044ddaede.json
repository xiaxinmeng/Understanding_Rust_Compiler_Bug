{"sha": "a935964dea160c1dbf97ccc8527fff2044ddaede", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTkzNTk2NGRlYTE2MGMxZGJmOTdjY2M4NTI3ZmZmMjA0NGRkYWVkZQ==", "commit": {"author": {"name": "Segher Boessenkool", "email": "segher@kernel.crashing.org", "date": "2014-12-10T18:37:58Z"}, "committer": {"name": "Segher Boessenkool", "email": "segher@gcc.gnu.org", "date": "2014-12-10T18:37:58Z"}, "message": "re PR target/64180 (PowerPC carry bit improvements)\n\n\tPR target/64180\n\t* config/rs6000/predicates.md (unsigned_comparison_operator): New.\n\t(signed_comparison_operator): New.\n\t* config/rs6000/rs6000-protos.h (rs6000_emit_eqne): Declare.\n\t* config/rs6000/rs6000.c (rs6000_emit_eqne): New function.\n\t(rs6000_emit_sCOND): Remove ISEL test (move it to the expander).\n\t* config/rs6000/rs6000.md (add<mode>3 for SDI): Expand DImode\n\tadd to addc,adde directly, if !TARGET_POWERPC64.\n\t(sub<mode>3 for SDI): Expand DImode sub to subfc,subfe directly,\n\tif !TARGET_POWERPC64.\n\t(neg<mode>2): Delete expander.\n\t(*neg<mode>2): Rename to \"neg<mode>2\".\n\t(addti3, subti3): Delete.\n\t(addti3, subti3): New expanders.\n\t(*adddi3_noppc64, *subdi3_noppc64, *negdi2_noppc64): Delete.\n\t(cstore<mode>4_unsigned): New expander.\n\t(cstore<mode>4): Allow GPR as output (not just SI).  Rewrite.\n\t(cstore<mode>4 for FP): Remove superfluous quotes.\n\t(*eq<mode>, *eq<mode>_compare, *plus_eqsi and splitter,\n\t*compare_plus_eqsi and splitter, *plus_eqsi_compare and splitter,\n\t*neg_eq0<mode>, *neg_eq<mode>, *ne0_<mode>, plus_ne0_<mode>,\n\tcompare_plus_ne0_<mode> and splitter, *compare_plus_ne0_<mode>_1 and\n\tsplitter, *plus_ne0_<mode>_compare and splitter, *leu<mode>,\n\t*leu<mode>_compare and splitter, *plus_leu<mode>, *neg_leu<mode>,\n\t*and_neg_leu<mode>, *ltu<mode>, *ltu<mode>_compare, *plus_ltu<mode>,\n\t*plus_ltu<mode>_1, *plus_ltu<mode>compare, *neg_ltu<mode>, *geu<mode>,\n\t*geu<mode>_compare and splitter, *plus_geu<mode>, *neg_geu<mode>,\n\t*and_neg_geu<mode>, *plus_gt0<mode>, *gtu<mode>, *gtu<mode>_compare,\n\t*plus_gtu<mode>, *plus_gtu<mode>_1, *plus_gtu<mode>_compare,\n\t*neg_gtu<mode>, 12 anonymous insns, and 12 anonymous splitters):\n\tDelete.\n\t(eq<mode>3, ne<mode>3): New.\n\t(*neg_eq_<mode>, *neg_ne_<mode>): New.\n\t(*plus_eq_<mode>, *plus_ne_<mode>): New.\n\t(*minus_eq_<mode>, *minus_ne_<mode>): New.\n\nFrom-SVN: r218595", "tree": {"sha": "89528fa3913c260563739e6d62f8db4300aa8f34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/89528fa3913c260563739e6d62f8db4300aa8f34"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a935964dea160c1dbf97ccc8527fff2044ddaede", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a935964dea160c1dbf97ccc8527fff2044ddaede", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a935964dea160c1dbf97ccc8527fff2044ddaede", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a935964dea160c1dbf97ccc8527fff2044ddaede/comments", "author": {"login": "segher", "id": 417629, "node_id": "MDQ6VXNlcjQxNzYyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/417629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/segher", "html_url": "https://github.com/segher", "followers_url": "https://api.github.com/users/segher/followers", "following_url": "https://api.github.com/users/segher/following{/other_user}", "gists_url": "https://api.github.com/users/segher/gists{/gist_id}", "starred_url": "https://api.github.com/users/segher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/segher/subscriptions", "organizations_url": "https://api.github.com/users/segher/orgs", "repos_url": "https://api.github.com/users/segher/repos", "events_url": "https://api.github.com/users/segher/events{/privacy}", "received_events_url": "https://api.github.com/users/segher/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "969ce0b0a60ac986c6b4f31cbc7c262b7be9f80b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/969ce0b0a60ac986c6b4f31cbc7c262b7be9f80b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/969ce0b0a60ac986c6b4f31cbc7c262b7be9f80b"}], "stats": {"total": 1633, "additions": 438, "deletions": 1195}, "files": [{"sha": "ccca30945e90fac72d91d42482df37633db41b4b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a935964dea160c1dbf97ccc8527fff2044ddaede/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a935964dea160c1dbf97ccc8527fff2044ddaede/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a935964dea160c1dbf97ccc8527fff2044ddaede", "patch": "@@ -1,3 +1,41 @@\n+2014-12-10  Segher Boessenkool  <segher@kernel.crashing.org>\n+\n+\tPR target/64180\n+\t* config/rs6000/predicates.md (unsigned_comparison_operator): New.\n+\t(signed_comparison_operator): New.\n+\t* config/rs6000/rs6000-protos.h (rs6000_emit_eqne): Declare.\n+\t* config/rs6000/rs6000.c (rs6000_emit_eqne): New function.\n+\t(rs6000_emit_sCOND): Remove ISEL test (move it to the expander).\n+\t* config/rs6000/rs6000.md (add<mode>3 for SDI): Expand DImode\n+\tadd to addc,adde directly, if !TARGET_POWERPC64.\n+\t(sub<mode>3 for SDI): Expand DImode sub to subfc,subfe directly,\n+\tif !TARGET_POWERPC64.\n+\t(neg<mode>2): Delete expander.\n+\t(*neg<mode>2): Rename to \"neg<mode>2\".\n+\t(addti3, subti3): Delete.\n+\t(addti3, subti3): New expanders.\n+\t(*adddi3_noppc64, *subdi3_noppc64, *negdi2_noppc64): Delete.\n+\t(cstore<mode>4_unsigned): New expander.\n+\t(cstore<mode>4): Allow GPR as output (not just SI).  Rewrite.\n+\t(cstore<mode>4 for FP): Remove superfluous quotes.\n+\t(*eq<mode>, *eq<mode>_compare, *plus_eqsi and splitter,\n+\t*compare_plus_eqsi and splitter, *plus_eqsi_compare and splitter,\n+\t*neg_eq0<mode>, *neg_eq<mode>, *ne0_<mode>, plus_ne0_<mode>,\n+\tcompare_plus_ne0_<mode> and splitter, *compare_plus_ne0_<mode>_1 and\n+\tsplitter, *plus_ne0_<mode>_compare and splitter, *leu<mode>,\n+\t*leu<mode>_compare and splitter, *plus_leu<mode>, *neg_leu<mode>,\n+\t*and_neg_leu<mode>, *ltu<mode>, *ltu<mode>_compare, *plus_ltu<mode>,\n+\t*plus_ltu<mode>_1, *plus_ltu<mode>compare, *neg_ltu<mode>, *geu<mode>,\n+\t*geu<mode>_compare and splitter, *plus_geu<mode>, *neg_geu<mode>,\n+\t*and_neg_geu<mode>, *plus_gt0<mode>, *gtu<mode>, *gtu<mode>_compare,\n+\t*plus_gtu<mode>, *plus_gtu<mode>_1, *plus_gtu<mode>_compare,\n+\t*neg_gtu<mode>, 12 anonymous insns, and 12 anonymous splitters):\n+\tDelete.\n+\t(eq<mode>3, ne<mode>3): New.\n+\t(*neg_eq_<mode>, *neg_ne_<mode>): New.\n+\t(*plus_eq_<mode>, *plus_ne_<mode>): New.\n+\t(*minus_eq_<mode>, *minus_ne_<mode>): New.\n+\n 2014-12-10  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \tPR target/64180"}, {"sha": "8b68f9ce4649258b916502a83086eba61d0f367c", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a935964dea160c1dbf97ccc8527fff2044ddaede/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a935964dea160c1dbf97ccc8527fff2044ddaede/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=a935964dea160c1dbf97ccc8527fff2044ddaede", "patch": "@@ -1240,6 +1240,14 @@\n \t\t\t\t   (match_code (\"unlt,unle,ungt,unge\"))))\n \t\t(match_operand 0 \"comparison_operator\")))\n \n+;; Return 1 if OP is an unsigned comparison operator.\n+(define_predicate \"unsigned_comparison_operator\"\n+  (match_code \"ltu,gtu,leu,geu\"))\n+\n+;; Return 1 if OP is a signed comparison operator.\n+(define_predicate \"signed_comparison_operator\"\n+  (match_code \"lt,gt,le,ge\"))\n+\n ;; Return 1 if OP is a comparison operation that is valid for an SCC insn --\n ;; it must be a positive comparison.\n (define_predicate \"scc_comparison_operator\""}, {"sha": "eb64598352b95b8fcf7752d9f95b96b38b13fd24", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a935964dea160c1dbf97ccc8527fff2044ddaede/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a935964dea160c1dbf97ccc8527fff2044ddaede/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=a935964dea160c1dbf97ccc8527fff2044ddaede", "patch": "@@ -109,6 +109,7 @@ extern void print_operand (FILE *, rtx, int);\n extern void print_operand_address (FILE *, rtx);\n extern enum rtx_code rs6000_reverse_condition (machine_mode,\n \t\t\t\t\t       enum rtx_code);\n+extern rtx rs6000_emit_eqne (machine_mode, rtx, rtx, rtx);\n extern void rs6000_emit_sISEL (machine_mode, rtx[]);\n extern void rs6000_emit_sCOND (machine_mode, rtx[]);\n extern void rs6000_emit_cbranch (machine_mode, rtx[]);"}, {"sha": "fc81b79c23b39d0f40448102695822f332219beb", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a935964dea160c1dbf97ccc8527fff2044ddaede/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a935964dea160c1dbf97ccc8527fff2044ddaede/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=a935964dea160c1dbf97ccc8527fff2044ddaede", "patch": "@@ -19422,6 +19422,27 @@ rs6000_emit_sISEL (machine_mode mode ATTRIBUTE_UNUSED, rtx operands[])\n   rs6000_emit_int_cmove (operands[0], operands[1], const1_rtx, const0_rtx);\n }\n \n+/* Emit RTL that sets a register to zero if OP1 and OP2 are equal.  SCRATCH\n+   can be used as that dest register.  Return the dest register.  */\n+\n+rtx\n+rs6000_emit_eqne (machine_mode mode, rtx op1, rtx op2, rtx scratch)\n+{\n+  if (op2 == const0_rtx)\n+    return op1;\n+\n+  if (GET_CODE (scratch) == SCRATCH)\n+    scratch = gen_reg_rtx (mode);\n+\n+  if (logical_operand (op2, mode))\n+    emit_insn (gen_rtx_SET (VOIDmode, scratch, gen_rtx_XOR (mode, op1, op2)));\n+  else\n+    emit_insn (gen_rtx_SET (VOIDmode, scratch,\n+\t\t\t    gen_rtx_PLUS (mode, op1, negate_rtx (mode, op2))));\n+\n+  return scratch;\n+}\n+\n void\n rs6000_emit_sCOND (machine_mode mode, rtx operands[])\n {\n@@ -19430,12 +19451,6 @@ rs6000_emit_sCOND (machine_mode mode, rtx operands[])\n   enum rtx_code cond_code;\n   rtx result = operands[0];\n \n-  if (TARGET_ISEL && (mode == SImode || mode == DImode))\n-    {\n-      rs6000_emit_sISEL (mode, operands);\n-      return;\n-    }\n-\n   condition_rtx = rs6000_generate_compare (operands[1], mode);\n   cond_code = GET_CODE (condition_rtx);\n "}, {"sha": "233f7e67d5fa10c3af261e12ebdd4cf1e9c67a08", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 370, "deletions": 1189, "changes": 1559, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a935964dea160c1dbf97ccc8527fff2044ddaede/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a935964dea160c1dbf97ccc8527fff2044ddaede/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=a935964dea160c1dbf97ccc8527fff2044ddaede", "patch": "@@ -1463,13 +1463,26 @@\n \t\t  (match_operand:SDI 2 \"reg_or_add_cint_operand\" \"\")))]\n   \"\"\n {\n-  if (<MODE>mode == DImode && ! TARGET_POWERPC64)\n+  if (<MODE>mode == DImode && !TARGET_POWERPC64)\n     {\n-      if (non_short_cint_operand (operands[2], DImode))\n-\tFAIL;\n+      rtx lo0 = gen_lowpart (SImode, operands[0]);\n+      rtx lo1 = gen_lowpart (SImode, operands[1]);\n+      rtx lo2 = gen_lowpart (SImode, operands[2]);\n+      rtx hi0 = gen_highpart (SImode, operands[0]);\n+      rtx hi1 = gen_highpart (SImode, operands[1]);\n+      rtx hi2 = gen_highpart_mode (SImode, DImode, operands[2]);\n+\n+      if (!reg_or_short_operand (lo2, SImode))\n+\tlo2 = force_reg (SImode, lo2);\n+      if (!adde_operand (hi2, SImode))\n+\thi2 = force_reg (SImode, hi2);\n+\n+      emit_insn (gen_addsi3_carry (lo0, lo1, lo2));\n+      emit_insn (gen_addsi3_carry_in (hi0, hi1, hi2));\n+      DONE;\n     }\n-  else if (GET_CODE (operands[2]) == CONST_INT\n-\t   && ! add_operand (operands[2], <MODE>mode))\n+\n+  if (CONST_INT_P (operands[2]) && !add_operand (operands[2], <MODE>mode))\n     {\n       rtx tmp = ((!can_create_pseudo_p ()\n \t\t  || rtx_equal_p (operands[0], operands[1]))\n@@ -1809,8 +1822,26 @@\n \t\t   (match_operand:SDI 2 \"gpc_reg_operand\" \"\")))]\n   \"\"\n {\n-  if (short_cint_operand (operands[1], <MODE>mode)\n-      && !(<MODE>mode == DImode && !TARGET_POWERPC64))\n+  if (<MODE>mode == DImode && !TARGET_POWERPC64)\n+    {\n+      rtx lo0 = gen_lowpart (SImode, operands[0]);\n+      rtx lo1 = gen_lowpart (SImode, operands[1]);\n+      rtx lo2 = gen_lowpart (SImode, operands[2]);\n+      rtx hi0 = gen_highpart (SImode, operands[0]);\n+      rtx hi1 = gen_highpart_mode (SImode, DImode, operands[1]);\n+      rtx hi2 = gen_highpart (SImode, operands[2]);\n+\n+      if (!reg_or_short_operand (lo1, SImode))\n+\tlo1 = force_reg (SImode, lo1);\n+      if (!adde_operand (hi1, SImode))\n+\thi1 = force_reg (SImode, hi1);\n+\n+      emit_insn (gen_subfsi3_carry (lo0, lo2, lo1));\n+      emit_insn (gen_subfsi3_carry_in (hi0, hi2, hi1));\n+      DONE;\n+    }\n+\n+  if (short_cint_operand (operands[1], <MODE>mode))\n     {\n       emit_insn (gen_subf<mode>3_imm (operands[0], operands[2], operands[1]));\n       DONE;\n@@ -1972,13 +2003,7 @@\n   [(set_attr \"type\" \"add\")])\n \n \n-(define_expand \"neg<mode>2\"\n-  [(set (match_operand:SDI 0 \"gpc_reg_operand\" \"\")\n-\t(neg:SDI (match_operand:SDI 1 \"gpc_reg_operand\" \"\")))]\n-  \"\"\n-  \"\")\n-\n-(define_insn \"*neg<mode>2\"\n+(define_insn \"neg<mode>2\"\n   [(set (match_operand:GPR 0 \"gpc_reg_operand\" \"=r\")\n \t(neg:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"r\")))]\n   \"\"\n@@ -6487,99 +6512,51 @@\n ;; (for example, having an input in 7,8 and an output in 6,7).  We\n ;; also allow for the output being the same as one of the inputs.\n \n-(define_insn \"addti3\"\n-  [(set (match_operand:TI 0 \"gpc_reg_operand\" \"=&r,&r,r,r\")\n-\t(plus:TI (match_operand:TI 1 \"gpc_reg_operand\" \"%r,r,0,0\")\n-\t\t (match_operand:TI 2 \"reg_or_short_operand\" \"r,I,r,I\")))]\n-  \"TARGET_64BIT\"\n-{\n-  if (WORDS_BIG_ENDIAN)\n-    return (GET_CODE (operands[2])) != CONST_INT\n-\t    ? \\\"addc %L0,%L1,%L2\\;adde %0,%1,%2\\\"\n-\t    : \\\"addic %L0,%L1,%2\\;add%G2e %0,%1\\\";\n-  else\n-    return (GET_CODE (operands[2])) != CONST_INT\n-\t    ? \\\"addc %0,%1,%2\\;adde %L0,%L1,%L2\\\"\n-\t    : \\\"addic %0,%1,%2\\;add%G2e %L0,%L1\\\";\n-}\n-  [(set_attr \"type\" \"two\")\n-   (set_attr \"length\" \"8\")])\n-\n-(define_insn \"subti3\"\n-  [(set (match_operand:TI 0 \"gpc_reg_operand\" \"=&r,&r,r,r,r\")\n-\t(minus:TI (match_operand:TI 1 \"reg_or_short_operand\" \"r,I,0,r,I\")\n-\t\t  (match_operand:TI 2 \"gpc_reg_operand\" \"r,r,r,0,0\")))]\n+(define_expand \"addti3\"\n+  [(set (match_operand:TI 0 \"gpc_reg_operand\" \"\")\n+\t(plus:TI (match_operand:TI 1 \"gpc_reg_operand\" \"\")\n+\t\t (match_operand:TI 2 \"reg_or_short_operand\" \"\")))]\n   \"TARGET_64BIT\"\n {\n-  if (WORDS_BIG_ENDIAN)\n-    return (GET_CODE (operands[1]) != CONST_INT)\n-\t    ? \\\"subfc %L0,%L2,%L1\\;subfe %0,%2,%1\\\"\n-\t    : \\\"subfic %L0,%L2,%1\\;subf%G1e %0,%2\\\";\n-  else\n-    return (GET_CODE (operands[1]) != CONST_INT)\n-\t    ? \\\"subfc %0,%2,%1\\;subfe %L0,%L2,%L1\\\"\n-\t    : \\\"subfic %0,%2,%1\\;subf%G1e %L0,%L2\\\";\n-}\n-  [(set_attr \"type\" \"two\")\n-   (set_attr \"length\" \"8\")])\n+  rtx lo0 = gen_lowpart (DImode, operands[0]);\n+  rtx lo1 = gen_lowpart (DImode, operands[1]);\n+  rtx lo2 = gen_lowpart (DImode, operands[2]);\n+  rtx hi0 = gen_highpart (DImode, operands[0]);\n+  rtx hi1 = gen_highpart (DImode, operands[1]);\n+  rtx hi2 = gen_highpart_mode (DImode, TImode, operands[2]);\n \n+  if (!reg_or_short_operand (lo2, DImode))\n+    lo2 = force_reg (DImode, lo2);\n+  if (!adde_operand (hi2, DImode))\n+    hi2 = force_reg (DImode, hi2);\n \n-;; Define the DImode operations that can be done in a small number\n-;; of instructions.  The & constraints are to prevent the register\n-;; allocator from allocating registers that overlap with the inputs\n-;; (for example, having an input in 7,8 and an output in 6,7).  We\n-;; also allow for the output being the same as one of the inputs.\n+  emit_insn (gen_adddi3_carry (lo0, lo1, lo2));\n+  emit_insn (gen_adddi3_carry_in (hi0, hi1, hi2));\n+  DONE;\n+})\n \n-(define_insn \"*adddi3_noppc64\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=&r,&r,r,r\")\n-\t(plus:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r,r,0,0\")\n-\t\t (match_operand:DI 2 \"reg_or_short_operand\" \"r,I,r,I\")))]\n-  \"! TARGET_POWERPC64\"\n-  \"*\n+(define_expand \"subti3\"\n+  [(set (match_operand:TI 0 \"gpc_reg_operand\" \"\")\n+\t(minus:TI (match_operand:TI 1 \"reg_or_short_operand\" \"\")\n+\t\t  (match_operand:TI 2 \"gpc_reg_operand\" \"\")))]\n+  \"TARGET_64BIT\"\n {\n-  if (WORDS_BIG_ENDIAN)\n-    return (GET_CODE (operands[2])) != CONST_INT\n-\t    ? \\\"addc %L0,%L1,%L2\\;adde %0,%1,%2\\\"\n-\t    : \\\"addic %L0,%L1,%2\\;add%G2e %0,%1\\\";\n-  else\n-    return (GET_CODE (operands[2])) != CONST_INT\n-\t    ? \\\"addc %0,%1,%2\\;adde %L0,%L1,%L2\\\"\n-\t    : \\\"addic %0,%1,%2\\;add%G2e %L0,%L1\\\";\n-}\"\n-  [(set_attr \"type\" \"two\")\n-   (set_attr \"length\" \"8\")])\n+  rtx lo0 = gen_lowpart (DImode, operands[0]);\n+  rtx lo1 = gen_lowpart (DImode, operands[1]);\n+  rtx lo2 = gen_lowpart (DImode, operands[2]);\n+  rtx hi0 = gen_highpart (DImode, operands[0]);\n+  rtx hi1 = gen_highpart_mode (DImode, TImode, operands[1]);\n+  rtx hi2 = gen_highpart (DImode, operands[2]);\n \n-(define_insn \"*subdi3_noppc64\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=&r,&r,r,r,r\")\n-\t(minus:DI (match_operand:DI 1 \"reg_or_short_operand\" \"r,I,0,r,I\")\n-\t\t  (match_operand:DI 2 \"gpc_reg_operand\" \"r,r,r,0,0\")))]\n-  \"! TARGET_POWERPC64\"\n-  \"*\n-{\n-  if (WORDS_BIG_ENDIAN)\n-    return (GET_CODE (operands[1]) != CONST_INT)\n-\t    ? \\\"subfc %L0,%L2,%L1\\;subfe %0,%2,%1\\\"\n-\t    : \\\"subfic %L0,%L2,%1\\;subf%G1e %0,%2\\\";\n-  else\n-    return (GET_CODE (operands[1]) != CONST_INT)\n-\t    ? \\\"subfc %0,%2,%1\\;subfe %L0,%L2,%L1\\\"\n-\t    : \\\"subfic %0,%2,%1\\;subf%G1e %L0,%L2\\\";\n-}\"\n-  [(set_attr \"type\" \"two\")\n-   (set_attr \"length\" \"8\")])\n+  if (!reg_or_short_operand (lo1, DImode))\n+    lo1 = force_reg (DImode, lo1);\n+  if (!adde_operand (hi1, DImode))\n+    hi1 = force_reg (DImode, hi1);\n \n-(define_insn \"*negdi2_noppc64\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=&r,r\")\n-\t(neg:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r,0\")))]\n-  \"! TARGET_POWERPC64\"\n-  \"*\n-{\n-  return (WORDS_BIG_ENDIAN)\n-    ? \\\"subfic %L0,%L1,0\\;subfze %0,%1\\\"\n-    : \\\"subfic %0,%1,0\\;subfze %L0,%L1\\\";\n-}\"\n-  [(set_attr \"type\" \"two\")\n-   (set_attr \"length\" \"8\")])\n+  emit_insn (gen_subfdi3_carry (lo0, lo2, lo1));\n+  emit_insn (gen_subfdi3_carry_in (hi0, hi2, hi1));\n+  DONE;\n+})\n \n \n ;; Shift by a variable amount is too complex to be worth open-coding.  We\n@@ -11777,52 +11754,100 @@\n   DONE;\n }\")\n \n+(define_expand \"cstore<mode>4_unsigned\"\n+  [(use (match_operator 1 \"unsigned_comparison_operator\"\n+         [(match_operand:P 2 \"gpc_reg_operand\" \"\")\n+          (match_operand:P 3 \"reg_or_short_operand\" \"\")]))\n+   (clobber (match_operand:P 0 \"register_operand\"))]\n+  \"\"\n+{\n+  enum rtx_code cond_code = GET_CODE (operands[1]);\n+\n+  rtx op0 = operands[0];\n+  rtx op1 = operands[2];\n+  rtx op2 = operands[3];\n+\n+  if (cond_code == GEU || cond_code == LTU)\n+    {\n+      cond_code = swap_condition (cond_code);\n+      op1 = operands[3];\n+      op2 = operands[2];\n+    }\n+\n+  if (!gpc_reg_operand (op1, <MODE>mode))\n+    op1 = force_reg (<MODE>mode, op1);\n+  if (!reg_or_short_operand (op2, <MODE>mode))\n+    op2 = force_reg (<MODE>mode, op2);\n+\n+  rtx tmp = gen_reg_rtx (<MODE>mode);\n+  rtx tmp2 = gen_reg_rtx (<MODE>mode);\n+\n+  emit_insn (gen_subf<mode>3_carry (tmp, op1, op2));\n+  emit_insn (gen_subf<mode>3_carry_in_xx (tmp2));\n+\n+  if (cond_code == LEU)\n+    emit_insn (gen_add<mode>3 (op0, tmp2, const1_rtx));\n+  else\n+    emit_insn (gen_neg<mode>2 (op0, tmp2));\n+\n+  DONE;\n+})\n+\n (define_expand \"cstore<mode>4\"\n   [(use (match_operator 1 \"rs6000_cbranch_operator\"\n          [(match_operand:GPR 2 \"gpc_reg_operand\" \"\")\n           (match_operand:GPR 3 \"reg_or_short_operand\" \"\")]))\n-   (clobber (match_operand:SI 0 \"register_operand\"))]\n+   (clobber (match_operand:GPR 0 \"register_operand\"))]\n   \"\"\n-  \"\n {\n-  /* Take care of the possibility that operands[3] might be negative but\n-     this might be a logical operation.  That insn doesn't exist.  */\n-  if (GET_CODE (operands[3]) == CONST_INT\n-      && INTVAL (operands[3]) < 0)\n+  /* Use ISEL if the user asked for it.  */\n+  if (TARGET_ISEL)\n+    rs6000_emit_sISEL (<MODE>mode, operands);\n+\n+  /* Expanding EQ and NE directly to some machine instructions does not help\n+     but does hurt combine.  So don't.  */\n+  else if (GET_CODE (operands[1]) == EQ)\n+    emit_insn (gen_eq<mode>3 (operands[0], operands[2], operands[3]));\n+  else if (<MODE>mode == Pmode\n+\t   && GET_CODE (operands[1]) == NE)\n+    emit_insn (gen_ne<mode>3 (operands[0], operands[2], operands[3]));\n+  else if (GET_CODE (operands[1]) == NE)\n     {\n-      operands[3] = force_reg (<MODE>mode, operands[3]);\n-      operands[1] = gen_rtx_fmt_ee (GET_CODE (operands[1]),\n-\t\t\t\t    GET_MODE (operands[1]),\n-\t\t\t\t    operands[2], operands[3]);\n+      rtx tmp = gen_reg_rtx (<MODE>mode);\n+      emit_insn (gen_eq<mode>3 (tmp, operands[2], operands[3]));\n+      emit_insn (gen_xor<mode>3 (operands[0], tmp, const1_rtx));\n     }\n \n-  /* For SNE, we would prefer that the xor/abs sequence be used for integers.\n-     For SEQ, likewise, except that comparisons with zero should be done\n-     with an scc insns.  However, due to the order that combine see the\n-     resulting insns, we must, in fact, allow SEQ for integers.  Fail in\n-     the cases we don't want to handle or are best handled by portable\n-     code.  */\n-  if (GET_CODE (operands[1]) == NE)\n+  /* Expanding the unsigned comparisons however helps a lot: all the neg_ltu\n+     etc. combinations magically work out just right.  */\n+  else if (<MODE>mode == Pmode\n+\t   && unsigned_comparison_operator (operands[1], VOIDmode))\n+    emit_insn (gen_cstore<mode>4_unsigned (operands[0], operands[1],\n+\t\t\t\t\t   operands[2], operands[3]));\n+\n+  /* The generic code knows tricks to compute signed comparisons against\n+     zero.  Let it do its thing.  */\n+  else if (operands[3] == const0_rtx\n+\t   && signed_comparison_operator (operands[1], VOIDmode))\n     FAIL;\n-  if ((GET_CODE (operands[1]) == LT || GET_CODE (operands[1]) == LE\n-       || GET_CODE (operands[1]) == GT || GET_CODE (operands[1]) == GE)\n-      && operands[3] == const0_rtx)\n-    FAIL;\n-  rs6000_emit_sCOND (<MODE>mode, operands);\n+\n+  /* Everything else, use the mfcr brute force.  */\n+  else\n+    rs6000_emit_sCOND (<MODE>mode, operands);\n+\n   DONE;\n-}\")\n+})\n \n (define_expand \"cstore<mode>4\"\n   [(use (match_operator 1 \"rs6000_cbranch_operator\"\n          [(match_operand:FP 2 \"gpc_reg_operand\" \"\")\n           (match_operand:FP 3 \"gpc_reg_operand\" \"\")]))\n    (clobber (match_operand:SI 0 \"register_operand\"))]\n   \"\"\n-  \"\n {\n   rs6000_emit_sCOND (<MODE>mode, operands);\n   DONE;\n-}\")\n+})\n \n \n (define_expand \"stack_protect_set\"\n@@ -12294,1109 +12319,265 @@\n   [(set_attr \"type\" \"mfcr\")\n    (set_attr \"length\" \"12\")])\n \n-;; There are some scc insns that can be done directly, without a compare.\n-;; These are faster because they don't involve the communications between\n-;; the FXU and branch units.   In fact, we will be replacing all of the\n-;; integer scc insns here or in the portable methods in emit_store_flag.\n-;;\n-;; Also support (neg (scc ..)) since that construct is used to replace\n-;; branches, (plus (scc ..) ..) since that construct is common and\n-;; takes no more insns than scc, and (and (neg (scc ..)) ..) in the\n-;; cases where it is no more expensive than (neg (scc ..)).\n-\n-;; Have reload force a constant into a register for the simple insns that\n-;; otherwise won't accept constants.  We do this because it is faster than\n-;; the cmp/mfcr sequence we would otherwise generate.\n \n (define_mode_attr scc_eq_op2 [(SI \"rKLI\")\n \t\t\t      (DI \"rKJI\")])\n \n-(define_insn_and_split \"*eq<mode>\"\n+(define_insn_and_split \"eq<mode>3\"\n   [(set (match_operand:GPR 0 \"gpc_reg_operand\" \"=r\")\n \t(eq:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"r\")\n-\t\t(match_operand:GPR 2 \"scc_eq_operand\" \"<scc_eq_op2>\")))]\n+\t\t(match_operand:GPR 2 \"scc_eq_operand\" \"<scc_eq_op2>\")))\n+   (clobber (match_scratch:GPR 3 \"=r\"))\n+   (clobber (match_scratch:GPR 4 \"=r\"))]\n   \"\"\n   \"#\"\n   \"\"\n-  [(set (match_dup 0)\n+  [(set (match_dup 4)\n \t(clz:GPR (match_dup 3)))\n    (set (match_dup 0)\n-\t(lshiftrt:GPR (match_dup 0) (match_dup 4)))]\n-  {\n-    if (GET_CODE (operands[2]) != CONST_INT || INTVAL (operands[2]) != 0)\n-      {\n-\t/* Use output operand as intermediate.  */\n-\toperands[3] = operands[0];\n-\n-\tif (logical_operand (operands[2], <MODE>mode))\n-\t  emit_insn (gen_rtx_SET (VOIDmode, operands[3],\n-\t\t\t\t  gen_rtx_XOR (<MODE>mode,\n-\t\t\t\t\t       operands[1], operands[2])));\n-\telse\n-\t  emit_insn (gen_rtx_SET (VOIDmode, operands[3],\n-\t\t\t\t  gen_rtx_PLUS (<MODE>mode, operands[1],\n-\t\t\t\t\t\tnegate_rtx (<MODE>mode,\n-\t\t\t\t\t\t\t    operands[2]))));\n-      }\n-    else\n-      operands[3] = operands[1];\n-\n-    operands[4] = GEN_INT (exact_log2 (GET_MODE_BITSIZE (<MODE>mode)));\n-  })\n-\n-(define_insn_and_split \"*eq<mode>_compare\"\n-  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=y\")\n-\t(compare:CC\n-\t (eq:P (match_operand:P 1 \"gpc_reg_operand\" \"=r\")\n-\t       (match_operand:P 2 \"scc_eq_operand\" \"<scc_eq_op2>\"))\n-\t (const_int 0)))\n-   (set (match_operand:P 0 \"gpc_reg_operand\" \"=r\")\n-\t(eq:P (match_dup 1) (match_dup 2)))]\n-  \"optimize_size\"\n-  \"#\"\n-  \"optimize_size\"\n-  [(set (match_dup 0)\n-\t(clz:P (match_dup 4)))\n-   (parallel [(set (match_dup 3)\n-\t\t   (compare:CC (lshiftrt:P (match_dup 0) (match_dup 5))\n-\t\t\t       (const_int 0)))\n-\t      (set (match_dup 0)\n-\t\t   (lshiftrt:P (match_dup 0) (match_dup 5)))])]\n-  {\n-    if (GET_CODE (operands[2]) != CONST_INT || INTVAL (operands[2]) != 0)\n-      {\n-\t/* Use output operand as intermediate.  */\n-\toperands[4] = operands[0];\n-\n-\tif (logical_operand (operands[2], <MODE>mode))\n-\t  emit_insn (gen_rtx_SET (VOIDmode, operands[4],\n-\t\t\t\t  gen_rtx_XOR (<MODE>mode,\n-\t\t\t\t\t       operands[1], operands[2])));\n-\telse\n-\t  emit_insn (gen_rtx_SET (VOIDmode, operands[4],\n-\t\t\t\t  gen_rtx_PLUS (<MODE>mode, operands[1],\n-\t\t\t\t\t\tnegate_rtx (<MODE>mode,\n-\t\t\t\t\t\t\t    operands[2]))));\n-      }\n-    else\n-      operands[4] = operands[1];\n-\n-    operands[5] = GEN_INT (exact_log2 (GET_MODE_BITSIZE (<MODE>mode)));\n-  })\n-\n-;; We have insns of the form shown by the first define_insn below.  If\n-;; there is something inside the comparison operation, we must split it.\n-(define_split\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t(plus:SI (match_operator 1 \"comparison_operator\"\n-\t\t\t\t [(match_operand:SI 2 \"\" \"\")\n-\t\t\t\t  (match_operand:SI 3\n-\t\t\t\t\t\t    \"reg_or_cint_operand\" \"\")])\n-\t\t (match_operand:SI 4 \"gpc_reg_operand\" \"\")))\n-   (clobber (match_operand:SI 5 \"register_operand\" \"\"))]\n-  \"! gpc_reg_operand (operands[2], SImode)\"\n-  [(set (match_dup 5) (match_dup 2))\n-   (set (match_dup 0) (plus:SI (match_op_dup 1 [(match_dup 5) (match_dup 3)])\n-\t\t\t       (match_dup 4)))])\n-\n-(define_insn \"*plus_eqsi\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=&r,&r,&r,&r,&r\")\n-\t(plus:SI (eq:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r,r,r,r\")\n-\t\t\t(match_operand:SI 2 \"scc_eq_operand\" \"r,O,K,L,I\"))\n-\t\t (match_operand:SI 3 \"gpc_reg_operand\" \"r,r,r,r,r\")))]\n-  \"TARGET_32BIT\"\n-  \"@\n-   xor %0,%1,%2\\;subfic %0,%0,0\\;addze %0,%3\n-   subfic %0,%1,0\\;addze %0,%3\n-   xori %0,%1,%b2\\;subfic %0,%0,0\\;addze %0,%3\n-   xoris %0,%1,%u2\\;subfic %0,%0,0\\;addze %0,%3\n-   subfic %0,%1,%2\\;subfic %0,%0,0\\;addze %0,%3\"\n-  [(set_attr \"type\" \"three,two,three,three,three\")\n-   (set_attr \"length\" \"12,8,12,12,12\")])\n+\t(lshiftrt:GPR (match_dup 4)\n+\t\t      (match_dup 5)))]\n+{\n+  operands[3] = rs6000_emit_eqne (<MODE>mode,\n+\t\t\t\t  operands[1], operands[2], operands[3]);\n \n-(define_insn \"*compare_plus_eqsi\"\n-  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x,x,x,x,x,?y,?y,?y,?y,?y\")\n-\t(compare:CC\n-\t (plus:SI\n-\t  (eq:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r,r,r,r,r,r,r,r,r\")\n-\t\t (match_operand:SI 2 \"scc_eq_operand\" \"r,O,K,L,I,r,O,K,L,I\"))\n-\t  (match_operand:SI 3 \"gpc_reg_operand\" \"r,r,r,r,r,r,r,r,r,r\"))\n-\t (const_int 0)))\n-   (clobber (match_scratch:SI 4 \"=&r,&r,&r,&r,&r,&r,&r,&r,&r,&r\"))]\n-  \"TARGET_32BIT && optimize_size\"\n-  \"@\n-   xor %4,%1,%2\\;subfic %4,%4,0\\;addze. %4,%3\n-   subfic %4,%1,0\\;addze. %4,%3\n-   xori %4,%1,%b2\\;subfic %4,%4,0\\;addze. %4,%3\n-   xoris %4,%1,%u2\\;subfic %4,%4,0\\;addze. %4,%3\n-   subfic %4,%1,%2\\;subfic %4,%4,0\\;addze. %4,%3\n-   #\n-   #\n-   #\n-   #\n-   #\"\n-  [(set_attr \"type\" \"compare\")\n-   (set_attr \"length\" \"12,8,12,12,12,16,12,16,16,16\")])\n+  if (GET_CODE (operands[4]) == SCRATCH)\n+    operands[4] = gen_reg_rtx (<MODE>mode);\n \n-(define_split\n-  [(set (match_operand:CC 0 \"cc_reg_not_cr0_operand\" \"\")\n-\t(compare:CC\n-\t (plus:SI\n-\t  (eq:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n-\t\t (match_operand:SI 2 \"scc_eq_operand\" \"\"))\n-\t  (match_operand:SI 3 \"gpc_reg_operand\" \"\"))\n-\t (const_int 0)))\n-   (clobber (match_scratch:SI 4 \"\"))]\n-  \"TARGET_32BIT && optimize_size && reload_completed\"\n-  [(set (match_dup 4)\n-\t(plus:SI (eq:SI (match_dup 1)\n-\t\t (match_dup 2))\n-\t  (match_dup 3)))\n-   (set (match_dup 0)\n-\t(compare:CC (match_dup 4)\n-\t\t    (const_int 0)))]\n-  \"\")\n+  operands[5] = GEN_INT (exact_log2 (GET_MODE_BITSIZE (<MODE>mode)));\n+}\n+  [(set (attr \"length\")\n+\t(if_then_else (match_test \"operands[2] == const0_rtx\")\n+\t\t      (const_string \"8\")\n+\t\t      (const_string \"12\")))])\n \n-(define_insn \"*plus_eqsi_compare\"\n-  [(set (match_operand:CC 4 \"cc_reg_operand\" \"=x,x,x,x,x,?y,?y,?y,?y,?y\")\n-\t(compare:CC\n-\t (plus:SI\n-\t  (eq:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r,r,r,r,r,r,r,r,r\")\n-\t\t (match_operand:SI 2 \"scc_eq_operand\" \"r,O,K,L,I,r,O,K,L,I\"))\n-\t  (match_operand:SI 3 \"gpc_reg_operand\" \"r,r,r,r,r,r,r,r,r,r\"))\n-\t (const_int 0)))\n-   (set (match_operand:SI 0 \"gpc_reg_operand\" \"=&r,&r,&r,&r,&r,&r,&r,&r,&r,&r\")\n-\t(plus:SI (eq:SI (match_dup 1) (match_dup 2)) (match_dup 3)))]\n-  \"TARGET_32BIT && optimize_size\"\n-  \"@\n-   xor %0,%1,%2\\;subfic %0,%0,0\\;addze. %0,%3\n-   subfic %0,%1,0\\;addze. %0,%3\n-   xori %0,%1,%b2\\;subfic %0,%0,0\\;addze. %0,%3\n-   xoris %0,%1,%u2\\;subfic %0,%0,0\\;addze. %0,%3\n-   subfic %0,%1,%2\\;subfic %0,%0,0\\;addze. %0,%3\n-   #\n-   #\n-   #\n-   #\n-   #\"\n-  [(set_attr \"type\" \"compare\")\n-   (set_attr \"length\" \"12,8,12,12,12,16,12,16,16,16\")])\n+(define_insn_and_split \"ne<mode>3\"\n+  [(set (match_operand:P 0 \"gpc_reg_operand\" \"=r\")\n+\t(ne:P (match_operand:P 1 \"gpc_reg_operand\" \"r\")\n+\t      (match_operand:P 2 \"scc_eq_operand\" \"<scc_eq_op2>\")))\n+   (clobber (match_scratch:P 3 \"=r\"))\n+   (clobber (match_scratch:P 4 \"=r\"))\n+   (clobber (reg:P CA_REGNO))]\n+  \"!TARGET_ISEL\"\n+  \"#\"\n+  \"\"\n+  [(parallel [(set (match_dup 4)\n+\t\t   (plus:P (match_dup 3)\n+\t\t\t   (const_int -1)))\n+\t      (set (reg:P CA_REGNO)\n+\t\t   (ne:P (match_dup 3)\n+\t\t\t (const_int 0)))])\n+   (parallel [(set (match_dup 0)\n+\t\t   (plus:P (plus:P (not:P (match_dup 4))\n+\t\t\t\t   (reg:P CA_REGNO))\n+\t\t\t   (match_dup 3)))\n+\t      (clobber (reg:P CA_REGNO))])]\n+{\n+  operands[3] = rs6000_emit_eqne (<MODE>mode,\n+\t\t\t\t  operands[1], operands[2], operands[3]);\n \n-(define_split\n-  [(set (match_operand:CC 4 \"cc_reg_not_cr0_operand\" \"\")\n-\t(compare:CC\n-\t (plus:SI\n-\t  (eq:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n-\t\t (match_operand:SI 2 \"scc_eq_operand\" \"\"))\n-\t  (match_operand:SI 3 \"gpc_reg_operand\" \"\"))\n-\t (const_int 0)))\n-   (set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t(plus:SI (eq:SI (match_dup 1) (match_dup 2)) (match_dup 3)))]\n-  \"TARGET_32BIT && optimize_size && reload_completed\"\n-  [(set (match_dup 0)\n-\t(plus:SI (eq:SI (match_dup 1) (match_dup 2)) (match_dup 3)))\n-   (set (match_dup 4)\n-\t(compare:CC (match_dup 0)\n-\t\t    (const_int 0)))]\n-  \"\")\n+  if (GET_CODE (operands[4]) == SCRATCH)\n+    operands[4] = gen_reg_rtx (<MODE>mode);\n+}\n+  [(set (attr \"length\")\n+\t(if_then_else (match_test \"operands[2] == const0_rtx\")\n+\t\t      (const_string \"8\")\n+\t\t      (const_string \"12\")))])\n \n-(define_insn \"*neg_eq0<mode>\"\n+(define_insn_and_split \"*neg_eq_<mode>\"\n   [(set (match_operand:P 0 \"gpc_reg_operand\" \"=r\")\n \t(neg:P (eq:P (match_operand:P 1 \"gpc_reg_operand\" \"r\")\n-\t\t     (const_int 0))))]\n+\t\t     (match_operand:P 2 \"scc_eq_operand\" \"<scc_eq_op2>\"))))\n+   (clobber (match_scratch:P 3 \"=r\"))\n+   (clobber (match_scratch:P 4 \"=r\"))\n+   (clobber (reg:P CA_REGNO))]\n   \"\"\n-  \"addic %0,%1,-1\\;subfe %0,%0,%0\"\n-  [(set_attr \"type\" \"two\")\n-   (set_attr \"length\" \"8\")])\n+  \"#\"\n+  \"\"\n+  [(parallel [(set (match_dup 4)\n+\t\t   (plus:P (match_dup 3)\n+\t\t\t   (const_int -1)))\n+\t      (set (reg:P CA_REGNO)\n+\t\t   (ne:P (match_dup 3)\n+\t\t\t (const_int 0)))])\n+   (parallel [(set (match_dup 0)\n+\t\t   (plus:P (reg:P CA_REGNO)\n+\t\t\t   (const_int -1)))\n+\t      (clobber (reg:P CA_REGNO))])]\n+{\n+  operands[3] = rs6000_emit_eqne (<MODE>mode,\n+\t\t\t\t  operands[1], operands[2], operands[3]);\n \n-(define_insn_and_split \"*neg_eq<mode>\"\n+  if (GET_CODE (operands[4]) == SCRATCH)\n+    operands[4] = gen_reg_rtx (<MODE>mode);\n+}\n+  [(set (attr \"length\")\n+\t(if_then_else (match_test \"operands[2] == const0_rtx\")\n+\t\t      (const_string \"8\")\n+\t\t      (const_string \"12\")))])\n+\n+(define_insn_and_split \"*neg_ne_<mode>\"\n   [(set (match_operand:P 0 \"gpc_reg_operand\" \"=r\")\n-\t(neg:P (eq:P (match_operand:P 1 \"gpc_reg_operand\" \"%r\")\n-\t\t     (match_operand:P 2 \"scc_eq_operand\" \"<scc_eq_op2>\"))))]\n+\t(neg:P (ne:P (match_operand:P 1 \"gpc_reg_operand\" \"r\")\n+\t\t     (match_operand:P 2 \"scc_eq_operand\" \"<scc_eq_op2>\"))))\n+   (clobber (match_scratch:P 3 \"=r\"))\n+   (clobber (match_scratch:P 4 \"=r\"))\n+   (clobber (reg:P CA_REGNO))]\n   \"\"\n   \"#\"\n   \"\"\n-  [(set (match_dup 0) (neg:P (eq:P (match_dup 3) (const_int 0))))]\n-  {\n-    if (GET_CODE (operands[2]) != CONST_INT || INTVAL (operands[2]) != 0)\n-      {\n-\t/* Use output operand as intermediate.  */\n-\toperands[3] = operands[0];\n-\n-\tif (logical_operand (operands[2], <MODE>mode))\n-\t  emit_insn (gen_rtx_SET (VOIDmode, operands[3],\n-\t\t\t\t  gen_rtx_XOR (<MODE>mode,\n-\t\t\t\t\t       operands[1], operands[2])));\n-\telse\n-\t  emit_insn (gen_rtx_SET (VOIDmode, operands[3],\n-\t\t\t\t  gen_rtx_PLUS (<MODE>mode, operands[1],\n-\t\t\t\t\t\tnegate_rtx (<MODE>mode,\n-\t\t\t\t\t\t\t    operands[2]))));\n-      }\n-    else\n-      operands[3] = operands[1];\n-  })\n+  [(parallel [(set (match_dup 4)\n+\t\t   (neg:P (match_dup 3)))\n+\t      (set (reg:P CA_REGNO)\n+\t\t   (eq:P (match_dup 3)\n+\t\t\t (const_int 0)))])\n+   (parallel [(set (match_dup 0)\n+\t\t   (plus:P (reg:P CA_REGNO)\n+\t\t\t   (const_int -1)))\n+\t      (clobber (reg:P CA_REGNO))])]\n+{\n+  operands[3] = rs6000_emit_eqne (<MODE>mode,\n+\t\t\t\t  operands[1], operands[2], operands[3]);\n+\n+  if (GET_CODE (operands[4]) == SCRATCH)\n+    operands[4] = gen_reg_rtx (<MODE>mode);\n+}\n+  [(set (attr \"length\")\n+\t(if_then_else (match_test \"operands[2] == const0_rtx\")\n+\t\t      (const_string \"8\")\n+\t\t      (const_string \"12\")))])\n \n-(define_insn \"*ne0_<mode>\"\n+(define_insn_and_split \"*plus_eq_<mode>\"\n   [(set (match_operand:P 0 \"gpc_reg_operand\" \"=r\")\n-\t(ne:P (match_operand:P 1 \"gpc_reg_operand\" \"r\")\n-\t      (const_int 0)))\n-   (clobber (match_scratch:P 2 \"=&r\"))]\n-  \"!(TARGET_32BIT && TARGET_ISEL)\"\n-  \"addic %2,%1,-1\\;subfe %0,%2,%1\"\n-  [(set_attr \"type\" \"two\")\n-   (set_attr \"length\" \"8\")])\n+\t(plus:P (eq:P (match_operand:P 1 \"gpc_reg_operand\" \"r\")\n+\t\t      (match_operand:P 2 \"scc_eq_operand\" \"<scc_eq_op2>\"))\n+\t\t(match_operand:P 3 \"gpc_reg_operand\" \"r\")))\n+   (clobber (match_scratch:P 4 \"=r\"))\n+   (clobber (match_scratch:P 5 \"=r\"))\n+   (clobber (reg:P CA_REGNO))]\n+  \"\"\n+  \"#\"\n+  \"\"\n+  [(parallel [(set (match_dup 5)\n+\t\t   (neg:P (match_dup 4)))\n+\t      (set (reg:P CA_REGNO)\n+\t\t   (eq:P (match_dup 4)\n+\t\t\t (const_int 0)))])\n+   (parallel [(set (match_dup 0)\n+\t\t   (plus:P (match_dup 3)\n+\t\t\t   (reg:P CA_REGNO)))\n+\t      (clobber (reg:P CA_REGNO))])]\n+{\n+  operands[4] = rs6000_emit_eqne (<MODE>mode,\n+\t\t\t\t  operands[1], operands[2], operands[4]);\n+\n+  if (GET_CODE (operands[5]) == SCRATCH)\n+    operands[5] = gen_reg_rtx (<MODE>mode);\n+}\n+  [(set (attr \"length\")\n+\t(if_then_else (match_test \"operands[2] == const0_rtx\")\n+\t\t      (const_string \"8\")\n+\t\t      (const_string \"12\")))])\n \n-(define_insn \"*plus_ne0_<mode>\"\n+(define_insn_and_split \"*plus_ne_<mode>\"\n   [(set (match_operand:P 0 \"gpc_reg_operand\" \"=r\")\n \t(plus:P (ne:P (match_operand:P 1 \"gpc_reg_operand\" \"r\")\n-\t\t      (const_int 0))\n-\t\t(match_operand:P 2 \"gpc_reg_operand\" \"r\")))\n-   (clobber (match_scratch:P 3 \"=&r\"))]\n+\t\t      (match_operand:P 2 \"scc_eq_operand\" \"<scc_eq_op2>\"))\n+\t\t(match_operand:P 3 \"gpc_reg_operand\" \"r\")))\n+   (clobber (match_scratch:P 4 \"=r\"))\n+   (clobber (match_scratch:P 5 \"=r\"))\n+   (clobber (reg:P CA_REGNO))]\n   \"\"\n-  \"addic %3,%1,-1\\;addze %0,%2\"\n-  [(set_attr \"type\" \"two\")\n-   (set_attr \"length\" \"8\")])\n-\n-(define_insn \"*compare_plus_ne0_<mode>\"\n-  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x,?y\")\n-\t(compare:CC (plus:P (ne:P (match_operand:P 1 \"gpc_reg_operand\" \"r,r\")\n-\t\t\t\t  (const_int 0))\n-\t\t\t    (match_operand:P 2 \"gpc_reg_operand\" \"r,r\"))\n-\t\t    (const_int 0)))\n-   (clobber (match_scratch:P 3 \"=&r,&r\"))\n-   (clobber (match_scratch:P 4 \"=X,&r\"))]\n+  \"#\"\n   \"\"\n-  \"@\n-   addic %3,%1,-1\\;addze. %3,%2\n-   #\"\n-  [(set_attr \"type\" \"compare\")\n-   (set_attr \"length\" \"8,12\")])\n+  [(parallel [(set (match_dup 5)\n+\t\t   (plus:P (match_dup 4)\n+\t\t\t   (const_int -1)))\n+\t      (set (reg:P CA_REGNO)\n+\t\t   (ne:P (match_dup 4)\n+\t\t\t (const_int 0)))])\n+   (parallel [(set (match_dup 0)\n+\t\t   (plus:P (match_dup 3)\n+\t\t\t   (reg:P CA_REGNO)))\n+\t      (clobber (reg:P CA_REGNO))])]\n+{\n+  operands[4] = rs6000_emit_eqne (<MODE>mode,\n+\t\t\t\t  operands[1], operands[2], operands[4]);\n \n-(define_split\n-  [(set (match_operand:CC 0 \"cc_reg_not_micro_cr0_operand\" \"\")\n-\t(compare:CC (ne:P (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n-\t\t\t  (const_int 0))\n-\t\t    (neg:P (match_operand:P 2 \"gpc_reg_operand\" \"\"))))\n-   (clobber (match_scratch:P 3 \"\"))\n-   (clobber (match_scratch:P 4 \"\"))]\n-  \"reload_completed\"\n-  [(parallel [(set (match_dup 3)\n-\t\t   (plus:P (ne:P (match_dup 1)\n-\t\t\t\t (const_int 0))\n-\t\t\t   (match_dup 2)))\n-              (clobber (match_dup 4))])\n-   (set (match_dup 0)\n-\t(compare:CC (match_dup 3)\n-\t\t    (const_int 0)))]\n-  \"\")\n+  if (GET_CODE (operands[5]) == SCRATCH)\n+    operands[5] = gen_reg_rtx (<MODE>mode);\n+}\n+  [(set (attr \"length\")\n+\t(if_then_else (match_test \"operands[2] == const0_rtx\")\n+\t\t      (const_string \"8\")\n+\t\t      (const_string \"12\")))])\n \n-; For combine.\n-(define_insn \"*compare_plus_ne0_<mode>_1\"\n-  [(set (match_operand:CCEQ 0 \"cc_reg_operand\" \"=x,?y\")\n-\t(compare:CCEQ (ne:P (match_operand:P 1 \"gpc_reg_operand\" \"r,r\")\n-\t\t\t    (const_int 0))\n-\t\t      (neg:P (match_operand:P 2 \"gpc_reg_operand\" \"r,r\"))))\n-   (clobber (match_scratch:P 3 \"=&r,&r\"))\n-   (clobber (match_scratch:P 4 \"=X,&r\"))]\n+(define_insn_and_split \"*minus_eq_<mode>\"\n+  [(set (match_operand:P 0 \"gpc_reg_operand\" \"=r\")\n+\t(minus:P (match_operand:P 3 \"gpc_reg_operand\" \"r\")\n+\t\t (eq:P (match_operand:P 1 \"gpc_reg_operand\" \"r\")\n+\t\t       (match_operand:P 2 \"scc_eq_operand\" \"<scc_eq_op2>\"))))\n+   (clobber (match_scratch:P 4 \"=r\"))\n+   (clobber (match_scratch:P 5 \"=r\"))\n+   (clobber (reg:P CA_REGNO))]\n   \"\"\n-  \"@\n-   addic %3,%1,-1\\;addze. %3,%2\n-   #\"\n-  [(set_attr \"type\" \"compare\")\n-   (set_attr \"length\" \"8,12\")])\n+  \"#\"\n+  \"\"\n+  [(parallel [(set (match_dup 5)\n+\t\t   (plus:P (match_dup 4)\n+\t\t\t   (const_int -1)))\n+\t      (set (reg:P CA_REGNO)\n+\t\t   (ne:P (match_dup 4)\n+\t\t\t (const_int 0)))])\n+   (parallel [(set (match_dup 0)\n+\t\t   (plus:P (plus:P (match_dup 3)\n+\t\t\t\t   (reg:P CA_REGNO))\n+\t\t\t   (const_int -1)))\n+\t      (clobber (reg:P CA_REGNO))])]\n+{\n+  operands[4] = rs6000_emit_eqne (<MODE>mode,\n+\t\t\t\t  operands[1], operands[2], operands[4]);\n \n-(define_split\n-  [(set (match_operand:CCEQ 0 \"cc_reg_not_micro_cr0_operand\" \"\")\n-\t(compare:CCEQ (ne:P (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n-\t\t\t    (const_int 0))\n-\t\t      (neg:P (match_operand:P 2 \"gpc_reg_operand\" \"\"))))\n-   (clobber (match_scratch:P 3 \"\"))\n-   (clobber (match_scratch:P 4 \"\"))]\n-  \"reload_completed\"\n-  [(parallel [(set (match_dup 3)\n-\t\t   (plus:P (ne:P (match_dup 1)\n-\t\t\t\t (const_int 0))\n-\t\t\t   (match_dup 2)))\n-              (clobber (match_dup 4))])\n-   (set (match_dup 0)\n-\t(compare:CC (match_dup 3)\n-\t\t    (const_int 0)))]\n-  \"\")\n+  if (GET_CODE (operands[5]) == SCRATCH)\n+    operands[5] = gen_reg_rtx (<MODE>mode);\n+}\n+  [(set (attr \"length\")\n+\t(if_then_else (match_test \"operands[2] == const0_rtx\")\n+\t\t      (const_string \"8\")\n+\t\t      (const_string \"12\")))])\n \n-(define_insn \"*plus_ne0_<mode>_compare\"\n-  [(set (match_operand:CC 4 \"cc_reg_operand\" \"=x,?y\")\n-\t(compare:CC\n-\t (plus:P (ne:P (match_operand:P 1 \"gpc_reg_operand\" \"r,r\")\n-\t\t       (const_int 0))\n-\t\t (match_operand:P 2 \"gpc_reg_operand\" \"r,r\"))\n-\t (const_int 0)))\n-   (set (match_operand:P 0 \"gpc_reg_operand\" \"=r,r\")\n-\t(plus:P (ne:P (match_dup 1)\n-\t\t      (const_int 0))\n-\t\t(match_dup 2)))\n-   (clobber (match_scratch:P 3 \"=&r,&r\"))]\n+(define_insn_and_split \"*minus_ne_<mode>\"\n+  [(set (match_operand:P 0 \"gpc_reg_operand\" \"=r\")\n+\t(minus:P (match_operand:P 3 \"gpc_reg_operand\" \"r\")\n+\t\t (ne:P (match_operand:P 1 \"gpc_reg_operand\" \"r\")\n+\t\t       (match_operand:P 2 \"scc_eq_operand\" \"<scc_eq_op2>\"))))\n+   (clobber (match_scratch:P 4 \"=r\"))\n+   (clobber (match_scratch:P 5 \"=r\"))\n+   (clobber (reg:P CA_REGNO))]\n   \"\"\n-  \"@\n-   addic %3,%1,-1\\;addze. %0,%2\n-   #\"\n-  [(set_attr \"type\" \"compare\")\n-   (set_attr \"length\" \"8,12\")])\n-\n-(define_split\n-  [(set (match_operand:CC 4 \"cc_reg_not_micro_cr0_operand\" \"\")\n-\t(compare:CC\n-\t (plus:P (ne:P (match_operand:P 1 \"gpc_reg_operand\" \"\")\n-\t\t       (const_int 0))\n-\t\t (match_operand:P 2 \"gpc_reg_operand\" \"\"))\n-\t (const_int 0)))\n-   (set (match_operand:P 0 \"gpc_reg_operand\" \"\")\n-\t(plus:P (ne:P (match_dup 1)\n-\t\t      (const_int 0))\n-\t\t(match_dup 2)))\n-   (clobber (match_scratch:P 3 \"\"))]\n-  \"reload_completed\"\n-  [(parallel [(set (match_dup 0)\n-\t\t   (plus:P (ne:P (match_dup 1)\n-\t\t\t\t (const_int 0))\n-\t\t\t   (match_dup 2)))\n-\t      (clobber (match_dup 3))])\n-   (set (match_dup 4)\n-\t(compare:CC (match_dup 0)\n-\t\t    (const_int 0)))]\n-  \"\")\n-\n-(define_insn \"*leu<mode>\"\n-  [(set (match_operand:P 0 \"gpc_reg_operand\" \"=r\")\n-\t(leu:P (match_operand:P 1 \"gpc_reg_operand\" \"r\")\n-\t       (match_operand:P 2 \"reg_or_short_operand\" \"rI\")))]\n-  \"\"\n-  \"subf%I2c %0,%1,%2\\;li %0,0\\;adde %0,%0,%0\"\n-  [(set_attr \"type\" \"three\")\n-   (set_attr \"length\" \"12\")])\n-\n-(define_insn \"*leu<mode>_compare\"\n-  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,?y\")\n-\t(compare:CC\n-\t (leu:P (match_operand:P 1 \"gpc_reg_operand\" \"r,r\")\n-\t\t(match_operand:P 2 \"reg_or_short_operand\" \"rI,rI\"))\n-\t (const_int 0)))\n-   (set (match_operand:P 0 \"gpc_reg_operand\" \"=r,r\")\n-\t(leu:P (match_dup 1) (match_dup 2)))]\n-  \"\"\n-  \"@\n-   subf%I2c %0,%1,%2\\;li %0,0\\;adde. %0,%0,%0\n-   #\"\n-  [(set_attr \"type\" \"compare\")\n-   (set_attr \"length\" \"12,16\")])\n-\n-(define_split\n-  [(set (match_operand:CC 3 \"cc_reg_not_cr0_operand\" \"\")\n-\t(compare:CC\n-\t (leu:P (match_operand:P 1 \"gpc_reg_operand\" \"\")\n-\t\t(match_operand:P 2 \"reg_or_short_operand\" \"\"))\n-\t (const_int 0)))\n-   (set (match_operand:P 0 \"gpc_reg_operand\" \"\")\n-\t(leu:P (match_dup 1) (match_dup 2)))]\n-  \"reload_completed\"\n-  [(set (match_dup 0)\n-\t(leu:P (match_dup 1) (match_dup 2)))\n-   (set (match_dup 3)\n-\t(compare:CC (match_dup 0)\n-\t\t    (const_int 0)))]\n-  \"\")\n-\n-(define_insn \"*plus_leu<mode>\"\n-  [(set (match_operand:P 0 \"gpc_reg_operand\" \"=&r\")\n-\t(plus:P (leu:P (match_operand:P 1 \"gpc_reg_operand\" \"r\")\n-\t\t       (match_operand:P 2 \"reg_or_short_operand\" \"rI\"))\n-\t\t(match_operand:P 3 \"gpc_reg_operand\" \"r\")))]\n-  \"\"\n-  \"subf%I2c %0,%1,%2\\;addze %0,%3\"\n-  [(set_attr \"type\" \"two\")\n-   (set_attr \"length\" \"8\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x,?y\")\n-\t(compare:CC\n-\t (plus:SI (leu:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r,r\")\n-\t\t\t  (match_operand:SI 2 \"reg_or_short_operand\" \"rI,rI\"))\n-\t\t  (match_operand:SI 3 \"gpc_reg_operand\" \"r,r\"))\n-\t (const_int 0)))\n-   (clobber (match_scratch:SI 4 \"=&r,&r\"))]\n-  \"TARGET_32BIT\"\n-  \"@\n-   subf%I2c %4,%1,%2\\;addze. %4,%3\n-   #\"\n-  [(set_attr \"type\" \"compare\")\n-   (set_attr \"length\" \"8,12\")])\n-\n-(define_split\n-  [(set (match_operand:CC 0 \"cc_reg_not_cr0_operand\" \"\")\n-\t(compare:CC\n-\t (plus:SI (leu:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n-\t\t\t  (match_operand:SI 2 \"reg_or_short_operand\" \"\"))\n-\t\t  (match_operand:SI 3 \"gpc_reg_operand\" \"\"))\n-\t (const_int 0)))\n-   (clobber (match_scratch:SI 4 \"\"))]\n-  \"TARGET_32BIT && reload_completed\"\n-  [(set (match_dup 4)\n-\t(plus:SI (leu:SI (match_dup 1) (match_dup 2))\n-\t\t  (match_dup 3)))\n-   (set (match_dup 0)\n-\t(compare:CC (match_dup 4)\n-\t\t    (const_int 0)))]\n-  \"\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:CC 4 \"cc_reg_operand\" \"=x,?y\")\n-\t(compare:CC\n-\t (plus:SI (leu:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r,r\")\n-\t\t\t  (match_operand:SI 2 \"reg_or_short_operand\" \"rI,rI\"))\n-\t\t  (match_operand:SI 3 \"gpc_reg_operand\" \"r,r\"))\n-\t (const_int 0)))\n-   (set (match_operand:SI 0 \"gpc_reg_operand\" \"=&r,&r\")\n-\t(plus:SI (leu:SI (match_dup 1) (match_dup 2)) (match_dup 3)))]\n-  \"TARGET_32BIT\"\n-  \"@\n-   subf%I2c %0,%1,%2\\;addze. %0,%3\n-   #\"\n-  [(set_attr \"type\" \"compare\")\n-   (set_attr \"length\" \"8,12\")])\n-\n-(define_split\n-  [(set (match_operand:CC 4 \"cc_reg_not_cr0_operand\" \"\")\n-\t(compare:CC\n-\t (plus:SI (leu:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n-\t\t\t  (match_operand:SI 2 \"reg_or_short_operand\" \"\"))\n-\t\t  (match_operand:SI 3 \"gpc_reg_operand\" \"\"))\n-\t (const_int 0)))\n-   (set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t(plus:SI (leu:SI (match_dup 1) (match_dup 2)) (match_dup 3)))]\n-  \"TARGET_32BIT && reload_completed\"\n-  [(set (match_dup 0)\n-\t(plus:SI (leu:SI (match_dup 1) (match_dup 2)) (match_dup 3)))\n-   (set (match_dup 4)\n-\t(compare:CC (match_dup 0)\n-\t\t    (const_int 0)))]\n-  \"\")\n-\n-(define_insn \"*neg_leu<mode>\"\n-  [(set (match_operand:P 0 \"gpc_reg_operand\" \"=r\")\n-\t(neg:P (leu:P (match_operand:P 1 \"gpc_reg_operand\" \"r\")\n-\t\t      (match_operand:P 2 \"reg_or_short_operand\" \"rI\"))))]\n-  \"\"\n-  \"subf%I2c %0,%1,%2\\;subfe %0,%0,%0\\;nand %0,%0,%0\"\n-   [(set_attr \"type\" \"three\")\n-    (set_attr \"length\" \"12\")])\n-\n-(define_insn \"*and_neg_leu<mode>\"\n-  [(set (match_operand:P 0 \"gpc_reg_operand\" \"=&r\")\n-\t(and:P (neg:P\n-\t\t (leu:P (match_operand:P 1 \"gpc_reg_operand\" \"r\")\n-\t\t\t(match_operand:P 2 \"reg_or_short_operand\" \"rI\")))\n-\t\t(match_operand:P 3 \"gpc_reg_operand\" \"r\")))]\n-  \"\"\n-  \"subf%I2c %0,%1,%2\\;subfe %0,%0,%0\\;andc %0,%3,%0\"\n-  [(set_attr \"type\" \"three\")\n-   (set_attr \"length\" \"12\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x,?y\")\n-\t(compare:CC\n-\t (and:SI (neg:SI\n-\t\t  (leu:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r,r\")\n-\t\t\t  (match_operand:SI 2 \"reg_or_short_operand\" \"rI,rI\")))\n-\t\t (match_operand:SI 3 \"gpc_reg_operand\" \"r,r\"))\n-\t (const_int 0)))\n-   (clobber (match_scratch:SI 4 \"=&r,&r\"))]\n-  \"TARGET_32BIT\"\n-  \"@\n-   subf%I2c %4,%1,%2\\;subfe %4,%4,%4\\;andc. %4,%3,%4\n-   #\"\n-  [(set_attr \"type\" \"compare\")\n-   (set_attr \"length\" \"12,16\")])\n-\n-(define_split\n-  [(set (match_operand:CC 0 \"cc_reg_not_cr0_operand\" \"\")\n-\t(compare:CC\n-\t (and:SI (neg:SI\n-\t\t  (leu:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n-\t\t\t  (match_operand:SI 2 \"reg_or_short_operand\" \"\")))\n-\t\t (match_operand:SI 3 \"gpc_reg_operand\" \"\"))\n-\t (const_int 0)))\n-   (clobber (match_scratch:SI 4 \"\"))]\n-  \"TARGET_32BIT && reload_completed\"\n-  [(set (match_dup 4)\n-\t(and:SI (neg:SI (leu:SI (match_dup 1) (match_dup 2)))\n-\t\t(match_dup 3)))\n-   (set (match_dup 0)\n-\t(compare:CC (match_dup 4)\n-\t\t    (const_int 0)))]\n-  \"\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:CC 4 \"cc_reg_operand\" \"=x,?y\")\n-\t(compare:CC\n-\t (and:SI (neg:SI\n-\t\t  (leu:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r,r\")\n-\t\t\t  (match_operand:SI 2 \"reg_or_short_operand\" \"rI,rI\")))\n-\t\t (match_operand:SI 3 \"gpc_reg_operand\" \"r,r\"))\n-\t (const_int 0)))\n-   (set (match_operand:SI 0 \"gpc_reg_operand\" \"=&r,&r\")\n-\t(and:SI (neg:SI (leu:SI (match_dup 1) (match_dup 2))) (match_dup 3)))]\n-  \"TARGET_32BIT\"\n-  \"@\n-   subf%I2c %0,%1,%2\\;subfe %0,%0,%0\\;andc. %0,%3,%0\n-   #\"\n-  [(set_attr \"type\" \"compare\")\n-   (set_attr \"length\" \"12,16\")])\n-\n-(define_split\n-  [(set (match_operand:CC 4 \"cc_reg_not_cr0_operand\" \"\")\n-\t(compare:CC\n-\t (and:SI (neg:SI\n-\t\t  (leu:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n-\t\t\t  (match_operand:SI 2 \"reg_or_short_operand\" \"\")))\n-\t\t (match_operand:SI 3 \"gpc_reg_operand\" \"\"))\n-\t (const_int 0)))\n-   (set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t(and:SI (neg:SI (leu:SI (match_dup 1) (match_dup 2))) (match_dup 3)))]\n-  \"TARGET_32BIT && reload_completed\"\n-  [(set (match_dup 0)\n-\t(and:SI (neg:SI (leu:SI (match_dup 1) (match_dup 2)))\n-\t\t(match_dup 3)))\n-   (set (match_dup 4)\n-\t(compare:CC (match_dup 0)\n-\t\t    (const_int 0)))]\n-  \"\")\n-\n-(define_insn_and_split \"*ltu<mode>\"\n-  [(set (match_operand:P 0 \"gpc_reg_operand\" \"=r,r\")\n-\t(ltu:P (match_operand:P 1 \"gpc_reg_operand\" \"r,r\")\n-\t       (match_operand:P 2 \"reg_or_neg_short_operand\" \"r,P\")))]\n-  \"\"\n-  \"#\"\n-  \"\"\n-  [(set (match_dup 0) (neg:P (ltu:P (match_dup 1) (match_dup 2))))\n-   (set (match_dup 0) (neg:P (match_dup 0)))]\n-  \"\")\n-\n-(define_insn_and_split \"*ltu<mode>_compare\"\n-  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,x,?y,?y\")\n-\t(compare:CC\n-\t (ltu:P (match_operand:P 1 \"gpc_reg_operand\" \"r,r,r,r\")\n-\t\t(match_operand:P 2 \"reg_or_neg_short_operand\" \"r,P,r,P\"))\n-\t (const_int 0)))\n-   (set (match_operand:P 0 \"gpc_reg_operand\" \"=r,r,r,r\")\n-\t(ltu:P (match_dup 1) (match_dup 2)))]\n-  \"\"\n-  \"#\"\n-  \"\"\n-  [(set (match_dup 0) (neg:P (ltu:P (match_dup 1) (match_dup 2))))\n-   (parallel [(set (match_dup 3)\n-\t\t   (compare:CC (neg:P (match_dup 0)) (const_int 0)))\n-\t      (set (match_dup 0) (neg:P (match_dup 0)))])]\n-  \"\")\n-\n-(define_insn_and_split \"*plus_ltu<mode>\"\n-  [(set (match_operand:P 0 \"gpc_reg_operand\" \"=&r,r\")\n-\t(plus:P (ltu:P (match_operand:P 1 \"gpc_reg_operand\" \"r,r\")\n-\t\t       (match_operand:P 2 \"reg_or_neg_short_operand\" \"r,P\"))\n-\t\t(match_operand:P 3 \"gpc_reg_operand\" \"r,r\")))]\n-  \"\"\n-  \"#\"\n-  \"&& !reg_overlap_mentioned_p (operands[0], operands[3])\"\n-  [(set (match_dup 0) (neg:P (ltu:P (match_dup 1) (match_dup 2))))\n-   (set (match_dup 0) (minus:P (match_dup 3) (match_dup 0)))]\n-  \"\")\n-\n-(define_insn_and_split \"*plus_ltu<mode>_1\"\n-  [(set (match_operand:P 0 \"gpc_reg_operand\" \"=&r,r\")\n-\t(plus:P (ltu:P (match_operand:P 1 \"gpc_reg_operand\" \"r,r\")\n-\t\t       (match_operand:P 2 \"reg_or_neg_short_operand\" \"r,P\"))\n-\t\t(match_operand:P 3 \"short_cint_operand\" \"I,I\")))]\n-  \"\"\n-  \"#\"\n-  \"&& !reg_overlap_mentioned_p (operands[0], operands[3])\"\n-  [(set (match_dup 0) (neg:P (ltu:P (match_dup 1) (match_dup 2))))\n-   (parallel [(set (match_dup 0) (minus:P (match_dup 3) (match_dup 0)))\n-\t      (clobber (reg:P CA_REGNO))])]\n-  \"\")\n-\n-(define_insn_and_split \"*plus_ltu<mode>_compare\"\n-  [(set (match_operand:CC 4 \"cc_reg_operand\" \"=x,x,?y,?y\")\n-\t(compare:CC\n-\t (plus:P (ltu:P (match_operand:P 1 \"gpc_reg_operand\" \"r,r,r,r\")\n-\t\t\t(match_operand:P 2 \"reg_or_neg_short_operand\" \"r,P,r,P\"))\n-\t\t (match_operand:P 3 \"gpc_reg_operand\" \"r,r,r,r\"))\n-\t (const_int 0)))\n-   (set (match_operand:P 0 \"gpc_reg_operand\" \"=&r,&r,&r,&r\")\n-\t(plus:P (ltu:P (match_dup 1) (match_dup 2)) (match_dup 3)))]\n-  \"\"\n-  \"#\"\n-  \"&& !reg_overlap_mentioned_p (operands[0], operands[3])\"\n-  [(set (match_dup 0) (neg:P (ltu:P (match_dup 1) (match_dup 2))))\n-   (parallel [(set (match_dup 4)\n-\t\t   (compare:CC (minus:P (match_dup 3) (match_dup 0))\n-\t\t\t       (const_int 0)))\n-\t      (set (match_dup 0) (minus:P (match_dup 3) (match_dup 0)))])]\n-  \"\")\n-\n-(define_insn \"*neg_ltu<mode>\"\n-  [(set (match_operand:P 0 \"gpc_reg_operand\" \"=r,r\")\n-\t(neg:P (ltu:P (match_operand:P 1 \"gpc_reg_operand\" \"r,r\")\n-\t\t      (match_operand:P 2 \"reg_or_neg_short_operand\" \"r,P\"))))]\n-  \"\"\n-  \"@\n-   subfc %0,%2,%1\\;subfe %0,%0,%0\n-   addic %0,%1,%n2\\;subfe %0,%0,%0\"\n-  [(set_attr \"type\" \"two\")\n-   (set_attr \"length\" \"8\")])\n-\n-(define_insn \"*geu<mode>\"\n-  [(set (match_operand:P 0 \"gpc_reg_operand\" \"=r,r\")\n-\t(geu:P (match_operand:P 1 \"gpc_reg_operand\" \"r,r\")\n-\t       (match_operand:P 2 \"reg_or_neg_short_operand\" \"r,P\")))]\n-  \"\"\n-  \"@\n-   subfc %0,%2,%1\\;li %0,0\\;adde %0,%0,%0\n-   addic %0,%1,%n2\\;li %0,0\\;adde %0,%0,%0\"\n-  [(set_attr \"type\" \"three\")\n-   (set_attr \"length\" \"12\")])\n-\n-(define_insn \"*geu<mode>_compare\"\n-  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,x,?y,?y\")\n-\t(compare:CC\n-\t (geu:P (match_operand:P 1 \"gpc_reg_operand\" \"r,r,r,r\")\n-\t\t(match_operand:P 2 \"reg_or_neg_short_operand\" \"r,P,r,P\"))\n-\t (const_int 0)))\n-   (set (match_operand:P 0 \"gpc_reg_operand\" \"=r,r,r,r\")\n-\t(geu:P (match_dup 1) (match_dup 2)))]\n-  \"\"\n-  \"@\n-   subfc %0,%2,%1\\;li %0,0\\;adde. %0,%0,%0\n-   addic %0,%1,%n2\\;li %0,0\\;adde. %0,%0,%0\n-   #\n-   #\"\n-  [(set_attr \"type\" \"compare\")\n-   (set_attr \"length\" \"12,12,16,16\")])\n-\n-(define_split\n-  [(set (match_operand:CC 3 \"cc_reg_not_micro_cr0_operand\" \"\")\n-\t(compare:CC\n-\t (geu:P (match_operand:P 1 \"gpc_reg_operand\" \"\")\n-\t\t(match_operand:P 2 \"reg_or_neg_short_operand\" \"\"))\n-\t (const_int 0)))\n-   (set (match_operand:P 0 \"gpc_reg_operand\" \"\")\n-\t(geu:P (match_dup 1) (match_dup 2)))]\n-  \"reload_completed\"\n-  [(set (match_dup 0)\n-\t(geu:P (match_dup 1) (match_dup 2)))\n-   (set (match_dup 3)\n-\t(compare:CC (match_dup 0)\n-\t\t    (const_int 0)))]\n-  \"\")\n-\n-(define_insn \"*plus_geu<mode>\"\n-  [(set (match_operand:P 0 \"gpc_reg_operand\" \"=&r,&r\")\n-\t(plus:P (geu:P (match_operand:P 1 \"gpc_reg_operand\" \"r,r\")\n-\t\t       (match_operand:P 2 \"reg_or_neg_short_operand\" \"r,P\"))\n-\t\t(match_operand:P 3 \"gpc_reg_operand\" \"r,r\")))]\n-  \"\"\n-  \"@\n-   subfc %0,%2,%1\\;addze %0,%3\n-   addic %0,%1,%n2\\;addze %0,%3\"\n-  [(set_attr \"type\" \"two\")\n-   (set_attr \"length\" \"8\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x,x,?y,?y\")\n-\t(compare:CC\n-\t (plus:SI (geu:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r,r,r,r\")\n-\t\t\t  (match_operand:SI 2 \"reg_or_neg_short_operand\" \"r,P,r,P\"))\n-\t\t  (match_operand:SI 3 \"gpc_reg_operand\" \"r,r,r,r\"))\n-\t (const_int 0)))\n-   (clobber (match_scratch:SI 4 \"=&r,&r,&r,&r\"))]\n-  \"TARGET_32BIT\"\n-  \"@\n-   subfc %4,%2,%1\\;addze. %4,%3\n-   addic %4,%1,%n2\\;addze. %4,%3\n-   #\n-   #\"\n-  [(set_attr \"type\" \"compare\")\n-   (set_attr \"length\" \"8,8,12,12\")])\n-\n-(define_split\n-  [(set (match_operand:CC 0 \"cc_reg_not_cr0_operand\" \"\")\n-\t(compare:CC\n-\t (plus:SI (geu:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n-\t\t\t  (match_operand:SI 2 \"reg_or_neg_short_operand\" \"\"))\n-\t\t  (match_operand:SI 3 \"gpc_reg_operand\" \"\"))\n-\t (const_int 0)))\n-   (clobber (match_scratch:SI 4 \"\"))]\n-  \"TARGET_32BIT && reload_completed\"\n-  [(set (match_dup 4)\n-\t(plus:SI (geu:SI (match_dup 1) (match_dup 2))\n-\t\t  (match_dup 3)))\n-   (set (match_dup 0)\n-\t(compare:CC (match_dup 4)\n-\t\t    (const_int 0)))]\n-  \"\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:CC 4 \"cc_reg_operand\" \"=x,x,?y,?y\")\n-\t(compare:CC\n-\t (plus:SI (geu:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r,r,r,r\")\n-\t\t\t  (match_operand:SI 2 \"reg_or_neg_short_operand\" \"r,P,r,P\"))\n-\t\t  (match_operand:SI 3 \"gpc_reg_operand\" \"r,r,r,r\"))\n-\t (const_int 0)))\n-   (set (match_operand:SI 0 \"gpc_reg_operand\" \"=&r,&r,&r,&r\")\n-\t(plus:SI (geu:SI (match_dup 1) (match_dup 2)) (match_dup 3)))]\n-  \"TARGET_32BIT\"\n-  \"@\n-   subfc %0,%2,%1\\;addze. %0,%3\n-   addic %0,%1,%n2\\;addze. %0,%3\n-   #\n-   #\"\n-  [(set_attr \"type\" \"compare\")\n-   (set_attr \"length\" \"8,8,12,12\")])\n-\n-(define_split\n-  [(set (match_operand:CC 4 \"cc_reg_not_cr0_operand\" \"\")\n-\t(compare:CC\n-\t (plus:SI (geu:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n-\t\t\t  (match_operand:SI 2 \"reg_or_neg_short_operand\" \"\"))\n-\t\t  (match_operand:SI 3 \"gpc_reg_operand\" \"\"))\n-\t (const_int 0)))\n-   (set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t(plus:SI (geu:SI (match_dup 1) (match_dup 2)) (match_dup 3)))]\n-  \"TARGET_32BIT && reload_completed\"\n-  [(set (match_dup 0)\n-\t(plus:SI (geu:SI (match_dup 1) (match_dup 2)) (match_dup 3)))\n-   (set (match_dup 4)\n-\t(compare:CC (match_dup 0)\n-\t\t    (const_int 0)))]\n-  \"\")\n-\n-(define_insn \"*neg_geu<mode>\"\n-  [(set (match_operand:P 0 \"gpc_reg_operand\" \"=r,r\")\n-\t(neg:P (geu:P (match_operand:P 1 \"gpc_reg_operand\" \"r,r\")\n-\t\t      (match_operand:P 2 \"reg_or_short_operand\" \"r,I\"))))]\n-  \"\"\n-  \"@\n-   subfc %0,%2,%1\\;subfe %0,%0,%0\\;nand %0,%0,%0\n-   subfic %0,%1,-1\\;add%I2c %0,%0,%2\\;subfe %0,%0,%0\"\n-  [(set_attr \"type\" \"three\")\n-   (set_attr \"length\" \"12\")])\n-\n-(define_insn \"*and_neg_geu<mode>\"\n-  [(set (match_operand:P 0 \"gpc_reg_operand\" \"=&r,&r\")\n-\t(and:P (neg:P\n-\t\t (geu:P (match_operand:P 1 \"gpc_reg_operand\" \"r,r\")\n-\t\t\t(match_operand:P 2 \"reg_or_neg_short_operand\" \"r,P\")))\n-\t\t(match_operand:P 3 \"gpc_reg_operand\" \"r,r\")))]\n-  \"\"\n-  \"@\n-   subfc %0,%2,%1\\;subfe %0,%0,%0\\;andc %0,%3,%0\n-   addic %0,%1,%n2\\;subfe %0,%0,%0\\;andc %0,%3,%0\"\n-  [(set_attr \"type\" \"three\")\n-   (set_attr \"length\" \"12\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x,x,?y,?y\")\n-\t(compare:CC\n-\t (and:SI (neg:SI\n-\t\t  (geu:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r,r,r,r\")\n-\t\t\t  (match_operand:SI 2 \"reg_or_neg_short_operand\" \"r,P,r,P\")))\n-\t\t (match_operand:SI 3 \"gpc_reg_operand\" \"r,r,r,r\"))\n-\t (const_int 0)))\n-   (clobber (match_scratch:SI 4 \"=&r,&r,&r,&r\"))]\n-  \"TARGET_32BIT\"\n-  \"@\n-   subfc %4,%2,%1\\;subfe %4,%4,%4\\;andc. %4,%3,%4\n-   addic %4,%1,%n2\\;subfe %4,%4,%4\\;andc. %4,%3,%4\n-   #\n-   #\"\n-  [(set_attr \"type\" \"compare\")\n-   (set_attr \"length\" \"12,12,16,16\")])\n-\n-(define_split\n-  [(set (match_operand:CC 0 \"cc_reg_not_cr0_operand\" \"\")\n-\t(compare:CC\n-\t (and:SI (neg:SI\n-\t\t  (geu:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n-\t\t\t  (match_operand:SI 2 \"reg_or_neg_short_operand\" \"\")))\n-\t\t (match_operand:SI 3 \"gpc_reg_operand\" \"\"))\n-\t (const_int 0)))\n-   (clobber (match_scratch:SI 4 \"\"))]\n-  \"TARGET_32BIT && reload_completed\"\n-  [(set (match_dup 4)\n-\t(and:SI (neg:SI (geu:SI (match_dup 1) (match_dup 2)))\n-\t\t(match_dup 3)))\n-   (set (match_dup 0)\n-\t(compare:CC (match_dup 4)\n-\t\t    (const_int 0)))]\n-  \"\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:CC 4 \"cc_reg_operand\" \"=x,x,?y,?y\")\n-\t(compare:CC\n-\t (and:SI (neg:SI\n-\t\t  (geu:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r,r,r,r\")\n-\t\t\t  (match_operand:SI 2 \"reg_or_neg_short_operand\" \"r,P,r,P\")))\n-\t\t (match_operand:SI 3 \"gpc_reg_operand\" \"r,r,r,r\"))\n-\t (const_int 0)))\n-   (set (match_operand:SI 0 \"gpc_reg_operand\" \"=&r,&r,&r,&r\")\n-\t(and:SI (neg:SI (geu:SI (match_dup 1) (match_dup 2))) (match_dup 3)))]\n-  \"TARGET_32BIT\"\n-  \"@\n-   subfc %0,%2,%1\\;subfe %0,%0,%0\\;andc. %0,%3,%0\n-   addic %0,%1,%n2\\;subfe %0,%0,%0\\;andc. %0,%3,%0\n-   #\n-   #\"\n-  [(set_attr \"type\" \"compare\")\n-   (set_attr \"length\" \"12,12,16,16\")])\n-\n-(define_split\n-  [(set (match_operand:CC 4 \"cc_reg_not_cr0_operand\" \"\")\n-\t(compare:CC\n-\t (and:SI (neg:SI\n-\t\t  (geu:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n-\t\t\t  (match_operand:SI 2 \"reg_or_neg_short_operand\" \"\")))\n-\t\t (match_operand:SI 3 \"gpc_reg_operand\" \"\"))\n-\t (const_int 0)))\n-   (set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t(and:SI (neg:SI (geu:SI (match_dup 1) (match_dup 2))) (match_dup 3)))]\n-  \"TARGET_32BIT && reload_completed\"\n-  [(set (match_dup 0)\n-\t(and:SI (neg:SI (geu:SI (match_dup 1) (match_dup 2))) (match_dup 3)))\n-   (set (match_dup 4)\n-\t(compare:CC (match_dup 0)\n-\t\t    (const_int 0)))]\n-  \"\")\n-\n-(define_insn \"*plus_gt0<mode>\"\n-  [(set (match_operand:P 0 \"gpc_reg_operand\" \"=&r\")\n-\t(plus:P (gt:P (match_operand:P 1 \"gpc_reg_operand\" \"r\")\n-\t\t      (const_int 0))\n-\t\t (match_operand:P 2 \"gpc_reg_operand\" \"r\")))]\n-  \"\"\n-  \"addc %0,%1,%1\\;subfe %0,%1,%0\\;addze %0,%2\"\n-  [(set_attr \"type\" \"three\")\n-   (set_attr \"length\" \"12\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x,?y\")\n-\t(compare:CC\n-\t (plus:SI (gt:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r,r\")\n-\t\t\t (const_int 0))\n-\t\t  (match_operand:SI 2 \"gpc_reg_operand\" \"r,r\"))\n-\t (const_int 0)))\n-   (clobber (match_scratch:SI 3 \"=&r,&r\"))]\n-  \"TARGET_32BIT\"\n-  \"@\n-   addc %3,%1,%1\\;subfe %3,%1,%3\\;addze. %3,%2\n-   #\"\n-  [(set_attr \"type\" \"compare\")\n-   (set_attr \"length\" \"12,16\")])\n-\n-(define_split\n-  [(set (match_operand:CC 0 \"cc_reg_not_cr0_operand\" \"\")\n-\t(compare:CC\n-\t (plus:SI (gt:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n-\t\t\t (const_int 0))\n-\t\t  (match_operand:SI 2 \"gpc_reg_operand\" \"\"))\n-\t (const_int 0)))\n-   (clobber (match_scratch:SI 3 \"\"))]\n-  \"TARGET_32BIT && reload_completed\"\n-  [(set (match_dup 3)\n-\t(plus:SI (gt:SI (match_dup 1) (const_int 0))\n-\t\t  (match_dup 2)))\n-   (set (match_dup 0)\n-\t(compare:CC (match_dup 3)\n-\t\t    (const_int 0)))]\n-  \"\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x,?y\")\n-\t(compare:CC\n-\t (plus:DI (gt:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r,r\")\n-\t\t\t (const_int 0))\n-\t\t  (match_operand:DI 2 \"gpc_reg_operand\" \"r,r\"))\n-\t (const_int 0)))\n-   (clobber (match_scratch:DI 3 \"=&r,&r\"))]\n-  \"TARGET_64BIT\"\n-  \"@\n-   addc %3,%1,%1\\;subfe %3,%1,%3\\;addze. %3,%2\n-   #\"\n-  [(set_attr \"type\" \"compare\")\n-   (set_attr \"length\" \"12,16\")])\n-\n-(define_split\n-  [(set (match_operand:CC 0 \"cc_reg_not_micro_cr0_operand\" \"\")\n-\t(compare:CC\n-\t (plus:DI (gt:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n-\t\t\t (const_int 0))\n-\t\t  (match_operand:DI 2 \"gpc_reg_operand\" \"\"))\n-\t (const_int 0)))\n-   (clobber (match_scratch:DI 3 \"\"))]\n-  \"TARGET_64BIT && reload_completed\"\n-  [(set (match_dup 3)\n-\t(plus:DI (gt:DI (match_dup 1) (const_int 0))\n-\t\t (match_dup 2)))\n-   (set (match_dup 0)\n-\t(compare:CC (match_dup 3)\n-\t\t    (const_int 0)))]\n-  \"\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,?y\")\n-\t(compare:CC\n-\t (plus:SI (gt:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r,r\")\n-\t\t\t (const_int 0))\n-\t\t  (match_operand:SI 2 \"gpc_reg_operand\" \"r,r\"))\n-\t (const_int 0)))\n-   (set (match_operand:SI 0 \"gpc_reg_operand\" \"=&r,&r\")\n-\t(plus:SI (gt:SI (match_dup 1) (const_int 0)) (match_dup 2)))]\n-  \"TARGET_32BIT\"\n-  \"@\n-   addc %0,%1,%1\\;subfe %0,%1,%0\\;addze. %0,%2\n-   #\"\n-  [(set_attr \"type\" \"compare\")\n-   (set_attr \"length\" \"12,16\")])\n-\n-(define_split\n-  [(set (match_operand:CC 3 \"cc_reg_not_cr0_operand\" \"\")\n-\t(compare:CC\n-\t (plus:SI (gt:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n-\t\t\t (const_int 0))\n-\t\t  (match_operand:SI 2 \"gpc_reg_operand\" \"\"))\n-\t (const_int 0)))\n-   (set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t(plus:SI (gt:SI (match_dup 1) (const_int 0)) (match_dup 2)))]\n-  \"TARGET_32BIT && reload_completed\"\n-  [(set (match_dup 0)\n-\t(plus:SI (gt:SI (match_dup 1) (const_int 0)) (match_dup 2)))\n-   (set (match_dup 3)\n-\t(compare:CC (match_dup 0)\n-\t\t    (const_int 0)))]\n-  \"\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,?y\")\n-\t(compare:CC\n-\t (plus:DI (gt:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r,r\")\n-\t\t\t (const_int 0))\n-\t\t  (match_operand:DI 2 \"gpc_reg_operand\" \"r,r\"))\n-\t (const_int 0)))\n-   (set (match_operand:DI 0 \"gpc_reg_operand\" \"=&r,&r\")\n-\t(plus:DI (gt:DI (match_dup 1) (const_int 0)) (match_dup 2)))]\n-  \"TARGET_64BIT\"\n-  \"@\n-   addc %0,%1,%1\\;subfe %0,%1,%0\\;addze. %0,%2\n-   #\"\n-  [(set_attr \"type\" \"compare\")\n-   (set_attr \"length\" \"12,16\")])\n-\n-(define_split\n-  [(set (match_operand:CC 3 \"cc_reg_not_micro_cr0_operand\" \"\")\n-\t(compare:CC\n-\t (plus:DI (gt:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n-\t\t\t (const_int 0))\n-\t\t  (match_operand:DI 2 \"gpc_reg_operand\" \"\"))\n-\t (const_int 0)))\n-   (set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n-\t(plus:DI (gt:DI (match_dup 1) (const_int 0)) (match_dup 2)))]\n-  \"TARGET_64BIT && reload_completed\"\n-  [(set (match_dup 0)\n-\t(plus:DI (gt:DI (match_dup 1) (const_int 0)) (match_dup 2)))\n-   (set (match_dup 3)\n-\t(compare:CC (match_dup 0)\n-\t\t    (const_int 0)))]\n-  \"\")\n-\n-(define_insn_and_split \"*gtu<mode>\"\n-  [(set (match_operand:P 0 \"gpc_reg_operand\" \"=r\")\n-\t(gtu:P (match_operand:P 1 \"gpc_reg_operand\" \"r\")\n-\t       (match_operand:P 2 \"reg_or_short_operand\" \"rI\")))]\n-  \"\"\n-  \"#\"\n-  \"\"\n-  [(set (match_dup 0) (neg:P (gtu:P (match_dup 1) (match_dup 2))))\n-   (set (match_dup 0) (neg:P (match_dup 0)))]\n-  \"\")\n-\n-(define_insn_and_split \"*gtu<mode>_compare\"\n-  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,?y\")\n-\t(compare:CC\n-\t (gtu:P (match_operand:P 1 \"gpc_reg_operand\" \"r,r\")\n-\t\t (match_operand:P 2 \"reg_or_short_operand\" \"rI,rI\"))\n-\t (const_int 0)))\n-   (set (match_operand:P 0 \"gpc_reg_operand\" \"=r,r\")\n-\t(gtu:P (match_dup 1) (match_dup 2)))]\n-  \"\"\n-  \"#\"\n-  \"\"\n-  [(set (match_dup 0) (neg:P (gtu:P (match_dup 1) (match_dup 2))))\n-   (parallel [(set (match_dup 3)\n-\t\t   (compare:CC (neg:P (match_dup 0)) (const_int 0)))\n-\t      (set (match_dup 0) (neg:P (match_dup 0)))])]\n-  \"\")\n-\n-(define_insn_and_split \"*plus_gtu<mode>\"\n-  [(set (match_operand:P 0 \"gpc_reg_operand\" \"=&r\")\n-        (plus:P (gtu:P (match_operand:P 1 \"gpc_reg_operand\" \"r\")\n-\t\t       (match_operand:P 2 \"reg_or_short_operand\" \"rI\"))\n-\t\t(match_operand:P 3 \"gpc_reg_operand\" \"r\")))]\n-  \"\"\n-  \"#\"\n-  \"&& !reg_overlap_mentioned_p (operands[0], operands[3])\"\n-  [(set (match_dup 0) (neg:P (gtu:P (match_dup 1) (match_dup 2))))\n-   (set (match_dup 0) (minus:P (match_dup 3) (match_dup 0)))]\n-  \"\")\n-\n-(define_insn_and_split \"*plus_gtu<mode>_1\"\n-  [(set (match_operand:P 0 \"gpc_reg_operand\" \"=&r\")\n-        (plus:P (gtu:P (match_operand:P 1 \"gpc_reg_operand\" \"r\")\n-\t\t       (match_operand:P 2 \"reg_or_short_operand\" \"rI\"))\n-\t\t(match_operand:P 3 \"short_cint_operand\" \"I\")))]\n-  \"\"\n-  \"#\"\n-  \"&& !reg_overlap_mentioned_p (operands[0], operands[3])\"\n-  [(set (match_dup 0) (neg:P (gtu:P (match_dup 1) (match_dup 2))))\n-   (parallel [(set (match_dup 0) (minus:P (match_dup 3) (match_dup 0)))\n-\t      (clobber (reg:P CA_REGNO))])]\n-  \"\")\n-\n-(define_insn_and_split \"*plus_gtu<mode>_compare\"\n-  [(set (match_operand:CC 4 \"cc_reg_operand\" \"=x,x,?y,?y\")\n-\t(compare:CC\n-\t (plus:P (gtu:P (match_operand:P 1 \"gpc_reg_operand\" \"r,r,r,r\")\n-\t\t\t(match_operand:P 2 \"reg_or_short_operand\" \"I,r,I,r\"))\n-\t\t (match_operand:P 3 \"gpc_reg_operand\" \"r,r,r,r\"))\n-\t (const_int 0)))\n-   (set (match_operand:P 0 \"gpc_reg_operand\" \"=&r,&r,&r,&r\")\n-\t(plus:P (gtu:P (match_dup 1) (match_dup 2)) (match_dup 3)))]\n-  \"\"\n-  \"#\"\n-  \"&& !reg_overlap_mentioned_p (operands[0], operands[3])\"\n-  [(set (match_dup 0) (neg:P (gtu:P (match_dup 1) (match_dup 2))))\n-   (parallel [(set (match_dup 4)\n-\t\t   (compare:CC (minus:P (match_dup 3) (match_dup 0))\n-\t\t\t       (const_int 0)))\n-\t      (set (match_dup 0) (minus:P (match_dup 3) (match_dup 0)))])]\n-  \"\")\n-\n-(define_insn \"*neg_gtu<mode>\"\n-  [(set (match_operand:P 0 \"gpc_reg_operand\" \"=r\")\n-\t(neg:P (gtu:P (match_operand:P 1 \"gpc_reg_operand\" \"r\")\n-\t\t      (match_operand:P 2 \"reg_or_short_operand\" \"rI\"))))]\n-  \"\"\n-  \"subf%I2c %0,%1,%2\\;subfe %0,%0,%0\"\n-  [(set_attr \"type\" \"two\")\n-   (set_attr \"length\" \"8\")])\n+  \"#\"\n+  \"\"\n+  [(parallel [(set (match_dup 5)\n+\t\t   (neg:P (match_dup 4)))\n+\t      (set (reg:P CA_REGNO)\n+\t\t   (eq:P (match_dup 4)\n+\t\t\t (const_int 0)))])\n+   (parallel [(set (match_dup 0)\n+\t\t   (plus:P (plus:P (match_dup 3)\n+\t\t\t\t   (reg:P CA_REGNO))\n+\t\t\t   (const_int -1)))\n+\t      (clobber (reg:P CA_REGNO))])]\n+{\n+  operands[4] = rs6000_emit_eqne (<MODE>mode,\n+\t\t\t\t  operands[1], operands[2], operands[4]);\n \n+  if (GET_CODE (operands[5]) == SCRATCH)\n+    operands[5] = gen_reg_rtx (<MODE>mode);\n+}\n+  [(set (attr \"length\")\n+\t(if_then_else (match_test \"operands[2] == const0_rtx\")\n+\t\t      (const_string \"8\")\n+\t\t      (const_string \"12\")))])\n \f\n ;; Define both directions of branch and return.  If we need a reload\n ;; register, we'd rather use CR0 since it is much easier to copy a"}]}