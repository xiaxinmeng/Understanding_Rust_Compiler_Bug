{"sha": "fe45e59ec7c0f225502471bf4202bee09efb63db", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmU0NWU1OWVjN2MwZjIyNTUwMjQ3MWJmNDIwMmJlZTA5ZWZiNjNkYg==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2006-02-15T09:44:37Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-02-15T09:44:37Z"}, "message": "sem_ch4.adb (Remove_Abstract_Interpretations): Even if there are no abstract interpretations on an operator...\n\n2006-02-13  Ed Schonberg  <schonberg@adacore.com>\n\t    Javier Miranda  <miranda@adacore.com>\n\n\t* sem_ch4.adb (Remove_Abstract_Interpretations): Even if there are no\n\tabstract interpretations on an operator, remove interpretations that\n\tyield Address or a type derived from it, if one of the operands is an\n\tinteger literal.\n\t(Try_Object_Operation.Try_Primitive_Operation,\n\tTry_Object_Operation.Try_Class_Wide_Operation): Set proper source\n\tlocation when creating the new reference to a primitive or class-wide\n\toperation as a part of rewriting a subprogram call.\n\t(Try_Primitive_Operations): If context requires a function, collect all\n\tinterpretations after the first match, because there may be primitive\n\toperations of the same type with the same profile and different return\n\ttypes. From code reading.\n\t(Try_Primitive_Operation): Use the node kind to choose the proper\n\toperation when a function and a procedure have the same parameter\n\tprofile.\n\t(Complete_Object_Operation): If formal is an access parameter and prefix\n\tis an object, rewrite as an Access reference, to match signature of\n\tprimitive operation.\n\t(Find_Equality_Type, Find_One_Interp): Handle properly equality given\n\tby an expanded name with prefix Standard, when the operands are of an\n\tanonymous access type.\n\t(Remove_Abstract_Operations): If the operation is abstract because it is\n\tinherited by a user-defined type derived from Address, remove it as\n\twell from the set of candidate interpretations of an overloaded node.\n\t(Analyze_Membership_Op): Membership test not applicable to cpp-class\n\ttypes.\n\nFrom-SVN: r111092", "tree": {"sha": "7851a02c7a187a5b03c154214ea5fede66f09443", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7851a02c7a187a5b03c154214ea5fede66f09443"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fe45e59ec7c0f225502471bf4202bee09efb63db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe45e59ec7c0f225502471bf4202bee09efb63db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe45e59ec7c0f225502471bf4202bee09efb63db", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe45e59ec7c0f225502471bf4202bee09efb63db/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "57193e09243103515c50b2b433ddb15a90d311b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57193e09243103515c50b2b433ddb15a90d311b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57193e09243103515c50b2b433ddb15a90d311b7"}], "stats": {"total": 201, "additions": 156, "deletions": 45}, "files": [{"sha": "06669fb4a17628d3814d4b136f27081e589d0f44", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 156, "deletions": 45, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe45e59ec7c0f225502471bf4202bee09efb63db/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe45e59ec7c0f225502471bf4202bee09efb63db/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=fe45e59ec7c0f225502471bf4202bee09efb63db", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -41,6 +41,7 @@ with Opt;      use Opt;\n with Output;   use Output;\n with Restrict; use Restrict;\n with Rident;   use Rident;\n+with Rtsfind;  use Rtsfind;\n with Sem;      use Sem;\n with Sem_Cat;  use Sem_Cat;\n with Sem_Ch3;  use Sem_Ch3;\n@@ -1870,6 +1871,12 @@ package body Sem_Ch4 is\n       --  in any case.\n \n       Set_Etype (N, Standard_Boolean);\n+\n+      if Comes_From_Source (N)\n+        and then Is_CPP_Class (Etype (Etype (Right_Opnd (N))))\n+      then\n+         Error_Msg_N (\"membership test not applicable to cpp-class types\", N);\n+      end if;\n    end Analyze_Membership_Op;\n \n    ----------------------\n@@ -2040,7 +2047,7 @@ package body Sem_Ch4 is\n       then\n          return;\n \n-      elsif not Present (Actuals) then\n+      elsif No (Actuals) then\n \n          --  If Normalize succeeds, then there are default parameters for\n          --  all formals.\n@@ -4064,18 +4071,31 @@ package body Sem_Ch4 is\n          --  universal, the context will impose the correct type. An anonymous\n          --  type for a 'Access reference is also universal in this sense, as\n          --  the actual type is obtained from context.\n+         --  In Ada 2005, the equality operator for anonymous access types\n+         --  is declared in Standard, and preference rules apply to it.\n \n-         if Present (Scop)\n-            and then not Defined_In_Scope (T1, Scop)\n-            and then T1 /= Universal_Integer\n-            and then T1 /= Universal_Real\n-            and then T1 /= Any_Access\n-            and then T1 /= Any_String\n-            and then T1 /= Any_Composite\n-            and then (Ekind (T1) /= E_Access_Subprogram_Type\n-                        or else Comes_From_Source (T1))\n-         then\n-            return;\n+         if Present (Scop) then\n+            if Defined_In_Scope (T1, Scop)\n+              or else T1 = Universal_Integer\n+              or else T1 = Universal_Real\n+              or else T1 = Any_Access\n+              or else T1 = Any_String\n+              or else T1 = Any_Composite\n+              or else (Ekind (T1) = E_Access_Subprogram_Type\n+                          and then not Comes_From_Source (T1))\n+            then\n+               null;\n+\n+            elsif Ekind (T1) = E_Anonymous_Access_Type\n+              and then Scop = Standard_Standard\n+            then\n+               null;\n+\n+            else\n+               --  The scope does not contain an operator for the type\n+\n+               return;\n+            end if;\n          end if;\n \n          --  Ada 2005 (AI-230): Keep restriction imposed by Ada 83 and 95:\n@@ -4123,6 +4143,11 @@ package body Sem_Ch4 is\n             if Etype (N) = Any_Type then\n                Found := False;\n             end if;\n+\n+         elsif Scop = Standard_Standard\n+           and then Ekind (T1) = E_Anonymous_Access_Type\n+         then\n+            Found := True;\n          end if;\n       end Try_One_Interp;\n \n@@ -4595,27 +4620,56 @@ package body Sem_Ch4 is\n             if not Is_Type (It.Nam)\n               and then Is_Abstract (It.Nam)\n               and then not Is_Dispatching_Operation (It.Nam)\n-              and then\n-                (Ada_Version >= Ada_05\n-                   or else Is_Predefined_File_Name\n-                             (Unit_File_Name (Get_Source_Unit (It.Nam))))\n-\n             then\n                Abstract_Op := It.Nam;\n-               Remove_Interp (I);\n-               exit;\n+\n+               --  In Ada 2005, this operation does not participate in Overload\n+               --  resolution. If the operation is defined in in a predefined\n+               --  unit, it is one of the operations declared abstract in some\n+               --  variants of System, and it must be removed as well.\n+\n+               if Ada_Version >= Ada_05\n+                   or else Is_Predefined_File_Name\n+                             (Unit_File_Name (Get_Source_Unit (It.Nam)))\n+                   or else Is_Descendent_Of_Address (It.Typ)\n+               then\n+                  Remove_Interp (I);\n+                  exit;\n+               end if;\n             end if;\n \n             Get_Next_Interp (I, It);\n          end loop;\n \n          if No (Abstract_Op) then\n-            return;\n+\n+            --  If some interpretation yields an integer type, it is still\n+            --  possible that there are address interpretations. Remove them\n+            --  if one operand is a literal, to avoid spurious ambiguities\n+            --  on systems where Address is a visible integer type.\n+\n+            if Is_Overloaded (N)\n+              and then  Nkind (N) in N_Op\n+              and then Is_Integer_Type (Etype (N))\n+            then\n+               if Nkind (N) in N_Binary_Op then\n+                  if Nkind (Right_Opnd (N)) = N_Integer_Literal then\n+                     Remove_Address_Interpretations (Second_Op);\n+\n+                  elsif Nkind (Right_Opnd (N)) = N_Integer_Literal then\n+                     Remove_Address_Interpretations (First_Op);\n+                  end if;\n+               end if;\n+            end if;\n \n          elsif Nkind (N) in N_Op then\n \n-            --  Remove interpretations that treat literals as addresses.\n-            --  This is never appropriate.\n+            --  Remove interpretations that treat literals as addresses. This\n+            --  is never appropriate, even when Address is defined as a visible\n+            --  Integer type. The reason is that we would really prefer Address\n+            --  to behave as a private type, even in this case, which is there\n+            --  only to accomodate oddities of VMS address sizes. If Address is\n+            --  a visible integer type, we get lots of overload ambiguities.\n \n             if Nkind (N) in N_Binary_Op then\n                declare\n@@ -4884,6 +4938,8 @@ package body Sem_Ch4 is\n          Node_To_Replace : Node_Id;\n          Subprog         : Node_Id)\n       is\n+         Formal_Type  : constant Entity_Id :=\n+                          Etype (First_Formal (Entity (Subprog)));\n          First_Actual : Node_Id;\n \n       begin\n@@ -4898,12 +4954,26 @@ package body Sem_Ch4 is\n \n          --  If need be, rewrite first actual as an explicit dereference\n \n-         if not Is_Access_Type (Etype (First_Formal (Entity (Subprog))))\n+         if not Is_Access_Type (Formal_Type)\n            and then Is_Access_Type (Etype (Obj))\n          then\n             Rewrite (First_Actual,\n               Make_Explicit_Dereference (Sloc (Obj), Obj));\n             Analyze (First_Actual);\n+\n+         --  Conversely, if the formal is an access parameter and the\n+         --  object is not, replace the actual with a 'Access reference.\n+         --   Its analysis will check that the object is aliased.\n+\n+         elsif Is_Access_Type (Formal_Type)\n+           and then not Is_Access_Type (Etype (Obj))\n+         then\n+            Rewrite (First_Actual,\n+              Make_Attribute_Reference (Loc,\n+                Attribute_Name => Name_Access,\n+                Prefix => Relocate_Node (Obj)));\n+            Analyze (First_Actual);\n+\n          else\n             Rewrite (First_Actual, Obj);\n          end if;\n@@ -5040,7 +5110,7 @@ package body Sem_Ch4 is\n                  and then Etype (First_Formal (Hom)) =\n                             Class_Wide_Type (Anc_Type)\n                then\n-                  Hom_Ref := New_Reference_To (Hom, Loc);\n+                  Hom_Ref := New_Reference_To (Hom, Sloc (Subprog));\n \n                   Set_Etype (Call_Node, Any_Type);\n                   Set_Parent (Call_Node, Parent (Node_To_Replace));\n@@ -5091,8 +5161,9 @@ package body Sem_Ch4 is\n       is\n          Elmt        : Elmt_Id;\n          Prim_Op     : Entity_Id;\n-         Prim_Op_Ref : Node_Id;\n-         Success     : Boolean;\n+         Prim_Op_Ref : Node_Id := Empty;\n+         Success     : Boolean := False;\n+         Op_Exists   : Boolean := False;\n \n          function Valid_First_Argument_Of (Op : Entity_Id) return Boolean;\n          --  Verify that the prefix, dereferenced if need be, is a valid\n@@ -5128,7 +5199,9 @@ package body Sem_Ch4 is\n       --  Start of processing for Try_Primitive_Operation\n \n       begin\n-         --  Look for the subprogram in the list of primitive operations\n+         --  Look for subprograms in the list of primitive operations\n+         --  The name must be identical, and the kind of call indicates\n+         --  the expected kind of operation (function or procedure).\n \n          Elmt := First_Elmt (Primitive_Operations (Obj_Type));\n          while Present (Elmt) loop\n@@ -5137,35 +5210,73 @@ package body Sem_Ch4 is\n             if Chars (Prim_Op) = Chars (Subprog)\n               and then Present (First_Formal (Prim_Op))\n               and then Valid_First_Argument_Of (Prim_Op)\n+              and then\n+                 (Nkind (Call_Node) = N_Function_Call)\n+                   = (Ekind (Prim_Op) = E_Function)\n             then\n-               Prim_Op_Ref := New_Reference_To (Prim_Op, Loc);\n+               --  If this primitive operation corresponds with an immediate\n+               --  ancestor interface there is no need to add it to the list\n+               --  of interpretations; the corresponding aliased primitive is\n+               --  also in this list of primitive operations and will be\n+               --  used instead.\n+\n+               if Present (Abstract_Interface_Alias (Prim_Op))\n+                 and then Present (DTC_Entity (Alias (Prim_Op)))\n+                 and then Etype (DTC_Entity (Alias (Prim_Op))) = RTE (RE_Tag)\n+               then\n+                  goto Continue;\n+               end if;\n+\n+               if not Success then\n+                  Prim_Op_Ref := New_Reference_To (Prim_Op, Sloc (Subprog));\n \n-               Set_Etype (Call_Node, Any_Type);\n-               Set_Parent (Call_Node, Parent (Node_To_Replace));\n+                  Set_Etype (Call_Node, Any_Type);\n+                  Set_Parent (Call_Node, Parent (Node_To_Replace));\n \n-               Set_Name (Call_Node, Prim_Op_Ref);\n+                  Set_Name (Call_Node, Prim_Op_Ref);\n \n-               Analyze_One_Call\n-                 (N          => Call_Node,\n-                  Nam        => Prim_Op,\n-                  Report     => False,\n-                  Success    => Success,\n-                  Skip_First => True);\n+                  Analyze_One_Call\n+                    (N          => Call_Node,\n+                     Nam        => Prim_Op,\n+                     Report     => False,\n+                     Success    => Success,\n+                     Skip_First => True);\n \n-               if Success then\n-                  Complete_Object_Operation\n-                    (Call_Node       => Call_Node,\n-                     Node_To_Replace => Node_To_Replace,\n-                     Subprog         => Prim_Op_Ref);\n+                  if Success then\n+                     Op_Exists := True;\n \n-                  return True;\n+                     --  If the operation is a procedure call, there can only\n+                     --  be one candidate and we found it. If it is a function\n+                     --  we must collect all interpretations, because there\n+                     --  may be several primitive operations that differ only\n+                     --  in the return type.\n+\n+                     if Nkind (Call_Node) = N_Procedure_Call_Statement then\n+                        exit;\n+                     end if;\n+                  end if;\n+\n+               elsif Ekind (Prim_Op) = E_Function then\n+\n+                  --  Collect remaining function interpretations, to be\n+                  --  resolved from context.\n+\n+                  Add_One_Interp (Prim_Op_Ref, Prim_Op, Etype (Prim_Op));\n                end if;\n             end if;\n \n+            <<Continue>>\n             Next_Elmt (Elmt);\n          end loop;\n \n-         return False;\n+         if Op_Exists then\n+            Complete_Object_Operation\n+              (Call_Node       => Call_Node,\n+               Node_To_Replace => Node_To_Replace,\n+               Subprog         => Prim_Op_Ref);\n+         end if;\n+\n+         return Op_Exists;\n       end Try_Primitive_Operation;\n \n    --  Start of processing for Try_Object_Operation"}]}