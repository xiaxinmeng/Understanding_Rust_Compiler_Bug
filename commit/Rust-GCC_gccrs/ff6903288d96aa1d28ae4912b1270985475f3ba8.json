{"sha": "ff6903288d96aa1d28ae4912b1270985475f3ba8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmY2OTAzMjg4ZDk2YWExZDI4YWU0OTEyYjEyNzA5ODU0NzVmM2JhOA==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2021-02-11T13:24:50Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2021-02-11T13:25:04Z"}, "message": "Fortran: Fix calls to associate name typebound subroutines [PR98897].\n\n2021-02-11  Paul Thomas  <pault@gcc.gnu.org>\n\ngcc/fortran\n\tPR fortran/98897\n\t* match.c (gfc_match_call): Include associate names as possible\n\tentities with typebound subroutines. The target needs to be\n\tresolved for the type.\n\ngcc/testsuite/\n\tPR fortran/98897\n\t* gfortran.dg/typebound_call_32.f90: New test.", "tree": {"sha": "e881839a198422bcdc2c84c10fc9fdc0188a7689", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e881839a198422bcdc2c84c10fc9fdc0188a7689"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ff6903288d96aa1d28ae4912b1270985475f3ba8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff6903288d96aa1d28ae4912b1270985475f3ba8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff6903288d96aa1d28ae4912b1270985475f3ba8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff6903288d96aa1d28ae4912b1270985475f3ba8/comments", "author": null, "committer": null, "parents": [{"sha": "22a6d99d0a0d383856440ea479b4a9edabf23961", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22a6d99d0a0d383856440ea479b4a9edabf23961", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22a6d99d0a0d383856440ea479b4a9edabf23961"}], "stats": {"total": 53, "additions": 49, "deletions": 4}, "files": [{"sha": "2df6191d7e6809f4d3d53f151ff6dc2a43fbe02f", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6903288d96aa1d28ae4912b1270985475f3ba8/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6903288d96aa1d28ae4912b1270985475f3ba8/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=ff6903288d96aa1d28ae4912b1270985475f3ba8", "patch": "@@ -4999,10 +4999,16 @@ gfc_match_call (void)\n   sym = st->n.sym;\n \n   /* If this is a variable of derived-type, it probably starts a type-bound\n-     procedure call.  */\n-  if ((sym->attr.flavor != FL_PROCEDURE\n-       || gfc_is_function_return_value (sym, gfc_current_ns))\n-      && (sym->ts.type == BT_DERIVED || sym->ts.type == BT_CLASS))\n+     procedure call. Associate variable targets have to be resolved for the\n+     target type.  */\n+  if (((sym->attr.flavor != FL_PROCEDURE\n+\t|| gfc_is_function_return_value (sym, gfc_current_ns))\n+       && (sym->ts.type == BT_DERIVED || sym->ts.type == BT_CLASS))\n+\t\t||\n+      (sym->assoc && sym->assoc->target\n+       && gfc_resolve_expr (sym->assoc->target)\n+       && (sym->assoc->target->ts.type == BT_DERIVED\n+\t   || sym->assoc->target->ts.type == BT_CLASS)))\n     return match_typebound_call (st);\n \n   /* If it does not seem to be callable (include functions so that the"}, {"sha": "88ddae494c2a6ab6bfe148fb17cfeb7abaf8a162", "filename": "gcc/testsuite/gfortran.dg/typebound_call_32.f90", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6903288d96aa1d28ae4912b1270985475f3ba8/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_call_32.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6903288d96aa1d28ae4912b1270985475f3ba8/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_call_32.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_call_32.f90?ref=ff6903288d96aa1d28ae4912b1270985475f3ba8", "patch": "@@ -0,0 +1,39 @@\n+! { dg-do run }\n+!\n+! Test the fix for PR98897 in which typebound subroutines of associate names\n+! were not recognised in a call. Functions were OK but this is tested below.\n+!\n+! Contributed by Damian Rouson  <damian@sourceryinstitute.org>\n+!\n+module output_data_m\n+  implicit none\n+\n+  type output_data_t\n+    integer, private :: i = 0\n+  contains\n+    procedure output, return_value\n+  end type\n+\n+\n+contains\n+  subroutine output(self)\n+      implicit none\n+      class(output_data_t) self\n+      self%i = 1234\n+  end subroutine\n+\n+  integer function return_value(self)\n+      implicit none\n+      class(output_data_t) self\n+      return_value = self%i\n+  end function\n+end module\n+\n+  use output_data_m\n+  implicit none\n+  associate(output_data => output_data_t())\n+    call output_data%output\n+    if (output_data%return_value() .ne. 1234) stop 1\n+  end associate\n+end\n+"}]}