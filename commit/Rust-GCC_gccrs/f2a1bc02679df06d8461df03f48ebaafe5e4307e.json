{"sha": "f2a1bc02679df06d8461df03f48ebaafe5e4307e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjJhMWJjMDI2NzlkZjA2ZDg0NjFkZjAzZjQ4ZWJhYWZlNWU0MzA3ZQ==", "commit": {"author": {"name": "Bob Manson", "email": "manson@cygnus.com", "date": "1999-08-24T22:35:55Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-08-24T22:35:55Z"}, "message": "haifa-sched.c (split_hard_reg_notes): Move to flow.c\n\n        * haifa-sched.c (split_hard_reg_notes): Move to flow.c\n        (new_insn_dead_notes): Likewise.\n        (update_n_sets): Likewise.\n        (update_flow_info): Move to flow.c, renamed to update_life_info;\n        extend to handle multiple source insns.\n        * flow.c: Include resource.h\n        (unlink_insn_chain): New.\n        (split_hard_reg_notes): New.\n        (maybe_add_dead_note): New.\n        (maybe_add_dead_note_use): New.\n        (find_insn_with_note): New.\n        (new_insn_dead_notes): New.\n        (update_n_sets): New.\n        (sets_reg_or_subreg_1, sets_reg_or_subreg): New.\n        (maybe_remove_dead_notes): New.\n        (update_life_info): New.\n        (prepend_reg_notes): New.\n        (replace_insns): New.\n        * output.h (update_life_info): Declare.\n        * recog.c (split_block_insns): Use update_life_info.\n        * resource.c (find_free_register): Use reg_alloc_order, don't use\n        fixed regs, make sure the mode is supported, don't use new regs.\n        (reg_dead_p): New.\n        * rtl.h (replace_insns): Declare.\n\nCo-Authored-By: Richard Henderson <rth@cygnus.com>\n\nFrom-SVN: r28828", "tree": {"sha": "e86a9635ca292ea67589cef742a73eea422d2d19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e86a9635ca292ea67589cef742a73eea422d2d19"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f2a1bc02679df06d8461df03f48ebaafe5e4307e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2a1bc02679df06d8461df03f48ebaafe5e4307e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2a1bc02679df06d8461df03f48ebaafe5e4307e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2a1bc02679df06d8461df03f48ebaafe5e4307e/comments", "author": null, "committer": null, "parents": [{"sha": "952d33b8db3341dd48dc4e73186720f33a8525db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/952d33b8db3341dd48dc4e73186720f33a8525db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/952d33b8db3341dd48dc4e73186720f33a8525db"}], "stats": {"total": 1817, "additions": 1128, "deletions": 689}, "files": [{"sha": "e98401a62e391e817cde3dc52465a4ce193fbe46", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2a1bc02679df06d8461df03f48ebaafe5e4307e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2a1bc02679df06d8461df03f48ebaafe5e4307e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f2a1bc02679df06d8461df03f48ebaafe5e4307e", "patch": "@@ -1,3 +1,31 @@\n+Tue Aug 24 11:46:10 1999  Bob Manson <manson@cygnus.com>\n+\t\t\t  Richard Henderson  <rth@cygnus.com>\n+\n+\t* haifa-sched.c (split_hard_reg_notes): Move to flow.c\n+\t(new_insn_dead_notes): Likewise.\n+\t(update_n_sets): Likewise.\n+\t(update_flow_info): Move to flow.c, renamed to update_life_info;\n+\textend to handle multiple source insns.\n+\t* flow.c: Include resource.h\n+\t(unlink_insn_chain): New.\n+\t(split_hard_reg_notes): New.\n+\t(maybe_add_dead_note): New.\n+\t(maybe_add_dead_note_use): New.\n+\t(find_insn_with_note): New.\n+\t(new_insn_dead_notes): New.\n+\t(update_n_sets): New.\n+\t(sets_reg_or_subreg_1, sets_reg_or_subreg): New.\n+\t(maybe_remove_dead_notes): New.\n+\t(update_life_info): New.\n+\t(prepend_reg_notes): New.\n+\t(replace_insns): New.\n+\t* output.h (update_life_info): Declare.\n+\t* recog.c (split_block_insns): Use update_life_info.\n+\t* resource.c (find_free_register): Use reg_alloc_order, don't use\n+\tfixed regs, make sure the mode is supported, don't use new regs.\n+\t(reg_dead_p): New.\n+\t* rtl.h (replace_insns): Declare.\n+\n Tue Aug 24 13:48:39 1999  Nathan Sidwell  <nathan@acm.org>\n \n \t* expr.c (expand_expr): Cope with COND_EXPRs with one"}, {"sha": "27e8355bb34eb11fca34d69d0fb96c00dcb6f82d", "filename": "gcc/flow.c", "status": "modified", "additions": 1049, "deletions": 0, "changes": 1049, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2a1bc02679df06d8461df03f48ebaafe5e4307e/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2a1bc02679df06d8461df03f48ebaafe5e4307e/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=f2a1bc02679df06d8461df03f48ebaafe5e4307e", "patch": "@@ -132,6 +132,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"toplev.h\"\n #include \"recog.h\"\n #include \"insn-flags.h\"\n+#include \"resource.h\"\n \n #include \"obstack.h\"\n #define obstack_chunk_alloc xmalloc\n@@ -333,6 +334,13 @@ static void count_reg_sets\t\tPROTO ((rtx));\n static void count_reg_references\tPROTO ((rtx));\n static void notice_stack_pointer_modification PROTO ((rtx, rtx));\n static void invalidate_mems_from_autoinc\tPROTO ((rtx));\n+static void maybe_remove_dead_notes\tPROTO ((rtx, rtx, rtx, rtx,\n+\t\t\t\t\t\trtx, rtx));\n+static int maybe_add_dead_note_use\tPROTO ((rtx, rtx));\n+static int maybe_add_dead_note\t\tPROTO ((rtx, rtx, rtx));\n+static int sets_reg_or_subreg\t\tPROTO ((rtx, rtx));\n+static void update_n_sets \t\tPROTO ((rtx, int));\n+static void new_insn_dead_notes\t\tPROTO ((rtx, rtx, rtx, rtx, rtx, rtx));\n void verify_flow_info\t\t\tPROTO ((void));\n \f\n /* Find basic blocks of the current function.\n@@ -5034,6 +5042,1047 @@ set_block_num (insn, bb)\n   set_block_for_insn (insn, BASIC_BLOCK (bb));\n }\n \f\n+/* Unlink a chain of insns between START and FINISH inclusive, leaving notes\n+   that must be paired, and return the new chain.  */\n+\n+rtx\n+unlink_insn_chain (start, finish)\n+     rtx start, finish;\n+{\n+  rtx insert_point = PREV_INSN (start);\n+  rtx chain = NULL_RTX, curr;\n+\n+  /* Unchain the insns one by one.  It would be quicker to delete all\n+     of these with a single unchaining, rather than one at a time, but\n+     we need to keep the NOTE's.  */\n+\n+  while (1)\n+    {\n+      rtx next = NEXT_INSN (start);\n+\n+      remove_insn (start);\n+\n+      /* ??? Despite the fact that we're patching out the insn, it's\n+\t still referenced in LOG_LINKS.  Rather than try and track\n+\t them all down and remove them, just mark the insn deleted.  */\n+      INSN_DELETED_P (start) = 1;\n+\n+      if (GET_CODE (start) == NOTE && ! can_delete_note_p (start))\n+\t{\n+\t  add_insn_after (start, insert_point);\n+\t  insert_point = start;\n+\t}\n+      else\n+\t{\n+\t  if (chain != NULL)\n+\t    {\n+\t      NEXT_INSN (curr) = start;\n+\t      PREV_INSN (start) = curr;\n+\t      curr = start;\n+\t    }\n+\t  else\n+\t    {\n+\t      chain = start;\n+\t      curr = start;\n+\t      PREV_INSN (chain) = NULL_RTX;\n+\t    }\n+\t}\n+\n+      if (start == finish)\n+\tbreak;\n+      start = next;\n+    }\n+\n+  if (chain != NULL_RTX)\n+    NEXT_INSN (curr) = NULL_RTX;\n+\n+  return chain;\n+}\n+\n+/* Subroutine of update_life_info.  Determines whether multiple\n+   REG_NOTEs need to be distributed for the hard register mentioned in\n+   NOTE.  This can happen if a reference to a hard register in the\n+   original insns was split into several smaller hard register\n+   references in the new insns.  */\n+\n+static void\n+split_hard_reg_notes (curr_insn, note, first, last)\n+     rtx curr_insn, note, first, last;\n+{\n+  rtx reg, temp, link;\n+  rtx insn;\n+  int n_regs, i, new_reg;\n+\n+  reg = XEXP (note, 0);\n+\n+  if (REG_NOTE_KIND (note) != REG_DEAD\n+      || GET_CODE (reg) != REG\n+      || REGNO (reg) >= FIRST_PSEUDO_REGISTER\n+      || HARD_REGNO_NREGS (REGNO (reg), GET_MODE (reg)) == 1)\n+    {\n+      XEXP (note, 1) = REG_NOTES (curr_insn);\n+      REG_NOTES (curr_insn) = note;\n+      return;\n+    }\n+\n+  n_regs = HARD_REGNO_NREGS (REGNO (reg), GET_MODE (reg));\n+\n+  for (i = 0; i < n_regs; i++)\n+    {\n+      new_reg = REGNO (reg) + i;\n+\n+      /* Check for references to new_reg in the split insns.  */\n+      for (insn = last; ; insn = PREV_INSN (insn))\n+\t{\n+\t  if (GET_RTX_CLASS (GET_CODE (insn)) == 'i'\n+\t      && (temp = regno_use_in (new_reg, PATTERN (insn))))\n+\t    {\n+\t      /* Create a new reg dead note here.  */\n+\t      link = rtx_alloc (EXPR_LIST);\n+\t      PUT_REG_NOTE_KIND (link, REG_DEAD);\n+\t      XEXP (link, 0) = temp;\n+\t      XEXP (link, 1) = REG_NOTES (insn);\n+\t      REG_NOTES (insn) = link;\n+\n+\t      /* If killed multiple registers here, then add in the excess.  */\n+\t      i += HARD_REGNO_NREGS (REGNO (temp), GET_MODE (temp)) - 1;\n+\n+\t      break;\n+\t    }\n+\t  /* It isn't mentioned anywhere, so no new reg note is needed for\n+\t     this register.  */\n+\t  if (insn == first)\n+\t    break;\n+\t}\n+    }\n+}\n+\n+/* SET_INSN kills REG; add a REG_DEAD note mentioning REG to the last\n+   use of REG in the insns after SET_INSN and before or including\n+   LAST, if necessary.\n+\n+   A non-zero value is returned if we added a REG_DEAD note, or if we\n+   determined that a REG_DEAD note because of this particular SET\n+   wasn't necessary. */\n+\n+static int\n+maybe_add_dead_note (reg, set_insn, last)\n+     rtx reg, set_insn, last;\n+{\n+  rtx insn;\n+\n+  for (insn = last; insn != set_insn; insn = PREV_INSN (insn))\n+    {\n+      rtx set;\n+\n+      if (GET_RTX_CLASS (GET_CODE (insn)) == 'i'\n+\t  && reg_overlap_mentioned_p (reg, PATTERN (insn))\n+\t  && (set = single_set (insn)))\n+\t{\n+\t  rtx insn_dest = SET_DEST (set);\n+\n+\t  while (GET_CODE (insn_dest) == ZERO_EXTRACT\n+\t\t || GET_CODE (insn_dest) == SUBREG\n+\t\t || GET_CODE (insn_dest) == STRICT_LOW_PART\n+\t\t || GET_CODE (insn_dest) == SIGN_EXTRACT)\n+\t    insn_dest = XEXP (insn_dest, 0);\n+\n+\t  if (! rtx_equal_p (insn_dest, reg))\n+\t    {\n+\t      /* Use the same scheme as combine.c, don't put both REG_DEAD\n+\t\t and REG_UNUSED notes on the same insn.  */\n+\t      if (! find_regno_note (insn, REG_UNUSED, REGNO (reg))\n+\t\t  && ! find_regno_note (insn, REG_DEAD, REGNO (reg)))\n+\t\t{\n+\t\t  rtx note = rtx_alloc (EXPR_LIST);\n+\t\t  PUT_REG_NOTE_KIND (note, REG_DEAD);\n+\t\t  XEXP (note, 0) = reg;\n+\t\t  XEXP (note, 1) = REG_NOTES (insn);\n+\t\t  REG_NOTES (insn) = note;\n+\t\t}\n+\t      return 1;\n+\t    }\n+\t  else if (reg_overlap_mentioned_p (reg, SET_SRC (set)))\n+\t    {\n+\t      /* We found an instruction that both uses the register and\n+\t\t sets it, so no new REG_NOTE is needed for the previous\n+\t\t set.  */\n+\t      return 0;\n+\t    }\n+\t}\n+    }\n+  return 0;\n+}\n+\n+static int\n+maybe_add_dead_note_use (insn, dest)\n+     rtx insn, dest;\n+{\n+  rtx set;\n+\n+  /* We need to add a REG_DEAD note to the last place DEST is\n+     referenced. */\n+\n+  if (GET_RTX_CLASS (GET_CODE (insn)) == 'i'\n+      && reg_mentioned_p (dest, PATTERN (insn))\n+      && (set = single_set (insn)))\n+    {\n+      rtx insn_dest = SET_DEST (set);\n+\n+      while (GET_CODE (insn_dest) == ZERO_EXTRACT\n+\t     || GET_CODE (insn_dest) == SUBREG\n+\t     || GET_CODE (insn_dest) == STRICT_LOW_PART\n+\t     || GET_CODE (insn_dest) == SIGN_EXTRACT)\n+\tinsn_dest = XEXP (insn_dest, 0);\n+\n+      if (! rtx_equal_p (insn_dest, dest))\n+\t{\n+\t  /* Use the same scheme as combine.c, don't put both REG_DEAD\n+\t     and REG_UNUSED notes on the same insn.  */\n+\t  if (! find_regno_note (insn, REG_UNUSED, REGNO (dest))\n+\t      && ! find_regno_note (insn, REG_DEAD, REGNO (dest)))\n+\t    {\n+\t      rtx note = rtx_alloc (EXPR_LIST);\n+\t      PUT_REG_NOTE_KIND (note, REG_DEAD);\n+\t      XEXP (note, 0) = dest;\n+\t      XEXP (note, 1) = REG_NOTES (insn);\n+\t      REG_NOTES (insn) = note;\n+\t    }\n+\t  return 1;\n+\t}\n+    }\n+  return 0;\n+}\n+\n+/* Find the first insn in the set of insns from FIRST to LAST inclusive\n+   that contains the note NOTE. */\n+rtx\n+find_insn_with_note (note, first, last)\n+     rtx note, first, last;\n+{\n+  rtx insn;\n+\n+  for (insn = first; insn != NULL_RTX; insn = NEXT_INSN (insn))\n+    {\n+      rtx temp = find_reg_note (insn, REG_NOTE_KIND (note), XEXP (note, 0));\n+      if (temp == note)\n+\t{\n+\t  return insn;\n+\t}\n+      if (insn == last)\n+\t{\n+\t  break;\n+\t}\n+    }\n+  return NULL_RTX;\n+}\n+     \n+/* Subroutine of update_life_info.  Determines whether a SET or\n+   CLOBBER in an insn created by splitting needs a REG_DEAD or\n+   REG_UNUSED note added.  */\n+\n+static void\n+new_insn_dead_notes (pat, insn, first, last, orig_first_insn, orig_last_insn)\n+     rtx pat, insn, first, last, orig_first_insn, orig_last_insn;\n+{\n+  rtx dest, tem;\n+\n+  if (GET_CODE (pat) != CLOBBER && GET_CODE (pat) != SET)\n+    abort ();\n+\n+  dest = XEXP (pat, 0);\n+\n+  while (GET_CODE (dest) == ZERO_EXTRACT || GET_CODE (dest) == SUBREG\n+\t || GET_CODE (dest) == STRICT_LOW_PART\n+\t || GET_CODE (dest) == SIGN_EXTRACT)\n+    dest = XEXP (dest, 0);\n+\n+  if (GET_CODE (dest) == REG)\n+    {\n+      /* If the original insns already used this register, we may not\n+         add new notes for it.  One example for a replacement that\n+         needs this test is when a multi-word memory access with\n+         register-indirect addressing is changed into multiple memory\n+         accesses with auto-increment and one adjusting add\n+         instruction for the address register.\n+\n+\t However, there is a problem with this code. We're assuming\n+\t that any registers that are set in the new insns are either\n+\t set/referenced in the old insns (and thus \"inherit\" the\n+\t liveness of the old insns), or are registers that are dead\n+\t before we enter this part of the stream (and thus should be\n+\t dead when we leave).\n+\n+\t To do this absolutely correctly, we must determine the actual\n+\t liveness of the registers before we go randomly adding\n+\t REG_DEAD notes. This can probably be accurately done by\n+\t calling mark_referenced_resources() on the old stream before\n+\t replacing the old insns.  */\n+\n+      for (tem = orig_first_insn; tem != NULL_RTX; tem = NEXT_INSN (tem))\n+\t{\n+\t  if (GET_RTX_CLASS (GET_CODE (tem)) == 'i'\n+\t      && reg_referenced_p (dest, PATTERN (tem)))\n+\t    return;\n+\t  if (tem == orig_last_insn)\n+\t    break;\n+\t}\n+      /* So it's a new register, presumably only used within this\n+\t group of insns. Find the last insn in the set of new insns\n+\t that DEST is referenced in, and add a dead note to it. */\n+      if (! maybe_add_dead_note (dest, insn, last))\n+\t{\n+\t  /* If this is a set, it must die somewhere, unless it is the\n+\t     dest of the original insn, and thus is live after the\n+\t     original insn.  Abort if it isn't supposed to be live after\n+\t     the original insn.\n+\n+\t     If this is a clobber, then just add a REG_UNUSED note.  */\n+\t  if (GET_CODE (pat) == CLOBBER)\n+\t    {\n+\t      rtx note = rtx_alloc (EXPR_LIST);\n+\t      PUT_REG_NOTE_KIND (note, REG_UNUSED);\n+\t      XEXP (note, 0) = dest;\n+\t      XEXP (note, 1) = REG_NOTES (insn);\n+\t      REG_NOTES (insn) = note;\n+\t      return;\n+\t    }\n+\t  else\n+\t    {\n+\t      struct resources res;\n+\t      rtx curr;\n+\n+\t      CLEAR_RESOURCE (&res);\n+\t      for (curr = orig_first_insn;\n+\t\t   curr != NULL_RTX;\n+\t\t   curr = NEXT_INSN (curr))\n+\t\t{\n+\t\t  if (GET_RTX_CLASS (GET_CODE (curr)) == 'i')\n+\t\t    mark_set_resources (PATTERN (curr), &res, 0, 0);\n+\t\t  if (TEST_HARD_REG_BIT (res.regs, REGNO (dest)))\n+\t\t    break;\n+\t\t  if (curr == orig_last_insn)\n+\t\t    break;\n+\t\t}\n+\n+\t      /* In case reg was not used later, it is dead store.\n+\t         add REG_UNUSED note.  */\n+\t      if (! TEST_HARD_REG_BIT (res.regs, REGNO (dest)))\n+\t        {\n+\t          rtx note = rtx_alloc (EXPR_LIST);\n+\t          PUT_REG_NOTE_KIND (note, REG_UNUSED);\n+\t          XEXP (note, 0) = dest;\n+\t          XEXP (note, 1) = REG_NOTES (insn);\n+\t          REG_NOTES (insn) = note;\n+\t          return;\n+\t        }\n+\t    }\n+\t}\n+      if (insn != first)\n+\t{\n+\t  rtx set = single_set (insn);\n+\t  /* If this is a set, scan backwards for a previous\n+\t     reference, and attach a REG_DEAD note to it. But we don't\n+\t     want to do it if the insn is both using and setting the\n+\t     register.\n+\n+\t     Global registers are always live.  */\n+\t  if (set && ! reg_overlap_mentioned_p (dest, SET_SRC (pat))\n+\t      && (REGNO (dest) >= FIRST_PSEUDO_REGISTER\n+\t\t  || ! global_regs[REGNO (dest)]))\n+\t    {\n+\t      for (tem = PREV_INSN (insn);\n+\t\t   tem != NULL_RTX; tem = PREV_INSN (tem))\n+\t\t{\n+\t\t  if (maybe_add_dead_note_use (tem, dest))\n+\t\t    break;\n+\t\t  if (tem == first)\n+\t\t    break;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* Subroutine of update_life_info.  Update the value of reg_n_sets for all\n+   registers modified by X.  INC is -1 if the containing insn is being deleted,\n+   and is 1 if the containing insn is a newly generated insn.  */\n+\n+static void\n+update_n_sets (x, inc)\n+     rtx x;\n+     int inc;\n+{\n+  rtx dest = SET_DEST (x);\n+\n+  while (GET_CODE (dest) == STRICT_LOW_PART || GET_CODE (dest) == SUBREG\n+\t || GET_CODE (dest) == ZERO_EXTRACT || GET_CODE (dest) == SIGN_EXTRACT)\n+    dest = SUBREG_REG (dest);\n+\n+  if (GET_CODE (dest) == REG)\n+    {\n+      int regno = REGNO (dest);\n+      \n+      if (regno < FIRST_PSEUDO_REGISTER)\n+\t{\n+\t  register int i;\n+\t  int endregno = regno + HARD_REGNO_NREGS (regno, GET_MODE (dest));\n+\t  \n+\t  for (i = regno; i < endregno; i++)\n+\t    REG_N_SETS (i) += inc;\n+\t}\n+      else\n+\tREG_N_SETS (regno) += inc;\n+    }\n+}\n+\n+/* Scan INSN for a SET that sets REG. If it sets REG via a SUBREG,\n+   then return 2. If it sets REG directly, return 1. Otherwise, return\n+   0. */\n+\n+static int sets_reg_or_subreg_ret;\n+static rtx sets_reg_or_subreg_rtx;\n+\n+static void\n+sets_reg_or_subreg_1 (x, set)\n+     rtx x, set;\n+{\n+  if (rtx_equal_p (x, sets_reg_or_subreg_rtx))\n+    {\n+      if (x == XEXP (set, 0))\n+\tsets_reg_or_subreg_ret = 1;\n+      else if (GET_CODE (XEXP (set, 0)) == SUBREG)\n+\tsets_reg_or_subreg_ret = 2;\n+    }\n+}\n+\n+static int\n+sets_reg_or_subreg (insn, reg)\n+     rtx insn;\n+     rtx reg;\n+{\n+  if (GET_RTX_CLASS (GET_CODE (insn)) != 'i')\n+    return 0;\n+\n+  sets_reg_or_subreg_ret = 0;\n+  sets_reg_or_subreg_rtx = reg;\n+  note_stores (PATTERN (insn), sets_reg_or_subreg_1);\n+  return sets_reg_or_subreg_ret;\n+}\n+\n+/* If a replaced SET_INSN (which is part of the insns between\n+   OLD_FIRST_INSN and OLD_LAST_INSN inclusive) is modifying a multiple\n+   register target, and the original dest is now set in the new insns\n+   (between FIRST_INSN and LAST_INSN inclusive) by one or more subreg\n+   sets, then the new insns no longer kill the destination of the\n+   original insn.\n+\n+   We may also be directly using the register in the new insns before\n+   setting it.\n+\n+   In either case, if there exists an instruction in the same basic\n+   block before the replaced insns which uses the original dest (and\n+   contains a corresponding REG_DEAD note), then we must remove this\n+   REG_DEAD note. \n+\n+   SET_INSN is the insn that contains the SET; it may be a PARALLEL\n+   containing the SET insn.\n+\n+   SET is the actual SET insn proper. */\n+\n+static void\n+maybe_remove_dead_notes (set_insn, set, first_insn, last_insn, \n+\t\t\t old_first_insn, old_last_insn)\n+     rtx set_insn, set;\n+     rtx first_insn, last_insn;\n+     rtx old_first_insn, old_last_insn;\n+{\n+  rtx insn;\n+  rtx stop_insn = NEXT_INSN (last_insn);\n+  int set_type = 0;\n+  rtx set_dest;\n+  rtx set_pattern;\n+\n+  if (GET_RTX_CLASS (GET_CODE (set)) != 'i')\n+    return;\n+\n+  set_pattern = PATTERN (set);\n+\n+  if (GET_CODE (set_pattern) == PARALLEL)\n+    {\n+      int i;\n+\n+      for (i = 0; i < XVECLEN (set_pattern, 0); i++)\n+\t{\n+\t  maybe_remove_dead_notes (set_insn, XVECEXP (set_pattern, 0, i),\n+\t\t\t\t   first_insn, last_insn, \n+\t\t\t\t   old_first_insn, old_last_insn);\n+\t}\n+      return;\n+    }\n+\n+  if (GET_CODE (set_pattern) != SET)\n+    {\n+      return;\n+    }\n+\n+  set_dest = SET_DEST (set_pattern);\n+\n+  if (GET_CODE (set_dest) != REG)\n+    {\n+      return;\n+    }\n+\n+  /* We have a set of a REG. First we need to determine if this set is\n+     both using and setting the register. (FIXME: if this is in a\n+     PARALLEL, we will have to check the other exprs as well.) */\n+  if (reg_overlap_mentioned_p (set_dest, SET_SRC (set_pattern)))\n+    {\n+      return;\n+    }\n+\n+  /* Now determine if we used or set the register in the old insns\n+     previous to this one. */\n+\n+  for (insn = old_first_insn; insn != set_insn; insn = NEXT_INSN (insn))\n+    {\n+      if (reg_overlap_mentioned_p (set_dest, insn))\n+\t{\n+\t  return;\n+\t}\n+    }\n+\n+  /* Now determine if we're setting it in the new insns, or using\n+     it. */\n+  for (insn = first_insn; insn != stop_insn; insn = NEXT_INSN (insn))\n+    {\n+      set_type = sets_reg_or_subreg (insn, set_dest);\n+      if (set_type != 0)\n+\t{\n+\t  break;\n+\t}\n+      else if (reg_overlap_mentioned_p (set_dest, insn))\n+\t{\n+\t  /* Is the reg now used in this new insn?  -- This is probably an\n+\t     error. */\n+\t  set_type = 2;\n+\t  break;\n+\t}\n+    }\n+  if (set_type == 2)\n+    {\n+      /* The register is being set via a SUBREG or is being used in\n+\t some other way, so it's no longer dead.\n+\n+\t Search backwards from first_insn, looking for the first insn\n+\t that uses the original dest.  Stop if we pass a CODE_LABEL or\n+\t a JUMP_INSN.\n+\n+\t If we find such an insn and it has a REG_DEAD note referring\n+\t to the original dest, then delete the note.  */\n+\n+      for (insn = first_insn; insn != NULL_RTX; insn = PREV_INSN (insn))\n+\t{\n+\t  if (GET_CODE (insn) == CODE_LABEL\n+\t      || GET_CODE (insn) == JUMP_INSN)\n+\t    break;\n+\t  else if (GET_RTX_CLASS (GET_CODE (insn)) == 'i'\n+\t\t   && reg_mentioned_p (set_dest, insn))\n+\t    {\n+\t      rtx note = find_regno_note (insn, REG_DEAD, REGNO (set_dest));\n+\t      if (note != NULL_RTX)\n+\t\t{\n+\t\t  remove_note (insn, note);\n+\t\t}\n+\t      /* ??? -- Is this right? */\n+\t      break;\n+\t    }\n+\t}\n+    }\n+  else if (set_type == 0)\n+    {\n+      /* The reg is not being set or used in the new insns at all. */\n+      int i, regno;\n+\n+      /* Should never reach here for a pseudo reg.  */\n+      if (REGNO (set_dest) >= FIRST_PSEUDO_REGISTER)\n+\tabort ();\n+\n+      /* This can happen for a hard register, if the new insns do not\n+\t contain instructions which would be no-ops referring to the\n+\t old registers. \n+\n+\t We try to verify that this is the case by checking to see if\n+\t the original instruction uses all of the registers that it\n+\t set. This case is OK, because deleting a no-op can not affect\n+\t REG_DEAD notes on other insns. If this is not the case, then\n+\t abort.  */\n+\n+      regno = REGNO (set_dest);\n+      for (i = HARD_REGNO_NREGS (regno, GET_MODE (set_dest)) - 1;\n+\t   i >= 0; i--)\n+\t{\n+\t  if (! refers_to_regno_p (regno + i, regno + i + 1, set,\n+\t\t\t\t   NULL_PTR))\n+\t    break;\n+\t}\n+      if (i >= 0)\n+\tabort ();\n+    }\n+}\n+\n+/* Updates all flow-analysis related quantities (including REG_NOTES) for\n+   the insns from FIRST to LAST inclusive that were created by replacing\n+   the insns from ORIG_INSN_FIRST to ORIG_INSN_LAST inclusive.  NOTES\n+   are the original REG_NOTES.  */\n+\n+void\n+update_life_info (notes, first, last, orig_first_insn, orig_last_insn)\n+     rtx notes;\n+     rtx first, last;\n+     rtx orig_first_insn, orig_last_insn;\n+{\n+  rtx insn, note;\n+  rtx next;\n+  rtx orig_dest, temp;\n+  rtx orig_insn;\n+  rtx tem;\n+\n+  /* Get and save the destination set by the original insn, if there\n+     was only one insn replaced.  */\n+\n+  if (orig_first_insn == orig_last_insn)\n+    {\n+      orig_insn = orig_first_insn;\n+      orig_dest = single_set (orig_insn);\n+      if (orig_dest)\n+\torig_dest = SET_DEST (orig_dest);\n+    }\n+  else\n+    {\n+      orig_insn = NULL_RTX;\n+      orig_dest = NULL_RTX;\n+    }\n+\n+  /* Move REG_NOTES from the original insns to where they now belong.  */\n+\n+  for (note = notes; note; note = next)\n+    {\n+      next = XEXP (note, 1);\n+      switch (REG_NOTE_KIND (note))\n+\t{\n+\tcase REG_DEAD:\n+\tcase REG_UNUSED:\n+\t  /* Move these notes from the original insn to the last new\n+\t     insn where the register is mentioned.  */\n+\n+\t  for (insn = last; ; insn = PREV_INSN (insn))\n+\t    {\n+\t      if (GET_RTX_CLASS (GET_CODE (insn)) == 'i'\n+\t\t  && reg_mentioned_p (XEXP (note, 0), PATTERN (insn)))\n+\t\t{\n+\t\t  /* Sometimes need to convert REG_UNUSED notes to\n+\t\t     REG_DEAD notes. */\n+\t\t  if (REG_NOTE_KIND (note) == REG_UNUSED\n+\t\t      && GET_CODE (XEXP (note, 0)) == REG\n+\t\t      && ! dead_or_set_p (insn, XEXP (note, 0)))\n+\t\t    {\n+\t\t      PUT_REG_NOTE_KIND (note, REG_DEAD);\n+\t\t    }\n+\t\t  split_hard_reg_notes (insn, note, first, last);\n+\t\t  /* The reg only dies in one insn, the last one that uses\n+\t\t     it.  */\n+\t\t  break;\n+\t\t}\n+\t      /* It must die somewhere, fail if we couldn't find where it died.\n+\n+\t\t We abort because otherwise the register will be live\n+\t\t longer than it should, and we'll probably take an\n+\t\t abort later. What we should do instead is search back\n+\t\t and find the appropriate places to insert the note.  */\n+\t      if (insn == first)\n+\t\t{\n+\t\t  if (REG_NOTE_KIND (note) == REG_DEAD)\n+\t\t    {\n+\t\t      abort ();\n+\t\t    }\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t  break;\n+\n+\tcase REG_WAS_0:\n+\t  {\n+\t    rtx note_dest;\n+\n+\t    /* If the insn that set the register to 0 was deleted, this\n+\t       note cannot be relied on any longer.  The destination might\n+\t       even have been moved to memory.\n+\t       This was observed for SH4 with execute/920501-6.c compilation,\n+\t       -O2 -fomit-frame-pointer -finline-functions .  */\n+\n+\t    if (GET_CODE (XEXP (note, 0)) == NOTE\n+\t\t|| INSN_DELETED_P (XEXP (note, 0)))\n+\t      break;\n+\t    if (orig_insn != NULL_RTX)\n+\t      {\n+\t\tnote_dest = orig_dest;\n+\t      }\n+\t    else\n+\t      {\n+\t\tnote_dest = find_insn_with_note (note, first, last);\n+\t\tif (note_dest != NULL_RTX)\n+\t\t  {\n+\t\t    note_dest = single_set (orig_dest);\n+\t\t    if (note_dest != NULL_RTX)\n+\t\t      {\n+\t\t\tnote_dest = SET_DEST (orig_dest);\n+\t\t      }\n+\t\t  }\n+\t      }\n+\t      /* This note applies to the dest of the original insn.  Find the\n+\t\t first new insn that now has the same dest, and move the note\n+\t\t there.  */\n+\n+\t    if (! note_dest)\n+\t      abort ();\n+\n+\t    for (insn = first; ; insn = NEXT_INSN (insn))\n+\t      {\n+\t\tif (GET_RTX_CLASS (GET_CODE (insn)) == 'i'\n+\t\t    && (temp = single_set (insn))\n+\t\t    && rtx_equal_p (SET_DEST (temp), note_dest))\n+\t\t  {\n+\t\t    XEXP (note, 1) = REG_NOTES (insn);\n+\t\t    REG_NOTES (insn) = note;\n+\t\t    /* The reg is only zero before one insn, the first that\n+\t\t       uses it.  */\n+\t\t    break;\n+\t\t  }\n+\t\t/* If this note refers to a multiple word hard\n+\t\t   register, it may have been split into several smaller\n+\t\t   hard register references.  We could split the notes,\n+\t\t   but simply dropping them is good enough.  */\n+\t\tif (GET_CODE (note_dest) == REG\n+\t\t    && REGNO (note_dest) < FIRST_PSEUDO_REGISTER\n+\t\t    && HARD_REGNO_NREGS (REGNO (note_dest),\n+\t\t\t\t\t GET_MODE (note_dest)) > 1)\n+\t\t  break;\n+\t\t/* It must be set somewhere; fail if we couldn't find\n+\t\t   where it was set.  */\n+\t\tif (insn == last)\n+\t\t  abort ();\n+\t      }\n+\t  }\n+\t  break;\n+\n+\tcase REG_EQUAL:\n+\tcase REG_EQUIV:\n+\t  /* A REG_EQUIV or REG_EQUAL note on an insn with more than one\n+\t     set is meaningless.  Just drop the note.  */\n+\t  if (! orig_dest)\n+\t    break;\n+\n+\tcase REG_NO_CONFLICT:\n+\t  /* These notes apply to the dest of the original insn.  Find the last\n+\t     new insn that now has the same dest, and move the note there.  \n+\n+\t     If we are replacing multiple insns, just drop the note. */\n+\n+\t  if (! orig_insn)\n+\t    break;\n+\n+\t  if (! orig_dest)\n+\t    abort ();\n+\n+\t  for (insn = last; ; insn = PREV_INSN (insn))\n+\t    {\n+\t      if (GET_RTX_CLASS (GET_CODE (insn)) == 'i'\n+\t\t  && (temp = single_set (insn))\n+\t\t  && rtx_equal_p (SET_DEST (temp), orig_dest))\n+\t\t{\n+\t\t  XEXP (note, 1) = REG_NOTES (insn);\n+\t\t  REG_NOTES (insn) = note;\n+\t\t  /* Only put this note on one of the new insns.  */\n+\t\t  break;\n+\t\t}\n+\n+\t      /* The original dest must still be set someplace.  Abort if we\n+\t\t couldn't find it.  */\n+\t      if (insn == first)\n+\t\t{\n+\t\t  /* However, if this note refers to a multiple word hard\n+\t\t     register, it may have been split into several smaller\n+\t\t     hard register references.  We could split the notes,\n+\t\t     but simply dropping them is good enough.  */\n+\t\t  if (GET_CODE (orig_dest) == REG\n+\t\t      && REGNO (orig_dest) < FIRST_PSEUDO_REGISTER\n+\t\t      && HARD_REGNO_NREGS (REGNO (orig_dest),\n+\t\t\t\t\t   GET_MODE (orig_dest)) > 1)\n+\t\t    break;\n+\t\t  /* Likewise for multi-word memory references.  */\n+\t\t  if (GET_CODE (orig_dest) == MEM\n+\t\t      && GET_MODE_SIZE (GET_MODE (orig_dest)) > MOVE_MAX)\n+\t\t    break;\n+\t\t  abort ();\n+\t\t}\n+\t    }\n+\t  break;\n+\n+\tcase REG_LIBCALL:\n+\t  /* Move a REG_LIBCALL note to the first insn created, and update\n+\t     the corresponding REG_RETVAL note.  */\n+\t  XEXP (note, 1) = REG_NOTES (first);\n+\t  REG_NOTES (first) = note;\n+\n+\t  insn = XEXP (note, 0);\n+\t  note = find_reg_note (insn, REG_RETVAL, NULL_RTX);\n+\t  if (note)\n+\t    XEXP (note, 0) = first;\n+\t  break;\n+\n+\tcase REG_EXEC_COUNT:\n+\t  /* Move a REG_EXEC_COUNT note to the first insn created.  */\n+\t  XEXP (note, 1) = REG_NOTES (first);\n+\t  REG_NOTES (first) = note;\n+\t  break;\n+\n+\tcase REG_RETVAL:\n+\t  /* Move a REG_RETVAL note to the last insn created, and update\n+\t     the corresponding REG_LIBCALL note.  */\n+\t  XEXP (note, 1) = REG_NOTES (last);\n+\t  REG_NOTES (last) = note;\n+\n+\t  insn = XEXP (note, 0);\n+\t  note = find_reg_note (insn, REG_LIBCALL, NULL_RTX);\n+\t  if (note)\n+\t    XEXP (note, 0) = last;\n+\t  break;\n+\n+\tcase REG_NONNEG:\n+\tcase REG_BR_PROB:\n+\t  /* This should be moved to whichever instruction is a JUMP_INSN.  */\n+\n+\t  for (insn = last; ; insn = PREV_INSN (insn))\n+\t    {\n+\t      if (GET_CODE (insn) == JUMP_INSN)\n+\t\t{\n+\t\t  XEXP (note, 1) = REG_NOTES (insn);\n+\t\t  REG_NOTES (insn) = note;\n+\t\t  /* Only put this note on one of the new insns.  */\n+\t\t  break;\n+\t\t}\n+\t      /* Fail if we couldn't find a JUMP_INSN.  */\n+\t      if (insn == first)\n+\t\tabort ();\n+\t    }\n+\t  break;\n+\n+\tcase REG_INC:\n+\t  /* reload sometimes leaves obsolete REG_INC notes around.  */\n+\t  if (reload_completed)\n+\t    break;\n+\t  /* This should be moved to whichever instruction now has the\n+\t     increment operation.  */\n+\t  abort ();\n+\n+\tcase REG_LABEL:\n+\t  /* Should be moved to the new insn(s) which use the label.  */\n+\t  for (insn = first; insn != NEXT_INSN (last); insn = NEXT_INSN (insn))\n+\t    if (GET_RTX_CLASS (GET_CODE (insn)) == 'i'\n+\t\t&& reg_mentioned_p (XEXP (note, 0), PATTERN (insn)))\n+\t      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_LABEL,\n+\t\t\t\t\t\t    XEXP (note, 0),\n+\t\t\t\t\t\t    REG_NOTES (insn));\n+\t  break;\n+\n+\tcase REG_CC_SETTER:\n+\tcase REG_CC_USER:\n+\t  /* These two notes will never appear until after reorg, so we don't\n+\t     have to handle them here.  */\n+\tdefault:\n+\t  abort ();\n+\t}\n+    }\n+\n+  /* Each new insn created has a new set.  If the destination is a\n+     register, then this reg is now live across several insns, whereas\n+     previously the dest reg was born and died within the same insn.\n+     To reflect this, we now need a REG_DEAD note on the insn where\n+     this dest reg dies.\n+\n+     Similarly, the new insns may have clobbers that need REG_UNUSED\n+     notes.  */\n+\n+  for (insn = first; ;insn = NEXT_INSN (insn))\n+    {\n+      rtx pat;\n+      int i;\n+\n+      pat = PATTERN (insn);\n+      if (GET_CODE (pat) == SET || GET_CODE (pat) == CLOBBER)\n+\tnew_insn_dead_notes (pat, insn, first, last, \n+\t\t\t     orig_first_insn, orig_last_insn);\n+      else if (GET_CODE (pat) == PARALLEL)\n+\t{\n+\t  for (i = 0; i < XVECLEN (pat, 0); i++)\n+\t    {\n+\t      if (GET_CODE (XVECEXP (pat, 0, i)) == SET\n+\t\t  || GET_CODE (XVECEXP (pat, 0, i)) == CLOBBER)\n+\t\t{\n+\t\t  rtx parpat = XVECEXP (pat, 0, i);\n+\n+\t\t  new_insn_dead_notes (parpat, insn, first, last, \n+\t\t\t\t       orig_first_insn, orig_last_insn);\n+\t\t}\n+\t    }\n+\t}\n+      if (insn == last)\n+\t{\n+\t  break;\n+\t}\n+    }\n+\n+  /* Check to see if we have any REG_DEAD notes on insns previous to\n+     the new ones that are now incorrect and need to be removed. */\n+\n+  for (insn = orig_first_insn; ; insn = NEXT_INSN (insn))\n+    {\n+      maybe_remove_dead_notes (insn, insn, first, last,\n+\t\t\t       orig_first_insn, orig_last_insn);\n+\n+      if (insn == orig_last_insn)\n+\tbreak;\n+    }\n+\n+  /* Update reg_n_sets.  This is necessary to prevent local alloc from\n+     converting REG_EQUAL notes to REG_EQUIV when the new insns are setting\n+     a reg multiple times instead of once. */\n+\n+  for (tem = orig_first_insn; tem != NULL_RTX; tem = NEXT_INSN (tem))\n+    {\n+      rtx x;\n+      RTX_CODE code;\n+\n+      if (GET_RTX_CLASS (GET_CODE (tem)) != 'i')\n+\tcontinue;\n+\n+       x = PATTERN (tem);\n+      code = GET_CODE (x);\n+      if (code == SET || code == CLOBBER)\n+\tupdate_n_sets (x, -1);\n+      else if (code == PARALLEL)\n+\t{\n+\t  int i;\n+\t  for (i = XVECLEN (x, 0) - 1; i >= 0; i--)\n+\t    {\n+\t      code = GET_CODE (XVECEXP (x, 0, i));\n+\t      if (code == SET || code == CLOBBER)\n+\t\tupdate_n_sets (XVECEXP (x, 0, i), -1);\n+\t    }\n+\t}\n+      if (tem == orig_last_insn)\n+\tbreak;\n+    }\n+\n+  for (insn = first; ; insn = NEXT_INSN (insn))\n+    {\n+      rtx x = PATTERN (insn);\n+      RTX_CODE code = GET_CODE (x);\n+\n+      if (code == SET || code == CLOBBER)\n+\tupdate_n_sets (x, 1);\n+      else if (code == PARALLEL)\n+\t{\n+\t  int i;\n+\t  for (i = XVECLEN (x, 0) - 1; i >= 0; i--)\n+\t    {\n+\t      code = GET_CODE (XVECEXP (x, 0, i));\n+\t      if (code == SET || code == CLOBBER)\n+\t\tupdate_n_sets (XVECEXP (x, 0, i), 1);\n+\t    }\n+\t}\n+\n+      if (insn == last)\n+\tbreak;\n+    }\n+}\n+\f\n+/* Prepends the set of REG_NOTES in NEW to NOTES, and returns NEW. */\n+static rtx\n+prepend_reg_notes (notes, new)\n+     rtx notes, new;\n+{\n+  rtx end;\n+\n+  if (new == NULL_RTX)\n+    {\n+      return notes;\n+    }\n+  if (notes == NULL_RTX)\n+    {\n+      return new;\n+    }\n+  end = new;\n+  while (XEXP (end, 1) != NULL_RTX)\n+    {\n+      end = XEXP (end, 1);\n+    }\n+  XEXP (end, 1) = notes;\n+  return new;\n+}\n+\f\n+/* Replace the insns from FIRST to LAST inclusive with the set of insns in\n+   NEW, and update the life analysis info accordingly. */\n+void\n+replace_insns (first, last, first_new, notes)\n+     rtx first, last, first_new, notes;\n+{\n+  rtx stop = NEXT_INSN (last);\n+  rtx last_new;\n+  rtx curr, next;\n+  rtx prev = PREV_INSN (first);\n+  int i;\n+\n+  if (notes == NULL_RTX)\n+    {\n+      for (curr = first; curr != stop; curr = NEXT_INSN (curr))\n+\t{\n+\t  notes = prepend_reg_notes (notes, REG_NOTES (curr));\n+\t}\n+    }\n+  for (curr = first; curr; curr = next)\n+    {\n+      next = NEXT_INSN (curr);\n+      delete_insn (curr);\n+      if (curr == last)\n+\tbreak;\n+    }\n+  last_new = emit_insn_after (first_new, prev);\n+  first_new = NEXT_INSN (prev);\n+  for (i = 0; i < n_basic_blocks; i++)\n+    {\n+      if (BLOCK_HEAD (i) == first)\n+\t{\n+\t  BLOCK_HEAD (i) = first_new;\n+\t}\n+      if (BLOCK_END (i) == last)\n+\t{\n+\t  BLOCK_END (i) = last_new;\n+\t}\n+    }\n+  /* This is probably bogus. */\n+  if (first_new == last_new)\n+    {\n+      if (GET_CODE (first_new) == SEQUENCE)\n+\t{\n+\t  first_new = XVECEXP (first_new, 0, 0);\n+\t  last_new = XVECEXP (last_new, 0, XVECLEN (last_new, 0) - 1);\n+\t}\n+    }\n+  update_life_info (notes, first_new, last_new, first, last);\n+}\n+\f\n /* Verify the CFG consistency.  This function check some CFG invariants and\n    aborts when something is wrong.  Hope that this function will help to\n    convert many optimization passes to preserve CFG consistent."}, {"sha": "d63e04c816f19d761f6ce7e75287a164978e5dae", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 0, "deletions": 680, "changes": 680, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2a1bc02679df06d8461df03f48ebaafe5e4307e/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2a1bc02679df06d8461df03f48ebaafe5e4307e/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=f2a1bc02679df06d8461df03f48ebaafe5e4307e", "patch": "@@ -452,9 +452,6 @@ static void attach_deaths_insn PROTO ((rtx));\n static int new_sometimes_live PROTO ((struct sometimes *, int, int));\n static void finish_sometimes_live PROTO ((struct sometimes *, int));\n static int schedule_block PROTO ((int, int));\n-static void split_hard_reg_notes PROTO ((rtx, rtx, rtx));\n-static void new_insn_dead_notes PROTO ((rtx, rtx, rtx, rtx));\n-static void update_n_sets PROTO ((rtx, int));\n static char *safe_concat PROTO ((char *, char *, const char *));\n static int insn_issue_delay PROTO ((rtx));\n static int birthing_insn_p PROTO ((rtx));\n@@ -7775,683 +7772,6 @@ schedule_region (rgn)\n   FREE_REG_SET (reg_pending_clobbers);\n }\n \n-/* Subroutine of update_flow_info.  Determines whether any new REG_NOTEs are\n-   needed for the hard register mentioned in the note.  This can happen\n-   if the reference to the hard register in the original insn was split into\n-   several smaller hard register references in the split insns.  */\n-\n-static void\n-split_hard_reg_notes (note, first, last)\n-     rtx note, first, last;\n-{\n-  rtx reg, temp, link;\n-  int n_regs, i, new_reg;\n-  rtx insn;\n-\n-  /* Assume that this is a REG_DEAD note.  */\n-  if (REG_NOTE_KIND (note) != REG_DEAD)\n-    abort ();\n-\n-  reg = XEXP (note, 0);\n-\n-  n_regs = HARD_REGNO_NREGS (REGNO (reg), GET_MODE (reg));\n-\n-  for (i = 0; i < n_regs; i++)\n-    {\n-      new_reg = REGNO (reg) + i;\n-\n-      /* Check for references to new_reg in the split insns.  */\n-      for (insn = last;; insn = PREV_INSN (insn))\n-\t{\n-\t  if (GET_RTX_CLASS (GET_CODE (insn)) == 'i'\n-\t      && (temp = regno_use_in (new_reg, PATTERN (insn))))\n-\t    {\n-\t      /* Create a new reg dead note ere.  */\n-\t      link = alloc_EXPR_LIST (REG_DEAD, temp, REG_NOTES (insn));\n-\t      REG_NOTES (insn) = link;\n-\n-\t      /* If killed multiple registers here, then add in the excess.  */\n-\t      i += HARD_REGNO_NREGS (REGNO (temp), GET_MODE (temp)) - 1;\n-\n-\t      break;\n-\t    }\n-\t  /* It isn't mentioned anywhere, so no new reg note is needed for\n-\t     this register.  */\n-\t  if (insn == first)\n-\t    break;\n-\t}\n-    }\n-}\n-\n-/* Subroutine of update_flow_info.  Determines whether a SET or CLOBBER in an\n-   insn created by splitting needs a REG_DEAD or REG_UNUSED note added.  */\n-\n-static void\n-new_insn_dead_notes (pat, insn, last, orig_insn)\n-     rtx pat, insn, last, orig_insn;\n-{\n-  rtx dest, tem, set;\n-\n-  /* PAT is either a CLOBBER or a SET here.  */\n-  dest = XEXP (pat, 0);\n-\n-  while (GET_CODE (dest) == ZERO_EXTRACT || GET_CODE (dest) == SUBREG\n-\t || GET_CODE (dest) == STRICT_LOW_PART\n-\t || GET_CODE (dest) == SIGN_EXTRACT)\n-    dest = XEXP (dest, 0);\n-\n-  if (GET_CODE (dest) == REG)\n-    {\n-      /* If the original insn already used this register, we may not add new\n-         notes for it.  One example for a split that needs this test is\n-\t when a multi-word memory access with register-indirect addressing\n-\t is split into multiple memory accesses with auto-increment and\n-\t one adjusting add instruction for the address register.  */\n-      if (reg_referenced_p (dest, PATTERN (orig_insn)))\n-\treturn;\n-      for (tem = last; tem != insn; tem = PREV_INSN (tem))\n-\t{\n-\t  if (GET_RTX_CLASS (GET_CODE (tem)) == 'i'\n-\t      && reg_overlap_mentioned_p (dest, PATTERN (tem))\n-\t      && (set = single_set (tem)))\n-\t    {\n-\t      rtx tem_dest = SET_DEST (set);\n-\n-\t      while (GET_CODE (tem_dest) == ZERO_EXTRACT\n-\t\t     || GET_CODE (tem_dest) == SUBREG\n-\t\t     || GET_CODE (tem_dest) == STRICT_LOW_PART\n-\t\t     || GET_CODE (tem_dest) == SIGN_EXTRACT)\n-\t\ttem_dest = XEXP (tem_dest, 0);\n-\n-\t      if (!rtx_equal_p (tem_dest, dest))\n-\t\t{\n-\t\t  /* Use the same scheme as combine.c, don't put both REG_DEAD\n-\t\t     and REG_UNUSED notes on the same insn.  */\n-\t\t  if (!find_regno_note (tem, REG_UNUSED, REGNO (dest))\n-\t\t      && !find_regno_note (tem, REG_DEAD, REGNO (dest)))\n-\t\t    {\n-\t\t      rtx note = alloc_EXPR_LIST (REG_DEAD, dest,\n-\t\t\t\t\t\t  REG_NOTES (tem));\n-\t\t      REG_NOTES (tem) = note;\n-\t\t    }\n-\t\t  /* The reg only dies in one insn, the last one that uses\n-\t\t     it.  */\n-\t\t  break;\n-\t\t}\n-\t      else if (reg_overlap_mentioned_p (dest, SET_SRC (set)))\n-\t\t/* We found an instruction that both uses the register,\n-\t\t   and sets it, so no new REG_NOTE is needed for this set.  */\n-\t\tbreak;\n-\t    }\n-\t}\n-      /* If this is a set, it must die somewhere, unless it is the dest of\n-         the original insn, and hence is live after the original insn.  Abort\n-         if it isn't supposed to be live after the original insn.\n-\n-         If this is a clobber, then just add a REG_UNUSED note.  */\n-      if (tem == insn)\n-\t{\n-\t  int live_after_orig_insn = 0;\n-\t  rtx pattern = PATTERN (orig_insn);\n-\t  int i;\n-\n-\t  if (GET_CODE (pat) == CLOBBER)\n-\t    {\n-\t      rtx note = alloc_EXPR_LIST (REG_UNUSED, dest, REG_NOTES (insn));\n-\t      REG_NOTES (insn) = note;\n-\t      return;\n-\t    }\n-\n-\t  /* The original insn could have multiple sets, so search the\n-\t     insn for all sets.  */\n-\t  if (GET_CODE (pattern) == SET)\n-\t    {\n-\t      if (reg_overlap_mentioned_p (dest, SET_DEST (pattern)))\n-\t\tlive_after_orig_insn = 1;\n-\t    }\n-\t  else if (GET_CODE (pattern) == PARALLEL)\n-\t    {\n-\t      for (i = 0; i < XVECLEN (pattern, 0); i++)\n-\t\tif (GET_CODE (XVECEXP (pattern, 0, i)) == SET\n-\t\t    && reg_overlap_mentioned_p (dest,\n-\t\t\t\t\t\tSET_DEST (XVECEXP (pattern,\n-\t\t\t\t\t\t\t\t   0, i))))\n-\t\t  live_after_orig_insn = 1;\n-\t    }\n-\n-\t  if (!live_after_orig_insn)\n-\t    abort ();\n-\t}\n-    }\n-}\n-\n-/* Subroutine of update_flow_info.  Update the value of reg_n_sets for all\n-   registers modified by X.  INC is -1 if the containing insn is being deleted,\n-   and is 1 if the containing insn is a newly generated insn.  */\n-\n-static void\n-update_n_sets (x, inc)\n-     rtx x;\n-     int inc;\n-{\n-  rtx dest = SET_DEST (x);\n-\n-  while (GET_CODE (dest) == STRICT_LOW_PART || GET_CODE (dest) == SUBREG\n-      || GET_CODE (dest) == ZERO_EXTRACT || GET_CODE (dest) == SIGN_EXTRACT)\n-    dest = SUBREG_REG (dest);\n-\n-  if (GET_CODE (dest) == REG)\n-    {\n-      int regno = REGNO (dest);\n-\n-      if (regno < FIRST_PSEUDO_REGISTER)\n-\t{\n-\t  register int i;\n-\t  int endregno = regno + HARD_REGNO_NREGS (regno, GET_MODE (dest));\n-\n-\t  for (i = regno; i < endregno; i++)\n-\t    REG_N_SETS (i) += inc;\n-\t}\n-      else\n-\tREG_N_SETS (regno) += inc;\n-    }\n-}\n-\n-/* Updates all flow-analysis related quantities (including REG_NOTES) for\n-   the insns from FIRST to LAST inclusive that were created by splitting\n-   ORIG_INSN.  NOTES are the original REG_NOTES.  */\n-\n-void\n-update_flow_info (notes, first, last, orig_insn)\n-     rtx notes;\n-     rtx first, last;\n-     rtx orig_insn;\n-{\n-  rtx insn, note;\n-  rtx next;\n-  rtx orig_dest, temp;\n-  rtx set;\n-\n-  /* Get and save the destination set by the original insn.  */\n-\n-  orig_dest = single_set (orig_insn);\n-  if (orig_dest)\n-    orig_dest = SET_DEST (orig_dest);\n-\n-  /* Move REG_NOTES from the original insn to where they now belong.  */\n-\n-  for (note = notes; note; note = next)\n-    {\n-      next = XEXP (note, 1);\n-      switch (REG_NOTE_KIND (note))\n-\t{\n-\tcase REG_DEAD:\n-\tcase REG_UNUSED:\n-\t  /* Move these notes from the original insn to the last new insn where\n-\t     the register is now set.  */\n-\n-\t  for (insn = last;; insn = PREV_INSN (insn))\n-\t    {\n-\t      if (GET_RTX_CLASS (GET_CODE (insn)) == 'i'\n-\t\t  && reg_mentioned_p (XEXP (note, 0), PATTERN (insn)))\n-\t\t{\n-\t\t  /* If this note refers to a multiple word hard register, it\n-\t\t     may have been split into several smaller hard register\n-\t\t     references, so handle it specially.  */\n-\t\t  temp = XEXP (note, 0);\n-\t\t  if (REG_NOTE_KIND (note) == REG_DEAD\n-\t\t      && GET_CODE (temp) == REG\n-\t\t      && REGNO (temp) < FIRST_PSEUDO_REGISTER\n-\t\t      && HARD_REGNO_NREGS (REGNO (temp), GET_MODE (temp)) > 1)\n-\t\t    split_hard_reg_notes (note, first, last);\n-\t\t  else\n-\t\t    {\n-\t\t      XEXP (note, 1) = REG_NOTES (insn);\n-\t\t      REG_NOTES (insn) = note;\n-\t\t    }\n-\n-\t\t  /* Sometimes need to convert REG_UNUSED notes to REG_DEAD\n-\t\t     notes.  */\n-\t\t  /* ??? This won't handle multiple word registers correctly,\n-\t\t     but should be good enough for now.  */\n-\t\t  if (REG_NOTE_KIND (note) == REG_UNUSED\n-\t\t      && GET_CODE (XEXP (note, 0)) != SCRATCH\n-\t\t      && !dead_or_set_p (insn, XEXP (note, 0)))\n-\t\t    PUT_REG_NOTE_KIND (note, REG_DEAD);\n-\n-\t\t  /* The reg only dies in one insn, the last one that uses\n-\t\t     it.  */\n-\t\t  break;\n-\t\t}\n-\t      /* It must die somewhere, fail it we couldn't find where it died.\n-\n-\t         If this is a REG_UNUSED note, then it must be a temporary\n-\t         register that was not needed by this instantiation of the\n-\t         pattern, so we can safely ignore it.  */\n-\t      if (insn == first)\n-\t\t{\t\t\t\n-\t\t  if (REG_NOTE_KIND (note) != REG_UNUSED)\n-\t\t    abort ();\n-\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t  break;\n-\n-\tcase REG_WAS_0:\n-\t  /* If the insn that set the register to 0 was deleted, this\n-\t     note cannot be relied on any longer.  The destination might\n-\t     even have been moved to memory.\n-             This was observed for SH4 with execute/920501-6.c compilation,\n-\t     -O2 -fomit-frame-pointer -finline-functions .  */\n-\t  if (GET_CODE (XEXP (note, 0)) == NOTE\n-\t      || INSN_DELETED_P (XEXP (note, 0)))\n-\t    break;\n-\t  /* This note applies to the dest of the original insn.  Find the\n-\t     first new insn that now has the same dest, and move the note\n-\t     there.  */\n-\n-\t  if (!orig_dest)\n-\t    abort ();\n-\n-\t  for (insn = first;; insn = NEXT_INSN (insn))\n-\t    {\n-\t      if (GET_RTX_CLASS (GET_CODE (insn)) == 'i'\n-\t\t  && (temp = single_set (insn))\n-\t\t  && rtx_equal_p (SET_DEST (temp), orig_dest))\n-\t\t{\n-\t\t  XEXP (note, 1) = REG_NOTES (insn);\n-\t\t  REG_NOTES (insn) = note;\n-\t\t  /* The reg is only zero before one insn, the first that\n-\t\t     uses it.  */\n-\t\t  break;\n-\t\t}\n-\t      /* If this note refers to a multiple word hard\n-\t\t register, it may have been split into several smaller\n-\t\t hard register references.  We could split the notes,\n-\t\t but simply dropping them is good enough.  */\n-\t      if (GET_CODE (orig_dest) == REG\n-\t\t  && REGNO (orig_dest) < FIRST_PSEUDO_REGISTER\n-\t\t  && HARD_REGNO_NREGS (REGNO (orig_dest),\n-\t\t\t\t       GET_MODE (orig_dest)) > 1)\n-\t\t    break;\n-\t      /* It must be set somewhere, fail if we couldn't find where it\n-\t         was set.  */\n-\t      if (insn == last)\n-\t\tabort ();\n-\t    }\n-\t  break;\n-\n-\tcase REG_EQUAL:\n-\tcase REG_EQUIV:\n-\t  /* A REG_EQUIV or REG_EQUAL note on an insn with more than one\n-\t     set is meaningless.  Just drop the note.  */\n-\t  if (!orig_dest)\n-\t    break;\n-\n-\tcase REG_NO_CONFLICT:\n-\t  /* These notes apply to the dest of the original insn.  Find the last\n-\t     new insn that now has the same dest, and move the note there.  */\n-\n-\t  if (!orig_dest)\n-\t    abort ();\n-\n-\t  for (insn = last;; insn = PREV_INSN (insn))\n-\t    {\n-\t      if (GET_RTX_CLASS (GET_CODE (insn)) == 'i'\n-\t\t  && (temp = single_set (insn))\n-\t\t  && rtx_equal_p (SET_DEST (temp), orig_dest))\n-\t\t{\n-\t\t  XEXP (note, 1) = REG_NOTES (insn);\n-\t\t  REG_NOTES (insn) = note;\n-\t\t  /* Only put this note on one of the new insns.  */\n-\t\t  break;\n-\t\t}\n-\n-\t      /* The original dest must still be set someplace.  Abort if we\n-\t         couldn't find it.  */\n-\t      if (insn == first)\n-\t\t{\n-\t\t  /* However, if this note refers to a multiple word hard\n-\t\t     register, it may have been split into several smaller\n-\t\t     hard register references.  We could split the notes,\n-\t\t     but simply dropping them is good enough.  */\n-\t\t  if (GET_CODE (orig_dest) == REG\n-\t\t      && REGNO (orig_dest) < FIRST_PSEUDO_REGISTER\n-\t\t      && HARD_REGNO_NREGS (REGNO (orig_dest),\n-\t\t\t\t\t   GET_MODE (orig_dest)) > 1)\n-\t\t    break;\n-\t\t  /* Likewise for multi-word memory references.  */\n-\t\t  if (GET_CODE (orig_dest) == MEM\n-\t\t      && SIZE_FOR_MODE (orig_dest) > UNITS_PER_WORD)\n-\t\t    break;\n-\t\t  abort ();\n-\t\t}\n-\t    }\n-\t  break;\n-\n-\tcase REG_LIBCALL:\n-\t  /* Move a REG_LIBCALL note to the first insn created, and update\n-\t     the corresponding REG_RETVAL note.  */\n-\t  XEXP (note, 1) = REG_NOTES (first);\n-\t  REG_NOTES (first) = note;\n-\n-\t  insn = XEXP (note, 0);\n-\t  note = find_reg_note (insn, REG_RETVAL, NULL_RTX);\n-\t  if (note)\n-\t    XEXP (note, 0) = first;\n-\t  break;\n-\n-\tcase REG_EXEC_COUNT:\n-\t  /* Move a REG_EXEC_COUNT note to the first insn created.  */\n-\t  XEXP (note, 1) = REG_NOTES (first);\n-\t  REG_NOTES (first) = note;\n-\t  break;\n-\n-\tcase REG_RETVAL:\n-\t  /* Move a REG_RETVAL note to the last insn created, and update\n-\t     the corresponding REG_LIBCALL note.  */\n-\t  XEXP (note, 1) = REG_NOTES (last);\n-\t  REG_NOTES (last) = note;\n-\n-\t  insn = XEXP (note, 0);\n-\t  note = find_reg_note (insn, REG_LIBCALL, NULL_RTX);\n-\t  if (note)\n-\t    XEXP (note, 0) = last;\n-\t  break;\n-\n-\tcase REG_NONNEG:\n-\tcase REG_BR_PROB:\n-\t  /* This should be moved to whichever instruction is a JUMP_INSN.  */\n-\n-\t  for (insn = last;; insn = PREV_INSN (insn))\n-\t    {\n-\t      if (GET_CODE (insn) == JUMP_INSN)\n-\t\t{\n-\t\t  XEXP (note, 1) = REG_NOTES (insn);\n-\t\t  REG_NOTES (insn) = note;\n-\t\t  /* Only put this note on one of the new insns.  */\n-\t\t  break;\n-\t\t}\n-\t      /* Fail if we couldn't find a JUMP_INSN.  */\n-\t      if (insn == first)\n-\t\tabort ();\n-\t    }\n-\t  break;\n-\n-\tcase REG_INC:\n-\t  /* reload sometimes leaves obsolete REG_INC notes around.  */\n-\t  if (reload_completed)\n-\t    break;\n-\t  /* This should be moved to whichever instruction now has the\n-\t     increment operation.  */\n-\t  abort ();\n-\n-\tcase REG_LABEL:\n-\t  /* Should be moved to the new insn(s) which use the label.  */\n-\t  for (insn = first; insn != NEXT_INSN (last); insn = NEXT_INSN (insn))\n-\t    if (GET_RTX_CLASS (GET_CODE (insn)) == 'i'\n-\t\t&& reg_mentioned_p (XEXP (note, 0), PATTERN (insn)))\n-\t      {\n-\t        REG_NOTES (insn) = alloc_EXPR_LIST (REG_LABEL,\n-\t\t\t\t\t\t    XEXP (note, 0),\n-\t\t\t\t\t\t    REG_NOTES (insn));\n-\t      }\n-\t  break;\n-\n-\tcase REG_CC_SETTER:\n-\tcase REG_CC_USER:\n-\t  /* These two notes will never appear until after reorg, so we don't\n-\t     have to handle them here.  */\n-\tdefault:\n-\t  abort ();\n-\t}\n-    }\n-\n-  /* Each new insn created, except the last, has a new set.  If the destination\n-     is a register, then this reg is now live across several insns, whereas\n-     previously the dest reg was born and died within the same insn.  To\n-     reflect this, we now need a REG_DEAD note on the insn where this\n-     dest reg dies.\n-\n-     Similarly, the new insns may have clobbers that need REG_UNUSED notes.  */\n-\n-  for (insn = first; insn != last; insn = NEXT_INSN (insn))\n-    {\n-      rtx pat;\n-      int i;\n-\n-      pat = PATTERN (insn);\n-      if (GET_CODE (pat) == SET || GET_CODE (pat) == CLOBBER)\n-\tnew_insn_dead_notes (pat, insn, last, orig_insn);\n-      else if (GET_CODE (pat) == PARALLEL)\n-\t{\n-\t  for (i = 0; i < XVECLEN (pat, 0); i++)\n-\t    if (GET_CODE (XVECEXP (pat, 0, i)) == SET\n-\t\t|| GET_CODE (XVECEXP (pat, 0, i)) == CLOBBER)\n-\t      new_insn_dead_notes (XVECEXP (pat, 0, i), insn, last, orig_insn);\n-\t}\n-    }\n-\n-  /* If any insn, except the last, uses the register set by the last insn,\n-     then we need a new REG_DEAD note on that insn.  In this case, there\n-     would not have been a REG_DEAD note for this register in the original\n-     insn because it was used and set within one insn.  */\n-\n-  set = single_set (last);\n-  if (set)\n-    {\n-      rtx dest = SET_DEST (set);\n-\n-      while (GET_CODE (dest) == ZERO_EXTRACT || GET_CODE (dest) == SUBREG\n-\t     || GET_CODE (dest) == STRICT_LOW_PART\n-\t     || GET_CODE (dest) == SIGN_EXTRACT)\n-\tdest = XEXP (dest, 0);\n-\n-      if (GET_CODE (dest) == REG\n-\t  /* Global registers are always live, so the code below does not\n-\t     apply to them.  */\n-\t  && (REGNO (dest) >= FIRST_PSEUDO_REGISTER\n-\t      || ! global_regs[REGNO (dest)]))\n-\t{\n-\t  rtx stop_insn = PREV_INSN (first);\n-\n-\t  /* If the last insn uses the register that it is setting, then\n-\t     we don't want to put a REG_DEAD note there.  Search backwards\n-\t     to find the first insn that sets but does not use DEST.  */\n-\n-\t  insn = last;\n-\t  if (reg_overlap_mentioned_p (dest, SET_SRC (set)))\n-\t    {\n-\t      for (insn = PREV_INSN (insn); insn != first;\n-\t\t   insn = PREV_INSN (insn))\n-\t\t{\n-\t\t  if ((set = single_set (insn))\n-\t\t      && reg_mentioned_p (dest, SET_DEST (set))\n-\t\t      && ! reg_overlap_mentioned_p (dest, SET_SRC (set)))\n-\t\t    break;\n-\t\t}\n-\t    }\n-\n-\t  /* Now find the first insn that uses but does not set DEST.  */\n-\n-\t  for (insn = PREV_INSN (insn); insn != stop_insn;\n-\t       insn = PREV_INSN (insn))\n-\t    {\n-\t      if (GET_RTX_CLASS (GET_CODE (insn)) == 'i'\n-\t\t  && reg_mentioned_p (dest, PATTERN (insn))\n-\t\t  && (set = single_set (insn)))\n-\t\t{\n-\t\t  rtx insn_dest = SET_DEST (set);\n-\n-\t\t  while (GET_CODE (insn_dest) == ZERO_EXTRACT\n-\t\t\t || GET_CODE (insn_dest) == SUBREG\n-\t\t\t || GET_CODE (insn_dest) == STRICT_LOW_PART\n-\t\t\t || GET_CODE (insn_dest) == SIGN_EXTRACT)\n-\t\t    insn_dest = XEXP (insn_dest, 0);\n-\n-\t\t  if (insn_dest != dest)\n-\t\t    {\n-\t\t      note = alloc_EXPR_LIST (REG_DEAD, dest, REG_NOTES (insn));\n-\t\t      REG_NOTES (insn) = note;\n-\t\t      /* The reg only dies in one insn, the last one\n-\t\t\t that uses it.  */\n-\t\t      break;\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n-    }\n-\n-  /* If the original dest is modifying a multiple register target, and the\n-     original instruction was split such that the original dest is now set\n-     by two or more SUBREG sets, then the split insns no longer kill the\n-     destination of the original insn.\n-\n-     In this case, if there exists an instruction in the same basic block,\n-     before the split insn, which uses the original dest, and this use is\n-     killed by the original insn, then we must remove the REG_DEAD note on\n-     this insn, because it is now superfluous.\n-\n-     This does not apply when a hard register gets split, because the code\n-     knows how to handle overlapping hard registers properly.  */\n-  if (orig_dest && GET_CODE (orig_dest) == REG)\n-    {\n-      int found_orig_dest = 0;\n-      int found_split_dest = 0;\n-\n-      for (insn = first;; insn = NEXT_INSN (insn))\n-\t{\n-\t  rtx pat;\n-\t  int i;\n-\n-\t  /* I'm not sure if this can happen, but let's be safe.  */\n-\t  if (GET_RTX_CLASS (GET_CODE (insn)) != 'i')\n-\t    continue;\n-\n-\t  pat = PATTERN (insn);\n-\t  i = GET_CODE (pat) == PARALLEL ? XVECLEN (pat, 0) : 0;\n-\t  set = pat;\n-\n-\t  for (;;)\n-\t    {\n-\t      if (GET_CODE (set) == SET)\n-\t\t{\n-\t\t  if (GET_CODE (SET_DEST (set)) == REG\n-\t\t      && REGNO (SET_DEST (set)) == REGNO (orig_dest))\n-\t\t    {\n-\t\t      found_orig_dest = 1;\n-\t\t      break;\n-\t\t    }\n-\t\t  else if (GET_CODE (SET_DEST (set)) == SUBREG\n-\t\t\t   && SUBREG_REG (SET_DEST (set)) == orig_dest)\n-\t\t    {\n-\t\t      found_split_dest = 1;\n-\t\t      break;\n-\t\t    }\n-\t\t}\n-\t      if (--i < 0)\n-\t\tbreak;\n-\t      set = XVECEXP (pat, 0, i);\n-\t    }\n-\n-\t  if (insn == last)\n-\t    break;\n-\t}\n-\n-      if (found_split_dest)\n-\t{\n-\t  /* Search backwards from FIRST, looking for the first insn that uses\n-\t     the original dest.  Stop if we pass a CODE_LABEL or a JUMP_INSN.\n-\t     If we find an insn, and it has a REG_DEAD note, then delete the\n-\t     note.  */\n-\n-\t  for (insn = first; insn; insn = PREV_INSN (insn))\n-\t    {\n-\t      if (GET_CODE (insn) == CODE_LABEL\n-\t\t  || GET_CODE (insn) == JUMP_INSN)\n-\t\tbreak;\n-\t      else if (GET_RTX_CLASS (GET_CODE (insn)) == 'i'\n-\t\t       && reg_mentioned_p (orig_dest, insn))\n-\t\t{\n-\t\t  note = find_regno_note (insn, REG_DEAD, REGNO (orig_dest));\n-\t\t  if (note)\n-\t\t    remove_note (insn, note);\n-\t\t}\n-\t    }\n-\t}\n-      else if (!found_orig_dest)\n-\t{\n-\t  int i, regno;\n-\n-\t  /* Should never reach here for a pseudo reg.  */\n-\t  if (REGNO (orig_dest) >= FIRST_PSEUDO_REGISTER)\n-\t    abort ();\n-\n-\t  /* This can happen for a hard register, if the splitter\n-\t     does not bother to emit instructions which would be no-ops.\n-\t     We try to verify that this is the case by checking to see if\n-\t     the original instruction uses all of the registers that it\n-\t     set.  This case is OK, because deleting a no-op can not affect\n-\t     REG_DEAD notes on other insns.  If this is not the case, then\n-\t     abort.  */\n-\t  \n-\t  regno = REGNO (orig_dest);\n-\t  for (i = HARD_REGNO_NREGS (regno, GET_MODE (orig_dest)) - 1;\n-\t       i >= 0; i--)\n-\t    if (! refers_to_regno_p (regno + i, regno + i + 1, orig_insn,\n-\t\t\t\t     NULL_PTR))\n-\t      break;\n-\t  if (i >= 0)\n-\t    abort ();\n-\t}\n-    }\n-\n-  /* Update reg_n_sets.  This is necessary to prevent local alloc from\n-     converting REG_EQUAL notes to REG_EQUIV when splitting has modified\n-     a reg from set once to set multiple times.  */\n-\n-  {\n-    rtx x = PATTERN (orig_insn);\n-    RTX_CODE code = GET_CODE (x);\n-\n-    if (code == SET || code == CLOBBER)\n-      update_n_sets (x, -1);\n-    else if (code == PARALLEL)\n-      {\n-\tint i;\n-\tfor (i = XVECLEN (x, 0) - 1; i >= 0; i--)\n-\t  {\n-\t    code = GET_CODE (XVECEXP (x, 0, i));\n-\t    if (code == SET || code == CLOBBER)\n-\t      update_n_sets (XVECEXP (x, 0, i), -1);\n-\t  }\n-      }\n-\n-    for (insn = first;; insn = NEXT_INSN (insn))\n-      {\n-\tx = PATTERN (insn);\n-\tcode = GET_CODE (x);\n-\n-\tif (code == SET || code == CLOBBER)\n-\t  update_n_sets (x, 1);\n-\telse if (code == PARALLEL)\n-\t  {\n-\t    int i;\n-\t    for (i = XVECLEN (x, 0) - 1; i >= 0; i--)\n-\t      {\n-\t\tcode = GET_CODE (XVECEXP (x, 0, i));\n-\t\tif (code == SET || code == CLOBBER)\n-\t\t  update_n_sets (XVECEXP (x, 0, i), 1);\n-\t      }\n-\t  }\n-\n-\tif (insn == last)\n-\t  break;\n-      }\n-  }\n-}\n-\n /* The one entry point in this file.  DUMP_FILE is the dump file for\n    this pass.  */\n "}, {"sha": "dd8e83438f36131d777a51762bd42857d3e372f8", "filename": "gcc/output.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2a1bc02679df06d8461df03f48ebaafe5e4307e/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2a1bc02679df06d8461df03f48ebaafe5e4307e/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=f2a1bc02679df06d8461df03f48ebaafe5e4307e", "patch": "@@ -132,6 +132,7 @@ extern void find_basic_blocks         PROTO((rtx, int, FILE *, int));\n extern void free_basic_block_vars     PROTO((int));\n extern void set_block_num             PROTO((rtx, int));\n extern void life_analysis             PROTO((rtx, int, FILE *, int));\n+extern void update_life_info\t        PROTO((rtx, rtx, rtx, rtx, rtx));\n #endif\n \n /* Functions in varasm.c.  */"}, {"sha": "f41c3d1895956069440f0e63e520d513b6ccca1f", "filename": "gcc/recog.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2a1bc02679df06d8461df03f48ebaafe5e4307e/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2a1bc02679df06d8461df03f48ebaafe5e4307e/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=f2a1bc02679df06d8461df03f48ebaafe5e4307e", "patch": "@@ -2669,7 +2669,7 @@ split_block_insns (b, do_split)\n \t      /* try_split returns the NOTE that INSN became.  */\n \t      first = NEXT_INSN (first);\n #ifdef INSN_SCHEDULING\n-\t      update_flow_info (notes, first, last, insn);\n+\t      update_life_info (notes, first, last, insn, insn);\n #endif\n \t      PUT_CODE (insn, NOTE);\n \t      NOTE_SOURCE_FILE (insn) = 0;"}, {"sha": "b310dd654d336cabe1e9208033111459e6202e34", "filename": "gcc/resource.c", "status": "modified", "additions": 48, "deletions": 8, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2a1bc02679df06d8461df03f48ebaafe5e4307e/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2a1bc02679df06d8461df03f48ebaafe5e4307e/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=f2a1bc02679df06d8461df03f48ebaafe5e4307e", "patch": "@@ -1264,27 +1264,67 @@ find_free_register (current_insn, class_str, mode, reg_set)\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     {\n-      int success = 1;\n+      int regno;\n+      int success;\n+\n+#ifdef REG_ALLOC_ORDER\n+      regno = reg_alloc_order [i];\n+#else\n+      regno = i;\n+#endif\n \n-      if (! TEST_HARD_REG_BIT (reg_class_contents[class], i))\n+      /* Don't allocate fixed registers.  */\n+      if (fixed_regs[regno])\n+\tcontinue;\n+      /* Make sure the register is of the right class.  */\n+      if (! TEST_HARD_REG_BIT (reg_class_contents[class], regno))\n+\tcontinue;\n+      /* And can support the mode we need.  */\n+      if (! HARD_REGNO_MODE_OK (regno, mode))\n \tcontinue;\n-      for (j = HARD_REGNO_NREGS (i, mode) - 1; j >= 0; j--)\n+      /* And that we don't create an extra save/restore.  */\n+      if (! call_used_regs[regno] && ! regs_ever_live[regno])\n+\tcontinue;\n+\n+      success = 1;\n+      for (j = HARD_REGNO_NREGS (regno, mode) - 1; j >= 0; j--)\n \t{\n-\t  if (TEST_HARD_REG_BIT (*reg_set, i + j)\n-\t      || TEST_HARD_REG_BIT (used.regs, i + j))\n+\t  if (TEST_HARD_REG_BIT (*reg_set, regno + j)\n+\t      || TEST_HARD_REG_BIT (used.regs, regno + j))\n \t    {\n \t      success = 0;\n \t      break;\n \t    }\n \t}\n       if (success)\n \t{\n-\t  for (j = HARD_REGNO_NREGS (i, mode) - 1; j >= 0; j--)\n+\t  for (j = HARD_REGNO_NREGS (regno, mode) - 1; j >= 0; j--)\n \t    {\n-\t      SET_HARD_REG_BIT (*reg_set, i + j);\n+\t      SET_HARD_REG_BIT (*reg_set, regno + j);\n \t    }\n-\t  return gen_rtx_REG (mode, i);\n+\t  return gen_rtx_REG (mode, regno);\n \t}\n     }\n   return NULL_RTX;\n }\n+\n+/* Return true if REG is dead at CURRENT_INSN.  */\n+\n+int\n+reg_dead_p (current_insn, reg)\n+     rtx current_insn, reg;\n+{\n+  struct resources used;\n+  int regno, j;\n+\n+  mark_target_live_regs (get_insns (), current_insn, &used);\n+  \n+  regno = REGNO (reg);\n+  for (j = HARD_REGNO_NREGS (regno, GET_MODE (reg)) - 1; j >= 0; j--)\n+    {\n+      if (TEST_HARD_REG_BIT (used.regs, regno + j))\n+\treturn 0;\n+    }\n+\n+  return 1;\n+}"}, {"sha": "40a3125342f7eacdd3b9d0b887687b37d622a84b", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2a1bc02679df06d8461df03f48ebaafe5e4307e/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2a1bc02679df06d8461df03f48ebaafe5e4307e/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=f2a1bc02679df06d8461df03f48ebaafe5e4307e", "patch": "@@ -1412,6 +1412,7 @@ extern void recompute_reg_usage\t\tPROTO ((rtx, int));\n extern void dump_flow_info\t\tPROTO ((FILE *));\n #endif\n extern void free_bb_mem\t\t\tPROTO ((void));\n+extern void replace_insns               PROTO ((rtx, rtx, rtx, rtx));\n \n /* In expmed.c */\n extern void init_expmed\t\t\tPROTO ((void));"}]}