{"sha": "46e89251c471b2780ba0831b26c90995f52408a9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDZlODkyNTFjNDcxYjI3ODBiYTA4MzFiMjZjOTA5OTVmNTI0MDhhOQ==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2016-11-23T19:05:53Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2016-11-23T19:05:53Z"}, "message": "i386.md (*movqi_internal): Calculate mode attribute of alternatives 7,8,9 depending on TARGET_AVX512DQ.\n\n\t* gcc.target/config/i386.md (*movqi_internal): Calculate mode\n\tattribute of alternatives 7,8,9 depending on TARGET_AVX512DQ.\n\t<TYPE_MSKMOV>: Emit kmovw for MODE_HI insn mode attribute.\n\t(*k<logic><mode>): Calculate mode attribute depending on\n\tTARGET_AVX512DQ.  Emit k<logic>w for MODE_HI insn mode attribute.\n\t(*andqi_1): Calculate mode attribute of alternative 3 depending\n\ton TARGET_AVX512DQ.  Emit kandw for MODE_HI insn mode attribute.\n\t(kandn<mode>): Calculate mode attribute of alternative 2 depending\n\ton TARGET_AVX512DQ.  Emit kandnw for MODE_HI insn mode attribute.\n\t(kxnor<mode>): Merge insn patterns using SWI1248_AVX512BW mode\n\titerator.  Calculate mode attribute of alternative 1 depending\n\ton TARGET_AVX512DQ.  Emit kxnorw for MODE_HI insn mode attribute.\n\t(*one_cmplqi2_1): Calculate mode attribute of alternative 2 depending\n\ton TARGET_AVX512DQ.  Emit knotw for MODE_HI insn mode attribute.\n\nFrom-SVN: r242791", "tree": {"sha": "55befb1886aa972e07308684ea362d5c1b791832", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/55befb1886aa972e07308684ea362d5c1b791832"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/46e89251c471b2780ba0831b26c90995f52408a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46e89251c471b2780ba0831b26c90995f52408a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46e89251c471b2780ba0831b26c90995f52408a9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46e89251c471b2780ba0831b26c90995f52408a9/comments", "author": null, "committer": null, "parents": [{"sha": "25cb6b33f75fb4183bfe816cf95b68613b1af4bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25cb6b33f75fb4183bfe816cf95b68613b1af4bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25cb6b33f75fb4183bfe816cf95b68613b1af4bb"}], "stats": {"total": 230, "additions": 145, "deletions": 85}, "files": [{"sha": "a62f37895b7981e2f1ac1d74af6a4dff828441f3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 11, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46e89251c471b2780ba0831b26c90995f52408a9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46e89251c471b2780ba0831b26c90995f52408a9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=46e89251c471b2780ba0831b26c90995f52408a9", "patch": "@@ -1,3 +1,20 @@\n+2016-11-23  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* gcc.target/config/i386.md (*movqi_internal): Calculate mode\n+\tattribute of alternatives 7,8,9 depending on TARGET_AVX512DQ.\n+\t<TYPE_MSKMOV>: Emit kmovw for MODE_HI insn mode attribute.\n+\t(*k<logic><mode>): Calculate mode attribute depending on\n+\tTARGET_AVX512DQ.  Emit k<logic>w for MODE_HI insn mode attribute.\n+\t(*andqi_1): Calculate mode attribute of alternative 3 depending\n+\ton TARGET_AVX512DQ.  Emit kandw for MODE_HI insn mode attribute.\n+\t(kandn<mode>): Calculate mode attribute of alternative 2 depending\n+\ton TARGET_AVX512DQ.  Emit kandnw for MODE_HI insn mode attribute.\n+\t(kxnor<mode>): Merge insn patterns using SWI1248_AVX512BW mode\n+\titerator.  Calculate mode attribute of alternative 1 depending\n+\ton TARGET_AVX512DQ.  Emit kxnorw for MODE_HI insn mode attribute.\n+\t(*one_cmplqi2_1): Calculate mode attribute of alternative 2 depending\n+\ton TARGET_AVX512DQ.  Emit knotw for MODE_HI insn mode attribute.\n+\n 2016-11-23  Prathamesh Kulkarni  <prathamesh.kulkarni@linaro.org>\n \n \tPR middle-end/78153\n@@ -159,8 +176,8 @@\n \t(grid_call_permissible_in_distribute_p): Likewise.\n \t(grid_handle_call_in_distribute): Likewise.\n \t(grid_dist_follows_tiling_pattern): Likewise.\n-\t(grid_target_follows_gridifiable_pattern): Support standalone distribute\n-\tconstructs.\n+\t(grid_target_follows_gridifiable_pattern): Support standalone\n+\tdistribute constructs.\n \t(grid_var_segment): New enum.\n \t(grid_mark_variable_segment): New function.\n \t(grid_copy_leading_local_assignments): Call grid_mark_variable_segment\n@@ -221,7 +238,7 @@\n \t(get_in_type): Return this if it is a register of\n \tmatching size.\n \t(hsa_get_declaration_name): Moved to...\n-        * hsa-gen.c (hsa_get_declaration_name): ...here.  Allocate\n+\t* hsa-gen.c (hsa_get_declaration_name): ...here.  Allocate\n \ttemporary string on an obstack instead from ggc.\n \t(query_hsa_grid): Renamed to query_hsa_grid_dim, reimplemented, cut\n \tdown to two overloads.\n@@ -450,15 +467,14 @@\n \t(predicate_scalar_phi): Call fold_stmt using the new valueize func.\n \n 2016-11-23  Martin Liska  <mliska@suse.cz>\n-            Martin Jambor  <mjambor@suse.cz>\n+\t    Martin Jambor  <mjambor@suse.cz>\n \n \t* doc/install.texi: Remove entry about --with-hsa-kmt-lib.\n \n 2016-11-23  Aldy Hernandez  <aldyh@redhat.com>\n \n \tPR target/78213\n-\t* opts.c (finish_options): Set -fsyntax-only if running self\n-\ttests.\n+\t* opts.c (finish_options): Set -fsyntax-only if running self tests.\n \n 2016-11-23  Richard Biener  <rguenther@suse.de>\n \n@@ -537,13 +553,14 @@\n \tior and xor operators.\n \t* config/aarch64/constraints.md (UsO constraint): New SImode constraint\n \tfor constants in \"and\" operantions.\n-\t(UsP constraint): New DImode constraint for constants in \"and\" operations.\n+\t(UsP constraint): New DImode constraint for constants\n+\tin \"and\" operations.\n \t* config/aarch64/iterators.md (lconst2): New mode iterator.\n \t(LOGICAL2): New code iterator.\n \t* config/aarch64/predicates.md (aarch64_logical_and_immediate): New\n-\tpredicate\n-\t(aarch64_logical_and_operand): New predicate allowing extended constants\n-\tfor \"and\" operations.\n+\tpredicate.\n+\t(aarch64_logical_and_operand): New predicate allowing extended\n+\tconstants for \"and\" operations.\n \n 2016-11-22  Walter Lee  <walt@tilera.com>\n \n@@ -635,7 +652,7 @@\n \t* sel-sched-ir.h: Remove trailing blank lines.\n \n 2016-11-22  Jakub Jelinek  <jakub@redhat.com>\n-            Alexander Monakov  <amonakov@ispras.ru>\n+\t    Alexander Monakov  <amonakov@ispras.ru>\n \n \t* internal-fn.c (expand_GOMP_USE_SIMT): New function.\n \t* tree.c (omp_clause_num_ops): OMP_CLAUSE__SIMT_ has 0 operands."}, {"sha": "3947df768eae9a9cd17385ea9bd5a8498af9af9b", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 117, "deletions": 74, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46e89251c471b2780ba0831b26c90995f52408a9/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46e89251c471b2780ba0831b26c90995f52408a9/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=46e89251c471b2780ba0831b26c90995f52408a9", "patch": "@@ -970,6 +970,11 @@\n (define_mode_iterator SWI1248_AVX512BWDQ\n   [(QI \"TARGET_AVX512DQ\") HI (SI \"TARGET_AVX512BW\") (DI \"TARGET_AVX512BW\")])\n \n+;; All integer modes with AVX512BW, where HImode operation\n+;; can be used instead of QImode.\n+(define_mode_iterator SWI1248_AVX512BW\n+  [QI HI (SI \"TARGET_AVX512BW\") (DI \"TARGET_AVX512BW\")])\n+\n ;; All integer modes without QImode.\n (define_mode_iterator SWI248x [HI SI DI])\n \n@@ -2170,9 +2175,9 @@\n \n (define_insn \"*movdi_internal\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\"\n-    \"=r  ,o  ,r,r  ,r,m ,*y,*y,?*y,?m,?r ,?*Ym,*v,*v,*v,m ,m,?r ,?r,?*Yi,?*Ym,?*Yi,*k,*k ,*r ,*m\")\n+    \"=r  ,o  ,r,r  ,r,m ,*y,*y,?*y,?m,?r ,?*Ym,*v,*v,*v,m ,m,?r ,?r,?*Yi,?*Ym,?*Yi,*k,*k ,*r,*m\")\n \t(match_operand:DI 1 \"general_operand\"\n-    \"riFo,riF,Z,rem,i,re,C ,*y,m  ,*y,*Yn,r   ,C ,*v,m ,*v,v,*Yj,*v,r   ,*Yj ,*Yn ,*r ,*km,*k,*k\"))]\n+    \"riFo,riF,Z,rem,i,re,C ,*y,m  ,*y,*Yn,r   ,C ,*v,m ,*v,v,*Yj,*v,r   ,*Yj ,*Yn ,*r,*km,*k,*k\"))]\n   \"!(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n {\n   switch (get_attr_type (insn))\n@@ -2489,17 +2494,16 @@\n \t(unspec:HI\n \t  [(match_operand:HI 1 \"nonimmediate_operand\" \"r,km\")]\n \t  UNSPEC_KMOV))]\n-  \"!(MEM_P (operands[0]) && MEM_P (operands[1])) && TARGET_AVX512F\"\n+  \"TARGET_AVX512F && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n   \"@\n    kmovw\\t{%k1, %0|%0, %k1}\n    kmovw\\t{%1, %0|%0, %1}\";\n-  [(set_attr \"mode\" \"HI\")\n-   (set_attr \"type\" \"mskmov\")\n-   (set_attr \"prefix\" \"vex\")])\n-\n+  [(set_attr \"type\" \"mskmov\")\n+   (set_attr \"prefix\" \"vex\")\n+   (set_attr \"mode\" \"HI\")])\n \n (define_insn \"*movhi_internal\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,r ,r ,m ,k,k, r,m\")\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,r ,r ,m ,k,k ,r,m\")\n \t(match_operand:HI 1 \"general_operand\"      \"r ,rn,rm,rn,r,km,k,k\"))]\n   \"!(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n {\n@@ -2512,19 +2516,23 @@\n \n     case TYPE_MSKMOV:\n       switch (which_alternative)\n-        {\n-\tcase 4: return \"kmovw\\t{%k1, %0|%0, %k1}\";\n-\tcase 5: /* FALLTHRU */\n-\tcase 7: return \"kmovw\\t{%1, %0|%0, %1}\";\n-\tcase 6: return \"kmovw\\t{%1, %k0|%k0, %1}\";\n-\tdefault: gcc_unreachable ();\n+\t{\n+\tcase 4:\n+\t  return \"kmovw\\t{%k1, %0|%0, %k1}\";\n+\tcase 6:\n+\t  return \"kmovw\\t{%1, %k0|%k0, %1}\";\n+\tcase 5:\n+\tcase 7:\n+\t  return \"kmovw\\t{%1, %0|%0, %1}\";\n+\tdefault:\n+\t  gcc_unreachable ();\n \t}\n \n     default:\n       if (get_attr_mode (insn) == MODE_SI)\n-        return \"mov{l}\\t{%k1, %k0|%k0, %k1}\";\n+\treturn \"mov{l}\\t{%k1, %k0|%k0, %k1}\";\n       else\n-        return \"mov{w}\\t{%1, %0|%0, %1}\";\n+\treturn \"mov{w}\\t{%1, %0|%0, %1}\";\n     }\n }\n   [(set (attr \"type\")\n@@ -2574,11 +2582,15 @@\n \n (define_insn \"*movqi_internal\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\"\n-\t\t\t\"=q,q ,q ,r,r ,?r,m ,k,k,r ,m,k\")\n+\t\t\t\"=q,q ,q ,r,r ,?r,m ,k,k,r,m,k\")\n \t(match_operand:QI 1 \"general_operand\"\n-\t\t\t\"q ,qn,qm,q,rn,qm,qn,r ,k,k,k,m\"))]\n+\t\t\t\"q ,qn,qm,q,rn,qm,qn,r,k,k,k,m\"))]\n   \"!(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n {\n+  static char buf[128];\n+  const char *ops;\n+  const char *suffix;\n+\n   switch (get_attr_type (insn))\n     {\n     case TYPE_IMOVX:\n@@ -2588,24 +2600,33 @@\n     case TYPE_MSKMOV:\n       switch (which_alternative)\n         {\n-\tcase 7: return TARGET_AVX512DQ ? \"kmovb\\t{%k1, %0|%0, %k1}\"\n-\t\t\t\t       : \"kmovw\\t{%k1, %0|%0, %k1}\";\n-\tcase 8: return TARGET_AVX512DQ ? \"kmovb\\t{%1, %0|%0, %1}\"\n-\t\t\t\t       : \"kmovw\\t{%1, %0|%0, %1}\";\n-\tcase 9: return TARGET_AVX512DQ ? \"kmovb\\t{%1, %k0|%k0, %1}\"\n-\t\t\t\t       : \"kmovw\\t{%1, %k0|%k0, %1}\";\n+\tcase 7:\n+\t  ops = \"kmov%s\\t{%%k1, %%0|%%0, %%k1}\";\n+\t  break;\n+\tcase 9:\n+\t  ops = \"kmov%s\\t{%%1, %%k0|%%k0, %%1}\";\n+\t  break;\n \tcase 10:\n \tcase 11:\n \t  gcc_assert (TARGET_AVX512DQ);\n-\t  return \"kmovb\\t{%1, %0|%0, %1}\";\n-\tdefault: gcc_unreachable ();\n+\t  /* FALLTHRU */\n+\tcase 8:\n+\t  ops = \"kmov%s\\t{%%1, %%0|%%0, %%1}\";\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n \t}\n \n+      suffix = (get_attr_mode (insn) == MODE_HI) ? \"w\" : \"b\";\n+\n+      snprintf (buf, sizeof (buf), ops, suffix);\n+      return buf;\n+\n     default:\n       if (get_attr_mode (insn) == MODE_SI)\n-        return \"mov{l}\\t{%k1, %k0|%k0, %k1}\";\n+\treturn \"mov{l}\\t{%k1, %k0|%k0, %k1}\";\n       else\n-        return \"mov{b}\\t{%1, %0|%0, %1}\";\n+\treturn \"mov{b}\\t{%1, %0|%0, %1}\";\n     }\n }\n   [(set (attr \"isa\")\n@@ -2640,6 +2661,9 @@\n \t       (const_string \"SI\")\n \t     (eq_attr \"alternative\" \"6\")\n \t       (const_string \"QI\")\n+\t     (and (eq_attr \"alternative\" \"7,8,9\")\n+\t\t  (not (match_test \"TARGET_AVX512DQ\")))\n+\t       (const_string \"HI\")\n \t     (eq_attr \"type\" \"imovx\")\n \t       (const_string \"SI\")\n \t     (and (eq_attr \"type\" \"imov\")\n@@ -3822,7 +3846,7 @@\n    kmov<mskmodesuffix>\\t{%1, %k0|%k0, %1}\"\n   [(set_attr \"isa\" \"*,<kmov_isa>\")\n    (set_attr \"type\" \"imovx,mskmov\")\n-   (set_attr \"mode\" \"SI\")])\n+   (set_attr \"mode\" \"SI,<MODE>\")])\n \n (define_expand \"zero_extend<mode>si2\"\n   [(set (match_operand:SI 0 \"register_operand\")\n@@ -3923,8 +3947,8 @@\n   \"@\n    movz{bl|x}\\t{%1, %k0|%k0, %1}\n    kmovb\\t{%1, %k0|%k0, %1}\"\n-  [(set_attr \"type\" \"imovx,mskmov\")\n-   (set_attr \"isa\" \"*,avx512dq\")\n+  [(set_attr \"isa\" \"*,avx512dq\")\n+   (set_attr \"type\" \"imovx,mskmov\")\n    (set_attr \"mode\" \"SI,QI\")])\n \n (define_insn_and_split \"*zext<mode>_doubleword_and\"\n@@ -8055,23 +8079,26 @@\n \t(any_logic:SWI1248x (match_dup 1)\n \t\t\t    (match_dup 2)))])\n \n-(define_mode_iterator SWI1248_AVX512BW\n-  [QI HI (SI \"TARGET_AVX512BW\") (DI \"TARGET_AVX512BW\")])\n-\n (define_insn \"*k<logic><mode>\"\n   [(set (match_operand:SWI1248_AVX512BW 0 \"mask_reg_operand\" \"=k\")\n-\t(any_logic:SWI1248_AVX512BW (match_operand:SWI1248_AVX512BW 1 \"mask_reg_operand\" \"k\")\n-\t\t\t\t    (match_operand:SWI1248_AVX512BW 2 \"mask_reg_operand\" \"k\")))]\n+\t(any_logic:SWI1248_AVX512BW\n+\t  (match_operand:SWI1248_AVX512BW 1 \"mask_reg_operand\" \"k\")\n+\t  (match_operand:SWI1248_AVX512BW 2 \"mask_reg_operand\" \"k\")))]\n   \"TARGET_AVX512F\"\n   {\n-    if (!TARGET_AVX512DQ && <MODE>mode == QImode)\n+    if (get_attr_mode (insn) == MODE_HI)\n       return \"k<logic>w\\t{%2, %1, %0|%0, %1, %2}\";\n     else\n       return \"k<logic><mskmodesuffix>\\t{%2, %1, %0|%0, %1, %2}\";\n   }\n-  [(set_attr \"mode\" \"<MODE>\")\n-   (set_attr \"type\" \"msklog\")\n-   (set_attr \"prefix\" \"vex\")])\n+  [(set_attr \"type\" \"msklog\")\n+   (set_attr \"prefix\" \"vex\")\n+   (set (attr \"mode\")\n+     (cond [(and (match_test \"<MODE>mode == QImode\")\n+\t\t (not (match_test \"TARGET_AVX512DQ\")))\n+\t       (const_string \"HI\")\n+\t   ]\n+\t   (const_string \"<MODE>\")))])\n \n ;; %%% This used to optimize known byte-wide and operations to memory,\n ;; and sometimes to QImode registers.  If this is considered useful,\n@@ -8278,14 +8305,22 @@\n     case 2:\n       return \"and{l}\\t{%k2, %k0|%k0, %k2}\";\n     case 3:\n-      return TARGET_AVX512DQ ? \"kandb\\t{%2, %1, %0|%0, %1, %2}\"\n-\t\t\t     : \"kandw\\t{%2, %1, %0|%0, %1, %2}\";\n+      if (get_attr_mode (insn) == MODE_HI)\n+\treturn \"kandw\\t{%2, %1, %0|%0, %1, %2}\";\n+      else\n+\treturn \"kandb\\t{%2, %1, %0|%0, %1, %2}\";\n     default:\n       gcc_unreachable ();\n     }\n }\n   [(set_attr \"type\" \"alu,alu,alu,msklog\")\n-   (set_attr \"mode\" \"QI,QI,SI,HI\")\n+   (set (attr \"mode\")\n+      (cond [(eq_attr \"alternative\" \"2\")\n+\t       (const_string \"SI\")\n+\t     (and (eq_attr \"alternative\" \"3\")\n+\t\t  (not (match_test \"TARGET_AVX512DQ\")))\n+\t       (const_string \"HI\")]\n+\t    (const_string \"QI\")))\n    ;; Potential partial reg stall on alternative 2.\n    (set (attr \"preferred_for_speed\")\n      (cond [(eq_attr \"alternative\" \"2\")\n@@ -8319,10 +8354,10 @@\n     case 1:\n       return \"#\";\n     case 2:\n-      if (TARGET_AVX512DQ && <MODE>mode == QImode)\n-\treturn \"kandnb\\t{%2, %1, %0|%0, %1, %2}\";\n-      else\n+      if (get_attr_mode (insn) == MODE_HI)\n \treturn \"kandnw\\t{%2, %1, %0|%0, %1, %2}\";\n+      else\n+\treturn \"kandn<mskmodesuffix>\\t{%2, %1, %0|%0, %1, %2}\";\n     default:\n       gcc_unreachable ();\n     }\n@@ -8331,7 +8366,13 @@\n    (set_attr \"type\" \"bitmanip,*,msklog\")\n    (set_attr \"prefix\" \"*,*,vex\")\n    (set_attr \"btver2_decode\" \"direct,*,*\")\n-   (set_attr \"mode\" \"<MODE>\")])\n+   (set (attr \"mode\")\n+     (cond [(and (eq_attr \"alternative\" \"2\")\n+\t\t (and (match_test \"<MODE>mode == QImode\")\n+\t\t      (not (match_test \"TARGET_AVX512DQ\"))))\n+\t       (const_string \"HI\")\n+\t   ]\n+\t   (const_string \"<MODE>\")))])\n \n (define_split\n   [(set (match_operand:SWI12 0 \"general_reg_operand\")\n@@ -8843,36 +8884,31 @@\n    (set_attr \"mode\" \"<MODE>\")])\n \n (define_insn \"kxnor<mode>\"\n-  [(set (match_operand:SWI12 0 \"register_operand\" \"=r,!k\")\n-\t(not:SWI12\n-\t  (xor:SWI12\n-\t    (match_operand:SWI12 1 \"register_operand\" \"0,k\")\n-\t    (match_operand:SWI12 2 \"register_operand\" \"r,k\"))))\n+  [(set (match_operand:SWI1248_AVX512BW 0 \"register_operand\" \"=r,!k\")\n+\t(not:SWI1248_AVX512BW\n+\t  (xor:SWI1248_AVX512BW\n+\t    (match_operand:SWI1248_AVX512BW 1 \"register_operand\" \"0,k\")\n+\t    (match_operand:SWI1248_AVX512BW 2 \"register_operand\" \"r,k\"))))\n    (clobber (reg:CC FLAGS_REG))]\n   \"TARGET_AVX512F\"\n {\n-  if (which_alternative == 1 && <MODE>mode == QImode && TARGET_AVX512DQ)\n-    return \"kxnorb\\t{%2, %1, %0|%0, %1, %2}\";\n-  return \"kxnorw\\t{%2, %1, %0|%0, %1, %2}\";\n-}\n-  [(set_attr \"type\" \"*,msklog\")\n-   (set_attr \"prefix\" \"*,vex\")\n-   (set_attr \"mode\" \"<MODE>\")])\n+  if (which_alternative == 0)\n+    return \"#\";\n \n-(define_insn \"kxnor<mode>\"\n-  [(set (match_operand:SWI48x 0 \"register_operand\" \"=r,!k\")\n-\t(not:SWI48x\n-\t  (xor:SWI48x\n-\t    (match_operand:SWI48x 1 \"register_operand\" \"0,k\")\n-\t    (match_operand:SWI48x 2 \"register_operand\" \"r,k\"))))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_AVX512BW\"\n-  \"@\n-   #\n-   kxnor<mskmodesuffix>\\t{%2, %1, %0|%0, %1, %2}\"\n+  if (get_attr_mode (insn) == MODE_HI)\n+    return \"kxnorw\\t{%2, %1, %0|%0, %1, %2}\";\n+  else\n+    return \"kxnor<mskmodesuffix>\\t{%2, %1, %0|%0, %1, %2}\";\n+}\n   [(set_attr \"type\" \"*,msklog\")\n    (set_attr \"prefix\" \"*,vex\")\n-   (set_attr \"mode\" \"<MODE>\")])\n+   (set (attr \"mode\")\n+     (cond [(and (eq_attr \"alternative\" \"1\")\n+\t\t (and (match_test \"<MODE>mode == QImode\")\n+\t\t      (not (match_test \"TARGET_AVX512DQ\"))))\n+\t      (const_string \"HI\")\n+\t   ]\n+\t   (const_string \"<MODE>\")))])\n \n (define_split\n   [(set (match_operand:SWI1248x 0 \"general_reg_operand\")\n@@ -9583,17 +9619,24 @@\n     case 1:\n       return \"not{l}\\t%k0\";\n     case 2:\n-      if (TARGET_AVX512DQ)\n+      if (get_attr_mode (insn) == MODE_HI)\n+\treturn \"knotw\\t{%1, %0|%0, %1}\";\n+      else\n \treturn \"knotb\\t{%1, %0|%0, %1}\";\n-      return \"knotw\\t{%1, %0|%0, %1}\";\n     default:\n       gcc_unreachable ();\n     }\n }\n   [(set_attr \"isa\" \"*,*,avx512f\")\n    (set_attr \"type\" \"negnot,negnot,msklog\")\n    (set_attr \"prefix\" \"*,*,vex\")\n-   (set_attr \"mode\" \"QI,SI,QI\")\n+   (set (attr \"mode\")\n+      (cond [(eq_attr \"alternative\" \"1\")\n+\t       (const_string \"SI\")\n+\t     (and (eq_attr \"alternative\" \"2\")\n+\t\t  (not (match_test \"TARGET_AVX512DQ\")))\n+\t       (const_string \"HI\")]\n+\t    (const_string \"QI\")))\n    ;; Potential partial reg stall on alternative 1.\n    (set (attr \"preferred_for_speed\")\n      (cond [(eq_attr \"alternative\" \"1\")"}]}