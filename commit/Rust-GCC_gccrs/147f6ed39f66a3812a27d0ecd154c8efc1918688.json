{"sha": "147f6ed39f66a3812a27d0ecd154c8efc1918688", "node_id": "C_kwDOANBUbNoAKDE0N2Y2ZWQzOWY2NmEzODEyYTI3ZDBlY2QxNTRjOGVmYzE5MTg2ODg", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-10-04T13:45:15Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-10-04T13:45:15Z"}, "message": "libstdc++: Implement ranges::join_with_view from P2441R2\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/std/ranges: Include <variant> for C++23.\n\t(__detail::__compatible_joinable_ranges): Define.\n\t(__detail::__bidirectional_common): Define.\n\t(join_with_view): Define.\n\t(join_with_view::_Iterator): Define.\n\t(join_with_view::_Sentinel): Define.\n\t(views::__detail::__can_join_with_view): Define.\n\t(views::_JoinWith, views::join_with): Define.\n\t* testsuite/std/ranges/adaptors/join_with/1.cc: New test.", "tree": {"sha": "7689b7c051500c2023b0ae36fa71b4ccb526a28c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7689b7c051500c2023b0ae36fa71b4ccb526a28c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/147f6ed39f66a3812a27d0ecd154c8efc1918688", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/147f6ed39f66a3812a27d0ecd154c8efc1918688", "html_url": "https://github.com/Rust-GCC/gccrs/commit/147f6ed39f66a3812a27d0ecd154c8efc1918688", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/147f6ed39f66a3812a27d0ecd154c8efc1918688/comments", "author": null, "committer": null, "parents": [{"sha": "e886ebd17965d78f609b62479f4f48085108389c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e886ebd17965d78f609b62479f4f48085108389c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e886ebd17965d78f609b62479f4f48085108389c"}], "stats": {"total": 555, "additions": 555, "deletions": 0}, "files": [{"sha": "d0d6ce61a87f434b205cf8edb9da2b579dbf291c", "filename": "libstdc++-v3/include/std/ranges", "status": "modified", "additions": 458, "deletions": 0, "changes": 458, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/147f6ed39f66a3812a27d0ecd154c8efc1918688/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/147f6ed39f66a3812a27d0ecd154c8efc1918688/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges?ref=147f6ed39f66a3812a27d0ecd154c8efc1918688", "patch": "@@ -44,6 +44,9 @@\n #include <optional>\n #include <span>\n #include <tuple>\n+#if __cplusplus > 202002L\n+#include <variant>\n+#endif\n #include <bits/ranges_util.h>\n #include <bits/refwrap.h>\n \n@@ -6873,6 +6876,461 @@ namespace views::__adaptor\n \n     inline constexpr _ChunkBy chunk_by;\n   }\n+\n+  namespace __detail\n+  {\n+    template<typename _Range, typename _Pattern>\n+      concept __compatible_joinable_ranges\n+\t= common_with<range_value_t<_Range>, range_value_t<_Pattern>>\n+\t  && common_reference_with<range_reference_t<_Range>,\n+\t\t\t\t   range_reference_t<_Pattern>>\n+\t  && common_reference_with<range_rvalue_reference_t<_Range>,\n+\t\t\t\t   range_rvalue_reference_t<_Pattern>>;\n+\n+    template<typename _Range>\n+      concept __bidirectional_common = bidirectional_range<_Range> && common_range<_Range>;\n+  }\n+\n+  template<input_range _Vp, forward_range _Pattern>\n+    requires view<_Vp> && view<_Pattern>\n+      && input_range<range_reference_t<_Vp>>\n+      && __detail::__compatible_joinable_ranges<range_reference_t<_Vp>, _Pattern>\n+  class join_with_view : public view_interface<join_with_view<_Vp, _Pattern>>\n+  {\n+    using _InnerRange = range_reference_t<_Vp>;\n+\n+    _Vp _M_base = _Vp();\n+    __detail::__non_propagating_cache<remove_cv_t<_InnerRange>> _M_inner;\n+    _Pattern _M_pattern = _Pattern();\n+\n+    template<bool _Const> using _Base = __detail::__maybe_const_t<_Const, _Vp>;\n+    template<bool _Const> using _InnerBase = range_reference_t<_Base<_Const>>;\n+    template<bool _Const> using _PatternBase = __detail::__maybe_const_t<_Const, _Pattern>;\n+\n+    template<bool _Const> using _OuterIter = iterator_t<_Base<_Const>>;\n+    template<bool _Const> using _InnerIter = iterator_t<_InnerBase<_Const>>;\n+    template<bool _Const> using _PatternIter = iterator_t<_PatternBase<_Const>>;\n+\n+    template<bool _Const>\n+      static constexpr bool _S_ref_is_glvalue = is_reference_v<_InnerBase<_Const>>;\n+\n+    template<bool _Const>\n+    struct __iter_cat\n+    { };\n+\n+    template<bool _Const>\n+      requires _S_ref_is_glvalue<_Const>\n+\t&& forward_range<_Base<_Const>>\n+\t&& forward_range<_InnerBase<_Const>>\n+    struct __iter_cat<_Const>\n+    {\n+      private:\n+\tstatic auto\n+\t_S_iter_cat()\n+\t{\n+\t  using _OuterIter = join_with_view::_OuterIter<_Const>;\n+\t  using _InnerIter = join_with_view::_InnerIter<_Const>;\n+\t  using _PatternIter = join_with_view::_PatternIter<_Const>;\n+\t  using _OuterCat = typename iterator_traits<_OuterIter>::iterator_category;\n+\t  using _InnerCat = typename iterator_traits<_InnerIter>::iterator_category;\n+\t  using _PatternCat = typename iterator_traits<_PatternIter>::iterator_category;\n+\t  if constexpr (!is_lvalue_reference_v<common_reference_t<iter_reference_t<_InnerIter>,\n+\t\t\t\t\t\t\t\t  iter_reference_t<_PatternIter>>>)\n+\t    return input_iterator_tag{};\n+\t  else if constexpr (derived_from<_OuterCat, bidirectional_iterator_tag>\n+\t\t\t     && derived_from<_InnerCat, bidirectional_iterator_tag>\n+\t\t\t     && derived_from<_PatternCat, bidirectional_iterator_tag>\n+\t\t\t     && common_range<_InnerBase<_Const>>\n+\t\t\t     && common_range<_PatternBase<_Const>>)\n+\t    return bidirectional_iterator_tag{};\n+\t  else if constexpr (derived_from<_OuterCat, forward_iterator_tag>\n+\t\t\t     && derived_from<_InnerCat, forward_iterator_tag>\n+\t\t\t     && derived_from<_PatternCat, forward_iterator_tag>)\n+\t    return forward_iterator_tag{};\n+\t  else\n+\t    return input_iterator_tag{};\n+\t}\n+      public:\n+\tusing iterator_category = decltype(_S_iter_cat());\n+    };\n+\n+    template<bool> struct _Iterator;\n+    template<bool> struct _Sentinel;\n+\n+  public:\n+    join_with_view() requires (default_initializable<_Vp>\n+\t\t\t       && default_initializable<_Pattern>)\n+      = default;\n+\n+    constexpr\n+    join_with_view(_Vp __base, _Pattern __pattern)\n+    : _M_base(std::move(__base)), _M_pattern(std::move(__pattern))\n+    { }\n+\n+    template<input_range _Range>\n+      requires constructible_from<_Vp, views::all_t<_Range>>\n+\t&& constructible_from<_Pattern, single_view<range_value_t<_InnerRange>>>\n+    constexpr\n+    join_with_view(_Range&& __r, range_value_t<_InnerRange> __e)\n+    : _M_base(views::all(std::forward<_Range>(__r))),\n+      _M_pattern(views::single(std::move(__e)))\n+    { }\n+\n+    constexpr _Vp\n+    base() const& requires copy_constructible<_Vp>\n+    { return _M_base; }\n+\n+    constexpr _Vp\n+    base() &&\n+    { return std::move(_M_base); }\n+\n+    constexpr auto\n+    begin()\n+    {\n+      constexpr bool __use_const = is_reference_v<_InnerRange>\n+\t&& __detail::__simple_view<_Vp> && __detail::__simple_view<_Pattern>;\n+      return _Iterator<__use_const>{*this, ranges::begin(_M_base)};\n+    }\n+\n+    constexpr auto\n+    begin() const\n+      requires input_range<const _Vp>\n+\t&& forward_range<const _Pattern>\n+\t&& is_reference_v<range_reference_t<const _Vp>>\n+    { return _Iterator<true>{*this, ranges::begin(_M_base)}; }\n+\n+    constexpr auto\n+    end()\n+    {\n+      constexpr bool __use_const\n+\t= __detail::__simple_view<_Vp> && __detail::__simple_view<_Pattern>;\n+      if constexpr (is_reference_v<_InnerRange>\n+\t\t    && forward_range<_Vp> && common_range<_Vp>\n+\t\t    && forward_range<_InnerRange> && common_range<_InnerRange>)\n+        return _Iterator<__use_const>{*this, ranges::end(_M_base)};\n+      else\n+        return _Sentinel<__use_const>{*this};\n+    }\n+\n+    constexpr auto\n+    end() const\n+      requires input_range<const _Vp>\n+\t&& forward_range<const _Pattern>\n+\t&& is_reference_v<range_reference_t<const _Vp>>\n+    {\n+      using _InnerConstRange = range_reference_t<const _Vp>;\n+      if constexpr (forward_range<const _Vp>\n+\t\t    && forward_range<_InnerConstRange>\n+\t\t    && common_range<const _Vp>\n+\t\t    && common_range<_InnerConstRange>)\n+        return _Iterator<true>{*this, ranges::end(_M_base)};\n+      else\n+        return _Sentinel<true>{*this};\n+    }\n+  };\n+\n+  template<typename _Range, typename _Pattern>\n+    join_with_view(_Range&&, _Pattern&&)\n+      -> join_with_view<views::all_t<_Range>, views::all_t<_Pattern>>;\n+\n+  template<input_range _Range>\n+    join_with_view(_Range&&, range_value_t<range_reference_t<_Range>>)\n+      -> join_with_view<views::all_t<_Range>,\n+\t\t\tsingle_view<range_value_t<range_reference_t<_Range>>>>;\n+\n+  template<input_range _Vp, forward_range _Pattern>\n+    requires view<_Vp> && view<_Pattern>\n+      && input_range<range_reference_t<_Vp>>\n+      && __detail::__compatible_joinable_ranges<range_reference_t<_Vp>, _Pattern>\n+  template<bool _Const>\n+  class join_with_view<_Vp, _Pattern>::_Iterator : public __iter_cat<_Const>\n+  {\n+    using _Parent = __detail::__maybe_const_t<_Const, join_with_view>;\n+    using _Base = join_with_view::_Base<_Const>;\n+    using _InnerBase = join_with_view::_InnerBase<_Const>;\n+    using _PatternBase = join_with_view::_PatternBase<_Const>;\n+\n+    using _OuterIter = join_with_view::_OuterIter<_Const>;\n+    using _InnerIter = join_with_view::_InnerIter<_Const>;\n+    using _PatternIter = join_with_view::_PatternIter<_Const>;\n+\n+    static constexpr bool _S_ref_is_glvalue = join_with_view::_S_ref_is_glvalue<_Const>;\n+\n+    _Parent* _M_parent = nullptr;\n+    _OuterIter _M_outer_it = _OuterIter();\n+    variant<_PatternIter, _InnerIter> _M_inner_it;\n+\n+    constexpr\n+    _Iterator(_Parent& __parent, iterator_t<_Base> __outer)\n+    : _M_parent(std::__addressof(__parent)), _M_outer_it(std::move(__outer))\n+    {\n+      if (_M_outer_it != ranges::end(_M_parent->_M_base))\n+\t{\n+\t  auto&& __inner = _M_update_inner(_M_outer_it);\n+\t  _M_inner_it.template emplace<1>(ranges::begin(__inner));\n+\t  _M_satisfy();\n+\t}\n+    }\n+\n+    constexpr auto&&\n+    _M_update_inner(const _OuterIter& __x)\n+    {\n+      if constexpr (_S_ref_is_glvalue)\n+\treturn *__x;\n+      else\n+\treturn _M_parent->_M_inner._M_emplace_deref(__x);\n+    }\n+\n+    constexpr auto&&\n+    _M_get_inner(const _OuterIter& __x)\n+    {\n+      if constexpr (_S_ref_is_glvalue)\n+\treturn *__x;\n+      else\n+\treturn *_M_parent->_M_inner;\n+    }\n+\n+    constexpr void\n+    _M_satisfy()\n+    {\n+      while (true)\n+\t{\n+\t  if (_M_inner_it.index() == 0)\n+\t    {\n+\t      if (std::get<0>(_M_inner_it) != ranges::end(_M_parent->_M_pattern))\n+\t\tbreak;\n+\n+\t      auto&& __inner = _M_update_inner(_M_outer_it);\n+\t      _M_inner_it.template emplace<1>(ranges::begin(__inner));\n+\t    }\n+\t  else\n+\t    {\n+\t      auto&& __inner = _M_get_inner(_M_outer_it);\n+\t      if (std::get<1>(_M_inner_it) != ranges::end(__inner))\n+\t\tbreak;\n+\n+\t      if (++_M_outer_it == ranges::end(_M_parent->_M_base))\n+\t\t{\n+\t\t  if constexpr (_S_ref_is_glvalue)\n+\t\t    _M_inner_it.template emplace<0>();\n+\t\t  break;\n+\t\t}\n+\n+\t      _M_inner_it.template emplace<0>(ranges::begin(_M_parent->_M_pattern));\n+\t    }\n+\t}\n+    }\n+\n+    static auto\n+    _S_iter_concept()\n+    {\n+      if constexpr (_S_ref_is_glvalue\n+\t\t    && bidirectional_range<_Base>\n+\t\t    && __detail::__bidirectional_common<_InnerBase>\n+\t\t    && __detail::__bidirectional_common<_PatternBase>)\n+\treturn bidirectional_iterator_tag{};\n+      else if constexpr (_S_ref_is_glvalue\n+\t\t\t && forward_range<_Base>\n+\t\t\t && forward_range<_InnerBase>)\n+\treturn forward_iterator_tag{};\n+      else\n+\treturn input_iterator_tag{};\n+    }\n+\n+    friend join_with_view;\n+\n+  public:\n+    using iterator_concept = decltype(_S_iter_concept());\n+    // iterator_category defined in join_with_view::__iter_cat\n+    using value_type = common_type_t<iter_value_t<_InnerIter>,\n+\t\t\t\t     iter_value_t<_PatternIter>>;\n+    using difference_type = common_type_t<iter_difference_t<_OuterIter>,\n+\t\t\t\t\t  iter_difference_t<_InnerIter>,\n+\t\t\t\t\t  iter_difference_t<_PatternIter>>;\n+\n+    _Iterator() requires default_initializable<_OuterIter> = default;\n+\n+    constexpr\n+    _Iterator(_Iterator<!_Const> __i)\n+      requires _Const\n+\t&& convertible_to<iterator_t<_Vp>, _OuterIter>\n+\t&& convertible_to<iterator_t<_InnerRange>, _InnerIter>\n+\t&& convertible_to<iterator_t<_Pattern>, _PatternIter>\n+    : _M_parent(__i._M_parent),\n+      _M_outer_it(std::move(__i._M_outer_it))\n+    {\n+      if (__i._M_inner_it.index() == 0)\n+\t_M_inner_it.template emplace<0>(std::get<0>(std::move(__i._M_inner_it)));\n+      else\n+\t_M_inner_it.template emplace<1>(std::get<1>(std::move(__i._M_inner_it)));\n+    }\n+\n+    constexpr decltype(auto)\n+    operator*() const\n+    {\n+      using reference = common_reference_t<iter_reference_t<_InnerIter>,\n+\t\t\t\t\t   iter_reference_t<_PatternIter>>;\n+      return std::visit([](auto& __it) -> reference { return *__it; }, _M_inner_it);\n+    }\n+\n+    constexpr _Iterator&\n+    operator++()\n+    {\n+      std::visit([](auto& __it){ ++__it; }, _M_inner_it);\n+      _M_satisfy();\n+      return *this;\n+    }\n+\n+    constexpr void\n+    operator++(int)\n+    { ++*this; }\n+\n+    constexpr _Iterator\n+    operator++(int)\n+      requires _S_ref_is_glvalue\n+\t&& forward_iterator<_OuterIter> && forward_iterator<_InnerIter>\n+    {\n+      _Iterator __tmp = *this;\n+      ++*this;\n+      return __tmp;\n+    }\n+\n+    constexpr _Iterator&\n+    operator--()\n+      requires _S_ref_is_glvalue\n+\t&& bidirectional_range<_Base>\n+\t&& __detail::__bidirectional_common<_InnerBase>\n+\t&& __detail::__bidirectional_common<_PatternBase>\n+    {\n+      if (_M_outer_it == ranges::end(_M_parent->_M_base))\n+\t{\n+\t  auto&& __inner = *--_M_outer_it;\n+\t  _M_inner_it.template emplace<1>(ranges::end(__inner));\n+\t}\n+\n+      while (true)\n+\t{\n+\t  if (_M_inner_it.index() == 0)\n+\t    {\n+\t      auto& __it = std::get<0>(_M_inner_it);\n+\t      if (__it == ranges::begin(_M_parent->_M_pattern))\n+\t\t{\n+\t\t  auto&& __inner = *--_M_outer_it;\n+\t\t  _M_inner_it.template emplace<1>(ranges::end(__inner));\n+\t\t}\n+\t      else\n+\t\tbreak;\n+\t    }\n+\t  else\n+\t    {\n+\t      auto& __it = std::get<1>(_M_inner_it);\n+\t      auto&& __inner = *_M_outer_it;\n+\t      if (__it == ranges::begin(__inner))\n+\t\t_M_inner_it.template emplace<0>(ranges::end(_M_parent->_M_pattern));\n+\t      else\n+\t\tbreak;\n+\t    }\n+\t}\n+\n+      std::visit([](auto& __it){ --__it; }, _M_inner_it);\n+      return *this;\n+    }\n+\n+    constexpr _Iterator\n+    operator--(int)\n+      requires _S_ref_is_glvalue && bidirectional_range<_Base>\n+\t&& __detail::__bidirectional_common<_InnerBase>\n+\t&& __detail::__bidirectional_common<_PatternBase>\n+    {\n+      _Iterator __tmp = *this;\n+      --*this;\n+      return __tmp;\n+    }\n+\n+    friend constexpr bool\n+    operator==(const _Iterator& __x, const _Iterator& __y)\n+      requires _S_ref_is_glvalue\n+\t&& equality_comparable<_OuterIter> && equality_comparable<_InnerIter>\n+    { return __x._M_outer_it == __y._M_outer_it && __x._M_inner_it ==__y._M_inner_it; }\n+\n+    friend constexpr decltype(auto)\n+    iter_move(const _Iterator& __x)\n+    {\n+      using __rval_ref = common_reference_t<iter_rvalue_reference_t<_InnerIter>,\n+\t\t\t\t\t    iter_rvalue_reference_t<_PatternIter>>;\n+      return std::visit<__rval_ref>(ranges::iter_move, __x._M_inner_it);\n+    }\n+\n+    friend constexpr void\n+    iter_swap(const _Iterator& __x, const _Iterator& __y)\n+      requires indirectly_swappable<_InnerIter, _PatternIter>\n+    { std::visit(ranges::iter_swap, __x._M_inner_it, __y._M_inner_it); }\n+  };\n+\n+  template<input_range _Vp, forward_range _Pattern>\n+    requires view<_Vp> && view<_Pattern>\n+      && input_range<range_reference_t<_Vp>>\n+      && __detail::__compatible_joinable_ranges<range_reference_t<_Vp>, _Pattern>\n+  template<bool _Const>\n+  class join_with_view<_Vp, _Pattern>::_Sentinel\n+  {\n+    using _Parent = __detail::__maybe_const_t<_Const, join_with_view>;\n+    using _Base = join_with_view::_Base<_Const>;\n+\n+    sentinel_t<_Base> _M_end = sentinel_t<_Base>();\n+\n+    constexpr explicit\n+    _Sentinel(_Parent& __parent)\n+    : _M_end(ranges::end(__parent._M_base))\n+    { }\n+\n+    friend join_with_view;\n+\n+  public:\n+    _Sentinel() = default;\n+\n+    constexpr\n+    _Sentinel(_Sentinel<!_Const> __s)\n+      requires _Const && convertible_to<sentinel_t<_Vp>, sentinel_t<_Base>>\n+    : _M_end(std::move(__s._M_end))\n+    { }\n+\n+    template<bool _OtherConst>\n+      requires sentinel_for<sentinel_t<_Base>,\n+\t\t\t    iterator_t<__detail::__maybe_const_t<_OtherConst, _Vp>>>\n+    friend constexpr bool\n+    operator==(const _Iterator<_OtherConst>& __x, const _Sentinel& __y)\n+    { return __x._M_outer_it == __y._M_end; }\n+  };\n+\n+  namespace views\n+  {\n+    namespace __detail\n+    {\n+      template<typename _Range, typename _Pattern>\n+\tconcept __can_join_with_view\n+\t  = requires { join_with_view(std::declval<_Range>(), std::declval<_Pattern>()); };\n+    } // namespace __detail\n+\n+    struct _JoinWith : __adaptor::_RangeAdaptor<_JoinWith>\n+    {\n+      template<viewable_range _Range, typename _Pattern>\n+\trequires __detail::__can_join_with_view<_Range, _Pattern>\n+\tconstexpr auto\n+\toperator() [[nodiscard]] (_Range&& __r, _Pattern&& __f) const\n+\t{\n+\t  return join_with_view(std::forward<_Range>(__r), std::forward<_Pattern>(__f));\n+\t}\n+\n+      using _RangeAdaptor<_JoinWith>::operator();\n+      static constexpr int _S_arity = 2;\n+      template<typename _Pattern>\n+\tstatic constexpr bool _S_has_simple_extra_args\n+\t  = _LazySplit::_S_has_simple_extra_args<_Pattern>;\n+    };\n+\n+    inline constexpr _JoinWith join_with;\n+  } // namespace views\n #endif // C++23\n } // namespace ranges\n "}, {"sha": "efa350feb11b40c23dfb7d4992db5739dcde10c0", "filename": "libstdc++-v3/testsuite/std/ranges/adaptors/join_with/1.cc", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/147f6ed39f66a3812a27d0ecd154c8efc1918688/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fjoin_with%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/147f6ed39f66a3812a27d0ecd154c8efc1918688/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fjoin_with%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fjoin_with%2F1.cc?ref=147f6ed39f66a3812a27d0ecd154c8efc1918688", "patch": "@@ -0,0 +1,97 @@\n+// { dg-options \"-std=gnu++23\" }\n+// { dg-do run { target c++23 } }\n+\n+#include <ranges>\n+#include <algorithm>\n+#include <sstream>\n+#include <string_view>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+namespace ranges = std::ranges;\n+namespace views = std::views;\n+using namespace std::literals;\n+\n+constexpr bool\n+test01()\n+{\n+  std::string_view rs[] = {\"hello\", \"world\"};\n+  auto v = rs | views::join_with(' ');\n+  VERIFY( ranges::equal(v | views::split(' '), rs, ranges::equal) );\n+  auto i = v.begin(), j = v.begin();\n+  VERIFY( i == j );\n+  ++i;\n+  i++;\n+  VERIFY( i != j );\n+  VERIFY( *i == 'l' );\n+  --i;\n+  i--;\n+  VERIFY( *i == 'h' );\n+  return true;\n+}\n+\n+constexpr bool\n+test02()\n+{\n+  std::string_view rs[] = {\"the\", \"quick\", \"brown\", \"fox\"};\n+  auto v = rs\n+    | views::transform([](auto x) { return x; })\n+    | views::filter([](auto) { return true; });\n+  VERIFY( ranges::equal(v | views::join_with(views::empty<char>), \"thequickbrownfox\"sv) );\n+  VERIFY( ranges::equal(v | views::join_with('-'), \"the-quick-brown-fox\"sv) );\n+  VERIFY( ranges::equal(v | views::join_with(\"--\"sv), \"the--quick--brown--fox\"sv) );\n+  VERIFY( ranges::empty(views::empty<int[3]> | views::join_with(0)));\n+  VERIFY( ranges::equal(views::single(std::array{42}) | views::join_with(0), (int[]){42}));\n+  return true;\n+}\n+\n+constexpr bool\n+test03()\n+{\n+  using __gnu_test::test_input_range;\n+  using __gnu_test::test_forward_range;\n+  using __gnu_test::test_bidirectional_range;\n+\n+  using ty1 = ranges::join_with_view<views::all_t<test_input_range<test_input_range<int>>>,\n+\t\t\t\t     views::all_t<test_forward_range<int>>>;\n+  static_assert(ranges::input_range<ty1>);\n+  static_assert(!ranges::forward_range<ty1>);\n+  static_assert(!ranges::common_range<ty1>);\n+\n+  using ty2 = ranges::join_with_view<views::all_t<test_forward_range<test_forward_range<int>>>,\n+\t\t\t\t     views::all_t<test_forward_range<int>>>;\n+  static_assert(ranges::forward_range<ty2>);\n+  static_assert(!ranges::bidirectional_range<ty2>);\n+  static_assert(!ranges::common_range<ty2>);\n+\n+  using ty3 = ranges::join_with_view<views::all_t<std::array<std::string_view, 3>>,\n+\t\t\t\t     std::string_view>;\n+  static_assert(ranges::bidirectional_range<ty3>);\n+  static_assert(!ranges::random_access_range<ty3>);\n+  static_assert(ranges::common_range<ty3>);\n+\n+  return true;\n+}\n+\n+constexpr bool\n+test04()\n+{\n+  std::string rs[] = {\"a\", \"\", \"b\", \"\", \"c\"};\n+  auto v = rs | views::join_with(' ');\n+  VERIFY( ranges::equal(v, \"a  b  c\"sv) );\n+  auto i = v.begin();\n+  auto j = ranges::next(i, 3);\n+  ranges::iter_swap(i, j);\n+  *j = ranges::iter_move(i);\n+  VERIFY( ranges::equal(v, \"b  b  c\"sv) );\n+  return true;\n+}\n+\n+int\n+main()\n+{\n+  static_assert(test01());\n+  static_assert(test02());\n+  static_assert(test03());\n+  static_assert(test04());\n+}"}]}