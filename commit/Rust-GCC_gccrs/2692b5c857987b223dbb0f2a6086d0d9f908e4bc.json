{"sha": "2692b5c857987b223dbb0f2a6086d0d9f908e4bc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjY5MmI1Yzg1Nzk4N2IyMjNkYmIwZjJhNjA4NmQwZDlmOTA4ZTRiYw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2016-02-04T15:01:15Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2016-02-04T15:01:15Z"}, "message": "PR 69577: Invalid RA of destination subregs\n\nIn PR 69577 we have:\n\n      A: (set (reg:V2TI X) ...)\n      B: (set (subreg:TI (reg:V2TI X) 0) ...)\n\nX gets allocated to an AVX register, as usual for V2TI.  The problem is\nthat the movti for B doesn't then preserve the other half of X, even\nthough the subreg semantics are supposed to guarantee that.\n\nIf instead the same value had been set by:\n\n      A': (set (subreg:TI (reg:V2TI X) 16) ...)\n      B: (set (subreg:TI (reg:V2TI X) 0) ...)\n\nthe subreg in A' would have prevented the use of AVX registers for X,\nsince you can't directly access the high part.\n\nIMO these are really the same thing.  An alternative way to view it\nis that the original sequence is equivalent to:\n\n      A: (set (reg:V2TI X) ...)\n      B1: (set (subreg:TI (reg:V2TI X) 0) ...)\n      B2: (set (subreg:TI (reg:V2TI X) 16) (subreg:TI (reg:V2TI X) 16))\n\nin which B2 is a no-op and therefore implicit.  The handling ought\nto be the same regardless of whether there is an rtl insn that\nexplicitly assigns to (subreg:TI (reg:V2TI X) 16).\n\nThis patch implements that idea.  Hopefully the comments explain\nwhat's going on.\n\nTested on x86_64-linux-gnu, aarch64-linux-gnu and arm-linux-gnueabihf.\n\ngcc/\n\tPR rtl-optimization/69577\n\t* reginfo.c (record_subregs_of_mode): Add a partial_def parameter.\n\t(find_subregs_of_mode): Update accordingly.  Iterate over partial\n\tdefinitions.\n\ngcc/testsuite/\n\tPR rtl-optimization/69577\n\t* gcc.target/i386/pr69577.c: New test.\n\nFrom-SVN: r233143", "tree": {"sha": "a9aa9dd6694766c5a4db3eb12026c67801b1456e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a9aa9dd6694766c5a4db3eb12026c67801b1456e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2692b5c857987b223dbb0f2a6086d0d9f908e4bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2692b5c857987b223dbb0f2a6086d0d9f908e4bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2692b5c857987b223dbb0f2a6086d0d9f908e4bc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2692b5c857987b223dbb0f2a6086d0d9f908e4bc/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1d1086348122165d29157eaffe3bd906769f1dff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d1086348122165d29157eaffe3bd906769f1dff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d1086348122165d29157eaffe3bd906769f1dff"}], "stats": {"total": 88, "additions": 83, "deletions": 5}, "files": [{"sha": "ca62ac6dbcc03f9d5491d8f436e014e902649628", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2692b5c857987b223dbb0f2a6086d0d9f908e4bc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2692b5c857987b223dbb0f2a6086d0d9f908e4bc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2692b5c857987b223dbb0f2a6086d0d9f908e4bc", "patch": "@@ -1,3 +1,10 @@\n+2016-02-04  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\tPR rtl-optimization/69577\n+\t* reginfo.c (record_subregs_of_mode): Add a partial_def parameter.\n+\t(find_subregs_of_mode): Update accordingly.  Iterate over partial\n+\tdefinitions.\n+\n 2016-02-04  Alan Lawrence  <alan.lawrence@arm.com>\n \n \t* config/arm/arm-protos.h (neon_reinterpret): Remove."}, {"sha": "ccf53bfbc1f10f9c604519d750986d6e7b2fa730", "filename": "gcc/reginfo.c", "status": "modified", "additions": 46, "deletions": 5, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2692b5c857987b223dbb0f2a6086d0d9f908e4bc/gcc%2Freginfo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2692b5c857987b223dbb0f2a6086d0d9f908e4bc/gcc%2Freginfo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freginfo.c?ref=2692b5c857987b223dbb0f2a6086d0d9f908e4bc", "patch": "@@ -1244,8 +1244,16 @@ simplifiable_subregs (const subreg_shape &shape)\n static HARD_REG_SET **valid_mode_changes;\n static obstack valid_mode_changes_obstack;\n \n+/* Restrict the choice of register for SUBREG_REG (SUBREG) based\n+   on information about SUBREG.\n+\n+   If PARTIAL_DEF, SUBREG is a partial definition of a multipart inner\n+   register and we want to ensure that the other parts of the inner\n+   register are correctly preserved.  If !PARTIAL_DEF we need to\n+   ensure that SUBREG itself can be formed.  */\n+\n static void\n-record_subregs_of_mode (rtx subreg)\n+record_subregs_of_mode (rtx subreg, bool partial_def)\n {\n   unsigned int regno;\n \n@@ -1256,15 +1264,41 @@ record_subregs_of_mode (rtx subreg)\n   if (regno < FIRST_PSEUDO_REGISTER)\n     return;\n \n+  subreg_shape shape (shape_of_subreg (subreg));\n+  if (partial_def)\n+    {\n+      /* The number of independently-accessible SHAPE.outer_mode values\n+\t in SHAPE.inner_mode is GET_MODE_SIZE (SHAPE.inner_mode) / SIZE.\n+\t We need to check that the assignment will preserve all the other\n+\t SIZE-byte chunks in the inner register besides the one that\n+\t includes SUBREG.\n+\n+\t In practice it is enough to check whether an equivalent\n+\t SHAPE.inner_mode value in an adjacent SIZE-byte chunk can be formed.\n+\t If the underlying registers are small enough, both subregs will\n+\t be valid.  If the underlying registers are too large, one of the\n+\t subregs will be invalid.\n+\n+\t This relies on the fact that we've already been passed\n+\t SUBREG with PARTIAL_DEF set to false.  */\n+      unsigned int size = MAX (REGMODE_NATURAL_SIZE (shape.inner_mode),\n+\t\t\t       GET_MODE_SIZE (shape.outer_mode));\n+      gcc_checking_assert (size < GET_MODE_SIZE (shape.inner_mode));\n+      if (shape.offset >= size)\n+\tshape.offset -= size;\n+      else\n+\tshape.offset += size;\n+    }\n+\n   if (valid_mode_changes[regno])\n     AND_HARD_REG_SET (*valid_mode_changes[regno],\n-\t\t      simplifiable_subregs (shape_of_subreg (subreg)));\n+\t\t      simplifiable_subregs (shape));\n   else\n     {\n       valid_mode_changes[regno]\n \t= XOBNEW (&valid_mode_changes_obstack, HARD_REG_SET);\n       COPY_HARD_REG_SET (*valid_mode_changes[regno],\n-\t\t\t simplifiable_subregs (shape_of_subreg (subreg)));\n+\t\t\t simplifiable_subregs (shape));\n     }\n }\n \n@@ -1277,7 +1311,7 @@ find_subregs_of_mode (rtx x)\n   int i;\n \n   if (code == SUBREG)\n-    record_subregs_of_mode (x);\n+    record_subregs_of_mode (x, false);\n \n   /* Time for some deep diving.  */\n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n@@ -1305,7 +1339,14 @@ init_subregs_of_mode (void)\n   FOR_EACH_BB_FN (bb, cfun)\n     FOR_BB_INSNS (bb, insn)\n       if (NONDEBUG_INSN_P (insn))\n-        find_subregs_of_mode (PATTERN (insn));\n+\t{\n+\t  find_subregs_of_mode (PATTERN (insn));\n+\t  df_ref def;\n+\t  FOR_EACH_INSN_DEF (def, insn)\n+\t    if (DF_REF_FLAGS_IS_SET (def, DF_REF_PARTIAL)\n+\t\t&& df_read_modify_subreg_p (DF_REF_REG (def)))\n+\t      record_subregs_of_mode (DF_REF_REG (def), true);\n+\t}\n }\n \n const HARD_REG_SET *"}, {"sha": "66115f01555c97cfa34c7a3ae29c35e40fc15aab", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2692b5c857987b223dbb0f2a6086d0d9f908e4bc/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2692b5c857987b223dbb0f2a6086d0d9f908e4bc/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2692b5c857987b223dbb0f2a6086d0d9f908e4bc", "patch": "@@ -1,3 +1,8 @@\n+2016-02-04  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\tPR rtl-optimization/69577\n+\t* gcc.target/i386/pr69577.c: New test.\n+\n 2016-02-04  Martin Liska  <mliska@suse.cz>\n \n \t* g++.dg/asan/pr69276.C: New test."}, {"sha": "d680539e36f2c14ff5b075323a8bde7c6818a2fe", "filename": "gcc/testsuite/gcc.target/i386/pr69577.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2692b5c857987b223dbb0f2a6086d0d9f908e4bc/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr69577.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2692b5c857987b223dbb0f2a6086d0d9f908e4bc/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr69577.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr69577.c?ref=2692b5c857987b223dbb0f2a6086d0d9f908e4bc", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target avx } */\n+/* { dg-require-effective-target int128 } */\n+/* { dg-options \"-O -fno-forward-propagate -fno-split-wide-types -mavx\" } */\n+\n+typedef unsigned int u32;\n+typedef unsigned __int128 u128;\n+typedef unsigned __int128 v32u128 __attribute__ ((vector_size (32)));\n+\n+u128 __attribute__ ((noinline, noclone))\n+foo (u32 u32_0, v32u128 v32u128_0)\n+{\n+  v32u128_0[0] >>= u32_0;\n+  v32u128_0 += (v32u128) {u32_0, 0};\n+  return u32_0 + v32u128_0[0] + v32u128_0[1];\n+}\n+\n+int\n+main()\n+{\n+  u128 x = foo (1, (v32u128) {1, 4});\n+  if (x != 6)\n+    __builtin_abort ();\n+  return 0;\n+}"}]}