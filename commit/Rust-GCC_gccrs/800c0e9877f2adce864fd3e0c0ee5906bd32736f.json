{"sha": "800c0e9877f2adce864fd3e0c0ee5906bd32736f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODAwYzBlOTg3N2YyYWRjZTg2NGZkM2UwYzBlZTU5MDZiZDMyNzM2Zg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2018-08-17T23:18:11Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2018-08-17T23:18:11Z"}, "message": "[PATCH] Adjust lazy macro definition\n\nhttps://gcc.gnu.org/ml/gcc-patches/2018-08/msg01072.html\n\tlibcpp/\n\t* include/cpplib.h (struct cpp_callbacks): Replace\n\tuser_builtin_macro with user_lazy_macro.\n\t(struct cpp_macro): add lazy field.\n\t(enum cpp_builtin_type): Remove BT_FIRST_USER, BT_LAST_USER.\n\t(cpp_define_lazily): Declare.\n\t* macro.c (enter_macro_context) Use _cpp_maybe_notify_macro_use.\n\t(warn_of_redefinition): Use cpp_builtin_macro_p, directly call\n\tuser_lazy_macro hook.\n\t(_cpp_new_macro): Clear lazy field.\n\t(cpp_define_lazily): Define.\n\t(_cpp_notify_macro_use): Adjust lazy definition code.\n\t(cpp_macro_definition): No need to do lazy definition here.\n\t* pch.c (write_macdef, save_macros): Likewise.\n\tgcc/c-family/\n\t* c-cppbuiltin.c (struct lazy_hex_fp_value_struct): Remove macro\n\tfield.\n\t(laxy_hex_fp_value_count): Make unsigned.\n\t(lazy_hex_fp_value): Provided with macro & lazy number.  Directly\n\tmanipulate the macro.\n\t(builtin_defin_with_hex_fp_value): Adjust callback name, use\n\tcpp_define_lazily.\n\nFrom-SVN: r263640", "tree": {"sha": "d259b37b7b95254179ac5634b71a84ce199430fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d259b37b7b95254179ac5634b71a84ce199430fe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/800c0e9877f2adce864fd3e0c0ee5906bd32736f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/800c0e9877f2adce864fd3e0c0ee5906bd32736f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/800c0e9877f2adce864fd3e0c0ee5906bd32736f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/800c0e9877f2adce864fd3e0c0ee5906bd32736f/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6f0821f4468b774cefe0a00560ed4bd290835fe2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f0821f4468b774cefe0a00560ed4bd290835fe2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f0821f4468b774cefe0a00560ed4bd290835fe2"}], "stats": {"total": 180, "additions": 96, "deletions": 84}, "files": [{"sha": "6cdade5695a349b651440603366fd25494d6593d", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/800c0e9877f2adce864fd3e0c0ee5906bd32736f/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/800c0e9877f2adce864fd3e0c0ee5906bd32736f/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=800c0e9877f2adce864fd3e0c0ee5906bd32736f", "patch": "@@ -1,3 +1,13 @@\n+2018-08-17  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* c-cppbuiltin.c (struct lazy_hex_fp_value_struct): Remove macro\n+\tfield.\n+\t(laxy_hex_fp_value_count): Make unsigned.\n+\t(lazy_hex_fp_value): Provided with macro & lazy number.  Directly\n+\tmanipulate the macro.\n+\t(builtin_defin_with_hex_fp_value): Adjust callback name, use\n+\tcpp_define_lazily.\n+\n 2018-08-17  David Malcolm  <dmalcolm@redhat.com>\n \n \t* c-format.c (enum format_type): Add gcc_dump_printf_format_type."}, {"sha": "96a6b4dfd2b9e898567aeb9e9586e5738fdeb15d", "filename": "gcc/c-family/c-cppbuiltin.c", "status": "modified", "additions": 26, "deletions": 33, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/800c0e9877f2adce864fd3e0c0ee5906bd32736f/gcc%2Fc-family%2Fc-cppbuiltin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/800c0e9877f2adce864fd3e0c0ee5906bd32736f/gcc%2Fc-family%2Fc-cppbuiltin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-cppbuiltin.c?ref=800c0e9877f2adce864fd3e0c0ee5906bd32736f", "patch": "@@ -1570,7 +1570,6 @@ builtin_define_with_int_value (const char *macro, HOST_WIDE_INT value)\n struct GTY(()) lazy_hex_fp_value_struct\n {\n   const char *hex_str;\n-  cpp_macro *macro;\n   machine_mode mode;\n   int digits;\n   const char *fp_suffix;\n@@ -1583,36 +1582,35 @@ struct GTY(()) lazy_hex_fp_value_struct\n #define LAZY_HEX_FP_VALUES_CNT (4 * (3 + NUM_FLOATN_NX_TYPES))\n static GTY(()) struct lazy_hex_fp_value_struct\n   lazy_hex_fp_values[LAZY_HEX_FP_VALUES_CNT];\n-static GTY(()) int lazy_hex_fp_value_count;\n+static GTY(()) unsigned lazy_hex_fp_value_count;\n \n-static bool\n-lazy_hex_fp_value (cpp_reader *pfile ATTRIBUTE_UNUSED,\n-\t\t   cpp_hashnode *node)\n+static void\n+lazy_hex_fp_value (cpp_reader *, cpp_macro *macro, unsigned num)\n {\n   REAL_VALUE_TYPE real;\n   char dec_str[64], buf1[256];\n-  unsigned int idx;\n-  if (node->value.builtin < BT_FIRST_USER\n-      || (int) node->value.builtin >= BT_FIRST_USER + lazy_hex_fp_value_count)\n-    return false;\n \n-  idx = node->value.builtin - BT_FIRST_USER;\n-  real_from_string (&real, lazy_hex_fp_values[idx].hex_str);\n+  gcc_checking_assert (num < lazy_hex_fp_value_count);\n+\n+  real_from_string (&real, lazy_hex_fp_values[num].hex_str);\n   real_to_decimal_for_mode (dec_str, &real, sizeof (dec_str),\n-\t\t\t    lazy_hex_fp_values[idx].digits, 0,\n-\t\t\t    lazy_hex_fp_values[idx].mode);\n-\n-  sprintf (buf1, \"%s%s\", dec_str, lazy_hex_fp_values[idx].fp_suffix);\n-  node->flags &= ~(NODE_BUILTIN | NODE_USED);\n-  node->value.macro = lazy_hex_fp_values[idx].macro;\n-  for (idx = 0; idx < node->value.macro->count; idx++)\n-    if (node->value.macro->exp.tokens[idx].type == CPP_NUMBER)\n-      break;\n-  gcc_assert (idx < node->value.macro->count);\n-  node->value.macro->exp.tokens[idx].val.str.len = strlen (buf1);\n-  node->value.macro->exp.tokens[idx].val.str.text\n-    = (const unsigned char *) ggc_strdup (buf1);\n-  return true;\n+\t\t\t    lazy_hex_fp_values[num].digits, 0,\n+\t\t\t    lazy_hex_fp_values[num].mode);\n+\n+  size_t len\n+    = sprintf (buf1, \"%s%s\", dec_str, lazy_hex_fp_values[num].fp_suffix);\n+  gcc_assert (len < sizeof (buf1));\n+  for (unsigned idx = 0; idx < macro->count; idx++)\n+    if (macro->exp.tokens[idx].type == CPP_NUMBER)\n+      {\n+\tmacro->exp.tokens[idx].val.str.len = len;\n+\tmacro->exp.tokens[idx].val.str.text\n+\t  = (const unsigned char *) ggc_strdup (buf1);\n+\treturn;\n+      }\n+\n+  /* We must have replaced a token.  */\n+  gcc_unreachable ();\n }\n \n /* Pass an object-like macro a hexadecimal floating-point value.  */\n@@ -1631,23 +1629,18 @@ builtin_define_with_hex_fp_value (const char *macro,\n       && flag_dump_macros == 0\n       && !cpp_get_options (parse_in)->traditional)\n     {\n-      struct cpp_hashnode *node;\n       if (lazy_hex_fp_value_count == 0)\n-\tcpp_get_callbacks (parse_in)->user_builtin_macro = lazy_hex_fp_value;\n+\tcpp_get_callbacks (parse_in)->user_lazy_macro = lazy_hex_fp_value;\n       sprintf (buf2, fp_cast, \"1.1\");\n       sprintf (buf1, \"%s=%s\", macro, buf2);\n       cpp_define (parse_in, buf1);\n-      node = C_CPP_HASHNODE (get_identifier (macro));\n+      struct cpp_hashnode *node = C_CPP_HASHNODE (get_identifier (macro));\n       lazy_hex_fp_values[lazy_hex_fp_value_count].hex_str\n \t= ggc_strdup (hex_str);\n       lazy_hex_fp_values[lazy_hex_fp_value_count].mode = TYPE_MODE (type);\n       lazy_hex_fp_values[lazy_hex_fp_value_count].digits = digits;\n       lazy_hex_fp_values[lazy_hex_fp_value_count].fp_suffix = fp_suffix;\n-      lazy_hex_fp_values[lazy_hex_fp_value_count].macro = node->value.macro;\n-      node->flags |= NODE_BUILTIN;\n-      node->value.builtin\n-\t= (enum cpp_builtin_type) (BT_FIRST_USER + lazy_hex_fp_value_count);\n-      lazy_hex_fp_value_count++;\n+      cpp_define_lazily (parse_in, node, lazy_hex_fp_value_count++);\n       return;\n     }\n "}, {"sha": "994d424c1452603fbf911ad4e9d4447ea3e3fbb2", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/800c0e9877f2adce864fd3e0c0ee5906bd32736f/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/800c0e9877f2adce864fd3e0c0ee5906bd32736f/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=800c0e9877f2adce864fd3e0c0ee5906bd32736f", "patch": "@@ -1,5 +1,19 @@\n 2018-08-17  Nathan Sidwell  <nathan@acm.org>\n \n+\t* include/cpplib.h (struct cpp_callbacks): Replace\n+\tuser_builtin_macro with user_lazy_macro.\n+\t(struct cpp_macro): add lazy field.\n+\t(enum cpp_builtin_type): Remove BT_FIRST_USER, BT_LAST_USER.\n+\t(cpp_define_lazily): Declare.\n+\t* macro.c (enter_macro_context) Use _cpp_maybe_notify_macro_use.\n+\t(warn_of_redefinition): Use cpp_builtin_macro_p, directly call\n+\tuser_lazy_macro hook.\n+\t(_cpp_new_macro): Clear lazy field.\n+\t(cpp_define_lazily): Define.\n+\t(_cpp_notify_macro_use): Adjust lazy definition code.\n+\t(cpp_macro_definition): No need to do lazy definition here.\n+\t* pch.c (write_macdef, save_macros): Likewise.\n+\n \t* include/cpplib.h (enum cpp_macro_kind): New.\n \t(struct cpp_macro): Make body trailing array.  Add kind field,\n \tdelete traditional flag."}, {"sha": "e0be2dc28b4a5d0dcb5d2492da24da7bed20462a", "filename": "libcpp/include/cpplib.h", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/800c0e9877f2adce864fd3e0c0ee5906bd32736f/libcpp%2Finclude%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/800c0e9877f2adce864fd3e0c0ee5906bd32736f/libcpp%2Finclude%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fcpplib.h?ref=800c0e9877f2adce864fd3e0c0ee5906bd32736f", "patch": "@@ -605,8 +605,8 @@ struct cpp_callbacks\n   /* Callback to identify whether an attribute exists.  */\n   int (*has_attribute) (cpp_reader *);\n \n-  /* Callback that can change a user builtin into normal macro.  */\n-  bool (*user_builtin_macro) (cpp_reader *, cpp_hashnode *);\n+  /* Callback that can change a user lazy into normal macro.  */\n+  void (*user_lazy_macro) (cpp_reader *, cpp_macro *, unsigned);\n \n   /* Callback to parse SOURCE_DATE_EPOCH from environment.  */\n   time_t (*get_source_date_epoch) (cpp_reader *);\n@@ -698,6 +698,9 @@ struct GTY(()) cpp_macro {\n   /* Number of parameters.  */\n   unsigned short paramc;\n \n+  /* Non-zero if this is a user-lazy macro, value provided by user.  */\n+  unsigned char lazy;\n+\n   /* The kind of this macro (ISO, trad or assert) */\n   unsigned kind : 2;\n \n@@ -778,9 +781,7 @@ enum cpp_builtin_type\n   BT_PRAGMA,\t\t\t/* `_Pragma' operator */\n   BT_TIMESTAMP,\t\t\t/* `__TIMESTAMP__' */\n   BT_COUNTER,\t\t\t/* `__COUNTER__' */\n-  BT_HAS_ATTRIBUTE,\t\t/* `__has_attribute__(x)' */\n-  BT_FIRST_USER,\t\t/* User defined builtin macros.  */\n-  BT_LAST_USER = BT_FIRST_USER + 63\n+  BT_HAS_ATTRIBUTE\t\t/* `__has_attribute__(x)' */\n };\n \n #define CPP_HASHNODE(HNODE)\t((cpp_hashnode *) (HNODE))\n@@ -1001,6 +1002,9 @@ extern void cpp_assert (cpp_reader *, const char *);\n extern void cpp_undef (cpp_reader *, const char *);\n extern void cpp_unassert (cpp_reader *, const char *);\n \n+/* Mark a node as a lazily defined macro.  */\n+extern void cpp_define_lazily (cpp_reader *, cpp_hashnode *node, unsigned N);\n+\n /* Undefine all macros and assertions.  */\n extern void cpp_undef_all (cpp_reader *);\n "}, {"sha": "369a4614bbdbe73769487b6b13a90827c507d9a6", "filename": "libcpp/macro.c", "status": "modified", "additions": 36, "deletions": 38, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/800c0e9877f2adce864fd3e0c0ee5906bd32736f/libcpp%2Fmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/800c0e9877f2adce864fd3e0c0ee5906bd32736f/libcpp%2Fmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fmacro.c?ref=800c0e9877f2adce864fd3e0c0ee5906bd32736f", "patch": "@@ -1273,15 +1273,6 @@ enter_macro_context (cpp_reader *pfile, cpp_hashnode *node,\n      function where set this flag to FALSE.  */\n   pfile->about_to_expand_macro_p = true;\n \n-  if ((node->flags & NODE_BUILTIN) && !(node->flags & NODE_USED))\n-    {\n-      node->flags |= NODE_USED;\n-      if ((!pfile->cb.user_builtin_macro\n-\t   || !pfile->cb.user_builtin_macro (pfile, node))\n-\t  && pfile->cb.used_define)\n-\tpfile->cb.used_define (pfile, pfile->directive_line, node);\n-    }\n-\n   if (cpp_user_macro_p (node))\n     {\n       cpp_macro *macro = node->value.macro;\n@@ -1328,13 +1319,9 @@ enter_macro_context (cpp_reader *pfile, cpp_hashnode *node,\n       /* Disable the macro within its expansion.  */\n       node->flags |= NODE_DISABLED;\n \n-      if (!(node->flags & NODE_USED))\n-\t{\n-\t  node->flags |= NODE_USED;\n-\t  if (pfile->cb.used_define)\n-\t    pfile->cb.used_define (pfile, pfile->directive_line, node);\n-\t}\n-\n+      /* Laziness can only affect the expansion tokens of the macro,\n+\t not its fun-likeness or parameters.  */\n+      _cpp_maybe_notify_macro_use (pfile, node);\n       if (pfile->cb.used)\n \tpfile->cb.used (pfile, location, node);\n \n@@ -2993,7 +2980,6 @@ static bool\n warn_of_redefinition (cpp_reader *pfile, cpp_hashnode *node,\n \t\t      const cpp_macro *macro2)\n {\n-  const cpp_macro *macro1;\n   unsigned int i;\n \n   /* Some redefinitions need to be warned about regardless.  */\n@@ -3002,19 +2988,25 @@ warn_of_redefinition (cpp_reader *pfile, cpp_hashnode *node,\n \n   /* Suppress warnings for builtins that lack the NODE_WARN flag,\n      unless Wbuiltin-macro-redefined.  */\n-  if (node->flags & NODE_BUILTIN\n-      && (!pfile->cb.user_builtin_macro\n-\t  || !pfile->cb.user_builtin_macro (pfile, node)))\n+  if (cpp_builtin_macro_p (node))\n     return CPP_OPTION (pfile, warn_builtin_macro_redefined);\n \n   /* Redefinitions of conditional (context-sensitive) macros, on\n      the other hand, must be allowed silently.  */\n   if (node->flags & NODE_CONDITIONAL)\n     return false;\n \n+  cpp_macro *macro1 = node->value.macro;\n+  if (macro1->lazy)\n+    {\n+      /* We don't want to mark MACRO as used, but do need to finalize\n+\t its laziness.  */\n+      pfile->cb.user_lazy_macro (pfile, macro1, macro1->lazy - 1);\n+      macro1->lazy = 0;\n+    }\n+\n   /* Redefinition of a macro is allowed if and only if the old and new\n      definitions are the same.  (6.10.3 paragraph 2).  */\n-  macro1 = node->value.macro;\n \n   /* Don't check count here as it can be different in valid\n      traditional redefinitions with just whitespace differences.  */\n@@ -3481,6 +3473,7 @@ _cpp_new_macro (cpp_reader *pfile, cpp_macro_kind kind, void *placement)\n \n   macro->line = pfile->directive_line;\n   macro->params = 0;\n+  macro->lazy = 0;\n   macro->paramc = 0;\n   macro->variadic = 0;\n   macro->used = !CPP_OPTION (pfile, warn_unused_macros);\n@@ -3553,6 +3546,16 @@ _cpp_create_definition (cpp_reader *pfile, cpp_hashnode *node)\n   return true;\n }\n \n+extern void\n+cpp_define_lazily (cpp_reader *pfile, cpp_hashnode *node, unsigned num)\n+{\n+  cpp_macro *macro = node->value.macro;\n+\n+  gcc_checking_assert (pfile->cb.user_lazy_macro && macro && num < 255);\n+\n+  macro->lazy = num + 1;\n+}\n+\n /* Notify the use of NODE in a macro-aware context (i.e. expanding it,\n    or testing its existance).  Also applies any lazy definition.  */\n \n@@ -3563,9 +3566,15 @@ _cpp_notify_macro_use (cpp_reader *pfile, cpp_hashnode *node)\n   switch (node->type)\n     {\n     case NT_MACRO:\n-      if ((node->flags & NODE_BUILTIN)\n-\t  && pfile->cb.user_builtin_macro)\n-\tpfile->cb.user_builtin_macro (pfile, node);\n+      if (!(node->flags & NODE_BUILTIN))\n+\t{\n+\t  cpp_macro *macro = node->value.macro;\n+\t  if (macro->lazy)\n+\t    {\n+\t      pfile->cb.user_lazy_macro (pfile, macro, macro->lazy - 1);\n+\t      macro->lazy = 0;\n+\t    }\n+\t}\n \n       if (pfile->cb.used_define)\n \tpfile->cb.used_define (pfile, pfile->directive_line, node);\n@@ -3641,23 +3650,12 @@ const unsigned char *\n cpp_macro_definition (cpp_reader *pfile, cpp_hashnode *node)\n {\n   unsigned int i, len;\n-  const cpp_macro *macro;\n   unsigned char *buffer;\n \n-  if (node->type != NT_MACRO || (node->flags & NODE_BUILTIN))\n-    {\n-      if (node->type != NT_MACRO\n-\t  || !pfile->cb.user_builtin_macro\n-          || !pfile->cb.user_builtin_macro (pfile, node))\n-\t{\n-\t  cpp_error (pfile, CPP_DL_ICE,\n-\t\t     \"invalid hash type %d in cpp_macro_definition\",\n-\t\t     node->type);\n-\t  return 0;\n-\t}\n-    }\n+  gcc_checking_assert (cpp_user_macro_p (node));\n+\n+  const cpp_macro *macro = node->value.macro;\n \n-  macro = node->value.macro;\n   /* Calculate length.  */\n   len = NODE_LEN (node) * 10 + 2;\t\t/* ' ' and NUL.  */\n   if (macro->fun_like)"}, {"sha": "47b99c1198159bb83f1dfad7c5b3c46d2bda19c3", "filename": "libcpp/pch.c", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/800c0e9877f2adce864fd3e0c0ee5906bd32736f/libcpp%2Fpch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/800c0e9877f2adce864fd3e0c0ee5906bd32736f/libcpp%2Fpch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fpch.c?ref=800c0e9877f2adce864fd3e0c0ee5906bd32736f", "patch": "@@ -59,9 +59,7 @@ write_macdef (cpp_reader *pfile, cpp_hashnode *hn, void *file_p)\n       /* FALLTHRU */\n \n     case NT_MACRO:\n-      if ((hn->flags & NODE_BUILTIN)\n-\t  && (!pfile->cb.user_builtin_macro\n-\t      || !pfile->cb.user_builtin_macro (pfile, hn)))\n+      if (hn->flags & NODE_BUILTIN)\n \treturn 1;\n \n       {\n@@ -760,11 +758,6 @@ save_macros (cpp_reader *r, cpp_hashnode *h, void *data_p)\n {\n   struct save_macro_data *data = (struct save_macro_data *)data_p;\n \n-  if ((h->flags & NODE_BUILTIN)\n-      && h->type == NT_MACRO\n-      && r->cb.user_builtin_macro)\n-    r->cb.user_builtin_macro (r, h);\n-\n   if (h->type != NT_VOID\n       && (h->flags & NODE_BUILTIN) == 0)\n     {"}]}