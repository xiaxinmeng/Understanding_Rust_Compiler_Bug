{"sha": "f1f39033accfe89082fc2701d02bd65b57df0978", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjFmMzkwMzNhY2NmZTg5MDgyZmMyNzAxZDAyYmQ2NWI1N2RmMDk3OA==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2011-01-08T19:17:03Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2011-01-08T19:17:03Z"}, "message": "re PR fortran/46896 (Wrong code with transpose(a) passed to subroutine)\n\n2011-01-08  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/46896\n\t* trans-expr.c (gfc_conv_procedure_call): With a non-copying\n\tprocedure argument (eg TRANSPOSE) use a temporary if there is\n\tany chance of aliasing due to host or use association.\n\t(arrayfunc_assign_needs_temporary): Correct logic for function\n\tresults and do not use a temporary for implicitly PURE\n\tvariables.  Use a temporary for Cray pointees.\n\t* symbol.c (gfc_add_save): Explicit SAVE not compatible with\n\timplicit pureness of containing procedure.\n\t* decl.c (match_old_style_init, gfc_match_data): Where decl\n\twould fail in PURE procedure, set implicit_pure to zero.\n\t* gfortran.h : Add implicit_pure to structure symbol_attr and\n\tadd prototype for function gfc_implicit_pure.\n\t* expr.c (gfc_check_pointer_assign, gfc_check_vardef_context):\n\tWhere decl would fail in PURE procedure, reset implicit_pure.\n\t* io.c (match_vtag, gfc_match_open, gfc_match_close,\n\tgfc_match_print, gfc_match_inquire, gfc_match_wait): The same.\n\t* match.c (gfc_match_critical, gfc_match_stopcode,\n\tsync_statement, gfc_match_allocate, gfc_match_deallocate): The\n\tsame.\n\t* parse.c (decode_omp_directive): The same.\n\t(parse_contained): If not PURE, set implicit pure attribute.\n\t* resolve.c (resolve_formal_arglist, resolve_structure_cons,\n\tresolve_function, resolve_ordinary_assign) : The same.\n\t(gfc_implicit_pure): New function.\n\t* module.c (mio_symbol_attribute): Introduce AB_IMPLICIT_PURE\n\tto ab_attribute enum and use it in this function.\n\n2011-01-08  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/46896\n\t* gfortran.dg/transpose_optimization_2.f90 : New test.\n\nFrom-SVN: r168600", "tree": {"sha": "6cbb30f180525c7412d32456d32db59b7e9882aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6cbb30f180525c7412d32456d32db59b7e9882aa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f1f39033accfe89082fc2701d02bd65b57df0978", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1f39033accfe89082fc2701d02bd65b57df0978", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1f39033accfe89082fc2701d02bd65b57df0978", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1f39033accfe89082fc2701d02bd65b57df0978/comments", "author": null, "committer": null, "parents": [{"sha": "f69e4b94c128d3145ac7377e9d277f0bf48ffad8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f69e4b94c128d3145ac7377e9d277f0bf48ffad8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f69e4b94c128d3145ac7377e9d277f0bf48ffad8"}], "stats": {"total": 325, "additions": 308, "deletions": 17}, "files": [{"sha": "f24c22f701663bc8d5b8d006bd74360452f603d3", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1f39033accfe89082fc2701d02bd65b57df0978/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1f39033accfe89082fc2701d02bd65b57df0978/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=f1f39033accfe89082fc2701d02bd65b57df0978", "patch": "@@ -1,3 +1,33 @@\n+2011-01-08  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/46896\n+\t* trans-expr.c (gfc_conv_procedure_call): With a non-copying\n+\tprocedure argument (eg TRANSPOSE) use a temporary if there is\n+\tany chance of aliasing due to host or use association.\n+\t(arrayfunc_assign_needs_temporary): Correct logic for function\n+\tresults and do not use a temporary for implicitly PURE\n+\tvariables.  Use a temporary for Cray pointees.\n+\t* symbol.c (gfc_add_save): Explicit SAVE not compatible with\n+\timplicit pureness of containing procedure.\n+\t* decl.c (match_old_style_init, gfc_match_data): Where decl\n+\twould fail in PURE procedure, set implicit_pure to zero.\n+\t* gfortran.h : Add implicit_pure to structure symbol_attr and\n+\tadd prototype for function gfc_implicit_pure.\n+\t* expr.c (gfc_check_pointer_assign, gfc_check_vardef_context):\n+\tWhere decl would fail in PURE procedure, reset implicit_pure.\n+\t* io.c (match_vtag, gfc_match_open, gfc_match_close,\n+\tgfc_match_print, gfc_match_inquire, gfc_match_wait): The same.\n+\t* match.c (gfc_match_critical, gfc_match_stopcode,\n+\tsync_statement, gfc_match_allocate, gfc_match_deallocate): The\n+\tsame.\n+\t* parse.c (decode_omp_directive): The same.\n+\t(parse_contained): If not PURE, set implicit pure attribute.\n+\t* resolve.c (resolve_formal_arglist, resolve_structure_cons,\n+\tresolve_function, resolve_ordinary_assign) : The same.\n+\t(gfc_implicit_pure): New function.\n+\t* module.c (mio_symbol_attribute): Introduce AB_IMPLICIT_PURE\n+\tto ab_attribute enum and use it in this function.\n+\n 2011-01-08  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/45777"}, {"sha": "638a7386d156cb950953cc9816dcebd6c0f6163e", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1f39033accfe89082fc2701d02bd65b57df0978/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1f39033accfe89082fc2701d02bd65b57df0978/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=f1f39033accfe89082fc2701d02bd65b57df0978", "patch": "@@ -1,5 +1,5 @@\n /* Declaration statement matcher\n-   Copyright (C) 2002, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n+   Copyright (C) 2002, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011\n    Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n \n@@ -502,6 +502,9 @@ match_old_style_init (const char *name)\n       return MATCH_ERROR;\n     }\n \n+  if (gfc_implicit_pure (NULL))\n+    gfc_current_ns->proc_name->attr.implicit_pure = 0;\n+\n   /* Mark the variable as having appeared in a data statement.  */\n   if (gfc_add_data (&sym->attr, sym->name, &sym->declared_at) == FAILURE)\n     {\n@@ -560,6 +563,9 @@ gfc_match_data (void)\n       return MATCH_ERROR;\n     }\n \n+  if (gfc_implicit_pure (NULL))\n+    gfc_current_ns->proc_name->attr.implicit_pure = 0;\n+\n   return MATCH_YES;\n \n cleanup:"}, {"sha": "3f1141a0e0b618e4758ef8906232b2249b98038a", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1f39033accfe89082fc2701d02bd65b57df0978/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1f39033accfe89082fc2701d02bd65b57df0978/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=f1f39033accfe89082fc2701d02bd65b57df0978", "patch": "@@ -1,6 +1,6 @@\n /* Routines for manipulation of expression nodes.\n    Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,\n-   2009, 2010\n+   2009, 2010, 2011\n    Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n \n@@ -3227,7 +3227,7 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n {\n   symbol_attribute attr;\n   gfc_ref *ref;\n-  bool is_pure, rank_remap;\n+  bool is_pure, is_implicit_pure, rank_remap;\n   int proc_pointer;\n \n   if (lvalue->symtree->n.sym->ts.type == BT_UNKNOWN\n@@ -3311,6 +3311,7 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n     }\n \n   is_pure = gfc_pure (NULL);\n+  is_implicit_pure = gfc_implicit_pure (NULL);\n \n   /* If rvalue is a NULL() or NULLIFY, we're done. Otherwise the type,\n      kind, etc for lvalue and rvalue must match, and rvalue must be a\n@@ -3519,6 +3520,10 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n \t\t \"procedure at %L\", &rvalue->where);\n     }\n \n+  if (is_implicit_pure && gfc_impure_variable (rvalue->symtree->n.sym))\n+    gfc_current_ns->proc_name->attr.implicit_pure = 0;\n+    \n+\n   if (gfc_has_vector_index (rvalue))\n     {\n       gfc_error (\"Pointer assignment with vector subscript \"\n@@ -4461,6 +4466,9 @@ gfc_check_vardef_context (gfc_expr* e, bool pointer, const char* context)\n       return FAILURE;\n     }\n \n+  if (!pointer && gfc_implicit_pure (NULL) && gfc_impure_variable (sym))\n+    gfc_current_ns->proc_name->attr.implicit_pure = 0;\n+\n   /* Check variable definition context for associate-names.  */\n   if (!pointer && sym->assoc)\n     {"}, {"sha": "d0377f9745785c0128a02856457eb91369c92133", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1f39033accfe89082fc2701d02bd65b57df0978/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1f39033accfe89082fc2701d02bd65b57df0978/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=f1f39033accfe89082fc2701d02bd65b57df0978", "patch": "@@ -1,6 +1,6 @@\n /* gfortran header file\n    Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,\n-   2009, 2010\n+   2009, 2010, 2011\n    Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n \n@@ -723,6 +723,11 @@ typedef struct\n   unsigned sequence:1, elemental:1, pure:1, recursive:1;\n   unsigned unmaskable:1, masked:1, contained:1, mod_proc:1, abstract:1;\n \n+  /* This is set if a contained procedure could be declared pure.  This is\n+     used for certain optimizations that require the result or arguments\n+     cannot alias.  Note that this is zero for PURE procedures.  */\n+  unsigned implicit_pure:1;\n+\n   /* This is set if the subroutine doesn't return.  Currently, this\n      is only possible for intrinsic subroutines.  */\n   unsigned noreturn:1;\n@@ -2736,6 +2741,7 @@ void gfc_resolve (gfc_namespace *);\n void gfc_resolve_blocks (gfc_code *, gfc_namespace *);\n int gfc_impure_variable (gfc_symbol *);\n int gfc_pure (gfc_symbol *);\n+int gfc_implicit_pure (gfc_symbol *);\n int gfc_elemental (gfc_symbol *);\n gfc_try gfc_resolve_iterator (gfc_iterator *, bool);\n gfc_try find_forall_index (gfc_expr *, gfc_symbol *, int);"}, {"sha": "b8a6a4a307512b492f503e0fbac6534f8b534911", "filename": "gcc/fortran/io.c", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1f39033accfe89082fc2701d02bd65b57df0978/gcc%2Ffortran%2Fio.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1f39033accfe89082fc2701d02bd65b57df0978/gcc%2Ffortran%2Fio.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fio.c?ref=f1f39033accfe89082fc2701d02bd65b57df0978", "patch": "@@ -1,6 +1,6 @@\n /* Deal with I/O statements & related stuff.\n    Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,\n-   2009, 2010\n+   2009, 2010, 2011\n    Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n \n@@ -1315,6 +1315,9 @@ match_vtag (const io_tag *tag, gfc_expr **v)\n       return MATCH_ERROR;\n     }\n \n+  if (gfc_implicit_pure (NULL) && gfc_impure_variable (result->symtree->n.sym))\n+    gfc_current_ns->proc_name->attr.implicit_pure = 0;\n+\n   *v = result;\n   return MATCH_YES;\n }\n@@ -1824,6 +1827,9 @@ gfc_match_open (void)\n       goto cleanup;\n     }\n \n+  if (gfc_implicit_pure (NULL))\n+    gfc_current_ns->proc_name->attr.implicit_pure = 0;\n+\n   warn = (open->err || open->iostat) ? true : false;\n \n   /* Checks on NEWUNIT specifier.  */\n@@ -2238,6 +2244,9 @@ gfc_match_close (void)\n       goto cleanup;\n     }\n \n+  if (gfc_implicit_pure (NULL))\n+    gfc_current_ns->proc_name->attr.implicit_pure = 0;\n+\n   warn = (close->iostat || close->err) ? true : false;\n \n   /* Checks on the STATUS specifier.  */\n@@ -2385,6 +2394,9 @@ match_filepos (gfc_statement st, gfc_exec_op op)\n       goto cleanup;\n     }\n \n+  if (gfc_implicit_pure (NULL))\n+    gfc_current_ns->proc_name->attr.implicit_pure = 0;\n+\n   new_st.op = op;\n   new_st.ext.filepos = fp;\n   return MATCH_YES;\n@@ -3223,6 +3235,10 @@ if (condition) \\\n \t\t     \"IO UNIT in %s statement at %C must be \"\n \t\t     \"an internal file in a PURE procedure\",\n \t\t     io_kind_name (k));\n+\n+      if (gfc_implicit_pure (NULL) && (k == M_READ || k == M_WRITE))\n+\tgfc_current_ns->proc_name->attr.implicit_pure = 0;\n+\n     }\n \n   if (k != M_READ)\n@@ -3753,6 +3769,9 @@ gfc_match_print (void)\n       return MATCH_ERROR;\n     }\n \n+  if (gfc_implicit_pure (NULL))\n+    gfc_current_ns->proc_name->attr.implicit_pure = 0;\n+\n   return MATCH_YES;\n }\n \n@@ -3909,6 +3928,9 @@ gfc_match_inquire (void)\n \t  return MATCH_ERROR;\n \t}\n \n+      if (gfc_implicit_pure (NULL))\n+\tgfc_current_ns->proc_name->attr.implicit_pure = 0;\n+\n       new_st.block = gfc_get_code ();\n       new_st.block->op = EXEC_IOLENGTH;\n       terminate_io (code);\n@@ -3959,6 +3981,9 @@ gfc_match_inquire (void)\n       gfc_error (\"INQUIRE statement not allowed in PURE procedure at %C\");\n       goto cleanup;\n     }\n+\n+  if (gfc_implicit_pure (NULL))\n+    gfc_current_ns->proc_name->attr.implicit_pure = 0;\n   \n   if (inquire->id != NULL && inquire->pending == NULL)\n     {\n@@ -4142,6 +4167,9 @@ gfc_match_wait (void)\n       goto cleanup;\n     }\n \n+  if (gfc_implicit_pure (NULL))\n+    gfc_current_ns->proc_name->attr.implicit_pure = 0;\n+\n   new_st.op = EXEC_WAIT;\n   new_st.ext.wait = wait;\n "}, {"sha": "926fea7ee53b246e689168950ca396a90fd5583c", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1f39033accfe89082fc2701d02bd65b57df0978/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1f39033accfe89082fc2701d02bd65b57df0978/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=f1f39033accfe89082fc2701d02bd65b57df0978", "patch": "@@ -1,7 +1,7 @@\n /* Matching subroutines in all sizes, shapes and colors.\n    Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,\n-   2009, 2010\n-   2010 Free Software Foundation, Inc.\n+   2009, 2010, 2011\n+   Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n \n This file is part of GCC.\n@@ -1746,6 +1746,9 @@ gfc_match_critical (void)\n       return MATCH_ERROR;\n     }\n \n+  if (gfc_implicit_pure (NULL))\n+    gfc_current_ns->proc_name->attr.implicit_pure = 0;\n+\n   if (gfc_notify_std (GFC_STD_F2008, \"Fortran 2008: CRITICAL statement at %C\")\n       == FAILURE)\n     return MATCH_ERROR;\n@@ -2189,6 +2192,9 @@ gfc_match_stopcode (gfc_statement st)\n       goto cleanup;\n     }\n \n+  if (gfc_implicit_pure (NULL))\n+    gfc_current_ns->proc_name->attr.implicit_pure = 0;\n+\n   if (st == ST_STOP && gfc_find_state (COMP_CRITICAL) == SUCCESS)\n     {\n       gfc_error (\"Image control statement STOP at %C in CRITICAL block\");\n@@ -2321,6 +2327,9 @@ sync_statement (gfc_statement st)\n       return MATCH_ERROR;\n     }\n \n+  if (gfc_implicit_pure (NULL))\n+    gfc_current_ns->proc_name->attr.implicit_pure = 0;\n+\n   if (gfc_notify_std (GFC_STD_F2008, \"Fortran 2008: SYNC statement at %C\")\n       == FAILURE)\n     return MATCH_ERROR;\n@@ -2920,6 +2929,10 @@ gfc_match_allocate (void)\n \t  goto cleanup;\n \t}\n \n+      if (gfc_implicit_pure (NULL)\n+\t    && gfc_impure_variable (tail->expr->symtree->n.sym))\n+\tgfc_current_ns->proc_name->attr.implicit_pure = 0;\n+\n       if (tail->expr->ts.deferred)\n \t{\n \t  saw_deferred = true;\n@@ -3263,6 +3276,9 @@ gfc_match_deallocate (void)\n \t  goto cleanup;\n \t}\n \n+      if (gfc_implicit_pure (NULL) && gfc_impure_variable (sym))\n+\tgfc_current_ns->proc_name->attr.implicit_pure = 0;\n+\n       /* FIXME: disable the checking on derived types.  */\n       b1 = !(tail->expr->ref\n \t   && (tail->expr->ref->type == REF_COMPONENT"}, {"sha": "8de19273f34fb7e99f86cc413bc893d3915982bf", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1f39033accfe89082fc2701d02bd65b57df0978/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1f39033accfe89082fc2701d02bd65b57df0978/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=f1f39033accfe89082fc2701d02bd65b57df0978", "patch": "@@ -1,7 +1,7 @@\n /* Handle modules, which amounts to loading and saving symbols and\n    their attendant structures.\n    Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,\n-   2009, 2010\n+   2009, 2010, 2011\n    Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n \n@@ -1675,7 +1675,8 @@ typedef enum\n   AB_POINTER_COMP, AB_PRIVATE_COMP, AB_VALUE, AB_VOLATILE, AB_PROTECTED,\n   AB_IS_BIND_C, AB_IS_C_INTEROP, AB_IS_ISO_C, AB_ABSTRACT, AB_ZERO_COMP,\n   AB_IS_CLASS, AB_PROCEDURE, AB_PROC_POINTER, AB_ASYNCHRONOUS, AB_CODIMENSION,\n-  AB_COARRAY_COMP, AB_VTYPE, AB_VTAB, AB_CONTIGUOUS, AB_CLASS_POINTER\n+  AB_COARRAY_COMP, AB_VTYPE, AB_VTAB, AB_CONTIGUOUS, AB_CLASS_POINTER,\n+  AB_IMPLICIT_PURE\n }\n ab_attribute;\n \n@@ -1725,6 +1726,7 @@ static const mstring attr_bits[] =\n     minit (\"VTYPE\", AB_VTYPE),\n     minit (\"VTAB\", AB_VTAB),\n     minit (\"CLASS_POINTER\", AB_CLASS_POINTER),\n+    minit (\"IMPLICIT_PURE\", AB_IMPLICIT_PURE),\n     minit (NULL, -1)\n };\n \n@@ -1859,6 +1861,8 @@ mio_symbol_attribute (symbol_attribute *attr)\n \tMIO_NAME (ab_attribute) (AB_ELEMENTAL, attr_bits);\n       if (attr->pure)\n \tMIO_NAME (ab_attribute) (AB_PURE, attr_bits);\n+      if (attr->implicit_pure)\n+\tMIO_NAME (ab_attribute) (AB_IMPLICIT_PURE, attr_bits);\n       if (attr->recursive)\n \tMIO_NAME (ab_attribute) (AB_RECURSIVE, attr_bits);\n       if (attr->always_explicit)\n@@ -1990,6 +1994,9 @@ mio_symbol_attribute (symbol_attribute *attr)\n \t    case AB_PURE:\n \t      attr->pure = 1;\n \t      break;\n+\t    case AB_IMPLICIT_PURE:\n+\t      attr->implicit_pure = 1;\n+\t      break;\n \t    case AB_RECURSIVE:\n \t      attr->recursive = 1;\n \t      break;"}, {"sha": "e7898cc56214a9af540e3bee9fcf57d644c15c61", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1f39033accfe89082fc2701d02bd65b57df0978/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1f39033accfe89082fc2701d02bd65b57df0978/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=f1f39033accfe89082fc2701d02bd65b57df0978", "patch": "@@ -1,6 +1,6 @@\n /* Main parser.\n    Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,\n-   2009, 2010\n+   2009, 2010, 2011\n    Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n \n@@ -495,6 +495,9 @@ decode_omp_directive (void)\n       return ST_NONE;\n     }\n \n+  if (gfc_implicit_pure (NULL))\n+    gfc_current_ns->proc_name->attr.implicit_pure = 0;\n+\n   old_locus = gfc_current_locus;\n \n   /* General OpenMP directive matching: Instead of testing every possible\n@@ -3850,6 +3853,12 @@ parse_contained (int module)\n \t  sym->attr.contained = 1;\n \t  sym->attr.referenced = 1;\n \n+\t  /* Set implicit_pure so that it can be reset if any of the\n+\t     tests for purity fail.  This is used for some optimisation\n+\t     during translation.  */\n+\t  if (!sym->attr.pure)\n+\t    sym->attr.implicit_pure = 1;\n+\n \t  parse_progunit (ST_NONE);\n \n \t  /* Fix up any sibling functions that refer to this one.  */"}, {"sha": "fec84cc71e97aea6888c8992ea6e2ada7d678013", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 72, "deletions": 1, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1f39033accfe89082fc2701d02bd65b57df0978/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1f39033accfe89082fc2701d02bd65b57df0978/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=f1f39033accfe89082fc2701d02bd65b57df0978", "patch": "@@ -1,5 +1,6 @@\n /* Perform type resolution on the various structures.\n-   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n+   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,\n+   2010, 2011\n    Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n \n@@ -273,6 +274,9 @@ resolve_formal_arglist (gfc_symbol *proc)\n \t      continue;\n \t    }\n \n+\t  if (proc->attr.implicit_pure && !gfc_pure(sym))\n+\t    proc->attr.implicit_pure = 0;\n+\n \t  if (gfc_elemental (proc))\n \t    {\n \t      gfc_error (\"Dummy procedure at %L not allowed in ELEMENTAL \"\n@@ -345,6 +349,16 @@ resolve_formal_arglist (gfc_symbol *proc)\n \t\t       &sym->declared_at);\n \t}\n \n+      if (proc->attr.implicit_pure && !sym->attr.pointer\n+\t  && sym->attr.flavor != FL_PROCEDURE)\n+\t{\n+\t  if (proc->attr.function && sym->attr.intent != INTENT_IN)\n+\t    proc->attr.implicit_pure = 0;\n+\n+\t  if (proc->attr.subroutine && sym->attr.intent == INTENT_UNKNOWN)\n+\t    proc->attr.implicit_pure = 0;\n+\t}\n+\n       if (gfc_elemental (proc))\n \t{\n \t  /* F2008, C1289.  */\n@@ -1124,6 +1138,12 @@ resolve_structure_cons (gfc_expr *expr, int init)\n \t\t     comp->name, &cons->expr->where);\n \t}\n \n+      if (gfc_implicit_pure (NULL)\n+\t    && cons->expr->expr_type == EXPR_VARIABLE\n+\t    && (gfc_impure_variable (cons->expr->symtree->n.sym)\n+\t\t|| gfc_is_coindexed (cons->expr)))\n+\tgfc_current_ns->proc_name->attr.implicit_pure = 0;\n+\n     }\n \n   return t;\n@@ -3067,6 +3087,9 @@ resolve_function (gfc_expr *expr)\n \t}\n     }\n \n+  if (!pure_function (expr, &name) && name && gfc_implicit_pure (NULL))\n+    gfc_current_ns->proc_name->attr.implicit_pure = 0;\n+\n   /* Functions without the RECURSIVE attribution are not allowed to\n    * call themselves.  */\n   if (expr->value.function.esym && !expr->value.function.esym->attr.recursive)\n@@ -8812,6 +8835,26 @@ resolve_ordinary_assign (gfc_code *code, gfc_namespace *ns)\n \t}\n     }\n \n+  if (gfc_implicit_pure (NULL))\n+    {\n+      if (lhs->expr_type == EXPR_VARIABLE\n+\t    && lhs->symtree->n.sym != gfc_current_ns->proc_name\n+\t    && lhs->symtree->n.sym->ns != gfc_current_ns)\n+\tgfc_current_ns->proc_name->attr.implicit_pure = 0;\n+\n+      if (lhs->ts.type == BT_DERIVED\n+\t    && lhs->expr_type == EXPR_VARIABLE\n+\t    && lhs->ts.u.derived->attr.pointer_comp\n+\t    && rhs->expr_type == EXPR_VARIABLE\n+\t    && (gfc_impure_variable (rhs->symtree->n.sym)\n+\t\t|| gfc_is_coindexed (rhs)))\n+\tgfc_current_ns->proc_name->attr.implicit_pure = 0;\n+\n+      /* Fortran 2008, C1283.  */\n+      if (gfc_is_coindexed (lhs))\n+\tgfc_current_ns->proc_name->attr.implicit_pure = 0;\n+    }\n+\n   /* F03:7.4.1.2.  */\n   /* FIXME: Valid in Fortran 2008, unless the LHS is both polymorphic\n      and coindexed; cf. F2008, 7.2.1.2 and PR 43366.  */\n@@ -12764,6 +12807,34 @@ gfc_pure (gfc_symbol *sym)\n }\n \n \n+/* Test whether a symbol is implicitly pure or not.  For a NULL pointer,\n+   checks if the current namespace is implicitly pure.  Note that this\n+   function returns false for a PURE procedure.  */\n+\n+int\n+gfc_implicit_pure (gfc_symbol *sym)\n+{\n+  symbol_attribute attr;\n+\n+  if (sym == NULL)\n+    {\n+      /* Check if the current namespace is implicit_pure.  */\n+      sym = gfc_current_ns->proc_name;\n+      if (sym == NULL)\n+\treturn 0;\n+      attr = sym->attr;\n+      if (attr.flavor == FL_PROCEDURE\n+\t    && attr.implicit_pure && !attr.pure)\n+\treturn 1;\n+      return 0;\n+    }\n+\n+  attr = sym->attr;\n+\n+  return attr.flavor == FL_PROCEDURE && attr.implicit_pure && !attr.pure;\n+}\n+\n+\n /* Test whether the current procedure is elemental or not.  */\n \n int"}, {"sha": "cb5a08f87e09cd23001cddf7cadcb269fd6ac1fc", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1f39033accfe89082fc2701d02bd65b57df0978/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1f39033accfe89082fc2701d02bd65b57df0978/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=f1f39033accfe89082fc2701d02bd65b57df0978", "patch": "@@ -1,6 +1,6 @@\n /* Maintain binary trees of symbols.\n    Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,\n-   2009, 2010\n+   2009, 2010, 2011\n    Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n \n@@ -1110,6 +1110,9 @@ gfc_add_save (symbol_attribute *attr, save_state s, const char *name,\n       return FAILURE;\n     }\n \n+  if (s == SAVE_EXPLICIT && gfc_implicit_pure (NULL))\n+    gfc_current_ns->proc_name->attr.implicit_pure = 0;\n+\n   if (s == SAVE_EXPLICIT && attr->save == SAVE_EXPLICIT)\n     {\n \tif (gfc_notify_std (GFC_STD_LEGACY, "}, {"sha": "42e259354d18b4ba05f79a409bc0b677f525be00", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 42, "deletions": 5, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1f39033accfe89082fc2701d02bd65b57df0978/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1f39033accfe89082fc2701d02bd65b57df0978/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=f1f39033accfe89082fc2701d02bd65b57df0978", "patch": "@@ -1,5 +1,6 @@\n /* Expression translation\n-   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n+   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,\n+   2011\n    Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n    and Steven Bosscher <s.bosscher@student.tudelft.nl>\n@@ -3078,6 +3079,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t argument and another one.  */\n \t      if (gfc_get_noncopying_intrinsic_argument (e) != NULL)\n \t\t{\n+\t\t  gfc_expr *iarg;\n \t\t  sym_intent intent;\n \n \t\t  if (fsym != NULL)\n@@ -3088,6 +3090,25 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t  if (gfc_check_fncall_dependency (e, intent, sym, args,\n \t\t\t\t\t\t   NOT_ELEMENTAL))\n \t\t    parmse.force_tmp = 1;\n+\n+\t\t  iarg = e->value.function.actual->expr;\n+\n+\t\t  /* Temporary needed if aliasing due to host association.  */\n+\t\t  if (sym->attr.contained\n+\t\t\t&& !sym->attr.pure\n+\t\t\t&& !sym->attr.implicit_pure\n+\t\t\t&& !sym->attr.use_assoc\n+\t\t\t&& iarg->expr_type == EXPR_VARIABLE\n+\t\t\t&& sym->ns == iarg->symtree->n.sym->ns)\n+\t\t    parmse.force_tmp = 1;\n+\n+\t\t  /* Ditto within module.  */\n+\t\t  if (sym->attr.use_assoc\n+\t\t\t&& !sym->attr.pure\n+\t\t\t&& !sym->attr.implicit_pure\n+\t\t\t&& iarg->expr_type == EXPR_VARIABLE\n+\t\t\t&& sym->module == iarg->symtree->n.sym->module)\n+\t\t    parmse.force_tmp = 1;\n \t\t}\n \n \t      if (e->expr_type == EXPR_VARIABLE\n@@ -3382,7 +3403,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \n \t  /* If the lhs of an assignment x = f(..) is allocatable and\n \t     f2003 is allowed, we must do the automatic reallocation.\n-\t     TODO - deal with instrinsics, without using a temporary.  */\n+\t     TODO - deal with intrinsics, without using a temporary.  */\n \t  if (gfc_option.flag_realloc_lhs\n \t\t&& se->ss && se->ss->loop_chain\n \t\t&& se->ss->loop_chain->is_alloc_lhs\n@@ -5376,18 +5397,34 @@ arrayfunc_assign_needs_temporary (gfc_expr * expr1, gfc_expr * expr2)\n   if (sym->attr.dummy && sym->attr.intent != INTENT_OUT)\n     return true;\n \n+  /* If the lhs has been host_associated, is in common, a pointer or is\n+     a target and the function is not using a RESULT variable, aliasing\n+     can occur and a temporary is needed.  */\n+  if ((sym->attr.host_assoc\n+\t   || sym->attr.in_common\n+\t   || sym->attr.pointer\n+\t   || sym->attr.cray_pointee\n+\t   || sym->attr.target)\n+\t&& expr2->symtree != NULL\n+\t&& expr2->symtree->n.sym == expr2->symtree->n.sym->result)\n+    return true;\n+\n   /* A PURE function can unconditionally be called without a temporary.  */\n   if (expr2->value.function.esym != NULL\n       && expr2->value.function.esym->attr.pure)\n     return false;\n \n-  /* TODO a function that could correctly be declared PURE but is not\n-     could do with returning false as well.  */\n+  /* Implicit_pure functions are those which could legally be declared\n+     to be PURE.  */\n+  if (expr2->value.function.esym != NULL\n+      && expr2->value.function.esym->attr.implicit_pure)\n+    return false;\n \n   if (!sym->attr.use_assoc\n \t&& !sym->attr.in_common\n \t&& !sym->attr.pointer\n \t&& !sym->attr.target\n+\t&& !sym->attr.cray_pointee\n \t&& expr2->value.function.esym)\n     {\n       /* A temporary is not needed if the function is not contained and\n@@ -6003,7 +6040,7 @@ gfc_trans_assignment (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,\n \t\t      bool dealloc)\n {\n   tree tmp;\n-  \n+\n   if (expr1->ts.type == BT_CHARACTER && expr1->ts.deferred)\n     {\n       gfc_error (\"Assignment to deferred-length character variable at %L \""}, {"sha": "2824845e5a68721ce0f89af229d52841bdd4835e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1f39033accfe89082fc2701d02bd65b57df0978/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1f39033accfe89082fc2701d02bd65b57df0978/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f1f39033accfe89082fc2701d02bd65b57df0978", "patch": "@@ -1,3 +1,8 @@\n+2011-01-08  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/46896\n+\t* gfortran.dg/transpose_optimization_2.f90 : New test.\n+\n 2011-01-08  Jan Hubicka  <jh@suse.cz>\n \n \tPR tree-optmization/46469"}, {"sha": "08923329ff4a1b124661ee0094841cd0b3cff153", "filename": "gcc/testsuite/gfortran.dg/transpose_optimization_2.f90", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1f39033accfe89082fc2701d02bd65b57df0978/gcc%2Ftestsuite%2Fgfortran.dg%2Ftranspose_optimization_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1f39033accfe89082fc2701d02bd65b57df0978/gcc%2Ftestsuite%2Fgfortran.dg%2Ftranspose_optimization_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftranspose_optimization_2.f90?ref=f1f39033accfe89082fc2701d02bd65b57df0978", "patch": "@@ -0,0 +1,65 @@\n+! { dg-do run }\n+! { dg-options \"-fdump-tree-original \" }\n+! Checks the fix for PR46896, in which the optimization that passes\n+! the argument of TRANSPOSE directly missed the possible aliasing\n+! through host association.\n+!\n+! Contributed by Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+!\n+module mod\n+  integer :: b(2,3) = reshape([1,2,3,4,5,6], [2,3])\n+contains\n+  subroutine msub(x)\n+    integer :: x(:,:)\n+    b(1,:) = 99\n+    b(2,:) = x(:,1)\n+    if (any (b(:,1) /= [99, 1]).or.any (b(:,2) /= [99, 3])) call abort()\n+  end subroutine msub\n+  subroutine pure_msub(x, y)\n+    integer, intent(in) :: x(:,:)\n+    integer, intent(OUT) :: y(size (x, 2), size (x, 1))\n+    y = transpose (x)\n+  end subroutine pure_msub\n+end\n+\n+  use mod\n+  integer :: a(2,3) = reshape([1,2,3,4,5,6], [2,3])\n+  call impure\n+  call purity\n+contains\n+!\n+! pure_sub and pure_msub could be PURE, if so declared.  They do not\n+! need a temporary.\n+!\n+  subroutine purity\n+    integer :: c(2,3)\n+    call pure_sub(transpose(a), c)\n+    if (any (c .ne. a)) call abort\n+    call pure_msub(transpose(b), c)\n+    if (any (c .ne. b)) call abort\n+  end subroutine purity\n+!\n+! sub and msub both need temporaries to avoid aliasing.\n+!\n+  subroutine impure\n+    call sub(transpose(a))\n+  end subroutine impure\n+\n+  subroutine sub(x)\n+    integer :: x(:,:)\n+    a(1,:) = 88\n+    a(2,:) = x(:,1)\n+    if (any (a(:,1) /= [88, 1]).or.any (a(:,2) /= [88, 3])) call abort()\n+  end subroutine sub\n+  subroutine pure_sub(x, y)\n+    integer, intent(in) :: x(:,:)\n+    integer, intent(OUT) :: y(size (x, 2), size (x, 1))\n+    y = transpose (x)\n+  end subroutine pure_sub\n+end\n+!\n+! The check below for temporaries gave 14 and 33 for \"parm\" and \"atmp\".\n+!\n+! { dg-final { scan-tree-dump-times \"parm\" 66 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"atmp\" 12 \"original\" } }\n+! { dg-final { cleanup-modules \"mod\" } }"}]}