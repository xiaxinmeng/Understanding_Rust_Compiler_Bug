{"sha": "1f3d3a31617991a3ded514cd78e0c7dae081390c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWYzZDNhMzE2MTc5OTFhM2RlZDUxNGNkNzhlMGM3ZGFlMDgxMzkwYw==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-12-18T22:42:41Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-12-18T22:42:41Z"}, "message": "integrate.c (get_label_from_map): New function.\n\n        * integrate.c (get_label_from_map): New function.\n        (expand_inline_function): Use it.  Initialize the label_map to\n        NULL_RTX instead of gen_label_rtx.\n        (copy_rtx_and_substitute): Use get_label_from_map.\n        * integrate.h (get_label_from_map): New function.\n        (set_label_from_map): New macro.\n        * unroll.c (unroll_loop): Use them.\n        (copy_loop_body): Ditto.\n\nFrom-SVN: r17139", "tree": {"sha": "070f1def188c90a7cf968b88a5a1f1a8d66b386d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/070f1def188c90a7cf968b88a5a1f1a8d66b386d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1f3d3a31617991a3ded514cd78e0c7dae081390c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f3d3a31617991a3ded514cd78e0c7dae081390c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f3d3a31617991a3ded514cd78e0c7dae081390c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f3d3a31617991a3ded514cd78e0c7dae081390c/comments", "author": null, "committer": null, "parents": [{"sha": "6ba4439c3b168c79fb4a9eed9e6491f39752b57d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ba4439c3b168c79fb4a9eed9e6491f39752b57d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ba4439c3b168c79fb4a9eed9e6491f39752b57d"}], "stats": {"total": 81, "additions": 60, "deletions": 21}, "files": [{"sha": "e88f16aa59f49d02cd698f889959d969c2c1a7ba", "filename": "gcc/integrate.c", "status": "modified", "additions": 29, "deletions": 6, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f3d3a31617991a3ded514cd78e0c7dae081390c/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f3d3a31617991a3ded514cd78e0c7dae081390c/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=1f3d3a31617991a3ded514cd78e0c7dae081390c", "patch": "@@ -77,6 +77,25 @@ static void set_block_abstract_flags PROTO((tree, int));\n \n void set_decl_abstract_flags\tPROTO((tree, int));\n \f\n+/* Returns the Ith entry in the label_map contained in MAP.  If the\n+   Ith entry has not yet been set, it is assumed to be a fresh label.\n+   Essentially, we use this function to perform a lazy initialization\n+   of label_map, thereby avoiding huge memory explosions when the\n+   label_map gets very large.  */\n+rtx\n+get_label_from_map (map, i)\n+     struct inline_remap* map;\n+     int i;\n+{\n+  rtx x = map->label_map[i];\n+\n+  if (x == NULL_RTX)\n+    x = map->label_map[i] = gen_label_rtx();\n+\n+  return x;\n+}\n+\n+\n /* Zero if the current function (whose FUNCTION_DECL is FNDECL)\n    is safe and reasonable to integrate into other functions.\n    Nonzero means value is a warning message with a single %s\n@@ -1767,7 +1786,7 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n \n   /* Make new label equivalences for the labels in the called function.  */\n   for (i = min_labelno; i < max_labelno; i++)\n-    map->label_map[i] = gen_label_rtx ();\n+    map->label_map[i] = NULL_RTX;\n \n   /* Perform postincrements before actually calling the function.  */\n   emit_queue ();\n@@ -1966,7 +1985,9 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n \t  break;\n \n \tcase CODE_LABEL:\n-\t  copy = emit_label (map->label_map[CODE_LABEL_NUMBER (insn)]);\n+\t  copy = \n+\t    emit_label (get_label_from_map(map,\n+\t\t\t\t\t   CODE_LABEL_NUMBER (insn)));\n \t  LABEL_NAME (copy) = LABEL_NAME (insn);\n \t  map->const_age++;\n \t  break;\n@@ -1989,7 +2010,8 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n \t      if (copy && (NOTE_LINE_NUMBER (copy) == NOTE_INSN_EH_REGION_BEG\n \t\t\t   || NOTE_LINE_NUMBER (copy) == NOTE_INSN_EH_REGION_END))\n \t\t{\n-\t\t  rtx label = map->label_map[NOTE_BLOCK_NUMBER (copy)];\n+\t\t  rtx label =\n+\t\t    get_label_from_map (map, NOTE_BLOCK_NUMBER (copy));\n \n \t\t  /* We have to forward these both to match the new exception\n \t\t     region.  */\n@@ -2404,14 +2426,15 @@ copy_rtx_and_substitute (orig, map)\n       return gen_rtx (code, VOIDmode, copy);\n \n     case CODE_LABEL:\n-      LABEL_PRESERVE_P (map->label_map[CODE_LABEL_NUMBER (orig)])\n+      LABEL_PRESERVE_P (get_label_from_map (map, CODE_LABEL_NUMBER (orig)))\n \t= LABEL_PRESERVE_P (orig);\n-      return map->label_map[CODE_LABEL_NUMBER (orig)];\n+      return get_label_from_map (map, CODE_LABEL_NUMBER (orig));\n \n     case LABEL_REF:\n       copy = gen_rtx (LABEL_REF, mode,\n \t\t      LABEL_REF_NONLOCAL_P (orig) ? XEXP (orig, 0)\n-\t\t      : map->label_map[CODE_LABEL_NUMBER (XEXP (orig, 0))]);\n+\t\t      : get_label_from_map (map, \n+\t\t\t\t\t    CODE_LABEL_NUMBER (XEXP (orig, 0))));\n       LABEL_OUTSIDE_LOOP_P (copy) = LABEL_OUTSIDE_LOOP_P (orig);\n \n       /* The fact that this label was previously nonlocal does not mean"}, {"sha": "f0c46ff1ddceec1cbd67b3fc8b6e81c8b68474ac", "filename": "gcc/integrate.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f3d3a31617991a3ded514cd78e0c7dae081390c/gcc%2Fintegrate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f3d3a31617991a3ded514cd78e0c7dae081390c/gcc%2Fintegrate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.h?ref=1f3d3a31617991a3ded514cd78e0c7dae081390c", "patch": "@@ -122,6 +122,13 @@ extern void try_constants PROTO((rtx, struct inline_remap *));\n \n extern void mark_stores PROTO((rtx, rtx));\n \n+/* Return the label indicated.  */\n+extern rtx get_label_from_map PROTO((struct inline_remap *, int));\n+\n+/* Set the label indicated.  */\n+#define set_label_in_map(map, i, x) \\\n+  ((map)->label_map[i] = (x))\n+\n /* Unfortunately, we need a global copy of const_equiv map for communication\n    with a function called from note_stores.  Be *very* careful that this\n    is used properly in the presence of recursion.  */"}, {"sha": "f796c599e6234587364ca4bbc5cc823079400271", "filename": "gcc/unroll.c", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f3d3a31617991a3ded514cd78e0c7dae081390c/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f3d3a31617991a3ded514cd78e0c7dae081390c/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=1f3d3a31617991a3ded514cd78e0c7dae081390c", "patch": "@@ -691,8 +691,9 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n       else if (GET_CODE (insn) == JUMP_INSN)\n \t{\n \t  if (JUMP_LABEL (insn))\n-\t    map->label_map[CODE_LABEL_NUMBER (JUMP_LABEL (insn))]\n-\t      = JUMP_LABEL (insn);\n+\t    set_label_in_map (map,\n+\t\t\t      CODE_LABEL_NUMBER (JUMP_LABEL (insn)),\n+\t\t\t      JUMP_LABEL (insn));\n \t  else if (GET_CODE (PATTERN (insn)) == ADDR_VEC\n \t\t   || GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC)\n \t    {\n@@ -704,7 +705,9 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \t      for (i = 0; i < len; i++)\n \t\t{\n \t\t  label = XEXP (XVECEXP (pat, diff_vec_p, i), 0);\n-\t\t  map->label_map[CODE_LABEL_NUMBER (label)] = label;\n+\t\t  set_label_in_map (map,\n+\t\t\t\t    CODE_LABEL_NUMBER (label),\n+\t\t\t\t    label);\n \t\t}\n \t    }\n \t}\n@@ -1043,7 +1046,7 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \n \t      for (j = 0; j < max_labelno; j++)\n \t\tif (local_label[j])\n-\t\t  map->label_map[j] = gen_label_rtx ();\n+\t\t  set_label_in_map (map, j, gen_label_rtx ());\n \n \t      for (j = FIRST_PSEUDO_REGISTER; j < max_reg_before_loop; j++)\n \t\tif (local_regno[j])\n@@ -1205,7 +1208,7 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \n       for (j = 0; j < max_labelno; j++)\n \tif (local_label[j])\n-\t  map->label_map[j] = gen_label_rtx ();\n+\t  set_label_in_map (map, j, gen_label_rtx ());\n \n       for (j = FIRST_PSEUDO_REGISTER; j < max_reg_before_loop; j++)\n \tif (local_regno[j])\n@@ -1222,8 +1225,9 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \t  insn = PREV_INSN (copy_start);\n \t  pattern = PATTERN (insn);\n \t  \n-\t  tem = map->label_map[CODE_LABEL_NUMBER\n-\t\t\t       (XEXP (SET_SRC (pattern), 0))];\n+\t  tem = get_label_from_map (map,\n+\t\t\t\t    CODE_LABEL_NUMBER\n+\t\t\t\t    (XEXP (SET_SRC (pattern), 0)));\n \t  SET_SRC (pattern) = gen_rtx (LABEL_REF, VOIDmode, tem);\n \n \t  /* Set the jump label so that it can be used by later loop unrolling\n@@ -1640,10 +1644,11 @@ copy_loop_body (copy_start, copy_end, map, exit_label, last_iteration,\n   if (! last_iteration)\n     {\n       final_label = gen_label_rtx ();\n-      map->label_map[CODE_LABEL_NUMBER (start_label)] = final_label;\n+      set_label_in_map (map, CODE_LABEL_NUMBER (start_label),\n+\t\t\tfinal_label); \n     }\n   else\n-    map->label_map[CODE_LABEL_NUMBER (start_label)] = start_label;\n+    set_label_in_map (map, CODE_LABEL_NUMBER (start_label), start_label);\n \n   start_sequence ();\n   \n@@ -1928,8 +1933,9 @@ copy_loop_body (copy_start, copy_end, map, exit_label, last_iteration,\n \t      if (invert_exp (pattern, copy))\n \t\t{\n \t\t  if (! redirect_exp (&pattern,\n-\t\t\t\t      map->label_map[CODE_LABEL_NUMBER\n-\t\t\t\t\t\t     (JUMP_LABEL (insn))],\n+\t\t\t\t      get_label_from_map (map,\n+\t\t\t\t\t\t\t  CODE_LABEL_NUMBER\n+\t\t\t\t\t\t\t  (JUMP_LABEL (insn))),\n \t\t\t\t      exit_label, copy))\n \t\t    abort ();\n \t\t}\n@@ -1946,8 +1952,9 @@ copy_loop_body (copy_start, copy_end, map, exit_label, last_iteration,\n \t\t  emit_label_after (lab, jmp);\n \t\t  LABEL_NUSES (lab) = 0;\n \t\t  if (! redirect_exp (&pattern,\n-\t\t\t\t      map->label_map[CODE_LABEL_NUMBER\n-\t\t\t\t\t\t     (JUMP_LABEL (insn))],\n+\t\t\t\t      get_label_from_map (map,\n+\t\t\t\t\t\t\t  CODE_LABEL_NUMBER\n+\t\t\t\t\t\t\t  (JUMP_LABEL (insn))),\n \t\t\t\t      lab, copy))\n \t\t    abort ();\n \t\t}\n@@ -1990,7 +1997,8 @@ copy_loop_body (copy_start, copy_end, map, exit_label, last_iteration,\n \t\t     for a switch statement.  This label must have been mapped,\n \t\t     so just use the label_map to get the new jump label.  */\n \t\t  JUMP_LABEL (copy)\n-\t\t    = map->label_map[CODE_LABEL_NUMBER (JUMP_LABEL (insn))];\n+\t\t    = get_label_from_map (map, \n+\t\t\t\t\t  CODE_LABEL_NUMBER (JUMP_LABEL (insn))); \n \t\t}\n \t  \n \t      /* If this is a non-local jump, then must increase the label\n@@ -2068,7 +2076,8 @@ copy_loop_body (copy_start, copy_end, map, exit_label, last_iteration,\n \n \t  if (insn != start_label)\n \t    {\n-\t      copy = emit_label (map->label_map[CODE_LABEL_NUMBER (insn)]);\n+\t      copy = emit_label (get_label_from_map (map,\n+\t\t\t\t\t\t     CODE_LABEL_NUMBER (insn)));\n \t      map->const_age++;\n \t    }\n \t  break;"}]}