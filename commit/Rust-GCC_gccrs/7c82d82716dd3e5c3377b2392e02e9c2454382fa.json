{"sha": "7c82d82716dd3e5c3377b2392e02e9c2454382fa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2M4MmQ4MjcxNmRkM2U1YzMzNzdiMjM5MmUwMmU5YzI0NTQzODJmYQ==", "commit": {"author": {"name": "Tom de Vries", "email": "tom@codesourcery.com", "date": "2015-06-05T15:57:34Z"}, "committer": {"name": "Tom de Vries", "email": "vries@gcc.gnu.org", "date": "2015-06-05T15:57:34Z"}, "message": "Add transform_to_exit_first_loop_alt\n\n2015-06-05  Tom de Vries  <tom@codesourcery.com>\n\n\tmerge from gomp4 branch:\n\t2015-05-28  Tom de Vries  <tom@codesourcery.com>\n\n\tPR tree-optimization/65443\n\t* tree-parloops.c (replace_imm_uses, replace_uses_in_bb_by)\n\t(replace_uses_in_bbs_by, transform_to_exit_first_loop_alt)\n\t(try_transform_to_exit_first_loop_alt): New function.\n\t(transform_to_exit_first_loop): Use\n\ttry_transform_to_exit_first_loop_alt.\n\n\t* gcc.dg/parloops-exit-first-loop-alt-2.c: New test.\n\t* gcc.dg/parloops-exit-first-loop-alt-3.c: New test.\n\t* gcc.dg/parloops-exit-first-loop-alt.c: New test.\n\n\t* testsuite/libgomp.c/parloops-exit-first-loop-alt-2.c: New test.\n\t* testsuite/libgomp.c/parloops-exit-first-loop-alt-3.c: New test.\n\t* testsuite/libgomp.c/parloops-exit-first-loop-alt.c: New test.\n\nFrom-SVN: r224154", "tree": {"sha": "299636b9713d77014b892241dd301e1b62c714b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/299636b9713d77014b892241dd301e1b62c714b3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7c82d82716dd3e5c3377b2392e02e9c2454382fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c82d82716dd3e5c3377b2392e02e9c2454382fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c82d82716dd3e5c3377b2392e02e9c2454382fa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c82d82716dd3e5c3377b2392e02e9c2454382fa/comments", "author": null, "committer": null, "parents": [{"sha": "ddb63209a8dc059a7b2a137d7a1859222bb43dd6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddb63209a8dc059a7b2a137d7a1859222bb43dd6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ddb63209a8dc059a7b2a137d7a1859222bb43dd6"}], "stats": {"total": 636, "additions": 624, "deletions": 12}, "files": [{"sha": "d641111dc121356b9a7e84b49b2e79f29021beb7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c82d82716dd3e5c3377b2392e02e9c2454382fa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c82d82716dd3e5c3377b2392e02e9c2454382fa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7c82d82716dd3e5c3377b2392e02e9c2454382fa", "patch": "@@ -1,3 +1,15 @@\n+2015-06-05  Tom de Vries  <tom@codesourcery.com>\n+\n+\tmerge from gomp4 branch:\n+\t2015-05-28  Tom de Vries  <tom@codesourcery.com>\n+\n+\tPR tree-optimization/65443\n+\t* tree-parloops.c (replace_imm_uses, replace_uses_in_bb_by)\n+\t(replace_uses_in_bbs_by, transform_to_exit_first_loop_alt)\n+\t(try_transform_to_exit_first_loop_alt): New function.\n+\t(transform_to_exit_first_loop): Use\n+\ttry_transform_to_exit_first_loop_alt.\n+\n 2015-06-05  James Greenhalgh  <james.greenhalgh@arm.com>\n \n \t* builtins.c (expand_builtin_atomic_compare_exchange): Call"}, {"sha": "c5adc35b8ed61c4ba21901c67894aa80c36d0e90", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c82d82716dd3e5c3377b2392e02e9c2454382fa/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c82d82716dd3e5c3377b2392e02e9c2454382fa/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7c82d82716dd3e5c3377b2392e02e9c2454382fa", "patch": "@@ -1,3 +1,13 @@\n+2015-06-05  Tom de Vries  <tom@codesourcery.com>\n+\n+\tmerge from gomp4 branch:\n+\t2015-05-28  Tom de Vries  <tom@codesourcery.com>\n+\n+\tPR tree-optimization/65443\n+\t* gcc.dg/parloops-exit-first-loop-alt-2.c: New test.\n+\t* gcc.dg/parloops-exit-first-loop-alt-3.c: New test.\n+\t* gcc.dg/parloops-exit-first-loop-alt.c: New test.\n+\n 2015-06-05  Nathan Sidwell  <nathan@acm.org>\n \n \tPR c++/52595"}, {"sha": "956be9b912be37f4c711601c790c64386bfcaa08", "filename": "gcc/testsuite/gcc.dg/parloops-exit-first-loop-alt-2.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c82d82716dd3e5c3377b2392e02e9c2454382fa/gcc%2Ftestsuite%2Fgcc.dg%2Fparloops-exit-first-loop-alt-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c82d82716dd3e5c3377b2392e02e9c2454382fa/gcc%2Ftestsuite%2Fgcc.dg%2Fparloops-exit-first-loop-alt-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fparloops-exit-first-loop-alt-2.c?ref=7c82d82716dd3e5c3377b2392e02e9c2454382fa", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target pthread } */\n+/* { dg-options \"-O2 -ftree-parallelize-loops=2 -fdump-tree-parloops\" } */\n+\n+#define N 1000\n+\n+unsigned int a[N];\n+unsigned int b[N];\n+unsigned int c[N];\n+\n+void __attribute__((noclone,noinline))\n+f (unsigned int n)\n+{\n+  int i;\n+\n+    for (i = 0; i < N; ++i)\n+      c[i] = a[i] + b[i];\n+}\n+\n+/* Three times three array accesses:\n+   - three in f._loopfn.0\n+   - three in the parallel\n+   - three in the low iteration count loop\n+   Crucially, none for a peeled off last iteration following the parallel.  */\n+/* { dg-final { scan-tree-dump-times \"(?n)\\\\\\[i\" 9 \"parloops\" } } */"}, {"sha": "82b0b1d5bfd4de296492608e3effff31dca38500", "filename": "gcc/testsuite/gcc.dg/parloops-exit-first-loop-alt-3.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c82d82716dd3e5c3377b2392e02e9c2454382fa/gcc%2Ftestsuite%2Fgcc.dg%2Fparloops-exit-first-loop-alt-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c82d82716dd3e5c3377b2392e02e9c2454382fa/gcc%2Ftestsuite%2Fgcc.dg%2Fparloops-exit-first-loop-alt-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fparloops-exit-first-loop-alt-3.c?ref=7c82d82716dd3e5c3377b2392e02e9c2454382fa", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target pthread } */\n+/* { dg-options \"-O2 -ftree-parallelize-loops=2 -fdump-tree-parloops\" } */\n+\n+unsigned int *a;\n+\n+unsigned int __attribute__((noclone,noinline))\n+f (unsigned int n)\n+{\n+  int i;\n+  unsigned int sum = 1;\n+\n+  for (i = 0; i < n; ++i)\n+    sum += a[i];\n+\n+  return sum;\n+}\n+\n+/* Three array accesses:\n+   - one in f._loopfn.0\n+   - one in the parallel\n+   - one in the low iteration count loop\n+   Crucially, none for a peeled off last iteration following the parallel.  */\n+/* { dg-final { scan-tree-dump-times \"(?n)\\\\\\* 4\" 3 \"parloops\" } } */"}, {"sha": "9be844adef52d30cba0d2f06edec4a5012a57a3d", "filename": "gcc/testsuite/gcc.dg/parloops-exit-first-loop-alt.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c82d82716dd3e5c3377b2392e02e9c2454382fa/gcc%2Ftestsuite%2Fgcc.dg%2Fparloops-exit-first-loop-alt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c82d82716dd3e5c3377b2392e02e9c2454382fa/gcc%2Ftestsuite%2Fgcc.dg%2Fparloops-exit-first-loop-alt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fparloops-exit-first-loop-alt.c?ref=7c82d82716dd3e5c3377b2392e02e9c2454382fa", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target pthread } */\n+/* { dg-options \"-O2 -ftree-parallelize-loops=2 -fdump-tree-parloops\" } */\n+\n+#define N 1000\n+\n+unsigned int a[N];\n+unsigned int b[N];\n+unsigned int c[N];\n+\n+void __attribute__((noclone,noinline))\n+f (unsigned int n)\n+{\n+  int i;\n+\n+  for (i = 0; i < n; ++i)\n+    c[i] = a[i] + b[i];\n+}\n+\n+/* Three times three array accesses:\n+   - three in f._loopfn.0\n+   - three in the parallel\n+   - three in the low iteration count loop\n+   Crucially, none for a peeled off last iteration following the parallel.  */\n+/* { dg-final { scan-tree-dump-times \"(?n)\\\\\\[i\" 9 \"parloops\" } } */"}, {"sha": "02f44ebac74309eecd02d3ce02c6fd77cf22375f", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 393, "deletions": 12, "changes": 405, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c82d82716dd3e5c3377b2392e02e9c2454382fa/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c82d82716dd3e5c3377b2392e02e9c2454382fa/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=7c82d82716dd3e5c3377b2392e02e9c2454382fa", "patch": "@@ -75,6 +75,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"plugin-api.h\"\n #include \"ipa-ref.h\"\n #include \"cgraph.h\"\n+#include \"tree-ssa.h\"\n \n /* This pass tries to distribute iterations of loops into several threads.\n    The implementation is straightforward -- for each loop we test whether its\n@@ -1484,17 +1485,386 @@ create_loop_fn (location_t loc)\n   return decl;\n }\n \n-/* Moves the exit condition of LOOP to the beginning of its header, and\n-   duplicates the part of the last iteration that gets disabled to the\n-   exit of the loop.  NIT is the number of iterations of the loop\n-   (used to initialize the variables in the duplicated part).\n+/* Replace uses of NAME by VAL in block BB.  */\n \n-   TODO: the common case is that latch of the loop is empty and immediately\n-   follows the loop exit.  In this case, it would be better not to copy the\n-   body of the loop, but only move the entry of the loop directly before the\n-   exit check and increase the number of iterations of the loop by one.\n-   This may need some additional preconditioning in case NIT = ~0.\n-   REDUCTION_LIST describes the reductions in LOOP.  */\n+static void\n+replace_uses_in_bb_by (tree name, tree val, basic_block bb)\n+{\n+  gimple use_stmt;\n+  imm_use_iterator imm_iter;\n+\n+  FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, name)\n+    {\n+      if (gimple_bb (use_stmt) != bb)\n+\tcontinue;\n+\n+      use_operand_p use_p;\n+      FOR_EACH_IMM_USE_ON_STMT (use_p, imm_iter)\n+\tSET_USE (use_p, val);\n+    }\n+}\n+\n+/* Replace uses of NAME by VAL in blocks BBS.  */\n+\n+static void\n+replace_uses_in_bbs_by (tree name, tree val, bitmap bbs)\n+{\n+  gimple use_stmt;\n+  imm_use_iterator imm_iter;\n+\n+  FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, name)\n+    {\n+      if (!bitmap_bit_p (bbs, gimple_bb (use_stmt)->index))\n+\tcontinue;\n+\n+      use_operand_p use_p;\n+      FOR_EACH_IMM_USE_ON_STMT (use_p, imm_iter)\n+\tSET_USE (use_p, val);\n+    }\n+}\n+\n+/* Do transformation from:\n+\n+     <bb preheader>:\n+     ...\n+     goto <bb header>\n+\n+     <bb header>:\n+     ivtmp_a = PHI <ivtmp_init (preheader), ivtmp_b (latch)>\n+     sum_a = PHI <sum_init (preheader), sum_b (latch)>\n+     ...\n+     use (ivtmp_a)\n+     ...\n+     sum_b = sum_a + sum_update\n+     ...\n+     if (ivtmp_a < n)\n+       goto <bb latch>;\n+     else\n+       goto <bb exit>;\n+\n+     <bb latch>:\n+     ivtmp_b = ivtmp_a + 1;\n+     goto <bb header>\n+\n+     <bb exit>:\n+     sum_z = PHI <sum_b (cond[1])>\n+\n+     [1] Where <bb cond> is single_pred (bb latch); In the simplest case,\n+\t that's <bb header>.\n+\n+   to:\n+\n+     <bb preheader>:\n+     ...\n+     goto <bb newheader>\n+\n+     <bb header>:\n+     ivtmp_a = PHI <ivtmp_c (latch)>\n+     sum_a = PHI <sum_c (latch)>\n+     ...\n+     use (ivtmp_a)\n+     ...\n+     sum_b = sum_a + sum_update\n+     ...\n+     goto <bb latch>;\n+\n+     <bb newheader>:\n+     ivtmp_c = PHI <ivtmp_init (preheader), ivtmp_b (latch)>\n+     sum_c = PHI <sum_init (preheader), sum_b (latch)>\n+     if (ivtmp_c < n + 1)\n+       goto <bb header>;\n+     else\n+       goto <bb exit>;\n+\n+     <bb latch>:\n+     ivtmp_b = ivtmp_a + 1;\n+     goto <bb newheader>\n+\n+     <bb exit>:\n+     sum_z = PHI <sum_c (newheader)>\n+\n+\n+   In unified diff format:\n+\n+      <bb preheader>:\n+      ...\n+-     goto <bb header>\n++     goto <bb newheader>\n+\n+      <bb header>:\n+-     ivtmp_a = PHI <ivtmp_init (preheader), ivtmp_b (latch)>\n+-     sum_a = PHI <sum_init (preheader), sum_b (latch)>\n++     ivtmp_a = PHI <ivtmp_c (latch)>\n++     sum_a = PHI <sum_c (latch)>\n+      ...\n+      use (ivtmp_a)\n+      ...\n+      sum_b = sum_a + sum_update\n+      ...\n+-     if (ivtmp_a < n)\n+-       goto <bb latch>;\n++     goto <bb latch>;\n++\n++     <bb newheader>:\n++     ivtmp_c = PHI <ivtmp_init (preheader), ivtmp_b (latch)>\n++     sum_c = PHI <sum_init (preheader), sum_b (latch)>\n++     if (ivtmp_c < n + 1)\n++       goto <bb header>;\n+      else\n+\tgoto <bb exit>;\n+\n+      <bb latch>:\n+      ivtmp_b = ivtmp_a + 1;\n+-     goto <bb header>\n++     goto <bb newheader>\n+\n+      <bb exit>:\n+-     sum_z = PHI <sum_b (cond[1])>\n++     sum_z = PHI <sum_c (newheader)>\n+\n+   Note: the example does not show any virtual phis, but these are handled more\n+   or less as reductions.\n+\n+\n+   Moves the exit condition of LOOP to the beginning of its header.\n+   REDUCTION_LIST describes the reductions in LOOP.  BOUND is the new loop\n+   bound.  */\n+\n+static void\n+transform_to_exit_first_loop_alt (struct loop *loop,\n+\t\t\t\t  reduction_info_table_type *reduction_list,\n+\t\t\t\t  tree bound)\n+{\n+  basic_block header = loop->header;\n+  basic_block latch = loop->latch;\n+  edge exit = single_dom_exit (loop);\n+  basic_block exit_block = exit->dest;\n+  gcond *cond_stmt = as_a <gcond *> (last_stmt (exit->src));\n+  tree control = gimple_cond_lhs (cond_stmt);\n+  edge e;\n+\n+  /* Gather the bbs dominated by the exit block.  */\n+  bitmap exit_dominated = BITMAP_ALLOC (NULL);\n+  bitmap_set_bit (exit_dominated, exit_block->index);\n+  vec<basic_block> exit_dominated_vec\n+    = get_dominated_by (CDI_DOMINATORS, exit_block);\n+\n+  int i;\n+  basic_block dom_bb;\n+  FOR_EACH_VEC_ELT (exit_dominated_vec, i, dom_bb)\n+    bitmap_set_bit (exit_dominated, dom_bb->index);\n+\n+  exit_dominated_vec.release ();\n+\n+  /* Create the new_header block.  */\n+  basic_block new_header = split_block_before_cond_jump (exit->src);\n+  edge split_edge = single_pred_edge (new_header);\n+\n+  /* Redirect entry edge to new_header.  */\n+  edge entry = loop_preheader_edge (loop);\n+  e = redirect_edge_and_branch (entry, new_header);\n+  gcc_assert (e == entry);\n+\n+  /* Redirect post_inc_edge to new_header.  */\n+  edge post_inc_edge = single_succ_edge (latch);\n+  e = redirect_edge_and_branch (post_inc_edge, new_header);\n+  gcc_assert (e == post_inc_edge);\n+\n+  /* Redirect post_cond_edge to header.  */\n+  edge post_cond_edge = single_pred_edge (latch);\n+  e = redirect_edge_and_branch (post_cond_edge, header);\n+  gcc_assert (e == post_cond_edge);\n+\n+  /* Redirect split_edge to latch.  */\n+  e = redirect_edge_and_branch (split_edge, latch);\n+  gcc_assert (e == split_edge);\n+\n+  /* Set the new loop bound.  */\n+  gimple_cond_set_rhs (cond_stmt, bound);\n+\n+  /* Repair the ssa.  */\n+  vec<edge_var_map> *v = redirect_edge_var_map_vector (post_inc_edge);\n+  edge_var_map *vm;\n+  gphi_iterator gsi;\n+  for (gsi = gsi_start_phis (header), i = 0;\n+       !gsi_end_p (gsi) && v->iterate (i, &vm);\n+       gsi_next (&gsi), i++)\n+    {\n+      gphi *phi = gsi.phi ();\n+      tree res_a = PHI_RESULT (phi);\n+\n+      /* Create new phi.  */\n+      tree res_c = copy_ssa_name (res_a, phi);\n+      gphi *nphi = create_phi_node (res_c, new_header);\n+\n+      /* Replace ivtmp_a with ivtmp_c in condition 'if (ivtmp_a < n)'.  */\n+      replace_uses_in_bb_by (res_a, res_c, new_header);\n+\n+      /* Replace ivtmp/sum_b with ivtmp/sum_c in header phi.  */\n+      add_phi_arg (phi, res_c, post_cond_edge, UNKNOWN_LOCATION);\n+\n+      /* Replace sum_b with sum_c in exit phi.  Loop-closed ssa does not hold\n+\t for virtuals, so we cannot get away with exit_block only.  */\n+      tree res_b = redirect_edge_var_map_def (vm);\n+      replace_uses_in_bbs_by (res_b, res_c, exit_dominated);\n+\n+      struct reduction_info *red = reduction_phi (reduction_list, phi);\n+      gcc_assert (virtual_operand_p (res_a)\n+\t\t  || res_a == control\n+\t\t  || red != NULL);\n+\n+      if (red)\n+\t{\n+\t  /* Register the new reduction phi.  */\n+\t  red->reduc_phi = nphi;\n+\t  gimple_set_uid (red->reduc_phi, red->reduc_version);\n+\t}\n+    }\n+  gcc_assert (gsi_end_p (gsi) && !v->iterate (i, &vm));\n+  BITMAP_FREE (exit_dominated);\n+\n+  /* Set the preheader argument of the new phis to ivtmp/sum_init.  */\n+  flush_pending_stmts (entry);\n+\n+  /* Set the latch arguments of the new phis to ivtmp/sum_b.  */\n+  flush_pending_stmts (post_inc_edge);\n+\n+  /* Register the reduction exit phis.  */\n+  for (gphi_iterator gsi = gsi_start_phis (exit_block);\n+       !gsi_end_p (gsi);\n+       gsi_next (&gsi))\n+    {\n+      gphi *phi = gsi.phi ();\n+      tree res_z = PHI_RESULT (phi);\n+      if (virtual_operand_p (res_z))\n+\tcontinue;\n+\n+      tree res_c = PHI_ARG_DEF_FROM_EDGE (phi, exit);\n+      gimple reduc_phi = SSA_NAME_DEF_STMT (res_c);\n+      struct reduction_info *red = reduction_phi (reduction_list, reduc_phi);\n+      if (red != NULL)\n+\tred->keep_res = phi;\n+    }\n+\n+  /* We're going to cancel the loop at the end of gen_parallel_loop, but until\n+     then we're still using some fields, so only bother about fields that are\n+     still used: header and latch.\n+     The loop has a new header bb, so we update it.  The latch bb stays the\n+     same.  */\n+  loop->header = new_header;\n+\n+  /* Recalculate dominance info.  */\n+  free_dominance_info (CDI_DOMINATORS);\n+  calculate_dominance_info (CDI_DOMINATORS);\n+}\n+\n+/* Tries to moves the exit condition of LOOP to the beginning of its header\n+   without duplication of the loop body.  NIT is the number of iterations of the\n+   loop.  REDUCTION_LIST describes the reductions in LOOP.  Return true if\n+   transformation is successful.  */\n+\n+static bool\n+try_transform_to_exit_first_loop_alt (struct loop *loop,\n+\t\t\t\t      reduction_info_table_type *reduction_list,\n+\t\t\t\t      tree nit)\n+{\n+  /* Check whether the latch contains a single statement.  */\n+  if (!gimple_seq_singleton_p (bb_seq (loop->latch)))\n+    return true;\n+\n+  /* Check whether the latch contains the loop iv increment.  */\n+  edge back = single_succ_edge (loop->latch);\n+  edge exit = single_dom_exit (loop);\n+  gcond *cond_stmt = as_a <gcond *> (last_stmt (exit->src));\n+  tree control = gimple_cond_lhs (cond_stmt);\n+  gphi *phi = as_a <gphi *> (SSA_NAME_DEF_STMT (control));\n+  tree inc_res = gimple_phi_arg_def (phi, back->dest_idx);\n+  if (gimple_bb (SSA_NAME_DEF_STMT (inc_res)) != loop->latch)\n+    return false;\n+\n+  /* Check whether there's no code between the loop condition and the latch.  */\n+  if (!single_pred_p (loop->latch)\n+      || single_pred (loop->latch) != exit->src)\n+    return false;\n+\n+  tree alt_bound = NULL_TREE;\n+  tree nit_type = TREE_TYPE (nit);\n+\n+  /* Figure out whether nit + 1 overflows.  */\n+  if (TREE_CODE (nit) == INTEGER_CST)\n+    {\n+      if (!tree_int_cst_equal (nit, TYPE_MAXVAL (nit_type)))\n+\t{\n+\t  alt_bound = fold_build2_loc (UNKNOWN_LOCATION, PLUS_EXPR, nit_type,\n+\t\t\t\t       nit, build_one_cst (nit_type));\n+\n+\t  gcc_assert (TREE_CODE (alt_bound) == INTEGER_CST);\n+\t}\n+      else\n+\t{\n+\t  /* Todo: Figure out if we can trigger this, if it's worth to handle\n+\t     optimally, and if we can handle it optimally.  */\n+\t}\n+    }\n+  else\n+    {\n+      gcc_assert (TREE_CODE (nit) == SSA_NAME);\n+\n+      gimple def = SSA_NAME_DEF_STMT (nit);\n+\n+      if (def\n+\t  && is_gimple_assign (def)\n+\t  && gimple_assign_rhs_code (def) == PLUS_EXPR)\n+\t{\n+\t  tree op1 = gimple_assign_rhs1 (def);\n+\t  tree op2 = gimple_assign_rhs2 (def);\n+\t  if (integer_minus_onep (op1))\n+\t    alt_bound = op2;\n+\t  else if (integer_minus_onep (op2))\n+\t    alt_bound = op1;\n+\t}\n+\n+      /* There is a number of test-cases for which we don't get an alt_bound\n+\t here: they're listed here, with the lhs of the last stmt as the nit:\n+\n+\t libgomp.graphite/force-parallel-1.c:\n+\t _21 = (signed long) N_6(D);\n+\t _19 = _21 + -1;\n+\t _7 = (unsigned long) _19;\n+\n+\t libgomp.graphite/force-parallel-2.c:\n+\t _33 = (signed long) N_9(D);\n+\t _16 = _33 + -1;\n+\t _37 = (unsigned long) _16;\n+\n+\t libgomp.graphite/force-parallel-5.c:\n+\t <bb 6>:\n+\t # graphite_IV.5_46 = PHI <0(5), graphite_IV.5_47(11)>\n+\t <bb 7>:\n+\t _33 = (unsigned long) graphite_IV.5_46;\n+\n+\t g++.dg/tree-ssa/pr34355.C:\n+\t _2 = (unsigned int) i_9;\n+\t _3 = 4 - _2;\n+\n+\t gcc.dg/pr53849.c:\n+\t _5 = d.0_11 + -2;\n+\t _18 = (unsigned int) _5;\n+\n+\t We will be able to handle some of these cases, if we can determine when\n+\t it's safe to look past casts.  */\n+    }\n+\n+  if (alt_bound == NULL_TREE)\n+    return false;\n+\n+  transform_to_exit_first_loop_alt (loop, reduction_list, alt_bound);\n+  return true;\n+}\n+\n+/* Moves the exit condition of LOOP to the beginning of its header.  NIT is the\n+   number of iterations of the loop.  REDUCTION_LIST describes the reductions in\n+   LOOP.  */\n \n static void\n transform_to_exit_first_loop (struct loop *loop,\n@@ -1879,8 +2249,19 @@ gen_parallel_loop (struct loop *loop,\n   /* Base all the induction variables in LOOP on a single control one.  */\n   canonicalize_loop_ivs (loop, &nit, true);\n \n-  /* Ensure that the exit condition is the first statement in the loop.  */\n-  transform_to_exit_first_loop (loop, reduction_list, nit);\n+  /* Ensure that the exit condition is the first statement in the loop.\n+     The common case is that latch of the loop is empty (apart from the\n+     increment) and immediately follows the loop exit test.  Attempt to move the\n+     entry of the loop directly before the exit check and increase the number of\n+     iterations of the loop by one.  */\n+  if (!try_transform_to_exit_first_loop_alt (loop, reduction_list, nit))\n+    {\n+      /* Fall back on the method that handles more cases, but duplicates the\n+\t loop body: move the exit condition of LOOP to the beginning of its\n+\t header, and duplicate the part of the last iteration that gets disabled\n+\t to the exit of the loop.  */\n+      transform_to_exit_first_loop (loop, reduction_list, nit);\n+    }\n \n   /* Generate initializations for reductions.  */\n   if (reduction_list->elements () > 0)"}, {"sha": "c0a03c8874898cfa6b13fa7b8ed3e27a90f9e2e8", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c82d82716dd3e5c3377b2392e02e9c2454382fa/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c82d82716dd3e5c3377b2392e02e9c2454382fa/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=7c82d82716dd3e5c3377b2392e02e9c2454382fa", "patch": "@@ -1,3 +1,13 @@\n+2015-06-05  Tom de Vries  <tom@codesourcery.com>\n+\n+\tmerge from gomp4 branch:\n+\t2015-05-28  Tom de Vries  <tom@codesourcery.com>\n+\n+\tPR tree-optimization/65443\n+\t* testsuite/libgomp.c/parloops-exit-first-loop-alt-2.c: New test.\n+\t* testsuite/libgomp.c/parloops-exit-first-loop-alt-3.c: New test.\n+\t* testsuite/libgomp.c/parloops-exit-first-loop-alt.c: New test.\n+\n 2015-05-29  Bernhard Reutner-Fischer  <aldot@gcc.gnu.org>\n \n \t* testsuite/libgomp.graphite/bounds.c: Adjust for"}, {"sha": "eb5e11f4c5ac9b0dfacca7d6b0eca21fd517d7d2", "filename": "libgomp/testsuite/libgomp.c/parloops-exit-first-loop-alt-2.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c82d82716dd3e5c3377b2392e02e9c2454382fa/libgomp%2Ftestsuite%2Flibgomp.c%2Fparloops-exit-first-loop-alt-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c82d82716dd3e5c3377b2392e02e9c2454382fa/libgomp%2Ftestsuite%2Flibgomp.c%2Fparloops-exit-first-loop-alt-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fparloops-exit-first-loop-alt-2.c?ref=7c82d82716dd3e5c3377b2392e02e9c2454382fa", "patch": "@@ -0,0 +1,48 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -ftree-parallelize-loops=2\" } */\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+#define N 1000\n+\n+unsigned int a[N];\n+unsigned int b[N];\n+unsigned int c[N];\n+\n+void __attribute__((noclone,noinline))\n+f (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < N; ++i)\n+    c[i] = a[i] + b[i];\n+}\n+\n+int\n+main (void)\n+{\n+  int i, j;\n+\n+  /* Complexify loop to inhibit parloops.  */\n+  for (j = 0; j < 100; ++j)\n+    for (i = 0; i < 10; i++)\n+      {\n+\tint k = i + (10 * j);\n+\ta[k] = k;\n+\tb[k] = (k * 3) % 7;\n+\tc[k] = k * 2;\n+      }\n+\n+  f ();\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      unsigned int actual = c[i];\n+      unsigned int expected = i + ((i * 3) % 7);\n+      if (actual != expected)\n+\tabort ();\n+    }\n+\n+  return 0;\n+}"}, {"sha": "b426b3f124ba31a4346258b0fdf8bac21d2efa10", "filename": "libgomp/testsuite/libgomp.c/parloops-exit-first-loop-alt-3.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c82d82716dd3e5c3377b2392e02e9c2454382fa/libgomp%2Ftestsuite%2Flibgomp.c%2Fparloops-exit-first-loop-alt-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c82d82716dd3e5c3377b2392e02e9c2454382fa/libgomp%2Ftestsuite%2Flibgomp.c%2Fparloops-exit-first-loop-alt-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fparloops-exit-first-loop-alt-3.c?ref=7c82d82716dd3e5c3377b2392e02e9c2454382fa", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -ftree-parallelize-loops=2\" } */\n+\n+unsigned int *a;\n+\n+unsigned int __attribute__((noclone,noinline))\n+f (unsigned int n)\n+{\n+  int i;\n+  unsigned int sum = 1;\n+\n+  for (i = 0; i < n; ++i)\n+    sum += a[i];\n+\n+  return sum;\n+}\n+\n+int\n+main (void)\n+{\n+  unsigned int res;\n+  unsigned int array[4000];\n+  int i;\n+  for (i = 0; i < 4000; ++i)\n+    array[i] = i % 7;\n+  a = &array[0];\n+  res = f (4000);\n+  return !(res == 11995);\n+}"}, {"sha": "d7d400328f10f317f13243e238377a08d5204d02", "filename": "libgomp/testsuite/libgomp.c/parloops-exit-first-loop-alt.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c82d82716dd3e5c3377b2392e02e9c2454382fa/libgomp%2Ftestsuite%2Flibgomp.c%2Fparloops-exit-first-loop-alt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c82d82716dd3e5c3377b2392e02e9c2454382fa/libgomp%2Ftestsuite%2Flibgomp.c%2Fparloops-exit-first-loop-alt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fparloops-exit-first-loop-alt.c?ref=7c82d82716dd3e5c3377b2392e02e9c2454382fa", "patch": "@@ -0,0 +1,48 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -ftree-parallelize-loops=2\" } */\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+#define N 1000\n+\n+unsigned int a[N];\n+unsigned int b[N];\n+unsigned int c[N];\n+\n+void __attribute__((noclone,noinline))\n+f (unsigned int n)\n+{\n+  int i;\n+\n+  for (i = 0; i < n; ++i)\n+    c[i] = a[i] + b[i];\n+}\n+\n+int\n+main (void)\n+{\n+  int i, j;\n+\n+  /* Complexify loop to inhibit parloops.  */\n+  for (j = 0; j < 100; ++j)\n+    for (i = 0; i < 10; i++)\n+      {\n+\tint k = i + (10 * j);\n+\ta[k] = k;\n+\tb[k] = (k * 3) % 7;\n+\tc[k] = k * 2;\n+      }\n+\n+  f (N);\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      unsigned int actual = c[i];\n+      unsigned int expected = i + ((i * 3) % 7);\n+      if (actual != expected)\n+\tabort ();\n+    }\n+\n+  return 0;\n+}"}]}