{"sha": "2b38137d3da2a06e99682362b1a298fe5f67731a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmIzODEzN2QzZGEyYTA2ZTk5NjgyMzYyYjFhMjk4ZmU1ZjY3NzMxYQ==", "commit": {"author": {"name": "David S. Miller", "email": "davem@davemloft.net", "date": "2011-11-11T08:23:34Z"}, "committer": {"name": "David S. Miller", "email": "davem@gcc.gnu.org", "date": "2011-11-11T08:23:34Z"}, "message": "Revert sparc vec_init improvements as they cause 64-bit regressions.\n\ngcc/\n\n\tRevert\n\t2011-11-05  David S. Miller  <davem@davemloft.net>\n\nFrom-SVN: r181283", "tree": {"sha": "d2afd17db58522f630344f961e7f7d898ee7283b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d2afd17db58522f630344f961e7f7d898ee7283b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2b38137d3da2a06e99682362b1a298fe5f67731a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b38137d3da2a06e99682362b1a298fe5f67731a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b38137d3da2a06e99682362b1a298fe5f67731a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b38137d3da2a06e99682362b1a298fe5f67731a/comments", "author": {"login": "davem330", "id": 1053866, "node_id": "MDQ6VXNlcjEwNTM4NjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1053866?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davem330", "html_url": "https://github.com/davem330", "followers_url": "https://api.github.com/users/davem330/followers", "following_url": "https://api.github.com/users/davem330/following{/other_user}", "gists_url": "https://api.github.com/users/davem330/gists{/gist_id}", "starred_url": "https://api.github.com/users/davem330/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davem330/subscriptions", "organizations_url": "https://api.github.com/users/davem330/orgs", "repos_url": "https://api.github.com/users/davem330/repos", "events_url": "https://api.github.com/users/davem330/events{/privacy}", "received_events_url": "https://api.github.com/users/davem330/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ca3e7c9ffdf8d0478f51c49e68c5f13eb90fe8c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca3e7c9ffdf8d0478f51c49e68c5f13eb90fe8c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca3e7c9ffdf8d0478f51c49e68c5f13eb90fe8c4"}], "stats": {"total": 499, "additions": 105, "deletions": 394}, "files": [{"sha": "cf4e66b77c210368cb7f0431e295d8fe1c8b479c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b38137d3da2a06e99682362b1a298fe5f67731a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b38137d3da2a06e99682362b1a298fe5f67731a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2b38137d3da2a06e99682362b1a298fe5f67731a", "patch": "@@ -1,3 +1,8 @@\n+2011-11-11  David S. Miller  <davem@davemloft.net>\n+\n+\tRevert\n+\t2011-11-05  David S. Miller  <davem@davemloft.net>\n+\n 2011-11-11  Jakub Jelinek  <jakub@redhat.com>\n \n \t* opts-common.c (generate_canonical_option): Free opt_text"}, {"sha": "55759a03bd1fc6c453aadfac1edff3f580d3eea6", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 100, "deletions": 340, "changes": 440, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b38137d3da2a06e99682362b1a298fe5f67731a/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b38137d3da2a06e99682362b1a298fe5f67731a/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=2b38137d3da2a06e99682362b1a298fe5f67731a", "patch": "@@ -11285,357 +11285,88 @@ output_v8plus_mult (rtx insn, rtx *operands, const char *opcode)\n     }\n }\n \n-/* Subroutine of sparc_expand_vector_init.  Emit code to initialize TARGET to\n-   the N_ELTS values for individual fields contained in LOCS by means of VIS2\n-   BSHUFFLE insn.  MODE and INNER_MODE are the modes describing TARGET.  */\n+/* Subroutine of sparc_expand_vector_init.  Emit code to initialize\n+   all fields of TARGET to ELT by means of VIS2 BSHUFFLE insn.  MODE\n+   and INNER_MODE are the modes describing TARGET.  */\n \n static void\n-vector_init_bshuffle (rtx target, rtx *locs, int n_elts,\n-\t\t      enum machine_mode mode,\n+vector_init_bshuffle (rtx target, rtx elt, enum machine_mode mode,\n \t\t      enum machine_mode inner_mode)\n {\n-  rtx mid_target, r0_high, r0_low, r1_high, r1_low;\n-  enum machine_mode partial_mode;\n-  int bmask, i, idxs[8];\n+  rtx t1, final_insn;\n+  int bmask;\n \n-  partial_mode = (mode == V4HImode\n-\t\t  ? V2HImode\n-\t\t  : (mode == V8QImode\n-\t\t     ? V4QImode : mode));\n+  t1 = gen_reg_rtx (mode);\n \n-  r0_high = r0_low = NULL_RTX;\n-  r1_high = r1_low = NULL_RTX;\n+  elt = convert_modes (SImode, inner_mode, elt, true);\n+  emit_move_insn (gen_lowpart(SImode, t1), elt);\n \n-  /* Move the pieces into place, as needed, and calculate the nibble\n-     indexes for the bmask calculation.  After we execute this loop the\n-     locs[] array is no longer needed.  Therefore, to simplify things,\n-     we set entries that have been processed already to NULL_RTX.  */\n-\n-  for (i = 0; i < n_elts; i++)\n-    {\n-      int j;\n-\n-      if (locs[i] == NULL_RTX)\n-\tcontinue;\n-\n-      if (!r0_low)\n-\t{\n-\t  r0_low = locs[i];\n-\t  idxs[i] = 0x7;\n-\t}\n-      else if (!r1_low)\n-\t{\n-\t  r1_low = locs[i];\n-\t  idxs[i] = 0xf;\n-\t}\n-      else if (!r0_high)\n-\t{\n-\t  r0_high = gen_highpart (partial_mode, r0_low);\n-\t  emit_move_insn (r0_high, gen_lowpart (partial_mode, locs[i]));\n-\t  idxs[i] = 0x3;\n-\t}\n-      else if (!r1_high)\n-\t{\n-\t  r1_high = gen_highpart (partial_mode, r1_low);\n-\t  emit_move_insn (r1_high, gen_lowpart (partial_mode, locs[i]));\n-\t  idxs[i] = 0xb;\n-\t}\n-      else\n-\tgcc_unreachable ();\n-\n-      for (j = i + 1; j < n_elts; j++)\n-\t{\n-\t  if (locs[j] == locs[i])\n-\t    {\n-\t      locs[j] = NULL_RTX;\n-\t      idxs[j] = idxs[i];\n-\t    }\n-\t}\n-      locs[i] = NULL_RTX;\n-    }\n-\n-  bmask = 0;\n-  for (i = 0; i < n_elts; i++)\n-    {\n-      int v = idxs[i];\n-\n-      switch (GET_MODE_SIZE (inner_mode))\n-\t{\n-\tcase 2:\n-\t  bmask <<= 8;\n-\t  bmask |= (((v - 1) << 4) | v);\n-\t  break;\n-\n-\tcase 1:\n-\t  bmask <<= 4;\n-\t  bmask |= v;\n-\t  break;\n-\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-    }\n-\n-  emit_insn (gen_bmasksi_vis (gen_reg_rtx (SImode), CONST0_RTX (SImode),\n-\t\t\t      force_reg (SImode, GEN_INT (bmask))));\n-\n-  mid_target = target;\n-  if (GET_MODE_SIZE (mode) == 4)\n-    {\n-      mid_target = gen_reg_rtx (mode == V2HImode\n-\t\t\t\t? V4HImode : V8QImode);\n-    }\n-\n-  if (!r1_low)\n-    r1_low = r0_low;\n-\n-  switch (GET_MODE (mid_target))\n+  switch (mode)\n     {\n+    case V2SImode:\n+      final_insn = gen_bshufflev2si_vis (target, t1, t1);\n+      bmask = 0x45674567;\n+      break;\n     case V4HImode:\n-      emit_insn (gen_bshufflev4hi_vis (mid_target, r0_low, r1_low));\n+      final_insn = gen_bshufflev4hi_vis (target, t1, t1);\n+      bmask = 0x67676767;\n       break;\n     case V8QImode:\n-      emit_insn (gen_bshufflev8qi_vis (mid_target, r0_low, r1_low));\n+      final_insn = gen_bshufflev8qi_vis (target, t1, t1);\n+      bmask = 0x77777777;\n       break;\n     default:\n       gcc_unreachable ();\n     }\n \n-  if (mid_target != target)\n-    emit_move_insn (target, gen_lowpart (partial_mode, mid_target));\n-}\n-\n-/* Subroutine of sparc_expand_vector_init.  Emit code to initialize TARGET to\n-   values for individual fields VALS by means of simple word moves if this is\n-   possible.  MODE and INNER_MODE are the modes describing TARGET.  Return true\n-   on success.  */\n-\n-static bool\n-vector_init_move_words (rtx target, rtx vals, enum machine_mode mode,\n-\t\t\tenum machine_mode inner_mode)\n-{\n-  switch (mode)\n-    {\n-    case V1SImode:\n-    case V1DImode:\n-      emit_move_insn (gen_lowpart (inner_mode, target),\n-\t\t      gen_lowpart (inner_mode, XVECEXP (vals, 0, 0)));\n-      return true;\n-\n-    case V2SImode:\n-      emit_move_insn (gen_highpart (SImode, target), XVECEXP (vals, 0, 0));\n-      emit_move_insn (gen_lowpart (SImode, target), XVECEXP (vals, 0, 1));\n-      return true;\n-\n-    default:\n-      break;\n-    }\n-  return false;\n+  emit_insn (gen_bmasksi_vis (gen_reg_rtx (SImode), CONST0_RTX (SImode),\n+\t\t\t      force_reg (SImode, GEN_INT (bmask))));\n+  emit_insn (final_insn);\n }\n \n-/* Subroutine of sparc_expand_vector_init.  Move the N_ELTS elements in VALS\n-   into registers compatible with MODE and INNER_MODE.  Store the RTX for\n-   these regs into the corresponding array entry of LOCS.  */\n-\n static void\n-vector_init_prepare_elts (rtx *locs, rtx vals, int n_elts,\n-\t\t\t  enum machine_mode mode,\n-\t\t\t  enum machine_mode inner_mode)\n+vector_init_fpmerge (rtx target, rtx elt, enum machine_mode inner_mode)\n {\n-  enum machine_mode loc_mode;\n-  int i;\n+  rtx t1, t2, t3, t3_low;\n \n-  switch (mode)\n-    {\n-    case V2HImode:\n-      loc_mode = V4HImode;\n-      break;\n+  t1 = gen_reg_rtx (V4QImode);\n+  elt = convert_modes (SImode, inner_mode, elt, true);\n+  emit_move_insn (gen_lowpart (SImode, t1), elt);\n \n-    case V4QImode:\n-      loc_mode = V8QImode;\n-      break;\n+  t2 = gen_reg_rtx (V4QImode);\n+  emit_move_insn (t2, t1);\n \n-    case V4HImode:\n-    case V8QImode:\n-      loc_mode = mode;\n-      break;\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n+  t3 = gen_reg_rtx (V8QImode);\n+  t3_low = gen_lowpart (V4QImode, t3);\n \n-  gcc_assert (GET_MODE_SIZE (inner_mode) <= 4);\n-  for (i = 0; i < n_elts; i++)\n-    {\n-      rtx dst, elt = XVECEXP (vals, 0, i);\n-      int j;\n-\n-      /* Did we see this already?  If so just record it's location.  */\n-      dst = NULL_RTX;\n-      for (j = 0; j < i; j++)\n-\t{\n-\t  if (XVECEXP (vals, 0, j) == elt)\n-\t    {\n-\t      dst = locs[j];\n-\t      break;\n-\t    }\n-\t}\n-\n-      if (! dst)\n-\t{\n-\t  enum rtx_code code = GET_CODE (elt);\n+  emit_insn (gen_fpmerge_vis (t3, t1, t2));\n+  emit_move_insn (t1, t3_low);\n+  emit_move_insn (t2, t3_low);\n \n-\t  dst = gen_reg_rtx (loc_mode);\n+  emit_insn (gen_fpmerge_vis (t3, t1, t2));\n+  emit_move_insn (t1, t3_low);\n+  emit_move_insn (t2, t3_low);\n \n-\t  /* We use different strategies based upon whether the element\n-\t     is in memory or in a register.  When we start in a register\n-\t     and we're VIS3 capable, it's always cheaper to use the VIS3\n-\t     int-->fp register moves since we avoid having to use stack\n-\t     memory.  */\n-\t  if ((TARGET_VIS3 && (code == REG || code == SUBREG))\n-\t      || (CONSTANT_P (elt)\n-\t\t  && (const_zero_operand (elt, inner_mode)\n-\t\t      || const_all_ones_operand (elt, inner_mode))))\n-\t    {\n-\t      elt = convert_modes (SImode, inner_mode, elt, true);\n-\n-\t      emit_clobber (dst);\n-\t      emit_move_insn (gen_lowpart (SImode, dst), elt);\n-\t    }\n-\t  else\n-\t    {\n-\t      rtx m = elt;\n-\n-\t      if (CONSTANT_P (elt))\n-\t\t{\n-\t\t  m = force_const_mem (inner_mode, elt);\n-\t\t}\n-\t      else if (code != MEM)\n-\t\t{\n-\t\t  rtx stk\n-\t\t    = assign_stack_temp (inner_mode, GET_MODE_SIZE(inner_mode),\n-\t\t\t\t\t 0);\n-\t\t  emit_move_insn (stk, elt);\n-\t\t  m = stk;\n-\t\t}\n-\n-\t      switch (loc_mode)\n-\t\t{\n-\t\tcase V4HImode:\n-\t\t  emit_insn (gen_zero_extend_v4hi_vis (dst, m));\n-\t\t  break;\n-\t\tcase V8QImode:\n-\t\t  emit_insn (gen_zero_extend_v8qi_vis (dst, m));\n-\t\t  break;\n-\t\tdefault:\n-\t\t  gcc_unreachable ();\n-\t\t}\n-\t    }\n-\t}\n-      locs[i] = dst;\n-    }\n+  emit_insn (gen_fpmerge_vis (gen_lowpart (V8QImode, target), t1, t2));\n }\n \n-/* Subroutine of sparc_expand_vector_init.  Emit code to initialize TARGET to\n-   the N_ELTS values for individual fields contained in LOCS by means of VIS2\n-   instructions, among which N_UNIQUE are unique.  MODE and INNER_MODE are the\n-   modes describing TARGET.  */\n-\n static void\n-sparc_expand_vector_init_vis2 (rtx target, rtx *locs, int n_elts, int n_unique,\n-\t\t\t       enum machine_mode mode,\n-\t\t\t       enum machine_mode inner_mode)\n+vector_init_faligndata (rtx target, rtx elt, enum machine_mode inner_mode)\n {\n-  if (n_unique <= 4)\n-    {\n-      vector_init_bshuffle (target, locs, n_elts, mode, inner_mode);\n-    }\n-  else\n-    {\n-      int i;\n+  rtx t1 = gen_reg_rtx (V4HImode);\n \n-      gcc_assert (mode == V8QImode);\n+  elt = convert_modes (SImode, inner_mode, elt, true);\n \n-      emit_insn (gen_alignaddrsi_vis (gen_reg_rtx (SImode),\n-\t\t\t\t      force_reg (SImode, GEN_INT (7)),\n-\t\t\t\t      CONST0_RTX (SImode)));\n-      i = n_elts - 1;\n-      emit_insn (gen_faligndatav8qi_vis (target, locs[i], locs[i]));\n-      while (--i >= 0)\n-\temit_insn (gen_faligndatav8qi_vis (target, locs[i], target));\n-    }\n-}\n-\n-/* Subroutine of sparc_expand_vector_init.  Emit code to initialize TARGET to\n-   the N_ELTS values for individual fields contained in LOCS by means of VIS1\n-   instructions, among which N_UNIQUE are unique.  MODE is TARGET's mode.  */\n-\n-static void\n-sparc_expand_vector_init_vis1 (rtx target, rtx *locs, int n_elts, int n_unique,\n-\t\t\t       enum machine_mode mode)\n-{\n-  enum machine_mode full_mode = mode;\n-  rtx (*emitter)(rtx, rtx, rtx);\n-  int alignaddr_val, i;\n-  rtx tmp = target;\n-\n-  if (n_unique == 1 && mode == V8QImode)\n-    {\n-      rtx t2, t2_low, t1;\n-\n-      t1 = gen_reg_rtx (V4QImode);\n-      emit_move_insn (t1, gen_lowpart (V4QImode, locs[0]));\n-\n-      t2 = gen_reg_rtx (V8QImode);\n-      t2_low = gen_lowpart (V4QImode, t2);\n-\n-      /* xxxxxxAA --> xxxxxxxxxxxxAAAA\n-         xxxxAAAA --> xxxxxxxxAAAAAAAA\n-         AAAAAAAA --> AAAAAAAAAAAAAAAA */\n-      emit_insn (gen_fpmerge_vis (t2, t1, t1));\n-      emit_move_insn (t1, t2_low);\n-      emit_insn (gen_fpmerge_vis (t2, t1, t1));\n-      emit_move_insn (t1, t2_low);\n-      emit_insn (gen_fpmerge_vis (target, t1, t1));\n-      return;\n-    }\n-\n-  switch (mode)\n-    {\n-    case V2HImode:\n-      full_mode = V4HImode;\n-      /* FALLTHRU */\n-    case V4HImode:\n-      emitter = gen_faligndatav4hi_vis;\n-      alignaddr_val = 6;\n-      break;\n-\n-    case V4QImode:\n-      full_mode = V8QImode;\n-      /* FALLTHRU */\n-    case V8QImode:\n-      emitter = gen_faligndatav8qi_vis;\n-      alignaddr_val = 7;\n-      break;\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  if (full_mode != mode)\n-    tmp = gen_reg_rtx (full_mode);\n+  emit_move_insn (gen_lowpart (SImode, t1), elt);\n \n   emit_insn (gen_alignaddrsi_vis (gen_reg_rtx (SImode),\n-\t\t\t\t  force_reg (SImode, GEN_INT (alignaddr_val)),\n+\t\t\t\t  force_reg (SImode, GEN_INT (6)),\n \t\t\t\t  CONST0_RTX (SImode)));\n \n-  i = n_elts - 1;\n-  emit_insn (emitter (tmp, locs[i], locs[i]));\n-  while (--i >= 0)\n-    emit_insn (emitter (tmp, locs[i], tmp));\n-\n-  if (tmp != target)\n-    emit_move_insn (target, gen_highpart (mode, tmp));\n+  emit_insn (gen_faligndatav4hi_vis (target, t1, target));\n+  emit_insn (gen_faligndatav4hi_vis (target, t1, target));\n+  emit_insn (gen_faligndatav4hi_vis (target, t1, target));\n+  emit_insn (gen_faligndatav4hi_vis (target, t1, target));\n }\n \n /* Emit code to initialize TARGET to values for individual fields VALS.  */\n@@ -11646,30 +11377,19 @@ sparc_expand_vector_init (rtx target, rtx vals)\n   enum machine_mode mode = GET_MODE (target);\n   enum machine_mode inner_mode = GET_MODE_INNER (mode);\n   int n_elts = GET_MODE_NUNITS (mode);\n-  int i, n_var = 0, n_unique = 0;\n-  rtx locs[8];\n-\n-  gcc_assert (n_elts <= 8);\n+  int i, n_var = 0;\n+  bool all_same;\n+  rtx mem;\n \n+  all_same = true;\n   for (i = 0; i < n_elts; i++)\n     {\n       rtx x = XVECEXP (vals, 0, i);\n-      bool found = false;\n-      int j;\n-\n       if (!CONSTANT_P (x))\n \tn_var++;\n \n-      for (j = 0; j < i; j++)\n-\t{\n-\t  if (rtx_equal_p (x, XVECEXP (vals, 0, j)))\n-\t    {\n-\t      found = true;\n-\t      break;\n-\t    }\n-\t}\n-      if (!found)\n-\tn_unique++;\n+      if (i > 0 && !rtx_equal_p (x, XVECEXP (vals, 0, 0)))\n+\tall_same = false;\n     }\n \n   if (n_var == 0)\n@@ -11678,16 +11398,56 @@ sparc_expand_vector_init (rtx target, rtx vals)\n       return;\n     }\n \n-  if (vector_init_move_words (target, vals, mode, inner_mode))\n-    return;\n+  if (GET_MODE_SIZE (inner_mode) == GET_MODE_SIZE (mode))\n+    {\n+      if (GET_MODE_SIZE (inner_mode) == 4)\n+\t{\n+\t  emit_move_insn (gen_lowpart (SImode, target),\n+\t\t\t  gen_lowpart (SImode, XVECEXP (vals, 0, 0)));\n+\t  return;\n+\t}\n+      else if (GET_MODE_SIZE (inner_mode) == 8)\n+\t{\n+\t  emit_move_insn (gen_lowpart (DImode, target),\n+\t\t\t  gen_lowpart (DImode, XVECEXP (vals, 0, 0)));\n+\t  return;\n+\t}\n+    }\n+  else if (GET_MODE_SIZE (inner_mode) == GET_MODE_SIZE (word_mode)\n+\t   && GET_MODE_SIZE (mode) == 2 * GET_MODE_SIZE (word_mode))\n+    {\n+      emit_move_insn (gen_highpart (word_mode, target),\n+\t\t      gen_lowpart (word_mode, XVECEXP (vals, 0, 0)));\n+      emit_move_insn (gen_lowpart (word_mode, target),\n+\t\t      gen_lowpart (word_mode, XVECEXP (vals, 0, 1)));\n+      return;\n+    }\n \n-  vector_init_prepare_elts (locs, vals, n_elts, mode, inner_mode);\n+  if (all_same && GET_MODE_SIZE (mode) == 8)\n+    {\n+      if (TARGET_VIS2)\n+\t{\n+\t  vector_init_bshuffle (target, XVECEXP (vals, 0, 0), mode, inner_mode);\n+\t  return;\n+\t}\n+      if (mode == V8QImode)\n+\t{\n+\t  vector_init_fpmerge (target, XVECEXP (vals, 0, 0), inner_mode);\n+\t  return;\n+\t}\n+      if (mode == V4HImode)\n+\t{\n+\t  vector_init_faligndata (target, XVECEXP (vals, 0, 0), inner_mode);\n+\t  return;\n+\t}\n+    }\n \n-  if (TARGET_VIS2)\n-    sparc_expand_vector_init_vis2 (target, locs, n_elts, n_unique,\n-\t\t\t\t   mode, inner_mode);\n-  else\n-    sparc_expand_vector_init_vis1 (target, locs, n_elts, n_unique, mode);\n+  mem = assign_stack_temp (mode, GET_MODE_SIZE (mode), 0);\n+  for (i = 0; i < n_elts; i++)\n+    emit_move_insn (adjust_address_nv (mem, inner_mode,\n+\t\t\t\t       i * GET_MODE_SIZE (inner_mode)),\n+\t\t    XVECEXP (vals, 0, i));\n+  emit_move_insn (target, mem);\n }\n \n /* Implement TARGET_SECONDARY_RELOAD.  */"}, {"sha": "c059dc5e730c52e80941c4d30dcd46b17ed56053", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b38137d3da2a06e99682362b1a298fe5f67731a/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b38137d3da2a06e99682362b1a298fe5f67731a/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=2b38137d3da2a06e99682362b1a298fe5f67731a", "patch": "@@ -7830,60 +7830,6 @@\n   DONE;\n })\n \n-(define_expand \"zero_extend_v8qi_vis\"\n-  [(set (match_operand:V8QI 0 \"register_operand\" \"\")\n-        (vec_merge:V8QI\n-          (vec_duplicate:V8QI\n-            (match_operand:QI 1 \"memory_operand\" \"\"))\n-          (match_dup 2)\n-          (const_int 254)))]\n-  \"TARGET_VIS\"\n-{\n-  if (! REG_P (XEXP (operands[1], 0)))\n-    {\n-      rtx addr = force_reg (Pmode, XEXP (operands[1], 0));\n-      operands[1] = replace_equiv_address (operands[1], addr);\n-    }\n-  operands[2] = CONST0_RTX (V8QImode);\n-})\n-\n-(define_expand \"zero_extend_v4hi_vis\"\n-  [(set (match_operand:V4HI 0 \"register_operand\" \"\")\n-        (vec_merge:V4HI\n-          (vec_duplicate:V4HI\n-            (match_operand:HI 1 \"memory_operand\" \"\"))\n-          (match_dup 2)\n-          (const_int 14)))]\n-  \"TARGET_VIS\"\n-{\n-  if (! REG_P (XEXP (operands[1], 0)))\n-    {\n-      rtx addr = force_reg (Pmode, XEXP (operands[1], 0));\n-      operands[1] = replace_equiv_address (operands[1], addr);\n-    }\n-  operands[2] = CONST0_RTX (V4HImode);\n-})\n-\n-(define_insn \"*zero_extend_v8qi_<P:mode>_insn\"\n-  [(set (match_operand:V8QI 0 \"register_operand\" \"=e\")\n-        (vec_merge:V8QI\n-          (vec_duplicate:V8QI\n-            (mem:QI (match_operand:P 1 \"register_operand\" \"r\")))\n-          (match_operand:V8QI 2 \"const_zero_operand\" \"Y\")\n-          (const_int 254)))]\n-  \"TARGET_VIS\"\n-  \"ldda\\t[%1] 0xd0, %0\")\n-\n-(define_insn \"*zero_extend_v4hi_<P:mode>_insn\"\n-  [(set (match_operand:V4HI 0 \"register_operand\" \"=e\")\n-        (vec_merge:V4HI\n-          (vec_duplicate:V4HI\n-            (mem:HI (match_operand:P 1 \"register_operand\" \"r\")))\n-          (match_operand:V4HI 2 \"const_zero_operand\" \"Y\")\n-          (const_int 14)))]\n-  \"TARGET_VIS\"\n-  \"ldda\\t[%1] 0xd2, %0\")\n-\n (define_expand \"vec_init<mode>\"\n   [(match_operand:VMALL 0 \"register_operand\" \"\")\n    (match_operand:VMALL 1 \"\" \"\")]"}]}