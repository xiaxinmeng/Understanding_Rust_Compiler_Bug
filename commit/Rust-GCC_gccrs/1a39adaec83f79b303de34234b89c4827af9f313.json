{"sha": "1a39adaec83f79b303de34234b89c4827af9f313", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWEzOWFkYWVjODNmNzliMzAzZGUzNDIzNGI4OWM0ODI3YWY5ZjMxMw==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2010-07-22T21:55:32Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2010-07-22T21:55:32Z"}, "message": "tree-ssa-math-opts.c (is_widening_mult_rhs_p): New function.\n\ngcc/\n\t* tree-ssa-math-opts.c (is_widening_mult_rhs_p): New function.\n\t(is_widening_mult_p): Likewise.\n\t(convert_to_widen): Use them.\n\t(convert_plusminus_to_widen): Likewise.  Handle fixed-point types as\n\twell as integer ones.\n\nFrom-SVN: r162431", "tree": {"sha": "ae415a4d497cfe2e676f6d950251b0f94d8a1217", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ae415a4d497cfe2e676f6d950251b0f94d8a1217"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a39adaec83f79b303de34234b89c4827af9f313", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a39adaec83f79b303de34234b89c4827af9f313", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a39adaec83f79b303de34234b89c4827af9f313", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a39adaec83f79b303de34234b89c4827af9f313/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9362286d7477401ced3eb0b176071d6ec68ed976", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9362286d7477401ced3eb0b176071d6ec68ed976", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9362286d7477401ced3eb0b176071d6ec68ed976"}], "stats": {"total": 194, "additions": 121, "deletions": 73}, "files": [{"sha": "c1a496977b86a75674978c42bd384412f8ae1dea", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a39adaec83f79b303de34234b89c4827af9f313/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a39adaec83f79b303de34234b89c4827af9f313/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1a39adaec83f79b303de34234b89c4827af9f313", "patch": "@@ -1,3 +1,11 @@\n+2010-07-22  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* tree-ssa-math-opts.c (is_widening_mult_rhs_p): New function.\n+\t(is_widening_mult_p): Likewise.\n+\t(convert_to_widen): Use them.\n+\t(convert_plusminus_to_widen): Likewise.  Handle fixed-point types as\n+\twell as integer ones.\n+\n 2010-07-22  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* alias.c (true_dependence_1): New function, merged version of"}, {"sha": "9b96a60882756450b863abc2b097ebc5ba5561bc", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 113, "deletions": 73, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a39adaec83f79b303de34234b89c4827af9f313/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a39adaec83f79b303de34234b89c4827af9f313/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=1a39adaec83f79b303de34234b89c4827af9f313", "patch": "@@ -1260,93 +1260,127 @@ struct gimple_opt_pass pass_optimize_bswap =\n  }\n };\n \n-/* Process a single gimple statement STMT, which has a MULT_EXPR as\n-   its rhs, and try to convert it into a WIDEN_MULT_EXPR.  The return\n-   value is true iff we converted the statement.  */\n+/* Return true if RHS is a suitable operand for a widening multiplication.\n+   There are two cases:\n+\n+     - RHS makes some value twice as wide.  Store that value in *NEW_RHS_OUT\n+       if so, and store its type in *TYPE_OUT.\n+\n+     - RHS is an integer constant.  Store that value in *NEW_RHS_OUT if so,\n+       but leave *TYPE_OUT untouched.  */\n \n static bool\n-convert_mult_to_widen (gimple stmt)\n+is_widening_mult_rhs_p (tree rhs, tree *type_out, tree *new_rhs_out)\n+{\n+  gimple stmt;\n+  tree type, type1, rhs1;\n+  enum tree_code rhs_code;\n+\n+  if (TREE_CODE (rhs) == SSA_NAME)\n+    {\n+      type = TREE_TYPE (rhs);\n+      stmt = SSA_NAME_DEF_STMT (rhs);\n+      if (!is_gimple_assign (stmt))\n+\treturn false;\n+\n+      rhs_code = gimple_assign_rhs_code (stmt);\n+      if (TREE_CODE (type) == INTEGER_TYPE\n+\t  ? !CONVERT_EXPR_CODE_P (rhs_code)\n+\t  : rhs_code != FIXED_CONVERT_EXPR)\n+\treturn false;\n+\n+      rhs1 = gimple_assign_rhs1 (stmt);\n+      type1 = TREE_TYPE (rhs1);\n+      if (TREE_CODE (type1) != TREE_CODE (type)\n+\t  || TYPE_PRECISION (type1) * 2 != TYPE_PRECISION (type))\n+\treturn false;\n+\n+      *new_rhs_out = rhs1;\n+      *type_out = type1;\n+      return true;\n+    }\n+\n+  if (TREE_CODE (rhs) == INTEGER_CST)\n+    {\n+      *new_rhs_out = rhs;\n+      *type_out = NULL;\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n+/* Return true if STMT performs a widening multiplication.  If so,\n+   store the unwidened types of the operands in *TYPE1_OUT and *TYPE2_OUT\n+   respectively.  Also fill *RHS1_OUT and *RHS2_OUT such that converting\n+   those operands to types *TYPE1_OUT and *TYPE2_OUT would give the\n+   operands of the multiplication.  */\n+\n+static bool\n+is_widening_mult_p (gimple stmt,\n+\t\t    tree *type1_out, tree *rhs1_out,\n+\t\t    tree *type2_out, tree *rhs2_out)\n {\n-  gimple rhs1_stmt = NULL, rhs2_stmt = NULL;\n-  tree type1 = NULL, type2 = NULL;\n-  tree rhs1, rhs2, rhs1_convop = NULL, rhs2_convop = NULL;\n-  enum tree_code rhs1_code, rhs2_code;\n   tree type;\n \n   type = TREE_TYPE (gimple_assign_lhs (stmt));\n+  if (TREE_CODE (type) != INTEGER_TYPE\n+      && TREE_CODE (type) != FIXED_POINT_TYPE)\n+    return false;\n \n-  if (TREE_CODE (type) != INTEGER_TYPE)\n+  if (!is_widening_mult_rhs_p (gimple_assign_rhs1 (stmt), type1_out, rhs1_out))\n     return false;\n \n-  rhs1 = gimple_assign_rhs1 (stmt);\n-  rhs2 = gimple_assign_rhs2 (stmt);\n+  if (!is_widening_mult_rhs_p (gimple_assign_rhs2 (stmt), type2_out, rhs2_out))\n+    return false;\n \n-  if (TREE_CODE (rhs1) == SSA_NAME)\n+  if (*type1_out == NULL)\n     {\n-      rhs1_stmt = SSA_NAME_DEF_STMT (rhs1);\n-      if (!is_gimple_assign (rhs1_stmt))\n-\treturn false;\n-      rhs1_code = gimple_assign_rhs_code (rhs1_stmt);\n-      if (!CONVERT_EXPR_CODE_P (rhs1_code))\n-\treturn false;\n-      rhs1_convop = gimple_assign_rhs1 (rhs1_stmt);\n-      type1 = TREE_TYPE (rhs1_convop);\n-      if (TYPE_PRECISION (type1) * 2 != TYPE_PRECISION (type))\n+      if (*type2_out == NULL || !int_fits_type_p (*rhs1_out, *type2_out))\n \treturn false;\n+      *type1_out = *type2_out;\n     }\n-  else if (TREE_CODE (rhs1) != INTEGER_CST)\n-    return false;\n \n-  if (TREE_CODE (rhs2) == SSA_NAME)\n+  if (*type2_out == NULL)\n     {\n-      rhs2_stmt = SSA_NAME_DEF_STMT (rhs2);\n-      if (!is_gimple_assign (rhs2_stmt))\n-\treturn false;\n-      rhs2_code = gimple_assign_rhs_code (rhs2_stmt);\n-      if (!CONVERT_EXPR_CODE_P (rhs2_code))\n-\treturn false;\n-      rhs2_convop = gimple_assign_rhs1 (rhs2_stmt);\n-      type2 = TREE_TYPE (rhs2_convop);\n-      if (TYPE_PRECISION (type2) * 2 != TYPE_PRECISION (type))\n+      if (!int_fits_type_p (*rhs2_out, *type1_out))\n \treturn false;\n+      *type2_out = *type1_out;\n     }\n-  else if (TREE_CODE (rhs2) != INTEGER_CST)\n-    return false;\n \n-  if (rhs1_stmt == NULL && rhs2_stmt == NULL)\n-    return false;\n+  return true;\n+}\n \n-  /* Verify that the machine can perform a widening multiply in this\n-     mode/signedness combination, otherwise this transformation is\n-     likely to pessimize code.  */\n-  if ((rhs1_stmt == NULL || TYPE_UNSIGNED (type1))\n-      && (rhs2_stmt == NULL || TYPE_UNSIGNED (type2))\n-      && (optab_handler (umul_widen_optab, TYPE_MODE (type))\n-\t  == CODE_FOR_nothing))\n-    return false;\n-  else if ((rhs1_stmt == NULL || !TYPE_UNSIGNED (type1))\n-\t   && (rhs2_stmt == NULL || !TYPE_UNSIGNED (type2))\n-\t   && (optab_handler (smul_widen_optab, TYPE_MODE (type))\n-\t       == CODE_FOR_nothing))\n-    return false;\n-  else if (rhs1_stmt != NULL && rhs2_stmt != NULL\n-\t   && (TYPE_UNSIGNED (type1) != TYPE_UNSIGNED (type2))\n-\t   && (optab_handler (usmul_widen_optab, TYPE_MODE (type))\n-\t       == CODE_FOR_nothing))\n+/* Process a single gimple statement STMT, which has a MULT_EXPR as\n+   its rhs, and try to convert it into a WIDEN_MULT_EXPR.  The return\n+   value is true iff we converted the statement.  */\n+\n+static bool\n+convert_mult_to_widen (gimple stmt)\n+{\n+  tree lhs, rhs1, rhs2, type, type1, type2;\n+  enum insn_code handler;\n+\n+  lhs = gimple_assign_lhs (stmt);\n+  type = TREE_TYPE (lhs);\n+  if (TREE_CODE (type) != INTEGER_TYPE)\n     return false;\n \n-  if ((rhs1_stmt == NULL && !int_fits_type_p (rhs1, type2))\n-      || (rhs2_stmt == NULL && !int_fits_type_p (rhs2, type1)))\n+  if (!is_widening_mult_p (stmt, &type1, &rhs1, &type2, &rhs2))\n     return false;\n \n-  if (rhs1_stmt == NULL)\n-    gimple_assign_set_rhs1 (stmt, fold_convert (type2, rhs1));\n+  if (TYPE_UNSIGNED (type1) && TYPE_UNSIGNED (type2))\n+    handler = optab_handler (umul_widen_optab, TYPE_MODE (type));\n+  else if (!TYPE_UNSIGNED (type1) && !TYPE_UNSIGNED (type2))\n+    handler = optab_handler (smul_widen_optab, TYPE_MODE (type));\n   else\n-    gimple_assign_set_rhs1 (stmt, rhs1_convop);\n-  if (rhs2_stmt == NULL)\n-    gimple_assign_set_rhs2 (stmt, fold_convert (type1, rhs2));\n-  else\n-    gimple_assign_set_rhs2 (stmt, rhs2_convop);\n+    handler = optab_handler (usmul_widen_optab, TYPE_MODE (type));\n+\n+  if (handler == CODE_FOR_nothing)\n+    return false;\n+\n+  gimple_assign_set_rhs1 (stmt, fold_convert (type1, rhs1));\n+  gimple_assign_set_rhs2 (stmt, fold_convert (type2, rhs2));\n   gimple_assign_set_rhs_code (stmt, WIDEN_MULT_EXPR);\n   update_stmt (stmt);\n   return true;\n@@ -1363,15 +1397,16 @@ convert_plusminus_to_widen (gimple_stmt_iterator *gsi, gimple stmt,\n \t\t\t    enum tree_code code)\n {\n   gimple rhs1_stmt = NULL, rhs2_stmt = NULL;\n-  tree type;\n+  tree type, type1, type2;\n   tree lhs, rhs1, rhs2, mult_rhs1, mult_rhs2, add_rhs;\n   enum tree_code rhs1_code = ERROR_MARK, rhs2_code = ERROR_MARK;\n   optab this_optab;\n   enum tree_code wmult_code;\n \n   lhs = gimple_assign_lhs (stmt);\n   type = TREE_TYPE (lhs);\n-  if (TREE_CODE (type) != INTEGER_TYPE)\n+  if (TREE_CODE (type) != INTEGER_TYPE\n+      && TREE_CODE (type) != FIXED_POINT_TYPE)\n     return false;\n \n   if (code == MINUS_EXPR)\n@@ -1407,20 +1442,25 @@ convert_plusminus_to_widen (gimple_stmt_iterator *gsi, gimple stmt,\n   else\n     return false;\n \n-  if (rhs1_code == MULT_EXPR)\n+  if (code == PLUS_EXPR && rhs1_code == MULT_EXPR)\n     {\n-      if (!convert_mult_to_widen (rhs1_stmt))\n+      if (!is_widening_mult_p (rhs1_stmt, &type1, &mult_rhs1,\n+\t\t\t       &type2, &mult_rhs2))\n \treturn false;\n-      rhs1_code = gimple_assign_rhs_code (rhs1_stmt);\n+      mult_rhs1 = fold_convert (type1, mult_rhs1);\n+      mult_rhs2 = fold_convert (type2, mult_rhs2);\n+      add_rhs = rhs2;\n     }\n-  if (rhs2_code == MULT_EXPR)\n+  else if (rhs2_code == MULT_EXPR)\n     {\n-      if (!convert_mult_to_widen (rhs2_stmt))\n+      if (!is_widening_mult_p (rhs1_stmt, &type1, &mult_rhs1,\n+\t\t\t       &type2, &mult_rhs2))\n \treturn false;\n-      rhs2_code = gimple_assign_rhs_code (rhs2_stmt);\n+      mult_rhs1 = fold_convert (type1, mult_rhs1);\n+      mult_rhs2 = fold_convert (type2, mult_rhs2);\n+      add_rhs = rhs1;\n     }\n-  \n-  if (code == PLUS_EXPR && rhs1_code == WIDEN_MULT_EXPR)\n+  else if (code == PLUS_EXPR && rhs1_code == WIDEN_MULT_EXPR)\n     {\n       mult_rhs1 = gimple_assign_rhs1 (rhs1_stmt);\n       mult_rhs2 = gimple_assign_rhs2 (rhs1_stmt);"}]}