{"sha": "e7cf2f7789dccbb1d8aac6222b2b1c0f4d5f18f6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTdjZjJmNzc4OWRjY2JiMWQ4YWFjNjIyMmIyYjFjMGY0ZDVmMThmNg==", "commit": {"author": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2020-10-03T14:08:13Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2020-11-28T21:13:21Z"}, "message": "Added skeleton for macro expansion and added way to convert MetaItems back to Attributes (e.g. for cfg_attr use)", "tree": {"sha": "8afd482e28be8b98920f34cec016523c714f8112", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8afd482e28be8b98920f34cec016523c714f8112"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e7cf2f7789dccbb1d8aac6222b2b1c0f4d5f18f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7cf2f7789dccbb1d8aac6222b2b1c0f4d5f18f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7cf2f7789dccbb1d8aac6222b2b1c0f4d5f18f6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7cf2f7789dccbb1d8aac6222b2b1c0f4d5f18f6/comments", "author": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ed062a0be3e2c6e7bd50d25d9ede336fad7be38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ed062a0be3e2c6e7bd50d25d9ede336fad7be38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ed062a0be3e2c6e7bd50d25d9ede336fad7be38"}], "stats": {"total": 402, "additions": 209, "deletions": 193}, "files": [{"sha": "3293f908e8ecef745f0501077f669ae749f9e5be", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7cf2f7789dccbb1d8aac6222b2b1c0f4d5f18f6/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7cf2f7789dccbb1d8aac6222b2b1c0f4d5f18f6/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=e7cf2f7789dccbb1d8aac6222b2b1c0f4d5f18f6", "patch": "@@ -72,6 +72,7 @@ GRS_OBJS = \\\n     rust/rust-resolution.o \\\n     rust/rust-scan.o \\\n     rust/rust-compile.o \\\n+    rust/rust-macro-expand.o \\\n     $(END)\n # removed object files from here \n \n@@ -211,7 +212,7 @@ CFLAGS-rust/rust-lang.o += -DDEFAULT_TARGET_VERSION=\\\"$(version)\\\" \\\n \t-DDEFAULT_TARGET_MACHINE=\\\"$(target_noncanonical)\\\"\n \n # cross-folder includes - add new folders later\n-RUST_INCLUDES = -I $(srcdir)/rust -I $(srcdir)/rust/lex -I $(srcdir)/rust/parse -I $(srcdir)/rust/ast -I $(srcdir)/rust/analysis -I $(srcdir)/rust/backend\n+RUST_INCLUDES = -I $(srcdir)/rust -I $(srcdir)/rust/lex -I $(srcdir)/rust/parse -I $(srcdir)/rust/ast -I $(srcdir)/rust/analysis -I $(srcdir)/rust/backend -I $(srcdir)/rust/expand\n \n # add files that require cross-folder includes - currently rust-lang.o, rust-lex.o\n CFLAGS-rust/rust-lang.o += $(RUST_INCLUDES)\n@@ -245,3 +246,8 @@ rust/%.o: rust/analysis/%.cc\n rust/%.o: rust/backend/%.cc\n \t$(COMPILE) -std=c++11 $(RUST_INCLUDES) $<\n \t$(POSTCOMPILE)\n+\n+# build rust/backend files in rust folder\n+rust/%.o: rust/expand/%.cc\n+\t$(COMPILE) -std=c++11 $(RUST_INCLUDES) $<\n+\t$(POSTCOMPILE)"}, {"sha": "0cdac5f5681e37a9d306dbccf310fb515c16cfc7", "filename": "gcc/rust/ast/rust-ast-full-test.cc", "status": "modified", "additions": 103, "deletions": 55, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7cf2f7789dccbb1d8aac6222b2b1c0f4d5f18f6/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7cf2f7789dccbb1d8aac6222b2b1c0f4d5f18f6/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-full-test.cc?ref=e7cf2f7789dccbb1d8aac6222b2b1c0f4d5f18f6", "patch": "@@ -2448,7 +2448,7 @@ MatchExpr::as_string () const\n   else\n     {\n       for (const auto &arm : match_arms)\n-\t  str += \"\\n  \" + arm.as_string ();\n+\tstr += \"\\n  \" + arm.as_string ();\n     }\n \n   return str;\n@@ -4635,16 +4635,10 @@ DelimTokenTree::parse_to_meta_item () const\n \n   /* assume top-level delim token tree in attribute - convert all nested ones\n    * to token stream */\n-  std::vector<std::unique_ptr<Token>> token_stream = to_token_stream ();\n-\n-  // TODO: replace this with a specialised converter that the token stream is\n-  // moved into\n-  /*int i = 0;\n-  std::vector<std::unique_ptr<MetaItemInner>> meta_items(\n-    parse_meta_item_seq(token_stream, i));*/\n-  // something like:\n+  std::vector<std::unique_ptr<Token> > token_stream = to_token_stream ();\n+\n   MacroParser parser (std::move (token_stream));\n-  std::vector<std::unique_ptr<MetaItemInner>> meta_items (\n+  std::vector<std::unique_ptr<MetaItemInner> > meta_items (\n     parser.parse_meta_item_seq ());\n \n   return new AttrInputMetaItemContainer (std::move (meta_items));\n@@ -4729,15 +4723,14 @@ MacroParser::parse_meta_item_inner ()\n \n   /* HACK: parse parenthesised sequence, and then try conversions to other\n    * stuff */\n-  std::vector<std::unique_ptr<MetaItemInner>> meta_items\n+  std::vector<std::unique_ptr<MetaItemInner> > meta_items\n     = parse_meta_item_seq ();\n \n   // pass for meta name value str\n   std::vector<MetaNameValueStr> meta_name_value_str_items;\n   for (const auto &item : meta_items)\n     {\n-      std::unique_ptr<MetaNameValueStr> converted_item (\n-\titem->to_meta_name_value_str ());\n+      std::unique_ptr<MetaNameValueStr> converted_item = item->to_meta_name_value_str ();\n       if (converted_item == nullptr)\n \t{\n \t  meta_name_value_str_items.clear ();\n@@ -4814,7 +4807,7 @@ MacroParser::parse_path_meta_item ()\n   switch (peek_token ()->get_id ())\n     {\n       case LEFT_PAREN: {\n-\tstd::vector<std::unique_ptr<MetaItemInner>> meta_items\n+\tstd::vector<std::unique_ptr<MetaItemInner> > meta_items\n \t  = parse_meta_item_seq ();\n \n \treturn std::unique_ptr<MetaItemSeq> (\n@@ -4852,7 +4845,7 @@ MacroParser::parse_path_meta_item ()\n \n /* Parses a parenthesised sequence of meta item inners. Parentheses are\n  * required here. */\n-std::vector<std::unique_ptr<MetaItemInner>>\n+std::vector<std::unique_ptr<MetaItemInner> >\n MacroParser::parse_meta_item_seq ()\n {\n   if (stream_pos != 0)\n@@ -4864,7 +4857,7 @@ MacroParser::parse_meta_item_seq ()\n \n   // int i = 0;\n   int vec_length = token_stream.size ();\n-  std::vector<std::unique_ptr<MetaItemInner>> meta_items;\n+  std::vector<std::unique_ptr<MetaItemInner> > meta_items;\n \n   if (peek_token ()->get_id () != LEFT_PAREN)\n     {\n@@ -4905,10 +4898,10 @@ MacroParser::parse_meta_item_seq ()\n \n /* Collects any nested token trees into a flat token stream, suitable for\n  * parsing. */\n-std::vector<std::unique_ptr<Token>>\n+std::vector<std::unique_ptr<Token> >\n DelimTokenTree::to_token_stream () const\n {\n-  std::vector<std::unique_ptr<Token>> tokens;\n+  std::vector<std::unique_ptr<Token> > tokens;\n \n   // simulate presence of delimiters\n   tokens.push_back (\n@@ -4917,7 +4910,7 @@ DelimTokenTree::to_token_stream () const\n \n   for (const auto &tree : token_trees)\n     {\n-      std::vector<std::unique_ptr<Token>> stream = tree->to_token_stream ();\n+      std::vector<std::unique_ptr<Token> > stream = tree->to_token_stream ();\n \n       tokens.insert (tokens.end (), std::make_move_iterator (stream.begin ()),\n \t\t     std::make_move_iterator (stream.end ()));\n@@ -5060,9 +5053,7 @@ AttrInputMetaItemContainer::check_cfg_predicate (const Session &session) const\n   for (const auto &inner_item : items)\n     {\n       if (!inner_item->check_cfg_predicate (session))\n-\t{\n-\t  return false;\n-\t}\n+\treturn false;\n     }\n \n   /* TODO: as far as I can tell, there should only be a single element to\n@@ -5088,9 +5079,7 @@ MetaListNameValueStr::check_cfg_predicate (const Session &session) const\n       for (const auto &str : strs)\n \t{\n \t  if (!str.check_cfg_predicate (session))\n-\t    {\n-\t      return false;\n-\t    }\n+\t    return false;\n \t}\n       return true;\n     }\n@@ -5099,9 +5088,7 @@ MetaListNameValueStr::check_cfg_predicate (const Session &session) const\n       for (const auto &str : strs)\n \t{\n \t  if (str.check_cfg_predicate (session))\n-\t    {\n-\t      return true;\n-\t    }\n+\t    return true;\n \t}\n       return false;\n     }\n@@ -5140,9 +5127,7 @@ MetaListPaths::check_cfg_predicate (const Session &session) const\n       for (const auto &path : paths)\n \t{\n \t  if (!check_path_exists_in_cfg (session, path))\n-\t    {\n-\t      return false;\n-\t    }\n+\t    return false;\n \t}\n       return true;\n     }\n@@ -5151,9 +5136,7 @@ MetaListPaths::check_cfg_predicate (const Session &session) const\n       for (const auto &path : paths)\n \t{\n \t  if (check_path_exists_in_cfg (session, path))\n-\t    {\n-\t      return true;\n-\t    }\n+\t    return true;\n \t}\n       return false;\n     }\n@@ -5190,9 +5173,7 @@ MetaListPaths::check_path_exists_in_cfg (const Session &session,\n {\n   auto it = session.options.target_data.features.find (path.as_string ());\n   if (it != session.options.target_data.features.end ())\n-    {\n-      return true;\n-    }\n+    return true;\n   return false;\n }\n \n@@ -5204,9 +5185,7 @@ MetaItemSeq::check_cfg_predicate (const Session &session) const\n       for (const auto &item : seq)\n \t{\n \t  if (!item->check_cfg_predicate (session))\n-\t    {\n-\t      return false;\n-\t    }\n+\t    return false;\n \t}\n       return true;\n     }\n@@ -5215,18 +5194,16 @@ MetaItemSeq::check_cfg_predicate (const Session &session) const\n       for (const auto &item : seq)\n \t{\n \t  if (item->check_cfg_predicate (session))\n-\t    {\n-\t      return true;\n-\t    }\n+\t    return true;\n \t}\n       return false;\n     }\n   else if (path.as_string () == \"not\")\n     {\n       if (seq.size () != 1)\n \t{\n-\t  // HACK: convert vector platform-dependent size_type to string to\n-\t  // use in printf\n+\t  /* HACK: convert vector platform-dependent size_type to string to\n+\t   * use in printf */\n \t  rust_error_at (Linemap::unknown_location (),\n \t\t\t \"cfg predicate could not be checked for MetaItemSeq \"\n \t\t\t \"with ident of 'not' \"\n@@ -5253,9 +5230,7 @@ MetaWord::check_cfg_predicate (const Session &session) const\n {\n   auto it = session.options.target_data.features.find (ident);\n   if (it != session.options.target_data.features.end ())\n-    {\n-      return true;\n-    }\n+    return true;\n   return false;\n }\n \n@@ -5268,9 +5243,7 @@ MetaItemPath::check_cfg_predicate (const Session &session) const\n    * (though this shouldn't occur). */\n   auto it = session.options.target_data.features.find (path.as_string ());\n   if (it != session.options.target_data.features.end ())\n-    {\n-      return true;\n-    }\n+    return true;\n   return false;\n }\n \n@@ -5287,17 +5260,92 @@ MetaItemPathLit::check_cfg_predicate (const Session &session) const\n \t\t\t\t\t\t\t lit.as_string ());\n }\n \n-std::vector<std::unique_ptr<Token>>\n+std::vector<std::unique_ptr<Token> >\n Token::to_token_stream () const\n {\n-  // initialisation list doesn't work as it needs copy constructor, so have to\n-  // do this\n-  std::vector<std::unique_ptr<Token>> dummy_vector;\n+  /* initialisation list doesn't work as it needs copy constructor, so have to\n+   * do this */\n+  std::vector<std::unique_ptr<Token> > dummy_vector;\n   dummy_vector.reserve (1);\n   dummy_vector.push_back (std::unique_ptr<Token> (clone_token_impl ()));\n   return dummy_vector;\n }\n \n+Attribute\n+MetaNameValueStr::to_attribute () const\n+{\n+  LiteralExpr lit_expr (str, Literal::LitType::STRING, Location ());\n+  return Attribute (SimplePath::from_str (ident),\n+\t\t    std::unique_ptr<AttrInputLiteral> (\n+\t\t      new AttrInputLiteral (std::move (lit_expr))));\n+}\n+\n+Attribute\n+MetaItemPath::to_attribute () const\n+{\n+  return Attribute (path, nullptr);\n+}\n+\n+Attribute\n+MetaItemSeq::to_attribute () const\n+{\n+  std::vector<std::unique_ptr<MetaItemInner> > new_seq;\n+  new_seq.reserve (seq.size ());\n+  for (const auto &e : seq)\n+    new_seq.push_back (e->clone_meta_item_inner ());\n+\n+  std::unique_ptr<AttrInputMetaItemContainer> new_seq_container (\n+    new AttrInputMetaItemContainer (std::move (new_seq)));\n+  return Attribute (path, std::move (new_seq_container));\n+}\n+\n+Attribute\n+MetaWord::to_attribute () const\n+{\n+  return Attribute (SimplePath::from_str (ident), nullptr);\n+}\n+\n+Attribute\n+MetaListPaths::to_attribute () const\n+{\n+  /* probably one of the most annoying conversions - have to lose specificity by\n+   * turning it into just AttrInputMetaItemContainer (i.e. paths-only nature is\n+   * no longer known). If conversions back are required, might have to do a\n+   * \"check all are paths\" pass or something. */\n+\n+  std::vector<std::unique_ptr<MetaItemInner> > new_seq;\n+  new_seq.reserve (paths.size ());\n+  for (const auto &e : paths)\n+    new_seq.push_back (std::unique_ptr<MetaItemPath> (new MetaItemPath (e)));\n+\n+  std::unique_ptr<AttrInputMetaItemContainer> new_seq_container (\n+    new AttrInputMetaItemContainer (std::move (new_seq)));\n+  return Attribute (SimplePath::from_str (ident),\n+\t\t    std::move (new_seq_container));\n+}\n+\n+Attribute\n+MetaListNameValueStr::to_attribute () const\n+{\n+  std::vector<std::unique_ptr<MetaItemInner> > new_seq;\n+  new_seq.reserve (strs.size ());\n+  for (const auto &e : strs)\n+    new_seq.push_back (\n+      std::unique_ptr<MetaNameValueStr> (new MetaNameValueStr (e)));\n+\n+  std::unique_ptr<AttrInputMetaItemContainer> new_seq_container (\n+    new AttrInputMetaItemContainer (std::move (new_seq)));\n+  return Attribute (SimplePath::from_str (ident),\n+\t\t    std::move (new_seq_container));\n+}\n+\n+Attribute\n+MetaItemPathLit::to_attribute () const\n+{\n+  return Attribute (path, std::unique_ptr<AttrInputLiteral> (\n+\t\t\t    new AttrInputLiteral (lit)));\n+}\n+\n /* Visitor implementations - these are short but inlining can't happen anyway\n  * due to virtual functions and I didn't want to make the ast header includes\n  * any longer than they already are. */"}, {"sha": "ad3722fb350ad0ce0a271b91258f712daad35844", "filename": "gcc/rust/ast/rust-ast.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7cf2f7789dccbb1d8aac6222b2b1c0f4d5f18f6/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7cf2f7789dccbb1d8aac6222b2b1c0f4d5f18f6/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=e7cf2f7789dccbb1d8aac6222b2b1c0f4d5f18f6", "patch": "@@ -638,14 +638,16 @@ class MetaItemInner\n \n   /* HACK: used to simplify parsing - creates a copy of that type, or returns\n    * null */\n-  virtual MetaNameValueStr *to_meta_name_value_str () const { return nullptr; }\n+  virtual std::unique_ptr<MetaNameValueStr> to_meta_name_value_str () const { return nullptr; }\n \n   // HACK: used to simplify parsing - same thing\n   virtual SimplePath to_path_item () const\n   {\n     return SimplePath::create_empty ();\n   }\n \n+  virtual Attribute to_attribute() const { return Attribute::create_empty (); }\n+\n   virtual bool check_cfg_predicate (const Session &session) const = 0;\n };\n "}, {"sha": "fd6913f31e2c8d3f7f0e5630051b5e32c7550336", "filename": "gcc/rust/ast/rust-expr.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7cf2f7789dccbb1d8aac6222b2b1c0f4d5f18f6/gcc%2Frust%2Fast%2Frust-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7cf2f7789dccbb1d8aac6222b2b1c0f4d5f18f6/gcc%2Frust%2Fast%2Frust-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-expr.h?ref=e7cf2f7789dccbb1d8aac6222b2b1c0f4d5f18f6", "patch": "@@ -180,6 +180,8 @@ class MetaItemPathLit : public MetaItem\n   /* TODO: return true if \"ident\" is defined and value of it is \"lit\", return\n    * false otherwise */\n \n+  Attribute to_attribute () const override;\n+\n protected:\n   // Use covariance to implement clone function as returning this type\n   MetaItemPathLit *clone_meta_item_inner_impl () const override"}, {"sha": "b51b149bcb8401dd00a1595f0a8f8da48d53476c", "filename": "gcc/rust/ast/rust-macro.h", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7cf2f7789dccbb1d8aac6222b2b1c0f4d5f18f6/gcc%2Frust%2Fast%2Frust-macro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7cf2f7789dccbb1d8aac6222b2b1c0f4d5f18f6/gcc%2Frust%2Fast%2Frust-macro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-macro.h?ref=e7cf2f7789dccbb1d8aac6222b2b1c0f4d5f18f6", "patch": "@@ -112,7 +112,7 @@ class MacroMatchRepetition : public MacroMatch\n   };\n \n private:\n-  std::vector<std::unique_ptr<MacroMatch>> matches;\n+  std::vector<std::unique_ptr<MacroMatch> > matches;\n   MacroRepOp op;\n \n   // bool has_sep;\n@@ -126,7 +126,7 @@ class MacroMatchRepetition : public MacroMatch\n   // Returns whether macro match repetition has separator token.\n   bool has_sep () const { return sep != NULL; }\n \n-  MacroMatchRepetition (std::vector<std::unique_ptr<MacroMatch>> matches,\n+  MacroMatchRepetition (std::vector<std::unique_ptr<MacroMatch> > matches,\n \t\t\tMacroRepOp op, std::unique_ptr<MacroRepSep> sep)\n     : matches (std::move (matches)), op (op), sep (std::move (sep))\n   {}\n@@ -174,7 +174,7 @@ class MacroMatchRepetition : public MacroMatch\n class MacroMatcher : public MacroMatch\n {\n   DelimType delim_type;\n-  std::vector<std::unique_ptr<MacroMatch>> matches;\n+  std::vector<std::unique_ptr<MacroMatch> > matches;\n \n   // TODO: think of way to mark invalid that doesn't take up more space\n   bool is_invalid;\n@@ -183,7 +183,7 @@ class MacroMatcher : public MacroMatch\n \n public:\n   MacroMatcher (DelimType delim_type,\n-\t\tstd::vector<std::unique_ptr<MacroMatch>> matches)\n+\t\tstd::vector<std::unique_ptr<MacroMatch> > matches)\n     : delim_type (delim_type), matches (std::move (matches)), is_invalid (false)\n   {}\n \n@@ -392,6 +392,8 @@ class MetaItemPath : public MetaItem\n \n   bool check_cfg_predicate (const Session &session) const override;\n \n+  Attribute to_attribute () const override;\n+\n protected:\n   // Use covariance to implement clone function as returning this type\n   MetaItemPath *clone_meta_item_inner_impl () const override\n@@ -404,11 +406,11 @@ class MetaItemPath : public MetaItem\n class MetaItemSeq : public MetaItem\n {\n   SimplePath path;\n-  std::vector<std::unique_ptr<MetaItemInner>> seq;\n+  std::vector<std::unique_ptr<MetaItemInner> > seq;\n \n public:\n   MetaItemSeq (SimplePath path,\n-\t       std::vector<std::unique_ptr<MetaItemInner>> seq)\n+\t       std::vector<std::unique_ptr<MetaItemInner> > seq)\n     : path (std::move (path)), seq (std::move (seq))\n   {}\n \n@@ -443,6 +445,8 @@ class MetaItemSeq : public MetaItem\n \n   bool check_cfg_predicate (const Session &session) const override;\n \n+  Attribute to_attribute () const override;\n+\n protected:\n   // Use covariance to implement clone function as returning this type\n   MetaItemSeq *clone_meta_item_inner_impl () const override\n@@ -465,6 +469,8 @@ class MetaWord : public MetaItem\n \n   bool check_cfg_predicate (const Session &session) const override;\n \n+  Attribute to_attribute () const override;\n+\n protected:\n   // Use covariance to implement clone function as returning this type\n   MetaWord *clone_meta_item_inner_impl () const override\n@@ -489,13 +495,15 @@ class MetaNameValueStr : public MetaItem\n   void accept_vis (ASTVisitor &vis) override;\n \n   // HACK: used to simplify parsing - creates a copy of this\n-  MetaNameValueStr *to_meta_name_value_str () const override\n+  std::unique_ptr<MetaNameValueStr> to_meta_name_value_str () const override\n   {\n-    return clone_meta_item_inner_impl ();\n+    return std::unique_ptr<MetaNameValueStr> (clone_meta_item_inner_impl ());\n   }\n \n   bool check_cfg_predicate (const Session &session) const override;\n \n+  Attribute to_attribute () const override;\n+\n protected:\n   // Use covariance to implement clone function as returning this type\n   MetaNameValueStr *clone_meta_item_inner_impl () const override\n@@ -522,6 +530,8 @@ class MetaListPaths : public MetaItem\n \n   bool check_cfg_predicate (const Session &session) const override;\n \n+  Attribute to_attribute () const override;\n+\n private:\n   bool check_path_exists_in_cfg (const Session &session,\n \t\t\t\t const SimplePath &path) const;\n@@ -551,6 +561,8 @@ class MetaListNameValueStr : public MetaItem\n \n   bool check_cfg_predicate (const Session &session) const override;\n \n+  Attribute to_attribute () const override;\n+\n protected:\n   // Use covariance to implement clone function as returning this type\n   MetaListNameValueStr *clone_meta_item_inner_impl () const override\n@@ -563,22 +575,22 @@ class MetaListNameValueStr : public MetaItem\n struct MacroParser\n {\n private:\n-  std::vector<std::unique_ptr<Token>> token_stream;\n+  std::vector<std::unique_ptr<Token> > token_stream;\n   /* probably have to make this mutable (mutable int stream_pos) otherwise const\n    * has to be removed up to DelimTokenTree or further ok since this changing\n    * would have an effect on the results of the methods run (i.e. not logically\n    * const), the parsing methods shouldn't be const */\n   int stream_pos;\n \n public:\n-  MacroParser (std::vector<std::unique_ptr<Token>> token_stream,\n+  MacroParser (std::vector<std::unique_ptr<Token> > token_stream,\n \t       int stream_start_pos = 0)\n     : token_stream (std::move (token_stream)), stream_pos (stream_start_pos)\n   {}\n \n   ~MacroParser () = default;\n \n-  std::vector<std::unique_ptr<MetaItemInner>> parse_meta_item_seq ();\n+  std::vector<std::unique_ptr<MetaItemInner> > parse_meta_item_seq ();\n \n private:\n   // Parses a MetaItemInner."}, {"sha": "8df1d1adae2571bb12e901799f0a9ef73b8dc95b", "filename": "gcc/rust/expand/rust-macro-expand.cc", "status": "modified", "additions": 52, "deletions": 67, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7cf2f7789dccbb1d8aac6222b2b1c0f4d5f18f6/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7cf2f7789dccbb1d8aac6222b2b1c0f4d5f18f6/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc?ref=e7cf2f7789dccbb1d8aac6222b2b1c0f4d5f18f6", "patch": "@@ -3,83 +3,68 @@\n // is full really required?\n \n namespace Rust {\n-void\n-MacroExpander::expand_invoc (::std::unique_ptr<AST::MacroInvocation> &invoc)\n-{\n-  // if current expansion depth > recursion limit, create an error (maybe fatal\n-  // error) and return\n+    void MacroExpander::expand_invoc(std::unique_ptr<AST::MacroInvocation>& invoc) {\n+        /* if current expansion depth > recursion limit, create an error (maybe fatal\n+         * error) and return */\n \n-  /* switch on type of macro:\n-      - '!' syntax macro (inner switch)\n-\t  - procedural macro - \"A token-based function-like macro\"\n-\t  - 'macro_rules' (by example/pattern-match) macro? or not? \"an\n-     AST-based function-like macro\"\n-\t  - else is unreachable\n-      - attribute syntax macro (inner switch)\n-\t  - procedural macro attribute syntax - \"A token-based attribute macro\"\n-\t  - legacy macro attribute syntax? - \"an AST-based attribute macro\"\n-\t  - non-macro attribute: mark known\n-\t  - else is unreachable\n-      - derive macro (inner switch)\n-\t  - derive or legacy derive - \"token-based\" vs \"AST-based\"\n-\t  - else is unreachable\n-      - derive container macro - unreachable*/\n-}\n+        /* switch on type of macro:\n+            - '!' syntax macro (inner switch)\n+                - procedural macro - \"A token-based function-like macro\"\n+                - 'macro_rules' (by example/pattern-match) macro? or not? \"an\n+           AST-based function-like macro\"\n+                - else is unreachable\n+            - attribute syntax macro (inner switch)\n+                - procedural macro attribute syntax - \"A token-based attribute macro\"\n+                - legacy macro attribute syntax? - \"an AST-based attribute macro\"\n+                - non-macro attribute: mark known\n+                - else is unreachable\n+            - derive macro (inner switch)\n+                - derive or legacy derive - \"token-based\" vs \"AST-based\"\n+                - else is unreachable\n+            - derive container macro - unreachable*/\n+    }\n \n-// Determines whether cfg predicate is true and item with attribute should not\n-// be stripped.\n-bool\n-check_cfg_predicate ()\n-{}\n+    /* Determines whether cfg predicate is true and item with attribute should not\n+     * be stripped. */\n+    bool check_cfg_predicate() {}\n \n-// Determines whether cfg predicate is true and item with attribute should not\n-// be stripped.\n-bool\n-check_cfg (AST::Attribute &attr)\n-{}\n+    /* Determines whether cfg predicate is true and item with attribute should not\n+     * be stripped. */\n+    bool check_cfg(AST::Attribute& attr) {}\n \n-// Expands cfg_attr attributes.\n-void\n-expand_attrs_cfgattr (::std::vector<AST::Attribute> &attrs)\n-{\n-  for (auto it = attrs.begin (); it != attrs.end ();)\n-    {\n-      auto &attr = *it;\n-      if (attr.get_path () == \"cfg_attr\")\n-\t{\n-\t  if (check_cfg (attr))\n-\t    {\n-\t    }\n+    // Expands cfg_attr attributes.\n+    void expand_attrs_cfgattr(std::vector<AST::Attribute>& attrs) {\n+        for (auto it = attrs.begin(); it != attrs.end();) {\n+            auto& attr = *it;\n+            if (attr.get_path() == \"cfg_attr\") {\n+                if (check_cfg(attr)) {\n+                }\n \n-\t  /* do something - if feature (first token in tree) is in fact enabled,\n-\t   * make tokens listed afterwards into attributes. i.e.: for\n-\t   * [cfg_attr(feature = \"wow\", wow1, wow2)], if \"wow\" is true, then add\n-\t   * attributes [wow1] and [wow2] to attribute list. This can also be\n-\t   * recursive, so check for expanded attributes being recursive and\n-\t   * possibly recursively call the expand_attrs? */\n-\t}\n-      else\n-\t{\n-\t  ++it;\n-\t}\n+                /* do something - if feature (first token in tree) is in fact enabled,\n+                 * make tokens listed afterwards into attributes. i.e.: for\n+                 * [cfg_attr(feature = \"wow\", wow1, wow2)], if \"wow\" is true, then add\n+                 * attributes [wow1] and [wow2] to attribute list. This can also be\n+                 * recursive, so check for expanded attributes being recursive and\n+                 * possibly recursively call the expand_attrs? */\n+            } else {\n+                ++it;\n+            }\n+        }\n     }\n-}\n \n-void\n-MacroExpander::expand_crate (AST::Crate &crate)\n-{\n-  // fill macro/decorator map from init list? not sure where init list comes\n-  // from?\n+    void MacroExpander::expand_crate() {\n+        /* fill macro/decorator map from init list? not sure where init list comes\n+         * from? */\n \n-  // expand crate attributes\n-  expand_attrs_cfgattr (crate.inner_attrs);\n+        // expand crate attributes\n+        expand_attrs_cfgattr(crate.inner_attrs);\n \n-  // expand module attributes?\n+        // expand module attributes?\n \n-  // expand module tree recursively\n+        // expand module tree recursively\n \n-  // post-process\n+        // post-process\n \n-  // extract exported macros?\n-}\n+        // extract exported macros?\n+    }\n } // namespace Rust"}, {"sha": "92cb06da421aeeb404dcd89acfd143409e5bb72b", "filename": "gcc/rust/expand/rust-macro-expand.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7cf2f7789dccbb1d8aac6222b2b1c0f4d5f18f6/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7cf2f7789dccbb1d8aac6222b2b1c0f4d5f18f6/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.h?ref=e7cf2f7789dccbb1d8aac6222b2b1c0f4d5f18f6", "patch": "@@ -33,15 +33,15 @@ struct MacroExpander\n   ~MacroExpander () = default;\n \n   // Expands all macros in the crate passed in.\n-  void expand_crate (AST::Crate &crate);\n+  void expand_crate ();\n \n   /* Expands a macro invocation (not macro invocation semi) - possibly make both\n    * have similar duck-typed interface and use templates?*/\n   // should this be public or private?\n-  void expand_invoc (::std::unique_ptr<AST::MacroInvocation> &invoc);\n+  void expand_invoc (std::unique_ptr<AST::MacroInvocation> &invoc);\n \n-  // TODO: make it extend ASTVisitor so that individual items can be accessed\n-  // properly?\n+  /* TODO: make it extend ASTVisitor so that individual items can be accessed\n+   * properly? */\n \n private:\n   AST::Crate &crate;"}, {"sha": "4d54242358c11724f5b80bb50a498f66bf551a15", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 6, "deletions": 20, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7cf2f7789dccbb1d8aac6222b2b1c0f4d5f18f6/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7cf2f7789dccbb1d8aac6222b2b1c0f4d5f18f6/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=e7cf2f7789dccbb1d8aac6222b2b1c0f4d5f18f6", "patch": "@@ -8254,9 +8254,7 @@ Parser<ManagedTokenSource>::parse_match_arm_patterns (TokenId end_token_id)\n \n   // quick break out if end_token_id\n   if (lexer.peek_token ()->get_id () == end_token_id)\n-    {\n-      return patterns;\n-    }\n+    return patterns;\n \n   // parse required pattern - if doesn't exist, return empty\n   std::unique_ptr<AST::Pattern> initial_pattern = parse_pattern ();\n@@ -8279,9 +8277,7 @@ Parser<ManagedTokenSource>::parse_match_arm_patterns (TokenId end_token_id)\n \n       // break if hit end token id\n       if (lexer.peek_token ()->get_id () == end_token_id)\n-\t{\n-\t  break;\n-\t}\n+\tbreak;\n \n       // parse pattern\n       std::unique_ptr<AST::Pattern> pattern = parse_pattern ();\n@@ -8291,7 +8287,7 @@ Parser<ManagedTokenSource>::parse_match_arm_patterns (TokenId end_token_id)\n \t  rust_error_at (lexer.peek_token ()->get_locus (),\n \t\t\t \"failed to parse pattern in match arm patterns\");\n \t  // skip somewhere?\n-\t  return std::vector<std::unique_ptr<AST::Pattern> > ();\n+\t  return {};\n \t}\n \n       patterns.push_back (std::move (pattern));\n@@ -8459,9 +8455,7 @@ Parser<ManagedTokenSource>::parse_array_expr (\n \n \t      // quick break if right square bracket\n \t      if (lexer.peek_token ()->get_id () == RIGHT_SQUARE)\n-\t\t{\n-\t\t  break;\n-\t\t}\n+\t\tbreak;\n \n \t      // parse expression (required)\n \t      std::unique_ptr<AST::Expr> expr = parse_expr ();\n@@ -8604,9 +8598,7 @@ Parser<ManagedTokenSource>::parse_grouped_or_tuple_expr (\n \n \t  // break out if right paren\n \t  if (lexer.peek_token ()->get_id () == RIGHT_PAREN)\n-\t    {\n-\t      break;\n-\t    }\n+\t    break;\n \n \t  // parse expr, which is now required\n \t  std::unique_ptr<AST::Expr> expr = parse_expr ();\n@@ -11848,16 +11840,12 @@ Parser<ManagedTokenSource>::parse_expr (int right_binding_power,\n   return expr;\n }\n \n-/* Parse expression with lowest left binding power. FIXME: this may only apply\n- * to expressions without blocks as they are the only ones to have precedence?\n- */\n+// Parse expression with lowest left binding power.\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::Expr>\n Parser<ManagedTokenSource>::parse_expr (std::vector<AST::Attribute> outer_attrs,\n \t\t\t\t\tParseRestrictions restrictions)\n {\n-  /* HACK: only call parse_expr(LBP_LOWEST) after ensuring it is not an\n-   * expression with block? */\n   return parse_expr (LBP_LOWEST, std::move (outer_attrs), restrictions);\n }\n \n@@ -14273,9 +14261,7 @@ Parser<ManagedTokenSource>::parse_tuple_index_expr_float (\n {\n   // only works on float literals\n   if (tok->get_id () != FLOAT_LITERAL)\n-    {\n       return nullptr;\n-    }\n \n   // DEBUG:\n   fprintf (stderr, \"exact string form of float: '%s'\\n\","}, {"sha": "20c7e347a715e368f6090bef5092351737d8fa13", "filename": "gcc/rust/rust-session-manager.cc", "status": "modified", "additions": 9, "deletions": 34, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7cf2f7789dccbb1d8aac6222b2b1c0f4d5f18f6/gcc%2Frust%2Frust-session-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7cf2f7789dccbb1d8aac6222b2b1c0f4d5f18f6/gcc%2Frust%2Frust-session-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.cc?ref=e7cf2f7789dccbb1d8aac6222b2b1c0f4d5f18f6", "patch": "@@ -14,6 +14,7 @@\n #include \"rust-name-resolution.h\"\n #include \"rust-type-resolution.h\"\n #include \"rust-compile.h\"\n+#include \"rust-macro-expand.h\"\n \n #include \"rust-target.h\"\n \n@@ -507,35 +508,6 @@ Session::parse_file (const char *filename)\n   Compile::Compilation::Compile (parsed_crate, backend);\n }\n \n-// Checks whether 'cfg' attribute prevents compilation.\n-bool\n-check_cfg (const AST::Attribute &attr ATTRIBUTE_UNUSED)\n-{\n-  // if \"has sub items\", and if 'cfg' attr, recursively call this on sub items?\n-\n-  // TODO: actually implement. assume true for now\n-\n-  return true;\n-}\n-// TODO: deprecated - don't use\n-\n-// Checks whether any 'cfg' attribute on the item prevents compilation of that\n-// item.\n-bool\n-check_item_cfg (std::vector<AST::Attribute> attrs)\n-{\n-  for (const auto &attr : attrs)\n-    {\n-      if (attr.get_path () == \"cfg\" && !check_cfg (attr))\n-\t{\n-\t  return false;\n-\t}\n-    }\n-\n-  return true;\n-}\n-// TODO: deprecated - don't use\n-\n // TODO: actually implement method\n void\n load_extern_crate (std::string crate_name ATTRIBUTE_UNUSED)\n@@ -729,19 +701,22 @@ Session::injection (AST::Crate &crate)\n }\n \n void\n-Session::expansion (AST::Crate &crate ATTRIBUTE_UNUSED)\n+Session::expansion (AST::Crate &crate)\n {\n   fprintf (stderr, \"started expansion\\n\");\n \n-  // rustc has a modification to windows PATH temporarily here, which may end up\n-  // being required\n+  /* rustc has a modification to windows PATH temporarily here, which may end up\n+   * being required */\n \n   // create macro expansion config?\n   // if not, would at least have to configure recursion_limit\n+  ExpansionCfg cfg;\n \n   // create extctxt? from parse session, cfg, and resolver?\n-  // expand by calling cxtctxt object's monotonic_expander's expand_crate\n-  // method.\n+  /* expand by calling cxtctxt object's monotonic_expander's expand_crate\n+   * method. */\n+  MacroExpander expander (crate, cfg);\n+  expander.expand_crate ();\n \n   // error reporting - check unused macros, get missing fragment specifiers\n "}]}