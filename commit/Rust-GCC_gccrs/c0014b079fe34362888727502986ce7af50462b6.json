{"sha": "c0014b079fe34362888727502986ce7af50462b6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzAwMTRiMDc5ZmUzNDM2Mjg4ODcyNzUwMjk4NmNlN2FmNTA0NjJiNg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2014-08-07T01:44:40Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2014-08-07T01:44:40Z"}, "message": "init.c (build_vec_init): Fix constant initialization of trailing elements.\n\n\t* init.c (build_vec_init): Fix constant initialization of\n\ttrailing elements.\n\t(build_value_init_noctor): Call maybe_constant_init.\n\t* semantics.c (maybe_constant_init): See through EXPR_STMT and\n\tconversion to void.\n\nFrom-SVN: r213690", "tree": {"sha": "7a2eca9735cdf863cc4b5e88bd27f5763bf4c02f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7a2eca9735cdf863cc4b5e88bd27f5763bf4c02f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c0014b079fe34362888727502986ce7af50462b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0014b079fe34362888727502986ce7af50462b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0014b079fe34362888727502986ce7af50462b6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0014b079fe34362888727502986ce7af50462b6/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ced2fb085c43bef21e863989129c54279b7c8e48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ced2fb085c43bef21e863989129c54279b7c8e48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ced2fb085c43bef21e863989129c54279b7c8e48"}], "stats": {"total": 187, "additions": 134, "deletions": 53}, "files": [{"sha": "3f159a736c8f7a377ca592731eca64345991ab97", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0014b079fe34362888727502986ce7af50462b6/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0014b079fe34362888727502986ce7af50462b6/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=c0014b079fe34362888727502986ce7af50462b6", "patch": "@@ -1,5 +1,11 @@\n 2014-08-06  Jason Merrill  <jason@redhat.com>\n \n+\t* init.c (build_vec_init): Fix constant initialization of\n+\ttrailing elements.\n+\t(build_value_init_noctor): Call maybe_constant_init.\n+\t* semantics.c (maybe_constant_init): See through EXPR_STMT and\n+\tconversion to void.\n+\n \tPR c++/60417\n \t* init.c (build_vec_init): Reorganize earlier change a bit.\n "}, {"sha": "f0ca9b9a396c5faa0924ff050dfa828115e61895", "filename": "gcc/cp/init.c", "status": "modified", "additions": 79, "deletions": 53, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0014b079fe34362888727502986ce7af50462b6/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0014b079fe34362888727502986ce7af50462b6/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=c0014b079fe34362888727502986ce7af50462b6", "patch": "@@ -419,12 +419,18 @@ build_value_init_noctor (tree type, tsubst_flags_t complain)\n \t\t over TYPE_FIELDs will result in correct initialization of\n \t\t all of the subobjects.  */\n \t      value = build_value_init (ftype, complain);\n+\t      value = maybe_constant_init (value);\n \n \t      if (value == error_mark_node)\n \t\treturn error_mark_node;\n \n-\t      if (value)\n-\t\tCONSTRUCTOR_APPEND_ELT(v, field, value);\n+\t      CONSTRUCTOR_APPEND_ELT(v, field, value);\n+\n+\t      /* We shouldn't have gotten here for anything that would need\n+\t\t non-trivial initialization, and gimplify_init_ctor_preeval\n+\t\t would need to be fixed to allow it.  */\n+\t      gcc_assert (TREE_CODE (value) != TARGET_EXPR\n+\t\t\t  && TREE_CODE (value) != AGGR_INIT_EXPR);\n \t    }\n \n \t  /* Build a constructor to contain the zero- initializations.  */\n@@ -462,20 +468,18 @@ build_value_init_noctor (tree type, tsubst_flags_t complain)\n \t    ce.index = build2 (RANGE_EXPR, sizetype, size_zero_node, max_index);\n \n \t  ce.value = build_value_init (TREE_TYPE (type), complain);\n-\t  if (ce.value)\n-\t    {\n-\t      if (ce.value == error_mark_node)\n-\t\treturn error_mark_node;\n+\t  ce.value = maybe_constant_init (ce.value);\n+\t  if (ce.value == error_mark_node)\n+\t    return error_mark_node;\n \n-\t      vec_alloc (v, 1);\n-\t      v->quick_push (ce);\n+\t  vec_alloc (v, 1);\n+\t  v->quick_push (ce);\n \n-\t      /* We shouldn't have gotten here for anything that would need\n-\t\t non-trivial initialization, and gimplify_init_ctor_preeval\n-\t\t would need to be fixed to allow it.  */\n-\t      gcc_assert (TREE_CODE (ce.value) != TARGET_EXPR\n-\t\t\t  && TREE_CODE (ce.value) != AGGR_INIT_EXPR);\n-\t    }\n+\t  /* We shouldn't have gotten here for anything that would need\n+\t     non-trivial initialization, and gimplify_init_ctor_preeval\n+\t     would need to be fixed to allow it.  */\n+\t  gcc_assert (TREE_CODE (ce.value) != TARGET_EXPR\n+\t\t      && TREE_CODE (ce.value) != AGGR_INIT_EXPR);\n \t}\n \n       /* Build a constructor to contain the initializations.  */\n@@ -3412,7 +3416,6 @@ build_vec_init (tree base, tree maxindex, tree init,\n   tree try_block = NULL_TREE;\n   int num_initialized_elts = 0;\n   bool is_global;\n-  tree const_init = NULL_TREE;\n   tree obase = base;\n   bool xvalue = false;\n   bool errors = false;\n@@ -3545,6 +3548,19 @@ build_vec_init (tree base, tree maxindex, tree init,\n       try_block = begin_try_block ();\n     }\n \n+  /* Should we try to create a constant initializer?  */\n+  bool try_const = (TREE_CODE (atype) == ARRAY_TYPE\n+\t\t    && TREE_CONSTANT (maxindex)\n+\t\t    && init && TREE_CODE (init) == CONSTRUCTOR\n+\t\t    && (literal_type_p (inner_elt_type)\n+\t\t\t|| TYPE_HAS_CONSTEXPR_CTOR (inner_elt_type)));\n+  vec<constructor_elt, va_gc> *const_vec = NULL;\n+  bool saw_non_const = false;\n+  /* If we're initializing a static array, we want to do static\n+     initialization of any elements with constant initializers even if\n+     some are non-constant.  */\n+  bool do_static_init = (DECL_P (obase) && TREE_STATIC (obase));\n+\n   bool empty_list = false;\n   if (init && BRACE_ENCLOSED_INITIALIZER_P (init)\n       && CONSTRUCTOR_NELTS (init) == 0)\n@@ -3559,21 +3575,9 @@ build_vec_init (tree base, tree maxindex, tree init,\n \t brace-enclosed initializers.  */\n       unsigned HOST_WIDE_INT idx;\n       tree field, elt;\n-      /* Should we try to create a constant initializer?  */\n-      bool try_const = (TREE_CODE (atype) == ARRAY_TYPE\n-\t\t\t&& TREE_CONSTANT (maxindex)\n-\t\t\t&& (literal_type_p (inner_elt_type)\n-\t\t\t    || TYPE_HAS_CONSTEXPR_CTOR (inner_elt_type)));\n       /* If the constructor already has the array type, it's been through\n \t digest_init, so we shouldn't try to do anything more.  */\n       bool digested = same_type_p (atype, TREE_TYPE (init));\n-      bool saw_non_const = false;\n-      bool saw_const = false;\n-      /* If we're initializing a static array, we want to do static\n-\t initialization of any elements with constant initializers even if\n-\t some are non-constant.  */\n-      bool do_static_init = (DECL_P (obase) && TREE_STATIC (obase));\n-      vec<constructor_elt, va_gc> *new_vec;\n       from_array = 0;\n \n       if (length_check)\n@@ -3589,9 +3593,7 @@ build_vec_init (tree base, tree maxindex, tree init,\n \t}\n \n       if (try_const)\n-\tvec_alloc (new_vec, CONSTRUCTOR_NELTS (init));\n-      else\n-\tnew_vec = NULL;\n+\tvec_alloc (const_vec, CONSTRUCTOR_NELTS (init));\n \n       FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (init), idx, field, elt)\n \t{\n@@ -3612,21 +3614,14 @@ build_vec_init (tree base, tree maxindex, tree init,\n \t    errors = true;\n \t  if (try_const)\n \t    {\n-\t      tree e = one_init;\n-\t      if (TREE_CODE (e) == EXPR_STMT)\n-\t\te = TREE_OPERAND (e, 0);\n-\t      if (TREE_CODE (e) == CONVERT_EXPR\n-\t\t  && VOID_TYPE_P (TREE_TYPE (e)))\n-\t\te = TREE_OPERAND (e, 0);\n-\t      e = maybe_constant_init (e);\n+\t      tree e = maybe_constant_init (one_init);\n \t      if (reduced_constant_expression_p (e))\n \t\t{\n-\t\t  CONSTRUCTOR_APPEND_ELT (new_vec, field, e);\n+\t\t  CONSTRUCTOR_APPEND_ELT (const_vec, field, e);\n \t\t  if (do_static_init)\n \t\t    one_init = NULL_TREE;\n \t\t  else\n \t\t    one_init = build2 (INIT_EXPR, type, baseref, e);\n-\t\t  saw_const = true;\n \t\t}\n \t      else\n \t\t{\n@@ -3635,7 +3630,7 @@ build_vec_init (tree base, tree maxindex, tree init,\n \t\t      tree value = build_zero_init (TREE_TYPE (e), NULL_TREE,\n \t\t\t\t\t\t    true);\n \t\t      if (value)\n-\t\t\tCONSTRUCTOR_APPEND_ELT (new_vec, field, value);\n+\t\t\tCONSTRUCTOR_APPEND_ELT (const_vec, field, value);\n \t\t    }\n \t\t  saw_non_const = true;\n \t\t}\n@@ -3659,16 +3654,6 @@ build_vec_init (tree base, tree maxindex, tree init,\n \t    finish_expr_stmt (one_init);\n \t}\n \n-      if (try_const)\n-\t{\n-\t  if (!saw_non_const)\n-\t    const_init = build_constructor (atype, new_vec);\n-\t  else if (do_static_init && saw_const)\n-\t    DECL_INITIAL (obase) = build_constructor (atype, new_vec);\n-\t  else\n-\t    vec_free (new_vec);\n-\t}\n-\n       /* Any elements without explicit initializers get T{}.  */\n       empty_list = true;\n     }\n@@ -3793,8 +3778,38 @@ build_vec_init (tree base, tree maxindex, tree init,\n       if (elt_init == error_mark_node)\n \terrors = true;\n \n+      if (try_const)\n+\t{\n+\t  tree e = maybe_constant_init (elt_init);\n+\t  if (reduced_constant_expression_p (e))\n+\t    {\n+\t      if (initializer_zerop (e))\n+\t\t/* Don't fill the CONSTRUCTOR with zeros.  */\n+\t\te = NULL_TREE;\n+\t      if (do_static_init)\n+\t\telt_init = NULL_TREE;\n+\t    }\n+\t  else\n+\t    {\n+\t      saw_non_const = true;\n+\t      if (do_static_init)\n+\t\te = build_zero_init (TREE_TYPE (e), NULL_TREE, true);\n+\t    }\n+\n+\t  if (e)\n+\t    {\n+\t      int max = tree_to_shwi (maxindex)+1;\n+\t      for (; num_initialized_elts < max; ++num_initialized_elts)\n+\t\t{\n+\t\t  tree field = size_int (num_initialized_elts);\n+\t\t  CONSTRUCTOR_APPEND_ELT (const_vec, field, e);\n+\t\t}\n+\t    }\n+\t}\n+\n       current_stmt_tree ()->stmts_are_full_exprs_p = 1;\n-      finish_expr_stmt (elt_init);\n+      if (elt_init)\n+\tfinish_expr_stmt (elt_init);\n       current_stmt_tree ()->stmts_are_full_exprs_p = 0;\n \n       finish_expr_stmt (cp_build_unary_op (PREINCREMENT_EXPR, base, 0,\n@@ -3844,8 +3859,19 @@ build_vec_init (tree base, tree maxindex, tree init,\n \n   if (errors)\n     return error_mark_node;\n-  if (const_init)\n-    return build2 (INIT_EXPR, atype, obase, const_init);\n+\n+  if (try_const)\n+    {\n+      if (!saw_non_const)\n+\t{\n+\t  tree const_init = build_constructor (atype, const_vec);\n+\t  return build2 (INIT_EXPR, atype, obase, const_init);\n+\t}\n+      else if (do_static_init && !vec_safe_is_empty (const_vec))\n+\tDECL_INITIAL (obase) = build_constructor (atype, const_vec);\n+      else\n+\tvec_free (const_vec);\n+    }\n \n   /* Now make the result have the correct type.  */\n   if (TREE_CODE (atype) == ARRAY_TYPE)"}, {"sha": "536ea5c396454ecb389ad16d95fba7f0c68668ad", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0014b079fe34362888727502986ce7af50462b6/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0014b079fe34362888727502986ce7af50462b6/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=c0014b079fe34362888727502986ce7af50462b6", "patch": "@@ -9976,6 +9976,11 @@ maybe_constant_value (tree t)\n tree\n maybe_constant_init (tree t)\n {\n+  if (TREE_CODE (t) == EXPR_STMT)\n+    t = TREE_OPERAND (t, 0);\n+  if (TREE_CODE (t) == CONVERT_EXPR\n+      && VOID_TYPE_P (TREE_TYPE (t)))\n+    t = TREE_OPERAND (t, 0);\n   t = maybe_constant_value (t);\n   if (TREE_CODE (t) == TARGET_EXPR)\n     {"}, {"sha": "f4aae4f58d9f09260870a049a2ef56ef0bb0574b", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-array8.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0014b079fe34362888727502986ce7af50462b6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-array8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0014b079fe34362888727502986ce7af50462b6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-array8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-array8.C?ref=c0014b079fe34362888727502986ce7af50462b6", "patch": "@@ -0,0 +1,22 @@\n+// { dg-do run { target c++11 } }\n+\n+struct A { int i,j; };\n+\n+struct X {\n+  A a = {1,1};\n+};\n+\n+constexpr X table[2][2] = {{ {} }};\n+\n+#define SA(X) static_assert(X,#X)\n+SA(table[1][1].a.i == 1);\n+\n+extern \"C\" void abort();\n+\n+const int *p = &table[1][1].a.j;\n+\n+int main()\n+{\n+  if (*p != 1)\n+    abort();\n+}"}, {"sha": "20ec2559b1dabb33567000554ccb19d9a09a5c0c", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-array9.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0014b079fe34362888727502986ce7af50462b6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-array9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0014b079fe34362888727502986ce7af50462b6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-array9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-array9.C?ref=c0014b079fe34362888727502986ce7af50462b6", "patch": "@@ -0,0 +1,22 @@\n+// { dg-do run { target c++11 } }\n+\n+struct A { int i,j; };\n+\n+struct X {\n+  A a = {0,0};\n+};\n+\n+constexpr X table[2][2] = {{ {} }};\n+\n+#define SA(X) static_assert(X,#X)\n+SA(table[1][1].a.i == 0);\n+\n+extern \"C\" void abort();\n+\n+const int *p = &table[1][1].a.j;\n+\n+int main()\n+{\n+  if (*p != 0)\n+    abort();\n+}"}]}