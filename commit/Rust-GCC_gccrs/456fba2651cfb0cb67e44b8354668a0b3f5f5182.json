{"sha": "456fba2651cfb0cb67e44b8354668a0b3f5f5182", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDU2ZmJhMjY1MWNmYjBjYjY3ZTQ0YjgzNTQ2NjhhMGIzZjVmNTE4Mg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-03-30T21:27:11Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-03-30T21:27:11Z"}, "message": "libgo: Update to weekly.2012-03-13.\n\nFrom-SVN: r186023", "tree": {"sha": "9a0dfa827abe382ac0f44768e5365b87f00ac0a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9a0dfa827abe382ac0f44768e5365b87f00ac0a9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/456fba2651cfb0cb67e44b8354668a0b3f5f5182", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/456fba2651cfb0cb67e44b8354668a0b3f5f5182", "html_url": "https://github.com/Rust-GCC/gccrs/commit/456fba2651cfb0cb67e44b8354668a0b3f5f5182", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/456fba2651cfb0cb67e44b8354668a0b3f5f5182/comments", "author": null, "committer": null, "parents": [{"sha": "e0be8a5c203451b47fd3da59b0e0f56cc3d42f22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0be8a5c203451b47fd3da59b0e0f56cc3d42f22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0be8a5c203451b47fd3da59b0e0f56cc3d42f22"}], "stats": {"total": 6486, "additions": 4853, "deletions": 1633}, "files": [{"sha": "13b0438ece689fa679f479a5b97ca53a9f2697cd", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -1,4 +1,4 @@\n-f4470a54e6db\n+3cdba7b0650c\n \n The first line of this file holds the Mercurial revision number of the\n last merge done from the master library sources."}, {"sha": "14f72ecdc7d4be40e1d4b5e47eec8618411a44b7", "filename": "libgo/Makefile.am", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -813,6 +813,7 @@ go_net_rpc_files = \\\n \tgo/net/rpc/server.go\n \n go_runtime_files = \\\n+\tgo/runtime/compiler.go \\\n \tgo/runtime/debug.go \\\n \tgo/runtime/error.go \\\n \tgo/runtime/extern.go \\\n@@ -843,6 +844,7 @@ go_strconv_files = \\\n \tgo/strconv/decimal.go \\\n \tgo/strconv/extfloat.go \\\n \tgo/strconv/ftoa.go \\\n+\tgo/strconv/isprint.go \\\n \tgo/strconv/itoa.go \\\n \tgo/strconv/quote.go\n \n@@ -1000,12 +1002,13 @@ go_crypto_tls_files = \\\n \tgo/crypto/tls/handshake_server.go \\\n \tgo/crypto/tls/key_agreement.go \\\n \tgo/crypto/tls/prf.go \\\n-\tgo/crypto/tls/root_unix.go \\\n \tgo/crypto/tls/tls.go\n go_crypto_x509_files = \\\n \tgo/crypto/x509/cert_pool.go \\\n \tgo/crypto/x509/pkcs1.go \\\n \tgo/crypto/x509/pkcs8.go \\\n+\tgo/crypto/x509/root.go \\\n+\tgo/crypto/x509/root_unix.go \\\n \tgo/crypto/x509/verify.go \\\n \tgo/crypto/x509/x509.go\n \n@@ -1320,7 +1323,8 @@ go_os_user_files = \\\n go_path_filepath_files = \\\n \tgo/path/filepath/match.go \\\n \tgo/path/filepath/path.go \\\n-\tgo/path/filepath/path_unix.go\n+\tgo/path/filepath/path_unix.go \\\n+\tgo/path/filepath/symlink.go\n \n go_regexp_syntax_files = \\\n \tgo/regexp/syntax/compile.go \\"}, {"sha": "720d57e04f01c491e48359494e18749a1c26d980", "filename": "libgo/Makefile.in", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -1131,6 +1131,7 @@ go_net_rpc_files = \\\n \tgo/net/rpc/server.go\n \n go_runtime_files = \\\n+\tgo/runtime/compiler.go \\\n \tgo/runtime/debug.go \\\n \tgo/runtime/error.go \\\n \tgo/runtime/extern.go \\\n@@ -1150,6 +1151,7 @@ go_strconv_files = \\\n \tgo/strconv/decimal.go \\\n \tgo/strconv/extfloat.go \\\n \tgo/strconv/ftoa.go \\\n+\tgo/strconv/isprint.go \\\n \tgo/strconv/itoa.go \\\n \tgo/strconv/quote.go\n \n@@ -1315,13 +1317,14 @@ go_crypto_tls_files = \\\n \tgo/crypto/tls/handshake_server.go \\\n \tgo/crypto/tls/key_agreement.go \\\n \tgo/crypto/tls/prf.go \\\n-\tgo/crypto/tls/root_unix.go \\\n \tgo/crypto/tls/tls.go\n \n go_crypto_x509_files = \\\n \tgo/crypto/x509/cert_pool.go \\\n \tgo/crypto/x509/pkcs1.go \\\n \tgo/crypto/x509/pkcs8.go \\\n+\tgo/crypto/x509/root.go \\\n+\tgo/crypto/x509/root_unix.go \\\n \tgo/crypto/x509/verify.go \\\n \tgo/crypto/x509/x509.go\n \n@@ -1677,7 +1680,8 @@ go_os_user_files = \\\n go_path_filepath_files = \\\n \tgo/path/filepath/match.go \\\n \tgo/path/filepath/path.go \\\n-\tgo/path/filepath/path_unix.go\n+\tgo/path/filepath/path_unix.go \\\n+\tgo/path/filepath/symlink.go\n \n go_regexp_syntax_files = \\\n \tgo/regexp/syntax/compile.go \\"}, {"sha": "1b40af812ae627a267b9331bda7e7a00970ae21c", "filename": "libgo/go/archive/tar/reader.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Farchive%2Ftar%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Farchive%2Ftar%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Freader.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -18,7 +18,7 @@ import (\n )\n \n var (\n-\tErrHeader = errors.New(\"invalid tar header\")\n+\tErrHeader = errors.New(\"archive/tar: invalid tar header\")\n )\n \n // A Reader provides sequential access to the contents of a tar archive."}, {"sha": "b2b7a58a10a7e22250af5074308d7dd3d98b1b36", "filename": "libgo/go/archive/tar/writer.go", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Farchive%2Ftar%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Farchive%2Ftar%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fwriter.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -5,18 +5,19 @@\n package tar\n \n // TODO(dsymonds):\n-// - catch more errors (no first header, write after close, etc.)\n+// - catch more errors (no first header, etc.)\n \n import (\n \t\"errors\"\n+\t\"fmt\"\n \t\"io\"\n \t\"strconv\"\n )\n \n var (\n-\tErrWriteTooLong    = errors.New(\"write too long\")\n-\tErrFieldTooLong    = errors.New(\"header field too long\")\n-\tErrWriteAfterClose = errors.New(\"write after close\")\n+\tErrWriteTooLong    = errors.New(\"archive/tar: write too long\")\n+\tErrFieldTooLong    = errors.New(\"archive/tar: header field too long\")\n+\tErrWriteAfterClose = errors.New(\"archive/tar: write after close\")\n )\n \n // A Writer provides sequential writing of a tar archive in POSIX.1 format.\n@@ -48,6 +49,11 @@ func NewWriter(w io.Writer) *Writer { return &Writer{w: w} }\n \n // Flush finishes writing the current file (optional).\n func (tw *Writer) Flush() error {\n+\tif tw.nb > 0 {\n+\t\ttw.err = fmt.Errorf(\"archive/tar: missed writing %d bytes\", tw.nb)\n+\t\treturn tw.err\n+\t}\n+\n \tn := tw.nb + tw.pad\n \tfor n > 0 && tw.err == nil {\n \t\tnr := n\n@@ -193,6 +199,9 @@ func (tw *Writer) Close() error {\n \t}\n \ttw.Flush()\n \ttw.closed = true\n+\tif tw.err != nil {\n+\t\treturn tw.err\n+\t}\n \n \t// trailer: two zero blocks\n \tfor i := 0; i < 2; i++ {"}, {"sha": "a214e57b9fc46dc48870822c0d096b883690c072", "filename": "libgo/go/archive/tar/writer_test.go", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Farchive%2Ftar%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Farchive%2Ftar%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fwriter_test.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -9,6 +9,7 @@ import (\n \t\"fmt\"\n \t\"io\"\n \t\"io/ioutil\"\n+\t\"strings\"\n \t\"testing\"\n \t\"testing/iotest\"\n \t\"time\"\n@@ -95,7 +96,8 @@ var writerTests = []*writerTest{\n \t\t\t\t\tUname:    \"dsymonds\",\n \t\t\t\t\tGname:    \"eng\",\n \t\t\t\t},\n-\t\t\t\t// no contents\n+\t\t\t\t// fake contents\n+\t\t\t\tcontents: strings.Repeat(\"\\x00\", 4<<10),\n \t\t\t},\n \t\t},\n \t},\n@@ -150,7 +152,9 @@ testLoop:\n \n \t\tbuf := new(bytes.Buffer)\n \t\ttw := NewWriter(iotest.TruncateWriter(buf, 4<<10)) // only catch the first 4 KB\n+\t\tbig := false\n \t\tfor j, entry := range test.entries {\n+\t\t\tbig = big || entry.header.Size > 1<<10\n \t\t\tif err := tw.WriteHeader(entry.header); err != nil {\n \t\t\t\tt.Errorf(\"test %d, entry %d: Failed writing header: %v\", i, j, err)\n \t\t\t\tcontinue testLoop\n@@ -160,7 +164,8 @@ testLoop:\n \t\t\t\tcontinue testLoop\n \t\t\t}\n \t\t}\n-\t\tif err := tw.Close(); err != nil {\n+\t\t// Only interested in Close failures for the small tests.\n+\t\tif err := tw.Close(); err != nil && !big {\n \t\t\tt.Errorf(\"test %d: Failed closing archive: %v\", i, err)\n \t\t\tcontinue testLoop\n \t\t}"}, {"sha": "ddd507538b39944d6f04232deb7c04c4ffcf5f1b", "filename": "libgo/go/archive/zip/reader.go", "status": "modified", "additions": 49, "deletions": 16, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Farchive%2Fzip%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Farchive%2Fzip%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Freader.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -124,10 +124,6 @@ func (f *File) Open() (rc io.ReadCloser, err error) {\n \t\treturn\n \t}\n \tsize := int64(f.CompressedSize)\n-\tif size == 0 && f.hasDataDescriptor() {\n-\t\t// permit SectionReader to see the rest of the file\n-\t\tsize = f.zipsize - (f.headerOffset + bodyOffset)\n-\t}\n \tr := io.NewSectionReader(f.zipr, f.headerOffset+bodyOffset, size)\n \tswitch f.Method {\n \tcase Store: // (no compression)\n@@ -136,34 +132,50 @@ func (f *File) Open() (rc io.ReadCloser, err error) {\n \t\trc = flate.NewReader(r)\n \tdefault:\n \t\terr = ErrAlgorithm\n+\t\treturn\n \t}\n-\tif rc != nil {\n-\t\trc = &checksumReader{rc, crc32.NewIEEE(), f, r}\n+\tvar desr io.Reader\n+\tif f.hasDataDescriptor() {\n+\t\tdesr = io.NewSectionReader(f.zipr, f.headerOffset+bodyOffset+size, dataDescriptorLen)\n \t}\n+\trc = &checksumReader{rc, crc32.NewIEEE(), f, desr, nil}\n \treturn\n }\n \n type checksumReader struct {\n \trc   io.ReadCloser\n \thash hash.Hash32\n \tf    *File\n-\tzipr io.Reader // for reading the data descriptor\n+\tdesr io.Reader // if non-nil, where to read the data descriptor\n+\terr  error     // sticky error\n }\n \n func (r *checksumReader) Read(b []byte) (n int, err error) {\n+\tif r.err != nil {\n+\t\treturn 0, r.err\n+\t}\n \tn, err = r.rc.Read(b)\n \tr.hash.Write(b[:n])\n-\tif err != io.EOF {\n+\tif err == nil {\n \t\treturn\n \t}\n-\tif r.f.hasDataDescriptor() {\n-\t\tif err = readDataDescriptor(r.zipr, r.f); err != nil {\n-\t\t\treturn\n+\tif err == io.EOF {\n+\t\tif r.desr != nil {\n+\t\t\tif err1 := readDataDescriptor(r.desr, r.f); err1 != nil {\n+\t\t\t\terr = err1\n+\t\t\t} else if r.hash.Sum32() != r.f.CRC32 {\n+\t\t\t\terr = ErrChecksum\n+\t\t\t}\n+\t\t} else {\n+\t\t\t// If there's not a data descriptor, we still compare\n+\t\t\t// the CRC32 of what we've read against the file header\n+\t\t\t// or TOC's CRC32, if it seems like it was set.\n+\t\t\tif r.f.CRC32 != 0 && r.hash.Sum32() != r.f.CRC32 {\n+\t\t\t\terr = ErrChecksum\n+\t\t\t}\n \t\t}\n \t}\n-\tif r.hash.Sum32() != r.f.CRC32 {\n-\t\terr = ErrChecksum\n-\t}\n+\tr.err = err\n \treturn\n }\n \n@@ -226,10 +238,31 @@ func readDirectoryHeader(f *File, r io.Reader) error {\n \n func readDataDescriptor(r io.Reader, f *File) error {\n \tvar buf [dataDescriptorLen]byte\n-\tif _, err := io.ReadFull(r, buf[:]); err != nil {\n+\n+\t// The spec says: \"Although not originally assigned a\n+\t// signature, the value 0x08074b50 has commonly been adopted\n+\t// as a signature value for the data descriptor record.\n+\t// Implementers should be aware that ZIP files may be\n+\t// encountered with or without this signature marking data\n+\t// descriptors and should account for either case when reading\n+\t// ZIP files to ensure compatibility.\"\n+\t//\n+\t// dataDescriptorLen includes the size of the signature but\n+\t// first read just those 4 bytes to see if it exists.\n+\tif _, err := io.ReadFull(r, buf[:4]); err != nil {\n \t\treturn err\n \t}\n-\tb := readBuf(buf[:])\n+\toff := 0\n+\tmaybeSig := readBuf(buf[:4])\n+\tif maybeSig.uint32() != dataDescriptorSignature {\n+\t\t// No data descriptor signature. Keep these four\n+\t\t// bytes.\n+\t\toff += 4\n+\t}\n+\tif _, err := io.ReadFull(r, buf[off:12]); err != nil {\n+\t\treturn err\n+\t}\n+\tb := readBuf(buf[:12])\n \tf.CRC32 = b.uint32()\n \tf.CompressedSize = b.uint32()\n \tf.UncompressedSize = b.uint32()"}, {"sha": "c2db0dc4a7c65ee5586ae920bba979cdd852d3cb", "filename": "libgo/go/archive/zip/reader_test.go", "status": "modified", "additions": 157, "deletions": 36, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -10,23 +10,26 @@ import (\n \t\"io\"\n \t\"io/ioutil\"\n \t\"os\"\n+\t\"path/filepath\"\n \t\"testing\"\n \t\"time\"\n )\n \n type ZipTest struct {\n \tName    string\n+\tSource  func() (r io.ReaderAt, size int64) // if non-nil, used instead of testdata/<Name> file\n \tComment string\n \tFile    []ZipTestFile\n \tError   error // the error that Opening this file should return\n }\n \n type ZipTestFile struct {\n-\tName    string\n-\tContent []byte // if blank, will attempt to compare against File\n-\tFile    string // name of file to compare to (relative to testdata/)\n-\tMtime   string // modified time in format \"mm-dd-yy hh:mm:ss\"\n-\tMode    os.FileMode\n+\tName       string\n+\tContent    []byte // if blank, will attempt to compare against File\n+\tContentErr error\n+\tFile       string // name of file to compare to (relative to testdata/)\n+\tMtime      string // modified time in format \"mm-dd-yy hh:mm:ss\"\n+\tMode       os.FileMode\n }\n \n // Caution: The Mtime values found for the test files should correspond to\n@@ -107,6 +110,99 @@ var tests = []ZipTest{\n \t\tName: \"unix.zip\",\n \t\tFile: crossPlatform,\n \t},\n+\t{\n+\t\t// created by Go, before we wrote the \"optional\" data\n+\t\t// descriptor signatures (which are required by OS X)\n+\t\tName: \"go-no-datadesc-sig.zip\",\n+\t\tFile: []ZipTestFile{\n+\t\t\t{\n+\t\t\t\tName:    \"foo.txt\",\n+\t\t\t\tContent: []byte(\"foo\\n\"),\n+\t\t\t\tMtime:   \"03-08-12 16:59:10\",\n+\t\t\t\tMode:    0644,\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tName:    \"bar.txt\",\n+\t\t\t\tContent: []byte(\"bar\\n\"),\n+\t\t\t\tMtime:   \"03-08-12 16:59:12\",\n+\t\t\t\tMode:    0644,\n+\t\t\t},\n+\t\t},\n+\t},\n+\t{\n+\t\t// created by Go, after we wrote the \"optional\" data\n+\t\t// descriptor signatures (which are required by OS X)\n+\t\tName: \"go-with-datadesc-sig.zip\",\n+\t\tFile: []ZipTestFile{\n+\t\t\t{\n+\t\t\t\tName:    \"foo.txt\",\n+\t\t\t\tContent: []byte(\"foo\\n\"),\n+\t\t\t\tMode:    0666,\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tName:    \"bar.txt\",\n+\t\t\t\tContent: []byte(\"bar\\n\"),\n+\t\t\t\tMode:    0666,\n+\t\t\t},\n+\t\t},\n+\t},\n+\t{\n+\t\tName:   \"Bad-CRC32-in-data-descriptor\",\n+\t\tSource: returnCorruptCRC32Zip,\n+\t\tFile: []ZipTestFile{\n+\t\t\t{\n+\t\t\t\tName:       \"foo.txt\",\n+\t\t\t\tContent:    []byte(\"foo\\n\"),\n+\t\t\t\tMode:       0666,\n+\t\t\t\tContentErr: ErrChecksum,\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tName:    \"bar.txt\",\n+\t\t\t\tContent: []byte(\"bar\\n\"),\n+\t\t\t\tMode:    0666,\n+\t\t\t},\n+\t\t},\n+\t},\n+\t// Tests that we verify (and accept valid) crc32s on files\n+\t// with crc32s in their file header (not in data descriptors)\n+\t{\n+\t\tName: \"crc32-not-streamed.zip\",\n+\t\tFile: []ZipTestFile{\n+\t\t\t{\n+\t\t\t\tName:    \"foo.txt\",\n+\t\t\t\tContent: []byte(\"foo\\n\"),\n+\t\t\t\tMtime:   \"03-08-12 16:59:10\",\n+\t\t\t\tMode:    0644,\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tName:    \"bar.txt\",\n+\t\t\t\tContent: []byte(\"bar\\n\"),\n+\t\t\t\tMtime:   \"03-08-12 16:59:12\",\n+\t\t\t\tMode:    0644,\n+\t\t\t},\n+\t\t},\n+\t},\n+\t// Tests that we verify (and reject invalid) crc32s on files\n+\t// with crc32s in their file header (not in data descriptors)\n+\t{\n+\t\tName:   \"crc32-not-streamed.zip\",\n+\t\tSource: returnCorruptNotStreamedZip,\n+\t\tFile: []ZipTestFile{\n+\t\t\t{\n+\t\t\t\tName:       \"foo.txt\",\n+\t\t\t\tContent:    []byte(\"foo\\n\"),\n+\t\t\t\tMtime:      \"03-08-12 16:59:10\",\n+\t\t\t\tMode:       0644,\n+\t\t\t\tContentErr: ErrChecksum,\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tName:    \"bar.txt\",\n+\t\t\t\tContent: []byte(\"bar\\n\"),\n+\t\t\t\tMtime:   \"03-08-12 16:59:12\",\n+\t\t\t\tMode:    0644,\n+\t\t\t},\n+\t\t},\n+\t},\n }\n \n var crossPlatform = []ZipTestFile{\n@@ -139,7 +235,18 @@ func TestReader(t *testing.T) {\n }\n \n func readTestZip(t *testing.T, zt ZipTest) {\n-\tz, err := OpenReader(\"testdata/\" + zt.Name)\n+\tvar z *Reader\n+\tvar err error\n+\tif zt.Source != nil {\n+\t\trat, size := zt.Source()\n+\t\tz, err = NewReader(rat, size)\n+\t} else {\n+\t\tvar rc *ReadCloser\n+\t\trc, err = OpenReader(filepath.Join(\"testdata\", zt.Name))\n+\t\tif err == nil {\n+\t\t\tz = &rc.Reader\n+\t\t}\n+\t}\n \tif err != zt.Error {\n \t\tt.Errorf(\"error=%v, want %v\", err, zt.Error)\n \t\treturn\n@@ -149,11 +256,6 @@ func readTestZip(t *testing.T, zt ZipTest) {\n \tif err == ErrFormat {\n \t\treturn\n \t}\n-\tdefer func() {\n-\t\tif err := z.Close(); err != nil {\n-\t\t\tt.Errorf(\"error %q when closing zip file\", err)\n-\t\t}\n-\t}()\n \n \t// bail here if no Files expected to be tested\n \t// (there may actually be files in the zip, but we don't care)\n@@ -170,7 +272,7 @@ func readTestZip(t *testing.T, zt ZipTest) {\n \n \t// test read of each file\n \tfor i, ft := range zt.File {\n-\t\treadTestFile(t, ft, z.File[i])\n+\t\treadTestFile(t, zt, ft, z.File[i])\n \t}\n \n \t// test simultaneous reads\n@@ -179,7 +281,7 @@ func readTestZip(t *testing.T, zt ZipTest) {\n \tfor i := 0; i < 5; i++ {\n \t\tfor j, ft := range zt.File {\n \t\t\tgo func(j int, ft ZipTestFile) {\n-\t\t\t\treadTestFile(t, ft, z.File[j])\n+\t\t\t\treadTestFile(t, zt, ft, z.File[j])\n \t\t\t\tdone <- true\n \t\t\t}(j, ft)\n \t\t\tn++\n@@ -188,26 +290,11 @@ func readTestZip(t *testing.T, zt ZipTest) {\n \tfor ; n > 0; n-- {\n \t\t<-done\n \t}\n-\n-\t// test invalid checksum\n-\tif !z.File[0].hasDataDescriptor() { // skip test when crc32 in dd\n-\t\tz.File[0].CRC32++ // invalidate\n-\t\tr, err := z.File[0].Open()\n-\t\tif err != nil {\n-\t\t\tt.Error(err)\n-\t\t\treturn\n-\t\t}\n-\t\tvar b bytes.Buffer\n-\t\t_, err = io.Copy(&b, r)\n-\t\tif err != ErrChecksum {\n-\t\t\tt.Errorf(\"%s: copy error=%v, want %v\", z.File[0].Name, err, ErrChecksum)\n-\t\t}\n-\t}\n }\n \n-func readTestFile(t *testing.T, ft ZipTestFile, f *File) {\n+func readTestFile(t *testing.T, zt ZipTest, ft ZipTestFile, f *File) {\n \tif f.Name != ft.Name {\n-\t\tt.Errorf(\"name=%q, want %q\", f.Name, ft.Name)\n+\t\tt.Errorf(\"%s: name=%q, want %q\", zt.Name, f.Name, ft.Name)\n \t}\n \n \tif ft.Mtime != \"\" {\n@@ -217,11 +304,11 @@ func readTestFile(t *testing.T, ft ZipTestFile, f *File) {\n \t\t\treturn\n \t\t}\n \t\tif ft := f.ModTime(); !ft.Equal(mtime) {\n-\t\t\tt.Errorf(\"%s: mtime=%s, want %s\", f.Name, ft, mtime)\n+\t\t\tt.Errorf(\"%s: %s: mtime=%s, want %s\", zt.Name, f.Name, ft, mtime)\n \t\t}\n \t}\n \n-\ttestFileMode(t, f, ft.Mode)\n+\ttestFileMode(t, zt.Name, f, ft.Mode)\n \n \tsize0 := f.UncompressedSize\n \n@@ -237,8 +324,10 @@ func readTestFile(t *testing.T, ft ZipTestFile, f *File) {\n \t}\n \n \t_, err = io.Copy(&b, r)\n+\tif err != ft.ContentErr {\n+\t\tt.Errorf(\"%s: copying contents: %v (want %v)\", zt.Name, err, ft.ContentErr)\n+\t}\n \tif err != nil {\n-\t\tt.Error(err)\n \t\treturn\n \t}\n \tr.Close()\n@@ -264,12 +353,12 @@ func readTestFile(t *testing.T, ft ZipTestFile, f *File) {\n \t}\n }\n \n-func testFileMode(t *testing.T, f *File, want os.FileMode) {\n+func testFileMode(t *testing.T, zipName string, f *File, want os.FileMode) {\n \tmode := f.Mode()\n \tif want == 0 {\n-\t\tt.Errorf(\"%s mode: got %v, want none\", f.Name, mode)\n+\t\tt.Errorf(\"%s: %s mode: got %v, want none\", zipName, f.Name, mode)\n \t} else if mode != want {\n-\t\tt.Errorf(\"%s mode: want %v, got %v\", f.Name, want, mode)\n+\t\tt.Errorf(\"%s: %s mode: want %v, got %v\", zipName, f.Name, want, mode)\n \t}\n }\n \n@@ -294,3 +383,35 @@ func TestInvalidFiles(t *testing.T) {\n \t\tt.Errorf(\"sigs: error=%v, want %v\", err, ErrFormat)\n \t}\n }\n+\n+func messWith(fileName string, corrupter func(b []byte)) (r io.ReaderAt, size int64) {\n+\tdata, err := ioutil.ReadFile(filepath.Join(\"testdata\", fileName))\n+\tif err != nil {\n+\t\tpanic(\"Error reading \" + fileName + \": \" + err.Error())\n+\t}\n+\tcorrupter(data)\n+\treturn bytes.NewReader(data), int64(len(data))\n+}\n+\n+func returnCorruptCRC32Zip() (r io.ReaderAt, size int64) {\n+\treturn messWith(\"go-with-datadesc-sig.zip\", func(b []byte) {\n+\t\t// Corrupt one of the CRC32s in the data descriptor:\n+\t\tb[0x2d]++\n+\t})\n+}\n+\n+func returnCorruptNotStreamedZip() (r io.ReaderAt, size int64) {\n+\treturn messWith(\"crc32-not-streamed.zip\", func(b []byte) {\n+\t\t// Corrupt foo.txt's final crc32 byte, in both\n+\t\t// the file header and TOC. (0x7e -> 0x7f)\n+\t\tb[0x11]++\n+\t\tb[0x9d]++\n+\n+\t\t// TODO(bradfitz): add a new test that only corrupts\n+\t\t// one of these values, and verify that that's also an\n+\t\t// error. Currently, the reader code doesn't verify the\n+\t\t// fileheader and TOC's crc32 match if they're both\n+\t\t// non-zero and only the second line above, the TOC,\n+\t\t// is what matters.\n+\t})\n+}"}, {"sha": "55f3dcfb82e85ea7f22ef422f0042f568e66753e", "filename": "libgo/go/archive/zip/struct.go", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -27,10 +27,11 @@ const (\n \tfileHeaderSignature      = 0x04034b50\n \tdirectoryHeaderSignature = 0x02014b50\n \tdirectoryEndSignature    = 0x06054b50\n-\tfileHeaderLen            = 30 // + filename + extra\n-\tdirectoryHeaderLen       = 46 // + filename + extra + comment\n-\tdirectoryEndLen          = 22 // + comment\n-\tdataDescriptorLen        = 12\n+\tdataDescriptorSignature  = 0x08074b50 // de-facto standard; required by OS X Finder\n+\tfileHeaderLen            = 30         // + filename + extra\n+\tdirectoryHeaderLen       = 46         // + filename + extra + comment\n+\tdirectoryEndLen          = 22         // + comment\n+\tdataDescriptorLen        = 16         // four uint32: descriptor signature, crc32, compressed size, size\n \n \t// Constants for the first byte in CreatorVersion\n \tcreatorFAT    = 0"}, {"sha": "f268d88732f837723525285c0922231d9c3fcb46", "filename": "libgo/go/archive/zip/testdata/crc32-not-streamed.zip", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Farchive%2Fzip%2Ftestdata%2Fcrc32-not-streamed.zip", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Farchive%2Fzip%2Ftestdata%2Fcrc32-not-streamed.zip", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Ftestdata%2Fcrc32-not-streamed.zip?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182"}, {"sha": "c3d593f44f988ab96b59549096903a5c7f7a10d2", "filename": "libgo/go/archive/zip/testdata/go-no-datadesc-sig.zip", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Farchive%2Fzip%2Ftestdata%2Fgo-no-datadesc-sig.zip", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Farchive%2Fzip%2Ftestdata%2Fgo-no-datadesc-sig.zip", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Ftestdata%2Fgo-no-datadesc-sig.zip?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182"}, {"sha": "bcfe121bb63c79be6849ca64589feea612015512", "filename": "libgo/go/archive/zip/testdata/go-with-datadesc-sig.zip", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Farchive%2Fzip%2Ftestdata%2Fgo-with-datadesc-sig.zip", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Farchive%2Fzip%2Ftestdata%2Fgo-with-datadesc-sig.zip", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Ftestdata%2Fgo-with-datadesc-sig.zip?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182"}, {"sha": "45eb6bd730d4729e7525e280e4c96f359bb59073", "filename": "libgo/go/archive/zip/writer.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Farchive%2Fzip%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Farchive%2Fzip%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fwriter.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -224,6 +224,7 @@ func (w *fileWriter) close() error {\n \t// write data descriptor\n \tvar buf [dataDescriptorLen]byte\n \tb := writeBuf(buf[:])\n+\tb.uint32(dataDescriptorSignature) // de-facto standard, required by OS X\n \tb.uint32(fh.CRC32)\n \tb.uint32(fh.CompressedSize)\n \tb.uint32(fh.UncompressedSize)"}, {"sha": "8b1c4dfd265f69fae24817ae803fd08719c3947b", "filename": "libgo/go/archive/zip/writer_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Farchive%2Fzip%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Farchive%2Fzip%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fwriter_test.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -108,7 +108,7 @@ func testReadFile(t *testing.T, f *File, wt *WriteTest) {\n \tif f.Name != wt.Name {\n \t\tt.Fatalf(\"File name: got %q, want %q\", f.Name, wt.Name)\n \t}\n-\ttestFileMode(t, f, wt.Mode)\n+\ttestFileMode(t, wt.Name, f, wt.Mode)\n \trc, err := f.Open()\n \tif err != nil {\n \t\tt.Fatal(\"opening:\", err)"}, {"sha": "4ba0bf874814ca031f505d6bc3d155d0687dee2f", "filename": "libgo/go/crypto/tls/common.go", "status": "modified", "additions": 5, "deletions": 25, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -198,14 +198,6 @@ func (c *Config) time() time.Time {\n \treturn t()\n }\n \n-func (c *Config) rootCAs() *x509.CertPool {\n-\ts := c.RootCAs\n-\tif s == nil {\n-\t\ts = defaultRoots()\n-\t}\n-\treturn s\n-}\n-\n func (c *Config) cipherSuites() []uint16 {\n \ts := c.CipherSuites\n \tif s == nil {\n@@ -311,28 +303,16 @@ func defaultConfig() *Config {\n \treturn &emptyConfig\n }\n \n-var once sync.Once\n-\n-func defaultRoots() *x509.CertPool {\n-\tonce.Do(initDefaults)\n-\treturn varDefaultRoots\n-}\n+var (\n+\tonce                   sync.Once\n+\tvarDefaultCipherSuites []uint16\n+)\n \n func defaultCipherSuites() []uint16 {\n-\tonce.Do(initDefaults)\n+\tonce.Do(initDefaultCipherSuites)\n \treturn varDefaultCipherSuites\n }\n \n-func initDefaults() {\n-\tinitDefaultRoots()\n-\tinitDefaultCipherSuites()\n-}\n-\n-var (\n-\tvarDefaultRoots        *x509.CertPool\n-\tvarDefaultCipherSuites []uint16\n-)\n-\n func initDefaultCipherSuites() {\n \tvarDefaultCipherSuites = make([]uint16, len(cipherSuites))\n \tfor i, suite := range cipherSuites {"}, {"sha": "266eb8f578d56de54dde2fcd556391ab5cd0f385", "filename": "libgo/go/crypto/tls/handshake_client.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -102,7 +102,7 @@ func (c *Conn) clientHandshake() error {\n \n \tif !c.config.InsecureSkipVerify {\n \t\topts := x509.VerifyOptions{\n-\t\t\tRoots:         c.config.rootCAs(),\n+\t\t\tRoots:         c.config.RootCAs,\n \t\t\tCurrentTime:   c.config.time(),\n \t\t\tDNSName:       c.config.ServerName,\n \t\t\tIntermediates: x509.NewCertPool(),"}, {"sha": "08a0ccb09808cfe6c7a786a138683bf55eda47a4", "filename": "libgo/go/crypto/tls/handshake_server_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -143,7 +143,7 @@ func testServerScript(t *testing.T, name string, serverScript [][]byte, config *\n \tif peers != nil {\n \t\tgotpeers := <-pchan\n \t\tif len(peers) == len(gotpeers) {\n-\t\t\tfor i, _ := range peers {\n+\t\t\tfor i := range peers {\n \t\t\t\tif !peers[i].Equal(gotpeers[i]) {\n \t\t\t\t\tt.Fatalf(\"%s: mismatch on peer cert %d\", name, i)\n \t\t\t\t}"}, {"sha": "e61c2185126c154536f391585e41374e928b14fe", "filename": "libgo/go/crypto/tls/root_test.go", "status": "modified", "additions": 31, "deletions": 6, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fcrypto%2Ftls%2Froot_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fcrypto%2Ftls%2Froot_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Froot_test.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -5,25 +5,25 @@\n package tls\n \n import (\n+\t\"crypto/x509\"\n+\t\"runtime\"\n \t\"testing\"\n )\n \n var tlsServers = []string{\n-\t\"google.com:443\",\n-\t\"github.com:443\",\n-\t\"twitter.com:443\",\n+\t\"google.com\",\n+\t\"github.com\",\n+\t\"twitter.com\",\n }\n \n func TestOSCertBundles(t *testing.T) {\n-\tdefaultRoots()\n-\n \tif testing.Short() {\n \t\tt.Logf(\"skipping certificate tests in short mode\")\n \t\treturn\n \t}\n \n \tfor _, addr := range tlsServers {\n-\t\tconn, err := Dial(\"tcp\", addr, nil)\n+\t\tconn, err := Dial(\"tcp\", addr+\":443\", &Config{ServerName: addr})\n \t\tif err != nil {\n \t\t\tt.Errorf(\"unable to verify %v: %v\", addr, err)\n \t\t\tcontinue\n@@ -34,3 +34,28 @@ func TestOSCertBundles(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func TestCertHostnameVerifyWindows(t *testing.T) {\n+\tif runtime.GOOS != \"windows\" {\n+\t\treturn\n+\t}\n+\n+\tif testing.Short() {\n+\t\tt.Logf(\"skipping certificate tests in short mode\")\n+\t\treturn\n+\t}\n+\n+\tfor _, addr := range tlsServers {\n+\t\tcfg := &Config{ServerName: \"example.com\"}\n+\t\tconn, err := Dial(\"tcp\", addr+\":443\", cfg)\n+\t\tif err == nil {\n+\t\t\tconn.Close()\n+\t\t\tt.Errorf(\"should fail to verify for example.com: %v\", addr)\n+\t\t\tcontinue\n+\t\t}\n+\t\t_, ok := err.(x509.HostnameError)\n+\t\tif !ok {\n+\t\t\tt.Errorf(\"error type mismatch, got: %v\", err)\n+\t\t}\n+\t}\n+}"}, {"sha": "319309ae6e7eb5a9ea74bdb1167f3377047cf6d4", "filename": "libgo/go/crypto/tls/root_windows.go", "status": "removed", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0be8a5c203451b47fd3da59b0e0f56cc3d42f22/libgo%2Fgo%2Fcrypto%2Ftls%2Froot_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0be8a5c203451b47fd3da59b0e0f56cc3d42f22/libgo%2Fgo%2Fcrypto%2Ftls%2Froot_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Froot_windows.go?ref=e0be8a5c203451b47fd3da59b0e0f56cc3d42f22", "patch": "@@ -1,47 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package tls\n-\n-import (\n-\t\"crypto/x509\"\n-\t\"syscall\"\n-\t\"unsafe\"\n-)\n-\n-func loadStore(roots *x509.CertPool, name string) {\n-\tstore, err := syscall.CertOpenSystemStore(syscall.InvalidHandle, syscall.StringToUTF16Ptr(name))\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\tdefer syscall.CertCloseStore(store, 0)\n-\n-\tvar cert *syscall.CertContext\n-\tfor {\n-\t\tcert, err = syscall.CertEnumCertificatesInStore(store, cert)\n-\t\tif err != nil {\n-\t\t\treturn\n-\t\t}\n-\n-\t\tbuf := (*[1 << 20]byte)(unsafe.Pointer(cert.EncodedCert))[:]\n-\t\t// ParseCertificate requires its own copy of certificate data to keep.\n-\t\tbuf2 := make([]byte, cert.Length)\n-\t\tcopy(buf2, buf)\n-\t\tif c, err := x509.ParseCertificate(buf2); err == nil {\n-\t\t\troots.AddCert(c)\n-\t\t}\n-\t}\n-}\n-\n-func initDefaultRoots() {\n-\troots := x509.NewCertPool()\n-\n-\t// Roots\n-\tloadStore(roots, \"ROOT\")\n-\n-\t// Intermediates\n-\tloadStore(roots, \"CA\")\n-\n-\tvarDefaultRoots = roots\n-}"}, {"sha": "09df5ad445ca86b8a1ba6c27ee85a4c2a7574d57", "filename": "libgo/go/crypto/tls/tls.go", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -2,8 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// Package tls partially implements the TLS 1.1 protocol, as specified in RFC\n-// 4346.\n+// Package tls partially implements TLS 1.0, as specified in RFC 2246.\n package tls\n \n import (\n@@ -98,7 +97,9 @@ func Dial(network, addr string, config *Config) (*Conn, error) {\n \tif config == nil {\n \t\tconfig = defaultConfig()\n \t}\n-\tif config.ServerName != \"\" {\n+\t// If no ServerName is set, infer the ServerName\n+\t// from the hostname we're connecting to.\n+\tif config.ServerName == \"\" {\n \t\t// Make a copy to avoid polluting argument or default.\n \t\tc := *config\n \t\tc.ServerName = hostname"}, {"sha": "873d3966eb55cf51488d2e14ec6013d17ccda157", "filename": "libgo/go/crypto/x509/pkcs1.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkcs1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkcs1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkcs1.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -24,7 +24,7 @@ type pkcs1PrivateKey struct {\n \tDq   *big.Int `asn1:\"optional\"`\n \tQinv *big.Int `asn1:\"optional\"`\n \n-\tAdditionalPrimes []pkcs1AdditionalRSAPrime `asn1:\"optional\"`\n+\tAdditionalPrimes []pkcs1AdditionalRSAPrime `asn1:\"optional,omitempty\"`\n }\n \n type pkcs1AdditionalRSAPrime struct {"}, {"sha": "8aae14e09ee72626b64895c8ffd282938c62faeb", "filename": "libgo/go/crypto/x509/root.go", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fcrypto%2Fx509%2Froot.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fcrypto%2Fx509%2Froot.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Froot.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package x509\n+\n+import \"sync\"\n+\n+var (\n+\tonce        sync.Once\n+\tsystemRoots *CertPool\n+)\n+\n+func systemRootsPool() *CertPool {\n+\tonce.Do(initSystemRoots)\n+\treturn systemRoots\n+}"}, {"sha": "0f99581e8a776766f45b9ef41bbe9fc5eb2d324c", "filename": "libgo/go/crypto/x509/root_darwin.go", "status": "renamed", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_darwin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_darwin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_darwin.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-package tls\n+package x509\n \n /*\n #cgo CFLAGS: -mmacosx-version-min=10.6 -D__MAC_OS_X_VERSION_MAX_ALLOWED=1060\n@@ -59,13 +59,14 @@ int FetchPEMRoots(CFDataRef *pemRoots) {\n }\n */\n import \"C\"\n-import (\n-\t\"crypto/x509\"\n-\t\"unsafe\"\n-)\n+import \"unsafe\"\n \n-func initDefaultRoots() {\n-\troots := x509.NewCertPool()\n+func (c *Certificate) systemVerify(opts *VerifyOptions) (chains [][]*Certificate, err error) {\n+\treturn nil, nil\n+}\n+\n+func initSystemRoots() {\n+\troots := NewCertPool()\n \n \tvar data C.CFDataRef = nil\n \terr := C.FetchPEMRoots(&data)\n@@ -75,5 +76,5 @@ func initDefaultRoots() {\n \t\troots.AppendCertsFromPEM(buf)\n \t}\n \n-\tvarDefaultRoots = roots\n+\tsystemRoots = roots\n }", "previous_filename": "libgo/go/crypto/tls/root_darwin.go"}, {"sha": "568004108b538e8858e70b6656987314a7a8cf41", "filename": "libgo/go/crypto/x509/root_stub.go", "status": "renamed", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_stub.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_stub.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_stub.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -4,7 +4,12 @@\n \n // +build plan9 darwin,!cgo\n \n-package tls\n+package x509\n \n-func initDefaultRoots() {\n+func (c *Certificate) systemVerify(opts *VerifyOptions) (chains [][]*Certificate, err error) {\n+\treturn nil, nil\n+}\n+\n+func initSystemRoots() {\n+\tsystemRoots = NewCertPool()\n }", "previous_filename": "libgo/go/crypto/tls/root_stub.go"}, {"sha": "76e79f494f75e8074061249e9f42f3462ef66e5f", "filename": "libgo/go/crypto/x509/root_unix.go", "status": "renamed", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_unix.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -4,12 +4,9 @@\n \n // +build freebsd linux openbsd netbsd\n \n-package tls\n+package x509\n \n-import (\n-\t\"crypto/x509\"\n-\t\"io/ioutil\"\n-)\n+import \"io/ioutil\"\n \n // Possible certificate files; stop after finding one.\n var certFiles = []string{\n@@ -20,14 +17,19 @@ var certFiles = []string{\n \t\"/usr/local/share/certs/ca-root-nss.crt\", // FreeBSD\n }\n \n-func initDefaultRoots() {\n-\troots := x509.NewCertPool()\n+func (c *Certificate) systemVerify(opts *VerifyOptions) (chains [][]*Certificate, err error) {\n+\treturn nil, nil\n+}\n+\n+func initSystemRoots() {\n+\troots := NewCertPool()\n \tfor _, file := range certFiles {\n \t\tdata, err := ioutil.ReadFile(file)\n \t\tif err == nil {\n \t\t\troots.AppendCertsFromPEM(data)\n \t\t\tbreak\n \t\t}\n \t}\n-\tvarDefaultRoots = roots\n+\n+\tsystemRoots = roots\n }", "previous_filename": "libgo/go/crypto/tls/root_unix.go"}, {"sha": "7e8f2af4b0ea94304a0818982c50365e5c3a3c26", "filename": "libgo/go/crypto/x509/root_windows.go", "status": "added", "additions": 226, "deletions": 0, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_windows.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -0,0 +1,226 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package x509\n+\n+import (\n+\t\"errors\"\n+\t\"syscall\"\n+\t\"unsafe\"\n+)\n+\n+// Creates a new *syscall.CertContext representing the leaf certificate in an in-memory\n+// certificate store containing itself and all of the intermediate certificates specified\n+// in the opts.Intermediates CertPool.\n+//\n+// A pointer to the in-memory store is available in the returned CertContext's Store field.\n+// The store is automatically freed when the CertContext is freed using\n+// syscall.CertFreeCertificateContext.\n+func createStoreContext(leaf *Certificate, opts *VerifyOptions) (*syscall.CertContext, error) {\n+\tvar storeCtx *syscall.CertContext\n+\n+\tleafCtx, err := syscall.CertCreateCertificateContext(syscall.X509_ASN_ENCODING|syscall.PKCS_7_ASN_ENCODING, &leaf.Raw[0], uint32(len(leaf.Raw)))\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer syscall.CertFreeCertificateContext(leafCtx)\n+\n+\thandle, err := syscall.CertOpenStore(syscall.CERT_STORE_PROV_MEMORY, 0, 0, syscall.CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG, 0)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer syscall.CertCloseStore(handle, 0)\n+\n+\terr = syscall.CertAddCertificateContextToStore(handle, leafCtx, syscall.CERT_STORE_ADD_ALWAYS, &storeCtx)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tif opts.Intermediates != nil {\n+\t\tfor _, intermediate := range opts.Intermediates.certs {\n+\t\t\tctx, err := syscall.CertCreateCertificateContext(syscall.X509_ASN_ENCODING|syscall.PKCS_7_ASN_ENCODING, &intermediate.Raw[0], uint32(len(intermediate.Raw)))\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\n+\t\t\terr = syscall.CertAddCertificateContextToStore(handle, ctx, syscall.CERT_STORE_ADD_ALWAYS, nil)\n+\t\t\tsyscall.CertFreeCertificateContext(ctx)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn storeCtx, nil\n+}\n+\n+// extractSimpleChain extracts the final certificate chain from a CertSimpleChain.\n+func extractSimpleChain(simpleChain **syscall.CertSimpleChain, count int) (chain []*Certificate, err error) {\n+\tif simpleChain == nil || count == 0 {\n+\t\treturn nil, errors.New(\"x509: invalid simple chain\")\n+\t}\n+\n+\tsimpleChains := (*[1 << 20]*syscall.CertSimpleChain)(unsafe.Pointer(simpleChain))[:]\n+\tlastChain := simpleChains[count-1]\n+\telements := (*[1 << 20]*syscall.CertChainElement)(unsafe.Pointer(lastChain.Elements))[:]\n+\tfor i := 0; i < int(lastChain.NumElements); i++ {\n+\t\t// Copy the buf, since ParseCertificate does not create its own copy.\n+\t\tcert := elements[i].CertContext\n+\t\tencodedCert := (*[1 << 20]byte)(unsafe.Pointer(cert.EncodedCert))[:]\n+\t\tbuf := make([]byte, cert.Length)\n+\t\tcopy(buf, encodedCert[:])\n+\t\tparsedCert, err := ParseCertificate(buf)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tchain = append(chain, parsedCert)\n+\t}\n+\n+\treturn chain, nil\n+}\n+\n+// checkChainTrustStatus checks the trust status of the certificate chain, translating\n+// any errors it finds into Go errors in the process.\n+func checkChainTrustStatus(c *Certificate, chainCtx *syscall.CertChainContext) error {\n+\tif chainCtx.TrustStatus.ErrorStatus != syscall.CERT_TRUST_NO_ERROR {\n+\t\tstatus := chainCtx.TrustStatus.ErrorStatus\n+\t\tswitch status {\n+\t\tcase syscall.CERT_TRUST_IS_NOT_TIME_VALID:\n+\t\t\treturn CertificateInvalidError{c, Expired}\n+\t\tdefault:\n+\t\t\treturn UnknownAuthorityError{c}\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+// checkChainSSLServerPolicy checks that the certificate chain in chainCtx is valid for\n+// use as a certificate chain for a SSL/TLS server.\n+func checkChainSSLServerPolicy(c *Certificate, chainCtx *syscall.CertChainContext, opts *VerifyOptions) error {\n+\tsslPara := &syscall.SSLExtraCertChainPolicyPara{\n+\t\tAuthType:   syscall.AUTHTYPE_SERVER,\n+\t\tServerName: syscall.StringToUTF16Ptr(opts.DNSName),\n+\t}\n+\tsslPara.Size = uint32(unsafe.Sizeof(*sslPara))\n+\n+\tpara := &syscall.CertChainPolicyPara{\n+\t\tExtraPolicyPara: uintptr(unsafe.Pointer(sslPara)),\n+\t}\n+\tpara.Size = uint32(unsafe.Sizeof(*para))\n+\n+\tstatus := syscall.CertChainPolicyStatus{}\n+\terr := syscall.CertVerifyCertificateChainPolicy(syscall.CERT_CHAIN_POLICY_SSL, chainCtx, para, &status)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\t// TODO(mkrautz): use the lChainIndex and lElementIndex fields\n+\t// of the CertChainPolicyStatus to provide proper context, instead\n+\t// using c.\n+\tif status.Error != 0 {\n+\t\tswitch status.Error {\n+\t\tcase syscall.CERT_E_EXPIRED:\n+\t\t\treturn CertificateInvalidError{c, Expired}\n+\t\tcase syscall.CERT_E_CN_NO_MATCH:\n+\t\t\treturn HostnameError{c, opts.DNSName}\n+\t\tcase syscall.CERT_E_UNTRUSTEDROOT:\n+\t\t\treturn UnknownAuthorityError{c}\n+\t\tdefault:\n+\t\t\treturn UnknownAuthorityError{c}\n+\t\t}\n+\t}\n+\n+\treturn nil\n+}\n+\n+// systemVerify is like Verify, except that it uses CryptoAPI calls\n+// to build certificate chains and verify them.\n+func (c *Certificate) systemVerify(opts *VerifyOptions) (chains [][]*Certificate, err error) {\n+\thasDNSName := opts != nil && len(opts.DNSName) > 0\n+\n+\tstoreCtx, err := createStoreContext(c, opts)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer syscall.CertFreeCertificateContext(storeCtx)\n+\n+\tpara := new(syscall.CertChainPara)\n+\tpara.Size = uint32(unsafe.Sizeof(*para))\n+\n+\t// If there's a DNSName set in opts, assume we're verifying\n+\t// a certificate from a TLS server.\n+\tif hasDNSName {\n+\t\toids := []*byte{\n+\t\t\t&syscall.OID_PKIX_KP_SERVER_AUTH[0],\n+\t\t\t// Both IE and Chrome allow certificates with\n+\t\t\t// Server Gated Crypto as well. Some certificates\n+\t\t\t// in the wild require them.\n+\t\t\t&syscall.OID_SERVER_GATED_CRYPTO[0],\n+\t\t\t&syscall.OID_SGC_NETSCAPE[0],\n+\t\t}\n+\t\tpara.RequestedUsage.Type = syscall.USAGE_MATCH_TYPE_OR\n+\t\tpara.RequestedUsage.Usage.Length = uint32(len(oids))\n+\t\tpara.RequestedUsage.Usage.UsageIdentifiers = &oids[0]\n+\t} else {\n+\t\tpara.RequestedUsage.Type = syscall.USAGE_MATCH_TYPE_AND\n+\t\tpara.RequestedUsage.Usage.Length = 0\n+\t\tpara.RequestedUsage.Usage.UsageIdentifiers = nil\n+\t}\n+\n+\tvar verifyTime *syscall.Filetime\n+\tif opts != nil && !opts.CurrentTime.IsZero() {\n+\t\tft := syscall.NsecToFiletime(opts.CurrentTime.UnixNano())\n+\t\tverifyTime = &ft\n+\t}\n+\n+\t// CertGetCertificateChain will traverse Windows's root stores\n+\t// in an attempt to build a verified certificate chain.  Once\n+\t// it has found a verified chain, it stops. MSDN docs on\n+\t// CERT_CHAIN_CONTEXT:\n+\t//\n+\t//   When a CERT_CHAIN_CONTEXT is built, the first simple chain\n+\t//   begins with an end certificate and ends with a self-signed\n+\t//   certificate. If that self-signed certificate is not a root\n+\t//   or otherwise trusted certificate, an attempt is made to\n+\t//   build a new chain. CTLs are used to create the new chain\n+\t//   beginning with the self-signed certificate from the original\n+\t//   chain as the end certificate of the new chain. This process\n+\t//   continues building additional simple chains until the first\n+\t//   self-signed certificate is a trusted certificate or until\n+\t//   an additional simple chain cannot be built.\n+\t//\n+\t// The result is that we'll only get a single trusted chain to\n+\t// return to our caller.\n+\tvar chainCtx *syscall.CertChainContext\n+\terr = syscall.CertGetCertificateChain(syscall.Handle(0), storeCtx, verifyTime, storeCtx.Store, para, 0, 0, &chainCtx)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer syscall.CertFreeCertificateChain(chainCtx)\n+\n+\terr = checkChainTrustStatus(c, chainCtx)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tif hasDNSName {\n+\t\terr = checkChainSSLServerPolicy(c, chainCtx, opts)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t}\n+\n+\tchain, err := extractSimpleChain(chainCtx.Chains, int(chainCtx.ChainCount))\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tchains = append(chains, chain)\n+\n+\treturn chains, nil\n+}\n+\n+func initSystemRoots() {\n+\tsystemRoots = NewCertPool()\n+}"}, {"sha": "307c5ef03394e581c8aaf8ef219ee500a6d7ee11", "filename": "libgo/go/crypto/x509/verify.go", "status": "modified", "additions": 30, "deletions": 6, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -5,6 +5,7 @@\n package x509\n \n import (\n+\t\"runtime\"\n \t\"strings\"\n \t\"time\"\n \t\"unicode/utf8\"\n@@ -23,6 +24,9 @@ const (\n \t// certificate has a name constraint which doesn't include the name\n \t// being checked.\n \tCANotAuthorizedForThisName\n+\t// TooManyIntermediates results when a path length constraint is\n+\t// violated.\n+\tTooManyIntermediates\n )\n \n // CertificateInvalidError results when an odd error occurs. Users of this\n@@ -40,6 +44,8 @@ func (e CertificateInvalidError) Error() string {\n \t\treturn \"x509: certificate has expired or is not yet valid\"\n \tcase CANotAuthorizedForThisName:\n \t\treturn \"x509: a root or intermediate certificate is not authorized to sign in this domain\"\n+\tcase TooManyIntermediates:\n+\t\treturn \"x509: too many intermediates for path length constraint\"\n \t}\n \treturn \"x509: unknown error\"\n }\n@@ -76,7 +82,7 @@ func (e UnknownAuthorityError) Error() string {\n type VerifyOptions struct {\n \tDNSName       string\n \tIntermediates *CertPool\n-\tRoots         *CertPool\n+\tRoots         *CertPool // if nil, the system roots are used\n \tCurrentTime   time.Time // if zero, the current time is used\n }\n \n@@ -87,7 +93,7 @@ const (\n )\n \n // isValid performs validity checks on the c.\n-func (c *Certificate) isValid(certType int, opts *VerifyOptions) error {\n+func (c *Certificate) isValid(certType int, currentChain []*Certificate, opts *VerifyOptions) error {\n \tnow := opts.CurrentTime\n \tif now.IsZero() {\n \t\tnow = time.Now()\n@@ -130,26 +136,44 @@ func (c *Certificate) isValid(certType int, opts *VerifyOptions) error {\n \t\treturn CertificateInvalidError{c, NotAuthorizedToSign}\n \t}\n \n+\tif c.BasicConstraintsValid && c.MaxPathLen >= 0 {\n+\t\tnumIntermediates := len(currentChain) - 1\n+\t\tif numIntermediates > c.MaxPathLen {\n+\t\t\treturn CertificateInvalidError{c, TooManyIntermediates}\n+\t\t}\n+\t}\n+\n \treturn nil\n }\n \n // Verify attempts to verify c by building one or more chains from c to a\n-// certificate in opts.roots, using certificates in opts.Intermediates if\n+// certificate in opts.Roots, using certificates in opts.Intermediates if\n // needed. If successful, it returns one or more chains where the first\n // element of the chain is c and the last element is from opts.Roots.\n //\n // WARNING: this doesn't do any revocation checking.\n func (c *Certificate) Verify(opts VerifyOptions) (chains [][]*Certificate, err error) {\n-\terr = c.isValid(leafCertificate, &opts)\n+\t// Use Windows's own verification and chain building.\n+\tif opts.Roots == nil && runtime.GOOS == \"windows\" {\n+\t\treturn c.systemVerify(&opts)\n+\t}\n+\n+\tif opts.Roots == nil {\n+\t\topts.Roots = systemRootsPool()\n+\t}\n+\n+\terr = c.isValid(leafCertificate, nil, &opts)\n \tif err != nil {\n \t\treturn\n \t}\n+\n \tif len(opts.DNSName) > 0 {\n \t\terr = c.VerifyHostname(opts.DNSName)\n \t\tif err != nil {\n \t\t\treturn\n \t\t}\n \t}\n+\n \treturn c.buildChains(make(map[int][][]*Certificate), []*Certificate{c}, &opts)\n }\n \n@@ -163,7 +187,7 @@ func appendToFreshChain(chain []*Certificate, cert *Certificate) []*Certificate\n func (c *Certificate) buildChains(cache map[int][][]*Certificate, currentChain []*Certificate, opts *VerifyOptions) (chains [][]*Certificate, err error) {\n \tfor _, rootNum := range opts.Roots.findVerifiedParents(c) {\n \t\troot := opts.Roots.certs[rootNum]\n-\t\terr = root.isValid(rootCertificate, opts)\n+\t\terr = root.isValid(rootCertificate, currentChain, opts)\n \t\tif err != nil {\n \t\t\tcontinue\n \t\t}\n@@ -178,7 +202,7 @@ nextIntermediate:\n \t\t\t\tcontinue nextIntermediate\n \t\t\t}\n \t\t}\n-\t\terr = intermediate.isValid(intermediateCertificate, opts)\n+\t\terr = intermediate.isValid(intermediateCertificate, currentChain, opts)\n \t\tif err != nil {\n \t\t\tcontinue\n \t\t}"}, {"sha": "7b171b291a4b5eb645f4b7edfd231ef5987f4835", "filename": "libgo/go/crypto/x509/verify_test.go", "status": "modified", "additions": 34, "deletions": 19, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify_test.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -8,6 +8,7 @@ import (\n \t\"crypto/x509/pkix\"\n \t\"encoding/pem\"\n \t\"errors\"\n+\t\"runtime\"\n \t\"strings\"\n \t\"testing\"\n \t\"time\"\n@@ -19,7 +20,7 @@ type verifyTest struct {\n \troots         []string\n \tcurrentTime   int64\n \tdnsName       string\n-\tnilRoots      bool\n+\tsystemSkip    bool\n \n \terrorCallback  func(*testing.T, int, error) bool\n \texpectedChains [][]string\n@@ -57,14 +58,6 @@ var verifyTests = []verifyTest{\n \n \t\terrorCallback: expectHostnameError,\n \t},\n-\t{\n-\t\tleaf:          googleLeaf,\n-\t\tintermediates: []string{thawteIntermediate},\n-\t\tnilRoots:      true, // verifies that we don't crash\n-\t\tcurrentTime:   1302726541,\n-\t\tdnsName:       \"www.google.com\",\n-\t\terrorCallback: expectAuthorityUnknown,\n-\t},\n \t{\n \t\tleaf:          googleLeaf,\n \t\tintermediates: []string{thawteIntermediate},\n@@ -80,6 +73,9 @@ var verifyTests = []verifyTest{\n \t\tcurrentTime: 1302726541,\n \t\tdnsName:     \"www.google.com\",\n \n+\t\t// Skip when using systemVerify, since Windows\n+\t\t// *will* find the missing intermediate cert.\n+\t\tsystemSkip:    true,\n \t\terrorCallback: expectAuthorityUnknown,\n \t},\n \t{\n@@ -109,6 +105,9 @@ var verifyTests = []verifyTest{\n \t\troots:         []string{startComRoot},\n \t\tcurrentTime:   1302726541,\n \n+\t\t// Skip when using systemVerify, since Windows\n+\t\t// can only return a single chain to us (for now).\n+\t\tsystemSkip: true,\n \t\texpectedChains: [][]string{\n \t\t\t{\"dnssec-exp\", \"StartCom Class 1\", \"StartCom Certification Authority\"},\n \t\t\t{\"dnssec-exp\", \"StartCom Class 1\", \"StartCom Certification Authority\", \"StartCom Certification Authority\"},\n@@ -148,23 +147,26 @@ func certificateFromPEM(pemBytes string) (*Certificate, error) {\n \treturn ParseCertificate(block.Bytes)\n }\n \n-func TestVerify(t *testing.T) {\n+func testVerify(t *testing.T, useSystemRoots bool) {\n \tfor i, test := range verifyTests {\n+\t\tif useSystemRoots && test.systemSkip {\n+\t\t\tcontinue\n+\t\t}\n+\n \t\topts := VerifyOptions{\n-\t\t\tRoots:         NewCertPool(),\n \t\t\tIntermediates: NewCertPool(),\n \t\t\tDNSName:       test.dnsName,\n \t\t\tCurrentTime:   time.Unix(test.currentTime, 0),\n \t\t}\n-\t\tif test.nilRoots {\n-\t\t\topts.Roots = nil\n-\t\t}\n \n-\t\tfor j, root := range test.roots {\n-\t\t\tok := opts.Roots.AppendCertsFromPEM([]byte(root))\n-\t\t\tif !ok {\n-\t\t\t\tt.Errorf(\"#%d: failed to parse root #%d\", i, j)\n-\t\t\t\treturn\n+\t\tif !useSystemRoots {\n+\t\t\topts.Roots = NewCertPool()\n+\t\t\tfor j, root := range test.roots {\n+\t\t\t\tok := opts.Roots.AppendCertsFromPEM([]byte(root))\n+\t\t\t\tif !ok {\n+\t\t\t\t\tt.Errorf(\"#%d: failed to parse root #%d\", i, j)\n+\t\t\t\t\treturn\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \n@@ -225,6 +227,19 @@ func TestVerify(t *testing.T) {\n \t}\n }\n \n+func TestGoVerify(t *testing.T) {\n+\ttestVerify(t, false)\n+}\n+\n+func TestSystemVerify(t *testing.T) {\n+\tif runtime.GOOS != \"windows\" {\n+\t\tt.Logf(\"skipping verify test using system APIs on %q\", runtime.GOOS)\n+\t\treturn\n+\t}\n+\n+\ttestVerify(t, true)\n+}\n+\n func chainToDebugString(chain []*Certificate) string {\n \tvar chainStr string\n \tfor _, cert := range chain {"}, {"sha": "8dae7e7fcf948c302c0ac97dd1fa415e5fb6334a", "filename": "libgo/go/crypto/x509/x509.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -429,7 +429,7 @@ func (h UnhandledCriticalExtension) Error() string {\n \n type basicConstraints struct {\n \tIsCA       bool `asn1:\"optional\"`\n-\tMaxPathLen int  `asn1:\"optional\"`\n+\tMaxPathLen int  `asn1:\"optional,default:-1\"`\n }\n \n // RFC 5280 4.2.1.4"}, {"sha": "2f5280db810516be9d3ae53f1c3a4c56ff854f5b", "filename": "libgo/go/database/sql/driver/driver.go", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fdatabase%2Fsql%2Fdriver%2Fdriver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fdatabase%2Fsql%2Fdriver%2Fdriver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fdriver%2Fdriver.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -43,6 +43,17 @@ type Driver interface {\n // documented.\n var ErrSkip = errors.New(\"driver: skip fast-path; continue as if unimplemented\")\n \n+// ErrBadConn should be returned by a driver to signal to the sql\n+// package that a driver.Conn is in a bad state (such as the server\n+// having earlier closed the connection) and the sql package should\n+// retry on a new connection.\n+//\n+// To prevent duplicate operations, ErrBadConn should NOT be returned\n+// if there's a possibility that the database server might have\n+// performed the operation. Even if the server sends back an error,\n+// you shouldn't return ErrBadConn.\n+var ErrBadConn = errors.New(\"driver: bad connection\")\n+\n // Execer is an optional interface that may be implemented by a Conn.\n //\n // If a Conn does not implement Execer, the db package's DB.Exec will"}, {"sha": "184e7756c51e4228e89e420393519bff05361a81", "filename": "libgo/go/database/sql/fakedb_test.go", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fdatabase%2Fsql%2Ffakedb_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fdatabase%2Fsql%2Ffakedb_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Ffakedb_test.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -82,6 +82,7 @@ type fakeConn struct {\n \tmu          sync.Mutex\n \tstmtsMade   int\n \tstmtsClosed int\n+\tnumPrepare  int\n }\n \n func (c *fakeConn) incrStat(v *int) {\n@@ -208,10 +209,13 @@ func (c *fakeConn) Begin() (driver.Tx, error) {\n \n func (c *fakeConn) Close() error {\n \tif c.currTx != nil {\n-\t\treturn errors.New(\"can't close; in a Transaction\")\n+\t\treturn errors.New(\"can't close fakeConn; in a Transaction\")\n \t}\n \tif c.db == nil {\n-\t\treturn errors.New(\"can't close; already closed\")\n+\t\treturn errors.New(\"can't close fakeConn; already closed\")\n+\t}\n+\tif c.stmtsMade > c.stmtsClosed {\n+\t\treturn errors.New(\"can't close; dangling statement(s)\")\n \t}\n \tc.db = nil\n \treturn nil\n@@ -249,6 +253,7 @@ func errf(msg string, args ...interface{}) error {\n //  just a limitation for fakedb)\n func (c *fakeConn) prepareSelect(stmt *fakeStmt, parts []string) (driver.Stmt, error) {\n \tif len(parts) != 3 {\n+\t\tstmt.Close()\n \t\treturn nil, errf(\"invalid SELECT syntax with %d parts; want 3\", len(parts))\n \t}\n \tstmt.table = parts[0]\n@@ -259,14 +264,17 @@ func (c *fakeConn) prepareSelect(stmt *fakeStmt, parts []string) (driver.Stmt, e\n \t\t}\n \t\tnameVal := strings.Split(colspec, \"=\")\n \t\tif len(nameVal) != 2 {\n+\t\t\tstmt.Close()\n \t\t\treturn nil, errf(\"SELECT on table %q has invalid column spec of %q (index %d)\", stmt.table, colspec, n)\n \t\t}\n \t\tcolumn, value := nameVal[0], nameVal[1]\n \t\t_, ok := c.db.columnType(stmt.table, column)\n \t\tif !ok {\n+\t\t\tstmt.Close()\n \t\t\treturn nil, errf(\"SELECT on table %q references non-existent column %q\", stmt.table, column)\n \t\t}\n \t\tif value != \"?\" {\n+\t\t\tstmt.Close()\n \t\t\treturn nil, errf(\"SELECT on table %q has pre-bound value for where column %q; need a question mark\",\n \t\t\t\tstmt.table, column)\n \t\t}\n@@ -279,12 +287,14 @@ func (c *fakeConn) prepareSelect(stmt *fakeStmt, parts []string) (driver.Stmt, e\n // parts are table|col=type,col2=type2\n func (c *fakeConn) prepareCreate(stmt *fakeStmt, parts []string) (driver.Stmt, error) {\n \tif len(parts) != 2 {\n+\t\tstmt.Close()\n \t\treturn nil, errf(\"invalid CREATE syntax with %d parts; want 2\", len(parts))\n \t}\n \tstmt.table = parts[0]\n \tfor n, colspec := range strings.Split(parts[1], \",\") {\n \t\tnameType := strings.Split(colspec, \"=\")\n \t\tif len(nameType) != 2 {\n+\t\t\tstmt.Close()\n \t\t\treturn nil, errf(\"CREATE table %q has invalid column spec of %q (index %d)\", stmt.table, colspec, n)\n \t\t}\n \t\tstmt.colName = append(stmt.colName, nameType[0])\n@@ -296,17 +306,20 @@ func (c *fakeConn) prepareCreate(stmt *fakeStmt, parts []string) (driver.Stmt, e\n // parts are table|col=?,col2=val\n func (c *fakeConn) prepareInsert(stmt *fakeStmt, parts []string) (driver.Stmt, error) {\n \tif len(parts) != 2 {\n+\t\tstmt.Close()\n \t\treturn nil, errf(\"invalid INSERT syntax with %d parts; want 2\", len(parts))\n \t}\n \tstmt.table = parts[0]\n \tfor n, colspec := range strings.Split(parts[1], \",\") {\n \t\tnameVal := strings.Split(colspec, \"=\")\n \t\tif len(nameVal) != 2 {\n+\t\t\tstmt.Close()\n \t\t\treturn nil, errf(\"INSERT table %q has invalid column spec of %q (index %d)\", stmt.table, colspec, n)\n \t\t}\n \t\tcolumn, value := nameVal[0], nameVal[1]\n \t\tctype, ok := c.db.columnType(stmt.table, column)\n \t\tif !ok {\n+\t\t\tstmt.Close()\n \t\t\treturn nil, errf(\"INSERT table %q references non-existent column %q\", stmt.table, column)\n \t\t}\n \t\tstmt.colName = append(stmt.colName, column)\n@@ -322,10 +335,12 @@ func (c *fakeConn) prepareInsert(stmt *fakeStmt, parts []string) (driver.Stmt, e\n \t\t\tcase \"int32\":\n \t\t\t\ti, err := strconv.Atoi(value)\n \t\t\t\tif err != nil {\n+\t\t\t\t\tstmt.Close()\n \t\t\t\t\treturn nil, errf(\"invalid conversion to int32 from %q\", value)\n \t\t\t\t}\n \t\t\t\tsubsetVal = int64(i) // int64 is a subset type, but not int32\n \t\t\tdefault:\n+\t\t\t\tstmt.Close()\n \t\t\t\treturn nil, errf(\"unsupported conversion for pre-bound parameter %q to type %q\", value, ctype)\n \t\t\t}\n \t\t\tstmt.colValue = append(stmt.colValue, subsetVal)\n@@ -339,6 +354,7 @@ func (c *fakeConn) prepareInsert(stmt *fakeStmt, parts []string) (driver.Stmt, e\n }\n \n func (c *fakeConn) Prepare(query string) (driver.Stmt, error) {\n+\tc.numPrepare++\n \tif c.db == nil {\n \t\tpanic(\"nil c.db; conn = \" + fmt.Sprintf(\"%#v\", c))\n \t}\n@@ -360,6 +376,7 @@ func (c *fakeConn) Prepare(query string) (driver.Stmt, error) {\n \tcase \"INSERT\":\n \t\treturn c.prepareInsert(stmt, parts)\n \tdefault:\n+\t\tstmt.Close()\n \t\treturn nil, errf(\"unsupported command type %q\", cmd)\n \t}\n \treturn stmt, nil"}, {"sha": "51a357b37debbc2cd6cefe176a6472686699a5c8", "filename": "libgo/go/database/sql/sql.go", "status": "modified", "additions": 102, "deletions": 43, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -175,6 +175,16 @@ var ErrNoRows = errors.New(\"sql: no rows in result set\")\n \n // DB is a database handle. It's safe for concurrent use by multiple\n // goroutines.\n+//\n+// If the underlying database driver has the concept of a connection\n+// and per-connection session state, the sql package manages creating\n+// and freeing connections automatically, including maintaining a free\n+// pool of idle connections. If observing session state is required,\n+// either do not share a *DB between multiple concurrent goroutines or\n+// create and observe all state only within a transaction. Once\n+// DB.Open is called, the returned Tx is bound to a single isolated\n+// connection. Once Tx.Commit or Tx.Rollback is called, that\n+// connection is returned to DB's idle connection pool.\n type DB struct {\n \tdriver driver.Driver\n \tdsn    string\n@@ -241,34 +251,56 @@ func (db *DB) conn() (driver.Conn, error) {\n func (db *DB) connIfFree(wanted driver.Conn) (conn driver.Conn, ok bool) {\n \tdb.mu.Lock()\n \tdefer db.mu.Unlock()\n-\tfor n, conn := range db.freeConn {\n-\t\tif conn == wanted {\n-\t\t\tdb.freeConn[n] = db.freeConn[len(db.freeConn)-1]\n-\t\t\tdb.freeConn = db.freeConn[:len(db.freeConn)-1]\n-\t\t\treturn wanted, true\n+\tfor i, conn := range db.freeConn {\n+\t\tif conn != wanted {\n+\t\t\tcontinue\n \t\t}\n+\t\tdb.freeConn[i] = db.freeConn[len(db.freeConn)-1]\n+\t\tdb.freeConn = db.freeConn[:len(db.freeConn)-1]\n+\t\treturn wanted, true\n \t}\n \treturn nil, false\n }\n \n-func (db *DB) putConn(c driver.Conn) {\n+// putConnHook is a hook for testing.\n+var putConnHook func(*DB, driver.Conn)\n+\n+// putConn adds a connection to the db's free pool.\n+// err is optionally the last error that occured on this connection.\n+func (db *DB) putConn(c driver.Conn, err error) {\n+\tif err == driver.ErrBadConn {\n+\t\t// Don't reuse bad connections.\n+\t\treturn\n+\t}\n \tdb.mu.Lock()\n-\tdefer db.mu.Unlock()\n+\tif putConnHook != nil {\n+\t\tputConnHook(db, c)\n+\t}\n \tif n := len(db.freeConn); !db.closed && n < db.maxIdleConns() {\n \t\tdb.freeConn = append(db.freeConn, c)\n+\t\tdb.mu.Unlock()\n \t\treturn\n \t}\n-\tdb.closeConn(c) // TODO(bradfitz): release lock before calling this?\n-}\n-\n-func (db *DB) closeConn(c driver.Conn) {\n-\t// TODO: check to see if we need this Conn for any prepared statements\n-\t// that are active.\n+\t// TODO: check to see if we need this Conn for any prepared\n+\t// statements which are still active?\n+\tdb.mu.Unlock()\n \tc.Close()\n }\n \n // Prepare creates a prepared statement for later execution.\n func (db *DB) Prepare(query string) (*Stmt, error) {\n+\tvar stmt *Stmt\n+\tvar err error\n+\tfor i := 0; i < 10; i++ {\n+\t\tstmt, err = db.prepare(query)\n+\t\tif err != driver.ErrBadConn {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\treturn stmt, err\n+}\n+\n+func (db *DB) prepare(query string) (stmt *Stmt, err error) {\n \t// TODO: check if db.driver supports an optional\n \t// driver.Preparer interface and call that instead, if so,\n \t// otherwise we make a prepared statement that's bound\n@@ -279,12 +311,12 @@ func (db *DB) Prepare(query string) (*Stmt, error) {\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\tdefer db.putConn(ci)\n+\tdefer db.putConn(ci, err)\n \tsi, err := ci.Prepare(query)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\tstmt := &Stmt{\n+\tstmt = &Stmt{\n \t\tdb:    db,\n \t\tquery: query,\n \t\tcss:   []connStmt{{ci, si}},\n@@ -295,15 +327,22 @@ func (db *DB) Prepare(query string) (*Stmt, error) {\n // Exec executes a query without returning any rows.\n func (db *DB) Exec(query string, args ...interface{}) (Result, error) {\n \tsargs, err := subsetTypeArgs(args)\n-\tif err != nil {\n-\t\treturn nil, err\n+\tvar res Result\n+\tfor i := 0; i < 10; i++ {\n+\t\tres, err = db.exec(query, sargs)\n+\t\tif err != driver.ErrBadConn {\n+\t\t\tbreak\n+\t\t}\n \t}\n+\treturn res, err\n+}\n \n+func (db *DB) exec(query string, sargs []driver.Value) (res Result, err error) {\n \tci, err := db.conn()\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\tdefer db.putConn(ci)\n+\tdefer db.putConn(ci, err)\n \n \tif execer, ok := ci.(driver.Execer); ok {\n \t\tresi, err := execer.Exec(query, sargs)\n@@ -354,13 +393,25 @@ func (db *DB) QueryRow(query string, args ...interface{}) *Row {\n // Begin starts a transaction. The isolation level is dependent on\n // the driver.\n func (db *DB) Begin() (*Tx, error) {\n+\tvar tx *Tx\n+\tvar err error\n+\tfor i := 0; i < 10; i++ {\n+\t\ttx, err = db.begin()\n+\t\tif err != driver.ErrBadConn {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\treturn tx, err\n+}\n+\n+func (db *DB) begin() (tx *Tx, err error) {\n \tci, err := db.conn()\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \ttxi, err := ci.Begin()\n \tif err != nil {\n-\t\tdb.putConn(ci)\n+\t\tdb.putConn(ci, err)\n \t\treturn nil, fmt.Errorf(\"sql: failed to Begin transaction: %v\", err)\n \t}\n \treturn &Tx{\n@@ -406,7 +457,7 @@ func (tx *Tx) close() {\n \t\tpanic(\"double close\") // internal error\n \t}\n \ttx.done = true\n-\ttx.db.putConn(tx.ci)\n+\ttx.db.putConn(tx.ci, nil)\n \ttx.ci = nil\n \ttx.txi = nil\n }\n@@ -561,9 +612,11 @@ func (tx *Tx) Query(query string, args ...interface{}) (*Rows, error) {\n \t\treturn nil, err\n \t}\n \trows, err := stmt.Query(args...)\n-\tif err == nil {\n-\t\trows.closeStmt = stmt\n+\tif err != nil {\n+\t\tstmt.Close()\n+\t\treturn nil, err\n \t}\n+\trows.closeStmt = stmt\n \treturn rows, err\n }\n \n@@ -609,7 +662,7 @@ func (s *Stmt) Exec(args ...interface{}) (Result, error) {\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\tdefer releaseConn()\n+\tdefer releaseConn(nil)\n \n \t// -1 means the driver doesn't know how to count the number of\n \t// placeholders, so we won't sanity check input here and instead let the\n@@ -672,7 +725,7 @@ func (s *Stmt) Exec(args ...interface{}) (Result, error) {\n // connStmt returns a free driver connection on which to execute the\n // statement, a function to call to release the connection, and a\n // statement bound to that connection.\n-func (s *Stmt) connStmt() (ci driver.Conn, releaseConn func(), si driver.Stmt, err error) {\n+func (s *Stmt) connStmt() (ci driver.Conn, releaseConn func(error), si driver.Stmt, err error) {\n \tif err = s.stickyErr; err != nil {\n \t\treturn\n \t}\n@@ -691,7 +744,7 @@ func (s *Stmt) connStmt() (ci driver.Conn, releaseConn func(), si driver.Stmt, e\n \t\tif err != nil {\n \t\t\treturn\n \t\t}\n-\t\treleaseConn = func() { s.tx.releaseConn() }\n+\t\treleaseConn = func(error) { s.tx.releaseConn() }\n \t\treturn ci, releaseConn, s.txsi, nil\n \t}\n \n@@ -700,7 +753,7 @@ func (s *Stmt) connStmt() (ci driver.Conn, releaseConn func(), si driver.Stmt, e\n \tfor _, v := range s.css {\n \t\t// TODO(bradfitz): lazily clean up entries in this\n \t\t// list with dead conns while enumerating\n-\t\tif _, match = s.db.connIfFree(cs.ci); match {\n+\t\tif _, match = s.db.connIfFree(v.ci); match {\n \t\t\tcs = v\n \t\t\tbreak\n \t\t}\n@@ -710,22 +763,28 @@ func (s *Stmt) connStmt() (ci driver.Conn, releaseConn func(), si driver.Stmt, e\n \t// Make a new conn if all are busy.\n \t// TODO(bradfitz): or wait for one? make configurable later?\n \tif !match {\n-\t\tci, err := s.db.conn()\n-\t\tif err != nil {\n-\t\t\treturn nil, nil, nil, err\n-\t\t}\n-\t\tsi, err := ci.Prepare(s.query)\n-\t\tif err != nil {\n-\t\t\treturn nil, nil, nil, err\n+\t\tfor i := 0; ; i++ {\n+\t\t\tci, err := s.db.conn()\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, nil, nil, err\n+\t\t\t}\n+\t\t\tsi, err := ci.Prepare(s.query)\n+\t\t\tif err == driver.ErrBadConn && i < 10 {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, nil, nil, err\n+\t\t\t}\n+\t\t\ts.mu.Lock()\n+\t\t\tcs = connStmt{ci, si}\n+\t\t\ts.css = append(s.css, cs)\n+\t\t\ts.mu.Unlock()\n+\t\t\tbreak\n \t\t}\n-\t\ts.mu.Lock()\n-\t\tcs = connStmt{ci, si}\n-\t\ts.css = append(s.css, cs)\n-\t\ts.mu.Unlock()\n \t}\n \n \tconn := cs.ci\n-\treleaseConn = func() { s.db.putConn(conn) }\n+\treleaseConn = func(err error) { s.db.putConn(conn, err) }\n \treturn conn, releaseConn, cs.si, nil\n }\n \n@@ -749,7 +808,7 @@ func (s *Stmt) Query(args ...interface{}) (*Rows, error) {\n \t}\n \trowsi, err := si.Query(sargs)\n \tif err != nil {\n-\t\ts.db.putConn(ci)\n+\t\treleaseConn(err)\n \t\treturn nil, err\n \t}\n \t// Note: ownership of ci passes to the *Rows, to be freed\n@@ -800,7 +859,7 @@ func (s *Stmt) Close() error {\n \t\tfor _, v := range s.css {\n \t\t\tif ci, match := s.db.connIfFree(v.ci); match {\n \t\t\t\tv.si.Close()\n-\t\t\t\ts.db.putConn(ci)\n+\t\t\t\ts.db.putConn(ci, nil)\n \t\t\t} else {\n \t\t\t\t// TODO(bradfitz): care that we can't close\n \t\t\t\t// this statement because the statement's\n@@ -827,7 +886,7 @@ func (s *Stmt) Close() error {\n type Rows struct {\n \tdb          *DB\n \tci          driver.Conn // owned; must call putconn when closed to release\n-\treleaseConn func()\n+\treleaseConn func(error)\n \trowsi       driver.Rows\n \n \tclosed    bool\n@@ -939,7 +998,7 @@ func (rs *Rows) Close() error {\n \t}\n \trs.closed = true\n \terr := rs.rowsi.Close()\n-\trs.releaseConn()\n+\trs.releaseConn(err)\n \tif rs.closeStmt != nil {\n \t\trs.closeStmt.Close()\n \t}\n@@ -963,7 +1022,7 @@ func (r *Row) Scan(dest ...interface{}) error {\n \t}\n \n \t// TODO(bradfitz): for now we need to defensively clone all\n-\t// []byte that the driver returned (not permitting \n+\t// []byte that the driver returned (not permitting\n \t// *RawBytes in Rows.Scan), since we're about to close\n \t// the Rows in our defer, when we return from this function.\n \t// the contract with the driver.Next(...) interface is that it"}, {"sha": "b296705865f10c935efe541ae771a41de0beb8a1", "filename": "libgo/go/database/sql/sql_test.go", "status": "modified", "additions": 89, "deletions": 26, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql_test.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -5,13 +5,35 @@\n package sql\n \n import (\n+\t\"database/sql/driver\"\n \t\"fmt\"\n \t\"reflect\"\n+\t\"runtime\"\n \t\"strings\"\n \t\"testing\"\n \t\"time\"\n )\n \n+func init() {\n+\ttype dbConn struct {\n+\t\tdb *DB\n+\t\tc  driver.Conn\n+\t}\n+\tfreedFrom := make(map[dbConn]string)\n+\tputConnHook = func(db *DB, c driver.Conn) {\n+\t\tfor _, oc := range db.freeConn {\n+\t\t\tif oc == c {\n+\t\t\t\t// print before panic, as panic may get lost due to conflicting panic\n+\t\t\t\t// (all goroutines asleep) elsewhere, since we might not unlock\n+\t\t\t\t// the mutex in freeConn here.\n+\t\t\t\tprintln(\"double free of conn. conflicts are:\\nA) \" + freedFrom[dbConn{db, c}] + \"\\n\\nand\\nB) \" + stack())\n+\t\t\t\tpanic(\"double free of conn.\")\n+\t\t\t}\n+\t\t}\n+\t\tfreedFrom[dbConn{db, c}] = stack()\n+\t}\n+}\n+\n const fakeDBName = \"foo\"\n \n var chrisBirthday = time.Unix(123456789, 0)\n@@ -47,9 +69,19 @@ func closeDB(t *testing.T, db *DB) {\n \t}\n }\n \n+// numPrepares assumes that db has exactly 1 idle conn and returns\n+// its count of calls to Prepare\n+func numPrepares(t *testing.T, db *DB) int {\n+\tif n := len(db.freeConn); n != 1 {\n+\t\tt.Fatalf(\"free conns = %d; want 1\", n)\n+\t}\n+\treturn db.freeConn[0].(*fakeConn).numPrepare\n+}\n+\n func TestQuery(t *testing.T) {\n \tdb := newTestDB(t, \"people\")\n \tdefer closeDB(t, db)\n+\tprepares0 := numPrepares(t, db)\n \trows, err := db.Query(\"SELECT|people|age,name|\")\n \tif err != nil {\n \t\tt.Fatalf(\"Query: %v\", err)\n@@ -83,7 +115,10 @@ func TestQuery(t *testing.T) {\n \t// And verify that the final rows.Next() call, which hit EOF,\n \t// also closed the rows connection.\n \tif n := len(db.freeConn); n != 1 {\n-\t\tt.Errorf(\"free conns after query hitting EOF = %d; want 1\", n)\n+\t\tt.Fatalf(\"free conns after query hitting EOF = %d; want 1\", n)\n+\t}\n+\tif prepares := numPrepares(t, db) - prepares0; prepares != 1 {\n+\t\tt.Errorf(\"executed %d Prepare statements; want 1\", prepares)\n \t}\n }\n \n@@ -216,6 +251,7 @@ func TestStatementQueryRow(t *testing.T) {\n \tif err != nil {\n \t\tt.Fatalf(\"Prepare: %v\", err)\n \t}\n+\tdefer stmt.Close()\n \tvar age int\n \tfor n, tt := range []struct {\n \t\tname string\n@@ -256,6 +292,7 @@ func TestExec(t *testing.T) {\n \tif err != nil {\n \t\tt.Errorf(\"Stmt, err = %v, %v\", stmt, err)\n \t}\n+\tdefer stmt.Close()\n \n \ttype execTest struct {\n \t\targs    []interface{}\n@@ -297,11 +334,14 @@ func TestTxStmt(t *testing.T) {\n \tif err != nil {\n \t\tt.Fatalf(\"Stmt, err = %v, %v\", stmt, err)\n \t}\n+\tdefer stmt.Close()\n \ttx, err := db.Begin()\n \tif err != nil {\n \t\tt.Fatalf(\"Begin = %v\", err)\n \t}\n-\t_, err = tx.Stmt(stmt).Exec(\"Bobby\", 7)\n+\ttxs := tx.Stmt(stmt)\n+\tdefer txs.Close()\n+\t_, err = txs.Exec(\"Bobby\", 7)\n \tif err != nil {\n \t\tt.Fatalf(\"Exec = %v\", err)\n \t}\n@@ -330,6 +370,7 @@ func TestTxQuery(t *testing.T) {\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n+\tdefer r.Close()\n \n \tif !r.Next() {\n \t\tif r.Err() != nil {\n@@ -345,6 +386,22 @@ func TestTxQuery(t *testing.T) {\n \t}\n }\n \n+func TestTxQueryInvalid(t *testing.T) {\n+\tdb := newTestDB(t, \"\")\n+\tdefer closeDB(t, db)\n+\n+\ttx, err := db.Begin()\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tdefer tx.Rollback()\n+\n+\t_, err = tx.Query(\"SELECT|t1|name|\")\n+\tif err == nil {\n+\t\tt.Fatal(\"Error expected\")\n+\t}\n+}\n+\n // Tests fix for issue 2542, that we release a lock when querying on\n // a closed connection.\n func TestIssue2542Deadlock(t *testing.T) {\n@@ -450,48 +507,48 @@ type nullTestSpec struct {\n \n func TestNullStringParam(t *testing.T) {\n \tspec := nullTestSpec{\"nullstring\", \"string\", [6]nullTestRow{\n-\t\tnullTestRow{NullString{\"aqua\", true}, \"\", NullString{\"aqua\", true}},\n-\t\tnullTestRow{NullString{\"brown\", false}, \"\", NullString{\"\", false}},\n-\t\tnullTestRow{\"chartreuse\", \"\", NullString{\"chartreuse\", true}},\n-\t\tnullTestRow{NullString{\"darkred\", true}, \"\", NullString{\"darkred\", true}},\n-\t\tnullTestRow{NullString{\"eel\", false}, \"\", NullString{\"\", false}},\n-\t\tnullTestRow{\"foo\", NullString{\"black\", false}, nil},\n+\t\t{NullString{\"aqua\", true}, \"\", NullString{\"aqua\", true}},\n+\t\t{NullString{\"brown\", false}, \"\", NullString{\"\", false}},\n+\t\t{\"chartreuse\", \"\", NullString{\"chartreuse\", true}},\n+\t\t{NullString{\"darkred\", true}, \"\", NullString{\"darkred\", true}},\n+\t\t{NullString{\"eel\", false}, \"\", NullString{\"\", false}},\n+\t\t{\"foo\", NullString{\"black\", false}, nil},\n \t}}\n \tnullTestRun(t, spec)\n }\n \n func TestNullInt64Param(t *testing.T) {\n \tspec := nullTestSpec{\"nullint64\", \"int64\", [6]nullTestRow{\n-\t\tnullTestRow{NullInt64{31, true}, 1, NullInt64{31, true}},\n-\t\tnullTestRow{NullInt64{-22, false}, 1, NullInt64{0, false}},\n-\t\tnullTestRow{22, 1, NullInt64{22, true}},\n-\t\tnullTestRow{NullInt64{33, true}, 1, NullInt64{33, true}},\n-\t\tnullTestRow{NullInt64{222, false}, 1, NullInt64{0, false}},\n-\t\tnullTestRow{0, NullInt64{31, false}, nil},\n+\t\t{NullInt64{31, true}, 1, NullInt64{31, true}},\n+\t\t{NullInt64{-22, false}, 1, NullInt64{0, false}},\n+\t\t{22, 1, NullInt64{22, true}},\n+\t\t{NullInt64{33, true}, 1, NullInt64{33, true}},\n+\t\t{NullInt64{222, false}, 1, NullInt64{0, false}},\n+\t\t{0, NullInt64{31, false}, nil},\n \t}}\n \tnullTestRun(t, spec)\n }\n \n func TestNullFloat64Param(t *testing.T) {\n \tspec := nullTestSpec{\"nullfloat64\", \"float64\", [6]nullTestRow{\n-\t\tnullTestRow{NullFloat64{31.2, true}, 1, NullFloat64{31.2, true}},\n-\t\tnullTestRow{NullFloat64{13.1, false}, 1, NullFloat64{0, false}},\n-\t\tnullTestRow{-22.9, 1, NullFloat64{-22.9, true}},\n-\t\tnullTestRow{NullFloat64{33.81, true}, 1, NullFloat64{33.81, true}},\n-\t\tnullTestRow{NullFloat64{222, false}, 1, NullFloat64{0, false}},\n-\t\tnullTestRow{10, NullFloat64{31.2, false}, nil},\n+\t\t{NullFloat64{31.2, true}, 1, NullFloat64{31.2, true}},\n+\t\t{NullFloat64{13.1, false}, 1, NullFloat64{0, false}},\n+\t\t{-22.9, 1, NullFloat64{-22.9, true}},\n+\t\t{NullFloat64{33.81, true}, 1, NullFloat64{33.81, true}},\n+\t\t{NullFloat64{222, false}, 1, NullFloat64{0, false}},\n+\t\t{10, NullFloat64{31.2, false}, nil},\n \t}}\n \tnullTestRun(t, spec)\n }\n \n func TestNullBoolParam(t *testing.T) {\n \tspec := nullTestSpec{\"nullbool\", \"bool\", [6]nullTestRow{\n-\t\tnullTestRow{NullBool{false, true}, true, NullBool{false, true}},\n-\t\tnullTestRow{NullBool{true, false}, false, NullBool{false, false}},\n-\t\tnullTestRow{true, true, NullBool{true, true}},\n-\t\tnullTestRow{NullBool{true, true}, false, NullBool{true, true}},\n-\t\tnullTestRow{NullBool{true, false}, true, NullBool{false, false}},\n-\t\tnullTestRow{true, NullBool{true, false}, nil},\n+\t\t{NullBool{false, true}, true, NullBool{false, true}},\n+\t\t{NullBool{true, false}, false, NullBool{false, false}},\n+\t\t{true, true, NullBool{true, true}},\n+\t\t{NullBool{true, true}, false, NullBool{true, true}},\n+\t\t{NullBool{true, false}, true, NullBool{false, false}},\n+\t\t{true, NullBool{true, false}, nil},\n \t}}\n \tnullTestRun(t, spec)\n }\n@@ -510,6 +567,7 @@ func nullTestRun(t *testing.T, spec nullTestSpec) {\n \tif err != nil {\n \t\tt.Fatalf(\"prepare: %v\", err)\n \t}\n+\tdefer stmt.Close()\n \tif _, err := stmt.Exec(3, \"chris\", spec.rows[2].nullParam, spec.rows[2].notNullParam); err != nil {\n \t\tt.Errorf(\"exec insert chris: %v\", err)\n \t}\n@@ -549,3 +607,8 @@ func nullTestRun(t *testing.T, spec nullTestSpec) {\n \t\t}\n \t}\n }\n+\n+func stack() string {\n+\tbuf := make([]byte, 1024)\n+\treturn string(buf[:runtime.Stack(buf, false)])\n+}"}, {"sha": "3bf81a68cf4f73fdf043252ed9cc1c1f1eefa55c", "filename": "libgo/go/encoding/asn1/asn1.go", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fencoding%2Fasn1%2Fasn1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fencoding%2Fasn1%2Fasn1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fasn1%2Fasn1.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -250,10 +250,14 @@ func parseBase128Int(bytes []byte, initOffset int) (ret, offset int, err error)\n func parseUTCTime(bytes []byte) (ret time.Time, err error) {\n \ts := string(bytes)\n \tret, err = time.Parse(\"0601021504Z0700\", s)\n-\tif err == nil {\n-\t\treturn\n+\tif err != nil {\n+\t\tret, err = time.Parse(\"060102150405Z0700\", s)\n \t}\n-\tret, err = time.Parse(\"060102150405Z0700\", s)\n+\tif err == nil && ret.Year() >= 2050 {\n+\t\t// UTCTime only encodes times prior to 2050. See https://tools.ietf.org/html/rfc5280#section-4.1.2.5.1\n+\t\tret = ret.AddDate(-100, 0, 0)\n+\t}\n+\n \treturn\n }\n "}, {"sha": "93803f43532938bf27894d714651646b04236498", "filename": "libgo/go/encoding/asn1/asn1_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fencoding%2Fasn1%2Fasn1_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fencoding%2Fasn1%2Fasn1_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fasn1%2Fasn1_test.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -321,7 +321,7 @@ var parseFieldParametersTestData []parseFieldParametersTest = []parseFieldParame\n \t{\"default:42\", fieldParameters{defaultValue: newInt64(42)}},\n \t{\"tag:17\", fieldParameters{tag: newInt(17)}},\n \t{\"optional,explicit,default:42,tag:17\", fieldParameters{optional: true, explicit: true, defaultValue: newInt64(42), tag: newInt(17)}},\n-\t{\"optional,explicit,default:42,tag:17,rubbish1\", fieldParameters{true, true, false, newInt64(42), newInt(17), 0, false}},\n+\t{\"optional,explicit,default:42,tag:17,rubbish1\", fieldParameters{true, true, false, newInt64(42), newInt(17), 0, false, false}},\n \t{\"set\", fieldParameters{set: true}},\n }\n "}, {"sha": "03856bc55c5ab41e3e95a0686c5ff314d0e160e6", "filename": "libgo/go/encoding/asn1/common.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fencoding%2Fasn1%2Fcommon.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fencoding%2Fasn1%2Fcommon.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fasn1%2Fcommon.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -75,6 +75,7 @@ type fieldParameters struct {\n \ttag          *int   // the EXPLICIT or IMPLICIT tag (maybe nil).\n \tstringType   int    // the string tag to use when marshaling.\n \tset          bool   // true iff this should be encoded as a SET\n+\tomitEmpty    bool   // true iff this should be omitted if empty when marshaling.\n \n \t// Invariants:\n \t//   if explicit is set, tag is non-nil.\n@@ -116,6 +117,8 @@ func parseFieldParameters(str string) (ret fieldParameters) {\n \t\t\tif ret.tag == nil {\n \t\t\t\tret.tag = new(int)\n \t\t\t}\n+\t\tcase part == \"omitempty\":\n+\t\t\tret.omitEmpty = true\n \t\t}\n \t}\n \treturn"}, {"sha": "163bca575de1c0e6dca78f3883cc9ff6119e7f72", "filename": "libgo/go/encoding/asn1/marshal.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fencoding%2Fasn1%2Fmarshal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fencoding%2Fasn1%2Fmarshal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fasn1%2Fmarshal.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -463,6 +463,10 @@ func marshalField(out *forkableWriter, v reflect.Value, params fieldParameters)\n \t\treturn marshalField(out, v.Elem(), params)\n \t}\n \n+\tif v.Kind() == reflect.Slice && v.Len() == 0 && params.omitEmpty {\n+\t\treturn\n+\t}\n+\n \tif params.optional && reflect.DeepEqual(v.Interface(), reflect.Zero(v.Type()).Interface()) {\n \t\treturn\n \t}"}, {"sha": "f43bcae681a503bdf674ce971a2f9c590baa25ff", "filename": "libgo/go/encoding/asn1/marshal_test.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fencoding%2Fasn1%2Fmarshal_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fencoding%2Fasn1%2Fmarshal_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fasn1%2Fmarshal_test.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -54,6 +54,10 @@ type optionalRawValueTest struct {\n \tA RawValue `asn1:\"optional\"`\n }\n \n+type omitEmptyTest struct {\n+\tA []string `asn1:\"omitempty\"`\n+}\n+\n type testSET []int\n \n var PST = time.FixedZone(\"PST\", -8*60*60)\n@@ -116,6 +120,8 @@ var marshalTests = []marshalTest{\n \t{rawContentsStruct{[]byte{0x30, 3, 1, 2, 3}, 64}, \"3003010203\"},\n \t{RawValue{Tag: 1, Class: 2, IsCompound: false, Bytes: []byte{1, 2, 3}}, \"8103010203\"},\n \t{testSET([]int{10}), \"310302010a\"},\n+\t{omitEmptyTest{[]string{}}, \"3000\"},\n+\t{omitEmptyTest{[]string{\"1\"}}, \"30053003130131\"},\n }\n \n func TestMarshal(t *testing.T) {"}, {"sha": "712e490e6563088d1d3b03bc0f97032d88e394e6", "filename": "libgo/go/encoding/binary/binary.go", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -2,12 +2,17 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// Package binary implements translation between\n-// unsigned integer values and byte sequences\n-// and the reading and writing of fixed-size values.\n+// Package binary implements translation between numbers and byte sequences\n+// and encoding and decoding of varints.\n+//\n+// Numbers are translated by reading and writing fixed-size values.\n // A fixed-size value is either a fixed-size arithmetic\n // type (int8, uint8, int16, float32, complex64, ...)\n // or an array or struct containing only fixed-size values.\n+//\n+// Varints are a method of encoding integers using one or more bytes;\n+// numbers with smaller absolute value take a smaller number of bytes.\n+// For a specification, see http://code.google.com/apis/protocolbuffers/docs/encoding.html.\n package binary\n \n import ("}, {"sha": "db4d988526f0623165d380c398a85888d528e269", "filename": "libgo/go/encoding/csv/reader.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fencoding%2Fcsv%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fencoding%2Fcsv%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fcsv%2Freader.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -92,7 +92,8 @@ var (\n // If FieldsPerRecord is positive, Read requires each record to\n // have the given number of fields.  If FieldsPerRecord is 0, Read sets it to\n // the number of fields in the first record, so that future records must\n-// have the same field count.\n+// have the same field count.  If FieldsPerRecord is negative, no check is\n+// made and records may have a variable number of fields.\n //\n // If LazyQuotes is true, a quote may appear in an unquoted field and a\n // non-doubled quote may appear in a quoted field."}, {"sha": "e32a178aba396fe2d0cc89d1f746abbb886bf01a", "filename": "libgo/go/encoding/gob/decode.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fencoding%2Fgob%2Fdecode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fencoding%2Fgob%2Fdecode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fdecode.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -707,6 +707,9 @@ func (dec *Decoder) decodeInterface(ityp reflect.Type, state *decoderState, p ui\n \tif name == \"\" {\n \t\t// Copy the representation of the nil interface value to the target.\n \t\t// This is horribly unsafe and special.\n+\t\tif indir > 0 {\n+\t\t\tp = allocate(ityp, p, 1) // All but the last level has been allocated by dec.Indirect\n+\t\t}\n \t\t*(*[2]uintptr)(unsafe.Pointer(p)) = ivalue.InterfaceData()\n \t\treturn\n \t}"}, {"sha": "c4947cbb8d312da0bc98cfc39144d1725d59967a", "filename": "libgo/go/encoding/gob/encoder_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fencoding%2Fgob%2Fencoder_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fencoding%2Fgob%2Fencoder_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fencoder_test.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -694,8 +694,8 @@ type Bug3 struct {\n \n func TestGobPtrSlices(t *testing.T) {\n \tin := []*Bug3{\n-\t\t&Bug3{1, nil},\n-\t\t&Bug3{2, nil},\n+\t\t{1, nil},\n+\t\t{2, nil},\n \t}\n \tb := new(bytes.Buffer)\n \terr := NewEncoder(b).Encode(&in)"}, {"sha": "45240d764dcf474e19effb8bc8670ba740c6b590", "filename": "libgo/go/encoding/gob/gobencdec_test.go", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fencoding%2Fgob%2Fgobencdec_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fencoding%2Fgob%2Fgobencdec_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fgobencdec_test.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -573,3 +573,22 @@ func TestGobEncodeIsZero(t *testing.T) {\n \t\tt.Fatalf(\"%v != %v\", x, y)\n \t}\n }\n+\n+func TestGobEncodePtrError(t *testing.T) {\n+\tvar err error\n+\tb := new(bytes.Buffer)\n+\tenc := NewEncoder(b)\n+\terr = enc.Encode(&err)\n+\tif err != nil {\n+\t\tt.Fatal(\"encode:\", err)\n+\t}\n+\tdec := NewDecoder(b)\n+\terr2 := fmt.Errorf(\"foo\")\n+\terr = dec.Decode(&err2)\n+\tif err != nil {\n+\t\tt.Fatal(\"decode:\", err)\n+\t}\n+\tif err2 != nil {\n+\t\tt.Fatalf(\"expected nil, got %v\", err2)\n+\t}\n+}"}, {"sha": "edbafcf65f1fa6d78e6e54b49040fe049c43d7c7", "filename": "libgo/go/encoding/json/encode.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fencoding%2Fjson%2Fencode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fencoding%2Fjson%2Fencode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fencode.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -43,7 +43,8 @@ import (\n // to keep some browsers from misinterpreting JSON output as HTML.\n //\n // Array and slice values encode as JSON arrays, except that\n-// []byte encodes as a base64-encoded string.\n+// []byte encodes as a base64-encoded string, and a nil slice\n+// encodes as the null JSON object.\n //\n // Struct values encode as JSON objects. Each exported struct field\n // becomes a member of the object unless"}, {"sha": "1deedc949c2d88758c1c8123598c6a1fb016cb40", "filename": "libgo/go/exp/norm/maketables.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fexp%2Fnorm%2Fmaketables.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fexp%2Fnorm%2Fmaketables.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fmaketables.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -577,7 +577,7 @@ type decompSet [4]map[string]bool\n \n func makeDecompSet() decompSet {\n \tm := decompSet{}\n-\tfor i, _ := range m {\n+\tfor i := range m {\n \t\tm[i] = make(map[string]bool)\n \t}\n \treturn m\n@@ -646,7 +646,7 @@ func printCharInfoTables() int {\n \tfmt.Println(\"const (\")\n \tfor i, m := range decompSet {\n \t\tsa := []string{}\n-\t\tfor s, _ := range m {\n+\t\tfor s := range m {\n \t\t\tsa = append(sa, s)\n \t\t}\n \t\tsort.Strings(sa)"}, {"sha": "3b79873fa2bda394dda1456f83c074cbae980030", "filename": "libgo/go/exp/wingui/gui.go", "status": "removed", "additions": 0, "deletions": 155, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0be8a5c203451b47fd3da59b0e0f56cc3d42f22/libgo%2Fgo%2Fexp%2Fwingui%2Fgui.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0be8a5c203451b47fd3da59b0e0f56cc3d42f22/libgo%2Fgo%2Fexp%2Fwingui%2Fgui.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fwingui%2Fgui.go?ref=e0be8a5c203451b47fd3da59b0e0f56cc3d42f22", "patch": "@@ -1,155 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build windows\n-\n-package main\n-\n-import (\n-\t\"fmt\"\n-\t\"os\"\n-\t\"syscall\"\n-\t\"unsafe\"\n-)\n-\n-// some help functions\n-\n-func abortf(format string, a ...interface{}) {\n-\tfmt.Fprintf(os.Stdout, format, a...)\n-\tos.Exit(1)\n-}\n-\n-func abortErrNo(funcname string, err error) {\n-\terrno, _ := err.(syscall.Errno)\n-\tabortf(\"%s failed: %d %s\\n\", funcname, uint32(errno), err)\n-}\n-\n-// global vars\n-\n-var (\n-\tmh syscall.Handle\n-\tbh syscall.Handle\n-)\n-\n-// WinProc called by windows to notify us of all windows events we might be interested in.\n-func WndProc(hwnd syscall.Handle, msg uint32, wparam, lparam uintptr) (rc uintptr) {\n-\tswitch msg {\n-\tcase WM_CREATE:\n-\t\tvar e error\n-\t\t// CreateWindowEx\n-\t\tbh, e = CreateWindowEx(\n-\t\t\t0,\n-\t\t\tsyscall.StringToUTF16Ptr(\"button\"),\n-\t\t\tsyscall.StringToUTF16Ptr(\"Quit\"),\n-\t\t\tWS_CHILD|WS_VISIBLE|BS_DEFPUSHBUTTON,\n-\t\t\t75, 70, 140, 25,\n-\t\t\thwnd, 1, mh, 0)\n-\t\tif e != nil {\n-\t\t\tabortErrNo(\"CreateWindowEx\", e)\n-\t\t}\n-\t\tfmt.Printf(\"button handle is %x\\n\", bh)\n-\t\trc = DefWindowProc(hwnd, msg, wparam, lparam)\n-\tcase WM_COMMAND:\n-\t\tswitch syscall.Handle(lparam) {\n-\t\tcase bh:\n-\t\t\te := PostMessage(hwnd, WM_CLOSE, 0, 0)\n-\t\t\tif e != nil {\n-\t\t\t\tabortErrNo(\"PostMessage\", e)\n-\t\t\t}\n-\t\tdefault:\n-\t\t\trc = DefWindowProc(hwnd, msg, wparam, lparam)\n-\t\t}\n-\tcase WM_CLOSE:\n-\t\tDestroyWindow(hwnd)\n-\tcase WM_DESTROY:\n-\t\tPostQuitMessage(0)\n-\tdefault:\n-\t\trc = DefWindowProc(hwnd, msg, wparam, lparam)\n-\t}\n-\t//fmt.Printf(\"WndProc(0x%08x, %d, 0x%08x, 0x%08x) (%d)\\n\", hwnd, msg, wparam, lparam, rc)\n-\treturn\n-}\n-\n-func rungui() int {\n-\tvar e error\n-\n-\t// GetModuleHandle\n-\tmh, e = GetModuleHandle(nil)\n-\tif e != nil {\n-\t\tabortErrNo(\"GetModuleHandle\", e)\n-\t}\n-\n-\t// Get icon we're going to use.\n-\tmyicon, e := LoadIcon(0, IDI_APPLICATION)\n-\tif e != nil {\n-\t\tabortErrNo(\"LoadIcon\", e)\n-\t}\n-\n-\t// Get cursor we're going to use.\n-\tmycursor, e := LoadCursor(0, IDC_ARROW)\n-\tif e != nil {\n-\t\tabortErrNo(\"LoadCursor\", e)\n-\t}\n-\n-\t// Create callback\n-\twproc := syscall.NewCallback(WndProc)\n-\n-\t// RegisterClassEx\n-\twcname := syscall.StringToUTF16Ptr(\"myWindowClass\")\n-\tvar wc Wndclassex\n-\twc.Size = uint32(unsafe.Sizeof(wc))\n-\twc.WndProc = wproc\n-\twc.Instance = mh\n-\twc.Icon = myicon\n-\twc.Cursor = mycursor\n-\twc.Background = COLOR_BTNFACE + 1\n-\twc.MenuName = nil\n-\twc.ClassName = wcname\n-\twc.IconSm = myicon\n-\tif _, e := RegisterClassEx(&wc); e != nil {\n-\t\tabortErrNo(\"RegisterClassEx\", e)\n-\t}\n-\n-\t// CreateWindowEx\n-\twh, e := CreateWindowEx(\n-\t\tWS_EX_CLIENTEDGE,\n-\t\twcname,\n-\t\tsyscall.StringToUTF16Ptr(\"My window\"),\n-\t\tWS_OVERLAPPEDWINDOW,\n-\t\tCW_USEDEFAULT, CW_USEDEFAULT, 300, 200,\n-\t\t0, 0, mh, 0)\n-\tif e != nil {\n-\t\tabortErrNo(\"CreateWindowEx\", e)\n-\t}\n-\tfmt.Printf(\"main window handle is %x\\n\", wh)\n-\n-\t// ShowWindow\n-\tShowWindow(wh, SW_SHOWDEFAULT)\n-\n-\t// UpdateWindow\n-\tif e := UpdateWindow(wh); e != nil {\n-\t\tabortErrNo(\"UpdateWindow\", e)\n-\t}\n-\n-\t// Process all windows messages until WM_QUIT.\n-\tvar m Msg\n-\tfor {\n-\t\tr, e := GetMessage(&m, 0, 0, 0)\n-\t\tif e != nil {\n-\t\t\tabortErrNo(\"GetMessage\", e)\n-\t\t}\n-\t\tif r == 0 {\n-\t\t\t// WM_QUIT received -> get out\n-\t\t\tbreak\n-\t\t}\n-\t\tTranslateMessage(&m)\n-\t\tDispatchMessage(&m)\n-\t}\n-\treturn int(m.Wparam)\n-}\n-\n-func main() {\n-\trc := rungui()\n-\tos.Exit(rc)\n-}"}, {"sha": "f876088e91fc893dac2ea6b634301358aad0fbf6", "filename": "libgo/go/exp/wingui/winapi.go", "status": "removed", "additions": 0, "deletions": 134, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0be8a5c203451b47fd3da59b0e0f56cc3d42f22/libgo%2Fgo%2Fexp%2Fwingui%2Fwinapi.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0be8a5c203451b47fd3da59b0e0f56cc3d42f22/libgo%2Fgo%2Fexp%2Fwingui%2Fwinapi.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fwingui%2Fwinapi.go?ref=e0be8a5c203451b47fd3da59b0e0f56cc3d42f22", "patch": "@@ -1,134 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build windows\n-\n-package main\n-\n-import (\n-\t\"syscall\"\n-\t\"unsafe\"\n-)\n-\n-type Wndclassex struct {\n-\tSize       uint32\n-\tStyle      uint32\n-\tWndProc    uintptr\n-\tClsExtra   int32\n-\tWndExtra   int32\n-\tInstance   syscall.Handle\n-\tIcon       syscall.Handle\n-\tCursor     syscall.Handle\n-\tBackground syscall.Handle\n-\tMenuName   *uint16\n-\tClassName  *uint16\n-\tIconSm     syscall.Handle\n-}\n-\n-type Point struct {\n-\tX uintptr\n-\tY uintptr\n-}\n-\n-type Msg struct {\n-\tHwnd    syscall.Handle\n-\tMessage uint32\n-\tWparam  uintptr\n-\tLparam  uintptr\n-\tTime    uint32\n-\tPt      Point\n-}\n-\n-const (\n-\t// Window styles\n-\tWS_OVERLAPPED   = 0\n-\tWS_POPUP        = 0x80000000\n-\tWS_CHILD        = 0x40000000\n-\tWS_MINIMIZE     = 0x20000000\n-\tWS_VISIBLE      = 0x10000000\n-\tWS_DISABLED     = 0x8000000\n-\tWS_CLIPSIBLINGS = 0x4000000\n-\tWS_CLIPCHILDREN = 0x2000000\n-\tWS_MAXIMIZE     = 0x1000000\n-\tWS_CAPTION      = WS_BORDER | WS_DLGFRAME\n-\tWS_BORDER       = 0x800000\n-\tWS_DLGFRAME     = 0x400000\n-\tWS_VSCROLL      = 0x200000\n-\tWS_HSCROLL      = 0x100000\n-\tWS_SYSMENU      = 0x80000\n-\tWS_THICKFRAME   = 0x40000\n-\tWS_GROUP        = 0x20000\n-\tWS_TABSTOP      = 0x10000\n-\tWS_MINIMIZEBOX  = 0x20000\n-\tWS_MAXIMIZEBOX  = 0x10000\n-\tWS_TILED        = WS_OVERLAPPED\n-\tWS_ICONIC       = WS_MINIMIZE\n-\tWS_SIZEBOX      = WS_THICKFRAME\n-\t// Common Window Styles\n-\tWS_OVERLAPPEDWINDOW = WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX\n-\tWS_TILEDWINDOW      = WS_OVERLAPPEDWINDOW\n-\tWS_POPUPWINDOW      = WS_POPUP | WS_BORDER | WS_SYSMENU\n-\tWS_CHILDWINDOW      = WS_CHILD\n-\n-\tWS_EX_CLIENTEDGE = 0x200\n-\n-\t// Some windows messages\n-\tWM_CREATE  = 1\n-\tWM_DESTROY = 2\n-\tWM_CLOSE   = 16\n-\tWM_COMMAND = 273\n-\n-\t// Some button control styles\n-\tBS_DEFPUSHBUTTON = 1\n-\n-\t// Some color constants\n-\tCOLOR_WINDOW  = 5\n-\tCOLOR_BTNFACE = 15\n-\n-\t// Default window position\n-\tCW_USEDEFAULT = 0x80000000 - 0x100000000\n-\n-\t// Show window default style\n-\tSW_SHOWDEFAULT = 10\n-)\n-\n-var (\n-\t// Some globally known cursors\n-\tIDC_ARROW = MakeIntResource(32512)\n-\tIDC_IBEAM = MakeIntResource(32513)\n-\tIDC_WAIT  = MakeIntResource(32514)\n-\tIDC_CROSS = MakeIntResource(32515)\n-\n-\t// Some globally known icons\n-\tIDI_APPLICATION = MakeIntResource(32512)\n-\tIDI_HAND        = MakeIntResource(32513)\n-\tIDI_QUESTION    = MakeIntResource(32514)\n-\tIDI_EXCLAMATION = MakeIntResource(32515)\n-\tIDI_ASTERISK    = MakeIntResource(32516)\n-\tIDI_WINLOGO     = MakeIntResource(32517)\n-\tIDI_WARNING     = IDI_EXCLAMATION\n-\tIDI_ERROR       = IDI_HAND\n-\tIDI_INFORMATION = IDI_ASTERISK\n-)\n-\n-//sys\tGetModuleHandle(modname *uint16) (handle syscall.Handle, err error) = GetModuleHandleW\n-//sys\tRegisterClassEx(wndclass *Wndclassex) (atom uint16, err error) = user32.RegisterClassExW\n-//sys\tCreateWindowEx(exstyle uint32, classname *uint16, windowname *uint16, style uint32, x int32, y int32, width int32, height int32, wndparent syscall.Handle, menu syscall.Handle, instance syscall.Handle, param uintptr) (hwnd syscall.Handle, err error) = user32.CreateWindowExW\n-//sys\tDefWindowProc(hwnd syscall.Handle, msg uint32, wparam uintptr, lparam uintptr) (lresult uintptr) = user32.DefWindowProcW\n-//sys\tDestroyWindow(hwnd syscall.Handle) (err error) = user32.DestroyWindow\n-//sys\tPostQuitMessage(exitcode int32) = user32.PostQuitMessage\n-//sys\tShowWindow(hwnd syscall.Handle, cmdshow int32) (wasvisible bool) = user32.ShowWindow\n-//sys\tUpdateWindow(hwnd syscall.Handle) (err error) = user32.UpdateWindow\n-//sys\tGetMessage(msg *Msg, hwnd syscall.Handle, MsgFilterMin uint32, MsgFilterMax uint32) (ret int32, err error) [failretval==-1] = user32.GetMessageW\n-//sys\tTranslateMessage(msg *Msg) (done bool) = user32.TranslateMessage\n-//sys\tDispatchMessage(msg *Msg) (ret int32) = user32.DispatchMessageW\n-//sys\tLoadIcon(instance syscall.Handle, iconname *uint16) (icon syscall.Handle, err error) = user32.LoadIconW\n-//sys\tLoadCursor(instance syscall.Handle, cursorname *uint16) (cursor syscall.Handle, err error) = user32.LoadCursorW\n-//sys\tSetCursor(cursor syscall.Handle) (precursor syscall.Handle, err error) = user32.SetCursor\n-//sys\tSendMessage(hwnd syscall.Handle, msg uint32, wparam uintptr, lparam uintptr) (lresult uintptr) = user32.SendMessageW\n-//sys\tPostMessage(hwnd syscall.Handle, msg uint32, wparam uintptr, lparam uintptr) (err error) = user32.PostMessageW\n-\n-func MakeIntResource(id uint16) *uint16 {\n-\treturn (*uint16)(unsafe.Pointer(uintptr(id)))\n-}"}, {"sha": "5666c6de5308f95d424ea21f8f5fb2999e4e150b", "filename": "libgo/go/exp/wingui/zwinapi.go", "status": "removed", "additions": 0, "deletions": 192, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0be8a5c203451b47fd3da59b0e0f56cc3d42f22/libgo%2Fgo%2Fexp%2Fwingui%2Fzwinapi.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0be8a5c203451b47fd3da59b0e0f56cc3d42f22/libgo%2Fgo%2Fexp%2Fwingui%2Fzwinapi.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fwingui%2Fzwinapi.go?ref=e0be8a5c203451b47fd3da59b0e0f56cc3d42f22", "patch": "@@ -1,192 +0,0 @@\n-// +build windows\n-// mksyscall_windows.pl winapi.go\n-// MACHINE GENERATED BY THE COMMAND ABOVE; DO NOT EDIT\n-\n-package main\n-\n-import \"unsafe\"\n-import \"syscall\"\n-\n-var (\n-\tmodkernel32 = syscall.NewLazyDLL(\"kernel32.dll\")\n-\tmoduser32   = syscall.NewLazyDLL(\"user32.dll\")\n-\n-\tprocGetModuleHandleW = modkernel32.NewProc(\"GetModuleHandleW\")\n-\tprocRegisterClassExW = moduser32.NewProc(\"RegisterClassExW\")\n-\tprocCreateWindowExW  = moduser32.NewProc(\"CreateWindowExW\")\n-\tprocDefWindowProcW   = moduser32.NewProc(\"DefWindowProcW\")\n-\tprocDestroyWindow    = moduser32.NewProc(\"DestroyWindow\")\n-\tprocPostQuitMessage  = moduser32.NewProc(\"PostQuitMessage\")\n-\tprocShowWindow       = moduser32.NewProc(\"ShowWindow\")\n-\tprocUpdateWindow     = moduser32.NewProc(\"UpdateWindow\")\n-\tprocGetMessageW      = moduser32.NewProc(\"GetMessageW\")\n-\tprocTranslateMessage = moduser32.NewProc(\"TranslateMessage\")\n-\tprocDispatchMessageW = moduser32.NewProc(\"DispatchMessageW\")\n-\tprocLoadIconW        = moduser32.NewProc(\"LoadIconW\")\n-\tprocLoadCursorW      = moduser32.NewProc(\"LoadCursorW\")\n-\tprocSetCursor        = moduser32.NewProc(\"SetCursor\")\n-\tprocSendMessageW     = moduser32.NewProc(\"SendMessageW\")\n-\tprocPostMessageW     = moduser32.NewProc(\"PostMessageW\")\n-)\n-\n-func GetModuleHandle(modname *uint16) (handle syscall.Handle, err error) {\n-\tr0, _, e1 := syscall.Syscall(procGetModuleHandleW.Addr(), 1, uintptr(unsafe.Pointer(modname)), 0, 0)\n-\thandle = syscall.Handle(r0)\n-\tif handle == 0 {\n-\t\tif e1 != 0 {\n-\t\t\terr = error(e1)\n-\t\t} else {\n-\t\t\terr = syscall.EINVAL\n-\t\t}\n-\t}\n-\treturn\n-}\n-\n-func RegisterClassEx(wndclass *Wndclassex) (atom uint16, err error) {\n-\tr0, _, e1 := syscall.Syscall(procRegisterClassExW.Addr(), 1, uintptr(unsafe.Pointer(wndclass)), 0, 0)\n-\tatom = uint16(r0)\n-\tif atom == 0 {\n-\t\tif e1 != 0 {\n-\t\t\terr = error(e1)\n-\t\t} else {\n-\t\t\terr = syscall.EINVAL\n-\t\t}\n-\t}\n-\treturn\n-}\n-\n-func CreateWindowEx(exstyle uint32, classname *uint16, windowname *uint16, style uint32, x int32, y int32, width int32, height int32, wndparent syscall.Handle, menu syscall.Handle, instance syscall.Handle, param uintptr) (hwnd syscall.Handle, err error) {\n-\tr0, _, e1 := syscall.Syscall12(procCreateWindowExW.Addr(), 12, uintptr(exstyle), uintptr(unsafe.Pointer(classname)), uintptr(unsafe.Pointer(windowname)), uintptr(style), uintptr(x), uintptr(y), uintptr(width), uintptr(height), uintptr(wndparent), uintptr(menu), uintptr(instance), uintptr(param))\n-\thwnd = syscall.Handle(r0)\n-\tif hwnd == 0 {\n-\t\tif e1 != 0 {\n-\t\t\terr = error(e1)\n-\t\t} else {\n-\t\t\terr = syscall.EINVAL\n-\t\t}\n-\t}\n-\treturn\n-}\n-\n-func DefWindowProc(hwnd syscall.Handle, msg uint32, wparam uintptr, lparam uintptr) (lresult uintptr) {\n-\tr0, _, _ := syscall.Syscall6(procDefWindowProcW.Addr(), 4, uintptr(hwnd), uintptr(msg), uintptr(wparam), uintptr(lparam), 0, 0)\n-\tlresult = uintptr(r0)\n-\treturn\n-}\n-\n-func DestroyWindow(hwnd syscall.Handle) (err error) {\n-\tr1, _, e1 := syscall.Syscall(procDestroyWindow.Addr(), 1, uintptr(hwnd), 0, 0)\n-\tif int(r1) == 0 {\n-\t\tif e1 != 0 {\n-\t\t\terr = error(e1)\n-\t\t} else {\n-\t\t\terr = syscall.EINVAL\n-\t\t}\n-\t}\n-\treturn\n-}\n-\n-func PostQuitMessage(exitcode int32) {\n-\tsyscall.Syscall(procPostQuitMessage.Addr(), 1, uintptr(exitcode), 0, 0)\n-\treturn\n-}\n-\n-func ShowWindow(hwnd syscall.Handle, cmdshow int32) (wasvisible bool) {\n-\tr0, _, _ := syscall.Syscall(procShowWindow.Addr(), 2, uintptr(hwnd), uintptr(cmdshow), 0)\n-\twasvisible = bool(r0 != 0)\n-\treturn\n-}\n-\n-func UpdateWindow(hwnd syscall.Handle) (err error) {\n-\tr1, _, e1 := syscall.Syscall(procUpdateWindow.Addr(), 1, uintptr(hwnd), 0, 0)\n-\tif int(r1) == 0 {\n-\t\tif e1 != 0 {\n-\t\t\terr = error(e1)\n-\t\t} else {\n-\t\t\terr = syscall.EINVAL\n-\t\t}\n-\t}\n-\treturn\n-}\n-\n-func GetMessage(msg *Msg, hwnd syscall.Handle, MsgFilterMin uint32, MsgFilterMax uint32) (ret int32, err error) {\n-\tr0, _, e1 := syscall.Syscall6(procGetMessageW.Addr(), 4, uintptr(unsafe.Pointer(msg)), uintptr(hwnd), uintptr(MsgFilterMin), uintptr(MsgFilterMax), 0, 0)\n-\tret = int32(r0)\n-\tif ret == -1 {\n-\t\tif e1 != 0 {\n-\t\t\terr = error(e1)\n-\t\t} else {\n-\t\t\terr = syscall.EINVAL\n-\t\t}\n-\t}\n-\treturn\n-}\n-\n-func TranslateMessage(msg *Msg) (done bool) {\n-\tr0, _, _ := syscall.Syscall(procTranslateMessage.Addr(), 1, uintptr(unsafe.Pointer(msg)), 0, 0)\n-\tdone = bool(r0 != 0)\n-\treturn\n-}\n-\n-func DispatchMessage(msg *Msg) (ret int32) {\n-\tr0, _, _ := syscall.Syscall(procDispatchMessageW.Addr(), 1, uintptr(unsafe.Pointer(msg)), 0, 0)\n-\tret = int32(r0)\n-\treturn\n-}\n-\n-func LoadIcon(instance syscall.Handle, iconname *uint16) (icon syscall.Handle, err error) {\n-\tr0, _, e1 := syscall.Syscall(procLoadIconW.Addr(), 2, uintptr(instance), uintptr(unsafe.Pointer(iconname)), 0)\n-\ticon = syscall.Handle(r0)\n-\tif icon == 0 {\n-\t\tif e1 != 0 {\n-\t\t\terr = error(e1)\n-\t\t} else {\n-\t\t\terr = syscall.EINVAL\n-\t\t}\n-\t}\n-\treturn\n-}\n-\n-func LoadCursor(instance syscall.Handle, cursorname *uint16) (cursor syscall.Handle, err error) {\n-\tr0, _, e1 := syscall.Syscall(procLoadCursorW.Addr(), 2, uintptr(instance), uintptr(unsafe.Pointer(cursorname)), 0)\n-\tcursor = syscall.Handle(r0)\n-\tif cursor == 0 {\n-\t\tif e1 != 0 {\n-\t\t\terr = error(e1)\n-\t\t} else {\n-\t\t\terr = syscall.EINVAL\n-\t\t}\n-\t}\n-\treturn\n-}\n-\n-func SetCursor(cursor syscall.Handle) (precursor syscall.Handle, err error) {\n-\tr0, _, e1 := syscall.Syscall(procSetCursor.Addr(), 1, uintptr(cursor), 0, 0)\n-\tprecursor = syscall.Handle(r0)\n-\tif precursor == 0 {\n-\t\tif e1 != 0 {\n-\t\t\terr = error(e1)\n-\t\t} else {\n-\t\t\terr = syscall.EINVAL\n-\t\t}\n-\t}\n-\treturn\n-}\n-\n-func SendMessage(hwnd syscall.Handle, msg uint32, wparam uintptr, lparam uintptr) (lresult uintptr) {\n-\tr0, _, _ := syscall.Syscall6(procSendMessageW.Addr(), 4, uintptr(hwnd), uintptr(msg), uintptr(wparam), uintptr(lparam), 0, 0)\n-\tlresult = uintptr(r0)\n-\treturn\n-}\n-\n-func PostMessage(hwnd syscall.Handle, msg uint32, wparam uintptr, lparam uintptr) (err error) {\n-\tr1, _, e1 := syscall.Syscall6(procPostMessageW.Addr(), 4, uintptr(hwnd), uintptr(msg), uintptr(wparam), uintptr(lparam), 0, 0)\n-\tif int(r1) == 0 {\n-\t\tif e1 != 0 {\n-\t\t\terr = error(e1)\n-\t\t} else {\n-\t\t\terr = syscall.EINVAL\n-\t\t}\n-\t}\n-\treturn\n-}"}, {"sha": "b06599505fc1dccc5780c94fdcfeac67abeb445e", "filename": "libgo/go/expvar/expvar.go", "status": "modified", "additions": 29, "deletions": 12, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fexpvar%2Fexpvar.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fexpvar%2Fexpvar.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexpvar%2Fexpvar.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -41,10 +41,14 @@ type Var interface {\n // Int is a 64-bit integer variable that satisfies the Var interface.\n type Int struct {\n \ti  int64\n-\tmu sync.Mutex\n+\tmu sync.RWMutex\n }\n \n-func (v *Int) String() string { return strconv.FormatInt(v.i, 10) }\n+func (v *Int) String() string {\n+\tv.mu.RLock()\n+\tdefer v.mu.RUnlock()\n+\treturn strconv.FormatInt(v.i, 10)\n+}\n \n func (v *Int) Add(delta int64) {\n \tv.mu.Lock()\n@@ -61,10 +65,14 @@ func (v *Int) Set(value int64) {\n // Float is a 64-bit float variable that satisfies the Var interface.\n type Float struct {\n \tf  float64\n-\tmu sync.Mutex\n+\tmu sync.RWMutex\n }\n \n-func (v *Float) String() string { return strconv.FormatFloat(v.f, 'g', -1, 64) }\n+func (v *Float) String() string {\n+\tv.mu.RLock()\n+\tdefer v.mu.RUnlock()\n+\treturn strconv.FormatFloat(v.f, 'g', -1, 64)\n+}\n \n // Add adds delta to v.\n func (v *Float) Add(delta float64) {\n@@ -95,17 +103,17 @@ type KeyValue struct {\n func (v *Map) String() string {\n \tv.mu.RLock()\n \tdefer v.mu.RUnlock()\n-\tb := new(bytes.Buffer)\n-\tfmt.Fprintf(b, \"{\")\n+\tvar b bytes.Buffer\n+\tfmt.Fprintf(&b, \"{\")\n \tfirst := true\n \tfor key, val := range v.m {\n \t\tif !first {\n-\t\t\tfmt.Fprintf(b, \", \")\n+\t\t\tfmt.Fprintf(&b, \", \")\n \t\t}\n-\t\tfmt.Fprintf(b, \"\\\"%s\\\": %v\", key, val)\n+\t\tfmt.Fprintf(&b, \"\\\"%s\\\": %v\", key, val)\n \t\tfirst = false\n \t}\n-\tfmt.Fprintf(b, \"}\")\n+\tfmt.Fprintf(&b, \"}\")\n \treturn b.String()\n }\n \n@@ -180,12 +188,21 @@ func (v *Map) Do(f func(KeyValue)) {\n \n // String is a string variable, and satisfies the Var interface.\n type String struct {\n-\ts string\n+\ts  string\n+\tmu sync.RWMutex\n }\n \n-func (v *String) String() string { return strconv.Quote(v.s) }\n+func (v *String) String() string {\n+\tv.mu.RLock()\n+\tdefer v.mu.RUnlock()\n+\treturn strconv.Quote(v.s)\n+}\n \n-func (v *String) Set(value string) { v.s = value }\n+func (v *String) Set(value string) {\n+\tv.mu.Lock()\n+\tdefer v.mu.Unlock()\n+\tv.s = value\n+}\n \n // Func implements Var by calling the function\n // and formatting the returned value using JSON."}, {"sha": "9660370c2928665a3e6ca7f8302843dbf24312e9", "filename": "libgo/go/fmt/doc.go", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Ffmt%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Ffmt%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fdoc.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -7,7 +7,8 @@\n \tto C's printf and scanf.  The format 'verbs' are derived from C's but\n \tare simpler.\n \n-\tPrinting:\n+\n+\tPrinting\n \n \tThe verbs:\n \n@@ -127,7 +128,8 @@\n \tby a single character (the verb) and end with a parenthesized\n \tdescription.\n \n-\tScanning:\n+\n+\tScanning\n \n \tAn analogous set of functions scans formatted text to yield\n \tvalues.  Scan, Scanf and Scanln read from os.Stdin; Fscan,"}, {"sha": "89d57ee6ce33a18e3dd9dc9ae8183264ad04e0e8", "filename": "libgo/go/fmt/export_test.go", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Ffmt%2Fexport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Ffmt%2Fexport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fexport_test.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -0,0 +1,7 @@\n+// Copyright 2012 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package fmt\n+\n+var IsSpace = isSpace"}, {"sha": "e0c587a3525629be56075210115bd7c854a02fcd", "filename": "libgo/go/fmt/fmt_test.go", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Ffmt%2Ffmt_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Ffmt%2Ffmt_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Ffmt_test.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -13,6 +13,7 @@ import (\n \t\"strings\"\n \t\"testing\"\n \t\"time\"\n+\t\"unicode\"\n )\n \n type (\n@@ -830,3 +831,13 @@ func TestBadVerbRecursion(t *testing.T) {\n \t\tt.Error(\"fail with value\")\n \t}\n }\n+\n+func TestIsSpace(t *testing.T) {\n+\t// This tests the internal isSpace function.\n+\t// IsSpace = isSpace is defined in export_test.go.\n+\tfor i := rune(0); i <= unicode.MaxRune; i++ {\n+\t\tif IsSpace(i) != unicode.IsSpace(i) {\n+\t\t\tt.Errorf(\"isSpace(%U) = %v, want %v\", i, IsSpace(i), unicode.IsSpace(i))\n+\t\t}\n+\t}\n+}"}, {"sha": "2186f334b916217547cee6d94d45e9328e9204fd", "filename": "libgo/go/fmt/format.go", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Ffmt%2Fformat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Ffmt%2Fformat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fformat.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -5,9 +5,7 @@\n package fmt\n \n import (\n-\t\"bytes\"\n \t\"strconv\"\n-\t\"unicode\"\n \t\"unicode/utf8\"\n )\n \n@@ -36,10 +34,10 @@ func init() {\n }\n \n // A fmt is the raw formatter used by Printf etc.\n-// It prints into a bytes.Buffer that must be set up externally.\n+// It prints into a buffer that must be set up separately.\n type fmt struct {\n \tintbuf [nByte]byte\n-\tbuf    *bytes.Buffer\n+\tbuf    *buffer\n \t// width, precision\n \twid  int\n \tprec int\n@@ -69,7 +67,7 @@ func (f *fmt) clearflags() {\n \tf.zero = false\n }\n \n-func (f *fmt) init(buf *bytes.Buffer) {\n+func (f *fmt) init(buf *buffer) {\n \tf.buf = buf\n \tf.clearflags()\n }\n@@ -247,7 +245,7 @@ func (f *fmt) integer(a int64, base uint64, signedness bool, digits string) {\n \t}\n \n \t// If we want a quoted char for %#U, move the data up to make room.\n-\tif f.unicode && f.uniQuote && a >= 0 && a <= unicode.MaxRune && unicode.IsPrint(rune(a)) {\n+\tif f.unicode && f.uniQuote && a >= 0 && a <= utf8.MaxRune && strconv.IsPrint(rune(a)) {\n \t\truneWidth := utf8.RuneLen(rune(a))\n \t\twidth := 1 + 1 + runeWidth + 1 // space, quote, rune, quote\n \t\tcopy(buf[i-width:], buf[i:])   // guaranteed to have enough room.\n@@ -290,16 +288,15 @@ func (f *fmt) fmt_s(s string) {\n // fmt_sx formats a string as a hexadecimal encoding of its bytes.\n func (f *fmt) fmt_sx(s, digits string) {\n \t// TODO: Avoid buffer by pre-padding.\n-\tvar b bytes.Buffer\n+\tvar b []byte\n \tfor i := 0; i < len(s); i++ {\n \t\tif i > 0 && f.space {\n-\t\t\tb.WriteByte(' ')\n+\t\t\tb = append(b, ' ')\n \t\t}\n \t\tv := s[i]\n-\t\tb.WriteByte(digits[v>>4])\n-\t\tb.WriteByte(digits[v&0xF])\n+\t\tb = append(b, digits[v>>4], digits[v&0xF])\n \t}\n-\tf.pad(b.Bytes())\n+\tf.pad(b)\n }\n \n // fmt_q formats a string as a double-quoted, escaped Go string constant."}, {"sha": "13438243cdddc75fd52a9b7eed8f94bc7596ccc1", "filename": "libgo/go/fmt/print.go", "status": "modified", "additions": 45, "deletions": 13, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Ffmt%2Fprint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Ffmt%2Fprint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fprint.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -5,13 +5,11 @@\n package fmt\n \n import (\n-\t\"bytes\"\n \t\"errors\"\n \t\"io\"\n \t\"os\"\n \t\"reflect\"\n \t\"sync\"\n-\t\"unicode\"\n \t\"unicode/utf8\"\n )\n \n@@ -71,11 +69,45 @@ type GoStringer interface {\n \tGoString() string\n }\n \n+// Use simple []byte instead of bytes.Buffer to avoid large dependency.\n+type buffer []byte\n+\n+func (b *buffer) Write(p []byte) (n int, err error) {\n+\t*b = append(*b, p...)\n+\treturn len(p), nil\n+}\n+\n+func (b *buffer) WriteString(s string) (n int, err error) {\n+\t*b = append(*b, s...)\n+\treturn len(s), nil\n+}\n+\n+func (b *buffer) WriteByte(c byte) error {\n+\t*b = append(*b, c)\n+\treturn nil\n+}\n+\n+func (bp *buffer) WriteRune(r rune) error {\n+\tif r < utf8.RuneSelf {\n+\t\t*bp = append(*bp, byte(r))\n+\t\treturn nil\n+\t}\n+\n+\tb := *bp\n+\tn := len(b)\n+\tfor n+utf8.UTFMax > cap(b) {\n+\t\tb = append(b, 0)\n+\t}\n+\tw := utf8.EncodeRune(b[n:n+utf8.UTFMax], r)\n+\t*bp = b[:n+w]\n+\treturn nil\n+}\n+\n type pp struct {\n \tn         int\n \tpanicking bool\n \terroring  bool // printing an error condition\n-\tbuf       bytes.Buffer\n+\tbuf       buffer\n \t// field holds the current item, as an interface{}.\n \tfield interface{}\n \t// value holds the current item, as a reflect.Value, and will be\n@@ -133,10 +165,10 @@ func newPrinter() *pp {\n // Save used pp structs in ppFree; avoids an allocation per invocation.\n func (p *pp) free() {\n \t// Don't hold on to pp structs with large buffers.\n-\tif cap(p.buf.Bytes()) > 1024 {\n+\tif cap(p.buf) > 1024 {\n \t\treturn\n \t}\n-\tp.buf.Reset()\n+\tp.buf = p.buf[:0]\n \tp.field = nil\n \tp.value = reflect.Value{}\n \tppFree.put(p)\n@@ -179,7 +211,7 @@ func (p *pp) Write(b []byte) (ret int, err error) {\n func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error) {\n \tp := newPrinter()\n \tp.doPrintf(format, a)\n-\tn64, err := p.buf.WriteTo(w)\n+\tn64, err := w.Write(p.buf)\n \tp.free()\n \treturn int(n64), err\n }\n@@ -194,7 +226,7 @@ func Printf(format string, a ...interface{}) (n int, err error) {\n func Sprintf(format string, a ...interface{}) string {\n \tp := newPrinter()\n \tp.doPrintf(format, a)\n-\ts := p.buf.String()\n+\ts := string(p.buf)\n \tp.free()\n \treturn s\n }\n@@ -213,7 +245,7 @@ func Errorf(format string, a ...interface{}) error {\n func Fprint(w io.Writer, a ...interface{}) (n int, err error) {\n \tp := newPrinter()\n \tp.doPrint(a, false, false)\n-\tn64, err := p.buf.WriteTo(w)\n+\tn64, err := w.Write(p.buf)\n \tp.free()\n \treturn int(n64), err\n }\n@@ -230,7 +262,7 @@ func Print(a ...interface{}) (n int, err error) {\n func Sprint(a ...interface{}) string {\n \tp := newPrinter()\n \tp.doPrint(a, false, false)\n-\ts := p.buf.String()\n+\ts := string(p.buf)\n \tp.free()\n \treturn s\n }\n@@ -245,7 +277,7 @@ func Sprint(a ...interface{}) string {\n func Fprintln(w io.Writer, a ...interface{}) (n int, err error) {\n \tp := newPrinter()\n \tp.doPrint(a, true, true)\n-\tn64, err := p.buf.WriteTo(w)\n+\tn64, err := w.Write(p.buf)\n \tp.free()\n \treturn int(n64), err\n }\n@@ -262,7 +294,7 @@ func Println(a ...interface{}) (n int, err error) {\n func Sprintln(a ...interface{}) string {\n \tp := newPrinter()\n \tp.doPrint(a, true, true)\n-\ts := p.buf.String()\n+\ts := string(p.buf)\n \tp.free()\n \treturn s\n }\n@@ -352,7 +384,7 @@ func (p *pp) fmtInt64(v int64, verb rune) {\n \tcase 'o':\n \t\tp.fmt.integer(v, 8, signed, ldigits)\n \tcase 'q':\n-\t\tif 0 <= v && v <= unicode.MaxRune {\n+\t\tif 0 <= v && v <= utf8.MaxRune {\n \t\t\tp.fmt.fmt_qc(v)\n \t\t} else {\n \t\t\tp.badVerb(verb)\n@@ -416,7 +448,7 @@ func (p *pp) fmtUint64(v uint64, verb rune, goSyntax bool) {\n \tcase 'o':\n \t\tp.fmt.integer(int64(v), 8, unsigned, ldigits)\n \tcase 'q':\n-\t\tif 0 <= v && v <= unicode.MaxRune {\n+\t\tif 0 <= v && v <= utf8.MaxRune {\n \t\t\tp.fmt.fmt_qc(int64(v))\n \t\t} else {\n \t\t\tp.badVerb(verb)"}, {"sha": "0b3e04069a0dd80363946f58881006375051845d", "filename": "libgo/go/fmt/scan.go", "status": "modified", "additions": 81, "deletions": 32, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Ffmt%2Fscan.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Ffmt%2Fscan.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fscan.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -5,15 +5,12 @@\n package fmt\n \n import (\n-\t\"bytes\"\n \t\"errors\"\n \t\"io\"\n \t\"math\"\n \t\"os\"\n \t\"reflect\"\n \t\"strconv\"\n-\t\"strings\"\n-\t\"unicode\"\n \t\"unicode/utf8\"\n )\n \n@@ -87,25 +84,36 @@ func Scanf(format string, a ...interface{}) (n int, err error) {\n \treturn Fscanf(os.Stdin, format, a...)\n }\n \n+type stringReader string\n+\n+func (r *stringReader) Read(b []byte) (n int, err error) {\n+\tn = copy(b, *r)\n+\t*r = (*r)[n:]\n+\tif n == 0 {\n+\t\terr = io.EOF\n+\t}\n+\treturn\n+}\n+\n // Sscan scans the argument string, storing successive space-separated\n // values into successive arguments.  Newlines count as space.  It\n // returns the number of items successfully scanned.  If that is less\n // than the number of arguments, err will report why.\n func Sscan(str string, a ...interface{}) (n int, err error) {\n-\treturn Fscan(strings.NewReader(str), a...)\n+\treturn Fscan((*stringReader)(&str), a...)\n }\n \n // Sscanln is similar to Sscan, but stops scanning at a newline and\n // after the final item there must be a newline or EOF.\n func Sscanln(str string, a ...interface{}) (n int, err error) {\n-\treturn Fscanln(strings.NewReader(str), a...)\n+\treturn Fscanln((*stringReader)(&str), a...)\n }\n \n // Sscanf scans the argument string, storing successive space-separated\n // values into successive arguments as determined by the format.  It\n // returns the number of items successfully parsed.\n func Sscanf(str string, format string, a ...interface{}) (n int, err error) {\n-\treturn Fscanf(strings.NewReader(str), format, a...)\n+\treturn Fscanf((*stringReader)(&str), format, a...)\n }\n \n // Fscan scans text read from r, storing successive space-separated\n@@ -149,7 +157,7 @@ const eof = -1\n // ss is the internal implementation of ScanState.\n type ss struct {\n \trr       io.RuneReader // where to read input\n-\tbuf      bytes.Buffer  // token accumulator\n+\tbuf      buffer        // token accumulator\n \tpeekRune rune          // one-rune lookahead\n \tprevRune rune          // last rune returned by ReadRune\n \tcount    int           // runes consumed so far.\n@@ -262,14 +270,46 @@ func (s *ss) Token(skipSpace bool, f func(rune) bool) (tok []byte, err error) {\n \tif f == nil {\n \t\tf = notSpace\n \t}\n-\ts.buf.Reset()\n+\ts.buf = s.buf[:0]\n \ttok = s.token(skipSpace, f)\n \treturn\n }\n \n+// space is a copy of the unicode.White_Space ranges,\n+// to avoid depending on package unicode.\n+var space = [][2]uint16{\n+\t{0x0009, 0x000d},\n+\t{0x0020, 0x0020},\n+\t{0x0085, 0x0085},\n+\t{0x00a0, 0x00a0},\n+\t{0x1680, 0x1680},\n+\t{0x180e, 0x180e},\n+\t{0x2000, 0x200a},\n+\t{0x2028, 0x2029},\n+\t{0x202f, 0x202f},\n+\t{0x205f, 0x205f},\n+\t{0x3000, 0x3000},\n+}\n+\n+func isSpace(r rune) bool {\n+\tif r >= 1<<16 {\n+\t\treturn false\n+\t}\n+\trx := uint16(r)\n+\tfor _, rng := range space {\n+\t\tif rx < rng[0] {\n+\t\t\treturn false\n+\t\t}\n+\t\tif rx <= rng[1] {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}\n+\n // notSpace is the default scanning function used in Token.\n func notSpace(r rune) bool {\n-\treturn !unicode.IsSpace(r)\n+\treturn !isSpace(r)\n }\n \n // skipSpace provides Scan() methods the ability to skip space and newline characters \n@@ -378,10 +418,10 @@ func (s *ss) free(old ssave) {\n \t\treturn\n \t}\n \t// Don't hold on to ss structs with large buffers.\n-\tif cap(s.buf.Bytes()) > 1024 {\n+\tif cap(s.buf) > 1024 {\n \t\treturn\n \t}\n-\ts.buf.Reset()\n+\ts.buf = s.buf[:0]\n \ts.rr = nil\n \tssFree.put(s)\n }\n@@ -403,7 +443,7 @@ func (s *ss) skipSpace(stopAtNewline bool) {\n \t\t\ts.errorString(\"unexpected newline\")\n \t\t\treturn\n \t\t}\n-\t\tif !unicode.IsSpace(r) {\n+\t\tif !isSpace(r) {\n \t\t\ts.UnreadRune()\n \t\t\tbreak\n \t\t}\n@@ -429,7 +469,7 @@ func (s *ss) token(skipSpace bool, f func(rune) bool) []byte {\n \t\t}\n \t\ts.buf.WriteRune(r)\n \t}\n-\treturn s.buf.Bytes()\n+\treturn s.buf\n }\n \n // typeError indicates that the type of the operand did not match the format\n@@ -440,14 +480,23 @@ func (s *ss) typeError(field interface{}, expected string) {\n var complexError = errors.New(\"syntax error scanning complex number\")\n var boolError = errors.New(\"syntax error scanning boolean\")\n \n+func indexRune(s string, r rune) int {\n+\tfor i, c := range s {\n+\t\tif c == r {\n+\t\t\treturn i\n+\t\t}\n+\t}\n+\treturn -1\n+}\n+\n // consume reads the next rune in the input and reports whether it is in the ok string.\n // If accept is true, it puts the character into the input token.\n func (s *ss) consume(ok string, accept bool) bool {\n \tr := s.getRune()\n \tif r == eof {\n \t\treturn false\n \t}\n-\tif strings.IndexRune(ok, r) >= 0 {\n+\tif indexRune(ok, r) >= 0 {\n \t\tif accept {\n \t\t\ts.buf.WriteRune(r)\n \t\t}\n@@ -465,7 +514,7 @@ func (s *ss) peek(ok string) bool {\n \tif r != eof {\n \t\ts.UnreadRune()\n \t}\n-\treturn strings.IndexRune(ok, r) >= 0\n+\treturn indexRune(ok, r) >= 0\n }\n \n func (s *ss) notEOF() {\n@@ -560,7 +609,7 @@ func (s *ss) scanNumber(digits string, haveDigits bool) string {\n \t}\n \tfor s.accept(digits) {\n \t}\n-\treturn s.buf.String()\n+\treturn string(s.buf)\n }\n \n // scanRune returns the next rune value in the input.\n@@ -660,16 +709,16 @@ func (s *ss) scanUint(verb rune, bitSize int) uint64 {\n // if the width is specified. It's not rigorous about syntax because it doesn't check that\n // we have at least some digits, but Atof will do that.\n func (s *ss) floatToken() string {\n-\ts.buf.Reset()\n+\ts.buf = s.buf[:0]\n \t// NaN?\n \tif s.accept(\"nN\") && s.accept(\"aA\") && s.accept(\"nN\") {\n-\t\treturn s.buf.String()\n+\t\treturn string(s.buf)\n \t}\n \t// leading sign?\n \ts.accept(sign)\n \t// Inf?\n \tif s.accept(\"iI\") && s.accept(\"nN\") && s.accept(\"fF\") {\n-\t\treturn s.buf.String()\n+\t\treturn string(s.buf)\n \t}\n \t// digits?\n \tfor s.accept(decimalDigits) {\n@@ -688,7 +737,7 @@ func (s *ss) floatToken() string {\n \t\tfor s.accept(decimalDigits) {\n \t\t}\n \t}\n-\treturn s.buf.String()\n+\treturn string(s.buf)\n }\n \n // complexTokens returns the real and imaginary parts of the complex number starting here.\n@@ -698,13 +747,13 @@ func (s *ss) complexTokens() (real, imag string) {\n \t// TODO: accept N and Ni independently?\n \tparens := s.accept(\"(\")\n \treal = s.floatToken()\n-\ts.buf.Reset()\n+\ts.buf = s.buf[:0]\n \t// Must now have a sign.\n \tif !s.accept(\"+-\") {\n \t\ts.error(complexError)\n \t}\n \t// Sign is now in buffer\n-\timagSign := s.buf.String()\n+\timagSign := string(s.buf)\n \timag = s.floatToken()\n \tif !s.accept(\"i\") {\n \t\ts.error(complexError)\n@@ -717,7 +766,7 @@ func (s *ss) complexTokens() (real, imag string) {\n \n // convertFloat converts the string to a float64value.\n func (s *ss) convertFloat(str string, n int) float64 {\n-\tif p := strings.Index(str, \"p\"); p >= 0 {\n+\tif p := indexRune(str, 'p'); p >= 0 {\n \t\t// Atof doesn't handle power-of-2 exponents,\n \t\t// but they're easy to evaluate.\n \t\tf, err := strconv.ParseFloat(str[:p], n)\n@@ -794,7 +843,7 @@ func (s *ss) quotedString() string {\n \t\t\t}\n \t\t\ts.buf.WriteRune(r)\n \t\t}\n-\t\treturn s.buf.String()\n+\t\treturn string(s.buf)\n \tcase '\"':\n \t\t// Double-quoted: Include the quotes and let strconv.Unquote do the backslash escapes.\n \t\ts.buf.WriteRune(quote)\n@@ -811,7 +860,7 @@ func (s *ss) quotedString() string {\n \t\t\t\tbreak\n \t\t\t}\n \t\t}\n-\t\tresult, err := strconv.Unquote(s.buf.String())\n+\t\tresult, err := strconv.Unquote(string(s.buf))\n \t\tif err != nil {\n \t\t\ts.error(err)\n \t\t}\n@@ -844,7 +893,7 @@ func (s *ss) hexByte() (b byte, ok bool) {\n \tif rune1 == eof {\n \t\treturn\n \t}\n-\tif unicode.IsSpace(rune1) {\n+\tif isSpace(rune1) {\n \t\ts.UnreadRune()\n \t\treturn\n \t}\n@@ -862,11 +911,11 @@ func (s *ss) hexString() string {\n \t\t}\n \t\ts.buf.WriteByte(b)\n \t}\n-\tif s.buf.Len() == 0 {\n+\tif len(s.buf) == 0 {\n \t\ts.errorString(\"Scan: no hex data for %x string\")\n \t\treturn \"\"\n \t}\n-\treturn s.buf.String()\n+\treturn string(s.buf)\n }\n \n const floatVerbs = \"beEfFgGv\"\n@@ -875,7 +924,7 @@ const hugeWid = 1 << 30\n \n // scanOne scans a single value, deriving the scanner from the type of the argument.\n func (s *ss) scanOne(verb rune, field interface{}) {\n-\ts.buf.Reset()\n+\ts.buf = s.buf[:0]\n \tvar err error\n \t// If the parameter has its own Scan method, use that.\n \tif v, ok := field.(Scanner); ok {\n@@ -1004,7 +1053,7 @@ func (s *ss) doScan(a []interface{}) (numProcessed int, err error) {\n \t\t\tif r == '\\n' || r == eof {\n \t\t\t\tbreak\n \t\t\t}\n-\t\t\tif !unicode.IsSpace(r) {\n+\t\t\tif !isSpace(r) {\n \t\t\t\ts.errorString(\"Scan: expected newline\")\n \t\t\t\tbreak\n \t\t\t}\n@@ -1032,7 +1081,7 @@ func (s *ss) advance(format string) (i int) {\n \t\t\ti += w // skip the first %\n \t\t}\n \t\tsawSpace := false\n-\t\tfor unicode.IsSpace(fmtc) && i < len(format) {\n+\t\tfor isSpace(fmtc) && i < len(format) {\n \t\t\tsawSpace = true\n \t\t\ti += w\n \t\t\tfmtc, w = utf8.DecodeRuneInString(format[i:])\n@@ -1044,7 +1093,7 @@ func (s *ss) advance(format string) (i int) {\n \t\t\tif inputc == eof {\n \t\t\t\treturn\n \t\t\t}\n-\t\t\tif !unicode.IsSpace(inputc) {\n+\t\t\tif !isSpace(inputc) {\n \t\t\t\t// Space in format but not in input: error\n \t\t\t\ts.errorString(\"expected space in input to match format\")\n \t\t\t}"}, {"sha": "dc9dcd1d652e011a1fcc662164d9e37edea21d9f", "filename": "libgo/go/go/build/build.go", "status": "modified", "additions": 42, "deletions": 16, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -34,7 +34,7 @@ type Context struct {\n \tCgoEnabled  bool     // whether cgo can be used\n \tBuildTags   []string // additional tags to recognize in +build lines\n \tUseAllFiles bool     // use files regardless of +build lines, file names\n-\tGccgo       bool     // assume use of gccgo when computing object paths\n+\tCompiler    string   // compiler to assume when computing target paths\n \n \t// By default, Import uses the operating system's file system calls\n \t// to read directories and files.  To read from other sources,\n@@ -210,6 +210,7 @@ func (ctxt *Context) SrcDirs() []string {\n // if set, or else the compiled code's GOARCH, GOOS, and GOROOT.\n var Default Context = defaultContext()\n \n+// This list is also known to ../../../cmd/dist/build.c.\n var cgoEnabled = map[string]bool{\n \t\"darwin/386\":    true,\n \t\"darwin/amd64\":  true,\n@@ -228,6 +229,7 @@ func defaultContext() Context {\n \tc.GOOS = envOr(\"GOOS\", runtime.GOOS)\n \tc.GOROOT = runtime.GOROOT()\n \tc.GOPATH = envOr(\"GOPATH\", \"\")\n+\tc.Compiler = runtime.Compiler\n \n \tswitch os.Getenv(\"CGO_ENABLED\") {\n \tcase \"1\":\n@@ -277,11 +279,12 @@ type Package struct {\n \tPkgObj     string // installed .a file\n \n \t// Source files\n-\tGoFiles  []string // .go source files (excluding CgoFiles, TestGoFiles, XTestGoFiles)\n-\tCgoFiles []string // .go source files that import \"C\"\n-\tCFiles   []string // .c source files\n-\tHFiles   []string // .h source files\n-\tSFiles   []string // .s source files\n+\tGoFiles   []string // .go source files (excluding CgoFiles, TestGoFiles, XTestGoFiles)\n+\tCgoFiles  []string // .go source files that import \"C\"\n+\tCFiles    []string // .c source files\n+\tHFiles    []string // .h source files\n+\tSFiles    []string // .s source files\n+\tSysoFiles []string // .syso system object files to add to archive\n \n \t// Cgo directives\n \tCgoPkgConfig []string // Cgo pkg-config directives\n@@ -314,6 +317,16 @@ func (ctxt *Context) ImportDir(dir string, mode ImportMode) (*Package, error) {\n \treturn ctxt.Import(\".\", dir, mode)\n }\n \n+// NoGoError is the error used by Import to describe a directory\n+// containing no Go source files.\n+type NoGoError struct {\n+\tDir string\n+}\n+\n+func (e *NoGoError) Error() string {\n+\treturn \"no Go source files in \" + e.Dir\n+}\n+\n // Import returns details about the Go package named by the import path,\n // interpreting local import paths relative to the src directory.  If the path\n // is a local import path naming a package that can be imported using a\n@@ -336,11 +349,16 @@ func (ctxt *Context) Import(path string, src string, mode ImportMode) (*Package,\n \t}\n \n \tvar pkga string\n-\tif ctxt.Gccgo {\n+\tvar pkgerr error\n+\tswitch ctxt.Compiler {\n+\tcase \"gccgo\":\n \t\tdir, elem := pathpkg.Split(p.ImportPath)\n \t\tpkga = \"pkg/gccgo/\" + dir + \"lib\" + elem + \".a\"\n-\t} else {\n+\tcase \"gc\":\n \t\tpkga = \"pkg/\" + ctxt.GOOS + \"_\" + ctxt.GOARCH + \"/\" + p.ImportPath + \".a\"\n+\tdefault:\n+\t\t// Save error for end of function.\n+\t\tpkgerr = fmt.Errorf(\"import %q: unknown compiler %q\", path, ctxt.Compiler)\n \t}\n \n \tbinaryOnly := false\n@@ -396,7 +414,7 @@ func (ctxt *Context) Import(path string, src string, mode ImportMode) (*Package,\n \t\tif ctxt.GOROOT != \"\" {\n \t\t\tdir := ctxt.joinPath(ctxt.GOROOT, \"src\", \"pkg\", path)\n \t\t\tisDir := ctxt.isDir(dir)\n-\t\t\tbinaryOnly = !isDir && mode&AllowBinary != 0 && ctxt.isFile(ctxt.joinPath(ctxt.GOROOT, pkga))\n+\t\t\tbinaryOnly = !isDir && mode&AllowBinary != 0 && pkga != \"\" && ctxt.isFile(ctxt.joinPath(ctxt.GOROOT, pkga))\n \t\t\tif isDir || binaryOnly {\n \t\t\t\tp.Dir = dir\n \t\t\t\tp.Goroot = true\n@@ -407,7 +425,7 @@ func (ctxt *Context) Import(path string, src string, mode ImportMode) (*Package,\n \t\tfor _, root := range ctxt.gopath() {\n \t\t\tdir := ctxt.joinPath(root, \"src\", path)\n \t\t\tisDir := ctxt.isDir(dir)\n-\t\t\tbinaryOnly = !isDir && mode&AllowBinary != 0 && ctxt.isFile(ctxt.joinPath(root, pkga))\n+\t\t\tbinaryOnly = !isDir && mode&AllowBinary != 0 && pkga != \"\" && ctxt.isFile(ctxt.joinPath(root, pkga))\n \t\t\tif isDir || binaryOnly {\n \t\t\t\tp.Dir = dir\n \t\t\t\tp.Root = root\n@@ -426,14 +444,16 @@ Found:\n \t\t}\n \t\tp.PkgRoot = ctxt.joinPath(p.Root, \"pkg\")\n \t\tp.BinDir = ctxt.joinPath(p.Root, \"bin\")\n-\t\tp.PkgObj = ctxt.joinPath(p.Root, pkga)\n+\t\tif pkga != \"\" {\n+\t\t\tp.PkgObj = ctxt.joinPath(p.Root, pkga)\n+\t\t}\n \t}\n \n \tif mode&FindOnly != 0 {\n-\t\treturn p, nil\n+\t\treturn p, pkgerr\n \t}\n \tif binaryOnly && (mode&AllowBinary) != 0 {\n-\t\treturn p, nil\n+\t\treturn p, pkgerr\n \t}\n \n \tdirs, err := ctxt.readDir(p.Dir)\n@@ -467,7 +487,13 @@ Found:\n \t\text := name[i:]\n \t\tswitch ext {\n \t\tcase \".go\", \".c\", \".s\", \".h\", \".S\":\n-\t\t\t// tentatively okay\n+\t\t\t// tentatively okay - read to make sure\n+\t\tcase \".syso\":\n+\t\t\t// binary objects to add to package archive\n+\t\t\t// Likely of the form foo_windows.syso, but\n+\t\t\t// the name was vetted above with goodOSArchFile.\n+\t\t\tp.SysoFiles = append(p.SysoFiles, name)\n+\t\t\tcontinue\n \t\tdefault:\n \t\t\t// skip\n \t\t\tcontinue\n@@ -586,7 +612,7 @@ Found:\n \t\t}\n \t}\n \tif p.Name == \"\" {\n-\t\treturn p, fmt.Errorf(\"no Go source files in %s\", p.Dir)\n+\t\treturn p, &NoGoError{p.Dir}\n \t}\n \n \tp.Imports, p.ImportPos = cleanImports(imported)\n@@ -601,7 +627,7 @@ Found:\n \t\tsort.Strings(p.SFiles)\n \t}\n \n-\treturn p, nil\n+\treturn p, pkgerr\n }\n \n func cleanImports(m map[string][]token.Position) ([]string, map[string][]token.Position) {"}, {"sha": "4e9f32a036ff15aa9749d6b214ac6105c191a6b6", "filename": "libgo/go/go/build/deps_test.go", "status": "added", "additions": 424, "deletions": 0, "changes": 424, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fgo%2Fbuild%2Fdeps_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fgo%2Fbuild%2Fdeps_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fdeps_test.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -0,0 +1,424 @@\n+// Copyright 2012 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// This file exercises the import parser but also checks that\n+// some low-level packages do not have new dependencies added.\n+\n+package build_test\n+\n+import (\n+\t\"go/build\"\n+\t\"sort\"\n+\t\"testing\"\n+)\n+\n+// pkgDeps defines the expected dependencies between packages in\n+// the Go source tree.  It is a statement of policy.\n+// Changes should not be made to this map without prior discussion.\n+//\n+// The map contains two kinds of entries:\n+// 1) Lower-case keys are standard import paths and list the\n+// allowed imports in that package.\n+// 2) Upper-case keys define aliases for package sets, which can then\n+// be used as dependencies by other rules.\n+//\n+// DO NOT CHANGE THIS DATA TO FIX BUILDS.\n+// \n+var pkgDeps = map[string][]string{\n+\t// L0 is the lowest level, core, nearly unavoidable packages.\n+\t\"errors\":      {},\n+\t\"io\":          {\"errors\", \"sync\"},\n+\t\"runtime\":     {\"unsafe\"},\n+\t\"sync\":        {\"sync/atomic\"},\n+\t\"sync/atomic\": {\"unsafe\"},\n+\t\"unsafe\":      {},\n+\n+\t\"L0\": {\n+\t\t\"errors\",\n+\t\t\"io\",\n+\t\t\"runtime\",\n+\t\t\"sync\",\n+\t\t\"sync/atomic\",\n+\t\t\"unsafe\",\n+\t},\n+\n+\t// L1 adds simple functions and strings processing,\n+\t// but not Unicode tables.\n+\t\"math\":          {\"unsafe\"},\n+\t\"math/cmplx\":    {\"math\"},\n+\t\"math/rand\":     {\"L0\", \"math\"},\n+\t\"sort\":          {\"math\"},\n+\t\"strconv\":       {\"L0\", \"unicode/utf8\", \"math\"},\n+\t\"unicode/utf16\": {},\n+\t\"unicode/utf8\":  {},\n+\n+\t\"L1\": {\n+\t\t\"L0\",\n+\t\t\"math\",\n+\t\t\"math/cmplx\",\n+\t\t\"math/rand\",\n+\t\t\"sort\",\n+\t\t\"strconv\",\n+\t\t\"unicode/utf16\",\n+\t\t\"unicode/utf8\",\n+\t},\n+\n+\t// L2 adds Unicode and strings processing.\n+\t\"bufio\":   {\"L0\", \"unicode/utf8\", \"bytes\"},\n+\t\"bytes\":   {\"L0\", \"unicode\", \"unicode/utf8\"},\n+\t\"path\":    {\"L0\", \"unicode/utf8\", \"strings\"},\n+\t\"strings\": {\"L0\", \"unicode\", \"unicode/utf8\"},\n+\t\"unicode\": {},\n+\n+\t\"L2\": {\n+\t\t\"L1\",\n+\t\t\"bufio\",\n+\t\t\"bytes\",\n+\t\t\"path\",\n+\t\t\"strings\",\n+\t\t\"unicode\",\n+\t},\n+\n+\t// L3 adds reflection and some basic utility packages\n+\t// and interface definitions, but nothing that makes\n+\t// system calls.\n+\t\"crypto\":          {\"L2\", \"hash\"}, // interfaces\n+\t\"crypto/cipher\":   {\"L2\"},         // interfaces\n+\t\"encoding/base32\": {\"L2\"},\n+\t\"encoding/base64\": {\"L2\"},\n+\t\"encoding/binary\": {\"L2\", \"reflect\"},\n+\t\"hash\":            {\"L2\"}, // interfaces\n+\t\"hash/adler32\":    {\"L2\", \"hash\"},\n+\t\"hash/crc32\":      {\"L2\", \"hash\"},\n+\t\"hash/crc64\":      {\"L2\", \"hash\"},\n+\t\"hash/fnv\":        {\"L2\", \"hash\"},\n+\t\"image\":           {\"L2\", \"image/color\"}, // interfaces\n+\t\"image/color\":     {\"L2\"},                // interfaces\n+\t\"reflect\":         {\"L2\"},\n+\n+\t\"L3\": {\n+\t\t\"L2\",\n+\t\t\"crypto\",\n+\t\t\"crypto/cipher\",\n+\t\t\"encoding/base32\",\n+\t\t\"encoding/base64\",\n+\t\t\"encoding/binary\",\n+\t\t\"hash\",\n+\t\t\"hash/adler32\",\n+\t\t\"hash/crc32\",\n+\t\t\"hash/crc64\",\n+\t\t\"hash/fnv\",\n+\t\t\"image\",\n+\t\t\"image/color\",\n+\t\t\"reflect\",\n+\t},\n+\n+\t// End of linear dependency definitions.\n+\n+\t// Operating system access.\n+\t\"syscall\":       {\"L0\", \"unicode/utf16\"},\n+\t\"time\":          {\"L0\", \"syscall\"},\n+\t\"os\":            {\"L1\", \"os\", \"syscall\", \"time\"},\n+\t\"path/filepath\": {\"L2\", \"os\", \"syscall\"},\n+\t\"io/ioutil\":     {\"L2\", \"os\", \"path/filepath\", \"time\"},\n+\t\"os/exec\":       {\"L2\", \"os\", \"syscall\"},\n+\t\"os/signal\":     {\"L2\", \"os\", \"syscall\"},\n+\n+\t// OS enables basic operating system functionality,\n+\t// but not direct use of package syscall, nor os/signal.\n+\t\"OS\": {\n+\t\t\"io/ioutil\",\n+\t\t\"os\",\n+\t\t\"os/exec\",\n+\t\t\"path/filepath\",\n+\t\t\"time\",\n+\t},\n+\n+\t// Formatted I/O: few dependencies (L1) but we must add reflect.\n+\t\"fmt\": {\"L1\", \"os\", \"reflect\"},\n+\t\"log\": {\"L1\", \"os\", \"fmt\", \"time\"},\n+\n+\t// Packages used by testing must be low-level (L2+fmt).\n+\t\"regexp\":         {\"L2\", \"regexp/syntax\"},\n+\t\"regexp/syntax\":  {\"L2\"},\n+\t\"runtime/debug\":  {\"L2\", \"fmt\", \"io/ioutil\", \"os\"},\n+\t\"runtime/pprof\":  {\"L2\", \"fmt\", \"text/tabwriter\"},\n+\t\"text/tabwriter\": {\"L2\"},\n+\n+\t\"testing\":        {\"L2\", \"flag\", \"fmt\", \"os\", \"runtime/pprof\", \"time\"},\n+\t\"testing/iotest\": {\"L2\", \"log\"},\n+\t\"testing/quick\":  {\"L2\", \"flag\", \"fmt\", \"reflect\"},\n+\n+\t// L4 is defined as L3+fmt+log+time, because in general once\n+\t// you're using L3 packages, use of fmt, log, or time is not a big deal.\n+\t\"L4\": {\n+\t\t\"L3\",\n+\t\t\"fmt\",\n+\t\t\"log\",\n+\t\t\"time\",\n+\t},\n+\n+\t// Go parser.\n+\t\"go/ast\":     {\"L4\", \"OS\", \"go/scanner\", \"go/token\"},\n+\t\"go/doc\":     {\"L4\", \"go/ast\", \"go/token\", \"regexp\", \"text/template\"},\n+\t\"go/parser\":  {\"L4\", \"OS\", \"go/ast\", \"go/scanner\", \"go/token\"},\n+\t\"go/printer\": {\"L4\", \"OS\", \"go/ast\", \"go/scanner\", \"go/token\", \"text/tabwriter\"},\n+\t\"go/scanner\": {\"L4\", \"OS\", \"go/token\"},\n+\t\"go/token\":   {\"L4\"},\n+\n+\t\"GOPARSER\": {\n+\t\t\"go/ast\",\n+\t\t\"go/doc\",\n+\t\t\"go/parser\",\n+\t\t\"go/printer\",\n+\t\t\"go/scanner\",\n+\t\t\"go/token\",\n+\t},\n+\n+\t// One of a kind.\n+\t\"archive/tar\":         {\"L4\", \"OS\"},\n+\t\"archive/zip\":         {\"L4\", \"OS\", \"compress/flate\"},\n+\t\"compress/bzip2\":      {\"L4\"},\n+\t\"compress/flate\":      {\"L4\"},\n+\t\"compress/gzip\":       {\"L4\", \"compress/flate\"},\n+\t\"compress/lzw\":        {\"L4\"},\n+\t\"compress/zlib\":       {\"L4\", \"compress/flate\"},\n+\t\"database/sql\":        {\"L4\", \"database/sql/driver\"},\n+\t\"database/sql/driver\": {\"L4\", \"time\"},\n+\t\"debug/dwarf\":         {\"L4\"},\n+\t\"debug/elf\":           {\"L4\", \"OS\", \"debug/dwarf\"},\n+\t\"debug/gosym\":         {\"L4\"},\n+\t\"debug/macho\":         {\"L4\", \"OS\", \"debug/dwarf\"},\n+\t\"debug/pe\":            {\"L4\", \"OS\", \"debug/dwarf\"},\n+\t\"encoding/ascii85\":    {\"L4\"},\n+\t\"encoding/asn1\":       {\"L4\", \"math/big\"},\n+\t\"encoding/csv\":        {\"L4\"},\n+\t\"encoding/gob\":        {\"L4\", \"OS\"},\n+\t\"encoding/hex\":        {\"L4\"},\n+\t\"encoding/json\":       {\"L4\"},\n+\t\"encoding/pem\":        {\"L4\"},\n+\t\"encoding/xml\":        {\"L4\"},\n+\t\"flag\":                {\"L4\", \"OS\"},\n+\t\"go/build\":            {\"L4\", \"OS\", \"GOPARSER\"},\n+\t\"html\":                {\"L4\"},\n+\t\"image/draw\":          {\"L4\"},\n+\t\"image/gif\":           {\"L4\", \"compress/lzw\"},\n+\t\"image/jpeg\":          {\"L4\"},\n+\t\"image/png\":           {\"L4\", \"compress/zlib\"},\n+\t\"index/suffixarray\":   {\"L4\", \"regexp\"},\n+\t\"math/big\":            {\"L4\"},\n+\t\"mime\":                {\"L4\", \"OS\", \"syscall\"},\n+\t\"net/url\":             {\"L4\"},\n+\t\"text/scanner\":        {\"L4\", \"OS\"},\n+\t\"text/template/parse\": {\"L4\"},\n+\n+\t\"html/template\": {\n+\t\t\"L4\", \"OS\", \"encoding/json\", \"html\", \"text/template\",\n+\t\t\"text/template/parse\",\n+\t},\n+\t\"text/template\": {\n+\t\t\"L4\", \"OS\", \"net/url\", \"text/template/parse\",\n+\t},\n+\n+\t// Cgo.\n+\t\"runtime/cgo\": {\"L0\", \"C\"},\n+\t\"CGO\":         {\"C\", \"runtime/cgo\"},\n+\n+\t// Fake entry to satisfy the pseudo-import \"C\"\n+\t// that shows up in programs that use cgo.\n+\t\"C\": {},\n+\n+\t\"os/user\": {\"L4\", \"CGO\", \"syscall\"},\n+\n+\t// Basic networking.\n+\t// Because net must be used by any package that wants to\n+\t// do networking portably, it must have a small dependency set: just L1+basic os.\n+\t\"net\": {\"L1\", \"CGO\", \"os\", \"syscall\", \"time\"},\n+\n+\t// NET enables use of basic network-related packages.\n+\t\"NET\": {\n+\t\t\"net\",\n+\t\t\"mime\",\n+\t\t\"net/textproto\",\n+\t\t\"net/url\",\n+\t},\n+\n+\t// Uses of networking.\n+\t\"log/syslog\":    {\"L4\", \"OS\", \"net\"},\n+\t\"net/mail\":      {\"L4\", \"NET\", \"OS\"},\n+\t\"net/textproto\": {\"L4\", \"OS\", \"net\"},\n+\n+\t// Core crypto.\n+\t\"crypto/aes\":    {\"L3\"},\n+\t\"crypto/des\":    {\"L3\"},\n+\t\"crypto/hmac\":   {\"L3\"},\n+\t\"crypto/md5\":    {\"L3\"},\n+\t\"crypto/rc4\":    {\"L3\"},\n+\t\"crypto/sha1\":   {\"L3\"},\n+\t\"crypto/sha256\": {\"L3\"},\n+\t\"crypto/sha512\": {\"L3\"},\n+\t\"crypto/subtle\": {\"L3\"},\n+\n+\t\"CRYPTO\": {\n+\t\t\"crypto/aes\",\n+\t\t\"crypto/des\",\n+\t\t\"crypto/hmac\",\n+\t\t\"crypto/md5\",\n+\t\t\"crypto/rc4\",\n+\t\t\"crypto/sha1\",\n+\t\t\"crypto/sha256\",\n+\t\t\"crypto/sha512\",\n+\t\t\"crypto/subtle\",\n+\t},\n+\n+\t// Random byte, number generation.\n+\t// This would be part of core crypto except that it imports\n+\t// math/big, which imports fmt.\n+\t\"crypto/rand\": {\"L4\", \"CRYPTO\", \"OS\", \"math/big\", \"syscall\"},\n+\n+\t// Mathematical crypto: dependencies on fmt (L4) and math/big.\n+\t// We could avoid some of the fmt, but math/big imports fmt anyway.\n+\t\"crypto/dsa\":      {\"L4\", \"CRYPTO\", \"math/big\"},\n+\t\"crypto/ecdsa\":    {\"L4\", \"CRYPTO\", \"crypto/elliptic\", \"math/big\"},\n+\t\"crypto/elliptic\": {\"L4\", \"CRYPTO\", \"math/big\"},\n+\t\"crypto/rsa\":      {\"L4\", \"CRYPTO\", \"crypto/rand\", \"math/big\"},\n+\n+\t\"CRYPTO-MATH\": {\n+\t\t\"CRYPTO\",\n+\t\t\"crypto/dsa\",\n+\t\t\"crypto/ecdsa\",\n+\t\t\"crypto/elliptic\",\n+\t\t\"crypto/rand\",\n+\t\t\"crypto/rsa\",\n+\t\t\"encoding/asn1\",\n+\t\t\"math/big\",\n+\t},\n+\n+\t// SSL/TLS.\n+\t\"crypto/tls\": {\n+\t\t\"L4\", \"CRYPTO-MATH\", \"CGO\", \"OS\",\n+\t\t\"crypto/x509\", \"encoding/pem\", \"net\", \"syscall\",\n+\t},\n+\t\"crypto/x509\":      {\"L4\", \"CRYPTO-MATH\", \"OS\", \"CGO\", \"crypto/x509/pkix\", \"encoding/pem\", \"syscall\"},\n+\t\"crypto/x509/pkix\": {\"L4\", \"CRYPTO-MATH\"},\n+\n+\t// Simple net+crypto-aware packages.\n+\t\"mime/multipart\": {\"L4\", \"OS\", \"mime\", \"crypto/rand\", \"net/textproto\"},\n+\t\"net/smtp\":       {\"L4\", \"CRYPTO\", \"NET\", \"crypto/tls\"},\n+\n+\t// HTTP, kingpin of dependencies.\n+\t\"net/http\": {\n+\t\t\"L4\", \"NET\", \"OS\",\n+\t\t\"compress/gzip\", \"crypto/tls\", \"mime/multipart\", \"runtime/debug\",\n+\t},\n+\n+\t// HTTP-using packages.\n+\t\"expvar\":            {\"L4\", \"OS\", \"encoding/json\", \"net/http\"},\n+\t\"net/http/cgi\":      {\"L4\", \"NET\", \"OS\", \"crypto/tls\", \"net/http\", \"regexp\"},\n+\t\"net/http/fcgi\":     {\"L4\", \"NET\", \"OS\", \"net/http\", \"net/http/cgi\"},\n+\t\"net/http/httptest\": {\"L4\", \"NET\", \"OS\", \"crypto/tls\", \"flag\", \"net/http\"},\n+\t\"net/http/httputil\": {\"L4\", \"NET\", \"OS\", \"net/http\"},\n+\t\"net/http/pprof\":    {\"L4\", \"OS\", \"html/template\", \"net/http\", \"runtime/pprof\"},\n+\t\"net/rpc\":           {\"L4\", \"NET\", \"encoding/gob\", \"net/http\", \"text/template\"},\n+\t\"net/rpc/jsonrpc\":   {\"L4\", \"NET\", \"encoding/json\", \"net/rpc\"},\n+}\n+\n+// isMacro reports whether p is a package dependency macro\n+// (uppercase name).\n+func isMacro(p string) bool {\n+\treturn 'A' <= p[0] && p[0] <= 'Z'\n+}\n+\n+func allowed(pkg string) map[string]bool {\n+\tm := map[string]bool{}\n+\tvar allow func(string)\n+\tallow = func(p string) {\n+\t\tif m[p] {\n+\t\t\treturn\n+\t\t}\n+\t\tm[p] = true // set even for macros, to avoid loop on cycle\n+\n+\t\t// Upper-case names are macro-expanded.\n+\t\tif isMacro(p) {\n+\t\t\tfor _, pp := range pkgDeps[p] {\n+\t\t\t\tallow(pp)\n+\t\t\t}\n+\t\t}\n+\t}\n+\tfor _, pp := range pkgDeps[pkg] {\n+\t\tallow(pp)\n+\t}\n+\treturn m\n+}\n+\n+var bools = []bool{false, true}\n+var geese = []string{\"darwin\", \"freebsd\", \"linux\", \"netbsd\", \"openbsd\", \"plan9\", \"windows\"}\n+var goarches = []string{\"386\", \"amd64\", \"arm\"}\n+\n+type osPkg struct {\n+\tgoos, pkg string\n+}\n+\n+// allowedErrors are the operating systems and packages known to contain errors\n+// (currently just \"no Go source files\")\n+var allowedErrors = map[osPkg]bool{\n+\tosPkg{\"windows\", \"log/syslog\"}: true,\n+\tosPkg{\"plan9\", \"log/syslog\"}:   true,\n+}\n+\n+func TestDependencies(t *testing.T) {\n+\tvar all []string\n+\n+\tfor k := range pkgDeps {\n+\t\tall = append(all, k)\n+\t}\n+\tsort.Strings(all)\n+\n+\tctxt := build.Default\n+\ttest := func(mustImport bool) {\n+\t\tfor _, pkg := range all {\n+\t\t\tif isMacro(pkg) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tp, err := ctxt.Import(pkg, \"\", 0)\n+\t\t\tif err != nil {\n+\t\t\t\tif allowedErrors[osPkg{ctxt.GOOS, pkg}] {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\t// Some of the combinations we try might not\n+\t\t\t\t// be reasonable (like arm,plan9,cgo), so ignore\n+\t\t\t\t// errors for the auto-generated combinations.\n+\t\t\t\tif !mustImport {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\tt.Errorf(\"%s/%s/cgo=%v %v\", ctxt.GOOS, ctxt.GOARCH, ctxt.CgoEnabled, err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tok := allowed(pkg)\n+\t\t\tvar bad []string\n+\t\t\tfor _, imp := range p.Imports {\n+\t\t\t\tif !ok[imp] {\n+\t\t\t\t\tbad = append(bad, imp)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif bad != nil {\n+\t\t\t\tt.Errorf(\"%s/%s/cgo=%v unexpected dependency: %s imports %v\", ctxt.GOOS, ctxt.GOARCH, ctxt.CgoEnabled, pkg, bad)\n+\t\t\t}\n+\t\t}\n+\t}\n+\ttest(true)\n+\n+\tif testing.Short() {\n+\t\tt.Logf(\"skipping other systems\")\n+\t\treturn\n+\t}\n+\n+\tfor _, ctxt.GOOS = range geese {\n+\t\tfor _, ctxt.GOARCH = range goarches {\n+\t\t\tfor _, ctxt.CgoEnabled = range bools {\n+\t\t\t\ttest(false)\n+\t\t\t}\n+\t\t}\n+\t}\n+}"}, {"sha": "377c8b80cbaa831275294ea672fd9a52d8e07173", "filename": "libgo/go/go/parser/error_test.go", "status": "added", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fgo%2Fparser%2Ferror_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fgo%2Fparser%2Ferror_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Ferror_test.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -0,0 +1,166 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// This file implements a parser test harness. The files in the testdata\n+// directory are parsed and the errors reported are compared against the\n+// error messages expected in the test files. The test files must end in\n+// .src rather than .go so that they are not disturbed by gofmt runs.\n+//\n+// Expected errors are indicated in the test files by putting a comment\n+// of the form /* ERROR \"rx\" */ immediately following an offending token.\n+// The harness will verify that an error matching the regular expression\n+// rx is reported at that source position.\n+//\n+// For instance, the following test file indicates that a \"not declared\"\n+// error should be reported for the undeclared variable x:\n+//\n+//\tpackage p\n+//\tfunc f() {\n+//\t\t_ = x /* ERROR \"not declared\" */ + 1\n+//\t}\n+\n+package parser\n+\n+import (\n+\t\"go/scanner\"\n+\t\"go/token\"\n+\t\"io/ioutil\"\n+\t\"path/filepath\"\n+\t\"regexp\"\n+\t\"strings\"\n+\t\"testing\"\n+)\n+\n+const testdata = \"testdata\"\n+\n+// getFile assumes that each filename occurs at most once\n+func getFile(filename string) (file *token.File) {\n+\tfset.Iterate(func(f *token.File) bool {\n+\t\tif f.Name() == filename {\n+\t\t\tif file != nil {\n+\t\t\t\tpanic(filename + \" used multiple times\")\n+\t\t\t}\n+\t\t\tfile = f\n+\t\t}\n+\t\treturn true\n+\t})\n+\treturn file\n+}\n+\n+func getPos(filename string, offset int) token.Pos {\n+\tif f := getFile(filename); f != nil {\n+\t\treturn f.Pos(offset)\n+\t}\n+\treturn token.NoPos\n+}\n+\n+// ERROR comments must be of the form /* ERROR \"rx\" */ and rx is\n+// a regular expression that matches the expected error message.\n+//\n+var errRx = regexp.MustCompile(`^/\\* *ERROR *\"([^\"]*)\" *\\*/$`)\n+\n+// expectedErrors collects the regular expressions of ERROR comments found\n+// in files and returns them as a map of error positions to error messages.\n+//\n+func expectedErrors(t *testing.T, filename string, src []byte) map[token.Pos]string {\n+\terrors := make(map[token.Pos]string)\n+\n+\tvar s scanner.Scanner\n+\t// file was parsed already - do not add it again to the file\n+\t// set otherwise the position information returned here will\n+\t// not match the position information collected by the parser\n+\ts.Init(getFile(filename), src, nil, scanner.ScanComments)\n+\tvar prev token.Pos // position of last non-comment, non-semicolon token\n+\n+\tfor {\n+\t\tpos, tok, lit := s.Scan()\n+\t\tswitch tok {\n+\t\tcase token.EOF:\n+\t\t\treturn errors\n+\t\tcase token.COMMENT:\n+\t\t\ts := errRx.FindStringSubmatch(lit)\n+\t\t\tif len(s) == 2 {\n+\t\t\t\terrors[prev] = string(s[1])\n+\t\t\t}\n+\t\tdefault:\n+\t\t\tprev = pos\n+\t\t}\n+\t}\n+\n+\tpanic(\"unreachable\")\n+}\n+\n+// compareErrors compares the map of expected error messages with the list\n+// of found errors and reports discrepancies.\n+//\n+func compareErrors(t *testing.T, expected map[token.Pos]string, found scanner.ErrorList) {\n+\tfor _, error := range found {\n+\t\t// error.Pos is a token.Position, but we want\n+\t\t// a token.Pos so we can do a map lookup\n+\t\tpos := getPos(error.Pos.Filename, error.Pos.Offset)\n+\t\tif msg, found := expected[pos]; found {\n+\t\t\t// we expect a message at pos; check if it matches\n+\t\t\trx, err := regexp.Compile(msg)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Errorf(\"%s: %v\", error.Pos, err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif match := rx.MatchString(error.Msg); !match {\n+\t\t\t\tt.Errorf(\"%s: %q does not match %q\", error.Pos, error.Msg, msg)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\t// we have a match - eliminate this error\n+\t\t\tdelete(expected, pos)\n+\t\t} else {\n+\t\t\t// To keep in mind when analyzing failed test output:\n+\t\t\t// If the same error position occurs multiple times in errors,\n+\t\t\t// this message will be triggered (because the first error at\n+\t\t\t// the position removes this position from the expected errors).\n+\t\t\tt.Errorf(\"%s: unexpected error: %s\", error.Pos, error.Msg)\n+\t\t}\n+\t}\n+\n+\t// there should be no expected errors left\n+\tif len(expected) > 0 {\n+\t\tt.Errorf(\"%d errors not reported:\", len(expected))\n+\t\tfor pos, msg := range expected {\n+\t\t\tt.Errorf(\"%s: %s\\n\", fset.Position(pos), msg)\n+\t\t}\n+\t}\n+}\n+\n+func checkErrors(t *testing.T, filename string, input interface{}) {\n+\tsrc, err := readSource(filename, input)\n+\tif err != nil {\n+\t\tt.Error(err)\n+\t\treturn\n+\t}\n+\n+\t_, err = ParseFile(fset, filename, src, DeclarationErrors)\n+\tfound, ok := err.(scanner.ErrorList)\n+\tif err != nil && !ok {\n+\t\tt.Error(err)\n+\t\treturn\n+\t}\n+\n+\t// we are expecting the following errors\n+\t// (collect these after parsing a file so that it is found in the file set)\n+\texpected := expectedErrors(t, filename, src)\n+\n+\t// verify errors returned by the parser\n+\tcompareErrors(t, expected, found)\n+}\n+\n+func TestErrors(t *testing.T) {\n+\tlist, err := ioutil.ReadDir(testdata)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tfor _, fi := range list {\n+\t\tname := fi.Name()\n+\t\tif !fi.IsDir() && !strings.HasPrefix(name, \".\") && strings.HasSuffix(name, \".src\") {\n+\t\t\tcheckErrors(t, filepath.Join(testdata, name), nil)\n+\t\t}\n+\t}\n+}"}, {"sha": "e362e13a7b632f28e3b095db8e2856a56467a2f3", "filename": "libgo/go/go/parser/parser.go", "status": "modified", "additions": 124, "deletions": 28, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -40,6 +40,13 @@ type parser struct {\n \ttok token.Token // one token look-ahead\n \tlit string      // token literal\n \n+\t// Error recovery\n+\t// (used to limit the number of calls to syncXXX functions\n+\t// w/o making scanning progress - avoids potential endless\n+\t// loops across multiple parser functions during error recovery)\n+\tsyncPos token.Pos // last synchronization position\n+\tsyncCnt int       // number of calls to syncXXX without progress\n+\n \t// Non-syntactic parser control\n \texprLev int // < 0: in control clause, >= 0: in expression\n \n@@ -362,18 +369,36 @@ func (p *parser) expect(tok token.Token) token.Pos {\n // expectClosing is like expect but provides a better error message\n // for the common case of a missing comma before a newline.\n //\n-func (p *parser) expectClosing(tok token.Token, construct string) token.Pos {\n+func (p *parser) expectClosing(tok token.Token, context string) token.Pos {\n \tif p.tok != tok && p.tok == token.SEMICOLON && p.lit == \"\\n\" {\n-\t\tp.error(p.pos, \"missing ',' before newline in \"+construct)\n+\t\tp.error(p.pos, \"missing ',' before newline in \"+context)\n \t\tp.next()\n \t}\n \treturn p.expect(tok)\n }\n \n func (p *parser) expectSemi() {\n+\t// semicolon is optional before a closing ')' or '}'\n \tif p.tok != token.RPAREN && p.tok != token.RBRACE {\n-\t\tp.expect(token.SEMICOLON)\n+\t\tif p.tok == token.SEMICOLON {\n+\t\t\tp.next()\n+\t\t} else {\n+\t\t\tp.errorExpected(p.pos, \"';'\")\n+\t\t\tsyncStmt(p)\n+\t\t}\n+\t}\n+}\n+\n+func (p *parser) atComma(context string) bool {\n+\tif p.tok == token.COMMA {\n+\t\treturn true\n+\t}\n+\tif p.tok == token.SEMICOLON && p.lit == \"\\n\" {\n+\t\tp.error(p.pos, \"missing ',' before newline in \"+context)\n+\t\treturn true // \"insert\" the comma and continue\n+\n \t}\n+\treturn false\n }\n \n func assert(cond bool, msg string) {\n@@ -382,6 +407,68 @@ func assert(cond bool, msg string) {\n \t}\n }\n \n+// syncStmt advances to the next statement.\n+// Used for synchronization after an error.\n+//\n+func syncStmt(p *parser) {\n+\tfor {\n+\t\tswitch p.tok {\n+\t\tcase token.BREAK, token.CONST, token.CONTINUE, token.DEFER,\n+\t\t\ttoken.FALLTHROUGH, token.FOR, token.GO, token.GOTO,\n+\t\t\ttoken.IF, token.RETURN, token.SELECT, token.SWITCH,\n+\t\t\ttoken.TYPE, token.VAR:\n+\t\t\t// Return only if parser made some progress since last\n+\t\t\t// sync or if it has not reached 10 sync calls without\n+\t\t\t// progress. Otherwise consume at least one token to\n+\t\t\t// avoid an endless parser loop (it is possible that\n+\t\t\t// both parseOperand and parseStmt call syncStmt and\n+\t\t\t// correctly do not advance, thus the need for the\n+\t\t\t// invocation limit p.syncCnt).\n+\t\t\tif p.pos == p.syncPos && p.syncCnt < 10 {\n+\t\t\t\tp.syncCnt++\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tif p.pos > p.syncPos {\n+\t\t\t\tp.syncPos = p.pos\n+\t\t\t\tp.syncCnt = 0\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\t// Reaching here indicates a parser bug, likely an\n+\t\t\t// incorrect token list in this function, but it only\n+\t\t\t// leads to skipping of possibly correct code if a\n+\t\t\t// previous error is present, and thus is preferred\n+\t\t\t// over a non-terminating parse.\n+\t\tcase token.EOF:\n+\t\t\treturn\n+\t\t}\n+\t\tp.next()\n+\t}\n+}\n+\n+// syncDecl advances to the next declaration.\n+// Used for synchronization after an error.\n+//\n+func syncDecl(p *parser) {\n+\tfor {\n+\t\tswitch p.tok {\n+\t\tcase token.CONST, token.TYPE, token.VAR:\n+\t\t\t// see comments in syncStmt\n+\t\t\tif p.pos == p.syncPos && p.syncCnt < 10 {\n+\t\t\t\tp.syncCnt++\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tif p.pos > p.syncPos {\n+\t\t\t\tp.syncPos = p.pos\n+\t\t\t\tp.syncCnt = 0\n+\t\t\t\treturn\n+\t\t\t}\n+\t\tcase token.EOF:\n+\t\t\treturn\n+\t\t}\n+\t\tp.next()\n+\t}\n+}\n+\n // ----------------------------------------------------------------------------\n // Identifiers\n \n@@ -522,9 +609,11 @@ func (p *parser) makeIdentList(list []ast.Expr) []*ast.Ident {\n \tfor i, x := range list {\n \t\tident, isIdent := x.(*ast.Ident)\n \t\tif !isIdent {\n-\t\t\tpos := x.Pos()\n-\t\t\tp.errorExpected(pos, \"identifier\")\n-\t\t\tident = &ast.Ident{NamePos: pos, Name: \"_\"}\n+\t\t\tif _, isBad := x.(*ast.BadExpr); !isBad {\n+\t\t\t\t// only report error if it's a new one\n+\t\t\t\tp.errorExpected(x.Pos(), \"identifier\")\n+\t\t\t}\n+\t\t\tident = &ast.Ident{NamePos: x.Pos(), Name: \"_\"}\n \t\t}\n \t\tidents[i] = ident\n \t}\n@@ -688,7 +777,7 @@ func (p *parser) parseParameterList(scope *ast.Scope, ellipsisOk bool) (params [\n \t\t\t// Go spec: The scope of an identifier denoting a function\n \t\t\t// parameter or result variable is the function body.\n \t\t\tp.declare(field, nil, scope, ast.Var, idents...)\n-\t\t\tif p.tok != token.COMMA {\n+\t\t\tif !p.atComma(\"parameter list\") {\n \t\t\t\tbreak\n \t\t\t}\n \t\t\tp.next()\n@@ -991,19 +1080,19 @@ func (p *parser) parseOperand(lhs bool) ast.Expr {\n \n \tcase token.FUNC:\n \t\treturn p.parseFuncTypeOrLit()\n+\t}\n \n-\tdefault:\n-\t\tif typ := p.tryIdentOrType(true); typ != nil {\n-\t\t\t// could be type for composite literal or conversion\n-\t\t\t_, isIdent := typ.(*ast.Ident)\n-\t\t\tassert(!isIdent, \"type cannot be identifier\")\n-\t\t\treturn typ\n-\t\t}\n+\tif typ := p.tryIdentOrType(true); typ != nil {\n+\t\t// could be type for composite literal or conversion\n+\t\t_, isIdent := typ.(*ast.Ident)\n+\t\tassert(!isIdent, \"type cannot be identifier\")\n+\t\treturn typ\n \t}\n \n+\t// we have an error\n \tpos := p.pos\n \tp.errorExpected(pos, \"operand\")\n-\tp.next() // make progress\n+\tsyncStmt(p)\n \treturn &ast.BadExpr{From: pos, To: p.pos}\n }\n \n@@ -1078,7 +1167,7 @@ func (p *parser) parseCallOrConversion(fun ast.Expr) *ast.CallExpr {\n \t\t\tellipsis = p.pos\n \t\t\tp.next()\n \t\t}\n-\t\tif p.tok != token.COMMA {\n+\t\tif !p.atComma(\"argument list\") {\n \t\t\tbreak\n \t\t}\n \t\tp.next()\n@@ -1118,7 +1207,7 @@ func (p *parser) parseElementList() (list []ast.Expr) {\n \n \tfor p.tok != token.RBRACE && p.tok != token.EOF {\n \t\tlist = append(list, p.parseElement(true))\n-\t\tif p.tok != token.COMMA {\n+\t\tif !p.atComma(\"composite literal\") {\n \t\t\tbreak\n \t\t}\n \t\tp.next()\n@@ -1262,8 +1351,8 @@ L:\n \t\t\t\tx = p.parseTypeAssertion(p.checkExpr(x))\n \t\t\tdefault:\n \t\t\t\tpos := p.pos\n-\t\t\t\tp.next() // make progress\n \t\t\t\tp.errorExpected(pos, \"selector or type assertion\")\n+\t\t\t\tp.next() // make progress\n \t\t\t\tx = &ast.BadExpr{From: pos, To: p.pos}\n \t\t\t}\n \t\tcase token.LBRACK:\n@@ -1471,7 +1560,10 @@ func (p *parser) parseCallExpr() *ast.CallExpr {\n \tif call, isCall := x.(*ast.CallExpr); isCall {\n \t\treturn call\n \t}\n-\tp.errorExpected(x.Pos(), \"function/method call\")\n+\tif _, isBad := x.(*ast.BadExpr); !isBad {\n+\t\t// only report error if it's a new one\n+\t\tp.errorExpected(x.Pos(), \"function/method call\")\n+\t}\n \treturn nil\n }\n \n@@ -1862,7 +1954,7 @@ func (p *parser) parseStmt() (s ast.Stmt) {\n \n \tswitch p.tok {\n \tcase token.CONST, token.TYPE, token.VAR:\n-\t\ts = &ast.DeclStmt{Decl: p.parseDecl()}\n+\t\ts = &ast.DeclStmt{Decl: p.parseDecl(syncStmt)}\n \tcase\n \t\t// tokens that may start an expression\n \t\ttoken.IDENT, token.INT, token.FLOAT, token.IMAG, token.CHAR, token.STRING, token.FUNC, token.LPAREN, // operands\n@@ -1904,7 +1996,7 @@ func (p *parser) parseStmt() (s ast.Stmt) {\n \t\t// no statement found\n \t\tpos := p.pos\n \t\tp.errorExpected(pos, \"statement\")\n-\t\tp.next() // make progress\n+\t\tsyncStmt(p)\n \t\ts = &ast.BadStmt{From: pos, To: p.pos}\n \t}\n \n@@ -2095,8 +2187,13 @@ func (p *parser) parseReceiver(scope *ast.Scope) *ast.FieldList {\n \trecv := par.List[0]\n \tbase := deref(recv.Type)\n \tif _, isIdent := base.(*ast.Ident); !isIdent {\n-\t\tp.errorExpected(base.Pos(), \"(unqualified) identifier\")\n-\t\tpar.List = []*ast.Field{{Type: &ast.BadExpr{From: recv.Pos(), To: recv.End()}}}\n+\t\tif _, isBad := base.(*ast.BadExpr); !isBad {\n+\t\t\t// only report error if it's a new one\n+\t\t\tp.errorExpected(base.Pos(), \"(unqualified) identifier\")\n+\t\t}\n+\t\tpar.List = []*ast.Field{\n+\t\t\t{Type: &ast.BadExpr{From: recv.Pos(), To: recv.End()}},\n+\t\t}\n \t}\n \n \treturn par\n@@ -2152,7 +2249,7 @@ func (p *parser) parseFuncDecl() *ast.FuncDecl {\n \treturn decl\n }\n \n-func (p *parser) parseDecl() ast.Decl {\n+func (p *parser) parseDecl(sync func(*parser)) ast.Decl {\n \tif p.trace {\n \t\tdefer un(trace(p, \"Declaration\"))\n \t}\n@@ -2174,9 +2271,8 @@ func (p *parser) parseDecl() ast.Decl {\n \tdefault:\n \t\tpos := p.pos\n \t\tp.errorExpected(pos, \"declaration\")\n-\t\tp.next() // make progress\n-\t\tdecl := &ast.BadDecl{From: pos, To: p.pos}\n-\t\treturn decl\n+\t\tsync(p)\n+\t\treturn &ast.BadDecl{From: pos, To: p.pos}\n \t}\n \n \treturn p.parseGenDecl(p.tok, f)\n@@ -2215,7 +2311,7 @@ func (p *parser) parseFile() *ast.File {\n \t\tif p.mode&ImportsOnly == 0 {\n \t\t\t// rest of package body\n \t\t\tfor p.tok != token.EOF {\n-\t\t\t\tdecls = append(decls, p.parseDecl())\n+\t\t\t\tdecls = append(decls, p.parseDecl(syncDecl))\n \t\t\t}\n \t\t}\n \t}"}, {"sha": "5e45acd007afe101db4955bf670ae5559c629b71", "filename": "libgo/go/go/parser/parser_test.go", "status": "modified", "additions": 5, "deletions": 78, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fgo%2Fparser%2Fparser_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fgo%2Fparser%2Fparser_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Fparser_test.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -14,87 +14,14 @@ import (\n \n var fset = token.NewFileSet()\n \n-var illegalInputs = []interface{}{\n-\tnil,\n-\t3.14,\n-\t[]byte(nil),\n-\t\"foo!\",\n-\t`package p; func f() { if /* should have condition */ {} };`,\n-\t`package p; func f() { if ; /* should have condition */ {} };`,\n-\t`package p; func f() { if f(); /* should have condition */ {} };`,\n-\t`package p; const c; /* should have constant value */`,\n-\t`package p; func f() { if _ = range x; true {} };`,\n-\t`package p; func f() { switch _ = range x; true {} };`,\n-\t`package p; func f() { for _ = range x ; ; {} };`,\n-\t`package p; func f() { for ; ; _ = range x {} };`,\n-\t`package p; func f() { for ; _ = range x ; {} };`,\n-\t`package p; func f() { switch t = t.(type) {} };`,\n-\t`package p; func f() { switch t, t = t.(type) {} };`,\n-\t`package p; func f() { switch t = t.(type), t {} };`,\n-\t`package p; var a = [1]int; /* illegal expression */`,\n-\t`package p; var a = [...]int; /* illegal expression */`,\n-\t`package p; var a = struct{} /* illegal expression */`,\n-\t`package p; var a = func(); /* illegal expression */`,\n-\t`package p; var a = interface{} /* illegal expression */`,\n-\t`package p; var a = []int /* illegal expression */`,\n-\t`package p; var a = map[int]int /* illegal expression */`,\n-\t`package p; var a = chan int; /* illegal expression */`,\n-\t`package p; var a = []int{[]int}; /* illegal expression */`,\n-\t`package p; var a = ([]int); /* illegal expression */`,\n-\t`package p; var a = a[[]int:[]int]; /* illegal expression */`,\n-\t`package p; var a = <- chan int; /* illegal expression */`,\n-\t`package p; func f() { select { case _ <- chan int: } };`,\n-}\n-\n-func TestParseIllegalInputs(t *testing.T) {\n-\tfor _, src := range illegalInputs {\n-\t\t_, err := ParseFile(fset, \"\", src, 0)\n-\t\tif err == nil {\n-\t\t\tt.Errorf(\"ParseFile(%v) should have failed\", src)\n-\t\t}\n-\t}\n-}\n-\n-var validPrograms = []string{\n-\t\"package p\\n\",\n-\t`package p;`,\n-\t`package p; import \"fmt\"; func f() { fmt.Println(\"Hello, World!\") };`,\n-\t`package p; func f() { if f(T{}) {} };`,\n-\t`package p; func f() { _ = (<-chan int)(x) };`,\n-\t`package p; func f() { _ = (<-chan <-chan int)(x) };`,\n-\t`package p; func f(func() func() func());`,\n-\t`package p; func f(...T);`,\n-\t`package p; func f(float, ...int);`,\n-\t`package p; func f(x int, a ...int) { f(0, a...); f(1, a...,) };`,\n-\t`package p; func f(int,) {};`,\n-\t`package p; func f(...int,) {};`,\n-\t`package p; func f(x ...int,) {};`,\n-\t`package p; type T []int; var a []bool; func f() { if a[T{42}[0]] {} };`,\n-\t`package p; type T []int; func g(int) bool { return true }; func f() { if g(T{42}[0]) {} };`,\n-\t`package p; type T []int; func f() { for _ = range []int{T{42}[0]} {} };`,\n-\t`package p; var a = T{{1, 2}, {3, 4}}`,\n-\t`package p; func f() { select { case <- c: case c <- d: case c <- <- d: case <-c <- d: } };`,\n-\t`package p; func f() { select { case x := (<-c): } };`,\n-\t`package p; func f() { if ; true {} };`,\n-\t`package p; func f() { switch ; {} };`,\n-\t`package p; func f() { for _ = range \"foo\" + \"bar\" {} };`,\n-}\n-\n-func TestParseValidPrograms(t *testing.T) {\n-\tfor _, src := range validPrograms {\n-\t\t_, err := ParseFile(fset, \"\", src, SpuriousErrors)\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"ParseFile(%q): %v\", src, err)\n-\t\t}\n-\t}\n-}\n-\n var validFiles = []string{\n \t\"parser.go\",\n \t\"parser_test.go\",\n+\t\"error_test.go\",\n+\t\"short_test.go\",\n }\n \n-func TestParse3(t *testing.T) {\n+func TestParse(t *testing.T) {\n \tfor _, filename := range validFiles {\n \t\t_, err := ParseFile(fset, filename, nil, DeclarationErrors)\n \t\tif err != nil {\n@@ -116,7 +43,7 @@ func nameFilter(filename string) bool {\n \n func dirFilter(f os.FileInfo) bool { return nameFilter(f.Name()) }\n \n-func TestParse4(t *testing.T) {\n+func TestParseDir(t *testing.T) {\n \tpath := \".\"\n \tpkgs, err := ParseDir(fset, path, dirFilter, 0)\n \tif err != nil {\n@@ -158,7 +85,7 @@ func TestParseExpr(t *testing.T) {\n \t}\n \n \t// it must not crash\n-\tfor _, src := range validPrograms {\n+\tfor _, src := range valids {\n \t\tParseExpr(src)\n \t}\n }"}, {"sha": "238492bf3f7f824884afd063d7272132ee71288d", "filename": "libgo/go/go/parser/short_test.go", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fgo%2Fparser%2Fshort_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fgo%2Fparser%2Fshort_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Fshort_test.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -0,0 +1,75 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// This file contains test cases for short valid and invalid programs.\n+\n+package parser\n+\n+import \"testing\"\n+\n+var valids = []string{\n+\t\"package p\\n\",\n+\t`package p;`,\n+\t`package p; import \"fmt\"; func f() { fmt.Println(\"Hello, World!\") };`,\n+\t`package p; func f() { if f(T{}) {} };`,\n+\t`package p; func f() { _ = (<-chan int)(x) };`,\n+\t`package p; func f() { _ = (<-chan <-chan int)(x) };`,\n+\t`package p; func f(func() func() func());`,\n+\t`package p; func f(...T);`,\n+\t`package p; func f(float, ...int);`,\n+\t`package p; func f(x int, a ...int) { f(0, a...); f(1, a...,) };`,\n+\t`package p; func f(int,) {};`,\n+\t`package p; func f(...int,) {};`,\n+\t`package p; func f(x ...int,) {};`,\n+\t`package p; type T []int; var a []bool; func f() { if a[T{42}[0]] {} };`,\n+\t`package p; type T []int; func g(int) bool { return true }; func f() { if g(T{42}[0]) {} };`,\n+\t`package p; type T []int; func f() { for _ = range []int{T{42}[0]} {} };`,\n+\t`package p; var a = T{{1, 2}, {3, 4}}`,\n+\t`package p; func f() { select { case <- c: case c <- d: case c <- <- d: case <-c <- d: } };`,\n+\t`package p; func f() { select { case x := (<-c): } };`,\n+\t`package p; func f() { if ; true {} };`,\n+\t`package p; func f() { switch ; {} };`,\n+\t`package p; func f() { for _ = range \"foo\" + \"bar\" {} };`,\n+}\n+\n+func TestValid(t *testing.T) {\n+\tfor _, src := range valids {\n+\t\tcheckErrors(t, src, src)\n+\t}\n+}\n+\n+var invalids = []string{\n+\t`foo /* ERROR \"expected 'package'\" */ !`,\n+\t`package p; func f() { if { /* ERROR \"expected operand\" */ } };`,\n+\t`package p; func f() { if ; { /* ERROR \"expected operand\" */ } };`,\n+\t`package p; func f() { if f(); { /* ERROR \"expected operand\" */ } };`,\n+\t`package p; const c; /* ERROR \"expected '='\" */`,\n+\t`package p; func f() { if _ /* ERROR \"expected condition\" */ = range x; true {} };`,\n+\t`package p; func f() { switch _ /* ERROR \"expected condition\" */ = range x; true {} };`,\n+\t`package p; func f() { for _ = range x ; /* ERROR \"expected '{'\" */ ; {} };`,\n+\t`package p; func f() { for ; ; _ = range /* ERROR \"expected operand\" */ x {} };`,\n+\t`package p; func f() { for ; _ /* ERROR \"expected condition\" */ = range x ; {} };`,\n+\t`package p; func f() { switch t /* ERROR \"expected condition\" */ = t.(type) {} };`,\n+\t`package p; func f() { switch t /* ERROR \"expected condition\" */ , t = t.(type) {} };`,\n+\t`package p; func f() { switch t /* ERROR \"expected condition\" */ = t.(type), t {} };`,\n+\t`package p; var a = [ /* ERROR \"expected expression\" */ 1]int;`,\n+\t`package p; var a = [ /* ERROR \"expected expression\" */ ...]int;`,\n+\t`package p; var a = struct /* ERROR \"expected expression\" */ {}`,\n+\t`package p; var a = func /* ERROR \"expected expression\" */ ();`,\n+\t`package p; var a = interface /* ERROR \"expected expression\" */ {}`,\n+\t`package p; var a = [ /* ERROR \"expected expression\" */ ]int`,\n+\t`package p; var a = map /* ERROR \"expected expression\" */ [int]int`,\n+\t`package p; var a = chan /* ERROR \"expected expression\" */ int;`,\n+\t`package p; var a = []int{[ /* ERROR \"expected expression\" */ ]int};`,\n+\t`package p; var a = ( /* ERROR \"expected expression\" */ []int);`,\n+\t`package p; var a = a[[ /* ERROR \"expected expression\" */ ]int:[]int];`,\n+\t`package p; var a = <-  /* ERROR \"expected expression\" */ chan int;`,\n+\t`package p; func f() { select { case _ <- chan  /* ERROR \"expected expression\" */ int: } };`,\n+}\n+\n+func TestInvalid(t *testing.T) {\n+\tfor _, src := range invalids {\n+\t\tcheckErrors(t, src, src)\n+\t}\n+}"}, {"sha": "af6e706450691f3636fc4af4946f2c59345cf476", "filename": "libgo/go/go/parser/testdata/commas.src", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fgo%2Fparser%2Ftestdata%2Fcommas.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fgo%2Fparser%2Ftestdata%2Fcommas.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Ftestdata%2Fcommas.src?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Test case for error messages/parser synchronization\n+// after missing commas.\n+\n+package p\n+\n+var _ = []int{\n+\t0 /* ERROR \"missing ','\" */\n+}\n+\n+var _ = []int{\n+\t0,\n+\t1,\n+\t2,\n+\t3 /* ERROR \"missing ','\" */\n+}"}, {"sha": "82796c8ceb650e0dbad83f43eabdb5ed9c3d3737", "filename": "libgo/go/go/parser/testdata/issue3106.src", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fgo%2Fparser%2Ftestdata%2Fissue3106.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fgo%2Fparser%2Ftestdata%2Fissue3106.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Ftestdata%2Fissue3106.src?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Test case for issue 3106: Better synchronization of\n+// parser after certain syntax errors.\n+\n+package main\n+\n+func f() {\n+\tvar m Mutex\n+\tc := MakeCond(&m)\n+\tpercent := 0\n+\tconst step = 10\n+\tfor i := 0; i < 5; i++ {\n+\t\tgo func() {\n+\t\t\tfor {\n+\t\t\t\t// Emulates some useful work.\n+\t\t\t\ttime.Sleep(1e8)\n+\t\t\t\tm.Lock()\n+\t\t\t\tdefer\n+\t\t\t\tif /* ERROR \"expected operand, found 'if'\" */ percent == 100 {\n+\t\t\t\t\tm.Unlock()\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t\tpercent++\n+\t\t\t\tif percent % step == 0 {\n+\t\t\t\t\t//c.Signal()\n+\t\t\t\t}\n+\t\t\t\tm.Unlock()\n+\t\t\t}\n+\t\t}()\n+\t}\n+\tfor {\n+\t\tm.Lock()\n+\t\tif percent == 0 || percent % step != 0 {\n+\t\t\tc.Wait()\n+\t\t}\n+\t\tfmt.Print(\",\")\n+\t\tif percent == 100 {\n+\t\t\tm.Unlock()\n+\t\t\tbreak\n+\t\t}\n+\t\tm.Unlock()\n+\t}\n+}"}, {"sha": "6be3c09382e06b3b6b826dda59b56771a72f608a", "filename": "libgo/go/go/printer/nodes.go", "status": "modified", "additions": 51, "deletions": 5, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -15,7 +15,7 @@ import (\n \t\"unicode/utf8\"\n )\n \n-// Other formatting issues:\n+// Formatting issues:\n // - better comment formatting for /*-style comments at the end of a line (e.g. a declaration)\n //   when the comment spans multiple lines; if such a comment is just two lines, formatting is\n //   not idempotent\n@@ -964,6 +964,41 @@ func (p *printer) controlClause(isForStmt bool, init ast.Stmt, expr ast.Expr, po\n \t}\n }\n \n+// indentList reports whether an expression list would look better if it\n+// were indented wholesale (starting with the very first element, rather\n+// than starting at the first line break).\n+//\n+func (p *printer) indentList(list []ast.Expr) bool {\n+\t// Heuristic: indentList returns true if there are more than one multi-\n+\t// line element in the list, or if there is any element that is not\n+\t// starting on the same line as the previous one ends.\n+\tif len(list) >= 2 {\n+\t\tvar b = p.lineFor(list[0].Pos())\n+\t\tvar e = p.lineFor(list[len(list)-1].End())\n+\t\tif 0 < b && b < e {\n+\t\t\t// list spans multiple lines\n+\t\t\tn := 0 // multi-line element count\n+\t\t\tline := b\n+\t\t\tfor _, x := range list {\n+\t\t\t\txb := p.lineFor(x.Pos())\n+\t\t\t\txe := p.lineFor(x.End())\n+\t\t\t\tif line < xb {\n+\t\t\t\t\t// x is not starting on the same\n+\t\t\t\t\t// line as the previous one ended\n+\t\t\t\t\treturn true\n+\t\t\t\t}\n+\t\t\t\tif xb < xe {\n+\t\t\t\t\t// x is a multi-line element\n+\t\t\t\t\tn++\n+\t\t\t\t}\n+\t\t\t\tline = xe\n+\t\t\t}\n+\t\t\treturn n > 1\n+\t\t}\n+\t}\n+\treturn false\n+}\n+\n func (p *printer) stmt(stmt ast.Stmt, nextIsRBrace bool) {\n \tp.print(stmt.Pos())\n \n@@ -1030,7 +1065,18 @@ func (p *printer) stmt(stmt ast.Stmt, nextIsRBrace bool) {\n \t\tp.print(token.RETURN)\n \t\tif s.Results != nil {\n \t\t\tp.print(blank)\n-\t\t\tp.exprList(s.Pos(), s.Results, 1, 0, token.NoPos)\n+\t\t\t// Use indentList heuristic to make corner cases look\n+\t\t\t// better (issue 1207). A more systematic approach would\n+\t\t\t// always indent, but this would cause significant\n+\t\t\t// reformatting of the code base and not necessarily\n+\t\t\t// lead to more nicely formatted code in general.\n+\t\t\tif p.indentList(s.Results) {\n+\t\t\t\tp.print(indent)\n+\t\t\t\tp.exprList(s.Pos(), s.Results, 1, noIndent, token.NoPos)\n+\t\t\t\tp.print(unindent)\n+\t\t\t} else {\n+\t\t\t\tp.exprList(s.Pos(), s.Results, 1, 0, token.NoPos)\n+\t\t\t}\n \t\t}\n \n \tcase *ast.BranchStmt:\n@@ -1200,9 +1246,9 @@ func keepTypeColumn(specs []ast.Spec) []bool {\n \treturn m\n }\n \n-func (p *printer) valueSpec(s *ast.ValueSpec, keepType, doIndent bool) {\n+func (p *printer) valueSpec(s *ast.ValueSpec, keepType bool) {\n \tp.setComment(s.Doc)\n-\tp.identList(s.Names, doIndent) // always present\n+\tp.identList(s.Names, false) // always present\n \textraTabs := 3\n \tif s.Type != nil || keepType {\n \t\tp.print(vtab)\n@@ -1290,7 +1336,7 @@ func (p *printer) genDecl(d *ast.GenDecl) {\n \t\t\t\t\tif i > 0 {\n \t\t\t\t\t\tp.linebreak(p.lineFor(s.Pos()), 1, ignore, newSection)\n \t\t\t\t\t}\n-\t\t\t\t\tp.valueSpec(s.(*ast.ValueSpec), keepType[i], false)\n+\t\t\t\t\tp.valueSpec(s.(*ast.ValueSpec), keepType[i])\n \t\t\t\t\tnewSection = p.isMultiLine(s)\n \t\t\t\t}\n \t\t\t} else {"}, {"sha": "4d70617bf13ec191658ecce11dcfb266cbb95711", "filename": "libgo/go/go/printer/testdata/statements.golden", "status": "modified", "additions": 51, "deletions": 8, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fstatements.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fstatements.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fstatements.golden?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -55,12 +55,24 @@ func _f() {\n \treturn T{\n \t\t1,\n \t\t2,\n-\t},\n+\t}, nil\n+\treturn T{\n+\t\t\t1,\n+\t\t\t2,\n+\t\t},\n+\t\tT{\n+\t\t\tx:\t3,\n+\t\t\ty:\t4,\n+\t\t}, nil\n+\treturn T{\n+\t\t\t1,\n+\t\t\t2,\n+\t\t},\n \t\tnil\n \treturn T{\n-\t\t1,\n-\t\t2,\n-\t},\n+\t\t\t1,\n+\t\t\t2,\n+\t\t},\n \t\tT{\n \t\t\tx:\t3,\n \t\t\ty:\t4,\n@@ -70,10 +82,10 @@ func _f() {\n \t\tz\n \treturn func() {}\n \treturn func() {\n-\t\t_ = 0\n-\t}, T{\n-\t\t1, 2,\n-\t}\n+\t\t\t_ = 0\n+\t\t}, T{\n+\t\t\t1, 2,\n+\t\t}\n \treturn func() {\n \t\t_ = 0\n \t}\n@@ -84,6 +96,37 @@ func _f() {\n \t}\n }\n \n+// Formatting of multi-line returns: test cases from issue 1207.\n+func F() (*T, os.Error) {\n+\treturn &T{\n+\t\t\tX:\t1,\n+\t\t\tY:\t2,\n+\t\t},\n+\t\tnil\n+}\n+\n+func G() (*T, *T, os.Error) {\n+\treturn &T{\n+\t\t\tX:\t1,\n+\t\t\tY:\t2,\n+\t\t},\n+\t\t&T{\n+\t\t\tX:\t3,\n+\t\t\tY:\t4,\n+\t\t},\n+\t\tnil\n+}\n+\n+func _() interface{} {\n+\treturn &fileStat{\n+\t\tname:\t\tbasename(file.name),\n+\t\tsize:\t\tmkSize(d.FileSizeHigh, d.FileSizeLow),\n+\t\tmodTime:\tmkModTime(d.LastWriteTime),\n+\t\tmode:\t\tmkMode(d.FileAttributes),\n+\t\tsys:\t\tmkSysFromFI(&d),\n+\t}, nil\n+}\n+\n // Formatting of if-statement headers.\n func _() {\n \tif true {"}, {"sha": "bd03bc98b7791fa4b8ab6e4cadba687d20764a31", "filename": "libgo/go/go/printer/testdata/statements.input", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fstatements.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fstatements.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fstatements.input?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -52,6 +52,18 @@ func _f() {\n \t\t\t3},\n \t\t3,\n \t}\n+\treturn T{\n+\t\t\t1,\n+\t\t\t2,\n+\t\t}, nil\n+\treturn T{\n+\t\t\t1,\n+\t\t\t2,\n+\t\t},\n+\t\tT{\n+\t\t\tx: 3,\n+\t\t\ty: 4,\n+\t\t}, nil\n \treturn T{\n \t\t\t1,\n \t\t\t2,\n@@ -84,6 +96,37 @@ func _f() {\n \t}\n }\n \n+// Formatting of multi-line returns: test cases from issue 1207.\n+func F() (*T, os.Error) {\n+       return &T{\n+               X: 1,\n+               Y: 2,\n+       },\n+               nil\n+}\n+\n+func G() (*T, *T, os.Error) {\n+       return &T{\n+               X: 1,\n+               Y: 2,\n+       },\n+               &T{\n+                       X: 3,\n+                       Y: 4,\n+               },\n+               nil\n+}\n+\n+func _() interface{} {\n+\treturn &fileStat{\n+\t\t\tname:    basename(file.name),\n+\t\t\tsize:    mkSize(d.FileSizeHigh, d.FileSizeLow),\n+\t\t\tmodTime: mkModTime(d.LastWriteTime),\n+\t\t\tmode:    mkMode(d.FileAttributes),\n+\t\t\tsys:     mkSysFromFI(&d),\n+\t\t}, nil\n+}\n+\n // Formatting of if-statement headers.\n func _() {\n \tif true {}"}, {"sha": "da508747a6d4c668189d20593e021becabe459d2", "filename": "libgo/go/go/scanner/scanner.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -109,7 +109,7 @@ const (\n func (s *Scanner) Init(file *token.File, src []byte, err ErrorHandler, mode Mode) {\n \t// Explicitly initialize all fields since a scanner may be reused.\n \tif file.Size() != len(src) {\n-\t\tpanic(\"file size does not match src len\")\n+\t\tpanic(fmt.Sprintf(\"file size (%d) does not match src len (%d)\", file.Size(), len(src)))\n \t}\n \ts.file = file\n \ts.dir, _ = filepath.Split(file.Name())"}, {"sha": "f470facfd0c86c2ae9c1d8e4e8294e8db43c2ff0", "filename": "libgo/go/html/template/doc.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fhtml%2Ftemplate%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fhtml%2Ftemplate%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Fdoc.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -29,7 +29,7 @@ can be safely embedded in an HTML document. The escaping is contextual, so\n actions can appear within JavaScript, CSS, and URI contexts.\n \n The security model used by this package assumes that template authors are\n-trusted, while text/template Execute's data parameter is not. More details are\n+trusted, while Execute's data parameter is not. More details are\n provided below.\n \n Example"}, {"sha": "54bf159eb4112442607d021e514a0ed73b831950", "filename": "libgo/go/io/io.go", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fio%2Fio.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fio%2Fio.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Fio.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -173,6 +173,13 @@ type ReaderAt interface {\n // at offset off.  It returns the number of bytes written from p (0 <= n <= len(p))\n // and any error encountered that caused the write to stop early.\n // WriteAt must return a non-nil error if it returns n < len(p).\n+//\n+// If WriteAt is writing to a destination with a seek offset,\n+// WriteAt should not affect nor be affected by the underlying\n+// seek offset.\n+//\n+// Clients of WriteAt can execute parallel WriteAt calls on the same\n+// destination if the ranges do not overlap.\n type WriterAt interface {\n \tWriteAt(p []byte, off int64) (n int, err error)\n }"}, {"sha": "1d7f209d1daf676bce28a54aed4ba4bb3327b43a", "filename": "libgo/go/log/log.go", "status": "modified", "additions": 25, "deletions": 32, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Flog%2Flog.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Flog%2Flog.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Flog%2Flog.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -13,8 +13,6 @@\n package log\n \n import (\n-\t\"bytes\"\n-\t_ \"debug/elf\"\n \t\"fmt\"\n \t\"io\"\n \t\"os\"\n@@ -29,7 +27,7 @@ const (\n \t// order they appear (the order listed here) or the format they present (as\n \t// described in the comments).  A colon appears after these items:\n \t//\t2009/0123 01:23:23.123123 /a/b/c/d.go:23: message\n-\tLdate         = 1 << iota     // the date: 2009/0123\n+\tLdate         = 1 << iota     // the date: 2009/01/23\n \tLtime                         // the time: 01:23:23\n \tLmicroseconds                 // microsecond resolution: 01:23:23.123123.  assumes Ltime.\n \tLlongfile                     // full file name and line number: /a/b/c/d.go:23\n@@ -42,11 +40,11 @@ const (\n // the Writer's Write method.  A Logger can be used simultaneously from\n // multiple goroutines; it guarantees to serialize access to the Writer.\n type Logger struct {\n-\tmu     sync.Mutex   // ensures atomic writes; protects the following fields\n-\tprefix string       // prefix to write at beginning of each line\n-\tflag   int          // properties\n-\tout    io.Writer    // destination for output\n-\tbuf    bytes.Buffer // for accumulating text to write\n+\tmu     sync.Mutex // ensures atomic writes; protects the following fields\n+\tprefix string     // prefix to write at beginning of each line\n+\tflag   int        // properties\n+\tout    io.Writer  // destination for output\n+\tbuf    []byte     // for accumulating text to write\n }\n \n // New creates a new Logger.   The out variable sets the\n@@ -61,10 +59,10 @@ var std = New(os.Stderr, \"\", LstdFlags)\n \n // Cheap integer to fixed-width decimal ASCII.  Give a negative width to avoid zero-padding.\n // Knows the buffer has capacity.\n-func itoa(buf *bytes.Buffer, i int, wid int) {\n+func itoa(buf *[]byte, i int, wid int) {\n \tvar u uint = uint(i)\n \tif u == 0 && wid <= 1 {\n-\t\tbuf.WriteByte('0')\n+\t\t*buf = append(*buf, '0')\n \t\treturn\n \t}\n \n@@ -76,38 +74,33 @@ func itoa(buf *bytes.Buffer, i int, wid int) {\n \t\twid--\n \t\tb[bp] = byte(u%10) + '0'\n \t}\n-\n-\t// avoid slicing b to avoid an allocation.\n-\tfor bp < len(b) {\n-\t\tbuf.WriteByte(b[bp])\n-\t\tbp++\n-\t}\n+\t*buf = append(*buf, b[bp:]...)\n }\n \n-func (l *Logger) formatHeader(buf *bytes.Buffer, t time.Time, file string, line int) {\n-\tbuf.WriteString(l.prefix)\n+func (l *Logger) formatHeader(buf *[]byte, t time.Time, file string, line int) {\n+\t*buf = append(*buf, l.prefix...)\n \tif l.flag&(Ldate|Ltime|Lmicroseconds) != 0 {\n \t\tif l.flag&Ldate != 0 {\n \t\t\tyear, month, day := t.Date()\n \t\t\titoa(buf, year, 4)\n-\t\t\tbuf.WriteByte('/')\n+\t\t\t*buf = append(*buf, '/')\n \t\t\titoa(buf, int(month), 2)\n-\t\t\tbuf.WriteByte('/')\n+\t\t\t*buf = append(*buf, '/')\n \t\t\titoa(buf, day, 2)\n-\t\t\tbuf.WriteByte(' ')\n+\t\t\t*buf = append(*buf, ' ')\n \t\t}\n \t\tif l.flag&(Ltime|Lmicroseconds) != 0 {\n \t\t\thour, min, sec := t.Clock()\n \t\t\titoa(buf, hour, 2)\n-\t\t\tbuf.WriteByte(':')\n+\t\t\t*buf = append(*buf, ':')\n \t\t\titoa(buf, min, 2)\n-\t\t\tbuf.WriteByte(':')\n+\t\t\t*buf = append(*buf, ':')\n \t\t\titoa(buf, sec, 2)\n \t\t\tif l.flag&Lmicroseconds != 0 {\n-\t\t\t\tbuf.WriteByte('.')\n+\t\t\t\t*buf = append(*buf, '.')\n \t\t\t\titoa(buf, t.Nanosecond()/1e3, 6)\n \t\t\t}\n-\t\t\tbuf.WriteByte(' ')\n+\t\t\t*buf = append(*buf, ' ')\n \t\t}\n \t}\n \tif l.flag&(Lshortfile|Llongfile) != 0 {\n@@ -121,10 +114,10 @@ func (l *Logger) formatHeader(buf *bytes.Buffer, t time.Time, file string, line\n \t\t\t}\n \t\t\tfile = short\n \t\t}\n-\t\tbuf.WriteString(file)\n-\t\tbuf.WriteByte(':')\n+\t\t*buf = append(*buf, file...)\n+\t\t*buf = append(*buf, ':')\n \t\titoa(buf, line, -1)\n-\t\tbuf.WriteString(\": \")\n+\t\t*buf = append(*buf, \": \"...)\n \t}\n }\n \n@@ -151,13 +144,13 @@ func (l *Logger) Output(calldepth int, s string) error {\n \t\t}\n \t\tl.mu.Lock()\n \t}\n-\tl.buf.Reset()\n+\tl.buf = l.buf[:0]\n \tl.formatHeader(&l.buf, now, file, line)\n-\tl.buf.WriteString(s)\n+\tl.buf = append(l.buf, s...)\n \tif len(s) > 0 && s[len(s)-1] != '\\n' {\n-\t\tl.buf.WriteByte('\\n')\n+\t\tl.buf = append(l.buf, '\\n')\n \t}\n-\t_, err := l.out.Write(l.buf.Bytes())\n+\t_, err := l.out.Write(l.buf)\n \treturn err\n }\n "}, {"sha": "7212087fe0c98dace02798cef56431e44e4acf19", "filename": "libgo/go/net/dial_test.go", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Fdial_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Fdial_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdial_test.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -6,6 +6,7 @@ package net\n \n import (\n \t\"flag\"\n+\t\"fmt\"\n \t\"regexp\"\n \t\"runtime\"\n \t\"testing\"\n@@ -32,7 +33,7 @@ func TestDialTimeout(t *testing.T) {\n \tnumConns := listenerBacklog + 10\n \n \t// TODO(bradfitz): It's hard to test this in a portable\n-\t// way. This is unforunate, but works for now.\n+\t// way. This is unfortunate, but works for now.\n \tswitch runtime.GOOS {\n \tcase \"linux\":\n \t\t// The kernel will start accepting TCP connections before userspace\n@@ -44,13 +45,25 @@ func TestDialTimeout(t *testing.T) {\n \t\t\t\terrc <- err\n \t\t\t}()\n \t\t}\n-\tcase \"darwin\":\n+\tcase \"darwin\", \"windows\":\n \t\t// At least OS X 10.7 seems to accept any number of\n \t\t// connections, ignoring listen's backlog, so resort\n \t\t// to connecting to a hopefully-dead 127/8 address.\n \t\t// Same for windows.\n+\t\t//\n+\t\t// Use an IANA reserved port (49151) instead of 80, because\n+\t\t// on our 386 builder, this Dial succeeds, connecting\n+\t\t// to an IIS web server somewhere.  The data center\n+\t\t// or VM or firewall must be stealing the TCP connection.\n+\t\t// \n+\t\t// IANA Service Name and Transport Protocol Port Number Registry\n+\t\t// <http://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xml>\n \t\tgo func() {\n-\t\t\t_, err := DialTimeout(\"tcp\", \"127.0.71.111:80\", 200*time.Millisecond)\n+\t\t\tc, err := DialTimeout(\"tcp\", \"127.0.71.111:49151\", 200*time.Millisecond)\n+\t\t\tif err == nil {\n+\t\t\t\terr = fmt.Errorf(\"unexpected: connected to %s!\", c.RemoteAddr())\n+\t\t\t\tc.Close()\n+\t\t\t}\n \t\t\terrc <- err\n \t\t}()\n \tdefault:"}, {"sha": "e69cb3188bcce2f18717036c002ccdc70a135251", "filename": "libgo/go/net/dnsclient.go", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Fdnsclient.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Fdnsclient.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdnsclient.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -5,8 +5,6 @@\n package net\n \n import (\n-\t\"bytes\"\n-\t\"fmt\"\n \t\"math/rand\"\n \t\"sort\"\n )\n@@ -45,20 +43,22 @@ func reverseaddr(addr string) (arpa string, err error) {\n \t\treturn \"\", &DNSError{Err: \"unrecognized address\", Name: addr}\n \t}\n \tif ip.To4() != nil {\n-\t\treturn fmt.Sprintf(\"%d.%d.%d.%d.in-addr.arpa.\", ip[15], ip[14], ip[13], ip[12]), nil\n+\t\treturn itoa(int(ip[15])) + \".\" + itoa(int(ip[14])) + \".\" + itoa(int(ip[13])) + \".\" +\n+\t\t\titoa(int(ip[12])) + \".in-addr.arpa.\", nil\n \t}\n \t// Must be IPv6\n-\tvar buf bytes.Buffer\n+\tbuf := make([]byte, 0, len(ip)*4+len(\"ip6.arpa.\"))\n \t// Add it, in reverse, to the buffer\n \tfor i := len(ip) - 1; i >= 0; i-- {\n-\t\ts := fmt.Sprintf(\"%02x\", ip[i])\n-\t\tbuf.WriteByte(s[1])\n-\t\tbuf.WriteByte('.')\n-\t\tbuf.WriteByte(s[0])\n-\t\tbuf.WriteByte('.')\n+\t\tv := ip[i]\n+\t\tbuf = append(buf, hexDigit[v&0xF])\n+\t\tbuf = append(buf, '.')\n+\t\tbuf = append(buf, hexDigit[v>>4])\n+\t\tbuf = append(buf, '.')\n \t}\n \t// Append \"ip6.arpa.\" and return (buf already has the final .)\n-\treturn buf.String() + \"ip6.arpa.\", nil\n+\tbuf = append(buf, \"ip6.arpa.\"...)\n+\treturn string(buf), nil\n }\n \n // Find answer for name in dns message."}, {"sha": "b6ebe117363b3a821e9078c56b68ee1d3937dd01", "filename": "libgo/go/net/dnsmsg.go", "status": "modified", "additions": 229, "deletions": 121, "changes": 350, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Fdnsmsg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Fdnsmsg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdnsmsg.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -7,11 +7,10 @@\n // This is intended to support name resolution during Dial.\n // It doesn't have to be blazing fast.\n //\n-// Rather than write the usual handful of routines to pack and\n-// unpack every message that can appear on the wire, we use\n-// reflection to write a generic pack/unpack for structs and then\n-// use it.  Thus, if in the future we need to define new message\n-// structs, no new pack/unpack/printing code needs to be written.\n+// Each message structure has a Walk method that is used by\n+// a generic pack/unpack routine. Thus, if in the future we need\n+// to define new message structs, no new pack/unpack/printing code\n+// needs to be written.\n //\n // The first half of this file defines the DNS message formats.\n // The second half implements the conversion to and from wire format.\n@@ -23,12 +22,6 @@\n \n package net\n \n-import (\n-\t\"fmt\"\n-\t\"os\"\n-\t\"reflect\"\n-)\n-\n // Packet formats\n \n // Wire constants.\n@@ -75,13 +68,36 @@ const (\n \tdnsRcodeRefused        = 5\n )\n \n+// A dnsStruct describes how to iterate over its fields to emulate\n+// reflective marshalling.\n+type dnsStruct interface {\n+\t// Walk iterates over fields of a structure and calls f\n+\t// with a reference to that field, the name of the field\n+\t// and a tag (\"\", \"domain\", \"ipv4\", \"ipv6\") specifying\n+\t// particular encodings. Possible concrete types\n+\t// for v are *uint16, *uint32, *string, or []byte, and\n+\t// *int, *bool in the case of dnsMsgHdr.\n+\t// Whenever f returns false, Walk must stop and return\n+\t// false, and otherwise return true.\n+\tWalk(f func(v interface{}, name, tag string) (ok bool)) (ok bool)\n+}\n+\n // The wire format for the DNS packet header.\n type dnsHeader struct {\n \tId                                 uint16\n \tBits                               uint16\n \tQdcount, Ancount, Nscount, Arcount uint16\n }\n \n+func (h *dnsHeader) Walk(f func(v interface{}, name, tag string) bool) bool {\n+\treturn f(&h.Id, \"Id\", \"\") &&\n+\t\tf(&h.Bits, \"Bits\", \"\") &&\n+\t\tf(&h.Qdcount, \"Qdcount\", \"\") &&\n+\t\tf(&h.Ancount, \"Ancount\", \"\") &&\n+\t\tf(&h.Nscount, \"Nscount\", \"\") &&\n+\t\tf(&h.Arcount, \"Arcount\", \"\")\n+}\n+\n const (\n \t// dnsHeader.Bits\n \t_QR = 1 << 15 // query/response (response=1)\n@@ -98,6 +114,12 @@ type dnsQuestion struct {\n \tQclass uint16\n }\n \n+func (q *dnsQuestion) Walk(f func(v interface{}, name, tag string) bool) bool {\n+\treturn f(&q.Name, \"Name\", \"domain\") &&\n+\t\tf(&q.Qtype, \"Qtype\", \"\") &&\n+\t\tf(&q.Qclass, \"Qclass\", \"\")\n+}\n+\n // DNS responses (resource records).\n // There are many types of messages,\n // but they all share the same header.\n@@ -113,7 +135,16 @@ func (h *dnsRR_Header) Header() *dnsRR_Header {\n \treturn h\n }\n \n+func (h *dnsRR_Header) Walk(f func(v interface{}, name, tag string) bool) bool {\n+\treturn f(&h.Name, \"Name\", \"domain\") &&\n+\t\tf(&h.Rrtype, \"Rrtype\", \"\") &&\n+\t\tf(&h.Class, \"Class\", \"\") &&\n+\t\tf(&h.Ttl, \"Ttl\", \"\") &&\n+\t\tf(&h.Rdlength, \"Rdlength\", \"\")\n+}\n+\n type dnsRR interface {\n+\tdnsStruct\n \tHeader() *dnsRR_Header\n }\n \n@@ -128,6 +159,10 @@ func (rr *dnsRR_CNAME) Header() *dnsRR_Header {\n \treturn &rr.Hdr\n }\n \n+func (rr *dnsRR_CNAME) Walk(f func(v interface{}, name, tag string) bool) bool {\n+\treturn rr.Hdr.Walk(f) && f(&rr.Cname, \"Cname\", \"domain\")\n+}\n+\n type dnsRR_HINFO struct {\n \tHdr dnsRR_Header\n \tCpu string\n@@ -138,6 +173,10 @@ func (rr *dnsRR_HINFO) Header() *dnsRR_Header {\n \treturn &rr.Hdr\n }\n \n+func (rr *dnsRR_HINFO) Walk(f func(v interface{}, name, tag string) bool) bool {\n+\treturn rr.Hdr.Walk(f) && f(&rr.Cpu, \"Cpu\", \"\") && f(&rr.Os, \"Os\", \"\")\n+}\n+\n type dnsRR_MB struct {\n \tHdr dnsRR_Header\n \tMb  string `net:\"domain-name\"`\n@@ -147,6 +186,10 @@ func (rr *dnsRR_MB) Header() *dnsRR_Header {\n \treturn &rr.Hdr\n }\n \n+func (rr *dnsRR_MB) Walk(f func(v interface{}, name, tag string) bool) bool {\n+\treturn rr.Hdr.Walk(f) && f(&rr.Mb, \"Mb\", \"domain\")\n+}\n+\n type dnsRR_MG struct {\n \tHdr dnsRR_Header\n \tMg  string `net:\"domain-name\"`\n@@ -156,6 +199,10 @@ func (rr *dnsRR_MG) Header() *dnsRR_Header {\n \treturn &rr.Hdr\n }\n \n+func (rr *dnsRR_MG) Walk(f func(v interface{}, name, tag string) bool) bool {\n+\treturn rr.Hdr.Walk(f) && f(&rr.Mg, \"Mg\", \"domain\")\n+}\n+\n type dnsRR_MINFO struct {\n \tHdr   dnsRR_Header\n \tRmail string `net:\"domain-name\"`\n@@ -166,6 +213,10 @@ func (rr *dnsRR_MINFO) Header() *dnsRR_Header {\n \treturn &rr.Hdr\n }\n \n+func (rr *dnsRR_MINFO) Walk(f func(v interface{}, name, tag string) bool) bool {\n+\treturn rr.Hdr.Walk(f) && f(&rr.Rmail, \"Rmail\", \"domain\") && f(&rr.Email, \"Email\", \"domain\")\n+}\n+\n type dnsRR_MR struct {\n \tHdr dnsRR_Header\n \tMr  string `net:\"domain-name\"`\n@@ -175,6 +226,10 @@ func (rr *dnsRR_MR) Header() *dnsRR_Header {\n \treturn &rr.Hdr\n }\n \n+func (rr *dnsRR_MR) Walk(f func(v interface{}, name, tag string) bool) bool {\n+\treturn rr.Hdr.Walk(f) && f(&rr.Mr, \"Mr\", \"domain\")\n+}\n+\n type dnsRR_MX struct {\n \tHdr  dnsRR_Header\n \tPref uint16\n@@ -185,6 +240,10 @@ func (rr *dnsRR_MX) Header() *dnsRR_Header {\n \treturn &rr.Hdr\n }\n \n+func (rr *dnsRR_MX) Walk(f func(v interface{}, name, tag string) bool) bool {\n+\treturn rr.Hdr.Walk(f) && f(&rr.Pref, \"Pref\", \"\") && f(&rr.Mx, \"Mx\", \"domain\")\n+}\n+\n type dnsRR_NS struct {\n \tHdr dnsRR_Header\n \tNs  string `net:\"domain-name\"`\n@@ -194,6 +253,10 @@ func (rr *dnsRR_NS) Header() *dnsRR_Header {\n \treturn &rr.Hdr\n }\n \n+func (rr *dnsRR_NS) Walk(f func(v interface{}, name, tag string) bool) bool {\n+\treturn rr.Hdr.Walk(f) && f(&rr.Ns, \"Ns\", \"domain\")\n+}\n+\n type dnsRR_PTR struct {\n \tHdr dnsRR_Header\n \tPtr string `net:\"domain-name\"`\n@@ -203,6 +266,10 @@ func (rr *dnsRR_PTR) Header() *dnsRR_Header {\n \treturn &rr.Hdr\n }\n \n+func (rr *dnsRR_PTR) Walk(f func(v interface{}, name, tag string) bool) bool {\n+\treturn rr.Hdr.Walk(f) && f(&rr.Ptr, \"Ptr\", \"domain\")\n+}\n+\n type dnsRR_SOA struct {\n \tHdr     dnsRR_Header\n \tNs      string `net:\"domain-name\"`\n@@ -218,6 +285,17 @@ func (rr *dnsRR_SOA) Header() *dnsRR_Header {\n \treturn &rr.Hdr\n }\n \n+func (rr *dnsRR_SOA) Walk(f func(v interface{}, name, tag string) bool) bool {\n+\treturn rr.Hdr.Walk(f) &&\n+\t\tf(&rr.Ns, \"Ns\", \"domain\") &&\n+\t\tf(&rr.Mbox, \"Mbox\", \"domain\") &&\n+\t\tf(&rr.Serial, \"Serial\", \"\") &&\n+\t\tf(&rr.Refresh, \"Refresh\", \"\") &&\n+\t\tf(&rr.Retry, \"Retry\", \"\") &&\n+\t\tf(&rr.Expire, \"Expire\", \"\") &&\n+\t\tf(&rr.Minttl, \"Minttl\", \"\")\n+}\n+\n type dnsRR_TXT struct {\n \tHdr dnsRR_Header\n \tTxt string // not domain name\n@@ -227,6 +305,10 @@ func (rr *dnsRR_TXT) Header() *dnsRR_Header {\n \treturn &rr.Hdr\n }\n \n+func (rr *dnsRR_TXT) Walk(f func(v interface{}, name, tag string) bool) bool {\n+\treturn rr.Hdr.Walk(f) && f(&rr.Txt, \"Txt\", \"\")\n+}\n+\n type dnsRR_SRV struct {\n \tHdr      dnsRR_Header\n \tPriority uint16\n@@ -239,6 +321,14 @@ func (rr *dnsRR_SRV) Header() *dnsRR_Header {\n \treturn &rr.Hdr\n }\n \n+func (rr *dnsRR_SRV) Walk(f func(v interface{}, name, tag string) bool) bool {\n+\treturn rr.Hdr.Walk(f) &&\n+\t\tf(&rr.Priority, \"Priority\", \"\") &&\n+\t\tf(&rr.Weight, \"Weight\", \"\") &&\n+\t\tf(&rr.Port, \"Port\", \"\") &&\n+\t\tf(&rr.Target, \"Target\", \"domain\")\n+}\n+\n type dnsRR_A struct {\n \tHdr dnsRR_Header\n \tA   uint32 `net:\"ipv4\"`\n@@ -248,6 +338,10 @@ func (rr *dnsRR_A) Header() *dnsRR_Header {\n \treturn &rr.Hdr\n }\n \n+func (rr *dnsRR_A) Walk(f func(v interface{}, name, tag string) bool) bool {\n+\treturn rr.Hdr.Walk(f) && f(&rr.A, \"A\", \"ipv4\")\n+}\n+\n type dnsRR_AAAA struct {\n \tHdr  dnsRR_Header\n \tAAAA [16]byte `net:\"ipv6\"`\n@@ -257,6 +351,10 @@ func (rr *dnsRR_AAAA) Header() *dnsRR_Header {\n \treturn &rr.Hdr\n }\n \n+func (rr *dnsRR_AAAA) Walk(f func(v interface{}, name, tag string) bool) bool {\n+\treturn rr.Hdr.Walk(f) && f(rr.AAAA[:], \"AAAA\", \"ipv6\")\n+}\n+\n // Packing and unpacking.\n //\n // All the packers and unpackers take a (msg []byte, off int)\n@@ -386,134 +484,107 @@ Loop:\n \treturn s, off1, true\n }\n \n-// TODO(rsc): Move into generic library?\n-// Pack a reflect.StructValue into msg.  Struct members can only be uint16, uint32, string,\n-// [n]byte, and other (often anonymous) structs.\n-func packStructValue(val reflect.Value, msg []byte, off int) (off1 int, ok bool) {\n-\tfor i := 0; i < val.NumField(); i++ {\n-\t\tf := val.Type().Field(i)\n-\t\tswitch fv := val.Field(i); fv.Kind() {\n+// packStruct packs a structure into msg at specified offset off, and\n+// returns off1 such that msg[off:off1] is the encoded data.\n+func packStruct(any dnsStruct, msg []byte, off int) (off1 int, ok bool) {\n+\tok = any.Walk(func(field interface{}, name, tag string) bool {\n+\t\tswitch fv := field.(type) {\n \t\tdefault:\n-\t\t\tfmt.Fprintf(os.Stderr, \"net: dns: unknown packing type %v\", f.Type)\n-\t\t\treturn len(msg), false\n-\t\tcase reflect.Struct:\n-\t\t\toff, ok = packStructValue(fv, msg, off)\n-\t\tcase reflect.Uint16:\n+\t\t\tprintln(\"net: dns: unknown packing type\")\n+\t\t\treturn false\n+\t\tcase *uint16:\n+\t\t\ti := *fv\n \t\t\tif off+2 > len(msg) {\n-\t\t\t\treturn len(msg), false\n+\t\t\t\treturn false\n \t\t\t}\n-\t\t\ti := fv.Uint()\n \t\t\tmsg[off] = byte(i >> 8)\n \t\t\tmsg[off+1] = byte(i)\n \t\t\toff += 2\n-\t\tcase reflect.Uint32:\n-\t\t\tif off+4 > len(msg) {\n-\t\t\t\treturn len(msg), false\n-\t\t\t}\n-\t\t\ti := fv.Uint()\n+\t\tcase *uint32:\n+\t\t\ti := *fv\n \t\t\tmsg[off] = byte(i >> 24)\n \t\t\tmsg[off+1] = byte(i >> 16)\n \t\t\tmsg[off+2] = byte(i >> 8)\n \t\t\tmsg[off+3] = byte(i)\n \t\t\toff += 4\n-\t\tcase reflect.Array:\n-\t\t\tif fv.Type().Elem().Kind() != reflect.Uint8 {\n-\t\t\t\tfmt.Fprintf(os.Stderr, \"net: dns: unknown packing type %v\", f.Type)\n-\t\t\t\treturn len(msg), false\n-\t\t\t}\n-\t\t\tn := fv.Len()\n+\t\tcase []byte:\n+\t\t\tn := len(fv)\n \t\t\tif off+n > len(msg) {\n-\t\t\t\treturn len(msg), false\n+\t\t\t\treturn false\n \t\t\t}\n-\t\t\treflect.Copy(reflect.ValueOf(msg[off:off+n]), fv)\n+\t\t\tcopy(msg[off:off+n], fv)\n \t\t\toff += n\n-\t\tcase reflect.String:\n-\t\t\t// There are multiple string encodings.\n-\t\t\t// The tag distinguishes ordinary strings from domain names.\n-\t\t\ts := fv.String()\n-\t\t\tswitch f.Tag {\n+\t\tcase *string:\n+\t\t\ts := *fv\n+\t\t\tswitch tag {\n \t\t\tdefault:\n-\t\t\t\tfmt.Fprintf(os.Stderr, \"net: dns: unknown string tag %v\", f.Tag)\n-\t\t\t\treturn len(msg), false\n-\t\t\tcase `net:\"domain-name\"`:\n+\t\t\t\tprintln(\"net: dns: unknown string tag\", tag)\n+\t\t\t\treturn false\n+\t\t\tcase \"domain\":\n \t\t\t\toff, ok = packDomainName(s, msg, off)\n \t\t\t\tif !ok {\n-\t\t\t\t\treturn len(msg), false\n+\t\t\t\t\treturn false\n \t\t\t\t}\n \t\t\tcase \"\":\n \t\t\t\t// Counted string: 1 byte length.\n \t\t\t\tif len(s) > 255 || off+1+len(s) > len(msg) {\n-\t\t\t\t\treturn len(msg), false\n+\t\t\t\t\treturn false\n \t\t\t\t}\n \t\t\t\tmsg[off] = byte(len(s))\n \t\t\t\toff++\n \t\t\t\toff += copy(msg[off:], s)\n \t\t\t}\n \t\t}\n+\t\treturn true\n+\t})\n+\tif !ok {\n+\t\treturn len(msg), false\n \t}\n \treturn off, true\n }\n \n-func structValue(any interface{}) reflect.Value {\n-\treturn reflect.ValueOf(any).Elem()\n-}\n-\n-func packStruct(any interface{}, msg []byte, off int) (off1 int, ok bool) {\n-\toff, ok = packStructValue(structValue(any), msg, off)\n-\treturn off, ok\n-}\n-\n-// TODO(rsc): Move into generic library?\n-// Unpack a reflect.StructValue from msg.\n-// Same restrictions as packStructValue.\n-func unpackStructValue(val reflect.Value, msg []byte, off int) (off1 int, ok bool) {\n-\tfor i := 0; i < val.NumField(); i++ {\n-\t\tf := val.Type().Field(i)\n-\t\tswitch fv := val.Field(i); fv.Kind() {\n+// unpackStruct decodes msg[off:]\u00a0into the given structure, and\n+// returns off1 such that msg[off:off1] is the encoded data.\n+func unpackStruct(any dnsStruct, msg []byte, off int) (off1 int, ok bool) {\n+\tok = any.Walk(func(field interface{}, name, tag string) bool {\n+\t\tswitch fv := field.(type) {\n \t\tdefault:\n-\t\t\tfmt.Fprintf(os.Stderr, \"net: dns: unknown packing type %v\", f.Type)\n-\t\t\treturn len(msg), false\n-\t\tcase reflect.Struct:\n-\t\t\toff, ok = unpackStructValue(fv, msg, off)\n-\t\tcase reflect.Uint16:\n+\t\t\tprintln(\"net: dns: unknown packing type\")\n+\t\t\treturn false\n+\t\tcase *uint16:\n \t\t\tif off+2 > len(msg) {\n-\t\t\t\treturn len(msg), false\n+\t\t\t\treturn false\n \t\t\t}\n-\t\t\ti := uint16(msg[off])<<8 | uint16(msg[off+1])\n-\t\t\tfv.SetUint(uint64(i))\n+\t\t\t*fv = uint16(msg[off])<<8 | uint16(msg[off+1])\n \t\t\toff += 2\n-\t\tcase reflect.Uint32:\n+\t\tcase *uint32:\n \t\t\tif off+4 > len(msg) {\n-\t\t\t\treturn len(msg), false\n+\t\t\t\treturn false\n \t\t\t}\n-\t\t\ti := uint32(msg[off])<<24 | uint32(msg[off+1])<<16 | uint32(msg[off+2])<<8 | uint32(msg[off+3])\n-\t\t\tfv.SetUint(uint64(i))\n+\t\t\t*fv = uint32(msg[off])<<24 | uint32(msg[off+1])<<16 |\n+\t\t\t\tuint32(msg[off+2])<<8 | uint32(msg[off+3])\n \t\t\toff += 4\n-\t\tcase reflect.Array:\n-\t\t\tif fv.Type().Elem().Kind() != reflect.Uint8 {\n-\t\t\t\tfmt.Fprintf(os.Stderr, \"net: dns: unknown packing type %v\", f.Type)\n-\t\t\t\treturn len(msg), false\n-\t\t\t}\n-\t\t\tn := fv.Len()\n+\t\tcase []byte:\n+\t\t\tn := len(fv)\n \t\t\tif off+n > len(msg) {\n-\t\t\t\treturn len(msg), false\n+\t\t\t\treturn false\n \t\t\t}\n-\t\t\treflect.Copy(fv, reflect.ValueOf(msg[off:off+n]))\n+\t\t\tcopy(fv, msg[off:off+n])\n \t\t\toff += n\n-\t\tcase reflect.String:\n+\t\tcase *string:\n \t\t\tvar s string\n-\t\t\tswitch f.Tag {\n+\t\t\tswitch tag {\n \t\t\tdefault:\n-\t\t\t\tfmt.Fprintf(os.Stderr, \"net: dns: unknown string tag %v\", f.Tag)\n-\t\t\t\treturn len(msg), false\n-\t\t\tcase `net:\"domain-name\"`:\n+\t\t\t\tprintln(\"net: dns: unknown string tag\", tag)\n+\t\t\t\treturn false\n+\t\t\tcase \"domain\":\n \t\t\t\ts, off, ok = unpackDomainName(msg, off)\n \t\t\t\tif !ok {\n-\t\t\t\t\treturn len(msg), false\n+\t\t\t\t\treturn false\n \t\t\t\t}\n \t\t\tcase \"\":\n \t\t\t\tif off >= len(msg) || off+1+int(msg[off]) > len(msg) {\n-\t\t\t\t\treturn len(msg), false\n+\t\t\t\t\treturn false\n \t\t\t\t}\n \t\t\t\tn := int(msg[off])\n \t\t\t\toff++\n@@ -524,51 +595,77 @@ func unpackStructValue(val reflect.Value, msg []byte, off int) (off1 int, ok boo\n \t\t\t\toff += n\n \t\t\t\ts = string(b)\n \t\t\t}\n-\t\t\tfv.SetString(s)\n+\t\t\t*fv = s\n \t\t}\n+\t\treturn true\n+\t})\n+\tif !ok {\n+\t\treturn len(msg), false\n \t}\n \treturn off, true\n }\n \n-func unpackStruct(any interface{}, msg []byte, off int) (off1 int, ok bool) {\n-\toff, ok = unpackStructValue(structValue(any), msg, off)\n-\treturn off, ok\n-}\n-\n-// Generic struct printer.\n-// Doesn't care about the string tag `net:\"domain-name\"`,\n-// but does look for an `net:\"ipv4\"` tag on uint32 variables\n-// and the `net:\"ipv6\"` tag on array variables,\n-// printing them as IP addresses.\n-func printStructValue(val reflect.Value) string {\n+// Generic struct printer. Prints fields with tag \"ipv4\" or \"ipv6\"\n+// as IP addresses.\n+func printStruct(any dnsStruct) string {\n \ts := \"{\"\n-\tfor i := 0; i < val.NumField(); i++ {\n-\t\tif i > 0 {\n+\ti := 0\n+\tany.Walk(func(val interface{}, name, tag string) bool {\n+\t\ti++\n+\t\tif i > 1 {\n \t\t\ts += \", \"\n \t\t}\n-\t\tf := val.Type().Field(i)\n-\t\tif !f.Anonymous {\n-\t\t\ts += f.Name + \"=\"\n-\t\t}\n-\t\tfval := val.Field(i)\n-\t\tif fv := fval; fv.Kind() == reflect.Struct {\n-\t\t\ts += printStructValue(fv)\n-\t\t} else if fv := fval; (fv.Kind() == reflect.Uint || fv.Kind() == reflect.Uint8 || fv.Kind() == reflect.Uint16 || fv.Kind() == reflect.Uint32 || fv.Kind() == reflect.Uint64 || fv.Kind() == reflect.Uintptr) && f.Tag == `net:\"ipv4\"` {\n-\t\t\ti := fv.Uint()\n+\t\ts += name + \"=\"\n+\t\tswitch tag {\n+\t\tcase \"ipv4\":\n+\t\t\ti := val.(uint32)\n \t\t\ts += IPv4(byte(i>>24), byte(i>>16), byte(i>>8), byte(i)).String()\n-\t\t} else if fv := fval; fv.Kind() == reflect.Array && f.Tag == `net:\"ipv6\"` {\n-\t\t\ti := fv.Interface().([]byte)\n+\t\tcase \"ipv6\":\n+\t\t\ti := val.([]byte)\n \t\t\ts += IP(i).String()\n-\t\t} else {\n-\t\t\ts += fmt.Sprint(fval.Interface())\n+\t\tdefault:\n+\t\t\tvar i int64\n+\t\t\tswitch v := val.(type) {\n+\t\t\tdefault:\n+\t\t\t\t// can't really happen.\n+\t\t\t\ts += \"<unknown type>\"\n+\t\t\t\treturn true\n+\t\t\tcase *string:\n+\t\t\t\ts += *v\n+\t\t\t\treturn true\n+\t\t\tcase []byte:\n+\t\t\t\ts += string(v)\n+\t\t\t\treturn true\n+\t\t\tcase *bool:\n+\t\t\t\tif *v {\n+\t\t\t\t\ts += \"true\"\n+\t\t\t\t} else {\n+\t\t\t\t\ts += \"false\"\n+\t\t\t\t}\n+\t\t\t\treturn true\n+\t\t\tcase *int:\n+\t\t\t\ti = int64(*v)\n+\t\t\tcase *uint:\n+\t\t\t\ti = int64(*v)\n+\t\t\tcase *uint8:\n+\t\t\t\ti = int64(*v)\n+\t\t\tcase *uint16:\n+\t\t\t\ti = int64(*v)\n+\t\t\tcase *uint32:\n+\t\t\t\ti = int64(*v)\n+\t\t\tcase *uint64:\n+\t\t\t\ti = int64(*v)\n+\t\t\tcase *uintptr:\n+\t\t\t\ti = int64(*v)\n+\t\t\t}\n+\t\t\ts += itoa(int(i))\n \t\t}\n-\t}\n+\t\treturn true\n+\t})\n \ts += \"}\"\n \treturn s\n }\n \n-func printStruct(any interface{}) string { return printStructValue(structValue(any)) }\n-\n // Resource record packer.\n func packRR(rr dnsRR, msg []byte, off int) (off2 int, ok bool) {\n \tvar off1 int\n@@ -627,6 +724,17 @@ type dnsMsgHdr struct {\n \trcode               int\n }\n \n+func (h *dnsMsgHdr) Walk(f func(v interface{}, name, tag string) bool) bool {\n+\treturn f(&h.id, \"id\", \"\") &&\n+\t\tf(&h.response, \"response\", \"\") &&\n+\t\tf(&h.opcode, \"opcode\", \"\") &&\n+\t\tf(&h.authoritative, \"authoritative\", \"\") &&\n+\t\tf(&h.truncated, \"truncated\", \"\") &&\n+\t\tf(&h.recursion_desired, \"recursion_desired\", \"\") &&\n+\t\tf(&h.recursion_available, \"recursion_available\", \"\") &&\n+\t\tf(&h.rcode, \"rcode\", \"\")\n+}\n+\n type dnsMsg struct {\n \tdnsMsgHdr\n \tquestion []dnsQuestion"}, {"sha": "c39dbdb049d63058f8e2df942de151a366304590", "filename": "libgo/go/net/dnsmsg_test.go", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Fdnsmsg_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Fdnsmsg_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdnsmsg_test.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -6,6 +6,7 @@ package net\n \n import (\n \t\"encoding/hex\"\n+\t\"reflect\"\n \t\"testing\"\n )\n \n@@ -19,6 +20,7 @@ func TestDNSParseSRVReply(t *testing.T) {\n \tif !ok {\n \t\tt.Fatalf(\"unpacking packet failed\")\n \t}\n+\tmsg.String() // exercise this code path\n \tif g, e := len(msg.answer), 5; g != e {\n \t\tt.Errorf(\"len(msg.answer) = %d; want %d\", g, e)\n \t}\n@@ -38,6 +40,16 @@ func TestDNSParseSRVReply(t *testing.T) {\n \t\tt.Errorf(\"len(addrs) = %d; want %d\", g, e)\n \t\tt.Logf(\"addrs = %#v\", addrs)\n \t}\n+\t// repack and unpack.\n+\tdata2, ok := msg.Pack()\n+\tmsg2 := new(dnsMsg)\n+\tmsg2.Unpack(data2)\n+\tswitch {\n+\tcase !ok:\n+\t\tt.Errorf(\"failed to repack message\")\n+\tcase !reflect.DeepEqual(msg, msg2):\n+\t\tt.Errorf(\"repacked message differs from original\")\n+\t}\n }\n \n func TestDNSParseCorruptSRVReply(t *testing.T) {\n@@ -50,6 +62,7 @@ func TestDNSParseCorruptSRVReply(t *testing.T) {\n \tif !ok {\n \t\tt.Fatalf(\"unpacking packet failed\")\n \t}\n+\tmsg.String() // exercise this code path\n \tif g, e := len(msg.answer), 5; g != e {\n \t\tt.Errorf(\"len(msg.answer) = %d; want %d\", g, e)\n \t}"}, {"sha": "085e423072aa3c6d2912979b2295b87bdc8efc48", "filename": "libgo/go/net/fd_linux.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Ffd_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Ffd_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffd_linux.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -84,7 +84,8 @@ func (p *pollster) StopWaiting(fd int, bits uint) {\n \n \tevents, already := p.events[fd]\n \tif !already {\n-\t\tprint(\"Epoll unexpected fd=\", fd, \"\\n\")\n+\t\t// The fd returned by the kernel may have been\n+\t\t// cancelled already; return silently.\n \t\treturn\n \t}\n "}, {"sha": "95c0b66995e4a17a8bca7a74eeda129e6b6255d9", "filename": "libgo/go/net/file_test.go", "status": "modified", "additions": 88, "deletions": 24, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Ffile_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Ffile_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffile_test.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -27,7 +27,8 @@ type connFile interface {\n }\n \n func testFileListener(t *testing.T, net, laddr string) {\n-\tif net == \"tcp\" {\n+\tswitch net {\n+\tcase \"tcp\", \"tcp4\", \"tcp6\":\n \t\tladdr += \":0\" // any available port\n \t}\n \tl, err := Listen(net, laddr)\n@@ -55,20 +56,52 @@ func testFileListener(t *testing.T, net, laddr string) {\n \t}\n }\n \n+var fileListenerTests = []struct {\n+\tnet   string\n+\tladdr string\n+\tipv6  bool // test with underlying AF_INET6 socket\n+\tlinux bool // test with abstract unix domain socket, a Linux-ism\n+}{\n+\t{net: \"tcp\", laddr: \"\"},\n+\t{net: \"tcp\", laddr: \"0.0.0.0\"},\n+\t{net: \"tcp\", laddr: \"[::ffff:0.0.0.0]\"},\n+\t{net: \"tcp\", laddr: \"[::]\", ipv6: true},\n+\n+\t{net: \"tcp\", laddr: \"127.0.0.1\"},\n+\t{net: \"tcp\", laddr: \"[::ffff:127.0.0.1]\"},\n+\t{net: \"tcp\", laddr: \"[::1]\", ipv6: true},\n+\n+\t{net: \"tcp4\", laddr: \"\"},\n+\t{net: \"tcp4\", laddr: \"0.0.0.0\"},\n+\t{net: \"tcp4\", laddr: \"[::ffff:0.0.0.0]\"},\n+\n+\t{net: \"tcp4\", laddr: \"127.0.0.1\"},\n+\t{net: \"tcp4\", laddr: \"[::ffff:127.0.0.1]\"},\n+\n+\t{net: \"tcp6\", laddr: \"\", ipv6: true},\n+\t{net: \"tcp6\", laddr: \"[::]\", ipv6: true},\n+\n+\t{net: \"tcp6\", laddr: \"[::1]\", ipv6: true},\n+\n+\t{net: \"unix\", laddr: \"@gotest/net\", linux: true},\n+\t{net: \"unixpacket\", laddr: \"@gotest/net\", linux: true},\n+}\n+\n func TestFileListener(t *testing.T) {\n-\tif runtime.GOOS == \"windows\" || runtime.GOOS == \"plan9\" {\n+\tswitch runtime.GOOS {\n+\tcase \"plan9\", \"windows\":\n+\t\tt.Logf(\"skipping test on %q\", runtime.GOOS)\n \t\treturn\n \t}\n-\ttestFileListener(t, \"tcp\", \"127.0.0.1\")\n-\ttestFileListener(t, \"tcp\", \"127.0.0.1\")\n-\tif supportsIPv6 && supportsIPv4map {\n-\t\ttestFileListener(t, \"tcp\", \"[::ffff:127.0.0.1]\")\n-\t\ttestFileListener(t, \"tcp\", \"127.0.0.1\")\n-\t\ttestFileListener(t, \"tcp\", \"[::ffff:127.0.0.1]\")\n-\t}\n-\tif runtime.GOOS == \"linux\" {\n-\t\ttestFileListener(t, \"unix\", \"@gotest/net\")\n-\t\ttestFileListener(t, \"unixpacket\", \"@gotest/net\")\n+\n+\tfor _, tt := range fileListenerTests {\n+\t\tif skipServerTest(tt.net, \"unix\", tt.laddr, tt.ipv6, false, tt.linux) {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif skipServerTest(tt.net, \"unixpacket\", tt.laddr, tt.ipv6, false, tt.linux) {\n+\t\t\tcontinue\n+\t\t}\n+\t\ttestFileListener(t, tt.net, tt.laddr)\n \t}\n }\n \n@@ -98,9 +131,13 @@ func testFilePacketConn(t *testing.T, pcf packetConnFile, listen bool) {\n }\n \n func testFilePacketConnListen(t *testing.T, net, laddr string) {\n+\tswitch net {\n+\tcase \"udp\", \"udp4\", \"udp6\":\n+\t\tladdr += \":0\" // any available port\n+\t}\n \tl, err := ListenPacket(net, laddr)\n \tif err != nil {\n-\t\tt.Fatalf(\"Listen failed: %v\", err)\n+\t\tt.Fatalf(\"ListenPacket failed: %v\", err)\n \t}\n \ttestFilePacketConn(t, l.(packetConnFile), true)\n \tif err := l.Close(); err != nil {\n@@ -109,6 +146,10 @@ func testFilePacketConnListen(t *testing.T, net, laddr string) {\n }\n \n func testFilePacketConnDial(t *testing.T, net, raddr string) {\n+\tswitch net {\n+\tcase \"udp\", \"udp4\", \"udp6\":\n+\t\traddr += \":12345\"\n+\t}\n \tc, err := Dial(net, raddr)\n \tif err != nil {\n \t\tt.Fatalf(\"Dial failed: %v\", err)\n@@ -119,19 +160,42 @@ func testFilePacketConnDial(t *testing.T, net, raddr string) {\n \t}\n }\n \n+var filePacketConnTests = []struct {\n+\tnet   string\n+\taddr  string\n+\tipv6  bool // test with underlying AF_INET6 socket\n+\tlinux bool // test with abstract unix domain socket, a Linux-ism\n+}{\n+\t{net: \"udp\", addr: \"127.0.0.1\"},\n+\t{net: \"udp\", addr: \"[::ffff:127.0.0.1]\"},\n+\t{net: \"udp\", addr: \"[::1]\", ipv6: true},\n+\n+\t{net: \"udp4\", addr: \"127.0.0.1\"},\n+\t{net: \"udp4\", addr: \"[::ffff:127.0.0.1]\"},\n+\n+\t{net: \"udp6\", addr: \"[::1]\", ipv6: true},\n+\n+\t{net: \"unixgram\", addr: \"@gotest3/net\", linux: true},\n+}\n+\n func TestFilePacketConn(t *testing.T) {\n-\tif runtime.GOOS == \"windows\" || runtime.GOOS == \"plan9\" {\n+\tswitch runtime.GOOS {\n+\tcase \"plan9\", \"windows\":\n+\t\tt.Logf(\"skipping test on %q\", runtime.GOOS)\n \t\treturn\n \t}\n-\ttestFilePacketConnListen(t, \"udp\", \"127.0.0.1:0\")\n-\ttestFilePacketConnDial(t, \"udp\", \"127.0.0.1:12345\")\n-\tif supportsIPv6 {\n-\t\ttestFilePacketConnListen(t, \"udp\", \"[::1]:0\")\n-\t}\n-\tif supportsIPv6 && supportsIPv4map {\n-\t\ttestFilePacketConnDial(t, \"udp\", \"[::ffff:127.0.0.1]:12345\")\n-\t}\n-\tif runtime.GOOS == \"linux\" {\n-\t\ttestFilePacketConnListen(t, \"unixgram\", \"@gotest1/net\")\n+\n+\tfor _, tt := range filePacketConnTests {\n+\t\tif skipServerTest(tt.net, \"unixgram\", tt.addr, tt.ipv6, false, tt.linux) {\n+\t\t\tcontinue\n+\t\t}\n+\t\ttestFilePacketConnListen(t, tt.net, tt.addr)\n+\t\tswitch tt.addr {\n+\t\tcase \"\", \"0.0.0.0\", \"[::ffff:0.0.0.0]\", \"[::]\":\n+\t\tdefault:\n+\t\t\tif tt.net != \"unixgram\" {\n+\t\t\t\ttestFilePacketConnDial(t, tt.net, tt.addr)\n+\t\t\t}\n+\t\t}\n \t}\n }"}, {"sha": "e00b62e590a2869b13c400b0b6cce3377dcad309", "filename": "libgo/go/net/http/client_test.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Fhttp%2Fclient_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Fhttp%2Fclient_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fclient_test.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -238,9 +238,9 @@ func TestRedirects(t *testing.T) {\n }\n \n var expectedCookies = []*Cookie{\n-\t&Cookie{Name: \"ChocolateChip\", Value: \"tasty\"},\n-\t&Cookie{Name: \"First\", Value: \"Hit\"},\n-\t&Cookie{Name: \"Second\", Value: \"Hit\"},\n+\t{Name: \"ChocolateChip\", Value: \"tasty\"},\n+\t{Name: \"First\", Value: \"Hit\"},\n+\t{Name: \"Second\", Value: \"Hit\"},\n }\n \n var echoCookiesRedirectHandler = HandlerFunc(func(w ResponseWriter, r *Request) {"}, {"sha": "f5bc6eb9100fb9aeca4d92e94f70e29fcc138c1e", "filename": "libgo/go/net/http/request.go", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Fhttp%2Frequest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Fhttp%2Frequest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Frequest.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -455,11 +455,13 @@ func ReadRequest(b *bufio.Reader) (req *Request, err error) {\n \t// First line: GET /index.html HTTP/1.0\n \tvar s string\n \tif s, err = tp.ReadLine(); err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer func() {\n \t\tif err == io.EOF {\n \t\t\terr = io.ErrUnexpectedEOF\n \t\t}\n-\t\treturn nil, err\n-\t}\n+\t}()\n \n \tvar f []string\n \tif f = strings.SplitN(s, \" \", 3); len(f) < 3 {"}, {"sha": "6e00b9bfd394ed2e875b0967b2ea6abc12315175", "filename": "libgo/go/net/http/request_test.go", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Fhttp%2Frequest_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Fhttp%2Frequest_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Frequest_test.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -5,6 +5,7 @@\n package http_test\n \n import (\n+\t\"bufio\"\n \t\"bytes\"\n \t\"fmt\"\n \t\"io\"\n@@ -177,6 +178,24 @@ func TestRequestMultipartCallOrder(t *testing.T) {\n \t}\n }\n \n+var readRequestErrorTests = []struct {\n+\tin  string\n+\terr error\n+}{\n+\t{\"GET / HTTP/1.1\\r\\nheader:foo\\r\\n\\r\\n\", nil},\n+\t{\"GET / HTTP/1.1\\r\\nheader:foo\\r\\n\", io.ErrUnexpectedEOF},\n+\t{\"\", io.EOF},\n+}\n+\n+func TestReadRequestErrors(t *testing.T) {\n+\tfor i, tt := range readRequestErrorTests {\n+\t\t_, err := ReadRequest(bufio.NewReader(strings.NewReader(tt.in)))\n+\t\tif err != tt.err {\n+\t\t\tt.Errorf(\"%d. got error = %v; want %v\", i, err, tt.err)\n+\t\t}\n+\t}\n+}\n+\n func testMissingFile(t *testing.T, req *Request) {\n \tf, fh, err := req.FormFile(\"missing\")\n \tif f != nil {"}, {"sha": "228ac401968182fe6b4c2a42588892b322f0fec7", "filename": "libgo/go/net/http/server.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Fhttp%2Fserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Fhttp%2Fserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fserver.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -601,7 +601,7 @@ func (c *conn) serve() {\n \t\t\t\t// while they're still writing their\n \t\t\t\t// request.  Undefined behavior.\n \t\t\t\tmsg = \"413 Request Entity Too Large\"\n-\t\t\t} else if err == io.ErrUnexpectedEOF {\n+\t\t\t} else if err == io.EOF {\n \t\t\t\tbreak // Don't reply\n \t\t\t} else if neterr, ok := err.(net.Error); ok && neterr.Timeout() {\n \t\t\t\tbreak // Don't reply"}, {"sha": "024975946e52b2073800191a5bc41f917ce5743c", "filename": "libgo/go/net/http/transport.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -196,7 +196,7 @@ func (t *Transport) CloseIdleConnections() {\n \t\t\tpconn.close()\n \t\t}\n \t}\n-\tt.idleConn = nil\n+\tt.idleConn = make(map[string][]*persistConn)\n }\n \n //"}, {"sha": "a9e401de58da441207775d8bb32ae2d1f9efb4e4", "filename": "libgo/go/net/http/transport_test.go", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_test.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -698,6 +698,32 @@ func TestTransportPersistConnLeak(t *testing.T) {\n \t}\n }\n \n+// This used to crash; http://golang.org/issue/3266\n+func TestTransportIdleConnCrash(t *testing.T) {\n+\ttr := &Transport{}\n+\tc := &Client{Transport: tr}\n+\n+\tunblockCh := make(chan bool, 1)\n+\tts := httptest.NewServer(HandlerFunc(func(w ResponseWriter, r *Request) {\n+\t\t<-unblockCh\n+\t\ttr.CloseIdleConnections()\n+\t}))\n+\tdefer ts.Close()\n+\n+\tdidreq := make(chan bool)\n+\tgo func() {\n+\t\tres, err := c.Get(ts.URL)\n+\t\tif err != nil {\n+\t\t\tt.Error(err)\n+\t\t} else {\n+\t\t\tres.Body.Close() // returns idle conn\n+\t\t}\n+\t\tdidreq <- true\n+\t}()\n+\tunblockCh <- true\n+\t<-didreq\n+}\n+\n type fooProto struct{}\n \n func (fooProto) RoundTrip(req *Request) (*Response, error) {"}, {"sha": "ee23570a96da6ddd445960a4a44198fd0cc2c76a", "filename": "libgo/go/net/interface.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Finterface.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Finterface.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Finterface.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -78,7 +78,7 @@ func (ifi *Interface) MulticastAddrs() ([]Addr, error) {\n \treturn interfaceMulticastAddrTable(ifi.Index)\n }\n \n-// Interfaces returns a list of the systems's network interfaces.\n+// Interfaces returns a list of the system's network interfaces.\n func Interfaces() ([]Interface, error) {\n \treturn interfaceTable(0)\n }"}, {"sha": "8c9c304087471247292b2b91840bd34701472709", "filename": "libgo/go/net/interface_linux.go", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Finterface_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Finterface_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Finterface_linux.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -7,7 +7,6 @@\n package net\n \n import (\n-\t\"fmt\"\n \t\"os\"\n \t\"syscall\"\n \t\"unsafe\"\n@@ -194,7 +193,9 @@ func parseProcNetIGMP(path string, ifi *Interface) []Addr {\n \t\t\tname = f[1]\n \t\tcase len(f[0]) == 8:\n \t\t\tif ifi == nil || name == ifi.Name {\n-\t\t\t\tfmt.Sscanf(f[0], \"%08x\", &b)\n+\t\t\t\tfor i := 0; i+1 < len(f[0]); i += 2 {\n+\t\t\t\t\tb[i/2], _ = xtoi2(f[0][i:i+2], 0)\n+\t\t\t\t}\n \t\t\t\tifma := IPAddr{IP: IPv4(b[3], b[2], b[1], b[0])}\n \t\t\t\tifmat = append(ifmat, ifma.toAddr())\n \t\t\t}\n@@ -218,10 +219,11 @@ func parseProcNetIGMP6(path string, ifi *Interface) []Addr {\n \t\t\tcontinue\n \t\t}\n \t\tif ifi == nil || f[1] == ifi.Name {\n-\t\t\tfmt.Sscanf(f[2], \"%32x\", &b)\n+\t\t\tfor i := 0; i+1 < len(f[2]); i += 2 {\n+\t\t\t\tb[i/2], _ = xtoi2(f[2][i:i+2], 0)\n+\t\t\t}\n \t\t\tifma := IPAddr{IP: IP{b[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7], b[8], b[9], b[10], b[11], b[12], b[13], b[14], b[15]}}\n \t\t\tifmat = append(ifmat, ifma.toAddr())\n-\n \t\t}\n \t}\n \treturn ifmat"}, {"sha": "6bbe67c3d9a65216a5e637422cc7d06b8f40b910", "filename": "libgo/go/net/iprawsock_posix.go", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Fiprawsock_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Fiprawsock_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fiprawsock_posix.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -34,6 +34,13 @@ func (a *IPAddr) family() int {\n \treturn syscall.AF_INET6\n }\n \n+func (a *IPAddr) isWildcard() bool {\n+\tif a == nil || a.IP == nil {\n+\t\treturn true\n+\t}\n+\treturn a.IP.IsUnspecified()\n+}\n+\n func (a *IPAddr) sockaddr(family int) (syscall.Sockaddr, error) {\n \treturn ipToSockaddr(family, a.IP, 0)\n }"}, {"sha": "ed313195c97fae98f99cb1cf2e22a0d003355294", "filename": "libgo/go/net/ipsock_posix.go", "status": "modified", "additions": 50, "deletions": 32, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Fipsock_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Fipsock_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fipsock_posix.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -38,6 +38,7 @@ func probeIPv6Stack() (supportsIPv6, supportsIPv4map bool) {\n \t\t\tcontinue\n \t\t}\n \t\tdefer closesocket(s)\n+\t\tsyscall.SetsockoptInt(s, syscall.IPPROTO_IPV6, syscall.IPV6_V6ONLY, 0)\n \t\tsa, err := probes[i].la.toAddr().sockaddr(syscall.AF_INET6)\n \t\tif err != nil {\n \t\t\tcontinue\n@@ -55,58 +56,75 @@ func probeIPv6Stack() (supportsIPv6, supportsIPv4map bool) {\n // favoriteAddrFamily returns the appropriate address family to\n // the given net, laddr, raddr and mode.  At first it figures\n // address family out from the net.  If mode indicates \"listen\"\n-// and laddr.(type).IP is nil, it assumes that the user wants to\n-// make a passive connection with wildcard address family, both\n-// INET and INET6, and wildcard address.  Otherwise guess: if the\n-// addresses are IPv4 then returns INET, or else returns INET6.\n-func favoriteAddrFamily(net string, laddr, raddr sockaddr, mode string) int {\n+// and laddr is a wildcard, it assumes that the user wants to\n+// make a passive connection with a wildcard address family, both\n+// AF_INET and AF_INET6, and a wildcard address like following:\n+//\n+//\t1. A wild-wild listen, \"tcp\" + \"\"\n+//\tIf the platform supports both IPv6 and IPv6 IPv4-mapping\n+//\tcapabilities, we assume that the user want to listen on\n+//\tboth IPv4 and IPv6 wildcard address over an AF_INET6\n+//\tsocket with IPV6_V6ONLY=0.  Otherwise we prefer an IPv4\n+//\twildcard address listen over an AF_INET socket.\n+//\n+//\t2. A wild-ipv4wild listen, \"tcp\" + \"0.0.0.0\"\n+//\tSame as 1.\n+//\n+//\t3. A wild-ipv6wild listen, \"tcp\" + \"[::]\"\n+//\tAlmost same as 1 but we prefer an IPv6 wildcard address\n+//\tlisten over an AF_INET6 socket with IPV6_V6ONLY=0 when\n+//\tthe platform supports IPv6 capability but not IPv6 IPv4-\n+//\tmapping capability.\n+//\n+//\t4. A ipv4-ipv4wild listen, \"tcp4\" + \"\" or \"0.0.0.0\"\n+//\tWe use an IPv4 (AF_INET) wildcard address listen.\n+//\n+//\t5. A ipv6-ipv6wild listen, \"tcp6\" + \"\" or \"[::]\"\n+//\tWe use an IPv6 (AF_INET6, IPV6_V6ONLY=1) wildcard address\n+//\tlisten.\n+//\n+// Otherwise guess: if the addresses are IPv4 then returns AF_INET,\n+// or else returns AF_INET6.  It also returns a boolean value what\n+// designates IPV6_V6ONLY option.\n+//\n+// Note that OpenBSD allows neither \"net.inet6.ip6.v6only=1\" change\n+// nor IPPROTO_IPV6 level IPV6_V6ONLY socket option setting.\n+func favoriteAddrFamily(net string, laddr, raddr sockaddr, mode string) (family int, ipv6only bool) {\n \tswitch net[len(net)-1] {\n \tcase '4':\n-\t\treturn syscall.AF_INET\n+\t\treturn syscall.AF_INET, false\n \tcase '6':\n-\t\treturn syscall.AF_INET6\n+\t\treturn syscall.AF_INET6, true\n \t}\n \n-\tif mode == \"listen\" {\n-\t\t// Note that OpenBSD allows neither \"net.inet6.ip6.v6only\"\n-\t\t// change nor IPPROTO_IPV6 level IPV6_V6ONLY socket option\n-\t\t// setting.\n-\t\tswitch a := laddr.(type) {\n-\t\tcase *TCPAddr:\n-\t\t\tif a.IP == nil && supportsIPv6 && supportsIPv4map {\n-\t\t\t\treturn syscall.AF_INET6\n-\t\t\t}\n-\t\tcase *UDPAddr:\n-\t\t\tif a.IP == nil && supportsIPv6 && supportsIPv4map {\n-\t\t\t\treturn syscall.AF_INET6\n-\t\t\t}\n-\t\tcase *IPAddr:\n-\t\t\tif a.IP == nil && supportsIPv6 && supportsIPv4map {\n-\t\t\t\treturn syscall.AF_INET6\n-\t\t\t}\n+\tif mode == \"listen\" && laddr.isWildcard() {\n+\t\tif supportsIPv4map {\n+\t\t\treturn syscall.AF_INET6, false\n \t\t}\n+\t\treturn laddr.family(), false\n \t}\n \n \tif (laddr == nil || laddr.family() == syscall.AF_INET) &&\n \t\t(raddr == nil || raddr.family() == syscall.AF_INET) {\n-\t\treturn syscall.AF_INET\n+\t\treturn syscall.AF_INET, false\n \t}\n-\treturn syscall.AF_INET6\n+\treturn syscall.AF_INET6, false\n }\n \n-// Internet sockets (TCP, UDP)\n+// Internet sockets (TCP, UDP, IP)\n \n-// A sockaddr represents a TCP or UDP network address that can\n+// A sockaddr represents a TCP, UDP or IP network address that can\n // be converted into a syscall.Sockaddr.\n type sockaddr interface {\n \tAddr\n-\tsockaddr(family int) (syscall.Sockaddr, error)\n \tfamily() int\n+\tisWildcard() bool\n+\tsockaddr(family int) (syscall.Sockaddr, error)\n }\n \n func internetSocket(net string, laddr, raddr sockaddr, sotype, proto int, mode string, toAddr func(syscall.Sockaddr) Addr) (fd *netFD, err error) {\n \tvar la, ra syscall.Sockaddr\n-\tfamily := favoriteAddrFamily(net, laddr, raddr, mode)\n+\tfamily, ipv6only := favoriteAddrFamily(net, laddr, raddr, mode)\n \tif laddr != nil {\n \t\tif la, err = laddr.sockaddr(family); err != nil {\n \t\t\tgoto Error\n@@ -117,7 +135,7 @@ func internetSocket(net string, laddr, raddr sockaddr, sotype, proto int, mode s\n \t\t\tgoto Error\n \t\t}\n \t}\n-\tfd, err = socket(net, family, sotype, proto, la, ra, toAddr)\n+\tfd, err = socket(net, family, sotype, proto, ipv6only, la, ra, toAddr)\n \tif err != nil {\n \t\tgoto Error\n \t}\n@@ -152,7 +170,7 @@ func ipToSockaddr(family int, ip IP, port int) (syscall.Sockaddr, error) {\n \t\t}\n \t\t// IPv4 callers use 0.0.0.0 to mean \"announce on any available address\".\n \t\t// In IPv6 mode, Linux treats that as meaning \"announce on 0.0.0.0\",\n-\t\t// which it refuses to do.  Rewrite to the IPv6 all zeros.\n+\t\t// which it refuses to do.  Rewrite to the IPv6 unspecified address.\n \t\tif ip.Equal(IPv4zero) {\n \t\t\tip = IPv6zero\n \t\t}"}, {"sha": "d616b1f689f46db6ec9ca3b025713ba362523400", "filename": "libgo/go/net/mac.go", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Fmac.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Fmac.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fmac.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -6,24 +6,26 @@\n \n package net\n \n-import (\n-\t\"bytes\"\n-\t\"errors\"\n-\t\"fmt\"\n-)\n+import \"errors\"\n+\n+const hexDigit = \"0123456789abcdef\"\n \n // A HardwareAddr represents a physical hardware address.\n type HardwareAddr []byte\n \n func (a HardwareAddr) String() string {\n-\tvar buf bytes.Buffer\n+\tif len(a) == 0 {\n+\t\treturn \"\"\n+\t}\n+\tbuf := make([]byte, 0, len(a)*3-1)\n \tfor i, b := range a {\n \t\tif i > 0 {\n-\t\t\tbuf.WriteByte(':')\n+\t\t\tbuf = append(buf, ':')\n \t\t}\n-\t\tfmt.Fprintf(&buf, \"%02x\", b)\n+\t\tbuf = append(buf, hexDigit[b>>4])\n+\t\tbuf = append(buf, hexDigit[b&0xF])\n \t}\n-\treturn buf.String()\n+\treturn string(buf)\n }\n \n // ParseMAC parses s as an IEEE 802 MAC-48, EUI-48, or EUI-64 using one of the"}, {"sha": "8f9dc6685f88a5292104e5b25e1cb8c7765a7e39", "filename": "libgo/go/net/mac_test.go", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Fmac_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Fmac_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fmac_test.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -43,12 +43,24 @@ func match(err error, s string) bool {\n \treturn err != nil && strings.Contains(err.Error(), s)\n }\n \n-func TestParseMAC(t *testing.T) {\n-\tfor _, tt := range mactests {\n+func TestMACParseString(t *testing.T) {\n+\tfor i, tt := range mactests {\n \t\tout, err := ParseMAC(tt.in)\n \t\tif !reflect.DeepEqual(out, tt.out) || !match(err, tt.err) {\n \t\t\tt.Errorf(\"ParseMAC(%q) = %v, %v, want %v, %v\", tt.in, out, err, tt.out,\n \t\t\t\ttt.err)\n \t\t}\n+\t\tif tt.err == \"\" {\n+\t\t\t// Verify that serialization works too, and that it round-trips.\n+\t\t\ts := out.String()\n+\t\t\tout2, err := ParseMAC(s)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Errorf(\"%d. ParseMAC(%q) = %v\", i, s, err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif !reflect.DeepEqual(out2, out) {\n+\t\t\t\tt.Errorf(\"%d. ParseMAC(%q) = %v, want %v\", i, s, out2, out)\n+\t\t\t}\n+\t\t}\n \t}\n }"}, {"sha": "0917bbedf1b3eb4e6dda4c6f0220dc609524d267", "filename": "libgo/go/net/mail/message.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Fmail%2Fmessage.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Fmail%2Fmessage.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fmail%2Fmessage.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -394,8 +394,7 @@ func (p *addrParser) consumeAtom(dot bool) (atom string, err error) {\n \ti := 1\n \tfor ; i < p.len() && isAtext((*p)[i], dot); i++ {\n \t}\n-\t// TODO(dsymonds): Remove the []byte() conversion here when 6g doesn't need it.\n-\tatom, *p = string([]byte((*p)[:i])), (*p)[i:]\n+\tatom, *p = string((*p)[:i]), (*p)[i:]\n \treturn atom, nil\n }\n "}, {"sha": "67261b1ee775dea2da9f5a9d95656c0034e32535", "filename": "libgo/go/net/multicast_test.go", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Fmulticast_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Fmulticast_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fmulticast_test.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -47,9 +47,11 @@ var multicastListenerTests = []struct {\n func TestMulticastListener(t *testing.T) {\n \tswitch runtime.GOOS {\n \tcase \"netbsd\", \"openbsd\", \"plan9\", \"windows\":\n+\t\tt.Logf(\"skipping test on %q\", runtime.GOOS)\n \t\treturn\n \tcase \"linux\":\n \t\tif runtime.GOARCH == \"arm\" || runtime.GOARCH == \"alpha\" {\n+\t\t\tt.Logf(\"skipping test on %q/%q\", runtime.GOOS, runtime.GOARCH)\n \t\t\treturn\n \t\t}\n \t}\n@@ -86,7 +88,13 @@ func TestMulticastListener(t *testing.T) {\n func TestSimpleMulticastListener(t *testing.T) {\n \tswitch runtime.GOOS {\n \tcase \"plan9\":\n+\t\tt.Logf(\"skipping test on %q\", runtime.GOOS)\n \t\treturn\n+\tcase \"windows\":\n+\t\tif testing.Short() || !*testExternal {\n+\t\t\tt.Logf(\"skipping test on windows to avoid firewall\")\n+\t\t\treturn\n+\t\t}\n \t}\n \n \tfor _, tt := range multicastListenerTests {"}, {"sha": "9ebcdbe996cde22c7c4bdd0261619ded64af703a", "filename": "libgo/go/net/net.go", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Fnet.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Fnet.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fnet.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -54,6 +54,8 @@ type Addr interface {\n }\n \n // Conn is a generic stream-oriented network connection.\n+//\n+// Multiple goroutines may invoke methods on a Conn simultaneously.\n type Conn interface {\n \t// Read reads data from the connection.\n \t// Read can be made to time out and return a Error with Timeout() == true\n@@ -66,6 +68,7 @@ type Conn interface {\n \tWrite(b []byte) (n int, err error)\n \n \t// Close closes the connection.\n+\t// Any blocked Read or Write operations will be unblocked and return errors.\n \tClose() error\n \n \t// LocalAddr returns the local network address.\n@@ -89,11 +92,11 @@ type Conn interface {\n \t// A zero value for t means I/O operations will not time out.\n \tSetDeadline(t time.Time) error\n \n-\t// SetReadDeadline sets the deadline for Read calls.\n+\t// SetReadDeadline sets the deadline for future Read calls.\n \t// A zero value for t means Read will not time out.\n \tSetReadDeadline(t time.Time) error\n \n-\t// SetWriteDeadline sets the deadline for Write calls.\n+\t// SetWriteDeadline sets the deadline for future Write calls.\n \t// Even if write times out, it may return n > 0, indicating that\n \t// some of the data was successfully written.\n \t// A zero value for t means Write will not time out.\n@@ -108,6 +111,8 @@ type Error interface {\n }\n \n // PacketConn is a generic packet-oriented network connection.\n+//\n+// Multiple goroutines may invoke methods on a PacketConn simultaneously.\n type PacketConn interface {\n \t// ReadFrom reads a packet from the connection,\n \t// copying the payload into b.  It returns the number of\n@@ -126,6 +131,7 @@ type PacketConn interface {\n \tWriteTo(b []byte, addr Addr) (n int, err error)\n \n \t// Close closes the connection.\n+\t// Any blocked ReadFrom or WriteTo operations will be unblocked and return errors.\n \tClose() error\n \n \t// LocalAddr returns the local network address.\n@@ -135,13 +141,13 @@ type PacketConn interface {\n \t// with the connection.\n \tSetDeadline(t time.Time) error\n \n-\t// SetReadDeadline sets the deadline for all Read calls to return.\n+\t// SetReadDeadline sets the deadline for future Read calls.\n \t// If the deadline is reached, Read will fail with a timeout\n \t// (see type Error) instead of blocking.\n \t// A zero value for t means Read will not time out.\n \tSetReadDeadline(t time.Time) error\n \n-\t// SetWriteDeadline sets the deadline for all Write calls to return.\n+\t// SetWriteDeadline sets the deadline for future Write calls.\n \t// If the deadline is reached, Write will fail with a timeout\n \t// (see type Error) instead of blocking.\n \t// A zero value for t means Write will not time out.\n@@ -151,11 +157,14 @@ type PacketConn interface {\n }\n \n // A Listener is a generic network listener for stream-oriented protocols.\n+//\n+// Multiple goroutines may invoke methods on a Listener simultaneously.\n type Listener interface {\n \t// Accept waits for and returns the next connection to the listener.\n \tAccept() (c Conn, err error)\n \n \t// Close closes the listener.\n+\t// Any blocked Accept operations will be unblocked and return errors.\n \tClose() error\n \n \t// Addr returns the listener's network address."}, {"sha": "fd145e1d70fa8e3d9ec4058cda9806d4379d3365", "filename": "libgo/go/net/net_test.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Fnet_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Fnet_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fnet_test.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -13,6 +13,7 @@ import (\n \n func TestShutdown(t *testing.T) {\n \tif runtime.GOOS == \"plan9\" {\n+\t\tt.Logf(\"skipping test on %q\", runtime.GOOS)\n \t\treturn\n \t}\n \tl, err := Listen(\"tcp\", \"127.0.0.1:0\")"}, {"sha": "30fda45dfd4e70d6f42e2e7f44ebfd456f09a0fd", "filename": "libgo/go/net/parse_test.go", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Fparse_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Fparse_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fparse_test.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -13,7 +13,9 @@ import (\n \n func TestReadLine(t *testing.T) {\n \t// /etc/services file does not exist on windows and Plan 9.\n-\tif runtime.GOOS == \"windows\" || runtime.GOOS == \"plan9\" {\n+\tswitch runtime.GOOS {\n+\tcase \"plan9\", \"windows\":\n+\t\tt.Logf(\"skipping test on %q\", runtime.GOOS)\n \t\treturn\n \t}\n \tfilename := \"/etc/services\" // a nice big file"}, {"sha": "db2da8e4418d32ba2c6200d1e263eebe0206068a", "filename": "libgo/go/net/rpc/client.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Frpc%2Fclient.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Frpc%2Fclient.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Frpc%2Fclient.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -36,7 +36,8 @@ type Call struct {\n \n // Client represents an RPC Client.\n // There may be multiple outstanding Calls associated\n-// with a single Client.\n+// with a single Client, and a Client may be used by\n+// multiple goroutines simultaneously.\n type Client struct {\n \tmutex    sync.Mutex // protects pending, seq, request\n \tsending  sync.Mutex"}, {"sha": "158b9477d03a8595fa5b8960e45a0ca2d154d5f2", "filename": "libgo/go/net/server_test.go", "status": "modified", "additions": 387, "deletions": 160, "changes": 547, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Fserver_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Fserver_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fserver_test.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -9,234 +9,461 @@ import (\n \t\"io\"\n \t\"os\"\n \t\"runtime\"\n-\t\"strings\"\n \t\"testing\"\n \t\"time\"\n )\n \n-// Do not test empty datagrams by default.\n-// It causes unexplained timeouts on some systems,\n-// including Snow Leopard.  I think that the kernel\n-// doesn't quite expect them.\n-var testUDP = flag.Bool(\"udp\", false, \"whether to test UDP datagrams\")\n+func skipServerTest(net, unixsotype, addr string, ipv6, ipv4map, linuxonly bool) bool {\n+\tswitch runtime.GOOS {\n+\tcase \"linux\":\n+\tcase \"plan9\", \"windows\":\n+\t\t// \"unix\" sockets are not supported on Windows and Plan 9.\n+\t\tif net == unixsotype {\n+\t\t\treturn true\n+\t\t}\n+\tdefault:\n+\t\tif net == unixsotype && linuxonly {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\tswitch addr {\n+\tcase \"\", \"0.0.0.0\", \"[::ffff:0.0.0.0]\", \"[::]\":\n+\t\tif testing.Short() || !*testExternal {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\tif ipv6 && !supportsIPv6 {\n+\t\treturn true\n+\t}\n+\tif ipv4map && !supportsIPv4map {\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n \n-func runEcho(fd io.ReadWriter, done chan<- int) {\n-\tvar buf [1024]byte\n+var streamConnServerTests = []struct {\n+\tsnet    string // server side\n+\tsaddr   string\n+\tcnet    string // client side\n+\tcaddr   string\n+\tipv6    bool // test with underlying AF_INET6 socket\n+\tipv4map bool // test with IPv6 IPv4-mapping functionality\n+\tempty   bool // test with empty data\n+\tlinux   bool // test with abstract unix domain socket, a Linux-ism\n+}{\n+\t{snet: \"tcp\", saddr: \"\", cnet: \"tcp\", caddr: \"127.0.0.1\"},\n+\t{snet: \"tcp\", saddr: \"0.0.0.0\", cnet: \"tcp\", caddr: \"127.0.0.1\"},\n+\t{snet: \"tcp\", saddr: \"[::ffff:0.0.0.0]\", cnet: \"tcp\", caddr: \"127.0.0.1\"},\n+\t{snet: \"tcp\", saddr: \"[::]\", cnet: \"tcp\", caddr: \"[::1]\", ipv6: true},\n \n-\tfor {\n-\t\tn, err := fd.Read(buf[0:])\n-\t\tif err != nil || n == 0 || string(buf[:n]) == \"END\" {\n-\t\t\tbreak\n+\t{snet: \"tcp\", saddr: \"\", cnet: \"tcp\", caddr: \"[::1]\", ipv4map: true},\n+\t{snet: \"tcp\", saddr: \"0.0.0.0\", cnet: \"tcp\", caddr: \"[::1]\", ipv4map: true},\n+\t{snet: \"tcp\", saddr: \"[::ffff:0.0.0.0]\", cnet: \"tcp\", caddr: \"[::1]\", ipv4map: true},\n+\t{snet: \"tcp\", saddr: \"[::]\", cnet: \"tcp\", caddr: \"127.0.0.1\", ipv4map: true},\n+\n+\t{snet: \"tcp\", saddr: \"\", cnet: \"tcp4\", caddr: \"127.0.0.1\"},\n+\t{snet: \"tcp\", saddr: \"0.0.0.0\", cnet: \"tcp4\", caddr: \"127.0.0.1\"},\n+\t{snet: \"tcp\", saddr: \"[::ffff:0.0.0.0]\", cnet: \"tcp4\", caddr: \"127.0.0.1\"},\n+\t{snet: \"tcp\", saddr: \"[::]\", cnet: \"tcp6\", caddr: \"[::1]\", ipv6: true},\n+\n+\t{snet: \"tcp\", saddr: \"\", cnet: \"tcp6\", caddr: \"[::1]\", ipv4map: true},\n+\t{snet: \"tcp\", saddr: \"0.0.0.0\", cnet: \"tcp6\", caddr: \"[::1]\", ipv4map: true},\n+\t{snet: \"tcp\", saddr: \"[::ffff:0.0.0.0]\", cnet: \"tcp6\", caddr: \"[::1]\", ipv4map: true},\n+\t{snet: \"tcp\", saddr: \"[::]\", cnet: \"tcp4\", caddr: \"127.0.0.1\", ipv4map: true},\n+\n+\t{snet: \"tcp\", saddr: \"127.0.0.1\", cnet: \"tcp\", caddr: \"127.0.0.1\"},\n+\t{snet: \"tcp\", saddr: \"[::ffff:127.0.0.1]\", cnet: \"tcp\", caddr: \"127.0.0.1\"},\n+\t{snet: \"tcp\", saddr: \"[::1]\", cnet: \"tcp\", caddr: \"[::1]\", ipv6: true},\n+\n+\t{snet: \"tcp4\", saddr: \"\", cnet: \"tcp4\", caddr: \"127.0.0.1\"},\n+\t{snet: \"tcp4\", saddr: \"0.0.0.0\", cnet: \"tcp4\", caddr: \"127.0.0.1\"},\n+\t{snet: \"tcp4\", saddr: \"[::ffff:0.0.0.0]\", cnet: \"tcp4\", caddr: \"127.0.0.1\"},\n+\n+\t{snet: \"tcp4\", saddr: \"127.0.0.1\", cnet: \"tcp4\", caddr: \"127.0.0.1\"},\n+\n+\t{snet: \"tcp6\", saddr: \"\", cnet: \"tcp6\", caddr: \"[::1]\", ipv6: true},\n+\t{snet: \"tcp6\", saddr: \"[::]\", cnet: \"tcp6\", caddr: \"[::1]\", ipv6: true},\n+\n+\t{snet: \"tcp6\", saddr: \"[::1]\", cnet: \"tcp6\", caddr: \"[::1]\", ipv6: true},\n+\n+\t{snet: \"unix\", saddr: \"/tmp/gotest1.net\", cnet: \"unix\", caddr: \"/tmp/gotest1.net.local\"},\n+\t{snet: \"unix\", saddr: \"@gotest2/net\", cnet: \"unix\", caddr: \"@gotest2/net.local\", linux: true},\n+}\n+\n+func TestStreamConnServer(t *testing.T) {\n+\tfor _, tt := range streamConnServerTests {\n+\t\tif skipServerTest(tt.snet, \"unix\", tt.saddr, tt.ipv6, tt.ipv4map, tt.linux) {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tlistening := make(chan string)\n+\t\tdone := make(chan int)\n+\t\tswitch tt.snet {\n+\t\tcase \"tcp\", \"tcp4\", \"tcp6\":\n+\t\t\ttt.saddr += \":0\"\n+\t\tcase \"unix\":\n+\t\t\tos.Remove(tt.saddr)\n+\t\t\tos.Remove(tt.caddr)\n+\t\t}\n+\n+\t\tgo runStreamConnServer(t, tt.snet, tt.saddr, listening, done)\n+\t\ttaddr := <-listening // wait for server to start\n+\n+\t\tswitch tt.cnet {\n+\t\tcase \"tcp\", \"tcp4\", \"tcp6\":\n+\t\t\t_, port, err := SplitHostPort(taddr)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Errorf(\"SplitHostPort(%q) failed: %v\", taddr, err)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\ttaddr = tt.caddr + \":\" + port\n+\t\t}\n+\n+\t\trunStreamConnClient(t, tt.cnet, taddr, tt.empty)\n+\t\t<-done // make sure server stopped\n+\n+\t\tswitch tt.snet {\n+\t\tcase \"unix\":\n+\t\t\tos.Remove(tt.saddr)\n+\t\t\tos.Remove(tt.caddr)\n+\t\t}\n+\t}\n+}\n+\n+var seqpacketConnServerTests = []struct {\n+\tnet   string\n+\tsaddr string // server address\n+\tcaddr string // client address\n+\tempty bool   // test with empty data\n+}{\n+\t{net: \"unixpacket\", saddr: \"/tmp/gotest3.net\", caddr: \"/tmp/gotest3.net.local\"},\n+\t{net: \"unixpacket\", saddr: \"@gotest4/net\", caddr: \"@gotest4/net.local\"},\n+}\n+\n+func TestSeqpacketConnServer(t *testing.T) {\n+\tif runtime.GOOS != \"linux\" {\n+\t\tt.Logf(\"skipping test on %q\", runtime.GOOS)\n+\t\treturn\n+\t}\n+\n+\tfor _, tt := range seqpacketConnServerTests {\n+\t\tlistening := make(chan string)\n+\t\tdone := make(chan int)\n+\t\tswitch tt.net {\n+\t\tcase \"unixpacket\":\n+\t\t\tos.Remove(tt.saddr)\n+\t\t\tos.Remove(tt.caddr)\n+\t\t}\n+\n+\t\tgo runStreamConnServer(t, tt.net, tt.saddr, listening, done)\n+\t\ttaddr := <-listening // wait for server to start\n+\n+\t\trunStreamConnClient(t, tt.net, taddr, tt.empty)\n+\t\t<-done // make sure server stopped\n+\n+\t\tswitch tt.net {\n+\t\tcase \"unixpacket\":\n+\t\t\tos.Remove(tt.saddr)\n+\t\t\tos.Remove(tt.caddr)\n \t\t}\n-\t\tfd.Write(buf[0:n])\n \t}\n-\tdone <- 1\n }\n \n-func runServe(t *testing.T, network, addr string, listening chan<- string, done chan<- int) {\n-\tl, err := Listen(network, addr)\n+func runStreamConnServer(t *testing.T, net, laddr string, listening chan<- string, done chan<- int) {\n+\tl, err := Listen(net, laddr)\n \tif err != nil {\n-\t\tt.Fatalf(\"net.Listen(%q, %q) = _, %v\", network, addr, err)\n+\t\tt.Errorf(\"Listen(%q, %q) failed: %v\", net, laddr, err)\n+\t\tlistening <- \"<nil>\"\n+\t\tdone <- 1\n+\t\treturn\n \t}\n+\tdefer l.Close()\n \tlistening <- l.Addr().String()\n \n+\techo := func(rw io.ReadWriter, done chan<- int) {\n+\t\tbuf := make([]byte, 1024)\n+\t\tfor {\n+\t\t\tn, err := rw.Read(buf[0:])\n+\t\t\tif err != nil || n == 0 || string(buf[:n]) == \"END\" {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\trw.Write(buf[0:n])\n+\t\t}\n+\t\tdone <- 1\n+\t}\n+\n+run:\n \tfor {\n-\t\tfd, err := l.Accept()\n+\t\tc, err := l.Accept()\n \t\tif err != nil {\n-\t\t\tbreak\n+\t\t\tcontinue run\n \t\t}\n \t\techodone := make(chan int)\n-\t\tgo runEcho(fd, echodone)\n-\t\t<-echodone // make sure Echo stops\n-\t\tl.Close()\n+\t\tgo echo(c, echodone)\n+\t\t<-echodone // make sure echo stopped\n+\t\tc.Close()\n+\t\tbreak run\n \t}\n \tdone <- 1\n }\n \n-func connect(t *testing.T, network, addr string, isEmpty bool) {\n-\tvar fd Conn\n-\tvar err error\n-\tif network == \"unixgram\" {\n-\t\tfd, err = DialUnix(network, &UnixAddr{addr + \".local\", network}, &UnixAddr{addr, network})\n-\t} else {\n-\t\tfd, err = Dial(network, addr)\n-\t}\n+func runStreamConnClient(t *testing.T, net, taddr string, isEmpty bool) {\n+\tc, err := Dial(net, taddr)\n \tif err != nil {\n-\t\tt.Fatalf(\"net.Dial(%q, %q) = _, %v\", network, addr, err)\n+\t\tt.Errorf(\"Dial(%q, %q) failed: %v\", net, taddr, err)\n+\t\treturn\n \t}\n-\tfd.SetReadDeadline(time.Now().Add(1 * time.Second))\n+\tdefer c.Close()\n+\tc.SetReadDeadline(time.Now().Add(1 * time.Second))\n \n-\tvar b []byte\n+\tvar wb []byte\n \tif !isEmpty {\n-\t\tb = []byte(\"hello, world\\n\")\n+\t\twb = []byte(\"StreamConnClient by Dial\\n\")\n \t}\n-\tvar b1 [100]byte\n-\n-\tn, err1 := fd.Write(b)\n-\tif n != len(b) {\n-\t\tt.Fatalf(\"fd.Write(%q) = %d, %v\", b, n, err1)\n+\tif n, err := c.Write(wb); err != nil || n != len(wb) {\n+\t\tt.Errorf(\"Write failed: %v, %v; want %v, <nil>\", n, err, len(wb))\n+\t\treturn\n \t}\n \n-\tn, err1 = fd.Read(b1[0:])\n-\tif n != len(b) || err1 != nil {\n-\t\tt.Fatalf(\"fd.Read() = %d, %v (want %d, nil)\", n, err1, len(b))\n+\trb := make([]byte, 1024)\n+\tif n, err := c.Read(rb[0:]); err != nil || n != len(wb) {\n+\t\tt.Errorf(\"Read failed: %v, %v; want %v, <nil>\", n, err, len(wb))\n+\t\treturn\n \t}\n \n \t// Send explicit ending for unixpacket.\n \t// Older Linux kernels do not stop reads on close.\n-\tif network == \"unixpacket\" {\n-\t\tfd.Write([]byte(\"END\"))\n+\tswitch net {\n+\tcase \"unixpacket\":\n+\t\tc.Write([]byte(\"END\"))\n \t}\n-\n-\tfd.Close()\n }\n \n-func doTest(t *testing.T, network, listenaddr, dialaddr string) {\n-\tt.Logf(\"Test %q %q %q\", network, listenaddr, dialaddr)\n-\tswitch listenaddr {\n-\tcase \"\", \"0.0.0.0\", \"[::]\", \"[::ffff:0.0.0.0]\":\n-\t\tif testing.Short() || !*testExternal {\n-\t\t\tt.Logf(\"skip wildcard listen during short test\")\n-\t\t\treturn\n-\t\t}\n-\t}\n-\tlistening := make(chan string)\n-\tdone := make(chan int)\n-\tif network == \"tcp\" || network == \"tcp4\" || network == \"tcp6\" {\n-\t\tlistenaddr += \":0\" // any available port\n-\t}\n-\tgo runServe(t, network, listenaddr, listening, done)\n-\taddr := <-listening // wait for server to start\n-\tif network == \"tcp\" || network == \"tcp4\" || network == \"tcp6\" {\n-\t\tdialaddr += addr[strings.LastIndex(addr, \":\"):]\n-\t}\n-\tconnect(t, network, dialaddr, false)\n-\t<-done // make sure server stopped\n-}\n+// Do not test empty datagrams by default.\n+// It causes unexplained timeouts on some systems,\n+// including Snow Leopard.  I think that the kernel\n+// doesn't quite expect them.\n+var testDatagram = flag.Bool(\"datagram\", false, \"whether to test udp and unixgram\")\n \n-func TestTCPServer(t *testing.T) {\n-\tdoTest(t, \"tcp\", \"\", \"127.0.0.1\")\n-\tdoTest(t, \"tcp\", \"0.0.0.0\", \"127.0.0.1\")\n-\tdoTest(t, \"tcp\", \"127.0.0.1\", \"127.0.0.1\")\n-\tdoTest(t, \"tcp4\", \"\", \"127.0.0.1\")\n-\tdoTest(t, \"tcp4\", \"0.0.0.0\", \"127.0.0.1\")\n-\tdoTest(t, \"tcp4\", \"127.0.0.1\", \"127.0.0.1\")\n-\tif supportsIPv6 {\n-\t\tdoTest(t, \"tcp\", \"[::]\", \"[::1]\")\n-\t\tdoTest(t, \"tcp\", \"[::1]\", \"[::1]\")\n-\t\tdoTest(t, \"tcp6\", \"\", \"[::1]\")\n-\t\tdoTest(t, \"tcp6\", \"[::]\", \"[::1]\")\n-\t\tdoTest(t, \"tcp6\", \"[::1]\", \"[::1]\")\n-\t}\n-\tif supportsIPv6 && supportsIPv4map {\n-\t\tdoTest(t, \"tcp\", \"[::ffff:0.0.0.0]\", \"127.0.0.1\")\n-\t\tdoTest(t, \"tcp\", \"[::]\", \"127.0.0.1\")\n-\t\tdoTest(t, \"tcp4\", \"[::ffff:0.0.0.0]\", \"127.0.0.1\")\n-\t\tdoTest(t, \"tcp6\", \"\", \"127.0.0.1\")\n-\t\tdoTest(t, \"tcp6\", \"[::ffff:0.0.0.0]\", \"127.0.0.1\")\n-\t\tdoTest(t, \"tcp6\", \"[::]\", \"127.0.0.1\")\n-\t\tdoTest(t, \"tcp\", \"127.0.0.1\", \"[::ffff:127.0.0.1]\")\n-\t\tdoTest(t, \"tcp\", \"[::ffff:127.0.0.1]\", \"127.0.0.1\")\n-\t\tdoTest(t, \"tcp4\", \"127.0.0.1\", \"[::ffff:127.0.0.1]\")\n-\t\tdoTest(t, \"tcp4\", \"[::ffff:127.0.0.1]\", \"127.0.0.1\")\n-\t\tdoTest(t, \"tcp6\", \"127.0.0.1\", \"[::ffff:127.0.0.1]\")\n-\t\tdoTest(t, \"tcp6\", \"[::ffff:127.0.0.1]\", \"127.0.0.1\")\n-\t}\n+var datagramPacketConnServerTests = []struct {\n+\tsnet    string // server side\n+\tsaddr   string\n+\tcnet    string // client side\n+\tcaddr   string\n+\tipv6    bool // test with underlying AF_INET6 socket\n+\tipv4map bool // test with IPv6 IPv4-mapping functionality\n+\tdial    bool // test with Dial or DialUnix\n+\tempty   bool // test with empty data\n+\tlinux   bool // test with abstract unix domain socket, a Linux-ism\n+}{\n+\t{snet: \"udp\", saddr: \"\", cnet: \"udp\", caddr: \"127.0.0.1\"},\n+\t{snet: \"udp\", saddr: \"0.0.0.0\", cnet: \"udp\", caddr: \"127.0.0.1\"},\n+\t{snet: \"udp\", saddr: \"[::ffff:0.0.0.0]\", cnet: \"udp\", caddr: \"127.0.0.1\"},\n+\t{snet: \"udp\", saddr: \"[::]\", cnet: \"udp\", caddr: \"[::1]\", ipv6: true},\n+\n+\t{snet: \"udp\", saddr: \"\", cnet: \"udp\", caddr: \"[::1]\", ipv4map: true},\n+\t{snet: \"udp\", saddr: \"0.0.0.0\", cnet: \"udp\", caddr: \"[::1]\", ipv4map: true},\n+\t{snet: \"udp\", saddr: \"[::ffff:0.0.0.0]\", cnet: \"udp\", caddr: \"[::1]\", ipv4map: true},\n+\t{snet: \"udp\", saddr: \"[::]\", cnet: \"udp\", caddr: \"127.0.0.1\", ipv4map: true},\n+\n+\t{snet: \"udp\", saddr: \"\", cnet: \"udp4\", caddr: \"127.0.0.1\"},\n+\t{snet: \"udp\", saddr: \"0.0.0.0\", cnet: \"udp4\", caddr: \"127.0.0.1\"},\n+\t{snet: \"udp\", saddr: \"[::ffff:0.0.0.0]\", cnet: \"udp4\", caddr: \"127.0.0.1\"},\n+\t{snet: \"udp\", saddr: \"[::]\", cnet: \"udp6\", caddr: \"[::1]\", ipv6: true},\n+\n+\t{snet: \"udp\", saddr: \"\", cnet: \"udp6\", caddr: \"[::1]\", ipv4map: true},\n+\t{snet: \"udp\", saddr: \"0.0.0.0\", cnet: \"udp6\", caddr: \"[::1]\", ipv4map: true},\n+\t{snet: \"udp\", saddr: \"[::ffff:0.0.0.0]\", cnet: \"udp6\", caddr: \"[::1]\", ipv4map: true},\n+\t{snet: \"udp\", saddr: \"[::]\", cnet: \"udp4\", caddr: \"127.0.0.1\", ipv4map: true},\n+\n+\t{snet: \"udp\", saddr: \"127.0.0.1\", cnet: \"udp\", caddr: \"127.0.0.1\"},\n+\t{snet: \"udp\", saddr: \"[::ffff:127.0.0.1]\", cnet: \"udp\", caddr: \"127.0.0.1\"},\n+\t{snet: \"udp\", saddr: \"[::1]\", cnet: \"udp\", caddr: \"[::1]\", ipv6: true},\n+\n+\t{snet: \"udp4\", saddr: \"\", cnet: \"udp4\", caddr: \"127.0.0.1\"},\n+\t{snet: \"udp4\", saddr: \"0.0.0.0\", cnet: \"udp4\", caddr: \"127.0.0.1\"},\n+\t{snet: \"udp4\", saddr: \"[::ffff:0.0.0.0]\", cnet: \"udp4\", caddr: \"127.0.0.1\"},\n+\n+\t{snet: \"udp4\", saddr: \"127.0.0.1\", cnet: \"udp4\", caddr: \"127.0.0.1\"},\n+\n+\t{snet: \"udp6\", saddr: \"\", cnet: \"udp6\", caddr: \"[::1]\", ipv6: true},\n+\t{snet: \"udp6\", saddr: \"[::]\", cnet: \"udp6\", caddr: \"[::1]\", ipv6: true},\n+\n+\t{snet: \"udp6\", saddr: \"[::1]\", cnet: \"udp6\", caddr: \"[::1]\", ipv6: true},\n+\n+\t{snet: \"udp\", saddr: \"127.0.0.1\", cnet: \"udp\", caddr: \"127.0.0.1\", dial: true},\n+\t{snet: \"udp\", saddr: \"127.0.0.1\", cnet: \"udp\", caddr: \"127.0.0.1\", empty: true},\n+\t{snet: \"udp\", saddr: \"127.0.0.1\", cnet: \"udp\", caddr: \"127.0.0.1\", dial: true, empty: true},\n+\n+\t{snet: \"udp\", saddr: \"[::1]\", cnet: \"udp\", caddr: \"[::1]\", ipv6: true, dial: true},\n+\t{snet: \"udp\", saddr: \"[::1]\", cnet: \"udp\", caddr: \"[::1]\", ipv6: true, empty: true},\n+\t{snet: \"udp\", saddr: \"[::1]\", cnet: \"udp\", caddr: \"[::1]\", ipv6: true, dial: true, empty: true},\n+\n+\t{snet: \"unixgram\", saddr: \"/tmp/gotest5.net\", cnet: \"unixgram\", caddr: \"/tmp/gotest5.net.local\"},\n+\t{snet: \"unixgram\", saddr: \"/tmp/gotest5.net\", cnet: \"unixgram\", caddr: \"/tmp/gotest5.net.local\", dial: true},\n+\t{snet: \"unixgram\", saddr: \"/tmp/gotest5.net\", cnet: \"unixgram\", caddr: \"/tmp/gotest5.net.local\", empty: true},\n+\t{snet: \"unixgram\", saddr: \"/tmp/gotest5.net\", cnet: \"unixgram\", caddr: \"/tmp/gotest5.net.local\", dial: true, empty: true},\n+\n+\t{snet: \"unixgram\", saddr: \"@gotest6/net\", cnet: \"unixgram\", caddr: \"@gotest6/net.local\", linux: true},\n }\n \n-func TestUnixServer(t *testing.T) {\n-\t// \"unix\" sockets are not supported on windows and Plan 9.\n-\tif runtime.GOOS == \"windows\" || runtime.GOOS == \"plan9\" {\n+func TestDatagramPacketConnServer(t *testing.T) {\n+\tif !*testDatagram {\n \t\treturn\n \t}\n-\tos.Remove(\"/tmp/gotest.net\")\n-\tdoTest(t, \"unix\", \"/tmp/gotest.net\", \"/tmp/gotest.net\")\n-\tos.Remove(\"/tmp/gotest.net\")\n-\tif runtime.GOOS == \"linux\" {\n-\t\tdoTest(t, \"unixpacket\", \"/tmp/gotest.net\", \"/tmp/gotest.net\")\n-\t\tos.Remove(\"/tmp/gotest.net\")\n-\t\t// Test abstract unix domain socket, a Linux-ism\n-\t\tdoTest(t, \"unix\", \"@gotest/net\", \"@gotest/net\")\n-\t\tdoTest(t, \"unixpacket\", \"@gotest/net\", \"@gotest/net\")\n+\n+\tfor _, tt := range datagramPacketConnServerTests {\n+\t\tif skipServerTest(tt.snet, \"unixgram\", tt.saddr, tt.ipv6, tt.ipv4map, tt.linux) {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tlistening := make(chan string)\n+\t\tdone := make(chan int)\n+\t\tswitch tt.snet {\n+\t\tcase \"udp\", \"udp4\", \"udp6\":\n+\t\t\ttt.saddr += \":0\"\n+\t\tcase \"unixgram\":\n+\t\t\tos.Remove(tt.saddr)\n+\t\t\tos.Remove(tt.caddr)\n+\t\t}\n+\n+\t\tgo runDatagramPacketConnServer(t, tt.snet, tt.saddr, listening, done)\n+\t\ttaddr := <-listening // wait for server to start\n+\n+\t\tswitch tt.cnet {\n+\t\tcase \"udp\", \"udp4\", \"udp6\":\n+\t\t\t_, port, err := SplitHostPort(taddr)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Errorf(\"SplitHostPort(%q) failed: %v\", taddr, err)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\ttaddr = tt.caddr + \":\" + port\n+\t\t\ttt.caddr += \":0\"\n+\t\t}\n+\t\tif tt.dial {\n+\t\t\trunDatagramConnClient(t, tt.cnet, tt.caddr, taddr, tt.empty)\n+\t\t} else {\n+\t\t\trunDatagramPacketConnClient(t, tt.cnet, tt.caddr, taddr, tt.empty)\n+\t\t}\n+\t\t<-done // tell server to stop\n+\t\t<-done // make sure server stopped\n+\n+\t\tswitch tt.snet {\n+\t\tcase \"unixgram\":\n+\t\t\tos.Remove(tt.saddr)\n+\t\t\tos.Remove(tt.caddr)\n+\t\t}\n \t}\n }\n \n-func runPacket(t *testing.T, network, addr string, listening chan<- string, done chan<- int) {\n-\tc, err := ListenPacket(network, addr)\n+func runDatagramPacketConnServer(t *testing.T, net, laddr string, listening chan<- string, done chan<- int) {\n+\tc, err := ListenPacket(net, laddr)\n \tif err != nil {\n-\t\tt.Fatalf(\"net.ListenPacket(%q, %q) = _, %v\", network, addr, err)\n+\t\tt.Errorf(\"ListenPacket(%q, %q) failed: %v\", net, laddr, err)\n+\t\tlistening <- \"<nil>\"\n+\t\tdone <- 1\n+\t\treturn\n \t}\n+\tdefer c.Close()\n \tlistening <- c.LocalAddr().String()\n-\tvar buf [1000]byte\n-Run:\n+\n+\tbuf := make([]byte, 1024)\n+run:\n \tfor {\n \t\tc.SetReadDeadline(time.Now().Add(10 * time.Millisecond))\n-\t\tn, addr, err := c.ReadFrom(buf[0:])\n-\t\tif e, ok := err.(Error); ok && e.Timeout() {\n+\t\tn, ra, err := c.ReadFrom(buf[0:])\n+\t\tif nerr, ok := err.(Error); ok && nerr.Timeout() {\n \t\t\tselect {\n \t\t\tcase done <- 1:\n-\t\t\t\tbreak Run\n+\t\t\t\tbreak run\n \t\t\tdefault:\n-\t\t\t\tcontinue Run\n+\t\t\t\tcontinue run\n \t\t\t}\n \t\t}\n \t\tif err != nil {\n-\t\t\tbreak\n+\t\t\tbreak run\n \t\t}\n-\t\tif _, err = c.WriteTo(buf[0:n], addr); err != nil {\n-\t\t\tt.Fatalf(\"WriteTo %v: %v\", addr, err)\n+\t\tif _, err = c.WriteTo(buf[0:n], ra); err != nil {\n+\t\t\tt.Errorf(\"WriteTo(%v) failed: %v\", ra, err)\n+\t\t\tbreak run\n \t\t}\n \t}\n-\tc.Close()\n \tdone <- 1\n }\n \n-func doTestPacket(t *testing.T, network, listenaddr, dialaddr string, isEmpty bool) {\n-\tt.Logf(\"TestPacket %q %q %q\", network, listenaddr, dialaddr)\n-\tlistening := make(chan string)\n-\tdone := make(chan int)\n-\tif network == \"udp\" {\n-\t\tlistenaddr += \":0\" // any available port\n-\t}\n-\tgo runPacket(t, network, listenaddr, listening, done)\n-\taddr := <-listening // wait for server to start\n-\tif network == \"udp\" {\n-\t\tdialaddr += addr[strings.LastIndex(addr, \":\"):]\n-\t}\n-\tconnect(t, network, dialaddr, isEmpty)\n-\t<-done // tell server to stop\n-\t<-done // wait for stop\n-}\n+func runDatagramConnClient(t *testing.T, net, laddr, taddr string, isEmpty bool) {\n+\tvar c Conn\n+\tvar err error\n+\tswitch net {\n+\tcase \"udp\", \"udp4\", \"udp6\":\n+\t\tc, err = Dial(net, taddr)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"Dial(%q, %q) failed: %v\", net, taddr, err)\n+\t\t\treturn\n+\t\t}\n+\tcase \"unixgram\":\n+\t\tc, err = DialUnix(net, &UnixAddr{laddr, net}, &UnixAddr{taddr, net})\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"DialUnix(%q, {%q, %q}) failed: %v\", net, laddr, taddr, err)\n+\t\t\treturn\n+\t\t}\n+\t}\n+\tdefer c.Close()\n+\tc.SetReadDeadline(time.Now().Add(1 * time.Second))\n \n-func TestUDPServer(t *testing.T) {\n-\tif !*testUDP {\n+\tvar wb []byte\n+\tif !isEmpty {\n+\t\twb = []byte(\"DatagramConnClient by Dial\\n\")\n+\t}\n+\tif n, err := c.Write(wb[0:]); err != nil || n != len(wb) {\n+\t\tt.Errorf(\"Write failed: %v, %v; want %v, <nil>\", n, err, len(wb))\n \t\treturn\n \t}\n-\tfor _, isEmpty := range []bool{false, true} {\n-\t\tdoTestPacket(t, \"udp\", \"0.0.0.0\", \"127.0.0.1\", isEmpty)\n-\t\tdoTestPacket(t, \"udp\", \"\", \"127.0.0.1\", isEmpty)\n-\t\tif supportsIPv6 && supportsIPv4map {\n-\t\t\tdoTestPacket(t, \"udp\", \"[::]\", \"[::ffff:127.0.0.1]\", isEmpty)\n-\t\t\tdoTestPacket(t, \"udp\", \"[::]\", \"127.0.0.1\", isEmpty)\n-\t\t\tdoTestPacket(t, \"udp\", \"0.0.0.0\", \"[::ffff:127.0.0.1]\", isEmpty)\n-\t\t}\n+\n+\trb := make([]byte, 1024)\n+\tif n, err := c.Read(rb[0:]); err != nil || n != len(wb) {\n+\t\tt.Errorf(\"Read failed: %v, %v; want %v, <nil>\", n, err, len(wb))\n+\t\treturn\n \t}\n }\n \n-func TestUnixDatagramServer(t *testing.T) {\n-\t// \"unix\" sockets are not supported on windows and Plan 9.\n-\tif runtime.GOOS == \"windows\" || runtime.GOOS == \"plan9\" {\n+func runDatagramPacketConnClient(t *testing.T, net, laddr, taddr string, isEmpty bool) {\n+\tvar ra Addr\n+\tvar err error\n+\tswitch net {\n+\tcase \"udp\", \"udp4\", \"udp6\":\n+\t\tra, err = ResolveUDPAddr(net, taddr)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"ResolveUDPAddr(%q, %q) failed: %v\", net, taddr, err)\n+\t\t\treturn\n+\t\t}\n+\tcase \"unixgram\":\n+\t\tra, err = ResolveUnixAddr(net, taddr)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"ResolveUxixAddr(%q, %q) failed: %v\", net, taddr, err)\n+\t\t\treturn\n+\t\t}\n+\t}\n+\tc, err := ListenPacket(net, laddr)\n+\tif err != nil {\n+\t\tt.Errorf(\"ListenPacket(%q, %q) faild: %v\", net, laddr, err)\n \t\treturn\n \t}\n-\tfor _, isEmpty := range []bool{false} {\n-\t\tos.Remove(\"/tmp/gotest1.net\")\n-\t\tos.Remove(\"/tmp/gotest1.net.local\")\n-\t\tdoTestPacket(t, \"unixgram\", \"/tmp/gotest1.net\", \"/tmp/gotest1.net\", isEmpty)\n-\t\tos.Remove(\"/tmp/gotest1.net\")\n-\t\tos.Remove(\"/tmp/gotest1.net.local\")\n-\t\tif runtime.GOOS == \"linux\" {\n-\t\t\t// Test abstract unix domain socket, a Linux-ism\n-\t\t\tdoTestPacket(t, \"unixgram\", \"@gotest1/net\", \"@gotest1/net\", isEmpty)\n-\t\t}\n+\tdefer c.Close()\n+\tc.SetReadDeadline(time.Now().Add(1 * time.Second))\n+\n+\tvar wb []byte\n+\tif !isEmpty {\n+\t\twb = []byte(\"DatagramPacketConnClient by ListenPacket\\n\")\n+\t}\n+\tif n, err := c.WriteTo(wb[0:], ra); err != nil || n != len(wb) {\n+\t\tt.Errorf(\"WriteTo(%v) failed: %v, %v; want %v, <nil>\", ra, n, err, len(wb))\n+\t\treturn\n+\t}\n+\n+\trb := make([]byte, 1024)\n+\tif n, _, err := c.ReadFrom(rb[0:]); err != nil || n != len(wb) {\n+\t\tt.Errorf(\"ReadFrom failed: %v, %v; want %v, <nil>\", n, err, len(wb))\n+\t\treturn\n \t}\n }"}, {"sha": "3ae16054e4726a142b8ddd56f0477a171d127655", "filename": "libgo/go/net/sock.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Fsock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Fsock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsock.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -16,7 +16,7 @@ import (\n var listenerBacklog = maxListenerBacklog()\n \n // Generic socket creation.\n-func socket(net string, f, t, p int, la, ra syscall.Sockaddr, toAddr func(syscall.Sockaddr) Addr) (fd *netFD, err error) {\n+func socket(net string, f, t, p int, ipv6only bool, la, ra syscall.Sockaddr, toAddr func(syscall.Sockaddr) Addr) (fd *netFD, err error) {\n \t// See ../syscall/exec.go for description of ForkLock.\n \tsyscall.ForkLock.RLock()\n \ts, err := syscall.Socket(f, t, p)\n@@ -27,7 +27,7 @@ func socket(net string, f, t, p int, la, ra syscall.Sockaddr, toAddr func(syscal\n \tsyscall.CloseOnExec(s)\n \tsyscall.ForkLock.RUnlock()\n \n-\terr = setDefaultSockopts(s, f, t)\n+\terr = setDefaultSockopts(s, f, t, ipv6only)\n \tif err != nil {\n \t\tclosesocket(s)\n \t\treturn nil, err"}, {"sha": "0cd19266fe06cfca173a230c48c0feaea5291834", "filename": "libgo/go/net/sockopt.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Fsockopt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Fsockopt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsockopt.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -9,7 +9,6 @@\n package net\n \n import (\n-\t\"bytes\"\n \t\"os\"\n \t\"syscall\"\n \t\"time\"\n@@ -98,7 +97,7 @@ func setIPv4MreqToInterface(mreq *syscall.IPMreq, ifi *Interface) error {\n \t\t}\n \t}\n done:\n-\tif bytes.Equal(mreq.Multiaddr[:], IPv4zero.To4()) {\n+\tif bytesEqual(mreq.Multiaddr[:], IPv4zero.To4()) {\n \t\treturn errNoSuchMulticastInterface\n \t}\n \treturn nil"}, {"sha": "fff65f362b19007bee28b80c4fb627cae804dd40", "filename": "libgo/go/net/sockopt_bsd.go", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Fsockopt_bsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Fsockopt_bsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsockopt_bsd.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -13,12 +13,17 @@ import (\n \t\"syscall\"\n )\n \n-func setDefaultSockopts(s, f, t int) error {\n+func setDefaultSockopts(s, f, t int, ipv6only bool) error {\n \tswitch f {\n \tcase syscall.AF_INET6:\n-\t\t// Allow both IP versions even if the OS default is otherwise.\n-\t\t// Note that some operating systems never admit this option.\n-\t\tsyscall.SetsockoptInt(s, syscall.IPPROTO_IPV6, syscall.IPV6_V6ONLY, 0)\n+\t\tif ipv6only {\n+\t\t\tsyscall.SetsockoptInt(s, syscall.IPPROTO_IPV6, syscall.IPV6_V6ONLY, 1)\n+\t\t} else {\n+\t\t\t// Allow both IP versions even if the OS default\n+\t\t\t// is otherwise.  Note that some operating systems\n+\t\t\t// never admit this option.\n+\t\t\tsyscall.SetsockoptInt(s, syscall.IPPROTO_IPV6, syscall.IPV6_V6ONLY, 0)\n+\t\t}\n \t}\n \t// Allow broadcast.\n \terr := syscall.SetsockoptInt(s, syscall.SOL_SOCKET, syscall.SO_BROADCAST, 1)"}, {"sha": "0f47538c541254731c4374299b5d97105f62c045", "filename": "libgo/go/net/sockopt_linux.go", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Fsockopt_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Fsockopt_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsockopt_linux.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -11,12 +11,17 @@ import (\n \t\"syscall\"\n )\n \n-func setDefaultSockopts(s, f, t int) error {\n+func setDefaultSockopts(s, f, t int, ipv6only bool) error {\n \tswitch f {\n \tcase syscall.AF_INET6:\n-\t\t// Allow both IP versions even if the OS default is otherwise.\n-\t\t// Note that some operating systems never admit this option.\n-\t\tsyscall.SetsockoptInt(s, syscall.IPPROTO_IPV6, syscall.IPV6_V6ONLY, 0)\n+\t\tif ipv6only {\n+\t\t\tsyscall.SetsockoptInt(s, syscall.IPPROTO_IPV6, syscall.IPV6_V6ONLY, 1)\n+\t\t} else {\n+\t\t\t// Allow both IP versions even if the OS default\n+\t\t\t// is otherwise.  Note that some operating systems\n+\t\t\t// never admit this option.\n+\t\t\tsyscall.SetsockoptInt(s, syscall.IPPROTO_IPV6, syscall.IPV6_V6ONLY, 0)\n+\t\t}\n \t}\n \t// Allow broadcast.\n \terr := syscall.SetsockoptInt(s, syscall.SOL_SOCKET, syscall.SO_BROADCAST, 1)"}, {"sha": "509b5963bf3c3b0369a273ec5e94d6b28da1321e", "filename": "libgo/go/net/sockopt_windows.go", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Fsockopt_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Fsockopt_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsockopt_windows.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -11,12 +11,17 @@ import (\n \t\"syscall\"\n )\n \n-func setDefaultSockopts(s syscall.Handle, f, t int) error {\n+func setDefaultSockopts(s syscall.Handle, f, t int, ipv6only bool) error {\n \tswitch f {\n \tcase syscall.AF_INET6:\n-\t\t// Allow both IP versions even if the OS default is otherwise.\n-\t\t// Note that some operating systems never admit this option.\n-\t\tsyscall.SetsockoptInt(s, syscall.IPPROTO_IPV6, syscall.IPV6_V6ONLY, 0)\n+\t\tif ipv6only {\n+\t\t\tsyscall.SetsockoptInt(s, syscall.IPPROTO_IPV6, syscall.IPV6_V6ONLY, 1)\n+\t\t} else {\n+\t\t\t// Allow both IP versions even if the OS default\n+\t\t\t// is otherwise.  Note that some operating systems\n+\t\t\t// never admit this option.\n+\t\t\tsyscall.SetsockoptInt(s, syscall.IPPROTO_IPV6, syscall.IPV6_V6ONLY, 0)\n+\t\t}\n \t}\n \t// Allow broadcast.\n \tsyscall.SetsockoptInt(s, syscall.SOL_SOCKET, syscall.SO_BROADCAST, 1)"}, {"sha": "15f8efdd7013fabbf83aebb66ac8791adafbab31", "filename": "libgo/go/net/tcpsock_posix.go", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Ftcpsock_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Ftcpsock_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ftcpsock_posix.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -9,7 +9,6 @@\n package net\n \n import (\n-\t\"fmt\"\n \t\"io\"\n \t\"os\"\n \t\"syscall\"\n@@ -30,7 +29,7 @@ func sockaddrToTCP(sa syscall.Sockaddr) Addr {\n \tdefault:\n \t\tif sa != nil {\n \t\t\t// Diagnose when we will turn a non-nil sockaddr into a nil.\n-\t\t\tpanic(fmt.Sprintf(\"unexpected type in sockaddrToTCP: %T\", sa))\n+\t\t\tpanic(\"unexpected type in sockaddrToTCP\")\n \t\t}\n \t}\n \treturn nil\n@@ -46,6 +45,13 @@ func (a *TCPAddr) family() int {\n \treturn syscall.AF_INET6\n }\n \n+func (a *TCPAddr) isWildcard() bool {\n+\tif a == nil || a.IP == nil {\n+\t\treturn true\n+\t}\n+\treturn a.IP.IsUnspecified()\n+}\n+\n func (a *TCPAddr) sockaddr(family int) (syscall.Sockaddr, error) {\n \treturn ipToSockaddr(family, a.IP, a.Port)\n }"}, {"sha": "672fb7241d7e54ae8605a64d89ca92bd97f24f70", "filename": "libgo/go/net/timeout_test.go", "status": "modified", "additions": 33, "deletions": 18, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Ftimeout_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Ftimeout_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ftimeout_test.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -11,13 +11,13 @@ import (\n \t\"time\"\n )\n \n-func testTimeout(t *testing.T, network, addr string, readFrom bool) {\n-\tfd, err := Dial(network, addr)\n+func testTimeout(t *testing.T, net, addr string, readFrom bool) {\n+\tc, err := Dial(net, addr)\n \tif err != nil {\n-\t\tt.Errorf(\"dial %s %s failed: %v\", network, addr, err)\n+\t\tt.Errorf(\"Dial(%q, %q) failed: %v\", net, addr, err)\n \t\treturn\n \t}\n-\tdefer fd.Close()\n+\tdefer c.Close()\n \twhat := \"Read\"\n \tif readFrom {\n \t\twhat = \"ReadFrom\"\n@@ -26,22 +26,22 @@ func testTimeout(t *testing.T, network, addr string, readFrom bool) {\n \terrc := make(chan error, 1)\n \tgo func() {\n \t\tt0 := time.Now()\n-\t\tfd.SetReadDeadline(time.Now().Add(100 * time.Millisecond))\n+\t\tc.SetReadDeadline(time.Now().Add(100 * time.Millisecond))\n \t\tvar b [100]byte\n \t\tvar n int\n-\t\tvar err1 error\n+\t\tvar err error\n \t\tif readFrom {\n-\t\t\tn, _, err1 = fd.(PacketConn).ReadFrom(b[0:])\n+\t\t\tn, _, err = c.(PacketConn).ReadFrom(b[0:])\n \t\t} else {\n-\t\t\tn, err1 = fd.Read(b[0:])\n+\t\t\tn, err = c.Read(b[0:])\n \t\t}\n \t\tt1 := time.Now()\n-\t\tif n != 0 || err1 == nil || !err1.(Error).Timeout() {\n-\t\t\terrc <- fmt.Errorf(\"fd.%s on %s %s did not return 0, timeout: %v, %v\", what, network, addr, n, err1)\n+\t\tif n != 0 || err == nil || !err.(Error).Timeout() {\n+\t\t\terrc <- fmt.Errorf(\"%s(%q, %q) did not return 0, timeout: %v, %v\", what, net, addr, n, err)\n \t\t\treturn\n \t\t}\n \t\tif dt := t1.Sub(t0); dt < 50*time.Millisecond || !testing.Short() && dt > 250*time.Millisecond {\n-\t\t\terrc <- fmt.Errorf(\"fd.%s on %s %s took %s, expected 0.1s\", what, network, addr, dt)\n+\t\t\terrc <- fmt.Errorf(\"%s(%q, %q) took %s, expected 0.1s\", what, net, addr, dt)\n \t\t\treturn\n \t\t}\n \t\terrc <- nil\n@@ -52,34 +52,49 @@ func testTimeout(t *testing.T, network, addr string, readFrom bool) {\n \t\t\tt.Error(err)\n \t\t}\n \tcase <-time.After(1 * time.Second):\n-\t\tt.Errorf(\"%s on %s %s took over 1 second, expected 0.1s\", what, network, addr)\n+\t\tt.Errorf(\"%s(%q, %q) took over 1 second, expected 0.1s\", what, net, addr)\n \t}\n }\n \n func TestTimeoutUDP(t *testing.T) {\n-\tif runtime.GOOS == \"plan9\" {\n+\tswitch runtime.GOOS {\n+\tcase \"plan9\":\n+\t\tt.Logf(\"skipping test on %q\", runtime.GOOS)\n \t\treturn\n \t}\n-\ttestTimeout(t, \"udp\", \"127.0.0.1:53\", false)\n-\ttestTimeout(t, \"udp\", \"127.0.0.1:53\", true)\n+\n+\t// set up a listener that won't talk back\n+\tlistening := make(chan string)\n+\tdone := make(chan int)\n+\tgo runDatagramPacketConnServer(t, \"udp\", \"127.0.0.1:0\", listening, done)\n+\taddr := <-listening\n+\n+\ttestTimeout(t, \"udp\", addr, false)\n+\ttestTimeout(t, \"udp\", addr, true)\n+\t<-done\n }\n \n func TestTimeoutTCP(t *testing.T) {\n-\tif runtime.GOOS == \"plan9\" {\n+\tswitch runtime.GOOS {\n+\tcase \"plan9\":\n+\t\tt.Logf(\"skipping test on %q\", runtime.GOOS)\n \t\treturn\n \t}\n+\n \t// set up a listener that won't talk back\n \tlistening := make(chan string)\n \tdone := make(chan int)\n-\tgo runServe(t, \"tcp\", \"127.0.0.1:0\", listening, done)\n+\tgo runStreamConnServer(t, \"tcp\", \"127.0.0.1:0\", listening, done)\n \taddr := <-listening\n \n \ttestTimeout(t, \"tcp\", addr, false)\n \t<-done\n }\n \n func TestDeadlineReset(t *testing.T) {\n-\tif runtime.GOOS == \"plan9\" {\n+\tswitch runtime.GOOS {\n+\tcase \"plan9\":\n+\t\tt.Logf(\"skipping test on %q\", runtime.GOOS)\n \t\treturn\n \t}\n \tln, err := Listen(\"tcp\", \"127.0.0.1:0\")"}, {"sha": "f80d3b5a9cfa77e2e50549406e13a42e24b60155", "filename": "libgo/go/net/udp_test.go", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Fudp_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Fudp_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fudp_test.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -10,7 +10,9 @@ import (\n )\n \n func TestWriteToUDP(t *testing.T) {\n-\tif runtime.GOOS == \"plan9\" {\n+\tswitch runtime.GOOS {\n+\tcase \"plan9\":\n+\t\tt.Logf(\"skipping test on %q\", runtime.GOOS)\n \t\treturn\n \t}\n "}, {"sha": "9e820e1c57acd716c7f016983f6c72e8d6334b6d", "filename": "libgo/go/net/udpsock_posix.go", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Fudpsock_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Fudpsock_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fudpsock_posix.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -37,6 +37,13 @@ func (a *UDPAddr) family() int {\n \treturn syscall.AF_INET6\n }\n \n+func (a *UDPAddr) isWildcard() bool {\n+\tif a == nil || a.IP == nil {\n+\t\treturn true\n+\t}\n+\treturn a.IP.IsUnspecified()\n+}\n+\n func (a *UDPAddr) sockaddr(family int) (syscall.Sockaddr, error) {\n \treturn ipToSockaddr(family, a.IP, a.Port)\n }"}, {"sha": "a23bc5adaf28dceb89793df354554ee0f1060531", "filename": "libgo/go/net/unicast_test.go", "status": "modified", "additions": 474, "deletions": 47, "changes": 521, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Funicast_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Funicast_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Funicast_test.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -7,105 +7,532 @@ package net\n import (\n \t\"io\"\n \t\"runtime\"\n+\t\"syscall\"\n \t\"testing\"\n )\n \n-var unicastTests = []struct {\n-\tnet    string\n-\tladdr  string\n-\tipv6   bool\n-\tpacket bool\n+var listenerTests = []struct {\n+\tnet      string\n+\tladdr    string\n+\tipv6     bool // test with underlying AF_INET6 socket\n+\twildcard bool // test with wildcard address\n }{\n-\t{net: \"tcp4\", laddr: \"127.0.0.1:0\"},\n-\t{net: \"tcp4\", laddr: \"previous\"},\n-\t{net: \"tcp6\", laddr: \"[::1]:0\", ipv6: true},\n-\t{net: \"tcp6\", laddr: \"previous\", ipv6: true},\n-\t{net: \"udp4\", laddr: \"127.0.0.1:0\", packet: true},\n-\t{net: \"udp6\", laddr: \"[::1]:0\", ipv6: true, packet: true},\n+\t{net: \"tcp\", laddr: \"\", wildcard: true},\n+\t{net: \"tcp\", laddr: \"0.0.0.0\", wildcard: true},\n+\t{net: \"tcp\", laddr: \"[::ffff:0.0.0.0]\", wildcard: true},\n+\t{net: \"tcp\", laddr: \"[::]\", ipv6: true, wildcard: true},\n+\n+\t{net: \"tcp\", laddr: \"127.0.0.1\"},\n+\t{net: \"tcp\", laddr: \"[::ffff:127.0.0.1]\"},\n+\t{net: \"tcp\", laddr: \"[::1]\", ipv6: true},\n+\n+\t{net: \"tcp4\", laddr: \"\", wildcard: true},\n+\t{net: \"tcp4\", laddr: \"0.0.0.0\", wildcard: true},\n+\t{net: \"tcp4\", laddr: \"[::ffff:0.0.0.0]\", wildcard: true},\n+\n+\t{net: \"tcp4\", laddr: \"127.0.0.1\"},\n+\t{net: \"tcp4\", laddr: \"[::ffff:127.0.0.1]\"},\n+\n+\t{net: \"tcp6\", laddr: \"\", ipv6: true, wildcard: true},\n+\t{net: \"tcp6\", laddr: \"[::]\", ipv6: true, wildcard: true},\n+\n+\t{net: \"tcp6\", laddr: \"[::1]\", ipv6: true},\n }\n \n-func TestUnicastTCPAndUDP(t *testing.T) {\n-\tif runtime.GOOS == \"plan9\" || runtime.GOOS == \"windows\" {\n+// TestTCPListener tests both single and double listen to a test\n+// listener with same address family, same listening address and\n+// same port.\n+func TestTCPListener(t *testing.T) {\n+\tswitch runtime.GOOS {\n+\tcase \"plan9\", \"windows\":\n+\t\tt.Logf(\"skipping test on %q\", runtime.GOOS)\n \t\treturn\n \t}\n \n-\tprevladdr := \"\"\n-\tfor _, tt := range unicastTests {\n+\tfor _, tt := range listenerTests {\n+\t\tif tt.wildcard && (testing.Short() || !*testExternal) {\n+\t\t\tcontinue\n+\t\t}\n \t\tif tt.ipv6 && !supportsIPv6 {\n \t\t\tcontinue\n \t\t}\n-\t\tvar (\n-\t\t\tfd     *netFD\n-\t\t\tcloser io.Closer\n-\t\t)\n-\t\tif !tt.packet {\n-\t\t\tif tt.laddr == \"previous\" {\n-\t\t\t\ttt.laddr = prevladdr\n+\t\tl1, port := usableListenPort(t, tt.net, tt.laddr)\n+\t\tcheckFirstListener(t, tt.net, tt.laddr+\":\"+port, l1)\n+\t\tl2, err := Listen(tt.net, tt.laddr+\":\"+port)\n+\t\tcheckSecondListener(t, tt.net, tt.laddr+\":\"+port, err, l2)\n+\t\tfd := l1.(*TCPListener).fd\n+\t\tswitch fd.family {\n+\t\tcase syscall.AF_INET:\n+\t\t\ttestIPv4UnicastSocketOptions(t, fd)\n+\t\tcase syscall.AF_INET6:\n+\t\t\ttestIPv6UnicastSocketOptions(t, fd)\n+\t\t}\n+\t\tl1.(io.Closer).Close()\n+\t}\n+}\n+\n+// TestUDPListener tests both single and double listen to a test\n+// listener with same address family, same listening address and\n+// same port.\n+func TestUDPListener(t *testing.T) {\n+\tswitch runtime.GOOS {\n+\tcase \"plan9\", \"windows\":\n+\t\tt.Logf(\"skipping test on %q\", runtime.GOOS)\n+\t\treturn\n+\t}\n+\n+\ttoudpnet := func(net string) string {\n+\t\tswitch net {\n+\t\tcase \"tcp\":\n+\t\t\treturn \"udp\"\n+\t\tcase \"tcp4\":\n+\t\t\treturn \"udp4\"\n+\t\tcase \"tcp6\":\n+\t\t\treturn \"udp6\"\n+\t\t}\n+\t\treturn \"<nil>\"\n+\t}\n+\n+\tfor _, tt := range listenerTests {\n+\t\tif tt.wildcard && (testing.Short() || !*testExternal) {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif tt.ipv6 && !supportsIPv6 {\n+\t\t\tcontinue\n+\t\t}\n+\t\ttt.net = toudpnet(tt.net)\n+\t\tl1, port := usableListenPacketPort(t, tt.net, tt.laddr)\n+\t\tcheckFirstListener(t, tt.net, tt.laddr+\":\"+port, l1)\n+\t\tl2, err := ListenPacket(tt.net, tt.laddr+\":\"+port)\n+\t\tcheckSecondListener(t, tt.net, tt.laddr+\":\"+port, err, l2)\n+\t\tfd := l1.(*UDPConn).fd\n+\t\tswitch fd.family {\n+\t\tcase syscall.AF_INET:\n+\t\t\ttestIPv4UnicastSocketOptions(t, fd)\n+\t\tcase syscall.AF_INET6:\n+\t\t\ttestIPv6UnicastSocketOptions(t, fd)\n+\t\t}\n+\t\tl1.(io.Closer).Close()\n+\t}\n+}\n+\n+func TestSimpleTCPListener(t *testing.T) {\n+\tswitch runtime.GOOS {\n+\tcase \"plan9\":\n+\t\tt.Logf(\"skipping test on %q\", runtime.GOOS)\n+\t\treturn\n+\t}\n+\n+\tfor _, tt := range listenerTests {\n+\t\tif tt.wildcard && (testing.Short() || !*testExternal) {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif tt.ipv6 {\n+\t\t\tcontinue\n+\t\t}\n+\t\tl1, port := usableListenPort(t, tt.net, tt.laddr)\n+\t\tcheckFirstListener(t, tt.net, tt.laddr+\":\"+port, l1)\n+\t\tl2, err := Listen(tt.net, tt.laddr+\":\"+port)\n+\t\tcheckSecondListener(t, tt.net, tt.laddr+\":\"+port, err, l2)\n+\t\tl1.(io.Closer).Close()\n+\t}\n+}\n+\n+func TestSimpleUDPListener(t *testing.T) {\n+\tswitch runtime.GOOS {\n+\tcase \"plan9\":\n+\t\tt.Logf(\"skipping test on %q\", runtime.GOOS)\n+\t\treturn\n+\t}\n+\n+\ttoudpnet := func(net string) string {\n+\t\tswitch net {\n+\t\tcase \"tcp\":\n+\t\t\treturn \"udp\"\n+\t\tcase \"tcp4\":\n+\t\t\treturn \"udp4\"\n+\t\tcase \"tcp6\":\n+\t\t\treturn \"udp6\"\n+\t\t}\n+\t\treturn \"<nil>\"\n+\t}\n+\n+\tfor _, tt := range listenerTests {\n+\t\tif tt.wildcard && (testing.Short() || !*testExternal) {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif tt.ipv6 {\n+\t\t\tcontinue\n+\t\t}\n+\t\ttt.net = toudpnet(tt.net)\n+\t\tl1, port := usableListenPacketPort(t, tt.net, tt.laddr)\n+\t\tcheckFirstListener(t, tt.net, tt.laddr+\":\"+port, l1)\n+\t\tl2, err := ListenPacket(tt.net, tt.laddr+\":\"+port)\n+\t\tcheckSecondListener(t, tt.net, tt.laddr+\":\"+port, err, l2)\n+\t\tl1.(io.Closer).Close()\n+\t}\n+}\n+\n+var dualStackListenerTests = []struct {\n+\tnet1     string // first listener\n+\tladdr1   string\n+\tnet2     string // second listener\n+\tladdr2   string\n+\twildcard bool  // test with wildcard address\n+\txerr     error // expected error value, nil or other\n+}{\n+\t// Test cases and expected results for the attemping 2nd listen on the same port\n+\t// 1st listen                2nd listen                 darwin  freebsd  linux  openbsd\n+\t// ------------------------------------------------------------------------------------\n+\t// \"tcp\"  \"\"                 \"tcp\"  \"\"                    -        -       -       - \n+\t// \"tcp\"  \"\"                 \"tcp\"  \"0.0.0.0\"             -        -       -       - \n+\t// \"tcp\"  \"0.0.0.0\"          \"tcp\"  \"\"                    -        -       -       - \n+\t// ------------------------------------------------------------------------------------\n+\t// \"tcp\"  \"\"                 \"tcp\"  \"[::]\"                -        -       -       ok\n+\t// \"tcp\"  \"[::]\"             \"tcp\"  \"\"                    -        -       -       ok\n+\t// \"tcp\"  \"0.0.0.0\"          \"tcp\"  \"[::]\"                -        -       -       ok\n+\t// \"tcp\"  \"[::]\"             \"tcp\"  \"0.0.0.0\"             -        -       -       ok\n+\t// \"tcp\"  \"[::ffff:0.0.0.0]\" \"tcp\"  \"[::]\"                -        -       -       ok\n+\t// \"tcp\"  \"[::]\"             \"tcp\"  \"[::ffff:0.0.0.0]\"    -        -       -       ok\n+\t// ------------------------------------------------------------------------------------\n+\t// \"tcp4\" \"\"                 \"tcp6\" \"\"                    ok       ok      ok      ok\n+\t// \"tcp6\" \"\"                 \"tcp4\" \"\"                    ok       ok      ok      ok\n+\t// \"tcp4\" \"0.0.0.0\"          \"tcp6\" \"[::]\"                ok       ok      ok      ok\n+\t// \"tcp6\" \"[::]\"             \"tcp4\" \"0.0.0.0\"             ok       ok      ok      ok\n+\t// ------------------------------------------------------------------------------------\n+\t// \"tcp\"  \"127.0.0.1\"        \"tcp\"  \"[::1]\"               ok       ok      ok      ok\n+\t// \"tcp\"  \"[::1]\"            \"tcp\"  \"127.0.0.1\"           ok       ok      ok      ok\n+\t// \"tcp4\" \"127.0.0.1\"        \"tcp6\" \"[::1]\"               ok       ok      ok      ok\n+\t// \"tcp6\" \"[::1]\"            \"tcp4\" \"127.0.0.1\"           ok       ok      ok      ok\n+\t//\n+\t// Platform default configurations:\n+\t// darwin, kernel version 11.3.0\n+\t//\tnet.inet6.ip6.v6only=0 (overridable by sysctl or IPV6_V6ONLY option)\n+\t// freebsd, kernel version 8.2\n+\t//\tnet.inet6.ip6.v6only=1 (overridable by sysctl or IPV6_V6ONLY option)\n+\t// linux, kernel version 3.0.0\n+\t//\tnet.ipv6.bindv6only=0 (overridable by sysctl or IPV6_V6ONLY option)\n+\t// openbsd, kernel version 5.0\n+\t//\tnet.inet6.ip6.v6only=1 (overriding is prohibited)\n+\n+\t{net1: \"tcp\", laddr1: \"\", net2: \"tcp\", laddr2: \"\", wildcard: true, xerr: syscall.EADDRINUSE},\n+\t{net1: \"tcp\", laddr1: \"\", net2: \"tcp\", laddr2: \"0.0.0.0\", wildcard: true, xerr: syscall.EADDRINUSE},\n+\t{net1: \"tcp\", laddr1: \"0.0.0.0\", net2: \"tcp\", laddr2: \"\", wildcard: true, xerr: syscall.EADDRINUSE},\n+\n+\t{net1: \"tcp\", laddr1: \"\", net2: \"tcp\", laddr2: \"[::]\", wildcard: true, xerr: syscall.EADDRINUSE},\n+\t{net1: \"tcp\", laddr1: \"[::]\", net2: \"tcp\", laddr2: \"\", wildcard: true, xerr: syscall.EADDRINUSE},\n+\t{net1: \"tcp\", laddr1: \"0.0.0.0\", net2: \"tcp\", laddr2: \"[::]\", wildcard: true, xerr: syscall.EADDRINUSE},\n+\t{net1: \"tcp\", laddr1: \"[::]\", net2: \"tcp\", laddr2: \"0.0.0.0\", wildcard: true, xerr: syscall.EADDRINUSE},\n+\t{net1: \"tcp\", laddr1: \"[::ffff:0.0.0.0]\", net2: \"tcp\", laddr2: \"[::]\", wildcard: true, xerr: syscall.EADDRINUSE},\n+\t{net1: \"tcp\", laddr1: \"[::]\", net2: \"tcp\", laddr2: \"[::ffff:0.0.0.0]\", wildcard: true, xerr: syscall.EADDRINUSE},\n+\n+\t{net1: \"tcp4\", laddr1: \"\", net2: \"tcp6\", laddr2: \"\", wildcard: true},\n+\t{net1: \"tcp6\", laddr1: \"\", net2: \"tcp4\", laddr2: \"\", wildcard: true},\n+\t{net1: \"tcp4\", laddr1: \"0.0.0.0\", net2: \"tcp6\", laddr2: \"[::]\", wildcard: true},\n+\t{net1: \"tcp6\", laddr1: \"[::]\", net2: \"tcp4\", laddr2: \"0.0.0.0\", wildcard: true},\n+\n+\t{net1: \"tcp\", laddr1: \"127.0.0.1\", net2: \"tcp\", laddr2: \"[::1]\"},\n+\t{net1: \"tcp\", laddr1: \"[::1]\", net2: \"tcp\", laddr2: \"127.0.0.1\"},\n+\t{net1: \"tcp4\", laddr1: \"127.0.0.1\", net2: \"tcp6\", laddr2: \"[::1]\"},\n+\t{net1: \"tcp6\", laddr1: \"[::1]\", net2: \"tcp4\", laddr2: \"127.0.0.1\"},\n+}\n+\n+// TestDualStackTCPListener tests both single and double listen\n+// to a test listener with various address families, differnet\n+// listening address and same port.\n+func TestDualStackTCPListener(t *testing.T) {\n+\tswitch runtime.GOOS {\n+\tcase \"plan9\":\n+\t\tt.Logf(\"skipping test on %q\", runtime.GOOS)\n+\t\treturn\n+\t}\n+\tif !supportsIPv6 {\n+\t\treturn\n+\t}\n+\n+\tfor _, tt := range dualStackListenerTests {\n+\t\tif tt.wildcard && (testing.Short() || !*testExternal) {\n+\t\t\tcontinue\n+\t\t}\n+\t\tswitch runtime.GOOS {\n+\t\tcase \"openbsd\":\n+\t\t\tif tt.wildcard && differentWildcardAddr(tt.laddr1, tt.laddr2) {\n+\t\t\t\ttt.xerr = nil\n+\t\t\t}\n+\t\t}\n+\t\tl1, port := usableListenPort(t, tt.net1, tt.laddr1)\n+\t\tladdr := tt.laddr1 + \":\" + port\n+\t\tcheckFirstListener(t, tt.net1, laddr, l1)\n+\t\tladdr = tt.laddr2 + \":\" + port\n+\t\tl2, err := Listen(tt.net2, laddr)\n+\t\tcheckDualStackSecondListener(t, tt.net2, laddr, tt.xerr, err, l2)\n+\t\tl1.Close()\n+\t}\n+}\n+\n+// TestDualStackUDPListener tests both single and double listen\n+// to a test listener with various address families, differnet\n+// listening address and same port.\n+func TestDualStackUDPListener(t *testing.T) {\n+\tswitch runtime.GOOS {\n+\tcase \"plan9\":\n+\t\tt.Logf(\"skipping test on %q\", runtime.GOOS)\n+\t\treturn\n+\t}\n+\tif !supportsIPv6 {\n+\t\treturn\n+\t}\n+\n+\ttoudpnet := func(net string) string {\n+\t\tswitch net {\n+\t\tcase \"tcp\":\n+\t\t\treturn \"udp\"\n+\t\tcase \"tcp4\":\n+\t\t\treturn \"udp4\"\n+\t\tcase \"tcp6\":\n+\t\t\treturn \"udp6\"\n+\t\t}\n+\t\treturn \"<nil>\"\n+\t}\n+\n+\tfor _, tt := range dualStackListenerTests {\n+\t\tif tt.wildcard && (testing.Short() || !*testExternal) {\n+\t\t\tcontinue\n+\t\t}\n+\t\ttt.net1 = toudpnet(tt.net1)\n+\t\ttt.net2 = toudpnet(tt.net2)\n+\t\tswitch runtime.GOOS {\n+\t\tcase \"openbsd\":\n+\t\t\tif tt.wildcard && differentWildcardAddr(tt.laddr1, tt.laddr2) {\n+\t\t\t\ttt.xerr = nil\n \t\t\t}\n-\t\t\tl, err := Listen(tt.net, tt.laddr)\n-\t\t\tif err != nil {\n-\t\t\t\tt.Fatalf(\"Listen failed: %v\", err)\n+\t\t}\n+\t\tl1, port := usableListenPacketPort(t, tt.net1, tt.laddr1)\n+\t\tladdr := tt.laddr1 + \":\" + port\n+\t\tcheckFirstListener(t, tt.net1, laddr, l1)\n+\t\tladdr = tt.laddr2 + \":\" + port\n+\t\tl2, err := ListenPacket(tt.net2, laddr)\n+\t\tcheckDualStackSecondListener(t, tt.net2, laddr, tt.xerr, err, l2)\n+\t\tl1.Close()\n+\t}\n+}\n+\n+func usableListenPort(t *testing.T, net, laddr string) (l Listener, port string) {\n+\tvar nladdr string\n+\tvar err error\n+\tswitch net {\n+\tdefault:\n+\t\tpanic(\"usableListenPort net=\" + net)\n+\tcase \"tcp\", \"tcp4\", \"tcp6\":\n+\t\tl, err = Listen(net, laddr+\":0\")\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"Probe Listen(%q, %q) failed: %v\", net, laddr, err)\n+\t\t}\n+\t\tnladdr = l.(*TCPListener).Addr().String()\n+\t}\n+\t_, port, err = SplitHostPort(nladdr)\n+\tif err != nil {\n+\t\tt.Fatalf(\"SplitHostPort failed: %v\", err)\n+\t}\n+\treturn l, port\n+}\n+\n+func usableListenPacketPort(t *testing.T, net, laddr string) (l PacketConn, port string) {\n+\tvar nladdr string\n+\tvar err error\n+\tswitch net {\n+\tdefault:\n+\t\tpanic(\"usableListenPacketPort net=\" + net)\n+\tcase \"udp\", \"udp4\", \"udp6\":\n+\t\tl, err = ListenPacket(net, laddr+\":0\")\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"Probe ListenPacket(%q, %q) failed: %v\", net, laddr, err)\n+\t\t}\n+\t\tnladdr = l.(*UDPConn).LocalAddr().String()\n+\t}\n+\t_, port, err = SplitHostPort(nladdr)\n+\tif err != nil {\n+\t\tt.Fatalf(\"SplitHostPort failed: %v\", err)\n+\t}\n+\treturn l, port\n+}\n+\n+func differentWildcardAddr(i, j string) bool {\n+\tif (i == \"\" || i == \"0.0.0.0\" || i == \"::ffff:0.0.0.0\") && (j == \"\" || j == \"0.0.0.0\" || j == \"::ffff:0.0.0.0\") {\n+\t\treturn false\n+\t}\n+\tif i == \"[::]\" && j == \"[::]\" {\n+\t\treturn false\n+\t}\n+\treturn true\n+}\n+\n+func checkFirstListener(t *testing.T, net, laddr string, l interface{}) {\n+\tswitch net {\n+\tcase \"tcp\":\n+\t\tfd := l.(*TCPListener).fd\n+\t\tcheckDualStackAddrFamily(t, net, laddr, fd)\n+\tcase \"tcp4\":\n+\t\tfd := l.(*TCPListener).fd\n+\t\tif fd.family != syscall.AF_INET {\n+\t\t\tt.Fatalf(\"First Listen(%q, %q) returns address family %v, expected %v\", net, laddr, fd.family, syscall.AF_INET)\n+\t\t}\n+\tcase \"tcp6\":\n+\t\tfd := l.(*TCPListener).fd\n+\t\tif fd.family != syscall.AF_INET6 {\n+\t\t\tt.Fatalf(\"First Listen(%q, %q) returns address family %v, expected %v\", net, laddr, fd.family, syscall.AF_INET6)\n+\t\t}\n+\tcase \"udp\":\n+\t\tfd := l.(*UDPConn).fd\n+\t\tcheckDualStackAddrFamily(t, net, laddr, fd)\n+\tcase \"udp4\":\n+\t\tfd := l.(*UDPConn).fd\n+\t\tif fd.family != syscall.AF_INET {\n+\t\t\tt.Fatalf(\"First ListenPacket(%q, %q) returns address family %v, expected %v\", net, laddr, fd.family, syscall.AF_INET)\n+\t\t}\n+\tcase \"udp6\":\n+\t\tfd := l.(*UDPConn).fd\n+\t\tif fd.family != syscall.AF_INET6 {\n+\t\t\tt.Fatalf(\"First ListenPacket(%q, %q) returns address family %v, expected %v\", net, laddr, fd.family, syscall.AF_INET6)\n+\t\t}\n+\tdefault:\n+\t\tt.Fatalf(\"Unexpected network: %q\", net)\n+\t}\n+}\n+\n+func checkSecondListener(t *testing.T, net, laddr string, err error, l interface{}) {\n+\tswitch net {\n+\tcase \"tcp\", \"tcp4\", \"tcp6\":\n+\t\tif err == nil {\n+\t\t\tl.(*TCPListener).Close()\n+\t\t\tt.Fatalf(\"Second Listen(%q, %q) should fail\", net, laddr)\n+\t\t}\n+\tcase \"udp\", \"udp4\", \"udp6\":\n+\t\tif err == nil {\n+\t\t\tl.(*UDPConn).Close()\n+\t\t\tt.Fatalf(\"Second ListenPacket(%q, %q) should fail\", net, laddr)\n+\t\t}\n+\tdefault:\n+\t\tt.Fatalf(\"Unexpected network: %q\", net)\n+\t}\n+}\n+\n+func checkDualStackSecondListener(t *testing.T, net, laddr string, xerr, err error, l interface{}) {\n+\tswitch net {\n+\tcase \"tcp\", \"tcp4\", \"tcp6\":\n+\t\tif xerr == nil && err != nil || xerr != nil && err == nil {\n+\t\t\tt.Fatalf(\"Second Listen(%q, %q) returns %v, expected %v\", net, laddr, err, xerr)\n+\t\t}\n+\t\tl.(*TCPListener).Close()\n+\tcase \"udp\", \"udp4\", \"udp6\":\n+\t\tif xerr == nil && err != nil || xerr != nil && err == nil {\n+\t\t\tt.Fatalf(\"Second ListenPacket(%q, %q) returns %v, expected %v\", net, laddr, err, xerr)\n+\t\t}\n+\t\tl.(*UDPConn).Close()\n+\tdefault:\n+\t\tt.Fatalf(\"Unexpected network: %q\", net)\n+\t}\n+}\n+\n+func checkDualStackAddrFamily(t *testing.T, net, laddr string, fd *netFD) {\n+\tswitch a := fd.laddr.(type) {\n+\tcase *TCPAddr:\n+\t\t// If a node under test supports both IPv6 capability\n+\t\t// and IPv6 IPv4-mapping capability, we can assume\n+\t\t// that the node listens on a wildcard address with an\n+\t\t// AF_INET6 socket.\n+\t\tif supportsIPv4map && fd.laddr.(*TCPAddr).isWildcard() {\n+\t\t\tif fd.family != syscall.AF_INET6 {\n+\t\t\t\tt.Fatalf(\"Listen(%q, %q) returns address family %v, expected %v\", net, laddr, fd.family, syscall.AF_INET6)\n \t\t\t}\n-\t\t\tprevladdr = l.Addr().String()\n-\t\t\tcloser = l\n-\t\t\tfd = l.(*TCPListener).fd\n \t\t} else {\n-\t\t\tc, err := ListenPacket(tt.net, tt.laddr)\n-\t\t\tif err != nil {\n-\t\t\t\tt.Fatalf(\"ListenPacket failed: %v\", err)\n+\t\t\tif fd.family != a.family() {\n+\t\t\t\tt.Fatalf(\"Listen(%q, %q) returns address family %v, expected %v\", net, laddr, fd.family, a.family())\n \t\t\t}\n-\t\t\tcloser = c\n-\t\t\tfd = c.(*UDPConn).fd\n \t\t}\n-\t\tif !tt.ipv6 {\n-\t\t\ttestIPv4UnicastSocketOptions(t, fd)\n+\tcase *UDPAddr:\n+\t\t// If a node under test supports both IPv6 capability\n+\t\t// and IPv6 IPv4-mapping capability, we can assume\n+\t\t// that the node listens on a wildcard address with an\n+\t\t// AF_INET6 socket.\n+\t\tif supportsIPv4map && fd.laddr.(*UDPAddr).isWildcard() {\n+\t\t\tif fd.family != syscall.AF_INET6 {\n+\t\t\t\tt.Fatalf(\"ListenPacket(%q, %q) returns address family %v, expected %v\", net, laddr, fd.family, syscall.AF_INET6)\n+\t\t\t}\n \t\t} else {\n-\t\t\ttestIPv6UnicastSocketOptions(t, fd)\n+\t\t\tif fd.family != a.family() {\n+\t\t\t\tt.Fatalf(\"ListenPacket(%q, %q) returns address family %v, expected %v\", net, laddr, fd.family, a.family())\n+\t\t\t}\n \t\t}\n-\t\tcloser.Close()\n+\tdefault:\n+\t\tt.Fatalf(\"Unexpected protocol address type: %T\", a)\n \t}\n }\n \n func testIPv4UnicastSocketOptions(t *testing.T, fd *netFD) {\n-\ttos, err := ipv4TOS(fd)\n+\t_, err := ipv4TOS(fd)\n \tif err != nil {\n \t\tt.Fatalf(\"ipv4TOS failed: %v\", err)\n \t}\n-\tt.Logf(\"IPv4 TOS: %v\", tos)\n \terr = setIPv4TOS(fd, 1)\n \tif err != nil {\n \t\tt.Fatalf(\"setIPv4TOS failed: %v\", err)\n \t}\n-\n-\tttl, err := ipv4TTL(fd)\n+\t_, err = ipv4TTL(fd)\n \tif err != nil {\n \t\tt.Fatalf(\"ipv4TTL failed: %v\", err)\n \t}\n-\tt.Logf(\"IPv4 TTL: %v\", ttl)\n \terr = setIPv4TTL(fd, 1)\n \tif err != nil {\n \t\tt.Fatalf(\"setIPv4TTL failed: %v\", err)\n \t}\n }\n \n func testIPv6UnicastSocketOptions(t *testing.T, fd *netFD) {\n-\ttos, err := ipv6TrafficClass(fd)\n+\t_, err := ipv6TrafficClass(fd)\n \tif err != nil {\n \t\tt.Fatalf(\"ipv6TrafficClass failed: %v\", err)\n \t}\n-\tt.Logf(\"IPv6 TrafficClass: %v\", tos)\n \terr = setIPv6TrafficClass(fd, 1)\n \tif err != nil {\n \t\tt.Fatalf(\"setIPv6TrafficClass failed: %v\", err)\n \t}\n-\n-\thoplim, err := ipv6HopLimit(fd)\n+\t_, err = ipv6HopLimit(fd)\n \tif err != nil {\n \t\tt.Fatalf(\"ipv6HopLimit failed: %v\", err)\n \t}\n-\tt.Logf(\"IPv6 HopLimit: %v\", hoplim)\n \terr = setIPv6HopLimit(fd, 1)\n \tif err != nil {\n \t\tt.Fatalf(\"setIPv6HopLimit failed: %v\", err)\n \t}\n }\n+\n+var prohibitionaryDialArgTests = []struct {\n+\tnet  string\n+\taddr string\n+}{\n+\t{\"tcp6\", \"127.0.0.1\"},\n+\t{\"tcp6\", \"[::ffff:127.0.0.1]\"},\n+}\n+\n+func TestProhibitionaryDialArgs(t *testing.T) {\n+\tswitch runtime.GOOS {\n+\tcase \"plan9\":\n+\t\tt.Logf(\"skipping test on %q\", runtime.GOOS)\n+\t\treturn\n+\t}\n+\t// This test requires both IPv6 and IPv6 IPv4-mapping functionality.\n+\tif !supportsIPv4map || testing.Short() || !*testExternal {\n+\t\treturn\n+\t}\n+\n+\tl, port := usableListenPort(t, \"tcp\", \"[::]\")\n+\tdefer l.Close()\n+\n+\tfor _, tt := range prohibitionaryDialArgTests {\n+\t\t_, err := Dial(tt.net, tt.addr+\":\"+port)\n+\t\tif err == nil {\n+\t\t\tt.Fatalf(\"Dial(%q, %q) should fail\", tt.net, tt.addr)\n+\t\t}\n+\t}\n+}"}, {"sha": "37a2b1e09ece3e29ade1b2b73ef8e55afd82f938", "filename": "libgo/go/net/unixsock_posix.go", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Funixsock_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fnet%2Funixsock_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Funixsock_posix.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -59,7 +59,7 @@ func unixSocket(net string, laddr, raddr *UnixAddr, mode string) (fd *netFD, err\n \t\tf = sockaddrToUnixpacket\n \t}\n \n-\tfd, err = socket(net, syscall.AF_UNIX, sotype, 0, la, ra, f)\n+\tfd, err = socket(net, syscall.AF_UNIX, sotype, 0, false, la, ra, f)\n \tif err != nil {\n \t\tgoto Error\n \t}\n@@ -208,8 +208,8 @@ func (c *UnixConn) SetWriteBuffer(bytes int) error {\n }\n \n // ReadFromUnix reads a packet from c, copying the payload into b.\n-// It returns the number of bytes copied into b and the return address\n-// that was on the packet.\n+// It returns the number of bytes copied into b and the source address\n+// of the packet.\n //\n // ReadFromUnix can be made to time out and return\n // an error with Timeout() == true after a fixed time limit;\n@@ -264,6 +264,11 @@ func (c *UnixConn) WriteTo(b []byte, addr Addr) (n int, err error) {\n \treturn c.WriteToUnix(b, a)\n }\n \n+// ReadMsgUnix reads a packet from c, copying the payload into b\n+// and the associated out-of-band data into oob.\n+// It returns the number of bytes copied into b, the number of\n+// bytes copied into oob, the flags that were set on the packet,\n+// and the source address of the packet.\n func (c *UnixConn) ReadMsgUnix(b, oob []byte) (n, oobn, flags int, addr *UnixAddr, err error) {\n \tif !c.ok() {\n \t\treturn 0, 0, 0, nil, syscall.EINVAL\n@@ -276,6 +281,9 @@ func (c *UnixConn) ReadMsgUnix(b, oob []byte) (n, oobn, flags int, addr *UnixAdd\n \treturn\n }\n \n+// WriteMsgUnix writes a packet to addr via c, copying the payload from b\n+// and the associated out-of-band data from oob.  It returns the number\n+// of payload and out-of-band bytes written.\n func (c *UnixConn) WriteMsgUnix(b, oob []byte, addr *UnixAddr) (n, oobn int, err error) {\n \tif !c.ok() {\n \t\treturn 0, 0, syscall.EINVAL"}, {"sha": "d08ad5db167f7731beba250c6e6340b87b76ac9b", "filename": "libgo/go/os/error_posix.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fos%2Ferror_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fos%2Ferror_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ferror_posix.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build darwin freebsd linux netbsd openbsd windows\n+// +build darwin freebsd linux netbsd openbsd\n \n package os\n "}, {"sha": "8218f861aff34d84477e18af53c3907b3256c128", "filename": "libgo/go/os/error_test.go", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fos%2Ferror_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fos%2Ferror_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ferror_test.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package os_test\n+\n+import (\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"testing\"\n+)\n+\n+func TestErrIsExist(t *testing.T) {\n+\tf, err := ioutil.TempFile(\"\", \"_Go_ErrIsExist\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"open ErrIsExist tempfile: %s\", err)\n+\t\treturn\n+\t}\n+\tdefer os.Remove(f.Name())\n+\tdefer f.Close()\n+\tf2, err := os.OpenFile(f.Name(), os.O_RDWR|os.O_CREATE|os.O_EXCL, 0600)\n+\tif err == nil {\n+\t\tf2.Close()\n+\t\tt.Fatal(\"Open should have failed\")\n+\t\treturn\n+\t}\n+\tif !os.IsExist(err) {\n+\t\tt.Fatalf(\"os.IsExist does not work as expected for %#v\", err)\n+\t\treturn\n+\t}\n+}"}, {"sha": "84bf5eae8aed54df01a9ad0912447ebe6aa2e7a4", "filename": "libgo/go/os/error_windows.go", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fos%2Ferror_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fos%2Ferror_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ferror_windows.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package os\n+\n+import \"syscall\"\n+\n+// IsExist returns whether the error is known to report that a file already exists.\n+// It is satisfied by ErrExist as well as some syscall errors.\n+func IsExist(err error) bool {\n+\tif pe, ok := err.(*PathError); ok {\n+\t\terr = pe.Err\n+\t}\n+\treturn err == syscall.EEXIST || err == syscall.ERROR_ALREADY_EXISTS ||\n+\t\terr == syscall.ERROR_FILE_EXISTS || err == ErrExist\n+}\n+\n+// IsNotExist returns whether the error is known to report that a file does not exist.\n+// It is satisfied by ErrNotExist as well as some syscall errors.\n+func IsNotExist(err error) bool {\n+\tif pe, ok := err.(*PathError); ok {\n+\t\terr = pe.Err\n+\t}\n+\treturn err == syscall.ENOENT || err == ErrNotExist\n+}\n+\n+// IsPermission returns whether the error is known to report that permission is denied.\n+// It is satisfied by ErrPermission as well as some syscall errors.\n+func IsPermission(err error) bool {\n+\tif pe, ok := err.(*PathError); ok {\n+\t\terr = pe.Err\n+\t}\n+\treturn err == syscall.EACCES || err == syscall.EPERM || err == ErrPermission\n+}"}, {"sha": "bbd04902b742d289a806f86aff7dc54ddbe8a34d", "filename": "libgo/go/os/exec/exec.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fos%2Fexec%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fos%2Fexec%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec%2Fexec.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -59,7 +59,7 @@ type Cmd struct {\n \t// If either is nil, Run connects the corresponding file descriptor\n \t// to the null device (os.DevNull).\n \t//\n-\t// If Stdout and Stderr are are the same writer, at most one\n+\t// If Stdout and Stderr are the same writer, at most one\n \t// goroutine at a time will call Write.\n \tStdout io.Writer\n \tStderr io.Writer"}, {"sha": "01dddf50de0428fa8c46c9814f79b255960aeffc", "filename": "libgo/go/os/types.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fos%2Ftypes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fos%2Ftypes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ftypes.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -15,7 +15,7 @@ func Getpagesize() int { return syscall.Getpagesize() }\n // A FileInfo describes a file and is returned by Stat and Lstat\n type FileInfo interface {\n \tName() string       // base name of the file\n-\tSize() int64        // length in bytes\n+\tSize() int64        // length in bytes for regular files; system-dependent for others\n \tMode() FileMode     // file mode bits\n \tModTime() time.Time // modification time\n \tIsDir() bool        // abbreviation for Mode().IsDir()"}, {"sha": "1e7487263674f3aca703f7f0272c282cdd4727e9", "filename": "libgo/go/path/filepath/path.go", "status": "modified", "additions": 1, "deletions": 60, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -7,10 +7,8 @@\n package filepath\n \n import (\n-\t\"bytes\"\n \t\"errors\"\n \t\"os\"\n-\t\"runtime\"\n \t\"sort\"\n \t\"strings\"\n )\n@@ -191,64 +189,7 @@ func Ext(path string) string {\n // If path is relative the result will be relative to the current directory,\n // unless one of the components is an absolute symbolic link.\n func EvalSymlinks(path string) (string, error) {\n-\tif runtime.GOOS == \"windows\" {\n-\t\t// Symlinks are not supported under windows.\n-\t\t_, err := os.Lstat(path)\n-\t\tif err != nil {\n-\t\t\treturn \"\", err\n-\t\t}\n-\t\treturn Clean(path), nil\n-\t}\n-\tconst maxIter = 255\n-\toriginalPath := path\n-\t// consume path by taking each frontmost path element,\n-\t// expanding it if it's a symlink, and appending it to b\n-\tvar b bytes.Buffer\n-\tfor n := 0; path != \"\"; n++ {\n-\t\tif n > maxIter {\n-\t\t\treturn \"\", errors.New(\"EvalSymlinks: too many links in \" + originalPath)\n-\t\t}\n-\n-\t\t// find next path component, p\n-\t\ti := strings.IndexRune(path, Separator)\n-\t\tvar p string\n-\t\tif i == -1 {\n-\t\t\tp, path = path, \"\"\n-\t\t} else {\n-\t\t\tp, path = path[:i], path[i+1:]\n-\t\t}\n-\n-\t\tif p == \"\" {\n-\t\t\tif b.Len() == 0 {\n-\t\t\t\t// must be absolute path\n-\t\t\t\tb.WriteRune(Separator)\n-\t\t\t}\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tfi, err := os.Lstat(b.String() + p)\n-\t\tif err != nil {\n-\t\t\treturn \"\", err\n-\t\t}\n-\t\tif fi.Mode()&os.ModeSymlink == 0 {\n-\t\t\tb.WriteString(p)\n-\t\t\tif path != \"\" {\n-\t\t\t\tb.WriteRune(Separator)\n-\t\t\t}\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\t// it's a symlink, put it at the front of path\n-\t\tdest, err := os.Readlink(b.String() + p)\n-\t\tif err != nil {\n-\t\t\treturn \"\", err\n-\t\t}\n-\t\tif IsAbs(dest) {\n-\t\t\tb.Reset()\n-\t\t}\n-\t\tpath = dest + string(Separator) + path\n-\t}\n-\treturn Clean(b.String()), nil\n+\treturn evalSymlinks(path)\n }\n \n // Abs returns an absolute representation of path."}, {"sha": "87cb5e5530837b3d93ae02ff387f7b3f620399ee", "filename": "libgo/go/path/filepath/path_test.go", "status": "modified", "additions": 55, "deletions": 24, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_test.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -10,6 +10,7 @@ import (\n \t\"path/filepath\"\n \t\"reflect\"\n \t\"runtime\"\n+\t\"strings\"\n \t\"testing\"\n )\n \n@@ -439,7 +440,7 @@ func TestBase(t *testing.T) {\n \ttests := basetests\n \tif runtime.GOOS == \"windows\" {\n \t\t// make unix tests work on windows\n-\t\tfor i, _ := range tests {\n+\t\tfor i := range tests {\n \t\t\ttests[i].result = filepath.Clean(tests[i].result)\n \t\t}\n \t\t// add windows specific tests\n@@ -482,7 +483,7 @@ func TestDir(t *testing.T) {\n \ttests := dirtests\n \tif runtime.GOOS == \"windows\" {\n \t\t// make unix tests work on windows\n-\t\tfor i, _ := range tests {\n+\t\tfor i := range tests {\n \t\t\ttests[i].result = filepath.Clean(tests[i].result)\n \t\t}\n \t\t// add windows specific tests\n@@ -620,6 +621,12 @@ func TestEvalSymlinks(t *testing.T) {\n \t\t\tif d.path == d.dest {\n \t\t\t\t// will test only real files and directories\n \t\t\t\ttests = append(tests, d)\n+\t\t\t\t// test \"canonical\" names\n+\t\t\t\td2 := EvalSymlinksTest{\n+\t\t\t\t\tpath: strings.ToUpper(d.path),\n+\t\t\t\t\tdest: d.dest,\n+\t\t\t\t}\n+\t\t\t\ttests = append(tests, d2)\n \t\t\t}\n \t\t}\n \t} else {\n@@ -641,35 +648,61 @@ func TestEvalSymlinks(t *testing.T) {\n \t}\n }\n \n-/* These tests do not work in the gccgo test environment.\n+// Test directories relative to temporary directory.\n+// The tests are run in absTestDirs[0].\n+var absTestDirs = []string{\n+\t\"a\",\n+\t\"a/b\",\n+\t\"a/b/c\",\n+}\n \n-// Test paths relative to $GOROOT/src\n-var abstests = []string{\n-\t\"../AUTHORS\",\n-\t\"pkg/../../AUTHORS\",\n-\t\"Make.inc\",\n-\t\"pkg/math\",\n+// Test paths relative to temporary directory. $ expands to the directory.\n+// The tests are run in absTestDirs[0].\n+// We create absTestDirs first.\n+var absTests = []string{\n \t\".\",\n-\t\"$GOROOT/src/Make.inc\",\n-\t\"$GOROOT/src/../src/Make.inc\",\n-\t\"$GOROOT/misc/cgo\",\n-\t\"$GOROOT\",\n+\t\"b\",\n+\t\"../a\",\n+\t\"../a/b\",\n+\t\"../a/b/./c/../../.././a\",\n+\t\"$\",\n+\t\"$/.\",\n+\t\"$/a/../a/b\",\n+\t\"$/a/b/c/../../.././a\",\n }\n \n func TestAbs(t *testing.T) {\n-\tt.Logf(\"test needs to be rewritten; disabled\")\n-\treturn\n-\n \toldwd, err := os.Getwd()\n \tif err != nil {\n-\t\tt.Fatal(\"Getwd failed: \" + err.Error())\n+\t\tt.Fatal(\"Getwd failed: \", err)\n \t}\n \tdefer os.Chdir(oldwd)\n-\tgoroot := os.Getenv(\"GOROOT\")\n-\tcwd := filepath.Join(goroot, \"src\")\n-\tos.Chdir(cwd)\n-\tfor _, path := range abstests {\n-\t\tpath = strings.Replace(path, \"$GOROOT\", goroot, -1)\n+\n+\troot, err := ioutil.TempDir(\"\", \"TestAbs\")\n+\tif err != nil {\n+\t\tt.Fatal(\"TempDir failed: \", err)\n+\t}\n+\tdefer os.RemoveAll(root)\n+\n+\terr = os.Chdir(root)\n+\tif err != nil {\n+\t\tt.Fatal(\"chdir failed: \", err)\n+\t}\n+\n+\tfor _, dir := range absTestDirs {\n+\t\terr = os.Mkdir(dir, 0777)\n+\t\tif err != nil {\n+\t\t\tt.Fatal(\"Mkdir failed: \", err)\n+\t\t}\n+\t}\n+\n+\terr = os.Chdir(absTestDirs[0])\n+\tif err != nil {\n+\t\tt.Fatal(\"chdir failed: \", err)\n+\t}\n+\n+\tfor _, path := range absTests {\n+\t\tpath = strings.Replace(path, \"$\", root, -1)\n \t\tinfo, err := os.Stat(path)\n \t\tif err != nil {\n \t\t\tt.Errorf(\"%s: %s\", path, err)\n@@ -694,8 +727,6 @@ func TestAbs(t *testing.T) {\n \t}\n }\n \n-*/\n-\n type RelTests struct {\n \troot, path, want string\n }"}, {"sha": "307dd0f8fee5270614fab01a2c273388329ea22f", "filename": "libgo/go/path/filepath/symlink.go", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fpath%2Ffilepath%2Fsymlink.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fpath%2Ffilepath%2Fsymlink.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Ffilepath%2Fsymlink.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -0,0 +1,67 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build !windows\n+\n+package filepath\n+\n+import (\n+\t\"bytes\"\n+\t\"errors\"\n+\t\"os\"\n+\t\"strings\"\n+)\n+\n+func evalSymlinks(path string) (string, error) {\n+\tconst maxIter = 255\n+\toriginalPath := path\n+\t// consume path by taking each frontmost path element,\n+\t// expanding it if it's a symlink, and appending it to b\n+\tvar b bytes.Buffer\n+\tfor n := 0; path != \"\"; n++ {\n+\t\tif n > maxIter {\n+\t\t\treturn \"\", errors.New(\"EvalSymlinks: too many links in \" + originalPath)\n+\t\t}\n+\n+\t\t// find next path component, p\n+\t\ti := strings.IndexRune(path, Separator)\n+\t\tvar p string\n+\t\tif i == -1 {\n+\t\t\tp, path = path, \"\"\n+\t\t} else {\n+\t\t\tp, path = path[:i], path[i+1:]\n+\t\t}\n+\n+\t\tif p == \"\" {\n+\t\t\tif b.Len() == 0 {\n+\t\t\t\t// must be absolute path\n+\t\t\t\tb.WriteRune(Separator)\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tfi, err := os.Lstat(b.String() + p)\n+\t\tif err != nil {\n+\t\t\treturn \"\", err\n+\t\t}\n+\t\tif fi.Mode()&os.ModeSymlink == 0 {\n+\t\t\tb.WriteString(p)\n+\t\t\tif path != \"\" {\n+\t\t\t\tb.WriteRune(Separator)\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\t// it's a symlink, put it at the front of path\n+\t\tdest, err := os.Readlink(b.String() + p)\n+\t\tif err != nil {\n+\t\t\treturn \"\", err\n+\t\t}\n+\t\tif IsAbs(dest) {\n+\t\t\tb.Reset()\n+\t\t}\n+\t\tpath = dest + string(Separator) + path\n+\t}\n+\treturn Clean(b.String()), nil\n+}"}, {"sha": "afa88bfe876f1ea1dca7f8af50617305e70728e0", "filename": "libgo/go/path/filepath/symlink_windows.go", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fpath%2Ffilepath%2Fsymlink_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fpath%2Ffilepath%2Fsymlink_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Ffilepath%2Fsymlink_windows.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package filepath\n+\n+import (\n+\t\"syscall\"\n+)\n+\n+func evalSymlinks(path string) (string, error) {\n+\tp := syscall.StringToUTF16(path)\n+\tb := p // GetLongPathName says we can reuse buffer\n+\tn, err := syscall.GetLongPathName(&p[0], &b[0], uint32(len(b)))\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\tif n > uint32(len(b)) {\n+\t\tb = make([]uint16, n)\n+\t\tn, err = syscall.GetLongPathName(&p[0], &b[0], uint32(len(b)))\n+\t\tif err != nil {\n+\t\t\treturn \"\", err\n+\t\t}\n+\t}\n+\tb = b[:n]\n+\treturn Clean(syscall.UTF16ToString(b)), nil\n+}"}, {"sha": "92e84f43b06a6857d2e82ae6c0406128c7023357", "filename": "libgo/go/reflect/type.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Freflect%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Freflect%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Ftype.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -234,6 +234,7 @@ type commonType struct {\n \tkind       uint8   // enumeration for C\n \talign      int8    // alignment of variable with this type\n \tfieldAlign uint8   // alignment of struct field with this type\n+\t_          uint8   // unused/padding\n \tsize       uintptr // size in bytes\n \thash       uint32  // hash of type; avoids computation in hash tables\n "}, {"sha": "f3a0a7cfde5660e61204f4eb22ec7dd99b74f8da", "filename": "libgo/go/reflect/value.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Freflect%2Fvalue.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Freflect%2Fvalue.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fvalue.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -54,6 +54,10 @@ func memmove(adst, asrc unsafe.Pointer, n uintptr) {\n // its String method returns \"<invalid Value>\", and all other methods panic.\n // Most functions and methods never return an invalid value.\n // If one does, its documentation states the conditions explicitly.\n+//\n+// A Value can be used concurrently by multiple goroutines provided that\n+// the underlying Go value can be used concurrently for the equivalent\n+// direct operations.\n type Value struct {\n \t// typ holds the type of the value represented by a Value.\n \ttyp *commonType"}, {"sha": "0ed3b183fe2e2e40a97c92443639cec7738e643e", "filename": "libgo/go/runtime/compiler.go", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fruntime%2Fcompiler.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fruntime%2Fcompiler.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fcompiler.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2012 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package runtime\n+\n+// Compiler is the name of the compiler toolchain that built the\n+// running binary.  Known toolchains are:\n+//\n+//\tgc      The 5g/6g/8g compiler suite at code.google.com/p/go.\n+//\tgccgo   The gccgo front end, part of the GCC compiler suite.\n+//\n+const Compiler = \"gccgo\""}, {"sha": "f33f5072b40d7797b6f7cb3e9820fd7d18ed6214", "filename": "libgo/go/runtime/debug/stack_test.go", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fruntime%2Fdebug%2Fstack_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fruntime%2Fdebug%2Fstack_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fdebug%2Fstack_test.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -39,13 +39,20 @@ func TestStack(t *testing.T) {\n \tif len(lines) <= 6 {\n \t\tt.Fatal(\"too few lines\")\n \t}\n-\tcheck(t, lines[0], \"src/pkg/runtime/debug/stack_test.go\")\n-\tcheck(t, lines[1], \"\\t(*T).ptrmethod: return Stack()\")\n-\tcheck(t, lines[2], \"src/pkg/runtime/debug/stack_test.go\")\n-\tcheck(t, lines[3], \"\\tT.method: return t.ptrmethod()\")\n-\tcheck(t, lines[4], \"src/pkg/runtime/debug/stack_test.go\")\n-\tcheck(t, lines[5], \"\\tTestStack: b := T(0).method()\")\n-\tcheck(t, lines[6], \"src/pkg/testing/testing.go\")\n+\tn := 0\n+\tframe := func(line, code string) {\n+\t\tcheck(t, lines[n], line)\n+\t\tn++\n+\t\t// The source might not be available while running the test.\n+\t\tif strings.HasPrefix(lines[n], \"\\t\") {\n+\t\t\tcheck(t, lines[n], code)\n+\t\t\tn++\n+\t\t}\n+\t}\n+\tframe(\"src/pkg/runtime/debug/stack_test.go\", \"\\t(*T).ptrmethod: return Stack()\")\n+\tframe(\"src/pkg/runtime/debug/stack_test.go\", \"\\tT.method: return t.ptrmethod()\")\n+\tframe(\"src/pkg/runtime/debug/stack_test.go\", \"\\tTestStack: b := T(0).method()\")\n+\tframe(\"src/pkg/testing/testing.go\", \"\")\n }\n \n func check(t *testing.T, line, has string) {"}, {"sha": "82bb2a2926b20358e30f632a68f69cdbf89a630a", "filename": "libgo/go/runtime/pprof/pprof_test.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof_test.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -24,8 +24,9 @@ func TestCPUProfile(t *testing.T) {\n \t\t}\n \t\tvers := string(out)\n \t\tt.Logf(\"uname -a: %v\", vers)\n-\t\tif strings.Contains(vers, \"Darwin Kernel Version 10.8.0\") && strings.Contains(vers, \"root:xnu-1504.15.3~1/RELEASE_X86_64\") {\n-\t\t\tt.Logf(\"skipping test on known-broken kernel (64-bit Snow Leopard)\")\n+\t\t// Lion uses \"Darwin Kernel Version 11\".\n+\t\tif strings.Contains(vers, \"Darwin Kernel Version 10\") && strings.Contains(vers, \"RELEASE_X86_64\") {\n+\t\t\tt.Logf(\"skipping test on known-broken kernel (64-bit Leopard / Snow Leopard)\")\n \t\t\treturn\n \t\t}\n \tcase \"plan9\":"}, {"sha": "a03a07bfb5fb476aa4be3672f0c4adc85b52e431", "filename": "libgo/go/strconv/isprint.go", "status": "added", "additions": 521, "deletions": 0, "changes": 521, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fstrconv%2Fisprint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fstrconv%2Fisprint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Fisprint.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -0,0 +1,521 @@\n+// DO NOT EDIT.  GENERATED BY\n+//     go run makeisprint.go >x && mv x isprint.go\n+\n+package strconv\n+\n+// (474+134+42)*2 + (180)*4 = 2020 bytes\n+\n+var isPrint16 = []uint16{\n+\t0x0020, 0x007e,\n+\t0x00a1, 0x0377,\n+\t0x037a, 0x037e,\n+\t0x0384, 0x0527,\n+\t0x0531, 0x0556,\n+\t0x0559, 0x058a,\n+\t0x0591, 0x05c7,\n+\t0x05d0, 0x05ea,\n+\t0x05f0, 0x05f4,\n+\t0x0606, 0x061b,\n+\t0x061e, 0x070d,\n+\t0x0710, 0x074a,\n+\t0x074d, 0x07b1,\n+\t0x07c0, 0x07fa,\n+\t0x0800, 0x082d,\n+\t0x0830, 0x085b,\n+\t0x085e, 0x085e,\n+\t0x0900, 0x098c,\n+\t0x098f, 0x0990,\n+\t0x0993, 0x09b2,\n+\t0x09b6, 0x09b9,\n+\t0x09bc, 0x09c4,\n+\t0x09c7, 0x09c8,\n+\t0x09cb, 0x09ce,\n+\t0x09d7, 0x09d7,\n+\t0x09dc, 0x09e3,\n+\t0x09e6, 0x09fb,\n+\t0x0a01, 0x0a0a,\n+\t0x0a0f, 0x0a10,\n+\t0x0a13, 0x0a39,\n+\t0x0a3c, 0x0a42,\n+\t0x0a47, 0x0a48,\n+\t0x0a4b, 0x0a4d,\n+\t0x0a51, 0x0a51,\n+\t0x0a59, 0x0a5e,\n+\t0x0a66, 0x0a75,\n+\t0x0a81, 0x0ab9,\n+\t0x0abc, 0x0acd,\n+\t0x0ad0, 0x0ad0,\n+\t0x0ae0, 0x0ae3,\n+\t0x0ae6, 0x0af1,\n+\t0x0b01, 0x0b0c,\n+\t0x0b0f, 0x0b10,\n+\t0x0b13, 0x0b39,\n+\t0x0b3c, 0x0b44,\n+\t0x0b47, 0x0b48,\n+\t0x0b4b, 0x0b4d,\n+\t0x0b56, 0x0b57,\n+\t0x0b5c, 0x0b63,\n+\t0x0b66, 0x0b77,\n+\t0x0b82, 0x0b8a,\n+\t0x0b8e, 0x0b95,\n+\t0x0b99, 0x0b9f,\n+\t0x0ba3, 0x0ba4,\n+\t0x0ba8, 0x0baa,\n+\t0x0bae, 0x0bb9,\n+\t0x0bbe, 0x0bc2,\n+\t0x0bc6, 0x0bcd,\n+\t0x0bd0, 0x0bd0,\n+\t0x0bd7, 0x0bd7,\n+\t0x0be6, 0x0bfa,\n+\t0x0c01, 0x0c39,\n+\t0x0c3d, 0x0c4d,\n+\t0x0c55, 0x0c59,\n+\t0x0c60, 0x0c63,\n+\t0x0c66, 0x0c6f,\n+\t0x0c78, 0x0c7f,\n+\t0x0c82, 0x0cb9,\n+\t0x0cbc, 0x0ccd,\n+\t0x0cd5, 0x0cd6,\n+\t0x0cde, 0x0ce3,\n+\t0x0ce6, 0x0cf2,\n+\t0x0d02, 0x0d3a,\n+\t0x0d3d, 0x0d4e,\n+\t0x0d57, 0x0d57,\n+\t0x0d60, 0x0d63,\n+\t0x0d66, 0x0d75,\n+\t0x0d79, 0x0d7f,\n+\t0x0d82, 0x0d96,\n+\t0x0d9a, 0x0dbd,\n+\t0x0dc0, 0x0dc6,\n+\t0x0dca, 0x0dca,\n+\t0x0dcf, 0x0ddf,\n+\t0x0df2, 0x0df4,\n+\t0x0e01, 0x0e3a,\n+\t0x0e3f, 0x0e5b,\n+\t0x0e81, 0x0e84,\n+\t0x0e87, 0x0e8a,\n+\t0x0e8d, 0x0e8d,\n+\t0x0e94, 0x0ea7,\n+\t0x0eaa, 0x0ebd,\n+\t0x0ec0, 0x0ecd,\n+\t0x0ed0, 0x0ed9,\n+\t0x0edc, 0x0edd,\n+\t0x0f00, 0x0f6c,\n+\t0x0f71, 0x0fda,\n+\t0x1000, 0x10c5,\n+\t0x10d0, 0x10fc,\n+\t0x1100, 0x124d,\n+\t0x1250, 0x125d,\n+\t0x1260, 0x128d,\n+\t0x1290, 0x12b5,\n+\t0x12b8, 0x12c5,\n+\t0x12c8, 0x1315,\n+\t0x1318, 0x135a,\n+\t0x135d, 0x137c,\n+\t0x1380, 0x1399,\n+\t0x13a0, 0x13f4,\n+\t0x1400, 0x169c,\n+\t0x16a0, 0x16f0,\n+\t0x1700, 0x1714,\n+\t0x1720, 0x1736,\n+\t0x1740, 0x1753,\n+\t0x1760, 0x1773,\n+\t0x1780, 0x17b3,\n+\t0x17b6, 0x17dd,\n+\t0x17e0, 0x17e9,\n+\t0x17f0, 0x17f9,\n+\t0x1800, 0x180d,\n+\t0x1810, 0x1819,\n+\t0x1820, 0x1877,\n+\t0x1880, 0x18aa,\n+\t0x18b0, 0x18f5,\n+\t0x1900, 0x191c,\n+\t0x1920, 0x192b,\n+\t0x1930, 0x193b,\n+\t0x1940, 0x1940,\n+\t0x1944, 0x196d,\n+\t0x1970, 0x1974,\n+\t0x1980, 0x19ab,\n+\t0x19b0, 0x19c9,\n+\t0x19d0, 0x19da,\n+\t0x19de, 0x1a1b,\n+\t0x1a1e, 0x1a7c,\n+\t0x1a7f, 0x1a89,\n+\t0x1a90, 0x1a99,\n+\t0x1aa0, 0x1aad,\n+\t0x1b00, 0x1b4b,\n+\t0x1b50, 0x1b7c,\n+\t0x1b80, 0x1baa,\n+\t0x1bae, 0x1bb9,\n+\t0x1bc0, 0x1bf3,\n+\t0x1bfc, 0x1c37,\n+\t0x1c3b, 0x1c49,\n+\t0x1c4d, 0x1c7f,\n+\t0x1cd0, 0x1cf2,\n+\t0x1d00, 0x1de6,\n+\t0x1dfc, 0x1f15,\n+\t0x1f18, 0x1f1d,\n+\t0x1f20, 0x1f45,\n+\t0x1f48, 0x1f4d,\n+\t0x1f50, 0x1f7d,\n+\t0x1f80, 0x1fd3,\n+\t0x1fd6, 0x1fef,\n+\t0x1ff2, 0x1ffe,\n+\t0x2010, 0x2027,\n+\t0x2030, 0x205e,\n+\t0x2070, 0x2071,\n+\t0x2074, 0x209c,\n+\t0x20a0, 0x20b9,\n+\t0x20d0, 0x20f0,\n+\t0x2100, 0x2189,\n+\t0x2190, 0x23f3,\n+\t0x2400, 0x2426,\n+\t0x2440, 0x244a,\n+\t0x2460, 0x2b4c,\n+\t0x2b50, 0x2b59,\n+\t0x2c00, 0x2cf1,\n+\t0x2cf9, 0x2d25,\n+\t0x2d30, 0x2d65,\n+\t0x2d6f, 0x2d70,\n+\t0x2d7f, 0x2d96,\n+\t0x2da0, 0x2e31,\n+\t0x2e80, 0x2ef3,\n+\t0x2f00, 0x2fd5,\n+\t0x2ff0, 0x2ffb,\n+\t0x3001, 0x3096,\n+\t0x3099, 0x30ff,\n+\t0x3105, 0x312d,\n+\t0x3131, 0x31ba,\n+\t0x31c0, 0x31e3,\n+\t0x31f0, 0x4db5,\n+\t0x4dc0, 0x9fcb,\n+\t0xa000, 0xa48c,\n+\t0xa490, 0xa4c6,\n+\t0xa4d0, 0xa62b,\n+\t0xa640, 0xa673,\n+\t0xa67c, 0xa697,\n+\t0xa6a0, 0xa6f7,\n+\t0xa700, 0xa791,\n+\t0xa7a0, 0xa7a9,\n+\t0xa7fa, 0xa82b,\n+\t0xa830, 0xa839,\n+\t0xa840, 0xa877,\n+\t0xa880, 0xa8c4,\n+\t0xa8ce, 0xa8d9,\n+\t0xa8e0, 0xa8fb,\n+\t0xa900, 0xa953,\n+\t0xa95f, 0xa97c,\n+\t0xa980, 0xa9d9,\n+\t0xa9de, 0xa9df,\n+\t0xaa00, 0xaa36,\n+\t0xaa40, 0xaa4d,\n+\t0xaa50, 0xaa59,\n+\t0xaa5c, 0xaa7b,\n+\t0xaa80, 0xaac2,\n+\t0xaadb, 0xaadf,\n+\t0xab01, 0xab06,\n+\t0xab09, 0xab0e,\n+\t0xab11, 0xab16,\n+\t0xab20, 0xab2e,\n+\t0xabc0, 0xabed,\n+\t0xabf0, 0xabf9,\n+\t0xac00, 0xd7a3,\n+\t0xd7b0, 0xd7c6,\n+\t0xd7cb, 0xd7fb,\n+\t0xf900, 0xfa2d,\n+\t0xfa30, 0xfa6d,\n+\t0xfa70, 0xfad9,\n+\t0xfb00, 0xfb06,\n+\t0xfb13, 0xfb17,\n+\t0xfb1d, 0xfbc1,\n+\t0xfbd3, 0xfd3f,\n+\t0xfd50, 0xfd8f,\n+\t0xfd92, 0xfdc7,\n+\t0xfdf0, 0xfdfd,\n+\t0xfe00, 0xfe19,\n+\t0xfe20, 0xfe26,\n+\t0xfe30, 0xfe6b,\n+\t0xfe70, 0xfefc,\n+\t0xff01, 0xffbe,\n+\t0xffc2, 0xffc7,\n+\t0xffca, 0xffcf,\n+\t0xffd2, 0xffd7,\n+\t0xffda, 0xffdc,\n+\t0xffe0, 0xffee,\n+\t0xfffc, 0xfffd,\n+}\n+\n+var isNotPrint16 = []uint16{\n+\t0x00ad,\n+\t0x038b,\n+\t0x038d,\n+\t0x03a2,\n+\t0x0560,\n+\t0x0588,\n+\t0x06dd,\n+\t0x083f,\n+\t0x0978,\n+\t0x0980,\n+\t0x0984,\n+\t0x09a9,\n+\t0x09b1,\n+\t0x09de,\n+\t0x0a04,\n+\t0x0a29,\n+\t0x0a31,\n+\t0x0a34,\n+\t0x0a37,\n+\t0x0a3d,\n+\t0x0a5d,\n+\t0x0a84,\n+\t0x0a8e,\n+\t0x0a92,\n+\t0x0aa9,\n+\t0x0ab1,\n+\t0x0ab4,\n+\t0x0ac6,\n+\t0x0aca,\n+\t0x0af0,\n+\t0x0b04,\n+\t0x0b29,\n+\t0x0b31,\n+\t0x0b34,\n+\t0x0b5e,\n+\t0x0b84,\n+\t0x0b91,\n+\t0x0b9b,\n+\t0x0b9d,\n+\t0x0bc9,\n+\t0x0c04,\n+\t0x0c0d,\n+\t0x0c11,\n+\t0x0c29,\n+\t0x0c34,\n+\t0x0c45,\n+\t0x0c49,\n+\t0x0c57,\n+\t0x0c84,\n+\t0x0c8d,\n+\t0x0c91,\n+\t0x0ca9,\n+\t0x0cb4,\n+\t0x0cc5,\n+\t0x0cc9,\n+\t0x0cdf,\n+\t0x0cf0,\n+\t0x0d04,\n+\t0x0d0d,\n+\t0x0d11,\n+\t0x0d45,\n+\t0x0d49,\n+\t0x0d84,\n+\t0x0db2,\n+\t0x0dbc,\n+\t0x0dd5,\n+\t0x0dd7,\n+\t0x0e83,\n+\t0x0e89,\n+\t0x0e98,\n+\t0x0ea0,\n+\t0x0ea4,\n+\t0x0ea6,\n+\t0x0eac,\n+\t0x0eba,\n+\t0x0ec5,\n+\t0x0ec7,\n+\t0x0f48,\n+\t0x0f98,\n+\t0x0fbd,\n+\t0x0fcd,\n+\t0x1249,\n+\t0x1257,\n+\t0x1259,\n+\t0x1289,\n+\t0x12b1,\n+\t0x12bf,\n+\t0x12c1,\n+\t0x12d7,\n+\t0x1311,\n+\t0x1680,\n+\t0x170d,\n+\t0x176d,\n+\t0x1771,\n+\t0x1a5f,\n+\t0x1f58,\n+\t0x1f5a,\n+\t0x1f5c,\n+\t0x1f5e,\n+\t0x1fb5,\n+\t0x1fc5,\n+\t0x1fdc,\n+\t0x1ff5,\n+\t0x208f,\n+\t0x2700,\n+\t0x27cb,\n+\t0x27cd,\n+\t0x2c2f,\n+\t0x2c5f,\n+\t0x2da7,\n+\t0x2daf,\n+\t0x2db7,\n+\t0x2dbf,\n+\t0x2dc7,\n+\t0x2dcf,\n+\t0x2dd7,\n+\t0x2ddf,\n+\t0x2e9a,\n+\t0x3040,\n+\t0x318f,\n+\t0x321f,\n+\t0x32ff,\n+\t0xa78f,\n+\t0xa9ce,\n+\t0xab27,\n+\t0xfb37,\n+\t0xfb3d,\n+\t0xfb3f,\n+\t0xfb42,\n+\t0xfb45,\n+\t0xfe53,\n+\t0xfe67,\n+\t0xfe75,\n+\t0xffe7,\n+}\n+\n+var isPrint32 = []uint32{\n+\t0x010000, 0x01004d,\n+\t0x010050, 0x01005d,\n+\t0x010080, 0x0100fa,\n+\t0x010100, 0x010102,\n+\t0x010107, 0x010133,\n+\t0x010137, 0x01018a,\n+\t0x010190, 0x01019b,\n+\t0x0101d0, 0x0101fd,\n+\t0x010280, 0x01029c,\n+\t0x0102a0, 0x0102d0,\n+\t0x010300, 0x010323,\n+\t0x010330, 0x01034a,\n+\t0x010380, 0x0103c3,\n+\t0x0103c8, 0x0103d5,\n+\t0x010400, 0x01049d,\n+\t0x0104a0, 0x0104a9,\n+\t0x010800, 0x010805,\n+\t0x010808, 0x010838,\n+\t0x01083c, 0x01083c,\n+\t0x01083f, 0x01085f,\n+\t0x010900, 0x01091b,\n+\t0x01091f, 0x010939,\n+\t0x01093f, 0x01093f,\n+\t0x010a00, 0x010a06,\n+\t0x010a0c, 0x010a33,\n+\t0x010a38, 0x010a3a,\n+\t0x010a3f, 0x010a47,\n+\t0x010a50, 0x010a58,\n+\t0x010a60, 0x010a7f,\n+\t0x010b00, 0x010b35,\n+\t0x010b39, 0x010b55,\n+\t0x010b58, 0x010b72,\n+\t0x010b78, 0x010b7f,\n+\t0x010c00, 0x010c48,\n+\t0x010e60, 0x010e7e,\n+\t0x011000, 0x01104d,\n+\t0x011052, 0x01106f,\n+\t0x011080, 0x0110c1,\n+\t0x012000, 0x01236e,\n+\t0x012400, 0x012462,\n+\t0x012470, 0x012473,\n+\t0x013000, 0x01342e,\n+\t0x016800, 0x016a38,\n+\t0x01b000, 0x01b001,\n+\t0x01d000, 0x01d0f5,\n+\t0x01d100, 0x01d126,\n+\t0x01d129, 0x01d172,\n+\t0x01d17b, 0x01d1dd,\n+\t0x01d200, 0x01d245,\n+\t0x01d300, 0x01d356,\n+\t0x01d360, 0x01d371,\n+\t0x01d400, 0x01d49f,\n+\t0x01d4a2, 0x01d4a2,\n+\t0x01d4a5, 0x01d4a6,\n+\t0x01d4a9, 0x01d50a,\n+\t0x01d50d, 0x01d546,\n+\t0x01d54a, 0x01d6a5,\n+\t0x01d6a8, 0x01d7cb,\n+\t0x01d7ce, 0x01d7ff,\n+\t0x01f000, 0x01f02b,\n+\t0x01f030, 0x01f093,\n+\t0x01f0a0, 0x01f0ae,\n+\t0x01f0b1, 0x01f0be,\n+\t0x01f0c1, 0x01f0df,\n+\t0x01f100, 0x01f10a,\n+\t0x01f110, 0x01f169,\n+\t0x01f170, 0x01f19a,\n+\t0x01f1e6, 0x01f202,\n+\t0x01f210, 0x01f23a,\n+\t0x01f240, 0x01f248,\n+\t0x01f250, 0x01f251,\n+\t0x01f300, 0x01f320,\n+\t0x01f330, 0x01f37c,\n+\t0x01f380, 0x01f393,\n+\t0x01f3a0, 0x01f3ca,\n+\t0x01f3e0, 0x01f3f0,\n+\t0x01f400, 0x01f4fc,\n+\t0x01f500, 0x01f53d,\n+\t0x01f550, 0x01f567,\n+\t0x01f5fb, 0x01f625,\n+\t0x01f628, 0x01f62d,\n+\t0x01f630, 0x01f640,\n+\t0x01f645, 0x01f64f,\n+\t0x01f680, 0x01f6c5,\n+\t0x01f700, 0x01f773,\n+\t0x020000, 0x02a6d6,\n+\t0x02a700, 0x02b734,\n+\t0x02b740, 0x02b81d,\n+\t0x02f800, 0x02fa1d,\n+\t0x0e0100, 0x0e01ef,\n+}\n+\n+var isNotPrint32 = []uint16{ // add 0x10000 to each entry\n+\t0x000c,\n+\t0x0027,\n+\t0x003b,\n+\t0x003e,\n+\t0x031f,\n+\t0x039e,\n+\t0x0809,\n+\t0x0836,\n+\t0x0856,\n+\t0x0a04,\n+\t0x0a14,\n+\t0x0a18,\n+\t0x10bd,\n+\t0xd455,\n+\t0xd49d,\n+\t0xd4ad,\n+\t0xd4ba,\n+\t0xd4bc,\n+\t0xd4c4,\n+\t0xd506,\n+\t0xd515,\n+\t0xd51d,\n+\t0xd53a,\n+\t0xd53f,\n+\t0xd545,\n+\t0xd551,\n+\t0xf0d0,\n+\t0xf12f,\n+\t0xf336,\n+\t0xf3c5,\n+\t0xf43f,\n+\t0xf441,\n+\t0xf4f8,\n+\t0xf600,\n+\t0xf611,\n+\t0xf615,\n+\t0xf617,\n+\t0xf619,\n+\t0xf61b,\n+\t0xf61f,\n+\t0xf62c,\n+\t0xf634,\n+}"}, {"sha": "8a6699bdb52e378e618d2946f0e071db7500d22d", "filename": "libgo/go/strconv/makeisprint.go", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fstrconv%2Fmakeisprint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fstrconv%2Fmakeisprint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Fmakeisprint.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -0,0 +1,162 @@\n+// Copyright 2012 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build ignore\n+\n+// makeisprint generates the tables for strconv's compact isPrint.\n+package main\n+\n+import (\n+\t\"fmt\"\n+\t\"os\"\n+\t\"unicode\"\n+)\n+\n+var (\n+\trange16  []uint16\n+\texcept16 []uint16\n+\trange32  []uint32\n+\texcept32 []uint32\n+)\n+\n+// bsearch16 returns the smallest i such that a[i] >= x.\n+// If there is no such i, bsearch16 returns len(a).\n+func bsearch16(a []uint16, x uint16) int {\n+\ti, j := 0, len(a)\n+\tfor i < j {\n+\t\th := i + (j-i)/2\n+\t\tif a[h] < x {\n+\t\t\ti = h + 1\n+\t\t} else {\n+\t\t\tj = h\n+\t\t}\n+\t}\n+\treturn i\n+}\n+\n+// bsearch32 returns the smallest i such that a[i] >= x.\n+// If there is no such i, bsearch32 returns len(a).\n+func bsearch32(a []uint32, x uint32) int {\n+\ti, j := 0, len(a)\n+\tfor i < j {\n+\t\th := i + (j-i)/2\n+\t\tif a[h] < x {\n+\t\t\ti = h + 1\n+\t\t} else {\n+\t\t\tj = h\n+\t\t}\n+\t}\n+\treturn i\n+}\n+\n+func isPrint(r rune) bool {\n+\t// Same algorithm, either on uint16 or uint32 value.\n+\t// First, find first i such that rang[i] >= x.\n+\t// This is the index of either the start or end of a pair that might span x.\n+\t// The start is even (rang[i&^1]) and the end is odd (rang[i|1]).\n+\t// If we find x in a range, make sure x is not in exception list.\n+\n+\tif 0 <= r && r < 1<<16 {\n+\t\trr, rang, except := uint16(r), range16, except16\n+\t\ti := bsearch16(rang, rr)\n+\t\tif i >= len(rang) || rr < rang[i&^1] || rang[i|1] < rr {\n+\t\t\treturn false\n+\t\t}\n+\t\tj := bsearch16(except, rr)\n+\t\treturn j >= len(except) || except[j] != rr\n+\t}\n+\n+\trr, rang, except := uint32(r), range32, except32\n+\ti := bsearch32(rang, rr)\n+\tif i >= len(rang) || rr < rang[i&^1] || rang[i|1] < rr {\n+\t\treturn false\n+\t}\n+\tj := bsearch32(except, rr)\n+\treturn j >= len(except) || except[j] != rr\n+}\n+\n+func scan(min, max rune) (rang, except []uint32) {\n+\tlo := rune(-1)\n+\tfor i := min; ; i++ {\n+\t\tif (i > max || !unicode.IsPrint(i)) && lo >= 0 {\n+\t\t\t// End range, but avoid flip flop.\n+\t\t\tif i+1 <= max && unicode.IsPrint(i+1) {\n+\t\t\t\texcept = append(except, uint32(i))\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\trang = append(rang, uint32(lo), uint32(i-1))\n+\t\t\tlo = -1\n+\t\t}\n+\t\tif i > max {\n+\t\t\tbreak\n+\t\t}\n+\t\tif lo < 0 && unicode.IsPrint(i) {\n+\t\t\tlo = i\n+\t\t}\n+\t}\n+\treturn\n+}\n+\n+func to16(x []uint32) []uint16 {\n+\tvar y []uint16\n+\tfor _, v := range x {\n+\t\tif uint32(uint16(v)) != v {\n+\t\t\tpanic(\"bad 32->16 conversion\")\n+\t\t}\n+\t\ty = append(y, uint16(v))\n+\t}\n+\treturn y\n+}\n+\n+func main() {\n+\trang, except := scan(0, 0xFFFF)\n+\trange16 = to16(rang)\n+\texcept16 = to16(except)\n+\trange32, except32 = scan(0x10000, unicode.MaxRune)\n+\n+\tfor i := rune(0); i <= unicode.MaxRune; i++ {\n+\t\tif isPrint(i) != unicode.IsPrint(i) {\n+\t\t\tfmt.Fprintf(os.Stderr, \"%U: isPrint=%v, want %v\\n\", i, isPrint(i), unicode.IsPrint(i))\n+\t\t\treturn\n+\t\t}\n+\t}\n+\n+\tfmt.Printf(\"// DO NOT EDIT.  GENERATED BY\\n\")\n+\tfmt.Printf(\"//     go run makeisprint.go >x && mv x isprint.go\\n\\n\")\n+\tfmt.Printf(\"package strconv\\n\\n\")\n+\n+\tfmt.Printf(\"// (%d+%d+%d)*2 + (%d)*4 = %d bytes\\n\\n\",\n+\t\tlen(range16), len(except16), len(except32),\n+\t\tlen(range32),\n+\t\t(len(range16)+len(except16)+len(except32))*2+\n+\t\t\t(len(range32))*4)\n+\n+\tfmt.Printf(\"var isPrint16 = []uint16{\\n\")\n+\tfor i := 0; i < len(range16); i += 2 {\n+\t\tfmt.Printf(\"\\t%#04x, %#04x,\\n\", range16[i], range16[i+1])\n+\t}\n+\tfmt.Printf(\"}\\n\\n\")\n+\n+\tfmt.Printf(\"var isNotPrint16 = []uint16{\\n\")\n+\tfor _, r := range except16 {\n+\t\tfmt.Printf(\"\\t%#04x,\\n\", r)\n+\t}\n+\tfmt.Printf(\"}\\n\\n\")\n+\n+\tfmt.Printf(\"var isPrint32 = []uint32{\\n\")\n+\tfor i := 0; i < len(range32); i += 2 {\n+\t\tfmt.Printf(\"\\t%#06x, %#06x,\\n\", range32[i], range32[i+1])\n+\t}\n+\tfmt.Printf(\"}\\n\\n\")\n+\n+\tfmt.Printf(\"var isNotPrint32 = []uint16{ // add 0x10000 to each entry\\n\")\n+\tfor _, r := range except32 {\n+\t\tif r >= 0x20000 {\n+\t\t\tfmt.Fprintf(os.Stderr, \"%U too big for isNotPrint32\\n\", r)\n+\t\t\treturn\n+\t\t}\n+\t\tfmt.Printf(\"\\t%#04x,\\n\", r-0x10000)\n+\t}\n+\tfmt.Printf(\"}\\n\")\n+}"}, {"sha": "8a73f9d3b28302966185e86289787a54369bf32e", "filename": "libgo/go/strconv/quote.go", "status": "modified", "additions": 136, "deletions": 45, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fstrconv%2Fquote.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fstrconv%2Fquote.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Fquote.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -5,89 +5,88 @@\n package strconv\n \n import (\n-\t\"bytes\"\n-\t\"strings\"\n-\t\"unicode\"\n \t\"unicode/utf8\"\n )\n \n const lowerhex = \"0123456789abcdef\"\n \n func quoteWith(s string, quote byte, ASCIIonly bool) string {\n-\tvar buf bytes.Buffer\n-\tbuf.WriteByte(quote)\n+\tvar runeTmp [utf8.UTFMax]byte\n+\tbuf := make([]byte, 0, 3*len(s)/2) // Try to avoid more allocations.\n+\tbuf = append(buf, quote)\n \tfor width := 0; len(s) > 0; s = s[width:] {\n \t\tr := rune(s[0])\n \t\twidth = 1\n \t\tif r >= utf8.RuneSelf {\n \t\t\tr, width = utf8.DecodeRuneInString(s)\n \t\t}\n \t\tif width == 1 && r == utf8.RuneError {\n-\t\t\tbuf.WriteString(`\\x`)\n-\t\t\tbuf.WriteByte(lowerhex[s[0]>>4])\n-\t\t\tbuf.WriteByte(lowerhex[s[0]&0xF])\n+\t\t\tbuf = append(buf, `\\x`...)\n+\t\t\tbuf = append(buf, lowerhex[s[0]>>4])\n+\t\t\tbuf = append(buf, lowerhex[s[0]&0xF])\n \t\t\tcontinue\n \t\t}\n \t\tif r == rune(quote) || r == '\\\\' { // always backslashed\n-\t\t\tbuf.WriteByte('\\\\')\n-\t\t\tbuf.WriteByte(byte(r))\n+\t\t\tbuf = append(buf, '\\\\')\n+\t\t\tbuf = append(buf, byte(r))\n \t\t\tcontinue\n \t\t}\n \t\tif ASCIIonly {\n-\t\t\tif r <= unicode.MaxASCII && unicode.IsPrint(r) {\n-\t\t\t\tbuf.WriteRune(r)\n+\t\t\tif r < utf8.RuneSelf && IsPrint(r) {\n+\t\t\t\tbuf = append(buf, byte(r))\n \t\t\t\tcontinue\n \t\t\t}\n-\t\t} else if unicode.IsPrint(r) {\n-\t\t\tbuf.WriteRune(r)\n+\t\t} else if IsPrint(r) {\n+\t\t\tn := utf8.EncodeRune(runeTmp[:], r)\n+\t\t\tbuf = append(buf, runeTmp[:n]...)\n \t\t\tcontinue\n \t\t}\n \t\tswitch r {\n \t\tcase '\\a':\n-\t\t\tbuf.WriteString(`\\a`)\n+\t\t\tbuf = append(buf, `\\a`...)\n \t\tcase '\\b':\n-\t\t\tbuf.WriteString(`\\b`)\n+\t\t\tbuf = append(buf, `\\b`...)\n \t\tcase '\\f':\n-\t\t\tbuf.WriteString(`\\f`)\n+\t\t\tbuf = append(buf, `\\f`...)\n \t\tcase '\\n':\n-\t\t\tbuf.WriteString(`\\n`)\n+\t\t\tbuf = append(buf, `\\n`...)\n \t\tcase '\\r':\n-\t\t\tbuf.WriteString(`\\r`)\n+\t\t\tbuf = append(buf, `\\r`...)\n \t\tcase '\\t':\n-\t\t\tbuf.WriteString(`\\t`)\n+\t\t\tbuf = append(buf, `\\t`...)\n \t\tcase '\\v':\n-\t\t\tbuf.WriteString(`\\v`)\n+\t\t\tbuf = append(buf, `\\v`...)\n \t\tdefault:\n \t\t\tswitch {\n \t\t\tcase r < ' ':\n-\t\t\t\tbuf.WriteString(`\\x`)\n-\t\t\t\tbuf.WriteByte(lowerhex[s[0]>>4])\n-\t\t\t\tbuf.WriteByte(lowerhex[s[0]&0xF])\n-\t\t\tcase r > unicode.MaxRune:\n+\t\t\t\tbuf = append(buf, `\\x`...)\n+\t\t\t\tbuf = append(buf, lowerhex[s[0]>>4])\n+\t\t\t\tbuf = append(buf, lowerhex[s[0]&0xF])\n+\t\t\tcase r > utf8.MaxRune:\n \t\t\t\tr = 0xFFFD\n \t\t\t\tfallthrough\n \t\t\tcase r < 0x10000:\n-\t\t\t\tbuf.WriteString(`\\u`)\n+\t\t\t\tbuf = append(buf, `\\u`...)\n \t\t\t\tfor s := 12; s >= 0; s -= 4 {\n-\t\t\t\t\tbuf.WriteByte(lowerhex[r>>uint(s)&0xF])\n+\t\t\t\t\tbuf = append(buf, lowerhex[r>>uint(s)&0xF])\n \t\t\t\t}\n \t\t\tdefault:\n-\t\t\t\tbuf.WriteString(`\\U`)\n+\t\t\t\tbuf = append(buf, `\\U`...)\n \t\t\t\tfor s := 28; s >= 0; s -= 4 {\n-\t\t\t\t\tbuf.WriteByte(lowerhex[r>>uint(s)&0xF])\n+\t\t\t\t\tbuf = append(buf, lowerhex[r>>uint(s)&0xF])\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n-\tbuf.WriteByte(quote)\n-\treturn buf.String()\n+\tbuf = append(buf, quote)\n+\treturn string(buf)\n \n }\n \n // Quote returns a double-quoted Go string literal representing s.  The\n // returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for\n // control characters and non-printable characters as defined by\n-// unicode.IsPrint.\n+// IsPrint.\n func Quote(s string) string {\n \treturn quoteWith(s, '\"', false)\n }\n@@ -100,8 +99,7 @@ func AppendQuote(dst []byte, s string) []byte {\n \n // QuoteToASCII returns a double-quoted Go string literal representing s.\n // The returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for\n-// non-ASCII characters and non-printable characters as defined by\n-// unicode.IsPrint.\n+// non-ASCII characters and non-printable characters as defined by IsPrint.\n func QuoteToASCII(s string) string {\n \treturn quoteWith(s, '\"', true)\n }\n@@ -114,8 +112,7 @@ func AppendQuoteToASCII(dst []byte, s string) []byte {\n \n // QuoteRune returns a single-quoted Go character literal representing the\n // rune.  The returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100)\n-// for control characters and non-printable characters as defined by\n-// unicode.IsPrint.\n+// for control characters and non-printable characters as defined by IsPrint.\n func QuoteRune(r rune) string {\n \t// TODO: avoid the allocation here.\n \treturn quoteWith(string(r), '\\'', false)\n@@ -130,7 +127,7 @@ func AppendQuoteRune(dst []byte, r rune) []byte {\n // QuoteRuneToASCII returns a single-quoted Go character literal representing\n // the rune.  The returned string uses Go escape sequences (\\t, \\n, \\xFF,\n // \\u0100) for non-ASCII characters and non-printable characters as defined\n-// by unicode.IsPrint.\n+// by IsPrint.\n func QuoteRuneToASCII(r rune) string {\n \t// TODO: avoid the allocation here.\n \treturn quoteWith(string(r), '\\'', true)\n@@ -245,7 +242,7 @@ func UnquoteChar(s string, quote byte) (value rune, multibyte bool, tail string,\n \t\t\tvalue = v\n \t\t\tbreak\n \t\t}\n-\t\tif v > unicode.MaxRune {\n+\t\tif v > utf8.MaxRune {\n \t\t\terr = ErrSyntax\n \t\t\treturn\n \t\t}\n@@ -304,20 +301,20 @@ func Unquote(s string) (t string, err error) {\n \ts = s[1 : n-1]\n \n \tif quote == '`' {\n-\t\tif strings.Contains(s, \"`\") {\n+\t\tif contains(s, '`') {\n \t\t\treturn \"\", ErrSyntax\n \t\t}\n \t\treturn s, nil\n \t}\n \tif quote != '\"' && quote != '\\'' {\n \t\treturn \"\", ErrSyntax\n \t}\n-\tif strings.Index(s, \"\\n\") >= 0 {\n+\tif contains(s, '\\n') {\n \t\treturn \"\", ErrSyntax\n \t}\n \n \t// Is it trivial?  Avoid allocation.\n-\tif strings.Index(s, `\\`) < 0 && strings.IndexRune(s, rune(quote)) < 0 {\n+\tif !contains(s, '\\\\') && !contains(s, quote) {\n \t\tswitch quote {\n \t\tcase '\"':\n \t\t\treturn s, nil\n@@ -329,22 +326,116 @@ func Unquote(s string) (t string, err error) {\n \t\t}\n \t}\n \n-\tvar buf bytes.Buffer\n+\tvar runeTmp [utf8.UTFMax]byte\n+\tbuf := make([]byte, 0, 3*len(s)/2) // Try to avoid more allocations.\n \tfor len(s) > 0 {\n \t\tc, multibyte, ss, err := UnquoteChar(s, quote)\n \t\tif err != nil {\n \t\t\treturn \"\", err\n \t\t}\n \t\ts = ss\n \t\tif c < utf8.RuneSelf || !multibyte {\n-\t\t\tbuf.WriteByte(byte(c))\n+\t\t\tbuf = append(buf, byte(c))\n \t\t} else {\n-\t\t\tbuf.WriteString(string(c))\n+\t\t\tn := utf8.EncodeRune(runeTmp[:], c)\n+\t\t\tbuf = append(buf, runeTmp[:n]...)\n \t\t}\n \t\tif quote == '\\'' && len(s) != 0 {\n \t\t\t// single-quoted must be single character\n \t\t\treturn \"\", ErrSyntax\n \t\t}\n \t}\n-\treturn buf.String(), nil\n+\treturn string(buf), nil\n+}\n+\n+// contains reports whether the string contains the byte c.\n+func contains(s string, c byte) bool {\n+\tfor i := 0; i < len(s); i++ {\n+\t\tif s[i] == c {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}\n+\n+// bsearch16 returns the smallest i such that a[i] >= x.\n+// If there is no such i, bsearch16 returns len(a).\n+func bsearch16(a []uint16, x uint16) int {\n+\ti, j := 0, len(a)\n+\tfor i < j {\n+\t\th := i + (j-i)/2\n+\t\tif a[h] < x {\n+\t\t\ti = h + 1\n+\t\t} else {\n+\t\t\tj = h\n+\t\t}\n+\t}\n+\treturn i\n+}\n+\n+// bsearch32 returns the smallest i such that a[i] >= x.\n+// If there is no such i, bsearch32 returns len(a).\n+func bsearch32(a []uint32, x uint32) int {\n+\ti, j := 0, len(a)\n+\tfor i < j {\n+\t\th := i + (j-i)/2\n+\t\tif a[h] < x {\n+\t\t\ti = h + 1\n+\t\t} else {\n+\t\t\tj = h\n+\t\t}\n+\t}\n+\treturn i\n+}\n+\n+// TODO: IsPrint is a local implementation of unicode.IsPrint, verified by the tests\n+// to give the same answer. It allows this package not to depend on unicode,\n+// and therefore not pull in all the Unicode tables. If the linker were better\n+// at tossing unused tables, we could get rid of this implementation.\n+// That would be nice.\n+\n+// IsPrint reports whether the rune is defined as printable by Go, with\n+// the same definition as unicode.IsPrint: letters, numbers, punctuation,\n+// symbols and ASCII space.\n+func IsPrint(r rune) bool {\n+\t// Fast check for Latin-1\n+\tif r <= 0xFF {\n+\t\tif 0x20 <= r && r <= 0x7E {\n+\t\t\t// All the ASCII is printable from space through DEL-1.\n+\t\t\treturn true\n+\t\t}\n+\t\tif 0xA1 <= r && r <= 0xFF {\n+\t\t\t// Similarly for \u00a1 through \u00ff...\n+\t\t\treturn r != 0xAD // ...except for the bizarre soft hyphen.\n+\t\t}\n+\t\treturn false\n+\t}\n+\n+\t// Same algorithm, either on uint16 or uint32 value.\n+\t// First, find first i such that isPrint[i] >= x.\n+\t// This is the index of either the start or end of a pair that might span x.\n+\t// The start is even (isPrint[i&^1]) and the end is odd (isPrint[i|1]).\n+\t// If we find x in a range, make sure x is not in isNotPrint list.\n+\n+\tif 0 <= r && r < 1<<16 {\n+\t\trr, isPrint, isNotPrint := uint16(r), isPrint16, isNotPrint16\n+\t\ti := bsearch16(isPrint, rr)\n+\t\tif i >= len(isPrint) || rr < isPrint[i&^1] || isPrint[i|1] < rr {\n+\t\t\treturn false\n+\t\t}\n+\t\tj := bsearch16(isNotPrint, rr)\n+\t\treturn j >= len(isNotPrint) || isNotPrint[j] != rr\n+\t}\n+\n+\trr, isPrint, isNotPrint := uint32(r), isPrint32, isNotPrint32\n+\ti := bsearch32(isPrint, rr)\n+\tif i >= len(isPrint) || rr < isPrint[i&^1] || isPrint[i|1] < rr {\n+\t\treturn false\n+\t}\n+\tif r >= 0x20000 {\n+\t\treturn true\n+\t}\n+\tr -= 0x10000\n+\tj := bsearch16(isNotPrint, uint16(r))\n+\treturn j >= len(isNotPrint) || isNotPrint[j] != uint16(r)\n }"}, {"sha": "61d9bf9a571428e351bb4cdde9689f45dd17f7fc", "filename": "libgo/go/strconv/quote_test.go", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fstrconv%2Fquote_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fstrconv%2Fquote_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Fquote_test.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -7,8 +7,23 @@ package strconv_test\n import (\n \t. \"strconv\"\n \t\"testing\"\n+\t\"unicode\"\n )\n \n+// Verify that our isPrint agrees with unicode.IsPrint\n+func TestIsPrint(t *testing.T) {\n+\tn := 0\n+\tfor r := rune(0); r <= unicode.MaxRune; r++ {\n+\t\tif IsPrint(r) != unicode.IsPrint(r) {\n+\t\t\tt.Errorf(\"IsPrint(%U)=%t incorrect\", r, IsPrint(r))\n+\t\t\tn++\n+\t\t\tif n > 10 {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n type quoteTest struct {\n \tin    string\n \tout   string"}, {"sha": "11417107282601c959b01aac2175f316a6f1262e", "filename": "libgo/go/strings/example_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fstrings%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fstrings%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrings%2Fexample_test.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -60,7 +60,7 @@ func ExampleIndex() {\n \t// -1\n }\n \n-func ExampleRune() {\n+func ExampleIndexRune() {\n \tfmt.Println(strings.IndexRune(\"chicken\", 'k'))\n \tfmt.Println(strings.IndexRune(\"chicken\", 'd'))\n \t// Output:"}, {"sha": "f60d997ce83d5aca8fcadfc0864ff9d597dd1cb8", "filename": "libgo/go/sync/atomic/atomic_test.go", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fsync%2Fatomic%2Fatomic_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Fsync%2Fatomic%2Fatomic_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsync%2Fatomic%2Fatomic_test.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -1012,6 +1012,10 @@ func TestHammerStoreLoad(t *testing.T) {\n }\n \n func TestStoreLoadSeqCst32(t *testing.T) {\n+\tif runtime.NumCPU() == 1 {\n+\t\tt.Logf(\"Skipping test on %v processor machine\", runtime.NumCPU())\n+\t\treturn\n+\t}\n \tdefer runtime.GOMAXPROCS(runtime.GOMAXPROCS(4))\n \tN := int32(1e3)\n \tif testing.Short() {\n@@ -1049,6 +1053,10 @@ func TestStoreLoadSeqCst32(t *testing.T) {\n }\n \n func TestStoreLoadSeqCst64(t *testing.T) {\n+\tif runtime.NumCPU() == 1 {\n+\t\tt.Logf(\"Skipping test on %v processor machine\", runtime.NumCPU())\n+\t\treturn\n+\t}\n \tif test64err != nil {\n \t\tt.Logf(\"Skipping 64-bit tests: %v\", test64err)\n \t\treturn\n@@ -1090,6 +1098,10 @@ func TestStoreLoadSeqCst64(t *testing.T) {\n }\n \n func TestStoreLoadRelAcq32(t *testing.T) {\n+\tif runtime.NumCPU() == 1 {\n+\t\tt.Logf(\"Skipping test on %v processor machine\", runtime.NumCPU())\n+\t\treturn\n+\t}\n \tdefer runtime.GOMAXPROCS(runtime.GOMAXPROCS(4))\n \tN := int32(1e3)\n \tif testing.Short() {\n@@ -1132,6 +1144,10 @@ func TestStoreLoadRelAcq32(t *testing.T) {\n }\n \n func TestStoreLoadRelAcq64(t *testing.T) {\n+\tif runtime.NumCPU() == 1 {\n+\t\tt.Logf(\"Skipping test on %v processor machine\", runtime.NumCPU())\n+\t\treturn\n+\t}\n \tif test64err != nil {\n \t\tt.Logf(\"Skipping 64-bit tests: %v\", test64err)\n \t\treturn"}, {"sha": "1cb8a078c6d14100481314a5c1df2d0597c0fba2", "filename": "libgo/go/testing/testing.go", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Ftesting%2Ftesting.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Ftesting%2Ftesting.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Ftesting.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -108,6 +108,8 @@ var (\n \tcpuListStr     = flag.String(\"test.cpu\", \"\", \"comma-separated list of number of CPUs to use for each test\")\n \tparallel       = flag.Int(\"test.parallel\", runtime.GOMAXPROCS(0), \"maximum test parallelism\")\n \n+\thaveExamples bool // are there examples?\n+\n \tcpuList []int\n )\n \n@@ -280,6 +282,7 @@ func Main(matchString func(pat, str string) (bool, error), tests []InternalTest,\n \n \tbefore()\n \tstartAlarm()\n+\thaveExamples = len(examples) > 0\n \ttestOk := RunTests(matchString, tests)\n \texampleOk := RunExamples(matchString, examples)\n \tif !testOk || !exampleOk {\n@@ -304,7 +307,7 @@ func (t *T) report() {\n \n func RunTests(matchString func(pat, str string) (bool, error), tests []InternalTest) (ok bool) {\n \tok = true\n-\tif len(tests) == 0 {\n+\tif len(tests) == 0 && !haveExamples {\n \t\tfmt.Fprintln(os.Stderr, \"testing: warning: no tests to run\")\n \t\treturn\n \t}"}, {"sha": "d8a086ceb2548725c90ecd670571386d185d435e", "filename": "libgo/go/time/tick_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Ftime%2Ftick_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Ftime%2Ftick_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Ftick_test.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -22,7 +22,7 @@ func TestTicker(t *testing.T) {\n \tdt := t1.Sub(t0)\n \ttarget := Delta * Count\n \tslop := target * 2 / 10\n-\tif dt < target-slop || dt > target+slop {\n+\tif dt < target-slop || (!testing.Short() && dt > target+slop) {\n \t\tt.Fatalf(\"%d %s ticks took %s, expected [%s,%s]\", Count, Delta, dt, target-slop, target+slop)\n \t}\n \t// Now test that the ticker stopped"}, {"sha": "473bc2a451625c11261ff0c42b41adb90270cbc5", "filename": "libgo/go/time/time.go", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Ftime%2Ftime.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Ftime%2Ftime.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Ftime.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -13,7 +13,8 @@ import \"errors\"\n //\n // Programs using times should typically store and pass them as values,\n // not pointers.  That is, time variables and struct fields should be of\n-// type time.Time, not *time.Time.\n+// type time.Time, not *time.Time.  A Time value can be used by\n+// multiple goroutines simultaneously.\n //\n // Time instants can be compared using the Before, After, and Equal methods.\n // The Sub method subtracts two instants, producing a Duration.\n@@ -755,13 +756,13 @@ func (t Time) Zone() (name string, offset int) {\n \treturn\n }\n \n-// Unix returns the Unix time, the number of seconds elapsed\n+// Unix returns t as a Unix time, the number of seconds elapsed\n // since January 1, 1970 UTC.\n func (t Time) Unix() int64 {\n \treturn t.sec + internalToUnix\n }\n \n-// UnixNano returns the Unix time, the number of nanoseconds elapsed\n+// UnixNano returns t as a Unix time, the number of nanoseconds elapsed\n // since January 1, 1970 UTC.\n func (t Time) UnixNano() int64 {\n \treturn (t.sec+internalToUnix)*1e9 + int64(t.nsec)"}, {"sha": "306247e48f1c0945399f6e6575ef3222c945c8ca", "filename": "libgo/go/unicode/utf16/export_test.go", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Funicode%2Futf16%2Fexport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Funicode%2Futf16%2Fexport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Funicode%2Futf16%2Fexport_test.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2012 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package utf16\n+\n+// Extra names for constants so we can validate them during testing.\n+const (\n+\tMaxRune         = maxRune\n+\tReplacementChar = replacementChar\n+)"}, {"sha": "903e4012aa4ab4cb592013f2d7cbc5b02c234f7a", "filename": "libgo/go/unicode/utf16/utf16.go", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Funicode%2Futf16%2Futf16.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Funicode%2Futf16%2Futf16.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Funicode%2Futf16%2Futf16.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -5,7 +5,14 @@\n // Package utf16 implements encoding and decoding of UTF-16 sequences.\n package utf16\n \n-import \"unicode\"\n+// The conditions replacementChar==unicode.ReplacementChar and\n+// maxRune==unicode.MaxRune are verified in the tests.\n+// Defining them locally avoids this package depending on package unicode.\n+\n+const (\n+\treplacementChar = '\\uFFFD'     // Unicode replacement character\n+\tmaxRune         = '\\U0010FFFF' // Maximum valid Unicode code point.\n+)\n \n const (\n \t// 0xd800-0xdc00 encodes the high 10 bits of a pair.\n@@ -31,15 +38,15 @@ func DecodeRune(r1, r2 rune) rune {\n \tif surr1 <= r1 && r1 < surr2 && surr2 <= r2 && r2 < surr3 {\n \t\treturn (rune(r1)-surr1)<<10 | (rune(r2) - surr2) + 0x10000\n \t}\n-\treturn unicode.ReplacementChar\n+\treturn replacementChar\n }\n \n // EncodeRune returns the UTF-16 surrogate pair r1, r2 for the given rune.\n // If the rune is not a valid Unicode code point or does not need encoding,\n // EncodeRune returns U+FFFD, U+FFFD.\n func EncodeRune(r rune) (r1, r2 rune) {\n-\tif r < surrSelf || r > unicode.MaxRune || IsSurrogate(r) {\n-\t\treturn unicode.ReplacementChar, unicode.ReplacementChar\n+\tif r < surrSelf || r > maxRune || IsSurrogate(r) {\n+\t\treturn replacementChar, replacementChar\n \t}\n \tr -= surrSelf\n \treturn surr1 + (r>>10)&0x3ff, surr2 + r&0x3ff\n@@ -58,8 +65,8 @@ func Encode(s []rune) []uint16 {\n \tn = 0\n \tfor _, v := range s {\n \t\tswitch {\n-\t\tcase v < 0, surr1 <= v && v < surr3, v > unicode.MaxRune:\n-\t\t\tv = unicode.ReplacementChar\n+\t\tcase v < 0, surr1 <= v && v < surr3, v > maxRune:\n+\t\t\tv = replacementChar\n \t\t\tfallthrough\n \t\tcase v < surrSelf:\n \t\t\ta[n] = uint16(v)\n@@ -89,7 +96,7 @@ func Decode(s []uint16) []rune {\n \t\t\tn++\n \t\tcase surr1 <= r && r < surr3:\n \t\t\t// invalid surrogate sequence\n-\t\t\ta[n] = unicode.ReplacementChar\n+\t\t\ta[n] = replacementChar\n \t\t\tn++\n \t\tdefault:\n \t\t\t// normal rune"}, {"sha": "ee16a303df3159c4a99dc4b0db1920c756fe88fa", "filename": "libgo/go/unicode/utf16/utf16_test.go", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Funicode%2Futf16%2Futf16_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Funicode%2Futf16%2Futf16_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Funicode%2Futf16%2Futf16_test.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -11,6 +11,16 @@ import (\n \t. \"unicode/utf16\"\n )\n \n+// Validate the constants redefined from unicode.\n+func TestConstants(t *testing.T) {\n+\tif MaxRune != unicode.MaxRune {\n+\t\tt.Errorf(\"utf16.maxRune is wrong: %x should be %x\", MaxRune, unicode.MaxRune)\n+\t}\n+\tif ReplacementChar != unicode.ReplacementChar {\n+\t\tt.Errorf(\"utf16.replacementChar is wrong: %x should be %x\", ReplacementChar, unicode.ReplacementChar)\n+\t}\n+}\n+\n type encodeTest struct {\n \tin  []rune\n \tout []uint16"}, {"sha": "57ea19e96d4e0b2f9b7b9c112aae6d4efa3bab77", "filename": "libgo/go/unicode/utf8/utf8.go", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Funicode%2Futf8%2Futf8.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Funicode%2Futf8%2Futf8.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Funicode%2Futf8%2Futf8.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -6,13 +6,16 @@\n // UTF-8. It includes functions to translate between runes and UTF-8 byte sequences.\n package utf8\n \n-import \"unicode\" // only needed for a couple of constants\n+// The conditions RuneError==unicode.ReplacementChar and\n+// MaxRune==unicode.MaxRune are verified in the tests.\n+// Defining them locally avoids this package depending on package unicode.\n \n // Numbers fundamental to the encoding.\n const (\n-\tRuneError = unicode.ReplacementChar // the \"error\" Rune or \"replacement character\".\n-\tRuneSelf  = 0x80                    // characters below Runeself are represented as themselves in a single byte.\n-\tUTFMax    = 4                       // maximum number of bytes of a UTF-8 encoded Unicode character.\n+\tRuneError = '\\uFFFD'     // the \"error\" Rune or \"Unicode replacement character\"\n+\tRuneSelf  = 0x80         // characters below Runeself are represented as themselves in a single byte.\n+\tMaxRune   = '\\U0010FFFF' // Maximum valid Unicode code point.\n+\tUTFMax    = 4            // maximum number of bytes of a UTF-8 encoded Unicode character.\n )\n \n const (\n@@ -309,7 +312,7 @@ func EncodeRune(p []byte, r rune) int {\n \t\treturn 2\n \t}\n \n-\tif uint32(r) > unicode.MaxRune {\n+\tif uint32(r) > MaxRune {\n \t\tr = RuneError\n \t}\n "}, {"sha": "4f73c8fb81a2f71e211ffee7f66ab1950cf9a802", "filename": "libgo/go/unicode/utf8/utf8_test.go", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Funicode%2Futf8%2Futf8_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fgo%2Funicode%2Futf8%2Futf8_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Funicode%2Futf8%2Futf8_test.go?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -7,9 +7,30 @@ package utf8_test\n import (\n \t\"bytes\"\n \t\"testing\"\n+\t\"unicode\"\n \t. \"unicode/utf8\"\n )\n \n+// Validate the constants redefined from unicode.\n+func init() {\n+\tif MaxRune != unicode.MaxRune {\n+\t\tpanic(\"utf8.MaxRune is wrong\")\n+\t}\n+\tif RuneError != unicode.ReplacementChar {\n+\t\tpanic(\"utf8.RuneError is wrong\")\n+\t}\n+}\n+\n+// Validate the constants redefined from unicode.\n+func TestConstants(t *testing.T) {\n+\tif MaxRune != unicode.MaxRune {\n+\t\tt.Errorf(\"utf8.MaxRune is wrong: %x should be %x\", MaxRune, unicode.MaxRune)\n+\t}\n+\tif RuneError != unicode.ReplacementChar {\n+\t\tt.Errorf(\"utf8.RuneError is wrong: %x should be %x\", RuneError, unicode.ReplacementChar)\n+\t}\n+}\n+\n type Utf8Map struct {\n \tr   rune\n \tstr string"}, {"sha": "97cfabe040a26d4b7bf510632bc1b185d55ff712", "filename": "libgo/runtime/malloc.goc", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fruntime%2Fmalloc.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fruntime%2Fmalloc.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmalloc.goc?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -390,6 +390,23 @@ runtime_MHeap_SysAlloc(MHeap *h, uintptr n)\n {\n \tbyte *p;\n \n+\n+\tif(n > (uintptr)(h->arena_end - h->arena_used)) {\n+\t\t// We are in 32-bit mode, maybe we didn't use all possible address space yet.\n+\t\t// Reserve some more space.\n+\t\tbyte *new_end;\n+\t\tuintptr needed;\n+\n+\t\tneeded = (uintptr)h->arena_used + n - (uintptr)h->arena_end;\n+\t\t// Round wanted arena size to a multiple of 256MB.\n+\t\tneeded = (needed + (256<<20) - 1) & ~((256<<20)-1);\n+\t\tnew_end = h->arena_end + needed;\n+\t\tif(new_end <= h->arena_start + MaxArena32) {\n+\t\t\tp = runtime_SysReserve(h->arena_end, new_end - h->arena_end);\n+\t\t\tif(p == h->arena_end)\n+\t\t\t\th->arena_end = new_end;\n+\t\t}\n+\t}\n \tif(n <= (uintptr)(h->arena_end - h->arena_used)) {\n \t\t// Keep taking from our reservation.\n \t\tp = h->arena_used;\n@@ -411,7 +428,8 @@ runtime_MHeap_SysAlloc(MHeap *h, uintptr n)\n \t\treturn nil;\n \n \tif(p < h->arena_start || (uintptr)(p+n - h->arena_start) >= MaxArena32) {\n-\t\truntime_printf(\"runtime: memory allocated by OS not in usable range\\n\");\n+\t\truntime_printf(\"runtime: memory allocated by OS (%p) not in usable range [%p,%p)\\n\",\n+\t\t\tp, h->arena_start, h->arena_start+MaxArena32);\n \t\truntime_SysFree(p, n);\n \t\treturn nil;\n \t}"}, {"sha": "049f77eada2dd1111f4a4a0ce47fb3410cd9d6b4", "filename": "libgo/runtime/proc.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fruntime%2Fproc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fruntime%2Fproc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fproc.c?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -406,7 +406,9 @@ runtime_schedinit(void)\n \t\t\tn = maxgomaxprocs;\n \t\truntime_gomaxprocs = n;\n \t}\n-\tsetmcpumax(runtime_gomaxprocs);\n+\t// wait for the main goroutine to start before taking\n+\t// GOMAXPROCS into account.\n+\tsetmcpumax(1);\n \truntime_singleproc = runtime_gomaxprocs == 1;\n \n \tcanaddmcpu();\t// mcpu++ to account for bootstrap m\n@@ -432,6 +434,8 @@ runtime_main(void)\n \t// by calling runtime.LockOSThread during initialization\n \t// to preserve the lock.\n \truntime_LockOSThread();\n+\t// From now on, newgoroutines may use non-main threads.\n+\tsetmcpumax(runtime_gomaxprocs);\n \truntime_sched.init = true;\n \tscvg = __go_go(runtime_MHeap_Scavenger, nil);\n \tmain_init();"}, {"sha": "a81c210a2b84409d7527e8fdec7e1c8b927a6166", "filename": "libgo/runtime/runtime.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fruntime%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456fba2651cfb0cb67e44b8354668a0b3f5f5182/libgo%2Fruntime%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.h?ref=456fba2651cfb0cb67e44b8354668a0b3f5f5182", "patch": "@@ -416,7 +416,6 @@ void\truntime_usleep(uint32);\n /*\n  * runtime c-called (but written in Go)\n  */\n-void\truntime_newError(String, Eface*);\n void\truntime_printany(Eface)\n      __asm__(\"libgo_runtime.runtime.Printany\");\n void\truntime_newTypeAssertionError(const String*, const String*, const String*, const String*, Eface*)\n@@ -429,7 +428,6 @@ void\truntime_newErrorString(String, Eface*)\n  */\n void\truntime_semacquire(uint32 volatile *);\n void\truntime_semrelease(uint32 volatile *);\n-String\truntime_signame(int32 sig);\n int32\truntime_gomaxprocsfunc(int32 n);\n void\truntime_procyield(uint32);\n void\truntime_osyield(void);"}]}