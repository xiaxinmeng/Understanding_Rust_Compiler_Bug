{"sha": "1a1035e41b21a28386d0a85e108d582db4ee9a6a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWExMDM1ZTQxYjIxYTI4Mzg2ZDBhODVlMTA4ZDU4MmRiNGVlOWE2YQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-12-08T11:47:21Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-12-08T11:47:21Z"}, "message": "lib-xref.adb (Generate_Reference): Handle properly a reference to an entry formal...\n\n\t* lib-xref.adb (Generate_Reference): Handle properly a reference to an\n\tentry formal, when an accept statement has a pragma Unreferenced for it.\n\n\t* sem_ch9.adb (Analyze_Accept_Statement): Reset the Is_Referenced flag\n\tand the Has_Pragma_Unreferenced flag for each formal before analyzing\n\tthe body, to ensure that warnings are properly emitted for each accept\n\tstatement of a given task entry.\n\nFrom-SVN: r91888", "tree": {"sha": "2dce85e50d1c540821c9ea5d07628a8f8eaca246", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2dce85e50d1c540821c9ea5d07628a8f8eaca246"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a1035e41b21a28386d0a85e108d582db4ee9a6a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a1035e41b21a28386d0a85e108d582db4ee9a6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a1035e41b21a28386d0a85e108d582db4ee9a6a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a1035e41b21a28386d0a85e108d582db4ee9a6a/comments", "author": null, "committer": null, "parents": [{"sha": "4722c5d693d886d22da0a52e8a8133e0e33bdd30", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4722c5d693d886d22da0a52e8a8133e0e33bdd30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4722c5d693d886d22da0a52e8a8133e0e33bdd30"}], "stats": {"total": 68, "additions": 45, "deletions": 23}, "files": [{"sha": "b446b99f333ac1753f2ab74e4dd0376de768137a", "filename": "gcc/ada/lib-xref.adb", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a1035e41b21a28386d0a85e108d582db4ee9a6a/gcc%2Fada%2Flib-xref.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a1035e41b21a28386d0a85e108d582db4ee9a6a/gcc%2Fada%2Flib-xref.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref.adb?ref=1a1035e41b21a28386d0a85e108d582db4ee9a6a", "patch": "@@ -33,6 +33,7 @@ with Namet;    use Namet;\n with Nlists;   use Nlists;\n with Opt;      use Opt;\n with Sem_Prag; use Sem_Prag;\n+with Sem_Util; use Sem_Util;\n with Sinfo;    use Sinfo;\n with Sinput;   use Sinput;\n with Snames;   use Snames;\n@@ -377,14 +378,29 @@ package body Lib.Xref is\n             then\n                null;\n \n-            --  For now, ignore case of parameter to entry, since we don't deal\n-            --  correctly with the case of multiple accepts for the same entry.\n-            --  To deal with this we would have to put the flag on the body\n-            --  entity, but that's not easy, since everyone references the spec\n-            --  entity. To be looked at later to improve this case ???\n+            --  For entry formals, we want to place the warning on the\n+            --  corresponding entity in the accept statement. The current\n+            --  scope is the body of the accept, so we find the formal\n+            --  whose name matches that of the entry formal (there is no\n+            --  link between the two entities, and the one in the accept\n+            --  statement is only used for conformance checking).\n \n             elsif Ekind (Scope (E)) = E_Entry then\n-               null;\n+               declare\n+                  BE : Entity_Id;\n+\n+               begin\n+                  BE := First_Entity (Current_Scope);\n+                  while Present (BE) loop\n+                     if Chars (BE) = Chars (E) then\n+                        Error_Msg_NE\n+                          (\"?pragma Unreferenced given for&\", N, BE);\n+                        exit;\n+                     end if;\n+\n+                     Next_Entity (BE);\n+                  end loop;\n+               end;\n \n             --  Here we issue the warning, since this is a real reference\n "}, {"sha": "06060ab9ff088f74a0ee63f674ce6938df084658", "filename": "gcc/ada/sem_ch9.adb", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a1035e41b21a28386d0a85e108d582db4ee9a6a/gcc%2Fada%2Fsem_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a1035e41b21a28386d0a85e108d582db4ee9a6a/gcc%2Fada%2Fsem_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch9.adb?ref=1a1035e41b21a28386d0a85e108d582db4ee9a6a", "patch": "@@ -134,7 +134,7 @@ package body Sem_Ch9 is\n       Formals   : constant List_Id   := Parameter_Specifications (N);\n       Index     : constant Node_Id   := Entry_Index (N);\n       Stats     : constant Node_Id   := Handled_Statement_Sequence (N);\n-      Ityp      : Entity_Id;\n+      Accept_Id : Entity_Id;\n       Entry_Nam : Entity_Id;\n       E         : Entity_Id;\n       Kind      : Entity_Kind;\n@@ -233,38 +233,39 @@ package body Sem_Ch9 is\n \n       --  In order to process the parameters, we create a defining\n       --  identifier that can be used as the name of the scope. The\n-      --  name of the accept statement itself is not a defining identifier.\n+      --  name of the accept statement itself is not a defining identifier,\n+      --  and we cannot use its name directly because the task may have\n+      --  any number of accept statements for the same entry.\n \n       if Present (Index) then\n-         Ityp := New_Internal_Entity\n+         Accept_Id := New_Internal_Entity\n            (E_Entry_Family, Current_Scope, Sloc (N), 'E');\n       else\n-         Ityp := New_Internal_Entity\n+         Accept_Id := New_Internal_Entity\n            (E_Entry, Current_Scope, Sloc (N), 'E');\n       end if;\n \n-      Set_Etype          (Ityp, Standard_Void_Type);\n-      Set_Accept_Address (Ityp, New_Elmt_List);\n+      Set_Etype          (Accept_Id, Standard_Void_Type);\n+      Set_Accept_Address (Accept_Id, New_Elmt_List);\n \n       if Present (Formals) then\n-         New_Scope (Ityp);\n+         New_Scope (Accept_Id);\n          Process_Formals (Formals, N);\n-         Create_Extra_Formals (Ityp);\n+         Create_Extra_Formals (Accept_Id);\n          End_Scope;\n       end if;\n \n       --  We set the default expressions processed flag because we don't\n       --  need default expression functions. This is really more like a\n       --  body entity than a spec entity anyway.\n \n-      Set_Default_Expressions_Processed (Ityp);\n+      Set_Default_Expressions_Processed (Accept_Id);\n \n       E := First_Entity (Etype (Task_Nam));\n-\n       while Present (E) loop\n          if Chars (E) = Chars (Nam)\n-           and then (Ekind (E) = Ekind (Ityp))\n-           and then Type_Conformant (Ityp, E)\n+           and then (Ekind (E) = Ekind (Accept_Id))\n+           and then Type_Conformant (Accept_Id, E)\n          then\n             Entry_Nam := E;\n             exit;\n@@ -306,8 +307,8 @@ package body Sem_Ch9 is\n          end;\n       end if;\n \n-      Set_Convention (Ityp, Convention (Entry_Nam));\n-      Check_Fully_Conformant (Ityp, Entry_Nam, N);\n+      Set_Convention (Accept_Id, Convention (Entry_Nam));\n+      Check_Fully_Conformant (Accept_Id, Entry_Nam, N);\n \n       for J in reverse 0 .. Scope_Stack.Last loop\n          exit when Task_Nam = Scope_Stack.Table (J).Entity;\n@@ -391,13 +392,18 @@ package body Sem_Ch9 is\n \n       --  Set Never_Set_In_Source and clear Is_True_Constant/Current_Value\n       --  fields on all entry formals (this loop ignores all other entities).\n+      --  Reset Set_Referenced and Has_Pragma_Unreferenced as well, so that\n+      --  we can post accurate warnings on each accept statement for the same\n+      --  entry.\n \n       E := First_Entity (Entry_Nam);\n       while Present (E) loop\n          if Is_Formal (E) then\n-            Set_Never_Set_In_Source (E, True);\n-            Set_Is_True_Constant    (E, False);\n-            Set_Current_Value       (E, Empty);\n+            Set_Never_Set_In_Source     (E, True);\n+            Set_Is_True_Constant        (E, False);\n+            Set_Current_Value           (E, Empty);\n+            Set_Referenced              (E, False);\n+            Set_Has_Pragma_Unreferenced (E, False);\n          end if;\n \n          Next_Entity (E);"}]}