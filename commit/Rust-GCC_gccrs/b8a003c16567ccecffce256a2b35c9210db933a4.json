{"sha": "b8a003c16567ccecffce256a2b35c9210db933a4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjhhMDAzYzE2NTY3Y2NlY2ZmY2UyNTZhMmIzNWM5MjEwZGI5MzNhNA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2018-12-06T23:28:04Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2018-12-06T23:28:04Z"}, "message": "re PR tree-optimization/88367 (-fno-delete-null-pointer-checks doesn't work properly)\n\n\tPR c/88367\n\t* tree-vrp.c (extract_range_from_binary_expr): For POINTER_PLUS_EXPR\n\twith -fno-delete-null-pointer-checks, set_nonnull only if the pointer\n\tis non-NULL and offset is known to have most significant bit clear.\n\t* vr-values.c (vr_values::vrp_stmt_computes_nonzero): For ADDR_EXPR\n\tof MEM_EXPR, return true if the MEM_EXPR has non-zero offset with\n\tmost significant bit clear.  If offset does have most significant bit\n\tset and -fno-delete-null-pointer-checks, don't return true even if\n\tthe base pointer is non-NULL.\n\n\t* gcc.dg/tree-ssa/pr88367.c: New test.\n\nFrom-SVN: r266878", "tree": {"sha": "cd2b1d9b89ff3acda5dd2a6f6fa1e668e192e7fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cd2b1d9b89ff3acda5dd2a6f6fa1e668e192e7fe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b8a003c16567ccecffce256a2b35c9210db933a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8a003c16567ccecffce256a2b35c9210db933a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8a003c16567ccecffce256a2b35c9210db933a4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8a003c16567ccecffce256a2b35c9210db933a4/comments", "author": null, "committer": null, "parents": [{"sha": "ff8ba86f447546c57e26bfab2a3437f14d6f2595", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff8ba86f447546c57e26bfab2a3437f14d6f2595", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff8ba86f447546c57e26bfab2a3437f14d6f2595"}], "stats": {"total": 111, "additions": 104, "deletions": 7}, "files": [{"sha": "f2512ba68cb573fd14c681f9b173bbae79b84e25", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8a003c16567ccecffce256a2b35c9210db933a4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8a003c16567ccecffce256a2b35c9210db933a4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b8a003c16567ccecffce256a2b35c9210db933a4", "patch": "@@ -1,4 +1,16 @@\n-2018-12-06  Alexandre Oliva <aoliva@redhat.com>\n+2018-12-07  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c/88367\n+\t* tree-vrp.c (extract_range_from_binary_expr): For POINTER_PLUS_EXPR\n+\twith -fno-delete-null-pointer-checks, set_nonnull only if the pointer\n+\tis non-NULL and offset is known to have most significant bit clear.\n+\t* vr-values.c (vr_values::vrp_stmt_computes_nonzero): For ADDR_EXPR\n+\tof MEM_EXPR, return true if the MEM_EXPR has non-zero offset with\n+\tmost significant bit clear.  If offset does have most significant bit\n+\tset and -fno-delete-null-pointer-checks, don't return true even if\n+\tthe base pointer is non-NULL.\n+\n+2018-12-06  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* cselib.c (cselib_record_sets): Skip strict low part sets\n \twith NULL src_elt."}, {"sha": "e4afdc79fdcd63102bfebe4a66ea68305b46bfd4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8a003c16567ccecffce256a2b35c9210db933a4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8a003c16567ccecffce256a2b35c9210db933a4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b8a003c16567ccecffce256a2b35c9210db933a4", "patch": "@@ -1,5 +1,8 @@\n 2018-12-07  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR c/88367\n+\t* gcc.dg/tree-ssa/pr88367.c: New test.\n+\n \tPR c++/87506\n \t* g++.dg/cpp0x/constexpr-87506.C: New test.\n "}, {"sha": "ff1c424df4215d56cdbca14ca5b77bd8eeff8ef4", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr88367.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8a003c16567ccecffce256a2b35c9210db933a4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr88367.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8a003c16567ccecffce256a2b35c9210db933a4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr88367.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr88367.c?ref=b8a003c16567ccecffce256a2b35c9210db933a4", "patch": "@@ -0,0 +1,31 @@\n+/* PR c/88367 */\n+/* { dg-do compile } */\n+/* { dg-options \"-fno-delete-null-pointer-checks -O2 -fdump-tree-optimized -fno-wrapv-pointer\" } */\n+/* { dg-final { scan-tree-dump-not \"link_error \\\\(\\\\);\" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"bar \\\\(\\\\);\" 2 \"optimized\" } } */\n+\n+void bar (void);\n+void link_error (void);\n+\n+void\n+foo (char *p)\n+{\n+  if (!p)\n+    return;\n+  p += 3;\n+  if (!p)\n+    link_error ();\n+  p -= 6;\n+  if (!p)\n+    bar ();\n+}\n+\n+void\n+baz (char *p)\n+{\n+  if (!p)\n+    return;\n+  p -= 6;\n+  if (!p)\n+    bar ();\n+}"}, {"sha": "15ac65b7dd435a714c6a3b8418a2c5e9749fa52a", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8a003c16567ccecffce256a2b35c9210db933a4/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8a003c16567ccecffce256a2b35c9210db933a4/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=b8a003c16567ccecffce256a2b35c9210db933a4", "patch": "@@ -1673,9 +1673,26 @@ extract_range_from_binary_expr (value_range_base *vr,\n       else if (code == POINTER_PLUS_EXPR)\n \t{\n \t  /* For pointer types, we are really only interested in asserting\n-\t     whether the expression evaluates to non-NULL.  */\n-\t  if (!range_includes_zero_p (&vr0)\n-\t      || !range_includes_zero_p (&vr1))\n+\t     whether the expression evaluates to non-NULL.\n+\t     With -fno-delete-null-pointer-checks we need to be more\n+\t     conservative.  As some object might reside at address 0,\n+\t     then some offset could be added to it and the same offset\n+\t     subtracted again and the result would be NULL.\n+\t     E.g.\n+\t     static int a[12]; where &a[0] is NULL and\n+\t     ptr = &a[6];\n+\t     ptr -= 6;\n+\t     ptr will be NULL here, even when there is POINTER_PLUS_EXPR\n+\t     where the first range doesn't include zero and the second one\n+\t     doesn't either.  As the second operand is sizetype (unsigned),\n+\t     consider all ranges where the MSB could be set as possible\n+\t     subtractions where the result might be NULL.  */\n+\t  if ((!range_includes_zero_p (&vr0)\n+\t       || !range_includes_zero_p (&vr1))\n+\t      && !TYPE_OVERFLOW_WRAPS (expr_type)\n+\t      && (flag_delete_null_pointer_checks\n+\t\t  || (range_int_cst_p (&vr1)\n+\t\t      && !tree_int_cst_sign_bit (vr1.max ()))))\n \t    vr->set_nonnull (expr_type);\n \t  else if (range_is_null (&vr0) && range_is_null (&vr1))\n \t    vr->set_null (expr_type);"}, {"sha": "075ea8431a6baa7de9c716f068713955b7e04ac6", "filename": "gcc/vr-values.c", "status": "modified", "additions": 37, "deletions": 3, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8a003c16567ccecffce256a2b35c9210db933a4/gcc%2Fvr-values.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8a003c16567ccecffce256a2b35c9210db933a4/gcc%2Fvr-values.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.c?ref=b8a003c16567ccecffce256a2b35c9210db933a4", "patch": "@@ -297,14 +297,48 @@ vr_values::vrp_stmt_computes_nonzero (gimple *stmt)\n       && gimple_assign_rhs_code (stmt) == ADDR_EXPR)\n     {\n       tree expr = gimple_assign_rhs1 (stmt);\n-      tree base = get_base_address (TREE_OPERAND (expr, 0));\n+      poly_int64 bitsize, bitpos;\n+      tree offset;\n+      machine_mode mode;\n+      int unsignedp, reversep, volatilep;\n+      tree base = get_inner_reference (TREE_OPERAND (expr, 0), &bitsize,\n+\t\t\t\t       &bitpos, &offset, &mode, &unsignedp,\n+\t\t\t\t       &reversep, &volatilep);\n \n       if (base != NULL_TREE\n \t  && TREE_CODE (base) == MEM_REF\n \t  && TREE_CODE (TREE_OPERAND (base, 0)) == SSA_NAME)\n \t{\n-\t  value_range *vr = get_value_range (TREE_OPERAND (base, 0));\n-\t  if (!range_includes_zero_p (vr))\n+\t  poly_offset_int off = 0;\n+\t  bool off_cst = false;\n+\t  if (offset == NULL_TREE || TREE_CODE (offset) == INTEGER_CST)\n+\t    {\n+\t      off = mem_ref_offset (base);\n+\t      if (offset)\n+\t\toff += poly_offset_int::from (wi::to_poly_wide (offset),\n+\t\t\t\t\t      SIGNED);\n+\t      off <<= LOG2_BITS_PER_UNIT;\n+\t      off += bitpos;\n+\t      off_cst = true;\n+\t    }\n+\t  /* If &X->a is equal to X and X is ~[0, 0], the result is too.\n+\t     For -fdelete-null-pointer-checks -fno-wrapv-pointer we don't\n+\t     allow going from non-NULL pointer to NULL.  */\n+\t  if ((off_cst && known_eq (off, 0))\n+\t      || (flag_delete_null_pointer_checks\n+\t\t  && !TYPE_OVERFLOW_WRAPS (TREE_TYPE (expr))))\n+\t    {\n+\t      value_range *vr = get_value_range (TREE_OPERAND (base, 0));\n+\t      if (!range_includes_zero_p (vr))\n+\t\treturn true;\n+\t    }\n+\t  /* If MEM_REF has a \"positive\" offset, consider it non-NULL\n+\t     always, for -fdelete-null-pointer-checks also \"negative\"\n+\t     ones.  Punt for unknown offsets (e.g. variable ones).  */\n+\t  if (!TYPE_OVERFLOW_WRAPS (TREE_TYPE (expr))\n+\t      && off_cst\n+\t      && known_ne (off, 0)\n+\t      && (flag_delete_null_pointer_checks || known_gt (off, 0)))\n \t    return true;\n \t}\n     }"}]}