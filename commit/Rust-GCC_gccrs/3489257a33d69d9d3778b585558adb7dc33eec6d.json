{"sha": "3489257a33d69d9d3778b585558adb7dc33eec6d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzQ4OTI1N2EzM2Q2OWQ5ZDM3NzhiNTg1NTU4YWRiN2RjMzNlZWM2ZA==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2021-05-10T13:51:12Z"}, "committer": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2021-05-14T08:51:02Z"}, "message": "Port gnat-style to Sphinx.\n\ngcc/ada/ChangeLog:\n\n\t* doc/Makefile: Add gnat-style target.\n\t* doc/share/conf.py: Likewise.\n\t* doc/gnat-style.rst: New file.", "tree": {"sha": "dae30956c8dd3ad74325de5c222e82d3674ee0ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dae30956c8dd3ad74325de5c222e82d3674ee0ae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3489257a33d69d9d3778b585558adb7dc33eec6d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3489257a33d69d9d3778b585558adb7dc33eec6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3489257a33d69d9d3778b585558adb7dc33eec6d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3489257a33d69d9d3778b585558adb7dc33eec6d/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ae3e0b8bc204d1f6ce858c2637e1e72b636af3a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae3e0b8bc204d1f6ce858c2637e1e72b636af3a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae3e0b8bc204d1f6ce858c2637e1e72b636af3a2"}], "stats": {"total": 697, "additions": 695, "deletions": 2}, "files": [{"sha": "4adfd368cc8d090026ec1f072452850c9db9c879", "filename": "gcc/ada/doc/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3489257a33d69d9d3778b585558adb7dc33eec6d/gcc%2Fada%2Fdoc%2FMakefile", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3489257a33d69d9d3778b585558adb7dc33eec6d/gcc%2Fada%2Fdoc%2FMakefile", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2FMakefile?ref=3489257a33d69d9d3778b585558adb7dc33eec6d", "patch": "@@ -14,7 +14,7 @@ ALLSPHINXOPTS   = $(PAPEROPT_$(PAPER)) $(SPHINXOPTS) \\\n \t\t  -c $(SOURCEDIR)/share \\\n \t\t  -d $(BUILDDIR)/$*/doctrees \\\n \t\t  $(SOURCEDIR)\n-DOC_LIST=gnat_rm gnat_ugn\n+DOC_LIST=gnat_rm gnat_ugn gnat-style\n FMT_LIST=html pdf txt info\n \n .PHONY: help clean"}, {"sha": "527e7ba2a66d7b2df71eb6d6ca2a88cb784578ad", "filename": "gcc/ada/doc/gnat-style.rst", "status": "added", "additions": 691, "deletions": 0, "changes": 691, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3489257a33d69d9d3778b585558adb7dc33eec6d/gcc%2Fada%2Fdoc%2Fgnat-style.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3489257a33d69d9d3778b585558adb7dc33eec6d/gcc%2Fada%2Fdoc%2Fgnat-style.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat-style.rst?ref=3489257a33d69d9d3778b585558adb7dc33eec6d", "patch": "@@ -0,0 +1,691 @@\n+GNAT Coding Style: A Guide for GNAT Developers\n+==============================================\n+\n+General\n+-------\n+\n+Most of GNAT is written in Ada using a consistent style to ensure\n+readability of the code.  This document has been written to help\n+maintain this consistent style, while having a large group of developers\n+work on the compiler.\n+\n+For the coding style in the C parts of the compiler and run time,\n+see the GNU Coding Guidelines.\n+\n+This document is structured after the Ada Reference Manual.\n+Those familiar with that document should be able to quickly\n+lookup style rules for particular constructs.\n+\n+Lexical Elements\n+----------------\n+\n+Character Set and Separators\n+****************************\n+\n+.. index:: Character set\n+.. index:: ASCII\n+.. index:: Separators\n+.. index:: End-of-line\n+.. index:: Line length\n+.. index:: Indentation\n+\n+* The character set used should be plain 7-bit ASCII.\n+  The only separators allowed are space and the end-of-line sequence.\n+  No other control character or format effector (such as ``HT``,\n+  ``VT``, ``FF`` )\n+  should be used.\n+  The normal end-of-line sequence is used, which may be\n+  ``LF``, ``CR/LF`` or ``CR``,\n+  depending on the host system.  An optional ``SUB``\n+  ( ``16#1A#`` ) may be present as the\n+  last character in the file on hosts using that character as file terminator.\n+\n+* Files that are checked in or distributed should be in host format.\n+\n+* A line should never be longer than 79 characters, not counting the line\n+  separator.\n+\n+* Lines must not have trailing blanks.\n+\n+* Indentation is 3 characters per level for ``if`` statements, loops, and\n+  ``case`` statements.\n+  For exact information on required spacing between lexical\n+  elements, see file style.adb.\n+\n+  .. index:: style.adb file\n+\n+Identifiers\n+***********\n+\n+* Identifiers will start with an upper case letter, and each letter following\n+  an underscore will be upper case.\n+\n+  .. index:: Casing (for identifiers)\n+\n+  Short acronyms may be all upper case.\n+  All other letters are lower case.\n+  An exception is for identifiers matching a foreign language.  In particular,\n+  we use all lower case where appropriate for C.\n+\n+* Use underscores to separate words in an identifier.\n+\n+  .. index:: Underscores\n+\n+* Try to limit your use of abbreviations in identifiers.\n+  It is ok to make a few abbreviations, explain what they mean, and then\n+  use them frequently, but don't use lots of obscure abbreviations.  An\n+  example is the ``ALI`` word which stands for Ada Library\n+  Information and is by convention always written in upper-case when\n+  used in entity names.\n+\n+  .. code-block:: ada\n+\n+           procedure Find_ALI_Files;\n+\n+* Don't use the variable name ``I``, use ``J`` instead; ``I`` is too\n+  easily confused with ``1`` in some fonts.  Similarly don't use the\n+  variable ``O``, which is too easily mistaken for the number ``0``.\n+\n+Numeric Literals\n+****************\n+\n+* Numeric literals should include underscores where helpful for\n+  readability.\n+\n+  .. index:: Underscores\n+\n+  .. code-block:: ada\n+\n+          1_000_000\n+          16#8000_0000#\n+          3.14159_26535_89793_23846\n+\n+Reserved Words\n+**************\n+\n+* Reserved words use all lower case.\n+\n+  .. index:: Casing (for reserved words)\n+\n+  .. code-block:: ada\n+\n+           return else\n+\n+* The words ``Access``, ``Delta`` and ``Digits`` are\n+  capitalized when used as attribute_designator.\n+\n+Comments\n+********\n+\n+* A comment starts with ``--`` followed by two spaces.\n+  The only exception to this rule (i.e. one space is tolerated) is when the\n+  comment ends with a single space followed by ``--``.\n+  It is also acceptable to have only one space between ``--`` and the start\n+  of the comment when the comment is at the end of a line,\n+  after some Ada code.\n+\n+* Every sentence in a comment should start with an upper-case letter (including\n+  the first letter of the comment).\n+\n+  .. index:: Casing (in comments)\n+\n+* When declarations are commented with 'hanging' comments, i.e.\n+  comments after the declaration, there is no blank line before the\n+  comment, and if it is absolutely necessary to have blank lines within\n+  the comments, e.g. to make paragraph separations within a single comment,\n+  these blank lines *do* have a ``--`` (unlike the\n+  normal rule, which is to use entirely blank lines for separating\n+  comment paragraphs).  The comment starts at same level of indentation\n+  as code it is commenting.\n+\n+  .. index:: Blank lines (in comments)\n+  .. index:: Indentation\n+\n+  .. code-block:: ada\n+\n+           z : Integer;\n+           --  Integer value for storing value of z\n+           --\n+           --  The previous line was a blank line.\n+\n+* Comments that are dubious or incomplete, or that comment on possibly\n+  wrong or incomplete code, should be preceded or followed by ``???``.\n+\n+* Comments in a subprogram body must generally be surrounded by blank lines.\n+  An exception is a comment that follows a line containing a single keyword\n+  ( ``begin``, ``else``, ``loop`` ):\n+\n+  .. code-block:: ada\n+\n+           begin\n+              --  Comment for the next statement\n+\n+              A := 5;\n+\n+              --  Comment for the B statement\n+\n+              B := 6;\n+           end;\n+\n+* In sequences of statements, comments at the end of the lines should be\n+  aligned.\n+\n+  .. index:: Alignment (in comments)\n+\n+  .. code-block:: ada\n+\n+            My_Identifier := 5;      --  First comment\n+            Other_Id := 6;           --  Second comment\n+\n+* Short comments that fit on a single line are *not* ended with a\n+  period.  Comments taking more than a line are punctuated in the normal\n+  manner.\n+\n+* Comments should focus on *why* instead of *what*.\n+  Descriptions of what subprograms do go with the specification.\n+\n+* Comments describing a subprogram spec should specifically mention the\n+  formal argument names.  General rule: write a comment that does not\n+  depend on the names of things.  The names are supplementary, not\n+  sufficient, as comments.\n+\n+* *Do not* put two spaces after periods in comments.\n+\n+Declarations and Types\n+----------------------\n+\n+* In entity declarations, colons must be surrounded by spaces.  Colons\n+  should be aligned.\n+\n+  .. index:: Alignment (in declarations)\n+\n+  .. code-block:: ada\n+\n+            Entity1   : Integer;\n+            My_Entity : Integer;\n+\n+* Declarations should be grouped in a logical order.\n+  Related groups of declarations may be preceded by a header comment.\n+\n+* All local subprograms in a subprogram or package body should be declared\n+  before the first local subprogram body.\n+\n+* Do not declare local entities that hide global entities.\n+\n+  .. index:: Hiding of outer entities\n+\n+* Do not declare multiple variables in one declaration that spans lines.\n+  Start a new declaration on each line, instead.\n+\n+* The defining_identifiers of global declarations serve as\n+  comments of a sort.  So don't choose terse names, but look for names\n+  that give useful information instead.\n+\n+* Local names can be shorter, because they are used only within\n+  one context, where comments explain their purpose.\n+\n+* When starting an initialization or default expression on the line that follows\n+  the declaration line, use 2 characters for indentation.\n+\n+  .. code-block:: ada\n+\n+            Entity1 : Integer :=\n+              Function_Name (Parameters, For_Call);\n+\n+* If an initialization or default expression needs to be continued on subsequent\n+  lines, the continuations should be indented from the start of the expression.\n+\n+  .. code-block:: ada\n+\n+            Entity1 : Integer := Long_Function_Name\n+                                   (parameters for call);\n+\n+Expressions and Names\n+---------------------\n+\n+* Every operator must be surrounded by spaces. An exception is that\n+  this rule does not apply to the exponentiation operator, for which\n+  there are no specific layout rules. The reason for this exception\n+  is that sometimes it makes clearer reading to leave out the spaces\n+  around exponentiation.\n+\n+  .. index:: Operators\n+\n+  .. code-block:: ada\n+\n+           E := A * B**2 + 3 * (C - D);\n+\n+* Use parentheses where they clarify the intended association of operands\n+  with operators:\n+\n+  .. index:: Parenthesization of expressions\n+\n+  .. code-block:: ada\n+\n+           (A / B) * C\n+\n+Statements\n+----------\n+\n+Simple and Compound Statements\n+******************************\n+\n+* Use only one statement or label per line.\n+\n+* A longer sequence_of_statements may be divided in logical\n+  groups or separated from surrounding code using a blank line.\n+\n+\n+If Statements\n+*************\n+\n+* When the ``if``, ``elsif`` or ``else`` keywords fit on the\n+  same line with the condition and the ``then`` keyword, then the\n+  statement is formatted as follows:\n+\n+  .. index:: Alignment (in an if statement)\n+\n+  .. code-block:: ada\n+\n+            if condition then\n+               ...\n+            elsif condition then\n+               ...\n+            else\n+               ...\n+            end if;\n+\n+  When the above layout is not possible, ``then`` should be aligned\n+  with ``if``, and conditions should preferably be split before an\n+  ``and`` or ``or`` keyword a follows:\n+\n+  .. code-block:: ada\n+\n+            if long_condition_that_has_to_be_split\n+              and then continued_on_the_next_line\n+            then\n+               ...\n+            end if;\n+\n+  The ``elsif``, ``else`` and ``end if`` always line up with\n+  the ``if`` keyword.  The preferred location for splitting the line\n+  is before ``and`` or ``or``.  The continuation of a condition is\n+  indented with two spaces or as many as needed to make nesting clear.\n+  As an exception, if conditions are closely related either of the\n+  following is allowed:\n+\n+  .. code-block:: ada\n+\n+         if x = lakdsjfhlkashfdlkflkdsalkhfsalkdhflkjdsahf\n+              or else\n+            x = asldkjhalkdsjfhhfd\n+              or else\n+            x = asdfadsfadsf\n+         then\n+           ...\n+         end if;\n+\n+         if x = lakdsjfhlkashfdlkflkdsalkhfsalkdhflkjdsahf or else\n+            x = asldkjhalkdsjfhhfd                         or else\n+            x = asdfadsfadsf\n+         then\n+           ...\n+         end if;\n+\n+* Conditions should use short-circuit forms ( ``and then``,\n+  ``or else`` ), except when the operands are boolean variables\n+  or boolean constants.\n+\n+  .. index:: Short-circuit forms\n+\n+* Complex conditions in ``if`` statements are indented two characters:\n+\n+  .. index:: Indentation (in if statements)\n+\n+  .. code-block:: ada\n+\n+          if this_complex_condition\n+            and then that_other_one\n+            and then one_last_one\n+          then\n+             ...\n+          end if;\n+\n+  There are some cases where complex conditionals can be laid out\n+  in manners that do not follow these rules to preserve better\n+  parallelism between branches, e.g.\n+\n+  .. code-block:: ada\n+\n+          if xyz.abc (gef) = 'c'\n+               or else\n+             xyz.abc (gef) = 'x'\n+          then\n+             ...\n+          end if;\n+\n+* Every ``if`` block is preceded and followed by a blank line, except\n+  where it begins or ends a sequence_of_statements.\n+\n+  .. index:: Blank lines (in an if statement)\n+\n+  .. code-block:: ada\n+\n+            A := 5;\n+\n+            if A = 5 then\n+               null;\n+            end if;\n+\n+            A := 6;\n+\n+Case Statements\n+***************\n+\n+* Layout is as below.  For long ``case`` statements, the extra indentation\n+  can be saved by aligning the ``when`` clauses with the opening ``case``.\n+\n+  .. code-block:: ada\n+\n+           case expression is\n+              when condition =>\n+                 ...\n+              when condition =>\n+                 ...\n+           end case;\n+\n+Loop Statements\n+***************\n+\n+* When possible, have ``for`` or ``while`` on one line with the\n+  condition and the ``loop`` keyword.\n+\n+  .. code-block:: ada\n+\n+           for J in S'Range loop\n+              ...\n+           end loop;\n+\n+  If the condition is too long, split the condition (see 'If\n+  statements' above) and align ``loop`` with the ``for`` or\n+  ``while`` keyword.\n+\n+  .. index:: Alignment (in a loop statement)\n+\n+  .. code-block:: ada\n+\n+          while long_condition_that_has_to_be_split\n+            and then continued_on_the_next_line\n+          loop\n+             ...\n+          end loop;\n+\n+  If the loop_statement has an identifier, it is laid out as follows:\n+\n+  .. code-block:: ada\n+\n+          Outer : while not condition loop\n+             ...\n+          end Outer;\n+\n+Block Statements\n+****************\n+\n+* The ``declare`` (optional), ``begin`` and ``end`` words\n+  are aligned, except when the block_statement is named.  There\n+  is a blank line before the ``begin`` keyword:\n+\n+  .. index:: Alignment (in a block statement)\n+\n+  .. code-block:: ada\n+\n+          Some_Block : declare\n+             ...\n+\n+          begin\n+             ...\n+          end Some_Block;\n+\n+Subprograms\n+-----------\n+\n+Subprogram Declarations\n+***********************\n+\n+* Do not write the ``in`` for parameters.\n+\n+  .. code-block:: ada\n+\n+          function Length (S : String) return Integer;\n+\n+* When the declaration line for a procedure or a function is too long to fit\n+  the entire declaration (including the keyword procedure or function) on a\n+  single line, then fold it, putting a single parameter on a line, aligning\n+  the colons, as in:\n+\n+  .. code-block:: ada\n+\n+         procedure Set_Heading\n+           (Source : String;\n+            Count  : Natural;\n+            Pad    : Character := Space;\n+            Fill   : Boolean   := True);\n+\n+  In the case of a function, if the entire spec does not fit on one line, then\n+  the return may appear after the last parameter, as in:\n+\n+  .. code-block:: ada\n+\n+          function Head\n+            (Source : String;\n+             Count  : Natural;\n+             Pad    : Character := Space) return String;\n+\n+  Or it may appear on its own as a separate line. This form is preferred when\n+  putting the return on the same line as the last parameter would result in\n+  an overlong line. The return type may optionally be aligned with the types\n+  of the parameters (usually we do this aligning if it results only in a small\n+  number of extra spaces, and otherwise we don't attempt to align). So two\n+  alternative forms for the above spec are:\n+\n+  .. code-block:: ada\n+\n+          function Head\n+            (Source : String;\n+             Count  : Natural;\n+             Pad    : Character := Space)\n+             return   String;\n+\n+          function Head\n+            (Source : String;\n+             Count  : Natural;\n+             Pad    : Character := Space)\n+             return String;\n+\n+Subprogram Bodies\n+*****************\n+\n+* Function and procedure bodies should usually be sorted alphabetically. Do\n+  not attempt to sort them in some logical order by functionality. For a\n+  sequence of subprogram specs, a general alphabetical sorting is also\n+  usually appropriate, but occasionally it makes sense to group by major\n+  function, with appropriate headers.\n+\n+* All subprograms have a header giving the function name, with the following\n+  format:\n+\n+  .. code-block:: ada\n+\n+          -----------------\n+          -- My_Function --\n+          -----------------\n+\n+          procedure My_Function is\n+          begin\n+            ...\n+          end My_Function;\n+\n+  Note that the name in the header is preceded by a single space,\n+  not two spaces as for other comments. These headers are used on\n+  nested subprograms as well as outer level subprograms. They may\n+  also be used as headers for sections of comments, or collections\n+  of declarations that are related.\n+\n+* Every subprogram body must have a preceding subprogram_declaration,\n+  which includes proper client documentation so that you do not need to\n+  read the subprogram body in order to understand what the subprogram does and\n+  how to call it. All subprograms should be documented, without exceptions.\n+\n+  .. index:: Blank lines (in subprogram bodies)\n+\n+* A sequence of declarations may optionally be separated from the following\n+  begin by a blank line.  Just as we optionally allow blank lines in general\n+  between declarations, this blank line should be present only if it improves\n+  readability. Generally we avoid this blank line if the declarative part is\n+  small (one or two lines) and the body has no blank lines, and we include it\n+  if the declarative part is long or if the body has blank lines.\n+\n+* If the declarations in a subprogram contain at least one nested\n+  subprogram body, then just before the ``begin`` of the enclosing\n+  subprogram, there is a comment line and a blank line:\n+\n+  .. code-block:: ada\n+\n+        --  Start of processing for Enclosing_Subprogram\n+\n+        begin\n+          ...\n+        end Enclosing_Subprogram;\n+\n+* When nested subprograms are present, variables that are referenced by any\n+  nested subprogram should precede the nested subprogram specs. For variables\n+  that are not referenced by nested procedures, the declarations can either also\n+  be before any of the nested subprogram specs (this is the old style, more\n+  generally used). Or then can come just before the begin, with a header. The\n+  following example shows the two possible styles:\n+\n+  .. code-block:: ada\n+\n+        procedure Style1 is\n+           Var_Referenced_In_Nested      : Integer;\n+           Var_Referenced_Only_In_Style1 : Integer;\n+\n+           proc Nested;\n+           --  Comments ...\n+\n+           ------------\n+           -- Nested --\n+           ------------\n+\n+           procedure Nested is\n+           begin\n+              ...\n+           end Nested;\n+\n+        --  Start of processing for Style1\n+\n+        begin\n+           ...\n+        end Style1;\n+\n+        procedure Style2 is\n+           Var_Referenced_In_Nested : Integer;\n+\n+           proc Nested;\n+           --  Comments ...\n+\n+           ------------\n+           -- Nested --\n+           ------------\n+\n+           procedure Nested is\n+           begin\n+              ...\n+           end Nested;\n+\n+           --  Local variables\n+\n+           Var_Referenced_Only_In_Style2 : Integer;\n+\n+        --  Start of processing for Style2\n+\n+        begin\n+           ...\n+        end Style2;\n+\n+  For new code, we generally prefer Style2, but we do not insist on\n+  modifying all legacy occurrences of Style1, which is still much\n+  more common in the sources.\n+\n+Packages and Visibility Rules\n+-----------------------------\n+\n+* All program units and subprograms have their name at the end:\n+\n+  .. code-block:: ada\n+\n+          package P is\n+             ...\n+          end P;\n+\n+* We will use the style of ``use`` -ing ``with`` -ed packages, with\n+  the context clauses looking like:\n+\n+  .. index:: use clauses\n+\n+  .. code-block:: ada\n+\n+          with A; use A;\n+          with B; use B;\n+\n+* Names declared in the visible part of packages should be\n+  unique, to prevent name clashes when the packages are ``use`` d.\n+\n+  .. index:: Name clash avoidance\n+\n+  .. code-block:: ada\n+\n+          package Entity is\n+             type Entity_Kind is ...;\n+             ...\n+          end Entity;\n+\n+* After the file header comment, the context clause and unit specification\n+  should be the first thing in a program_unit.\n+\n+* Preelaborate, Pure and Elaborate_Body pragmas should be added right after the\n+  package name, indented an extra level and using the parameterless form:\n+\n+  .. code-block:: ada\n+\n+          package Preelaborate_Package is\n+             pragma Preelaborate;\n+             ...\n+          end Preelaborate_Package;\n+\n+Program Structure and Compilation Issues\n+----------------------------------------\n+\n+* Every GNAT source file must be compiled with the ``-gnatg``\n+  switch to check the coding style.\n+  (Note that you should look at\n+  style.adb to see the lexical rules enforced by ``-gnatg`` ).\n+\n+  .. index:: -gnatg option (to gcc)\n+  .. index:: style.adb file\n+\n+* Each source file should contain only one compilation unit.\n+\n+* Filenames should be 8 or fewer characters, followed by the ``.adb``\n+  extension for a body or ``.ads`` for a spec.\n+\n+  .. index:: File name length\n+\n+* Unit names should be distinct when 'krunch'ed to 8 characters\n+  (see krunch.ads) and the filenames should match the unit name,\n+  except that they are all lower case.\n+\n+  .. index:: krunch.ads file\n+\n+.. toctree::\n+   share/gnu_free_documentation_license"}, {"sha": "755c3a682f8c3eeeaaada372fa70e97d712ee183", "filename": "gcc/ada/doc/share/conf.py", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3489257a33d69d9d3778b585558adb7dc33eec6d/gcc%2Fada%2Fdoc%2Fshare%2Fconf.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3489257a33d69d9d3778b585558adb7dc33eec6d/gcc%2Fada%2Fdoc%2Fshare%2Fconf.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fshare%2Fconf.py?ref=3489257a33d69d9d3778b585558adb7dc33eec6d", "patch": "@@ -20,7 +20,9 @@\n     'gnat_rm': {\n         'title': 'GNAT Reference Manual'},\n     'gnat_ugn': {\n-        'title': 'GNAT User\\'s Guide for Native Platforms'}}\n+        'title': 'GNAT User\\'s Guide for Native Platforms'},\n+    'gnat-style': {\n+        'title': 'GNAT Coding Style: A Guide for GNAT Developers'}}\n \n # Then retrieve the source directory\n root_source_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))"}]}