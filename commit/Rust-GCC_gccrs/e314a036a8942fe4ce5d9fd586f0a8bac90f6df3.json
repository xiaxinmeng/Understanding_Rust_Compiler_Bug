{"sha": "e314a036a8942fe4ce5d9fd586f0a8bac90f6df3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTMxNGEwMzZhODk0MmZlNGNlNWQ5ZmQ1ODZmMGE4YmFjOTBmNmRmMw==", "commit": {"author": {"name": "Josef Zlomek", "email": "zlomekj@suse.cz", "date": "2004-05-27T04:28:12Z"}, "committer": {"name": "Josef Zlomek", "email": "zlomek@gcc.gnu.org", "date": "2004-05-27T04:28:12Z"}, "message": "re PR middle-end/14084 (Reg allocator incorrectly changes REG_OFFSET)\n\n\tPR middle-end/14084\n\t* emit-rtl.c (gen_rtx_REG_offset): Adjust the offset according\n\tto size of decl.\n\nFrom-SVN: r82313", "tree": {"sha": "495f11c36b83e1b4a4adfe71e9dc03141b117804", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/495f11c36b83e1b4a4adfe71e9dc03141b117804"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e314a036a8942fe4ce5d9fd586f0a8bac90f6df3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e314a036a8942fe4ce5d9fd586f0a8bac90f6df3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e314a036a8942fe4ce5d9fd586f0a8bac90f6df3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e314a036a8942fe4ce5d9fd586f0a8bac90f6df3/comments", "author": null, "committer": null, "parents": [{"sha": "2140214f631a6ec8a4cd9c45e1001a5a40fef5e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2140214f631a6ec8a4cd9c45e1001a5a40fef5e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2140214f631a6ec8a4cd9c45e1001a5a40fef5e7"}], "stats": {"total": 93, "additions": 91, "deletions": 2}, "files": [{"sha": "a13cbdde627d5fd1f122e81720b3c10b8a150d99", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e314a036a8942fe4ce5d9fd586f0a8bac90f6df3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e314a036a8942fe4ce5d9fd586f0a8bac90f6df3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e314a036a8942fe4ce5d9fd586f0a8bac90f6df3", "patch": "@@ -1,3 +1,9 @@\n+2004-05-27  Josef Zlomek  <zlomekj@suse.cz>\n+\n+\tPR middle-end/14084\n+\t* emit-rtl.c (gen_rtx_REG_offset): Adjust the offset according\n+\tto size of decl.\n+\n 2004-05-26  Aldy Hernandez  <aldyh@redhat.com>\n \n \tPR/14924"}, {"sha": "bc23bb7beba4b175d6f4e9b28a122a91acb73c49", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 85, "deletions": 2, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e314a036a8942fe4ce5d9fd586f0a8bac90f6df3/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e314a036a8942fe4ce5d9fd586f0a8bac90f6df3/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=e314a036a8942fe4ce5d9fd586f0a8bac90f6df3", "patch": "@@ -746,13 +746,96 @@ gen_reg_rtx (enum machine_mode mode)\n   return val;\n }\n \n-/* Generate a register with same attributes as REG,\n-   but offsetted by OFFSET.  */\n+/* Generate a register with same attributes as REG, but offsetted by OFFSET.\n+   Do the big endian correction if needed.  */\n \n rtx\n gen_rtx_REG_offset (rtx reg, enum machine_mode mode, unsigned int regno, int offset)\n {\n   rtx new = gen_rtx_REG (mode, regno);\n+  tree decl;\n+  HOST_WIDE_INT var_size;\n+\n+  /* PR middle-end/14084\n+     The problem appears when a variable is stored in a larger register\n+     and later it is used in the original mode or some mode in between\n+     or some part of variable is accessed.\n+\n+     On little endian machines there is no problem because\n+     the REG_OFFSET of the start of the variable is the same when\n+     accessed in any mode (it is 0).\n+\n+     However, this is not true on big endian machines.\n+     The offset of the start of the variable is different when accessed\n+     in different modes.\n+     When we are taking a part of the REG we have to change the OFFSET\n+     from offset WRT size of mode of REG to offset WRT size of variable.\n+\n+     If we would not do the big endian correction the resulting REG_OFFSET\n+     would be larger than the size of the DECL.\n+\n+     Examples of correction, for BYTES_BIG_ENDIAN WORDS_BIG_ENDIAN machine:\n+\n+     REG.mode  MODE  DECL size  old offset  new offset  description\n+     DI        SI    4          4           0           int32 in SImode\n+     DI        SI    1          4           0           char in SImode\n+     DI        QI    1          7           0           char in QImode\n+     DI        QI    4          5           1           1st element in QImode\n+                                                        of char[4]\n+     DI        HI    4          6           2           1st element in HImode\n+                                                        of int16[2]\n+\n+     If the size of DECL is equal or greater than the size of REG\n+     we can't do this correction because the register holds the\n+     whole variable or a part of the variable and thus the REG_OFFSET\n+     is already correct.  */\n+\n+  decl = REG_EXPR (reg);\n+  if ((BYTES_BIG_ENDIAN || WORDS_BIG_ENDIAN)\n+      && decl != NULL\n+      && offset > 0\n+      && GET_MODE_SIZE (GET_MODE (reg)) > GET_MODE_SIZE (mode)\n+      && ((var_size = int_size_in_bytes (TREE_TYPE (decl))) > 0\n+\t  && var_size < GET_MODE_SIZE (GET_MODE (reg))))\n+    {\n+      int offset_le;\n+\n+      /* Convert machine endian to little endian WRT size of mode of REG.  */\n+      if (WORDS_BIG_ENDIAN)\n+\toffset_le = ((GET_MODE_SIZE (GET_MODE (reg)) - 1 - offset)\n+\t\t     / UNITS_PER_WORD) * UNITS_PER_WORD;\n+      else\n+\toffset_le = (offset / UNITS_PER_WORD) * UNITS_PER_WORD;\n+\n+      if (BYTES_BIG_ENDIAN)\n+\toffset_le += ((GET_MODE_SIZE (GET_MODE (reg)) - 1 - offset)\n+\t\t      % UNITS_PER_WORD);\n+      else\n+\toffset_le += offset % UNITS_PER_WORD;\n+\n+      if (offset_le >= var_size)\n+\t{\n+\t  /* MODE is wider than the variable so the new reg will cover\n+\t     the whole variable so the resulting OFFSET should be 0.  */\n+\t  offset = 0;\n+\t}\n+      else\n+\t{\n+\t  /* Convert little endian to machine endian WRT size of variable.  */\n+\t  if (WORDS_BIG_ENDIAN)\n+\t    offset = ((var_size - 1 - offset_le)\n+\t\t      / UNITS_PER_WORD) * UNITS_PER_WORD;\n+\t  else\n+\t    offset = (offset_le / UNITS_PER_WORD) * UNITS_PER_WORD;\n+\n+\t  if (BYTES_BIG_ENDIAN)\n+\t    offset += ((var_size - 1 - offset_le)\n+\t\t       % UNITS_PER_WORD);\n+\t  else\n+\t    offset += offset_le % UNITS_PER_WORD;\n+\t}\n+    }\n+\n   REG_ATTRS (new) = get_reg_attrs (REG_EXPR (reg),\n \t\t\t\t   REG_OFFSET (reg) + offset);\n   return new;"}]}