{"sha": "dbaabd06aaf4a1b0f2a20671c39148a0bd6ccf0e", "node_id": "C_kwDOANBUbNoAKGRiYWFiZDA2YWFmNGExYjBmMmEyMDY3MWMzOTE0OGEwYmQ2Y2NmMGU", "commit": {"author": {"name": "Qing Zhao", "email": "qing.zhao@oracle.com", "date": "2022-03-02T16:48:37Z"}, "committer": {"name": "Qing Zhao", "email": "qing.zhao@oracle.com", "date": "2022-03-02T16:53:00Z"}, "message": "Don't emit switch-unreachable warnings for -ftrivial-auto-var-init (PR102276)\n\nAt the same time, adding -Wtrivial-auto-var-init and update documentation.\n -Wtrivial-auto-var-init and update documentation.\n\nfor the following testing case:\n1 int g(int *);\n2 int f1()\n3 {\n4     switch (0) {\n5         int x;\n6         default:\n7         return g(&x);\n8     }\n9 }\ncompiling with -O -ftrivial-auto-var-init causes spurious warning:\nwarning: statement will never be executed [-Wswitch-unreachable]\n5 |         int x;\n  |             ^\nThis is due to the compiler-generated initialization at the point of\nthe declaration.\n\nWe could avoid the warning  to exclude the following cases:\n\nwhen\nflag_auto_var_init > AUTO_INIT_UNINITIALIZED\nAnd\n1) call to .DEFERRED_INIT\n2) call to __builtin_clear_padding if the 2nd argument is present and non-zero\n3) a gimple assign store right after the .DEFERRED_INIT call that has the LHS\n   as RHS\n\nHowever, we still need to warn users about the incapability of the option\n-ftrivial-auto-var-init by adding a new warning option -Wtrivial-auto-var-init\nto report cases when it cannot initialize the auto variable. At the same\ntime, update documentation for -ftrivial-auto-var-init to connect it with\nthe new warning option -Wtrivial-auto-var-init,  and add documentation\nfor -Wtrivial-auto-var-init.\n\ngcc/ChangeLog:\n\n\tPR middle-end/102276\n\t* common.opt (-Wtrivial-auto-var-init): New option.\n\t* doc/invoke.texi (-Wtrivial-auto-var-init): Document new option.\n\t(-ftrivial-auto-var-init): Update option;\n\t* gimplify.cc (emit_warn_switch_unreachable): New function.\n\t(warn_switch_unreachable_r): Rename to ...\n\t(warn_switch_unreachable_and_auto_init_r): This.\n\t(maybe_warn_switch_unreachable): Rename to ...\n\t(maybe_warn_switch_unreachable_and_auto_init): This.\n\t(gimplify_switch_expr): Update calls to renamed function.\n\ngcc/testsuite/ChangeLog:\n\n\tPR middle-end/102276\n\t* gcc.dg/auto-init-pr102276-1.c: New test.\n\t* gcc.dg/auto-init-pr102276-2.c: New test.\n\t* gcc.dg/auto-init-pr102276-3.c: New test.\n\t* gcc.dg/auto-init-pr102276-4.c: New test.", "tree": {"sha": "da157c6ccb1c857e58b7e4521fde2bd561351390", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/da157c6ccb1c857e58b7e4521fde2bd561351390"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dbaabd06aaf4a1b0f2a20671c39148a0bd6ccf0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbaabd06aaf4a1b0f2a20671c39148a0bd6ccf0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dbaabd06aaf4a1b0f2a20671c39148a0bd6ccf0e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbaabd06aaf4a1b0f2a20671c39148a0bd6ccf0e/comments", "author": {"login": "qingzhao69", "id": 89154636, "node_id": "MDQ6VXNlcjg5MTU0NjM2", "avatar_url": "https://avatars.githubusercontent.com/u/89154636?v=4", "gravatar_id": "", "url": "https://api.github.com/users/qingzhao69", "html_url": "https://github.com/qingzhao69", "followers_url": "https://api.github.com/users/qingzhao69/followers", "following_url": "https://api.github.com/users/qingzhao69/following{/other_user}", "gists_url": "https://api.github.com/users/qingzhao69/gists{/gist_id}", "starred_url": "https://api.github.com/users/qingzhao69/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/qingzhao69/subscriptions", "organizations_url": "https://api.github.com/users/qingzhao69/orgs", "repos_url": "https://api.github.com/users/qingzhao69/repos", "events_url": "https://api.github.com/users/qingzhao69/events{/privacy}", "received_events_url": "https://api.github.com/users/qingzhao69/received_events", "type": "User", "site_admin": false}, "committer": {"login": "qingzhao69", "id": 89154636, "node_id": "MDQ6VXNlcjg5MTU0NjM2", "avatar_url": "https://avatars.githubusercontent.com/u/89154636?v=4", "gravatar_id": "", "url": "https://api.github.com/users/qingzhao69", "html_url": "https://github.com/qingzhao69", "followers_url": "https://api.github.com/users/qingzhao69/followers", "following_url": "https://api.github.com/users/qingzhao69/following{/other_user}", "gists_url": "https://api.github.com/users/qingzhao69/gists{/gist_id}", "starred_url": "https://api.github.com/users/qingzhao69/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/qingzhao69/subscriptions", "organizations_url": "https://api.github.com/users/qingzhao69/orgs", "repos_url": "https://api.github.com/users/qingzhao69/repos", "events_url": "https://api.github.com/users/qingzhao69/events{/privacy}", "received_events_url": "https://api.github.com/users/qingzhao69/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8fede2876a751d53a28442dcca32466daa929daa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fede2876a751d53a28442dcca32466daa929daa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8fede2876a751d53a28442dcca32466daa929daa"}], "stats": {"total": 285, "additions": 259, "deletions": 26}, "files": [{"sha": "8b6513de47cfba716212d80b5b97fef1606223cf", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbaabd06aaf4a1b0f2a20671c39148a0bd6ccf0e/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbaabd06aaf4a1b0f2a20671c39148a0bd6ccf0e/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=dbaabd06aaf4a1b0f2a20671c39148a0bd6ccf0e", "patch": "@@ -801,6 +801,10 @@ Wtrampolines\n Common Var(warn_trampolines) Warning\n Warn whenever a trampoline is generated.\n \n+Wtrivial-auto-var-init\n+Common Var(warn_trivial_auto_var_init) Warning Init(0)\n+Warn about cases where -ftrivial-auto-var-init cannot initialize an auto variable.\n+\n Wtype-limits\n Common Var(warn_type_limits) Warning EnabledBy(Wextra)\n Warn if a comparison is always true or always false due to the limited range of the data type."}, {"sha": "248ed534aee4af4fd602da55ea34fd601cbdc0f8", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbaabd06aaf4a1b0f2a20671c39148a0bd6ccf0e/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbaabd06aaf4a1b0f2a20671c39148a0bd6ccf0e/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=dbaabd06aaf4a1b0f2a20671c39148a0bd6ccf0e", "patch": "@@ -399,7 +399,7 @@ Objective-C and Objective-C++ Dialects}.\n -Wswitch  -Wno-switch-bool  -Wswitch-default  -Wswitch-enum @gol\n -Wno-switch-outside-range  -Wno-switch-unreachable  -Wsync-nand @gol\n -Wsystem-headers  -Wtautological-compare  -Wtrampolines  -Wtrigraphs @gol\n--Wtsan -Wtype-limits  -Wundef @gol\n+-Wtrivial-auto-var-init -Wtsan -Wtype-limits  -Wundef @gol\n -Wuninitialized  -Wunknown-pragmas @gol\n -Wunsuffixed-float-constants  -Wunused @gol\n -Wunused-but-set-parameter  -Wunused-but-set-variable @gol\n@@ -6953,6 +6953,14 @@ This warning is enabled by default for C and C++ programs.\n Warn when @code{__sync_fetch_and_nand} and @code{__sync_nand_and_fetch}\n built-in functions are used.  These functions changed semantics in GCC 4.4.\n \n+@item -Wtrivial-auto-var-init\n+@opindex Wtrivial-auto-var-init\n+@opindex Wno-trivial-auto-var-init\n+Warn when @code{-ftrivial-auto-var-init} cannot initialize the automatic\n+variable.  A common situation is an automatic variable that is declared\n+between the controlling expression and the first case label of a @code{switch}\n+statement.\n+\n @item -Wunused-but-set-parameter\n @opindex Wunused-but-set-parameter\n @opindex Wno-unused-but-set-parameter\n@@ -12314,6 +12322,10 @@ initializer as uninitialized, @option{-Wuninitialized} and\n warning messages on such automatic variables.\n With this option, GCC will also initialize any padding of automatic variables\n that have structure or union types to zeroes.\n+However, the current implementation cannot initialize automatic variables that\n+are declared between the controlling expression and the first case of a\n+@code{switch} statement.  Using @option{-Wtrivial-auto-var-init} to report all\n+such cases.\n \n The three values of @var{choice} are:\n "}, {"sha": "2364d2e51829eaeb3facf098d7aa9f5657fd0f22", "filename": "gcc/gimplify.cc", "status": "modified", "additions": 86, "deletions": 25, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbaabd06aaf4a1b0f2a20671c39148a0bd6ccf0e/gcc%2Fgimplify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbaabd06aaf4a1b0f2a20671c39148a0bd6ccf0e/gcc%2Fgimplify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.cc?ref=dbaabd06aaf4a1b0f2a20671c39148a0bd6ccf0e", "patch": "@@ -2029,13 +2029,55 @@ gimplify_statement_list (tree *expr_p, gimple_seq *pre_p)\n   return GS_ALL_DONE;\n }\n \n+\n+/* Emit warning for the unreachable statment STMT if needed.\n+   Return the gimple itself when the warning is emitted, otherwise\n+   return NULL.  */\n+static gimple *\n+emit_warn_switch_unreachable (gimple *stmt)\n+{\n+  if (gimple_code (stmt) == GIMPLE_GOTO\n+      && TREE_CODE (gimple_goto_dest (stmt)) == LABEL_DECL\n+      && DECL_ARTIFICIAL (gimple_goto_dest (stmt)))\n+  /* Don't warn for compiler-generated gotos.  These occur\n+     in Duff's devices, for example.  */\n+    return NULL;\n+  else if ((flag_auto_var_init > AUTO_INIT_UNINITIALIZED)\n+\t   && ((gimple_call_internal_p (stmt, IFN_DEFERRED_INIT))\n+\t\t|| (gimple_call_builtin_p (stmt, BUILT_IN_CLEAR_PADDING)\n+\t\t    && (bool) TREE_INT_CST_LOW (gimple_call_arg (stmt, 1)))\n+\t\t|| (is_gimple_assign (stmt)\n+\t\t    && gimple_assign_single_p (stmt)\n+\t\t    && (TREE_CODE (gimple_assign_rhs1 (stmt)) == SSA_NAME)\n+\t\t    && gimple_call_internal_p (\n+\t\t\t SSA_NAME_DEF_STMT (gimple_assign_rhs1 (stmt)),\n+\t\t\t IFN_DEFERRED_INIT))))\n+  /* Don't warn for compiler-generated initializations for\n+     -ftrivial-auto-var-init.\n+     There are 3 cases:\n+\tcase 1: a call to .DEFERRED_INIT;\n+\tcase 2: a call to __builtin_clear_padding with the 2nd argument is\n+\t\tpresent and non-zero;\n+\tcase 3: a gimple assign store right after the call to .DEFERRED_INIT\n+\t\tthat has the LHS of .DEFERRED_INIT as the RHS as following:\n+\t\t  _1 = .DEFERRED_INIT (4, 2, &\"i1\"[0]);\n+\t\t  i1 = _1.  */\n+    return NULL;\n+  else\n+    warning_at (gimple_location (stmt), OPT_Wswitch_unreachable,\n+\t\t\"statement will never be executed\");\n+  return stmt;\n+}\n+\n /* Callback for walk_gimple_seq.  */\n \n static tree\n-warn_switch_unreachable_r (gimple_stmt_iterator *gsi_p, bool *handled_ops_p,\n-\t\t\t   struct walk_stmt_info *wi)\n+warn_switch_unreachable_and_auto_init_r (gimple_stmt_iterator *gsi_p,\n+\t\t\t\t\t bool *handled_ops_p,\n+\t\t\t\t\t struct walk_stmt_info *wi)\n {\n   gimple *stmt = gsi_stmt (*gsi_p);\n+  bool unreachable_issued = wi->info != NULL;\n \n   *handled_ops_p = true;\n   switch (gimple_code (stmt))\n@@ -2046,8 +2088,12 @@ warn_switch_unreachable_r (gimple_stmt_iterator *gsi_p, bool *handled_ops_p,\n \t worse location info.  */\n       if (gimple_try_eval (stmt) == NULL)\n \t{\n-\t  wi->info = stmt;\n-\t  return integer_zero_node;\n+\t  if (warn_switch_unreachable && !unreachable_issued)\n+\t    wi->info = emit_warn_switch_unreachable (stmt);\n+\n+\t  /* Stop when auto var init warning is not on.  */\n+\t  if (!warn_trivial_auto_var_init)\n+\t    return integer_zero_node;\n \t}\n       /* Fall through.  */\n     case GIMPLE_BIND:\n@@ -2064,50 +2110,65 @@ warn_switch_unreachable_r (gimple_stmt_iterator *gsi_p, bool *handled_ops_p,\n \t there will be non-debug stmts too, and we'll catch those.  */\n       break;\n \n+    case GIMPLE_LABEL:\n+      /* Stop till the first Label.  */\n+      return integer_zero_node;\n     case GIMPLE_CALL:\n       if (gimple_call_internal_p (stmt, IFN_ASAN_MARK))\n \t{\n \t  *handled_ops_p = false;\n \t  break;\n \t}\n+      if (warn_trivial_auto_var_init\n+\t  && flag_auto_var_init > AUTO_INIT_UNINITIALIZED\n+\t  && gimple_call_internal_p (stmt, IFN_DEFERRED_INIT))\n+\t{\n+\t  /* Get the variable name from the 3rd argument of call.  */\n+\t  tree var_name = gimple_call_arg (stmt, 2);\n+\t  var_name = TREE_OPERAND (TREE_OPERAND (var_name, 0), 0);\n+\t  const char *var_name_str = TREE_STRING_POINTER (var_name);\n+\n+\t  warning_at (gimple_location (stmt), OPT_Wtrivial_auto_var_init,\n+\t\t      \"%qs cannot be initialized with\"\n+\t\t      \"%<-ftrivial-auto-var_init%>\",\n+\t\t      var_name_str);\n+\t  break;\n+       }\n+\n       /* Fall through.  */\n     default:\n-      /* Save the first \"real\" statement (not a decl/lexical scope/...).  */\n-      wi->info = stmt;\n-      return integer_zero_node;\n+      /* check the first \"real\" statement (not a decl/lexical scope/...), issue\n+\t warning if needed.  */\n+      if (warn_switch_unreachable && !unreachable_issued)\n+\twi->info = emit_warn_switch_unreachable (stmt);\n+      /* Stop when auto var init warning is not on.  */\n+      if (!warn_trivial_auto_var_init)\n+\treturn integer_zero_node;\n+      break;\n     }\n   return NULL_TREE;\n }\n \n+\n /* Possibly warn about unreachable statements between switch's controlling\n-   expression and the first case.  SEQ is the body of a switch expression.  */\n+   expression and the first case.  Also warn about -ftrivial-auto-var-init\n+   cannot initialize the auto variable under such situation.\n+   SEQ is the body of a switch expression.  */\n \n static void\n-maybe_warn_switch_unreachable (gimple_seq seq)\n+maybe_warn_switch_unreachable_and_auto_init (gimple_seq seq)\n {\n-  if (!warn_switch_unreachable\n+  if ((!warn_switch_unreachable && !warn_trivial_auto_var_init)\n       /* This warning doesn't play well with Fortran when optimizations\n \t are on.  */\n       || lang_GNU_Fortran ()\n       || seq == NULL)\n     return;\n \n   struct walk_stmt_info wi;\n-  memset (&wi, 0, sizeof (wi));\n-  walk_gimple_seq (seq, warn_switch_unreachable_r, NULL, &wi);\n-  gimple *stmt = (gimple *) wi.info;\n \n-  if (stmt && gimple_code (stmt) != GIMPLE_LABEL)\n-    {\n-      if (gimple_code (stmt) == GIMPLE_GOTO\n-\t  && TREE_CODE (gimple_goto_dest (stmt)) == LABEL_DECL\n-\t  && DECL_ARTIFICIAL (gimple_goto_dest (stmt)))\n-\t/* Don't warn for compiler-generated gotos.  These occur\n-\t   in Duff's devices, for example.  */;\n-      else\n-\twarning_at (gimple_location (stmt), OPT_Wswitch_unreachable,\n-\t\t    \"statement will never be executed\");\n-    }\n+  memset (&wi, 0, sizeof (wi));\n+  walk_gimple_seq (seq, warn_switch_unreachable_and_auto_init_r, NULL, &wi);\n }\n \n \n@@ -2640,7 +2701,7 @@ gimplify_switch_expr (tree *expr_p, gimple_seq *pre_p)\n       gimplify_stmt (&SWITCH_BODY (switch_expr), &switch_body_seq);\n \n       gimplify_ctxp->in_switch_expr = old_in_switch_expr;\n-      maybe_warn_switch_unreachable (switch_body_seq);\n+      maybe_warn_switch_unreachable_and_auto_init (switch_body_seq);\n       maybe_warn_implicit_fallthrough (switch_body_seq);\n       /* Only do this for the outermost GIMPLE_SWITCH.  */\n       if (!gimplify_ctxp->in_switch_expr)"}, {"sha": "d574926e0c83f7d8e1a92a92f3b505ad2714de5c", "filename": "gcc/testsuite/gcc.dg/auto-init-pr102276-1.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbaabd06aaf4a1b0f2a20671c39148a0bd6ccf0e/gcc%2Ftestsuite%2Fgcc.dg%2Fauto-init-pr102276-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbaabd06aaf4a1b0f2a20671c39148a0bd6ccf0e/gcc%2Ftestsuite%2Fgcc.dg%2Fauto-init-pr102276-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fauto-init-pr102276-1.c?ref=dbaabd06aaf4a1b0f2a20671c39148a0bd6ccf0e", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Wall -ftrivial-auto-var-init=zero\" } */\n+\n+int g(int *);\n+int f()\n+{\n+    switch (0) { \n+        int x;  /* { dg-bogus \"statement will never be executed\" } */\n+        default:\n+        return g(&x);\n+    }\n+}\n+\n+int g1(int);\n+int f1()\n+{\n+    switch (0) {\n+        int x; /* { dg-bogus \"statement will never be executed\" } */\n+        default:\n+        return g1(x);  /* { dg-warning \"is used uninitialized\" } */\n+    }\n+}\n+\n+struct S\n+{\n+  char a;\n+  int b;\n+};\n+int g2(int);\n+int f2(int input)\n+{\n+    switch (0) {\n+        struct S x; /* { dg-bogus \"statement will never be executed\" } */\n+        default:\n+        return g2(input) + x.b;  /* { dg-warning \"is used uninitialized\" } */\n+    }\n+}\n+"}, {"sha": "779d3ec3882339ec4526fc40635eb854dde74f29", "filename": "gcc/testsuite/gcc.dg/auto-init-pr102276-2.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbaabd06aaf4a1b0f2a20671c39148a0bd6ccf0e/gcc%2Ftestsuite%2Fgcc.dg%2Fauto-init-pr102276-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbaabd06aaf4a1b0f2a20671c39148a0bd6ccf0e/gcc%2Ftestsuite%2Fgcc.dg%2Fauto-init-pr102276-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fauto-init-pr102276-2.c?ref=dbaabd06aaf4a1b0f2a20671c39148a0bd6ccf0e", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Wall -ftrivial-auto-var-init=pattern\" } */\n+\n+int g(int *);\n+int f()\n+{\n+    switch (0) { \n+        int x;  /* { dg-bogus \"statement will never be executed\" } */\n+        default:\n+        return g(&x);\n+    }\n+}\n+\n+int g1(int);\n+int f1()\n+{\n+    switch (0) {\n+        int x; /* { dg-bogus \"statement will never be executed\" } */\n+        default:\n+        return g1(x);  /* { dg-warning \"is used uninitialized\" } */\n+    }\n+}\n+\n+struct S\n+{\n+  char a;\n+  int b;\n+};\n+int g2(int);\n+int f2(int input)\n+{\n+    switch (0) {\n+        struct S x; /* { dg-bogus \"statement will never be executed\" } */\n+        default:\n+        return g2(input) + x.b;  /* { dg-warning \"is used uninitialized\" } */\n+    }\n+}\n+"}, {"sha": "f113f46e29dcff9dfdc96ec67c35e58d829a266c", "filename": "gcc/testsuite/gcc.dg/auto-init-pr102276-3.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbaabd06aaf4a1b0f2a20671c39148a0bd6ccf0e/gcc%2Ftestsuite%2Fgcc.dg%2Fauto-init-pr102276-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbaabd06aaf4a1b0f2a20671c39148a0bd6ccf0e/gcc%2Ftestsuite%2Fgcc.dg%2Fauto-init-pr102276-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fauto-init-pr102276-3.c?ref=dbaabd06aaf4a1b0f2a20671c39148a0bd6ccf0e", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Wtrivial-auto-var-init -ftrivial-auto-var-init=zero\" } */\n+\n+int g(int *, int *);\n+int f()\n+{\n+    switch (0) {\n+        int x;  /* { dg-warning \"cannot be initialized with\" } */\n+        int y;  /* { dg-warning \"cannot be initialized with\" } */\n+        default:\n+        return g(&x, &y);\n+    }\n+}\n+\n+int g1(int, int);\n+int f1()\n+{\n+    switch (0) {\n+        int x; /* { dg-warning \"cannot be initialized with\" } */\n+        int y; /* { dg-warning \"cannot be initialized with\" } */\n+        default:\n+        return g1(x, y);\n+    }\n+}\n+\n+struct S\n+{\n+  char a;\n+  int b;\n+};\n+int g2(int);\n+int f2(int input)\n+{\n+    switch (0) {\n+        struct S x; /* { dg-warning \"cannot be initialized with\" } */\n+        struct S y; /* { dg-warning \"cannot be initialized with\" } */\n+        default:\n+        return g2(input) + x.b + y.b;\n+    }\n+}"}, {"sha": "662e0d1182e6ccb597975e52e8535ab2e06c3f16", "filename": "gcc/testsuite/gcc.dg/auto-init-pr102276-4.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbaabd06aaf4a1b0f2a20671c39148a0bd6ccf0e/gcc%2Ftestsuite%2Fgcc.dg%2Fauto-init-pr102276-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbaabd06aaf4a1b0f2a20671c39148a0bd6ccf0e/gcc%2Ftestsuite%2Fgcc.dg%2Fauto-init-pr102276-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fauto-init-pr102276-4.c?ref=dbaabd06aaf4a1b0f2a20671c39148a0bd6ccf0e", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Wtrivial-auto-var-init -ftrivial-auto-var-init=pattern\" } */\n+\n+int g(int *, int *);\n+int f()\n+{\n+    switch (0) {\n+        int x;  /* { dg-warning \"cannot be initialized with\" } */\n+        int y;  /* { dg-warning \"cannot be initialized with\" } */\n+        default:\n+        return g(&x, &y);\n+    }\n+}\n+\n+int g1(int, int);\n+int f1()\n+{\n+    switch (0) {\n+        int x; /* { dg-warning \"cannot be initialized with\" } */\n+        int y; /* { dg-warning \"cannot be initialized with\" } */\n+        default:\n+        return g1(x, y);\n+    }\n+}\n+\n+struct S\n+{\n+  char a;\n+  int b;\n+};\n+int g2(int);\n+int f2(int input)\n+{\n+    switch (0) {\n+        struct S x; /* { dg-warning \"cannot be initialized with\" } */\n+        struct S y; /* { dg-warning \"cannot be initialized with\" } */\n+        default:\n+        return g2(input) + x.b + y.b;\n+    }\n+}"}]}