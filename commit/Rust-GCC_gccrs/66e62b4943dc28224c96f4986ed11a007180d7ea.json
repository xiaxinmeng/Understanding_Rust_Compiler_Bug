{"sha": "66e62b4943dc28224c96f4986ed11a007180d7ea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjZlNjJiNDk0M2RjMjgyMjRjOTZmNDk4NmVkMTFhMDA3MTgwZDdlYQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@codesourcery.com", "date": "2008-11-06T14:59:09Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2008-11-06T14:59:09Z"}, "message": "re PR target/35574 (unrecognizable insn generated for vector move)\n\n\tPR target/35574\n\t* config/sparc/constraints.md (D): New.\n\t* config/sparc/predicates.md (const_double_or_vector_operand):\n\tNew.\n\t* config/sparc/sparc.c (sparc_extra_constraint_check): Handle the\n\t'D' constraint.\n\t* config/sparc/sparc.md (*movdf_insn_sp32_v9, *movdf_insn_sp64):\n\tUse the 'D' constraint in addition to 'F' in some alternatives.\n\t(DF splitter): Generalize for V64mode.\n\t* doc/md.texi (SPARC): Document the 'D' constraint.\n\nFrom-SVN: r141644", "tree": {"sha": "58b44151e6e81b9d15ee44718df0e1316e8a2dd8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/58b44151e6e81b9d15ee44718df0e1316e8a2dd8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/66e62b4943dc28224c96f4986ed11a007180d7ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66e62b4943dc28224c96f4986ed11a007180d7ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66e62b4943dc28224c96f4986ed11a007180d7ea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66e62b4943dc28224c96f4986ed11a007180d7ea/comments", "author": null, "committer": null, "parents": [{"sha": "1ddb9ec910a77414305a4b3bba72e3f4ae02f92a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ddb9ec910a77414305a4b3bba72e3f4ae02f92a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ddb9ec910a77414305a4b3bba72e3f4ae02f92a"}], "stats": {"total": 69, "additions": 46, "deletions": 23}, "files": [{"sha": "44b888e8537381696c1b6312c7a38fc9aec2eda9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66e62b4943dc28224c96f4986ed11a007180d7ea/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66e62b4943dc28224c96f4986ed11a007180d7ea/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=66e62b4943dc28224c96f4986ed11a007180d7ea", "patch": "@@ -1,3 +1,16 @@\n+2008-11-06  Kazu Hirata  <kazu@codesourcery.com>\n+\n+\tPR target/35574\n+\t* config/sparc/constraints.md (D): New.\n+\t* config/sparc/predicates.md (const_double_or_vector_operand):\n+\tNew.\n+\t* config/sparc/sparc.c (sparc_extra_constraint_check): Handle the\n+\t'D' constraint.\n+\t* config/sparc/sparc.md (*movdf_insn_sp32_v9, *movdf_insn_sp64):\n+\tUse the 'D' constraint in addition to 'F' in some alternatives.\n+\t(DF splitter): Generalize for V64mode.\n+\t* doc/md.texi (SPARC): Document the 'D' constraint.\n+\n 2008-11-06  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* reg-stack.c (reg_to_stack): Generate +QNaN using real_nan."}, {"sha": "ee0fbbda69ac84ae272b90950a8efdc32b957b3c", "filename": "gcc/config/sparc/constraints.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66e62b4943dc28224c96f4986ed11a007180d7ea/gcc%2Fconfig%2Fsparc%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66e62b4943dc28224c96f4986ed11a007180d7ea/gcc%2Fconfig%2Fsparc%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fconstraints.md?ref=66e62b4943dc28224c96f4986ed11a007180d7ea", "patch": "@@ -100,6 +100,11 @@\n ;; Our memory extra constraints have to emulate the behavior of 'm' and 'o',\n ;; i.e. accept pseudo-registers during reload.\n \n+(define_constraint \"D\"\n+ \"const_vector\"\n+  (and (match_code \"const_vector\")\n+       (match_test \"GET_MODE_CLASS (GET_MODE (op)) == MODE_VECTOR_INT\")))\n+\n (define_constraint \"Q\"\n  \"Floating-point constant that can be loaded with a sethi instruction\"\n  (and (match_code \"const_double\")"}, {"sha": "379c73c8f82509f0d3d7d3c8405b92f23f865e21", "filename": "gcc/config/sparc/predicates.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66e62b4943dc28224c96f4986ed11a007180d7ea/gcc%2Fconfig%2Fsparc%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66e62b4943dc28224c96f4986ed11a007180d7ea/gcc%2Fconfig%2Fsparc%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fpredicates.md?ref=66e62b4943dc28224c96f4986ed11a007180d7ea", "patch": "@@ -83,6 +83,10 @@\n   return fp_high_losum_p (op);\n })\n \n+;; Return true if OP is a const_double or const_vector.\n+(define_predicate \"const_double_or_vector_operand\"\n+  (match_code \"const_double,const_vector\"))\n+\n \n ;; Predicates for symbolic constants.\n "}, {"sha": "7dadde2b443cb1eb51bee4498e5f31ca2292a600", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 21, "deletions": 23, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66e62b4943dc28224c96f4986ed11a007180d7ea/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66e62b4943dc28224c96f4986ed11a007180d7ea/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=66e62b4943dc28224c96f4986ed11a007180d7ea", "patch": "@@ -2571,7 +2571,7 @@\n ;; We have available v9 double floats but not 64-bit integer registers.\n (define_insn \"*movdf_insn_sp32_v9\"\n   [(set (match_operand:V64 0 \"nonimmediate_operand\" \"=b,e,e,T,W,U,T,f,*r,o\")\n-        (match_operand:V64 1 \"input_operand\" \"GY,e,W#F,GY,e,T,U,o#F,*roGYF,*rGYf\"))]\n+        (match_operand:V64 1 \"input_operand\" \"GY,e,W#F,GY,e,T,U,o#F,*roGYDF,*rGYf\"))]\n   \"TARGET_FPU\n    && TARGET_V9\n    && ! TARGET_ARCH64\n@@ -2612,7 +2612,7 @@\n ;; We have available both v9 double floats and 64-bit integer registers.\n (define_insn \"*movdf_insn_sp64\"\n   [(set (match_operand:V64 0 \"nonimmediate_operand\" \"=b,e,e,W,*r,*r,m,*r\")\n-        (match_operand:V64 1 \"input_operand\"    \"GY,e,W#F,e,*rGY,m,*rGY,F\"))]\n+        (match_operand:V64 1 \"input_operand\"    \"GY,e,W#F,e,*rGY,m,*rGY,DF\"))]\n   \"TARGET_FPU\n    && TARGET_ARCH64\n    && (register_operand (operands[0], <V64:MODE>mode)\n@@ -2643,54 +2643,52 @@\n   stx\\t%r1, %0\"\n   [(set_attr \"type\" \"*,load,store\")])\n \n-;; This pattern build DFmode constants in integer registers.\n+;; This pattern builds V64mode constants in integer registers.\n (define_split\n-  [(set (match_operand:DF 0 \"register_operand\" \"\")\n-        (match_operand:DF 1 \"const_double_operand\" \"\"))]\n+  [(set (match_operand:V64 0 \"register_operand\" \"\")\n+        (match_operand:V64 1 \"const_double_or_vector_operand\" \"\"))]\n   \"TARGET_FPU\n    && (GET_CODE (operands[0]) == REG\n        && REGNO (operands[0]) < 32)\n-   && ! const_zero_operand(operands[1], DFmode)\n+   && ! const_zero_operand (operands[1], GET_MODE (operands[0]))\n    && reload_completed\"\n   [(clobber (const_int 0))]\n {\n-  REAL_VALUE_TYPE r;\n-  long l[2];\n-\n-  REAL_VALUE_FROM_CONST_DOUBLE (r, operands[1]);\n-  REAL_VALUE_TO_TARGET_DOUBLE (r, l);\n   operands[0] = gen_rtx_raw_REG (DImode, REGNO (operands[0]));\n \n   if (TARGET_ARCH64)\n     {\n #if HOST_BITS_PER_WIDE_INT == 32\n       gcc_unreachable ();\n #else\n-      HOST_WIDE_INT val;\n-\n-      val = ((HOST_WIDE_INT)(unsigned long)l[1] |\n-             ((HOST_WIDE_INT)(unsigned long)l[0] << 32));\n-      emit_insn (gen_movdi (operands[0], gen_int_mode (val, DImode)));\n+      enum machine_mode mode = GET_MODE (operands[1]);\n+      rtx tem = simplify_subreg (DImode, operands[1], mode, 0);\n+      emit_insn (gen_movdi (operands[0], tem));\n #endif\n     }\n   else\n     {\n-      emit_insn (gen_movsi (gen_highpart (SImode, operands[0]),\n-\t\t\t    gen_int_mode (l[0], SImode)));\n+      enum machine_mode mode = GET_MODE (operands[1]);\n+      rtx hi = simplify_subreg (SImode, operands[1], mode, 0);\n+      rtx lo = simplify_subreg (SImode, operands[1], mode, 4);\n+\n+      gcc_assert (GET_CODE (hi) == CONST_INT);\n+      gcc_assert (GET_CODE (lo) == CONST_INT);\n+\n+      emit_insn (gen_movsi (gen_highpart (SImode, operands[0]), hi));\n \n       /* Slick... but this trick loses if this subreg constant part\n          can be done in one insn.  */\n-      if (l[1] == l[0]\n-\t  && ! SPARC_SETHI32_P (l[0])\n-\t  && ! SPARC_SIMM13_P (l[0]))\n+      if (lo == hi\n+\t  && ! SPARC_SETHI32_P (INTVAL (hi))\n+\t  && ! SPARC_SIMM13_P (INTVAL (hi)))\n         {\n           emit_insn (gen_movsi (gen_lowpart (SImode, operands[0]),\n \t\t\t        gen_highpart (SImode, operands[0])));\n         }\n       else\n         {\n-          emit_insn (gen_movsi (gen_lowpart (SImode, operands[0]),\n-\t\t\t        gen_int_mode (l[1], SImode)));\n+          emit_insn (gen_movsi (gen_lowpart (SImode, operands[0]), lo));\n         }\n     }\n   DONE;"}, {"sha": "3505dea45af6734f72e204a96e95e1bafd9363b7", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66e62b4943dc28224c96f4986ed11a007180d7ea/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66e62b4943dc28224c96f4986ed11a007180d7ea/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=66e62b4943dc28224c96f4986ed11a007180d7ea", "patch": "@@ -2738,6 +2738,9 @@ when the Visual Instruction Set is available.\n @item h\n 64-bit global or out register for the SPARC-V8+ architecture.\n \n+@item D\n+A vector constant\n+\n @item I\n Signed 13-bit constant\n "}]}