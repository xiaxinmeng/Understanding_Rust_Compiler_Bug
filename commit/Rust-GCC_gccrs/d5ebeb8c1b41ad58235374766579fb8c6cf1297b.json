{"sha": "d5ebeb8c1b41ad58235374766579fb8c6cf1297b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDVlYmViOGMxYjQxYWQ1ODIzNTM3NDc2NjU3OWZiOGM2Y2YxMjk3Yg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2016-06-06T09:26:07Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2016-06-06T09:26:07Z"}, "message": "decl.c (gnat_to_gnu_entity): Remove useless 'else' statements and tidy up.\n\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Component>: Remove\n\tuseless 'else' statements and tidy up.\n\t<E_Array_Subtype>: Fully deal with the declaration here.\n\t<E_Incomplete_Type>: Use properly-typed constant.\n\tAssert that we don't apply the special type treatment to dummy types.\n\tSeparate this treatment from the final back-annotation and simplify\n\tthe condition for the RM size.\n\t(gnat_to_gnu_param): Add GNU_PARAM_TYPE parameter and adjust.\n\t(gnat_to_gnu_subprog_type): Ajust call to gnat_to_gnu_param.\n\t* gcc-interface/trans.c (gnat_to_gnu) <N_Subprogram_Declaration>: Add\n\tcomment.\n\t(process_freeze_entity): Remove obsolete code.\n\t(process_type): Minor tweaks.\n\nFrom-SVN: r237122", "tree": {"sha": "9422b441779d5c1c3325ca70c21c4637227cb4e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9422b441779d5c1c3325ca70c21c4637227cb4e5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d5ebeb8c1b41ad58235374766579fb8c6cf1297b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5ebeb8c1b41ad58235374766579fb8c6cf1297b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5ebeb8c1b41ad58235374766579fb8c6cf1297b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5ebeb8c1b41ad58235374766579fb8c6cf1297b/comments", "author": null, "committer": null, "parents": [{"sha": "4d9446f9c071edf7fad4a58267009fdd190de9d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d9446f9c071edf7fad4a58267009fdd190de9d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d9446f9c071edf7fad4a58267009fdd190de9d2"}], "stats": {"total": 184, "additions": 101, "deletions": 83}, "files": [{"sha": "0370cd112ee8af9863065ddf9ffad9e9ec4eb8cb", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5ebeb8c1b41ad58235374766579fb8c6cf1297b/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5ebeb8c1b41ad58235374766579fb8c6cf1297b/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d5ebeb8c1b41ad58235374766579fb8c6cf1297b", "patch": "@@ -1,3 +1,19 @@\n+2016-06-06  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Component>: Remove\n+\tuseless 'else' statements and tidy up.\n+\t<E_Array_Subtype>: Fully deal with the declaration here.\n+\t<E_Incomplete_Type>: Use properly-typed constant.\n+\tAssert that we don't apply the special type treatment to dummy types.\n+\tSeparate this treatment from the final back-annotation and simplify\n+\tthe condition for the RM size.\n+\t(gnat_to_gnu_param): Add GNU_PARAM_TYPE parameter and adjust.\n+\t(gnat_to_gnu_subprog_type): Ajust call to gnat_to_gnu_param.\n+\t* gcc-interface/trans.c (gnat_to_gnu) <N_Subprogram_Declaration>: Add\n+\tcomment.\n+\t(process_freeze_entity): Remove obsolete code.\n+\t(process_type): Minor tweaks.\n+\n 2016-06-06  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* einfo.ads (Returns_Limited_View): Remove."}, {"sha": "c3aee4829a3ba292c5f2f86744522654d33892f2", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 54, "deletions": 48, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5ebeb8c1b41ad58235374766579fb8c6cf1297b/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5ebeb8c1b41ad58235374766579fb8c6cf1297b/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=d5ebeb8c1b41ad58235374766579fb8c6cf1297b", "patch": "@@ -496,8 +496,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t   be a FIELD_DECL.  Likewise for discriminants.  If the entity is a\n \t   non-girder discriminant (in the case of derived untagged record\n \t   types), return the stored discriminant it renames.  */\n-\telse if (Present (Original_Record_Component (gnat_entity))\n-\t\t && Original_Record_Component (gnat_entity) != gnat_entity)\n+\tif (Present (Original_Record_Component (gnat_entity))\n+\t    && Original_Record_Component (gnat_entity) != gnat_entity)\n \t  {\n \t    gnu_decl\n \t      = gnat_to_gnu_entity (Original_Record_Component (gnat_entity),\n@@ -509,7 +509,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t/* Otherwise, if we are not defining this and we have no GCC type\n \t   for the containing record, make one for it.  Then we should\n \t   have made our own equivalent.  */\n-\telse if (!definition && !present_gnu_tree (gnat_record))\n+\tif (!definition && !present_gnu_tree (gnat_record))\n \t  {\n \t    /* ??? If this is in a record whose scope is a protected\n \t       type and we have an Original_Record_Component, use it.\n@@ -523,21 +523,21 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t\t  = gnat_to_gnu_entity (Original_Record_Component\n \t\t\t\t\t(gnat_entity),\n \t\t\t\t\tgnu_expr, false);\n-\t\tsaved = true;\n-\t\tbreak;\n+\t      }\n+\t    else\n+\t      {\n+\t\tgnat_to_gnu_entity (Scope (gnat_entity), NULL_TREE, false);\n+\t\tgnu_decl = get_gnu_tree (gnat_entity);\n \t      }\n \n-\t    gnat_to_gnu_entity (Scope (gnat_entity), NULL_TREE, false);\n-\t    gnu_decl = get_gnu_tree (gnat_entity);\n \t    saved = true;\n \t    break;\n \t  }\n \n-\telse\n-\t  /* Here we have no GCC type and this is a reference rather than a\n-\t     definition.  This should never happen.  Most likely the cause is\n-\t     reference before declaration in the GNAT tree for gnat_entity.  */\n-\t  gcc_unreachable ();\n+\t/* Here we have no GCC type and this is a reference rather than a\n+\t   definition.  This should never happen.  Most likely the cause is\n+\t   reference before declaration in the GNAT tree for gnat_entity.  */\n+\tgcc_unreachable ();\n       }\n \n     case E_Constant:\n@@ -1064,6 +1064,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t\t    gcc_assert (ralign >= align);\n \t\t  }\n \n+\t\t/* The expression might not be a DECL so save it manually.  */\n \t\tsave_gnu_tree (gnat_entity, gnu_decl, true);\n \t\tsaved = true;\n \t\tannotate_object (gnat_entity, gnu_type, NULL_TREE, false);\n@@ -2828,8 +2829,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t\t\t\t      NULL_TREE, false);\n \t      this_made_decl = true;\n \t      gnu_type = TREE_TYPE (gnu_decl);\n-\n \t      save_gnu_tree (gnat_entity, NULL_TREE, false);\n+\t      save_gnu_tree (gnat_entity, gnu_decl, false);\n+\t      saved = true;\n \n \t      gnu_inner = gnu_type;\n \t      while (TREE_CODE (gnu_inner) == RECORD_TYPE\n@@ -4356,7 +4358,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t    gnu_decl = TYPE_STUB_DECL (gnu_type);\n \t    if (Has_Completion_In_Body (gnat_entity))\n \t      DECL_TAFT_TYPE_P (gnu_decl) = 1;\n-\t    save_gnu_tree (full_view, gnu_decl, 0);\n+\t    save_gnu_tree (full_view, gnu_decl, false);\n \t  }\n       }\n       break;\n@@ -4455,6 +4457,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n      handling alignment and possible padding.  */\n   if (is_type && (!gnu_decl || this_made_decl))\n     {\n+      gcc_assert (!TYPE_IS_DUMMY_P (gnu_type));\n+\n       /* Process the attributes, if not already done.  Note that the type is\n \t already defined so we cannot pass true for IN_PLACE here.  */\n       process_attributes (&gnu_type, &attr_list, false, gnat_entity);\n@@ -4703,21 +4707,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t    }\n \t}\n \n-      if (!gnu_decl)\n-\tgnu_decl = create_type_decl (gnu_entity_name, gnu_type,\n-\t\t\t\t     artificial_p, debug_info_p,\n-\t\t\t\t     gnat_entity);\n-      else\n-\t{\n-\t  TREE_TYPE (gnu_decl) = gnu_type;\n-\t  TYPE_STUB_DECL (gnu_type) = gnu_decl;\n-\t}\n-    }\n-\n-  if (is_type && !TYPE_IS_DUMMY_P (TREE_TYPE (gnu_decl)))\n-    {\n-      gnu_type = TREE_TYPE (gnu_decl);\n-\n       /* If this is a derived type, relate its alias set to that of its parent\n \t to avoid troubles when a call to an inherited primitive is inlined in\n \t a context where a derived object is accessed.  The inlined code works\n@@ -4796,8 +4785,23 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t\t\t     ? ALIAS_SET_COPY : ALIAS_SET_SUPERSET);\n \t}\n \n-      /* Back-annotate the Alignment of the type if not already in the\n-\t tree.  Likewise for sizes.  */\n+      if (!gnu_decl)\n+\tgnu_decl = create_type_decl (gnu_entity_name, gnu_type,\n+\t\t\t\t     artificial_p, debug_info_p,\n+\t\t\t\t     gnat_entity);\n+      else\n+\t{\n+\t  TREE_TYPE (gnu_decl) = gnu_type;\n+\t  TYPE_STUB_DECL (gnu_type) = gnu_decl;\n+\t}\n+    }\n+\n+  /* If we got a type that is not dummy, back-annotate the alignment of the\n+     type if not already in the tree.  Likewise for the size, if any.  */\n+  if (is_type && !TYPE_IS_DUMMY_P (TREE_TYPE (gnu_decl)))\n+    {\n+      gnu_type = TREE_TYPE (gnu_decl);\n+\n       if (Unknown_Alignment (gnat_entity))\n \t{\n \t  unsigned int double_align, align;\n@@ -4883,7 +4887,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t    Set_Esize (gnat_entity, annotate_value (gnu_size));\n \t}\n \n-      if (Unknown_RM_Size (gnat_entity) && rm_size (gnu_type))\n+      if (Unknown_RM_Size (gnat_entity) && TYPE_SIZE (gnu_type))\n \tSet_RM_Size (gnat_entity, annotate_value (rm_size (gnu_type)));\n     }\n \n@@ -5266,22 +5270,22 @@ gnat_to_gnu_component_type (Entity_Id gnat_array, bool definition,\n }\n \n /* Return a GCC tree for a parameter corresponding to GNAT_PARAM, to be placed\n-   in the parameter list built for GNAT_SUBPROG.  FIRST is true if GNAT_PARAM\n-   is the first parameter in the list.  Also set CICO to true if the parameter\n-   must use the copy-in copy-out implementation mechanism.\n+   in the parameter list of GNAT_SUBPROG.  GNU_PARAM_TYPE is the GCC tree for\n+   the type of the parameter.  FIRST is true if this is the first parameter in\n+   the list of GNAT_SUBPROG.  Also set CICO to true if the parameter must use\n+   the copy-in copy-out implementation mechanism.\n \n-   The returned tree is a PARM_DECL, except for those cases where no\n-   parameter needs to be actually passed to the subprogram; the type\n-   of this \"shadow\" parameter is then returned instead.  */\n+   The returned tree is a PARM_DECL, except for the cases where no parameter\n+   needs to be actually passed to the subprogram; the type of this \"shadow\"\n+   parameter is then returned instead.  */\n \n static tree\n-gnat_to_gnu_param (Entity_Id gnat_param, bool first, Entity_Id gnat_subprog,\n-\t\t   bool *cico)\n+gnat_to_gnu_param (Entity_Id gnat_param, tree gnu_param_type, bool first,\n+\t\t   Entity_Id gnat_subprog, bool *cico)\n {\n   Entity_Id gnat_param_type = Etype (gnat_param);\n   Mechanism_Type mech = Mechanism (gnat_param);\n   tree gnu_param_name = get_entity_name (gnat_param);\n-  tree gnu_param_type = gnat_to_gnu_type (gnat_param_type);\n   bool foreign = Has_Foreign_Convention (gnat_subprog);\n   bool in_param = (Ekind (gnat_param) == E_In_Parameter);\n   /* The parameter can be indirectly modified if its address is taken.  */\n@@ -5482,14 +5486,14 @@ gnat_to_gnu_param (Entity_Id gnat_param, bool first, Entity_Id gnat_subprog,\n }\n \n /* Associate GNAT_SUBPROG with GNU_TYPE, which must be a dummy type, so that\n-   GNAT_SUBPROG is updated when TYPE is completed.\n+   GNAT_SUBPROG is updated when GNU_TYPE is completed.\n \n    Ada 2012 (AI05-019) says that freezing a subprogram does not always freeze\n    the corresponding profile, which means that, by the time the freeze node\n    of the subprogram is encountered, types involved in its profile may still\n-   be not frozen yet.  That's why we do not update GNAT_SUBPROG when we see\n-   its freeze node but only when we see the freeze node of types involved in\n-   its profile, either types of formal parameters or the return type.  */\n+   be not yet frozen.  That's why we need to update GNAT_SUBPROG when we see\n+   the freeze node of types involved in its profile, either types of formal\n+   parameters or the return type.  */\n \n static void\n associate_subprog_with_dummy_type (Entity_Id gnat_subprog, tree gnu_type)\n@@ -5648,7 +5652,9 @@ gnat_to_gnu_profile_type (Entity_Id gnat_type)\n \t   && ((!in_main_unit\n \t        && !present_gnu_tree (gnat_equiv)\n \t\t&& Present (gnat_full)\n-\t\t&& (Is_Record_Type (gnat_full) || Is_Array_Type (gnat_full)))\n+\t\t&& (Is_Record_Type (gnat_full)\n+\t\t    || Is_Array_Type (gnat_full)\n+\t\t    || Is_Access_Type (gnat_full)))\n \t       || (in_main_unit && Present (Freeze_Node (gnat_rep)))))\n     {\n       gnu_type = make_dummy_type (gnat_equiv);\n@@ -5959,8 +5965,8 @@ gnat_to_gnu_subprog_type (Entity_Id gnat_subprog, bool definition,\n \t  else\n \t    {\n \t      gnu_param\n-\t\t= gnat_to_gnu_param (gnat_param, num == 0, gnat_subprog,\n-\t\t\t\t     &cico);\n+\t\t= gnat_to_gnu_param (gnat_param, gnu_param_type, num == 0,\n+\t\t\t\t     gnat_subprog, &cico);\n \n \t      /* We are returned either a PARM_DECL or a type if no parameter\n \t\t needs to be passed; in either case, adjust the type.  */"}, {"sha": "c8f125b554724004e0f9c71ddeb2c94bc9c5727b", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 31, "deletions": 35, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5ebeb8c1b41ad58235374766579fb8c6cf1297b/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5ebeb8c1b41ad58235374766579fb8c6cf1297b/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=d5ebeb8c1b41ad58235374766579fb8c6cf1297b", "patch": "@@ -7137,11 +7137,19 @@ gnat_to_gnu (Node_Id gnat_node)\n     /***************************/\n \n     case N_Subprogram_Declaration:\n-      /* Unless there is a freeze node, declare the subprogram.  We consider\n-\t this a \"definition\" even though we're not generating code for\n-\t the subprogram because we will be making the corresponding GCC\n-\t node here.  */\n-\n+      /* Unless there is a freeze node, declare the entity.  We consider\n+\t this a definition even though we're not generating code for the\n+\t subprogram because we will be making the corresponding GCC node.\n+\t When there is a freeze node, it is considered the definition of\n+\t the subprogram and we do nothing until after it is encountered.\n+\t That's an efficiency issue: the types involved in the profile\n+\t are far more likely to be frozen between the declaration and\n+\t the freeze node than before the declaration, so we save some\n+\t updates of the GCC node by waiting until the freeze node.\n+\t The counterpart is that we assume that there is no reference\n+\t to the subprogram between the declaration and the freeze node\n+\t in the expanded code; otherwise, it will be interpreted as an\n+\t external reference and very likely give rise to a link failure.  */\n       if (No (Freeze_Node (Defining_Entity (Specification (gnat_node)))))\n \tgnat_to_gnu_entity (Defining_Entity (Specification (gnat_node)),\n \t\t\t    NULL_TREE, true);\n@@ -7572,7 +7580,6 @@ gnat_to_gnu (Node_Id gnat_node)\n     case N_Itype_Reference:\n       if (!present_gnu_tree (Itype (gnat_node)))\n \tprocess_type (Itype (gnat_node));\n-\n       gnu_result = alloc_stmt_list ();\n       break;\n \n@@ -8571,20 +8578,16 @@ process_freeze_entity (Node_Id gnat_node)\n \t      && kind == E_Subprogram_Type)))\n     return;\n \n-  /* If we have a non-dummy type old tree, we have nothing to do, except\n-     aborting if this is the public view of a private type whose full view was\n-     not delayed, as this node was never delayed as it should have been.  We\n+  /* If we have a non-dummy type old tree, we have nothing to do, except for\n+     aborting, since this node was never delayed as it should have been.  We\n      let this happen for concurrent types and their Corresponding_Record_Type,\n      however, because each might legitimately be elaborated before its own\n      freeze node, e.g. while processing the other.  */\n   if (gnu_old\n       && !(TREE_CODE (gnu_old) == TYPE_DECL\n \t   && TYPE_IS_DUMMY_P (TREE_TYPE (gnu_old))))\n     {\n-      gcc_assert ((IN (kind, Incomplete_Or_Private_Kind)\n-\t\t   && Present (Full_View (gnat_entity))\n-\t\t   && No (Freeze_Node (Full_View (gnat_entity))))\n-\t\t  || Is_Concurrent_Type (gnat_entity)\n+      gcc_assert (Is_Concurrent_Type (gnat_entity)\n \t\t  || (IN (kind, Record_Kind)\n \t\t      && Is_Concurrent_Record_Type (gnat_entity)));\n       return;\n@@ -9456,28 +9459,22 @@ addressable_p (tree gnu_expr, tree gnu_type)\n     }\n }\n \f\n-/* Do the processing for the declaration of a GNAT_ENTITY, a type.  If\n-   a separate Freeze node exists, delay the bulk of the processing.  Otherwise\n-   make a GCC type for GNAT_ENTITY and set up the correspondence.  */\n+/* Do the processing for the declaration of a GNAT_ENTITY, a type or subtype.\n+   If a Freeze node exists for the entity, delay the bulk of the processing.\n+   Otherwise make a GCC type for GNAT_ENTITY and set up the correspondence.  */\n \n void\n process_type (Entity_Id gnat_entity)\n {\n   tree gnu_old\n-    = present_gnu_tree (gnat_entity) ? get_gnu_tree (gnat_entity) : 0;\n-  tree gnu_new;\n-\n-  /* If we are to delay elaboration of this type, just do any\n-     elaborations needed for expressions within the declaration and\n-     make a dummy type entry for this node and its Full_View (if\n-     any) in case something points to it.  Don't do this if it\n-     has already been done (the only way that can happen is if\n-     the private completion is also delayed).  */\n-  if (Present (Freeze_Node (gnat_entity))\n-      || (IN (Ekind (gnat_entity), Incomplete_Or_Private_Kind)\n-\t  && Present (Full_View (gnat_entity))\n-\t  && Present (Freeze_Node (Full_View (gnat_entity)))\n-\t  && !present_gnu_tree (Full_View (gnat_entity))))\n+    = present_gnu_tree (gnat_entity) ? get_gnu_tree (gnat_entity) : NULL_TREE;\n+\n+  /* If we are to delay elaboration of this type, just do any elaboration\n+     needed for expressions within the declaration and make a dummy node\n+     for it and its Full_View (if any), in case something points to it.\n+     Do not do this if it has already been done (the only way that can\n+     happen is if the private completion is also delayed).  */\n+  if (Present (Freeze_Node (gnat_entity)))\n     {\n       elaborate_entity (gnat_entity);\n \n@@ -9497,10 +9494,9 @@ process_type (Entity_Id gnat_entity)\n       return;\n     }\n \n-  /* If we saved away a dummy type for this node it means that this\n-     made the type that corresponds to the full type of an incomplete\n-     type.  Clear that type for now and then update the type in the\n-     pointers.  */\n+  /* If we saved away a dummy type for this node, it means that this made the\n+     type that corresponds to the full type of an incomplete type.  Clear that\n+     type for now and then update the type in the pointers below.  */\n   if (gnu_old)\n     {\n       gcc_assert (TREE_CODE (gnu_old) == TYPE_DECL\n@@ -9510,7 +9506,7 @@ process_type (Entity_Id gnat_entity)\n     }\n \n   /* Now fully elaborate the type.  */\n-  gnu_new = gnat_to_gnu_entity (gnat_entity, NULL_TREE, true);\n+  tree gnu_new = gnat_to_gnu_entity (gnat_entity, NULL_TREE, true);\n   gcc_assert (TREE_CODE (gnu_new) == TYPE_DECL);\n \n   /* If we have an old type and we've made pointers to this type, update those"}]}