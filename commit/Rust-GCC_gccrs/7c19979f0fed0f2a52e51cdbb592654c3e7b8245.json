{"sha": "7c19979f0fed0f2a52e51cdbb592654c3e7b8245", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2MxOTk3OWYwZmVkMGYyYTUyZTUxY2RiYjU5MjY1NGMzZTdiODI0NQ==", "commit": {"author": {"name": "James Greenhalgh", "email": "james.greenhalgh@arm.com", "date": "2013-05-01T10:40:23Z"}, "committer": {"name": "James Greenhalgh", "email": "jgreenhalgh@gcc.gnu.org", "date": "2013-05-01T10:40:23Z"}, "message": "[AArch64] Add special case when expanding vcond with arms {-1, -1}, {0, 0}.\n\ngcc/\n\t* config/aarch64/aarch64-simd.md\n\t(vcond<mode>_internal): Handle special cases for constant masks.\n\t(vcond<mode><mode>): Allow nonmemory_operands for outcome vectors.\n\t(vcondu<mode><mode>): Likewise.\n\t(vcond<v_cmp_result><mode>): New.\n\nFrom-SVN: r198492", "tree": {"sha": "c0fc67631e0a91dd0cdfa60945d063a46e8ac3a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c0fc67631e0a91dd0cdfa60945d063a46e8ac3a5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7c19979f0fed0f2a52e51cdbb592654c3e7b8245", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c19979f0fed0f2a52e51cdbb592654c3e7b8245", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c19979f0fed0f2a52e51cdbb592654c3e7b8245", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c19979f0fed0f2a52e51cdbb592654c3e7b8245/comments", "author": {"login": "jgreenhalgh-arm", "id": 6104025, "node_id": "MDQ6VXNlcjYxMDQwMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6104025?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jgreenhalgh-arm", "html_url": "https://github.com/jgreenhalgh-arm", "followers_url": "https://api.github.com/users/jgreenhalgh-arm/followers", "following_url": "https://api.github.com/users/jgreenhalgh-arm/following{/other_user}", "gists_url": "https://api.github.com/users/jgreenhalgh-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jgreenhalgh-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jgreenhalgh-arm/subscriptions", "organizations_url": "https://api.github.com/users/jgreenhalgh-arm/orgs", "repos_url": "https://api.github.com/users/jgreenhalgh-arm/repos", "events_url": "https://api.github.com/users/jgreenhalgh-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/jgreenhalgh-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bb60efd9bf472f4a6ca4e2071931d3761bd8b6c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb60efd9bf472f4a6ca4e2071931d3761bd8b6c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb60efd9bf472f4a6ca4e2071931d3761bd8b6c4"}], "stats": {"total": 95, "additions": 77, "deletions": 18}, "files": [{"sha": "d0392c80076093f40c8793f70df86b219ec92968", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c19979f0fed0f2a52e51cdbb592654c3e7b8245/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c19979f0fed0f2a52e51cdbb592654c3e7b8245/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7c19979f0fed0f2a52e51cdbb592654c3e7b8245", "patch": "@@ -1,3 +1,11 @@\n+2013-05-01  James Greenhalgh  <james.greenhalgh@arm.com>\n+\n+\t* config/aarch64/aarch64-simd.md\n+\t(vcond<mode>_internal): Handle special cases for constant masks.\n+\t(vcond<mode><mode>): Allow nonmemory_operands for outcome vectors.\n+\t(vcondu<mode><mode>): Likewise.\n+\t(vcond<v_cmp_result><mode>): New.\n+\n 2013-05-01  James Greenhalgh  <james.greenhalgh@arm.com>\n \n \t* config/aarch64/aarch64-builtins.c (BUILTIN_VALLDI): Define."}, {"sha": "dfe4acb51a8b35d5e005176e5263141b9c971d2e", "filename": "gcc/config/aarch64/aarch64-simd.md", "status": "modified", "additions": 69, "deletions": 18, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c19979f0fed0f2a52e51cdbb592654c3e7b8245/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c19979f0fed0f2a52e51cdbb592654c3e7b8245/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md?ref=7c19979f0fed0f2a52e51cdbb592654c3e7b8245", "patch": "@@ -1683,11 +1683,13 @@\n \t  (match_operator 3 \"comparison_operator\"\n \t    [(match_operand:VDQ 4 \"register_operand\")\n \t     (match_operand:VDQ 5 \"nonmemory_operand\")])\n-\t  (match_operand:VDQ 1 \"register_operand\")\n-\t  (match_operand:VDQ 2 \"register_operand\")))]\n+\t  (match_operand:VDQ 1 \"nonmemory_operand\")\n+\t  (match_operand:VDQ 2 \"nonmemory_operand\")))]\n   \"TARGET_SIMD\"\n {\n   int inverse = 0, has_zero_imm_form = 0;\n+  rtx op1 = operands[1];\n+  rtx op2 = operands[2];\n   rtx mask = gen_reg_rtx (<MODE>mode);\n \n   switch (GET_CODE (operands[3]))\n@@ -1746,11 +1748,26 @@\n     }\n \n   if (inverse)\n-    emit_insn (gen_aarch64_simd_bsl<mode> (operands[0], mask, operands[2],\n-\t\t\t\t    operands[1]));\n-  else\n-    emit_insn (gen_aarch64_simd_bsl<mode> (operands[0], mask, operands[1],\n-\t\t\t\t    operands[2]));\n+    {\n+      op1 = operands[2];\n+      op2 = operands[1];\n+    }\n+\n+    /* If we have (a = (b CMP c) ? -1 : 0);\n+       Then we can simply move the generated mask.  */\n+\n+    if (op1 == CONSTM1_RTX (<V_cmp_result>mode)\n+\t&& op2 == CONST0_RTX (<V_cmp_result>mode))\n+      emit_move_insn (operands[0], mask);\n+    else\n+      {\n+\tif (!REG_P (op1))\n+\t  op1 = force_reg (<MODE>mode, op1);\n+\tif (!REG_P (op2))\n+\t  op2 = force_reg (<MODE>mode, op2);\n+\temit_insn (gen_aarch64_simd_bsl<mode> (operands[0], mask,\n+\t\t\t\t\t       op1, op2));\n+      }\n \n   DONE;\n })\n@@ -1761,13 +1778,15 @@\n \t  (match_operator 3 \"comparison_operator\"\n \t    [(match_operand:VDQF 4 \"register_operand\")\n \t     (match_operand:VDQF 5 \"nonmemory_operand\")])\n-\t  (match_operand:VDQF 1 \"register_operand\")\n-\t  (match_operand:VDQF 2 \"register_operand\")))]\n+\t  (match_operand:VDQF 1 \"nonmemory_operand\")\n+\t  (match_operand:VDQF 2 \"nonmemory_operand\")))]\n   \"TARGET_SIMD\"\n {\n   int inverse = 0;\n   int use_zero_form = 0;\n   int swap_bsl_operands = 0;\n+  rtx op1 = operands[1];\n+  rtx op2 = operands[2];\n   rtx mask = gen_reg_rtx (<V_cmp_result>mode);\n   rtx tmp = gen_reg_rtx (<V_cmp_result>mode);\n \n@@ -1912,11 +1931,27 @@\n     }\n \n   if (swap_bsl_operands)\n-    emit_insn (gen_aarch64_simd_bsl<mode> (operands[0], mask, operands[2],\n-\t\t\t\t    operands[1]));\n-  else\n-    emit_insn (gen_aarch64_simd_bsl<mode> (operands[0], mask, operands[1],\n-\t\t\t\t    operands[2]));\n+    {\n+      op1 = operands[2];\n+      op2 = operands[1];\n+    }\n+\n+    /* If we have (a = (b CMP c) ? -1 : 0);\n+       Then we can simply move the generated mask.  */\n+\n+    if (op1 == CONSTM1_RTX (<V_cmp_result>mode)\n+\t&& op2 == CONST0_RTX (<V_cmp_result>mode))\n+      emit_move_insn (operands[0], mask);\n+    else\n+      {\n+\tif (!REG_P (op1))\n+\t  op1 = force_reg (<MODE>mode, op1);\n+\tif (!REG_P (op2))\n+\t  op2 = force_reg (<MODE>mode, op2);\n+\temit_insn (gen_aarch64_simd_bsl<mode> (operands[0], mask,\n+\t\t\t\t\t       op1, op2));\n+      }\n+\n   DONE;\n })\n \n@@ -1926,8 +1961,8 @@\n \t  (match_operator 3 \"comparison_operator\"\n \t    [(match_operand:VALL 4 \"register_operand\")\n \t     (match_operand:VALL 5 \"nonmemory_operand\")])\n-\t  (match_operand:VALL 1 \"register_operand\")\n-\t  (match_operand:VALL 2 \"register_operand\")))]\n+\t  (match_operand:VALL 1 \"nonmemory_operand\")\n+\t  (match_operand:VALL 2 \"nonmemory_operand\")))]\n   \"TARGET_SIMD\"\n {\n   emit_insn (gen_aarch64_vcond_internal<mode> (operands[0], operands[1],\n@@ -1936,15 +1971,31 @@\n   DONE;\n })\n \n+(define_expand \"vcond<v_cmp_result><mode>\"\n+  [(set (match_operand:<V_cmp_result> 0 \"register_operand\")\n+\t(if_then_else:<V_cmp_result>\n+\t  (match_operator 3 \"comparison_operator\"\n+\t    [(match_operand:VDQF 4 \"register_operand\")\n+\t     (match_operand:VDQF 5 \"nonmemory_operand\")])\n+\t  (match_operand:<V_cmp_result> 1 \"nonmemory_operand\")\n+\t  (match_operand:<V_cmp_result> 2 \"nonmemory_operand\")))]\n+  \"TARGET_SIMD\"\n+{\n+  emit_insn (gen_aarch64_vcond_internal<v_cmp_result> (\n+\t\t\t\t\t\toperands[0], operands[1],\n+\t\t\t\t\t\toperands[2], operands[3],\n+\t\t\t\t\t\toperands[4], operands[5]));\n+  DONE;\n+})\n \n (define_expand \"vcondu<mode><mode>\"\n   [(set (match_operand:VDQ 0 \"register_operand\")\n \t(if_then_else:VDQ\n \t  (match_operator 3 \"comparison_operator\"\n \t    [(match_operand:VDQ 4 \"register_operand\")\n \t     (match_operand:VDQ 5 \"nonmemory_operand\")])\n-\t  (match_operand:VDQ 1 \"register_operand\")\n-\t  (match_operand:VDQ 2 \"register_operand\")))]\n+\t  (match_operand:VDQ 1 \"nonmemory_operand\")\n+\t  (match_operand:VDQ 2 \"nonmemory_operand\")))]\n   \"TARGET_SIMD\"\n {\n   emit_insn (gen_aarch64_vcond_internal<mode> (operands[0], operands[1],"}]}