{"sha": "b3763384a1f696260f3ee7bda8c0e7e4ad732ad9", "node_id": "C_kwDOANBUbNoAKGIzNzYzMzg0YTFmNjk2MjYwZjNlZTdiZGE4YzBlN2U0YWQ3MzJhZDk", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-02-05T09:52:19Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-02-05T09:53:54Z"}, "message": "match.pd: Fix x * 0.0 -> 0.0 folding [PR104389]\n\nThe recent PR95115 change to punt in const_binop on folding operation\nwith non-NaN operands into NaN if flag_trapping_math broke the following\ntestcase, because the x * 0.0 simplification punts just if\nx maybe a NaN (because NaN * 0.0 is NaN not 0.0) or if one of the operands\ncould be negative zero.  But Inf * 0.0 or -Inf * 0.0 is also NaN, not\n0.0, so when NaNs are honored we need to punt for possible infinities too.\n\n2022-02-05  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR tree-optimization/104389\n\t* match.pd (x * 0 -> 0): Punt if x maybe infinite and NaNs are\n\thonored.\n\n\t* gcc.dg/pr104389.c: New test.", "tree": {"sha": "febcce6fffe8b8fa9fac9d643ba784416217f0b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/febcce6fffe8b8fa9fac9d643ba784416217f0b9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b3763384a1f696260f3ee7bda8c0e7e4ad732ad9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3763384a1f696260f3ee7bda8c0e7e4ad732ad9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3763384a1f696260f3ee7bda8c0e7e4ad732ad9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3763384a1f696260f3ee7bda8c0e7e4ad732ad9/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "affdeda16ef7fbd34f850443fe63bb407714297e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/affdeda16ef7fbd34f850443fe63bb407714297e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/affdeda16ef7fbd34f850443fe63bb407714297e"}], "stats": {"total": 30, "additions": 29, "deletions": 1}, "files": [{"sha": "7bbb80172fc786af220ed9f6cd124a0b1f7f44ae", "filename": "gcc/match.pd", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3763384a1f696260f3ee7bda8c0e7e4ad732ad9/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3763384a1f696260f3ee7bda8c0e7e4ad732ad9/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=b3763384a1f696260f3ee7bda8c0e7e4ad732ad9", "patch": "@@ -256,10 +256,12 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n /* Maybe fold x * 0 to 0.  The expressions aren't the same\n    when x is NaN, since x * 0 is also NaN.  Nor are they the\n    same in modes with signed zeros, since multiplying a\n-   negative value by 0 gives -0, not +0.  */\n+   negative value by 0 gives -0, not +0.  Nor when x is +-Inf,\n+   since x * 0 is NaN.  */\n (simplify\n  (mult @0 real_zerop@1)\n  (if (!tree_expr_maybe_nan_p (@0)\n+      && (!HONOR_NANS (type) || !tree_expr_maybe_infinite_p (@0))\n       && !tree_expr_maybe_real_minus_zero_p (@0)\n       && !tree_expr_maybe_real_minus_zero_p (@1))\n   @1))"}, {"sha": "0c6c85a4f48e2a53337809e1936de17ce1a86767", "filename": "gcc/testsuite/gcc.dg/pr104389.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3763384a1f696260f3ee7bda8c0e7e4ad732ad9/gcc%2Ftestsuite%2Fgcc.dg%2Fpr104389.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3763384a1f696260f3ee7bda8c0e7e4ad732ad9/gcc%2Ftestsuite%2Fgcc.dg%2Fpr104389.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr104389.c?ref=b3763384a1f696260f3ee7bda8c0e7e4ad732ad9", "patch": "@@ -0,0 +1,26 @@\n+/* PR tree-optimization/104389 */\n+/* { dg-do run } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-add-options ieee } */\n+/* { dg-require-effective-target inf } */\n+\n+__attribute__((noipa)) double\n+foo (void)\n+{\n+  double a = __builtin_huge_val ();\n+  return a * 0.0;\n+}\n+\n+__attribute__((noipa)) long double\n+bar (void)\n+{\n+  return __builtin_huge_vall () * 0.0L;\n+}\n+\n+int\n+main ()\n+{\n+  if (!__builtin_isnan (foo ()) || !__builtin_isnanl (bar ()))\n+    __builtin_abort ();\n+  return 0;\n+}"}]}