{"sha": "d392d163c58a6f9dcc2e68ae20ffde4c1bd69be5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDM5MmQxNjNjNThhNmY5ZGNjMmU2OGFlMjBmZmRlNGMxYmQ2OWJlNQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-05-20T00:01:58Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-05-20T00:01:58Z"}, "message": "Various updates.\n\nFrom-SVN: r19900", "tree": {"sha": "bfa4311063051c99b83076bcf738953262b7c76d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bfa4311063051c99b83076bcf738953262b7c76d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d392d163c58a6f9dcc2e68ae20ffde4c1bd69be5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d392d163c58a6f9dcc2e68ae20ffde4c1bd69be5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d392d163c58a6f9dcc2e68ae20ffde4c1bd69be5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d392d163c58a6f9dcc2e68ae20ffde4c1bd69be5/comments", "author": null, "committer": null, "parents": [{"sha": "aef1617ccb1782dd94d435e59ad2b10bd4b505fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aef1617ccb1782dd94d435e59ad2b10bd4b505fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aef1617ccb1782dd94d435e59ad2b10bd4b505fc"}], "stats": {"total": 48, "additions": 30, "deletions": 18}, "files": [{"sha": "2c2111a2a6e3fd8f7a7fff909eff2b6308312276", "filename": "gcc/PROJECTS", "status": "modified", "additions": 30, "deletions": 18, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d392d163c58a6f9dcc2e68ae20ffde4c1bd69be5/gcc%2FPROJECTS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d392d163c58a6f9dcc2e68ae20ffde4c1bd69be5/gcc%2FPROJECTS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FPROJECTS?ref=d392d163c58a6f9dcc2e68ae20ffde4c1bd69be5", "patch": "@@ -22,14 +22,9 @@ Haifa scheduler (haifa-sched.c, loop.[ch], unroll.[ch], genattrtab.c):\n   opinion that gcc already has too many -foptions, and haifa doesn't help\n   that situation.\n \n-  * Testing and benchmarking.  Haifa has received little testing inside\n-  Cygnus -- it needs to be throughly tested on a wide variety of platforms\n-  which benefit from instruction scheduling (sparc, alpha, pa, ppc, mips, x86,\n-  i960, m88k, sh, etc).    It needs to be benchmarked -- my tests showed\n-  haifa was very much a hit or miss in terms of performance improvements.\n-\n-  Some benchmarks ran significantly fasters, other significantly slower.\n-  We need to work on making haifa generate better overall code.\n+  * Testing and benchmarking.    We've converted a few ports to using the\n+  Haifa scheduler (hppa, sparc, ppc, alpha).  We need to continue testing\n+  and benchmarking the new scheduler on additional targets.\n \n   We need to have some kind of docs for how to best describe a machine to\n   the haifa scheduler to get good performance.  Some existing ports have\n@@ -38,6 +33,26 @@ Haifa scheduler (haifa-sched.c, loop.[ch], unroll.[ch], genattrtab.c):\n \n   \n \n+Improvements to global cse and partial redundancy elimination:\n+\n+The current implementation of global cse uses partial redundancy elimination\n+as described in Chow's thesis.\n+\n+Long term we want to use lazy code motion as the basis for partial redundancy\n+elimination.  lcm will find as many (or more) redunancies *and* it will\n+place the remaining computations at computationally optimal placement points\n+within the function.  This reduces the number of redundant operations performed\n+as well as reducing register lifetimes.  My experiments have shown that the\n+cases were the current PRE code hurts performance are greatly helped by using\n+lazy code motion.\n+\n+lcm also provides the underlying framework for several additional optimizations\n+such as shrink wrapping, spill code motion, dead store elimination, and generic\n+load/store motion (all the other examples are subcases of load/store motion).\n+\n+It can probably also be used to improve the reg-stack pass of the compiler.\n+\n+Contact law@cygnus.com if you're interested in working on lazy code motion.\n \n -------------\n \n@@ -57,14 +72,6 @@ The difficulty is in finding a clean way for the RTL which refers\n to the constant (currently, only by an assembler symbol name)\n to point to the constant and cause it to be output.\n \n-* More cse\n-\n-The techniques for doing full global cse are described in the red\n-dragon book, or (a different version) in Frederick Chow's thesis from\n-Stanford.  It is likely to be slow and use a lot of memory, but it\n-might be worth offering as an additional option.  Contact dje@cygnus.com\n-before doing any work on CSE.\n-\n * Optimize a sequence of if statements whose conditions are exclusive.\n \n It is possible to optimize \n@@ -207,6 +214,10 @@ the same location; and, in between, there is no reference to anything\n that might be that location (including no reference to a variable\n address).\n \n+This can be modeled as a partial redundancy elimination/lazy code motion\n+problem.  Contact law@cygnus.com before working on dead store elimination\n+optimizations.\n+\n * Loop optimization.\n \n Strength reduction and iteration variable elimination could be\n@@ -275,8 +286,9 @@ to the order in which to generate code for subexpressions of an expression.\n \n * More code motion.\n \n-Consider hoisting common code up past conditional branches or\n-tablejumps.\n+Consider hoisting common code up past conditional branches or tablejumps.\n+\n+Contact law@cygnus.com before working on code hoisting.\n \n * Trace scheduling.\n "}]}