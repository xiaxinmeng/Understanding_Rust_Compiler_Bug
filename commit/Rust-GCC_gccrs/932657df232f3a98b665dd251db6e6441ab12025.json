{"sha": "932657df232f3a98b665dd251db6e6441ab12025", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTMyNjU3ZGYyMzJmM2E5OGI2NjVkZDI1MWRiNmU2NDQxYWIxMjAyNQ==", "commit": {"author": {"name": "Stephane Carrez", "email": "Stephane.Carrez@worldnet.fr", "date": "2002-03-15T22:04:49Z"}, "committer": {"name": "Stephane Carrez", "email": "ciceron@gcc.gnu.org", "date": "2002-03-15T22:04:49Z"}, "message": "m68hc11.c (m68hc11_symbolic_p): New function.\n\n\t* config/m68hc11/m68hc11.c (m68hc11_symbolic_p): New function.\n\t(m68hc11_indirect_p): New function.\n\t(m68hc11_override_options): Must set MASK_NO_DIRECT_MODE for 68HC12.\n\t(m68hc11_gen_highpart): Use TARGET_NO_DIRECT_MODE instead of\n\tTARGET_M6812.\n\t(asm_print_register): Likewise.\n\t* config/m68hc11/m68hc11-protos.h (m68hc11_symbolic_p): Declare.\n\t(m68hc11_indirect_p): Declare.\n\t* config/m68hc11/m68hc11.h (EXTRA_CONSTRAINT): New constraint 'R', 'Q'.\n\t(TARGET_NO_DIRECT_MODE, TARGET_RELAX): New.\n\t(TARGET_SWITCHES): New option -mrelax.\n\t* config/m68hc11/m68hc11.md (\"andsi3\"): Allow soft register for\n\tdestination.\n\t(\"iorsi3\", \"xorsi3\"): Likewise.\n\t(\"andhi3\", \"andqi3\", \"iorhi3\", \"iorqi3\"): Use a define_expand.\n\t(\"*andhi3_mem\"): New to handle destination in memory with bclr\n\tand a scratch register.\n\t(\"*andqi3_mem\", \"*iorhi3_mem\", \"*iorqi3_mem\"): Likewise.\n\t(\"*andhi3_const\"): New when operand2 is constant.\n\t(\"*andqi3_const\", \"*iorhi3_const\", \"*iorqi3_const\"): Likewise.\n\t(\"*andhi3_gen\"): Cleanup of the old \"andhi3\".\n\t(\"*andqi3_gen\", \"*iorhi3_gen\", \"*iorqi3_gen\"): Likewise.\n\t(\"xorqi3\"): Update constraints.\n\nFrom-SVN: r50843", "tree": {"sha": "47617df8de8657579c5b7459a11542bac89bfe21", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/47617df8de8657579c5b7459a11542bac89bfe21"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/932657df232f3a98b665dd251db6e6441ab12025", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/932657df232f3a98b665dd251db6e6441ab12025", "html_url": "https://github.com/Rust-GCC/gccrs/commit/932657df232f3a98b665dd251db6e6441ab12025", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/932657df232f3a98b665dd251db6e6441ab12025/comments", "author": null, "committer": null, "parents": [{"sha": "60f32585da3a529a5a6e03e30c2184ae8abc0f94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60f32585da3a529a5a6e03e30c2184ae8abc0f94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60f32585da3a529a5a6e03e30c2184ae8abc0f94"}], "stats": {"total": 644, "additions": 484, "deletions": 160}, "files": [{"sha": "2aa5993c477355d3e536143c0a29818ea3c01ec4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/932657df232f3a98b665dd251db6e6441ab12025/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/932657df232f3a98b665dd251db6e6441ab12025/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=932657df232f3a98b665dd251db6e6441ab12025", "patch": "@@ -1,3 +1,29 @@\n+2002-03-15  Stephane Carrez  <Stephane.Carrez@worldnet.fr>\n+\n+\t* config/m68hc11/m68hc11.c (m68hc11_symbolic_p): New function.\n+\t(m68hc11_indirect_p): New function.\n+\t(m68hc11_override_options): Must set MASK_NO_DIRECT_MODE for 68HC12.\n+\t(m68hc11_gen_highpart): Use TARGET_NO_DIRECT_MODE instead of\n+\tTARGET_M6812.\n+\t(asm_print_register): Likewise.\n+\t* config/m68hc11/m68hc11-protos.h (m68hc11_symbolic_p): Declare.\n+\t(m68hc11_indirect_p): Declare.\n+\t* config/m68hc11/m68hc11.h (EXTRA_CONSTRAINT): New constraint 'R', 'Q'.\n+\t(TARGET_NO_DIRECT_MODE, TARGET_RELAX): New.\n+\t(TARGET_SWITCHES): New option -mrelax.\n+\t* config/m68hc11/m68hc11.md (\"andsi3\"): Allow soft register for\n+\tdestination.\n+\t(\"iorsi3\", \"xorsi3\"): Likewise.\n+\t(\"andhi3\", \"andqi3\", \"iorhi3\", \"iorqi3\"): Use a define_expand.\n+\t(\"*andhi3_mem\"): New to handle destination in memory with bclr\n+\tand a scratch register.\n+\t(\"*andqi3_mem\", \"*iorhi3_mem\", \"*iorqi3_mem\"): Likewise.\n+\t(\"*andhi3_const\"): New when operand2 is constant.\n+\t(\"*andqi3_const\", \"*iorhi3_const\", \"*iorqi3_const\"): Likewise.\n+\t(\"*andhi3_gen\"): Cleanup of the old \"andhi3\".\n+\t(\"*andqi3_gen\", \"*iorhi3_gen\", \"*iorqi3_gen\"): Likewise.\n+\t(\"xorqi3\"): Update constraints.\n+\n 2002-03-15  Stephane Carrez  <Stephane.Carrez@worldnet.fr>\n \n \t* config/m68hc11/m68hc11.c (m68hc11_small_indexed_indirect_p): Look"}, {"sha": "27358b7b62f4a9e3600edd8883ad345deda6a632", "filename": "gcc/config/m68hc11/m68hc11-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/932657df232f3a98b665dd251db6e6441ab12025/gcc%2Fconfig%2Fm68hc11%2Fm68hc11-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/932657df232f3a98b665dd251db6e6441ab12025/gcc%2Fconfig%2Fm68hc11%2Fm68hc11-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11-protos.h?ref=932657df232f3a98b665dd251db6e6441ab12025", "patch": "@@ -106,6 +106,8 @@ extern void m68hc11_emit_libcall PARAMS((const char*, enum rtx_code,\n                                          enum machine_mode, enum machine_mode,\n                                          int, rtx*));\n extern int m68hc11_small_indexed_indirect_p PARAMS((rtx, enum machine_mode));\n+extern int m68hc11_symbolic_p PARAMS((rtx, enum machine_mode));\n+extern int m68hc11_indirect_p PARAMS((rtx, enum machine_mode));\n extern int go_if_legitimate_address2 PARAMS((rtx, enum machine_mode, int));\n \n extern int reg_or_indexed_operand PARAMS((rtx,enum machine_mode));"}, {"sha": "041b596e2823d9bb18f8b5a4feb448ed66ca3f75", "filename": "gcc/config/m68hc11/m68hc11.c", "status": "modified", "additions": 41, "deletions": 3, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/932657df232f3a98b665dd251db6e6441ab12025/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/932657df232f3a98b665dd251db6e6441ab12025/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c?ref=932657df232f3a98b665dd251db6e6441ab12025", "patch": "@@ -276,6 +276,7 @@ m68hc11_override_options ()\n       m68hc11_sp_correction = 0;\n       m68hc11_tmp_regs_class = TMP_REGS;\n       target_flags &= ~MASK_M6811;\n+      target_flags |= MASK_NO_DIRECT_MODE;\n       if (m68hc11_soft_reg_count == 0)\n \tm68hc11_soft_reg_count = \"2\";\n     }\n@@ -926,6 +927,42 @@ reg_or_some_mem_operand (operand, mode)\n   return register_operand (operand, mode);\n }\n \n+int\n+m68hc11_symbolic_p (operand, mode)\n+     rtx operand;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (operand) == MEM)\n+    {\n+      rtx op = XEXP (operand, 0);\n+\n+      if (symbolic_memory_operand (op, mode))\n+\treturn 1;\n+    }\n+  return 0;\n+}\n+\n+int\n+m68hc11_indirect_p (operand, mode)\n+     rtx operand;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (operand) == MEM)\n+    {\n+      rtx op = XEXP (operand, 0);\n+\n+      if (symbolic_memory_operand (op, mode))\n+\treturn 0;\n+\n+      if (reload_in_progress)\n+        return 1;\n+\n+      operand = XEXP (operand, 0);\n+      return register_indirect_p (operand, mode, reload_completed);\n+    }\n+  return 0;\n+}\n+\n int\n stack_register_operand (operand, mode)\n      rtx operand;\n@@ -1950,8 +1987,9 @@ m68hc11_gen_highpart (mode, x)\n     {\n       int pos;\n \n-      /* For 68HC12, avoid the '*' for direct addressing mode.  */\n-      pos = TARGET_M6812 ? 1 : 0;\n+      /* Avoid the '*' for direct addressing mode when this\n+         addressing mode is disabled.  */\n+      pos = TARGET_NO_DIRECT_MODE ? 1 : 0;\n       return gen_rtx (MEM, QImode,\n \t\t      gen_rtx (SYMBOL_REF, Pmode,\n \t\t\t       &reg_names[REGNO (x)][pos]));\n@@ -2079,7 +2117,7 @@ asm_print_register (file, regno)\n {\n   const char *name = reg_names[regno];\n \n-  if (TARGET_M6812 && name[0] == '*')\n+  if (TARGET_NO_DIRECT_MODE && name[0] == '*')\n     name++;\n \n   asm_fprintf (file, \"%s\", name);"}, {"sha": "865e2ebd424ae98cfceb521e405afa70b9790c62", "filename": "gcc/config/m68hc11/m68hc11.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/932657df232f3a98b665dd251db6e6441ab12025/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/932657df232f3a98b665dd251db6e6441ab12025/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h?ref=932657df232f3a98b665dd251db6e6441ab12025", "patch": "@@ -118,12 +118,15 @@ extern short *reg_renumber;\t/* def in local_alloc.c */\n #define MASK_AUTO_INC_DEC       0004\n #define MASK_M6811              0010\n #define MASK_M6812              0020\n+#define MASK_NO_DIRECT_MODE     0040\n \n #define TARGET_OP_TIME\t\t(optimize && optimize_size == 0)\n #define TARGET_SHORT            (target_flags & MASK_SHORT)\n #define TARGET_M6811            (target_flags & MASK_M6811)\n #define TARGET_M6812            (target_flags & MASK_M6812)\n #define TARGET_AUTO_INC_DEC     (target_flags & MASK_AUTO_INC_DEC)\n+#define TARGET_NO_DIRECT_MODE   (target_flags & MASK_NO_DIRECT_MODE)\n+#define TARGET_RELAX            (TARGET_NO_DIRECT_MODE)\n \n /* Default target_flags if no switches specified.  */\n #ifndef TARGET_DEFAULT\n@@ -156,6 +159,8 @@ extern short *reg_renumber;\t/* def in local_alloc.c */\n     N_(\"Auto pre/post decrement increment allowed\")},\t\t\\\n   { \"noauto-incdec\", - MASK_AUTO_INC_DEC,\t\t\t\\\n     N_(\"Auto pre/post decrement increment not allowed\")},\t\\\n+  { \"relax\", MASK_NO_DIRECT_MODE,                               \\\n+    N_(\"Do not use direct addressing mode for soft registers\")},\\\n   { \"68hc11\", MASK_M6811,\t\t\t\t\t\\\n     N_(\"Compile for a 68HC11\")},\t\t\t\t\\\n   { \"68hc12\", MASK_M6812,\t\t\t\t\t\\\n@@ -830,7 +835,9 @@ extern enum reg_class m68hc11_tmp_regs_class;\n /* 'U' represents certain kind of memory indexed operand for 68HC12.\n    and any memory operand for 68HC11.  */\n #define EXTRA_CONSTRAINT(OP, C)                         \\\n-((C) == 'U' ? m68hc11_small_indexed_indirect_p (OP, GET_MODE (OP)) : 0)\n+((C) == 'U' ? m68hc11_small_indexed_indirect_p (OP, GET_MODE (OP)) \\\n+ : (C) == 'Q' ? m68hc11_symbolic_p (OP, GET_MODE (OP)) \\\n+ : (C) == 'R' ? m68hc11_indirect_p (OP, GET_MODE (OP)) : 0)\n \n \n \f"}, {"sha": "1871d47e6d2eb0122ad8223bb822603720114771", "filename": "gcc/config/m68hc11/m68hc11.md", "status": "modified", "additions": 407, "deletions": 156, "changes": 563, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/932657df232f3a98b665dd251db6e6441ab12025/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/932657df232f3a98b665dd251db6e6441ab12025/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.md?ref=932657df232f3a98b665dd251db6e6441ab12025", "patch": "@@ -65,9 +65,20 @@\n ;;\n ;; Other constraints:\n ;;\n-;; T    an operand that can be accessed with 68HC1X direct addressing\n-;;      mode.  For 68HC11 this includes the pseudo soft registers and\n-;;      any memory operand that is a direct addressing (.page0).\n+;; Q    an operand which is in memory but whose address is constant\n+;;      (ie, a (MEM (SYMBOL_REF x))).  This constraint is used by\n+;;      bset/bclr instructions together with linker relaxation.  The\n+;;      operand can be translated to a page0 addressing mode if the\n+;;      symbol address is in page0 (0..255).\n+;;\n+;; R    an operand which is in memory and whose address is expressed\n+;;      with 68HC11/68HC12 indexed addressing mode.  In general this\n+;;      is any valid (MEM) except a (MEM (SYMBOL_REF x)).\n+;;\n+;; U    an operand which is in memory and if it uses the 68HC12 indexed\n+;;      addressing mode, the offset is in the range -16..+15.  This is\n+;;      used by 68HC12 movb/movw instructions since they do not accept\n+;;      the full 16-bit offset range (as other insn do).\n ;;\n ;;\n ;; Immediate integer operand constraints:\n@@ -94,9 +105,9 @@\n ;;\t\tsome values in bad registers. \n ;;\n ;; 32/64-bit Patterns:\n-;;     The 68HC11 does not support 32/64-bit operations. Most of the\n+;;     The 68HC11 does not support 32/64-bit operations.  Most of the\n ;;     32/64-bit patterns are defined to split the instruction in\n-;;     16-bits patterns. Providing split patterns generates better code\n+;;     16-bits patterns.  Providing split patterns generates better code\n ;;     than letting GCC implement the 32/64-bit operation itself.\n ;;\n ;;\n@@ -111,7 +122,7 @@\n ;;   them correctly (it would treat the X, Y or D register as dead sometimes).\n ;;\n ;; o Some split pattern generate instructions that operate on 'a' or 'b'\n-;;   register directory (high part and low part of D respectively).\n+;;   register directly (high part and low part of D respectively).\n ;;   Such split pattern must also be valid when z_replacement_completed == 2\n ;;   because flow/cse is not aware that D is composed of {a, b}.\n ;;\n@@ -3027,138 +3038,242 @@\n   \"#\")\n \n (define_insn \"andsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=D\")\n-\t(and:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n-\t\t(match_operand:SI 2 \"general_operand\" \"Dimu\")))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"=D,!u\")\n+\t(and:SI (match_operand:SI 1 \"register_operand\" \"%0,0\")\n+\t\t(match_operand:SI 2 \"general_operand\" \"Dimu,imu\")))\n+   (clobber (match_scratch:HI 3 \"=X,d\"))]\n   \"\"\n   \"#\")\n \n-(define_insn \"andhi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=d,!u,d,!*A\")\n-\t(and:HI (match_operand:HI 1 \"register_operand\" \"%0,0,0,0\")\n-\t\t(match_operand:HI 2 \"general_operand\" \"i,i,!um*A,!ium*A\")))]\n+(define_expand \"andhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(and:HI (match_operand:HI 1 \"register_operand\" \"\")\n+\t\t(match_operand:HI 2 \"general_operand\" \"\")))]\n   \"\"\n+  \"\")\n+\n+(define_insn \"*andhi3_mem\"\n+  [(set (match_operand:HI 0 \"memory_operand\" \"=Q,R\")\n+\t(and:HI (match_dup 0)\n+\t        (match_operand:HI 1 \"immediate_operand\" \"i,i\")))\n+   (clobber (match_scratch:HI 2 \"=xy,X\"))]\n+  \"TARGET_RELAX && !TARGET_M6812\"\n   \"*\n {\n-  if (A_REG_P (operands[0]) || H_REG_P (operands[2]))\n-    return \\\"#\\\";\n+  int val = INTVAL (operands[1]) & 0x0FFFF;\n \n-  if (GET_CODE (operands[2]) == CONST_INT)\n+  if (val == 0x0ffff)\n     {\n-      int val = INTVAL (operands[2]) & 0x0FFFF;\n-      char lowpart_zero     = 0;\n-      char lowpart_unknown  = 0;\n-      char highpart_zero    = 0;\n-      char highpart_unknown = 0;\n+      cc_status = cc_prev_status;\n+      return \\\"\\\";\n+    }\n \n-      if (val == 0xFFFF)\n-\t{\n-\t  cc_status = cc_prev_status;\n-\t  return \\\"\\\";\n-\t}\n+  CC_STATUS_INIT;\n \n-      /* First, try to clear the low and high part.\n-\t If that's possible, the second 'and' will give\n-\t the good status flags and we can avoid a tsthi.  */\n-      if ((val & 0x0FF) == 0)\n-\t{\n-          if (D_REG_P (operands[0]))\n-\t    output_asm_insn (\\\"clrb\\\", operands);\n-\t  else\n-\t    output_asm_insn (\\\"clr\\\\t%b0\\\", operands);\n-\t  lowpart_zero = 1;\n-\t}\n-      if ((val & 0x0FF00) == 0)\n-\t{\n-\t  if (D_REG_P (operands[0]))\n-\t    output_asm_insn (\\\"clra\\\", operands);\n-\t  else\n-\t    output_asm_insn (\\\"clr\\\\t%h0\\\", operands);\n-\t  highpart_zero = 1;\n-\t}\n+  /* The bclr instruction uses an inverted mask.  */\n+  operands[1] = gen_rtx (CONST_INT, VOIDmode, (~val) & 0x0FFFF);\n \n-      if ((val & 0x0FF) == 0x0FF)\n-        {\n-\t  lowpart_unknown = 1;\n-        }\n-      else if ((val & 0x0FF) != 0 && !H_REG_P (operands[0]))\n-        {\n-\t  rtx ops[2];\n+  /* When destination is a global variable, generate a .relax instruction\n+     and load the address in the clobber register.  That load can be\n+     eliminated by the linker if the address is in page0.  */\n+  if (which_alternative == 0)\n+    {\n+      rtx ops[3];\n \n-\t  ops[0] = operands[0];\n-\t  ops[1] = gen_rtx (CONST_INT, VOIDmode, (~val) & 0x0FF);\n-          output_asm_insn (\\\"bclr\\\\t%b0, %1\\\", ops);\n-        }\n-      else if ((val & 0x0FF) != 0)\n-\t{\n-\t  output_asm_insn (\\\"andb\\\\t%b2\\\", operands);\n-\t}\n+      ops[0] = operands[2];\n+      ops[1] = XEXP (operands[0], 0);\n+      ops[2] = gen_label_rtx ();\n+      output_asm_insn (\\\".relax\\\\t%l2\\\", ops);\n+      m68hc11_gen_movhi (insn, ops);\n+      if ((val & 0x0FF) != 0x0FF)\n+        output_asm_insn (\\\"bclr\\\\t1,%2, %b1\\\", operands);\n \n-      if ((val & 0x0FF00) == 0x0FF00)\n-\t{\n-\t  highpart_unknown = 1;\n-\t}\n-      else if (((val & 0x0FF00) != 0) && !H_REG_P (operands[0]))\n-        {\n-\t  rtx ops[2];\n+      if ((val & 0x0FF00) != 0x0FF00)\n+        output_asm_insn (\\\"bclr\\\\t0,%2, %h1\\\", operands);\n \n-\t  ops[0] = operands[0];\n-\t  ops[1] = gen_rtx (CONST_INT, VOIDmode, ((~val) & 0x0FF00) >> 8);\n-          output_asm_insn (\\\"bclr\\\\t%h0, %1\\\", ops);\n-        }\n-      else if ((val & 0x0FF00) != 0)\n-\t{\n-\t  output_asm_insn (\\\"anda\\\\t%h2\\\", operands);\n-\t}\n+      ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \\\"L\\\",\n+\t\t\t\t CODE_LABEL_NUMBER (ops[2]));\n+      return \\\"\\\";\n+    }\n+\n+  if ((val & 0x0FF) != 0x0FF)\n+    output_asm_insn (\\\"bclr\\\\t%b0, %b1\\\", operands);\n+\n+  if ((val & 0x0FF00) != 0x0FF00)\n+    output_asm_insn (\\\"bclr\\\\t%h0, %h1\\\", operands);\n \n-      if (highpart_unknown || lowpart_unknown)\n-\t CC_STATUS_INIT;\n-      else if (highpart_zero == 0 && lowpart_zero == 0)\n-\t CC_STATUS_INIT;\n+  return \\\"\\\";\n+}\")\n+\n+(define_insn \"*andhi3_const\"\n+  [(set (match_operand:HI 0 \"reg_or_some_mem_operand\" \"=R,d,?*A\")\n+\t(and:HI (match_operand:HI 1 \"reg_or_some_mem_operand\" \"%0,0,0\")\n+\t        (match_operand:HI 2 \"const_int_operand\" \"\")))]\n+  \"\"\n+  \"*\n+{\n+  int val = INTVAL (operands[2]) & 0x0FFFF;\n+  int lowpart_zero = 0;\n+  int highpart_zero = 0;\n+  int lowpart_unknown = 0;\n+  int highpart_unknown = 0;\n+\n+  if (A_REG_P (operands[0]) || H_REG_P (operands[2]))\n+    return \\\"#\\\";\n \n+  if (val == 0x0ffff)\n+    {\n+      cc_status = cc_prev_status;\n       return \\\"\\\";\n     }\n \n+  /* First, try to clear the low and high part.\n+     If that's possible, the second 'and' will give\n+     the good status flags and we can avoid a tsthi.  */\n+  if ((val & 0x0FF) == 0)\n+    {\n+      if (D_REG_P (operands[0]))\n+\toutput_asm_insn (\\\"clrb\\\", operands);\n+      else\n+\toutput_asm_insn (\\\"clr\\\\t%b0\\\", operands);\n+      lowpart_zero = 1;\n+    }\n+  if ((val & 0x0FF00) == 0)\n+    {\n+      if (D_REG_P (operands[0]))\n+\toutput_asm_insn (\\\"clra\\\", operands);\n+      else\n+\toutput_asm_insn (\\\"clr\\\\t%h0\\\", operands);\n+      highpart_zero = 1;\n+    }\n+\n+  if ((val & 0x0FF) == 0x0FF)\n+    {\n+      lowpart_unknown = 1;\n+    }\n+  else if ((val & 0x0FF) != 0 && !H_REG_P (operands[0]))\n+    {\n+      rtx ops[2];\n+\n+      ops[0] = operands[0];\n+      ops[1] = gen_rtx (CONST_INT, VOIDmode, (~val) & 0x0FF);\n+      output_asm_insn (\\\"bclr\\\\t%b0, %1\\\", ops);\n+    }\n+  else if ((val & 0x0FF) != 0)\n+    {\n+      output_asm_insn (\\\"andb\\\\t%b2\\\", operands);\n+    }\n+\n+  if ((val & 0x0FF00) == 0x0FF00)\n+    {\n+      highpart_unknown = 1;\n+    }\n+  else if (((val & 0x0FF00) != 0) && !H_REG_P (operands[0]))\n+    {\n+      rtx ops[2];\n+\n+      ops[0] = operands[0];\n+      ops[1] = gen_rtx (CONST_INT, VOIDmode, ((~val) & 0x0FF00) >> 8);\n+      output_asm_insn (\\\"bclr\\\\t%h0, %1\\\", ops);\n+    }\n+  else if ((val & 0x0FF00) != 0)\n+    {\n+      output_asm_insn (\\\"anda\\\\t%h2\\\", operands);\n+    }\n+\n+  if (highpart_unknown || lowpart_unknown)\n+     CC_STATUS_INIT;\n+  else if (highpart_zero == 0 && lowpart_zero == 0)\n+     CC_STATUS_INIT;\n+\n+  return \\\"\\\";\n+}\")\n+\n+(define_insn \"*andhi3_gen\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=d,d,!*A\")\n+\t(and:HI (match_operand:HI 1 \"register_operand\" \"%0,0,0\")\n+\t\t(match_operand:HI 2 \"general_operand\" \"mi,!u*A,!um*A\")))]\n+  \"\"\n+  \"*\n+{\n+  if (A_REG_P (operands[0]) || H_REG_P (operands[2]))\n+    return \\\"#\\\";\n+\n   CC_STATUS_INIT;\n   return \\\"andb\\\\t%b2\\\\n\\\\tanda\\\\t%h2\\\";\n }\")\n \n-(define_insn \"andqi3\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=d,!u,d,d,?*A,?*A,!*q\")\n-        (and:QI (match_operand:QI 1 \"register_operand\" \"%0,0,0,0,0,0,0\")\n-             (match_operand:QI 2 \"general_operand\" \"i,i,!um,?*A,!ium,?*A*d,!ium*A\")))]\n+(define_expand \"andqi3\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n+        (and:QI (match_operand:QI 1 \"register_operand\" \"\")\n+                (match_operand:QI 2 \"general_operand\" \"\")))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"*andqi3_mem\"\n+  [(set (match_operand:QI 0 \"memory_operand\" \"=Q,R\")\n+\t(and:QI (match_dup 0)\n+\t        (match_operand:QI 1 \"const_int_operand\" \"i,i\")))\n+   (clobber (match_scratch:HI 2 \"=xy,X\"))]\n+  \"TARGET_RELAX && !TARGET_M6812\"\n+  \"*\n+{\n+  int val = INTVAL (operands[1]) & 0x0FF;\n+\n+  if (val == 0x0ff)\n+    {\n+      cc_status = cc_prev_status;\n+      return \\\"\\\";\n+    }\n+\n+  /* The bclr instruction uses an inverted mask.  */\n+  operands[1] = gen_rtx (CONST_INT, VOIDmode, (~val) & 0x0FF);\n+\n+  /* When destination is a global variable, generate a .relax instruction\n+     and load the address in the clobber register.  That load can be\n+     eliminated by the linker if the address is in page0.  */\n+  if (which_alternative == 0)\n+    {\n+      rtx ops[3];\n+\n+      ops[0] = operands[2];\n+      ops[1] = XEXP (operands[0], 0);\n+      ops[2] = gen_label_rtx ();\n+      output_asm_insn (\\\".relax\\\\t%l2\\\", ops);\n+      m68hc11_gen_movhi (insn, ops);\n+      output_asm_insn (\\\"bclr\\\\t0,%2, %1\\\", operands);\n+      ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \\\"L\\\",\n+\t\t\t\t CODE_LABEL_NUMBER (ops[2]));\n+      return \\\"\\\";\n+    }\n+  return \\\"bclr\\\\t%b0, %1\\\";\n+}\")\n+\n+(define_insn \"*andqi3_const\"\n+  [(set (match_operand:QI 0 \"reg_or_some_mem_operand\" \"=R,d,?*A*q\")\n+\t(and:QI (match_operand:QI 1 \"reg_or_some_mem_operand\" \"%0,0,0\")\n+\t        (match_operand:QI 2 \"const_int_operand\" \"\")))]\n   \"\"\n   \"*\n {\n+  int val = INTVAL (operands[2]) & 0x0FF;\n+\n   if (A_REG_P (operands[0]) || H_REG_P (operands[2]))\n     return \\\"#\\\";\n \n-  if (GET_CODE (operands[2]) == CONST_INT)\n+  if (val == 0x0ff)\n     {\n-      int val = INTVAL (operands[2]) & 0x0FF;\n+      cc_status = cc_prev_status;\n+      return \\\"\\\";\n+    }\n+  if (!H_REG_P (operands[0]))\n+    {\n+      rtx ops[2];\n \n-      if (val == 0xFF)\n-\t{\n-\t  cc_status = cc_prev_status;\n-\t  return \\\"\\\";\n-\t}\n-      if (val == 0)\n-\t{\n-          if (D_REG_P (operands[0]) || DB_REG_P (operands[0]))\n-\t    return \\\"clrb\\\";\n-\t  else if (DA_REG_P (operands[0]))\n-\t    return \\\"clra\\\";\n-\t  else\n-\t    return \\\"clr\\\\t%b0\\\";\n-\t}\n-      if (!H_REG_P (operands[0]))\n-        {\n-          rtx ops[2];\n-          ops[0] = operands[0];\n-          ops[1] = gen_rtx (CONST_INT, VOIDmode, (~val) & 0x0FF);\n-          output_asm_insn (\\\"bclr\\\\t%b0, %b1\\\", ops);\n-          return \\\"\\\";\n-        }\n+      ops[0] = operands[0];\n+      ops[1] = gen_rtx (CONST_INT, VOIDmode, (~val) & 0x0FF);\n+      output_asm_insn (\\\"bclr\\\\t%b0, %b1\\\", ops);\n+      return \\\"\\\";\n     }\n   if (D_REG_P (operands[0]) || DB_REG_P (operands[0]))\n     return \\\"andb\\\\t%b2\\\";\n@@ -3168,6 +3283,24 @@\n     fatal_insn (\\\"Invalid operand in the instruction\\\", insn);\n }\")\n \n+(define_insn \"*andqi3_gen\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=d,d,d,?*A,?*A,!*q\")\n+        (and:QI (match_operand:QI 1 \"register_operand\" \"%0,0,0,0,0,0\")\n+             (match_operand:QI 2 \"general_operand\" \"mi,!u,?*A,!um,?*A*d,!um*A\")))]\n+  \"\"\n+  \"*\n+{\n+  if (A_REG_P (operands[0]) || H_REG_P (operands[2]))\n+    return \\\"#\\\";\n+\n+  if (D_REG_P (operands[0]) || DB_REG_P (operands[0]))\n+    return \\\"andb\\\\t%b2\\\";\n+  else if (DA_REG_P (operands[0]))\n+    return \\\"anda\\\\t%b2\\\";\n+  else\n+    fatal_insn (\\\"Invalid operand in the instruction\\\", insn);\n+}\")\n+\n ;;--------------------------------------------------------------------\n ;;- Bit set or instructions.\n ;;--------------------------------------------------------------------\n@@ -3181,79 +3314,195 @@\n   \"#\")\n \n (define_insn \"iorsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=D\")\n-\t(ior:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n-\t\t(match_operand:SI 2 \"general_operand\" \"Dimu\")))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"=D,!u\")\n+\t(ior:SI (match_operand:SI 1 \"register_operand\" \"%0,0\")\n+\t\t(match_operand:SI 2 \"general_operand\" \"Dimu,imu\")))\n+   (clobber (match_scratch:HI 3 \"=X,d\"))]\n   \"\"\n   \"#\")\n \n-(define_insn \"iorhi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=d,!u,d,!*A\")\n-\t(ior:HI (match_operand:HI 1 \"register_operand\" \"%0,0,0,0\")\n-\t\t(match_operand:HI 2 \"general_operand\" \"i,i,!um*A,!ium*A\")))]\n+(define_expand \"iorhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(ior:HI (match_operand:HI 1 \"register_operand\" \"\")\n+\t\t(match_operand:HI 2 \"general_operand\" \"\")))]\n   \"\"\n+  \"\")\n+\n+(define_insn \"*iorhi3_mem\"\n+  [(set (match_operand:HI 0 \"memory_operand\" \"=Q,R\")\n+\t(ior:HI (match_dup 0)\n+\t        (match_operand:HI 1 \"const_int_operand\" \"\")))\n+   (clobber (match_scratch:HI 2 \"=xy,X\"))]\n+  \"TARGET_RELAX && !TARGET_M6812\"\n   \"*\n {\n-  if (A_REG_P (operands[0]) || H_REG_P (operands[2]))\n-    return \\\"#\\\";\n+  int val = INTVAL (operands[1]) & 0x0FFFF;\n \n-  if (GET_CODE (operands[2]) == CONST_INT)\n+  if (val == 0)\n     {\n-      int val = INTVAL (operands[2]) & 0x0FFFF;\n+      cc_status = cc_prev_status;\n+      return \\\"\\\";\n+    }\n+  CC_STATUS_INIT;\n+  if (which_alternative == 0)\n+    {\n+      rtx ops[3];\n \n-      if (val == 0)\n-\t{\n-\t  cc_status = cc_prev_status;\n-\t  return \\\"\\\";\n-\t}\n+      ops[0] = operands[2];\n+      ops[1] = XEXP (operands[0], 0);\n+      ops[2] = gen_label_rtx ();\n+      output_asm_insn (\\\".relax\\\\t%l2\\\", ops);\n+      m68hc11_gen_movhi (insn, ops);\n       if ((val & 0x0FF) != 0)\n-        {\n-          if (!H_REG_P (operands[0]))\n-            output_asm_insn (\\\"bset\\\\t%b0, %b2\\\", operands);\n-          else\n-\t    output_asm_insn (\\\"orab\\\\t%b2\\\", operands);\n-\t}\n+        output_asm_insn (\\\"bset\\\\t1,%2, %b1\\\", operands);\n \n       if ((val & 0x0FF00) != 0)\n-        {\n-          if (!H_REG_P (operands[0]))\n-            output_asm_insn (\\\"bset\\\\t%h0, %h2\\\", operands);\n-          else\n-\t    output_asm_insn (\\\"oraa\\\\t%h2\\\", operands);\n-\t}\n+        output_asm_insn (\\\"bset\\\\t0,%2, %h1\\\", operands);\n+      ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \\\"L\\\",\n+\t\t\t\t CODE_LABEL_NUMBER (ops[2]));\n+      return \\\"\\\";\n+    }\n \n-      CC_STATUS_INIT;\n+  if ((val & 0x0FF) != 0)\n+    output_asm_insn (\\\"bset\\\\t%b0, %b1\\\", operands);\n+\n+  if ((val & 0x0FF00) != 0)\n+    output_asm_insn (\\\"bset\\\\t%h0, %h1\\\", operands);\n+\n+  return \\\"\\\";\n+}\")\n+\n+(define_insn \"*iorhi3_const\"\n+  [(set (match_operand:HI 0 \"reg_or_some_mem_operand\" \"=R,d,?*A\")\n+\t(ior:HI (match_operand:HI 1 \"reg_or_some_mem_operand\" \"%0,0,0\")\n+\t\t(match_operand:HI 2 \"const_int_operand\" \"\")))]\n+  \"\"\n+  \"*\n+{\n+  int val = INTVAL (operands[2]) & 0x0FFFF;\n+\n+  if (A_REG_P (operands[0]) || H_REG_P (operands[2]))\n+    return \\\"#\\\";\n+\n+  if (val == 0)\n+    {\n+      cc_status = cc_prev_status;\n       return \\\"\\\";\n     }\n \n+  if ((val & 0x0FF) != 0)\n+    {\n+      if (!H_REG_P (operands[0]))\n+        output_asm_insn (\\\"bset\\\\t%b0, %b2\\\", operands);\n+      else\n+\toutput_asm_insn (\\\"orab\\\\t%b2\\\", operands);\n+    }\n+\n+  if ((val & 0x0FF00) != 0)\n+    {\n+      if (!H_REG_P (operands[0]))\n+         output_asm_insn (\\\"bset\\\\t%h0, %h2\\\", operands);\n+      else\n+\t output_asm_insn (\\\"oraa\\\\t%h2\\\", operands);\n+    }\n+\n   CC_STATUS_INIT;\n-  return \\\"orab\\\\t%b2\\\\n\\\\toraa\\\\t%h2\\\";\n+  return \\\"\\\";\n }\")\n \n-(define_insn \"iorqi3\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=d,!u,d,d,?*A,?*A,!*q\")\n-\t(ior:QI (match_operand:QI 1 \"register_operand\" \"%0,0,0,0,0,0,0\")\n-\t     (match_operand:QI 2 \"general_operand\" \"i,i,!um,!*A,!ium,?*A*d,!ium*A\")))]\n+(define_insn \"*iorhi3_gen\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=d,d,!*A\")\n+\t(ior:HI (match_operand:HI 1 \"register_operand\" \"%0,0,0\")\n+\t\t(match_operand:HI 2 \"general_operand\" \"mi,!u*A,!um*A\")))]\n   \"\"\n   \"*\n {\n   if (A_REG_P (operands[0]) || H_REG_P (operands[2]))\n     return \\\"#\\\";\n \n-  if (GET_CODE (operands[2]) == CONST_INT)\n+  CC_STATUS_INIT;\n+  return \\\"orab\\\\t%b2\\\\n\\\\toraa\\\\t%h2\\\";\n+}\")\n+\n+(define_expand \"iorqi3\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n+\t(ior:QI (match_operand:QI 1 \"register_operand\" \"\")\n+\t        (match_operand:QI 2 \"general_operand\" \"\")))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"*iorqi3_mem\"\n+  [(set (match_operand:QI 0 \"memory_operand\" \"=Q,R\")\n+\t(ior:QI (match_dup 0)\n+\t        (match_operand:QI 1 \"const_int_operand\" \"\")))\n+   (clobber (match_scratch:HI 2 \"=xy,X\"))]\n+  \"TARGET_RELAX && !TARGET_M6812\"\n+  \"*\n+{\n+  int val = INTVAL (operands[1]) & 0x0FF;\n+\n+  if (val == 0)\n     {\n-      int val = INTVAL (operands[2]) & 0x0FF;\n+      cc_status = cc_prev_status;\n+      return \\\"\\\";\n+    }\n+  if (which_alternative == 0)\n+    {\n+      rtx ops[3];\n \n-      if (val == 0)\n-\t{\n-\t  cc_status = cc_prev_status;\n-\t  return \\\"\\\";\n-\t}\n-      if (!H_REG_P (operands[0]))\n-        {\n-          return \\\"bset\\\\t%b0, %2\\\";\n-        }\n+      ops[0] = operands[2];\n+      ops[1] = XEXP (operands[0], 0);\n+      ops[2] = gen_label_rtx ();\n+      output_asm_insn (\\\".relax\\\\t%l2\\\", ops);\n+      m68hc11_gen_movhi (insn, ops);\n+      output_asm_insn (\\\"bset\\\\t0,%2, %1\\\", operands);\n+      ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \\\"L\\\",\n+\t\t\t\t CODE_LABEL_NUMBER (ops[2]));\n+      return \\\"\\\";\n+    }\n+  return \\\"bset\\\\t%b0, %1\\\";\n+}\")\n+\n+(define_insn \"*iorqi3_const\"\n+  [(set (match_operand:QI 0 \"reg_or_some_mem_operand\" \"=R,d,?*A*q\")\n+\t(ior:QI (match_operand:QI 1 \"reg_or_some_mem_operand\" \"%0,0,0\")\n+\t\t(match_operand:QI 2 \"const_int_operand\" \"\")))]\n+  \"\"\n+  \"*\n+{\n+  int val = INTVAL (operands[2]) & 0x0FF;\n+\n+  if (A_REG_P (operands[0]) || H_REG_P (operands[2]))\n+    return \\\"#\\\";\n+\n+  if (val == 0)\n+    {\n+      cc_status = cc_prev_status;\n+      return \\\"\\\";\n+    }\n+  if (!H_REG_P (operands[0]))\n+    {\n+      return \\\"bset\\\\t%b0, %2\\\";\n     }\n+\n+  if (D_REG_P (operands[0]) || DB_REG_P (operands[0]))\n+    return \\\"orab\\\\t%b2\\\";\n+  else if (DA_REG_P (operands[0]))\n+    return \\\"oraa\\\\t%b2\\\";\n+  else\n+    fatal_insn (\\\"Invalid operand in the instruction\\\", insn);\n+}\")\n+\n+(define_insn \"*iorqi3_gen\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=d,d,d,?*A,?*A,!*q\")\n+\t(ior:QI (match_operand:QI 1 \"register_operand\" \"%0,0,0,0,0,0\")\n+\t     (match_operand:QI 2 \"general_operand\" \"mi,!u,!*A,!um,?*A*d,!um*A\")))]\n+  \"\"\n+  \"*\n+{\n+  if (A_REG_P (operands[0]) || H_REG_P (operands[2]))\n+    return \\\"#\\\";\n+\n   if (D_REG_P (operands[0]) || DB_REG_P (operands[0]))\n     return \\\"orab\\\\t%b2\\\";\n   else if (DA_REG_P (operands[0]))\n@@ -3262,6 +3511,7 @@\n     fatal_insn (\\\"Invalid operand in the instruction\\\", insn);\n }\")\n \n+\n ;;--------------------------------------------------------------------\n ;;- xor instructions.\n ;;--------------------------------------------------------------------\n@@ -3275,9 +3525,10 @@\n   \"#\")\n \n (define_insn \"xorsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=D\")\n-\t(xor:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n-\t\t(match_operand:SI 2 \"general_operand\" \"Dimu\")))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"=D,!u\")\n+\t(xor:SI (match_operand:SI 1 \"register_operand\" \"%0,0\")\n+\t\t(match_operand:SI 2 \"general_operand\" \"Dimu,imu\")))\n+   (clobber (match_scratch:HI 3 \"=X,d\"))]\n   \"\"\n   \"#\")\n \n@@ -3329,7 +3580,7 @@\n (define_insn \"xorqi3\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=d,d,d,?*A,?*A,!*q\")\n         (xor:QI (match_operand:QI 1 \"register_operand\" \"%0,0,0,0,0,0\")\n-             (match_operand:QI 2 \"general_operand\" \"i,!um,!*A,!ium,?*A*d,!ium*A\")))]\n+             (match_operand:QI 2 \"general_operand\" \"im,!u,!*A,!ium,?*A*d,!ium*A\")))]\n   \"\"\n   \"*\n {"}]}