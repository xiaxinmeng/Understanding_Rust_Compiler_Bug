{"sha": "e8e0acbaa38ed57b4cbf9e60556f78a059ba2c0b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZThlMGFjYmFhMzhlZDU3YjRjYmY5ZTYwNTU2Zjc4YTA1OWJhMmMwYg==", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-03-31T16:18:32Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-03-31T17:03:04Z"}, "message": "d: Use memset to fill alignment holes with zeroes.\n\nThis patch removes the manual insertion of padding for fields in\nconstructed struct literals, and instead uses memset() on the\ndeclaration being initialized.\n\nWhen compiling optimized builds, the intent is usually missed, and\nalignment holes end up with non-zero values in them anyway.\n\ngcc/d/ChangeLog:\n\n\tPR d/94424\n\t* d-codegen.cc (build_alignment_field): Remove.\n\t(build_struct_literal): Don't insert alignment padding.\n\t* expr.cc (ExprVisitor::visit (AssignExp *)): Call memset before\n\tassigning struct literals.\n\ngcc/testsuite/ChangeLog:\n\n\tPR d/94424\n\t* gdc.dg/pr94424.d: New test.", "tree": {"sha": "2b0a1176388e6ba4d442efc370ed2e919ce95eb9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2b0a1176388e6ba4d442efc370ed2e919ce95eb9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e8e0acbaa38ed57b4cbf9e60556f78a059ba2c0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8e0acbaa38ed57b4cbf9e60556f78a059ba2c0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8e0acbaa38ed57b4cbf9e60556f78a059ba2c0b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8e0acbaa38ed57b4cbf9e60556f78a059ba2c0b/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f14b41d27124601284347a10d496362c8b4b8e1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f14b41d27124601284347a10d496362c8b4b8e1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f14b41d27124601284347a10d496362c8b4b8e1c"}], "stats": {"total": 96, "additions": 49, "deletions": 47}, "files": [{"sha": "9a3fbfa7c561ba06a6791d099328a5e6fa25707f", "filename": "gcc/d/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8e0acbaa38ed57b4cbf9e60556f78a059ba2c0b/gcc%2Fd%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8e0acbaa38ed57b4cbf9e60556f78a059ba2c0b/gcc%2Fd%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2FChangeLog?ref=e8e0acbaa38ed57b4cbf9e60556f78a059ba2c0b", "patch": "@@ -1,3 +1,11 @@\n+2020-03-31  Iain Buclaw  <ibuclaw@gdcproject.org>\n+\n+\tPR d/94424\n+\t* d-codegen.cc (build_alignment_field): Remove.\n+\t(build_struct_literal): Don't insert alignment padding.\n+\t* expr.cc (ExprVisitor::visit (AssignExp *)): Call memset before\n+\tassigning struct literals.\n+\n 2020-03-31  Iain Buclaw  <ibuclaw@gdcproject.org>\n \n \t* typeinfo.cc (TypeInfoVisitor::internal_reference): Call"}, {"sha": "66af2b4da308a59da95768f28a97ff15a7952674", "filename": "gcc/d/d-codegen.cc", "status": "modified", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8e0acbaa38ed57b4cbf9e60556f78a059ba2c0b/gcc%2Fd%2Fd-codegen.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8e0acbaa38ed57b4cbf9e60556f78a059ba2c0b/gcc%2Fd%2Fd-codegen.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-codegen.cc?ref=e8e0acbaa38ed57b4cbf9e60556f78a059ba2c0b", "patch": "@@ -1076,26 +1076,6 @@ build_array_struct_comparison (tree_code code, StructDeclaration *sd,\n   return compound_expr (body, result);\n }\n \n-/* Create an anonymous field of type ubyte[T] at OFFSET to fill\n-   the alignment hole between OFFSET and FIELDPOS.  */\n-\n-static tree\n-build_alignment_field (tree type, HOST_WIDE_INT offset, HOST_WIDE_INT fieldpos)\n-{\n-  tree atype = make_array_type (Type::tuns8, fieldpos - offset);\n-  tree field = create_field_decl (atype, NULL, 1, 1);\n-\n-  SET_DECL_OFFSET_ALIGN (field, TYPE_ALIGN (atype));\n-  DECL_FIELD_OFFSET (field) = size_int (offset);\n-  DECL_FIELD_BIT_OFFSET (field) = bitsize_zero_node;\n-  DECL_FIELD_CONTEXT (field) = type;\n-  DECL_PADDING_P (field) = 1;\n-\n-  layout_decl (field, 0);\n-\n-  return field;\n-}\n-\n /* Build a constructor for a variable of aggregate type TYPE using the\n    initializer INIT, an ordered flat list of fields and values provided\n    by the frontend.  The returned constructor should be a value that\n@@ -1111,14 +1091,8 @@ build_struct_literal (tree type, vec<constructor_elt, va_gc> *init)\n   vec<constructor_elt, va_gc> *ve = NULL;\n   HOST_WIDE_INT offset = 0;\n   bool constant_p = true;\n-  bool fillholes = true;\n   bool finished = false;\n \n-  /* Filling alignment holes this only applies to structs.  */\n-  if (TREE_CODE (type) != RECORD_TYPE\n-      || CLASS_TYPE_P (type) || TYPE_PACKED (type))\n-    fillholes = false;\n-\n   /* Walk through each field, matching our initializer list.  */\n   for (tree field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n     {\n@@ -1163,15 +1137,6 @@ build_struct_literal (tree type, vec<constructor_elt, va_gc> *init)\n \t  HOST_WIDE_INT fieldpos = int_byte_position (field);\n \t  gcc_assert (value != NULL_TREE);\n \n-\t  /* Insert anonymous fields in the constructor for padding out\n-\t     alignment holes in-place between fields.  */\n-\t  if (fillholes && offset < fieldpos)\n-\t    {\n-\t      tree pfield = build_alignment_field (type, offset, fieldpos);\n-\t      tree pvalue = build_zero_cst (TREE_TYPE (pfield));\n-\t      CONSTRUCTOR_APPEND_ELT (ve, pfield, pvalue);\n-\t    }\n-\n \t  /* Must not initialize fields that overlap.  */\n \t  if (fieldpos < offset)\n \t    {\n@@ -1214,15 +1179,6 @@ build_struct_literal (tree type, vec<constructor_elt, va_gc> *init)\n \tbreak;\n     }\n \n-  /* Finally pad out the end of the record.  */\n-  if (fillholes && offset < int_size_in_bytes (type))\n-    {\n-      tree pfield = build_alignment_field (type, offset,\n-\t\t\t\t\t   int_size_in_bytes (type));\n-      tree pvalue = build_zero_cst (TREE_TYPE (pfield));\n-      CONSTRUCTOR_APPEND_ELT (ve, pfield, pvalue);\n-    }\n-\n   /* Ensure that we have consumed all values.  */\n   gcc_assert (vec_safe_is_empty (init) || ANON_AGGR_TYPE_P (type));\n "}, {"sha": "0ed50ee2d9e9120dfa8f991b290490a6240f3537", "filename": "gcc/d/expr.cc", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8e0acbaa38ed57b4cbf9e60556f78a059ba2c0b/gcc%2Fd%2Fexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8e0acbaa38ed57b4cbf9e60556f78a059ba2c0b/gcc%2Fd%2Fexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fexpr.cc?ref=e8e0acbaa38ed57b4cbf9e60556f78a059ba2c0b", "patch": "@@ -1054,14 +1054,13 @@ class ExprVisitor : public Visitor\n \ttree t1 = build_expr (e->e1);\n \ttree t2 = convert_for_assignment (build_expr (e->e2),\n \t\t\t\t\t  e->e2->type, e->e1->type);\n+\tStructDeclaration *sd = ((TypeStruct *) tb1)->sym;\n \n \t/* Look for struct = 0.  */\n \tif (e->e2->op == TOKint64)\n \t  {\n \t    /* Use memset to fill struct.  */\n \t    gcc_assert (e->op == TOKblit);\n-\t    StructDeclaration *sd = ((TypeStruct *) tb1)->sym;\n-\n \t    tree tmemset = builtin_decl_explicit (BUILT_IN_MEMSET);\n \t    tree result = build_call_expr (tmemset, 3, build_address (t1),\n \t\t\t\t\t   t2, size_int (sd->structsize));\n@@ -1079,7 +1078,22 @@ class ExprVisitor : public Visitor\n \t    this->result_ = compound_expr (result, t1);\n \t  }\n \telse\n-\t  this->result_ = build_assign (modifycode, t1, t2);\n+\t  {\n+\t    /* Simple struct literal assignment.  */\n+\t    tree init = NULL_TREE;\n+\n+\t    /* Fill any alignment holes in the struct using memset.  */\n+\t    if (e->op == TOKconstruct && !identity_compare_p (sd))\n+\t      {\n+\t\ttree tmemset = builtin_decl_explicit (BUILT_IN_MEMSET);\n+\t\tinit = build_call_expr (tmemset, 3, build_address (t1),\n+\t\t\t\t\tinteger_zero_node,\n+\t\t\t\t\tsize_int (sd->structsize));\n+\t      }\n+\n+\t    tree result = build_assign (modifycode, t1, t2);\n+\t    this->result_ = compound_expr (init, result);\n+\t  }\n \n \treturn;\n       }"}, {"sha": "008acc6e231735117a54ae3b6806d26576498b11", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8e0acbaa38ed57b4cbf9e60556f78a059ba2c0b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8e0acbaa38ed57b4cbf9e60556f78a059ba2c0b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e8e0acbaa38ed57b4cbf9e60556f78a059ba2c0b", "patch": "@@ -1,3 +1,8 @@\n+2020-03-31  Iain Buclaw  <ibuclaw@gdcproject.org>\n+\n+\tPR d/94424\n+\t* gdc.dg/pr94424.d: New test.\n+\n 2020-03-31  Felix Yang  <felix.yang@huawei.com>\n \n \tPR tree-optimization/94398"}, {"sha": "b9f9fac89571dccef62d10465f240a6d8b6847ef", "filename": "gcc/testsuite/gdc.dg/pr94424.d", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8e0acbaa38ed57b4cbf9e60556f78a059ba2c0b/gcc%2Ftestsuite%2Fgdc.dg%2Fpr94424.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8e0acbaa38ed57b4cbf9e60556f78a059ba2c0b/gcc%2Ftestsuite%2Fgdc.dg%2Fpr94424.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fpr94424.d?ref=e8e0acbaa38ed57b4cbf9e60556f78a059ba2c0b", "patch": "@@ -0,0 +1,19 @@\n+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=94424\n+// { dg-additional-options \"-fmain -funittest\" }\n+// { dg-do run { target hw } }\n+// { dg-skip-if \"needs gcc/config.d\" { ! d_runtime } }\n+@safe unittest\n+{\n+    struct C\n+    {\n+        ubyte i;\n+        this(ubyte i) { this.i = i; }\n+    }\n+\n+    auto c1 = C(1);\n+    auto c2 = C(2);\n+\n+    assert(__cmp([c1, c1][], [c2, c2][]) < 0);\n+    assert(__cmp([c2, c2], [c1, c1]) > 0);\n+    assert(__cmp([c2, c2], [c2, c1]) > 0);\n+}"}]}