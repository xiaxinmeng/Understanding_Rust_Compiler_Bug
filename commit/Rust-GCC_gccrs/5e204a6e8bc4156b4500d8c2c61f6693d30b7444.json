{"sha": "5e204a6e8bc4156b4500d8c2c61f6693d30b7444", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWUyMDRhNmU4YmM0MTU2YjQ1MDBkOGMyYzYxZjY2OTNkMzBiNzQ0NA==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2012-07-03T22:26:23Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2012-07-03T22:26:23Z"}, "message": "predicates.md (logical_and_operand): New predicate.\n\n\t* config/sh/predicates.md (logical_and_operand): New predicate.\n\t* config/sh/constraints.md (Jmb, Jmw): New constraints.\n\t* config/sh/sh.md (andsi3): Move expander above insns.  Add handling\n\tof 0xFFFF constant.  Use logical_and_operand predicate and\n\tsatisfies_constraint_Jmb, satisfies_constraint_Jmw.\n\t(*andsi3_compact): Make it an insn_and_split.  Use\n\tlogical_and_operand predicate.  Add Jmb,Jmw alternatives.\n\nFrom-SVN: r189241", "tree": {"sha": "1cff334f75f67c52c224b42160692031f21c5157", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1cff334f75f67c52c224b42160692031f21c5157"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e204a6e8bc4156b4500d8c2c61f6693d30b7444", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e204a6e8bc4156b4500d8c2c61f6693d30b7444", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e204a6e8bc4156b4500d8c2c61f6693d30b7444", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e204a6e8bc4156b4500d8c2c61f6693d30b7444/comments", "author": null, "committer": null, "parents": [{"sha": "c128d2031e725201c1529564388b3bfb84872e35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c128d2031e725201c1529564388b3bfb84872e35", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c128d2031e725201c1529564388b3bfb84872e35"}], "stats": {"total": 108, "additions": 85, "deletions": 23}, "files": [{"sha": "f161d63f41dd69980181fd3aca95e64be9d3eeba", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e204a6e8bc4156b4500d8c2c61f6693d30b7444/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e204a6e8bc4156b4500d8c2c61f6693d30b7444/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5e204a6e8bc4156b4500d8c2c61f6693d30b7444", "patch": "@@ -1,3 +1,13 @@\n+2012-07-03  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\t* config/sh/predicates.md (logical_and_operand): New predicate.\n+\t* config/sh/constraints.md (Jmb, Jmw): New constraints.\n+\t* config/sh/sh.md (andsi3): Move expander above insns.  Add handling\n+\tof 0xFFFF constant.  Use logical_and_operand predicate and\n+\tsatisfies_constraint_Jmb, satisfies_constraint_Jmw.\n+\t(*andsi3_compact): Make it an insn_and_split.  Use\n+\tlogical_and_operand predicate.  Add Jmb,Jmw alternatives.\n+\n 2012-07-03  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/53826"}, {"sha": "8642ea808a73b4334f48f3ad878a4c5f6a4ec9e7", "filename": "gcc/config/sh/constraints.md", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e204a6e8bc4156b4500d8c2c61f6693d30b7444/gcc%2Fconfig%2Fsh%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e204a6e8bc4156b4500d8c2c61f6693d30b7444/gcc%2Fconfig%2Fsh%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fconstraints.md?ref=5e204a6e8bc4156b4500d8c2c61f6693d30b7444", "patch": "@@ -31,6 +31,8 @@\n ;; IJKLMNOP: CONT_INT constants\n ;;  Ixx: signed xx bit\n ;;  J16: 0xffffffff00000000 | 0x00000000ffffffff\n+;;  Jmb: 0x000000FF\n+;;  Jmw: 0x0000FFFF\n ;;  Kxx: unsigned xx bit\n ;;  M: 1\n ;;  N: 0\n@@ -135,6 +137,16 @@\n   (and (match_code \"const_int\")\n        (match_test \"CONST_OK_FOR_J16 (ival)\")))\n \n+(define_constraint \"Jmb\"\n+  \"Low byte mask constant 0x000000FF\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival == 0xFF\")))\n+\n+(define_constraint \"Jmw\"\n+  \"Low word mask constant 0x0000FFFF\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival == 0xFFFF\")))\n+\n (define_constraint \"K03\"\n   \"An unsigned 3-bit constant, as used in SH2A bclr, bset, etc.\"\n   (and (match_code \"const_int\")"}, {"sha": "3e7efd3504483d7a156a2b93c71f8087564fe72d", "filename": "gcc/config/sh/predicates.md", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e204a6e8bc4156b4500d8c2c61f6693d30b7444/gcc%2Fconfig%2Fsh%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e204a6e8bc4156b4500d8c2c61f6693d30b7444/gcc%2Fconfig%2Fsh%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fpredicates.md?ref=5e204a6e8bc4156b4500d8c2c61f6693d30b7444", "patch": "@@ -574,6 +574,21 @@\n   return 0;\n })\n \n+;; Like logical_operand but allows additional constant values which can be\n+;; done with zero extensions.  Used for the second operand of and insns.\n+(define_predicate \"logical_and_operand\"\n+  (match_code \"subreg,reg,const_int\")\n+{\n+  if (logical_operand (op, mode))\n+    return 1;\n+\n+  if (! TARGET_SHMEDIA\n+      && (satisfies_constraint_Jmb (op) || satisfies_constraint_Jmw (op)))\n+    return 1;\n+\n+  return 0;\n+})\n+\n ;; TODO: Add a comment here.\n \n (define_predicate \"logical_operator\""}, {"sha": "1dda1943cba7065f3193e2c1397cec57e694f232", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 48, "deletions": 23, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e204a6e8bc4156b4500d8c2c61f6693d30b7444/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e204a6e8bc4156b4500d8c2c61f6693d30b7444/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=5e204a6e8bc4156b4500d8c2c61f6693d30b7444", "patch": "@@ -3113,12 +3113,55 @@ label:\n ;; Logical operations\n ;; -------------------------------------------------------------------------\n \n-(define_insn \"*andsi3_compact\"\n-  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=z,r\")\n-\t(and:SI (match_operand:SI 1 \"arith_reg_operand\" \"%0,0\")\n-\t\t(match_operand:SI 2 \"logical_operand\" \"K08,r\")))]\n+(define_expand \"andsi3\"\n+  [(set (match_operand:SI 0 \"arith_reg_operand\" \"\")\n+\t(and:SI (match_operand:SI 1 \"logical_reg_operand\" \"\")\n+\t\t(match_operand:SI 2 \"logical_and_operand\" \"\")))]\n+  \"\"\n+{\n+  /* If it is possible to turn the and insn into a zero extension\n+     already, redundant zero extensions will be folded, which results\n+     in better code.  \n+     Ideally the splitter of *andsi_compact would be enough, if reundant\n+     zero extensions were detected after the combine pass, which does not\n+     happen at the moment.  */\n+  if (TARGET_SH1)\n+    {\n+      if (satisfies_constraint_Jmb (operands[2]))\n+\t{\n+\t  emit_insn (gen_zero_extendqisi2 (operands[0],\n+\t\t\t\t\t   gen_lowpart (QImode, operands[1])));\n+\t  DONE;\n+\t}\n+      else if (satisfies_constraint_Jmw (operands[2]))\n+\t{\n+\t  emit_insn (gen_zero_extendhisi2 (operands[0],\n+\t\t\t\t\t   gen_lowpart (HImode, operands[1])));\n+\t  DONE;\n+\t}\n+    }\n+})\n+\n+(define_insn_and_split \"*andsi_compact\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r,r,z,r\")\n+\t(and:SI (match_operand:SI 1 \"arith_reg_operand\" \"%r,r,0,0\")\n+\t\t(match_operand:SI 2 \"logical_and_operand\" \"Jmb,Jmw,K08,r\")))]\n   \"TARGET_SH1\"\n-  \"and\t%2,%0\"\n+  \"@\n+\textu.b\t%1,%0\n+\textu.w\t%1,%0\n+\tand\t%2,%0\n+\tand\t%2,%0\"\n+  \"&& 1\"\n+ [(set (match_dup 0) (zero_extend:SI (match_dup 1)))]\n+{\n+  if (satisfies_constraint_Jmb (operands[2]))\n+    operands[1] = gen_lowpart (QImode, operands[1]);\n+  else if (satisfies_constraint_Jmw (operands[2]))\n+    operands[1] = gen_lowpart (HImode, operands[1]);\n+  else\n+    FAIL;\n+}\n   [(set_attr \"type\" \"arith\")])\n \n (define_insn \"*andsi3_media\"\n@@ -3139,24 +3182,6 @@ label:\n   \"bclr\\\\t%W2,%0\"\n   [(set_attr \"type\" \"arith\")])\n \n-;; If the constant is 255, then emit an extu.b instruction instead of an\n-;; and, since that will give better code.\n-\n-(define_expand \"andsi3\"\n-  [(set (match_operand:SI 0 \"arith_reg_operand\" \"\")\n-\t(and:SI (match_operand:SI 1 \"logical_reg_operand\" \"\")\n-\t\t(match_operand:SI 2 \"logical_operand\" \"\")))]\n-  \"\"\n-{\n-  if (TARGET_SH1\n-      && CONST_INT_P (operands[2]) && INTVAL (operands[2]) == 255)\n-    {\n-      emit_insn (gen_zero_extendqisi2 (operands[0],\n-\t\t\t\t       gen_lowpart (QImode, operands[1])));\n-      DONE;\n-    }\n-})\n-\n (define_insn_and_split \"anddi3\"\n   [(set (match_operand:DI 0 \"arith_reg_dest\" \"=r,r,r\")\n \t(and:DI (match_operand:DI 1 \"arith_reg_operand\" \"%r,r,r\")"}]}