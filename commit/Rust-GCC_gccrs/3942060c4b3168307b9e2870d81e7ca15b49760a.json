{"sha": "3942060c4b3168307b9e2870d81e7ca15b49760a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzk0MjA2MGM0YjMxNjgzMDdiOWUyODcwZDgxZTdjYTE1YjQ5NzYwYQ==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2020-04-21T16:59:24Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2020-04-21T17:11:06Z"}, "message": "PR middle-end/94647 - bogus -Warray-bounds on strncpy into a larger member array from a smaller array\n\ngcc/ChangeLog:\n\n\tPR middle-end/94647\n\t* gimple-ssa-warn-restrict.c (builtin_access::builtin_access): Correct\n\tthe computation of the lower bound of the source access size.\n\t(builtin_access::generic_overlap): Remove a hack for setting ranges\n\tof overlap offsets.\n\ngcc/testsuite/ChangeLog:\n\n\tPR middle-end/94647\n\t* c-c++-common/Warray-bounds-2.c: Adjust a test case and add a new one.\n\t* c-c++-common/Warray-bounds-3.c: Add tests for missing warnings.\n\t* c-c++-common/Wrestrict.c: Invert bounds in printed ranges.\n\t* gcc.dg/Warray-bounds-59.c: New test.\n\t* gcc.dg/Wrestrict-10.c: Add a missing warning.\n\t* gcc.dg/Wrestrict-5.c: Adjust text of expected warning.\n\t* gcc.dg/Wrestrict-6.c: Expect to see a range of overlap offsets.", "tree": {"sha": "63775e1c15a45fc845647576c47d8e22cd3a4620", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/63775e1c15a45fc845647576c47d8e22cd3a4620"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3942060c4b3168307b9e2870d81e7ca15b49760a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3942060c4b3168307b9e2870d81e7ca15b49760a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3942060c4b3168307b9e2870d81e7ca15b49760a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3942060c4b3168307b9e2870d81e7ca15b49760a/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb22faf48f6eb518932f24005f8606e5f19a7304", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb22faf48f6eb518932f24005f8606e5f19a7304", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb22faf48f6eb518932f24005f8606e5f19a7304"}], "stats": {"total": 167, "additions": 110, "deletions": 57}, "files": [{"sha": "6e226ccec8b0df66cdb565cb9aaa8bfa2f6f41da", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3942060c4b3168307b9e2870d81e7ca15b49760a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3942060c4b3168307b9e2870d81e7ca15b49760a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3942060c4b3168307b9e2870d81e7ca15b49760a", "patch": "@@ -1,3 +1,11 @@\n+2020-04-21  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/94647\n+\t* gimple-ssa-warn-restrict.c (builtin_access::builtin_access): Correct\n+\tthe computation of the lower bound of the source access size.\n+\t(builtin_access::generic_overlap): Remove a hack for setting ranges\n+\tof overlap offsets.\n+\n 2020-04-21  John David Anglin  <danglin@gcc.gnu.org>\n \n \t* config/pa/som.h (ASM_WEAKEN_LABEL): Delete."}, {"sha": "19d2ec09aa51e64541d4183a6c95b3a255fdd58b", "filename": "gcc/gimple-ssa-warn-restrict.c", "status": "modified", "additions": 9, "deletions": 31, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3942060c4b3168307b9e2870d81e7ca15b49760a/gcc%2Fgimple-ssa-warn-restrict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3942060c4b3168307b9e2870d81e7ca15b49760a/gcc%2Fgimple-ssa-warn-restrict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-warn-restrict.c?ref=3942060c4b3168307b9e2870d81e7ca15b49760a", "patch": "@@ -831,8 +831,8 @@ builtin_access::builtin_access (gimple *call, builtin_memref &dst,\n     }\n   else if (srcref->sizrange[0] == 0 && srcref->sizrange[1] == maxobjsize)\n     {\n-      /* When the source size is unknown set it to the size of\n-\t the destination.  */\n+      /* When the size of the source access is unknown set it to the size\n+\t of the destination first and adjust it later if necessary.  */\n       srcref->sizrange[0] = dstref->sizrange[0];\n       srcref->sizrange[1] = dstref->sizrange[1];\n \n@@ -842,15 +842,11 @@ builtin_access::builtin_access (gimple *call, builtin_memref &dst,\n \t    {\n \t      /* Read access by strncpy is constrained by the third\n \t\t argument but except for a zero bound is at least one.  */\n-\t      offset_int size = wi::umax (srcref->basesize, 1);\n-\t      offset_int bound = wi::umin (size, bounds[0]);\n-\t      if (bound < srcref->sizrange[0])\n-\t\tsrcref->sizrange[0] = bound;\n-\t      bound = wi::umin (srcref->basesize, bounds[1]);\n+\t      srcref->sizrange[0] = bounds[1] > 0 ? 1 : 0;\n+\t      offset_int bound = wi::umin (srcref->basesize, bounds[1]);\n \t      if (bound < srcref->sizrange[1])\n \t\tsrcref->sizrange[1] = bound;\n \t    }\n-\n \t  /* For string functions, adjust the size range of the source\n \t     reference by the inverse boundaries of the offset (because\n \t     the higher the offset into the string the shorter its\n@@ -859,7 +855,7 @@ builtin_access::builtin_access (gimple *call, builtin_memref &dst,\n \t      && srcref->offrange[1] < srcref->sizrange[0])\n \t    srcref->sizrange[0] -= srcref->offrange[1];\n \t  else\n-\t    srcref->sizrange[0] = 0;\n+\t    srcref->sizrange[0] = 1;\n \n \t  if (srcref->offrange[0] > 0)\n \t    {\n@@ -1060,16 +1056,8 @@ builtin_access::generic_overlap ()\n   ovloff[0] = HOST_WIDE_INT_MAX;\n   ovloff[1] = HOST_WIDE_INT_MIN;\n \n-  /* Adjustment to the lower bound of the offset of the overlap to\n-     account for a subset of unbounded string calls where the size\n-     of the destination string depends on the length of the source\n-     which in turn depends on the offset into it.  */\n-  bool sub1;\n-\n   if (stxcpy_p)\n     {\n-      sub1 = acs.dstoff[0] <= acs.srcoff[0];\n-\n       /* Iterate over the extreme locations (on the horizontal axis formed\n \t by their offsets) and sizes of two regions and find their smallest\n \t and largest overlap and the corresponding offsets.  */\n@@ -1102,11 +1090,9 @@ builtin_access::generic_overlap ()\n     }\n   else\n     {\n-      sub1 = !depends_p;\n-\n       /* Iterate over the extreme locations (on the horizontal axis\n-\t formed by their offsets) and sizes of two regions and find\n-\t their smallest and largest overlap and the corresponding\n+\t formed by their offsets) and sizes of the two regions and\n+\t find their smallest and largest overlap and the corresponding\n \t offsets.  */\n \n       for (unsigned io = 0; io != 2; ++io)\n@@ -1119,15 +1105,6 @@ builtin_access::generic_overlap ()\n \t    for (unsigned jo = 0; jo != 2; ++jo)\n \t      for (unsigned js = 0; js != 2; ++js)\n \t\t{\n-\t\t  if (depends_p)\n-\t\t    {\n-\t\t      /* For st{p,r}ncpy the size of the source sequence\n-\t\t\t depends on the offset into it.  */\n-\t\t      if (js)\n-\t\t\tbreak;\n-\t\t      js = !jo;\n-\t\t    }\n-\n \t\t  const offset_int b[2] = {\n \t\t    acs.srcoff[jo], acs.srcoff[jo] + acs.srcsiz[js]\n \t\t  };\n@@ -1154,8 +1131,9 @@ builtin_access::generic_overlap ()\n   ovlsiz[0] = siz[0].to_shwi ();\n   ovlsiz[1] = siz[1].to_shwi ();\n \n+  /* Adjust the overlap offset range to reflect the overlap size range.  */\n   if (ovlsiz[0] == 0 && ovlsiz[1] > 1)\n-    ovloff[0] = ovloff[1] + ovlsiz[1] - 1 - sub1;\n+    ovloff[1] = ovloff[0] + ovlsiz[1] - 1;\n \n   return true;\n }"}, {"sha": "bd196966e6cec790e3c0c521d7a002ce1e300edf", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3942060c4b3168307b9e2870d81e7ca15b49760a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3942060c4b3168307b9e2870d81e7ca15b49760a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3942060c4b3168307b9e2870d81e7ca15b49760a", "patch": "@@ -1,3 +1,14 @@\n+2020-04-21  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/94647\n+\t* c-c++-common/Warray-bounds-2.c: Adjust a test case and add a new one.\n+\t* c-c++-common/Warray-bounds-3.c: Add tests for missing warnings.\n+\t* c-c++-common/Wrestrict.c: Invert bounds in printed ranges.\n+\t* gcc.dg/Warray-bounds-59.c: New test.\n+\t* gcc.dg/Wrestrict-10.c: Add a missing warning.\n+\t* gcc.dg/Wrestrict-5.c: Adjust text of expected warning.\n+\t* gcc.dg/Wrestrict-6.c: Expect to see a range of overlap offsets.\n+\n 2020-04-21  Szabolcs Nagy  <szabolcs.nagy@arm.com>\n \n \tPR target/94514"}, {"sha": "8c6e0a62b15244ce61855466f21989ec777c3e52", "filename": "gcc/testsuite/c-c++-common/Warray-bounds-2.c", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3942060c4b3168307b9e2870d81e7ca15b49760a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWarray-bounds-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3942060c4b3168307b9e2870d81e7ca15b49760a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWarray-bounds-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWarray-bounds-2.c?ref=3942060c4b3168307b9e2870d81e7ca15b49760a", "patch": "@@ -172,14 +172,26 @@ void call_strncpy_src_xsize (char *d, size_t n)\n /* Exercise strncpy out-of-bounds offsets with an array of unknown size.  */\n \n static void\n-wrap_strncpy_src_diff_max (char *d, const char *s, ptrdiff_t i, size_t n)\n+wrap_strncpy_src_diff_max_m1 (char *d, const char *s, ptrdiff_t i, size_t n)\n {\n   /* Unlike in the similar call to memcpy(), there is no pointer\n      overflow here because the size N is not added to the source\n-     offset.  */\n+     offset MAX - 1 (only 1 is for the access to its first element,\n+     which is tested below).  */\n   strncpy (d, s + i, n);\n }\n \n+void call_strncpy_src_diff_max_m1 (char *d, const char *s, size_t n)\n+{\n+  wrap_strncpy_src_diff_max_m1 (d, s, MAX - 1, 3);\n+}\n+\n+static void\n+wrap_strncpy_src_diff_max (char *d, const char *s, ptrdiff_t i, size_t n)\n+{\n+  strncpy (d, s + i, n);  /* { dg-warning \"pointer overflow between offset 9223372036854775807 and size \\\\\\[1, 0]\" } */\n+}\n+\n void call_strncpy_src_diff_max (char *d, const char *s, size_t n)\n {\n   wrap_strncpy_src_diff_max (d, s, MAX, 3);"}, {"sha": "aae4999ea1348d2e4bde89a4edbde6de1d2da965", "filename": "gcc/testsuite/c-c++-common/Warray-bounds-3.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3942060c4b3168307b9e2870d81e7ca15b49760a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWarray-bounds-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3942060c4b3168307b9e2870d81e7ca15b49760a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWarray-bounds-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWarray-bounds-3.c?ref=3942060c4b3168307b9e2870d81e7ca15b49760a", "patch": "@@ -287,15 +287,16 @@ void test_strcpy_bounds (char *d, const char *s)\n   TI (char, 1, \"\",   a, a + SR (0, DIFF_MAX - 1));\n   TI (char, 2, \"0\",  a, a + SR (0, DIFF_MAX - 1));\n   TI (char, 2, \"0\",  a, a + SR (1, DIFF_MAX - 1));\n-  /* The following needs a warning for reading past the end.  */\n-  TI (char, 2, \"0\",  a, a + SR (2, DIFF_MAX - 1));\n+  /* The warning below isn't the most accurate because while reading\n+     from it is invalid, the offset that refers just past the end of\n+     the source array is strictly valid.  */\n+  TI (char, 2, \"0\",  a, a + SR (2, DIFF_MAX - 1));    /* { dg-warning \"offset 2 is out of the bounds \\\\\\[0, 2] of object \\[^\\n\\r\\]+ with type 'char ?\\\\\\[2]'\" } */\n   TI (char, 2, \"0\",  a, a + SR (3, DIFF_MAX - 1));   /* { dg-warning \"offset \\\\\\[3, \\[0-9\\]+] is out of the bounds \\\\\\[0, 2] of object \\[^\\n\\r\\]+ with type .char ?\\\\\\[2\\\\\\].\"  \"strcpy\" } */\n \n   TI (char, 3, \"01\", a, a + SR (0, DIFF_MAX - 1));\n   TI (char, 3, \"01\", a, a + SR (1, DIFF_MAX - 1));\n   TI (char, 3, \"01\", a, a + SR (2, DIFF_MAX - 1));\n-  /* The following needs a warning for reading past the end.  */\n-  TI (char, 3, \"01\", a, a + SR (3, DIFF_MAX - 1));\n+  TI (char, 3, \"01\", a, a + SR (3, DIFF_MAX - 1));   /* { dg-warning \"offset 3 is out of the bounds \\\\\\[0, 3] of object \\[^\\n\\r\\]+ with type 'char ?\\\\\\[3]'\" } */\n   TI (char, 3, \"01\", a, a + SR (4, DIFF_MAX - 1));   /* { dg-warning \"offset \\\\\\[4, \\[0-9\\]+] is out of the bounds \\\\\\[0, 3] of object \\[^\\n\\r\\]+ with type .char ?\\\\\\[3\\\\\\].\"  \"strcpy\" } */\n \n   TI (char, 4, \"012\", a, a + SR (DIFF_MAX - 2, DIFF_MAX - 1));   /* { dg-warning \"offset \\\\\\[\\[0-9\\]+, \\[0-9\\]+] is out of the bounds \\\\\\[0, 4] of object \\[^\\n\\r\\]+ with type .char ?\\\\\\[4\\\\\\].\"  \"strcpy\" } */"}, {"sha": "eb074a13e7d12c5471f35dce40f0aa63a37efc18", "filename": "gcc/testsuite/c-c++-common/Wrestrict.c", "status": "modified", "additions": 29, "deletions": 16, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3942060c4b3168307b9e2870d81e7ca15b49760a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWrestrict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3942060c4b3168307b9e2870d81e7ca15b49760a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWrestrict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWrestrict.c?ref=3942060c4b3168307b9e2870d81e7ca15b49760a", "patch": "@@ -684,7 +684,7 @@ void test_strcpy_range (void)\n \n   r = SR (2, 5);\n   T (8, \"01\",  a + r, a);            /* { dg-warning \"accessing 3 bytes at offsets \\\\\\[2, 5] and 0 may overlap 1 byte at offset 2\" } */\n-  T (8, \"012\", a + r, a);            /* { dg-warning \"accessing 4 bytes at offsets \\\\\\[2, 5] and 0 may overlap up to 2 bytes at offset \\\\\\[3, 2]\" \"strcpy\" } */\n+  T (8, \"012\", a + r, a);            /* { dg-warning \"accessing 4 bytes at offsets \\\\\\[2, 5] and 0 may overlap up to 2 bytes at offset \\\\\\[2, 3]\" \"strcpy\" } */\n \n   /* The highest offset to which to copy without overflowing the 8-byte\n      destination is 3 and that overlaps 2 bytes.  */\n@@ -697,7 +697,7 @@ void test_strcpy_range (void)\n   /* With a 10-byte buffer it's possible to copy all 5 bytes without\n      overlap at (a + 5).  Copying at offsets 2 through 4 overflows\n      between 3 and 1 bytes, respectively.  */\n-  T (10, \"0123\", a + r, a);          /* { dg-warning \"accessing 5 bytes at offsets \\\\\\[2, 5] and 0 may overlap up to 3 bytes at offset \\\\\\[4, 2]\" \"strcpy\" } */\n+  T (10, \"0123\", a + r, a);          /* { dg-warning \"accessing 5 bytes at offsets \\\\\\[2, 5] and 0 may overlap up to 3 bytes at offset \\\\\\[2, 4]\" \"strcpy\" } */\n \n \n   r  = SR (3, 4);\n@@ -727,7 +727,7 @@ void test_strcpy_range (void)\n      overlap, so the warning is a \"may overlap\" and the size of\n      the overlap is 1 byte.  */\n   T (8, \"012345\", a, a + r);         /* { dg-warning \"accessing between 3 and 4 bytes at offsets 0 and \\\\\\[3, 4] may overlap 1 byte at offset 3\" \"strcpy\" } */\n-  T (8, \"0123456\", a, a + r);        /* { dg-warning \"accessing between 4 and 5 bytes at offsets 0 and \\\\\\[3, 4] may overlap up to 2 bytes at offset 3\" \"strcpy\" } */\n+  T (8, \"0123456\", a, a + r);        /* { dg-warning \"accessing between 4 and 5 bytes at offsets 0 and \\\\\\[3, 4] may overlap up to 2 bytes at offset \\\\\\[3, 4]\" \"strcpy\" } */\n \n   r = SR (3, DIFF_MAX - 3);\n   T (8, \"01\",  a + r, a);\n@@ -752,8 +752,8 @@ void test_strcpy_range (void)\n   T (8, \"012\", a + r, a);            /* { dg-warning \"accessing 4 bytes at offsets \\\\\\[0, 8] and 0 may overlap up to 4 bytes\" \"strcpy\" } */\n \n   T (8, \"\", a, a + r);               /* { dg-warning \"accessing 1 byte at offsets 0 and \\\\\\[0, 8] may overlap\" \"strcpy\" } */\n-  T (8, \"0\", a, a + r);              /* { dg-warning \"accessing between 0 and 2 bytes at offsets 0 and \\\\\\[0, 8] may overlap up to 2 bytes\" \"strcpy\" } */\n-  T (8, \"012\", a, a + r);            /* { dg-warning \"accessing between 0 and 4 bytes at offsets 0 and \\\\\\[0, 8] may overlap up to 4 bytes\" \"strcpy\" } */\n+  T (8, \"0\", a, a + r);              /* { dg-warning \"accessing between 1 and 2 bytes at offsets 0 and \\\\\\[0, 8] may overlap up to 2 bytes\" \"strcpy\" } */\n+  T (8, \"012\", a, a + r);            /* { dg-warning \"accessing between 1 and 4 bytes at offsets 0 and \\\\\\[0, 8] may overlap up to 4 bytes\" \"strcpy\" } */\n }\n \n /* Exercise strcpy with destination and/or source of unknown lengthu.  */\n@@ -868,27 +868,36 @@ void test_strncpy_range (char *d, size_t n)\n   T (\"0123\", a, a + i, 0);\n   T (\"0123\", a, a + i, 1);\n   T (\"0123\", a, a + i, 2);   /* { dg-warning \"accessing 2 bytes at offsets 0 and \\\\\\[1, 5] may overlap 1 byte at offset 1\" \"strncpy\" } */\n-  T (\"0123\", a, a + i, 3);   /* { dg-warning \"accessing 3 bytes at offsets 0 and \\\\\\[1, 5] may overlap up to 2 bytes at offset \\\\\\[2, 1]\" \"strncpy\" } */\n-  T (\"0123\", a, a + i, 4);   /* { dg-warning \"accessing 4 bytes at offsets 0 and \\\\\\[1, 5] may overlap up to 3 bytes at offset \\\\\\[3, 1]\" \"strncpy\" } */\n-  T (\"0123\", a, a + i, 5);   /* { dg-warning \"accessing 5 bytes at offsets 0 and \\\\\\[1, 5] may overlap up to 4 bytes at offset \\\\\\[4, 1]\" \"strncpy\" } */\n+  T (\"0123\", a, a + i, 3);   /* { dg-warning \"accessing 3 bytes at offsets 0 and \\\\\\[1, 5] may overlap up to 2 bytes at offset \\\\\\[1, 2]\" \"strncpy\" } */\n+  T (\"0123\", a, a + i, 4);   /* { dg-warning \"accessing 4 bytes at offsets 0 and \\\\\\[1, 5] may overlap up to 3 bytes at offset \\\\\\[1, 3]\" \"strncpy\" } */\n+  T (\"0123\", a, a + i, 5);   /* { dg-warning \"accessing 5 bytes at offsets 0 and \\\\\\[1, 5] may overlap up to 4 bytes at offset \\\\\\[1, 4]\" \"strncpy\" } */\n \n   i = SR (2, 5);\n   T (\"0123\", a, a + i, 0);\n   T (\"0123\", a, a + i, 1);\n   T (\"0123\", a, a + i, 2);\n   T (\"0123\", a, a + i, 3);   /* { dg-warning \"accessing 3 bytes at offsets 0 and \\\\\\[2, 5] may overlap 1 byte at offset 2\" \"strncpy\" } */\n-  T (\"0123\", a, a + i, 4);   /* { dg-warning \"accessing 4 bytes at offsets 0 and \\\\\\[2, 5] may overlap up to 2 bytes at offset \\\\\\[3, 2]\" \"strncpy\" } */\n-  T (\"0123\", a, a + i, 5);   /* { dg-warning \"accessing 5 bytes at offsets 0 and \\\\\\[2, 5] may overlap up to 3 bytes at offset \\\\\\[4, 2]\" \"strncpy\" } */\n-  T (\"0123\", a, a + i, 6);   /* { dg-warning \"accessing 6 bytes at offsets 0 and \\\\\\[2, 5] may overlap up to 3 bytes at offset \\\\\\[4, 2]\" \"strncpy\" } */\n+  T (\"0123\", a, a + i, 4);   /* { dg-warning \"accessing 4 bytes at offsets 0 and \\\\\\[2, 5] may overlap up to 2 bytes at offset \\\\\\[2, 3]\" \"strncpy\" } */\n+  T (\"0123\", a, a + i, 5);   /* { dg-warning \"accessing 5 bytes at offsets 0 and \\\\\\[2, 5] may overlap up to 3 bytes at offset \\\\\\[2, 4]\" \"strncpy\" } */\n+  /* When i == 5 the following overlaps at least 1 byte: the nul at a[5]\n+     (if a + 5 is the empty string).  If a + 5 is not empty then it overlaps\n+     it plus as many non-nul characters after it, up to the total of 6.  */\n+  T (\"0123\", a, a + i, 6);   /* { dg-warning \"accessing 6 bytes at offsets 0 and \\\\\\[2, 5] overlaps between 1 and 3 bytes at offset \\\\\\[2, 5]\" \"strncpy\" } */\n \n   i = SR (3, 5);\n   T (\"0123\", a, a + i, 0);\n   T (\"0123\", a, a + i, 1);\n   T (\"0123\", a, a + i, 2);\n   T (\"0123\", a, a + i, 3);\n   T (\"0123\", a, a + i, 4);   /* { dg-warning \"accessing 4 bytes at offsets 0 and \\\\\\[3, 5] may overlap 1 byte at offset 3\" \"strncpy\" } */\n-  T (\"0123\", a, a + i, 5);   /* { dg-warning \"accessing 5 bytes at offsets 0 and \\\\\\[3, 5] may overlap up to 2 bytes at offset \\\\\\[4, 3]\" \"strncpy\" } */\n-  T (\"0123\", a, a + i, 6);   /* { dg-warning \"accessing 6 bytes at offsets 0 and \\\\\\[3, 5] may overlap up to 2 bytes at offset \\\\\\[4, 3]\" \"strncpy\" } */\n+  T (\"0123\", a, a + i, 5);   /* { dg-warning \"accessing 5 bytes at offsets 0 and \\\\\\[3, 5] may overlap up to 2 bytes at offset \\\\\\[3, 4]\" \"strncpy\" } */\n+\n+  /* The following copy overlaps at most 2 bytes.  When i == 3 it overlaps\n+     the 2 bytes at \"3\", when i == 4 just the final nul.  When i == 5 it\n+     also overlaps 1 byte, the nul at a[5].  Although the overlap offset\n+     range suggests the overlap is up to three bytes, it correctly reflects\n+     the union of the two cases.  */\n+  T (\"0123\", a, a + i, 6);   /* { dg-warning \"accessing 6 bytes at offsets 0 and \\\\\\[3, 5] overlaps between 1 and 2 bytes at offset \\\\\\[3, 5]\" \"strncpy\" } */\n \n   i = SR (4, 5);\n   T (\"0123\", a, a + i, 0);\n@@ -897,7 +906,11 @@ void test_strncpy_range (char *d, size_t n)\n   T (\"0123\", a, a + i, 3);\n   T (\"0123\", a, a + i, 4);\n   T (\"0123\", a, a + i, 5);   /* { dg-warning \"accessing 5 bytes at offsets 0 and \\\\\\[4, 5] may overlap 1 byte at offset 4\" \"strncpy\" } */\n-  T (\"0123\", a, a + i, 6);   /* { dg-warning \"accessing 6 bytes at offsets 0 and \\\\\\[4, 5] may overlap 1 byte at offset 4\" \"strncpy\" } */\n+  /* Regardless of the value of i, the following overlaps exactlty\n+     one byte: the nul at a[4].  There is no overlap at a[5] because\n+     the source is not read past the nul so the offset below isn't\n+     entirely correct.  */\n+  T (\"0123\", a, a + i, 6);   /* { dg-warning \"accessing 6 bytes at offsets 0 and \\\\\\[4, 5] overlaps 1 byte at offset \\\\\\[4, 5]\" \"strncpy\" } */\n \n   /* Verify offset and size both in some range.  The strncpy checking\n      is more strict than that of memcpy and triggers even when the\n@@ -911,10 +924,10 @@ void test_strncpy_range (char *d, size_t n)\n         i = 5:    567*       none\n                   567*.      none\n                   567*..     overlaps 1 at offset 5  */\n-  T (\"01234567\", a, a + i, UR (4, 6));   /* { dg-warning \"accessing between 4 and 6 bytes at offsets 0 and \\\\\\[4, 5] may overlap up to 2 bytes at offset \\\\\\[5, 4]\" \"strncpy\" } */\n+  T (\"01234567\", a, a + i, UR (4, 6));   /* { dg-warning \"accessing between 4 and 6 bytes at offsets 0 and \\\\\\[4, 5] may overlap up to 2 bytes at offset \\\\\\[4, 5]\" \"strncpy\" } */\n \n   /* Ditto for objects of unknown sizes.  */\n-  T (\"01234567\", d, d + i, UR (4, 6));  /* { dg-warning \"accessing between 4 and 6 bytes at offsets 0 and \\\\\\[4, 5] may overlap up to 2 bytes at offset \\\\\\[5, 4]\" \"strncpy\" } */\n+  T (\"01234567\", d, d + i, UR (4, 6));  /* { dg-warning \"accessing between 4 and 6 bytes at offsets 0 and \\\\\\[4, 5] may overlap up to 2 bytes at offset \\\\\\[4, 5]\" \"strncpy\" } */\n \n   T (\"01234567\", a, a + i, UR (6, 7));  /* { dg-warning \"accessing between 6 and 7 bytes at offsets 0 and \\\\\\[4, 5] overlaps between 1 and 3 bytes at offset \\\\\\[4, 5]\" \"strncpy\" } */\n "}, {"sha": "99b18fce753ab1b0ed830524aa45fc16c028389a", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-59.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3942060c4b3168307b9e2870d81e7ca15b49760a/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-59.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3942060c4b3168307b9e2870d81e7ca15b49760a/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-59.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-59.c?ref=3942060c4b3168307b9e2870d81e7ca15b49760a", "patch": "@@ -0,0 +1,30 @@\n+/* PR middle-end/94647 - bogus -Warray-bounds on strncpy into a larger\n+   member array from a smaller array\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+extern char* strncpy (char*, const char*, size_t);\n+\n+\n+char a4[4], a8[8];\n+\n+void nowarn_nonmeber (void)\n+{\n+  /* The following would deserve a warning if A4 were known not to be\n+     nul-terminated (or declared with attribute nonstring).  */\n+  strncpy (a8, a4, sizeof a8);\n+}\n+struct S\n+{\n+  char a4[4], a8[8];\n+};\n+\n+void nowarn_member (struct S *p, struct S *q)\n+{\n+  /* The following would deserve a warning if A4 were known either\n+     not to be nul-terminated (e.g., declared nonstring) or to be\n+     uninitialized.  */\n+  strncpy (p->a8, p->a4, sizeof p->a8);   // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+}"}, {"sha": "7dcbf89066eb408d535ee2ef5b6cfddaa5aa6114", "filename": "gcc/testsuite/gcc.dg/Wrestrict-10.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3942060c4b3168307b9e2870d81e7ca15b49760a/gcc%2Ftestsuite%2Fgcc.dg%2FWrestrict-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3942060c4b3168307b9e2870d81e7ca15b49760a/gcc%2Ftestsuite%2Fgcc.dg%2FWrestrict-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWrestrict-10.c?ref=3942060c4b3168307b9e2870d81e7ca15b49760a", "patch": "@@ -63,7 +63,7 @@ test_arr_strcpy_1 (void)\n void __attribute__ ((noclone, noinline))\n test_arr_strcpy_2 (void)\n {\n-  strcpy (b.a, &b.a[i]);\n+  strcpy (b.a, &b.a[i]);            /* { dg-warning \"\\\\\\[-Wrestrict\" } */\n }\n \n "}, {"sha": "21e190129e4811f7ed60999d27caeac4d81ee973", "filename": "gcc/testsuite/gcc.dg/Wrestrict-5.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3942060c4b3168307b9e2870d81e7ca15b49760a/gcc%2Ftestsuite%2Fgcc.dg%2FWrestrict-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3942060c4b3168307b9e2870d81e7ca15b49760a/gcc%2Ftestsuite%2Fgcc.dg%2FWrestrict-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWrestrict-5.c?ref=3942060c4b3168307b9e2870d81e7ca15b49760a", "patch": "@@ -26,7 +26,7 @@ void test_memcpy_nowarn (char *d)\n \n void test_strncpy_warn (char *d)\n {\n-  strncpy (d + 1, d + 3, 5);  /* { dg-warning \"accessing 5 bytes at offsets 1 and 3 overlaps 2 bytes at offset 3\" } */\n+  strncpy (d + 1, d + 3, 5);  /* { dg-warning \"accessing 5 bytes at offsets 1 and 3 overlaps between 1 and 2 bytes at offset 3\" } */\n }\n \n void test_strncpy_nowarn (char *d)"}, {"sha": "d1ef1a3e608cb824cbbee2eba52116b6f0c1cdae", "filename": "gcc/testsuite/gcc.dg/Wrestrict-6.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3942060c4b3168307b9e2870d81e7ca15b49760a/gcc%2Ftestsuite%2Fgcc.dg%2FWrestrict-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3942060c4b3168307b9e2870d81e7ca15b49760a/gcc%2Ftestsuite%2Fgcc.dg%2FWrestrict-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWrestrict-6.c?ref=3942060c4b3168307b9e2870d81e7ca15b49760a", "patch": "@@ -21,7 +21,7 @@ void warn_2_smax_p2 (void)\n \n   ptrdiff_t i = UR (2, DIFF_MAX + (size_t)2);\n \n-  strcpy (d, d + i);          /* { dg-warning \"accessing between 0 and 4 bytes at offsets 0 and \\\\\\[2, 7] may overlap up to 2 bytes at offset 2\" } */\n+  strcpy (d, d + i);          /* { dg-warning \"accessing between 1 and 4 bytes at offsets 0 and \\\\\\[2, 7] may overlap up to 2 bytes at offset \\\\\\[2, 3]\" } */\n \n   sink (d);\n }\n@@ -47,7 +47,7 @@ void warn_2u_smax_p2 (void)\n \n   size_t i = UR (2, DIFF_MAX + (size_t)2);\n \n-  strcpy (d, d + i);          /* { dg-warning \"accessing between 0 and 4 bytes at offsets 0 and \\\\\\[2, 7] may overlap up to 2 bytes at offset 2\" } */\n+  strcpy (d, d + i);          /* { dg-warning \"accessing between 1 and 4 bytes at offsets 0 and \\\\\\[2, 7] may overlap up to 2 bytes at offset \\\\\\[2, 3]\" } */\n \n   sink (d);\n }"}]}