{"sha": "95cefe5f0ea9e244b73de42ef1ee54d2d9b3a5f6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTVjZWZlNWYwZWE5ZTI0NGI3M2RlNDJlZjFlZTU0ZDJkOWIzYTVmNg==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2006-09-19T09:07:56Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2006-09-19T09:07:56Z"}, "message": "hashtable_policy.h: Uglify all the names.\n\n2006-09-19  Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/tr1/hashtable_policy.h: Uglify all the names.\n\t* include/tr1/hashtable: Likewise.\n\t* include/tr1/unordered_map: Likewise.\n\t* include/tr1/unordered_set: Likewise.\n\t* include/tr1/functional: Uglify struct hash names.\n\t* include/tr1/cmath: Uglify namespace detail to __detail.\n\nFrom-SVN: r117052", "tree": {"sha": "76de244c6642362c0e7e7e91a9a77d1a5323fec4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/76de244c6642362c0e7e7e91a9a77d1a5323fec4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/95cefe5f0ea9e244b73de42ef1ee54d2d9b3a5f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95cefe5f0ea9e244b73de42ef1ee54d2d9b3a5f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95cefe5f0ea9e244b73de42ef1ee54d2d9b3a5f6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95cefe5f0ea9e244b73de42ef1ee54d2d9b3a5f6/comments", "author": null, "committer": null, "parents": [{"sha": "b5387733524e6ba066d34812b24f9e7bdf4b478d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5387733524e6ba066d34812b24f9e7bdf4b478d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5387733524e6ba066d34812b24f9e7bdf4b478d"}], "stats": {"total": 2641, "additions": 1396, "deletions": 1245}, "files": [{"sha": "0d8622b71ad918f704e422ca5a46074dae4da476", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95cefe5f0ea9e244b73de42ef1ee54d2d9b3a5f6/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95cefe5f0ea9e244b73de42ef1ee54d2d9b3a5f6/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=95cefe5f0ea9e244b73de42ef1ee54d2d9b3a5f6", "patch": "@@ -1,3 +1,12 @@\n+2006-09-19  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/tr1/hashtable_policy.h: Uglify all the names.\n+\t* include/tr1/hashtable: Likewise.\n+\t* include/tr1/unordered_map: Likewise.\n+\t* include/tr1/unordered_set: Likewise.\n+\t* include/tr1/functional: Uglify struct hash names.\n+\t* include/tr1/cmath: Uglify namespace detail to __detail.\n+\n 2006-09-18  Benjamin Kosnik  <bkoz@redhat.com>\n \n \t* testsuite/util/regression/res_mng: Remove."}, {"sha": "0e3320decc0477a5d88632e14c71dc4c0a7044a3", "filename": "libstdc++-v3/include/tr1/cmath", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95cefe5f0ea9e244b73de42ef1ee54d2d9b3a5f6/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcmath", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95cefe5f0ea9e244b73de42ef1ee54d2d9b3a5f6/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcmath", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcmath?ref=95cefe5f0ea9e244b73de42ef1ee54d2d9b3a5f6", "patch": "@@ -368,21 +368,23 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n   using std::atan;\n \n   // Workaround for c++/21682.\n-  namespace detail\n+  namespace __detail\n   {\n     template<typename _Tp, typename _Up>\n-      inline typename __gnu_cxx::__enable_if<std::__is_floating<_Tp>::__value\n-    \t                                   || std::__is_floating<_Up>::__value,\n-      typename std::tr1::__promote_2<_Tp, _Up>::__type>::__type\n-    atan2(_Tp __y, _Up __x)\n-    {\n-      typedef typename std::tr1::__promote_2<_Tp, _Up>::__type __type;\n-      return std::atan2(__type(__y), __type(__x));\n-    }\n-  } // namespace detail\n+      inline typename\n+      __gnu_cxx::__enable_if<std::__is_floating<_Tp>::__value\n+                             || std::__is_floating<_Up>::__value,\n+\t\t\t     typename\n+\t\t\t     std::tr1::__promote_2<_Tp, _Up>::__type>::__type\n+      atan2(_Tp __y, _Up __x)\n+      {\n+\ttypedef typename std::tr1::__promote_2<_Tp, _Up>::__type __type;\n+\treturn std::atan2(__type(__y), __type(__x));\n+      }\n+  } // namespace __detail\n \n   using std::atan2;\n-  using detail::atan2;\n+  using __detail::atan2;\n  \n   inline float\n   atanh(float __x)"}, {"sha": "ef85e5b7ab0b7de2f1e34b26d2c3c088acb97256", "filename": "libstdc++-v3/include/tr1/functional", "status": "modified", "additions": 108, "deletions": 106, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95cefe5f0ea9e244b73de42ef1ee54d2d9b3a5f6/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ffunctional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95cefe5f0ea9e244b73de42ef1ee54d2d9b3a5f6/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ffunctional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ffunctional?ref=95cefe5f0ea9e244b73de42ef1ee54d2d9b3a5f6", "patch": "@@ -1,6 +1,6 @@\n // TR1 functional header -*- C++ -*-\n \n-// Copyright (C) 2004, 2005 Free Software Foundation, Inc.\n+// Copyright (C) 2004, 2005, 2006 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -106,7 +106,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n   */\n   template<typename _Functor>\n     struct _Weak_result_type_impl\n-      : _Maybe_get_result_type<_Has_result_type<_Functor>::value, _Functor>\n+    : _Maybe_get_result_type<_Has_result_type<_Functor>::value, _Functor>\n     {\n     };\n \n@@ -214,33 +214,33 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n   // Not a unary_function or binary_function, so try a weak result type\n   template<typename _Tp>\n     struct _Reference_wrapper_base_impl<false, false, _Tp>\n-      : _Weak_result_type<_Tp>\n+    : _Weak_result_type<_Tp>\n     { };\n \n   // unary_function but not binary_function\n   template<typename _Tp>\n     struct _Reference_wrapper_base_impl<true, false, _Tp>\n-      : unary_function<typename _Tp::argument_type,\n-                       typename _Tp::result_type>\n+    : unary_function<typename _Tp::argument_type,\n+\t\t     typename _Tp::result_type>\n     { };\n \n   // binary_function but not unary_function\n   template<typename _Tp>\n     struct _Reference_wrapper_base_impl<false, true, _Tp>\n-      : binary_function<typename _Tp::first_argument_type,\n-                        typename _Tp::second_argument_type,\n-                        typename _Tp::result_type>\n+    : binary_function<typename _Tp::first_argument_type,\n+\t\t      typename _Tp::second_argument_type,\n+\t\t      typename _Tp::result_type>\n     { };\n \n   // both unary_function and binary_function. import result_type to\n   // avoid conflicts.\n    template<typename _Tp>\n     struct _Reference_wrapper_base_impl<true, true, _Tp>\n-      : unary_function<typename _Tp::argument_type,\n-                       typename _Tp::result_type>,\n-        binary_function<typename _Tp::first_argument_type,\n-                        typename _Tp::second_argument_type,\n-                        typename _Tp::result_type>\n+    : unary_function<typename _Tp::argument_type,\n+\t\t     typename _Tp::result_type>,\n+      binary_function<typename _Tp::first_argument_type,\n+\t\t      typename _Tp::second_argument_type,\n+\t\t      typename _Tp::result_type>\n     {\n       typedef typename _Tp::result_type result_type;\n     };\n@@ -255,82 +255,82 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n   */\n   template<typename _Tp>\n     struct _Reference_wrapper_base\n-      : _Reference_wrapper_base_impl<\n-          _Derives_from_unary_function<_Tp>::value,\n-          _Derives_from_binary_function<_Tp>::value,\n-          _Tp>\n+    : _Reference_wrapper_base_impl<\n+      _Derives_from_unary_function<_Tp>::value,\n+      _Derives_from_binary_function<_Tp>::value,\n+      _Tp>\n     { };\n \n   // - a function type (unary)\n   template<typename _Res, typename _T1>\n     struct _Reference_wrapper_base<_Res(_T1)>\n-      : unary_function<_T1, _Res>\n+    : unary_function<_T1, _Res>\n     { };\n \n   // - a function type (binary)\n   template<typename _Res, typename _T1, typename _T2>\n     struct _Reference_wrapper_base<_Res(_T1, _T2)>\n-      : binary_function<_T1, _T2, _Res>\n+    : binary_function<_T1, _T2, _Res>\n     { };\n \n   // - a function pointer type (unary)\n   template<typename _Res, typename _T1>\n     struct _Reference_wrapper_base<_Res(*)(_T1)>\n-      : unary_function<_T1, _Res>\n+    : unary_function<_T1, _Res>\n     { };\n \n   // - a function pointer type (binary)\n   template<typename _Res, typename _T1, typename _T2>\n     struct _Reference_wrapper_base<_Res(*)(_T1, _T2)>\n-      : binary_function<_T1, _T2, _Res>\n+    : binary_function<_T1, _T2, _Res>\n     { };\n \n   // - a pointer to member function type (unary, no qualifiers)\n   template<typename _Res, typename _T1>\n     struct _Reference_wrapper_base<_Res (_T1::*)()>\n-      : unary_function<_T1*, _Res>\n+    : unary_function<_T1*, _Res>\n     { };\n \n   // - a pointer to member function type (binary, no qualifiers)\n   template<typename _Res, typename _T1, typename _T2>\n     struct _Reference_wrapper_base<_Res (_T1::*)(_T2)>\n-      : binary_function<_T1*, _T2, _Res>\n+    : binary_function<_T1*, _T2, _Res>\n     { };\n \n   // - a pointer to member function type (unary, const)\n   template<typename _Res, typename _T1>\n     struct _Reference_wrapper_base<_Res (_T1::*)() const>\n-      : unary_function<const _T1*, _Res>\n+    : unary_function<const _T1*, _Res>\n     { };\n \n   // - a pointer to member function type (binary, const)\n   template<typename _Res, typename _T1, typename _T2>\n     struct _Reference_wrapper_base<_Res (_T1::*)(_T2) const>\n-      : binary_function<const _T1*, _T2, _Res>\n+    : binary_function<const _T1*, _T2, _Res>\n     { };\n \n   // - a pointer to member function type (unary, volatile)\n   template<typename _Res, typename _T1>\n     struct _Reference_wrapper_base<_Res (_T1::*)() volatile>\n-      : unary_function<volatile _T1*, _Res>\n+    : unary_function<volatile _T1*, _Res>\n     { };\n \n   // - a pointer to member function type (binary, volatile)\n   template<typename _Res, typename _T1, typename _T2>\n     struct _Reference_wrapper_base<_Res (_T1::*)(_T2) volatile>\n-      : binary_function<volatile _T1*, _T2, _Res>\n+    : binary_function<volatile _T1*, _T2, _Res>\n     { };\n \n   // - a pointer to member function type (unary, const volatile)\n   template<typename _Res, typename _T1>\n     struct _Reference_wrapper_base<_Res (_T1::*)() const volatile>\n-      : unary_function<const volatile _T1*, _Res>\n+    : unary_function<const volatile _T1*, _Res>\n     { };\n \n   // - a pointer to member function type (binary, const volatile)\n   template<typename _Res, typename _T1, typename _T2>\n     struct _Reference_wrapper_base<_Res (_T1::*)(_T2) const volatile>\n-      : binary_function<const volatile _T1*, _T2, _Res>\n+    : binary_function<const volatile _T1*, _T2, _Res>\n     { };\n \n   template<typename _Tp>\n@@ -452,22 +452,22 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n   public:\n     template<typename _Tp>\n       struct _Result_type\n-        : _Mem_fn_const_or_non<\n-            _Res,\n-            (sizeof(__sfinae_types::__two)\n-             == sizeof(__check_const<_Tp>(__get_ref<_Tp>(), (_Tp*)0)))>\n+      : _Mem_fn_const_or_non<\n+        _Res,\n+        (sizeof(__sfinae_types::__two)\n+\t == sizeof(__check_const<_Tp>(__get_ref<_Tp>(), (_Tp*)0)))>\n       { };\n \n     template<typename _Signature>\n       struct result;\n \n     template<typename _CVMem, typename _Tp>\n       struct result<_CVMem(_Tp)>\n-        : public _Result_type<_Tp> { };\n+      : public _Result_type<_Tp> { };\n \n     template<typename _CVMem, typename _Tp>\n       struct result<_CVMem(_Tp&)>\n-        : public _Result_type<_Tp> { };\n+      : public _Result_type<_Tp> { };\n \n     explicit _Mem_fn(_Res _Class::*__pm) : __pm(__pm) { }\n \n@@ -1100,85 +1100,86 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n   template<typename T>\n     struct hash;\n \n-#define tr1_hashtable_define_trivial_hash(T)            \\\n+#define _TR1_hashtable_define_trivial_hash(_Tp)         \\\n   template<>                                            \\\n-    struct hash<T>                                      \\\n-    : public std::unary_function<T, std::size_t>        \\\n+    struct hash<_Tp>                                    \\\n+    : public std::unary_function<_Tp, std::size_t>      \\\n     {                                                   \\\n       std::size_t                                       \\\n-      operator()(T val) const                           \\\n-      { return static_cast<std::size_t>(val); }         \\\n+      operator()(_Tp __val) const                       \\\n+      { return static_cast<std::size_t>(__val); }       \\\n     }                                                     \n \n-  tr1_hashtable_define_trivial_hash(bool);\n-  tr1_hashtable_define_trivial_hash(char);\n-  tr1_hashtable_define_trivial_hash(signed char);\n-  tr1_hashtable_define_trivial_hash(unsigned char);\n-  tr1_hashtable_define_trivial_hash(wchar_t);\n-  tr1_hashtable_define_trivial_hash(short);\n-  tr1_hashtable_define_trivial_hash(int);\n-  tr1_hashtable_define_trivial_hash(long);\n-  tr1_hashtable_define_trivial_hash(unsigned short);\n-  tr1_hashtable_define_trivial_hash(unsigned int);\n-  tr1_hashtable_define_trivial_hash(unsigned long);\n+  _TR1_hashtable_define_trivial_hash(bool);\n+  _TR1_hashtable_define_trivial_hash(char);\n+  _TR1_hashtable_define_trivial_hash(signed char);\n+  _TR1_hashtable_define_trivial_hash(unsigned char);\n+  _TR1_hashtable_define_trivial_hash(wchar_t);\n+  _TR1_hashtable_define_trivial_hash(short);\n+  _TR1_hashtable_define_trivial_hash(int);\n+  _TR1_hashtable_define_trivial_hash(long);\n+  _TR1_hashtable_define_trivial_hash(unsigned short);\n+  _TR1_hashtable_define_trivial_hash(unsigned int);\n+  _TR1_hashtable_define_trivial_hash(unsigned long);\n \n-#undef tr1_hashtable_define_trivial_hash\n+#undef _TR1_hashtable_define_trivial_hash\n \n-  template<typename T>\n-    struct hash<T*>\n-    : public std::unary_function<T*, std::size_t>\n+  template<typename _Tp>\n+    struct hash<_Tp*>\n+    : public std::unary_function<_Tp*, std::size_t>\n     {\n       std::size_t\n-      operator()(T* p) const\n-      { return reinterpret_cast<std::size_t>(p); }\n+      operator()(_Tp* __p) const\n+      { return reinterpret_cast<std::size_t>(__p); }\n     };\n \n   // Fowler / Noll / Vo (FNV) Hash (type FNV-1a)\n   // (used by the next specializations of std::tr1::hash<>)\n \n   // Dummy generic implementation (for sizeof(size_t) != 4, 8).\n   template<std::size_t = sizeof(std::size_t)>\n-    struct Fnv_hash\n+    struct _Fnv_hash\n     {\n       static std::size_t\n-      hash(const char* first, std::size_t length)\n+      hash(const char* __first, std::size_t __length)\n       {\n-\tstd::size_t result = 0;\n-\tfor (; length > 0; --length)\n-\t  result = (result * 131) + *first++;\n-\treturn result;\n+\tstd::size_t __result = 0;\n+\tfor (; __length > 0; --__length)\n+\t  __result = (__result * 131) + *__first++;\n+\treturn __result;\n       }\n     };\n \n   template<>\n-    struct Fnv_hash<4>\n+    struct _Fnv_hash<4>\n     {\n       static std::size_t\n-      hash(const char* first, std::size_t length)\n+      hash(const char* __first, std::size_t __length)\n       {\n-\tstd::size_t result = static_cast<std::size_t>(2166136261UL);\n-\tfor (; length > 0; --length)\n+\tstd::size_t __result = static_cast<std::size_t>(2166136261UL);\n+\tfor (; __length > 0; --__length)\n \t  {\n-\t    result ^= (std::size_t)*first++;\n-\t    result *= 16777619UL;\n+\t    __result ^= (std::size_t)*__first++;\n+\t    __result *= 16777619UL;\n \t  }\n-\treturn result;\n+\treturn __result;\n       }\n     };\n   \n   template<>\n-    struct Fnv_hash<8>\n+    struct _Fnv_hash<8>\n     {\n       static std::size_t\n-      hash(const char* first, std::size_t length)\n+      hash(const char* __first, std::size_t __length)\n       {\n-\tstd::size_t result = static_cast<std::size_t>(14695981039346656037ULL);\n-\tfor (; length > 0; --length)\n+\tstd::size_t __result =\n+\t  static_cast<std::size_t>(14695981039346656037ULL);\n+\tfor (; __length > 0; --__length)\n \t  {\n-\t    result ^= (std::size_t)*first++;\n-\t    result *= 1099511628211ULL;\n+\t    __result ^= (std::size_t)*__first++;\n+\t    __result *= 1099511628211ULL;\n \t  }\n-\treturn result;\n+\treturn __result;\n       }\n     };\n \n@@ -1190,8 +1191,8 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n     : public std::unary_function<std::string, std::size_t>\n     {      \n       std::size_t\n-      operator()(const std::string& s) const\n-      { return Fnv_hash<>::hash(s.data(), s.length()); }\n+      operator()(const std::string& __s) const\n+      { return _Fnv_hash<>::hash(__s.data(), __s.length()); }\n     };\n \n #ifdef _GLIBCXX_USE_WCHAR_T\n@@ -1200,10 +1201,10 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n     : public std::unary_function<std::wstring, std::size_t>\n     {\n       std::size_t\n-      operator()(const std::wstring& s) const\n+      operator()(const std::wstring& __s) const\n       {\n-\treturn Fnv_hash<>::hash(reinterpret_cast<const char*>(s.data()),\n-\t\t\t\ts.length() * sizeof(wchar_t));\n+\treturn _Fnv_hash<>::hash(reinterpret_cast<const char*>(__s.data()),\n+\t\t\t\t __s.length() * sizeof(wchar_t));\n       }\n     };\n #endif\n@@ -1213,15 +1214,15 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n     : public std::unary_function<float, std::size_t>\n     {\n       std::size_t\n-      operator()(float fval) const\n+      operator()(float __fval) const\n       {\n-\tstd::size_t result = 0;\n+\tstd::size_t __result = 0;\n \n \t// 0 and -0 both hash to zero.\n-\tif (fval != 0.0f)\n-\t  result = Fnv_hash<>::hash(reinterpret_cast<const char*>(&fval),\n-\t\t\t\t    sizeof(fval));\n-\treturn result;\n+\tif (__fval != 0.0f)\n+\t  __result = _Fnv_hash<>::hash(reinterpret_cast<const char*>(&__fval),\n+\t\t\t\t       sizeof(__fval));\n+\treturn __result;\n       }\n     };\n \n@@ -1230,15 +1231,15 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n     : public std::unary_function<double, std::size_t>\n     {\n       std::size_t\n-      operator()(double dval) const\n+      operator()(double __dval) const\n       {\n-\tstd::size_t result = 0;\n+\tstd::size_t __result = 0;\n \n \t// 0 and -0 both hash to zero.\n-\tif (dval != 0.0)\n-\t  result = Fnv_hash<>::hash(reinterpret_cast<const char*>(&dval),\n-\t\t\t\t    sizeof(dval));\n-\treturn result;\n+\tif (__dval != 0.0)\n+\t  __result = _Fnv_hash<>::hash(reinterpret_cast<const char*>(&__dval),\n+\t\t\t\t       sizeof(__dval));\n+\treturn __result;\n       }\n     };\n \n@@ -1249,29 +1250,30 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n     : public std::unary_function<long double, std::size_t>\n     {\n       std::size_t\n-      operator()(long double ldval) const\n+      operator()(long double __ldval) const\n       {\n-\tstd::size_t result = 0;\n+\tstd::size_t __result = 0;\n \n-\tint exponent;\n-\tldval = std::frexp(ldval, &exponent);\n-\tldval = ldval < 0.0l ? -(ldval + 0.5l) : ldval;\n+\tint __exponent;\n+\t__ldval = std::frexp(__ldval, &__exponent);\n+\t__ldval = __ldval < 0.0l ? -(__ldval + 0.5l) : __ldval;\n \n-\tconst long double mult = std::numeric_limits<std::size_t>::max() + 1.0l;\n-\tldval *= mult;\n+\tconst long double __mult =\n+\t  std::numeric_limits<std::size_t>::max() + 1.0l;\n+\t__ldval *= __mult;\n \n \t// Try to use all the bits of the mantissa (really necessary only\n \t// on 32-bit targets, at least for 80-bit floating point formats).\n-\tconst std::size_t hibits = (std::size_t)ldval;\n-\tldval = (ldval - (long double)hibits) * mult;\n+\tconst std::size_t __hibits = (std::size_t)__ldval;\n+\t__ldval = (__ldval - (long double)__hibits) * __mult;\n \n-\tconst std::size_t coeff =\n+\tconst std::size_t __coeff =\n \t  (std::numeric_limits<std::size_t>::max()\n \t   / std::numeric_limits<long double>::max_exponent);\n \n-\tresult = hibits + (std::size_t)ldval + coeff * exponent;\n+\t__result = __hibits + (std::size_t)__ldval + __coeff * __exponent;\n \n-\treturn result;\n+\treturn __result;\n       }\n     };\n "}, {"sha": "07ac6a881a8c9ed4539024bf8f73617d8c342ec1", "filename": "libstdc++-v3/include/tr1/hashtable", "status": "modified", "additions": 682, "deletions": 596, "changes": 1278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95cefe5f0ea9e244b73de42ef1ee54d2d9b3a5f6/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhashtable", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95cefe5f0ea9e244b73de42ef1ee54d2d9b3a5f6/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhashtable", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhashtable?ref=95cefe5f0ea9e244b73de42ef1ee54d2d9b3a5f6", "patch": "@@ -66,40 +66,40 @@ namespace std\n { \n _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \n-  // Class template hashtable, class definition.\n+  // Class template _Hashtable, class definition.\n   \n-  // Meaning of class template hashtable's template parameters\n+  // Meaning of class template _Hashtable's template parameters\n   \n-  // Key and Value: arbitrary CopyConstructible types.\n+  // _Key and _Value: arbitrary CopyConstructible types.\n   \n-  // Allocator: an allocator type ([lib.allocator.requirements]) whose\n+  // _Allocator: an allocator type ([lib.allocator.requirements]) whose\n   // value type is Value.\n   \n-  // ExtractKey: function object that takes a object of type Value\n-  // and returns a value of type Key.\n+  // _ExtractKey: function object that takes a object of type Value\n+  // and returns a value of type _Key.\n   \n-  // Equal: function object that takes two objects of type k and returns\n+  // _Equal: function object that takes two objects of type k and returns\n   // a bool-like value that is true if the two objects are considered equal.\n   \n-  // H1: the hash function.  A unary function object with argument type\n+  // _H1: the hash function.  A unary function object with argument type\n   // Key and result type size_t.  Return values should be distributed\n   // over the entire range [0, numeric_limits<size_t>:::max()].\n   \n-  // H2: the range-hashing function (in the terminology of Tavori and\n+  // _H2: the range-hashing function (in the terminology of Tavori and\n   // Dreizin).  A binary function object whose argument types and result\n   // type are all size_t.  Given arguments r and N, the return value is\n   // in the range [0, N).\n   \n-  // H: the ranged hash function (Tavori and Dreizin). A binary function\n-  // whose argument types are Key and size_t and whose result type is\n+  // _Hash: the ranged hash function (Tavori and Dreizin). A binary function\n+  // whose argument types are _Key and size_t and whose result type is\n   // size_t.  Given arguments k and N, the return value is in the range\n-  // [0, N).  Default: h(k, N) = h2(h1(k), N).  If H is anything other\n-  // than the default, H1 and H2 are ignored.\n+  // [0, N).  Default: hash(k, N) = h2(h1(k), N).  If _Hash is anything other\n+  // than the default, _H1 and _H2 are ignored.\n   \n-  // RehashPolicy: Policy class with three members, all of which govern\n-  // the bucket count. n_bkt(n) returns a bucket count no smaller\n-  // than n.  bkt_for_elements(n) returns a bucket count appropriate\n-  // for an element count of n.  need_rehash(n_bkt, n_elt, n_ins)\n+  // _RehashPolicy: Policy class with three members, all of which govern\n+  // the bucket count. _M_next_bkt(n) returns a bucket count no smaller\n+  // than n.  _M_bkt_for_elements(n) returns a bucket count appropriate\n+  // for an element count of n.  _M_need_rehash(n_bkt, n_elt, n_ins)\n   // determines whether, if the current bucket count is n_bkt and the\n   // current element count is n_elt, we need to increase the bucket\n   // count.  If so, returns make_pair(true, n), where n is the new\n@@ -108,202 +108,210 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n   // ??? Right now it is hard-wired that the number of buckets never\n   // shrinks.  Should we allow RehashPolicy to change that?\n   \n-  // cache_hash_code: bool.  true if we store the value of the hash\n+  // __cache_hash_code: bool.  true if we store the value of the hash\n   // function along with the value.  This is a time-space tradeoff.\n   // Storing it may improve lookup speed by reducing the number of times\n   // we need to call the Equal function.\n   \n-  // constant_iterators: bool.  true if iterator and const_iterator are\n+  // __constant_iterators: bool.  true if iterator and const_iterator are\n   // both constant iterator types.  This is true for unordered_set and\n   // unordered_multiset, false for unordered_map and unordered_multimap.\n   \n-  // unique_keys: bool.  true if the return value of hashtable::count(k)\n+  // __unique_keys: bool.  true if the return value of _Hashtable::count(k)\n   // is always at most one, false if it may be an arbitrary number.  This\n   // true for unordered_set and unordered_map, false for unordered_multiset\n   // and unordered_multimap.\n   \n-  template<typename Key, typename Value, typename Allocator,\n-\t   typename ExtractKey, typename Equal,\n-\t   typename H1, typename H2, typename H, \n-\t   typename RehashPolicy,\n-\t   bool cache_hash_code,\n-\t   bool constant_iterators,\n-\t   bool unique_keys>\n-    class hashtable\n-    : public detail::rehash_base<RehashPolicy,\n-\t\t\t\t hashtable<Key, Value, Allocator, ExtractKey,\n-\t\t\t\t\t   Equal, H1, H2, H, RehashPolicy,\n-\t\t\t\t\t   cache_hash_code, constant_iterators,\n-\t\t\t\t\t   unique_keys> >,\n-      public detail::hash_code_base<Key, Value, ExtractKey, Equal, H1, H2, H,\n-\t\t\t\t    cache_hash_code>,\n-      public detail::map_base<Key, Value, ExtractKey, unique_keys,\n-\t\t\t      hashtable<Key, Value, Allocator, ExtractKey,\n-\t\t\t\t\tEqual, H1, H2, H, RehashPolicy,\n-\t\t\t\t\tcache_hash_code, constant_iterators,\n-\t\t\t\t\tunique_keys> >\n+  template<typename _Key, typename _Value, typename _Allocator,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, \n+\t   typename _RehashPolicy,\n+\t   bool __cache_hash_code,\n+\t   bool __constant_iterators,\n+\t   bool __unique_keys>\n+    class _Hashtable\n+    : public __detail::_Rehash_base<_RehashPolicy,\n+\t\t\t\t    _Hashtable<_Key, _Value, _Allocator,\n+\t\t\t\t\t       _ExtractKey,\n+\t\t\t\t\t       _Equal, _H1, _H2, _Hash,\n+\t\t\t\t\t       _RehashPolicy,\n+\t\t\t\t\t       __cache_hash_code,\n+\t\t\t\t\t       __constant_iterators,\n+\t\t\t\t\t       __unique_keys> >,\n+      public __detail::_Hash_code_base<_Key, _Value, _ExtractKey, _Equal,\n+\t\t\t\t       _H1, _H2, _Hash, __cache_hash_code>,\n+      public __detail::_Map_base<_Key, _Value, _ExtractKey, __unique_keys,\n+\t\t\t\t _Hashtable<_Key, _Value, _Allocator,\n+\t\t\t\t\t    _ExtractKey,\n+\t\t\t\t\t    _Equal, _H1, _H2, _Hash,\n+\t\t\t\t\t    _RehashPolicy,\n+\t\t\t\t\t    __cache_hash_code,\n+\t\t\t\t\t    __constant_iterators,\n+\t\t\t\t\t    __unique_keys> >\n     {\n     public:\n-      typedef Allocator                                   allocator_type;\n-      typedef Value                                       value_type;\n-      typedef Key                                         key_type;\n-      typedef Equal                                       key_equal;\n+      typedef _Allocator                                  allocator_type;\n+      typedef _Value                                      value_type;\n+      typedef _Key                                        key_type;\n+      typedef _Equal                                      key_equal;\n       // mapped_type, if present, comes from map_base.\n       // hasher, if present, comes from hash_code_base.\n-      typedef typename Allocator::difference_type         difference_type;\n-      typedef typename Allocator::size_type               size_type;\n-      typedef typename Allocator::reference               reference;\n-      typedef typename Allocator::const_reference         const_reference;\n+      typedef typename _Allocator::difference_type        difference_type;\n+      typedef typename _Allocator::size_type              size_type;\n+      typedef typename _Allocator::reference              reference;\n+      typedef typename _Allocator::const_reference        const_reference;\n       \n-      typedef detail::node_iterator<value_type, constant_iterators,\n-\t\t\t\t      cache_hash_code>\n+      typedef __detail::_Node_iterator<value_type, __constant_iterators,\n+\t\t\t\t       __cache_hash_code>\n                                                           local_iterator;\n-      typedef detail::node_const_iterator<value_type, constant_iterators,\n-\t\t\t\t\t    cache_hash_code>\n+      typedef __detail::_Node_const_iterator<value_type,\n+\t\t\t\t\t     __constant_iterators,\n+\t\t\t\t\t     __cache_hash_code>\n                                                           const_local_iterator;\n \n-      typedef detail::hashtable_iterator<value_type, constant_iterators,\n-\t\t\t\t\t   cache_hash_code>\n+      typedef __detail::_Hashtable_iterator<value_type, __constant_iterators,\n+\t\t\t\t\t    __cache_hash_code>\n                                                           iterator;\n-      typedef detail::hashtable_const_iterator<value_type, constant_iterators,\n-\t\t\t\t\t\t cache_hash_code>\n+      typedef __detail::_Hashtable_const_iterator<value_type,\n+\t\t\t\t\t\t  __constant_iterators,\n+\t\t\t\t\t\t  __cache_hash_code>\n                                                           const_iterator;\n \n-      template<typename K, typename Pair, typename Hashtable>\n-        friend struct detail::map_base;\n+      template<typename _Key2, typename _Pair, typename _Hashtable>\n+        friend struct __detail::_Map_base;\n \n     private:\n-      typedef detail::hash_node<Value, cache_hash_code> node;\n-      typedef typename Allocator::template rebind<node>::other\n-                                                          node_allocator_t;\n-      typedef typename Allocator::template rebind<node*>::other\n-                                                          bucket_allocator_t;\n-\n-      node_allocator_t      m_node_allocator;\n-      node**                m_buckets;\n-      size_type             m_bucket_count;\n-      size_type             m_element_count;\n-      RehashPolicy          m_rehash_policy;\n+      typedef __detail::_Hash_node<_Value, __cache_hash_code> _Node;\n+      typedef typename _Allocator::template rebind<_Node>::other\n+                                                        _Node_allocator_type;\n+      typedef typename _Allocator::template rebind<_Node*>::other\n+                                                        _Bucket_allocator_type;\n+\n+      _Node_allocator_type   _M_node_allocator;\n+      _Node**                _M_buckets;\n+      size_type              _M_bucket_count;\n+      size_type              _M_element_count;\n+      _RehashPolicy          _M_rehash_policy;\n       \n-      node*\n-      m_allocate_node(const value_type& v);\n+      _Node*\n+      _M_allocate_node(const value_type& __v);\n   \n       void\n-      m_deallocate_node(node* n);\n+      _M_deallocate_node(_Node* __n);\n   \n       void\n-      m_deallocate_nodes(node**, size_type);\n+      _M_deallocate_nodes(_Node**, size_type);\n \n-      node**\n-      m_allocate_buckets(size_type n);\n+      _Node**\n+      _M_allocate_buckets(size_type __n);\n   \n       void\n-      m_deallocate_buckets(node**, size_type n);\n+      _M_deallocate_buckets(_Node**, size_type __n);\n \n     public:\t\t\t    \n       // Constructor, destructor, assignment, swap\n-      hashtable(size_type bucket_hint,\n-\t\tconst H1&, const H2&, const H&,\n-\t\tconst Equal&, const ExtractKey&,\n-\t\tconst allocator_type&);\n+      _Hashtable(size_type __bucket_hint,\n+\t\t const _H1&, const _H2&, const _Hash&,\n+\t\t const _Equal&, const _ExtractKey&,\n+\t\t const allocator_type&);\n   \n-      template<typename InIter>\n-        hashtable(InIter first, InIter last,\n-\t\t  size_type bucket_hint,\n-\t\t  const H1&, const H2&, const H&, \n-\t\t  const Equal&, const ExtractKey&,\n-\t\t  const allocator_type&);\n+      template<typename _InputIterator>\n+        _Hashtable(_InputIterator __first, _InputIterator __last,\n+\t\t   size_type __bucket_hint,\n+\t\t   const _H1&, const _H2&, const _Hash&, \n+\t\t   const _Equal&, const _ExtractKey&,\n+\t\t   const allocator_type&);\n   \n-      hashtable(const hashtable&);\n+      _Hashtable(const _Hashtable&);\n       \n-      hashtable&\n-      operator=(const hashtable&);\n+      _Hashtable&\n+      operator=(const _Hashtable&);\n   \n-      ~hashtable();\n+      ~_Hashtable();\n \n-      void swap(hashtable&);\n+      void swap(_Hashtable&);\n \n       // Basic container operations\n       iterator\n       begin()\n       {\n-\titerator i(m_buckets);\n-\tif (!i.m_cur_node)\n-\t  i.m_incr_bucket();\n-\treturn i;\n+\titerator __i(_M_buckets);\n+\tif (!__i._M_cur_node)\n+\t  __i._M_incr_bucket();\n+\treturn __i;\n       }\n \n       const_iterator\n       begin() const\n       {\n-\tconst_iterator i(m_buckets);\n-\tif (!i.m_cur_node)\n-\t  i.m_incr_bucket();\n-\treturn i;\n+\tconst_iterator __i(_M_buckets);\n+\tif (!__i._M_cur_node)\n+\t  __i._M_incr_bucket();\n+\treturn __i;\n       }\n \n       iterator\n       end()\n-      { return iterator(m_buckets + m_bucket_count); }\n+      { return iterator(_M_buckets + _M_bucket_count); }\n \n       const_iterator\n       end() const\n-      { return const_iterator(m_buckets + m_bucket_count); }\n+      { return const_iterator(_M_buckets + _M_bucket_count); }\n \n       size_type\n       size() const\n-      { return m_element_count; }\n+      { return _M_element_count; }\n   \n       bool\n       empty() const\n       { return size() == 0; }\n \n       allocator_type\n       get_allocator() const\n-      { return m_node_allocator; }\n+      { return _M_node_allocator; }\n   \n       size_type\n       max_size() const\n-      { return m_node_allocator.max_size(); }\n+      { return _M_node_allocator.max_size(); }\n \n       // Observers\n       key_equal\n       key_eq() const\n-      { return this->m_eq; }\n+      { return this->_M_eq; }\n \n-      // hash_function, if present, comes from hash_code_base.\n+      // hash_function, if present, comes from _Hash_code_base.\n \n       // Bucket operations\n       size_type\n       bucket_count() const\n-      { return m_bucket_count; }\n+      { return _M_bucket_count; }\n   \n       size_type\n       max_bucket_count() const\n       { return max_size(); }\n   \n       size_type\n-      bucket_size(size_type n) const\n-      { return std::distance(begin(n), end(n)); }\n+      bucket_size(size_type __n) const\n+      { return std::distance(begin(__n), end(__n)); }\n   \n       size_type\n-      bucket(const key_type& k) const\n+      bucket(const key_type& __k) const\n       { \n-\treturn this->bucket_index(k, this->m_hash_code(k),\n-\t\t\t\t  this->m_bucket_count);\n+\treturn this->_M_bucket_index(__k, this->_M_hash_code(__k),\n+\t\t\t\t     bucket_count());\n       }\n \n       local_iterator\n-      begin(size_type n)\n-      { return local_iterator(m_buckets[n]); }\n+      begin(size_type __n)\n+      { return local_iterator(_M_buckets[__n]); }\n   \n       local_iterator\n       end(size_type)\n       { return local_iterator(0); }\n   \n       const_local_iterator\n-      begin(size_type n) const\n-      { return const_local_iterator(m_buckets[n]); }\n+      begin(size_type __n) const\n+      { return const_local_iterator(_M_buckets[__n]); }\n   \n       const_local_iterator\n       end(size_type) const\n@@ -315,82 +323,83 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \treturn static_cast<float>(size()) / static_cast<float>(bucket_count());\n       }\n \n-      // max_load_factor, if present, comes from rehash_base.\n+      // max_load_factor, if present, comes from _Rehash_base.\n \n       // Generalization of max_load_factor.  Extension, not found in TR1.  Only\n-      // useful if RehashPolicy is something other than the default.\n-      const RehashPolicy&\n-      rehash_policy() const\n-      { return m_rehash_policy; }\n+      // useful if _RehashPolicy is something other than the default.\n+      const _RehashPolicy&\n+      __rehash_policy() const\n+      { return _M_rehash_policy; }\n       \n       void \n-      rehash_policy(const RehashPolicy&);\n+      __rehash_policy(const _RehashPolicy&);\n \n       // Lookup.\n       iterator\n-      find(const key_type& k);\n+      find(const key_type& __k);\n \n       const_iterator\n-      find(const key_type& k) const;\n+      find(const key_type& __k) const;\n \n       size_type\n-      count(const key_type& k) const;\n+      count(const key_type& __k) const;\n \n       std::pair<iterator, iterator>\n-      equal_range(const key_type& k);\n+      equal_range(const key_type& __k);\n \n       std::pair<const_iterator, const_iterator>\n-      equal_range(const key_type& k) const;\n+      equal_range(const key_type& __k) const;\n \n     private:\t\t\t// Find, insert and erase helper functions\n       // ??? This dispatching is a workaround for the fact that we don't\n       // have partial specialization of member templates; it would be\n-      // better to just specialize insert on unique_keys.  There may be a\n+      // better to just specialize insert on __unique_keys.  There may be a\n       // cleaner workaround.\n-      typedef typename __gnu_cxx::__conditional_type<unique_keys,\n+      typedef typename __gnu_cxx::__conditional_type<__unique_keys,\n \t\t       \t    std::pair<iterator, bool>, iterator>::__type\n-        Insert_Return_Type;\n+        _Insert_Return_Type;\n \n-      typedef typename __gnu_cxx::__conditional_type<unique_keys,\n-\t\t\t\t\t   std::_Select1st<Insert_Return_Type>,\n-\t\t\t\t  \t   std::_Identity<Insert_Return_Type>\n+      typedef typename __gnu_cxx::__conditional_type<__unique_keys,\n+\t\t\t\t\t  std::_Select1st<_Insert_Return_Type>,\n+\t\t\t\t  \t  std::_Identity<_Insert_Return_Type>\n                                    >::__type\n-        Insert_Conv_Type;\n+        _Insert_Conv_Type;\n \n-      node*\n-      m_find_node(node*, const key_type&,\n-\t\t  typename hashtable::hash_code_t) const;\n+      _Node*\n+      _M_find_node(_Node*, const key_type&,\n+\t\t   typename _Hashtable::_Hash_code_type) const;\n \n       iterator\n-      m_insert_bucket(const value_type&, size_type,\n-\t\t      typename hashtable::hash_code_t);\n+      _M_insert_bucket(const value_type&, size_type,\n+\t\t       typename _Hashtable::_Hash_code_type);\n \n       std::pair<iterator, bool>\n-      m_insert(const value_type&, std::tr1::true_type);\n+      _M_insert(const value_type&, std::tr1::true_type);\n \n       iterator\n-      m_insert(const value_type&, std::tr1::false_type);\n+      _M_insert(const value_type&, std::tr1::false_type);\n \n       void\n-      m_erase_node(node*, node**);\n+      _M_erase_node(_Node*, _Node**);\n \n     public:\t\t\t\t\n       // Insert and erase\n-      Insert_Return_Type\n-      insert(const value_type& v) \n-      { return m_insert(v, std::tr1::integral_constant<bool, unique_keys>()); }\n+      _Insert_Return_Type\n+      insert(const value_type& __v) \n+      { return _M_insert(__v, std::tr1::integral_constant<bool,\n+\t\t\t __unique_keys>()); }\n \n       iterator\n-      insert(iterator, const value_type& v)\n-      { return iterator(Insert_Conv_Type()(this->insert(v))); }\n+      insert(iterator, const value_type& __v)\n+      { return iterator(_Insert_Conv_Type()(this->insert(__v))); }\n \n       const_iterator\n-      insert(const_iterator, const value_type& v)\n-      { return const_iterator(Insert_Conv_Type()(this->insert(v))); }\n+      insert(const_iterator, const value_type& __v)\n+      { return const_iterator(_Insert_Conv_Type()(this->insert(__v))); }\n \n-      template<typename InIter>\n+      template<typename _InputIterator>\n         void\n-        insert(InIter first, InIter last);\n+        insert(_InputIterator __first, _InputIterator __last);\n \n       iterator\n       erase(iterator);\n@@ -411,672 +420,749 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n       clear();\n \n       // Set number of buckets to be appropriate for container of n element.\n-      void rehash(size_type n);\n+      void rehash(size_type __n);\n       \n     private:\n       // Unconditionally change size of bucket array to n.\n-      void m_rehash(size_type n);\n+      void _M_rehash(size_type __n);\n     };\n \n \n-  // Definitions of class template hashtable's out-of-line member functions.\n-  template<typename K, typename V, \n-\t   typename A, typename Ex, typename Eq,\n-\t   typename H1, typename H2, typename H, typename RP,\n-\t   bool c, bool ci, bool u>\n-    typename hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::node*\n-    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n-    m_allocate_node(const value_type& v)\n+  // Definitions of class template _Hashtable's out-of-line member functions.\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n+\t\t\t__chc, __cit, __uk>::_Node*\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    _M_allocate_node(const value_type& __v)\n     {\n-      node* n = m_node_allocator.allocate(1);\n+      _Node* __n = _M_node_allocator.allocate(1);\n       try\n \t{\n-\t  get_allocator().construct(&n->m_v, v);\n-\t  n->m_next = 0;\n-\t  return n;\n+\t  get_allocator().construct(&__n->_M_v, __v);\n+\t  __n->_M_next = 0;\n+\t  return __n;\n \t}\n       catch(...)\n \t{\n-\t  m_node_allocator.deallocate(n, 1);\n+\t  _M_node_allocator.deallocate(__n, 1);\n \t  __throw_exception_again;\n \t}\n     }\n \n-  template<typename K, typename V, \n-\t   typename A, typename Ex, typename Eq,\n-\t   typename H1, typename H2, typename H, typename RP,\n-\t   bool c, bool ci, bool u>\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n     void\n-    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n-    m_deallocate_node(node* n)\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    _M_deallocate_node(_Node* __n)\n     {\n-      get_allocator().destroy(&n->m_v);\n-      m_node_allocator.deallocate(n, 1);\n+      get_allocator().destroy(&__n->_M_v);\n+      _M_node_allocator.deallocate(__n, 1);\n     }\n \n-  template<typename K, typename V, \n-\t   typename A, typename Ex, typename Eq,\n-\t   typename H1, typename H2, typename H, typename RP,\n-\t   bool c, bool ci, bool u>\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n     void\n-    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n-    m_deallocate_nodes(node** array, size_type n)\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    _M_deallocate_nodes(_Node** __array, size_type __n)\n     {\n-      for (size_type i = 0; i < n; ++i)\n+      for (size_type __i = 0; __i < __n; ++__i)\n \t{\n-\t  node* p = array[i];\n-\t  while (p)\n+\t  _Node* __p = __array[__i];\n+\t  while (__p)\n \t    {\n-\t      node* tmp = p;\n-\t      p = p->m_next;\n-\t      m_deallocate_node(tmp);\n+\t      _Node* __tmp = __p;\n+\t      __p = __p->_M_next;\n+\t      _M_deallocate_node(__tmp);\n \t    }\n-\t  array[i] = 0;\n+\t  __array[__i] = 0;\n \t}\n     }\n \n-  template<typename K, typename V, \n-\t   typename A, typename Ex, typename Eq,\n-\t   typename H1, typename H2, typename H, typename RP,\n-\t   bool c, bool ci, bool u>\n-    typename hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::node**\n-    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n-    m_allocate_buckets(size_type n)\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n+\t\t\t__chc, __cit, __uk>::_Node**\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    _M_allocate_buckets(size_type __n)\n     {\n-      bucket_allocator_t alloc(m_node_allocator);\n+      _Bucket_allocator_type __alloc(_M_node_allocator);\n \n       // We allocate one extra bucket to hold a sentinel, an arbitrary\n       // non-null pointer.  Iterator increment relies on this.\n-      node** p = alloc.allocate(n + 1);\n-      std::fill(p, p + n, (node*) 0);\n-      p[n] = reinterpret_cast<node*>(0x1000);\n-      return p;\n+      _Node** __p = __alloc.allocate(__n + 1);\n+      std::fill(__p, __p + __n, (_Node*) 0);\n+      __p[__n] = reinterpret_cast<_Node*>(0x1000);\n+      return __p;\n     }\n \n-  template<typename K, typename V, \n-\t   typename A, typename Ex, typename Eq,\n-\t   typename H1, typename H2, typename H, typename RP,\n-\t   bool c, bool ci, bool u>\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n     void\n-    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n-    m_deallocate_buckets(node** p, size_type n)\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    _M_deallocate_buckets(_Node** __p, size_type __n)\n     {\n-      bucket_allocator_t alloc(m_node_allocator);\n-      alloc.deallocate(p, n + 1);\n+      _Bucket_allocator_type __alloc(_M_node_allocator);\n+      __alloc.deallocate(__p, __n + 1);\n     }\n \n-  template<typename K, typename V, \n-\t   typename A, typename Ex, typename Eq,\n-\t   typename H1, typename H2, typename H, typename RP,\n-\t   bool c, bool ci, bool u>\n-    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n-    hashtable(size_type bucket_hint,\n-\t      const H1& h1, const H2& h2, const H& h,\n-\t      const Eq& eq, const Ex& exk,\n-\t      const allocator_type& a)\n-    : detail::rehash_base<RP, hashtable>(),\n-      detail::hash_code_base<K, V, Ex, Eq, H1, H2, H, c>(exk, eq, h1, h2, h),\n-      detail::map_base<K, V, Ex, u, hashtable>(),\n-      m_node_allocator(a),\n-      m_bucket_count(0),\n-      m_element_count(0),\n-      m_rehash_policy()\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    _Hashtable(size_type __bucket_hint,\n+\t       const _H1& __h1, const _H2& __h2, const _Hash& __h,\n+\t       const _Equal& __eq, const _ExtractKey& __exk,\n+\t       const allocator_type& __a)\n+    : __detail::_Rehash_base<_RehashPolicy, _Hashtable>(),\n+      __detail::_Hash_code_base<_Key, _Value, _ExtractKey, _Equal,\n+\t\t\t\t_H1, _H2, _Hash, __chc>(__exk, __eq,\n+\t\t\t\t\t\t\t__h1, __h2, __h),\n+      __detail::_Map_base<_Key, _Value, _ExtractKey, __uk, _Hashtable>(),\n+      _M_node_allocator(__a),\n+      _M_bucket_count(0),\n+      _M_element_count(0),\n+      _M_rehash_policy()\n     {\n-      m_bucket_count = m_rehash_policy.next_bkt(bucket_hint);\n-      m_buckets = m_allocate_buckets(m_bucket_count);\n+      _M_bucket_count = _M_rehash_policy._M_next_bkt(__bucket_hint);\n+      _M_buckets = _M_allocate_buckets(_M_bucket_count);\n     }\n \n-  template<typename K, typename V, \n-\t   typename A, typename Ex, typename Eq,\n-\t   typename H1, typename H2, typename H, typename RP,\n-\t   bool c, bool ci, bool u>\n-    template<typename InIter>\n-      hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n-      hashtable(InIter f, InIter l,\n-\t\tsize_type bucket_hint,\n-\t\tconst H1& h1, const H2& h2, const H& h,\n-\t\tconst Eq& eq, const Ex& exk,\n-\t\tconst allocator_type& a)\n-      : detail::rehash_base<RP, hashtable>(),\n-\tdetail::hash_code_base<K, V, Ex, Eq, H1, H2, H, c>(exk, eq,\n-\t\t\t\t\t\t\t     h1, h2, h),\n-\tdetail::map_base<K, V, Ex, u, hashtable>(),\n-\tm_node_allocator(a),\n-\tm_bucket_count(0),\n-\tm_element_count(0),\n-\tm_rehash_policy()\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    template<typename _InputIterator>\n+      _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t\t _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+      _Hashtable(_InputIterator __f, _InputIterator __l,\n+\t\tsize_type __bucket_hint,\n+\t\tconst _H1& __h1, const _H2& __h2, const _Hash& __h,\n+\t\tconst _Equal& __eq, const _ExtractKey& __exk,\n+\t\tconst allocator_type& __a)\n+      : __detail::_Rehash_base<_RehashPolicy, _Hashtable>(),\n+\t__detail::_Hash_code_base<_Key, _Value, _ExtractKey, _Equal,\n+\t\t\t\t  _H1, _H2, _Hash, __chc>(__exk, __eq,\n+\t\t\t\t\t\t\t  __h1, __h2, __h),\n+\t__detail::_Map_base<_Key, _Value, _ExtractKey, __uk, _Hashtable>(),\n+\t_M_node_allocator(__a),\n+\t_M_bucket_count(0),\n+\t_M_element_count(0),\n+\t_M_rehash_policy()\n       {\n-\tm_bucket_count = std::max(m_rehash_policy.next_bkt(bucket_hint),\n-\t\t\t\t  m_rehash_policy.\n-\t\t\t\t  bkt_for_elements(detail::\n-\t\t\t\t\t\t   distance_fw(f, l)));\n-\tm_buckets = m_allocate_buckets(m_bucket_count);\n+\t_M_bucket_count = std::max(_M_rehash_policy._M_next_bkt(__bucket_hint),\n+\t\t\t\t   _M_rehash_policy.\n+\t\t\t\t   _M_bkt_for_elements(__detail::\n+\t\t\t\t\t\t       __distance_fw(__f,\n+\t\t\t\t\t\t\t\t     __l)));\n+\t_M_buckets = _M_allocate_buckets(_M_bucket_count);\n \ttry\n \t  {\n-\t    for (; f != l; ++f)\n-\t      this->insert(*f);\n+\t    for (; __f != __l; ++__f)\n+\t      this->insert(*__f);\n \t  }\n \tcatch(...)\n \t  {\n \t    clear();\n-\t    m_deallocate_buckets(m_buckets, m_bucket_count);\n+\t    _M_deallocate_buckets(_M_buckets, _M_bucket_count);\n \t    __throw_exception_again;\n \t  }\n       }\n   \n-  template<typename K, typename V, \n-\t   typename A, typename Ex, typename Eq,\n-\t   typename H1, typename H2, typename H, typename RP,\n-\t   bool c, bool ci, bool u>\n-    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n-    hashtable(const hashtable& ht)\n-    : detail::rehash_base<RP, hashtable>(ht),\n-      detail::hash_code_base<K, V, Ex, Eq, H1, H2, H, c>(ht),\n-      detail::map_base<K, V, Ex, u, hashtable>(ht),\n-      m_node_allocator(ht.get_allocator()),\n-      m_bucket_count(ht.m_bucket_count),\n-      m_element_count(ht.m_element_count),\n-      m_rehash_policy(ht.m_rehash_policy)\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    _Hashtable(const _Hashtable& __ht)\n+    : __detail::_Rehash_base<_RehashPolicy, _Hashtable>(__ht),\n+      __detail::_Hash_code_base<_Key, _Value, _ExtractKey, _Equal,\n+\t\t\t\t_H1, _H2, _Hash, __chc>(__ht),\n+      __detail::_Map_base<_Key, _Value, _ExtractKey, __uk, _Hashtable>(__ht),\n+      _M_node_allocator(__ht.get_allocator()),\n+      _M_bucket_count(__ht._M_bucket_count),\n+      _M_element_count(__ht._M_element_count),\n+      _M_rehash_policy(__ht._M_rehash_policy)\n     {\n-      m_buckets = m_allocate_buckets(m_bucket_count);\n+      _M_buckets = _M_allocate_buckets(_M_bucket_count);\n       try\n \t{\n-\t  for (size_type i = 0; i < ht.m_bucket_count; ++i)\n+\t  for (size_type __i = 0; __i < __ht._M_bucket_count; ++__i)\n \t    {\n-\t      node* n = ht.m_buckets[i];\n-\t      node** tail = m_buckets + i;\n-\t      while (n)\n+\t      _Node* __n = __ht._M_buckets[__i];\n+\t      _Node** __tail = _M_buckets + __i;\n+\t      while (__n)\n \t\t{\n-\t\t  *tail = m_allocate_node(n->m_v);\n-\t\t  this->copy_code(*tail, n);\n-\t\t  tail = &((*tail)->m_next);\n-\t\t  n = n->m_next;\n+\t\t  *__tail = _M_allocate_node(__n->_M_v);\n+\t\t  this->_M_copy_code(*__tail, __n);\n+\t\t  __tail = &((*__tail)->_M_next);\n+\t\t  __n = __n->_M_next;\n \t\t}\n \t    }\n \t}\n       catch(...)\n \t{\n \t  clear();\n-\t  m_deallocate_buckets(m_buckets, m_bucket_count);\n+\t  _M_deallocate_buckets(_M_buckets, _M_bucket_count);\n \t  __throw_exception_again;\n \t}\n     }\n \n-  template<typename K, typename V, \n-\t   typename A, typename Ex, typename Eq,\n-\t   typename H1, typename H2, typename H, typename RP,\n-\t   bool c, bool ci, bool u>\n-    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>&\n-    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n-    operator=(const hashtable& ht)\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>&\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    operator=(const _Hashtable& __ht)\n     {\n-      hashtable tmp(ht);\n-      this->swap(tmp);\n+      _Hashtable __tmp(__ht);\n+      this->swap(__tmp);\n       return *this;\n     }\n \n-  template<typename K, typename V, \n-\t   typename A, typename Ex, typename Eq,\n-\t   typename H1, typename H2, typename H, typename RP,\n-\t   bool c, bool ci, bool u>\n-    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n-    ~hashtable()\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    ~_Hashtable()\n     {\n       clear();\n-      m_deallocate_buckets(m_buckets, m_bucket_count);\n+      _M_deallocate_buckets(_M_buckets, _M_bucket_count);\n     }\n \n-  template<typename K, typename V, \n-\t   typename A, typename Ex, typename Eq,\n-\t   typename H1, typename H2, typename H, typename RP,\n-\t   bool c, bool ci, bool u>\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n     void\n-    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n-    swap(hashtable& x)\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    swap(_Hashtable& __x)\n     {\n       // The only base class with member variables is hash_code_base.  We\n-      // define hash_code_base::m_swap because different specializations\n+      // define _Hash_code_base::_M_swap because different specializations\n       // have different members.\n-      detail::hash_code_base<K, V, Ex, Eq, H1, H2, H, c>::m_swap(x);\n+      __detail::_Hash_code_base<_Key, _Value, _ExtractKey, _Equal,\n+\t_H1, _H2, _Hash, __chc>::_M_swap(__x);\n \n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // 431. Swapping containers with unequal allocators.\n-      std::__alloc_swap<node_allocator_t>::_S_do_it(m_node_allocator,\n-\t\t\t\t\t\t    x.m_node_allocator);\n+      std::__alloc_swap<_Node_allocator_type>::_S_do_it(_M_node_allocator,\n+\t\t\t\t\t\t\t__x._M_node_allocator);\n \n-      std::swap(m_rehash_policy, x.m_rehash_policy);\n-      std::swap(m_buckets, x.m_buckets);\n-      std::swap(m_bucket_count, x.m_bucket_count);\n-      std::swap(m_element_count, x.m_element_count);\n+      std::swap(_M_rehash_policy, __x._M_rehash_policy);\n+      std::swap(_M_buckets, __x._M_buckets);\n+      std::swap(_M_bucket_count, __x._M_bucket_count);\n+      std::swap(_M_element_count, __x._M_element_count);\n     }\n \n-  template<typename K, typename V, \n-\t   typename A, typename Ex, typename Eq,\n-\t   typename H1, typename H2, typename H, typename RP,\n-\t   bool c, bool ci, bool u>\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n     void\n-    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n-    rehash_policy(const RP& pol)\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    __rehash_policy(const _RehashPolicy& __pol)\n     {\n-      m_rehash_policy = pol;\n-      size_type n_bkt = pol.bkt_for_elements(m_element_count);\n-      if (n_bkt > m_bucket_count)\n-\tm_rehash(n_bkt);\n+      _M_rehash_policy = __pol;\n+      size_type __n_bkt = __pol._M_bkt_for_elements(_M_element_count);\n+      if (__n_bkt > _M_bucket_count)\n+\t_M_rehash(__n_bkt);\n     }\n \n-  template<typename K, typename V, \n-\t   typename A, typename Ex, typename Eq,\n-\t   typename H1, typename H2, typename H, typename RP,\n-\t   bool c, bool ci, bool u>\n-    typename hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::iterator\n-    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n-    find(const key_type& k)\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n+\t\t\t__chc, __cit, __uk>::iterator\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    find(const key_type& __k)\n     {\n-      typename hashtable::hash_code_t code = this->m_hash_code(k);\n-      std::size_t n = this->bucket_index(k, code, this->bucket_count());\n-      node* p = m_find_node(m_buckets[n], k, code);\n-      return p ? iterator(p, m_buckets + n) : this->end();\n+      typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);\n+      std::size_t __n = this->_M_bucket_index(__k, __code, _M_bucket_count);\n+      _Node* __p = _M_find_node(_M_buckets[__n], __k, __code);\n+      return __p ? iterator(__p, _M_buckets + __n) : this->end();\n     }\n \n-  template<typename K, typename V, \n-\t   typename A, typename Ex, typename Eq,\n-\t   typename H1, typename H2, typename H, typename RP,\n-\t   bool c, bool ci, bool u>\n-    typename hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::const_iterator\n-    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n-    find(const key_type& k) const\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n+\t\t\t__chc, __cit, __uk>::const_iterator\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    find(const key_type& __k) const\n     {\n-      typename hashtable::hash_code_t code = this->m_hash_code(k);\n-      std::size_t n = this->bucket_index(k, code, this->bucket_count());\n-      node* p = m_find_node(m_buckets[n], k, code);\n-      return p ? const_iterator(p, m_buckets + n) : this->end();\n+      typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);\n+      std::size_t __n = this->_M_bucket_index(__k, __code, _M_bucket_count);\n+      _Node* __p = _M_find_node(_M_buckets[__n], __k, __code);\n+      return __p ? const_iterator(__p, _M_buckets + __n) : this->end();\n     }\n \n-  template<typename K, typename V, \n-\t   typename A, typename Ex, typename Eq,\n-\t   typename H1, typename H2, typename H, typename RP,\n-\t   bool c, bool ci, bool u>\n-    typename hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::size_type\n-    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n-    count(const key_type& k) const\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n+\t\t\t__chc, __cit, __uk>::size_type\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    count(const key_type& __k) const\n     {\n-      typename hashtable::hash_code_t code = this->m_hash_code(k);\n-      std::size_t n = this->bucket_index(k, code, this->bucket_count());\n-      std::size_t result = 0;\n-      for (node* p = m_buckets[n]; p; p = p->m_next)\n-\tif (this->compare(k, code, p))\n-\t  ++result;\n-      return result;\n+      typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);\n+      std::size_t __n = this->_M_bucket_index(__k, __code, _M_bucket_count);\n+      std::size_t __result = 0;\n+      for (_Node* __p = _M_buckets[__n]; __p; __p = __p->_M_next)\n+\tif (this->_M_compare(__k, __code, __p))\n+\t  ++__result;\n+      return __result;\n     }\n \n-  template<typename K, typename V, \n-\t   typename A, typename Ex, typename Eq,\n-\t   typename H1, typename H2, typename H, typename RP,\n-\t   bool c, bool ci, bool u>\n-    std::pair<typename hashtable<K, V, A, Ex, Eq, H1,\n-\t\t\t\t H2, H, RP, c, ci, u>::iterator,\n-\t      typename hashtable<K, V, A, Ex, Eq, H1,\n-\t\t\t\t H2, H, RP, c, ci, u>::iterator>\n-    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n-    equal_range(const key_type& k)\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    std::pair<typename _Hashtable<_Key, _Value, _Allocator,\n+\t\t\t\t  _ExtractKey, _Equal, _H1,\n+\t\t\t\t  _H2, _Hash, _RehashPolicy,\n+\t\t\t\t  __chc, __cit, __uk>::iterator,\n+\t      typename _Hashtable<_Key, _Value, _Allocator,\n+\t\t\t\t  _ExtractKey, _Equal, _H1,\n+\t\t\t\t  _H2, _Hash, _RehashPolicy,\n+\t\t\t\t  __chc, __cit, __uk>::iterator>\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    equal_range(const key_type& __k)\n     {\n-      typename hashtable::hash_code_t code = this->m_hash_code(k);\n-      std::size_t n = this->bucket_index(k, code, this->bucket_count());\n-      node** head = m_buckets + n;\n-      node* p = m_find_node(*head, k, code);\n+      typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);\n+      std::size_t __n = this->_M_bucket_index(__k, __code, _M_bucket_count);\n+      _Node** __head = _M_buckets + __n;\n+      _Node* __p = _M_find_node(*__head, __k, __code);\n       \n-      if (p)\n+      if (__p)\n \t{\n-\t  node* p1 = p->m_next;\n-\t  for (; p1; p1 = p1->m_next)\n-\t    if (!this->compare(k, code, p1))\n+\t  _Node* __p1 = __p->_M_next;\n+\t  for (; __p1; __p1 = __p1->_M_next)\n+\t    if (!this->_M_compare(__k, __code, __p1))\n \t      break;\n \n-\t  iterator first(p, head);\n-\t  iterator last(p1, head);\n-\t  if (!p1)\n-\t    last.m_incr_bucket();\n-\t  return std::make_pair(first, last);\n+\t  iterator __first(__p, __head);\n+\t  iterator __last(__p1, __head);\n+\t  if (!__p1)\n+\t    __last._M_incr_bucket();\n+\t  return std::make_pair(__first, __last);\n \t}\n       else\n \treturn std::make_pair(this->end(), this->end());\n     }\n \n-  template<typename K, typename V, \n-\t   typename A, typename Ex, typename Eq,\n-\t   typename H1, typename H2, typename H, typename RP,\n-\t   bool c, bool ci, bool u>\n-    std::pair<typename hashtable<K, V, A, Ex, Eq, H1,\n-\t\t\t\t H2, H, RP, c, ci, u>::const_iterator,\n-\t      typename hashtable<K, V, A, Ex, Eq, H1,\n-\t\t\t\t H2, H, RP, c, ci, u>::const_iterator>\n-    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n-    equal_range(const key_type& k) const\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    std::pair<typename _Hashtable<_Key, _Value, _Allocator,\n+\t\t\t\t  _ExtractKey, _Equal, _H1,\n+\t\t\t\t  _H2, _Hash, _RehashPolicy,\n+\t\t\t\t  __chc, __cit, __uk>::const_iterator,\n+\t      typename _Hashtable<_Key, _Value, _Allocator,\n+\t\t\t\t  _ExtractKey, _Equal, _H1,\n+\t\t\t\t  _H2, _Hash, _RehashPolicy,\n+\t\t\t\t  __chc, __cit, __uk>::const_iterator>\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    equal_range(const key_type& __k) const\n     {\n-      typename hashtable::hash_code_t code = this->m_hash_code(k);\n-      std::size_t n = this->bucket_index(k, code, this->bucket_count());\n-      node** head = m_buckets + n;\n-      node* p = m_find_node(*head, k, code);\n+      typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);\n+      std::size_t __n = this->_M_bucket_index(__k, __code, _M_bucket_count);\n+      _Node** __head = _M_buckets + __n;\n+      _Node* __p = _M_find_node(*__head, __k, __code);\n \n-      if (p)\n+      if (__p)\n \t{\n-\t  node* p1 = p->m_next;\n-\t  for (; p1; p1 = p1->m_next)\n-\t    if (!this->compare(k, code, p1))\n+\t  _Node* __p1 = __p->_M_next;\n+\t  for (; __p1; __p1 = __p1->_M_next)\n+\t    if (!this->_M_compare(__k, __code, __p1))\n \t      break;\n \n-\t  const_iterator first(p, head);\n-\t  const_iterator last(p1, head);\n-\t  if (!p1)\n-\t    last.m_incr_bucket();\n-\t  return std::make_pair(first, last);\n+\t  const_iterator __first(__p, __head);\n+\t  const_iterator __last(__p1, __head);\n+\t  if (!__p1)\n+\t    __last._M_incr_bucket();\n+\t  return std::make_pair(__first, __last);\n \t}\n       else\n \treturn std::make_pair(this->end(), this->end());\n     }\n \n   // Find the node whose key compares equal to k, beginning the search\n   // at p (usually the head of a bucket).  Return nil if no node is found.\n-  template<typename K, typename V, \n-\t   typename A, typename Ex, typename Eq,\n-\t   typename H1, typename H2, typename H, typename RP,\n-\t   bool c, bool ci, bool u>\n-    typename hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::node* \n-    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n-    m_find_node(node* p, const key_type& k,\n-\t\ttypename hashtable::hash_code_t code) const\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey,\n+\t\t\t_Equal, _H1, _H2, _Hash, _RehashPolicy,\n+\t\t\t__chc, __cit, __uk>::_Node* \n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    _M_find_node(_Node* __p, const key_type& __k,\n+\t\ttypename _Hashtable::_Hash_code_type __code) const\n     {\n-      for (; p; p = p->m_next)\n-\tif (this->compare(k, code, p))\n-\t  return p;\n+      for (; __p; __p = __p->_M_next)\n+\tif (this->_M_compare(__k, __code, __p))\n+\t  return __p;\n       return false;\n     }\n \n   // Insert v in bucket n (assumes no element with its key already present).\n-  template<typename K, typename V, \n-\t   typename A, typename Ex, typename Eq,\n-\t   typename H1, typename H2, typename H, typename RP,\n-\t   bool c, bool ci, bool u>\n-    typename hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::iterator\n-    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n-    m_insert_bucket(const value_type& v, size_type n,\n-\t\t    typename hashtable::hash_code_t code)\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n+\t\t\t__chc, __cit, __uk>::iterator\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    _M_insert_bucket(const value_type& __v, size_type __n,\n+\t\t    typename _Hashtable::_Hash_code_type __code)\n     {\n-      std::pair<bool, std::size_t> do_rehash\n-\t= m_rehash_policy.need_rehash(m_bucket_count, m_element_count, 1);\n+      std::pair<bool, std::size_t> __do_rehash\n+\t= _M_rehash_policy._M_need_rehash(_M_bucket_count,\n+\t\t\t\t\t  _M_element_count, 1);\n \n       // Allocate the new node before doing the rehash so that we don't\n       // do a rehash if the allocation throws.\n-      node* new_node = m_allocate_node(v);\n+      _Node* __new_node = _M_allocate_node(__v);\n \n       try\n \t{\n-\t  if (do_rehash.first)\n+\t  if (__do_rehash.first)\n \t    {\n-\t      const key_type& k = this->m_extract(v);\n-\t      n = this->bucket_index(k, code, do_rehash.second);\n-\t      m_rehash(do_rehash.second);\n+\t      const key_type& __k = this->_M_extract(__v);\n+\t      __n = this->_M_bucket_index(__k, __code, __do_rehash.second);\n+\t      _M_rehash(__do_rehash.second);\n \t    }\n \n-\t  new_node->m_next = m_buckets[n];\n-\t  this->store_code(new_node, code);\n-\t  m_buckets[n] = new_node;\n-\t  ++m_element_count;\n-\t  return iterator(new_node, m_buckets + n);\n+\t  __new_node->_M_next = _M_buckets[__n];\n+\t  this->_M_store_code(__new_node, __code);\n+\t  _M_buckets[__n] = __new_node;\n+\t  ++_M_element_count;\n+\t  return iterator(__new_node, _M_buckets + __n);\n \t}\n       catch(...)\n \t{\n-\t  m_deallocate_node(new_node);\n+\t  _M_deallocate_node(__new_node);\n \t  __throw_exception_again;\n \t}\n     }\n \n   // Insert v if no element with its key is already present.\n-  template<typename K, typename V, \n-\t   typename A, typename Ex, typename Eq,\n-\t   typename H1, typename H2, typename H, typename RP,\n-\t   bool c, bool ci, bool u>\n-    std::pair<typename hashtable<K, V, A, Ex, Eq, H1,\n-\t\t\t\t H2, H, RP, c, ci, u>::iterator, bool>\n-    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n-    m_insert(const value_type& v, std::tr1::true_type)\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    std::pair<typename _Hashtable<_Key, _Value, _Allocator,\n+\t\t\t\t  _ExtractKey, _Equal, _H1,\n+\t\t\t\t  _H2, _Hash, _RehashPolicy,\n+\t\t\t\t  __chc, __cit, __uk>::iterator, bool>\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    _M_insert(const value_type& __v, std::tr1::true_type)\n     {\n-      const key_type& k = this->m_extract(v);\n-      typename hashtable::hash_code_t code = this->m_hash_code(k);\n-      size_type n = this->bucket_index(k, code, m_bucket_count);\n+      const key_type& __k = this->_M_extract(__v);\n+      typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);\n+      size_type __n = this->_M_bucket_index(__k, __code, _M_bucket_count);\n \n-      if (node* p = m_find_node(m_buckets[n], k, code))\n-\treturn std::make_pair(iterator(p, m_buckets + n), false);\n-      return std::make_pair(m_insert_bucket(v, n, code), true);\n+      if (_Node* __p = _M_find_node(_M_buckets[__n], __k, __code))\n+\treturn std::make_pair(iterator(__p, _M_buckets + __n), false);\n+      return std::make_pair(_M_insert_bucket(__v, __n, __code), true);\n     }\n   \n   // Insert v unconditionally.\n-  template<typename K, typename V, \n-\t   typename A, typename Ex, typename Eq,\n-\t   typename H1, typename H2, typename H, typename RP,\n-\t   bool c, bool ci, bool u>\n-    typename hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::iterator\n-    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n-    m_insert(const value_type& v, std::tr1::false_type)\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n+\t\t\t__chc, __cit, __uk>::iterator\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    _M_insert(const value_type& __v, std::tr1::false_type)\n     {\n-      std::pair<bool, std::size_t> do_rehash\n-\t= m_rehash_policy.need_rehash(m_bucket_count, m_element_count, 1);\n-      if (do_rehash.first)\n-\tm_rehash(do_rehash.second);\n+      std::pair<bool, std::size_t> __do_rehash\n+\t= _M_rehash_policy._M_need_rehash(_M_bucket_count,\n+\t\t\t\t\t  _M_element_count, 1);\n+      if (__do_rehash.first)\n+\t_M_rehash(__do_rehash.second);\n  \n-      const key_type& k = this->m_extract(v);\n-      typename hashtable::hash_code_t code = this->m_hash_code(k);\n-      size_type n = this->bucket_index(k, code, m_bucket_count);\n+      const key_type& __k = this->_M_extract(__v);\n+      typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);\n+      size_type __n = this->_M_bucket_index(__k, __code, _M_bucket_count);\n \n       // First find the node, avoid leaking new_node if compare throws.\n-      node* prev = m_find_node(m_buckets[n], k, code);\n-      node* new_node = m_allocate_node(v);\n+      _Node* __prev = _M_find_node(_M_buckets[__n], __k, __code);\n+      _Node* __new_node = _M_allocate_node(__v);\n \n-      if (prev)\n+      if (__prev)\n \t{\n-\t  new_node->m_next = prev->m_next;\n-\t  prev->m_next = new_node;\n+\t  __new_node->_M_next = __prev->_M_next;\n+\t  __prev->_M_next = __new_node;\n \t}\n       else\n \t{\n-\t  new_node->m_next = m_buckets[n];\n-\t  m_buckets[n] = new_node;\n+\t  __new_node->_M_next = _M_buckets[__n];\n+\t  _M_buckets[__n] = __new_node;\n \t}\n-      this->store_code(new_node, code);\n+      this->_M_store_code(__new_node, __code);\n \n-      ++m_element_count;\n-      return iterator(new_node, m_buckets + n);\n+      ++_M_element_count;\n+      return iterator(__new_node, _M_buckets + __n);\n     }\n \n   // For erase(iterator) and erase(const_iterator).\n-  template<typename K, typename V, \n-\t   typename A, typename Ex, typename Eq,\n-\t   typename H1, typename H2, typename H, typename RP,\n-\t   bool c, bool ci, bool u>\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n     void\n-    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n-    m_erase_node(node* p, node** b)\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    _M_erase_node(_Node* __p, _Node** __b)\n     {\n-      node* cur = *b;\n-      if (cur == p)\n-\t*b = cur->m_next;\n+      _Node* __cur = *__b;\n+      if (__cur == __p)\n+\t*__b = __cur->_M_next;\n       else\n \t{\n-\t  node* next = cur->m_next;\n-\t  while (next != p)\n+\t  _Node* __next = __cur->_M_next;\n+\t  while (__next != __p)\n \t    {\n-\t      cur = next;\n-\t      next = cur->m_next;\n+\t      __cur = __next;\n+\t      __next = __cur->_M_next;\n \t    }\n-\t  cur->m_next = next->m_next;\n+\t  __cur->_M_next = __next->_M_next;\n \t}\n \n-      m_deallocate_node(p);\n-      --m_element_count;\n+      _M_deallocate_node(__p);\n+      --_M_element_count;\n     }\n \n-  template<typename K, typename V, \n-\t   typename A, typename Ex, typename Eq,\n-\t   typename H1, typename H2, typename H, typename RP,\n-\t   bool c, bool ci, bool u>\n-    template<typename InIter>\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    template<typename _InputIterator>\n       void \n-      hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n-      insert(InIter first, InIter last)\n+      _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t\t _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+      insert(_InputIterator __first, _InputIterator __last)\n       {\n-\tsize_type n_elt = detail::distance_fw(first, last);\n-\tstd::pair<bool, std::size_t> do_rehash\n-\t  = m_rehash_policy.need_rehash(m_bucket_count, m_element_count, n_elt);\n-\tif (do_rehash.first)\n-\t  m_rehash(do_rehash.second);\n-\n-\tfor (; first != last; ++first)\n-\t  this->insert(*first);\n+\tsize_type __n_elt = __detail::__distance_fw(__first, __last);\n+\tstd::pair<bool, std::size_t> __do_rehash\n+\t  = _M_rehash_policy._M_need_rehash(_M_bucket_count,\n+\t\t\t\t\t    _M_element_count, __n_elt);\n+\tif (__do_rehash.first)\n+\t  _M_rehash(__do_rehash.second);\n+\n+\tfor (; __first != __last; ++__first)\n+\t  this->insert(*__first);\n       }\n \n-  template<typename K, typename V, \n-\t   typename A, typename Ex, typename Eq,\n-\t   typename H1, typename H2, typename H, typename RP,\n-\t   bool c, bool ci, bool u>\n-    typename hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::iterator\n-    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n-    erase(iterator it)\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n+\t\t\t__chc, __cit, __uk>::iterator\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    erase(iterator __it)\n     {\n-      iterator result = it;\n-      ++result;\n-      m_erase_node(it.m_cur_node, it.m_cur_bucket);\n-      return result;\n+      iterator __result = __it;\n+      ++__result;\n+      _M_erase_node(__it._M_cur_node, __it._M_cur_bucket);\n+      return __result;\n     }\n \n-  template<typename K, typename V, \n-\t   typename A, typename Ex, typename Eq,\n-\t   typename H1, typename H2, typename H, typename RP,\n-\t   bool c, bool ci, bool u>\n-    typename hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::const_iterator\n-    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n-    erase(const_iterator it)\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n+\t\t\t__chc, __cit, __uk>::const_iterator\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    erase(const_iterator __it)\n     {\n-      const_iterator result = it;\n-      ++result;\n-      m_erase_node(it.m_cur_node, it.m_cur_bucket);\n-      return result;\n+      const_iterator __result = __it;\n+      ++__result;\n+      _M_erase_node(__it._M_cur_node, __it._M_cur_bucket);\n+      return __result;\n     }\n \n-  template<typename K, typename V, \n-\t   typename A, typename Ex, typename Eq,\n-\t   typename H1, typename H2, typename H, typename RP,\n-\t   bool c, bool ci, bool u>\n-    typename hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::size_type\n-    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n-    erase(const key_type& k)\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n+\t\t\t__chc, __cit, __uk>::size_type\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    erase(const key_type& __k)\n     {\n-      typename hashtable::hash_code_t code = this->m_hash_code(k);\n-      std::size_t n = this->bucket_index(k, code, m_bucket_count);\n-      size_type result = 0;\n+      typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);\n+      std::size_t __n = this->_M_bucket_index(__k, __code, _M_bucket_count);\n+      size_type __result = 0;\n       \n-      node** slot = m_buckets + n;\n-      while (*slot && !this->compare(k, code, *slot))\n-\tslot = &((*slot)->m_next);\n+      _Node** __slot = _M_buckets + __n;\n+      while (*__slot && !this->_M_compare(__k, __code, *__slot))\n+\t__slot = &((*__slot)->_M_next);\n \n-      while (*slot && this->compare(k, code, *slot))\n+      while (*__slot && this->_M_compare(__k, __code, *__slot))\n \t{\n-\t  node* p = *slot;\n-\t  *slot = p->m_next;\n-\t  m_deallocate_node(p);\n-\t  --m_element_count;\n-\t  ++result;\n+\t  _Node* __p = *__slot;\n+\t  *__slot = __p->_M_next;\n+\t  _M_deallocate_node(__p);\n+\t  --_M_element_count;\n+\t  ++__result;\n \t}\n \n-      return result;\n+      return __result;\n     }\n \n   // ??? This could be optimized by taking advantage of the bucket\n   // structure, but it's not clear that it's worth doing.  It probably\n   // wouldn't even be an optimization unless the load factor is large.\n-  template<typename K, typename V, \n-\t   typename A, typename Ex, typename Eq,\n-\t   typename H1, typename H2, typename H, typename RP,\n-\t   bool c, bool ci, bool u>\n-    typename hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::iterator\n-    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n-    erase(iterator first, iterator last)\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n+\t\t\t__chc, __cit, __uk>::iterator\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    erase(iterator __first, iterator __last)\n     {\n-      while (first != last)\n-\tfirst = this->erase(first);\n-      return last;\n+      while (__first != __last)\n+\t__first = this->erase(__first);\n+      return __last;\n     }\n   \n-  template<typename K, typename V, \n-\t   typename A, typename Ex, typename Eq,\n-\t   typename H1, typename H2, typename H, typename RP,\n-\t   bool c, bool ci, bool u>\n-    typename hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::const_iterator\n-    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n-    erase(const_iterator first, const_iterator last)\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n+\t\t\t__chc, __cit, __uk>::const_iterator\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    erase(const_iterator __first, const_iterator __last)\n     {\n-      while (first != last)\n-\tfirst = this->erase(first);\n-      return last;\n+      while (__first != __last)\n+\t__first = this->erase(__first);\n+      return __last;\n     }\n \n-  template<typename K, typename V, \n-\t   typename A, typename Ex, typename Eq,\n-\t   typename H1, typename H2, typename H, typename RP,\n-\t   bool c, bool ci, bool u>\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n     void\n-    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n     clear()\n     {\n-      m_deallocate_nodes(m_buckets, m_bucket_count);\n-      m_element_count = 0;\n+      _M_deallocate_nodes(_M_buckets, _M_bucket_count);\n+      _M_element_count = 0;\n     }\n  \n-  template<typename K, typename V, \n-\t   typename A, typename Ex, typename Eq,\n-\t   typename H1, typename H2, typename H, typename RP,\n-\t   bool c, bool ci, bool u>\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n     void\n-    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n-    rehash(size_type n)\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    rehash(size_type __n)\n     {\n-      m_rehash(std::max(m_rehash_policy.next_bkt(n),\n-\t\t\tm_rehash_policy.bkt_for_elements(m_element_count\n-\t\t\t\t\t\t\t + 1)));\n+      _M_rehash(std::max(_M_rehash_policy._M_next_bkt(__n),\n+\t\t\t _M_rehash_policy._M_bkt_for_elements(_M_element_count\n+\t\t\t\t\t\t\t      + 1)));\n     }\n \n-  template<typename K, typename V, \n-\t   typename A, typename Ex, typename Eq,\n-\t   typename H1, typename H2, typename H, typename RP,\n-\t   bool c, bool ci, bool u>\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n     void\n-    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n-    m_rehash(size_type n)\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    _M_rehash(size_type __n)\n     {\n-      node** new_array = m_allocate_buckets(n);\n+      _Node** __new_array = _M_allocate_buckets(__n);\n       try\n \t{\n-\t  for (size_type i = 0; i < m_bucket_count; ++i)\n-\t    while (node* p = m_buckets[i])\n+\t  for (size_type __i = 0; __i < _M_bucket_count; ++__i)\n+\t    while (_Node* __p = _M_buckets[__i])\n \t      {\n-\t\tstd::size_t new_index = this->bucket_index(p, n);\n-\t\tm_buckets[i] = p->m_next;\n-\t\tp->m_next = new_array[new_index];\n-\t\tnew_array[new_index] = p;\n+\t\tstd::size_t __new_index = this->_M_bucket_index(__p, __n);\n+\t\t_M_buckets[__i] = __p->_M_next;\n+\t\t__p->_M_next = __new_array[__new_index];\n+\t\t__new_array[__new_index] = __p;\n \t      }\n-\t  m_deallocate_buckets(m_buckets, m_bucket_count);\n-\t  m_bucket_count = n;\n-\t  m_buckets = new_array;\n+\t  _M_deallocate_buckets(_M_buckets, _M_bucket_count);\n+\t  _M_bucket_count = __n;\n+\t  _M_buckets = __new_array;\n \t}\n       catch(...)\n \t{\n \t  // A failure here means that a hash function threw an exception.\n \t  // We can't restore the previous state without calling the hash\n \t  // function again, so the only sensible recovery is to delete\n \t  // everything.\n-\t  m_deallocate_nodes(new_array, n);\n-\t  m_deallocate_buckets(new_array, n);\n-\t  m_deallocate_nodes(m_buckets, m_bucket_count);\n-\t  m_element_count = 0;\n+\t  _M_deallocate_nodes(__new_array, __n);\n+\t  _M_deallocate_buckets(__new_array, __n);\n+\t  _M_deallocate_nodes(_M_buckets, _M_bucket_count);\n+\t  _M_element_count = 0;\n \t  __throw_exception_again;\n \t}\n     }"}, {"sha": "d9fda09f5bee75d1396c4bad019a7afa029e929a", "filename": "libstdc++-v3/include/tr1/hashtable_policy.h", "status": "modified", "additions": 400, "deletions": 360, "changes": 760, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95cefe5f0ea9e244b73de42ef1ee54d2d9b3a5f6/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhashtable_policy.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95cefe5f0ea9e244b73de42ef1ee54d2d9b3a5f6/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhashtable_policy.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhashtable_policy.h?ref=95cefe5f0ea9e244b73de42ef1ee54d2d9b3a5f6", "patch": "@@ -41,56 +41,58 @@\n namespace std\n { \n _GLIBCXX_BEGIN_NAMESPACE(tr1)\n-namespace detail\n+namespace __detail\n {\n namespace \n {\n   // Helper function: return distance(first, last) for forward\n   // iterators, or 0 for input iterators.\n-  template<class Iterator>\n-    inline typename std::iterator_traits<Iterator>::difference_type\n-    distance_fw(Iterator first, Iterator last, std::input_iterator_tag)\n+  template<class _Iterator>\n+    inline typename std::iterator_traits<_Iterator>::difference_type\n+    __distance_fw(_Iterator __first, _Iterator __last,\n+\t\t  std::input_iterator_tag)\n     { return 0; }\n \n-  template<class Iterator>\n-    inline typename std::iterator_traits<Iterator>::difference_type\n-    distance_fw(Iterator first, Iterator last, std::forward_iterator_tag)\n-    { return std::distance(first, last); }\n+  template<class _Iterator>\n+    inline typename std::iterator_traits<_Iterator>::difference_type\n+    __distance_fw(_Iterator __first, _Iterator __last,\n+\t\t  std::forward_iterator_tag)\n+    { return std::distance(__first, __last); }\n \n-  template<class Iterator>\n-    inline typename std::iterator_traits<Iterator>::difference_type\n-    distance_fw(Iterator first, Iterator last)\n+  template<class _Iterator>\n+    inline typename std::iterator_traits<_Iterator>::difference_type\n+    __distance_fw(_Iterator __first, _Iterator __last)\n     {\n-      typedef typename std::iterator_traits<Iterator>::iterator_category tag;\n-      return distance_fw(first, last, tag());\n+      typedef typename std::iterator_traits<_Iterator>::iterator_category _Tag;\n+      return __distance_fw(__first, __last, _Tag());\n     }\n \n-  // XXX This is a hack.  prime_rehash_policy's member functions, and\n+  // XXX This is a hack.  _Prime_rehash_policy's member functions, and\n   // certainly the list of primes, should be defined in a .cc file.\n   // We're temporarily putting them in a header because we don't have a\n   // place to put TR1 .cc files yet.  There's no good reason for any of\n-  // prime_rehash_policy's member functions to be inline, and there's\n-  // certainly no good reason for X<> to exist at all.  \n-  struct lt\n+  // _Prime_rehash_policy's member functions to be inline, and there's\n+  // certainly no good reason for _Primes<> to exist at all.  \n+  struct _LessThan\n   {\n-    template<typename X, typename Y>\n+    template<typename _Tp, typename _Up>\n       bool\n-      operator()(X x, Y y)\n-      { return x < y; }\n+      operator()(_Tp __x, _Up __y)\n+      { return __x < __y; }\n   };\n \n-  template<int ulongsize = sizeof(unsigned long)>\n-    struct X\n+  template<int __ulongsize = sizeof(unsigned long)>\n+    struct _Primes\n     {\n-      static const int n_primes = ulongsize != 8 ? 256 : 256 + 48;\n-      static const unsigned long primes[256 + 48 + 1];\n+      static const int __n_primes = __ulongsize != 8 ? 256 : 256 + 48;\n+      static const unsigned long __primes[256 + 48 + 1];\n     };\n \n-  template<int ulongsize>\n-    const int X<ulongsize>::n_primes;\n+  template<int __ulongsize>\n+    const int _Primes<__ulongsize>::__n_primes;\n \n-  template<int ulongsize>\n-    const unsigned long X<ulongsize>::primes[256 + 48 + 1] =\n+  template<int __ulongsize>\n+    const unsigned long _Primes<__ulongsize>::__primes[256 + 48 + 1] =\n     {\n       2ul, 3ul, 5ul, 7ul, 11ul, 13ul, 17ul, 19ul, 23ul, 29ul, 31ul,\n       37ul, 41ul, 43ul, 47ul, 53ul, 59ul, 61ul, 67ul, 71ul, 73ul, 79ul,\n@@ -135,7 +137,7 @@ namespace\n       4294967291ul,\n       // Sentinel, so we don't have to test the result of lower_bound,\n       // or, on 64-bit machines, rest of the table.\n-      ulongsize != 8 ? 4294967291ul : (unsigned long)6442450933ull,\n+      __ulongsize != 8 ? 4294967291ul : (unsigned long)6442450933ull,\n       (unsigned long)8589934583ull,\n       (unsigned long)12884901857ull, (unsigned long)17179869143ull,\n       (unsigned long)25769803693ull, (unsigned long)34359738337ull,\n@@ -168,489 +170,513 @@ namespace\n     };\n } // anonymous namespace\n \n-  // Auxiliary types used for all instantiations of hashtable: nodes\n+  // Auxiliary types used for all instantiations of _Hashtable: nodes\n   // and iterators.\n   \n   // Nodes, used to wrap elements stored in the hash table.  A policy\n-  // template parameter of class template hashtable controls whether\n+  // template parameter of class template _Hashtable controls whether\n   // nodes also store a hash code. In some cases (e.g. strings) this\n   // may be a performance win.\n-  template<typename Value, bool cache_hash_code>\n-    struct hash_node;\n+  template<typename _Value, bool __cache_hash_code>\n+    struct _Hash_node;\n \n-  template<typename Value>\n-    struct hash_node<Value, true>\n+  template<typename _Value>\n+    struct _Hash_node<_Value, true>\n     {\n-      Value       m_v;\n-      std::size_t hash_code;\n-      hash_node*  m_next;\n+      _Value       _M_v;\n+      std::size_t  _M_hash_code;\n+      _Hash_node*  _M_next;\n     };\n \n-  template<typename Value>\n-    struct hash_node<Value, false>\n+  template<typename _Value>\n+    struct _Hash_node<_Value, false>\n     {\n-      Value       m_v;\n-      hash_node*  m_next;\n+      _Value       _M_v;\n+      _Hash_node*  _M_next;\n     };\n \n   // Local iterators, used to iterate within a bucket but not between\n   // buckets.\n-  template<typename Value, bool cache>\n-    struct node_iterator_base\n+  template<typename _Value, bool __cache>\n+    struct _Node_iterator_base\n     {\n-      node_iterator_base(hash_node<Value, cache>* p)\n-      : m_cur(p) { }\n+      _Node_iterator_base(_Hash_node<_Value, __cache>* __p)\n+      : _M_cur(__p) { }\n       \n       void\n-      incr()\n-      { m_cur = m_cur->m_next; }\n+      _M_incr()\n+      { _M_cur = _M_cur->_M_next; }\n \n-      hash_node<Value, cache>* m_cur;\n+      _Hash_node<_Value, __cache>*  _M_cur;\n     };\n \n-  template<typename Value, bool cache>\n+  template<typename _Value, bool __cache>\n     inline bool\n-    operator==(const node_iterator_base<Value, cache>& x,\n-\t       const node_iterator_base<Value, cache>& y)\n-    { return x.m_cur == y.m_cur; }\n+    operator==(const _Node_iterator_base<_Value, __cache>& __x,\n+\t       const _Node_iterator_base<_Value, __cache>& __y)\n+    { return __x._M_cur == __y._M_cur; }\n \n-  template<typename Value, bool cache>\n+  template<typename _Value, bool __cache>\n     inline bool\n-    operator!=(const node_iterator_base<Value, cache>& x,\n-\t       const node_iterator_base<Value, cache>& y)\n-    { return x.m_cur != y.m_cur; }\n+    operator!=(const _Node_iterator_base<_Value, __cache>& __x,\n+\t       const _Node_iterator_base<_Value, __cache>& __y)\n+    { return __x._M_cur != __y._M_cur; }\n \n-  template<typename Value, bool constant_iterators, bool cache>\n-    struct node_iterator\n-    : public node_iterator_base<Value, cache>\n+  template<typename _Value, bool __constant_iterators, bool __cache>\n+    struct _Node_iterator\n+    : public _Node_iterator_base<_Value, __cache>\n     {\n-      typedef Value                                    value_type;\n-      typedef typename __gnu_cxx::__conditional_type<constant_iterators, const Value*, Value*>::__type\n+      typedef _Value                                   value_type;\n+      typedef typename\n+      __gnu_cxx::__conditional_type<__constant_iterators,\n+\t\t\t\t    const _Value*, _Value*>::__type\n                                                        pointer;\n-      typedef typename __gnu_cxx::__conditional_type<constant_iterators, const Value&, Value&>::__type\n+      typedef typename\n+      __gnu_cxx::__conditional_type<__constant_iterators,\n+\t\t\t\t    const _Value&, _Value&>::__type\n                                                        reference;\n       typedef std::ptrdiff_t                           difference_type;\n       typedef std::forward_iterator_tag                iterator_category;\n \n-      node_iterator()\n-      : node_iterator_base<Value, cache>(0) { }\n+      _Node_iterator()\n+      : _Node_iterator_base<_Value, __cache>(0) { }\n \n       explicit\n-      node_iterator(hash_node<Value, cache>* p)\n-      : node_iterator_base<Value, cache>(p) { }\n+      _Node_iterator(_Hash_node<_Value, __cache>* __p)\n+      : _Node_iterator_base<_Value, __cache>(__p) { }\n \n       reference\n       operator*() const\n-      { return this->m_cur->m_v; }\n+      { return this->_M_cur->_M_v; }\n   \n       pointer\n       operator->() const\n-      { return &this->m_cur->m_v; }\n+      { return &this->_M_cur->_M_v; }\n \n-      node_iterator&\n+      _Node_iterator&\n       operator++()\n       { \n-\tthis->incr(); \n+\tthis->_M_incr();\n \treturn *this; \n       }\n   \n-      node_iterator\n+      _Node_iterator\n       operator++(int)\n       { \n-\tnode_iterator tmp(*this);\n-\tthis->incr();\n-\treturn tmp;\n+\t_Node_iterator __tmp(*this);\n+\tthis->_M_incr();\n+\treturn __tmp;\n       }\n     };\n \n-  template<typename Value, bool constant_iterators, bool cache>\n-    struct node_const_iterator\n-    : public node_iterator_base<Value, cache>\n+  template<typename _Value, bool __constant_iterators, bool __cache>\n+    struct _Node_const_iterator\n+    : public _Node_iterator_base<_Value, __cache>\n     {\n-      typedef Value                                    value_type;\n-      typedef const Value*                             pointer;\n-      typedef const Value&                             reference;\n+      typedef _Value                                   value_type;\n+      typedef const _Value*                            pointer;\n+      typedef const _Value&                            reference;\n       typedef std::ptrdiff_t                           difference_type;\n       typedef std::forward_iterator_tag                iterator_category;\n \n-      node_const_iterator()\n-      : node_iterator_base<Value, cache>(0) { }\n+      _Node_const_iterator()\n+      : _Node_iterator_base<_Value, __cache>(0) { }\n \n       explicit\n-      node_const_iterator(hash_node<Value, cache>* p)\n-      : node_iterator_base<Value, cache>(p) { }\n+      _Node_const_iterator(_Hash_node<_Value, __cache>* __p)\n+      : _Node_iterator_base<_Value, __cache>(__p) { }\n \n-      node_const_iterator(const node_iterator<Value, constant_iterators,\n-\t\t\t  cache>& x)\n-      : node_iterator_base<Value, cache>(x.m_cur) { }\n+      _Node_const_iterator(const _Node_iterator<_Value, __constant_iterators,\n+\t\t\t   __cache>& __x)\n+      : _Node_iterator_base<_Value, __cache>(__x._M_cur) { }\n \n       reference\n       operator*() const\n-      { return this->m_cur->m_v; }\n+      { return this->_M_cur->_M_v; }\n   \n       pointer\n       operator->() const\n-      { return &this->m_cur->m_v; }\n+      { return &this->_M_cur->_M_v; }\n \n-      node_const_iterator&\n+      _Node_const_iterator&\n       operator++()\n       { \n-\tthis->incr(); \n+\tthis->_M_incr();\n \treturn *this; \n       }\n   \n-      node_const_iterator\n+      _Node_const_iterator\n       operator++(int)\n       { \n-\tnode_const_iterator tmp(*this);\n-\tthis->incr();\n-\treturn tmp;\n+\t_Node_const_iterator __tmp(*this);\n+\tthis->_M_incr();\n+\treturn __tmp;\n       }\n     };\n \n-  template<typename Value, bool cache>\n-    struct hashtable_iterator_base\n+  template<typename _Value, bool __cache>\n+    struct _Hashtable_iterator_base\n     {\n-      hashtable_iterator_base(hash_node<Value, cache>* node,\n-\t\t\t      hash_node<Value, cache>** bucket)\n-      : m_cur_node(node), m_cur_bucket(bucket) { }\n+      _Hashtable_iterator_base(_Hash_node<_Value, __cache>* __node,\n+\t\t\t       _Hash_node<_Value, __cache>** __bucket)\n+      : _M_cur_node(__node), _M_cur_bucket(__bucket) { }\n \n       void\n-      incr()\n+      _M_incr()\n       {\n-\tm_cur_node = m_cur_node->m_next;\n-\tif (!m_cur_node)\n-\t  m_incr_bucket();\n+\t_M_cur_node = _M_cur_node->_M_next;\n+\tif (!_M_cur_node)\n+\t  _M_incr_bucket();\n       }\n \n       void\n-      m_incr_bucket();\n+      _M_incr_bucket();\n \n-      hash_node<Value, cache>*  m_cur_node;\n-      hash_node<Value, cache>** m_cur_bucket;\n+      _Hash_node<_Value, __cache>*   _M_cur_node;\n+      _Hash_node<_Value, __cache>**  _M_cur_bucket;\n     };\n \n   // Global iterators, used for arbitrary iteration within a hash\n   // table.  Larger and more expensive than local iterators.\n-  template<typename Value, bool cache>\n+  template<typename _Value, bool __cache>\n     void\n-    hashtable_iterator_base<Value, cache>::\n-    m_incr_bucket()\n+    _Hashtable_iterator_base<_Value, __cache>::\n+    _M_incr_bucket()\n     {\n-      ++m_cur_bucket;\n+      ++_M_cur_bucket;\n \n       // This loop requires the bucket array to have a non-null sentinel.\n-      while (!*m_cur_bucket)\n-\t++m_cur_bucket;\n-      m_cur_node = *m_cur_bucket;\n+      while (!*_M_cur_bucket)\n+\t++_M_cur_bucket;\n+      _M_cur_node = *_M_cur_bucket;\n     }\n \n-  template<typename Value, bool cache>\n+  template<typename _Value, bool __cache>\n     inline bool\n-    operator==(const hashtable_iterator_base<Value, cache>& x,\n-\t       const hashtable_iterator_base<Value, cache>& y)\n-    { return x.m_cur_node == y.m_cur_node; }\n+    operator==(const _Hashtable_iterator_base<_Value, __cache>& __x,\n+\t       const _Hashtable_iterator_base<_Value, __cache>& __y)\n+    { return __x._M_cur_node == __y._M_cur_node; }\n \n-  template<typename Value, bool cache>\n+  template<typename _Value, bool __cache>\n     inline bool\n-    operator!=(const hashtable_iterator_base<Value, cache>& x,\n-\t       const hashtable_iterator_base<Value, cache>& y)\n-    { return x.m_cur_node != y.m_cur_node; }\n+    operator!=(const _Hashtable_iterator_base<_Value, __cache>& __x,\n+\t       const _Hashtable_iterator_base<_Value, __cache>& __y)\n+    { return __x._M_cur_node != __y._M_cur_node; }\n \n-  template<typename Value, bool constant_iterators, bool cache>\n-    struct hashtable_iterator\n-    : public hashtable_iterator_base<Value, cache>\n+  template<typename _Value, bool __constant_iterators, bool __cache>\n+    struct _Hashtable_iterator\n+    : public _Hashtable_iterator_base<_Value, __cache>\n     {\n-      typedef Value                                    value_type;\n-      typedef typename __gnu_cxx::__conditional_type<constant_iterators, const Value*, Value*>::__type\n+      typedef _Value                                   value_type;\n+      typedef typename\n+      __gnu_cxx::__conditional_type<__constant_iterators,\n+\t\t\t\t    const _Value*, _Value*>::__type\n                                                        pointer;\n-      typedef typename __gnu_cxx::__conditional_type<constant_iterators, const Value&, Value&>::__type\n+      typedef typename\n+      __gnu_cxx::__conditional_type<__constant_iterators,\n+\t\t\t\t    const _Value&, _Value&>::__type\n                                                        reference;\n       typedef std::ptrdiff_t                           difference_type;\n       typedef std::forward_iterator_tag                iterator_category;\n \n-      hashtable_iterator()\n-      : hashtable_iterator_base<Value, cache>(0, 0) { }\n+      _Hashtable_iterator()\n+      : _Hashtable_iterator_base<_Value, __cache>(0, 0) { }\n \n-      hashtable_iterator(hash_node<Value, cache>* p,\n-\t\t\t hash_node<Value, cache>** b)\n-      : hashtable_iterator_base<Value, cache>(p, b) { }\n+      _Hashtable_iterator(_Hash_node<_Value, __cache>* __p,\n+\t\t\t  _Hash_node<_Value, __cache>** __b)\n+      : _Hashtable_iterator_base<_Value, __cache>(__p, __b) { }\n \n       explicit\n-      hashtable_iterator(hash_node<Value, cache>** b)\n-      : hashtable_iterator_base<Value, cache>(*b, b) { }\n+      _Hashtable_iterator(_Hash_node<_Value, __cache>** __b)\n+      : _Hashtable_iterator_base<_Value, __cache>(*__b, __b) { }\n \n       reference\n       operator*() const\n-      { return this->m_cur_node->m_v; }\n+      { return this->_M_cur_node->_M_v; }\n   \n       pointer\n       operator->() const\n-      { return &this->m_cur_node->m_v; }\n+      { return &this->_M_cur_node->_M_v; }\n \n-      hashtable_iterator&\n+      _Hashtable_iterator&\n       operator++()\n       { \n-\tthis->incr();\n+\tthis->_M_incr();\n \treturn *this;\n       }\n   \n-      hashtable_iterator\n+      _Hashtable_iterator\n       operator++(int)\n       { \n-\thashtable_iterator tmp(*this);\n-\tthis->incr();\n-\treturn tmp;\n+\t_Hashtable_iterator __tmp(*this);\n+\tthis->_M_incr();\n+\treturn __tmp;\n       }\n     };\n \n-  template<typename Value, bool constant_iterators, bool cache>\n-    struct hashtable_const_iterator\n-    : public hashtable_iterator_base<Value, cache>\n+  template<typename _Value, bool __constant_iterators, bool __cache>\n+    struct _Hashtable_const_iterator\n+    : public _Hashtable_iterator_base<_Value, __cache>\n     {\n-      typedef Value                                    value_type;\n-      typedef const Value*                             pointer;\n-      typedef const Value&                             reference;\n+      typedef _Value                                   value_type;\n+      typedef const _Value*                            pointer;\n+      typedef const _Value&                            reference;\n       typedef std::ptrdiff_t                           difference_type;\n       typedef std::forward_iterator_tag                iterator_category;\n \n-      hashtable_const_iterator()\n-      : hashtable_iterator_base<Value, cache>(0, 0) { }\n+      _Hashtable_const_iterator()\n+      : _Hashtable_iterator_base<_Value, __cache>(0, 0) { }\n \n-      hashtable_const_iterator(hash_node<Value, cache>* p,\n-\t\t\t       hash_node<Value, cache>** b)\n-      : hashtable_iterator_base<Value, cache>(p, b) { }\n+      _Hashtable_const_iterator(_Hash_node<_Value, __cache>* __p,\n+\t\t\t\t_Hash_node<_Value, __cache>** __b)\n+      : _Hashtable_iterator_base<_Value, __cache>(__p, __b) { }\n \n       explicit\n-      hashtable_const_iterator(hash_node<Value, cache>** b)\n-      : hashtable_iterator_base<Value, cache>(*b, b) { }\n+      _Hashtable_const_iterator(_Hash_node<_Value, __cache>** __b)\n+      : _Hashtable_iterator_base<_Value, __cache>(*__b, __b) { }\n \n-      hashtable_const_iterator(const hashtable_iterator<Value,\n-\t\t\t       constant_iterators, cache>& x)\n-      : hashtable_iterator_base<Value, cache>(x.m_cur_node, x.m_cur_bucket) { }\n+      _Hashtable_const_iterator(const _Hashtable_iterator<_Value,\n+\t\t\t\t__constant_iterators, __cache>& __x)\n+      : _Hashtable_iterator_base<_Value, __cache>(__x._M_cur_node,\n+\t\t\t\t\t\t  __x._M_cur_bucket) { }\n \n       reference\n       operator*() const\n-      { return this->m_cur_node->m_v; }\n+      { return this->_M_cur_node->_M_v; }\n   \n       pointer\n       operator->() const\n-      { return &this->m_cur_node->m_v; }\n+      { return &this->_M_cur_node->_M_v; }\n \n-      hashtable_const_iterator&\n+      _Hashtable_const_iterator&\n       operator++()\n       { \n-\tthis->incr();\n+\tthis->_M_incr();\n \treturn *this;\n       }\n   \n-      hashtable_const_iterator\n+      _Hashtable_const_iterator\n       operator++(int)\n       { \n-\thashtable_const_iterator tmp(*this);\n-\tthis->incr();\n-\treturn tmp;\n+\t_Hashtable_const_iterator __tmp(*this);\n+\tthis->_M_incr();\n+\treturn __tmp;\n       }\n     };\n \n \n-  // Many of class template hashtable's template parameters are policy\n+  // Many of class template _Hashtable's template parameters are policy\n   // classes.  These are defaults for the policies.\n \n   // Default range hashing function: use division to fold a large number\n   // into the range [0, N).\n-  struct mod_range_hashing\n+  struct _Mod_range_hashing\n   {\n     typedef std::size_t first_argument_type;\n     typedef std::size_t second_argument_type;\n     typedef std::size_t result_type;\n \n     result_type\n-    operator()(first_argument_type r, second_argument_type N) const\n-    { return r % N; }\n+    operator()(first_argument_type __num, second_argument_type __den) const\n+    { return __num % __den; }\n   };\n \n   // Default ranged hash function H.  In principle it should be a\n   // function object composed from objects of type H1 and H2 such that\n   // h(k, N) = h2(h1(k), N), but that would mean making extra copies of\n   // h1 and h2.  So instead we'll just use a tag to tell class template\n   // hashtable to do that composition.\n-  struct default_ranged_hash { };\n+  struct _Default_ranged_hash { };\n \n   // Default value for rehash policy.  Bucket size is (usually) the\n   // smallest prime that keeps the load factor small enough.\n-  struct prime_rehash_policy\n+  struct _Prime_rehash_policy\n   {\n-    prime_rehash_policy(float z = 1.0);\n-    \n+    _Prime_rehash_policy(float __z = 1.0);\n+\n     float\n     max_load_factor() const;\n \n     // Return a bucket size no smaller than n.\n     std::size_t\n-    next_bkt(std::size_t n) const;\n+    _M_next_bkt(std::size_t __n) const;\n     \n     // Return a bucket count appropriate for n elements\n     std::size_t\n-    bkt_for_elements(std::size_t n) const;\n+    _M_bkt_for_elements(std::size_t __n) const;\n     \n-    // n_bkt is current bucket count, n_elt is current element count,\n-    // and n_ins is number of elements to be inserted.  Do we need to\n+    // __n_bkt is current bucket count, __n_elt is current element count,\n+    // and __n_ins is number of elements to be inserted.  Do we need to\n     // increase bucket count?  If so, return make_pair(true, n), where n\n     // is the new bucket count.  If not, return make_pair(false, 0).\n     std::pair<bool, std::size_t>\n-    need_rehash(std::size_t n_bkt, std::size_t n_elt, std::size_t n_ins) const;\n+    _M_need_rehash(std::size_t __n_bkt, std::size_t __n_elt,\n+\t\t   std::size_t __n_ins) const;\n     \n-    float               m_max_load_factor;\n-    float               m_growth_factor;\n-    mutable std::size_t m_next_resize;\n+    float                _M_max_load_factor;\n+    float                _M_growth_factor;\n+    mutable std::size_t  _M_next_resize;\n   };\n \n   inline\n-  prime_rehash_policy::\n-  prime_rehash_policy(float z)\n-  : m_max_load_factor(z), m_growth_factor(2.f), m_next_resize(0)\n+  _Prime_rehash_policy::\n+  _Prime_rehash_policy(float __z)\n+  : _M_max_load_factor(__z), _M_growth_factor(2.f), _M_next_resize(0)\n   { }\n \n   inline float\n-  prime_rehash_policy::\n+  _Prime_rehash_policy::\n   max_load_factor() const\n-  { return m_max_load_factor; }\n+  { return _M_max_load_factor; }\n \n   // Return a prime no smaller than n.\n   inline std::size_t\n-  prime_rehash_policy::\n-  next_bkt(std::size_t n) const\n+  _Prime_rehash_policy::\n+  _M_next_bkt(std::size_t __n) const\n   {\n-    const unsigned long* const last = X<>::primes + X<>::n_primes;\n-    const unsigned long* p = std::lower_bound(X<>::primes, last, n);\n-    m_next_resize = static_cast<std::size_t>(std::ceil(*p * m_max_load_factor));\n-    return *p;\n+    const unsigned long* const __last = (_Primes<>::__primes\n+\t\t\t\t\t + _Primes<>::__n_primes);\n+    const unsigned long* __p = std::lower_bound(_Primes<>::__primes, __last,\n+\t\t\t\t\t\t__n);\n+    _M_next_resize = static_cast<std::size_t>(std::ceil(*__p\n+\t\t\t\t\t\t\t* _M_max_load_factor));\n+    return *__p;\n   }\n \n   // Return the smallest prime p such that alpha p >= n, where alpha\n   // is the load factor.\n   inline std::size_t\n-  prime_rehash_policy::\n-  bkt_for_elements(std::size_t n) const\n+  _Prime_rehash_policy::\n+  _M_bkt_for_elements(std::size_t __n) const\n   {\n-    const unsigned long* const last = X<>::primes + X<>::n_primes;\n-    const float min_bkts = n / m_max_load_factor;\n-    const unsigned long* p = std::lower_bound(X<>::primes, last,\n-\t\t\t\t\t      min_bkts, lt());\n-    m_next_resize = static_cast<std::size_t>(std::ceil(*p * m_max_load_factor));\n-    return *p;\n+    const unsigned long* const __last = (_Primes<>::__primes\n+\t\t\t\t\t + _Primes<>::__n_primes);\n+    const float __min_bkts = __n / _M_max_load_factor;\n+    const unsigned long* __p = std::lower_bound(_Primes<>::__primes, __last,\n+\t\t\t\t\t\t__min_bkts, _LessThan());\n+    _M_next_resize = static_cast<std::size_t>(std::ceil(*__p\n+\t\t\t\t\t\t\t* _M_max_load_factor));\n+    return *__p;\n   }\n \n-  // Finds the smallest prime p such that alpha p > n_elt + n_ins.\n-  // If p > n_bkt, return make_pair(true, p); otherwise return\n+  // Finds the smallest prime p such that alpha p > __n_elt + __n_ins.\n+  // If p > __n_bkt, return make_pair(true, p); otherwise return\n   // make_pair(false, 0).  In principle this isn't very different from \n-  // bkt_for_elements.\n+  // _M_bkt_for_elements.\n   \n   // The only tricky part is that we're caching the element count at\n   // which we need to rehash, so we don't have to do a floating-point\n   // multiply for every insertion.\n   \n   inline std::pair<bool, std::size_t>\n-  prime_rehash_policy::\n-  need_rehash(std::size_t n_bkt, std::size_t n_elt, std::size_t n_ins) const\n+  _Prime_rehash_policy::\n+  _M_need_rehash(std::size_t __n_bkt, std::size_t __n_elt,\n+\t\t std::size_t __n_ins) const\n   {\n-    if (n_elt + n_ins > m_next_resize)\n+    if (__n_elt + __n_ins > _M_next_resize)\n       {\n-\tfloat min_bkts = (float(n_ins) + float(n_elt)) / m_max_load_factor;\n-\tif (min_bkts > n_bkt)\n+\tfloat __min_bkts = ((float(__n_ins) + float(__n_elt))\n+\t\t\t    / _M_max_load_factor);\n+\tif (__min_bkts > __n_bkt)\n \t  {\n-\t    min_bkts = std::max(min_bkts, m_growth_factor * n_bkt);\n-\t    const unsigned long* const last = X<>::primes + X<>::n_primes;\n-\t    const unsigned long* p = std::lower_bound(X<>::primes, last,\n-\t\t\t\t\t\t      min_bkts, lt());\n-\t    m_next_resize = \n-\t      static_cast<std::size_t>(std::ceil(*p * m_max_load_factor));\n-\t    return std::make_pair(true, *p);\n+\t    __min_bkts = std::max(__min_bkts, _M_growth_factor * __n_bkt);\n+\t    const unsigned long* const __last = (_Primes<>::__primes\n+\t\t\t\t\t\t + _Primes<>::__n_primes);\n+\t    const unsigned long* __p = std::lower_bound(_Primes<>::__primes,\n+\t\t\t\t\t\t\t__last, __min_bkts,\n+\t\t\t\t\t\t\t_LessThan());\n+\t    _M_next_resize = \n+\t      static_cast<std::size_t>(std::ceil(*__p * _M_max_load_factor));\n+\t    return std::make_pair(true, *__p);\n \t  }\n \telse \n \t  {\n-\t    m_next_resize = \n-\t      static_cast<std::size_t>(std::ceil(n_bkt * m_max_load_factor));\n+\t    _M_next_resize =\n+\t      static_cast<std::size_t>(std::ceil(__n_bkt\n+\t\t\t\t\t\t * _M_max_load_factor));\n \t    return std::make_pair(false, 0);\n \t  }\n       }\n     else\n       return std::make_pair(false, 0);\n   }\n \n-  // Base classes for std::tr1::hashtable.  We define these base\n+  // Base classes for std::tr1::_Hashtable.  We define these base\n   // classes because in some cases we want to do different things\n   // depending on the value of a policy class.  In some cases the\n   // policy class affects which member functions and nested typedefs\n   // are defined; we handle that by specializing base class templates.\n   // Several of the base class templates need to access other members\n-  // of class template hashtable, so we use the \"curiously recurring\n+  // of class template _Hashtable, so we use the \"curiously recurring\n   // template pattern\" for them.\n \n-  // class template map_base.  If the hashtable has a value type of the\n+  // class template _Map_base.  If the hashtable has a value type of the\n   // form pair<T1, T2> and a key extraction policy that returns the\n   // first part of the pair, the hashtable gets a mapped_type typedef.\n   // If it satisfies those criteria and also has unique keys, then it\n   // also gets an operator[].  \n-  template<typename K, typename V, typename Ex, bool unique, typename Hashtable>\n-    struct map_base { };\n+  template<typename _Key, typename _Value, typename _Ex, bool __unique,\n+\t   typename _Hashtable>\n+    struct _Map_base { };\n \t  \n-  template<typename K, typename Pair, typename Hashtable>\n-    struct map_base<K, Pair, std::_Select1st<Pair>, false, Hashtable>\n+  template<typename _Key, typename _Pair, typename _Hashtable>\n+    struct _Map_base<_Key, _Pair, std::_Select1st<_Pair>, false, _Hashtable>\n     {\n-      typedef typename Pair::second_type mapped_type;\n+      typedef typename _Pair::second_type mapped_type;\n     };\n \n-  template<typename K, typename Pair, typename Hashtable>\n-  struct map_base<K, Pair, std::_Select1st<Pair>, true, Hashtable>\n+  template<typename _Key, typename _Pair, typename _Hashtable>\n+  struct _Map_base<_Key, _Pair, std::_Select1st<_Pair>, true, _Hashtable>\n     {\n-      typedef typename Pair::second_type mapped_type;\n+      typedef typename _Pair::second_type mapped_type;\n       \n       mapped_type&\n-      operator[](const K& k);\n+      operator[](const _Key& __k);\n     };\n \n-  template<typename K, typename Pair, typename Hashtable>\n-    typename map_base<K, Pair, std::_Select1st<Pair>, true, Hashtable>::mapped_type&\n-    map_base<K, Pair, std::_Select1st<Pair>, true, Hashtable>::\n-    operator[](const K& k)\n+  template<typename _Key, typename _Pair, typename _Hashtable>\n+    typename _Map_base<_Key, _Pair, std::_Select1st<_Pair>,\n+\t\t       true, _Hashtable>::mapped_type&\n+    _Map_base<_Key, _Pair, std::_Select1st<_Pair>, true, _Hashtable>::\n+    operator[](const _Key& __k)\n     {\n-      Hashtable* h = static_cast<Hashtable*>(this);\n-      typename Hashtable::hash_code_t code = h->m_hash_code(k);\n-      std::size_t n = h->bucket_index(k, code, h->bucket_count());\n-\n-      typename Hashtable::node* p = h->m_find_node(h->m_buckets[n], k, code);\n-      if (!p)\n-\treturn h->m_insert_bucket(std::make_pair(k, mapped_type()),\n-\t\t\t\t  n, code)->second;\n-      return (p->m_v).second;\n+      _Hashtable* __h = static_cast<_Hashtable*>(this);\n+      typename _Hashtable::_Hash_code_type __code = __h->_M_hash_code(__k);\n+      std::size_t __n = __h->_M_bucket_index(__k, __code,\n+\t\t\t\t\t     __h->_M_bucket_count);\n+\n+      typename _Hashtable::_Node* __p =\n+\t__h->_M_find_node(__h->_M_buckets[__n], __k, __code);\n+      if (!__p)\n+\treturn __h->_M_insert_bucket(std::make_pair(__k, mapped_type()),\n+\t\t\t\t     __n, __code)->second;\n+      return (__p->_M_v).second;\n     }\n \n-  // class template rehash_base.  Give hashtable the max_load_factor\n-  // functions iff the rehash policy is prime_rehash_policy.\n-  template<typename RehashPolicy, typename Hashtable>\n-    struct rehash_base { };\n+  // class template _Rehash_base.  Give hashtable the max_load_factor\n+  // functions iff the rehash policy is _Prime_rehash_policy.\n+  template<typename _RehashPolicy, typename _Hashtable>\n+    struct _Rehash_base { };\n \n-  template<typename Hashtable>\n-    struct rehash_base<prime_rehash_policy, Hashtable>\n+  template<typename _Hashtable>\n+    struct _Rehash_base<_Prime_rehash_policy, _Hashtable>\n     {\n       float\n       max_load_factor() const\n       {\n-\tconst Hashtable* This = static_cast<const Hashtable*>(this);\n-\treturn This->rehash_policy().max_load_factor();\n+\tconst _Hashtable* __this = static_cast<const _Hashtable*>(this);\n+\treturn __this->__rehash_policy().max_load_factor();\n       }\n \n       void\n-      max_load_factor(float z)\n+      max_load_factor(float __z)\n       {\n-\tHashtable* This = static_cast<Hashtable*>(this);\n-\tThis->rehash_policy(prime_rehash_policy(z));    \n+\t_Hashtable* __this = static_cast<_Hashtable*>(this);\n+\t__this->__rehash_policy(_Prime_rehash_policy(__z));\n       }\n     };\n \n-  // Class template hash_code_base.  Encapsulates two policy issues that\n+  // Class template _Hash_code_base.  Encapsulates two policy issues that\n   // aren't quite orthogonal.\n   //   (1) the difference between using a ranged hash function and using\n   //       the combination of a hash function and a range-hashing function.\n@@ -662,62 +688,67 @@ namespace\n   // objects here, for convenience.\n   \n   // Primary template: unused except as a hook for specializations.  \n-  template<typename Key, typename Value,\n-\t   typename ExtractKey, typename Equal,\n-\t   typename H1, typename H2, typename H,\n-\t   bool cache_hash_code>\n-    struct hash_code_base;\n+  template<typename _Key, typename _Value,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash,\n+\t   bool __cache_hash_code>\n+    struct _Hash_code_base;\n \n   // Specialization: ranged hash function, no caching hash codes.  H1\n   // and H2 are provided but ignored.  We define a dummy hash code type.\n-  template<typename Key, typename Value,\n-\t   typename ExtractKey, typename Equal,\n-\t   typename H1, typename H2, typename H>\n-    struct hash_code_base<Key, Value, ExtractKey, Equal, H1, H2, H, false>\n+  template<typename _Key, typename _Value,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash>\n+    struct _Hash_code_base<_Key, _Value, _ExtractKey, _Equal, _H1, _H2,\n+\t\t\t   _Hash, false>\n     {\n     protected:\n-      hash_code_base(const ExtractKey& ex, const Equal& eq,\n-\t\t     const H1&, const H2&, const H& h)\n-      : m_extract(ex), m_eq(eq), m_ranged_hash(h) { }\n+      _Hash_code_base(const _ExtractKey& __ex, const _Equal& __eq,\n+\t\t      const _H1&, const _H2&, const _Hash& __h)\n+      : _M_extract(__ex), _M_eq(__eq), _M_ranged_hash(__h) { }\n \n-      typedef void* hash_code_t;\n+      typedef void* _Hash_code_type;\n   \n-      hash_code_t\n-      m_hash_code(const Key& k) const\n+      _Hash_code_type\n+      _M_hash_code(const _Key& __key) const\n       { return 0; }\n   \n       std::size_t\n-      bucket_index(const Key& k, hash_code_t, std::size_t N) const\n-      { return m_ranged_hash(k, N); }\n+      _M_bucket_index(const _Key& __k, _Hash_code_type,\n+\t\t      std::size_t __n) const\n+      { return _M_ranged_hash(__k, __n); }\n \n       std::size_t\n-      bucket_index(const hash_node<Value, false>* p, std::size_t N) const\n-      { return m_ranged_hash(m_extract(p->m_v), N); }\n+      _M_bucket_index(const _Hash_node<_Value, false>* __p,\n+\t\t      std::size_t __n) const\n+      { return _M_ranged_hash(_M_extract(__p->_M_v), __n); }\n   \n       bool\n-      compare(const Key& k, hash_code_t, hash_node<Value, false>* n) const\n-      { return m_eq(k, m_extract(n->m_v)); }\n+      _M_compare(const _Key& __k, _Hash_code_type,\n+\t\t _Hash_node<_Value, false>* __n) const\n+      { return _M_eq(__k, _M_extract(__n->_M_v)); }\n \n       void\n-      store_code(hash_node<Value, false>*, hash_code_t) const\n+      _M_store_code(_Hash_node<_Value, false>*, _Hash_code_type) const\n       { }\n \n       void\n-      copy_code(hash_node<Value, false>*, const hash_node<Value, false>*) const\n+      _M_copy_code(_Hash_node<_Value, false>*,\n+\t\t   const _Hash_node<_Value, false>*) const\n       { }\n       \n       void\n-      m_swap(hash_code_base& x)\n+      _M_swap(_Hash_code_base& __x)\n       {\n-\tstd::swap(m_extract, x.m_extract);\n-\tstd::swap(m_eq, x.m_eq);\n-\tstd::swap(m_ranged_hash, x.m_ranged_hash);\n+\tstd::swap(_M_extract, __x._M_extract);\n+\tstd::swap(_M_eq, __x._M_eq);\n+\tstd::swap(_M_ranged_hash, __x._M_ranged_hash);\n       }\n \n     protected:\n-      ExtractKey m_extract;\n-      Equal      m_eq;\n-      H          m_ranged_hash;\n+      _ExtractKey  _M_extract;\n+      _Equal       _M_eq;\n+      _Hash        _M_ranged_hash;\n     };\n \n \n@@ -728,137 +759,146 @@ namespace\n   // Specialization: ranged hash function, cache hash codes.  This\n   // combination is meaningless, so we provide only a declaration\n   // and no definition.  \n-  template<typename Key, typename Value,\n-\t    typename ExtractKey, typename Equal,\n-\t    typename H1, typename H2, typename H>\n-    struct hash_code_base<Key, Value, ExtractKey, Equal, H1, H2, H, true>;\n-\n+  template<typename _Key, typename _Value,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash>\n+    struct _Hash_code_base<_Key, _Value, _ExtractKey, _Equal, _H1, _H2,\n+\t\t\t   _Hash, true>;\n \n   // Specialization: hash function and range-hashing function, no\n   // caching of hash codes.  H is provided but ignored.  Provides\n   // typedef and accessor required by TR1.  \n-  template<typename Key, typename Value,\n-\t   typename ExtractKey, typename Equal,\n-\t   typename H1, typename H2>\n-    struct hash_code_base<Key, Value, ExtractKey, Equal, H1, H2,\n-\t\t\t  default_ranged_hash, false>\n+  template<typename _Key, typename _Value,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2>\n+    struct _Hash_code_base<_Key, _Value, _ExtractKey, _Equal, _H1, _H2,\n+\t\t\t   _Default_ranged_hash, false>\n     {\n-      typedef H1 hasher;\n-      \n+      typedef _H1 hasher;\n+\n       hasher\n       hash_function() const\n-      { return m_h1; }\n+      { return _M_h1; }\n \n     protected:\n-      hash_code_base(const ExtractKey& ex, const Equal& eq,\n-\t\t     const H1& h1, const H2& h2, const default_ranged_hash&)\n-      : m_extract(ex), m_eq(eq), m_h1(h1), m_h2(h2) { }\n+      _Hash_code_base(const _ExtractKey& __ex, const _Equal& __eq,\n+\t\t      const _H1& __h1, const _H2& __h2,\n+\t\t      const _Default_ranged_hash&)\n+      : _M_extract(__ex), _M_eq(__eq), _M_h1(__h1), _M_h2(__h2) { }\n \n-      typedef std::size_t hash_code_t;\n-      \n-      hash_code_t\n-      m_hash_code(const Key& k) const\n-      { return m_h1(k); }\n+      typedef std::size_t _Hash_code_type;\n+\n+      _Hash_code_type\n+      _M_hash_code(const _Key& __k) const\n+      { return _M_h1(__k); }\n       \n       std::size_t\n-      bucket_index(const Key&, hash_code_t c, std::size_t N) const\n-      { return m_h2(c, N); }\n+      _M_bucket_index(const _Key&, _Hash_code_type __c,\n+\t\t      std::size_t __n) const\n+      { return _M_h2(__c, __n); }\n \n       std::size_t\n-      bucket_index(const hash_node<Value, false>* p, std::size_t N) const\n-      { return m_h2(m_h1(m_extract(p->m_v)), N); }\n+      _M_bucket_index(const _Hash_node<_Value, false>* __p,\n+\t\t      std::size_t __n) const\n+      { return _M_h2(_M_h1(_M_extract(__p->_M_v)), __n); }\n \n       bool\n-      compare(const Key& k, hash_code_t, hash_node<Value, false>* n) const\n-      { return m_eq(k, m_extract(n->m_v)); }\n+      _M_compare(const _Key& __k, _Hash_code_type,\n+\t\t _Hash_node<_Value, false>* __n) const\n+      { return _M_eq(__k, _M_extract(__n->_M_v)); }\n \n       void\n-      store_code(hash_node<Value, false>*, hash_code_t) const\n+      _M_store_code(_Hash_node<_Value, false>*, _Hash_code_type) const\n       { }\n \n       void\n-      copy_code(hash_node<Value, false>*, const hash_node<Value, false>*) const\n+      _M_copy_code(_Hash_node<_Value, false>*,\n+\t\t   const _Hash_node<_Value, false>*) const\n       { }\n \n       void\n-      m_swap(hash_code_base& x)\n+      _M_swap(_Hash_code_base& __x)\n       {\n-\tstd::swap(m_extract, x.m_extract);\n-\tstd::swap(m_eq, x.m_eq);\n-\tstd::swap(m_h1, x.m_h1);\n-\tstd::swap(m_h2, x.m_h2);\n+\tstd::swap(_M_extract, __x._M_extract);\n+\tstd::swap(_M_eq, __x._M_eq);\n+\tstd::swap(_M_h1, __x._M_h1);\n+\tstd::swap(_M_h2, __x._M_h2);\n       }\n \n     protected:\n-      ExtractKey m_extract;\n-      Equal      m_eq;\n-      H1         m_h1;\n-      H2         m_h2;\n+      _ExtractKey  _M_extract;\n+      _Equal       _M_eq;\n+      _H1          _M_h1;\n+      _H2          _M_h2;\n     };\n \n   // Specialization: hash function and range-hashing function, \n   // caching hash codes.  H is provided but ignored.  Provides\n   // typedef and accessor required by TR1.\n-  template<typename Key, typename Value,\n-\t   typename ExtractKey, typename Equal,\n-\t   typename H1, typename H2>\n-    struct hash_code_base<Key, Value, ExtractKey, Equal, H1, H2,\n-\t\t\t  default_ranged_hash, true>\n+  template<typename _Key, typename _Value,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2>\n+    struct _Hash_code_base<_Key, _Value, _ExtractKey, _Equal, _H1, _H2,\n+\t\t\t   _Default_ranged_hash, true>\n     {\n-      typedef H1 hasher;\n+      typedef _H1 hasher;\n       \n       hasher\n       hash_function() const\n-      { return m_h1; }\n+      { return _M_h1; }\n \n     protected:\n-      hash_code_base(const ExtractKey& ex, const Equal& eq,\n-\t\t     const H1& h1, const H2& h2, const default_ranged_hash&)\n-      : m_extract(ex), m_eq(eq), m_h1(h1), m_h2(h2) { }\n+      _Hash_code_base(const _ExtractKey& __ex, const _Equal& __eq,\n+\t\t      const _H1& __h1, const _H2& __h2,\n+\t\t      const _Default_ranged_hash&)\n+      : _M_extract(__ex), _M_eq(__eq), _M_h1(__h1), _M_h2(__h2) { }\n \n-      typedef std::size_t hash_code_t;\n+      typedef std::size_t _Hash_code_type;\n   \n-      hash_code_t\n-      m_hash_code(const Key& k) const\n-      { return m_h1(k); }\n+      _Hash_code_type\n+      _M_hash_code(const _Key& __k) const\n+      { return _M_h1(__k); }\n   \n       std::size_t\n-      bucket_index(const Key&, hash_code_t c, std::size_t N) const\n-      { return m_h2(c, N); }\n+      _M_bucket_index(const _Key&, _Hash_code_type __c,\n+\t\t      std::size_t __n) const\n+      { return _M_h2(__c, __n); }\n \n       std::size_t\n-      bucket_index(const hash_node<Value, true>* p, std::size_t N) const\n-      { return m_h2(p->hash_code, N); }\n+      _M_bucket_index(const _Hash_node<_Value, true>* __p,\n+\t\t      std::size_t __n) const\n+      { return _M_h2(__p->_M_hash_code, __n); }\n \n       bool\n-      compare(const Key& k, hash_code_t c, hash_node<Value, true>* n) const\n-      { return c == n->hash_code && m_eq(k, m_extract(n->m_v)); }\n+      _M_compare(const _Key& __k, _Hash_code_type __c,\n+\t\t _Hash_node<_Value, true>* __n) const\n+      { return __c == __n->_M_hash_code && _M_eq(__k, _M_extract(__n->_M_v)); }\n \n       void\n-      store_code(hash_node<Value, true>* n, hash_code_t c) const\n-      { n->hash_code = c; }\n+      _M_store_code(_Hash_node<_Value, true>* __n, _Hash_code_type __c) const\n+      { __n->_M_hash_code = __c; }\n \n       void\n-      copy_code(hash_node<Value, true>* to,\n-\t\tconst hash_node<Value, true>* from) const\n-      { to->hash_code = from->hash_code; }\n+      _M_copy_code(_Hash_node<_Value, true>* __to,\n+\t\t   const _Hash_node<_Value, true>* __from) const\n+      { __to->_M_hash_code = __from->_M_hash_code; }\n \n       void\n-      m_swap(hash_code_base& x)\n+      _M_swap(_Hash_code_base& __x)\n       {\n-\tstd::swap(m_extract, x.m_extract);\n-\tstd::swap(m_eq, x.m_eq);\n-\tstd::swap(m_h1, x.m_h1);\n-\tstd::swap(m_h2, x.m_h2);\n+\tstd::swap(_M_extract, __x._M_extract);\n+\tstd::swap(_M_eq, __x._M_eq);\n+\tstd::swap(_M_h1, __x._M_h1);\n+\tstd::swap(_M_h2, __x._M_h2);\n       }\n       \n     protected:\n-      ExtractKey m_extract;\n-      Equal      m_eq;\n-      H1         m_h1;\n-      H2         m_h2;\n+      _ExtractKey  _M_extract;\n+      _Equal       _M_eq;\n+      _H1          _M_h1;\n+      _H2          _M_h2;\n     };\n-} // namespace detail\n+} // namespace __detail\n _GLIBCXX_END_NAMESPACE\n } // namespace std::tr1\n "}, {"sha": "9d0098b590b21132e9df7cb69bb0ad7670ff75c9", "filename": "libstdc++-v3/include/tr1/unordered_map", "status": "modified", "additions": 93, "deletions": 89, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95cefe5f0ea9e244b73de42ef1ee54d2d9b3a5f6/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Funordered_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95cefe5f0ea9e244b73de42ef1ee54d2d9b3a5f6/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Funordered_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Funordered_map?ref=95cefe5f0ea9e244b73de42ef1ee54d2d9b3a5f6", "patch": "@@ -43,120 +43,124 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \n   // XXX When we get typedef templates these class definitions\n   // will be unnecessary.\n-  template<class Key, class T,\n-\t   class Hash = hash<Key>,\n-\t   class Pred = std::equal_to<Key>,\n-\t   class Alloc = std::allocator<std::pair<const Key, T> >,\n-\t   bool cache_hash_code = false>\n+  template<class _Key, class _Tp,\n+\t   class _Hash = hash<_Key>,\n+\t   class _Pred = std::equal_to<_Key>,\n+\t   class _Alloc = std::allocator<std::pair<const _Key, _Tp> >,\n+\t   bool __cache_hash_code = false>\n     class unordered_map\n-    : public hashtable<Key, std::pair<const Key, T>, Alloc,\n-\t\t       std::_Select1st<std::pair<const Key, T> >, Pred, \n-\t\t       Hash, detail::mod_range_hashing,\n-\t\t       detail::default_ranged_hash,\n-\t\t       detail::prime_rehash_policy,\n-\t\t       cache_hash_code, false, true>\n+    : public _Hashtable<_Key, std::pair<const _Key, _Tp>, _Alloc,\n+\t\t\tstd::_Select1st<std::pair<const _Key, _Tp> >, _Pred, \n+\t\t\t_Hash, __detail::_Mod_range_hashing,\n+\t\t\t__detail::_Default_ranged_hash,\n+\t\t\t__detail::_Prime_rehash_policy,\n+\t\t\t__cache_hash_code, false, true>\n     {\n-      typedef hashtable<Key, std::pair<const Key, T>, Alloc,\n-\t\t\tstd::_Select1st<std::pair<const Key, T> >, Pred,\n-\t\t\tHash, detail::mod_range_hashing,\n-\t\t\tdetail::default_ranged_hash,\n-\t\t\tdetail::prime_rehash_policy,\n-\t\t\tcache_hash_code, false, true>\n-      Base;\n+      typedef _Hashtable<_Key, std::pair<const _Key, _Tp>, _Alloc,\n+\t\t\t std::_Select1st<std::pair<const _Key, _Tp> >, _Pred,\n+\t\t\t _Hash, __detail::_Mod_range_hashing,\n+\t\t\t __detail::_Default_ranged_hash,\n+\t\t\t __detail::_Prime_rehash_policy,\n+\t\t\t __cache_hash_code, false, true>\n+        _Base;\n \n     public:\n-      typedef typename Base::size_type size_type;\n-      typedef typename Base::hasher hasher;\n-      typedef typename Base::key_equal key_equal;\n-      typedef typename Base::allocator_type allocator_type;\n+      typedef typename _Base::size_type       size_type;\n+      typedef typename _Base::hasher          hasher;\n+      typedef typename _Base::key_equal       key_equal;\n+      typedef typename _Base::allocator_type  allocator_type;\n \n       explicit\n-      unordered_map(size_type n = 10,\n-\t\t    const hasher& hf = hasher(),\n-\t\t    const key_equal& eql = key_equal(),\n-\t\t    const allocator_type& a = allocator_type())\n-      : Base(n, hf, detail::mod_range_hashing(),\n-\t     detail::default_ranged_hash(),\n-\t     eql, std::_Select1st<std::pair<const Key, T> >(), a)\n+      unordered_map(size_type __n = 10,\n+\t\t    const hasher& __hf = hasher(),\n+\t\t    const key_equal& __eql = key_equal(),\n+\t\t    const allocator_type& __a = allocator_type())\n+      : _Base(__n, __hf, __detail::_Mod_range_hashing(),\n+\t      __detail::_Default_ranged_hash(),\n+\t      __eql, std::_Select1st<std::pair<const _Key, _Tp> >(), __a)\n       { }\n \n-      template<typename InputIterator>\n-        unordered_map(InputIterator f, InputIterator l, \n-\t\t      size_type n = 10,\n-\t\t      const hasher& hf = hasher(), \n-\t\t      const key_equal& eql = key_equal(), \n-\t\t      const allocator_type& a = allocator_type())\n-\t: Base (f, l, n, hf, detail::mod_range_hashing(),\n-\t\tdetail::default_ranged_hash(),\n-\t\teql, std::_Select1st<std::pair<const Key, T> >(), a)\n+      template<typename _InputIterator>\n+        unordered_map(_InputIterator __f, _InputIterator __l, \n+\t\t      size_type __n = 10,\n+\t\t      const hasher& __hf = hasher(), \n+\t\t      const key_equal& __eql = key_equal(), \n+\t\t      const allocator_type& __a = allocator_type())\n+\t: _Base(__f, __l, __n, __hf, __detail::_Mod_range_hashing(),\n+\t\t__detail::_Default_ranged_hash(),\n+\t\t__eql, std::_Select1st<std::pair<const _Key, _Tp> >(), __a)\n \t{ }\n     };\n   \n-  template<class Key, class T,\n-\t   class Hash = hash<Key>,\n-\t   class Pred = std::equal_to<Key>,\n-\t   class Alloc = std::allocator<std::pair<const Key, T> >,\n-\t   bool cache_hash_code = false>\n+  template<class _Key, class _Tp,\n+\t   class _Hash = hash<_Key>,\n+\t   class _Pred = std::equal_to<_Key>,\n+\t   class _Alloc = std::allocator<std::pair<const _Key, _Tp> >,\n+\t   bool __cache_hash_code = false>\n     class unordered_multimap\n-    : public hashtable <Key, std::pair<const Key, T>,\n-\t\t\tAlloc,\n-\t\t\tstd::_Select1st<std::pair<const Key, T> >, Pred,\n-\t\t\tHash, detail::mod_range_hashing,\n-\t\t\tdetail::default_ranged_hash,\n-\t\t\tdetail::prime_rehash_policy,\n-\t\t\tcache_hash_code, false, false>\n+    : public _Hashtable<_Key, std::pair<const _Key, _Tp>,\n+\t\t\t_Alloc,\n+\t\t\tstd::_Select1st<std::pair<const _Key, _Tp> >, _Pred,\n+\t\t\t_Hash, __detail::_Mod_range_hashing,\n+\t\t\t__detail::_Default_ranged_hash,\n+\t\t\t__detail::_Prime_rehash_policy,\n+\t\t\t__cache_hash_code, false, false>\n     {\n-      typedef hashtable <Key, std::pair<const Key, T>,\n-\t\t\t Alloc,\n-\t\t\t std::_Select1st<std::pair<const Key, T> >, Pred,\n-\t\t\t Hash, detail::mod_range_hashing,\n-\t\t\t detail::default_ranged_hash,\n-\t\t\t detail::prime_rehash_policy,\n-\t\t\t cache_hash_code, false, false>\n-        Base;\n+      typedef _Hashtable<_Key, std::pair<const _Key, _Tp>,\n+\t\t\t _Alloc,\n+\t\t\t std::_Select1st<std::pair<const _Key, _Tp> >, _Pred,\n+\t\t\t _Hash, __detail::_Mod_range_hashing,\n+\t\t\t __detail::_Default_ranged_hash,\n+\t\t\t __detail::_Prime_rehash_policy,\n+\t\t\t __cache_hash_code, false, false>\n+        _Base;\n \n     public:\n-      typedef typename Base::size_type size_type;\n-      typedef typename Base::hasher hasher;\n-      typedef typename Base::key_equal key_equal;\n-      typedef typename Base::allocator_type allocator_type;\n+      typedef typename _Base::size_type       size_type;\n+      typedef typename _Base::hasher          hasher;\n+      typedef typename _Base::key_equal       key_equal;\n+      typedef typename _Base::allocator_type  allocator_type;\n       \n       explicit\n-      unordered_multimap(size_type n = 10,\n-\t\t\t const hasher& hf = hasher(),\n-\t\t\t const key_equal& eql = key_equal(),\n-\t\t\t const allocator_type& a = allocator_type())\n-      : Base (n, hf, detail::mod_range_hashing(),\n-\t      detail::default_ranged_hash(),\n-\t      eql, std::_Select1st<std::pair<const Key, T> >(), a)\n+      unordered_multimap(size_type __n = 10,\n+\t\t\t const hasher& __hf = hasher(),\n+\t\t\t const key_equal& __eql = key_equal(),\n+\t\t\t const allocator_type& __a = allocator_type())\n+      : _Base(__n, __hf, __detail::_Mod_range_hashing(),\n+\t      __detail::_Default_ranged_hash(),\n+\t      __eql, std::_Select1st<std::pair<const _Key, _Tp> >(), __a)\n       { }\n \n \n-      template<typename InputIterator>\n-        unordered_multimap(InputIterator f, InputIterator l, \n-\t\t\t   typename Base::size_type n = 0,\n-\t\t\t   const hasher& hf = hasher(), \n-\t\t\t   const key_equal& eql = key_equal(), \n-\t\t\t   const allocator_type& a = allocator_type())\n-\t: Base (f, l, n, hf, detail::mod_range_hashing(),\n-\t\tdetail::default_ranged_hash(),\n-\t\teql, std::_Select1st<std::pair<const Key, T> >(), a)\n+      template<typename _InputIterator>\n+        unordered_multimap(_InputIterator __f, _InputIterator __l, \n+\t\t\t   typename _Base::size_type __n = 0,\n+\t\t\t   const hasher& __hf = hasher(), \n+\t\t\t   const key_equal& __eql = key_equal(), \n+\t\t\t   const allocator_type& __a = allocator_type())\n+\t: _Base(__f, __l, __n, __hf, __detail::_Mod_range_hashing(),\n+\t\t__detail::_Default_ranged_hash(),\n+\t\t__eql, std::_Select1st<std::pair<const _Key, _Tp> >(), __a)\n         { }\n     };\n \n-  template<class Key, class T, class Hash, class Pred, class Alloc,\n-\t   bool cache_hash_code>\n+  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc,\n+\t   bool __cache_hash_code>\n     inline void\n-    swap(unordered_map<Key, T, Hash, Pred, Alloc, cache_hash_code>& x,\n-\t unordered_map<Key, T, Hash, Pred, Alloc, cache_hash_code>& y)\n-    { x.swap(y); }\n-\n-  template<class Key, class T, class Hash, class Pred, class Alloc,\n-\t   bool cache_hash_code>\n+    swap(unordered_map<_Key, _Tp, _Hash, _Pred,\n+\t _Alloc, __cache_hash_code>& __x,\n+\t unordered_map<_Key, _Tp, _Hash, _Pred,\n+\t _Alloc, __cache_hash_code>& __y)\n+    { __x.swap(__y); }\n+\n+  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc,\n+\t   bool __cache_hash_code>\n     inline void\n-    swap(unordered_multimap<Key, T, Hash, Pred, Alloc, cache_hash_code>& x,\n-\t unordered_multimap<Key, T, Hash, Pred, Alloc, cache_hash_code>& y)\n-    { x.swap(y); }\n+    swap(unordered_multimap<_Key, _Tp, _Hash, _Pred,\n+\t _Alloc, __cache_hash_code>& __x,\n+\t unordered_multimap<_Key, _Tp, _Hash, _Pred,\n+\t _Alloc, __cache_hash_code>& __y)\n+    { __x.swap(__y); }\n \n _GLIBCXX_END_NAMESPACE\n }"}, {"sha": "227dae54968ee5263795dd530154ad9bbb6d564f", "filename": "libstdc++-v3/include/tr1/unordered_set", "status": "modified", "additions": 91, "deletions": 83, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95cefe5f0ea9e244b73de42ef1ee54d2d9b3a5f6/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Funordered_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95cefe5f0ea9e244b73de42ef1ee54d2d9b3a5f6/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Funordered_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Funordered_set?ref=95cefe5f0ea9e244b73de42ef1ee54d2d9b3a5f6", "patch": "@@ -43,114 +43,122 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \n   // XXX When we get typedef templates these class definitions\n   // will be unnecessary.\n-  template<class Value,\n-\t   class Hash = hash<Value>,\n-\t   class Pred = std::equal_to<Value>,\n-\t   class Alloc = std::allocator<Value>,\n-\t   bool cache_hash_code = false>\n+  template<class _Value,\n+\t   class _Hash = hash<_Value>,\n+\t   class _Pred = std::equal_to<_Value>,\n+\t   class _Alloc = std::allocator<_Value>,\n+\t   bool __cache_hash_code = false>\n     class unordered_set\n-    : public hashtable<Value, Value, Alloc,\n-\t\t       std::_Identity<Value>, Pred,\n-\t\t       Hash, detail::mod_range_hashing,\n-\t\t       detail::default_ranged_hash,\n-\t\t       detail::prime_rehash_policy,\n-\t\t       cache_hash_code, true, true>\n+    : public _Hashtable<_Value, _Value, _Alloc,\n+\t\t\tstd::_Identity<_Value>, _Pred,\n+\t\t\t_Hash, __detail::_Mod_range_hashing,\n+\t\t\t__detail::_Default_ranged_hash,\n+\t\t\t__detail::_Prime_rehash_policy,\n+\t\t\t__cache_hash_code, true, true>\n     {\n-      typedef hashtable<Value, Value, Alloc,\n-\t\t\tstd::_Identity<Value>, Pred,\n-\t\t\tHash, detail::mod_range_hashing,\n-\t\t\tdetail::default_ranged_hash,\n-\t\t\tdetail::prime_rehash_policy,\n-\t\t\tcache_hash_code, true, true>\n-        Base;\n+      typedef _Hashtable<_Value, _Value, _Alloc,\n+\t\t\t std::_Identity<_Value>, _Pred,\n+\t\t\t _Hash, __detail::_Mod_range_hashing,\n+\t\t\t __detail::_Default_ranged_hash,\n+\t\t\t __detail::_Prime_rehash_policy,\n+\t\t\t __cache_hash_code, true, true>\n+        _Base;\n \n     public:\n-      typedef typename Base::size_type size_type;\n-      typedef typename Base::hasher hasher;\n-      typedef typename Base::key_equal key_equal;\n-      typedef typename Base::allocator_type allocator_type;\n+      typedef typename _Base::size_type       size_type;\n+      typedef typename _Base::hasher          hasher;\n+      typedef typename _Base::key_equal       key_equal;\n+      typedef typename _Base::allocator_type  allocator_type;\n       \n       explicit\n-      unordered_set(size_type n = 10,\n-\t\t    const hasher& hf = hasher(),\n-\t\t    const key_equal& eql = key_equal(),\n-\t\t    const allocator_type& a = allocator_type())\n-      : Base(n, hf, detail::mod_range_hashing(),\n-\t     detail::default_ranged_hash(), eql, std::_Identity<Value>(), a)\n+      unordered_set(size_type __n = 10,\n+\t\t    const hasher& __hf = hasher(),\n+\t\t    const key_equal& __eql = key_equal(),\n+\t\t    const allocator_type& __a = allocator_type())\n+      : _Base(__n, __hf, __detail::_Mod_range_hashing(),\n+\t      __detail::_Default_ranged_hash(), __eql,\n+\t      std::_Identity<_Value>(), __a)\n       { }\n \n-      template<typename InputIterator>\n-        unordered_set(InputIterator f, InputIterator l, \n-\t\t      size_type n = 10,\n-\t\t      const hasher& hf = hasher(), \n-\t\t      const key_equal& eql = key_equal(), \n-\t\t      const allocator_type& a = allocator_type())\n-\t: Base(f, l, n, hf, detail::mod_range_hashing(),\n-\t       detail::default_ranged_hash(), eql, std::_Identity<Value>(), a)\n+      template<typename _InputIterator>\n+        unordered_set(_InputIterator __f, _InputIterator __l, \n+\t\t      size_type __n = 10,\n+\t\t      const hasher& __hf = hasher(), \n+\t\t      const key_equal& __eql = key_equal(), \n+\t\t      const allocator_type& __a = allocator_type())\n+\t: _Base(__f, __l, __n, __hf, __detail::_Mod_range_hashing(),\n+\t\t__detail::_Default_ranged_hash(), __eql,\n+\t\tstd::_Identity<_Value>(), __a)\n         { }\n     };\n \n-  template<class Value,\n-\t   class Hash = hash<Value>,\n-\t   class Pred = std::equal_to<Value>,\n-\t   class Alloc = std::allocator<Value>,\n-\t   bool cache_hash_code = false>\n+  template<class _Value,\n+\t   class _Hash = hash<_Value>,\n+\t   class _Pred = std::equal_to<_Value>,\n+\t   class _Alloc = std::allocator<_Value>,\n+\t   bool __cache_hash_code = false>\n     class unordered_multiset\n-    : public hashtable <Value, Value, Alloc,\n-\t\t\tstd::_Identity<Value>, Pred,\n-\t\t\tHash, detail::mod_range_hashing,\n-\t\t\tdetail::default_ranged_hash,\n-\t\t\tdetail::prime_rehash_policy,\n-\t\t\tcache_hash_code, true, false>\n+    : public _Hashtable<_Value, _Value, _Alloc,\n+\t\t\tstd::_Identity<_Value>, _Pred,\n+\t\t\t_Hash, __detail::_Mod_range_hashing,\n+\t\t\t__detail::_Default_ranged_hash,\n+\t\t\t__detail::_Prime_rehash_policy,\n+\t\t\t__cache_hash_code, true, false>\n     {\n-      typedef hashtable<Value, Value, Alloc,\n-\t\t\tstd::_Identity<Value>, Pred,\n-\t\t\tHash, detail::mod_range_hashing,\n-\t\t\tdetail::default_ranged_hash,\n-\t\t\tdetail::prime_rehash_policy,\n-\t\t\tcache_hash_code, true, false>\n-        Base;\n+      typedef _Hashtable<_Value, _Value, _Alloc,\n+\t\t\t std::_Identity<_Value>, _Pred,\n+\t\t\t _Hash, __detail::_Mod_range_hashing,\n+\t\t\t __detail::_Default_ranged_hash,\n+\t\t\t __detail::_Prime_rehash_policy,\n+\t\t\t __cache_hash_code, true, false>\n+        _Base;\n \n     public:\n-      typedef typename Base::size_type size_type;\n-      typedef typename Base::hasher hasher;\n-      typedef typename Base::key_equal key_equal;\n-      typedef typename Base::allocator_type allocator_type;\n+      typedef typename _Base::size_type       size_type;\n+      typedef typename _Base::hasher          hasher;\n+      typedef typename _Base::key_equal       key_equal;\n+      typedef typename _Base::allocator_type  allocator_type;\n       \n       explicit\n-      unordered_multiset(size_type n = 10,\n-\t\t\t const hasher& hf = hasher(),\n-\t\t\t const key_equal& eql = key_equal(),\n-\t\t\t const allocator_type& a = allocator_type())\n-      : Base(n, hf, detail::mod_range_hashing(),\n-\t     detail::default_ranged_hash(), eql, std::_Identity<Value>(), a)\n+      unordered_multiset(size_type __n = 10,\n+\t\t\t const hasher& __hf = hasher(),\n+\t\t\t const key_equal& __eql = key_equal(),\n+\t\t\t const allocator_type& __a = allocator_type())\n+      : _Base(__n, __hf, __detail::_Mod_range_hashing(),\n+\t      __detail::_Default_ranged_hash(), __eql,\n+\t      std::_Identity<_Value>(), __a)\n       { }\n \n \n-      template<typename InputIterator>\n-        unordered_multiset(InputIterator f, InputIterator l, \n-\t\t\t   typename Base::size_type n = 0,\n-\t\t\t   const hasher& hf = hasher(), \n-\t\t\t   const key_equal& eql = key_equal(), \n-\t\t\t   const allocator_type& a = allocator_type())\n-\t: Base(f, l, n, hf, detail::mod_range_hashing(),\n-\t       detail::default_ranged_hash(), eql, std::_Identity<Value>(), a)\n+      template<typename _InputIterator>\n+        unordered_multiset(_InputIterator __f, _InputIterator __l, \n+\t\t\t   typename _Base::size_type __n = 0,\n+\t\t\t   const hasher& __hf = hasher(), \n+\t\t\t   const key_equal& __eql = key_equal(), \n+\t\t\t   const allocator_type& __a = allocator_type())\n+\t: _Base(__f, __l, __n, __hf, __detail::_Mod_range_hashing(),\n+\t\t__detail::_Default_ranged_hash(), __eql,\n+\t\tstd::_Identity<_Value>(), __a)\n         { }\n     };\n \n-  template<class Value, class Hash, class Pred, class Alloc,\n-\t   bool cache_hash_code>\n+  template<class _Value, class _Hash, class _Pred, class _Alloc,\n+\t   bool __cache_hash_code>\n     inline void\n-    swap (unordered_set<Value, Hash, Pred, Alloc, cache_hash_code>& x,\n-\t  unordered_set<Value, Hash, Pred, Alloc, cache_hash_code>& y)\n-    { x.swap(y); }\n-\n-  template<class Value, class Hash, class Pred, class Alloc,\n-\t   bool cache_hash_code>\n+    swap (unordered_set<_Value, _Hash, _Pred,\n+\t  _Alloc, __cache_hash_code>& __x,\n+\t  unordered_set<_Value, _Hash, _Pred,\n+\t  _Alloc, __cache_hash_code>& __y)\n+    { __x.swap(__y); }\n+\n+  template<class _Value, class _Hash, class _Pred, class _Alloc,\n+\t   bool __cache_hash_code>\n     inline void\n-    swap(unordered_multiset<Value, Hash, Pred, Alloc, cache_hash_code>& x,\n-\t unordered_multiset<Value, Hash, Pred, Alloc, cache_hash_code>& y)\n-   { x.swap(y); }\n+    swap(unordered_multiset<_Value, _Hash, _Pred,\n+\t _Alloc, __cache_hash_code>& __x,\n+\t unordered_multiset<_Value, _Hash, _Pred,\n+\t _Alloc, __cache_hash_code>& __y)\n+    { __x.swap(__y); }\n \n _GLIBCXX_END_NAMESPACE\n }"}]}