{"sha": "a5f09e731173ce7b5fbe6731b0afde5390663147", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTVmMDllNzMxMTczY2U3YjVmYmU2NzMxYjBhZmRlNTM5MDY2MzE0Nw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2010-11-11T16:20:54Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2010-11-11T16:20:54Z"}, "message": "Recognize -(a * b) + c -> fma(-a,b,c).\n\n\t* tree-ssa-math-opts.c (convert_mult_to_fma): Handle a NEGATE_EXPR\n\tin between the MULT and the PLUS/MINUS.\n\nFrom-SVN: r166605", "tree": {"sha": "06e97e21329b81448a04044180f5d2199d9fb106", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/06e97e21329b81448a04044180f5d2199d9fb106"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a5f09e731173ce7b5fbe6731b0afde5390663147", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5f09e731173ce7b5fbe6731b0afde5390663147", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5f09e731173ce7b5fbe6731b0afde5390663147", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5f09e731173ce7b5fbe6731b0afde5390663147/comments", "author": null, "committer": null, "parents": [{"sha": "1004f0c5c83b9cffe17adbaabf935db8ab290911", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1004f0c5c83b9cffe17adbaabf935db8ab290911", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1004f0c5c83b9cffe17adbaabf935db8ab290911"}], "stats": {"total": 112, "additions": 83, "deletions": 29}, "files": [{"sha": "3dd3047165be9d0bcce858cd879b45fa587c14da", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5f09e731173ce7b5fbe6731b0afde5390663147/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5f09e731173ce7b5fbe6731b0afde5390663147/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a5f09e731173ce7b5fbe6731b0afde5390663147", "patch": "@@ -1,3 +1,8 @@\n+2010-11-11  Richard Henderson  <rth@redhat.com>\n+\n+\t* tree-ssa-math-opts.c (convert_mult_to_fma): Handle a NEGATE_EXPR\n+\tin between the MULT and the PLUS/MINUS.\n+\n 2010-11-11  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/46388"}, {"sha": "28401502aa9b306ceedeecfd6cd4d3404c618376", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 78, "deletions": 29, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5f09e731173ce7b5fbe6731b0afde5390663147/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5f09e731173ce7b5fbe6731b0afde5390663147/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=a5f09e731173ce7b5fbe6731b0afde5390663147", "patch": "@@ -1503,7 +1503,7 @@ convert_mult_to_fma (gimple mul_stmt)\n {\n   tree mul_result = gimple_assign_lhs (mul_stmt);\n   tree type = TREE_TYPE (mul_result);\n-  gimple use_stmt, fma_stmt;\n+  gimple use_stmt, neguse_stmt, fma_stmt;\n   use_operand_p use_p;\n   imm_use_iterator imm_iter;\n \n@@ -1529,17 +1529,12 @@ convert_mult_to_fma (gimple mul_stmt)\n   FOR_EACH_IMM_USE_FAST (use_p, imm_iter, mul_result)\n     {\n       enum tree_code use_code;\n+      tree result = mul_result;\n+      bool negate_p = false;\n+      optab opt;\n \n       use_stmt = USE_STMT (use_p);\n \n-      if (!is_gimple_assign (use_stmt))\n-\treturn false;\n-      use_code = gimple_assign_rhs_code (use_stmt);\n-      /* ???  We need to handle NEGATE_EXPR to eventually form fnms.  */\n-      if (use_code != PLUS_EXPR\n-\t  && use_code != MINUS_EXPR)\n-\treturn false;\n-\n       /* For now restrict this operations to single basic blocks.  In theory\n \t we would want to support sinking the multiplication in\n \t m = a*b;\n@@ -1552,32 +1547,82 @@ convert_mult_to_fma (gimple mul_stmt)\n       if (gimple_bb (use_stmt) != gimple_bb (mul_stmt))\n \treturn false;\n \n-      /* We can't handle a * b + a * b.  */\n-      if (gimple_assign_rhs1 (use_stmt) == gimple_assign_rhs2 (use_stmt))\n+      if (!is_gimple_assign (use_stmt))\n \treturn false;\n \n-      /* If the target doesn't support a * b - c then drop the ball.  */\n-      if (gimple_assign_rhs1 (use_stmt) == mul_result\n-\t  && use_code == MINUS_EXPR\n-\t  && optab_handler (fms_optab, TYPE_MODE (type)) == CODE_FOR_nothing)\n-\treturn false;\n+      use_code = gimple_assign_rhs_code (use_stmt);\n+\n+      /* A negate on the multiplication leads to FNMA.  */\n+      if (use_code == NEGATE_EXPR)\n+\t{\n+\t  result = gimple_assign_lhs (use_stmt);\n+\n+\t  /* Make sure the negate statement becomes dead with this\n+\t     single transformation.  */\n+\t  if (!single_imm_use (gimple_assign_lhs (use_stmt),\n+\t\t\t       &use_p, &neguse_stmt))\n+\t    return false;\n+\n+\t  /* Re-validate.  */\n+\t  use_stmt = neguse_stmt;\n+\t  if (gimple_bb (use_stmt) != gimple_bb (mul_stmt))\n+\t    return false;\n+\t  if (!is_gimple_assign (use_stmt))\n+\t    return false;\n+\n+\t  use_code = gimple_assign_rhs_code (use_stmt);\n+\t  negate_p = true;\n+\t}\n \n-      /* If the target doesn't support -a * b + c then drop the ball.  */\n-      if (gimple_assign_rhs2 (use_stmt) == mul_result\n-\t  && use_code == MINUS_EXPR\n-\t  && optab_handler (fnma_optab, TYPE_MODE (type)) == CODE_FOR_nothing)\n+      /* Determine if the target supports the exact form we found.  */\n+      switch (use_code)\n+\t{\n+\tcase MINUS_EXPR:\n+\t  if (gimple_assign_rhs1 (use_stmt) == result)\n+\t    {\n+\t      opt = negate_p ? fnms_optab : fms_optab;\n+\t      break;\n+\t    }\n+\t  negate_p = !negate_p;\n+\t  /* FALLTHRU */\n+\n+\tcase PLUS_EXPR:\n+\t  opt = negate_p ? fnma_optab : fma_optab;\n+\t  break;\n+\n+\tdefault:\n+\t  /* FMA can only be formed from PLUS and MINUS.  */\n+\t  return false;\n+\t}\n+      if (optab_handler (opt, TYPE_MODE (type)) == CODE_FOR_nothing)\n \treturn false;\n \n-      /* We don't yet generate -a * b - c below yet.  */\n+      /* We can't handle a * b + a * b.  */\n+      if (gimple_assign_rhs1 (use_stmt) == gimple_assign_rhs2 (use_stmt))\n+\treturn false;\n     }\n \n   FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, mul_result)\n     {\n-      tree addop, mulop1;\n       gimple_stmt_iterator gsi = gsi_for_stmt (use_stmt);\n+      enum tree_code use_code = gimple_assign_rhs_code (use_stmt);\n+      tree addop, mulop1, result = mul_result;\n+      bool negate_p = false;\n \n-      mulop1 = gimple_assign_rhs1 (mul_stmt);\n-      if (gimple_assign_rhs1 (use_stmt) == mul_result)\n+      if (use_code == NEGATE_EXPR)\n+\t{\n+\t  result = gimple_assign_lhs (use_stmt);\n+\t  single_imm_use (gimple_assign_lhs (use_stmt), &use_p, &neguse_stmt);\n+\t  gsi_remove (&gsi, true);\n+\t  release_defs (use_stmt);\n+\n+\t  use_stmt = neguse_stmt;\n+\t  gsi = gsi_for_stmt (use_stmt);\n+\t  use_code = gimple_assign_rhs_code (use_stmt);\n+\t  negate_p = true;\n+\t}\n+\n+      if (gimple_assign_rhs1 (use_stmt) == result)\n \t{\n \t  addop = gimple_assign_rhs2 (use_stmt);\n \t  /* a * b - c -> a * b + (-c)  */\n@@ -1593,13 +1638,17 @@ convert_mult_to_fma (gimple mul_stmt)\n \t  addop = gimple_assign_rhs1 (use_stmt);\n \t  /* a - b * c -> (-b) * c + a */\n \t  if (gimple_assign_rhs_code (use_stmt) == MINUS_EXPR)\n-\t    mulop1 = force_gimple_operand_gsi (&gsi,\n-\t\t\t\t\t       build1 (NEGATE_EXPR,\n-\t\t\t\t\t\t       type, mulop1),\n-\t\t\t\t\t       true, NULL_TREE, true,\n-\t\t\t\t\t       GSI_SAME_STMT);\n+\t    negate_p = !negate_p;\n \t}\n \n+      mulop1 = gimple_assign_rhs1 (mul_stmt);\n+      if (negate_p)\n+\tmulop1 = force_gimple_operand_gsi (&gsi,\n+\t\t\t\t\t   build1 (NEGATE_EXPR,\n+\t\t\t\t\t\t   type, mulop1),\n+\t\t\t\t\t   true, NULL_TREE, true,\n+\t\t\t\t\t   GSI_SAME_STMT);\n+\n       fma_stmt = gimple_build_assign_with_ops3 (FMA_EXPR,\n \t\t\t\t\t\tgimple_assign_lhs (use_stmt),\n \t\t\t\t\t\tmulop1,"}]}