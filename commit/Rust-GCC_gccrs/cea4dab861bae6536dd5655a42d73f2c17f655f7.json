{"sha": "cea4dab861bae6536dd5655a42d73f2c17f655f7", "node_id": "C_kwDOANBUbNoAKGNlYTRkYWI4NjFiYWU2NTM2ZGQ1NjU1YTQyZDczZjJjMTdmNjU1Zjc", "commit": {"author": {"name": "Siddhesh Poyarekar", "email": "siddhesh@gotplt.org", "date": "2021-11-15T17:33:14Z"}, "committer": {"name": "Siddhesh Poyarekar", "email": "siddhesh@gotplt.org", "date": "2021-11-15T22:50:31Z"}, "message": "gimple-fold: Use ranges to simplify _chk calls\n\nInstead of comparing LEN and SIZE only if they are constants, use their\nranges to decide if LEN will always be lower than or same as SIZE.\n\nThis change ends up putting the stringop-overflow warning line number\nagainst the strcpy implementation, so adjust the warning check to be\nline number agnostic.\n\ngcc/ChangeLog:\n\n\t* gimple-fold.c (known_lower): New function.\n\t(gimple_fold_builtin_strncat_chk,\n\tgimple_fold_builtin_memory_chk, gimple_fold_builtin_stxcpy_chk,\n\tgimple_fold_builtin_stxncpy_chk,\n\tgimple_fold_builtin_snprintf_chk,\n\tgimple_fold_builtin_sprintf_chk): Use it.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.dg/Wobjsize-1.c: Make warning change line agnostic.\n\t* gcc.dg/fold-stringops-2.c: New test.\n\nSigned-off-by: Siddhesh Poyarekar <siddhesh@gotplt.org>", "tree": {"sha": "205fe929f25b0dc3b051f1f72a11b3e71bf101e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/205fe929f25b0dc3b051f1f72a11b3e71bf101e3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cea4dab861bae6536dd5655a42d73f2c17f655f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cea4dab861bae6536dd5655a42d73f2c17f655f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cea4dab861bae6536dd5655a42d73f2c17f655f7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cea4dab861bae6536dd5655a42d73f2c17f655f7/comments", "author": {"login": "siddhesh", "id": 158582, "node_id": "MDQ6VXNlcjE1ODU4Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/158582?v=4", "gravatar_id": "", "url": "https://api.github.com/users/siddhesh", "html_url": "https://github.com/siddhesh", "followers_url": "https://api.github.com/users/siddhesh/followers", "following_url": "https://api.github.com/users/siddhesh/following{/other_user}", "gists_url": "https://api.github.com/users/siddhesh/gists{/gist_id}", "starred_url": "https://api.github.com/users/siddhesh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/siddhesh/subscriptions", "organizations_url": "https://api.github.com/users/siddhesh/orgs", "repos_url": "https://api.github.com/users/siddhesh/repos", "events_url": "https://api.github.com/users/siddhesh/events{/privacy}", "received_events_url": "https://api.github.com/users/siddhesh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "siddhesh", "id": 158582, "node_id": "MDQ6VXNlcjE1ODU4Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/158582?v=4", "gravatar_id": "", "url": "https://api.github.com/users/siddhesh", "html_url": "https://github.com/siddhesh", "followers_url": "https://api.github.com/users/siddhesh/followers", "following_url": "https://api.github.com/users/siddhesh/following{/other_user}", "gists_url": "https://api.github.com/users/siddhesh/gists{/gist_id}", "starred_url": "https://api.github.com/users/siddhesh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/siddhesh/subscriptions", "organizations_url": "https://api.github.com/users/siddhesh/orgs", "repos_url": "https://api.github.com/users/siddhesh/repos", "events_url": "https://api.github.com/users/siddhesh/events{/privacy}", "received_events_url": "https://api.github.com/users/siddhesh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1753b4be981fcb176f56b6ed45f7dbe1177d641", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1753b4be981fcb176f56b6ed45f7dbe1177d641", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1753b4be981fcb176f56b6ed45f7dbe1177d641"}], "stats": {"total": 271, "additions": 133, "deletions": 138}, "files": [{"sha": "dd96830429b312132a3a3564f7c8a3d6c61f43cd", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 81, "deletions": 136, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cea4dab861bae6536dd5655a42d73f2c17f655f7/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cea4dab861bae6536dd5655a42d73f2c17f655f7/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=cea4dab861bae6536dd5655a42d73f2c17f655f7", "patch": "@@ -2031,6 +2031,28 @@ get_maxval_strlen (tree arg, strlen_range_kind rkind, tree *nonstr = NULL)\n   return lendata.decl ? NULL_TREE : lendata.maxlen;\n }\n \n+/* Return true if LEN is known to be less than or equal to (or if STRICT is\n+   true, strictly less than) the lower bound of SIZE at compile time and false\n+   otherwise.  */\n+\n+static bool\n+known_lower (gimple *stmt, tree len, tree size, bool strict = false)\n+{\n+  if (len == NULL_TREE)\n+    return false;\n+\n+  wide_int size_range[2];\n+  wide_int len_range[2];\n+  if (get_range (len, stmt, len_range) && get_range (size, stmt, size_range))\n+    {\n+      if (strict)\n+\treturn wi::ltu_p (len_range[1], size_range[0]);\n+      else\n+       return wi::leu_p (len_range[1], size_range[0]);\n+    }\n+\n+  return false;\n+}\n \n /* Fold function call to builtin strcpy with arguments DEST and SRC.\n    If LEN is not NULL, it represents the length of the string to be\n@@ -2566,16 +2588,10 @@ gimple_fold_builtin_strncat_chk (gimple_stmt_iterator *gsi)\n       return true;\n     }\n \n-  if (! tree_fits_uhwi_p (size))\n-    return false;\n-\n   if (! integer_all_onesp (size))\n     {\n       tree src_len = c_strlen (src, 1);\n-      if (src_len\n-\t  && tree_fits_uhwi_p (src_len)\n-\t  && tree_fits_uhwi_p (len)\n-\t  && ! tree_int_cst_lt (len, src_len))\n+      if (known_lower (stmt, src_len, len))\n \t{\n \t  /* If LEN >= strlen (SRC), optimize into __strcat_chk.  */\n \t  fn = builtin_decl_explicit (BUILT_IN_STRCAT_CHK);\n@@ -3024,39 +3040,25 @@ gimple_fold_builtin_memory_chk (gimple_stmt_iterator *gsi,\n \t}\n     }\n \n-  if (! tree_fits_uhwi_p (size))\n-    return false;\n-\n   tree maxlen = get_maxval_strlen (len, SRK_INT_VALUE);\n-  if (! integer_all_onesp (size))\n+  if (! integer_all_onesp (size)\n+      && !known_lower (stmt, len, size)\n+      && !known_lower (stmt, maxlen, size))\n     {\n-      if (! tree_fits_uhwi_p (len))\n+      /* MAXLEN and LEN both cannot be proved to be less than SIZE, at\n+\t least try to optimize (void) __mempcpy_chk () into\n+\t (void) __memcpy_chk () */\n+      if (fcode == BUILT_IN_MEMPCPY_CHK && ignore)\n \t{\n-\t  /* If LEN is not constant, try MAXLEN too.\n-\t     For MAXLEN only allow optimizing into non-_ocs function\n-\t     if SIZE is >= MAXLEN, never convert to __ocs_fail ().  */\n-\t  if (maxlen == NULL_TREE || ! tree_fits_uhwi_p (maxlen))\n-\t    {\n-\t      if (fcode == BUILT_IN_MEMPCPY_CHK && ignore)\n-\t\t{\n-\t\t  /* (void) __mempcpy_chk () can be optimized into\n-\t\t     (void) __memcpy_chk ().  */\n-\t\t  fn = builtin_decl_explicit (BUILT_IN_MEMCPY_CHK);\n-\t\t  if (!fn)\n-\t\t    return false;\n+\t  fn = builtin_decl_explicit (BUILT_IN_MEMCPY_CHK);\n+\t  if (!fn)\n+\t    return false;\n \n-\t\t  gimple *repl = gimple_build_call (fn, 4, dest, src, len, size);\n-\t\t  replace_call_with_call_and_fold (gsi, repl);\n-\t\t  return true;\n-\t\t}\n-\t      return false;\n-\t    }\n+\t  gimple *repl = gimple_build_call (fn, 4, dest, src, len, size);\n+\t  replace_call_with_call_and_fold (gsi, repl);\n+\t  return true;\n \t}\n-      else\n-\tmaxlen = len;\n-\n-      if (tree_int_cst_lt (size, maxlen))\n-\treturn false;\n+      return false;\n     }\n \n   fn = NULL_TREE;\n@@ -3136,61 +3138,48 @@ gimple_fold_builtin_stxcpy_chk (gimple_stmt_iterator *gsi,\n       return true;\n     }\n \n-  if (! tree_fits_uhwi_p (size))\n-    return false;\n-\n   tree maxlen = get_maxval_strlen (src, SRK_STRLENMAX);\n   if (! integer_all_onesp (size))\n     {\n       len = c_strlen (src, 1);\n-      if (! len || ! tree_fits_uhwi_p (len))\n+      if (!known_lower (stmt, len, size, true)\n+\t  && !known_lower (stmt, maxlen, size, true))\n \t{\n-\t  /* If LEN is not constant, try MAXLEN too.\n-\t     For MAXLEN only allow optimizing into non-_ocs function\n-\t     if SIZE is >= MAXLEN, never convert to __ocs_fail ().  */\n-\t  if (maxlen == NULL_TREE || ! tree_fits_uhwi_p (maxlen))\n+\t  if (fcode == BUILT_IN_STPCPY_CHK)\n \t    {\n-\t      if (fcode == BUILT_IN_STPCPY_CHK)\n-\t\t{\n-\t\t  if (! ignore)\n-\t\t    return false;\n-\n-\t\t  /* If return value of __stpcpy_chk is ignored,\n-\t\t     optimize into __strcpy_chk.  */\n-\t\t  fn = builtin_decl_explicit (BUILT_IN_STRCPY_CHK);\n-\t\t  if (!fn)\n-\t\t    return false;\n-\n-\t\t  gimple *repl = gimple_build_call (fn, 3, dest, src, size);\n-\t\t  replace_call_with_call_and_fold (gsi, repl);\n-\t\t  return true;\n-\t\t}\n-\n-\t      if (! len || TREE_SIDE_EFFECTS (len))\n+\t      if (! ignore)\n \t\treturn false;\n \n-\t      /* If c_strlen returned something, but not a constant,\n-\t\t transform __strcpy_chk into __memcpy_chk.  */\n-\t      fn = builtin_decl_explicit (BUILT_IN_MEMCPY_CHK);\n+\t      /* If return value of __stpcpy_chk is ignored,\n+\t\t optimize into __strcpy_chk.  */\n+\t      fn = builtin_decl_explicit (BUILT_IN_STRCPY_CHK);\n \t      if (!fn)\n \t\treturn false;\n \n-\t      gimple_seq stmts = NULL;\n-\t      len = force_gimple_operand (len, &stmts, true, NULL_TREE);\n-\t      len = gimple_convert (&stmts, loc, size_type_node, len);\n-\t      len = gimple_build (&stmts, loc, PLUS_EXPR, size_type_node, len,\n-\t\t\t\t  build_int_cst (size_type_node, 1));\n-\t      gsi_insert_seq_before (gsi, stmts, GSI_SAME_STMT);\n-\t      gimple *repl = gimple_build_call (fn, 4, dest, src, len, size);\n+\t      gimple *repl = gimple_build_call (fn, 3, dest, src, size);\n \t      replace_call_with_call_and_fold (gsi, repl);\n \t      return true;\n \t    }\n-\t}\n-      else\n-\tmaxlen = len;\n \n-      if (! tree_int_cst_lt (maxlen, size))\n-\treturn false;\n+\t  if (! len || TREE_SIDE_EFFECTS (len))\n+\t    return false;\n+\n+\t  /* If c_strlen returned something, but not provably less than size,\n+\t     transform __strcpy_chk into __memcpy_chk.  */\n+\t  fn = builtin_decl_explicit (BUILT_IN_MEMCPY_CHK);\n+\t  if (!fn)\n+\t    return false;\n+\n+\t  gimple_seq stmts = NULL;\n+\t  len = force_gimple_operand (len, &stmts, true, NULL_TREE);\n+\t  len = gimple_convert (&stmts, loc, size_type_node, len);\n+\t  len = gimple_build (&stmts, loc, PLUS_EXPR, size_type_node, len,\n+\t\t\t      build_int_cst (size_type_node, 1));\n+\t  gsi_insert_seq_before (gsi, stmts, GSI_SAME_STMT);\n+\t  gimple *repl = gimple_build_call (fn, 4, dest, src, len, size);\n+\t  replace_call_with_call_and_fold (gsi, repl);\n+\t  return true;\n+\t}\n     }\n \n   /* If __builtin_st{r,p}cpy_chk is used, assume st{r,p}cpy is available.  */\n@@ -3220,41 +3209,23 @@ gimple_fold_builtin_stxncpy_chk (gimple_stmt_iterator *gsi,\n   bool ignore = gimple_call_lhs (stmt) == NULL_TREE;\n   tree fn;\n \n-  if (! tree_fits_uhwi_p (size))\n-    return false;\n-\n   tree maxlen = get_maxval_strlen (len, SRK_INT_VALUE);\n-  if (! integer_all_onesp (size))\n+  if (! integer_all_onesp (size)\n+      && !known_lower (stmt, len, size) && !known_lower (stmt, maxlen, size))\n     {\n-      if (! tree_fits_uhwi_p (len))\n+      if (fcode == BUILT_IN_STPNCPY_CHK && ignore)\n \t{\n-\t  /* If LEN is not constant, try MAXLEN too.\n-\t     For MAXLEN only allow optimizing into non-_ocs function\n-\t     if SIZE is >= MAXLEN, never convert to __ocs_fail ().  */\n-\t  if (maxlen == NULL_TREE || ! tree_fits_uhwi_p (maxlen))\n+\t  /* If return value of __stpncpy_chk is ignored,\n+\t     optimize into __strncpy_chk.  */\n+\t  fn = builtin_decl_explicit (BUILT_IN_STRNCPY_CHK);\n+\t  if (fn)\n \t    {\n-\t      if (fcode == BUILT_IN_STPNCPY_CHK && ignore)\n-\t\t{\n-\t\t  /* If return value of __stpncpy_chk is ignored,\n-\t\t     optimize into __strncpy_chk.  */\n-\t\t  fn = builtin_decl_explicit (BUILT_IN_STRNCPY_CHK);\n-\t\t  if (fn)\n-\t\t    {\n-\t\t      gimple *repl = gimple_build_call (fn, 4, dest, src, len,\n-\t\t\t\t\t\t\tsize);\n-\t\t      replace_call_with_call_and_fold (gsi, repl);\n-\t\t      return true;\n-\t\t    }\n-\t\t}\n-\n-\t      return false;\n+\t      gimple *repl = gimple_build_call (fn, 4, dest, src, len, size);\n+\t      replace_call_with_call_and_fold (gsi, repl);\n+\t      return true;\n \t    }\n \t}\n-      else\n-\tmaxlen = len;\n-\n-      if (tree_int_cst_lt (size, maxlen))\n-\treturn false;\n+      return false;\n     }\n \n   /* If __builtin_st{r,p}ncpy_chk is used, assume st{r,p}ncpy is available.  */\n@@ -3374,27 +3345,11 @@ gimple_fold_builtin_snprintf_chk (gimple_stmt_iterator *gsi,\n   size = gimple_call_arg (stmt, 3);\n   fmt = gimple_call_arg (stmt, 4);\n \n-  if (! tree_fits_uhwi_p (size))\n+  tree maxlen = get_maxval_strlen (len, SRK_INT_VALUE);\n+  if (! integer_all_onesp (size)\n+      && !known_lower (stmt, len, size) && !known_lower (stmt, maxlen, size))\n     return false;\n \n-  if (! integer_all_onesp (size))\n-    {\n-      tree maxlen = get_maxval_strlen (len, SRK_INT_VALUE);\n-      if (! tree_fits_uhwi_p (len))\n-\t{\n-\t  /* If LEN is not constant, try MAXLEN too.\n-\t     For MAXLEN only allow optimizing into non-_ocs function\n-\t     if SIZE is >= MAXLEN, never convert to __ocs_fail ().  */\n-\t  if (maxlen == NULL_TREE || ! tree_fits_uhwi_p (maxlen))\n-\t    return false;\n-\t}\n-      else\n-\tmaxlen = len;\n-\n-      if (tree_int_cst_lt (size, maxlen))\n-\treturn false;\n-    }\n-\n   if (!init_target_chars ())\n     return false;\n \n@@ -3453,9 +3408,6 @@ gimple_fold_builtin_sprintf_chk (gimple_stmt_iterator *gsi,\n   size = gimple_call_arg (stmt, 2);\n   fmt = gimple_call_arg (stmt, 3);\n \n-  if (! tree_fits_uhwi_p (size))\n-    return false;\n-\n   len = NULL_TREE;\n \n   if (!init_target_chars ())\n@@ -3482,20 +3434,13 @@ gimple_fold_builtin_sprintf_chk (gimple_stmt_iterator *gsi,\n \t    {\n \t      arg = gimple_call_arg (stmt, 4);\n \t      if (POINTER_TYPE_P (TREE_TYPE (arg)))\n-\t\t{\n-\t\t  len = c_strlen (arg, 1);\n-\t\t  if (! len || ! tree_fits_uhwi_p (len))\n-\t\t    len = NULL_TREE;\n-\t\t}\n+\t\tlen = c_strlen (arg, 1);\n \t    }\n \t}\n     }\n \n-  if (! integer_all_onesp (size))\n-    {\n-      if (! len || ! tree_int_cst_lt (len, size))\n-\treturn false;\n-    }\n+  if (! integer_all_onesp (size) && !known_lower (stmt, len, size, true))\n+    return false;\n \n   /* Only convert __{,v}sprintf_chk to {,v}sprintf if flag is 0\n      or if format doesn't contain % chars or is \"%s\".  */"}, {"sha": "988b8bcbf35d8ff2635c196fa7ec6c8a501ddcec", "filename": "gcc/testsuite/gcc.dg/Wobjsize-1.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cea4dab861bae6536dd5655a42d73f2c17f655f7/gcc%2Ftestsuite%2Fgcc.dg%2FWobjsize-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cea4dab861bae6536dd5655a42d73f2c17f655f7/gcc%2Ftestsuite%2Fgcc.dg%2FWobjsize-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWobjsize-1.c?ref=cea4dab861bae6536dd5655a42d73f2c17f655f7", "patch": "@@ -7,11 +7,12 @@ char buf[6];\n \n int main(int argc, char **argv)\n {\n-  strcpy (buf,\"hello \");    /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n+  strcpy (buf,\"hello \");\n   return 0;\n }\n \n-/* { dg-message \"file included\" \"included\" { target *-*-* } 0 }\n+/* { dg-warning \"\\\\\\[-Wstringop-overflow\" \"warning\" { target *-*-* } 0 }\n+   { dg-message \"file included\" \"included\" { target *-*-* } 0 }\n    { dg-message \"inlined from\" \"inlined\" { target *-*-* } 0 }\n \n    The test might emit two warnings, one for the strcpy call and"}, {"sha": "0b415dfaf57fe0679e30d3a7e457c435d3d6d91e", "filename": "gcc/testsuite/gcc.dg/fold-stringops-2.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cea4dab861bae6536dd5655a42d73f2c17f655f7/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-stringops-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cea4dab861bae6536dd5655a42d73f2c17f655f7/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-stringops-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-stringops-2.c?ref=cea4dab861bae6536dd5655a42d73f2c17f655f7", "patch": "@@ -0,0 +1,49 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#define bos(__d) __builtin_object_size ((__d), 0)\n+\n+char *\n+safe1 (const char *src, int cond, __SIZE_TYPE__ len)\n+{\n+  char *dst;\n+\n+  if (cond)\n+    dst = __builtin_malloc (1024);\n+  else\n+    dst = __builtin_malloc (2048);\n+\n+  len = len > 2048 ? 2048 : len;\n+\n+  return __builtin___memcpy_chk (dst, src, len, bos (dst));\n+}\n+\n+char *\n+safe2 (const char *src, int cond, unsigned char len)\n+{\n+  char *dst;\n+\n+  if (cond)\n+    dst = __builtin_malloc (1024);\n+  else\n+    dst = __builtin_malloc (2048);\n+\n+  return __builtin___strncpy_chk (dst, src, len, bos (dst));\n+}\n+\n+int\n+safe3 (const char *src, int cond, unsigned char len)\n+{\n+  char *dst;\n+\n+  if (cond)\n+    dst = __builtin_malloc (1024);\n+  else\n+    dst = __builtin_malloc (2048);\n+\n+  return __builtin___snprintf_chk (dst, len, 0, bos (dst), \"%s\", src);\n+}\n+\n+/* { dg-final { scan-assembler-not \"__memcpy_chk\" } } */\n+/* { dg-final { scan-assembler-not \"__strncpy_chk\" } } */\n+/* { dg-final { scan-assembler-not \"__snprintf_chk\" } } */"}]}