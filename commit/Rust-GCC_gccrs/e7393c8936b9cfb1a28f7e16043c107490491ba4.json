{"sha": "e7393c8936b9cfb1a28f7e16043c107490491ba4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTczOTNjODkzNmI5Y2ZiMWEyOGY3ZTE2MDQzYzEwNzQ5MDQ5MWJhNA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2019-05-31T21:38:35Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2019-05-31T21:38:35Z"}, "message": "tree.h (OMP_CLAUSE__CONDTEMP__ITER): Define.\n\n\t* tree.h (OMP_CLAUSE__CONDTEMP__ITER): Define.\n\t* gimplify.c (gimplify_scan_omp_clauses): Allow lastprivate conditional\n\ton OMP_SIMD if not nested inside of worksharing loop that also has\n\tlastprivate conditional clause for the same decl.\n\t(gimplify_omp_for): Add _condtemp_ clauses to OMP_SIMD if needed.\n\t* omp-low.c (scan_sharing_clauses): Handle OMP_CLAUSE__CONDTEMP_ also\n\ton simd.\n\t(lower_rec_input_clauses): Likewise.  Handle lastprivate conditional\n\ton simd construct.\n\t(lower_lastprivate_conditional_clauses): Handle lastprivate conditional\n\ton simd construct.\n\t(lower_lastprivate_clauses): Likewise.\n\t(lower_omp_sections): Call lower_lastprivate_conditional_clauses before\n\tcalling lower_rec_input_clauses.\n\t(lower_omp_for): Likewise.\n\t(lower_omp_1): Use first rather than second OMP_CLAUSE__CONDTEMP_\n\tclause on simd construct.\n\t* omp-expand.c (expand_omp_simd): Initialize cond_var if\n\tOMP_CLAUSE__CONDTEMP_ clause is present.\n\n\t* c-c++-common/gomp/lastprivate-conditional-2.c (foo): Don't expect\n\ta sorry on lastprivate conditional on simd construct.\n\t* gcc.dg/vect/vect-simd-6.c: New test.\n\t* gcc.dg/vect/vect-simd-7.c: New test.\n\nFrom-SVN: r271825", "tree": {"sha": "d0fa7f6aa5f6d8bb93ca641511f03dc17e4ee9be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d0fa7f6aa5f6d8bb93ca641511f03dc17e4ee9be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e7393c8936b9cfb1a28f7e16043c107490491ba4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7393c8936b9cfb1a28f7e16043c107490491ba4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7393c8936b9cfb1a28f7e16043c107490491ba4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7393c8936b9cfb1a28f7e16043c107490491ba4/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1ce8fc63a4132b66ced527afd2c88b840ecbb0b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ce8fc63a4132b66ced527afd2c88b840ecbb0b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ce8fc63a4132b66ced527afd2c88b840ecbb0b9"}], "stats": {"total": 332, "additions": 312, "deletions": 20}, "files": [{"sha": "2717c3cf0733fbef500602510b3ce853fb23f729", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7393c8936b9cfb1a28f7e16043c107490491ba4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7393c8936b9cfb1a28f7e16043c107490491ba4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e7393c8936b9cfb1a28f7e16043c107490491ba4", "patch": "@@ -1,5 +1,25 @@\n 2019-05-31  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* tree.h (OMP_CLAUSE__CONDTEMP__ITER): Define.\n+\t* gimplify.c (gimplify_scan_omp_clauses): Allow lastprivate conditional\n+\ton OMP_SIMD if not nested inside of worksharing loop that also has\n+\tlastprivate conditional clause for the same decl.\n+\t(gimplify_omp_for): Add _condtemp_ clauses to OMP_SIMD if needed.\n+\t* omp-low.c (scan_sharing_clauses): Handle OMP_CLAUSE__CONDTEMP_ also\n+\ton simd.\n+\t(lower_rec_input_clauses): Likewise.  Handle lastprivate conditional\n+\ton simd construct.\n+\t(lower_lastprivate_conditional_clauses): Handle lastprivate conditional\n+\ton simd construct.\n+\t(lower_lastprivate_clauses): Likewise.\n+\t(lower_omp_sections): Call lower_lastprivate_conditional_clauses before\n+\tcalling lower_rec_input_clauses.\n+\t(lower_omp_for): Likewise.\n+\t(lower_omp_1): Use first rather than second OMP_CLAUSE__CONDTEMP_\n+\tclause on simd construct.\n+\t* omp-expand.c (expand_omp_simd): Initialize cond_var if\n+\tOMP_CLAUSE__CONDTEMP_ clause is present.\n+\n \t* omp-low.c (lower_rec_simd_input_clauses): Set TREE_THIS_NOTRAP on\n \tivar and lvar.\n "}, {"sha": "d4fbe0c55a555ec52d179d1aa13c64265f192276", "filename": "gcc/gimplify.c", "status": "modified", "additions": 39, "deletions": 5, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7393c8936b9cfb1a28f7e16043c107490491ba4/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7393c8936b9cfb1a28f7e16043c107490491ba4/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=e7393c8936b9cfb1a28f7e16043c107490491ba4", "patch": "@@ -8146,17 +8146,29 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t    }\n \t  if (OMP_CLAUSE_LASTPRIVATE_CONDITIONAL (c))\n \t    {\n-\t      if (code == OMP_FOR\n-\t\t  || code == OMP_SECTIONS\n-\t\t  || region_type == ORT_COMBINED_PARALLEL)\n-\t\tflags |= GOVD_LASTPRIVATE_CONDITIONAL;\n-\t      else\n+\t      splay_tree_node n = NULL;\n+\t      if (code == OMP_SIMD\n+\t\t  && outer_ctx\n+\t\t  && outer_ctx->region_type == ORT_WORKSHARE)\n+\t\t{\n+\t\t  n = splay_tree_lookup (outer_ctx->variables,\n+\t\t\t\t\t (splay_tree_key) decl);\n+\t\t  if (n == NULL\n+\t\t      && outer_ctx->outer_context\n+\t\t      && (outer_ctx->outer_context->region_type\n+\t\t\t  == ORT_COMBINED_PARALLEL))\n+\t\t    n = splay_tree_lookup (outer_ctx->outer_context->variables,\n+\t\t\t\t\t   (splay_tree_key) decl);\n+\t\t}\n+\t      if (n && (n->value & GOVD_LASTPRIVATE_CONDITIONAL) != 0)\n \t\t{\n \t\t  sorry_at (OMP_CLAUSE_LOCATION (c),\n \t\t\t    \"%<conditional%> modifier on %<lastprivate%> \"\n \t\t\t    \"clause not supported yet\");\n \t\t  OMP_CLAUSE_LASTPRIVATE_CONDITIONAL (c) = 0;\n \t\t}\n+\t      else\n+\t\tflags |= GOVD_LASTPRIVATE_CONDITIONAL;\n \t    }\n \t  if (outer_ctx\n \t      && (outer_ctx->region_type == ORT_COMBINED_PARALLEL\n@@ -11559,6 +11571,28 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \t  omp_add_variable (ctx, var, GOVD_CONDTEMP | GOVD_SEEN);\n \t}\n     }\n+  else if (TREE_CODE (orig_for_stmt) == OMP_SIMD)\n+    {\n+      unsigned lastprivate_conditional = 0;\n+      for (tree c = gimple_omp_for_clauses (gfor); c; c = OMP_CLAUSE_CHAIN (c))\n+\tif (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LASTPRIVATE\n+\t    && OMP_CLAUSE_LASTPRIVATE_CONDITIONAL (c))\n+\t  ++lastprivate_conditional;\n+      if (lastprivate_conditional)\n+\t{\n+\t  struct omp_for_data fd;\n+\t  omp_extract_for_data (gfor, &fd, NULL);\n+\t  tree type = unsigned_type_for (fd.iter_type);\n+\t  while (lastprivate_conditional--)\n+\t    {\n+\t      tree c = build_omp_clause (UNKNOWN_LOCATION,\n+\t\t\t\t\t OMP_CLAUSE__CONDTEMP_);\n+\t      OMP_CLAUSE_DECL (c) = create_tmp_var (type);\n+\t      OMP_CLAUSE_CHAIN (c) = gimple_omp_for_clauses (gfor);\n+\t      gimple_omp_for_set_clauses (gfor, c);\n+\t    }\n+\t}\n+    }\n \n   if (ret != GS_ALL_DONE)\n     return GS_ERROR;"}, {"sha": "0c31f95ec309116dea36c6fa3699993989535ae9", "filename": "gcc/omp-expand.c", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7393c8936b9cfb1a28f7e16043c107490491ba4/gcc%2Fomp-expand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7393c8936b9cfb1a28f7e16043c107490491ba4/gcc%2Fomp-expand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-expand.c?ref=e7393c8936b9cfb1a28f7e16043c107490491ba4", "patch": "@@ -4908,7 +4908,10 @@ expand_omp_simd (struct omp_region *region, struct omp_for_data *fd)\n \t\t\t      OMP_CLAUSE_IF);\n   tree simdlen = omp_find_clause (gimple_omp_for_clauses (fd->for_stmt),\n \t\t\t\t  OMP_CLAUSE_SIMDLEN);\n+  tree condtemp = omp_find_clause (gimple_omp_for_clauses (fd->for_stmt),\n+\t\t\t\t   OMP_CLAUSE__CONDTEMP_);\n   tree n1, n2;\n+  tree cond_var = condtemp ? OMP_CLAUSE_DECL (condtemp) : NULL_TREE;\n \n   if (safelen)\n     {\n@@ -5038,6 +5041,18 @@ expand_omp_simd (struct omp_region *region, struct omp_for_data *fd)\n \t    expand_omp_build_assign (&gsi, fd->loops[i].v, t);\n \t  }\n     }\n+  if (cond_var)\n+    {\n+      if (POINTER_TYPE_P (type)\n+\t  || TREE_CODE (n1) != INTEGER_CST\n+\t  || fd->loop.cond_code != LT_EXPR\n+\t  || tree_int_cst_sgn (n1) != 1)\n+\texpand_omp_build_assign (&gsi, cond_var,\n+\t\t\t\t build_one_cst (TREE_TYPE (cond_var)));\n+      else\n+\texpand_omp_build_assign (&gsi, cond_var,\n+\t\t\t\t fold_convert (TREE_TYPE (cond_var), n1));\n+    }\n \n   /* Remove the GIMPLE_OMP_FOR statement.  */\n   gsi_remove (&gsi, true);\n@@ -5103,6 +5118,19 @@ expand_omp_simd (struct omp_region *region, struct omp_for_data *fd)\n \t      expand_omp_build_assign (&gsi, fd->loops[i].v, t);\n \t    }\n \t}\n+      if (cond_var)\n+\t{\n+\t  if (POINTER_TYPE_P (type)\n+\t      || TREE_CODE (n1) != INTEGER_CST\n+\t      || fd->loop.cond_code != LT_EXPR\n+\t      || tree_int_cst_sgn (n1) != 1)\n+\t    t = fold_build2 (PLUS_EXPR, TREE_TYPE (cond_var), cond_var,\n+\t\t\t     build_one_cst (TREE_TYPE (cond_var)));\n+\t  else\n+\t    t = fold_build2 (PLUS_EXPR, TREE_TYPE (cond_var), cond_var,\n+\t\t\t     fold_convert (TREE_TYPE (cond_var), step));\n+\t  expand_omp_build_assign (&gsi, cond_var, t);\n+\t}\n \n       /* Remove GIMPLE_OMP_CONTINUE.  */\n       gsi_remove (&gsi, true);"}, {"sha": "cfc237cd8951eea1b502f90467140d29ff0c9863", "filename": "gcc/omp-low.c", "status": "modified", "additions": 112, "deletions": 14, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7393c8936b9cfb1a28f7e16043c107490491ba4/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7393c8936b9cfb1a28f7e16043c107490491ba4/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=e7393c8936b9cfb1a28f7e16043c107490491ba4", "patch": "@@ -1414,12 +1414,16 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \t  break;\n \n \tcase OMP_CLAUSE__CONDTEMP_:\n+\t  decl = OMP_CLAUSE_DECL (c);\n \t  if (is_parallel_ctx (ctx))\n \t    {\n-\t      decl = OMP_CLAUSE_DECL (c);\n \t      install_var_field (decl, false, 3, ctx);\n \t      install_var_local (decl, ctx);\n \t    }\n+\t  else if (gimple_code (ctx->stmt) == GIMPLE_OMP_FOR\n+\t\t   && (gimple_omp_for_kind (ctx->stmt) & GF_OMP_FOR_SIMD)\n+\t\t   && !OMP_CLAUSE__CONDTEMP__ITER (c))\n+\t    install_var_local (decl, ctx);\n \t  break;\n \n \tcase OMP_CLAUSE__CACHE_:\n@@ -3840,6 +3844,11 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t  if (integer_onep (OMP_CLAUSE_SIMDLEN_EXPR (c)))\n \t    sctx.max_vf = 1;\n \t  break;\n+\tcase OMP_CLAUSE__CONDTEMP_:\n+\t  /* FIXME: lastprivate(conditional:) not handled for SIMT yet.  */\n+\t  if (sctx.is_simt)\n+\t    sctx.max_vf = 1;\n+\t  break;\n \tdefault:\n \t  continue;\n \t}\n@@ -4054,7 +4063,8 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t}\n \t      continue;\n \t    case OMP_CLAUSE__CONDTEMP_:\n-\t      if (is_parallel_ctx (ctx))\n+\t      if (is_parallel_ctx (ctx)\n+\t\t  || (is_simd && !OMP_CLAUSE__CONDTEMP__ITER (c)))\n \t\tbreak;\n \t      continue;\n \t    default:\n@@ -4730,6 +4740,11 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t  SET_DECL_VALUE_EXPR (new_var, x);\n \t\t  DECL_HAS_VALUE_EXPR_P (new_var) = 1;\n \t\t}\n+\t      else if (is_simd && !OMP_CLAUSE__CONDTEMP__ITER (c))\n+\t\t{\n+\t\t  x = build_zero_cst (TREE_TYPE (var));\n+\t\t  goto do_private;\n+\t\t}\n \t      break;\n \n \t    case OMP_CLAUSE_LASTPRIVATE:\n@@ -4757,15 +4772,52 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t{\n \t\t  tree y = lang_hooks.decls.omp_clause_dtor (c, new_var);\n \t\t  if ((TREE_ADDRESSABLE (new_var) || nx || y\n-\t\t       || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LASTPRIVATE)\n+\t\t       || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LASTPRIVATE\n+\t\t       || OMP_CLAUSE_CODE (c) == OMP_CLAUSE__CONDTEMP_)\n \t\t      && lower_rec_simd_input_clauses (new_var, ctx, &sctx,\n \t\t\t\t\t\t       ivar, lvar))\n \t\t    {\n \t\t      if (nx)\n \t\t\tx = lang_hooks.decls.omp_clause_default_ctor\n \t\t\t\t\t\t(c, unshare_expr (ivar), x);\n+\t\t      else if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE__CONDTEMP_)\n+\t\t\t{\n+\t\t\t  x = build2 (MODIFY_EXPR, TREE_TYPE (ivar),\n+\t\t\t\t      unshare_expr (ivar), x);\n+\t\t\t  nx = x;\n+\t\t\t}\n \t\t      if (nx && x)\n \t\t\tgimplify_and_add (x, &llist[0]);\n+\t\t      if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LASTPRIVATE\n+\t\t\t  && OMP_CLAUSE_LASTPRIVATE_CONDITIONAL (c))\n+\t\t\t{\n+\t\t\t  tree v\n+\t\t\t    = *ctx->lastprivate_conditional_map->get (new_var);\n+\t\t\t  tree t = create_tmp_var (TREE_TYPE (v));\n+\t\t\t  tree z = build_zero_cst (TREE_TYPE (v));\n+\t\t\t  tree orig_v\n+\t\t\t    = build_outer_var_ref (var, ctx,\n+\t\t\t\t\t\t   OMP_CLAUSE_LASTPRIVATE);\n+\t\t\t  gimple_seq_add_stmt (dlist,\n+\t\t\t\t\t       gimple_build_assign (t, z));\n+\t\t\t  gcc_assert (DECL_HAS_VALUE_EXPR_P (v));\n+\t\t\t  tree civar = DECL_VALUE_EXPR (v);\n+\t\t\t  gcc_assert (TREE_CODE (civar) == ARRAY_REF);\n+\t\t\t  civar = unshare_expr (civar);\n+\t\t\t  TREE_OPERAND (civar, 1) = sctx.idx;\n+\t\t\t  x = build2 (MODIFY_EXPR, TREE_TYPE (t), t,\n+\t\t\t\t      unshare_expr (civar));\n+\t\t\t  x = build2 (COMPOUND_EXPR, TREE_TYPE (orig_v), x,\n+\t\t\t\t      build2 (MODIFY_EXPR, TREE_TYPE (orig_v),\n+\t\t\t\t\t      orig_v, unshare_expr (ivar)));\n+\t\t\t  tree cond = build2 (LT_EXPR, boolean_type_node, t,\n+\t\t\t\t\t      civar);\n+\t\t\t  x = build3 (COND_EXPR, void_type_node, cond, x,\n+\t\t\t\t      void_node);\n+\t\t\t  gimple_seq tseq = NULL;\n+\t\t\t  gimplify_and_add (x, &tseq);\n+\t\t\t  gimple_seq_add_seq (&llist[1], tseq);\n+\t\t\t}\n \t\t      if (y)\n \t\t\t{\n \t\t\t  y = lang_hooks.decls.omp_clause_dtor (c, ivar);\n@@ -5222,7 +5274,17 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n     }\n \n   if (known_eq (sctx.max_vf, 1U))\n-    sctx.is_simt = false;\n+    {\n+      sctx.is_simt = false;\n+      if (ctx->lastprivate_conditional_map)\n+\t{\n+\t  /* When not vectorized, treat lastprivate(conditional:) like\n+\t     normal lastprivate, as there will be just one simd lane\n+\t     writing the privatized variable.  */\n+\t  delete ctx->lastprivate_conditional_map;\n+\t  ctx->lastprivate_conditional_map = NULL;\n+\t}\n+    }\n \n   if (nonconst_simd_if)\n     {\n@@ -5398,10 +5460,39 @@ lower_lastprivate_conditional_clauses (tree *clauses, omp_context *ctx)\n   tree iter_type = NULL_TREE;\n   tree cond_ptr = NULL_TREE;\n   tree iter_var = NULL_TREE;\n+  bool is_simd = (gimple_code (ctx->stmt) == GIMPLE_OMP_FOR\n+\t\t  && gimple_omp_for_kind (ctx->stmt) & GF_OMP_FOR_SIMD);\n+  tree next = *clauses;\n   for (tree c = *clauses; c; c = OMP_CLAUSE_CHAIN (c))\n     if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LASTPRIVATE\n \t&& OMP_CLAUSE_LASTPRIVATE_CONDITIONAL (c))\n       {\n+\tif (is_simd)\n+\t  {\n+\t    tree cc = omp_find_clause (next, OMP_CLAUSE__CONDTEMP_);\n+\t    gcc_assert (cc);\n+\t    if (iter_type == NULL_TREE)\n+\t      {\n+\t\titer_type = TREE_TYPE (OMP_CLAUSE_DECL (cc));\n+\t\titer_var = create_tmp_var_raw (iter_type);\n+\t\tDECL_CONTEXT (iter_var) = current_function_decl;\n+\t\tDECL_SEEN_IN_BIND_EXPR_P (iter_var) = 1;\n+\t\tDECL_CHAIN (iter_var) = ctx->block_vars;\n+\t\tctx->block_vars = iter_var;\n+\t\ttree c3\n+\t\t  = build_omp_clause (UNKNOWN_LOCATION, OMP_CLAUSE__CONDTEMP_);\n+\t\tOMP_CLAUSE__CONDTEMP__ITER (c3) = 1;\n+\t\tOMP_CLAUSE_DECL (c3) = iter_var;\n+\t\tOMP_CLAUSE_CHAIN (c3) = *clauses;\n+\t\t*clauses = c3;\n+\t\tctx->lastprivate_conditional_map = new hash_map<tree, tree>;\n+\t      }\n+\t    next = OMP_CLAUSE_CHAIN (cc);\n+\t    tree o = lookup_decl (OMP_CLAUSE_DECL (c), ctx);\n+\t    tree v = lookup_decl (OMP_CLAUSE_DECL (cc), ctx);\n+\t    ctx->lastprivate_conditional_map->put (o, v);\n+\t    continue;\n+\t  }\n \tif (iter_type == NULL)\n \t  {\n \t    if (gimple_code (ctx->stmt) == GIMPLE_OMP_FOR)\n@@ -5440,6 +5531,7 @@ lower_lastprivate_conditional_clauses (tree *clauses, omp_context *ctx)\n \t    ctx->block_vars = iter_var;\n \t    tree c3\n \t      = build_omp_clause (UNKNOWN_LOCATION, OMP_CLAUSE__CONDTEMP_);\n+\t    OMP_CLAUSE__CONDTEMP__ITER (c3) = 1;\n \t    OMP_CLAUSE_DECL (c3) = iter_var;\n \t    OMP_CLAUSE_CHAIN (c3) = OMP_CLAUSE_CHAIN (c2);\n \t    OMP_CLAUSE_CHAIN (c2) = c3;\n@@ -5559,9 +5651,12 @@ lower_lastprivate_clauses (tree clauses, tree predicate, gimple_seq *body_p,\n       tree lab2 = NULL_TREE;\n \n       if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LASTPRIVATE\n-\t  && OMP_CLAUSE_LASTPRIVATE_CONDITIONAL (c))\n+\t  && OMP_CLAUSE_LASTPRIVATE_CONDITIONAL (c)\n+\t  && ctx->lastprivate_conditional_map)\n \t{\n-\t  gcc_assert (body_p && ctx->lastprivate_conditional_map);\n+\t  gcc_assert (body_p);\n+\t  if (simduid)\n+\t    goto next;\n \t  if (cond_ptr == NULL_TREE)\n \t    {\n \t      cond_ptr = omp_find_clause (orig_clauses, OMP_CLAUSE__CONDTEMP_);\n@@ -5701,6 +5796,7 @@ lower_lastprivate_clauses (tree clauses, tree predicate, gimple_seq *body_p,\n \t    gimple_seq_add_stmt (this_stmt_list, gimple_build_label (lab2));\n \t}\n \n+     next:\n       c = OMP_CLAUSE_CHAIN (c);\n       if (c == NULL && !par_clauses)\n \t{\n@@ -6826,15 +6922,15 @@ lower_omp_sections (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n       gimple_seq_add_stmt (&ilist, gimple_build_assign (rtmp, temp));\n     }\n \n+  tree *clauses_ptr = gimple_omp_sections_clauses_ptr (stmt);\n+  lower_lastprivate_conditional_clauses (clauses_ptr, ctx);\n+\n   lower_rec_input_clauses (gimple_omp_sections_clauses (stmt),\n       \t\t\t   &ilist, &dlist, ctx, NULL);\n \n   control = create_tmp_var (unsigned_type_node, \".section\");\n   gimple_omp_sections_set_control (stmt, control);\n \n-  tree *clauses_ptr = gimple_omp_sections_clauses_ptr (stmt);\n-  lower_lastprivate_conditional_clauses (clauses_ptr, ctx);\n-\n   new_body = gimple_omp_body (stmt);\n   gimple_omp_set_body (stmt, NULL);\n   tgsi = gsi_start (new_body);\n@@ -8486,14 +8582,14 @@ lower_omp_for (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n       gimple_seq_add_stmt (&body, gimple_build_assign (rtmp, temp));\n     }\n \n+  lower_lastprivate_conditional_clauses (gimple_omp_for_clauses_ptr (stmt),\n+\t\t\t\t\t ctx);\n+\n   lower_rec_input_clauses (gimple_omp_for_clauses (stmt), &body, &dlist, ctx,\n \t\t\t   fdp);\n   gimple_seq_add_seq (rclauses ? &tred_ilist : &body,\n \t\t      gimple_omp_for_pre_body (stmt));\n \n-  lower_lastprivate_conditional_clauses (gimple_omp_for_clauses_ptr (stmt),\n-\t\t\t\t\t ctx);\n-\n   lower_omp (gimple_omp_body_ptr (stmt), ctx);\n \n   /* Lower the header expressions.  At this point, we can assume that\n@@ -10721,8 +10817,10 @@ lower_omp_1 (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t\telse\n \t\t  clauses = gimple_omp_sections_clauses (up->stmt);\n \t\ttree c = omp_find_clause (clauses, OMP_CLAUSE__CONDTEMP_);\n-\t\tc = omp_find_clause (OMP_CLAUSE_CHAIN (c),\n-\t\t\t\t     OMP_CLAUSE__CONDTEMP_);\n+\t\tif (!OMP_CLAUSE__CONDTEMP__ITER (c))\n+\t\t  c = omp_find_clause (OMP_CLAUSE_CHAIN (c),\n+\t\t\t\t       OMP_CLAUSE__CONDTEMP_);\n+\t\tgcc_assert (OMP_CLAUSE__CONDTEMP__ITER (c));\n \t\tgimple *g = gimple_build_assign (*v, OMP_CLAUSE_DECL (c));\n \t\tgsi_insert_after (gsi_p, g, GSI_SAME_STMT);\n \t      }"}, {"sha": "04e7f552e3fc22c673959fbf542bf8afe052e778", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7393c8936b9cfb1a28f7e16043c107490491ba4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7393c8936b9cfb1a28f7e16043c107490491ba4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e7393c8936b9cfb1a28f7e16043c107490491ba4", "patch": "@@ -1,5 +1,10 @@\n 2019-05-31  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* c-c++-common/gomp/lastprivate-conditional-2.c (foo): Don't expect\n+\ta sorry on lastprivate conditional on simd construct.\n+\t* gcc.dg/vect/vect-simd-6.c: New test.\n+\t* gcc.dg/vect/vect-simd-7.c: New test.\n+\n \t* gcc.dg/vect/vect-simd-5.c: New test.\n \n 2019-05-31  Xiong Hu Luo  <luoxhu@linux.ibm.com>"}, {"sha": "95626087b6ec16dccda923f722dc8b7afe13ae2c", "filename": "gcc/testsuite/c-c++-common/gomp/lastprivate-conditional-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7393c8936b9cfb1a28f7e16043c107490491ba4/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Flastprivate-conditional-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7393c8936b9cfb1a28f7e16043c107490491ba4/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Flastprivate-conditional-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Flastprivate-conditional-2.c?ref=e7393c8936b9cfb1a28f7e16043c107490491ba4", "patch": "@@ -8,7 +8,7 @@ foo (int *p)\n   for (i = 0; i < 32; i++)\n     if (p[i])\n       a = i;\n-  #pragma omp simd lastprivate (conditional: b) /* { dg-message \"not supported yet\" } */\n+  #pragma omp simd lastprivate (conditional: b)\n   for (i = 0; i < 32; i++)\n     if (p[i])\n       b = i;"}, {"sha": "b7e951468be4d251ce75f8f2c7e4228f311c6cca", "filename": "gcc/testsuite/gcc.dg/vect/vect-simd-6.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7393c8936b9cfb1a28f7e16043c107490491ba4/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7393c8936b9cfb1a28f7e16043c107490491ba4/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-6.c?ref=e7393c8936b9cfb1a28f7e16043c107490491ba4", "patch": "@@ -0,0 +1,52 @@\n+/* { dg-additional-options \"-fopenmp-simd\" } */\n+/* { dg-final { scan-tree-dump-times \"vectorized \\[12] loops\" 2 \"vect\" { target vect_condition } } } */\n+\n+#include \"tree-vect.h\"\n+\n+int v;\n+\n+__attribute__((noipa)) int\n+foo (int *a)\n+{\n+  int x = 5;\n+  #pragma omp simd lastprivate (conditional: x)\n+  for (int i = 0; i < 128; i++)\n+    if (a[i])\n+      x = a[i];\n+  return x;\n+}\n+\n+__attribute__((noipa)) int\n+bar (int *a, int *b)\n+{\n+  int x = 0;\n+  #pragma omp simd lastprivate (conditional: x, v)\n+  for (int i = 16; i < 128; ++i)\n+    {\n+      if (a[i])\n+\tx = a[i];\n+      if (b[i])\n+\tv = b[i] + 10;\n+    }\n+  return x;\n+}\n+\n+int\n+main ()\n+{\n+  int a[128], b[128], i;\n+  check_vect ();\n+  for (i = 0; i < 128; i++)\n+    {\n+      a[i] = ((i % 11) == 2) ? i + 10 : 0;\n+      asm volatile (\"\" : \"+g\" (i));\n+      b[i] = ((i % 13) == 5) ? i * 2 : 0;\n+    }\n+  if (foo (a) != 133)\n+    abort ();\n+  if (bar (b, a) != 244)\n+    abort ();\n+  if (v != 143)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "15e0c51bec444ef3723c57e63518edfa04e68536", "filename": "gcc/testsuite/gcc.dg/vect/vect-simd-7.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7393c8936b9cfb1a28f7e16043c107490491ba4/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7393c8936b9cfb1a28f7e16043c107490491ba4/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-7.c?ref=e7393c8936b9cfb1a28f7e16043c107490491ba4", "patch": "@@ -0,0 +1,51 @@\n+/* { dg-additional-options \"-fopenmp-simd\" } */\n+\n+#include \"tree-vect.h\"\n+\n+int v;\n+\n+__attribute__((noipa)) int\n+foo (int *a)\n+{\n+  int x = 5;\n+  #pragma omp simd lastprivate (conditional: x) safelen (1)\n+  for (int i = 0; i < 128; i++)\n+    if (a[i])\n+      x = a[i];\n+  return x;\n+}\n+\n+__attribute__((noipa)) int\n+bar (int *a, int *b)\n+{\n+  int x = 0;\n+  #pragma omp simd lastprivate (conditional: x, v) if (0)\n+  for (int i = 16; i < 128; ++i)\n+    {\n+      if (a[i])\n+\tx = a[i];\n+      if (b[i])\n+\tv = b[i] + 10;\n+    }\n+  return x;\n+}\n+\n+int\n+main ()\n+{\n+  int a[128], b[128], i;\n+  check_vect ();\n+  for (i = 0; i < 128; i++)\n+    {\n+      a[i] = ((i % 11) == 2) ? i + 10 : 0;\n+      asm volatile (\"\" : \"+g\" (i));\n+      b[i] = ((i % 13) == 5) ? i * 2 : 0;\n+    }\n+  if (foo (a) != 133)\n+    abort ();\n+  if (bar (b, a) != 244)\n+    abort ();\n+  if (v != 143)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "5b50941aa8371664aeec02dbe3417106ab18115c", "filename": "gcc/tree.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7393c8936b9cfb1a28f7e16043c107490491ba4/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7393c8936b9cfb1a28f7e16043c107490491ba4/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=e7393c8936b9cfb1a28f7e16043c107490491ba4", "patch": "@@ -1752,6 +1752,10 @@ class auto_suppress_location_wrappers\n #define OMP_CLAUSE__GRIDDIM__GROUP(NODE) \\\n   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE__GRIDDIM_), 1)\n \n+/* _CONDTEMP_ holding temporary with iteration count.  */\n+#define OMP_CLAUSE__CONDTEMP__ITER(NODE) \\\n+  (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE__CONDTEMP_)->base.public_flag)\n+\n /* SSA_NAME accessors.  */\n \n /* Whether SSA_NAME NODE is a virtual operand.  This simply caches the"}]}