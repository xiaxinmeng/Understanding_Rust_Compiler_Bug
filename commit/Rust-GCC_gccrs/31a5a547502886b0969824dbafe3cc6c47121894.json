{"sha": "31a5a547502886b0969824dbafe3cc6c47121894", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzFhNWE1NDc1MDI4ODZiMDk2OTgyNGRiYWZlM2NjNmM0NzEyMTg5NA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2011-02-03T13:19:38Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2011-02-03T13:19:38Z"}, "message": "gigi.h (fill_vms_descriptor): Take GNU_TYPE instead of GNAT_FORMAL.\n\n\t* gcc-interface/gigi.h (fill_vms_descriptor): Take GNU_TYPE instead of\n\tGNAT_FORMAL.\n\t* gcc-interface/utils2.c (fill_vms_descriptor): Move from here to...\n\t* gcc-interface/utils.c (fill_vms_descriptor): ...here.  Take GNU_TYPE\n\tinstead of GNAT_FORMAL.  Protect the expression against multiple uses.\n\tDo not generate the check directly, instead instantiate the template\n\tcheck present in the descriptor.\n\t(make_descriptor_field): Move around.\n\t(build_vms_descriptor32): Build a template check in the POINTER field.\n\t(build_vms_descriptor): Remove useless suffixes.\n\t* gcc-interface/trans.c (call_to_gnu): Adjust fill_vms_descriptor call.\n\nFrom-SVN: r169788", "tree": {"sha": "9167b15080830b6d4c3189773eafb6d54b67f535", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9167b15080830b6d4c3189773eafb6d54b67f535"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/31a5a547502886b0969824dbafe3cc6c47121894", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31a5a547502886b0969824dbafe3cc6c47121894", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31a5a547502886b0969824dbafe3cc6c47121894", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31a5a547502886b0969824dbafe3cc6c47121894/comments", "author": null, "committer": null, "parents": [{"sha": "6479ed4b0718c1032a5b4ff926897a63cb935c14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6479ed4b0718c1032a5b4ff926897a63cb935c14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6479ed4b0718c1032a5b4ff926897a63cb935c14"}], "stats": {"total": 279, "additions": 134, "deletions": 145}, "files": [{"sha": "c520f728562237d6659b8a6ba8d521719afba79f", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31a5a547502886b0969824dbafe3cc6c47121894/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31a5a547502886b0969824dbafe3cc6c47121894/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=31a5a547502886b0969824dbafe3cc6c47121894", "patch": "@@ -1,3 +1,17 @@\n+2011-02-03  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/gigi.h (fill_vms_descriptor): Take GNU_TYPE instead of\n+\tGNAT_FORMAL.\n+\t* gcc-interface/utils2.c (fill_vms_descriptor): Move from here to...\n+\t* gcc-interface/utils.c (fill_vms_descriptor): ...here.  Take GNU_TYPE\n+\tinstead of GNAT_FORMAL.  Protect the expression against multiple uses.\n+\tDo not generate the check directly, instead instantiate the template\n+\tcheck present in the descriptor.\n+\t(make_descriptor_field): Move around.\n+\t(build_vms_descriptor32): Build a template check in the POINTER field.\n+\t(build_vms_descriptor): Remove useless suffixes.\n+\t* gcc-interface/trans.c (call_to_gnu): Adjust fill_vms_descriptor call.\n+\n 2011-01-26  Eric Botcazou  <ebotcazou@adacore.com>\n \n \tPR bootstrap/47467"}, {"sha": "e45cf13833717188da95ce28aa3c60a1992350c9", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31a5a547502886b0969824dbafe3cc6c47121894/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31a5a547502886b0969824dbafe3cc6c47121894/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=31a5a547502886b0969824dbafe3cc6c47121894", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                              C Header File                               *\n  *                                                                          *\n- *          Copyright (C) 1992-2010, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2011, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -861,10 +861,9 @@ extern tree build_allocator (tree type, tree init, tree result_type,\n                              Entity_Id gnat_proc, Entity_Id gnat_pool,\n                              Node_Id gnat_node, bool);\n \n-/* Fill in a VMS descriptor for EXPR and return a constructor for it.\n-   GNAT_FORMAL is how we find the descriptor record. GNAT_ACTUAL is how\n-   we derive the source location on a C_E */\n-extern tree fill_vms_descriptor (tree expr, Entity_Id gnat_formal,\n+/* Fill in a VMS descriptor of GNU_TYPE for GNU_EXPR and return the result.\n+   GNAT_ACTUAL is the actual parameter for which the descriptor is built.  */\n+extern tree fill_vms_descriptor (tree gnu_type, tree gnu_expr,\n                                  Node_Id gnat_actual);\n \n /* Indicate that we need to take the address of T and that it therefore"}, {"sha": "e438960ee3be642d345c53e3e8a126eec0f87b7a", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31a5a547502886b0969824dbafe3cc6c47121894/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31a5a547502886b0969824dbafe3cc6c47121894/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=31a5a547502886b0969824dbafe3cc6c47121894", "patch": "@@ -3071,9 +3071,9 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t      = convert (DECL_ARG_TYPE (gnu_formal), integer_zero_node);\n \t  else\n \t    gnu_actual = build_unary_op (ADDR_EXPR, NULL_TREE,\n-\t\t\t\t\t fill_vms_descriptor (gnu_actual,\n-\t\t\t\t\t\t\t      gnat_formal,\n-\t\t\t\t\t\t\t      gnat_actual));\n+\t\t\t\t\t fill_vms_descriptor\n+\t\t\t\t\t (TREE_TYPE (TREE_TYPE (gnu_formal)),\n+\t\t\t\t\t  gnu_actual, gnat_actual));\n \t}\n       else\n \t{"}, {"sha": "eac87e0bbc97600d6e557ee91c0751fec46f4716", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 112, "deletions": 84, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31a5a547502886b0969824dbafe3cc6c47121894/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31a5a547502886b0969824dbafe3cc6c47121894/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=31a5a547502886b0969824dbafe3cc6c47121894", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *          Copyright (C) 1992-2010, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2011, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -203,7 +203,6 @@ static tree split_plus (tree, tree *);\n static tree float_type_for_precision (int, enum machine_mode);\n static tree convert_to_fat_pointer (tree, tree);\n static tree convert_to_thin_pointer (tree, tree);\n-static tree make_descriptor_field (const char *,tree, tree, tree, tree);\n static bool potential_alignment_gap (tree, tree, tree);\n static void process_attributes (tree, struct attrib *);\n \f\n@@ -2280,6 +2279,22 @@ build_template (tree template_type, tree array_type, tree expr)\n   return gnat_build_constructor (template_type, template_elts);\n }\n \f\n+/* Helper routine to make a descriptor field.  FIELD_LIST is the list of decls\n+   being built; the new decl is chained on to the front of the list.  */\n+\n+static tree\n+make_descriptor_field (const char *name, tree type, tree rec_type,\n+\t\t       tree initial, tree field_list)\n+{\n+  tree field\n+    = create_field_decl (get_identifier (name), type, rec_type, NULL_TREE,\n+\t\t\t NULL_TREE, 0, 0);\n+\n+  DECL_INITIAL (field) = initial;\n+  DECL_CHAIN (field) = field_list;\n+  return field;\n+}\n+\n /* Build a 32-bit VMS descriptor from a Mechanism_Type, which must specify a\n    descriptor type, and the GCC type of an object.  Each FIELD_DECL in the\n    type contains in its DECL_INITIAL the expression to use when a constructor\n@@ -2291,15 +2306,11 @@ tree\n build_vms_descriptor32 (tree type, Mechanism_Type mech, Entity_Id gnat_entity)\n {\n   tree record_type = make_node (RECORD_TYPE);\n-  tree pointer32_type;\n+  tree pointer32_type, pointer64_type;\n   tree field_list = NULL_TREE;\n-  int klass;\n-  int dtype = 0;\n-  tree inner_type;\n-  int ndim;\n-  int i;\n+  int klass, ndim, i, dtype = 0;\n+  tree inner_type, tem;\n   tree *idx_arr;\n-  tree tem;\n \n   /* If TYPE is an unconstrained array, use the underlying array type.  */\n   if (TREE_CODE (type) == UNCONSTRAINED_ARRAY_TYPE)\n@@ -2439,15 +2450,22 @@ build_vms_descriptor32 (tree type, Mechanism_Type mech, Entity_Id gnat_entity)\n     = make_descriptor_field (\"CLASS\", gnat_type_for_size (8, 1), record_type,\n \t\t\t     size_int (klass), field_list);\n \n-  /* Of course this will crash at run time if the address space is not\n-     within the low 32 bits, but there is nothing else we can do.  */\n   pointer32_type = build_pointer_type_for_mode (type, SImode, false);\n+  pointer64_type = build_pointer_type_for_mode (type, DImode, false);\n+\n+  /* Ensure that only 32-bit pointers are passed in 32-bit descriptors.  Note\n+     that we cannot build a template call to the CE routine as it would get a\n+     wrong source location; instead we use a second placeholder for it.  */\n+  tem = build_unary_op (ADDR_EXPR, pointer64_type,\n+\t\t\tbuild0 (PLACEHOLDER_EXPR, type));\n+  tem = build3 (COND_EXPR, pointer32_type,\n+\t\tbuild_binary_op (GE_EXPR, boolean_type_node, tem,\n+\t\t\t\t build_int_cstu (pointer64_type, 0x80000000)),\n+\t\tbuild0 (PLACEHOLDER_EXPR, void_type_node),\n+\t\tconvert (pointer32_type, tem));\n \n   field_list\n-    = make_descriptor_field (\"POINTER\", pointer32_type, record_type,\n-\t\t\t     build_unary_op (ADDR_EXPR,\n-\t\t\t\t\t     pointer32_type,\n-\t\t\t\t\t     build0 (PLACEHOLDER_EXPR, type)),\n+    = make_descriptor_field (\"POINTER\", pointer32_type, record_type, tem,\n \t\t\t     field_list);\n \n   switch (mech)\n@@ -2488,7 +2506,6 @@ build_vms_descriptor32 (tree type, Mechanism_Type mech, Entity_Id gnat_entity)\n \t= make_descriptor_field (\"DIGITS\", gnat_type_for_size (8, 1),\n \t\t\t\t record_type, size_zero_node, field_list);\n \n-\n       field_list\n \t= make_descriptor_field (\"AFLAGS\", gnat_type_for_size (8, 1),\n \t\t\t\t record_type,\n@@ -2587,16 +2604,12 @@ build_vms_descriptor32 (tree type, Mechanism_Type mech, Entity_Id gnat_entity)\n tree\n build_vms_descriptor (tree type, Mechanism_Type mech, Entity_Id gnat_entity)\n {\n-  tree record64_type = make_node (RECORD_TYPE);\n+  tree record_type = make_node (RECORD_TYPE);\n   tree pointer64_type;\n-  tree field_list64 = NULL_TREE;\n-  int klass;\n-  int dtype = 0;\n-  tree inner_type;\n-  int ndim;\n-  int i;\n+  tree field_list = NULL_TREE;\n+  int klass, ndim, i, dtype = 0;\n+  tree inner_type, tem;\n   tree *idx_arr;\n-  tree tem;\n \n   /* If TYPE is an unconstrained array, use the underlying array type.  */\n   if (TREE_CODE (type) == UNCONSTRAINED_ARRAY_TYPE)\n@@ -2718,32 +2731,32 @@ build_vms_descriptor (tree type, Mechanism_Type mech, Entity_Id gnat_entity)\n \n   /* Make the type for a 64-bit descriptor for VMS.  The first six fields\n      are the same for all types.  */\n-  field_list64\n+  field_list\n     = make_descriptor_field (\"MBO\", gnat_type_for_size (16, 1),\n-\t\t\t     record64_type, size_int (1), field_list64);\n-  field_list64\n+\t\t\t     record_type, size_int (1), field_list);\n+  field_list\n     = make_descriptor_field (\"DTYPE\", gnat_type_for_size (8, 1),\n-\t\t\t     record64_type, size_int (dtype), field_list64);\n-  field_list64\n+\t\t\t     record_type, size_int (dtype), field_list);\n+  field_list\n     = make_descriptor_field (\"CLASS\", gnat_type_for_size (8, 1),\n-\t\t\t     record64_type, size_int (klass), field_list64);\n-  field_list64\n+\t\t\t     record_type, size_int (klass), field_list);\n+  field_list\n     = make_descriptor_field (\"MBMO\", gnat_type_for_size (32, 1),\n-\t\t\t     record64_type, ssize_int (-1), field_list64);\n-  field_list64\n+\t\t\t     record_type, ssize_int (-1), field_list);\n+  field_list\n     = make_descriptor_field (\"LENGTH\", gnat_type_for_size (64, 1),\n-\t\t\t     record64_type,\n+\t\t\t     record_type,\n \t\t\t     size_in_bytes (mech == By_Descriptor_A\n \t\t\t\t\t    ? inner_type : type),\n-\t\t\t     field_list64);\n+\t\t\t     field_list);\n \n   pointer64_type = build_pointer_type_for_mode (type, DImode, false);\n \n-  field_list64\n-    = make_descriptor_field (\"POINTER\", pointer64_type, record64_type,\n+  field_list\n+    = make_descriptor_field (\"POINTER\", pointer64_type, record_type,\n \t\t\t     build_unary_op (ADDR_EXPR, pointer64_type,\n \t\t\t\t\t     build0 (PLACEHOLDER_EXPR, type)),\n-\t\t\t     field_list64);\n+\t\t\t     field_list);\n \n   switch (mech)\n     {\n@@ -2752,31 +2765,31 @@ build_vms_descriptor (tree type, Mechanism_Type mech, Entity_Id gnat_entity)\n       break;\n \n     case By_Descriptor_SB:\n-      field_list64\n+      field_list\n \t= make_descriptor_field (\"SB_L1\", gnat_type_for_size (64, 1),\n-\t\t\t\t record64_type,\n+\t\t\t\t record_type,\n \t\t\t\t (TREE_CODE (type) == ARRAY_TYPE\n \t\t\t\t  ? TYPE_MIN_VALUE (TYPE_DOMAIN (type))\n \t\t\t\t  : size_zero_node),\n-\t\t\t\t field_list64);\n-      field_list64\n+\t\t\t\t field_list);\n+      field_list\n \t= make_descriptor_field (\"SB_U1\", gnat_type_for_size (64, 1),\n-\t\t\t\t record64_type,\n+\t\t\t\t record_type,\n \t\t\t\t (TREE_CODE (type) == ARRAY_TYPE\n \t\t\t\t  ? TYPE_MAX_VALUE (TYPE_DOMAIN (type))\n \t\t\t\t  : size_zero_node),\n-\t\t\t\t field_list64);\n+\t\t\t\t field_list);\n       break;\n \n     case By_Descriptor_A:\n     case By_Descriptor_NCA:\n-      field_list64\n+      field_list\n \t= make_descriptor_field (\"SCALE\", gnat_type_for_size (8, 1),\n-\t\t\t\t record64_type, size_zero_node, field_list64);\n+\t\t\t\t record_type, size_zero_node, field_list);\n \n-      field_list64\n+      field_list\n \t= make_descriptor_field (\"DIGITS\", gnat_type_for_size (8, 1),\n-\t\t\t\t record64_type, size_zero_node, field_list64);\n+\t\t\t\t record_type, size_zero_node, field_list);\n \n       dtype = (mech == By_Descriptor_NCA\n \t       ? 0\n@@ -2785,22 +2798,22 @@ build_vms_descriptor (tree type, Mechanism_Type mech, Entity_Id gnat_entity)\n \t       : (TREE_CODE (type) == ARRAY_TYPE\n \t\t  && TYPE_CONVENTION_FORTRAN_P (type)\n \t\t  ? 224 : 192));\n-      field_list64\n+      field_list\n \t= make_descriptor_field (\"AFLAGS\", gnat_type_for_size (8, 1),\n-\t\t\t\t record64_type, size_int (dtype),\n-\t\t\t\t field_list64);\n+\t\t\t\t record_type, size_int (dtype),\n+\t\t\t\t field_list);\n \n-      field_list64\n+      field_list\n \t= make_descriptor_field (\"DIMCT\", gnat_type_for_size (8, 1),\n-\t\t\t\t record64_type, size_int (ndim), field_list64);\n+\t\t\t\t record_type, size_int (ndim), field_list);\n \n-      field_list64\n+      field_list\n \t= make_descriptor_field (\"MBZ\", gnat_type_for_size (32, 1),\n-\t\t\t\t record64_type, size_int (0), field_list64);\n-      field_list64\n+\t\t\t\t record_type, size_int (0), field_list);\n+      field_list\n \t= make_descriptor_field (\"ARSIZE\", gnat_type_for_size (64, 1),\n-\t\t\t\t record64_type, size_in_bytes (type),\n-\t\t\t\t field_list64);\n+\t\t\t\t record_type, size_in_bytes (type),\n+\t\t\t\t field_list);\n \n       /* Now build a pointer to the 0,0,0... element.  */\n       tem = build0 (PLACEHOLDER_EXPR, type);\n@@ -2810,10 +2823,10 @@ build_vms_descriptor (tree type, Mechanism_Type mech, Entity_Id gnat_entity)\n \t\t      convert (TYPE_DOMAIN (inner_type), size_zero_node),\n \t\t      NULL_TREE, NULL_TREE);\n \n-      field_list64\n-\t= make_descriptor_field (\"A0\", pointer64_type, record64_type,\n+      field_list\n+\t= make_descriptor_field (\"A0\", pointer64_type, record_type,\n \t\t\t\t build1 (ADDR_EXPR, pointer64_type, tem),\n-\t\t\t\t field_list64);\n+\t\t\t\t field_list);\n \n       /* Next come the addressing coefficients.  */\n       tem = size_one_node;\n@@ -2830,9 +2843,9 @@ build_vms_descriptor (tree type, Mechanism_Type mech, Entity_Id gnat_entity)\n \n \t  fname[0] = (mech == By_Descriptor_NCA ? 'S' : 'M');\n \t  fname[1] = '0' + i, fname[2] = 0;\n-\t  field_list64\n+\t  field_list\n \t    = make_descriptor_field (fname, gnat_type_for_size (64, 1),\n-\t\t\t\t     record64_type, idx_length, field_list64);\n+\t\t\t\t     record_type, idx_length, field_list);\n \n \t  if (mech == By_Descriptor_NCA)\n \t    tem = idx_length;\n@@ -2844,43 +2857,58 @@ build_vms_descriptor (tree type, Mechanism_Type mech, Entity_Id gnat_entity)\n \t  char fname[3];\n \n \t  fname[0] = 'L', fname[1] = '0' + i, fname[2] = 0;\n-\t  field_list64\n+\t  field_list\n \t    = make_descriptor_field (fname, gnat_type_for_size (64, 1),\n-\t\t\t\t     record64_type,\n-\t\t\t\t     TYPE_MIN_VALUE (idx_arr[i]), field_list64);\n+\t\t\t\t     record_type,\n+\t\t\t\t     TYPE_MIN_VALUE (idx_arr[i]), field_list);\n \n \t  fname[0] = 'U';\n-\t  field_list64\n+\t  field_list\n \t    = make_descriptor_field (fname, gnat_type_for_size (64, 1),\n-\t\t\t\t     record64_type,\n-\t\t\t\t     TYPE_MAX_VALUE (idx_arr[i]), field_list64);\n+\t\t\t\t     record_type,\n+\t\t\t\t     TYPE_MAX_VALUE (idx_arr[i]), field_list);\n \t}\n       break;\n \n     default:\n       post_error (\"unsupported descriptor type for &\", gnat_entity);\n     }\n \n-  TYPE_NAME (record64_type) = create_concat_name (gnat_entity, \"DESC64\");\n-  finish_record_type (record64_type, nreverse (field_list64), 0, false);\n-  return record64_type;\n+  TYPE_NAME (record_type) = create_concat_name (gnat_entity, \"DESC64\");\n+  finish_record_type (record_type, nreverse (field_list), 0, false);\n+  return record_type;\n }\n \n-/* Utility routine for above code to make a field.  FIELD_LIST is the\n-   list of decls being built; the new decl is chained on to the front of\n-   the list.  */\n+/* Fill in a VMS descriptor of GNU_TYPE for GNU_EXPR and return the result.\n+   GNAT_ACTUAL is the actual parameter for which the descriptor is built.  */\n \n-static tree\n-make_descriptor_field (const char *name, tree type,\n-\t\t       tree rec_type, tree initial, tree field_list)\n+tree\n+fill_vms_descriptor (tree gnu_type, tree gnu_expr, Node_Id gnat_actual)\n {\n-  tree field\n-    = create_field_decl (get_identifier (name), type, rec_type, NULL_TREE,\n-\t\t\t NULL_TREE, 0, 0);\n+  VEC(constructor_elt,gc) *v = NULL;\n+  tree field;\n \n-  DECL_INITIAL (field) = initial;\n-  DECL_CHAIN (field) = field_list;\n-  return field;\n+  gnu_expr = maybe_unconstrained_array (gnu_expr);\n+  gnu_expr = gnat_protect_expr (gnu_expr);\n+  gnat_mark_addressable (gnu_expr);\n+\n+  /* We may need to substitute both GNU_EXPR and a CALL_EXPR to the raise CE\n+     routine in case we have a 32-bit descriptor.  */\n+  gnu_expr = build2 (COMPOUND_EXPR, void_type_node,\n+\t\t     build_call_raise (CE_Range_Check_Failed, gnat_actual,\n+\t\t\t\t       N_Raise_Constraint_Error),\n+\t\t     gnu_expr);\n+\n+  for (field = TYPE_FIELDS (gnu_type); field; field = DECL_CHAIN (field))\n+    {\n+      tree value\n+\t= convert (TREE_TYPE (field),\n+\t\t   SUBSTITUTE_PLACEHOLDER_IN_EXPR (DECL_INITIAL (field),\n+\t\t\t\t\t\t   gnu_expr));\n+      CONSTRUCTOR_APPEND_ELT (v, field, value);\n+    }\n+\n+  return gnat_build_constructor (gnu_type, v);\n }\n \n /* Convert GNU_EXPR, a pointer to a 64bit VMS descriptor, to GNU_TYPE, a"}, {"sha": "07d6b5bd0bfb4fe9a4340ec98a569b31a9e80f8c", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 1, "deletions": 53, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31a5a547502886b0969824dbafe3cc6c47121894/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31a5a547502886b0969824dbafe3cc6c47121894/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=31a5a547502886b0969824dbafe3cc6c47121894", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *          Copyright (C) 1992-2010, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2011, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -2216,58 +2216,6 @@ build_allocator (tree type, tree init, tree result_type, Entity_Id gnat_proc,\n   return convert (result_type, result);\n }\n \f\n-/* Fill in a VMS descriptor for EXPR and return a constructor for it.\n-   GNAT_FORMAL is how we find the descriptor record.  GNAT_ACTUAL is\n-   how we derive the source location to raise C_E on an out of range\n-   pointer. */\n-\n-tree\n-fill_vms_descriptor (tree expr, Entity_Id gnat_formal, Node_Id gnat_actual)\n-{\n-  tree parm_decl = get_gnu_tree (gnat_formal);\n-  tree record_type = TREE_TYPE (TREE_TYPE (parm_decl));\n-  tree field;\n-  const bool do_range_check\n-    = strcmp (\"MBO\",\n-\t      IDENTIFIER_POINTER (DECL_NAME (TYPE_FIELDS (record_type))));\n-  VEC(constructor_elt,gc) *v = NULL;\n-\n-  expr = maybe_unconstrained_array (expr);\n-  gnat_mark_addressable (expr);\n-\n-  for (field = TYPE_FIELDS (record_type); field; field = DECL_CHAIN (field))\n-    {\n-      tree conexpr = convert (TREE_TYPE (field),\n-\t\t\t      SUBSTITUTE_PLACEHOLDER_IN_EXPR\n-\t\t\t      (DECL_INITIAL (field), expr));\n-\n-      /* Check to ensure that only 32-bit pointers are passed in\n-\t 32-bit descriptors */\n-      if (do_range_check\n-          && strcmp (IDENTIFIER_POINTER (DECL_NAME (field)), \"POINTER\") == 0)\n-        {\n-\t  tree pointer64type\n-\t    = build_pointer_type_for_mode (void_type_node, DImode, false);\n-\t  tree addr64expr = build_unary_op (ADDR_EXPR, pointer64type, expr);\n-\t  tree malloc64low\n-\t    = build_int_cstu (long_integer_type_node, 0x80000000);\n-\n-\t  add_stmt (build3 (COND_EXPR, void_type_node,\n-\t\t\t    build_binary_op (GE_EXPR, boolean_type_node,\n-\t\t\t\t\t     convert (long_integer_type_node,\n-\t\t\t\t\t\t      addr64expr),\n-\t\t\t\t\t     malloc64low),\n-\t\t\t    build_call_raise (CE_Range_Check_Failed,\n-\t\t\t\t\t      gnat_actual,\n-\t\t\t\t\t      N_Raise_Constraint_Error),\n-\t\t\t    NULL_TREE));\n-        }\n-      CONSTRUCTOR_APPEND_ELT (v, field, conexpr);\n-    }\n-\n-  return gnat_build_constructor (record_type, v);\n-}\n-\n /* Indicate that we need to take the address of T and that it therefore\n    should not be allocated in a register.  Returns true if successful.  */\n "}]}