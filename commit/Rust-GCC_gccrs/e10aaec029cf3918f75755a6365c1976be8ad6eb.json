{"sha": "e10aaec029cf3918f75755a6365c1976be8ad6eb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTEwYWFlYzAyOWNmMzkxOGY3NTc1NWE2MzY1YzE5NzZiZThhZDZlYg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-07-06T18:54:38Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-07-06T18:54:38Z"}, "message": "lto-symtab.c (lto_cgraph_replace_node): Handle aliases.\n\n\n\t* lto-symtab.c (lto_cgraph_replace_node): Handle aliases.\n\t(lto_symtab_resolve_can_prevail_p): Also alias of cgraph node\n\twith body can prevail.\n\t(lto_symtab_resolve_symbols): Use cgraph_get_node_or_alias.\n\t(lto_symtab_merge_cgraph_nodes_1): Do not remove nodes from aliases.\n\t* cgraph.c (cgraph_get_node_or_alias): New function.\n\t* cgraph.h (cgraph_get_node_or_alias): Declare.\n\nFrom-SVN: r161877", "tree": {"sha": "da7ceb57fd3446fb3bfc8509e1cdccdfa6ff9e48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/da7ceb57fd3446fb3bfc8509e1cdccdfa6ff9e48"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e10aaec029cf3918f75755a6365c1976be8ad6eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e10aaec029cf3918f75755a6365c1976be8ad6eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e10aaec029cf3918f75755a6365c1976be8ad6eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e10aaec029cf3918f75755a6365c1976be8ad6eb/comments", "author": null, "committer": null, "parents": [{"sha": "4bbf141cf116e3c59cba66e9c51fb33bc90793f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bbf141cf116e3c59cba66e9c51fb33bc90793f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4bbf141cf116e3c59cba66e9c51fb33bc90793f1"}], "stats": {"total": 114, "additions": 81, "deletions": 33}, "files": [{"sha": "65b78836cff4c349efb4a097847616791ddc9cc4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e10aaec029cf3918f75755a6365c1976be8ad6eb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e10aaec029cf3918f75755a6365c1976be8ad6eb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e10aaec029cf3918f75755a6365c1976be8ad6eb", "patch": "@@ -1,3 +1,13 @@\n+2010-07-06  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto-symtab.c (lto_cgraph_replace_node): Handle aliases.\n+\t(lto_symtab_resolve_can_prevail_p): Also alias of cgraph node\n+\twith body can prevail.\n+\t(lto_symtab_resolve_symbols): Use cgraph_get_node_or_alias.\n+\t(lto_symtab_merge_cgraph_nodes_1): Do not remove nodes from aliases.\n+\t* cgraph.c (cgraph_get_node_or_alias): New function.\n+\t* cgraph.h (cgraph_get_node_or_alias): Declare.\n+\n 2010-07-06  Kai Tietz  <kai.tietz@onevision.com>\n \n \t* config/i386/i386.c (ix86_function_ms_hook_prologue): Enable x64"}, {"sha": "37367695606c9facb52725caea4aff46a2118b2c", "filename": "gcc/cgraph.c", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e10aaec029cf3918f75755a6365c1976be8ad6eb/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e10aaec029cf3918f75755a6365c1976be8ad6eb/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=e10aaec029cf3918f75755a6365c1976be8ad6eb", "patch": "@@ -600,6 +600,29 @@ cgraph_add_thunk (tree alias, tree decl, bool this_adjusting,\n   node->thunk.thunk_p = true;\n }\n \n+/* Returns the cgraph node assigned to DECL or NULL if no cgraph node\n+   is assigned.  */\n+\n+struct cgraph_node *\n+cgraph_get_node_or_alias (tree decl)\n+{\n+  struct cgraph_node key, *node = NULL, **slot;\n+\n+  gcc_assert (TREE_CODE (decl) == FUNCTION_DECL);\n+\n+  if (!cgraph_hash)\n+    return NULL;\n+\n+  key.decl = decl;\n+\n+  slot = (struct cgraph_node **) htab_find_slot (cgraph_hash, &key,\n+\t\t\t\t\t\t NO_INSERT);\n+\n+  if (slot && *slot)\n+    node = *slot;\n+  return node;\n+}\n+\n /* Returns the cgraph node assigned to DECL or NULL if no cgraph node\n    is assigned.  */\n "}, {"sha": "9985745d1df383c4974ece04eff188f9cfea9538", "filename": "gcc/lto-symtab.c", "status": "modified", "additions": 48, "deletions": 33, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e10aaec029cf3918f75755a6365c1976be8ad6eb/gcc%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e10aaec029cf3918f75755a6365c1976be8ad6eb/gcc%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-symtab.c?ref=e10aaec029cf3918f75755a6365c1976be8ad6eb", "patch": "@@ -206,6 +206,24 @@ lto_cgraph_replace_node (struct cgraph_node *node,\n \t\t\t struct cgraph_node *prevailing_node)\n {\n   struct cgraph_edge *e, *next;\n+  bool no_aliases_please = false;\n+\n+  if (cgraph_dump_file)\n+    {\n+      fprintf (cgraph_dump_file, \"Replacing cgraph node %s/%i by %s/%i\"\n+ \t       \" for symbol %s\\n\",\n+\t       cgraph_node_name (node), node->uid,\n+\t       cgraph_node_name (prevailing_node),\n+\t       prevailing_node->uid,\n+\t       IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (node->decl)));\n+    }\n+\n+  if (prevailing_node->same_body_alias)\n+    {\n+      if (prevailing_node->thunk.thunk_p)\n+\tno_aliases_please = true;\n+      prevailing_node = prevailing_node->same_body;\n+    }\n \n   /* Merge node flags.  */\n   if (node->needed)\n@@ -227,27 +245,37 @@ lto_cgraph_replace_node (struct cgraph_node *node,\n   /* Redirect incomming references.  */\n   ipa_clone_refering (prevailing_node, NULL, &node->ref_list);\n \n-  if (node->same_body)\n+  /* If we have aliases, redirect them to the prevailing node.  */\n+  if (!node->same_body_alias && node->same_body)\n     {\n-      struct cgraph_node *alias;\n+      struct cgraph_node *alias, *last;\n+      /* We prevail aliases/tunks by a thunk.  This is doable but\n+         would need thunk combination.  Hopefully no ABI changes will\n+         every be crazy enough.  */\n+      gcc_assert (!no_aliases_please);\n \n       for (alias = node->same_body; alias; alias = alias->next)\n-\tif (DECL_ASSEMBLER_NAME_SET_P (alias->decl))\n-\t  {\n-\t    lto_symtab_entry_t se\n-\t      = lto_symtab_get (DECL_ASSEMBLER_NAME (alias->decl));\n-\n-\t    for (; se; se = se->next)\n-\t      if (se->node == node)\n-\t\t{\n-\t\t  se->node = NULL;\n-\t\t  break;\n-\t\t}\n-\t  }\n+\t{\n+\t  last = alias;\n+\t  gcc_assert (alias->same_body_alias);\n+\t  alias->same_body = prevailing_node;\n+\t  alias->thunk.alias = prevailing_node->decl;\n+\t}\n+      last->next = prevailing_node->same_body;\n+      /* Node with aliases is prevailed by alias.\n+\t We could handle this, but combining thunks together will be tricky.\n+\t Hopefully this does not happen.  */\n+      if (prevailing_node->same_body)\n+\tprevailing_node->same_body->previous = last;\n+      prevailing_node->same_body = node->same_body;\n+      node->same_body = NULL;\n     }\n \n   /* Finally remove the replaced node.  */\n-  cgraph_remove_node (node);\n+  if (node->same_body_alias)\n+    cgraph_remove_same_body_alias (node);\n+  else\n+    cgraph_remove_node (node);\n }\n \n /* Replace the cgraph node NODE with PREVAILING_NODE in the cgraph, merging\n@@ -433,7 +461,9 @@ lto_symtab_resolve_can_prevail_p (lto_symtab_entry_t e)\n \n   /* For functions we need a non-discarded body.  */\n   if (TREE_CODE (e->decl) == FUNCTION_DECL)\n-    return (e->node && e->node->analyzed);\n+    return (e->node\n+\t    && (e->node->analyzed\n+\t        || (e->node->same_body_alias && e->node->same_body->analyzed)));\n \n   /* A variable should have a size.  */\n   else if (TREE_CODE (e->decl) == VAR_DECL)\n@@ -461,7 +491,7 @@ lto_symtab_resolve_symbols (void **slot)\n   for (e = (lto_symtab_entry_t) *slot; e; e = e->next)\n     {\n       if (TREE_CODE (e->decl) == FUNCTION_DECL)\n-\te->node = cgraph_get_node (e->decl);\n+\te->node = cgraph_get_node_or_alias (e->decl);\n       else if (TREE_CODE (e->decl) == VAR_DECL)\n \t{\n \t  e->vnode = varpool_get_node (e->decl);\n@@ -751,22 +781,7 @@ lto_symtab_merge_cgraph_nodes_1 (void **slot, void *data ATTRIBUTE_UNUSED)\n   for (e = prevailing->next; e; e = e->next)\n     {\n       if (e->node != NULL)\n-\t{\n-\t  if (e->node->decl != e->decl && e->node->same_body)\n-\t    {\n-\t      struct cgraph_node *alias;\n-\n-\t      for (alias = e->node->same_body; alias; alias = alias->next)\n-\t\tif (alias->decl == e->decl)\n-\t\t  break;\n-\t      if (alias)\n-\t\t{\n-\t\t  cgraph_remove_same_body_alias (alias);\n-\t\t  continue;\n-\t\t}\n-\t    }\n-\t  lto_cgraph_replace_node (e->node, prevailing->node);\n-\t}\n+\tlto_cgraph_replace_node (e->node, prevailing->node);\n       if (e->vnode != NULL)\n \tlto_varpool_replace_node (e->vnode, prevailing->vnode);\n     }"}]}