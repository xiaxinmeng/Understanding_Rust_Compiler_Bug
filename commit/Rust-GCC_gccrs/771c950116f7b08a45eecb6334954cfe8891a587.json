{"sha": "771c950116f7b08a45eecb6334954cfe8891a587", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzcxYzk1MDExNmY3YjA4YTQ1ZWVjYjYzMzQ5NTRjZmU4ODkxYTU4Nw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2014-04-28T14:07:51Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2014-04-28T14:07:51Z"}, "message": "tree-vrp.c (vrp_var_may_overflow): Remove.\n\n2014-04-28  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vrp.c (vrp_var_may_overflow): Remove.\n\t(vrp_visit_phi_node): Rather than bumping to +-INF possibly\n\twith overflow immediately bump to one before that value and\n\tlet iteration figure out overflow status.\n\n\t* gcc.dg/tree-ssa/vrp91.c: New testcase.\n\t* gcc.dg/Wstrict-overflow-14.c: XFAIL.\n\t* gcc.dg/Wstrict-overflow-15.c: Likewise.\n\t* gcc.dg/Wstrict-overflow-18.c: Remove XFAIL.\n\nFrom-SVN: r209862", "tree": {"sha": "f0c265427988aef0111991241732b3a1d9dea238", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f0c265427988aef0111991241732b3a1d9dea238"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/771c950116f7b08a45eecb6334954cfe8891a587", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/771c950116f7b08a45eecb6334954cfe8891a587", "html_url": "https://github.com/Rust-GCC/gccrs/commit/771c950116f7b08a45eecb6334954cfe8891a587", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/771c950116f7b08a45eecb6334954cfe8891a587/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "279a935ff4bc1df86e090f8e28f15d70384514eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/279a935ff4bc1df86e090f8e28f15d70384514eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/279a935ff4bc1df86e090f8e28f15d70384514eb"}], "stats": {"total": 140, "additions": 65, "deletions": 75}, "files": [{"sha": "67a4645a87a9c887632c09458879fb9ca1613569", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/771c950116f7b08a45eecb6334954cfe8891a587/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/771c950116f7b08a45eecb6334954cfe8891a587/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=771c950116f7b08a45eecb6334954cfe8891a587", "patch": "@@ -1,3 +1,10 @@\n+2014-04-28  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vrp.c (vrp_var_may_overflow): Remove.\n+\t(vrp_visit_phi_node): Rather than bumping to +-INF possibly\n+\twith overflow immediately bump to one before that value and\n+\tlet iteration figure out overflow status.\n+\n 2014-04-28  Richard Biener  <rguenther@suse.de>\n \n \t* configure.ac: Do valgrind header checks unconditionally."}, {"sha": "261bb98a3a497296b0801d4641e56c7de800f0c1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/771c950116f7b08a45eecb6334954cfe8891a587/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/771c950116f7b08a45eecb6334954cfe8891a587/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=771c950116f7b08a45eecb6334954cfe8891a587", "patch": "@@ -1,3 +1,10 @@\n+2014-04-28  Richard Biener  <rguenther@suse.de>\n+\n+\t* gcc.dg/tree-ssa/vrp91.c: New testcase.\n+\t* gcc.dg/Wstrict-overflow-14.c: XFAIL.\n+\t* gcc.dg/Wstrict-overflow-15.c: Likewise.\n+\t* gcc.dg/Wstrict-overflow-18.c: Remove XFAIL.\n+\n 2014-04-28  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/60979"}, {"sha": "dda07ea733b65dc2cea85d159aefd139771a7ccf", "filename": "gcc/testsuite/gcc.dg/Wstrict-overflow-14.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/771c950116f7b08a45eecb6334954cfe8891a587/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/771c950116f7b08a45eecb6334954cfe8891a587/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-14.c?ref=771c950116f7b08a45eecb6334954cfe8891a587", "patch": "@@ -10,6 +10,6 @@ foo (int j)\n   int sum = 0;\n \n   for (i = 1; i < j; i += i)\n-    sum += i / 16; /* { dg-warning \"assuming signed overflow does not occur\" \"\" } */\n+    sum += i / 16; /* { dg-warning \"assuming signed overflow does not occur\" \"\"  { xfail *-*-* } } */\n   return sum;\n }"}, {"sha": "c9e275c0bd614dc6e95c0fb71e9ce6f13ee40b16", "filename": "gcc/testsuite/gcc.dg/Wstrict-overflow-15.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/771c950116f7b08a45eecb6334954cfe8891a587/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/771c950116f7b08a45eecb6334954cfe8891a587/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-15.c?ref=771c950116f7b08a45eecb6334954cfe8891a587", "patch": "@@ -10,6 +10,6 @@ foo (int j)\n   int sum = 0;\n \n   for (i = 1; i < j; i += i)\n-    sum += __builtin_abs (i); /* { dg-warning \"assuming signed overflow does not occur\" \"\" } */\n+    sum += __builtin_abs (i); /* { dg-warning \"assuming signed overflow does not occur\" \"\" { xfail *-*-* } } */\n   return sum;\n }"}, {"sha": "7bf111a50ea01616742b482435877726e0cdaeaa", "filename": "gcc/testsuite/gcc.dg/Wstrict-overflow-18.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/771c950116f7b08a45eecb6334954cfe8891a587/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/771c950116f7b08a45eecb6334954cfe8891a587/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-18.c?ref=771c950116f7b08a45eecb6334954cfe8891a587", "patch": "@@ -17,7 +17,7 @@ foo (struct c *p)\n \n   for (i = 0; i < p->a - p->b; ++i)\n     {\n-      if (i > 0)  /* { dg-bogus \"warning\" \"\" { xfail *-*-* } } */\n+      if (i > 0)  /* { dg-bogus \"warning\" \"\" } */\n \tsum += 2;\n       bar (p);\n     }"}, {"sha": "68d8fd33a0b5b1fda5d41e844bf03fd187cc3d5c", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp91.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/771c950116f7b08a45eecb6334954cfe8891a587/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp91.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/771c950116f7b08a45eecb6334954cfe8891a587/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp91.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp91.c?ref=771c950116f7b08a45eecb6334954cfe8891a587", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-S -O2 -fdump-tree-vrp2\" } */\n+\n+unsigned short data;\n+void foo ()\n+{\n+  unsigned char  x16;\n+  unsigned int i;\n+  for (i = 0; i < 8; i++)\n+    {\n+      x16 = data & 1;\n+      data >>= 1;\n+      if (x16 == 1)\n+\t{\n+\t  data ^= 0x4;\n+\t}\n+      data >>= 1;\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump \"\\\\\\[0, 7\\\\\\]\" \"vrp2\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp2\" } } */"}, {"sha": "042f7121133c42fec2e725d522f267d23917bb62", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 26, "deletions": 72, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/771c950116f7b08a45eecb6334954cfe8891a587/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/771c950116f7b08a45eecb6334954cfe8891a587/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=771c950116f7b08a45eecb6334954cfe8891a587", "patch": "@@ -4026,52 +4026,6 @@ adjust_range_with_scev (value_range_t *vr, struct loop *loop,\n     }\n }\n \n-/* Return true if VAR may overflow at STMT.  This checks any available\n-   loop information to see if we can determine that VAR does not\n-   overflow.  */\n-\n-static bool\n-vrp_var_may_overflow (tree var, gimple stmt)\n-{\n-  struct loop *l;\n-  tree chrec, init, step;\n-\n-  if (current_loops == NULL)\n-    return true;\n-\n-  l = loop_containing_stmt (stmt);\n-  if (l == NULL\n-      || !loop_outer (l))\n-    return true;\n-\n-  chrec = instantiate_parameters (l, analyze_scalar_evolution (l, var));\n-  if (TREE_CODE (chrec) != POLYNOMIAL_CHREC)\n-    return true;\n-\n-  init = initial_condition_in_loop_num (chrec, l->num);\n-  step = evolution_part_in_loop_num (chrec, l->num);\n-\n-  if (step == NULL_TREE\n-      || !is_gimple_min_invariant (step)\n-      || !valid_value_p (init))\n-    return true;\n-\n-  /* If we get here, we know something useful about VAR based on the\n-     loop information.  If it wraps, it may overflow.  */\n-\n-  if (scev_probably_wraps_p (init, step, stmt, get_chrec_loop (chrec),\n-\t\t\t     true))\n-    return true;\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS) != 0)\n-    {\n-      print_generic_expr (dump_file, var, 0);\n-      fprintf (dump_file, \": loop information indicates does not overflow\\n\");\n-    }\n-\n-  return false;\n-}\n-\n \n /* Given two numeric value ranges VR0, VR1 and a comparison code COMP:\n \n@@ -8452,32 +8406,32 @@ vrp_visit_phi_node (gimple phi)\n \t  && (cmp_min != 0 || cmp_max != 0))\n \tgoto varying;\n \n-      /* If the new minimum is smaller or larger than the previous\n-\t one, go all the way to -INF.  In the first case, to avoid\n-\t iterating millions of times to reach -INF, and in the\n-\t other case to avoid infinite bouncing between different\n-\t minimums.  */\n-      if (cmp_min > 0 || cmp_min < 0)\n-\t{\n-\t  if (!needs_overflow_infinity (TREE_TYPE (vr_result.min))\n-\t      || !vrp_var_may_overflow (lhs, phi))\n-\t    vr_result.min = TYPE_MIN_VALUE (TREE_TYPE (vr_result.min));\n-\t  else if (supports_overflow_infinity (TREE_TYPE (vr_result.min)))\n-\t    vr_result.min =\n-\t\tnegative_overflow_infinity (TREE_TYPE (vr_result.min));\n-\t}\n-\n-      /* Similarly, if the new maximum is smaller or larger than\n-\t the previous one, go all the way to +INF.  */\n-      if (cmp_max < 0 || cmp_max > 0)\n-\t{\n-\t  if (!needs_overflow_infinity (TREE_TYPE (vr_result.max))\n-\t      || !vrp_var_may_overflow (lhs, phi))\n-\t    vr_result.max = TYPE_MAX_VALUE (TREE_TYPE (vr_result.max));\n-\t  else if (supports_overflow_infinity (TREE_TYPE (vr_result.max)))\n-\t    vr_result.max =\n-\t\tpositive_overflow_infinity (TREE_TYPE (vr_result.max));\n-\t}\n+      /* If the new minimum is larger than than the previous one\n+\t retain the old value.  If the new minimum value is smaller\n+\t than the previous one and not -INF go all the way to -INF + 1.\n+\t In the first case, to avoid infinite bouncing between different\n+\t minimums, and in the other case to avoid iterating millions of\n+\t times to reach -INF.  Going to -INF + 1 also lets the following\n+\t iteration compute whether there will be any overflow, at the\n+\t expense of one additional iteration.  */\n+      if (cmp_min < 0)\n+\tvr_result.min = lhs_vr->min;\n+      else if (cmp_min > 0\n+\t       && !vrp_val_is_min (vr_result.min))\n+\tvr_result.min\n+\t  = int_const_binop (PLUS_EXPR,\n+\t\t\t     vrp_val_min (TREE_TYPE (vr_result.min)),\n+\t\t\t     build_int_cst (TREE_TYPE (vr_result.min), 1));\n+\n+      /* Similarly for the maximum value.  */\n+      if (cmp_max > 0)\n+\tvr_result.max = lhs_vr->max;\n+      else if (cmp_max < 0\n+\t       && !vrp_val_is_max (vr_result.max))\n+\tvr_result.max\n+\t  = int_const_binop (MINUS_EXPR,\n+\t\t\t     vrp_val_max (TREE_TYPE (vr_result.min)),\n+\t\t\t     build_int_cst (TREE_TYPE (vr_result.min), 1));\n \n       /* If we dropped either bound to +-INF then if this is a loop\n \t PHI node SCEV may known more about its value-range.  */"}]}