{"sha": "5b031b9b56c63fbf2a24638e6ccb8da45ce936c1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWIwMzFiOWI1NmM2M2ZiZjJhMjQ2MzhlNmNjYjhkYTQ1Y2U5MzZjMQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2012-10-08T14:45:24Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2012-10-08T14:45:24Z"}, "message": "Support C++11 thread_local destructors.\n\ngcc/cp/\n\t* decl.c (get_thread_atexit_node): New.\n\t(register_dtor_fn): Use it for TLS.\nlibstdc++-v3/\n\t* libsupc++/cxxabi.h: Declare __cxa_thread_atexit.\n\t* libsupc++/atexit_thread.cc: New.\n\t* libsupc++/Makefile.am (nested_exception.lo): Add it.\n\t* config/abi/pre/gnu.ver: Add __cxa_thread_atexit.\n\nFrom-SVN: r192210", "tree": {"sha": "a4a11fca4a9f7ebc76dd07531401ce88063958e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a4a11fca4a9f7ebc76dd07531401ce88063958e0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5b031b9b56c63fbf2a24638e6ccb8da45ce936c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b031b9b56c63fbf2a24638e6ccb8da45ce936c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b031b9b56c63fbf2a24638e6ccb8da45ce936c1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b031b9b56c63fbf2a24638e6ccb8da45ce936c1/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b1db7f9139c8a0915f81359eefc10c6187d6145c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1db7f9139c8a0915f81359eefc10c6187d6145c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1db7f9139c8a0915f81359eefc10c6187d6145c"}], "stats": {"total": 453, "additions": 408, "deletions": 45}, "files": [{"sha": "1807f5b0e435ecb5fdcb0c999e7163a90c6ee795", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b031b9b56c63fbf2a24638e6ccb8da45ce936c1/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b031b9b56c63fbf2a24638e6ccb8da45ce936c1/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=5b031b9b56c63fbf2a24638e6ccb8da45ce936c1", "patch": "@@ -1,5 +1,8 @@\n 2012-10-08  Jason Merrill  <jason@redhat.com>\n \n+\t* decl.c (get_thread_atexit_node): New.\n+\t(register_dtor_fn): Use it for TLS.\n+\n \tPartial implementation of C++11 thread_local.\n \t* decl.c (cp_finish_decl): Remove errors about non-trivial\n \tinitialization and destruction of TLS variables."}, {"sha": "7dc13fb94a35bc99182af05ca13cbfb160a86d5e", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 73, "deletions": 44, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b031b9b56c63fbf2a24638e6ccb8da45ce936c1/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b031b9b56c63fbf2a24638e6ccb8da45ce936c1/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=5b031b9b56c63fbf2a24638e6ccb8da45ce936c1", "patch": "@@ -6575,6 +6575,24 @@ get_atexit_node (void)\n   return atexit_node;\n }\n \n+/* Like get_atexit_node, but for thread-local cleanups.  */\n+\n+static tree\n+get_thread_atexit_node (void)\n+{\n+  /* The declaration for `__cxa_thread_atexit' is:\n+\n+     int __cxa_thread_atexit (void (*)(void *), void *, void *) */\n+  tree fn_type = build_function_type_list (integer_type_node,\n+\t\t\t\t\t   get_atexit_fn_ptr_type (),\n+\t\t\t\t\t   ptr_type_node, ptr_type_node,\n+\t\t\t\t\t   NULL_TREE);\n+\n+  /* Now, build the function declaration.  */\n+  tree atexit_fndecl = build_library_fn_ptr (\"__cxa_thread_atexit\", fn_type);\n+  return decay_conversion (atexit_fndecl, tf_warning_or_error);\n+}\n+\n /* Returns the __dso_handle VAR_DECL.  */\n \n static tree\n@@ -6666,23 +6684,27 @@ tree\n register_dtor_fn (tree decl)\n {\n   tree cleanup;\n+  tree addr;\n   tree compound_stmt;\n   tree fcall;\n   tree type;\n-  bool use_dtor;\n-  tree arg0, arg1 = NULL_TREE, arg2 = NULL_TREE;\n+  bool ob_parm, dso_parm, use_dtor;\n+  tree arg0, arg1, arg2;\n+  tree atex_node;\n \n   type = TREE_TYPE (decl);\n   if (TYPE_HAS_TRIVIAL_DESTRUCTOR (type))\n     return void_zero_node;\n \n-  /* If we're using \"__cxa_atexit\" (or \"__aeabi_atexit\"), and DECL is\n-     a class object, we can just pass the destructor to\n-     \"__cxa_atexit\"; we don't have to build a temporary function to do\n-     the cleanup.  */\n-  use_dtor = (flag_use_cxa_atexit \n-\t      && !targetm.cxx.use_atexit_for_cxa_atexit ()\n-\t      && CLASS_TYPE_P (type));\n+  /* If we're using \"__cxa_atexit\" (or \"__cxa_thread_atexit\" or\n+     \"__aeabi_atexit\"), and DECL is a class object, we can just pass the\n+     destructor to \"__cxa_atexit\"; we don't have to build a temporary\n+     function to do the cleanup.  */\n+  ob_parm = (DECL_THREAD_LOCAL_P (decl)\n+\t     || (flag_use_cxa_atexit\n+\t\t && !targetm.cxx.use_atexit_for_cxa_atexit ()));\n+  dso_parm = ob_parm;\n+  use_dtor = ob_parm && CLASS_TYPE_P (type);\n   if (use_dtor)\n     {\n       int idx;\n@@ -6720,44 +6742,48 @@ register_dtor_fn (tree decl)\n       end_cleanup_fn ();\n     }\n \n-  if (DECL_THREAD_LOCAL_P (decl))\n-    /* We don't have a thread-local atexit yet.  FIXME write one using\n-       pthread_key_create and friends.  */\n-    sorry (\"thread-local variable %q#D with non-trivial \"\n-\t   \"destructor\", decl);\n-\n   /* Call atexit with the cleanup function.  */\n   mark_used (cleanup);\n   cleanup = build_address (cleanup);\n-  if (flag_use_cxa_atexit && !targetm.cxx.use_atexit_for_cxa_atexit ())\n+\n+  if (DECL_THREAD_LOCAL_P (decl))\n+    atex_node = get_thread_atexit_node ();\n+  else\n+    atex_node = get_atexit_node ();\n+\n+  if (use_dtor)\n     {\n-      tree addr;\n+      /* We must convert CLEANUP to the type that \"__cxa_atexit\"\n+\t expects.  */\n+      cleanup = build_nop (get_atexit_fn_ptr_type (), cleanup);\n+      /* \"__cxa_atexit\" will pass the address of DECL to the\n+\t cleanup function.  */\n+      mark_used (decl);\n+      addr = build_address (decl);\n+      /* The declared type of the parameter to \"__cxa_atexit\" is\n+\t \"void *\".  For plain \"T*\", we could just let the\n+\t machinery in cp_build_function_call convert it -- but if the\n+\t type is \"cv-qualified T *\", then we need to convert it\n+\t before passing it in, to avoid spurious errors.  */\n+      addr = build_nop (ptr_type_node, addr);\n+    }\n+  else if (ob_parm)\n+    /* Since the cleanup functions we build ignore the address\n+       they're given, there's no reason to pass the actual address\n+       in, and, in general, it's cheaper to pass NULL than any\n+       other value.  */\n+    addr = null_pointer_node;\n+\n+  if (dso_parm)\n+    arg2 = cp_build_addr_expr (get_dso_handle_node (),\n+\t\t\t       tf_warning_or_error);\n+  else\n+    arg2 = NULL_TREE;\n \n-      if (use_dtor)\n-\t{\n-\t  /* We must convert CLEANUP to the type that \"__cxa_atexit\"\n-\t     expects.  */\n-\t  cleanup = build_nop (get_atexit_fn_ptr_type (), cleanup);\n-\t  /* \"__cxa_atexit\" will pass the address of DECL to the\n-\t     cleanup function.  */\n-\t  mark_used (decl);\n-\t  addr = build_address (decl);\n-\t  /* The declared type of the parameter to \"__cxa_atexit\" is\n-\t     \"void *\".  For plain \"T*\", we could just let the\n-\t     machinery in cp_build_function_call convert it -- but if the\n-\t     type is \"cv-qualified T *\", then we need to convert it\n-\t     before passing it in, to avoid spurious errors.  */\n-\t  addr = build_nop (ptr_type_node, addr);\n-\t}\n-      else\n-\t/* Since the cleanup functions we build ignore the address\n-\t   they're given, there's no reason to pass the actual address\n-\t   in, and, in general, it's cheaper to pass NULL than any\n-\t   other value.  */\n-\taddr = null_pointer_node;\n-      arg2 = cp_build_addr_expr (get_dso_handle_node (),\n-\t\t\t\t tf_warning_or_error);\n-      if (targetm.cxx.use_aeabi_atexit ())\n+  if (ob_parm)\n+    {\n+      if (!DECL_THREAD_LOCAL_P (decl)\n+\t  && targetm.cxx.use_aeabi_atexit ())\n \t{\n \t  arg1 = cleanup;\n \t  arg0 = addr;\n@@ -6769,8 +6795,11 @@ register_dtor_fn (tree decl)\n \t}\n     }\n   else\n-    arg0 = cleanup;\n-  return cp_build_function_call_nary (get_atexit_node (), tf_warning_or_error,\n+    {\n+      arg0 = cleanup;\n+      arg1 = NULL_TREE;\n+    }\n+  return cp_build_function_call_nary (atex_node, tf_warning_or_error,\n \t\t\t\t      arg0, arg1, arg2, NULL_TREE);\n }\n "}, {"sha": "d575489d2d5fe5de3c1bf1f3a2e3ed4318fa30cd", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b031b9b56c63fbf2a24638e6ccb8da45ce936c1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b031b9b56c63fbf2a24638e6ccb8da45ce936c1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5b031b9b56c63fbf2a24638e6ccb8da45ce936c1", "patch": "@@ -1,5 +1,10 @@\n 2012-10-08  Jason Merrill  <jason@redhat.com>\n \n+\t* g++.dg/tls/thread_local3.C: New.\n+\t* g++.dg/tls/thread_local4.C: New.\n+\t* g++.dg/tls/thread_local5.C: New.\n+\t* g++.dg/tls/thread_local6.C: New.\n+\n \t* g++.dg/tls/init-2.C: Tweak errors.\n \t* g++.dg/tls/thread_local1.C: New.\n \t* g++.dg/tls/thread_local2.C: New."}, {"sha": "461f12676999f2943635ce224e99ee1ac581de0e", "filename": "gcc/testsuite/g++.dg/tls/thread_local3.C", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b031b9b56c63fbf2a24638e6ccb8da45ce936c1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fthread_local3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b031b9b56c63fbf2a24638e6ccb8da45ce936c1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fthread_local3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fthread_local3.C?ref=5b031b9b56c63fbf2a24638e6ccb8da45ce936c1", "patch": "@@ -0,0 +1,37 @@\n+// { dg-do run }\n+// { dg-require-effective-target c++11 }\n+// { dg-require-effective-target tls_runtime }\n+// { dg-require-effective-target pthread }\n+// { dg-options -pthread }\n+\n+int c;\n+int d;\n+struct A\n+{\n+  A() { ++c; }\n+  ~A() { ++d; }\n+};\n+\n+void f()\n+{\n+  thread_local A a;\n+}\n+\n+void *thread_main(void *)\n+{\n+  f(); f(); f();\n+}\n+\n+#include <pthread.h>\n+\n+int main()\n+{\n+  pthread_t thread;\n+  pthread_create (&thread, 0, thread_main, 0);\n+  pthread_join(thread, 0);\n+  pthread_create (&thread, 0, thread_main, 0);\n+  pthread_join(thread, 0);\n+\n+  if (c != 2 || d != 2)\n+    __builtin_abort();\n+}"}, {"sha": "53b1f0519be68369bdea56db3f2961dd6442e2f0", "filename": "gcc/testsuite/g++.dg/tls/thread_local4.C", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b031b9b56c63fbf2a24638e6ccb8da45ce936c1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fthread_local4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b031b9b56c63fbf2a24638e6ccb8da45ce936c1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fthread_local4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fthread_local4.C?ref=5b031b9b56c63fbf2a24638e6ccb8da45ce936c1", "patch": "@@ -0,0 +1,47 @@\n+// Test for cleanups with pthread_cancel.\n+\n+// { dg-do run }\n+// { dg-require-effective-target c++11 }\n+// { dg-require-effective-target tls_runtime }\n+// { dg-require-effective-target pthread }\n+// { dg-options -pthread }\n+\n+#include <pthread.h>\n+#include <unistd.h>\n+\n+int c;\n+int d;\n+struct A\n+{\n+  A() { ++c; }\n+  ~A() { ++d; }\n+};\n+\n+void f()\n+{\n+  thread_local A a;\n+}\n+\n+void *thread_main(void *)\n+{\n+  f(); f(); f();\n+  while (true)\n+    {\n+      pthread_testcancel();\n+      sleep (1);\n+    }\n+}\n+\n+int main()\n+{\n+  pthread_t thread;\n+  pthread_create (&thread, 0, thread_main, 0);\n+  pthread_cancel(thread);\n+  pthread_join(thread, 0);\n+  pthread_create (&thread, 0, thread_main, 0);\n+  pthread_cancel(thread);\n+  pthread_join(thread, 0);\n+\n+   if (c != 2 || d != 2)\n+     __builtin_abort();\n+}"}, {"sha": "7ce02f62b97983397cbc8cfdda364c14302f9c33", "filename": "gcc/testsuite/g++.dg/tls/thread_local5.C", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b031b9b56c63fbf2a24638e6ccb8da45ce936c1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fthread_local5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b031b9b56c63fbf2a24638e6ccb8da45ce936c1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fthread_local5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fthread_local5.C?ref=5b031b9b56c63fbf2a24638e6ccb8da45ce936c1", "patch": "@@ -0,0 +1,47 @@\n+// Test for cleanups in the main thread, too.\n+\n+// { dg-do run }\n+// { dg-require-effective-target c++11 }\n+// { dg-require-effective-target tls_runtime }\n+// { dg-require-effective-target pthread }\n+// { dg-options -pthread }\n+\n+#include <pthread.h>\n+#include <unistd.h>\n+\n+int c;\n+int d;\n+struct A\n+{\n+  A() { ++c; }\n+  ~A() {\n+    if (++d == 3)\n+      _exit (0);\n+  }\n+};\n+\n+void f()\n+{\n+  thread_local A a;\n+}\n+\n+void *thread_main(void *)\n+{\n+  f(); f(); f();\n+}\n+\n+int main()\n+{\n+  pthread_t thread;\n+  thread_main(0);\n+  pthread_create (&thread, 0, thread_main, 0);\n+  pthread_join(thread, 0);\n+  pthread_create (&thread, 0, thread_main, 0);\n+  pthread_join(thread, 0);\n+\n+  // The dtor for a in the main thread is run after main exits, so we\n+  // return 1 now and override the return value with _exit above.\n+  if (c != 3 || d != 2)\n+    __builtin_abort();\n+  return 1;\n+}"}, {"sha": "118969ae1b398f3c29ec26e54900ca955c1cd2c5", "filename": "gcc/testsuite/g++.dg/tls/thread_local6.C", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b031b9b56c63fbf2a24638e6ccb8da45ce936c1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fthread_local6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b031b9b56c63fbf2a24638e6ccb8da45ce936c1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fthread_local6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fthread_local6.C?ref=5b031b9b56c63fbf2a24638e6ccb8da45ce936c1", "patch": "@@ -0,0 +1,33 @@\n+// Test for cleanups in the main thread without -pthread.\n+\n+// { dg-do run }\n+// { dg-options \"-std=c++11\" }\n+// { dg-require-effective-target tls_runtime }\n+\n+extern \"C\" void _exit (int);\n+\n+int c;\n+struct A\n+{\n+  A() { ++c; }\n+  ~A() { if (c == 1) _exit(0); }\n+};\n+\n+void f()\n+{\n+  thread_local A a;\n+}\n+\n+void *thread_main(void *)\n+{\n+  f(); f(); f();\n+}\n+\n+int main()\n+{\n+  thread_main(0);\n+\n+  // The dtor for a in the main thread is run after main exits, so we\n+  // return 1 now and override the return value with _exit above.\n+  return 1;\n+}"}, {"sha": "fa7381a35ae89ff89df52eed65c12c28b01face8", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b031b9b56c63fbf2a24638e6ccb8da45ce936c1/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b031b9b56c63fbf2a24638e6ccb8da45ce936c1/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=5b031b9b56c63fbf2a24638e6ccb8da45ce936c1", "patch": "@@ -1,3 +1,10 @@\n+2012-10-08  Jason Merrill  <jason@redhat.com>\n+\n+\t* libsupc++/cxxabi.h: Declare __cxa_thread_atexit.\n+\t* libsupc++/atexit_thread.cc: New.\n+\t* libsupc++/Makefile.am (nested_exception.lo): Add it.\n+\t* config/abi/pre/gnu.ver: Add __cxa_thread_atexit.\n+\n 2012-10-07  Matthias Klose  <doko@ubuntu.com>\n \n \t* testsuite/28_regex/algorithms/match/basic: Remove empty directory."}, {"sha": "e23fdfb63b06b9ee65369ee2a14bfd47e17ba79a", "filename": "libstdc++-v3/config/abi/pre/gnu.ver", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b031b9b56c63fbf2a24638e6ccb8da45ce936c1/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b031b9b56c63fbf2a24638e6ccb8da45ce936c1/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver?ref=5b031b9b56c63fbf2a24638e6ccb8da45ce936c1", "patch": "@@ -1531,6 +1531,10 @@ CXXABI_1.3.6 {\n \n } CXXABI_1.3.5;\n \n+CXXABI_1.3.7 {\n+    __cxa_thread_atexit;\n+} CXXABI_1.3.6;\n+\n \n # Symbols in the support library (libsupc++) supporting transactional memory.\n CXXABI_TM_1 {"}, {"sha": "a019bd894329882131e0a9808e122a5820aa72ca", "filename": "libstdc++-v3/libsupc++/Makefile.am", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b031b9b56c63fbf2a24638e6ccb8da45ce936c1/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b031b9b56c63fbf2a24638e6ccb8da45ce936c1/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.am?ref=5b031b9b56c63fbf2a24638e6ccb8da45ce936c1", "patch": "@@ -48,6 +48,7 @@ endif\n sources = \\\n \tarray_type_info.cc \\\n \tatexit_arm.cc \\\n+\tatexit_thread.cc \\\n \tbad_alloc.cc \\\n \tbad_cast.cc \\\n \tbad_typeid.cc \\\n@@ -123,6 +124,11 @@ guard.lo: guard.cc\n guard.o: guard.cc\n \t$(CXXCOMPILE) -std=gnu++0x -c $<\n \n+atexit_thread.lo: atexit_thread.cc\n+\t$(LTCXXCOMPILE) -std=gnu++0x -c $<\n+atexit_thread.o: atexit_thread.cc\n+\t$(CXXCOMPILE) -std=gnu++0x -c $<\n+\n nested_exception.lo: nested_exception.cc\n \t$(LTCXXCOMPILE) -std=gnu++0x -c $<\n nested_exception.o: nested_exception.cc"}, {"sha": "e745179cd3187bef4a4392487e767e4c2de29ef9", "filename": "libstdc++-v3/libsupc++/Makefile.in", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b031b9b56c63fbf2a24638e6ccb8da45ce936c1/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b031b9b56c63fbf2a24638e6ccb8da45ce936c1/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.in?ref=5b031b9b56c63fbf2a24638e6ccb8da45ce936c1", "patch": "@@ -90,7 +90,7 @@ am__installdirs = \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(bitsdir)\" \\\n \t\"$(DESTDIR)$(stddir)\"\n LTLIBRARIES = $(noinst_LTLIBRARIES) $(toolexeclib_LTLIBRARIES)\n libsupc___la_LIBADD =\n-am__objects_1 = array_type_info.lo atexit_arm.lo bad_alloc.lo \\\n+am__objects_1 = array_type_info.lo atexit_arm.lo atexit_thread.lo bad_alloc.lo \\\n \tbad_cast.lo bad_typeid.lo class_type_info.lo del_op.lo \\\n \tdel_opnt.lo del_opv.lo del_opvnt.lo dyncast.lo eh_alloc.lo \\\n \teh_arm.lo eh_aux_runtime.lo eh_call.lo eh_catch.lo \\\n@@ -362,6 +362,7 @@ headers = $(std_HEADERS) $(bits_HEADERS)\n sources = \\\n \tarray_type_info.cc \\\n \tatexit_arm.cc \\\n+\tatexit_thread.cc \\\n \tbad_alloc.cc \\\n \tbad_cast.cc \\\n \tbad_typeid.cc \\\n@@ -800,6 +801,11 @@ guard.lo: guard.cc\n guard.o: guard.cc\n \t$(CXXCOMPILE) -std=gnu++0x -c $<\n \n+atexit_thread.lo: atexit_thread.cc\n+\t$(LTCXXCOMPILE) -std=gnu++0x -c $<\n+atexit_thread.o: atexit_thread.cc\n+\t$(CXXCOMPILE) -std=gnu++0x -c $<\n+\n nested_exception.lo: nested_exception.cc\n \t$(LTCXXCOMPILE) -std=gnu++0x -c $<\n nested_exception.o: nested_exception.cc"}, {"sha": "5e47708d93472884eed9246d4bef11ef1dc25999", "filename": "libstdc++-v3/libsupc++/atexit_thread.cc", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b031b9b56c63fbf2a24638e6ccb8da45ce936c1/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fatexit_thread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b031b9b56c63fbf2a24638e6ccb8da45ce936c1/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fatexit_thread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fatexit_thread.cc?ref=5b031b9b56c63fbf2a24638e6ccb8da45ce936c1", "patch": "@@ -0,0 +1,135 @@\n+// Copyright (C) 2012 Free Software Foundation, Inc.\n+//\n+// This file is part of GCC.\n+//\n+// GCC is free software; you can redistribute it and/or modify\n+// it under the terms of the GNU General Public License as published by\n+// the Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// GCC is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <cxxabi.h>\n+#include <cstdlib>\n+#include <new>\n+#include \"bits/gthr.h\"\n+\n+namespace {\n+  // Data structure for the list of destructors: Singly-linked list\n+  // of arrays.\n+  class list\n+  {\n+    struct elt\n+    {\n+      void *object;\n+      void (*destructor)(void *);\n+    };\n+\n+    static const int max_nelts = 32;\n+\n+    list *next;\n+    int nelts;\n+    elt array[max_nelts];\n+\n+    elt *allocate_elt();\n+  public:\n+    void run();\n+    static void run(void *p);\n+    int add_elt(void (*)(void *), void *);\n+  };\n+\n+  // Return the address of an open slot.\n+  list::elt *\n+  list::allocate_elt()\n+  {\n+    if (nelts < max_nelts)\n+      return &array[nelts++];\n+    if (!next)\n+      next = new (std::nothrow) list();\n+    if (!next)\n+      return 0;\n+    return next->allocate_elt();\n+  }\n+\n+  // Run all the cleanups in the list.\n+  void\n+  list::run()\n+  {\n+    for (int i = nelts - 1; i >= 0; --i)\n+      array[i].destructor (array[i].object);\n+    if (next)\n+      next->run();\n+  }\n+\n+  // Static version to use as a callback to __gthread_key_create.\n+  void\n+  list::run(void *p)\n+  {\n+    static_cast<list *>(p)->run();\n+  }\n+\n+  // The list of cleanups is per-thread.\n+  thread_local list first;\n+\n+  // The pthread data structures for actually running the destructors at\n+  // thread exit are shared.  The constructor of the thread-local sentinel\n+  // object in add_elt performs the initialization.\n+  __gthread_key_t key;\n+  __gthread_once_t once = __GTHREAD_ONCE_INIT;\n+  void run_current () { first.run(); }\n+  void key_init() {\n+    __gthread_key_create (&key, list::run);\n+    // Also make sure the destructors are run by std::exit.\n+    // FIXME TLS cleanups should run before static cleanups and atexit\n+    // cleanups.\n+    std::atexit (run_current);\n+  }\n+  struct sentinel\n+  {\n+    sentinel()\n+    {\n+      if (__gthread_active_p ())\n+\t{\n+\t  __gthread_once (&once, key_init);\n+\t  __gthread_setspecific (key, &first);\n+\t}\n+      else\n+\tstd::atexit (run_current);\n+    }\n+  };\n+\n+  // Actually insert an element.\n+  int\n+  list::add_elt(void (*dtor)(void *), void *obj)\n+  {\n+    thread_local sentinel s;\n+    elt *e = allocate_elt ();\n+    if (!e)\n+      return -1;\n+    e->object = obj;\n+    e->destructor = dtor;\n+    return 0;\n+  }\n+}\n+\n+namespace __cxxabiv1\n+{\n+  extern \"C\" int\n+  __cxa_thread_atexit (void (*dtor)(void *), void *obj, void */*dso_handle*/)\n+    _GLIBCXX_NOTHROW\n+  {\n+    return first.add_elt (dtor, obj);\n+  }\n+}"}, {"sha": "582c435435d2eb0db43de8eae0b04d1fe7717ef3", "filename": "libstdc++-v3/libsupc++/cxxabi.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b031b9b56c63fbf2a24638e6ccb8da45ce936c1/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fcxxabi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b031b9b56c63fbf2a24638e6ccb8da45ce936c1/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fcxxabi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fcxxabi.h?ref=5b031b9b56c63fbf2a24638e6ccb8da45ce936c1", "patch": "@@ -134,6 +134,10 @@ namespace __cxxabiv1\n   int\n   __cxa_finalize(void*);\n \n+  // TLS destruction.\n+  int\n+  __cxa_thread_atexit(void (*)(void*), void*, void *) _GLIBCXX_NOTHROW;\n+\n   // Pure virtual functions.\n   void\n   __cxa_pure_virtual(void) __attribute__ ((__noreturn__));"}]}