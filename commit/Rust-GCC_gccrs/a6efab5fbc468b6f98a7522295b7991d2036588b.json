{"sha": "a6efab5fbc468b6f98a7522295b7991d2036588b", "node_id": "C_kwDOANBUbNoAKGE2ZWZhYjVmYmM0NjhiNmY5OGE3NTIyMjk1Yjc5OTFkMjAzNjU4OGI", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-07-25T14:42:00Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-07-25T18:54:23Z"}, "message": "Dispatch code for floating point range ops.\n\nThis modifies the range-op dispatch code to handle floats.  Also\nprovided are the stub routines for the floating point range-ops, as we\nneed something to dispatch to ;-).\n\nI am not ecstatic about the dispatch code, but there's no getting\naround having to switch on the tree code and type in some manner.  All\nthe other alternatives I played with ended up being slower, or harder\nto maintain.  At least, this one is self-contained in the\nrange_op_handler API, and less than 0.16% slower for VRP in our\nbenchmarks.\n\nTested on x86-64 Linux.\n\ngcc/ChangeLog:\n\n\t* Makefile.in (OBJS): Add range-op-float.o.\n\t* range-op.cc (get_float_handler): New.\n\t(range_op_handler::range_op_handler): Save code and type for\n\tdelayed querying.\n\t(range_op_handler::oeprator bool): Move from header file, and\n\tadd support for floats.\n\t(range_op_handler::fold_range): Add support for floats.\n\t(range_op_handler::op1_range): Same.\n\t(range_op_handler::op2_range): Same.\n\t(range_op_handler::lhs_op1_relation): Same.\n\t(range_op_handler::lhs_op2_relation): Same.\n\t(range_op_handler::op1_op2_relation): Same.\n\t* range-op.h (class range_operator_float): New.\n\t(class floating_op_table): New.\n\t* value-query.cc (range_query::get_tree_range): Add case for\n\tREAL_CST.\n\t* range-op-float.cc: New file.", "tree": {"sha": "2a307fd3068c5374870e6b6301e07d594013e3ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2a307fd3068c5374870e6b6301e07d594013e3ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a6efab5fbc468b6f98a7522295b7991d2036588b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6efab5fbc468b6f98a7522295b7991d2036588b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6efab5fbc468b6f98a7522295b7991d2036588b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6efab5fbc468b6f98a7522295b7991d2036588b/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "838da6cf8d2c8574f5b626823b742032e656619d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/838da6cf8d2c8574f5b626823b742032e656619d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/838da6cf8d2c8574f5b626823b742032e656619d"}], "stats": {"total": 430, "additions": 407, "deletions": 23}, "files": [{"sha": "203f0a15187d2c5fa64fb7a0f9d7d5e405c7a8a0", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6efab5fbc468b6f98a7522295b7991d2036588b/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6efab5fbc468b6f98a7522295b7991d2036588b/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=a6efab5fbc468b6f98a7522295b7991d2036588b", "patch": "@@ -1548,6 +1548,7 @@ OBJS = \\\n \tprofile-count.o \\\n \trange.o \\\n \trange-op.o \\\n+\trange-op-float.o \\\n \tread-md.o \\\n \tread-rtl.o \\\n \tread-rtl-function.o \\"}, {"sha": "8e9d83e38278620dd33f51b61413e975382d9c29", "filename": "gcc/range-op-float.cc", "status": "added", "additions": 206, "deletions": 0, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6efab5fbc468b6f98a7522295b7991d2036588b/gcc%2Frange-op-float.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6efab5fbc468b6f98a7522295b7991d2036588b/gcc%2Frange-op-float.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op-float.cc?ref=a6efab5fbc468b6f98a7522295b7991d2036588b", "patch": "@@ -0,0 +1,206 @@\n+/* Floating point range operators.\n+   Copyright (C) 2022 Free Software Foundation, Inc.\n+   Contributed by Aldy Hernandez <aldyh@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"backend.h\"\n+#include \"insn-codes.h\"\n+#include \"rtl.h\"\n+#include \"tree.h\"\n+#include \"gimple.h\"\n+#include \"cfghooks.h\"\n+#include \"tree-pass.h\"\n+#include \"ssa.h\"\n+#include \"optabs-tree.h\"\n+#include \"gimple-pretty-print.h\"\n+#include \"diagnostic-core.h\"\n+#include \"flags.h\"\n+#include \"fold-const.h\"\n+#include \"stor-layout.h\"\n+#include \"calls.h\"\n+#include \"cfganal.h\"\n+#include \"gimple-iterator.h\"\n+#include \"gimple-fold.h\"\n+#include \"tree-eh.h\"\n+#include \"gimple-walk.h\"\n+#include \"tree-cfg.h\"\n+#include \"wide-int.h\"\n+#include \"value-relation.h\"\n+#include \"range-op.h\"\n+\n+// Default definitions for floating point operators.\n+\n+bool\n+range_operator_float::fold_range (frange &r ATTRIBUTE_UNUSED,\n+\t\t\t\t  tree type ATTRIBUTE_UNUSED,\n+\t\t\t\t  const frange &lh ATTRIBUTE_UNUSED,\n+\t\t\t\t  const frange &rh ATTRIBUTE_UNUSED,\n+\t\t\t\t  relation_kind rel ATTRIBUTE_UNUSED) const\n+{\n+  return false;\n+}\n+\n+bool\n+range_operator_float::fold_range (irange &r ATTRIBUTE_UNUSED,\n+\t\t\t\t  tree type ATTRIBUTE_UNUSED,\n+\t\t\t\t  const frange &lh ATTRIBUTE_UNUSED,\n+\t\t\t\t  const frange &rh ATTRIBUTE_UNUSED,\n+\t\t\t\t  relation_kind rel ATTRIBUTE_UNUSED) const\n+{\n+  return false;\n+}\n+\n+bool\n+range_operator_float::op1_range (frange &r ATTRIBUTE_UNUSED,\n+\t\t\t\t tree type ATTRIBUTE_UNUSED,\n+\t\t\t\t const frange &lhs ATTRIBUTE_UNUSED,\n+\t\t\t\t const frange &op2 ATTRIBUTE_UNUSED,\n+\t\t\t\t relation_kind rel ATTRIBUTE_UNUSED) const\n+{\n+  return false;\n+}\n+\n+bool\n+range_operator_float::op1_range (frange &r ATTRIBUTE_UNUSED,\n+\t\t\t\t tree type ATTRIBUTE_UNUSED,\n+\t\t\t\t const irange &lhs ATTRIBUTE_UNUSED,\n+\t\t\t\t const frange &op2 ATTRIBUTE_UNUSED,\n+\t\t\t\t relation_kind rel ATTRIBUTE_UNUSED) const\n+{\n+  return false;\n+}\n+\n+bool\n+range_operator_float::op2_range (frange &r ATTRIBUTE_UNUSED,\n+\t\t\t\t tree type ATTRIBUTE_UNUSED,\n+\t\t\t\t const frange &lhs ATTRIBUTE_UNUSED,\n+\t\t\t\t const frange &op1 ATTRIBUTE_UNUSED,\n+\t\t\t\t relation_kind rel ATTRIBUTE_UNUSED) const\n+{\n+  return false;\n+}\n+\n+bool\n+range_operator_float::op2_range (frange &r ATTRIBUTE_UNUSED,\n+\t\t\t\t tree type ATTRIBUTE_UNUSED,\n+\t\t\t\t const irange &lhs ATTRIBUTE_UNUSED,\n+\t\t\t\t const frange &op1 ATTRIBUTE_UNUSED,\n+\t\t\t\t relation_kind rel ATTRIBUTE_UNUSED) const\n+{\n+  return false;\n+}\n+\n+relation_kind\n+range_operator_float::lhs_op1_relation (const frange &lhs ATTRIBUTE_UNUSED,\n+\t\t\t\t\tconst frange &op1 ATTRIBUTE_UNUSED,\n+\t\t\t\t\tconst frange &op2 ATTRIBUTE_UNUSED,\n+\t\t\t\t\trelation_kind) const\n+{\n+  return VREL_VARYING;\n+}\n+\n+relation_kind\n+range_operator_float::lhs_op1_relation (const irange &lhs ATTRIBUTE_UNUSED,\n+\t\t\t\t\tconst frange &op1 ATTRIBUTE_UNUSED,\n+\t\t\t\t\tconst frange &op2 ATTRIBUTE_UNUSED,\n+\t\t\t\t\trelation_kind) const\n+{\n+  return VREL_VARYING;\n+}\n+\n+relation_kind\n+range_operator_float::lhs_op2_relation (const irange &lhs ATTRIBUTE_UNUSED,\n+\t\t\t\t\tconst frange &op1 ATTRIBUTE_UNUSED,\n+\t\t\t\t\tconst frange &op2 ATTRIBUTE_UNUSED,\n+\t\t\t\t\trelation_kind) const\n+{\n+  return VREL_VARYING;\n+}\n+\n+relation_kind\n+range_operator_float::lhs_op2_relation (const frange &lhs ATTRIBUTE_UNUSED,\n+\t\t\t\t\tconst frange &op1 ATTRIBUTE_UNUSED,\n+\t\t\t\t\tconst frange &op2 ATTRIBUTE_UNUSED,\n+\t\t\t\t\trelation_kind) const\n+{\n+  return VREL_VARYING;\n+}\n+\n+relation_kind\n+range_operator_float::op1_op2_relation (const irange &lhs ATTRIBUTE_UNUSED) const\n+{\n+  return VREL_VARYING;\n+}\n+\n+class foperator_identity : public range_operator_float\n+{\n+  using range_operator_float::fold_range;\n+  using range_operator_float::op1_range;\n+\n+  bool fold_range (frange &r, tree type ATTRIBUTE_UNUSED,\n+\t\t   const frange &op1, const frange &op2 ATTRIBUTE_UNUSED,\n+\t\t   relation_kind) const final override\n+  {\n+    r = op1;\n+    return true;\n+  }\n+  bool op1_range (frange &r, tree type ATTRIBUTE_UNUSED,\n+\t\t  const frange &lhs, const frange &op2 ATTRIBUTE_UNUSED,\n+\t\t  relation_kind) const final override\n+  {\n+    r = lhs;\n+    return true;\n+  }\n+public:\n+} fop_identity;\n+\n+\n+// Instantiate a range_op_table for floating point operations.\n+static floating_op_table global_floating_table;\n+\n+// Pointer to the float table so the dispatch code can access it.\n+floating_op_table *floating_tree_table = &global_floating_table;\n+\n+floating_op_table::floating_op_table ()\n+{\n+  set (SSA_NAME, fop_identity);\n+  set (PAREN_EXPR, fop_identity);\n+  set (OBJ_TYPE_REF, fop_identity);\n+  set (REAL_CST, fop_identity);\n+}\n+\n+// Return a pointer to the range_operator_float instance, if there is\n+// one associated with tree_code CODE.\n+\n+range_operator_float *\n+floating_op_table::operator[] (enum tree_code code)\n+{\n+  return m_range_tree[code];\n+}\n+\n+// Add OP to the handler table for CODE.\n+\n+void\n+floating_op_table::set (enum tree_code code, range_operator_float &op)\n+{\n+  gcc_checking_assert (m_range_tree[code] == NULL);\n+  m_range_tree[code] = &op;\n+}"}, {"sha": "dfdd971c90acd0a54dfe182d92ea0ff88ce64d51", "filename": "gcc/range-op.cc", "status": "modified", "additions": 132, "deletions": 21, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6efab5fbc468b6f98a7522295b7991d2036588b/gcc%2Frange-op.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6efab5fbc468b6f98a7522295b7991d2036588b/gcc%2Frange-op.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op.cc?ref=a6efab5fbc468b6f98a7522295b7991d2036588b", "patch": "@@ -4152,28 +4152,56 @@ get_handler (enum tree_code code, tree type)\n   return NULL;\n }\n \n+// Return the floating point operator for CODE or NULL if none available.\n+\n+static inline range_operator_float *\n+get_float_handler (enum tree_code code, tree)\n+{\n+  return (*floating_tree_table)[code];\n+}\n+\n range_op_handler::range_op_handler (tree_code code, tree type)\n+  : m_code (code), m_type (type)\n {\n-  m_op = get_handler (code, type);\n }\n \n range_op_handler::range_op_handler (const gimple *s)\n {\n   if (const gassign *ass = dyn_cast<const gassign *> (s))\n     {\n-      enum tree_code code = gimple_assign_rhs_code (ass);\n+      m_code = gimple_assign_rhs_code (ass);\n       // The LHS of a comparison is always an int, so we must look at\n       // the operands.\n-      if (TREE_CODE_CLASS (code) == tcc_comparison)\n-\tm_op = get_handler (code, TREE_TYPE (gimple_assign_rhs1 (ass)));\n+      if (TREE_CODE_CLASS (m_code) == tcc_comparison)\n+\tm_type = TREE_TYPE (gimple_assign_rhs1 (ass));\n       else\n-\tm_op = get_handler (code, TREE_TYPE (gimple_assign_lhs (ass)));\n+\tm_type = TREE_TYPE (gimple_assign_lhs (ass));\n     }\n   else if (const gcond *cond = dyn_cast<const gcond *> (s))\n-    m_op = get_handler (gimple_cond_code (cond),\n-\t\t\tTREE_TYPE (gimple_cond_lhs (cond)));\n+    {\n+      m_code = gimple_cond_code (cond);\n+      m_type = TREE_TYPE (gimple_cond_lhs (cond));\n+    }\n   else\n-    m_op = NULL;\n+    {\n+      // A null type means there is no handler for this combination,\n+      // but the decision whether there is one or not, is delayed\n+      // until operator bool below is queried.\n+      m_code = NOP_EXPR;\n+      m_type = nullptr;\n+    }\n+}\n+\n+// Return TRUE if there is a handler available for the current\n+// combination of tree_code and type.\n+\n+range_op_handler::operator bool () const\n+{\n+  if (!m_type)\n+    return false;\n+  if (frange::supports_p (m_type))\n+    return get_float_handler (m_code, m_type);\n+  return get_handler (m_code, m_type);\n }\n \n bool\n@@ -4182,10 +4210,24 @@ range_op_handler::fold_range (vrange &r, tree type,\n \t\t\t      const vrange &rh,\n \t\t\t      relation_kind rel) const\n {\n-  if (is_a <irange> (lh))\n-    return m_op->fold_range (as_a <irange> (r), type,\n+  if (irange::supports_p (m_type))\n+    {\n+      range_operator *op = get_handler (m_code, m_type);\n+      return op->fold_range (as_a <irange> (r), type,\n \t\t\t     as_a <irange> (lh),\n \t\t\t     as_a <irange> (rh), rel);\n+    }\n+  if (frange::supports_p (m_type))\n+    {\n+      range_operator_float *op = get_float_handler (m_code, m_type);\n+      if (is_a <irange> (r))\n+\treturn op->fold_range (as_a <irange> (r), type,\n+\t\t\t       as_a <frange> (lh),\n+\t\t\t       as_a <frange> (rh), rel);\n+      return op->fold_range (as_a <frange> (r), type,\n+\t\t\t     as_a <frange> (lh),\n+\t\t\t     as_a <frange> (rh), rel);\n+    }\n   gcc_unreachable ();\n   return false;\n }\n@@ -4196,10 +4238,24 @@ range_op_handler::op1_range (vrange &r, tree type,\n \t\t\t     const vrange &op2,\n \t\t\t     relation_kind rel) const\n {\n-  if (is_a <irange> (r))\n-    return m_op->op1_range (as_a <irange> (r), type,\n+  if (irange::supports_p (m_type))\n+    {\n+      range_operator *op = get_handler (m_code, m_type);\n+      return op->op1_range (as_a <irange> (r), type,\n \t\t\t    as_a <irange> (lhs),\n \t\t\t    as_a <irange> (op2), rel);\n+    }\n+  if (frange::supports_p (m_type))\n+    {\n+      range_operator_float *op = get_float_handler (m_code, m_type);\n+      if (is_a <irange> (lhs))\n+\treturn op->op1_range (as_a <frange> (r), type,\n+\t\t\t      as_a <irange> (lhs),\n+\t\t\t      as_a <frange> (op2), rel);\n+      return op->op1_range (as_a <frange> (r), type,\n+\t\t\t    as_a <frange> (lhs),\n+\t\t\t    as_a <frange> (op2), rel);\n+    }\n   gcc_unreachable ();\n   return false;\n }\n@@ -4210,10 +4266,24 @@ range_op_handler::op2_range (vrange &r, tree type,\n \t\t\t     const vrange &op1,\n \t\t\t     relation_kind rel) const\n {\n-  if (is_a <irange> (r))\n-    return m_op->op2_range (as_a <irange> (r), type,\n+  if (irange::supports_p (m_type))\n+    {\n+      range_operator *op = get_handler (m_code, m_type);\n+      return op->op2_range (as_a <irange> (r), type,\n \t\t\t    as_a <irange> (lhs),\n \t\t\t    as_a <irange> (op1), rel);\n+    }\n+  if (frange::supports_p (m_type))\n+    {\n+      range_operator_float *op = get_float_handler (m_code, m_type);\n+      if (is_a <irange> (lhs))\n+\treturn op->op2_range (as_a <frange> (r), type,\n+\t\t\t      as_a <irange> (lhs),\n+\t\t\t      as_a <frange> (op1), rel);\n+      return op->op2_range (as_a <frange> (r), type,\n+\t\t\t    as_a <frange> (lhs),\n+\t\t\t    as_a <frange> (op1), rel);\n+    }\n   gcc_unreachable ();\n   return false;\n }\n@@ -4224,9 +4294,24 @@ range_op_handler::lhs_op1_relation (const vrange &lhs,\n \t\t\t\t    const vrange &op2,\n \t\t\t\t    relation_kind rel) const\n {\n-  if (is_a <irange> (op1))\n-    return m_op->lhs_op1_relation (as_a <irange> (lhs),\n-\t\t\t\t   as_a <irange> (op1), as_a <irange> (op2), rel);\n+  if (irange::supports_p (m_type))\n+    {\n+      range_operator *op = get_handler (m_code, m_type);\n+      return op->lhs_op1_relation (as_a <irange> (lhs),\n+\t\t\t\t   as_a <irange> (op1),\n+\t\t\t\t   as_a <irange> (op2), rel);\n+    }\n+  if (frange::supports_p (m_type))\n+    {\n+      range_operator_float *op = get_float_handler (m_code, m_type);\n+      if (is_a <irange> (lhs))\n+\treturn op->lhs_op1_relation (as_a <irange> (lhs),\n+\t\t\t\t     as_a <frange> (op1),\n+\t\t\t\t     as_a <frange> (op2), rel);\n+      return op->lhs_op1_relation (as_a <frange> (lhs),\n+\t\t\t\t   as_a <frange> (op1),\n+\t\t\t\t   as_a <frange> (op2), rel);\n+    }\n   gcc_unreachable ();\n   return VREL_VARYING;\n }\n@@ -4237,17 +4322,43 @@ range_op_handler::lhs_op2_relation (const vrange &lhs,\n \t\t\t\t    const vrange &op2,\n \t\t\t\t    relation_kind rel) const\n {\n-  if (is_a <irange> (op1))\n-    return m_op->lhs_op2_relation (as_a <irange> (lhs),\n-\t\t\t\t   as_a <irange> (op1), as_a <irange> (op2), rel);\n+  if (irange::supports_p (m_type))\n+    {\n+      range_operator *op = get_handler (m_code, m_type);\n+      return op->lhs_op2_relation (as_a <irange> (lhs),\n+\t\t\t\t   as_a <irange> (op1),\n+\t\t\t\t   as_a <irange> (op2), rel);\n+    }\n+  if (frange::supports_p (m_type))\n+    {\n+      range_operator_float *op = get_float_handler (m_code, m_type);\n+      if (is_a <irange> (lhs))\n+\treturn op->lhs_op2_relation (as_a <irange> (lhs),\n+\t\t\t\t     as_a <frange> (op1),\n+\t\t\t\t     as_a <frange> (op2), rel);\n+      return op->lhs_op2_relation (as_a <frange> (lhs),\n+\t\t\t\t   as_a <frange> (op1),\n+\t\t\t\t   as_a <frange> (op2), rel);\n+    }\n   gcc_unreachable ();\n   return VREL_VARYING;\n }\n \n relation_kind\n range_op_handler::op1_op2_relation (const vrange &lhs) const\n {\n-  return m_op->op1_op2_relation (as_a <irange> (lhs));\n+  if (irange::supports_p (m_type))\n+    {\n+      range_operator *op = get_handler (m_code, m_type);\n+      return op->op1_op2_relation (as_a <irange> (lhs));\n+    }\n+  if (frange::supports_p (m_type))\n+    {\n+      range_operator_float *op = get_float_handler (m_code, m_type);\n+      return op->op1_op2_relation (as_a <irange> (lhs));\n+    }\n+  gcc_unreachable ();\n+  return VREL_VARYING;\n }\n \n // Cast the range in R to TYPE."}, {"sha": "37d9aa91c460fa76b94e09566574209c2725801d", "filename": "gcc/range-op.h", "status": "modified", "additions": 67, "deletions": 2, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6efab5fbc468b6f98a7522295b7991d2036588b/gcc%2Frange-op.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6efab5fbc468b6f98a7522295b7991d2036588b/gcc%2Frange-op.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op.h?ref=a6efab5fbc468b6f98a7522295b7991d2036588b", "patch": "@@ -108,12 +108,61 @@ class range_operator\n \t\t\t const wide_int &rh_ub) const;\n };\n \n+// Like range_operator above, but for floating point operators.\n+\n+class range_operator_float\n+{\n+public:\n+  virtual bool fold_range (frange &r, tree type,\n+\t\t\t   const frange &lh,\n+\t\t\t   const frange &rh,\n+\t\t\t   relation_kind rel = VREL_VARYING) const;\n+  virtual bool fold_range (irange &r, tree type,\n+\t\t\t   const frange &lh,\n+\t\t\t   const frange &rh,\n+\t\t\t   relation_kind rel = VREL_VARYING) const;\n+  virtual bool op1_range (frange &r, tree type,\n+\t\t\t  const frange &lhs,\n+\t\t\t  const frange &op2,\n+\t\t\t  relation_kind rel = VREL_VARYING) const;\n+  virtual bool op1_range (frange &r, tree type,\n+\t\t\t  const irange &lhs,\n+\t\t\t  const frange &op2,\n+\t\t\t  relation_kind rel = VREL_VARYING) const;\n+  virtual bool op2_range (frange &r, tree type,\n+\t\t\t  const frange &lhs,\n+\t\t\t  const frange &op1,\n+\t\t\t  relation_kind rel = VREL_VARYING) const;\n+  virtual bool op2_range (frange &r, tree type,\n+\t\t\t  const irange &lhs,\n+\t\t\t  const frange &op1,\n+\t\t\t  relation_kind rel = VREL_VARYING) const;\n+\n+  virtual relation_kind lhs_op1_relation (const frange &lhs,\n+\t\t\t\t\t  const frange &op1,\n+\t\t\t\t\t  const frange &op2,\n+\t\t\t\t\t  relation_kind = VREL_VARYING) const;\n+  virtual relation_kind lhs_op1_relation (const irange &lhs,\n+\t\t\t\t\t  const frange &op1,\n+\t\t\t\t\t  const frange &op2,\n+\t\t\t\t\t  relation_kind = VREL_VARYING) const;\n+  virtual relation_kind lhs_op2_relation (const frange &lhs,\n+\t\t\t\t\t  const frange &op1,\n+\t\t\t\t\t  const frange &op2,\n+\t\t\t\t\t  relation_kind = VREL_VARYING) const;\n+  virtual relation_kind lhs_op2_relation (const irange &lhs,\n+\t\t\t\t\t  const frange &op1,\n+\t\t\t\t\t  const frange &op2,\n+\t\t\t\t\t  relation_kind = VREL_VARYING) const;\n+  virtual relation_kind op1_op2_relation (const irange &lhs) const;\n+};\n+\n class range_op_handler\n {\n public:\n   range_op_handler (enum tree_code code, tree type);\n   range_op_handler (const gimple *s);\n-  operator bool () const { return m_op; }\n+  operator bool () const;\n \n   bool fold_range (vrange &r, tree type,\n \t\t   const vrange &lh,\n@@ -137,7 +186,8 @@ class range_op_handler\n \t\t\t\t  relation_kind = VREL_VARYING) const;\n   relation_kind op1_op2_relation (const vrange &lhs) const;\n private:\n-  range_operator *m_op;\n+  enum tree_code m_code;\n+  tree m_type;\n };\n \n extern bool range_cast (vrange &, tree type);\n@@ -218,4 +268,19 @@ class range_op_table\n   range_operator *m_range_tree[MAX_TREE_CODES];\n };\n \n+// Like above, but for floating point operators.\n+\n+class floating_op_table\n+{\n+public:\n+  floating_op_table ();\n+  range_operator_float *operator[] (enum tree_code code);\n+private:\n+  void set (enum tree_code code, range_operator_float &op);\n+  range_operator_float *m_range_tree[MAX_TREE_CODES];\n+};\n+\n+// This holds the range op table for floating point operations.\n+extern floating_op_table *floating_tree_table;\n+\n #endif // GCC_RANGE_OP_H"}, {"sha": "4af8eca0172f6d940c7c0264faf95fe3762057ee", "filename": "gcc/value-query.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6efab5fbc468b6f98a7522295b7991d2036588b/gcc%2Fvalue-query.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6efab5fbc468b6f98a7522295b7991d2036588b/gcc%2Fvalue-query.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-query.cc?ref=a6efab5fbc468b6f98a7522295b7991d2036588b", "patch": "@@ -211,6 +211,7 @@ range_query::get_tree_range (vrange &r, tree expr, gimple *stmt)\n   switch (TREE_CODE (expr))\n     {\n     case INTEGER_CST:\n+    case REAL_CST:\n       if (TREE_OVERFLOW_P (expr))\n \texpr = drop_tree_overflow (expr);\n       r.set (expr, expr);"}]}