{"sha": "3fb300196dd0d2ff04eddf6c53f825699fd6720a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2ZiMzAwMTk2ZGQwZDJmZjA0ZWRkZjZjNTNmODI1Njk5ZmQ2NzIwYQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard@codesourcery.com", "date": "2007-08-11T16:51:07Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2007-08-11T16:51:07Z"}, "message": "calls.c (avoid_likely_spilled_reg): New function.\n\ngcc/\n\t* calls.c (avoid_likely_spilled_reg): New function.\n\t(expand_call): Use it.\n\nFrom-SVN: r127360", "tree": {"sha": "0fd74ebf1392d72c5584f02386c670bcd635c4e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0fd74ebf1392d72c5584f02386c670bcd635c4e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3fb300196dd0d2ff04eddf6c53f825699fd6720a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fb300196dd0d2ff04eddf6c53f825699fd6720a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3fb300196dd0d2ff04eddf6c53f825699fd6720a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fb300196dd0d2ff04eddf6c53f825699fd6720a/comments", "author": null, "committer": null, "parents": [{"sha": "4d8a9bfe2438189694ccb83cf02f49b5f1659ae6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d8a9bfe2438189694ccb83cf02f49b5f1659ae6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d8a9bfe2438189694ccb83cf02f49b5f1659ae6"}], "stats": {"total": 39, "additions": 33, "deletions": 6}, "files": [{"sha": "906930e58672675b58f4b5ce275e6fbb45198824", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fb300196dd0d2ff04eddf6c53f825699fd6720a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fb300196dd0d2ff04eddf6c53f825699fd6720a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3fb300196dd0d2ff04eddf6c53f825699fd6720a", "patch": "@@ -1,3 +1,8 @@\n+2007-08-11  Richard Sandiford  <richard@codesourcery.com>\n+\n+\t* calls.c (avoid_likely_spilled_reg): New function.\n+\t(expand_call): Use it.\n+\n 2007-08-11  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* c-typeck.c (build_c_cast): Add OPT_Wcast_qual to warnings."}, {"sha": "df9ef39263bed95d0aacbbf3ab6080da09da9c88", "filename": "gcc/calls.c", "status": "modified", "additions": 28, "deletions": 6, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fb300196dd0d2ff04eddf6c53f825699fd6720a/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fb300196dd0d2ff04eddf6c53f825699fd6720a/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=3fb300196dd0d2ff04eddf6c53f825699fd6720a", "patch": "@@ -1856,6 +1856,31 @@ shift_return_value (enum machine_mode mode, bool left_p, rtx value)\n   return true;\n }\n \n+/* If X is a likely-spilled register value, copy it to a pseudo\n+   register and return that register.  Return X otherwise.  */\n+\n+static rtx\n+avoid_likely_spilled_reg (rtx x)\n+{\n+  rtx new;\n+\n+  if (REG_P (x)\n+      && HARD_REGISTER_P (x)\n+      && CLASS_LIKELY_SPILLED_P (REGNO_REG_CLASS (REGNO (x))))\n+    {\n+      /* Make sure that we generate a REG rather than a CONCAT.\n+\t Moves into CONCATs can need nontrivial instructions,\n+\t and the whole point of this function is to avoid\n+\t using the hard register directly in such a situation.  */\n+      generating_concat_p = 0;\n+      new = gen_reg_rtx (GET_MODE (x));\n+      generating_concat_p = 1;\n+      emit_move_insn (new, x);\n+      return new;\n+    }\n+  return x;\n+}\n+\n /* Generate all the code for a CALL_EXPR exp\n    and return an rtx for its value.\n    Store the value in TARGET (specified as an rtx) if convenient.\n@@ -2953,11 +2978,8 @@ expand_call (tree exp, rtx target, int ignore)\n \n \t  /* We have to copy a return value in a CLASS_LIKELY_SPILLED hard\n \t     reg to a plain register.  */\n-\t  if (REG_P (valreg)\n-\t      && HARD_REGISTER_P (valreg)\n-\t      && CLASS_LIKELY_SPILLED_P (REGNO_REG_CLASS (REGNO (valreg)))\n-\t      && !(REG_P (target) && !HARD_REGISTER_P (target)))\n-\t    valreg = copy_to_reg (valreg);\n+\t  if (!REG_P (target) || HARD_REGISTER_P (target))\n+\t    valreg = avoid_likely_spilled_reg (valreg);\n \n \t  /* If TARGET is a MEM in the argument area, and we have\n \t     saved part of the argument area, then we can't store\n@@ -3002,7 +3024,7 @@ expand_call (tree exp, rtx target, int ignore)\n \t  sibcall_failure = 1;\n \t}\n       else\n-\ttarget = copy_to_reg (valreg);\n+\ttarget = copy_to_reg (avoid_likely_spilled_reg (valreg));\n \n       if (targetm.calls.promote_function_return(funtype))\n \t{"}]}