{"sha": "e86074fd9a0383208782cc499e0eb0d1029efed4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTg2MDc0ZmQ5YTAzODMyMDg3ODJjYzQ5OWUwZWIwZDEwMjllZmVkNA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2013-05-08T11:00:55Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2013-05-08T11:00:55Z"}, "message": "re PR lto/54095 (Unnecessary static variable renaming)\n\n\n\tPR lto/54095\n\tlto-symtab.c (lto_symtab_symbol_p): New function.\n\t(lto_symtab_resolve_can_prevail_p, lto_symtab_resolve_symbols,\n\tlto_symtab_resolve_symbols, lto_symtab_merge_decls_2,\n\tlto_symtab_merge_decls_1, lto_symtab_merge_cgraph_nodes_1):\n\tSkip static symbols.\n\nFrom-SVN: r198707", "tree": {"sha": "dde67024cbc57a0af68b122cd0ddd8d4020977b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dde67024cbc57a0af68b122cd0ddd8d4020977b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e86074fd9a0383208782cc499e0eb0d1029efed4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e86074fd9a0383208782cc499e0eb0d1029efed4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e86074fd9a0383208782cc499e0eb0d1029efed4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e86074fd9a0383208782cc499e0eb0d1029efed4/comments", "author": null, "committer": null, "parents": [{"sha": "a9073727f2965366157d113600c1a51b97430251", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9073727f2965366157d113600c1a51b97430251", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9073727f2965366157d113600c1a51b97430251"}], "stats": {"total": 54, "additions": 40, "deletions": 14}, "files": [{"sha": "452b1e202320589af3428f42a9301b1504b2f5a9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e86074fd9a0383208782cc499e0eb0d1029efed4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e86074fd9a0383208782cc499e0eb0d1029efed4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e86074fd9a0383208782cc499e0eb0d1029efed4", "patch": "@@ -1,3 +1,12 @@\n+2013-05-08  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR lto/54095\n+\tlto-symtab.c (lto_symtab_symbol_p): New function.\n+\t(lto_symtab_resolve_can_prevail_p, lto_symtab_resolve_symbols,\n+\tlto_symtab_resolve_symbols, lto_symtab_merge_decls_2,\n+\tlto_symtab_merge_decls_1, lto_symtab_merge_cgraph_nodes_1):\n+\tSkip static symbols.\n+\n 2013-05-08  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR tree-optimization/57200"}, {"sha": "b28fe63aa851e2b1bf22fd5353d5ead12f53ff3a", "filename": "gcc/lto-symtab.c", "status": "modified", "additions": 31, "deletions": 14, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e86074fd9a0383208782cc499e0eb0d1029efed4/gcc%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e86074fd9a0383208782cc499e0eb0d1029efed4/gcc%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-symtab.c?ref=e86074fd9a0383208782cc499e0eb0d1029efed4", "patch": "@@ -226,12 +226,24 @@ lto_symtab_resolve_replaceable_p (symtab_node e)\n   return false;\n }\n \n+/* Return true, if the symbol E should be resolved by lto-symtab.\n+   Those are all real symbols that are not static (we handle renaming\n+   of static later in partitioning).  */\n+\n+static bool\n+lto_symtab_symbol_p (symtab_node e)\n+{\n+  if (!TREE_PUBLIC (e->symbol.decl))\n+    return false;\n+  return symtab_real_symbol_p (e);\n+}\n+\n /* Return true if the symtab entry E can be the prevailing one.  */\n \n static bool\n lto_symtab_resolve_can_prevail_p (symtab_node e)\n {\n-  if (!symtab_real_symbol_p (e))\n+  if (!lto_symtab_symbol_p (e))\n     return false;\n \n   /* The C++ frontend ends up neither setting TREE_STATIC nor\n@@ -261,7 +273,7 @@ lto_symtab_resolve_symbols (symtab_node first)\n \n   /* Always set e->node so that edges are updated to reflect decl merging. */\n   for (e = first; e; e = e->symbol.next_sharing_asm_name)\n-    if (symtab_real_symbol_p (e)\n+    if (lto_symtab_symbol_p (e)\n \t&& (e->symbol.resolution == LDPR_PREVAILING_DEF_IRONLY\n \t    || e->symbol.resolution == LDPR_PREVAILING_DEF_IRONLY_EXP\n \t    || e->symbol.resolution == LDPR_PREVAILING_DEF))\n@@ -275,7 +287,7 @@ lto_symtab_resolve_symbols (symtab_node first)\n     {\n       /* Assert it's the only one.  */\n       for (e = prevailing->symbol.next_sharing_asm_name; e; e = e->symbol.next_sharing_asm_name)\n-\tif (symtab_real_symbol_p (e)\n+\tif (lto_symtab_symbol_p (e)\n \t    && (e->symbol.resolution == LDPR_PREVAILING_DEF_IRONLY\n \t\t|| e->symbol.resolution == LDPR_PREVAILING_DEF_IRONLY_EXP\n \t\t|| e->symbol.resolution == LDPR_PREVAILING_DEF))\n@@ -310,8 +322,7 @@ lto_symtab_resolve_symbols (symtab_node first)\n   /* Do a second round choosing one from the replaceable prevailing decls.  */\n   for (e = first; e; e = e->symbol.next_sharing_asm_name)\n     {\n-      if (!lto_symtab_resolve_can_prevail_p (e)\n-\t  || !symtab_real_symbol_p (e))\n+      if (!lto_symtab_resolve_can_prevail_p (e))\n \tcontinue;\n \n       /* Choose the first function that can prevail as prevailing.  */\n@@ -365,11 +376,12 @@ lto_symtab_merge_decls_2 (symtab_node first, bool diagnosed_p)\n   /* Try to merge each entry with the prevailing one.  */\n   for (e = prevailing->symbol.next_sharing_asm_name;\n        e; e = e->symbol.next_sharing_asm_name)\n-    {\n-      if (!lto_symtab_merge (prevailing, e)\n-\t  && !diagnosed_p)\n-\tmismatches.safe_push (e->symbol.decl);\n-    }\n+    if (TREE_PUBLIC (e->symbol.decl))\n+      {\n+\tif (!lto_symtab_merge (prevailing, e)\n+\t    && !diagnosed_p)\n+\t  mismatches.safe_push (e->symbol.decl);\n+      }\n   if (mismatches.is_empty ())\n     return;\n \n@@ -411,7 +423,8 @@ lto_symtab_merge_decls_1 (symtab_node first)\n       fprintf (cgraph_dump_file, \"Merging nodes for %s. Candidates:\\n\",\n \t       symtab_node_asm_name (first));\n       for (e = first; e; e = e->symbol.next_sharing_asm_name)\n-\tdump_symtab_node (cgraph_dump_file, e);\n+\tif (TREE_PUBLIC (e->symbol.decl))\n+\t  dump_symtab_node (cgraph_dump_file, e);\n     }\n \n   /* Compute the symbol resolutions.  This is a no-op when using the\n@@ -436,15 +449,17 @@ lto_symtab_merge_decls_1 (symtab_node first)\n \t  for (e = prevailing->symbol.next_sharing_asm_name;\n \t       e; e = e->symbol.next_sharing_asm_name)\n \t    if (!COMPLETE_TYPE_P (TREE_TYPE (prevailing->symbol.decl))\n-\t\t&& COMPLETE_TYPE_P (TREE_TYPE (e->symbol.decl)))\n+\t\t&& COMPLETE_TYPE_P (TREE_TYPE (e->symbol.decl))\n+\t\t&& lto_symtab_symbol_p (e))\n \t      prevailing = e;\n \t}\n       /* For variables prefer the non-builtin if one is available.  */\n       else if (TREE_CODE (prevailing->symbol.decl) == FUNCTION_DECL)\n \t{\n \t  for (e = first; e; e = e->symbol.next_sharing_asm_name)\n \t    if (TREE_CODE (e->symbol.decl) == FUNCTION_DECL\n-\t\t&& !DECL_BUILT_IN (e->symbol.decl))\n+\t\t&& !DECL_BUILT_IN (e->symbol.decl)\n+\t\t&& lto_symtab_symbol_p (e))\n \t      {\n \t\tprevailing = e;\n \t\tbreak;\n@@ -461,6 +476,8 @@ lto_symtab_merge_decls_1 (symtab_node first)\n       if (TREE_CODE (prevailing->symbol.decl)\n \t  == TREE_CODE (e->symbol.decl))\n \tcontinue;\n+      if (!lto_symtab_symbol_p (e))\n+\tcontinue;\n \n       switch (TREE_CODE (prevailing->symbol.decl))\n \t{\n@@ -530,7 +547,7 @@ lto_symtab_merge_cgraph_nodes_1 (symtab_node prevailing)\n     {\n       next = e->symbol.next_sharing_asm_name;\n \n-      if (!symtab_real_symbol_p (e))\n+      if (!lto_symtab_symbol_p (e))\n \tcontinue;\n       cgraph_node *ce = dyn_cast <cgraph_node> (e);\n       if (ce && !DECL_BUILT_IN (e->symbol.decl))"}]}