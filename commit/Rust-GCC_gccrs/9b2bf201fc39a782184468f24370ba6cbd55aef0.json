{"sha": "9b2bf201fc39a782184468f24370ba6cbd55aef0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWIyYmYyMDFmYzM5YTc4MjE4NDQ2OGYyNDM3MGJhNmNiZDU1YWVmMA==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "1999-03-15T19:07:25Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "1999-03-15T19:07:25Z"}, "message": "lex.c: Don't include setjmp.h.\n\n        * lex.c: Don't include setjmp.h.\n        (parse_float): New static function.\n        (pf_args): New struct.\n        (real_yylex): Use them in call to `do_float_handler'.\n\nFrom-SVN: r25794", "tree": {"sha": "5077595da1b99303ab6f165ff6e33badff53202b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5077595da1b99303ab6f165ff6e33badff53202b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9b2bf201fc39a782184468f24370ba6cbd55aef0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b2bf201fc39a782184468f24370ba6cbd55aef0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b2bf201fc39a782184468f24370ba6cbd55aef0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b2bf201fc39a782184468f24370ba6cbd55aef0/comments", "author": null, "committer": null, "parents": [{"sha": "0b22d65c9a10ce316cb28c4c4a988cb3ccc73785", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b22d65c9a10ce316cb28c4c4a988cb3ccc73785", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b22d65c9a10ce316cb28c4c4a988cb3ccc73785"}], "stats": {"total": 212, "additions": 125, "deletions": 87}, "files": [{"sha": "3bf63ffeb362246a4257ad077f5b56175f117a36", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b2bf201fc39a782184468f24370ba6cbd55aef0/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b2bf201fc39a782184468f24370ba6cbd55aef0/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9b2bf201fc39a782184468f24370ba6cbd55aef0", "patch": "@@ -1,3 +1,10 @@\n+Mon Mar 15 21:57:16 1999  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+        * lex.c: Don't include setjmp.h.\n+\t(parse_float): New static function.\n+\t(pf_args): New struct.\n+\t(real_yylex): Use them in call to `do_float_handler'.\n+\n 1999-03-15  Mark Mitchell  <mark@markmitchell.com>\n \n \t* decl.c (xref_basetypes): Set CLASSTYPE_VBASECLASSES here."}, {"sha": "1ed8f0afa769f6440ed67bb2b6cc6ec2d28b4b14", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 118, "deletions": 87, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b2bf201fc39a782184468f24370ba6cbd55aef0/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b2bf201fc39a782184468f24370ba6cbd55aef0/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=9b2bf201fc39a782184468f24370ba6cbd55aef0", "patch": "@@ -27,7 +27,6 @@ Boston, MA 02111-1307, USA.  */\n \n #include \"config.h\"\n #include \"system.h\"\n-#include <setjmp.h>\n #include \"input.h\"\n #include \"tree.h\"\n #include \"lex.h\"\n@@ -85,6 +84,7 @@ static int token_cmp PROTO((int *, int *));\n #endif\n #endif\n static void begin_definition_of_inclass_inline PROTO((struct pending_inline*));\n+static void parse_float PROTO((PTR));\n \n /* Given a file name X, return the nondirectory portion.\n    Keep in mind that X can be computed more than once.  */\n@@ -3181,6 +3181,103 @@ identifier_typedecl_value (node)\n   return NULL_TREE;\n }\n \n+struct pf_args \n+{\n+  /* Input */\n+  /* I/O */\n+  char *p;\n+  int c;\n+  int imag;\n+  tree type;\n+  /* Output */\n+  REAL_VALUE_TYPE value;\n+};\n+\n+static void\n+parse_float (data)\n+     PTR data;\n+{\n+  struct pf_args * args = (struct pf_args *) data;\n+  int fflag = 0, lflag = 0;\n+  /* Copy token_buffer now, while it has just the number\n+     and not the suffixes; once we add `f' or `i',\n+     REAL_VALUE_ATOF may not work any more.  */\n+  char *copy = (char *) alloca (args->p - token_buffer + 1);\n+  bcopy (token_buffer, copy, args->p - token_buffer + 1);\n+  \n+  while (1)\n+    {\n+      int lose = 0;\n+      \n+      /* Read the suffixes to choose a data type.  */\n+      switch (args->c)\n+\t{\n+\tcase 'f': case 'F':\n+\t  if (fflag)\n+\t    error (\"more than one `f' in numeric constant\");\n+\t  fflag = 1;\n+\t  break;\n+\t  \n+\tcase 'l': case 'L':\n+\t  if (lflag)\n+\t    error (\"more than one `l' in numeric constant\");\n+\t  lflag = 1;\n+\t  break;\n+\t  \n+\tcase 'i': case 'I':\n+\t  if (args->imag)\n+\t    error (\"more than one `i' or `j' in numeric constant\");\n+\t  else if (pedantic)\n+\t    pedwarn (\"ANSI C++ forbids imaginary numeric constants\");\n+\t  args->imag = 1;\n+\t  break;\n+\t  \n+\tdefault:\n+\t  lose = 1;\n+\t}\n+      \n+      if (lose)\n+\tbreak;\n+      \n+      if (args->p >= token_buffer + maxtoken - 3)\n+\targs->p = extend_token_buffer (args->p);\n+      *(args->p++) = args->c;\n+      *(args->p) = 0;\n+      args->c = getch ();\n+    }\n+  \n+  /* The second argument, machine_mode, of REAL_VALUE_ATOF\n+     tells the desired precision of the binary result\n+     of decimal-to-binary conversion.  */\n+  \n+  if (fflag)\n+    {\n+      if (lflag)\n+\terror (\"both `f' and `l' in floating constant\");\n+      \n+      args->type = float_type_node;\n+      args->value = REAL_VALUE_ATOF (copy, TYPE_MODE (args->type));\n+      /* A diagnostic is required here by some ANSI C testsuites.\n+\t This is not pedwarn, become some people don't want\n+\t an error for this.  */\n+      if (REAL_VALUE_ISINF (args->value) && pedantic)\n+\twarning (\"floating point number exceeds range of `float'\");\n+    }\n+  else if (lflag)\n+    {\n+      args->type = long_double_type_node;\n+      args->value = REAL_VALUE_ATOF (copy, TYPE_MODE (args->type));\n+      if (REAL_VALUE_ISINF (args->value) && pedantic)\n+\twarning (\"floating point number exceeds range of `long double'\");\n+    }\n+  else\n+    {\n+      args->value = REAL_VALUE_ATOF (copy, TYPE_MODE (args->type));\n+      if (REAL_VALUE_ISINF (args->value) && pedantic)\n+\twarning (\"floating point number exceeds range of `double'\");\n+    }\n+}\n+\n int\n real_yylex ()\n {\n@@ -3716,7 +3813,7 @@ real_yylex ()\n \t    int exceeds_double = 0;\n \t    int imag = 0;\n \t    REAL_VALUE_TYPE value;\n-\t    jmp_buf handler;\n+\t    struct pf_args args;\n \n \t    /* Read explicit exponent if any, and put it in tokenbuf.  */\n \n@@ -3745,97 +3842,31 @@ real_yylex ()\n \t    *p = 0;\n \t    errno = 0;\n \n+\t    /* Setup input for parse_float() */\n+\t    args.p = p;\n+\t    args.c = c;\n+\t    args.imag = imag;\n+\t    args.type = type;\n+\t    \n \t    /* Convert string to a double, checking for overflow.  */\n-\t    if (setjmp (handler))\n+\t    if (do_float_handler (parse_float, (PTR) &args))\n \t      {\n-\t\terror (\"floating constant out of range\");\n-\t\tvalue = dconst0;\n+\t\t/* Receive output from parse_float() */\n+\t\tvalue = args.value;\n \t      }\n \t    else\n \t      {\n-\t\tint fflag = 0, lflag = 0;\n-\t\t/* Copy token_buffer now, while it has just the number\n-\t\t   and not the suffixes; once we add `f' or `i',\n-\t\t   REAL_VALUE_ATOF may not work any more.  */\n-\t\tchar *copy = (char *) alloca (p - token_buffer + 1);\n-\t\tbcopy (token_buffer, copy, p - token_buffer + 1);\n-\n-\t\tset_float_handler (handler);\n-\n-\t\twhile (1)\n-\t\t  {\n-\t\t    int lose = 0;\n-\n-\t\t    /* Read the suffixes to choose a data type.  */\n-\t\t    switch (c)\n-\t\t      {\n-\t\t      case 'f': case 'F':\n-\t\t\tif (fflag)\n-\t\t\t  error (\"more than one `f' in numeric constant\");\n-\t\t\tfflag = 1;\n-\t\t\tbreak;\n-\n-\t\t      case 'l': case 'L':\n-\t\t\tif (lflag)\n-\t\t\t  error (\"more than one `l' in numeric constant\");\n-\t\t\tlflag = 1;\n-\t\t\tbreak;\n-\n-\t\t      case 'i': case 'I':\n-\t\t\tif (imag)\n-\t\t\t  error (\"more than one `i' or `j' in numeric constant\");\n-\t\t\telse if (pedantic)\n-\t\t\t  pedwarn (\"ANSI C++ forbids imaginary numeric constants\");\n-\t\t\timag = 1;\n-\t\t\tbreak;\n-\n-\t\t      default:\n-\t\t\tlose = 1;\n-\t\t      }\n-\n-\t\t    if (lose)\n-\t\t      break;\n-\n-\t\t    if (p >= token_buffer + maxtoken - 3)\n-\t\t      p = extend_token_buffer (p);\n-\t\t    *p++ = c;\n-\t\t    *p = 0;\n-\t\t    c = getch ();\n-\t\t  }\n-\n-\t\t/* The second argument, machine_mode, of REAL_VALUE_ATOF\n-\t\t   tells the desired precision of the binary result\n-\t\t   of decimal-to-binary conversion.  */\n-\n-\t\tif (fflag)\n-\t\t  {\n-\t\t    if (lflag)\n-\t\t      error (\"both `f' and `l' in floating constant\");\n-\n-\t\t    type = float_type_node;\n-\t\t    value = REAL_VALUE_ATOF (copy, TYPE_MODE (type));\n-\t\t    /* A diagnostic is required here by some ANSI C testsuites.\n-\t\t       This is not pedwarn, become some people don't want\n-\t\t       an error for this.  */\n-\t\t    if (REAL_VALUE_ISINF (value) && pedantic)\n-\t\t      warning (\"floating point number exceeds range of `float'\");\n-\t\t  }\n-\t\telse if (lflag)\n-\t\t  {\n-\t\t    type = long_double_type_node;\n-\t\t    value = REAL_VALUE_ATOF (copy, TYPE_MODE (type));\n-\t\t    if (REAL_VALUE_ISINF (value) && pedantic)\n-\t\t      warning (\"floating point number exceeds range of `long double'\");\n-\t\t  }\n-\t\telse\n-\t\t  {\n-\t\t    value = REAL_VALUE_ATOF (copy, TYPE_MODE (type));\n-\t\t    if (REAL_VALUE_ISINF (value) && pedantic)\n-\t\t      warning (\"floating point number exceeds range of `double'\");\n-\t\t  }\n-\n-\t\tset_float_handler (NULL_PTR);\n+\t\t/* We got an exception from parse_float() */\n+\t\terror (\"floating constant out of range\");\n+\t\tvalue = dconst0;\n \t      }\n+\n+\t    /* Receive output from parse_float() */\n+\t    p = args.p;\n+\t    c = args.c;\n+\t    imag = args.imag;\n+\t    type = args.type;\n+\t    \n #ifdef ERANGE\n \t    if (errno == ERANGE && pedantic)\n \t      {"}]}