{"sha": "52682a1b7720c9f2d8528c3498631636f09ebd90", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTI2ODJhMWI3NzIwYzlmMmQ4NTI4YzM0OTg2MzE2MzZmMDllYmQ5MA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2001-02-14T06:32:15Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2001-02-14T06:32:15Z"}, "message": "cp-tree.h (CLASSTYPE_DESTRUCTORS): Fix typo in comment.\n\n\t* cp-tree.h (CLASSTYPE_DESTRUCTORS): Fix typo in comment.\n\t* call.c (build_op_delete_call): Simplify to remove duplicate\n\tcode.\n\t* class.c (clone_function_decl): Don't build the deleting variant\n\tof a non-virtual destructor.\n\t* decl.c (finish_destructor_body): Don't call delete if this is a\n\tnon-virtual destructor.\n\t* init.c (build_delete): Explicitly call `operator delete' when\n\tdeleting an object with a non-virtual destructor.\n\nFrom-SVN: r39659", "tree": {"sha": "d96b4a0445eaddd41c2f31bdde78ca4bce589951", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d96b4a0445eaddd41c2f31bdde78ca4bce589951"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/52682a1b7720c9f2d8528c3498631636f09ebd90", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52682a1b7720c9f2d8528c3498631636f09ebd90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52682a1b7720c9f2d8528c3498631636f09ebd90", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52682a1b7720c9f2d8528c3498631636f09ebd90/comments", "author": null, "committer": null, "parents": [{"sha": "97a4d32ec6b8e1ea688b2ccd8ba54b8597227c79", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97a4d32ec6b8e1ea688b2ccd8ba54b8597227c79", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97a4d32ec6b8e1ea688b2ccd8ba54b8597227c79"}], "stats": {"total": 160, "additions": 96, "deletions": 64}, "files": [{"sha": "4dad89821ba87ec7adec30dcc2fd539c00ab6fa6", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52682a1b7720c9f2d8528c3498631636f09ebd90/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52682a1b7720c9f2d8528c3498631636f09ebd90/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=52682a1b7720c9f2d8528c3498631636f09ebd90", "patch": "@@ -1,3 +1,15 @@\n+2001-02-13  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (CLASSTYPE_DESTRUCTORS): Fix typo in comment.\n+\t* call.c (build_op_delete_call): Simplify to remove duplicate\n+\tcode.\n+\t* class.c (clone_function_decl): Don't build the deleting variant\n+\tof a non-virtual destructor.\n+\t* decl.c (finish_destructor_body): Don't call delete if this is a\n+\tnon-virtual destructor.\n+\t* init.c (build_delete): Explicitly call `operator delete' when\n+\tdeleting an object with a non-virtual destructor.\n+\t\n 2001-02-13  Jason Merrill  <jason@redhat.com>\n \n \t* lang-specs.h: Add more __EXCEPTIONS."}, {"sha": "11cb6404054246b705b1bbb2b2d03868617db2b8", "filename": "gcc/cp/call.c", "status": "modified", "additions": 31, "deletions": 33, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52682a1b7720c9f2d8528c3498631636f09ebd90/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52682a1b7720c9f2d8528c3498631636f09ebd90/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=52682a1b7720c9f2d8528c3498631636f09ebd90", "patch": "@@ -3547,6 +3547,7 @@ build_op_delete_call (code, addr, size, flags, placement)\n      int flags;\n {\n   tree fn, fns, fnname, fntype, argtypes, args, type;\n+  int pass;\n \n   if (addr == error_mark_node)\n     return error_mark_node;\n@@ -3595,48 +3596,45 @@ build_op_delete_call (code, addr, size, flags, placement)\n       args = NULL_TREE;\n     }\n \n-  argtypes = tree_cons (NULL_TREE, ptr_type_node, argtypes);\n-  fntype = build_function_type (void_type_node, argtypes);\n-\n   /* Strip const and volatile from addr.  */\n   addr = cp_convert (ptr_type_node, addr);\n \n-  fn = instantiate_type (fntype, fns, itf_no_attributes);\n-\n-  if (fn != error_mark_node)\n+  /* We make two tries at finding a matching `operator delete'.  On\n+     the first pass, we look for an one-operator (or placement)\n+     operator delete.  If we're not doing placement delete, then on\n+     the second pass we look for a two-argument delete.  */\n+  for (pass = 0; pass < (placement ? 1 : 2); ++pass) \n     {\n-      if (TREE_CODE (fns) == TREE_LIST)\n-\t/* Member functions.  */\n-\tenforce_access (type, fn);\n-      return build_function_call (fn, tree_cons (NULL_TREE, addr, args));\n-    }\n-\n-  /* If we are doing placement delete we do nothing if we don't find a\n-     matching op delete.  */\n-  if (placement)\n-    return NULL_TREE;\n+      if (pass == 0)\n+\targtypes = tree_cons (NULL_TREE, ptr_type_node, argtypes);\n+      else \n+\t/* Normal delete; now try to find a match including the size\n+\t   argument.  */\n+\targtypes = tree_cons (NULL_TREE, ptr_type_node,\n+\t\t\t      tree_cons (NULL_TREE, sizetype, \n+\t\t\t\t\t void_list_node));\n \n-  /* Normal delete; now try to find a match including the size argument.  */\n-  argtypes = tree_cons (NULL_TREE, ptr_type_node,\n-\t\t\ttree_cons (NULL_TREE, sizetype, void_list_node));\n-  fntype = build_function_type (void_type_node, argtypes);\n+      fntype = build_function_type (void_type_node, argtypes);\n+      fn = instantiate_type (fntype, fns, itf_no_attributes);\n \n-  fn = instantiate_type (fntype, fns, itf_no_attributes);\n+      if (fn != error_mark_node)\n+\t{\n+\t  /* Member functions.  */\n+\t  if (BASELINK_P (fns))\n+\t    enforce_access (type, fn);\n \n-  if (fn != error_mark_node)\n-    {\n-      if (BASELINK_P (fns))\n-\t/* Member functions.  */\n-\tenforce_access (type, fn);\n-      return build_function_call\n-\t(fn, tree_cons (NULL_TREE, addr,\n-\t\t\tbuild_tree_list (NULL_TREE, size)));\n+\t  if (pass == 0)\n+\t    args = tree_cons (NULL_TREE, addr, args);\n+\t  else\n+\t    args = tree_cons (NULL_TREE, addr, \n+\t\t\t      build_tree_list (NULL_TREE, size));\n+\t  return build_function_call (fn, args);\n+\t}\n     }\n \n-  /* finish_function passes LOOKUP_SPECULATIVELY if we're in a\n-     destructor, in which case the error should be deferred\n-     until someone actually tries to delete one of these.  */\n-  if (flags & LOOKUP_SPECULATIVELY)\n+  /* If we are doing placement delete we do nothing if we don't find a\n+     matching op delete.  */\n+  if (placement)\n     return NULL_TREE;\n \n   cp_error (\"no suitable `operator delete' for `%T'\", type);"}, {"sha": "2d8ab83dee2aa55a19135e7f49057bfb0cea62ed", "filename": "gcc/cp/class.c", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52682a1b7720c9f2d8528c3498631636f09ebd90/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52682a1b7720c9f2d8528c3498631636f09ebd90/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=52682a1b7720c9f2d8528c3498631636f09ebd90", "patch": "@@ -4319,10 +4319,16 @@ clone_function_decl (fn, update_method_vec_p)\n \t version.  We clone the deleting version first because that\n \t means it will go second on the TYPE_METHODS list -- and that\n \t corresponds to the correct layout order in the virtual\n-\t function table.  */\n-      clone = build_clone (fn, deleting_dtor_identifier);\n-      if (update_method_vec_p)\n-\tadd_method (DECL_CONTEXT (clone), clone, /*error_p=*/0);\n+\t function table.  \n+\n+         For a non-virtual destructor, we do not build a deleting\n+\t destructor.  */\n+      if (DECL_VIRTUAL_P (fn))\n+\t{\n+\t  clone = build_clone (fn, deleting_dtor_identifier);\n+\t  if (update_method_vec_p)\n+\t    add_method (DECL_CONTEXT (clone), clone, /*error_p=*/0);\n+\t}\n       clone = build_clone (fn, complete_dtor_identifier);\n       if (update_method_vec_p)\n \tadd_method (DECL_CONTEXT (clone), clone, /*error_p=*/0);"}, {"sha": "7881429dadfe55ec7853342628705f9f1d85b2d4", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52682a1b7720c9f2d8528c3498631636f09ebd90/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52682a1b7720c9f2d8528c3498631636f09ebd90/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=52682a1b7720c9f2d8528c3498631636f09ebd90", "patch": "@@ -1456,7 +1456,7 @@ struct lang_type\n #define CLASSTYPE_CONSTRUCTORS(NODE) \\\n   (TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (NODE), CLASSTYPE_CONSTRUCTOR_SLOT))\n \n-/* A FUNCTION_DECL for the destructor for NODE.  These are te\n+/* A FUNCTION_DECL for the destructor for NODE.  These are the\n    destructors that take an in-charge parameter.  */\n #define CLASSTYPE_DESTRUCTORS(NODE) \\\n   (TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (NODE), CLASSTYPE_DESTRUCTOR_SLOT))"}, {"sha": "3e3f37be89de6b737e8f79cce1b65ea1db7ddd58", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52682a1b7720c9f2d8528c3498631636f09ebd90/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52682a1b7720c9f2d8528c3498631636f09ebd90/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=52682a1b7720c9f2d8528c3498631636f09ebd90", "patch": "@@ -13730,9 +13730,7 @@ static void\n finish_destructor_body ()\n {\n   tree compound_stmt;\n-  tree virtual_size;\n   tree exprstmt;\n-  tree if_stmt;\n \n   /* Create a block to contain all the extra code.  */\n   compound_stmt = begin_compound_stmt (/*has_no_scope=*/0);\n@@ -13814,31 +13812,31 @@ finish_destructor_body ()\n \t}\n     }\n \n-  virtual_size = c_sizeof (current_class_type);\n-\n-  /* At the end, call delete if that's what's requested.  */\n+  /* In a virtual destructor, we must call delete.  */\n+  if (DECL_VIRTUAL_P (current_function_decl))\n+    {\n+      tree if_stmt;\n+      tree virtual_size = c_sizeof (current_class_type);\n \n-  /* FDIS sez: At the point of definition of a virtual destructor\n-     (including an implicit definition), non-placement operator delete\n-     shall be looked up in the scope of the destructor's class and if\n-     found shall be accessible and unambiguous.\n+      /* [class.dtor]\n \n-     This is somewhat unclear, but I take it to mean that if the class\n-     only defines placement deletes we don't do anything here.  So we\n-     pass LOOKUP_SPECULATIVELY; delete_sanity will complain for us if\n-     they ever try to delete one of these.  */\n-  exprstmt = build_op_delete_call\n-    (DELETE_EXPR, current_class_ptr, virtual_size,\n-     LOOKUP_NORMAL | LOOKUP_SPECULATIVELY, NULL_TREE);\n+\t At the point of definition of a virtual destructor (including\n+\t an implicit definition), non-placement operator delete shall\n+\t be looked up in the scope of the destructor's class and if\n+\t found shall be accessible and unambiguous.  */\n+      exprstmt = build_op_delete_call\n+\t(DELETE_EXPR, current_class_ptr, virtual_size,\n+\t LOOKUP_NORMAL | LOOKUP_SPECULATIVELY, NULL_TREE);\n \n-  if_stmt = begin_if_stmt ();\n-  finish_if_stmt_cond (build (BIT_AND_EXPR, integer_type_node,\n-\t\t\t      current_in_charge_parm,\n-\t\t\t      integer_one_node),\n-\t\t       if_stmt);\n-  finish_expr_stmt (exprstmt);\n-  finish_then_clause (if_stmt);\n-  finish_if_stmt ();\n+      if_stmt = begin_if_stmt ();\n+      finish_if_stmt_cond (build (BIT_AND_EXPR, integer_type_node,\n+\t\t\t\t  current_in_charge_parm,\n+\t\t\t\t  integer_one_node),\n+\t\t\t   if_stmt);\n+      finish_expr_stmt (exprstmt);\n+      finish_then_clause (if_stmt);\n+      finish_if_stmt ();\n+    }\n \n   /* Close the block we started above.  */\n   finish_compound_stmt (/*has_no_scope=*/0, compound_stmt);"}, {"sha": "becb347bc963ec27b812aa3692b7165ce2be8dfd", "filename": "gcc/cp/init.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52682a1b7720c9f2d8528c3498631636f09ebd90/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52682a1b7720c9f2d8528c3498631636f09ebd90/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=52682a1b7720c9f2d8528c3498631636f09ebd90", "patch": "@@ -3235,6 +3235,9 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n       tree do_delete = NULL_TREE;\n       tree ifexp;\n \n+      /* For `::delete x', we must not use the deleting destructor\n+\t since then we would not be sure to get the global `operator\n+\t delete'.  */\n       if (use_global_delete && auto_delete == sfk_deleting_destructor)\n \t{\n \t  /* Delete the object. */\n@@ -3243,6 +3246,21 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n \t     call.  */\n \t  auto_delete = sfk_complete_destructor;\n \t}\n+      /* If the destructor is non-virtual, there is no deleting\n+\t variant.  Instead, we must explicitly call the appropriate\n+\t `operator delete' here.  */\n+      else if (!DECL_VIRTUAL_P (CLASSTYPE_DESTRUCTORS (type))\n+\t       && auto_delete == sfk_deleting_destructor)\n+\t{\n+\t  /* Buidl the call.  */\n+\t  do_delete = build_op_delete_call (DELETE_EXPR,\n+\t\t\t\t\t    addr,\n+\t\t\t\t\t    c_sizeof_nowarn (type),\n+\t\t\t\t\t    LOOKUP_NORMAL,\n+\t\t\t\t\t    NULL_TREE);\n+\t  /* Call the complete object destructor.  */\n+\t  auto_delete = sfk_complete_destructor;\n+\t}\n \n       expr = build_dtor_call (ref, auto_delete, flags);\n       if (do_delete)"}, {"sha": "d8ddefec32e421375c41569916bf5596f41d57d6", "filename": "gcc/testsuite/g++.old-deja/g++.oliva/delete1.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52682a1b7720c9f2d8528c3498631636f09ebd90/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.oliva%2Fdelete1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52682a1b7720c9f2d8528c3498631636f09ebd90/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.oliva%2Fdelete1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.oliva%2Fdelete1.C?ref=52682a1b7720c9f2d8528c3498631636f09ebd90", "patch": "@@ -1,6 +1,6 @@\n // Build don't link:\n \n-// Copyright (C) 1999 Free Software Foundation\n+// Copyright (C) 1999, 2001 Free Software Foundation\n \n // by Alexandre Oliva <oliva@dcc.unicamp.br>\n // simplified from bug report by K. Haley <khaley@bigfoot.com>\n@@ -21,7 +21,7 @@ struct bar : foo {\n     delete this; // ERROR - delete is private\n     // An implicit invocation of delete is emitted in destructors, but\n     // it should only be checked in virtual destructors\n-  } // gets bogus error - not virtual - XFAIL *-*-*\n+  } // gets bogus error - not virtual\n } bar_;\n \n struct baz : foo {"}]}