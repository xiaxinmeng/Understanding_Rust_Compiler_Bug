{"sha": "8edfc4ccb46c6b8ccd48e7136d1ed5f5f646ff9a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGVkZmM0Y2NiNDZjNmI4Y2NkNDhlNzEzNmQxZWQ1ZjVmNjQ2ZmY5YQ==", "commit": {"author": {"name": "Mark Shinwell", "email": "shinwell@codesourcery.com", "date": "2006-12-13T17:32:47Z"}, "committer": {"name": "Mark Shinwell", "email": "shinwell@gcc.gnu.org", "date": "2006-12-13T17:32:47Z"}, "message": "arm.c (arm_output_fldmx): Output FLDMD instead of FLDMX.\n\n        gcc/\n        * config/arm/arm.c (arm_output_fldmx): Output FLDMD instead of\n        FLDMX.  Rename function to...\n        (vfp_output_fldmd): ...this.\n        (vfp_output_fstmx): Output FSTMD instead of FSTMX.  Rename\n        function to...\n        (vfp_output_fstmd): ...this.\n        (vfp_emit_fstmx): Don't leave space in the frame layout for the\n        FSTMX format word.  Rename function to...\n        (vfp_emit_fstmd): ...this.\n        (arm_get_vfp_saved_size): Don't add in space for the FSTMX format\n        word.\n        (arm_output_epilogue): Adjust comment to reflect use of FSTMD.\n        (arm_unwind_emit_sequence): Don't compensate for the FSTMX format\n        word.  Also emit \"vsave\" assembler directives in such cases rather\n        than \"save\".\n        * config/arm/libunwind.S (gnu_Unwind_Restore_VFP,\n        gnu_Unwind_Save_VFP): Adjust comments.\n        (gnu_Unwind_Restore_VFP_D, gnu_Unwind_Save_VFP_D): New functions\n        for saving and restoring using FSTMD and FLDMD rather than\n        FSTMX and FLDMX.\n        (gnu_Unwind_Restore_VFP_D_16_to_31, gnu_Unwind_Restore_VFP_D_16_to_31):\n        New functions for saving and restoring the VFPv3 registers 16 .. 31.\n        * config/arm/pr-support.c (gnu_unwind_execute): Add conditional\n        compilation case to correctly handle unwind opcode 0xc8 when using\n        VFP.\n        * config/arm/unwind-arm.c (struct vfpv3_regs): New.\n        (DEMAND_SAVE_VFP_D, DEMAND_SAVE_VFP_V3): New flags.\n        (__gnu_Unwind_Save_VFP_D, __gnu_Unwind_Restore_VFP_D,\n        __gnu_Unwind_Save_VFP_D_16_to_31, __gnu_Unwind_Restore_VFP_D_16_to_31):\n        Declare.\n        (restore_non_core_regs): Restore registers using FLDMD rather than\n        FLDMX if required.  Also handle restoration of VFPv3 registers.\n        (_Unwind_VRS_Pop): Handle saving and restoring of registers using\n        FSTMD and FLDMD if required; also handle VFPv3 registers 16 .. 31,\n        including cases where the caller specifies a range of registers\n        that overlaps the d15/d16 boundary.\n\nFrom-SVN: r119838", "tree": {"sha": "a3726593e85e90ebfe48f61c453b0ee08de88369", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a3726593e85e90ebfe48f61c453b0ee08de88369"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8edfc4ccb46c6b8ccd48e7136d1ed5f5f646ff9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8edfc4ccb46c6b8ccd48e7136d1ed5f5f646ff9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8edfc4ccb46c6b8ccd48e7136d1ed5f5f646ff9a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8edfc4ccb46c6b8ccd48e7136d1ed5f5f646ff9a/comments", "author": null, "committer": null, "parents": [{"sha": "6cf43108a94524fb164f4d29401ed8cf1890d347", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cf43108a94524fb164f4d29401ed8cf1890d347", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6cf43108a94524fb164f4d29401ed8cf1890d347"}], "stats": {"total": 285, "additions": 232, "deletions": 53}, "files": [{"sha": "6f579c7b850559629888ece5d4cc526de2d162c8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8edfc4ccb46c6b8ccd48e7136d1ed5f5f646ff9a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8edfc4ccb46c6b8ccd48e7136d1ed5f5f646ff9a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8edfc4ccb46c6b8ccd48e7136d1ed5f5f646ff9a", "patch": "@@ -1,3 +1,42 @@\n+2006-12-13  Mark Shinwell  <shinwell@codesourcery.com>\n+\n+\t* config/arm/arm.c (arm_output_fldmx): Output FLDMD instead of\n+\tFLDMX.  Rename function to...\n+\t(vfp_output_fldmd): ...this.\n+\t(vfp_output_fstmx): Output FSTMD instead of FSTMX.  Rename\n+\tfunction to...\n+\t(vfp_output_fstmd): ...this.\n+\t(vfp_emit_fstmx): Don't leave space in the frame layout for the\n+\tFSTMX format word.  Rename function to...\n+\t(vfp_emit_fstmd): ...this.\n+\t(arm_get_vfp_saved_size): Don't add in space for the FSTMX format\n+\tword.\n+\t(arm_output_epilogue): Adjust comment to reflect use of FSTMD.\n+\t(arm_unwind_emit_sequence): Don't compensate for the FSTMX format\n+\tword.  Also emit \"vsave\" assembler directives in such cases rather\n+\tthan \"save\".\n+\t* config/arm/libunwind.S (gnu_Unwind_Restore_VFP,\n+\tgnu_Unwind_Save_VFP): Adjust comments.\n+\t(gnu_Unwind_Restore_VFP_D, gnu_Unwind_Save_VFP_D): New functions\n+\tfor saving and restoring using FSTMD and FLDMD rather than\n+\tFSTMX and FLDMX.\n+\t(gnu_Unwind_Restore_VFP_D_16_to_31, gnu_Unwind_Restore_VFP_D_16_to_31):\n+\tNew functions for saving and restoring the VFPv3 registers 16 .. 31.\n+\t* config/arm/pr-support.c (gnu_unwind_execute): Add conditional\n+\tcompilation case to correctly handle unwind opcode 0xc8 when using\n+\tVFP.\n+\t* config/arm/unwind-arm.c (struct vfpv3_regs): New.\n+\t(DEMAND_SAVE_VFP_D, DEMAND_SAVE_VFP_V3): New flags.\n+\t(__gnu_Unwind_Save_VFP_D, __gnu_Unwind_Restore_VFP_D,\n+\t__gnu_Unwind_Save_VFP_D_16_to_31, __gnu_Unwind_Restore_VFP_D_16_to_31):\n+\tDeclare.\n+\t(restore_non_core_regs): Restore registers using FLDMD rather than\n+\tFLDMX if required.  Also handle restoration of VFPv3 registers.\n+\t(_Unwind_VRS_Pop): Handle saving and restoring of registers using\n+\tFSTMD and FLDMD if required; also handle VFPv3 registers 16 .. 31,\n+\tincluding cases where the caller specifies a range of registers\n+\tthat overlaps the d15/d16 boundary.\n+\n 2006-12-13  Diego Novillo  <dnovillo@redhat.com>\n \n \tPR 30089"}, {"sha": "032c4e6ec699edb0e0c6e14abbfb3be8c001d9a2", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8edfc4ccb46c6b8ccd48e7136d1ed5f5f646ff9a/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8edfc4ccb46c6b8ccd48e7136d1ed5f5f646ff9a/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=8edfc4ccb46c6b8ccd48e7136d1ed5f5f646ff9a", "patch": "@@ -121,7 +121,7 @@ extern int arm_debugger_arg_offset (int, rtx);\n extern int arm_is_longcall_p (rtx, int, int);\n extern int    arm_emit_vector_const (FILE *, rtx);\n extern const char * arm_output_load_gr (rtx *);\n-extern const char *vfp_output_fstmx (rtx *);\n+extern const char *vfp_output_fstmd (rtx *);\n extern void arm_set_return_address (rtx, rtx);\n extern int arm_eliminable_register (rtx);\n "}, {"sha": "c7bf05fc4e4ed935439a1d942a0c166f4b8062f4", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 25, "deletions": 27, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8edfc4ccb46c6b8ccd48e7136d1ed5f5f646ff9a/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8edfc4ccb46c6b8ccd48e7136d1ed5f5f646ff9a/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=8edfc4ccb46c6b8ccd48e7136d1ed5f5f646ff9a", "patch": "@@ -8425,13 +8425,17 @@ print_multi_reg (FILE *stream, const char *instr, unsigned reg,\n }\n \n \n-/* Output a FLDMX instruction to STREAM.\n+/* Output a FLDMD instruction to STREAM.\n    BASE if the register containing the address.\n    REG and COUNT specify the register range.\n-   Extra registers may be added to avoid hardware bugs.  */\n+   Extra registers may be added to avoid hardware bugs.\n+\n+   We output FLDMD even for ARMv5 VFP implementations.  Although\n+   FLDMD is technically not supported until ARMv6, it is believed\n+   that all VFP implementations support its use in this context.  */\n \n static void\n-arm_output_fldmx (FILE * stream, unsigned int base, int reg, int count)\n+vfp_output_fldmd (FILE * stream, unsigned int base, int reg, int count)\n {\n   int i;\n \n@@ -8444,7 +8448,7 @@ arm_output_fldmx (FILE * stream, unsigned int base, int reg, int count)\n     }\n \n   fputc ('\\t', stream);\n-  asm_fprintf (stream, \"fldmfdx\\t%r!, {\", base);\n+  asm_fprintf (stream, \"fldmfdd\\t%r!, {\", base);\n \n   for (i = reg; i < reg + count; i++)\n     {\n@@ -8460,14 +8464,14 @@ arm_output_fldmx (FILE * stream, unsigned int base, int reg, int count)\n /* Output the assembly for a store multiple.  */\n \n const char *\n-vfp_output_fstmx (rtx * operands)\n+vfp_output_fstmd (rtx * operands)\n {\n   char pattern[100];\n   int p;\n   int base;\n   int i;\n \n-  strcpy (pattern, \"fstmfdx\\t%m0!, {%P1\");\n+  strcpy (pattern, \"fstmfdd\\t%m0!, {%P1\");\n   p = strlen (pattern);\n \n   gcc_assert (GET_CODE (operands[1]) == REG);\n@@ -8488,7 +8492,7 @@ vfp_output_fstmx (rtx * operands)\n    number of bytes pushed.  */\n \n static int\n-vfp_emit_fstmx (int base_reg, int count)\n+vfp_emit_fstmd (int base_reg, int count)\n {\n   rtx par;\n   rtx dwarf;\n@@ -8505,10 +8509,6 @@ vfp_emit_fstmx (int base_reg, int count)\n       count++;\n     }\n \n-  /* ??? The frame layout is implementation defined.  We describe\n-     standard format 1 (equivalent to a FSTMD insn and unused pad word).\n-     We really need some way of representing the whole block so that the\n-     unwinder can figure it out at runtime.  */\n   par = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (count));\n   dwarf = gen_rtx_SEQUENCE (VOIDmode, rtvec_alloc (count + 1));\n \n@@ -8525,7 +8525,7 @@ vfp_emit_fstmx (int base_reg, int count)\n \t\t\t\t   UNSPEC_PUSH_MULT));\n \n   tmp = gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n-\t\t     plus_constant (stack_pointer_rtx, -(count * 8 + 4)));\n+\t\t     plus_constant (stack_pointer_rtx, -(count * 8)));\n   RTX_FRAME_RELATED_P (tmp) = 1;\n   XVECEXP (dwarf, 0, 0) = tmp;\n \n@@ -8555,7 +8555,7 @@ vfp_emit_fstmx (int base_reg, int count)\n \t\t\t\t       REG_NOTES (par));\n   RTX_FRAME_RELATED_P (par) = 1;\n \n-  return count * 8 + 4;\n+  return count * 8;\n }\n \n \n@@ -9451,7 +9451,7 @@ arm_get_vfp_saved_size (void)\n \t\t  /* Workaround ARM10 VFPr1 bug.  */\n \t\t  if (count == 2 && !arm_arch6)\n \t\t    count++;\n-\t\t  saved += count * 8 + 4;\n+\t\t  saved += count * 8;\n \t\t}\n \t      count = 0;\n \t    }\n@@ -9462,7 +9462,7 @@ arm_get_vfp_saved_size (void)\n \t{\n \t  if (count == 2 && !arm_arch6)\n \t    count++;\n-\t  saved += count * 8 + 4;\n+\t  saved += count * 8;\n \t}\n     }\n   return saved;\n@@ -9888,8 +9888,8 @@ arm_output_epilogue (rtx sibling)\n \t{\n \t  int saved_size;\n \n-\t  /* The fldmx insn does not have base+offset addressing modes,\n-\t     so we use IP to hold the address.  */\n+\t  /* The fldmd insns do not have base+offset addressing\n+             modes, so we use IP to hold the address.  */\n \t  saved_size = arm_get_vfp_saved_size ();\n \n \t  if (saved_size > 0)\n@@ -9905,14 +9905,14 @@ arm_output_epilogue (rtx sibling)\n \t\t  && (!regs_ever_live[reg + 1] || call_used_regs[reg + 1]))\n \t\t{\n \t\t  if (start_reg != reg)\n-\t\t    arm_output_fldmx (f, IP_REGNUM,\n+\t\t    vfp_output_fldmd (f, IP_REGNUM,\n \t\t\t\t      (start_reg - FIRST_VFP_REGNUM) / 2,\n \t\t\t\t      (reg - start_reg) / 2);\n \t\t  start_reg = reg + 2;\n \t\t}\n \t    }\n \t  if (start_reg != reg)\n-\t    arm_output_fldmx (f, IP_REGNUM,\n+\t    vfp_output_fldmd (f, IP_REGNUM,\n \t\t\t      (start_reg - FIRST_VFP_REGNUM) / 2,\n \t\t\t      (reg - start_reg) / 2);\n \t}\n@@ -10036,14 +10036,14 @@ arm_output_epilogue (rtx sibling)\n \t\t  && (!regs_ever_live[reg + 1] || call_used_regs[reg + 1]))\n \t\t{\n \t\t  if (start_reg != reg)\n-\t\t    arm_output_fldmx (f, SP_REGNUM,\n+\t\t    vfp_output_fldmd (f, SP_REGNUM,\n \t\t\t\t      (start_reg - FIRST_VFP_REGNUM) / 2,\n \t\t\t\t      (reg - start_reg) / 2);\n \t\t  start_reg = reg + 2;\n \t\t}\n \t    }\n \t  if (start_reg != reg)\n-\t    arm_output_fldmx (f, SP_REGNUM,\n+\t    vfp_output_fldmd (f, SP_REGNUM,\n \t\t\t      (start_reg - FIRST_VFP_REGNUM) / 2,\n \t\t\t      (reg - start_reg) / 2);\n \t}\n@@ -10841,13 +10841,13 @@ arm_expand_prologue (void)\n \t\t  && (!regs_ever_live[reg + 1] || call_used_regs[reg + 1]))\n \t\t{\n \t\t  if (start_reg != reg)\n-\t\t    saved_regs += vfp_emit_fstmx (start_reg,\n+\t\t    saved_regs += vfp_emit_fstmd (start_reg,\n \t\t\t\t\t\t  (reg - start_reg) / 2);\n \t\t  start_reg = reg + 2;\n \t\t}\n \t    }\n \t  if (start_reg != reg)\n-\t    saved_regs += vfp_emit_fstmx (start_reg,\n+\t    saved_regs += vfp_emit_fstmd (start_reg,\n \t\t\t\t\t  (reg - start_reg) / 2);\n \t}\n     }\n@@ -15407,12 +15407,12 @@ arm_unwind_emit_stm (FILE * asm_out_file, rtx p)\n \t  offset -= 4;\n \t}\n       reg_size = 4;\n+      fprintf (asm_out_file, \"\\t.save {\");\n     }\n   else if (IS_VFP_REGNUM (reg))\n     {\n-      /* FPA register saves use an additional word.  */\n-      offset -= 4;\n       reg_size = 8;\n+      fprintf (asm_out_file, \"\\t.vsave {\");\n     }\n   else if (reg >= FIRST_FPA_REGNUM && reg <= LAST_FPA_REGNUM)\n     {\n@@ -15429,8 +15429,6 @@ arm_unwind_emit_stm (FILE * asm_out_file, rtx p)\n   if (offset != nregs * reg_size)\n     abort ();\n \n-  fprintf (asm_out_file, \"\\t.save {\");\n-\n   offset = 0;\n   lastreg = 0;\n   /* The remaining insns will describe the stores.  */"}, {"sha": "fd66724da723b527fd451c0396ffb59ebcc0074c", "filename": "gcc/config/arm/libunwind.S", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8edfc4ccb46c6b8ccd48e7136d1ed5f5f646ff9a/gcc%2Fconfig%2Farm%2Flibunwind.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8edfc4ccb46c6b8ccd48e7136d1ed5f5f646ff9a/gcc%2Fconfig%2Farm%2Flibunwind.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Flibunwind.S?ref=8edfc4ccb46c6b8ccd48e7136d1ed5f5f646ff9a", "patch": "@@ -68,20 +68,46 @@ ARM_FUNC_START restore_core_regs\n \tFUNC_END restore_core_regs\n \tUNPREFIX restore_core_regs\n \n-/* Load VFP registers d0-d15 from the address in r0.  */\n+/* Load VFP registers d0-d15 from the address in r0.\n+   Use this to load from FSTMX format.  */\n ARM_FUNC_START gnu_Unwind_Restore_VFP\n \t/* Use the generic coprocessor form so that gas doesn't complain\n \t   on soft-float targets.  */\n \tldc   p11,cr0,[r0],{0x21} /* fldmiax r0, {d0-d15} */\n \tRET\n \n-/* Store VFR regsters d0-d15 to the address in r0.  */\n+/* Store VFP registers d0-d15 to the address in r0.\n+   Use this to store in FSTMX format.  */\n ARM_FUNC_START gnu_Unwind_Save_VFP\n \t/* Use the generic coprocessor form so that gas doesn't complain\n \t   on soft-float targets.  */\n \tstc   p11,cr0,[r0],{0x21} /* fstmiax r0, {d0-d15} */\n \tRET\n \n+/* Load VFP registers d0-d15 from the address in r0.\n+   Use this to load from FSTMD format.  */\n+ARM_FUNC_START gnu_Unwind_Restore_VFP_D\n+\tldc   p11,cr0,[r0],{0x20} /* fldmiad r0, {d0-d15} */\n+\tRET\n+\n+/* Store VFP registers d0-d15 to the address in r0.\n+   Use this to store in FLDMD format.  */\n+ARM_FUNC_START gnu_Unwind_Save_VFP_D\n+\tstc   p11,cr0,[r0],{0x20} /* fstmiad r0, {d0-d15} */\n+\tRET\n+\n+/* Load VFP registers d16-d31 from the address in r0.\n+   Use this to load from FSTMD (=VSTM) format.  Needs VFPv3.  */\n+ARM_FUNC_START gnu_Unwind_Restore_VFP_D_16_to_31\n+\tldcl  p11,cr0,[r0],{0x20} /* vldm r0, {d16-d31} */\n+\tRET\n+\n+/* Store VFP registers d16-d31 to the address in r0.\n+   Use this to store in FLDMD (=VLDM) format.  Needs VFPv3.  */\n+ARM_FUNC_START gnu_Unwind_Save_VFP_D_16_to_31\n+\tstcl  p11,cr0,[r0],{0x20} /* vstm r0, {d16-d31} */\n+\tRET\n+\n /* Wrappers to save core registers, then call the real routine.   */\n \n .macro  UNWIND_WRAPPER name nargs"}, {"sha": "b5592b192fcaeb8de14be7f1371af7ca999c88ea", "filename": "gcc/config/arm/pr-support.c", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8edfc4ccb46c6b8ccd48e7136d1ed5f5f646ff9a/gcc%2Fconfig%2Farm%2Fpr-support.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8edfc4ccb46c6b8ccd48e7136d1ed5f5f646ff9a/gcc%2Fconfig%2Farm%2Fpr-support.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fpr-support.c?ref=8edfc4ccb46c6b8ccd48e7136d1ed5f5f646ff9a", "patch": "@@ -282,13 +282,23 @@ __gnu_unwind_execute (_Unwind_Context * context, __gnu_unwind_state * uws)\n \t    }\n \t  if (op == 0xc8)\n \t    {\n-\t      /* Pop FPA registers.  */\n-\t      op = next_unwind_byte (uws);\n+#ifndef __VFP_FP__\n+ \t      /* Pop FPA registers.  */\n+ \t      op = next_unwind_byte (uws);\n \t      op = ((op & 0xf0) << 12) | ((op & 0xf) + 1);\n-\t      if (_Unwind_VRS_Pop (context, _UVRSC_FPA, op, _UVRSD_FPAX)\n-\t\t  != _UVRSR_OK)\n-\t\treturn _URC_FAILURE;\n-\t      continue;\n+ \t      if (_Unwind_VRS_Pop (context, _UVRSC_FPA, op, _UVRSD_FPAX)\n+ \t\t  != _UVRSR_OK)\n+ \t\treturn _URC_FAILURE;\n+ \t      continue;\n+#else\n+              /* Pop VFPv3 registers D[16+ssss]-D[16+ssss+cccc] with vldm.  */\n+              op = next_unwind_byte (uws);\n+              op = (((op & 0xf0) + 16) << 12) | ((op & 0xf) + 1);\n+              if (_Unwind_VRS_Pop (context, _UVRSC_VFP, op, _UVRSD_DOUBLE)\n+                  != _UVRSR_OK)\n+                return _URC_FAILURE;\n+              continue;\n+#endif\n \t    }\n \t  if (op == 0xc9)\n \t    {"}, {"sha": "4b75b0fe665f03a53c77cd03a63c534eb85c47c6", "filename": "gcc/config/arm/unwind-arm.c", "status": "modified", "additions": 122, "deletions": 16, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8edfc4ccb46c6b8ccd48e7136d1ed5f5f646ff9a/gcc%2Fconfig%2Farm%2Funwind-arm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8edfc4ccb46c6b8ccd48e7136d1ed5f5f646ff9a/gcc%2Fconfig%2Farm%2Funwind-arm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Funwind-arm.c?ref=8edfc4ccb46c6b8ccd48e7136d1ed5f5f646ff9a", "patch": "@@ -74,6 +74,13 @@ struct vfp_regs\n   _uw pad;\n };\n \n+struct vfpv3_regs\n+{\n+  /* Always populated via VSTM, so no need for the \"pad\" field from\n+     vfp_regs (which is used to store the format word for FSTMX).  */\n+  _uw64 d[16];\n+};\n+\n struct fpa_reg\n {\n   _uw w[3];\n@@ -114,10 +121,14 @@ typedef struct\n   struct core_regs core;\n   _uw prev_sp; /* Only valid during forced unwinding.  */\n   struct vfp_regs vfp;\n+  struct vfpv3_regs vfp_regs_16_to_31;\n   struct fpa_regs fpa;\n } phase1_vrs;\n \n-#define DEMAND_SAVE_VFP 1\n+#define DEMAND_SAVE_VFP 1\t/* VFP state has been saved if not set */\n+#define DEMAND_SAVE_VFP_D 2\t/* VFP state is for FLDMD/FSTMD if set */\n+#define DEMAND_SAVE_VFP_V3 4    /* VFPv3 state for regs 16 .. 31 has\n+                                   been saved if not set */\n \n /* This must match the structure created by the assembly wrappers.  */\n typedef struct\n@@ -143,15 +154,33 @@ void __attribute__((noreturn)) restore_core_regs (struct core_regs *);\n \n /* Coprocessor register state manipulation functions.  */\n \n+/* Routines for FLDMX/FSTMX format...  */\n void __gnu_Unwind_Save_VFP (struct vfp_regs * p);\n void __gnu_Unwind_Restore_VFP (struct vfp_regs * p);\n \n+/* ...and those for FLDMD/FSTMD format...  */\n+void __gnu_Unwind_Save_VFP_D (struct vfp_regs * p);\n+void __gnu_Unwind_Restore_VFP_D (struct vfp_regs * p);\n+\n+/* ...and those for VLDM/VSTM format, saving/restoring only registers\n+   16 through 31.  */\n+void __gnu_Unwind_Save_VFP_D_16_to_31 (struct vfpv3_regs * p);\n+void __gnu_Unwind_Restore_VFP_D_16_to_31 (struct vfpv3_regs * p);\n+\n /* Restore coprocessor state after phase1 unwinding.  */\n static void\n restore_non_core_regs (phase1_vrs * vrs)\n {\n   if ((vrs->demand_save_flags & DEMAND_SAVE_VFP) == 0)\n-    __gnu_Unwind_Restore_VFP (&vrs->vfp);\n+    {\n+      if (vrs->demand_save_flags & DEMAND_SAVE_VFP_D)\n+        __gnu_Unwind_Restore_VFP_D (&vrs->vfp);\n+      else\n+        __gnu_Unwind_Restore_VFP (&vrs->vfp);\n+    }\n+\n+  if ((vrs->demand_save_flags & DEMAND_SAVE_VFP_V3) == 0)\n+    __gnu_Unwind_Restore_VFP_D_16_to_31 (&vrs->vfp_regs_16_to_31);\n }\n \n /* A better way to do this would probably be to compare the absolute address\n@@ -274,43 +303,120 @@ _Unwind_VRS_Result _Unwind_VRS_Pop (_Unwind_Context *context,\n \t_uw start = discriminator >> 16;\n \t_uw count = discriminator & 0xffff;\n \tstruct vfp_regs tmp;\n+\tstruct vfpv3_regs tmp_16_to_31;\n+\tint tmp_count;\n \t_uw *sp;\n \t_uw *dest;\n+        int num_vfpv3_regs = 0;\n \n+        /* We use an approximation here by bounding _UVRSD_DOUBLE\n+           register numbers at 32 always, since we can't detect if\n+           VFPv3 isn't present (in such a case the upper limit is 16).  */\n \tif ((representation != _UVRSD_VFPX && representation != _UVRSD_DOUBLE)\n-\t    || start + count > 16)\n+            || start + count > (representation == _UVRSD_VFPX ? 16 : 32)\n+            || (representation == _UVRSD_VFPX && start >= 16))\n \t  return _UVRSR_FAILED;\n \n-\tif (vrs->demand_save_flags & DEMAND_SAVE_VFP)\n+        /* Check if we're being asked to pop VFPv3-only registers\n+           (numbers 16 through 31).  */\n+\tif (start >= 16)\n+          num_vfpv3_regs = count;\n+        else if (start + count > 16)\n+          num_vfpv3_regs = start + count - 16;\n+\n+        if (num_vfpv3_regs && representation != _UVRSD_DOUBLE)\n+          return _UVRSR_FAILED;\n+\n+\t/* Demand-save coprocessor registers for stage1.  */\n+\tif (start < 16 && (vrs->demand_save_flags & DEMAND_SAVE_VFP))\n \t  {\n-\t    /* Demand-save resisters for stage1.  */\n \t    vrs->demand_save_flags &= ~DEMAND_SAVE_VFP;\n-\t    __gnu_Unwind_Save_VFP (&vrs->vfp);\n+\n+            if (representation == _UVRSD_DOUBLE)\n+              {\n+                /* Save in FLDMD/FSTMD format.  */\n+\t        vrs->demand_save_flags |= DEMAND_SAVE_VFP_D;\n+\t        __gnu_Unwind_Save_VFP_D (&vrs->vfp);\n+              }\n+            else\n+              {\n+                /* Save in FLDMX/FSTMX format.  */\n+\t        vrs->demand_save_flags &= ~DEMAND_SAVE_VFP_D;\n+\t        __gnu_Unwind_Save_VFP (&vrs->vfp);\n+              }\n+\t  }\n+\n+        if (num_vfpv3_regs > 0\n+            && (vrs->demand_save_flags & DEMAND_SAVE_VFP_V3))\n+\t  {\n+\t    vrs->demand_save_flags &= ~DEMAND_SAVE_VFP_V3;\n+            __gnu_Unwind_Save_VFP_D_16_to_31 (&vrs->vfp_regs_16_to_31);\n \t  }\n \n \t/* Restore the registers from the stack.  Do this by saving the\n \t   current VFP registers to a memory area, moving the in-memory\n \t   values into that area, and restoring from the whole area.\n \t   For _UVRSD_VFPX we assume FSTMX standard format 1.  */\n-\t__gnu_Unwind_Save_VFP (&tmp);\n-\n-\t/* The stack address is only guaranteed to be word aligned, so\n+        if (representation == _UVRSD_VFPX)\n+  \t  __gnu_Unwind_Save_VFP (&tmp);\n+        else\n+          {\n+\t    /* Save registers 0 .. 15 if required.  */\n+            if (start < 16)\n+              __gnu_Unwind_Save_VFP_D (&tmp);\n+\n+\t    /* Save VFPv3 registers 16 .. 31 if required.  */\n+            if (num_vfpv3_regs)\n+  \t      __gnu_Unwind_Save_VFP_D_16_to_31 (&tmp_16_to_31);\n+          }\n+\n+\t/* Work out how many registers below register 16 need popping.  */\n+\ttmp_count = num_vfpv3_regs > 0 ? 16 - start : count;\n+\n+\t/* Copy registers below 16, if needed.\n+\t   The stack address is only guaranteed to be word aligned, so\n \t   we can't use doubleword copies.  */\n \tsp = (_uw *) vrs->core.r[R_SP];\n-\tdest = (_uw *) &tmp.d[start];\n-\tcount *= 2;\n-\twhile (count--)\n-\t  *(dest++) = *(sp++);\n-\n-\t/* Skip the pad word */\n+        if (tmp_count > 0)\n+          {\n+\t    tmp_count *= 2;\n+\t    dest = (_uw *) &tmp.d[start];\n+\t    while (tmp_count--)\n+\t      *(dest++) = *(sp++);\n+          }\n+\n+\t/* Copy VFPv3 registers numbered >= 16, if needed.  */\n+        if (num_vfpv3_regs > 0)\n+          {\n+            /* num_vfpv3_regs is needed below, so copy it.  */\n+            int tmp_count_2 = num_vfpv3_regs * 2;\n+            int vfpv3_start = start < 16 ? 16 : start;\n+\n+\t    dest = (_uw *) &tmp_16_to_31.d[vfpv3_start - 16];\n+\t    while (tmp_count_2--)\n+\t      *(dest++) = *(sp++);\n+          }\n+\n+\t/* Skip the format word space if using FLDMX/FSTMX format.  */\n \tif (representation == _UVRSD_VFPX)\n \t  sp++;\n \n \t/* Set the new stack pointer.  */\n \tvrs->core.r[R_SP] = (_uw) sp;\n \n \t/* Reload the registers.  */\n-\t__gnu_Unwind_Restore_VFP (&tmp);\n+        if (representation == _UVRSD_VFPX)\n+  \t  __gnu_Unwind_Restore_VFP (&tmp);\n+        else\n+          {\n+\t    /* Restore registers 0 .. 15 if required.  */\n+            if (start < 16)\n+              __gnu_Unwind_Restore_VFP_D (&tmp);\n+\n+\t    /* Restore VFPv3 registers 16 .. 31 if required.  */\n+            if (num_vfpv3_regs > 0)\n+  \t      __gnu_Unwind_Restore_VFP_D_16_to_31 (&tmp_16_to_31);\n+          }\n       }\n       return _UVRSR_OK;\n "}, {"sha": "6d4d017f14dc84b886b49a7ca50ed00b1b309b57", "filename": "gcc/config/arm/vfp.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8edfc4ccb46c6b8ccd48e7136d1ed5f5f646ff9a/gcc%2Fconfig%2Farm%2Fvfp.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8edfc4ccb46c6b8ccd48e7136d1ed5f5f646ff9a/gcc%2Fconfig%2Farm%2Fvfp.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fvfp.md?ref=8edfc4ccb46c6b8ccd48e7136d1ed5f5f646ff9a", "patch": "@@ -828,7 +828,7 @@\n \t  (unspec:BLK [(match_operand:DF 1 \"s_register_operand\" \"w\")]\n \t\t      UNSPEC_PUSH_MULT))])]\n   \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n-  \"* return vfp_output_fstmx (operands);\"\n+  \"* return vfp_output_fstmd (operands);\"\n   [(set_attr \"type\" \"f_stored\")]\n )\n "}]}