{"sha": "72c68d7ad90221075102f08f22256d0b4a7631b3", "node_id": "C_kwDOANBUbNoAKDcyYzY4ZDdhZDkwMjIxMDc1MTAyZjA4ZjIyMjU2ZDBiNGE3NjMxYjM", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2021-12-20T20:15:50Z"}, "committer": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2021-12-20T20:16:39Z"}, "message": "i386: Fix <sse2p4_1>_pinsr<ssemodesuffix> and its splitters [PR103772]\n\nThe clever trick to duplicate the value of the input operand into itself\nproved not so clever after all.  The splitter should not clobber the input\noperand in any case, since the register can hold the value outside the HImode\nlowpart when accessed as subreg.  Use the standard earlyclobber approach\ninstead.\n\nThe testcase fails with avx2 ISA, but I was not able to create the testcase\nthat wouldn't require -mavx512fp16 compile flag.\n\n2021-12-20  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n\ngcc/ChangeLog:\n\n\tPR target/103772\n\t* config/i386/sse.md (<sse2p4_1>_pinsr<ssemodesuffix>): Add\n\tearlyclobber to (x,x,x,i) alternative.\n\t(<sse2p4_1>_pinsr<ssemodesuffix> peephole2): Remove.\n\t(<sse2p4_1>_pinsr<ssemodesuffix> splitter): Use output\n\toperand as a temporary register.  Split after reload_completed.", "tree": {"sha": "201ad2daa9fc9a829011d04b414ac16e28ad7ac9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/201ad2daa9fc9a829011d04b414ac16e28ad7ac9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/72c68d7ad90221075102f08f22256d0b4a7631b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72c68d7ad90221075102f08f22256d0b4a7631b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72c68d7ad90221075102f08f22256d0b4a7631b3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72c68d7ad90221075102f08f22256d0b4a7631b3/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ab85331c58223e483c55ff0316a92265d7910e9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab85331c58223e483c55ff0316a92265d7910e9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab85331c58223e483c55ff0316a92265d7910e9b"}], "stats": {"total": 31, "additions": 4, "deletions": 27}, "files": [{"sha": "cb1c0b1edece94c0080ee416a7dd4d9a597c3dc7", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 4, "deletions": 27, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72c68d7ad90221075102f08f22256d0b4a7631b3/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72c68d7ad90221075102f08f22256d0b4a7631b3/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=72c68d7ad90221075102f08f22256d0b4a7631b3", "patch": "@@ -17430,7 +17430,7 @@\n \n ;; sse4_1_pinsrd must come before sse2_loadld since it is preferred.\n (define_insn \"<sse2p4_1>_pinsr<ssemodesuffix>\"\n-  [(set (match_operand:PINSR_MODE 0 \"register_operand\" \"=x,x,x,x,v,v,x\")\n+  [(set (match_operand:PINSR_MODE 0 \"register_operand\" \"=x,x,x,x,v,v,&x\")\n \t(vec_merge:PINSR_MODE\n \t  (vec_duplicate:PINSR_MODE\n \t    (match_operand:<ssescalarmode> 2 \"nonimmediate_operand\" \"r,m,r,m,r,m,x\"))\n@@ -17499,44 +17499,21 @@\n \t   (const_string \"*\")))])\n \n ;; For TARGET_AVX2, implement insert from XMM reg with PBROADCASTW + PBLENDW.\n-;; First try to get a scratch register and go through it.  In case this fails,\n-;; overwrite source reg with broadcasted value and blend from there.\n-(define_peephole2\n-  [(match_scratch:V8_128 4 \"x\")\n-   (set (match_operand:V8_128 0 \"sse_reg_operand\")\n-\t(vec_merge:V8_128\n-\t  (vec_duplicate:V8_128\n-\t    (match_operand:<ssescalarmode> 2 \"sse_reg_operand\"))\n-\t  (match_operand:V8_128 1 \"sse_reg_operand\")\n-\t  (match_operand:SI 3 \"const_int_operand\")))]\n-  \"TARGET_AVX2\n-   && INTVAL (operands[3]) > 1\n-   && ((unsigned) exact_log2 (INTVAL (operands[3]))\n-       < GET_MODE_NUNITS (<MODE>mode))\"\n-  [(set (match_dup 4)\n-\t(vec_duplicate:V8_128 (match_dup 2)))\n-   (set (match_dup 0)\n-\t(vec_merge:V8_128 (match_dup 4) (match_dup 1) (match_dup 3)))])\n-\n (define_split\n   [(set (match_operand:V8_128 0 \"sse_reg_operand\")\n \t(vec_merge:V8_128\n \t  (vec_duplicate:V8_128\n \t    (match_operand:<ssescalarmode> 2 \"sse_reg_operand\"))\n \t  (match_operand:V8_128 1 \"sse_reg_operand\")\n \t  (match_operand:SI 3 \"const_int_operand\")))]\n-  \"TARGET_AVX2 && epilogue_completed\n+  \"TARGET_AVX2 && reload_completed\n    && INTVAL (operands[3]) > 1\n    && ((unsigned) exact_log2 (INTVAL (operands[3]))\n        < GET_MODE_NUNITS (<MODE>mode))\"\n-  [(set (match_dup 4)\n+  [(set (match_dup 0)\n \t(vec_duplicate:V8_128 (match_dup 2)))\n    (set (match_dup 0)\n-\t(vec_merge:V8_128 (match_dup 4) (match_dup 1) (match_dup 3)))]\n-{\n-  operands[4] = lowpart_subreg (<MODE>mode, operands[2],\n-\t\t\t\t<ssescalarmode>mode);\n-})\n+\t(vec_merge:V8_128 (match_dup 0) (match_dup 1) (match_dup 3)))])\n \n (define_expand \"<extract_type>_vinsert<shuffletype><extract_suf>_mask\"\n   [(match_operand:AVX512_VEC 0 \"register_operand\")"}]}