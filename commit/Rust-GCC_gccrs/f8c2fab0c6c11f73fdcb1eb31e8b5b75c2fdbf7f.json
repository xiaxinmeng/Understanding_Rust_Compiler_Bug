{"sha": "f8c2fab0c6c11f73fdcb1eb31e8b5b75c2fdbf7f", "node_id": "C_kwDOANBUbNoAKGY4YzJmYWIwYzZjMTFmNzNmZGNiMWViMzFlOGI1Yjc1YzJmZGJmN2Y", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-11-01T17:29:07Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-11-01T17:29:07Z"}, "message": "Merge #1622\n\n1622: intrinsics: Add atomic_load_* r=CohenArthur a=CohenArthur\n\n\n\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>", "tree": {"sha": "c93249a504a5b3fa3cf21daaa3d1402f4fe19fc5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c93249a504a5b3fa3cf21daaa3d1402f4fe19fc5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f8c2fab0c6c11f73fdcb1eb31e8b5b75c2fdbf7f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjYVdjCRBK7hj4Ov3rIwAAy/AIAEBFRVU/0dQdImic8ij22nVp\n7EZJ+AOazRLSWcCpbfY7WyxglpozHUfuajsre5DI4rTZIx5R/GXL0qPQ+7/cgV0F\nVxe0bvy+pjZcZO5eox6AzCXuSy6gtb1OHdWdG8SsVw53FejsjG5WkiPG+JI7X7Px\nbK6UUfhajrPlWimTJ8Qz23j870hbhh6o4DxP/kx+T57OwBvWgF25FO+tvKi4mwNN\n25uMdxMf8yNtBFz31/Ai4sIrYELPjf3NCTghSVImT/17raXI+IYvY1dB08MNANAF\n4Zz4bU5ItUqlWANTvmi2Rg99j6Rbuz/sesVD7RoOOLF0foKkMj+gTI2WheOYgQw=\n=cCMA\n-----END PGP SIGNATURE-----\n", "payload": "tree c93249a504a5b3fa3cf21daaa3d1402f4fe19fc5\nparent d8de1df88400156beb443726de229e6503d4af29\nparent b0bde7e2b5bafb111552e634b520cd908a767554\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1667323747 +0000\ncommitter GitHub <noreply@github.com> 1667323747 +0000\n\nMerge #1622\n\n1622: intrinsics: Add atomic_load_* r=CohenArthur a=CohenArthur\n\n\n\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8c2fab0c6c11f73fdcb1eb31e8b5b75c2fdbf7f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8c2fab0c6c11f73fdcb1eb31e8b5b75c2fdbf7f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8c2fab0c6c11f73fdcb1eb31e8b5b75c2fdbf7f/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d8de1df88400156beb443726de229e6503d4af29", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8de1df88400156beb443726de229e6503d4af29", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8de1df88400156beb443726de229e6503d4af29"}, {"sha": "b0bde7e2b5bafb111552e634b520cd908a767554", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0bde7e2b5bafb111552e634b520cd908a767554", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0bde7e2b5bafb111552e634b520cd908a767554"}], "stats": {"total": 227, "additions": 172, "deletions": 55}, "files": [{"sha": "66b3becc47a217e153aad8c7686c436f29d1301a", "filename": "gcc/rust/backend/rust-builtins.cc", "status": "modified", "additions": 31, "deletions": 25, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8c2fab0c6c11f73fdcb1eb31e8b5b75c2fdbf7f/gcc%2Frust%2Fbackend%2Frust-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8c2fab0c6c11f73fdcb1eb31e8b5b75c2fdbf7f/gcc%2Frust%2Fbackend%2Frust-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-builtins.cc?ref=f8c2fab0c6c11f73fdcb1eb31e8b5b75c2fdbf7f", "patch": "@@ -71,36 +71,42 @@ BuiltinsContext::setup_math_fns ()\n void\n BuiltinsContext::setup_atomic_fns ()\n {\n-  define_builtin (\"atomic_store\", BUILT_IN_ATOMIC_STORE, \"__atomic_store\", NULL,\n-\t\t  build_function_type_list (void_type_node, size_type_node,\n-\t\t\t\t\t    build_pointer_type (void_type_node),\n-\t\t\t\t\t    const_ptr_type_node,\n-\t\t\t\t\t    integer_type_node, NULL_TREE),\n-\t\t  0);\n-  define_builtin (\"atomic_store_n\", BUILT_IN_ATOMIC_STORE_N, \"__atomic_store_n\",\n-\t\t  NULL,\n-\t\t  build_varargs_function_type_list (void_type_node, NULL_TREE),\n-\t\t  0);\n+  auto atomic_store_type\n+    = build_varargs_function_type_list (void_type_node, NULL_TREE);\n+  auto atomic_load_type = [] (tree ret_type_node) {\n+    return build_function_type_list (ret_type_node,\n+\t\t\t\t     ptr_type_node, // const_ptr_type_node?\n+\t\t\t\t     integer_type_node, NULL_TREE);\n+  };\n+\n+  // FIXME: These should be the definition for the generic version of the\n+  // atomic_store builtins, but I cannot get them to work properly. Revisit\n+  // later. define_builtin (\"atomic_store\", BUILT_IN_ATOMIC_STORE,\n+  // \"__atomic_store\", NULL,\n+  //   atomic_store_type, 0);\n+  // define_builtin (\"atomic_store_n\", BUILT_IN_ATOMIC_STORE_N,\n+  // \"__atomic_store_n\",\n+  //   NULL, atomic_store_type, 0);\n+\n   define_builtin (\"atomic_store_1\", BUILT_IN_ATOMIC_STORE_1, \"__atomic_store_1\",\n-\t\t  NULL,\n-\t\t  build_varargs_function_type_list (void_type_node, NULL_TREE),\n-\t\t  0);\n+\t\t  NULL, atomic_store_type, 0);\n   define_builtin (\"atomic_store_2\", BUILT_IN_ATOMIC_STORE_2, \"__atomic_store_2\",\n-\t\t  NULL,\n-\t\t  build_varargs_function_type_list (void_type_node, NULL_TREE),\n-\t\t  0);\n+\t\t  NULL, atomic_store_type, 0);\n   define_builtin (\"atomic_store_4\", BUILT_IN_ATOMIC_STORE_4, \"__atomic_store_4\",\n-\t\t  NULL,\n-\t\t  build_varargs_function_type_list (void_type_node, NULL_TREE),\n-\t\t  0);\n+\t\t  NULL, atomic_store_type, 0);\n   define_builtin (\"atomic_store_8\", BUILT_IN_ATOMIC_STORE_8, \"__atomic_store_8\",\n-\t\t  NULL,\n-\t\t  build_varargs_function_type_list (void_type_node, NULL_TREE),\n-\t\t  0);\n+\t\t  NULL, atomic_store_type, 0);\n   define_builtin (\"atomic_store_16\", BUILT_IN_ATOMIC_STORE_16,\n-\t\t  \"__atomic_store_16\", NULL,\n-\t\t  build_varargs_function_type_list (void_type_node, NULL_TREE),\n-\t\t  0);\n+\t\t  \"__atomic_store_16\", NULL, atomic_store_type, 0);\n+\n+  define_builtin (\"atomic_load_1\", BUILT_IN_ATOMIC_LOAD_1, \"__atomic_load_1\",\n+\t\t  NULL, atomic_load_type (integer_type_node), 0);\n+  define_builtin (\"atomic_load_2\", BUILT_IN_ATOMIC_LOAD_2, \"__atomic_load_2\",\n+\t\t  NULL, atomic_load_type (integer_type_node), 0);\n+  define_builtin (\"atomic_load_4\", BUILT_IN_ATOMIC_LOAD_4, \"__atomic_load_4\",\n+\t\t  NULL, atomic_load_type (integer_type_node), 0);\n+  define_builtin (\"atomic_load_8\", BUILT_IN_ATOMIC_LOAD_8, \"__atomic_load_8\",\n+\t\t  NULL, atomic_load_type (integer_type_node), 0);\n }\n \n void"}, {"sha": "552221163666196566846b71e514c02bf0dccf2e", "filename": "gcc/rust/backend/rust-compile-intrinsic.cc", "status": "modified", "additions": 108, "deletions": 26, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8c2fab0c6c11f73fdcb1eb31e8b5b75c2fdbf7f/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8c2fab0c6c11f73fdcb1eb31e8b5b75c2fdbf7f/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.cc?ref=f8c2fab0c6c11f73fdcb1eb31e8b5b75c2fdbf7f", "patch": "@@ -50,6 +50,22 @@ is_basic_integer_type (TyTy::BaseType *type)\n     }\n }\n \n+static bool\n+check_for_basic_integer_type (const std::string &intrinsic_str, Location locus,\n+\t\t\t      TyTy::BaseType *type)\n+{\n+  auto is_basic_integer = is_basic_integer_type (type);\n+  if (!is_basic_integer)\n+    {\n+      rust_error_at (\n+\tlocus,\n+\t\"%s intrinsics can only be used with basic integer types (got %qs)\",\n+\tintrinsic_str.c_str (), type->get_name ().c_str ());\n+    }\n+\n+  return is_basic_integer;\n+}\n+\n static tree\n offset_handler (Context *ctx, TyTy::FnType *fntype);\n static tree\n@@ -104,6 +120,8 @@ prefetch_write_data (Context *ctx, TyTy::FnType *fntype)\n \n static tree\n atomic_store_handler_inner (Context *ctx, TyTy::FnType *fntype, int ordering);\n+static tree\n+atomic_load_handler_inner (Context *ctx, TyTy::FnType *fntype, int ordering);\n \n static inline std::function<tree (Context *, TyTy::FnType *)>\n atomic_store_handler (int ordering)\n@@ -113,6 +131,14 @@ atomic_store_handler (int ordering)\n   };\n }\n \n+static inline std::function<tree (Context *, TyTy::FnType *)>\n+atomic_load_handler (int ordering)\n+{\n+  return [ordering] (Context *ctx, TyTy::FnType *fntype) {\n+    return atomic_load_handler_inner (ctx, fntype, ordering);\n+  };\n+}\n+\n static inline tree\n unchecked_op_inner (Context *ctx, TyTy::FnType *fntype, tree_code op);\n \n@@ -124,7 +150,7 @@ unchecked_op_handler (tree_code op)\n   };\n }\n \n-static inline tree\n+inline tree\n sorry_handler (Context *ctx, TyTy::FnType *fntype)\n {\n   rust_sorry_at (fntype->get_locus (), \"intrinsic %qs is not yet implemented\",\n@@ -147,11 +173,14 @@ static const std::map<std::string,\n     {\"copy_nonoverlapping\", copy_nonoverlapping_handler},\n     {\"prefetch_read_data\", prefetch_read_data},\n     {\"prefetch_write_data\", prefetch_write_data},\n-    {\"atomic_load\", sorry_handler},\n     {\"atomic_store_seqcst\", atomic_store_handler (__ATOMIC_SEQ_CST)},\n     {\"atomic_store_release\", atomic_store_handler (__ATOMIC_RELEASE)},\n     {\"atomic_store_relaxed\", atomic_store_handler (__ATOMIC_RELAXED)},\n     {\"atomic_store_unordered\", atomic_store_handler (__ATOMIC_RELAXED)},\n+    {\"atomic_load_seqcst\", atomic_load_handler (__ATOMIC_SEQ_CST)},\n+    {\"atomic_load_acquire\", atomic_load_handler (__ATOMIC_ACQUIRE)},\n+    {\"atomic_load_relaxed\", atomic_load_handler (__ATOMIC_RELAXED)},\n+    {\"atomic_load_unordered\", atomic_load_handler (__ATOMIC_RELAXED)},\n     {\"unchecked_add\", unchecked_op_handler (PLUS_EXPR)},\n     {\"unchecked_sub\", unchecked_op_handler (MINUS_EXPR)},\n     {\"unchecked_mul\", unchecked_op_handler (MULT_EXPR)},\n@@ -652,7 +681,8 @@ prefetch_data_handler (Context *ctx, TyTy::FnType *fntype, Prefetch kind)\n }\n \n static std::string\n-build_atomic_builtin_name (Location locus, tree operand_type)\n+build_atomic_builtin_name (const std::string &prefix, Location locus,\n+\t\t\t   TyTy::BaseType *operand_type)\n {\n   static const std::map<std::string, std::string> allowed_types = {\n     {\"i8\", \"1\"},    {\"i16\", \"2\"},   {\"i32\", \"4\"},   {\"i64\", \"8\"},\n@@ -663,31 +693,20 @@ build_atomic_builtin_name (Location locus, tree operand_type)\n   // TODO: Can we maybe get the generic version (atomic_store_n) to work... This\n   // would be so much better\n \n-  std::string result = \"atomic_store_\";\n+  std::string result = prefix;\n \n-  auto type_name = std::string (TYPE_NAME_STRING (operand_type));\n+  auto type_name = operand_type->get_name ();\n   if (type_name == \"usize\" || type_name == \"isize\")\n     {\n       rust_sorry_at (\n \tlocus, \"atomics are not yet available for size types (usize, isize)\");\n       return \"\";\n     }\n \n-  // FIXME: Can we have a better looking name here?\n-  // Instead of `<crate>::<module>::<type>`?\n-  // Maybe instead of giving the tree node, pass the resolved Tyty before it\n-  // gets compiled?\n-  //\n-  // Or should we perform this check somwhere else in the compiler?\n   auto type_size_str = allowed_types.find (type_name);\n-  if (type_size_str == allowed_types.end ())\n-    {\n-      rust_error_at (locus,\n-\t\t     \"atomic intrinsics are only available for basic integer \"\n-\t\t     \"types: got type %qs\",\n-\t\t     type_name.c_str ());\n-      return \"\";\n-    }\n+\n+  if (!check_for_basic_integer_type (\"atomic\", locus, operand_type))\n+    return \"\";\n \n   result += type_size_str->second;\n \n@@ -726,8 +745,12 @@ atomic_store_handler_inner (Context *ctx, TyTy::FnType *fntype, int ordering)\n   auto value = ctx->get_backend ()->var_expression (param_vars[1], Location ());\n   auto memorder = make_unsigned_long_tree (ctx, ordering);\n \n+  auto monomorphized_type\n+    = fntype->get_substs ()[0].get_param_ty ()->resolve ();\n+\n   auto builtin_name\n-    = build_atomic_builtin_name (fntype->get_locus (), TREE_TYPE (types[0]));\n+    = build_atomic_builtin_name (\"atomic_store_\", fntype->get_locus (),\n+\t\t\t\t monomorphized_type);\n   if (builtin_name.empty ())\n     return error_mark_node;\n \n@@ -743,7 +766,6 @@ atomic_store_handler_inner (Context *ctx, TyTy::FnType *fntype, int ordering)\n     = ctx->get_backend ()->call_expression (atomic_store,\n \t\t\t\t\t    {dst, value, memorder}, nullptr,\n \t\t\t\t\t    Location ());\n-\n   TREE_READONLY (store_call) = 0;\n   TREE_SIDE_EFFECTS (store_call) = 1;\n \n@@ -753,6 +775,68 @@ atomic_store_handler_inner (Context *ctx, TyTy::FnType *fntype, int ordering)\n   return fndecl;\n }\n \n+static tree\n+atomic_load_handler_inner (Context *ctx, TyTy::FnType *fntype, int ordering)\n+{\n+  rust_assert (fntype->get_params ().size () == 1);\n+  rust_assert (fntype->get_num_substitutions () == 1);\n+\n+  tree lookup = NULL_TREE;\n+  if (check_for_cached_intrinsic (ctx, fntype, &lookup))\n+    return lookup;\n+\n+  auto fndecl = compile_intrinsic_function (ctx, fntype);\n+\n+  // Most intrinsic functions are pure but not the atomic ones\n+  // FIXME: Is atomic_load_* pure? Feels like it shouldn't so\n+  TREE_READONLY (fndecl) = 0;\n+  TREE_SIDE_EFFECTS (fndecl) = 1;\n+\n+  // setup the params\n+  std::vector<Bvariable *> param_vars;\n+  std::vector<tree> types;\n+  compile_fn_params (ctx, fntype, fndecl, &param_vars, &types);\n+\n+  auto ok = ctx->get_backend ()->function_set_parameters (fndecl, param_vars);\n+  rust_assert (ok);\n+\n+  enter_intrinsic_block (ctx, fndecl);\n+\n+  auto src = ctx->get_backend ()->var_expression (param_vars[0], Location ());\n+  auto memorder = make_unsigned_long_tree (ctx, ordering);\n+\n+  auto monomorphized_type\n+    = fntype->get_substs ()[0].get_param_ty ()->resolve ();\n+\n+  auto builtin_name\n+    = build_atomic_builtin_name (\"atomic_load_\", fntype->get_locus (),\n+\t\t\t\t monomorphized_type);\n+  if (builtin_name.empty ())\n+    return error_mark_node;\n+\n+  tree atomic_load_raw = nullptr;\n+  BuiltinsContext::get ().lookup_simple_builtin (builtin_name,\n+\t\t\t\t\t\t &atomic_load_raw);\n+  rust_assert (atomic_load_raw);\n+\n+  auto atomic_load\n+    = build_fold_addr_expr_loc (Location ().gcc_location (), atomic_load_raw);\n+\n+  auto load_call\n+    = ctx->get_backend ()->call_expression (atomic_load, {src, memorder},\n+\t\t\t\t\t    nullptr, Location ());\n+  auto return_statement\n+    = ctx->get_backend ()->return_statement (fndecl, {load_call}, Location ());\n+\n+  TREE_READONLY (load_call) = 0;\n+  TREE_SIDE_EFFECTS (load_call) = 1;\n+\n+  ctx->add_statement (return_statement);\n+  finalize_intrinsic_block (ctx, fndecl);\n+\n+  return fndecl;\n+}\n+\n static inline tree\n unchecked_op_inner (Context *ctx, TyTy::FnType *fntype, tree_code op)\n {\n@@ -781,11 +865,9 @@ unchecked_op_inner (Context *ctx, TyTy::FnType *fntype, tree_code op)\n \n   auto *monomorphized_type\n     = fntype->get_substs ().at (0).get_param_ty ()->resolve ();\n-  if (!is_basic_integer_type (monomorphized_type))\n-    rust_error_at (fntype->get_locus (),\n-\t\t   \"unchecked operation intrinsics can only be used with \"\n-\t\t   \"basic integer types (got %qs)\",\n-\t\t   monomorphized_type->get_name ().c_str ());\n+\n+  check_for_basic_integer_type (\"unchecked operation\", fntype->get_locus (),\n+\t\t\t\tmonomorphized_type);\n \n   auto expr = build2 (op, TREE_TYPE (x), x, y);\n   auto return_statement"}, {"sha": "5c131bd8aa290f94aebd730b1463e80f9aa78373", "filename": "gcc/testsuite/rust/compile/torture/intrinsics-3.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8c2fab0c6c11f73fdcb1eb31e8b5b75c2fdbf7f/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fintrinsics-3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8c2fab0c6c11f73fdcb1eb31e8b5b75c2fdbf7f/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fintrinsics-3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fintrinsics-3.rs?ref=f8c2fab0c6c11f73fdcb1eb31e8b5b75c2fdbf7f", "patch": "@@ -1,9 +1,7 @@\n extern \"rust-intrinsic\" {\n     fn not_an_intrinsic();\n-    fn atomic_load(); // { dg-message \"sorry, unimplemented: intrinsic .atomic_load. is not yet implemented\" }\n }\n \n fn main() {\n     unsafe { not_an_intrinsic() }; // { dg-error \"unknown builtin intrinsic: not_an_intrinsic\" }\n-    unsafe { atomic_load() };\n }"}, {"sha": "7fd84dcd63586c41ef97ae068d7099a0647947e7", "filename": "gcc/testsuite/rust/compile/torture/intrinsics-5.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8c2fab0c6c11f73fdcb1eb31e8b5b75c2fdbf7f/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fintrinsics-5.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8c2fab0c6c11f73fdcb1eb31e8b5b75c2fdbf7f/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fintrinsics-5.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fintrinsics-5.rs?ref=f8c2fab0c6c11f73fdcb1eb31e8b5b75c2fdbf7f", "patch": "@@ -2,8 +2,8 @@ trait Copy {}\n \n extern \"rust-intrinsic\" {\n     pub fn atomic_store_seqcst<T: Copy>(dst: *mut T, value: T);\n-    // { dg-error \"atomic intrinsics are only available for basic integer types: got type .intrinsics_5::VeryLargeType.\" \"\" { target *-*-* } .-1 }\n-    // { dg-error \"atomic intrinsics are only available for basic integer types: got type .bool.\" \"\" { target *-*-* } .-2 }\n+    // { dg-error \"atomic intrinsics can only be used with basic integer types .got .VeryLargeType..\" \"\" { target *-*-* } .-1 }\n+    // { dg-error \"atomic intrinsics can only be used with basic integer types .got .bool..\" \"\" { target *-*-* } .-2 }\n }\n \n struct VeryLargeType {"}, {"sha": "28ed8ae78f12023f0f40e3a7c100cec74b73f19d", "filename": "gcc/testsuite/rust/execute/torture/atomic_load.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8c2fab0c6c11f73fdcb1eb31e8b5b75c2fdbf7f/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fatomic_load.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8c2fab0c6c11f73fdcb1eb31e8b5b75c2fdbf7f/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fatomic_load.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fatomic_load.rs?ref=f8c2fab0c6c11f73fdcb1eb31e8b5b75c2fdbf7f", "patch": "@@ -0,0 +1,31 @@\n+trait Copy {}\n+\n+extern \"rust-intrinsic\" {\n+    pub fn atomic_load_seqcst<T: Copy>(src: *const T) -> T;\n+    pub fn atomic_load_acquire<T: Copy>(src: *const T) -> T;\n+    pub fn atomic_load_relaxed<T: Copy>(src: *const T) -> T;\n+    pub fn atomic_load_unordered<T: Copy>(src: *const T) -> T;\n+}\n+\n+fn main() -> i32 {\n+    let one;\n+    let two;\n+    let three;\n+    let four;\n+\n+    unsafe {\n+        let mut src = 1;\n+        one = atomic_load_seqcst(&src);\n+\n+        src = 2;\n+        two = atomic_load_acquire(&src);\n+\n+        src = 3;\n+        three = atomic_load_relaxed(&src);\n+\n+        src = 4;\n+        four = atomic_load_unordered(&src);\n+    }\n+\n+    (four + three + two + one) - 10\n+}"}]}