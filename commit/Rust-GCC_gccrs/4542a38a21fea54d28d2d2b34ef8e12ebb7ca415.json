{"sha": "4542a38a21fea54d28d2d2b34ef8e12ebb7ca415", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDU0MmEzOGEyMWZlYTU0ZDI4ZDJkMmIzNGVmOGUxMmViYjdjYTQxNQ==", "commit": {"author": {"name": "Greta Yorsh", "email": "greta.yorsh@arm.com", "date": "2013-04-05T17:26:12Z"}, "committer": {"name": "Greta Yorsh", "email": "gretay@gcc.gnu.org", "date": "2013-04-05T17:26:12Z"}, "message": "peep-ldrd-1.c: New test.\n\n2013-04-05  Greta Yorsh  <Greta.Yorsh@arm.com>\n\ngcc/testsuite\n\n\t* gcc.target/arm/peep-ldrd-1.c: New test.\n\t* gcc.target/arm/peep-strd-1.c: Likewise.\n\ngcc/\n\t* config/arm/constraints.md (q): New constraint.\n\t* config/arm/ldrdstrd.md: New file.\n\t* config/arm/arm.md (ldrdstrd.md) New include.\n\t(arm_movdi): Use \"q\" instead of \"r\" constraint\n\tfor double-word memory access.\n\t(movdf_soft_insn): Likewise.\n\t* config/arm/vfp.md (movdi_vfp): Likewise.\n\t* config/arm/t-arm (MD_INCLUDES): Add ldrdstrd.md.\n        * config/arm/arm-protos.h (gen_operands_ldrd_strd): New declaration.\n\t* config/arm/arm.c (gen_operands_ldrd_strd): New function.\n\t(mem_ok_for_ldrd_strd): Likewise.\n\t(output_move_double): Update assertion.\n\nFrom-SVN: r197530", "tree": {"sha": "372372b89c0e359b781b42285cc48fa5324b4f47", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/372372b89c0e359b781b42285cc48fa5324b4f47"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4542a38a21fea54d28d2d2b34ef8e12ebb7ca415", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4542a38a21fea54d28d2d2b34ef8e12ebb7ca415", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4542a38a21fea54d28d2d2b34ef8e12ebb7ca415", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4542a38a21fea54d28d2d2b34ef8e12ebb7ca415/comments", "author": null, "committer": null, "parents": [{"sha": "2385b218b2157281f844a5f58239f15a6db49a33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2385b218b2157281f844a5f58239f15a6db49a33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2385b218b2157281f844a5f58239f15a6db49a33"}], "stats": {"total": 596, "additions": 588, "deletions": 8}, "files": [{"sha": "1412a6ac87ab0a0d49ad1a9fec5da6e8dedf7fb9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4542a38a21fea54d28d2d2b34ef8e12ebb7ca415/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4542a38a21fea54d28d2d2b34ef8e12ebb7ca415/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4542a38a21fea54d28d2d2b34ef8e12ebb7ca415", "patch": "@@ -1,3 +1,18 @@\n+2013-04-05  Greta Yorsh  <Greta.Yorsh@arm.com>\n+\n+\t* config/arm/constraints.md (q): New constraint.\n+\t* config/arm/ldrdstrd.md: New file.\n+\t* config/arm/arm.md (ldrdstrd.md) New include.\n+\t(arm_movdi): Use \"q\" instead of \"r\" constraint\n+\tfor double-word memory access.\n+\t(movdf_soft_insn): Likewise.\n+\t* config/arm/vfp.md (movdi_vfp): Likewise.\n+\t* config/arm/t-arm (MD_INCLUDES): Add ldrdstrd.md.\n+        * config/arm/arm-protos.h (gen_operands_ldrd_strd): New declaration.\n+\t* config/arm/arm.c (gen_operands_ldrd_strd): New function.\n+\t(mem_ok_for_ldrd_strd): Likewise.\n+\t(output_move_double): Update assertion.\n+\n 2013-04-05  Greta Yorsh  <Greta.Yorsh@arm.com>\n \n \t* config/arm/arm.md: Comment on splitting Thumb1 patterns."}, {"sha": "a6af92757128cd644eefb68936a4172731229e32", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4542a38a21fea54d28d2d2b34ef8e12ebb7ca415/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4542a38a21fea54d28d2d2b34ef8e12ebb7ca415/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=4542a38a21fea54d28d2d2b34ef8e12ebb7ca415", "patch": "@@ -118,6 +118,7 @@ extern rtx arm_gen_load_multiple (int *, int, rtx, int, rtx, HOST_WIDE_INT *);\n extern rtx arm_gen_store_multiple (int *, int, rtx, int, rtx, HOST_WIDE_INT *);\n extern bool offset_ok_for_ldrd_strd (HOST_WIDE_INT);\n extern bool operands_ok_ldrd_strd (rtx, rtx, rtx, HOST_WIDE_INT, bool, bool);\n+extern bool gen_operands_ldrd_strd (rtx *, bool, bool, bool);\n extern int arm_gen_movmemqi (rtx *);\n extern enum machine_mode arm_select_cc_mode (RTX_CODE, rtx, rtx);\n extern enum machine_mode arm_select_dominance_cc_mode (rtx, rtx,"}, {"sha": "af95ac1d40799d0d023aaaca7bd9d68c305b98a8", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 273, "deletions": 1, "changes": 274, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4542a38a21fea54d28d2d2b34ef8e12ebb7ca415/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4542a38a21fea54d28d2d2b34ef8e12ebb7ca415/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=4542a38a21fea54d28d2d2b34ef8e12ebb7ca415", "patch": "@@ -12636,6 +12636,277 @@ operands_ok_ldrd_strd (rtx rt, rtx rt2, rtx rn, HOST_WIDE_INT offset,\n   return true;\n }\n \n+/* Helper for gen_operands_ldrd_strd.  Returns true iff the memory\n+   operand ADDR is an immediate offset from the base register and is\n+   not volatile, in which case it sets BASE and OFFSET\n+   accordingly.  */\n+bool\n+mem_ok_for_ldrd_strd (rtx addr, rtx *base, rtx *offset)\n+{\n+  /* TODO: Handle more general memory operand patterns, such as\n+     PRE_DEC and PRE_INC.  */\n+\n+  /* Convert a subreg of mem into mem itself.  */\n+  if (GET_CODE (addr) == SUBREG)\n+    addr = alter_subreg (&addr, true);\n+\n+  gcc_assert (MEM_P (addr));\n+\n+  /* Don't modify volatile memory accesses.  */\n+  if (MEM_VOLATILE_P (addr))\n+    return false;\n+\n+  *offset = const0_rtx;\n+\n+  addr = XEXP (addr, 0);\n+  if (REG_P (addr))\n+    {\n+      *base = addr;\n+      return true;\n+    }\n+  else if (GET_CODE (addr) == PLUS || GET_CODE (addr) == MINUS)\n+    {\n+      *base = XEXP (addr, 0);\n+      *offset = XEXP (addr, 1);\n+      return (REG_P (*base) && CONST_INT_P (*offset));\n+    }\n+\n+  return false;\n+}\n+\n+#define SWAP_RTX(x,y) do { rtx tmp = x; x = y; y = tmp; } while (0)\n+\n+/* Called from a peephole2 to replace two word-size accesses with a\n+   single LDRD/STRD instruction.  Returns true iff we can generate a\n+   new instruction sequence.  That is, both accesses use the same base\n+   register and the gap between constant offsets is 4.  This function\n+   may reorder its operands to match ldrd/strd RTL templates.\n+   OPERANDS are the operands found by the peephole matcher;\n+   OPERANDS[0,1] are register operands, and OPERANDS[2,3] are the\n+   corresponding memory operands.  LOAD indicaates whether the access\n+   is load or store.  CONST_STORE indicates a store of constant\n+   integer values held in OPERANDS[4,5] and assumes that the pattern\n+   is of length 4 insn, for the purpose of checking dead registers.\n+   COMMUTE indicates that register operands may be reordered.  */\n+bool\n+gen_operands_ldrd_strd (rtx *operands, bool load,\n+                        bool const_store, bool commute)\n+{\n+  int nops = 2;\n+  HOST_WIDE_INT offsets[2], offset;\n+  rtx base;\n+  rtx cur_base, cur_offset, tmp;\n+  int i, gap;\n+  HARD_REG_SET regset;\n+\n+  gcc_assert (!const_store || !load);\n+  /* Check that the memory references are immediate offsets from the\n+     same base register.  Extract the base register, the destination\n+     registers, and the corresponding memory offsets.  */\n+  for (i = 0; i < nops; i++)\n+    {\n+      if (!mem_ok_for_ldrd_strd (operands[nops+i], &cur_base, &cur_offset))\n+        return false;\n+\n+      if (i == 0)\n+        base = cur_base;\n+      else if (REGNO (base) != REGNO (cur_base))\n+        return false;\n+\n+      offsets[i] = INTVAL (cur_offset);\n+      if (GET_CODE (operands[i]) == SUBREG)\n+        {\n+          tmp = SUBREG_REG (operands[i]);\n+          gcc_assert (GET_MODE (operands[i]) == GET_MODE (tmp));\n+          operands[i] = tmp;\n+        }\n+    }\n+\n+  /* Make sure there is no dependency between the individual loads.  */\n+  if (load && REGNO (operands[0]) == REGNO (base))\n+    return false; /* RAW */\n+\n+  if (load && REGNO (operands[0]) == REGNO (operands[1]))\n+    return false; /* WAW */\n+\n+  /* If the same input register is used in both stores\n+     when storing different constants, try to find a free register.\n+     For example, the code\n+        mov r0, 0\n+        str r0, [r2]\n+        mov r0, 1\n+        str r0, [r2, #4]\n+     can be transformed into\n+        mov r1, 0\n+        strd r1, r0, [r2]\n+     in Thumb mode assuming that r1 is free.  */\n+  if (const_store\n+      && REGNO (operands[0]) == REGNO (operands[1])\n+      && INTVAL (operands[4]) != INTVAL (operands[5]))\n+    {\n+    if (TARGET_THUMB2)\n+      {\n+        CLEAR_HARD_REG_SET (regset);\n+        tmp = peep2_find_free_register (0, 4, \"r\", SImode, &regset);\n+        if (tmp == NULL_RTX)\n+          return false;\n+\n+        /* Use the new register in the first load to ensure that\n+           if the original input register is not dead after peephole,\n+           then it will have the correct constant value.  */\n+        operands[0] = tmp;\n+      }\n+    else if (TARGET_ARM)\n+      {\n+        return false;\n+        int regno = REGNO (operands[0]);\n+        if (!peep2_reg_dead_p (4, operands[0]))\n+          {\n+            /* When the input register is even and is not dead after the\n+               pattern, it has to hold the second constant but we cannot\n+               form a legal STRD in ARM mode with this register as the second\n+               register.  */\n+            if (regno % 2 == 0)\n+              return false;\n+\n+            /* Is regno-1 free? */\n+            SET_HARD_REG_SET (regset);\n+            CLEAR_HARD_REG_BIT(regset, regno - 1);\n+            tmp = peep2_find_free_register (0, 4, \"r\", SImode, &regset);\n+            if (tmp == NULL_RTX)\n+              return false;\n+\n+            operands[0] = tmp;\n+          }\n+        else\n+          {\n+            /* Find a DImode register.  */\n+            CLEAR_HARD_REG_SET (regset);\n+            tmp = peep2_find_free_register (0, 4, \"r\", DImode, &regset);\n+            if (tmp != NULL_RTX)\n+              {\n+                operands[0] = simplify_gen_subreg (SImode, tmp, DImode, 0);\n+                operands[1] = simplify_gen_subreg (SImode, tmp, DImode, 4);\n+              }\n+            else\n+              {\n+                /* Can we use the input register to form a DI register?  */\n+                SET_HARD_REG_SET (regset);\n+                CLEAR_HARD_REG_BIT(regset,\n+                                   regno % 2 == 0 ? regno + 1 : regno - 1);\n+                tmp = peep2_find_free_register (0, 4, \"r\", SImode, &regset);\n+                if (tmp == NULL_RTX)\n+                  return false;\n+                operands[regno % 2 == 1 ? 0 : 1] = tmp;\n+              }\n+          }\n+\n+        gcc_assert (operands[0] != NULL_RTX);\n+        gcc_assert (operands[1] != NULL_RTX);\n+        gcc_assert (REGNO (operands[0]) % 2 == 0);\n+        gcc_assert (REGNO (operands[1]) == REGNO (operands[0]) + 1);\n+      }\n+    }\n+\n+  /* Make sure the instructions are ordered with lower memory access first.  */\n+  if (offsets[0] > offsets[1])\n+    {\n+      gap = offsets[0] - offsets[1];\n+      offset = offsets[1];\n+\n+      /* Swap the instructions such that lower memory is accessed first.  */\n+      SWAP_RTX (operands[0], operands[1]);\n+      SWAP_RTX (operands[2], operands[3]);\n+      if (const_store)\n+        SWAP_RTX (operands[4], operands[5]);\n+    }\n+  else\n+    {\n+      gap = offsets[1] - offsets[0];\n+      offset = offsets[0];\n+    }\n+\n+  /* Make sure accesses are to consecutive memory locations.  */\n+  if (gap != 4)\n+    return false;\n+\n+  /* Make sure we generate legal instructions.  */\n+  if (operands_ok_ldrd_strd (operands[0], operands[1], base, offset,\n+                             false, load))\n+    return true;\n+\n+  /* In Thumb state, where registers are almost unconstrained, there\n+     is little hope to fix it.  */\n+  if (TARGET_THUMB2)\n+    return false;\n+\n+  if (load && commute)\n+    {\n+      /* Try reordering registers.  */\n+      SWAP_RTX (operands[0], operands[1]);\n+      if (operands_ok_ldrd_strd (operands[0], operands[1], base, offset,\n+                                 false, load))\n+        return true;\n+    }\n+\n+  if (const_store)\n+    {\n+      /* If input registers are dead after this pattern, they can be\n+         reordered or replaced by other registers that are free in the\n+         current pattern.  */\n+      if (!peep2_reg_dead_p (4, operands[0])\n+          || !peep2_reg_dead_p (4, operands[1]))\n+        return false;\n+\n+      /* Try to reorder the input registers.  */\n+      /* For example, the code\n+           mov r0, 0\n+           mov r1, 1\n+           str r1, [r2]\n+           str r0, [r2, #4]\n+         can be transformed into\n+           mov r1, 0\n+           mov r0, 1\n+           strd r0, [r2]\n+      */\n+      if (operands_ok_ldrd_strd (operands[1], operands[0], base, offset,\n+                                  false, false))\n+        {\n+          SWAP_RTX (operands[0], operands[1]);\n+          return true;\n+        }\n+\n+      /* Try to find a free DI register.  */\n+      CLEAR_HARD_REG_SET (regset);\n+      add_to_hard_reg_set (&regset, SImode, REGNO (operands[0]));\n+      add_to_hard_reg_set (&regset, SImode, REGNO (operands[1]));\n+      while (true)\n+        {\n+          tmp = peep2_find_free_register (0, 4, \"r\", DImode, &regset);\n+          if (tmp == NULL_RTX)\n+            return false;\n+\n+          /* DREG must be an even-numbered register in DImode.\n+             Split it into SI registers.  */\n+          operands[0] = simplify_gen_subreg (SImode, tmp, DImode, 0);\n+          operands[1] = simplify_gen_subreg (SImode, tmp, DImode, 4);\n+          gcc_assert (operands[0] != NULL_RTX);\n+          gcc_assert (operands[1] != NULL_RTX);\n+          gcc_assert (REGNO (operands[0]) % 2 == 0);\n+          gcc_assert (REGNO (operands[0]) + 1 == REGNO (operands[1]));\n+\n+          return (operands_ok_ldrd_strd (operands[0], operands[1],\n+                                         base, offset,\n+                                         false, load));\n+        }\n+    }\n+\n+  return false;\n+}\n+#undef SWAP_RTX\n+\n+\n+\n \f\n /* Print a symbolic form of X to the debug file, F.  */\n static void\n@@ -14825,7 +15096,8 @@ output_move_double (rtx *operands, bool emit, int *count)\n     {\n       /* Constraints should ensure this.  */\n       gcc_assert (code0 == MEM && code1 == REG);\n-      gcc_assert (REGNO (operands[1]) != IP_REGNUM);\n+      gcc_assert ((REGNO (operands[1]) != IP_REGNUM)\n+                  || (TARGET_ARM && TARGET_LDRD));\n \n       switch (GET_CODE (XEXP (operands[0], 0)))\n         {"}, {"sha": "b631e9e73416a371ba24d7961686269f59465c2b", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4542a38a21fea54d28d2d2b34ef8e12ebb7ca415/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4542a38a21fea54d28d2d2b34ef8e12ebb7ca415/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=4542a38a21fea54d28d2d2b34ef8e12ebb7ca415", "patch": "@@ -5729,8 +5729,8 @@\n )\n \n (define_insn \"*arm_movdi\"\n-  [(set (match_operand:DI 0 \"nonimmediate_di_operand\" \"=r, r, r, r, m\")\n-\t(match_operand:DI 1 \"di_operand\"              \"rDa,Db,Dc,mi,r\"))]\n+  [(set (match_operand:DI 0 \"nonimmediate_di_operand\" \"=r, r, r, q, m\")\n+\t(match_operand:DI 1 \"di_operand\"              \"rDa,Db,Dc,mi,q\"))]\n   \"TARGET_32BIT\n    && !(TARGET_HARD_FLOAT && TARGET_VFP)\n    && !TARGET_IWMMXT\n@@ -7154,8 +7154,8 @@\n )\n \n (define_insn \"*movdf_soft_insn\"\n-  [(set (match_operand:DF 0 \"nonimmediate_soft_df_operand\" \"=r,r,r,r,m\")\n-\t(match_operand:DF 1 \"soft_df_operand\" \"rDa,Db,Dc,mF,r\"))]\n+  [(set (match_operand:DF 0 \"nonimmediate_soft_df_operand\" \"=r,r,r,q,m\")\n+\t(match_operand:DF 1 \"soft_df_operand\" \"rDa,Db,Dc,mF,q\"))]\n   \"TARGET_32BIT && TARGET_SOFT_FLOAT\n    && (   register_operand (operands[0], DFmode)\n        || register_operand (operands[1], DFmode))\"\n@@ -12116,6 +12116,9 @@\n    (set_attr \"predicable\" \"yes\")])\n \n \n+;; Load the load/store double peephole optimizations.\n+(include \"ldrdstrd.md\")\n+\n ;; Load the load/store multiple patterns\n (include \"ldmstm.md\")\n "}, {"sha": "8974f4ee2ce45bfe033160e2c0181704539bc796", "filename": "gcc/config/arm/constraints.md", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4542a38a21fea54d28d2d2b34ef8e12ebb7ca415/gcc%2Fconfig%2Farm%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4542a38a21fea54d28d2d2b34ef8e12ebb7ca415/gcc%2Fconfig%2Farm%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fconstraints.md?ref=4542a38a21fea54d28d2d2b34ef8e12ebb7ca415", "patch": "@@ -21,7 +21,7 @@\n ;; The following register constraints have been used:\n ;; - in ARM/Thumb-2 state: t, w, x, y, z\n ;; - in Thumb state: h, b\n-;; - in both states: l, c, k\n+;; - in both states: l, c, k, q\n ;; In ARM state, 'l' is an alias for 'r'\n ;; 'f' and 'v' were previously used for FPA and MAVERICK registers.\n \n@@ -86,6 +86,9 @@\n (define_register_constraint \"k\" \"STACK_REG\"\n  \"@internal The stack register.\")\n \n+(define_register_constraint \"q\" \"(TARGET_ARM && TARGET_LDRD) ? CORE_REGS : GENERAL_REGS\"\n+  \"@internal In ARM state with LDRD support, core registers, otherwise general registers.\")\n+\n (define_register_constraint \"b\" \"TARGET_THUMB ? BASE_REGS : NO_REGS\"\n  \"@internal\n   Thumb only.  The union of the low registers and the stack register.\")"}, {"sha": "58c883ef1cb7b7e26437be640aab248ca1ebc60e", "filename": "gcc/config/arm/ldrdstrd.md", "status": "added", "additions": 260, "deletions": 0, "changes": 260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4542a38a21fea54d28d2d2b34ef8e12ebb7ca415/gcc%2Fconfig%2Farm%2Fldrdstrd.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4542a38a21fea54d28d2d2b34ef8e12ebb7ca415/gcc%2Fconfig%2Farm%2Fldrdstrd.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fldrdstrd.md?ref=4542a38a21fea54d28d2d2b34ef8e12ebb7ca415", "patch": "@@ -0,0 +1,260 @@\n+;; ARM ldrd/strd peephole optimizations.\n+;;\n+;; Copyright (C) 2013 Free Software Foundation, Inc.\n+;;\n+;; Written by Greta Yorsh <greta.yorsh@arm.com>\n+\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful, but\n+;; WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+;; General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+;; The following peephole optimizations identify consecutive memory\n+;; accesses, and try to rearrange the operands to enable generation of\n+;; ldrd/strd.\n+\n+(define_peephole2 ; ldrd\n+  [(set (match_operand:SI 0 \"arm_general_register_operand\" \"\")\n+        (match_operand:SI 2 \"memory_operand\" \"\"))\n+   (set (match_operand:SI 1 \"arm_general_register_operand\" \"\")\n+        (match_operand:SI 3 \"memory_operand\" \"\"))]\n+  \"TARGET_LDRD\n+     && current_tune->prefer_ldrd_strd\n+     && !optimize_function_for_size_p (cfun)\"\n+  [(const_int 0)]\n+{\n+  if (!gen_operands_ldrd_strd (operands, true, false, false))\n+    FAIL;\n+  else if (TARGET_ARM)\n+  {\n+    /* In ARM state, the destination registers of LDRD/STRD must be\n+       consecutive. We emit DImode access.  */\n+    operands[0] = gen_rtx_REG (DImode, REGNO (operands[0]));\n+    operands[2] = adjust_address (operands[2], DImode, 0);\n+    /* Emit [(set (match_dup 0) (match_dup 2))] */\n+    emit_insn (gen_rtx_SET (VOIDmode, operands[0], operands[2]));\n+    DONE;\n+  }\n+  else if (TARGET_THUMB2)\n+  {\n+    /* Emit the pattern:\n+       [(parallel [(set (match_dup 0) (match_dup 2))\n+                   (set (match_dup 1) (match_dup 3))])] */\n+    rtx t1 = gen_rtx_SET (VOIDmode, operands[0], operands[2]);\n+    rtx t2 = gen_rtx_SET (VOIDmode, operands[1], operands[3]);\n+    emit_insn (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, t1, t2)));\n+    DONE;\n+  }\n+})\n+\n+(define_peephole2 ; strd\n+  [(set (match_operand:SI 2 \"memory_operand\" \"\")\n+\t(match_operand:SI 0 \"arm_general_register_operand\" \"\"))\n+   (set (match_operand:SI 3 \"memory_operand\" \"\")\n+\t(match_operand:SI 1 \"arm_general_register_operand\" \"\"))]\n+  \"TARGET_LDRD\n+     && current_tune->prefer_ldrd_strd\n+     && !optimize_function_for_size_p (cfun)\"\n+  [(const_int 0)]\n+{\n+  if (!gen_operands_ldrd_strd (operands, false, false, false))\n+    FAIL;\n+  else if (TARGET_ARM)\n+  {\n+    /* In ARM state, the destination registers of LDRD/STRD must be\n+       consecutive. We emit DImode access.  */\n+    operands[0] = gen_rtx_REG (DImode, REGNO (operands[0]));\n+    operands[2] = adjust_address (operands[2], DImode, 0);\n+    /* Emit [(set (match_dup 2) (match_dup 0))]  */\n+    emit_insn (gen_rtx_SET (VOIDmode, operands[2], operands[0]));\n+    DONE;\n+  }\n+  else if (TARGET_THUMB2)\n+  {\n+    /* Emit the pattern:\n+       [(parallel [(set (match_dup 2) (match_dup 0))\n+                   (set (match_dup 3) (match_dup 1))])]  */\n+    rtx t1 = gen_rtx_SET (VOIDmode, operands[2], operands[0]);\n+    rtx t2 = gen_rtx_SET (VOIDmode, operands[3], operands[1]);\n+    emit_insn (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, t1, t2)));\n+    DONE;\n+  }\n+})\n+\n+;; The following peepholes reorder registers to enable LDRD/STRD.\n+(define_peephole2 ; strd of constants\n+  [(set (match_operand:SI 0 \"arm_general_register_operand\" \"\")\n+        (match_operand:SI 4 \"const_int_operand\" \"\"))\n+   (set (match_operand:SI 2 \"memory_operand\" \"\")\n+        (match_dup 0))\n+   (set (match_operand:SI 1 \"arm_general_register_operand\" \"\")\n+        (match_operand:SI 5 \"const_int_operand\" \"\"))\n+   (set (match_operand:SI 3 \"memory_operand\" \"\")\n+        (match_dup 1))]\n+ \"TARGET_LDRD\n+  && current_tune->prefer_ldrd_strd\n+  && !optimize_function_for_size_p (cfun)\"\n+  [(const_int 0)]\n+{\n+  if (!gen_operands_ldrd_strd (operands, false, true, false))\n+    FAIL;\n+  else if (TARGET_ARM)\n+  {\n+   rtx tmp = gen_rtx_REG (DImode, REGNO (operands[0]));\n+   operands[2] = adjust_address (operands[2], DImode, 0);\n+   /* Emit the pattern:\n+      [(set (match_dup 0) (match_dup 4))\n+      (set (match_dup 1) (match_dup 5))\n+      (set (match_dup 2) tmp)]  */\n+   emit_insn (gen_rtx_SET (VOIDmode, operands[0], operands[4]));\n+   emit_insn (gen_rtx_SET (VOIDmode, operands[1], operands[5]));\n+   emit_insn (gen_rtx_SET (VOIDmode, operands[2], tmp));\n+   DONE;\n+  }\n+  else if (TARGET_THUMB2)\n+  {\n+    /* Emit the pattern:\n+       [(set (match_dup 0) (match_dup 4))\n+        (set (match_dup 1) (match_dup 5))\n+        (parallel [(set (match_dup 2) (match_dup 0))\n+                   (set (match_dup 3) (match_dup 1))])]  */\n+    emit_insn (gen_rtx_SET (VOIDmode, operands[0], operands[4]));\n+    emit_insn (gen_rtx_SET (VOIDmode, operands[1], operands[5]));\n+    rtx t1 = gen_rtx_SET (VOIDmode, operands[2], operands[0]);\n+    rtx t2 = gen_rtx_SET (VOIDmode, operands[3], operands[1]);\n+    emit_insn (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, t1, t2)));\n+    DONE;\n+  }\n+})\n+\n+(define_peephole2 ; strd of constants\n+  [(set (match_operand:SI 0 \"arm_general_register_operand\" \"\")\n+        (match_operand:SI 4 \"const_int_operand\" \"\"))\n+   (set (match_operand:SI 1 \"arm_general_register_operand\" \"\")\n+        (match_operand:SI 5 \"const_int_operand\" \"\"))\n+   (set (match_operand:SI 2 \"memory_operand\" \"\")\n+        (match_dup 0))\n+   (set (match_operand:SI 3 \"memory_operand\" \"\")\n+        (match_dup 1))]\n+ \"TARGET_LDRD\n+  && current_tune->prefer_ldrd_strd\n+  && !optimize_function_for_size_p (cfun)\"\n+   [(const_int 0)]\n+{\n+  if (!gen_operands_ldrd_strd (operands, false, true, false))\n+     FAIL;\n+  else if (TARGET_ARM)\n+  {\n+   rtx tmp = gen_rtx_REG (DImode, REGNO (operands[0]));\n+   operands[2] = adjust_address (operands[2], DImode, 0);\n+   /* Emit the pattern\n+      [(set (match_dup 0) (match_dup 4))\n+       (set (match_dup 1) (match_dup 5))\n+       (set (match_dup 2) tmp)]  */\n+   emit_insn (gen_rtx_SET (VOIDmode, operands[0], operands[4]));\n+   emit_insn (gen_rtx_SET (VOIDmode, operands[1], operands[5]));\n+   emit_insn (gen_rtx_SET (VOIDmode, operands[2], tmp));\n+   DONE;\n+  }\n+  else if (TARGET_THUMB2)\n+  {\n+    /*  Emit the pattern:\n+        [(set (match_dup 0) (match_dup 4))\n+         (set (match_dup 1) (match_dup 5))\n+         (parallel [(set (match_dup 2) (match_dup 0))\n+                    (set (match_dup 3) (match_dup 1))])]  */\n+    emit_insn (gen_rtx_SET (VOIDmode, operands[0], operands[4]));\n+    emit_insn (gen_rtx_SET (VOIDmode, operands[1], operands[5]));\n+    rtx t1 = gen_rtx_SET (VOIDmode, operands[2], operands[0]);\n+    rtx t2 = gen_rtx_SET (VOIDmode, operands[3], operands[1]);\n+    emit_insn (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, t1, t2)));\n+    DONE;\n+  }\n+})\n+\n+;; The following two peephole optimizations are only relevant for ARM\n+;; mode where LDRD/STRD require consecutive registers.\n+\n+(define_peephole2 ; swap the destination registers of two loads\n+\t\t  ; before a commutative operation.\n+  [(set (match_operand:SI 0 \"arm_general_register_operand\" \"\")\n+        (match_operand:SI 2 \"memory_operand\" \"\"))\n+   (set (match_operand:SI 1 \"arm_general_register_operand\" \"\")\n+        (match_operand:SI 3 \"memory_operand\" \"\"))\n+   (set (match_operand:SI 4 \"arm_general_register_operand\" \"\")\n+        (match_operator:SI 5 \"commutative_binary_operator\"\n+\t\t\t   [(match_operand 6 \"arm_general_register_operand\" \"\")\n+\t\t\t    (match_operand 7 \"arm_general_register_operand\" \"\") ]))]\n+  \"TARGET_LDRD && TARGET_ARM\n+   && current_tune->prefer_ldrd_strd\n+   && !optimize_function_for_size_p (cfun)\n+   && (  ((rtx_equal_p(operands[0], operands[6])) && (rtx_equal_p(operands[1], operands[7])))\n+        ||((rtx_equal_p(operands[0], operands[7])) && (rtx_equal_p(operands[1], operands[6]))))\n+   && (peep2_reg_dead_p (3, operands[0]) || rtx_equal_p (operands[0], operands[4]))\n+   && (peep2_reg_dead_p (3, operands[1]) || rtx_equal_p (operands[1], operands[4]))\"\n+  [(set (match_dup 0) (match_dup 2))\n+   (set (match_dup 4) (match_op_dup 5 [(match_dup 6) (match_dup 7)]))]\n+  {\n+    if (!gen_operands_ldrd_strd (operands, true, false, true))\n+     {\n+        FAIL;\n+     }\n+    else\n+     {\n+        operands[0] = gen_rtx_REG (DImode, REGNO (operands[0]));\n+        operands[2] = adjust_address (operands[2], DImode, 0);\n+     }\n+   }\n+)\n+\n+(define_peephole2 ; swap the destination registers of two loads\n+\t\t  ; before a commutative operation that sets the flags.\n+  [(set (match_operand:SI 0 \"arm_general_register_operand\" \"\")\n+        (match_operand:SI 2 \"memory_operand\" \"\"))\n+   (set (match_operand:SI 1 \"arm_general_register_operand\" \"\")\n+        (match_operand:SI 3 \"memory_operand\" \"\"))\n+   (parallel\n+      [(set (match_operand:SI 4 \"arm_general_register_operand\" \"\")\n+\t    (match_operator:SI 5 \"commutative_binary_operator\"\n+\t\t\t       [(match_operand 6 \"arm_general_register_operand\" \"\")\n+\t\t\t\t(match_operand 7 \"arm_general_register_operand\" \"\") ]))\n+       (clobber (reg:CC CC_REGNUM))])]\n+  \"TARGET_LDRD && TARGET_ARM\n+   && current_tune->prefer_ldrd_strd\n+   && !optimize_function_for_size_p (cfun)\n+   && (  ((rtx_equal_p(operands[0], operands[6])) && (rtx_equal_p(operands[1], operands[7])))\n+       ||((rtx_equal_p(operands[0], operands[7])) && (rtx_equal_p(operands[1], operands[6]))))\n+   && (peep2_reg_dead_p (3, operands[0]) || rtx_equal_p (operands[0], operands[4]))\n+   && (peep2_reg_dead_p (3, operands[1]) || rtx_equal_p (operands[1], operands[4]))\"\n+  [(set (match_dup 0) (match_dup 2))\n+   (parallel\n+      [(set (match_dup 4)\n+\t    (match_op_dup 5 [(match_dup 6) (match_dup 7)]))\n+       (clobber (reg:CC CC_REGNUM))])]\n+  {\n+    if (!gen_operands_ldrd_strd (operands, true, false, true))\n+     {\n+        FAIL;\n+     }\n+    else\n+     {\n+        operands[0] = gen_rtx_REG (DImode, REGNO (operands[0]));\n+        operands[2] = adjust_address (operands[2], DImode, 0);\n+     }\n+   }\n+)\n+\n+;; TODO: Handle LDRD/STRD with writeback:\n+;; (a) memory operands can be POST_INC, POST_DEC, PRE_MODIFY, POST_MODIFY\n+;; (b) Patterns may be followed by an update of the base address."}, {"sha": "fe075e5862a58ffb629634ae15fa1525250adc45", "filename": "gcc/config/arm/t-arm", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4542a38a21fea54d28d2d2b34ef8e12ebb7ca415/gcc%2Fconfig%2Farm%2Ft-arm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4542a38a21fea54d28d2d2b34ef8e12ebb7ca415/gcc%2Fconfig%2Farm%2Ft-arm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-arm?ref=4542a38a21fea54d28d2d2b34ef8e12ebb7ca415", "patch": "@@ -53,6 +53,7 @@ MD_INCLUDES=\t$(srcdir)/config/arm/arm1020e.md \\\n \t\t$(srcdir)/config/arm/iwmmxt.md \\\n \t\t$(srcdir)/config/arm/iwmmxt2.md \\\n \t\t$(srcdir)/config/arm/ldmstm.md \\\n+\t\t$(srcdir)/config/arm/ldrdstrd.md \\\n \t\t$(srcdir)/config/arm/marvell-f-iwmmxt.md \\\n \t\t$(srcdir)/config/arm/neon.md \\\n \t\t$(srcdir)/config/arm/predicates.md \\"}, {"sha": "1930cddb835ddc67529ede1491dae7e6ad8ad36b", "filename": "gcc/config/arm/vfp.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4542a38a21fea54d28d2d2b34ef8e12ebb7ca415/gcc%2Fconfig%2Farm%2Fvfp.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4542a38a21fea54d28d2d2b34ef8e12ebb7ca415/gcc%2Fconfig%2Farm%2Fvfp.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fvfp.md?ref=4542a38a21fea54d28d2d2b34ef8e12ebb7ca415", "patch": "@@ -132,8 +132,8 @@\n ;; DImode moves\n \n (define_insn \"*movdi_vfp\"\n-  [(set (match_operand:DI 0 \"nonimmediate_di_operand\" \"=r,r,r,r,r,r,m,w,r,w,w, Uv\")\n-       (match_operand:DI 1 \"di_operand\"              \"r,rDa,Db,Dc,mi,mi,r,r,w,w,Uvi,w\"))]\n+  [(set (match_operand:DI 0 \"nonimmediate_di_operand\" \"=r,r,r,r,q,q,m,w,r,w,w, Uv\")\n+       (match_operand:DI 1 \"di_operand\"              \"r,rDa,Db,Dc,mi,mi,q,r,w,w,Uvi,w\"))]\n   \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP && arm_tune != cortexa8\n    && (   register_operand (operands[0], DImode)\n        || register_operand (operands[1], DImode))"}, {"sha": "68f778673a97118c12c079eabc3216f7abe363a1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4542a38a21fea54d28d2d2b34ef8e12ebb7ca415/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4542a38a21fea54d28d2d2b34ef8e12ebb7ca415/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4542a38a21fea54d28d2d2b34ef8e12ebb7ca415", "patch": "@@ -1,3 +1,8 @@\n+2013-04-05  Greta Yorsh  <Greta.Yorsh@arm.com>\n+\n+\t* gcc.target/arm/peep-ldrd-1.c: New test.\n+\t* gcc.target/arm/peep-strd-1.c: Likewise.\n+\n 2013-04-05  Greta Yorsh  <Greta.Yorsh@arm.com>\n \n \t* gcc.target/arm/negdi-1.c: New test."}, {"sha": "eb2b86ee7b6dcde4d420403d650923b0e30422f9", "filename": "gcc/testsuite/gcc.target/arm/peep-ldrd-1.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4542a38a21fea54d28d2d2b34ef8e12ebb7ca415/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpeep-ldrd-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4542a38a21fea54d28d2d2b34ef8e12ebb7ca415/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpeep-ldrd-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpeep-ldrd-1.c?ref=4542a38a21fea54d28d2d2b34ef8e12ebb7ca415", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_prefer_ldrd_strd } */\n+/* { dg-options \"-O2\" }  */\n+int foo(int a, int b, int* p, int *q)\n+{\n+  a = p[2] + p[3];\n+  *q = a;\n+  *p = a;\n+  return a;\n+}\n+/* { dg-final { scan-assembler \"ldrd\" } } */"}, {"sha": "bd3307695991b32bf58faa5ab3582459d13d3fb8", "filename": "gcc/testsuite/gcc.target/arm/peep-strd-1.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4542a38a21fea54d28d2d2b34ef8e12ebb7ca415/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpeep-strd-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4542a38a21fea54d28d2d2b34ef8e12ebb7ca415/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpeep-strd-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpeep-strd-1.c?ref=4542a38a21fea54d28d2d2b34ef8e12ebb7ca415", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_prefer_ldrd_strd } */\n+/* { dg-options \"-O2\" }  */\n+void foo(int a, int b, int* p)\n+{\n+  p[2] = a;\n+  p[3] = b;\n+}\n+/* { dg-final { scan-assembler \"strd\" } } */"}]}