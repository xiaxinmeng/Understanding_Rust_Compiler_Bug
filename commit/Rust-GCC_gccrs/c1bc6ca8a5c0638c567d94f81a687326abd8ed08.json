{"sha": "c1bc6ca8a5c0638c567d94f81a687326abd8ed08", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzFiYzZjYThhNWMwNjM4YzU2N2Q5NGY4MWE2ODczMjZhYmQ4ZWQwOA==", "commit": {"author": {"name": "James E Wilson", "email": "wilson@specifixinc.com", "date": "2005-04-28T00:40:42Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "2005-04-28T00:40:42Z"}, "message": "Fix issues brought up by Nathan's assertify patch for the ia64 backend.\n\n* config/ia64/ia64.c (update_set_flags): Delete ppred and pcond\nparameters.  Replace conditional move code with assert checking for\nar.lc.  Delete obsolete comments.\n(set_src_needs_barrier): Delete cond parameter, and code using it.\n(rtx_needs_barrier): Delete initialization of cond.  Fix typo in\nassert checking for PR_REGS.  Fix calls to update_set_flags and\nset_src_needs_barrier.\n(group_barrier_needed): Renamed from group_barrier_needed_p.  Fix all\ncallers.  Rewrite explanatory comment before the function.\n(safe_group_barrier_needed): Renamed from safe_group_barrier_needed_p.\nFix all callers.\n\nFrom-SVN: r98900", "tree": {"sha": "3c2a829120444ee41672edc146b4320b8d87ddc6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c2a829120444ee41672edc146b4320b8d87ddc6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c1bc6ca8a5c0638c567d94f81a687326abd8ed08", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1bc6ca8a5c0638c567d94f81a687326abd8ed08", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1bc6ca8a5c0638c567d94f81a687326abd8ed08", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1bc6ca8a5c0638c567d94f81a687326abd8ed08/comments", "author": null, "committer": null, "parents": [{"sha": "b23aee6c5fdad2f100ecfeaac31f19f514034542", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b23aee6c5fdad2f100ecfeaac31f19f514034542", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b23aee6c5fdad2f100ecfeaac31f19f514034542"}], "stats": {"total": 117, "additions": 50, "deletions": 67}, "files": [{"sha": "5da37d415a84f42d452a43e61a7e2e83d523f056", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1bc6ca8a5c0638c567d94f81a687326abd8ed08/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1bc6ca8a5c0638c567d94f81a687326abd8ed08/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c1bc6ca8a5c0638c567d94f81a687326abd8ed08", "patch": "@@ -1,3 +1,17 @@\n+2005-04-27  James E. Wilson  <wilson@specifixinc.com>\n+\n+\t* config/ia64/ia64.c (update_set_flags): Delete ppred and pcond\n+\tparameters.  Replace conditional move code with assert checking for\n+\tar.lc.  Delete obsolete comments.\n+\t(set_src_needs_barrier): Delete cond parameter, and code using it.\n+\t(rtx_needs_barrier): Delete initialization of cond.  Fix typo in\n+\tassert checking for PR_REGS.  Fix calls to update_set_flags and\n+\tset_src_needs_barrier.\n+\t(group_barrier_needed): Renamed from group_barrier_needed_p.  Fix all\n+\tcallers.  Rewrite explanatory comment before the function.\n+\t(safe_group_barrier_needed): Renamed from safe_group_barrier_needed_p.\n+\tFix all callers.\n+\n 2005-04-27  Mike Stump  <mrs@apple.com>\n \n \t* doc/cpp.texi: gcc now implements universal character names."}, {"sha": "e81a2f9a6dc523eb7ee90905badc69c774335653", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 36, "deletions": 67, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1bc6ca8a5c0638c567d94f81a687326abd8ed08/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1bc6ca8a5c0638c567d94f81a687326abd8ed08/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=c1bc6ca8a5c0638c567d94f81a687326abd8ed08", "patch": "@@ -4779,12 +4779,12 @@ struct reg_flags\n static void rws_update (struct reg_write_state *, int, struct reg_flags, int);\n static int rws_access_regno (int, struct reg_flags, int);\n static int rws_access_reg (rtx, struct reg_flags, int);\n-static void update_set_flags (rtx, struct reg_flags *, int *, rtx *);\n-static int set_src_needs_barrier (rtx, struct reg_flags, int, rtx);\n+static void update_set_flags (rtx, struct reg_flags *);\n+static int set_src_needs_barrier (rtx, struct reg_flags, int);\n static int rtx_needs_barrier (rtx, struct reg_flags, int);\n static void init_insn_group_barriers (void);\n-static int group_barrier_needed_p (rtx);\n-static int safe_group_barrier_needed_p (rtx);\n+static int group_barrier_needed (rtx);\n+static int safe_group_barrier_needed (rtx);\n \n /* Update *RWS for REGNO, which is being written by the current instruction,\n    with predicate PRED, and associated register flags in FLAGS.  */\n@@ -4944,12 +4944,10 @@ rws_access_reg (rtx reg, struct reg_flags flags, int pred)\n    the condition, stored in *PFLAGS, *PPRED and *PCOND.  */\n \n static void\n-update_set_flags (rtx x, struct reg_flags *pflags, int *ppred, rtx *pcond)\n+update_set_flags (rtx x, struct reg_flags *pflags)\n {\n   rtx src = SET_SRC (x);\n \n-  *pcond = 0;\n-\n   switch (GET_CODE (src))\n     {\n     case CALL:\n@@ -4961,40 +4959,16 @@ update_set_flags (rtx x, struct reg_flags *pflags, int *ppred, rtx *pcond)\n \treturn;\n       else\n \t{\n-\t  int is_complemented = 0;\n-\n \t  /* X is a conditional move.  */\n \t  rtx cond = XEXP (src, 0);\n-\t  if (GET_CODE (cond) == EQ)\n-\t    is_complemented = 1;\n \t  cond = XEXP (cond, 0);\n-\t  gcc_assert (GET_CODE (cond) == REG\n-\t\t      || REGNO_REG_CLASS (REGNO (cond)) == PR_REGS);\n-\t  *pcond = cond;\n-\t  if (XEXP (src, 1) == SET_DEST (x)\n-\t      || XEXP (src, 2) == SET_DEST (x))\n-\t    {\n-\t      /* X is a conditional move that conditionally writes the\n-\t\t destination.  */\n \n-\t      /* We need another complement in this case.  */\n-\t      if (XEXP (src, 1) == SET_DEST (x))\n-\t\tis_complemented = ! is_complemented;\n-\n-\t      *ppred = REGNO (cond);\n-\t      if (is_complemented)\n-\t\t++*ppred;\n-\t    }\n-\n-\t  /* ??? If this is a conditional write to the dest, then this\n-\t     instruction does not actually read one source.  This probably\n-\t     doesn't matter, because that source is also the dest.  */\n-\t  /* ??? Multiple writes to predicate registers are allowed\n-\t     if they are all AND type compares, or if they are all OR\n-\t     type compares.  We do not generate such instructions\n-\t     currently.  */\n+\t  /* We always split conditional moves into COND_EXEC patterns, so the\n+\t     only pattern that can reach here is doloop_end_internal.  We don't\n+\t     need to do anything special for this pattern.  */\n+\t  gcc_assert (GET_CODE (cond) == REG && REGNO (cond) == AR_LC_REGNUM);\n+\t  return;\n \t}\n-      /* ... fall through ...  */\n \n     default:\n       if (COMPARISON_P (src)\n@@ -5022,7 +4996,7 @@ update_set_flags (rtx x, struct reg_flags *pflags, int *ppred, rtx *pcond)\n    for this insn.  */\n \n static int\n-set_src_needs_barrier (rtx x, struct reg_flags flags, int pred, rtx cond)\n+set_src_needs_barrier (rtx x, struct reg_flags flags, int pred)\n {\n   int need_barrier = 0;\n   rtx dst;\n@@ -5043,10 +5017,6 @@ set_src_needs_barrier (rtx x, struct reg_flags flags, int pred, rtx cond)\n \n   need_barrier = rtx_needs_barrier (src, flags, pred);\n \n-  /* This instruction unconditionally uses a predicate register.  */\n-  if (cond)\n-    need_barrier |= rws_access_reg (cond, flags, 0);\n-\n   dst = SET_DEST (x);\n   if (GET_CODE (dst) == ZERO_EXTRACT)\n     {\n@@ -5069,7 +5039,7 @@ rtx_needs_barrier (rtx x, struct reg_flags flags, int pred)\n   int need_barrier = 0;\n   const char *format_ptr;\n   struct reg_flags new_flags;\n-  rtx cond = 0;\n+  rtx cond;\n \n   if (! x)\n     return 0;\n@@ -5079,8 +5049,8 @@ rtx_needs_barrier (rtx x, struct reg_flags flags, int pred)\n   switch (GET_CODE (x))\n     {\n     case SET:\n-      update_set_flags (x, &new_flags, &pred, &cond);\n-      need_barrier = set_src_needs_barrier (x, new_flags, pred, cond);\n+      update_set_flags (x, &new_flags);\n+      need_barrier = set_src_needs_barrier (x, new_flags, pred);\n       if (GET_CODE (SET_SRC (x)) != CALL)\n \t{\n \t  new_flags.is_write = 1;\n@@ -5114,7 +5084,7 @@ rtx_needs_barrier (rtx x, struct reg_flags flags, int pred)\n \tis_complemented = 1;\n       cond = XEXP (cond, 0);\n       gcc_assert (GET_CODE (cond) == REG\n-\t\t  || REGNO_REG_CLASS (REGNO (cond)) == PR_REGS);\n+\t\t  && REGNO_REG_CLASS (REGNO (cond)) == PR_REGS);\n       pred = REGNO (cond);\n       if (is_complemented)\n \t++pred;\n@@ -5161,9 +5131,8 @@ rtx_needs_barrier (rtx x, struct reg_flags flags, int pred)\n \t  switch (GET_CODE (pat))\n \t    {\n \t    case SET:\n-\t      update_set_flags (pat, &new_flags, &pred, &cond);\n-\t      need_barrier |= set_src_needs_barrier (pat, new_flags,\n-\t\t\t\t\t\t     pred, cond);\n+\t      update_set_flags (pat, &new_flags);\n+\t      need_barrier |= set_src_needs_barrier (pat, new_flags, pred);\n \t      break;\n \n \t    case USE:\n@@ -5397,7 +5366,7 @@ rtx_needs_barrier (rtx x, struct reg_flags flags, int pred)\n   return need_barrier;\n }\n \n-/* Clear out the state for group_barrier_needed_p at the start of a\n+/* Clear out the state for group_barrier_needed at the start of a\n    sequence of insns.  */\n \n static void\n@@ -5407,12 +5376,12 @@ init_insn_group_barriers (void)\n   first_instruction = 1;\n }\n \n-/* Given the current state, recorded by previous calls to this function,\n-   determine whether a group barrier (a stop bit) is necessary before INSN.\n-   Return nonzero if so.  */\n+/* Given the current state, determine whether a group barrier (a stop bit) is\n+   necessary before INSN.  Return nonzero if so.  This modifies the state to\n+   include the effects of INSN as a side-effect.  */\n \n static int\n-group_barrier_needed_p (rtx insn)\n+group_barrier_needed (rtx insn)\n {\n   rtx pat;\n   int need_barrier = 0;\n@@ -5520,10 +5489,10 @@ group_barrier_needed_p (rtx insn)\n   return need_barrier;\n }\n \n-/* Like group_barrier_needed_p, but do not clobber the current state.  */\n+/* Like group_barrier_needed, but do not clobber the current state.  */\n \n static int\n-safe_group_barrier_needed_p (rtx insn)\n+safe_group_barrier_needed (rtx insn)\n {\n   struct reg_write_state rws_saved[NUM_REGS];\n   int saved_first_instruction;\n@@ -5532,7 +5501,7 @@ safe_group_barrier_needed_p (rtx insn)\n   memcpy (rws_saved, rws_sum, NUM_REGS * sizeof *rws_saved);\n   saved_first_instruction = first_instruction;\n \n-  t = group_barrier_needed_p (insn);\n+  t = group_barrier_needed (insn);\n \n   memcpy (rws_sum, rws_saved, NUM_REGS * sizeof *rws_saved);\n   first_instruction = saved_first_instruction;\n@@ -5582,7 +5551,7 @@ emit_insn_group_barriers (FILE *dump)\n \t{\n \t  insns_since_last_label = 1;\n \n-\t  if (group_barrier_needed_p (insn))\n+\t  if (group_barrier_needed (insn))\n \t    {\n \t      if (last_label)\n \t\t{\n@@ -5630,11 +5599,11 @@ emit_all_insn_group_barriers (FILE *dump ATTRIBUTE_UNUSED)\n \t{\n \t  if (recog_memoized (insn) == CODE_FOR_insn_group_barrier)\n \t    init_insn_group_barriers ();\n-\t  else if (group_barrier_needed_p (insn))\n+\t  else if (group_barrier_needed (insn))\n \t    {\n \t      emit_insn_before (gen_insn_group_barrier (GEN_INT (3)), insn);\n \t      init_insn_group_barriers ();\n-\t      group_barrier_needed_p (insn);\n+\t      group_barrier_needed (insn);\n \t    }\n \t}\n     }\n@@ -5928,7 +5897,7 @@ ia64_dfa_sched_reorder (FILE *dump, int sched_verbose, rtx *ready,\n       int nr_need_stop = 0;\n \n       for (insnp = ready; insnp < e_ready; insnp++)\n-\tif (safe_group_barrier_needed_p (*insnp))\n+\tif (safe_group_barrier_needed (*insnp))\n \t  nr_need_stop++;\n \n       if (reorder_type == 1 && n_ready == nr_need_stop)\n@@ -5942,7 +5911,7 @@ ia64_dfa_sched_reorder (FILE *dump, int sched_verbose, rtx *ready,\n \twhile (insnp >= ready + deleted)\n \t  {\n \t    rtx insn = *insnp;\n-\t    if (! safe_group_barrier_needed_p (insn))\n+\t    if (! safe_group_barrier_needed (insn))\n \t      break;\n \t    memmove (ready + 1, ready, (insnp - ready) * sizeof (rtx));\n \t    *ready = insn;\n@@ -5993,7 +5962,7 @@ ia64_variable_issue (FILE *dump ATTRIBUTE_UNUSED,\n   memcpy (prev_cycle_state, curr_state, dfa_state_size);\n   if (reload_completed)\n     {\n-      int needed = group_barrier_needed_p (insn);\n+      int needed = group_barrier_needed (insn);\n       \n       gcc_assert (!needed);\n       if (GET_CODE (insn) == CALL_INSN)\n@@ -6012,7 +5981,7 @@ ia64_first_cycle_multipass_dfa_lookahead_guard (rtx insn)\n {\n   gcc_assert (insn  && INSN_P (insn));\n   return (!reload_completed\n-\t  || !safe_group_barrier_needed_p (insn));\n+\t  || !safe_group_barrier_needed (insn));\n }\n \n /* The following variable value is pseudo-insn used by the DFA insn\n@@ -6032,7 +6001,7 @@ ia64_dfa_new_cycle (FILE *dump, int verbose, rtx insn, int last_clock,\n   int setup_clocks_p = FALSE;\n \n   gcc_assert (insn && INSN_P (insn));\n-  if ((reload_completed && safe_group_barrier_needed_p (insn))\n+  if ((reload_completed && safe_group_barrier_needed (insn))\n       || (last_scheduled_insn\n \t  && (GET_CODE (last_scheduled_insn) == CALL_INSN\n \t      || GET_CODE (PATTERN (last_scheduled_insn)) == ASM_INPUT\n@@ -7065,7 +7034,7 @@ final_emit_insn_group_barriers (FILE *dump ATTRIBUTE_UNUSED)\n \t      need_barrier_p = 0;\n \t      prev_insn = NULL_RTX;\n \t    }\n-\t  else if (need_barrier_p || group_barrier_needed_p (insn))\n+\t  else if (need_barrier_p || group_barrier_needed (insn))\n \t    {\n \t      if (TARGET_EARLY_STOP_BITS)\n \t\t{\n@@ -7089,15 +7058,15 @@ final_emit_insn_group_barriers (FILE *dump ATTRIBUTE_UNUSED)\n \t\t       last != insn;\n \t\t       last = NEXT_INSN (last))\n \t\t    if (INSN_P (last))\n-\t\t      group_barrier_needed_p (last);\n+\t\t      group_barrier_needed (last);\n \t\t}\n \t      else\n \t\t{\n \t\t  emit_insn_before (gen_insn_group_barrier (GEN_INT (3)),\n \t\t\t\t    insn);\n \t\t  init_insn_group_barriers ();\n \t\t}\n-\t      group_barrier_needed_p (insn);\n+\t      group_barrier_needed (insn);\n \t      prev_insn = NULL_RTX;\n \t    }\n \t  else if (recog_memoized (insn) >= 0)"}]}