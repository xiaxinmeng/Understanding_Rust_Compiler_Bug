{"sha": "6e246559b842b9fc561f5ce6eefa08912dd4f7fd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmUyNDY1NTliODQyYjlmYzU2MWY1Y2U2ZWVmYTA4OTEyZGQ0ZjdmZA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-05-30T06:31:47Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-05-30T06:31:47Z"}, "message": "Use poly_int tree accessors\n\nThis patch generalises various places that used hwi tree accessors so\nthat they can handle poly_ints instead.  In many cases these changes\nare by inspection rather than because something had shown them to be\nnecessary.\n\nI think the alias.c part is a minor bug fix: previously we used\nfits_uhwi_p for a signed HOST_WIDE_INT (which the caller does\ntreat as signed rather than unsigned).  We also checked whether\neach individual offset overflowed but didn't check whether the\nsum did.\n\n2018-05-30  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* alias.c (adjust_offset_for_component_ref): Use poly_int_tree_p\n\tand wi::to_poly_offset.  Add the current offset and then check\n\twhether the sum fits, rather than using an unchecked addition of\n\ta checked term.  Check for a shwi rather than a uhwi.\n\t* expr.c (get_bit_range): Use tree_to_poly_uint64.\n\t(store_constructor): Use poly_int_tree_p.\n\t(expand_expr_real_1): Likewise.\n\t* function.c (assign_temp): Likewise.\n\t* fold-const.c (const_binop): Use poly_int_tree_p and\n\twi::to_poly_offset.\n\t(fold_indirect_ref_1): Likewise.  Use multiple_p to attempt an exact\n\tdivision.\n\t* ipa-icf-gimple.c (func_checker::compare_operand): Use\n\tto_poly_offset for MEM offsets.\n\t* ipa-icf.c (sem_variable::equals): Likewise.\n\t* stor-layout.c (compute_record_mode): Use poly_int_tree_p.\n\t* tree-ssa-sccvn.c (ao_ref_init_from_vn_reference): Use\n\twi::to_poly_offset for BIT_FIELD_REF offsets.\n\t(vn_reference_maybe_forwprop_address): Use poly_int_tree_p and\n\twi::to_poly_offset.\n\t* var-tracking.c (emit_note_insn_var_location): Use\n\ttree_to_poly_uint64.\n\nFrom-SVN: r260914", "tree": {"sha": "34d36011aa1f1b4d6e8fba4506d1fcf929336859", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/34d36011aa1f1b4d6e8fba4506d1fcf929336859"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e246559b842b9fc561f5ce6eefa08912dd4f7fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e246559b842b9fc561f5ce6eefa08912dd4f7fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e246559b842b9fc561f5ce6eefa08912dd4f7fd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e246559b842b9fc561f5ce6eefa08912dd4f7fd/comments", "author": null, "committer": null, "parents": [{"sha": "bb3976df48aecf734211898d6d954dc8ebed0713", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb3976df48aecf734211898d6d954dc8ebed0713", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb3976df48aecf734211898d6d954dc8ebed0713"}], "stats": {"total": 113, "additions": 69, "deletions": 44}, "files": [{"sha": "51958e8c3b5c8b4eb41e87fc43aca4597a50945c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e246559b842b9fc561f5ce6eefa08912dd4f7fd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e246559b842b9fc561f5ce6eefa08912dd4f7fd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6e246559b842b9fc561f5ce6eefa08912dd4f7fd", "patch": "@@ -1,3 +1,28 @@\n+2018-05-30  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* alias.c (adjust_offset_for_component_ref): Use poly_int_tree_p\n+\tand wi::to_poly_offset.  Add the current offset and then check\n+\twhether the sum fits, rather than using an unchecked addition of\n+\ta checked term.  Check for a shwi rather than a uhwi.\n+\t* expr.c (get_bit_range): Use tree_to_poly_uint64.\n+\t(store_constructor): Use poly_int_tree_p.\n+\t(expand_expr_real_1): Likewise.\n+\t* function.c (assign_temp): Likewise.\n+\t* fold-const.c (const_binop): Use poly_int_tree_p and\n+\twi::to_poly_offset.\n+\t(fold_indirect_ref_1): Likewise.  Use multiple_p to attempt an exact\n+\tdivision.\n+\t* ipa-icf-gimple.c (func_checker::compare_operand): Use\n+\tto_poly_offset for MEM offsets.\n+\t* ipa-icf.c (sem_variable::equals): Likewise.\n+\t* stor-layout.c (compute_record_mode): Use poly_int_tree_p.\n+\t* tree-ssa-sccvn.c (ao_ref_init_from_vn_reference): Use\n+\twi::to_poly_offset for BIT_FIELD_REF offsets.\n+\t(vn_reference_maybe_forwprop_address): Use poly_int_tree_p and\n+\twi::to_poly_offset.\n+\t* var-tracking.c (emit_note_insn_var_location): Use\n+\ttree_to_poly_uint64.\n+\n 2018-05-29  Jim Wilson  <jimw@sifive.com>\n \n \t* config/riscv/riscv.c (riscv_interrupt_type): Fix comment typo."}, {"sha": "40c74a07a4654152c488d92e73e8f91605dead82", "filename": "gcc/alias.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e246559b842b9fc561f5ce6eefa08912dd4f7fd/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e246559b842b9fc561f5ce6eefa08912dd4f7fd/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=6e246559b842b9fc561f5ce6eefa08912dd4f7fd", "patch": "@@ -2698,22 +2698,22 @@ adjust_offset_for_component_ref (tree x, bool *known_p,\n     {\n       tree xoffset = component_ref_field_offset (x);\n       tree field = TREE_OPERAND (x, 1);\n-      if (TREE_CODE (xoffset) != INTEGER_CST)\n+      if (!poly_int_tree_p (xoffset))\n \t{\n \t  *known_p = false;\n \t  return;\n \t}\n \n-      offset_int woffset\n-\t= (wi::to_offset (xoffset)\n+      poly_offset_int woffset\n+\t= (wi::to_poly_offset (xoffset)\n \t   + (wi::to_offset (DECL_FIELD_BIT_OFFSET (field))\n-\t      >> LOG2_BITS_PER_UNIT));\n-      if (!wi::fits_uhwi_p (woffset))\n+\t      >> LOG2_BITS_PER_UNIT)\n+\t   + *offset);\n+      if (!woffset.to_shwi (offset))\n \t{\n \t  *known_p = false;\n \t  return;\n \t}\n-      *offset += woffset.to_uhwi ();\n \n       x = TREE_OPERAND (x, 0);\n     }"}, {"sha": "1fa32275fdfe807e4e320eaabadb394ca931df28", "filename": "gcc/expr.c", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e246559b842b9fc561f5ce6eefa08912dd4f7fd/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e246559b842b9fc561f5ce6eefa08912dd4f7fd/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=6e246559b842b9fc561f5ce6eefa08912dd4f7fd", "patch": "@@ -4913,7 +4913,7 @@ get_bit_range (poly_uint64_pod *bitstart, poly_uint64_pod *bitend, tree exp,\n   else\n     *bitstart = *bitpos - bitoffset;\n \n-  *bitend = *bitstart + tree_to_uhwi (DECL_SIZE (repr)) - 1;\n+  *bitend = *bitstart + tree_to_poly_uint64 (DECL_SIZE (repr)) - 1;\n }\n \n /* Returns true if ADDR is an ADDR_EXPR of a DECL that does not reside\n@@ -6521,12 +6521,10 @@ store_constructor (tree exp, rtx target, int cleared, poly_int64 size,\n \t      continue;\n \n \t    mode = TYPE_MODE (elttype);\n-\t    if (mode == BLKmode)\n-\t      bitsize = (tree_fits_uhwi_p (TYPE_SIZE (elttype))\n-\t\t\t ? tree_to_uhwi (TYPE_SIZE (elttype))\n-\t\t\t : -1);\n-\t    else\n+\t    if (mode != BLKmode)\n \t      bitsize = GET_MODE_BITSIZE (mode);\n+\t    else if (!poly_int_tree_p (TYPE_SIZE (elttype), &bitsize))\n+\t      bitsize = -1;\n \n \t    if (index != NULL_TREE && TREE_CODE (index) == RANGE_EXPR)\n \t      {\n@@ -10249,11 +10247,11 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n \t  {\n \t    poly_int64 offset = mem_ref_offset (exp).force_shwi ();\n \t    base = TREE_OPERAND (base, 0);\n+\t    poly_uint64 type_size;\n \t    if (known_eq (offset, 0)\n \t        && !reverse\n-\t\t&& tree_fits_uhwi_p (TYPE_SIZE (type))\n-\t\t&& known_eq (GET_MODE_BITSIZE (DECL_MODE (base)),\n-\t\t\t     tree_to_uhwi (TYPE_SIZE (type))))\n+\t\t&& poly_int_tree_p (TYPE_SIZE (type), &type_size)\n+\t\t&& known_eq (GET_MODE_BITSIZE (DECL_MODE (base)), type_size))\n \t      return expand_expr (build1 (VIEW_CONVERT_EXPR, type, base),\n \t\t\t\t  target, tmode, modifier);\n \t    if (TYPE_MODE (type) == BLKmode)"}, {"sha": "6f80f1b1d695fd6920ddab46ce8ce8db47bb9ed3", "filename": "gcc/fold-const.c", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e246559b842b9fc561f5ce6eefa08912dd4f7fd/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e246559b842b9fc561f5ce6eefa08912dd4f7fd/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=6e246559b842b9fc561f5ce6eefa08912dd4f7fd", "patch": "@@ -1611,10 +1611,10 @@ const_binop (enum tree_code code, tree type, tree arg1, tree arg2)\n       return NULL_TREE;\n \n     case POINTER_DIFF_EXPR:\n-      if (TREE_CODE (arg1) == INTEGER_CST && TREE_CODE (arg2) == INTEGER_CST)\n+      if (poly_int_tree_p (arg1) && poly_int_tree_p (arg2))\n \t{\n-\t  offset_int res = wi::sub (wi::to_offset (arg1),\n-\t\t\t\t    wi::to_offset (arg2));\n+\t  poly_offset_int res = (wi::to_poly_offset (arg1)\n+\t\t\t\t - wi::to_poly_offset (arg2));\n \t  return force_fit_type (type, res, 1,\n \t\t\t\t TREE_OVERFLOW (arg1) | TREE_OVERFLOW (arg2));\n \t}\n@@ -14202,13 +14202,12 @@ fold_indirect_ref_1 (location_t loc, tree type, tree op0)\n \t      tree min_val = size_zero_node;\n \t      if (type_domain && TYPE_MIN_VALUE (type_domain))\n \t\tmin_val = TYPE_MIN_VALUE (type_domain);\n-\t      offset_int off = wi::to_offset (op01);\n-\t      offset_int el_sz = wi::to_offset (TYPE_SIZE_UNIT (type));\n-\t      offset_int remainder;\n-\t      off = wi::divmod_trunc (off, el_sz, SIGNED, &remainder);\n-\t      if (remainder == 0 && TREE_CODE (min_val) == INTEGER_CST)\n+\t      poly_uint64 type_size, index;\n+\t      if (poly_int_tree_p (min_val)\n+\t\t  && poly_int_tree_p (TYPE_SIZE_UNIT (type), &type_size)\n+\t\t  && multiple_p (const_op01, type_size, &index))\n \t\t{\n-\t\t  off = off + wi::to_offset (min_val);\n+\t\t  poly_offset_int off = index + wi::to_poly_offset (min_val);\n \t\t  op01 = wide_int_to_tree (sizetype, off);\n \t\t  return build4_loc (loc, ARRAY_REF, type, op00, op01,\n \t\t\t\t     NULL_TREE, NULL_TREE);"}, {"sha": "6b9fd597d41e6f60f972fba096cab3bd7db1edd2", "filename": "gcc/function.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e246559b842b9fc561f5ce6eefa08912dd4f7fd/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e246559b842b9fc561f5ce6eefa08912dd4f7fd/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=6e246559b842b9fc561f5ce6eefa08912dd4f7fd", "patch": "@@ -978,25 +978,26 @@ assign_temp (tree type_or_decl, int memory_required,\n \n   if (mode == BLKmode || memory_required)\n     {\n-      HOST_WIDE_INT size = int_size_in_bytes (type);\n+      poly_int64 size;\n       rtx tmp;\n \n-      /* Zero sized arrays are GNU C extension.  Set size to 1 to avoid\n-\t problems with allocating the stack space.  */\n-      if (size == 0)\n-\tsize = 1;\n-\n       /* Unfortunately, we don't yet know how to allocate variable-sized\n \t temporaries.  However, sometimes we can find a fixed upper limit on\n \t the size, so try that instead.  */\n-      else if (size == -1)\n+      if (!poly_int_tree_p (TYPE_SIZE_UNIT (type), &size))\n \tsize = max_int_size_in_bytes (type);\n \n+      /* Zero sized arrays are a GNU C extension.  Set size to 1 to avoid\n+\t problems with allocating the stack space.  */\n+      if (known_eq (size, 0))\n+\tsize = 1;\n+\n       /* The size of the temporary may be too large to fit into an integer.  */\n       /* ??? Not sure this should happen except for user silliness, so limit\n \t this to things that aren't compiler-generated temporaries.  The\n \t rest of the time we'll die in assign_stack_temp_for_type.  */\n-      if (decl && size == -1\n+      if (decl\n+\t  && !known_size_p (size)\n \t  && TREE_CODE (TYPE_SIZE_UNIT (type)) == INTEGER_CST)\n \t{\n \t  error (\"size of variable %q+D is too large\", decl);"}, {"sha": "6a5d1e969418602852a1f5110f1cf18501d414ff", "filename": "gcc/ipa-icf-gimple.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e246559b842b9fc561f5ce6eefa08912dd4f7fd/gcc%2Fipa-icf-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e246559b842b9fc561f5ce6eefa08912dd4f7fd/gcc%2Fipa-icf-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf-gimple.c?ref=6e246559b842b9fc561f5ce6eefa08912dd4f7fd", "patch": "@@ -463,7 +463,7 @@ func_checker::compare_operand (tree t1, tree t2)\n \t  return return_false_with_msg (\"\");\n \n \t/* Type of the offset on MEM_REF does not matter.  */\n-\treturn wi::to_offset  (y1) == wi::to_offset  (y2);\n+\treturn known_eq (wi::to_poly_offset (y1), wi::to_poly_offset (y2));\n       }\n     case COMPONENT_REF:\n       {"}, {"sha": "5a1e13560d6be5c391bbf60e1cec4b276cef5124", "filename": "gcc/ipa-icf.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e246559b842b9fc561f5ce6eefa08912dd4f7fd/gcc%2Fipa-icf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e246559b842b9fc561f5ce6eefa08912dd4f7fd/gcc%2Fipa-icf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.c?ref=6e246559b842b9fc561f5ce6eefa08912dd4f7fd", "patch": "@@ -1983,8 +1983,8 @@ sem_variable::equals (tree t1, tree t2)\n \n \t/* Type of the offset on MEM_REF does not matter.  */\n \treturn return_with_debug (sem_variable::equals (x1, x2)\n-\t\t\t          && wi::to_offset  (y1)\n-\t\t\t\t     == wi::to_offset  (y2));\n+\t\t\t          && known_eq (wi::to_poly_offset (y1),\n+\t\t\t\t\t       wi::to_poly_offset (y2)));\n       }\n     case ADDR_EXPR:\n     case FDESC_EXPR:"}, {"sha": "dd08165e6061c1e190b29bd269ef2a3ab5df12b6", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e246559b842b9fc561f5ce6eefa08912dd4f7fd/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e246559b842b9fc561f5ce6eefa08912dd4f7fd/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=6e246559b842b9fc561f5ce6eefa08912dd4f7fd", "patch": "@@ -1838,9 +1838,11 @@ compute_record_mode (tree type)\n   /* If we only have one real field; use its mode if that mode's size\n      matches the type's size.  This only applies to RECORD_TYPE.  This\n      does not apply to unions.  */\n-  if (TREE_CODE (type) == RECORD_TYPE && mode != VOIDmode\n-      && tree_fits_uhwi_p (TYPE_SIZE (type))\n-      && known_eq (GET_MODE_BITSIZE (mode), tree_to_uhwi (TYPE_SIZE (type))))\n+  poly_uint64 type_size;\n+  if (TREE_CODE (type) == RECORD_TYPE\n+      && mode != VOIDmode\n+      && poly_int_tree_p (TYPE_SIZE (type), &type_size)\n+      && known_eq (GET_MODE_BITSIZE (mode), type_size))\n     ;\n   else\n     mode = mode_for_size_tree (TYPE_SIZE (type), MODE_INT, 1).else_blk ();"}, {"sha": "4e946ba7bafe754d815ff72e79001c65b0e004dd", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e246559b842b9fc561f5ce6eefa08912dd4f7fd/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e246559b842b9fc561f5ce6eefa08912dd4f7fd/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=6e246559b842b9fc561f5ce6eefa08912dd4f7fd", "patch": "@@ -999,7 +999,7 @@ ao_ref_init_from_vn_reference (ao_ref *ref,\n \n \t/* And now the usual component-reference style ops.  */\n \tcase BIT_FIELD_REF:\n-\t  offset += wi::to_offset (op->op1);\n+\t  offset += wi::to_poly_offset (op->op1);\n \t  break;\n \n \tcase COMPONENT_REF:\n@@ -1265,10 +1265,10 @@ vn_reference_maybe_forwprop_address (vec<vn_reference_op_s> *ops,\n       ptroff = gimple_assign_rhs2 (def_stmt);\n       if (TREE_CODE (ptr) != SSA_NAME\n \t  || SSA_NAME_OCCURS_IN_ABNORMAL_PHI (ptr)\n-\t  || TREE_CODE (ptroff) != INTEGER_CST)\n+\t  || !poly_int_tree_p (ptroff))\n \treturn false;\n \n-      off += wi::to_offset (ptroff);\n+      off += wi::to_poly_offset (ptroff);\n       op->op0 = ptr;\n     }\n "}, {"sha": "16e1ea8f9976b0b0cbad5e97b53fd51a66daa491", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e246559b842b9fc561f5ce6eefa08912dd4f7fd/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e246559b842b9fc561f5ce6eefa08912dd4f7fd/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=6e246559b842b9fc561f5ce6eefa08912dd4f7fd", "patch": "@@ -8665,7 +8665,6 @@ emit_note_insn_var_location (variable **varp, emit_note_data *data)\n   bool complete;\n   enum var_init_status initialized = VAR_INIT_STATUS_UNINITIALIZED;\n   HOST_WIDE_INT last_limit;\n-  tree type_size_unit;\n   HOST_WIDE_INT offsets[MAX_VAR_PARTS];\n   rtx loc[MAX_VAR_PARTS];\n   tree decl;\n@@ -8816,8 +8815,9 @@ emit_note_insn_var_location (variable **varp, emit_note_data *data)\n \t}\n       ++n_var_parts;\n     }\n-  type_size_unit = TYPE_SIZE_UNIT (TREE_TYPE (decl));\n-  if ((unsigned HOST_WIDE_INT) last_limit < TREE_INT_CST_LOW (type_size_unit))\n+  poly_uint64 type_size_unit\n+    = tree_to_poly_uint64 (TYPE_SIZE_UNIT (TREE_TYPE (decl)));\n+  if (maybe_lt (poly_uint64 (last_limit), type_size_unit))\n     complete = false;\n \n   if (! flag_var_tracking_uninit)"}]}