{"sha": "e974b93b6cb75eb6828918fb4bb8454ed8249096", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTk3NGI5M2I2Y2I3NWViNjgyODkxOGZiNGJiODQ1NGVkODI0OTA5Ng==", "commit": {"author": {"name": "Zhenqiang Chen", "email": "zhenqiang.chen@linaro.org", "date": "2014-05-15T06:30:58Z"}, "committer": {"name": "Zhenqiang Chen", "email": "zqchen@gcc.gnu.org", "date": "2014-05-15T06:30:58Z"}, "message": "shrink-wrap.h: Update comment.\n\n2014-05-15  Zhenqiang Chen  <zhenqiang.chen@linaro.org>\n\n\t* shrink-wrap.h: Update comment.\n\t* shrink-wrap.c: Update comment.\n\t(next_block_for_reg): Rename to live_edge_for_reg.\n\t(live_edge_for_reg): Allow live_edge->dest has two predecessors.\n\t(move_insn_for_shrink_wrap): Split live_edge.\n\t(prepre_shrink_wrap): One more parameter for move_insn_for_shrink_wrap.\n\nFrom-SVN: r210457", "tree": {"sha": "0d210a75d0ce671d7b5f819655cefc89f3866431", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0d210a75d0ce671d7b5f819655cefc89f3866431"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e974b93b6cb75eb6828918fb4bb8454ed8249096", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e974b93b6cb75eb6828918fb4bb8454ed8249096", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e974b93b6cb75eb6828918fb4bb8454ed8249096", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e974b93b6cb75eb6828918fb4bb8454ed8249096/comments", "author": null, "committer": null, "parents": [{"sha": "be6027111390cc525948ed5f2e0608e95a0a285c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be6027111390cc525948ed5f2e0608e95a0a285c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be6027111390cc525948ed5f2e0608e95a0a285c"}], "stats": {"total": 95, "additions": 69, "deletions": 26}, "files": [{"sha": "daf1d6cb68d596ce63f15ff6fe9ce91abe1f929e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e974b93b6cb75eb6828918fb4bb8454ed8249096/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e974b93b6cb75eb6828918fb4bb8454ed8249096/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e974b93b6cb75eb6828918fb4bb8454ed8249096", "patch": "@@ -1,3 +1,12 @@\n+2014-05-15  Zhenqiang Chen  <zhenqiang.chen@linaro.org>\n+\n+\t* shrink-wrap.h: Update comment.\n+\t* shrink-wrap.c: Update comment.\n+\t(next_block_for_reg): Rename to live_edge_for_reg.\n+\t(live_edge_for_reg): Allow live_edge->dest has two predecessors.\n+\t(move_insn_for_shrink_wrap): Split live_edge.\n+\t(prepre_shrink_wrap): One more parameter for move_insn_for_shrink_wrap.\n+\n 2014-05-14  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* config/sparc/sparc-protos.h (sparc_absnegfloat_split_legitimate):"}, {"sha": "6f0cd0c99d2ac9a51c7dff8a5feb2fbe6fd939a4", "filename": "gcc/shrink-wrap.c", "status": "modified", "additions": 59, "deletions": 25, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e974b93b6cb75eb6828918fb4bb8454ed8249096/gcc%2Fshrink-wrap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e974b93b6cb75eb6828918fb4bb8454ed8249096/gcc%2Fshrink-wrap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fshrink-wrap.c?ref=e974b93b6cb75eb6828918fb4bb8454ed8249096", "patch": "@@ -1,4 +1,4 @@\n-/* Expands front end tree to back end RTL for GCC.\n+/* Shrink-wrapping related optimizations.\n    Copyright (C) 1987-2014 Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -110,12 +110,12 @@ requires_stack_frame_p (rtx insn, HARD_REG_SET prologue_used,\n   return false;\n }\n \n-/* See whether BB has a single successor that uses [REGNO, END_REGNO),\n-   and if BB is its only predecessor.  Return that block if so,\n-   otherwise return null.  */\n+/* See whether there has a single live edge from BB, which dest uses\n+   [REGNO, END_REGNO).  Return the live edge if its dest bb has\n+   one or two predecessors.  Otherwise return NULL.  */\n \n-static basic_block\n-next_block_for_reg (basic_block bb, int regno, int end_regno)\n+static edge\n+live_edge_for_reg (basic_block bb, int regno, int end_regno)\n {\n   edge e, live_edge;\n   edge_iterator ei;\n@@ -148,25 +148,30 @@ next_block_for_reg (basic_block bb, int regno, int end_regno)\n   if (live_edge->flags & EDGE_ABNORMAL)\n     return NULL;\n \n-  if (EDGE_COUNT (live_edge->dest->preds) > 1)\n+  /* When live_edge->dest->preds == 2, we can create a new block on\n+     the edge to make it meet the requirement.  */\n+  if (EDGE_COUNT (live_edge->dest->preds) > 2)\n     return NULL;\n \n-  return live_edge->dest;\n+  return live_edge;\n }\n \n /* Try to move INSN from BB to a successor.  Return true on success.\n    USES and DEFS are the set of registers that are used and defined\n-   after INSN in BB.  */\n+   after INSN in BB.  SPLIT_P indicates whether a live edge from BB\n+   is splitted or not.  */\n \n static bool\n move_insn_for_shrink_wrap (basic_block bb, rtx insn,\n \t\t\t   const HARD_REG_SET uses,\n-\t\t\t   const HARD_REG_SET defs)\n+\t\t\t   const HARD_REG_SET defs,\n+\t\t\t   bool *split_p)\n {\n   rtx set, src, dest;\n   bitmap live_out, live_in, bb_uses, bb_defs;\n   unsigned int i, dregno, end_dregno, sregno, end_sregno;\n   basic_block next_block;\n+  edge live_edge;\n \n   /* Look for a simple register copy.  */\n   set = single_set (insn);\n@@ -191,10 +196,24 @@ move_insn_for_shrink_wrap (basic_block bb, rtx insn,\n     return false;\n \n   /* See whether there is a successor block to which we could move INSN.  */\n-  next_block = next_block_for_reg (bb, dregno, end_dregno);\n-  if (!next_block)\n+  live_edge = live_edge_for_reg (bb, dregno, end_dregno);\n+  if (!live_edge)\n     return false;\n \n+  next_block = live_edge->dest;\n+  /* Create a new basic block on the edge.  */\n+  if (EDGE_COUNT (next_block->preds) == 2)\n+    {\n+      next_block = split_edge (live_edge);\n+\n+      bitmap_copy (df_get_live_in (next_block), df_get_live_out (bb));\n+      df_set_bb_dirty (next_block);\n+\n+      /* We should not split more than once for a function.  */\n+      gcc_assert (!(*split_p));\n+      *split_p = true;\n+    }\n+\n   /* At this point we are committed to moving INSN, but let's try to\n      move it as far as we can.  */\n   do\n@@ -212,7 +231,9 @@ move_insn_for_shrink_wrap (basic_block bb, rtx insn,\n \t{\n \t  for (i = dregno; i < end_dregno; i++)\n \t    {\n-\t      if (REGNO_REG_SET_P (bb_uses, i) || REGNO_REG_SET_P (bb_defs, i)\n+\t      if (*split_p\n+\t\t  || REGNO_REG_SET_P (bb_uses, i)\n+\t\t  || REGNO_REG_SET_P (bb_defs, i)\n \t\t  || REGNO_REG_SET_P (&DF_LIVE_BB_INFO (bb)->gen, i))\n \t\tnext_block = NULL;\n \t      CLEAR_REGNO_REG_SET (live_out, i);\n@@ -223,7 +244,8 @@ move_insn_for_shrink_wrap (basic_block bb, rtx insn,\n \t     Either way, SRC is now live on entry.  */\n \t  for (i = sregno; i < end_sregno; i++)\n \t    {\n-\t      if (REGNO_REG_SET_P (bb_defs, i)\n+\t      if (*split_p\n+\t\t  || REGNO_REG_SET_P (bb_defs, i)\n \t\t  || REGNO_REG_SET_P (&DF_LIVE_BB_INFO (bb)->gen, i))\n \t\tnext_block = NULL;\n \t      SET_REGNO_REG_SET (live_out, i);\n@@ -252,21 +274,31 @@ move_insn_for_shrink_wrap (basic_block bb, rtx insn,\n       /* If we don't need to add the move to BB, look for a single\n \t successor block.  */\n       if (next_block)\n-\tnext_block = next_block_for_reg (next_block, dregno, end_dregno);\n+\t{\n+\t  live_edge = live_edge_for_reg (next_block, dregno, end_dregno);\n+\t  if (!live_edge || EDGE_COUNT (live_edge->dest->preds) > 1)\n+\t    break;\n+\t  next_block = live_edge->dest;\n+\t}\n     }\n   while (next_block);\n \n-  /* BB now defines DEST.  It only uses the parts of DEST that overlap SRC\n-     (next loop).  */\n-  for (i = dregno; i < end_dregno; i++)\n+  /* For the new created basic block, there is no dataflow info at all.\n+     So skip the following dataflow update and check.  */\n+  if (!(*split_p))\n     {\n-      CLEAR_REGNO_REG_SET (bb_uses, i);\n-      SET_REGNO_REG_SET (bb_defs, i);\n-    }\n+      /* BB now defines DEST.  It only uses the parts of DEST that overlap SRC\n+\t (next loop).  */\n+      for (i = dregno; i < end_dregno; i++)\n+\t{\n+\t  CLEAR_REGNO_REG_SET (bb_uses, i);\n+\t  SET_REGNO_REG_SET (bb_defs, i);\n+\t}\n \n-  /* BB now uses SRC.  */\n-  for (i = sregno; i < end_sregno; i++)\n-    SET_REGNO_REG_SET (bb_uses, i);\n+      /* BB now uses SRC.  */\n+      for (i = sregno; i < end_sregno; i++)\n+\tSET_REGNO_REG_SET (bb_uses, i);\n+    }\n \n   emit_insn_after (PATTERN (insn), bb_note (bb));\n   delete_insn (insn);\n@@ -286,12 +318,14 @@ prepare_shrink_wrap (basic_block entry_block)\n   rtx insn, curr, x;\n   HARD_REG_SET uses, defs;\n   df_ref *ref;\n+  bool split_p = false;\n \n   CLEAR_HARD_REG_SET (uses);\n   CLEAR_HARD_REG_SET (defs);\n   FOR_BB_INSNS_REVERSE_SAFE (entry_block, insn, curr)\n     if (NONDEBUG_INSN_P (insn)\n-\t&& !move_insn_for_shrink_wrap (entry_block, insn, uses, defs))\n+\t&& !move_insn_for_shrink_wrap (entry_block, insn, uses, defs,\n+\t\t\t\t       &split_p))\n       {\n \t/* Add all defined registers to DEFs.  */\n \tfor (ref = DF_INSN_DEFS (insn); *ref; ref++)"}, {"sha": "bccfb31aad3d1208e41e4d06402075152e6cbac7", "filename": "gcc/shrink-wrap.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e974b93b6cb75eb6828918fb4bb8454ed8249096/gcc%2Fshrink-wrap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e974b93b6cb75eb6828918fb4bb8454ed8249096/gcc%2Fshrink-wrap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fshrink-wrap.h?ref=e974b93b6cb75eb6828918fb4bb8454ed8249096", "patch": "@@ -1,4 +1,4 @@\n-/* Structure for saving state for a nested function.\n+/* Shrink-wrapping related functions.\n    Copyright (C) 1989-2014 Free Software Foundation, Inc.\n \n This file is part of GCC."}]}