{"sha": "7e574f68fa82e7c5f879fd468291ec8b5ebecc83", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2U1NzRmNjhmYTgyZTdjNWY4NzlmZDQ2ODI5MWVjOGI1ZWJlY2M4Mw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2019-01-29T15:39:40Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2019-01-29T15:39:40Z"}, "message": "PR c++/89089 - ICE with [[no_unique_address]].\n\nIn 89089, we were never actually setting DECL_SIZE on an empty data member,\nbecause its type is a POD, so we didn't set it in the maybe-overlapping\nsection.  Fixed by also handling empty types there.\n\nIn 88865, we were failing to consider empty data members in\ninclude_empty_classes.  Fixed by making end_of_class always include them.\n\nWhile looking at these I noticed that the ABI says that a\npotentially-overlapping data member makes its class non-layout-POD, and that\nan empty data member doesn't prevent its class from being empty, so I've\nimplemented those points as well.\n\n\tPR c++/88865 - wrong layout with [[no_unique_address]].\n\t* class.c (check_field_decls): A potentially-overlapping field makes\n\tthe class non-layout-POD, but not non-empty.\n\t(end_of_class): Always consider empty data members.\n\t(layout_class_type): Set DECL_SIZE for empty fields.\n\nFrom-SVN: r268368", "tree": {"sha": "1f21833e2d6af54eca9bc56c95e022c7ebb25c54", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1f21833e2d6af54eca9bc56c95e022c7ebb25c54"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7e574f68fa82e7c5f879fd468291ec8b5ebecc83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e574f68fa82e7c5f879fd468291ec8b5ebecc83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e574f68fa82e7c5f879fd468291ec8b5ebecc83", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e574f68fa82e7c5f879fd468291ec8b5ebecc83/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6065f1c5889159c9fa1b6c74726d04fc9abea9fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6065f1c5889159c9fa1b6c74726d04fc9abea9fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6065f1c5889159c9fa1b6c74726d04fc9abea9fe"}], "stats": {"total": 112, "additions": 96, "deletions": 16}, "files": [{"sha": "3cdc7790f435f01f337f2b00c80bbd65c67a3382", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e574f68fa82e7c5f879fd468291ec8b5ebecc83/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e574f68fa82e7c5f879fd468291ec8b5ebecc83/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=7e574f68fa82e7c5f879fd468291ec8b5ebecc83", "patch": "@@ -1,3 +1,12 @@\n+2019-01-28  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/89089 - ICE with [[no_unique_address]].\n+\tPR c++/88865 - wrong layout with [[no_unique_address]].\n+\t* class.c (check_field_decls): A potentially-overlapping field makes\n+\tthe class non-layout-POD, but not non-empty.\n+\t(end_of_class): Always consider empty data members.\n+\t(layout_class_type): Set DECL_SIZE for empty fields.\n+\n 2019-01-28  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/88358 - name wrongly treated as type."}, {"sha": "48da081212afc27d294bfcaec69516a203bb7957", "filename": "gcc/cp/class.c", "status": "modified", "additions": 32, "deletions": 16, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e574f68fa82e7c5f879fd468291ec8b5ebecc83/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e574f68fa82e7c5f879fd468291ec8b5ebecc83/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=7e574f68fa82e7c5f879fd468291ec8b5ebecc83", "patch": "@@ -206,6 +206,7 @@ static int empty_base_at_nonzero_offset_p (tree, tree, splay_tree);\n static tree end_of_base (tree);\n static tree get_vcall_index (tree, tree);\n static bool type_maybe_constexpr_default_constructor (tree);\n+static bool field_poverlapping_p (tree);\n \n /* Return a COND_EXPR that executes TRUE_STMT if this execution of the\n    'structor is in charge of 'structing virtual bases, or FALSE_STMT\n@@ -3556,6 +3557,11 @@ check_field_decls (tree t, tree *access_decls,\n \t/* We don't treat zero-width bitfields as making a class\n \t   non-empty.  */\n \t;\n+      else if (field_poverlapping_p (x) && is_empty_class (type))\n+\t{\n+\t  /* Empty data members also don't make a class non-empty.  */\n+\t  CLASSTYPE_CONTAINS_EMPTY_CLASS_P (t) = 1;\n+\t}\n       else\n \t{\n \t  /* The class is non-empty.  */\n@@ -3608,6 +3614,11 @@ check_field_decls (tree t, tree *access_decls,\n \t   to be allowed in POD structs.  */\n \tCLASSTYPE_NON_LAYOUT_POD_P (t) = 1;\n \n+      if (field_poverlapping_p (x))\n+\t/* A potentially-overlapping non-static data member makes the class\n+\t   non-layout-POD.  */\n+\tCLASSTYPE_NON_LAYOUT_POD_P (t) = 1;\n+\n       if (!std_layout_type_p (type))\n \tCLASSTYPE_NON_STD_LAYOUT (t) = 1;\n \n@@ -5926,13 +5937,12 @@ end_of_base (tree binfo)\n   return size_binop (PLUS_EXPR, BINFO_OFFSET (binfo), size);\n }\n \n-/* Returns the offset of the byte just past the end of the base class\n-   with the highest offset in T.  If INCLUDE_VIRTUALS_P is zero, then\n-   only non-virtual bases are included.  If INCLUDE_FIELDS_P is true,\n-   then also consider non-static data members.  */\n+/* Returns the offset of the byte just past the end of the base class or empty\n+   data member with the highest offset in T.  If INCLUDE_VIRTUALS_P is zero,\n+   then only non-virtual bases are included.  */\n \n static tree\n-end_of_class (tree t, bool include_virtuals_p, bool include_fields_p = false)\n+end_of_class (tree t, bool include_virtuals_p)\n {\n   tree result = size_zero_node;\n   vec<tree, va_gc> *vbases;\n@@ -5955,15 +5965,19 @@ end_of_class (tree t, bool include_virtuals_p, bool include_fields_p = false)\n \tresult = offset;\n     }\n \n-  if (include_fields_p)\n-    for (tree field = TYPE_FIELDS (t); field; field = DECL_CHAIN (field))\n-      if (TREE_CODE (field) == FIELD_DECL)\n-\t{\n-\t  offset = size_binop (PLUS_EXPR, DECL_FIELD_OFFSET (field),\n-\t\t\t       DECL_SIZE_UNIT (field));\n-\t  if (tree_int_cst_lt (result, offset))\n-\t    result = offset;\n-\t}\n+  /* Also consider empty data members.  */\n+  for (tree field = TYPE_FIELDS (t); field; field = DECL_CHAIN (field))\n+    if (TREE_CODE (field) == FIELD_DECL\n+\t&& !DECL_ARTIFICIAL (field)\n+\t&& field_poverlapping_p (field)\n+\t&& is_empty_class (TREE_TYPE (field)))\n+      {\n+\t/* Update sizeof(C) to max (sizeof(C), offset(D)+sizeof(D)) */\n+\toffset = size_binop (PLUS_EXPR, DECL_FIELD_OFFSET (field),\n+\t\t\t     TYPE_SIZE_UNIT (TREE_TYPE (field)));\n+\tif (tree_int_cst_lt (result, offset))\n+\t  result = offset;\n+      }\n \n   if (include_virtuals_p)\n     for (vbases = CLASSTYPE_VBASECLASSES (t), i = 0;\n@@ -6154,12 +6168,14 @@ layout_class_type (tree t, tree *virtuals_p)\n       bool might_overlap = field_poverlapping_p (field);\n \n       if (might_overlap && CLASS_TYPE_P (type)\n-\t  && CLASSTYPE_NON_LAYOUT_POD_P (type))\n+\t  && (CLASSTYPE_NON_LAYOUT_POD_P (type) || CLASSTYPE_EMPTY_P (type)))\n \t{\n \t  /* if D is a potentially-overlapping data member, update sizeof(C) to\n \t     max (sizeof(C), offset(D)+max (nvsize(D), dsize(D))).  */\n \t  tree nvsize = CLASSTYPE_SIZE_UNIT (type);\n-\t  tree dsize = end_of_class (type, /*vbases*/true, /*fields*/true);\n+\t  /* end_of_class doesn't always give dsize, but it does in the case of\n+\t     a class with virtual bases, which is when dsize > nvsize.  */\n+\t  tree dsize = end_of_class (type, /*vbases*/true);\n \t  if (tree_int_cst_le (dsize, nvsize))\n \t    {\n \t      DECL_SIZE_UNIT (field) = nvsize;"}, {"sha": "c62cfe1f2c18f95f6260386ad5a54fa935d543d2", "filename": "gcc/testsuite/g++.dg/abi/no_unique_address4.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e574f68fa82e7c5f879fd468291ec8b5ebecc83/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fno_unique_address4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e574f68fa82e7c5f879fd468291ec8b5ebecc83/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fno_unique_address4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fno_unique_address4.C?ref=7e574f68fa82e7c5f879fd468291ec8b5ebecc83", "patch": "@@ -0,0 +1,25 @@\n+// Test that [[no_unique_address]] makes the enclosing class non-layout-POD.\n+// { dg-do compile { target c++11 } }\n+\n+struct A {};\n+struct B1: A {\n+  int i;\n+  char c;\n+};\n+\n+struct B2 {\n+  [[no_unique_address]] A a;\n+  int i;\n+  char c;\n+};\n+\n+struct C1: B1 {\n+  char d;\n+};\n+\n+struct C2: B2 {\n+  char d;\n+};\n+\n+#define SA(X) static_assert((X),#X)\n+SA(sizeof(C1) == sizeof(C2));"}, {"sha": "3e94048b90929933bdf6222163907b3ae2bafe1a", "filename": "gcc/testsuite/g++.dg/abi/no_unique_address5.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e574f68fa82e7c5f879fd468291ec8b5ebecc83/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fno_unique_address5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e574f68fa82e7c5f879fd468291ec8b5ebecc83/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fno_unique_address5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fno_unique_address5.C?ref=7e574f68fa82e7c5f879fd468291ec8b5ebecc83", "patch": "@@ -0,0 +1,18 @@\n+// PR c++/88865\n+// { dg-do compile { target c++11 } }\n+\n+struct B {};\n+struct A {\n+    [[no_unique_address]] B a;\n+    [[no_unique_address]] B b;\n+    [[no_unique_address]] B c;\n+    [[no_unique_address]] B d;\n+};\n+\n+#define SA(X) static_assert((X),#X)\n+SA(sizeof(A) == 4);\n+\n+A a;\n+SA(&a.a != &a.b);\n+SA(&a.c != &a.b);\n+SA(&a.c != &a.d);"}, {"sha": "aae2394383ee8c01884693112eb5bcdb92e00d40", "filename": "gcc/testsuite/g++.dg/cpp2a/no_unique_address2.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e574f68fa82e7c5f879fd468291ec8b5ebecc83/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fno_unique_address2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e574f68fa82e7c5f879fd468291ec8b5ebecc83/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fno_unique_address2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fno_unique_address2.C?ref=7e574f68fa82e7c5f879fd468291ec8b5ebecc83", "patch": "@@ -0,0 +1,12 @@\n+// PR c++/89089\n+// { dg-do compile { target c++11 } }\n+\n+template <typename...> struct A {};\n+template <typename T, typename... U> struct A<T, U...> {\n+private:\n+  [[no_unique_address]] A<U...> a;\n+};\n+struct B {\n+  template <typename... U> A<U...> operator()(U...) { return A<U...>(); }\n+} f;\n+auto fn = f (int{}, [] {});"}]}