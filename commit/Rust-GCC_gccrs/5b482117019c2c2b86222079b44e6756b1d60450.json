{"sha": "5b482117019c2c2b86222079b44e6756b1d60450", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWI0ODIxMTcwMTljMmMyYjg2MjIyMDc5YjQ0ZTY3NTZiMWQ2MDQ1MA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2005-05-08T20:58:31Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2005-05-08T20:58:31Z"}, "message": "m68hc11.c (m68hc11_emit_libcall): Use gcc_assert and gcc_unreachable as appropriate.\n\n\t* config/m68hc11/m68hc11.c (m68hc11_emit_libcall): Use gcc_assert\n\tand gcc_unreachable as appropriate.\n\t(expand_prologue, expand_epilogue, m68hc11_gen_lowpart,\n\tm68hc11_gen_highpart, print_operand, print_operand_address,\n\tm68hc11_expand_compare, m68hc11_expand_compare_and_branch,\n\tm68hc11_gen_movhi): Likewise.\n\t* config/m68hc11/m68hc11.h (HARD_X_REGNUM): Reword comment.\n\t* config/m68hc11/m68hc11.md: Reword comment.\n\nFrom-SVN: r99407", "tree": {"sha": "f5e555ced44cf66c6cbdab75fe39d97f28e1ae3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f5e555ced44cf66c6cbdab75fe39d97f28e1ae3d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5b482117019c2c2b86222079b44e6756b1d60450", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b482117019c2c2b86222079b44e6756b1d60450", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b482117019c2c2b86222079b44e6756b1d60450", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b482117019c2c2b86222079b44e6756b1d60450/comments", "author": null, "committer": null, "parents": [{"sha": "6e60976ff1aaa41de08d89e9237c30a4ed9a6159", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e60976ff1aaa41de08d89e9237c30a4ed9a6159", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e60976ff1aaa41de08d89e9237c30a4ed9a6159"}], "stats": {"total": 242, "additions": 107, "deletions": 135}, "files": [{"sha": "5184c4a12cebd702cb525a540ba84eac06575c8b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b482117019c2c2b86222079b44e6756b1d60450/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b482117019c2c2b86222079b44e6756b1d60450/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5b482117019c2c2b86222079b44e6756b1d60450", "patch": "@@ -1,3 +1,14 @@\n+2005-05-08  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* config/m68hc11/m68hc11.c (m68hc11_emit_libcall): Use gcc_assert\n+\tand gcc_unreachable as appropriate.\n+\t(expand_prologue, expand_epilogue, m68hc11_gen_lowpart,\n+\tm68hc11_gen_highpart, print_operand, print_operand_address,\n+\tm68hc11_expand_compare, m68hc11_expand_compare_and_branch,\n+\tm68hc11_gen_movhi): Likewise.\n+\t* config/m68hc11/m68hc11.h (HARD_X_REGNUM): Reword comment.\n+\t* config/m68hc11/m68hc11.md: Reword comment.\n+\n 2005-05-08  Stephane Carrez  <stcarrez@nerim.fr>\n \n \tPR target/21281\n@@ -9,7 +20,8 @@\n \t* config/m68hc11/predicates.md (reg_or_some_mem_operand): Do not allow\n \tthe 68HC12 address indirect addressing mode as it is not supported by\n \tbset and bclr.\n-\t* config/m68hc11/m68hc11-protos.h (m68hc11_valid_addressing_p): Declare.\n+\t* config/m68hc11/m68hc11-protos.h\n+\t(m68hc11_valid_addressing_p): Declare.\n \t(m68hc11_add_mode): Declare.\n \t* config/m68hc11/m68hc11.c (m68hc11_valid_addressing_p): Rename from\n \tregister_indirect_p and export it.\n@@ -30,8 +42,8 @@\n 2005-05-08  Stephane Carrez  <stcarrez@nerim.fr>\n \n \tPR target/19051\n-\t* config/m68hc11/m68hc11.md (\"mulqi3\"): Use general_operand for operand\n-\t1 and fix constraints.\n+\t* config/m68hc11/m68hc11.md (\"mulqi3\"): Use general_operand for\n+\toperand 1 and fix constraints.\n \t(\"mulqihi3\"): Use general_operand for operand 2.\n \n 2005-05-08  Julian Brown  <julian@codesourcery.com>"}, {"sha": "6b68d25fdf7b0677ff9c3f8c92a35ce47f3f6dc8", "filename": "gcc/config/m68hc11/m68hc11.c", "status": "modified", "additions": 90, "deletions": 130, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b482117019c2c2b86222079b44e6756b1d60450/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b482117019c2c2b86222079b44e6756b1d60450/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c?ref=5b482117019c2c2b86222079b44e6756b1d60450", "patch": "@@ -922,7 +922,7 @@ m68hc11_emit_libcall (const char *name, enum rtx_code code,\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   insns = get_insns ();\n@@ -1571,8 +1571,7 @@ expand_prologue (void)\n   int regno;\n   rtx scratch;\n \n-  if (reload_completed != 1)\n-    abort ();\n+  gcc_assert (reload_completed == 1);\n \n   size = get_frame_size ();\n \n@@ -1677,8 +1676,7 @@ expand_epilogue (void)\n   int return_size;\n   rtx scratch;\n \n-  if (reload_completed != 1)\n-    abort ();\n+  gcc_assert (reload_completed == 1);\n \n   size = get_frame_size ();\n \n@@ -1826,12 +1824,16 @@ m68hc11_gen_lowpart (enum machine_mode mode, rtx x)\n \t{\n \t  l[0] = CONST_DOUBLE_LOW (x);\n \t}\n-      if (mode == SImode)\n-\treturn GEN_INT (l[0]);\n-      else if (mode == HImode && GET_MODE (x) == SFmode)\n-\treturn gen_int_mode (l[0], HImode);\n-      else\n-\tabort ();\n+      switch (mode)\n+\t{\n+\tcase SImode:\n+\t  return GEN_INT (l[0]);\n+\tcase HImode:\n+\t  gcc_assert (GET_MODE (x) == SFmode);\n+\t  return gen_int_mode (l[0], HImode);\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n     }\n \n   if (mode == QImode && D_REG_P (x))\n@@ -1840,12 +1842,15 @@ m68hc11_gen_lowpart (enum machine_mode mode, rtx x)\n   /* gen_lowpart crashes when it is called with a SUBREG.  */\n   if (GET_CODE (x) == SUBREG && SUBREG_BYTE (x) != 0)\n     {\n-      if (mode == SImode)\n-\treturn gen_rtx_SUBREG (mode, SUBREG_REG (x), SUBREG_BYTE (x) + 4);\n-      else if (mode == HImode)\n-\treturn gen_rtx_SUBREG (mode, SUBREG_REG (x), SUBREG_BYTE (x) + 2);\n-      else\n-\tabort ();\n+      switch (mode)\n+\t{\n+\tcase SImode:\n+\t  return gen_rtx_SUBREG (mode, SUBREG_REG (x), SUBREG_BYTE (x) + 4);\n+\tcase HImode:\n+\t  return gen_rtx_SUBREG (mode, SUBREG_REG (x), SUBREG_BYTE (x) + 2);\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n     }\n   x = gen_lowpart (mode, x);\n \n@@ -1902,12 +1907,16 @@ m68hc11_gen_highpart (enum machine_mode mode, rtx x)\n \t  l[1] = CONST_DOUBLE_HIGH (x);\n \t}\n \n-      if (mode == SImode)\n-\treturn GEN_INT (l[1]);\n-      else if (mode == HImode && GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT)\n-\treturn gen_int_mode ((l[0] >> 16), HImode);\n-      else\n-\tabort ();\n+      switch (mode)\n+\t{\n+\tcase SImode:\n+\t  return GEN_INT (l[1]);\n+\tcase HImode:\n+\t  gcc_assert (GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT);\n+\t  return gen_int_mode ((l[0] >> 16), HImode);\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n     }\n   if (GET_CODE (x) == CONST_INT)\n     {\n@@ -1946,20 +1955,16 @@ m68hc11_gen_highpart (enum machine_mode mode, rtx x)\n     }\n \n   /* gen_highpart crashes when it is called with a SUBREG.  */\n-  if (GET_CODE (x) == SUBREG)\n+  switch (GET_CODE (x))\n     {\n+    case SUBREG:\n       return gen_rtx_SUBREG (mode, XEXP (x, 0), XEXP (x, 1));\n-    }\n-  if (GET_CODE (x) == REG)\n-    {\n+    case REG:\n       if (REGNO (x) < FIRST_PSEUDO_REGISTER)\n         return gen_rtx_REG (mode, REGNO (x));\n       else\n         return gen_rtx_SUBREG (mode, x, 0);\n-    }\n-\n-  if (GET_CODE (x) == MEM)\n-    {\n+    case MEM:\n       x = change_address (x, mode, 0);\n \n       /* Return a different rtx to avoid to share it in several insns\n@@ -1968,8 +1973,10 @@ m68hc11_gen_highpart (enum machine_mode mode, rtx x)\n       if (GET_CODE (x) == MEM)\n \tx = copy_rtx (x);\n       return x;\n+\n+    default:\n+      gcc_unreachable ();\n     }\n-  abort ();\n }\n \f\n \n@@ -2170,56 +2177,36 @@ print_operand (FILE *file, rtx op, int letter)\n       switch (GET_CODE (base))\n \t{\n \tcase PRE_DEC:\n-\t  if (TARGET_M6812)\n-\t    {\n-\t      fprintf (file, \"%u,-\", GET_MODE_SIZE (GET_MODE (op)));\n-\t      asm_print_register (file, REGNO (XEXP (base, 0)));\n-\t    }\n-\t  else\n-\t    abort ();\n+\t  gcc_assert (TARGET_M6812);\n+\t  fprintf (file, \"%u,-\", GET_MODE_SIZE (GET_MODE (op)));\n+\t  asm_print_register (file, REGNO (XEXP (base, 0)));\n \t  break;\n \n \tcase POST_DEC:\n-\t  if (TARGET_M6812)\n-\t    {\n-\t      fprintf (file, \"%u,\", GET_MODE_SIZE (GET_MODE (op)));\n-\t      asm_print_register (file, REGNO (XEXP (base, 0)));\n-\t      fprintf (file, \"-\");\n-\t    }\n-\t  else\n-\t    abort ();\n+\t  gcc_assert (TARGET_M6812);\n+\t  fprintf (file, \"%u,\", GET_MODE_SIZE (GET_MODE (op)));\n+\t  asm_print_register (file, REGNO (XEXP (base, 0)));\n+\t  fprintf (file, \"-\");\n \t  break;\n \n \tcase POST_INC:\n-\t  if (TARGET_M6812)\n-\t    {\n-\t      fprintf (file, \"%u,\", GET_MODE_SIZE (GET_MODE (op)));\n-\t      asm_print_register (file, REGNO (XEXP (base, 0)));\n-\t      fprintf (file, \"+\");\n-\t    }\n-\t  else\n-\t    abort ();\n+\t  gcc_assert (TARGET_M6812);\n+\t  fprintf (file, \"%u,\", GET_MODE_SIZE (GET_MODE (op)));\n+\t  asm_print_register (file, REGNO (XEXP (base, 0)));\n+\t  fprintf (file, \"+\");\n \t  break;\n \n \tcase PRE_INC:\n-\t  if (TARGET_M6812)\n-\t    {\n-\t      fprintf (file, \"%u,+\", GET_MODE_SIZE (GET_MODE (op)));\n-\t      asm_print_register (file, REGNO (XEXP (base, 0)));\n-\t    }\n-\t  else\n-\t    abort ();\n+\t  gcc_assert (TARGET_M6812);\n+\t  fprintf (file, \"%u,+\", GET_MODE_SIZE (GET_MODE (op)));\n+\t  asm_print_register (file, REGNO (XEXP (base, 0)));\n \t  break;\n \n         case MEM:\n-          if (TARGET_M6812)\n-            {\n-              fprintf (file, \"[\");\n-              print_operand_address (file, XEXP (base, 0));\n-              fprintf (file, \"]\");\n-            }\n-          else\n-            abort ();\n+          gcc_assert (TARGET_M6812);\n+\t  fprintf (file, \"[\");\n+\t  print_operand_address (file, XEXP (base, 0));\n+\t  fprintf (file, \"]\");\n           break;\n \n \tdefault:\n@@ -2324,8 +2311,7 @@ print_operand_address (FILE *file, rtx addr)\n   switch (GET_CODE (addr))\n     {\n     case REG:\n-      if (!REG_P (addr) || !REG_OK_FOR_BASE_STRICT_P (addr))\n-\tabort ();\n+      gcc_assert (REG_P (addr) && REG_OK_FOR_BASE_STRICT_P (addr));\n \n       fprintf (file, \"0,\");\n       asm_print_register (file, REGNO (addr));\n@@ -2336,45 +2322,29 @@ print_operand_address (FILE *file, rtx addr)\n       switch (GET_CODE (base))\n \t{\n \tcase PRE_DEC:\n-\t  if (TARGET_M6812)\n-\t    {\n-\t      fprintf (file, \"%u,-\", GET_MODE_SIZE (GET_MODE (addr)));\n-\t      asm_print_register (file, REGNO (XEXP (base, 0)));\n-\t    }\n-\t  else\n-\t    abort ();\n+\t  gcc_assert (TARGET_M6812);\n+\t  fprintf (file, \"%u,-\", GET_MODE_SIZE (GET_MODE (addr)));\n+\t  asm_print_register (file, REGNO (XEXP (base, 0)));\n \t  break;\n \n \tcase POST_DEC:\n-\t  if (TARGET_M6812)\n-\t    {\n-\t      fprintf (file, \"%u,\", GET_MODE_SIZE (GET_MODE (addr)));\n-\t      asm_print_register (file, REGNO (XEXP (base, 0)));\n-\t      fprintf (file, \"-\");\n-\t    }\n-\t  else\n-\t    abort ();\n+\t  gcc_assert (TARGET_M6812);\n+\t  fprintf (file, \"%u,\", GET_MODE_SIZE (GET_MODE (addr)));\n+\t  asm_print_register (file, REGNO (XEXP (base, 0)));\n+\t  fprintf (file, \"-\");\n \t  break;\n \n \tcase POST_INC:\n-\t  if (TARGET_M6812)\n-\t    {\n-\t      fprintf (file, \"%u,\", GET_MODE_SIZE (GET_MODE (addr)));\n-\t      asm_print_register (file, REGNO (XEXP (base, 0)));\n-\t      fprintf (file, \"+\");\n-\t    }\n-\t  else\n-\t    abort ();\n+\t  gcc_assert (TARGET_M6812);\n+\t  fprintf (file, \"%u,\", GET_MODE_SIZE (GET_MODE (addr)));\n+\t  asm_print_register (file, REGNO (XEXP (base, 0)));\n+\t  fprintf (file, \"+\");\n \t  break;\n \n \tcase PRE_INC:\n-\t  if (TARGET_M6812)\n-\t    {\n-\t      fprintf (file, \"%u,+\", GET_MODE_SIZE (GET_MODE (addr)));\n-\t      asm_print_register (file, REGNO (XEXP (base, 0)));\n-\t    }\n-\t  else\n-\t    abort ();\n+\t  gcc_assert (TARGET_M6812);\n+\t  fprintf (file, \"%u,+\", GET_MODE_SIZE (GET_MODE (addr)));\n+\t  asm_print_register (file, REGNO (XEXP (base, 0)));\n \t  break;\n \n \tdefault:\n@@ -2397,10 +2367,11 @@ print_operand_address (FILE *file, rtx addr)\n \t  base = XEXP (addr, 1);\n \t  offset = XEXP (addr, 0);\n \t}\n-      if ((CONSTANT_ADDRESS_P (base)) && (CONSTANT_ADDRESS_P (offset)))\n+      if (CONSTANT_ADDRESS_P (base))\n \t{\n \t  need_parenthesis = must_parenthesize (addr);\n \n+\t  gcc_assert (CONSTANT_ADDRESS_P (offset));\n \t  if (need_parenthesis)\n \t    fprintf (file, \"(\");\n \n@@ -2410,18 +2381,15 @@ print_operand_address (FILE *file, rtx addr)\n \t  if (need_parenthesis)\n \t    fprintf (file, \")\");\n \t}\n-      else if (REG_P (base) && REG_OK_FOR_BASE_STRICT_P (base))\n+      else\n \t{\n+\t  gcc_assert (REG_P (base) && REG_OK_FOR_BASE_STRICT_P (base));\n \t  if (REG_P (offset))\n \t    {\n-\t      if (TARGET_M6812)\n-\t\t{\n-\t\t  asm_print_register (file, REGNO (offset));\n-\t\t  fprintf (file, \",\");\n-\t\t  asm_print_register (file, REGNO (base));\n-\t\t}\n-\t      else\n-\t\tabort ();\n+\t      gcc_assert (TARGET_M6812);\n+\t      asm_print_register (file, REGNO (offset));\n+\t      fprintf (file, \",\");\n+\t      asm_print_register (file, REGNO (base));\n \t    }\n \t  else\n \t    {\n@@ -2436,10 +2404,6 @@ print_operand_address (FILE *file, rtx addr)\n \t      asm_print_register (file, REGNO (base));\n \t    }\n \t}\n-      else\n-\t{\n-\t  abort ();\n-\t}\n       break;\n \n     default:\n@@ -2470,14 +2434,10 @@ m68hc11_expand_compare (enum rtx_code code, rtx op0, rtx op1)\n {\n   rtx ret = 0;\n \n-  if (GET_MODE_CLASS (GET_MODE (op0)) == MODE_FLOAT)\n-    abort ();\n-  else\n-    {\n-      emit_insn (gen_rtx_SET (VOIDmode, cc0_rtx,\n-\t\t\t      gen_rtx_COMPARE (VOIDmode, op0, op1)));\n-      ret = gen_rtx_fmt_ee (code, VOIDmode, cc0_rtx, const0_rtx);\n-    }\n+  gcc_assert (GET_MODE_CLASS (GET_MODE (op0)) != MODE_FLOAT);\n+  emit_insn (gen_rtx_SET (VOIDmode, cc0_rtx,\n+\t\t\t  gen_rtx_COMPARE (VOIDmode, op0, op1)));\n+  ret = gen_rtx_fmt_ee (code, VOIDmode, cc0_rtx, const0_rtx);\n \n   return ret;\n }\n@@ -2605,7 +2565,7 @@ m68hc11_expand_compare_and_branch (enum rtx_code code, rtx op0, rtx op1,\n \t    break;\n \n \t  default:\n-\t    abort ();\n+\t    gcc_unreachable ();\n \t  }\n \n \t/*\n@@ -2628,7 +2588,7 @@ m68hc11_expand_compare_and_branch (enum rtx_code code, rtx op0, rtx op1,\n       }\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n   return 0;\n }\n@@ -3119,7 +3079,7 @@ m68hc11_gen_movhi (rtx insn, rtx *operands)\n               output_asm_insn (\"sts\\t2,-sp\", operands);\n               break;\n \t    default:\n-\t      abort ();\n+\t      gcc_unreachable ();\n \t    }\n \t  return;\n \t}\n@@ -3134,7 +3094,7 @@ m68hc11_gen_movhi (rtx insn, rtx *operands)\n \t      output_asm_insn (\"pul%0\", operands);\n \t      break;\n \t    default:\n-\t      abort ();\n+\t      gcc_unreachable ();\n \t    }\n \t  return;\n \t}\n@@ -3250,7 +3210,7 @@ m68hc11_gen_movhi (rtx insn, rtx *operands)\n \t  output_asm_insn (\"pulb\", operands);\n \t  break;\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n       return;\n     }\n@@ -3474,7 +3434,7 @@ m68hc11_gen_movhi (rtx insn, rtx *operands)\n \t  output_asm_insn (\"psha\", operands);\n \t  break;\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n       return;\n     }"}, {"sha": "b595568381d1ba8420a9c4eca0682ed5fe74c97c", "filename": "gcc/config/m68hc11/m68hc11.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b482117019c2c2b86222079b44e6756b1d60450/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b482117019c2c2b86222079b44e6756b1d60450/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h?ref=5b482117019c2c2b86222079b44e6756b1d60450", "patch": "@@ -289,7 +289,7 @@ extern const struct processor_costs *m68hc11_cost;\n /* The Z register does not really exist in the 68HC11.  This a fake register\n    for GCC.  It is treated exactly as an index register (X or Y).  It is only\n    in the A_REGS class, which is the BASE_REG_CLASS for GCC.  Defining this\n-   register helps the reload pass of GCC.  Otherwise, the reload often aborts\n+   register helps the reload pass of GCC.  Otherwise, the reload often dies\n    with register spill failures.\n \n    The Z register is replaced by either X or Y during the machine specific"}, {"sha": "c60dd29198ee7239de2884c173774c711d9bb56d", "filename": "gcc/config/m68hc11/m68hc11.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b482117019c2c2b86222079b44e6756b1d60450/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b482117019c2c2b86222079b44e6756b1d60450/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.md?ref=5b482117019c2c2b86222079b44e6756b1d60450", "patch": "@@ -6931,7 +6931,7 @@\n ;; Replace: \"pshx; tfr d,x; stx 0,sp\" into \"pshd; tfr d,x\"\n ;;\n ;; PR 14542: emit a use to pretend we need the value of initial register.\n-;; Otherwise verify_local_live_at_start will abort due to a live change\n+;; Otherwise verify_local_live_at_start will die due to a live change\n ;; of that register.\n ;;\n (define_peephole2"}]}