{"sha": "f0f4da3220c5b0c14d0e88ec57ff1bc5c5e0f367", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjBmNGRhMzIyMGM1YjBjMTRkMGU4OGVjNTdmZjFiYzVjNWUwZjM2Nw==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2003-09-12T09:57:11Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2003-09-12T09:57:11Z"}, "message": "mcore-protos.h (mcore_r15_operand_p): Declare.\n\n\t* config/mcore/mcore-protos.h (mcore_r15_operand_p): Declare.\n\t(mcore_secondary_reload_class): Declare.\n\t(mcore_output_inline_const_forced): Remove.\n\t* config/mcore/mcore.md (movsi): Remove the code that forced\n\tnon-inlineable constants into a register if the target was r15\n\tor the stack pointer.  Remove constant restrictions from the main\n\tdefine_insn.  Remove r <- I, r <- M and r <- N alternatives in favor\n\tof an r <- P alternative.  Remove fallback define_insn for reload.\n\t(movhi, movqi): Use gen_lowpart rather than gen_SUBREG.  Remove reload\n\tdefine_insn.  Use mcore_output_move in the remaining define_insn.\n\tAdjust condition and constraints in the way as for movsi.\n\t(movdi): Always split unacceptable constants into two.  Use\n\tsimplify_gen_subreg instead of operand_subword{,_force}.\n\t* config/mcore/mcore.c (mcore_output_inline_const_forced): Remove.\n\t(mcore_output_move): Support HImode and QImode moves as well.\n\t(mcore_m15_operand_p): New function.\n\t(mcore_reload_class): Use it to detect cases where LRW_REGS are better.\n\t(mcore_secondary_reload_class): New function.\n\t* config/mcore/mcore.h (SECONDARY_RELOAD_CLASS): Redefine in\n\tterms of mcore_secondary_reload_class.\n\nFrom-SVN: r71330", "tree": {"sha": "8e7462b7e5414a8979fdd4598a06cbb3fe7b3da1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8e7462b7e5414a8979fdd4598a06cbb3fe7b3da1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f0f4da3220c5b0c14d0e88ec57ff1bc5c5e0f367", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0f4da3220c5b0c14d0e88ec57ff1bc5c5e0f367", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0f4da3220c5b0c14d0e88ec57ff1bc5c5e0f367", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0f4da3220c5b0c14d0e88ec57ff1bc5c5e0f367/comments", "author": null, "committer": null, "parents": [{"sha": "70b160738b3bbebf0af218d785d6223628babc8f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70b160738b3bbebf0af218d785d6223628babc8f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70b160738b3bbebf0af218d785d6223628babc8f"}], "stats": {"total": 432, "additions": 108, "deletions": 324}, "files": [{"sha": "6a17614101724f84a9770381447246fa77b13d91", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0f4da3220c5b0c14d0e88ec57ff1bc5c5e0f367/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0f4da3220c5b0c14d0e88ec57ff1bc5c5e0f367/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f0f4da3220c5b0c14d0e88ec57ff1bc5c5e0f367", "patch": "@@ -1,3 +1,26 @@\n+2003-09-12  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* config/mcore/mcore-protos.h (mcore_r15_operand_p): Declare.\n+\t(mcore_secondary_reload_class): Declare.\n+\t(mcore_output_inline_const_forced): Remove.\n+\t* config/mcore/mcore.md (movsi): Remove the code that forced\n+\tnon-inlineable constants into a register if the target was r15\n+\tor the stack pointer.  Remove constant restrictions from the main\n+\tdefine_insn.  Remove r <- I, r <- M and r <- N alternatives in favor\n+\tof an r <- P alternative.  Remove fallback define_insn for reload.\n+\t(movhi, movqi): Use gen_lowpart rather than gen_SUBREG.  Remove reload\n+\tdefine_insn.  Use mcore_output_move in the remaining define_insn.\n+\tAdjust condition and constraints in the way as for movsi.\n+\t(movdi): Always split unacceptable constants into two.  Use\n+\tsimplify_gen_subreg instead of operand_subword{,_force}.\n+\t* config/mcore/mcore.c (mcore_output_inline_const_forced): Remove.\n+\t(mcore_output_move): Support HImode and QImode moves as well.\n+\t(mcore_m15_operand_p): New function.\n+\t(mcore_reload_class): Use it to detect cases where LRW_REGS are better.\n+\t(mcore_secondary_reload_class): New function.\n+\t* config/mcore/mcore.h (SECONDARY_RELOAD_CLASS): Redefine in\n+\tterms of mcore_secondary_reload_class.\n+\n 2003-09-11  Mike Stump  <mrs@apple.com>\n \n \t* c-lex.c (fe_file_change): Don't transform to_line with SOURCE_LINE."}, {"sha": "ae9f402f47f356fd99fbc7e09119ef61387d684a", "filename": "gcc/config/mcore/mcore-protos.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0f4da3220c5b0c14d0e88ec57ff1bc5c5e0f367/gcc%2Fconfig%2Fmcore%2Fmcore-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0f4da3220c5b0c14d0e88ec57ff1bc5c5e0f367/gcc%2Fconfig%2Fmcore%2Fmcore-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore-protos.h?ref=f0f4da3220c5b0c14d0e88ec57ff1bc5c5e0f367", "patch": "@@ -65,14 +65,15 @@ extern void         mcore_print_operand_address  \tPARAMS ((FILE *, rtx));\n extern void         mcore_print_operand          \tPARAMS ((FILE *, rtx, int));\n extern rtx          mcore_gen_compare_reg        \tPARAMS ((RTX_CODE));\n extern int          mcore_symbolic_address_p     \tPARAMS ((rtx));\n+extern bool         mcore_r15_operand_p\t\t\tPARAMS ((rtx));\n+extern enum reg_class mcore_secondary_reload_class\tPARAMS ((enum reg_class, enum machine_mode, rtx));\n extern enum reg_class mcore_reload_class \t\tPARAMS ((rtx, enum reg_class));\n extern int          mcore_is_same_reg            \tPARAMS ((rtx, rtx));\n extern int          mcore_arith_S_operand         \tPARAMS ((rtx));\n \n #ifdef HAVE_MACHINE_MODES\n extern const char * mcore_output_move          \t\tPARAMS ((rtx, rtx *, enum machine_mode));\n extern const char * mcore_output_movedouble    \t\tPARAMS ((rtx *, enum machine_mode));\n-extern const char * mcore_output_inline_const_forced\tPARAMS ((rtx, rtx *, enum machine_mode));\n extern int          mcore_arith_reg_operand       \tPARAMS ((rtx, enum machine_mode));\n extern int          mcore_general_movsrc_operand  \tPARAMS ((rtx, enum machine_mode));\n extern int          mcore_general_movdst_operand  \tPARAMS ((rtx, enum machine_mode));"}, {"sha": "b148c27b6aa8803975185ce9153181c09685837d", "filename": "gcc/config/mcore/mcore.c", "status": "modified", "additions": 60, "deletions": 112, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0f4da3220c5b0c14d0e88ec57ff1bc5c5e0f367/gcc%2Fconfig%2Fmcore%2Fmcore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0f4da3220c5b0c14d0e88ec57ff1bc5c5e0f367/gcc%2Fconfig%2Fmcore%2Fmcore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.c?ref=f0f4da3220c5b0c14d0e88ec57ff1bc5c5e0f367", "patch": "@@ -1270,7 +1270,17 @@ mcore_output_move (insn, operands, mode)\n \t  if (GET_CODE (XEXP (src, 0)) == LABEL_REF) \n             return \"lrw\\t%0,[%1]\";              /* a-R */\n \t  else\n-            return \"ldw\\t%0,%1\";                 /* r-m */\n+\t    switch (GET_MODE (src))\t\t/* r-m */\n+\t      {\n+\t      case SImode:\n+\t\treturn \"ldw\\t%0,%1\";\n+\t      case HImode:\n+\t\treturn \"ld.h\\t%0,%1\";\n+\t      case QImode:\n+\t\treturn \"ld.b\\t%0,%1\";\n+\t      default:\n+\t\tabort ();\n+\t      }\n \t}\n       else if (GET_CODE (src) == CONST_INT)\n \t{\n@@ -1291,100 +1301,21 @@ mcore_output_move (insn, operands, mode)\n \treturn \"lrw\\t%0, %1\";                /* Into the literal pool.  */\n     }\n   else if (GET_CODE (dst) == MEM)               /* m-r */\n-    return \"stw\\t%1,%0\";\n+    switch (GET_MODE (dst))\n+      {\n+      case SImode:\n+\treturn \"stw\\t%1,%0\";\n+      case HImode:\n+\treturn \"st.h\\t%1,%0\";\n+      case QImode:\n+\treturn \"st.b\\t%1,%0\";\n+      default:\n+\tabort ();\n+      }\n \n   abort ();\n }\n \n-/* Outputs a constant inline -- regardless of the cost.\n-   Useful for things where we've gotten into trouble and think we'd\n-   be doing an lrw into r15 (forbidden). This lets us get out of\n-   that pickle even after register allocation.  */\n-\n-const char *\n-mcore_output_inline_const_forced (insn, operands, mode)\n-     rtx insn ATTRIBUTE_UNUSED;\n-     rtx operands[];\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-{\n-  unsigned long value = INTVAL (operands[1]);\n-  unsigned long ovalue = value;\n-  struct piece\n-  {\n-    int low;\n-    int shift;\n-  }\n-  part[6];\n-  int i;\n-\n-  if (mcore_const_ok_for_inline (value))\n-    return output_inline_const (SImode, operands);\n-\n-  for (i = 0; (unsigned) i < ARRAY_SIZE (part); i++)\n-    {\n-      part[i].shift = 0;\n-      part[i].low = (value & 0x1F);\n-      value -= part[i].low;\n-      \n-      if (mcore_const_ok_for_inline (value))\n-\tbreak;\n-      else\n-\t{\n-\t  value >>= 5;\n-\t  part[i].shift = 5;\n-\t  \n-\t  while ((value & 1) == 0)\n-\t    {\n-\t      part[i].shift++;\n-\t      value >>= 1;\n-\t    }\n-\t  \n-\t  if (mcore_const_ok_for_inline (value))\n-\t    break;\n-\t}\n-    }\n-  \n-  /* 5 bits per iteration, a maximum of 5 times == 25 bits and leaves\n-     7 bits left in the constant -- which we know we can cover with\n-     a movi.  The final value can't be zero otherwise we'd have stopped\n-     in the previous iteration.   */\n-  if (value == 0 || ! mcore_const_ok_for_inline (value))\n-    abort ();\n-\n-  /* Now, work our way backwards emitting the constant.  */\n-\n-  /* Emit the value that remains -- it will be nonzero.  */\n-  operands[1] = GEN_INT (value);\n-  output_asm_insn (output_inline_const (SImode, operands), operands);\n- \n-  while (i >= 0)\n-    {\n-      /* Shift anything we've already loaded.  */\n-      if (part[i].shift)\n-        {\n-\t  operands[2] = GEN_INT (part[i].shift);\n-\t  output_asm_insn (\"lsli       %0,%2\", operands);\n-\t  value <<= part[i].shift;\n-        }\n-      \n-      /* Add anything we need into the low 5 bits.  */\n-      if (part[i].low != 0)\n-        {\n-\t  operands[2] = GEN_INT (part[i].low);\n-\t  output_asm_insn (\"addi      %0,%2\", operands);\n-\t  value += part[i].low;\n-        }\n-      \n-      i--;\n-    }\n-  \n-  if (value != ovalue)          /* sanity */\n-    abort ();\n- \n-  /* We've output all the instructions.  */\n-  return \"\";\n-}\n-\n /* Return a sequence of instructions to perform DI or DF move.\n    Since the MCORE cannot move a DI or DF in one instruction, we have\n    to take care when we see overlapping source and dest registers.  */\n@@ -3064,36 +2995,53 @@ mcore_reorg ()\n }\n \n \f\n-/* Return the reg_class to use when reloading the rtx X into the class\n-   CLASS.  */\n+/* Return true if X is something that can be moved directly into r15.  */\n \n-/* If the input is (PLUS REG CONSTANT) representing a stack slot address,\n-   then we want to restrict the class to LRW_REGS since that ensures that\n-   will be able to safely load the constant.\n+bool\n+mcore_r15_operand_p (x)\n+     rtx x;\n+{\n+  switch (GET_CODE (x))\n+    {\n+    case CONST_INT:\n+      return mcore_const_ok_for_inline (INTVAL (x));\n \n-   If the input is a constant that should be loaded with mvir1, then use\n-   ONLYR1_REGS.\n+    case REG:\n+    case SUBREG:\n+    case MEM:\n+      return 1;\n+\n+    default:\n+      return 0;\n+    }\n+}\n+\n+/* Implement SECONDARY_RELOAD_CLASS.  If CLASS contains r15, and we can't\n+   directly move X into it, use r1-r14 as a temporary.  */\n+enum reg_class\n+mcore_secondary_reload_class (class, mode, x)\n+     enum reg_class class;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n+     rtx x;\n+{\n+  if (TEST_HARD_REG_BIT (reg_class_contents[class], 15)\n+      && !mcore_r15_operand_p (x))\n+    return LRW_REGS;\n+  return NO_REGS;\n+}\n \n-   ??? We don't handle the case where we have (PLUS REG CONSTANT) and\n-   the constant should be loaded with mvir1, because that can lead to cases\n-   where an instruction needs two ONLYR1_REGS reloads.  */\n+/* Return the reg_class to use when reloading the rtx X into the class\n+   CLASS.  If X is too complex to move directly into r15, prefer to\n+   use LRW_REGS instead.  */\n enum reg_class\n mcore_reload_class (x, class)\n      rtx x;\n      enum reg_class class;\n {\n-  enum reg_class new_class;\n-\n-  if (class == GENERAL_REGS && CONSTANT_P (x)\n-      && (GET_CODE (x) != CONST_INT\n-\t  || (   ! CONST_OK_FOR_I (INTVAL (x))\n-\t      && ! CONST_OK_FOR_M (INTVAL (x))\n-\t      && ! CONST_OK_FOR_N (INTVAL (x)))))\n-    new_class = LRW_REGS;\n-  else\n-    new_class = class;\n+  if (reg_class_subset_p (LRW_REGS, class) && !mcore_r15_operand_p (x))\n+    return LRW_REGS;\n \n-  return new_class;\n+  return class;\n }\n \n /* Tell me if a pair of reg/subreg rtx's actually refer to the same"}, {"sha": "6a489e9fa9b5308d60ff8b741e445159bcd57236", "filename": "gcc/config/mcore/mcore.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0f4da3220c5b0c14d0e88ec57ff1bc5c5e0f367/gcc%2Fconfig%2Fmcore%2Fmcore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0f4da3220c5b0c14d0e88ec57ff1bc5c5e0f367/gcc%2Fconfig%2Fmcore%2Fmcore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.h?ref=f0f4da3220c5b0c14d0e88ec57ff1bc5c5e0f367", "patch": "@@ -603,7 +603,8 @@ extern const enum reg_class reg_class_from_letter[];\n /* Return the register class of a scratch register needed to copy IN into\n    or out of a register in CLASS in MODE.  If it can be done directly,\n    NO_REGS is returned.  */\n-#define SECONDARY_RELOAD_CLASS(CLASS, MODE, X) NO_REGS\n+#define SECONDARY_RELOAD_CLASS(CLASS, MODE, X) \\\n+  mcore_secondary_reload_class (CLASS, MODE, X)\n \n /* Return the maximum number of consecutive registers\n    needed to represent mode MODE in a register of class CLASS. "}, {"sha": "700dcb2cdc9d8052b43e18d038f2e024f8453890", "filename": "gcc/config/mcore/mcore.md", "status": "modified", "additions": 21, "deletions": 210, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0f4da3220c5b0c14d0e88ec57ff1bc5c5e0f367/gcc%2Fconfig%2Fmcore%2Fmcore.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0f4da3220c5b0c14d0e88ec57ff1bc5c5e0f367/gcc%2Fconfig%2Fmcore%2Fmcore.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.md?ref=f0f4da3220c5b0c14d0e88ec57ff1bc5c5e0f367", "patch": "@@ -1226,101 +1226,20 @@\n {\n   if (GET_CODE (operands[0]) == MEM)\n     operands[1] = force_reg (SImode, operands[1]);\n-  else if (CONSTANT_P (operands[1])\n-\t   && (GET_CODE (operands[1]) != CONST_INT\n-\t       || (   ! CONST_OK_FOR_I (INTVAL (operands[1]))\n-\t\t   && ! CONST_OK_FOR_M (INTVAL (operands[1]))\n-\t\t   && ! CONST_OK_FOR_N (INTVAL (operands[1]))\n-                   && (! TARGET_HARDLIT ||\n-                       ! mcore_const_ok_for_inline (INTVAL (operands[1])))))\n-\t   && ! reload_completed\n-\t   && ! reload_in_progress\n-\t   && GET_CODE (operands[0]) == REG\n-\t   && REGNO (operands[0]) < FIRST_PSEUDO_REGISTER\n-\t   && (REGNO (operands[0]) == STACK_POINTER_REGNUM\n-\t       || REGNO (operands[0]) == LK_REG))\n-    operands[1] = force_reg (SImode, operands[1]);\n }\")\n \n-;;; Must put a/i before r/r so that it will be preferred when the dest is\n-;;; a hard register.  Must put a/R before r/m.\n-;;; DO WE NEED a/i ANYMORE?\n-\n (define_insn \"\"\n-  [(set (match_operand:SI 0 \"mcore_general_movdst_operand\" \"=r,r,r,a,r,r,a,r,m\")\n-\t(match_operand:SI 1 \"mcore_general_movsrc_operand\"  \"I,M,N,i,r,c,R,m,r\"))]\n+  [(set (match_operand:SI 0 \"mcore_general_movdst_operand\" \"=r,r,a,r,a,r,m\")\n+\t(match_operand:SI 1 \"mcore_general_movsrc_operand\"  \"r,P,i,c,R,m,r\"))]\n   \"(register_operand (operands[0], SImode)\n-       || register_operand (operands[1], SImode))\n-   && ! (CONSTANT_P (operands[1])\n-         && (GET_CODE (operands[1]) != CONST_INT\n-\t     || (   ! CONST_OK_FOR_I (INTVAL (operands[1]))\n-                 && ! CONST_OK_FOR_M (INTVAL (operands[1]))\n-                 && ! CONST_OK_FOR_N (INTVAL (operands[1]))))\n-\t && GET_CODE (operands[0]) == REG\n-\t && REGNO (operands[0]) < FIRST_PSEUDO_REGISTER\n-         && (REGNO (operands[0]) == STACK_POINTER_REGNUM\n-\t     || REGNO (operands[0]) == LK_REG))\"\n+    || register_operand (operands[1], SImode))\"\n   \"* return mcore_output_move (insn, operands, SImode);\"\n-  [(set_attr \"type\" \"move,move,move,move,move,move,load,load,store\")])\n+  [(set_attr \"type\" \"move,move,move,move,load,load,store\")])\n \n-;; This is to work around a bug in reload.\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(match_operand:SI 1 \"immediate_operand\" \"i\"))]\n-  \"((reload_in_progress || reload_completed)\n-   && CONSTANT_P (operands[1])\n-   && GET_CODE (operands[1]) == CONST_INT\n-   && ! CONST_OK_FOR_I (INTVAL (operands[1]))\n-   && ! CONST_OK_FOR_M (INTVAL (operands[1]))\n-   && ! CONST_OK_FOR_N (INTVAL (operands[1]))\n-   && GET_CODE (operands[0]) == REG\n-   && REGNO (operands[0]) == LK_REG)\"\n-  \"* return mcore_output_inline_const_forced (insn, operands, SImode);\"\n-  [(set_attr \"type\" \"load\")])\n-\n-;; (define_expand \"reload_insi\"\n-;;   [(parallel [(match_operand:SI 0 \"register_operand\" \"=r\")\n-;; \t      (match_operand:SI 1 \"general_operand\"  \"\")\n-;; \t      (match_operand:DI 2 \"register_operand\" \"=&r\")])]\n-;;   \"\"\n-;;   \"\n-;;   {\n-;;     if (CONSTANT_P (operands[1])\n-;;        && GET_CODE (operands[1]) == CONST_INT\n-;;        && ! CONST_OK_FOR_I (INTVAL (operands[1]))\n-;;        && ! CONST_OK_FOR_M (INTVAL (operands[1]))\n-;;        && ! CONST_OK_FOR_N (INTVAL (operands[1]))\n-;;        && GET_CODE (operands[0]) == REG\n-;;        && (REGNO (operands[0]) == STACK_POINTER_REGNUM\n-;;           || REGNO (operands[0]) == LK_REG))\n-;;       {\n-;;         rtx tmp;\n-;; \n-;; \tif (   REGNO (operands[2]) == REGNO (operands[0])\n-;;             || REGNO (operands[2]) == STACK_POINTER_REGNUM\n-;; \t    || REGNO (operands[2]) == LK_REG)\n-;;           tmp = gen_rtx_REG (SImode, REGNO (operands[2]) + 1);\n-;; \telse\n-;;           tmp = gen_rtx_REG (SImode, REGNO (operands[2]));\n-;; \t\n-;;         emit_insn (gen_movsi (tmp, operands[1]));\n-;;         emit_insn (gen_movsi (operands[0], tmp));\n-;;         DONE;\n-;;       }\n-;;     emit_insn (gen_movsi (operands[0], operands[1]));\n-;;     DONE;\n-;;   }\"\n-;; )\n-\t\t\t       \n-\t    \n-\t\t\t       \n ;;\n ;; HImode\n ;;\n \n-;;; ??? This isn't guaranteed to work.  It should be more like the SImode\n-;;; patterns.\n-\n (define_expand \"movhi\"\n   [(set (match_operand:HI 0 \"general_operand\" \"\")\n \t(match_operand:HI 1 \"general_operand\"  \"\"))]\n@@ -1338,73 +1257,17 @@\n     {\n       rtx reg = gen_reg_rtx (SImode);\n       emit_insn (gen_movsi (reg, operands[1]));\n-      operands[1] = gen_rtx (SUBREG, HImode, reg, 0);\n+      operands[1] = gen_lowpart (HImode, reg);\n     }\n }\")\n   \n (define_insn \"\"\n-  [(set (match_operand:HI 0 \"mcore_general_movdst_operand\" \"=r,r,r,r,r,r,m\")\n-\t(match_operand:HI 1 \"mcore_general_movsrc_operand\"  \"r,I,M,N,c,m,r\"))]\n+  [(set (match_operand:HI 0 \"mcore_general_movdst_operand\" \"=r,r,a,r,r,m\")\n+\t(match_operand:HI 1 \"mcore_general_movsrc_operand\"  \"r,P,i,c,m,r\"))]\n   \"(register_operand (operands[0], HImode)\n-       || register_operand (operands[1], HImode))\n-   && (GET_CODE (operands[1]) != CONST_INT\n-       || CONST_OK_FOR_M (INTVAL (operands[1]))\n-       || CONST_OK_FOR_N (INTVAL (operands[1]))\n-       || CONST_OK_FOR_I (INTVAL (operands[1])))\"\n-  \"@\n-\tmov\t%0,%1\n-\tmovi\t%0,%1\n-\tbgeni\t%0,%P1\n-\tbmaski\t%0,%N1\n-\tmvc\t%0\n-\tld.h\t%0,%1\n-\tst.h\t%1,%0\"\n-  [(set_attr \"type\" \"move,move,move,move,move,load,store\")])\n-\n-;; Like movhi, but the const_int source can't be synthesized in\n-;; a single-instruction.  Fall back to the same things that \n-;; are done for movsi in such cases.  Presumes that we can\n-;; modify any parts of the register that we wish.\n-\n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"mcore_general_movdst_operand\" \"=r,a\")\n-\t(match_operand:HI 1 \"const_int_operand\"  \"P,i\"))]\n-  \"GET_CODE (operands[1]) == CONST_INT\n-    && INTVAL (operands[1]) > 127 && INTVAL (operands[1]) < 65536\"\n-  \"*\n-{\n-  if (GET_CODE (operands[0])== REG && REGNO (operands[0]) == 15\n-      && !mcore_const_ok_for_inline (INTVAL (operands[1])))\n-    {\n-      /* mcore_output_move would generate lrw r15 -- a forbidden combo */\n-      return mcore_output_inline_const_forced (insn, operands, SImode);\n-    }\n-  else\n-    return mcore_output_move (insn, operands, SImode);\n-}\"\n-  [(set_attr \"type\" \"move\")])\n-\n-\n-;; if we're still looking around for things to use, here's a last\n-;; ditch effort that just calls the move. We only let this happen\n-;; if we're in the reload pass.\n-;;\n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"mcore_general_movdst_operand\" \"=r,a\")\n-\t(match_operand:HI 1 \"const_int_operand\"  \"P,i\"))]\n-  \"reload_in_progress || reload_completed\"\n-  \"*\n-{\n-  if (GET_CODE (operands[0])== REG && REGNO (operands[0]) == 15\n-      && !mcore_const_ok_for_inline (INTVAL (operands[1])))\n-    {\n-      /* mcore_output_move would generate lrw r15 -- a forbidden combo */\n-      return mcore_output_inline_const_forced (insn, operands, SImode);\n-    }\n-  else\n-    return mcore_output_move (insn, operands, HImode);\n-}\"\n-  [(set_attr \"type\" \"move\")])\n+    || register_operand (operands[1], HImode))\"\n+  \"* return mcore_output_move (insn, operands, HImode);\"\n+  [(set_attr \"type\" \"move,move,move,move,load,store\")])\n \n ;;\n ;; QImode\n@@ -1427,67 +1290,18 @@\n     {\n       rtx reg = gen_reg_rtx (SImode);\n       emit_insn (gen_movsi (reg, operands[1]));\n-      operands[1] = gen_rtx (SUBREG, QImode, reg, 0);\n+      operands[1] = gen_lowpart (QImode, reg);\n     }\n }\")\n   \n (define_insn \"\"\n-  [(set (match_operand:QI 0 \"mcore_general_movdst_operand\" \"=r,r,r,r,r,r,m\")\n-\t(match_operand:QI 1 \"mcore_general_movsrc_operand\"  \"r,I,M,N,c,m,r\"))]\n+  [(set (match_operand:QI 0 \"mcore_general_movdst_operand\" \"=r,r,a,r,r,m\")\n+\t(match_operand:QI 1 \"mcore_general_movsrc_operand\"  \"r,P,i,c,m,r\"))]\n   \"(register_operand (operands[0], QImode)\n-       || register_operand (operands[1], QImode))\n-   && (GET_CODE (operands[1]) != CONST_INT\n-       || CONST_OK_FOR_M (INTVAL (operands[1]))\n-       || CONST_OK_FOR_N (INTVAL (operands[1]))\n-       || CONST_OK_FOR_I (INTVAL (operands[1])))\"\n-  \"@\n-\tmov\t%0,%1\n-\tmovi\t%0,%1\n-\tbgeni\t%0,%P1\n-\tbmaski\t%0,%N1\n-\tmvc\t%0\n-\tld.b\t%0,%1\n-\tst.b\t%1,%0\" \n-   [(set_attr \"type\" \"move,move,move,move,move,load,store\")])\n-\n-;; cover the case where the constant is 128..255; this isn't handled\n-;; in the above case. We could if we wanted to mess with adding a \n-;; new constraint class like M,N,I.\n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"mcore_general_movdst_operand\" \"=r\")\n-\t(match_operand:QI 1 \"const_int_operand\"  \"\"))]\n-  \"GET_CODE (operands[1]) == CONST_INT\n-    && INTVAL (operands[1]) > 127 && INTVAL (operands[1]) < 256\"\n-  \"*\n-{\n-   /* have a constant in range 128..255; have to do 2 insns; we can\n-    * do this with a movi followed by a bseti\n-    */\n-   operands[2] = GEN_INT (INTVAL (operands[1]) & 0x7f);\n-   return \\\"movi\\\\t%0,%2\\;bseti\\\\t%0,7\\\";\n-}\"\n-  [(set_attr \"type\" \"move\")])\n+    || register_operand (operands[1], QImode))\"\n+  \"* return mcore_output_move (insn, operands, QImode);\"\n+   [(set_attr \"type\" \"move,move,move,move,load,store\")])\n \n-;; if we're still looking around for things to use, here's a last\n-;; ditch effort that just calls the move. We only let this happen\n-;; if we're in the reload pass.\n-;;\n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"mcore_general_movdst_operand\" \"=r,a\")\n-\t(match_operand:QI 1 \"const_int_operand\"  \"P,i\"))]\n-  \"(reload_in_progress || reload_completed)\"\n-  \"*\n-{\n-  if (GET_CODE (operands[0])== REG && REGNO (operands[0]) == 15\n-      && ! mcore_const_ok_for_inline (INTVAL (operands[1])))\n-    {\n-      /* mcore_output_move would generate lrw r15 -- a forbidden combo */\n-      return mcore_output_inline_const_forced (insn, operands, SImode);\n-    }\n-  else\n-    return mcore_output_move (insn, operands, QImode);\n-}\"\n-  [(set_attr \"type\" \"move\")])\n \n ;; DImode\n \n@@ -1502,15 +1316,12 @@\n   else if (GET_CODE (operands[1]) == CONST_INT\n            && ! CONST_OK_FOR_I (INTVAL (operands[1]))\n \t   && ! CONST_OK_FOR_M (INTVAL (operands[1]))\n-\t   && ! CONST_OK_FOR_N (INTVAL (operands[1]))\n-\t   && ! reload_completed\n-\t   && ! reload_in_progress\n-\t   && GET_CODE (operands[0]) == REG)\n+\t   && ! CONST_OK_FOR_N (INTVAL (operands[1])))\n     {\n-      emit_move_insn (operand_subword (operands[0], 0, 1, DImode),\n-\t   \t      operand_subword_force (operands[1], 0, DImode));\n-      emit_move_insn (operand_subword (operands[0], 1, 1, DImode),\n-\t  \t      operand_subword_force (operands[1], 1, DImode));\n+      int i;\n+      for (i = 0; i < UNITS_PER_WORD * 2; i += UNITS_PER_WORD)\n+        emit_move_insn (simplify_gen_subreg (SImode, operands[0], DImode, i),\n+\t\t        simplify_gen_subreg (SImode, operands[1], DImode, i));\n       DONE;\n     }\n }\")"}]}