{"sha": "12a669d1e1b3b14f15bf512479c664130f52c89d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTJhNjY5ZDFlMWIzYjE0ZjE1YmY1MTI0NzljNjY0MTMwZjUyYzg5ZA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2005-02-14T09:36:35Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2005-02-14T09:36:35Z"}, "message": "re PR c++/19891 (Covariant returns are broken)\n\ncp:\n\tPR c++/19891\n\t* class.c (build_simple_base_path): Build the component_ref\n\tdirectly.\n\t(update_vtable_entry_for_fn): Walk the covariant's binfo chain\n\trather than using lookup_base.\n\t* search.c (dfs_walk_once): Add non-recursive assert check.\n\t* typeck.c (build_class_member_access_expr): It is possible for\n\tthe member type to be both const and volatile.\ntestsuite:\n\tPR c++/19891\n\t* g++.dg/abi/covariant4.C: New.\n\nFrom-SVN: r95005", "tree": {"sha": "489402919c97378f6127944f463d865fdc1383ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/489402919c97378f6127944f463d865fdc1383ad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/12a669d1e1b3b14f15bf512479c664130f52c89d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12a669d1e1b3b14f15bf512479c664130f52c89d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12a669d1e1b3b14f15bf512479c664130f52c89d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12a669d1e1b3b14f15bf512479c664130f52c89d/comments", "author": null, "committer": null, "parents": [{"sha": "90bb1c1f1511ccb29fc3c23fe2ab871c24c6b040", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90bb1c1f1511ccb29fc3c23fe2ab871c24c6b040", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90bb1c1f1511ccb29fc3c23fe2ab871c24c6b040"}], "stats": {"total": 160, "additions": 138, "deletions": 22}, "files": [{"sha": "7e39ce13ba3080c890ad70700cffa324fdb70afd", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12a669d1e1b3b14f15bf512479c664130f52c89d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12a669d1e1b3b14f15bf512479c664130f52c89d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=12a669d1e1b3b14f15bf512479c664130f52c89d", "patch": "@@ -1,3 +1,14 @@\n+2005-02-11  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/19891\n+\t* class.c (build_simple_base_path): Build the component_ref\n+\tdirectly.\n+\t(update_vtable_entry_for_fn): Walk the covariant's binfo chain\n+\trather than using lookup_base.\n+\t* search.c (dfs_walk_once): Add non-recursive assert check.\n+\t* typeck.c (build_class_member_access_expr): It is possible for\n+\tthe member type to be both const and volatile.\n+\n 2005-02-12  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n \n \tPR c++/14479"}, {"sha": "5207e924c2afdcf9676e83c4a713c69434b06d3f", "filename": "gcc/cp/class.c", "status": "modified", "additions": 69, "deletions": 21, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12a669d1e1b3b14f15bf512479c664130f52c89d/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12a669d1e1b3b14f15bf512479c664130f52c89d/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=12a669d1e1b3b14f15bf512479c664130f52c89d", "patch": "@@ -408,7 +408,18 @@ build_simple_base_path (tree expr, tree binfo)\n \n   if (d_binfo == NULL_TREE)\n     {\n+      tree temp;\n+      \n       gcc_assert (TYPE_MAIN_VARIANT (TREE_TYPE (expr)) == type);\n+      \n+      /* Transform `(a, b).x' into `(*(a, &b)).x', `(a ? b : c).x'\n+     \t into `(*(a ?  &b : &c)).x', and so on.  A COND_EXPR is only\n+     \t an lvalue in the frontend; only _DECLs and _REFs are lvalues\n+     \t in the backend.  */\n+      temp = unary_complex_lvalue (ADDR_EXPR, expr);\n+      if (temp)\n+\texpr = build_indirect_ref (temp, NULL);\n+\n       return expr;\n     }\n \n@@ -421,8 +432,27 @@ build_simple_base_path (tree expr, tree binfo)\n     if (TREE_CODE (field) == FIELD_DECL\n \t&& DECL_FIELD_IS_BASE (field)\n \t&& TREE_TYPE (field) == type)\n-      return build_class_member_access_expr (expr, field,\n-\t\t\t\t\t     NULL_TREE, false);\n+      {\n+\t/* We don't use build_class_member_access_expr here, as that\n+\t   has unnecessary checks, and more importantly results in\n+\t   recursive calls to dfs_walk_once.  */\n+\tint type_quals = cp_type_quals (TREE_TYPE (expr));\n+\n+\texpr = build3 (COMPONENT_REF,\n+\t\t       cp_build_qualified_type (type, type_quals),\n+\t\t       expr, field, NULL_TREE);\n+\texpr = fold_if_not_in_template (expr);\n+\t\n+\t/* Mark the expression const or volatile, as appropriate.\n+\t   Even though we've dealt with the type above, we still have\n+\t   to mark the expression itself.  */\n+\tif (type_quals & TYPE_QUAL_CONST)\n+\t  TREE_READONLY (expr) = 1;\n+\tif (type_quals & TYPE_QUAL_VOLATILE)\n+\t  TREE_THIS_VOLATILE (expr) = 1;\n+\t\n+\treturn expr;\n+      }\n \n   /* Didn't find the base field?!?  */\n   gcc_unreachable ();\n@@ -1996,6 +2026,9 @@ update_vtable_entry_for_fn (tree t, tree binfo, tree fn, tree* virtuals,\n          also be converting to the return type of FN, we have to\n          combine the two conversions here.  */\n       tree fixed_offset, virtual_offset;\n+\n+      over_return = TREE_TYPE (over_return);\n+      base_return = TREE_TYPE (base_return);\n       \n       if (DECL_THUNK_P (fn))\n \t{\n@@ -2011,32 +2044,47 @@ update_vtable_entry_for_fn (tree t, tree binfo, tree fn, tree* virtuals,\n \t   overriding function. We will want the vbase offset from\n \t   there.  */\n \tvirtual_offset = binfo_for_vbase (BINFO_TYPE (virtual_offset),\n-\t\t\t\t\t  TREE_TYPE (over_return));\n-      else if (!same_type_p (TREE_TYPE (over_return),\n-\t\t\t     TREE_TYPE (base_return)))\n+\t\t\t\t\t  over_return);\n+      else if (!same_type_ignoring_top_level_qualifiers_p\n+\t       (over_return, base_return))\n \t{\n \t  /* There was no existing virtual thunk (which takes\n-\t     precedence).  */\n-\t  tree thunk_binfo;\n-\t  base_kind kind;\n-\t  \n-\t  thunk_binfo = lookup_base (TREE_TYPE (over_return),\n-\t\t\t\t     TREE_TYPE (base_return),\n-\t\t\t\t     ba_check | ba_quiet, &kind);\n+\t     precedence).  So find the binfo of the base function's\n+\t     return type within the overriding function's return type.\n+\t     We cannot call lookup base here, because we're inside a\n+\t     dfs_walk, and will therefore clobber the BINFO_MARKED\n+\t     flags.  Fortunately we know the covariancy is valid (it\n+\t     has already been checked), so we can just iterate along\n+\t     the binfos, which have been chained in inheritance graph\n+\t     order.  Of course it is lame that we have to repeat the\n+\t     search here anyway -- we should really be caching pieces\n+\t     of the vtable and avoiding this repeated work.  */\n+\t  tree thunk_binfo, base_binfo;\n+\n+\t  /* Find the base binfo within the overriding function's\n+\t     return type.  */\n+\t  for (base_binfo = TYPE_BINFO (base_return),\n+\t       thunk_binfo = TYPE_BINFO (over_return);\n+\t       !SAME_BINFO_TYPE_P (BINFO_TYPE (thunk_binfo),\n+\t\t\t\t   BINFO_TYPE (base_binfo));\n+\t       thunk_binfo = TREE_CHAIN (thunk_binfo))\n+\t    continue;\n \n-\t  if (thunk_binfo && (kind == bk_via_virtual\n-\t\t\t      || !BINFO_OFFSET_ZEROP (thunk_binfo)))\n+\t  /* See if virtual inheritance is involved.  */\n+\t  for (virtual_offset = thunk_binfo;\n+\t       virtual_offset;\n+\t       virtual_offset = BINFO_INHERITANCE_CHAIN (virtual_offset))\n+\t    if (BINFO_VIRTUAL_P (virtual_offset))\n+\t      break;\n+\t  \n+\t  if (virtual_offset || !BINFO_OFFSET_ZEROP (thunk_binfo))\n \t    {\n \t      tree offset = convert (ssizetype, BINFO_OFFSET (thunk_binfo));\n \n-\t      if (kind == bk_via_virtual)\n+\t      if (virtual_offset)\n \t\t{\n-\t\t  /* We convert via virtual base. Find the virtual\n-\t\t     base and adjust the fixed offset to be from there.  */\n-\t\t  while (!BINFO_VIRTUAL_P (thunk_binfo))\n-\t\t    thunk_binfo = BINFO_INHERITANCE_CHAIN (thunk_binfo);\n-\n-\t\t  virtual_offset = thunk_binfo;\n+\t\t  /* We convert via virtual base.  Adjust the fixed\n+\t\t     offset to be from there.  */\n \t\t  offset = size_diffop\n \t\t    (offset, convert\n \t\t     (ssizetype, BINFO_OFFSET (virtual_offset)));"}, {"sha": "f6a9b577dfc0c6387a4b56b7c742702d11b64a44", "filename": "gcc/cp/search.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12a669d1e1b3b14f15bf512479c664130f52c89d/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12a669d1e1b3b14f15bf512479c664130f52c89d/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=12a669d1e1b3b14f15bf512479c664130f52c89d", "patch": "@@ -1639,9 +1639,12 @@ tree\n dfs_walk_once (tree binfo, tree (*pre_fn) (tree, void *),\n \t       tree (*post_fn) (tree, void *), void *data)\n {\n+  static int active = 0;  /* We must not be called recursively. */\n   tree rval;\n \n   gcc_assert (pre_fn || post_fn);\n+  gcc_assert (!active);\n+  active++;\n   \n   if (!CLASSTYPE_DIAMOND_SHAPED_P (BINFO_TYPE (binfo)))\n     /* We are not diamond shaped, and therefore cannot encounter the\n@@ -1666,6 +1669,9 @@ dfs_walk_once (tree binfo, tree (*pre_fn) (tree, void *),\n       else\n \tdfs_unmark_r (binfo);\n     }\n+\n+  active--;\n+  \n   return rval;\n }\n "}, {"sha": "e0dc1ebdb4936923546ed8291ec9f769e43688ab", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12a669d1e1b3b14f15bf512479c664130f52c89d/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12a669d1e1b3b14f15bf512479c664130f52c89d/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=12a669d1e1b3b14f15bf512479c664130f52c89d", "patch": "@@ -1750,7 +1750,7 @@ build_class_member_access_expr (tree object, tree member,\n \t expression itself.  */\n       if (type_quals & TYPE_QUAL_CONST)\n \tTREE_READONLY (result) = 1;\n-      else if (type_quals & TYPE_QUAL_VOLATILE)\n+      if (type_quals & TYPE_QUAL_VOLATILE)\n \tTREE_THIS_VOLATILE (result) = 1;\n     }\n   else if (BASELINK_P (member))"}, {"sha": "78c096320fed27d24f5b7a10a23b5d34b925a720", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12a669d1e1b3b14f15bf512479c664130f52c89d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12a669d1e1b3b14f15bf512479c664130f52c89d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=12a669d1e1b3b14f15bf512479c664130f52c89d", "patch": "@@ -1,3 +1,8 @@\n+2005-02-14  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/19891\n+\t* g++.dg/abi/covariant4.C: New.\n+\n 2005-02-13  James A. Morrison  <phython@gcc.gnu.org>\n \n \t* gcc.dg/pr15784-1.c, gcc.dg/pr15784-2.c, gcc.dg/pr15784-3.c: New tests."}, {"sha": "942b1686e8a4b9b5566a231c6ccb99ecb14fcd47", "filename": "gcc/testsuite/g++.dg/abi/covariant4.C", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12a669d1e1b3b14f15bf512479c664130f52c89d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fcovariant4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12a669d1e1b3b14f15bf512479c664130f52c89d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fcovariant4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fcovariant4.C?ref=12a669d1e1b3b14f15bf512479c664130f52c89d", "patch": "@@ -0,0 +1,46 @@\n+// { dg-do run  }\n+\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 11 Feb 2005 <nathan@codesourcery.com>\n+\n+// Origin: bredelin@ucla.edu\n+// Bug 19891: Incorrect covariant vtables\n+\n+struct Model {\n+  bool full_tree;\n+  virtual Model* clone() const =0;\n+  virtual const char *name() const =0;\n+  virtual ~Model() {}\n+};\n+\n+struct R: virtual public Model {\n+  virtual R* clone() const =0;\n+};\n+struct A: virtual public Model {\n+  virtual A* clone() const=0;\n+};\n+struct RA: public R, public A {\n+  virtual RA* clone() const=0;\n+};\n+\n+static const char *string = \"EQU\";\n+\n+struct EQU: public RA {\n+  virtual EQU* clone() const {return new EQU(*this);}\n+  const char *name() const {return string;}\n+};\n+\n+int main() {\n+  Model* M1 = new EQU();\n+  Model* M2 = M1->clone();\n+  Model* M3 = M2->clone();\n+\n+  if (M1->name () != string)\n+    return 1;\n+  if (M2->name () != string)\n+    return 2;\n+  if (M3->name () != string)\n+    return 3;\n+  \n+  return 0;\n+}"}]}