{"sha": "94e136b95b163c60090dc0a711b07de03649aca1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTRlMTM2Yjk1YjE2M2M2MDA5MGRjMGE3MTFiMDdkZTAzNjQ5YWNhMQ==", "commit": {"author": {"name": "Yuri Rumyantsev", "email": "ysrumyan@gmail.com", "date": "2016-07-18T14:30:20Z"}, "committer": {"name": "Ilya Enkovich", "email": "ienkovich@gcc.gnu.org", "date": "2016-07-18T14:30:20Z"}, "message": "re PR middle-end/71734 (FAIL: libgomp.fortran/simd4.f90   -O3 -g  execution test)\n\ngcc/\n\n2016-07-18  Yuri Rumyantsev  <ysrumyan@gmail.com>\n\n\tPR tree-optimization/71734\n\t* tree-ssa-loop-im.c (ref_indep_loop_p_1): Add REF_LOOP argument which\n\tcontains REF, use it to check safelen, assume that safelen value\n\tmust be greater 1, fix style.\n\t(ref_indep_loop_p_2): Add REF_LOOP argument.\n\t(ref_indep_loop_p): Pass LOOP as additional argument to\n\tref_indep_loop_p_2.\n\ngcc/testsuite/\n\n2016-07-18  Yuri Rumyantsev  <ysrumyan@gmail.com>\n\n\tPR tree-optimization/71734\n\t* g++.dg/vect/pr70729.cc: Delete redundant dg options, fix style.\n\nFrom-SVN: r238435", "tree": {"sha": "1c8a92434360b3bcfd40b883259b77ed2484d39e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1c8a92434360b3bcfd40b883259b77ed2484d39e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/94e136b95b163c60090dc0a711b07de03649aca1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94e136b95b163c60090dc0a711b07de03649aca1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94e136b95b163c60090dc0a711b07de03649aca1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94e136b95b163c60090dc0a711b07de03649aca1/comments", "author": {"login": "ysrumyan", "id": 44425612, "node_id": "MDQ6VXNlcjQ0NDI1NjEy", "avatar_url": "https://avatars.githubusercontent.com/u/44425612?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ysrumyan", "html_url": "https://github.com/ysrumyan", "followers_url": "https://api.github.com/users/ysrumyan/followers", "following_url": "https://api.github.com/users/ysrumyan/following{/other_user}", "gists_url": "https://api.github.com/users/ysrumyan/gists{/gist_id}", "starred_url": "https://api.github.com/users/ysrumyan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ysrumyan/subscriptions", "organizations_url": "https://api.github.com/users/ysrumyan/orgs", "repos_url": "https://api.github.com/users/ysrumyan/repos", "events_url": "https://api.github.com/users/ysrumyan/events{/privacy}", "received_events_url": "https://api.github.com/users/ysrumyan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7072df0aae0c59ae437e5cc28e4e5e5777e930ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7072df0aae0c59ae437e5cc28e4e5e5777e930ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7072df0aae0c59ae437e5cc28e4e5e5777e930ba"}], "stats": {"total": 62, "additions": 40, "deletions": 22}, "files": [{"sha": "3f24fab978d2faa2ef42d0a3c6f7680237254264", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e136b95b163c60090dc0a711b07de03649aca1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e136b95b163c60090dc0a711b07de03649aca1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=94e136b95b163c60090dc0a711b07de03649aca1", "patch": "@@ -1,3 +1,13 @@\n+2016-07-18  Yuri Rumyantsev  <ysrumyan@gmail.com>\n+\n+\tPR tree-optimization/71734\n+\t* tree-ssa-loop-im.c (ref_indep_loop_p_1): Add REF_LOOP argument which\n+\tcontains REF, use it to check safelen, assume that safelen value\n+\tmust be greater 1, fix style.\n+\t(ref_indep_loop_p_2): Add REF_LOOP argument.\n+\t(ref_indep_loop_p): Pass LOOP as additional argument to\n+\tref_indep_loop_p_2.\n+\n 2016-07-18  Dominik Vogt  <vogt@linux.vnet.ibm.com>\n \n \t* cfgexpand.c (expand_stack_vars): Implement synamic stack space"}, {"sha": "30e214aabc0272e7fed53d37e8b69e80fceb03fa", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e136b95b163c60090dc0a711b07de03649aca1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e136b95b163c60090dc0a711b07de03649aca1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=94e136b95b163c60090dc0a711b07de03649aca1", "patch": "@@ -1,3 +1,8 @@\n+2016-07-18  Yuri Rumyantsev  <ysrumyan@gmail.com>\n+\n+\tPR tree-optimization/71734\n+\t* g++.dg/vect/pr70729.cc: Delete redundant dg options, fix style.\n+\n 2016-07-18  Dominik Vogt  <vogt@linux.vnet.ibm.com>\n \n \t* gcc.target/s390/warn-dynamicstack-1.c: New test."}, {"sha": "014de8c1c47eecc03492713695a8989f42d340a0", "filename": "gcc/testsuite/g++.dg/vect/pr70729.cc", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e136b95b163c60090dc0a711b07de03649aca1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fpr70729.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e136b95b163c60090dc0a711b07de03649aca1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fpr70729.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fpr70729.cc?ref=94e136b95b163c60090dc0a711b07de03649aca1", "patch": "@@ -1,14 +1,13 @@\n // { dg-do compile }\n-// { dg-require-effective-target vect_simd_clones }\n-// { dg-additional-options \"-Ofast\" }\n-// { dg-additional-options \"-mavx2 -fopenmp-simd\" { target x86_64-*-* i?86-*-* } }\n+// { dg-additional-options \"-ffast-math -fopenmp-simd\" }\n+// { dg-additional-options \"-msse2\" { target x86_64-*-* i?86-*-* } }\n \n \n #include <string.h>\n #include <xmmintrin.h>\n \n-inline void* my_alloc(size_t bytes) {return _mm_malloc(bytes, 128);}\n-inline void my_free(void* memory) {_mm_free(memory);}\n+inline void* my_alloc (size_t bytes) {return _mm_malloc (bytes, 128);}\n+inline void my_free (void* memory) {_mm_free (memory);}\n \n template <typename T>\n class Vec\n@@ -18,13 +17,13 @@ class Vec\n \n public:\n \n-  Vec (int n) : isize(n) {data = (T*)my_alloc(isize*sizeof(T));}\n+  Vec (int n) : isize (n) {data = (T*)my_alloc (isize*sizeof (T));}\n   ~Vec () {my_free(data);}\n \n   Vec& operator = (const Vec& other)\t\n     {\n       if (this != &other)\n-\tmemcpy(data, other.data, isize*sizeof(T));\n+\tmemcpy (data, other.data, isize*sizeof (T));\n       return *this;\n     }\n \n@@ -67,12 +66,12 @@ struct Ss\n void Ss::foo (float *in, float w)\n {\n #pragma omp simd\n-  for (int i=0; i<S_n; i++)\n+  for (int i = 0; i < S_n; i++)\n     {\n       float w1 = C2[S_n + i] * w;\n       v1.v_i[i] += (int)w1;\n       C1[S_n + i] += w1;\n     }\n }\n  \n-// { dg-final { scan-tree-dump \"LOOP VECTORIZED\" \"vect\" } }\n+// { dg-final { scan-tree-dump \"LOOP VECTORIZED\" \"vect\" { target x86_64-*-* i?86-*-* } } }"}, {"sha": "278f60ab3fa1bcc3e0b0f588e6dbb5ac74acfa70", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e136b95b163c60090dc0a711b07de03649aca1/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e136b95b163c60090dc0a711b07de03649aca1/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=94e136b95b163c60090dc0a711b07de03649aca1", "patch": "@@ -2109,11 +2109,12 @@ record_dep_loop (struct loop *loop, im_mem_ref *ref, bool stored_p)\n     loop = loop_outer (loop);\n }\n \n-/* Returns true if REF is independent on all other memory references in\n-   LOOP.  */\n+/* Returns true if REF in REF_LOOP is independent on all other memory\n+   references in LOOP.  */\n \n static bool\n-ref_indep_loop_p_1 (struct loop *loop, im_mem_ref *ref, bool stored_p)\n+ref_indep_loop_p_1 (struct loop *ref_loop, struct loop *loop,\n+\t\t    im_mem_ref *ref, bool stored_p)\n {\n   bitmap refs_to_check;\n   unsigned i;\n@@ -2128,13 +2129,14 @@ ref_indep_loop_p_1 (struct loop *loop, im_mem_ref *ref, bool stored_p)\n   if (bitmap_bit_p (refs_to_check, UNANALYZABLE_MEM_ID))\n     return false;\n \n-  if (loop->safelen > 0)\n+  if (ref_loop->safelen > 1)\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n-\t  fprintf(dump_file,\"Consider REF independent in loop#%d\\n\", loop->num);\n-\t  print_generic_expr(dump_file, ref->mem.ref, TDF_SLIM);\n-\t  fprintf(dump_file, \"\\n\");\n+\t  fprintf (dump_file,\"REF is independent in ref_loop#%d\\n\",\n+\t\t   ref_loop->num);\n+\t  print_generic_expr (dump_file, ref->mem.ref, TDF_SLIM);\n+\t  fprintf (dump_file, \"\\n\");\n \t}\n       return true;\n     }\n@@ -2149,11 +2151,13 @@ ref_indep_loop_p_1 (struct loop *loop, im_mem_ref *ref, bool stored_p)\n   return true;\n }\n \n-/* Returns true if REF is independent on all other memory references in\n-   LOOP.  Wrapper over ref_indep_loop_p_1, caching its results.  */\n+/* Returns true if REF in REF_LOOP is independent on all other memory\n+   references in LOOP.  Wrapper over ref_indep_loop_p_1, caching its\n+   results.  */\n \n static bool\n-ref_indep_loop_p_2 (struct loop *loop, im_mem_ref *ref, bool stored_p)\n+ref_indep_loop_p_2 (struct loop *ref_loop, struct loop *loop,\n+\t\t    im_mem_ref *ref, bool stored_p)\n {\n   stored_p |= (ref->stored && bitmap_bit_p (ref->stored, loop->num));\n \n@@ -2165,12 +2169,12 @@ ref_indep_loop_p_2 (struct loop *loop, im_mem_ref *ref, bool stored_p)\n   struct loop *inner = loop->inner;\n   while (inner)\n     {\n-      if (!ref_indep_loop_p_2 (inner, ref, stored_p))\n+      if (!ref_indep_loop_p_2 (ref_loop, inner, ref, stored_p))\n \treturn false;\n       inner = inner->next;\n     }\n \n-  bool indep_p = ref_indep_loop_p_1 (loop, ref, stored_p);\n+  bool indep_p = ref_indep_loop_p_1 (ref_loop, loop, ref, stored_p);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"Querying dependencies of ref %u in loop %d: %s\\n\",\n@@ -2209,7 +2213,7 @@ ref_indep_loop_p (struct loop *loop, im_mem_ref *ref)\n {\n   gcc_checking_assert (MEM_ANALYZABLE (ref));\n \n-  return ref_indep_loop_p_2 (loop, ref, false);\n+  return ref_indep_loop_p_2 (loop, loop, ref, false);\n }\n \n /* Returns true if we can perform store motion of REF from LOOP.  */"}]}