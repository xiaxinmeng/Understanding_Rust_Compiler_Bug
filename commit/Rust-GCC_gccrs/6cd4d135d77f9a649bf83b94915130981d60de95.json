{"sha": "6cd4d135d77f9a649bf83b94915130981d60de95", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmNkNGQxMzVkNzdmOWE2NDliZjgzYjk0OTE1MTMwOTgxZDYwZGU5NQ==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2013-08-20T15:51:18Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2013-08-20T15:51:18Z"}, "message": "Revert my last two changes, r201865 and r201864\n\n2013-08-20  David Malcolm  <dmalcolm@redhat.com>\n\n\tRevert my last two changes, r201865 and r201864:\n\n\tRevert r201865:\n\t2013-08-20  David Malcolm  <dmalcolm@redhat.com>\n\n\tMake opt_pass and gcc::pass_manager be GC-managed, so that pass\n\tinstances can own GC refs.\n\n\t* Makefile.in (GTFILES): Add pass_manager.h and tree-pass.h.\n\t* context.c (gcc::context::gt_ggc_mx): Traverse passes_.\n\t(gcc::context::gt_pch_nx): Likewise.\n\t(gcc::context::gt_pch_nx):  Likewise.\n\t* ggc.h (gt_ggc_mx <T>): New.\n\t(gt_pch_nx_with_op <T>): New.\n\t(gt_pch_nx <T>): New.\n\t* passes.c (opt_pass::gt_ggc_mx): New.\n\t(opt_pass::gt_pch_nx): New.\n\t(opt_pass::gt_pch_nx_with_op): New.\n\t(pass_manager::gt_ggc_mx): New.\n\t(pass_manager::gt_pch_nx): New.\n\t(pass_manager::gt_pch_nx_with_op): New.\n\t(pass_manager::operator new): Use\n\tggc_internal_cleared_alloc_stat rather than xcalloc.\n\t* pass_manager.h (class pass_manager): Add GTY((user)) marking.\n\t(pass_manager::gt_ggc_mx): New.\n\t(pass_manager::gt_pch_nx): New.\n\t(pass_manager::gt_pch_nx_with_op): New.\n\t* tree-pass.h (class opt_pass): Add GTY((user)) marking.\n\t(opt_pass::operator new): New.\n\t(opt_pass::gt_ggc_mx): New.\n\t(opt_pass::gt_pch_nx): New.\n\t(opt_pass::gt_pch_nx_with_op): New.\n\n\tRevert r201864:\n\t2013-08-20  David Malcolm  <dmalcolm@redhat.com>\n\n\t* Makefile.in (GTFILES): Add context.h.\n\t* context.c (gcc::context::operator new): New.\n\t(gcc::context::gt_ggc_mx): New.\n\t(gcc::context::gt_pch_nx): New.\n\t(gcc::context::gt_pch_nx): New.\n\t* context.h (gcc::context): Add GTY((user)) marking.\n\t(gcc::context::operator new): New.\n\t(gcc::context::gt_ggc_mx): New.\n\t(gcc::context::gt_pch_nx): New.\n\t(gcc::context::gt_pch_nx): New.\n\t(g): Add GTY marking.\n\t(gt_ggc_mx (gcc::context *)): New.\n\t(gt_pch_nx (gcc::context *)): New.\n\t(gt_pch_nx (gcc::context *ctxt, gt_pointer_operator op,\n\tvoid *cookie)): New.\n\t* gengtype.c (open_base_files) <ifiles>: Add context.h.\n\nFrom-SVN: r201887", "tree": {"sha": "b21ed1e25159a34a0891b23327ff60b090410491", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b21ed1e25159a34a0891b23327ff60b090410491"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6cd4d135d77f9a649bf83b94915130981d60de95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cd4d135d77f9a649bf83b94915130981d60de95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6cd4d135d77f9a649bf83b94915130981d60de95", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cd4d135d77f9a649bf83b94915130981d60de95/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a046136a50df8d31ec75e1dd2b1279d028431d51", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a046136a50df8d31ec75e1dd2b1279d028431d51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a046136a50df8d31ec75e1dd2b1279d028431d51"}], "stats": {"total": 353, "additions": 62, "deletions": 291}, "files": [{"sha": "fa97b87157ce32ead1e0f94c67f4b4cb4ec869d8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cd4d135d77f9a649bf83b94915130981d60de95/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cd4d135d77f9a649bf83b94915130981d60de95/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6cd4d135d77f9a649bf83b94915130981d60de95", "patch": "@@ -1,3 +1,58 @@\n+2013-08-20  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tRevert my last two changes, r201865 and r201864:\n+\n+\tRevert r201865:\n+\t2013-08-20  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tMake opt_pass and gcc::pass_manager be GC-managed, so that pass\n+\tinstances can own GC refs.\n+\n+\t* Makefile.in (GTFILES): Add pass_manager.h and tree-pass.h.\n+\t* context.c (gcc::context::gt_ggc_mx): Traverse passes_.\n+\t(gcc::context::gt_pch_nx): Likewise.\n+\t(gcc::context::gt_pch_nx):  Likewise.\n+\t* ggc.h (gt_ggc_mx <T>): New.\n+\t(gt_pch_nx_with_op <T>): New.\n+\t(gt_pch_nx <T>): New.\n+\t* passes.c (opt_pass::gt_ggc_mx): New.\n+\t(opt_pass::gt_pch_nx): New.\n+\t(opt_pass::gt_pch_nx_with_op): New.\n+\t(pass_manager::gt_ggc_mx): New.\n+\t(pass_manager::gt_pch_nx): New.\n+\t(pass_manager::gt_pch_nx_with_op): New.\n+\t(pass_manager::operator new): Use\n+\tggc_internal_cleared_alloc_stat rather than xcalloc.\n+\t* pass_manager.h (class pass_manager): Add GTY((user)) marking.\n+\t(pass_manager::gt_ggc_mx): New.\n+\t(pass_manager::gt_pch_nx): New.\n+\t(pass_manager::gt_pch_nx_with_op): New.\n+\t* tree-pass.h (class opt_pass): Add GTY((user)) marking.\n+\t(opt_pass::operator new): New.\n+\t(opt_pass::gt_ggc_mx): New.\n+\t(opt_pass::gt_pch_nx): New.\n+\t(opt_pass::gt_pch_nx_with_op): New.\n+\n+\tRevert r201864:\n+\t2013-08-20  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* Makefile.in (GTFILES): Add context.h.\n+\t* context.c (gcc::context::operator new): New.\n+\t(gcc::context::gt_ggc_mx): New.\n+\t(gcc::context::gt_pch_nx): New.\n+\t(gcc::context::gt_pch_nx): New.\n+\t* context.h (gcc::context): Add GTY((user)) marking.\n+\t(gcc::context::operator new): New.\n+\t(gcc::context::gt_ggc_mx): New.\n+\t(gcc::context::gt_pch_nx): New.\n+\t(gcc::context::gt_pch_nx): New.\n+\t(g): Add GTY marking.\n+\t(gt_ggc_mx (gcc::context *)): New.\n+\t(gt_pch_nx (gcc::context *)): New.\n+\t(gt_pch_nx (gcc::context *ctxt, gt_pointer_operator op,\n+\tvoid *cookie)): New.\n+\t* gengtype.c (open_base_files) <ifiles>: Add context.h.\n+\n 2013-08-20  Alexey Makhalov  <makhaloff@gmail.com>\n \n \t* dce.c (fini_dce): Call df_analyze again just in case"}, {"sha": "6034046374a96e66b89d772d724fb400d304d2be", "filename": "gcc/Makefile.in", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cd4d135d77f9a649bf83b94915130981d60de95/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cd4d135d77f9a649bf83b94915130981d60de95/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=6cd4d135d77f9a649bf83b94915130981d60de95", "patch": "@@ -3831,9 +3831,6 @@ GTFILES = $(CPP_ID_DATA_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/vtable-verify.c \\\n   $(srcdir)/asan.c \\\n   $(srcdir)/tsan.c $(srcdir)/ipa-devirt.c \\\n-  $(srcdir)/context.h \\\n-  $(srcdir)/pass_manager.h \\\n-  $(srcdir)/tree-pass.h \\\n   @all_gtfiles@\n \n # Compute the list of GT header files from the corresponding C sources,"}, {"sha": "b5152419a971a427f5508c74d40bc27e4fea3ad3", "filename": "gcc/context.c", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cd4d135d77f9a649bf83b94915130981d60de95/gcc%2Fcontext.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cd4d135d77f9a649bf83b94915130981d60de95/gcc%2Fcontext.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcontext.c?ref=6cd4d135d77f9a649bf83b94915130981d60de95", "patch": "@@ -27,33 +27,7 @@ along with GCC; see the file COPYING3.  If not see\n /* The singleton holder of global state: */\n gcc::context *g;\n \n-void *\n-gcc::context::operator new (std::size_t size)\n-{\n-  return ggc_internal_cleared_alloc_stat (size MEM_STAT_INFO);\n-}\n-\n gcc::context::context()\n {\n   passes_ = new gcc::pass_manager (this);\n }\n-\n-/* Functions relating to the garbage collector.  */\n-void\n-gcc::context::gt_ggc_mx ()\n-{\n-  ::gt_ggc_mx (passes_);\n-}\n-\n-void\n-gcc::context::gt_pch_nx ()\n-{\n-  ::gt_pch_nx (passes_);\n-}\n-\n-void\n-gcc::context::gt_pch_nx (gt_pointer_operator op ATTRIBUTE_UNUSED,\n-\t\t\t void *cookie ATTRIBUTE_UNUSED)\n-{\n-  op (&passes_, cookie);\n-}"}, {"sha": "66260cd279a782209e29855c6c82ac36f6af43f6", "filename": "gcc/context.h", "status": "modified", "additions": 2, "deletions": 57, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cd4d135d77f9a649bf83b94915130981d60de95/gcc%2Fcontext.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cd4d135d77f9a649bf83b94915130981d60de95/gcc%2Fcontext.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcontext.h?ref=6cd4d135d77f9a649bf83b94915130981d60de95", "patch": "@@ -27,30 +27,11 @@ class pass_manager;\n /* GCC's internal state can be divided into zero or more\n    \"parallel universe\" of state; an instance of this class is one such\n    context of state.  */\n-class GTY((user)) context\n+class context\n {\n public:\n-  /* Ensure that instances are allocated within the GC-heap.  */\n-  void *operator new (std::size_t size);\n-\n   context();\n \n-  /* Garbage-collector integration.\n-\n-     Each context assumes it has full control of the GC-heap that it\n-     is associated with.  It acts as a root for that GC-heap, owning\n-     references to within it.\n-\n-     Note that context instances are allocated within their own GC\n-     heap.\n-\n-     The methods are called the *first time* that the context is reached\n-     during a ggc/pch traversal, rather than every time.  */\n-\n-  void gt_ggc_mx ();\n-  void gt_pch_nx ();\n-  void gt_pch_nx (gt_pointer_operator op, void *cookie);\n-\n   /* Pass-management.  */\n \n   pass_manager *get_passes () { gcc_assert (passes_); return passes_; }\n@@ -65,42 +46,6 @@ class GTY((user)) context\n \n /* The global singleton context aka \"g\".\n    (the name is chosen to be easy to type in a debugger).  */\n-extern GTY(()) gcc::context *g;\n-\n-/* Global hooks for ggc/pch.\n-\n-   The gcc::context class is marked with GTY((user)), which leads to\n-   gengtype creating autogenerated functions for handling context within\n-   gtype-desc.c:\n-\n-     void gt_ggc_mx_context (void *x_p);\n-     void gt_pch_nx_context (void *x_p)\n-     void gt_pch_p_7context (void *this_obj,\n-\t\t\t     void *x_p,\n-\t\t\t     gt_pointer_operator op,\n-\t\t\t     void *cookie);\n-\n-   Those functions call the following global functions the first time\n-   that the context is reached during a traversal, and the following\n-   global functions in turn simply call the corresponding  methods of the\n-   context (so that they can access private fields of the context).  */\n-\n-inline void\n-gt_ggc_mx (gcc::context *ctxt)\n-{\n-  ctxt->gt_ggc_mx ();\n-}\n-\n-inline void\n-gt_pch_nx (gcc::context *ctxt)\n-{\n-  ctxt->gt_pch_nx ();\n-}\n-\n-inline void\n-gt_pch_nx (gcc::context *ctxt, gt_pointer_operator op, void *cookie)\n-{\n-  ctxt->gt_pch_nx (op, cookie);\n-}\n+extern gcc::context *g;\n \n #endif /* ! GCC_CONTEXT_H */"}, {"sha": "c12a4e2393d750da08a1acc3e89d34a6b8ca6da9", "filename": "gcc/gengtype.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cd4d135d77f9a649bf83b94915130981d60de95/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cd4d135d77f9a649bf83b94915130981d60de95/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=6cd4d135d77f9a649bf83b94915130981d60de95", "patch": "@@ -1739,7 +1739,7 @@ open_base_files (void)\n       \"tree-flow.h\", \"reload.h\", \"cpp-id-data.h\", \"tree-chrec.h\",\n       \"except.h\", \"output.h\", \"gimple.h\", \"cfgloop.h\",\n       \"target.h\", \"ipa-prop.h\", \"lto-streamer.h\", \"target-globals.h\",\n-      \"ipa-inline.h\", \"dwarf2out.h\", \"context.h\", NULL\n+      \"ipa-inline.h\", \"dwarf2out.h\", NULL\n     };\n     const char *const *ifp;\n     outf_p gtype_desc_c;"}, {"sha": "b31bc80489f2a50aed4b110d4c7035805000b924", "filename": "gcc/ggc.h", "status": "modified", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cd4d135d77f9a649bf83b94915130981d60de95/gcc%2Fggc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cd4d135d77f9a649bf83b94915130981d60de95/gcc%2Fggc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc.h?ref=6cd4d135d77f9a649bf83b94915130981d60de95", "patch": "@@ -276,50 +276,4 @@ ggc_alloc_cleared_gimple_statement_d_stat (size_t s MEM_STAT_DECL)\n     ggc_internal_cleared_alloc_stat (s PASS_MEM_STAT);\n }\n \n-/* gengtype will autogenerate traversal functions (in gtype-desc.c) for\n-   all GTY-marked types that it sees are referenced by a GTY marker.\n-\n-   Unfortunately, it will not generate traveral functions for types that\n-   are only referenced by GTY((user)) types.\n-\n-   The following templates are a substitute, providing equivalent\n-   traversal functions for such types.  They are instantiated for\n-   types whose objects that are traversed during GC/PCH, and are\n-   called *every time* that an instance of type T is traversed during\n-   GC/PCH.\n-\n-   They require the presence of the following member functions\n-\n-     void gt_ggc_mx ();\n-     void gt_pch_nx ();\n-     void gt_pch_nx_with_op (gt_pointer_operator op, void *cookie);\n-\n-   within class T, which are called *once* per object - the first\n-   time the object is visited during the traversal.  */\n-\n-template<class T>\n-inline void gt_ggc_mx (T *p)\n-{\n-  if (ggc_test_and_set_mark (p))\n-    p->gt_ggc_mx ();\n-}\n-\n-template<class T>\n-void gt_pch_nx_with_op (void *this_obj, void *p,\n-\t\t\tgt_pointer_operator op, void *cookie)\n-{\n-  if (p == this_obj)\n-    {\n-      T *t = static_cast<T *>(p);\n-      t->gt_pch_nx_with_op (op, cookie);\n-    }\n-}\n-\n-template<class T>\n-inline void gt_pch_nx (T *p)\n-{\n-  if (gt_pch_note_object (p, p, gt_pch_nx_with_op<T>))\n-    p->gt_pch_nx ();\n-}\n-\n #endif"}, {"sha": "41d2c7605d24e08dd4341b0649f4f03e4c1129c9", "filename": "gcc/pass_manager.h", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cd4d135d77f9a649bf83b94915130981d60de95/gcc%2Fpass_manager.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cd4d135d77f9a649bf83b94915130981d60de95/gcc%2Fpass_manager.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpass_manager.h?ref=6cd4d135d77f9a649bf83b94915130981d60de95", "patch": "@@ -44,19 +44,13 @@ namespace gcc {\n \n class context;\n \n-class GTY((user)) pass_manager\n+class pass_manager\n {\n public:\n-  /* Ensure that instances are allocated in the GC-managed heap.  */\n   void *operator new (size_t sz);\n \n   pass_manager(context *ctxt);\n \n-  /* GTY((user)) methods.  */\n-  void gt_ggc_mx ();\n-  void gt_pch_nx ();\n-  void gt_pch_nx_with_op (gt_pointer_operator op, void *cookie);\n-\n   void register_pass (struct register_pass_info *pass_info);\n   void register_one_dump_file (struct opt_pass *pass);\n \n@@ -140,3 +134,4 @@ class GTY((user)) pass_manager\n } // namespace gcc\n \n #endif /* ! GCC_PASS_MANAGER_H */\n+"}, {"sha": "e3a7212ccce3574bcf56973cdc238a253a1cc314", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 139, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cd4d135d77f9a649bf83b94915130981d60de95/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cd4d135d77f9a649bf83b94915130981d60de95/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=6cd4d135d77f9a649bf83b94915130981d60de95", "patch": "@@ -82,58 +82,6 @@ struct opt_pass *current_pass;\n \n static void register_pass_name (struct opt_pass *, const char *);\n \n-void*\n-opt_pass::operator new (size_t sz)\n-{\n-  return ggc_internal_cleared_alloc_stat (sz MEM_STAT_INFO);\n-}\n-\n-void opt_pass::gt_ggc_mx ()\n-{\n-  ::gt_ggc_mx (ctxt_);\n-  ::gt_ggc_mx (sub);\n-\n-  /* Avoid deep stack usage by iteratively walking the chain of \"next\"\n-     passes, rather than recursing (analogous to the chain_next/chain_prev\n-     GTY options).  */\n-\n-  /* \"this\" has already been marked.\n-     Mark a chain of as-yet-unmarked passes.  */\n-  opt_pass *limit = this->next;\n-  while (ggc_test_and_set_mark (limit))\n-    limit = limit->next;\n-\n-  /* \"limit\" is the first in the chain that wasn't just marked, either\n-     because it is NULL, or because it was already marked.\n-     Hence all of the passes in the half-open interval:\n-\t[this->next...limit)\n-     have just been marked: visit them.  */\n-  for (opt_pass *iter = this->next; iter != limit; iter = iter->next)\n-    iter->gt_ggc_mx ();\n-}\n-\n-void opt_pass::gt_pch_nx ()\n-{\n-  ::gt_pch_nx (ctxt_);\n-  ::gt_pch_nx (sub);\n-\n-  /* Analogous to opt_pass::gt_ggc_mx.  */\n-  opt_pass *limit = this->next;\n-  while (gt_pch_note_object (limit, limit, ::gt_pch_nx_with_op<opt_pass>))\n-    limit = limit->next;\n-\n- for (opt_pass *iter = this->next; iter != limit; iter = iter->next)\n-    iter->gt_pch_nx ();\n-\n-}\n-\n-void opt_pass::gt_pch_nx_with_op (gt_pointer_operator op, void *cookie)\n-{\n-  op (&(ctxt_), cookie);\n-  op (&(sub), cookie);\n-  op (&(next), cookie);\n-}\n-\n /* Most passes are single-instance (within their context) and thus don't\n    need to implement cloning, but passes that support multiple instances\n    *must* provide their own implementation of the clone method.\n@@ -168,92 +116,6 @@ opt_pass::opt_pass(const pass_data &data, context *ctxt)\n {\n }\n \n-void\n-pass_manager::gt_ggc_mx ()\n-{\n-  /* We want to efficiently visit all pass objects without incurring deep\n-     call chains that could blow the stack.\n-\n-     Although there are multiple fields referencing passes within the\n-     pass_manager, *almost* all of the underlying pass instances are\n-     referenced by the passes_by_id array.\n-\n-     Specifically, passes are in the passes_by_id array if they have\n-     register_one_dump_file called on them, which requires them to have\n-     a name, and for that name to *not* begin with \"*\".  Currently\n-     there are 25 passes with a \"*\" prefix and thus not in the array.\n-\n-     Each pass holds references to its sub and next, so visiting a pass\n-     will potentially trigger a recursive traversal through these\n-     neighbours - if these passes haven't been visited yet.\n-\n-     By walking the passes_by_id array *backwards*, in the common case\n-     this leads to us walking the pass tree from the leaf passes first,\n-     eventually reaching the trunk passes, and hence none of the calls\n-     should recurse, given that at each point in the iteration pass->sub\n-     and pass->next will already have been marked.\n-\n-     Having walked the array, we then walk the higher-level fields,\n-     again in bottom-up order, which will ensure that we visit all\n-     remaining passes.  Most of the passes will have already been\n-     visited, which should minimize further recursion.  */\n-  for (int i = passes_by_id_size ; i > 0; )\n-    ::gt_ggc_mx (passes_by_id[--i]);\n-\n-  ::gt_ggc_mx (all_late_ipa_passes);\n-  ::gt_ggc_mx (all_lto_gen_passes);\n-  ::gt_ggc_mx (all_regular_ipa_passes);\n-  ::gt_ggc_mx (all_lowering_passes);\n-  ::gt_ggc_mx (all_small_ipa_passes);\n-  ::gt_ggc_mx (all_passes);\n-}\n-\n-void\n-pass_manager::gt_pch_nx ()\n-{\n-  /* Analogous to pass_manager::gt_ggc_mx */\n-  for (int i = passes_by_id_size ; i > 0; )\n-    ::gt_pch_nx (passes_by_id[--i]);\n-\n-  ::gt_pch_nx (all_late_ipa_passes);\n-  ::gt_pch_nx (all_lto_gen_passes);\n-  ::gt_pch_nx (all_regular_ipa_passes);\n-  ::gt_pch_nx (all_lowering_passes);\n-  ::gt_pch_nx (all_small_ipa_passes);\n-  ::gt_pch_nx (all_passes);\n-}\n-\n-void\n-pass_manager::gt_pch_nx_with_op (gt_pointer_operator op, void *cookie)\n-{\n-  /* Unlike the _mx and _nx hooks, we must visit *every* field, since\n-     they must each be reconstructed when reading the data back from\n-     disk.  */\n-  op (&(all_passes), cookie);\n-  op (&(all_small_ipa_passes), cookie);\n-  op (&(all_lowering_passes), cookie);\n-  op (&(all_regular_ipa_passes), cookie);\n-  op (&(all_lto_gen_passes), cookie);\n-  op (&(all_late_ipa_passes), cookie);\n-\n-  for (int i = 0; i < passes_by_id_size; i++)\n-    op (&(passes_by_id[i]), cookie);\n-\n-#define INSERT_PASSES_AFTER(PASS)\n-#define PUSH_INSERT_PASSES_WITHIN(PASS)\n-#define POP_INSERT_PASSES()\n-#define NEXT_PASS(PASS, NUM) op (&(PASS ## _ ## NUM), cookie);\n-#define TERMINATE_PASS_LIST()\n-\n-#include \"pass-instances.def\"\n-\n-#undef INSERT_PASSES_AFTER\n-#undef PUSH_INSERT_PASSES_WITHIN\n-#undef POP_INSERT_PASSES\n-#undef NEXT_PASS\n-#undef TERMINATE_PASS_LIST\n-\n-}\n \n void\n pass_manager::execute_early_local_passes ()\n@@ -1602,7 +1464,7 @@ void *\n pass_manager::operator new (size_t sz)\n {\n   /* Ensure that all fields of the pass manager are zero-initialized.  */\n-  return ggc_internal_cleared_alloc_stat (sz MEM_STAT_INFO);\n+  return xcalloc (1, sz);\n }\n \n pass_manager::pass_manager (context *ctxt)"}, {"sha": "787a49b7c41fbaeb27e9547466733d9ca831a09b", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cd4d135d77f9a649bf83b94915130981d60de95/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cd4d135d77f9a649bf83b94915130981d60de95/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=6cd4d135d77f9a649bf83b94915130981d60de95", "patch": "@@ -76,22 +76,11 @@ namespace gcc\n \n /* An instance of a pass.  This is also \"pass_data\" to minimize the\n    changes in existing code.  */\n-class GTY((user)) opt_pass : public pass_data\n+class opt_pass : public pass_data\n {\n public:\n-  /* Ensure that instances are allocated in the GC-managed heap.  */\n-  void *operator new (size_t sz);\n-\n   virtual ~opt_pass () { }\n \n-  /* GTY((user)) methods, to be called once per traversal.\n-     opt_pass subclasses with additional GC-managed data should override\n-     these, chain up to the base class implementation, then walk their\n-     extra fields.  */\n-  virtual void gt_ggc_mx ();\n-  virtual void gt_pch_nx ();\n-  virtual void gt_pch_nx_with_op (gt_pointer_operator op, void *cookie);\n-\n   /* Create a copy of this pass.\n \n      Passes that can have multiple instances must provide their own"}]}