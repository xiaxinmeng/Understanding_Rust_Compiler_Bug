{"sha": "a42a5f59d0f51034f35d3fe2fed40b8dd3540c37", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTQyYTVmNTlkMGY1MTAzNGYzNWQzZmUyZmVkNDBiOGRkMzU0MGMzNw==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2001-01-20T09:12:08Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2001-01-20T09:12:08Z"}, "message": "[multiple changes]\n\n2001-01-20  Jakub Jelinek  <jakub@redhat.com>\n\n\t* function.c (fixup_var_refs): Move CALL_PLACEHOLDER handling...\n\t(fixup_var_refs_insns): ...here.\n\n\t* gcc.c-torture/compile/20010118-1.c: New test.\n\n2001-01-20  Zack Weinberg  <zack@wolery.stanford.edu>\n\n\t* function.c (fixup_var_refs_insns): Break up into\n\tfixup_var_refs_insn [body of loop], fixup_var_refs_insns\n\t[loop over entire insn list], and fixup_var_refs_insns_with_hash\n\t[loop over hash table entries].\n\t(fixup_var_refs): Adjust calls to fixup_var_refs_insns and/or\n\tfixup_var_refs_insns_with_hash, to match above changes.\n\nFrom-SVN: r39151", "tree": {"sha": "c829264e3cc3482b3669733f988153e0b3d67c11", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c829264e3cc3482b3669733f988153e0b3d67c11"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a42a5f59d0f51034f35d3fe2fed40b8dd3540c37", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a42a5f59d0f51034f35d3fe2fed40b8dd3540c37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a42a5f59d0f51034f35d3fe2fed40b8dd3540c37", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a42a5f59d0f51034f35d3fe2fed40b8dd3540c37/comments", "author": null, "committer": null, "parents": [{"sha": "1b7f6755f98816a7477332204b06993b830a985c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b7f6755f98816a7477332204b06993b830a985c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b7f6755f98816a7477332204b06993b830a985c"}], "stats": {"total": 632, "additions": 350, "deletions": 282}, "files": [{"sha": "46627c84cf598c635ef8047125db2d82b1172a28", "filename": "gcc/ChangeLog", "status": "modified", "additions": 81, "deletions": 65, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a5f59d0f51034f35d3fe2fed40b8dd3540c37/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a5f59d0f51034f35d3fe2fed40b8dd3540c37/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a42a5f59d0f51034f35d3fe2fed40b8dd3540c37", "patch": "@@ -1,3 +1,19 @@\n+2001-01-20  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* function.c (fixup_var_refs): Move CALL_PLACEHOLDER handling...\n+\t(fixup_var_refs_insns): ...here.\n+\n+\t* gcc.c-torture/compile/20010118-1.c: New test.\n+\n+2001-01-20  Zack Weinberg  <zack@wolery.stanford.edu>\n+\n+\t* function.c (fixup_var_refs_insns): Break up into\n+\tfixup_var_refs_insn [body of loop], fixup_var_refs_insns\n+\t[loop over entire insn list], and fixup_var_refs_insns_with_hash\n+\t[loop over hash table entries].\n+\t(fixup_var_refs): Adjust calls to fixup_var_refs_insns and/or\n+\tfixup_var_refs_insns_with_hash, to match above changes.\n+\n 2001-01-19  John David Anglin  <dave@hiauly1.hia.nrc.ca>\n \n \t* Makefile.in (ORDINARY_FLAGS_TO_PASS): Add MAKEOVERRIDES variable.\n@@ -12,7 +28,7 @@\n \n 2001-01-19  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n-        * cppinternals.texi: Update.\n+\t* cppinternals.texi: Update.\n \n 2001-01-19  Richard Earnshaw  <rearnsha@arm.com>\n \n@@ -71,8 +87,8 @@ Thu Jan 18 06:43:04 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n 2001-01-18  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n-        * cpplib.c (_cpp_handle_directive): Use buffer->was_skipping,\n-        not pfile->skipping (== 0).\n+\t* cpplib.c (_cpp_handle_directive): Use buffer->was_skipping,\n+\tnot pfile->skipping (== 0).\n \n 2001-01-17  Nick Clifton  <nickc@redhat.com>\n \n@@ -90,7 +106,7 @@ Thu Jan 18 06:43:04 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n 2001-01-17  Aldy Hernandez  <aldyh@redhat.com>\n \n-        * invoke.texi (-fno-guess-branch-probability): New option.\n+\t* invoke.texi (-fno-guess-branch-probability): New option.\n \n Wed Jan 17 13:26:34 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n@@ -152,7 +168,7 @@ Tue Jan 16 17:20:43 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \t(movqi_internal, movhi_internal, movsi_internal, movdi_internal,\n \tmovsf_internal, movdf_internal, movtf_internal, cmovdi_internal,\n \tcmovsi_internal): Delete ! TARGET_A_STEP check.\n-\t\n+\n 2001-01-16  Gerald Pfeifer  <pfeifer@dbai.tuwien.ac.at>\n \n \t* gcc.texi (Bug Lists): Do not mention newsgroups nor the\n@@ -165,7 +181,7 @@ Tue Jan 16 17:20:43 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n 2001-01-16  Alan Modra <alan@linuxcare.com.au>\n \n-        * cppmain.c (general_init): Don't use ANSI prototype.\n+\t* cppmain.c (general_init): Don't use ANSI prototype.\n \n 2001-01-16  Tom Tromey  <tromey@redhat.com>\n \n@@ -268,7 +284,7 @@ Tue Jan 16 17:20:43 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \t(emit_multi_reg_push): Don't record dwarf information for the pc.\n \t* arm.md (eh_epilogue): The function type may have changed, so it\n \tneeds to be recalculated.\n-\t* arm/netbsd.h (DWARF2_UNWIND_INFO): Delete.  Can now use dwarf2 \n+\t* arm/netbsd.h (DWARF2_UNWIND_INFO): Delete.  Can now use dwarf2\n \tunwind tables on arm/netbsd.\n \n 2001-01-15  Richard Earnshaw  <rearnsha@arm.com>\n@@ -288,7 +304,7 @@ Tue Jan 16 17:20:43 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n 2001-01-15  Andreas Jaeger  <aj@suse.de>\n \n-\t* config/i386/i386.c (ix86_init_builtins): Make i size_t to remove \n+\t* config/i386/i386.c (ix86_init_builtins): Make i size_t to remove\n \twarnings.\n \t(ix86_expand_builtin): Likewise.\n \n@@ -301,8 +317,8 @@ Tue Jan 16 17:20:43 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n 2001-01-14  Ralf Baechle <ralf@gnu.org>\n \n-        * config/mips/linux.h (SUBTARGET_CPP_SPEC): Default ABI is 32; change\n-        SUBTARGET_CPP_SPEC apropriatly.\n+\t* config/mips/linux.h (SUBTARGET_CPP_SPEC): Default ABI is 32; change\n+\tSUBTARGET_CPP_SPEC apropriatly.\n \n 2001-01-12  Mark Mitchell  <mark@codesourcery.com>\n \n@@ -322,12 +338,12 @@ Sun Jan 14 22:31:30 2001  J\"orn Rennecke <amylaar@redhat.com>\n \n 2001-01-14  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n-        * c-parse.in (finish_parse): Add comment about cpp_destroy.\n-        * cp/lex.c (finish_parse): Similarly.\n-        * cppinit.c (cpp_cleanup): Rename cpp_destroy for clarity.\n-        Return the number of errors encountered.\n-        * cpplib.h (cpp_cleanup): Rename cpp_destroy, return int.\n-        * cppmain.c (main): Don't call cpp_destroy.\n+\t* c-parse.in (finish_parse): Add comment about cpp_destroy.\n+\t* cp/lex.c (finish_parse): Similarly.\n+\t* cppinit.c (cpp_cleanup): Rename cpp_destroy for clarity.\n+\tReturn the number of errors encountered.\n+\t* cpplib.h (cpp_cleanup): Rename cpp_destroy, return int.\n+\t* cppmain.c (main): Don't call cpp_destroy.\n \n 2001-01-14  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n@@ -351,12 +367,12 @@ Sun Jan 14 22:31:30 2001  J\"orn Rennecke <amylaar@redhat.com>\n \n 2001-01-14  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n-        * cppmain.c (do_preprocessing): New function; most of the old\n-        main.\n-        (main): Call it to do most of the work.\n-        (cb): Move from global scope to set_callbacks ().\n-        (setup_callbacks): Get the callback pointer.\n-        (general_init, printer_init): Clean up code and comments.\n+\t* cppmain.c (do_preprocessing): New function; most of the old\n+\tmain.\n+\t(main): Call it to do most of the work.\n+\t(cb): Move from global scope to set_callbacks ().\n+\t(setup_callbacks): Get the callback pointer.\n+\t(general_init, printer_init): Clean up code and comments.\n \n 2001-01-14  Richard Earnshaw  <rearnsha@arm.com>\n \n@@ -491,11 +507,11 @@ Sun Jan 14 00:23:15 2001  Denis Chertykov  <denisc@overta.ru>\n \n 2001-01-13  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n-        * cppfiles.c (_cpp_fake_include): New function.\n-        * cpphash.h (_cpp_fake_include): New.\n-        * cpplib.c (do_line): Call _cpp_fake_include when entering\n-        header files in preprocessed input.\n-        * cppmain.c (cb_pragma_implementation): Remove handling.\n+\t* cppfiles.c (_cpp_fake_include): New function.\n+\t* cpphash.h (_cpp_fake_include): New.\n+\t* cpplib.c (do_line): Call _cpp_fake_include when entering\n+\theader files in preprocessed input.\n+\t* cppmain.c (cb_pragma_implementation): Remove handling.\n \t(setup_callbacks): Don't register pragmas.\n \n 2001-01-13  Neil Booth  <neil@daikokuya.demon.co.uk>\n@@ -510,35 +526,35 @@ Sun Jan 14 00:23:15 2001  Denis Chertykov  <denisc@overta.ru>\n \n 2001-01-13  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n-        * cpplib.h (cpp_pool, mi_state, mi_ind, struct cpp_macro,\n-        struct cpp_chunk, struct htab, struct toklist,\n-        struct cpp_context, CPP_STACK_MAX, struct lexer_state,\n-        struct spec_nodes, struct cpp_reader, CPP_OPTION, CPP_BUFFER,\n-        CPP_BUF_LINE, CPP_BUF_COL, CPP_BUF_COLUMN, U, ustrcmp, ustrncmp,\n-        ustrlen, uxstrdup, ustrchr, ufputs): Move to cpphash.h.\n-        (struct macro_args): Delete.\n-        * cpphash.h: See above.\n+\t* cpplib.h (cpp_pool, mi_state, mi_ind, struct cpp_macro,\n+\tstruct cpp_chunk, struct htab, struct toklist,\n+\tstruct cpp_context, CPP_STACK_MAX, struct lexer_state,\n+\tstruct spec_nodes, struct cpp_reader, CPP_OPTION, CPP_BUFFER,\n+\tCPP_BUF_LINE, CPP_BUF_COL, CPP_BUF_COLUMN, U, ustrcmp, ustrncmp,\n+\tustrlen, uxstrdup, ustrchr, ufputs): Move to cpphash.h.\n+\t(struct macro_args): Delete.\n+\t* cpphash.h: See above.\n \n 2001-01-13  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n-        * cppmain.c (struct printer): Remove no_line_dirs.\n-        (options, cb): New.\n-        (main, setup_callbacks, scan_buffer, printer_init, cb_define)\n-        : Use options rather than CPP_OPTION.\n-        (setup_callbacks): Use cb rather than pfile->cb.\n-        (main): No need to check for a buffer.  Use cpp_errors.\n-        (printer_init): Don't set no_line_dirs.\n-        (maybe_print_line): Use options not no_line_dirs.\n-        (cb_file_change): Don't call print_line if -P.\n+\t* cppmain.c (struct printer): Remove no_line_dirs.\n+\t(options, cb): New.\n+\t(main, setup_callbacks, scan_buffer, printer_init, cb_define)\n+\t: Use options rather than CPP_OPTION.\n+\t(setup_callbacks): Use cb rather than pfile->cb.\n+\t(main): No need to check for a buffer.  Use cpp_errors.\n+\t(printer_init): Don't set no_line_dirs.\n+\t(maybe_print_line): Use options not no_line_dirs.\n+\t(cb_file_change): Don't call print_line if -P.\n \n 2001-01-13  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n-        * c-lex.c (init_c_lex): Use cpp_get_callbacks to set\n-        callbacks.\n-        * c-parse.in (finish_parse): Use cpp_errors.\n-        (__yylex): Use return value of cpp_pop_buffer.\n-        * cp/lex.c (finish_parse): Use cpp_errors.\n-        * cp/spew.c (read_token): Use return value of cpp_pop_buffer.\n+\t* c-lex.c (init_c_lex): Use cpp_get_callbacks to set\n+\tcallbacks.\n+\t* c-parse.in (finish_parse): Use cpp_errors.\n+\t(__yylex): Use return value of cpp_pop_buffer.\n+\t* cp/lex.c (finish_parse): Use cpp_errors.\n+\t* cp/spew.c (read_token): Use return value of cpp_pop_buffer.\n \n Sat Jan 13 16:57:40 2001  Denis Chertykov  <denisc@overta.ru>\n \n@@ -592,24 +608,24 @@ Sat Jan 13 09:53:32 MET 2001  Jan Hubicka  <jh@suse.cz>\n \n 2001-01-13  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n-        * fix-header.c (read_scan_file): Use cpp_get_callbacks and\n-        cpp_get_options rather than dereferencing pfile and using\n-        CPP_OPTION.\n-        * scan-decls.c (scan_decls): Use return value of\n-        cpp_pop_buffer rather than CPP_BUFFER.\n+\t* fix-header.c (read_scan_file): Use cpp_get_callbacks and\n+\tcpp_get_options rather than dereferencing pfile and using\n+\tCPP_OPTION.\n+\t* scan-decls.c (scan_decls): Use return value of\n+\tcpp_pop_buffer rather than CPP_BUFFER.\n \n 2001-01-13  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n-        * cppinit.c (cpp_handle_option): help_only is now part of the\n-        cpp_options structure.\n-        * cpplib.c (cpp_errors, cpp_get_options, cpp_get_callbacks,\n-        cpp_set_callbacks): New functions.\n-        * cpplib.h (cpp_callbacks): Break out as a named structure.\n-        (cpp_options): Move help_only here from cpp_reader.\n-        (CPP_FATAL_ERRORS): Update to use cpp_errors.\n-        (cpp_errors, cpp_get_options, cpp_get_callbacks,\n-        cpp_set_callbacks): New prototypes.\n-        * cppmain.c (main): Update for help_only.\n+\t* cppinit.c (cpp_handle_option): help_only is now part of the\n+\tcpp_options structure.\n+\t* cpplib.c (cpp_errors, cpp_get_options, cpp_get_callbacks,\n+\tcpp_set_callbacks): New functions.\n+\t* cpplib.h (cpp_callbacks): Break out as a named structure.\n+\t(cpp_options): Move help_only here from cpp_reader.\n+\t(CPP_FATAL_ERRORS): Update to use cpp_errors.\n+\t(cpp_errors, cpp_get_options, cpp_get_callbacks,\n+\tcpp_set_callbacks): New prototypes.\n+\t* cppmain.c (main): Update for help_only.\n \n 2001-01-13  Joseph S. Myers  <jsm28@cam.ac.uk>\n "}, {"sha": "8e7eeae372b512c53795392e6b2099a25b719c7d", "filename": "gcc/function.c", "status": "modified", "additions": 248, "deletions": 217, "changes": 465, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a5f59d0f51034f35d3fe2fed40b8dd3540c37/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a5f59d0f51034f35d3fe2fed40b8dd3540c37/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=a42a5f59d0f51034f35d3fe2fed40b8dd3540c37", "patch": "@@ -253,8 +253,13 @@ static void fixup_var_refs\tPARAMS ((rtx, enum machine_mode, int,\n \t\t\t\t\t struct hash_table *));\n static struct fixup_replacement\n   *find_fixup_replacement\tPARAMS ((struct fixup_replacement **, rtx));\n-static void fixup_var_refs_insns PARAMS ((rtx, enum machine_mode, int,\n-\t\t\t\t\t  rtx, int, struct hash_table *));\n+static void fixup_var_refs_insns PARAMS ((rtx, rtx, enum machine_mode,\n+\t\t\t\t\t  int, int));\n+static void fixup_var_refs_insns_with_hash\n+\t\t\t\tPARAMS ((struct hash_table *, rtx,\n+\t\t\t\t\t enum machine_mode, int));\n+static void fixup_var_refs_insn PARAMS ((rtx, rtx, enum machine_mode,\n+\t\t\t\t\t int, int));\n static void fixup_var_refs_1\tPARAMS ((rtx, enum machine_mode, rtx *, rtx,\n \t\t\t\t\t struct fixup_replacement **));\n static rtx fixup_memory_subreg\tPARAMS ((rtx, rtx, int));\n@@ -1542,21 +1547,25 @@ fixup_var_refs (var, promoted_mode, unsignedp, ht)\n   rtx first_insn = get_insns ();\n   struct sequence_stack *stack = seq_stack;\n   tree rtl_exps = rtl_expr_chain;\n-  rtx insn;\n \n-  /* Must scan all insns for stack-refs that exceed the limit.  */\n-  fixup_var_refs_insns (var, promoted_mode, unsignedp, first_insn,\n-\t\t\tstack == 0, ht);\n   /* If there's a hash table, it must record all uses of VAR.  */\n   if (ht)\n-    return;\n+    {\n+      if (stack != 0)\n+\tabort ();\n+      fixup_var_refs_insns_with_hash (ht, var, promoted_mode, unsignedp);\n+      return;\n+    }\n+\n+  fixup_var_refs_insns (first_insn, var, promoted_mode, unsignedp,\n+\t\t\tstack == 0);\n \n   /* Scan all pending sequences too.  */\n   for (; stack; stack = stack->next)\n     {\n       push_to_full_sequence (stack->first, stack->last);\n-      fixup_var_refs_insns (var, promoted_mode, unsignedp,\n-\t\t\t    stack->first, stack->next != 0, 0);\n+      fixup_var_refs_insns (stack->first, var, promoted_mode, unsignedp,\n+\t\t\t    stack->next != 0);\n       /* Update remembered end of sequence\n \t in case we added an insn at the end.  */\n       stack->last = get_last_insn ();\n@@ -1570,40 +1579,15 @@ fixup_var_refs (var, promoted_mode, unsignedp, ht)\n       if (seq != const0_rtx && seq != 0)\n \t{\n \t  push_to_sequence (seq);\n-\t  fixup_var_refs_insns (var, promoted_mode, unsignedp, seq, 0, 0);\n+\t  fixup_var_refs_insns (seq, var, promoted_mode, unsignedp, 0);\n \t  end_sequence ();\n \t}\n     }\n \n   /* Scan the catch clauses for exception handling too.  */\n   push_to_full_sequence (catch_clauses, catch_clauses_last);\n-  fixup_var_refs_insns (var, promoted_mode, unsignedp, catch_clauses, 0, 0);\n+  fixup_var_refs_insns (catch_clauses, var, promoted_mode, unsignedp, 0);\n   end_full_sequence (&catch_clauses, &catch_clauses_last);\n-\n-  /* Scan sequences saved in CALL_PLACEHOLDERS too.  */\n-  for (insn = first_insn; insn; insn = NEXT_INSN (insn))\n-    {\n-      if (GET_CODE (insn) == CALL_INSN\n-\t  && GET_CODE (PATTERN (insn)) == CALL_PLACEHOLDER)\n-\t{\n-\t  int i;\n-\n-\t  /* Look at the Normal call, sibling call and tail recursion\n-\t     sequences attached to the CALL_PLACEHOLDER.  */\n-\t  for (i = 0; i < 3; i++)\n-\t    {\n-\t      rtx seq = XEXP (PATTERN (insn), i);\n-\t      if (seq)\n-\t\t{\n-\t\t  push_to_sequence (seq);\n-\t\t  fixup_var_refs_insns (var, promoted_mode, unsignedp,\n-\t\t\t\t\tseq, 0, 0);\n-\t\t  XEXP (PATTERN (insn), i) = get_insns ();\n-\t\t  end_sequence ();\n-\t\t}\n-\t    }\n-\t}\n-    }\n }\n \f\n /* REPLACEMENTS is a pointer to a list of the struct fixup_replacement and X is\n@@ -1638,218 +1622,265 @@ find_fixup_replacement (replacements, x)\n    main chain of insns for the current function.  */\n \n static void\n-fixup_var_refs_insns (var, promoted_mode, unsignedp, insn, toplevel, ht)\n+fixup_var_refs_insns (insn, var, promoted_mode, unsignedp, toplevel)\n+     rtx insn;\n      rtx var;\n      enum machine_mode promoted_mode;\n      int unsignedp;\n-     rtx insn;\n      int toplevel;\n+{\n+  while (insn)\n+    {\n+      /* fixup_var_refs_insn might modify insn, so save its next\n+         pointer now.  */\n+      rtx next = NEXT_INSN (insn);\n+\n+      /* CALL_PLACEHOLDERs are special; we have to switch into each of\n+\t the three sequences they (potentially) contain, and process\n+\t them recursively.  The CALL_INSN itself is not interesting.  */\n+\n+      if (GET_CODE (insn) == CALL_INSN\n+\t  && GET_CODE (PATTERN (insn)) == CALL_PLACEHOLDER)\n+\t{\n+\t  int i;\n+\n+\t  /* Look at the Normal call, sibling call and tail recursion\n+\t     sequences attached to the CALL_PLACEHOLDER.  */\n+\t  for (i = 0; i < 3; i++)\n+\t    {\n+\t      rtx seq = XEXP (PATTERN (insn), i);\n+\t      if (seq)\n+\t\t{\n+\t\t  push_to_sequence (seq);\n+\t\t  fixup_var_refs_insns (seq, var, promoted_mode, unsignedp, 0);\n+\t\t  XEXP (PATTERN (insn), i) = get_insns ();\n+\t\t  end_sequence ();\n+\t\t}\n+\t    }\n+\t}\n+\n+      else if (INSN_P (insn))\n+\tfixup_var_refs_insn (insn, var, promoted_mode, unsignedp, toplevel);\n+\n+      insn = next;\n+    }\n+}\n+\n+/* Look up the insns which reference VAR in HT and fix them up.  Other\n+   arguments are the same as fixup_var_refs_insns.\n+\n+   N.B. No need for special processing of CALL_PLACEHOLDERs here,\n+   because the hash table will point straight to the interesting insn\n+   (inside the CALL_PLACEHOLDER).  */\n+static void\n+fixup_var_refs_insns_with_hash (ht, var, promoted_mode, unsignedp)\n      struct hash_table *ht;\n+     rtx var;\n+     enum machine_mode promoted_mode;\n+     int unsignedp;\n {\n-  rtx call_dest = 0;\n-  rtx insn_list = NULL_RTX;\n+  struct insns_for_mem_entry *ime = (struct insns_for_mem_entry *)\n+    hash_lookup (ht, var, /*create=*/0, /*copy=*/0);\n+  rtx insn_list = ime->insns;\n \n-  /* If we already know which INSNs reference VAR there's no need\n-     to walk the entire instruction chain.  */\n-  if (ht)\n+  while (insn_list)\n     {\n-      insn_list = ((struct insns_for_mem_entry *)\n-\t\t   hash_lookup (ht, var, /*create=*/0, /*copy=*/0))->insns;\n-      insn = insn_list ? XEXP (insn_list, 0) : NULL_RTX;\n+      rtx insn = XEXP (insn_list, 0);\n+\t\n+      if (INSN_P (insn))\n+\tfixup_var_refs_insn (insn, var, promoted_mode, unsignedp, 0);\n+\n       insn_list = XEXP (insn_list, 1);\n     }\n+}\n \n-  while (insn)\n+\n+/* Per-insn processing by fixup_var_refs_insns(_with_hash).  INSN is\n+   the insn under examination, VAR is the variable to fix up\n+   references to, PROMOTED_MODE and UNSIGNEDP describe VAR, and\n+   TOPLEVEL is nonzero if this is the main insn chain for this\n+   function.  */\n+static void\n+fixup_var_refs_insn (insn, var, promoted_mode, unsignedp, toplevel)\n+     rtx insn;\n+     rtx var;\n+     enum machine_mode promoted_mode;\n+     int unsignedp;\n+     int toplevel;\n+{\n+  rtx call_dest = 0;\n+  rtx set, prev, prev_set;\n+  rtx note;\n+\n+  /* Remember the notes in case we delete the insn.  */\n+  note = REG_NOTES (insn);\n+\n+  /* If this is a CLOBBER of VAR, delete it.\n+\n+     If it has a REG_LIBCALL note, delete the REG_LIBCALL\n+     and REG_RETVAL notes too.  */\n+  if (GET_CODE (PATTERN (insn)) == CLOBBER\n+      && (XEXP (PATTERN (insn), 0) == var\n+\t  || (GET_CODE (XEXP (PATTERN (insn), 0)) == CONCAT\n+\t      && (XEXP (XEXP (PATTERN (insn), 0), 0) == var\n+\t\t  || XEXP (XEXP (PATTERN (insn), 0), 1) == var))))\n     {\n-      rtx next = NEXT_INSN (insn);\n-      rtx set, prev, prev_set;\n-      rtx note;\n+      if ((note = find_reg_note (insn, REG_LIBCALL, NULL_RTX)) != 0)\n+\t/* The REG_LIBCALL note will go away since we are going to\n+\t   turn INSN into a NOTE, so just delete the\n+\t   corresponding REG_RETVAL note.  */\n+\tremove_note (XEXP (note, 0),\n+\t\t     find_reg_note (XEXP (note, 0), REG_RETVAL,\n+\t\t\t\t    NULL_RTX));\n+\n+      /* In unoptimized compilation, we shouldn't call delete_insn\n+\t except in jump.c doing warnings.  */\n+      PUT_CODE (insn, NOTE);\n+      NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n+      NOTE_SOURCE_FILE (insn) = 0;\n+    }\n \n-      if (INSN_P (insn))\n+  /* The insn to load VAR from a home in the arglist\n+     is now a no-op.  When we see it, just delete it.\n+     Similarly if this is storing VAR from a register from which\n+     it was loaded in the previous insn.  This will occur\n+     when an ADDRESSOF was made for an arglist slot.  */\n+  else if (toplevel\n+\t   && (set = single_set (insn)) != 0\n+\t   && SET_DEST (set) == var\n+\t   /* If this represents the result of an insn group,\n+\t      don't delete the insn.  */\n+\t   && find_reg_note (insn, REG_RETVAL, NULL_RTX) == 0\n+\t   && (rtx_equal_p (SET_SRC (set), var)\n+\t       || (GET_CODE (SET_SRC (set)) == REG\n+\t\t   && (prev = prev_nonnote_insn (insn)) != 0\n+\t\t   && (prev_set = single_set (prev)) != 0\n+\t\t   && SET_DEST (prev_set) == SET_SRC (set)\n+\t\t   && rtx_equal_p (SET_SRC (prev_set), var))))\n+    {\n+      /* In unoptimized compilation, we shouldn't call delete_insn\n+\t except in jump.c doing warnings.  */\n+      PUT_CODE (insn, NOTE);\n+      NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n+      NOTE_SOURCE_FILE (insn) = 0;\n+    }\n+  else\n+    {\n+      struct fixup_replacement *replacements = 0;\n+      rtx next_insn = NEXT_INSN (insn);\n+\n+      if (SMALL_REGISTER_CLASSES)\n \t{\n-\t  /* Remember the notes in case we delete the insn.  */\n-\t  note = REG_NOTES (insn);\n-\n-\t  /* If this is a CLOBBER of VAR, delete it.\n-\n-\t     If it has a REG_LIBCALL note, delete the REG_LIBCALL\n-\t     and REG_RETVAL notes too.  */\n-\t  if (GET_CODE (PATTERN (insn)) == CLOBBER\n-\t      && (XEXP (PATTERN (insn), 0) == var\n-\t\t  || (GET_CODE (XEXP (PATTERN (insn), 0)) == CONCAT\n-\t\t      && (XEXP (XEXP (PATTERN (insn), 0), 0) == var\n-\t\t\t  || XEXP (XEXP (PATTERN (insn), 0), 1) == var))))\n+\t  /* If the insn that copies the results of a CALL_INSN\n+\t     into a pseudo now references VAR, we have to use an\n+\t     intermediate pseudo since we want the life of the\n+\t     return value register to be only a single insn.\n+\n+\t     If we don't use an intermediate pseudo, such things as\n+\t     address computations to make the address of VAR valid\n+\t     if it is not can be placed between the CALL_INSN and INSN.\n+\n+\t     To make sure this doesn't happen, we record the destination\n+\t     of the CALL_INSN and see if the next insn uses both that\n+\t     and VAR.  */\n+\n+\t  if (call_dest != 0 && GET_CODE (insn) == INSN\n+\t      && reg_mentioned_p (var, PATTERN (insn))\n+\t      && reg_mentioned_p (call_dest, PATTERN (insn)))\n \t    {\n-\t      if ((note = find_reg_note (insn, REG_LIBCALL, NULL_RTX)) != 0)\n-\t\t/* The REG_LIBCALL note will go away since we are going to\n-\t\t   turn INSN into a NOTE, so just delete the\n-\t\t   corresponding REG_RETVAL note.  */\n-\t\tremove_note (XEXP (note, 0),\n-\t\t\t     find_reg_note (XEXP (note, 0), REG_RETVAL,\n-\t\t\t\t\t    NULL_RTX));\n-\n-\t      /* In unoptimized compilation, we shouldn't call delete_insn\n-\t\t except in jump.c doing warnings.  */\n-\t      PUT_CODE (insn, NOTE);\n-\t      NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n-\t      NOTE_SOURCE_FILE (insn) = 0;\n-\t    }\n+\t      rtx temp = gen_reg_rtx (GET_MODE (call_dest));\n \n-\t  /* The insn to load VAR from a home in the arglist\n-\t     is now a no-op.  When we see it, just delete it.\n-\t     Similarly if this is storing VAR from a register from which\n-\t     it was loaded in the previous insn.  This will occur\n-\t     when an ADDRESSOF was made for an arglist slot.  */\n-\t  else if (toplevel\n-\t\t   && (set = single_set (insn)) != 0\n-\t\t   && SET_DEST (set) == var\n-\t\t   /* If this represents the result of an insn group,\n-\t\t      don't delete the insn.  */\n-\t\t   && find_reg_note (insn, REG_RETVAL, NULL_RTX) == 0\n-\t\t   && (rtx_equal_p (SET_SRC (set), var)\n-\t\t       || (GET_CODE (SET_SRC (set)) == REG\n-\t\t\t   && (prev = prev_nonnote_insn (insn)) != 0\n-\t\t\t   && (prev_set = single_set (prev)) != 0\n-\t\t\t   && SET_DEST (prev_set) == SET_SRC (set)\n-\t\t\t   && rtx_equal_p (SET_SRC (prev_set), var))))\n-\t    {\n-\t      /* In unoptimized compilation, we shouldn't call delete_insn\n-\t\t except in jump.c doing warnings.  */\n-\t      PUT_CODE (insn, NOTE);\n-\t      NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n-\t      NOTE_SOURCE_FILE (insn) = 0;\n-\t      if (insn == last_parm_insn)\n-\t\tlast_parm_insn = PREV_INSN (next);\n+\t      emit_insn_before (gen_move_insn (temp, call_dest), insn);\n+\n+\t      PATTERN (insn) = replace_rtx (PATTERN (insn),\n+\t\t\t\t\t    call_dest, temp);\n \t    }\n+\n+\t  if (GET_CODE (insn) == CALL_INSN\n+\t      && GET_CODE (PATTERN (insn)) == SET)\n+\t    call_dest = SET_DEST (PATTERN (insn));\n+\t  else if (GET_CODE (insn) == CALL_INSN\n+\t\t   && GET_CODE (PATTERN (insn)) == PARALLEL\n+\t\t   && GET_CODE (XVECEXP (PATTERN (insn), 0, 0)) == SET)\n+\t    call_dest = SET_DEST (XVECEXP (PATTERN (insn), 0, 0));\n \t  else\n-\t    {\n-\t      struct fixup_replacement *replacements = 0;\n-\t      rtx next_insn = NEXT_INSN (insn);\n+\t    call_dest = 0;\n+\t}\n \n-\t      if (SMALL_REGISTER_CLASSES)\n-\t\t{\n-\t\t  /* If the insn that copies the results of a CALL_INSN\n-\t\t     into a pseudo now references VAR, we have to use an\n-\t\t     intermediate pseudo since we want the life of the\n-\t\t     return value register to be only a single insn.\n-\n-\t\t     If we don't use an intermediate pseudo, such things as\n-\t\t     address computations to make the address of VAR valid\n-\t\t     if it is not can be placed between the CALL_INSN and INSN.\n-\n-\t\t     To make sure this doesn't happen, we record the destination\n-\t\t     of the CALL_INSN and see if the next insn uses both that\n-\t\t     and VAR.  */\n-\n-\t\t  if (call_dest != 0 && GET_CODE (insn) == INSN\n-\t\t      && reg_mentioned_p (var, PATTERN (insn))\n-\t\t      && reg_mentioned_p (call_dest, PATTERN (insn)))\n-\t\t    {\n-\t\t      rtx temp = gen_reg_rtx (GET_MODE (call_dest));\n+      /* See if we have to do anything to INSN now that VAR is in\n+\t memory.  If it needs to be loaded into a pseudo, use a single\n+\t pseudo for the entire insn in case there is a MATCH_DUP\n+\t between two operands.  We pass a pointer to the head of\n+\t a list of struct fixup_replacements.  If fixup_var_refs_1\n+\t needs to allocate pseudos or replacement MEMs (for SUBREGs),\n+\t it will record them in this list.\n \n-\t\t      emit_insn_before (gen_move_insn (temp, call_dest), insn);\n+\t If it allocated a pseudo for any replacement, we copy into\n+\t it here.  */\n \n-\t\t      PATTERN (insn) = replace_rtx (PATTERN (insn),\n-\t\t\t\t\t\t    call_dest, temp);\n-\t\t    }\n+      fixup_var_refs_1 (var, promoted_mode, &PATTERN (insn), insn,\n+\t\t\t&replacements);\n \n-\t\t  if (GET_CODE (insn) == CALL_INSN\n-\t\t      && GET_CODE (PATTERN (insn)) == SET)\n-\t\t    call_dest = SET_DEST (PATTERN (insn));\n-\t\t  else if (GET_CODE (insn) == CALL_INSN\n-\t\t\t   && GET_CODE (PATTERN (insn)) == PARALLEL\n-\t\t\t   && GET_CODE (XVECEXP (PATTERN (insn), 0, 0)) == SET)\n-\t\t    call_dest = SET_DEST (XVECEXP (PATTERN (insn), 0, 0));\n-\t\t  else\n-\t\t    call_dest = 0;\n-\t\t}\n+      /* If this is last_parm_insn, and any instructions were output\n+\t after it to fix it up, then we must set last_parm_insn to\n+\t the last such instruction emitted.  */\n+      if (insn == last_parm_insn)\n+\tlast_parm_insn = PREV_INSN (next_insn);\n \n-\t      /* See if we have to do anything to INSN now that VAR is in\n-\t\t memory.  If it needs to be loaded into a pseudo, use a single\n-\t\t pseudo for the entire insn in case there is a MATCH_DUP\n-\t\t between two operands.  We pass a pointer to the head of\n-\t\t a list of struct fixup_replacements.  If fixup_var_refs_1\n-\t\t needs to allocate pseudos or replacement MEMs (for SUBREGs),\n-\t\t it will record them in this list.\n-\n-\t\t If it allocated a pseudo for any replacement, we copy into\n-\t\t it here.  */\n+      while (replacements)\n+\t{\n+\t  struct fixup_replacement *next;\n \n-\t      fixup_var_refs_1 (var, promoted_mode, &PATTERN (insn), insn,\n-\t\t\t\t&replacements);\n+\t  if (GET_CODE (replacements->new) == REG)\n+\t    {\n+\t      rtx insert_before;\n+\t      rtx seq;\n \n-\t      /* If this is last_parm_insn, and any instructions were output\n-\t\t after it to fix it up, then we must set last_parm_insn to\n-\t\t the last such instruction emitted.  */\n-\t      if (insn == last_parm_insn)\n-\t\tlast_parm_insn = PREV_INSN (next_insn);\n+\t      /* OLD might be a (subreg (mem)).  */\n+\t      if (GET_CODE (replacements->old) == SUBREG)\n+\t\treplacements->old\n+\t\t  = fixup_memory_subreg (replacements->old, insn, 0);\n+\t      else\n+\t\treplacements->old\n+\t\t  = fixup_stack_1 (replacements->old, insn);\n \n-\t      while (replacements)\n-\t\t{\n-\t\t  struct fixup_replacement *next;\n+\t      insert_before = insn;\n \n-\t\t  if (GET_CODE (replacements->new) == REG)\n-\t\t    {\n-\t\t      rtx insert_before;\n-\t\t      rtx seq;\n-\n-\t\t      /* OLD might be a (subreg (mem)).  */\n-\t\t      if (GET_CODE (replacements->old) == SUBREG)\n-\t\t\treplacements->old\n-\t\t\t  = fixup_memory_subreg (replacements->old, insn, 0);\n-\t\t      else\n-\t\t\treplacements->old\n-\t\t\t  = fixup_stack_1 (replacements->old, insn);\n-\n-\t\t      insert_before = insn;\n-\n-\t\t      /* If we are changing the mode, do a conversion.\n-\t\t\t This might be wasteful, but combine.c will\n-\t\t\t eliminate much of the waste.  */\n-\n-\t\t      if (GET_MODE (replacements->new)\n-\t\t\t  != GET_MODE (replacements->old))\n-\t\t\t{\n-\t\t\t  start_sequence ();\n-\t\t\t  convert_move (replacements->new,\n-\t\t\t\t\treplacements->old, unsignedp);\n-\t\t\t  seq = gen_sequence ();\n-\t\t\t  end_sequence ();\n-\t\t\t}\n-\t\t      else\n-\t\t\tseq = gen_move_insn (replacements->new,\n-\t\t\t\t\t     replacements->old);\n-\n-\t\t      emit_insn_before (seq, insert_before);\n-\t\t    }\n+\t      /* If we are changing the mode, do a conversion.\n+\t\t This might be wasteful, but combine.c will\n+\t\t eliminate much of the waste.  */\n \n-\t\t  next = replacements->next;\n-\t\t  free (replacements);\n-\t\t  replacements = next;\n+\t      if (GET_MODE (replacements->new)\n+\t\t  != GET_MODE (replacements->old))\n+\t\t{\n+\t\t  start_sequence ();\n+\t\t  convert_move (replacements->new,\n+\t\t\t\treplacements->old, unsignedp);\n+\t\t  seq = gen_sequence ();\n+\t\t  end_sequence ();\n \t\t}\n-\t    }\n+\t      else\n+\t\tseq = gen_move_insn (replacements->new,\n+\t\t\t\t     replacements->old);\n \n-\t  /* Also fix up any invalid exprs in the REG_NOTES of this insn.\n-\t     But don't touch other insns referred to by reg-notes;\n-\t     we will get them elsewhere.  */\n-\t  while (note)\n-\t    {\n-\t      if (GET_CODE (note) != INSN_LIST)\n-\t\tXEXP (note, 0)\n-\t\t  = walk_fixup_memory_subreg (XEXP (note, 0), insn, 1);\n-\t      note = XEXP (note, 1);\n+\t      emit_insn_before (seq, insert_before);\n \t    }\n-\t}\n \n-      if (!ht)\n-\tinsn = next;\n-      else if (insn_list)\n-\t{\n-\t  insn = XEXP (insn_list, 0);\n-\t  insn_list = XEXP (insn_list, 1);\n+\t  next = replacements->next;\n+\t  free (replacements);\n+\t  replacements = next;\n \t}\n-      else\n-\tinsn = NULL_RTX;\n+    }\n+\n+  /* Also fix up any invalid exprs in the REG_NOTES of this insn.\n+     But don't touch other insns referred to by reg-notes;\n+     we will get them elsewhere.  */\n+  while (note)\n+    {\n+      if (GET_CODE (note) != INSN_LIST)\n+\tXEXP (note, 0)\n+\t  = walk_fixup_memory_subreg (XEXP (note, 0), insn, 1);\n+      note = XEXP (note, 1);\n     }\n }\n \f\n@@ -1861,7 +1892,7 @@ fixup_var_refs_insns (var, promoted_mode, unsignedp, insn, toplevel, ht)\n    to modify this insn by replacing a memory reference with a pseudo or by\n    making a new MEM to implement a SUBREG, we consult that list to see if\n    we have already chosen a replacement. If none has already been allocated,\n-   we allocate it and update the list.  fixup_var_refs_insns will copy VAR\n+   we allocate it and update the list.  fixup_var_refs_insn will copy VAR\n    or the SUBREG, as appropriate, to the pseudo.  */\n \n static void\n@@ -4564,7 +4595,7 @@ assign_parms (fndecl)\n \t\t&& GET_CODE (XEXP (XVECEXP (entry_parm, 0, i), 0)) == REG\n \t\t&& (GET_MODE (XEXP (XVECEXP (entry_parm, 0, i), 0))\n \t\t    == passed_mode)\n-\t\t&& INTVAL (XEXP (XVECEXP (entry_parm, 0, i), 1)) == 0)\n+\t\t&& XINT (XEXP (XVECEXP (entry_parm, 0, i), 1), 0) == 0)\n \t      {\n \t\tentry_parm = XEXP (XVECEXP (entry_parm, 0, i), 0);\n \t\tDECL_INCOMING_RTL (parm) = entry_parm;"}, {"sha": "6d1fc6431c6f200440f181e2c458322883ceb0f7", "filename": "gcc/testsuite/gcc.c-torture/compile/20010118-1.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42a5f59d0f51034f35d3fe2fed40b8dd3540c37/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20010118-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42a5f59d0f51034f35d3fe2fed40b8dd3540c37/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20010118-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20010118-1.c?ref=a42a5f59d0f51034f35d3fe2fed40b8dd3540c37", "patch": "@@ -0,0 +1,21 @@\n+static unsigned int bar(void *h, unsigned int n)\n+{\n+  static int i;\n+  return i++;\n+}\n+\n+static void baz(unsigned int *x)\n+{\n+  (*x)++;\n+}\n+\n+long\n+foo(void *h, unsigned int l)\n+{\n+  unsigned int n;\n+  long m;\n+  n = bar(h, 0);\n+  n = bar(h, n);\n+  m = ({ baz(&n); 21; });\n+  return m;\n+}"}]}