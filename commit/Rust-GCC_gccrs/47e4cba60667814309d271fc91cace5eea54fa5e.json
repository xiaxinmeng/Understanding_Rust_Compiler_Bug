{"sha": "47e4cba60667814309d271fc91cace5eea54fa5e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDdlNGNiYTYwNjY3ODE0MzA5ZDI3MWZjOTFjYWNlNWVlYTU0ZmE1ZQ==", "commit": {"author": {"name": "Segher Boessenkool", "email": "segher@kernel.crashing.org", "date": "2019-05-17T22:10:29Z"}, "committer": {"name": "Segher Boessenkool", "email": "segher@gcc.gnu.org", "date": "2019-05-17T22:10:29Z"}, "message": "rs6000: Some rs6000_emit_epilogue improvements\n\nThis uses epilogue_type directly.  It also changes some ints to bools,\ndeclares variables later, and simplifies some code.\n\nThere is one actual change:\n\n   else if (info->push_p\n           && DEFAULT_ABI != ABI_V4\n-          && !crtl->calls_eh_return)\n+          && epilogue_type != EPILOGUE_TYPE_EH_RETURN)\n     {\n       /* Prevent reordering memory accesses against stack pointer restore.  */\n\n(different because calls_eh_return can be true for sibcalls).  This is\na bugfix.  The code was never exercised.\n\nOne place in the epilogue still uses crtl->calls_eh_return.  If that\nis changed the prologue has to have a corresponding change, and the\nemit_prologue function does not have an epilogue_type parameter, so\nbail on changing this for now.  We might want to do this (saving the\nCR fields to separate stack slots) always, not just for functions\ncalling eh_return, but that will require more investigation.\n\n\n\t* config/rs6000/rs6000.c (restore_saved_cr): Change a boolean\n\targument to be type bool (was int before).\n\t(rs6000_emit_epilogue): Simplify some code.  Declare some variables\n\tat first use.  Use type bool for some variables.  Fix a theoretical\n\teh_return bug for svr4.\n\nFrom-SVN: r271361", "tree": {"sha": "744a6bb123d1313c5474620caba317584e611601", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/744a6bb123d1313c5474620caba317584e611601"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/47e4cba60667814309d271fc91cace5eea54fa5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47e4cba60667814309d271fc91cace5eea54fa5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47e4cba60667814309d271fc91cace5eea54fa5e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47e4cba60667814309d271fc91cace5eea54fa5e/comments", "author": {"login": "segher", "id": 417629, "node_id": "MDQ6VXNlcjQxNzYyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/417629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/segher", "html_url": "https://github.com/segher", "followers_url": "https://api.github.com/users/segher/followers", "following_url": "https://api.github.com/users/segher/following{/other_user}", "gists_url": "https://api.github.com/users/segher/gists{/gist_id}", "starred_url": "https://api.github.com/users/segher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/segher/subscriptions", "organizations_url": "https://api.github.com/users/segher/orgs", "repos_url": "https://api.github.com/users/segher/repos", "events_url": "https://api.github.com/users/segher/events{/privacy}", "received_events_url": "https://api.github.com/users/segher/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d78ba51841e429173f7a9eaa20006c04ceced29c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d78ba51841e429173f7a9eaa20006c04ceced29c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d78ba51841e429173f7a9eaa20006c04ceced29c"}], "stats": {"total": 105, "additions": 61, "deletions": 44}, "files": [{"sha": "0d27fffccd9532d3237eb47822095fb1333b7f5d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47e4cba60667814309d271fc91cace5eea54fa5e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47e4cba60667814309d271fc91cace5eea54fa5e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=47e4cba60667814309d271fc91cace5eea54fa5e", "patch": "@@ -1,3 +1,11 @@\n+2019-05-17  Segher Boessenkool  <segher@kernel.crashing.org>\n+\n+\t* config/rs6000/rs6000.c (restore_saved_cr): Change a boolean\n+\targument to be type bool (was int before).\n+\t(rs6000_emit_epilogue): Simplify some code.  Declare some variables\n+\tat first use.  Use type bool for some variables.  Fix a theoretical\n+\teh_return bug for svr4.\n+\n 2019-05-17  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \t* config/rs6000/rs6000.md (isa): New attribute."}, {"sha": "6cbff91260669e94d3c8d4c9a487169ff1be5334", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 53, "deletions": 44, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47e4cba60667814309d271fc91cace5eea54fa5e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47e4cba60667814309d271fc91cace5eea54fa5e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=47e4cba60667814309d271fc91cace5eea54fa5e", "patch": "@@ -27712,7 +27712,7 @@ load_cr_save (int regno, rtx frame_reg_rtx, int offset, bool exit_func)\n /* Reload CR from REG.  */\n \n static void\n-restore_saved_cr (rtx reg, int using_mfcr_multiple, bool exit_func)\n+restore_saved_cr (rtx reg, bool using_mfcr_multiple, bool exit_func)\n {\n   int count = 0;\n   int i;\n@@ -27876,15 +27876,6 @@ emit_cfa_restores (rtx cfa_restores)\n void\n rs6000_emit_epilogue (enum epilogue_type epilogue_type)\n {\n-  int sibcall = (epilogue_type == EPILOGUE_TYPE_SIBCALL);\n-  rs6000_stack_t *info;\n-  int restoring_GPRs_inline;\n-  int restoring_FPRs_inline;\n-  int using_load_multiple;\n-  int using_mtcr_multiple;\n-  int use_backchain_to_restore_sp;\n-  int restore_lr;\n-  int strategy;\n   HOST_WIDE_INT frame_off = 0;\n   rtx sp_reg_rtx = gen_rtx_REG (Pmode, 1);\n   rtx frame_reg_rtx = sp_reg_rtx;\n@@ -27896,30 +27887,38 @@ rs6000_emit_epilogue (enum epilogue_type epilogue_type)\n   machine_mode fp_reg_mode = TARGET_HARD_FLOAT ? DFmode : SFmode;\n   int fp_reg_size = 8;\n   int i;\n-  bool exit_func;\n   unsigned ptr_regno;\n \n-  info = rs6000_stack_info ();\n+  rs6000_stack_t *info = rs6000_stack_info ();\n+\n+  if (epilogue_type == EPILOGUE_TYPE_NORMAL && crtl->calls_eh_return)\n+    epilogue_type = EPILOGUE_TYPE_EH_RETURN;\n+\n+  int strategy = info->savres_strategy;\n+  bool using_load_multiple = !!(strategy & REST_MULTIPLE);\n+  bool restoring_GPRs_inline = !!(strategy & REST_INLINE_GPRS);\n+  bool restoring_FPRs_inline = !!(strategy & REST_INLINE_FPRS);\n+  if (epilogue_type == EPILOGUE_TYPE_SIBCALL)\n+    {\n+      restoring_GPRs_inline = true;\n+      restoring_FPRs_inline = true;\n+    }\n+\n+  bool using_mtcr_multiple = (rs6000_tune == PROCESSOR_PPC601\n+\t\t\t      || rs6000_tune == PROCESSOR_PPC603\n+\t\t\t      || rs6000_tune == PROCESSOR_PPC750\n+\t\t\t      || optimize_size);\n \n-  strategy = info->savres_strategy;\n-  using_load_multiple = strategy & REST_MULTIPLE;\n-  restoring_FPRs_inline = sibcall || (strategy & REST_INLINE_FPRS);\n-  restoring_GPRs_inline = sibcall || (strategy & REST_INLINE_GPRS);\n-  using_mtcr_multiple = (rs6000_tune == PROCESSOR_PPC601\n-\t\t\t || rs6000_tune == PROCESSOR_PPC603\n-\t\t\t || rs6000_tune == PROCESSOR_PPC750\n-\t\t\t || optimize_size);\n   /* Restore via the backchain when we have a large frame, since this\n      is more efficient than an addis, addi pair.  The second condition\n      here will not trigger at the moment;  We don't actually need a\n      frame pointer for alloca, but the generic parts of the compiler\n      give us one anyway.  */\n-  use_backchain_to_restore_sp = (info->total_size + (info->lr_save_p\n-\t\t\t\t\t\t     ? info->lr_save_offset\n-\t\t\t\t\t\t     : 0) > 32767\n-\t\t\t\t || (cfun->calls_alloca\n-\t\t\t\t     && !frame_pointer_needed));\n-  restore_lr = (info->lr_save_p\n+  bool use_backchain_to_restore_sp\n+    = (info->total_size + (info->lr_save_p ? info->lr_save_offset : 0) > 32767\n+       || (cfun->calls_alloca && !frame_pointer_needed));\n+\n+  bool restore_lr = (info->lr_save_p\n \t\t&& (restoring_FPRs_inline\n \t\t    || (strategy & REST_NOINLINE_FPRS_DOESNT_RESTORE_LR))\n \t\t&& (restoring_GPRs_inline\n@@ -27929,10 +27928,7 @@ rs6000_emit_epilogue (enum epilogue_type epilogue_type)\n \n   if (WORLD_SAVE_P (info))\n     {\n-      int i, j;\n-      char rname[30];\n-      const char *alloc_rname;\n-      rtvec p;\n+      gcc_assert (epilogue_type != EPILOGUE_TYPE_SIBCALL);\n \n       /* eh_rest_world_r10 will return to the location saved in the LR\n \t stack slot (which is not likely to be our caller.)\n@@ -27941,19 +27937,31 @@ rs6000_emit_epilogue (enum epilogue_type epilogue_type)\n \t The exception-handling stuff that was here in 2.95 is no\n \t longer necessary.  */\n \n+      rtvec p;\n       p = rtvec_alloc (9\n \t\t       + 32 - info->first_gp_reg_save\n \t\t       + LAST_ALTIVEC_REGNO + 1 - info->first_altivec_reg_save\n \t\t       + 63 + 1 - info->first_fp_reg_save);\n \n-      strcpy (rname, ((crtl->calls_eh_return) ?\n-\t\t      \"*eh_rest_world_r10\" : \"*rest_world\"));\n-      alloc_rname = ggc_strdup (rname);\n+      const char *rname;\n+      switch (epilogue_type)\n+\t{\n+\tcase EPILOGUE_TYPE_NORMAL:\n+\t  rname = ggc_strdup (\"*rest_world\");\n+\t  break;\n \n-      j = 0;\n+\tcase EPILOGUE_TYPE_EH_RETURN:\n+\t  rname = ggc_strdup (\"*eh_rest_world_r10\");\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+\n+      int j = 0;\n       RTVEC_ELT (p, j++) = ret_rtx;\n       RTVEC_ELT (p, j++)\n-\t= gen_rtx_USE (VOIDmode, gen_rtx_SYMBOL_REF (Pmode, alloc_rname));\n+\t= gen_rtx_USE (VOIDmode, gen_rtx_SYMBOL_REF (Pmode, rname));\n       /* The instruction pattern requires a clobber here;\n \t it is shared with the restVEC helper. */\n       RTVEC_ELT (p, j++) = gen_hard_reg_clobber (Pmode, 11);\n@@ -27972,6 +27980,7 @@ rs6000_emit_epilogue (enum epilogue_type epilogue_type)\n \t  }\n       }\n \n+      int i;\n       for (i = 0; i < 32 - info->first_gp_reg_save; i++)\n \t{\n \t  rtx reg = gen_rtx_REG (reg_mode, info->first_gp_reg_save + i);\n@@ -28196,7 +28205,7 @@ rs6000_emit_epilogue (enum epilogue_type epilogue_type)\n     }\n   else if (info->push_p\n \t   && DEFAULT_ABI != ABI_V4\n-\t   && !crtl->calls_eh_return)\n+\t   && epilogue_type != EPILOGUE_TYPE_EH_RETURN)\n     {\n       /* Prevent reordering memory accesses against stack pointer restore.  */\n       if (cfun->calls_alloca\n@@ -28356,9 +28365,9 @@ rs6000_emit_epilogue (enum epilogue_type epilogue_type)\n      function will deallocate the stack, so we don't need to worry\n      about the unwinder restoring cr from an invalid stack frame\n      location.  */\n-  exit_func = (!restoring_FPRs_inline\n-\t       || (!restoring_GPRs_inline\n-\t\t   && info->first_fp_reg_save == 64));\n+  bool exit_func = (!restoring_FPRs_inline\n+\t\t    || (!restoring_GPRs_inline\n+\t\t\t&& info->first_fp_reg_save == 64));\n \n   /* In the ELFv2 ABI we need to restore all call-saved CR fields from\n      *separate* slots if the routine calls __builtin_eh_return, so\n@@ -28424,7 +28433,7 @@ rs6000_emit_epilogue (enum epilogue_type epilogue_type)\n     restore_saved_lr (0, exit_func);\n \n   /* Load exception handler data registers, if needed.  */\n-  if (!sibcall && crtl->calls_eh_return)\n+  if (epilogue_type == EPILOGUE_TYPE_EH_RETURN)\n     {\n       unsigned int i, regno;\n \n@@ -28615,13 +28624,13 @@ rs6000_emit_epilogue (enum epilogue_type epilogue_type)\n       RTX_FRAME_RELATED_P (insn) = 1;\n     }\n \n-  if (!sibcall && crtl->calls_eh_return)\n+  if (epilogue_type == EPILOGUE_TYPE_EH_RETURN)\n     {\n       rtx sa = EH_RETURN_STACKADJ_RTX;\n       emit_insn (gen_add3_insn (sp_reg_rtx, sp_reg_rtx, sa));\n     }\n \n-  if (!sibcall && restoring_FPRs_inline)\n+  if (epilogue_type != EPILOGUE_TYPE_SIBCALL && restoring_FPRs_inline)\n     {\n       if (cfa_restores)\n \t{\n@@ -28646,7 +28655,7 @@ rs6000_emit_epilogue (enum epilogue_type epilogue_type)\n       emit_jump_insn (targetm.gen_simple_return ());\n     }\n \n-  if (!sibcall && !restoring_FPRs_inline)\n+  if (epilogue_type != EPILOGUE_TYPE_SIBCALL && !restoring_FPRs_inline)\n     {\n       bool lr = (strategy & REST_NOINLINE_FPRS_DOESNT_RESTORE_LR) == 0;\n       rtvec p = rtvec_alloc (3 + !!lr + 64 - info->first_fp_reg_save);\n@@ -28685,7 +28694,7 @@ rs6000_emit_epilogue (enum epilogue_type epilogue_type)\n \n   if (cfa_restores)\n     {\n-      if (sibcall)\n+      if (epilogue_type == EPILOGUE_TYPE_SIBCALL)\n \t/* Ensure the cfa_restores are hung off an insn that won't\n \t   be reordered above other restores.  */\n \temit_insn (gen_blockage ());"}]}