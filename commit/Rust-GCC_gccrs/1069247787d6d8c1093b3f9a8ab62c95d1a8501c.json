{"sha": "1069247787d6d8c1093b3f9a8ab62c95d1a8501c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTA2OTI0Nzc4N2Q2ZDhjMTA5M2IzZjlhOGFiNjJjOTVkMWE4NTAxYw==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2010-06-10T20:21:23Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2010-06-10T20:21:23Z"}, "message": "Makefile.in (READ_MD_H): New variable.\n\ngcc/\n\t* Makefile.in (READ_MD_H): New variable.\n\t(BUILD_RTL): Add build/read-md.o.\n\t(lto-wrapper.o): Depend on coretypes.h instead of defaults.h.\n\t(build/gensupport.o, build/read-rtl.o, build/genattr.o)\n\t(build/genattrtab.o, build/genconditions.o build/genemit.o)\n\t(build/genextract.o, build/genflags.o, build/genoutput.o)\n\t(build/genpreds.o, build/genrecog.o): Depend on $(READ_MD_H).\n\t(build/read-md.o): New rule.\n\t* defaults.h (obstack_chunk_alloc, obstack_chunk_free)\n\t(OBSTACK_CHUNK_SIZE, gcc_obstack_init): Move to...\n\t* coretypes.h: ...here.\n\t* lto-wrapper.c: Include coretypes.h instead of defaults.h.\n\t* pretty-print.c (obstack_chunk_alloc, obstack_chunk_free): Delete.\n\t* genattr.c: Include read-md.h.\n\t* genattrtab.c: Likewise.\n\t* genconditions.c: Likewise.\n\t* genemit.c: Likewise.\n\t* genextract.c: Likewise.\n\t* genflags.c: Likewise.\n\t* genoutput.c: Likewise.\n\t* genpreds.c: Likewise.\n\t* genrecog.c: Likewise.\n\t* rtl.h (read_skip_spaces, copy_rtx_ptr_loc, print_rtx_ptr_loc)\n\t(join_c_conditions, print_c_condition, read_rtx_filename)\n\t(read_rtx_lineno): Move to read-md.h.\n\t* read-rtl.c: Include read-md.h.\n\t(ptr_loc, string_obstack, ptr_locs, ptr_loc_obstack)\n\t(joined_conditions, joined_conditions_obstack, read_rtx_lineno)\n\t(read_rtx_filename, fatal_with_file_and_line, fatal_expected_char)\n\t(leading_ptr_hash, leading_ptr_eq_p, set_rtx_ptr_loc, get_rtx_ptr_loc)\n\t(copy_rtx_ptr_loc, print_rtx_ptr_loc, join_c_conditions)\n\t(print_c_condition, read_skip_spaces, read_escape, read_quoted_string)\n\t(read_braced_string, read_string): Move to read-md.c.\n\t(read_rtx): Move some initialization to init_md_reader and call\n\tinit_md_reader here.\n\t* gensupport.h (message_with_line, n_comma_elts, scan_comma_elt):\n\tMove to read-md.h.\n\t* gensupport.c: Include read-md.h.\n\t(message_with_line, n_comma_elts, scan_comma_elt): Move to\n\tread-md.c.\n\t* read-md.h, read-md.c: New files.\n\nFrom-SVN: r160570", "tree": {"sha": "4a0361cb6d566c6fbfc6ab0e87114c356330d3d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4a0361cb6d566c6fbfc6ab0e87114c356330d3d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1069247787d6d8c1093b3f9a8ab62c95d1a8501c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1069247787d6d8c1093b3f9a8ab62c95d1a8501c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1069247787d6d8c1093b3f9a8ab62c95d1a8501c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1069247787d6d8c1093b3f9a8ab62c95d1a8501c/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f14b9067c9d5c119f686e65dcae79730021bb455", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f14b9067c9d5c119f686e65dcae79730021bb455", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f14b9067c9d5c119f686e65dcae79730021bb455"}], "stats": {"total": 1167, "additions": 641, "deletions": 526}, "files": [{"sha": "6b2d1dc6ed00c8bfd92edc13ca8503775fd2de68", "filename": "gcc/ChangeLog", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1069247787d6d8c1093b3f9a8ab62c95d1a8501c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1069247787d6d8c1093b3f9a8ab62c95d1a8501c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1069247787d6d8c1093b3f9a8ab62c95d1a8501c", "patch": "@@ -1,3 +1,47 @@\n+2010-06-10  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* Makefile.in (READ_MD_H): New variable.\n+\t(BUILD_RTL): Add build/read-md.o.\n+\t(lto-wrapper.o): Depend on coretypes.h instead of defaults.h.\n+\t(build/gensupport.o, build/read-rtl.o, build/genattr.o)\n+\t(build/genattrtab.o, build/genconditions.o build/genemit.o)\n+\t(build/genextract.o, build/genflags.o, build/genoutput.o)\n+\t(build/genpreds.o, build/genrecog.o): Depend on $(READ_MD_H).\n+\t(build/read-md.o): New rule.\n+\t* defaults.h (obstack_chunk_alloc, obstack_chunk_free)\n+\t(OBSTACK_CHUNK_SIZE, gcc_obstack_init): Move to...\n+\t* coretypes.h: ...here.\n+\t* lto-wrapper.c: Include coretypes.h instead of defaults.h.\n+\t* pretty-print.c (obstack_chunk_alloc, obstack_chunk_free): Delete.\n+\t* genattr.c: Include read-md.h.\n+\t* genattrtab.c: Likewise.\n+\t* genconditions.c: Likewise.\n+\t* genemit.c: Likewise.\n+\t* genextract.c: Likewise.\n+\t* genflags.c: Likewise.\n+\t* genoutput.c: Likewise.\n+\t* genpreds.c: Likewise.\n+\t* genrecog.c: Likewise.\n+\t* rtl.h (read_skip_spaces, copy_rtx_ptr_loc, print_rtx_ptr_loc)\n+\t(join_c_conditions, print_c_condition, read_rtx_filename)\n+\t(read_rtx_lineno): Move to read-md.h.\n+\t* read-rtl.c: Include read-md.h.\n+\t(ptr_loc, string_obstack, ptr_locs, ptr_loc_obstack)\n+\t(joined_conditions, joined_conditions_obstack, read_rtx_lineno)\n+\t(read_rtx_filename, fatal_with_file_and_line, fatal_expected_char)\n+\t(leading_ptr_hash, leading_ptr_eq_p, set_rtx_ptr_loc, get_rtx_ptr_loc)\n+\t(copy_rtx_ptr_loc, print_rtx_ptr_loc, join_c_conditions)\n+\t(print_c_condition, read_skip_spaces, read_escape, read_quoted_string)\n+\t(read_braced_string, read_string): Move to read-md.c.\n+\t(read_rtx): Move some initialization to init_md_reader and call\n+\tinit_md_reader here.\n+\t* gensupport.h (message_with_line, n_comma_elts, scan_comma_elt):\n+\tMove to read-md.h.\n+\t* gensupport.c: Include read-md.h.\n+\t(message_with_line, n_comma_elts, scan_comma_elt): Move to\n+\tread-md.c.\n+\t* read-md.h, read-md.c: New files.\n+\n 2010-06-10  Anatoly Sokolov  <aesok@post.ru>\n \n \t* config/moxie/moxie.h (FUNCTION_VALUE, FUNCTION_OUTGOING_VALUE,"}, {"sha": "4add13fd73b49dbc0a285cc268ac126c10b53423", "filename": "gcc/Makefile.in", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1069247787d6d8c1093b3f9a8ab62c95d1a8501c/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1069247787d6d8c1093b3f9a8ab62c95d1a8501c/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=1069247787d6d8c1093b3f9a8ab62c95d1a8501c", "patch": "@@ -871,6 +871,7 @@ RTL_BASE_H = rtl.h rtl.def $(MACHMODE_H) reg-notes.def insn-notes.def \\\n   $(INPUT_H) $(REAL_H) statistics.h $(VEC_H) $(FIXED_VALUE_H) alias.h\n FIXED_VALUE_H = fixed-value.h $(MACHMODE_H) double-int.h\n RTL_H = $(RTL_BASE_H) genrtl.h vecir.h\n+READ_MD_H = $(OBSTACK_H) read-md.h\n PARAMS_H = params.h params.def\n BUILTINS_DEF = builtins.def sync-builtins.def omp-builtins.def\n TREE_H = tree.h all-tree.def tree.def c-family/c-common.def \\\n@@ -1036,8 +1037,9 @@ LDEXP_LIB = @LDEXP_LIB@\n # even if we are cross-building GCC.\n BUILD_LIBS = $(BUILD_LIBIBERTY)\n \n-BUILD_RTL = build/rtl.o build/read-rtl.o build/ggc-none.o build/vec.o \\\n-\t    build/min-insn-modes.o build/gensupport.o build/print-rtl.o\n+BUILD_RTL = build/read-md.o build/rtl.o build/read-rtl.o build/ggc-none.o \\\n+\t    build/vec.o build/min-insn-modes.o build/gensupport.o \\\n+\t    build/print-rtl.o\n BUILD_ERRORS = build/errors.o\n \n # Specify the directories to be searched for header files.\n@@ -2059,7 +2061,7 @@ lto-wrapper$(exeext): lto-wrapper.o intl.o $(LIBDEPS)\n \t$(COMPILER) $(ALL_COMPILERFLAGS) $(LDFLAGS) -o T$@ lto-wrapper.o intl.o $(LIBS)\n \tmv -f T$@ $@\n \n-lto-wrapper.o: lto-wrapper.c $(CONFIG_H) $(SYSTEM_H) defaults.h intl.h \\\n+lto-wrapper.o: lto-wrapper.c $(CONFIG_H) $(SYSTEM_H) coretypes.h intl.h \\\n \t$(OBSTACK_H)\n \n # Files used by all variants of C.\n@@ -3765,15 +3767,18 @@ build/%.o :  # dependencies provided by explicit rule later\n build/errors.o : errors.c $(BCONFIG_H) $(SYSTEM_H) errors.h\n build/gensupport.o: gensupport.c $(BCONFIG_H) $(SYSTEM_H) coretypes.h\t\\\n   $(GTM_H) $(RTL_BASE_H) $(OBSTACK_H) errors.h $(HASHTAB_H)\t\t\\\n-  gensupport.h\n+  $(READ_MD_H) gensupport.h\n build/ggc-none.o : ggc-none.c $(BCONFIG_H) $(SYSTEM_H) coretypes.h \t\\\n   $(GGC_H)\n build/min-insn-modes.o : min-insn-modes.c $(BCONFIG_H) $(SYSTEM_H)\t\\\n   $(MACHMODE_H)\n build/print-rtl.o: print-rtl.c $(BCONFIG_H) $(SYSTEM_H) coretypes.h\t\\\n   $(GTM_H) $(RTL_BASE_H)\n+build/read-md.o: read-md.c $(BCONFIG_H) $(SYSTEM_H) coretypes.h\t\t\\\n+  $(HASHTAB_H) $(READ_MD_H)\n build/read-rtl.o: read-rtl.c $(BCONFIG_H) $(SYSTEM_H) coretypes.h\t\\\n-  $(GTM_H) $(RTL_BASE_H) $(OBSTACK_H) $(HASHTAB_H) gensupport.h\n+  $(GTM_H) $(RTL_BASE_H) $(OBSTACK_H) $(HASHTAB_H) $(READ_MD_H)\t\t\\\n+  gensupport.h\n build/rtl.o: rtl.c $(BCONFIG_H) coretypes.h $(GTM_H) $(SYSTEM_H)\t\\\n   $(RTL_H) $(GGC_H) errors.h\n build/vec.o : vec.c $(BCONFIG_H) $(SYSTEM_H) coretypes.h $(VEC_H)\t\\\n@@ -3791,10 +3796,10 @@ build/gencondmd.o : \\\n \n # ...these are the programs themselves.\n build/genattr.o : genattr.c $(RTL_BASE_H) $(BCONFIG_H) $(SYSTEM_H)\t\\\n-  coretypes.h $(GTM_H) errors.h gensupport.h\n+  coretypes.h $(GTM_H) errors.h $(READ_MD_H) gensupport.h\n build/genattrtab.o : genattrtab.c $(RTL_BASE_H) $(OBSTACK_H)\t\t\\\n   $(BCONFIG_H) $(SYSTEM_H) coretypes.h $(GTM_H) errors.h $(GGC_H)\t\\\n-  gensupport.h\n+  $(READ_MD_H) gensupport.h\n build/genautomata.o : genautomata.c $(RTL_BASE_H) $(OBSTACK_H)\t\t\\\n   $(BCONFIG_H) $(SYSTEM_H) coretypes.h $(GTM_H) errors.h $(VEC_H)\t\\\n   $(HASHTAB_H) gensupport.h\n@@ -3804,17 +3809,19 @@ build/genchecksum.o : genchecksum.c $(BCONFIG_H) $(SYSTEM_H) $(MD5_H)\n build/gencodes.o : gencodes.c $(RTL_BASE_H) $(BCONFIG_H) $(SYSTEM_H)\t\\\n   coretypes.h $(GTM_H) errors.h gensupport.h\n build/genconditions.o : genconditions.c $(RTL_BASE_H) $(BCONFIG_H)\t\\\n-  $(SYSTEM_H) coretypes.h $(GTM_H) errors.h\n+  $(SYSTEM_H) coretypes.h $(GTM_H) errors.h $(HASHTAB_H) $(READ_MD_H)\t\\\n+  gensupport.h\n build/genconfig.o : genconfig.c $(RTL_BASE_H) $(BCONFIG_H) $(SYSTEM_H)\t\\\n   coretypes.h $(GTM_H) errors.h gensupport.h\n build/genconstants.o : genconstants.c $(RTL_BASE_H) $(BCONFIG_H)\t\\\n   $(SYSTEM_H) coretypes.h $(GTM_H) errors.h\n build/genemit.o : genemit.c $(RTL_BASE_H) $(BCONFIG_H) $(SYSTEM_H)\t\\\n-  coretypes.h $(GTM_H) errors.h gensupport.h\n+  coretypes.h $(GTM_H) errors.h $(READ_MD_H) gensupport.h\n build/genextract.o : genextract.c $(RTL_BASE_H) $(BCONFIG_H)\t\t\\\n-  $(SYSTEM_H) coretypes.h $(GTM_H) errors.h gensupport.h vecprim.h\n+  $(SYSTEM_H) coretypes.h $(GTM_H) errors.h $(READ_MD_H) gensupport.h\t\\\n+  vecprim.h\n build/genflags.o : genflags.c $(RTL_BASE_H) $(OBSTACK_H) $(BCONFIG_H)\t\\\n-  $(SYSTEM_H) coretypes.h $(GTM_H) errors.h gensupport.h\n+  $(SYSTEM_H) coretypes.h $(GTM_H) errors.h $(READ_MD_H) gensupport.h\n build/gengenrtl.o : gengenrtl.c $(BCONFIG_H) $(SYSTEM_H) rtl.def\n build/gengtype-lex.o : gengtype-lex.c gengtype.h $(BCONFIG_H) $(SYSTEM_H)\n build/gengtype-parse.o : gengtype-parse.c gengtype.h $(BCONFIG_H)\t\\\n@@ -3828,13 +3835,13 @@ build/genmodes.o : genmodes.c $(BCONFIG_H) $(SYSTEM_H) errors.h\t\t\\\n build/genopinit.o : genopinit.c $(RTL_BASE_H) $(BCONFIG_H) $(SYSTEM_H)\t\\\n   coretypes.h $(GTM_H) errors.h gensupport.h\n build/genoutput.o : genoutput.c $(RTL_BASE_H) $(BCONFIG_H) $(SYSTEM_H)\t\\\n-  coretypes.h $(GTM_H) errors.h gensupport.h\n+  coretypes.h $(GTM_H) errors.h $(READ_MD_H) gensupport.h\n build/genpeep.o : genpeep.c $(RTL_BASE_H) $(BCONFIG_H) $(SYSTEM_H)\t\\\n   coretypes.h $(GTM_H) errors.h gensupport.h $(TOPLEV_H)\n build/genpreds.o : genpreds.c $(RTL_BASE_H) $(BCONFIG_H) $(SYSTEM_H)\t\\\n-  coretypes.h $(GTM_H) errors.h gensupport.h $(OBSTACK_H)\n+  coretypes.h $(GTM_H) errors.h $(READ_MD_H) gensupport.h $(OBSTACK_H)\n build/genrecog.o : genrecog.c $(RTL_BASE_H) $(BCONFIG_H) $(SYSTEM_H)\t\\\n-  coretypes.h $(GTM_H) errors.h gensupport.h\n+  coretypes.h $(GTM_H) errors.h $(READ_MD_H) gensupport.h\n \n # Compile the programs that generate insn-* from the machine description.\n # They are compiled with $(COMPILER_FOR_BUILD), and associated libraries,"}, {"sha": "b26496d32bd2050258d9f9b9d315cbf1e582ec94", "filename": "gcc/coretypes.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1069247787d6d8c1093b3f9a8ab62c95d1a8501c/gcc%2Fcoretypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1069247787d6d8c1093b3f9a8ab62c95d1a8501c/gcc%2Fcoretypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoretypes.h?ref=1069247787d6d8c1093b3f9a8ab62c95d1a8501c", "patch": "@@ -113,6 +113,15 @@ typedef const struct edge_def *const_edge;\n struct basic_block_def;\n typedef struct basic_block_def *basic_block;\n typedef const struct basic_block_def *const_basic_block;\n+\n+#define obstack_chunk_alloc\t((void *(*) (long)) xmalloc)\n+#define obstack_chunk_free\t((void (*) (void *)) free)\n+#define OBSTACK_CHUNK_SIZE\t0\n+#define gcc_obstack_init(OBSTACK)\t\t\t\\\n+  _obstack_begin ((OBSTACK), OBSTACK_CHUNK_SIZE, 0,\t\\\n+\t\t  obstack_chunk_alloc,\t\t\t\\\n+\t\t  obstack_chunk_free)\n+\n #else\n \n struct _dont_use_rtx_here_;"}, {"sha": "c4809c97b20896cf552b1f53f3dab9a79d0c0598", "filename": "gcc/defaults.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1069247787d6d8c1093b3f9a8ab62c95d1a8501c/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1069247787d6d8c1093b3f9a8ab62c95d1a8501c/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=1069247787d6d8c1093b3f9a8ab62c95d1a8501c", "patch": "@@ -32,14 +32,6 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #define GET_ENVIRONMENT(VALUE, NAME) do { (VALUE) = getenv (NAME); } while (0)\n #endif\n \n-#define obstack_chunk_alloc\t((void *(*) (long)) xmalloc)\n-#define obstack_chunk_free\t((void (*) (void *)) free)\n-#define OBSTACK_CHUNK_SIZE\t0\n-#define gcc_obstack_init(OBSTACK)\t\t\t\\\n-  _obstack_begin ((OBSTACK), OBSTACK_CHUNK_SIZE, 0,\t\\\n-\t\t  obstack_chunk_alloc,\t\t\t\\\n-\t\t  obstack_chunk_free)\n-\n /* Store in OUTPUT a string (made with alloca) containing an\n    assembler-name for a local static variable or function named NAME.\n    LABELNO is an integer which is different for each call.  */"}, {"sha": "78c510d3b13569554eb9226548b4f78a4b5a199b", "filename": "gcc/genattr.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1069247787d6d8c1093b3f9a8ab62c95d1a8501c/gcc%2Fgenattr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1069247787d6d8c1093b3f9a8ab62c95d1a8501c/gcc%2Fgenattr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattr.c?ref=1069247787d6d8c1093b3f9a8ab62c95d1a8501c", "patch": "@@ -26,6 +26,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tm.h\"\n #include \"rtl.h\"\n #include \"errors.h\"\n+#include \"read-md.h\"\n #include \"gensupport.h\"\n \n "}, {"sha": "a641f8bbaabcf94699008da89bd0e140d8ddc6e4", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1069247787d6d8c1093b3f9a8ab62c95d1a8501c/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1069247787d6d8c1093b3f9a8ab62c95d1a8501c/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=1069247787d6d8c1093b3f9a8ab62c95d1a8501c", "patch": "@@ -109,9 +109,10 @@ along with GCC; see the file COPYING3.  If not see\n #include \"coretypes.h\"\n #include \"tm.h\"\n #include \"rtl.h\"\n-#include \"gensupport.h\"\n #include \"obstack.h\"\n #include \"errors.h\"\n+#include \"read-md.h\"\n+#include \"gensupport.h\"\n \n /* Flags for make_internal_attr's `special' parameter.  */\n #define ATTR_NONE\t\t0"}, {"sha": "aed0469b4f0cc70fc4de4f70ecead99805f56ae6", "filename": "gcc/genconditions.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1069247787d6d8c1093b3f9a8ab62c95d1a8501c/gcc%2Fgenconditions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1069247787d6d8c1093b3f9a8ab62c95d1a8501c/gcc%2Fgenconditions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenconditions.c?ref=1069247787d6d8c1093b3f9a8ab62c95d1a8501c", "patch": "@@ -33,6 +33,7 @@\n #include \"rtl.h\"\n #include \"errors.h\"\n #include \"hashtab.h\"\n+#include \"read-md.h\"\n #include \"gensupport.h\"\n \n /* so we can include except.h in the generated file.  */"}, {"sha": "e0e48363f3886c3d61edd5693eb4b086d41722f8", "filename": "gcc/genemit.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1069247787d6d8c1093b3f9a8ab62c95d1a8501c/gcc%2Fgenemit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1069247787d6d8c1093b3f9a8ab62c95d1a8501c/gcc%2Fgenemit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenemit.c?ref=1069247787d6d8c1093b3f9a8ab62c95d1a8501c", "patch": "@@ -25,6 +25,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tm.h\"\n #include \"rtl.h\"\n #include \"errors.h\"\n+#include \"read-md.h\"\n #include \"gensupport.h\"\n \n "}, {"sha": "289bc093235e28bd2f3d96200b056b3464bea047", "filename": "gcc/genextract.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1069247787d6d8c1093b3f9a8ab62c95d1a8501c/gcc%2Fgenextract.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1069247787d6d8c1093b3f9a8ab62c95d1a8501c/gcc%2Fgenextract.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenextract.c?ref=1069247787d6d8c1093b3f9a8ab62c95d1a8501c", "patch": "@@ -26,6 +26,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tm.h\"\n #include \"rtl.h\"\n #include \"errors.h\"\n+#include \"read-md.h\"\n #include \"gensupport.h\"\n #include \"vec.h\"\n #include \"vecprim.h\""}, {"sha": "6f0fdf1f9418f3a2d3f18368eefe8142ae8800de", "filename": "gcc/genflags.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1069247787d6d8c1093b3f9a8ab62c95d1a8501c/gcc%2Fgenflags.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1069247787d6d8c1093b3f9a8ab62c95d1a8501c/gcc%2Fgenflags.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenflags.c?ref=1069247787d6d8c1093b3f9a8ab62c95d1a8501c", "patch": "@@ -28,6 +28,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"rtl.h\"\n #include \"obstack.h\"\n #include \"errors.h\"\n+#include \"read-md.h\"\n #include \"gensupport.h\"\n \n /* Obstack to remember insns with.  */"}, {"sha": "8fc3f47a4ead6b8ea5dc44e09df8f834befaf2bb", "filename": "gcc/genoutput.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1069247787d6d8c1093b3f9a8ab62c95d1a8501c/gcc%2Fgenoutput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1069247787d6d8c1093b3f9a8ab62c95d1a8501c/gcc%2Fgenoutput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenoutput.c?ref=1069247787d6d8c1093b3f9a8ab62c95d1a8501c", "patch": "@@ -88,6 +88,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tm.h\"\n #include \"rtl.h\"\n #include \"errors.h\"\n+#include \"read-md.h\"\n #include \"gensupport.h\"\n \n /* No instruction can have more operands than this.  Sorry for this"}, {"sha": "42528ac75345b25460e4bf947188361582389998", "filename": "gcc/genpreds.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1069247787d6d8c1093b3f9a8ab62c95d1a8501c/gcc%2Fgenpreds.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1069247787d6d8c1093b3f9a8ab62c95d1a8501c/gcc%2Fgenpreds.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenpreds.c?ref=1069247787d6d8c1093b3f9a8ab62c95d1a8501c", "patch": "@@ -28,6 +28,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"rtl.h\"\n #include \"errors.h\"\n #include \"obstack.h\"\n+#include \"read-md.h\"\n #include \"gensupport.h\"\n \n /* Given a predicate expression EXP, from form NAME at line LINENO,"}, {"sha": "a8b8bdd4afdd7d21954551d18edcfbe1ca78af60", "filename": "gcc/genrecog.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1069247787d6d8c1093b3f9a8ab62c95d1a8501c/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1069247787d6d8c1093b3f9a8ab62c95d1a8501c/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=1069247787d6d8c1093b3f9a8ab62c95d1a8501c", "patch": "@@ -56,6 +56,7 @@\n #include \"tm.h\"\n #include \"rtl.h\"\n #include \"errors.h\"\n+#include \"read-md.h\"\n #include \"gensupport.h\"\n \n #define OUTPUT_LABEL(INDENT_STRING, LABEL_NUMBER) \\"}, {"sha": "4332772444d185cc9e8d8943a173c2f849425e91", "filename": "gcc/gensupport.c", "status": "modified", "additions": 1, "deletions": 61, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1069247787d6d8c1093b3f9a8ab62c95d1a8501c/gcc%2Fgensupport.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1069247787d6d8c1093b3f9a8ab62c95d1a8501c/gcc%2Fgensupport.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgensupport.c?ref=1069247787d6d8c1093b3f9a8ab62c95d1a8501c", "patch": "@@ -26,6 +26,7 @@\n #include \"obstack.h\"\n #include \"errors.h\"\n #include \"hashtab.h\"\n+#include \"read-md.h\"\n #include \"gensupport.h\"\n \n \n@@ -119,20 +120,6 @@ static char *save_string (const char *, int);\n static void init_predicate_table (void);\n static void record_insn_name (int, const char *);\n \f\n-void\n-message_with_line (int lineno, const char *msg, ...)\n-{\n-  va_list ap;\n-\n-  va_start (ap, msg);\n-\n-  fprintf (stderr, \"%s:%d: \", read_rtx_filename, lineno);\n-  vfprintf (stderr, msg, ap);\n-  fputc ('\\n', stderr);\n-\n-  va_end (ap);\n-}\n-\n /* Make a version of gen_rtx_CONST_INT so that GEN_INT can be used in\n    the gensupport programs.  */\n \n@@ -1227,53 +1214,6 @@ traverse_c_tests (htab_trav callback, void *info)\n     htab_traverse (condition_table, callback, info);\n }\n \n-\n-/* Given a string, return the number of comma-separated elements in it.\n-   Return 0 for the null string.  */\n-int\n-n_comma_elts (const char *s)\n-{\n-  int n;\n-\n-  if (*s == '\\0')\n-    return 0;\n-\n-  for (n = 1; *s; s++)\n-    if (*s == ',')\n-      n++;\n-\n-  return n;\n-}\n-\n-/* Given a pointer to a (char *), return a pointer to the beginning of the\n-   next comma-separated element in the string.  Advance the pointer given\n-   to the end of that element.  Return NULL if at end of string.  Caller\n-   is responsible for copying the string if necessary.  White space between\n-   a comma and an element is ignored.  */\n-\n-const char *\n-scan_comma_elt (const char **pstr)\n-{\n-  const char *start;\n-  const char *p = *pstr;\n-\n-  if (*p == ',')\n-    p++;\n-  while (ISSPACE(*p))\n-    p++;\n-\n-  if (*p == '\\0')\n-    return NULL;\n-\n-  start = p;\n-\n-  while (*p != ',' && *p != '\\0')\n-    p++;\n-\n-  *pstr = p;\n-  return start;\n-}\n-\n /* Helper functions for define_predicate and define_special_predicate\n    processing.  Shared between genrecog.c and genpreds.c.  */\n "}, {"sha": "3e916bef99fcd9390a2dd4a1fda748ef84e7c90b", "filename": "gcc/gensupport.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1069247787d6d8c1093b3f9a8ab62c95d1a8501c/gcc%2Fgensupport.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1069247787d6d8c1093b3f9a8ab62c95d1a8501c/gcc%2Fgensupport.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgensupport.h?ref=1069247787d6d8c1093b3f9a8ab62c95d1a8501c", "patch": "@@ -29,9 +29,6 @@ extern int init_md_reader_args_cb (int, char **, bool (*)(const char *));\n extern int init_md_reader_args (int, char **);\n extern rtx read_md_rtx (int *, int *);\n \n-extern void message_with_line (int, const char *, ...)\n-     ATTRIBUTE_PRINTF_2;\n-\n /* Set this to 0 to disable automatic elision of insn patterns which\n    can never be used in this configuration.  See genconditions.c.\n    Must be set before calling init_md_reader.  */\n@@ -60,9 +57,6 @@ extern int cmp_c_test (const void *, const void *);\n extern void traverse_c_tests (htab_trav, void *);\n #endif\n \n-extern int n_comma_elts\t(const char *);\n-extern const char *scan_comma_elt (const char **);\n-\n /* Predicate handling: helper functions and data structures.  */\n \n struct pred_data"}, {"sha": "da120b38e58fcc0ea319f9dcf5e07119cb8a87f7", "filename": "gcc/lto-wrapper.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1069247787d6d8c1093b3f9a8ab62c95d1a8501c/gcc%2Flto-wrapper.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1069247787d6d8c1093b3f9a8ab62c95d1a8501c/gcc%2Flto-wrapper.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-wrapper.c?ref=1069247787d6d8c1093b3f9a8ab62c95d1a8501c", "patch": "@@ -39,12 +39,12 @@ along with GCC; see the file COPYING3.  If not see\n \n #include \"config.h\"\n #include \"system.h\"\n+#include \"coretypes.h\"\n #include <errno.h>\n #include <signal.h>\n #if ! defined( SIGCHLD ) && defined( SIGCLD )\n #  define SIGCHLD SIGCLD\n #endif\n-#include \"defaults.h\"\n #include \"intl.h\"\n #include \"libiberty.h\"\n #include \"obstack.h\""}, {"sha": "8aa99787c59ab5fe5fa77d34f5498f74ca6a0a10", "filename": "gcc/pretty-print.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1069247787d6d8c1093b3f9a8ab62c95d1a8501c/gcc%2Fpretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1069247787d6d8c1093b3f9a8ab62c95d1a8501c/gcc%2Fpretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpretty-print.c?ref=1069247787d6d8c1093b3f9a8ab62c95d1a8501c", "patch": "@@ -29,9 +29,6 @@ along with GCC; see the file COPYING3.  If not see\n #include <iconv.h>\n #endif\n \n-#define obstack_chunk_alloc xmalloc\n-#define obstack_chunk_free  free\n-\n /* A pointer to the formatted diagnostic message.  */\n #define pp_formatted_text_data(PP) \\\n    ((const char *) obstack_base (pp_base (PP)->buffer->obstack))"}, {"sha": "48d75ceb60ef5c9c28838679a4eb0f3d978d70e2", "filename": "gcc/read-md.c", "status": "added", "additions": 512, "deletions": 0, "changes": 512, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1069247787d6d8c1093b3f9a8ab62c95d1a8501c/gcc%2Fread-md.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1069247787d6d8c1093b3f9a8ab62c95d1a8501c/gcc%2Fread-md.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-md.c?ref=1069247787d6d8c1093b3f9a8ab62c95d1a8501c", "patch": "@@ -0,0 +1,512 @@\n+/* MD reader for GCC.\n+   Copyright (C) 1987, 1988, 1991, 1994, 1997, 1998, 1999, 2000, 2001, 2002,\n+   2003, 2004, 2005, 2006, 2007, 2008, 2010\n+   Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"bconfig.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"hashtab.h\"\n+#include \"read-md.h\"\n+\n+/* Associates PTR (which can be a string, etc.) with the file location\n+   specified by FILENAME and LINENO.  */\n+struct ptr_loc {\n+  const void *ptr;\n+  const char *filename;\n+  int lineno;\n+};\n+\n+/* Obstack used for allocating RTL strings.  */\n+struct obstack string_obstack;\n+\n+/* A table of ptr_locs, hashed on the PTR field.  */\n+static htab_t ptr_locs;\n+\n+/* An obstack for the above.  Plain xmalloc is a bit heavyweight for a\n+   small structure like ptr_loc.  */\n+static struct obstack ptr_loc_obstack;\n+\n+/* A hash table of triples (A, B, C), where each of A, B and C is a condition\n+   and A is equivalent to \"B && C\".  This is used to keep track of the source\n+   of conditions that are made up of separate rtx strings (such as the split\n+   condition of a define_insn_and_split).  */\n+static htab_t joined_conditions;\n+\n+/* An obstack for allocating joined_conditions entries.  */\n+static struct obstack joined_conditions_obstack;\n+\n+/* The current line number for the file.  */\n+int read_rtx_lineno = 1;\n+\n+/* The filename for error reporting.  */\n+const char *read_rtx_filename = \"<unknown>\";\n+\n+/* Return a hash value for the pointer pointed to by DEF.  */\n+\n+static hashval_t\n+leading_ptr_hash (const void *def)\n+{\n+  return htab_hash_pointer (*(const void *const *) def);\n+}\n+\n+/* Return true if DEF1 and DEF2 are pointers to the same pointer.  */\n+\n+static int\n+leading_ptr_eq_p (const void *def1, const void *def2)\n+{\n+  return *(const void *const *) def1 == *(const void *const *) def2;\n+}\n+\n+/* Associate PTR with the file position given by FILENAME and LINENO.  */\n+\n+static void\n+set_rtx_ptr_loc (const void *ptr, const char *filename, int lineno)\n+{\n+  struct ptr_loc *loc;\n+\n+  loc = (struct ptr_loc *) obstack_alloc (&ptr_loc_obstack,\n+\t\t\t\t\t  sizeof (struct ptr_loc));\n+  loc->ptr = ptr;\n+  loc->filename = filename;\n+  loc->lineno = lineno;\n+  *htab_find_slot (ptr_locs, loc, INSERT) = loc;\n+}\n+\n+/* Return the position associated with pointer PTR.  Return null if no\n+   position was set.  */\n+\n+static const struct ptr_loc *\n+get_rtx_ptr_loc (const void *ptr)\n+{\n+  return (const struct ptr_loc *) htab_find (ptr_locs, &ptr);\n+}\n+\n+/* Associate NEW_PTR with the same file position as OLD_PTR.  */\n+\n+void\n+copy_rtx_ptr_loc (const void *new_ptr, const void *old_ptr)\n+{\n+  const struct ptr_loc *loc = get_rtx_ptr_loc (old_ptr);\n+  if (loc != 0)\n+    set_rtx_ptr_loc (new_ptr, loc->filename, loc->lineno);\n+}\n+\n+/* If PTR is associated with a known file position, print a #line\n+   directive for it.  */\n+\n+void\n+print_rtx_ptr_loc (const void *ptr)\n+{\n+  const struct ptr_loc *loc = get_rtx_ptr_loc (ptr);\n+  if (loc != 0)\n+    printf (\"#line %d \\\"%s\\\"\\n\", loc->lineno, loc->filename);\n+}\n+\n+/* Return a condition that satisfies both COND1 and COND2.  Either string\n+   may be null or empty.  */\n+\n+const char *\n+join_c_conditions (const char *cond1, const char *cond2)\n+{\n+  char *result;\n+  const void **entry;\n+\n+  if (cond1 == 0 || cond1[0] == 0)\n+    return cond2;\n+\n+  if (cond2 == 0 || cond2[0] == 0)\n+    return cond1;\n+\n+  if (strcmp (cond1, cond2) == 0)\n+    return cond1;\n+\n+  result = concat (\"(\", cond1, \") && (\", cond2, \")\", NULL);\n+  obstack_ptr_grow (&joined_conditions_obstack, result);\n+  obstack_ptr_grow (&joined_conditions_obstack, cond1);\n+  obstack_ptr_grow (&joined_conditions_obstack, cond2);\n+  entry = XOBFINISH (&joined_conditions_obstack, const void **);\n+  *htab_find_slot (joined_conditions, entry, INSERT) = entry;\n+  return result;\n+}\n+\n+/* Print condition COND, wrapped in brackets.  If COND was created by\n+   join_c_conditions, recursively invoke this function for the original\n+   conditions and join the result with \"&&\".  Otherwise print a #line\n+   directive for COND if its original file position is known.  */\n+\n+void\n+print_c_condition (const char *cond)\n+{\n+  const char **halves = (const char **) htab_find (joined_conditions, &cond);\n+  if (halves != 0)\n+    {\n+      printf (\"(\");\n+      print_c_condition (halves[1]);\n+      printf (\" && \");\n+      print_c_condition (halves[2]);\n+      printf (\")\");\n+    }\n+  else\n+    {\n+      putc ('\\n', stdout);\n+      print_rtx_ptr_loc (cond);\n+      printf (\"(%s)\", cond);\n+    }\n+}\n+\n+/* A printf-like function for reporting an error against line LINENO\n+   in the current MD file.  */\n+\n+void\n+message_with_line (int lineno, const char *msg, ...)\n+{\n+  va_list ap;\n+\n+  va_start (ap, msg);\n+\n+  fprintf (stderr, \"%s:%d: \", read_rtx_filename, lineno);\n+  vfprintf (stderr, msg, ap);\n+  fputc ('\\n', stderr);\n+\n+  va_end (ap);\n+}\n+\n+/* A printf-like function for reporting an error against the current\n+   position in the MD file, which is associated with INFILE.  */\n+\n+void\n+fatal_with_file_and_line (FILE *infile, const char *msg, ...)\n+{\n+  char context[64];\n+  size_t i;\n+  int c;\n+  va_list ap;\n+\n+  va_start (ap, msg);\n+\n+  fprintf (stderr, \"%s:%d: \", read_rtx_filename, read_rtx_lineno);\n+  vfprintf (stderr, msg, ap);\n+  putc ('\\n', stderr);\n+\n+  /* Gather some following context.  */\n+  for (i = 0; i < sizeof (context)-1; ++i)\n+    {\n+      c = getc (infile);\n+      if (c == EOF)\n+\tbreak;\n+      if (c == '\\r' || c == '\\n')\n+\tbreak;\n+      context[i] = c;\n+    }\n+  context[i] = '\\0';\n+\n+  fprintf (stderr, \"%s:%d: following context is `%s'\\n\",\n+\t   read_rtx_filename, read_rtx_lineno, context);\n+\n+  va_end (ap);\n+  exit (1);\n+}\n+\n+/* Report that we found character ACTUAL when we expected to find\n+   character EXPECTED.  INFILE is the file handle associated\n+   with the current file.  */\n+\n+void\n+fatal_expected_char (FILE *infile, int expected, int actual)\n+{\n+  if (actual == EOF)\n+    fatal_with_file_and_line (infile, \"expected character `%c', found EOF\",\n+\t\t\t      expected);\n+  else\n+    fatal_with_file_and_line (infile, \"expected character `%c', found `%c'\",\n+\t\t\t      expected, actual);\n+}\n+\n+/* Read chars from INFILE until a non-whitespace char and return that.\n+   Comments, both Lisp style and C style, are treated as whitespace.  */\n+\n+int\n+read_skip_spaces (FILE *infile)\n+{\n+  int c;\n+\n+  while (1)\n+    {\n+      c = getc (infile);\n+      switch (c)\n+\t{\n+\tcase '\\n':\n+\t  read_rtx_lineno++;\n+\t  break;\n+\n+\tcase ' ': case '\\t': case '\\f': case '\\r':\n+\t  break;\n+\n+\tcase ';':\n+\t  do\n+\t    c = getc (infile);\n+\t  while (c != '\\n' && c != EOF);\n+\t  read_rtx_lineno++;\n+\t  break;\n+\n+\tcase '/':\n+\t  {\n+\t    int prevc;\n+\t    c = getc (infile);\n+\t    if (c != '*')\n+\t      fatal_expected_char (infile, '*', c);\n+\n+\t    prevc = 0;\n+\t    while ((c = getc (infile)) && c != EOF)\n+\t      {\n+\t\tif (c == '\\n')\n+\t\t   read_rtx_lineno++;\n+\t        else if (prevc == '*' && c == '/')\n+\t\t  break;\n+\t        prevc = c;\n+\t      }\n+\t  }\n+\t  break;\n+\n+\tdefault:\n+\t  return c;\n+\t}\n+    }\n+}\n+\n+/* Subroutine of the string readers.  Handles backslash escapes.\n+   Caller has read the backslash, but not placed it into the obstack.  */\n+\n+static void\n+read_escape (FILE *infile)\n+{\n+  int c = getc (infile);\n+\n+  switch (c)\n+    {\n+      /* Backslash-newline is replaced by nothing, as in C.  */\n+    case '\\n':\n+      read_rtx_lineno++;\n+      return;\n+\n+      /* \\\" \\' \\\\ are replaced by the second character.  */\n+    case '\\\\':\n+    case '\"':\n+    case '\\'':\n+      break;\n+\n+      /* Standard C string escapes:\n+\t \\a \\b \\f \\n \\r \\t \\v\n+\t \\[0-7] \\x\n+\t all are passed through to the output string unmolested.\n+\t In normal use these wind up in a string constant processed\n+\t by the C compiler, which will translate them appropriately.\n+\t We do not bother checking that \\[0-7] are followed by up to\n+\t two octal digits, or that \\x is followed by N hex digits.\n+\t \\? \\u \\U are left out because they are not in traditional C.  */\n+    case 'a': case 'b': case 'f': case 'n': case 'r': case 't': case 'v':\n+    case '0': case '1': case '2': case '3': case '4': case '5': case '6':\n+    case '7': case 'x':\n+      obstack_1grow (&string_obstack, '\\\\');\n+      break;\n+\n+      /* \\; makes stuff for a C string constant containing\n+\t newline and tab.  */\n+    case ';':\n+      obstack_grow (&string_obstack, \"\\\\n\\\\t\", 4);\n+      return;\n+\n+      /* pass anything else through, but issue a warning.  */\n+    default:\n+      fprintf (stderr, \"%s:%d: warning: unrecognized escape \\\\%c\\n\",\n+\t       read_rtx_filename, read_rtx_lineno, c);\n+      obstack_1grow (&string_obstack, '\\\\');\n+      break;\n+    }\n+\n+  obstack_1grow (&string_obstack, c);\n+}\n+\n+/* Read a double-quoted string onto the obstack.  Caller has scanned\n+   the leading quote.  */\n+\n+char *\n+read_quoted_string (FILE *infile)\n+{\n+  int c;\n+\n+  while (1)\n+    {\n+      c = getc (infile); /* Read the string  */\n+      if (c == '\\n')\n+\tread_rtx_lineno++;\n+      else if (c == '\\\\')\n+\t{\n+\t  read_escape (infile);\n+\t  continue;\n+\t}\n+      else if (c == '\"' || c == EOF)\n+\tbreak;\n+\n+      obstack_1grow (&string_obstack, c);\n+    }\n+\n+  obstack_1grow (&string_obstack, 0);\n+  return XOBFINISH (&string_obstack, char *);\n+}\n+\n+/* Read a braced string (a la Tcl) onto the string obstack.  Caller\n+   has scanned the leading brace.  Note that unlike quoted strings,\n+   the outermost braces _are_ included in the string constant.  */\n+\n+static char *\n+read_braced_string (FILE *infile)\n+{\n+  int c;\n+  int brace_depth = 1;  /* caller-processed */\n+  unsigned long starting_read_rtx_lineno = read_rtx_lineno;\n+\n+  obstack_1grow (&string_obstack, '{');\n+  while (brace_depth)\n+    {\n+      c = getc (infile); /* Read the string  */\n+\n+      if (c == '\\n')\n+\tread_rtx_lineno++;\n+      else if (c == '{')\n+\tbrace_depth++;\n+      else if (c == '}')\n+\tbrace_depth--;\n+      else if (c == '\\\\')\n+\t{\n+\t  read_escape (infile);\n+\t  continue;\n+\t}\n+      else if (c == EOF)\n+\tfatal_with_file_and_line\n+\t  (infile, \"missing closing } for opening brace on line %lu\",\n+\t   starting_read_rtx_lineno);\n+\n+      obstack_1grow (&string_obstack, c);\n+    }\n+\n+  obstack_1grow (&string_obstack, 0);\n+  return XOBFINISH (&string_obstack, char *);\n+}\n+\n+/* Read some kind of string constant.  This is the high-level routine\n+   used by read_rtx.  It handles surrounding parentheses, leading star,\n+   and dispatch to the appropriate string constant reader.  */\n+\n+char *\n+read_string (FILE *infile, int star_if_braced)\n+{\n+  char *stringbuf;\n+  int saw_paren = 0;\n+  int c, old_lineno;\n+\n+  c = read_skip_spaces (infile);\n+  if (c == '(')\n+    {\n+      saw_paren = 1;\n+      c = read_skip_spaces (infile);\n+    }\n+\n+  old_lineno = read_rtx_lineno;\n+  if (c == '\"')\n+    stringbuf = read_quoted_string (infile);\n+  else if (c == '{')\n+    {\n+      if (star_if_braced)\n+\tobstack_1grow (&string_obstack, '*');\n+      stringbuf = read_braced_string (infile);\n+    }\n+  else\n+    fatal_with_file_and_line (infile, \"expected `\\\"' or `{', found `%c'\", c);\n+\n+  if (saw_paren)\n+    {\n+      c = read_skip_spaces (infile);\n+      if (c != ')')\n+\tfatal_expected_char (infile, ')', c);\n+    }\n+\n+  set_rtx_ptr_loc (stringbuf, read_rtx_filename, old_lineno);\n+  return stringbuf;\n+}\n+\n+/* Given a string, return the number of comma-separated elements in it.\n+   Return 0 for the null string.  */\n+\n+int\n+n_comma_elts (const char *s)\n+{\n+  int n;\n+\n+  if (*s == '\\0')\n+    return 0;\n+\n+  for (n = 1; *s; s++)\n+    if (*s == ',')\n+      n++;\n+\n+  return n;\n+}\n+\n+/* Given a pointer to a (char *), return a pointer to the beginning of the\n+   next comma-separated element in the string.  Advance the pointer given\n+   to the end of that element.  Return NULL if at end of string.  Caller\n+   is responsible for copying the string if necessary.  White space between\n+   a comma and an element is ignored.  */\n+\n+const char *\n+scan_comma_elt (const char **pstr)\n+{\n+  const char *start;\n+  const char *p = *pstr;\n+\n+  if (*p == ',')\n+    p++;\n+  while (ISSPACE(*p))\n+    p++;\n+\n+  if (*p == '\\0')\n+    return NULL;\n+\n+  start = p;\n+\n+  while (*p != ',' && *p != '\\0')\n+    p++;\n+\n+  *pstr = p;\n+  return start;\n+}\n+\n+/* Initialize this file's static data.  */\n+\n+void\n+init_md_reader (void)\n+{\n+  obstack_init (&string_obstack);\n+  ptr_locs = htab_create (161, leading_ptr_hash, leading_ptr_eq_p, 0);\n+  obstack_init (&ptr_loc_obstack);\n+  joined_conditions = htab_create (161, leading_ptr_hash, leading_ptr_eq_p, 0);\n+  obstack_init (&joined_conditions_obstack);\n+}"}, {"sha": "ec9dcdd2ae3b83ba3619438f0cad04a569e2532b", "filename": "gcc/read-md.h", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1069247787d6d8c1093b3f9a8ab62c95d1a8501c/gcc%2Fread-md.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1069247787d6d8c1093b3f9a8ab62c95d1a8501c/gcc%2Fread-md.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-md.h?ref=1069247787d6d8c1093b3f9a8ab62c95d1a8501c", "patch": "@@ -0,0 +1,41 @@\n+/* MD reader definitions.\n+   Copyright (C) 1987, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,\n+   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010\n+   Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"obstack.h\"\n+\n+extern int read_rtx_lineno;\n+extern const char *read_rtx_filename;\n+extern struct obstack string_obstack;\n+\n+extern void copy_rtx_ptr_loc (const void *, const void *);\n+extern void print_rtx_ptr_loc (const void *);\n+extern const char *join_c_conditions (const char *, const char *);\n+extern void print_c_condition (const char *);\n+extern void message_with_line (int, const char *, ...) ATTRIBUTE_PRINTF_2;\n+extern void fatal_with_file_and_line (FILE *, const char *, ...)\n+  ATTRIBUTE_PRINTF_2 ATTRIBUTE_NORETURN;\n+extern void fatal_expected_char (FILE *, int, int) ATTRIBUTE_NORETURN;\n+extern int read_skip_spaces (FILE *);\n+extern char *read_quoted_string (FILE *);\n+extern char *read_string (FILE *, int);\n+extern int n_comma_elts (const char *);\n+extern const char *scan_comma_elt (const char **);\n+extern void init_md_reader (void);"}, {"sha": "be7cbad6f3c3aa7a6389c94d6d9a8fe7e2d578d2", "filename": "gcc/read-rtl.c", "status": "modified", "additions": 2, "deletions": 425, "changes": 427, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1069247787d6d8c1093b3f9a8ab62c95d1a8501c/gcc%2Fread-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1069247787d6d8c1093b3f9a8ab62c95d1a8501c/gcc%2Fread-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-rtl.c?ref=1069247787d6d8c1093b3f9a8ab62c95d1a8501c", "patch": "@@ -30,6 +30,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"rtl.h\"\n #include \"obstack.h\"\n #include \"hashtab.h\"\n+#include \"read-md.h\"\n #include \"gensupport.h\"\n \n static htab_t md_constants;\n@@ -79,14 +80,6 @@ struct iterator_group {\n   void (*apply_iterator) (rtx, int);\n };\n \n-/* Associates PTR (which can be a string, etc.) with the file location\n-   specified by FILENAME and LINENO.  */\n-struct ptr_loc {\n-  const void *ptr;\n-  const char *filename;\n-  int lineno;\n-};\n-\n /* A structure used to pass data from read_rtx to apply_iterator_traverse\n    via htab_traverse.  */\n struct iterator_traverse_data {\n@@ -105,9 +98,6 @@ struct iterator_traverse_data {\n #define BELLWETHER_CODE(CODE) \\\n   ((CODE) < NUM_RTX_CODE ? CODE : bellwether_codes[CODE - NUM_RTX_CODE])\n \n-static void fatal_with_file_and_line (FILE *, const char *, ...)\n-  ATTRIBUTE_PRINTF_2 ATTRIBUTE_NORETURN;\n-static void fatal_expected_char (FILE *, int, int) ATTRIBUTE_NORETURN;\n static int find_mode (const char *, FILE *);\n static bool uses_mode_iterator_p (rtx, int);\n static void apply_mode_iterator (rtx, int);\n@@ -127,14 +117,6 @@ static struct map_value **add_map_value (struct map_value **,\n \t\t\t\t\t int, const char *);\n static void initialize_iterators (void);\n static void read_name (char *, FILE *);\n-static hashval_t leading_ptr_hash (const void *);\n-static int leading_ptr_eq_p (const void *, const void *);\n-static void set_rtx_ptr_loc (const void *, const char *, int);\n-static const struct ptr_loc *get_rtx_ptr_loc (const void *);\n-static char *read_string (FILE *, int);\n-static char *read_quoted_string (FILE *);\n-static char *read_braced_string (FILE *);\n-static void read_escape (FILE *);\n static hashval_t def_hash (const void *);\n static int def_name_eq_p (const void *, const void *);\n static void read_constants (FILE *infile, char *tmp_char);\n@@ -152,80 +134,6 @@ static struct iterator_group modes, codes;\n /* Index I is the value of BELLWETHER_CODE (I + NUM_RTX_CODE).  */\n static enum rtx_code *bellwether_codes;\n \n-/* Obstack used for allocating RTL strings.  */\n-static struct obstack string_obstack;\n-\n-/* A table of ptr_locs, hashed on the PTR field.  */\n-static htab_t ptr_locs;\n-\n-/* An obstack for the above.  Plain xmalloc is a bit heavyweight for a\n-   small structure like ptr_loc.  */\n-static struct obstack ptr_loc_obstack;\n-\n-/* A hash table of triples (A, B, C), where each of A, B and C is a condition\n-   and A is equivalent to \"B && C\".  This is used to keep track of the source\n-   of conditions that are made up of separate rtx strings (such as the split\n-   condition of a define_insn_and_split).  */\n-static htab_t joined_conditions;\n-\n-/* An obstack for allocating joined_conditions entries.  */\n-static struct obstack joined_conditions_obstack;\n-\n-/* Subroutines of read_rtx.  */\n-\n-/* The current line number for the file.  */\n-int read_rtx_lineno = 1;\n-\n-/* The filename for error reporting.  */\n-const char *read_rtx_filename = \"<unknown>\";\n-\n-static void\n-fatal_with_file_and_line (FILE *infile, const char *msg, ...)\n-{\n-  char context[64];\n-  size_t i;\n-  int c;\n-  va_list ap;\n-\n-  va_start (ap, msg);\n-\n-  fprintf (stderr, \"%s:%d: \", read_rtx_filename, read_rtx_lineno);\n-  vfprintf (stderr, msg, ap);\n-  putc ('\\n', stderr);\n-\n-  /* Gather some following context.  */\n-  for (i = 0; i < sizeof (context)-1; ++i)\n-    {\n-      c = getc (infile);\n-      if (c == EOF)\n-\tbreak;\n-      if (c == '\\r' || c == '\\n')\n-\tbreak;\n-      context[i] = c;\n-    }\n-  context[i] = '\\0';\n-\n-  fprintf (stderr, \"%s:%d: following context is `%s'\\n\",\n-\t   read_rtx_filename, read_rtx_lineno, context);\n-\n-  va_end (ap);\n-  exit (1);\n-}\n-\n-/* Dump code after printing a message.  Used when read_rtx finds\n-   invalid data.  */\n-\n-static void\n-fatal_expected_char (FILE *infile, int expected_c, int actual_c)\n-{\n-  if (actual_c == EOF)\n-    fatal_with_file_and_line (infile, \"expected character `%c', found EOF\",\n-\t\t\t      expected_c);\n-  else\n-    fatal_with_file_and_line (infile, \"expected character `%c', found `%c'\",\n-\t\t\t      expected_c, actual_c);\n-}\n-\n /* Implementations of the iterator_group callbacks for modes.  */\n \n static int\n@@ -711,173 +619,6 @@ initialize_iterators (void)\n     }\n }\n \n-/* Return a hash value for the pointer pointed to by DEF.  */\n-\n-static hashval_t\n-leading_ptr_hash (const void *def)\n-{\n-  return htab_hash_pointer (*(const void *const *) def);\n-}\n-\n-/* Return true if DEF1 and DEF2 are pointers to the same pointer.  */\n-\n-static int\n-leading_ptr_eq_p (const void *def1, const void *def2)\n-{\n-  return *(const void *const *) def1 == *(const void *const *) def2;\n-}\n-\n-/* Associate PTR with the file position given by FILENAME and LINENO.  */\n-\n-static void\n-set_rtx_ptr_loc (const void *ptr, const char *filename, int lineno)\n-{\n-  struct ptr_loc *loc;\n-\n-  loc = (struct ptr_loc *) obstack_alloc (&ptr_loc_obstack,\n-\t\t\t\t\t  sizeof (struct ptr_loc));\n-  loc->ptr = ptr;\n-  loc->filename = filename;\n-  loc->lineno = lineno;\n-  *htab_find_slot (ptr_locs, loc, INSERT) = loc;\n-}\n-\n-/* Return the position associated with pointer PTR.  Return null if no\n-   position was set.  */\n-\n-static const struct ptr_loc *\n-get_rtx_ptr_loc (const void *ptr)\n-{\n-  return (const struct ptr_loc *) htab_find (ptr_locs, &ptr);\n-}\n-\n-/* Associate NEW_PTR with the same file position as OLD_PTR.  */\n-\n-void\n-copy_rtx_ptr_loc (const void *new_ptr, const void *old_ptr)\n-{\n-  const struct ptr_loc *loc = get_rtx_ptr_loc (old_ptr);\n-  if (loc != 0)\n-    set_rtx_ptr_loc (new_ptr, loc->filename, loc->lineno);\n-}\n-\n-/* If PTR is associated with a known file position, print a #line\n-   directive for it.  */\n-\n-void\n-print_rtx_ptr_loc (const void *ptr)\n-{\n-  const struct ptr_loc *loc = get_rtx_ptr_loc (ptr);\n-  if (loc != 0)\n-    printf (\"#line %d \\\"%s\\\"\\n\", loc->lineno, loc->filename);\n-}\n-\n-/* Return a condition that satisfies both COND1 and COND2.  Either string\n-   may be null or empty.  */\n-\n-const char *\n-join_c_conditions (const char *cond1, const char *cond2)\n-{\n-  char *result;\n-  const void **entry;\n-\n-  if (cond1 == 0 || cond1[0] == 0)\n-    return cond2;\n-\n-  if (cond2 == 0 || cond2[0] == 0)\n-    return cond1;\n-\n-  if (strcmp (cond1, cond2) == 0)\n-    return cond1;\n-\n-  result = concat (\"(\", cond1, \") && (\", cond2, \")\", NULL);\n-  obstack_ptr_grow (&joined_conditions_obstack, result);\n-  obstack_ptr_grow (&joined_conditions_obstack, cond1);\n-  obstack_ptr_grow (&joined_conditions_obstack, cond2);\n-  entry = XOBFINISH (&joined_conditions_obstack, const void **);\n-  *htab_find_slot (joined_conditions, entry, INSERT) = entry;\n-  return result;\n-}\n-\n-/* Print condition COND, wrapped in brackets.  If COND was created by\n-   join_c_conditions, recursively invoke this function for the original\n-   conditions and join the result with \"&&\".  Otherwise print a #line\n-   directive for COND if its original file position is known.  */\n-\n-void\n-print_c_condition (const char *cond)\n-{\n-  const char **halves = (const char **) htab_find (joined_conditions, &cond);\n-  if (halves != 0)\n-    {\n-      printf (\"(\");\n-      print_c_condition (halves[1]);\n-      printf (\" && \");\n-      print_c_condition (halves[2]);\n-      printf (\")\");\n-    }\n-  else\n-    {\n-      putc ('\\n', stdout);\n-      print_rtx_ptr_loc (cond);\n-      printf (\"(%s)\", cond);\n-    }\n-}\n-\n-/* Read chars from INFILE until a non-whitespace char\n-   and return that.  Comments, both Lisp style and C style,\n-   are treated as whitespace.\n-   Tools such as genflags use this function.  */\n-\n-int\n-read_skip_spaces (FILE *infile)\n-{\n-  int c;\n-\n-  while (1)\n-    {\n-      c = getc (infile);\n-      switch (c)\n-\t{\n-\tcase '\\n':\n-\t  read_rtx_lineno++;\n-\t  break;\n-\n-\tcase ' ': case '\\t': case '\\f': case '\\r':\n-\t  break;\n-\n-\tcase ';':\n-\t  do\n-\t    c = getc (infile);\n-\t  while (c != '\\n' && c != EOF);\n-\t  read_rtx_lineno++;\n-\t  break;\n-\n-\tcase '/':\n-\t  {\n-\t    int prevc;\n-\t    c = getc (infile);\n-\t    if (c != '*')\n-\t      fatal_expected_char (infile, '*', c);\n-\n-\t    prevc = 0;\n-\t    while ((c = getc (infile)) && c != EOF)\n-\t      {\n-\t\tif (c == '\\n')\n-\t\t   read_rtx_lineno++;\n-\t        else if (prevc == '*' && c == '/')\n-\t\t  break;\n-\t        prevc = c;\n-\t      }\n-\t  }\n-\t  break;\n-\n-\tdefault:\n-\t  return c;\n-\t}\n-    }\n-}\n-\n /* Read an rtx code name into the buffer STR[].\n    It is terminated by any of the punctuation chars of rtx printed syntax.  */\n \n@@ -929,165 +670,6 @@ read_name (char *str, FILE *infile)\n \tstrcpy (str, p);\n     }\n }\n-\n-/* Subroutine of the string readers.  Handles backslash escapes.\n-   Caller has read the backslash, but not placed it into the obstack.  */\n-static void\n-read_escape (FILE *infile)\n-{\n-  int c = getc (infile);\n-\n-  switch (c)\n-    {\n-      /* Backslash-newline is replaced by nothing, as in C.  */\n-    case '\\n':\n-      read_rtx_lineno++;\n-      return;\n-\n-      /* \\\" \\' \\\\ are replaced by the second character.  */\n-    case '\\\\':\n-    case '\"':\n-    case '\\'':\n-      break;\n-\n-      /* Standard C string escapes:\n-\t \\a \\b \\f \\n \\r \\t \\v\n-\t \\[0-7] \\x\n-\t all are passed through to the output string unmolested.\n-\t In normal use these wind up in a string constant processed\n-\t by the C compiler, which will translate them appropriately.\n-\t We do not bother checking that \\[0-7] are followed by up to\n-\t two octal digits, or that \\x is followed by N hex digits.\n-\t \\? \\u \\U are left out because they are not in traditional C.  */\n-    case 'a': case 'b': case 'f': case 'n': case 'r': case 't': case 'v':\n-    case '0': case '1': case '2': case '3': case '4': case '5': case '6':\n-    case '7': case 'x':\n-      obstack_1grow (&string_obstack, '\\\\');\n-      break;\n-\n-      /* \\; makes stuff for a C string constant containing\n-\t newline and tab.  */\n-    case ';':\n-      obstack_grow (&string_obstack, \"\\\\n\\\\t\", 4);\n-      return;\n-\n-      /* pass anything else through, but issue a warning.  */\n-    default:\n-      fprintf (stderr, \"%s:%d: warning: unrecognized escape \\\\%c\\n\",\n-\t       read_rtx_filename, read_rtx_lineno, c);\n-      obstack_1grow (&string_obstack, '\\\\');\n-      break;\n-    }\n-\n-  obstack_1grow (&string_obstack, c);\n-}\n-\n-\n-/* Read a double-quoted string onto the obstack.  Caller has scanned\n-   the leading quote.  */\n-static char *\n-read_quoted_string (FILE *infile)\n-{\n-  int c;\n-\n-  while (1)\n-    {\n-      c = getc (infile); /* Read the string  */\n-      if (c == '\\n')\n-\tread_rtx_lineno++;\n-      else if (c == '\\\\')\n-\t{\n-\t  read_escape (infile);\n-\t  continue;\n-\t}\n-      else if (c == '\"' || c == EOF)\n-\tbreak;\n-\n-      obstack_1grow (&string_obstack, c);\n-    }\n-\n-  obstack_1grow (&string_obstack, 0);\n-  return XOBFINISH (&string_obstack, char *);\n-}\n-\n-/* Read a braced string (a la Tcl) onto the string obstack.  Caller\n-   has scanned the leading brace.  Note that unlike quoted strings,\n-   the outermost braces _are_ included in the string constant.  */\n-static char *\n-read_braced_string (FILE *infile)\n-{\n-  int c;\n-  int brace_depth = 1;  /* caller-processed */\n-  unsigned long starting_read_rtx_lineno = read_rtx_lineno;\n-\n-  obstack_1grow (&string_obstack, '{');\n-  while (brace_depth)\n-    {\n-      c = getc (infile); /* Read the string  */\n-\n-      if (c == '\\n')\n-\tread_rtx_lineno++;\n-      else if (c == '{')\n-\tbrace_depth++;\n-      else if (c == '}')\n-\tbrace_depth--;\n-      else if (c == '\\\\')\n-\t{\n-\t  read_escape (infile);\n-\t  continue;\n-\t}\n-      else if (c == EOF)\n-\tfatal_with_file_and_line\n-\t  (infile, \"missing closing } for opening brace on line %lu\",\n-\t   starting_read_rtx_lineno);\n-\n-      obstack_1grow (&string_obstack, c);\n-    }\n-\n-  obstack_1grow (&string_obstack, 0);\n-  return XOBFINISH (&string_obstack, char *);\n-}\n-\n-/* Read some kind of string constant.  This is the high-level routine\n-   used by read_rtx.  It handles surrounding parentheses, leading star,\n-   and dispatch to the appropriate string constant reader.  */\n-\n-static char *\n-read_string (FILE *infile, int star_if_braced)\n-{\n-  char *stringbuf;\n-  int saw_paren = 0;\n-  int c, old_lineno;\n-\n-  c = read_skip_spaces (infile);\n-  if (c == '(')\n-    {\n-      saw_paren = 1;\n-      c = read_skip_spaces (infile);\n-    }\n-\n-  old_lineno = read_rtx_lineno;\n-  if (c == '\"')\n-    stringbuf = read_quoted_string (infile);\n-  else if (c == '{')\n-    {\n-      if (star_if_braced)\n-\tobstack_1grow (&string_obstack, '*');\n-      stringbuf = read_braced_string (infile);\n-    }\n-  else\n-    fatal_with_file_and_line (infile, \"expected `\\\"' or `{', found `%c'\", c);\n-\n-  if (saw_paren)\n-    {\n-      c = read_skip_spaces (infile);\n-      if (c != ')')\n-\tfatal_expected_char (infile, ')', c);\n-    }\n-\n-  set_rtx_ptr_loc (stringbuf, read_rtx_filename, old_lineno);\n-  return stringbuf;\n-}\n \f\n /* Provide a version of a function to read a long long if the system does\n    not provide one.  */\n@@ -1401,14 +983,9 @@ read_rtx (FILE *infile, rtx *x, int *lineno)\n   /* Do one-time initialization.  */\n   if (queue_head == 0)\n     {\n+      init_md_reader ();\n       initialize_iterators ();\n-      obstack_init (&string_obstack);\n       queue_head = rtx_alloc (EXPR_LIST);\n-      ptr_locs = htab_create (161, leading_ptr_hash, leading_ptr_eq_p, 0);\n-      obstack_init (&ptr_loc_obstack);\n-      joined_conditions = htab_create (161, leading_ptr_hash,\n-\t\t\t\t       leading_ptr_eq_p, 0);\n-      obstack_init (&joined_conditions_obstack);\n     }\n \n   if (queue_next == 0)"}, {"sha": "be167e5e4b58a7232b254159a5f28111e7123ffb", "filename": "gcc/rtl.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1069247787d6d8c1093b3f9a8ab62c95d1a8501c/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1069247787d6d8c1093b3f9a8ab62c95d1a8501c/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=1069247787d6d8c1093b3f9a8ab62c95d1a8501c", "patch": "@@ -2361,14 +2361,7 @@ extern void traverse_md_constants (int (*) (void **, void *), void *);\n struct md_constant { char *name, *value; };\n \n /* In read-rtl.c */\n-extern int read_skip_spaces (FILE *);\n extern bool read_rtx (FILE *, rtx *, int *);\n-extern void copy_rtx_ptr_loc (const void *, const void *);\n-extern void print_rtx_ptr_loc (const void *);\n-extern const char *join_c_conditions (const char *, const char *);\n-extern void print_c_condition (const char *);\n-extern const char *read_rtx_filename;\n-extern int read_rtx_lineno;\n \n /* In alias.c */\n extern rtx canon_rtx (rtx);"}]}