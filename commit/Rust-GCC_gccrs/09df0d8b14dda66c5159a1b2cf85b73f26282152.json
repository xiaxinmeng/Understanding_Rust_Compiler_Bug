{"sha": "09df0d8b14dda66c5159a1b2cf85b73f26282152", "node_id": "C_kwDOANBUbNoAKDA5ZGYwZDhiMTRkZGE2NmM1MTU5YTFiMmNmODViNzNmMjYyODIxNTI", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-10-06T14:04:52Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-10-06T14:04:52Z"}, "message": "c++: remove optimize_specialization_lookup_p\n\nRoughly speaking, optimize_specialization_lookup_p returns true for a\nnon-template member function of a class template, e.g.\n\n  template<class T> struct A { int f(); };\n\nThe idea behind the optimization guarded by this predicate is that if\nwe want to look up the specialization A<T>::f [with T=int], then we can\njust do a name lookup for f in A<int> and avoid having to add a\nspec_entry for f in the decl_specializations table.\n\nBut the benefit of this optimization seems questionable because in\norder to do the name lookup we first need to look up A<T> [with T=int]\nin the type_specializations table, which is as expensive as the\ndecl_specializations lookup we're avoiding.  And according to some\nexperiments (using stdc++.h, range-v3 and libstdc++ tests) the compiler\nis slightly (<1%) _faster_ if we disable this optimization.\n\nAdditionally, this optimization means we won't record an explicit\nspecialization in decl_specializations for such a template either, which\nis an unfortunate inconsistency that apparently breaks the below modules\ntestcase.\n\nSo since this optimization doesn't improve performance, and complicates\nthe explicit specialization story which causes issues with modules, this\npatch proposes to remove it.\n\ngcc/cp/ChangeLog:\n\n\t* pt.cc (optimize_specialization_lookup_p): Remove.\n\t(retrieve_specialization): Assume the above returns false\n\tand simplify accordingly.\n\t(register_specialization): Likewise.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/modules/indirect-3_b.C: Expect that the entity\n\tfoo::TPL<0>::frob is tagged as a specialization instead\n\tof as a declaration.\n\t* g++.dg/modules/tpl-spec-8_a.H: New test.\n\t* g++.dg/modules/tpl-spec-8_b.C: New test.", "tree": {"sha": "9758930d46b0e4aae5170aaf5343e542f89f46c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9758930d46b0e4aae5170aaf5343e542f89f46c1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/09df0d8b14dda66c5159a1b2cf85b73f26282152", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09df0d8b14dda66c5159a1b2cf85b73f26282152", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09df0d8b14dda66c5159a1b2cf85b73f26282152", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09df0d8b14dda66c5159a1b2cf85b73f26282152/comments", "author": null, "committer": null, "parents": [{"sha": "3ec926d36fbf7cb3ff45759471139f3a71d1c4de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ec926d36fbf7cb3ff45759471139f3a71d1c4de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ec926d36fbf7cb3ff45759471139f3a71d1c4de"}], "stats": {"total": 177, "additions": 59, "deletions": 118}, "files": [{"sha": "5b9fc588a2127ed2ee4fd93b9d2848dc22b83b91", "filename": "gcc/cp/pt.cc", "status": "modified", "additions": 40, "deletions": 117, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09df0d8b14dda66c5159a1b2cf85b73f26282152/gcc%2Fcp%2Fpt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09df0d8b14dda66c5159a1b2cf85b73f26282152/gcc%2Fcp%2Fpt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.cc?ref=09df0d8b14dda66c5159a1b2cf85b73f26282152", "patch": "@@ -1170,39 +1170,6 @@ maybe_process_partial_specialization (tree type)\n   return type;\n }\n \n-/* Returns nonzero if we can optimize the retrieval of specializations\n-   for TMPL, a TEMPLATE_DECL.  In particular, for such a template, we\n-   do not use DECL_TEMPLATE_SPECIALIZATIONS at all.  */\n-\n-static inline bool\n-optimize_specialization_lookup_p (tree tmpl)\n-{\n-  return (DECL_FUNCTION_TEMPLATE_P (tmpl)\n-\t  && DECL_CLASS_SCOPE_P (tmpl)\n-\t  /* DECL_CLASS_SCOPE_P holds of T::f even if T is a template\n-\t     parameter.  */\n-\t  && CLASS_TYPE_P (DECL_CONTEXT (tmpl))\n-\t  /* The optimized lookup depends on the fact that the\n-\t     template arguments for the member function template apply\n-\t     purely to the containing class, which is not true if the\n-\t     containing class is an explicit or partial\n-\t     specialization.  */\n-\t  && !CLASSTYPE_TEMPLATE_SPECIALIZATION (DECL_CONTEXT (tmpl))\n-\t  && !DECL_MEMBER_TEMPLATE_P (tmpl)\n-\t  && !DECL_CONV_FN_P (tmpl)\n-\t  /* It is possible to have a template that is not a member\n-\t     template and is not a member of a template class:\n-\n-\t     template <typename T>\n-\t     struct S { friend A::f(); };\n-\n-\t     Here, the friend function is a template, but the context does\n-\t     not have template information.  The optimized lookup relies\n-\t     on having ARGS be the template arguments for both the class\n-\t     and the function template.  */\n-\t  && !DECL_UNIQUE_FRIEND_P (DECL_TEMPLATE_RESULT (tmpl)));\n-}\n-\n /* Make sure ARGS doesn't use any inappropriate typedefs; we should have\n    gone through coerce_template_parms by now.  */\n \n@@ -1276,54 +1243,21 @@ retrieve_specialization (tree tmpl, tree args, hashval_t hash)\n   if (lambda_fn_in_template_p (tmpl))\n     return NULL_TREE;\n \n-  if (optimize_specialization_lookup_p (tmpl))\n-    {\n-      /* The template arguments actually apply to the containing\n-\t class.  Find the class specialization with those\n-\t arguments.  */\n-      tree class_template = CLASSTYPE_TI_TEMPLATE (DECL_CONTEXT (tmpl));\n-      tree class_specialization\n-\t= retrieve_specialization (class_template, args, 0);\n-      if (!class_specialization)\n-\treturn NULL_TREE;\n+  spec_entry elt;\n+  elt.tmpl = tmpl;\n+  elt.args = args;\n+  elt.spec = NULL_TREE;\n \n-      /* Find the instance of TMPL.  */\n-      tree fns = get_class_binding (class_specialization, DECL_NAME (tmpl));\n-      for (ovl_iterator iter (fns); iter; ++iter)\n-\t{\n-\t  tree fn = *iter;\n-\t  if (tree ti = get_template_info (fn))\n-\t    if (TI_TEMPLATE (ti) == tmpl\n-\t\t/* using-declarations can bring in a different\n-\t\t   instantiation of tmpl as a member of a different\n-\t\t   instantiation of tmpl's class.  We don't want those\n-\t\t   here.  */\n-\t\t&& DECL_CONTEXT (fn) == class_specialization)\n-\t      return fn;\n-\t}\n-      return NULL_TREE;\n-    }\n+  spec_hash_table *specializations;\n+  if (DECL_CLASS_TEMPLATE_P (tmpl))\n+    specializations = type_specializations;\n   else\n-    {\n-      spec_entry *found;\n-      spec_entry elt;\n-      spec_hash_table *specializations;\n+    specializations = decl_specializations;\n \n-      elt.tmpl = tmpl;\n-      elt.args = args;\n-      elt.spec = NULL_TREE;\n-\n-      if (DECL_CLASS_TEMPLATE_P (tmpl))\n-\tspecializations = type_specializations;\n-      else\n-\tspecializations = decl_specializations;\n-\n-      if (hash == 0)\n-\thash = spec_hasher::hash (&elt);\n-      found = specializations->find_with_hash (&elt, hash);\n-      if (found)\n-\treturn found->spec;\n-    }\n+  if (hash == 0)\n+    hash = spec_hasher::hash (&elt);\n+  if (spec_entry *found = specializations->find_with_hash (&elt, hash))\n+    return found->spec;\n \n   return NULL_TREE;\n }\n@@ -1567,8 +1501,6 @@ register_specialization (tree spec, tree tmpl, tree args, bool is_friend,\n \t\t\t hashval_t hash)\n {\n   tree fn;\n-  spec_entry **slot = NULL;\n-  spec_entry elt;\n \n   gcc_assert ((TREE_CODE (tmpl) == TEMPLATE_DECL && DECL_P (spec))\n \t      || (TREE_CODE (tmpl) == FIELD_DECL\n@@ -1589,25 +1521,19 @@ register_specialization (tree spec, tree tmpl, tree args, bool is_friend,\n        instantiation unless and until it is actually needed.  */\n     return spec;\n \n-  if (optimize_specialization_lookup_p (tmpl))\n-    /* We don't put these specializations in the hash table, but we might\n-       want to give an error about a mismatch.  */\n-    fn = retrieve_specialization (tmpl, args, 0);\n-  else\n-    {\n-      elt.tmpl = tmpl;\n-      elt.args = args;\n-      elt.spec = spec;\n+  spec_entry elt;\n+  elt.tmpl = tmpl;\n+  elt.args = args;\n+  elt.spec = spec;\n \n-      if (hash == 0)\n-\thash = spec_hasher::hash (&elt);\n+  if (hash == 0)\n+    hash = spec_hasher::hash (&elt);\n \n-      slot = decl_specializations->find_slot_with_hash (&elt, hash, INSERT);\n-      if (*slot)\n-\tfn = (*slot)->spec;\n-      else\n-\tfn = NULL_TREE;\n-    }\n+  spec_entry **slot = decl_specializations->find_slot_with_hash (&elt, hash, INSERT);\n+  if (*slot)\n+    fn = (*slot)->spec;\n+  else\n+    fn = NULL_TREE;\n \n   /* We can sometimes try to re-register a specialization that we've\n      already got.  In particular, regenerate_decl_from_template calls\n@@ -1704,26 +1630,23 @@ register_specialization (tree spec, tree tmpl, tree args, bool is_friend,\n       && !check_specialization_namespace (tmpl))\n     DECL_CONTEXT (spec) = DECL_CONTEXT (tmpl);\n \n-  if (slot != NULL /* !optimize_specialization_lookup_p (tmpl) */)\n-    {\n-      spec_entry *entry = ggc_alloc<spec_entry> ();\n-      gcc_assert (tmpl && args && spec);\n-      *entry = elt;\n-      *slot = entry;\n-      if ((TREE_CODE (spec) == FUNCTION_DECL && DECL_NAMESPACE_SCOPE_P (spec)\n-\t   && PRIMARY_TEMPLATE_P (tmpl)\n-\t   && DECL_SAVED_TREE (DECL_TEMPLATE_RESULT (tmpl)) == NULL_TREE)\n-\t  || variable_template_p (tmpl))\n-\t/* If TMPL is a forward declaration of a template function, keep a list\n-\t   of all specializations in case we need to reassign them to a friend\n-\t   template later in tsubst_friend_function.\n-\n-\t   Also keep a list of all variable template instantiations so that\n-\t   process_partial_specialization can check whether a later partial\n-\t   specialization would have used it.  */\n-\tDECL_TEMPLATE_INSTANTIATIONS (tmpl)\n-\t  = tree_cons (args, spec, DECL_TEMPLATE_INSTANTIATIONS (tmpl));\n-    }\n+  spec_entry *entry = ggc_alloc<spec_entry> ();\n+  gcc_assert (tmpl && args && spec);\n+  *entry = elt;\n+  *slot = entry;\n+  if ((TREE_CODE (spec) == FUNCTION_DECL && DECL_NAMESPACE_SCOPE_P (spec)\n+       && PRIMARY_TEMPLATE_P (tmpl)\n+       && DECL_SAVED_TREE (DECL_TEMPLATE_RESULT (tmpl)) == NULL_TREE)\n+      || variable_template_p (tmpl))\n+    /* If TMPL is a forward declaration of a template function, keep a list\n+       of all specializations in case we need to reassign them to a friend\n+       template later in tsubst_friend_function.\n+\n+       Also keep a list of all variable template instantiations so that\n+       process_partial_specialization can check whether a later partial\n+       specialization would have used it.  */\n+    DECL_TEMPLATE_INSTANTIATIONS (tmpl)\n+      = tree_cons (args, spec, DECL_TEMPLATE_INSTANTIATIONS (tmpl));\n \n   return spec;\n }"}, {"sha": "038b01ecab7e0a58967888868edaf1d827e3e7a7", "filename": "gcc/testsuite/g++.dg/modules/indirect-3_b.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09df0d8b14dda66c5159a1b2cf85b73f26282152/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Findirect-3_b.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09df0d8b14dda66c5159a1b2cf85b73f26282152/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Findirect-3_b.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Findirect-3_b.C?ref=09df0d8b14dda66c5159a1b2cf85b73f26282152", "patch": "@@ -23,7 +23,7 @@ namespace bar\n // { dg-final { scan-lang-dump {Lazily binding '::foo@foo:.::TPL'@'foo' section} module } }\n // { dg-final { scan-lang-dump {Wrote import:-[0-9]* template_decl:'::foo@foo:.::template TPL@foo:.'@foo} module } }\n \n-// { dg-final { scan-lang-dump {Cluster members:\\n  \\[0\\]=specialization definition '::foo@foo:.::TPL<0x0>'\\n  \\[1\\]=specialization declaration '::foo@foo:.::TPL<0x0>::TPL<0x0>'\\n(  \\[.\\]=[^\\n]* '\\n)*  \\[.\\]=decl definition '::foo@foo:.::TPL<0x0>::frob<0x0>'\\n} module } }\n+// { dg-final { scan-lang-dump {Cluster members:\\n  \\[0\\]=specialization definition '::foo@foo:.::TPL<0x0>'\\n  \\[1\\]=specialization definition '::foo@foo:.::TPL<0x0>::frob<0x0>'\\n  \\[2\\]=specialization declaration '::foo@foo:.::TPL<0x0>::TPL<0x0>'} module } }\n \n // { dg-final { scan-lang-dump {Cluster members:\\n  \\[0\\]=specialization definition '::foo@foo:.::X@foo:.::frob<0x0>'} module } }\n // { dg-final { scan-lang-dump {Writing:-[0-9]*'s type spec merge key \\(specialization\\) type_decl:'::foo@foo:.::TPL<0x0>'} module } }"}, {"sha": "5309130dced675efd3a6f54bceabdb0acd33ad18", "filename": "gcc/testsuite/g++.dg/modules/tpl-spec-8_a.H", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09df0d8b14dda66c5159a1b2cf85b73f26282152/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Ftpl-spec-8_a.H", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09df0d8b14dda66c5159a1b2cf85b73f26282152/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Ftpl-spec-8_a.H", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Ftpl-spec-8_a.H?ref=09df0d8b14dda66c5159a1b2cf85b73f26282152", "patch": "@@ -0,0 +1,10 @@\n+// { dg-additional-options -fmodule-header }\n+// { dg-module-cmi {} }\n+\n+template<class T>\n+struct A {\n+  static void f() { T::nonexistent; }\n+};\n+\n+template<>\n+inline void A<int>::f() { }"}, {"sha": "f23eb370370ba8f7feb44344481971ab0beae2d9", "filename": "gcc/testsuite/g++.dg/modules/tpl-spec-8_b.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09df0d8b14dda66c5159a1b2cf85b73f26282152/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Ftpl-spec-8_b.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09df0d8b14dda66c5159a1b2cf85b73f26282152/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Ftpl-spec-8_b.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Ftpl-spec-8_b.C?ref=09df0d8b14dda66c5159a1b2cf85b73f26282152", "patch": "@@ -0,0 +1,8 @@\n+// { dg-additional-options -fmodules-ts }\n+// { dg-do link }\n+\n+import \"tpl-spec-8_a.H\";\n+\n+int main() {\n+  A<int>::f();\n+}"}]}