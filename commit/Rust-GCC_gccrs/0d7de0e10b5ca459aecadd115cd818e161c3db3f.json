{"sha": "0d7de0e10b5ca459aecadd115cd818e161c3db3f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGQ3ZGUwZTEwYjVjYTQ1OWFlY2FkZDExNWNkODE4ZTE2MWMzZGIzZg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2012-03-09T09:28:02Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2012-03-09T09:28:02Z"}, "message": "ada-tree.h (TYPE_VAX_FLOATING_POINT_P): Move around.\n\n\t* gcc-interface/ada-tree.h (TYPE_VAX_FLOATING_POINT_P): Move around.\n\t(TYPE_UNCONSTRAINED_ARRAY): Adjust comment.\n\t* gcc-interface/trans.c (Attribute_to_gnu) <Attr_Pool_Address>: Tidy\n\tup.  Add comment and use canonical predicate for thin pointers.\n\t(gnat_to_gnu) <N_Free_Statement>: Tidy up and reorder.  Add comment\n\tand use canonical predicate for thin pointers.\n\t* gcc-interface/utils.c (convert_to_fat_pointer): Remove superfluous\n\t'else' and use standard name.\n\t(convert_to_thin_pointer): Delete.\n\t(convert) <POINTER_TYPE>: Do the difference in sizetype directly and\n\tchange obsolete idioms.  Do not call above function.\n\t(unchecked_convert): Fix formatting.\n\t* gcc-interface/utils2.c (build_unary_op) <INDIRECT_REF>: In the thin\n\tpointer case, use byte_position to get the field position.\n\nFrom-SVN: r185132", "tree": {"sha": "118dcac148376d9060365be8e9e9370aa8d37894", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/118dcac148376d9060365be8e9e9370aa8d37894"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0d7de0e10b5ca459aecadd115cd818e161c3db3f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d7de0e10b5ca459aecadd115cd818e161c3db3f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d7de0e10b5ca459aecadd115cd818e161c3db3f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d7de0e10b5ca459aecadd115cd818e161c3db3f/comments", "author": null, "committer": null, "parents": [{"sha": "210ac0b75b991788e1de7989fe7ea6d86bf41ab3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/210ac0b75b991788e1de7989fe7ea6d86bf41ab3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/210ac0b75b991788e1de7989fe7ea6d86bf41ab3"}], "stats": {"total": 171, "additions": 78, "deletions": 93}, "files": [{"sha": "826383eb5bbe68b5d4edb26e0db5562368ad003a", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d7de0e10b5ca459aecadd115cd818e161c3db3f/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d7de0e10b5ca459aecadd115cd818e161c3db3f/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=0d7de0e10b5ca459aecadd115cd818e161c3db3f", "patch": "@@ -1,3 +1,20 @@\n+2012-03-09  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/ada-tree.h (TYPE_VAX_FLOATING_POINT_P): Move around.\n+\t(TYPE_UNCONSTRAINED_ARRAY): Adjust comment.\n+\t* gcc-interface/trans.c (Attribute_to_gnu) <Attr_Pool_Address>: Tidy\n+\tup.  Add comment and use canonical predicate for thin pointers.\n+\t(gnat_to_gnu) <N_Free_Statement>: Tidy up and reorder.  Add comment\n+\tand use canonical predicate for thin pointers.\n+\t* gcc-interface/utils.c (convert_to_fat_pointer): Remove superfluous\n+\t'else' and use standard name.\n+\t(convert_to_thin_pointer): Delete.\n+\t(convert) <POINTER_TYPE>: Do the difference in sizetype directly and\n+\tchange obsolete idioms.  Do not call above function.\n+\t(unchecked_convert): Fix formatting.\n+\t* gcc-interface/utils2.c (build_unary_op) <INDIRECT_REF>: In the thin\n+\tpointer case, use byte_position to get the field position.\n+\n 2012-03-07  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/decl.c (gnat_to_gnu_entity): Do not set flags on the"}, {"sha": "ec00cc4775f796098bfddc8e477baeee3e3f51af", "filename": "gcc/ada/gcc-interface/ada-tree.h", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d7de0e10b5ca459aecadd115cd818e161c3db3f/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d7de0e10b5ca459aecadd115cd818e161c3db3f/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fada-tree.h?ref=0d7de0e10b5ca459aecadd115cd818e161c3db3f", "patch": "@@ -124,17 +124,17 @@ do {\t\t\t\t\t\t\t \\\n     || TREE_CODE (NODE) == ENUMERAL_TYPE)\t    \\\n    && TYPE_BY_REFERENCE_P (NODE))\n \n+/* For INTEGER_TYPE, nonzero if this really represents a VAX\n+   floating-point type.  */\n+#define TYPE_VAX_FLOATING_POINT_P(NODE) \\\n+  TYPE_LANG_FLAG_3 (INTEGER_TYPE_CHECK (NODE))\n+\n /* For RECORD_TYPE, UNION_TYPE, and QUAL_UNION_TYPE, nonzero if this is the\n    type for an object whose type includes its template in addition to\n    its value (only true for RECORD_TYPE).  */\n #define TYPE_CONTAINS_TEMPLATE_P(NODE) \\\n   TYPE_LANG_FLAG_3 (RECORD_OR_UNION_CHECK (NODE))\n \n-/* For INTEGER_TYPE, nonzero if this really represents a VAX\n-   floating-point type.  */\n-#define TYPE_VAX_FLOATING_POINT_P(NODE) \\\n-  TYPE_LANG_FLAG_3 (INTEGER_TYPE_CHECK (NODE))\n-\n /* True if NODE is a thin pointer.  */\n #define TYPE_IS_THIN_POINTER_P(NODE)\t\t\t\\\n   (POINTER_TYPE_P (NODE)\t\t\t\t\\\n@@ -328,8 +328,10 @@ do {\t\t\t\t\t\t   \\\n   SET_TYPE_LANG_SPECIFIC (POINTER_TYPE_CHECK (NODE), X)\n \n /* For a RECORD_TYPE that is a fat pointer, this is the type for the\n-   unconstrained object.  Likewise for a RECORD_TYPE that is pointed\n-   to by a thin pointer.  */\n+   unconstrained array.  Likewise for a RECORD_TYPE that is pointed\n+   to by a thin pointer, if it is made for the unconstrained array\n+   type itself; the field is NULL_TREE if the RECORD_TYPE is made\n+   for a constrained subtype of the array type.  */\n #define TYPE_UNCONSTRAINED_ARRAY(NODE) \\\n   GET_TYPE_LANG_SPECIFIC (RECORD_TYPE_CHECK (NODE))\n #define SET_TYPE_UNCONSTRAINED_ARRAY(NODE, X) \\"}, {"sha": "cd6626fe450517cb509970008f2ab56038573399", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 36, "deletions": 40, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d7de0e10b5ca459aecadd115cd818e161c3db3f/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d7de0e10b5ca459aecadd115cd818e161c3db3f/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=0d7de0e10b5ca459aecadd115cd818e161c3db3f", "patch": "@@ -1415,14 +1415,14 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \n     case Attr_Pool_Address:\n       {\n-\ttree gnu_obj_type;\n \ttree gnu_ptr = gnu_prefix;\n+\ttree gnu_obj_type;\n \n \tgnu_result_type = get_unpadded_type (Etype (gnat_node));\n \n-\t/* If this is an unconstrained array, we know the object has been\n-\t   allocated with the template in front of the object.  So compute\n-\t   the template address.  */\n+\t/* If this is fat pointer, the object must have been allocated with the\n+\t   template in front of the array.  So compute the template address; do\n+\t   it by converting to a thin pointer.  */\n \tif (TYPE_IS_FAT_POINTER_P (TREE_TYPE (gnu_ptr)))\n \t  gnu_ptr\n \t    = convert (build_pointer_type\n@@ -1431,16 +1431,15 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \t\t       gnu_ptr);\n \n \tgnu_obj_type = TREE_TYPE (TREE_TYPE (gnu_ptr));\n-\tif (TREE_CODE (gnu_obj_type) == RECORD_TYPE\n-\t    && TYPE_CONTAINS_TEMPLATE_P (gnu_obj_type))\n-\t  {\n-\t    tree gnu_char_ptr_type\n-\t      = build_pointer_type (unsigned_char_type_node);\n-\t    tree gnu_pos = byte_position (TYPE_FIELDS (gnu_obj_type));\n-\t    gnu_ptr = convert (gnu_char_ptr_type, gnu_ptr);\n-\t    gnu_ptr = build_binary_op (POINTER_PLUS_EXPR, gnu_char_ptr_type,\n-\t\t\t\t       gnu_ptr, gnu_pos);\n-\t  }\n+\n+\t/* If this is a thin pointer, the object must have been allocated with\n+\t   the template in front of the array.  So compute the template address\n+\t   and return it.  */\n+\tif (TYPE_IS_THIN_POINTER_P (TREE_TYPE (gnu_ptr)))\n+\t  gnu_ptr\n+\t    = build_binary_op (POINTER_PLUS_EXPR, TREE_TYPE (gnu_ptr),\n+\t\t\t       gnu_ptr,\n+\t\t\t       byte_position (TYPE_FIELDS (gnu_obj_type)));\n \n \tgnu_result = convert (gnu_result_type, gnu_ptr);\n       }\n@@ -6593,23 +6592,20 @@ gnat_to_gnu (Node_Id gnat_node)\n \t{\n \t  tree gnu_ptr = gnat_to_gnu (Expression (gnat_node));\n \t  tree gnu_ptr_type = TREE_TYPE (gnu_ptr);\n-\t  tree gnu_obj_type;\n-\t  tree gnu_actual_obj_type = 0;\n-\t  tree gnu_obj_size;\n-\n-\t  /* If this is a thin pointer, we must dereference it to create\n-\t     a fat pointer, then go back below to a thin pointer.  The\n-\t     reason for this is that we need a fat pointer someplace in\n-\t     order to properly compute the size.  */\n+\t  tree gnu_obj_type, gnu_actual_obj_type;\n+\n+\t  /* If this is a thin pointer, we must first dereference it to create\n+\t     a fat pointer, then go back below to a thin pointer.  The reason\n+\t     for this is that we need to have a fat pointer someplace in order\n+\t     to properly compute the size.  */\n \t  if (TYPE_IS_THIN_POINTER_P (TREE_TYPE (gnu_ptr)))\n \t    gnu_ptr = build_unary_op (ADDR_EXPR, NULL_TREE,\n \t\t\t\t      build_unary_op (INDIRECT_REF, NULL_TREE,\n \t\t\t\t\t\t      gnu_ptr));\n \n-\t  /* If this is an unconstrained array, we know the object must\n-\t     have been allocated with the template in front of the object.\n-\t     So pass the template address, but get the total size.  Do this\n-\t     by converting to a thin pointer.  */\n+\t  /* If this is a fat pointer, the object must have been allocated with\n+\t     the template in front of the array.  So pass the template address,\n+\t     and get the total size; do it by converting to a thin pointer.  */\n \t  if (TYPE_IS_FAT_POINTER_P (TREE_TYPE (gnu_ptr)))\n \t    gnu_ptr\n \t      = convert (build_pointer_type\n@@ -6619,6 +6615,17 @@ gnat_to_gnu (Node_Id gnat_node)\n \n \t  gnu_obj_type = TREE_TYPE (TREE_TYPE (gnu_ptr));\n \n+\t  /* If this is a thin pointer, the object must have been allocated with\n+\t     the template in front of the array.  So pass the template address,\n+\t     and get the total size.  */\n+\t  if (TYPE_IS_THIN_POINTER_P (TREE_TYPE (gnu_ptr)))\n+\t    gnu_ptr\n+\t      = build_binary_op (POINTER_PLUS_EXPR, TREE_TYPE (gnu_ptr),\n+\t\t\t\t gnu_ptr,\n+\t\t\t\t byte_position (TYPE_FIELDS (gnu_obj_type)));\n+\n+\t  /* If we have a special dynamic constrained subtype on the node, use\n+\t     it to compute the size; otherwise, use the designated subtype.  */\n \t  if (Present (Actual_Designated_Subtype (gnat_node)))\n \t    {\n \t      gnu_actual_obj_type\n@@ -6634,21 +6641,10 @@ gnat_to_gnu (Node_Id gnat_node)\n \t  else\n \t    gnu_actual_obj_type = gnu_obj_type;\n \n-\t  gnu_obj_size = TYPE_SIZE_UNIT (gnu_actual_obj_type);\n-\n-\t  if (TREE_CODE (gnu_obj_type) == RECORD_TYPE\n-\t      && TYPE_CONTAINS_TEMPLATE_P (gnu_obj_type))\n-\t    {\n-\t      tree gnu_char_ptr_type\n-\t\t= build_pointer_type (unsigned_char_type_node);\n-\t      tree gnu_pos = byte_position (TYPE_FIELDS (gnu_obj_type));\n-\t      gnu_ptr = convert (gnu_char_ptr_type, gnu_ptr);\n-\t      gnu_ptr = build_binary_op (POINTER_PLUS_EXPR, gnu_char_ptr_type,\n-\t\t\t\t\t gnu_ptr, gnu_pos);\n-\t    }\n-\n \t  gnu_result\n-\t      = build_call_alloc_dealloc (gnu_ptr, gnu_obj_size, gnu_obj_type,\n+\t      = build_call_alloc_dealloc (gnu_ptr,\n+\t\t\t\t\t  TYPE_SIZE_UNIT (gnu_actual_obj_type),\n+\t\t\t\t\t  gnu_obj_type,\n \t\t\t\t\t  Procedure_To_Call (gnat_node),\n \t\t\t\t\t  Storage_Pool (gnat_node),\n \t\t\t\t\t  gnat_node);"}, {"sha": "4f8ab205d0b0432ab3ce2306d0e6bd57933b380b", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 15, "deletions": 45, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d7de0e10b5ca459aecadd115cd818e161c3db3f/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d7de0e10b5ca459aecadd115cd818e161c3db3f/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=0d7de0e10b5ca459aecadd115cd818e161c3db3f", "patch": "@@ -220,7 +220,6 @@ static tree compute_related_constant (tree, tree);\n static tree split_plus (tree, tree *);\n static tree float_type_for_precision (int, enum machine_mode);\n static tree convert_to_fat_pointer (tree, tree);\n-static tree convert_to_thin_pointer (tree, tree);\n static bool potential_alignment_gap (tree, tree, tree);\n static void process_attributes (tree, struct attrib *);\n \f\n@@ -3608,21 +3607,21 @@ convert_to_fat_pointer (tree type, tree expr)\n       return t;\n     }\n \n-  /* If EXPR is a thin pointer, make template and data from the record..  */\n-  else if (TYPE_IS_THIN_POINTER_P (etype))\n+  /* If EXPR is a thin pointer, make template and data from the record.  */\n+  if (TYPE_IS_THIN_POINTER_P (etype))\n     {\n-      tree fields = TYPE_FIELDS (TREE_TYPE (etype));\n+      tree field = TYPE_FIELDS (TREE_TYPE (etype));\n \n       expr = gnat_protect_expr (expr);\n       if (TREE_CODE (expr) == ADDR_EXPR)\n \texpr = TREE_OPERAND (expr, 0);\n       else\n \texpr = build1 (INDIRECT_REF, TREE_TYPE (etype), expr);\n \n-      template_tree = build_component_ref (expr, NULL_TREE, fields, false);\n+      template_tree = build_component_ref (expr, NULL_TREE, field, false);\n       expr = build_unary_op (ADDR_EXPR, NULL_TREE,\n \t\t\t     build_component_ref (expr, NULL_TREE,\n-\t\t\t\t\t\t  DECL_CHAIN (fields), false));\n+\t\t\t\t\t\t  DECL_CHAIN (field), false));\n     }\n \n   /* Otherwise, build the constructor for the template.  */\n@@ -3649,27 +3648,6 @@ convert_to_fat_pointer (tree type, tree expr)\n   return gnat_build_constructor (type, v);\n }\n \f\n-/* Convert to a thin pointer type, TYPE.  The only thing we know how to convert\n-   is something that is a fat pointer, so convert to it first if it EXPR\n-   is not already a fat pointer.  */\n-\n-static tree\n-convert_to_thin_pointer (tree type, tree expr)\n-{\n-  if (!TYPE_IS_FAT_POINTER_P (TREE_TYPE (expr)))\n-    expr\n-      = convert_to_fat_pointer\n-\t(TREE_TYPE (TYPE_UNCONSTRAINED_ARRAY (TREE_TYPE (type))), expr);\n-\n-  /* We get the pointer to the data and use a NOP_EXPR to make it the\n-     proper GCC type.  */\n-  expr = build_component_ref (expr, NULL_TREE, TYPE_FIELDS (TREE_TYPE (expr)),\n-\t\t\t      false);\n-  expr = build1 (NOP_EXPR, type, expr);\n-\n-  return expr;\n-}\n-\f\n /* Create an expression whose value is that of EXPR,\n    converted to type TYPE.  The TREE_TYPE of the value\n    is always TYPE.  This function implements all reasonable\n@@ -4124,33 +4102,25 @@ convert (tree type, tree expr)\n \n     case POINTER_TYPE:\n     case REFERENCE_TYPE:\n-      /* If converting between two pointers to records denoting\n-\t both a template and type, adjust if needed to account\n-\t for any differing offsets, since one might be negative.  */\n+      /* If converting between two thin pointers, adjust if needed to account\n+\t for any differing offsets, since one of them might be negative.  */\n       if (TYPE_IS_THIN_POINTER_P (etype) && TYPE_IS_THIN_POINTER_P (type))\n \t{\n-\t  tree bit_diff\n-\t    = size_diffop (bit_position (TYPE_FIELDS (TREE_TYPE (etype))),\n-\t\t\t   bit_position (TYPE_FIELDS (TREE_TYPE (type))));\n \t  tree byte_diff\n-\t    = size_binop (CEIL_DIV_EXPR, bit_diff, sbitsize_unit_node);\n+\t    = size_diffop (byte_position (TYPE_FIELDS (TREE_TYPE (etype))),\n+\t\t\t   byte_position (TYPE_FIELDS (TREE_TYPE (type))));\n+\n \t  expr = build1 (NOP_EXPR, type, expr);\n-\t  TREE_CONSTANT (expr) = TREE_CONSTANT (TREE_OPERAND (expr, 0));\n \t  if (integer_zerop (byte_diff))\n \t    return expr;\n \n \t  return build_binary_op (POINTER_PLUS_EXPR, type, expr,\n-\t\t\t\t  fold (convert (sizetype, byte_diff)));\n+\t\t\t\t  fold_convert (sizetype, byte_diff));\n \t}\n \n-      /* If converting to a thin pointer, handle specially.  */\n-      if (TYPE_IS_THIN_POINTER_P (type)\n-\t  && TYPE_UNCONSTRAINED_ARRAY (TREE_TYPE (type)))\n-\treturn convert_to_thin_pointer (type, expr);\n-\n-      /* If converting fat pointer to normal pointer, get the pointer to the\n-\t array and then convert it.  */\n-      else if (TYPE_IS_FAT_POINTER_P (etype))\n+      /* If converting fat pointer to normal or thin pointer, get the pointer\n+\t to the array and then convert it.  */\n+      if (TYPE_IS_FAT_POINTER_P (etype))\n \texpr\n \t  = build_component_ref (expr, NULL_TREE, TYPE_FIELDS (etype), false);\n \n@@ -4521,7 +4491,7 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)\n      Likewise for a conversion to an unconstrained array.  */\n   if ((((INTEGRAL_TYPE_P (type)\n \t && !(code == INTEGER_TYPE && TYPE_VAX_FLOATING_POINT_P (type)))\n-\t|| (POINTER_TYPE_P (type) && ! TYPE_IS_THIN_POINTER_P (type))\n+\t|| (POINTER_TYPE_P (type) && !TYPE_IS_THIN_POINTER_P (type))\n \t|| (code == RECORD_TYPE && TYPE_JUSTIFIED_MODULAR_P (type)))\n        && ((INTEGRAL_TYPE_P (etype)\n \t    && !(ecode == INTEGER_TYPE && TYPE_VAX_FLOATING_POINT_P (etype)))"}, {"sha": "79c5a1face3b8118e1478296f1f1b6bde6483d52", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d7de0e10b5ca459aecadd115cd818e161c3db3f/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d7de0e10b5ca459aecadd115cd818e161c3db3f/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=0d7de0e10b5ca459aecadd115cd818e161c3db3f", "patch": "@@ -1398,7 +1398,7 @@ build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n \t    if (TREE_CODE (operand) == POINTER_PLUS_EXPR\n \t\t&& integer_zerop\n \t\t   (size_binop (PLUS_EXPR, TREE_OPERAND (operand, 1),\n-\t\t\t\tDECL_FIELD_OFFSET (TYPE_FIELDS (rec_type))))\n+\t\t\t\tbyte_position (TYPE_FIELDS (rec_type))))\n \t\t&& TREE_CODE (TREE_OPERAND (operand, 0)) == NOP_EXPR)\n \t      {\n \t\toperand = TREE_OPERAND (TREE_OPERAND (operand, 0), 0);"}]}