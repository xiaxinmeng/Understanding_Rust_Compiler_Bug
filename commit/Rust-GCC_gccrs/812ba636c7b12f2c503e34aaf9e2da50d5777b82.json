{"sha": "812ba636c7b12f2c503e34aaf9e2da50d5777b82", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODEyYmE2MzZjN2IxMmYyYzUwM2UzNGFhZjllMmRhNTBkNTc3N2I4Mg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-10-18T14:38:29Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-10-18T14:38:29Z"}, "message": "runtime: copy netpoll code from Go 1.7 runtime\n    \n    Reviewed-on: https://go-review.googlesource.com/31325\n\nFrom-SVN: r241307", "tree": {"sha": "c81659977f9a532c5d4b53872301ba5e67c4166f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c81659977f9a532c5d4b53872301ba5e67c4166f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/812ba636c7b12f2c503e34aaf9e2da50d5777b82", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/812ba636c7b12f2c503e34aaf9e2da50d5777b82", "html_url": "https://github.com/Rust-GCC/gccrs/commit/812ba636c7b12f2c503e34aaf9e2da50d5777b82", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/812ba636c7b12f2c503e34aaf9e2da50d5777b82/comments", "author": null, "committer": null, "parents": [{"sha": "f5de494c59532fdad30097af4185b2ce74700984", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5de494c59532fdad30097af4185b2ce74700984", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5de494c59532fdad30097af4185b2ce74700984"}], "stats": {"total": 2305, "additions": 1159, "deletions": 1146}, "files": [{"sha": "40f91ced442ec93c2508c6951550f8120e8051b1", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/812ba636c7b12f2c503e34aaf9e2da50d5777b82/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/812ba636c7b12f2c503e34aaf9e2da50d5777b82/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=812ba636c7b12f2c503e34aaf9e2da50d5777b82", "patch": "@@ -1,4 +1,4 @@\n-0a49b1dadd862215bdd38b9725a6e193b0d8fd0b\n+68bb6a9875499037d3eccb79a1f92e1c7a476d58\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "1d93deb137016ed01f0cb637cfeedc31a878bed3", "filename": "libgo/Makefile.am", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/812ba636c7b12f2c503e34aaf9e2da50d5777b82/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/812ba636c7b12f2c503e34aaf9e2da50d5777b82/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=812ba636c7b12f2c503e34aaf9e2da50d5777b82", "patch": "@@ -427,16 +427,6 @@ endif\n endif\n endif\n \n-if LIBGO_IS_LINUX\n-runtime_netpoll_files = runtime/netpoll_epoll.c\n-else\n-if LIBGO_IS_SOLARIS\n-runtime_netpoll_files = runtime/netpoll_select.c\n-else\n-runtime_netpoll_files = runtime/netpoll_kqueue.c\n-endif\n-endif\n-\n runtime_files = \\\n \truntime/go-append.c \\\n \truntime/go-assert.c \\\n@@ -500,7 +490,6 @@ runtime_files = \\\n \truntime/mgc0.c \\\n \truntime/mheap.c \\\n \truntime/msize.c \\\n-\t$(runtime_netpoll_files) \\\n \truntime/panic.c \\\n \truntime/parfor.c \\\n \truntime/print.c \\\n@@ -514,7 +503,6 @@ runtime_files = \\\n \tgo-iface.c \\\n \tlfstack.c \\\n \tmalloc.c \\\n-\tnetpoll.c \\\n \treflect.c \\\n \truntime1.c \\\n \tsigqueue.c \\\n@@ -530,14 +518,6 @@ malloc.c: $(srcdir)/runtime/malloc.goc goc2c\n \t./goc2c $< > $@.tmp\n \tmv -f $@.tmp $@\n \n-mprof.c: $(srcdir)/runtime/mprof.goc goc2c\n-\t./goc2c $< > $@.tmp\n-\tmv -f $@.tmp $@\n-\n-netpoll.c: $(srcdir)/runtime/netpoll.goc goc2c\n-\t./goc2c $< > $@.tmp\n-\tmv -f $@.tmp $@\n-\n reflect.c: $(srcdir)/runtime/reflect.goc goc2c\n \t./goc2c $< > $@.tmp\n \tmv -f $@.tmp $@\n@@ -546,18 +526,10 @@ runtime1.c: $(srcdir)/runtime/runtime1.goc goc2c\n \t./goc2c $< > $@.tmp\n \tmv -f $@.tmp $@\n \n-sema.c: $(srcdir)/runtime/sema.goc goc2c\n-\t./goc2c $< > $@.tmp\n-\tmv -f $@.tmp $@\n-\n sigqueue.c: $(srcdir)/runtime/sigqueue.goc goc2c\n \t./goc2c --go-pkgpath os_signal $< > $@.tmp\n \tmv -f $@.tmp $@\n \n-time.c: $(srcdir)/runtime/time.goc goc2c\n-\t./goc2c $< > $@.tmp\n-\tmv -f $@.tmp $@\n-\n %.c: $(srcdir)/runtime/%.goc goc2c\n \t./goc2c $< > $@.tmp\n \tmv -f $@.tmp $@"}, {"sha": "43c404790e0cd2e7f4f1137eb32dccb9ef392cbb", "filename": "libgo/Makefile.in", "status": "modified", "additions": 17, "deletions": 66, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/812ba636c7b12f2c503e34aaf9e2da50d5777b82/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/812ba636c7b12f2c503e34aaf9e2da50d5777b82/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=812ba636c7b12f2c503e34aaf9e2da50d5777b82", "patch": "@@ -226,21 +226,18 @@ am__DEPENDENCIES_4 = $(am__DEPENDENCIES_2) \\\n libgo_llgo_la_DEPENDENCIES = $(am__DEPENDENCIES_4)\n @HAVE_SYS_MMAN_H_FALSE@am__objects_1 = mem_posix_memalign.lo\n @HAVE_SYS_MMAN_H_TRUE@am__objects_1 = mem.lo\n-@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_FALSE@am__objects_2 = netpoll_kqueue.lo\n-@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_TRUE@am__objects_2 = netpoll_select.lo\n-@LIBGO_IS_LINUX_TRUE@am__objects_2 = netpoll_epoll.lo\n-@LIBGO_IS_LINUX_FALSE@am__objects_3 = thread-sema.lo\n-@LIBGO_IS_LINUX_TRUE@am__objects_3 = thread-linux.lo\n-@LIBGO_IS_RTEMS_TRUE@am__objects_4 = rtems-task-variable-add.lo\n-@LIBGO_IS_DARWIN_FALSE@@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_FALSE@@LIBGO_IS_SOLARIS_FALSE@am__objects_5 = getncpu-none.lo\n-@LIBGO_IS_DARWIN_FALSE@@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_TRUE@@LIBGO_IS_SOLARIS_FALSE@am__objects_5 = getncpu-bsd.lo\n-@LIBGO_IS_DARWIN_FALSE@@LIBGO_IS_FREEBSD_TRUE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_FALSE@am__objects_5 = getncpu-bsd.lo\n-@LIBGO_IS_DARWIN_FALSE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_TRUE@am__objects_5 = getncpu-solaris.lo\n-@LIBGO_IS_DARWIN_FALSE@@LIBGO_IS_IRIX_TRUE@@LIBGO_IS_LINUX_FALSE@am__objects_5 = getncpu-irix.lo\n-@LIBGO_IS_DARWIN_TRUE@@LIBGO_IS_LINUX_FALSE@am__objects_5 =  \\\n+@LIBGO_IS_LINUX_FALSE@am__objects_2 = thread-sema.lo\n+@LIBGO_IS_LINUX_TRUE@am__objects_2 = thread-linux.lo\n+@LIBGO_IS_RTEMS_TRUE@am__objects_3 = rtems-task-variable-add.lo\n+@LIBGO_IS_DARWIN_FALSE@@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_FALSE@@LIBGO_IS_SOLARIS_FALSE@am__objects_4 = getncpu-none.lo\n+@LIBGO_IS_DARWIN_FALSE@@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_TRUE@@LIBGO_IS_SOLARIS_FALSE@am__objects_4 = getncpu-bsd.lo\n+@LIBGO_IS_DARWIN_FALSE@@LIBGO_IS_FREEBSD_TRUE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_FALSE@am__objects_4 = getncpu-bsd.lo\n+@LIBGO_IS_DARWIN_FALSE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_TRUE@am__objects_4 = getncpu-solaris.lo\n+@LIBGO_IS_DARWIN_FALSE@@LIBGO_IS_IRIX_TRUE@@LIBGO_IS_LINUX_FALSE@am__objects_4 = getncpu-irix.lo\n+@LIBGO_IS_DARWIN_TRUE@@LIBGO_IS_LINUX_FALSE@am__objects_4 =  \\\n @LIBGO_IS_DARWIN_TRUE@@LIBGO_IS_LINUX_FALSE@\tgetncpu-bsd.lo\n-@LIBGO_IS_LINUX_TRUE@am__objects_5 = getncpu-linux.lo\n-am__objects_6 = go-append.lo go-assert.lo go-assert-interface.lo \\\n+@LIBGO_IS_LINUX_TRUE@am__objects_4 = getncpu-linux.lo\n+am__objects_5 = go-append.lo go-assert.lo go-assert-interface.lo \\\n \tgo-breakpoint.lo go-caller.lo go-callers.lo \\\n \tgo-can-convert-interface.lo go-cdiv.lo go-cgo.lo \\\n \tgo-check-interface.lo go-construct-map.lo \\\n@@ -259,18 +256,18 @@ am__objects_6 = go-append.lo go-assert.lo go-assert-interface.lo \\\n \tgo-unsafe-pointer.lo go-unsetenv.lo go-unwind.lo go-varargs.lo \\\n \tenv_posix.lo heapdump.lo mcache.lo mcentral.lo \\\n \t$(am__objects_1) mfixalloc.lo mgc0.lo mheap.lo msize.lo \\\n-\t$(am__objects_2) panic.lo parfor.lo print.lo proc.lo \\\n-\truntime.lo signal_unix.lo thread.lo $(am__objects_3) yield.lo \\\n-\t$(am__objects_4) go-iface.lo lfstack.lo malloc.lo netpoll.lo \\\n-\treflect.lo runtime1.lo sigqueue.lo $(am__objects_5)\n-am_libgo_llgo_la_OBJECTS = $(am__objects_6)\n+\tpanic.lo parfor.lo print.lo proc.lo runtime.lo signal_unix.lo \\\n+\tthread.lo $(am__objects_2) yield.lo $(am__objects_3) \\\n+\tgo-iface.lo lfstack.lo malloc.lo reflect.lo runtime1.lo \\\n+\tsigqueue.lo $(am__objects_4)\n+am_libgo_llgo_la_OBJECTS = $(am__objects_5)\n libgo_llgo_la_OBJECTS = $(am_libgo_llgo_la_OBJECTS)\n libgo_llgo_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \\\n \t$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \\\n \t$(libgo_llgo_la_LDFLAGS) $(LDFLAGS) -o $@\n @GOC_IS_LLGO_TRUE@am_libgo_llgo_la_rpath = -rpath $(toolexeclibdir)\n libgo_la_DEPENDENCIES = $(am__DEPENDENCIES_4)\n-am_libgo_la_OBJECTS = $(am__objects_6)\n+am_libgo_la_OBJECTS = $(am__objects_5)\n libgo_la_OBJECTS = $(am_libgo_la_OBJECTS)\n libgo_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n \t--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(libgo_la_LDFLAGS) \\\n@@ -832,9 +829,6 @@ toolexeclibgounicode_DATA = \\\n @LIBGO_IS_DARWIN_FALSE@@LIBGO_IS_IRIX_TRUE@@LIBGO_IS_LINUX_FALSE@runtime_getncpu_file = runtime/getncpu-irix.c\n @LIBGO_IS_DARWIN_TRUE@@LIBGO_IS_LINUX_FALSE@runtime_getncpu_file = runtime/getncpu-bsd.c\n @LIBGO_IS_LINUX_TRUE@runtime_getncpu_file = runtime/getncpu-linux.c\n-@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_FALSE@runtime_netpoll_files = runtime/netpoll_kqueue.c\n-@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_TRUE@runtime_netpoll_files = runtime/netpoll_select.c\n-@LIBGO_IS_LINUX_TRUE@runtime_netpoll_files = runtime/netpoll_epoll.c\n runtime_files = \\\n \truntime/go-append.c \\\n \truntime/go-assert.c \\\n@@ -898,7 +892,6 @@ runtime_files = \\\n \truntime/mgc0.c \\\n \truntime/mheap.c \\\n \truntime/msize.c \\\n-\t$(runtime_netpoll_files) \\\n \truntime/panic.c \\\n \truntime/parfor.c \\\n \truntime/print.c \\\n@@ -912,7 +905,6 @@ runtime_files = \\\n \tgo-iface.c \\\n \tlfstack.c \\\n \tmalloc.c \\\n-\tnetpoll.c \\\n \treflect.c \\\n \truntime1.c \\\n \tsigqueue.c \\\n@@ -1616,10 +1608,6 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mgc0.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mheap.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/msize.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/netpoll.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/netpoll_epoll.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/netpoll_kqueue.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/netpoll_select.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/panic.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/parfor.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/print.Plo@am__quote@\n@@ -2139,27 +2127,6 @@ msize.lo: runtime/msize.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o msize.lo `test -f 'runtime/msize.c' || echo '$(srcdir)/'`runtime/msize.c\n \n-netpoll_kqueue.lo: runtime/netpoll_kqueue.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT netpoll_kqueue.lo -MD -MP -MF $(DEPDIR)/netpoll_kqueue.Tpo -c -o netpoll_kqueue.lo `test -f 'runtime/netpoll_kqueue.c' || echo '$(srcdir)/'`runtime/netpoll_kqueue.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/netpoll_kqueue.Tpo $(DEPDIR)/netpoll_kqueue.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/netpoll_kqueue.c' object='netpoll_kqueue.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o netpoll_kqueue.lo `test -f 'runtime/netpoll_kqueue.c' || echo '$(srcdir)/'`runtime/netpoll_kqueue.c\n-\n-netpoll_select.lo: runtime/netpoll_select.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT netpoll_select.lo -MD -MP -MF $(DEPDIR)/netpoll_select.Tpo -c -o netpoll_select.lo `test -f 'runtime/netpoll_select.c' || echo '$(srcdir)/'`runtime/netpoll_select.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/netpoll_select.Tpo $(DEPDIR)/netpoll_select.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/netpoll_select.c' object='netpoll_select.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o netpoll_select.lo `test -f 'runtime/netpoll_select.c' || echo '$(srcdir)/'`runtime/netpoll_select.c\n-\n-netpoll_epoll.lo: runtime/netpoll_epoll.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT netpoll_epoll.lo -MD -MP -MF $(DEPDIR)/netpoll_epoll.Tpo -c -o netpoll_epoll.lo `test -f 'runtime/netpoll_epoll.c' || echo '$(srcdir)/'`runtime/netpoll_epoll.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/netpoll_epoll.Tpo $(DEPDIR)/netpoll_epoll.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/netpoll_epoll.c' object='netpoll_epoll.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o netpoll_epoll.lo `test -f 'runtime/netpoll_epoll.c' || echo '$(srcdir)/'`runtime/netpoll_epoll.c\n-\n panic.lo: runtime/panic.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT panic.lo -MD -MP -MF $(DEPDIR)/panic.Tpo -c -o panic.lo `test -f 'runtime/panic.c' || echo '$(srcdir)/'`runtime/panic.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/panic.Tpo $(DEPDIR)/panic.Plo\n@@ -3402,14 +3369,6 @@ malloc.c: $(srcdir)/runtime/malloc.goc goc2c\n \t./goc2c $< > $@.tmp\n \tmv -f $@.tmp $@\n \n-mprof.c: $(srcdir)/runtime/mprof.goc goc2c\n-\t./goc2c $< > $@.tmp\n-\tmv -f $@.tmp $@\n-\n-netpoll.c: $(srcdir)/runtime/netpoll.goc goc2c\n-\t./goc2c $< > $@.tmp\n-\tmv -f $@.tmp $@\n-\n reflect.c: $(srcdir)/runtime/reflect.goc goc2c\n \t./goc2c $< > $@.tmp\n \tmv -f $@.tmp $@\n@@ -3418,18 +3377,10 @@ runtime1.c: $(srcdir)/runtime/runtime1.goc goc2c\n \t./goc2c $< > $@.tmp\n \tmv -f $@.tmp $@\n \n-sema.c: $(srcdir)/runtime/sema.goc goc2c\n-\t./goc2c $< > $@.tmp\n-\tmv -f $@.tmp $@\n-\n sigqueue.c: $(srcdir)/runtime/sigqueue.goc goc2c\n \t./goc2c --go-pkgpath os_signal $< > $@.tmp\n \tmv -f $@.tmp $@\n \n-time.c: $(srcdir)/runtime/time.goc goc2c\n-\t./goc2c $< > $@.tmp\n-\tmv -f $@.tmp $@\n-\n %.c: $(srcdir)/runtime/%.goc goc2c\n \t./goc2c $< > $@.tmp\n \tmv -f $@.tmp $@"}, {"sha": "d3b3067d32a52c9f65312f803638aac1de7d4553", "filename": "libgo/config.h.in", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/812ba636c7b12f2c503e34aaf9e2da50d5777b82/libgo%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/812ba636c7b12f2c503e34aaf9e2da50d5777b82/libgo%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfig.h.in?ref=812ba636c7b12f2c503e34aaf9e2da50d5777b82", "patch": "@@ -186,6 +186,9 @@\n /* Define to 1 if you have the `pipe2' function. */\n #undef HAVE_PIPE2\n \n+/* Define to 1 if you have the <port.h> header file. */\n+#undef HAVE_PORT_H\n+\n /* Define to 1 if you have the `removexattr' function. */\n #undef HAVE_REMOVEXATTR\n \n@@ -259,6 +262,9 @@\n /* Define to 1 if you have the <sys/epoll.h> header file. */\n #undef HAVE_SYS_EPOLL_H\n \n+/* Define to 1 if you have the <sys/event.h> header file. */\n+#undef HAVE_SYS_EVENT_H\n+\n /* Define to 1 if you have the <sys/file.h> header file. */\n #undef HAVE_SYS_FILE_H\n "}, {"sha": "6fd742b50b08c1cd00329687c64315b6a2c71d29", "filename": "libgo/configure", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/812ba636c7b12f2c503e34aaf9e2da50d5777b82/libgo%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/812ba636c7b12f2c503e34aaf9e2da50d5777b82/libgo%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfigure?ref=812ba636c7b12f2c503e34aaf9e2da50d5777b82", "patch": "@@ -14714,7 +14714,7 @@ $as_echo \"#define HAVE_GETIPINFO 1\" >>confdefs.h\n   fi\n \n \n-for ac_header in sched.h semaphore.h sys/file.h sys/mman.h syscall.h sys/epoll.h sys/inotify.h sys/ptrace.h sys/syscall.h sys/user.h sys/utsname.h sys/select.h sys/socket.h net/if.h net/if_arp.h net/route.h netpacket/packet.h sys/prctl.h sys/mount.h sys/vfs.h sys/statfs.h sys/timex.h sys/sysinfo.h utime.h linux/ether.h linux/fs.h linux/reboot.h netinet/icmp6.h netinet/in_syst.h netinet/ip.h netinet/ip_mroute.h netinet/if_ether.h\n+for ac_header in port.h sched.h semaphore.h sys/file.h sys/mman.h syscall.h sys/epoll.h sys/event.h sys/inotify.h sys/ptrace.h sys/syscall.h sys/user.h sys/utsname.h sys/select.h sys/socket.h net/if.h net/if_arp.h net/route.h netpacket/packet.h sys/prctl.h sys/mount.h sys/vfs.h sys/statfs.h sys/timex.h sys/sysinfo.h utime.h linux/ether.h linux/fs.h linux/reboot.h netinet/icmp6.h netinet/in_syst.h netinet/ip.h netinet/ip_mroute.h netinet/if_ether.h\n do :\n   as_ac_Header=`$as_echo \"ac_cv_header_$ac_header\" | $as_tr_sh`\n ac_fn_c_check_header_mongrel \"$LINENO\" \"$ac_header\" \"$as_ac_Header\" \"$ac_includes_default\""}, {"sha": "ef0e700db47c80e09762e3cb2f004372d6193bc9", "filename": "libgo/configure.ac", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/812ba636c7b12f2c503e34aaf9e2da50d5777b82/libgo%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/812ba636c7b12f2c503e34aaf9e2da50d5777b82/libgo%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfigure.ac?ref=812ba636c7b12f2c503e34aaf9e2da50d5777b82", "patch": "@@ -570,7 +570,7 @@ AC_C_BIGENDIAN\n \n GCC_CHECK_UNWIND_GETIPINFO\n \n-AC_CHECK_HEADERS(sched.h semaphore.h sys/file.h sys/mman.h syscall.h sys/epoll.h sys/inotify.h sys/ptrace.h sys/syscall.h sys/user.h sys/utsname.h sys/select.h sys/socket.h net/if.h net/if_arp.h net/route.h netpacket/packet.h sys/prctl.h sys/mount.h sys/vfs.h sys/statfs.h sys/timex.h sys/sysinfo.h utime.h linux/ether.h linux/fs.h linux/reboot.h netinet/icmp6.h netinet/in_syst.h netinet/ip.h netinet/ip_mroute.h netinet/if_ether.h)\n+AC_CHECK_HEADERS(port.h sched.h semaphore.h sys/file.h sys/mman.h syscall.h sys/epoll.h sys/event.h sys/inotify.h sys/ptrace.h sys/syscall.h sys/user.h sys/utsname.h sys/select.h sys/socket.h net/if.h net/if_arp.h net/route.h netpacket/packet.h sys/prctl.h sys/mount.h sys/vfs.h sys/statfs.h sys/timex.h sys/sysinfo.h utime.h linux/ether.h linux/fs.h linux/reboot.h netinet/icmp6.h netinet/in_syst.h netinet/ip.h netinet/ip_mroute.h netinet/if_ether.h)\n \n AC_CHECK_HEADERS([linux/filter.h linux/if_addr.h linux/if_ether.h linux/if_tun.h linux/netlink.h linux/rtnetlink.h], [], [],\n [#ifdef HAVE_SYS_SOCKET_H"}, {"sha": "729b59736754fa2b7893fd4ab72056729eabb7b3", "filename": "libgo/go/runtime/netpoll.go", "status": "added", "additions": 452, "deletions": 0, "changes": 452, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/812ba636c7b12f2c503e34aaf9e2da50d5777b82/libgo%2Fgo%2Fruntime%2Fnetpoll.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/812ba636c7b12f2c503e34aaf9e2da50d5777b82/libgo%2Fgo%2Fruntime%2Fnetpoll.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fnetpoll.go?ref=812ba636c7b12f2c503e34aaf9e2da50d5777b82", "patch": "@@ -0,0 +1,452 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build darwin dragonfly freebsd linux nacl netbsd openbsd solaris windows\n+\n+package runtime\n+\n+import (\n+\t\"runtime/internal/atomic\"\n+\t\"unsafe\"\n+)\n+\n+// Export temporarily for gccgo's C code to call:\n+//go:linkname netpoll runtime.netpoll\n+\n+// Integrated network poller (platform-independent part).\n+// A particular implementation (epoll/kqueue) must define the following functions:\n+// func netpollinit()\t\t\t// to initialize the poller\n+// func netpollopen(fd uintptr, pd *pollDesc) int32\t// to arm edge-triggered notifications\n+// and associate fd with pd.\n+// An implementation must call the following function to denote that the pd is ready.\n+// func netpollready(gpp **g, pd *pollDesc, mode int32)\n+\n+// pollDesc contains 2 binary semaphores, rg and wg, to park reader and writer\n+// goroutines respectively. The semaphore can be in the following states:\n+// pdReady - io readiness notification is pending;\n+//           a goroutine consumes the notification by changing the state to nil.\n+// pdWait - a goroutine prepares to park on the semaphore, but not yet parked;\n+//          the goroutine commits to park by changing the state to G pointer,\n+//          or, alternatively, concurrent io notification changes the state to READY,\n+//          or, alternatively, concurrent timeout/close changes the state to nil.\n+// G pointer - the goroutine is blocked on the semaphore;\n+//             io notification or timeout/close changes the state to READY or nil respectively\n+//             and unparks the goroutine.\n+// nil - nothing of the above.\n+const (\n+\tpdReady uintptr = 1\n+\tpdWait  uintptr = 2\n+)\n+\n+const pollBlockSize = 4 * 1024\n+\n+// Network poller descriptor.\n+type pollDesc struct {\n+\tlink *pollDesc // in pollcache, protected by pollcache.lock\n+\n+\t// The lock protects pollOpen, pollSetDeadline, pollUnblock and deadlineimpl operations.\n+\t// This fully covers seq, rt and wt variables. fd is constant throughout the PollDesc lifetime.\n+\t// pollReset, pollWait, pollWaitCanceled and runtime\u00b7netpollready (IO readiness notification)\n+\t// proceed w/o taking the lock. So closing, rg, rd, wg and wd are manipulated\n+\t// in a lock-free way by all operations.\n+\t// NOTE(dvyukov): the following code uses uintptr to store *g (rg/wg),\n+\t// that will blow up when GC starts moving objects.\n+\tlock    mutex // protects the following fields\n+\tfd      uintptr\n+\tclosing bool\n+\tseq     uintptr // protects from stale timers and ready notifications\n+\trg      uintptr // pdReady, pdWait, G waiting for read or nil\n+\trt      timer   // read deadline timer (set if rt.f != nil)\n+\trd      int64   // read deadline\n+\twg      uintptr // pdReady, pdWait, G waiting for write or nil\n+\twt      timer   // write deadline timer\n+\twd      int64   // write deadline\n+\tuser    uint32  // user settable cookie\n+}\n+\n+type pollCache struct {\n+\tlock  mutex\n+\tfirst *pollDesc\n+\t// PollDesc objects must be type-stable,\n+\t// because we can get ready notification from epoll/kqueue\n+\t// after the descriptor is closed/reused.\n+\t// Stale notifications are detected using seq variable,\n+\t// seq is incremented when deadlines are changed or descriptor is reused.\n+}\n+\n+var (\n+\tnetpollInited uint32\n+\tpollcache     pollCache\n+)\n+\n+//go:linkname net_runtime_pollServerInit net.runtime_pollServerInit\n+func net_runtime_pollServerInit() {\n+\tnetpollinit()\n+\tatomic.Store(&netpollInited, 1)\n+}\n+\n+func netpollinited() bool {\n+\treturn atomic.Load(&netpollInited) != 0\n+}\n+\n+//go:linkname net_runtime_pollOpen net.runtime_pollOpen\n+func net_runtime_pollOpen(fd uintptr) (*pollDesc, int) {\n+\tpd := pollcache.alloc()\n+\tlock(&pd.lock)\n+\tif pd.wg != 0 && pd.wg != pdReady {\n+\t\tthrow(\"netpollOpen: blocked write on free descriptor\")\n+\t}\n+\tif pd.rg != 0 && pd.rg != pdReady {\n+\t\tthrow(\"netpollOpen: blocked read on free descriptor\")\n+\t}\n+\tpd.fd = fd\n+\tpd.closing = false\n+\tpd.seq++\n+\tpd.rg = 0\n+\tpd.rd = 0\n+\tpd.wg = 0\n+\tpd.wd = 0\n+\tunlock(&pd.lock)\n+\n+\tvar errno int32\n+\terrno = netpollopen(fd, pd)\n+\treturn pd, int(errno)\n+}\n+\n+//go:linkname net_runtime_pollClose net.runtime_pollClose\n+func net_runtime_pollClose(pd *pollDesc) {\n+\tif !pd.closing {\n+\t\tthrow(\"netpollClose: close w/o unblock\")\n+\t}\n+\tif pd.wg != 0 && pd.wg != pdReady {\n+\t\tthrow(\"netpollClose: blocked write on closing descriptor\")\n+\t}\n+\tif pd.rg != 0 && pd.rg != pdReady {\n+\t\tthrow(\"netpollClose: blocked read on closing descriptor\")\n+\t}\n+\tnetpollclose(pd.fd)\n+\tpollcache.free(pd)\n+}\n+\n+func (c *pollCache) free(pd *pollDesc) {\n+\tlock(&c.lock)\n+\tpd.link = c.first\n+\tc.first = pd\n+\tunlock(&c.lock)\n+}\n+\n+//go:linkname net_runtime_pollReset net.runtime_pollReset\n+func net_runtime_pollReset(pd *pollDesc, mode int) int {\n+\terr := netpollcheckerr(pd, int32(mode))\n+\tif err != 0 {\n+\t\treturn err\n+\t}\n+\tif mode == 'r' {\n+\t\tpd.rg = 0\n+\t} else if mode == 'w' {\n+\t\tpd.wg = 0\n+\t}\n+\treturn 0\n+}\n+\n+//go:linkname net_runtime_pollWait net.runtime_pollWait\n+func net_runtime_pollWait(pd *pollDesc, mode int) int {\n+\terr := netpollcheckerr(pd, int32(mode))\n+\tif err != 0 {\n+\t\treturn err\n+\t}\n+\t// As for now only Solaris uses level-triggered IO.\n+\tif GOOS == \"solaris\" {\n+\t\tnetpollarm(pd, mode)\n+\t}\n+\tfor !netpollblock(pd, int32(mode), false) {\n+\t\terr = netpollcheckerr(pd, int32(mode))\n+\t\tif err != 0 {\n+\t\t\treturn err\n+\t\t}\n+\t\t// Can happen if timeout has fired and unblocked us,\n+\t\t// but before we had a chance to run, timeout has been reset.\n+\t\t// Pretend it has not happened and retry.\n+\t}\n+\treturn 0\n+}\n+\n+//go:linkname net_runtime_pollWaitCanceled net.runtime_pollWaitCanceled\n+func net_runtime_pollWaitCanceled(pd *pollDesc, mode int) {\n+\t// This function is used only on windows after a failed attempt to cancel\n+\t// a pending async IO operation. Wait for ioready, ignore closing or timeouts.\n+\tfor !netpollblock(pd, int32(mode), true) {\n+\t}\n+}\n+\n+//go:linkname net_runtime_pollSetDeadline net.runtime_pollSetDeadline\n+func net_runtime_pollSetDeadline(pd *pollDesc, d int64, mode int) {\n+\tlock(&pd.lock)\n+\tif pd.closing {\n+\t\tunlock(&pd.lock)\n+\t\treturn\n+\t}\n+\tpd.seq++ // invalidate current timers\n+\t// Reset current timers.\n+\tif pd.rt.f != nil {\n+\t\tdeltimer(&pd.rt)\n+\t\tpd.rt.f = nil\n+\t}\n+\tif pd.wt.f != nil {\n+\t\tdeltimer(&pd.wt)\n+\t\tpd.wt.f = nil\n+\t}\n+\t// Setup new timers.\n+\tif d != 0 && d <= nanotime() {\n+\t\td = -1\n+\t}\n+\tif mode == 'r' || mode == 'r'+'w' {\n+\t\tpd.rd = d\n+\t}\n+\tif mode == 'w' || mode == 'r'+'w' {\n+\t\tpd.wd = d\n+\t}\n+\tif pd.rd > 0 && pd.rd == pd.wd {\n+\t\tpd.rt.f = netpollDeadline\n+\t\tpd.rt.when = pd.rd\n+\t\t// Copy current seq into the timer arg.\n+\t\t// Timer func will check the seq against current descriptor seq,\n+\t\t// if they differ the descriptor was reused or timers were reset.\n+\t\tpd.rt.arg = pd\n+\t\tpd.rt.seq = pd.seq\n+\t\taddtimer(&pd.rt)\n+\t} else {\n+\t\tif pd.rd > 0 {\n+\t\t\tpd.rt.f = netpollReadDeadline\n+\t\t\tpd.rt.when = pd.rd\n+\t\t\tpd.rt.arg = pd\n+\t\t\tpd.rt.seq = pd.seq\n+\t\t\taddtimer(&pd.rt)\n+\t\t}\n+\t\tif pd.wd > 0 {\n+\t\t\tpd.wt.f = netpollWriteDeadline\n+\t\t\tpd.wt.when = pd.wd\n+\t\t\tpd.wt.arg = pd\n+\t\t\tpd.wt.seq = pd.seq\n+\t\t\taddtimer(&pd.wt)\n+\t\t}\n+\t}\n+\t// If we set the new deadline in the past, unblock currently pending IO if any.\n+\tvar rg, wg *g\n+\tatomicstorep(unsafe.Pointer(&wg), nil) // full memory barrier between stores to rd/wd and load of rg/wg in netpollunblock\n+\tif pd.rd < 0 {\n+\t\trg = netpollunblock(pd, 'r', false)\n+\t}\n+\tif pd.wd < 0 {\n+\t\twg = netpollunblock(pd, 'w', false)\n+\t}\n+\tunlock(&pd.lock)\n+\tif rg != nil {\n+\t\tgoready(rg, 3)\n+\t}\n+\tif wg != nil {\n+\t\tgoready(wg, 3)\n+\t}\n+}\n+\n+//go:linkname net_runtime_pollUnblock net.runtime_pollUnblock\n+func net_runtime_pollUnblock(pd *pollDesc) {\n+\tlock(&pd.lock)\n+\tif pd.closing {\n+\t\tthrow(\"netpollUnblock: already closing\")\n+\t}\n+\tpd.closing = true\n+\tpd.seq++\n+\tvar rg, wg *g\n+\tatomicstorep(unsafe.Pointer(&rg), nil) // full memory barrier between store to closing and read of rg/wg in netpollunblock\n+\trg = netpollunblock(pd, 'r', false)\n+\twg = netpollunblock(pd, 'w', false)\n+\tif pd.rt.f != nil {\n+\t\tdeltimer(&pd.rt)\n+\t\tpd.rt.f = nil\n+\t}\n+\tif pd.wt.f != nil {\n+\t\tdeltimer(&pd.wt)\n+\t\tpd.wt.f = nil\n+\t}\n+\tunlock(&pd.lock)\n+\tif rg != nil {\n+\t\tgoready(rg, 3)\n+\t}\n+\tif wg != nil {\n+\t\tgoready(wg, 3)\n+\t}\n+}\n+\n+// make pd ready, newly runnable goroutines (if any) are returned in rg/wg\n+// May run during STW, so write barriers are not allowed.\n+//go:nowritebarrier\n+func netpollready(gpp *guintptr, pd *pollDesc, mode int32) {\n+\tvar rg, wg guintptr\n+\tif mode == 'r' || mode == 'r'+'w' {\n+\t\trg.set(netpollunblock(pd, 'r', true))\n+\t}\n+\tif mode == 'w' || mode == 'r'+'w' {\n+\t\twg.set(netpollunblock(pd, 'w', true))\n+\t}\n+\tif rg != 0 {\n+\t\trg.ptr().schedlink = *gpp\n+\t\t*gpp = rg\n+\t}\n+\tif wg != 0 {\n+\t\twg.ptr().schedlink = *gpp\n+\t\t*gpp = wg\n+\t}\n+}\n+\n+func netpollcheckerr(pd *pollDesc, mode int32) int {\n+\tif pd.closing {\n+\t\treturn 1 // errClosing\n+\t}\n+\tif (mode == 'r' && pd.rd < 0) || (mode == 'w' && pd.wd < 0) {\n+\t\treturn 2 // errTimeout\n+\t}\n+\treturn 0\n+}\n+\n+func netpollblockcommit(gp *g, gpp unsafe.Pointer) bool {\n+\treturn atomic.Casuintptr((*uintptr)(gpp), pdWait, uintptr(unsafe.Pointer(gp)))\n+}\n+\n+// returns true if IO is ready, or false if timedout or closed\n+// waitio - wait only for completed IO, ignore errors\n+func netpollblock(pd *pollDesc, mode int32, waitio bool) bool {\n+\tgpp := &pd.rg\n+\tif mode == 'w' {\n+\t\tgpp = &pd.wg\n+\t}\n+\n+\t// set the gpp semaphore to WAIT\n+\tfor {\n+\t\told := *gpp\n+\t\tif old == pdReady {\n+\t\t\t*gpp = 0\n+\t\t\treturn true\n+\t\t}\n+\t\tif old != 0 {\n+\t\t\tthrow(\"netpollblock: double wait\")\n+\t\t}\n+\t\tif atomic.Casuintptr(gpp, 0, pdWait) {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\n+\t// need to recheck error states after setting gpp to WAIT\n+\t// this is necessary because runtime_pollUnblock/runtime_pollSetDeadline/deadlineimpl\n+\t// do the opposite: store to closing/rd/wd, membarrier, load of rg/wg\n+\tif waitio || netpollcheckerr(pd, mode) == 0 {\n+\t\tgopark(netpollblockcommit, unsafe.Pointer(gpp), \"IO wait\", traceEvGoBlockNet, 5)\n+\t}\n+\t// be careful to not lose concurrent READY notification\n+\told := atomic.Xchguintptr(gpp, 0)\n+\tif old > pdWait {\n+\t\tthrow(\"netpollblock: corrupted state\")\n+\t}\n+\treturn old == pdReady\n+}\n+\n+func netpollunblock(pd *pollDesc, mode int32, ioready bool) *g {\n+\tgpp := &pd.rg\n+\tif mode == 'w' {\n+\t\tgpp = &pd.wg\n+\t}\n+\n+\tfor {\n+\t\told := *gpp\n+\t\tif old == pdReady {\n+\t\t\treturn nil\n+\t\t}\n+\t\tif old == 0 && !ioready {\n+\t\t\t// Only set READY for ioready. runtime_pollWait\n+\t\t\t// will check for timeout/cancel before waiting.\n+\t\t\treturn nil\n+\t\t}\n+\t\tvar new uintptr\n+\t\tif ioready {\n+\t\t\tnew = pdReady\n+\t\t}\n+\t\tif atomic.Casuintptr(gpp, old, new) {\n+\t\t\tif old == pdReady || old == pdWait {\n+\t\t\t\told = 0\n+\t\t\t}\n+\t\t\treturn (*g)(unsafe.Pointer(old))\n+\t\t}\n+\t}\n+}\n+\n+func netpolldeadlineimpl(pd *pollDesc, seq uintptr, read, write bool) {\n+\tlock(&pd.lock)\n+\t// Seq arg is seq when the timer was set.\n+\t// If it's stale, ignore the timer event.\n+\tif seq != pd.seq {\n+\t\t// The descriptor was reused or timers were reset.\n+\t\tunlock(&pd.lock)\n+\t\treturn\n+\t}\n+\tvar rg *g\n+\tif read {\n+\t\tif pd.rd <= 0 || pd.rt.f == nil {\n+\t\t\tthrow(\"netpolldeadlineimpl: inconsistent read deadline\")\n+\t\t}\n+\t\tpd.rd = -1\n+\t\tatomicstorep(unsafe.Pointer(&pd.rt.f), nil) // full memory barrier between store to rd and load of rg in netpollunblock\n+\t\trg = netpollunblock(pd, 'r', false)\n+\t}\n+\tvar wg *g\n+\tif write {\n+\t\tif pd.wd <= 0 || pd.wt.f == nil && !read {\n+\t\t\tthrow(\"netpolldeadlineimpl: inconsistent write deadline\")\n+\t\t}\n+\t\tpd.wd = -1\n+\t\tatomicstorep(unsafe.Pointer(&pd.wt.f), nil) // full memory barrier between store to wd and load of wg in netpollunblock\n+\t\twg = netpollunblock(pd, 'w', false)\n+\t}\n+\tunlock(&pd.lock)\n+\tif rg != nil {\n+\t\tgoready(rg, 0)\n+\t}\n+\tif wg != nil {\n+\t\tgoready(wg, 0)\n+\t}\n+}\n+\n+func netpollDeadline(arg interface{}, seq uintptr) {\n+\tnetpolldeadlineimpl(arg.(*pollDesc), seq, true, true)\n+}\n+\n+func netpollReadDeadline(arg interface{}, seq uintptr) {\n+\tnetpolldeadlineimpl(arg.(*pollDesc), seq, true, false)\n+}\n+\n+func netpollWriteDeadline(arg interface{}, seq uintptr) {\n+\tnetpolldeadlineimpl(arg.(*pollDesc), seq, false, true)\n+}\n+\n+func (c *pollCache) alloc() *pollDesc {\n+\tlock(&c.lock)\n+\tif c.first == nil {\n+\t\tconst pdSize = unsafe.Sizeof(pollDesc{})\n+\t\tn := pollBlockSize / pdSize\n+\t\tif n == 0 {\n+\t\t\tn = 1\n+\t\t}\n+\t\t// Must be in non-GC memory because can be referenced\n+\t\t// only from epoll/kqueue internals.\n+\t\tmem := persistentalloc(n*pdSize, 0, &memstats.other_sys)\n+\t\tfor i := uintptr(0); i < n; i++ {\n+\t\t\tpd := (*pollDesc)(add(mem, i*pdSize))\n+\t\t\tpd.link = c.first\n+\t\t\tc.first = pd\n+\t\t}\n+\t}\n+\tpd := c.first\n+\tc.first = pd.link\n+\tunlock(&c.lock)\n+\treturn pd\n+}"}, {"sha": "777150eb7abd54981c47cac40433969638ecb5c3", "filename": "libgo/go/runtime/netpoll_epoll.go", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/812ba636c7b12f2c503e34aaf9e2da50d5777b82/libgo%2Fgo%2Fruntime%2Fnetpoll_epoll.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/812ba636c7b12f2c503e34aaf9e2da50d5777b82/libgo%2Fgo%2Fruntime%2Fnetpoll_epoll.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fnetpoll_epoll.go?ref=812ba636c7b12f2c503e34aaf9e2da50d5777b82", "patch": "@@ -0,0 +1,116 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build linux\n+\n+package runtime\n+\n+import \"unsafe\"\n+\n+//extern epoll_create\n+func epollcreate(size int32) int32\n+\n+//extern epoll_create1\n+func epollcreate1(flags int32) int32\n+\n+//go:noescape\n+//extern epoll_ctl\n+func epollctl(epfd, op, fd int32, ev *epollevent) int32\n+\n+//go:noescape\n+//extern epoll_wait\n+func epollwait(epfd int32, ev *epollevent, nev, timeout int32) int32\n+\n+//extern __go_fcntl_uintptr\n+func fcntlUintptr(fd, cmd, arg uintptr) (uintptr, uintptr)\n+\n+func closeonexec(fd int32) {\n+\tfcntlUintptr(uintptr(fd), _F_SETFD, _FD_CLOEXEC)\n+}\n+\n+var (\n+\tepfd int32 = -1 // epoll descriptor\n+)\n+\n+func netpollinit() {\n+\tepfd = epollcreate1(_EPOLL_CLOEXEC)\n+\tif epfd >= 0 {\n+\t\treturn\n+\t}\n+\tepfd = epollcreate(1024)\n+\tif epfd >= 0 {\n+\t\tcloseonexec(epfd)\n+\t\treturn\n+\t}\n+\tprintln(\"netpollinit: failed to create epoll descriptor\", errno())\n+\tthrow(\"netpollinit: failed to create descriptor\")\n+}\n+\n+func netpollopen(fd uintptr, pd *pollDesc) int32 {\n+\tvar ev epollevent\n+\tev.events = _EPOLLIN | _EPOLLOUT | _EPOLLRDHUP | _EPOLLET\n+\t*(**pollDesc)(unsafe.Pointer(&ev.data)) = pd\n+\tif epollctl(epfd, _EPOLL_CTL_ADD, int32(fd), &ev) < 0 {\n+\t\treturn int32(errno())\n+\t}\n+\treturn 0\n+}\n+\n+func netpollclose(fd uintptr) int32 {\n+\tvar ev epollevent\n+\tif epollctl(epfd, _EPOLL_CTL_DEL, int32(fd), &ev) < 0 {\n+\t\treturn int32(errno())\n+\t}\n+\treturn 0\n+}\n+\n+func netpollarm(pd *pollDesc, mode int) {\n+\tthrow(\"unused\")\n+}\n+\n+// polls for ready network connections\n+// returns list of goroutines that become runnable\n+func netpoll(block bool) *g {\n+\tif epfd == -1 {\n+\t\treturn nil\n+\t}\n+\twaitms := int32(-1)\n+\tif !block {\n+\t\twaitms = 0\n+\t}\n+\tvar events [128]epollevent\n+retry:\n+\tn := epollwait(epfd, &events[0], int32(len(events)), waitms)\n+\tif n < 0 {\n+\t\te := errno()\n+\t\tif e != _EINTR {\n+\t\t\tprintln(\"runtime: epollwait on fd\", epfd, \"failed with\", e)\n+\t\t\tthrow(\"epollwait failed\")\n+\t\t}\n+\t\tgoto retry\n+\t}\n+\tvar gp guintptr\n+\tfor i := int32(0); i < n; i++ {\n+\t\tev := &events[i]\n+\t\tif ev.events == 0 {\n+\t\t\tcontinue\n+\t\t}\n+\t\tvar mode int32\n+\t\tif ev.events&(_EPOLLIN|_EPOLLRDHUP|_EPOLLHUP|_EPOLLERR) != 0 {\n+\t\t\tmode += 'r'\n+\t\t}\n+\t\tif ev.events&(_EPOLLOUT|_EPOLLHUP|_EPOLLERR) != 0 {\n+\t\t\tmode += 'w'\n+\t\t}\n+\t\tif mode != 0 {\n+\t\t\tpd := *(**pollDesc)(unsafe.Pointer(&ev.data))\n+\n+\t\t\tnetpollready(&gp, pd, mode)\n+\t\t}\n+\t}\n+\tif block && gp == 0 {\n+\t\tgoto retry\n+\t}\n+\treturn gp.ptr()\n+}"}, {"sha": "eae4f21d1df997bb520121e65996361c2b0ee490", "filename": "libgo/go/runtime/netpoll_kqueue.go", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/812ba636c7b12f2c503e34aaf9e2da50d5777b82/libgo%2Fgo%2Fruntime%2Fnetpoll_kqueue.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/812ba636c7b12f2c503e34aaf9e2da50d5777b82/libgo%2Fgo%2Fruntime%2Fnetpoll_kqueue.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fnetpoll_kqueue.go?ref=812ba636c7b12f2c503e34aaf9e2da50d5777b82", "patch": "@@ -0,0 +1,110 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build darwin dragonfly freebsd netbsd openbsd\n+\n+package runtime\n+\n+// Integrated network poller (kqueue-based implementation).\n+\n+import \"unsafe\"\n+\n+//extern kqueue\n+func kqueue() int32\n+\n+//go:noescape\n+//extern kevent\n+func kevent(kq int32, ch *keventt, nch uintptr, ev *keventt, nev uintptr, ts *timespec) int32\n+\n+//extern __go_fcntl_uintptr\n+func fcntlUintptr(fd, cmd, arg uintptr) (uintptr, uintptr)\n+\n+func closeonexec(fd int32) {\n+\tfcntlUintptr(uintptr(fd), _F_SETFD, _FD_CLOEXEC)\n+}\n+\n+var (\n+\tkq int32 = -1\n+)\n+\n+func netpollinit() {\n+\tkq = kqueue()\n+\tif kq < 0 {\n+\t\tprintln(\"netpollinit: kqueue failed with\", errno())\n+\t\tthrow(\"netpollinit: kqueue failed\")\n+\t}\n+\tcloseonexec(kq)\n+}\n+\n+func netpollopen(fd uintptr, pd *pollDesc) int32 {\n+\t// Arm both EVFILT_READ and EVFILT_WRITE in edge-triggered mode (EV_CLEAR)\n+\t// for the whole fd lifetime. The notifications are automatically unregistered\n+\t// when fd is closed.\n+\tvar ev [2]keventt\n+\t*(*uintptr)(unsafe.Pointer(&ev[0].ident)) = fd\n+\tev[0].filter = _EVFILT_READ\n+\tev[0].flags = _EV_ADD | _EV_CLEAR\n+\tev[0].fflags = 0\n+\tev[0].data = 0\n+\tev[0].udata = (*byte)(unsafe.Pointer(pd))\n+\tev[1] = ev[0]\n+\tev[1].filter = _EVFILT_WRITE\n+\tn := kevent(kq, &ev[0], 2, nil, 0, nil)\n+\tif n < 0 {\n+\t\treturn int32(errno())\n+\t}\n+\treturn 0\n+}\n+\n+func netpollclose(fd uintptr) int32 {\n+\t// Don't need to unregister because calling close()\n+\t// on fd will remove any kevents that reference the descriptor.\n+\treturn 0\n+}\n+\n+func netpollarm(pd *pollDesc, mode int) {\n+\tthrow(\"unused\")\n+}\n+\n+// Polls for ready network connections.\n+// Returns list of goroutines that become runnable.\n+func netpoll(block bool) *g {\n+\tif kq == -1 {\n+\t\treturn nil\n+\t}\n+\tvar tp *timespec\n+\tvar ts timespec\n+\tif !block {\n+\t\ttp = &ts\n+\t}\n+\tvar events [64]keventt\n+retry:\n+\tn := kevent(kq, nil, 0, &events[0], uintptr(len(events)), tp)\n+\tif n < 0 {\n+\t\te := errno()\n+\t\tif e != _EINTR {\n+\t\t\tprintln(\"runtime: kevent on fd\", kq, \"failed with\", e)\n+\t\t\tthrow(\"kevent failed\")\n+\t\t}\n+\t\tgoto retry\n+\t}\n+\tvar gp guintptr\n+\tfor i := 0; i < int(n); i++ {\n+\t\tev := &events[i]\n+\t\tvar mode int32\n+\t\tif ev.filter == _EVFILT_READ {\n+\t\t\tmode += 'r'\n+\t\t}\n+\t\tif ev.filter == _EVFILT_WRITE {\n+\t\t\tmode += 'w'\n+\t\t}\n+\t\tif mode != 0 {\n+\t\t\tnetpollready(&gp, (*pollDesc)(unsafe.Pointer(ev.udata)), mode)\n+\t\t}\n+\t}\n+\tif block && gp == 0 {\n+\t\tgoto retry\n+\t}\n+\treturn gp.ptr()\n+}"}, {"sha": "5cbc30032141482703da4d653c5a353eed69ec30", "filename": "libgo/go/runtime/netpoll_nacl.go", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/812ba636c7b12f2c503e34aaf9e2da50d5777b82/libgo%2Fgo%2Fruntime%2Fnetpoll_nacl.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/812ba636c7b12f2c503e34aaf9e2da50d5777b82/libgo%2Fgo%2Fruntime%2Fnetpoll_nacl.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fnetpoll_nacl.go?ref=812ba636c7b12f2c503e34aaf9e2da50d5777b82", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Fake network poller for NaCl.\n+// Should never be used, because NaCl network connections do not honor \"SetNonblock\".\n+\n+package runtime\n+\n+func netpollinit() {\n+}\n+\n+func netpollopen(fd uintptr, pd *pollDesc) int32 {\n+\treturn 0\n+}\n+\n+func netpollclose(fd uintptr) int32 {\n+\treturn 0\n+}\n+\n+func netpollarm(pd *pollDesc, mode int) {\n+}\n+\n+func netpoll(block bool) *g {\n+\treturn nil\n+}"}, {"sha": "cc6754cd2ebd0a450ecddbf83c88a8a70d242e7f", "filename": "libgo/go/runtime/netpoll_solaris.go", "status": "added", "additions": 225, "deletions": 0, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/812ba636c7b12f2c503e34aaf9e2da50d5777b82/libgo%2Fgo%2Fruntime%2Fnetpoll_solaris.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/812ba636c7b12f2c503e34aaf9e2da50d5777b82/libgo%2Fgo%2Fruntime%2Fnetpoll_solaris.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fnetpoll_solaris.go?ref=812ba636c7b12f2c503e34aaf9e2da50d5777b82", "patch": "@@ -0,0 +1,225 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package runtime\n+\n+import \"unsafe\"\n+\n+// Solaris runtime-integrated network poller.\n+//\n+// Solaris uses event ports for scalable network I/O. Event\n+// ports are level-triggered, unlike epoll and kqueue which\n+// can be configured in both level-triggered and edge-triggered\n+// mode. Level triggering means we have to keep track of a few things\n+// ourselves. After we receive an event for a file descriptor,\n+// it's our responsibility to ask again to be notified for future\n+// events for that descriptor. When doing this we must keep track of\n+// what kind of events the goroutines are currently interested in,\n+// for example a fd may be open both for reading and writing.\n+//\n+// A description of the high level operation of this code\n+// follows. Networking code will get a file descriptor by some means\n+// and will register it with the netpolling mechanism by a code path\n+// that eventually calls runtime\u00b7netpollopen. runtime\u00b7netpollopen\n+// calls port_associate with an empty event set. That means that we\n+// will not receive any events at this point. The association needs\n+// to be done at this early point because we need to process the I/O\n+// readiness notification at some point in the future. If I/O becomes\n+// ready when nobody is listening, when we finally care about it,\n+// nobody will tell us anymore.\n+//\n+// Beside calling runtime\u00b7netpollopen, the networking code paths\n+// will call runtime\u00b7netpollarm each time goroutines are interested\n+// in doing network I/O. Because now we know what kind of I/O we\n+// are interested in (reading/writing), we can call port_associate\n+// passing the correct type of event set (POLLIN/POLLOUT). As we made\n+// sure to have already associated the file descriptor with the port,\n+// when we now call port_associate, we will unblock the main poller\n+// loop (in runtime\u00b7netpoll) right away if the socket is actually\n+// ready for I/O.\n+//\n+// The main poller loop runs in its own thread waiting for events\n+// using port_getn. When an event happens, it will tell the scheduler\n+// about it using runtime\u00b7netpollready. Besides doing this, it must\n+// also re-associate the events that were not part of this current\n+// notification with the file descriptor. Failing to do this would\n+// mean each notification will prevent concurrent code using the\n+// same file descriptor in parallel.\n+//\n+// The logic dealing with re-associations is encapsulated in\n+// runtime\u00b7netpollupdate. This function takes care to associate the\n+// descriptor only with the subset of events that were previously\n+// part of the association, except the one that just happened. We\n+// can't re-associate with that right away, because event ports\n+// are level triggered so it would cause a busy loop. Instead, that\n+// association is effected only by the runtime\u00b7netpollarm code path,\n+// when Go code actually asks for I/O.\n+//\n+// The open and arming mechanisms are serialized using the lock\n+// inside PollDesc. This is required because the netpoll loop runs\n+// asynchronously in respect to other Go code and by the time we get\n+// to call port_associate to update the association in the loop, the\n+// file descriptor might have been closed and reopened already. The\n+// lock allows runtime\u00b7netpollupdate to be called synchronously from\n+// the loop thread while preventing other threads operating to the\n+// same PollDesc, so once we unblock in the main loop, until we loop\n+// again we know for sure we are always talking about the same file\n+// descriptor and can safely access the data we want (the event set).\n+\n+//extern __go_fcntl_uintptr\n+func fcntlUintptr(fd, cmd, arg uintptr) (uintptr, uintptr)\n+\n+func fcntl(fd, cmd int32, arg uintptr) int32 {\n+\tr, _ := fcntlUintptr(uintptr(fd), uintptr(cmd), arg)\n+\treturn int32(r)\n+}\n+\n+//extern port_create\n+func port_create() int32\n+\n+//extern port_associate\n+func port_associate(port, source int32, object uintptr, events uint32, user uintptr) int32\n+\n+//extern port_dissociate\n+func port_dissociate(port, source int32, object uintptr) int32\n+\n+//extern port_getn\n+func port_getn(port int32, evs *portevent, max uint32, nget *uint32, timeout *timespec) int32\n+\n+var portfd int32 = -1\n+\n+func netpollinit() {\n+\tportfd = port_create()\n+\tif portfd >= 0 {\n+\t\tfcntl(portfd, _F_SETFD, _FD_CLOEXEC)\n+\t\treturn\n+\t}\n+\n+\tprint(\"netpollinit: failed to create port (\", errno(), \")\\n\")\n+\tthrow(\"netpollinit: failed to create port\")\n+}\n+\n+func netpollopen(fd uintptr, pd *pollDesc) int32 {\n+\tlock(&pd.lock)\n+\t// We don't register for any specific type of events yet, that's\n+\t// netpollarm's job. We merely ensure we call port_associate before\n+\t// asynchronous connect/accept completes, so when we actually want\n+\t// to do any I/O, the call to port_associate (from netpollarm,\n+\t// with the interested event set) will unblock port_getn right away\n+\t// because of the I/O readiness notification.\n+\tpd.user = 0\n+\tr := port_associate(portfd, _PORT_SOURCE_FD, fd, 0, uintptr(unsafe.Pointer(pd)))\n+\tunlock(&pd.lock)\n+\tif r < 0 {\n+\t\treturn int32(errno())\n+\t}\n+\treturn 0\n+}\n+\n+func netpollclose(fd uintptr) int32 {\n+\tif port_dissociate(portfd, _PORT_SOURCE_FD, fd) < 0 {\n+\t\treturn int32(errno())\n+\t}\n+\treturn 0\n+}\n+\n+// Updates the association with a new set of interested events. After\n+// this call, port_getn will return one and only one event for that\n+// particular descriptor, so this function needs to be called again.\n+func netpollupdate(pd *pollDesc, set, clear uint32) {\n+\tif pd.closing {\n+\t\treturn\n+\t}\n+\n+\told := pd.user\n+\tevents := (old & ^clear) | set\n+\tif old == events {\n+\t\treturn\n+\t}\n+\n+\tif events != 0 && port_associate(portfd, _PORT_SOURCE_FD, pd.fd, events, uintptr(unsafe.Pointer(pd))) != 0 {\n+\t\tprint(\"netpollupdate: failed to associate (\", errno(), \")\\n\")\n+\t\tthrow(\"netpollupdate: failed to associate\")\n+\t}\n+\tpd.user = events\n+}\n+\n+// subscribe the fd to the port such that port_getn will return one event.\n+func netpollarm(pd *pollDesc, mode int) {\n+\tlock(&pd.lock)\n+\tswitch mode {\n+\tcase 'r':\n+\t\tnetpollupdate(pd, _POLLIN, 0)\n+\tcase 'w':\n+\t\tnetpollupdate(pd, _POLLOUT, 0)\n+\tdefault:\n+\t\tthrow(\"netpollarm: bad mode\")\n+\t}\n+\tunlock(&pd.lock)\n+}\n+\n+// polls for ready network connections\n+// returns list of goroutines that become runnable\n+func netpoll(block bool) *g {\n+\tif portfd == -1 {\n+\t\treturn nil\n+\t}\n+\n+\tvar wait *timespec\n+\tvar zero timespec\n+\tif !block {\n+\t\twait = &zero\n+\t}\n+\n+\tvar events [128]portevent\n+retry:\n+\tvar n uint32 = 1\n+\tif port_getn(portfd, &events[0], uint32(len(events)), &n, wait) < 0 {\n+\t\tif e := errno(); e != _EINTR {\n+\t\t\tprint(\"runtime: port_getn on fd \", portfd, \" failed with \", e, \"\\n\")\n+\t\t\tthrow(\"port_getn failed\")\n+\t\t}\n+\t\tgoto retry\n+\t}\n+\n+\tvar gp guintptr\n+\tfor i := 0; i < int(n); i++ {\n+\t\tev := &events[i]\n+\n+\t\tif ev.portev_events == 0 {\n+\t\t\tcontinue\n+\t\t}\n+\t\tpd := (*pollDesc)(unsafe.Pointer(ev.portev_user))\n+\n+\t\tvar mode, clear int32\n+\t\tif (ev.portev_events & (_POLLIN | _POLLHUP | _POLLERR)) != 0 {\n+\t\t\tmode += 'r'\n+\t\t\tclear |= _POLLIN\n+\t\t}\n+\t\tif (ev.portev_events & (_POLLOUT | _POLLHUP | _POLLERR)) != 0 {\n+\t\t\tmode += 'w'\n+\t\t\tclear |= _POLLOUT\n+\t\t}\n+\t\t// To effect edge-triggered events, we need to be sure to\n+\t\t// update our association with whatever events were not\n+\t\t// set with the event. For example if we are registered\n+\t\t// for POLLIN|POLLOUT, and we get POLLIN, besides waking\n+\t\t// the goroutine interested in POLLIN we have to not forget\n+\t\t// about the one interested in POLLOUT.\n+\t\tif clear != 0 {\n+\t\t\tlock(&pd.lock)\n+\t\t\tnetpollupdate(pd, 0, uint32(clear))\n+\t\t\tunlock(&pd.lock)\n+\t\t}\n+\n+\t\tif mode != 0 {\n+\t\t\tnetpollready(&gp, pd, mode)\n+\t\t}\n+\t}\n+\n+\tif block && gp == 0 {\n+\t\tgoto retry\n+\t}\n+\treturn gp.ptr()\n+}"}, {"sha": "09f64ad9b5b4d920f623b2728e8157824da3f109", "filename": "libgo/go/runtime/netpoll_stub.go", "status": "renamed", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/812ba636c7b12f2c503e34aaf9e2da50d5777b82/libgo%2Fgo%2Fruntime%2Fnetpoll_stub.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/812ba636c7b12f2c503e34aaf9e2da50d5777b82/libgo%2Fgo%2Fruntime%2Fnetpoll_stub.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fnetpoll_stub.go?ref=812ba636c7b12f2c503e34aaf9e2da50d5777b82", "patch": "@@ -4,23 +4,16 @@\n \n // +build plan9\n \n-#include \"runtime.h\"\n-#include \"malloc.h\"\n+package runtime\n \n // Polls for ready network connections.\n // Returns list of goroutines that become runnable.\n-G*\n-runtime_netpoll(bool block)\n-{\n+func netpoll(block bool) (gp *g) {\n \t// Implementation for platforms that do not support\n \t// integrated network poller.\n-\tUSED(block);\n-\treturn nil;\n+\treturn\n }\n \n-void\n-runtime_netpoll_scan(struct Workbuf** wbufp, void (*enqueue1)(struct Workbuf**, Obj))\n-{\n-\tUSED(wbufp);\n-\tUSED(addroot);\n+func netpollinited() bool {\n+\treturn false\n }", "previous_filename": "libgo/runtime/netpoll_stub.c"}, {"sha": "7ad115850d58fdc9a505fc7071852d6801aa93f0", "filename": "libgo/go/runtime/netpoll_windows.go", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/812ba636c7b12f2c503e34aaf9e2da50d5777b82/libgo%2Fgo%2Fruntime%2Fnetpoll_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/812ba636c7b12f2c503e34aaf9e2da50d5777b82/libgo%2Fgo%2Fruntime%2Fnetpoll_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fnetpoll_windows.go?ref=812ba636c7b12f2c503e34aaf9e2da50d5777b82", "patch": "@@ -0,0 +1,145 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package runtime\n+\n+import (\n+\t\"unsafe\"\n+)\n+\n+const _DWORD_MAX = 0xffffffff\n+\n+const _INVALID_HANDLE_VALUE = ^uintptr(0)\n+\n+// net_op must be the same as beginning of net.operation. Keep these in sync.\n+type net_op struct {\n+\t// used by windows\n+\to overlapped\n+\t// used by netpoll\n+\tpd    *pollDesc\n+\tmode  int32\n+\terrno int32\n+\tqty   uint32\n+}\n+\n+type overlappedEntry struct {\n+\tkey      uintptr\n+\top       *net_op // In reality it's *overlapped, but we cast it to *net_op anyway.\n+\tinternal uintptr\n+\tqty      uint32\n+}\n+\n+var iocphandle uintptr = _INVALID_HANDLE_VALUE // completion port io handle\n+\n+func netpollinit() {\n+\tiocphandle = stdcall4(_CreateIoCompletionPort, _INVALID_HANDLE_VALUE, 0, 0, _DWORD_MAX)\n+\tif iocphandle == 0 {\n+\t\tprintln(\"netpoll: failed to create iocp handle (errno=\", getlasterror(), \")\")\n+\t\tthrow(\"netpoll: failed to create iocp handle\")\n+\t}\n+}\n+\n+func netpollopen(fd uintptr, pd *pollDesc) int32 {\n+\tif stdcall4(_CreateIoCompletionPort, fd, iocphandle, 0, 0) == 0 {\n+\t\treturn -int32(getlasterror())\n+\t}\n+\treturn 0\n+}\n+\n+func netpollclose(fd uintptr) int32 {\n+\t// nothing to do\n+\treturn 0\n+}\n+\n+func netpollarm(pd *pollDesc, mode int) {\n+\tthrow(\"unused\")\n+}\n+\n+// Polls for completed network IO.\n+// Returns list of goroutines that become runnable.\n+func netpoll(block bool) *g {\n+\tvar entries [64]overlappedEntry\n+\tvar wait, qty, key, flags, n, i uint32\n+\tvar errno int32\n+\tvar op *net_op\n+\tvar gp guintptr\n+\n+\tmp := getg().m\n+\n+\tif iocphandle == _INVALID_HANDLE_VALUE {\n+\t\treturn nil\n+\t}\n+\twait = 0\n+\tif block {\n+\t\twait = _INFINITE\n+\t}\n+retry:\n+\tif _GetQueuedCompletionStatusEx != nil {\n+\t\tn = uint32(len(entries) / int(gomaxprocs))\n+\t\tif n < 8 {\n+\t\t\tn = 8\n+\t\t}\n+\t\tif block {\n+\t\t\tmp.blocked = true\n+\t\t}\n+\t\tif stdcall6(_GetQueuedCompletionStatusEx, iocphandle, uintptr(unsafe.Pointer(&entries[0])), uintptr(n), uintptr(unsafe.Pointer(&n)), uintptr(wait), 0) == 0 {\n+\t\t\tmp.blocked = false\n+\t\t\terrno = int32(getlasterror())\n+\t\t\tif !block && errno == _WAIT_TIMEOUT {\n+\t\t\t\treturn nil\n+\t\t\t}\n+\t\t\tprintln(\"netpoll: GetQueuedCompletionStatusEx failed (errno=\", errno, \")\")\n+\t\t\tthrow(\"netpoll: GetQueuedCompletionStatusEx failed\")\n+\t\t}\n+\t\tmp.blocked = false\n+\t\tfor i = 0; i < n; i++ {\n+\t\t\top = entries[i].op\n+\t\t\terrno = 0\n+\t\t\tqty = 0\n+\t\t\tif stdcall5(_WSAGetOverlappedResult, op.pd.fd, uintptr(unsafe.Pointer(op)), uintptr(unsafe.Pointer(&qty)), 0, uintptr(unsafe.Pointer(&flags))) == 0 {\n+\t\t\t\terrno = int32(getlasterror())\n+\t\t\t}\n+\t\t\thandlecompletion(&gp, op, errno, qty)\n+\t\t}\n+\t} else {\n+\t\top = nil\n+\t\terrno = 0\n+\t\tqty = 0\n+\t\tif block {\n+\t\t\tmp.blocked = true\n+\t\t}\n+\t\tif stdcall5(_GetQueuedCompletionStatus, iocphandle, uintptr(unsafe.Pointer(&qty)), uintptr(unsafe.Pointer(&key)), uintptr(unsafe.Pointer(&op)), uintptr(wait)) == 0 {\n+\t\t\tmp.blocked = false\n+\t\t\terrno = int32(getlasterror())\n+\t\t\tif !block && errno == _WAIT_TIMEOUT {\n+\t\t\t\treturn nil\n+\t\t\t}\n+\t\t\tif op == nil {\n+\t\t\t\tprintln(\"netpoll: GetQueuedCompletionStatus failed (errno=\", errno, \")\")\n+\t\t\t\tthrow(\"netpoll: GetQueuedCompletionStatus failed\")\n+\t\t\t}\n+\t\t\t// dequeued failed IO packet, so report that\n+\t\t}\n+\t\tmp.blocked = false\n+\t\thandlecompletion(&gp, op, errno, qty)\n+\t}\n+\tif block && gp == 0 {\n+\t\tgoto retry\n+\t}\n+\treturn gp.ptr()\n+}\n+\n+func handlecompletion(gpp *guintptr, op *net_op, errno int32, qty uint32) {\n+\tif op == nil {\n+\t\tthrow(\"netpoll: GetQueuedCompletionStatus returned op == nil\")\n+\t}\n+\tmode := op.mode\n+\tif mode != 'r' && mode != 'w' {\n+\t\tprintln(\"netpoll: GetQueuedCompletionStatus returned invalid mode=\", mode)\n+\t\tthrow(\"netpoll: GetQueuedCompletionStatus returned invalid mode\")\n+\t}\n+\top.errno = errno\n+\top.qty = qty\n+\tnetpollready(gpp, op.pd, mode)\n+}"}, {"sha": "083710d0b15aff8af390331c342de366c01eb07b", "filename": "libgo/go/runtime/stubs.go", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/812ba636c7b12f2c503e34aaf9e2da50d5777b82/libgo%2Fgo%2Fruntime%2Fstubs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/812ba636c7b12f2c503e34aaf9e2da50d5777b82/libgo%2Fgo%2Fruntime%2Fstubs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fstubs.go?ref=812ba636c7b12f2c503e34aaf9e2da50d5777b82", "patch": "@@ -296,7 +296,7 @@ func casp(ptr *unsafe.Pointer, old, new unsafe.Pointer) bool {\n func lock(l *mutex)\n func unlock(l *mutex)\n \n-// Here for gccgo for Solaris.\n+// Here for gccgo for netpoll and Solaris.\n func errno() int\n \n // Temporary for gccgo until we port proc.go.\n@@ -460,3 +460,9 @@ func setmaxthreads(int) int\n func setMaxThreads(in int) (out int) {\n \treturn setmaxthreads(in)\n }\n+\n+// Temporary for gccgo until we port atomic_pointer.go.\n+//go:nosplit\n+func atomicstorep(ptr unsafe.Pointer, new unsafe.Pointer) {\n+\tatomic.StorepNoWB(noescape(ptr), new)\n+}"}, {"sha": "8df185dc8fd6056d2c9986fdbbcb5d6bbab5e01e", "filename": "libgo/go/runtime/time.go", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/812ba636c7b12f2c503e34aaf9e2da50d5777b82/libgo%2Fgo%2Fruntime%2Ftime.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/812ba636c7b12f2c503e34aaf9e2da50d5777b82/libgo%2Fgo%2Fruntime%2Ftime.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Ftime.go?ref=812ba636c7b12f2c503e34aaf9e2da50d5777b82", "patch": "@@ -8,10 +8,6 @@ package runtime\n \n import \"unsafe\"\n \n-// Export temporarily for gccgo's C code to call:\n-//go:linkname addtimer runtime.addtimer\n-//go:linkname deltimer runtime.deltimer\n-\n // Package time knows the layout of this structure.\n // If this struct changes, adjust ../time/sleep.go:/runtimeTimer.\n // For GOOS=nacl, package syscall knows the layout of this structure."}, {"sha": "d05e5ecaffb6630a354891c6cf19aee8f274d3f0", "filename": "libgo/mkrsysinfo.sh", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/812ba636c7b12f2c503e34aaf9e2da50d5777b82/libgo%2Fmkrsysinfo.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/812ba636c7b12f2c503e34aaf9e2da50d5777b82/libgo%2Fmkrsysinfo.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmkrsysinfo.sh?ref=812ba636c7b12f2c503e34aaf9e2da50d5777b82", "patch": "@@ -64,6 +64,27 @@ echo \"func (ts *timespec) set_nsec(x int32) {\" >> ${OUT}\n echo \"\tts.tv_nsec = timespec_nsec_t(x)\" >> ${OUT}\n echo \"}\" >> ${OUT}\n \n+# Define the epollevent struct.  This needs special attention because\n+# the C definition uses a union and is sometimes packed.\n+if grep '^const _epoll_data_offset ' ${OUT} >/dev/null 2>&1; then\n+  val=`grep '^const _epoll_data_offset ' ${OUT} | sed -e 's/const _epoll_data_offset = \\(.*\\)$/\\1/'`\n+  if test \"$val\" = \"4\"; then\n+      echo 'type epollevent struct { events uint32; data [8]byte }' >> ${OUT}\n+  elif test \"$val\" = \"8\"; then\n+      echo 'type epollevent struct { events uint32; pad [4]byte; data [8]byte }' >> ${OUT}\n+  else\n+      echo 1>&2 \"unknown epoll data offset value ${val}\"\n+      exit 1\n+  fi\n+fi\n+# Make sure EPOLLRDHUP and EPOLL_CLOEXEC are defined.\n+if ! grep '^const _EPOLLRDHUP' ${OUT} >/dev/null 2>&1; then\n+  echo \"const _EPOLLRDHUP = 0x2000\" >> ${OUT}\n+fi\n+if ! grep '^const _EPOLL_CLOEXEC' ${OUT} >/dev/null 2>&1; then\n+  echo \"const _EPOLL_CLOEXEC = 02000000\" >> ${OUT}\n+fi\n+\n # The semt structure, for Solaris.\n grep '^type _sem_t ' gen-sysinfo.go | \\\n     sed -e 's/_sem_t/semt/' >> ${OUT}\n@@ -101,3 +122,14 @@ grep '^type _mac_ipaddr_t ' gen-sysinfo.go | \\\n grep '^type _mactun_info_t ' gen-sysinfo.go | \\\n     sed -e 's/_in6_addr_t/[16]byte/g' \\\n     >> ${OUT}\n+\n+# The Solaris port_event_t struct.\n+grep '^type _port_event_t ' gen-sysinfo.go | \\\n+    sed -e s'/_port_event_t/portevent/' \\\n+    >> ${OUT}\n+\n+# The *BSD kevent struct.\n+grep '^type _kevent ' gen-sysinfo.go | \\\n+    sed -e s'/_kevent/keventt/' \\\n+      -e 's/ udata [^;}]*/ udata *byte/' \\\n+    >> ${OUT}"}, {"sha": "f033aa6efdabf3830c7c8bd9616c12e71c6c13c0", "filename": "libgo/runtime/malloc.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/812ba636c7b12f2c503e34aaf9e2da50d5777b82/libgo%2Fruntime%2Fmalloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/812ba636c7b12f2c503e34aaf9e2da50d5777b82/libgo%2Fruntime%2Fmalloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmalloc.h?ref=812ba636c7b12f2c503e34aaf9e2da50d5777b82", "patch": "@@ -544,4 +544,3 @@ int32\truntime_setgcpercent(int32)\n \n struct Workbuf;\n void\truntime_proc_scan(struct Workbuf**, void (*)(struct Workbuf**, Obj));\n-void\truntime_netpoll_scan(struct Workbuf**, void (*)(struct Workbuf**, Obj));"}, {"sha": "cd3c55244b56632051eb875eb724c903f53cefe6", "filename": "libgo/runtime/mgc0.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/812ba636c7b12f2c503e34aaf9e2da50d5777b82/libgo%2Fruntime%2Fmgc0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/812ba636c7b12f2c503e34aaf9e2da50d5777b82/libgo%2Fruntime%2Fmgc0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmgc0.c?ref=812ba636c7b12f2c503e34aaf9e2da50d5777b82", "patch": "@@ -1277,7 +1277,6 @@ markroot(ParFor *desc, uint32 i)\n \t\tenqueue1(&wbuf, (Obj){(byte*)&runtime_allp, sizeof runtime_allp, 0});\n \t\tenqueue1(&wbuf, (Obj){(byte*)&work, sizeof work, 0});\n \t\truntime_proc_scan(&wbuf, enqueue1);\n-\t\truntime_netpoll_scan(&wbuf, enqueue1);\n \t\tbreak;\n \n \tcase RootFinalizers:"}, {"sha": "9467c02bc52caca6ffe84ed8605cf770240146b6", "filename": "libgo/runtime/netpoll.goc", "status": "removed", "additions": 0, "deletions": 467, "changes": 467, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5de494c59532fdad30097af4185b2ce74700984/libgo%2Fruntime%2Fnetpoll.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5de494c59532fdad30097af4185b2ce74700984/libgo%2Fruntime%2Fnetpoll.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fnetpoll.goc?ref=f5de494c59532fdad30097af4185b2ce74700984", "patch": "@@ -1,467 +0,0 @@\n-// Copyright 2013 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build darwin dragonfly freebsd linux nacl netbsd openbsd solaris windows\n-\n-package net\n-\n-#include \"runtime.h\"\n-#include \"defs.h\"\n-#include \"arch.h\"\n-#include \"malloc.h\"\n-\n-// Map gccgo field names to gc field names.\n-// Eface aka __go_empty_interface.\n-#define type __type_descriptor\n-#define data __object\n-\n-// Integrated network poller (platform-independent part).\n-// A particular implementation (epoll/kqueue) must define the following functions:\n-// void runtime_netpollinit(void);\t\t\t// to initialize the poller\n-// int32 runtime_netpollopen(uintptr fd, PollDesc *pd);\t// to arm edge-triggered notifications\n-\t\t\t\t\t\t\t// and associate fd with pd.\n-// An implementation must call the following function to denote that the pd is ready.\n-// void runtime_netpollready(G **gpp, PollDesc *pd, int32 mode);\n-\n-// PollDesc contains 2 binary semaphores, rg and wg, to park reader and writer\n-// goroutines respectively. The semaphore can be in the following states:\n-// READY - io readiness notification is pending;\n-//         a goroutine consumes the notification by changing the state to nil.\n-// WAIT - a goroutine prepares to park on the semaphore, but not yet parked;\n-//        the goroutine commits to park by changing the state to G pointer,\n-//        or, alternatively, concurrent io notification changes the state to READY,\n-//        or, alternatively, concurrent timeout/close changes the state to nil.\n-// G pointer - the goroutine is blocked on the semaphore;\n-//             io notification or timeout/close changes the state to READY or nil respectively\n-//             and unparks the goroutine.\n-// nil - nothing of the above.\n-#define READY ((G*)1)\n-#define WAIT  ((G*)2)\n-\n-enum\n-{\n-\tPollBlockSize\t= 4*1024,\n-};\n-\n-struct PollDesc\n-{\n-\tPollDesc* link;\t// in pollcache, protected by pollcache.Lock\n-\n-\t// The lock protects pollOpen, pollSetDeadline, pollUnblock and deadlineimpl operations.\n-\t// This fully covers seq, rt and wt variables. fd is constant throughout the PollDesc lifetime.\n-\t// pollReset, pollWait, pollWaitCanceled and runtime_netpollready (IO rediness notification)\n-\t// proceed w/o taking the lock. So closing, rg, rd, wg and wd are manipulated\n-\t// in a lock-free way by all operations.\n-\tLock;\t\t// protectes the following fields\n-\tuintptr\tfd;\n-\tbool\tclosing;\n-\tuintptr\tseq;\t// protects from stale timers and ready notifications\n-\tG*\trg;\t// READY, WAIT, G waiting for read or nil\n-\tTimer\trt;\t// read deadline timer (set if rt.fv != nil)\n-\tint64\trd;\t// read deadline\n-\tG*\twg;\t// READY, WAIT, G waiting for write or nil\n-\tTimer\twt;\t// write deadline timer\n-\tint64\twd;\t// write deadline\n-\tvoid*\tuser;\t// user settable cookie\n-};\n-\n-static struct\n-{\n-\tLock;\n-\tPollDesc*\tfirst;\n-\t// PollDesc objects must be type-stable,\n-\t// because we can get ready notification from epoll/kqueue\n-\t// after the descriptor is closed/reused.\n-\t// Stale notifications are detected using seq variable,\n-\t// seq is incremented when deadlines are changed or descriptor is reused.\n-} pollcache;\n-\n-static bool\tnetpollblock(PollDesc*, int32, bool);\n-static G*\tnetpollunblock(PollDesc*, int32, bool);\n-static void\tdeadline(Eface, uintptr);\n-static void\treadDeadline(Eface, uintptr);\n-static void\twriteDeadline(Eface, uintptr);\n-static PollDesc*\tallocPollDesc(void);\n-static intgo\tcheckerr(PollDesc *pd, int32 mode);\n-\n-static FuncVal deadlineFn\t= {(void(*)(void))deadline};\n-static FuncVal readDeadlineFn\t= {(void(*)(void))readDeadline};\n-static FuncVal writeDeadlineFn\t= {(void(*)(void))writeDeadline};\n-\n-func runtime_pollServerInit() {\n-\truntime_netpollinit();\n-}\n-\n-func runtime_pollOpen(fd uintptr) (pd *PollDesc, errno int) {\n-\tpd = allocPollDesc();\n-\truntime_lock(pd);\n-\tif(pd->wg != nil && pd->wg != READY)\n-\t\truntime_throw(\"runtime_pollOpen: blocked write on free descriptor\");\n-\tif(pd->rg != nil && pd->rg != READY)\n-\t\truntime_throw(\"runtime_pollOpen: blocked read on free descriptor\");\n-\tpd->fd = fd;\n-\tpd->closing = false;\n-\tpd->seq++;\n-\tpd->rg = nil;\n-\tpd->rd = 0;\n-\tpd->wg = nil;\n-\tpd->wd = 0;\n-\truntime_unlock(pd);\n-\n-\terrno = runtime_netpollopen(fd, pd);\n-}\n-\n-func runtime_pollClose(pd *PollDesc) {\n-\tif(!pd->closing)\n-\t\truntime_throw(\"runtime_pollClose: close w/o unblock\");\n-\tif(pd->wg != nil && pd->wg != READY)\n-\t\truntime_throw(\"runtime_pollClose: blocked write on closing descriptor\");\n-\tif(pd->rg != nil && pd->rg != READY)\n-\t\truntime_throw(\"runtime_pollClose: blocked read on closing descriptor\");\n-\truntime_netpollclose(pd->fd);\n-\truntime_lock(&pollcache);\n-\tpd->link = pollcache.first;\n-\tpollcache.first = pd;\n-\truntime_unlock(&pollcache);\n-}\n-\n-func runtime_pollReset(pd *PollDesc, mode int) (err int) {\n-\terr = checkerr(pd, mode);\n-\tif(err)\n-\t\tgoto ret;\n-\tif(mode == 'r')\n-\t\tpd->rg = nil;\n-\telse if(mode == 'w')\n-\t\tpd->wg = nil;\n-ret:\n-}\n-\n-func runtime_pollWait(pd *PollDesc, mode int) (err int) {\n-\terr = checkerr(pd, mode);\n-\tif(err == 0) {\n-\t\t// As for now only Solaris uses level-triggered IO.\n-\t\tif(Solaris)\n-\t\t\truntime_netpollarm(pd, mode);\n-\t\twhile(!netpollblock(pd, mode, false)) {\n-\t\t\terr = checkerr(pd, mode);\n-\t\t\tif(err != 0)\n-\t\t\t\tbreak;\n-\t\t\t// Can happen if timeout has fired and unblocked us,\n-\t\t\t// but before we had a chance to run, timeout has been reset.\n-\t\t\t// Pretend it has not happened and retry.\n-\t\t}\n-\t}\n-}\n-\n-func runtime_pollWaitCanceled(pd *PollDesc, mode int) {\n-\t// This function is used only on windows after a failed attempt to cancel\n-\t// a pending async IO operation. Wait for ioready, ignore closing or timeouts.\n-\twhile(!netpollblock(pd, mode, true))\n-\t\t;\n-}\n-\n-func runtime_pollSetDeadline(pd *PollDesc, d int64, mode int) {\n-\tG *rg, *wg;\n-\n-\truntime_lock(pd);\n-\tif(pd->closing) {\n-\t\truntime_unlock(pd);\n-\t\treturn;\n-\t}\n-\tpd->seq++;  // invalidate current timers\n-\t// Reset current timers.\n-\tif(pd->rt.f) {\n-\t\truntime_deltimer(&pd->rt);\n-\t\tpd->rt.f = nil;\n-\t}\n-\tif(pd->wt.f) {\n-\t\truntime_deltimer(&pd->wt);\n-\t\tpd->wt.f = nil;\n-\t}\n-\t// Setup new timers.\n-\tif(d != 0 && d <= runtime_nanotime())\n-\t\td = -1;\n-\tif(mode == 'r' || mode == 'r'+'w')\n-\t\tpd->rd = d;\n-\tif(mode == 'w' || mode == 'r'+'w')\n-\t\tpd->wd = d;\n-\tif(pd->rd > 0 && pd->rd == pd->wd) {\n-\t\tpd->rt.f = &deadlineFn;\n-\t\tpd->rt.when = pd->rd;\n-\t\t// Copy current seq into the timer arg.\n-\t\t// Timer func will check the seq against current descriptor seq,\n-\t\t// if they differ the descriptor was reused or timers were reset.\n-\t\tpd->rt.arg.type = nil; // should be *pollDesc type descriptor.\n-\t\tpd->rt.arg.data = pd;\n-\t\tpd->rt.seq = pd->seq;\n-\t\truntime_addtimer(&pd->rt);\n-\t} else {\n-\t\tif(pd->rd > 0) {\n-\t\t\tpd->rt.f = &readDeadlineFn;\n-\t\t\tpd->rt.when = pd->rd;\n-\t\t\tpd->rt.arg.type = nil; // should be *pollDesc type descriptor.\n-\t\t\tpd->rt.arg.data = pd;\n-\t\t\tpd->rt.seq = pd->seq;\n-\t\t\truntime_addtimer(&pd->rt);\n-\t\t}\n-\t\tif(pd->wd > 0) {\n-\t\t\tpd->wt.f = &writeDeadlineFn;\n-\t\t\tpd->wt.when = pd->wd;\n-\t\t\tpd->wt.arg.type = nil; // should be *pollDesc type descriptor.\n-\t\t\tpd->wt.arg.data = pd;\n-\t\t\tpd->wt.seq = pd->seq;\n-\t\t\truntime_addtimer(&pd->wt);\n-\t\t}\n-\t}\n-\t// If we set the new deadline in the past, unblock currently pending IO if any.\n-\trg = nil;\n-\truntime_atomicstorep(&wg, nil);  // full memory barrier between stores to rd/wd and load of rg/wg in netpollunblock\n-\tif(pd->rd < 0)\n-\t\trg = netpollunblock(pd, 'r', false);\n-\tif(pd->wd < 0)\n-\t\twg = netpollunblock(pd, 'w', false);\n-\truntime_unlock(pd);\n-\tif(rg)\n-\t\truntime_ready(rg);\n-\tif(wg)\n-\t\truntime_ready(wg);\n-}\n-\n-func runtime_pollUnblock(pd *PollDesc) {\n-\tG *rg, *wg;\n-\n-\truntime_lock(pd);\n-\tif(pd->closing)\n-\t\truntime_throw(\"runtime_pollUnblock: already closing\");\n-\tpd->closing = true;\n-\tpd->seq++;\n-\truntime_atomicstorep(&rg, nil);  // full memory barrier between store to closing and read of rg/wg in netpollunblock\n-\trg = netpollunblock(pd, 'r', false);\n-\twg = netpollunblock(pd, 'w', false);\n-\tif(pd->rt.f) {\n-\t\truntime_deltimer(&pd->rt);\n-\t\tpd->rt.f = nil;\n-\t}\n-\tif(pd->wt.f) {\n-\t\truntime_deltimer(&pd->wt);\n-\t\tpd->wt.f = nil;\n-\t}\n-\truntime_unlock(pd);\n-\tif(rg)\n-\t\truntime_ready(rg);\n-\tif(wg)\n-\t\truntime_ready(wg);\n-}\n-\n-uintptr\n-runtime_netpollfd(PollDesc *pd)\n-{\n-\treturn pd->fd;\n-}\n-\n-void**\n-runtime_netpolluser(PollDesc *pd)\n-{\n-\treturn &pd->user;\n-}\n-\n-bool\n-runtime_netpollclosing(PollDesc *pd)\n-{\n-\treturn pd->closing;\n-}\n-\n-void\n-runtime_netpolllock(PollDesc *pd)\n-{\n-\truntime_lock(pd);\n-}\n-\n-void\n-runtime_netpollunlock(PollDesc *pd)\n-{\n-\truntime_unlock(pd);\n-}\n-\n-// make pd ready, newly runnable goroutines (if any) are enqueued info gpp list\n-void\n-runtime_netpollready(G **gpp, PollDesc *pd, int32 mode)\n-{\n-\tG *rg, *wg;\n-\n-\trg = wg = nil;\n-\tif(mode == 'r' || mode == 'r'+'w')\n-\t\trg = netpollunblock(pd, 'r', true);\n-\tif(mode == 'w' || mode == 'r'+'w')\n-\t\twg = netpollunblock(pd, 'w', true);\n-\tif(rg) {\n-\t\trg->schedlink = (uintptr)*gpp;\n-\t\t*gpp = rg;\n-\t}\n-\tif(wg) {\n-\t\twg->schedlink = (uintptr)*gpp;\n-\t\t*gpp = wg;\n-\t}\n-}\n-\n-static intgo\n-checkerr(PollDesc *pd, int32 mode)\n-{\n-\tif(pd->closing)\n-\t\treturn 1;  // errClosing\n-\tif((mode == 'r' && pd->rd < 0) || (mode == 'w' && pd->wd < 0))\n-\t\treturn 2;  // errTimeout\n-\treturn 0;\n-}\n-\n-static bool\n-blockcommit(G *gp, G **gpp)\n-{\n-\treturn runtime_casp(gpp, WAIT, gp);\n-}\n-\n-// returns true if IO is ready, or false if timedout or closed\n-// waitio - wait only for completed IO, ignore errors\n-static bool\n-netpollblock(PollDesc *pd, int32 mode, bool waitio)\n-{\n-\tG **gpp, *old;\n-\n-\tgpp = &pd->rg;\n-\tif(mode == 'w')\n-\t\tgpp = &pd->wg;\n-\n-\t// set the gpp semaphore to WAIT\n-\tfor(;;) {\n-\t\told = *gpp;\n-\t\tif(old == READY) {\n-\t\t\t*gpp = nil;\n-\t\t\treturn true;\n-\t\t}\n-\t\tif(old != nil)\n-\t\t\truntime_throw(\"netpollblock: double wait\");\n-\t\tif(runtime_casp(gpp, nil, WAIT))\n-\t\t\tbreak;\n-\t}\n-\n-\t// need to recheck error states after setting gpp to WAIT\n-\t// this is necessary because runtime_pollUnblock/runtime_pollSetDeadline/deadlineimpl\n-\t// do the opposite: store to closing/rd/wd, membarrier, load of rg/wg\n-\tif(waitio || checkerr(pd, mode) == 0)\n-\t\truntime_park((bool(*)(G*, void*))blockcommit, gpp, \"IO wait\");\n-\t// be careful to not lose concurrent READY notification\n-\told = runtime_xchgp(gpp, nil);\n-\tif(old > WAIT)\n-\t\truntime_throw(\"netpollblock: corrupted state\");\n-\treturn old == READY;\n-}\n-\n-static G*\n-netpollunblock(PollDesc *pd, int32 mode, bool ioready)\n-{\n-\tG **gpp, *old, *new;\n-\n-\tgpp = &pd->rg;\n-\tif(mode == 'w')\n-\t\tgpp = &pd->wg;\n-\n-\tfor(;;) {\n-\t\told = *gpp;\n-\t\tif(old == READY)\n-\t\t\treturn nil;\n-\t\tif(old == nil && !ioready) {\n-\t\t\t// Only set READY for ioready. runtime_pollWait\n-\t\t\t// will check for timeout/cancel before waiting.\n-\t\t\treturn nil;\n-\t\t}\n-\t\tnew = nil;\n-\t\tif(ioready)\n-\t\t\tnew = READY;\n-\t\tif(runtime_casp(gpp, old, new))\n-\t\t\tbreak;\n-\t}\n-\tif(old > WAIT)\n-\t\treturn old;  // must be G*\n-\treturn nil;\n-}\n-\n-static void\n-deadlineimpl(Eface arg, uintptr seq, bool read, bool write)\n-{\n-\tPollDesc *pd;\n-\tG *rg, *wg;\n-\n-\tpd = (PollDesc*)arg.data;\n-\trg = wg = nil;\n-\truntime_lock(pd);\n-\t// Seq arg is seq when the timer was set.\n-\t// If it's stale, ignore the timer event.\n-\tif(seq != pd->seq) {\n-\t\t// The descriptor was reused or timers were reset.\n-\t\truntime_unlock(pd);\n-\t\treturn;\n-\t}\n-\tif(read) {\n-\t\tif(pd->rd <= 0 || pd->rt.f == nil)\n-\t\t\truntime_throw(\"deadlineimpl: inconsistent read deadline\");\n-\t\tpd->rd = -1;\n-\t\truntime_atomicstorep(&pd->rt.f, nil);  // full memory barrier between store to rd and load of rg in netpollunblock\n-\t\trg = netpollunblock(pd, 'r', false);\n-\t}\n-\tif(write) {\n-\t\tif(pd->wd <= 0 || (pd->wt.f == nil && !read))\n-\t\t\truntime_throw(\"deadlineimpl: inconsistent write deadline\");\n-\t\tpd->wd = -1;\n-\t\truntime_atomicstorep(&pd->wt.f, nil);  // full memory barrier between store to wd and load of wg in netpollunblock\n-\t\twg = netpollunblock(pd, 'w', false);\n-\t}\n-\truntime_unlock(pd);\n-\tif(rg)\n-\t\truntime_ready(rg);\n-\tif(wg)\n-\t\truntime_ready(wg);\n-}\n-\n-static void\n-deadline(Eface arg, uintptr seq)\n-{\n-\tdeadlineimpl(arg, seq, true, true);\n-}\n-\n-static void\n-readDeadline(Eface arg, uintptr seq)\n-{\n-\tdeadlineimpl(arg, seq, true, false);\n-}\n-\n-static void\n-writeDeadline(Eface arg, uintptr seq)\n-{\n-\tdeadlineimpl(arg, seq, false, true);\n-}\n-\n-static PollDesc*\n-allocPollDesc(void)\n-{\n-\tPollDesc *pd;\n-\tuint32 i, n;\n-\n-\truntime_lock(&pollcache);\n-\tif(pollcache.first == nil) {\n-\t\tn = PollBlockSize/sizeof(*pd);\n-\t\tif(n == 0)\n-\t\t\tn = 1;\n-\t\t// Must be in non-GC memory because can be referenced\n-\t\t// only from epoll/kqueue internals.\n-\t\tpd = runtime_persistentalloc(n*sizeof(*pd), 0, &mstats()->other_sys);\n-\t\tfor(i = 0; i < n; i++) {\n-\t\t\tpd[i].link = pollcache.first;\n-\t\t\tpollcache.first = &pd[i];\n-\t\t}\n-\t}\n-\tpd = pollcache.first;\n-\tpollcache.first = pd->link;\n-\truntime_unlock(&pollcache);\n-\treturn pd;\n-}"}, {"sha": "1281f45b085bbc4a36c744f6ff9af543ae58af58", "filename": "libgo/runtime/netpoll_epoll.c", "status": "removed", "additions": 0, "deletions": 174, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5de494c59532fdad30097af4185b2ce74700984/libgo%2Fruntime%2Fnetpoll_epoll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5de494c59532fdad30097af4185b2ce74700984/libgo%2Fruntime%2Fnetpoll_epoll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fnetpoll_epoll.c?ref=f5de494c59532fdad30097af4185b2ce74700984", "patch": "@@ -1,174 +0,0 @@\n-// Copyright 2013 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build linux\n-\n-#include <errno.h>\n-#include <unistd.h>\n-#include <fcntl.h>\n-#include <sys/epoll.h>\n-\n-#include \"runtime.h\"\n-#include \"defs.h\"\n-#include \"malloc.h\"\n-\n-#ifndef EPOLLRDHUP\n-#define EPOLLRDHUP 0x2000\n-#endif\n-\n-#ifndef EPOLL_CLOEXEC\n-#define EPOLL_CLOEXEC 02000000\n-#endif\n-\n-#ifndef HAVE_EPOLL_CREATE1\n-extern int epoll_create1(int __flags);\n-#endif\n-\n-typedef struct epoll_event EpollEvent;\n-\n-static int32\n-runtime_epollcreate(int32 size)\n-{\n-\tint r;\n-\n-\tr = epoll_create(size);\n-\tif(r >= 0)\n-\t\treturn r;\n-\treturn - errno;\n-}\n-\n-static int32\n-runtime_epollcreate1(int32 flags)\n-{\n-\tint r;\n-\n-\tr = epoll_create1(flags);\n-\tif(r >= 0)\n-\t\treturn r;\n-\treturn - errno;\n-}\n-\n-static int32\n-runtime_epollctl(int32 epfd, int32 op, int32 fd, EpollEvent *ev)\n-{\n-\tint r;\n-\n-\tr = epoll_ctl(epfd, op, fd, ev);\n-\tif(r >= 0)\n-\t\treturn r;\n-\treturn - errno;\n-}\n-\n-static int32\n-runtime_epollwait(int32 epfd, EpollEvent *ev, int32 nev, int32 timeout)\n-{\n-\tint r;\n-\n-\tr = epoll_wait(epfd, ev, nev, timeout);\n-\tif(r >= 0)\n-\t\treturn r;\n-\treturn - errno;\n-}\n-\n-static void\n-runtime_closeonexec(int32 fd)\n-{\n-\tfcntl(fd, F_SETFD, FD_CLOEXEC);\n-}\n-\n-static int32 epfd = -1;  // epoll descriptor\n-\n-void\n-runtime_netpollinit(void)\n-{\n-\tepfd = runtime_epollcreate1(EPOLL_CLOEXEC);\n-\tif(epfd >= 0)\n-\t\treturn;\n-\tepfd = runtime_epollcreate(1024);\n-\tif(epfd >= 0) {\n-\t\truntime_closeonexec(epfd);\n-\t\treturn;\n-\t}\n-\truntime_printf(\"netpollinit: failed to create descriptor (%d)\\n\", -epfd);\n-\truntime_throw(\"netpollinit: failed to create descriptor\");\n-}\n-\n-int32\n-runtime_netpollopen(uintptr fd, PollDesc *pd)\n-{\n-\tEpollEvent ev;\n-\tint32 res;\n-\n-\tev.events = EPOLLIN|EPOLLOUT|EPOLLRDHUP|EPOLLET;\n-\tev.data.ptr = (void*)pd;\n-\tres = runtime_epollctl(epfd, EPOLL_CTL_ADD, (int32)fd, &ev);\n-\treturn -res;\n-}\n-\n-int32\n-runtime_netpollclose(uintptr fd)\n-{\n-\tEpollEvent ev;\n-\tint32 res;\n-\n-\tres = runtime_epollctl(epfd, EPOLL_CTL_DEL, (int32)fd, &ev);\n-\treturn -res;\n-}\n-\n-void\n-runtime_netpollarm(PollDesc* pd, int32 mode)\n-{\n-\tUSED(pd);\n-\tUSED(mode);\n-\truntime_throw(\"unused\");\n-}\n-\n-// polls for ready network connections\n-// returns list of goroutines that become runnable\n-G*\n-runtime_netpoll(bool block)\n-{\n-\tstatic int32 lasterr;\n-\tEpollEvent events[128], *ev;\n-\tint32 n, i, waitms, mode;\n-\tG *gp;\n-\n-\tif(epfd == -1)\n-\t\treturn nil;\n-\twaitms = -1;\n-\tif(!block)\n-\t\twaitms = 0;\n-retry:\n-\tn = runtime_epollwait(epfd, events, nelem(events), waitms);\n-\tif(n < 0) {\n-\t\tif(n != -EINTR && n != lasterr) {\n-\t\t\tlasterr = n;\n-\t\t\truntime_printf(\"runtime: epollwait on fd %d failed with %d\\n\", epfd, -n);\n-\t\t}\n-\t\tgoto retry;\n-\t}\n-\tgp = nil;\n-\tfor(i = 0; i < n; i++) {\n-\t\tev = &events[i];\n-\t\tif(ev->events == 0)\n-\t\t\tcontinue;\n-\t\tmode = 0;\n-\t\tif(ev->events & (EPOLLIN|EPOLLRDHUP|EPOLLHUP|EPOLLERR))\n-\t\t\tmode += 'r';\n-\t\tif(ev->events & (EPOLLOUT|EPOLLHUP|EPOLLERR))\n-\t\t\tmode += 'w';\n-\t\tif(mode)\n-\t\t\truntime_netpollready(&gp, (void*)ev->data.ptr, mode);\n-\t}\n-\tif(block && gp == nil)\n-\t\tgoto retry;\n-\treturn gp;\n-}\n-\n-void\n-runtime_netpoll_scan(struct Workbuf** wbufp, void (*enqueue1)(struct Workbuf**, Obj))\n-{\n-\tUSED(wbufp);\n-\tUSED(enqueue1);\n-}"}, {"sha": "5144a870fb2c744f483a731cdc4a6983469c50b8", "filename": "libgo/runtime/netpoll_kqueue.c", "status": "removed", "additions": 0, "deletions": 118, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5de494c59532fdad30097af4185b2ce74700984/libgo%2Fruntime%2Fnetpoll_kqueue.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5de494c59532fdad30097af4185b2ce74700984/libgo%2Fruntime%2Fnetpoll_kqueue.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fnetpoll_kqueue.c?ref=f5de494c59532fdad30097af4185b2ce74700984", "patch": "@@ -1,118 +0,0 @@\n-// Copyright 2013 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build darwin dragonfly freebsd netbsd openbsd\n-\n-#include \"runtime.h\"\n-#include \"defs.h\"\n-#include \"malloc.h\"\n-\n-// Integrated network poller (kqueue-based implementation).\n-\n-int32\truntime_kqueue(void);\n-int32\truntime_kevent(int32, Kevent*, int32, Kevent*, int32, Timespec*);\n-void\truntime_closeonexec(int32);\n-\n-static int32 kq = -1;\n-\n-void\n-runtime_netpollinit(void)\n-{\n-\tkq = runtime_kqueue();\n-\tif(kq < 0) {\n-\t\truntime_printf(\"netpollinit: kqueue failed with %d\\n\", -kq);\n-\t\truntime_throw(\"netpollinit: kqueue failed\");\n-\t}\n-\truntime_closeonexec(kq);\n-}\n-\n-int32\n-runtime_netpollopen(uintptr fd, PollDesc *pd)\n-{\n-\tKevent ev[2];\n-\tint32 n;\n-\n-\t// Arm both EVFILT_READ and EVFILT_WRITE in edge-triggered mode (EV_CLEAR)\n-\t// for the whole fd lifetime.  The notifications are automatically unregistered\n-\t// when fd is closed.\n-\tev[0].ident = (uint32)fd;\n-\tev[0].filter = EVFILT_READ;\n-\tev[0].flags = EV_ADD|EV_CLEAR;\n-\tev[0].fflags = 0;\n-\tev[0].data = 0;\n-\tev[0].udata = (kevent_udata)pd;\n-\tev[1] = ev[0];\n-\tev[1].filter = EVFILT_WRITE;\n-\tn = runtime_kevent(kq, ev, 2, nil, 0, nil);\n-\tif(n < 0)\n-\t\treturn -n;\n-\treturn 0;\n-}\n-\n-int32\n-runtime_netpollclose(uintptr fd)\n-{\n-\t// Don't need to unregister because calling close()\n-\t// on fd will remove any kevents that reference the descriptor.\n-\tUSED(fd);\n-\treturn 0;\n-}\n-\n-void\n-runtime_netpollarm(PollDesc* pd, int32 mode)\n-{\n-\tUSED(pd, mode);\n-\truntime_throw(\"unused\");\n-}\n-\n-// Polls for ready network connections.\n-// Returns list of goroutines that become runnable.\n-G*\n-runtime_netpoll(bool block)\n-{\n-\tstatic int32 lasterr;\n-\tKevent events[64], *ev;\n-\tTimespec ts, *tp;\n-\tint32 n, i, mode;\n-\tG *gp;\n-\n-\tif(kq == -1)\n-\t\treturn nil;\n-\ttp = nil;\n-\tif(!block) {\n-\t\tts.tv_sec = 0;\n-\t\tts.tv_nsec = 0;\n-\t\ttp = &ts;\n-\t}\n-\tgp = nil;\n-retry:\n-\tn = runtime_kevent(kq, nil, 0, events, nelem(events), tp);\n-\tif(n < 0) {\n-\t\tif(n != -EINTR && n != lasterr) {\n-\t\t\tlasterr = n;\n-\t\t\truntime_printf(\"runtime: kevent on fd %d failed with %d\\n\", kq, -n);\n-\t\t}\n-\t\tgoto retry;\n-\t}\n-\tfor(i = 0; i < n; i++) {\n-\t\tev = &events[i];\n-\t\tmode = 0;\n-\t\tif(ev->filter == EVFILT_READ)\n-\t\t\tmode += 'r';\n-\t\tif(ev->filter == EVFILT_WRITE)\n-\t\t\tmode += 'w';\n-\t\tif(mode)\n-\t\t\truntime_netpollready(&gp, (PollDesc*)ev->udata, mode);\n-\t}\n-\tif(block && gp == nil)\n-\t\tgoto retry;\n-\treturn gp;\n-}\n-\n-void\n-runtime_netpoll_scan(struct Workbuf** wbufp, void (*enqueue1)(struct Workbuf**, Obj))\n-{\n-\tUSED(wbufp);\n-\tUSED(enqueue1);\n-}"}, {"sha": "b32a1d5af8932eb6bc2afe0f973659e6be373708", "filename": "libgo/runtime/netpoll_select.c", "status": "removed", "additions": 0, "deletions": 256, "changes": 256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5de494c59532fdad30097af4185b2ce74700984/libgo%2Fruntime%2Fnetpoll_select.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5de494c59532fdad30097af4185b2ce74700984/libgo%2Fruntime%2Fnetpoll_select.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fnetpoll_select.c?ref=f5de494c59532fdad30097af4185b2ce74700984", "patch": "@@ -1,256 +0,0 @@\n-// Copyright 2013 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build solaris\n-\n-#include \"config.h\"\n-\n-#include <errno.h>\n-#include <sys/times.h>\n-#include <sys/types.h>\n-#include <unistd.h>\n-#include <fcntl.h>\n-\n-#ifdef HAVE_SYS_SELECT_H\n-#include <sys/select.h>\n-#endif\n-\n-#include \"runtime.h\"\n-#include \"malloc.h\"\n-\n-static Lock selectlock;\n-static int rdwake;\n-static int wrwake;\n-static fd_set fds;\n-static PollDesc **data;\n-static int allocated;\n-\n-void\n-runtime_netpollinit(void)\n-{\n-\tint p[2];\n-\tint fl;\n-\n-\tFD_ZERO(&fds);\n-\tallocated = 128;\n-\tdata = runtime_mallocgc(allocated * sizeof(PollDesc *), 0,\n-\t\t\t\tFlagNoScan|FlagNoProfiling|FlagNoInvokeGC);\n-\n-\tif(pipe(p) < 0)\n-\t\truntime_throw(\"netpollinit: failed to create pipe\");\n-\trdwake = p[0];\n-\twrwake = p[1];\n-\n-\tfl = fcntl(rdwake, F_GETFL);\n-\tif(fl < 0)\n-\t\truntime_throw(\"netpollinit: fcntl failed\");\n-\tfl |= O_NONBLOCK;\n-\tif(fcntl(rdwake, F_SETFL, fl))\n-\t\t runtime_throw(\"netpollinit: fcntl failed\");\n-\tfcntl(rdwake, F_SETFD, FD_CLOEXEC);\n-\n-\tfl = fcntl(wrwake, F_GETFL);\n-\tif(fl < 0)\n-\t\truntime_throw(\"netpollinit: fcntl failed\");\n-\tfl |= O_NONBLOCK;\n-\tif(fcntl(wrwake, F_SETFL, fl))\n-\t\t runtime_throw(\"netpollinit: fcntl failed\");\n-\tfcntl(wrwake, F_SETFD, FD_CLOEXEC);\n-\n-\tFD_SET(rdwake, &fds);\n-}\n-\n-int32\n-runtime_netpollopen(uintptr fd, PollDesc *pd)\n-{\n-\tbyte b;\n-\n-\truntime_lock(&selectlock);\n-\n-\tif((int)fd >= allocated) {\n-\t\tint c;\n-\t\tPollDesc **n;\n-\n-\t\tc = allocated;\n-\n-\t\truntime_unlock(&selectlock);\n-\n-\t\twhile((int)fd >= c)\n-\t\t\tc *= 2;\n-\t\tn = runtime_mallocgc(c * sizeof(PollDesc *), 0,\n-\t\t\t\t     FlagNoScan|FlagNoProfiling|FlagNoInvokeGC);\n-\n-\t\truntime_lock(&selectlock);\n-\n-\t\tif(c > allocated) {\n-\t\t\t__builtin_memcpy(n, data, allocated * sizeof(PollDesc *));\n-\t\t\tallocated = c;\n-\t\t\tdata = n;\n-\t\t}\n-\t}\n-\tFD_SET(fd, &fds);\n-\tdata[fd] = pd;\n-\n-\truntime_unlock(&selectlock);\n-\n-\tb = 0;\n-\twrite(wrwake, &b, sizeof b);\n-\n-\treturn 0;\n-}\n-\n-int32\n-runtime_netpollclose(uintptr fd)\n-{\n-\tbyte b;\n-\n-\truntime_lock(&selectlock);\n-\n-\tFD_CLR(fd, &fds);\n-\tdata[fd] = nil;\n-\n-\truntime_unlock(&selectlock);\n-\n-\tb = 0;\n-\twrite(wrwake, &b, sizeof b);\n-\n-\treturn 0;\n-}\n-\n-/* Used to avoid using too much stack memory.  */\n-static bool inuse;\n-static fd_set grfds, gwfds, gefds, gtfds;\n-\n-G*\n-runtime_netpoll(bool block)\n-{\n-\tfd_set *prfds, *pwfds, *pefds, *ptfds;\n-\tbool allocatedfds;\n-\tstruct timeval timeout;\n-\tstruct timeval *pt;\n-\tint max, c, i;\n-\tG *gp;\n-\tint32 mode;\n-\tbyte b;\n-\tstruct stat st;\n-\n-\tallocatedfds = false;\n-\n- retry:\n-\truntime_lock(&selectlock);\n-\n-\tmax = allocated;\n-\n-\tif(max == 0) {\n-\t\truntime_unlock(&selectlock);\n-\t\treturn nil;\n-\t}\n-\n-\tif(inuse) {\n-\t\tif(!allocatedfds) {\n-\t\t\tprfds = runtime_SysAlloc(4 * sizeof fds, &mstats()->other_sys);\n-\t\t\tpwfds = prfds + 1;\n-\t\t\tpefds = pwfds + 1;\n-\t\t\tptfds = pefds + 1;\n-\t\t\tallocatedfds = true;\n-\t\t}\n-\t} else {\n-\t\tprfds = &grfds;\n-\t\tpwfds = &gwfds;\n-\t\tpefds = &gefds;\n-\t\tptfds = &gtfds;\n-\t\tinuse = true;\n-\t\tallocatedfds = false;\n-\t}\n-\n-\t__builtin_memcpy(prfds, &fds, sizeof fds);\n-\n-\truntime_unlock(&selectlock);\n-\n-\t__builtin_memcpy(pwfds, prfds, sizeof fds);\n-\tFD_CLR(rdwake, pwfds);\n-\t__builtin_memcpy(pefds, pwfds, sizeof fds);\n-\n-\t__builtin_memcpy(ptfds, pwfds, sizeof fds);\n-\n-\t__builtin_memset(&timeout, 0, sizeof timeout);\n-\tpt = &timeout;\n-\tif(block)\n-\t\tpt = nil;\n-\n-\tc = select(max, prfds, pwfds, pefds, pt);\n-\tif(c < 0) {\n-\t\tif(errno == EBADF) {\n-\t\t\t// Some file descriptor has been closed.\n-\t\t\t// Check each one, and treat each closed\n-\t\t\t// descriptor as ready for read/write.\n-\t\t\tc = 0;\n-\t\t\tFD_ZERO(prfds);\n-\t\t\tFD_ZERO(pwfds);\n-\t\t\tFD_ZERO(pefds);\n-\t\t\tfor(i = 0; i < max; i++) {\n-\t\t\t\tif(FD_ISSET(i, ptfds)\n-\t\t\t\t   && fstat(i, &st) < 0\n-\t\t\t\t   && errno == EBADF) {\n-\t\t\t\t\tFD_SET(i, prfds);\n-\t\t\t\t\tFD_SET(i, pwfds);\n-\t\t\t\t\tc += 2;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\telse {\n-\t\t\tif(errno != EINTR)\n-\t\t\t\truntime_printf(\"runtime: select failed with %d\\n\", errno);\n-\t\t\tgoto retry;\n-\t\t}\n-\t}\n-\tgp = nil;\n-\tfor(i = 0; i < max && c > 0; i++) {\n-\t\tmode = 0;\n-\t\tif(FD_ISSET(i, prfds)) {\n-\t\t\tmode += 'r';\n-\t\t\t--c;\n-\t\t}\n-\t\tif(FD_ISSET(i, pwfds)) {\n-\t\t\tmode += 'w';\n-\t\t\t--c;\n-\t\t}\n-\t\tif(FD_ISSET(i, pefds)) {\n-\t\t\tmode = 'r' + 'w';\n-\t\t\t--c;\n-\t\t}\n-\t\tif(i == rdwake && mode != 0) {\n-\t\t\twhile(read(rdwake, &b, sizeof b) > 0)\n-\t\t\t\t;\n-\t\t\tcontinue;\n-\t\t}\n-\t\tif(mode) {\n-\t\t\tPollDesc *pd;\n-\n-\t\t\truntime_lock(&selectlock);\n-\t\t\tpd = data[i];\n-\t\t\truntime_unlock(&selectlock);\n-\t\t\tif(pd != nil)\n-\t\t\t\truntime_netpollready(&gp, pd, mode);\n-\t\t}\n-\t}\n-\tif(block && gp == nil)\n-\t\tgoto retry;\n-\n-\tif(allocatedfds) {\n-\t\truntime_SysFree(prfds, 4 * sizeof fds, &mstats()->other_sys);\n-\t} else {\n-\t\truntime_lock(&selectlock);\n-\t\tinuse = false;\n-\t\truntime_unlock(&selectlock);\n-\t}\n-\n-\treturn gp;\n-}\n-\n-void\n-runtime_netpoll_scan(struct Workbuf** wbufp, void (*enqueue1)(struct Workbuf**, Obj))\n-{\n-\tenqueue1(wbufp, (Obj){(byte*)&data, sizeof data, 0});\n-}"}, {"sha": "e60eaed63744cfe7ae6040f50d966c4ed0a75df4", "filename": "libgo/runtime/runtime.h", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/812ba636c7b12f2c503e34aaf9e2da50d5777b82/libgo%2Fruntime%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/812ba636c7b12f2c503e34aaf9e2da50d5777b82/libgo%2Fruntime%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.h?ref=812ba636c7b12f2c503e34aaf9e2da50d5777b82", "patch": "@@ -391,21 +391,8 @@ int64\truntime_tickspersecond(void)\n      __asm__ (GOSYM_PREFIX \"runtime.tickspersecond\");\n void\truntime_blockevent(int64, int32);\n extern int64 runtime_blockprofilerate;\n-void\truntime_addtimer(Timer*)\n-  __asm__ (GOSYM_PREFIX \"runtime.addtimer\");\n-bool\truntime_deltimer(Timer*)\n-  __asm__ (GOSYM_PREFIX \"runtime.deltimer\");\n-G*\truntime_netpoll(bool);\n-void\truntime_netpollinit(void);\n-int32\truntime_netpollopen(uintptr, PollDesc*);\n-int32   runtime_netpollclose(uintptr);\n-void\truntime_netpollready(G**, PollDesc*, int32);\n-uintptr\truntime_netpollfd(PollDesc*);\n-void\truntime_netpollarm(PollDesc*, int32);\n-void**\truntime_netpolluser(PollDesc*);\n-bool\truntime_netpollclosing(PollDesc*);\n-void\truntime_netpolllock(PollDesc*);\n-void\truntime_netpollunlock(PollDesc*);\n+G*\truntime_netpoll(bool)\n+  __asm__ (GOSYM_PREFIX \"runtime.netpoll\");\n void\truntime_crash(void);\n void\truntime_parsedebugvars(void)\n   __asm__(GOSYM_PREFIX \"runtime.parsedebugvars\");"}, {"sha": "56790c604159468c049da3bfa35644e86b1758d6", "filename": "libgo/sysinfo.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/812ba636c7b12f2c503e34aaf9e2da50d5777b82/libgo%2Fsysinfo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/812ba636c7b12f2c503e34aaf9e2da50d5777b82/libgo%2Fsysinfo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fsysinfo.c?ref=812ba636c7b12f2c503e34aaf9e2da50d5777b82", "patch": "@@ -9,6 +9,7 @@\n \n #include \"config.h\"\n \n+#include <stddef.h>\n #include <sys/types.h>\n #include <dirent.h>\n #include <errno.h>\n@@ -49,6 +50,9 @@\n #if defined(HAVE_SYS_EPOLL_H)\n #include <sys/epoll.h>\n #endif\n+#if defined(HAVE_SYS_EVENT_H)\n+#include <sys/event.h>\n+#endif\n #if defined(HAVE_SYS_FILE_H)\n #include <sys/file.h>\n #endif\n@@ -155,6 +159,9 @@\n #if defined(HAVE_SEMAPHORE_H)\n #include <semaphore.h>\n #endif\n+#if defined(HAVE_PORT_H)\n+#include <port.h>\n+#endif\n \n /* Constants that may only be defined as expressions on some systems,\n    expressions too complex for -fdump-go-spec to handle.  These are\n@@ -260,3 +267,9 @@ enum {\n   NLA_HDRLEN_val = NLA_HDRLEN,\n #endif\n };\n+\n+#if defined(HAVE_SYS_EPOLL_H)\n+enum {\n+  epoll_data_offset = offsetof(struct epoll_event, data)\n+};\n+#endif"}]}