{"sha": "577e5d76f980c812f7f26f6aeded7cda5049c5d7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTc3ZTVkNzZmOTgwYzgxMmY3ZjI2ZjZhZWRlZDdjZGE1MDQ5YzVkNw==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2005-04-02T19:31:23Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-04-02T19:31:23Z"}, "message": "m68hc11-protos.h: Add a prototype for m68hcc_auto_inc_p.\n\n\t* config/m68hc11/m68hc11-protos.h: Add a prototype for\n\tm68hcc_auto_inc_p.\n\tRemove the prototypes for tst_operand, cmp_operand,\n\tstack_register_operand, d_register_operand,\n\thard_addr_reg_operand, splitable_operand,\n\tm68hc11_logical_operator, m68hc11_arith_operator,\n\tm68hc11_non_shift_operator, m68hc11_shift_operator,\n\tm68hc11_unary_operator, m68hc11_eq_compare_operator,\n\tnon_push_operand, hard_reg_operand, and\n\treg_or_some_mem_operand.\n\t* config/m68hc11/m68hc11.c (m68hcc_auto_inc_p): Make it\n\textern.\n\t(tst_operand, cmp_operand, non_push_operand,\n\tsplitable_operand, reg_or_some_mem_operand,\n\tstack_register_operand, d_register_operand,\n\thard_addr_reg_operand, hard_reg_operand,\n\tm68hc11_eq_compare_operator, m68hc11_logical_operator,\n\tm68hc11_arith_operator, m68hc11_non_shift_operator,\n\tm68hc11_shift_operator, m68hc11_unary_operator): Move to\n\tpredicates.md.\n\t* config/m68hc11/m68hc11.h (PREDICATE_CODES): Remove.\n\t* config/m68hc11/m68hc11.md: Include predicates.md.\n\t* config/m68hc11/predicates.md: New.\n\nFrom-SVN: r97455", "tree": {"sha": "5f9ad5386673079898234990f8a8c1fc361c3422", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f9ad5386673079898234990f8a8c1fc361c3422"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/577e5d76f980c812f7f26f6aeded7cda5049c5d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/577e5d76f980c812f7f26f6aeded7cda5049c5d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/577e5d76f980c812f7f26f6aeded7cda5049c5d7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/577e5d76f980c812f7f26f6aeded7cda5049c5d7/comments", "author": null, "committer": null, "parents": [{"sha": "8c1d21e66a9ca1403ac36883a93bda16a0f6edb6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c1d21e66a9ca1403ac36883a93bda16a0f6edb6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c1d21e66a9ca1403ac36883a93bda16a0f6edb6"}], "stats": {"total": 463, "additions": 252, "deletions": 211}, "files": [{"sha": "1eaa6d089e7b5ac9dd473b511f55e0d87f06ee93", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/577e5d76f980c812f7f26f6aeded7cda5049c5d7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/577e5d76f980c812f7f26f6aeded7cda5049c5d7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=577e5d76f980c812f7f26f6aeded7cda5049c5d7", "patch": "@@ -3,6 +3,30 @@\n \t* config/fr30/fr30.h (PREDICATE_CODES): Remove\n \tfp_displacement_operand, sp_displacement_operand.\n \n+\t* config/m68hc11/m68hc11-protos.h: Add a prototype for\n+\tm68hcc_auto_inc_p.\n+\tRemove the prototypes for tst_operand, cmp_operand,\n+\tstack_register_operand, d_register_operand,\n+\thard_addr_reg_operand, splitable_operand,\n+\tm68hc11_logical_operator, m68hc11_arith_operator,\n+\tm68hc11_non_shift_operator, m68hc11_shift_operator,\n+\tm68hc11_unary_operator, m68hc11_eq_compare_operator,\n+\tnon_push_operand, hard_reg_operand, and\n+\treg_or_some_mem_operand.\n+\t* config/m68hc11/m68hc11.c (m68hcc_auto_inc_p): Make it\n+\textern.\n+\t(tst_operand, cmp_operand, non_push_operand,\n+\tsplitable_operand, reg_or_some_mem_operand,\n+\tstack_register_operand, d_register_operand,\n+\thard_addr_reg_operand, hard_reg_operand,\n+\tm68hc11_eq_compare_operator, m68hc11_logical_operator,\n+\tm68hc11_arith_operator, m68hc11_non_shift_operator,\n+\tm68hc11_shift_operator, m68hc11_unary_operator): Move to\n+\tpredicates.md.\n+\t* config/m68hc11/m68hc11.h (PREDICATE_CODES): Remove.\n+\t* config/m68hc11/m68hc11.md: Include predicates.md.\n+\t* config/m68hc11/predicates.md: New.\n+\n 2005-04-02  Alexandre Oliva  <aoliva@redhat.com>\n \n \tPR debug/19345"}, {"sha": "4a123e8de016955c1e0a83999f8fcec716af6368", "filename": "gcc/config/m68hc11/m68hc11-protos.h", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/577e5d76f980c812f7f26f6aeded7cda5049c5d7/gcc%2Fconfig%2Fm68hc11%2Fm68hc11-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/577e5d76f980c812f7f26f6aeded7cda5049c5d7/gcc%2Fconfig%2Fm68hc11%2Fm68hc11-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11-protos.h?ref=577e5d76f980c812f7f26f6aeded7cda5049c5d7", "patch": "@@ -1,5 +1,6 @@\n /* Prototypes for exported functions defined in m68hc11.c\n-   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005\n+   Free Software Foundation, Inc.\n    Contributed by Stephane Carrez (stcarrez@nerim.fr)\n \n This file is part of GCC.\n@@ -41,6 +42,8 @@ extern void m68hc11_function_arg_advance (CUMULATIVE_ARGS*,\n #endif\n \n #ifdef RTX_CODE\n+extern int m68hc11_auto_inc_p (rtx);\n+\n extern void m68hc11_initialize_trampoline (rtx, rtx, rtx);\n \n extern rtx m68hc11_expand_compare_and_branch (enum rtx_code, rtx, rtx, rtx);\n@@ -90,8 +93,6 @@ extern int m68hc11_indirect_p (rtx, enum machine_mode);\n extern int go_if_legitimate_address2 (rtx, enum machine_mode, int);\n \n extern int reg_or_indexed_operand (rtx,enum machine_mode);\n-extern int tst_operand (rtx,enum machine_mode);\n-extern int cmp_operand (rtx,enum machine_mode);\n extern int memory_indexed_operand (rtx, enum machine_mode);\n \n extern void m68hc11_split_logical (enum machine_mode, int, rtx*);\n@@ -101,21 +102,8 @@ extern int m68hc11_register_indirect_p (rtx, enum machine_mode);\n extern int symbolic_memory_operand (rtx, enum machine_mode);\n \n extern int memory_reload_operand (rtx, enum machine_mode);\n-extern int stack_register_operand (rtx, enum machine_mode);\n-extern int d_register_operand (rtx, enum machine_mode);\n-extern int hard_addr_reg_operand (rtx, enum machine_mode);\n-extern int splitable_operand (rtx, enum machine_mode);\n extern int arith_src_operand (rtx, enum machine_mode);\n-extern int m68hc11_logical_operator (rtx, enum machine_mode);\n-extern int m68hc11_arith_operator (rtx, enum machine_mode);\n-extern int m68hc11_non_shift_operator (rtx, enum machine_mode);\n-extern int m68hc11_shift_operator (rtx, enum machine_mode);\n-extern int m68hc11_unary_operator (rtx, enum machine_mode);\n-extern int m68hc11_eq_compare_operator (rtx, enum machine_mode);\n-extern int non_push_operand (rtx, enum machine_mode);\n-extern int hard_reg_operand (rtx, enum machine_mode);\n extern int soft_reg_operand (rtx, enum machine_mode);\n-extern int reg_or_some_mem_operand (rtx, enum machine_mode);\n \n #if defined TREE_CODE\n extern void m68hc11_init_cumulative_args (CUMULATIVE_ARGS*, tree, rtx);"}, {"sha": "373d74b2294c54a9ebe9eaee94d9ba3537888828", "filename": "gcc/config/m68hc11/m68hc11.c", "status": "modified", "additions": 1, "deletions": 172, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/577e5d76f980c812f7f26f6aeded7cda5049c5d7/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/577e5d76f980c812f7f26f6aeded7cda5049c5d7/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c?ref=577e5d76f980c812f7f26f6aeded7cda5049c5d7", "patch": "@@ -72,7 +72,6 @@ static int m68hc11_address_cost (rtx);\n static int m68hc11_shift_cost (enum machine_mode, rtx, int);\n static int m68hc11_rtx_costs_1 (rtx, enum rtx_code, enum rtx_code);\n static bool m68hc11_rtx_costs (rtx, int, int, int *);\n-static int m68hc11_auto_inc_p (rtx);\n static tree m68hc11_handle_fntype_attribute (tree *, tree, tree, int, bool *);\n const struct attribute_spec m68hc11_attribute_table[];\n \n@@ -957,7 +956,7 @@ m68hc11_emit_libcall (const char *name, enum rtx_code code,\n /* Returns true if X is a PRE/POST increment decrement\n    (same as auto_inc_p() in rtlanal.c but do not take into\n    account the stack).  */\n-static int\n+int\n m68hc11_auto_inc_p (rtx x)\n {\n   return GET_CODE (x) == PRE_DEC\n@@ -979,81 +978,6 @@ memory_reload_operand (rtx operand, enum machine_mode mode ATTRIBUTE_UNUSED)\n \t    && GET_CODE (XEXP (XEXP (operand, 0), 0)) == CONST_INT));\n }\n \n-int\n-tst_operand (rtx operand, enum machine_mode mode)\n-{\n-  if (GET_CODE (operand) == MEM && reload_completed == 0)\n-    {\n-      rtx addr = XEXP (operand, 0);\n-      if (m68hc11_auto_inc_p (addr))\n-\treturn 0;\n-    }\n-  return nonimmediate_operand (operand, mode);\n-}\n-\n-int\n-cmp_operand (rtx operand, enum machine_mode mode)\n-{\n-  if (GET_CODE (operand) == MEM)\n-    {\n-      rtx addr = XEXP (operand, 0);\n-      if (m68hc11_auto_inc_p (addr))\n-\treturn 0;\n-    }\n-  return general_operand (operand, mode);\n-}\n-\n-int\n-non_push_operand (rtx operand, enum machine_mode mode)\n-{\n-  if (general_operand (operand, mode) == 0)\n-    return 0;\n-\n-  if (push_operand (operand, mode) == 1)\n-    return 0;\n-  return 1;\n-}\n-\n-int\n-splitable_operand (rtx operand, enum machine_mode mode)\n-{\n-  if (general_operand (operand, mode) == 0)\n-    return 0;\n-\n-  if (push_operand (operand, mode) == 1)\n-    return 0;\n-\n-  /* Reject a (MEM (MEM X)) because the patterns that use non_push_operand\n-     need to split such addresses to access the low and high part but it\n-     is not possible to express a valid address for the low part.  */\n-  if (mode != QImode && GET_CODE (operand) == MEM\n-      && GET_CODE (XEXP (operand, 0)) == MEM)\n-    return 0;\n-  return 1;\n-}\n-\n-int\n-reg_or_some_mem_operand (rtx operand, enum machine_mode mode)\n-{\n-  if (GET_CODE (operand) == MEM)\n-    {\n-      rtx op = XEXP (operand, 0);\n-\n-      if (symbolic_memory_operand (op, mode))\n-\treturn 1;\n-\n-      if (IS_STACK_PUSH (operand))\n-\treturn 1;\n-\n-      if (m68hc11_register_indirect_p (operand, mode))\n-\treturn 1;\n-\n-      return 0;\n-    }\n-\n-  return register_operand (operand, mode);\n-}\n-\n int\n m68hc11_symbolic_p (rtx operand, enum machine_mode mode)\n {\n@@ -1091,56 +1015,6 @@ m68hc11_indirect_p (rtx operand, enum machine_mode mode)\n   return 0;\n }\n \n-int\n-stack_register_operand (rtx operand, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return SP_REG_P (operand);\n-}\n-\n-int\n-d_register_operand (rtx operand, enum machine_mode mode)\n-{\n-  if (GET_MODE (operand) != mode && mode != VOIDmode)\n-    return 0;\n-\n-  if (GET_CODE (operand) == SUBREG)\n-    operand = XEXP (operand, 0);\n-\n-  return GET_CODE (operand) == REG\n-    && (REGNO (operand) >= FIRST_PSEUDO_REGISTER\n-\t|| REGNO (operand) == HARD_D_REGNUM\n-        || (mode == QImode && REGNO (operand) == HARD_B_REGNUM));\n-}\n-\n-int\n-hard_addr_reg_operand (rtx operand, enum machine_mode mode)\n-{\n-  if (GET_MODE (operand) != mode && mode != VOIDmode)\n-    return 0;\n-\n-  if (GET_CODE (operand) == SUBREG)\n-    operand = XEXP (operand, 0);\n-\n-  return GET_CODE (operand) == REG\n-    && (REGNO (operand) == HARD_X_REGNUM\n-\t|| REGNO (operand) == HARD_Y_REGNUM\n-\t|| REGNO (operand) == HARD_Z_REGNUM);\n-}\n-\n-int\n-hard_reg_operand (rtx operand, enum machine_mode mode)\n-{\n-  if (GET_MODE (operand) != mode && mode != VOIDmode)\n-    return 0;\n-\n-  if (GET_CODE (operand) == SUBREG)\n-    operand = XEXP (operand, 0);\n-\n-  return GET_CODE (operand) == REG\n-    && (REGNO (operand) >= FIRST_PSEUDO_REGISTER\n-\t|| H_REGNO_P (REGNO (operand)));\n-}\n-\n int\n memory_indexed_operand (rtx operand, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n@@ -1201,51 +1075,6 @@ symbolic_memory_operand (rtx op, enum machine_mode mode)\n       return 0;\n     }\n }\n-\n-int\n-m68hc11_eq_compare_operator (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return GET_CODE (op) == EQ || GET_CODE (op) == NE;\n-}\n-\n-int\n-m68hc11_logical_operator (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return GET_CODE (op) == AND || GET_CODE (op) == IOR || GET_CODE (op) == XOR;\n-}\n-\n-int\n-m68hc11_arith_operator (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return GET_CODE (op) == AND || GET_CODE (op) == IOR || GET_CODE (op) == XOR\n-    || GET_CODE (op) == PLUS || GET_CODE (op) == MINUS\n-    || GET_CODE (op) == ASHIFT || GET_CODE (op) == ASHIFTRT\n-    || GET_CODE (op) == LSHIFTRT || GET_CODE (op) == ROTATE\n-    || GET_CODE (op) == ROTATERT;\n-}\n-\n-int\n-m68hc11_non_shift_operator (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return GET_CODE (op) == AND || GET_CODE (op) == IOR || GET_CODE (op) == XOR\n-    || GET_CODE (op) == PLUS || GET_CODE (op) == MINUS;\n-}\n-\n-/* Return true if op is a shift operator.  */\n-int\n-m68hc11_shift_operator (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return GET_CODE (op) == ROTATE || GET_CODE (op) == ROTATERT\n-    || GET_CODE (op) == LSHIFTRT || GET_CODE (op) == ASHIFT\n-    || GET_CODE (op) == ASHIFTRT;\n-}\n-\n-int\n-m68hc11_unary_operator (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return GET_CODE (op) == NEG || GET_CODE (op) == NOT\n-    || GET_CODE (op) == SIGN_EXTEND || GET_CODE (op) == ZERO_EXTEND;\n-}\n \f\n /* Emit the code to build the trampoline used to call a nested function.\n    "}, {"sha": "a03956e0e1634ac4896922d2e9d03920d7cffa9d", "filename": "gcc/config/m68hc11/m68hc11.h", "status": "modified", "additions": 2, "deletions": 22, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/577e5d76f980c812f7f26f6aeded7cda5049c5d7/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/577e5d76f980c812f7f26f6aeded7cda5049c5d7/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h?ref=577e5d76f980c812f7f26f6aeded7cda5049c5d7", "patch": "@@ -1,6 +1,7 @@\n /* Definitions of target machine for GNU compiler.\n    Motorola 68HC11 and 68HC12.\n-   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005\n+   Free Software Foundation, Inc.\n    Contributed by Stephane Carrez (stcarrez@nerim.fr)\n \n This file is part of GCC.\n@@ -1589,27 +1590,6 @@ do {                                                                    \\\n \f\n /* Miscellaneous Parameters.  */\n \n-/* Define the codes that are matched by predicates in m68hc11.c.  */\n-#define PREDICATE_CODES \\\n-{\"stack_register_operand\",   {SUBREG, REG}},\t\t\t\t\\\n-{\"d_register_operand\",       {SUBREG, REG}},\t\t\t\t\\\n-{\"hard_addr_reg_operand\",    {SUBREG, REG}},\t\t\t\t\\\n-{\"hard_reg_operand\",         {SUBREG, REG}},\t\t\t\t\\\n-{\"m68hc11_logical_operator\", {AND, IOR, XOR}},\t\t\t\t\\\n-{\"m68hc11_arith_operator\",   {AND, IOR, XOR, PLUS, MINUS,\t\t\\\n-\t\t\t      ASHIFT, ASHIFTRT, LSHIFTRT,\t\t\\\n-\t\t\t      ROTATE, ROTATERT }},\t\t\t\\\n-{\"m68hc11_non_shift_operator\", {AND, IOR, XOR, PLUS, MINUS}},\t\t\\\n-{\"m68hc11_unary_operator\",   {NEG, NOT, SIGN_EXTEND, ZERO_EXTEND}},\t\\\n-{\"m68hc11_shift_operator\",   {ASHIFT, ASHIFTRT, LSHIFTRT, ROTATE, ROTATERT}},\\\n-{\"m68hc11_eq_compare_operator\", {EQ, NE}},                              \\\n-{\"non_push_operand\",         {SUBREG, REG, MEM}},\t\t\t\\\n-{\"splitable_operand\",        {SUBREG, REG, MEM}},\t\t\t\\\n-{\"reg_or_some_mem_operand\",  {SUBREG, REG, MEM}},\t\t\t\\\n-{\"tst_operand\",              {SUBREG, REG, MEM}},\t\t\t\\\n-{\"cmp_operand\",              {SUBREG, REG, MEM, SYMBOL_REF, LABEL_REF,\t\\\n-\t\t\t     CONST_INT, CONST_DOUBLE}},\n-\n /* Specify the machine mode that this machine uses\n    for the index in the tablejump instruction.  */\n #define CASE_VECTOR_MODE\tPmode"}, {"sha": "b51d8083c2b6458f96ffee3fe50cc2962f36ceaf", "filename": "gcc/config/m68hc11/m68hc11.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/577e5d76f980c812f7f26f6aeded7cda5049c5d7/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/577e5d76f980c812f7f26f6aeded7cda5049c5d7/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.md?ref=577e5d76f980c812f7f26f6aeded7cda5049c5d7", "patch": "@@ -1,5 +1,5 @@\n ;;- Machine description file for Motorola 68HC11 and 68HC12.\n-;;- Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004\n+;;- Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005\n ;;- Free Software Foundation, Inc.\n ;;- Contributed by Stephane Carrez (stcarrez@nerim.fr)\n \n@@ -149,6 +149,8 @@\n    (SOFT_XY_REGNUM  12)         ; XY soft register\n ])\n \n+(include \"predicates.md\")\n+\n ;;--------------------------------------------------------------------\n ;;-  Test\n ;;--------------------------------------------------------------------"}, {"sha": "67d1f988840aafdbbfdb596d69006910ca8ec24d", "filename": "gcc/config/m68hc11/predicates.md", "status": "added", "additions": 218, "deletions": 0, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/577e5d76f980c812f7f26f6aeded7cda5049c5d7/gcc%2Fconfig%2Fm68hc11%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/577e5d76f980c812f7f26f6aeded7cda5049c5d7/gcc%2Fconfig%2Fm68hc11%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fpredicates.md?ref=577e5d76f980c812f7f26f6aeded7cda5049c5d7", "patch": "@@ -0,0 +1,218 @@\n+;; Predicate definitions for Motorola 68HC11 and 68HC12.\n+;; Copyright (C) 2005 Free Software Foundation, Inc.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 59 Temple Place - Suite 330,\n+;; Boston, MA 02111-1307, USA.\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"stack_register_operand\"\n+  (match_code \"subreg,reg\")\n+{\n+  return SP_REG_P (op);\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"d_register_operand\"\n+  (match_code \"subreg,reg\")\n+{\n+  if (GET_MODE (op) != mode && mode != VOIDmode)\n+    return 0;\n+\n+  if (GET_CODE (op) == SUBREG)\n+    op = XEXP (op, 0);\n+\n+  return GET_CODE (op) == REG\n+    && (REGNO (op) >= FIRST_PSEUDO_REGISTER\n+\t|| REGNO (op) == HARD_D_REGNUM\n+        || (mode == QImode && REGNO (op) == HARD_B_REGNUM));\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"hard_addr_reg_operand\"\n+  (match_code \"subreg,reg\")\n+{\n+  if (GET_MODE (op) != mode && mode != VOIDmode)\n+    return 0;\n+\n+  if (GET_CODE (op) == SUBREG)\n+    op = XEXP (op, 0);\n+\n+  return GET_CODE (op) == REG\n+    && (REGNO (op) == HARD_X_REGNUM\n+\t|| REGNO (op) == HARD_Y_REGNUM\n+\t|| REGNO (op) == HARD_Z_REGNUM);\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"hard_reg_operand\"\n+  (match_code \"subreg,reg\")\n+{\n+  if (GET_MODE (op) != mode && mode != VOIDmode)\n+    return 0;\n+\n+  if (GET_CODE (op) == SUBREG)\n+    op = XEXP (op, 0);\n+\n+  return GET_CODE (op) == REG\n+    && (REGNO (op) >= FIRST_PSEUDO_REGISTER\n+\t|| H_REGNO_P (REGNO (op)));\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"m68hc11_logical_operator\"\n+  (match_code \"and,ior,xor\")\n+{\n+  return GET_CODE (op) == AND || GET_CODE (op) == IOR || GET_CODE (op) == XOR;\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"m68hc11_arith_operator\"\n+  (match_code \"and,ior,xor,plus,minus,ashift,ashiftrt,lshiftrt,rotate,rotatert\")\n+{\n+  return GET_CODE (op) == AND || GET_CODE (op) == IOR || GET_CODE (op) == XOR\n+    || GET_CODE (op) == PLUS || GET_CODE (op) == MINUS\n+    || GET_CODE (op) == ASHIFT || GET_CODE (op) == ASHIFTRT\n+    || GET_CODE (op) == LSHIFTRT || GET_CODE (op) == ROTATE\n+    || GET_CODE (op) == ROTATERT;\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"m68hc11_non_shift_operator\"\n+  (match_code \"and,ior,xor,plus,minus\")\n+{\n+  return GET_CODE (op) == AND || GET_CODE (op) == IOR || GET_CODE (op) == XOR\n+    || GET_CODE (op) == PLUS || GET_CODE (op) == MINUS;\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"m68hc11_unary_operator\"\n+  (match_code \"neg,not,sign_extend,zero_extend\")\n+{\n+  return GET_CODE (op) == NEG || GET_CODE (op) == NOT\n+    || GET_CODE (op) == SIGN_EXTEND || GET_CODE (op) == ZERO_EXTEND;\n+})\n+\n+;; Return true if op is a shift operator.\n+\n+(define_predicate \"m68hc11_shift_operator\"\n+  (match_code \"ashift,ashiftrt,lshiftrt,rotate,rotatert\")\n+{\n+  return GET_CODE (op) == ROTATE || GET_CODE (op) == ROTATERT\n+    || GET_CODE (op) == LSHIFTRT || GET_CODE (op) == ASHIFT\n+    || GET_CODE (op) == ASHIFTRT;\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"m68hc11_eq_compare_operator\"\n+  (match_code \"eq,ne\")\n+{\n+  return GET_CODE (op) == EQ || GET_CODE (op) == NE;\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"non_push_operand\"\n+  (match_code \"subreg,reg,mem\")\n+{\n+  if (general_operand (op, mode) == 0)\n+    return 0;\n+\n+  if (push_operand (op, mode) == 1)\n+    return 0;\n+  return 1;\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"splitable_operand\"\n+  (match_code \"subreg,reg,mem\")\n+{\n+  if (general_operand (op, mode) == 0)\n+    return 0;\n+\n+  if (push_operand (op, mode) == 1)\n+    return 0;\n+\n+  /* Reject a (MEM (MEM X)) because the patterns that use non_push_operand\n+     need to split such addresses to access the low and high part but it\n+     is not possible to express a valid address for the low part.  */\n+  if (mode != QImode && GET_CODE (op) == MEM\n+      && GET_CODE (XEXP (op, 0)) == MEM)\n+    return 0;\n+  return 1;\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"reg_or_some_mem_operand\"\n+  (match_code \"subreg,reg,mem\")\n+{\n+  if (GET_CODE (op) == MEM)\n+    {\n+      rtx op0 = XEXP (op, 0);\n+\n+      if (symbolic_memory_operand (op0, mode))\n+\treturn 1;\n+\n+      if (IS_STACK_PUSH (op))\n+\treturn 1;\n+\n+      if (m68hc11_register_indirect_p (op, mode))\n+\treturn 1;\n+\n+      return 0;\n+    }\n+\n+  return register_operand (op, mode);\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"tst_operand\"\n+  (match_code \"subreg,reg,mem\")\n+{\n+  if (GET_CODE (op) == MEM && reload_completed == 0)\n+    {\n+      rtx addr = XEXP (op, 0);\n+      if (m68hc11_auto_inc_p (addr))\n+\treturn 0;\n+    }\n+  return nonimmediate_operand (op, mode);\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"cmp_operand\"\n+  (match_code \"subreg,reg,mem,symbol_ref,label_ref,const_int,const_double\")\n+{\n+  if (GET_CODE (op) == MEM)\n+    {\n+      rtx addr = XEXP (op, 0);\n+      if (m68hc11_auto_inc_p (addr))\n+\treturn 0;\n+    }\n+  return general_operand (op, mode);\n+})"}]}