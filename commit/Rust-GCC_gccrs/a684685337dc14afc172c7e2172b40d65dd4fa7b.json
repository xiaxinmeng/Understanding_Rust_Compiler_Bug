{"sha": "a684685337dc14afc172c7e2172b40d65dd4fa7b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTY4NDY4NTMzN2RjMTRhZmMxNzJjN2UyMTcyYjQwZDY1ZGQ0ZmE3Yg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2010-04-27T21:26:25Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2010-04-27T21:26:25Z"}, "message": "re PR c++/43856 ([C++0x] gcc-4.5.0 fails to transform id-expression into class member access in lambda compound-statement)\n\n\tPR c++/43856\n\t* name-lookup.c (qualify_lookup): Disqualify lambda op().\n\t* class.c (current_nonlambda_class_type): New fn.\n\t* semantics.c (nonlambda_method_basetype): New.\n\t* cp-tree.h: Declare them.\n\t* tree.c (maybe_dummy_object): Handle implicit 'this' capture.\n\nFrom-SVN: r158807", "tree": {"sha": "29e991f81e1c25904d490958f6de0701b19fd4a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/29e991f81e1c25904d490958f6de0701b19fd4a6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a684685337dc14afc172c7e2172b40d65dd4fa7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a684685337dc14afc172c7e2172b40d65dd4fa7b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a684685337dc14afc172c7e2172b40d65dd4fa7b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a684685337dc14afc172c7e2172b40d65dd4fa7b/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "16de17aec71ab79c098ce82ac091f447f272834c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16de17aec71ab79c098ce82ac091f447f272834c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16de17aec71ab79c098ce82ac091f447f272834c"}], "stats": {"total": 101, "additions": 97, "deletions": 4}, "files": [{"sha": "4dd3df41ba6d9272bbea78d57ef65850faef9262", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a684685337dc14afc172c7e2172b40d65dd4fa7b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a684685337dc14afc172c7e2172b40d65dd4fa7b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a684685337dc14afc172c7e2172b40d65dd4fa7b", "patch": "@@ -1,5 +1,12 @@\n 2010-04-27  Jason Merrill  <jason@redhat.com>\n \n+\tPR c++/43856\n+\t* name-lookup.c (qualify_lookup): Disqualify lambda op().\n+\t* class.c (current_nonlambda_class_type): New fn.\n+\t* semantics.c (nonlambda_method_basetype): New.\n+\t* cp-tree.h: Declare them.\n+\t* tree.c (maybe_dummy_object): Handle implicit 'this' capture.\n+\n \t* semantics.c (baselink_for_fns): Correct BASELINK_BINFO.\n \n \tPR c++/43875"}, {"sha": "c640af4d5b64d7ee83778a56462c58e023e978b3", "filename": "gcc/cp/class.c", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a684685337dc14afc172c7e2172b40d65dd4fa7b/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a684685337dc14afc172c7e2172b40d65dd4fa7b/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=a684685337dc14afc172c7e2172b40d65dd4fa7b", "patch": "@@ -5971,6 +5971,34 @@ currently_open_derived_class (tree t)\n   return NULL_TREE;\n }\n \n+/* Returns the innermost class type which is not a lambda closure type.  */\n+\n+tree\n+current_nonlambda_class_type (void)\n+{\n+  int i;\n+\n+  /* We start looking from 1 because entry 0 is from global scope,\n+     and has no type.  */\n+  for (i = current_class_depth; i > 0; --i)\n+    {\n+      tree c;\n+      if (i == current_class_depth)\n+\tc = current_class_type;\n+      else\n+\t{\n+\t  if (current_class_stack[i].hidden)\n+\t    break;\n+\t  c = current_class_stack[i].type;\n+\t}\n+      if (!c)\n+\tcontinue;\n+      if (!LAMBDA_TYPE_P (c))\n+\treturn c;\n+    }\n+  return NULL_TREE;\n+}\n+\n /* When entering a class scope, all enclosing class scopes' names with\n    static meaning (static variables, static functions, types and\n    enumerators) have to be visible.  This recursive function calls"}, {"sha": "62e92cc81c76ae4b3437982ecfc6d38b08d43b90", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a684685337dc14afc172c7e2172b40d65dd4fa7b/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a684685337dc14afc172c7e2172b40d65dd4fa7b/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=a684685337dc14afc172c7e2172b40d65dd4fa7b", "patch": "@@ -4580,6 +4580,7 @@ extern void resort_type_method_vec\t\t(void *, void *,\n extern bool add_method\t\t\t\t(tree, tree, tree);\n extern bool currently_open_class\t\t(tree);\n extern tree currently_open_derived_class\t(tree);\n+extern tree current_nonlambda_class_type\t(void);\n extern tree finish_struct\t\t\t(tree, tree);\n extern void finish_struct_1\t\t\t(tree);\n extern int resolves_to_fixed_type_p\t\t(tree, int *);\n@@ -5212,6 +5213,7 @@ extern tree add_capture                         (tree, tree, tree, bool, bool);\n extern tree add_default_capture                 (tree, tree, tree);\n extern void register_capture_members\t\t(tree);\n extern tree lambda_expr_this_capture            (tree);\n+extern tree nonlambda_method_basetype\t\t(void);\n extern void maybe_add_lambda_conv_op            (tree);\n \n /* in tree.c */"}, {"sha": "5586bf7f969c31ea22c2432a18da772b35692c32", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a684685337dc14afc172c7e2172b40d65dd4fa7b/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a684685337dc14afc172c7e2172b40d65dd4fa7b/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=a684685337dc14afc172c7e2172b40d65dd4fa7b", "patch": "@@ -3807,6 +3807,10 @@ qualify_lookup (tree val, int flags)\n   if (cp_unevaluated_operand && TREE_CODE (val) == FIELD_DECL\n       && DECL_NORMAL_CAPTURE_P (val))\n     return false;\n+  /* None of the lookups that use qualify_lookup want the op() from the\n+     lambda; they want the one from the enclosing class.  */\n+  if (TREE_CODE (val) == FUNCTION_DECL && LAMBDA_FUNCTION_P (val))\n+    return false;\n   return true;\n }\n "}, {"sha": "7c039593608029181560084e136996e7be59bc7e", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a684685337dc14afc172c7e2172b40d65dd4fa7b/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a684685337dc14afc172c7e2172b40d65dd4fa7b/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=a684685337dc14afc172c7e2172b40d65dd4fa7b", "patch": "@@ -5869,6 +5869,32 @@ lambda_expr_this_capture (tree lambda)\n   return result;\n }\n \n+/* Returns the method basetype of the innermost non-lambda function, or\n+   NULL_TREE if none.  */\n+\n+tree\n+nonlambda_method_basetype (void)\n+{\n+  tree fn, type;\n+  if (!current_class_ref)\n+    return NULL_TREE;\n+\n+  type = current_class_type;\n+  if (!LAMBDA_TYPE_P (type))\n+    return type;\n+\n+  /* Find the nearest enclosing non-lambda function.  */\n+  fn = TYPE_NAME (type);\n+  do\n+    fn = decl_function_context (fn);\n+  while (fn && LAMBDA_FUNCTION_P (fn));\n+\n+  if (!fn || !DECL_NONSTATIC_MEMBER_FUNCTION_P (fn))\n+    return NULL_TREE;\n+\n+  return TYPE_METHOD_BASETYPE (TREE_TYPE (fn));\n+}\n+\n /* If the closure TYPE has a static op(), also add a conversion to function\n    pointer.  */\n "}, {"sha": "f8b2c403af4df2536c4d9b6308343417cc333d42", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a684685337dc14afc172c7e2172b40d65dd4fa7b/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a684685337dc14afc172c7e2172b40d65dd4fa7b/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=a684685337dc14afc172c7e2172b40d65dd4fa7b", "patch": "@@ -2293,11 +2293,11 @@ maybe_dummy_object (tree type, tree* binfop)\n {\n   tree decl, context;\n   tree binfo;\n+  tree current = current_nonlambda_class_type ();\n \n-  if (current_class_type\n-      && (binfo = lookup_base (current_class_type, type,\n-\t\t\t       ba_unique | ba_quiet, NULL)))\n-    context = current_class_type;\n+  if (current\n+      && (binfo = lookup_base (current, type, ba_any, NULL)))\n+    context = current;\n   else\n     {\n       /* Reference from a nested class member function.  */\n@@ -2315,6 +2315,13 @@ maybe_dummy_object (tree type, tree* binfop)\n       && same_type_p (TYPE_MAIN_VARIANT (TREE_TYPE (current_class_ref)),\n \t\t      current_class_type))\n     decl = current_class_ref;\n+  else if (current != current_class_type\n+\t   && context == nonlambda_method_basetype ())\n+    /* In a lambda, need to go through 'this' capture.  */\n+    decl = (cp_build_indirect_ref\n+\t    ((lambda_expr_this_capture\n+\t      (CLASSTYPE_LAMBDA_EXPR (current_class_type))),\n+\t     RO_NULL, tf_warning_or_error));\n   else\n     decl = build_dummy_object (context);\n "}, {"sha": "37f201ab2e20d80fe855676747e8013dc9b63f2d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a684685337dc14afc172c7e2172b40d65dd4fa7b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a684685337dc14afc172c7e2172b40d65dd4fa7b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a684685337dc14afc172c7e2172b40d65dd4fa7b", "patch": "@@ -1,5 +1,8 @@\n 2010-04-27  Jason Merrill  <jason@redhat.com>\n \n+\tPR c++/43856\n+\t* g++.dg/cpp0x/lambda/lambda-this2.C: New.\n+\n \tPR c++/43875\n \t* g++.dg/cpp0x/lambda/lambda-deduce2.C: New.\n "}, {"sha": "ce4bda458c8a4cc6ff400958cd37e176d6417bc8", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-this2.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a684685337dc14afc172c7e2172b40d65dd4fa7b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-this2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a684685337dc14afc172c7e2172b40d65dd4fa7b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-this2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-this2.C?ref=a684685337dc14afc172c7e2172b40d65dd4fa7b", "patch": "@@ -0,0 +1,16 @@\n+// PR c++/43856\n+// Test for implicit 'this' capture via rewriting.\n+// { dg-options \"-std=c++0x\" }\n+\n+struct S1 {\n+  int operator()(int);\n+  int i;\n+  void g();\n+  void f() {\n+    [=]() {\n+      i;\n+      g();\n+      operator()(42);\n+    };\n+  }\n+};"}]}