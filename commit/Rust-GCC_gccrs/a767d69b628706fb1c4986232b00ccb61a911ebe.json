{"sha": "a767d69b628706fb1c4986232b00ccb61a911ebe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTc2N2Q2OWI2Mjg3MDZmYjFjNDk4NjIzMmIwMGNjYjYxYTkxMWViZQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-02-19T11:05:35Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-02-19T11:05:35Z"}, "message": "[multiple changes]\n\n2014-02-19  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_util.adb: Update comments.\n\n2014-02-19  Doug Rupp  <rupp@adacore.com>\n\n\t* bindgen.adb (Gen_Adainit) [VMS] New global Float_Format.\n\t* init.c (__gl_float_format): [VMS] New global.\n\t(__gnat_set_features): Call FP_CONTROL to set FPSR for the float\n\trepresentation in effect.\n\n2014-02-19  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch6.adb Add with and use clause for Exp_Prag.\n\t(Expand_Contract_Cases): Relocated to Exp_Prag.\n\t* exp_ch6.ads (Expand_Contract_Cases): Relocated to Exp_Prag.\n\t* exp_prag.adb Add with and use clauses for Checks and Validsw.\n\t(Expand_Contract_Cases): Relocated from Exp_Ch6. Update the\n\tstructure of the expanded code to showcase the evaluation of\n\tattribute 'Old prefixes. Add local variable Old_Evals. Expand\n\tany attribute 'Old references found within a consequence. Add\n\tcircuitry to evaluate the prefixes of attribute 'Old that\n\tbelong to a selected consequence.\n\t(Expand_Old_In_Consequence): New routine.\n\t* exp_prag.ads (Expand_Contract_Cases): Relocated from Exp_Ch6.\n\t* sem_attr.adb (Check_Use_In_Contract_Cases): Warn that a\n\tpotentially unevaluated prefix is always evaluated.\n\nFrom-SVN: r207891", "tree": {"sha": "3d6d6f007167e2b2dca010de1831d469c4aacb35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d6d6f007167e2b2dca010de1831d469c4aacb35"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a767d69b628706fb1c4986232b00ccb61a911ebe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a767d69b628706fb1c4986232b00ccb61a911ebe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a767d69b628706fb1c4986232b00ccb61a911ebe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a767d69b628706fb1c4986232b00ccb61a911ebe/comments", "author": null, "committer": null, "parents": [{"sha": "adb252d824eac519413d0114a813543391c10592", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/adb252d824eac519413d0114a813543391c10592", "html_url": "https://github.com/Rust-GCC/gccrs/commit/adb252d824eac519413d0114a813543391c10592"}], "stats": {"total": 1259, "additions": 773, "deletions": 486}, "files": [{"sha": "dba833b5744de5b8a36c45a48063c9a305764883", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a767d69b628706fb1c4986232b00ccb61a911ebe/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a767d69b628706fb1c4986232b00ccb61a911ebe/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=a767d69b628706fb1c4986232b00ccb61a911ebe", "patch": "@@ -1,3 +1,31 @@\n+2014-02-19  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_util.adb: Update comments.\n+\n+2014-02-19  Doug Rupp  <rupp@adacore.com>\n+\n+\t* bindgen.adb (Gen_Adainit) [VMS] New global Float_Format.\n+\t* init.c (__gl_float_format): [VMS] New global.\n+\t(__gnat_set_features): Call FP_CONTROL to set FPSR for the float\n+\trepresentation in effect.\n+\n+2014-02-19  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch6.adb Add with and use clause for Exp_Prag.\n+\t(Expand_Contract_Cases): Relocated to Exp_Prag.\n+\t* exp_ch6.ads (Expand_Contract_Cases): Relocated to Exp_Prag.\n+\t* exp_prag.adb Add with and use clauses for Checks and Validsw.\n+\t(Expand_Contract_Cases): Relocated from Exp_Ch6. Update the\n+\tstructure of the expanded code to showcase the evaluation of\n+\tattribute 'Old prefixes. Add local variable Old_Evals. Expand\n+\tany attribute 'Old references found within a consequence. Add\n+\tcircuitry to evaluate the prefixes of attribute 'Old that\n+\tbelong to a selected consequence.\n+\t(Expand_Old_In_Consequence): New routine.\n+\t* exp_prag.ads (Expand_Contract_Cases): Relocated from Exp_Ch6.\n+\t* sem_attr.adb (Check_Use_In_Contract_Cases): Warn that a\n+\tpotentially unevaluated prefix is always evaluated.\n+\n 2014-02-19  Robert Dewar  <dewar@adacore.com>\n \n \t* exp_attr.adb (Expand_Min_Max_Attribute): Use Insert_Declaration"}, {"sha": "270aa5e07b6a1a56e149199c4d960552aba4d26c", "filename": "gcc/ada/bindgen.adb", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a767d69b628706fb1c4986232b00ccb61a911ebe/gcc%2Fada%2Fbindgen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a767d69b628706fb1c4986232b00ccb61a911ebe/gcc%2Fada%2Fbindgen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindgen.adb?ref=a767d69b628706fb1c4986232b00ccb61a911ebe", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -132,7 +132,7 @@ package body Bindgen is\n    -- Run-Time Globals --\n    ----------------------\n \n-   --  This section documents the global variables that set from the\n+   --  This section documents the global variables that are set from the\n    --  generated binder file.\n \n    --     Main_Priority                 : Integer;\n@@ -167,6 +167,9 @@ package body Bindgen is\n    --  -Hnn parameter for the binder or by the GNAT$NO_MALLOC_64 logical.\n    --  Valid values are 32 and 64. This switch is only effective on VMS.\n \n+   --  Float_Format is the float representation in use. Valid values are\n+   --  'I' for IEEE and 'V' for VAX Float. This is only for VMS.\n+\n    --  WC_Encoding shows the wide character encoding method used for the main\n    --  program. This is one of the encoding letters defined in\n    --  System.WCh_Con.WC_Encoding_Letters.\n@@ -677,6 +680,13 @@ package body Bindgen is\n \n                Write_Statement_Buffer;\n             end if;\n+\n+            WBI (\"\");\n+            WBI (\"      Float_Format : Character;\");\n+            WBI (\"      pragma Import (C, Float_Format, \" &\n+                    \"\"\"__gl_float_format\"\");\");\n+\n+            Write_Statement_Buffer;\n          end if;\n \n          --  Initialize stack limit variable of the environment task if the\n@@ -868,6 +878,25 @@ package body Bindgen is\n          --  Generate call to Set_Features\n \n          if OpenVMS_On_Target then\n+\n+            --  Set_Features will call IEEE$SET_FP_CONTROL appropriately\n+            --  depending on the setting of Float_Format.\n+\n+            WBI (\"\");\n+            Set_String (\"      Float_Format := '\");\n+\n+            if Float_Format_Specified = 'G'\n+                 or else\n+               Float_Format_Specified = 'D'\n+            then\n+               Set_Char ('V');\n+            else\n+               Set_Char ('I');\n+            end if;\n+\n+            Set_String (\"';\");\n+            Write_Statement_Buffer;\n+\n             WBI (\"\");\n             WBI (\"      if Features_Set = 0 then\");\n             WBI (\"         Set_Features;\");"}, {"sha": "ccf85796828cb0ce83303f8da946b0e669a76b75", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 1, "deletions": 470, "changes": 471, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a767d69b628706fb1c4986232b00ccb61a911ebe/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a767d69b628706fb1c4986232b00ccb61a911ebe/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=a767d69b628706fb1c4986232b00ccb61a911ebe", "patch": "@@ -41,6 +41,7 @@ with Exp_Disp; use Exp_Disp;\n with Exp_Dist; use Exp_Dist;\n with Exp_Intr; use Exp_Intr;\n with Exp_Pakd; use Exp_Pakd;\n+with Exp_Prag; use Exp_Prag;\n with Exp_Tss;  use Exp_Tss;\n with Exp_Util; use Exp_Util;\n with Exp_VFpt; use Exp_VFpt;\n@@ -4118,476 +4119,6 @@ package body Exp_Ch6 is\n       end if;\n    end Expand_Call;\n \n-   ---------------------------\n-   -- Expand_Contract_Cases --\n-   ---------------------------\n-\n-   --  Pragma Contract_Cases is expanded in the following manner:\n-\n-   --    subprogram S is\n-   --       Flag_1   : Boolean := False;\n-   --       . . .\n-   --       Flag_N   : Boolean := False;\n-   --       Flag_N+1 : Boolean := False;  --  when \"others\" present\n-   --       Count    : Natural := 0;\n-\n-   --       <preconditions (if any)>\n-\n-   --       if Case_Guard_1 then\n-   --          Flag_1 := True;\n-   --          Count  := Count + 1;\n-   --       end if;\n-   --       . . .\n-   --       if Case_Guard_N then\n-   --          Flag_N := True;\n-   --          Count  := Count + 1;\n-   --       end if;\n-\n-   --       if Count = 0 then\n-   --          raise Assertion_Error with \"xxx contract cases incomplete\";\n-   --            <or>\n-   --          Flag_N+1 := True;  --  when \"others\" present\n-\n-   --       elsif Count > 1 then\n-   --          declare\n-   --             Str0 : constant String :=\n-   --                      \"contract cases overlap for subprogram ABC\";\n-   --             Str1 : constant String :=\n-   --                      (if Flag_1 then\n-   --                         Str0 & \"case guard at xxx evaluates to True\"\n-   --                       else Str0);\n-   --             StrN : constant String :=\n-   --                      (if Flag_N then\n-   --                         StrN-1 & \"case guard at xxx evaluates to True\"\n-   --                       else StrN-1);\n-   --          begin\n-   --             raise Assertion_Error with StrN;\n-   --          end;\n-   --       end if;\n-\n-   --       procedure _Postconditions is\n-   --       begin\n-   --          <postconditions (if any)>\n-\n-   --          if Flag_1 and then not Consequence_1 then\n-   --             raise Assertion_Error with \"failed contract case at xxx\";\n-   --          end if;\n-   --          . . .\n-   --          if Flag_N[+1] and then not Consequence_N[+1] then\n-   --             raise Assertion_Error with \"failed contract case at xxx\";\n-   --          end if;\n-   --       end _Postconditions;\n-   --    begin\n-   --       . . .\n-   --    end S;\n-\n-   procedure Expand_Contract_Cases\n-     (CCs     : Node_Id;\n-      Subp_Id : Entity_Id;\n-      Decls   : List_Id;\n-      Stmts   : in out List_Id)\n-   is\n-      Loc : constant Source_Ptr := Sloc (CCs);\n-\n-      procedure Case_Guard_Error\n-        (Decls     : List_Id;\n-         Flag      : Entity_Id;\n-         Error_Loc : Source_Ptr;\n-         Msg       : in out Entity_Id);\n-      --  Given a declarative list Decls, status flag Flag, the location of the\n-      --  error and a string Msg, construct the following check:\n-      --    Msg : constant String :=\n-      --            (if Flag then\n-      --                Msg & \"case guard at Error_Loc evaluates to True\"\n-      --             else Msg);\n-      --  The resulting code is added to Decls\n-\n-      procedure Consequence_Error\n-        (Checks : in out Node_Id;\n-         Flag   : Entity_Id;\n-         Conseq : Node_Id);\n-      --  Given an if statement Checks, status flag Flag and a consequence\n-      --  Conseq, construct the following check:\n-      --    [els]if Flag and then not Conseq then\n-      --       raise Assertion_Error\n-      --         with \"failed contract case at Sloc (Conseq)\";\n-      --    [end if;]\n-      --  The resulting code is added to Checks\n-\n-      function Declaration_Of (Id : Entity_Id) return Node_Id;\n-      --  Given the entity Id of a boolean flag, generate:\n-      --    Id : Boolean := False;\n-\n-      function Increment (Id : Entity_Id) return Node_Id;\n-      --  Given the entity Id of a numerical variable, generate:\n-      --    Id := Id + 1;\n-\n-      function Set (Id : Entity_Id) return Node_Id;\n-      --  Given the entity Id of a boolean variable, generate:\n-      --    Id := True;\n-\n-      ----------------------\n-      -- Case_Guard_Error --\n-      ----------------------\n-\n-      procedure Case_Guard_Error\n-        (Decls     : List_Id;\n-         Flag      : Entity_Id;\n-         Error_Loc : Source_Ptr;\n-         Msg       : in out Entity_Id)\n-      is\n-         New_Line : constant Character := Character'Val (10);\n-         New_Msg  : constant Entity_Id := Make_Temporary (Loc, 'S');\n-\n-      begin\n-         Start_String;\n-         Store_String_Char  (New_Line);\n-         Store_String_Chars (\"  case guard at \");\n-         Store_String_Chars (Build_Location_String (Error_Loc));\n-         Store_String_Chars (\" evaluates to True\");\n-\n-         --  Generate:\n-         --    New_Msg : constant String :=\n-         --      (if Flag then\n-         --          Msg & \"case guard at Error_Loc evaluates to True\"\n-         --       else Msg);\n-\n-         Append_To (Decls,\n-           Make_Object_Declaration (Loc,\n-             Defining_Identifier => New_Msg,\n-             Constant_Present    => True,\n-             Object_Definition   => New_Reference_To (Standard_String, Loc),\n-             Expression          =>\n-               Make_If_Expression (Loc,\n-                 Expressions => New_List (\n-                   New_Reference_To (Flag, Loc),\n-\n-                   Make_Op_Concat (Loc,\n-                     Left_Opnd  => New_Reference_To (Msg, Loc),\n-                     Right_Opnd => Make_String_Literal (Loc, End_String)),\n-\n-                   New_Reference_To (Msg, Loc)))));\n-\n-         Msg := New_Msg;\n-      end Case_Guard_Error;\n-\n-      -----------------------\n-      -- Consequence_Error --\n-      -----------------------\n-\n-      procedure Consequence_Error\n-        (Checks : in out Node_Id;\n-         Flag   : Entity_Id;\n-         Conseq : Node_Id)\n-      is\n-         Cond  : Node_Id;\n-         Error : Node_Id;\n-\n-      begin\n-         --  Generate:\n-         --    Flag and then not Conseq\n-\n-         Cond :=\n-           Make_And_Then (Loc,\n-             Left_Opnd  => New_Reference_To (Flag, Loc),\n-             Right_Opnd =>\n-               Make_Op_Not (Loc,\n-                 Right_Opnd => Relocate_Node (Conseq)));\n-\n-         --  Generate:\n-         --    raise Assertion_Error\n-         --      with \"failed contract case at Sloc (Conseq)\";\n-\n-         Start_String;\n-         Store_String_Chars (\"failed contract case at \");\n-         Store_String_Chars (Build_Location_String (Sloc (Conseq)));\n-\n-         Error :=\n-           Make_Procedure_Call_Statement (Loc,\n-             Name                   =>\n-               New_Reference_To (RTE (RE_Raise_Assert_Failure), Loc),\n-             Parameter_Associations => New_List (\n-               Make_String_Literal (Loc, End_String)));\n-\n-         if No (Checks) then\n-            Checks :=\n-              Make_Implicit_If_Statement (CCs,\n-                Condition       => Cond,\n-                Then_Statements => New_List (Error));\n-\n-         else\n-            if No (Elsif_Parts (Checks)) then\n-               Set_Elsif_Parts (Checks, New_List);\n-            end if;\n-\n-            Append_To (Elsif_Parts (Checks),\n-              Make_Elsif_Part (Loc,\n-                Condition       => Cond,\n-                Then_Statements => New_List (Error)));\n-         end if;\n-      end Consequence_Error;\n-\n-      --------------------\n-      -- Declaration_Of --\n-      --------------------\n-\n-      function Declaration_Of (Id : Entity_Id) return Node_Id is\n-      begin\n-         return\n-           Make_Object_Declaration (Loc,\n-             Defining_Identifier => Id,\n-             Object_Definition   => New_Reference_To (Standard_Boolean, Loc),\n-             Expression          => New_Reference_To (Standard_False, Loc));\n-      end Declaration_Of;\n-\n-      ---------------\n-      -- Increment --\n-      ---------------\n-\n-      function Increment (Id : Entity_Id) return Node_Id is\n-      begin\n-         return\n-           Make_Assignment_Statement (Loc,\n-             Name       => New_Reference_To (Id, Loc),\n-             Expression =>\n-               Make_Op_Add (Loc,\n-                 Left_Opnd  => New_Reference_To (Id, Loc),\n-                 Right_Opnd => Make_Integer_Literal (Loc, 1)));\n-      end Increment;\n-\n-      ---------\n-      -- Set --\n-      ---------\n-\n-      function Set (Id : Entity_Id) return Node_Id is\n-      begin\n-         return\n-           Make_Assignment_Statement (Loc,\n-             Name       => New_Reference_To (Id, Loc),\n-             Expression => New_Reference_To (Standard_True, Loc));\n-      end Set;\n-\n-      --  Local variables\n-\n-      Aggr          : constant Node_Id :=\n-                        Expression (First\n-                          (Pragma_Argument_Associations (CCs)));\n-      Case_Guard    : Node_Id;\n-      CG_Checks     : Node_Id;\n-      CG_Stmts      : List_Id;\n-      Conseq        : Node_Id;\n-      Conseq_Checks : Node_Id := Empty;\n-      Count         : Entity_Id;\n-      Error_Decls   : List_Id;\n-      Flag          : Entity_Id;\n-      Msg_Str       : Entity_Id;\n-      Multiple_PCs  : Boolean;\n-      Others_Flag   : Entity_Id := Empty;\n-      Post_Case     : Node_Id;\n-\n-   --  Start of processing for Expand_Contract_Cases\n-\n-   begin\n-      --  Do nothing if pragma is not enabled. If pragma is disabled, it has\n-      --  already been rewritten as a Null statement.\n-\n-      if Is_Ignored (CCs) then\n-         return;\n-\n-      --  Guard against malformed contract cases\n-\n-      elsif Nkind (Aggr) /= N_Aggregate then\n-         return;\n-      end if;\n-\n-      Multiple_PCs := List_Length (Component_Associations (Aggr)) > 1;\n-\n-      --  Create the counter which tracks the number of case guards that\n-      --  evaluate to True.\n-\n-      --    Count : Natural := 0;\n-\n-      Count := Make_Temporary (Loc, 'C');\n-\n-      Prepend_To (Decls,\n-        Make_Object_Declaration (Loc,\n-          Defining_Identifier => Count,\n-          Object_Definition   => New_Reference_To (Standard_Natural, Loc),\n-          Expression          => Make_Integer_Literal (Loc, 0)));\n-\n-      --  Create the base error message for multiple overlapping case guards\n-\n-      --    Msg_Str : constant String :=\n-      --                \"contract cases overlap for subprogram Subp_Id\";\n-\n-      if Multiple_PCs then\n-         Msg_Str := Make_Temporary (Loc, 'S');\n-\n-         Start_String;\n-         Store_String_Chars (\"contract cases overlap for subprogram \");\n-         Store_String_Chars (Get_Name_String (Chars (Subp_Id)));\n-\n-         Error_Decls := New_List (\n-           Make_Object_Declaration (Loc,\n-             Defining_Identifier => Msg_Str,\n-             Constant_Present    => True,\n-             Object_Definition   => New_Reference_To (Standard_String, Loc),\n-             Expression          => Make_String_Literal (Loc, End_String)));\n-      end if;\n-\n-      --  Process individual post cases\n-\n-      Post_Case := First (Component_Associations (Aggr));\n-      while Present (Post_Case) loop\n-         Case_Guard := First (Choices (Post_Case));\n-         Conseq     := Expression (Post_Case);\n-\n-         --  The \"others\" choice requires special processing\n-\n-         if Nkind (Case_Guard) = N_Others_Choice then\n-            Others_Flag := Make_Temporary (Loc, 'F');\n-            Prepend_To (Decls, Declaration_Of (Others_Flag));\n-\n-            --  Check possible overlap between a case guard and \"others\"\n-\n-            if Multiple_PCs and Exception_Extra_Info then\n-               Case_Guard_Error\n-                 (Decls     => Error_Decls,\n-                  Flag      => Others_Flag,\n-                  Error_Loc => Sloc (Case_Guard),\n-                  Msg       => Msg_Str);\n-            end if;\n-\n-            --  Check the corresponding consequence of \"others\"\n-\n-            Consequence_Error\n-              (Checks => Conseq_Checks,\n-               Flag   => Others_Flag,\n-               Conseq => Conseq);\n-\n-         --  Regular post case\n-\n-         else\n-            --  Create the flag which tracks the state of its associated case\n-            --  guard.\n-\n-            Flag := Make_Temporary (Loc, 'F');\n-            Prepend_To (Decls, Declaration_Of (Flag));\n-\n-            --  The flag is set when the case guard is evaluated to True\n-            --    if Case_Guard then\n-            --       Flag  := True;\n-            --       Count := Count + 1;\n-            --    end if;\n-\n-            Append_To (Decls,\n-              Make_Implicit_If_Statement (CCs,\n-                Condition       => Relocate_Node (Case_Guard),\n-                Then_Statements => New_List (\n-                  Set (Flag),\n-                  Increment (Count))));\n-\n-            --  Check whether this case guard overlaps with another one\n-\n-            if Multiple_PCs and Exception_Extra_Info then\n-               Case_Guard_Error\n-                 (Decls     => Error_Decls,\n-                  Flag      => Flag,\n-                  Error_Loc => Sloc (Case_Guard),\n-                  Msg       => Msg_Str);\n-            end if;\n-\n-            --  The corresponding consequence of the case guard which evaluated\n-            --  to True must hold on exit from the subprogram.\n-\n-            Consequence_Error\n-              (Checks => Conseq_Checks,\n-               Flag   => Flag,\n-               Conseq => Conseq);\n-         end if;\n-\n-         Next (Post_Case);\n-      end loop;\n-\n-      --  Raise Assertion_Error when none of the case guards evaluate to True.\n-      --  The only exception is when we have \"others\", in which case there is\n-      --  no error because \"others\" acts as a default True.\n-\n-      --  Generate:\n-      --    Flag := True;\n-\n-      if Present (Others_Flag) then\n-         CG_Stmts := New_List (Set (Others_Flag));\n-\n-      --  Generate:\n-      --    raise Assertion_Error with \"xxx contract cases incomplete\";\n-\n-      else\n-         Start_String;\n-         Store_String_Chars (Build_Location_String (Loc));\n-         Store_String_Chars (\" contract cases incomplete\");\n-\n-         CG_Stmts := New_List (\n-           Make_Procedure_Call_Statement (Loc,\n-             Name                   =>\n-               New_Reference_To (RTE (RE_Raise_Assert_Failure), Loc),\n-             Parameter_Associations => New_List (\n-               Make_String_Literal (Loc, End_String))));\n-      end if;\n-\n-      CG_Checks :=\n-        Make_Implicit_If_Statement (CCs,\n-          Condition       =>\n-            Make_Op_Eq (Loc,\n-              Left_Opnd  => New_Reference_To (Count, Loc),\n-              Right_Opnd => Make_Integer_Literal (Loc, 0)),\n-          Then_Statements => CG_Stmts);\n-\n-      --  Detect a possible failure due to several case guards evaluating to\n-      --  True.\n-\n-      --  Generate:\n-      --    elsif Count > 0 then\n-      --       declare\n-      --          <Error_Decls>\n-      --       begin\n-      --          raise Assertion_Error with <Msg_Str>;\n-      --    end if;\n-\n-      if Multiple_PCs then\n-         Set_Elsif_Parts (CG_Checks, New_List (\n-           Make_Elsif_Part (Loc,\n-             Condition       =>\n-               Make_Op_Gt (Loc,\n-                 Left_Opnd  => New_Reference_To (Count, Loc),\n-                 Right_Opnd => Make_Integer_Literal (Loc, 1)),\n-\n-             Then_Statements => New_List (\n-               Make_Block_Statement (Loc,\n-                 Declarations               => Error_Decls,\n-                 Handled_Statement_Sequence =>\n-                   Make_Handled_Sequence_Of_Statements (Loc,\n-                     Statements => New_List (\n-                       Make_Procedure_Call_Statement (Loc,\n-                         Name                   =>\n-                           New_Reference_To\n-                             (RTE (RE_Raise_Assert_Failure), Loc),\n-                         Parameter_Associations => New_List (\n-                           New_Reference_To (Msg_Str, Loc))))))))));\n-      end if;\n-\n-      Append_To (Decls, CG_Checks);\n-\n-      --  Raise Assertion_Error when the corresponding consequence of a case\n-      --  guard that evaluated to True fails.\n-\n-      if No (Stmts) then\n-         Stmts := New_List;\n-      end if;\n-\n-      Append_To (Stmts, Conseq_Checks);\n-   end Expand_Contract_Cases;\n-\n    -------------------------------\n    -- Expand_Ctrl_Function_Call --\n    -------------------------------"}, {"sha": "8cdd6fa7d37cd6a4f47f5e34c41f3844c648135e", "filename": "gcc/ada/exp_ch6.ads", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a767d69b628706fb1c4986232b00ccb61a911ebe/gcc%2Fada%2Fexp_ch6.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a767d69b628706fb1c4986232b00ccb61a911ebe/gcc%2Fada%2Fexp_ch6.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.ads?ref=a767d69b628706fb1c4986232b00ccb61a911ebe", "patch": "@@ -71,17 +71,6 @@ package Exp_Ch6 is\n    --  This procedure contains common processing for Expand_N_Function_Call,\n    --  Expand_N_Procedure_Statement, and Expand_N_Entry_Call.\n \n-   procedure Expand_Contract_Cases\n-     (CCs     : Node_Id;\n-      Subp_Id : Entity_Id;\n-      Decls   : List_Id;\n-      Stmts   : in out List_Id);\n-   --  Given pragma Contract_Cases CCs, create the circuitry needed to evaluate\n-   --  case guards and trigger consequence expressions. Subp_Id is the related\n-   --  subprogram for which the pragma applies. Decls are the declarations of\n-   --  Subp_Id's body. All generated code is added to list Stmts. If Stmts is\n-   --  empty, a new list is created.\n-\n    procedure Expand_Subprogram_Contract\n      (N       : Node_Id;\n       Spec_Id : Entity_Id;"}, {"sha": "f477b8e5ab2ab6cecb818ee979a3869da4dade34", "filename": "gcc/ada/exp_prag.adb", "status": "modified", "additions": 641, "deletions": 0, "changes": 641, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a767d69b628706fb1c4986232b00ccb61a911ebe/gcc%2Fada%2Fexp_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a767d69b628706fb1c4986232b00ccb61a911ebe/gcc%2Fada%2Fexp_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_prag.adb?ref=a767d69b628706fb1c4986232b00ccb61a911ebe", "patch": "@@ -25,6 +25,7 @@\n \n with Atree;    use Atree;\n with Casing;   use Casing;\n+with Checks;   use Checks;\n with Debug;    use Debug;\n with Einfo;    use Einfo;\n with Errout;   use Errout;\n@@ -50,6 +51,7 @@ with Stand;    use Stand;\n with Targparm; use Targparm;\n with Tbuild;   use Tbuild;\n with Uintp;    use Uintp;\n+with Validsw;  use Validsw;\n \n package body Exp_Prag is\n \n@@ -148,6 +150,645 @@ package body Exp_Prag is\n       end if;\n    end Arg3;\n \n+   ---------------------------\n+   -- Expand_Contract_Cases --\n+   ---------------------------\n+\n+   --  Pragma Contract_Cases is expanded in the following manner:\n+\n+   --    subprogram S is\n+   --       Count    : Natural := 0;\n+   --       Flag_1   : Boolean := False;\n+   --       . . .\n+   --       Flag_N   : Boolean := False;\n+   --       Flag_N+1 : Boolean := False;  --  when \"others\" present\n+   --       Pref_1   : ...;\n+   --       . . .\n+   --       Pref_M   : ...;\n+\n+   --       <preconditions (if any)>\n+\n+   --       --  Evaluate all case guards\n+\n+   --       if Case_Guard_1 then\n+   --          Flag_1 := True;\n+   --          Count  := Count + 1;\n+   --       end if;\n+   --       . . .\n+   --       if Case_Guard_N then\n+   --          Flag_N := True;\n+   --          Count  := Count + 1;\n+   --       end if;\n+\n+   --       --  Emit errors depending on the number of case guards that\n+   --       --  evaluated to True.\n+\n+   --       if Count = 0 then\n+   --          raise Assertion_Error with \"xxx contract cases incomplete\";\n+   --            <or>\n+   --          Flag_N+1 := True;  --  when \"others\" present\n+\n+   --       elsif Count > 1 then\n+   --          declare\n+   --             Str0 : constant String :=\n+   --                      \"contract cases overlap for subprogram ABC\";\n+   --             Str1 : constant String :=\n+   --                      (if Flag_1 then\n+   --                         Str0 & \"case guard at xxx evaluates to True\"\n+   --                       else Str0);\n+   --             StrN : constant String :=\n+   --                      (if Flag_N then\n+   --                         StrN-1 & \"case guard at xxx evaluates to True\"\n+   --                       else StrN-1);\n+   --          begin\n+   --             raise Assertion_Error with StrN;\n+   --          end;\n+   --       end if;\n+\n+   --       --  Evaluate all attribute 'Old prefixes found in the selected\n+   --       --  consequence.\n+\n+   --       if Flag_1 then\n+   --          Pref_1 := <prefix of 'Old found in Consequence_1>\n+   --       . . .\n+   --       elsif Flag_N then\n+   --          Pref_M := <prefix of 'Old found in Consequence_N>\n+   --       end if;\n+\n+   --       procedure _Postconditions is\n+   --       begin\n+   --          <postconditions (if any)>\n+\n+   --          if Flag_1 and then not Consequence_1 then\n+   --             raise Assertion_Error with \"failed contract case at xxx\";\n+   --          end if;\n+   --          . . .\n+   --          if Flag_N[+1] and then not Consequence_N[+1] then\n+   --             raise Assertion_Error with \"failed contract case at xxx\";\n+   --          end if;\n+   --       end _Postconditions;\n+   --    begin\n+   --       . . .\n+   --    end S;\n+\n+   procedure Expand_Contract_Cases\n+     (CCs     : Node_Id;\n+      Subp_Id : Entity_Id;\n+      Decls   : List_Id;\n+      Stmts   : in out List_Id)\n+   is\n+      Loc : constant Source_Ptr := Sloc (CCs);\n+\n+      procedure Case_Guard_Error\n+        (Decls     : List_Id;\n+         Flag      : Entity_Id;\n+         Error_Loc : Source_Ptr;\n+         Msg       : in out Entity_Id);\n+      --  Given a declarative list Decls, status flag Flag, the location of the\n+      --  error and a string Msg, construct the following check:\n+      --    Msg : constant String :=\n+      --            (if Flag then\n+      --                Msg & \"case guard at Error_Loc evaluates to True\"\n+      --             else Msg);\n+      --  The resulting code is added to Decls\n+\n+      procedure Consequence_Error\n+        (Checks : in out Node_Id;\n+         Flag   : Entity_Id;\n+         Conseq : Node_Id);\n+      --  Given an if statement Checks, status flag Flag and a consequence\n+      --  Conseq, construct the following check:\n+      --    [els]if Flag and then not Conseq then\n+      --       raise Assertion_Error\n+      --         with \"failed contract case at Sloc (Conseq)\";\n+      --    [end if;]\n+      --  The resulting code is added to Checks\n+\n+      function Declaration_Of (Id : Entity_Id) return Node_Id;\n+      --  Given the entity Id of a boolean flag, generate:\n+      --    Id : Boolean := False;\n+\n+      procedure Expand_Old_In_Consequence\n+        (Decls  : List_Id;\n+         Evals  : in out Node_Id;\n+         Flag   : Entity_Id;\n+         Conseq : Node_Id);\n+      --  Perform specialized expansion of all attribute 'Old references found\n+      --  in consequence Conseq such that at runtime only prefixes coming from\n+      --  the selected consequence are evaluated. Any temporaries generated in\n+      --  the process are added to declarative list Decls. Evals is a complex\n+      --  if statement tasked with the evaluation of all prefixes coming from\n+      --  a selected consequence. Flag is the corresponding case guard flag.\n+      --  Conseq is the consequence expression.\n+\n+      function Increment (Id : Entity_Id) return Node_Id;\n+      --  Given the entity Id of a numerical variable, generate:\n+      --    Id := Id + 1;\n+\n+      function Set (Id : Entity_Id) return Node_Id;\n+      --  Given the entity Id of a boolean variable, generate:\n+      --    Id := True;\n+\n+      ----------------------\n+      -- Case_Guard_Error --\n+      ----------------------\n+\n+      procedure Case_Guard_Error\n+        (Decls     : List_Id;\n+         Flag      : Entity_Id;\n+         Error_Loc : Source_Ptr;\n+         Msg       : in out Entity_Id)\n+      is\n+         New_Line : constant Character := Character'Val (10);\n+         New_Msg  : constant Entity_Id := Make_Temporary (Loc, 'S');\n+\n+      begin\n+         Start_String;\n+         Store_String_Char  (New_Line);\n+         Store_String_Chars (\"  case guard at \");\n+         Store_String_Chars (Build_Location_String (Error_Loc));\n+         Store_String_Chars (\" evaluates to True\");\n+\n+         --  Generate:\n+         --    New_Msg : constant String :=\n+         --      (if Flag then\n+         --          Msg & \"case guard at Error_Loc evaluates to True\"\n+         --       else Msg);\n+\n+         Append_To (Decls,\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => New_Msg,\n+             Constant_Present    => True,\n+             Object_Definition   => New_Reference_To (Standard_String, Loc),\n+             Expression          =>\n+               Make_If_Expression (Loc,\n+                 Expressions => New_List (\n+                   New_Reference_To (Flag, Loc),\n+\n+                   Make_Op_Concat (Loc,\n+                     Left_Opnd  => New_Reference_To (Msg, Loc),\n+                     Right_Opnd => Make_String_Literal (Loc, End_String)),\n+\n+                   New_Reference_To (Msg, Loc)))));\n+\n+         Msg := New_Msg;\n+      end Case_Guard_Error;\n+\n+      -----------------------\n+      -- Consequence_Error --\n+      -----------------------\n+\n+      procedure Consequence_Error\n+        (Checks : in out Node_Id;\n+         Flag   : Entity_Id;\n+         Conseq : Node_Id)\n+      is\n+         Cond  : Node_Id;\n+         Error : Node_Id;\n+\n+      begin\n+         --  Generate:\n+         --    Flag and then not Conseq\n+\n+         Cond :=\n+           Make_And_Then (Loc,\n+             Left_Opnd  => New_Reference_To (Flag, Loc),\n+             Right_Opnd =>\n+               Make_Op_Not (Loc,\n+                 Right_Opnd => Relocate_Node (Conseq)));\n+\n+         --  Generate:\n+         --    raise Assertion_Error\n+         --      with \"failed contract case at Sloc (Conseq)\";\n+\n+         Start_String;\n+         Store_String_Chars (\"failed contract case at \");\n+         Store_String_Chars (Build_Location_String (Sloc (Conseq)));\n+\n+         Error :=\n+           Make_Procedure_Call_Statement (Loc,\n+             Name                   =>\n+               New_Reference_To (RTE (RE_Raise_Assert_Failure), Loc),\n+             Parameter_Associations => New_List (\n+               Make_String_Literal (Loc, End_String)));\n+\n+         if No (Checks) then\n+            Checks :=\n+              Make_Implicit_If_Statement (CCs,\n+                Condition       => Cond,\n+                Then_Statements => New_List (Error));\n+\n+         else\n+            if No (Elsif_Parts (Checks)) then\n+               Set_Elsif_Parts (Checks, New_List);\n+            end if;\n+\n+            Append_To (Elsif_Parts (Checks),\n+              Make_Elsif_Part (Loc,\n+                Condition       => Cond,\n+                Then_Statements => New_List (Error)));\n+         end if;\n+      end Consequence_Error;\n+\n+      --------------------\n+      -- Declaration_Of --\n+      --------------------\n+\n+      function Declaration_Of (Id : Entity_Id) return Node_Id is\n+      begin\n+         return\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => Id,\n+             Object_Definition   => New_Reference_To (Standard_Boolean, Loc),\n+             Expression          => New_Reference_To (Standard_False, Loc));\n+      end Declaration_Of;\n+\n+      -------------------------------\n+      -- Expand_Old_In_Consequence --\n+      -------------------------------\n+\n+      procedure Expand_Old_In_Consequence\n+        (Decls  : List_Id;\n+         Evals  : in out Node_Id;\n+         Flag   : Entity_Id;\n+         Conseq : Node_Id)\n+      is\n+         Eval_Stmts : List_Id := No_List;\n+         --  The evaluation sequence expressed as assignment statements of all\n+         --  prefixes of attribute 'Old found in the current consequence.\n+\n+         function Expand_Old (N : Node_Id) return Traverse_Result;\n+         --  Determine whether an arbitrary node denotes attribute 'Old and if\n+         --  it does, perform all expansion-related actions.\n+\n+         ----------------\n+         -- Expand_Old --\n+         ----------------\n+\n+         function Expand_Old (N : Node_Id) return Traverse_Result is\n+            Decl : Node_Id;\n+            Pref : Node_Id;\n+            Temp : Entity_Id;\n+\n+         begin\n+            if Nkind (N) = N_Attribute_Reference\n+              and then Attribute_Name (N) = Name_Old\n+            then\n+               Pref := Prefix (N);\n+               Temp := Make_Temporary (Loc, 'T', Pref);\n+\n+               --  Generate a temporary to capture the value of the prefix:\n+               --    Temp : <Pref type>;\n+\n+               Decl :=\n+                 Make_Object_Declaration (Loc,\n+                   Defining_Identifier => Temp,\n+                   Object_Definition   =>\n+                     New_Reference_To (Etype (Pref), Loc));\n+               Set_No_Initialization (Decl);\n+\n+               Append_To (Decls, Decl);\n+\n+               --  Evaluate the prefix, generate:\n+               --    Temp := <Pref>;\n+\n+               if No (Eval_Stmts) then\n+                  Eval_Stmts := New_List;\n+               end if;\n+\n+               Append_To (Eval_Stmts,\n+                 Make_Assignment_Statement (Loc,\n+                   Name       => New_Reference_To (Temp, Loc),\n+                   Expression => Pref));\n+\n+               --  Ensure that the prefix is valid\n+\n+               if Validity_Checks_On and then Validity_Check_Operands then\n+                  Ensure_Valid (Pref);\n+               end if;\n+\n+               --  Replace the original attribute 'Old by a reference to the\n+               --  generated temporary.\n+\n+               Rewrite (N, New_Reference_To (Temp, Loc));\n+            end if;\n+\n+            return OK;\n+         end Expand_Old;\n+\n+         procedure Expand_Olds is new Traverse_Proc (Expand_Old);\n+\n+      --  Start of processing for Expand_Old_In_Consequence\n+\n+      begin\n+         --  Inspect the consequence and expand any attribute 'Old references\n+         --  found within.\n+\n+         Expand_Olds (Conseq);\n+\n+         --  Augment the machinery to trigger the evaluation of all prefixes\n+         --  found in the step above. If Eval is empty, then this is the first\n+         --  consequence to yield expansion of 'Old. Generate:\n+\n+         --    if Flag then\n+         --       <evaluation statements>\n+         --    end if;\n+\n+         if No (Evals) then\n+            Evals :=\n+              Make_Implicit_If_Statement (CCs,\n+                Condition       => New_Reference_To (Flag, Loc),\n+                Then_Statements => Eval_Stmts);\n+\n+         --  Otherwise generate:\n+         --    elsif Flag then\n+         --       <evaluation statements>\n+         --    end if;\n+\n+         else\n+            if No (Elsif_Parts (Evals)) then\n+               Set_Elsif_Parts (Evals, New_List);\n+            end if;\n+\n+            Append_To (Elsif_Parts (Evals),\n+              Make_Elsif_Part (Loc,\n+                Condition       => New_Reference_To (Flag, Loc),\n+                Then_Statements => Eval_Stmts));\n+         end if;\n+      end Expand_Old_In_Consequence;\n+\n+      ---------------\n+      -- Increment --\n+      ---------------\n+\n+      function Increment (Id : Entity_Id) return Node_Id is\n+      begin\n+         return\n+           Make_Assignment_Statement (Loc,\n+             Name       => New_Reference_To (Id, Loc),\n+             Expression =>\n+               Make_Op_Add (Loc,\n+                 Left_Opnd  => New_Reference_To (Id, Loc),\n+                 Right_Opnd => Make_Integer_Literal (Loc, 1)));\n+      end Increment;\n+\n+      ---------\n+      -- Set --\n+      ---------\n+\n+      function Set (Id : Entity_Id) return Node_Id is\n+      begin\n+         return\n+           Make_Assignment_Statement (Loc,\n+             Name       => New_Reference_To (Id, Loc),\n+             Expression => New_Reference_To (Standard_True, Loc));\n+      end Set;\n+\n+      --  Local variables\n+\n+      Aggr          : constant Node_Id :=\n+                        Expression (First\n+                          (Pragma_Argument_Associations (CCs)));\n+      Case_Guard    : Node_Id;\n+      CG_Checks     : Node_Id;\n+      CG_Stmts      : List_Id;\n+      Conseq        : Node_Id;\n+      Conseq_Checks : Node_Id   := Empty;\n+      Count         : Entity_Id;\n+      Error_Decls   : List_Id;\n+      Flag          : Entity_Id;\n+      Msg_Str       : Entity_Id;\n+      Multiple_PCs  : Boolean;\n+      Old_Evals     : Node_Id   := Empty;\n+      Others_Flag   : Entity_Id := Empty;\n+      Post_Case     : Node_Id;\n+\n+   --  Start of processing for Expand_Contract_Cases\n+\n+   begin\n+      --  Do nothing if pragma is not enabled. If pragma is disabled, it has\n+      --  already been rewritten as a Null statement.\n+\n+      if Is_Ignored (CCs) then\n+         return;\n+\n+      --  Guard against malformed contract cases\n+\n+      elsif Nkind (Aggr) /= N_Aggregate then\n+         return;\n+      end if;\n+\n+      Multiple_PCs := List_Length (Component_Associations (Aggr)) > 1;\n+\n+      --  Create the counter which tracks the number of case guards that\n+      --  evaluate to True.\n+\n+      --    Count : Natural := 0;\n+\n+      Count := Make_Temporary (Loc, 'C');\n+\n+      Prepend_To (Decls,\n+        Make_Object_Declaration (Loc,\n+          Defining_Identifier => Count,\n+          Object_Definition   => New_Reference_To (Standard_Natural, Loc),\n+          Expression          => Make_Integer_Literal (Loc, 0)));\n+\n+      --  Create the base error message for multiple overlapping case guards\n+\n+      --    Msg_Str : constant String :=\n+      --                \"contract cases overlap for subprogram Subp_Id\";\n+\n+      if Multiple_PCs then\n+         Msg_Str := Make_Temporary (Loc, 'S');\n+\n+         Start_String;\n+         Store_String_Chars (\"contract cases overlap for subprogram \");\n+         Store_String_Chars (Get_Name_String (Chars (Subp_Id)));\n+\n+         Error_Decls := New_List (\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => Msg_Str,\n+             Constant_Present    => True,\n+             Object_Definition   => New_Reference_To (Standard_String, Loc),\n+             Expression          => Make_String_Literal (Loc, End_String)));\n+      end if;\n+\n+      --  Process individual post cases\n+\n+      Post_Case := First (Component_Associations (Aggr));\n+      while Present (Post_Case) loop\n+         Case_Guard := First (Choices (Post_Case));\n+         Conseq     := Expression (Post_Case);\n+\n+         --  The \"others\" choice requires special processing\n+\n+         if Nkind (Case_Guard) = N_Others_Choice then\n+            Others_Flag := Make_Temporary (Loc, 'F');\n+            Prepend_To (Decls, Declaration_Of (Others_Flag));\n+\n+            --  Check possible overlap between a case guard and \"others\"\n+\n+            if Multiple_PCs and Exception_Extra_Info then\n+               Case_Guard_Error\n+                 (Decls     => Error_Decls,\n+                  Flag      => Others_Flag,\n+                  Error_Loc => Sloc (Case_Guard),\n+                  Msg       => Msg_Str);\n+            end if;\n+\n+            --  Inspect the consequence and perform special expansion of any\n+            --  attribute 'Old references found within.\n+\n+            Expand_Old_In_Consequence\n+              (Decls  => Decls,\n+               Evals  => Old_Evals,\n+               Flag   => Others_Flag,\n+               Conseq => Conseq);\n+\n+            --  Check the corresponding consequence of \"others\"\n+\n+            Consequence_Error\n+              (Checks => Conseq_Checks,\n+               Flag   => Others_Flag,\n+               Conseq => Conseq);\n+\n+         --  Regular post case\n+\n+         else\n+            --  Create the flag which tracks the state of its associated case\n+            --  guard.\n+\n+            Flag := Make_Temporary (Loc, 'F');\n+            Prepend_To (Decls, Declaration_Of (Flag));\n+\n+            --  The flag is set when the case guard is evaluated to True\n+            --    if Case_Guard then\n+            --       Flag  := True;\n+            --       Count := Count + 1;\n+            --    end if;\n+\n+            Append_To (Decls,\n+              Make_Implicit_If_Statement (CCs,\n+                Condition       => Relocate_Node (Case_Guard),\n+                Then_Statements => New_List (\n+                  Set (Flag),\n+                  Increment (Count))));\n+\n+            --  Check whether this case guard overlaps with another one\n+\n+            if Multiple_PCs and Exception_Extra_Info then\n+               Case_Guard_Error\n+                 (Decls     => Error_Decls,\n+                  Flag      => Flag,\n+                  Error_Loc => Sloc (Case_Guard),\n+                  Msg       => Msg_Str);\n+            end if;\n+\n+            --  Inspect the consequence and perform special expansion of any\n+            --  attribute 'Old references found within.\n+\n+            Expand_Old_In_Consequence\n+              (Decls  => Decls,\n+               Evals  => Old_Evals,\n+               Flag   => Flag,\n+               Conseq => Conseq);\n+\n+            --  The corresponding consequence of the case guard which evaluated\n+            --  to True must hold on exit from the subprogram.\n+\n+            Consequence_Error\n+              (Checks => Conseq_Checks,\n+               Flag   => Flag,\n+               Conseq => Conseq);\n+         end if;\n+\n+         Next (Post_Case);\n+      end loop;\n+\n+      --  Raise Assertion_Error when none of the case guards evaluate to True.\n+      --  The only exception is when we have \"others\", in which case there is\n+      --  no error because \"others\" acts as a default True.\n+\n+      --  Generate:\n+      --    Flag := True;\n+\n+      if Present (Others_Flag) then\n+         CG_Stmts := New_List (Set (Others_Flag));\n+\n+      --  Generate:\n+      --    raise Assertion_Error with \"xxx contract cases incomplete\";\n+\n+      else\n+         Start_String;\n+         Store_String_Chars (Build_Location_String (Loc));\n+         Store_String_Chars (\" contract cases incomplete\");\n+\n+         CG_Stmts := New_List (\n+           Make_Procedure_Call_Statement (Loc,\n+             Name                   =>\n+               New_Reference_To (RTE (RE_Raise_Assert_Failure), Loc),\n+             Parameter_Associations => New_List (\n+               Make_String_Literal (Loc, End_String))));\n+      end if;\n+\n+      CG_Checks :=\n+        Make_Implicit_If_Statement (CCs,\n+          Condition       =>\n+            Make_Op_Eq (Loc,\n+              Left_Opnd  => New_Reference_To (Count, Loc),\n+              Right_Opnd => Make_Integer_Literal (Loc, 0)),\n+          Then_Statements => CG_Stmts);\n+\n+      --  Detect a possible failure due to several case guards evaluating to\n+      --  True.\n+\n+      --  Generate:\n+      --    elsif Count > 0 then\n+      --       declare\n+      --          <Error_Decls>\n+      --       begin\n+      --          raise Assertion_Error with <Msg_Str>;\n+      --    end if;\n+\n+      if Multiple_PCs then\n+         Set_Elsif_Parts (CG_Checks, New_List (\n+           Make_Elsif_Part (Loc,\n+             Condition       =>\n+               Make_Op_Gt (Loc,\n+                 Left_Opnd  => New_Reference_To (Count, Loc),\n+                 Right_Opnd => Make_Integer_Literal (Loc, 1)),\n+\n+             Then_Statements => New_List (\n+               Make_Block_Statement (Loc,\n+                 Declarations               => Error_Decls,\n+                 Handled_Statement_Sequence =>\n+                   Make_Handled_Sequence_Of_Statements (Loc,\n+                     Statements => New_List (\n+                       Make_Procedure_Call_Statement (Loc,\n+                         Name                   =>\n+                           New_Reference_To\n+                             (RTE (RE_Raise_Assert_Failure), Loc),\n+                         Parameter_Associations => New_List (\n+                           New_Reference_To (Msg_Str, Loc))))))))));\n+      end if;\n+\n+      Append_To (Decls, CG_Checks);\n+\n+      --  Once all case guards are evaluated and checked, evaluate any prefixes\n+      --  of attribute 'Old founds in the selected consequence.\n+\n+      Append_To (Decls, Old_Evals);\n+\n+      --  Raise Assertion_Error when the corresponding consequence of a case\n+      --  guard that evaluated to True fails.\n+\n+      if No (Stmts) then\n+         Stmts := New_List;\n+      end if;\n+\n+      Append_To (Stmts, Conseq_Checks);\n+   end Expand_Contract_Cases;\n+\n    ---------------------\n    -- Expand_N_Pragma --\n    ---------------------"}, {"sha": "681f1160dea6b22ae10dadcfea11939504cc2f60", "filename": "gcc/ada/exp_prag.ads", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a767d69b628706fb1c4986232b00ccb61a911ebe/gcc%2Fada%2Fexp_prag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a767d69b628706fb1c4986232b00ccb61a911ebe/gcc%2Fada%2Fexp_prag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_prag.ads?ref=a767d69b628706fb1c4986232b00ccb61a911ebe", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,4 +31,15 @@ package Exp_Prag is\n \n    procedure Expand_N_Pragma (N : Node_Id);\n \n+   procedure Expand_Contract_Cases\n+     (CCs     : Node_Id;\n+      Subp_Id : Entity_Id;\n+      Decls   : List_Id;\n+      Stmts   : in out List_Id);\n+   --  Given pragma Contract_Cases CCs, create the circuitry needed to evaluate\n+   --  case guards and trigger consequence expressions. Subp_Id is the related\n+   --  subprogram for which the pragma applies. Decls are the declarations of\n+   --  Subp_Id's body. All generated code is added to list Stmts. If Stmts is\n+   --  No_List on entry, a new list is created.\n+\n end Exp_Prag;"}, {"sha": "ff18d08ef16c0edfc212d094532d4c5a2c9165a6", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a767d69b628706fb1c4986232b00ccb61a911ebe/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a767d69b628706fb1c4986232b00ccb61a911ebe/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=a767d69b628706fb1c4986232b00ccb61a911ebe", "patch": "@@ -7981,6 +7981,13 @@ package body Exp_Util is\n                 Side_Effect_Free\n                   (First (Parameter_Associations (N)), Name_Req, Variable_Ref);\n \n+         --  An IF expression is side effect free if its components are all\n+         --  side effect free (conditions and then actions and else actions).\n+\n+         --  when N_If_Expression =>\n+         --  return Side_Effect_Free (Expressions (N), Name_Req, Variable_Ref);\n+         --  commented out for now, caused some crashes ???\n+\n          --  An indexed component is side effect free if it is a side\n          --  effect free prefixed reference and all the indexing\n          --  expressions are side effect free."}, {"sha": "d61086e214c17df2c78addbc00bed71588d02643", "filename": "gcc/ada/init.c", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a767d69b628706fb1c4986232b00ccb61a911ebe/gcc%2Fada%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a767d69b628706fb1c4986232b00ccb61a911ebe/gcc%2Fada%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finit.c?ref=a767d69b628706fb1c4986232b00ccb61a911ebe", "patch": "@@ -1508,6 +1508,14 @@ __gnat_set_stack_limit (void)\n #endif\n }\n \n+#ifdef IN_RTS\n+extern int SYS$IEEE_SET_FP_CONTROL (void *, void *, void *);\n+#define K_TRUE 1\n+#define __int64 long long\n+#define __NEW_STARLET\n+#include <vms/ieeedef.h>\n+#endif\n+\n /* Feature logical name and global variable address pair.\n    If we ever add another feature logical to this list, the\n    feature struct will need to be enhanced to take into account\n@@ -1517,9 +1525,21 @@ struct feature {\n   int *gl_addr;\n };\n \n-/* Default values for GNAT features set by environment.  */\n+/* Default values for GNAT features set by environment or binder.  */\n int __gl_heap_size = 64;\n \n+/* Default float format is 'I' meaning IEEE.  If gnatbind detetcts that a\n+   VAX Float format is specified, it will set this global variable to 'V'.\n+   Subsequently __gnat_set_features will test the variable and if set for\n+   VAX Float will call a Starlet function to enable trapping for invalid\n+   operation, drivide by zero, and overflow. This will prevent the VMS runtime\n+   (specifically OTS$CHECK_FP_MODE) from complaining about inconsistent\n+   floating point settings in a mixed language program. Ideally the setting\n+   would be determined at link time based on setttings in the object files,\n+   however the VMS linker seems to take the setting from the first object\n+   in the link, e.g. pcrt0.o which is float representation neutral.  */\n+char __gl_float_format = 'I';\n+\n /* Array feature logical names and global variable addresses.  */\n static const struct feature features[] =\n {\n@@ -1532,6 +1552,12 @@ __gnat_set_features (void)\n {\n   int i;\n   char buff[16];\n+#ifdef IN_RTS\n+  IEEE clrmsk, setmsk, prvmsk;\n+\n+  clrmsk.ieee$q_flags = 0LL;\n+  setmsk.ieee$q_flags = 0LL;\n+#endif\n \n   /* Loop through features array and test name for enable/disable.  */\n   for (i = 0; features[i].name; i++)\n@@ -1551,6 +1577,16 @@ __gnat_set_features (void)\n   /* Features to artificially limit the stack size.  */\n   __gnat_set_stack_limit ();\n \n+#ifdef IN_RTS\n+  if (__gl_float_format == 'V')\n+    {\n+      setmsk.ieee$v_trap_enable_inv = K_TRUE;\n+      setmsk.ieee$v_trap_enable_dze = K_TRUE;\n+      setmsk.ieee$v_trap_enable_ovf = K_TRUE;\n+      SYS$IEEE_SET_FP_CONTROL (&clrmsk, &setmsk, &prvmsk);\n+    }\n+#endif\n+\n   __gnat_features_set = 1;\n }\n "}, {"sha": "3e39d3a073aa36c0ef1f6b3d8720a4732c1daaf1", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a767d69b628706fb1c4986232b00ccb61a911ebe/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a767d69b628706fb1c4986232b00ccb61a911ebe/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=a767d69b628706fb1c4986232b00ccb61a911ebe", "patch": "@@ -4466,7 +4466,22 @@ package body Sem_Attr is\n             --  contract case as this is the only postcondition-like part of\n             --  the pragma.\n \n-            if Expr /= Expression (Parent (Expr)) then\n+            if Expr = Expression (Parent (Expr)) then\n+\n+               --  Warn that a potentially unevaluated prefix is always\n+               --  evaluated when the corresponding consequence is selected.\n+\n+               if Is_Potentially_Unevaluated (P) then\n+                  Error_Msg_Name_1 := Aname;\n+                  Error_Msg_N\n+                    (\"?prefix of attribute % is always evaluated when \"\n+                     & \"related consequence is selected\", P);\n+               end if;\n+\n+            --  Attribute 'Old appears in the condition of a contract case.\n+            --  Emit an error since this is not a postcondition-like context.\n+\n+            else\n                Error_Attr\n                  (\"attribute % cannot appear in the condition of a contract \"\n                   & \"case (SPARK RM 6.1.3(2))\", P);"}]}