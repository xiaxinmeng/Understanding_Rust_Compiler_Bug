{"sha": "d47cc544b60738db5e983c4b1ac6b40236b9633c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDQ3Y2M1NDRiNjA3MzhkYjVlOTgzYzRiMWFjNmI0MDIzNmI5NjMzYw==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2003-12-30T10:40:56Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2003-12-30T10:40:56Z"}, "message": "backport: et-forest.h (et_forest_create, [...]): Declarations removed.\n\n\tBackport from tree-ssa (relevant changes only):\n\t2003-12-18  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n\n\t* et-forest.h (et_forest_create, et_forest_delete,\n\tet_forest_add_node, et_forest_add_edge, et_forest_remove_node,\n\tet_forest_remove_edge, et_forest_parent,\n\tet_forest_common_ancestor, et_forest_node_value,\n\tet_forest_enumerate_sons): Declarations removed.\n\t(struct et_node): New.\n\t(et_new_tree, et_free_tree, et_set_father, et_split, et_nca,\n\tet_below): Declare.\n\t* et-forest.c (struct et_forest_occurrence, struct et_forest,\n\tstruct et_forest_node): Removed.\n\t(et_forest_create, et_forest_delete,\n\tet_forest_add_node, et_forest_add_edge, et_forest_remove_node,\n\tet_forest_remove_edge, et_forest_parent,\n\tet_forest_common_ancestor, et_forest_node_value,\n\tet_forest_enumerate_sons, splay, remove_all_occurrences,\n\tfind_leftmost_node, find_rightmost_node, calculate_value): Removed.\n\t(struct et_occ): New.\n\t(et_nodes, et_occurences): New.\n\t(set_depth, set_depth_add, set_prev, set_next, et_recomp_min,\n\tet_check_occ_sanity, et_check_sanity, et_check_tree_sanity,\n\trecord_path_before_1, record_path_before, check_path_after_1,\n\tcheck_path_after, et_splay, et_new_occ, et_new_tree,\n\tet_free_tree, et_set_father, et_split, et_nca, et_below): New.\n\t* basic-block.h (struct basic_block_def): New field dom.\n\t(struct dominance_info): Type removed.\n\t(calculate_dominance_info, free_dominance_info,\n\tnearest_common_dominator, set_immediate_dominator,\n\tget_immediate_dominator, dominated_by_p, get_dominated_by,\n\tadd_to_dominance_info, delete_from_dominance_info,\n\trecount_dominator, redirect_immediate_dominators,\n\titerate_fix_dominators, verify_dominators): Declarations\n\tchanged.\n\t(enum dom_state): New.\n\t(dom_computed): New variable.\n\t(first_dom_son, next_dom_son): Declare.\n\t* dominance.c (struct dominance_info): Removed.\n\t(BB_NODE, SET_BB_NODE): Removed.\n\t(calculate_dominance_info, free_dominance_info,\n\tnearest_common_dominator, set_immediate_dominator,\n\tget_immediate_dominator, dominated_by_p, get_dominated_by,\n\tadd_to_dominance_info, delete_from_dominance_info,\n\trecount_dominator, redirect_immediate_dominators,\n\titerate_fix_dominators, verify_dominators,\n\tdebug_dominance_info): Work over new datastructure.  Access\n\tdominance datastructures through CFG.\n\t(assign_dfs_numbers, compute_dom_fast_query, first_dom_son,\n\tnext_dom_son): New.\n\t* bt-load.c (dom): Variable removed.\n\t(augment_live_range, combine_btr_defs, migrate_btr_def,\n\tmigrate_btr_defs, branch_target_load_optimize): Updated for the\n\tnew interface for dominance information.\n\t* cfg.c {exit_entry_blocks): Update initializer.\n\t* cfglayout.c (copy_bbs): Removed loops argument. Updated for\n\tthe new interface for dominance information.\n\t* cfglayout.h (copy_bbs): Declaration changed.\n\t* cfgloop.c (flow_loop_pre_header_find, flow_loops_cfg_dump,\n\tflow_loop_scan, canonicalize_loop_headers, flow_loops_find): Updated\n\tfor the new interface for dominance information.\n\t(flow_loop_scan): Loops argument removed.\n\t(flow_loops_free): Don't release dominators.\n\t* cfgloop.h (struct cfg): Dom field removed.\n\t(flow_loop_scan, loop_split_edge_with, simple_loop_p,\n\tjust_once_each_iteration_p, split_loop_bb): Declaration changed.\n\t* cfgloopanal.c (simple_loop_exit_p, simple_increment,\n\tjust_once_each_iteration_p, simple_loop_p): Remove loops argument.\n\tUpdated for the new interface for dominance information.\n\t* cfgloopmanip.c (remove_bbs, find_path, create_preheader,\n\tsplit_loop_bb, loopify, duplicate_loop_to_header_edge,\n\tforce_single_succ_latches, loop_split_edge_with): Ditto.\n\t* gcse.c (dominators): Variable removed.\n\t(free_code_hoist_mem, compute_code_hoist_data, hoist_code):\n\tUpdated for the new interface for dominance information.\n\t* ifcvt.c (post_dominators): Variable removed.\n\t(mark_loop_exit_edges, merge_if_block, find_if_header,\n\tfind_cond_trap, find_if_case_1, find_if_case_2, if_convert):\n\tUpdated for the new interface for dominance information.\n\t* loop-init.c (rtl_loop_optimizer_init,\n\trtl_loop_optimizer_finalize): Ditto.\n\t* loop-unroll.c (decide_peel_simple, decide_peel_once_rolling,\n\tdecide_peel_completely, decide_unroll_stupid,\n\tdecide_unroll_constant_iterations,\n\tdecide_unroll_runtime_iterations): Loops argument removed.\n\tUpdated for the new interface for dominance information.\n\t(unroll_and_peel_loops, peel_loops_completely,\n\tunroll_loop_runtime_iterations): Updated for the new interface for\n\tdominance information.\n\t* loop-unswitch.c (may_unswitch_on_p, unswitch_loops,\n\tunswitch_single_loop, unswitch_loop): Updated for the new\n\tinterface for dominance information.\n\t* predict.c (process_note_predictions, process_note_prediction,\n\testimate_probability, note_prediction_to_br_prob): Ditto.\n\t* sched-rgn.c (find_rgns, init_regions): Ditto.\n\t* toplev.c (rest_of_handle_branch_prob): Free the dominators.\n\nFrom-SVN: r75226", "tree": {"sha": "10047b16072acc29f1f177189825f45ac62aba97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/10047b16072acc29f1f177189825f45ac62aba97"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d47cc544b60738db5e983c4b1ac6b40236b9633c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d47cc544b60738db5e983c4b1ac6b40236b9633c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d47cc544b60738db5e983c4b1ac6b40236b9633c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d47cc544b60738db5e983c4b1ac6b40236b9633c/comments", "author": null, "committer": null, "parents": [{"sha": "58496de135a8b4fdfe552d0d9b18c9d1db147582", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58496de135a8b4fdfe552d0d9b18c9d1db147582", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58496de135a8b4fdfe552d0d9b18c9d1db147582"}], "stats": {"total": 2166, "additions": 1206, "deletions": 960}, "files": [{"sha": "4b5b073e2ca8626a30bec87105ff4da303a2d6c7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d47cc544b60738db5e983c4b1ac6b40236b9633c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d47cc544b60738db5e983c4b1ac6b40236b9633c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d47cc544b60738db5e983c4b1ac6b40236b9633c", "patch": "@@ -1,3 +1,102 @@\n+2003-12-30  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\tBackport from tree-ssa (relevant changes only):\n+\t2003-12-18  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n+\n+\t* et-forest.h (et_forest_create, et_forest_delete,\n+\tet_forest_add_node, et_forest_add_edge, et_forest_remove_node,\n+\tet_forest_remove_edge, et_forest_parent,\n+\tet_forest_common_ancestor, et_forest_node_value,\n+\tet_forest_enumerate_sons): Declarations removed.\n+\t(struct et_node): New.\n+\t(et_new_tree, et_free_tree, et_set_father, et_split, et_nca,\n+\tet_below): Declare.\n+\t* et-forest.c (struct et_forest_occurrence, struct et_forest,\n+\tstruct et_forest_node): Removed.\n+\t(et_forest_create, et_forest_delete,\n+\tet_forest_add_node, et_forest_add_edge, et_forest_remove_node,\n+\tet_forest_remove_edge, et_forest_parent,\n+\tet_forest_common_ancestor, et_forest_node_value,\n+\tet_forest_enumerate_sons, splay, remove_all_occurrences,\n+\tfind_leftmost_node, find_rightmost_node, calculate_value): Removed.\n+\t(struct et_occ): New.\n+\t(et_nodes, et_occurences): New.\n+\t(set_depth, set_depth_add, set_prev, set_next, et_recomp_min,\n+\tet_check_occ_sanity, et_check_sanity, et_check_tree_sanity,\n+\trecord_path_before_1, record_path_before, check_path_after_1,\n+\tcheck_path_after, et_splay, et_new_occ, et_new_tree,\n+\tet_free_tree, et_set_father, et_split, et_nca, et_below): New.\n+\t* basic-block.h (struct basic_block_def): New field dom.\n+\t(struct dominance_info): Type removed.\n+\t(calculate_dominance_info, free_dominance_info,\n+\tnearest_common_dominator, set_immediate_dominator,\n+\tget_immediate_dominator, dominated_by_p, get_dominated_by,\n+\tadd_to_dominance_info, delete_from_dominance_info,\n+\trecount_dominator, redirect_immediate_dominators,\n+\titerate_fix_dominators, verify_dominators): Declarations\n+\tchanged.\n+\t(enum dom_state): New.\n+\t(dom_computed): New variable.\n+\t(first_dom_son, next_dom_son): Declare.\n+\t* dominance.c (struct dominance_info): Removed.\n+\t(BB_NODE, SET_BB_NODE): Removed.\n+\t(calculate_dominance_info, free_dominance_info,\n+\tnearest_common_dominator, set_immediate_dominator,\n+\tget_immediate_dominator, dominated_by_p, get_dominated_by,\n+\tadd_to_dominance_info, delete_from_dominance_info,\n+\trecount_dominator, redirect_immediate_dominators,\n+\titerate_fix_dominators, verify_dominators,\n+\tdebug_dominance_info): Work over new datastructure.  Access\n+\tdominance datastructures through CFG.\n+\t(assign_dfs_numbers, compute_dom_fast_query, first_dom_son,\n+\tnext_dom_son): New.\n+\t* bt-load.c (dom): Variable removed.\n+\t(augment_live_range, combine_btr_defs, migrate_btr_def,\n+\tmigrate_btr_defs, branch_target_load_optimize): Updated for the\n+\tnew interface for dominance information.\n+\t* cfg.c {exit_entry_blocks): Update initializer.\n+\t* cfglayout.c (copy_bbs): Removed loops argument. Updated for\n+\tthe new interface for dominance information.\n+\t* cfglayout.h (copy_bbs): Declaration changed.\n+\t* cfgloop.c (flow_loop_pre_header_find, flow_loops_cfg_dump,\n+\tflow_loop_scan, canonicalize_loop_headers, flow_loops_find): Updated\n+\tfor the new interface for dominance information.\n+\t(flow_loop_scan): Loops argument removed.\n+\t(flow_loops_free): Don't release dominators.\n+\t* cfgloop.h (struct cfg): Dom field removed.\n+\t(flow_loop_scan, loop_split_edge_with, simple_loop_p,\n+\tjust_once_each_iteration_p, split_loop_bb): Declaration changed.\n+\t* cfgloopanal.c (simple_loop_exit_p, simple_increment,\n+\tjust_once_each_iteration_p, simple_loop_p): Remove loops argument.\n+\tUpdated for the new interface for dominance information.\n+\t* cfgloopmanip.c (remove_bbs, find_path, create_preheader,\n+\tsplit_loop_bb, loopify, duplicate_loop_to_header_edge,\n+\tforce_single_succ_latches, loop_split_edge_with): Ditto.\n+\t* gcse.c (dominators): Variable removed.\n+\t(free_code_hoist_mem, compute_code_hoist_data, hoist_code):\n+\tUpdated for the new interface for dominance information.\n+\t* ifcvt.c (post_dominators): Variable removed.\n+\t(mark_loop_exit_edges, merge_if_block, find_if_header,\n+\tfind_cond_trap, find_if_case_1, find_if_case_2, if_convert):\n+\tUpdated for the new interface for dominance information.\n+\t* loop-init.c (rtl_loop_optimizer_init,\n+\trtl_loop_optimizer_finalize): Ditto.\n+\t* loop-unroll.c (decide_peel_simple, decide_peel_once_rolling,\n+\tdecide_peel_completely, decide_unroll_stupid,\n+\tdecide_unroll_constant_iterations,\n+\tdecide_unroll_runtime_iterations): Loops argument removed.\n+\tUpdated for the new interface for dominance information.\n+\t(unroll_and_peel_loops, peel_loops_completely,\n+\tunroll_loop_runtime_iterations): Updated for the new interface for\n+\tdominance information.\n+\t* loop-unswitch.c (may_unswitch_on_p, unswitch_loops,\n+\tunswitch_single_loop, unswitch_loop): Updated for the new\n+\tinterface for dominance information.\n+\t* predict.c (process_note_predictions, process_note_prediction,\n+\testimate_probability, note_prediction_to_br_prob): Ditto.\n+\t* sched-rgn.c (find_rgns, init_regions): Ditto.\n+\t* toplev.c (rest_of_handle_branch_prob): Free the dominators.\n+\n 2003-12-30  Jan Hubicka  <jh@suse.cz>\n \n \tPR target/13456"}, {"sha": "bd65e0bf67ed9296b13e0b21c122679b7d8f758d", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d47cc544b60738db5e983c4b1ac6b40236b9633c/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d47cc544b60738db5e983c4b1ac6b40236b9633c/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=d47cc544b60738db5e983c4b1ac6b40236b9633c", "patch": "@@ -1322,7 +1322,7 @@ c-convert.o : c-convert.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H)\n c-pragma.o: c-pragma.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \\\n     function.h c-pragma.h toplev.h output.h $(GGC_H) $(TM_P_H) $(C_COMMON_H) gt-c-pragma.h\n graph.o: graph.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) toplev.h flags.h output.h \\\n-    $(RTL_H) function.h hard-reg-set.h $(BASIC_BLOCK_H) graph.h\n+    $(RTL_H) function.h langhooks.h hard-reg-set.h $(BASIC_BLOCK_H) graph.h $(TREE_H)\n sbitmap.o: sbitmap.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) flags.h \\\n     hard-reg-set.h $(BASIC_BLOCK_H)\n \n@@ -1651,7 +1651,7 @@ web.o : web.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(REGS_H) \\\n    hard-reg-set.h flags.h $(BASIC_BLOCK_H) function.h output.h toplev.h df.h\n gcse.o : gcse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(REGS_H) \\\n    hard-reg-set.h flags.h real.h insn-config.h $(GGC_H) $(RECOG_H) $(EXPR_H) \\\n-   $(BASIC_BLOCK_H) function.h output.h toplev.h $(TM_P_H) $(PARAMS_H) \\\n+   $(BASIC_BLOCK_H) function.h langhooks.h output.h toplev.h $(TM_P_H) $(PARAMS_H) \\\n    except.h gt-gcse.h $(TREE_H)\n sibcall.o : sibcall.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(REGS_H) \\\n    function.h hard-reg-set.h flags.h insn-config.h $(RECOG_H) $(BASIC_BLOCK_H)"}, {"sha": "2e8f5786348c8f1f42120f792232f64cea6cf39e", "filename": "gcc/basic-block.h", "status": "modified", "additions": 29, "deletions": 17, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d47cc544b60738db5e983c4b1ac6b40236b9633c/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d47cc544b60738db5e983c4b1ac6b40236b9633c/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=d47cc544b60738db5e983c4b1ac6b40236b9633c", "patch": "@@ -234,6 +234,9 @@ typedef struct basic_block_def {\n   /* Outermost loop containing the block.  */\n   struct loop *loop_father;\n \n+  /* The dominance and postdominance information node.  */\n+  struct et_node *dom[2];\n+\n   /* Expected number of executions: calculated in profile.c.  */\n   gcov_type count;\n \n@@ -373,10 +376,6 @@ extern void clear_edges (void);\n extern void mark_critical_edges (void);\n extern rtx first_insn_after_basic_block_note (basic_block);\n \n-/* Dominator information for basic blocks.  */\n-\n-typedef struct dominance_info *dominance_info;\n-\n /* Structure to group all of the information to process IF-THEN and\n    IF-THEN-ELSE blocks for the conditional execution support.  This\n    needs to be in a public file in case the IFCVT macros call\n@@ -612,22 +611,35 @@ enum cdi_direction\n   CDI_POST_DOMINATORS\n };\n \n-extern dominance_info calculate_dominance_info (enum cdi_direction);\n-extern void free_dominance_info (dominance_info);\n-extern basic_block nearest_common_dominator (dominance_info,\n+enum dom_state\n+{\n+  DOM_NONE,\t\t/* Not computed at all.  */\n+  DOM_CONS_OK,\t\t/* The data is conservatively OK, i.e. if it says you that A dominates B,\n+\t\t\t   it indeed does.  */\n+  DOM_NO_FAST_QUERY,\t/* The data is OK, but the fast query data are not usable.  */\n+  DOM_OK\t\t/* Everything is ok.  */\n+};\n+\n+extern enum dom_state dom_computed[2];\n+\n+extern void calculate_dominance_info (enum cdi_direction);\n+extern void free_dominance_info (enum cdi_direction);\n+extern basic_block nearest_common_dominator (enum cdi_direction,\n \t\t\t\t\t     basic_block, basic_block);\n-extern void set_immediate_dominator (dominance_info, basic_block,\n+extern void set_immediate_dominator (enum cdi_direction, basic_block,\n \t\t\t\t     basic_block);\n-extern basic_block get_immediate_dominator (dominance_info, basic_block);\n-extern bool dominated_by_p (dominance_info, basic_block, basic_block);\n-extern int get_dominated_by (dominance_info, basic_block, basic_block **);\n-extern void add_to_dominance_info (dominance_info, basic_block);\n-extern void delete_from_dominance_info (dominance_info, basic_block);\n-basic_block recount_dominator (dominance_info, basic_block);\n-extern void redirect_immediate_dominators (dominance_info, basic_block,\n+extern basic_block get_immediate_dominator (enum cdi_direction, basic_block);\n+extern bool dominated_by_p (enum cdi_direction, basic_block, basic_block);\n+extern int get_dominated_by (enum cdi_direction, basic_block, basic_block **);\n+extern void add_to_dominance_info (enum cdi_direction, basic_block);\n+extern void delete_from_dominance_info (enum cdi_direction, basic_block);\n+basic_block recount_dominator (enum cdi_direction, basic_block);\n+extern void redirect_immediate_dominators (enum cdi_direction, basic_block,\n \t\t\t\t\t   basic_block);\n-void iterate_fix_dominators (dominance_info, basic_block *, int);\n-extern void verify_dominators (dominance_info);\n+extern void iterate_fix_dominators (enum cdi_direction, basic_block *, int);\n+extern void verify_dominators (enum cdi_direction);\n+extern basic_block first_dom_son (enum cdi_direction, basic_block);\n+extern basic_block next_dom_son (enum cdi_direction, basic_block);\n \n #include \"cfghooks.h\"\n "}, {"sha": "2a68cd76bdbd148280298e2a92d7c31e30a1a52a", "filename": "gcc/bt-load.c", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d47cc544b60738db5e983c4b1ac6b40236b9633c/gcc%2Fbt-load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d47cc544b60738db5e983c4b1ac6b40236b9633c/gcc%2Fbt-load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbt-load.c?ref=d47cc544b60738db5e983c4b1ac6b40236b9633c", "patch": "@@ -155,9 +155,6 @@ static void note_btr_set (rtx, rtx, void *);\n    migrating branch target load instructions.  */\n static struct obstack migrate_btrl_obstack;\n \n-/* Basic block dominator information used when migrating PT instructions.  */\n-static dominance_info dom;\n-\n /* Array indexed by basic block number, giving the set of registers\n    live in that block.  */\n static HARD_REG_SET *btrs_live;\n@@ -840,9 +837,9 @@ augment_live_range (bitmap live_range, HARD_REG_SET *btrs_live_in_range,\n \n   tos = worklist = xmalloc (sizeof (basic_block) * (n_basic_blocks + 1));\n \n-  if (dominated_by_p (dom, new_bb, head_bb))\n+  if (dominated_by_p (CDI_DOMINATORS, new_bb, head_bb))\n     *tos++ = new_bb;\n-  else if (dominated_by_p (dom, head_bb, new_bb))\n+  else if (dominated_by_p (CDI_DOMINATORS, head_bb, new_bb))\n     {\n       edge e;\n       int new_block = new_bb->index;\n@@ -974,7 +971,7 @@ combine_btr_defs (btr_def def, HARD_REG_SET *btrs_live_in_range)\n       if (other_def != def\n \t  && other_def->uses != NULL\n \t  && ! other_def->has_ambiguous_use\n-\t  && dominated_by_p (dom, other_def->bb, def->bb))\n+\t  && dominated_by_p (CDI_DOMINATORS, other_def->bb, def->bb))\n \t{\n \t  /* def->bb dominates the other def, so def and other_def could\n \t     be combined.  */\n@@ -1226,9 +1223,9 @@ migrate_btr_def (btr_def def, int min_cost)\n \n   def_basic_block_freq = basic_block_freq (def->bb);\n \n-  for (try = get_immediate_dominator (dom, def->bb);\n+  for (try = get_immediate_dominator (CDI_DOMINATORS, def->bb);\n        !give_up && try && try != ENTRY_BLOCK_PTR && def->cost >= min_cost;\n-       try = get_immediate_dominator (dom, try))\n+       try = get_immediate_dominator (CDI_DOMINATORS, try))\n     {\n       /* Try to move the instruction that sets the target register into\n \t basic block TRY.  */\n@@ -1299,7 +1296,7 @@ migrate_btr_defs (enum reg_class btr_class, int allow_callee_save)\n \t    \"Basic block %d: count = \" HOST_WIDEST_INT_PRINT_DEC\n \t    \" loop-depth = %d idom = %d\\n\",\n \t    i, (HOST_WIDEST_INT) bb->count, bb->loop_depth,\n-\t    get_immediate_dominator (dom, bb)->index);\n+\t    get_immediate_dominator (CDI_DOMINATORS, bb)->index);\n \t}\n     }\n \n@@ -1367,12 +1364,12 @@ branch_target_load_optimize (rtx insns, bool after_prologue_epilogue_gen)\n       life_analysis (insns, NULL, 0);\n \n       /* Dominator info is also needed for migrate_btr_def.  */\n-      dom = calculate_dominance_info (CDI_DOMINATORS);\n+      calculate_dominance_info (CDI_DOMINATORS);\n       migrate_btr_defs (class,\n \t\t       ((*targetm.branch_target_register_callee_saved)\n \t\t\t(after_prologue_epilogue_gen)));\n \n-      free_dominance_info (dom);\n+      free_dominance_info (CDI_DOMINATORS);\n \n       update_life_info (NULL, UPDATE_LIFE_GLOBAL_RM_NOTES,\n \t\t\tPROP_DEATH_NOTES | PROP_REG_INFO);"}, {"sha": "96dac25d0ac540ef0c82e317fb2c3a7751d8b75c", "filename": "gcc/cfg.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d47cc544b60738db5e983c4b1ac6b40236b9633c/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d47cc544b60738db5e983c4b1ac6b40236b9633c/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=d47cc544b60738db5e983c4b1ac6b40236b9633c", "patch": "@@ -111,6 +111,7 @@ struct basic_block_def entry_exit_blocks[2]\n     EXIT_BLOCK_PTR,\t\t/* next_bb */\n     0,\t\t\t\t/* loop_depth */\n     NULL,                       /* loop_father */\n+    { NULL, NULL },\t\t/* dom */\n     0,\t\t\t\t/* count */\n     0,\t\t\t\t/* frequency */\n     0,\t\t\t\t/* flags */\n@@ -133,6 +134,7 @@ struct basic_block_def entry_exit_blocks[2]\n     NULL,\t\t\t/* next_bb */\n     0,\t\t\t\t/* loop_depth */\n     NULL,                       /* loop_father */\n+    { NULL, NULL },\t\t/* dom */\n     0,\t\t\t\t/* count */\n     0,\t\t\t\t/* frequency */\n     0,\t\t\t\t/* flags */"}, {"sha": "15ec054745122fcbf5bcd3a8b055ffacfab701c6", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d47cc544b60738db5e983c4b1ac6b40236b9633c/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d47cc544b60738db5e983c4b1ac6b40236b9633c/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=d47cc544b60738db5e983c4b1ac6b40236b9633c", "patch": "@@ -1253,7 +1253,7 @@ can_copy_bbs_p (basic_block *bbs, unsigned n)\n void\n copy_bbs (basic_block *bbs, unsigned n, basic_block *new_bbs,\n \t  edge *edges, unsigned n_edges, edge *new_edges,\n-\t  struct loop *base, struct loops *loops)\n+\t  struct loop *base)\n {\n   unsigned i, j;\n   basic_block bb, new_bb, dom_bb;\n@@ -1268,7 +1268,7 @@ copy_bbs (basic_block *bbs, unsigned n, basic_block *new_bbs,\n       bb->rbi->duplicated = 1;\n       /* Add to loop.  */\n       add_bb_to_loop (new_bb, bb->loop_father->copy);\n-      add_to_dominance_info (loops->cfg.dom, new_bb);\n+      add_to_dominance_info (CDI_DOMINATORS, new_bb);\n       /* Possibly set header.  */\n       if (bb->loop_father->header == bb && bb->loop_father != base)\n \tnew_bb->loop_father->header = new_bb;\n@@ -1283,11 +1283,11 @@ copy_bbs (basic_block *bbs, unsigned n, basic_block *new_bbs,\n       bb = bbs[i];\n       new_bb = new_bbs[i];\n \n-      dom_bb = get_immediate_dominator (loops->cfg.dom, bb);\n+      dom_bb = get_immediate_dominator (CDI_DOMINATORS, bb);\n       if (dom_bb->rbi->duplicated)\n \t{\n \t  dom_bb = dom_bb->rbi->copy;\n-\t  set_immediate_dominator (loops->cfg.dom, new_bb, dom_bb);\n+\t  set_immediate_dominator (CDI_DOMINATORS, new_bb, dom_bb);\n \t}\n     }\n "}, {"sha": "ca79e26c433fbabf61b4cc26555ebef5d7375b74", "filename": "gcc/cfglayout.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d47cc544b60738db5e983c4b1ac6b40236b9633c/gcc%2Fcfglayout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d47cc544b60738db5e983c4b1ac6b40236b9633c/gcc%2Fcfglayout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.h?ref=d47cc544b60738db5e983c4b1ac6b40236b9633c", "patch": "@@ -43,5 +43,5 @@ extern void insn_locators_initialize (void);\n extern void reemit_insn_block_notes (void);\n extern bool can_copy_bbs_p (basic_block *, unsigned);\n extern void copy_bbs (basic_block *, unsigned, basic_block *,\n-\t\t      edge *, unsigned, edge *, struct loop *, struct loops *);\n-extern void cfg_layout_initialize_rbi\t(basic_block);\n+\t\t      edge *, unsigned, edge *, struct loop *);\n+extern void cfg_layout_initialize_rbi (basic_block);"}, {"sha": "43c52f23ddb7d0906b01ee78b6584e905989edef", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 17, "deletions": 24, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d47cc544b60738db5e983c4b1ac6b40236b9633c/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d47cc544b60738db5e983c4b1ac6b40236b9633c/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=d47cc544b60738db5e983c4b1ac6b40236b9633c", "patch": "@@ -38,7 +38,7 @@ static void flow_loop_entry_edges_find (struct loop *);\n static void flow_loop_exit_edges_find (struct loop *);\n static int flow_loop_nodes_find (basic_block, struct loop *);\n static void flow_loop_pre_header_scan (struct loop *);\n-static basic_block flow_loop_pre_header_find (basic_block, dominance_info);\n+static basic_block flow_loop_pre_header_find (basic_block);\n static int flow_loop_level_compute (struct loop *);\n static int flow_loops_level_compute (struct loops *);\n static void establish_preds (struct loop *);\n@@ -55,7 +55,7 @@ flow_loops_cfg_dump (const struct loops *loops, FILE *file)\n   int i;\n   basic_block bb;\n \n-  if (! loops->num || ! file || ! loops->cfg.dom)\n+  if (! loops->num || ! file)\n     return;\n \n   FOR_EACH_BB (bb)\n@@ -212,9 +212,6 @@ flow_loops_free (struct loops *loops)\n       free (loops->parray);\n       loops->parray = NULL;\n \n-      if (loops->cfg.dom)\n-\tfree_dominance_info (loops->cfg.dom);\n-\n       if (loops->cfg.dfs_order)\n \tfree (loops->cfg.dfs_order);\n       if (loops->cfg.rc_order)\n@@ -391,11 +388,10 @@ flow_loop_pre_header_scan (struct loop *loop)\n }\n \n /* Return the block for the pre-header of the loop with header\n-   HEADER where DOM specifies the dominator information.  Return NULL if\n-   there is no pre-header.  */\n+   HEADER.  Return NULL if there is no pre-header.  */\n \n static basic_block\n-flow_loop_pre_header_find (basic_block header, dominance_info dom)\n+flow_loop_pre_header_find (basic_block header)\n {\n   basic_block pre_header;\n   edge e;\n@@ -408,7 +404,7 @@ flow_loop_pre_header_find (basic_block header, dominance_info dom)\n       basic_block node = e->src;\n \n       if (node != ENTRY_BLOCK_PTR\n-\t  && ! dominated_by_p (dom, node, header))\n+\t  && ! dominated_by_p (CDI_DOMINATORS, node, header))\n \t{\n \t  if (pre_header == NULL)\n \t    pre_header = node;\n@@ -522,7 +518,7 @@ flow_loops_level_compute (struct loops *loops)\n    about it specified by FLAGS.  */\n \n int\n-flow_loop_scan (struct loops *loops, struct loop *loop, int flags)\n+flow_loop_scan (struct loop *loop, int flags)\n {\n   if (flags & LOOP_ENTRY_EDGES)\n     {\n@@ -541,8 +537,7 @@ flow_loop_scan (struct loops *loops, struct loop *loop, int flags)\n   if (flags & LOOP_PRE_HEADER)\n     {\n       /* Look to see if the loop has a pre-header node.  */\n-      loop->pre_header\n-\t= flow_loop_pre_header_find (loop->header, loops->cfg.dom);\n+      loop->pre_header = flow_loop_pre_header_find (loop->header);\n \n       /* Find the blocks within the extended basic block of\n \t the loop pre-header.  */\n@@ -627,12 +622,11 @@ make_forwarder_block (basic_block bb, int redirect_latch, int redirect_nonlatch,\n static void\n canonicalize_loop_headers (void)\n {\n-  dominance_info dom;\n   basic_block header;\n   edge e;\n \n   /* Compute the dominators.  */\n-  dom = calculate_dominance_info (CDI_DOMINATORS);\n+  calculate_dominance_info (CDI_DOMINATORS);\n \n   alloc_aux_for_blocks (sizeof (int));\n   alloc_aux_for_edges (sizeof (int));\n@@ -651,7 +645,7 @@ canonicalize_loop_headers (void)\n \t    have_abnormal_edge = 1;\n \n \t  if (latch != ENTRY_BLOCK_PTR\n-\t      && dominated_by_p (dom, latch, header))\n+\t      && dominated_by_p (CDI_DOMINATORS, latch, header))\n \t    {\n \t      num_latches++;\n \t      LATCH_EDGE (e) = 1;\n@@ -663,6 +657,8 @@ canonicalize_loop_headers (void)\n \tHEADER_BLOCK (header) = num_latches;\n     }\n \n+  free_dominance_info (CDI_DOMINATORS);\n+\n   if (HEADER_BLOCK (ENTRY_BLOCK_PTR->succ->dest))\n     {\n       basic_block bb;\n@@ -728,7 +724,6 @@ canonicalize_loop_headers (void)\n \n   free_aux_for_blocks ();\n   free_aux_for_edges ();\n-  free_dominance_info (dom);\n }\n \n /* Find all the natural loops in the function and save in LOOPS structure and\n@@ -744,7 +739,6 @@ flow_loops_find (struct loops *loops, int flags)\n   int num_loops;\n   edge e;\n   sbitmap headers;\n-  dominance_info dom;\n   int *dfs_order;\n   int *rc_order;\n   basic_block header;\n@@ -770,7 +764,7 @@ flow_loops_find (struct loops *loops, int flags)\n   canonicalize_loop_headers ();\n \n   /* Compute the dominators.  */\n-  dom = loops->cfg.dom = calculate_dominance_info (CDI_DOMINATORS);\n+  calculate_dominance_info (CDI_DOMINATORS);\n \n   /* Count the number of loop headers.  This should be the\n      same as the number of natural loops.  */\n@@ -804,7 +798,8 @@ flow_loops_find (struct loops *loops, int flags)\n \t     node (header) that dominates all the nodes in the\n \t     loop.  It also has single back edge to the header\n \t     from a latch node.  */\n-\t  if (latch != ENTRY_BLOCK_PTR && dominated_by_p (dom, latch, header))\n+\t  if (latch != ENTRY_BLOCK_PTR\n+\t      && dominated_by_p (CDI_DOMINATORS, latch, header))\n \t    {\n \t      /* Shared headers should be eliminated by now.  */\n \t      if (more_latches)\n@@ -849,7 +844,6 @@ flow_loops_find (struct loops *loops, int flags)\n       flow_depth_first_order_compute (dfs_order, rc_order);\n \n       /* Save CFG derived information to avoid recomputing it.  */\n-      loops->cfg.dom = dom;\n       loops->cfg.dfs_order = dfs_order;\n       loops->cfg.rc_order = rc_order;\n \n@@ -878,7 +872,7 @@ flow_loops_find (struct loops *loops, int flags)\n \t      basic_block latch = e->src;\n \n \t      if (latch != ENTRY_BLOCK_PTR\n-\t\t  && dominated_by_p (dom, latch, header))\n+\t\t  && dominated_by_p (CDI_DOMINATORS, latch, header))\n \t\t{\n \t\t  loop->latch = latch;\n \t\t  break;\n@@ -897,14 +891,13 @@ flow_loops_find (struct loops *loops, int flags)\n \n       /* Scan the loops.  */\n       for (i = 1; i < num_loops; i++)\n-\tflow_loop_scan (loops, loops->parray[i], flags);\n+\tflow_loop_scan (loops->parray[i], flags);\n \n       loops->num = num_loops;\n     }\n   else\n     {\n-      loops->cfg.dom = NULL;\n-      free_dominance_info (dom);\n+      free_dominance_info (CDI_DOMINATORS);\n     }\n \n   loops->state = 0;"}, {"sha": "4d8c67dd35d357ab059d27850c891660eb9f8028", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d47cc544b60738db5e983c4b1ac6b40236b9633c/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d47cc544b60738db5e983c4b1ac6b40236b9633c/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=d47cc544b60738db5e983c4b1ac6b40236b9633c", "patch": "@@ -230,9 +230,6 @@ struct loops\n   /* Information derived from the CFG.  */\n   struct cfg\n   {\n-    /* The bitmap vector of dominators or NULL if not computed.  */\n-    dominance_info dom;\n-\n     /* The ordering of the basic blocks in a depth first search.  */\n     int *dfs_order;\n \n@@ -265,7 +262,7 @@ extern void flow_loops_dump (const struct loops *, FILE *,\n \t\t\t     void (*)(const struct loop *, FILE *, int), int);\n extern void flow_loop_dump (const struct loop *, FILE *,\n \t\t\t    void (*)(const struct loop *, FILE *, int), int);\n-extern int flow_loop_scan (struct loops *, struct loop *, int);\n+extern int flow_loop_scan (struct loop *, int);\n extern void flow_loop_free (struct loop *);\n void mark_irreducible_loops (struct loops *);\n \n@@ -292,7 +289,7 @@ extern void remove_bb_from_loops (basic_block);\n extern void cancel_loop (struct loops *, struct loop *);\n extern void cancel_loop_tree (struct loops *, struct loop *);\n \n-extern basic_block loop_split_edge_with (edge, rtx, struct loops *);\n+extern basic_block loop_split_edge_with (edge, rtx);\n extern int fix_loop_placement (struct loop *);\n \n enum\n@@ -306,10 +303,9 @@ extern void force_single_succ_latches (struct loops *);\n extern void verify_loop_structure (struct loops *);\n \n /* Loop analysis.  */\n-extern bool simple_loop_p (struct loops *, struct loop *, struct loop_desc *);\n+extern bool simple_loop_p (struct loop *, struct loop_desc *);\n extern rtx count_loop_iterations (struct loop_desc *, rtx, rtx);\n-extern bool just_once_each_iteration_p (struct loops *,struct loop *,\n-\t\t\t\t\tbasic_block);\n+extern bool just_once_each_iteration_p (struct loop *, basic_block);\n extern unsigned expected_loop_iterations (const struct loop *);\n \n /* Loop manipulation.  */\n@@ -324,7 +320,7 @@ extern int duplicate_loop_to_header_edge (struct loop *, edge, struct loops *,\n extern struct loop *loopify (struct loops *, edge, edge, basic_block);\n extern void unloop (struct loops *, struct loop *);\n extern bool remove_path (struct loops *, edge);\n-extern edge split_loop_bb (struct loops *, basic_block, rtx);\n+extern edge split_loop_bb (basic_block, rtx);\n \n /* Loop optimizer initialization.  */\n extern struct loops *loop_optimizer_init (FILE *);"}, {"sha": "fb5f8ae6c6b820a3d609499bcc77b00dab3bb202", "filename": "gcc/cfgloopanal.c", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d47cc544b60738db5e983c4b1ac6b40236b9633c/gcc%2Fcfgloopanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d47cc544b60738db5e983c4b1ac6b40236b9633c/gcc%2Fcfgloopanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopanal.c?ref=d47cc544b60738db5e983c4b1ac6b40236b9633c", "patch": "@@ -39,14 +39,13 @@ static bool invariant_rtx_wrto_regs_p (rtx, regset);\n static rtx test_for_iteration (struct loop_desc *desc, unsigned HOST_WIDE_INT);\n static bool constant_iterations (struct loop_desc *, unsigned HOST_WIDE_INT *,\n \t\t\t\t bool *);\n-static bool simple_loop_exit_p (struct loops *, struct loop *, edge, regset,\n+static bool simple_loop_exit_p (struct loop *, edge, regset,\n \t\t\t\trtx *, struct loop_desc *);\n static rtx variable_initial_value (rtx, regset, rtx, rtx *, enum machine_mode);\n static rtx variable_initial_values (edge, rtx, enum machine_mode);\n static bool simple_condition_p (struct loop *, rtx, regset,\n \t\t\t\tstruct loop_desc *);\n-static basic_block simple_increment (struct loops *, struct loop *, rtx *,\n-\t\t\t\t     struct loop_desc *);\n+static basic_block simple_increment (struct loop *, rtx *, struct loop_desc *);\n static rtx count_strange_loop_iterations (rtx, rtx, enum rtx_code,\n \t\t\t\t\t  int, rtx, enum machine_mode,\n \t\t\t\t\t  enum machine_mode);\n@@ -73,10 +72,10 @@ inverse (unsigned HOST_WIDEST_INT x, int mod)\n \n /* Checks whether BB is executed exactly once in each LOOP iteration.  */\n bool\n-just_once_each_iteration_p (struct loops *loops, struct loop *loop, basic_block bb)\n+just_once_each_iteration_p (struct loop *loop, basic_block bb)\n {\n   /* It must be executed at least once each iteration.  */\n-  if (!dominated_by_p (loops->cfg.dom, loop->latch, bb))\n+  if (!dominated_by_p (CDI_DOMINATORS, loop->latch, bb))\n     return false;\n \n   /* And just once.  */\n@@ -295,8 +294,8 @@ simple_condition_p (struct loop *loop ATTRIBUTE_UNUSED, rtx condition,\n    iteration.  Fills in DESC->stride and returns block in that DESC->var is\n    modified.  */\n static basic_block\n-simple_increment (struct loops *loops, struct loop *loop,\n-\t\t  rtx *simple_increment_regs, struct loop_desc *desc)\n+simple_increment (struct loop *loop, rtx *simple_increment_regs,\n+\t\t  struct loop_desc *desc)\n {\n   rtx mod_insn, mod_insn1, set, set_src, set_add;\n   basic_block mod_bb, mod_bb1;\n@@ -308,7 +307,7 @@ simple_increment (struct loops *loops, struct loop *loop,\n   mod_bb = BLOCK_FOR_INSN (mod_insn);\n \n   /* Check that it is executed exactly once each iteration.  */\n-  if (!just_once_each_iteration_p (loops, loop, mod_bb))\n+  if (!just_once_each_iteration_p (loop, mod_bb))\n     return NULL;\n \n   /* mod_insn must be a simple increment/decrement.  */\n@@ -355,7 +354,7 @@ simple_increment (struct loops *loops, struct loop *loop,\n \treturn NULL;\n \n       mod_bb1 = BLOCK_FOR_INSN (mod_insn1);\n-      if (!dominated_by_p (loops->cfg.dom, mod_bb, mod_bb1))\n+      if (!dominated_by_p (CDI_DOMINATORS, mod_bb, mod_bb1))\n \treturn NULL;\n       if (mod_bb1 == mod_bb)\n \t{\n@@ -962,7 +961,7 @@ test_for_iteration (struct loop_desc *desc, unsigned HOST_WIDE_INT iter)\n    description joined to it in in DESC.  INVARIANT_REGS and SINGLE_SET_REGS\n    are results of blocks_{invariant,single_set}_regs over BODY.  */\n static bool\n-simple_loop_exit_p (struct loops *loops, struct loop *loop, edge exit_edge,\n+simple_loop_exit_p (struct loop *loop, edge exit_edge,\n \t\t    regset invariant_regs, rtx *single_set_regs,\n \t\t    struct loop_desc *desc)\n {\n@@ -979,7 +978,7 @@ simple_loop_exit_p (struct loops *loops, struct loop *loop, edge exit_edge,\n     return false;\n \n   /* It must be tested (at least) once during any iteration.  */\n-  if (!dominated_by_p (loops->cfg.dom, loop->latch, exit_bb))\n+  if (!dominated_by_p (CDI_DOMINATORS, loop->latch, exit_bb))\n     return false;\n \n   /* It must end in a simple conditional jump.  */\n@@ -1003,11 +1002,11 @@ simple_loop_exit_p (struct loops *loops, struct loop *loop, edge exit_edge,\n \n   /*  Var must be simply incremented or decremented in exactly one insn that\n      is executed just once every iteration.  */\n-  if (!(mod_bb = simple_increment (loops, loop, single_set_regs, desc)))\n+  if (!(mod_bb = simple_increment (loop, single_set_regs, desc)))\n     return false;\n \n   /* OK, it is simple loop.  Now just fill in remaining info.  */\n-  desc->postincr = !dominated_by_p (loops->cfg.dom, exit_bb, mod_bb);\n+  desc->postincr = !dominated_by_p (CDI_DOMINATORS, exit_bb, mod_bb);\n   desc->neg = !fallthru_out;\n \n   /* Find initial value of var and alternative values for lim.  */\n@@ -1026,7 +1025,7 @@ simple_loop_exit_p (struct loops *loops, struct loop *loop, edge exit_edge,\n /* Tests whether LOOP is simple for loop.  Returns simple loop description\n    in DESC.  */\n bool\n-simple_loop_p (struct loops *loops, struct loop *loop, struct loop_desc *desc)\n+simple_loop_p (struct loop *loop, struct loop_desc *desc)\n {\n   unsigned i;\n   basic_block *body;\n@@ -1051,7 +1050,7 @@ simple_loop_p (struct loops *loops, struct loop *loop, struct loop_desc *desc)\n     {\n       for (e = body[i]->succ; e; e = e->succ_next)\n \tif (!flow_bb_inside_loop_p (loop, e->dest)\n-\t    && simple_loop_exit_p (loops, loop, e,\n+\t    && simple_loop_exit_p (loop, e,\n \t\t   invariant_regs, single_set_regs, &act))\n \t  {\n \t    /* Prefer constant iterations; the less the better.  */"}, {"sha": "86af4a2536b7027088a29a2c9aaa0ae4f94bc367", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 57, "deletions": 76, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d47cc544b60738db5e983c4b1ac6b40236b9633c/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d47cc544b60738db5e983c4b1ac6b40236b9633c/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=d47cc544b60738db5e983c4b1ac6b40236b9633c", "patch": "@@ -36,9 +36,9 @@ static void copy_loops_to (struct loops *, struct loop **, int,\n \t\t\t   struct loop *);\n static void loop_redirect_edge (edge, basic_block);\n static bool loop_delete_branch_edge (edge, int);\n-static void remove_bbs (dominance_info, basic_block *, int);\n+static void remove_bbs (basic_block *, int);\n static bool rpe_enum_p (basic_block, void *);\n-static int find_path (edge, dominance_info, basic_block **);\n+static int find_path (edge, basic_block **);\n static bool alp_enum_p (basic_block, void *);\n static void add_loop (struct loops *, struct loop *);\n static void fix_loop_placements (struct loop *);\n@@ -47,17 +47,15 @@ static void fix_bb_placements (struct loops *, basic_block);\n static void place_new_loop (struct loops *, struct loop *);\n static void scale_loop_frequencies (struct loop *, int, int);\n static void scale_bbs_frequencies (basic_block *, int, int, int);\n-static basic_block create_preheader (struct loop *, dominance_info, int);\n+static basic_block create_preheader (struct loop *, int);\n static void fix_irreducible_loops (basic_block);\n \n /* Splits basic block BB after INSN, returns created edge.  Updates loops\n    and dominators.  */\n edge\n-split_loop_bb (struct loops *loops, basic_block bb, rtx insn)\n+split_loop_bb (basic_block bb, rtx insn)\n {\n   edge e;\n-  basic_block *dom_bbs;\n-  int n_dom_bbs, i;\n \n   /* Split the block.  */\n   e = split_block (bb, insn);\n@@ -66,42 +64,31 @@ split_loop_bb (struct loops *loops, basic_block bb, rtx insn)\n   add_bb_to_loop (e->dest, e->src->loop_father);\n \n   /* Fix dominators.  */\n-  add_to_dominance_info (loops->cfg.dom, e->dest);\n-  n_dom_bbs = get_dominated_by (loops->cfg.dom, e->src, &dom_bbs);\n-  for (i = 0; i < n_dom_bbs; i++)\n-    set_immediate_dominator (loops->cfg.dom, dom_bbs[i], e->dest);\n-  free (dom_bbs);\n-  set_immediate_dominator (loops->cfg.dom, e->dest, e->src);\n+  add_to_dominance_info (CDI_DOMINATORS, e->dest);\n+  redirect_immediate_dominators (CDI_DOMINATORS, e->src, e->dest);\n+  set_immediate_dominator (CDI_DOMINATORS, e->dest, e->src);\n \n   return e;\n }\n \n-/* Checks whether basic block BB is dominated by RPE->DOM, where\n-   RPE is passed through DATA.  */\n-struct rpe_data\n- {\n-   basic_block dom;\n-   dominance_info doms;\n- };\n-\n+/* Checks whether basic block BB is dominated by DATA.  */\n static bool\n rpe_enum_p (basic_block bb, void *data)\n {\n-  struct rpe_data *rpe = data;\n-  return dominated_by_p (rpe->doms, bb, rpe->dom);\n+  return dominated_by_p (CDI_DOMINATORS, bb, data);\n }\n \n /* Remove basic blocks BBS from loop structure and dominance info,\n    and delete them afterwards.  */\n static void\n-remove_bbs (dominance_info dom, basic_block *bbs, int nbbs)\n+remove_bbs (basic_block *bbs, int nbbs)\n {\n   int i;\n \n   for (i = 0; i < nbbs; i++)\n     {\n       remove_bb_from_loops (bbs[i]);\n-      delete_from_dominance_info (dom, bbs[i]);\n+      delete_from_dominance_info (CDI_DOMINATORS, bbs[i]);\n       delete_block (bbs[i]);\n     }\n }\n@@ -113,19 +100,15 @@ remove_bbs (dominance_info dom, basic_block *bbs, int nbbs)\n    alter anything by this function).  The number of basic blocks in the\n    path is returned.  */\n static int\n-find_path (edge e, dominance_info doms, basic_block **bbs)\n+find_path (edge e, basic_block **bbs)\n {\n-  struct rpe_data rpe;\n-\n   if (e->dest->pred->pred_next)\n     abort ();\n \n   /* Find bbs in the path.  */\n-  rpe.dom = e->dest;\n-  rpe.doms = doms;\n   *bbs = xcalloc (n_basic_blocks, sizeof (basic_block));\n   return dfs_enumerate_from (e->dest, 0, rpe_enum_p, *bbs,\n-\t\t\t     n_basic_blocks, &rpe);\n+\t\t\t     n_basic_blocks, e->dest);\n }\n \n /* Fix placement of basic block BB inside loop hierarchy stored in LOOPS --\n@@ -353,19 +336,19 @@ remove_path (struct loops *loops, edge e)\n      fix -- when e->dest has exactly one predecessor, this corresponds\n      to blocks dominated by e->dest, if not, split the edge.  */\n   if (e->dest->pred->pred_next)\n-    e = loop_split_edge_with (e, NULL_RTX, loops)->pred;\n+    e = loop_split_edge_with (e, NULL_RTX)->pred;\n \n   /* It may happen that by removing path we remove one or more loops\n      we belong to.  In this case first unloop the loops, then proceed\n      normally.   We may assume that e->dest is not a header of any loop,\n      as it now has exactly one predecessor.  */\n   while (e->src->loop_father->outer\n-\t && dominated_by_p (loops->cfg.dom,\n+\t && dominated_by_p (CDI_DOMINATORS,\n \t\t\t    e->src->loop_father->latch, e->dest))\n     unloop (loops, e->src->loop_father);\n \n   /* Identify the path.  */\n-  nrem = find_path (e, loops->cfg.dom, &rem_bbs);\n+  nrem = find_path (e, &rem_bbs);\n \n   n_bord_bbs = 0;\n   bord_bbs = xcalloc (n_basic_blocks, sizeof (basic_block));\n@@ -397,33 +380,32 @@ remove_path (struct loops *loops, edge e)\n     if (rem_bbs[i]->loop_father->header == rem_bbs[i])\n       cancel_loop_tree (loops, rem_bbs[i]->loop_father);\n \n-  remove_bbs (loops->cfg.dom, rem_bbs, nrem);\n+  remove_bbs (rem_bbs, nrem);\n   free (rem_bbs);\n \n   /* Find blocks whose dominators may be affected.  */\n   n_dom_bbs = 0;\n   sbitmap_zero (seen);\n   for (i = 0; i < n_bord_bbs; i++)\n     {\n-      int j, nldom;\n-      basic_block *ldom;\n+      basic_block ldom;\n \n-      bb = get_immediate_dominator (loops->cfg.dom, bord_bbs[i]);\n+      bb = get_immediate_dominator (CDI_DOMINATORS, bord_bbs[i]);\n       if (TEST_BIT (seen, bb->index))\n \tcontinue;\n       SET_BIT (seen, bb->index);\n \n-      nldom = get_dominated_by (loops->cfg.dom, bb, &ldom);\n-      for (j = 0; j < nldom; j++)\n-\tif (!dominated_by_p (loops->cfg.dom, from, ldom[j]))\n-\t  dom_bbs[n_dom_bbs++] = ldom[j];\n-      free(ldom);\n+      for (ldom = first_dom_son (CDI_DOMINATORS, bb);\n+\t   ldom;\n+\t   ldom = next_dom_son (CDI_DOMINATORS, ldom))\n+\tif (!dominated_by_p (CDI_DOMINATORS, from, ldom))\n+\t  dom_bbs[n_dom_bbs++] = ldom;\n     }\n \n   free (seen);\n \n   /* Recount dominators.  */\n-  iterate_fix_dominators (loops->cfg.dom, dom_bbs, n_dom_bbs);\n+  iterate_fix_dominators (CDI_DOMINATORS, dom_bbs, n_dom_bbs);\n   free (dom_bbs);\n \n   /* These blocks have lost some predecessor(s), thus their irreducible\n@@ -513,7 +495,7 @@ loopify (struct loops *loops, edge latch_edge, edge header_edge, basic_block swi\n   basic_block succ_bb = latch_edge->dest;\n   basic_block pred_bb = header_edge->src;\n   basic_block *dom_bbs, *body;\n-  unsigned n_dom_bbs, i, j;\n+  unsigned n_dom_bbs, i;\n   sbitmap seen;\n   struct loop *loop = xcalloc (1, sizeof (struct loop));\n   struct loop *outer = succ_bb->loop_father->outer;\n@@ -538,9 +520,9 @@ loopify (struct loops *loops, edge latch_edge, edge header_edge, basic_block swi\n   loop_redirect_edge (switch_bb->succ, succ_bb);\n \n   /* Update dominators.  */\n-  set_immediate_dominator (loops->cfg.dom, switch_bb, pred_bb);\n-  set_immediate_dominator (loops->cfg.dom, loop->header, switch_bb);\n-  set_immediate_dominator (loops->cfg.dom, succ_bb, switch_bb);\n+  set_immediate_dominator (CDI_DOMINATORS, switch_bb, pred_bb);\n+  set_immediate_dominator (CDI_DOMINATORS, loop->header, switch_bb);\n+  set_immediate_dominator (CDI_DOMINATORS, succ_bb, switch_bb);\n \n   /* Compute new loop.  */\n   add_loop (loops, loop);\n@@ -569,20 +551,19 @@ loopify (struct loops *loops, edge latch_edge, edge header_edge, basic_block swi\n \n   for (i = 0; i < loop->num_nodes; i++)\n     {\n-      unsigned nldom;\n-      basic_block *ldom;\n+      basic_block ldom;\n \n-      nldom = get_dominated_by (loops->cfg.dom, body[i], &ldom);\n-      for (j = 0; j < nldom; j++)\n-\tif (!TEST_BIT (seen, ldom[j]->index))\n+      for (ldom = first_dom_son (CDI_DOMINATORS, body[i]);\n+\t   ldom;\n+\t   ldom = next_dom_son (CDI_DOMINATORS, ldom))\n+\tif (!TEST_BIT (seen, ldom->index))\n \t  {\n-\t    SET_BIT (seen, ldom[j]->index);\n-\t    dom_bbs[n_dom_bbs++] = ldom[j];\n+\t    SET_BIT (seen, ldom->index);\n+\t    dom_bbs[n_dom_bbs++] = ldom;\n \t  }\n-      free (ldom);\n     }\n \n-  iterate_fix_dominators (loops->cfg.dom, dom_bbs, n_dom_bbs);\n+  iterate_fix_dominators (CDI_DOMINATORS, dom_bbs, n_dom_bbs);\n \n   free (body);\n   free (seen);\n@@ -990,7 +971,7 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e, struct loops *loops,\n       copy_loops_to (loops, orig_loops, n_orig_loops, target);\n \n       /* Copy bbs.  */\n-      copy_bbs (bbs, n, new_bbs, spec_edges, 2, new_spec_edges, loop, loops);\n+      copy_bbs (bbs, n, new_bbs, spec_edges, 2, new_spec_edges, loop);\n \n       /* Note whether the blocks and edges belong to an irreducible loop.  */\n       if (add_irreducible_flag)\n@@ -1019,7 +1000,7 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e, struct loops *loops,\n \t  redirect_edge_and_branch_force (latch_edge, new_bbs[0]);\n \t  redirect_edge_and_branch_force (new_spec_edges[SE_LATCH],\n \t\t\t\t\t  loop->header);\n-\t  set_immediate_dominator (loops->cfg.dom, new_bbs[0], latch);\n+\t  set_immediate_dominator (CDI_DOMINATORS, new_bbs[0], latch);\n \t  latch = loop->latch = new_bbs[1];\n \t  e = latch_edge = new_spec_edges[SE_LATCH];\n \t}\n@@ -1028,7 +1009,7 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e, struct loops *loops,\n \t  redirect_edge_and_branch_force (new_spec_edges[SE_LATCH],\n \t\t\t\t\t  loop->header);\n \t  redirect_edge_and_branch_force (e, new_bbs[0]);\n-\t  set_immediate_dominator (loops->cfg.dom, new_bbs[0], e->src);\n+\t  set_immediate_dominator (CDI_DOMINATORS, new_bbs[0], e->src);\n \t  e = new_spec_edges[SE_LATCH];\n \t}\n \n@@ -1056,7 +1037,7 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e, struct loops *loops,\n   \n   /* Update the original loop.  */\n   if (!is_latch)\n-    set_immediate_dominator (loops->cfg.dom, e->dest, e->src);\n+    set_immediate_dominator (CDI_DOMINATORS, e->dest, e->src);\n   if (flags & DLTHE_FLAG_UPDATE_FREQ)\n     {\n       scale_bbs_frequencies (bbs, n, scale_main, REG_BR_PROB_BASE);\n@@ -1070,15 +1051,15 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e, struct loops *loops,\n       int n_dom_bbs,j;\n \n       bb = bbs[i];\n-      n_dom_bbs = get_dominated_by (loops->cfg.dom, bb, &dom_bbs);\n+      n_dom_bbs = get_dominated_by (CDI_DOMINATORS, bb, &dom_bbs);\n       for (j = 0; j < n_dom_bbs; j++)\n \t{\n \t  dominated = dom_bbs[j];\n \t  if (flow_bb_inside_loop_p (loop, dominated))\n \t    continue;\n \t  dom_bb = nearest_common_dominator (\n-\t\t\tloops->cfg.dom, first_active[i], first_active_latch);\n-          set_immediate_dominator (loops->cfg.dom, dominated, dom_bb);\n+\t\t\tCDI_DOMINATORS, first_active[i], first_active_latch);\n+          set_immediate_dominator (CDI_DOMINATORS, dominated, dom_bb);\n \t}\n       free (dom_bbs);\n     }\n@@ -1094,7 +1075,7 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e, struct loops *loops,\n    entry; otherwise we also force preheader block to have only one successor.\n    The function also updates dominators stored in DOM.  */\n static basic_block\n-create_preheader (struct loop *loop, dominance_info dom, int flags)\n+create_preheader (struct loop *loop, int flags)\n {\n   edge e, fallthru;\n   basic_block dummy;\n@@ -1141,7 +1122,7 @@ create_preheader (struct loop *loop, dominance_info dom, int flags)\n     if (ploop->latch == dummy)\n       ploop->latch = fallthru->dest;\n \n-  add_to_dominance_info (dom, fallthru->dest);\n+  add_to_dominance_info (CDI_DOMINATORS, fallthru->dest);\n \n   /* Redirect edges.  */\n   for (e = dummy->pred; e; e = e->pred_next)\n@@ -1159,15 +1140,15 @@ create_preheader (struct loop *loop, dominance_info dom, int flags)\n   jump = redirect_edge_and_branch_force (e, loop->header);\n   if (jump)\n     {\n-      add_to_dominance_info (dom, jump);\n-      set_immediate_dominator (dom, jump, src);\n+      add_to_dominance_info (CDI_DOMINATORS, jump);\n+      set_immediate_dominator (CDI_DOMINATORS, jump, src);\n       add_bb_to_loop (jump, loop);\n       loop->latch = jump;\n     }\n \n   /* Update structures.  */\n-  redirect_immediate_dominators (dom, dummy, loop->header);\n-  set_immediate_dominator (dom, loop->header, dummy);\n+  redirect_immediate_dominators (CDI_DOMINATORS, dummy, loop->header);\n+  set_immediate_dominator (CDI_DOMINATORS, loop->header, dummy);\n   loop->header->loop_father = loop;\n   add_bb_to_loop (dummy, cloop);\n   if (rtl_dump_file)\n@@ -1184,7 +1165,7 @@ create_preheaders (struct loops *loops, int flags)\n {\n   unsigned i;\n   for (i = 1; i < loops->num; i++)\n-    create_preheader (loops->parray[i], loops->cfg.dom, flags);\n+    create_preheader (loops->parray[i], flags);\n   loops->state |= LOOPS_HAVE_PREHEADERS;\n }\n \n@@ -1207,7 +1188,7 @@ force_single_succ_latches (struct loops *loops)\n       for (e = loop->header->pred; e->src != loop->latch; e = e->pred_next)\n \tcontinue;\n \n-      loop_split_edge_with (e, NULL_RTX, loops);\n+      loop_split_edge_with (e, NULL_RTX);\n     }\n   loops->state |= LOOPS_HAVE_SIMPLE_LATCHES;\n }\n@@ -1217,7 +1198,7 @@ force_single_succ_latches (struct loops *loops)\n    be ok after this function.  The created block is placed on correct place\n    in LOOPS structure and its dominator is set.  */\n basic_block\n-loop_split_edge_with (edge e, rtx insns, struct loops *loops)\n+loop_split_edge_with (edge e, rtx insns)\n {\n   basic_block src, dest, new_bb;\n   struct loop *loop_c;\n@@ -1231,7 +1212,7 @@ loop_split_edge_with (edge e, rtx insns, struct loops *loops)\n   /* Create basic block for it.  */\n \n   new_bb = split_edge (e);\n-  add_to_dominance_info (loops->cfg.dom, new_bb);\n+  add_to_dominance_info (CDI_DOMINATORS, new_bb);\n   add_bb_to_loop (new_bb, loop_c);\n   new_bb->flags = insns ? BB_SUPERBLOCK : 0;\n \n@@ -1245,9 +1226,9 @@ loop_split_edge_with (edge e, rtx insns, struct loops *loops)\n   if (insns)\n     emit_insn_after (insns, BB_END (new_bb));\n \n-  set_immediate_dominator (loops->cfg.dom, new_bb, src);\n-  set_immediate_dominator (loops->cfg.dom, dest,\n-    recount_dominator (loops->cfg.dom, dest));\n+  set_immediate_dominator (CDI_DOMINATORS, new_bb, src);\n+  set_immediate_dominator (CDI_DOMINATORS, dest,\n+\t\t\t   recount_dominator (CDI_DOMINATORS, dest));\n \n   if (dest->loop_father->latch == src)\n     dest->loop_father->latch = new_bb;"}, {"sha": "1b6c9fd8f4268370f5576ff474c015e683190903", "filename": "gcc/dominance.c", "status": "modified", "additions": 227, "deletions": 119, "changes": 346, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d47cc544b60738db5e983c4b1ac6b40236b9633c/gcc%2Fdominance.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d47cc544b60738db5e983c4b1ac6b40236b9633c/gcc%2Fdominance.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdominance.c?ref=d47cc544b60738db5e983c4b1ac6b40236b9633c", "patch": "@@ -43,16 +43,8 @@\n #include \"errors.h\"\n #include \"et-forest.h\"\n \n-struct dominance_info\n-{\n-  et_forest_t forest;\n-  varray_type varray;\n-};\n-\n-#define BB_NODE(info, bb) \\\n-  ((et_forest_node_t)VARRAY_GENERIC_PTR ((info)->varray, (bb)->index + 2))\n-#define SET_BB_NODE(info, bb, node) \\\n-  (VARRAY_GENERIC_PTR ((info)->varray, (bb)->index + 2) = (node))\n+/* Whether the dominators and the postdominators are available.  */\n+enum dom_state dom_computed[2];\n \n /* We name our nodes with integers, beginning with 1.  Zero is reserved for\n    'undefined' or 'end of list'.  The name of each node is given by the dfs\n@@ -124,7 +116,7 @@ static void compress (struct dom_info *, TBB);\n static TBB eval (struct dom_info *, TBB);\n static void link_roots (struct dom_info *, TBB, TBB);\n static void calc_idoms (struct dom_info *, enum cdi_direction);\n-void debug_dominance_info (dominance_info);\n+void debug_dominance_info (enum cdi_direction);\n \n /* Helper macro for allocating and initializing an array,\n    for aesthetic reasons.  */\n@@ -526,172 +518,250 @@ calc_idoms (struct dom_info *di, enum cdi_direction reverse)\n       di->dom[v] = di->dom[di->dom[v]];\n }\n \n-/* The main entry point into this module.  IDOM is an integer array with room\n-   for last_basic_block integers, DOMS is a preallocated sbitmap array having\n-   room for last_basic_block^2 bits, and POST is true if the caller wants to\n-   know post-dominators.\n+/* Assign dfs numbers starting from NUM to NODE and its sons.  */\n+\n+static void\n+assign_dfs_numbers (struct et_node *node, int *num)\n+{\n+  struct et_node *son;\n+\n+  node->dfs_num_in = (*num)++;\n+\n+  if (node->son)\n+    {\n+      assign_dfs_numbers (node->son, num);\n+      for (son = node->son->right; son != node->son; son = son->right)\n+      assign_dfs_numbers (son, num);\n+    }\n \n-   On return IDOM[i] will be the BB->index of the immediate (post) dominator\n-   of basic block i, and DOMS[i] will have set bit j if basic block j is a\n-   (post)dominator for block i.\n+  node->dfs_num_out = (*num)++;\n+}\n \n-   Either IDOM or DOMS may be NULL (meaning the caller is not interested in\n-   immediate resp. all dominators).  */\n+/* Compute the data neccesary for fast resolving of dominator queries in a\n+   static dominator tree.  */\n \n-dominance_info\n-calculate_dominance_info (enum cdi_direction reverse)\n+static void\n+compute_dom_fast_query (enum cdi_direction dir)\n+{\n+  int num = 0;\n+  basic_block bb;\n+\n+  if (dom_computed[dir] < DOM_NO_FAST_QUERY)\n+    abort ();\n+\n+  if (dom_computed[dir] == DOM_OK)\n+    return;\n+\n+  FOR_ALL_BB (bb)\n+    {\n+      if (!bb->dom[dir]->father)\n+      assign_dfs_numbers (bb->dom[dir], &num);\n+    }\n+\n+  dom_computed[dir] = DOM_OK;\n+}\n+\n+/* The main entry point into this module.  DIR is set depending on whether\n+   we want to compute dominators or postdominators.  */\n+\n+void\n+calculate_dominance_info (enum cdi_direction dir)\n {\n   struct dom_info di;\n-  dominance_info info;\n   basic_block b;\n \n-  /* Allocate structure for dominance information.  */\n-  info = xmalloc (sizeof (struct dominance_info));\n-  info->forest = et_forest_create ();\n-  VARRAY_GENERIC_PTR_INIT (info->varray, last_basic_block + 3, \"dominance info\");\n+  if (dom_computed[dir] == DOM_OK)\n+    return;\n \n-  /* Add the two well-known basic blocks.  */\n-  SET_BB_NODE (info, ENTRY_BLOCK_PTR, et_forest_add_node (info->forest,\n-\t\t\t\t\t\t\t  ENTRY_BLOCK_PTR));\n-  SET_BB_NODE (info, EXIT_BLOCK_PTR, et_forest_add_node (info->forest,\n-\t\t\t\t\t\t\t EXIT_BLOCK_PTR));\n-  FOR_EACH_BB (b)\n-    SET_BB_NODE (info, b, et_forest_add_node (info->forest, b));\n+  if (dom_computed[dir] != DOM_NO_FAST_QUERY)\n+    {\n+      if (dom_computed[dir] != DOM_NONE)\n+      free_dominance_info (dir);\n \n-  init_dom_info (&di);\n-  calc_dfs_tree (&di, reverse);\n-  calc_idoms (&di, reverse);\n+      FOR_ALL_BB (b)\n+\t{\n+\t  b->dom[dir] = et_new_tree (b);\n+\t}\n \n+      init_dom_info (&di);\n+      calc_dfs_tree (&di, dir);\n+      calc_idoms (&di, dir);\n \n-  FOR_EACH_BB (b)\n-    {\n-      TBB d = di.dom[di.dfs_order[b->index]];\n+      FOR_EACH_BB (b)\n+\t{\n+\t  TBB d = di.dom[di.dfs_order[b->index]];\n+\n+\t  if (di.dfs_to_bb[d])\n+\t    et_set_father (b->dom[dir], di.dfs_to_bb[d]->dom[dir]);\n+\t}\n \n-      if (di.dfs_to_bb[d])\n-        et_forest_add_edge (info->forest, BB_NODE (info, di.dfs_to_bb[d]), BB_NODE (info, b));\n+      free_dom_info (&di);\n+      dom_computed[dir] = DOM_NO_FAST_QUERY;\n     }\n \n-  free_dom_info (&di);\n-  return info;\n+  compute_dom_fast_query (dir);\n }\n \n-/* Free dominance information.  */\n+/* Free dominance information for direction DIR.  */\n void\n-free_dominance_info (dominance_info info)\n+free_dominance_info (enum cdi_direction dir)\n {\n   basic_block bb;\n \n-  /* Allow users to create new basic block without setting up the dominance\n-     information for them.  */\n-  FOR_EACH_BB (bb)\n-    if (bb->index < (int)(info->varray->num_elements - 2)\n-\t&& BB_NODE (info, bb))\n-      delete_from_dominance_info (info, bb);\n-  delete_from_dominance_info (info, ENTRY_BLOCK_PTR);\n-  delete_from_dominance_info (info, EXIT_BLOCK_PTR);\n-  et_forest_delete (info->forest);\n-  VARRAY_GROW (info->varray, 0);\n-  free (info);\n+  if (!dom_computed[dir])\n+    return;\n+\n+  FOR_ALL_BB (bb)\n+    {\n+      delete_from_dominance_info (dir, bb);\n+    }\n+\n+  dom_computed[dir] = DOM_NONE;\n }\n \n /* Return the immediate dominator of basic block BB.  */\n basic_block\n-get_immediate_dominator (dominance_info dom, basic_block bb)\n+get_immediate_dominator (enum cdi_direction dir, basic_block bb)\n {\n-  return et_forest_node_value (dom->forest,\n-\t\t\t       et_forest_parent (dom->forest,\n-\t\t\t\t\t\t BB_NODE (dom, bb)));\n+  struct et_node *node = bb->dom[dir];\n+\n+  if (!dom_computed[dir])\n+    abort ();\n+\n+  if (!node->father)\n+    return NULL;\n+\n+  return node->father->data; \n }\n \n /* Set the immediate dominator of the block possibly removing\n    existing edge.  NULL can be used to remove any edge.  */\n inline void\n-set_immediate_dominator (dominance_info dom, basic_block bb, basic_block dominated_by)\n+set_immediate_dominator (enum cdi_direction dir, basic_block bb,\n+\t\t\t basic_block dominated_by)\n {\n-  void *aux_bb_node;\n-  et_forest_node_t bb_node = BB_NODE (dom, bb);\n+  struct et_node *node = bb->dom[dir];\n+\n+  if (!dom_computed[dir])\n+    abort ();\n \n-  aux_bb_node = et_forest_parent (dom->forest, bb_node);\n-  if (aux_bb_node)\n-    et_forest_remove_edge (dom->forest, aux_bb_node, bb_node);\n-  if (dominated_by != NULL)\n+  if (node->father)\n     {\n-      if (bb == dominated_by)\n-\tabort ();\n-      if (!et_forest_add_edge (dom->forest, BB_NODE (dom, dominated_by), bb_node))\n-\tabort ();\n+      if (node->father->data == dominated_by)\n+      return;\n+      et_split (node);\n     }\n+\n+  if (dominated_by)\n+    et_set_father (node, dominated_by->dom[dir]);\n+\n+  if (dom_computed[dir] == DOM_OK)\n+    dom_computed[dir] = DOM_NO_FAST_QUERY;\n }\n \n-/* Store all basic blocks dominated by BB into BBS and return their number.  */\n+/* Store all basic blocks immediatelly dominated by BB into BBS and return\n+   their number.  */\n int\n-get_dominated_by (dominance_info dom, basic_block bb, basic_block **bbs)\n+get_dominated_by (enum cdi_direction dir, basic_block bb, basic_block **bbs)\n {\n-  int n, i;\n+  int n;\n+  struct et_node *node = bb->dom[dir], *son = node->son, *ason;\n+\n+  if (!dom_computed[dir])\n+    abort ();\n+\n+  if (!son)\n+    {\n+      *bbs = NULL;\n+      return 0;\n+    }\n+\n+  for (ason = son->right, n = 1; ason != son; ason = ason->right)\n+    n++;\n+\n+  *bbs = xmalloc (n * sizeof (basic_block));\n+  (*bbs)[0] = son->data;\n+  for (ason = son->right, n = 1; ason != son; ason = ason->right)\n+    (*bbs)[n++] = ason->data;\n \n-  *bbs = xmalloc (n_basic_blocks * sizeof (basic_block));\n-  n = et_forest_enumerate_sons (dom->forest, BB_NODE (dom, bb), (et_forest_node_t *)*bbs);\n-  for (i = 0; i < n; i++)\n-   (*bbs)[i] = et_forest_node_value (dom->forest, (et_forest_node_t)(*bbs)[i]);\n   return n;\n }\n \n /* Redirect all edges pointing to BB to TO.  */\n void\n-redirect_immediate_dominators (dominance_info dom, basic_block bb, basic_block to)\n+redirect_immediate_dominators (enum cdi_direction dir, basic_block bb,\n+\t\t\t       basic_block to)\n {\n-  et_forest_node_t *bbs = xmalloc (n_basic_blocks * sizeof (basic_block));\n-  et_forest_node_t node = BB_NODE (dom, bb);\n-  et_forest_node_t node2 = BB_NODE (dom, to);\n-  int n = et_forest_enumerate_sons (dom->forest, node, bbs);\n-  int i;\n+  struct et_node *bb_node = bb->dom[dir], *to_node = to->dom[dir], *son;\n+\n+  if (!dom_computed[dir])\n+    abort ();\n \n-  for (i = 0; i < n; i++)\n+  if (!bb_node->son)\n+    return;\n+\n+  while (bb_node->son)\n     {\n-      et_forest_remove_edge (dom->forest, node, bbs[i]);\n-      et_forest_add_edge (dom->forest, node2, bbs[i]);\n+      son = bb_node->son;\n+\n+      et_split (son);\n+      et_set_father (son, to_node);\n     }\n-  free (bbs);\n+\n+  if (dom_computed[dir] == DOM_OK)\n+    dom_computed[dir] = DOM_NO_FAST_QUERY;\n }\n \n /* Find first basic block in the tree dominating both BB1 and BB2.  */\n basic_block\n-nearest_common_dominator (dominance_info dom, basic_block bb1, basic_block bb2)\n+nearest_common_dominator (enum cdi_direction dir, basic_block bb1, basic_block bb2)\n {\n+  if (!dom_computed[dir])\n+    abort ();\n+\n   if (!bb1)\n     return bb2;\n   if (!bb2)\n     return bb1;\n-  return et_forest_node_value (dom->forest,\n-\t\t\t       et_forest_common_ancestor (dom->forest,\n-\t\t\t\t\t\t\t  BB_NODE (dom, bb1),\n-\t\t\t\t\t\t\t  BB_NODE (dom,\n-\t\t\t\t\t\t\t\t   bb2)));\n+\n+  return et_nca (bb1->dom[dir], bb2->dom[dir])->data;\n }\n \n /* Return TRUE in case BB1 is dominated by BB2.  */\n bool\n-dominated_by_p (dominance_info dom, basic_block bb1, basic_block bb2)\n+dominated_by_p (enum cdi_direction dir, basic_block bb1, basic_block bb2)\n {\n-  return nearest_common_dominator (dom, bb1, bb2) == bb2;\n+  struct et_node *n1 = bb1->dom[dir], *n2 = bb2->dom[dir];\n+\n+  if (!dom_computed[dir])\n+    abort ();\n+\n+  if (dom_computed[dir] == DOM_OK)\n+    return (n1->dfs_num_in >= n2->dfs_num_in\n+\t    && n1->dfs_num_out <= n2->dfs_num_out);\n+\n+  return et_below (n1, n2);\n }\n \n /* Verify invariants of dominator structure.  */\n void\n-verify_dominators (dominance_info dom)\n+verify_dominators (enum cdi_direction dir)\n {\n   int err = 0;\n   basic_block bb;\n \n+  if (!dom_computed[dir])\n+    abort ();\n+\n   FOR_EACH_BB (bb)\n     {\n       basic_block dom_bb;\n \n-      dom_bb = recount_dominator (dom, bb);\n-      if (dom_bb != get_immediate_dominator (dom, bb))\n+      dom_bb = recount_dominator (dir, bb);\n+      if (dom_bb != get_immediate_dominator (dir, bb))\n \t{\n \t  error (\"dominator of %d should be %d, not %d\",\n-\t   bb->index, dom_bb->index, get_immediate_dominator(dom, bb)->index);\n+\t   bb->index, dom_bb->index, get_immediate_dominator(dir, bb)->index);\n \t  err = 1;\n \t}\n     }\n@@ -701,15 +771,18 @@ verify_dominators (dominance_info dom)\n \n /* Recount dominator of BB.  */\n basic_block\n-recount_dominator (dominance_info dom, basic_block bb)\n+recount_dominator (enum cdi_direction dir, basic_block bb)\n {\n    basic_block dom_bb = NULL;\n    edge e;\n \n+  if (!dom_computed[dir])\n+    abort ();\n+\n    for (e = bb->pred; e; e = e->pred_next)\n      {\n-       if (!dominated_by_p (dom, e->src, bb))\n-         dom_bb = nearest_common_dominator (dom, dom_bb, e->src);\n+       if (!dominated_by_p (dir, e->src, bb))\n+         dom_bb = nearest_common_dominator (dir, dom_bb, e->src);\n      }\n \n    return dom_bb;\n@@ -718,50 +791,85 @@ recount_dominator (dominance_info dom, basic_block bb)\n /* Iteratively recount dominators of BBS. The change is supposed to be local\n    and not to grow further.  */\n void\n-iterate_fix_dominators (dominance_info dom, basic_block *bbs, int n)\n+iterate_fix_dominators (enum cdi_direction dir, basic_block *bbs, int n)\n {\n   int i, changed = 1;\n   basic_block old_dom, new_dom;\n \n+  if (!dom_computed[dir])\n+    abort ();\n+\n   while (changed)\n     {\n       changed = 0;\n       for (i = 0; i < n; i++)\n \t{\n-\t  old_dom = get_immediate_dominator (dom, bbs[i]);\n-\t  new_dom = recount_dominator (dom, bbs[i]);\n+\t  old_dom = get_immediate_dominator (dir, bbs[i]);\n+\t  new_dom = recount_dominator (dir, bbs[i]);\n \t  if (old_dom != new_dom)\n \t    {\n \t      changed = 1;\n-\t      set_immediate_dominator (dom, bbs[i], new_dom);\n+\t      set_immediate_dominator (dir, bbs[i], new_dom);\n \t    }\n \t}\n     }\n }\n \n void\n-add_to_dominance_info (dominance_info dom, basic_block bb)\n+add_to_dominance_info (enum cdi_direction dir, basic_block bb)\n {\n-  VARRAY_GROW (dom->varray, last_basic_block + 3);\n-#ifdef ENABLE_CHECKING\n-  if (BB_NODE (dom, bb))\n+  if (!dom_computed[dir])\n     abort ();\n-#endif\n-  SET_BB_NODE (dom, bb, et_forest_add_node (dom->forest, bb));\n+\n+  if (bb->dom[dir])\n+    abort ();\n+\n+  bb->dom[dir] = et_new_tree (bb);\n+\n+  if (dom_computed[dir] == DOM_OK)\n+    dom_computed[dir] = DOM_NO_FAST_QUERY;\n }\n \n void\n-delete_from_dominance_info (dominance_info dom, basic_block bb)\n+delete_from_dominance_info (enum cdi_direction dir, basic_block bb)\n+{\n+  if (!dom_computed[dir])\n+    abort ();\n+\n+  et_free_tree (bb->dom[dir]);\n+  bb->dom[dir] = NULL;\n+\n+  if (dom_computed[dir] == DOM_OK)\n+    dom_computed[dir] = DOM_NO_FAST_QUERY;\n+}\n+\n+/* Returns the first son of BB in the dominator or postdominator tree\n+   as determined by DIR.  */\n+\n+basic_block\n+first_dom_son (enum cdi_direction dir, basic_block bb)\n {\n-  et_forest_remove_node (dom->forest, BB_NODE (dom, bb));\n-  SET_BB_NODE (dom, bb, NULL);\n+  struct et_node *son = bb->dom[dir]->son;\n+\n+  return son ? son->data : NULL;\n+}\n+\n+/* Returns the next dominance son after BB in the dominator or postdominator\n+   tree as determined by DIR, or NULL if it was the last one.  */\n+\n+basic_block\n+next_dom_son (enum cdi_direction dir, basic_block bb)\n+{\n+  struct et_node *next = bb->dom[dir]->right;\n+\n+  return next->father->son == next ? NULL : next->data;\n }\n \n void\n-debug_dominance_info (dominance_info dom)\n+debug_dominance_info (enum cdi_direction dir)\n {\n   basic_block bb, bb2;\n   FOR_EACH_BB (bb)\n-    if ((bb2 = get_immediate_dominator (dom, bb)))\n+    if ((bb2 = get_immediate_dominator (dir, bb)))\n       fprintf (stderr, \"%i %i\\n\", bb->index, bb2->index);\n }"}, {"sha": "ea7793f83b3d72786e4c06ef46d736908fff70e6", "filename": "gcc/et-forest.c", "status": "modified", "additions": 583, "deletions": 507, "changes": 1090, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d47cc544b60738db5e983c4b1ac6b40236b9633c/gcc%2Fet-forest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d47cc544b60738db5e983c4b1ac6b40236b9633c/gcc%2Fet-forest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fet-forest.c?ref=d47cc544b60738db5e983c4b1ac6b40236b9633c", "patch": "@@ -30,638 +30,714 @@ Boston, MA 02111-1307, USA.\n #include \"et-forest.h\"\n #include \"alloc-pool.h\"\n \n-struct et_forest_occurrence;\n-typedef struct et_forest_occurrence* et_forest_occurrence_t;\n+/* We do not enable this with ENABLE_CHECKING, since it is awfully slow.  */\n+#undef DEBUG_ET\n \n-/* The ET-forest type.  */\n-struct et_forest\n-{\n-  /* Linked list of nodes is used to destroy the structure.  */\n-  int nnodes;\n-  alloc_pool node_pool;\n-  alloc_pool occur_pool;\n-};\n+#ifdef DEBUG_ET\n+#include \"basic-block.h\"\n+#endif\n \n-/* Single occurrence of node in ET-forest.\n-   A single node may have multiple occurrences.\n- */\n-struct et_forest_occurrence\n+/* The occurence of a node in the et tree.  */\n+struct et_occ\n {\n-  /* Parent in the splay-tree.  */\n-  et_forest_occurrence_t parent;\n+  struct et_node *of;\t\t/* The node.  */\n+\n+  struct et_occ *parent;\t/* Parent in the splay-tree.  */\n+  struct et_occ *prev;\t\t/* Left son in the splay-tree.  */\n+  struct et_occ *next;\t\t/* Right son in the splay-tree.  */\n+\n+  int depth;\t\t\t/* The depth of the node is the sum of depth\n+\t\t\t\t   fields on the path to the root.  */\n+  int min;\t\t\t/* The minimum value of the depth in the subtree\n+\t\t\t\t   is obtained by adding sum of depth fields\n+\t\t\t\t   on the path to the root.  */\n+  struct et_occ *min_occ;\t/* The occurence in the subtree with the minimal\n+\t\t\t\t   depth.  */\n+};\n \n-  /* Children in the splay-tree.  */\n-  et_forest_occurrence_t left, right;\n+static alloc_pool et_nodes;\n+static alloc_pool et_occurences;\n \n-  /* Counts of vertices in the two splay-subtrees.  */\n-  int count_left, count_right;\n+/* Changes depth of OCC to D.  */\n \n-  /* Next occurrence of this node in the sequence.  */\n-  et_forest_occurrence_t next;\n+static inline void\n+set_depth (struct et_occ *occ, int d)\n+{\n+  if (!occ)\n+    return;\n \n-  /* The node, which this occurrence is of.  */\n-  et_forest_node_t node;\n-};\n+  occ->min += d - occ->depth;\n+  occ->depth = d;\n+}\n \n+/* Adds D to the depth of OCC.  */\n \n-/* ET-forest node.  */\n-struct et_forest_node\n+static inline void\n+set_depth_add (struct et_occ *occ, int d)\n {\n-  et_forest_t forest;\n-  void *value;\n-\n-  /* First and last occurrence of this node in the sequence.  */\n-  et_forest_occurrence_t first, last;\n-};\n+  if (!occ)\n+    return;\n \n+  occ->min += d;\n+  occ->depth += d;\n+}\n \n-static et_forest_occurrence_t splay (et_forest_occurrence_t);\n-static void remove_all_occurrences (et_forest_t, et_forest_node_t);\n-static inline et_forest_occurrence_t find_leftmost_node\n-  (et_forest_occurrence_t);\n-static inline et_forest_occurrence_t find_rightmost_node\n-  (et_forest_occurrence_t);\n-static int calculate_value (et_forest_occurrence_t);\n+/* Sets prev field of OCC to P.  */\n \n-/* Return leftmost node present in the tree roted by OCC.  */\n-static inline et_forest_occurrence_t\n-find_leftmost_node (et_forest_occurrence_t occ)\n+static inline void\n+set_prev (struct et_occ *occ, struct et_occ *t)\n {\n-  while (occ->left)\n-    occ = occ->left;\n+#ifdef DEBUG_ET\n+  if (occ == t)\n+    abort ();\n+#endif\n \n-  return occ;\n+  occ->prev = t;\n+  if (t)\n+    t->parent = occ;\n }\n \n-/* Return rightmost node present in the tree roted by OCC.  */\n-static inline et_forest_occurrence_t\n-find_rightmost_node (et_forest_occurrence_t occ)\n+/* Sets next field of OCC to P.  */\n+\n+static inline void\n+set_next (struct et_occ *occ, struct et_occ *t)\n {\n-  while (occ->right)\n-    occ = occ->right;\n-  return occ;\n+#ifdef DEBUG_ET\n+  if (occ == t)\n+    abort ();\n+#endif\n+\n+  occ->next = t;\n+  if (t)\n+    t->parent = occ;\n }\n \n+/* Recompute minimum for occurence OCC.  */\n \n-/* Operation splay for splay tree structure representing occurrences.  */\n-static et_forest_occurrence_t\n-splay (et_forest_occurrence_t node)\n+static inline void\n+et_recomp_min (struct et_occ *occ)\n {\n-  et_forest_occurrence_t parent;\n-  et_forest_occurrence_t grandparent;\n+  struct et_occ *mson = occ->prev;\n \n-  while (1)\n-    {\n-      parent = node->parent;\n+  if (!mson\n+      || (occ->next\n+\t  && mson->min > occ->next->min))\n+      mson = occ->next;\n \n-      if (! parent)\n-\treturn node;  /* node == root.  */\n+  if (mson && mson->min < 0)\n+    {\n+      occ->min = mson->min + occ->depth;\n+      occ->min_occ = mson->min_occ;\n+    }\n+  else\n+    {\n+      occ->min = occ->depth;\n+      occ->min_occ = occ;\n+    }\n+}\n \n-      grandparent = parent->parent;\n+#ifdef DEBUG_ET\n+/* Checks whether neighbourhood of OCC seems sane.  */\n \n-      if (! grandparent)\n-\tbreak;\n+static void\n+et_check_occ_sanity (struct et_occ *occ)\n+{\n+  if (!occ)\n+    return;\n \n-      /* Now there are four possible combinations:  */\n+  if (occ->parent == occ)\n+    abort ();\n \n-      if (node == parent->left)\n-\t{\n-\t  if (parent == grandparent->left)\n-\t    {\n-\t      et_forest_occurrence_t node1, node2;\n-\t      int count1, count2;\n-\n-\t      node1 = node->right;\n-\t      count1 = node->count_right;\n-\t      node2 = parent->right;\n-\t      count2 = parent->count_right;\n-\n-\t      grandparent->left = node2;\n-\t      grandparent->count_left = count2;\n-\t      if (node2)\n-\t\tnode2->parent = grandparent;\n-\t      parent->left = node1;\n-\t      parent->count_left = count1;\n-\t      if (node1)\n-\t\tnode1->parent = parent;\n-\t      parent->right = grandparent;\n-\t      parent->count_right = count2 + grandparent->count_right + 1;\n-\t      node->right = parent;\n-\t      node->count_right = count1 + parent->count_right + 1;\n-\n-\t      node->parent = grandparent->parent;\n-\t      parent->parent = node;\n-\t      grandparent->parent = parent;\n-\n-\t      if (node->parent)\n-\t\t{\n-\t\t  if (node->parent->left == grandparent)\n-\t\t    node->parent->left = node;\n-\t\t  else\n-\t\t    node->parent->right = node;\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      /* parent == grandparent->right && node == parent->left*/\n-\t      et_forest_occurrence_t node1, node2;\n-\t      int count1, count2;\n-\n-\t      node1 = node->left;\n-\t      count1 = node->count_left;\n-\t      node2 = node->right;\n-\t      count2 = node->count_right;\n-\n-\t      grandparent->right = node1;\n-\t      grandparent->count_right = count1;\n-\t      if (node1)\n-\t\tnode1->parent = grandparent;\n-\t      parent->left = node2;\n-\t      parent->count_left = count2;\n-\t      if (node2)\n-\t\tnode2->parent = parent;\n-\t      node->left = grandparent;\n-\t      node->count_left = grandparent->count_left + count1 + 1;\n-\t      node->right = parent;\n-\t      node->count_right = parent->count_right + count2 + 1;\n-\n-\t      node->parent = grandparent->parent;\n-\t      parent->parent = node;\n-\t      grandparent->parent = node;\n-\n-\t      if (node->parent)\n-\t\t{\n-\t\t  if (node->parent->left == grandparent)\n-\t\t    node->parent->left = node;\n-\t\t  else\n-\t\t    node->parent->right = node;\n-\t\t}\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  /* node == parent->right.  */\n-\t  if (parent == grandparent->left)\n-\t    {\n-\t      et_forest_occurrence_t node1, node2;\n-\t      int count1, count2;\n-\n-\t      node1 = node->left;\n-\t      count1 = node->count_left;\n-\t      node2 = node->right;\n-\t      count2 = node->count_right;\n-\n-\t      parent->right = node1;\n-\t      parent->count_right = count1;\n-\t      if (node1)\n-\t\tnode1->parent = parent;\n-\t      grandparent->left = node2;\n-\t      grandparent->count_left = count2;\n-\t      if (node2)\n-\t\tnode2->parent = grandparent;\n-\t      node->left = parent;\n-\t      node->count_left = parent->count_left + count1 + 1;\n-\t      node->right = grandparent;\n-\t      node->count_right = grandparent->count_right + count2 + 1;\n-\n-\t      node->parent = grandparent->parent;\n-\t      parent->parent = node;\n-\t      grandparent->parent = node;\n-\n-\t      if (node->parent)\n-\t\t{\n-\t\t  if (node->parent->left == grandparent)\n-\t\t    node->parent->left = node;\n-\t\t  else\n-\t\t    node->parent->right = node;\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      /* parent == grandparent->right && node == parent->right*/\n-\t      et_forest_occurrence_t node1, node2;\n-\t      int count1, count2;\n-\n-\t      node1 = node->left;\n-\t      count1 = node->count_left;\n-\t      node2 = parent->left;\n-\t      count2 = parent->count_left;\n-\n-\t      grandparent->right = node2;\n-\t      grandparent->count_right = count2;\n-\t      if (node2)\n-\t\tnode2->parent = grandparent;\n-\t      parent->right = node1;\n-\t      parent->count_right = count1;\n-\t      if (node1)\n-\t\tnode1->parent = parent;\n-\t      parent->left = grandparent;\n-\t      parent->count_left = count2 + grandparent->count_left + 1;\n-\t      node->left = parent;\n-\t      node->count_left = count1 + parent->count_left + 1;\n-\n-\t      node->parent = grandparent->parent;\n-\t      parent->parent = node;\n-\t      grandparent->parent = parent;\n-\n-\t      if (node->parent)\n-\t\t{\n-\t\t  if (node->parent->left == grandparent)\n-\t\t    node->parent->left = node;\n-\t\t  else\n-\t\t    node->parent->right = node;\n-\t\t}\n-\t    }\n-\t}\n+  if (occ->prev == occ)\n+    abort ();\n \n-    }\n+  if (occ->next == occ)\n+    abort ();\n \n-  /* parent == root.  */\n-  /* There are two possible combinations:  */\n+  if (occ->next && occ->next == occ->prev)\n+    abort ();\n \n-  if (node == parent->left)\n+  if (occ->next)\n     {\n-      et_forest_occurrence_t node1;\n-      int count1;\n-\n-      node1 = node->right;\n-      count1 = node->count_right;\n-\n-      parent->left = node1;\n-      parent->count_left = count1;\n-      if (node1)\n-\tnode1->parent = parent;\n-      node->right = parent;\n-      node->count_right = parent->count_right + 1 + count1;\n-      node->parent = parent->parent;  /* the same as = 0;  */\n-      parent->parent = node;\n-\n-      if (node->parent)\n-\t{\n-\t  if (node->parent->left == parent)\n-\t    node->parent->left = node;\n-\t  else\n-\t    node->parent->right = node;\n-\t}\n+      if (occ->next == occ->parent)\n+\tabort ();\n+\n+      if (occ->next->parent != occ)\n+\tabort ();\n     }\n-  else\n+\n+  if (occ->prev)\n     {\n-      /* node == parent->right.  */\n-      et_forest_occurrence_t node1;\n-      int count1;\n-\n-      node1 = node->left;\n-      count1 = node->count_left;\n-\n-      parent->right = node1;\n-      parent->count_right = count1;\n-      if (node1)\n-\tnode1->parent = parent;\n-      node->left = parent;\n-      node->count_left = parent->count_left + 1 + count1;\n-      node->parent = parent->parent;  /* the same as = 0;  */\n-      parent->parent = node;\n-\n-      if (node->parent)\n-\t{\n-\t  if (node->parent->left == parent)\n-\t    node->parent->left = node;\n-\t  else\n-\t    node->parent->right = node;\n-\t}\n+      if (occ->prev == occ->parent)\n+\tabort ();\n+\n+      if (occ->prev->parent != occ)\n+\tabort ();\n     }\n \n-  return node;\n+  if (occ->parent\n+      && occ->parent->prev != occ\n+      && occ->parent->next != occ)\n+    abort ();\n }\n \n-/* Remove all occurrences of the given node before destroying the node.  */\n+/* Checks whether tree rooted at OCC is sane.  */\n+\n static void\n-remove_all_occurrences (et_forest_t forest, et_forest_node_t forest_node)\n+et_check_sanity (struct et_occ *occ)\n {\n-  et_forest_occurrence_t first = forest_node->first;\n-  et_forest_occurrence_t last = forest_node->last;\n-  et_forest_occurrence_t node;\n+  et_check_occ_sanity (occ);\n+  if (occ->prev)\n+    et_check_sanity (occ->prev);\n+  if (occ->next)\n+    et_check_sanity (occ->next);\n+}\n \n-  splay (first);\n+/* Checks whether tree containing OCC is sane.  */\n \n-  if (first->left)\n-    first->left->parent = 0;\n-  if (first->right)\n-    first->right->parent = 0;\n+static void\n+et_check_tree_sanity (struct et_occ *occ)\n+{\n+  while (occ->parent)\n+    occ = occ->parent;\n \n-  if (last != first)\n-    {\n-      splay (last);\n+  et_check_sanity (occ);\n+}\n \n-      if (last->left)\n-\tlast->left->parent = 0;\n-      if (last->right)\n-\tlast->right->parent = 0;\n-    }\n+/* For recording the paths.  */\n \n-  if (last->right && first->left) /* actually, first->left would suffice.  */\n-    {\n-      /* Need to join them.  */\n-      et_forest_occurrence_t prev_node, next_node;\n-\n-      prev_node = splay (find_rightmost_node (first->left));\n-      next_node = splay (find_leftmost_node (last->right));\n-      /* prev_node and next_node are consecutive occurrences\n-\t of the same node.  */\n-      if (prev_node->next != next_node)\n-\tabort ();\n+static int len;\n+static void *datas[100000];\n+static int depths[100000];\n \n-      prev_node->right = next_node->right;\n-      prev_node->count_right = next_node->count_right;\n-      prev_node->next = next_node->next;\n-      if (prev_node->right)\n-\tprev_node->right->parent = prev_node;\n+/* Records the path represented by OCC, with depth incremented by DEPTH.  */\n \n-      if (prev_node->node->last == next_node)\n-\tprev_node->node->last = prev_node;\n+static int\n+record_path_before_1 (struct et_occ *occ, int depth)\n+{\n+  int mn, m;\n \n-      pool_free (forest->occur_pool, next_node);\n+  depth += occ->depth;\n+  mn = depth;\n+\n+  if (occ->prev)\n+    {\n+      m = record_path_before_1 (occ->prev, depth); \n+      if (m < mn)\n+\tmn = m;\n     }\n \n-  if (first != last)\n+  fprintf (stderr, \"%d (%d); \", ((basic_block) occ->of->data)->index, depth);\n+  depths[len] = depth;\n+  datas[len] = occ->of;\n+  len++;\n+\n+  if (occ->next)\n     {\n-      node = first->next;\n+      m = record_path_before_1 (occ->next, depth);\n+      if (m < mn)\n+\tmn = m;\n+    }\n \n-      while (node != last)\n-\t{\n-\t  et_forest_occurrence_t next_node;\n+  if (mn != occ->min + depth - occ->depth)\n+    abort ();\n \n-\t  splay (node);\n+  return mn;\n+}\n \n-\t  if (node->left)\n-\t    node->left->parent = 0;\n-\t  if (node->right)\n-\t    node->right->parent = 0;\n+/* Records the path represented by a tree containing OCC.  */\n \n-\t  next_node = node->next;\n-\t  pool_free (forest->occur_pool, node);\n-\t  node = next_node;\n-\t}\n-    }\n+static void\n+record_path_before (struct et_occ *occ)\n+{\n+  while (occ->parent)\n+    occ = occ->parent;\n \n-  pool_free (forest->occur_pool, first);\n-  if (first != last)\n-    pool_free (forest->occur_pool, last);\n+  len = 0;\n+  record_path_before_1 (occ, 0);\n+  fprintf (stderr, \"\\n\");\n }\n \n-/* Calculate ET value of the given node.  */\n-static inline int\n-calculate_value (et_forest_occurrence_t node)\n+/* Checks whether the path represented by OCC, with depth incremented by DEPTH,\n+   was not changed since the last recording.  */\n+\n+static int\n+check_path_after_1 (struct et_occ *occ, int depth)\n {\n-  int value = node->count_left;\n+  int mn, m;\n+\n+  depth += occ->depth;\n+  mn = depth;\n \n-  while (node->parent)\n+  if (occ->next)\n     {\n-      if (node == node->parent->right)\n-\tvalue += node->parent->count_left + 1;\n+      m = check_path_after_1 (occ->next, depth); \n+      if (m < mn)\n+\tmn =  m;\n+    }\n \n-      node = node->parent;\n+  len--;\n+  if (depths[len] != depth\n+      || datas[len] != occ->of)\n+    abort ();\n+\n+  if (occ->prev)\n+    {\n+      m = check_path_after_1 (occ->prev, depth);\n+      if (m < mn)\n+\tmn =  m;\n     }\n \n-  return value;\n+  if (mn != occ->min + depth - occ->depth)\n+    abort ();\n+\n+  return mn;\n }\n \n+/* Checks whether the path represented by a tree containing OCC was\n+   not changed since the last recording.  */\n+\n+static void\n+check_path_after (struct et_occ *occ)\n+{\n+  while (occ->parent)\n+    occ = occ->parent;\n+\n+  check_path_after_1 (occ, 0);\n+  if (len != 0)\n+    abort ();\n+}\n \n+#endif\n \n+/* Splay the occurence OCC to the root of the tree.  */\n \n-/* Create ET-forest structure.  */\n-et_forest_t\n-et_forest_create (void)\n+static inline void\n+et_splay (struct et_occ *occ)\n {\n-  et_forest_t forest = xmalloc (sizeof (struct et_forest));\n+  struct et_occ *f, *gf, *ggf;\n+  int occ_depth, f_depth, gf_depth;\n+\n+#ifdef DEBUG_ET\n+  record_path_before (occ);\n+  et_check_tree_sanity (occ);\n+#endif\n+ \n+  while (occ->parent)\n+    {\n+      occ_depth = occ->depth;\n \n-  forest->nnodes = 0;\n-  forest->occur_pool = create_alloc_pool (\"et_forest_occurrence pool\", sizeof (struct et_forest_occurrence), 300);\n-  forest->node_pool = create_alloc_pool (\"et_forest_node pool\", sizeof (struct et_forest_node), 300);\n-  return forest;\n-}\n+      f = occ->parent;\n+      f_depth = f->depth;\n \n+      gf = f->parent;\n \n+      if (!gf)\n+\t{\n+\t  set_depth_add (occ, f_depth);\n+\t  occ->min_occ = f->min_occ;\n+\t  occ->min = f->min;\n \n-/* Deallocate the structure.  */\n-void\n-et_forest_delete (et_forest_t forest)\n+\t  if (f->prev == occ)\n+\t    {\n+\t      /* zig */\n+\t      set_prev (f, occ->next);\n+\t      set_next (occ, f);\n+\t      set_depth_add (f->prev, occ_depth);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* zag */\n+\t      set_next (f, occ->prev);\n+\t      set_prev (occ, f);\n+\t      set_depth_add (f->next, occ_depth);\n+\t    }\n+\t  set_depth (f, -occ_depth);\n+\t  occ->parent = NULL;\n+\n+\t  et_recomp_min (f);\n+#ifdef DEBUG_ET\n+\t  et_check_tree_sanity (occ);\n+\t  check_path_after (occ);\n+#endif\n+\t  return;\n+\t}\n+\n+      gf_depth = gf->depth;\n+\n+      set_depth_add (occ, f_depth + gf_depth);\n+      occ->min_occ = gf->min_occ;\n+      occ->min = gf->min;\n+\n+      ggf = gf->parent;\n+\n+      if (gf->prev == f)\n+\t{\n+\t  if (f->prev == occ)\n+\t    {\n+\t      /* zig zig */\n+\t      set_prev (gf, f->next);\n+\t      set_prev (f, occ->next);\n+\t      set_next (occ, f);\n+\t      set_next (f, gf);\n+\n+\t      set_depth (f, -occ_depth);\n+\t      set_depth_add (f->prev, occ_depth);\n+\t      set_depth (gf, -f_depth);\n+\t      set_depth_add (gf->prev, f_depth);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* zag zig */\n+\t      set_prev (gf, occ->next);\n+\t      set_next (f, occ->prev);\n+\t      set_prev (occ, f);\n+\t      set_next (occ, gf);\n+\n+\t      set_depth (f, -occ_depth);\n+\t      set_depth_add (f->next, occ_depth);\n+\t      set_depth (gf, -occ_depth - f_depth);\n+\t      set_depth_add (gf->prev, occ_depth + f_depth);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  if (f->prev == occ)\n+\t    {\n+\t      /* zig zag */\n+\t      set_next (gf, occ->prev);\n+\t      set_prev (f, occ->next);\n+\t      set_prev (occ, gf);\n+\t      set_next (occ, f);\n+\n+\t      set_depth (f, -occ_depth);\n+\t      set_depth_add (f->prev, occ_depth);\n+\t      set_depth (gf, -occ_depth - f_depth);\n+\t      set_depth_add (gf->next, occ_depth + f_depth);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* zag zag */\n+\t      set_next (gf, f->prev);\n+\t      set_next (f, occ->prev);\n+\t      set_prev (occ, f);\n+\t      set_prev (f, gf);\n+\n+\t      set_depth (f, -occ_depth);\n+\t      set_depth_add (f->next, occ_depth);\n+\t      set_depth (gf, -f_depth);\n+\t      set_depth_add (gf->next, f_depth);\n+\t    }\n+\t}\n+\n+      occ->parent = ggf;\n+      if (ggf)\n+\t{\n+\t  if (ggf->prev == gf)\n+\t    ggf->prev = occ;\n+\t  else\n+\t    ggf->next = occ;\n+\t}\n+\n+      et_recomp_min (gf);\n+      et_recomp_min (f);\n+#ifdef DEBUG_ET\n+      et_check_tree_sanity (occ);\n+#endif\n+    }\n+\n+#ifdef DEBUG_ET\n+  et_check_sanity (occ);\n+  check_path_after (occ);\n+#endif\n+}\n+\n+/* Create a new et tree occurence of NODE.  */\n+\n+static struct et_occ *\n+et_new_occ (struct et_node *node)\n {\n-  if (forest->nnodes)\n-    abort ();\n-  free_alloc_pool (forest->occur_pool);\n-  free_alloc_pool (forest->node_pool);\n-  free (forest);\n+  struct et_occ *nw;\n+  \n+  if (!et_occurences)\n+    et_occurences = create_alloc_pool (\"et_occ pool\", sizeof (struct et_occ), 300);\n+  nw = pool_alloc (et_occurences);\n+\n+  nw->of = node;\n+  nw->parent = NULL;\n+  nw->prev = NULL;\n+  nw->next = NULL;\n+\n+  nw->depth = 0;\n+  nw->min_occ = nw;\n+  nw->min = 0;\n+\n+  return nw;\n }\n \n-/* Create new node with VALUE and return the edge.\n-   Return NULL when memory allocation failed.  */\n-et_forest_node_t\n-et_forest_add_node (et_forest_t forest, void *value)\n+/* Create a new et tree containing DATA.  */\n+\n+struct et_node *\n+et_new_tree (void *data)\n {\n-  /* Create node with one occurrence.  */\n-  et_forest_node_t node;\n-  et_forest_occurrence_t occ;\n-\n-  node = pool_alloc (forest->node_pool);\n-  occ = pool_alloc (forest->occur_pool);\n-\n-  node->first = node->last = occ;\n-  node->value = value;\n-  forest->nnodes++;\n-\n-  occ->node = node;\n-  occ->left = occ->right = occ->parent = 0;\n-  occ->next = 0;\n-  occ->count_left = occ->count_right = 0;\n-  return node;\n+  struct et_node *nw;\n+  \n+  if (!et_nodes)\n+    et_nodes = create_alloc_pool (\"et_node pool\", sizeof (struct et_node), 300);\n+  nw = pool_alloc (et_nodes);\n+\n+  nw->data = data;\n+  nw->father = NULL;\n+  nw->left = NULL;\n+  nw->right = NULL;\n+  nw->son = NULL;\n+\n+  nw->rightmost_occ = et_new_occ (nw);\n+  nw->parent_occ = NULL;\n+\n+  return nw;\n }\n \n-/* Add new edge to the tree, return 1 if successful.\n-   0 indicates that creation of the edge will close the cycle in graph.  */\n-int\n-et_forest_add_edge (et_forest_t forest ATTRIBUTE_UNUSED,\n-\t\t    et_forest_node_t parent_node, et_forest_node_t child_node)\n+/* Releases et tree T.  */\n+\n+void\n+et_free_tree (struct et_node *t)\n {\n-  et_forest_occurrence_t new_occ, parent_occ, child_occ;\n+  while (t->son)\n+    et_split (t->son);\n \n-  if (! parent_node || ! child_node)\n-    abort ();\n+  if (t->father)\n+    et_split (t);\n \n-  parent_occ = parent_node->first;\n-  child_occ = child_node->first;\n-\n-  splay (parent_occ);\n-  splay (child_occ);\n-\n-  if (parent_occ->parent)\n-    return 0; /* Both child and parent are in the same tree.  */\n-\n-  if (child_occ->left)\n-    abort ();  /* child must be root of its containing tree.  */\n-\n-  new_occ = pool_alloc (forest->occur_pool);\n-\n-  new_occ->node = parent_node;\n-  new_occ->left = child_occ;\n-  new_occ->count_left = child_occ->count_right + 1; /* count_left is 0.  */\n-  new_occ->right = parent_occ->right;\n-  new_occ->count_right = parent_occ->count_right;\n-  new_occ->parent = parent_occ;\n-  new_occ->next = parent_occ->next;\n-  child_occ->parent = new_occ;\n-  parent_occ->right = new_occ;\n-  parent_occ->count_right = new_occ->count_left + new_occ->count_right + 1;\n-  parent_occ->next = new_occ;\n-  if (new_occ->right)\n-    new_occ->right->parent = new_occ;\n-\n-  if (parent_node->last == parent_occ)\n-    parent_node->last = new_occ;\n-  return 1;\n+  pool_free (et_occurences, t->rightmost_occ);\n+  pool_free (et_nodes, t);\n }\n \n-/* Remove NODE from the tree and all connected edges.  */\n+/* Sets father of et tree T to FATHER.  */\n+\n void\n-et_forest_remove_node (et_forest_t forest, et_forest_node_t node)\n+et_set_father (struct et_node *t, struct et_node *father)\n {\n-  remove_all_occurrences (forest, node);\n-  forest->nnodes--;\n+  struct et_node *left, *right;\n+  struct et_occ *rmost, *left_part, *new_f_occ, *p;\n \n-  pool_free (forest->node_pool, node);\n-}\n+  /* Update the path represented in the splay tree.  */\n+  new_f_occ = et_new_occ (father);\n \n-/* Remove edge from the tree, return 1 if successful,\n-   0 indicates nonexisting edge.  */\n-int\n-et_forest_remove_edge (et_forest_t forest ATTRIBUTE_UNUSED,\n-\t\t       et_forest_node_t parent_node,\n-\t\t       et_forest_node_t child_node)\n-{\n-  et_forest_occurrence_t parent_pre_occ, parent_post_occ;\n+  rmost = father->rightmost_occ;\n+  et_splay (rmost);\n \n-  splay (child_node->first);\n+  left_part = rmost->prev;\n \n-  if (! child_node->first->left)\n-    return 0;\n+  p = t->rightmost_occ;\n+  et_splay (p);\n \n-  parent_pre_occ = find_rightmost_node (child_node->first->left);\n-  if (parent_pre_occ->node != parent_node)\n-    abort ();\n+  set_prev (new_f_occ, left_part);\n+  set_next (new_f_occ, p);\n+\n+  p->depth++;\n+  p->min++;\n+  et_recomp_min (new_f_occ);\n \n-  splay (parent_pre_occ);\n-  parent_pre_occ->right->parent = 0;\n+  set_prev (rmost, new_f_occ);\n \n-  parent_post_occ = parent_pre_occ->next;\n-  splay (parent_post_occ);\n+  if (new_f_occ->min + rmost->depth < rmost->min)\n+    {\n+      rmost->min = new_f_occ->min + rmost->depth;\n+      rmost->min_occ = new_f_occ->min_occ;\n+    }\n \n-  parent_post_occ->left->parent = 0;\n+  t->parent_occ = new_f_occ;\n \n-  parent_pre_occ->right = parent_post_occ->right;\n-  parent_pre_occ->count_right = parent_post_occ->count_right;\n-  if (parent_post_occ->right)\n-    parent_post_occ->right->parent = parent_pre_occ;\n+  /* Update the tree.  */\n+  t->father = father;\n+  right = father->son;\n+  if (right)\n+    left = right->left;\n+  else\n+    left = right = t;\n \n-  parent_pre_occ->next = parent_post_occ->next;\n+  left->right = t;\n+  right->left = t;\n+  t->left = left;\n+  t->right = right;\n \n-  if (parent_post_occ == parent_node->last)\n-    parent_node->last = parent_pre_occ;\n+  father->son = t;\n \n-  pool_free (forest->occur_pool, parent_post_occ);\n-  return 1;\n+#ifdef DEBUG_ET\n+  et_check_tree_sanity (rmost);\n+  record_path_before (rmost);\n+#endif\n }\n \n-/* Return the parent of the NODE if any, NULL otherwise.  */\n-et_forest_node_t\n-et_forest_parent (et_forest_t forest ATTRIBUTE_UNUSED, et_forest_node_t node)\n+/* Splits the edge from T to its father.  */\n+\n+void\n+et_split (struct et_node *t)\n {\n-  splay (node->first);\n+  struct et_node *father = t->father;\n+  struct et_occ *r, *l, *rmost, *p_occ;\n \n-  if (node->first->left)\n-    return find_rightmost_node (node->first->left)->node;\n-  else\n-    return 0;\n-}\n+  /* Update the path represented by the splay tree.  */\n+  rmost = t->rightmost_occ;\n+  et_splay (rmost);\n \n+  for (r = rmost->next; r->prev; r = r->prev)\n+    continue;\n+  et_splay (r); \n \n-/* Return nearest common ancestor of NODE1 and NODE2.\n-   Return NULL of they are in different trees.  */\n-et_forest_node_t\n-et_forest_common_ancestor (et_forest_t forest ATTRIBUTE_UNUSED,\n-\t\t\t   et_forest_node_t node1, et_forest_node_t node2)\n-{\n-  int value1, value2, max_value;\n-  et_forest_node_t ancestor;\n+  r->prev->parent = NULL;\n+  p_occ = t->parent_occ;\n+  et_splay (p_occ);\n+  t->parent_occ = NULL;\n \n-  if (node1 == node2)\n-    return node1;\n+  l = p_occ->prev;\n+  p_occ->next->parent = NULL;\n \n-  if (! node1 || ! node2)\n-    abort ();\n+  set_prev (r, l);\n \n-  splay (node1->first);\n-  splay (node2->first);\n+  et_recomp_min (r);\n \n-  if (! node1->first->parent)  /* The two vertices are in different trees.  */\n-    return 0;\n+  et_splay (rmost);\n+  rmost->depth = 0;\n+  rmost->min = 0;\n \n-  value2 = calculate_value (node2->first);\n-  value1 = calculate_value (node1->first);\n+  pool_free (et_occurences, p_occ);\n \n-  if (value1 < value2)\n+  /* Update the tree.  */\n+  if (father->son == t)\n+    father->son = t->right;\n+  if (father->son == t)\n+    father->son = NULL;\n+  else\n     {\n-      ancestor = node1;\n-      max_value = value2;\n+      t->left->right = t->right;\n+      t->right->left = t->left;\n+    }\n+  t->left = t->right = NULL;\n+  t->father = NULL;\n+\n+#ifdef DEBUG_ET\n+  et_check_tree_sanity (rmost);\n+  record_path_before (rmost);\n+\n+  et_check_tree_sanity (r);\n+  record_path_before (r);\n+#endif\n+}\n+\n+/* Finds the nearest common ancestor of the nodes N1 and N2.  */\n+\n+struct et_node *\n+et_nca (struct et_node *n1, struct et_node *n2)\n+{\n+  struct et_occ *o1 = n1->rightmost_occ, *o2 = n2->rightmost_occ, *om;\n+  struct et_occ *l, *r, *ret;\n+  int mn;\n+\n+  if (n1 == n2)\n+    return n1;\n+\n+  et_splay (o1);\n+  l = o1->prev;\n+  r = o1->next;\n+  if (l)\n+    l->parent = NULL;\n+  if (r)\n+    r->parent = NULL;\n+  et_splay (o2);\n+\n+  if (l == o2 || (l && l->parent != NULL))\n+    {\n+      ret = o2->next;\n+\n+      set_prev (o1, o2);\n+      if (r)\n+\tr->parent = o1;\n     }\n   else\n     {\n-      ancestor = node2;\n-      max_value = value1;\n+      ret = o2->prev;\n+\n+      set_next (o1, o2);\n+      if (l)\n+\tl->parent = o1;\n     }\n \n-  while (calculate_value (ancestor->last) < max_value)\n+  if (0 < o2->depth)\n     {\n-      /* Find parent node.  */\n-      splay (ancestor->first);\n-      ancestor = find_rightmost_node (ancestor->first->left) ->node;\n+      om = o1;\n+      mn = o1->depth;\n+    }\n+  else\n+    {\n+      om = o2;\n+      mn = o2->depth + o1->depth;\n     }\n \n-  return ancestor;\n-}\n+#ifdef DEBUG_ET\n+  et_check_tree_sanity (o2);\n+#endif\n \n-/* Return the value pointer of node set during it's creation.  */\n-void *\n-et_forest_node_value (et_forest_t forest ATTRIBUTE_UNUSED,\n-\t\t      et_forest_node_t node)\n-{\n-  /* Alloc threading NULL as a special node of the forest.  */\n-  if (!node)\n-    return NULL;\n-  return node->value;\n+  if (ret && ret->min + o1->depth + o2->depth < mn)\n+    return ret->min_occ->of;\n+  else\n+    return om->of;\n }\n \n-/* Find all sons of NODE and store them into ARRAY allocated by the caller.\n-   Return number of nodes found.  */\n-int\n-et_forest_enumerate_sons (et_forest_t forest ATTRIBUTE_UNUSED,\n-\t\t\t  et_forest_node_t node, et_forest_node_t *array)\n+/* Checks whether the node UP is an ancestor of the node DOWN.  */\n+\n+bool\n+et_below (struct et_node *down, struct et_node *up)\n {\n-  int n = 0;\n-  et_forest_occurrence_t occ = node->first, stop = node->last, occ1;\n+  struct et_occ *u = up->rightmost_occ, *d = down->rightmost_occ;\n+  struct et_occ *l, *r;\n+\n+  if (up == down)\n+    return true;\n+\n+  et_splay (u);\n+  l = u->prev;\n+  r = u->next;\n+\n+  if (!l)\n+    return false;\n+\n+  l->parent = NULL;\n+\n+  if (r)\n+    r->parent = NULL;\n \n-  /* Parent is the rightmost node of the left successor.\n-     Look for all occurrences having no right successor\n-     and lookup the sons.  */\n-  while (occ != stop)\n+  et_splay (d);\n+\n+  if (l == d || l->parent != NULL)\n     {\n-      splay (occ);\n-      if (occ->right)\n-\t{\n-          occ1 = find_leftmost_node (occ->right);\n-\t  if (occ1->node->first == occ1)\n-\t    array[n++] = occ1->node;\n-\t}\n-      occ = occ->next;\n+      if (r)\n+\tr->parent = u;\n+      set_prev (u, d);\n+#ifdef DEBUG_ET\n+      et_check_tree_sanity (u);\n+#endif\n     }\n-  return n;\n+  else\n+    {\n+      l->parent = u;\n+\n+      /* In case O1 and O2 are in two different trees, we must just restore the\n+\t original state.  */\n+      if (r && r->parent != NULL)\n+\tset_next (u, d);\n+      else\n+\tset_next (u, r);\n+\n+#ifdef DEBUG_ET\n+      et_check_tree_sanity (u);\n+#endif\n+      return false;\n+    }\n+\n+  if (0 >= d->depth)\n+    return false;\n+\n+  return !d->next || d->next->min + d->depth >= 0;\n }"}, {"sha": "833146d61470df14bf1138f9f083a038f8adbc0b", "filename": "gcc/et-forest.h", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d47cc544b60738db5e983c4b1ac6b40236b9633c/gcc%2Fet-forest.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d47cc544b60738db5e983c4b1ac6b40236b9633c/gcc%2Fet-forest.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fet-forest.h?ref=d47cc544b60738db5e983c4b1ac6b40236b9633c", "patch": "@@ -55,26 +55,28 @@ Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n extern \"C\" {\n #endif /* __cplusplus */\n \n-typedef struct et_forest *et_forest_t;\n-typedef struct et_forest_node *et_forest_node_t;\n-\n-extern et_forest_t et_forest_create (void);\n-\n-extern void et_forest_delete (et_forest_t);\n-\n-extern et_forest_node_t et_forest_add_node (et_forest_t, void *);\n-extern int et_forest_add_edge (et_forest_t, et_forest_node_t,\n-\t\t\t       et_forest_node_t);\n-extern void et_forest_remove_node (et_forest_t, et_forest_node_t);\n-extern int et_forest_remove_edge (et_forest_t, et_forest_node_t,\n-\t\t\t\t  et_forest_node_t);\n-extern et_forest_node_t et_forest_parent (et_forest_t, et_forest_node_t);\n-extern et_forest_node_t et_forest_common_ancestor (et_forest_t,\n-\t\t\t\t\t\t   et_forest_node_t,\n-\t\t\t\t\t\t   et_forest_node_t);\n-extern void * et_forest_node_value (et_forest_t, et_forest_node_t);\n-extern int et_forest_enumerate_sons (et_forest_t, et_forest_node_t,\n-\t\t\t\t     et_forest_node_t *);\n+/* The node representing the node in an et tree.  */\n+struct et_node\n+{\n+  void *data;\t\t\t/* The data represented by the node.  */\n+\n+  int dfs_num_in, dfs_num_out;\t/* Number of the node in the dfs ordering.  */\n+\n+  struct et_node *father;\t/* Father of the node.  */\n+  struct et_node *son;\t\t/* The first of the sons of the node.  */\n+  struct et_node *left;\n+  struct et_node *right;\t/* The brothers of the node.  */\n+\n+  struct et_occ *rightmost_occ;\t/* The rightmost occurence.  */\n+  struct et_occ *parent_occ;\t/* The occurence of the parent node.  */\n+};\n+\n+struct et_node *et_new_tree (void *data);\n+void et_free_tree (struct et_node *);\n+void et_set_father (struct et_node *, struct et_node *);\n+void et_split (struct et_node *);\n+struct et_node *et_nca (struct et_node *, struct et_node *);\n+bool et_below (struct et_node *, struct et_node *);\n \n #ifdef __cplusplus\n }"}, {"sha": "1da182af4dca6aec9c072fe83167de472c3e5195", "filename": "gcc/function.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d47cc544b60738db5e983c4b1ac6b40236b9633c/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d47cc544b60738db5e983c4b1ac6b40236b9633c/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=d47cc544b60738db5e983c4b1ac6b40236b9633c", "patch": "@@ -6408,8 +6408,6 @@ allocate_struct_function (tree fndecl)\n   DECL_SAVED_INSNS (fndecl) = cfun;\n   cfun->decl = fndecl;\n \n-  current_function_name = (*lang_hooks.decl_printable_name) (fndecl, 2);\n-\n   result = DECL_RESULT (fndecl);\n   if (aggregate_value_p (result, fndecl))\n     {"}, {"sha": "a8c5233d5991090209aea60991da30364155451d", "filename": "gcc/function.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d47cc544b60738db5e983c4b1ac6b40236b9633c/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d47cc544b60738db5e983c4b1ac6b40236b9633c/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=d47cc544b60738db5e983c4b1ac6b40236b9633c", "patch": "@@ -183,9 +183,6 @@ struct function GTY(())\n \n   /* For function.c.  */\n \n-  /* Name of this function.  */\n-  const char *name;\n-\n   /* Points to the FUNCTION_DECL of this function.  */\n   tree decl;\n \n@@ -534,7 +531,6 @@ extern int virtuals_instantiated;\n extern int trampolines_created;\n \n /* For backward compatibility... eventually these should all go away.  */\n-#define current_function_name (cfun->name)\n #define current_function_pops_args (cfun->pops_args)\n #define current_function_returns_struct (cfun->returns_struct)\n #define current_function_returns_pcc_struct (cfun->returns_pcc_struct)"}, {"sha": "cf845af0da7cff4844e68325337f78130c2dad09", "filename": "gcc/gcse.c", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d47cc544b60738db5e983c4b1ac6b40236b9633c/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d47cc544b60738db5e983c4b1ac6b40236b9633c/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=d47cc544b60738db5e983c4b1ac6b40236b9633c", "patch": "@@ -161,6 +161,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"basic-block.h\"\n #include \"output.h\"\n #include \"function.h\"\n+#include \"langhooks.h\"\n #include \"expr.h\"\n #include \"except.h\"\n #include \"ggc.h\"\n@@ -855,7 +856,8 @@ gcse_main (rtx f, FILE *file)\n   if (file)\n     {\n       fprintf (file, \"GCSE of %s: %d basic blocks, \",\n-\t       current_function_name, n_basic_blocks);\n+\t       (*lang_hooks.decl_printable_name) (current_function_decl, 2),\n+\t       n_basic_blocks);\n       fprintf (file, \"%d pass%s, %d bytes\\n\\n\",\n \t       pass, pass > 1 ? \"es\" : \"\", max_pass_bytes);\n     }\n@@ -3614,7 +3616,8 @@ one_classic_gcse_pass (int pass)\n     {\n       fprintf (gcse_file, \"\\n\");\n       fprintf (gcse_file, \"GCSE of %s, pass %d: %d bytes needed, %d substs,\",\n-\t       current_function_name, pass, bytes_used, gcse_subst_count);\n+\t       (*lang_hooks.decl_printable_name) (current_function_decl, 2),\n+\t       pass, bytes_used, gcse_subst_count);\n       fprintf (gcse_file, \"%d insns created\\n\", gcse_create_count);\n     }\n \n@@ -4686,7 +4689,8 @@ one_cprop_pass (int pass, int cprop_jumps, int bypass_jumps)\n   if (gcse_file)\n     {\n       fprintf (gcse_file, \"CPROP of %s, pass %d: %d bytes needed, \",\n-\t       current_function_name, pass, bytes_used);\n+\t       (*lang_hooks.decl_printable_name) (current_function_decl, 2),\n+\t       pass, bytes_used);\n       fprintf (gcse_file, \"%d const props, %d copy props\\n\\n\",\n \t       const_prop_count, copy_prop_count);\n     }\n@@ -5788,7 +5792,8 @@ one_pre_gcse_pass (int pass)\n   if (gcse_file)\n     {\n       fprintf (gcse_file, \"\\nPRE GCSE of %s, pass %d: %d bytes needed, \",\n-\t       current_function_name, pass, bytes_used);\n+\t       (*lang_hooks.decl_printable_name) (current_function_decl, 2),\n+\t       pass, bytes_used);\n       fprintf (gcse_file, \"%d substs, %d insns created\\n\",\n \t       gcse_subst_count, gcse_create_count);\n     }\n@@ -6182,9 +6187,6 @@ static sbitmap *hoist_vbeout;\n /* Hoistable expressions.  */\n static sbitmap *hoist_exprs;\n \n-/* Dominator bitmaps.  */\n-dominance_info dominators;\n-\n /* ??? We could compute post dominators and run this algorithm in\n    reverse to perform tail merging, doing so would probably be\n    more effective than the tail merging code in jump.c.\n@@ -6221,7 +6223,7 @@ free_code_hoist_mem (void)\n   sbitmap_vector_free (hoist_exprs);\n   sbitmap_vector_free (transpout);\n \n-  free_dominance_info (dominators);\n+  free_dominance_info (CDI_DOMINATORS);\n }\n \n /* Compute the very busy expressions at entry/exit from each block.\n@@ -6270,7 +6272,7 @@ compute_code_hoist_data (void)\n   compute_local_properties (transp, comp, antloc, &expr_hash_table);\n   compute_transpout ();\n   compute_code_hoist_vbeinout ();\n-  dominators = calculate_dominance_info (CDI_DOMINATORS);\n+  calculate_dominance_info (CDI_DOMINATORS);\n   if (gcse_file)\n     fprintf (gcse_file, \"\\n\");\n }\n@@ -6362,7 +6364,7 @@ hoist_code (void)\n       int found = 0;\n       int insn_inserted_p;\n \n-      domby_len = get_dominated_by (dominators, bb, &domby);\n+      domby_len = get_dominated_by (CDI_DOMINATORS, bb, &domby);\n       /* Examine each expression that is very busy at the exit of this\n \t block.  These are the potentially hoistable expressions.  */\n       for (i = 0; i < hoist_vbeout[bb->index]->n_bits; i++)\n@@ -8020,7 +8022,8 @@ bypass_jumps (FILE *file)\n   if (file)\n     {\n       fprintf (file, \"BYPASS of %s: %d basic blocks, \",\n-\t       current_function_name, n_basic_blocks);\n+\t       (*lang_hooks.decl_printable_name) (current_function_decl, 2),\n+\t       n_basic_blocks);\n       fprintf (file, \"%d bytes\\n\\n\", bytes_used);\n     }\n "}, {"sha": "483cc7e35a1d4b20fcc48170a0760171f07eca76", "filename": "gcc/graph.c", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d47cc544b60738db5e983c4b1ac6b40236b9633c/gcc%2Fgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d47cc544b60738db5e983c4b1ac6b40236b9633c/gcc%2Fgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraph.c?ref=d47cc544b60738db5e983c4b1ac6b40236b9633c", "patch": "@@ -25,9 +25,11 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"tm.h\"\n \n #include \"rtl.h\"\n+#include \"tree.h\"\n #include \"flags.h\"\n #include \"output.h\"\n #include \"function.h\"\n+#include \"langhooks.h\"\n #include \"hard-reg-set.h\"\n #include \"basic-block.h\"\n #include \"toplev.h\"\n@@ -55,7 +57,8 @@ start_fct (FILE *fp)\n     case vcg:\n       fprintf (fp, \"\\\n graph: { title: \\\"%s\\\"\\nfolding: 1\\nhidden: 2\\nnode: { title: \\\"%s.0\\\" }\\n\",\n-\t       current_function_name, current_function_name);\n+\t       (*lang_hooks.decl_printable_name) (current_function_decl, 2),\n+\t       (*lang_hooks.decl_printable_name) (current_function_decl, 2));\n       break;\n     case no_graph:\n       break;\n@@ -71,7 +74,8 @@ start_bb (FILE *fp, int bb)\n       fprintf (fp, \"\\\n graph: {\\ntitle: \\\"%s.BB%d\\\"\\nfolding: 1\\ncolor: lightblue\\n\\\n label: \\\"basic block %d\",\n-\t       current_function_name, bb, bb);\n+\t       (*lang_hooks.decl_printable_name) (current_function_decl, 2),\n+\t       bb, bb);\n       break;\n     case no_graph:\n       break;\n@@ -113,8 +117,9 @@ node_data (FILE *fp, rtx tmp_rtx)\n \tcase vcg:\n \t  fprintf (fp, \"\\\n edge: { sourcename: \\\"%s.0\\\" targetname: \\\"%s.%d\\\" }\\n\",\n-\t\t   current_function_name,\n-\t\t   current_function_name, XINT (tmp_rtx, 0));\n+\t\t   (*lang_hooks.decl_printable_name) (current_function_decl, 2),\n+\t\t   (*lang_hooks.decl_printable_name) (current_function_decl, 2),\n+\t\t   XINT (tmp_rtx, 0));\n \t  break;\n \tcase no_graph:\n \t  break;\n@@ -126,7 +131,8 @@ edge: { sourcename: \\\"%s.0\\\" targetname: \\\"%s.%d\\\" }\\n\",\n     case vcg:\n       fprintf (fp, \"node: {\\n  title: \\\"%s.%d\\\"\\n  color: %s\\n  \\\n label: \\\"%s %d\\n\",\n-\t       current_function_name, XINT (tmp_rtx, 0),\n+\t       (*lang_hooks.decl_printable_name) (current_function_decl, 2),\n+\t       XINT (tmp_rtx, 0),\n \t       GET_CODE (tmp_rtx) == NOTE ? \"lightgrey\"\n \t       : GET_CODE (tmp_rtx) == INSN ? \"green\"\n \t       : GET_CODE (tmp_rtx) == JUMP_INSN ? \"darkgreen\"\n@@ -178,8 +184,11 @@ draw_edge (FILE *fp, int from, int to, int bb_edge, int class)\n \tcolor = \"color: green \";\n       fprintf (fp,\n \t       \"edge: { sourcename: \\\"%s.%d\\\" targetname: \\\"%s.%d\\\" %s\",\n-\t       current_function_name, from,\n-\t       current_function_name, to, color);\n+\t       (*lang_hooks.decl_printable_name) (current_function_decl, 2),\n+\t       from,\n+\t       (*lang_hooks.decl_printable_name) (current_function_decl, 2),\n+\t       to,\n+\t       color);\n       if (class)\n \tfprintf (fp, \"class: %d \", class);\n       fputs (\"}\\n\", fp);\n@@ -209,7 +218,7 @@ end_fct (FILE *fp)\n     {\n     case vcg:\n       fprintf (fp, \"node: { title: \\\"%s.999999\\\" label: \\\"END\\\" }\\n}\\n\",\n-\t       current_function_name);\n+\t       (*lang_hooks.decl_printable_name) (current_function_decl, 2));\n       break;\n     case no_graph:\n       break;"}, {"sha": "2b10e18628e6a1809f603e056dc03ad2c81a2500", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 22, "deletions": 27, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d47cc544b60738db5e983c4b1ac6b40236b9633c/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d47cc544b60738db5e983c4b1ac6b40236b9633c/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=d47cc544b60738db5e983c4b1ac6b40236b9633c", "patch": "@@ -84,9 +84,6 @@ static int cond_exec_changed_p;\n /* True if life data ok at present.  */\n static bool life_data_ok;\n \n-/* The post-dominator relation on the original block numbers.  */\n-static dominance_info post_dominators;\n-\n /* Forward references.  */\n static int count_bb_insns (basic_block);\n static rtx first_active_insn (basic_block);\n@@ -123,6 +120,7 @@ mark_loop_exit_edges (void)\n   edge e;\n   \n   flow_loops_find (&loops, LOOP_TREE);\n+  free_dominance_info (CDI_DOMINATORS);\n   \n   if (loops.num > 1)\n     {\n@@ -2105,8 +2103,8 @@ merge_if_block (struct ce_if_block * ce_info)\n \t{\n \t  bb = fallthru;\n \t  fallthru = block_fallthru (bb);\n-\t  if (post_dominators)\n-\t    delete_from_dominance_info (post_dominators, bb);\n+\t  if (dom_computed[CDI_POST_DOMINATORS] >= DOM_NO_FAST_QUERY)\n+\t    delete_from_dominance_info (CDI_POST_DOMINATORS, bb);\n \t  merge_blocks (combo_bb, bb);\n \t  num_true_changes++;\n \t}\n@@ -2122,8 +2120,8 @@ merge_if_block (struct ce_if_block * ce_info)\n       if (combo_bb->global_live_at_end)\n \tCOPY_REG_SET (combo_bb->global_live_at_end,\n \t\t      then_bb->global_live_at_end);\n-      if (post_dominators)\n-\tdelete_from_dominance_info (post_dominators, then_bb);\n+      if (dom_computed[CDI_POST_DOMINATORS] >= DOM_NO_FAST_QUERY)\n+\tdelete_from_dominance_info (CDI_POST_DOMINATORS, then_bb);\n       merge_blocks (combo_bb, then_bb);\n       num_true_changes++;\n     }\n@@ -2133,8 +2131,8 @@ merge_if_block (struct ce_if_block * ce_info)\n      get their addresses taken.  */\n   if (else_bb)\n     {\n-      if (post_dominators)\n-\tdelete_from_dominance_info (post_dominators, else_bb);\n+      if (dom_computed[CDI_POST_DOMINATORS] >= DOM_NO_FAST_QUERY)\n+       \tdelete_from_dominance_info (CDI_POST_DOMINATORS, else_bb);\n       merge_blocks (combo_bb, else_bb);\n       num_true_changes++;\n     }\n@@ -2190,8 +2188,8 @@ merge_if_block (struct ce_if_block * ce_info)\n \tCOPY_REG_SET (combo_bb->global_live_at_end,\n \t\t      join_bb->global_live_at_end);\n \n-      if (post_dominators)\n-\tdelete_from_dominance_info (post_dominators, join_bb);\n+      if (dom_computed[CDI_POST_DOMINATORS] >= DOM_NO_FAST_QUERY)\n+\tdelete_from_dominance_info (CDI_POST_DOMINATORS, join_bb);\n       merge_blocks (combo_bb, join_bb);\n       num_true_changes++;\n     }\n@@ -2271,7 +2269,7 @@ find_if_header (basic_block test_bb, int pass)\n       && find_cond_trap (test_bb, then_edge, else_edge))\n     goto success;\n \n-  if (post_dominators\n+  if (dom_computed[CDI_POST_DOMINATORS] >= DOM_NO_FAST_QUERY\n       && (! HAVE_conditional_execution || reload_completed))\n     {\n       if (find_if_case_1 (test_bb, then_edge, else_edge))\n@@ -2646,8 +2644,8 @@ find_cond_trap (basic_block test_bb, edge then_edge, edge else_edge)\n   remove_edge (trap_bb == then_bb ? then_edge : else_edge);\n   if (trap_bb->pred == NULL)\n     {\n-      if (post_dominators)\n-\tdelete_from_dominance_info (post_dominators, trap_bb);\n+      if (dom_computed[CDI_POST_DOMINATORS] >= DOM_NO_FAST_QUERY)\n+\tdelete_from_dominance_info (CDI_POST_DOMINATORS, trap_bb);\n       delete_block (trap_bb);\n     }\n \n@@ -2831,8 +2829,8 @@ find_if_case_1 (basic_block test_bb, edge then_edge, edge else_edge)\n \n   new_bb = redirect_edge_and_branch_force (FALLTHRU_EDGE (test_bb), else_bb);\n   then_bb_index = then_bb->index;\n-  if (post_dominators)\n-    delete_from_dominance_info (post_dominators, then_bb);\n+  if (dom_computed[CDI_POST_DOMINATORS] >= DOM_NO_FAST_QUERY)\n+    delete_from_dominance_info (CDI_POST_DOMINATORS, then_bb);\n   delete_block (then_bb);\n \n   /* Make rest of code believe that the newly created block is the THEN_BB\n@@ -2841,8 +2839,8 @@ find_if_case_1 (basic_block test_bb, edge then_edge, edge else_edge)\n     {\n       new_bb->index = then_bb_index;\n       BASIC_BLOCK (then_bb_index) = new_bb;\n-      if (post_dominators)\n-\tadd_to_dominance_info (post_dominators, new_bb);\n+      if (dom_computed[CDI_POST_DOMINATORS] >= DOM_NO_FAST_QUERY)\n+\tadd_to_dominance_info (CDI_POST_DOMINATORS, new_bb);\n     }\n   /* We've possibly created jump to next insn, cleanup_cfg will solve that\n      later.  */\n@@ -2884,7 +2882,7 @@ find_if_case_2 (basic_block test_bb, edge then_edge, edge else_edge)\n   if (note && INTVAL (XEXP (note, 0)) >= REG_BR_PROB_BASE / 2)\n     ;\n   else if (else_succ->dest->index < 0\n-\t   || dominated_by_p (post_dominators, then_bb,\n+\t   || dominated_by_p (CDI_POST_DOMINATORS, then_bb,\n \t\t\t      else_succ->dest))\n     ;\n   else\n@@ -2911,8 +2909,8 @@ find_if_case_2 (basic_block test_bb, edge then_edge, edge else_edge)\n \t\t    then_bb->global_live_at_start,\n \t\t    else_bb->global_live_at_end, BITMAP_IOR);\n \n-  if (post_dominators)\n-    delete_from_dominance_info (post_dominators, else_bb);\n+  if (dom_computed[CDI_POST_DOMINATORS] >= DOM_NO_FAST_QUERY)\n+    delete_from_dominance_info (CDI_POST_DOMINATORS, else_bb);\n   delete_block (else_bb);\n \n   num_true_changes++;\n@@ -3217,11 +3215,9 @@ if_convert (int x_life_data_ok)\n   free_basic_block_vars (1);\n \n   /* Compute postdominators if we think we'll use them.  */\n-  post_dominators = NULL;\n   if (HAVE_conditional_execution || life_data_ok)\n-    {\n-      post_dominators = calculate_dominance_info (CDI_POST_DOMINATORS);\n-    }\n+    calculate_dominance_info (CDI_POST_DOMINATORS);\n+\n   if (life_data_ok)\n     clear_bb_flags ();\n \n@@ -3258,8 +3254,7 @@ if_convert (int x_life_data_ok)\n     fprintf (rtl_dump_file, \"\\n\\n========== no more changes\\n\");\n #endif\n \n-  if (post_dominators)\n-    free_dominance_info (post_dominators);\n+  free_dominance_info (CDI_POST_DOMINATORS);\n \n   if (rtl_dump_file)\n     fflush (rtl_dump_file);"}, {"sha": "0b882d9e16367ed5ebce83c224ffcdb6f48434e7", "filename": "gcc/loop-init.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d47cc544b60738db5e983c4b1ac6b40236b9633c/gcc%2Floop-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d47cc544b60738db5e983c4b1ac6b40236b9633c/gcc%2Floop-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-init.c?ref=d47cc544b60738db5e983c4b1ac6b40236b9633c", "patch": "@@ -53,7 +53,9 @@ loop_optimizer_init (FILE *dumpfile)\n \n       /* No loops.  */\n       flow_loops_free (loops);\n+      free_dominance_info (CDI_DOMINATORS);\n       free (loops);\n+\n       /* Make chain.  */\n       FOR_EACH_BB (bb)\n \tif (bb->next_bb != EXIT_BLOCK_PTR)\n@@ -81,7 +83,7 @@ loop_optimizer_init (FILE *dumpfile)\n   flow_loops_dump (loops, dumpfile, NULL, 1);\n \n #ifdef ENABLE_CHECKING\n-  verify_dominators (loops->cfg.dom);\n+  verify_dominators (CDI_DOMINATORS);\n   verify_loop_structure (loops);\n #endif\n \n@@ -105,6 +107,7 @@ loop_optimizer_finalize (struct loops *loops, FILE *dumpfile)\n \n   /* Clean up.  */\n   flow_loops_free (loops);\n+  free_dominance_info (CDI_DOMINATORS);\n   free (loops);\n \n   /* Finalize changes.  */"}, {"sha": "6c796af577c836b31a8fa04416e800eed1aa9af5", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 36, "deletions": 44, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d47cc544b60738db5e983c4b1ac6b40236b9633c/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d47cc544b60738db5e983c4b1ac6b40236b9633c/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=d47cc544b60738db5e983c4b1ac6b40236b9633c", "patch": "@@ -68,14 +68,12 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n static void decide_unrolling_and_peeling (struct loops *, int);\n static void peel_loops_completely (struct loops *, int);\n-static void decide_peel_simple (struct loops *, struct loop *, int);\n-static void decide_peel_once_rolling (struct loops *, struct loop *, int);\n-static void decide_peel_completely (struct loops *, struct loop *, int);\n-static void decide_unroll_stupid (struct loops *, struct loop *, int);\n-static void decide_unroll_constant_iterations (struct loops *,\n-\t\t\t\t\t       struct loop *, int);\n-static void decide_unroll_runtime_iterations (struct loops *, struct loop *,\n-\t\t\t\t\t      int);\n+static void decide_peel_simple (struct loop *, int);\n+static void decide_peel_once_rolling (struct loop *, int);\n+static void decide_peel_completely (struct loop *, int);\n+static void decide_unroll_stupid (struct loop *, int);\n+static void decide_unroll_constant_iterations (struct loop *, int);\n+static void decide_unroll_runtime_iterations (struct loop *, int);\n static void peel_loop_simple (struct loops *, struct loop *);\n static void peel_loop_completely (struct loops *, struct loop *);\n static void unroll_loop_stupid (struct loops *, struct loop *);\n@@ -140,7 +138,7 @@ unroll_and_peel_loops (struct loops *loops, int flags)\n       if (check)\n \t{\n #ifdef ENABLE_CHECKING\n-\t  verify_dominators (loops->cfg.dom);\n+\t  verify_dominators (CDI_DOMINATORS);\n \t  verify_loop_structure (loops);\n #endif\n \t}\n@@ -178,15 +176,15 @@ peel_loops_completely (struct loops *loops, int flags)\n \n       loop->ninsns = num_loop_insns (loop);\n \n-      decide_peel_once_rolling (loops, loop, flags);\n+      decide_peel_once_rolling (loop, flags);\n       if (loop->lpt_decision.decision == LPT_NONE)\n-\tdecide_peel_completely (loops, loop, flags);\n+\tdecide_peel_completely (loop, flags);\n \n       if (loop->lpt_decision.decision == LPT_PEEL_COMPLETELY)\n \t{\n \t  peel_loop_completely (loops, loop);\n #ifdef ENABLE_CHECKING\n-\t  verify_dominators (loops->cfg.dom);\n+\t  verify_dominators (CDI_DOMINATORS);\n \t  verify_loop_structure (loops);\n #endif\n \t}\n@@ -254,13 +252,13 @@ decide_unrolling_and_peeling (struct loops *loops, int flags)\n       /* Try transformations one by one in decreasing order of\n \t priority.  */\n \n-      decide_unroll_constant_iterations (loops, loop, flags);\n+      decide_unroll_constant_iterations (loop, flags);\n       if (loop->lpt_decision.decision == LPT_NONE)\n-\tdecide_unroll_runtime_iterations (loops, loop, flags);\n+\tdecide_unroll_runtime_iterations (loop, flags);\n       if (loop->lpt_decision.decision == LPT_NONE)\n-\tdecide_unroll_stupid (loops, loop, flags);\n+\tdecide_unroll_stupid (loop, flags);\n       if (loop->lpt_decision.decision == LPT_NONE)\n-\tdecide_peel_simple (loops, loop, flags);\n+\tdecide_peel_simple (loop, flags);\n \n       loop = next;\n     }\n@@ -269,8 +267,7 @@ decide_unrolling_and_peeling (struct loops *loops, int flags)\n /* Decide whether the LOOP is once rolling and suitable for complete\n    peeling.  */\n static void\n-decide_peel_once_rolling (struct loops *loops, struct loop *loop,\n-\t\t\t  int flags ATTRIBUTE_UNUSED)\n+decide_peel_once_rolling (struct loop *loop, int flags ATTRIBUTE_UNUSED)\n {\n   if (rtl_dump_file)\n     fprintf (rtl_dump_file, \";; Considering peeling once rolling loop\\n\");\n@@ -284,7 +281,7 @@ decide_peel_once_rolling (struct loops *loops, struct loop *loop,\n     }\n \n   /* Check for simple loops.  */\n-  loop->simple = simple_loop_p (loops, loop, &loop->desc);\n+  loop->simple = simple_loop_p (loop, &loop->desc);\n   loop->has_desc = 1;\n \n   /* Check number of iterations.  */\n@@ -303,8 +300,7 @@ decide_peel_once_rolling (struct loops *loops, struct loop *loop,\n \n /* Decide whether the LOOP is suitable for complete peeling.  */\n static void\n-decide_peel_completely (struct loops *loops, struct loop *loop,\n-\t\t\tint flags ATTRIBUTE_UNUSED)\n+decide_peel_completely (struct loop *loop, int flags ATTRIBUTE_UNUSED)\n {\n   unsigned npeel;\n \n@@ -352,7 +348,7 @@ decide_peel_completely (struct loops *loops, struct loop *loop,\n   /* Check for simple loops.  */\n   if (!loop->has_desc)\n     {\n-      loop->simple = simple_loop_p (loops, loop, &loop->desc);\n+      loop->simple = simple_loop_p (loop, &loop->desc);\n       loop->has_desc = 1;\n     }\n \n@@ -441,8 +437,7 @@ peel_loop_completely (struct loops *loops, struct loop *loop)\n \n /* Decide whether to unroll LOOP iterating constant number of times and how much.  */\n static void\n-decide_unroll_constant_iterations (struct loops *loops, struct loop *loop,\n-\t\t\t\t   int flags)\n+decide_unroll_constant_iterations (struct loop *loop, int flags)\n {\n   unsigned nunroll, nunroll_by_av, best_copies, best_unroll = -1, n_copies, i;\n \n@@ -475,7 +470,7 @@ decide_unroll_constant_iterations (struct loops *loops, struct loop *loop,\n   /* Check for simple loops.  */\n   if (!loop->has_desc)\n     {\n-      loop->simple = simple_loop_p (loops, loop, &loop->desc);\n+      loop->simple = simple_loop_p (loop, &loop->desc);\n       loop->has_desc = 1;\n     }\n \n@@ -649,8 +644,7 @@ unroll_loop_constant_iterations (struct loops *loops, struct loop *loop)\n /* Decide whether to unroll LOOP iterating runtime computable number of times\n    and how much.  */\n static void\n-decide_unroll_runtime_iterations (struct loops *loops, struct loop *loop,\n-\t\t\t\t  int flags)\n+decide_unroll_runtime_iterations (struct loop *loop, int flags)\n {\n   unsigned nunroll, nunroll_by_av, i;\n \n@@ -683,7 +677,7 @@ decide_unroll_runtime_iterations (struct loops *loops, struct loop *loop,\n   /* Check for simple loops.  */\n   if (!loop->has_desc)\n     {\n-      loop->simple = simple_loop_p (loops, loop, &loop->desc);\n+      loop->simple = simple_loop_p (loop, &loop->desc);\n       loop->has_desc = 1;\n     }\n \n@@ -774,7 +768,7 @@ unroll_loop_runtime_iterations (struct loops *loops, struct loop *loop)\n       unsigned nldom;\n       basic_block *ldom;\n \n-      nldom = get_dominated_by (loops->cfg.dom, body[i], &ldom);\n+      nldom = get_dominated_by (CDI_DOMINATORS, body[i], &ldom);\n       for (j = 0; j < nldom; j++)\n \tif (!flow_bb_inside_loop_p (loop, ldom[j]))\n \t  dom_bbs[n_dom_bbs++] = ldom[j];\n@@ -821,7 +815,7 @@ unroll_loop_runtime_iterations (struct loops *loops, struct loop *loop)\n   end_sequence ();\n \n   /* Precondition the loop.  */\n-  loop_split_edge_with (loop_preheader_edge (loop), init_code, loops);\n+  loop_split_edge_with (loop_preheader_edge (loop), init_code);\n \n   remove_edges = xcalloc (max_unroll + n_peel + 1, sizeof (edge));\n   n_remove_edges = 0;\n@@ -844,7 +838,7 @@ unroll_loop_runtime_iterations (struct loops *loops, struct loop *loop)\n \n   /* Record the place where switch will be built for preconditioning.  */\n   swtch = loop_split_edge_with (loop_preheader_edge (loop),\n-\t\t\t\tNULL_RTX, loops);\n+\t\t\t\tNULL_RTX);\n \n   for (i = 0; i < n_peel; i++)\n     {\n@@ -862,8 +856,7 @@ unroll_loop_runtime_iterations (struct loops *loops, struct loop *loop)\n       j = n_peel - i - (extra_zero_check ? 0 : 1);\n       p = REG_BR_PROB_BASE / (i + 2);\n \n-      preheader = loop_split_edge_with (loop_preheader_edge (loop),\n-\t\t\t\t\tNULL_RTX, loops);\n+      preheader = loop_split_edge_with (loop_preheader_edge (loop), NULL_RTX);\n       label = block_label (preheader);\n       start_sequence ();\n       do_compare_rtx_and_jump (copy_rtx (niter), GEN_INT (j), EQ, 0,\n@@ -879,8 +872,8 @@ unroll_loop_runtime_iterations (struct loops *loops, struct loop *loop)\n       branch_code = get_insns ();\n       end_sequence ();\n \n-      swtch = loop_split_edge_with (swtch->pred, branch_code, loops);\n-      set_immediate_dominator (loops->cfg.dom, preheader, swtch);\n+      swtch = loop_split_edge_with (swtch->pred, branch_code);\n+      set_immediate_dominator (CDI_DOMINATORS, preheader, swtch);\n       swtch->succ->probability = REG_BR_PROB_BASE - p;\n       e = make_edge (swtch, preheader,\n \t\t     swtch->succ->flags & EDGE_IRREDUCIBLE_LOOP);\n@@ -892,8 +885,7 @@ unroll_loop_runtime_iterations (struct loops *loops, struct loop *loop)\n       /* Add branch for zero iterations.  */\n       p = REG_BR_PROB_BASE / (max_unroll + 1);\n       swtch = ezc_swtch;\n-      preheader = loop_split_edge_with (loop_preheader_edge (loop),\n-\t\t\t\t\tNULL_RTX, loops);\n+      preheader = loop_split_edge_with (loop_preheader_edge (loop), NULL_RTX);\n       label = block_label (preheader);\n       start_sequence ();\n       do_compare_rtx_and_jump (copy_rtx (niter), const0_rtx, EQ, 0,\n@@ -909,16 +901,16 @@ unroll_loop_runtime_iterations (struct loops *loops, struct loop *loop)\n       branch_code = get_insns ();\n       end_sequence ();\n \n-      swtch = loop_split_edge_with (swtch->succ, branch_code, loops);\n-      set_immediate_dominator (loops->cfg.dom, preheader, swtch);\n+      swtch = loop_split_edge_with (swtch->succ, branch_code);\n+      set_immediate_dominator (CDI_DOMINATORS, preheader, swtch);\n       swtch->succ->probability = REG_BR_PROB_BASE - p;\n       e = make_edge (swtch, preheader,\n \t\t     swtch->succ->flags & EDGE_IRREDUCIBLE_LOOP);\n       e->probability = p;\n     }\n \n   /* Recount dominators for outer blocks.  */\n-  iterate_fix_dominators (loops->cfg.dom, dom_bbs, n_dom_bbs);\n+  iterate_fix_dominators (CDI_DOMINATORS, dom_bbs, n_dom_bbs);\n \n   /* And unroll loop.  */\n \n@@ -946,7 +938,7 @@ unroll_loop_runtime_iterations (struct loops *loops, struct loop *loop)\n \n /* Decide whether to simply peel LOOP and how much.  */\n static void\n-decide_peel_simple (struct loops *loops, struct loop *loop, int flags)\n+decide_peel_simple (struct loop *loop, int flags)\n {\n   unsigned npeel;\n \n@@ -975,7 +967,7 @@ decide_peel_simple (struct loops *loops, struct loop *loop, int flags)\n   /* Check for simple loops.  */\n   if (!loop->has_desc)\n     {\n-      loop->simple = simple_loop_p (loops, loop, &loop->desc);\n+      loop->simple = simple_loop_p (loop, &loop->desc);\n       loop->has_desc = 1;\n     }\n \n@@ -1062,7 +1054,7 @@ peel_loop_simple (struct loops *loops, struct loop *loop)\n \n /* Decide whether to unroll LOOP stupidly and how much.  */\n static void\n-decide_unroll_stupid (struct loops *loops, struct loop *loop, int flags)\n+decide_unroll_stupid (struct loop *loop, int flags)\n {\n   unsigned nunroll, nunroll_by_av, i;\n \n@@ -1095,7 +1087,7 @@ decide_unroll_stupid (struct loops *loops, struct loop *loop, int flags)\n   /* Check for simple loops.  */\n   if (!loop->has_desc)\n     {\n-      loop->simple = simple_loop_p (loops, loop, &loop->desc);\n+      loop->simple = simple_loop_p (loop, &loop->desc);\n       loop->has_desc = 1;\n     }\n "}, {"sha": "4cfaa2f62554b07e014aef78dddcf53d826cab2c", "filename": "gcc/loop-unswitch.c", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d47cc544b60738db5e983c4b1ac6b40236b9633c/gcc%2Floop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d47cc544b60738db5e983c4b1ac6b40236b9633c/gcc%2Floop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unswitch.c?ref=d47cc544b60738db5e983c4b1ac6b40236b9633c", "patch": "@@ -81,7 +81,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n static struct loop *unswitch_loop (struct loops *, struct loop *,\n \t\t\t\t   basic_block);\n static void unswitch_single_loop (struct loops *, struct loop *, rtx, int);\n-static bool may_unswitch_on_p (struct loops *, basic_block, struct loop *,\n+static bool may_unswitch_on_p (basic_block, struct loop *,\n \t\t\t       basic_block *);\n static rtx reversed_condition (rtx);\n \n@@ -107,7 +107,7 @@ unswitch_loops (struct loops *loops)\n \n       unswitch_single_loop (loops, loop, NULL_RTX, 0);\n #ifdef ENABLE_CHECKING\n-      verify_dominators (loops->cfg.dom);\n+      verify_dominators (CDI_DOMINATORS);\n       verify_loop_structure (loops);\n #endif\n     }\n@@ -117,8 +117,7 @@ unswitch_loops (struct loops *loops)\n    basic blocks (for what it means see comments below).  List of basic blocks\n    inside LOOP is provided in BODY to save time.  */\n static bool\n-may_unswitch_on_p (struct loops *loops, basic_block bb, struct loop *loop,\n-\t\t   basic_block *body)\n+may_unswitch_on_p (basic_block bb, struct loop *loop, basic_block *body)\n {\n   rtx test;\n   unsigned i;\n@@ -136,7 +135,7 @@ may_unswitch_on_p (struct loops *loops, basic_block bb, struct loop *loop,\n \n   /* It must be executed just once each iteration (because otherwise we\n      are unable to update dominator/irreducible loop information correctly).  */\n-  if (!just_once_each_iteration_p (loops, loop, bb))\n+  if (!just_once_each_iteration_p (loop, bb))\n     return false;\n \n   /* Condition must be invariant.  We use just a stupid test of invariantness\n@@ -239,7 +238,7 @@ unswitch_single_loop (struct loops *loops, struct loop *loop,\n       /* Find a bb to unswitch on.  */\n       bbs = get_loop_body (loop);\n       for (i = 0; i < loop->num_nodes; i++)\n-\tif (may_unswitch_on_p (loops, bbs[i], loop, bbs))\n+\tif (may_unswitch_on_p (bbs[i], loop, bbs))\n \t  break;\n \n       if (i == loop->num_nodes)\n@@ -295,7 +294,7 @@ unswitch_single_loop (struct loops *loops, struct loop *loop,\n     rconds = cond_checked;\n \n   /* Separate condition in a single basic block.  */\n-  bb = split_loop_bb (loops, bbs[i], PREV_INSN (split_before))->dest;\n+  bb = split_loop_bb (bbs[i], PREV_INSN (split_before))->dest;\n   free (bbs);\n   true_first = !(bb->succ->flags & EDGE_FALLTHRU);\n   if (rtl_dump_file)\n@@ -335,7 +334,7 @@ unswitch_loop (struct loops *loops, struct loop *loop, basic_block unswitch_on)\n   if (!unswitch_on->succ || !unswitch_on->succ->succ_next ||\n       unswitch_on->succ->succ_next->succ_next)\n     abort ();\n-  if (!just_once_each_iteration_p (loops, loop, unswitch_on))\n+  if (!just_once_each_iteration_p (loop, unswitch_on))\n     abort ();\n   if (loop->inner)\n     abort ();\n@@ -382,7 +381,7 @@ unswitch_loop (struct loops *loops, struct loop *loop, basic_block unswitch_on)\n       switch_bb->succ->flags &= ~EDGE_IRREDUCIBLE_LOOP;\n       switch_bb->succ->succ_next->flags &= ~EDGE_IRREDUCIBLE_LOOP;\n     }\n-  add_to_dominance_info (loops->cfg.dom, switch_bb);\n+  add_to_dominance_info (CDI_DOMINATORS, switch_bb);\n   unswitch_on->rbi->copy = unswitch_on_alt;\n \n   /* Loopify from the copy of LOOP body, constructing the new loop.  */\n@@ -403,8 +402,8 @@ unswitch_loop (struct loops *loops, struct loop *loop, basic_block unswitch_on)\n   fix_loop_placement (nloop);\n \n   /* Preserve the simple loop preheaders.  */\n-  loop_split_edge_with (loop_preheader_edge (loop), NULL_RTX, loops);\n-  loop_split_edge_with (loop_preheader_edge (nloop), NULL_RTX, loops);\n+  loop_split_edge_with (loop_preheader_edge (loop), NULL_RTX);\n+  loop_split_edge_with (loop_preheader_edge (nloop), NULL_RTX);\n \n   return nloop;\n }"}, {"sha": "74a1f24c3ad504b36e37f822b9a42c413426b7db", "filename": "gcc/predict.c", "status": "modified", "additions": 22, "deletions": 38, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d47cc544b60738db5e983c4b1ac6b40236b9633c/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d47cc544b60738db5e983c4b1ac6b40236b9633c/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=d47cc544b60738db5e983c4b1ac6b40236b9633c", "patch": "@@ -72,10 +72,8 @@ static void estimate_loops_at_level (struct loop *loop);\n static void propagate_freq (struct loop *);\n static void estimate_bb_frequencies (struct loops *);\n static void counts_to_freqs (void);\n-static void process_note_predictions (basic_block, int *, dominance_info,\n-\t\t\t\t      dominance_info);\n-static void process_note_prediction (basic_block, int *, dominance_info,\n-\t\t\t\t     dominance_info, int, int);\n+static void process_note_predictions (basic_block, int *);\n+static void process_note_prediction (basic_block, int *, int, int);\n static bool last_basic_block_p (basic_block);\n static void compute_function_frequency (void);\n static void choose_function_section (void);\n@@ -393,13 +391,12 @@ combine_predictions_for_insn (rtx insn, basic_block bb)\n void\n estimate_probability (struct loops *loops_info)\n {\n-  dominance_info dominators, post_dominators;\n   basic_block bb;\n   unsigned i;\n \n   connect_infinite_loops_to_exit ();\n-  dominators = calculate_dominance_info (CDI_DOMINATORS);\n-  post_dominators = calculate_dominance_info (CDI_POST_DOMINATORS);\n+  calculate_dominance_info (CDI_DOMINATORS);\n+  calculate_dominance_info (CDI_POST_DOMINATORS);\n \n   /* Try to predict out blocks in a loop that are not part of a\n      natural loop.  */\n@@ -412,11 +409,10 @@ estimate_probability (struct loops *loops_info)\n       struct loop_desc desc;\n       unsigned HOST_WIDE_INT niter;\n \n-      flow_loop_scan (loops_info, loop, LOOP_EXIT_EDGES);\n+      flow_loop_scan (loop, LOOP_EXIT_EDGES);\n       exits = loop->num_exits;\n \n-      if (simple_loop_p (loops_info, loop, &desc)\n-\t  && desc.const_iter)\n+      if (simple_loop_p (loop, &desc) && desc.const_iter)\n \t{\n \t  int prob;\n \t  niter = desc.niter + 1;\n@@ -500,8 +496,8 @@ estimate_probability (struct loops *loops_info)\n \t  /* Look for block we are guarding (ie we dominate it,\n \t     but it doesn't postdominate us).  */\n \t  if (e->dest != EXIT_BLOCK_PTR && e->dest != bb\n-\t      && dominated_by_p (dominators, e->dest, e->src)\n-\t      && !dominated_by_p (post_dominators, e->src, e->dest))\n+\t      && dominated_by_p (CDI_DOMINATORS, e->dest, e->src)\n+\t      && !dominated_by_p (CDI_POST_DOMINATORS, e->src, e->dest))\n \t    {\n \t      rtx insn;\n \n@@ -618,8 +614,7 @@ estimate_probability (struct loops *loops_info)\n \t&& bb->succ->succ_next != NULL)\n       combine_predictions_for_insn (BB_END (bb), bb);\n \n-  free_dominance_info (post_dominators);\n-  free_dominance_info (dominators);\n+  free_dominance_info (CDI_POST_DOMINATORS);\n \n   remove_fake_edges ();\n   estimate_bb_frequencies (loops_info);\n@@ -719,10 +714,7 @@ last_basic_block_p (basic_block bb)\n    on demand, so -1 may be there in case this was not needed yet).  */\n \n static void\n-process_note_prediction (basic_block bb, int *heads,\n-\t\t\t dominance_info dominators,\n-\t\t\t dominance_info post_dominators, int pred,\n-\t\t\t int flags)\n+process_note_prediction (basic_block bb, int *heads, int pred, int flags)\n {\n   edge e;\n   int y;\n@@ -736,18 +728,18 @@ process_note_prediction (basic_block bb, int *heads,\n          find first dominator that we do not post-dominate (we are\n          using already known members of heads array).  */\n       basic_block ai = bb;\n-      basic_block next_ai = get_immediate_dominator (dominators, bb);\n+      basic_block next_ai = get_immediate_dominator (CDI_DOMINATORS, bb);\n       int head;\n \n       while (heads[next_ai->index] < 0)\n \t{\n-\t  if (!dominated_by_p (post_dominators, next_ai, bb))\n+\t  if (!dominated_by_p (CDI_POST_DOMINATORS, next_ai, bb))\n \t    break;\n \t  heads[next_ai->index] = ai->index;\n \t  ai = next_ai;\n-\t  next_ai = get_immediate_dominator (dominators, next_ai);\n+\t  next_ai = get_immediate_dominator (CDI_DOMINATORS, next_ai);\n \t}\n-      if (!dominated_by_p (post_dominators, next_ai, bb))\n+      if (!dominated_by_p (CDI_POST_DOMINATORS, next_ai, bb))\n \thead = next_ai->index;\n       else\n \thead = heads[next_ai->index];\n@@ -769,7 +761,7 @@ process_note_prediction (basic_block bb, int *heads,\n     return;\n   for (e = BASIC_BLOCK (y)->succ; e; e = e->succ_next)\n     if (e->dest->index >= 0\n-\t&& dominated_by_p (post_dominators, e->dest, bb))\n+\t&& dominated_by_p (CDI_POST_DOMINATORS, e->dest, bb))\n       predict_edge_def (e, pred, taken);\n }\n \n@@ -778,9 +770,7 @@ process_note_prediction (basic_block bb, int *heads,\n    process_note_prediction.  */\n \n static void\n-process_note_predictions (basic_block bb, int *heads,\n-\t\t\t  dominance_info dominators,\n-\t\t\t  dominance_info post_dominators)\n+process_note_predictions (basic_block bb, int *heads)\n {\n   rtx insn;\n   edge e;\n@@ -813,8 +803,6 @@ process_note_predictions (basic_block bb, int *heads,\n \t  /* Process single prediction note.  */\n \t  process_note_prediction (bb,\n \t\t\t\t   heads,\n-\t\t\t\t   dominators,\n-\t\t\t\t   post_dominators,\n \t\t\t\t   alg, (int) NOTE_PREDICTION_FLAGS (insn));\n \t  delete_insn (insn);\n \t}\n@@ -827,10 +815,7 @@ process_note_predictions (basic_block bb, int *heads,\n       /* This block ended from other reasons than because of return.\n          If it is because of noreturn call, this should certainly not\n          be taken.  Otherwise it is probably some error recovery.  */\n-      process_note_prediction (bb,\n-\t\t\t       heads,\n-\t\t\t       dominators,\n-\t\t\t       post_dominators, PRED_NORETURN, NOT_TAKEN);\n+      process_note_prediction (bb, heads, PRED_NORETURN, NOT_TAKEN);\n     }\n }\n \n@@ -841,15 +826,14 @@ void\n note_prediction_to_br_prob (void)\n {\n   basic_block bb;\n-  dominance_info post_dominators, dominators;\n   int *heads;\n \n   /* To enable handling of noreturn blocks.  */\n   add_noreturn_fake_exit_edges ();\n   connect_infinite_loops_to_exit ();\n \n-  post_dominators = calculate_dominance_info (CDI_POST_DOMINATORS);\n-  dominators = calculate_dominance_info (CDI_DOMINATORS);\n+  calculate_dominance_info (CDI_POST_DOMINATORS);\n+  calculate_dominance_info (CDI_DOMINATORS);\n \n   heads = xmalloc (sizeof (int) * last_basic_block);\n   memset (heads, -1, sizeof (int) * last_basic_block);\n@@ -858,10 +842,10 @@ note_prediction_to_br_prob (void)\n   /* Process all prediction notes.  */\n \n   FOR_EACH_BB (bb)\n-    process_note_predictions (bb, heads, dominators, post_dominators);\n+    process_note_predictions (bb, heads);\n \n-  free_dominance_info (post_dominators);\n-  free_dominance_info (dominators);\n+  free_dominance_info (CDI_POST_DOMINATORS);\n+  free_dominance_info (CDI_DOMINATORS);\n   free (heads);\n \n   remove_fake_edges ();"}, {"sha": "b8e474d0b448b11bb7d83c4d03a85ec5afd274d8", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d47cc544b60738db5e983c4b1ac6b40236b9633c/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d47cc544b60738db5e983c4b1ac6b40236b9633c/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=d47cc544b60738db5e983c4b1ac6b40236b9633c", "patch": "@@ -155,7 +155,7 @@ static int *containing_rgn;\n \n void debug_regions (void);\n static void find_single_block_region (void);\n-static void find_rgns (struct edge_list *, dominance_info);\n+static void find_rgns (struct edge_list *);\n static int too_large (int, int *, int *);\n \n extern void debug_live (int, int);\n@@ -613,7 +613,7 @@ too_large (int block, int *num_bbs, int *num_insns)\n    of edge tables.  That would simplify it somewhat.  */\n \n static void\n-find_rgns (struct edge_list *edge_list, dominance_info dom)\n+find_rgns (struct edge_list *edge_list)\n {\n   int *max_hdr, *dfs_nr, *stack, *degree;\n   char no_loops = 1;\n@@ -827,7 +827,7 @@ find_rgns (struct edge_list *edge_list, dominance_info dom)\n \t\t    {\n \t\t      /* Now verify that the block is dominated by the loop\n \t\t\t header.  */\n-\t\t      if (!dominated_by_p (dom, jbb, bb))\n+\t\t      if (!dominated_by_p (CDI_DOMINATORS, jbb, bb))\n \t\t\tbreak;\n \t\t    }\n \t\t}\n@@ -2597,7 +2597,6 @@ init_regions (void)\n \t}\n       else\n \t{\n-\t  dominance_info dom;\n \t  struct edge_list *edge_list;\n \n \t  /* The scheduler runs after estimate_probabilities; therefore, we\n@@ -2607,15 +2606,15 @@ init_regions (void)\n \t  edge_list = create_edge_list ();\n \n \t  /* Compute the dominators and post dominators.  */\n-\t  dom = calculate_dominance_info (CDI_DOMINATORS);\n+\t  calculate_dominance_info (CDI_DOMINATORS);\n \n \t  /* build_control_flow will return nonzero if it detects unreachable\n \t     blocks or any other irregularity with the cfg which prevents\n \t     cross block scheduling.  */\n \t  if (build_control_flow (edge_list) != 0)\n \t    find_single_block_region ();\n \t  else\n-\t    find_rgns (edge_list, dom);\n+\t    find_rgns (edge_list);\n \n \t  if (sched_verbose >= 3)\n \t    debug_regions ();\n@@ -2625,7 +2624,7 @@ init_regions (void)\n \n \t  /* For now.  This will move as more and more of haifa is converted\n \t     to using the cfg code in flow.c.  */\n-\t  free_dominance_info (dom);\n+\t  free_dominance_info (CDI_DOMINATORS);\n \t}\n     }\n "}, {"sha": "6e34c6d6c06922b5d15b16bf7d526e5d8948c8df", "filename": "gcc/toplev.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d47cc544b60738db5e983c4b1ac6b40236b9633c/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d47cc544b60738db5e983c4b1ac6b40236b9633c/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=d47cc544b60738db5e983c4b1ac6b40236b9633c", "patch": "@@ -2477,6 +2477,7 @@ rest_of_handle_branch_prob (tree decl, rtx insns)\n     estimate_probability (&loops);\n \n   flow_loops_free (&loops);\n+  free_dominance_info (CDI_DOMINATORS);\n   close_dump_file (DFI_bp, print_rtl_with_bb, insns);\n   timevar_pop (TV_BRANCH_PROB);\n }\n@@ -3014,8 +3015,9 @@ rest_of_handle_loop_optimize (tree decl, rtx insns)\n    sooner, but we want the profile feedback to work more\n    efficiently.  */\n static void\n-rest_of_handle_loop2 (tree decl, rtx insns)\n+rest_of_handle_loop2 (tree decl ATTRIBUTE_UNUSED, rtx insns ATTRIBUTE_UNUSED)\n {\n+#if 0\n   struct loops *loops;\n   timevar_push (TV_LOOP);\n   open_dump_file (DFI_loop2, decl);\n@@ -3047,6 +3049,7 @@ rest_of_handle_loop2 (tree decl, rtx insns)\n   close_dump_file (DFI_loop2, print_rtl_with_bb, get_insns ());\n   timevar_pop (TV_LOOP);\n   ggc_collect ();\n+#endif\n }\n \n /* This is called from finish_function (within langhooks.parse_file)"}]}