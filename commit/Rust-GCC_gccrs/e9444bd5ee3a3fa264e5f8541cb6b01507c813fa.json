{"sha": "e9444bd5ee3a3fa264e5f8541cb6b01507c813fa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTk0NDRiZDVlZTNhM2ZhMjY0ZTVmODU0MWNiNmIwMTUwN2M4MTNmYQ==", "commit": {"author": {"name": "Tobias Schl\u00fcter", "email": "tobias.schlueter@physik.uni-muenchen.de", "date": "2005-02-23T22:14:12Z"}, "committer": {"name": "Tobias Schl\u00fcter", "email": "tobi@gcc.gnu.org", "date": "2005-02-23T22:14:12Z"}, "message": "gfortran.h (gfc_component, [...]): Make 'name' a 'const char *'.\n\n* gfortran.h (gfc_component, gfc_actual_arglist, gfc_user_op): Make\n'name' a 'const char *'.\n(gfc_symbol): Likewise, also for 'module'.\n(gfc_symtree): Make 'name' a 'const char *'.\n(gfc_intrinsic_sym): Likewise, also for 'lib_name'.\n(gfc_get_gsymbol, gfc_find_gsymbol): Add 'const' qualifier to\n'char *' argument.\n(gfc_intrinsic_symbol): Use 'gfc_get_string' instead of 'strcpy' to\ninitialize 'SYM->module'.\n* check.c (gfc_check_minloc_maxloc, check_reduction): Check for NULL\npointer instead of empty string.\n* dump-parse-tree.c (gfc_show_actual_arglist): Likewise.\n* interface.c (gfc_compare_types): Adapt check to account for possible\nNULL pointer.\n(compare_actual_formal): Check for NULL pointer instead of empty\nstring.\n* intrinsic.c (gfc_current_intrinsic, gfc_current_intrinsic_arg):\nAdd 'const' qualifier.\n(conv_name): Return a heap allocated string.\n(find_conv): Add 'const' qualifier to 'target'.\n(add_sym): Use 'gfc_get_string' instead of 'strcpy'.\n(make_generic): Check for NULL pointer instead of emptystring.\n(make_alias): Use 'gfc_get_string' instead of 'strcpy'.\n(add_conv): No need to strcpy result from 'conv_name'.\n(sort_actual): Check for NULL pointer instead of emptystring.\n* intrinsic.h (gfc_current_intrinsic, gfc_current_intrinsic_arg):\nAdapt prototype.\n* module.c (compare_true_names): Compare pointers instead of strings\nfor 'module' member.\n(find_true_name): Initialize string fields with gfc_get_string.\n(mio_pool_string): New function.\n(mio_internal_string): Adapt comment.\n(mio_component_ref, mio_component, mio_actual_arg): Use\n'mio_pool_string' instead of 'mio_internal_string'.\n(mio_symbol_interface): Add 'const' qualifier to string arguments.\nAdd level of indirection. Use 'mio_pool_string' instead of\n'mio_internal_string'.\n(load_needed, read_module): Use 'gfc_get_string' instead of 'strcpy'.\n(write_common, write_symbol): Use 'mio_pool_string' instead of\n'mio_internal_string'.\n(write_symbol0, write_symbol1): Likewise, also check for NULL pointer\ninstead of empty string.\n(write_operator, write_generic): Pass correct type variable to\n'mio_symbol_interface'.\n(write_symtree): Use 'mio_pool_string' instead of\n'mio_internal_string'.\n* primary.c (match_keyword_arg): Adapt check to possible\ncase of NULL pointer.  Use 'gfc_get_string' instead of 'strcpy'.\n* symbol.c (gfc_add_component, gfc_new_symtree, delete_symtree,\ngfc_get_uop, gfc_new_symbol): Use 'gfc_get_string' instead of\n'strcpy'.\n(ambiguous_symbol): Check for NULL pointer instead of empty string.\n(gfc_find_gsymbol, gfc_get_gsymbol): Add 'const' qualifier on string\narguments.\n* trans-array.c (gfc_trans_auto_array_allocation): Check for NULL\npointer instead of empty string.\n* trans-decl.c (gfc_sym_mangled_identifier,\ngfc_sym_mangled_function_id, gfc_finish_var_decl, gfc_get_symbol_decl,\ngfc_get_symbol_decl): Likewise.\n* trans-io.c (gfc_new_nml_name_expr): Add 'const' qualifier to\nargument.  Copy string instead of pointing to it.\n\nFrom-SVN: r95472", "tree": {"sha": "94405864274f14b88cb5fd2d24eba85e42579556", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/94405864274f14b88cb5fd2d24eba85e42579556"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e9444bd5ee3a3fa264e5f8541cb6b01507c813fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9444bd5ee3a3fa264e5f8541cb6b01507c813fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9444bd5ee3a3fa264e5f8541cb6b01507c813fa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9444bd5ee3a3fa264e5f8541cb6b01507c813fa/comments", "author": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "58b03ab29f5bad84af12b599a1791c65c2d01405", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58b03ab29f5bad84af12b599a1791c65c2d01405", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58b03ab29f5bad84af12b599a1791c65c2d01405"}], "stats": {"total": 241, "additions": 167, "deletions": 74}, "files": [{"sha": "f35b20264b10a9da6d63a502f53f2f804afd06f7", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9444bd5ee3a3fa264e5f8541cb6b01507c813fa/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9444bd5ee3a3fa264e5f8541cb6b01507c813fa/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=e9444bd5ee3a3fa264e5f8541cb6b01507c813fa", "patch": "@@ -38,6 +38,68 @@\n \t* trans-expr.c (gfc_conv_unary_op, gfc_conv_power_op,\n \tgfc_conv_concat_op, gfc_conv_expr_op): Likewise.\n \n+\t* gfortran.h (gfc_component, gfc_actual_arglist, gfc_user_op): Make\n+\t'name' a 'const char *'.\n+\t(gfc_symbol): Likewise, also for 'module'.\n+\t(gfc_symtree): Make 'name' a 'const char *'.\n+\t(gfc_intrinsic_sym): Likewise, also for 'lib_name'.\n+\t(gfc_get_gsymbol, gfc_find_gsymbol): Add 'const' qualifier to\n+\t'char *' argument.\n+\t(gfc_intrinsic_symbol): Use 'gfc_get_string' instead of 'strcpy' to\n+\tinitialize 'SYM->module'.\n+\t* check.c (gfc_check_minloc_maxloc, check_reduction): Check for NULL\n+\tpointer instead of empty string.\n+\t* dump-parse-tree.c (gfc_show_actual_arglist): Likewise.\n+\t* interface.c (gfc_compare_types): Adapt check to account for possible\n+\tNULL pointer.\n+\t(compare_actual_formal): Check for NULL pointer instead of empty\n+\tstring.\n+\t* intrinsic.c (gfc_current_intrinsic, gfc_current_intrinsic_arg):\n+\tAdd 'const' qualifier.\t\n+\t(conv_name): Return a heap allocated string.\n+\t(find_conv): Add 'const' qualifier to 'target'.\n+\t(add_sym): Use 'gfc_get_string' instead of 'strcpy'.\n+\t(make_generic): Check for NULL pointer instead of empty\tstring.\n+\t(make_alias): Use 'gfc_get_string' instead of 'strcpy'.\n+\t(add_conv): No need to strcpy result from 'conv_name'.\n+\t(sort_actual): Check for NULL pointer instead of empty\tstring.\n+\t* intrinsic.h (gfc_current_intrinsic, gfc_current_intrinsic_arg):\n+\tAdapt prototype.\n+\t* module.c (compare_true_names): Compare pointers instead of strings\n+\tfor 'module' member.\n+\t(find_true_name): Initialize string fields with gfc_get_string.\n+\t(mio_pool_string): New function.\n+\t(mio_internal_string): Adapt comment.\n+\t(mio_component_ref, mio_component, mio_actual_arg): Use\n+\t'mio_pool_string' instead of 'mio_internal_string'.\n+\t(mio_symbol_interface): Add 'const' qualifier to string arguments.\n+\tAdd level of indirection. Use 'mio_pool_string' instead of\n+\t'mio_internal_string'.\n+\t(load_needed, read_module): Use 'gfc_get_string' instead of 'strcpy'.\n+\t(write_common, write_symbol): Use 'mio_pool_string' instead of\n+\t'mio_internal_string'.\n+\t(write_symbol0, write_symbol1): Likewise, also check for NULL pointer\n+\tinstead of empty string.\n+\t(write_operator, write_generic): Pass correct type variable to\n+\t'mio_symbol_interface'.\n+\t(write_symtree): Use 'mio_pool_string' instead of\n+\t'mio_internal_string'.\n+\t* primary.c (match_keyword_arg): Adapt check to possible\n+\tcase of NULL pointer.  Use 'gfc_get_string' instead of 'strcpy'.\n+\t* symbol.c (gfc_add_component, gfc_new_symtree, delete_symtree,\n+\tgfc_get_uop, gfc_new_symbol): Use 'gfc_get_string' instead of\n+\t'strcpy'.\n+\t(ambiguous_symbol): Check for NULL pointer instead of empty string.\n+\t(gfc_find_gsymbol, gfc_get_gsymbol): Add 'const' qualifier on string\n+\targuments.\n+\t* trans-array.c (gfc_trans_auto_array_allocation): Check for NULL\n+\tpointer instead of empty string.\n+\t* trans-decl.c (gfc_sym_mangled_identifier,\n+\tgfc_sym_mangled_function_id, gfc_finish_var_decl, gfc_get_symbol_decl,\n+\tgfc_get_symbol_decl): Likewise.\n+\t* trans-io.c (gfc_new_nml_name_expr): Add 'const' qualifier to\n+\targument.  Copy string instead of pointing to it.\n+\n 2005-02-23  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* intrinsic.h, st.c: Update copyright."}, {"sha": "7a971f20038d1f3aff7551e7fd6838d6fd536f31", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9444bd5ee3a3fa264e5f8541cb6b01507c813fa/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9444bd5ee3a3fa264e5f8541cb6b01507c813fa/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=e9444bd5ee3a3fa264e5f8541cb6b01507c813fa", "patch": "@@ -1214,7 +1214,7 @@ gfc_check_minloc_maxloc (gfc_actual_arglist * ap)\n   m = ap->next->next->expr;\n \n   if (m == NULL && d != NULL && d->ts.type == BT_LOGICAL\n-      && ap->next->name[0] == '\\0')\n+      && ap->next->name == NULL)\n     {\n       m = d;\n       d = NULL;\n@@ -1259,7 +1259,7 @@ check_reduction (gfc_actual_arglist * ap)\n   m = ap->next->next->expr;\n \n   if (m == NULL && d != NULL && d->ts.type == BT_LOGICAL\n-      && ap->next->name[0] == '\\0')\n+      && ap->next->name == NULL)\n     {\n       m = d;\n       d = NULL;"}, {"sha": "f8df9dabb124d9d50bfdf8df4e74eac6377421ea", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9444bd5ee3a3fa264e5f8541cb6b01507c813fa/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9444bd5ee3a3fa264e5f8541cb6b01507c813fa/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=e9444bd5ee3a3fa264e5f8541cb6b01507c813fa", "patch": "@@ -106,7 +106,7 @@ gfc_show_actual_arglist (gfc_actual_arglist * a)\n   for (; a; a = a->next)\n     {\n       gfc_status_char ('(');\n-      if (a->name[0] != '\\0')\n+      if (a->name != NULL)\n \tgfc_status (\"%s = \", a->name);\n       if (a->expr != NULL)\n \tgfc_show_expr (a->expr);"}, {"sha": "adbccc11486aa1b5dc86bed35032f867e1e7f985", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9444bd5ee3a3fa264e5f8541cb6b01507c813fa/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9444bd5ee3a3fa264e5f8541cb6b01507c813fa/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=e9444bd5ee3a3fa264e5f8541cb6b01507c813fa", "patch": "@@ -540,7 +540,7 @@ gfc_array_spec;\n /* Components of derived types.  */\n typedef struct gfc_component\n {\n-  char name[GFC_MAX_SYMBOL_LEN + 1];\n+  const char *name;\n   gfc_typespec ts;\n \n   int pointer, dimension;\n@@ -571,7 +571,7 @@ gfc_formal_arglist;\n /* The gfc_actual_arglist structure is for actual arguments.  */\n typedef struct gfc_actual_arglist\n {\n-  char name[GFC_MAX_SYMBOL_LEN + 1];\n+  const char *name;\n   /* Alternate return label when the expr member is null.  */\n   struct gfc_st_label *label;\n \n@@ -636,7 +636,7 @@ gfc_interface;\n /* User operator nodes.  These are like stripped down symbols.  */\n typedef struct\n {\n-  char name[GFC_MAX_SYMBOL_LEN + 1];\n+  const char *name;\n \n   gfc_interface *operator;\n   struct gfc_namespace *ns;\n@@ -652,8 +652,8 @@ gfc_user_op;\n \n typedef struct gfc_symbol\n {\n-  char name[GFC_MAX_SYMBOL_LEN + 1];\t/* Primary name, before renaming */\n-  char module[GFC_MAX_SYMBOL_LEN + 1];\t/* Module this symbol came from */\n+  const char *name;\t/* Primary name, before renaming */\n+  const char *module;\t/* Module this symbol came from */\n   locus declared_at;\n \n   gfc_typespec ts;\n@@ -744,7 +744,7 @@ gfc_entry_list;\n typedef struct gfc_symtree\n {\n   BBT_HEADER (gfc_symtree);\n-  char name[GFC_MAX_SYMBOL_LEN + 1];\n+  const char *name;\n   int ambiguous;\n   union\n   {\n@@ -1003,7 +1003,7 @@ gfc_resolve_f;\n \n typedef struct gfc_intrinsic_sym\n {\n-  char name[GFC_MAX_SYMBOL_LEN + 1], lib_name[GFC_MAX_SYMBOL_LEN + 1];\n+  const char *name, *lib_name;\n   gfc_intrinsic_arg *formal;\n   gfc_typespec ts;\n   int elemental, pure, generic, specific, actual_ok, standard;\n@@ -1654,8 +1654,8 @@ void gfc_save_all (gfc_namespace *);\n \n void gfc_symbol_state (void);\n \n-gfc_gsymbol *gfc_get_gsymbol (char *);\n-gfc_gsymbol *gfc_find_gsymbol (gfc_gsymbol *, char *);\n+gfc_gsymbol *gfc_get_gsymbol (const char *);\n+gfc_gsymbol *gfc_find_gsymbol (gfc_gsymbol *, const char *);\n \n /* intrinsic.c */\n extern int gfc_init_expr;\n@@ -1664,7 +1664,7 @@ extern int gfc_init_expr;\n    by placing it into a special module that is otherwise impossible to\n    read or write.  */\n \n-#define gfc_intrinsic_symbol(SYM) strcpy (SYM->module, \"(intrinsic)\")\n+#define gfc_intrinsic_symbol(SYM) SYM->module = gfc_get_string (\"(intrinsic)\")\n \n void gfc_intrinsic_init_1 (void);\n void gfc_intrinsic_done_1 (void);"}, {"sha": "ecbf9a27aacbc003275b717339234bd2010e6212", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9444bd5ee3a3fa264e5f8541cb6b01507c813fa/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9444bd5ee3a3fa264e5f8541cb6b01507c813fa/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=e9444bd5ee3a3fa264e5f8541cb6b01507c813fa", "patch": "@@ -340,8 +340,9 @@ gfc_compare_types (gfc_typespec * ts1, gfc_typespec * ts2)\n      true names and module names are the same and the module name is\n      nonnull, then they are equal.  */\n   if (strcmp (ts1->derived->name, ts2->derived->name) == 0\n-      && ts1->derived->module[0] != '\\0'\n-      && strcmp (ts1->derived->module, ts2->derived->module) == 0)\n+      && ((ts1->derived->module == NULL && ts2->derived->module == NULL)\n+\t  || (ts1->derived != NULL && ts2->derived != NULL\n+\t      && strcmp (ts1->derived->module, ts2->derived->module) == 0)))\n     return 1;\n \n   /* Compare type via the rules of the standard.  Both types must have\n@@ -1165,7 +1166,7 @@ compare_actual_formal (gfc_actual_arglist ** ap,\n \n   for (a = actual; a; a = a->next, f = f->next)\n     {\n-      if (a->name[0] != '\\0')\n+      if (a->name != NULL)\n \t{\n \t  i = 0;\n \t  for (f = formal; f; f = f->next, i++)"}, {"sha": "ebf5cb2edda2220289379e874821d97c12370b3b", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9444bd5ee3a3fa264e5f8541cb6b01507c813fa/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9444bd5ee3a3fa264e5f8541cb6b01507c813fa/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=e9444bd5ee3a3fa264e5f8541cb6b01507c813fa", "patch": "@@ -37,7 +37,8 @@ int gfc_init_expr = 0;\n /* Pointers to an intrinsic function and its argument names that are being\n    checked.  */\n \n-char *gfc_current_intrinsic, *gfc_current_intrinsic_arg[MAX_INTRINSIC_ARGS];\n+const char *gfc_current_intrinsic;\n+const char *gfc_current_intrinsic_arg[MAX_INTRINSIC_ARGS];\n locus *gfc_current_intrinsic_where;\n \n static gfc_intrinsic_sym *functions, *subroutines, *conversion, *next_sym;\n@@ -107,15 +108,15 @@ gfc_get_intrinsic_sub_symbol (const char * name)\n /* Return a pointer to the name of a conversion function given two\n    typespecs.  */\n \n-static char *\n+static const char *\n conv_name (gfc_typespec * from, gfc_typespec * to)\n {\n   static char name[30];\n \n   sprintf (name, \"__convert_%c%d_%c%d\", gfc_type_letter (from->type),\n \t   from->kind, gfc_type_letter (to->type), to->kind);\n \n-  return name;\n+  return gfc_get_string (name);\n }\n \n \n@@ -127,7 +128,7 @@ static gfc_intrinsic_sym *\n find_conv (gfc_typespec * from, gfc_typespec * to)\n {\n   gfc_intrinsic_sym *sym;\n-  char *target;\n+  const char *target;\n   int i;\n \n   target = conv_name (from, to);\n@@ -213,7 +214,7 @@ add_sym (const char *name, int elemental, int actual_ok ATTRIBUTE_UNUSED,\n \t bt type, int kind, int standard, gfc_check_f check,\n \t gfc_simplify_f simplify, gfc_resolve_f resolve, ...)\n {\n-\n+  char buf[GFC_MAX_SYMBOL_LEN + 11]; /* 10 for '_gfortran_', 1 for '\\0'  */\n   int optional, first_flag;\n   va_list argp;\n \n@@ -233,10 +234,11 @@ add_sym (const char *name, int elemental, int actual_ok ATTRIBUTE_UNUSED,\n       break;\n \n     case SZ_NOTHING:\n-      strcpy (next_sym->name, name);\n+      next_sym->name = gfc_get_string (name);\n \n-      strcpy (next_sym->lib_name, \"_gfortran_\");\n-      strcat (next_sym->lib_name, name);\n+      strcpy (buf, \"_gfortran_\");\n+      strcat (buf, name);\n+      next_sym->lib_name = gfc_get_string (buf);\n \n       next_sym->elemental = elemental;\n       next_sym->ts.type = type;\n@@ -785,11 +787,11 @@ make_generic (const char *name, gfc_generic_isym_id generic_id, int standard)\n   g->generic = 1;\n   g->specific = 1;\n   g->generic_id = generic_id;\n-  if ((g + 1)->name[0] != '\\0')\n+  if ((g + 1)->name != NULL)\n     g->specific_head = g + 1;\n   g++;\n \n-  while (g->name[0] != '\\0')\n+  while (g->name != NULL)\n     {\n       g->next = g + 1;\n       g->specific = 1;\n@@ -828,7 +830,7 @@ make_alias (const char *name, int standard)\n \n     case SZ_NOTHING:\n       next_sym[0] = next_sym[-1];\n-      strcpy (next_sym->name, name);\n+      next_sym->name = gfc_get_string (name);\n       next_sym++;\n       break;\n \n@@ -2152,8 +2154,8 @@ add_conv (bt from_type, int from_kind, bt to_type, int to_kind,\n \n   sym = conversion + nconv;\n \n-  strcpy (sym->name, conv_name (&from, &to));\n-  strcpy (sym->lib_name, sym->name);\n+  sym->name =  conv_name (&from, &to);\n+  sym->lib_name = sym->name;\n   sym->simplify.cc = simplify;\n   sym->elemental = 1;\n   sym->ts = to;\n@@ -2359,7 +2361,7 @@ sort_actual (const char *name, gfc_actual_arglist ** ap,\n       if (a == NULL)\n \tgoto optional;\n \n-      if (a->name[0] != '\\0')\n+      if (a->name != NULL)\n \tgoto keywords;\n \n       f->actual = a;"}, {"sha": "3f5fcba3736cda29ab85a7408c5b123831ba8bf6", "filename": "gcc/fortran/intrinsic.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9444bd5ee3a3fa264e5f8541cb6b01507c813fa/gcc%2Ffortran%2Fintrinsic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9444bd5ee3a3fa264e5f8541cb6b01507c813fa/gcc%2Ffortran%2Fintrinsic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.h?ref=e9444bd5ee3a3fa264e5f8541cb6b01507c813fa", "patch": "@@ -368,6 +368,6 @@ void gfc_resolve_unlink_sub (gfc_code *);\n \n #define MAX_INTRINSIC_ARGS 5\n \n-extern char *gfc_current_intrinsic,\n-  *gfc_current_intrinsic_arg[MAX_INTRINSIC_ARGS];\n+extern const char *gfc_current_intrinsic;\n+extern const char *gfc_current_intrinsic_arg[MAX_INTRINSIC_ARGS];\n extern locus *gfc_current_intrinsic_where;"}, {"sha": "5bba099eba107c5ae5bda409e944efb92bffeda3", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 50, "deletions": 23, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9444bd5ee3a3fa264e5f8541cb6b01507c813fa/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9444bd5ee3a3fa264e5f8541cb6b01507c813fa/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=e9444bd5ee3a3fa264e5f8541cb6b01507c813fa", "patch": "@@ -655,7 +655,8 @@ compare_true_names (void * _t1, void * _t2)\n   t1 = (true_name *) _t1;\n   t2 = (true_name *) _t2;\n \n-  c = strcmp (t1->sym->module, t2->sym->module);\n+  c = ((t1->sym->module > t2->sym->module)\n+       - (t1->sym->module < t2->sym->module));\n   if (c != 0)\n     return c;\n \n@@ -673,8 +674,8 @@ find_true_name (const char *name, const char *module)\n   gfc_symbol sym;\n   int c;\n \n-  strcpy (sym.name, name);\n-  strcpy (sym.module, module);\n+  sym.name = gfc_get_string (name);\n+  sym.module = gfc_get_string (module);\n   t.sym = &sym;\n \n   p = true_name_root;\n@@ -1341,8 +1342,33 @@ mio_allocated_string (const char *s)\n }\n \n \n-/* Read or write a string that is in static memory or inside of some\n-   already-allocated structure.  */\n+/* Read or write a string that is in static memory.  */\n+\n+static void\n+mio_pool_string (const char **stringp)\n+{\n+  /* TODO: one could write the string only once, and refer to it via a\n+     fixup pointer.  */\n+\n+  /* As a special case we have to deal with a NULL string.  This\n+     happens for the 'module' member of 'gfc_symbol's that are not in a\n+     module.  We read / write these as the empty string.  */\n+  if (iomode == IO_OUTPUT)\n+    {\n+      const char *p = *stringp == NULL ? \"\" : *stringp;\n+      write_atom (ATOM_STRING, p);\n+    }\n+  else\n+    {\n+      require_atom (ATOM_STRING);\n+      *stringp = atom_string[0] == '\\0' ? NULL : gfc_get_string (atom_string);\n+      gfc_free (atom_string);\n+    }\n+}\n+\n+\n+/* Read or write a string that is inside of some already-allocated\n+   structure.  */\n \n static void\n mio_internal_string (char *string)\n@@ -1802,7 +1828,7 @@ mio_component_ref (gfc_component ** cp, gfc_symbol * sym)\n     p->type = P_COMPONENT;\n \n   if (iomode == IO_OUTPUT)\n-    mio_internal_string ((*cp)->name);\n+    mio_pool_string (&(*cp)->name);\n   else\n     {\n       mio_internal_string (name);\n@@ -1851,7 +1877,7 @@ mio_component (gfc_component * c)\n   if (p->type == P_UNKNOWN)\n     p->type = P_COMPONENT;\n \n-  mio_internal_string (c->name);\n+  mio_pool_string (&c->name);\n   mio_typespec (&c->ts);\n   mio_array_spec (&c->as);\n \n@@ -1907,7 +1933,7 @@ mio_actual_arg (gfc_actual_arglist * a)\n {\n \n   mio_lparen ();\n-  mio_internal_string (a->name);\n+  mio_pool_string (&a->name);\n   mio_expr (&a->expr);\n   mio_rparen ();\n }\n@@ -2599,14 +2625,14 @@ mio_interface (gfc_interface ** ip)\n /* Save/restore a named operator interface.  */\n \n static void\n-mio_symbol_interface (char *name, char *module,\n+mio_symbol_interface (const char **name, const char **module,\n \t\t      gfc_interface ** ip)\n {\n \n   mio_lparen ();\n \n-  mio_internal_string (name);\n-  mio_internal_string (module);\n+  mio_pool_string (name);\n+  mio_pool_string (module);\n \n   mio_interface_rest (ip);\n }\n@@ -2884,7 +2910,7 @@ load_needed (pointer_info * p)\n \t}\n \n       sym = gfc_new_symbol (p->u.rsym.true_name, ns);\n-      strcpy (sym->module, p->u.rsym.module);\n+      sym->module = gfc_get_string (p->u.rsym.module);\n \n       associate_integer_pointer (p, sym);\n     }\n@@ -3037,7 +3063,7 @@ read_module (void)\n \t      sym = info->u.rsym.sym =\n \t\tgfc_new_symbol (info->u.rsym.true_name, gfc_current_ns);\n \n-\t      strcpy (sym->module, info->u.rsym.module);\n+\t      sym->module = gfc_get_string (info->u.rsym.module);\n \t    }\n \n \t  st->n.sym = sym;\n@@ -3170,7 +3196,7 @@ write_common (gfc_symtree *st)\n   write_common(st->right);\n \n   mio_lparen();\n-  mio_internal_string(st->name);\n+  mio_pool_string(&st->name);\n \n   p = st->n.common;\n   mio_symbol_ref(&p->head);\n@@ -3190,9 +3216,9 @@ write_symbol (int n, gfc_symbol * sym)\n     gfc_internal_error (\"write_symbol(): bad module symbol '%s'\", sym->name);\n \n   mio_integer (&n);\n-  mio_internal_string (sym->name);\n+  mio_pool_string (&sym->name);\n \n-  mio_internal_string (sym->module);\n+  mio_pool_string (&sym->module);\n   mio_pointer_ref (&sym->ns);\n \n   mio_symbol (sym);\n@@ -3217,8 +3243,8 @@ write_symbol0 (gfc_symtree * st)\n   write_symbol0 (st->right);\n \n   sym = st->n.sym;\n-  if (sym->module[0] == '\\0')\n-    strcpy (sym->module, module_name);\n+  if (sym->module == NULL)\n+    sym->module = gfc_get_string (module_name);\n \n   if (sym->attr.flavor == FL_PROCEDURE && sym->attr.generic\n       && !sym->attr.subroutine && !sym->attr.function)\n@@ -3265,8 +3291,8 @@ write_symbol1 (pointer_info * p)\n \n   /* FIXME: This shouldn't be necessary, but it works around\n      deficiencies in the module loader or/and symbol handling.  */\n-  if (p->u.wsym.sym->module[0] == '\\0' && p->u.wsym.sym->attr.dummy)\n-    strcpy (p->u.wsym.sym->module, module_name);\n+  if (p->u.wsym.sym->module == NULL && p->u.wsym.sym->attr.dummy)\n+    p->u.wsym.sym->module = gfc_get_string (module_name);\n \n   p->u.wsym.state = WRITTEN;\n   write_symbol (p->integer, p->u.wsym.sym);\n@@ -3281,12 +3307,13 @@ static void\n write_operator (gfc_user_op * uop)\n {\n   static char nullstring[] = \"\";\n+  const char *p = nullstring;\n \n   if (uop->operator == NULL\n       || !gfc_check_access (uop->access, uop->ns->default_access))\n     return;\n \n-  mio_symbol_interface (uop->name, nullstring, &uop->operator);\n+  mio_symbol_interface (&uop->name, &p, &uop->operator);\n }\n \n \n@@ -3300,7 +3327,7 @@ write_generic (gfc_symbol * sym)\n       || !gfc_check_access (sym->attr.access, sym->ns->default_access))\n     return;\n \n-  mio_symbol_interface (sym->name, sym->module, &sym->generic);\n+  mio_symbol_interface (&sym->name, &sym->module, &sym->generic);\n }\n \n \n@@ -3323,7 +3350,7 @@ write_symtree (gfc_symtree * st)\n   if (p == NULL)\n     gfc_internal_error (\"write_symtree(): Symbol not written\");\n \n-  mio_internal_string (st->name);\n+  mio_pool_string (&st->name);\n   mio_integer (&st->ambiguous);\n   mio_integer (&p->integer);\n }"}, {"sha": "f3c51ab46759021499962f1773385661b9904e09", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9444bd5ee3a3fa264e5f8541cb6b01507c813fa/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9444bd5ee3a3fa264e5f8541cb6b01507c813fa/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=e9444bd5ee3a3fa264e5f8541cb6b01507c813fa", "patch": "@@ -1273,7 +1273,7 @@ match_keyword_arg (gfc_actual_arglist * actual, gfc_actual_arglist * base)\n   if (name[0] != '\\0')\n     {\n       for (a = base; a; a = a->next)\n-\tif (strcmp (a->name, name) == 0)\n+\tif (a->name != NULL && strcmp (a->name, name) == 0)\n \t  {\n \t    gfc_error\n \t      (\"Keyword '%s' at %C has already appeared in the current \"\n@@ -1282,7 +1282,7 @@ match_keyword_arg (gfc_actual_arglist * actual, gfc_actual_arglist * base)\n \t  }\n     }\n \n-  strcpy (actual->name, name);\n+  actual->name = gfc_get_string (name);\n   return MATCH_YES;\n \n cleanup:"}, {"sha": "0b5e8e727a44d5c713c8385df7df4e443a142e19", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9444bd5ee3a3fa264e5f8541cb6b01507c813fa/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9444bd5ee3a3fa264e5f8541cb6b01507c813fa/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=e9444bd5ee3a3fa264e5f8541cb6b01507c813fa", "patch": "@@ -1157,7 +1157,7 @@ gfc_add_component (gfc_symbol * sym, const char *name, gfc_component ** componen\n   else\n     tail->next = p;\n \n-  strcpy (p->name, name);\n+  p->name = gfc_get_string (name);\n   p->loc = gfc_current_locus;\n \n   *component = p;\n@@ -1613,7 +1613,7 @@ gfc_new_symtree (gfc_symtree ** root, const char *name)\n   gfc_symtree *st;\n \n   st = gfc_getmem (sizeof (gfc_symtree));\n-  strcpy (st->name, name);\n+  st->name = gfc_get_string (name);\n \n   gfc_insert_bbt (root, st, compare_symtree);\n   return st;\n@@ -1629,7 +1629,7 @@ delete_symtree (gfc_symtree ** root, const char *name)\n \n   st0 = gfc_find_symtree (*root, name);\n \n-  strcpy (st.name, name);\n+  st.name = gfc_get_string (name);\n   gfc_delete_bbt (root, &st, compare_symtree);\n \n   gfc_free (st0);\n@@ -1674,7 +1674,7 @@ gfc_get_uop (const char *name)\n   st = gfc_new_symtree (&gfc_current_ns->uop_root, name);\n \n   uop = st->n.uop = gfc_getmem (sizeof (gfc_user_op));\n-  strcpy (uop->name, name);\n+  uop->name = gfc_get_string (name);\n   uop->access = ACCESS_UNKNOWN;\n   uop->ns = gfc_current_ns;\n \n@@ -1743,7 +1743,7 @@ gfc_new_symbol (const char *name, gfc_namespace * ns)\n   if (strlen (name) > GFC_MAX_SYMBOL_LEN)\n     gfc_internal_error (\"new_symbol(): Symbol name too long\");\n \n-  strcpy (p->name, name);\n+  p->name = gfc_get_string (name);\n   return p;\n }\n \n@@ -1754,7 +1754,7 @@ static void\n ambiguous_symbol (const char *name, gfc_symtree * st)\n {\n \n-  if (st->n.sym->module[0])\n+  if (st->n.sym->module)\n     gfc_error (\"Name '%s' at %C is an ambiguous reference to '%s' \"\n \t       \"from module '%s'\", name, st->n.sym->name, st->n.sym->module);\n   else\n@@ -2362,7 +2362,7 @@ gfc_symbol_state(void) {\n /* Search a tree for the global symbol.  */\n \n gfc_gsymbol *\n-gfc_find_gsymbol (gfc_gsymbol *symbol, char *name)\n+gfc_find_gsymbol (gfc_gsymbol *symbol, const char *name)\n {\n   gfc_gsymbol *s;\n \n@@ -2399,7 +2399,7 @@ gsym_compare (void * _s1, void * _s2)\n /* Get a global symbol, creating it if it doesn't exist.  */\n \n gfc_gsymbol *\n-gfc_get_gsymbol (char *name)\n+gfc_get_gsymbol (const char *name)\n {\n   gfc_gsymbol *s;\n "}, {"sha": "2ed83e6508958eecd765f0af8ed426b527bc0e5a", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9444bd5ee3a3fa264e5f8541cb6b01507c813fa/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9444bd5ee3a3fa264e5f8541cb6b01507c813fa/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=e9444bd5ee3a3fa264e5f8541cb6b01507c813fa", "patch": "@@ -3071,7 +3071,7 @@ gfc_trans_auto_array_allocation (tree decl, gfc_symbol * sym, tree fnbody)\n \n   gcc_assert (!sym->attr.use_assoc);\n   gcc_assert (!TREE_STATIC (decl));\n-  gcc_assert (!sym->module[0]);\n+  gcc_assert (!sym->module);\n \n   if (sym->ts.type == BT_CHARACTER\n       && !INTEGER_CST_P (sym->ts.cl->backend_decl))"}, {"sha": "b81b9862207b82acb2e8bd7d2e8677c4a92a9800", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9444bd5ee3a3fa264e5f8541cb6b01507c813fa/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9444bd5ee3a3fa264e5f8541cb6b01507c813fa/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=e9444bd5ee3a3fa264e5f8541cb6b01507c813fa", "patch": "@@ -272,7 +272,7 @@ gfc_sym_mangled_identifier (gfc_symbol * sym)\n {\n   char name[GFC_MAX_MANGLED_SYMBOL_LEN + 1];\n \n-  if (sym->module[0] == 0)\n+  if (sym->module == NULL)\n     return gfc_sym_identifier (sym);\n   else\n     {\n@@ -290,8 +290,8 @@ gfc_sym_mangled_function_id (gfc_symbol * sym)\n   int has_underscore;\n   char name[GFC_MAX_MANGLED_SYMBOL_LEN + 1];\n \n-  if (sym->module[0] == 0 || sym->attr.proc == PROC_EXTERNAL\n-      || (sym->module[0] != 0 && sym->attr.if_source == IFSRC_IFBODY))\n+  if (sym->module == NULL || sym->attr.proc == PROC_EXTERNAL\n+      || (sym->module != NULL && sym->attr.if_source == IFSRC_IFBODY))\n     {\n       if (strcmp (sym->name, \"MAIN__\") == 0\n \t  || sym->attr.proc == PROC_INTRINSIC)\n@@ -404,7 +404,7 @@ gfc_finish_var_decl (tree decl, gfc_symbol * sym)\n       DECL_EXTERNAL (decl) = 1;\n       TREE_PUBLIC (decl) = 1;\n     }\n-  else if (sym->module[0] && !sym->attr.result && !sym->attr.dummy)\n+  else if (sym->module && !sym->attr.result && !sym->attr.dummy)\n     {\n       /* TODO: Don't set sym->module for result or dummy variables.  */\n       gcc_assert (current_function_decl == NULL_TREE);\n@@ -766,7 +766,7 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n   /* Symbols from modules should have their assembler names mangled.\n      This is done here rather than in gfc_finish_var_decl because it\n      is different for string length variables.  */\n-  if (sym->module[0])\n+  if (sym->module)\n     SET_DECL_ASSEMBLER_NAME (decl, gfc_sym_mangled_identifier (sym));\n \n   if (sym->attr.dimension)\n@@ -808,7 +808,7 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n \t{\n \t  char name[GFC_MAX_MANGLED_SYMBOL_LEN + 2];\n \n-\t  if (sym->module[0])\n+\t  if (sym->module)\n \t    {\n \t      /* Also prefix the mangled name for symbols from modules.  */\n \t      strcpy (&name[1], sym->name);"}, {"sha": "26f05f1e9fb792c492bf49629c8d572857193f81", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9444bd5ee3a3fa264e5f8541cb6b01507c813fa/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9444bd5ee3a3fa264e5f8541cb6b01507c813fa/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=e9444bd5ee3a3fa264e5f8541cb6b01507c813fa", "patch": "@@ -816,7 +816,7 @@ gfc_trans_inquire (gfc_code * code)\n \n \n static gfc_expr *\n-gfc_new_nml_name_expr (char * name)\n+gfc_new_nml_name_expr (const char * name)\n {\n    gfc_expr * nml_name;\n    nml_name = gfc_get_expr();\n@@ -825,7 +825,8 @@ gfc_new_nml_name_expr (char * name)\n    nml_name->ts.kind = gfc_default_character_kind;\n    nml_name->ts.type = BT_CHARACTER;\n    nml_name->value.character.length = strlen(name);\n-   nml_name->value.character.string = name;\n+   nml_name->value.character.string = gfc_getmem (strlen (name) + 1);\n+   strcpy (nml_name->value.character.string, name);\n \n    return nml_name;\n }"}]}