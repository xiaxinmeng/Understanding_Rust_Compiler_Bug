{"sha": "42c1e008b0153a83329fb63497f936cbb95c68e1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDJjMWUwMDhiMDE1M2E4MzMyOWZiNjM0OTdmOTM2Y2JiOTVjNjhlMQ==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2014-04-26T21:52:26Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2014-04-26T21:52:26Z"}, "message": "re PR libfortran/52539 (I/O: Wrong result for UTF-8/UCS-4 list-directed and namelist read and nml write)\n\n2014-04-26  Jerry DeLisle  <jvdelisle@gcc.gnu>\n\n\tPR libfortran/52539\n\t* io/list_read.c: Add uchar typedef. (push_char4): New function\n\tto save kind=4 character. (next_char_utf8): New function to read\n\ta single UTF-8 encoded character value. (read_chracter): Update\n\tto use the new functions for reading UTF-8 strings.\n\t(list_formatted_read_scalar): Update to handle list directed\n\treads of UTF-8 strings. (nml_read_obj): Likewise update for\n\tUTF-8 strings in namelists.\n\t* io/write.c (nml_write_obj): Add kind=4 character support for\n\tnamelist writes.\n\nFrom-SVN: r209828", "tree": {"sha": "df39b5d5bebd6745e36ff64f6927e58baedf3fc5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/df39b5d5bebd6745e36ff64f6927e58baedf3fc5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/42c1e008b0153a83329fb63497f936cbb95c68e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42c1e008b0153a83329fb63497f936cbb95c68e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42c1e008b0153a83329fb63497f936cbb95c68e1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42c1e008b0153a83329fb63497f936cbb95c68e1/comments", "author": null, "committer": null, "parents": [{"sha": "167c3e96ae9215c9f644969fa3f575ce66437410", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/167c3e96ae9215c9f644969fa3f575ce66437410", "html_url": "https://github.com/Rust-GCC/gccrs/commit/167c3e96ae9215c9f644969fa3f575ce66437410"}], "stats": {"total": 276, "additions": 223, "deletions": 53}, "files": [{"sha": "dc37a861f024eaa8456af1290239717fa6e4d44c", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42c1e008b0153a83329fb63497f936cbb95c68e1/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42c1e008b0153a83329fb63497f936cbb95c68e1/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=42c1e008b0153a83329fb63497f936cbb95c68e1", "patch": "@@ -1,3 +1,16 @@\n+2014-04-26  Jerry DeLisle  <jvdelisle@gcc.gnu>\n+\n+\tPR libfortran/52539\n+\t* io/list_read.c: Add uchar typedef. (push_char4): New function\n+\tto save kind=4 character. (next_char_utf8): New function to read\n+\ta single UTF-8 encoded character value. (read_chracter): Update\n+\tto use the new functions for reading UTF-8 strings.\n+\t(list_formatted_read_scalar): Update to handle list directed\n+\treads of UTF-8 strings. (nml_read_obj): Likewise update for\n+\tUTF-8 strings in namelists.\n+\t* io/write.c (nml_write_obj): Add kind=4 character support for\n+\tnamelist writes.\n+\n 2014-04-24  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* configure.ac: Quote usage of ac_cv_func_clock_gettime in if test."}, {"sha": "b052c06b557730bf0a83935173713f6be42df59f", "filename": "libgfortran/io/list_read.c", "status": "modified", "additions": 206, "deletions": 52, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42c1e008b0153a83329fb63497f936cbb95c68e1/libgfortran%2Fio%2Flist_read.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42c1e008b0153a83329fb63497f936cbb95c68e1/libgfortran%2Fio%2Flist_read.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Flist_read.c?ref=42c1e008b0153a83329fb63497f936cbb95c68e1", "patch": "@@ -32,6 +32,8 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include <stdlib.h>\n #include <ctype.h>\n \n+typedef unsigned char uchar;\n+\n \n /* List directed input.  Several parsing subroutines are practically\n    reimplemented from formatted input, the reason being that there are\n@@ -97,6 +99,37 @@ push_char (st_parameter_dt *dtp, char c)\n   dtp->u.p.saved_string[dtp->u.p.saved_used++] = c;\n }\n \n+/* Save a KIND=4 character to a string buffer, enlarging the buffer\n+   as necessary.  */\n+\n+static void\n+push_char4 (st_parameter_dt *dtp, gfc_char4_t c)\n+{\n+  gfc_char4_t *new, *p = (gfc_char4_t *) dtp->u.p.saved_string;\n+\n+  if (p == NULL)\n+    {\n+      dtp->u.p.saved_string = xcalloc (SCRATCH_SIZE, sizeof (gfc_char4_t));\n+      dtp->u.p.saved_length = SCRATCH_SIZE;\n+      dtp->u.p.saved_used = 0;\n+      p = (gfc_char4_t *) dtp->u.p.saved_string;\n+    }\n+\n+  if (dtp->u.p.saved_used >= dtp->u.p.saved_length)\n+    {\n+      dtp->u.p.saved_length = 2 * dtp->u.p.saved_length;\n+      new = realloc (p, dtp->u.p.saved_length);\n+      if (new == NULL)\n+\tgenerate_error (&dtp->common, LIBERROR_OS, NULL);\n+      p = new;\n+      \n+      memset (new + dtp->u.p.saved_used, 0, \n+\t      dtp->u.p.saved_length - dtp->u.p.saved_used);\n+    }\n+\n+  p[dtp->u.p.saved_used++] = c;\n+}\n+\n \n /* Free the input buffer if necessary.  */\n \n@@ -247,6 +280,57 @@ next_char (st_parameter_dt *dtp)\n }\n \n \n+static gfc_char4_t\n+next_char_utf8 (st_parameter_dt *dtp) \n+{\n+  static const uchar masks[6] = { 0x7F, 0x1F, 0x0F, 0x07, 0x02, 0x01 };\n+  static const uchar patns[6] = { 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };\n+  int i, nb;\n+  gfc_char4_t c;\n+\n+  c = next_char (dtp);\n+  if (c < 0x80)\n+    return c;\n+\n+  /* The number of leading 1-bits in the first byte indicates how many\n+     bytes follow.  */\n+  for (nb = 2; nb < 7; nb++)\n+    if ((c & ~masks[nb-1]) == patns[nb-1])\n+      goto found;\n+  goto invalid;\n+\t\n+ found:\n+  c = (c & masks[nb-1]);\n+\n+  /* Decode the bytes read.  */\n+  for (i = 1; i < nb; i++)\n+    {\n+      gfc_char4_t n = next_char (dtp);\n+\n+      if ((n & 0xC0) != 0x80)\n+\tgoto invalid;\n+\n+      c = ((c << 6) + (n & 0x3F));\n+    }\n+\n+  /* Make sure the shortest possible encoding was used.  */\n+  if (c <=      0x7F && nb > 1) goto invalid;\n+  if (c <=     0x7FF && nb > 2) goto invalid;\n+  if (c <=    0xFFFF && nb > 3) goto invalid;\n+  if (c <=  0x1FFFFF && nb > 4) goto invalid;\n+  if (c <= 0x3FFFFFF && nb > 5) goto invalid;\n+\n+  /* Make sure the character is valid.  */\n+  if (c > 0x7FFFFFFF || (c >= 0xD800 && c <= 0xDFFF))\n+    goto invalid;\n+\n+  return c;\n+      \n+ invalid:\n+  generate_error (&dtp->common, LIBERROR_READ_VALUE, \"Invalid UTF-8 encoding\");\n+  return (gfc_char4_t) '?';\n+}\n+\n /* Push a character back onto the input.  */\n \n static void\n@@ -1087,50 +1171,97 @@ read_character (st_parameter_dt *dtp, int length __attribute__ ((unused)))\n     }\n \n  get_string:\n-  for (;;)\n-    {\n-      if ((c = next_char (dtp)) == EOF)\n-\tgoto done_eof;\n-      switch (c)\n-\t{\n-\tcase '\"':\n-\tcase '\\'':\n-\t  if (c != quote)\n-\t    {\n-\t      push_char (dtp, c);\n-\t      break;\n-\t    }\n-\n-\t  /* See if we have a doubled quote character or the end of\n-\t     the string.  */\n-\n-\t  if ((c = next_char (dtp)) == EOF)\n-\t    goto done_eof;\n-\t  if (c == quote)\n-\t    {\n-\t      push_char (dtp, quote);\n-\t      break;\n-\t    }\n-\n-\t  unget_char (dtp, c);\n-\t  goto done;\n-\n-\tCASE_SEPARATORS:\n-\t  if (quote == ' ')\n-\t    {\n-\t      unget_char (dtp, c);\n-\t      goto done;\n-\t    }\n \n-\t  if (c != '\\n' && c != '\\r')\n+  if (dtp->u.p.current_unit->flags.encoding == ENCODING_UTF8)\n+    for (;;)\n+      {\n+\tif ((c = next_char_utf8 (dtp)) == EOF)\n+\t  goto done_eof;\n+\tswitch (c)\n+\t  {\n+\t  case '\"':\n+\t  case '\\'':\n+\t    if (c != quote)\n+\t      {\n+\t\tpush_char4 (dtp, c);\n+\t\tbreak;\n+\t      }\n+  \n+\t    /* See if we have a doubled quote character or the end of\n+\t       the string.  */\n+  \n+\t    if ((c = next_char_utf8 (dtp)) == EOF)\n+\t      goto done_eof;\n+\t    if (c == quote)\n+\t      {\n+\t\tpush_char4 (dtp, quote);\n+\t\tbreak;\n+\t      }\n+  \n+\t    unget_char (dtp, c);\n+\t    goto done;\n+  \n+\t  CASE_SEPARATORS:\n+\t    if (quote == ' ')\n+\t      {\n+\t\tunget_char (dtp, c);\n+\t\tgoto done;\n+\t      }\n+  \n+\t    if (c != '\\n' && c != '\\r')\n+\t      push_char4 (dtp, c);\n+\t    break;\n+  \n+\t  default:\n+\t    push_char4 (dtp, c);\n+\t    break;\n+\t  }\n+      }\n+  else\n+    for (;;)\n+      {\n+\tif ((c = next_char (dtp)) == EOF)\n+\t  goto done_eof;\n+\tswitch (c)\n+\t  {\n+\t  case '\"':\n+\t  case '\\'':\n+\t    if (c != quote)\n+\t      {\n+\t\tpush_char (dtp, c);\n+\t\tbreak;\n+\t      }\n+  \n+\t    /* See if we have a doubled quote character or the end of\n+\t       the string.  */\n+  \n+\t    if ((c = next_char (dtp)) == EOF)\n+\t      goto done_eof;\n+\t    if (c == quote)\n+\t      {\n+\t\tpush_char (dtp, quote);\n+\t\tbreak;\n+\t      }\n+  \n+\t    unget_char (dtp, c);\n+\t    goto done;\n+  \n+\t  CASE_SEPARATORS:\n+\t    if (quote == ' ')\n+\t      {\n+\t\tunget_char (dtp, c);\n+\t\tgoto done;\n+\t      }\n+  \n+\t    if (c != '\\n' && c != '\\r')\n+\t      push_char (dtp, c);\n+\t    break;\n+  \n+\t  default:\n \t    push_char (dtp, c);\n-\t  break;\n-\n-\tdefault:\n-\t  push_char (dtp, c);\n-\t  break;\n-\t}\n-    }\n+\t    break;\n+\t  }\n+      }\n \n   /* At this point, we have to have a separator, or else the string is\n      invalid.  */\n@@ -1903,7 +2034,7 @@ static int\n list_formatted_read_scalar (st_parameter_dt *dtp, bt type, void *p,\n \t\t\t    int kind, size_t size)\n {\n-  gfc_char4_t *q;\n+  gfc_char4_t *q, *r;\n   int c, i, m;\n   int err = 0;\n \n@@ -2031,13 +2162,19 @@ list_formatted_read_scalar (st_parameter_dt *dtp, bt type, void *p,\n \t{\n \t  m = ((int) size < dtp->u.p.saved_used)\n \t      ? (int) size : dtp->u.p.saved_used;\n-\t  if (kind == 1)\n-\t    memcpy (p, dtp->u.p.saved_string, m);\n+\n+\t  q = (gfc_char4_t *) p;\n+\t  r = (gfc_char4_t *) dtp->u.p.saved_string;\n+\t  if (dtp->u.p.current_unit->flags.encoding == ENCODING_UTF8)\n+\t    for (i = 0; i < m; i++)\n+\t      *q++ = *r++;\n \t  else\n \t    {\n-\t      q = (gfc_char4_t *) p;\n-\t      for (i = 0; i < m; i++)\n-\t\tq[i] = (unsigned char) dtp->u.p.saved_string[i];\n+\t      if (kind == 1)\n+\t\tmemcpy (p, dtp->u.p.saved_string, m);\n+\t      else\n+\t\tfor (i = 0; i < m; i++)\n+\t\t  *q++ = (unsigned char) dtp->u.p.saved_string[i];\n \t    }\n \t}\n       else\n@@ -2771,10 +2908,27 @@ nml_read_obj (st_parameter_dt *dtp, namelist_info * nl, index_type offset,\n \t    }\n \t  else\n \t    m = dtp->u.p.saved_used;\n-\t  pdata = (void*)( pdata + clow - 1 );\n-\t  memcpy (pdata, dtp->u.p.saved_string, m);\n-\t  if (m < dlen)\n-\t    memset ((void*)( pdata + m ), ' ', dlen - m);\n+\n+\t  if (dtp->u.p.current_unit->flags.encoding == ENCODING_UTF8)\n+\t    {\n+\t      gfc_char4_t *q4, *p4 = pdata;\n+\t      int i;\n+\n+\t      q4 = (gfc_char4_t *) dtp->u.p.saved_string;\n+\t      p4 += clow -1;\n+\t      for (i = 0; i < m; i++)\n+\t\t*p4++ = *q4++;\n+\t      if (m < dlen)\n+\t\tfor (i = 0; i < dlen - m; i++)\n+\t\t  *p4++ = (gfc_char4_t) ' ';\n+\t    }\n+\t  else\n+\t    {\n+\t      pdata = (void*)( pdata + clow - 1 );\n+\t      memcpy (pdata, dtp->u.p.saved_string, m);\n+\t      if (m < dlen)\n+\t\tmemset ((void*)( pdata + m ), ' ', dlen - m);\n+\t    }\n \t  break;\n \n \tdefault:"}, {"sha": "e17a3d86203cd914c5b5b07c163e537650b5ff55", "filename": "libgfortran/io/write.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42c1e008b0153a83329fb63497f936cbb95c68e1/libgfortran%2Fio%2Fwrite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42c1e008b0153a83329fb63497f936cbb95c68e1/libgfortran%2Fio%2Fwrite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fwrite.c?ref=42c1e008b0153a83329fb63497f936cbb95c68e1", "patch": "@@ -1835,7 +1835,10 @@ nml_write_obj (st_parameter_dt *dtp, namelist_info * obj, index_type offset,\n               break;\n \n \t    case BT_CHARACTER:\n-\t      write_character (dtp, p, 1, obj->string_length, DELIM);\n+\t      if (dtp->u.p.current_unit->flags.encoding == ENCODING_UTF8)\n+\t\twrite_character (dtp, p, 4, obj->string_length, DELIM);\n+\t      else\n+\t\twrite_character (dtp, p, 1, obj->string_length, DELIM);\n               break;\n \n \t    case BT_REAL:"}]}