{"sha": "62cb090122381c4e7a3058c88a5a5ef192c08e7c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjJjYjA5MDEyMjM4MWM0ZTdhMzA1OGM4OGE1YTVlZjE5MmMwOGU3Yw==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1996-05-15T18:00:36Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1996-05-15T18:00:36Z"}, "message": "Use pic_offset_table_rtx instead of rs6000_pic_register; Rewrite int/float conversions so reload allocates the temp\n\nFrom-SVN: r11973", "tree": {"sha": "52ed4de376c0e2c206979b7fad79af247531f78d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/52ed4de376c0e2c206979b7fad79af247531f78d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/62cb090122381c4e7a3058c88a5a5ef192c08e7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62cb090122381c4e7a3058c88a5a5ef192c08e7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62cb090122381c4e7a3058c88a5a5ef192c08e7c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62cb090122381c4e7a3058c88a5a5ef192c08e7c/comments", "author": null, "committer": null, "parents": [{"sha": "3c75f3970ceedec4f8bc2553ae049ee6c505ec2a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c75f3970ceedec4f8bc2553ae049ee6c505ec2a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c75f3970ceedec4f8bc2553ae049ee6c505ec2a"}], "stats": {"total": 111, "additions": 21, "deletions": 90}, "files": [{"sha": "4298987967a8e275f3db0ae88486aba1a447eeaf", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 1, "deletions": 40, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62cb090122381c4e7a3058c88a5a5ef192c08e7c/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62cb090122381c4e7a3058c88a5a5ef192c08e7c/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=62cb090122381c4e7a3058c88a5a5ef192c08e7c", "patch": "@@ -99,12 +99,6 @@ int rs6000_save_toc_p;\n /* ABI enumeration available for subtarget to use.  */\n enum rs6000_abi rs6000_current_abi;\n \n-/* Temporary memory used to convert integer -> float */\n-static rtx stack_temps[NUM_MACHINE_MODES];\n-\n-/* Current PIC register used by the V4 code */\n-struct rtx_def *rs6000_pic_register = (struct rtx_def *)0;\n-\n \f\n /* Default register names.  */\n char rs6000_reg_names[][8] =\n@@ -1487,35 +1481,6 @@ expand_builtin_saveregs (args)\n   return virtual_incoming_args_rtx;\n }\n \n-\f\n-/* Allocate a stack temp.  Only allocate one stack temp per type for a\n-   function.  */\n-\n-struct rtx_def *\n-rs6000_stack_temp (mode, size)\n-     enum machine_mode mode;\n-     int size;\n-{\n-  rtx temp = stack_temps[ (int)mode ];\n-  rtx addr;\n-\n-  if (temp == NULL_RTX)\n-    {\n-      temp = assign_stack_local (mode, size, 0);\n-      addr = XEXP (temp, 0);\n-\n-      if ((size > 4 && !offsettable_address_p (0, mode, addr))\n-\t  || (size <= 4 && !memory_address_p (mode, addr)))\n-\t{\n-\t  XEXP (temp, 0) = copy_addr_to_reg (addr);\n-\t}\n-\n-      stack_temps[ (int)mode ] = temp;\n-    }\n-\n-  return temp;\n-}\n-\n \f\n /* Generate a memory reference for expand_block_move, copying volatile,\n    and other bits from an original memory reference.  */\n@@ -3467,10 +3432,6 @@ output_epilog (file, size)\n   int sp_offset = 0;\n   int i;\n \n-  /* Forget about any temporaries created */\n-  for (i = 0; i < NUM_MACHINE_MODES; i++)\n-    stack_temps[i] = NULL_RTX;\n-\n   /* If the last insn was a BARRIER, we don't have to write anything except\n      the trace table.  */\n   if (GET_CODE (insn) == NOTE)\n@@ -3765,7 +3726,7 @@ output_epilog (file, size)\n   /* Reset varargs and save TOC indicator */\n   rs6000_sysv_varargs_p = 0;\n   rs6000_save_toc_p = 0;\n-  rs6000_pic_register = (rtx)0;\n+  pic_offset_table_rtx = (rtx)0;\n \n   if (DEFAULT_ABI == ABI_NT)\n     {"}, {"sha": "eccfe3155b54dd38b1f39aa71cf9a526bd779e26", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62cb090122381c4e7a3058c88a5a5ef192c08e7c/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62cb090122381c4e7a3058c88a5a5ef192c08e7c/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=62cb090122381c4e7a3058c88a5a5ef192c08e7c", "patch": "@@ -1884,10 +1884,6 @@ typedef struct rs6000_args\n \n /* #define FINALIZE_PIC */\n \n-/* Current PIC register used by the V4 code */\n-extern struct rtx_def *rs6000_pic_register;\n-\n-\n /* A C expression that is nonzero if X is a legitimate immediate\n    operand on the target machine when generating position independent\n    code.  You can assume that X satisfies `CONSTANT_P', so you need"}, {"sha": "1e35c93cc85f365853daa77a73723466b817328e", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 20, "deletions": 46, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62cb090122381c4e7a3058c88a5a5ef192c08e7c/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62cb090122381c4e7a3058c88a5a5ef192c08e7c/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=62cb090122381c4e7a3058c88a5a5ef192c08e7c", "patch": "@@ -3573,54 +3573,29 @@\n }\")\n \n (define_expand \"move_to_float\"\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n-\t(unspec [(match_operand:SI 1 \"gpc_reg_operand\" \"\")\n-\t\t (match_operand:SI 2 \"gpc_reg_operand\" \"\")\n-\t\t (match_dup 3)] 2))]\n+  [(set (match_dup 4)\t\t\t\t\t;; low word\n+\t(match_operand:SI 1 \"register_operand\" \"\"))\n+   (set (match_dup 5)\t\t\t\t\t;; high word\n+\t(match_operand:SI 2 \"register_operand\" \"\"))\n+   (set (match_operand:SI 0 \"register_operand\" \"\")\t;; float value\n+\t(match_dup 3))]\n   \"! TARGET_POWERPC64 && TARGET_HARD_FLOAT\"\n   \"\n {\n-  operands[3] = XEXP (rs6000_stack_temp (DFmode, 8, 1), 0);\n-}\")\n-\n-(define_split\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n-\t(unspec [(match_operand:SI 1 \"gpc_reg_operand\" \"\")\n-\t\t (match_operand:SI 2 \"gpc_reg_operand\" \"\")\n-\t\t (match_operand:SI 3 \"offsettable_addr_operand\" \"\")] 2))]\n-  \"reload_completed\"\n-  [(set (match_dup 4) (match_dup 1))\n-   (set (match_dup 5) (match_dup 2))\n-   (set (match_dup 0) (mem:DF (match_dup 3)))]\n-  \"\n-{\n-  rtx word1 = gen_rtx (MEM, SImode, operands[3]);\n-  rtx word2 = gen_rtx (MEM, SImode, plus_constant (operands[3], 4));\n-\n-  MEM_IN_STRUCT_P (word1) = 1;\n-  MEM_IN_STRUCT_P (word2) = 1;\n+  operands[3] = gen_reg_rtx (DFmode);\n \n   if (WORDS_BIG_ENDIAN)\n     {\n-      operands[4] = word2;\n-      operands[5] = word1;\n+      operands[4] = gen_rtx (SUBREG, SImode, operands[3], 1);\n+      operands[5] = gen_rtx (SUBREG, SImode, operands[3], 0);\n     }\n   else\n     {\n-      operands[4] = word1;\n-      operands[5] = word2;\n+      operands[4] = gen_rtx (SUBREG, SImode, operands[3], 0);\n+      operands[5] = gen_rtx (SUBREG, SImode, operands[3], 1);\n     }\n }\")\n \n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=f\")\n-\t(unspec [(match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n-\t\t (match_operand:SI 2 \"gpc_reg_operand\" \"r\")\n-\t\t (match_operand:SI 3 \"offsettable_addr_operand\" \"p\")] 2))]\n-  \"! TARGET_POWERPC64 && TARGET_HARD_FLOAT\"\n-  \"#\"\n-  [(set_attr \"length\" \"12\")])\n-\n (define_expand \"fix_truncdfsi2\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n \t(fix:SI (match_operand:DF 1 \"gpc_reg_operand\" \"\")))]\n@@ -3629,13 +3604,12 @@\n {\n   if (TARGET_POWER2 || TARGET_POWERPC)\n     {\n-      rtx stack_slot = rs6000_stack_temp (DImode, 8, 1);\n-      rtx temp = gen_reg_rtx (DImode);\n+      rtx temp1 = gen_reg_rtx (DImode);\n+      rtx temp2 = gen_reg_rtx (SImode);\n \n-      emit_insn (gen_fpcvtsi (temp, operands[1]));\n-      emit_move_insn (stack_slot, temp);\n-      emit_move_insn (operands[0],\n-\t\t      gen_rtx (SUBREG, SImode, stack_slot, WORDS_BIG_ENDIAN));\n+      emit_insn (gen_fpcvtsi (temp1, operands[1]));\n+      emit_move_insn (temp2, gen_rtx (SUBREG, SImode, temp1, WORDS_BIG_ENDIAN));\n+      emit_move_insn (operands[0], temp2);\n       DONE;\n     }\n   else\n@@ -4824,13 +4798,13 @@\n   \"(DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_SOLARIS) && flag_pic\"\n   \"\n {\n-  if (!rs6000_pic_register)\n+  if (!pic_offset_table_rtx)\n     {\n-      rs6000_pic_register = gen_reg_rtx (SImode);\n-      emit_insn (gen_init_v4_pic (rs6000_pic_register));\n+      pic_offset_table_rtx = gen_reg_rtx (SImode);\n+      emit_insn (gen_init_v4_pic (pic_offset_table_rtx));\n     }\n \n-  operands[2] = rs6000_pic_register;\n+  operands[2] = pic_offset_table_rtx;\n   if (flag_pic > 1)\n     {\n       emit_insn (gen_movsi_got_large (operands[0], operands[1], operands[2]));"}]}