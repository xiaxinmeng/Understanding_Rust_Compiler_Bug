{"sha": "46336a0eab790e4f94dd7e7ecf9339a884c44746", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDYzMzZhMGVhYjc5MGU0Zjk0ZGQ3ZTdlY2Y5MzM5YTg4NGM0NDc0Ng==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2018-01-12T11:29:30Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2018-01-12T11:29:30Z"}, "message": "re PR target/83368 (alloca after setjmp breaks PIC base reg)\n\n\tPR target/83368\n\t* config/sparc/sparc.h (PIC_OFFSET_TABLE_REGNUM): Set to INVALID_REGNUM\n\tin PIC mode except for TARGET_VXWORKS_RTP.\n\t* config/sparc/sparc.c: Include cfgrtl.h.\n\t(TARGET_INIT_PIC_REG): Define.\n\t(TARGET_USE_PSEUDO_PIC_REG): Likewise.\n\t(sparc_pic_register_p): New predicate.\n\t(sparc_legitimate_address_p): Use it.\n\t(sparc_legitimize_pic_address): Likewise.\n\t(sparc_delegitimize_address): Likewise.\n\t(sparc_mode_dependent_address_p): Likewise.\n\t(gen_load_pcrel_sym): Remove 4th parameter.\n\t(load_got_register): Adjust call to above.  Remove obsolete stuff.\n\t(sparc_expand_prologue): Do not call load_got_register here.\n\t(sparc_flat_expand_prologue): Likewise.\n\t(sparc_output_mi_thunk): Set the pic_offset_table_rtx object.\n\t(sparc_use_pseudo_pic_reg): New function.\n\t(sparc_init_pic_reg): Likewise.\n\t* config/sparc/sparc.md (vxworks_load_got): Set the GOT register.\n\t(builtin_setjmp_receiver): Enable only for TARGET_VXWORKS_RTP.\n\nFrom-SVN: r256575", "tree": {"sha": "51b16fb66a4da8d279c2e67e868a44edb627e20e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/51b16fb66a4da8d279c2e67e868a44edb627e20e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/46336a0eab790e4f94dd7e7ecf9339a884c44746", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46336a0eab790e4f94dd7e7ecf9339a884c44746", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46336a0eab790e4f94dd7e7ecf9339a884c44746", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46336a0eab790e4f94dd7e7ecf9339a884c44746/comments", "author": null, "committer": null, "parents": [{"sha": "7dbf870757aa5a35d52a2e1a3c40ce488c898d14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7dbf870757aa5a35d52a2e1a3c40ce488c898d14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7dbf870757aa5a35d52a2e1a3c40ce488c898d14"}], "stats": {"total": 179, "additions": 141, "deletions": 38}, "files": [{"sha": "e13743d6a3be6aa24a25eec1964d0bab3b51815c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46336a0eab790e4f94dd7e7ecf9339a884c44746/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46336a0eab790e4f94dd7e7ecf9339a884c44746/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=46336a0eab790e4f94dd7e7ecf9339a884c44746", "patch": "@@ -1,3 +1,26 @@\n+2018-01-12  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tPR target/83368\n+\t* config/sparc/sparc.h (PIC_OFFSET_TABLE_REGNUM): Set to INVALID_REGNUM\n+\tin PIC mode except for TARGET_VXWORKS_RTP.\n+\t* config/sparc/sparc.c: Include cfgrtl.h.\n+\t(TARGET_INIT_PIC_REG): Define.\n+\t(TARGET_USE_PSEUDO_PIC_REG): Likewise.\n+\t(sparc_pic_register_p): New predicate.\n+\t(sparc_legitimate_address_p): Use it.\n+\t(sparc_legitimize_pic_address): Likewise.\n+\t(sparc_delegitimize_address): Likewise.\n+\t(sparc_mode_dependent_address_p): Likewise.\n+\t(gen_load_pcrel_sym): Remove 4th parameter.\n+\t(load_got_register): Adjust call to above.  Remove obsolete stuff.\n+\t(sparc_expand_prologue): Do not call load_got_register here.\n+\t(sparc_flat_expand_prologue): Likewise.\n+\t(sparc_output_mi_thunk): Set the pic_offset_table_rtx object.\n+\t(sparc_use_pseudo_pic_reg): New function.\n+\t(sparc_init_pic_reg): Likewise.\n+\t* config/sparc/sparc.md (vxworks_load_got): Set the GOT register.\n+\t(builtin_setjmp_receiver): Enable only for TARGET_VXWORKS_RTP.\n+\n 2018-01-12  Christophe Lyon  <christophe.lyon@linaro.org>\n \n \t* doc/sourcebuild.texi (Effective-Target Keywords, Other attributes):"}, {"sha": "48669f1776520af1abc48b2b9604cd11abb77c9a", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 72, "deletions": 32, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46336a0eab790e4f94dd7e7ecf9339a884c44746/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46336a0eab790e4f94dd7e7ecf9339a884c44746/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=46336a0eab790e4f94dd7e7ecf9339a884c44746", "patch": "@@ -51,6 +51,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"explow.h\"\n #include \"expr.h\"\n #include \"debug.h\"\n+#include \"cfgrtl.h\"\n #include \"common/common-target.h\"\n #include \"gimplify.h\"\n #include \"langhooks.h\"\n@@ -662,6 +663,8 @@ static bool sparc_frame_pointer_required (void);\n static bool sparc_can_eliminate (const int, const int);\n static rtx sparc_builtin_setjmp_frame_value (void);\n static void sparc_conditional_register_usage (void);\n+static bool sparc_use_pseudo_pic_reg (void);\n+static void sparc_init_pic_reg (void);\n #ifdef TARGET_ALTERNATE_LONG_DOUBLE_MANGLING\n static const char *sparc_mangle_type (const_tree);\n #endif\n@@ -877,6 +880,12 @@ char sparc_hard_reg_printed[8];\n #undef TARGET_CONDITIONAL_REGISTER_USAGE\n #define TARGET_CONDITIONAL_REGISTER_USAGE sparc_conditional_register_usage\n \n+#undef TARGET_INIT_PIC_REG\n+#define TARGET_INIT_PIC_REG sparc_init_pic_reg\n+\n+#undef TARGET_USE_PSEUDO_PIC_REG\n+#define TARGET_USE_PSEUDO_PIC_REG sparc_use_pseudo_pic_reg\n+\n #ifdef TARGET_ALTERNATE_LONG_DOUBLE_MANGLING\n #undef TARGET_MANGLE_TYPE\n #define TARGET_MANGLE_TYPE sparc_mangle_type\n@@ -4361,6 +4370,25 @@ legitimate_pic_operand_p (rtx x)\n   return true;\n }\n \n+/* Return true if X is a representation of the PIC register.  */\n+\n+static bool\n+sparc_pic_register_p (rtx x)\n+{\n+  if (!REG_P (x) || !pic_offset_table_rtx)\n+    return false;\n+\n+  if (x == pic_offset_table_rtx)\n+    return true;\n+\n+  if (!HARD_REGISTER_P (pic_offset_table_rtx)\n+      && (HARD_REGISTER_P (x) || lra_in_progress)\n+      && ORIGINAL_REGNO (x) == REGNO (pic_offset_table_rtx))\n+    return true;\n+\n+  return false;\n+}\n+\n #define RTX_OK_FOR_OFFSET_P(X, MODE)\t\t\t\\\n   (CONST_INT_P (X)\t\t\t\t\t\\\n    && INTVAL (X) >= -0x1000\t\t\t\t\\\n@@ -4401,7 +4429,7 @@ sparc_legitimate_address_p (machine_mode mode, rtx addr, bool strict)\n \t}\n \n       if ((flag_pic == 1\n-\t   && rs1 == pic_offset_table_rtx\n+\t   && sparc_pic_register_p (rs1)\n \t   && !REG_P (rs2)\n \t   && GET_CODE (rs2) != SUBREG\n \t   && GET_CODE (rs2) != LO_SUM\n@@ -4796,7 +4824,7 @@ sparc_legitimize_pic_address (rtx orig, rtx reg)\n       rtx base, offset;\n \n       if (GET_CODE (XEXP (orig, 0)) == PLUS\n-\t  && XEXP (XEXP (orig, 0), 0) == pic_offset_table_rtx)\n+\t  && sparc_pic_register_p (XEXP (XEXP (orig, 0), 0)))\n \treturn orig;\n \n       if (reg == 0)\n@@ -4901,8 +4929,7 @@ sparc_delegitimize_address (rtx x)\n \n   /* This is generated by mov{si,di}_pic_label_ref in PIC mode.  */\n   if (GET_CODE (x) == MINUS\n-      && REG_P (XEXP (x, 0))\n-      && REGNO (XEXP (x, 0)) == PIC_OFFSET_TABLE_REGNUM\n+      && sparc_pic_register_p (XEXP (x, 0))\n       && GET_CODE (XEXP (x, 1)) == LO_SUM\n       && GET_CODE (XEXP (XEXP (x, 1), 1)) == UNSPEC\n       && XINT (XEXP (XEXP (x, 1), 1), 1) == UNSPEC_MOVE_PIC_LABEL)\n@@ -4981,14 +5008,10 @@ static bool\n sparc_mode_dependent_address_p (const_rtx addr,\n \t\t\t\taddr_space_t as ATTRIBUTE_UNUSED)\n {\n-  if (flag_pic && GET_CODE (addr) == PLUS)\n-    {\n-      rtx op0 = XEXP (addr, 0);\n-      rtx op1 = XEXP (addr, 1);\n-      if (op0 == pic_offset_table_rtx\n-\t  && symbolic_operand (op1, VOIDmode))\n-\treturn true;\n-    }\n+  if (GET_CODE (addr) == PLUS\n+      && sparc_pic_register_p (XEXP (addr, 0))\n+      && symbolic_operand (XEXP (addr, 1), VOIDmode))\n+    return true;\n \n   return false;\n }\n@@ -5017,17 +5040,17 @@ get_pc_thunk_name (char name[32], unsigned int regno)\n /* Wrapper around the load_pcrel_sym{si,di} patterns.  */\n \n static rtx\n-gen_load_pcrel_sym (rtx op0, rtx op1, rtx op2, rtx op3)\n+gen_load_pcrel_sym (rtx op0, rtx op1, rtx op2)\n {\n   int orig_flag_pic = flag_pic;\n   rtx insn;\n \n   /* The load_pcrel_sym{si,di} patterns require absolute addressing.  */\n   flag_pic = 0;\n   if (TARGET_ARCH64)\n-    insn = gen_load_pcrel_symdi (op0, op1, op2, op3);\n+    insn = gen_load_pcrel_symdi (op0, op1, op2, GEN_INT (REGNO (op0)));\n   else\n-    insn = gen_load_pcrel_symsi (op0, op1, op2, op3);\n+    insn = gen_load_pcrel_symsi (op0, op1, op2, GEN_INT (REGNO (op0)));\n   flag_pic = orig_flag_pic;\n \n   return insn;\n@@ -5038,7 +5061,6 @@ gen_load_pcrel_sym (rtx op0, rtx op1, rtx op2, rtx op3)\n void\n load_got_register (void)\n {\n-  /* In PIC mode, this will retrieve pic_offset_table_rtx.  */\n   if (!global_offset_table_rtx)\n     global_offset_table_rtx = gen_rtx_REG (Pmode, GLOBAL_OFFSET_TABLE_REGNUM);\n \n@@ -5056,15 +5078,8 @@ load_got_register (void)\n \t}\n \n       emit_insn (gen_load_pcrel_sym (global_offset_table_rtx, sparc_got (),\n-\t\t\t\t     got_helper_rtx,\n-\t\t\t\t     GEN_INT (GLOBAL_OFFSET_TABLE_REGNUM)));\n+\t\t\t\t     got_helper_rtx));\n     }\n-\n-  /* Need to emit this whether or not we obey regdecls,\n-     since setjmp/longjmp can cause life info to screw up.\n-     ??? In the case where we don't obey regdecls, this is not sufficient\n-     since we may not fall out the bottom.  */\n-  emit_use (global_offset_table_rtx);\n }\n \n /* Emit a call instruction with the pattern given by PAT.  ADDR is the\n@@ -6039,10 +6054,6 @@ sparc_expand_prologue (void)\n \t\t\t\t\t   - sparc_apparent_frame_size,\n \t\t\t\t\t SORR_SAVE);\n \n-  /* Load the GOT register if needed.  */\n-  if (crtl->uses_pic_offset_table)\n-    load_got_register ();\n-\n   /* Advertise that the data calculated just above are now valid.  */\n   sparc_prologue_data_valid_p = true;\n }\n@@ -6161,10 +6172,6 @@ sparc_flat_expand_prologue (void)\n \t\t\t\t\t   - sparc_apparent_frame_size,\n \t\t\t\t\t SORR_SAVE);\n \n-  /* Load the GOT register if needed.  */\n-  if (crtl->uses_pic_offset_table)\n-    load_got_register ();\n-\n   /* Advertise that the data calculated just above are now valid.  */\n   sparc_prologue_data_valid_p = true;\n }\n@@ -12305,6 +12312,8 @@ sparc_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n \t  spill_reg = gen_rtx_REG (word_mode, 15);  /* %o7 */\n \t  start_sequence ();\n \t  load_got_register ();  /* clobbers %o7 */\n+\t  if (!TARGET_VXWORKS_RTP)\n+\t    pic_offset_table_rtx = global_offset_table_rtx;\n \t  scratch = sparc_legitimize_pic_address (funexp, scratch);\n \t  seq = get_insns ();\n \t  end_sequence ();\n@@ -12950,6 +12959,37 @@ sparc_conditional_register_usage (void)\n     global_regs[SPARC_GSR_REG] = 1;\n }\n \n+/* Implement TARGET_USE_PSEUDO_PIC_REG.  */\n+\n+static bool\n+sparc_use_pseudo_pic_reg (void)\n+{\n+  return !TARGET_VXWORKS_RTP && flag_pic;\n+}\n+\n+/* Implement TARGET_INIT_PIC_REG.  */\n+\n+static void\n+sparc_init_pic_reg (void)\n+{\n+  edge entry_edge;\n+  rtx_insn *seq;\n+\n+  if (!crtl->uses_pic_offset_table)\n+    return;\n+\n+  start_sequence ();\n+  load_got_register ();\n+  if (!TARGET_VXWORKS_RTP)\n+    emit_move_insn (pic_offset_table_rtx, global_offset_table_rtx);\n+  seq = get_insns ();\n+  end_sequence ();\n+\n+  entry_edge = single_succ_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n+  insert_insn_on_edge (seq, entry_edge);\n+  commit_one_edge_insertion (entry_edge);\n+}\n+\n /* Implement TARGET_PREFERRED_RELOAD_CLASS:\n \n    - We can't load constants into FP registers."}, {"sha": "419995431e252a647be64db23dd69c19ea12386e", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46336a0eab790e4f94dd7e7ecf9339a884c44746/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46336a0eab790e4f94dd7e7ecf9339a884c44746/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=46336a0eab790e4f94dd7e7ecf9339a884c44746", "patch": "@@ -808,11 +808,14 @@ extern enum cmodel sparc_cmodel;\n \n #define GLOBAL_OFFSET_TABLE_REGNUM 23\n \n-/* Register which holds offset table for position-independent\n-   data references.  */\n+/* Register which holds offset table for position-independent data references.\n+   The original SPARC ABI imposes no requirement on the choice of the register\n+   so we use a pseudo-register to make sure it is properly saved and restored\n+   around calls to setjmp.  Now the ABI of VxWorks RTP makes it live on entry\n+   to PLT entries so we use the canonical GOT register in this case.  */\n \n #define PIC_OFFSET_TABLE_REGNUM \\\n-  (flag_pic ? GLOBAL_OFFSET_TABLE_REGNUM : INVALID_REGNUM)\n+  (TARGET_VXWORKS_RTP && flag_pic ? GLOBAL_OFFSET_TABLE_REGNUM : INVALID_REGNUM)\n \n /* Pick a default value we can notice from override_options:\n    !v9: Default is on."}, {"sha": "3255e5c827229c0f679b7be7659e4d1d12b5d9ff", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46336a0eab790e4f94dd7e7ecf9339a884c44746/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46336a0eab790e4f94dd7e7ecf9339a884c44746/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=46336a0eab790e4f94dd7e7ecf9339a884c44746", "patch": "@@ -1797,7 +1797,7 @@\n   \"flag_pic\"\n   \"or\\t%1, %%lo(%a3-(%a2-.)), %0\")\n \n-;; Set up the PIC register for VxWorks.\n+;; Set up the GOT register for VxWorks.\n \n (define_expand \"vxworks_load_got\"\n   [(set (match_dup 0)\n@@ -1808,7 +1808,7 @@\n \t(mem:SI (lo_sum:SI (match_dup 0) (match_dup 2))))]\n   \"TARGET_VXWORKS_RTP\"\n {\n-  operands[0] = pic_offset_table_rtx;\n+  operands[0] = global_offset_table_rtx;\n   operands[1] = gen_rtx_SYMBOL_REF (SImode, VXWORKS_GOTT_BASE);\n   operands[2] = gen_rtx_SYMBOL_REF (SImode, VXWORKS_GOTT_INDEX);\n })\n@@ -7475,7 +7475,7 @@ visl\")\n \n (define_expand \"builtin_setjmp_receiver\"\n   [(label_ref (match_operand 0 \"\" \"\"))]\n-  \"flag_pic\"\n+  \"TARGET_VXWORKS_RTP && flag_pic\"\n {\n   load_got_register ();\n   DONE;"}, {"sha": "d0fecb3632707798cb98b824015350c18ee732ff", "filename": "gcc/testsuite/gcc.target/sparc/setjmp-1.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46336a0eab790e4f94dd7e7ecf9339a884c44746/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fsetjmp-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46336a0eab790e4f94dd7e7ecf9339a884c44746/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fsetjmp-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fsetjmp-1.c?ref=46336a0eab790e4f94dd7e7ecf9339a884c44746", "patch": "@@ -0,0 +1,37 @@\n+/* PR target/83368 */\r\n+/* Testcase written by James Clarke <jrtc27@jrtc27.com> */\r\n+\r\n+/* { dg-do run { target *-*-solaris2.* *-*-linux* *-*-*bsd* } } */\r\n+/* { dg-require-effective-target fpic } */\r\n+/* { dg-options \"-fPIC\" } */\r\n+\r\n+#include <stdio.h>\r\n+#include <alloca.h>\r\n+#include <setjmp.h>\r\n+#include <string.h>\r\n+#include <stdlib.h>\r\n+\r\n+jmp_buf jb;\r\n+\r\n+int foo = 99;\r\n+int c = 0;\r\n+\r\n+void bar (void)\r\n+{\r\n+  c++;\r\n+  longjmp (jb, 1);\r\n+}\r\n+\r\n+int main (void)\r\n+{\r\n+  setjmp (jb);\r\n+\r\n+  char *p = alloca (256);\r\n+  memset (p, 0, 256);\r\n+  sprintf (p, \"%d\\n\", foo);\r\n+\r\n+  if (c < 10)\r\n+    bar();\r\n+\r\n+  return 0;\r\n+}\r"}]}