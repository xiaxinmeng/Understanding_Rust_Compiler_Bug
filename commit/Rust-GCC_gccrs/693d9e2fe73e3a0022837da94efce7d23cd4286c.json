{"sha": "693d9e2fe73e3a0022837da94efce7d23cd4286c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjkzZDllMmZlNzNlM2EwMDIyODM3ZGE5NGVmY2U3ZDIzY2Q0Mjg2Yw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-04-27T07:01:04Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-04-27T07:01:04Z"}, "message": "flow.c (update_life_info): Consider blocks null to mean the universal set.\n\n        * flow.c (update_life_info): Consider blocks null to mean the\n        universal set.\n        (calculate_global_regs_live): Likewise.\n        (life_analysis): Do that instead of collecting all_blocks.\n\nFrom-SVN: r33469", "tree": {"sha": "ecee1c2481cdd007936d5ea6811322ad50e6ac37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ecee1c2481cdd007936d5ea6811322ad50e6ac37"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/693d9e2fe73e3a0022837da94efce7d23cd4286c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/693d9e2fe73e3a0022837da94efce7d23cd4286c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/693d9e2fe73e3a0022837da94efce7d23cd4286c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/693d9e2fe73e3a0022837da94efce7d23cd4286c/comments", "author": null, "committer": null, "parents": [{"sha": "56aba4a8b5221971ccfb59f144d8666905512179", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56aba4a8b5221971ccfb59f144d8666905512179", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56aba4a8b5221971ccfb59f144d8666905512179"}], "stats": {"total": 100, "additions": 73, "deletions": 27}, "files": [{"sha": "68fa1c047cb15676c5789a8162c07308245a567f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/693d9e2fe73e3a0022837da94efce7d23cd4286c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/693d9e2fe73e3a0022837da94efce7d23cd4286c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=693d9e2fe73e3a0022837da94efce7d23cd4286c", "patch": "@@ -1,3 +1,10 @@\n+2000-04-26  Richard Henderson  <rth@cygnus.com>\n+\n+\t* flow.c (update_life_info): Consider blocks null to mean the\n+\tuniversal set.\n+\t(calculate_global_regs_live): Likewise.\n+\t(life_analysis): Do that instead of collecting all_blocks.\n+\n 2000-04-26  Richard Henderson  <rth@cygnus.com>\n \n \t* flow.c (tidy_fallthru_edge): Don't delete the jump when it's"}, {"sha": "8e7b9c337c79cebb6f0f7fcec3451d1782f41663", "filename": "gcc/flow.c", "status": "modified", "additions": 66, "deletions": 27, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/693d9e2fe73e3a0022837da94efce7d23cd4286c/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/693d9e2fe73e3a0022837da94efce7d23cd4286c/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=693d9e2fe73e3a0022837da94efce7d23cd4286c", "patch": "@@ -2486,7 +2486,6 @@ life_analysis (f, file, flags)\n   register int i;\n   static struct {int from, to; } eliminables[] = ELIMINABLE_REGS;\n #endif\n-  sbitmap all_blocks;\n \n   /* Record which registers will be eliminated.  We use this in\n      mark_used_regs.  */\n@@ -2532,8 +2531,6 @@ life_analysis (f, file, flags)\n      data from lifetime analysis.  */\n   allocate_reg_life_data ();\n   allocate_bb_life_data ();\n-  all_blocks = sbitmap_alloc (n_basic_blocks);\n-  sbitmap_ones (all_blocks);\n \n   /* Find the set of registers live on function exit.  */\n   mark_regs_live_at_end (EXIT_BLOCK_PTR->global_live_at_start);\n@@ -2544,11 +2541,9 @@ life_analysis (f, file, flags)\n \n   if (flags & PROP_REG_INFO)\n     memset (regs_ever_live, 0, sizeof(regs_ever_live));\n-  update_life_info (all_blocks, UPDATE_LIFE_GLOBAL, flags);\n+  update_life_info (NULL, UPDATE_LIFE_GLOBAL, flags);\n \n   /* Clean up.  */\n-  sbitmap_free (all_blocks);\n-\n   if (flags & PROP_SCAN_DEAD_CODE)\n     end_alias_analysis ();\n \n@@ -2634,10 +2629,11 @@ verify_local_live_at_start (new_live_at_start, bb)\n }\n \n /* Updates life information starting with the basic blocks set in BLOCKS.\n+   If BLOCKS is null, consider it to be the universal set.\n    \n-   If LOCAL_ONLY, such as after splitting or peepholeing, we are only\n-   expecting local modifications to basic blocks.  If we find extra\n-   registers live at the beginning of a block, then we either killed\n+   If EXTENT is UPDATE_LIFE_LOCAL, such as after splitting or peepholeing,\n+   we are only expecting local modifications to basic blocks.  If we find\n+   extra registers live at the beginning of a block, then we either killed\n    useful data, or we have a broken split that wants data not provided.\n    If we find registers removed from live_at_start, that means we have\n    a broken peephole that is killing a register it shouldn't.\n@@ -2672,16 +2668,32 @@ update_life_info (blocks, extent, prop_flags)\n \tcount_or_remove_death_notes (blocks, 1);\n     }\n \n-  EXECUTE_IF_SET_IN_SBITMAP (blocks, 0, i,\n+  if (blocks)\n     {\n-      basic_block bb = BASIC_BLOCK (i);\n+      EXECUTE_IF_SET_IN_SBITMAP (blocks, 0, i,\n+\t{\n+\t  basic_block bb = BASIC_BLOCK (i);\n \n-      COPY_REG_SET (tmp, bb->global_live_at_end);\n-      propagate_block (bb, tmp, (regset) NULL, prop_flags);\n+\t  COPY_REG_SET (tmp, bb->global_live_at_end);\n+\t  propagate_block (bb, tmp, (regset) NULL, prop_flags);\n \n-      if (extent == UPDATE_LIFE_LOCAL)\n-\tverify_local_live_at_start (tmp, bb);\n-    });\n+\t  if (extent == UPDATE_LIFE_LOCAL)\n+\t    verify_local_live_at_start (tmp, bb);\n+\t});\n+    }\n+  else\n+    {\n+      for (i = n_basic_blocks - 1; i >= 0; --i)\n+\t{\n+\t  basic_block bb = BASIC_BLOCK (i);\n+\n+\t  COPY_REG_SET (tmp, bb->global_live_at_end);\n+\t  propagate_block (bb, tmp, (regset) NULL, prop_flags);\n+\n+\t  if (extent == UPDATE_LIFE_LOCAL)\n+\t    verify_local_live_at_start (tmp, bb);\n+\t}\n+    }\n \n   FREE_REG_SET (tmp);\n \n@@ -2970,6 +2982,8 @@ set_phi_alternative_reg (insn, dest_regno, src_regno, data)\n \n /* Propagate global life info around the graph of basic blocks.  Begin\n    considering blocks with their corresponding bit set in BLOCKS_IN. \n+   If BLOCKS_IN is null, consider it the universal set.\n+\n    BLOCKS_OUT is set for every block that was changed.  */\n \n static void\n@@ -3000,14 +3014,27 @@ calculate_global_regs_live (blocks_in, blocks_out, flags)\n   /* Queue the blocks set in the initial mask.  Do this in reverse block\n      number order so that we are more likely for the first round to do \n      useful work.  We use AUX non-null to flag that the block is queued.  */\n-  EXECUTE_IF_SET_IN_SBITMAP (blocks_in, 0, i,\n+  if (blocks_in)\n     {\n-      basic_block bb = BASIC_BLOCK (i);\n-      *--qhead = bb;\n-      bb->aux = bb;\n-    });\n+      EXECUTE_IF_SET_IN_SBITMAP (blocks_in, 0, i,\n+\t{\n+\t  basic_block bb = BASIC_BLOCK (i);\n+\t  *--qhead = bb;\n+\t  bb->aux = bb;\n+\t});\n+    }\n+  else\n+    {\n+      for (i = 0; i < n_basic_blocks; ++i)\n+\t{\n+\t  basic_block bb = BASIC_BLOCK (i);\n+\t  *--qhead = bb;\n+\t  bb->aux = bb;\n+\t}\n+    }\n \n-  sbitmap_zero (blocks_out);\n+  if (blocks_out)\n+    sbitmap_zero (blocks_out);\n \n   while (qhead != qtail)\n     {\n@@ -3080,7 +3107,8 @@ calculate_global_regs_live (blocks_in, blocks_out, flags)\n \n       /* Let our caller know that BB changed enough to require its\n \t death notes updated.  */\n-      SET_BIT (blocks_out, bb->index);\n+      if (blocks_out)\n+\tSET_BIT (blocks_out, bb->index);\n \n       if (! rescan)\n \t{\n@@ -3130,11 +3158,22 @@ calculate_global_regs_live (blocks_in, blocks_out, flags)\n   FREE_REG_SET (tmp);\n   FREE_REG_SET (new_live_at_end);\n \n-  EXECUTE_IF_SET_IN_SBITMAP (blocks_out, 0, i,\n+  if (blocks_out)\n     {\n-      basic_block bb = BASIC_BLOCK (i);\n-      FREE_REG_SET (bb->local_set);\n-    });\n+      EXECUTE_IF_SET_IN_SBITMAP (blocks_out, 0, i,\n+\t{\n+\t  basic_block bb = BASIC_BLOCK (i);\n+\t  FREE_REG_SET (bb->local_set);\n+\t});\n+    }\n+  else\n+    {\n+      for (i = n_basic_blocks - 1; i >= 0; --i)\n+\t{\n+\t  basic_block bb = BASIC_BLOCK (i);\n+\t  FREE_REG_SET (bb->local_set);\n+\t}\n+    }\n \n   free (queue);\n }"}]}