{"sha": "5f57ad31792778dd585481c39f0deffef3aaa0a5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWY1N2FkMzE3OTI3NzhkZDU4NTQ4MWMzOWYwZGVmZmVmM2FhYTBhNQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-02-10T13:54:45Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-02-10T13:54:45Z"}, "message": "init.c (__gnat_initialize): Add a new parameter eh which contains the address of the exception registration.\n\n\t* init.c (__gnat_initialize): Add a new parameter eh which contains the\n\taddress of the exception registration. The Win32 version of this\n\troutine calls __gnat_install_SEH_handler() to initialize the SEH\n\t(Structured Exception Handling) handler.\n\t(__gnat_error_handler) [Win32]: Removed. Not needed as we use\n\tSEH (Structured Exception Handling) now.\n\t(__gnat_install_handler) [Win32]: Nothing to do now as we use SEH.\n\t(__gnat_initialize for ppc-vxworks): Adjust comments and the\n\tpreprocessor condition protecting the call to the extra eh setup\n\tsubprogram, which is only available for the ppc target.\n\t(__gnat_clear_exception_count): replaced reference to\n\tvariable taskIdCurrent by call to taskIdSelf(), cleaner.\n\n\t* seh_init.c: New file.\n\n\t* Make-lang.in: (GNAT_ADA_OBJS): Add seh_init.o.\n\t(GNATBIND_OBJS): Idem.\n\n\t* misc.c (gnat_parse_file): Update call to __gnat_initialize. This\n\troutine takes a new parameter (a pointer to the exception registration\n\tfor the SEH (Structured Exception Handling) support.\n\n\t* raise.h: (__gnat_install_SEH_handler): New prototype.\n\tUpdate copyright notice.\n\n\t* s-tassta.adb (Task_Wrapper): Declare the exception registration\n\trecord and initialize it by calling __gnat_install_SEH_handler.\n\nFrom-SVN: r94816", "tree": {"sha": "260cb614852d6263229864541810297807d70342", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/260cb614852d6263229864541810297807d70342"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5f57ad31792778dd585481c39f0deffef3aaa0a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f57ad31792778dd585481c39f0deffef3aaa0a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f57ad31792778dd585481c39f0deffef3aaa0a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f57ad31792778dd585481c39f0deffef3aaa0a5/comments", "author": null, "committer": null, "parents": [{"sha": "16e845ef3dcb66829c8b5f086164cc7540093a73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16e845ef3dcb66829c8b5f086164cc7540093a73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16e845ef3dcb66829c8b5f086164cc7540093a73"}], "stats": {"total": 451, "additions": 293, "deletions": 158}, "files": [{"sha": "220b3563a2952be46c6c0d565323a5cd50a197c8", "filename": "gcc/ada/Make-lang.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f57ad31792778dd585481c39f0deffef3aaa0a5/gcc%2Fada%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f57ad31792778dd585481c39f0deffef3aaa0a5/gcc%2Fada%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMake-lang.in?ref=5f57ad31792778dd585481c39f0deffef3aaa0a5", "patch": "@@ -146,7 +146,7 @@ GNAT_ADA_OBJS = ada/ada.o ada/a-charac.o ada/a-chlat1.o ada/a-except.o \\\n  ada/stylesw.o ada/validsw.o ada/system.o ada/table.o ada/targparm.o \\\n  ada/tbuild.o ada/tree_gen.o ada/tree_io.o ada/treepr.o ada/treeprs.o \\\n  ada/ttypef.o ada/ttypes.o ada/types.o ada/uintp.o ada/uname.o ada/urealp.o \\\n- ada/usage.o ada/widechar.o ada/s-crtl.o\n+ ada/usage.o ada/widechar.o ada/s-crtl.o ada/seh_init.o\n \n # Object files for gnat executables\n GNAT1_ADA_OBJS = $(GNAT_ADA_OBJS) ada/back_end.o ada/gnat1drv.o\n@@ -161,6 +161,7 @@ GNATBIND_OBJS = \\\n  ada/cstreams.o   \\\n  ada/final.o      \\\n  ada/init.o       \\\n+ ada/seh_init.o   \\\n  ada/link.o       \\\n  ada/raise.o      \\\n  ada/tracebak.o   \\"}, {"sha": "df5b2496749306aac729cba73e9aed8eb9776453", "filename": "gcc/ada/init.c", "status": "modified", "additions": 38, "deletions": 151, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f57ad31792778dd585481c39f0deffef3aaa0a5/gcc%2Fada%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f57ad31792778dd585481c39f0deffef3aaa0a5/gcc%2Fada%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finit.c?ref=5f57ad31792778dd585481c39f0deffef3aaa0a5", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *          Copyright (C) 1992-2005 Free Software Foundation, Inc.          *\n+ *          Copyright (C) 1992-2005, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -403,7 +403,7 @@ __gnat_install_handler (void)\n }\n \n void\n-__gnat_initialize (void)\n+__gnat_initialize (void *eh)\n {\n }\n \n@@ -418,7 +418,7 @@ extern void __gnat_install_handler (void);\n /* For RTEMS, each bsp will provide a custom __gnat_install_handler (). */\n \n void\n-__gnat_initialize (void)\n+__gnat_initialize (void *eh)\n {\n    __gnat_install_handler ();\n }\n@@ -543,7 +543,7 @@ __gnat_install_handler (void)\n }\n \n void\n-__gnat_initialize (void)\n+__gnat_initialize (void *eh)\n {\n }\n \n@@ -657,7 +657,7 @@ __gnat_install_handler (void)\n }\n \n void\n-__gnat_initialize (void)\n+__gnat_initialize (void *eh)\n {\n }\n \n@@ -806,7 +806,7 @@ __gnat_install_handler (void)\n }\n \n void\n-__gnat_initialize (void)\n+__gnat_initialize (void *eh ATTRIBUTE_UNUSED)\n {\n }\n \n@@ -817,142 +817,27 @@ __gnat_initialize (void)\n #elif defined (__MINGW32__)\n #include <windows.h>\n \n-static LONG WINAPI __gnat_error_handler (PEXCEPTION_POINTERS);\n-\n-/* __gnat_initialize (mingw32).  */\n-\n-static LONG WINAPI\n-__gnat_error_handler (PEXCEPTION_POINTERS info)\n-{\n-  struct Exception_Data *exception;\n-  const char *msg;\n-\n-  switch (info->ExceptionRecord->ExceptionCode)\n-    {\n-    case EXCEPTION_ACCESS_VIOLATION:\n-      /* If the failing address isn't maximally-aligned or if the page\n-\t before the faulting page is not accessible, this is a program error.\n-      */\n-      if ((info->ExceptionRecord->ExceptionInformation[1] & 3) != 0\n-\t  || IsBadCodePtr\n-\t  ((void *)(info->ExceptionRecord->ExceptionInformation[1] + 4096)))\n-\t{\n-\t  exception = &program_error;\n-\t  msg = \"EXCEPTION_ACCESS_VIOLATION\";\n-\t}\n-      else\n-\t{\n-\t  /* otherwise it is a stack overflow  */\n-\t  exception = &storage_error;\n-\t  msg = \"stack overflow (or erroneous memory access)\";\n-\t}\n-      break;\n-\n-    case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:\n-      exception = &constraint_error;\n-      msg = \"EXCEPTION_ARRAY_BOUNDS_EXCEEDED\";\n-      break;\n-\n-    case EXCEPTION_DATATYPE_MISALIGNMENT:\n-      exception = &constraint_error;\n-      msg = \"EXCEPTION_DATATYPE_MISALIGNMENT\";\n-      break;\n-\n-    case EXCEPTION_FLT_DENORMAL_OPERAND:\n-      exception = &constraint_error;\n-      msg = \"EXCEPTION_FLT_DENORMAL_OPERAND\";\n-      break;\n-\n-    case EXCEPTION_FLT_DIVIDE_BY_ZERO:\n-      exception = &constraint_error;\n-      msg = \"EXCEPTION_FLT_DENORMAL_OPERAND\";\n-      break;\n-\n-    case EXCEPTION_FLT_INVALID_OPERATION:\n-      exception = &constraint_error;\n-      msg = \"EXCEPTION_FLT_INVALID_OPERATION\";\n-      break;\n-\n-    case EXCEPTION_FLT_OVERFLOW:\n-      exception = &constraint_error;\n-      msg = \"EXCEPTION_FLT_OVERFLOW\";\n-      break;\n-\n-    case EXCEPTION_FLT_STACK_CHECK:\n-      exception = &program_error;\n-      msg = \"EXCEPTION_FLT_STACK_CHECK\";\n-      break;\n-\n-    case EXCEPTION_FLT_UNDERFLOW:\n-      exception = &constraint_error;\n-      msg = \"EXCEPTION_FLT_UNDERFLOW\";\n-      break;\n-\n-    case EXCEPTION_INT_DIVIDE_BY_ZERO:\n-      exception = &constraint_error;\n-      msg = \"EXCEPTION_INT_DIVIDE_BY_ZERO\";\n-      break;\n-\n-    case EXCEPTION_INT_OVERFLOW:\n-      exception = &constraint_error;\n-      msg = \"EXCEPTION_INT_OVERFLOW\";\n-      break;\n-\n-    case EXCEPTION_INVALID_DISPOSITION:\n-      exception = &program_error;\n-      msg = \"EXCEPTION_INVALID_DISPOSITION\";\n-      break;\n-\n-    case EXCEPTION_NONCONTINUABLE_EXCEPTION:\n-      exception = &program_error;\n-      msg = \"EXCEPTION_NONCONTINUABLE_EXCEPTION\";\n-      break;\n-\n-    case EXCEPTION_PRIV_INSTRUCTION:\n-      exception = &program_error;\n-      msg = \"EXCEPTION_PRIV_INSTRUCTION\";\n-      break;\n-\n-    case EXCEPTION_SINGLE_STEP:\n-      exception = &program_error;\n-      msg = \"EXCEPTION_SINGLE_STEP\";\n-      break;\n-\n-    case EXCEPTION_STACK_OVERFLOW:\n-      exception = &storage_error;\n-      msg = \"EXCEPTION_STACK_OVERFLOW\";\n-      break;\n-\n-   default:\n-      exception = &program_error;\n-      msg = \"unhandled signal\";\n-    }\n-\n-  Raise_From_Signal_Handler (exception, msg);\n-  return 0; /* This is never reached, avoid compiler warning */\n-}\n-\n void\n __gnat_install_handler (void)\n {\n-  SetUnhandledExceptionFilter (__gnat_error_handler);\n-  __gnat_handler_installed = 1;\n }\n \n void\n-__gnat_initialize (void)\n+__gnat_initialize (void *eh)\n {\n-\n    /* Initialize floating-point coprocessor. This call is needed because\n       the MS libraries default to 64-bit precision instead of 80-bit\n       precision, and we require the full precision for proper operation,\n       given that we have set Max_Digits etc with this in mind */\n-\n    __gnat_init_float ();\n \n-   /* initialize a lock for a process handle list - see a-adaint.c for the\n+   /* Initialize a lock for a process handle list - see a-adaint.c for the\n       implementation of __gnat_portable_no_block_spawn, __gnat_portable_wait */\n    __gnat_plist_init();\n+\n+   /* Install the Structured Exception handler.  */\n+   if (eh)\n+     __gnat_install_SEH_handler (eh);\n }\n \n /***************************************/\n@@ -1023,7 +908,7 @@ __gnat_install_handler (void)\n }\n \n void\n-__gnat_initialize (void)\n+__gnat_initialize (void *eh)\n {\n    __gnat_init_float ();\n }\n@@ -1035,7 +920,7 @@ __gnat_initialize (void)\n #elif defined (__Lynx__)\n \n void\n-__gnat_initialize (void)\n+__gnat_initialize (void *eh)\n {\n    __gnat_init_float ();\n }\n@@ -1057,7 +942,7 @@ __gnat_install_handler (void)\n #elif defined (__EMX__) /* OS/2 dependent initialization */\n \n void\n-__gnat_initialize (void)\n+__gnat_initialize (void *eh)\n {\n }\n \n@@ -1224,7 +1109,7 @@ __gnat_install_handler (void)\n }\n \n void\n-__gnat_initialize (void)\n+__gnat_initialize (void *eh)\n {\n }\n \n@@ -1332,7 +1217,7 @@ __gnat_install_handler (void)\n }\n \n void\n-__gnat_initialize (void)\n+__gnat_initialize (void *eh)\n {\n }\n \n@@ -1564,7 +1449,7 @@ __gnat_install_handler (void)\n }\n \n void\n-__gnat_initialize(void)\n+__gnat_initialize(void *eh)\n {\n }\n \n@@ -1636,7 +1521,7 @@ __gnat_install_handler ()\n }\n \n void\n-__gnat_initialize ()\n+__gnat_initialize (void *eh)\n {\n    __gnat_install_handler ();\n \n@@ -1694,7 +1579,9 @@ void\n __gnat_clear_exception_count (void)\n {\n #ifdef VTHREADS\n-  taskIdCurrent->vThreads.excCnt = 0;\n+  WIND_TCB *currentTask = (WIND_TCB *) taskIdSelf();\n+\n+  currentTask->vThreads.excCnt = 0;\n #endif\n }\n \n@@ -1824,28 +1711,28 @@ __gnat_init_float (void)\n }\n \n void\n-__gnat_initialize (void)\n+__gnat_initialize (void *eh)\n {\n   __gnat_init_float ();\n \n   /* On targets where we might be using the ZCX scheme, we need to register\n      the frame tables.\n \n      For applications loaded as a set of \"modules\", the crtstuff objects\n-     linked in (crtbegin/endS) are tailored to provide this service a-la C++\n-     static constructor fashion, typically triggered by the VxWorks loader.\n-     This is achieved by way of a special variable declaration in the crt\n-     object, the name of which has been deduced by analyzing the output of the\n-     \"munching\" step documented for C++.  The de-registration call is handled\n-     symetrically, a-la C++ destructor fashion and typically triggered by the\n-     dynamic unloader. Note that since the tables shall be registered against\n-     a common datastructure, libgcc should be one of the modules (vs beeing\n+     linked in (crtbegin/end) are tailored to provide this service a-la C++\n+     constructor fashion, typically triggered by the VxWorks loader.  This is\n+     achieved by way of a special variable declaration in the crt object, the\n+     name of which has been deduced by analyzing the output of the \"munching\"\n+     step documented for C++.  The de-registration is handled symetrically,\n+     a-la C++ destructor fashion and typically triggered by the dynamic\n+     unloader.  Note that since the tables shall be registered against a\n+     common datastructure, libgcc should be one of the modules (vs beeing\n      partially linked against all the others at build time) and shall be\n      loaded first.\n \n      For applications linked with the kernel, the scheme above would lead to\n      duplicated symbols because the VxWorks kernel build \"munches\" by default.\n-     To prevent those conflicts, we link against crtbegin/end objects that\n+     To prevent those conflicts, we link against crtbegin/endS objects that\n      don't include the special variable and directly call the appropriate\n      function here. We'll never unload that, so there is no de-registration to\n      worry about.\n@@ -1856,15 +1743,15 @@ __gnat_initialize (void)\n \n      We can differentiate by looking at the __module_has_ctors value provided\n      by each class of crt objects. As of today, selecting the crt set with the\n-     static ctors/dtors capabilities (first scheme above) is triggered by\n-     adding \"-static\" to the gcc *link* command line options. Without this,\n-     the other set of crt objects is fetched.\n+     ctors/dtors capabilities (first scheme above) is triggered by adding\n+     \"-dynamic\" to the gcc *link* command line options. Selecting the other\n+     set of crt objects is achieved by \"-static\" instead.\n \n      This is a first approach, tightly synchronized with a number of GCC\n      configuration and crtstuff changes. We need to ensure that those changes\n      are there to activate this circuitry.  */\n \n-#if DWARF2_UNWIND_INFO && defined (_ARCH_PPC)\n+#if (__GNUC__ >= 3) && (defined (_ARCH_PPC) || defined (__ppc))\n  {\n    /* The scheme described above is only useful for the actual ZCX case, and\n       we don't want any reference to the crt provided symbols otherwise.  We\n@@ -1947,7 +1834,7 @@ __gnat_install_handler(void)\n }\n \n void\n-__gnat_initialize (void)\n+__gnat_initialize (void *eh)\n {\n   __gnat_install_handler ();\n   __gnat_init_float ();\n@@ -1963,7 +1850,7 @@ __gnat_initialize (void)\n /***************************************/\n \n void\n-__gnat_initialize (void)\n+__gnat_initialize (void *eh)\n {\n }\n "}, {"sha": "e63277dc34529a7046f15c548ce086e5aeffcdb9", "filename": "gcc/ada/misc.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f57ad31792778dd585481c39f0deffef3aaa0a5/gcc%2Fada%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f57ad31792778dd585481c39f0deffef3aaa0a5/gcc%2Fada%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmisc.c?ref=5f57ad31792778dd585481c39f0deffef3aaa0a5", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                           C Implementation File                          *\n  *                                                                          *\n- *          Copyright (C) 1992-2004 Free Software Foundation, Inc.          *\n+ *          Copyright (C) 1992-2005, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -217,7 +217,7 @@ extern char **gnat_argv;\n \n \f\n /* Declare functions we use as part of startup.  */\n-extern void __gnat_initialize\t(void);\n+extern void __gnat_initialize\t(void *);\n extern void adainit\t\t(void);\n extern void _ada_gnat1drv\t(void);\n \n@@ -227,7 +227,7 @@ static void\n gnat_parse_file (int set_yydebug ATTRIBUTE_UNUSED)\n {\n   /* call the target specific initializations */\n-  __gnat_initialize();\n+  __gnat_initialize (NULL);\n \n   /* Call the front-end elaboration procedures */\n   adainit ();"}, {"sha": "8ef77d7f5c6cf42c5a690ab295477f204a743a11", "filename": "gcc/ada/raise.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f57ad31792778dd585481c39f0deffef3aaa0a5/gcc%2Fada%2Fraise.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f57ad31792778dd585481c39f0deffef3aaa0a5/gcc%2Fada%2Fraise.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fraise.h?ref=5f57ad31792778dd585481c39f0deffef3aaa0a5", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                              C Header File                               *\n  *                                                                          *\n- *          Copyright (C) 1992-2004, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2005, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -66,8 +66,9 @@ extern void __gnat_set_globals\t\t(int, int,\n \t\t\t\t\t\t char, char, char, char,\n \t\t\t\t\t\t char *, char *,\n \t\t\t\t\t\t int, int, int, int, int);\n-extern void __gnat_initialize\t\t(void);\n+extern void __gnat_initialize\t\t(void *);\n extern void __gnat_init_float\t\t(void);\n extern void __gnat_install_handler\t(void);\n+extern void __gnat_install_SEH_handler  (void *);\n \n extern int gnat_exit_status;"}, {"sha": "0355e61e4c5d5fba57b1f94eba14e8b22bc108f1", "filename": "gcc/ada/s-tassta.adb", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f57ad31792778dd585481c39f0deffef3aaa0a5/gcc%2Fada%2Fs-tassta.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f57ad31792778dd585481c39f0deffef3aaa0a5/gcc%2Fada%2Fs-tassta.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tassta.adb?ref=5f57ad31792778dd585481c39f0deffef3aaa0a5", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1992-2004, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2005, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -910,6 +910,13 @@ package body System.Tasking.Stages is\n \n       Secondary_Stack_Address : System.Address := Secondary_Stack'Address;\n \n+      SEH_Table : aliased SSE.Storage_Array (1 .. 8);\n+      --  Structured Exception Registration table (2 words)\n+\n+      procedure Install_SEH_Handler (Addr : System.Address);\n+      pragma Import (C, Install_SEH_Handler, \"__gnat_install_SEH_handler\");\n+      --  Install the SEH (Structured Exception Handling) handler\n+\n    begin\n       pragma Assert (Self_ID.Deferral_Level = 1);\n \n@@ -930,6 +937,11 @@ package body System.Tasking.Stages is\n \n       Enter_Task (Self_ID);\n \n+      --  We setup the SEH (Structured Exception Handling) handler if supported\n+      --  on the target.\n+\n+      Install_SEH_Handler (SEH_Table'Address);\n+\n       --  We lock RTS_Lock to wait for activator to finish activating\n       --  the rest of the chain, so that everyone in the chain comes out\n       --  in priority order."}, {"sha": "cf1ada8a497a20d3178f9c3fd9701ba36a252b2b", "filename": "gcc/ada/seh_init.c", "status": "added", "additions": 234, "deletions": 0, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f57ad31792778dd585481c39f0deffef3aaa0a5/gcc%2Fada%2Fseh_init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f57ad31792778dd585481c39f0deffef3aaa0a5/gcc%2Fada%2Fseh_init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fseh_init.c?ref=5f57ad31792778dd585481c39f0deffef3aaa0a5", "patch": "@@ -0,0 +1,234 @@\n+/****************************************************************************\n+ *                                                                          *\n+ *                         GNAT COMPILER COMPONENTS                         *\n+ *                                                                          *\n+ *                              S E H - I N I T                             *\n+ *                                                                          *\n+ *                          C Implementation File                           *\n+ *                                                                          *\n+ *             Copyright (C) 2005, Free Software Foundation, Inc.           *\n+ *                                                                          *\n+ * GNAT is free software;  you can  redistribute it  and/or modify it under *\n+ * terms of the  GNU General Public License as published  by the Free Soft- *\n+ * ware  Foundation;  either version 2,  or (at your option) any later ver- *\n+ * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n+ * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License *\n+ * for  more details.  You should have  received  a copy of the GNU General *\n+ * Public License  distributed with GNAT;  see file COPYING.  If not, write *\n+ * to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, *\n+ * MA 02111-1307, USA.                                                      *\n+ *                                                                          *\n+ * As a  special  exception,  if you  link  this file  with other  files to *\n+ * produce an executable,  this file does not by itself cause the resulting *\n+ * executable to be covered by the GNU General Public License. This except- *\n+ * ion does not  however invalidate  any other reasons  why the  executable *\n+ * file might be covered by the  GNU Public License.                        *\n+ *                                                                          *\n+ * GNAT was originally developed  by the GNAT team at  New York University. *\n+ * Extensive contributions were provided by Ada Core Technologies Inc.      *\n+ *                                                                          *\n+ ****************************************************************************/\n+\n+/*  This unit contains support for SEH (Structured Exception Handling).\n+    Right now the only implementation is for Win32.  */\n+\n+#ifdef IN_RTS\n+#include \"tconfig.h\"\n+#include \"tsystem.h\"\n+#include <sys/stat.h>\n+\n+/* We don't have libiberty, so us malloc.  */\n+#define xmalloc(S) malloc (S)\n+\n+#else\n+#include \"config.h\"\n+#include \"system.h\"\n+#endif\n+\n+#include \"raise.h\"\n+\n+/* Addresses of exception data blocks for predefined exceptions. */\n+extern struct Exception_Data constraint_error;\n+extern struct Exception_Data numeric_error;\n+extern struct Exception_Data program_error;\n+extern struct Exception_Data storage_error;\n+extern struct Exception_Data tasking_error;\n+extern struct Exception_Data _abort_signal;\n+\n+#define Raise_From_Signal_Handler \\\n+                      ada__exceptions__raise_from_signal_handler\n+extern void Raise_From_Signal_Handler (struct Exception_Data *, const char *);\n+\n+\n+#ifdef _WIN32\n+\n+#include <windows.h>\n+#include <excpt.h>\n+\n+extern void _global_unwind2 (void *);\n+\n+EXCEPTION_DISPOSITION __gnat_SEH_error_handler\n+(struct _EXCEPTION_RECORD*, void*, struct _CONTEXT*, void*);\n+\n+EXCEPTION_DISPOSITION\n+__gnat_SEH_error_handler (struct _EXCEPTION_RECORD* ExceptionRecord,\n+\t\t\t  void *EstablisherFrame,\n+\t\t\t  struct _CONTEXT* ContextRecord,\n+\t\t\t  void *DispatcherContext)\n+{\n+  struct Exception_Data *exception;\n+  const char *msg;\n+\n+  switch (ExceptionRecord->ExceptionCode)\n+    {\n+    case EXCEPTION_ACCESS_VIOLATION:\n+      /* If the failing address isn't maximally-aligned or if the page\n+\t before the faulting page is not accessible, this is a program error.\n+      */\n+      if ((ExceptionRecord->ExceptionInformation[1] & 3) != 0\n+\t  || IsBadCodePtr\n+\t  ((void *)(ExceptionRecord->ExceptionInformation[1] + 4096)))\n+\t{\n+\t  exception = &program_error;\n+\t  msg = \"EXCEPTION_ACCESS_VIOLATION\";\n+\t}\n+      else\n+\t{\n+\t  /* otherwise it is a stack overflow  */\n+\t  exception = &storage_error;\n+\t  msg = \"stack overflow (or erroneous memory access)\";\n+\t}\n+      break;\n+\n+    case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:\n+      exception = &constraint_error;\n+      msg = \"EXCEPTION_ARRAY_BOUNDS_EXCEEDED\";\n+      break;\n+\n+    case EXCEPTION_DATATYPE_MISALIGNMENT:\n+      exception = &constraint_error;\n+      msg = \"EXCEPTION_DATATYPE_MISALIGNMENT\";\n+      break;\n+\n+    case EXCEPTION_FLT_DENORMAL_OPERAND:\n+      exception = &constraint_error;\n+      msg = \"EXCEPTION_FLT_DENORMAL_OPERAND\";\n+      break;\n+\n+    case EXCEPTION_FLT_DIVIDE_BY_ZERO:\n+      exception = &constraint_error;\n+      msg = \"EXCEPTION_FLT_DENORMAL_OPERAND\";\n+      break;\n+\n+    case EXCEPTION_FLT_INVALID_OPERATION:\n+      exception = &constraint_error;\n+      msg = \"EXCEPTION_FLT_INVALID_OPERATION\";\n+      break;\n+\n+    case EXCEPTION_FLT_OVERFLOW:\n+      exception = &constraint_error;\n+      msg = \"EXCEPTION_FLT_OVERFLOW\";\n+      break;\n+\n+    case EXCEPTION_FLT_STACK_CHECK:\n+      exception = &program_error;\n+      msg = \"EXCEPTION_FLT_STACK_CHECK\";\n+      break;\n+\n+    case EXCEPTION_FLT_UNDERFLOW:\n+      exception = &constraint_error;\n+      msg = \"EXCEPTION_FLT_UNDERFLOW\";\n+      break;\n+\n+    case EXCEPTION_INT_DIVIDE_BY_ZERO:\n+      exception = &constraint_error;\n+      msg = \"EXCEPTION_INT_DIVIDE_BY_ZERO\";\n+      break;\n+\n+    case EXCEPTION_INT_OVERFLOW:\n+      exception = &constraint_error;\n+      msg = \"EXCEPTION_INT_OVERFLOW\";\n+      break;\n+\n+    case EXCEPTION_INVALID_DISPOSITION:\n+      exception = &program_error;\n+      msg = \"EXCEPTION_INVALID_DISPOSITION\";\n+      break;\n+\n+    case EXCEPTION_NONCONTINUABLE_EXCEPTION:\n+      exception = &program_error;\n+      msg = \"EXCEPTION_NONCONTINUABLE_EXCEPTION\";\n+      break;\n+\n+    case EXCEPTION_PRIV_INSTRUCTION:\n+      exception = &program_error;\n+      msg = \"EXCEPTION_PRIV_INSTRUCTION\";\n+      break;\n+\n+    case EXCEPTION_SINGLE_STEP:\n+      exception = &program_error;\n+      msg = \"EXCEPTION_SINGLE_STEP\";\n+      break;\n+\n+    case EXCEPTION_STACK_OVERFLOW:\n+      exception = &storage_error;\n+      msg = \"EXCEPTION_STACK_OVERFLOW\";\n+      break;\n+\n+   default:\n+      exception = &program_error;\n+      msg = \"unhandled signal\";\n+    }\n+\n+  /* This call is important as it avoids locking the second time we catch a\n+     signal. Note that this routine is documented as internal to Windows and\n+     should not be used.  */\n+\n+  _global_unwind2 (EstablisherFrame);\n+  /* Call equivalent to RtlUnwind (EstablisherFrame, NULL, NULL, 0); */\n+\n+  Raise_From_Signal_Handler (exception, msg);\n+  return 0; /* This is never reached, avoid compiler warning  */\n+}\n+\n+/*  Install the Win32 SEH exception handler. Note that the caller must have\n+    allocated 8 bytes on the stack and pass the pointer to this stack\n+    space. This is needed as the SEH exception handler must be on the stack of\n+    the thread.\n+\n+       int buf[2];\n+\n+       __gnat_install_SEH_handler ((void*)buf);\n+\n+       main();\n+\n+   This call must be done before calling the main procedure or the thread\n+   entry. The stack space must exists during all the main run.  */\n+\n+void\n+__gnat_install_SEH_handler (void *ER)\n+{\n+  int *ptr;\n+\n+  /* put current handler in ptr */\n+\n+  asm (\"mov %%fs:(0),%%ecx\" : : : \"%ecx\");\n+  asm (\"mov %%ecx,%0\" : \"=m\" (ptr));\n+\n+  ((int *)ER)[0] = (int)ptr;                       /* previous handler */\n+  ((int *)ER)[1] = (int)__gnat_SEH_error_handler;  /* new handler */\n+\n+  /* ptr is the new handler, set fs:(0) with this value */\n+\n+  ptr = (int *)ER;\n+  asm (\"mov %0,%%ecx\" : : \"m\" (ptr) : \"%ecx\");\n+  asm (\"mov %ecx,%fs:(0)\");\n+}\n+\n+#else /* _WIN32 */\n+/* For all non Windows targets we provide a dummy SEH install handler.  */\n+void __gnat_install_SEH_handler (void *eh ATTRIBUTE_UNUSED)\n+{\n+}\n+#endif"}]}