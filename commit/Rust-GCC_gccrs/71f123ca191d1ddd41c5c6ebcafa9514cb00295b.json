{"sha": "71f123ca191d1ddd41c5c6ebcafa9514cb00295b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzFmMTIzY2ExOTFkMWRkZDQxYzVjNmViY2FmYTk1MTRjYjAwMjk1Yg==", "commit": {"author": {"name": "Franz Sirl", "email": "Franz.Sirl-kernel@lauterbach.com", "date": "2001-01-22T22:47:25Z"}, "committer": {"name": "Franz Sirl", "email": "sirl@gcc.gnu.org", "date": "2001-01-22T22:47:25Z"}, "message": "rs6000.h (INIT_EXPANDERS): Delete.\n\n        2001-01-22  Franz Sirl  <Franz.Sirl-kernel@lauterbach.com>\n\n        * rs6000.h (INIT_EXPANDERS): Delete.\n        (RETURN_ADDR_RTX): Call rs6000_return_addr().\n        * rs6000.c (rs6000_override_options): Call *_machine_status from\n        here...\n        (rs6000_init_expanders): ...instead of here. Delete.\n        (rs6000_mark_machine_status): New function.\n        (rs6000_init_machine_status): Use xcalloc.\n        (rs6000_return_addr): Generate RTX for the return address.\n        (rs6000_ra_ever_killed): New, check if LR was ever destroyed.\n        (rs6000_stack_info): Use it.\n\nFrom-SVN: r39188", "tree": {"sha": "05102979db2027472e84ad31a59f9674ec41d5d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/05102979db2027472e84ad31a59f9674ec41d5d3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/71f123ca191d1ddd41c5c6ebcafa9514cb00295b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71f123ca191d1ddd41c5c6ebcafa9514cb00295b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71f123ca191d1ddd41c5c6ebcafa9514cb00295b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71f123ca191d1ddd41c5c6ebcafa9514cb00295b/comments", "author": {"login": "jinkama-san", "id": 1462162, "node_id": "MDQ6VXNlcjE0NjIxNjI=", "avatar_url": "https://avatars.githubusercontent.com/u/1462162?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jinkama-san", "html_url": "https://github.com/jinkama-san", "followers_url": "https://api.github.com/users/jinkama-san/followers", "following_url": "https://api.github.com/users/jinkama-san/following{/other_user}", "gists_url": "https://api.github.com/users/jinkama-san/gists{/gist_id}", "starred_url": "https://api.github.com/users/jinkama-san/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jinkama-san/subscriptions", "organizations_url": "https://api.github.com/users/jinkama-san/orgs", "repos_url": "https://api.github.com/users/jinkama-san/repos", "events_url": "https://api.github.com/users/jinkama-san/events{/privacy}", "received_events_url": "https://api.github.com/users/jinkama-san/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5dab7f92ce35e0e3591e6dda28977da4949411ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5dab7f92ce35e0e3591e6dda28977da4949411ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5dab7f92ce35e0e3591e6dda28977da4949411ac"}], "stats": {"total": 135, "additions": 103, "deletions": 32}, "files": [{"sha": "26d488d35186f565e579ae29df3d3716af229c47", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71f123ca191d1ddd41c5c6ebcafa9514cb00295b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71f123ca191d1ddd41c5c6ebcafa9514cb00295b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=71f123ca191d1ddd41c5c6ebcafa9514cb00295b", "patch": "@@ -1,3 +1,16 @@\n+2001-01-22  Franz Sirl  <Franz.Sirl-kernel@lauterbach.com>\n+\n+\t* rs6000.h (INIT_EXPANDERS): Delete.\n+\t(RETURN_ADDR_RTX): Call rs6000_return_addr().\n+\t* rs6000.c (rs6000_override_options): Call *_machine_status from\n+\there...\n+\t(rs6000_init_expanders): ...instead of here. Delete.\n+\t(rs6000_mark_machine_status): New function.\n+\t(rs6000_init_machine_status): Use xcalloc.\n+\t(rs6000_return_addr): Generate RTX for the return address.\n+\t(rs6000_ra_ever_killed): New, check if LR was ever destroyed.\n+\t(rs6000_stack_info): Use it.\n+\n 2001-01-22  Thomas Pfaff  <tpfaff@gmx.net>\n \n \t* gthr-win32.h: Include errno.h to get a declaration for"}, {"sha": "3fa0e0a43c1b951e9017931e0d612be96ebb4f88", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 80, "deletions": 17, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71f123ca191d1ddd41c5c6ebcafa9514cb00295b/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71f123ca191d1ddd41c5c6ebcafa9514cb00295b/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=71f123ca191d1ddd41c5c6ebcafa9514cb00295b", "patch": "@@ -122,6 +122,8 @@ static void toc_hash_mark_table PARAMS ((void *));\n static int constant_pool_expr_1 PARAMS ((rtx, int *, int *));\n static void rs6000_free_machine_status PARAMS ((struct function *));\n static void rs6000_init_machine_status PARAMS ((struct function *));\n+static void rs6000_mark_machine_status PARAMS ((struct function *));\n+static int rs6000_ra_ever_killed PARAMS ((void));\n \f\n /* Default register names.  */\n char rs6000_reg_names[][8] =\n@@ -399,6 +401,11 @@ rs6000_override_options (default_cpu)\n \n   if (TARGET_TOC) \n     ASM_GENERATE_INTERNAL_LABEL (toc_label_name, \"LCTOC\", 1);\n+\n+  /* Arrange to save and restore machine status around nested functions.  */\n+  init_machine_status = rs6000_init_machine_status;\n+  mark_machine_status = rs6000_mark_machine_status;\n+  free_machine_status = rs6000_free_machine_status;\n }\n \n void\n@@ -3619,17 +3626,23 @@ rs6000_got_register (value)\n   return pic_offset_table_rtx;\n }\n \f\n-/* Functions to save and restore sysv_varargs_p.\n+/* Functions to init, mark and free struct machine_function.\n    These will be called, via pointer variables,\n    from push_function_context and pop_function_context.  */\n \n static void\n rs6000_init_machine_status (p)\n      struct function *p;\n {\n-  p->machine = (machine_function *) xmalloc (sizeof (machine_function));\n+  p->machine = (machine_function *) xcalloc (1, sizeof (machine_function));\n+}\n \n-  p->machine->sysv_varargs_p = 0;\n+static void\n+rs6000_mark_machine_status (p)\n+     struct function *p;\n+{\n+  if (p->machine)\n+    ggc_mark_rtx (p->machine->ra_rtx);\n }\n \n static void\n@@ -3643,17 +3656,6 @@ rs6000_free_machine_status (p)\n   p->machine = NULL;\n }\n \n-\n-/* Do anything needed before RTL is emitted for each function.  */\n-\n-void\n-rs6000_init_expanders ()\n-{\n-  /* Arrange to save and restore machine status around nested functions.  */\n-  init_machine_status = rs6000_init_machine_status;\n-  free_machine_status = rs6000_free_machine_status;\n-}\n-\n \f\n /* Print an operand.  Recognize special options, documented below.  */\n \n@@ -4824,10 +4826,11 @@ rs6000_stack_info ()\n   info_ptr->fp_size = 8 * (64 - info_ptr->first_fp_reg_save);\n \n   /* Does this function call anything? */\n-  info_ptr->calls_p = ! current_function_is_leaf;\n+  info_ptr->calls_p = (! current_function_is_leaf\n+\t\t       || cfun->machine->ra_needs_full_frame);\n \n   /* Determine if we need to save the link register */\n-  if (regs_ever_live[LINK_REGISTER_REGNUM]\n+  if (rs6000_ra_ever_killed ()\n       || (DEFAULT_ABI == ABI_AIX && profile_flag)\n #ifdef TARGET_RELOCATABLE\n       || (TARGET_RELOCATABLE && (get_pool_size () != 0))\n@@ -5043,6 +5046,66 @@ debug_stack_info (info)\n \n   fprintf (stderr, \"\\n\");\n }\n+\n+rtx\n+rs6000_return_addr (count, frame)\n+     int count;\n+     rtx frame;\n+{\n+  rtx init, reg;\n+\n+  /* Currently we don't optimize very well between prolog and body code and\n+     for PIC code the code can be actually quite bad, so don't try to be\n+     too clever here.  */\n+  if (count != 0 || flag_pic != 0)\n+    {\n+      cfun->machine->ra_needs_full_frame = 1;\n+      return\n+\tgen_rtx_MEM (Pmode,\n+\t  memory_address (Pmode,\n+\t\t\t  plus_constant (copy_to_reg (gen_rtx_MEM (Pmode,\n+\t\t\t\t\t\t\t\t   memory_address (Pmode, frame))),\n+\t\t\t\t\t RETURN_ADDRESS_OFFSET)));\n+    }\n+\n+  reg = cfun->machine->ra_rtx;\n+  if (reg == NULL)\n+    {\n+      /* No rtx yet.  Invent one, and initialize it from LR in\n+         the prologue.  */\n+      reg = gen_reg_rtx (Pmode);\n+      cfun->machine->ra_rtx = reg;\n+      init = gen_rtx_SET (VOIDmode, reg,\n+\t\t\t  gen_rtx_REG (Pmode, LINK_REGISTER_REGNUM));\n+\n+      /* Emit the insn to the prologue with the other argument copies.  */\n+      push_topmost_sequence ();\n+      emit_insn_after (init, get_insns ());\n+      pop_topmost_sequence ();\n+    }\n+\n+  return reg;\n+}\n+\n+static int\n+rs6000_ra_ever_killed ()\n+{\n+  rtx top;\n+\n+#ifdef ASM_OUTPUT_MI_THUNK\n+  if (current_function_is_thunk)\n+    return 0;\n+#endif\n+  if (!cfun->machine->ra_rtx || cfun->machine->ra_needs_full_frame)\n+    return regs_ever_live[LINK_REGISTER_REGNUM];\n+\n+  push_topmost_sequence ();\n+  top = get_insns ();\n+  pop_topmost_sequence ();\n+\n+  return reg_set_between_p (gen_rtx_REG (Pmode, LINK_REGISTER_REGNUM), \n+\t\t\t    top, NULL_RTX);\n+}\n \f\n /* Add a REG_MAYBE_DEAD note to the insn.  */\n static void\n@@ -5553,7 +5616,7 @@ rs6000_emit_prologue()\n \n   /* If we use the link register, get it into r0.  */\n   if (info->lr_save_p)\n-    emit_move_insn (gen_rtx_REG (Pmode, 0), \n+    emit_move_insn (gen_rtx_REG (Pmode, 0),\n \t\t    gen_rtx_REG (Pmode, LINK_REGISTER_REGNUM));\n \n   /* If we need to save CR, put it into r12.  */"}, {"sha": "54e987424e4a7ff095aac2ffaf5ad9d83dfcb7ad", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71f123ca191d1ddd41c5c6ebcafa9514cb00295b/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71f123ca191d1ddd41c5c6ebcafa9514cb00295b/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=71f123ca191d1ddd41c5c6ebcafa9514cb00295b", "patch": "@@ -1229,10 +1229,6 @@ typedef struct rs6000_stack {\n /* Align an address */\n #define RS6000_ALIGN(n,a) (((n) + (a) - 1) & ~((a) - 1))\n \n-/* Initialize data used by insn expanders.  This is called from\n-   init_emit, once for each function, before code is generated. */\n-#define INIT_EXPANDERS rs6000_init_expanders ()\n-\n /* Size of V.4 varargs area in bytes */\n #define RS6000_VARARGS_SIZE \\\n   ((GP_ARG_NUM_REG * (TARGET_32BIT ? 4 : 8)) + (FP_ARG_NUM_REG * 8) + 8)\n@@ -1388,6 +1384,10 @@ typedef struct machine_function\n {\n   /* Whether a System V.4 varargs area was created.  */\n   int sysv_varargs_p;\n+  /* Set if a return address rtx for loading from LR was created.  */\n+  struct rtx_def *ra_rtx;\n+  /* Flags if __builtin_return_address (n) with n >= 1 was used.  */\n+  int ra_needs_full_frame;\n } machine_function;\n \n /* Define a data type for recording info about an argument list\n@@ -1649,17 +1649,12 @@ typedef struct rs6000_args\n /* The current return address is in link register (65).  The return address\n    of anything farther back is accessed normally at an offset of 8 from the\n    frame pointer.  */\n-#define RETURN_ADDR_RTX(COUNT, FRAME)\t\t\t\\\n-  (((COUNT) == -1)\t\t\t\t\t\\\n-   ? gen_rtx_REG (Pmode, LINK_REGISTER_REGNUM)\t\t\\\n-   : gen_rtx_MEM (Pmode,\t\t\t\t\\\n-\t\t  memory_address\t\t\t\\\n-\t\t  (Pmode, \t\t\t\t\\\n-\t\t   plus_constant (copy_to_reg\t\t\\\n-\t\t\t\t  (gen_rtx_MEM (Pmode,\t\\\n-\t\t\t\t\t\tmemory_address (Pmode, \\\n-\t\t\t\t\t\t\t\t(FRAME)))), \\\n-\t\t\t\t  RETURN_ADDRESS_OFFSET))))\n+#define RETURN_ADDR_RTX(COUNT, FRAME)                 \\\n+  (rs6000_return_addr (COUNT, FRAME))\n+\n+extern struct rtx_def* rs6000_return_addr (int, struct rtx_def *rtx);\n+\n+\n \f\n /* Definitions for register eliminations.\n "}]}