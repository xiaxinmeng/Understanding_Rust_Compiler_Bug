{"sha": "4ab74a01477d4089a3474d52479ed372c9b5ae29", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGFiNzRhMDE0NzdkNDA4OWEzNDc0ZDUyNDc5ZWQzNzJjOWI1YWUyOQ==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2014-11-14T20:06:11Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2014-11-14T20:06:11Z"}, "message": "lra-int.h (lra_create_live_ranges): Add parameter.\n\n2014-11-14  Vladimir Makarov  <vmakarov@redhat.com>\n\n\t* lra-int.h (lra_create_live_ranges): Add parameter.\n\t* lra-lives.c (temp_bitmap): Move higher.\n\t(initiate_live_solver): Move temp_bitmap initialization into\n\tlra_live_ranges_init.\n\t(finish_live_solver): Move temp_bitmap clearing into\n\tlive_ranges_finish.\n\t(process_bb_lives): Add parameter.  Use it to control live info\n\tupdate and dead insn elimination.  Pass it to mark_regno_live and\n\tmark_regno_dead.\n\t(lra_create_live_ranges): Add parameter.  Pass it to\n\tprocess_bb_lives.\n\t(lra_live_ranges_init, lra_live_ranges_finish): See changes in\n\tinitiate_live_solver and finish_live_solver.\n\t* lra-remat.c (do_remat): Process insn non-operand hard regs too.\n\tUse temp_bitmap to update avail_cands.\n\t* lra.c (lra): Pass new parameter to lra_create_live_ranges.  Move\n\tcheck with lra_need_for_spill_p after live range pass.  Switch on\n\trematerialization pass.\n\nFrom-SVN: r217588", "tree": {"sha": "bca0d7e49464e99d894d55c93bb521b4d91d4e18", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bca0d7e49464e99d894d55c93bb521b4d91d4e18"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4ab74a01477d4089a3474d52479ed372c9b5ae29", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ab74a01477d4089a3474d52479ed372c9b5ae29", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ab74a01477d4089a3474d52479ed372c9b5ae29", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ab74a01477d4089a3474d52479ed372c9b5ae29/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "44210a9672aed3212c0e289dddc5bd38c314290b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44210a9672aed3212c0e289dddc5bd38c314290b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44210a9672aed3212c0e289dddc5bd38c314290b"}], "stats": {"total": 165, "additions": 113, "deletions": 52}, "files": [{"sha": "54610b69667aecf1332853d70b8a16fa85de0819", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ab74a01477d4089a3474d52479ed372c9b5ae29/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ab74a01477d4089a3474d52479ed372c9b5ae29/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4ab74a01477d4089a3474d52479ed372c9b5ae29", "patch": "@@ -1,3 +1,24 @@\n+2014-11-14  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* lra-int.h (lra_create_live_ranges): Add parameter.\n+\t* lra-lives.c (temp_bitmap): Move higher.\n+\t(initiate_live_solver): Move temp_bitmap initialization into\n+\tlra_live_ranges_init.\n+\t(finish_live_solver): Move temp_bitmap clearing into\n+\tlive_ranges_finish.\n+\t(process_bb_lives): Add parameter.  Use it to control live info\n+\tupdate and dead insn elimination.  Pass it to mark_regno_live and\n+\tmark_regno_dead.\n+\t(lra_create_live_ranges): Add parameter.  Pass it to\n+\tprocess_bb_lives.\n+\t(lra_live_ranges_init, lra_live_ranges_finish): See changes in\n+\tinitiate_live_solver and finish_live_solver.\n+\t* lra-remat.c (do_remat): Process insn non-operand hard regs too.\n+\tUse temp_bitmap to update avail_cands.\n+\t* lra.c (lra): Pass new parameter to lra_create_live_ranges.  Move\n+\tcheck with lra_need_for_spill_p after live range pass.  Switch on\n+\trematerialization pass.\n+\n 2014-11-14  Martin Jambor  <mjambor@suse.cz>\n \n \t* ipa-prop.h (ipa_get_jf_pass_through_type_preserved): use"}, {"sha": "9422afcbe55fce40d8d9b538222d120268ec4e45", "filename": "gcc/lra-int.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ab74a01477d4089a3474d52479ed372c9b5ae29/gcc%2Flra-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ab74a01477d4089a3474d52479ed372c9b5ae29/gcc%2Flra-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-int.h?ref=4ab74a01477d4089a3474d52479ed372c9b5ae29", "patch": "@@ -353,7 +353,7 @@ extern int *lra_point_freq;\n extern int lra_hard_reg_usage[FIRST_PSEUDO_REGISTER];\n \n extern int lra_live_range_iter;\n-extern void lra_create_live_ranges (bool);\n+extern void lra_create_live_ranges (bool, bool);\n extern lra_live_range_t lra_copy_live_range_list (lra_live_range_t);\n extern lra_live_range_t lra_merge_live_ranges (lra_live_range_t,\n \t\t\t\t\t       lra_live_range_t);"}, {"sha": "5868be86e372229d4346b2645ad3b5a7d508110c", "filename": "gcc/lra-lives.c", "status": "modified", "additions": 49, "deletions": 39, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ab74a01477d4089a3474d52479ed372c9b5ae29/gcc%2Flra-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ab74a01477d4089a3474d52479ed372c9b5ae29/gcc%2Flra-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-lives.c?ref=4ab74a01477d4089a3474d52479ed372c9b5ae29", "patch": "@@ -100,6 +100,9 @@ static sparseset start_living, start_dying;\n    insn.  */\n static sparseset unused_set, dead_set;\n \n+/* Bitmap used for holding intermediate bitmap operation results.  */\n+static bitmap_head temp_bitmap;\n+\n /* Pool for pseudo live ranges.\t */\n static alloc_pool live_range_pool;\n \n@@ -420,9 +423,6 @@ get_bb_data_by_index (int index)\n /* Bitmap with all hard regs.  */\n static bitmap_head all_hard_regs_bitmap;\n \n-/* Bitmap used for holding intermediate bitmap operation results.  */\n-static bitmap_head temp_bitmap;\n-\n /* The transfer function used by the DF equation solver to propagate\n    live info through block with BB_INDEX according to the following\n    equation:\n@@ -476,7 +476,6 @@ static bitmap_head all_blocks;\n static void\n initiate_live_solver (void)\n {\n-  bitmap_initialize (&temp_bitmap, &reg_obstack);\n   bitmap_initialize (&all_hard_regs_bitmap, &reg_obstack);\n   bitmap_set_range (&all_hard_regs_bitmap, 0, FIRST_PSEUDO_REGISTER);\n   bb_data = XNEWVEC (struct bb_data_pseudos, last_basic_block_for_fn (cfun));\n@@ -508,7 +507,6 @@ finish_live_solver (void)\n     }\n   free (bb_data);\n   bitmap_clear (&all_hard_regs_bitmap);\n-  bitmap_clear (&temp_bitmap);\n }\n \n \f\n@@ -640,10 +638,11 @@ check_pseudos_live_through_calls (int regno)\n    backward scan of BB insns.  CURR_POINT is the program point where\n    BB ends.  The function updates this counter and returns in\n    CURR_POINT the program point where BB starts.  The function also\n-   can delete the dead insns.  It returns true if pseudo live info was\n+   does local live info updates and can delete the dead insns if\n+   GLOBAL_LIVE_INFO_P.  It returns true if pseudo live info was\n    changed at the BB start.  */\n static bool\n-process_bb_lives (basic_block bb, int &curr_point)\n+process_bb_lives (basic_block bb, int &curr_point, bool global_live_info_p)\n {\n   int i, regno, freq;\n   unsigned int j;\n@@ -663,11 +662,13 @@ process_bb_lives (basic_block bb, int &curr_point)\n   EXECUTE_IF_SET_IN_BITMAP (reg_live_out, FIRST_PSEUDO_REGISTER, j, bi)\n     mark_pseudo_live (j, curr_point);\n \n-  bb_gen_pseudos = &get_bb_data (bb)->gen_pseudos;\n-  bb_killed_pseudos = &get_bb_data (bb)->killed_pseudos;\n-  bitmap_clear (bb_gen_pseudos);\n-  bitmap_clear (bb_killed_pseudos);\n-\n+  if (global_live_info_p)\n+    {\n+      bb_gen_pseudos = &get_bb_data (bb)->gen_pseudos;\n+      bb_killed_pseudos = &get_bb_data (bb)->killed_pseudos;\n+      bitmap_clear (bb_gen_pseudos);\n+      bitmap_clear (bb_killed_pseudos);\n+    }\n   freq = REG_FREQ_FROM_BB (bb);\n \n   if (lra_dump_file != NULL)\n@@ -700,7 +701,7 @@ process_bb_lives (basic_block bb, int &curr_point)\n \n       set = single_set (curr_insn);\n \n-      if (set != NULL_RTX\n+      if (global_live_info_p && set != NULL_RTX\n \t  && REG_P (SET_DEST (set)) && REGNO (SET_DEST (set)) >= FIRST_PSEUDO_REGISTER\n \t  && find_reg_note (curr_insn, REG_EH_REGION, NULL_RTX) == NULL_RTX\n \t  && ! may_trap_p (PATTERN (curr_insn))\n@@ -736,8 +737,8 @@ process_bb_lives (basic_block bb, int &curr_point)\n \t\t  unsigned int uid;\n \t\t  rtx_insn *insn;\n \n-\t\t  EXECUTE_IF_SET_IN_BITMAP\n-\t\t    (&lra_reg_info[dst_regno].insn_bitmap, 0, uid, bi)\n+\t\t  bitmap_copy (&temp_bitmap, &lra_reg_info[dst_regno].insn_bitmap);\n+\t\t  EXECUTE_IF_SET_IN_BITMAP (&temp_bitmap, 0, uid, bi)\n \t\t    {\n \t\t      insn = lra_insn_recog_data[uid]->insn;\n \t\t      lra_substitute_pseudo_within_insn (insn, dst_regno,\n@@ -815,9 +816,9 @@ process_bb_lives (basic_block bb, int &curr_point)\n       for (reg = curr_id->regs; reg != NULL; reg = reg->next)\n \tif (reg->type != OP_IN)\n \t  {\n-\t    need_curr_point_incr |= mark_regno_live (reg->regno,\n-\t\t\t\t\t\t     reg->biggest_mode,\n-\t\t\t\t\t\t     curr_point, true);\n+\t    need_curr_point_incr\n+\t      |= mark_regno_live (reg->regno, reg->biggest_mode,\n+\t\t\t\t  curr_point, global_live_info_p);\n \t    check_pseudos_live_through_calls (reg->regno);\n \t  }\n \n@@ -832,9 +833,9 @@ process_bb_lives (basic_block bb, int &curr_point)\n       /* See which defined values die here.  */\n       for (reg = curr_id->regs; reg != NULL; reg = reg->next)\n \tif (reg->type == OP_OUT && ! reg->early_clobber && ! reg->subreg_p)\n-\t  need_curr_point_incr |= mark_regno_dead (reg->regno,\n-\t\t\t\t\t\t   reg->biggest_mode,\n-\t\t\t\t\t\t   curr_point, true);\n+\t  need_curr_point_incr\n+\t    |= mark_regno_dead (reg->regno, reg->biggest_mode,\n+\t\t\t\tcurr_point, global_live_info_p);\n \n       for (reg = curr_static_id->hard_regs; reg != NULL; reg = reg->next)\n \tif (reg->type == OP_OUT && ! reg->early_clobber && ! reg->subreg_p)\n@@ -874,9 +875,9 @@ process_bb_lives (basic_block bb, int &curr_point)\n       for (reg = curr_id->regs; reg != NULL; reg = reg->next)\n \tif (reg->type == OP_IN)\n \t  {\n-\t    need_curr_point_incr |= mark_regno_live (reg->regno,\n-\t\t\t\t\t\t     reg->biggest_mode,\n-\t\t\t\t\t\t     curr_point, true);\n+\t    need_curr_point_incr\n+\t      |= mark_regno_live (reg->regno, reg->biggest_mode,\n+\t\t\t\t  curr_point, global_live_info_p);\n \t    check_pseudos_live_through_calls (reg->regno);\n \t  }\n \n@@ -894,9 +895,9 @@ process_bb_lives (basic_block bb, int &curr_point)\n       /* Mark early clobber outputs dead.  */\n       for (reg = curr_id->regs; reg != NULL; reg = reg->next)\n \tif (reg->type == OP_OUT && reg->early_clobber && ! reg->subreg_p)\n-\t  need_curr_point_incr |= mark_regno_dead (reg->regno,\n-\t\t\t\t\t\t   reg->biggest_mode,\n-\t\t\t\t\t\t   curr_point, true);\n+\t  need_curr_point_incr\n+\t    |= mark_regno_dead (reg->regno, reg->biggest_mode,\n+\t\t\t\tcurr_point, global_live_info_p);\n \n       for (reg = curr_static_id->hard_regs; reg != NULL; reg = reg->next)\n \tif (reg->type == OP_OUT && reg->early_clobber && ! reg->subreg_p)\n@@ -969,19 +970,25 @@ process_bb_lives (basic_block bb, int &curr_point)\n \t    make_hard_regno_born (px);\n     }\n \n-  /* Check if bb border live info was changed.  */\n-  unsigned int live_pseudos_num = 0;\n   bool live_change_p = false;\n-  EXECUTE_IF_SET_IN_BITMAP (df_get_live_in (bb), FIRST_PSEUDO_REGISTER, j, bi)\n+  if (global_live_info_p)\n     {\n-      live_pseudos_num++;\n-      if (! sparseset_bit_p (pseudos_live, j))\n+      /* Check if bb border live info was changed.  */\n+      unsigned int live_pseudos_num = 0;\n+      EXECUTE_IF_SET_IN_BITMAP (df_get_live_in (bb),\n+\t\t\t\tFIRST_PSEUDO_REGISTER, j, bi)\n \t{\n-\t  live_change_p = TRUE;\n-\t  break;\n+\t  live_pseudos_num++;\n+\t  if (! sparseset_bit_p (pseudos_live, j))\n+\t    {\n+\t      live_change_p = TRUE;\n+\t      break;\n+\t    }\n \t}\n+      live_change_p\n+\t= (live_change_p\n+\t   || sparseset_cardinality (pseudos_live) != live_pseudos_num);\n     }\n-  live_change_p = live_change_p || sparseset_cardinality (pseudos_live) != live_pseudos_num;\n \n   /* See if we'll need an increment at the end of this basic block.\n      An increment is needed if the PSEUDOS_LIVE set is not empty,\n@@ -1175,10 +1182,11 @@ int lra_live_range_iter;\n \n /* The main entry function creates live ranges only for memory pseudos\n    (or for all ones if ALL_P), set up CONFLICT_HARD_REGS for the\n-   pseudos.  It also does global live analysis only for pseudos and\n-   only if the pseudo live info was changed on a BB border.  */\n+   pseudos.  It also does dead insn elimination and global live\n+   analysis only for pseudos and only if GLOBAL_LIVE_INFO_P and the\n+   pseudo live info was changed on a BB border.  */\n void\n-lra_create_live_ranges (bool all_p)\n+lra_create_live_ranges (bool all_p, bool global_live_info_p)\n {\n   basic_block bb;\n   int i, hard_regno, max_regno = max_reg_num ();\n@@ -1254,7 +1262,7 @@ lra_create_live_ranges (bool all_p)\n       if (bb == EXIT_BLOCK_PTR_FOR_FN (cfun) || bb\n \t  == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n \tcontinue;\n-      if (process_bb_lives (bb, curr_point))\n+      if (process_bb_lives (bb, curr_point, global_live_info_p))\n \tbb_live_change_p = true;\n     }\n   if (bb_live_change_p)\n@@ -1328,6 +1336,7 @@ lra_live_ranges_init (void)\n {\n   live_range_pool = create_alloc_pool (\"live ranges\",\n \t\t\t\t       sizeof (struct lra_live_range), 100);\n+  bitmap_initialize (&temp_bitmap, &reg_obstack);\n   initiate_live_solver ();\n }\n \n@@ -1336,5 +1345,6 @@ void\n lra_live_ranges_finish (void)\n {\n   finish_live_solver ();\n+  bitmap_clear (&temp_bitmap);\n   free_alloc_pool (live_range_pool);\n }"}, {"sha": "f638a1d87407d284b74c3724568054ba14ff0229", "filename": "gcc/lra-remat.c", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ab74a01477d4089a3474d52479ed372c9b5ae29/gcc%2Flra-remat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ab74a01477d4089a3474d52479ed372c9b5ae29/gcc%2Flra-remat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-remat.c?ref=4ab74a01477d4089a3474d52479ed372c9b5ae29", "patch": "@@ -1026,6 +1026,7 @@ do_remat (void)\n \t    continue;\n \n \t  lra_insn_recog_data_t id = lra_get_insn_recog_data (insn);\n+\t  struct lra_static_insn_data *static_id = id->insn_static_data;\n \t  struct lra_insn_reg *reg;\n \t  cand_t cand;\n \t  unsigned int cid;\n@@ -1059,7 +1060,10 @@ do_remat (void)\n \t  HOST_WIDE_INT cand_sp_offset = 0;\n \t  if (cand != NULL)\n \t    {\n-\t      lra_insn_recog_data_t cand_id = lra_get_insn_recog_data (cand->insn);\n+\t      lra_insn_recog_data_t cand_id\n+\t\t= lra_get_insn_recog_data (cand->insn);\n+\t      struct lra_static_insn_data *static_cand_id\n+\t\t= cand_id->insn_static_data;\n \t      rtx saved_op = *cand_id->operand_loc[cand->nop];\n \n \t      /* Check clobbers do not kill something living.  */\n@@ -1078,6 +1082,16 @@ do_remat (void)\n \t\t      break;\n \t\t  }\n \n+\t      if (reg == NULL)\n+\t\t{\n+\t\t  for (reg = static_cand_id->hard_regs;\n+\t\t       reg != NULL;\n+\t\t       reg = reg->next)\n+\t\t    if (reg->type != OP_IN\n+\t\t\t&& TEST_HARD_REG_BIT (live_hard_regs, reg->regno))\n+\t\t      break;\n+\t\t}\n+\n \t      if (reg == NULL)\n \t\t{\n \t\t  *cand_id->operand_loc[cand->nop] = SET_DEST (set);\n@@ -1100,6 +1114,7 @@ do_remat (void)\n \t\t}\n \t    }\n \n+\t  bitmap_clear (&temp_bitmap);\n \t  /* Update avail_cands (see analogous code for\n \t     calculate_gen_cands).  */\n \t  for (reg = id->regs; reg != NULL; reg = reg->next)\n@@ -1115,7 +1130,7 @@ do_remat (void)\n \t\t    continue;\n \t\t  if (cand->regno == reg->regno\n \t\t      || input_regno_present_p (cand->insn, reg->regno))\n-\t\t    bitmap_clear_bit (&avail_cands, cand->index);\n+\t\t    bitmap_set_bit (&temp_bitmap, cand->index);\n \t\t}\n \n \t  if (CALL_P (insn))\n@@ -1124,9 +1139,10 @@ do_remat (void)\n \t\tcand = all_cands[cid];\n \t\t\n \t\tif (call_used_input_regno_present_p (cand->insn))\n-\t\t  bitmap_clear_bit (&avail_cands, cand->index);\n+\t\t  bitmap_set_bit (&temp_bitmap, cand->index);\n \t      }\n \n+\t  bitmap_and_compl_into (&avail_cands, &temp_bitmap);\n \t  if ((cand = insn_to_cand[INSN_UID (insn)]) != NULL)\n \t    bitmap_set_bit (&avail_cands, cand->index);\n \t    \n@@ -1160,6 +1176,15 @@ do_remat (void)\n \t\tfor (i = 0; i < nregs; i++)\n \t\t  SET_HARD_REG_BIT (live_hard_regs, hard_regno + i);\n \t      }\n+\t  /* Process also hard regs (e.g. CC register) which are part\n+\t     of insn definition.  */\n+\t  for (reg = static_id->hard_regs; reg != NULL; reg = reg->next)\n+\t    if (reg->type == OP_IN\n+\t\t&& find_regno_note (insn, REG_DEAD, reg->regno) != NULL)\n+\t      CLEAR_HARD_REG_BIT (live_hard_regs, reg->regno);\n+\t    else if (reg->type != OP_IN\n+\t\t     && find_regno_note (insn, REG_UNUSED, reg->regno) == NULL)\n+\t      SET_HARD_REG_BIT (live_hard_regs, reg->regno);\n \t}\n     }\n   bitmap_clear (&avail_cands);"}, {"sha": "9309d5e44c2c7658c598892ab65f44aef3143a8f", "filename": "gcc/lra.c", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ab74a01477d4089a3474d52479ed372c9b5ae29/gcc%2Flra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ab74a01477d4089a3474d52479ed372c9b5ae29/gcc%2Flra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.c?ref=4ab74a01477d4089a3474d52479ed372c9b5ae29", "patch": "@@ -2296,14 +2296,17 @@ lra (FILE *f)\n \t\t  /* As a side-effect of lra_create_live_ranges, we calculate\n \t\t     actual_call_used_reg_set,  which is needed during\n \t\t     lra_inheritance.  */\n-\t\t  lra_create_live_ranges (true);\n+\t\t  lra_create_live_ranges (true, true);\n \t\t}\n \t      lra_inheritance ();\n \t    }\n \t  if (live_p)\n \t    lra_clear_live_ranges ();\n-\t  /* We need live ranges for lra_assign -- so build them.  */\n-\t  lra_create_live_ranges (true);\n+\t  /* We need live ranges for lra_assign -- so build them.  But\n+\t     don't remove dead insns or change global live info as we\n+\t     can undo inheritance transformations after inheritance\n+\t     pseudo assigning.  */\n+\t  lra_create_live_ranges (true, false);\n \t  live_p = true;\n \t  /* If we don't spill non-reload and non-inheritance pseudos,\n \t     there is no sense to run memory-memory move coalescing.\n@@ -2322,7 +2325,7 @@ lra (FILE *f)\n \t\t{\n \t\t  if (! live_p)\n \t\t    {\n-\t\t      lra_create_live_ranges (true);\n+\t\t      lra_create_live_ranges (true, true);\n \t\t      live_p = true;\n \t\t    }\n \t\t  if (lra_coalesce ())\n@@ -2338,21 +2341,23 @@ lra (FILE *f)\n       bitmap_clear (&lra_subreg_reload_pseudos);\n       bitmap_clear (&lra_inheritance_pseudos);\n       bitmap_clear (&lra_split_regs);\n-      if (! lra_need_for_spills_p ())\n-\tbreak;\n       if (! live_p)\n \t{\n \t  /* We need full live info for spilling pseudos into\n \t     registers instead of memory.  */\n-\t  lra_create_live_ranges (lra_reg_spill_p);\n+\t  lra_create_live_ranges (lra_reg_spill_p, true);\n \t  live_p = true;\n \t}\n+      /* We should check necessity for spilling here as the above live\n+\t range pass can remove spilled pseudos.  */\n+      if (! lra_need_for_spills_p ())\n+\tbreak;\n       /* Now we know what pseudos should be spilled.  Try to\n \t rematerialize them first.  */\n-      if (0 && lra_remat ())\n+      if (lra_remat ())\n \t{\n \t  /* We need full live info -- see the comment above.  */\n-\t  lra_create_live_ranges (lra_reg_spill_p);\n+\t  lra_create_live_ranges (lra_reg_spill_p, true);\n \t  live_p = true;\n \t  if (! lra_need_for_spills_p ())\n \t    break;"}]}