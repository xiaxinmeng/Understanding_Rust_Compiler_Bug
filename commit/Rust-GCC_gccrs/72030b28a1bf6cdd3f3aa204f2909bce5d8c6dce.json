{"sha": "72030b28a1bf6cdd3f3aa204f2909bce5d8c6dce", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzIwMzBiMjhhMWJmNmNkZDNmM2FhMjA0ZjI5MDliY2U1ZDhjNmRjZQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2015-12-15T14:17:27Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2015-12-15T14:17:27Z"}, "message": "Remove vestigial traces of std::tr1::bind\n\n\t* include/std/functional (is_placeholder, is_bind_expression): Update\n\tcomments.\n\t(_Safe_tuple_element): Replace with _Safe_tuple_element_t alias\n\ttemplate.\n\t(_Mu): Remove vestigial TR1 return types and update coments.\n\nFrom-SVN: r231653", "tree": {"sha": "9b5b23d4117c50cd9d2715e6ccb6ba89258b6e11", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9b5b23d4117c50cd9d2715e6ccb6ba89258b6e11"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/72030b28a1bf6cdd3f3aa204f2909bce5d8c6dce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72030b28a1bf6cdd3f3aa204f2909bce5d8c6dce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72030b28a1bf6cdd3f3aa204f2909bce5d8c6dce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72030b28a1bf6cdd3f3aa204f2909bce5d8c6dce/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6666731254089eadcc09361ff815d0de80516c6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6666731254089eadcc09361ff815d0de80516c6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6666731254089eadcc09361ff815d0de80516c6d"}], "stats": {"total": 104, "additions": 31, "deletions": 73}, "files": [{"sha": "507c02fcaa95d6ecf54cded047709541f4483182", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72030b28a1bf6cdd3f3aa204f2909bce5d8c6dce/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72030b28a1bf6cdd3f3aa204f2909bce5d8c6dce/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=72030b28a1bf6cdd3f3aa204f2909bce5d8c6dce", "patch": "@@ -1,5 +1,11 @@\n 2015-12-15  Jonathan Wakely  <jwakely@redhat.com>\n \n+\t* include/std/functional (is_placeholder, is_bind_expression): Update\n+\tcomments.\n+\t(_Safe_tuple_element): Replace with _Safe_tuple_element_t alias\n+\ttemplate.\n+\t(_Mu): Remove vestigial TR1 return types and update coments.\n+\n \tPR libstdc++/68912\n \t* include/std/functional (_Bind::operator()): Use lvalue functor to\n \tdeduce return type."}, {"sha": "99af29efeb15e92e8cc705623962ee67db5b63fd", "filename": "libstdc++-v3/include/std/functional", "status": "modified", "additions": 25, "deletions": 73, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72030b28a1bf6cdd3f3aa204f2909bce5d8c6dce/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72030b28a1bf6cdd3f3aa204f2909bce5d8c6dce/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional?ref=72030b28a1bf6cdd3f3aa204f2909bce5d8c6dce", "patch": "@@ -654,9 +654,11 @@ _GLIBCXX_MEM_FN_TRAITS(&&, false_type, true_type)\n     }\n \n   /**\n-   *  @brief Determines if the given type _Tp is a function object\n+   *  @brief Determines if the given type _Tp is a function object that\n    *  should be treated as a subexpression when evaluating calls to\n-   *  function objects returned by bind(). [TR1 3.6.1]\n+   *  function objects returned by bind().\n+   *\n+   *  C++11 [func.bind.isbind].\n    *  @ingroup binders\n    */\n   template<typename _Tp>\n@@ -665,7 +667,9 @@ _GLIBCXX_MEM_FN_TRAITS(&&, false_type, true_type)\n \n   /**\n    *  @brief Determines if the given type _Tp is a placeholder in a\n-   *  bind() expression and, if so, which placeholder it is. [TR1 3.6.2]\n+   *  bind() expression and, if so, which placeholder it is.\n+   *\n+   *  C++11 [func.bind.isplace].\n    *  @ingroup binders\n    */\n   template<typename _Tp>\n@@ -740,45 +744,16 @@ _GLIBCXX_MEM_FN_TRAITS(&&, false_type, true_type)\n     : public integral_constant<int, _Num>\n     { };\n \n-  /**\n-   * Used by _Safe_tuple_element to indicate that there is no tuple\n-   * element at this position.\n-   */\n-  struct _No_tuple_element;\n-\n-  /**\n-   * Implementation helper for _Safe_tuple_element. This primary\n-   * template handles the case where it is safe to use @c\n-   * tuple_element.\n-   */\n-  template<std::size_t __i, typename _Tuple, bool _IsSafe>\n-    struct _Safe_tuple_element_impl\n-    : tuple_element<__i, _Tuple> { };\n-\n-  /**\n-   * Implementation helper for _Safe_tuple_element. This partial\n-   * specialization handles the case where it is not safe to use @c\n-   * tuple_element. We just return @c _No_tuple_element.\n-   */\n-  template<std::size_t __i, typename _Tuple>\n-    struct _Safe_tuple_element_impl<__i, _Tuple, false>\n-    {\n-      typedef _No_tuple_element type;\n-    };\n \n-  /**\n-   * Like tuple_element, but returns @c _No_tuple_element when\n-   * tuple_element would return an error.\n-   */\n+  // Like tuple_element_t but SFINAE-friendly.\n  template<std::size_t __i, typename _Tuple>\n-   struct _Safe_tuple_element\n-   : _Safe_tuple_element_impl<__i, _Tuple,\n-\t\t\t      (__i < tuple_size<_Tuple>::value)>\n-   { };\n+   using _Safe_tuple_element_t\n+     = typename enable_if<(__i < tuple_size<_Tuple>::value),\n+\t\t\t  tuple_element<__i, _Tuple>>::type::type;\n \n   /**\n    *  Maps an argument to bind() into an actual argument to the bound\n-   *  function object [TR1 3.6.3/5]. Only the first parameter should\n+   *  function object [func.bind.bind]/10. Only the first parameter should\n    *  be specified: the rest are used to determine among the various\n    *  implementations. Note that, although this class is a function\n    *  object, it isn't entirely normal because it takes only two\n@@ -794,28 +769,28 @@ _GLIBCXX_MEM_FN_TRAITS(&&, false_type, true_type)\n \n   /**\n    *  If the argument is reference_wrapper<_Tp>, returns the\n-   *  underlying reference. [TR1 3.6.3/5 bullet 1]\n+   *  underlying reference.\n+   *  C++11 [func.bind.bind] p10 bullet 1.\n    */\n   template<typename _Tp>\n     class _Mu<reference_wrapper<_Tp>, false, false>\n     {\n     public:\n-      typedef _Tp& result_type;\n-\n       /* Note: This won't actually work for const volatile\n        * reference_wrappers, because reference_wrapper::get() is const\n        * but not volatile-qualified. This might be a defect in the TR.\n        */\n       template<typename _CVRef, typename _Tuple>\n-\tresult_type\n+\t_Tp&\n \toperator()(_CVRef& __arg, _Tuple&) const volatile\n \t{ return __arg.get(); }\n     };\n \n   /**\n    *  If the argument is a bind expression, we invoke the underlying\n    *  function object with the same cv-qualifiers as we are given and\n-   *  pass along all of our arguments (unwrapped). [TR1 3.6.3/5 bullet 2]\n+   *  pass along all of our arguments (unwrapped).\n+   *  C++11 [func.bind.bind] p10 bullet 2.\n    */\n   template<typename _Arg>\n     class _Mu<_Arg, true, false>\n@@ -849,58 +824,35 @@ _GLIBCXX_MEM_FN_TRAITS(&&, false_type, true_type)\n   /**\n    *  If the argument is a placeholder for the Nth argument, returns\n    *  a reference to the Nth argument to the bind function object.\n-   *  [TR1 3.6.3/5 bullet 3]\n+   *  C++11 [func.bind.bind] p10 bullet 3.\n    */\n   template<typename _Arg>\n     class _Mu<_Arg, false, true>\n     {\n     public:\n-      template<typename _Signature> class result;\n-\n-      template<typename _CVMu, typename _CVArg, typename _Tuple>\n-\tclass result<_CVMu(_CVArg, _Tuple)>\n-\t{\n-\t  // Add a reference, if it hasn't already been done for us.\n-\t  // This allows us to be a little bit sloppy in constructing\n-\t  // the tuple that we pass to result_of<...>.\n-\t  typedef typename _Safe_tuple_element<(is_placeholder<_Arg>::value\n-\t\t\t\t\t\t- 1), _Tuple>::type\n-\t    __base_type;\n-\n-\tpublic:\n-\t  typedef typename add_rvalue_reference<__base_type>::type type;\n-\t};\n-\n       template<typename _Tuple>\n-\ttypename result<_Mu(_Arg, _Tuple)>::type\n+\t_Safe_tuple_element_t<(is_placeholder<_Arg>::value - 1), _Tuple>&&\n \toperator()(const volatile _Arg&, _Tuple& __tuple) const volatile\n \t{\n-\t  return std::forward<typename result<_Mu(_Arg, _Tuple)>::type>(\n+\t  using __type\n+\t    = __tuple_element_t<(is_placeholder<_Arg>::value - 1), _Tuple>;\n+\t  return std::forward<__type>(\n \t      ::std::get<(is_placeholder<_Arg>::value - 1)>(__tuple));\n \t}\n     };\n \n   /**\n    *  If the argument is just a value, returns a reference to that\n-   *  value. The cv-qualifiers on the reference are the same as the\n-   *  cv-qualifiers on the _Mu object. [TR1 3.6.3/5 bullet 4]\n+   *  value. The cv-qualifiers on the reference are determined by the caller.\n+   *  C++11 [func.bind.bind] p10 bullet 4.\n    */\n   template<typename _Arg>\n     class _Mu<_Arg, false, false>\n     {\n     public:\n-      template<typename _Signature> struct result;\n-\n-      template<typename _CVMu, typename _CVArg, typename _Tuple>\n-\tstruct result<_CVMu(_CVArg, _Tuple)>\n-\t{\n-\t  typedef typename add_lvalue_reference<_CVArg>::type type;\n-\t};\n-\n-      // Pick up the cv-qualifiers of the argument\n       template<typename _CVArg, typename _Tuple>\n \t_CVArg&&\n-\toperator()(_CVArg&& __arg, _Tuple&) const volatile\n+\toperator()(_CVArg&& __arg, _Tuple&) const\n \t{ return std::forward<_CVArg>(__arg); }\n     };\n "}]}