{"sha": "67ffc8124f94d059eba8bcda0d1cfa070bc4eae0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjdmZmM4MTI0Zjk0ZDA1OWViYThiY2RhMGQxY2ZhMDcwYmM0ZWFlMA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1998-05-25T10:28:16Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-05-25T10:28:16Z"}, "message": "decl2.c (build_anon_union_vars): Don't crash on empty sub-unions.\n\n1998-05-25  Mark Mitchell  <mark@markmitchell.com>\n\t* decl2.c (build_anon_union_vars): Don't crash on empty sub-unions.\n\t* cp-tree.h (processing_template_parmlist): Declare.\n\t* decl.c (pushtag): Don't call push_template_decl when we\n\tshouldn't.\n\t* pt.c (processing_template_parmlist): New variable.\n\t(TMPL_ARGS_HAVE_MULTIPLE_LEVELS): New macro.\n\t(complete_template_args): Use it.\n\t(add_to_template_args): Likewise.\n\t(innermost_args): Likewise.\n\t(tsubst): Likewise.\n\t(begin_template_parm_list): Use processing_template_parmlist.\n\t(end_template_parm_list): Likewise.\n\t* cp-tree.h (ANON_UNION_TYPE_P): New macro.\n\t* decl.c (grokdeclarator): Use it.\n\t* decl2.c (grok_x_components): Likewise.\n\t* init.c (initializing_context): Likewise.\n\t* method.c (do_build_copy_constructor): Likewise.\n\t(do_build_assign_ref): Likewise.\n\t* search.c (compute_access): Likewise.\n\t* typeck.c (build_component_ref): Likewise.\n\t* decl.c (grokdeclarator): Don't give a cv-qualified version of an\n\tunnamed type a typedef name \"for linkage purposes\".\n\t* pt.c (lookup_template_class): Don't look at\n\tIDENTIFIER_CLASS_VALUE when there's no current_class_type.\n\t* method.c (build_overload_int): Handle error cases gracefully.\n\t* pt.c (instantiate_decl): Handle static member variables\n\tcorrectly.\n\t* pt.c (tsubst): Use the tsubst'd type when producing new\n\tTEMPLATE_PARM_INDEX nodes.\n\nFrom-SVN: r20045", "tree": {"sha": "585de9a1e35f1808041f780e2175364e45a326dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/585de9a1e35f1808041f780e2175364e45a326dd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/67ffc8124f94d059eba8bcda0d1cfa070bc4eae0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67ffc8124f94d059eba8bcda0d1cfa070bc4eae0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67ffc8124f94d059eba8bcda0d1cfa070bc4eae0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67ffc8124f94d059eba8bcda0d1cfa070bc4eae0/comments", "author": null, "committer": null, "parents": [{"sha": "c21f27a76270b3e7d2e23679524d2f39b506cef4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c21f27a76270b3e7d2e23679524d2f39b506cef4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c21f27a76270b3e7d2e23679524d2f39b506cef4"}], "stats": {"total": 269, "additions": 216, "deletions": 53}, "files": [{"sha": "23b61d0e491d8ed017e7b7372c9eb155f4c494fa", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67ffc8124f94d059eba8bcda0d1cfa070bc4eae0/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67ffc8124f94d059eba8bcda0d1cfa070bc4eae0/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=67ffc8124f94d059eba8bcda0d1cfa070bc4eae0", "patch": "@@ -1,3 +1,42 @@\n+1998-05-25  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* decl2.c (build_anon_union_vars): Don't crash on empty sub-unions.\n+\n+\t* cp-tree.h (processing_template_parmlist): Declare.\n+\t* decl.c (pushtag): Don't call push_template_decl when we\n+\tshouldn't. \n+\t* pt.c (processing_template_parmlist): New variable.\n+\t(TMPL_ARGS_HAVE_MULTIPLE_LEVELS): New macro.\n+\t(complete_template_args): Use it.\n+\t(add_to_template_args): Likewise.\n+\t(innermost_args): Likewise.\n+\t(tsubst): Likewise.\n+\t(begin_template_parm_list): Use processing_template_parmlist.\n+\t(end_template_parm_list): Likewise.\n+\n+\t* cp-tree.h (ANON_UNION_TYPE_P): New macro.\n+\t* decl.c (grokdeclarator): Use it.\n+\t* decl2.c (grok_x_components): Likewise.\n+\t* init.c (initializing_context): Likewise.\n+\t* method.c (do_build_copy_constructor): Likewise.\n+\t(do_build_assign_ref): Likewise.\n+\t* search.c (compute_access): Likewise.\n+\t* typeck.c (build_component_ref): Likewise.\n+\n+\t* decl.c (grokdeclarator): Don't give a cv-qualified version of an\n+\tunnamed type a typedef name \"for linkage purposes\".\n+\n+\t* pt.c (lookup_template_class): Don't look at\n+\tIDENTIFIER_CLASS_VALUE when there's no current_class_type.\n+\n+\t* method.c (build_overload_int): Handle error cases gracefully.\n+\n+\t* pt.c (instantiate_decl): Handle static member variables\n+\tcorrectly.\n+\n+\t* pt.c (tsubst): Use the tsubst'd type when producing new\n+\tTEMPLATE_PARM_INDEX nodes.\n+\n 1998-05-24  Mark Mitchell  <mark@markmitchell.com>\n \n \t* tree.c (cp_tree_equal): Handle pointers to member functions."}, {"sha": "f65fbd437ef5d05569cac9d56ea8abe3817e8765", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67ffc8124f94d059eba8bcda0d1cfa070bc4eae0/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67ffc8124f94d059eba8bcda0d1cfa070bc4eae0/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=67ffc8124f94d059eba8bcda0d1cfa070bc4eae0", "patch": "@@ -1452,6 +1452,11 @@ extern int flag_new_for_scope;\n \n #define ANON_UNION_P(NODE) (DECL_NAME (NODE) == 0)\n \n+/* Nonzero if TYPE is an anonymous union type.  */\n+#define ANON_UNION_TYPE_P(TYPE) \\\n+  (TREE_CODE (TYPE) == UNION_TYPE \\\n+   && ANON_AGGRNAME_P (TYPE_IDENTIFIER (TYPE)))\n+\n #define UNKNOWN_TYPE LANG_TYPE\n \n /* Define fields and accessors for nodes representing declared names.  */\n@@ -2644,6 +2649,7 @@ extern int comp_template_args                   PROTO((tree, tree));\n \n extern int processing_specialization;\n extern int processing_explicit_instantiation;\n+extern int processing_template_parmlist;\n \n /* in repo.c */\n extern void repo_template_used\t\t\tPROTO((tree));"}, {"sha": "67604d7cd08d20dbb2b55f8688d87c07aa39c91b", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67ffc8124f94d059eba8bcda0d1cfa070bc4eae0/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67ffc8124f94d059eba8bcda0d1cfa070bc4eae0/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=67ffc8124f94d059eba8bcda0d1cfa070bc4eae0", "patch": "@@ -2291,9 +2291,15 @@ pushtag (name, type, globalize)\n \t\t         friend class S2; \n \t\t       };\n \n-\t\t     declares S2 to be at global scope.  */\n-\t\t  || (processing_template_decl > \n-\t\t      template_class_depth (current_class_type))))\n+\t\t     declares S2 to be at global scope.  We must be\n+\t\t     careful, however, of the following case:\n+\n+\t\t       template <class A*> struct S;\n+\n+\t\t     which declares a non-template class `A'.  */\n+\t\t  || (!processing_template_parmlist\n+\t\t      && (processing_template_decl > \n+\t\t\t  template_class_depth (current_class_type)))))\n \t    {\n \t      d = push_template_decl_real (d, globalize);\n \t      /* If the current binding level is the binding level for\n@@ -8750,8 +8756,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n   /* Static anonymous unions are dealt with here.  */\n   if (staticp && decl_context == TYPENAME\n       && TREE_CODE (declspecs) == TREE_LIST\n-      && TREE_CODE (TREE_VALUE (declspecs)) == UNION_TYPE\n-      && ANON_AGGRNAME_P (TYPE_IDENTIFIER (TREE_VALUE (declspecs))))\n+      && ANON_UNION_TYPE_P (TREE_VALUE (declspecs)))\n     decl_context = FIELD;\n \n   /* Give error if `const,' `volatile,' `inline,' `friend,' or `virtual'\n@@ -9659,6 +9664,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t refer to it, so nothing needs know about the name change.\n \t The TYPE_NAME field was filled in by build_struct_xref.  */\n       if (type != error_mark_node\n+\t  && !TYPE_READONLY (type) && !TYPE_VOLATILE (type)\n \t  && TYPE_NAME (type)\n \t  && TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n \t  && ANON_AGGRNAME_P (TYPE_IDENTIFIER (type)))"}, {"sha": "e4c14abb30acbe0a441ac43a1c2ece7bab9e1dfc", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67ffc8124f94d059eba8bcda0d1cfa070bc4eae0/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67ffc8124f94d059eba8bcda0d1cfa070bc4eae0/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=67ffc8124f94d059eba8bcda0d1cfa070bc4eae0", "patch": "@@ -865,8 +865,7 @@ grok_x_components (specs, components)\n \t{\n \tcase VAR_DECL:\n \t  /* Static anonymous unions come out as VAR_DECLs.  */\n-\t  if (TREE_CODE (TREE_TYPE (t)) == UNION_TYPE\n-\t      && ANON_AGGRNAME_P (TYPE_IDENTIFIER (TREE_TYPE (t))))\n+\t  if (ANON_UNION_TYPE_P (TREE_TYPE (t)))\n \t    return t;\n \n \t  /* We return SPECS here, because in the parser it was ending\n@@ -904,8 +903,7 @@ grok_x_components (specs, components)\n \t    tcode = enum_type_node;\n \n \t  t = xref_tag (tcode, TYPE_IDENTIFIER (t), NULL_TREE, 0);\n-\t  if (TREE_CODE (t) == UNION_TYPE\n-\t      && ANON_AGGRNAME_P (TYPE_IDENTIFIER (t)))\n+\t  if (ANON_UNION_TYPE_P (t))\n \t    {\n \t      /* See also shadow_tag.  */\n \n@@ -2176,7 +2174,11 @@ build_anon_union_vars (anon_decl, elems, static_p, external_p)\n \n       if (DECL_NAME (field) == NULL_TREE\n \t  && TREE_CODE (TREE_TYPE (field)) == UNION_TYPE)\n-\tdecl = build_anon_union_vars (field, elems, static_p, external_p);\n+\t{\n+\t  decl = build_anon_union_vars (field, elems, static_p, external_p);\n+\t  if (!decl)\n+\t    continue;\n+\t}\n       else\n \t{\n \t  decl = build_decl (VAR_DECL, DECL_NAME (field), TREE_TYPE (field));"}, {"sha": "c706a04ba31fac0957c02e5a0cdf599226bc78cc", "filename": "gcc/cp/init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67ffc8124f94d059eba8bcda0d1cfa070bc4eae0/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67ffc8124f94d059eba8bcda0d1cfa070bc4eae0/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=67ffc8124f94d059eba8bcda0d1cfa070bc4eae0", "patch": "@@ -866,7 +866,7 @@ initializing_context (field)\n \n   /* Anonymous union members can be initialized in the first enclosing\n      non-anonymous union context.  */\n-  while (t && ANON_AGGRNAME_P (TYPE_IDENTIFIER (t)))\n+  while (t && ANON_UNION_TYPE_P (t))\n     t = TYPE_CONTEXT (t);\n   return t;\n }"}, {"sha": "054cfddb9f312b637ce998aca3e1c4156f22c221", "filename": "gcc/cp/method.c", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67ffc8124f94d059eba8bcda0d1cfa070bc4eae0/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67ffc8124f94d059eba8bcda0d1cfa070bc4eae0/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=67ffc8124f94d059eba8bcda0d1cfa070bc4eae0", "patch": "@@ -515,7 +515,13 @@ build_overload_int (value, in_template)\n \t  id = ansi_opname [(int) TREE_CODE (value)];\n \t  my_friendly_assert (id != NULL_TREE, 0);\n \t  name = IDENTIFIER_POINTER (id);\n-\t  my_friendly_assert (name[0] == '_' && name[1] == '_', 0);\n+\t  if (name[0] != '_' || name[1] != '_')\n+\t    /* On some erroneous inputs, we can get here with VALUE a\n+\t       LOOKUP_EXPR.  In that case, the NAME will be the\n+\t       identifier for \"<invalid operator>\".  We must survive\n+\t       this routine in order to issue a sensible error\n+\t       message, so we fall through to the case below.  */\n+\t    goto bad_value;\n \n \t  for (i = 0; i < operands; ++i)\n \t    {\n@@ -553,6 +559,7 @@ build_overload_int (value, in_template)\n \t     This should cause assembler errors we'll notice.  */\n \t    \n \t  static int n;\n+\tbad_value:\n \t  sprintf (digit_buffer, \" *%d\", n++);\n \t  OB_PUTCP (digit_buffer);\n \t}\n@@ -2180,8 +2187,7 @@ do_build_copy_constructor (fndecl)\n \t\tcontinue;\n \t    }\n \t  else if ((t = TREE_TYPE (field)) != NULL_TREE\n-\t\t   && TREE_CODE (t) == UNION_TYPE\n-\t\t   && ANON_AGGRNAME_P (TYPE_IDENTIFIER (t))\n+\t\t   && ANON_UNION_TYPE_P (t)\n \t\t   && TYPE_FIELDS (t) != NULL_TREE)\n \t    {\n \t      do\n@@ -2190,8 +2196,7 @@ do_build_copy_constructor (fndecl)\n \t\t  field = largest_union_member (t);\n \t\t}\n \t      while ((t = TREE_TYPE (field)) != NULL_TREE\n-\t\t     && TREE_CODE (t) == UNION_TYPE\n-\t\t     && ANON_AGGRNAME_P (TYPE_IDENTIFIER (t))\n+\t\t     && ANON_UNION_TYPE_P (t)\n \t\t     && TYPE_FIELDS (t) != NULL_TREE);\n \t    }\n \t  else\n@@ -2290,8 +2295,7 @@ do_build_assign_ref (fndecl)\n \t\tcontinue;\n \t    }\n \t  else if ((t = TREE_TYPE (field)) != NULL_TREE\n-\t\t   && TREE_CODE (t) == UNION_TYPE\n-\t\t   && ANON_AGGRNAME_P (TYPE_IDENTIFIER (t))\n+\t\t   && ANON_UNION_TYPE_P (t)\n \t\t   && TYPE_FIELDS (t) != NULL_TREE)\n \t    {\n \t      do\n@@ -2301,8 +2305,7 @@ do_build_assign_ref (fndecl)\n \t\t  field = largest_union_member (t);\n \t\t}\n \t      while ((t = TREE_TYPE (field)) != NULL_TREE\n-\t\t     && TREE_CODE (t) == UNION_TYPE\n-\t\t     && ANON_AGGRNAME_P (TYPE_IDENTIFIER (t))\n+\t\t     && ANON_UNION_TYPE_P (t)\n \t\t     && TYPE_FIELDS (t) != NULL_TREE);\n \t    }\n \t  else"}, {"sha": "dd7060ad43fa74dadf5120726c225fc48917036d", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 35, "deletions": 28, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67ffc8124f94d059eba8bcda0d1cfa070bc4eae0/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67ffc8124f94d059eba8bcda0d1cfa070bc4eae0/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=67ffc8124f94d059eba8bcda0d1cfa070bc4eae0", "patch": "@@ -63,6 +63,7 @@ int minimal_parse_mode;\n \n int processing_specialization;\n int processing_explicit_instantiation;\n+int processing_template_parmlist;\n static int template_header_count;\n \n static tree saved_trees;\n@@ -115,6 +116,14 @@ static int check_cv_quals_for_unify PROTO((int, tree, tree));\n static tree tsubst_template_arg_vector PROTO((tree, tree));\n static void regenerate_decl_from_template PROTO((tree, tree));\n \n+/* Nonzero if ARGVEC contains multiple levels of template arguments.  */\n+#define TMPL_ARGS_HAVE_MULTIPLE_LEVELS(NODE) \t\t\\\n+  (NODE != NULL_TREE \t\t\t\t\t\\\n+   && TREE_CODE (NODE) == TREE_VEC \t\t\t\\\n+   && TREE_VEC_LENGTH (NODE) > 0 \t\t\t\\\n+   && TREE_VEC_ELT (NODE, 0) != NULL_TREE               \\\n+   && TREE_CODE (TREE_VEC_ELT (NODE, 0)) == TREE_VEC)\n+\n /* Do any processing required when DECL (a member template declaration\n    using TEMPLATE_PARAMETERS as its innermost parameter list) is\n    finished.  Returns the TEMPLATE_DECL corresponding to DECL, unless\n@@ -388,7 +397,7 @@ complete_template_args (tmpl, extra_args, unbound_only)\n   my_friendly_assert (TREE_CODE (tmpl) == TEMPLATE_DECL, 0);\n   my_friendly_assert (TREE_CODE (extra_args) == TREE_VEC, 0);\n \n-  if (TREE_CODE (TREE_VEC_ELT (extra_args, 0)) == TREE_VEC)\n+  if (TMPL_ARGS_HAVE_MULTIPLE_LEVELS (extra_args))\n     extra_arg_depth = TREE_VEC_LENGTH (extra_args);\n   else\n     extra_arg_depth = 1;\n@@ -411,7 +420,7 @@ complete_template_args (tmpl, extra_args, unbound_only)\n \t     TEMPLATE_DECL with DECL_TEMPLATE_INFO.  DECL_TI_ARGS is\n \t     all the bound template arguments.  */\n \t  args = DECL_TI_ARGS (tmpl);\n-\t  if (TREE_CODE (TREE_VEC_ELT (args, 0)) != TREE_VEC)\n+\t  if (!TMPL_ARGS_HAVE_MULTIPLE_LEVELS (args))\n \t    depth = 1;\n \t  else\n \t    depth = TREE_VEC_LENGTH (args);\n@@ -485,7 +494,7 @@ add_to_template_args (args, extra_args)\n {\n   tree new_args;\n \n-  if (TREE_CODE (TREE_VEC_ELT (args, 0)) != TREE_VEC)\n+  if (!TMPL_ARGS_HAVE_MULTIPLE_LEVELS (args))\n     {\n       new_args = make_tree_vec (2);\n       TREE_VEC_ELT (new_args, 0) = args;\n@@ -529,6 +538,7 @@ begin_template_parm_list ()\n   pushlevel (0);\n   declare_pseudo_global_level ();\n   ++processing_template_decl;\n+  ++processing_template_parmlist;\n   note_template_header (0);\n }\n \n@@ -1452,6 +1462,8 @@ end_template_parm_list (parms)\n   for (parm = parms, nparms = 0; parm; parm = TREE_CHAIN (parm), nparms++)\n     TREE_VEC_ELT (saved_parmlist, nparms) = parm;\n \n+  --processing_template_parmlist;\n+\n   return saved_parmlist;\n }\n \n@@ -2858,9 +2870,10 @@ lookup_template_class (d1, arglist, in_decl, context)\n \t{\n \t  if (context)\n \t    push_decl_namespace (context);\n-\t  template = \n-\t    maybe_get_template_decl_from_type_decl\n-\t    (IDENTIFIER_CLASS_VALUE (d1));\n+\t  if (current_class_type != NULL_TREE)\n+\t    template = \n+\t      maybe_get_template_decl_from_type_decl\n+\t      (IDENTIFIER_CLASS_VALUE (d1));\n \t  if (template == NULL_TREE)\n \t    template = lookup_name_nonclass (d1);\n \t  if (context)\n@@ -3993,7 +4006,7 @@ innermost_args (args, is_spec)\n      tree args;\n      int is_spec;\n {\n-  if (args != NULL_TREE && TREE_CODE (TREE_VEC_ELT (args, 0)) == TREE_VEC)\n+  if (TMPL_ARGS_HAVE_MULTIPLE_LEVELS (args))\n     return TREE_VEC_ELT (args, TREE_VEC_LENGTH (args) - 1 - is_spec);\n   return args;\n }\n@@ -4189,8 +4202,7 @@ tsubst (t, args, in_decl)\n \t  {\n \t    tree arg = NULL_TREE;\n \n-\t    if (TREE_VEC_ELT (args, 0) != NULL_TREE\n-\t\t&& TREE_CODE (TREE_VEC_ELT (args, 0)) == TREE_VEC)\n+\t    if (TMPL_ARGS_HAVE_MULTIPLE_LEVELS (args))\n \t      {\n \t\tlevels = TREE_VEC_LENGTH (args);\n \t\tif (level <= levels)\n@@ -4275,7 +4287,7 @@ tsubst (t, args, in_decl)\n \t    break;\n \n \t  case TEMPLATE_PARM_INDEX:\n-\t    r = reduce_template_parm_level (t, TREE_TYPE (t), levels);\n+\t    r = reduce_template_parm_level (t, type, levels);\n \t    break;\n \t   \n \t  default:\n@@ -6220,14 +6232,14 @@ unify (tparms, targs, parm, arg, strict, explicit_mask)\n \t/* The PARM is not one we're trying to unify.  Just check\n \t   to see if it matches ARG.  */\n \treturn (TREE_CODE (arg) == TREE_CODE (parm)\n-\t\t&& cp_tree_equal (parm, arg)) ? 0 : 1;\n+\t\t&& cp_tree_equal (parm, arg) > 0) ? 0 : 1;\n \n       idx = TEMPLATE_PARM_IDX (parm);\n       targ = TREE_VEC_ELT (targs, idx);\n \n       if (targ)\n \t{\n-\t  int i = cp_tree_equal (targ, arg);\n+\t  int i = (cp_tree_equal (targ, arg) > 0);\n \t  if (i == 1)\n \t    return 0;\n \t  else if (i == 0)\n@@ -7082,17 +7094,6 @@ instantiate_decl (d)\n   lineno = DECL_SOURCE_LINE (d);\n   input_filename = DECL_SOURCE_FILE (d);\n \n-  /* We need to set up DECL_INITIAL regardless of pattern_defined if the\n-     variable is a static const initialized in the class body.  */\n-  if (TREE_CODE (d) == VAR_DECL\n-      && ! DECL_INITIAL (d) && DECL_INITIAL (code_pattern))\n-    {\n-      pushclass (DECL_CONTEXT (d), 2);\n-      DECL_INITIAL (d) = tsubst_expr (DECL_INITIAL (code_pattern), args,\n-\t\t\t\t      tmpl);\n-      cp_finish_decl (d, DECL_INITIAL (d), NULL_TREE, 0, LOOKUP_NORMAL);\n-    }\n-\n   if (pattern_defined)\n     {\n       repo_template_used (d);\n@@ -7123,11 +7124,17 @@ instantiate_decl (d)\n       && ! (TREE_CODE (d) == FUNCTION_DECL && DECL_INLINE (d)))\n     goto out;\n \n-  /* Defer all templates except inline functions used in another function.  */\n-  if (! pattern_defined\n-      || (! (TREE_CODE (d) == FUNCTION_DECL && DECL_INLINE (d) && nested)\n-\t  && ! at_eof))\n-    {\n+  if (TREE_CODE (d) == VAR_DECL \n+      && DECL_INITIAL (d) == NULL_TREE\n+      && DECL_INITIAL (code_pattern) != NULL_TREE)\n+    /* We need to set up DECL_INITIAL regardless of pattern_defined if\n+\t the variable is a static const initialized in the class body.  */;\n+  else if (! pattern_defined\n+\t   || (! (TREE_CODE (d) == FUNCTION_DECL && DECL_INLINE (d) && nested)\n+\t       && ! at_eof))\n+    {\n+      /* Defer all templates except inline functions used in another\n+         function.  */\n       lineno = line;\n       input_filename = file;\n "}, {"sha": "c0db0572ee506a530fe54c6c68cd80ff5b50cd1c", "filename": "gcc/cp/search.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67ffc8124f94d059eba8bcda0d1cfa070bc4eae0/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67ffc8124f94d059eba8bcda0d1cfa070bc4eae0/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=67ffc8124f94d059eba8bcda0d1cfa070bc4eae0", "patch": "@@ -969,8 +969,7 @@ compute_access (basetype_path, field)\n   /* Fields coming from nested anonymous unions have their DECL_CLASS_CONTEXT\n      slot set to the union type rather than the record type containing\n      the anonymous union.  */\n-  if (context && TREE_CODE (context) == UNION_TYPE\n-      && ANON_AGGRNAME_P (TYPE_IDENTIFIER (context)))\n+  if (context && ANON_UNION_TYPE_P (context))\n     context = TYPE_CONTEXT (context);\n \n   /* Virtual function tables are never private.  But we should know that"}, {"sha": "63b2adc2f3b450c480a8d2d345896dea8bf61524", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67ffc8124f94d059eba8bcda0d1cfa070bc4eae0/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67ffc8124f94d059eba8bcda0d1cfa070bc4eae0/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=67ffc8124f94d059eba8bcda0d1cfa070bc4eae0", "patch": "@@ -2065,8 +2065,8 @@ build_component_ref (datum, component, basetype_path, protect)\n     {\n       tree context = DECL_FIELD_CONTEXT (field);\n       tree base = context;\n-      while (base != basetype && TYPE_NAME (base)\n-\t     && ANON_AGGRNAME_P (TYPE_IDENTIFIER (base)))\n+      while (!comptypes (base, basetype,1) && TYPE_NAME (base)\n+\t     && ANON_UNION_TYPE_P (base))\n \t{\n \t  base = TYPE_CONTEXT (base);\n \t}\n@@ -2096,7 +2096,7 @@ build_component_ref (datum, component, basetype_path, protect)\n       basetype = base;\n  \n       /* Handle things from anon unions here...  */\n-      if (TYPE_NAME (context) && ANON_AGGRNAME_P (TYPE_IDENTIFIER (context)))\n+      if (TYPE_NAME (context) && ANON_UNION_TYPE_P (context))\n \t{\n \t  tree subfield = lookup_anon_field (basetype, context);\n \t  tree subdatum = build_component_ref (datum, subfield,"}, {"sha": "d44772932edbbcdd07757f13cc55c71cbdec76a3", "filename": "gcc/testsuite/g++.old-deja/g++.other/typedef1.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67ffc8124f94d059eba8bcda0d1cfa070bc4eae0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Ftypedef1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67ffc8124f94d059eba8bcda0d1cfa070bc4eae0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Ftypedef1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Ftypedef1.C?ref=67ffc8124f94d059eba8bcda0d1cfa070bc4eae0", "patch": "@@ -0,0 +1,13 @@\n+// Build don't link:\n+\n+typedef const struct {\n+   int x;\n+} Test;\n+\n+void foo(Test);\n+\n+void foo(Test t)\n+{\n+  t.x = 0; // ERROR - assignment of read-only member\n+  return;\n+}"}, {"sha": "786cdf2c9027e7f5158ef013a7d092a2b8f4b600", "filename": "gcc/testsuite/g++.old-deja/g++.pt/crash5.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67ffc8124f94d059eba8bcda0d1cfa070bc4eae0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67ffc8124f94d059eba8bcda0d1cfa070bc4eae0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash5.C?ref=67ffc8124f94d059eba8bcda0d1cfa070bc4eae0", "patch": "@@ -0,0 +1,12 @@\n+// Build don't link:\n+\n+template <class T, int i>\n+struct K {\n+\tvoid f();\n+};\n+\n+template <class T>\n+void\n+K<T, i>::f()\n+{ // ERROR - template parameters\n+}"}, {"sha": "4ff38b6c04c80bb58e45833621fff9be52d490a8", "filename": "gcc/testsuite/g++.old-deja/g++.pt/memtemp75.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67ffc8124f94d059eba8bcda0d1cfa070bc4eae0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemtemp75.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67ffc8124f94d059eba8bcda0d1cfa070bc4eae0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemtemp75.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemtemp75.C?ref=67ffc8124f94d059eba8bcda0d1cfa070bc4eae0", "patch": "@@ -0,0 +1,25 @@\n+// Build don't link:\n+\n+void\n+print(const int& i)\n+{\n+}\n+\n+template<class A>\n+class bar\n+{\n+public:\t\n+  template<void (*B)(const A& a)>\n+  void doit(const A& a)\n+    {\n+      B(a);\n+    }\n+};\n+\n+\n+int\n+main()\n+{\n+  bar<int>\tb;\n+  b.template doit<print>(2);\n+}"}, {"sha": "d7d034d6f7fd58f7749474e01559b5f107366048", "filename": "gcc/testsuite/g++.old-deja/g++.pt/spec18.C", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67ffc8124f94d059eba8bcda0d1cfa070bc4eae0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec18.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67ffc8124f94d059eba8bcda0d1cfa070bc4eae0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec18.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec18.C?ref=67ffc8124f94d059eba8bcda0d1cfa070bc4eae0", "patch": "@@ -0,0 +1,30 @@\n+// Build don't link:\n+\n+template<class A, class B>\n+void foo(const A& a, const B& b)\n+{\n+}\n+\n+template<class A, class B>\n+void foo(const A& a, const int& b)\n+{\n+}\n+\n+template<class A*, class B>\n+void foo(const A*& a, const B& b)\n+{\n+}\n+\n+template<>\n+void foo(const int&, const double&)\n+{\n+}\n+\n+\n+int\n+main()\n+{\n+  foo(\"98239\", 23);\n+  foo(232, 1.022);\n+}\n+"}, {"sha": "5060cfdfb9ec14745dbcca4469c4caebe1707b3f", "filename": "gcc/testsuite/g++.old-deja/g++.pt/static2.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67ffc8124f94d059eba8bcda0d1cfa070bc4eae0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fstatic2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67ffc8124f94d059eba8bcda0d1cfa070bc4eae0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fstatic2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fstatic2.C?ref=67ffc8124f94d059eba8bcda0d1cfa070bc4eae0", "patch": "@@ -0,0 +1,21 @@\n+// Build don't link:\n+\n+template <class A>\n+class TEST\n+{\n+public:\n+  TEST (A) {}\n+};\n+\n+template <class A>\n+class TEST2\n+{\n+  static A i;\n+};\n+\n+template <class A>\n+A TEST2 <A>::i (0);\n+\n+TEST2 <TEST <int> > a;\n+\n+template class TEST2 <TEST <int> >;"}]}