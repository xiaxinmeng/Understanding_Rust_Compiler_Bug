{"sha": "a6253d46c5baa987b12af721d78988806867cea8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTYyNTNkNDZjNWJhYTk4N2IxMmFmNzIxZDc4OTg4ODA2ODY3Y2VhOA==", "commit": {"author": {"name": "Daniel Berlin", "email": "dan@cgsoftware.com", "date": "2001-11-25T17:22:55Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2001-11-25T17:22:55Z"}, "message": "df.c: Add prototypes for hybrid_search_bitmap and hybrid_search_sbitmap.\n\n2001-11-25  Daniel Berlin  <dan@cgsoftware.com>\n\n\t* df.c: Add prototypes for hybrid_search_bitmap and\n\thybrid_search_sbitmap.\n\t(hybrid_search_bitmap): New function.\n\t(hybrid_search_sbitmap): New function.\n\t(iterative_dataflow_sbitmap): Change to use hybrid_search_sbitmap.\n\t(iterative_dataflow_bitmap): Ditto.\n\nFrom-SVN: r47326", "tree": {"sha": "9a7a53923107122ab808e46fe17cde862c20a250", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9a7a53923107122ab808e46fe17cde862c20a250"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a6253d46c5baa987b12af721d78988806867cea8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6253d46c5baa987b12af721d78988806867cea8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6253d46c5baa987b12af721d78988806867cea8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6253d46c5baa987b12af721d78988806867cea8/comments", "author": null, "committer": null, "parents": [{"sha": "cb33a143b96c9a6723c9da3afc3f87218fce4a1f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb33a143b96c9a6723c9da3afc3f87218fce4a1f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb33a143b96c9a6723c9da3afc3f87218fce4a1f"}], "stats": {"total": 423, "additions": 263, "deletions": 160}, "files": [{"sha": "2450132ca322a1f98987ba5aaaa994db54b0a920", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6253d46c5baa987b12af721d78988806867cea8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6253d46c5baa987b12af721d78988806867cea8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a6253d46c5baa987b12af721d78988806867cea8", "patch": "@@ -1,3 +1,12 @@\n+2001-11-25  Daniel Berlin  <dan@cgsoftware.com>\n+\n+\t* df.c: Add prototypes for hybrid_search_bitmap and\n+\thybrid_search_sbitmap. \n+\t(hybrid_search_bitmap): New function.\n+\t(hybrid_search_sbitmap): New function.\n+\t(iterative_dataflow_sbitmap): Change to use hybrid_search_sbitmap.\n+\t(iterative_dataflow_bitmap): Ditto.\n+\t\n 2001-11-25  Stephane Carrez  <Stephane.Carrez@worldnet.fr>\n \n \t* config/m68hc11/m68hc11.md (peephole2): New peephole2 to optimize"}, {"sha": "9cb0230b27cba4c7180b4c6aaf8d7a88d6a4db80", "filename": "gcc/df.c", "status": "modified", "additions": 254, "deletions": 160, "changes": 414, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6253d46c5baa987b12af721d78988806867cea8/gcc%2Fdf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6253d46c5baa987b12af721d78988806867cea8/gcc%2Fdf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.c?ref=a6253d46c5baa987b12af721d78988806867cea8", "patch": "@@ -301,6 +301,16 @@ static void df_ru_transfer_function PARAMS ((int, int *, bitmap, bitmap,\n \t\t\t\t\t     bitmap, bitmap, void *));\n static void df_lr_transfer_function PARAMS ((int, int *, bitmap, bitmap, \n \t\t\t\t\t     bitmap, bitmap, void *));\n+static void hybrid_search_bitmap PARAMS ((basic_block, bitmap *, bitmap *, \n+\t\t\t\t\t  bitmap *, bitmap *, enum df_flow_dir, \n+\t\t\t\t\t  enum df_confluence_op, \n+\t\t\t\t\t  transfer_function_bitmap, \n+\t\t\t\t\t  sbitmap, sbitmap, void *));\n+static void hybrid_search_sbitmap PARAMS ((basic_block, sbitmap *, sbitmap *,\n+\t\t\t\t\t   sbitmap *, sbitmap *, enum df_flow_dir,\n+\t\t\t\t\t   enum df_confluence_op,\n+\t\t\t\t\t   transfer_function_sbitmap,\n+\t\t\t\t\t   sbitmap, sbitmap, void *));\n static inline bool read_modify_subreg_p PARAMS ((rtx));\n \n \f\n@@ -1014,7 +1024,6 @@ df_uses_record (df, loc, ref_type, bb, insn, flags)\n {\n   RTX_CODE code;\n   rtx x;\n-\n  retry:\n   x = *loc;\n   if (!x)\n@@ -1928,7 +1937,6 @@ df_luids_set (df, blocks)\n   return total;\n }\n \n-\n /* Perform dataflow analysis using existing DF structure for blocks\n    within BLOCKS.  If BLOCKS is zero, use all basic blocks in the CFG.  */\n static void\n@@ -3588,279 +3596,365 @@ debug_df_chain (link)\n   fputc ('\\n', stderr);\n }\n \n-/* gen = GEN set.\n-   kill = KILL set.\n-   in, out = Filled in by function.\n-   blocks = Blocks to analyze.\n-   dir = Dataflow direction.\n-   conf_op = Confluence operation.\n-   transfun = Transfer function.\n-   order = Order to iterate in. (Should map block numbers -> order)\n-   data = Whatever you want.  It's passed to the transfer function.\n-   \n-   This function will perform iterative bitvector dataflow, producing\n-   the in and out sets.  Even if you only want to perform it for a\n-   small number of blocks, the vectors for in and out must be large\n-   enough for *all* blocks, because changing one block might affect\n-   others.  However, it'll only put what you say to analyze on the\n-   initial worklist.\n-   \n-   For forward problems, you probably want to pass in a mapping of\n-   block number to rc_order (like df->inverse_rc_map).\n-*/\n-\n-void\n-iterative_dataflow_sbitmap (in, out, gen, kill, blocks, \n-\t\t\t    dir, conf_op, transfun, order, data)\n-     sbitmap *in, *out, *gen, *kill;\n-     bitmap blocks;\n+/* Hybrid search algorithm from \"Implementation Techniques for\n+   Efficient Data-Flow Analysis of Large Programs\".  */\n+static void \n+hybrid_search_bitmap (block, in, out, gen, kill, dir, \n+\t\t      conf_op, transfun, visited, pending, \n+\t\t      data)\n+     basic_block block;\n+     bitmap *in, *out, *gen, *kill;\n      enum df_flow_dir dir;\n      enum df_confluence_op conf_op;\n-     transfer_function_sbitmap transfun;\n-     int *order;\n+     transfer_function_bitmap transfun;\n+     sbitmap visited;\n+     sbitmap pending;\n      void *data;\n {\n   int changed;\n-  int i;\n-  fibheap_t worklist;\n-  sbitmap onqueue;\n-  basic_block bb;\n-  onqueue = sbitmap_alloc (n_basic_blocks);\n-  sbitmap_zero (onqueue);\n-  worklist = fibheap_new ();\n-  EXECUTE_IF_SET_IN_BITMAP (blocks, 0, i,\n-  {\n-    fibheap_insert (worklist, order[i], (void *) i); \n-    SET_BIT (onqueue, i);\n-    if (dir == FORWARD)\n-      {\n-\tsbitmap_copy (out[i], gen[i]);\n-      }\n-    else\n-      {\n-\tsbitmap_copy (in[i], gen[i]);\n-      }\n-    \n-  });\n-  while (!fibheap_empty (worklist))\n+  int i = block->index;\n+  edge e;\n+  basic_block bb= block;\n+  SET_BIT (visited, block->index);\n+  if (TEST_BIT (pending, block->index))\n     {\n-      edge e;\n-      i = (int) fibheap_extract_min  (worklist);\n-      changed = 0;\n-      bb = BASIC_BLOCK (i);\n-      RESET_BIT (onqueue, i);\n       if (dir == FORWARD)\n \t{\n \t  /*  Calculate <conf_op> of predecessor_outs */\n-\t  for (e = bb->pred; e != 0; e = e->pred_next)\n-\t    {\n-\t      if (e->src == ENTRY_BLOCK_PTR)\n-\t\t{\n-\t\t  sbitmap_zero (in[i]);\n-\t\t  continue;\n-\t\t}\n-\t      sbitmap_copy (in[i], out[e->src->index]);\n-\t      break;\n-\t    }\n-\t  if (e == 0)\n-\t    sbitmap_zero (in[i]);\n+\t  bitmap_zero (in[i]);\n \t  for (e = bb->pred; e != 0; e = e->pred_next)\n \t    {\n \t      if (e->src == ENTRY_BLOCK_PTR)\n \t\tcontinue;\n \t      switch (conf_op)\n \t\t{\n \t\tcase UNION:\n-\t\t  sbitmap_a_or_b (in[i], in[i], out[e->src->index]);\n+\t\t  bitmap_a_or_b (in[i], in[i], out[e->src->index]);\n \t\t  break;\n \t\tcase INTERSECTION:\n-\t\t  sbitmap_a_and_b (in[i], in[i], out[e->src->index]);\n+\t\t  bitmap_a_and_b (in[i], in[i], out[e->src->index]);\n \t\t  break;\n \t\t}\n \t    }\n \t}\n       else \n \t{\n \t  /* Calculate <conf_op> of successor ins */\n-\t  sbitmap_zero (out[i]);\n+\t  bitmap_zero(out[i]);\n \t  for (e = bb->succ; e != 0; e = e->succ_next)\n \t    {\n \t      if (e->dest == EXIT_BLOCK_PTR)\n \t\tcontinue;\n \t      switch (conf_op)\n \t\t{\t\n \t\tcase UNION:\n-\t\t  sbitmap_a_or_b (out[i], out[i], in[e->dest->index]);\n+\t\t  bitmap_a_or_b (out[i], out[i], in[e->dest->index]);\n \t\t  break;\n \t\tcase INTERSECTION:\n-\t\t  sbitmap_a_and_b (out[i], out[i], in[e->dest->index]);\n+\t\t  bitmap_a_and_b (out[i], out[i], in[e->dest->index]);\n \t\t  break;\n \t\t}\n \t    }\n \t}      \n       /* Common part */\n       (*transfun)(i, &changed, in[i], out[i], gen[i], kill[i], data);\n-\n+      RESET_BIT (pending, i);\n       if (changed)\n \t{\n \t  if (dir == FORWARD)\n \t    {\n \t      for (e = bb->succ; e != 0; e = e->succ_next)\n \t\t{\n-\t\t  if (e->dest == EXIT_BLOCK_PTR)\n+\t\t  if (e->dest == EXIT_BLOCK_PTR || e->dest->index == i)\n \t\t    continue;\n-\t\t  if (!TEST_BIT (onqueue, e->dest->index))\n-\t\t    { \n-\t\t      SET_BIT (onqueue, e->dest->index);\n-\t\t      fibheap_insert (worklist, \n-\t\t\t\t      order[e->dest->index], \n-\t\t\t\t      (void *)e->dest->index);\n-\t\t    }\n+\t\t  SET_BIT (pending, e->dest->index);\n \t\t}\n \t    }\n \t  else\n \t    {\n \t      for (e = bb->pred; e != 0; e = e->pred_next)\n \t\t{\n-\t\t  if (e->src == ENTRY_BLOCK_PTR)\n+\t\t  if (e->src == ENTRY_BLOCK_PTR || e->dest->index == i)\n \t\t    continue;\n-\t\t  if (!TEST_BIT (onqueue, e->src->index))\n-\t\t    {\n-\t\t      SET_BIT (onqueue, e->src->index);\n-\t\t      fibheap_insert (worklist, \n-\t\t\t\t      order[e->src->index], \n-\t\t\t\t      (void *)e->src->index);\n-\t\t    }\n-\n+\t\t  SET_BIT (pending, e->src->index);\n \t\t}\n \t    }\n \t}\n     }\n-  sbitmap_free (onqueue);\n-  fibheap_delete (worklist);\n-  \n+  if (dir == FORWARD)\n+    {\n+      for (e = bb->succ; e != 0; e = e->succ_next)\n+\t{\n+\t  if (e->dest == EXIT_BLOCK_PTR || e->dest->index == i)\n+\t    continue;\n+\t  if (!TEST_BIT (visited, e->dest->index))\n+\t    hybrid_search_bitmap (e->dest, in, out, gen, kill, dir, \n+\t\t\t\t  conf_op, transfun, visited, pending, \n+\t\t\t\t  data);\n+\t}\n+    }\n+  else\n+    {\n+      for (e = bb->pred; e != 0; e = e->pred_next)\n+\t{\n+\t  if (e->src == ENTRY_BLOCK_PTR || e->src->index == i)\n+\t    continue;\n+\t  if (!TEST_BIT (visited, e->src->index))\n+\t    hybrid_search_bitmap (e->src, in, out, gen, kill, dir, \n+\t\t\t\t  conf_op, transfun, visited, pending, \n+\t\t\t\t  data);\n+\t}\n+    }\n }\n-/* Exactly the same as iterative_dataflow_sbitmap, except it works on\n-   bitmaps instead */\n-void\n-iterative_dataflow_bitmap (in, out, gen, kill, blocks, \n-\t\t\t   dir, conf_op, transfun, order, data)     \n-     bitmap *in, *out, *gen, *kill;\n-     bitmap blocks;\n+\n+\n+/* Hybrid search for sbitmaps, rather than bitmaps.  */\n+static void \n+hybrid_search_sbitmap (block, in, out, gen, kill, dir, \n+\t\t       conf_op, transfun, visited, pending,\n+\t\t       data)\n+     basic_block block;\n+     sbitmap *in, *out, *gen, *kill;\n      enum df_flow_dir dir;\n      enum df_confluence_op conf_op;\n-     transfer_function_bitmap transfun;\n-     int *order;\n+     transfer_function_sbitmap transfun;\n+     sbitmap visited;\n+     sbitmap pending;\n      void *data;\n {\n   int changed;\n-  int i;\n-  fibheap_t worklist;\n-  sbitmap onqueue;\n-  basic_block bb;\n-\n-  onqueue = sbitmap_alloc (n_basic_blocks);\n-  sbitmap_zero (onqueue);\n-  worklist = fibheap_new ();\n-  EXECUTE_IF_SET_IN_BITMAP (blocks, 0, i,\n-  {\n-    fibheap_insert (worklist, order[i], (void *) i); \n-    SET_BIT (onqueue, i);\n-    if (dir == FORWARD)\n-      {\n-\tbitmap_copy (out[i], gen[i]);\n-      }\n-    else\n-      {\n-\tbitmap_copy (in[i], gen[i]);\n-      }\n-    \n-  });\n-  while (!fibheap_empty (worklist))\n-    {\n-      edge e;\n-      i = (int) fibheap_extract_min  (worklist);\n-      changed = 0;\n-      bb = BASIC_BLOCK (i);\n-      RESET_BIT (onqueue, i);\n-      \n+  int i = block->index;\n+  edge e;\n+  basic_block bb= block;\n+  SET_BIT (visited, block->index);\n+  if (TEST_BIT (pending, block->index))\n+    {\n       if (dir == FORWARD)\n \t{\n \t  /*  Calculate <conf_op> of predecessor_outs */\n-\t  bitmap_zero (in[i]);\n+\t  sbitmap_zero (in[i]);\n \t  for (e = bb->pred; e != 0; e = e->pred_next)\n \t    {\n \t      if (e->src == ENTRY_BLOCK_PTR)\n \t\tcontinue;\n \t      switch (conf_op)\n \t\t{\n \t\tcase UNION:\n-\t\t  bitmap_a_or_b (in[i], in[i], out[e->src->index]);\n+\t\t  sbitmap_a_or_b (in[i], in[i], out[e->src->index]);\n \t\t  break;\n \t\tcase INTERSECTION:\n-\t\t  bitmap_a_and_b (in[i], in[i], out[e->src->index]);\n+\t\t  sbitmap_a_and_b (in[i], in[i], out[e->src->index]);\n \t\t  break;\n \t\t}\n \t    }\n \t}\n       else \n \t{\n \t  /* Calculate <conf_op> of successor ins */\n-\t  bitmap_zero(out[i]);\n+\t  sbitmap_zero(out[i]);\n \t  for (e = bb->succ; e != 0; e = e->succ_next)\n \t    {\n \t      if (e->dest == EXIT_BLOCK_PTR)\n \t\tcontinue;\n \t      switch (conf_op)\n \t\t{\t\n \t\tcase UNION:\n-\t\t  bitmap_a_or_b (out[i], out[i], in[e->dest->index]);\n+\t\t  sbitmap_a_or_b (out[i], out[i], in[e->dest->index]);\n \t\t  break;\n \t\tcase INTERSECTION:\n-\t\t  bitmap_a_and_b (out[i], out[i], in[e->dest->index]);\n+\t\t  sbitmap_a_and_b (out[i], out[i], in[e->dest->index]);\n \t\t  break;\n \t\t}\n \t    }\n \t}      \n       /* Common part */\n       (*transfun)(i, &changed, in[i], out[i], gen[i], kill[i], data);\n-\n+      RESET_BIT (pending, i);\n       if (changed)\n \t{\n \t  if (dir == FORWARD)\n \t    {\n \t      for (e = bb->succ; e != 0; e = e->succ_next)\n \t\t{\n-\t\t  if (e->dest == EXIT_BLOCK_PTR)\n+\t\t  if (e->dest == EXIT_BLOCK_PTR || e->dest->index == i)\n \t\t    continue;\n-\t\t  if (!TEST_BIT (onqueue, e->dest->index))\n-\t\t    { \n-\t\t      SET_BIT (onqueue, e->dest->index);\n-\t\t      fibheap_insert (worklist, \n-\t\t\t\t      order[e->dest->index], \n-\t\t\t\t      (void *)e->dest->index);\n-\t\t    }\n+\t\t  SET_BIT (pending, e->dest->index);\n \t\t}\n \t    }\n \t  else\n \t    {\n \t      for (e = bb->pred; e != 0; e = e->pred_next)\n \t\t{\n-\t\t  if (e->src == ENTRY_BLOCK_PTR)\n+\t\t  if (e->src == ENTRY_BLOCK_PTR || e->dest->index == i)\n \t\t    continue;\n-\t\t  if (!TEST_BIT (onqueue, e->src->index))\n-\t\t    {\n-\t\t      SET_BIT (onqueue, e->src->index);\n-\t\t      fibheap_insert (worklist, \n-\t\t\t\t      order[e->src->index], \n-\t\t\t\t      (void *)e->src->index);\n-\t\t    }\n-\n+\t\t  SET_BIT (pending, e->src->index);\n \t\t}\n \t    }\n \t}\n     }\n-  sbitmap_free (onqueue);\n+  if (dir == FORWARD)\n+    {\n+      for (e = bb->succ; e != 0; e = e->succ_next)\n+\t{\n+\t  if (e->dest == EXIT_BLOCK_PTR || e->dest->index == i)\n+\t    continue;\n+\t  if (!TEST_BIT (visited, e->dest->index))\n+\t    hybrid_search_sbitmap (e->dest, in, out, gen, kill, dir, \n+\t\t\t\t   conf_op, transfun, visited, pending, \n+\t\t\t\t   data);\n+\t}\n+    }\n+  else\n+    {\n+      for (e = bb->pred; e != 0; e = e->pred_next)\n+\t{\n+\t  if (e->src == ENTRY_BLOCK_PTR || e->src->index == i)\n+\t    continue;\n+\t  if (!TEST_BIT (visited, e->src->index))\n+\t    hybrid_search_sbitmap (e->src, in, out, gen, kill, dir, \n+\t\t\t\t   conf_op, transfun, visited, pending, \n+\t\t\t\t   data);\n+\t}\n+    }\n+}\n+\n+\n+\n+\n+/* gen = GEN set.\n+   kill = KILL set.\n+   in, out = Filled in by function.\n+   blocks = Blocks to analyze.\n+   dir = Dataflow direction.\n+   conf_op = Confluence operation.\n+   transfun = Transfer function.\n+   order = Order to iterate in. (Should map block numbers -> order)\n+   data = Whatever you want.  It's passed to the transfer function.\n+   \n+   This function will perform iterative bitvector dataflow, producing\n+   the in and out sets.  Even if you only want to perform it for a\n+   small number of blocks, the vectors for in and out must be large\n+   enough for *all* blocks, because changing one block might affect\n+   others.  However, it'll only put what you say to analyze on the\n+   initial worklist.\n+   \n+   For forward problems, you probably want to pass in a mapping of\n+   block number to rc_order (like df->inverse_rc_map).\n+*/\n+void\n+iterative_dataflow_sbitmap (in, out, gen, kill, blocks, \n+\t\t\t    dir, conf_op, transfun, order, data)     \n+     sbitmap *in, *out, *gen, *kill;\n+     bitmap blocks;\n+     enum df_flow_dir dir;\n+     enum df_confluence_op conf_op;\n+     transfer_function_sbitmap transfun;\n+     int *order;\n+     void *data;\n+{\n+  int i;\n+  fibheap_t worklist;\n+  basic_block bb;\n+  sbitmap visited, pending;\n+  pending = sbitmap_alloc (n_basic_blocks);\n+  visited = sbitmap_alloc (n_basic_blocks);\n+  sbitmap_zero (pending);\n+  sbitmap_zero (visited);\n+  worklist = fibheap_new ();\n+  EXECUTE_IF_SET_IN_BITMAP (blocks, 0, i,\n+  {\n+    fibheap_insert (worklist, order[i], (void *) i); \n+    SET_BIT (pending, i);\n+    if (dir == FORWARD)\n+      sbitmap_copy (out[i], gen[i]);\n+    else\n+      sbitmap_copy (in[i], gen[i]);\n+  });\n+  while (sbitmap_first_set_bit (pending) != -1)\n+    {\n+      while (!fibheap_empty (worklist))\n+\t{\n+\t  i = (int) fibheap_extract_min  (worklist);\n+\t  bb = BASIC_BLOCK (i);\n+\t  if (!TEST_BIT (visited, bb->index))\n+\t    hybrid_search_sbitmap (bb, in, out, gen, kill, dir, \n+\t\t\t\t   conf_op, transfun, visited, pending, \n+\t\t\t\t   data);\n+\t}\n+      if (sbitmap_first_set_bit (pending) != -1)\n+\t{\n+\t  EXECUTE_IF_SET_IN_BITMAP (blocks, 0, i,\n+\t  {\n+\t    fibheap_insert (worklist, order[i], (void *) i);\n+\t  });\n+\t  sbitmap_zero (visited);\n+\t}\n+      else\n+\t{\n+\t  break;\n+\t}      \n+    }\n+  sbitmap_free (pending);\n+  sbitmap_free (visited);\n   fibheap_delete (worklist);\n-  \n+}\n+\n+/* Exactly the same as iterative_dataflow_sbitmap, except it works on\n+   bitmaps instead */\n+void\n+iterative_dataflow_bitmap (in, out, gen, kill, blocks, \n+\t\t\t   dir, conf_op, transfun, order, data)     \n+     bitmap *in, *out, *gen, *kill;\n+     bitmap blocks;\n+     enum df_flow_dir dir;\n+     enum df_confluence_op conf_op;\n+     transfer_function_bitmap transfun;\n+     int *order;\n+     void *data;\n+{\n+  int i;\n+  fibheap_t worklist;\n+  basic_block bb;\n+  sbitmap visited, pending;\n+  pending = sbitmap_alloc (n_basic_blocks);\n+  visited = sbitmap_alloc (n_basic_blocks);\n+  sbitmap_zero (pending);\n+  sbitmap_zero (visited);\n+  worklist = fibheap_new ();\n+  EXECUTE_IF_SET_IN_BITMAP (blocks, 0, i,\n+  {\n+    fibheap_insert (worklist, order[i], (void *) i); \n+    SET_BIT (pending, i);\n+    if (dir == FORWARD)\n+      bitmap_copy (out[i], gen[i]);\n+    else\n+      bitmap_copy (in[i], gen[i]);\n+  });\n+  while (sbitmap_first_set_bit (pending) != -1)\n+    {\n+      while (!fibheap_empty (worklist))\n+\t{\n+\t  i = (int) fibheap_extract_min  (worklist);\n+\t  bb = BASIC_BLOCK (i);\n+\t  if (!TEST_BIT (visited, bb->index))\n+\t    hybrid_search_bitmap (bb, in, out, gen, kill, dir, \n+\t\t\t\t  conf_op, transfun, visited, pending, \n+\t\t\t\t  data);\n+\t}\n+      if (sbitmap_first_set_bit (pending) != -1)\n+\t{\n+\t  EXECUTE_IF_SET_IN_BITMAP (blocks, 0, i,\n+\t  {\n+\t    fibheap_insert (worklist, order[i], (void *) i);\n+\t  });\n+\t  sbitmap_zero (visited);\n+\t}\n+      else\n+\t{\n+\t  break;\n+\t}     \n+    }\n+  sbitmap_free (pending);\n+  sbitmap_free (visited);\n+  fibheap_delete (worklist);  \n }"}]}