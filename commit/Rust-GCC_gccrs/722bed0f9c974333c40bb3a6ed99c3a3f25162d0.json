{"sha": "722bed0f9c974333c40bb3a6ed99c3a3f25162d0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzIyYmVkMGY5Yzk3NDMzM2M0MGJiM2E2ZWQ5OWMzYTNmMjUxNjJkMA==", "commit": {"author": {"name": "Alex Samuel", "email": "samuel@codesourcery.com", "date": "2000-07-30T23:37:04Z"}, "committer": {"name": "Alex Samuel", "email": "samuel@gcc.gnu.org", "date": "2000-07-30T23:37:04Z"}, "message": "mangle.c (DECL_TEMPLATE_ID_P): Remove.\n\n\t* mangle.c (DECL_TEMPLATE_ID_P): Remove.\n\t(CLASSTYEP_TEMPLATE_ID_P): Check template info, and context when\n\tascertaining primaryness.\n\t(G): Remove template_args.\n\t(decl_is_template_id): New function.\n\t(write_encoding): Use decl_is_template_id.\n\t(write_name): Likewise.  Handle type_decls.  Get main variant of\n\ttype decls.\n\t(write_nested_name): Likewise.\n\t(write_prefix): Likewise.\n\t(write_template_prefix): Likewise.\n\t(write_special_name_constructor): Remove defunct production from\n\tcomment.\n\t(write_bare_function_type): Remove comment about absent parameter.\n\t(write_template_template_arg): Add missing grammar production to\n\tcomment.\n\nFrom-SVN: r35355", "tree": {"sha": "ba7a10bab18f248255919c0c392770a86e35ff54", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ba7a10bab18f248255919c0c392770a86e35ff54"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/722bed0f9c974333c40bb3a6ed99c3a3f25162d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/722bed0f9c974333c40bb3a6ed99c3a3f25162d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/722bed0f9c974333c40bb3a6ed99c3a3f25162d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/722bed0f9c974333c40bb3a6ed99c3a3f25162d0/comments", "author": null, "committer": null, "parents": [{"sha": "4e07a9eadbf4c8bf943964c95a664494508cc28e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e07a9eadbf4c8bf943964c95a664494508cc28e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e07a9eadbf4c8bf943964c95a664494508cc28e"}], "stats": {"total": 196, "additions": 131, "deletions": 65}, "files": [{"sha": "ad35dd85f3f11a61d4748200608b787c618e24c9", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/722bed0f9c974333c40bb3a6ed99c3a3f25162d0/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/722bed0f9c974333c40bb3a6ed99c3a3f25162d0/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=722bed0f9c974333c40bb3a6ed99c3a3f25162d0", "patch": "@@ -1,3 +1,22 @@\n+2000-07-30  Alex Samuel  <samuel@codesourcery.com>\n+\n+\t* mangle.c (DECL_TEMPLATE_ID_P): Remove.\n+\t(CLASSTYEP_TEMPLATE_ID_P): Check template info, and context when\n+\tascertaining primaryness.\n+\t(G): Remove template_args.\n+\t(decl_is_template_id): New function.\n+\t(write_encoding): Use decl_is_template_id.\n+\t(write_name): Likewise.  Handle type_decls.  Get main variant of\n+\ttype decls.\n+\t(write_nested_name): Likewise.\n+\t(write_prefix): Likewise.\n+\t(write_template_prefix): Likewise.\n+\t(write_special_name_constructor): Remove defunct production from\n+\tcomment.\n+\t(write_bare_function_type): Remove comment about absent parameter.\n+\t(write_template_template_arg): Add missing grammar production to\n+\tcomment.\n+\n 2000-07-27  Jason Merrill  <jason@redhat.com>\n \n \t* decl.c (duplicate_decls): If common_type produces a non-typedef"}, {"sha": "c5601185e41b8903492262c463028f935f6994f6", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 112, "deletions": 65, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/722bed0f9c974333c40bb3a6ed99c3a3f25162d0/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/722bed0f9c974333c40bb3a6ed99c3a3f25162d0/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=722bed0f9c974333c40bb3a6ed99c3a3f25162d0", "patch": "@@ -74,27 +74,25 @@\n # define MANGLE_TRACE_TREE(FN, NODE)\n #endif\n \n-/* Non-zero if NODE is a template-id.  */\n-#define DECL_TEMPLATE_ID_P(NODE)\t\t\t\t\\\n-  (DECL_LANG_SPECIFIC (NODE) != NULL \t\t\t\t\\\n-   && DECL_USE_TEMPLATE (NODE)\t\t\t\t\t\\\n-   && PRIMARY_TEMPLATE_P (DECL_TI_TEMPLATE (NODE)))\n-\n-/* Non-zero if NODE is a class template-id.  */\n-#define CLASSTYPE_TEMPLATE_ID_P(NODE)\t\t\t\t\\\n-  (TYPE_LANG_SPECIFIC (NODE) != NULL \t\t\t\t\\\n-   && CLASSTYPE_USE_TEMPLATE (NODE)\t\t\t\t\\\n-   && PRIMARY_TEMPLATE_P (CLASSTYPE_TI_TEMPLATE (NODE)))\n+/* Non-zero if NODE is a class template-id.  We can't rely on\n+   CLASSTYPE_USE_TEMPLATE here because of tricky bugs in the parser\n+   that hard to distinguish A<T> from A, where A<T> is the type as\n+   instantiated outside of the template, and A is the type used\n+   without parameters inside the template.  The logic here is\n+   historical magic that apparently produces the right result.  */\n+#define CLASSTYPE_TEMPLATE_ID_P(NODE)\t\t\t\t      \\\n+  (TYPE_LANG_SPECIFIC (NODE) != NULL \t\t\t\t      \\\n+   && CLASSTYPE_TEMPLATE_INFO (NODE) != NULL                          \\\n+   && (PRIMARY_TEMPLATE_P (CLASSTYPE_TI_TEMPLATE (NODE))              \\\n+       || (TREE_CODE (CP_DECL_CONTEXT (CLASSTYPE_TI_TEMPLATE (NODE))) \\\n+           == FUNCTION_DECL)))\n \n /* Things we only need one of.  This module is not reentrant.  */\n static struct globals\n {\n   /* The name in which we're building the mangled name.  */\n   struct obstack name_obstack;\n \n-  /* The current innermost template args.  */\n-  tree template_args;\n-\n   /* An array of the current substitution candidates, in the order\n      we've seen them.  */\n   varray_type substitutions;\n@@ -136,6 +134,8 @@ integer_type_codes[itk_none] =\n   'y'   /* itk_unsigned_long_long */\n };\n \n+static int decl_is_template_id PARAMS ((tree, tree*));\n+\n /* Functions for handling substitutions.  */\n \n static inline tree canonicalize_for_substitution PARAMS ((tree));\n@@ -228,6 +228,50 @@ static tree mangle_special_for_type PARAMS ((tree, const char *));\n #define write_unsigned_number(NUMBER) \\\n   write_number (NUMBER, /*unsigned_p=*/1, 10)\n \n+/* If DECL is a template instance, return non-zero and, if\n+   TEMPLATE_INFO is non-NULL, set *TEMPLATE_INFO to its template info.\n+   Otherwise return zero.  */\n+\n+static int\n+decl_is_template_id (decl, template_info)\n+     tree decl;\n+     tree* template_info;\n+{\n+  if (TREE_CODE (decl) == TYPE_DECL)\n+    {\n+      /* TYPE_DECLs are handled specially.  Look at its type to decide\n+\t if this is a template instantiation.  */\n+      tree type = TREE_TYPE (decl);\n+\n+      if (CLASS_TYPE_P (type) && CLASSTYPE_TEMPLATE_ID_P (type))\n+\t{\n+\t  if (template_info != NULL)\n+\t    /* For a templated TYPE_DECL, the template info is hanging\n+\t       off the type.  */\n+\t    *template_info = CLASSTYPE_TEMPLATE_INFO (type);\n+\t  return 1;\n+\t}\n+    } \n+  else\n+    {\n+      /* Check if this is a primary template.  */\n+      if (DECL_LANG_SPECIFIC (decl) != NULL\n+\t  && DECL_USE_TEMPLATE (decl)\n+\t  && PRIMARY_TEMPLATE_P (DECL_TI_TEMPLATE (decl))\n+\t  && TREE_CODE (decl) != TEMPLATE_DECL)\n+\t{\n+\t  if (template_info != NULL)\n+\t    /* For most templated decls, the template info is hanging\n+\t       off the decl.  */\n+\t    *template_info = DECL_TEMPLATE_INFO (decl);\n+\t  return 1;\n+\t}\n+    }\n+\n+  /* It's not a template id.  */\n+  return 0;\n+}\n+\n /* Produce debugging output of current substitution candidates.  */\n \n static void\n@@ -591,12 +635,12 @@ write_encoding (decl)\n     {\n       tree fn_type;\n \n-      if (DECL_TEMPLATE_ID_P (decl))\n+      if (decl_is_template_id (decl, NULL))\n \tfn_type = get_mostly_instantiated_function_type (decl, NULL, NULL);\n       else\n \tfn_type = TREE_TYPE (decl);\n \n-      write_bare_function_type (fn_type, DECL_TEMPLATE_ID_P (decl));\n+      write_bare_function_type (fn_type, decl_is_template_id (decl, NULL));\n     }\n }\n \n@@ -611,28 +655,30 @@ write_name (decl)\n {\n   tree context;\n \n-  context = CP_DECL_CONTEXT (decl);\n-\n   MANGLE_TRACE_TREE (\"name\", decl);\n \n+  if (TREE_CODE (decl) == TYPE_DECL)\n+    {\n+      /* In case this is a typedef, fish out the corresponding\n+\t TYPE_DECL for the main variant.  */\n+      decl = TYPE_NAME (TYPE_MAIN_VARIANT (TREE_TYPE (decl)));\n+      context = TYPE_CONTEXT (TYPE_MAIN_VARIANT (TREE_TYPE (decl)));\n+    }\n+  else\n+    context = (DECL_CONTEXT (decl) == NULL) ? NULL : CP_DECL_CONTEXT (decl);\n+\n   /* Decls in :: or ::std scope are treated specially.  */\n-  if (context == global_namespace || DECL_NAMESPACE_STD_P (context))\n+  if (context == NULL \n+      || context == global_namespace \n+      || DECL_NAMESPACE_STD_P (context))\n     {\n-      if (decl && DECL_TEMPLATE_ID_P (decl))\n+      tree template_info;\n+      /* Is this a template instance?  */\n+      if (decl_is_template_id (decl, &template_info))\n \t{\n-\t  /* Templated decls get an <unqualified-template-name>.  */\n-\t  write_unscoped_template_name (DECL_TI_TEMPLATE (decl));\n-\t  write_template_args (DECL_TI_ARGS (decl));\n-\t}\n-      else if (TREE_CODE (decl) == TYPE_DECL \n-\t       && CLASSTYPE_TEMPLATE_ID_P (TREE_TYPE (decl)))\n-\t{\n-\t  tree type;\n-\n-\t  /* Templated decls get an <unqualified-template-name>.  */\n-\t  type = TREE_TYPE (decl);\n-\t  write_unscoped_template_name (TYPE_TI_TEMPLATE (type));\n-\t  write_template_args (TYPE_TI_ARGS (type));\n+\t  /* Yes: use <unscoped-template-name>.  */\n+\t  write_unscoped_template_name (TI_TEMPLATE (template_info));\n+\t  write_template_args (TI_ARGS (template_info));\n \t}\n       else\n \t/* Everything else gets an <unqualified-name>.  */\n@@ -696,6 +742,8 @@ static void\n write_nested_name (decl)\n      tree decl;\n {\n+  tree template_info;\n+\n   MANGLE_TRACE_TREE (\"nested-name\", decl);\n \n   write_char ('N');\n@@ -710,18 +758,16 @@ write_nested_name (decl)\n \twrite_char ('K');\n     }\n \n-  if (DECL_TEMPLATE_ID_P (decl))\n+  /* Is this a template instance?  */\n+  if (decl_is_template_id (decl, &template_info))\n     {\n+      /* Yes, use <template-prefix>.  */\n       write_template_prefix (decl);\n-      write_template_args (DECL_TI_ARGS (decl));\n-    }\n-  else if (CLASSTYPE_TEMPLATE_ID_P (TREE_TYPE (decl)))\n-    {\n-      write_template_prefix (decl);\n-      write_template_args (CLASSTYPE_TI_ARGS (TREE_TYPE (decl)));\n+      write_template_args (TI_ARGS (template_info));\n     }\n   else\n     {\n+      /* No, just use <prefix>  */\n       write_prefix (DECL_CONTEXT (decl));\n       write_component (decl);\n     }\n@@ -738,40 +784,42 @@ write_prefix (node)\n      tree node;\n {\n   tree decl;\n-  tree type;\n-  tree context;\n+  /* Non-NULL if NODE represents a template-id.  */\n+  tree template_info = NULL;\n+\n+  MANGLE_TRACE_TREE (\"prefix\", node);\n \n   if (node == NULL\n       || node == global_namespace)\n     return;\n \n-  MANGLE_TRACE_TREE (\"prefix\", node);\n-\n-  decl = DECL_P (node) ? node : TYPE_NAME (node);\n-  type = DECL_P (node) ? TREE_TYPE (node) : node;\n-  context = CP_DECL_CONTEXT (decl);\n-\n   if (find_substitution (node))\n     return;\n \n-  /* Check if this is a template-id.  For a template member, the\n-     template info will be hanging off the decl.  */\n-  if (DECL_TEMPLATE_ID_P (decl))\n+  if (DECL_P (node))\n+    /* Node is a decl.  */\n     {\n-      write_template_prefix (decl);\n-      write_template_args (DECL_TI_ARGS (decl));\n+      decl = node;\n+      decl_is_template_id (decl, &template_info);\n     }\n-  /* For a template class, the template info will be hanging off the\n-     type.  */\n-  else if (type && CLASSTYPE_TEMPLATE_ID_P (type))\n+  else\n+    /* Node is a type.  */\n+    {\n+      decl = TYPE_NAME (node);\n+      if (CLASSTYPE_TEMPLATE_ID_P (node))\n+\ttemplate_info = CLASSTYPE_TEMPLATE_INFO (node);\n+    }\n+\n+  if (template_info != NULL)\n+    /* Templated.  */\n     {\n-      write_template_prefix (type);\n-      write_template_args (CLASSTYPE_TI_ARGS (type));\n+      write_template_prefix (decl);\n+      write_template_args (TI_ARGS (template_info));\n     }\n   else\n     /* Not templated.  */\n     {\n-      write_prefix (context);\n+      write_prefix (CP_DECL_CONTEXT (decl));\n       write_component (decl);\n     }\n \n@@ -788,14 +836,15 @@ write_template_prefix (node)\n   tree decl = DECL_P (node) ? node : TYPE_NAME (node);\n   tree type = DECL_P (node) ? TREE_TYPE (node) : node;\n   tree context = CP_DECL_CONTEXT (decl);\n+  tree template_info;\n   tree template;\n   tree substitution;\n \n   MANGLE_TRACE_TREE (\"template-prefix\", node);\n \n   /* Find the template decl.  */\n-  if (DECL_TEMPLATE_ID_P (decl))\n-    template = DECL_TI_TEMPLATE (decl);\n+  if (decl_is_template_id (decl, &template_info))\n+    template = TI_TEMPLATE (template_info);\n   else if (CLASSTYPE_TEMPLATE_ID_P (type))\n     template = CLASSTYPE_TI_TEMPLATE (type);\n   else\n@@ -997,7 +1046,6 @@ write_identifier (identifier)\n      <special-name> ::= C1   # complete object constructor\n                     ::= C2   # base object constructor\n                     ::= C3   # complete object allocating constructor\n-                    ::= C4   # base object allocating constructor  \n \n    Currently, allocating constructors are never used. \n \n@@ -1436,9 +1484,7 @@ write_bare_function_type (type, include_return_type_p)\n \n /* Write the mangled representation of a method parameter list of\n    types given in PARM_LIST.  If METHOD_P is non-zero, the function is \n-   considered a non-static method, and the this parameter is omitted.\n-   If VARARGS_P is non-zero, an additional token designating varargs\n-   is appended.  */\n+   considered a non-static method, and the this parameter is omitted.  */\n \n static void\n write_method_parms (parm_list, method_p)\n@@ -1744,6 +1790,7 @@ write_template_template_arg (tree decl)\n /* Non-terminal <array-type>.  TYPE is an ARRAY_TYPE.  \n \n      <array-type> ::= A [</dimension/ number>] _ </element/ type>  \n+                  ::= A <expression> _ </element/ type>\n \n      \"Array types encode the dimension (number of elements) and the\n      element type. For variable length arrays, the dimension (but not"}]}