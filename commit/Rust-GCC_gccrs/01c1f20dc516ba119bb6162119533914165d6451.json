{"sha": "01c1f20dc516ba119bb6162119533914165d6451", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDFjMWYyMGRjNTE2YmExMTliYjYxNjIxMTk1MzM5MTQxNjVkNjQ1MQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2012-03-12T10:04:34Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2012-03-12T10:04:34Z"}, "message": "re PR tree-optimization/52533 (ice in remove_range_assertions)\n\n\tPR tree-optimization/52533\n\t* tree-vrp.c (register_edge_assert_for_2): Use double_int\n\ttype for mask, only handle shifts by non-zero in-range\n\tshift count, for LE_EXPR and GT_EXPR if new_val is\n\tmaximum, don't add the assertion.\n\n\t* gcc.c-torture/compile/pr52533.c: New test.\n\nFrom-SVN: r185219", "tree": {"sha": "92d75a9c7880a8f395fec4f461dab201f1466a0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/92d75a9c7880a8f395fec4f461dab201f1466a0a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/01c1f20dc516ba119bb6162119533914165d6451", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01c1f20dc516ba119bb6162119533914165d6451", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01c1f20dc516ba119bb6162119533914165d6451", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01c1f20dc516ba119bb6162119533914165d6451/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bf2eaa3f2de7adf678876909b33bf0f7c2eb2170", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf2eaa3f2de7adf678876909b33bf0f7c2eb2170", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf2eaa3f2de7adf678876909b33bf0f7c2eb2170"}], "stats": {"total": 86, "additions": 56, "deletions": 30}, "files": [{"sha": "da514e8a93533ca234d39f8fdfd5f0528670b017", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01c1f20dc516ba119bb6162119533914165d6451/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01c1f20dc516ba119bb6162119533914165d6451/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=01c1f20dc516ba119bb6162119533914165d6451", "patch": "@@ -1,3 +1,11 @@\n+2012-03-12  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/52533\n+\t* tree-vrp.c (register_edge_assert_for_2): Use double_int\n+\ttype for mask, only handle shifts by non-zero in-range\n+\tshift count, for LE_EXPR and GT_EXPR if new_val is\n+\tmaximum, don't add the assertion.\n+\n 2012-02-12  Kirill Yukhin  <kirill.yukhin@intel.com>\n \n \t* doc/invoke.texi: Document -mrtm option."}, {"sha": "4721de45ce15703ddf37742c1bc5bbe87c652cff", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01c1f20dc516ba119bb6162119533914165d6451/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01c1f20dc516ba119bb6162119533914165d6451/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=01c1f20dc516ba119bb6162119533914165d6451", "patch": "@@ -1,3 +1,8 @@\n+2012-03-12  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/52533\n+\t* gcc.c-torture/compile/pr52533.c: New test.\n+\n 2012-03-12  Kirill Yukhin  <kirill.yukhin@intel.com>\n \n \t* gcc.target/i386/rtm-xabort-1.c: New."}, {"sha": "82753cd73d64479fc730fef96784e8fe45122e1b", "filename": "gcc/testsuite/gcc.c-torture/compile/pr52533.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01c1f20dc516ba119bb6162119533914165d6451/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr52533.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01c1f20dc516ba119bb6162119533914165d6451/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr52533.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr52533.c?ref=01c1f20dc516ba119bb6162119533914165d6451", "patch": "@@ -0,0 +1,19 @@\n+/* PR tree-optimization/52533 */\n+\n+int\n+foo (unsigned char x)\n+{\n+  if (x <= 9)\n+    return '0' + x;\n+  else if (x <= 15)\n+    return 'a' + (x - 10);\n+  else\n+    return 0;\n+}\n+\n+void\n+bar (unsigned char x, unsigned char *y)\n+{\n+  y[0] = foo ((unsigned char) (x >> 4));\n+  y[1] = foo ((unsigned char) (x & 0x0f));\n+}"}, {"sha": "febe33f93c0fc2302dd321261ba23dcb5b32d1eb", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 24, "deletions": 30, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01c1f20dc516ba119bb6162119533914165d6451/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01c1f20dc516ba119bb6162119533914165d6451/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=01c1f20dc516ba119bb6162119533914165d6451", "patch": "@@ -4470,7 +4470,8 @@ register_edge_assert_for_2 (tree name, edge e, gimple_stmt_iterator bsi,\n       gimple def_stmt = SSA_NAME_DEF_STMT (name);\n       tree name2 = NULL_TREE, cst2 = NULL_TREE;\n       tree val2 = NULL_TREE;\n-      unsigned HOST_WIDE_INT mask[2] = { 0, 0 };\n+      double_int mask = double_int_zero;\n+      unsigned int prec = TYPE_PRECISION (TREE_TYPE (val));\n \n       /* Extract CST2 from the right shift.  */\n       if (is_gimple_assign (def_stmt)\n@@ -4480,23 +4481,13 @@ register_edge_assert_for_2 (tree name, edge e, gimple_stmt_iterator bsi,\n \t  cst2 = gimple_assign_rhs2 (def_stmt);\n \t  if (TREE_CODE (name2) == SSA_NAME\n \t      && host_integerp (cst2, 1)\n-\t      && (unsigned HOST_WIDE_INT) tree_low_cst (cst2, 1)\n-\t\t < 2 * HOST_BITS_PER_WIDE_INT\n \t      && INTEGRAL_TYPE_P (TREE_TYPE (name2))\n+\t      && IN_RANGE (tree_low_cst (cst2, 1), 1, prec - 1)\n+\t      && prec <= 2 * HOST_BITS_PER_WIDE_INT\n \t      && live_on_edge (e, name2)\n \t      && !has_single_use (name2))\n \t    {\n-\t      if ((unsigned HOST_WIDE_INT) tree_low_cst (cst2, 1)\n-\t\t  < HOST_BITS_PER_WIDE_INT)\n-\t\tmask[0] = ((unsigned HOST_WIDE_INT) 1\n-\t\t\t   << tree_low_cst (cst2, 1)) - 1;\n-\t      else\n-\t\t{\n-\t\t  mask[1] = ((unsigned HOST_WIDE_INT) 1\n-\t\t\t     << (tree_low_cst (cst2, 1)\n-\t\t\t\t - HOST_BITS_PER_WIDE_INT)) - 1;\n-\t\t  mask[0] = -1;\n-\t\t}\n+\t      mask = double_int_mask (tree_low_cst (cst2, 1));\n \t      val2 = fold_binary (LSHIFT_EXPR, TREE_TYPE (val), val, cst2);\n \t    }\n \t}\n@@ -4515,37 +4506,40 @@ register_edge_assert_for_2 (tree name, edge e, gimple_stmt_iterator bsi,\n \t    {\n \t      if (!TYPE_UNSIGNED (TREE_TYPE (val)))\n \t\t{\n-\t\t  unsigned int prec = TYPE_PRECISION (TREE_TYPE (val));\n \t\t  tree type = build_nonstandard_integer_type (prec, 1);\n \t\t  tmp = build1 (NOP_EXPR, type, name2);\n \t\t  val2 = fold_convert (type, val2);\n \t\t}\n \t      tmp = fold_build2 (MINUS_EXPR, TREE_TYPE (tmp), tmp, val2);\n-\t      new_val = build_int_cst_wide (TREE_TYPE (tmp), mask[0], mask[1]);\n+\t      new_val = double_int_to_tree (TREE_TYPE (tmp), mask);\n \t      new_comp_code = comp_code == EQ_EXPR ? LE_EXPR : GT_EXPR;\n \t    }\n \t  else if (comp_code == LT_EXPR || comp_code == GE_EXPR)\n \t    new_val = val2;\n \t  else\n \t    {\n-\t      new_val = build_int_cst_wide (TREE_TYPE (val2),\n-\t\t\t\t\t    mask[0], mask[1]);\n-\t      new_val = fold_binary (BIT_IOR_EXPR, TREE_TYPE (val2),\n-\t\t\t\t     val2, new_val);\n+\t      mask = double_int_ior (tree_to_double_int (val2), mask);\n+\t      if (double_int_minus_one_p (double_int_sext (mask, prec)))\n+\t\tnew_val = NULL_TREE;\n+\t      else\n+\t\tnew_val = double_int_to_tree (TREE_TYPE (val2), mask);\n \t    }\n \n-\t  if (dump_file)\n+\t  if (new_val)\n \t    {\n-\t      fprintf (dump_file, \"Adding assert for \");\n-\t      print_generic_expr (dump_file, name2, 0);\n-\t      fprintf (dump_file, \" from \");\n-\t      print_generic_expr (dump_file, tmp, 0);\n-\t      fprintf (dump_file, \"\\n\");\n-\t    }\n+\t      if (dump_file)\n+\t\t{\n+\t\t  fprintf (dump_file, \"Adding assert for \");\n+\t\t  print_generic_expr (dump_file, name2, 0);\n+\t\t  fprintf (dump_file, \" from \");\n+\t\t  print_generic_expr (dump_file, tmp, 0);\n+\t\t  fprintf (dump_file, \"\\n\");\n+\t\t}\n \n-\t  register_new_assert_for (name2, tmp, new_comp_code, new_val,\n-\t\t\t\t   NULL, e, bsi);\n-\t  retval = true;\n+\t      register_new_assert_for (name2, tmp, new_comp_code, new_val,\n+\t\t\t\t       NULL, e, bsi);\n+\t      retval = true;\n+\t    }\n \t}\n     }\n "}]}