{"sha": "031905948adabb18c9a4f1fe9156cbf5aea964b2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDMxOTA1OTQ4YWRhYmIxOGM5YTRmMWZlOTE1NmNiZjVhZWE5NjRiMg==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2005-11-03T15:39:48Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2005-11-03T15:39:48Z"}, "message": "re PR tree-optimization/24351 (ICE in do_simple_structure_copy with some C++ code)\n\n2005-11-03  Daniel Berlin  <dberlin@dberlin.org>\n\n\tFix PR tree-optimization/24351\n\n\t* tree-ssa-structalias.c (struct variable_info): Add\n\tcollapsed_into.\n\t(get_varinfo_fc): New function to follow collapsing.\n\t(new_var_info): Set collapsed_to to NULL.\n\t(dump_constraint): Follow collapsing.\n\t(build_constraint_graph): Handle collapsing.\n\t(do_simple_structure_copy): Return false if something bad\n\thappened.\n\t(collapse_rest_of_var): New function.\n\t(do_structure_copy): Collapse if do_simple_structure_copy returns\n\tfalse.\n\nFrom-SVN: r106437", "tree": {"sha": "9dcbe9162456b36aa816086c8de751f7d2af94ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9dcbe9162456b36aa816086c8de751f7d2af94ad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/031905948adabb18c9a4f1fe9156cbf5aea964b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/031905948adabb18c9a4f1fe9156cbf5aea964b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/031905948adabb18c9a4f1fe9156cbf5aea964b2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/031905948adabb18c9a4f1fe9156cbf5aea964b2/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "08330ec2ad5a413f7e88fbb48092dd0d27000850", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08330ec2ad5a413f7e88fbb48092dd0d27000850", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08330ec2ad5a413f7e88fbb48092dd0d27000850"}], "stats": {"total": 260, "additions": 245, "deletions": 15}, "files": [{"sha": "a1b0097cb8dcb2e1ef4f84cb47b5109150a79143", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/031905948adabb18c9a4f1fe9156cbf5aea964b2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/031905948adabb18c9a4f1fe9156cbf5aea964b2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=031905948adabb18c9a4f1fe9156cbf5aea964b2", "patch": "@@ -1,3 +1,19 @@\n+2005-11-03  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\tFix PR tree-optimization/24351\n+\n+\t* tree-ssa-structalias.c (struct variable_info): Add\n+\tcollapsed_into.\n+\t(get_varinfo_fc): New function to follow collapsing.\n+\t(new_var_info): Set collapsed_to to NULL.\n+\t(dump_constraint): Follow collapsing.\n+\t(build_constraint_graph): Handle collapsing.\n+\t(do_simple_structure_copy): Return false if something bad\n+\thappened.\n+\t(collapse_rest_of_var): New function.\n+\t(do_structure_copy): Collapse if do_simple_structure_copy returns\n+\tfalse.\n+\t\n 2005-11-03  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \tPR middle-end/24589"}, {"sha": "40959effa5e50acea9d58f5075fdaa64777df901", "filename": "gcc/testsuite/g++.dg/tree-ssa/pr24351-1.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/031905948adabb18c9a4f1fe9156cbf5aea964b2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr24351-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/031905948adabb18c9a4f1fe9156cbf5aea964b2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr24351-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr24351-1.C?ref=031905948adabb18c9a4f1fe9156cbf5aea964b2", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+struct adaptor_base {\n+};\n+struct bound_argument {\n+  bound_argument();\n+};\n+template <class T_functor> struct adaptor_functor : public adaptor_base {\n+  explicit adaptor_functor(const T_functor& _A_functor) : functor_(_A_functor)\n+{\n+  }\n+  T_functor functor_;\n+  bound_argument bound_;\n+};\n+template <class T_functor> struct adapts : public adaptor_base {\n+  explicit adapts(const T_functor& _A_functor) : functor_(_A_functor) {\n+  }\n+  adaptor_functor<T_functor> functor_;\n+};\n+int main() {\n+  adapts<adapts<int> > a (adapts<int>(1));\n+}\n+\n+"}, {"sha": "cfc0e4a4cb0b7322b50bbbe7c63edb26254e5577", "filename": "gcc/testsuite/g++.dg/tree-ssa/pr24351-2.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/031905948adabb18c9a4f1fe9156cbf5aea964b2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr24351-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/031905948adabb18c9a4f1fe9156cbf5aea964b2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr24351-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr24351-2.C?ref=031905948adabb18c9a4f1fe9156cbf5aea964b2", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+struct adaptor_base {};\n+struct bound_argument {\n+  bound_argument();\n+};\n+struct adaptor_functorint : public adaptor_base {};\n+struct adaptsint : public adaptor_base {\n+  adaptsint(const int& _A_functor);\n+  adaptor_functorint functor_;\n+};\n+struct adaptor_functor_adaptsint {\n+  adaptor_functor_adaptsint(const adaptsint& _A_functor) : functor_(_A_functor)\n+  {}\n+  adaptsint functor_;\n+  bound_argument bound_;\n+};\n+struct adapts_adaptsint {\n+  adapts_adaptsint(const adaptsint& _A_functor) : functor_(_A_functor)\n+  {}\n+  adaptor_functor_adaptsint functor_;\n+};\n+int main() {\n+  adapts_adaptsint a (adaptsint(1));\n+}"}, {"sha": "09a3f9462f35e3d573e710018ee6545e6855152a", "filename": "gcc/testsuite/g++.dg/tree-ssa/pr24351-3.C", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/031905948adabb18c9a4f1fe9156cbf5aea964b2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr24351-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/031905948adabb18c9a4f1fe9156cbf5aea964b2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr24351-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr24351-3.C?ref=031905948adabb18c9a4f1fe9156cbf5aea964b2", "patch": "@@ -0,0 +1,101 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+namespace sigc {\n+    template <class T_type>     struct type_trait     {\n+    \ttypedef T_type& pass;\n+    \ttypedef const T_type& take;\n+    \ttypedef T_type* pointer;\n+    };\n+    template <class T_type>     struct type_trait<T_type&>     {\n+    \ttypedef T_type& pass;\n+    };\n+    template<>     struct type_trait<void>     {\n+    \ttypedef void pass;\n+    };\n+    template <class T_base, class T_derived>     struct is_base_and_derived     {\n+    \tstruct big {\n+  \t    char memory[64];\n+  \t};\n+    \tstatic big is_base_class_(...);\n+    \tstatic char is_base_class_(typename type_trait<T_base>::pointer);\n+    \tstatic const bool value = sizeof(is_base_class_(reinterpret_cast<typename type_trait<T_derived>::pointer>(0))) == sizeof(char);\n+    };\n+    struct nil;\n+    struct functor_base {\n+    };\n+    template <class T_functor, bool I_derives_functor_base=is_base_and_derived<functor_base,T_functor>::value>     struct functor_trait     {\n+    \ttypedef typename T_functor::result_type result_type;\n+    \ttypedef T_functor functor_type;\n+    };\n+    struct adaptor_base : public functor_base {\n+    };\n+    template <class T_functor, class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void, bool I_derives_adaptor_base=is_base_and_derived<adaptor_base,T_functor>::value>     struct deduce_result_type     {\n+    \ttypedef typename functor_trait<T_functor>::result_type type;\n+    };\n+    template <class T_functor>     struct adaptor_functor\n+\t: public adaptor_base     {\n+    \ttemplate <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void> \tstruct deduce_result_type \t{\n+  \t    typedef typename sigc::deduce_result_type<T_functor, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7>::type type;\n+  \t};\n+    \ttypedef typename functor_trait<T_functor>::result_type result_type;\n+    \ttemplate <class T_arg1,class T_arg2> \ttypename deduce_result_type<T_arg1,T_arg2>::type operator()(T_arg1 _A_arg1,T_arg2 _A_arg2) const \t{\n+  \t    return functor_(_A_arg1,_A_arg2);\n+  \t}\n+    \texplicit adaptor_functor(const T_functor& _A_functor) : functor_(_A_functor) {\n+\t}\n+    \tmutable T_functor functor_;\n+    };\n+    template <class T_functor, bool I_isadaptor = is_base_and_derived<adaptor_base, T_functor>::value>     struct adaptor_trait;\n+    template <class T_functor>     struct adaptor_trait<T_functor, true>     {\n+    \ttypedef T_functor adaptor_type;\n+    };\n+    template <class T_functor>     struct adaptor_trait<T_functor, false>     {\n+    \ttypedef typename functor_trait<T_functor>::functor_type functor_type;\n+    \ttypedef adaptor_functor<functor_type> adaptor_type;\n+    };\n+    template <class T_functor>     struct adapts\n+\t: public adaptor_base     {\n+    \ttypedef typename adaptor_trait<T_functor>::adaptor_type adaptor_type;\n+    \texplicit adapts(const T_functor& _A_functor) : functor_(_A_functor) {\n+\t}\n+    \tmutable adaptor_type functor_;\n+    };\n+    template <class T_type>     struct unwrap_reference     {\n+    \ttypedef T_type type;\n+    };\n+    template <class T_type>     class bound_argument     {\n+    public:\n+\tbound_argument(const T_type& _A_argument) : visited_(_A_argument) {\n+\t}\n+    \tinline T_type& invoke() {\n+\t}\n+    \tT_type visited_;\n+    };\n+    template <int I_location, class T_functor, class T_type1=nil,class T_type2=nil,class T_type3=nil,class T_type4=nil,class T_type5=nil,class T_type6=nil,class T_type7=nil>     struct bind_functor;\n+    template <class T_functor, class T_bound>     struct bind_functor<0, T_functor, T_bound, nil,nil,nil,nil,nil,nil> : public adapts<T_functor>     {\n+    \ttypedef typename adapts<T_functor>::adaptor_type adaptor_type;\n+    \ttemplate <class T_arg1=void,class T_arg2=void,class T_arg3=void,class T_arg4=void,class T_arg5=void,class T_arg6=void,class T_arg7=void> \tstruct deduce_result_type      \t{\n+  \t    typedef typename adaptor_type::template deduce_result_type<typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg1>::pass, typename type_trait<T_arg2>::pass, typename type_trait<T_arg3>::pass, typename type_trait<T_arg4>::pass, typename type_trait<T_arg5>::pass, typename type_trait<T_arg6>::pass>::type type;\n+  \t};\n+    \ttypedef typename adaptor_type::result_type result_type;\n+    \tresult_type operator()() \t{\n+  \t    return this->functor_.template operator()<typename type_trait<typename unwrap_reference<T_bound>::type>::pass> (bound_.invoke());\n+  \t}\n+    \ttemplate <class T_arg1> \ttypename deduce_result_type<T_arg1>::type operator()(T_arg1 _A_arg1) \t{\n+  \t    return this->functor_.template operator()<typename type_trait<typename unwrap_reference<T_bound>::type>::pass, typename type_trait<T_arg1>::pass>         (bound_.invoke(), _A_arg1);\n+  \t}\n+    \tbind_functor(typename type_trait<T_functor>::take _A_func, typename type_trait<T_bound>::take _A_bound) : adapts<T_functor>(_A_func), bound_(_A_bound) {\n+\t}\n+    \tbound_argument<T_bound> bound_;\n+    };\n+    template <int I_location, class T_bound1, class T_functor> inline bind_functor<I_location, T_functor, T_bound1>     bind(const T_functor& _A_func, T_bound1 _A_b1)     {\n+    \treturn bind_functor<I_location, T_functor, T_bound1>(_A_func, _A_b1);\n+    };\n+}\n+struct foo {\n+    typedef int result_type;\n+    int operator()(int i, int j);\n+};\n+int main() {\n+    sigc::bind<0>(sigc::bind<0>(foo(),7),8)();\n+}"}, {"sha": "cee6502ffea40ff41ae1ee6c00504ee0799316af", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 79, "deletions": 15, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/031905948adabb18c9a4f1fe9156cbf5aea964b2/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/031905948adabb18c9a4f1fe9156cbf5aea964b2/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=031905948adabb18c9a4f1fe9156cbf5aea964b2", "patch": "@@ -239,6 +239,11 @@ struct variable_info\n   /* Vector of complex constraints for this node.  Complex\n      constraints are those involving dereferences.  */\n   VEC(constraint_t,heap) *complex;\n+  \n+  /* Variable id this was collapsed to due to type unsafety.\n+     This should be unused completely after build_constraint_graph, or\n+     something is broken.  */\n+  struct variable_info *collapsed_to;\n };\n typedef struct variable_info *varinfo_t;\n \n@@ -258,11 +263,23 @@ static VEC(varinfo_t,heap) *varmap;\n /* Return the varmap element N */\n \n static inline varinfo_t\n-get_varinfo(unsigned int n)\n+get_varinfo (unsigned int n)\n {\n   return VEC_index(varinfo_t, varmap, n);\n }\n \n+/* Return the varmap element N, following the collapsed_to link.  */\n+\n+static inline varinfo_t\n+get_varinfo_fc (unsigned int n)\n+{\n+  varinfo_t v = VEC_index(varinfo_t, varmap, n);\n+\n+  if (v->collapsed_to)\n+    return v->collapsed_to;\n+  return v;\n+}\n+\n /* Variable that represents the unknown pointer.  */\n static varinfo_t var_anything;\n static tree anything_tree;\n@@ -316,6 +333,7 @@ new_var_info (tree t, unsigned int id, const char *name, unsigned int node)\n   bitmap_clear (ret->variables);\n   ret->complex = NULL;\n   ret->next = NULL;\n+  ret->collapsed_to = NULL;\n   return ret;\n }\n \n@@ -429,15 +447,15 @@ dump_constraint (FILE *file, constraint_t c)\n     fprintf (file, \"&\");\n   else if (c->lhs.type == DEREF)\n     fprintf (file, \"*\");  \n-  fprintf (file, \"%s\", get_varinfo (c->lhs.var)->name);\n+  fprintf (file, \"%s\", get_varinfo_fc (c->lhs.var)->name);\n   if (c->lhs.offset != 0)\n     fprintf (file, \" + \" HOST_WIDE_INT_PRINT_DEC, c->lhs.offset);\n   fprintf (file, \" = \");\n   if (c->rhs.type == ADDRESSOF)\n     fprintf (file, \"&\");\n   else if (c->rhs.type == DEREF)\n     fprintf (file, \"*\");\n-  fprintf (file, \"%s\", get_varinfo (c->rhs.var)->name);\n+  fprintf (file, \"%s\", get_varinfo_fc (c->rhs.var)->name);\n   if (c->rhs.offset != 0)\n     fprintf (file, \" + \" HOST_WIDE_INT_PRINT_DEC, c->rhs.offset);\n   fprintf (file, \"\\n\");\n@@ -982,33 +1000,36 @@ build_constraint_graph (void)\n     {\n       struct constraint_expr lhs = c->lhs;\n       struct constraint_expr rhs = c->rhs;\n+      unsigned int lhsvar = get_varinfo_fc (lhs.var)->id;\n+      unsigned int rhsvar = get_varinfo_fc (rhs.var)->id;\n+\n       if (lhs.type == DEREF)\n \t{\n \t  /* *x = y or *x = &y (complex) */\n-\t  if (rhs.type == ADDRESSOF || rhs.var > anything_id)\n-\t    insert_into_complex (lhs.var, c);\n+\t  if (rhs.type == ADDRESSOF || rhsvar > anything_id)\n+\t    insert_into_complex (lhsvar, c);\n \t}\n       else if (rhs.type == DEREF)\n \t{\n \t  /* !special var= *y */\n-\t  if (!(get_varinfo (lhs.var)->is_special_var))\n-\t    insert_into_complex (rhs.var, c);\n+\t  if (!(get_varinfo (lhsvar)->is_special_var))\n+\t    insert_into_complex (rhsvar, c);\n \t}\n       else if (rhs.type == ADDRESSOF)\n \t{\n \t  /* x = &y */\n-\t  bitmap_set_bit (get_varinfo (lhs.var)->solution, rhs.var);\n+\t  bitmap_set_bit (get_varinfo (lhsvar)->solution, rhsvar);\n \t}\n-      else if (lhs.var > anything_id)\n+      else if (lhsvar > anything_id)\n \t{\n \t  /* Ignore 0 weighted self edges, as they can't possibly contribute\n \t     anything */\n-\t  if (lhs.var != rhs.var || rhs.offset != 0 || lhs.offset != 0)\n+\t  if (lhsvar != rhsvar || rhs.offset != 0 || lhs.offset != 0)\n \t    {\n \t      \n \t      struct constraint_edge edge;\n-\t      edge.src = lhs.var;\n-\t      edge.dest = rhs.var;\n+\t      edge.src = lhsvar;\n+\t      edge.dest = rhsvar;\n \t      /* x = y (simple) */\n \t      add_graph_edge (graph, edge);\n \t      bitmap_set_bit (get_graph_weights (graph, edge),\n@@ -2300,9 +2321,12 @@ get_constraint_for (tree t, bool *need_anyoffset)\n    For each field of the lhs variable (lhsfield)\n      For each field of the rhs variable at lhsfield.offset (rhsfield)\n        add the constraint lhsfield = rhsfield\n-*/\n \n-static void\n+   If we fail due to some kind of type unsafety or other thing we\n+   can't handle, return false.  We expect the caller to collapse the\n+   variable in that case.  */\n+\n+static bool\n do_simple_structure_copy (const struct constraint_expr lhs,\n \t\t\t  const struct constraint_expr rhs,\n \t\t\t  const unsigned HOST_WIDE_INT size)\n@@ -2322,9 +2346,12 @@ do_simple_structure_copy (const struct constraint_expr lhs,\n       q = get_varinfo (temprhs.var);\n       fieldoffset = p->offset - pstart;\n       q = first_vi_for_offset (q, q->offset + fieldoffset);\n+      if (!q)\n+\treturn false;\n       temprhs.var = q->id;\n       process_constraint (new_constraint (templhs, temprhs));\n     }\n+  return true;\n }\n \n \n@@ -2406,6 +2433,32 @@ do_lhs_deref_structure_copy (const struct constraint_expr lhs,\n     }\n }\n \n+/* Sometimes, frontends like to give us bad type information.  This\n+   function will collapse all the fields from VAR to the end of VAR,\n+   into VAR, so that we treat those fields as a single variable. \n+   We return the variable they were collapsed into.  */\n+\n+static unsigned int\n+collapse_rest_of_var (unsigned int var)\n+{\n+  varinfo_t currvar = get_varinfo (var);\n+  varinfo_t field;\n+\n+  for (field = currvar->next; field; field = field->next)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"Type safety: Collapsing var %s into %s\\n\", \n+\t\t field->name, currvar->name);\n+      \n+      gcc_assert (!field->collapsed_to);\n+      field->collapsed_to = currvar;\n+    }\n+\n+  currvar->next = NULL;\n+  currvar->size = currvar->fullsize - currvar->offset;\n+  \n+  return currvar->id;\n+}\n \n /* Handle aggregate copies by expanding into copies of the respective\n    fields of the structures.  */\n@@ -2492,7 +2545,18 @@ do_structure_copy (tree lhsop, tree rhsop)\n \n   \n       if (rhs.type == SCALAR && lhs.type == SCALAR)  \n-\tdo_simple_structure_copy (lhs, rhs, MIN (lhssize, rhssize));\n+\t{\n+\t  if (!do_simple_structure_copy (lhs, rhs, MIN (lhssize, rhssize)))\n+\t    {\t      \n+\t      lhs.var = collapse_rest_of_var (lhs.var);\n+\t      rhs.var = collapse_rest_of_var (rhs.var);\n+\t      lhs.offset = 0;\n+\t      rhs.offset = 0;\n+\t      lhs.type = SCALAR;\n+\t      rhs.type = SCALAR;\n+\t      process_constraint (new_constraint (lhs, rhs));\n+\t    }\n+\t}\n       else if (lhs.type != DEREF && rhs.type == DEREF)\n \tdo_rhs_deref_structure_copy (lhs, rhs, MIN (lhssize, rhssize));\n       else if (lhs.type == DEREF && rhs.type != DEREF)"}]}