{"sha": "fc009f966c98317401b51127f59de4ad37bb7d19", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmMwMDlmOTY2Yzk4MzE3NDAxYjUxMTI3ZjU5ZGU0YWQzN2JiN2QxOQ==", "commit": {"author": {"name": "Geoff Keating", "email": "geoffk@cygnus.com", "date": "1999-09-09T04:00:37Z"}, "committer": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "1999-09-09T04:00:37Z"}, "message": "Makefile.in (cppexp.o): Depend on cpphash.h.\n\n\t* Makefile.in (cppexp.o): Depend on cpphash.h.\n\t* cppexp.c (cpp_lex): Handle `defined (xxx)' for poisoned xxx.\n\tInclude cpphash.h.\n\t* cpphash.c (special_symbol): Handle plain `xxx' for poisoned xxx.\n\t* cpplib.c (do_define): Generalise to handle poisoned definitions,\n\tredefining poisoned identifiers, etc.\n\t(do_undef): Don't allow poisoned identifiers to be undefined.\n\t(do_pragma): Add #pragma poison.\n\t(do_xifdef): Handle `#ifdef xxx' for poisoned xxx.\n\n\t* cccp.c: Add T_POISON node type.\n\t(special_symbol): Handle `defined(xxx)' and plain `xxx' for\n\tpoisoned xxx.\n\t(do_define): Generalise to handle poisoned definitions,\n\tredefining poisoned identifiers, etc.\n\t(do_undef): Don't allow poisoned identifiers to be undefined.\n\t(do_pragma): Add #pragma poison.\n\t(do_xifdef): Handle `#ifdef xxx' for poisoned xxx.\n\n\t* c-pragma.c (handle_pragma_token): Ignore #pragma poison.\n\t* c-pragma.h: Add ps_poison state.  We now always have generic\n\tpragmas.\n\nFrom-SVN: r29224", "tree": {"sha": "adfb849ae0813b5bacab43fb7a7ab5ec23bc7fb6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/adfb849ae0813b5bacab43fb7a7ab5ec23bc7fb6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fc009f966c98317401b51127f59de4ad37bb7d19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc009f966c98317401b51127f59de4ad37bb7d19", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc009f966c98317401b51127f59de4ad37bb7d19", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc009f966c98317401b51127f59de4ad37bb7d19/comments", "author": null, "committer": null, "parents": [{"sha": "d60f72aec57414b8339eecb25c33b423af7e6946", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d60f72aec57414b8339eecb25c33b423af7e6946", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d60f72aec57414b8339eecb25c33b423af7e6946"}], "stats": {"total": 354, "additions": 304, "deletions": 50}, "files": [{"sha": "ffd9ae553945006d52efbdc11a9fac9664ec8ece", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc009f966c98317401b51127f59de4ad37bb7d19/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc009f966c98317401b51127f59de4ad37bb7d19/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fc009f966c98317401b51127f59de4ad37bb7d19", "patch": "@@ -1,3 +1,28 @@\n+Thu Sep  9 13:46:06 1999  Geoffrey Keating  <geoffk@cygnus.com>\n+\n+\t* Makefile.in (cppexp.o): Depend on cpphash.h.\n+\t* cppexp.c (cpp_lex): Handle `defined (xxx)' for poisoned xxx.\n+\tInclude cpphash.h.\n+\t* cpphash.c (special_symbol): Handle plain `xxx' for poisoned xxx.\n+\t* cpplib.c (do_define): Generalise to handle poisoned definitions,\n+\tredefining poisoned identifiers, etc.\n+\t(do_undef): Don't allow poisoned identifiers to be undefined.\n+\t(do_pragma): Add #pragma poison.\n+\t(do_xifdef): Handle `#ifdef xxx' for poisoned xxx.\n+\n+\t* cccp.c: Add T_POISON node type.\n+\t(special_symbol): Handle `defined(xxx)' and plain `xxx' for \n+\tpoisoned xxx.  \n+\t(do_define): Generalise to handle poisoned definitions,\n+\tredefining poisoned identifiers, etc.\n+\t(do_undef): Don't allow poisoned identifiers to be undefined.\n+\t(do_pragma): Add #pragma poison.\n+\t(do_xifdef): Handle `#ifdef xxx' for poisoned xxx.\n+\n+\t* c-pragma.c (handle_pragma_token): Ignore #pragma poison.\n+\t* c-pragma.h: Add ps_poison state.  We now always have generic\n+\tpragmas.\n+\n Wed Sep  8 20:30:42 1999  Mark Mitchell  <mark@codesourcery.com>\n \n \t* ggc.h (ggc_alloc): New function."}, {"sha": "a5a87ee75aac568b3a06d20fbb17c34b411ee9a3", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc009f966c98317401b51127f59de4ad37bb7d19/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc009f966c98317401b51127f59de4ad37bb7d19/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=fc009f966c98317401b51127f59de4ad37bb7d19", "patch": "@@ -2019,7 +2019,7 @@ cpplib.o:  cpplib.c  $(CONFIG_H) cpplib.h intl.h system.h cpphash.h\n cpphash.o: cpphash.c $(CONFIG_H) cpplib.h intl.h system.h cpphash.h\n cppalloc.o: cppalloc.c $(CONFIG_H) cpplib.h intl.h system.h\n cpperror.o: cpperror.c $(CONFIG_H) cpplib.h intl.h system.h\n-cppexp.o:   cppexp.c   $(CONFIG_H) cpplib.h intl.h system.h\n+cppexp.o:   cppexp.c   $(CONFIG_H) cpplib.h intl.h system.h cpphash.h\n cppfiles.o: cppfiles.c $(CONFIG_H) cpplib.h intl.h system.h\n \n cppinit.o:  cppinit.c $(CONFIG_H) cpplib.h intl.h system.h \\"}, {"sha": "bfb6bdc6efb829cd2bbc91ec26128c518380b6f1", "filename": "gcc/c-pragma.c", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc009f966c98317401b51127f59de4ad37bb7d19/gcc%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc009f966c98317401b51127f59de4ad37bb7d19/gcc%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pragma.c?ref=fc009f966c98317401b51127f59de4ad37bb7d19", "patch": "@@ -300,6 +300,10 @@ handle_pragma_token (string, token)\n \t    ret_val = 1; /* Ignore the pragma.  */\n \t  break;\n #endif /* HANDLE_PRAGMA_WEAK */\n+\n+\tcase ps_poison:\n+\t  ret_val = 1;\n+\t  break;\n \t}\n \n       type = state = ps_start;\n@@ -338,9 +342,11 @@ handle_pragma_token (string, token)\n #ifdef HANDLE_PRAGMA_WEAK\n       if (strcmp (string, \"weak\") == 0)\n \ttype = state = ps_weak;\n-#endif\t  \n+#endif\n+      if (strcmp (string, \"poison\") == 0)\n+\ttype = state = ps_poison;\n       break;\n-      \n+\n #ifdef HANDLE_PRAGMA_WEAK\n     case ps_weak:\n       name = permalloc (strlen (string) + 1);\n@@ -485,7 +491,12 @@ handle_pragma_token (string, token)\n \tstate = ps_bad;\n       break;\n #endif /* HANDLE_PRAGMA_PACK_PUSH_POP */\n-      \n+\n+    case ps_poison:\n+      if (token && TREE_CODE (token) != IDENTIFIER_NODE)\n+\tstate = ps_bad;\n+      break;\n+\n     case ps_bad:\n     case ps_done:\n       break;"}, {"sha": "bfe7c1fe50a5e30b3dee4ec441a1e938cc1ae160", "filename": "gcc/c-pragma.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc009f966c98317401b51127f59de4ad37bb7d19/gcc%2Fc-pragma.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc009f966c98317401b51127f59de4ad37bb7d19/gcc%2Fc-pragma.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pragma.h?ref=fc009f966c98317401b51127f59de4ad37bb7d19", "patch": "@@ -61,13 +61,12 @@ extern int add_weak PROTO((char *, char *));\n #endif /* HANDLE_PRAGMA_WEAK */\n \n \n-#if defined HANDLE_PRAGMA_PACK || defined HANDLE_PRAGMA_WEAK\n /* Define HANDLE_GENERIC_PRAGMAS if any kind of front-end pragma\n    parsing is to be done.  The code in GCC's generic C source files\n    will only look for the definition of this constant.  They will\n-   ignore definitions of HANDLE_PRAGMA_PACK and so on.  */\n+   ignore definitions of HANDLE_PRAGMA_PACK and so on. \n+   With #pragma poison, this is always set.  */\n #define HANDLE_GENERIC_PRAGMAS 1\n-#endif\n \n \n #ifdef HANDLE_GENERIC_PRAGMAS\n@@ -91,6 +90,7 @@ enum pragma_state\n   ps_push, ps_pushcomma, ps_pushid, ps_pushcomma2,\n   ps_pop, ps_popcomma,\n #endif\n+  ps_poison,\n   ps_bad\n };\n "}, {"sha": "16def7a583b6126cdb0d69c9805aa9ac7214005f", "filename": "gcc/cccp.c", "status": "modified", "additions": 83, "deletions": 25, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc009f966c98317401b51127f59de4ad37bb7d19/gcc%2Fcccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc009f966c98317401b51127f59de4ad37bb7d19/gcc%2Fcccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcccp.c?ref=fc009f966c98317401b51127f59de4ad37bb7d19", "patch": "@@ -640,6 +640,7 @@ enum node_type {\n  T_DISABLED,\t/* macro temporarily turned off for rescan */\n  T_SPEC_DEFINED, /* special `defined' macro for use in #if statements */\n  T_PCSTRING,\t/* precompiled string (hashval is KEYDEF *) */\n+ T_POISON,\t/* defined with `#pragma poison' */\n  T_UNUSED\t/* Used for something not defined.  */\n  };\n \n@@ -4281,7 +4282,12 @@ special_symbol (hp, op)\n \t      || (hp->type == T_MACRO && hp->value.defn->predefined)))\n \t/* Output a precondition for this macro use.  */\n \tfprintf (pcp_outfile, \"#define %s\\n\", hp->name);\n-      buf = \" 1 \";\n+      if (hp->type == T_POISON) {\n+\terror(\"attempt to use poisoned `%s'.\", hp->name);\n+\tbuf = \" 0 \";\n+      } else {\n+\tbuf = \" 1 \";\n+      }\n     }\n     else\n       if (pcp_outfile && pcp_inside_if)\t{\n@@ -4302,6 +4308,11 @@ special_symbol (hp, op)\n     }\n     break;\n \n+  case T_POISON:\n+    error(\"attempt to use poisoned `%s'.\", hp->name);\n+    buf = \" 0 \";\t/* Consider poisoned symbol to not be defined */\n+    break;\n+\n oops:\n \n     error (\"`defined' without an identifier\");\n@@ -5926,6 +5937,7 @@ do_define (buf, limit, op, keyword)\n {\n   int hashcode;\n   MACRODEF mdef;\n+  enum node_type newtype = keyword->type == T_DEFINE ? T_MACRO : T_POISON;\n \n   /* If this is a precompiler run (with -pcp) pass thru #define directives.  */\n   if (pcp_outfile && op)\n@@ -5944,35 +5956,50 @@ do_define (buf, limit, op, keyword)\n       /* Redefining a precompiled key is ok.  */\n       if (hp->type == T_PCSTRING)\n \tok = 1;\n+      /* Redefining a poisoned identifier is even worse than `not ok'.  */\n+      else if (hp->type == T_POISON)\n+        ok = -1;\n+      /* Poisoning anything else is not ok.  \n+\t The poison should always come first.  */\n+      else if (newtype == T_POISON)\n+\tok = 0;\n       /* Redefining a macro is ok if the definitions are the same.  */\n       else if (hp->type == T_MACRO)\n \tok = ! compare_defs (mdef.defn, hp->value.defn);\n       /* Redefining a constant is ok with -D.  */\n       else if (hp->type == T_CONST)\n         ok = ! done_initializing;\n-      /* Print the warning if it's not ok.  */\n-      if (!ok) {\n-        /* If we are passing through #define and #undef directives, do\n-\t   that for this re-definition now.  */\n-        if (debug_output && op)\n-\t  pass_thru_directive (buf, limit, op, keyword);\n-\n-\tpedwarn (\"`%.*s' redefined\", mdef.symlen, mdef.symnam);\n-\tif (hp->type == T_MACRO)\n-\t  pedwarn_with_file_and_line (hp->value.defn->file,\n-\t\t\t\t      hp->value.defn->file_len,\n-\t\t\t\t      hp->value.defn->line,\n-\t\t\t\t      \"this is the location of the previous definition\");\n-      }\n-      /* Replace the old definition.  */\n-      hp->type = T_MACRO;\n-      hp->value.defn = mdef.defn;\n+      \n+      /* Print the warning or error if it's not ok.  */\n+      if (ok <= 0) \n+\t{\n+\t  /* If we are passing through #define and #undef directives, do\n+\t     that for this re-definition now.  */\n+\t  if (debug_output && op)\n+\t    pass_thru_directive (buf, limit, op, keyword);\n+\t  \n+\t  if (hp->type == T_POISON)\n+\t    error (\"redefining poisoned `%.*s'\", mdef.symlen, mdef.symnam);\n+\t  else\n+\t    pedwarn (\"`%.*s' redefined\", mdef.symlen, mdef.symnam);\n+\t  if (hp->type == T_MACRO)\n+\t    pedwarn_with_file_and_line (hp->value.defn->file,\n+\t\t\t\t\thp->value.defn->file_len,\n+\t\t\t\t\thp->value.defn->line,\n+\t\t\t\t\t\"this is the location of the previous definition\");\n+\t}\n+      if (hp->type != T_POISON)\n+\t{\n+\t  /* Replace the old definition.  */\n+\t  hp->type = newtype;\n+\t  hp->value.defn = mdef.defn;\n+\t}\n     } else {\n       /* If we are passing through #define and #undef directives, do\n \t that for this new definition now.  */\n       if (debug_output && op)\n \tpass_thru_directive (buf, limit, op, keyword);\n-      install (mdef.symnam, mdef.symlen, T_MACRO,\n+      install (mdef.symnam, mdef.symlen, newtype,\n \t       (char *) mdef.defn, hashcode);\n     }\n   }\n@@ -6990,9 +7017,13 @@ do_undef (buf, limit, op, keyword)\n        need to pass through all effective #undef directives.  */\n     if (debug_output && op)\n       pass_thru_directive (orig_buf, limit, op, keyword);\n-    if (hp->type != T_MACRO)\n-      warning (\"undefining `%s'\", hp->name);\n-    delete_macro (hp);\n+    if (hp->type == T_POISON)\n+      error (\"cannot undefine poisoned `%s'\", hp->name);\n+    else {\n+      if (hp->type != T_MACRO)\n+        warning (\"undefining `%s'\", hp->name);\n+      delete_macro (hp);\n+    }\n   }\n \n   if (pedantic) {\n@@ -7087,9 +7118,9 @@ do_ident (buf, limit, op, keyword)\n \n static int\n do_pragma (buf, limit, op, keyword)\n-     U_CHAR *buf, *limit ATTRIBUTE_UNUSED;\n-     FILE_BUF *op ATTRIBUTE_UNUSED;\n-     struct directive *keyword ATTRIBUTE_UNUSED;\n+     U_CHAR *buf, *limit;\n+     FILE_BUF *op;\n+     struct directive *keyword;\n {\n   SKIP_WHITE_SPACE (buf);\n   if (!strncmp ((char *) buf, \"once\", 4)) {\n@@ -7100,6 +7131,29 @@ do_pragma (buf, limit, op, keyword)\n     do_once ();\n   }\n \n+  if (!strncmp (buf, \"poison\", 6)) {\n+    /* Poison these symbols so that all subsequent usage produces an\n+       error message.  */\n+    U_CHAR *p = buf + 6;\n+\n+    SKIP_WHITE_SPACE (p);\n+    while (p < limit)\n+      {\n+\tU_CHAR *end = p;\n+\t\n+\twhile (end < limit && is_idchar[*end])\n+\t  end++;\n+\tif (end < limit && !is_space[*end])\n+\t  {\n+\t    error (\"invalid #pragma poison\");\n+\t    return 0;\n+\t  }\n+\tdo_define(p, end, op, keyword);\n+\tp = end;\n+\tSKIP_WHITE_SPACE (p);\n+      }\n+  }\n+\n   if (!strncmp ((char *) buf, \"implementation\", 14)) {\n     /* Be quiet about `#pragma implementation' for a file only if it hasn't\n        been included yet.  */\n@@ -7351,6 +7405,10 @@ do_xifdef (buf, limit, op, keyword)\n       }\n     }\n \n+    if ((hp != NULL) && (hp->type == T_POISON)) {\n+      error(\"attempt to use poisoned `%s'.\", hp->name);\n+      hp = NULL;\n+    }\n     skip = (hp == NULL) ^ (keyword->type == T_IFNDEF);\n     if (start_of_file && !skip) {\n       control_macro = (U_CHAR *) xmalloc (end - buf + 1);"}, {"sha": "57517223b9b9c320081f00d1444c1bde35cf8522", "filename": "gcc/cpp.texi", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc009f966c98317401b51127f59de4ad37bb7d19/gcc%2Fcpp.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc009f966c98317401b51127f59de4ad37bb7d19/gcc%2Fcpp.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpp.texi?ref=fc009f966c98317401b51127f59de4ad37bb7d19", "patch": "@@ -551,6 +551,7 @@ in the C preprocessor.\n * Concatenation::    Building tokens from parts taken from macro arguments.\n * Undefining::       Cancelling a macro's definition.\n * Redefining::       Changing a macro's definition.\n+* Poisoning::        Ensuring a macro is never defined or used.\n * Macro Pitfalls::   Macros can confuse the unwary.  Here we explain\n                        several common problems and strange features.\n @end menu\n@@ -1370,7 +1371,7 @@ The same form of @samp{#undef} directive will cancel definitions with\n arguments or definitions that don't expect arguments.  The @samp{#undef}\n directive has no effect when used on a name not currently defined as a macro.\n \n-@node Redefining, Macro Pitfalls, Undefining, Macros\n+@node Redefining, Poisoning, Undefining, Macros\n @subsection Redefining Macros\n \n @cindex redefining macros\n@@ -1404,7 +1405,28 @@ where there was no whitespace at all.\n \n Recall that a comment counts as whitespace.\n \n-@node Macro Pitfalls,, Redefining, Macros\n+@node Poisoning, Macro Pitfalls, Redefining, Macros\n+@subsection Poisoning Macros\n+@cindex poisoning macros\n+\n+Sometimes, there is an identifier that you want to remove completely\n+from your program, and make sure that it never creeps back in.  To\n+enforce this, the @samp{#pragma poison} directive can be used.\n+@samp{#pragma poison} is followed by a list of identifiers to poison,\n+and takes effect for the rest of the source.  You cannot @samp{#undef} a\n+poisoned identifier or test to see if it's defined with @samp{#ifdef}.\n+\n+For example,\n+\n+@example\n+#pragma poison printf sprintf fprintf\n+sprintf(some_string, \"hello\");\n+@end example\n+\n+@noindent\n+will produce an error.\n+\n+@node Macro Pitfalls,, Poisoning, Macros\n @subsection Pitfalls and Subtleties of Macros\n @cindex problems with macros\n @cindex pitfalls of macros"}, {"sha": "f037924d92737892ed0542ad9f4514a28dd00d22", "filename": "gcc/cppexp.c", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc009f966c98317401b51127f59de4ad37bb7d19/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc009f966c98317401b51127f59de4ad37bb7d19/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=fc009f966c98317401b51127f59de4ad37bb7d19", "patch": "@@ -27,6 +27,7 @@ Written by Per Bothner 1994.  */\n #include \"config.h\"\n #include \"system.h\"\n #include \"cpplib.h\"\n+#include \"cpphash.h\"\n \n #ifdef MULTIBYTE_CHARS\n #include <locale.h>\n@@ -445,6 +446,7 @@ cpp_lex (pfile, skip_evaluation)\n \t  int paren = 0, len;\n \t  cpp_buffer *ip = CPP_BUFFER (pfile);\n \t  U_CHAR *tok;\n+\t  HASHNODE *hp;\n \n \t  cpp_skip_hspace (pfile);\n \t  if (*ip->cur == '(')\n@@ -469,9 +471,14 @@ cpp_lex (pfile, skip_evaluation)\n \t\tgoto oops;\n \t      ++ip->cur;\n \t    }\n-\t  if (cpp_lookup (pfile, tok, len, -1))\n-\t    op.value = 1;\n-\n+\t  hp = cpp_lookup (pfile, tok, len, -1);\n+\t  if (hp != NULL)\n+\t    {\n+\t      if (hp->type == T_POISON)\n+\t\tcpp_error (pfile, \"attempt to use poisoned `%s'\", hp->name);\n+\t      else\n+\t\top.value = 1;\n+\t    }\n \t}\n       return op;\n "}, {"sha": "c7da2b3116d1c533392714e0cb9ddac58508836e", "filename": "gcc/cpphash.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc009f966c98317401b51127f59de4ad37bb7d19/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc009f966c98317401b51127f59de4ad37bb7d19/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=fc009f966c98317401b51127f59de4ad37bb7d19", "patch": "@@ -1020,6 +1020,13 @@ special_symbol (hp, pfile)\n \treturn;\n       }\n \n+    case T_POISON:\n+      cpp_error (pfile, \"attempt to use poisoned `%s'.\", hp->name);\n+      CPP_RESERVE (pfile, 1);\n+      CPP_PUTC_Q (pfile, '0');\n+      CPP_NUL_TERMINATE_Q (pfile);\n+      break;\n+\n     default:\n       cpp_fatal (pfile, \"cpplib internal error: invalid special hash type\");\n       return;"}, {"sha": "e274df9d2343f45e4c036f441d6e5a6589b13680", "filename": "gcc/cpplib.c", "status": "modified", "additions": 99, "deletions": 13, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc009f966c98317401b51127f59de4ad37bb7d19/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc009f966c98317401b51127f59de4ad37bb7d19/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=fc009f966c98317401b51127f59de4ad37bb7d19", "patch": "@@ -625,8 +625,9 @@ check_macro_name (pfile, symname, assertion)\n }\n \n /* Process a #define command.\n-KEYWORD is the keyword-table entry for #define,\n-or NULL for a \"predefined\" macro.  */\n+   KEYWORD is the keyword-table entry for #define,\n+   or NULL for a \"predefined\" macro,\n+   or the keyword-table entry for #pragma in the case of a #pragma poison.  */\n \n static int\n do_define (pfile, keyword)\n@@ -638,10 +639,16 @@ do_define (pfile, keyword)\n   HASHNODE *hp;\n   long here;\n   U_CHAR *macro, *buf, *end;\n+  enum node_type new_type;\n \n   here = CPP_WRITTEN (pfile);\n   copy_rest_of_line (pfile);\n \n+  if (keyword == NULL || keyword->type == T_DEFINE)\n+    new_type = T_MACRO;\n+  else\n+    new_type = T_POISON;\n+\n   /* Copy out the line so we can pop the token buffer. */\n   buf = pfile->token_buffer + here;\n   end = CPP_PWRITTEN (pfile);\n@@ -663,30 +670,40 @@ do_define (pfile, keyword)\n       /* Redefining a precompiled key is ok.  */\n       if (hp->type == T_PCSTRING)\n \tok = 1;\n+      /* Redefining a poisoned identifier is even worse than `not ok'.  */\n+      else if (hp->type == T_POISON)\n+\tok = -1;\n       /* Redefining a macro is ok if the definitions are the same.  */\n       else if (hp->type == T_MACRO)\n \tok = ! compare_defs (pfile, mdef.defn, hp->value.defn);\n       /* Redefining a constant is ok with -D.  */\n       else if (hp->type == T_CONST || hp->type == T_STDC)\n         ok = ! CPP_OPTIONS (pfile)->done_initializing;\n-      /* Print the warning if it's not ok.  */\n-      if (!ok)\n+      /* Print the warning or error if it's not ok.  */\n+      if (ok <= 0)\n \t{\n-\t  cpp_pedwarn (pfile, \"`%.*s' redefined\", mdef.symlen, mdef.symnam);\n+\t  if (hp->type == T_POISON)\n+\t    cpp_error (pfile, \"redefining poisoned `%.*s'\", \n+\t\t       mdef.symlen, mdef.symnam);\n+\t  else\n+\t    cpp_pedwarn (pfile, \"`%.*s' redefined\", mdef.symlen, mdef.symnam);\n \t  if (hp->type == T_MACRO)\n \t    cpp_pedwarn_with_file_and_line (pfile, hp->value.defn->file,\n \t\t\t\t\t    hp->value.defn->line,\n \t\t\t\"this is the location of the previous definition\");\n \t}\n-      /* Replace the old definition.  */\n-      hp->type = T_MACRO;\n-      hp->value.defn = mdef.defn;\n+      if (hp->type != T_POISON)\n+\t{\n+\t  /* Replace the old definition.  */\n+\t  hp->type = new_type;\n+\t  hp->value.defn = mdef.defn;\n+\t}\n     }\n   else\n-    cpp_install (pfile, mdef.symnam, mdef.symlen, T_MACRO,\n+    cpp_install (pfile, mdef.symnam, mdef.symlen, new_type,\n \t\t (char *) mdef.defn, hashcode);\n \n-  if (keyword)\n+  if (keyword != NULL && keyword->type == T_DEFINE)\n     {\n       if (CPP_OPTIONS (pfile)->debug_output\n \t  || CPP_OPTIONS (pfile)->dump_macros == dump_definitions)\n@@ -1425,9 +1442,14 @@ do_undef (pfile, keyword)\n \t need to pass through all effective #undef commands.  */\n       if (CPP_OPTIONS (pfile)->debug_output && keyword)\n \tpass_thru_directive (name, sym_length, pfile, keyword);\n-      if (hp->type != T_MACRO)\n-\tcpp_warning (pfile, \"undefining `%s'\", hp->name);\n-      delete_macro (hp);\n+      if (hp->type == T_POISON)\n+\tcpp_error (pfile, \"cannot undefine poisoned `%s'\", hp->name);\n+      else \n+\t{\n+\t  if (hp->type != T_MACRO)\n+\t    cpp_warning (pfile, \"undefining `%s'\", hp->name);\n+\t  delete_macro (hp);\n+\t}\n     }\n \n   return 0;\n@@ -1579,6 +1601,65 @@ do_pragma (pfile, keyword)\n \t  \"`#pragma implementation' for `%s' appears after file is included\",\n \t\t     fcopy);\n     }\n+  else if (!strncmp (buf, \"poison\", 6))\n+    {\n+      /* Poison these symbols so that all subsequent usage produces an\n+\t error message.  */\n+      U_CHAR *p = buf + 6;\n+      size_t plen;\n+      U_CHAR *syms;\n+      int writeit;\n+\n+      SKIP_WHITE_SPACE (p);\n+      plen = strlen(p) + 1;\n+\n+      syms = (U_CHAR *) alloca (plen);\n+      memcpy (syms, p, plen);\n+\n+      /* As a rule, don't include #pragma poison commands in output,  \n+         unless the user asks for them.  */\n+      writeit = (CPP_OPTIONS (pfile)->debug_output\n+\t\t || CPP_OPTIONS (pfile)->dump_macros == dump_definitions\n+\t\t || CPP_OPTIONS (pfile)->dump_macros == dump_names);\n+\n+      if (writeit)\n+\tCPP_SET_WRITTEN (pfile, here);\n+      else\n+\tCPP_SET_WRITTEN (pfile, here-8);\n+\n+      if (writeit)\n+\t{\n+\t  CPP_RESERVE (pfile, plen + 7);\n+\t  CPP_PUTS_Q (pfile, \"poison\", 7);\n+\t}\n+\n+      while (*syms != '\\0')\n+\t{\n+\t  U_CHAR *end = syms;\n+\t  \n+\t  while (is_idchar[*end])\n+\t    end++;\n+\n+\t  if (!is_hor_space[*end] && *end != '\\0')\n+\t    {\n+\t      cpp_error (pfile, \"invalid #pragma poison directive\");\n+\t      return 1;\n+\t    }\n+\n+\t  if (cpp_push_buffer (pfile, syms, end - syms) != NULL)\n+\t    {\n+\t      do_define (pfile, keyword);\n+\t      cpp_pop_buffer (pfile);\n+\t    }\n+\t  if (writeit)\n+\t    {\n+\t      CPP_PUTC_Q (pfile, ' ');\n+\t      CPP_PUTS_Q (pfile, syms, end - syms);\n+\t    }\n+\t  syms = end;\n+\t  SKIP_WHITE_SPACE (syms);\n+\t}\n+    }\n \n   return 0;\n }\n@@ -1807,6 +1888,11 @@ do_xifdef (pfile, keyword)\n \t  control_macro = (U_CHAR *) xmalloc (ident_length + 1);\n \t  bcopy (ident, control_macro, ident_length + 1);\n \t}\n+      if (hp != NULL && hp->type == T_POISON)\n+\t{\n+\t  cpp_error (pfile, \"attempt to use poisoned `%s'\", hp->name);\n+\t  skip = !skip;\n+\t}\n     }\n   else\n     {"}, {"sha": "daff0c631745b14150cf0ed914b520aad0eaf205", "filename": "gcc/cpplib.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc009f966c98317401b51127f59de4ad37bb7d19/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc009f966c98317401b51127f59de4ad37bb7d19/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=fc009f966c98317401b51127f59de4ad37bb7d19", "patch": "@@ -600,6 +600,7 @@ enum node_type {\n  T_MACRO,\t/* macro defined by `#define' */\n  T_DISABLED,\t/* macro temporarily turned off for rescan */\n  T_PCSTRING,\t/* precompiled string (hashval is KEYDEF *) */\n+ T_POISON,\t/* defined with `#pragma poison' */\n  T_UNUSED\t/* Used for something not defined.  */\n  };\n "}, {"sha": "9252ab38299c67b33e04dcfc86e0d29018ac4c97", "filename": "gcc/testsuite/gcc.c-torture/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc009f966c98317401b51127f59de4ad37bb7d19/gcc%2Ftestsuite%2Fgcc.c-torture%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc009f966c98317401b51127f59de4ad37bb7d19/gcc%2Ftestsuite%2Fgcc.c-torture%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2FChangeLog?ref=fc009f966c98317401b51127f59de4ad37bb7d19", "patch": "@@ -1,3 +1,8 @@\n+1999-09-08  Geoffrey Keating  <geoffk@cygnus.com>\n+\n+\t* noncompile/noncompile.exp: Add poison-1.c.\n+\t* noncompile/poison-1.c: New file.\n+\n 1999-09-06  Franz Sirl  <Franz.Sirl-kernel@lauterbach.com>\n \n \t* execute/va-arg-9.c: New test."}, {"sha": "80a5487c203c66cee7e5f0c92ff9b8d2554053af", "filename": "gcc/testsuite/gcc.c-torture/noncompile/noncompile.exp", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc009f966c98317401b51127f59de4ad37bb7d19/gcc%2Ftestsuite%2Fgcc.c-torture%2Fnoncompile%2Fnoncompile.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc009f966c98317401b51127f59de4ad37bb7d19/gcc%2Ftestsuite%2Fgcc.c-torture%2Fnoncompile%2Fnoncompile.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fnoncompile%2Fnoncompile.exp?ref=fc009f966c98317401b51127f59de4ad37bb7d19", "patch": "@@ -323,3 +323,13 @@ set compiler_output \".*:6:\"\n set groups {passed gcc-noncompile}\n \n postbase_with_opts $src_code $run $groups\n+\n+# Test poison-1.c\n+prebase\n+\n+set src_code poison-1.c\n+set compiler_output \".*c:2:.*c:4:.*c:5:.*c:7:.*c:8:.*c:9:.*c:11:.*c:12:.*c:13:.*c:14:.*c:17:.*c:20:\"\n+\n+set groups {passed gcc-noncompile}\n+\n+postbase $src_code $run $groups"}, {"sha": "1cb275ef11111c094b2603bdc0836c760bcf7189", "filename": "gcc/testsuite/gcc.c-torture/noncompile/poison-1.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc009f966c98317401b51127f59de4ad37bb7d19/gcc%2Ftestsuite%2Fgcc.c-torture%2Fnoncompile%2Fpoison-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc009f966c98317401b51127f59de4ad37bb7d19/gcc%2Ftestsuite%2Fgcc.c-torture%2Fnoncompile%2Fpoison-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fnoncompile%2Fpoison-1.c?ref=fc009f966c98317401b51127f59de4ad37bb7d19", "patch": "@@ -0,0 +1,22 @@\n+#pragma poison foo\n+foo\n+#pragma poison foo2 foo3\n+foo2\n+foo3\n+#pragma   poison\tfoo4 \tfoo5\n+foo4\n+foo5\n+#pragma poison +++\n+#define foo6 123\n+#pragma poison foo6\n+#define foo6 345\n+#define foo6 456\n+#ifdef foo6\n+#error hey!  foo6 poisoned!\n+#endif\n+#if defined(foo6)\n+#error no, foo6 still poisoned!\n+#else\n+foo6\n+#endif\n+#pragma poison"}]}