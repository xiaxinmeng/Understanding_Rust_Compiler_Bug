{"sha": "4cd0bc3b696fd8ea70f8e3d80d4eb4440e01f554", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGNkMGJjM2I2OTZmZDhlYTcwZjhlM2Q4MGQ0ZWI0NDQwZTAxZjU1NA==", "commit": {"author": {"name": "Jojo", "email": "jijie_rong@c-sky.com", "date": "2018-08-17T19:08:27Z"}, "committer": {"name": "Sandra Loosemore", "email": "sandra@gcc.gnu.org", "date": "2018-08-17T19:08:27Z"}, "message": "C-SKY port: libgcc\n\n2018-08-17  Jojo  <jijie_rong@c-sky.com>\n\t    Huibin Wang  <huibin_wang@c-sky.com>\n\t    Sandra Loosemore  <sandra@codesourcery.com>\n\t    Chung-Lin Tang  <cltang@codesourcery.com>\n\n\tC-SKY port: libgcc\n\n\tlibgcc/\n\t* config.host: Add C-SKY support.\n\t* config/csky/*: New.\n\nCo-Authored-By: Chung-Lin Tang <cltang@codesourcery.com>\nCo-Authored-By: Huibin Wang <huibin_wang@c-sky.com>\nCo-Authored-By: Sandra Loosemore <sandra@codesourcery.com>\n\nFrom-SVN: r263631", "tree": {"sha": "011cb4090dede9796f2b6de3d40be4a534a8eaca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/011cb4090dede9796f2b6de3d40be4a534a8eaca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4cd0bc3b696fd8ea70f8e3d80d4eb4440e01f554", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cd0bc3b696fd8ea70f8e3d80d4eb4440e01f554", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4cd0bc3b696fd8ea70f8e3d80d4eb4440e01f554", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cd0bc3b696fd8ea70f8e3d80d4eb4440e01f554/comments", "author": null, "committer": null, "parents": [{"sha": "9d21b3988043f147e611a1224781f4e75692cdec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d21b3988043f147e611a1224781f4e75692cdec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d21b3988043f147e611a1224781f4e75692cdec"}], "stats": {"total": 1371, "additions": 1371, "deletions": 0}, "files": [{"sha": "e800b36cacd75dcb25671c94c47b0f7a6402c212", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cd0bc3b696fd8ea70f8e3d80d4eb4440e01f554/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cd0bc3b696fd8ea70f8e3d80d4eb4440e01f554/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=4cd0bc3b696fd8ea70f8e3d80d4eb4440e01f554", "patch": "@@ -1,3 +1,13 @@\n+2018-08-17  Jojo  <jijie_rong@c-sky.com>\n+\t    Huibin Wang  <huibin_wang@c-sky.com>\n+\t    Sandra Loosemore  <sandra@codesourcery.com>\n+\t    Chung-Lin Tang  <cltang@codesourcery.com>\n+\n+\tC-SKY port: libgcc\n+\n+\t* config.host: Add C-SKY support.\n+\t* config/csky/*: New.\n+\n 2018-08-12  Chung-Ju Wu  <jasonwucj@gmail.com>\n \n \t* config/nds32/t-nds32-isr: Rearrange object dependency."}, {"sha": "bd4ef1e3584afa88236da5c11f35798543b466a0", "filename": "libgcc/config.host", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cd0bc3b696fd8ea70f8e3d80d4eb4440e01f554/libgcc%2Fconfig.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cd0bc3b696fd8ea70f8e3d80d4eb4440e01f554/libgcc%2Fconfig.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig.host?ref=4cd0bc3b696fd8ea70f8e3d80d4eb4440e01f554", "patch": "@@ -108,6 +108,9 @@ cr16-*-*)\n crisv32-*-*)\n \tcpu_type=cris\n \t;;\n+csky*-*-*)\n+\tcpu_type=csky\n+\t;;\n fido-*-*)\n \tcpu_type=m68k\n \t;;\n@@ -507,6 +510,15 @@ cris-*-elf)\n cris-*-linux* | crisv32-*-linux*)\n \ttmake_file=\"$tmake_file cris/t-cris t-softfp-sfdf t-softfp cris/t-linux\"\n \t;;\n+csky-*-elf*)\n+\ttmake_file=\"csky/t-csky t-fdpbit\"\n+\textra_parts=\"$extra_parts crti.o crtn.o\"\n+\t;;\n+csky-*-linux*)\n+\ttmake_file=\"$tmake_file csky/t-csky t-slibgcc-libgcc t-fdpbit csky/t-linux-csky\"\n+\textra_parts=\"$extra_parts crti.o crtn.o\"\n+\tmd_unwind_header=csky/linux-unwind.h\n+\t;;\n epiphany-*-elf* | epiphany-*-rtems*)\n \ttmake_file=\"$tmake_file epiphany/t-epiphany t-fdpbit epiphany/t-custom-eqsf\"\n \textra_parts=\"$extra_parts crti.o crtint.o crtrunc.o crtm1reg-r43.o crtm1reg-r63.o crtn.o\""}, {"sha": "3e4beb9628a9848c978fd39a2e7618f2d4ff65cb", "filename": "libgcc/config/csky/crti.S", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cd0bc3b696fd8ea70f8e3d80d4eb4440e01f554/libgcc%2Fconfig%2Fcsky%2Fcrti.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cd0bc3b696fd8ea70f8e3d80d4eb4440e01f554/libgcc%2Fconfig%2Fcsky%2Fcrti.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fcsky%2Fcrti.S?ref=4cd0bc3b696fd8ea70f8e3d80d4eb4440e01f554", "patch": "@@ -0,0 +1,140 @@\n+# Define _init and _fini entry points for C-SKY.\n+# Copyright (C) 2018 Free Software Foundation, Inc.\n+# Contributed by C-SKY Microsystems and Mentor Graphics.\n+#\n+# This file is free software; you can redistribute it and/or modify it\n+# under the terms of the GNU General Public License as published by the\n+# Free Software Foundation; either version 3, or (at your option) any\n+# later version.\n+#\n+# This file is distributed in the hope that it will be useful, but\n+# WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+# General Public License for more details.\n+#\n+# Under Section 7 of GPL version 3, you are granted additional\n+# permissions described in the GCC Runtime Library Exception, version\n+# 3.1, as published by the Free Software Foundation.\n+#\n+# You should have received a copy of the GNU General Public License and\n+# a copy of the GCC Runtime Library Exception along with this program;\n+# see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+# <http://www.gnu.org/licenses/>.\n+\n+\n+# This file just makes a stack frame for the contents of the .fini and\n+# .init sections.  Users may put any desired instructions in those\n+# sections.\n+\n+\t.file    \"crti.S\"\n+\n+/* We use more complicated versions of this code with GLIBC.  */\n+#if defined(__gnu_linux__)\n+\n+#ifndef PREINIT_FUNCTION\n+# define PREINIT_FUNCTION __gmon_start__\n+#endif\n+\n+#ifndef PREINIT_FUNCTION_WEAK\n+# define PREINIT_FUNCTION_WEAK 1\n+#endif\n+\n+#if PREINIT_FUNCTION_WEAK\n+\t.global PREINIT_FUNCTION\n+\t.weak PREINIT_FUNCTION\n+\t.align 4\n+\t.type call_weak_fn, %function\n+call_weak_fn:\n+\t// push  lr\n+\tsubi    sp, 4\n+\tstw     lr, (sp)\n+#ifdef  __PIC__\n+\tlrw     a2, PREINIT_FUNCTION@GOT\n+\taddu    a2, gb\n+\tldw     a2, (a2)\n+#else\n+\tlrw     a2, PREINIT_FUNCTION\n+#endif\n+\tcmpnei  a2, 0\n+\tbf      1f\n+\tjsr     a2\n+1:\n+\t// pop lr\n+\tldw     lr, (sp)\n+\taddi    sp, 4\n+\trts\n+\n+\t.align 4\n+#else\n+\t.hidden PREINIT_FUNCTION\n+#endif /* PREINIT_FUNCTION_WEAK */\n+\n+\t.section .init,\"ax\",@progbits\n+\t.align 4\n+\t.globl _init\n+\t.type _init, @function\n+_init:\n+\tsubi    sp, 8\n+\tstw     lr, (sp, 0)\n+#ifdef __PIC__\n+\t//  stw     gb, (sp, 4)\n+\tbsr     .Lgetpc\n+.Lgetpc:\n+\tlrw     gb, .Lgetpc@GOTPC\n+\tadd     gb, lr\n+#endif\n+#if PREINIT_FUNCTION_WEAK\n+#ifdef __PIC__\n+\tlrw     a2, call_weak_fn@GOTOFF\n+\tadd     a2, gb\n+\tjsr     a2\n+#else\n+\tjsri    call_weak_fn\n+#endif\n+#else /* !PREINIT_FUNCTION_WEAK */\n+#ifdef  __PIC__\n+\tlrw     a2, PREINIT_FUNCTION@PLT\n+\taddu    a2, gb\n+\tldw     a2, (a2)\n+\tjsr     a2\n+#else\n+\tjsri    PREINIT_FUNCTION\n+#endif\n+#endif /* PREINIT_FUNCTION_WEAK */\n+\n+\tbr      2f\n+\t.literals\n+\t.align  4\n+2:\n+\t.section .fini,\"ax\",@progbits\n+\t.align 4\n+\t.globl _fini\n+\t.type _fini, @function\n+_fini:\n+\tsubi    sp,8\n+\tstw     lr, (sp, 0)\n+\tbr      2f\n+\t.literals\n+\t.align  4\n+2:\n+\n+/* These are the non-GLIBC versions.  */\n+#else  /* !defined(__gnu_linux__) */\n+\t.section  \".init\"\n+\t.global  _init\n+\t.type  _init,@function\n+\t.align  2\n+_init:\n+\tsubi  sp, 16\n+\tst.w  lr, (sp, 12)\n+\tmov     r0, r0\n+\n+\t.section  \".fini\"\n+\t.global  _fini\n+\t.type  _fini,@function\n+\t.align  2\n+_fini:\n+\tsubi  sp, 16\n+\tst.w  lr, (sp, 12)\n+\tmov     r0, r0\n+#endif /* defined(__gnu_linux__) */"}, {"sha": "8bef9960bf697cde8677aca86d83d3b6d5c61db5", "filename": "libgcc/config/csky/crtn.S", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cd0bc3b696fd8ea70f8e3d80d4eb4440e01f554/libgcc%2Fconfig%2Fcsky%2Fcrtn.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cd0bc3b696fd8ea70f8e3d80d4eb4440e01f554/libgcc%2Fconfig%2Fcsky%2Fcrtn.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fcsky%2Fcrtn.S?ref=4cd0bc3b696fd8ea70f8e3d80d4eb4440e01f554", "patch": "@@ -0,0 +1,55 @@\n+# Terminate C-SKY .init and .fini sections.\n+# Copyright (C) 2018 Free Software Foundation, Inc.\n+# Contributed by C-SKY Microsystems and Mentor Graphics.\n+#\n+# This file is free software; you can redistribute it and/or modify it\n+# under the terms of the GNU General Public License as published by the\n+# Free Software Foundation; either version 3, or (at your option) any\n+# later version.\n+#\n+# This file is distributed in the hope that it will be useful, but\n+# WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+# General Public License for more details.\n+#\n+# Under Section 7 of GPL version 3, you are granted additional\n+# permissions described in the GCC Runtime Library Exception, version\n+# 3.1, as published by the Free Software Foundation.\n+#\n+# You should have received a copy of the GNU General Public License and\n+# a copy of the GCC Runtime Library Exception along with this program;\n+# see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+# <http://www.gnu.org/licenses/>.\n+\n+\n+# This file just makes sure that the .fini and .init sections do in\n+# fact return.  Users may put any desired instructions in those sections.\n+# This file is the last thing linked into any executable.\n+\n+\t.file    \"crtn.S\"\n+\n+# Is this the GLIBC version?\n+#if defined(__gnu_linux__)\n+\t .section .init,\"ax\",@progbits\n+\t ldw     lr, (sp, 0)\n+\t addi    sp, 8\n+\t rts\n+\n+\t .section .fini,\"ax\",@progbits\n+\t ldw     lr, (sp, 0)\n+\t addi    sp, 8\n+\t rts\n+\n+#else /* !defined(__gnu_linux__) */\n+\t.section  \".init\"\n+\tldw     lr, (sp, 12)\n+\taddi    sp, 16\n+\tjmp     lr\n+\n+\t.section  \".fini\"\n+\tldw     lr, (sp, 12)\n+\taddi    sp, 16\n+\tjmp     lr\n+\n+# Th-th-th-that is all folks!\n+#endif  /* defined(__gnu_linux__) */"}, {"sha": "a0a3c730417b171466ea2b87592dbff295e4df97", "filename": "libgcc/config/csky/lib1funcs.S", "status": "added", "additions": 675, "deletions": 0, "changes": 675, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cd0bc3b696fd8ea70f8e3d80d4eb4440e01f554/libgcc%2Fconfig%2Fcsky%2Flib1funcs.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cd0bc3b696fd8ea70f8e3d80d4eb4440e01f554/libgcc%2Fconfig%2Fcsky%2Flib1funcs.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fcsky%2Flib1funcs.S?ref=4cd0bc3b696fd8ea70f8e3d80d4eb4440e01f554", "patch": "@@ -0,0 +1,675 @@\n+/* libgcc routines for C-SKY.\n+   Copyright (C) 2018 Free Software Foundation, Inc.\n+   Contributed by C-SKY Microsystems and Mentor Graphics.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by the\n+   Free Software Foundation; either version 3, or (at your option) any\n+   later version.\n+\n+   This file is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+\n+/* Use the right prefix for global labels.  */\n+#define CONCAT1(a, b) CONCAT2(a, b)\n+#define CONCAT2(a, b) a ## b\n+#define SYM(x) CONCAT1 (__, x)\n+\n+#ifndef __CSKYBE__\n+#define xl r0\n+#define xh r1\n+#define yl r2\n+#define yh r3\n+#else\n+#define xh r0\n+#define xl r1\n+#define yh r2\n+#define yl r3\n+#endif\n+\n+\n+#ifdef __ELF__\n+#define TYPE(x) .type SYM (x),@function\n+#define SIZE(x) .size SYM (x), . - SYM (x)\n+#else\n+#define TYPE(x)\n+#define SIZE(x)\n+#endif\n+\n+.macro FUNC_START name\n+\t.text\n+\t.align\t2\n+\t.globl SYM (\\name)\n+\tTYPE (\\name)\n+SYM (\\name):\n+.endm\n+\n+.macro FUNC_END name\n+\tSIZE (\\name)\n+.endm\n+\n+\n+/* Emulate FF1 (\"fast find 1\") instruction on ck801.\n+   Result goes in rx, clobbering ry.  */\n+#if defined(__CK801__)\n+.macro FF1_M rx, ry\n+\tmovi\t\\rx, 32\n+10:\n+\tcmphsi\t\\ry, 1\n+\tbf\t11f\n+\tsubi\t\\rx, \\rx, 1\n+\tlsri\t\\ry, \\ry, 1\n+\tbr\t10b\n+11:\n+.endm\n+#else\n+.macro FF1_M rx, ry\n+\tff1\t\\rx, \\ry\n+.endm\n+#endif\n+\n+/* Likewise emulate lslc instruction (\"logical left shift to C\") on CK801.  */\n+#if defined(__CK801__)\n+.macro LSLC_M rx\n+\tcmpne\t\\rx, \\rx\n+\taddc\t\\rx, \\rx\n+.endm\n+#else\n+.macro LSLC_M rx\n+\tlslc\t\\rx\n+.endm\n+#endif\n+\n+/* Emulate the abs instruction.  */\n+#if  defined(__CK802__)\n+.macro ABS_M rx\n+\tbtsti\t\\rx, 31\n+\tbf\t10f\n+\tnot\t\\rx\n+\taddi\t\\rx, 1\n+10:\n+.endm\n+#elif defined(__CK801__)\n+.macro ABS_M rx\n+\tcmplti\t\\rx, 1\n+\tbf\t10f\n+\tnot\t\\rx\n+\taddi\t\\rx, 1\n+10:\n+.endm\n+#else\n+.macro ABS_M rx\n+\tabs\t\\rx\n+.endm\n+#endif\n+\n+/* Emulate the ld.hs (\"load signed halfword and extend\") instruction\n+   on ck801 and ck802.  */\n+#if defined(__CK801__)\n+.macro LDBS_M rx, ry\n+\tld.b \\rx, (\\ry, 0x0)\n+\tsextb \\rx, \\rx\n+.endm\n+#else\n+.macro LDBS_M rx, ry\n+\tld.bs \\rx, (\\ry, 0x0)\n+.endm\n+#endif\n+\n+#if defined(__CK801__)\n+.macro LDHS_M rx, ry\n+\tld.h \\rx, (\\ry, 0x0)\n+\tsexth \\rx, \\rx\n+.endm\n+#else\n+.macro LDHS_M rx, ry\n+\tld.hs \\rx, (\\ry, 0x0)\n+.endm\n+#endif\n+\n+\n+/* Signed and unsigned div/mod/rem functions.  */\n+\n+#ifdef\tL_udivsi3\n+FUNC_START udiv32\n+FUNC_START udivsi3\n+\tcmpnei\ta1, 0\t// look for 0 divisor\n+\tbt\t9f\n+\ttrap\t3\t// divide by 0\n+9:\n+\t// control iterations, skip across high order 0 bits in dividend\n+\tcmpnei\ta0, 0\n+\tbt\t8f\n+\tjmp\tlr\t// 0 dividend quick return\n+8:\n+\tpush\tl0\n+\tmovi\ta2, 1\t// a2 is quotient (1 for a sentinel)\n+\tmov\ta3, a0\n+\tFF1_M\tl0, a3\t// figure distance to skip\n+\tlsl\ta2, l0\t// move the sentinel along (with 0's behind)\n+\tlsl\ta0, l0\t// and the low 32 bits of numerator\n+\n+\t// FIXME:  Is this correct?\n+\tmov\ta3, a1\t// looking at divisor\n+\tFF1_M\tl0, a3\t// I can move 32-l0 more bits to left.\n+\taddi\tl0, 1\t// ok, one short of that...\n+\tmov\ta3, a0\n+\tlsr\ta3, l0\t// bits that came from low order...\n+\tnot\tl0\t// l0 == \"32-n\" == LEFT distance\n+\taddi\tl0, 33\t// this is (32-n)\n+\tlsl\ta2,l0\t// fixes the high 32 (quotient)\n+\tlsl\ta0,l0\n+\tcmpnei\ta2,0\n+\tbf\t4f\t// the sentinel went away...\n+\n+\t// run the remaining bits\n+1:\n+\tLSLC_M\ta0\t// 1 bit left shift of a3-a0\n+\taddc\ta3, a3\n+\tcmphs\ta3, a1\t// upper 32 of dividend >= divisor?\n+\tbf\t2f\n+\tsubu\ta3, a1\t// if yes, subtract divisor\n+2:\n+\taddc\ta2, a2\t// shift by 1 and count subtracts\n+\tbf\t1b\t// if sentinel falls out of quotient, stop\n+\n+4:\n+\tmov\ta0, a2\t// return quotient\n+\tmov\ta1, a3\t// and piggyback the remainder\n+\tpop\tl0\n+FUNC_END udiv32\n+FUNC_END udivsi3\n+#endif\n+\n+#ifdef\tL_umodsi3\n+FUNC_START urem32\n+FUNC_START umodsi3\n+\tcmpnei\ta1, 0\t// look for 0 divisor\n+\tbt\t9f\n+\ttrap\t3\t// divide by 0\n+9:\n+\t// control iterations, skip across high order 0 bits in dividend\n+\tcmpnei\ta0, 0\n+\tbt\t8f\n+\tjmp\tlr\t// 0 dividend quick return\n+8:\n+\tmov\ta2, a0\n+\tFF1_M\ta3, a2\t// figure distance to skip\n+\tmovi\ta2, 1\t// a2 is quotient (1 for a sentinel)\n+\tlsl\ta2, a3\t// move the sentinel along (with 0's behind)\n+\tlsl\ta0, a3\t// and the low 32 bits of numerator\n+\tmovi\ta3, 0\n+\n+1:\n+\tLSLC_M\ta0\t// 1 bit left shift of a3-a0\n+\taddc\ta3, a3\n+\tcmphs\ta3, a1\t// upper 32 of dividend >= divisor?\n+\tbf\t2f\n+\tsubu\ta3, a1\t// if yes, subtract divisor\n+2:\n+\taddc\ta2, a2\t// shift by 1 and count subtracts\n+\tbf\t1b\t// if sentinel falls out of quotient, stop\n+\n+4:\n+\tmov\ta0, a3\t// and piggyback the remainder\n+\tjmp\tlr\n+FUNC_END urem32\n+FUNC_END umodsi3\n+#endif\n+\n+\n+#ifdef\tL_divsi3\n+FUNC_START div32\n+FUNC_START divsi3\n+\tcmpnei\ta1, 0\t// look for 0 divisor\n+\tbt\t9f\n+\ttrap\t3\t// divide by 0\n+9:\n+\t// control iterations, skip across high order 0 bits in dividend\n+\tcmpnei\ta0, 0\n+\tbt\t8f\n+\tjmp\tlr\t// 0 dividend quick return\n+8:\n+\tpush\tl0, l1\n+\tmov\tl1, a0\n+\txor\tl1, a1\t// calc sign of quotient\n+\tABS_M\ta0\n+\tABS_M\ta1\n+\tmovi\ta2, 1\t// a2 is quotient (1 for a sentinel)\n+\tmov\ta3, a0\n+\tFF1_M\tl0, a3\t// figure distance to skip\n+\tlsl\ta2, l0\t// move the sentinel along (with 0's behind)\n+\tlsl\ta0, l0\t// and the low 32 bits of numerator\n+\n+\t// FIXME: is this correct?\n+\tmov\ta3, a1\t// looking at divisor\n+\tFF1_M\tl0, a3\t// I can move 32-l0 more bits to left.\n+\taddi\tl0, 1\t// ok, one short of that...\n+\tmov\ta3, a0\n+\tlsr\ta3, l0\t// bits that came from low order...\n+\tnot\tl0\t// l0 == \"32-n\" == LEFT distance\n+\taddi\tl0, 33\t// this is (32-n)\n+\tlsl\ta2,l0\t// fixes the high 32 (quotient)\n+\tlsl\ta0,l0\n+\tcmpnei\ta2,0\n+\tbf\t4f\t// the sentinel went away...\n+\n+\t// run the remaining bits\n+1:\n+\tLSLC_M\ta0\t// 1 bit left shift of a3-a0\n+\taddc\ta3, a3\n+\tcmphs\ta3, a1\t// upper 32 of dividend >= divisor?\n+\tbf\t2f\n+\tsubu\ta3, a1\t// if yes, subtract divisor\n+2:\n+\taddc\ta2, a2\t// shift by 1 and count subtracts\n+\tbf\t1b\t// if sentinel falls out of quotient, stop\n+\n+4:\n+\tmov\ta0, a2\t// return quotient\n+\tmov\ta1, a3\t// and piggyback the remainder\n+\tLSLC_M\tl1\t// after adjusting for sign\n+\tbf\t3f\n+\tnot\ta0\n+\taddi\ta0, 1\n+\tnot\ta1\n+\taddi\ta1, 1\n+3:\n+\tpop\tl0, l1\n+FUNC_END div32\n+FUNC_END divsi3\n+#endif\n+\n+#ifdef\tL_modsi3\n+FUNC_START rem32\n+FUNC_START modsi3\n+\tpush\tl0\n+\tcmpnei\ta1, 0\t// look for 0 divisor\n+\tbt\t9f\n+\ttrap\t3\t// divide by 0\n+9:\n+\t// control iterations, skip across high order 0 bits in dividend\n+\tcmpnei\ta0, 0\n+\tbt\t8f\n+\tpop\tl0\t// 0 dividend quick return\n+8:\n+\tmov\tl0, a0\n+\tABS_M\ta0\n+\tABS_M\ta1\n+\tmov\ta2, a0\n+\tFF1_M\ta3, a2\t// figure distance to skip\n+\tmovi\ta2, 1\t// a2 is quotient (1 for a sentinel)\n+\tlsl\ta2, a3\t// move the sentinel along (with 0's behind)\n+\tlsl\ta0, a3\t// and the low 32 bits of numerator\n+\tmovi\ta3, 0\n+\n+\t// run the remaining bits\n+1:\n+\tLSLC_M\ta0\t// 1 bit left shift of a3-a0\n+\taddc\ta3, a3\n+\tcmphs\ta3, a1\t// upper 32 of dividend >= divisor?\n+\tbf\t2f\n+\tsubu\ta3, a1\t// if yes, subtract divisor\n+2:\n+\taddc\ta2, a2\t// shift by 1 and count subtracts\n+\tbf\t1b\t// if sentinel falls out of quotient, stop\n+\n+4:\n+\tmov\ta0, a3\t// and piggyback the remainder\n+\tLSLC_M\tl0\t// after adjusting for sign\n+\tbf\t3f\n+\tnot\ta0\n+\taddi\ta0, 1\n+3:\n+\tpop\tl0\n+FUNC_END rem32\n+FUNC_END modsi3\n+#endif\n+\n+/* Unordered comparisons for single and double float.  */\n+\n+#ifdef L_unordsf2\n+FUNC_START unordsf2\n+#if defined(__CK801__)\n+\t subi\t  sp, 4\n+\t st.w\t  r4, (sp, 0x0)\n+\t lsli\t  r2, r0, 1\n+\t lsli\t  r3, r1, 1\n+\t asri\t  r4, r2, 24\n+\t not\t  r4\n+\t cmpnei\t  r4, 0\n+\t bt\t  1f\n+\t lsli\t  r4, r0, 9\n+\t cmpnei\t  r4, 0\n+\t bt\t  3f\n+1:\n+\t asri\t  r4, r3, 24\n+\t not\t  r4\n+\t cmpnei\t  r4, 0\n+\t bt\t  2f\n+\t lsli\t  r4, r1, 9\n+\t cmpnei\t  r4, 0\n+\t bt\t  3f\n+2:\n+\t ld.w\t  r4, (sp, 0x0)\n+\t addi\t  sp, 4\n+\t movi\t  r0, 0\n+\t rts\n+3:\n+\t ld.w\t  r4, (sp, 0x0)\n+\t addi\t  sp, 4\n+\t movi\t  r0, 1\n+\t rts\n+#elif defined(__CK802__)\n+\t lsli\t  r2, r0, 1\n+\t lsli\t  r3, r1, 1\n+\t asri\t  r2, r2, 24\n+\t not\t  r13, r2\n+\t cmpnei\t  r13, 0\n+\t bt\t  1f\n+\t lsli\t  r13, r0, 9\n+\t cmpnei\t  r13, 0\n+\t bt\t  3f\n+1:\n+\t asri\t  r3, r3, 24\n+\t not\t  r13, r3\n+\t cmpnei\t  r13, 0\n+\t bt\t  2f\n+\t lsli\t  r13, r1, 9\n+\t cmpnei\t  r13, 0\n+\t bt\t  3f\n+2:\n+\t movi\t  r0, 0\n+\t rts\n+3:\n+\t movi\t  r0, 1\n+\t rts\n+#else\n+\t lsli\t  r2, r0, 1\n+\t lsli\t  r3, r1, 1\n+\t asri\t  r2, r2, 24\n+\t not\t  r13, r2\n+\t bnez\t  r13, 1f\n+\t lsli\t  r13, r0, 9\n+\t bnez\t  r13, 3f\n+1:\n+\t asri\t  r3, r3, 24\n+\t not\t  r13, r3\n+\t bnez\t  r13, 2f\n+\t lsli\t  r13, r1, 9\n+\t bnez\t  r13, 3f\n+2:\n+\t movi\t  r0, 0\n+\t rts\n+3:\n+\t movi\t  r0, 1\n+\t rts\n+#endif\n+FUNC_END unordsf2\n+#endif\n+\n+#ifdef L_unorddf2\n+FUNC_START unorddf2\n+#if defined(__CK801__)\n+\t subi\t  sp, 8\n+\t st.w\t  r4, (sp, 0x0)\n+\t st.w\t  r5, (sp, 0x4)\n+\t lsli\t  r4, xh, 1\n+\t asri\t  r4, r4, 21\n+\t not\t  r4\n+\t cmpnei\t  r4, 0\n+\t bt\t  1f\n+\t mov\t  r4, xl\n+\t lsli\t  r5, xh, 12\n+\t or\t  r4, r5\n+\t cmpnei\t  r4, 0\n+\t bt\t  3f\n+1:\n+\t lsli\t  r4, yh, 1\n+\t asri\t  r4, r4, 21\n+\t not\t  r4\n+\t cmpnei\t  r4, 0\n+\t bt\t  2f\n+\t mov\t  r4,yl\n+\t lsli\t  r5, yh, 12\n+\t or\t  r4, r5\n+\t cmpnei\t  r4, 0\n+\t bt\t  3f\n+2:\n+\t ld.w\t  r4, (sp, 0x0)\n+\t ld.w\t  r5, (sp, 0x4)\n+\t addi\t  sp, 8\n+\t movi\t  r0, 0\n+\t rts\n+3:\n+\t ld.w\t  r4, (sp, 0x0)\n+\t ld.w\t  r5, (sp, 0x4)\n+\t addi\t  sp, 8\n+\t movi\t  r0, 1\n+\t rts\n+#elif defined(__CK802__)\n+\t lsli\t  r13, xh, 1\n+\t asri\t  r13, r13, 21\n+\t not\t  r13\n+\t cmpnei\t  r13, 0\n+\t bt\t  1f\n+\t lsli\t  xh, xh, 12\n+\t or\t  r13, xl, xh\n+\t cmpnei\t  r13, 0\n+\t bt\t  3f\n+1:\n+\t lsli\t  r13, yh, 1\n+\t asri\t  r13, r13, 21\n+\t not\t  r13\n+\t cmpnei\t  r13, 0\n+\t bt\t  2f\n+\t lsli\t  yh, yh, 12\n+\t or\t  r13, yl, yh\n+\t cmpnei\t  r13, 0\n+\t bt\t  3f\n+2:\n+\t movi\t  r0, 0\n+\t rts\n+3:\n+\t movi\t  r0, 1\n+\t rts\n+#else\n+\t lsli\t  r13, xh, 1\n+\t asri\t  r13, r13, 21\n+\t not\t  r13\n+\t bnez\t  r13, 1f\n+\t lsli\t  xh, xh, 12\n+\t or\t  r13, xl, xh\n+\t bnez\t  r13, 3f\n+1:\n+\t lsli\t  r13, yh, 1\n+\t asri\t  r13, r13, 21\n+\t not\t  r13\n+\t bnez\t  r13, 2f\n+\t lsli\t  yh, yh, 12\n+\t or\t  r13, yl, yh\n+\t bnez\t  r13, 3f\n+2:\n+\t movi\t  r0, 0\n+\t rts\n+3:\n+\t movi\t  r0, 1\n+\t rts\n+#endif\n+FUNC_END unorddf2\n+#endif\n+\n+/* When optimizing for size on ck801 and ck802, GCC emits calls to the\n+   following helper functions when expanding casesi, instead of emitting\n+   the table lookup and jump inline.  Note that in these functions the\n+   jump is handled by tweaking the value of lr before rts.  */\n+#ifdef L_csky_case_sqi\n+FUNC_START _gnu_csky_case_sqi\n+\tsubi\tsp, 4\n+\tst.w\ta1, (sp, 0x0)\n+\tmov\ta1, lr\n+\tadd\ta1, a1, a0\n+\tLDBS_M\ta1, a1\n+\tlsli\ta1, a1, 1\n+\tadd\tlr, lr, a1\n+\tld.w\ta1, (sp, 0x0)\n+\taddi\tsp, 4\n+\trts\n+FUNC_END _gnu_csky_case_sqi\n+#endif\n+\n+#ifdef L_csky_case_uqi\n+FUNC_START _gnu_csky_case_uqi\n+\tsubi\tsp, 4\n+\tst.w\ta1, (sp, 0x0)\n+\tmov\ta1, lr\n+\tadd\ta1, a1, a0\n+\tld.b\ta1, (a1, 0x0)\n+\tlsli\ta1, a1, 1\n+\tadd\tlr, lr, a1\n+\tld.w\ta1, (sp, 0x0)\n+\taddi\tsp, 4\n+\trts\n+FUNC_END _gnu_csky_case_uqi\n+#endif\n+\n+#ifdef L_csky_case_shi\n+FUNC_START _gnu_csky_case_shi\n+\tsubi\tsp, 8\n+\tst.w\ta0, (sp, 0x4)\n+\tst.w\ta1, (sp, 0x0)\n+\tmov\ta1, lr\n+\tlsli\ta0, a0, 1\n+\tadd\ta1, a1, a0\n+\tLDHS_M\ta1, a1\n+\tlsli\ta1, a1, 1\n+\tadd\tlr, lr, a1\n+\tld.w\ta0, (sp, 0x4)\n+\tld.w\ta1, (sp, 0x0)\n+\taddi\tsp, 8\n+\trts\n+FUNC_END _gnu_csky_case_shi\n+#endif\n+\n+#ifdef L_csky_case_uhi\n+FUNC_START _gnu_csky_case_uhi\n+\tsubi\tsp, 8\n+\tst.w\ta0, (sp, 0x4)\n+\tst.w\ta1, (sp, 0x0)\n+\tmov\ta1, lr\n+\tlsli\ta0, a0, 1\n+\tadd\ta1, a1, a0\n+\tld.h\ta1, (a1, 0x0)\n+\tlsli\ta1, a1, 1\n+\tadd\tlr, lr, a1\n+\tld.w\ta0, (sp, 0x4)\n+\tld.w\ta1, (sp, 0x0)\n+\taddi\tsp, 8\n+\trts\n+FUNC_END _gnu_csky_case_uhi\n+#endif\n+\n+#ifdef L_csky_case_si\n+FUNC_START _gnu_csky_case_si\n+\tsubi\tsp, 8\n+\tst.w\ta0, (sp, 0x4)\n+\tst.w\ta1, (sp, 0x0)\n+\tmov\ta1, lr\n+\taddi\ta1, a1, 2\t// Align to word.\n+\tbclri\ta1, a1, 1\n+\tmov\tlr, a1\n+\tlsli\ta0, a0, 2\n+\tadd\ta1, a1, a0\n+\tld.w\ta0, (a1, 0x0)\n+\tadd\tlr, lr, a0\n+\tld.w\ta0, (sp, 0x4)\n+\tld.w\ta1, (sp, 0x0)\n+\taddi\tsp, 8\n+\trts\n+FUNC_END _gnu_csky_case_si\n+#endif\n+\n+/* GCC expects that {__eq,__ne,__gt,__ge,__le,__lt}{df2,sf2}\n+   will behave as __cmpdf2. So, we stub the implementations to\n+   jump on to __cmpdf2 and __cmpsf2.\n+\n+   All of these short-circuit the return path so that __cmp{sd}f2\n+   will go directly back to the caller.  */\n+\n+.macro\tCOMPARE_DF_JUMP name\n+\t.import SYM (cmpdf2)\n+FUNC_START \\name\n+\tjmpi SYM (cmpdf2)\n+FUNC_END \\name\n+.endm\n+\n+#ifdef\tL_eqdf2\n+COMPARE_DF_JUMP eqdf2\n+#endif /* L_eqdf2 */\n+\n+#ifdef\tL_nedf2\n+COMPARE_DF_JUMP nedf2\n+#endif /* L_nedf2 */\n+\n+#ifdef\tL_gtdf2\n+COMPARE_DF_JUMP gtdf2\n+#endif /* L_gtdf2 */\n+\n+#ifdef\tL_gedf2\n+COMPARE_DF_JUMP gedf2\n+#endif /* L_gedf2 */\n+\n+#ifdef\tL_ltdf2\n+COMPARE_DF_JUMP ltdf2\n+#endif /* L_ltdf2 */\n+\n+#ifdef\tL_ledf2\n+COMPARE_DF_JUMP ledf2\n+#endif /* L_ledf2 */\n+\n+/* Single-precision floating point stubs.  */\n+\n+.macro\tCOMPARE_SF_JUMP name\n+\t.import SYM (cmpsf2)\n+FUNC_START \\name\n+\tjmpi SYM (cmpsf2)\n+FUNC_END \\name\n+.endm\n+\n+#ifdef\tL_eqsf2\n+COMPARE_SF_JUMP eqsf2\n+#endif /* L_eqsf2 */\n+\n+#ifdef\tL_nesf2\n+COMPARE_SF_JUMP nesf2\n+#endif /* L_nesf2 */\n+\n+#ifdef\tL_gtsf2\n+COMPARE_SF_JUMP gtsf2\n+#endif /* L_gtsf2 */\n+\n+#ifdef\tL_gesf2\n+COMPARE_SF_JUMP __gesf2\n+#endif /* L_gesf2 */\n+\n+#ifdef\tL_ltsf2\n+COMPARE_SF_JUMP __ltsf2\n+#endif /* L_ltsf2 */\n+\n+#ifdef\tL_lesf2\n+COMPARE_SF_JUMP lesf2\n+#endif /* L_lesf2 */"}, {"sha": "03cf2c02fbb1f0c2fa58c8c79fe199a7924f6ad4", "filename": "libgcc/config/csky/linux-atomic.c", "status": "added", "additions": 299, "deletions": 0, "changes": 299, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cd0bc3b696fd8ea70f8e3d80d4eb4440e01f554/libgcc%2Fconfig%2Fcsky%2Flinux-atomic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cd0bc3b696fd8ea70f8e3d80d4eb4440e01f554/libgcc%2Fconfig%2Fcsky%2Flinux-atomic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fcsky%2Flinux-atomic.c?ref=4cd0bc3b696fd8ea70f8e3d80d4eb4440e01f554", "patch": "@@ -0,0 +1,299 @@\n+/* Linux-specific atomic operations for C-SKY.\n+   Copyright (C) 2018 Free Software Foundation, Inc.\n+   Contributed by C-SKY Microsystems and Mentor Graphics.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.\t */\n+\n+/* Kernel helper for compare-and-exchange.  */\n+inline int\n+__kernel_cmpxchg (int oldval, int newval, volatile int *ptr)\n+{\n+  register int _a0 asm (\"a0\") = oldval;\n+  register int _a1 asm (\"a1\") = newval;\n+  register volatile int *_a2 asm (\"a2\") = ptr;\n+  __asm__ __volatile__ (\"trap\t  2\\n\"\t    \\\n+\t\t\t:\"+r\" (_a0) :\"r\" (_a1) , \"r\" (_a2)\t\\\n+\t\t\t: \"a3\", \"memory\");\t\t\t\\\n+  return _a0;\n+}\n+\n+\n+/* Kernel helper for memory barrier.  */\n+inline void __kernel_dmb (void)\n+{\n+  asm (\"sync\":::\"memory\");\n+}\n+\n+/* Note: we implement byte, short and int versions of atomic operations using\n+   the above kernel helpers, but there is no support for \"long long\" (64-bit)\n+   operations as yet.  */\n+\n+#define HIDDEN __attribute__ ((visibility (\"hidden\")))\n+\n+#ifdef __CSKYLE__\n+#define INVERT_MASK_1 0\n+#define INVERT_MASK_2 0\n+#else\n+#define INVERT_MASK_1 24\n+#define INVERT_MASK_2 16\n+#endif\n+\n+#define MASK_1 0xffu\n+#define MASK_2 0xffffu\n+\n+#define FETCH_AND_OP_WORD(OP, PFX_OP, INF_OP)\t\t\t\t\\\n+  int HIDDEN\t\t\t\t\t\t\t\t\\\n+  __sync_fetch_and_##OP##_4 (int *ptr, int val)\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    int failure, tmp;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    do\t\t\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\ttmp = *ptr;\t\t\t\t\t\t\t\\\n+\tfailure = __kernel_cmpxchg (tmp, PFX_OP (tmp INF_OP val), ptr);\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    while (failure != 0);\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    return tmp;\t\t\t\t\t\t\t\t\\\n+  }\n+\n+FETCH_AND_OP_WORD (add,\t  , +)\n+FETCH_AND_OP_WORD (sub,\t  , -)\n+FETCH_AND_OP_WORD (or,\t  , |)\n+FETCH_AND_OP_WORD (and,\t  , &)\n+FETCH_AND_OP_WORD (xor,\t  , ^)\n+FETCH_AND_OP_WORD (nand, ~, &)\n+\n+#define NAME_oldval(OP, WIDTH) __sync_fetch_and_##OP##_##WIDTH\n+#define NAME_newval(OP, WIDTH) __sync_##OP##_and_fetch_##WIDTH\n+\n+/* Implement both __sync_<op>_and_fetch and __sync_fetch_and_<op> for\n+   subword-sized quantities.  */\n+\n+#define SUBWORD_SYNC_OP(OP, PFX_OP, INF_OP, TYPE, WIDTH, RETURN)\t\\\n+  TYPE HIDDEN\t\t\t\t\t\t\t\t\\\n+  NAME##_##RETURN (OP, WIDTH) (TYPE *ptr, TYPE val)\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    int *wordptr = (int *) ((unsigned int) ptr & ~3);\t\t\t\\\n+    unsigned int mask, shift, oldval, newval;\t\t\t\t\\\n+    int failure;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    shift = (((unsigned int) ptr & 3) << 3) ^ INVERT_MASK_##WIDTH;\t\\\n+    mask = MASK_##WIDTH << shift;\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    do\t\t\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\toldval = *wordptr;\t\t\t\t\t\t\\\n+\tnewval = ((PFX_OP (((oldval & mask) >> shift)\t\t\t\\\n+\t\t   INF_OP (unsigned int) val)) << shift) & mask;\t\\\n+\tnewval |= oldval & ~mask;\t\t\t\t\t\\\n+\tfailure = __kernel_cmpxchg (oldval, newval, wordptr);\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    while (failure != 0);\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    return (RETURN & mask) >> shift;\t\t\t\t\t\\\n+  }\n+\n+SUBWORD_SYNC_OP (add,\t, +, unsigned short, 2, oldval)\n+SUBWORD_SYNC_OP (sub,\t, -, unsigned short, 2, oldval)\n+SUBWORD_SYNC_OP (or,\t, |, unsigned short, 2, oldval)\n+SUBWORD_SYNC_OP (and,\t, &, unsigned short, 2, oldval)\n+SUBWORD_SYNC_OP (xor,\t, ^, unsigned short, 2, oldval)\n+SUBWORD_SYNC_OP (nand, ~, &, unsigned short, 2, oldval)\n+\n+SUBWORD_SYNC_OP (add,\t, +, unsigned char, 1, oldval)\n+SUBWORD_SYNC_OP (sub,\t, -, unsigned char, 1, oldval)\n+SUBWORD_SYNC_OP (or,\t, |, unsigned char, 1, oldval)\n+SUBWORD_SYNC_OP (and,\t, &, unsigned char, 1, oldval)\n+SUBWORD_SYNC_OP (xor,\t, ^, unsigned char, 1, oldval)\n+SUBWORD_SYNC_OP (nand, ~, &, unsigned char, 1, oldval)\n+\n+#define OP_AND_FETCH_WORD(OP, PFX_OP, INF_OP)\t\t\t\t\\\n+  int HIDDEN\t\t\t\t\t\t\t\t\\\n+  __sync_##OP##_and_fetch_4 (int *ptr, int val)\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    int tmp, failure;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    do\t\t\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\ttmp = *ptr;\t\t\t\t\t\t\t\\\n+\tfailure = __kernel_cmpxchg (tmp, PFX_OP tmp INF_OP val, ptr);\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    while (failure != 0);\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    return PFX_OP tmp INF_OP val;\t\t\t\t\t\\\n+  }\n+\n+OP_AND_FETCH_WORD (add,\t  , +)\n+OP_AND_FETCH_WORD (sub,\t  , -)\n+OP_AND_FETCH_WORD (or,\t  , |)\n+OP_AND_FETCH_WORD (and,\t  , &)\n+OP_AND_FETCH_WORD (xor,\t  , ^)\n+OP_AND_FETCH_WORD (nand, ~, &)\n+\n+SUBWORD_SYNC_OP (add,\t, +, unsigned short, 2, newval)\n+SUBWORD_SYNC_OP (sub,\t, -, unsigned short, 2, newval)\n+SUBWORD_SYNC_OP (or,\t, |, unsigned short, 2, newval)\n+SUBWORD_SYNC_OP (and,\t, &, unsigned short, 2, newval)\n+SUBWORD_SYNC_OP (xor,\t, ^, unsigned short, 2, newval)\n+SUBWORD_SYNC_OP (nand, ~, &, unsigned short, 2, newval)\n+\n+SUBWORD_SYNC_OP (add,\t, +, unsigned char, 1, newval)\n+SUBWORD_SYNC_OP (sub,\t, -, unsigned char, 1, newval)\n+SUBWORD_SYNC_OP (or,\t, |, unsigned char, 1, newval)\n+SUBWORD_SYNC_OP (and,\t, &, unsigned char, 1, newval)\n+SUBWORD_SYNC_OP (xor,\t, ^, unsigned char, 1, newval)\n+SUBWORD_SYNC_OP (nand, ~, &, unsigned char, 1, newval)\n+\n+int HIDDEN\n+__sync_val_compare_and_swap_4 (int *ptr, int oldval, int newval)\n+{\n+  int actual_oldval, fail;\n+\n+  while (1)\n+    {\n+      actual_oldval = *ptr;\n+\n+      if (oldval != actual_oldval)\n+\treturn actual_oldval;\n+\n+      fail = __kernel_cmpxchg (actual_oldval, newval, ptr);\n+\n+      if (!fail)\n+\treturn oldval;\n+    }\n+}\n+\n+#define SUBWORD_VAL_CAS(TYPE, WIDTH)\t\t\t\t\t\\\n+  TYPE HIDDEN\t\t\t\t\t\t\t\t\\\n+  __sync_val_compare_and_swap_##WIDTH (TYPE *ptr, TYPE oldval,\t\t\\\n+\t\t\t\t       TYPE newval)\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    int *wordptr = (int *)((unsigned int) ptr & ~3), fail;\t\t\\\n+    unsigned int mask, shift, actual_oldval, actual_newval;\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    shift = (((unsigned int) ptr & 3) << 3) ^ INVERT_MASK_##WIDTH;\t\\\n+    mask = MASK_##WIDTH << shift;\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    while (1)\t\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tactual_oldval = *wordptr;\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tif (((actual_oldval & mask) >> shift) != (unsigned int) oldval)\t\\\n+\t  return (actual_oldval & mask) >> shift;\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tactual_newval = (actual_oldval & ~mask)\t\t\t\t\\\n+\t\t\t| (((unsigned int) newval << shift) & mask);\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tfail = __kernel_cmpxchg (actual_oldval, actual_newval,\t\t\\\n+\t\t\t\t wordptr);\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tif (!fail)\t\t\t\t\t\t\t\\\n+\t  return oldval;\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  }\n+\n+SUBWORD_VAL_CAS (unsigned short, 2)\n+SUBWORD_VAL_CAS (unsigned char,\t1)\n+\n+typedef unsigned char bool;\n+\n+bool HIDDEN\n+__sync_bool_compare_and_swap_4 (int *ptr, int oldval, int newval)\n+{\n+  int failure = __kernel_cmpxchg (oldval, newval, ptr);\n+  return (failure == 0);\n+}\n+\n+#define SUBWORD_BOOL_CAS(TYPE, WIDTH)\t\t\t\t\t\\\n+  bool HIDDEN\t\t\t\t\t\t\t\t\\\n+  __sync_bool_compare_and_swap_##WIDTH (TYPE *ptr, TYPE oldval,\t\t\\\n+\t\t\t\t\tTYPE newval)\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    TYPE actual_oldval\t\t\t\t\t\t\t\\\n+      = __sync_val_compare_and_swap_##WIDTH (ptr, oldval, newval);\t\\\n+    return (oldval == actual_oldval);\t\t\t\t\t\\\n+  }\n+\n+SUBWORD_BOOL_CAS (unsigned short, 2)\n+SUBWORD_BOOL_CAS (unsigned char, 1)\n+\n+void HIDDEN\n+__sync_synchronize (void)\n+{\n+  __kernel_dmb ();\n+}\n+\n+int HIDDEN\n+__sync_lock_test_and_set_4 (int *ptr, int val)\n+{\n+  int failure, oldval;\n+\n+  do\n+    {\n+      oldval = *ptr;\n+      failure = __kernel_cmpxchg (oldval, val, ptr);\n+    }\n+  while (failure != 0);\n+\n+  return oldval;\n+}\n+\n+#define SUBWORD_TEST_AND_SET(TYPE, WIDTH)\t\t\t\t\\\n+  TYPE HIDDEN\t\t\t\t\t\t\t\t\\\n+  __sync_lock_test_and_set_##WIDTH (TYPE *ptr, TYPE val)\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    int failure;\t\t\t\t\t\t\t\\\n+    unsigned int oldval, newval, shift, mask;\t\t\t\t\\\n+    int *wordptr = (int *) ((unsigned int) ptr & ~3);\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    shift = (((unsigned int) ptr & 3) << 3) ^ INVERT_MASK_##WIDTH;\t\\\n+    mask = MASK_##WIDTH << shift;\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    do\t\t\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\toldval = *wordptr;\t\t\t\t\t\t\\\n+\tnewval = ((oldval & ~mask)\t\t\t\t\t\\\n+\t\t  | (((unsigned int) val << shift) & mask));\t\t\\\n+\tfailure = __kernel_cmpxchg (oldval, newval, wordptr);\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    while (failure != 0);\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    return (oldval & mask) >> shift;\t\t\t\t\t\\\n+  }\n+\n+SUBWORD_TEST_AND_SET (unsigned short, 2)\n+SUBWORD_TEST_AND_SET (unsigned char,  1)\n+\n+#define SYNC_LOCK_RELEASE(TYPE, WIDTH)\t\t\t\t\t\\\n+  void HIDDEN\t\t\t\t\t\t\t\t\\\n+  __sync_lock_release_##WIDTH (TYPE *ptr)\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    /* All writes before this point must be seen before we release\t\\\n+       the lock itself.\t */\t\t\t\t\t\t\\\n+    __kernel_dmb ();\t\t\t\t\t\t\t\\\n+    *ptr = 0;\t\t\t\t\t\t\t\t\\\n+  }\n+\n+SYNC_LOCK_RELEASE (int,\t  4)\n+SYNC_LOCK_RELEASE (short, 2)\n+SYNC_LOCK_RELEASE (char,  1)"}, {"sha": "24638defd527b827d051019d9df1a8dbaca5cbe4", "filename": "libgcc/config/csky/linux-unwind.h", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cd0bc3b696fd8ea70f8e3d80d4eb4440e01f554/libgcc%2Fconfig%2Fcsky%2Flinux-unwind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cd0bc3b696fd8ea70f8e3d80d4eb4440e01f554/libgcc%2Fconfig%2Fcsky%2Flinux-unwind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fcsky%2Flinux-unwind.h?ref=4cd0bc3b696fd8ea70f8e3d80d4eb4440e01f554", "patch": "@@ -0,0 +1,131 @@\n+/* DWARF2 EH unwinding support for C-SKY Linux.\n+   Copyright (C) 2018 Free Software Foundation, Inc.\n+   Contributed by C-SKY Microsystems and Mentor Graphics.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef inhibit_libc\n+\n+/* Do code reading to identify a signal frame, and set the frame\n+   state data appropriately.  See unwind-dw2.c for the structs.  */\n+\n+#include <signal.h>\n+#include <asm/unistd.h>\n+\n+/* The third parameter to the signal handler points to something with\n+   this structure defined in asm/ucontext.h, but the name clashes with\n+   struct ucontext from sys/ucontext.h so this private copy is used.  */\n+typedef struct _sig_ucontext {\n+  unsigned long         uc_flags;\n+  struct _sig_ucontext  *uc_link;\n+  stack_t               uc_stack;\n+  struct sigcontext     uc_mcontext;\n+  sigset_t              uc_sigmask;\n+} _sig_ucontext_t;\n+\n+#define MD_FALLBACK_FRAME_STATE_FOR csky_fallback_frame_state\n+\n+static _Unwind_Reason_Code\n+csky_fallback_frame_state (struct _Unwind_Context *context,\n+\t\t\t   _Unwind_FrameState *fs)\n+{\n+  u_int16_t *pc = (u_int16_t *) context->ra;\n+  struct sigcontext *sc;\n+  _Unwind_Ptr new_cfa;\n+  int i;\n+\n+  /* movi r7, __NR_rt_sigreturn; trap 0  */\n+  if ((*(pc+0) == 0xea07) && (*(pc+1) == 119)\n+      && (*(pc+2) == 0xc000) &&  (*(pc+3) == 0x2020))\n+  {\n+    struct sigframe\n+    {\n+      int sig;\n+      int code;\n+      struct sigcontext *psc;\n+      unsigned long extramask[2]; /* _NSIG_WORDS */\n+      struct sigcontext sc;\n+    } *_rt = context->cfa;\n+    sc = _rt->psc; // &(_rt->sc);\n+  }\n+  /* movi r7, __NR_rt_sigreturn; trap 0  */\n+  else if ((*(pc+0) == 0xea07) && (*(pc+1) == 173)\n+\t   && (*(pc+2) == 0xc000) &&  (*(pc+3) == 0x2020))\n+  {\n+    struct rt_sigframe\n+    {\n+      int sig;\n+      struct siginfo *pinfo;\n+      void* puc;\n+      siginfo_t info;\n+      struct ucontext uc;\n+    } *_rt = context->cfa;\n+    sc = &(_rt->uc.uc_mcontext);\n+  }\n+  else\n+    return _URC_END_OF_STACK;\n+\n+  new_cfa = (_Unwind_Ptr) sc->sc_usp;\n+  fs->regs.cfa_how = CFA_REG_OFFSET;\n+  fs->regs.cfa_reg = STACK_POINTER_REGNUM;\n+  fs->regs.cfa_offset = new_cfa - (_Unwind_Ptr) context->cfa;\n+\n+  fs->regs.reg[0].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[0].loc.offset = (_Unwind_Ptr)&(sc->sc_a0) - new_cfa;\n+\n+  fs->regs.reg[1].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[1].loc.offset = (_Unwind_Ptr)&(sc->sc_a1) - new_cfa;\n+\n+  fs->regs.reg[2].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[2].loc.offset = (_Unwind_Ptr)&(sc->sc_a2) - new_cfa;\n+\n+  fs->regs.reg[3].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[3].loc.offset = (_Unwind_Ptr)&(sc->sc_a3) - new_cfa;\n+\n+  for (i = 4; i < 14; i++)\n+    {\n+      fs->regs.reg[i].how = REG_SAVED_OFFSET;\n+      fs->regs.reg[i].loc.offset = ((_Unwind_Ptr)&(sc->sc_regs[i - 4])\n+\t\t\t\t    - new_cfa);\n+    }\n+\n+  for (i = 16; i < 32; i++)\n+    {\n+      fs->regs.reg[i].how = REG_SAVED_OFFSET;\n+      fs->regs.reg[i].loc.offset = ((_Unwind_Ptr)&(sc->sc_exregs[i - 16])\n+\t\t\t\t    - new_cfa);\n+    }\n+\n+  /* FIXME : hi lo ? */\n+  fs->regs.reg[15].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[15].loc.offset = (_Unwind_Ptr)&(sc->sc_r15) - new_cfa;\n+\n+  fs->regs.reg[56].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[56].loc.offset = (_Unwind_Ptr)&(sc->sc_pc) - new_cfa;\n+  fs->retaddr_column = 56;\n+  fs->signal_frame = 1;\n+\n+  return _URC_NO_REASON;\n+}\n+\n+\n+#endif"}, {"sha": "06aa1c121f902e11540c56907db776618acb892e", "filename": "libgcc/config/csky/t-csky", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cd0bc3b696fd8ea70f8e3d80d4eb4440e01f554/libgcc%2Fconfig%2Fcsky%2Ft-csky", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cd0bc3b696fd8ea70f8e3d80d4eb4440e01f554/libgcc%2Fconfig%2Fcsky%2Ft-csky", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fcsky%2Ft-csky?ref=4cd0bc3b696fd8ea70f8e3d80d4eb4440e01f554", "patch": "@@ -0,0 +1,28 @@\n+# Makefile fragment for all C-SKY targets.\n+# Copyright (C) 2018 Free Software Foundation, Inc.\n+# Contributed by C-SKY Microsystems and Mentor Graphics.\n+#\n+# This file is part of GCC.\n+#\n+# GCC is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3, or (at your option)\n+# any later version.\n+#\n+# GCC is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+LIB1ASMSRC \t= csky/lib1funcs.S\n+LIB1ASMFUNCS   = _divsi3 _udivsi3 _modsi3 _umodsi3 _unorddf2 _unordsf2 \\\n+    _csky_case_sqi _csky_case_uqi  _csky_case_shi _csky_case_uhi _csky_case_si\n+\n+LIB2FUNCS_EXCLUDE  += _unord_df\n+LIB2FUNCS_EXCLUDE  += _unord_sf\n+\n+TARGET_LIBGCC2_CFLAGS=-O3 -DNO_FLOATLIB_FIXUNSDFSI"}, {"sha": "1f5c4ce1a7300c497785da32aff500ffa7c39953", "filename": "libgcc/config/csky/t-linux-csky", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cd0bc3b696fd8ea70f8e3d80d4eb4440e01f554/libgcc%2Fconfig%2Fcsky%2Ft-linux-csky", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cd0bc3b696fd8ea70f8e3d80d4eb4440e01f554/libgcc%2Fconfig%2Fcsky%2Ft-linux-csky", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fcsky%2Ft-linux-csky?ref=4cd0bc3b696fd8ea70f8e3d80d4eb4440e01f554", "patch": "@@ -0,0 +1,21 @@\n+# Makefile fragment for C-SKY targets running Linux.\n+# Copyright (C) 2018 Free Software Foundation, Inc.\n+# Contributed by C-SKY Microsystems and Mentor Graphics.\n+#\n+# This file is part of GCC.\n+#\n+# GCC is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3, or (at your option)\n+# any later version.\n+#\n+# GCC is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+LIB2ADD_ST += $(srcdir)/config/csky/linux-atomic.c"}]}