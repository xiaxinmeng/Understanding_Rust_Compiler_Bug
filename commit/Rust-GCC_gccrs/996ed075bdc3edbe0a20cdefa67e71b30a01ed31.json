{"sha": "996ed075bdc3edbe0a20cdefa67e71b30a01ed31", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTk2ZWQwNzViZGMzZWRiZTBhMjBjZGVmYTY3ZTcxYjMwYTAxZWQzMQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "1999-12-27T08:34:45Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "1999-12-27T08:34:45Z"}, "message": "h8300.h (TARGET_H8300H, [...]): Make sure UNITS_PER_WORD and BITS_PER_WORD are compile time constants when...\n\n\n\t* config/h8300/h8300.h (TARGET_H8300H, TARGET_H8300S): Make sure\n\tUNITS_PER_WORD and BITS_PER_WORD are compile time constants when\n\tcompiling libgcc2.\n\t* config/mips/mips.h (TARGET_64BIT): Likewise.\n\t* config/rs6000/rs6000.h (TARGET_POWERPC64): Likewise.\n\t* libgcc2.c: Use {,U}{HW,W,DW}type and DWunion everywhere instead\n\tof {SI,DI}type and DIunion.  Define these types to QI/HI modes on\n\tdsps.  Give routines proper names if SI/DI modes are not used.\n\t* longlong.h: Use DWunion instead of DIunion.\n\nFrom-SVN: r31095", "tree": {"sha": "02d25e0bc1c4d0f63ccc0fa33aaf34217c6cd2e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/02d25e0bc1c4d0f63ccc0fa33aaf34217c6cd2e7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/996ed075bdc3edbe0a20cdefa67e71b30a01ed31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/996ed075bdc3edbe0a20cdefa67e71b30a01ed31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/996ed075bdc3edbe0a20cdefa67e71b30a01ed31", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/996ed075bdc3edbe0a20cdefa67e71b30a01ed31/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9310f1eb4c883fcdcbfb606667f5ee6d237ab804", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9310f1eb4c883fcdcbfb606667f5ee6d237ab804", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9310f1eb4c883fcdcbfb606667f5ee6d237ab804"}], "stats": {"total": 527, "additions": 334, "deletions": 193}, "files": [{"sha": "dd06786f1b528fa8a5799517c5cdb5bb8b33b2b6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ed075bdc3edbe0a20cdefa67e71b30a01ed31/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ed075bdc3edbe0a20cdefa67e71b30a01ed31/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=996ed075bdc3edbe0a20cdefa67e71b30a01ed31", "patch": "@@ -1,3 +1,15 @@\n+1999-12-17  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* config/h8300/h8300.h (TARGET_H8300H, TARGET_H8300S): Make sure\n+\tUNITS_PER_WORD and BITS_PER_WORD are compile time constants when\n+\tcompiling libgcc2.\n+\t* config/mips/mips.h (TARGET_64BIT): Likewise.\n+\t* config/rs6000/rs6000.h (TARGET_POWERPC64): Likewise.\n+\t* libgcc2.c: Use {,U}{HW,W,DW}type and DWunion everywhere instead\n+\tof {SI,DI}type and DIunion.  Define these types to QI/HI modes on\n+\tdsps.  Give routines proper names if SI/DI modes are not used.\n+\t* longlong.h: Use DWunion instead of DIunion.\n+\n 1999-12-26  Zack Weinberg  <zack@wolery.cumb.org>\n \n \t* acconfig.h: New ENABLE flags: TREE_CHECKING, RTL_CHECKING,"}, {"sha": "1c980b752cffbdb9797113d516010b40507b18f2", "filename": "gcc/config/h8300/h8300.h", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ed075bdc3edbe0a20cdefa67e71b30a01ed31/gcc%2Fconfig%2Fh8300%2Fh8300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ed075bdc3edbe0a20cdefa67e71b30a01ed31/gcc%2Fconfig%2Fh8300%2Fh8300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.h?ref=996ed075bdc3edbe0a20cdefa67e71b30a01ed31", "patch": "@@ -112,6 +112,23 @@ extern int target_flags;\n     {\"align-300\",\t8192,  \"Use H8/300 alignment rules\"},\t\t\\\n     { \"\", TARGET_DEFAULT, NULL}}\n \n+#ifdef IN_LIBGCC2\n+#undef TARGET_H8300H\n+#undef TARGET_H8300S\n+/* If compiling libgcc2, make these compile time constants based on what\n+   flags are we actually compiling with.  */\n+#ifdef __H8300H__\n+#define TARGET_H8300H\t1\n+#else\n+#define TARGET_H8300H\t0\n+#endif\n+#ifdef __H8300S__\n+#define TARGET_H8300S\t1\n+#else\n+#define TARGET_H8300S\t0\n+#endif\n+#endif /* !IN_LIBGCC2 */\n+\n /* Do things that must be done once at start up.  */\n \n #define OVERRIDE_OPTIONS \\"}, {"sha": "8d8dcd080022037b3e0c9b9d382b437cde285355", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ed075bdc3edbe0a20cdefa67e71b30a01ed31/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ed075bdc3edbe0a20cdefa67e71b30a01ed31/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=996ed075bdc3edbe0a20cdefa67e71b30a01ed31", "patch": "@@ -481,6 +481,16 @@ extern void\t\tsbss_section PARAMS ((void));\n #define MIPS_ISA_DEFAULT 1\n #endif\n \n+#ifdef IN_LIBGCC2\n+#undef TARGET_64BIT\n+/* Make this compile time constant for libgcc2 */\n+#ifdef __mips64\n+#define TARGET_64BIT\t\t1\n+#else\n+#define TARGET_64BIT\t\t0\n+#endif\n+#else /* IN_LIBGCC2 */\n+\n #ifndef MULTILIB_ENDIAN_DEFAULT\n #if TARGET_ENDIAN_DEFAULT == 0\n #define MULTILIB_ENDIAN_DEFAULT \"EL\""}, {"sha": "f3f3f2e85f7971833533788b4e2c1efcad2b7f1a", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ed075bdc3edbe0a20cdefa67e71b30a01ed31/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ed075bdc3edbe0a20cdefa67e71b30a01ed31/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=996ed075bdc3edbe0a20cdefa67e71b30a01ed31", "patch": "@@ -303,6 +303,16 @@ extern int target_flags;\n #define TARGET_UPDATE\t\t(! TARGET_NO_UPDATE)\n #define TARGET_FUSED_MADD\t(! TARGET_NO_FUSED_MADD)\n \n+#ifdef IN_LIBGCC2\n+/* For libgcc2 we make sure this is a compile time constant */\n+#undef TARGET_POWERPC64\n+#ifdef __64BIT__\n+#define TARGET_POWERPC64\t1\n+#else\n+#define TARGET_POWERPC64\t0\n+#endif\n+#endif\n+\n /* Pseudo target to indicate whether the object format is ELF\n    (to get around not having conditional compilation in the md file)  */\n #ifndef\tTARGET_ELF"}, {"sha": "7cba424d1a7ec4057aa959d53e5cf3d3798d2790", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 283, "deletions": 191, "changes": 474, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ed075bdc3edbe0a20cdefa67e71b30a01ed31/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ed075bdc3edbe0a20cdefa67e71b30a01ed31/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=996ed075bdc3edbe0a20cdefa67e71b30a01ed31", "patch": "@@ -95,11 +95,22 @@ extern int atexit(void (*)(void));\n    because the sizes for those types can be configured to be anything.\n    Instead we use the following special type names.  */\n \n+typedef\t\t int QItype\t__attribute__ ((mode (QI)));\n typedef unsigned int UQItype\t__attribute__ ((mode (QI)));\n+typedef\t\t int HItype\t__attribute__ ((mode (HI)));\n+typedef unsigned int UHItype\t__attribute__ ((mode (HI)));\n+#if UNITS_PER_WORD > 1\n+/* These typedefs are usually forbidden on dsp's with UNITS_PER_WORD 1 */\n typedef \t int SItype\t__attribute__ ((mode (SI)));\n typedef unsigned int USItype\t__attribute__ ((mode (SI)));\n+#if UNITS_PER_WORD > 2\n+/* These typedefs are usually forbidden on archs with UNITS_PER_WORD 2 */\n typedef\t\t int DItype\t__attribute__ ((mode (DI)));\n typedef unsigned int UDItype\t__attribute__ ((mode (DI)));\n+#endif\n+#endif\n+\n+#if BITS_PER_UNIT == 8\n \n typedef \tfloat SFtype\t__attribute__ ((mode (SF)));\n typedef\t\tfloat DFtype\t__attribute__ ((mode (DF)));\n@@ -111,6 +122,29 @@ typedef\t\tfloat XFtype\t__attribute__ ((mode (XF)));\n typedef\t\tfloat TFtype\t__attribute__ ((mode (TF)));\n #endif\n \n+#else /* BITS_PER_UNIT != 8 */\n+\n+/* On dsp's there are usually qf/hf/tqf modes used instead of the above.\n+   For now we don't support them in libgcc2.c.  */\n+\n+#undef L_fixdfdi\n+#undef L_fixsfdi\n+#undef L_fixtfdi\n+#undef L_fixunsdfdi\n+#undef L_fixunsdfsi\n+#undef L_fixunssfdi\n+#undef L_fixunssfsi\n+#undef L_fixunstfdi\n+#undef L_fixunsxfdi\n+#undef L_fixunsxfsi\n+#undef L_fixxfdi\n+#undef L_floatdidf\n+#undef L_floatdisf\n+#undef L_floatditf\n+#undef L_floatdixf\n+\n+#endif /* BITS_PER_UNIT != 8 */\n+\n typedef int word_type __attribute__ ((mode (__word__)));\n \n /* Make sure that we don't accidentally use any normal C language built-in\n@@ -127,23 +161,75 @@ typedef int word_type __attribute__ ((mode (__word__)));\n #define float bogus_type\n #define double bogus_type\n \n-#if BITS_PER_UNIT == 8\n-#define SI_TYPE_SIZE 32\n-#else\n-#define SI_TYPE_SIZE (sizeof (SItype) * BITS_PER_UNIT)\n-#endif\n-#define W_TYPE_SIZE SI_TYPE_SIZE\n+#if UNITS_PER_WORD > 2\n+#define W_TYPE_SIZE (4 * BITS_PER_UNIT)\n+#define Wtype\tSItype\n #define UWtype\tUSItype\n+#define HWtype\tSItype\n #define UHWtype\tUSItype\n+#define DWtype\tDItype\n #define UDWtype\tUDItype\n+#define __NW(a,b)\t__ ## a ## si ## b\n+#define __NDW(a,b)\t__ ## a ## di ## b\n+#elif UNITS_PER_WORD > 1\n+#define W_TYPE_SIZE (2 * BITS_PER_UNIT)\n+#define Wtype\tHItype\n+#define UWtype\tUHItype\n+#define HWtype\tHItype\n+#define UHWtype\tUHItype\n+#define DWtype\tSItype\n+#define UDWtype\tUSItype\n+#define __NW(a,b)\t__ ## a ## hi ## b\n+#define __NDW(a,b)\t__ ## a ## si ## b\n+#else\n+#define W_TYPE_SIZE BITS_PER_UNIT\n+#define Wtype\tQItype\n+#define UWtype  UQItype\n+#define HWtype\tQItype\n+#define UHWtype\tUQItype\n+#define DWtype\tHItype\n+#define UDWtype\tUHItype\n+#define __NW(a,b)\t__ ## a ## qi ## b\n+#define __NDW(a,b)\t__ ## a ## hi ## b\n+#endif\n \n-/* DIstructs are pairs of SItype values in the order determined by\n+#define __muldi3\t__NDW(mul,3)\n+#define __divdi3\t__NDW(div,3)\n+#define __udivdi3\t__NDW(udiv,3)\n+#define __moddi3\t__NDW(mod,3)\n+#define __umoddi3\t__NDW(umod,3)\n+#define __negdi2\t__NDW(neg,2)\n+#define __lshrdi3\t__NDW(lshr,3)\n+#define __ashldi3\t__NDW(ashl,3)\n+#define __ashrdi3\t__NDW(ashr,3)\n+#define __ffsdi2\t__NDW(ffs,2)\n+#define __cmpdi2\t__NDW(cmp,2)\n+#define __ucmpdi2\t__NDW(ucmp,2)\n+#define __udivmoddi4\t__NDW(udivmod,4)\n+#define __fixunstfdi\t__NDW(fixunstf,)\n+#define __fixtfdi\t__NDW(fixtf,)\n+#define __fixunsxfdi\t__NDW(fixunsxf,)\n+#define __fixxfdi\t__NDW(fixxf,)\n+#define __fixunsdfdi\t__NDW(fixunsdf,)\n+#define __fixdfdi\t__NDW(fixdf,)\n+#define __fixunssfdi\t__NDW(fixunssf,)\n+#define __fixsfdi\t__NDW(fixsf,)\n+#define __floatdixf\t__NDW(float,xf)\n+#define __floatditf\t__NDW(float,tf)\n+#define __floatdidf\t__NDW(float,df)\n+#define __floatdisf\t__NDW(float,sf)\n+#define __fixunsxfsi\t__NW(fixunsxf,)\n+#define __fixunstfsi\t__NW(fixunstf,)\n+#define __fixunsdfsi\t__NW(fixunsdf,)\n+#define __fixunssfsi\t__NW(fixunssf,)\n+\n+/* DWstructs are pairs of Wtype values in the order determined by\n    LIBGCC2_WORDS_BIG_ENDIAN.  */\n \n #if LIBGCC2_WORDS_BIG_ENDIAN\n-  struct DIstruct {SItype high, low;};\n+  struct DWstruct {Wtype high, low;};\n #else\n-  struct DIstruct {SItype low, high;};\n+  struct DWstruct {Wtype low, high;};\n #endif\n \n /* We need this union to unpack/pack DImode values, since we don't have\n@@ -152,9 +238,9 @@ typedef int word_type __attribute__ ((mode (__word__)));\n \n typedef union\n {\n-  struct DIstruct s;\n-  DItype ll;\n-} DIunion;\n+  struct DWstruct s;\n+  DWtype ll;\n+} DWunion;\n \n #if (defined (L_udivmoddi4) || defined (L_muldi3) || defined (L_udiv_w_sdiv)\\\n      || defined (L_divdi3) || defined (L_udivdi3) \\\n@@ -164,29 +250,21 @@ typedef union\n \n #endif /* udiv or mul */\n \n-extern DItype __fixunssfdi (SFtype a);\n-extern DItype __fixunsdfdi (DFtype a);\n-#if LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 96\n-extern DItype __fixunsxfdi (XFtype a);\n-#endif\n-#if LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 128\n-extern DItype __fixunstfdi (TFtype a);\n-#endif\n \f\n #if defined (L_negdi2) || defined (L_divdi3) || defined (L_moddi3)\n #if defined (L_divdi3) || defined (L_moddi3)\n static inline\n #endif\n-DItype\n-__negdi2 (DItype u)\n+DWtype\n+__negdi2 (DWtype u)\n {\n-  DIunion w;\n-  DIunion uu;\n+  DWunion w;\n+  DWunion uu;\n \n   uu.ll = u;\n \n   w.s.low = -uu.s.low;\n-  w.s.high = -uu.s.high - ((USItype) w.s.low > 0);\n+  w.s.high = -uu.s.high - ((UWtype) w.s.low > 0);\n \n   return w.ll;\n }\n@@ -195,101 +273,101 @@ __negdi2 (DItype u)\n /* Unless shift functions are defined whith full ANSI prototypes,\n    parameter b will be promoted to int if word_type is smaller than an int.  */\n #ifdef L_lshrdi3\n-DItype\n-__lshrdi3 (DItype u, word_type b)\n+DWtype\n+__lshrdi3 (DWtype u, word_type b)\n {\n-  DIunion w;\n+  DWunion w;\n   word_type bm;\n-  DIunion uu;\n+  DWunion uu;\n \n   if (b == 0)\n     return u;\n \n   uu.ll = u;\n \n-  bm = (sizeof (SItype) * BITS_PER_UNIT) - b;\n+  bm = (sizeof (Wtype) * BITS_PER_UNIT) - b;\n   if (bm <= 0)\n     {\n       w.s.high = 0;\n-      w.s.low = (USItype)uu.s.high >> -bm;\n+      w.s.low = (UWtype)uu.s.high >> -bm;\n     }\n   else\n     {\n-      USItype carries = (USItype)uu.s.high << bm;\n-      w.s.high = (USItype)uu.s.high >> b;\n-      w.s.low = ((USItype)uu.s.low >> b) | carries;\n+      UWtype carries = (UWtype)uu.s.high << bm;\n+      w.s.high = (UWtype)uu.s.high >> b;\n+      w.s.low = ((UWtype)uu.s.low >> b) | carries;\n     }\n \n   return w.ll;\n }\n #endif\n \n #ifdef L_ashldi3\n-DItype\n-__ashldi3 (DItype u, word_type b)\n+DWtype\n+__ashldi3 (DWtype u, word_type b)\n {\n-  DIunion w;\n+  DWunion w;\n   word_type bm;\n-  DIunion uu;\n+  DWunion uu;\n \n   if (b == 0)\n     return u;\n \n   uu.ll = u;\n \n-  bm = (sizeof (SItype) * BITS_PER_UNIT) - b;\n+  bm = (sizeof (Wtype) * BITS_PER_UNIT) - b;\n   if (bm <= 0)\n     {\n       w.s.low = 0;\n-      w.s.high = (USItype)uu.s.low << -bm;\n+      w.s.high = (UWtype)uu.s.low << -bm;\n     }\n   else\n     {\n-      USItype carries = (USItype)uu.s.low >> bm;\n-      w.s.low = (USItype)uu.s.low << b;\n-      w.s.high = ((USItype)uu.s.high << b) | carries;\n+      UWtype carries = (UWtype)uu.s.low >> bm;\n+      w.s.low = (UWtype)uu.s.low << b;\n+      w.s.high = ((UWtype)uu.s.high << b) | carries;\n     }\n \n   return w.ll;\n }\n #endif\n \n #ifdef L_ashrdi3\n-DItype\n-__ashrdi3 (DItype u, word_type b)\n+DWtype\n+__ashrdi3 (DWtype u, word_type b)\n {\n-  DIunion w;\n+  DWunion w;\n   word_type bm;\n-  DIunion uu;\n+  DWunion uu;\n \n   if (b == 0)\n     return u;\n \n   uu.ll = u;\n \n-  bm = (sizeof (SItype) * BITS_PER_UNIT) - b;\n+  bm = (sizeof (Wtype) * BITS_PER_UNIT) - b;\n   if (bm <= 0)\n     {\n       /* w.s.high = 1..1 or 0..0 */\n-      w.s.high = uu.s.high >> (sizeof (SItype) * BITS_PER_UNIT - 1);\n+      w.s.high = uu.s.high >> (sizeof (Wtype) * BITS_PER_UNIT - 1);\n       w.s.low = uu.s.high >> -bm;\n     }\n   else\n     {\n-      USItype carries = (USItype)uu.s.high << bm;\n+      UWtype carries = (UWtype)uu.s.high << bm;\n       w.s.high = uu.s.high >> b;\n-      w.s.low = ((USItype)uu.s.low >> b) | carries;\n+      w.s.low = ((UWtype)uu.s.low >> b) | carries;\n     }\n \n   return w.ll;\n }\n #endif\n \f\n #ifdef L_ffsdi2\n-DItype\n-__ffsdi2 (DItype u)\n+DWtype\n+__ffsdi2 (DWtype u)\n {\n-  DIunion uu, w;\n+  DWunion uu, w;\n   uu.ll = u;\n   w.s.high = 0;\n   w.s.low = ffs (uu.s.low);\n@@ -298,61 +376,61 @@ __ffsdi2 (DItype u)\n   w.s.low = ffs (uu.s.high);\n   if (w.s.low != 0)\n     {\n-      w.s.low += BITS_PER_UNIT * sizeof (SItype);\n+      w.s.low += BITS_PER_UNIT * sizeof (Wtype);\n       return w.ll;\n     }\n   return w.ll;\n }\n #endif\n \f\n #ifdef L_muldi3\n-DItype\n-__muldi3 (DItype u, DItype v)\n+DWtype\n+__muldi3 (DWtype u, DWtype v)\n {\n-  DIunion w;\n-  DIunion uu, vv;\n+  DWunion w;\n+  DWunion uu, vv;\n \n   uu.ll = u,\n   vv.ll = v;\n \n   w.ll = __umulsidi3 (uu.s.low, vv.s.low);\n-  w.s.high += ((USItype) uu.s.low * (USItype) vv.s.high\n-\t       + (USItype) uu.s.high * (USItype) vv.s.low);\n+  w.s.high += ((UWtype) uu.s.low * (UWtype) vv.s.high\n+\t       + (UWtype) uu.s.high * (UWtype) vv.s.low);\n \n   return w.ll;\n }\n #endif\n \f\n #ifdef L_udiv_w_sdiv\n #if defined (sdiv_qrnnd)\n-USItype\n-__udiv_w_sdiv (USItype *rp, USItype a1, USItype a0, USItype d)\n+UWtype\n+__udiv_w_sdiv (UWtype *rp, UWtype a1, UWtype a0, UWtype d)\n {\n-  USItype q, r;\n-  USItype c0, c1, b1;\n+  UWtype q, r;\n+  UWtype c0, c1, b1;\n \n-  if ((SItype) d >= 0)\n+  if ((Wtype) d >= 0)\n     {\n-      if (a1 < d - a1 - (a0 >> (SI_TYPE_SIZE - 1)))\n+      if (a1 < d - a1 - (a0 >> (W_TYPE_SIZE - 1)))\n \t{\n \t  /* dividend, divisor, and quotient are nonnegative */\n \t  sdiv_qrnnd (q, r, a1, a0, d);\n \t}\n       else\n \t{\n \t  /* Compute c1*2^32 + c0 = a1*2^32 + a0 - 2^31*d */\n-\t  sub_ddmmss (c1, c0, a1, a0, d >> 1, d << (SI_TYPE_SIZE - 1));\n+\t  sub_ddmmss (c1, c0, a1, a0, d >> 1, d << (W_TYPE_SIZE - 1));\n \t  /* Divide (c1*2^32 + c0) by d */\n \t  sdiv_qrnnd (q, r, c1, c0, d);\n \t  /* Add 2^31 to quotient */\n-\t  q += (USItype) 1 << (SI_TYPE_SIZE - 1);\n+\t  q += (UWtype) 1 << (W_TYPE_SIZE - 1);\n \t}\n     }\n   else\n     {\n       b1 = d >> 1;\t\t\t/* d/2, between 2^30 and 2^31 - 1 */\n       c1 = a1 >> 1;\t\t\t/* A/2 */\n-      c0 = (a1 << (SI_TYPE_SIZE - 1)) + (a0 >> 1);\n+      c0 = (a1 << (W_TYPE_SIZE - 1)) + (a0 >> 1);\n \n       if (a1 < b1)\t\t\t/* A < 2^32*b1, so A/2 < 2^31*b1 */\n \t{\n@@ -423,11 +501,11 @@ __udiv_w_sdiv (USItype *rp, USItype a1, USItype a0, USItype d)\n }\n #else\n /* If sdiv_qrnnd doesn't exist, define dummy __udiv_w_sdiv.  */\n-USItype\n-__udiv_w_sdiv (USItype *rp __attribute__ ((__unused__)),\n-\t       USItype a1 __attribute__ ((__unused__)),\n-\t       USItype a0 __attribute__ ((__unused__)),\n-\t       USItype d __attribute__ ((__unused__)))\n+UWtype\n+__udiv_w_sdiv (UWtype *rp __attribute__ ((__unused__)),\n+\t       UWtype a1 __attribute__ ((__unused__)),\n+\t       UWtype a0 __attribute__ ((__unused__)),\n+\t       UWtype d __attribute__ ((__unused__)))\n {\n   return 0;\n }\n@@ -456,15 +534,15 @@ static const UQItype __clz_tab[] =\n      defined (L_umoddi3) || defined (L_moddi3))\n static inline\n #endif\n-UDItype\n-__udivmoddi4 (UDItype n, UDItype d, UDItype *rp)\n+UDWtype\n+__udivmoddi4 (UDWtype n, UDWtype d, UDWtype *rp)\n {\n-  DIunion ww;\n-  DIunion nn, dd;\n-  DIunion rr;\n-  USItype d0, d1, n0, n1, n2;\n-  USItype q0, q1;\n-  USItype b, bm;\n+  DWunion ww;\n+  DWunion nn, dd;\n+  DWunion rr;\n+  UWtype d0, d1, n0, n1, n2;\n+  UWtype q0, q1;\n+  UWtype b, bm;\n \n   nn.ll = n;\n   dd.ll = d;\n@@ -523,7 +601,7 @@ __udivmoddi4 (UDItype n, UDItype d, UDItype *rp)\n \t\t denominator set.  */\n \n \t      d0 = d0 << bm;\n-\t      n1 = (n1 << bm) | (n0 >> (SI_TYPE_SIZE - bm));\n+\t      n1 = (n1 << bm) | (n0 >> (W_TYPE_SIZE - bm));\n \t      n0 = n0 << bm;\n \t    }\n \n@@ -548,7 +626,7 @@ __udivmoddi4 (UDItype n, UDItype d, UDItype *rp)\n \t\t leading quotient digit q1 = 1).\n \n \t\t This special case is necessary, not an optimization.\n-\t\t (Shifts counts of SI_TYPE_SIZE are undefined.)  */\n+\t\t (Shifts counts of W_TYPE_SIZE are undefined.)  */\n \n \t      n1 -= d0;\n \t      q1 = 1;\n@@ -557,7 +635,7 @@ __udivmoddi4 (UDItype n, UDItype d, UDItype *rp)\n \t    {\n \t      /* Normalize.  */\n \n-\t      b = SI_TYPE_SIZE - bm;\n+\t      b = W_TYPE_SIZE - bm;\n \n \t      d0 = d0 << bm;\n \t      n2 = n1 >> b;\n@@ -634,10 +712,10 @@ __udivmoddi4 (UDItype n, UDItype d, UDItype *rp)\n \t    }\n \t  else\n \t    {\n-\t      USItype m1, m0;\n+\t      UWtype m1, m0;\n \t      /* Normalize.  */\n \n-\t      b = SI_TYPE_SIZE - bm;\n+\t      b = W_TYPE_SIZE - bm;\n \n \t      d1 = (d1 << bm) | (d0 >> b);\n \t      d0 = d0 << bm;\n@@ -675,12 +753,12 @@ __udivmoddi4 (UDItype n, UDItype d, UDItype *rp)\n #endif\n \n #ifdef L_divdi3\n-DItype\n-__divdi3 (DItype u, DItype v)\n+DWtype\n+__divdi3 (DWtype u, DWtype v)\n {\n   word_type c = 0;\n-  DIunion uu, vv;\n-  DItype w;\n+  DWunion uu, vv;\n+  DWtype w;\n \n   uu.ll = u;\n   vv.ll = v;\n@@ -692,7 +770,7 @@ __divdi3 (DItype u, DItype v)\n     c = ~c,\n     vv.ll = __negdi2 (vv.ll);\n \n-  w = __udivmoddi4 (uu.ll, vv.ll, (UDItype *) 0);\n+  w = __udivmoddi4 (uu.ll, vv.ll, (UDWtype *) 0);\n   if (c)\n     w = __negdi2 (w);\n \n@@ -701,12 +779,12 @@ __divdi3 (DItype u, DItype v)\n #endif\n \n #ifdef L_moddi3\n-DItype\n-__moddi3 (DItype u, DItype v)\n+DWtype\n+__moddi3 (DWtype u, DWtype v)\n {\n   word_type c = 0;\n-  DIunion uu, vv;\n-  DItype w;\n+  DWunion uu, vv;\n+  DWtype w;\n \n   uu.ll = u;\n   vv.ll = v;\n@@ -726,10 +804,10 @@ __moddi3 (DItype u, DItype v)\n #endif\n \n #ifdef L_umoddi3\n-UDItype\n-__umoddi3 (UDItype u, UDItype v)\n+UDWtype\n+__umoddi3 (UDWtype u, UDWtype v)\n {\n-  UDItype w;\n+  UDWtype w;\n \n   (void) __udivmoddi4 (u, v, &w);\n \n@@ -738,87 +816,89 @@ __umoddi3 (UDItype u, UDItype v)\n #endif\n \n #ifdef L_udivdi3\n-UDItype\n-__udivdi3 (UDItype n, UDItype d)\n+UDWtype\n+__udivdi3 (UDWtype n, UDWtype d)\n {\n-  return __udivmoddi4 (n, d, (UDItype *) 0);\n+  return __udivmoddi4 (n, d, (UDWtype *) 0);\n }\n #endif\n \f\n #ifdef L_cmpdi2\n word_type\n-__cmpdi2 (DItype a, DItype b)\n+__cmpdi2 (DWtype a, DWtype b)\n {\n-  DIunion au, bu;\n+  DWunion au, bu;\n \n   au.ll = a, bu.ll = b;\n \n   if (au.s.high < bu.s.high)\n     return 0;\n   else if (au.s.high > bu.s.high)\n     return 2;\n-  if ((USItype) au.s.low < (USItype) bu.s.low)\n+  if ((UWtype) au.s.low < (UWtype) bu.s.low)\n     return 0;\n-  else if ((USItype) au.s.low > (USItype) bu.s.low)\n+  else if ((UWtype) au.s.low > (UWtype) bu.s.low)\n     return 2;\n   return 1;\n }\n #endif\n \n #ifdef L_ucmpdi2\n word_type\n-__ucmpdi2 (DItype a, DItype b)\n+__ucmpdi2 (DWtype a, DWtype b)\n {\n-  DIunion au, bu;\n+  DWunion au, bu;\n \n   au.ll = a, bu.ll = b;\n \n-  if ((USItype) au.s.high < (USItype) bu.s.high)\n+  if ((UWtype) au.s.high < (UWtype) bu.s.high)\n     return 0;\n-  else if ((USItype) au.s.high > (USItype) bu.s.high)\n+  else if ((UWtype) au.s.high > (UWtype) bu.s.high)\n     return 2;\n-  if ((USItype) au.s.low < (USItype) bu.s.low)\n+  if ((UWtype) au.s.low < (UWtype) bu.s.low)\n     return 0;\n-  else if ((USItype) au.s.low > (USItype) bu.s.low)\n+  else if ((UWtype) au.s.low > (UWtype) bu.s.low)\n     return 2;\n   return 1;\n }\n #endif\n \f\n #if defined(L_fixunstfdi) && (LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 128)\n-#define WORD_SIZE (sizeof (SItype) * BITS_PER_UNIT)\n-#define HIGH_WORD_COEFF (((UDItype) 1) << WORD_SIZE)\n+#define WORD_SIZE (sizeof (Wtype) * BITS_PER_UNIT)\n+#define HIGH_WORD_COEFF (((UDWtype) 1) << WORD_SIZE)\n \n-DItype\n+DWtype\n __fixunstfdi (TFtype a)\n {\n   TFtype b;\n-  UDItype v;\n+  UDWtype v;\n \n   if (a < 0)\n     return 0;\n \n   /* Compute high word of result, as a flonum.  */\n   b = (a / HIGH_WORD_COEFF);\n-  /* Convert that to fixed (but not to DItype!),\n+  /* Convert that to fixed (but not to DWtype!),\n      and shift it into the high word.  */\n-  v = (USItype) b;\n+  v = (UWtype) b;\n   v <<= WORD_SIZE;\n   /* Remove high part from the TFtype, leaving the low part as flonum.  */\n   a -= (TFtype)v;\n-  /* Convert that to fixed (but not to DItype!) and add it in.\n+  /* Convert that to fixed (but not to DWtype!) and add it in.\n      Sometimes A comes out negative.  This is significant, since\n      A has more bits than a long int does.  */\n   if (a < 0)\n-    v -= (USItype) (- a);\n+    v -= (UWtype) (- a);\n   else\n-    v += (USItype) a;\n+    v += (UWtype) a;\n   return v;\n }\n #endif\n \n #if defined(L_fixtfdi) && (LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 128)\n-DItype\n+extern DWtype __fixunstfdi (TFtype a);\n+\n+DWtype\n __fixtfdi (TFtype a)\n {\n   if (a < 0)\n@@ -828,39 +908,41 @@ __fixtfdi (TFtype a)\n #endif\n \n #if defined(L_fixunsxfdi) && (LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 96)\n-#define WORD_SIZE (sizeof (SItype) * BITS_PER_UNIT)\n-#define HIGH_WORD_COEFF (((UDItype) 1) << WORD_SIZE)\n+#define WORD_SIZE (sizeof (Wtype) * BITS_PER_UNIT)\n+#define HIGH_WORD_COEFF (((UDWtype) 1) << WORD_SIZE)\n \n-DItype\n+DWtype\n __fixunsxfdi (XFtype a)\n {\n   XFtype b;\n-  UDItype v;\n+  UDWtype v;\n \n   if (a < 0)\n     return 0;\n \n   /* Compute high word of result, as a flonum.  */\n   b = (a / HIGH_WORD_COEFF);\n-  /* Convert that to fixed (but not to DItype!),\n+  /* Convert that to fixed (but not to DWtype!),\n      and shift it into the high word.  */\n-  v = (USItype) b;\n+  v = (UWtype) b;\n   v <<= WORD_SIZE;\n   /* Remove high part from the XFtype, leaving the low part as flonum.  */\n   a -= (XFtype)v;\n-  /* Convert that to fixed (but not to DItype!) and add it in.\n+  /* Convert that to fixed (but not to DWtype!) and add it in.\n      Sometimes A comes out negative.  This is significant, since\n      A has more bits than a long int does.  */\n   if (a < 0)\n-    v -= (USItype) (- a);\n+    v -= (UWtype) (- a);\n   else\n-    v += (USItype) a;\n+    v += (UWtype) a;\n   return v;\n }\n #endif\n \n #if defined(L_fixxfdi) && (LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 96)\n-DItype\n+extern DWtype __fixunsxfdi (XFtype a);\n+\n+DWtype\n __fixxfdi (XFtype a)\n {\n   if (a < 0)\n@@ -870,39 +952,41 @@ __fixxfdi (XFtype a)\n #endif\n \n #ifdef L_fixunsdfdi\n-#define WORD_SIZE (sizeof (SItype) * BITS_PER_UNIT)\n-#define HIGH_WORD_COEFF (((UDItype) 1) << WORD_SIZE)\n+#define WORD_SIZE (sizeof (Wtype) * BITS_PER_UNIT)\n+#define HIGH_WORD_COEFF (((UDWtype) 1) << WORD_SIZE)\n \n-DItype\n+DWtype\n __fixunsdfdi (DFtype a)\n {\n   DFtype b;\n-  UDItype v;\n+  UDWtype v;\n \n   if (a < 0)\n     return 0;\n \n   /* Compute high word of result, as a flonum.  */\n   b = (a / HIGH_WORD_COEFF);\n-  /* Convert that to fixed (but not to DItype!),\n+  /* Convert that to fixed (but not to DWtype!),\n      and shift it into the high word.  */\n-  v = (USItype) b;\n+  v = (UWtype) b;\n   v <<= WORD_SIZE;\n   /* Remove high part from the DFtype, leaving the low part as flonum.  */\n   a -= (DFtype)v;\n-  /* Convert that to fixed (but not to DItype!) and add it in.\n+  /* Convert that to fixed (but not to DWtype!) and add it in.\n      Sometimes A comes out negative.  This is significant, since\n      A has more bits than a long int does.  */\n   if (a < 0)\n-    v -= (USItype) (- a);\n+    v -= (UWtype) (- a);\n   else\n-    v += (USItype) a;\n+    v += (UWtype) a;\n   return v;\n }\n #endif\n \n #ifdef L_fixdfdi\n-DItype\n+extern DWtype __fixunsdfdi (DFtype a);\n+\n+DWtype\n __fixdfdi (DFtype a)\n {\n   if (a < 0)\n@@ -912,43 +996,45 @@ __fixdfdi (DFtype a)\n #endif\n \n #ifdef L_fixunssfdi\n-#define WORD_SIZE (sizeof (SItype) * BITS_PER_UNIT)\n-#define HIGH_WORD_COEFF (((UDItype) 1) << WORD_SIZE)\n+#define WORD_SIZE (sizeof (Wtype) * BITS_PER_UNIT)\n+#define HIGH_WORD_COEFF (((UDWtype) 1) << WORD_SIZE)\n \n-DItype\n+DWtype\n __fixunssfdi (SFtype original_a)\n {\n   /* Convert the SFtype to a DFtype, because that is surely not going\n      to lose any bits.  Some day someone else can write a faster version\n      that avoids converting to DFtype, and verify it really works right.  */\n   DFtype a = original_a;\n   DFtype b;\n-  UDItype v;\n+  UDWtype v;\n \n   if (a < 0)\n     return 0;\n \n   /* Compute high word of result, as a flonum.  */\n   b = (a / HIGH_WORD_COEFF);\n-  /* Convert that to fixed (but not to DItype!),\n+  /* Convert that to fixed (but not to DWtype!),\n      and shift it into the high word.  */\n-  v = (USItype) b;\n+  v = (UWtype) b;\n   v <<= WORD_SIZE;\n   /* Remove high part from the DFtype, leaving the low part as flonum.  */\n   a -= (DFtype)v;\n-  /* Convert that to fixed (but not to DItype!) and add it in.\n+  /* Convert that to fixed (but not to DWtype!) and add it in.\n      Sometimes A comes out negative.  This is significant, since\n      A has more bits than a long int does.  */\n   if (a < 0)\n-    v -= (USItype) (- a);\n+    v -= (UWtype) (- a);\n   else\n-    v += (USItype) a;\n+    v += (UWtype) a;\n   return v;\n }\n #endif\n \n #ifdef L_fixsfdi\n-DItype\n+extern DWtype __fixunssfdi (SFtype a);\n+\n+DWtype\n __fixsfdi (SFtype a)\n {\n   if (a < 0)\n@@ -958,67 +1044,67 @@ __fixsfdi (SFtype a)\n #endif\n \n #if defined(L_floatdixf) && (LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 96)\n-#define WORD_SIZE (sizeof (SItype) * BITS_PER_UNIT)\n-#define HIGH_HALFWORD_COEFF (((UDItype) 1) << (WORD_SIZE / 2))\n-#define HIGH_WORD_COEFF (((UDItype) 1) << WORD_SIZE)\n+#define WORD_SIZE (sizeof (Wtype) * BITS_PER_UNIT)\n+#define HIGH_HALFWORD_COEFF (((UDWtype) 1) << (WORD_SIZE / 2))\n+#define HIGH_WORD_COEFF (((UDWtype) 1) << WORD_SIZE)\n \n XFtype\n-__floatdixf (DItype u)\n+__floatdixf (DWtype u)\n {\n   XFtype d;\n \n-  d = (SItype) (u >> WORD_SIZE);\n+  d = (Wtype) (u >> WORD_SIZE);\n   d *= HIGH_HALFWORD_COEFF;\n   d *= HIGH_HALFWORD_COEFF;\n-  d += (USItype) (u & (HIGH_WORD_COEFF - 1));\n+  d += (UWtype) (u & (HIGH_WORD_COEFF - 1));\n \n   return d;\n }\n #endif\n \n #if defined(L_floatditf) && (LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 128)\n-#define WORD_SIZE (sizeof (SItype) * BITS_PER_UNIT)\n-#define HIGH_HALFWORD_COEFF (((UDItype) 1) << (WORD_SIZE / 2))\n-#define HIGH_WORD_COEFF (((UDItype) 1) << WORD_SIZE)\n+#define WORD_SIZE (sizeof (Wtype) * BITS_PER_UNIT)\n+#define HIGH_HALFWORD_COEFF (((UDWtype) 1) << (WORD_SIZE / 2))\n+#define HIGH_WORD_COEFF (((UDWtype) 1) << WORD_SIZE)\n \n TFtype\n-__floatditf (DItype u)\n+__floatditf (DWtype u)\n {\n   TFtype d;\n \n-  d = (SItype) (u >> WORD_SIZE);\n+  d = (Wtype) (u >> WORD_SIZE);\n   d *= HIGH_HALFWORD_COEFF;\n   d *= HIGH_HALFWORD_COEFF;\n-  d += (USItype) (u & (HIGH_WORD_COEFF - 1));\n+  d += (UWtype) (u & (HIGH_WORD_COEFF - 1));\n \n   return d;\n }\n #endif\n \n #ifdef L_floatdidf\n-#define WORD_SIZE (sizeof (SItype) * BITS_PER_UNIT)\n-#define HIGH_HALFWORD_COEFF (((UDItype) 1) << (WORD_SIZE / 2))\n-#define HIGH_WORD_COEFF (((UDItype) 1) << WORD_SIZE)\n+#define WORD_SIZE (sizeof (Wtype) * BITS_PER_UNIT)\n+#define HIGH_HALFWORD_COEFF (((UDWtype) 1) << (WORD_SIZE / 2))\n+#define HIGH_WORD_COEFF (((UDWtype) 1) << WORD_SIZE)\n \n DFtype\n-__floatdidf (DItype u)\n+__floatdidf (DWtype u)\n {\n   DFtype d;\n \n-  d = (SItype) (u >> WORD_SIZE);\n+  d = (Wtype) (u >> WORD_SIZE);\n   d *= HIGH_HALFWORD_COEFF;\n   d *= HIGH_HALFWORD_COEFF;\n-  d += (USItype) (u & (HIGH_WORD_COEFF - 1));\n+  d += (UWtype) (u & (HIGH_WORD_COEFF - 1));\n \n   return d;\n }\n #endif\n \n #ifdef L_floatdisf\n-#define WORD_SIZE (sizeof (SItype) * BITS_PER_UNIT)\n-#define HIGH_HALFWORD_COEFF (((UDItype) 1) << (WORD_SIZE / 2))\n-#define HIGH_WORD_COEFF (((UDItype) 1) << WORD_SIZE)\n-#define DI_SIZE (sizeof (DItype) * BITS_PER_UNIT)\n+#define WORD_SIZE (sizeof (Wtype) * BITS_PER_UNIT)\n+#define HIGH_HALFWORD_COEFF (((UDWtype) 1) << (WORD_SIZE / 2))\n+#define HIGH_WORD_COEFF (((UDWtype) 1) << WORD_SIZE)\n+#define DI_SIZE (sizeof (DWtype) * BITS_PER_UNIT)\n \n /* Define codes for all the float formats that we know of.  Note\n    that this is copied from real.h.  */\n@@ -1049,7 +1135,7 @@ __floatdidf (DItype u)\n #endif\n \n SFtype\n-__floatdisf (DItype u)\n+__floatdisf (DWtype u)\n {\n   /* Do the calculation in DFmode\n      so that we don't lose any of the precision of the high word\n@@ -1065,18 +1151,18 @@ __floatdisf (DItype u)\n   if (DF_SIZE < DI_SIZE\n       && DF_SIZE > (DI_SIZE - DF_SIZE + SF_SIZE))\n     {\n-#define REP_BIT ((USItype) 1 << (DI_SIZE - DF_SIZE))\n-      if (! (- ((DItype) 1 << DF_SIZE) < u\n-\t     && u < ((DItype) 1 << DF_SIZE)))\n+#define REP_BIT ((UWtype) 1 << (DI_SIZE - DF_SIZE))\n+      if (! (- ((DWtype) 1 << DF_SIZE) < u\n+\t     && u < ((DWtype) 1 << DF_SIZE)))\n \t{\n-\t  if ((USItype) u & (REP_BIT - 1))\n+\t  if ((UWtype) u & (REP_BIT - 1))\n \t    u |= REP_BIT;\n \t}\n     }\n-  f = (SItype) (u >> WORD_SIZE);\n+  f = (Wtype) (u >> WORD_SIZE);\n   f *= HIGH_HALFWORD_COEFF;\n   f *= HIGH_HALFWORD_COEFF;\n-  f += (USItype) (u & (HIGH_WORD_COEFF - 1));\n+  f += (UWtype) (u & (HIGH_WORD_COEFF - 1));\n \n   return (SFtype) f;\n }\n@@ -1095,12 +1181,12 @@ __floatdisf (DItype u)\n #undef MAX\n #include <limits.h>\n \n-USItype\n+UWtype\n __fixunsxfsi (XFtype a)\n {\n   if (a >= - (DFtype) LONG_MIN)\n-    return (SItype) (a + LONG_MIN) - LONG_MIN;\n-  return (SItype) a;\n+    return (Wtype) (a + LONG_MIN) - LONG_MIN;\n+  return (Wtype) a;\n }\n #endif\n \n@@ -1117,12 +1203,12 @@ __fixunsxfsi (XFtype a)\n #undef MAX\n #include <limits.h>\n \n-USItype\n+UWtype\n __fixunsdfsi (DFtype a)\n {\n   if (a >= - (DFtype) LONG_MIN)\n-    return (SItype) (a + LONG_MIN) - LONG_MIN;\n-  return (SItype) a;\n+    return (Wtype) (a + LONG_MIN) - LONG_MIN;\n+  return (Wtype) a;\n }\n #endif\n \n@@ -1139,12 +1225,12 @@ __fixunsdfsi (DFtype a)\n #undef MAX\n #include <limits.h>\n \n-USItype\n+UWtype\n __fixunssfsi (SFtype a)\n {\n   if (a >= - (SFtype) LONG_MIN)\n-    return (SItype) (a + LONG_MIN) - LONG_MIN;\n-  return (SItype) a;\n+    return (Wtype) (a + LONG_MIN) - LONG_MIN;\n+  return (Wtype) a;\n }\n #endif\n \f\n@@ -1156,6 +1242,12 @@ __fixunssfsi (SFtype a)\n #define UDItype bogus_type\n #define SFtype bogus_type\n #define DFtype bogus_type\n+#undef Wtype\n+#undef UWtype\n+#undef HWtype\n+#undef UHWtype\n+#undef DWtype\n+#undef UDWtype\n \n #undef char\n #undef short"}, {"sha": "539174ad910cd20273b572d8d882d2bc4669879b", "filename": "gcc/longlong.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/996ed075bdc3edbe0a20cdefa67e71b30a01ed31/gcc%2Flonglong.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/996ed075bdc3edbe0a20cdefa67e71b30a01ed31/gcc%2Flonglong.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flonglong.h?ref=996ed075bdc3edbe0a20cdefa67e71b30a01ed31", "patch": "@@ -195,7 +195,7 @@ extern UDItype __udiv_qrnnd __P ((UDItype *, UDItype, UDItype, UDItype));\n /* Call libgcc1 routine.  */\n #define umul_ppmm(w1, w0, u, v) \\\n do {\t\t\t\t\t\t\t\t\t\\\n-  DIunion __w;\t\t\t\t\t\t\t\t\\\n+  DWunion __w;\t\t\t\t\t\t\t\t\\\n   __w.ll = __umulsidi3 (u, v);\t\t\t\t\t\t\\\n   w1 = __w.s.high;\t\t\t\t\t\t\t\\\n   w0 = __w.s.low;\t\t\t\t\t\t\t\\\n@@ -1383,7 +1383,7 @@ UDItype __umulsidi3 (USItype, USItype);\n \n #if !defined (__umulsidi3)\n #define __umulsidi3(u, v) \\\n-  ({DIunion __w;\t\t\t\t\t\t\t\\\n+  ({DWunion __w;\t\t\t\t\t\t\t\\\n     umul_ppmm (__w.s.high, __w.s.low, u, v);\t\t\t\t\\\n     __w.ll; })\n #endif"}]}