{"sha": "d62294f57e859308c23fcbd156bb88b21e8f4547", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDYyMjk0ZjU3ZTg1OTMwOGMyM2ZjYmQxNTZiYjg4YjIxZThmNDU0Nw==", "commit": {"author": {"name": "Fariborz Jahanian", "email": "fjahanian@apple.com", "date": "2004-08-18T16:33:10Z"}, "committer": {"name": "Fariborz Jahanian", "email": "fjahanian@gcc.gnu.org", "date": "2004-08-18T16:33:10Z"}, "message": "save_world/rest_world for ppc-darwin.\n\nApproved by Geoff Keating.\n\nFrom-SVN: r86191", "tree": {"sha": "e13da96e33e66d0dea4fc8d0f78c6229bda50900", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e13da96e33e66d0dea4fc8d0f78c6229bda50900"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d62294f57e859308c23fcbd156bb88b21e8f4547", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d62294f57e859308c23fcbd156bb88b21e8f4547", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d62294f57e859308c23fcbd156bb88b21e8f4547", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d62294f57e859308c23fcbd156bb88b21e8f4547/comments", "author": null, "committer": null, "parents": [{"sha": "790ac0e12ab9a3d704f89d3480af437c550badc6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/790ac0e12ab9a3d704f89d3480af437c550badc6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/790ac0e12ab9a3d704f89d3480af437c550badc6"}], "stats": {"total": 488, "additions": 476, "deletions": 12}, "files": [{"sha": "9e38a2a7844207fdb1dc9d88b61975470d5b80d1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d62294f57e859308c23fcbd156bb88b21e8f4547/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d62294f57e859308c23fcbd156bb88b21e8f4547/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d62294f57e859308c23fcbd156bb88b21e8f4547", "patch": "@@ -1,3 +1,29 @@\n+2004-08-18  Fariborz Jahanian <fjahanian@apple.com>\n+\n+        * config/rs6000/altivec.md: Add new patterns for calls to\n+        save_world/rest_world functions.\n+\n+        * config/rs6000/rs6000-protos.h: (save_world_operation,\n+        restore_world_operation) new declarations.\n+\n+        * config/rs6000/rs6000.c: (struct rs6000_stack) new world_save_p\n+        field added.\n+        (rs6000_stack_info): Set world_save_p field.\n+        (save_world_operation): New function.\n+        (restore_world_operation): New function.\n+        (compute_save_world_info): New function.\n+        (rs6000_stack_info): Call compute_save_world_info.\n+        (rs6000_emit_prologue): Check for world_save_p and generate\n+        pattern to call save_world for saving all non-volatile and\n+        special registers.\n+        (rs6000_emit_epilogue): Check for world_save_p and generate\n+        pattern to call rest_world to restore saved registers.\n+\n+        config/rs6000/rs6000.h: macros FIRST_SAVED_ALTIVEC_REGNO,\n+        FIRST_SAVED_FP_REGNO, FIRST_SAVED_GP_REGNO defined.\n+        (rs6000_reg_names): New entries added for save_world_operation and\n+        restore_world_operation.\n+\n 2004-08-18  Caroline Tice  <ctice@apple.com>\n \n         * Makefile.in (STAGEFEEDBACK_FLAGS_TO_PASS) Add"}, {"sha": "ff58d8e3fa88a79e4af82cd170255f4219408e59", "filename": "gcc/config/rs6000/altivec.md", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d62294f57e859308c23fcbd156bb88b21e8f4547/gcc%2Fconfig%2Frs6000%2Faltivec.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d62294f57e859308c23fcbd156bb88b21e8f4547/gcc%2Fconfig%2Frs6000%2Faltivec.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faltivec.md?ref=d62294f57e859308c23fcbd156bb88b21e8f4547", "patch": "@@ -295,6 +295,28 @@\n }\"\n   [(set_attr \"type\" \"*\")])\n \n+(define_insn \"*save_world\"\n+ [(match_parallel 0 \"save_world_operation\"\n+                  [(clobber (match_operand:SI 1 \"register_operand\" \"=l\"))\n+                   (use (match_operand:SI 2 \"call_operand\" \"s\"))])]\n+ \"TARGET_MACHO && (DEFAULT_ABI == ABI_DARWIN) && TARGET_32BIT\"         \n+ {\n+    return \"bl %z2\";\n+ }\n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_insn \"*restore_world\"\n+ [(match_parallel 0 \"restore_world_operation\"\n+                  [(return)\n+                   (use (match_operand:SI 1 \"register_operand\" \"l\"))\n+                   (use (match_operand:SI 2 \"call_operand\" \"s\"))\n+                   (clobber (match_operand:SI 3 \"gpc_reg_operand\" \"=r\"))])]\n+ \"TARGET_MACHO && (DEFAULT_ABI == ABI_DARWIN) && TARGET_32BIT\"\n+ {\n+    return \"b %z2\";\n+ })\n+\n ;; Simple binary operations.\n \n (define_insn \"addv16qi3\""}, {"sha": "d146265f133f612c1e1c4c9a64934989e5b6b698", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d62294f57e859308c23fcbd156bb88b21e8f4547/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d62294f57e859308c23fcbd156bb88b21e8f4547/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=d62294f57e859308c23fcbd156bb88b21e8f4547", "patch": "@@ -89,6 +89,8 @@ extern bool legitimate_constant_pool_address_p (rtx);\n extern int expand_block_clear (rtx[]);\n extern int expand_block_move (rtx[]);\n extern int load_multiple_operation (rtx, enum machine_mode);\n+extern int save_world_operation (rtx, enum machine_mode);\n+extern int restore_world_operation (rtx, enum machine_mode);\n extern const char * rs6000_output_load_multiple (rtx[]);\n extern int store_multiple_operation (rtx, enum machine_mode);\n extern int branch_comparison_operator (rtx, enum machine_mode);"}, {"sha": "d103ac38a1561aa33409013ce9a161b7f5e9d9ae", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 420, "deletions": 12, "changes": 432, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d62294f57e859308c23fcbd156bb88b21e8f4547/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d62294f57e859308c23fcbd156bb88b21e8f4547/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=d62294f57e859308c23fcbd156bb88b21e8f4547", "patch": "@@ -79,6 +79,8 @@ typedef struct rs6000_stack {\n   int toc_save_p;\t\t/* true if the TOC needs to be saved */\n   int push_p;\t\t\t/* true if we need to allocate stack space */\n   int calls_p;\t\t\t/* true if the function makes any calls */\n+  int world_save_p;             /* true if we're saving *everything*:\n+\t\t\t\t   r13-r31, cr, f14-f31, vrsave, v20-v31  */\n   enum rs6000_abi abi;\t\t/* which ABI to use */\n   int gp_save_offset;\t\t/* offset to save GP regs from initial SP */\n   int fp_save_offset;\t\t/* offset to save FP regs from initial SP */\n@@ -714,6 +716,7 @@ static void rs6000_parse_tls_size_option (void);\n static void rs6000_parse_yes_no_option (const char *, const char *, int *);\n static int first_altivec_reg_to_save (void);\n static unsigned int compute_vrsave_mask (void);\n+static void compute_save_world_info(rs6000_stack_t *info_ptr);\n static void is_altivec_return_reg (rtx, void *);\n static rtx generate_set_vrsave (rtx, rs6000_stack_t *, int);\n int easy_vector_constant (rtx, enum machine_mode);\n@@ -8529,6 +8532,143 @@ expand_block_move (rtx operands[])\n   return 1;\n }\n \n+\f\n+/* Return 1 if OP is suitable for a save_world call in prologue. It is\n+   known to be a PARALLEL. */\n+int\n+save_world_operation (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  int index;\n+  int i;\n+  rtx elt;\n+  int count = XVECLEN (op, 0);\n+\n+  if (count != 55)\n+    return 0;\n+\n+  index = 0;\n+  if (GET_CODE (XVECEXP (op, 0, index++)) != CLOBBER\n+      || GET_CODE (XVECEXP (op, 0, index++)) != USE)\n+    return 0;\n+\n+  for (i=1; i <= 18; i++)\n+    {\n+      elt = XVECEXP (op, 0, index++);\n+      if (GET_CODE (elt) != SET\n+\t  || GET_CODE (SET_DEST (elt)) != MEM\n+\t  || ! memory_operand (SET_DEST (elt), DFmode)\n+\t  || GET_CODE (SET_SRC (elt)) != REG\n+\t  || GET_MODE (SET_SRC (elt)) != DFmode)\n+\treturn 0;\n+    }\n+\n+  for (i=1; i <= 12; i++)\n+    {\n+      elt = XVECEXP (op, 0, index++);\n+      if (GET_CODE (elt) != SET\n+\t  || GET_CODE (SET_DEST (elt)) != MEM\n+\t  || GET_CODE (SET_SRC (elt)) != REG\n+\t  || GET_MODE (SET_SRC (elt)) != V4SImode)\n+\treturn 0;\n+    }\n+\n+  for (i=1; i <= 19; i++)\n+    {\n+      elt = XVECEXP (op, 0, index++);\n+      if (GET_CODE (elt) != SET\n+\t  || GET_CODE (SET_DEST (elt)) != MEM\n+\t  || ! memory_operand (SET_DEST (elt), Pmode)\n+\t  || GET_CODE (SET_SRC (elt)) != REG\n+\t  || GET_MODE (SET_SRC (elt)) != Pmode)\n+\treturn 0;\n+    }\n+\n+  elt = XVECEXP (op, 0, index++);\n+  if (GET_CODE (elt) != SET\n+      || GET_CODE (SET_DEST (elt)) != MEM\n+      || ! memory_operand (SET_DEST (elt), Pmode)\n+      || GET_CODE (SET_SRC (elt)) != REG\n+      || REGNO (SET_SRC (elt)) != CR2_REGNO\n+      || GET_MODE (SET_SRC (elt)) != Pmode)\n+    return 0;\n+\n+  if (GET_CODE (XVECEXP (op, 0, index++)) != USE\n+      || GET_CODE (XVECEXP (op, 0, index++)) != USE\n+      || GET_CODE (XVECEXP (op, 0, index++)) != CLOBBER)\n+    return 0;\n+  return 1;\n+}\n+\n+/* Return 1 if OP is suitable for a save_world call in prologue. It is\n+   known to be a PARALLEL. */\n+int\n+restore_world_operation (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  int index;\n+  int i;\n+  rtx elt;\n+  int count = XVECLEN (op, 0);\n+\n+  if (count != 59)\n+    return 0;\n+\n+  index = 0;\n+  if (GET_CODE (XVECEXP (op, 0, index++)) != RETURN\n+      || GET_CODE (XVECEXP (op, 0, index++)) != USE\n+      || GET_CODE (XVECEXP (op, 0, index++)) != USE\n+      || GET_CODE (XVECEXP (op, 0, index++)) != CLOBBER)\n+    return 0;\n+\n+  elt = XVECEXP (op, 0, index++);\n+  if (GET_CODE (elt) != SET\n+      || GET_CODE (SET_SRC (elt)) != MEM\n+      || ! memory_operand (SET_SRC (elt), Pmode)\n+      || GET_CODE (SET_DEST (elt)) != REG\n+      || REGNO (SET_DEST (elt)) != CR2_REGNO\n+      || GET_MODE (SET_DEST (elt)) != Pmode)\n+    return 0;\n+\n+  for (i=1; i <= 19; i++)\n+    {\n+      elt = XVECEXP (op, 0, index++);\n+      if (GET_CODE (elt) != SET\n+\t  || GET_CODE (SET_SRC (elt)) != MEM\n+\t  || ! memory_operand (SET_SRC (elt), Pmode)\n+\t  || GET_CODE (SET_DEST (elt)) != REG\n+\t  || GET_MODE (SET_DEST (elt)) != Pmode)\n+\treturn 0;\n+    }\n+\n+  for (i=1; i <= 12; i++)\n+    {\n+      elt = XVECEXP (op, 0, index++);\n+      if (GET_CODE (elt) != SET\n+\t  || GET_CODE (SET_SRC (elt)) != MEM\n+\t  || GET_CODE (SET_DEST (elt)) != REG\n+\t  || GET_MODE (SET_DEST (elt)) != V4SImode)\n+\treturn 0;\n+    }\n+\n+  for (i=1; i <= 18; i++)\n+    {\n+      elt = XVECEXP (op, 0, index++);\n+      if (GET_CODE (elt) != SET\n+\t  || GET_CODE (SET_SRC (elt)) != MEM\n+\t  || ! memory_operand (SET_SRC (elt), DFmode)\n+\t  || GET_CODE (SET_DEST (elt)) != REG\n+\t  || GET_MODE (SET_DEST (elt)) != DFmode)\n+\treturn 0;\n+    }\n+\n+  if (GET_CODE (XVECEXP (op, 0, index++)) != CLOBBER\n+      || GET_CODE (XVECEXP (op, 0, index++)) != CLOBBER\n+      || GET_CODE (XVECEXP (op, 0, index++)) != CLOBBER\n+      || GET_CODE (XVECEXP (op, 0, index++)) != CLOBBER\n+      || GET_CODE (XVECEXP (op, 0, index++)) != USE)\n+    return 0;\n+  return 1;\n+}\n+\n \f\n /* Return 1 if OP is a load multiple operation.  It is known to be a\n    PARALLEL and the first section will be tested.  */\n@@ -11362,6 +11502,57 @@ compute_vrsave_mask (void)\n   return mask;\n }\n \n+/* For a very restricted set of circumstances, we can cut down the\n+   size of prologs/epilogs by calling our own save/restore-the-world\n+   routines. */\n+\n+static void\n+compute_save_world_info(rs6000_stack_t *info_ptr)\n+{\n+  info_ptr->world_save_p =\n+    (DEFAULT_ABI == ABI_DARWIN)\n+    && ! (current_function_calls_setjmp && flag_exceptions)\n+    && info_ptr->first_fp_reg_save == FIRST_SAVED_FP_REGNO\n+    && info_ptr->first_gp_reg_save == FIRST_SAVED_GP_REGNO\n+    && info_ptr->first_altivec_reg_save == FIRST_SAVED_ALTIVEC_REGNO\n+    && info_ptr->cr_save_p;\n+  \n+  /* This will not work in conjunction with sibcalls.  Make sure there\n+     are none.  (This check is expensive, but seldom executed.) */\n+  if ( info_ptr->world_save_p )\n+    { \n+      rtx insn;\n+      for ( insn = get_last_insn_anywhere (); insn; insn = PREV_INSN (insn))\n+        if ( GET_CODE (insn) == CALL_INSN\n+             && SIBLING_CALL_P (insn))\n+          { \n+            info_ptr->world_save_p = 0;\n+            break;\n+          }\n+    }\n+  \n+  if (info_ptr->world_save_p)\n+    {\n+      /* Even if we're not touching VRsave, make sure there's room on the\n+\t stack for it, if it looks like we're calling SAVE_WORLD, which\n+         will attempt to save it. */\n+      info_ptr->vrsave_size  = 4;\n+\n+      /* \"Save\" the VRsave register too if we're saving the world.  */\n+      if (info_ptr->vrsave_mask == 0)\n+        info_ptr->vrsave_mask = compute_vrsave_mask ();\n+\n+      /* Because the Darwin register save/restore routines only handle\n+         F14 .. F31 and V20 .. V31 as per the ABI, perform a consistancy\n+         check and abort if there's something worng.  */\n+      if (info_ptr->first_fp_reg_save < FIRST_SAVED_FP_REGNO \n+          || info_ptr->first_altivec_reg_save < FIRST_SAVED_ALTIVEC_REGNO)\n+        abort ();\n+    }\n+  return; \n+}\n+\n+\n static void\n is_altivec_return_reg (rtx reg, void *xyes)\n {\n@@ -11602,6 +11793,8 @@ rs6000_stack_info (void)\n   else\n     info_ptr->vrsave_size  = 0;\n \n+  compute_save_world_info (info_ptr);\n+\n   /* Calculate the offsets.  */\n   switch (DEFAULT_ABI)\n     {\n@@ -12716,8 +12909,128 @@ rs6000_emit_prologue (void)\n \trs6000_emit_stack_tie ();\n     }\n \n+  /* Handle world saves specially here.  */\n+  if (info->world_save_p)\n+    {\n+      int i, j, sz;\n+      rtx treg;\n+      rtvec p;\n+\n+      /* save_world expects lr in r0. */\n+      if (info->lr_save_p)\n+        {\n+          insn = emit_move_insn (gen_rtx_REG (Pmode, 0),\n+\t\t\t         gen_rtx_REG (Pmode, LINK_REGISTER_REGNUM));\n+          RTX_FRAME_RELATED_P (insn) = 1;\n+        }\n+\n+      /* The SAVE_WORLD and RESTORE_WORLD routines make a number of\n+         assumptions about the offsets of various bits of the stack\n+         frame.  Abort if things aren't what they should be.  */\n+      if (info->gp_save_offset != -220\n+          || info->fp_save_offset != -144\n+          || info->lr_save_offset != 8\n+          || info->cr_save_offset != 4\n+          || !info->push_p\n+          || !info->lr_save_p\n+          || (current_function_calls_eh_return && info->ehrd_offset != -432)\n+          || (info->vrsave_save_offset != -224\n+              || info->altivec_save_offset != (-224 -16 -192)))\n+        abort ();\n+\n+      treg = gen_rtx_REG (SImode, 11);\n+      emit_move_insn (treg, GEN_INT (-info->total_size));\n+\n+      /* SAVE_WORLD takes the caller's LR in R0 and the frame size\n+         in R11.  It also clobbers R12, so beware!  */\n+\n+      /* Preserve CR2 for save_world prologues */\n+      sz = 6;\n+      sz += 32 - info->first_gp_reg_save;\n+      sz += 64 - info->first_fp_reg_save;\n+      sz += LAST_ALTIVEC_REGNO - info->first_altivec_reg_save + 1;\n+      p = rtvec_alloc (sz);\n+      j = 0;\n+      RTVEC_ELT (p, j++) = gen_rtx_CLOBBER (VOIDmode,\n+                                            gen_rtx_REG (Pmode,\n+                                                         LINK_REGISTER_REGNUM));\n+      RTVEC_ELT (p, j++) = gen_rtx_USE (VOIDmode,\n+                                        gen_rtx_SYMBOL_REF (Pmode,\n+                                                            \"*save_world\"));\n+      /* We do floats first so that the instruction pattern matches\n+         properly.  */\n+     for (i = 0; i < 64 - info->first_fp_reg_save; i++)\n+        {\n+          rtx reg = gen_rtx_REG (DFmode, info->first_fp_reg_save + i);\n+          rtx addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n+                                   GEN_INT (info->fp_save_offset\n+                                            + sp_offset + 8 * i));\n+          rtx mem = gen_rtx_MEM (DFmode, addr);\n+          set_mem_alias_set (mem, rs6000_sr_alias_set);\n+\n+          RTVEC_ELT (p, j++) = gen_rtx_SET (VOIDmode, mem, reg);\n+        }\n+      for (i = 0; info->first_altivec_reg_save + i <= LAST_ALTIVEC_REGNO; i++)\n+        {\n+          rtx reg = gen_rtx_REG (V4SImode, info->first_altivec_reg_save + i);\n+          rtx addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n+                                   GEN_INT (info->altivec_save_offset\n+                                            + sp_offset + 16 * i));\n+          rtx mem = gen_rtx_MEM (V4SImode, addr);\n+          set_mem_alias_set (mem, rs6000_sr_alias_set);\n+\n+          RTVEC_ELT (p, j++) = gen_rtx_SET (VOIDmode, mem, reg);\n+        }\n+      for (i = 0; i < 32 - info->first_gp_reg_save; i++)\n+        {\n+          rtx reg = gen_rtx_REG (reg_mode, info->first_gp_reg_save + i);\n+          rtx addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n+                                   GEN_INT (info->gp_save_offset\n+                                            + sp_offset + reg_size * i));\n+          rtx mem = gen_rtx_MEM (reg_mode, addr);\n+          set_mem_alias_set (mem, rs6000_sr_alias_set);\n+\n+          RTVEC_ELT (p, j++) = gen_rtx_SET (VOIDmode, mem, reg);\n+        }\n+\n+        {\n+          /* CR register traditionally saved as CR2.  */\n+          rtx reg = gen_rtx_REG (reg_mode, CR2_REGNO);\n+          rtx addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n+                                   GEN_INT (info->cr_save_offset\n+                                            + sp_offset));\n+          rtx mem = gen_rtx_MEM (reg_mode, addr);\n+          set_mem_alias_set (mem, rs6000_sr_alias_set);\n+\n+          RTVEC_ELT (p, j++) = gen_rtx_SET (VOIDmode, mem, reg);\n+        }\n+      /* Prevent any attempt to delete the setting of r0 and treg!  */\n+      RTVEC_ELT (p, j++) = gen_rtx_USE (VOIDmode, gen_rtx_REG (Pmode, 0));\n+      RTVEC_ELT (p, j++) = gen_rtx_USE (VOIDmode, treg);\n+      RTVEC_ELT (p, j++) = gen_rtx_CLOBBER (VOIDmode, sp_reg_rtx);\n+\n+      insn = emit_insn (gen_rtx_PARALLEL (VOIDmode, p));\n+      rs6000_frame_related (insn, frame_ptr_rtx, info->total_size,\n+                            NULL_RTX, NULL_RTX);\n+\n+      if (current_function_calls_eh_return)\n+        {\n+          unsigned int i;\n+          for (i = 0; ; ++i)\n+            {\n+              unsigned int regno = EH_RETURN_DATA_REGNO (i);\n+              if (regno == INVALID_REGNUM)\n+                break;\n+              emit_frame_save (frame_reg_rtx, frame_ptr_rtx, reg_mode, regno,\n+                               info->ehrd_offset + sp_offset\n+                               + reg_size * (int) i,\n+                               info->total_size);\n+            }\n+        }\n+    }\n+\n   /* Save AltiVec registers if needed.  */\n-  if (TARGET_ALTIVEC_ABI && info->altivec_size != 0)\n+  if (! info->world_save_p && TARGET_ALTIVEC_ABI && info->altivec_size != 0)\n     {\n       int i;\n \n@@ -12758,7 +13071,7 @@ rs6000_emit_prologue (void)\n      epilogue.  */\n \n   if (TARGET_ALTIVEC && TARGET_ALTIVEC_VRSAVE\n-      && info->vrsave_mask != 0)\n+      && ! info->world_save_p && info->vrsave_mask != 0)\n     {\n       rtx reg, mem, vrsave;\n       int offset;\n@@ -12786,15 +13099,15 @@ rs6000_emit_prologue (void)\n     }\n \n   /* If we use the link register, get it into r0.  */\n-  if (info->lr_save_p)\n+  if (! info->world_save_p && info->lr_save_p)\n     {\n       insn = emit_move_insn (gen_rtx_REG (Pmode, 0),\n \t\t\t     gen_rtx_REG (Pmode, LINK_REGISTER_REGNUM));\n       RTX_FRAME_RELATED_P (insn) = 1;\n     }\n \n   /* If we need to save CR, put it into r12.  */\n-  if (info->cr_save_p && frame_reg_rtx != frame_ptr_rtx)\n+  if (! info->world_save_p && info->cr_save_p && frame_reg_rtx != frame_ptr_rtx)\n     {\n       rtx set;\n       \n@@ -12816,7 +13129,7 @@ rs6000_emit_prologue (void)\n \n   /* Do any required saving of fpr's.  If only one or two to save, do\n      it ourselves.  Otherwise, call function.  */\n-  if (saving_FPRs_inline)\n+  if (! info->world_save_p && saving_FPRs_inline)\n     {\n       int i;\n       for (i = 0; i < 64 - info->first_fp_reg_save; i++)\n@@ -12827,7 +13140,7 @@ rs6000_emit_prologue (void)\n \t\t\t   info->fp_save_offset + sp_offset + 8 * i,\n \t\t\t   info->total_size);\n     }\n-  else if (info->first_fp_reg_save != 64)\n+  else if (! info->world_save_p && info->first_fp_reg_save != 64)\n     {\n       int i;\n       char rname[30];\n@@ -12863,7 +13176,7 @@ rs6000_emit_prologue (void)\n \n   /* Save GPRs.  This is done as a PARALLEL if we are using\n      the store-multiple instructions.  */\n-  if (using_store_multiple)\n+  if (! info->world_save_p && using_store_multiple)\n     {\n       rtvec p;\n       int i;\n@@ -12885,7 +13198,7 @@ rs6000_emit_prologue (void)\n       rs6000_frame_related (insn, frame_ptr_rtx, info->total_size, \n \t\t\t    NULL_RTX, NULL_RTX);\n     }\n-  else\n+  else if (! info->world_save_p)\n     {\n       int i;\n       for (i = 0; i < 32 - info->first_gp_reg_save; i++)\n@@ -12944,7 +13257,7 @@ rs6000_emit_prologue (void)\n \n   /* ??? There's no need to emit actual instructions here, but it's the\n      easiest way to get the frame unwind information emitted.  */\n-  if (current_function_calls_eh_return)\n+  if (! info->world_save_p && current_function_calls_eh_return)\n     {\n       unsigned int i, regno;\n \n@@ -12979,7 +13292,7 @@ rs6000_emit_prologue (void)\n     }\n \n   /* Save lr if we used it.  */\n-  if (info->lr_save_p)\n+  if (! info->world_save_p && info->lr_save_p)\n     {\n       rtx addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n \t\t\t       GEN_INT (info->lr_save_offset + sp_offset));\n@@ -12994,7 +13307,7 @@ rs6000_emit_prologue (void)\n     }\n \n   /* Save CR if we use any that must be preserved.  */\n-  if (info->cr_save_p)\n+  if (! info->world_save_p && info->cr_save_p)\n     {\n       rtx addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n \t\t\t       GEN_INT (info->cr_save_offset + sp_offset));\n@@ -13027,7 +13340,7 @@ rs6000_emit_prologue (void)\n \n   /* Update stack and set back pointer unless this is V.4, \n      for which it was done previously.  */\n-  if (info->push_p\n+  if (! info->world_save_p && info->push_p\n       && !(DEFAULT_ABI == ABI_V4 || current_function_calls_eh_return))\n     rs6000_emit_allocate_stack (info->total_size, FALSE);\n \n@@ -13196,6 +13509,101 @@ rs6000_emit_epilogue (int sibcall)\n \t\t\t || rs6000_cpu == PROCESSOR_PPC750\n \t\t\t || optimize_size);\n \n+  if (info->world_save_p)\n+    {\n+      int i, j;\n+      char rname[30];\n+      const char *alloc_rname;\n+      rtvec p;\n+\n+      /* eh_rest_world_r10 will return to the location saved in the LR\n+         stack slot (which is not likely to be our caller.)\n+         Input: R10 -- stack adjustment.  Clobbers R0, R11, R12, R7, R8.\n+         rest_world is similar, except any R10 parameter is ignored.\n+         The exception-handling stuff that was here in 2.95 is no\n+         longer necessary.  */\n+\n+      p = rtvec_alloc (9\n+\t\t       + 1\n+\t\t       + 32 - info->first_gp_reg_save \n+                       + LAST_ALTIVEC_REGNO + 1 - info->first_altivec_reg_save\n+                       + 63 + 1 - info->first_fp_reg_save);\n+\n+      strcpy (rname, (current_function_calls_eh_return) ?\n+                        \"*eh_rest_world_r10\" : \"*rest_world\");\n+      alloc_rname = ggc_strdup (rname);\n+\n+      j = 0;\n+      RTVEC_ELT (p, j++) = gen_rtx_RETURN (VOIDmode);\n+      RTVEC_ELT (p, j++) = gen_rtx_USE (VOIDmode,\n+                                        gen_rtx_REG (Pmode,\n+                                                     LINK_REGISTER_REGNUM));\n+      RTVEC_ELT (p, j++)\n+        = gen_rtx_USE (VOIDmode, gen_rtx_SYMBOL_REF (Pmode, alloc_rname));\n+      /* The instruction pattern requires a clobber here;\n+         it is shared with the restVEC helper. */\n+      RTVEC_ELT (p, j++)\n+        = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (Pmode, 11));\n+\n+      {\n+        /* CR register traditionally saved as CR2.  */\n+        rtx reg = gen_rtx_REG (reg_mode, CR2_REGNO);\n+        rtx addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n+                                 GEN_INT (info->cr_save_offset));\n+        rtx mem = gen_rtx_MEM (reg_mode, addr);\n+        set_mem_alias_set (mem, rs6000_sr_alias_set);\n+\n+        RTVEC_ELT (p, j++) = gen_rtx_SET (VOIDmode, reg, mem);\n+      }\n+\n+      for (i = 0; i < 32 - info->first_gp_reg_save; i++)\n+        {\n+          rtx reg = gen_rtx_REG (reg_mode, info->first_gp_reg_save + i);\n+          rtx addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n+                                   GEN_INT (info->gp_save_offset\n+                                            + reg_size * i));\n+          rtx mem = gen_rtx_MEM (reg_mode, addr);\n+          set_mem_alias_set (mem, rs6000_sr_alias_set);\n+\n+          RTVEC_ELT (p, j++) = gen_rtx_SET (VOIDmode, reg, mem);\n+      }\n+      for (i = 0; info->first_altivec_reg_save + i <= LAST_ALTIVEC_REGNO; i++)\n+        {\n+          rtx reg = gen_rtx_REG (V4SImode, info->first_altivec_reg_save + i);\n+          rtx addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n+                                   GEN_INT (info->altivec_save_offset\n+                                            + 16 * i));\n+          rtx mem = gen_rtx_MEM (V4SImode, addr);\n+          set_mem_alias_set (mem, rs6000_sr_alias_set);\n+\n+          RTVEC_ELT (p, j++) = gen_rtx_SET (VOIDmode, reg, mem);\n+        }\n+      for (i = 0; info->first_fp_reg_save + i <= 63; i++)\n+        {\n+          rtx reg = gen_rtx_REG (DFmode, info->first_fp_reg_save + i);\n+          rtx addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n+                                   GEN_INT (info->fp_save_offset\n+                                            + 8 * i));\n+          rtx mem = gen_rtx_MEM (DFmode, addr);\n+          set_mem_alias_set (mem, rs6000_sr_alias_set);\n+\n+          RTVEC_ELT (p, j++) = gen_rtx_SET (VOIDmode, reg, mem);\n+        }\n+      RTVEC_ELT (p, j++)\n+        = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (Pmode, 0));\n+      RTVEC_ELT (p, j++)\n+        = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (SImode, 12));\n+      RTVEC_ELT (p, j++)\n+        = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (SImode, 7));\n+      RTVEC_ELT (p, j++)\n+        = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (SImode, 8));\n+      RTVEC_ELT (p, j++)\n+        = gen_rtx_USE (VOIDmode, gen_rtx_REG (SImode, 10));\n+      emit_jump_insn (gen_rtx_PARALLEL (VOIDmode, p));\n+\n+      return;\n+    }\n+\n   /* If we have a frame pointer, a call to alloca,  or a large stack\n      frame, restore the old stack pointer using the backchain.  Otherwise,\n      we know what size to update it with.  */"}, {"sha": "1f5caaa96fc1ca38cad6a48e1c3a29f0718dd9fd", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d62294f57e859308c23fcbd156bb88b21e8f4547/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d62294f57e859308c23fcbd156bb88b21e8f4547/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=d62294f57e859308c23fcbd156bb88b21e8f4547", "patch": "@@ -916,6 +916,10 @@ extern const char *rs6000_warn_altivec_long_switch;\n #define SPE_ACC_REGNO\t\t111\n #define SPEFSCR_REGNO\t\t112\n \n+#define FIRST_SAVED_ALTIVEC_REGNO (FIRST_ALTIVEC_REGNO+20)\n+#define FIRST_SAVED_FP_REGNO    (14+32)\n+#define FIRST_SAVED_GP_REGNO 13\n+\n /* List the order in which to allocate registers.  Each register must be\n    listed once, even those in FIXED_REGISTERS.\n \n@@ -2587,6 +2591,8 @@ extern char rs6000_reg_names[][8];\t/* register names (0 vs. %r0).  */\n   {\"lmw_operation\", {PARALLEL}},\t\t\t\t\t   \\\n   {\"stmw_operation\", {PARALLEL}},\t\t\t\t\t   \\\n   {\"vrsave_operation\", {PARALLEL}},\t\t\t\t\t   \\\n+  {\"save_world_operation\", {PARALLEL}},                                    \\\n+  {\"restore_world_operation\", {PARALLEL}},                                 \\\n   {\"mfcr_operation\", {PARALLEL}},\t\t\t\t\t   \\\n   {\"mtcrf_operation\", {PARALLEL}},\t\t\t\t\t   \\\n   {\"branch_comparison_operator\", {EQ, NE, LE, LT, GE,\t\t\t   \\"}]}