{"sha": "bf77398cef20e7f1d079bb8b76d383c4ca163165", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmY3NzM5OGNlZjIwZTdmMWQwNzliYjhiNzZkMzgzYzRjYTE2MzE2NQ==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "rakdver@atrey.karlin.mff.cuni.cz", "date": "2002-05-28T12:53:47Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2002-05-28T12:53:47Z"}, "message": "basic-block.h (last_basic_block): Declare.\n\n\t* basic-block.h (last_basic_block): Declare.\n\t(expunge_block_nocompact): Declaration removed.\n\t(compact_blocks): Declare.\n\t* cfg.c (last_basic_block): New variable.\n\t(expunge_block_nocompact): Removed.\n\t(expunge_block): Do not compact basic blocks.\n\t(compact_blocks): New.\n\t* cfganal.c (flow_call_edges_add): Use the fact that bb indices no\n\tlonger change.\n\t* cfgbuild.c (find_basic_blocks_1, find_basic_blocks): Set\n\tlast_basic_block.\n\t* cfgcleanup.c (merge_blocks_move_predecessor_nojumps): Do not change\n\treal positions of blocks.\n\t(delete_unreachable_blocks): Simplified -- quadratic behavior now\n\tcannot occur.\n\t(cleanup_cfg): Compact blocks.\n\t* cfgrtl.c (create_basic_block): Insert basic blocks to the end of\n\tbasic_block_info varray.\n\t(flow_delete_block): Comment update.\n\t(back_edge_of_syntactic_loop_p): Modify position check code.\n\t(verify_flow_info): Update checking.\n\t* flow.c (calculate_global_regs_live): Use FOR_EACH_BB.\n\t* ifcvt.c (SET_ORIG_INDEX, ORIG_INDEX): Removed.\n\t(find_if_case_1, find_if_case_2, if_convert): Use the fact that bb\n\tindices no longer change.\n\t* lcm.c (optimize_mode_switching): Replace n_basic_blocks with\n\tlast_basic_block.\n\t* predict.c (estimate_bb_frequencies): Remove unneccessary code.\n\t* profile.c (branch_prob): Compact blocks.\n\t* sched-rgn.c (find_rgns): Replace n_basic_blocks with\n\tlast_basic_block.\n\nFrom-SVN: r53957", "tree": {"sha": "e6c0737229b9c2c57cf0353f3dd15ebecc686b75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e6c0737229b9c2c57cf0353f3dd15ebecc686b75"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bf77398cef20e7f1d079bb8b76d383c4ca163165", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf77398cef20e7f1d079bb8b76d383c4ca163165", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf77398cef20e7f1d079bb8b76d383c4ca163165", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf77398cef20e7f1d079bb8b76d383c4ca163165/comments", "author": null, "committer": null, "parents": [{"sha": "ae12a094d64ceac6fa406c67f1e38e59bdfd95c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae12a094d64ceac6fa406c67f1e38e59bdfd95c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae12a094d64ceac6fa406c67f1e38e59bdfd95c9"}], "stats": {"total": 259, "additions": 126, "deletions": 133}, "files": [{"sha": "174b392e3dd3d6d8f566a643516af8accd93581f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf77398cef20e7f1d079bb8b76d383c4ca163165/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf77398cef20e7f1d079bb8b76d383c4ca163165/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bf77398cef20e7f1d079bb8b76d383c4ca163165", "patch": "@@ -1,3 +1,37 @@\n+2002-05-28  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n+\n+\t* basic-block.h (last_basic_block): Declare.\n+\t(expunge_block_nocompact): Declaration removed.\n+\t(compact_blocks): Declare.\n+\t* cfg.c (last_basic_block): New variable.\n+\t(expunge_block_nocompact): Removed.\n+\t(expunge_block): Do not compact basic blocks.\n+\t(compact_blocks): New.\n+\t* cfganal.c (flow_call_edges_add): Use the fact that bb indices no\n+\tlonger change.\n+\t* cfgbuild.c (find_basic_blocks_1, find_basic_blocks): Set\n+\tlast_basic_block.\n+\t* cfgcleanup.c (merge_blocks_move_predecessor_nojumps): Do not change\n+\treal positions of blocks.\n+\t(delete_unreachable_blocks): Simplified -- quadratic behavior now\n+\tcannot occur.\n+\t(cleanup_cfg): Compact blocks.\n+\t* cfgrtl.c (create_basic_block): Insert basic blocks to the end of\n+\tbasic_block_info varray.\n+\t(flow_delete_block): Comment update.\n+\t(back_edge_of_syntactic_loop_p): Modify position check code.\n+\t(verify_flow_info): Update checking.\n+\t* flow.c (calculate_global_regs_live): Use FOR_EACH_BB.\n+\t* ifcvt.c (SET_ORIG_INDEX, ORIG_INDEX): Removed.\n+\t(find_if_case_1, find_if_case_2, if_convert): Use the fact that bb\n+\tindices no longer change.\n+\t* lcm.c (optimize_mode_switching): Replace n_basic_blocks with\n+\tlast_basic_block.\n+\t* predict.c (estimate_bb_frequencies): Remove unneccessary code.\n+\t* profile.c (branch_prob): Compact blocks.\n+\t* sched-rgn.c (find_rgns): Replace n_basic_blocks with\n+\tlast_basic_block.\n+\n 2002-05-28  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* config/h8300/h8300.md (two anonymous patterns): New."}, {"sha": "a848e946e91d36b65edf024c148229307a8e621e", "filename": "gcc/basic-block.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf77398cef20e7f1d079bb8b76d383c4ca163165/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf77398cef20e7f1d079bb8b76d383c4ca163165/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=bf77398cef20e7f1d079bb8b76d383c4ca163165", "patch": "@@ -235,7 +235,7 @@ extern int n_basic_blocks;\n \n /* First free basic block number.  */\n \n-#define last_basic_block n_basic_blocks\n+extern int last_basic_block;\n \n /* Number of edges in the current function.  */\n \n@@ -670,7 +670,7 @@ extern void allocate_bb_life_data\tPARAMS ((void));\n extern void expunge_block\t\tPARAMS ((basic_block));\n extern void link_block\t\t\tPARAMS ((basic_block, basic_block));\n extern void unlink_block\t\tPARAMS ((basic_block));\n-extern void expunge_block_nocompact\tPARAMS ((basic_block));\n+extern void compact_blocks\t\tPARAMS ((void));\n extern basic_block alloc_block\t\tPARAMS ((void));\n extern void find_unreachable_blocks\tPARAMS ((void));\n extern int delete_noop_moves\t\tPARAMS ((rtx));"}, {"sha": "313516b32fa1c7fc6129b71934c9612e4175f659", "filename": "gcc/cfg.c", "status": "modified", "additions": 29, "deletions": 21, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf77398cef20e7f1d079bb8b76d383c4ca163165/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf77398cef20e7f1d079bb8b76d383c4ca163165/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=bf77398cef20e7f1d079bb8b76d383c4ca163165", "patch": "@@ -65,6 +65,10 @@ static char *flow_firstobj;\n \n int n_basic_blocks;\n \n+/* First free basic block number.  */\n+\n+int last_basic_block;\n+\n /* Number of edges in the current function.  */\n \n int n_edges;\n@@ -243,40 +247,44 @@ unlink_block (b)\n   b->prev_bb->next_bb = b->next_bb;\n }\n \n+/* Sequentially order blocks and compact the arrays.  */\n+void\n+compact_blocks ()\n+{\n+  int i;\n+  basic_block bb;\n+ \n+  i = 0;\n+  FOR_EACH_BB (bb)\n+    {\n+      BASIC_BLOCK (i) = bb;\n+      bb->index = i;\n+      i++;\n+    }\n+\n+  if (i != n_basic_blocks)\n+    abort ();\n+\n+  last_basic_block = n_basic_blocks;\n+}\n+\n \n-/* Remove block B from the basic block array and compact behind it.  */\n+/* Remove block B from the basic block array.  */\n \n void\n-expunge_block_nocompact (b)\n+expunge_block (b)\n      basic_block b;\n {\n   unlink_block (b);\n+  BASIC_BLOCK (b->index) = NULL;\n+  n_basic_blocks--;\n \n   /* Invalidate data to make bughunting easier.  */\n   memset (b, 0, sizeof *b);\n   b->index = -3;\n   b->succ = (edge) first_deleted_block;\n   first_deleted_block = (basic_block) b;\n }\n-\n-void\n-expunge_block (b)\n-     basic_block b;\n-{\n-  int i, n = n_basic_blocks;\n-\n-  for (i = b->index; i + 1 < n; ++i)\n-    {\n-      basic_block x = BASIC_BLOCK (i + 1);\n-      BASIC_BLOCK (i) = x;\n-      x->index = i;\n-    }\n-\n-  n_basic_blocks--;\n-  basic_block_info->num_elements--;\n-\n-  expunge_block_nocompact (b);\n-}\n \f\n /* Create an edge connecting SRC and DST with FLAGS optionally using\n    edge cache CACHE.  Return the new edge, NULL if already exist.  */"}, {"sha": "5f69d1ab2d4259445aa8d57ee1658eb38d64af23", "filename": "gcc/cfganal.c", "status": "modified", "additions": 14, "deletions": 22, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf77398cef20e7f1d079bb8b76d383c4ca163165/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf77398cef20e7f1d079bb8b76d383c4ca163165/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=bf77398cef20e7f1d079bb8b76d383c4ca163165", "patch": "@@ -258,29 +258,16 @@ flow_call_edges_add (blocks)\n {\n   int i;\n   int blocks_split = 0;\n-  int bb_num = 0;\n-  basic_block *bbs, bb;\n+  int last_bb = last_basic_block;\n   bool check_last_block = false;\n \n-  /* Map bb indices into basic block pointers since split_block\n-     will renumber the basic blocks.  */\n-\n-  bbs = xmalloc (n_basic_blocks * sizeof (*bbs));\n+  if (n_basic_blocks == 0)\n+    return 0;\n \n   if (! blocks)\n-    {\n-      FOR_EACH_BB (bb)\n-\tbbs[bb_num++] = bb;\n-\n-      check_last_block = true;\n-    }\n+    check_last_block = true;\n   else\n-    EXECUTE_IF_SET_IN_SBITMAP (blocks, 0, i,\n-\t\t\t       {\n-\t\t\t\t bbs[bb_num++] = BASIC_BLOCK (i);\n-\t\t\t\t if (i == n_basic_blocks - 1)\n-\t\t\t\t   check_last_block = true;\n-\t\t\t       });\n+    check_last_block = TEST_BIT (blocks, EXIT_BLOCK_PTR->prev_bb->index);\n \n   /* In the last basic block, before epilogue generation, there will be\n      a fallthru edge to EXIT.  Special care is required if the last insn\n@@ -321,12 +308,18 @@ flow_call_edges_add (blocks)\n      calls since there is no way that we can determine if they will\n      return or not...  */\n \n-  for (i = 0; i < bb_num; i++)\n+  for (i = 0; i < last_bb; i++)\n     {\n-      basic_block bb = bbs[i];\n+      basic_block bb = BASIC_BLOCK (i);\n       rtx insn;\n       rtx prev_insn;\n \n+      if (!bb)\n+\tcontinue;\n+\n+      if (blocks && !TEST_BIT (blocks, i))\n+\tcontinue;\n+\n       for (insn = bb->end; ; insn = prev_insn)\n \t{\n \t  prev_insn = PREV_INSN (insn);\n@@ -374,7 +367,6 @@ flow_call_edges_add (blocks)\n   if (blocks_split)\n     verify_flow_info ();\n \n-  free (bbs);\n   return blocks_split;\n }\n \n@@ -927,7 +919,7 @@ flow_preorder_transversal_compute (pot_order)\n       for (e = bb->succ; e; e = e->succ_next)\n \tmax_successors++;\n \n-      dfst[i].node\n+      dfst[bb->index].node\n \t= (max_successors\n \t   ? (struct dfst_node **) xcalloc (max_successors,\n \t\t\t\t\t    sizeof (struct dfst_node *))"}, {"sha": "bdf175d53af9d7215b0d51385aa17e854862b24c", "filename": "gcc/cfgbuild.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf77398cef20e7f1d079bb8b76d383c4ca163165/gcc%2Fcfgbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf77398cef20e7f1d079bb8b76d383c4ca163165/gcc%2Fcfgbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgbuild.c?ref=bf77398cef20e7f1d079bb8b76d383c4ca163165", "patch": "@@ -471,7 +471,6 @@ find_basic_blocks_1 (f)\n      rtx f;\n {\n   rtx insn, next;\n-  int i = 0;\n   rtx bb_note = NULL_RTX;\n   rtx lvl = NULL_RTX;\n   rtx trll = NULL_RTX;\n@@ -494,7 +493,7 @@ find_basic_blocks_1 (f)\n       if ((GET_CODE (insn) == CODE_LABEL || GET_CODE (insn) == BARRIER)\n \t  && head)\n \t{\n-\t  prev = create_basic_block_structure (i++, head, end, bb_note, prev);\n+\t  prev = create_basic_block_structure (last_basic_block++, head, end, bb_note, prev);\n \t  head = end = NULL_RTX;\n \t  bb_note = NULL_RTX;\n \t}\n@@ -508,7 +507,7 @@ find_basic_blocks_1 (f)\n \n       if (head && control_flow_insn_p (insn))\n \t{\n-\t  prev = create_basic_block_structure (i++, head, end, bb_note, prev);\n+\t  prev = create_basic_block_structure (last_basic_block++, head, end, bb_note, prev);\n \t  head = end = NULL_RTX;\n \t  bb_note = NULL_RTX;\n \t}\n@@ -590,11 +589,11 @@ find_basic_blocks_1 (f)\n     }\n \n   if (head != NULL_RTX)\n-    create_basic_block_structure (i++, head, end, bb_note, prev);\n+    create_basic_block_structure (last_basic_block++, head, end, bb_note, prev);\n   else if (bb_note)\n     delete_insn (bb_note);\n \n-  if (i != n_basic_blocks)\n+  if (last_basic_block != n_basic_blocks)\n     abort ();\n \n   label_value_list = lvl;\n@@ -635,6 +634,7 @@ find_basic_blocks (f, nregs, file)\n     }\n \n   n_basic_blocks = count_basic_blocks (f);\n+  last_basic_block = 0;\n   ENTRY_BLOCK_PTR->next_bb = EXIT_BLOCK_PTR;\n   EXIT_BLOCK_PTR->prev_bb = ENTRY_BLOCK_PTR;\n "}, {"sha": "2e6e02daba7d25dded1a472def8425f01748630e", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 6, "deletions": 22, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf77398cef20e7f1d079bb8b76d383c4ca163165/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf77398cef20e7f1d079bb8b76d383c4ca163165/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=bf77398cef20e7f1d079bb8b76d383c4ca163165", "patch": "@@ -688,7 +688,6 @@ merge_blocks_move_predecessor_nojumps (a, b)\n      basic_block a, b;\n {\n   rtx barrier;\n-  int index;\n \n   barrier = next_nonnote_insn (a->end);\n   if (GET_CODE (barrier) != BARRIER)\n@@ -714,14 +713,7 @@ merge_blocks_move_predecessor_nojumps (a, b)\n     fprintf (rtl_dump_file, \"Moved block %d before %d and merged.\\n\",\n \t     a->index, b->index);\n \n-  /* Swap the records for the two blocks around.  Although we are deleting B,\n-     A is now where B was and we want to compact the BB array from where\n-     A used to be.  */\n-  BASIC_BLOCK (a->index) = b;\n-  BASIC_BLOCK (b->index) = a;\n-  index = a->index;\n-  a->index = b->index;\n-  b->index = index;\n+  /* Swap the records for the two blocks around.  */\n \n   unlink_block (a);\n   link_block (a, b->prev_bb);\n@@ -1755,32 +1747,21 @@ delete_unreachable_blocks ()\n {\n   bool changed = false;\n   basic_block b, next_bb;\n-  int j = 0;\n \n   find_unreachable_blocks ();\n \n-  /* Delete all unreachable basic blocks.  Do compaction concurrently,\n-     as otherwise we can wind up with O(N^2) behaviour here when we\n-     have oodles of dead code.  */\n+  /* Delete all unreachable basic blocks.  */\n \n   for (b = ENTRY_BLOCK_PTR->next_bb; b != EXIT_BLOCK_PTR; b = next_bb)\n     {\n       next_bb = b->next_bb;\n \n       if (!(b->flags & BB_REACHABLE))\n \t{\n-\t  flow_delete_block_noexpunge (b);\n-\t  expunge_block_nocompact (b);\n+\t  flow_delete_block (b);\n \t  changed = true;\n \t}\n-      else\n-\t{\n-\t  BASIC_BLOCK (j) = b;\n-\t  b->index = j++;\n-\t}\n     }\n-  n_basic_blocks = j;\n-  basic_block_info->num_elements = j;\n \n   if (changed)\n     tidy_fallthru_edges ();\n@@ -1806,6 +1787,9 @@ cleanup_cfg (mode)\n \t  && !reload_completed)\n \tdelete_trivially_dead_insns (get_insns(), max_reg_num ());\n     }\n+\n+  compact_blocks ();\n+\n   while (try_optimize_cfg (mode))\n     {\n       delete_unreachable_blocks (), changed = true;"}, {"sha": "4509fa49de737d6046db5d6dbec18c28d263c146", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 20, "deletions": 38, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf77398cef20e7f1d079bb8b76d383c4ca163165/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf77398cef20e7f1d079bb8b76d383c4ca163165/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=bf77398cef20e7f1d079bb8b76d383c4ca163165", "patch": "@@ -336,22 +336,12 @@ create_basic_block (head, end, after)\n      basic_block after;\n {\n   basic_block bb;\n-  int i;\n-  int index = after->index + 1;\n+  int index = last_basic_block++;\n \n-  /* Place the new block just after the block being split.  */\n-  VARRAY_GROW (basic_block_info, ++n_basic_blocks);\n+  /* Place the new block just after the end.  */\n+  VARRAY_GROW (basic_block_info, last_basic_block);\n \n-  /* Some parts of the compiler expect blocks to be number in\n-     sequential order so insert the new block immediately after the\n-     block being split..  */\n-  for (i = n_basic_blocks - 1; i > index; --i)\n-    {\n-      basic_block tmp = BASIC_BLOCK (i - 1);\n-\n-      BASIC_BLOCK (i) = tmp;\n-      tmp->index = i;\n-    }\n+  n_basic_blocks++;\n \n   bb = create_basic_block_structure (index, head, end, NULL, after);\n   bb->aux = NULL;\n@@ -435,7 +425,7 @@ flow_delete_block (b)\n {\n   int deleted_handler = flow_delete_block_noexpunge (b);\n \n-  /* Remove the basic block from the array, and compact behind it.  */\n+  /* Remove the basic block from the array.  */\n   expunge_block (b);\n \n   return deleted_handler;\n@@ -1210,12 +1200,19 @@ back_edge_of_syntactic_loop_p (bb1, bb2)\n {\n   rtx insn;\n   int count = 0;\n+  basic_block bb;\n \n-  if (bb1->index > bb2->index)\n-    return false;\n-  else if (bb1->index == bb2->index)\n+  if (bb1 == bb2)\n     return true;\n \n+  /* ??? Could we guarantee that bb indices are monotone, so that we could\n+     just compare them?  */\n+  for (bb = bb1; bb && bb != bb2; bb = bb->next_bb)\n+    continue;\n+\n+  if (!bb)\n+    return false;\n+\n   for (insn = bb1->end; insn != bb2->head && count >= 0;\n        insn = NEXT_INSN (insn))\n     if (GET_CODE (insn) == NOTE)\n@@ -1708,7 +1705,7 @@ verify_flow_info ()\n   basic_block *bb_info, *last_visited;\n   size_t *edge_checksum;\n   rtx x;\n-  int i, num_bb_notes, err = 0;\n+  int num_bb_notes, err = 0;\n   basic_block bb, last_bb_seen;\n \n   bb_info = (basic_block *) xcalloc (max_uid, sizeof (basic_block));\n@@ -1734,21 +1731,6 @@ verify_flow_info ()\n \t  err = 1;\n \t}\n \n-      /* For now, also check that we didn't change the order.  */\n-      if (bb != EXIT_BLOCK_PTR && bb->index != last_bb_seen->index + 1)\n-\t{\n-\t  error (\"Wrong order of blocks %d and %d\",\n-\t\t last_bb_seen->index, bb->index);\n-\t  err = 1;\n-\t}\n-\n-      if (bb == EXIT_BLOCK_PTR && last_bb_seen->index != n_basic_blocks - 1)\n-\t{\n-\t  error (\"Only %d of %d blocks in chain\",\n-\t\t last_bb_seen->index + 1, n_basic_blocks);\n-\t  err = 1;\n-\t}\n-\n       last_bb_seen = bb;\n     }\n \n@@ -2065,10 +2047,10 @@ verify_flow_info ()\n       edge_checksum[e->dest->index + 2] -= (size_t) e;\n   }\n \n-  for (i = -2; i < n_basic_blocks; ++i)\n-    if (edge_checksum[i + 2])\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n+    if (edge_checksum[bb->index + 2])\n       {\n-\terror (\"basic block %i edge lists are corrupted\", i);\n+\terror (\"basic block %i edge lists are corrupted\", bb->index);\n \terr = 1;\n       }\n \n@@ -2079,7 +2061,7 @@ verify_flow_info ()\n     {\n       if (NOTE_INSN_BASIC_BLOCK_P (x))\n \t{\n-\t  basic_block bb = NOTE_BASIC_BLOCK (x);\n+\t  bb = NOTE_BASIC_BLOCK (x);\n \n \t  num_bb_notes++;\n \t  if (bb != last_bb_seen->next_bb)"}, {"sha": "17a2662d154c47bc2d93ee9baeb5046fd2309f0f", "filename": "gcc/flow.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf77398cef20e7f1d079bb8b76d383c4ca163165/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf77398cef20e7f1d079bb8b76d383c4ca163165/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=bf77398cef20e7f1d079bb8b76d383c4ca163165", "patch": "@@ -1108,9 +1108,8 @@ calculate_global_regs_live (blocks_in, blocks_out, flags)\n     }\n   else\n     {\n-      for (i = 0; i < n_basic_blocks; ++i)\n+      FOR_EACH_BB (bb)\n \t{\n-\t  basic_block bb = BASIC_BLOCK (i);\n \t  *--qhead = bb;\n \t  bb->aux = bb;\n \t}"}, {"sha": "4ed1494416e3208107ce2a0d895e4be3325e518b", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 10, "deletions": 17, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf77398cef20e7f1d079bb8b76d383c4ca163165/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf77398cef20e7f1d079bb8b76d383c4ca163165/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=bf77398cef20e7f1d079bb8b76d383c4ca163165", "patch": "@@ -110,14 +110,6 @@ static int find_memory\t\t\tPARAMS ((rtx *, void *));\n static int dead_or_predicable\t\tPARAMS ((basic_block, basic_block,\n \t\t\t\t\t\t basic_block, basic_block, int));\n static void noce_emit_move_insn\t\tPARAMS ((rtx, rtx));\n-\f\n-/* Abuse the basic_block AUX field to store the original block index,\n-   as well as a flag indicating that the block should be rescaned for\n-   life analysis.  */\n-\n-#define SET_ORIG_INDEX(BB,I)\t((BB)->aux = (void *)((size_t)(I)))\n-#define ORIG_INDEX(BB)\t\t((size_t)(BB)->aux)\n-\n \f\n /* Count the number of non-jump active insns in BB.  */\n \n@@ -2279,6 +2271,7 @@ find_if_case_1 (test_bb, then_edge, else_edge)\n   basic_block then_bb = then_edge->dest;\n   basic_block else_bb = else_edge->dest, new_bb;\n   edge then_succ = then_bb->succ;\n+  int then_bb_index;\n \n   /* THEN has one successor.  */\n   if (!then_succ || then_succ->succ_next != NULL)\n@@ -2319,11 +2312,15 @@ find_if_case_1 (test_bb, then_edge, else_edge)\n \t\t    then_bb->global_live_at_end, BITMAP_IOR);\n   \n   new_bb = redirect_edge_and_branch_force (FALLTHRU_EDGE (test_bb), else_bb);\n+  then_bb_index = then_bb->index;\n+  flow_delete_block (then_bb);\n   /* Make rest of code believe that the newly created block is the THEN_BB\n-     block we are going to remove.  */\n+     block we removed.  */\n   if (new_bb)\n-    new_bb->aux = then_bb->aux;\n-  flow_delete_block (then_bb);\n+    {\n+      new_bb->index = then_bb_index;\n+      BASIC_BLOCK (then_bb_index) = new_bb;\n+    }\n   /* We've possibly created jump to next insn, cleanup_cfg will solve that\n      later.  */\n \n@@ -2366,8 +2363,8 @@ find_if_case_2 (test_bb, then_edge, else_edge)\n   if (note && INTVAL (XEXP (note, 0)) >= REG_BR_PROB_BASE / 2)\n     ;\n   else if (else_succ->dest->index < 0\n-\t   || TEST_BIT (post_dominators[ORIG_INDEX (then_bb)], \n-\t\t\tORIG_INDEX (else_succ->dest)))\n+\t   || TEST_BIT (post_dominators[then_bb->index], \n+\t\t\telse_succ->dest->index))\n     ;\n   else\n     return FALSE;\n@@ -2706,10 +2703,6 @@ if_convert (x_life_data_ok)\n   if (life_data_ok)\n     clear_bb_flags ();\n \n-  /* Record initial block numbers.  */\n-  FOR_EACH_BB (bb)\n-    SET_ORIG_INDEX (bb, bb->index);\n-\n   /* Go through each of the basic blocks looking for things to convert.  */\n   FOR_EACH_BB (bb)\n     while (find_if_header (bb))"}, {"sha": "2630cf317dcbf2dd61d7a87ca28e8e0ad90413bf", "filename": "gcc/lcm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf77398cef20e7f1d079bb8b76d383c4ca163165/gcc%2Flcm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf77398cef20e7f1d079bb8b76d383c4ca163165/gcc%2Flcm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flcm.c?ref=bf77398cef20e7f1d079bb8b76d383c4ca163165", "patch": "@@ -1290,7 +1290,7 @@ optimize_mode_switching (file)\n \n #ifdef NORMAL_MODE\n   /* Restore the special status of EXIT_BLOCK.  */\n-  n_basic_blocks--;\n+  last_basic_block--;\n   VARRAY_POP (basic_block_info);\n   EXIT_BLOCK_PTR->index = EXIT_BLOCK;\n #endif"}, {"sha": "a5131d4a4757f4434f1dd196c640c4a7e2e4191b", "filename": "gcc/predict.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf77398cef20e7f1d079bb8b76d383c4ca163165/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf77398cef20e7f1d079bb8b76d383c4ca163165/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=bf77398cef20e7f1d079bb8b76d383c4ca163165", "patch": "@@ -1206,8 +1206,6 @@ estimate_bb_frequencies (loops)\n       FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n \tBLOCK_INFO (bb)->tovisit = 1;\n \n-      BLOCK_INFO (ENTRY_BLOCK_PTR)->tovisit = 1;\n-      BLOCK_INFO (EXIT_BLOCK_PTR)->tovisit = 1;\n       propagate_freq (ENTRY_BLOCK_PTR);\n \n       memcpy (&freq_max, &real_zero, sizeof (real_zero));"}, {"sha": "8f7d5ef97a60aa8807857f65335de61139746a4f", "filename": "gcc/profile.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf77398cef20e7f1d079bb8b76d383c4ca163165/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf77398cef20e7f1d079bb8b76d383c4ca163165/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=bf77398cef20e7f1d079bb8b76d383c4ca163165", "patch": "@@ -831,6 +831,9 @@ branch_prob ()\n   num_edges = NUM_EDGES (el);\n   alloc_aux_for_edges (sizeof (struct edge_info));\n \n+  /* The basic blocks are expected to be numbered sequentially.  */\n+  compact_blocks ();\n+\n   ignored_edges = 0;\n   for (i = 0 ; i < num_edges ; i++)\n     {"}, {"sha": "e2ea6b761173a6a8bbe8451d08cb399993126cbb", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf77398cef20e7f1d079bb8b76d383c4ca163165/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf77398cef20e7f1d079bb8b76d383c4ca163165/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=bf77398cef20e7f1d079bb8b76d383c4ca163165", "patch": "@@ -680,7 +680,7 @@ find_rgns (edge_list, dom)\n   in_stack = sbitmap_alloc (last_basic_block);\n   sbitmap_zero (in_stack);\n \n-  for (i = 0; i < n_basic_blocks; i++)\n+  for (i = 0; i < last_basic_block; i++)\n     max_hdr[i] = -1;\n \n   /* DFS traversal to find inner loops in the cfg.  */"}]}