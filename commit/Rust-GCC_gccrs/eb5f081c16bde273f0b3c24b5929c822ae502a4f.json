{"sha": "eb5f081c16bde273f0b3c24b5929c822ae502a4f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWI1ZjA4MWMxNmJkZTI3M2YwYjNjMjRiNTkyOWM4MjJhZTUwMmE0Zg==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.ibm.com", "date": "2020-08-07T05:03:22Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@linux.ibm.com", "date": "2020-08-07T05:03:22Z"}, "message": "Power10: Add BRD, BRW, and BRH support.\n\nThis patch adds support for the ISA 3.1 (power10) instructions that does a byte\nswap of values in GPR registers.\n\ngcc/\n2020-08-07  Michael Meissner  <meissner@linux.ibm.com>\n\n\t* config/rs6000/rs6000.md (bswaphi2_reg): Add ISA 3.1 support.\n\t(bswapsi2_reg): Add ISA 3.1 support.\n\t(bswapdi2): Rename bswapdi2_xxbrd to bswapdi2_brd.\n\t(bswapdi2_brd,bswapdi2_xxbrd): Rename.  Add ISA 3.1 support.\n\ngcc/testsuite/\n2020-08-07  Michael Meissner  <meissner@linux.ibm.com>\n\n\t* gcc.target/powerpc/bswap-brd.c: New test.\n\t* gcc.target/powerpc/bswap-brw.c: New test.\n\t* gcc.target/powerpc/bswap-brh.c: New test.", "tree": {"sha": "d879c763ff5895ab80d06414ae575854f50bb057", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d879c763ff5895ab80d06414ae575854f50bb057"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eb5f081c16bde273f0b3c24b5929c822ae502a4f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb5f081c16bde273f0b3c24b5929c822ae502a4f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb5f081c16bde273f0b3c24b5929c822ae502a4f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb5f081c16bde273f0b3c24b5929c822ae502a4f/comments", "author": null, "committer": null, "parents": [{"sha": "f8ac30f1653ff69706c35af6d725f1d330600f11", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8ac30f1653ff69706c35af6d725f1d330600f11", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8ac30f1653ff69706c35af6d725f1d330600f11"}], "stats": {"total": 100, "additions": 80, "deletions": 20}, "files": [{"sha": "43b620ae1c025eff91c4e3e808383ddf476ee665", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb5f081c16bde273f0b3c24b5929c822ae502a4f/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb5f081c16bde273f0b3c24b5929c822ae502a4f/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=eb5f081c16bde273f0b3c24b5929c822ae502a4f", "patch": "@@ -2591,15 +2591,16 @@\n   [(set_attr \"type\" \"store\")])\n \n (define_insn_and_split \"bswaphi2_reg\"\n-  [(set (match_operand:HI 0 \"gpc_reg_operand\" \"=&r,wa\")\n+  [(set (match_operand:HI 0 \"gpc_reg_operand\" \"=r,&r,wa\")\n \t(bswap:HI\n-\t (match_operand:HI 1 \"gpc_reg_operand\" \"r,wa\")))\n-   (clobber (match_scratch:SI 2 \"=&r,X\"))]\n+\t (match_operand:HI 1 \"gpc_reg_operand\" \"r,r,wa\")))\n+   (clobber (match_scratch:SI 2 \"=X,&r,X\"))]\n   \"\"\n   \"@\n+   brh %0,%1\n    #\n    xxbrh %x0,%x1\"\n-  \"reload_completed && int_reg_operand (operands[0], HImode)\"\n+  \"reload_completed && !TARGET_POWER10 && int_reg_operand (operands[0], HImode)\"\n   [(set (match_dup 3)\n \t(and:SI (lshiftrt:SI (match_dup 4)\n \t\t\t     (const_int 8))\n@@ -2615,21 +2616,22 @@\n   operands[3] = simplify_gen_subreg (SImode, operands[0], HImode, 0);\n   operands[4] = simplify_gen_subreg (SImode, operands[1], HImode, 0);\n }\n-  [(set_attr \"length\" \"12,4\")\n-   (set_attr \"type\" \"*,vecperm\")\n-   (set_attr \"isa\" \"*,p9v\")])\n+  [(set_attr \"length\" \"*,12,*\")\n+   (set_attr \"type\" \"shift,*,vecperm\")\n+   (set_attr \"isa\" \"p10,*,p9v\")])\n \n ;; We are always BITS_BIG_ENDIAN, so the bit positions below in\n ;; zero_extract insns do not change for -mlittle.\n (define_insn_and_split \"bswapsi2_reg\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=&r,wa\")\n+  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,&r,wa\")\n \t(bswap:SI\n-\t (match_operand:SI 1 \"gpc_reg_operand\" \"r,wa\")))]\n+\t (match_operand:SI 1 \"gpc_reg_operand\" \"r,r,wa\")))]\n   \"\"\n   \"@\n+   brw %0,%1\n    #\n    xxbrw %x0,%x1\"\n-  \"reload_completed && int_reg_operand (operands[0], SImode)\"\n+  \"reload_completed && !TARGET_POWER10 && int_reg_operand (operands[0], SImode)\"\n   [(set (match_dup 0)\t\t\t\t\t; DABC\n \t(rotate:SI (match_dup 1)\n \t\t   (const_int 24)))\n@@ -2646,9 +2648,9 @@\n \t\t(and:SI (match_dup 0)\n \t\t\t(const_int -256))))]\n   \"\"\n-  [(set_attr \"length\" \"12,4\")\n-   (set_attr \"type\" \"*,vecperm\")\n-   (set_attr \"isa\" \"*,p9v\")])\n+  [(set_attr \"length\" \"4,12,4\")\n+   (set_attr \"type\" \"shift,*,vecperm\")\n+   (set_attr \"isa\" \"p10,*,p9v\")])\n \n ;; On systems with LDBRX/STDBRX generate the loads/stores directly, just like\n ;; we do for L{H,W}BRX and ST{H,W}BRX above.  If not, we have to generate more\n@@ -2681,7 +2683,7 @@\n \t  emit_insn (gen_bswapdi2_store (dest, src));\n         }\n       else if (TARGET_P9_VECTOR)\n-\temit_insn (gen_bswapdi2_xxbrd (dest, src));\n+\temit_insn (gen_bswapdi2_brd (dest, src));\n       else\n \temit_insn (gen_bswapdi2_reg (dest, src));\n       DONE;\n@@ -2712,13 +2714,15 @@\n   \"stdbrx %1,%y0\"\n   [(set_attr \"type\" \"store\")])\n \n-(define_insn \"bswapdi2_xxbrd\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=wa\")\n-\t(bswap:DI (match_operand:DI 1 \"gpc_reg_operand\" \"wa\")))]\n+(define_insn \"bswapdi2_brd\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,wa\")\n+\t(bswap:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r,wa\")))]\n   \"TARGET_P9_VECTOR\"\n-  \"xxbrd %x0,%x1\"\n-  [(set_attr \"type\" \"vecperm\")\n-   (set_attr \"isa\" \"p9v\")])\n+  \"@\n+   brd %0,%1\n+   xxbrd %x0,%x1\"\n+  [(set_attr \"type\" \"shift,vecperm\")\n+   (set_attr \"isa\" \"p10,p9v\")])\n \n (define_insn \"bswapdi2_reg\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=&r\")"}, {"sha": "876129eb633160af113c2965605411181f8a0196", "filename": "gcc/testsuite/gcc.target/powerpc/bswap-brd.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb5f081c16bde273f0b3c24b5929c822ae502a4f/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbswap-brd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb5f081c16bde273f0b3c24b5929c822ae502a4f/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbswap-brd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbswap-brd.c?ref=eb5f081c16bde273f0b3c24b5929c822ae502a4f", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile { target { lp64 } } } */\n+/* { dg-require-effective-target power10_ok } */\n+/* { dg-options \"-O2 -mdejagnu-cpu=power10\" } */\n+\n+/* This tests whether GCC generates the ISA 3.1 BRW byte swap instruction for\n+   GPR data, but generates XXBRW for data in a vector register.  */\n+\n+unsigned long long\n+bswap_ll (unsigned long long a)\n+{\n+  return __builtin_bswap64 (a); /* { dg-final { scan-assembler {\\mbrd\\M} } } */\n+}\n+\n+double\n+bswap_ll_dbl (unsigned long long a)\n+{\n+  unsigned int b = a;\n+  /* Force the value to be loaded into a vector register.  */\n+  __asm__ (\" # %x0\" : \"+wa\" (b));\n+\n+  /* { dg-final { scan-assembler {\\mxxbrd\\M} } } */\n+  return (double) __builtin_bswap64 (b);\n+}"}, {"sha": "4dbab12891bfe6b8d568a5abe03be144cf471f9b", "filename": "gcc/testsuite/gcc.target/powerpc/bswap-brh.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb5f081c16bde273f0b3c24b5929c822ae502a4f/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbswap-brh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb5f081c16bde273f0b3c24b5929c822ae502a4f/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbswap-brh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbswap-brh.c?ref=eb5f081c16bde273f0b3c24b5929c822ae502a4f", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-require-effective-target power10_ok } */\n+/* { dg-options \"-O2 -mdejagnu-cpu=power10\" } */\n+\n+/* This tests whether GCC generates the ISA 3.1 16-bit byte swap\n+   instruction BRH.  */\n+\n+unsigned short\n+bswap_short (unsigned short a)\n+{\n+  return __builtin_bswap16 (a); /* { dg-final { scan-assembler {\\mbrh\\M} } } */\n+}"}, {"sha": "b3f923eea84816f6e29a35b1122d08fd8b7376f2", "filename": "gcc/testsuite/gcc.target/powerpc/bswap-brw.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb5f081c16bde273f0b3c24b5929c822ae502a4f/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbswap-brw.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb5f081c16bde273f0b3c24b5929c822ae502a4f/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbswap-brw.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbswap-brw.c?ref=eb5f081c16bde273f0b3c24b5929c822ae502a4f", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-require-effective-target power10_ok } */\n+/* { dg-options \"-O2 -mdejagnu-cpu=power10\" } */\n+\n+/* This tests whether GCC generates the ISA 3.1 BRW byte swap instruction for\n+   GPR data, but generates XXBRW for data in a vector register.  */\n+\n+unsigned int\n+bswap_int (unsigned int a)\n+{\n+  return __builtin_bswap32 (a); /* { dg-final { scan-assembler {\\mbrw\\M} } } */\n+}\n+\n+double\n+bswap_int_dbl (unsigned int a)\n+{\n+  unsigned int b = a;\n+  /* Force the value to be loaded into a vector register.  */\n+  __asm__ (\" # %x0\" : \"+wa\" (b));\n+\n+  /* { dg-final { scan-assembler {\\mxxbrw\\M} } } */\n+  return (double) __builtin_bswap32 (b);\n+}"}]}