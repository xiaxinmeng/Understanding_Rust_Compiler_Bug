{"sha": "e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTI1MDBmZWRlZjFhMWM1YjllODE4ZmQxZTJjMjgxYWRmZjgwZGY0YQ==", "commit": {"author": {"name": "Geoffrey Keating", "email": "geoffk@redhat.com", "date": "2002-06-04T07:11:05Z"}, "committer": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "2002-06-04T07:11:05Z"}, "message": "Merge from pch-branch up to tag pch-commit-20020603.\n\nFrom-SVN: r54232", "tree": {"sha": "720630adca0f6b357e05c4feb8cbe33d556925ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/720630adca0f6b357e05c4feb8cbe33d556925ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/comments", "author": null, "committer": null, "parents": [{"sha": "c2ae66169b8326bbf9b1dfa63083d2560fea7ddf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2ae66169b8326bbf9b1dfa63083d2560fea7ddf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2ae66169b8326bbf9b1dfa63083d2560fea7ddf"}], "stats": {"total": 13565, "additions": 7607, "deletions": 5958}, "files": [{"sha": "f8fdbf661ae637b94f4633bf53576072e847d45d", "filename": "gcc/.cvsignore", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2F.cvsignore", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2F.cvsignore", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2F.cvsignore?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -4,3 +4,6 @@ c-parse.c\n tradcif.c\n cscope.files\n cscope.out\n+gengtype-lex.c\n+gengtype-yacc.c\n+gengtype-yacc.h"}, {"sha": "ea60f963b3cec1042b236dc6fd5dbd0aa1bd501d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 1093, "deletions": 0, "changes": 1093, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -1,3 +1,1096 @@\n+2002-06-03  Geoffrey Keating  <geoffk@redhat.com>\n+\n+\tMerge from pch-branch:\n+\t\n+\t* gengtype.h (UNION_OR_STRUCT_P): New macro.\n+\t* gengtype.c (write_gc_structure_fields): Use it.\n+\t(write_gc_root): Use it here too.\n+\n+\t* gengtype.c (write_gc_structure_fields): Assume that lengths\n+\tof typenames fit into an 'int'; don't pass a size_t to \"%d\" in\n+\tprintf.\n+\t(write_gc_marker_routine_for_structure): Likewise.\n+\t(write_gc_types): Likewise.\n+\t(write_gc_root): Likewise.\n+\n+\t* varray.h (VARRAY_CLEAR): New.\n+\t(varray_clear): Prototype.\n+\t* varray.c (varray_clear): New.\n+\t* cselib.c (reg_values_old): New.\n+\t(used_regs_old): New.\n+\t(cselib_init): Use cached varrays if available to avoid\n+\tgenerating large amounts of garbage.\n+\t(cselib_finish): Don't throw away old varrays.\n+\n+\t* final.c (insn_addresses_): Move out of ifdef.\n+\n+\t* varray.c (uses_ggc): Make more varray kinds GCable.\n+\t* varray.h (union varray_data_tag): Let gengtype see\n+\tfields 'generic' and 'te'.\n+\t* reg-stack.c: Include gt-reg-stack.h, ggc.h.\n+\t(stack_regs_mentioned_data): Move out of ifdef; mark with gengtype.\n+\t(reg_to_stack): Don't call VARRAY_FREE.\n+\t* insn-addr.h (INSN_ADDRESSES_FREE): Don't use VARRAY_FREE.\n+\t(insn_addresses_): Use gengtype to mark.\n+\t* gengtype.c (write_gc_structure_fields): Handle arrays of generic\n+\tpointers; handle generic pointers in unused union fields.\n+\t(get_output_file_with_visibility): Include cselib.h,\n+\tinsn-addr.h in gtype-desc.c.\n+\t* function.c (prologue): Use gengtype to mark.\n+\t(epilogue): Likewise.\n+\t(sibcall_epilogue): Likewise.\n+\t* dependence.c: Include gt-dependence.h, ggc.h.\n+\t(struct def_use): Use gengtype to mark.\n+\t(struct loop): Likewise.\n+\t(struct induction): Likewise.\n+\t(struct dependence): Likewise.\n+\t(def_use_chain): Likewise.\n+\t(dep_chain): Likewise.\n+\t(loop_chain): Likewise.\n+\t(induction_chain): Likewise.\n+\t(init_dependence_analysis): Don't free anything, just clear pointers.\n+\t(build_def_use): Use GGC to allocate def_use.\n+\t(add_loop): Use GGC to allocate loop.\n+\t(find_induction_variable): Use GGC to allocate induction.\n+\t(check_node_dependence): Use GGC to allocate induction, dependence.\n+\t(dump_node_dependence): Don't free varrays.\n+\t(end_dependence_analysis): Likewise.\n+\t* cselib.h (struct cselib_val_struct): Use gengtype to mark.\n+\t(struct elt_loc_list): Likewise.\n+\t(struct elt_list): Likewise.\n+\t* cselib.c: Don't include obstack.h.\n+\t(hash_table): Use gengtype to mark.\n+\t(reg_values): Use gengtype to mark.\n+\t(used_regs): Use gengtype to mark.\n+\t(cselib_obstack): Delete.\n+\t(cselib_startobj): Delete.\n+\t(empty_vals): Mark as deletable.\n+\t(empty_elt_lists): Mark as deletable.\n+\t(empty_elt_loc_lists): Mark as deletable.\n+\t(new_elt_list): Use GGC to allocate struct elt_list.\n+\t(new_elt_loc_list): Use GGC to allocate struct elt_loc_list.\n+\t(clear_table): Don't delete obstack; don't unnecessarily clear\n+\tdeletable variables.\n+\t(new_cselib_val): Use GGC to allocate struct cselib_val.\n+\t(cselib_init): Don't set up obstacks.  Use GGC to allocate\n+\thash table.\n+\t(cselib_finish): Just clear variables, don't free anything.\n+\t* Makefile.in (cselib.o): Remove dependency on $(OBSTACK_H).\n+\t(reg-stack.o): Add dependency on gt-reg-stack.h, $(GGC_H).\n+\t(dependence.o): Add dependency on gt-dependence.h, $(GGC_H).\n+\t(GTFILES): Add insn-addr.h, cselib.h, dependence.c, reg-stack.c.\n+\t(gt-reg-stack.h): New rule.\n+\t(gt-dependence.h): New rule.\n+\t(gtype-desc.o): Add cselib.h, insn-addr.h.\n+\n+\t* varray.c: Use only necessary headers.\n+\t(element_size): New.\n+\t(uses_ggc): New.\n+\t(varray_init): Take type, not size.  Use GGC if appropriate.\n+\t(varray_grow): Update for change to struct varray_head_tag.\n+\tUse GGC if appropriate.\n+\t* varray.h (struct const_equiv_data): Use gengtype.\n+\t(enum varray_data_enum): New.\n+\t(union varray_data_tag): Use gengtype.\n+\t(struct varray_head_tag): Use gengtype.  Replace size field with\n+\tenum varray_data_enum.\n+\t(varray_init): Update prototype.\n+\t(VARRAY_SCHED_INIT): Delete.\n+\t(VARRAY_*_INIT): Update for change to varray_init.\n+\t(VARRAY_SCHED): Delete.\n+\t(VARRAY_PUSH_SCHED): Delete.\n+\t(VARRAY_TOP_SCHED): Delete.\n+\t* tree.h: Update for change to length specifier.\n+\t* tree-inline.c (optimize_inline_calls): Don't use VARRAY_FREE.\n+\t(clone_body): Likewise.\n+\t* ssa.h (ssa_definition): Use gengtype to mark.\n+\t* ssa.c (convert_from_ssa): Don't use VARRAY_FREE.\n+\t* ssa-dce.c (ssa_eliminate_dead_code): Don't use VARRAY_FREE.\n+\t* rtl.h (struct rtvec_def): Update for change to length specifier.\n+\t* integrate.c (expand_inline_function): Don't use VARRAY_FREE.\n+\t(struct initial_value_struct): Update for change to length specifier.\n+\t* ggc.h (ggc_add_rtx_varray_root): Delete prototype.\n+\t(ggc_add_tree_varray_root): Delete prototype.\n+\t(ggc_mark_rtx_varray): Delete prototype.\n+\t(ggc_mark_tree_varray): Delete prototype.\n+\t* ggc-common.c (ggc_add_rtx_varray_root): Delete.\n+\t(ggc_add_tree_varray_root): Delete.\n+\t(ggc_mark_rtx_varray): Delete.\n+\t(ggc_mark_tree_varray): Delete.\n+\t(ggc_mark_rtx_varray_ptr): Delete.\n+\t(ggc_mark_tree_varray_ptr): Delete.\n+\t* gengtype.h (enum typekind): Remove TYPE_VARRAY.\n+\t(create_varray): Delete prototype.\n+\t* gengtype.c (varrays): Delete.\n+\t(create_varray): Delete.\n+\t(adjust_field_type): Detect array of string pointers.\n+\t(process_gc_options): Remove code to handle varray_type option.\n+\t(set_gc_used_type): Remove TYPE_VARRAY case.\n+\t(output_escaped_param): New.\n+\t(write_gc_structure_fields): Use output_escaped_param on all\n+\tparameters.  Handle 'skip' with 'use_param' option.  Handle\n+\tarrays of strings.  Remove TYPE_VARRAY handling.\n+\t(write_gc_roots): Use boolean to detect 'length' option.\n+\t* gengtype-yacc.y (VARRAY_TYPE): Delete token.\n+\t(struct_fields): Call adjust_field_type on array fields.\n+\t(type): Remove VARRAY_TYPE case.\n+\t(type_option): Likewise.\n+\t* gengtype-lex.l: Don't consider varray_type a keyword.\n+\t* function.h: Update for change to length specifier.\n+\t(free_eh_status): Delete prototype.\n+\t* function.c (free_after_compilation): Don't call free_eh_status.\n+\t(reorder_blocks): Don't use VARRAY_FREE.\n+\t* except.c (struct eh_status): Update for change to length specifier.\n+\tremove varray_type specifier.\n+\t(free_eh_status): Delete.\n+\t* dwarf2out.c: Include gt-dwarf2out.h.\n+\t(used_rtx_varray): Use gengtype to mark, move\n+\toutside ifdefs.\n+\t(incomplete_types): Likewise.\n+\t(decl_scope_table): Likewise.\n+\t(dwarf2out_init): Don't call ggc_add_tree_varray_root.\t\n+\t* cfglayout.c (scope_to_insns_finalize): Don't use VARRAY_FREE.\n+\t* c-tree.h (struct lang_type): Update for change to length specifier.\n+\t* c-parse.in (yylexstring): Don't use VARRAY_FREE.\n+\t* c-objc-common.c: Include gt-c-objc-common.h.\n+\t(deferred_fns): Mark for gengtype.\n+\t(c_objc_common_init): Don't call ggc_add_tree_varray_root.\n+\t(expand_deferred_fns): Just set deferred_fns to 0 to free it.\n+\t* Makefile.in (c-objc-common.o): Add gt-c-objc-common.h.\n+\t(gtype-desc.o): Update dependencies.\n+\t(dwarf2out.o): Add gt-dwarf2out.h.\n+\t(varray.o): Update dependencies.\n+\t(GTFILES): Add varray.h, ssa.h, dwarf2out.c, c-objc-common.c.\n+\t(gt-c-objc-common.h): New rule.\n+\t(gt-dwarf2out.h): New rule.\n+\t* objc/objc-act.c (build_objc_string_object): Don't use VARRAY_FREE.\n+\n+\t* doc/gty.texi (GTY Options): Correct spelling.\n+\t(GGC Roots): Likewise.\n+\t* Makefile.in (TEXI_CPP_FILES): New.\n+\t(TEXI_GCC_FILES): New.\n+\t(TEXI_GCCINT_FILES): New.\n+\t(TEXI_CPPINT_FILES): New.\n+\t($(docdir)/cpp.info): Use new macros.\n+\t($(docdir)/gcc.info): Likewise.\n+\t($(docdir)/gccint.info): Likewise.\n+\t($(docdir)/cppinternals.info): Likewise.\n+\t(cpp.dvi): Likewise.\n+\t(gcc.dvi): Likewise.\n+\t(gccint.dvi): Likewise.\n+\t(cppinternals.dvi): Likewise.\n+\n+\t* Makefile.in ($(docdir)/gccint.info): Depend on gty.texi.\n+\t* doc/gccint.texi (Top): Include gty.texi.\n+\t* doc/gty.texi: New file.\n+\n+\t* bitmap.c: Include ggc.h, gt-bitmap.h.\n+\t(bitmap_ggc_free): New.\n+\t(bitmap_elem_to_freelist): New.\n+\t(bitmap_element_free): Use bitmap_elem_to_freelist.\n+\t(bitmap_element_allocate): Allow use of GGC.\n+\t(bitmap_clear): Use bitmap_elem_to_freelist.\n+\t(bitmap_copy): Update for change to bitmap_element_allocate.\n+\t(bitmap_set_bit): Likewise.\n+\t(bitmap_operation): Update for changes elsewhere.\n+\t(bitmap_initialize): Allow to create bitmaps that will use GGC.\n+\t* bitmap.h (struct bitmap_element_def): Use gengtype.\n+\t(struct bitmap_head_def): Likewise.  Also add 'using_obstack' field.\n+\t(bitmap_initialize): Add extra parameter.\n+\t(BITMAP_OBSTACK_ALLOC): Update for change to bitmap_initialize.\n+\t(BITMAP_ALLOCA): Delete.\n+\t(BITMAP_XMALLOC): Update for change to bitmap_initialize.\n+\t(BITMAP_GGC_ALLOC): New.\n+\t* Makefile.in (gtype-desc.o): Add bitmap.h.\n+\t(bitmap.o): Add gt-bitmap.h, $(GGC_H).\n+\t(GTFILES): Add bitmap.c.\n+\t(gt-bitmap.h): New rule.\n+\t($(HOST_PREFIX_1)bitmap.o): Add gt-bitmap.h.\n+\t* basic-block.h: Update for changes to bitmap_initialize.\n+\t* except.c (exception_handler_label_map): Move into...\n+\t(struct eh_status): Here.\n+\t(struct eh_region): Make 'aka' GCable.\n+\t(free_eh_status): Don't need to specially handle\n+\texception_handler_label_map.\n+\t(add_ehl_entry): Update for changes to exception_handler_label_map.\n+\t(find_exception_handler_labels): Likewise.\n+\t(remove_exception_handler_label): Likewise.\n+\t(maybe_remove_eh_handler): Likewise.\n+\t(for_each_eh_label): Likewise.\n+\t(remove_eh_handler): Allocate 'aka' using GGC.\n+\t* gengtype.c (get_output_file_with_visibility): Add bitmap.h\n+\tto list of includes.\n+\n+\t* gengtype.c (write_gc_marker_routine_for_structure): Name\n+\tthe routines 'gt_ggc_mx_*' instead of 'gt_ggc_m_*'.  \n+\t(write_gc_types): Arrange for the tests with NULL to be inlined.\n+\t(write_gc_roots): Update uses of procedure pointers.\n+\t* ggc-common.c (gt_ggc_mx_rtx_def): Rename from gt_ggc_m_rtx_def.\n+\n+\t* Makefile.in (explow.o): Add dependency on gt-explow.h.\n+\t(sdbout.o): Add dependency on gt-sdbout.h.\n+\n+\t* emit-rtl.c (const_int_htab): Use gengtype to clear unused entries.\n+\t(mem_attrs_htab): Likewise.\n+\t(init_emit_once): Don't call ggc_add_deletable_htab.\n+\t* fold-const.c (size_htab): Use gengtype to clear unused entries.\n+\t(size_int_type_wide): Don't call ggc_add_deletable_htab.\n+\t* gengtype.c (finish_root_table): Add LASTNAME and TNAME\n+\tparameters, use them, change callers.\n+\t(write_gc_root): Add IF_MARKED parameter, use it, change callers.\n+\t(write_gc_roots): Handle 'if_marked' option.\n+\t(main): Don't need to call set_gc_used_type any more.\n+\t* ggc.h (ggc_htab_marked_p): Delete.\n+\t(ggc_htab_mark): Delete.\n+\t(struct ggc_cache_tab): New.\n+\t(gt_ggc_cache_rtab): New declaration.\n+\t* ggc-common.c (struct d_htab_root): Delete.\n+\t(d_htab_roots): Delete.\n+\t(ggc_add_deletable_htab): Delete.\n+\t(ggc_htab_delete): Handle new htab-deleting mechanism.\n+\t(ggc_mark_roots): Use new htab-deleting mechanism.\n+\t* tree.c (type_hash_table): Use gengtype to clear unused entries.\n+\tMake static.\n+\t(init_obstacks): Don't call ggc_add_deletable_htab.\n+\n+\t* objc/objc-act.h (struct hashed_attribute): Use gengtype.\n+\t(struct hashed_entry): Likewise.\n+\t(nst_method_hash_list): Likewise.\n+\t(cls_method_hash_list): Likewise.\n+\t(HASH_ALLOC_LIST_SIZE): Delete.\n+\t(ATTR_ALLOC_LIST_SIZE): Delete.\n+\t* objc/objc-act.c (hash_init): Use ggc to allocate\n+\tnst_method_hash_list, cls_method_hash_list.\n+\t(hash_enter): Use ggc to allocate; allocate one entry at a time.\n+\t(hash_add_attr): Likewise.\n+\t(ggc_mark_hash_table): Delete.\n+\t(objc_act_parse_init): Delete.\n+\t(objc_init): Delete reference to objc_act_parse_init.\n+\t* tlink.c: Replace hash.h with hashtab.h.  Explicitly include\n+\tobstack.h.  Replace references to 'struct hash_table' with htab_t.\n+\t(struct symbol_hash_entry): Replace hash header with key field.\n+\t(struct file_hash_entry): Replace hash header with key field.\n+\t(struct demangled_hash_entry): Replace hash header with key field.\n+\t(hash_string_eq): New.\n+\t(hash_string_hash): New.\n+\t(symbol_hash_newfunc): Delete.\n+\t(symbol_hash_lookup): Modify to use htab_t.\n+\t(file_hash_newfunc): Delete.\n+\t(file_hash_lookup): Modify to use htab_t.\n+\t(demangled_hash_newfunc): Delete.\n+\t(demangled_hash_lookup): Modify to use htab_t.\n+\t(tlink_init): Modify to use htab_t.\n+\t* hash.h: Delete.\n+\t* hash.c: Delete.\n+\t* ggc.h: Delete forward structure declarations.\n+\tDelete prototypes for deleted functions.\n+\t* ggc-common.c: Don't include hash.h.\n+\t(ggc_add_tree_hash_table_root): Delete.\n+\t(ggc_mark_tree_hash_table_entry): Delete.\n+\t(ggc_mark_tree_hash_table): Delete.\n+\t(ggc_mark_tree_hash_table_ptr): Delete.\n+\t* gengtype.c (write_gc_structure_fields): Allow param_is option.\n+\t(write_gc_marker_routine_for_structure): Use visibility of\n+\tthe parameter if there is one.\n+\t* function.c: Replace hash.h with hashtab.h.  Replace references\n+\tto 'struct hash_table *' with htab_t.\n+\t(struct insns_for_mem_entry): Include a plain key.\n+\t(fixup_var_refs_insns_with_hash): Update to use htab_t.\n+\t(insns_for_mem_newfunc): Delete.\n+\t(insns_for_mem_hash): Update to use htab_t.\n+\t(insns_for_mem_comp): Likewise.\n+\t(insns_for_mem_walk): Likewise.\n+\t* c-lang.c: Include ggc.h.\n+\t* Makefile.in (OBJS): Remove hash.o.\n+\t(c-lang.o): Add GGC_H.\n+\t(COLLECT2_OBJS): Remove hash.o.\n+\t(tlink.o): Remove hash.h, add HASHTAB_H and OBSTACK_H.\n+\t(ggc-common.o): Remove hash.h.\n+\t(function.o): Remove hash.h, add HASHTAB_H.\n+\t(genautomata.o): Remove hash.h, add HASHTAB_H.\n+\n+\t* varasm.c (mark_const_str_htab_1): Delete.\n+\t(mark_const_str_htab): Delete.\n+\t(const_str_htab_del): Delete.\n+\t(const_str_htab): Use gengtype to mark.\n+\t(init_varasm_once): Use gengtype to mark hashtables.  Use GC to\n+\tallocate them.\n+\t* tree.c (mark_tree_hashtable_entry): Delete.\n+\t(mark_tree_hashtable): Delete.\n+\t* tree.h (mark_tree_hashtable): Delete prototype.\n+\t* ggc.h (ggc_test_and_set_mark): Treat (void *)1 like NULL.\n+\t(ggc_mark): Likewise.\n+\t(ggc_calloc): New.\n+\t(htab_create_ggc): New.\n+\t* ggc-common.c (ggc_calloc): New.\n+\t* gengtype.h (enum typekind): Add TYPE_PARAM_STRUCT.\n+\t(struct type): Add param_struct structure.\n+\t* gengtype.c (param_structs): New.\n+\t(adjust_field_type): Handle param_is option.\n+\t(set_gc_used_type): Handle TYPE_PARAM_STRUCT.\n+\t(get_output_file_with_visibility): Include hashtab.h in gtype-desc.c.\n+\t(write_gc_structure_fields): Add new PARAM parameter.  Update\n+\tcallers.  Handle use_param option.  Handle TYPE_PARAM_STRUCT.\n+\t(write_gc_marker_routine_for_structure): Add new PARAM parameter.\n+\tUse it to generate function name.  Update callers.\n+\t(write_gc_types): Add new PARAM_STRUCTS parameter.  Update callers.\n+\tProcess them.\n+\t(write_gc_roots): Handle TYPE_PARAM_STRUCT.  Allow param_is\n+\toption.\n+\t(main): Define PTR as pointer-to-scalar.  Don't specially\n+\tmark deferred_string or ehl_map_entry.\n+\t* gengtype-yacc.y (PARAM_IS): Add new token.\n+\t(externstatic): Use adjust_field_type.\n+\t(type_option): Add PARAM_IS.\n+\t* gengtype-lex.l: Add rule for typedef of function pointers.\n+\tAdd rule for PARAM_IS.\n+\t(IWORD): Add size_t.\n+\t* except.c (exception_handler_label_map): Use gengtype to mark.\n+\t(type_to_runtime_map): Likewise.\n+\t(mark_ehl_map_entry): Delete.\n+\t(mark_ehl_map): Delete.\n+\t(init_eh): Use gengtype for roots; use GC to allocate hash tables.\n+\t(t2r_mark_1): Delete.\n+\t(t2r_mark): Delete.\n+\t* Makefile.in (gtype-desc.o): Correct dependencies.\n+\t(GTFILES): Add hashtab.h.\n+\t(genautomata.o): Actually uses hashtab.h.\n+\n+\t* Makefile.in (stringpool.o): Add $(GGC_H).\n+\t(dwarf2asm.o): Likewise.\n+\t(GTFILES): Add hashtable.h.\n+\t* c-common.h (struct c_common_identifier): Use gengtype.\n+\t* c-decl.h (c_mark_tree): Delete.\n+\t* c-lang.c (LANG_HOOKS_MARK_TREE): Delete.\n+\t* c-tree.h (struct lang_identifier): Use gengtype.\n+\t(union lang_tree_node): New.\n+\t(c_mark_tree): Delete prototype.\n+\t* dwarf2out.c [!DWARF2_DEBUGGING_INFO]: Define dummy \n+\tdwarf2_debug_hooks.\n+\t* gengtype-lex.l (IWORD): Allow 'bool'.\n+\t(ptr_alias): Match.\n+\t* gengtype-yacc.y (ALIAS): New token.\n+\t(type_option): New rule.\n+\t(option): Use type_option.\n+\t* gengtype.c (process_gc_options): New.\n+\t(set_gc_used_type): Use it.\n+\t(write_gc_structure_fields): Add 'bitmap' parameter, change callers.\n+\tAdd new variable 't' to hold the type of the field being processed.\n+\tAdd more error checking.  Use UNION_P when looking at 'desc' option.\n+\tHandle language-specific structures containing other\n+\tlanguage-specific structures.\n+\t(write_gc_types): Handle 'ptr_alias' option.\n+\t(main): Don't need to specially output lang_type, lang_decl, lang_id2.\n+\t* ggc-common.c (ggc_pending_trees): Delete.\n+\t(ggc_mark_roots): Don't manipulate ggc_pending_trees.\n+\t(ggc_mark_trees): Delete.\n+\t(gt_ggc_m_tree_node): Delete.\n+\t* ggc.h (ggc_pending_trees): Delete.\n+\t(ggc_mark_tree): Make alias of gt_ggc_m_tree_node.\n+\t* hashtable.h (ht_identifier): Use gengtype.\n+\t* langhooks-def.h (LANG_HOOKS_MARK_TREE): Delete.\n+\t* langhooks.h (struct lang_hooks): Delete mark_tree.\n+\t* sdbout.c [! SDB_DEBUGGING_INFO]: Define dummy sdb_debug_hooks\n+\tanyway.\n+\t* system.h: Poison LANG_HOOKS_MARK_TREE.\n+\t* tree.c (tree_node_structure): New.\n+\t* tree.h (struct tree_common): Use gengtype.\n+\t(struct tree_int_cst): Likewise.\n+\t(struct tree_real_cst): Likewise.\n+\t(struct tree_string): Likewise.\n+\t(struct tree_complex): Likewise.\n+\t(struct tree_vector): Likewise.\n+\t(struct tree_identifier): Likewise.\n+\t(struct tree_list): Likewise.\n+\t(struct tree_vec): Likewise.\n+\t(struct tree_exp): Likewise.\n+\t(struct tree_block): Likewise.\n+\t(struct tree_type): Likewise.\n+\t(struct tree_decl): Likewise.\n+\t(enum tree_structure_enum): New.\n+\t(union tree_node): Use gengtype, with an alias.\n+\t(tree_node_structure): Prototype.\n+\t* objc/objc-lang.c (LANG_HOOKS_MARK_TREE): Delete.\n+\n+\tMerge to tag pch-merge-20020430.  The LANG_HOOKS_FUNCTION_MARK\n+\tmacro was deleted.  The LANG_HOOKS_FUNCTION_FREE macro was renamed\n+\tto LANG_HOOKS_FUNCTION_FINAL.\n+\t* Makefile.in (GTFILES): Add bitmap.h.\n+\t* except.c (struct eh_region): Mark field 'aka' to be skipped.\n+\n+\t* config/alpha/alpha.c [TARGET_ABI_UNICOSMK]\n+\t(alpha_init_machine_status): Give proper type.\n+\t* Makefile.in (c-lang.o): Depend on gtype-c.h.\n+\t(optabs.o): Depend on gt-optabs.h.\n+\t(GTFILES): Add optabs.o.\n+\t(gt-optabs.h): Add rule.\n+\t* optabs.c: Include gt-optabs.h.\n+\n+\t* gengtype.c (set_gc_used_type): Correct some errors in last change.\n+\t(write_gc_structure_fields): If a field which should be NULL is\n+\tnot, abort.\n+\t* c-pragma.c: Move struct align_stack and variable alignment_stack\n+\tout from the ifdef.\n+\n+\t* config/xtensa/t-xtensa: Add dependencies for gt-xtensa.h.\n+\t* config/xtensa/xtensa.c: Include gt-cris.h.\n+\t(struct machine_function): Use gengtype\tto mark.\n+\t* config/mmix/mmix.h (struct machine_function): Use gengtype\n+\tto mark.\n+\t* config/cris/t-cris: Add dependencies for gt-cris.h.\n+\t* config/cris/cris.c: Include gt-cris.h.\n+\t(struct machine_function): Use gengtype\tto mark.\n+\t* config/rs6000/rs6000.h (struct machine_function): Use gengtype\n+\tto mark.\n+\t* doc/tm.texi (Per-Function Data): Delete references to\n+\tmark_machine_status.\n+\t* config/ia64/ia64.c (ia64_override_options): Don't set\n+\tmark_machine_status.\n+\t* config/i386/i386.c (override_options): Likewise.\n+\t* config/d30v/d30v.c (d30v_init_expanders): Likewise.\n+\t* config/arm/arm.c (arm_init_expanders): Likewise.\n+\t* config/alpha/alpha.c (override_options): Likewise.\n+\t* gengtype.h (enum gc_used_enum): Add GC_MAYBE_POINTED_TO. \n+\t* gengtype.c (set_gc_used_type): Handle 'maybe_null' option.\n+\t(write_gc_structure_fields): Don't handle 'really' option.\n+\tHandle 'maybe_null' option.\n+\t(write_gc_types): Handle 'maybe_null' option.\n+\t* function.h (struct function): Don't use \"really\".\n+\t(mark_machine_status): Delete declaration.\n+\t(mark_lang_status): Delete declaration.\n+\t(gt_ggc_mr_machine_function): Delete prototype.\n+\t(gt_ggc_mr_language_function): Delete prototype.\n+\t* function.c (mark_machine_status): Delete.\n+\t(mark_lang_status): Delete.\n+\t(gt_ggc_mr_machine_function): Delete.\n+\t(gt_ggc_mr_language_function): Delete.\n+\t* c-tree.h (mark_c_function_context): Delete prototype.\n+\t* c-objc-common.c (c_objc_common_init): Don't set mark_lang_status.\n+\t* c-decl.c (struct language_function): Rename from struct\n+\tc_language_function.  Update uses.  Use gengtype to mark.\n+\t(mark_c_function_context): Delete.\n+\t* c-common.h (struct c_language_function): Rename from struct\n+\tlanguage_function.\n+\t(mark_stmt_tree): Delete prototype.\n+\t(c_mark_lang_decl): Delete prototype.\n+\t(mark_c_language_function): Delete prototype.\n+\t* c-common.c (mark_stmt_tree): Delete.\n+\t(c_mark_lang_decl): Delete.\n+\t(mark_c_language_function): Delete.\n+\n+\t* gengtype.h (enum typekind): Add TYPE_LANG_STRUCT.\n+\t(lang_bitmap): New typedef.  Use where appropriate.\n+\t(struct type): Add gc_used field, lang_struct field.\n+\t(UNION_P): New macro.\n+\t(new_structure): New prototype.\n+\t(find_structure): Remove 'pos' parameter.  Change all callers.\n+\t* gengtype-lex.l: Update for changes to find_structure.\n+\t* gengtype-yacc.y (typedef_struct): Use new_structure.\n+\t(yacc_ids): Suppress warning.\n+\t(type): Use new_structure.\n+\t* gengtype.c (string_type): Update for changes to struct type.\n+\t(find_structure): Just find a structure, don't worry about\n+\tcreating one.\n+\t(new_structure): New.\n+\t(note_yacc_type): Use new_structure.\n+\t(set_gc_used_type): New.\n+\t(set_gc_used): New.\n+\t(write_gc_structure_fields): Allow for pointers to TYPE_LANG_STRUCT.\n+\t(write_gc_types): Handle TYPE_LANG_STRUCT.\n+\t(write_gc_marker_routine_for_structure): New.\n+\t(main): Call set_gc_used.  Add some calls to set_gc_used_type\n+\tfor places where GCC doesn't use gengtype properly yet.\n+\t* ggc.h (gt_ggc_m_rtx_def): Don't prototype.\n+\t(gt_ggc_m_tree_node): Likewise.\n+\n+\t* varasm.c (copy_constant): Call expand_constant if we hit\n+\tsomething we can't recognise.\n+\n+\t* ggc-common.c (ggc_mark_rtvec_children): Delete.\n+\t(ggc_mark_rtx_children): Use generic name for ggc_mark_rtvec.\n+\t(lang_mark_false_label_stack): Delete.\n+\t* rtl.h (struct rtvec_def): Use gengtype to mark.\n+\t* ggc.h (ggc_mark_rtvec): Delete.\n+\t(gt_ggc_m_rtvec_def): Delete.\n+\t(ggc_mark_nonnull_tree): Delete.\n+\t(ggc_mark_rtvec_children): Delete prototype.\n+\t(lang_mark_false_label_stack): Delete declaration.\n+\n+\t* gengtype.h (note_yacc_type): Add prototype.\n+\t* gengtype.c (note_yacc_type): New function.\n+\t* gengtype-lex.l: Add lexer support for yacc files.\n+\t* gengtype-yacc.y (start): Extract union from yacc files.\n+\t(yacc_union): New rule.\n+\t(yacc_typematch): New rule.\n+\t(yacc_ids): New rule.\n+\t(enum_items): Tweak for efficiency.\n+\t(optionseq): Likewise.\n+\n+\t* c-common.h (struct language_function): Use gengtype.\n+\t(struct c_lang_decl): Likewise.\n+\t* c-tree.h (struct lang_decl): Likewise.\n+\t(struct lang_type): Likewise.\n+\t* c-decl.c (lang_mark_tree): Use generated marker routines to mark\n+\ttree language substructures.\n+\n+\t* stringpool.c (mark_ident): Replace ggc_mark_nonnull_tree with\n+\tggc_mark_tree.\n+\t* dwarf2asm.c (mark_indirect_pool_entry): Likewise.\n+\n+\t* varasm.c (struct rtx_const): Remove 'skip' tags for scalar arrays.\n+\n+\t* stmt.c (struct nesting): Add discriminator.  Use gengtype to\n+\tmark. Remove 'data.block.cleanup_ptr' field.\n+\t(struct stmt_status): Use usual technique to mark struct nesting.\n+\t(gt_ggc_mr_nesting_cond): Delete.\n+\t(gt_ggc_mr_nesting_loop): Delete.\n+\t(gt_ggc_mr_nesting_block): Delete.\n+\t(gt_ggc_mr_nesting_case_stmt): Delete.\n+\t(expand_start_cond): Set discriminator.\n+\t(expand_start_loop): Likewise.\n+\t(expand_start_null_loop): Likewise.\n+\t(expand_start_bindings_and_block): Set discriminator.  Don't set\n+\tdeleted fields.\n+\t(expand_decl_cleanup): Replace 'cleanup_ptr' with\n+\t&thisblock->data.block.cleanups.\n+\t(expand_start_case): Set discriminator.\n+\t(expand_start_case_dummy): Set discriminator.\n+\n+\t* ggc-callbacks.c: Remove.\n+\n+\t* gengtype.h (struct type): Add 'u.s.bitmap' field.\n+\t(find_structure): Add 'pos' parameter.\n+\t* gengtype-lex.l: Update callers to find_structure.\n+\t* gengtype-yacc.y: Likewise.\n+\t* gengtype.c (find_structure): Allow for structures to be defined\n+\tin multiple language backends.\n+\t(get_output_file_with_visibility): Include debug.h in gtype-desc.c.\n+\t(counter): Rename to gc_counter.\n+\t(write_gc_structure_fields): Fail when writing out fields for\n+\tan incomplete structure.  Ignore arrays of scalars.  Handle\n+\t'tree_vec' special.\n+\t(write_gc_types): Reset counter for each procedure written.\n+\n+\t* stmt.c (add_case_node): Use GGC to allocate struct case_node.\n+\t(free_case_nodes): Delete.\n+\t(expand_end_case_type): Delete call to free_case_nodes.\n+\n+\t* Makefile.in (cselib.o): Include gt-<filename>.h.\n+\t(gcse.o): Likewise.\n+\t(profile.o): Likewise.\n+\t(alias.o): Likewise.\n+\t(GTFILES): Add alias.c, cselib.c, gcse.c, profile.c, and\n+\talphabetize backend files.\n+\t(gt-alias.h, gt-cselib.h, gt-gcse.h, gt-profile.h): New rules.\n+\t* alias.c: Use gengtype for roots.\n+\t* c-common.h (struct stmt_tree_s): Use gengtype.\n+\t* c-decl.c: Use gengtype for roots.\n+\t* cselib.c: Use gengtype for roots.\n+\t* expr.c: Use gengtype for roots.\n+\t* fold-const.c: Use gengtype for roots.\n+\t* gcse.c: Use gengtype for roots.\n+\t* gengtype-lex.l: Handle typedefs of function types.\n+\tAllow for empty array bounds.\n+\tAllow processing to stop on initialisers.\n+\t* gengtype-yacc.y (externstatic): Stop processing on initialisers.\n+\t(semiequal): New rule.\n+\t* gengtype.c (create_file): Tidy output files.\n+\t(get_output_file_with_visibility): Fix paren warning.  Fix bug\n+\tinvolving multiple input files mapping to one output file.\n+\t(write_gc_structure_fields): Skip arrays of scalars.\n+\t(write_gc_types): Tidy output files.\n+\t(write_gc_root): New function.\n+\t(write_gc_roots): Fix bugs, add support for roots that are\n+\tstructures.\n+\t* ggc-common.c (ggc_mark_rtx_ptr): Delete.\n+\t(ggc_mark_tree_ptr): Delete.\n+\t(ggc_add_rtx_root): Delete.\n+\t(ggc_add_tree_root): Delete.\n+\t(ggc_del_root): Delete.\n+\t* integrate.c (get_func_hard_reg_initial_val): Use ggc_alloc to\n+\tallocate struct initial_value_struct.\n+\t* profile.c: Use gengtype for roots.\n+\t* sdbout.c: Use gengtype for roots.\n+\t* varasm.c (mark_weak_decls): Delete unused prototype.\n+\t(mark_const_hash_entry): Delete unused function.\n+\t* config/darwin-protos.h: Use gengtype for roots.\n+\t(machopic_add_gc_roots): Delete.\n+\t* config/arm/arm.c: Use gengtype for roots.\n+\t* config/arm/arm.h: Use gengtype for roots.\n+\t* config/c4x/c4x-protos.h: Use gengtype for roots.\n+\t* config/c4x/c4x.c (c4x_add_gc_roots): Delete.\n+\t* config/d30v/d30v-protos.h: Use gengtype for roots.\n+\t* config/d30v/d30v.c (d30v_add_gc_roots): Delete.\n+\t* config/dsp16xx/dsp16xx.c (override_options): Use gengtype for roots.\n+\t* config/dsp16xx/dsp16xx.h: Use gengtype for roots.\n+\t* config/ia64/ia64-protos.h: Use gengtype for roots.\n+\t* config/ia64/ia64.c (ia64_add_gc_roots): Delete.\n+\t* config/m68hc11/m68hc11-protos.h: Use gengtype for roots.\n+\t* config/m68hc11/m68hc11.c (z_reg): Make global.\n+\t(z_reg_qi): Make global.\n+\t(m68hc11_add_gc_roots): Delete.\n+\t* config/mcore/mcore-protos.h: Use gengtype for roots.\n+\t* config/mcore/mcore.c (mcore_add_gc_roots): Delete.\n+\t* config/mips/mips.c (mips_add_gc_roots): Delete.\n+\t* config/mips/mips.h: Use gengtype for roots.\n+\t* config/mmix/mmix.c (override_options): Use gengtype for roots.\n+\t* config/mmix/mmix.h: Use gengtype for roots.\n+\t* config/mn10200/mn10200.c (asm_file_start): Use gengtype for roots.\n+\t* config/mn10200/mn10200.h: Use gengtype for roots.\n+\t* config/pa/pa.c: Use gengtype for roots, marking.\n+\t(struct deferred_plabel): Use GGC, gengtype.\n+\t(pa_add_gc_roots): Delete.\n+\t(mark_deferred_plabels): Delete.\n+\t* config/pj/pj-protos.h: Use gengtype for roots.\n+\t* config/pj/pj.h (OVERRIDE_OPTIONS): Don't define.\n+\t* config/rs6000/rs6000.c: Use gengtype for roots.  Don't call\n+\tmachopic_add_gc_roots.\n+\t* config/rs6000/rs6000.h: Use gengtype for roots.\n+\t* config/rs6000/t-darwin (darwin.o): Add dependency on gt-darwin.h.\n+\t(gt-darwin.h): Add rule.\n+\t* config/sh/sh.c: Use gengtype for roots.\n+\t* config/sh/t-sh ($(out_object_file)): Add dependency on gt-sh.h.\n+\t(gt-sh.h): Add rule.\n+\t* config/sparc/sparc.c: Use gengtype for roots.\n+\t(sparc_add_gc_roots): Delete.\n+\t(struct ultrasparc_pipeline_state): Use GGC, gengtype.\n+\t(mark_ultrasparc_pipeline_state): Delete.\n+\t* config/sparc/sparc.h: Use gengtype for roots.\n+\n+\t* Makefile.in (c-parse.o): Update dependencies.\n+\t(c-common.o): Likewise.\n+\t(GTFILES): Add c-common.h, c-tree.h, c-common.c, c-parse.in.\n+\tAdd dependencies for the files they generate.\n+\t* c-common.c: Replace ggc_add_* uses with GTY annotations.\n+\t* c-common.h: Likewise.\n+\t* c-decl.c: Likewise.\n+\t(gt_ggc_mp_binding_level): Delete.\n+\t* c-lang.c: Include gtype-c.h.\n+\t* c-parse.in: Replace ggc_add_* uses with GTY annotations.  Include\n+\tgt-c-parse.h.\n+\t* c-pragma.h: Replace ggc_add_* uses with GTY annotations.\n+\t(gt_ggc_mp_align_stack): Delete.\n+\t* c-tree.h: Replace ggc_add_* uses with GTY annotations.\n+\t* function.c: Replace ggc_add_* uses with GTY annotations.\n+\t(gt_ggc_mp_function): Delete.\n+\t* function.h: Replace ggc_add_* uses with GTY annotations.\n+\t* gengtype.c (lang_names): New.\n+\t(NUM_BASE_FILES): New.\n+\t(open_base_files): Create language base files.\n+\t(startswith): New.\n+\t(get_file_basename): New.\n+\t(get_base_file_bitmap): New.\n+\t(get_output_file_with_visibility): Rename from get_output_file.\n+\tAdd more mappings for various C/Objc filenames.\n+\t(finish_root_table): New.\n+\t(write_gc_roots): Handle dependencies and scoping properly.\n+\t* gengtype.h: Add prototypes for new functions.\n+\t* ggc-common.c (struct deletable_root): Delete.\n+\t(deletables): Delete.\n+\t(ggc_add_deletable_root): Delete.\n+\t(ggc_mark_roots): No need to deal with deleted functionality.\n+\t* ggc.h (ggc_add_deletable_root): Delete prototype.\n+\t* objc/Make-lang.in (objc-act.o): Add gtype-objc.h dependency.\n+\t(gtype-objc.h): Add rule to create.\n+\t* objc/config-lang.in (gtfiles): New.\n+\t* objc/objc-act.c: Allocate imp_list using GGC.  Replace uses of\n+\tggc_add_* with GTY markers.  Include gtype-objc.h.\n+\t(ggc_mark_imp_list): Delete.\n+\t* objc/objc-act.h: Replace uses of ggc_add_* with GTY markers.\n+\t* objc/objc-lang.c: Random Whitespace Change.\n+\n+\t* except.h (exception_handler_labels): Delete.\n+\t(get_exception_handler_labels): New.\n+\t* except.c (exception_handler_labels): Delete.\n+\t(struct eh_status): Add exception_handler_labels field.\n+\t(doing_eh): Don't add exception_handler_labels as root.\n+\t(free_eh_status): Don't need to free exception_handler_labels.\n+\t(get_exception_handler_labels): New.\n+\t(find_exception_handler_labels): Update for move of\n+\texception_handler_labels.\n+\t(remove_exception_handler_label): Likewise.\n+\t* cfgrtl.c (can_delete_label_p): Use get_exception_handler_labels.\n+\t* jump.c (rebuild_jump_labels): Likewise.\n+\t* loop.c (find_and_verify_loops): Likewise.\n+\t* sched-rgn.c (is_cfg_nonregular): Likewise.\n+\n+\t* gengtype.c (write_gc_structure_fields): Handle variable-length\n+\tTYPE_ARRAYs.\n+\n+\t* varasm.c (struct weak_syms): Use GGC, gengtype.\n+\t(mark_weak_decls): Delete.\n+\t(weak_decls): Likewise.\n+\t(add_weak): Likewise.\n+\t(remove_from_pending_weak_list): Likewise.\n+\t(init_varasm_once): Likewise.\n+\n+\t* Makefile.in (gtype-desc.o): Add libfuncs.h dependency.\n+\t(GTFILES): Add tree.h, libfuncs.h, emit-rtl.c, explow.c,\n+\tstor-layout.c, regclass.c, and lists.c.\n+\tAdd dependencies of gt-emit-rtl.h gt-explow.h gt-stor-layout.h\n+\tgt-regclass.h and gt-lists.h on s-gtype.\n+\t* emit-rtl.c: Use gengtype for roots.  Include gt-emit-rtl.h.\n+\t* except.c: Use gengtype for roots.\n+\t* explow.c: Use gengtype for roots.  Include gt-explow.h.\n+\t* expr.h (init_stor_layout_once): Delete prototype.\n+\t* function.c: Use gengtype for roots.\n+\t* gengtype-lex.l: Add ENT_EXTERNSTATIC lexing.\n+\t* gengtype-yacc.y (start): Can also be an externstatic.\n+\t(externstatic): New production.\n+\t(struct_fields): Correct array bounds inversion for 2-d arrays.\n+\t* gengtype.c (variables): New variable.\n+\t(note_variable): New function.\n+\t(get_output_file): Include libfuncs.h into gtype-desc.c.\n+\t(get_output_file_name): New function.\n+\t(write_gc_structure_fields): Suppress warnings.\n+\t(write_gc_types): Make static.\n+\t(put_mangled_filename): New function.\n+\t(write_gc_roots): New function.\n+\t(main): Call write_gc_roots.\n+\t* gengtype.h (note_variable): Prototype.\n+\t(get_output_file_name): Prototype.\n+\t(write_gc_types): Delete prototype.\n+\t* ggc.h: Clean up unnecessary structure predefinitions.\n+\t(struct ggc_root_tab): Define.\n+\t(gt_ggc_m_rtx_def): Make function, not macro.\n+\t(gt_ggc_m_tree_node): Likewise.\n+\t* libfuncs.h: Use gengtype for roots.\n+\t* lists.c: Use gengtype for roots.  Include gt-lists.h.\n+\t(init_EXPR_INSN_LIST_cache): Delete.\n+\t* optabs.c: Use gengtype for roots.\n+\t(gt_ggc_mp_optab): Delete.\n+\t* optabs.h: Use gengtype for roots.\n+\t* regclass.c: Use gengtype for roots.  Include gt-regclass.h.\n+\t* rtl.h: Use gengtype for roots.\n+\t(init_EXPR_INSN_LIST_cache): Delete prototype.\n+\t* stor-layout.c: Use gengtype for roots.\n+\tInclude gt-stor-layout.h.\n+\t(init_stor_layout_once): Delete.\n+\t* toplev.c: Use gengtype for roots.  Delete calls to deleted\n+\troutines.\n+\t* tree.c: Use gengtype for roots.\n+\t* tree.h: Use gengtype for roots.\n+\t* varasm.c: Use gengtype for roots.\n+\t\n+\t* Makefile.in (GTFILES): Add @all_gtfiles@.\n+\t* configure: Regenerate.\n+\t* configure.in: Construct all_gtfiles from the gtfiles definitions\n+\tin config-lang.in.\n+\t* gengtype-yacc.y (type): Warn about duplicate structure names.\n+\t* gengtype.c (get_output_file): Handle .c files in language\n+\tsubdirectories.\n+\n+\t* Makefile.in (GTFILES): Run gengtype on all the config files\n+\tand on the target .c file.\n+\t* except.c (mark_eh_region): Delete.\n+\t(init_eh_for_function): Use GGC on struct eh_status.\n+\t(mark_eh_status): Delete.\n+\t(free_eh_status): Use GGC.\n+\t(expand_eh_region_start): Use GGC to\n+\t(collect_eh_region_array): Allocate last_region_number using GGC.\n+\t(duplicate_eh_region_1): Use GGC to allocate struct eh_region.\n+\t(remove_eh_handler): Let GGC free struct eh_region.\n+\t(add_call_site): Use GGC to reallocate call_site_record array.\n+\t* function.c (init_machine_status): Update calling sequence.\n+\t(mark_machine_status): Likewise.\n+\t(mark_lang_status): Likewise.\n+\t(prepare_function_start): Update init_machine_status call.\n+\t(mark_function_status): Delete.\n+\t(maybe_mark_struct_function): Delete.\n+\t(ggc_mark_struct_function): Delete.\n+\t(gt_ggc_mp_function): New.\n+\t(gt_ggc_mr_machine_function): New.\n+\t(gt_ggc_mr_language_function): New.\n+\t(init_function_once): Use canonical names.\n+\t* function.h (struct function): Use gengtype.\n+\t(init_machine_status): Return the structure.\n+\t(mark_machine_status): Take a 'void *'.\n+\t(mark_lang_status): Likewise.\n+\t* ggc-common.c (ggc_mark_trees): Use canonical name for\n+\tggc_mark_struct_function.\n+\t* tree.h (ggc_mark_struct_function): Delete prototype.\n+\t* config/alpha/alpha.c (alpha_mark_machine_status): Delete.\n+\t(alpha_init_machine_status): Likewise.\n+\t(override_options): Use canonical name for alpha_mark_machine_status.\n+\t* config/alpha/unicosmk.h (struct machine_function): Use gengtype.\n+\t* config/arm/arm.h (struct machine_function): Use gengtype.\n+\t* config/arm/arm.c (arm_mark_machine_status): Delete.\n+\t(arm_init_machine_status): Update calling sequence.\n+\t(arm_init_expanders): Use canonical name for arm_mark_machine_status.\n+\t* config/cris/cris.c (cris_init_machine_status): Update \n+\tcalling sequence.\n+\t* config/d30v/d30v.h (struct machine_function): Use gengtype.\n+\t* config/d30v/d30v.c (d30v_init_machine_status): Update \n+\tcalling sequence.\n+\t(d30v_mark_machine_status): Delete.\n+\t* config/i386/i386.c: Include gt-i386.h.\n+\t(struct machine_function): Use gengtype.\n+\t(ix86_init_machine_status): Update calling sequence.\n+\t(ix86_mark_machine_status): Delete.\n+\t(override_options): Use canonical namke for ix86_mark_machine_status.\n+\t* config/ia64/ia64.h (struct machine_function): Use gengtype.\n+\t* config/ia64/ia64.c (ia64_init_machine_status): Update calling \n+\tsequence.\n+\t(ia64_mark_machine_status): Delete.\n+\t(ia64_override_options): Use canonical name for \n+\tia64_mark_machine_status.\n+\t* config/mmix/mmix.c (mmix_init_machine_status): Update calling \n+\tsequence.\n+\t* config/rs6000/rs6000.c (rs6000_init_machine_status): Likewise.\n+\t* config/xtensa/xtensa.c (xtensa_init_machine_status): Likewise.\n+\t* gengtype.c (get_output_file): Fix warning.\n+\t(main): Add prototype to suppress warning.\n+\t* tree.c: Remove tree_hash_mark prototype.\n+\n+\t* tree.h (init_stmt): Delete prototype.\n+\t* toplev.c (lang_independent_init): Don't call init_stmt.\n+\t* stmt.c (ALLOC_NESTING): Use GGC for 'struct nesting'.\n+\t(stmt_obstack): Delete.\n+\t(POPSTACK): No need to free 'struct nesting'.\n+\t(gt_ggc_mr_nesting_cond): Use canonical names.\n+\t(gt_ggc_mr_nesting_loop): Use canonical names.\n+\t(gt_ggc_mr_nesting_block): Use canonical names.\n+\t(gt_ggc_mr_nesting_case_stmt): Use canonical names.\n+\t(mark_stmt_status): Delete.\n+\t(init_stmt): Delete.\n+\t(clear_last_expr): Clear both last_expr_type and last_expr_value.\n+\tUse it everywhere that last_expr_type was cleared.\n+\t* lists.c (init_EXPR_INSN_LIST_cache): Use ggc_add_deletable_root.\n+\t(zap_lists): Delete.\n+\t* ggc.h (ggc_add_deletable_root): Prototype.\n+\t(mark_stmt_status): Remove prototype.\n+\t* ggc-common.c (ggc_add_deletable_root): New.\n+\t(ggc_mark_roots): Handle deletable roots.\n+\t* function.c (ggc_mark_struct_function): Use canonical name\n+\tfor mark_stmt_status.\n+\t* emit-rtl.c (free_sequence_stack): New.\n+\t(start_sequence): Use a freelist for sequences.\n+\t(end_sequence): Likewise.\n+\t(init_emit_once): Add free_sequence_stack as a deleteable root.\n+\t* c-pragma.c Include gt-c-pragma.h.\n+\t(struct align_stack): Use gengtype.\n+\t(push_alignment): Use GGC for struct align_stack.\n+\t(mark_align_stack): Delete.\n+\t(gt_ggc_mp_align_stack): New.\n+\t(init_pragma): Use canonical name for mark_align_stack.\n+\t* c-decl.c: Include gt-c-decl.h.\n+\t(struct binding_level): Use gengtype.\n+\t(make_binding_level): Use GGC; handle the freelist here.\n+\t(pop_binding_level): New.\n+\t(pushlevel): Move code into make_binding_level.\n+\t(push_label_level): Likewise.\n+\t(poplevel): Move code into pop_binding_level.\n+\t(pop_label_level): Likewise.\n+\t(mark_binding_level): Delete.\n+\t(gt_ggc_mp_binding_level): New.\n+\t(c_init_decl_processing): Use canonical name for mark_binding_level.\n+\tAdd free_binding_level as deletable root.\n+\t(mark_c_function_context): Use canonical name for mark_binding_level.\n+\t* Makefile.in (c-decl.o): Add gt-c-decl.h.\n+\t(c-pragma.o): Add gt-c-pragma.h.\n+\t(GTFILES): Add c-decl.c and c-pragma.c.\n+\t(gt-c-decl.h, gt-c-pragma.h): Create using gengtype.\n+\n+\t* tree.c (struct type_hash): Use gengtype.\n+\t(init_obstacks): Use canonical name for type_hash_mark.\n+\t(type_hash_mark): Delete.\n+\tInclude gt-tree.h.\n+\t* rtl.h (struct mem_attrs): Use gengtype.\n+\t* optabs.h (struct optab): Use gengtype.\n+\t* optabs.c (expand_binop): Squish signed/unsigned warning.\n+\t(mark_optab): Make local, use canonical name, use autogenerated\n+\tmarker procedure.\n+\t(init_optabs): Use canonical name for mark_optab.\n+\t(new_optab): Use GGC to allocate optabs.\n+\t* ggc.h: Delete mark_optab prototype.\n+\t* ggc-common.c (ggc_mark_rtx_children): Use canonical name for\n+\tmem_attrs marker procedure.\n+\t* gengtype.c (get_output_file): Include headers in gtype-desc.c\n+\texplicitly rather than deducing them from file names.\n+\t(write_gc_structure_fields): Handle arrays of structures.\n+\t(main): Return non-zero exit code if errors occur during output.\n+\t* emit-rtl.c (mem_attrs_mark): Delete.\n+\t(init_emit_once): Use canonical name for mem_attrs marker procedure.\n+\t* Makefile.in (gtype-desc.o): Explicitly name dependencies.\n+\t(tree.o): Depend on gt-tree.h.\n+\t(GTFILES): Add rtl.h, optabs.h, tree.c.\n+\t(gt-tree.h): Add it to s-gtype rule.\n+\n+\t* .cvsignore: Ignore gengtype flex/bison generated files.\n+\t* Makefile.in (GGC_H): Add gtype-desc.h.\n+\t(OBJS): Add gtype-desc.o.\n+\t(GEN): Add gengtype.\n+\t(STAGESTUFF): Add gengtype.\n+\t(varasm.o): Add gt-varasm.h.\n+\t(stmt.o): Add gt-stmt.h.\n+\t(except.o): Add gt-except.h.\n+\t(integrate.o): Add gt-integrate.h.\n+\t(GTFILES): New.\n+\tAdd new rules for new files.\n+\t* configure: Regenerate.\n+\t* configure.in: Correct defaults.h paths.\n+\t* emit-rtl.c (mark_sequence_stack): Delete.\n+\t(mark_emit_status): Delete.\n+\t(start_sequence): Allocate sequence structures using GGC.\n+\t(end_sequence): Allocate sequence structures using GGC.\n+\t* except.c: Use gengtype for various structures.  Include\n+\tgt-except.h.\n+\t* expr.c (mark_expr_status): Delete.\n+\t* function.c: Use gengtype for various structures.  Include\n+\tgt-function.h.\n+\t(mark_function_status): Use standard gt_ggc names for marker functions.\n+\t(ggc_mark_struct_function): Likewise.\n+\t* function.h: Use gengtype for various structures.\n+\t* gengtype-lex.l: New file.\n+\t* gengtype-yacc.y: New file.\n+\t* gengtype.c: New file.\n+\t* gengtype.h: New file.\n+\t* ggc.h: Include gtype-desc.h.  Alias some marker procedures to\n+\tthe standard names.  Remove some now-unnecessary prototypes.\n+\t* integrate.c: Use gengtype for various structures.  Include\n+\tgt-integrate.h.\n+\t(mark_hard_reg_initial_vals): Delete.\n+\t* integrate.h (mark_hard_reg_initial_vals): Delete.\n+\t* stmt.c: Use gengtype for various structures.  Include\n+\tgt-stmt.h.\n+\t(mark_case_node): Delete.\n+\t(mark_goto_fixup): Delete.\n+\t(mark_stmt_status): Use standard gt_ggc names for marker functions.\n+\t* system.h: Define GTY to empty.   In flex/bison files,\n+\tdon't poison malloc or realloc, instead just define them to\n+\txmalloc and xrealloc.\n+\t* varasm.c: Use gengtype for various structures.  Include\n+\tgt-varasm.h.  Use standard gt_ggc names for marker functions.\n+\t(mark_pool_constant): Delete.\n+\t(mark_varasm_status): Delete.\n+\t(decode_rtx_const): #if 0 out non-typesafe hack.\n+\n+\t* function.h (free_lang_status): Mark as obsolete.\n+\t* function.c (free_lang_status): Mark as obsolete.\n+\t* c-decl.c (push_c_function_context): Use GC to allocate and free\n+\tstruct language_function.\n+\t(pop_c_function_context): Likewise.\n+\t* c-common.c (mark_c_language_function): Mark struct\n+\tlanguage_function.\n+\n+\t* doc/tm.texi (Per-Function Data): Don't document free_machine_status.\n+\tDocument that the machine_function structures must be allocated\n+\tusing GC.  Update mark_machine_status documentation.\n+\t* function.h: Don't declare free_machine_status.\n+\t* function.c (free_machine_status): Don't define. \n+\t(free_after_compilation): Don't call free_machine_status.\n+\t(ggc_mark_struct_function): Mark f->machine.  Call\n+\tmark_machine_status only on non-NULL pointers.\n+\t* system.h: Poison free_machine_status.\n+\t* config/xtensa/xtensa.c (xtensa_init_machine_status): Use GC on\n+\tstruct machine_function.\n+\t(xtensa_free_machine_status): Delete.\n+\t(override_options): Don't set free_machine_status.\n+\t* config/rs6000/rs6000.c (rs6000_override_options): Don't set\n+\tfree_machine_status.\n+\t(rs6000_init_machine_status): Use GC on struct machine_function.\n+\t(rs6000_free_machine_status): Delete.\n+\t* config/ia64/ia64.c (ia64_init_machine_status): Use GC on struct\n+\tmachine_function.\n+\t(ia64_mark_machine_status): Likewise.\n+\t(ia64_free_machine_status): Delete.\n+\t(ia64_override_options): Don't set free_machine_status.\n+\t* config/i386/i386.c (override_options): Don't set\n+\tfree_machine_status.\n+\t(ix86_init_machine_status): Use GC on struct machine_function.\n+\t(ix86_mark_machine_status): Likewise.\n+\t(ix86_free_machine_status): Delete.\n+\t* config/d30v/d30v.c: (d30v_init_machine_status): Use GC on struct\n+\tmachine_function.\n+\t(d30v_mark_machine_status): Likewise.\n+\t(d30v_free_machine_status): Delete.\n+\t(d30v_init_expanders): Don't set free_machine_status.\n+\t* config/arm/arm.c (arm_mark_machine_status): Use GC on struct\n+\tmachine_function.\n+\t(arm_init_machine_status): Likewise.\n+\t(arm_free_machine_status): Delete.\n+\t(arm_init_expanders): Don't set free_machine_status.\n+\t* config/alpha/alpha.c (override_options): Don't set\n+\tfree_machine_status.\n+\t(alpha_init_machine_status): Use GC on struct machine_function.\n+\t(alpha_mark_machine_status): Likewise.\n+\t(alpha_free_machine_status): Delete.\n+\n+\t* varasm.c (compare_constant): Fix typo.\n+\n+\t* varasm.c: Don't include obstack.h.\n+\t(struct varasm_status): x_const_rtx_hash_table is a hash of rtxes.\n+\t(struct rtx_const): Give substructures names, improve formatting.\n+\t(struct constant_descriptor): Delete.\n+\t(struct constant_descriptor_tree): New, based on constant_descriptor.\n+\t(const_hash_table): Is a hash table of trees.\n+\t(mark_const_hash_entry): Is used for hashes of trees.  Mark\n+\tconstant_descriptor_tree structure.\n+\t(mark_const_str_htab_1): Mark deferred_string structure.\n+\t(compare_constant): Rewrite to compare trees.\n+\t(compare_constant_1): Delete.\n+\t(record_constant): Delete.\n+\t(record_constant_1): Delete.\n+\t(output_constant_def): Use struct constant_descriptor_tree.\n+\tDon't duplicate trees twice.\n+\t(struct constant_descriptor_rtx): New.\n+\t(struct pool_constant): Used for rtx constants.\n+\t(init_varasm_status): Update for change to struct varasm_status.\n+\t(mark_varasm_status): Likewise.\n+\t(free_varasm_status): Delete.\n+\t(compare_constant_rtx): Rewrite to handle constant_descriptor_rtx.\n+\t(record_constant_rtx): Likewise.\n+\t(mem_for_const_double): Update to use struct constant_descriptor_rtx.\n+\t(force_const_mem): Likewise.\n+\t* Makefile.in (varasm.o): Doesn't depend on obstack.h.\n+\t* function.c (free_after_compilation): Don't use free_varasm_status.\n+\t* function.h: Don't prototype free_varasm_status.\n+\n+\t* ggc-common.c (ggc_realloc): Handle X being NULL.\n+\n+\t* ggc-common.c (ggc_realloc): New function.\n+\t* ggc.h: Prototype it.\n+\t* emit-rtl.c (free_emit_status): Delete.\n+\t(init_emit): Allocate emit subarrays using GC.\n+\t(gen_reg_rtx): Reallocate subarrays using GC.\n+\t(init_emit): Use GC to allocate 'struct emit_status' and its\n+\tsubarrays.\n+\t(mark_emit_status): Mark structure and its subarrays.\n+\t* stmt.c (free_stmt_status): Delete.\n+\t* expr.c (free_expr_status): Delete.\n+\t* function.h: Remove prototypes for deleted functions.\n+\t* function.c (free_after_compilation): Don't use deleted functions.\n+\tDon't call free() on x_parm_reg_stack_loc.\n+\t(free_after_parsing): Don't use free_stmt_status.\n+\t(assign_parms): Use GC to allocate and resize x_parm_reg_stack_loc.\n+\t(mark_function_status): Mark x_parm_reg_stack_loc.\n+\n+\t* varasm.c (init_varasm_status): Use GC to allocate\n+\t'struct varasm_status' and its fields x_const_rtx_hash_table\n+\tand x_const_rtx_sym_hash_table.\n+\t(mark_varasm_status): Mark them.\n+\t(free_varasm_status): Use GC to free them.\n+\t* expr.c (init_expr): Use GC to allocate 'struct expr_status'.\n+\t(mark_expr_status): Mark the structure itself.\n+\t(free_expr_status): Use GC to free the structure.\n+\t* stmt.c (free_stmt_status): Use GC to free 'struct stmt_status'.\n+\t(mark_stmt_status): Mark the 'struct stmt_status' itself.\n+\t(init_stmt_for_function): Allocate the structure for GC.\n+\n+\t* dwarf2out.c (lookup_type_die): Use TYPE_SYMTAB_DIE.\n+\t(equate_type_number_to_die): Likewise.\n+\t* tree.h (TYPE_SYMTAB_DIE): New macro.\n+\t(struct die_struct): Predeclare.\n+\t(struct tree_type): Add field symtab.die.   Add a tag\n+\tto the union type of field symtab.\n+\n+\t* varray.h (VARRAY_RTVEC_INIT): A varray of rtvec contains\n+\t'struct rtvec_def *', not 'struct rtvec_def'.\n+\n+\t* function.h (original_arg_vector): Make a real rtvec.\n+\t* function.c (ggc_mark_struct_function): Adjust.\n+\t* integrate.c (expand_inline_function): Adjust.\n+\n 2002-06-04  Jason Thorpe  <thorpej@wasabisystems.com>\n \n \t* config.gcc (sh5-*-netbsd*, sh5l*-*-netbsd*)"}, {"sha": "10ba33ffd1ac76233be3ec7bb96689346f000e96", "filename": "gcc/Makefile.in", "status": "modified", "additions": 144, "deletions": 85, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -562,7 +562,7 @@ REGS_H = regs.h varray.h $(MACHMODE_H)\n INTEGRATE_H = integrate.h varray.h\n LOOP_H = loop.h varray.h bitmap.h\n GCC_H = gcc.h version.h\n-GGC_H = ggc.h varray.h\n+GGC_H = ggc.h varray.h gtype-desc.h\n TIMEVAR_H = timevar.h timevar.def\n INSN_ATTR_H = insn-attr.h $(srcdir)/insn-addr.h $(srcdir)/varray.h\n C_COMMON_H = c-common.h $(SPLAY_TREE_H) $(CPPLIB_H)\n@@ -718,20 +718,21 @@ C_OBJS = c-parse.o c-lang.o $(C_AND_OBJC_OBJS)\n \n # Language-independent object files.\n \n-OBJS = alias.o bb-reorder.o bitmap.o builtins.o caller-save.o calls.o\t\\\n- cfg.o cfganal.o cfgbuild.o cfgcleanup.o cfglayout.o cfgloop.o cfgrtl.o \\\n- combine.o conflict.o convert.o cse.o cselib.o dbxout.o debug.o dependence.o \\\n- df.o diagnostic.o doloop.o dominance.o dwarf2asm.o dwarf2out.o dwarfout.o \\\n- emit-rtl.o except.o explow.o expmed.o expr.o final.o flow.o \t\t\\\n- fold-const.o function.o gcse.o genrtl.o ggc-common.o global.o graph.o\t\\\n- haifa-sched.o hash.o hashtable.o hooks.o ifcvt.o insn-attrtab.o insn-emit.o \\\n- insn-extract.o insn-opinit.o insn-output.o insn-peep.o insn-recog.o\t\\\n- integrate.o intl.o jump.o  langhooks.o lcm.o lists.o local-alloc.o \t\\\n- loop.o mbchar.o optabs.o params.o predict.o print-rtl.o print-tree.o\t\\\n- profile.o real.o recog.o reg-stack.o regclass.o regmove.o regrename.o\t\\\n- reload.o reload1.o reorg.o resource.o rtl.o rtlanal.o rtl-error.o\t\\\n- sbitmap.o sched-deps.o sched-ebb.o sched-rgn.o sched-vis.o sdbout.o\t\\\n- sibcall.o simplify-rtx.o ssa.o ssa-ccp.o ssa-dce.o stmt.o\t\\\n+OBJS = alias.o bb-reorder.o bitmap.o builtins.o caller-save.o calls.o\t   \\\n+ cfg.o cfganal.o cfgbuild.o cfgcleanup.o cfglayout.o cfgloop.o\t\t   \\\n+ cfgrtl.o combine.o conflict.o convert.o cse.o cselib.o dbxout.o\t   \\\n+ debug.o dependence.o df.o diagnostic.o doloop.o dominance.o\t\t   \\\n+ dwarf2asm.o dwarf2out.o dwarfout.o emit-rtl.o except.o explow.o\t   \\\n+ expmed.o expr.o final.o flow.o fold-const.o function.o gcse.o\t\t   \\\n+ genrtl.o ggc-common.o global.o graph.o gtype-desc.o\t\t\t   \\\n+ haifa-sched.o hashtable.o hooks.o ifcvt.o insn-attrtab.o insn-emit.o\t   \\\n+ insn-extract.o insn-opinit.o insn-output.o insn-peep.o insn-recog.o\t   \\\n+ integrate.o intl.o jump.o  langhooks.o lcm.o lists.o local-alloc.o\t   \\\n+ loop.o mbchar.o optabs.o params.o predict.o print-rtl.o print-tree.o\t   \\\n+ profile.o real.o recog.o reg-stack.o regclass.o regmove.o regrename.o\t   \\\n+ reload.o reload1.o reorg.o resource.o rtl.o rtlanal.o rtl-error.o\t   \\\n+ sbitmap.o sched-deps.o sched-ebb.o sched-rgn.o sched-vis.o sdbout.o\t   \\\n+ sibcall.o simplify-rtx.o ssa.o ssa-ccp.o ssa-dce.o stmt.o\t\t   \\\n  stor-layout.o stringpool.o timevar.o toplev.o tracer.o tree.o tree-dump.o \\\n  tree-inline.o unroll.o varasm.o varray.o version.o vmsdbgout.o xcoffout.o \\\n  $(GGC) $(out_object_file) $(EXTRA_OBJS)\n@@ -744,7 +745,8 @@ BACKEND = main.o libbackend.a\n GEN= genemit$(build_exeext) genoutput$(build_exeext) genrecog$(build_exeext) \\\n  genextract$(build_exeext) genflags$(build_exeext) gencodes$(build_exeext)   \\\n  genconfig$(build_exeext) genpeep$(build_exeext) gengenrtl$(build_exeext)    \\\n- gencheck$(build_exeext) genpreds$(build_exeext) genconstants$(build_exeext)\n+ gencheck$(build_exeext) genpreds$(build_exeext) genconstants$(build_exeext) \\\n+ gengtype$(build_exeext)\n \n # Files to be copied away after each stage in building.\n STAGESTUFF = *$(objext) insn-flags.h insn-config.h insn-codes.h \\\n@@ -759,6 +761,7 @@ STAGESTUFF = *$(objext) insn-flags.h insn-config.h insn-codes.h \\\n  genconfig$(build_exeext) genpeep$(build_exeext) genattrtab$(build_exeext) \\\n  genattr$(build_exeext) genopinit$(build_exeext) gengenrtl$(build_exeext) \\\n  gencheck$(build_exeext) genpreds$(build_exeext) genconstants$(build_exeext) \\\n+ gengtype$(build_exeext) \\\n  genrtl.c genrtl.h \\\n  xgcc$(exeext) cpp$(exeext) cc1$(exeext) $(EXTRA_PASSES) \\\n  $(EXTRA_PARTS) $(EXTRA_PROGRAMS) gcc-cross$(exeext) cc1obj$(exeext) \\\n@@ -1141,7 +1144,8 @@ s-crt0:\t$(CRT0_S) $(MCRT0_S) $(GCC_PASSES) $(CONFIG_H)\n c-errors.o: c-errors.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(C_TREE_H) flags.h \\\n     diagnostic.h $(TM_P_H)\n c-parse.o : $(srcdir)/c-parse.c $(CONFIG_H) $(TREE_H) $(GGC_H) intl.h \\\n-    $(C_TREE_H) input.h flags.h $(SYSTEM_H) toplev.h output.h $(CPPLIB_H)\n+    $(C_TREE_H) input.h flags.h $(SYSTEM_H) toplev.h output.h $(CPPLIB_H) \\\n+    gt-c-parse.h\n \t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n \t       -c $(srcdir)/c-parse.c $(OUTPUT_OPTION)\n \n@@ -1164,32 +1168,33 @@ $(srcdir)/c-parse.y: c-parse.in\n \n c-decl.o : c-decl.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(RTL_H) $(C_TREE_H) \\\n     $(GGC_H) $(TARGET_H) flags.h function.h output.h $(EXPR_H) \\\n-    debug.h toplev.h intl.h $(TM_P_H) tree-inline.h $(TIMEVAR_H) c-pragma.h\n+    debug.h toplev.h intl.h $(TM_P_H) tree-inline.h $(TIMEVAR_H) c-pragma.h \\\n+    gt-c-decl.h\n c-typeck.o : c-typeck.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(C_TREE_H) \\\n     $(TARGET_H) flags.h intl.h output.h $(EXPR_H) $(RTL_H) toplev.h $(TM_P_H)\n c-lang.o : c-lang.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(C_TREE_H) \\\n-    langhooks.h $(LANGHOOKS_DEF_H) c-common.h\n+    $(GGC_H) langhooks.h $(LANGHOOKS_DEF_H) c-common.h gtype-c.h\n c-lex.o : c-lex.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(RTL_H) \\\n     debug.h $(C_TREE_H) c-common.h real.h \\\n     c-pragma.h input.h intl.h flags.h toplev.h output.h \\\n     mbchar.h $(CPPLIB_H) $(EXPR_H) $(TM_P_H)\n c-objc-common.o : c-objc-common.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) \\\n     $(C_TREE_H) $(RTL_H) insn-config.h integrate.h $(EXPR_H) $(C_TREE_H) \\\n     flags.h toplev.h tree-inline.h diagnostic.h integrate.h $(VARRAY_H) \\\n-    langhooks.h $(GGC_H)\n+    langhooks.h $(GGC_H) gt-c-objc-common.h\n c-aux-info.o : c-aux-info.c  $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(C_TREE_H) \\\n     flags.h toplev.h\n c-convert.o : c-convert.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) flags.h toplev.h \\\n     $(C_COMMON_H)\n c-pragma.o: c-pragma.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) function.h \\\n-    c-pragma.h toplev.h output.h $(GGC_H) $(TM_P_H) $(C_COMMON_H)\n+    c-pragma.h toplev.h output.h $(GGC_H) $(TM_P_H) $(C_COMMON_H) gt-c-pragma.h\n mbchar.o: mbchar.c $(CONFIG_H) $(SYSTEM_H) mbchar.h\n graph.o: graph.c $(CONFIG_H) $(SYSTEM_H) toplev.h flags.h output.h $(RTL_H) \\\n     function.h hard-reg-set.h $(BASIC_BLOCK_H) graph.h\n sbitmap.o: sbitmap.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) flags.h hard-reg-set.h \\\n     $(BASIC_BLOCK_H)\n \n-COLLECT2_OBJS = collect2.o tlink.o hash.o intl.o underscore.o version.o\n+COLLECT2_OBJS = collect2.o tlink.o intl.o underscore.o version.o\n COLLECT2_LIBS = @COLLECT2_LIBS@\n collect2$(exeext): $(COLLECT2_OBJS) $(LIBDEPS)\n # Don't try modifying collect2 (aka ld) in place--it might be linking this.\n@@ -1203,9 +1208,8 @@ collect2.o : collect2.c $(CONFIG_H) $(SYSTEM_H) gstab.h intl.h \\\n \t-DTARGET_MACHINE=\\\"$(target_alias)\\\" \\\n \t-c $(srcdir)/collect2.c $(OUTPUT_OPTION)\n \n-tlink.o: tlink.c $(DEMANGLE_H) hash.h $(CONFIG_H) $(SYSTEM_H) collect2.h intl.h\n-hash.o: hash.c hash.h $(SYSTEM_H) toplev.h $(GCONFIG_H)\n-\t$(CC) -c $(ALL_CFLAGS) -DGENERATOR_FILE $(ALL_CPPFLAGS) $(INCLUDES) $< $(OUTPUT_OPTION)\n+tlink.o: tlink.c $(DEMANGLE_H) $(HASHTAB_H) $(CONFIG_H) $(SYSTEM_H) \\\n+    $(OBSTACK_H) collect2.h intl.h\n \n underscore.c: s-under ; @true\n \n@@ -1227,7 +1231,7 @@ s-under: $(GCC_PASSES)\n c-common.o : c-common.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(OBSTACK_H) \\\n \t$(C_COMMON_H) flags.h toplev.h output.h c-pragma.h $(RTL_H) $(GGC_H) \\\n \t$(EXPR_H) $(TM_P_H) builtin-types.def builtin-attrs.def $(TARGET_H) \\\n-\tdiagnostic.h tree-inline.h except.h real.h\n+\tdiagnostic.h tree-inline.h except.h gt-c-common.h real.h\n \n # A file used by all variants of C and some other languages.\n \n@@ -1314,8 +1318,13 @@ dumpvers: dumpvers.c\n \n version.o: version.c version.h\n \n+gtype-desc.o: gtype-desc.c $(CONFIG_H) $(SYSTEM_H) varray.h $(HASHTAB_H) \\\n+\t$(TREE_H) $(RTL_H) function.h insn-config.h $(EXPR_H) $(OPTABS_H) \\\n+\tlibfuncs.h debug.h $(GGC_H) bitmap.h $(BASIC_BLOCK_H) hard-reg-set.h \\\n+\tssa.h cselib.h insn-addr.h\n+\n ggc-common.o: ggc-common.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) \\\n-\tflags.h $(GGC_H) varray.h hash.h $(HASHTAB_H) $(TM_P_H) langhooks.h\n+\tflags.h $(GGC_H) varray.h $(HASHTAB_H) $(TM_P_H) langhooks.h\n \n ggc-simple.o: ggc-simple.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h \\\n \t$(GGC_H) varray.h $(TIMEVAR_H) $(TM_P_H)\n@@ -1324,7 +1333,7 @@ ggc-page.o: ggc-page.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h \\\n \ttoplev.h $(GGC_H) varray.h $(TIMEVAR_H) $(TM_P_H)\n \n stringpool.o: stringpool.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(OBSTACK_H) \\\n-\tflags.h toplev.h\n+\tflags.h toplev.h $(GGC_H)\n \n hashtable.o: hashtable.c hashtable.h $(CONFIG_H) $(SYSTEM_H) $(OBSTACK_H)\n \n@@ -1345,7 +1354,8 @@ langhooks.o : langhooks.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) toplev.h \\\n    tree-inline.h $(RTL_H) insn-config.h integrate.h langhooks.h \\\n    $(LANGHOOKS_DEF_H) flags.h\n tree.o : tree.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) flags.h function.h toplev.h \\\n-   $(GGC_H) $(HASHTAB_H) $(TARGET_H) output.h $(TM_P_H) langhooks.h real.h\n+   $(GGC_H) $(HASHTAB_H) $(TARGET_H) output.h $(TM_P_H) langhooks.h \\\n+   real.h gt-tree.h\n tree-dump.o: tree-dump.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(C_TREE_H) \\\n    flags.h langhooks.h toplev.h output.h c-pragma.h $(RTL_H) $(GGC_H) \\\n    $(EXPR_H) $(SPLAY_TREE_H) tree-dump.h\n@@ -1392,21 +1402,22 @@ errors.o : errors.c $(GCONFIG_H) $(SYSTEM_H) errors.h\n \t$(CC) -c $(ALL_CFLAGS) -DGENERATOR_FILE $(ALL_CPPFLAGS) $(INCLUDES) $< $(OUTPUT_OPTION)\n \n varasm.o : varasm.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(RTL_H) flags.h \\\n-   function.h $(EXPR_H) hard-reg-set.h $(REGS_H) $(OBSTACK_H) \\\n+   function.h $(EXPR_H) hard-reg-set.h $(REGS_H) \\\n    output.h c-pragma.h toplev.h xcoffout.h debug.h $(GGC_H) $(TM_P_H) \\\n-   $(HASHTAB_H) $(TARGET_H) langhooks.h\n+   $(HASHTAB_H) $(TARGET_H) langhooks.h gt-varasm.h\n function.o : function.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h \\\n    function.h $(EXPR_H) libfuncs.h $(REGS_H) hard-reg-set.h \\\n-   insn-config.h $(RECOG_H) output.h toplev.h except.h hash.h $(GGC_H) \\\n-   $(TM_P_H) langhooks.h\n+   insn-config.h $(RECOG_H) output.h toplev.h except.h $(HASHTAB_H) $(GGC_H) \\\n+   $(TM_P_H) langhooks.h gt-function.h\n stmt.o : stmt.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h function.h  \\\n    insn-config.h hard-reg-set.h $(EXPR_H) libfuncs.h except.h \\\n    $(LOOP_H) $(RECOG_H) toplev.h output.h varray.h $(GGC_H) $(TM_P_H) \\\n-   langhooks.h $(PREDICT_H)\n+   langhooks.h $(PREDICT_H) gt-stmt.h\n except.o : except.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h \\\n    except.h function.h $(EXPR_H) libfuncs.h integrate.h langhooks.h \\\n    insn-config.h hard-reg-set.h $(BASIC_BLOCK_H) output.h \\\n-   dwarf2asm.h dwarf2out.h toplev.h $(HASHTAB_H) intl.h $(GGC_H)\n+   dwarf2asm.h dwarf2out.h toplev.h $(HASHTAB_H) intl.h $(GGC_H) \\\n+   gt-except.h\n expr.o : expr.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h function.h \\\n    $(REGS_H) $(EXPR_H) $(OPTABS_H) libfuncs.h insn-attr.h insn-config.h \\\n    $(RECOG_H) output.h typeclass.h hard-reg-set.h toplev.h hard-reg-set.h \\\n@@ -1423,27 +1434,27 @@ expmed.o : expmed.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h  \\\n    toplev.h $(TM_P_H) langhooks.h\n explow.o : explow.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h \\\n    hard-reg-set.h insn-config.h $(EXPR_H) $(OPTABS_H) $(RECOG_H) \\\n-   toplev.h function.h ggc.h $(TM_P_H)\n+   toplev.h function.h ggc.h $(TM_P_H) gt-explow.h\n optabs.o : optabs.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h  \\\n    insn-config.h $(EXPR_H) $(OPTABS_H) libfuncs.h $(RECOG_H) reload.h \\\n-   toplev.h $(GGC_H) real.h $(TM_P_H) except.h\n+   toplev.h $(GGC_H) real.h $(TM_P_H) except.h gt-optabs.h\n dbxout.o : dbxout.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(RTL_H) flags.h \\\n     $(REGS_H) debug.h $(TM_P_H) $(TARGET_H) function.h langhooks.h \\\n    insn-config.h reload.h gstab.h xcoffout.h output.h dbxout.h toplev.h\n debug.o : debug.c debug.h $(CONFIG_H) $(SYSTEM_H)\n sdbout.o : sdbout.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(RTL_H) flags.h \\\n    function.h $(EXPR_H) output.h hard-reg-set.h $(REGS_H) real.h \\\n    insn-config.h $(OBSTACK_H) xcoffout.h c-pragma.h ggc.h \\\n-   sdbout.h toplev.h $(TM_P_H) except.h debug.h langhooks.h\n+   sdbout.h toplev.h $(TM_P_H) except.h debug.h langhooks.h gt-sdbout.h\n dwarfout.o : dwarfout.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(RTL_H) dwarf.h \\\n    flags.h insn-config.h reload.h output.h toplev.h $(TM_P_H) \\\n    debug.h langhooks.h\n dwarf2out.o : dwarf2out.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(RTL_H) dwarf2.h \\\n    debug.h flags.h insn-config.h reload.h output.h diagnostic.h real.h \\\n    hard-reg-set.h $(REGS_H) $(EXPR_H) libfuncs.h toplev.h dwarf2out.h varray.h \\\n-   $(GGC_H) except.h dwarf2asm.h $(TM_P_H) langhooks.h\n+   $(GGC_H) except.h dwarf2asm.h $(TM_P_H) langhooks.h gt-dwarf2out.h\n dwarf2asm.o : dwarf2asm.c $(CONFIG_H) $(SYSTEM_H) flags.h $(RTL_H) $(TREE_H) \\\n-   output.h dwarf2asm.h $(TM_P_H)\n+   output.h dwarf2asm.h $(TM_P_H) $(GGC_H)\n vmsdbgout.o : vmsdbgout.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(RTL_H) flags.h \\\n    output.h vmsdbg.h debug.h langhooks.h\n xcoffout.o : xcoffout.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(RTL_H) xcoffout.h \\\n@@ -1456,7 +1467,7 @@ real.o : real.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) toplev.h $(TM_P_H)\n integrate.o : integrate.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h \\\n    debug.h $(INTEGRATE_H) insn-config.h $(EXPR_H) real.h $(REGS_H) \\\n    intl.h function.h output.h $(RECOG_H) except.h toplev.h $(LOOP_H) \\\n-   $(PARAMS_H) $(TM_P_H) $(TARGET_H) langhooks.h\n+   $(PARAMS_H) $(TM_P_H) $(TARGET_H) langhooks.h gt-integrate.h\n jump.o : jump.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) flags.h hard-reg-set.h $(REGS_H) \\\n    insn-config.h $(RECOG_H) $(EXPR_H) real.h except.h function.h \\\n    toplev.h $(INSN_ATTR_H) $(TM_P_H) reload.h $(PREDICT_H)\n@@ -1466,13 +1477,13 @@ simplify-rtx.o : simplify-rtx.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(REGS_H) \\\n    output.h function.h $(GGC_H) $(OBSTACK_H) $(TM_P_H)\n cselib.o : cselib.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(REGS_H) \\\n    hard-reg-set.h flags.h real.h insn-config.h $(RECOG_H) $(EXPR_H) toplev.h \\\n-   output.h function.h cselib.h $(GGC_H) $(OBSTACK_H) $(TM_P_H)\n+   output.h function.h cselib.h $(GGC_H) $(TM_P_H) gt-cselib.h\n cse.o : cse.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(REGS_H) hard-reg-set.h flags.h \\\n    real.h insn-config.h $(RECOG_H) $(EXPR_H) toplev.h output.h function.h \\\n    $(BASIC_BLOCK_H) $(GGC_H) $(TM_P_H) $(TIMEVAR_H)\n gcse.o : gcse.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(REGS_H) hard-reg-set.h \\\n    flags.h real.h insn-config.h ggc.h $(RECOG_H) $(EXPR_H) $(BASIC_BLOCK_H) \\\n-   function.h output.h toplev.h $(TM_P_H) $(PARAMS_H) except.h\n+   function.h output.h toplev.h $(TM_P_H) $(PARAMS_H) except.h gt-gcse.h\n sibcall.o : sibcall.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(REGS_H) function.h \\\n    hard-reg-set.h flags.h insn-config.h $(RECOG_H) $(BASIC_BLOCK_H)\n resource.o : resource.c $(CONFIG_H) $(RTL_H) hard-reg-set.h $(SYSTEM_H) \\\n@@ -1497,7 +1508,7 @@ conflict.o : conflict.c $(CONFIG_H) $(SYSTEM_H) $(OBSTACK_H) $(HASHTAB_H) \\\n profile.o : profile.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h \\\n    insn-config.h output.h $(REGS_H) $(EXPR_H) function.h \\\n    gcov-io.h toplev.h $(GGC_H) hard-reg-set.h $(BASIC_BLOCK_H) $(TARGET_H) \\\n-   langhooks.h profile.h libfuncs.h\n+   langhooks.h profile.h libfuncs.h gt-profile.h\n loop.o : loop.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) flags.h $(LOOP_H) \\\n    insn-config.h $(REGS_H) hard-reg-set.h $(RECOG_H) $(EXPR_H) \\\n    real.h $(PREDICT_H) $(BASIC_BLOCK_H) function.h \\\n@@ -1537,14 +1548,13 @@ regclass.o : regclass.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) hard-reg-set.h flags.h\n local-alloc.o : local-alloc.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) flags.h \\\n    $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h insn-config.h $(RECOG_H) \\\n    output.h function.h $(INSN_ATTR_H) toplev.h  except.h $(TM_P_H)\n-bitmap.o : bitmap.c $(GCONFIG_H) $(SYSTEM_H) $(RTL_H) flags.h $(BASIC_BLOCK_H) \\\n-   $(REGS_H)\n+bitmap.o : bitmap.c $(GCONFIG_H) $(SYSTEM_H) $(RTL_H) flags.h \\\n+   $(BASIC_BLOCK_H) $(REGS_H) $(GGC_H)\n \t$(CC) -c $(ALL_CFLAGS) -DGENERATOR_FILE $(ALL_CPPFLAGS) $(INCLUDES) $< $(OUTPUT_OPTION)\n global.o : global.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) flags.h reload.h function.h \\\n    $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h insn-config.h output.h toplev.h \\\n    $(TM_P_H)\n-varray.o : varray.c $(CONFIG_H) $(SYSTEM_H) varray.h $(RTL_H) $(TREE_H) bitmap.h \\\n-   errors.h\n+varray.o : varray.c $(CONFIG_H) $(SYSTEM_H) varray.h $(GGC_H) errors.h\n reload.o : reload.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) flags.h output.h \\\n    $(EXPR_H) $(OPTABS_H) reload.h $(RECOG_H) hard-reg-set.h insn-config.h \\\n    $(REGS_H) function.h real.h toplev.h $(TM_P_H)\n@@ -1560,7 +1570,8 @@ reorg.o : reorg.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) conditions.h hard-reg-set.h \\\n    $(RECOG_H) function.h flags.h output.h $(EXPR_H) toplev.h $(PARAMS_H) $(TM_P_H)\n alias.o : alias.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) flags.h hard-reg-set.h \\\n    $(BASIC_BLOCK_H) $(REGS_H) toplev.h output.h $(EXPR_H) \\\n-   $(GGC_H) function.h cselib.h $(TREE_H) $(TM_P_H) langhooks.h $(TARGET_H)\n+   $(GGC_H) function.h cselib.h $(TREE_H) $(TM_P_H) langhooks.h $(TARGET_H) \\\n+   gt-alias.h\n regmove.o : regmove.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) insn-config.h \\\n    $(RECOG_H) output.h $(REGS_H) hard-reg-set.h flags.h function.h \\\n    $(EXPR_H) $(BASIC_BLOCK_H) toplev.h $(TM_P_H) except.h reload.h\n@@ -1588,7 +1599,7 @@ recog.o : recog.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) function.h $(BASIC_BLOCK_H) \\\n    $(INSN_ATTR_H) real.h toplev.h output.h reload.h $(TM_P_H)\n reg-stack.o : reg-stack.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) $(RECOG_H) \\\n    $(REGS_H) hard-reg-set.h flags.h insn-config.h toplev.h reload.h \\\n-   varray.h function.h $(TM_P_H)\n+   varray.h function.h $(TM_P_H) $(GGC_H) gt-reg-stack.h\n predict.o: predict.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h \\\n    insn-config.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h output.h toplev.h \\\n    $(RECOG_H) function.h except.h $(EXPR_H) $(TM_P_H) $(PREDICT_H) real.h \\\n@@ -1610,7 +1621,7 @@ ifcvt.o : ifcvt.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(REGS_H) toplev.h \\\n    flags.h insn-config.h function.h $(RECOG_H) $(BASIC_BLOCK_H) $(EXPR_H) \\\n    output.h except.h $(TM_P_H)\n dependence.o : dependence.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) \\\n-   $(C_COMMON_H) flags.h varray.h $(EXPR_H)\n+   $(C_COMMON_H) flags.h varray.h $(EXPR_H) $(GGC_H) gt-dependence.h\n params.o : params.c $(CONFIG_H) $(SYSTEM_H) $(PARAMS_H) toplev.h\n hooks.o: hooks.c $(CONFIG_H) $(SYSTEM_H) $(HOOKS_H)\n \n@@ -1793,6 +1804,38 @@ s-preds: genpreds$(build_exeext) $(srcdir)/move-if-change\n \t$(SHELL) $(srcdir)/move-if-change tmp-preds.h tm-preds.h\n \t$(STAMP) s-preds\n \n+GTFILES = $(GCONFIG_H) \\\n+  $(HASHTAB_H) \\\n+  $(srcdir)/bitmap.h $(srcdir)/function.h  $(srcdir)/rtl.h $(srcdir)/optabs.h \\\n+  $(srcdir)/tree.h $(srcdir)/libfuncs.h $(srcdir)/hashtable.h $(srcdir)/real.h \\\n+  $(srcdir)/varray.h $(srcdir)/ssa.h $(srcdir)/insn-addr.h $(srcdir)/cselib.h \\\n+  $(srcdir)/c-common.h $(srcdir)/c-tree.h \\\n+  $(srcdir)/alias.c $(srcdir)/bitmap.c $(srcdir)/cselib.c \\\n+  $(srcdir)/dependence.c $(srcdir)/dwarf2out.c $(srcdir)/emit-rtl.c \\\n+  $(srcdir)/except.c $(srcdir)/explow.c $(srcdir)/expr.c \\\n+  $(srcdir)/fold-const.c $(srcdir)/function.c \\\n+  $(srcdir)/gcse.c $(srcdir)/integrate.c $(srcdir)/lists.c $(srcdir)/optabs.c \\\n+  $(srcdir)/profile.c $(srcdir)/regclass.c $(srcdir)/reg-stack.c \\\n+  $(srcdir)/sdbout.c $(srcdir)/stmt.c $(srcdir)/stor-layout.c \\\n+  $(srcdir)/tree.c $(srcdir)/varasm.c \\\n+  $(srcdir)/c-objc-common.c $(srcdir)/c-common.c $(srcdir)/c-parse.in \\\n+  $(out_file) \\\n+  $(srcdir)/c-decl.c $(srcdir)/c-pragma.c \\\n+  @all_gtfiles@\n+\n+gtype-desc.h gtype-desc.c gt-except.h gt-function.h : s-gtype; @true\n+gt-integrate.h gt-stmt.h gt-tree.h gt-varasm.h gt-emit-rtl.h : s-gtype; @true\n+gt-explow.h gt-stor-layout.h gt-regclass.h gt-lists.h : s-gtype; @true\n+gt-alias.h gt-cselib.h gt-fold-const.h gt-gcse.h gt-profile.h : s-gtype; @true\n+gt-expr.h gt-sdbout.h gt-optabs.h gt-bitmap.h gt-dwarf2out.h : s-gtype ; @true\n+gt-reg-stack.h gt-dependence.h : s-gtype ; @true\n+gt-c-common.h gt-c-decl.h gt-c-parse.h gt-c-pragma.h : s-gtype; @true\n+gt-c-objc-common.h gtype-c.h : s-gtype ; @true\n+\n+s-gtype: gengtype$(build_exeext) $(GTFILES)\n+\t./gengtype $(GTFILES)\n+\t$(STAMP) s-gtype\n+\n #\f\n # Compile the programs that generate insn-* from the machine description.\n # They are compiled with $(HOST_CC), and associated libraries,\n@@ -1899,7 +1942,7 @@ genattrtab.o : genattrtab.c $(RTL_H) $(OBSTACK_H) $(HCONFIG_H) \\\n \t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(srcdir)/genattrtab.c $(OUTPUT_OPTION)\n \n genautomata.o : genautomata.c $(RTL_H) $(OBSTACK_H) $(HCONFIG_H) \\\n-  $(SYSTEM_H) errors.h varray.h hash.h genattrtab.h\n+  $(SYSTEM_H) errors.h varray.h genattrtab.h $(HASHTAB_H)\n \t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(srcdir)/genautomata.c $(OUTPUT_OPTION)\n \n genoutput$(build_exeext) : genoutput.o $(HOST_RTL) $(HOST_PRINT) $(HOST_ERRORS) $(HOST_LIBDEPS)\n@@ -1924,6 +1967,33 @@ genpreds$(build_exeext) : genpreds.o $(HOST_LIBDEPS)\n genpreds.o : genpreds.c $(RTL_BASE_H) $(HCONFIG_H) $(SYSTEM_H)\n \t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(srcdir)/genpreds.c $(OUTPUT_OPTION)\n \n+gengtype$(build_exeext) : gengtype.o gengtype-lex.o gengtype-yacc.o \\\n+  $(HOST_LIBDEPS)\n+\t$(HOST_CC) $(HOST_CFLAGS) $(HOST_LDFLAGS) -o $@ \\\n+\t gengtype.o gengtype-lex.o gengtype-yacc.o $(HOST_LIBS)\n+\n+gengtype.o : gengtype.c gengtype.h $(HCONFIG_H) $(SYSTEM_H) real.h\n+\t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) \\\n+\t  $(srcdir)/gengtype.c $(OUTPUT_OPTION)\n+\n+gengtype-lex.o : gengtype-lex.c gengtype.h gengtype-yacc.c \\\n+  $(HCONFIG_H) $(SYSTEM_H)\n+\t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) \\\n+\t  $(srcdir)/gengtype-lex.c $(OUTPUT_OPTION)\n+\n+gengtype-yacc.o : gengtype-yacc.c gengtype.h $(HCONFIG_H) $(SYSTEM_H)\n+\t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) \\\n+\t  $(srcdir)/gengtype-yacc.c $(OUTPUT_OPTION)\n+\n+$(srcdir)/gengtype-lex.c : $(srcdir)/gengtype-lex.l\n+\t$(FLEX) $(FLEXFLAGS) -o$@ $(srcdir)/gengtype-lex.l \\\n+\t || ( rm -f $@ && false )\n+\n+$(srcdir)/gengtype-yacc.c: $(srcdir)/gengtype-yacc.y\n+\t(cd $(srcdir) && \\\n+\t $(BISON) $(BISONFLAGS) -d -o gengtype-yacc.c gengtype-yacc.y || \\\n+\t ( rm -f $@ && false ) )\n+\n #\f\n # Compile the libraries to be used by gen*.\n # If we are not cross-building, gen* use the same .o's that cc1 will use,\n@@ -1941,8 +2011,8 @@ $(BUILD_PREFIX_1)print-rtl.o: $(srcdir)/print-rtl.c $(HCONFIG_H) \\\n \tsed -e 's/config[.]h/hconfig.h/' $(srcdir)/print-rtl.c > $(BUILD_PREFIX)print-rtl.c\n \t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(BUILD_PREFIX)print-rtl.c $(OUTPUT_OPTION)\n \n-$(BUILD_PREFIX_1)bitmap.o: $(srcdir)/bitmap.c $(HCONFIG_H) $(SYSTEM_H) $(RTL_H) \\\n-  flags.h $(BASIC_BLOCK_H) $(REGS_H)\n+$(BUILD_PREFIX_1)bitmap.o: $(srcdir)/bitmap.c $(HCONFIG_H) $(SYSTEM_H) \\\n+  $(RTL_H) flags.h $(BASIC_BLOCK_H) $(REGS_H) $(GGC_H)\n \trm -f $(BUILD_PREFIX)bitmap.c\n \tsed -e 's/config[.]h/hconfig.h/' $(srcdir)/bitmap.c > $(BUILD_PREFIX)bitmap.c\n \t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(BUILD_PREFIX)bitmap.c $(OUTPUT_OPTION)\n@@ -2303,11 +2373,10 @@ docdir = $(srcdir)/doc\n doc: $(BUILD_INFO) $(GENERATED_MANPAGES) gccbug\n info: $(docdir)/cpp.info $(docdir)/gcc.info $(docdir)/gccint.info lang.info $(docdir)/cppinternals.info\n \n-$(docdir)/cpp.info: $(docdir)/cpp.texi $(docdir)/include/fdl.texi \\\n+TEXI_CPP_FILES = $(docdir)/cpp.texi $(docdir)/include/fdl.texi \\\n   $(docdir)/cppenv.texi $(docdir)/cppopts.texi\n-\tcd $(srcdir) && $(MAKEINFO) $(MAKEINFOFLAGS) -I doc -I doc/include -o doc/cpp.info doc/cpp.texi\n \n-$(docdir)/gcc.info: $(docdir)/gcc.texi $(docdir)/include/gcc-common.texi \\\n+TEXI_GCC_FILES = $(docdir)/gcc.texi $(docdir)/include/gcc-common.texi \\\n \t $(docdir)/frontends.texi $(docdir)/standards.texi \\\n \t $(docdir)/invoke.texi $(docdir)/extend.texi $(docdir)/md.texi \\\n \t $(docdir)/objc.texi $(docdir)/gcov.texi $(docdir)/trouble.texi \\\n@@ -2316,9 +2385,8 @@ $(docdir)/gcc.info: $(docdir)/gcc.texi $(docdir)/include/gcc-common.texi \\\n \t $(docdir)/include/funding.texi $(docdir)/gnu.texi \\\n \t $(docdir)/include/gpl.texi $(docdir)/include/fdl.texi \\\n \t $(docdir)/contrib.texi $(docdir)/cppenv.texi $(docdir)/cppopts.texi\n-\tcd $(srcdir) && $(MAKEINFO) $(MAKEINFOFLAGS) -I doc -I doc/include -o doc/gcc.info doc/gcc.texi\n \n-$(docdir)/gccint.info: $(docdir)/gccint.texi \\\n+TEXI_GCCINT_FILES = $(docdir)/gccint.texi \\\n \t $(docdir)/include/gcc-common.texi $(docdir)/contribute.texi \\\n \t $(docdir)/makefile.texi $(docdir)/configterms.texi \\\n \t $(docdir)/portability.texi $(docdir)/interface.texi \\\n@@ -2329,46 +2397,37 @@ $(docdir)/gccint.info: $(docdir)/gccint.texi \\\n \t $(docdir)/headerdirs.texi $(docdir)/include/funding.texi \\\n \t $(docdir)/gnu.texi $(docdir)/include/gpl.texi \\\n \t $(docdir)/include/fdl.texi $(docdir)/contrib.texi \\\n-\t $(docdir)/languages.texi $(docdir)/sourcebuild.texi\n+\t $(docdir)/languages.texi $(docdir)/sourcebuild.texi \\\n+\t $(docdir)/gty.texi\n+\n+TEXI_CPPINT_FILES = $(docdir)/cppinternals.texi\n+\n+$(docdir)/cpp.info: $(TEXI_CPP_FILES)\n+\tcd $(srcdir) && $(MAKEINFO) $(MAKEINFOFLAGS) -I doc -I doc/include -o doc/cpp.info doc/cpp.texi\n+\n+$(docdir)/gcc.info: $(TEXI_GCC_FILES)\n+\tcd $(srcdir) && $(MAKEINFO) $(MAKEINFOFLAGS) -I doc -I doc/include -o doc/gcc.info doc/gcc.texi\n+\n+$(docdir)/gccint.info: $(TEXI_GCCINT_FILES)\n \tcd $(srcdir) && $(MAKEINFO) $(MAKEINFOFLAGS) -I doc -I doc/include -o doc/gccint.info doc/gccint.texi\n \n-$(docdir)/cppinternals.info: $(docdir)/cppinternals.texi\n+$(docdir)/cppinternals.info: $(TEXI_CPPINT_FILES)\n \tcd $(srcdir) && $(MAKEINFO) $(MAKEINFOFLAGS) -I doc -I doc/include -o doc/cppinternals.info \\\n \t\tdoc/cppinternals.texi\n \n dvi: gcc.dvi gccint.dvi cpp.dvi lang.dvi cppinternals.dvi\n \n # This works with GNU Make's default rule.\n-cpp.dvi: $(docdir)/cpp.texi $(docdir)/include/fdl.texi \\\n-\t$(docdir)/cppenv.texi $(docdir)/cppopts.texi\n+cpp.dvi: $(TEXI_CPP_FILES)\n \t$(TEXI2DVI) -I $(docdir) -I $(docdir)/include $(docdir)/cpp.texi\n \n-gcc.dvi: $(docdir)/gcc.texi $(docdir)/include/gcc-common.texi \\\n-\t $(docdir)/frontends.texi $(docdir)/standards.texi \\\n-\t $(docdir)/invoke.texi $(docdir)/extend.texi $(docdir)/md.texi \\\n-\t $(docdir)/objc.texi $(docdir)/gcov.texi $(docdir)/trouble.texi \\\n-\t $(docdir)/bugreport.texi $(docdir)/service.texi \\\n-\t $(docdir)/contribute.texi $(docdir)/vms.texi \\\n-\t $(docdir)/include/funding.texi $(docdir)/gnu.texi \\\n-\t $(docdir)/include/gpl.texi $(docdir)/include/fdl.texi \\\n-\t $(docdir)/contrib.texi $(docdir)/cppenv.texi $(docdir)/cppopts.texi\n+gcc.dvi: $(TEXI_GCC_FILES)\n \t$(TEXI2DVI) -I $(docdir) -I $(docdir)/include $(docdir)/gcc.texi\n \n-gccint.dvi: $(docdir)/gccint.texi \\\n-\t $(docdir)/include/gcc-common.texi $(docdir)/contribute.texi \\\n-\t $(docdir)/makefile.texi $(docdir)/configterms.texi \\\n-\t $(docdir)/portability.texi $(docdir)/interface.texi \\\n-\t $(docdir)/passes.texi $(docdir)/c-tree.texi \\\n-\t $(docdir)/rtl.texi $(docdir)/md.texi $(docdir)/tm.texi \\\n-\t $(docdir)/hostconfig.texi $(docdir)/fragments.texi \\\n-\t $(docdir)/configfiles.texi $(docdir)/collect2.texi \\\n-\t $(docdir)/headerdirs.texi $(docdir)/include/funding.texi \\\n-\t $(docdir)/gnu.texi $(docdir)/include/gpl.texi \\\n-\t $(docdir)/include/fdl.texi $(docdir)/contrib.texi \\\n-\t $(docdir)/languages.texi $(docdir)/sourcebuild.texi\n+gccint.dvi: $(TEXI_GCCINT_FILES)\n \t$(TEXI2DVI) -I $(docdir) -I $(docdir)/include $(docdir)/gccint.texi\n \n-cppinternals.dvi: $(docdir)/cppinternals.texi\n+cppinternals.dvi: $(TEXI_CPPINT_FILES)\n \t$(TEXI2DVI) -I $(docdir) -I $(docdir)/include $(docdir)/cppinternals.texi\n \n generated-manpages: $(docdir)/gcov.1 $(docdir)/cpp.1 $(docdir)/gcc.1 \\"}, {"sha": "0f28390b3ceb2bade1e155e411dc5f17bc274417", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -1,3 +1,58 @@\n+2002-06-03  Geoffrey Keating  <geoffk@redhat.com>\n+\n+\tMerge from pch-branch:\n+\n+\t* config-lang.in (gtfiles): Add ada-tree.h.\n+\t* ada-tree.h (SET_TYPE_CI_CO_LIST): New.\n+\t(SET_TYPE_MODULUS): New.\n+\t(SET_TYPE_INDEX): New.\n+\t(SET_TYPE_DIGITS_VALUE): New.\n+\t(SET_TYPE_RM_SIZE): New.\n+\t(SET_TYPE_UNCONSTRAINED_ARRAY): New.\n+\t(SET_TYPE_ADA_SIZE): New.\n+\t(SET_TYPE_ACTUAL_BOUNDS): New.\n+\t(SET_DECL_CONST_CORRESPONDING_VAR): New.\n+\t(SET_DECL_ORIGINAL_FIELD): New.\n+\t(TREE_LOOP_ID): Correct typo.\n+\t* decl.c: Use new macros.\n+\t* utils.c: Include debug.h, use new macros.\n+\t* utils2.c: Use new macros.\t\n+\n+\t* ada-tree.h: Update all macros for new tree description.\n+\t(struct tree_loop_id): New.\n+\t(union lang_tree_node): New.\n+\t(struct lang_decl): New.\n+\t(struct lang_type): New.\n+\t* misc.c (gnat_mark_tree): Delete.\n+\t(LANG_HOOKS_MARK_TREE): Delete.\n+\t* trans.c (tree_transform): No longer any need to cast\n+\tfor TREE_LOOP_ID.\n+\n+\t* utils.c (struct language_function): New dummy structure.\n+\n+\t* Makefile.in (decl.o): gt-ada-<filename.h> is in objdir, not srcdir.\n+\t(misc.o): Likewise.\n+\t(utils.o): Likewise; also gtype-ada.h.\n+\t* Make-lang.in (gnat1): Add dependency on s-gtype.\n+\t(gnatbind): Add dependency on $(CONFIG_H).\n+\t* utils.c: Correct last #include.\n+\t(stuct e_stack): Remove unnecessary 'static'.\n+\t(mark_e_stack): Remove unused prototype.\n+\n+\t* scn-nlit.adb: Remove whitespace after version number to\n+\tkeep lines under 80 chars.\n+\t* snames.adb: Likewise.\n+\t* treepr.ads: Likewise.\n+\t\n+\t* Makefile.in (decl.o): Include gt-ada-<filename>.h.\n+\t(misc.o): Likewise.\n+\t(utils.o): Include gt-ada-<filename>.h and gtype-ada.h.\n+\t* config-lang.in (gtfiles): New.\n+\t* decl.c: Use gengtype for roots.\n+\t* gigi.h: Use gengtype for roots.\n+\t* trans.c: Use gengtype for roots.\n+\t* utils.c: Use gengtype for roots, marking.  Include gtype-ada.h.\n+\n 2002-06-02  Gabriel Dos Reis  <gdr@codesourcery.com>\n \n \t* misc.c (gnat_init): Adjust setting of internal_error_function."}, {"sha": "af91c3228262bb6760dc5148e0693c1b53185d0d", "filename": "gcc/ada/Make-lang.in", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fada%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fada%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMake-lang.in?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -205,10 +205,6 @@ gnat1$(exeext): $(TARGET_ADA_SRCS) $(GNAT1_OBJS) $(ADA_BACKEND) $(LIBDEPS)\n \t\t$(SYSLIBS)\n \t$(RM) stamp-gnatlib2 stamp-tools\n \n-gnatbind$(exeext): ada/b_gnatb.o $(GNATBIND_OBJS)\n-\t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ ada/b_gnatb.o $(GNATBIND_OBJS) \\\n-\t      $(LIBIBERTY) $(LIBS)\n-\n # use target-gcc target-gnatmake target-gnatbind target-gnatlink \n gnattools: $(GCC_PARTS) $(CONFIG_H) prefix.o force\n \t$(MAKE) -C ada $(FLAGS_TO_PASS) $(ADA_FLAGS_TO_PASS) \\\n@@ -272,6 +268,9 @@ gnatlib_and_tools: gnatlib gnattools\n # use cross-gcc\n gnat-cross: force\n \t$(MAKE) -C ada $(FLAGS_TO_PASS) $(ADA_FLAGS_TO_PASS) gnat-cross\n+\n+gt-ada-decl.h gt-ada-trans.h gt-ada-utils.h gtype-ada.h : s-gtype ; @true\n+\n \f\n # Build hooks:\n \n@@ -1002,7 +1001,8 @@ ada/cuintp.o : ada/cuintp.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) ada/ada.h \\\n ada/decl.o : ada/decl.c $(CONFIG_H) $(TREE_H) $(srcdir)/flags.h \\\n    $(srcdir)/toplev.h $(srcdir)/convert.h ada/ada.h ada/types.h ada/atree.h \\\n    ada/nlists.h ada/elists.h ada/uintp.h ada/sinfo.h ada/einfo.h ada/snames.h \\\n-   ada/namet.h ada/stringt.h ada/repinfo.h ada/fe.h $(ADA_TREE_H) ada/gigi.h\n+   ada/namet.h ada/stringt.h ada/repinfo.h ada/fe.h $(ADA_TREE_H) ada/gigi.h \\\n+   gt-ada-decl.h\n \n ada/misc.o : ada/misc.c $(CONFIG_H) $(TREE_H) $(RTL_H) $(srcdir)/expr.h \\\n    insn-codes.h insn-flags.h insn-config.h $(srcdir)/recog.h \\\n@@ -1020,12 +1020,13 @@ ada/targtyps.o : ada/targtyps.c $(CONFIG_H) ada/ada.h ada/types.h ada/atree.h \\\n ada/trans.o : ada/trans.c $(CONFIG_H) $(TREE_H) $(RTL_H) $(srcdir)/flags.h \\\n    ada/ada.h $(srcdir)/except.h ada/types.h ada/atree.h ada/nlists.h \\\n    ada/elists.h ada/uintp.h ada/sinfo.h ada/einfo.h ada/namet.h ada/snames.h \\\n-   ada/stringt.h ada/urealp.h ada/fe.h $(ADA_TREE_H) ada/gigi.h\n+   ada/stringt.h ada/urealp.h ada/fe.h $(ADA_TREE_H) ada/gigi.h gt-ada-trans.h\n \n ada/utils.o : ada/utils.c $(CONFIG_H) $(TREE_H) $(srcdir)/flags.h \\\n    $(srcdir)/expr.h $(srcdir)/convert.h $(srcdir)/defaults.h ada/ada.h \\\n    ada/types.h ada/atree.h ada/nlists.h ada/elists.h ada/sinfo.h ada/einfo.h \\\n-   ada/namet.h ada/stringt.h ada/uintp.h ada/fe.h $(ADA_TREE_H) ada/gigi.h\n+   ada/namet.h ada/stringt.h ada/uintp.h ada/fe.h $(ADA_TREE_H) ada/gigi.h \\\n+   gt-ada-utils.h gtype-ada.h\n \n ada/utils2.o : ada/utils2.c $(CONFIG_H) $(TREE_H) $(srcdir)/flags.h ada/ada.h \\\n    ada/types.h ada/atree.h ada/nlists.h ada/elists.h ada/sinfo.h ada/einfo.h \\"}, {"sha": "b22f081bb6a5ee73188ff2a67907fdfa2a2c652d", "filename": "gcc/ada/ada-tree.h", "status": "modified", "additions": 61, "deletions": 11, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fada%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fada%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fada-tree.h?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -34,6 +34,35 @@ enum gnat_tree_code {\n };\n #undef DEFTREECODE\n \n+/* A tree to hold a loop ID.  */\n+struct tree_loop_id GTY(()) \n+{\n+  struct tree_common common;\n+  struct nesting *loop_id;\n+};\n+\n+/* The language-specific tree.  */\n+union lang_tree_node \n+  GTY((desc (\"TREE_CODE (&%h.generic) == GNAT_LOOP_ID\")))\n+{\n+  union tree_node GTY ((tag (\"0\"), \n+\t\t\tdesc (\"tree_node_structure (&%h)\"))) \n+    generic;\n+  struct tree_loop_id GTY ((tag (\"1\"))) loop_id;\n+};\n+\n+/* Ada uses the lang_decl and lang_type fields to hold more trees.  */\n+struct lang_decl GTY(()) \n+{\n+  union lang_tree_node \n+    GTY((desc (\"TREE_CODE (&%h.generic) == GNAT_LOOP_ID\"))) t;\n+};\n+struct lang_type GTY(())\n+{\n+  union lang_tree_node \n+    GTY((desc (\"TREE_CODE (&%h.generic) == GNAT_LOOP_ID\"))) t;\n+};\n+\n /* Flags added to GCC type nodes.  */\n \n /* For RECORD_TYPE, UNION_TYPE, and QUAL_UNION_TYPE, nonzero if this is a\n@@ -129,29 +158,39 @@ enum gnat_tree_code {\n    by copy in copy out.  It is a CONSTRUCTOR.  For a full description of the\n    cico parameter passing mechanism refer to the routine gnat_to_gnu_entity. */\n #define TYPE_CI_CO_LIST(NODE)   \\\n-  (tree) TYPE_LANG_SPECIFIC (FUNCTION_TYPE_CHECK (NODE))\n+  (&TYPE_LANG_SPECIFIC (FUNCTION_TYPE_CHECK (NODE))->t.generic)\n+#define SET_TYPE_CI_CO_LIST(NODE, X)   \\\n+  (TYPE_LANG_SPECIFIC (FUNCTION_TYPE_CHECK (NODE)) = (struct lang_type *)(X))\n \n /* For an INTEGER_TYPE with TYPE_MODULAR_P, this is the value of the\n    modulus. */\n #define TYPE_MODULUS(NODE)  \\\n-  (tree) TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE))\n+  (&TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE))->t.generic)\n+#define SET_TYPE_MODULUS(NODE, X)  \\\n+  (TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE)) = (struct lang_type *)(X))\n \n /* For an INTEGER_TYPE that is the TYPE_DOMAIN of some ARRAY_TYPE, points to\n    the type corresponding to the Ada index type.  */\n #define TYPE_INDEX_TYPE(NODE)\t\\\n-  (tree) TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE))\n+  (&TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE))->t.generic)\n+#define SET_TYPE_INDEX_TYPE(NODE, X)\t\\\n+  (TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE)) = (struct lang_type *)(X))\n \n /* For an INTEGER_TYPE with TYPE_VAX_FLOATING_POINT_P, stores the\n    Digits_Value.  */\n #define TYPE_DIGITS_VALUE(NODE)  \\\n-  (long) TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE))\n+  ((long) TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE)))\n+#define SET_TYPE_DIGITS_VALUE(NODE, X)  \\\n+  (TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE)) = (struct lang_type *)(X))\n \n /* For INTEGER_TYPE, stores the RM_Size of the type.  */\n #define TYPE_RM_SIZE_INT(NODE)\tTYPE_VALUES (INTEGER_TYPE_CHECK (NODE))\n \n /* Likewise for ENUMERAL_TYPE.  */\n #define TYPE_RM_SIZE_ENUM(NODE)\t\\\n-  (tree) TYPE_LANG_SPECIFIC (ENUMERAL_TYPE_CHECK (NODE))\n+  (&TYPE_LANG_SPECIFIC (ENUMERAL_TYPE_CHECK (NODE))->t.generic)\n+#define SET_TYPE_RM_SIZE_ENUM(NODE, X)\t\\\n+  (TYPE_LANG_SPECIFIC (ENUMERAL_TYPE_CHECK (NODE)) = (struct lang_type *)(X))\n \n #define TYPE_RM_SIZE(NODE)\t\t\t\t\t\\\n   (TREE_CODE (NODE) == ENUMERAL_TYPE ? TYPE_RM_SIZE_ENUM (NODE)\t\\\n@@ -162,17 +201,23 @@ enum gnat_tree_code {\n    unconstrained object.  Likewise for a RECORD_TYPE that is pointed\n    to by a thin pointer.  */\n #define TYPE_UNCONSTRAINED_ARRAY(NODE)  \\\n-  (tree) TYPE_LANG_SPECIFIC (RECORD_TYPE_CHECK (NODE))\n+  (&TYPE_LANG_SPECIFIC (RECORD_TYPE_CHECK (NODE))->t.generic)\n+#define SET_TYPE_UNCONSTRAINED_ARRAY(NODE, X)  \\\n+  (TYPE_LANG_SPECIFIC (RECORD_TYPE_CHECK (NODE)) = (struct lang_type *)(X))\n \n /* For other RECORD_TYPEs and all UNION_TYPEs and QUAL_UNION_TYPEs, the Ada\n    size of the object.  This differs from the GCC size in that it does not\n    include any rounding up to the alignment of the type.  */\n-#define TYPE_ADA_SIZE(NODE)\t(tree) TYPE_LANG_SPECIFIC (NODE)\n+#define TYPE_ADA_SIZE(NODE)\t(&TYPE_LANG_SPECIFIC (NODE)->t.generic)\n+#define SET_TYPE_ADA_SIZE(NODE, X) \\\n+  (TYPE_LANG_SPECIFIC (NODE) = (struct lang_type *)(X))\n \n /* For an INTEGER_TYPE with TYPE_HAS_ACTUAL_BOUNDS_P or an ARRAY_TYPE, this is\n    the index type that should be used when the actual bounds are required for\n    a template.  This is used in the case of packed arrays.  */\n-#define TYPE_ACTUAL_BOUNDS(NODE)   (tree) TYPE_LANG_SPECIFIC (NODE)\n+#define TYPE_ACTUAL_BOUNDS(NODE)   (&TYPE_LANG_SPECIFIC (NODE)->t.generic)\n+#define SET_TYPE_ACTUAL_BOUNDS(NODE, X) \\\n+  (TYPE_LANG_SPECIFIC (NODE) = (struct lang_type *)(X))\n \n /* In an UNCONSTRAINED_ARRAY_TYPE, points to the record containing both\n    the template and object.  */\n@@ -211,17 +256,22 @@ enum gnat_tree_code {\n    memory.  Used when a scalar constant is aliased or has its\n    address taken.  */\n #define DECL_CONST_CORRESPONDING_VAR(NODE) \\\n-  (tree) DECL_LANG_SPECIFIC (CONST_DECL_CHECK (NODE))\n+  (&DECL_LANG_SPECIFIC (CONST_DECL_CHECK (NODE))->t.generic)\n+#define SET_DECL_CONST_CORRESPONDING_VAR(NODE, X) \\\n+  (DECL_LANG_SPECIFIC (CONST_DECL_CHECK (NODE)) = (struct lang_decl *)(X))\n \n /* In a FIELD_DECL, points to the FIELD_DECL that was the ultimate\n    source of the decl.  */\n #define DECL_ORIGINAL_FIELD(NODE) \\\n-  (tree) DECL_LANG_SPECIFIC (FIELD_DECL_CHECK (NODE))\n+  (&DECL_LANG_SPECIFIC (FIELD_DECL_CHECK (NODE))->t.generic)\n+#define SET_DECL_ORIGINAL_FIELD(NODE, X) \\\n+  (DECL_LANG_SPECIFIC (FIELD_DECL_CHECK (NODE)) = (struct lang_decl *)(X))\n \n /* In a FIELD_DECL corresponding to a discriminant, contains the\n    discriminant number.  */\n #define DECL_DISCRIMINANT_NUMBER(NODE) DECL_INITIAL (FIELD_DECL_CHECK (NODE))\n \n /* This is a horrible kludge to store the loop_id of a loop into a tree\n    node.  We need to find some other place to store it!  */\n-#define TREE_LOOP_ID(NODE) (TREE_CHECK (NODE, GNAT_LOOP_ID)->real_cst.rtl)\n+#define TREE_LOOP_ID(NODE) \\\n+  (((union lang_tree_node *)TREE_CHECK (NODE, GNAT_LOOP_ID))->loop_id.loop_id)"}, {"sha": "b0fe156af131d2c0d08887c1c326c07b815e88c0", "filename": "gcc/ada/config-lang.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fada%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fada%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fconfig-lang.in?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -35,6 +35,8 @@ compilers=\"gnat1\\$(exeext)\"\n \n stagestuff=\"gnatbind\\$(exeext) gnat1\\$(exeext)\"\n \n+gtfiles=\"\\$(srcdir)/ada/ada-tree.h \\$(srcdir)/ada/gigi.h \\$(srcdir)/ada/decl.c \\$(srcdir)/ada/trans.c \\$(srcdir)/ada/utils.c\"\n+\n diff_excludes=\"-x ada/a-einfo.h -x ada/a-sinfo.h -x ada/nmake.adb -x ada/nmake.ads -x ada/treeprs.ads -x ada/sysid.ads\"\n \n outputs=ada/Makefile"}, {"sha": "fbced93ffd1aafad71d75cd4b293334ad0aa4a35", "filename": "gcc/ada/decl.c", "status": "modified", "additions": 51, "deletions": 46, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -1044,10 +1044,10 @@ gnat_to_gnu_entity (gnat_entity, gnu_expr, definition)\n \t\t|| Address_Taken (gnat_entity)\n \t\t|| Is_Aliased (gnat_entity)\n \t\t|| Is_Aliased (Etype (gnat_entity))))\n-\t  DECL_CONST_CORRESPONDING_VAR (gnu_decl)\n-\t    = create_var_decl (gnu_entity_id, gnu_ext_name, gnu_type,\n+\t  SET_DECL_CONST_CORRESPONDING_VAR (gnu_decl, \n+\t      create_var_decl (gnu_entity_id, gnu_ext_name, gnu_type,\n \t\t\t       gnu_expr, 0, Is_Public (gnat_entity), 0,\n-\t\t\t       static_p, 0);\n+\t\t\t       static_p, 0));\n \n \t/* If this is declared in a block that contains an block with an\n \t   exception handler, we must force this variable in memory to\n@@ -1184,7 +1184,7 @@ gnat_to_gnu_entity (gnat_entity, gnu_expr, definition)\n \tif (! integer_zerop (gnu_modulus))\n \t  {\n \t    TYPE_MODULAR_P (gnu_type) = 1;\n-\t    TYPE_MODULUS (gnu_type) = gnu_modulus;\n+\t    SET_TYPE_MODULUS (gnu_type, gnu_modulus);\n \t    gnu_high = fold (build (MINUS_EXPR, gnu_type, gnu_modulus,\n \t\t\t\t    convert (gnu_type, integer_one_node)));\n \t  }\n@@ -1308,7 +1308,7 @@ gnat_to_gnu_entity (gnat_entity, gnu_expr, definition)\n \t\t\t\t\t gnu_field_type, gnu_type, 1, 0, 0, 1),\n \t  finish_record_type (gnu_type, gnu_field, 0, 0);\n \t  TYPE_LEFT_JUSTIFIED_MODULAR_P (gnu_type) = 1;\n-\t  TYPE_ADA_SIZE (gnu_type) = bitsize_int (esize);\n+\t  SET_TYPE_ADA_SIZE (gnu_type, bitsize_int (esize));\n \t}\n \n       break;\n@@ -1320,8 +1320,8 @@ gnat_to_gnu_entity (gnat_entity, gnu_expr, definition)\n \t{\n \t  gnu_type = make_signed_type (esize);\n \t  TYPE_VAX_FLOATING_POINT_P (gnu_type) = 1;\n-\t  TYPE_DIGITS_VALUE (gnu_type)\n-\t    = UI_To_Int (Digits_Value (gnat_entity));\n+\t  SET_TYPE_DIGITS_VALUE (gnu_type, \n+\t\t\t\t UI_To_Int (Digits_Value (gnat_entity)));\n \t  break;\n \t}\n \n@@ -1619,7 +1619,7 @@ gnat_to_gnu_entity (gnat_entity, gnu_expr, definition)\n \t  = TYPE_REFERENCE_TO (gnu_type) = gnu_fat_type;\n \tTYPE_MODE (gnu_type) = BLKmode;\n \tTYPE_ALIGN (gnu_type) = TYPE_ALIGN (tem);\n-\tTYPE_UNCONSTRAINED_ARRAY (gnu_fat_type) = gnu_type;\n+\tSET_TYPE_UNCONSTRAINED_ARRAY (gnu_fat_type, gnu_type);\n \n \t/* If the maximum size doesn't overflow, use it.  */\n \tif (TREE_CODE (gnu_max_size) == INTEGER_CST\n@@ -1647,7 +1647,7 @@ gnat_to_gnu_entity (gnat_entity, gnu_expr, definition)\n \tDECL_FIELD_OFFSET (TREE_CHAIN (TYPE_FIELDS (tem))) = size_zero_node;\n \tDECL_FIELD_BIT_OFFSET (TREE_CHAIN (TYPE_FIELDS (tem)))\n \t  = bitsize_zero_node;\n-\tTYPE_UNCONSTRAINED_ARRAY (tem) = gnu_type;\n+\tSET_TYPE_UNCONSTRAINED_ARRAY (tem, gnu_type);\n \tTYPE_OBJECT_RECORD_TYPE (gnu_type) = tem;\n \n \t/* Give the thin pointer type a name.  */\n@@ -2066,18 +2066,18 @@ gnat_to_gnu_entity (gnat_entity, gnu_expr, definition)\n \t\t  TYPE_HAS_ACTUAL_BOUNDS_P (gnu_inner_type) = 1;\n \t\t}\n \n-\t      TYPE_ACTUAL_BOUNDS (gnu_inner_type) = NULL_TREE;\n+\t      SET_TYPE_ACTUAL_BOUNDS (gnu_inner_type, NULL_TREE);\n \n \t      for (gnat_index = First_Index (gnat_entity);\n \t\t   Present (gnat_index); gnat_index = Next_Index (gnat_index))\n-\t\tTYPE_ACTUAL_BOUNDS (gnu_inner_type)\n-\t\t  = tree_cons (NULL_TREE,\n+\t\tSET_TYPE_ACTUAL_BOUNDS (gnu_inner_type,\n+\t\t    tree_cons (NULL_TREE,\n \t\t\t       get_unpadded_type (Etype (gnat_index)),\n-\t\t\t       TYPE_ACTUAL_BOUNDS (gnu_inner_type));\n+\t\t\t       TYPE_ACTUAL_BOUNDS (gnu_inner_type)));\n \n \t      if (Convention (gnat_entity) != Convention_Fortran)\n-\t\tTYPE_ACTUAL_BOUNDS (gnu_inner_type)\n-\t\t  = nreverse (TYPE_ACTUAL_BOUNDS (gnu_inner_type));\n+\t\tSET_TYPE_ACTUAL_BOUNDS (gnu_inner_type,\n+\t\t    nreverse (TYPE_ACTUAL_BOUNDS (gnu_inner_type)));\n \n \t      if (TREE_CODE (gnu_type) == RECORD_TYPE\n \t\t  && TYPE_LEFT_JUSTIFIED_MODULAR_P (gnu_type))\n@@ -2577,9 +2577,10 @@ gnat_to_gnu_entity (gnat_entity, gnu_expr, definition)\n \n \t\t    DECL_INTERNAL_P (gnu_field)\n \t\t      = DECL_INTERNAL_P (gnu_old_field);\n-\t\t    DECL_ORIGINAL_FIELD (gnu_field)\n-\t\t      = DECL_ORIGINAL_FIELD (gnu_old_field) != 0\n-\t\t\t? DECL_ORIGINAL_FIELD (gnu_old_field) : gnu_old_field;\n+\t\t    SET_DECL_ORIGINAL_FIELD (gnu_field,\n+\t\t        (DECL_ORIGINAL_FIELD (gnu_old_field) != 0\n+\t\t\t ? DECL_ORIGINAL_FIELD (gnu_old_field) \n+\t\t\t : gnu_old_field));\n \t\t    DECL_DISCRIMINANT_NUMBER (gnu_field)\n \t\t      = DECL_DISCRIMINANT_NUMBER (gnu_old_field);\n \t\t    TREE_THIS_VOLATILE (gnu_field)\n@@ -2598,7 +2599,7 @@ gnat_to_gnu_entity (gnat_entity, gnu_expr, definition)\n \t      TYPE_ALIGN (gnu_type) = TYPE_ALIGN (gnu_base_type);\n \t      TYPE_SIZE (gnu_type) = TYPE_SIZE (gnu_base_type);\n \t      TYPE_SIZE_UNIT (gnu_type) = TYPE_SIZE_UNIT (gnu_base_type);\n-\t      TYPE_ADA_SIZE (gnu_type) = TYPE_ADA_SIZE (gnu_base_type);\n+\t      SET_TYPE_ADA_SIZE (gnu_type, TYPE_ADA_SIZE (gnu_base_type));\n \n \t      if (TREE_CODE (TYPE_SIZE (gnu_type)) != INTEGER_CST\n \t\t  && contains_placeholder_p (TYPE_SIZE (gnu_type)))\n@@ -2623,10 +2624,10 @@ gnat_to_gnu_entity (gnat_entity, gnu_expr, definition)\n \t\t  && contains_placeholder_p (TYPE_ADA_SIZE (gnu_type)))\n \t\tfor (gnu_temp = gnu_subst_list;\n \t\t     gnu_temp; gnu_temp = TREE_CHAIN (gnu_temp))\n-\t\t  TYPE_ADA_SIZE (gnu_type)\n-\t\t    = substitute_in_expr (TYPE_ADA_SIZE (gnu_type),\n+\t\t  SET_TYPE_ADA_SIZE (gnu_type,\n+\t\t      substitute_in_expr (TYPE_ADA_SIZE (gnu_type),\n \t\t\t\t\t  TREE_PURPOSE (gnu_temp),\n-\t\t\t\t\t  TREE_VALUE (gnu_temp));\n+\t\t\t\t\t  TREE_VALUE (gnu_temp)));\n \n \t      /* Recompute the mode of this record type now that we know its\n \t\t actual size.  */\n@@ -2816,7 +2817,7 @@ gnat_to_gnu_entity (gnat_entity, gnu_expr, definition)\n \t    if (gnu_type == 0)\n \t      {\n \t\tgnu_type = make_node (RECORD_TYPE);\n-\t\tTYPE_UNCONSTRAINED_ARRAY (gnu_type) = gnu_old;\n+\t\tSET_TYPE_UNCONSTRAINED_ARRAY (gnu_type, gnu_old);\n \t\tTYPE_POINTER_TO (gnu_old) = gnu_type;\n \n \t\tset_lineno (gnat_entity, 0);\n@@ -3670,11 +3671,14 @@ gnat_to_gnu_entity (gnat_entity, gnu_expr, definition)\n \t  if (TREE_CODE (gnu_type) == RECORD_TYPE\n \t      && operand_equal_p (TYPE_ADA_SIZE (gnu_type),\n \t\t\t\t  TYPE_SIZE (gnu_type), 0))\n-\t    TYPE_ADA_SIZE (gnu_type) = TYPE_SIZE (gnu_type)\n-\t      = elaborate_expression_1 (gnat_entity, gnat_entity,\n-\t\t\t\t\tTYPE_SIZE (gnu_type),\n-\t\t\t\t\tget_identifier (\"SIZE\"),\n-\t\t\t\t\tdefinition, 0);\n+\t    {\n+\t      TYPE_SIZE (gnu_type)\n+\t\t= elaborate_expression_1 (gnat_entity, gnat_entity,\n+\t\t\t\t\t  TYPE_SIZE (gnu_type),\n+\t\t\t\t\t  get_identifier (\"SIZE\"),\n+\t\t\t\t\t  definition, 0);\n+\t      SET_TYPE_ADA_SIZE (gnu_type, TYPE_SIZE (gnu_type));\n+\t    }\n \t  else\n \t    {\n \t      TYPE_SIZE (gnu_type)\n@@ -3699,11 +3703,11 @@ gnat_to_gnu_entity (gnat_entity, gnu_expr, definition)\n \t\t   size_int (TYPE_ALIGN (gnu_type) / BITS_PER_UNIT));\n \n \t      if (TREE_CODE (gnu_type) == RECORD_TYPE)\n-\t\tTYPE_ADA_SIZE (gnu_type)\n-\t\t  = elaborate_expression_1 (gnat_entity, gnat_entity,\n+\t\tSET_TYPE_ADA_SIZE (gnu_type,\n+\t\t    elaborate_expression_1 (gnat_entity, gnat_entity,\n \t\t\t\t\t    TYPE_ADA_SIZE (gnu_type),\n \t\t\t\t\t    get_identifier (\"RM_SIZE\"),\n-\t\t\t\t\t    definition, 0);\n+\t\t\t\t\t    definition, 0));\n \t    }\n \t}\n \n@@ -4040,7 +4044,7 @@ substitution_list (gnat_subtype, gnat_type, gnu_list, definition)\n /* For the following two functions: for each GNAT entity, the GCC\n    tree node used as a dummy for that entity, if any.  */\n \n-static tree *dummy_node_table;\n+static GTY((length (\"max_gnat_nodes\"))) tree * dummy_node_table;\n \n /* Initialize the above table.  */\n \n@@ -4049,8 +4053,7 @@ init_dummy_type ()\n {\n   Node_Id gnat_node;\n \n-  dummy_node_table = (tree *) xmalloc (max_gnat_nodes * sizeof (tree));\n-  ggc_add_tree_root (dummy_node_table, max_gnat_nodes);\n+  dummy_node_table = (tree *) ggc_alloc (max_gnat_nodes * sizeof (tree));\n \n   for (gnat_node = 0; gnat_node < max_gnat_nodes; gnat_node++)\n     dummy_node_table[gnat_node] = NULL_TREE;\n@@ -4447,9 +4450,9 @@ make_packable_type (type)\n \t\t\t     ! DECL_NONADDRESSABLE_P (old_field));\n \n       DECL_INTERNAL_P (new_field) = DECL_INTERNAL_P (old_field);\n-      DECL_ORIGINAL_FIELD (new_field)\n-\t= (DECL_ORIGINAL_FIELD (old_field) != 0\n-\t   ? DECL_ORIGINAL_FIELD (old_field) : old_field);\n+      SET_DECL_ORIGINAL_FIELD (new_field,\n+\t  (DECL_ORIGINAL_FIELD (old_field) != 0\n+\t   ? DECL_ORIGINAL_FIELD (old_field) : old_field));\n       TREE_CHAIN (new_field) = field_list;\n       field_list = new_field;\n     }\n@@ -4583,7 +4586,7 @@ maybe_pad_type (type, size, align, gnat_entity, name_trailer,\n \n   /* Keep the RM_Size of the padded record as that of the old record\n      if requested.  */\n-  TYPE_ADA_SIZE (record) = same_rm_size ? size : rm_size (type);\n+  SET_TYPE_ADA_SIZE (record, same_rm_size ? size : rm_size (type));\n \n   /* Unless debugging information isn't being written for the input type,\n      write a record that shows what we are a subtype of and also make a\n@@ -5696,12 +5699,12 @@ set_rm_size (uint_size, gnu_type, gnat_entity)\n       && Is_Discrete_Or_Fixed_Point_Type (gnat_entity))\n     TYPE_RM_SIZE_INT (gnu_type) = size;\n   else if (TREE_CODE (gnu_type) == ENUMERAL_TYPE)\n-    TYPE_RM_SIZE_ENUM (gnu_type) = size;\n+    SET_TYPE_RM_SIZE_ENUM (gnu_type, size);\n   else if ((TREE_CODE (gnu_type) == RECORD_TYPE\n \t    || TREE_CODE (gnu_type) == UNION_TYPE\n \t    || TREE_CODE (gnu_type) == QUAL_UNION_TYPE)\n \t   && ! TYPE_IS_FAT_POINTER_P (gnu_type))\n-    TYPE_ADA_SIZE (gnu_type) = size;\n+    SET_TYPE_ADA_SIZE (gnu_type, size);\n }\n \f\n /* Given a type TYPE, return a new type whose size is appropriate for SIZE.\n@@ -5935,8 +5938,8 @@ gnat_substitute_in_type (t, f, r)\n \n \t  new = build_range_type (TREE_TYPE (t), low, high);\n \t  if (TYPE_INDEX_TYPE (t))\n-\t    TYPE_INDEX_TYPE (new)\n-\t      = gnat_substitute_in_type (TYPE_INDEX_TYPE (t), f, r);\n+\t    SET_TYPE_INDEX_TYPE (new, \n+\t        gnat_substitute_in_type (TYPE_INDEX_TYPE (t), f, r));\n \t  return new;\n \t}\n \n@@ -6056,9 +6059,9 @@ gnat_substitute_in_type (t, f, r)\n \t      }\n \n \t    DECL_CONTEXT (new_field) = new;\n-\t    DECL_ORIGINAL_FIELD (new_field)\n-\t      = DECL_ORIGINAL_FIELD (field) != 0\n-\t\t? DECL_ORIGINAL_FIELD (field) : field;\n+\t    SET_DECL_ORIGINAL_FIELD (new_field,\n+\t       (DECL_ORIGINAL_FIELD (field) != 0\n+\t\t? DECL_ORIGINAL_FIELD (field) : field));\n \n \t    /* If the size of the old field was set at a constant,\n \t       propagate the size in case the type's size was variable.\n@@ -6121,7 +6124,7 @@ gnat_substitute_in_type (t, f, r)\n \t  {\n \t    TYPE_SIZE (new) = TYPE_SIZE (t);\n \t    TYPE_SIZE_UNIT (new) = TYPE_SIZE_UNIT (t);\n-\t    TYPE_ADA_SIZE (new) = TYPE_ADA_SIZE (t);\n+\t    SET_TYPE_ADA_SIZE (new, TYPE_ADA_SIZE (t));\n \t  }\n \n \treturn new;\n@@ -6209,3 +6212,5 @@ concat_id_with_name (gnu_id, suffix)\n   strcpy (Name_Buffer + len, suffix);\n   return get_identifier (Name_Buffer);\n }\n+\n+#include \"gt-ada-decl.h\""}, {"sha": "586b1fee9cf952bb33d7db7e39b273ae94485979", "filename": "gcc/ada/gigi.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fada%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fada%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgigi.h?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -159,7 +159,7 @@ extern const char *ref_filename;\n /* List of TREE_LIST nodes representing a block stack.  TREE_VALUE\n    of each gives the variable used for the setjmp buffer in the current\n    block, if any.  */\n-extern tree gnu_block_stack;\n+extern GTY(()) tree gnu_block_stack;\n \n /* This is the main program of the back-end.  It sets up all the table\n    structures and then generates code.  */\n@@ -348,8 +348,8 @@ enum standard_datatypes\n   ADT_raise_nodefer_decl,\n   ADT_LAST};\n \n-extern tree gnat_std_decls[(int) ADT_LAST];\n-extern tree gnat_raise_decls[(int) LAST_REASON_CODE + 1];\n+extern GTY(()) tree gnat_std_decls[(int) ADT_LAST];\n+extern GTY(()) tree gnat_raise_decls[(int) LAST_REASON_CODE + 1];\n \n #define longest_float_type_node gnat_std_decls[(int) ADT_longest_float_type]\n #define void_type_decl_node gnat_std_decls[(int) ADT_void_type_decl]"}, {"sha": "d1df13cc409da4c4302fa168432ebd1e8b4f2a0b", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -8,7 +8,7 @@\n @c                                                                            o\n @c                              G N A T _ RM                                  o\n @c                                                                            o\n-@c                            $Revision: 1.6 $\n+@c                            $Revision: 1.3.8.1 $\n @c                                                                            o\n @c              Copyright (C) 1995-2002 Free Software Foundation              o\n @c                                                                            o"}, {"sha": "a03a216d78d1eebf098971f3358dcd0cf44f58fa", "filename": "gcc/ada/misc.c", "status": "modified", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fada%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fada%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmisc.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -86,7 +86,6 @@ static const char *gnat_printable_name\tPARAMS  ((tree, int));\n static tree gnat_eh_runtime_type\tPARAMS ((tree));\n static int gnat_eh_type_covers\t\tPARAMS ((tree, tree));\n static void gnat_parse_file\t\tPARAMS ((int));\n-static void gnat_mark_tree\t\tPARAMS ((tree));\n static rtx gnat_expand_expr\t\tPARAMS ((tree, rtx, enum machine_mode,\n \t\t\t\t\t\t int));\n \n@@ -104,8 +103,6 @@ static rtx gnat_expand_expr\t\tPARAMS ((tree, rtx, enum machine_mode,\n #define LANG_HOOKS_DECODE_OPTION\tgnat_decode_option\n #undef LANG_HOOKS_PARSE_FILE\n #define LANG_HOOKS_PARSE_FILE\t\tgnat_parse_file\n-#undef LANG_HOOKS_MARK_TREE\n-#define LANG_HOOKS_MARK_TREE\t\tgnat_mark_tree\n #undef LANG_HOOKS_HONOR_READONLY\n #define LANG_HOOKS_HONOR_READONLY\t1\n #undef LANG_HOOKS_FINISH_INCOMPLETE_DECL\n@@ -289,53 +286,6 @@ gnat_init_options ()\n   gnat_argc = 1;\n }\n \n-static void\n-gnat_mark_tree (t)\n-     tree t;\n-{\n-  switch (TREE_CODE (t))\n-    {\n-    case FUNCTION_TYPE:\n-      ggc_mark_tree (TYPE_CI_CO_LIST (t));\n-      return;\n-\n-    case INTEGER_TYPE:\n-      if (TYPE_MODULAR_P (t))\n-\tggc_mark_tree (TYPE_MODULUS (t));\n-      else if (TYPE_VAX_FLOATING_POINT_P (t))\n-\t;\n-      else if (TYPE_HAS_ACTUAL_BOUNDS_P (t))\n-\tggc_mark_tree (TYPE_ACTUAL_BOUNDS (t));\n-      else\n-\tggc_mark_tree (TYPE_INDEX_TYPE (t));\n-      return;\n-\n-    case ENUMERAL_TYPE:\n-      ggc_mark_tree (TYPE_RM_SIZE_ENUM (t));\n-      return;\n-\n-    case ARRAY_TYPE:\n-      ggc_mark_tree (TYPE_ACTUAL_BOUNDS (t));\n-      return;\n-\n-    case RECORD_TYPE:  case UNION_TYPE:  case QUAL_UNION_TYPE:\n-      /* This is really TYPE_UNCONSTRAINED_ARRAY for fat pointers.  */\n-      ggc_mark_tree (TYPE_ADA_SIZE (t));\n-      return;\n-\n-    case CONST_DECL:\n-      ggc_mark_tree (DECL_CONST_CORRESPONDING_VAR (t));\n-      return;\n-\n-    case FIELD_DECL:\n-      ggc_mark_tree (DECL_ORIGINAL_FIELD (t));\n-      return;\n-\n-    default:\n-      return;\n-    }\n-}\n-\n /* Here is the function to handle the compiler error processing in GCC.  */\n \n static void"}, {"sha": "4cb9f02dc54e2d03bac46fa1e5afd19ecd1782a2", "filename": "gcc/ada/prj-makr.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fada%2Fprj-makr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fada%2Fprj-makr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-makr.adb?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -6,7 +6,6 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                            $Revision$\n --                                                                          --\n --          Copyright (C) 2001-2002 Free Software Foundation, Inc.          --\n --                                                                          --"}, {"sha": "7d0279858c82d30d1c6e8c81eb3903061a280a3c", "filename": "gcc/ada/prj-makr.ads", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fada%2Fprj-makr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fada%2Fprj-makr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-makr.ads?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -6,7 +6,6 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---                            $Revision$\n --                                                                          --\n --             Copyright (C) 2001-2002 Free Software Foundation, Inc.       --\n --                                                                          --"}, {"sha": "143eefa8d8851489a31bbc1087d00ec1679246e5", "filename": "gcc/ada/prj-pp.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fada%2Fprj-pp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fada%2Fprj-pp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-pp.adb?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -6,7 +6,6 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                            $Revision$\n --                                                                          --\n --             Copyright (C) 2001-2002 Free Software Foundation, Inc.       --\n --                                                                          --"}, {"sha": "ef859cf674b355e9d4447bc41190d397b79bfbe8", "filename": "gcc/ada/prj-pp.ads", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fada%2Fprj-pp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fada%2Fprj-pp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-pp.ads?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -6,7 +6,6 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---                            $Revision$\n --                                                                          --\n --             Copyright (C) 2001 Free Software Foundation, Inc.            --\n --                                                                          --"}, {"sha": "2fafd48de8ef100c46eb1c7cdc4234cd58235459", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -86,7 +86,7 @@ tree gnu_block_stack;\n    variables.  TREE_VALUE is the VAR_DECL that stores the address of\n    the raised exception.  Nonzero means we are in an exception\n    handler.  Not used in the zero-cost case.  */\n-static tree gnu_except_ptr_stack;\n+static GTY(()) tree gnu_except_ptr_stack;\n \n /* Map GNAT tree codes to GCC tree codes for simple expressions.  */\n static enum tree_code gnu_codes[Number_Node_Kinds];\n@@ -96,7 +96,7 @@ Node_Id error_gnat_node;\n \n /* Variable that stores a list of labels to be used as a goto target instead of\n    a return in some functions.  See processing for N_Subprogram_Body.  */\n-static tree gnu_return_label_stack;\n+static GTY(()) tree gnu_return_label_stack;\n \n static tree tree_transform\t\tPARAMS((Node_Id));\n static void elaborate_all_entities\tPARAMS((Node_Id));\n@@ -188,9 +188,6 @@ gigi (gnat_root, max_gnat_node, number_name, nodes_ptr, next_node_ptr,\n   save_gnu_tree (Base_Type (standard_integer),\n \t\t TYPE_NAME (integer_type_node), 0);\n \n-  ggc_add_tree_root (&gnu_block_stack, 1);\n-  ggc_add_tree_root (&gnu_except_ptr_stack, 1);\n-  ggc_add_tree_root (&gnu_return_label_stack, 1);\n   gnu_except_ptr_stack = tree_cons (NULL_TREE, NULL_TREE, NULL_TREE);\n \n   dconstp5 = REAL_VALUE_ATOF (\"0.5\", DFmode);\n@@ -2318,7 +2315,7 @@ tree_transform (gnat_node)\n \t  {\n \t    tree gnu_loop_id = make_node (GNAT_LOOP_ID);\n \n-\t    TREE_LOOP_ID (gnu_loop_id) = (rtx) loop_id;\n+\t    TREE_LOOP_ID (gnu_loop_id) = loop_id;\n \t    save_gnu_tree (Entity (Identifier (gnat_node)), gnu_loop_id, 1);\n \t  }\n \n@@ -2407,8 +2404,7 @@ tree_transform (gnat_node)\n \n \tif (Present (Name (gnat_node)))\n \t  loop_id\n-\t    = (struct nesting *)\n-\t      TREE_LOOP_ID (get_gnu_tree (Entity (Name (gnat_node))));\n+\t    = TREE_LOOP_ID (get_gnu_tree (Entity (Name (gnat_node))));\n \n \tif (Present (Condition (gnat_node)))\n \t  gnu_cond = invert_truthvalue (gnat_truthvalue_conversion\n@@ -5589,3 +5585,5 @@ init_code_table ()\n   gnu_codes[N_Op_Shift_Right] = RSHIFT_EXPR;\n   gnu_codes[N_Op_Shift_Right_Arithmetic] = RSHIFT_EXPR;\n }\n+\n+#include \"gt-ada-trans.h\""}, {"sha": "11cee7568d46911a6e1d5cf51e2dec3c79523dc7", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 28, "deletions": 62, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -33,6 +33,7 @@\n #include \"toplev.h\"\n #include \"output.h\"\n #include \"ggc.h\"\n+#include \"debug.h\"\n #include \"convert.h\"\n \n #include \"ada.h\"\n@@ -69,29 +70,33 @@ tree gnat_raise_decls[(int) LAST_REASON_CODE + 1];\n /* Associates a GNAT tree node to a GCC tree node. It is used in\n    `save_gnu_tree', `get_gnu_tree' and `present_gnu_tree'. See documentation\n    of `save_gnu_tree' for more info.  */\n-static tree *associate_gnat_to_gnu;\n+static GTY((length (\"max_gnat_nodes\"))) tree *associate_gnat_to_gnu;\n \n /* This listhead is used to record any global objects that need elaboration.\n    TREE_PURPOSE is the variable to be elaborated and TREE_VALUE is the\n    initial value to assign.  */\n \n-static tree pending_elaborations;\n+static GTY(()) tree pending_elaborations;\n \n /* This stack allows us to momentarily switch to generating elaboration\n    lists for an inner context.  */\n \n-static struct e_stack {struct e_stack *next; tree elab_list; } *elist_stack;\n+struct e_stack GTY(()) {\n+  struct e_stack *next; \n+  tree elab_list; \n+};\n+static GTY(()) struct e_stack *elist_stack;\n \n /* This variable keeps a table for types for each precision so that we only \n    allocate each of them once. Signed and unsigned types are kept separate.\n \n    Note that these types are only used when fold-const requests something\n    special.  Perhaps we should NOT share these types; we'll see how it\n    goes later.  */\n-static tree signed_and_unsigned_types[2 * MAX_BITS_PER_WORD + 1][2];\n+static GTY(()) tree signed_and_unsigned_types[2 * MAX_BITS_PER_WORD + 1][2];\n \n /* Likewise for float types, but record these by mode.  */\n-static tree float_types[NUM_MACHINE_MODES];\n+static GTY(()) tree float_types[NUM_MACHINE_MODES];\n \n /* For each binding contour we allocate a binding_level structure which records\n    the entities defined or declared in that contour. Contours include:\n@@ -102,7 +107,7 @@ static tree float_types[NUM_MACHINE_MODES];\n \n    Binding contours are used to create GCC tree BLOCK nodes.  */\n \n-struct binding_level\n+struct binding_level GTY(())\n {\n   /* A chain of ..._DECL nodes for all variables, constants, functions,\n      parameters and type declarations.  These ..._DECL nodes are chained\n@@ -121,10 +126,10 @@ struct binding_level\n };\n \n /* The binding level currently in effect.  */\n-static struct binding_level *current_binding_level = NULL;\n+static GTY(()) struct binding_level *current_binding_level;\n \n /* A chain of binding_level structures awaiting reuse.  */\n-static struct binding_level *free_binding_level = NULL;\n+static GTY((deletable (\"\"))) struct binding_level *free_binding_level;\n \n /* The outermost binding level. This binding level is created when the\n    compiler is started and it will exist through the entire compilation.  */\n@@ -133,6 +138,11 @@ static struct binding_level *global_binding_level;\n /* Binding level structures are initialized by copying this one.  */\n static struct binding_level clear_binding_level = {NULL, NULL, NULL, NULL};\n \n+struct language_function GTY(())\n+{\n+  int unused;\n+};\n+\n static tree merge_sizes\t\t\tPARAMS ((tree, tree, tree, int, int));\n static tree compute_related_constant\tPARAMS ((tree, tree));\n static tree split_plus\t\t\tPARAMS ((tree, tree *));\n@@ -142,8 +152,6 @@ static tree convert_to_fat_pointer\tPARAMS ((tree, tree));\n static tree convert_to_thin_pointer\tPARAMS ((tree, tree));\n static tree make_descriptor_field\tPARAMS ((const char *,tree, tree,\n \t\t\t\t\t\t tree));\n-static void mark_binding_level\t\tPARAMS ((PTR));\n-static void mark_e_stack\t  \tPARAMS ((PTR));\n \f\n /* Initialize the association of GNAT nodes to GCC trees.  */\n \n@@ -152,22 +160,12 @@ init_gnat_to_gnu ()\n {\n   Node_Id gnat_node;\n \n-  associate_gnat_to_gnu = (tree *) xmalloc (max_gnat_nodes * sizeof (tree));\n-  ggc_add_tree_root (associate_gnat_to_gnu, max_gnat_nodes);\n+  associate_gnat_to_gnu = (tree *) ggc_alloc (max_gnat_nodes * sizeof (tree));\n \n   for (gnat_node = 0; gnat_node < max_gnat_nodes; gnat_node++)\n     associate_gnat_to_gnu[gnat_node] = NULL_TREE;\n \n   pending_elaborations = build_tree_list (NULL_TREE, NULL_TREE);\n-  ggc_add_tree_root (&pending_elaborations, 1);\n-  ggc_add_root ((PTR) &elist_stack, 1, sizeof (struct e_stack), mark_e_stack);\n-  ggc_add_tree_root (&signed_and_unsigned_types[0][0],\n-\t\t     (sizeof signed_and_unsigned_types\n-\t\t      / sizeof signed_and_unsigned_types[0][0]));\n-  ggc_add_tree_root (float_types, ARRAY_SIZE (float_types));\n-\n-  ggc_add_root (&current_binding_level, 1, sizeof current_binding_level,\n-\t\tmark_binding_level);\n }\n \n /* GNAT_ENTITY is a GNAT tree node for an entity.   GNU_DECL is the GCC tree\n@@ -260,7 +258,7 @@ pushlevel (ignore)\n     }\n   else\n     newlevel\n-      = (struct binding_level *) xmalloc (sizeof (struct binding_level));\n+      = (struct binding_level *) ggc_alloc (sizeof (struct binding_level));\n \n   *newlevel = clear_binding_level;\n \n@@ -680,9 +678,6 @@ init_gigi_decls (long_long_float_type, exception_type)\n   DECL_FUNCTION_CODE (setjmp_decl) = BUILT_IN_SETJMP;\n \n   main_identifier_node = get_identifier (\"main\");\n-\n-  ggc_add_tree_root (gnat_std_decls, ARRAY_SIZE (gnat_std_decls));\n-  ggc_add_tree_root (gnat_raise_decls, ARRAY_SIZE (gnat_raise_decls));\n }\n \f\n /* This function is called indirectly from toplev.c to handle incomplete \n@@ -849,7 +844,7 @@ finish_record_type (record_type, fieldlist, has_rep, defer_debug)\n   /* Now set any of the values we've just computed that apply.  */\n   if (! TYPE_IS_FAT_POINTER_P (record_type)\n       && ! TYPE_CONTAINS_TEMPLATE_P (record_type))\n-    TYPE_ADA_SIZE (record_type) = ada_size;\n+    SET_TYPE_ADA_SIZE (record_type, ada_size);\n \n #ifdef ROUND_TYPE_SIZE\n   size = ROUND_TYPE_SIZE (record_type, size, TYPE_ALIGN (record_type));\n@@ -1159,7 +1154,7 @@ create_subprog_type (return_type, param_decl_list, cico_list,\n       || TYPE_RETURNS_BY_REF_P (type) != returns_by_ref)\n     type = copy_type (type);\n \n-  TYPE_CI_CO_LIST (type) = cico_list;\n+  SET_TYPE_CI_CO_LIST (type, cico_list);\n   TYPE_RETURNS_UNCONSTRAINED_P (type) = returns_unconstrained;\n   TYPE_RETURNS_STACK_DEPRESSED (type) = returns_with_dsp;\n   TYPE_RETURNS_BY_REF_P (type) = returns_by_ref;\n@@ -1207,7 +1202,7 @@ create_index_type (min, max, index)\n   else if (TYPE_INDEX_TYPE (type) != 0)\n     type = copy_type (type);\n \n-  TYPE_INDEX_TYPE (type) = index;\n+  SET_TYPE_INDEX_TYPE (type, index);\n   return type;\n }\n \f\n@@ -1598,37 +1593,6 @@ get_pending_elaborations ()\n   return result;\n }\n \n-/* Mark the binding level stack.  */\n-\n-static void\n-mark_binding_level (arg)\n-     PTR arg;\n-{\n-  struct binding_level *level = *(struct binding_level **) arg;\n-\n-  for (; level != 0; level = level->level_chain)\n-    {\n-      ggc_mark_tree (level->names);\n-      ggc_mark_tree (level->blocks);\n-      ggc_mark_tree (level->this_block);\n-    }\n-}\n-\n-/* Mark the pending elaboration list.  */\n-\n-static void\n-mark_e_stack (data)\n-     PTR data;\n-{\n-  struct e_stack *p = *((struct e_stack **) data);\n-\n-  if (p != 0)\n-    {\n-      ggc_mark_tree (p->elab_list);\n-      mark_e_stack (&p->next);\n-    }\n-}\n-\n /* Return nonzero if there are pending elaborations.  */\n \n int\n@@ -1643,7 +1607,7 @@ pending_elaborations_p ()\n void\n push_pending_elaborations ()\n {\n-  struct e_stack *p = (struct e_stack *) xmalloc (sizeof (struct e_stack));\n+  struct e_stack *p = (struct e_stack *) ggc_alloc (sizeof (struct e_stack));\n \n   p->next = elist_stack;\n   p->elab_list = pending_elaborations;\n@@ -1660,7 +1624,6 @@ pop_pending_elaborations ()\n \n   pending_elaborations = p->elab_list;\n   elist_stack = p->next;\n-  free (p);\n }\n \n /* Return the current position in pending_elaborations so we can insert\n@@ -2666,7 +2629,7 @@ update_pointer_to (old_type, new_type)\n \t\t\t\t  TREE_CHAIN (TYPE_FIELDS (ptr)), new_ref));\n \n       for (var = TYPE_MAIN_VARIANT (ptr); var; var = TYPE_NEXT_VARIANT (var))\n-\tTYPE_UNCONSTRAINED_ARRAY (var) = new_type;\n+\tSET_TYPE_UNCONSTRAINED_ARRAY (var, new_type);\n \n       TYPE_POINTER_TO (new_type) = TYPE_REFERENCE_TO (new_type)\n \t= TREE_TYPE (new_type) = ptr;\n@@ -3366,3 +3329,6 @@ unchecked_convert (type, expr)\n \n   return expr;\n }\n+\n+#include \"gt-ada-utils.h\"\n+#include \"gtype-ada.h\""}, {"sha": "e3627a28e5e47ddf75d6886923d0c2af39f16be0", "filename": "gcc/ada/utils2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fada%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fada%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils2.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -514,7 +514,7 @@ nonbinary_modular_operation (op_code, type, lhs, rhs)\n       /* Copy the node so we ensure it can be modified to make it modular.  */\n       op_type = copy_node (gnat_type_for_size (precision, unsignedp));\n       modulus = convert (op_type, modulus);\n-      TYPE_MODULUS (op_type) = modulus;\n+      SET_TYPE_MODULUS (op_type, modulus);\n       TYPE_MODULAR_P (op_type) = 1;\n       lhs = convert (op_type, lhs);\n       rhs = convert (op_type, rhs);\n@@ -530,7 +530,7 @@ nonbinary_modular_operation (op_code, type, lhs, rhs)\n     {\n       tree div_type = copy_node (gnat_type_for_size (needed_precision, 1));\n       modulus = convert (div_type, modulus);\n-      TYPE_MODULUS (div_type) = modulus;\n+      SET_TYPE_MODULUS (div_type, modulus);\n       TYPE_MODULAR_P (div_type) = 1;\n       result = convert (op_type,\n \t\t\tfold (build (TRUNC_MOD_EXPR, div_type,"}, {"sha": "c528fcf15520a6d7c29fea5d06a944041d41e154", "filename": "gcc/alias.c", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -152,7 +152,7 @@ static int nonlocal_set_p               PARAMS ((rtx));\n    current function performs nonlocal memory memory references for the\n    purposes of marking the function as a constant function.  */\n \n-static rtx *reg_base_value;\n+static GTY((length (\"reg_base_value_size\"))) rtx *reg_base_value;\n static rtx *new_reg_base_value;\n static unsigned int reg_base_value_size; /* size of reg_base_value array */\n \n@@ -2663,8 +2663,8 @@ init_alias_analysis ()\n      optimization.  Loop unrolling can create a large number of\n      registers.  */\n   reg_base_value_size = maxreg * 2;\n-  reg_base_value = (rtx *) xcalloc (reg_base_value_size, sizeof (rtx));\n-  ggc_add_rtx_root (reg_base_value, reg_base_value_size);\n+  reg_base_value = (rtx *) ggc_alloc_cleared (reg_base_value_size\n+\t\t\t\t\t      * sizeof (rtx));\n \n   new_reg_base_value = (rtx *) xmalloc (reg_base_value_size * sizeof (rtx));\n   reg_seen = (char *) xmalloc (reg_base_value_size);\n@@ -2878,16 +2878,13 @@ end_alias_analysis ()\n   reg_known_value_size = 0;\n   free (reg_known_equiv_p + FIRST_PSEUDO_REGISTER);\n   reg_known_equiv_p = 0;\n-  if (reg_base_value)\n-    {\n-      ggc_del_root (reg_base_value);\n-      free (reg_base_value);\n-      reg_base_value = 0;\n-    }\n+  reg_base_value = 0;\n   reg_base_value_size = 0;\n   if (alias_invariant)\n     {\n       free (alias_invariant);\n       alias_invariant = 0;\n     }\n }\n+\n+#include \"gt-alias.h\""}, {"sha": "7de4c7c088a8524cff77a7fb163d013c20f15dfa", "filename": "gcc/basic-block.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -33,7 +33,7 @@ typedef bitmap_head regset_head;\n typedef bitmap regset;\n \n /* Initialize a new regset.  */\n-#define INIT_REG_SET(HEAD) bitmap_initialize (HEAD)\n+#define INIT_REG_SET(HEAD) bitmap_initialize (HEAD, 1)\n \n /* Clear a register set by freeing up the linked list.  */\n #define CLEAR_REG_SET(HEAD) bitmap_clear (HEAD)\n@@ -99,7 +99,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define OBSTACK_ALLOC_REG_SET(OBSTACK) BITMAP_OBSTACK_ALLOC (OBSTACK)\n \n /* Initialize a register set.  Returns the new register set.  */\n-#define INITIALIZE_REG_SET(HEAD) bitmap_initialize (&HEAD)\n+#define INITIALIZE_REG_SET(HEAD) bitmap_initialize (&HEAD, 1)\n \n /* Do any cleanup needed on a regset when it is no longer used.  */\n #define FREE_REG_SET(REGSET) BITMAP_FREE(REGSET)"}, {"sha": "e22a524ce17fee65597d782f613e00b89f6d3e73", "filename": "gcc/bitmap.c", "status": "modified", "additions": 85, "deletions": 40, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -23,6 +23,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"rtl.h\"\n #include \"flags.h\"\n #include \"obstack.h\"\n+#include \"ggc.h\"\n #include \"bitmap.h\"\n \n /* Obstack to allocate bitmap elements from.  */\n@@ -40,13 +41,33 @@ static int bitmap_obstack_init = FALSE;\n /* Global data */\n bitmap_element bitmap_zero_bits;\t/* An element of all zero bits.  */\n static bitmap_element *bitmap_free;\t/* Freelist of bitmap elements.  */\n+static GTY((deletable (\"\"))) bitmap_element *bitmap_ggc_free;\n \n+static void bitmap_elem_to_freelist\tPARAMS ((bitmap, bitmap_element *));\n static void bitmap_element_free\t\tPARAMS ((bitmap, bitmap_element *));\n-static bitmap_element *bitmap_element_allocate PARAMS ((void));\n+static bitmap_element *bitmap_element_allocate PARAMS ((bitmap));\n static int bitmap_element_zerop\t\tPARAMS ((bitmap_element *));\n static void bitmap_element_link\t\tPARAMS ((bitmap, bitmap_element *));\n static bitmap_element *bitmap_find_bit\tPARAMS ((bitmap, unsigned int));\n \f\n+/* Add ELEM to the appropriate freelist.  */\n+static INLINE void\n+bitmap_elem_to_freelist (head, elt)\n+     bitmap head;\n+     bitmap_element *elt;\n+{\n+  if (head->using_obstack)\n+    {\n+      elt->next = bitmap_free;\n+      bitmap_free = elt;\n+    }\n+  else\n+    {\n+      elt->next = bitmap_ggc_free;\n+      bitmap_ggc_free = elt;\n+    }\n+}\n+\n /* Free a bitmap element.  Since these are allocated off the\n    bitmap_obstack, \"free\" actually means \"put onto the freelist\".  */\n \n@@ -75,56 +96,68 @@ bitmap_element_free (head, elt)\n       if (head->current)\n \thead->indx = head->current->indx;\n     }\n-\n-  elt->next = bitmap_free;\n-  bitmap_free = elt;\n+  bitmap_elem_to_freelist (head, elt);\n }\n \f\n /* Allocate a bitmap element.  The bits are cleared, but nothing else is.  */\n \n static INLINE bitmap_element *\n-bitmap_element_allocate ()\n+bitmap_element_allocate (head)\n+     bitmap head;\n {\n   bitmap_element *element;\n \n-  if (bitmap_free != 0)\n-    {\n-      element = bitmap_free;\n-      bitmap_free = element->next;\n-    }\n-  else\n+  if (head->using_obstack)\n     {\n-      /* We can't use gcc_obstack_init to initialize the obstack since\n-\t print-rtl.c now calls bitmap functions, and bitmap is linked\n-\t into the gen* functions.  */\n-      if (!bitmap_obstack_init)\n+      if (bitmap_free != 0)\n \t{\n-\t  bitmap_obstack_init = TRUE;\n-\n-\t  /* Let particular systems override the size of a chunk.  */\n+\t  element = bitmap_free;\n+\t  bitmap_free = element->next;\n+\t}\n+      else\n+\t{\n+\t  /* We can't use gcc_obstack_init to initialize the obstack since\n+\t     print-rtl.c now calls bitmap functions, and bitmap is linked\n+\t     into the gen* functions.  */\n+\t  if (!bitmap_obstack_init)\n+\t    {\n+\t      bitmap_obstack_init = TRUE;\n+\t      \n+\t      /* Let particular systems override the size of a chunk.  */\n #ifndef OBSTACK_CHUNK_SIZE\n #define OBSTACK_CHUNK_SIZE 0\n #endif\n-\t  /* Let them override the alloc and free routines too.  */\n+\t      /* Let them override the alloc and free routines too.  */\n #ifndef OBSTACK_CHUNK_ALLOC\n #define OBSTACK_CHUNK_ALLOC xmalloc\n #endif\n #ifndef OBSTACK_CHUNK_FREE\n #define OBSTACK_CHUNK_FREE free\n #endif\n-\n+\t      \n #if !defined(__GNUC__) || (__GNUC__ < 2)\n #define __alignof__(type) 0\n #endif\n-\n-\t  obstack_specify_allocation (&bitmap_obstack, OBSTACK_CHUNK_SIZE,\n-\t\t\t\t      __alignof__ (bitmap_element),\n-\t\t\t\t      (void *(*) PARAMS ((long))) OBSTACK_CHUNK_ALLOC,\n-\t\t\t\t      (void (*) PARAMS ((void *))) OBSTACK_CHUNK_FREE);\n+\t      \n+\t      obstack_specify_allocation (&bitmap_obstack, OBSTACK_CHUNK_SIZE,\n+\t\t\t\t\t  __alignof__ (bitmap_element),\n+\t\t\t\t\t  (void *(*) PARAMS ((long))) OBSTACK_CHUNK_ALLOC,\n+\t\t\t\t\t  (void (*) PARAMS ((void *))) OBSTACK_CHUNK_FREE);\n+\t    }\n+\t  \n+\t  element = (bitmap_element *) obstack_alloc (&bitmap_obstack,\n+\t\t\t\t\t\t      sizeof (bitmap_element));\n \t}\n-\n-      element = (bitmap_element *) obstack_alloc (&bitmap_obstack,\n-\t\t\t\t\t\t  sizeof (bitmap_element));\n+    }\n+  else\n+    {\n+      if (bitmap_ggc_free != NULL)\n+\t{\n+          element = bitmap_ggc_free;\n+          bitmap_ggc_free = element->next;\n+\t}\n+      else\n+\telement = ggc_alloc (sizeof (bitmap_element));\n     }\n \n   memset (element->bits, 0, sizeof (element->bits));\n@@ -232,8 +265,7 @@ bitmap_clear (head)\n   for (element = head->first; element != 0; element = next)\n     {\n       next = element->next;\n-      element->next = bitmap_free;\n-      bitmap_free = element;\n+      bitmap_elem_to_freelist (head, element);\n     }\n \n   head->first = head->current = 0;\n@@ -256,7 +288,7 @@ bitmap_copy (to, from)\n   /* Copy elements in forward direction one at a time */\n   for (from_ptr = from->first; from_ptr; from_ptr = from_ptr->next)\n     {\n-      bitmap_element *to_elt = bitmap_element_allocate ();\n+      bitmap_element *to_elt = bitmap_element_allocate (to);\n \n       to_elt->indx = from_ptr->indx;\n \n@@ -363,7 +395,7 @@ bitmap_set_bit (head, bit)\n \n   if (ptr == 0)\n     {\n-      ptr = bitmap_element_allocate ();\n+      ptr = bitmap_element_allocate (head);\n       ptr->indx = bit / BITMAP_ELEMENT_ALL_BITS;\n       ptr->bits[word_num] = bit_val;\n       bitmap_element_link (head, ptr);\n@@ -594,16 +626,15 @@ bitmap_operation (to, from1, from2, operation)\n \t  changed = 1;\n \t  to_tmp = to_ptr;\n \t  to_ptr = to_ptr->next;\n-\t  to_tmp->next = bitmap_free;\n-\t  bitmap_free = to_tmp;\n+\t  bitmap_elem_to_freelist (to, to_tmp);\n \t}\n       if (to_ptr && to_ptr->indx == indx)\n \t{\n \t  to_tmp = to_ptr;\n \t  to_ptr = to_ptr->next;\n \t}\n       else\n-\tto_tmp = bitmap_element_allocate ();\n+\tto_tmp = bitmap_element_allocate (to);\n \n       /* Do the operation, and if any bits are set, link it into the\n \t linked list.  */\n@@ -638,8 +669,7 @@ bitmap_operation (to, from1, from2, operation)\n \t}\n       else\n \t{\n-\t  to_tmp->next = bitmap_free;\n-\t  bitmap_free = to_tmp;\n+\t  bitmap_elem_to_freelist (to, to_tmp);\n \t}\n     }\n \n@@ -649,8 +679,16 @@ bitmap_operation (to, from1, from2, operation)\n       changed = 1;\n       for (to_tmp = to_ptr; to_tmp->next ; to_tmp = to_tmp->next)\n \tcontinue;\n-      to_tmp->next = bitmap_free;\n-      bitmap_free = to_ptr;\n+      if (to->using_obstack)\n+\t{\n+\t  to_tmp->next = bitmap_free;\n+\t  bitmap_free = to_ptr;\n+\t}\n+      else\n+\t{\n+\t  to_tmp->next = bitmap_ggc_free;\n+\t  bitmap_ggc_free = to_ptr;\n+\t}\n     }\n \n #undef DOIT\n@@ -715,10 +753,15 @@ bitmap_union_of_diff (dst, a, b, c)\n /* Initialize a bitmap header.  */\n \n bitmap\n-bitmap_initialize (head)\n+bitmap_initialize (head, using_obstack)\n      bitmap head;\n+     int using_obstack;\n {\n+  if (head == NULL && ! using_obstack)\n+    head = ggc_alloc (sizeof (*head));\n+  \n   head->first = head->current = 0;\n+  head->using_obstack = using_obstack;\n \n   return head;\n }\n@@ -800,3 +843,5 @@ bitmap_print (file, head, prefix, suffix)\n \t\t\t    });\n   fputs (suffix, file);\n }\n+\n+#include \"gt-bitmap.h\""}, {"sha": "ed402990f11d94f2da17fdcc2e17c28ca91ec8da", "filename": "gcc/bitmap.h", "status": "modified", "additions": 17, "deletions": 20, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.h?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -40,7 +40,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    having to realloc and copy a giant bit array.  The `prev' field is\n    undefined for an element on the free list.  */\n \n-typedef struct bitmap_element_def\n+typedef struct bitmap_element_def GTY(())\n {\n   struct bitmap_element_def *next;\t\t/* Next element.  */\n   struct bitmap_element_def *prev;\t\t/* Previous element.  */\n@@ -49,12 +49,14 @@ typedef struct bitmap_element_def\n } bitmap_element;\n \n /* Head of bitmap linked list.  */\n-typedef struct bitmap_head_def {\n+typedef struct bitmap_head_def GTY(()) {\n   bitmap_element *first;\t/* First element in linked list.  */\n   bitmap_element *current;\t/* Last element looked at.  */\n   unsigned int indx;\t\t/* Index of last element looked at.  */\n-\n-} bitmap_head, *bitmap;\n+  int using_obstack;\t\t/* Are we using an obstack or ggc for\n+                                   allocation?  */\n+} bitmap_head;\n+typedef struct bitmap_head_def *bitmap;\n \n /* Enumeration giving the various operations we support.  */\n enum bitmap_bits {\n@@ -100,10 +102,12 @@ extern void debug_bitmap_file PARAMS ((FILE *, bitmap));\n /* Print a bitmap */\n extern void bitmap_print PARAMS ((FILE *, bitmap, const char *, const char *));\n \n-/* Initialize a bitmap header.  */\n-extern bitmap bitmap_initialize PARAMS ((bitmap));\n+/* Initialize a bitmap header.  If HEAD is NULL, a new header will be\n+   allocated.  USING_OBSTACK indicates how elements should be allocated.  */\n+extern bitmap bitmap_initialize PARAMS ((bitmap head, \n+\t\t\t\t\t int using_obstack));\n \n-/* Release all memory held by bitmaps.  */\n+/* Release all memory used by the bitmap obstack.  */\n extern void bitmap_release_memory PARAMS ((void));\n \n /* A few compatibility/functions macros for compatibility with sbitmaps */\n@@ -117,22 +121,15 @@ extern int bitmap_last_set_bit PARAMS((bitmap));\n \n /* Allocate a bitmap with oballoc.  */\n #define BITMAP_OBSTACK_ALLOC(OBSTACK)\t\t\t\t\\\n-  bitmap_initialize ((bitmap) obstack_alloc (OBSTACK, sizeof (bitmap_head)))\n-\n-/* Allocate a bitmap with alloca.  Note alloca cannot be passed as an\n-   argument to a function, so we set a temporary variable to the value\n-   returned by alloca and pass that variable to bitmap_initialize().\n-   PTR is then set to the value returned from bitmap_initialize() to\n-   avoid having it appear more than once in case it has side effects.  */\n-#define BITMAP_ALLOCA(PTR) \\\n-do { \\\n-  bitmap temp_bitmap_ = (bitmap) alloca (sizeof (bitmap_head)); \\\n-  (PTR) = bitmap_initialize (temp_bitmap_); \\\n-} while (0)\n+  bitmap_initialize ((bitmap) obstack_alloc (OBSTACK, sizeof (bitmap_head)), 1)\n+\n+/* Allocate a bitmap with ggc_alloc.  */\n+#define BITMAP_GGC_ALLOC()\t\t\t\\\n+  bitmap_initialize (NULL, 0)\n \n /* Allocate a bitmap with xmalloc.  */\n #define BITMAP_XMALLOC()                                        \\\n-  bitmap_initialize ((bitmap) xmalloc (sizeof (bitmap_head)))\n+  bitmap_initialize ((bitmap) xmalloc (sizeof (bitmap_head)), 1)\n \n /* Do any cleanup needed on a bitmap when it is no longer used.  */\n #define BITMAP_FREE(BITMAP)\t\t\t\\"}, {"sha": "eaa812d587fdde270ad41c7a095cd1947438d5cf", "filename": "gcc/c-common.c", "status": "modified", "additions": 3, "deletions": 37, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -3750,41 +3750,6 @@ finish_label_address_expr (label)\n   return result;\n }\n \n-/* Mark P (a stmt_tree) for GC.  The use of a `void *' for the\n-   parameter allows this function to be used as a GC-marking\n-   function.  */\n-\n-void\n-mark_stmt_tree (p)\n-     void *p;\n-{\n-  stmt_tree st = (stmt_tree) p;\n-\n-  ggc_mark_tree (st->x_last_stmt);\n-  ggc_mark_tree (st->x_last_expr_type);\n-}\n-\n-/* Mark LD for GC.  */\n-\n-void\n-c_mark_lang_decl (c)\n-     struct c_lang_decl *c ATTRIBUTE_UNUSED;\n-{\n-}\n-\n-/* Mark F for GC.  */\n-\n-void\n-mark_c_language_function (f)\n-     struct language_function *f;\n-{\n-  if (!f)\n-    return;\n-\n-  mark_stmt_tree (&f->x_stmt_tree);\n-  ggc_mark_tree (f->x_scope_stmt_stack);\n-}\n-\n /* Hook used by expand_expr to expand language-specific tree codes.  */\n \n rtx\n@@ -4288,7 +4253,7 @@ enum built_in_attribute\n   ATTR_LAST\n };\n \n-static tree built_in_attributes[(int) ATTR_LAST];\n+static GTY(()) tree built_in_attributes[(int) ATTR_LAST];\n \n static bool c_attrs_initialized = false;\n \n@@ -4570,7 +4535,6 @@ c_init_attributes ()\n #undef DEF_ATTR_IDENT\n #undef DEF_ATTR_TREE_LIST\n #undef DEF_FN_ATTR\n-  ggc_add_tree_root (built_in_attributes, (int) ATTR_LAST);\n   c_attrs_initialized = true;\n }\n \n@@ -5938,3 +5902,5 @@ check_function_arguments_recurse (callback, ctx, param, param_num)\n \n   (*callback) (ctx, param, param_num);\n }\n+\n+#include \"gt-c-common.h\""}, {"sha": "d0523a50051992ca1ac6edc7fb6cc7c063030626", "filename": "gcc/c-common.h", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -183,10 +183,10 @@ enum c_tree_index\n \n /* Identifier part common to the C front ends.  Inherits from\n    tree_identifier, despite appearances.  */\n-struct c_common_identifier\n+struct c_common_identifier GTY(())\n {\n   struct tree_common common;\n-  struct cpp_hashnode node;\n+  struct cpp_hashnode GTY ((skip (\"\"))) node;\n };\n \n #define wchar_type_node\t\t\tc_global_trees[CTI_WCHAR_TYPE]\n@@ -231,7 +231,7 @@ struct c_common_identifier\n /* A node for `((void) 0)'.  */\n #define void_zero_node                  c_global_trees[CTI_VOID_ZERO]\n \n-extern tree c_global_trees[CTI_MAX];\n+extern GTY(()) tree c_global_trees[CTI_MAX];\n \n /* Mark which labels are explicitly declared.\n    These may be shadowed, and may be referenced from nested functions.  */\n@@ -252,7 +252,7 @@ c_language_kind;\n \n /* Information about a statement tree.  */\n \n-struct stmt_tree_s {\n+struct stmt_tree_s GTY(()) {\n   /* The last statement added to the tree.  */\n   tree x_last_stmt;\n   /* The type of the last expression statement.  (This information is\n@@ -282,7 +282,7 @@ typedef struct stmt_tree_s *stmt_tree;\n /* Global state pertinent to the current function.  Some C dialects\n    extend this structure with additional fields.  */\n \n-struct language_function {\n+struct c_language_function GTY(()) {\n   /* While we are parsing the function, this contains information\n      about the statement-tree that we are building.  */\n   struct stmt_tree_s x_stmt_tree;\n@@ -344,7 +344,6 @@ extern tree walk_stmt_tree\t\t\tPARAMS ((tree *,\n \t\t\t\t\t\t\t void *));\n extern void prep_stmt                           PARAMS ((tree));\n extern void expand_stmt                         PARAMS ((tree));\n-extern void mark_stmt_tree                      PARAMS ((void *));\n extern void shadow_warning\t\t\tPARAMS ((const char *,\n \t\t\t\t\t\t\t tree, tree));\n extern tree c_begin_if_stmt\t\t\tPARAMS ((void));\n@@ -357,7 +356,7 @@ extern void c_finish_while_stmt_cond\t\tPARAMS ((tree, tree));\n    structure for FUNCTION_DECLs; all other DECLs have a NULL\n    DECL_LANG_SPECIFIC field.  */\n \n-struct c_lang_decl {\n+struct c_lang_decl GTY(()) {\n   unsigned declared_inline : 1;\n };\n \n@@ -368,8 +367,6 @@ struct c_lang_decl {\n #define DECL_NUM_STMTS(NODE) \\\n   (FUNCTION_DECL_CHECK (NODE)->decl.u1.i)\n \n-extern void c_mark_lang_decl                    PARAMS ((struct c_lang_decl *));\n-\n /* The variant of the C language being processed.  Each C language\n    front-end defines this variable.  */\n \n@@ -869,8 +866,6 @@ extern tree boolean_increment\t\t\tPARAMS ((enum tree_code,\n    after entering or leaving a header file.  */\n extern void extract_interface_info\t\tPARAMS ((void));\n \n-extern void mark_c_language_function            PARAMS ((struct language_function *));\n-\n extern int case_compare                         PARAMS ((splay_tree_key,\n \t\t\t\t\t\t\t splay_tree_key));\n "}, {"sha": "6c16801e4e24126666b1ad958f3e3896196cab1e", "filename": "gcc/c-decl.c", "status": "modified", "additions": 47, "deletions": 133, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -103,21 +103,21 @@ static int current_function_prototype_line;\n \n /* The current statement tree.  */\n \n-static struct stmt_tree_s c_stmt_tree;\n+static GTY(()) struct stmt_tree_s c_stmt_tree;\n \n /* The current scope statement stack.  */\n \n-static tree c_scope_stmt_stack;\n+static GTY(()) tree c_scope_stmt_stack;\n \n /* A list (chain of TREE_LIST nodes) of all LABEL_DECLs in the function\n    that have names.  Here so we can clear out their names' definitions\n    at the end of the function.  */\n \n-static tree named_labels;\n+static GTY(()) tree named_labels;\n \n /* A list of LABEL_DECLs from outer contexts that are currently shadowed.  */\n \n-static tree shadowed_labels;\n+static GTY(()) tree shadowed_labels;\n \n /* Nonzero when store_parm_decls is called indicates a varargs function.\n    Value not meaningful after store_parm_decls.  */\n@@ -164,7 +164,7 @@ static int current_extern_inline;\n /* Note that the information in the `names' component of the global contour\n    is duplicated in the IDENTIFIER_GLOBAL_VALUEs of all identifiers.  */\n \n-struct binding_level\n+struct binding_level GTY(())\n   {\n     /* A chain of _DECL nodes for all variables, constants, functions,\n        and typedef types.  These are in the reverse of the order supplied.\n@@ -229,17 +229,17 @@ struct binding_level\n \n /* The binding level currently in effect.  */\n \n-static struct binding_level *current_binding_level;\n+static GTY(()) struct binding_level *current_binding_level;\n \n /* A chain of binding_level structures awaiting reuse.  */\n \n-static struct binding_level *free_binding_level;\n+static GTY((deletable (\"\"))) struct binding_level *free_binding_level;\n \n /* The outermost binding level, for names of file scope.\n    This is created when the compiler is started and exists\n    through the entire run.  */\n \n-static struct binding_level *global_binding_level;\n+static GTY(()) struct binding_level *global_binding_level;\n \n /* Binding level structures are initialized by copying this one.  */\n \n@@ -262,7 +262,7 @@ static int keep_next_if_subblocks;\n    saved values of named_labels and shadowed_labels for\n    a label binding level outside the current one.  */\n \n-static struct binding_level *label_level_chain;\n+static GTY(()) struct binding_level *label_level_chain;\n \n /* Functions called automatically at the beginning and end of execution.  */\n \n@@ -271,7 +271,7 @@ tree static_ctors, static_dtors;\n /* Forward declarations.  */\n \n static struct binding_level * make_binding_level\tPARAMS ((void));\n-static void mark_binding_level\t\tPARAMS ((void *));\n+static void pop_binding_level\t\tPARAMS ((struct binding_level **));\n static void clear_limbo_values\t\tPARAMS ((tree));\n static int duplicate_decls\t\tPARAMS ((tree, tree, int));\n static int redeclaration_error_message\tPARAMS ((tree, tree));\n@@ -755,13 +755,33 @@ c_finish_incomplete_decl (decl)\n     }\n }\n \f\n-/* Create a new `struct binding_level'.  */\n+/* Reuse or create a struct for this binding level.  */\n \n static struct binding_level *\n make_binding_level ()\n {\n-  /* NOSTRICT */\n-  return (struct binding_level *) xmalloc (sizeof (struct binding_level));\n+  if (free_binding_level)\n+    {\n+      struct binding_level *result = free_binding_level;\n+      free_binding_level = result->level_chain;\n+      return result;\n+    }\n+  else\n+    return (struct binding_level *) ggc_alloc (sizeof (struct binding_level));\n+}\n+\n+/* Remove a binding level from a list and add it to the level chain.  */\n+\n+static void\n+pop_binding_level (lp)\n+     struct binding_level **lp;\n+{\n+  struct binding_level *l = *lp;\n+  *lp = l->level_chain;\n+  \n+  memset (l, 0, sizeof (struct binding_level));\n+  l->level_chain = free_binding_level;\n+  free_binding_level = l;\n }\n \n /* Nonzero if we are currently in the global binding level.  */\n@@ -829,17 +849,7 @@ pushlevel (tag_transparent)\n       named_labels = 0;\n     }\n \n-  /* Reuse or create a struct for this binding level.  */\n-\n-  if (free_binding_level)\n-    {\n-      newlevel = free_binding_level;\n-      free_binding_level = free_binding_level->level_chain;\n-    }\n-  else\n-    {\n-      newlevel = make_binding_level ();\n-    }\n+  newlevel = make_binding_level ();\n \n   /* Add this level to the front of the chain (stack) of levels that\n      are active.  */\n@@ -1060,13 +1070,7 @@ poplevel (keep, reverse, functionbody)\n \n   /* Pop the current level, and free the structure for reuse.  */\n \n-  {\n-    struct binding_level *level = current_binding_level;\n-    current_binding_level = current_binding_level->level_chain;\n-\n-    level->level_chain = free_binding_level;\n-    free_binding_level = level;\n-  }\n+  pop_binding_level (&current_binding_level);\n \n   /* Dispose of the block that we just made inside some higher level.  */\n   if (functionbody)\n@@ -1145,17 +1149,7 @@ push_label_level ()\n {\n   struct binding_level *newlevel;\n \n-  /* Reuse or create a struct for this binding level.  */\n-\n-  if (free_binding_level)\n-    {\n-      newlevel = free_binding_level;\n-      free_binding_level = free_binding_level->level_chain;\n-    }\n-  else\n-    {\n-      newlevel = make_binding_level ();\n-    }\n+  newlevel = make_binding_level ();\n \n   /* Add this level to the front of the chain (stack) of label levels.  */\n \n@@ -1217,9 +1211,7 @@ pop_label_level ()\n   shadowed_labels = level->shadowed;\n \n   /* Pop the current level, and free the structure for reuse.  */\n-  label_level_chain = label_level_chain->level_chain;\n-  level->level_chain = free_binding_level;\n-  free_binding_level = level;\n+  pop_binding_level (&label_level_chain);\n }\n \f\n /* Push a definition or a declaration of struct, union or enum tag \"name\".\n@@ -2864,26 +2856,6 @@ lookup_name_current_level (name)\n   return t;\n }\n \f\n-/* Mark ARG for GC.  */\n-\n-static void\n-mark_binding_level (arg)\n-     void *arg;\n-{\n-  struct binding_level *level = *(struct binding_level **) arg;\n-\n-  for (; level != 0; level = level->level_chain)\n-    {\n-      ggc_mark_tree (level->names);\n-      ggc_mark_tree (level->tags);\n-      ggc_mark_tree (level->shadowed);\n-      ggc_mark_tree (level->blocks);\n-      ggc_mark_tree (level->this_block);\n-      ggc_mark_tree (level->parm_order);\n-      ggc_mark_tree (level->incomplete_list);\n-    }\n-}\n-\n /* Create the predefined scalar types of C,\n    and some nodes representing standard constants (0, 1, (void *) 0).\n    Initialize the global binding level.\n@@ -2937,20 +2909,6 @@ c_init_decl_processing ()\n \n   make_fname_decl = c_make_fname_decl;\n   start_fname_decls ();\n-\n-  /* Record our roots.  */\n-\n-  ggc_add_tree_root (c_global_trees, CTI_MAX);\n-  ggc_add_root (&c_stmt_tree, 1, sizeof c_stmt_tree, mark_stmt_tree);\n-  ggc_add_tree_root (&c_scope_stmt_stack, 1);\n-  ggc_add_tree_root (&named_labels, 1);\n-  ggc_add_tree_root (&shadowed_labels, 1);\n-  ggc_add_root (&current_binding_level, 1, sizeof current_binding_level,\n-\t\tmark_binding_level);\n-  ggc_add_root (&label_level_chain, 1, sizeof label_level_chain,\n-\t\tmark_binding_level);\n-  ggc_add_tree_root (&static_ctors, 1);\n-  ggc_add_tree_root (&static_dtors, 1);\n }\n \n /* Create the VAR_DECL for __FUNCTION__ etc. ID is the name to give the\n@@ -7045,9 +7003,9 @@ check_for_loop_decls ()\n    that keep track of the progress of compilation of the current function.\n    Used for nested functions.  */\n \n-struct c_language_function\n+struct language_function GTY(())\n {\n-  struct language_function base;\n+  struct c_language_function base;\n   tree named_labels;\n   tree shadowed_labels;\n   int returns_value;\n@@ -7065,10 +7023,10 @@ void\n c_push_function_context (f)\n      struct function *f;\n {\n-  struct c_language_function *p;\n-  p = ((struct c_language_function *)\n-       xmalloc (sizeof (struct c_language_function)));\n-  f->language = (struct language_function *) p;\n+  struct language_function *p;\n+  p = ((struct language_function *)\n+       ggc_alloc (sizeof (struct language_function)));\n+  f->language = p;\n \n   p->base.x_stmt_tree = c_stmt_tree;\n   p->base.x_scope_stmt_stack = c_scope_stmt_stack;\n@@ -7088,8 +7046,7 @@ void\n c_pop_function_context (f)\n      struct function *f;\n {\n-  struct c_language_function *p\n-    = (struct c_language_function *) f->language;\n+  struct language_function *p = f->language;\n   tree link;\n \n   /* Bring back all the labels that were shadowed.  */\n@@ -7119,26 +7076,7 @@ c_pop_function_context (f)\n   current_extern_inline = p->extern_inline;\n   current_binding_level = p->binding_level;\n \n-  free (p);\n-  f->language = 0;\n-}\n-\n-/* Mark the language specific parts of F for GC.  */\n-\n-void\n-c_mark_function_context (f)\n-     struct function *f;\n-{\n-  struct c_language_function *p\n-    = (struct c_language_function *) f->language;\n-\n-  if (p == 0)\n-    return;\n-\n-  mark_c_language_function (&p->base);\n-  ggc_mark_tree (p->shadowed_labels);\n-  ggc_mark_tree (p->named_labels);\n-  mark_binding_level (&p->binding_level);\n+  f->language = NULL;\n }\n \n /* Copy the DECL_LANG_SPECIFIC data associated with DECL.  */\n@@ -7158,32 +7096,6 @@ c_dup_lang_specific_decl (decl)\n   DECL_LANG_SPECIFIC (decl) = ld;\n }\n \n-/* Mark the language specific bits in T for GC.  */\n-\n-void\n-c_mark_tree (t)\n-     tree t;\n-{\n-  if (TREE_CODE (t) == IDENTIFIER_NODE)\n-    {\n-      struct lang_identifier *i = (struct lang_identifier *) t;\n-      ggc_mark_tree (i->global_value);\n-      ggc_mark_tree (i->local_value);\n-      ggc_mark_tree (i->label_value);\n-      ggc_mark_tree (i->implicit_decl);\n-      ggc_mark_tree (i->error_locus);\n-      ggc_mark_tree (i->limbo_value);\n-    }\n-  else if (TYPE_P (t) && TYPE_LANG_SPECIFIC (t))\n-    ggc_mark (TYPE_LANG_SPECIFIC (t));\n-  else if (DECL_P (t) && DECL_LANG_SPECIFIC (t))\n-    {\n-      ggc_mark (DECL_LANG_SPECIFIC (t));\n-      c_mark_lang_decl (&DECL_LANG_SPECIFIC (t)->base);\n-      ggc_mark_tree (DECL_LANG_SPECIFIC (t)->pending_sizes);\n-    }\n-}\n-\n /* The functions below are required for functionality of doing\n    function at once processing in the C front end. Currently these\n    functions are not called from anywhere in the C front end, but as\n@@ -7319,3 +7231,5 @@ make_pointer_declarator (type_quals_attrs, target)\n     itarget = tree_cons (attrs, target, NULL_TREE);\n   return build1 (INDIRECT_REF, quals, itarget);\n }\n+\n+#include \"gt-c-decl.h\""}, {"sha": "60588fbd82d78bc075f9c7d9a00b109a35dafaa8", "filename": "gcc/c-lang.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fc-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fc-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lang.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -25,6 +25,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"tree.h\"\n #include \"c-tree.h\"\n #include \"c-common.h\"\n+#include \"ggc.h\"\n #include \"langhooks.h\"\n #include \"langhooks-def.h\"\n \n@@ -49,8 +50,6 @@ static void c_init_options PARAMS ((void));\n #define LANG_HOOKS_GET_ALIAS_SET c_common_get_alias_set\n #undef LANG_HOOKS_SAFE_FROM_P\n #define LANG_HOOKS_SAFE_FROM_P c_safe_from_p\n-#undef LANG_HOOKS_MARK_TREE\n-#define LANG_HOOKS_MARK_TREE c_mark_tree\n #undef LANG_HOOKS_EXPAND_EXPR\n #define LANG_HOOKS_EXPAND_EXPR c_expand_expr\n #undef LANG_HOOKS_MARK_ADDRESSABLE\n@@ -75,8 +74,6 @@ static void c_init_options PARAMS ((void));\n #define LANG_HOOKS_FUNCTION_ENTER_NESTED c_push_function_context\n #undef LANG_HOOKS_FUNCTION_LEAVE_NESTED\n #define LANG_HOOKS_FUNCTION_LEAVE_NESTED c_pop_function_context\n-#undef LANG_HOOKS_FUNCTION_MARK\n-#define LANG_HOOKS_FUNCTION_MARK c_mark_function_context\n #undef LANG_HOOKS_DUP_LANG_SPECIFIC_DECL\n #define LANG_HOOKS_DUP_LANG_SPECIFIC_DECL c_dup_lang_specific_decl\n \n@@ -224,3 +221,5 @@ finish_file ()\n {\n   c_objc_common_finish_file ();\n }\n+\n+#include \"gtype-c.h\""}, {"sha": "1ff2668bed4a075851f32ce140861c6ecc9681e7", "filename": "gcc/c-objc-common.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fc-objc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fc-objc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-objc-common.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -41,7 +41,7 @@ static void expand_deferred_fns PARAMS ((void));\n static tree start_cdtor\tPARAMS ((int));\n static void finish_cdtor PARAMS ((tree));\n \n-static varray_type deferred_fns;\n+static GTY(()) varray_type deferred_fns;\n \n int\n c_missing_noreturn_ok_p (decl)\n@@ -253,7 +253,6 @@ c_objc_common_init (filename)\n     }\n \n   VARRAY_TREE_INIT (deferred_fns, 32, \"deferred_fns\");\n-  ggc_add_tree_varray_root (&deferred_fns, 1);\n \n   return filename;\n }\n@@ -291,7 +290,7 @@ expand_deferred_fns ()\n \t}\n     }\n \n-  VARRAY_FREE (deferred_fns);\n+  deferred_fns = 0;\n }\n \n static tree\n@@ -413,3 +412,5 @@ c_tree_printer (buffer)\n       return 0;\n     }\n }\n+\n+#include \"gt-c-objc-common.h\""}, {"sha": "c5c499cf0488dccf9a876642ecbaf2e15b22f26e", "filename": "gcc/c-parse.in", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -266,17 +266,17 @@ static const char *if_stmt_file;\n static int if_stmt_line;\n \n /* List of types and structure classes of the current declaration.  */\n-static tree current_declspecs = NULL_TREE;\n-static tree prefix_attributes = NULL_TREE;\n+static GTY(()) tree current_declspecs;\n+static GTY(()) tree prefix_attributes;\n \n /* List of all the attributes applying to the identifier currently being\n    declared; includes prefix_attributes and possibly some more attributes\n    just after a comma.  */\n-static tree all_prefix_attributes = NULL_TREE;\n+static GTY(()) tree all_prefix_attributes;\n \n /* Stack of saved values of current_declspecs, prefix_attributes and\n    all_prefix_attributes.  */\n-static tree declspec_stack;\n+static GTY(()) tree declspec_stack;\n \n /* PUSH_DECLSPEC_STACK is called from setspecs; POP_DECLSPEC_STACK\n    should be called from the productions making use of setspecs.  */\n@@ -341,16 +341,11 @@ static inline int _yylex  PARAMS ((void));\n static int  yylex\t  PARAMS ((void));\n static void init_reswords PARAMS ((void));\n \n-/* Add GC roots for variables local to this file.  */\n+  /* Initialisation routine for this file.  */\n void\n c_parse_init ()\n {\n   init_reswords ();\n-\n-  ggc_add_tree_root (&declspec_stack, 1);\n-  ggc_add_tree_root (&current_declspecs, 1);\n-  ggc_add_tree_root (&prefix_attributes, 1);\n-  ggc_add_tree_root (&all_prefix_attributes, 1);\n }\n \n %}\n@@ -3730,8 +3725,6 @@ end ifc\n \t     || (next_type == CPP_NAME && yylexname () == STRING));\n \n       yylval.ttype = combine_strings (strings);\n-\n-      VARRAY_FREE (strings);\n     }\n   else\n     yylval.ttype = orig;\n@@ -3943,3 +3936,5 @@ free_parser_stacks ()\n       free (malloced_yyvs);\n     }\n }\n+\n+#include \"gt-c-parse.h\""}, {"sha": "df9e1bf3c3403b97de4b8d88261791a6f4930f00", "filename": "gcc/c-pragma.c", "status": "modified", "additions": 15, "deletions": 37, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pragma.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -36,20 +36,20 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #define GCC_BAD(msgid) do { warning (msgid); return; } while (0)\n #define GCC_BAD2(msgid, arg) do { warning (msgid, arg); return; } while (0)\n \n-#ifdef HANDLE_PRAGMA_PACK\n-static void handle_pragma_pack PARAMS ((cpp_reader *));\n-\n-#ifdef HANDLE_PRAGMA_PACK_PUSH_POP\n-typedef struct align_stack\n+typedef struct align_stack GTY(())\n {\n   int                  alignment;\n   unsigned int         num_pushes;\n   tree                 id;\n   struct align_stack * prev;\n } align_stack;\n \n-static struct align_stack * alignment_stack = NULL;\n+static GTY(()) struct align_stack * alignment_stack;\n+\n+#ifdef HANDLE_PRAGMA_PACK\n+static void handle_pragma_pack PARAMS ((cpp_reader *));\n \n+#ifdef HANDLE_PRAGMA_PACK_PUSH_POP\n /* If we have a \"global\" #pragma pack(<n>) in effect when the first\n    #pragma pack(push,<n>) is encountered, this stores the value of \n    maximum_field_alignment in effect.  When the final pop_alignment() \n@@ -61,7 +61,6 @@ static int default_alignment;\n \n static void push_alignment PARAMS ((int, tree));\n static void pop_alignment  PARAMS ((tree));\n-static void mark_align_stack PARAMS ((void *));\n \n /* Push an alignment value onto the stack.  */\n static void\n@@ -75,7 +74,7 @@ push_alignment (alignment, id)\n     {\n       align_stack * entry;\n \n-      entry = (align_stack *) xmalloc (sizeof (* entry));\n+      entry = (align_stack *) ggc_alloc (sizeof (* entry));\n \n       entry->alignment  = alignment;\n       entry->num_pushes = 1;\n@@ -137,24 +136,9 @@ pop_alignment (id)\n       else\n \tmaximum_field_alignment = entry->alignment;\n \n-      free (alignment_stack);\n-\n       alignment_stack = entry;\n     }\n }\n-\n-static void\n-mark_align_stack (p)\n-    void *p;\n-{\n-  align_stack *a = *(align_stack **) p;\n-\n-  while (a)\n-    {\n-      ggc_mark_tree (a->id);\n-      a = a->prev;\n-    }\n-}\n #else  /* not HANDLE_PRAGMA_PACK_PUSH_POP */\n #define SET_GLOBAL_ALIGNMENT(ALIGN) (maximum_field_alignment = (ALIGN))\n #define push_alignment(ID, N) \\\n@@ -272,12 +256,12 @@ handle_pragma_pack (dummy)\n }\n #endif  /* HANDLE_PRAGMA_PACK */\n \n+static GTY(()) tree pending_weaks;\n+\n #ifdef HANDLE_PRAGMA_WEAK\n static void apply_pragma_weak PARAMS ((tree, tree));\n static void handle_pragma_weak PARAMS ((cpp_reader *));\n \n-static tree pending_weaks;\n-\n static void\n apply_pragma_weak (decl, value)\n      tree decl, value;\n@@ -363,11 +347,11 @@ maybe_apply_pragma_weak (decl)\n }\n #endif /* HANDLE_PRAGMA_WEAK */\n \n+static GTY(()) tree pending_redefine_extname;\n+\n #ifdef HANDLE_PRAGMA_REDEFINE_EXTNAME\n static void handle_pragma_redefine_extname PARAMS ((cpp_reader *));\n \n-static tree pending_redefine_extname;\n-\n /* #pragma redefined_extname oldname newname */\n static void\n handle_pragma_redefine_extname (dummy)\n@@ -404,11 +388,11 @@ handle_pragma_redefine_extname (dummy)\n }\n #endif\n \n+static GTY(()) tree pragma_extern_prefix;\n+\n #ifdef HANDLE_PRAGMA_EXTERN_PREFIX\n static void handle_pragma_extern_prefix PARAMS ((cpp_reader *));\n \n-static tree pragma_extern_prefix;\n-\n /* #pragma extern_prefix \"prefix\" */\n static void\n handle_pragma_extern_prefix (dummy)\n@@ -500,25 +484,19 @@ init_pragma ()\n #endif\n #ifdef HANDLE_PRAGMA_WEAK\n   cpp_register_pragma (parse_in, 0, \"weak\", handle_pragma_weak);\n-  ggc_add_tree_root (&pending_weaks, 1);\n #endif\n #ifdef HANDLE_PRAGMA_REDEFINE_EXTNAME\n   cpp_register_pragma (parse_in, 0, \"redefine_extname\",\n \t\t       handle_pragma_redefine_extname);\n-  ggc_add_tree_root (&pending_redefine_extname, 1);\n #endif\n #ifdef HANDLE_PRAGMA_EXTERN_PREFIX\n   cpp_register_pragma (parse_in, 0, \"extern_prefix\",\n \t\t       handle_pragma_extern_prefix);\n-  ggc_add_tree_root (&pragma_extern_prefix, 1);\n #endif\n \n #ifdef REGISTER_TARGET_PRAGMAS\n   REGISTER_TARGET_PRAGMAS (parse_in);\n #endif\n-\n-#ifdef HANDLE_PRAGMA_PACK_PUSH_POP\n-  ggc_add_root (&alignment_stack, 1, sizeof(alignment_stack),\n-\t\tmark_align_stack);\n-#endif\n }\n+\n+#include \"gt-c-pragma.h\""}, {"sha": "aff8800d2a5f0a6b98ed7f0b28ccb334a4e50b7a", "filename": "gcc/c-tree.h", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -34,16 +34,31 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    lang_identifier nodes, because some keywords are only special in a\n    particular context.  */\n \n-struct lang_identifier\n+struct lang_identifier GTY(())\n {\n-  struct c_common_identifier ignore;\n-  tree global_value, local_value, label_value, implicit_decl;\n-  tree error_locus, limbo_value;\n+  struct c_common_identifier common_id;\n+  tree global_value;\n+  tree local_value;\n+  tree label_value;\n+  tree implicit_decl;\n+  tree error_locus;\n+  tree limbo_value;\n+};\n+\n+/* The resulting tree type.  */\n+\n+union lang_tree_node \n+  GTY((desc (\"TREE_CODE (&%h.generic) == IDENTIFIER_NODE\")))\n+{\n+  union tree_node GTY ((tag (\"0\"), \n+\t\t\tdesc (\"tree_node_structure (&%h)\"))) \n+    generic;\n+  struct lang_identifier GTY ((tag (\"1\"))) identifier;\n };\n \n /* Language-specific declaration information.  */\n \n-struct lang_decl\n+struct lang_decl GTY(())\n {\n   struct c_lang_decl base;\n   /* The return types and parameter types may have variable size.\n@@ -107,10 +122,10 @@ struct lang_decl\n   (DECL_LANG_SPECIFIC (NODE)->base.declared_inline)\n \n /* In a RECORD_TYPE, a sorted array of the fields of the type.  */\n-struct lang_type\n+struct lang_type GTY(())\n {\n   int len;\n-  tree elts[1];\n+  tree GTY((length (\"%h.len\"))) elts[1];\n };\n \n /* Record whether a type or decl was written with nonconstant size.\n@@ -178,7 +193,6 @@ extern void c_insert_default_attributes\t\tPARAMS ((tree));\n extern void c_init_decl_processing\t\tPARAMS ((void));\n extern void c_dup_lang_specific_decl\t\tPARAMS ((tree));\n extern void c_print_identifier\t\t\tPARAMS ((FILE *, tree, int));\n-extern void c_mark_tree\t\t\t\tPARAMS ((tree));\n extern tree build_array_declarator              PARAMS ((tree, tree, int, int));\n extern tree build_enumerator                    PARAMS ((tree, tree));\n extern int  c_decode_option                     PARAMS ((int, char **));\n@@ -205,7 +219,6 @@ extern tree lookup_name                         PARAMS ((tree));\n extern tree lookup_name_current_level\t\tPARAMS ((tree));\n extern void parmlist_tags_warning               PARAMS ((void));\n extern void pending_xref_error                  PARAMS ((void));\n-extern void c_mark_function_context             PARAMS ((struct function *));\n extern void c_push_function_context             PARAMS ((struct function *));\n extern void c_pop_function_context              PARAMS ((struct function *));\n extern void pop_label_level                     PARAMS ((void));\n@@ -384,7 +397,7 @@ extern int mesg_implicit_function_declaration;\n /* In c-decl.c */\n extern void c_finish_incomplete_decl PARAMS ((tree));\n \n-extern tree static_ctors;\n-extern tree static_dtors;\n+extern GTY(()) tree static_ctors;\n+extern GTY(()) tree static_dtors;\n \n #endif /* ! GCC_C_TREE_H */"}, {"sha": "0d13840d0324658db84a4afd94dc673728d166e1", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 14, "deletions": 57, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -188,12 +188,8 @@ static void alpha_elf_select_rtx_section\n   PARAMS ((enum machine_mode, rtx, unsigned HOST_WIDE_INT));\n #endif\n \n-static void alpha_init_machine_status\n-  PARAMS ((struct function *p));\n-static void alpha_mark_machine_status\n-  PARAMS ((struct function *p));\n-static void alpha_free_machine_status\n-  PARAMS ((struct function *p));\n+static struct machine_function * alpha_init_machine_status\n+  PARAMS ((void));\n \n static void unicosmk_output_deferred_case_vectors PARAMS ((FILE *));\n static void unicosmk_gen_dsib PARAMS ((unsigned long *imaskP));\n@@ -562,8 +558,6 @@ override_options ()\n \n   /* Set up function hooks.  */\n   init_machine_status = alpha_init_machine_status;\n-  mark_machine_status = alpha_mark_machine_status;\n-  free_machine_status = alpha_free_machine_status;\n }\n \f\n /* Returns 1 if VALUE is a mask that contains full bytes of zero or ones.  */\n@@ -5311,68 +5305,28 @@ alpha_multipass_dfa_lookahead ()\n \f\n /* Machine-specific function data.  */\n \n-struct machine_function\n+struct machine_function GTY(())\n {\n-#if TARGET_ABI_UNICOSMK\n+  /* For unicosmk. */\n   /* List of call information words for calls from this function.  */\n   struct rtx_def *first_ciw;\n   struct rtx_def *last_ciw;\n   int ciw_count;\n \n   /* List of deferred case vectors.  */\n   struct rtx_def *addr_list;\n-#else\n-#if TARGET_ABI_OSF\n+\n+  /* For OSF. */\n   const char *some_ld_name;\n-#else\n-  /* Non-empty struct.  */\n-  char dummy;\n-#endif\n-#endif\n };\n \n-/* Register global variables and machine-specific functions with the\n-   garbage collector.  */\n+/* How to allocate a 'struct machine_function'.  */\n \n-static void\n-alpha_init_machine_status (p)\n-     struct function *p;\n+static struct machine_function *\n+alpha_init_machine_status ()\n {\n-  p->machine =\n-    (struct machine_function *) xcalloc (1, sizeof (struct machine_function));\n-\n-#if TARGET_ABI_UNICOSMK\n-  p->machine->first_ciw = NULL_RTX;\n-  p->machine->last_ciw = NULL_RTX;\n-  p->machine->ciw_count = 0;\n-  p->machine->addr_list = NULL_RTX;\n-#endif\n-#if TARGET_ABI_OSF\n-  p->machine->some_ld_name = NULL;\n-#endif\n-}\n-\n-static void\n-alpha_mark_machine_status (p)\n-     struct function *p;\n-{\n-  struct machine_function *machine = p->machine;\n-\n-  if (machine)\n-    {\n-#if TARGET_ABI_UNICOSMK\n-      ggc_mark_rtx (machine->first_ciw);\n-      ggc_mark_rtx (machine->addr_list);\n-#endif\n-    }\n-}\n-\n-static void\n-alpha_free_machine_status (p)\n-     struct function *p;\n-{\n-  free (p->machine);\n-  p->machine = NULL;\n+  return ((struct machine_function *) \n+\t\tggc_alloc_cleared (sizeof (struct machine_function)));\n }\n \n /* Functions to save and restore alpha_return_addr_rtx.  */\n@@ -9913,3 +9867,6 @@ unicosmk_need_dex (x)\n }\n \n #endif /* TARGET_ABI_UNICOSMK */\n+\n+#include \"gt-alpha.h\"\n+"}, {"sha": "4d1b467dd4966d53e7f583300df6997c6b78103d", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 10, "deletions": 42, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -82,9 +82,7 @@ static Ccstar    output_multi_immediate\t\tPARAMS ((rtx *, Ccstar, Ccstar, int, Hi\n static void      print_multi_reg\t\tPARAMS ((FILE *, Ccstar, int, int));\n static Mmode     select_dominance_cc_mode\tPARAMS ((rtx, rtx, Hint));\n static Ccstar    shift_op\t\t\tPARAMS ((rtx, Hint *));\n-static void      arm_init_machine_status\tPARAMS ((struct function *));\n-static void      arm_mark_machine_status        PARAMS ((struct function *));\n-static void      arm_free_machine_status        PARAMS ((struct function *));\n+static struct machine_function * arm_init_machine_status PARAMS ((void));\n static int       number_of_first_bit_set        PARAMS ((int));\n static void      replace_symbols_in_block       PARAMS ((tree, rtx, rtx));\n static void      thumb_exit                     PARAMS ((FILE *, int, rtx));\n@@ -772,10 +770,6 @@ arm_override_options ()\n static void\n arm_add_gc_roots ()\n {\n-  ggc_add_rtx_root (&arm_compare_op0, 1);\n-  ggc_add_rtx_root (&arm_compare_op1, 1);\n-  ggc_add_rtx_root (&arm_target_insn, 1); /* Not sure this is really a root.  */\n-\n   gcc_obstack_init(&minipool_obstack);\n   minipool_startobj = (char *) obstack_alloc (&minipool_obstack, 0);\n }\n@@ -10091,37 +10085,16 @@ thumb_unexpanded_epilogue ()\n \n /* Functions to save and restore machine-specific function data.  */\n \n-static void\n-arm_mark_machine_status (p)\n-     struct function * p;\n-{\n-  machine_function *machine = p->machine;\n-\n-  if (machine)\n-    ggc_mark_rtx (machine->eh_epilogue_sp_ofs);\n-}\n-\n-static void\n-arm_init_machine_status (p)\n-     struct function * p;\n+static struct machine_function *\n+arm_init_machine_status ()\n {\n-  p->machine =\n-    (machine_function *) xcalloc (1, sizeof (machine_function));\n+  struct machine_function *machine;\n+  machine = (machine_function *) ggc_alloc_cleared (sizeof (machine_function));\n \n-#if ARM_FT_UNKNOWWN != 0  \n-  ((machine_function *) p->machine)->func_type = ARM_FT_UNKNOWN;\n+#if ARM_FT_UNKNOWN != 0  \n+  machine->func_type = ARM_FT_UNKNOWN;\n #endif\n-}\n-\n-static void\n-arm_free_machine_status (p)\n-     struct function * p;\n-{\n-  if (p->machine)\n-    {\n-      free (p->machine);\n-      p->machine = NULL;\n-    }\n+  return machine;\n }\n \n /* Return an RTX indicating where the return address to the\n@@ -10152,8 +10125,6 @@ arm_init_expanders ()\n {\n   /* Arrange to initialize and mark the machine per-function status.  */\n   init_machine_status = arm_init_machine_status;\n-  mark_machine_status = arm_mark_machine_status;\n-  free_machine_status = arm_free_machine_status;\n }\n \n /* Generate the rest of a function's prologue.  */\n@@ -10851,10 +10822,11 @@ arm_strip_name_encoding (const char * name)\n   return name;\n }\n \n+rtx aof_pic_label;\n+\n #ifdef AOF_ASSEMBLER\n /* Special functions only needed when producing AOF syntax assembler.  */\n \n-rtx aof_pic_label = NULL_RTX;\n struct pic_chain\n {\n   struct pic_chain * next;\n@@ -10872,10 +10844,6 @@ aof_pic_entry (x)\n \n   if (aof_pic_label == NULL_RTX)\n     {\n-      /* We mark this here and not in arm_add_gc_roots() to avoid\n-\t polluting even more code with ifdefs, and because it never\n-\t contains anything useful until we assign to it here.  */\n-      ggc_add_rtx_root (&aof_pic_label, 1);\n       aof_pic_label = gen_rtx_SYMBOL_REF (Pmode, \"x$adcons\");\n     }\n "}, {"sha": "1b1b7dbe77c08b4994fb95d6a1d669ced5aa9a14", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -107,21 +107,22 @@ extern arm_cc arm_current_cc;\n \n extern int arm_target_label;\n extern int arm_ccfsm_state;\n-extern struct rtx_def * arm_target_insn;\n+extern GTY(()) rtx arm_target_insn;\n /* Run-time compilation parameters selecting different hardware subsets.  */\n extern int target_flags;\n /* The floating point instruction architecture, can be 2 or 3 */\n extern const char * target_fp_name;\n /* Define the information needed to generate branch insns.  This is\n-   stored from the compare operation.  Note that we can't use \"rtx\" here\n-   since it hasn't been defined!  */\n-extern struct rtx_def * arm_compare_op0;\n-extern struct rtx_def * arm_compare_op1;\n+   stored from the compare operation.  */\n+extern GTY(()) rtx arm_compare_op0;\n+extern GTY(()) rtx arm_compare_op1;\n /* The label of the current constant pool.  */\n-extern struct rtx_def * pool_vector_label;\n+extern rtx pool_vector_label;\n /* Set to 1 when a return insn is output, this means that the epilogue\n    is not needed. */\n extern int return_used_this_function;\n+/* Used to produce AOF syntax assembler.  */\n+extern GTY(()) rtx aof_pic_label;\n \f\n /* Just in case configure has failed to define anything. */\n #ifndef TARGET_CPU_DEFAULT\n@@ -1412,10 +1413,10 @@ enum reg_class\n \n /* A C structure for machine-specific, per-function data.\n    This is added to the cfun structure.  */\n-typedef struct machine_function\n+typedef struct machine_function GTY(())\n {\n   /* Additionsl stack adjustment in __builtin_eh_throw.  */\n-  struct rtx_def *eh_epilogue_sp_ofs;\n+  rtx eh_epilogue_sp_ofs;\n   /* Records if LR has to be saved for far jumps.  */\n   int far_jump_used;\n   /* Records if ARG_POINTER was ever live.  */"}, {"sha": "8176d4d37230dcd7b5db4bd8e031448bee73fa49", "filename": "gcc/config/c4x/c4x-protos.h", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fc4x%2Fc4x-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fc4x%2Fc4x-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x-protos.h?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -272,19 +272,19 @@ extern int valid_parallel_operands_5 PARAMS ((rtx *, enum machine_mode));\n \n extern int valid_parallel_operands_6 PARAMS ((rtx *, enum machine_mode));\n \n-extern rtx smulhi3_libfunc;\n-extern rtx umulhi3_libfunc;\n-extern rtx fix_truncqfhi2_libfunc;\n-extern rtx fixuns_truncqfhi2_libfunc;\n-extern rtx fix_trunchfhi2_libfunc;\n-extern rtx fixuns_trunchfhi2_libfunc;\n-extern rtx floathiqf2_libfunc;\n-extern rtx floatunshiqf2_libfunc;\n-extern rtx floathihf2_libfunc;\n-extern rtx floatunshihf2_libfunc;\n-\n-extern struct rtx_def *c4x_compare_op0;\t/* Operand 0 for comparisons.  */\n-extern struct rtx_def *c4x_compare_op1;\t/* Operand 1 for comparisons.  */\n+extern GTY(()) rtx smulhi3_libfunc;\n+extern GTY(()) rtx umulhi3_libfunc;\n+extern GTY(()) rtx fix_truncqfhi2_libfunc;\n+extern GTY(()) rtx fixuns_truncqfhi2_libfunc;\n+extern GTY(()) rtx fix_trunchfhi2_libfunc;\n+extern GTY(()) rtx fixuns_trunchfhi2_libfunc;\n+extern GTY(()) rtx floathiqf2_libfunc;\n+extern GTY(()) rtx floatunshiqf2_libfunc;\n+extern GTY(()) rtx floathihf2_libfunc;\n+extern GTY(()) rtx floatunshihf2_libfunc;\n+\n+extern GTY(()) rtx c4x_compare_op0;\t/* Operand 0 for comparisons.  */\n+extern GTY(()) rtx c4x_compare_op1;\t/* Operand 1 for comparisons.  */\n \n #endif /* RTX_CODE */\n \n@@ -303,7 +303,12 @@ extern void c4x_pr_FUNC_NEVER_RETURNS\tPARAMS ((cpp_reader *));\n extern void c4x_pr_INTERRUPT\t\tPARAMS ((cpp_reader *));\n extern void c4x_pr_ignored\t\tPARAMS ((cpp_reader *));\n extern void c4x_init_pragma\t\tPARAMS ((int (*) (tree *)));\n-extern tree code_tree, data_tree, pure_tree, noreturn_tree, interrupt_tree;\n #endif\n \n+extern GTY(()) tree code_tree;\n+extern GTY(()) tree data_tree;\n+extern GTY(()) tree pure_tree;\n+extern GTY(()) tree noreturn_tree;\n+extern GTY(()) tree interrupt_tree;\n+\n #endif /* ! GCC_C4X_PROTOS_H */"}, {"sha": "ad2ff6dff3ed2321da9298eb3433cb7b8dbb65ef", "filename": "gcc/config/c4x/c4x.c", "status": "modified", "additions": 3, "deletions": 32, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fc4x%2Fc4x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fc4x%2Fc4x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -148,8 +148,8 @@ enum machine_mode c4x_caller_save_map[FIRST_PSEUDO_REGISTER] =\n /* Test and compare insns in c4x.md store the information needed to\n    generate branch and scc insns here.  */\n \n-struct rtx_def *c4x_compare_op0 = NULL_RTX;\n-struct rtx_def *c4x_compare_op1 = NULL_RTX;\n+rtx c4x_compare_op0;\n+rtx c4x_compare_op1;\n \n const char *c4x_rpts_cycles_string;\n int c4x_rpts_cycles = 0;\t/* Max. cycles for RPTS.  */\n@@ -165,7 +165,6 @@ tree noreturn_tree = NULL_TREE;\n tree interrupt_tree = NULL_TREE;\n \n /* Forward declarations */\n-static void c4x_add_gc_roots PARAMS ((void));\n static int c4x_isr_reg_used_p PARAMS ((unsigned int));\n static int c4x_leaf_function_p PARAMS ((void));\n static int c4x_assembler_function_p PARAMS ((void));\n@@ -223,32 +222,6 @@ static void c4x_encode_section_info PARAMS ((tree, int));\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n-/* Called to register all of our global variables with the garbage\n-   collector.  */\n-\n-static void\n-c4x_add_gc_roots ()\n-{\n-  ggc_add_rtx_root (&c4x_compare_op0, 1);\n-  ggc_add_rtx_root (&c4x_compare_op1, 1);\n-  ggc_add_tree_root (&code_tree, 1);\n-  ggc_add_tree_root (&data_tree, 1);\n-  ggc_add_tree_root (&pure_tree, 1);\n-  ggc_add_tree_root (&noreturn_tree, 1);\n-  ggc_add_tree_root (&interrupt_tree, 1);\n-  ggc_add_rtx_root (&smulhi3_libfunc, 1);\n-  ggc_add_rtx_root (&umulhi3_libfunc, 1);\n-  ggc_add_rtx_root (&fix_truncqfhi2_libfunc, 1);\n-  ggc_add_rtx_root (&fixuns_truncqfhi2_libfunc, 1);\n-  ggc_add_rtx_root (&fix_trunchfhi2_libfunc, 1);\n-  ggc_add_rtx_root (&fixuns_trunchfhi2_libfunc, 1);\n-  ggc_add_rtx_root (&floathiqf2_libfunc, 1);\n-  ggc_add_rtx_root (&floatunshiqf2_libfunc, 1);\n-  ggc_add_rtx_root (&floathihf2_libfunc, 1);\n-  ggc_add_rtx_root (&floatunshihf2_libfunc, 1);\n-}\n-\n-\n /* Override command line options.\n    Called once after all options have been parsed.\n    Mostly we process the processor\n@@ -317,9 +290,6 @@ c4x_override_options ()\n      This provides compatibility with the old -mno-aliases option.  */\n   if (! TARGET_ALIASES && ! flag_argument_noalias)\n     flag_argument_noalias = 1;\n-\n-  /* Register global variables with the garbage collector.  */\n-  c4x_add_gc_roots ();\n }\n \n \n@@ -5087,3 +5057,4 @@ c4x_asm_named_section (name, flags)\n {\n   fprintf (asm_out_file, \"\\t.sect\\t\\\"%s\\\"\\n\", name);\n }\n+"}, {"sha": "0fa6660dc9734bccb56c62eef1a10b6f1b0fc168", "filename": "gcc/config/cris/cris.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fcris%2Fcris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fcris%2Fcris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -63,7 +63,7 @@ Boston, MA 02111-1307, USA.  */\n     } while (0)\n \n /* Per-function machine data.  */\n-struct machine_function\n+struct machine_function GTY(())\n  {\n    int needs_return_address_on_stack;\n  };\n@@ -85,7 +85,7 @@ static void cris_print_base PARAMS ((rtx, FILE *));\n \n static void cris_print_index PARAMS ((rtx, FILE *));\n \n-static void cris_init_machine_status PARAMS ((struct function *));\n+static struct machine_function * cris_init_machine_status PARAMS ((void));\n \n static int cris_initial_frame_pointer_offset PARAMS ((void));\n \n@@ -2697,11 +2697,10 @@ cris_init_expanders ()\n \n /* Zero initialization is OK for all current fields.  */\n \n-static void\n-cris_init_machine_status (p)\n-     struct function *p;\n+static struct machine_function *\n+cris_init_machine_status ()\n {\n-  p->machine = xcalloc (1, sizeof (struct machine_function));\n+  return ggc_alloc_cleared (sizeof (struct machine_function));\n }\n \n /* Split a 2 word move (DI or presumably DF) into component parts.\n@@ -3129,6 +3128,8 @@ Prev_insn (insn)\n }\n #endif\n \n+#include \"gt-cris.h\"\n+\n /*\n  * Local variables:\n  * eval: (c-set-style \"gnu\")"}, {"sha": "61745e50867594c08a36711b58f7334a1f4da96d", "filename": "gcc/config/cris/t-cris", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fcris%2Ft-cris", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fcris%2Ft-cris", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Ft-cris?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -39,3 +39,6 @@ $(LIB2FUNCS_EXTRA): $(CRIS_LIB1CSRC)\n \techo \"#define L$$name\" > tmp-$@ \\\n \t&& echo '#include \"$<\"' >> tmp-$@ \\\n \t&& mv -f tmp-$@ $@\n+\n+$(out_object_file): gt-cris.h\n+gt-cris.h : s-gtype ; @true"}, {"sha": "162a7172eb4a853e2edb3f7408690fdde234f04a", "filename": "gcc/config/d30v/d30v-protos.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fd30v%2Fd30v-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fd30v%2Fd30v-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fd30v%2Fd30v-protos.h?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -140,8 +140,8 @@ extern void debug_stack_info\t\tPARAMS ((d30v_stack_t *));\n /* Define the information needed to generate branch and scc insns.  This is\n    stored from the compare operation.  */\n \n-extern struct rtx_def *d30v_compare_op0;\n-extern struct rtx_def *d30v_compare_op1;\n+extern GTY(()) rtx d30v_compare_op0;\n+extern GTY(()) rtx d30v_compare_op1;\n \n /* Define the information needed to modify the epilogue for EH.  */\n "}, {"sha": "2ce3468140b60e09d4824db5316506a3451e0a8c", "filename": "gcc/config/d30v/d30v.c", "status": "modified", "additions": 4, "deletions": 46, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fd30v%2Fd30v.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fd30v%2Fd30v.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fd30v%2Fd30v.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -47,10 +47,7 @@\n static void d30v_print_operand_memory_reference PARAMS ((FILE *, rtx));\n static void d30v_build_long_insn PARAMS ((HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t\t\t  rtx, rtx));\n-static void d30v_add_gc_roots PARAMS ((void));\n-static void d30v_init_machine_status PARAMS ((struct function *));\n-static void d30v_mark_machine_status PARAMS ((struct function *));\n-static void d30v_free_machine_status PARAMS ((struct function *));\n+static struct machine_function * d30v_init_machine_status PARAMS ((void));\n static void d30v_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n static void d30v_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n static int d30v_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n@@ -298,8 +295,6 @@ override_options ()\n   reg_class_from_letter['x'] = F0_REGS;\n   reg_class_from_letter['y'] = F1_REGS;\n   reg_class_from_letter['z'] = OTHER_FLAG_REGS;\n-\n-  d30v_add_gc_roots ();\n }\n \n \f\n@@ -3482,35 +3477,10 @@ d30v_issue_rate ()\n /* Routine to allocate, mark and free a per-function,\n    machine specific structure.  */\n \n-static void\n-d30v_init_machine_status (p)\n-     struct function *p;\n+static struct machine_function *\n+d30v_init_machine_status ()\n {\n-  p->machine =\n-    (machine_function *) xcalloc (1, sizeof (machine_function));\n-}\n-\n-static void\n-d30v_mark_machine_status (p)\n-     struct function * p;\n-{\n-  if (p->machine == NULL)\n-    return;\n-  \n-  ggc_mark_rtx (p->machine->eh_epilogue_sp_ofs);\n-}\n-\n-static void\n-d30v_free_machine_status (p)\n-     struct function *p;\n-{\n-  struct machine_function *machine = p->machine;\n-\n-  if (machine == NULL)\n-    return;\n-\n-  free (machine);\n-  p->machine = NULL;\n+  return ggc_alloc_cleared (sizeof (machine_function));\n }\n \n /* Do anything needed before RTL is emitted for each function.  */\n@@ -3520,8 +3490,6 @@ d30v_init_expanders ()\n {\n   /* Arrange to save and restore machine status around nested functions.  */\n   init_machine_status = d30v_init_machine_status;\n-  mark_machine_status = d30v_mark_machine_status;\n-  free_machine_status = d30v_free_machine_status;\n }\n \n /* Find the current function's return address.\n@@ -3536,13 +3504,3 @@ d30v_return_addr ()\n {\n   return get_hard_reg_initial_val (Pmode, GPR_LINK);\n }\n-\n-/* Called to register all of our global variables with the garbage\n-   collector.  */\n-\n-static void\n-d30v_add_gc_roots ()\n-{\n-  ggc_add_rtx_root (&d30v_compare_op0, 1);\n-  ggc_add_rtx_root (&d30v_compare_op1, 1);\n-}"}, {"sha": "680f7c10cc29990db4de7b984f5f8993bf8cabb9", "filename": "gcc/config/d30v/d30v.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fd30v%2Fd30v.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fd30v%2Fd30v.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fd30v%2Fd30v.h?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -1929,10 +1929,10 @@ typedef int CUMULATIVE_ARGS;\n \n /* A C structure for machine-specific, per-function data.\n    This is added to the cfun structure.  */\n-typedef struct machine_function\n+typedef struct machine_function GTY(())\n {\n   /* Additionsl stack adjustment in __builtin_eh_throw.  */\n-  struct rtx_def * eh_epilogue_sp_ofs;\n+  rtx eh_epilogue_sp_ofs;\n } machine_function;\n \n \f"}, {"sha": "19f83c62308725448e2a4cf67b5998e5457eb26d", "filename": "gcc/config/darwin-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fdarwin-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fdarwin-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin-protos.h?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -26,8 +26,6 @@ extern char *machopic_function_base_name PARAMS ((void));\n extern char *machopic_non_lazy_ptr_name PARAMS ((const char*));\n extern char *machopic_stub_name PARAMS ((const char*));\n \n-extern void machopic_add_gc_roots PARAMS ((void));\n-\n extern void machopic_picsymbol_stub_section PARAMS ((void));\n extern void machopic_symbol_stub_section PARAMS ((void));\n extern void machopic_lazy_symbol_ptr_section PARAMS ((void));"}, {"sha": "82e320babe098655631ae7adfdb109eab2e0f354", "filename": "gcc/config/darwin.c", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fdarwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fdarwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -67,7 +67,7 @@ name_needs_quotes (name)\n /* This module assumes that (const (symbol_ref \"foo\")) is a legal pic\n    reference, which will not be changed.  */\n \n-static tree machopic_defined_list;\n+static GTY(()) tree machopic_defined_list;\n \n enum machopic_addr_class\n machopic_classify_ident (ident)\n@@ -257,7 +257,7 @@ machopic_function_base_name ()\n   return function_base;\n }\n \n-static tree machopic_non_lazy_pointers = NULL;\n+static GTY(()) tree machopic_non_lazy_pointers;\n \n /* Return a non-lazy pointer name corresponding to the given name,\n    either by finding it in our list of pointer names, or by generating\n@@ -321,17 +321,7 @@ machopic_non_lazy_ptr_name (name)\n   }\n }\n \n-static tree machopic_stubs = 0;\n-\n-/* Make sure the GC knows about our homemade lists.  */\n-\n-void\n-machopic_add_gc_roots ()\n-{\n-  ggc_add_tree_root (&machopic_defined_list, 1);\n-  ggc_add_tree_root (&machopic_non_lazy_pointers, 1);\n-  ggc_add_tree_root (&machopic_stubs, 1);\n-}\n+static GTY(()) tree machopic_stubs;\n \n /* Return the name of the stub corresponding to the given name,\n    generating a new stub name if necessary.  */\n@@ -1297,3 +1287,6 @@ machopic_asm_out_destructor (symbol, priority)\n   if (!flag_pic)\n     fprintf (asm_out_file, \".reference .destructors_used\\n\");\n }\n+\n+#include \"gt-darwin.h\"\n+"}, {"sha": "cc1c9d4d27999bfb63fa0cdcbcbad07170165634", "filename": "gcc/config/dsp16xx/dsp16xx.c", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -1725,29 +1725,6 @@ override_options ()\n   rsect_const = tmp = (char *) xmalloc (strlen(\".rsect \") + \n \t\t\t\t\tstrlen(const_seg_name) + 3);\n   sprintf (tmp, \".rsect \\\"%s\\\"\", const_seg_name);\n-  \n-  /* Mark our global variables for GC.  */\n-  ggc_add_rtx_root (&dsp16xx_addhf3_libcall, 1);\n-  ggc_add_rtx_root (&dsp16xx_subhf3_libcall, 1);\n-  ggc_add_rtx_root (&dsp16xx_mulhf3_libcall, 1);\n-  ggc_add_rtx_root (&dsp16xx_divhf3_libcall, 1);\n-  ggc_add_rtx_root (&dsp16xx_cmphf3_libcall, 1);\n-  ggc_add_rtx_root (&dsp16xx_fixhfhi2_libcall, 1);\n-  ggc_add_rtx_root (&dsp16xx_floathihf2_libcall, 1);\n-  ggc_add_rtx_root (&dsp16xx_neghf2_libcall, 1);\n-  ggc_add_rtx_root (&dsp16xx_mulhi3_libcall, 1);\n-  ggc_add_rtx_root (&dsp16xx_udivqi3_libcall, 1);\n-  ggc_add_rtx_root (&dsp16xx_udivhi3_libcall, 1);\n-  ggc_add_rtx_root (&dsp16xx_divqi3_libcall, 1);\n-  ggc_add_rtx_root (&dsp16xx_divhi3_libcall, 1);\n-  ggc_add_rtx_root (&dsp16xx_modqi3_libcall, 1);\n-  ggc_add_rtx_root (&dsp16xx_modhi3_libcall, 1);\n-  ggc_add_rtx_root (&dsp16xx_umodqi3_libcall, 1);\n-  ggc_add_rtx_root (&dsp16xx_umodhi3_libcall, 1);\n-  ggc_add_rtx_root (&dsp16xx_ashrhi3_libcall, 1);\n-  ggc_add_rtx_root (&dsp16xx_ashlhi3_libcall, 1);\n-  ggc_add_rtx_root (&dsp16xx_ucmphi2_libcall, 1);\n-  ggc_add_rtx_root (&dsp16xx_lshrhi3_libcall, 1);\n }\n \n int"}, {"sha": "905b027c8f03b1c42ca03a5d72adf48803162aa4", "filename": "gcc/config/dsp16xx/dsp16xx.h", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.h?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -31,29 +31,30 @@ extern const char *const_seg_name;\n extern const char *rsect_const;\n extern const char *chip_name;\n extern const char *save_chip_name;\n-extern struct rtx_def *dsp16xx_compare_op0, *dsp16xx_compare_op1;\n-extern struct rtx_def *dsp16xx_addhf3_libcall;\n-extern struct rtx_def *dsp16xx_subhf3_libcall;\n-extern struct rtx_def *dsp16xx_mulhf3_libcall;\n-extern struct rtx_def *dsp16xx_divhf3_libcall;\n-extern struct rtx_def *dsp16xx_cmphf3_libcall;\n-extern struct rtx_def *dsp16xx_fixhfhi2_libcall;\n-extern struct rtx_def *dsp16xx_floathihf2_libcall;\n-extern struct rtx_def *dsp16xx_neghf2_libcall;\n-extern struct rtx_def *dsp16xx_umulhi3_libcall;\n-extern struct rtx_def *dsp16xx_mulhi3_libcall;\n-extern struct rtx_def *dsp16xx_udivqi3_libcall;\n-extern struct rtx_def *dsp16xx_udivhi3_libcall;\n-extern struct rtx_def *dsp16xx_divqi3_libcall;\n-extern struct rtx_def *dsp16xx_divhi3_libcall;\n-extern struct rtx_def *dsp16xx_modqi3_libcall;\n-extern struct rtx_def *dsp16xx_modhi3_libcall;\n-extern struct rtx_def *dsp16xx_umodqi3_libcall;\n-extern struct rtx_def *dsp16xx_umodhi3_libcall;\n-\n-extern struct rtx_def *dsp16xx_ashrhi3_libcall;\n-extern struct rtx_def *dsp16xx_ashlhi3_libcall;\n-extern struct rtx_def *dsp16xx_lshrhi3_libcall;\n+extern GTY(()) rtx dsp16xx_compare_op0;\n+extern GTY(()) rtx dsp16xx_compare_op1;\n+extern GTY(()) rtx dsp16xx_addhf3_libcall;\n+extern GTY(()) rtx dsp16xx_subhf3_libcall;\n+extern GTY(()) rtx dsp16xx_mulhf3_libcall;\n+extern GTY(()) rtx dsp16xx_divhf3_libcall;\n+extern GTY(()) rtx dsp16xx_cmphf3_libcall;\n+extern GTY(()) rtx dsp16xx_fixhfhi2_libcall;\n+extern GTY(()) rtx dsp16xx_floathihf2_libcall;\n+extern GTY(()) rtx dsp16xx_neghf2_libcall;\n+extern GTY(()) rtx dsp16xx_umulhi3_libcall;\n+extern GTY(()) rtx dsp16xx_mulhi3_libcall;\n+extern GTY(()) rtx dsp16xx_udivqi3_libcall;\n+extern GTY(()) rtx dsp16xx_udivhi3_libcall;\n+extern GTY(()) rtx dsp16xx_divqi3_libcall;\n+extern GTY(()) rtx dsp16xx_divhi3_libcall;\n+extern GTY(()) rtx dsp16xx_modqi3_libcall;\n+extern GTY(()) rtx dsp16xx_modhi3_libcall;\n+extern GTY(()) rtx dsp16xx_umodqi3_libcall;\n+extern GTY(()) rtx dsp16xx_umodhi3_libcall;\n+\n+extern GTY(()) rtx dsp16xx_ashrhi3_libcall;\n+extern GTY(()) rtx dsp16xx_ashlhi3_libcall;\n+extern GTY(()) rtx dsp16xx_lshrhi3_libcall;\n \n /* RUN-TIME TARGET SPECIFICATION */\n #define DSP16XX   1"}, {"sha": "b5ca28f4fc7717a59ee83734af1c1ad351d1f958", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 12, "deletions": 43, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -553,7 +553,7 @@ static char const tls_model_chars[] = \" GLil\";\n #define X86_64_VARARGS_SIZE (REGPARM_MAX * UNITS_PER_WORD + SSE_REGPARM_MAX * 16)\n \n /* Define the structure for the machine field in struct function.  */\n-struct machine_function\n+struct machine_function GTY(())\n {\n   rtx stack_locals[(int) MAX_MACHINE_MODE][MAX_386_STACK_LOCALS];\n   const char *some_ld_name;\n@@ -680,9 +680,7 @@ static int ix86_agi_dependant PARAMS ((rtx, rtx, enum attr_type));\n static enum attr_ppro_uops ix86_safe_ppro_uops PARAMS ((rtx));\n static void ix86_dump_ppro_packet PARAMS ((FILE *));\n static void ix86_reorder_insn PARAMS ((rtx *, rtx *));\n-static void ix86_init_machine_status PARAMS ((struct function *));\n-static void ix86_mark_machine_status PARAMS ((struct function *));\n-static void ix86_free_machine_status PARAMS ((struct function *));\n+static struct machine_function * ix86_init_machine_status PARAMS ((void));\n static int ix86_split_to_parts PARAMS ((rtx, rtx *, enum machine_mode));\n static int ix86_nsaved_regs PARAMS ((void));\n static void ix86_emit_save_regs PARAMS ((void));\n@@ -1042,9 +1040,7 @@ override_options ()\n \n   /* Arrange to set up i386_stack_locals for all functions.  */\n   init_machine_status = ix86_init_machine_status;\n-  mark_machine_status = ix86_mark_machine_status;\n-  free_machine_status = ix86_free_machine_status;\n-\n+  \n   /* Validate -mregparm= value.  */\n   if (ix86_regparm_string)\n     {\n@@ -10636,38 +10632,10 @@ ix86_expand_call (retval, fnaddr, callarg1, callarg2, pop)\n    This is called from INIT_EXPANDERS once before RTL is emitted for each\n    function.  */\n \n-static void\n-ix86_init_machine_status (p)\n-     struct function *p;\n-{\n-  p->machine = (struct machine_function *)\n-    xcalloc (1, sizeof (struct machine_function));\n-}\n-\n-/* Mark machine specific bits of P for GC.  */\n-static void\n-ix86_mark_machine_status (p)\n-     struct function *p;\n-{\n-  struct machine_function *machine = p->machine;\n-  enum machine_mode mode;\n-  int n;\n-\n-  if (! machine)\n-    return;\n-\n-  for (mode = VOIDmode; (int) mode < (int) MAX_MACHINE_MODE;\n-       mode = (enum machine_mode) ((int) mode + 1))\n-    for (n = 0; n < MAX_386_STACK_LOCALS; n++)\n-      ggc_mark_rtx (machine->stack_locals[(int) mode][n]);\n-}\n-\n-static void\n-ix86_free_machine_status (p)\n-     struct function *p;\n+static struct machine_function *\n+ix86_init_machine_status ()\n {\n-  free (p->machine);\n-  p->machine = NULL;\n+  return ggc_alloc_cleared (sizeof (struct machine_function));\n }\n \n /* Return a MEM corresponding to a stack slot with mode MODE.\n@@ -10693,20 +10661,19 @@ assign_386_stack_local (mode, n)\n \n /* Construct the SYMBOL_REF for the tls_get_addr function.  */\n \n+static GTY(()) rtx ix86_tls_symbol;\n rtx\n ix86_tls_get_addr ()\n {\n-  static rtx symbol;\n \n-  if (!symbol)\n+  if (!ix86_tls_symbol)\n     {\n-      symbol = gen_rtx_SYMBOL_REF (Pmode, (TARGET_GNU_TLS\n+      ix86_tls_symbol = gen_rtx_SYMBOL_REF (Pmode, (TARGET_GNU_TLS\n \t\t\t\t\t   ? \"___tls_get_addr\"\n \t\t\t\t\t   : \"__tls_get_addr\"));\n-      ggc_add_rtx_root (&symbol, 1);\n     }\n \n-  return symbol;\n+  return ix86_tls_symbol;\n }\n \f\n /* Calculate the length of the memory address in the instruction\n@@ -13948,3 +13915,5 @@ x86_output_mi_thunk (file, delta, function)\n \t}\n     }\n }\n+\n+#include \"gt-i386.h\""}, {"sha": "2b10ef512aee84b13803aa17f339f535a6a3b8ad", "filename": "gcc/config/ia64/ia64-protos.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64-protos.h?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -21,7 +21,8 @@ Boston, MA 02111-1307, USA.  */\n /* Variables defined in ia64.c.  */\n \n #ifdef RTX_CODE\n-extern rtx ia64_compare_op0, ia64_compare_op1;\n+extern GTY(()) rtx ia64_compare_op0;\n+extern GTY(()) rtx ia64_compare_op1;\n #endif\n \n /* Functions defined in ia64.c */"}, {"sha": "a6066d8894ceaa7bdf25a2ae511c25aa887e1482", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 15, "deletions": 56, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -127,10 +127,7 @@ static rtx gen_fr_restore_x PARAMS ((rtx, rtx, rtx));\n \n static enum machine_mode hfa_element_mode PARAMS ((tree, int));\n static void fix_range PARAMS ((const char *));\n-static void ia64_add_gc_roots PARAMS ((void));\n-static void ia64_init_machine_status PARAMS ((struct function *));\n-static void ia64_mark_machine_status PARAMS ((struct function *));\n-static void ia64_free_machine_status PARAMS ((struct function *));\n+static struct machine_function * ia64_init_machine_status PARAMS ((void));\n static void emit_insn_group_barriers PARAMS ((FILE *, rtx));\n static void emit_all_insn_group_barriers PARAMS ((FILE *, rtx));\n static void emit_predicate_relation_info PARAMS ((void));\n@@ -1044,27 +1041,25 @@ ia64_expand_load_address (dest, src, scratch)\n     emit_move_insn (dest, temp);\n }\n \n+static GTY(()) rtx gen_tls_tga;\n static rtx\n gen_tls_get_addr ()\n {\n-  static rtx tga;\n-  if (!tga)\n+  if (!gen_tls_tga)\n     {\n-      tga = init_one_libfunc (\"__tls_get_addr\");\n-      ggc_add_rtx_root (&tga, 1);\n-    }\n-  return tga;\n+      gen_tls_tga = init_one_libfunc (\"__tls_get_addr\");\n+     }\n+  return gen_tls_tga;\n }\n \n+static GTY(()) rtx thread_pointer_rtx;\n static rtx\n gen_thread_pointer ()\n {\n-  static rtx tp;\n-  if (!tp)\n+  if (!thread_pointer_rtx)\n     {\n-      tp = gen_rtx_REG (Pmode, 13);\n-      RTX_UNCHANGING_P (tp);\n-      ggc_add_rtx_root (&tp, 1);\n+      thread_pointer_rtx = gen_rtx_REG (Pmode, 13);\n+      RTX_UNCHANGING_P (thread_pointer_rtx);\n     }\n   return tp;\n }\n@@ -4146,44 +4141,10 @@ fix_range (const_str)\n     }\n }\n \n-/* Called to register all of our global variables with the garbage\n-   collector.  */\n-\n-static void\n-ia64_add_gc_roots ()\n-{\n-  ggc_add_rtx_root (&ia64_compare_op0, 1);\n-  ggc_add_rtx_root (&ia64_compare_op1, 1);\n-}\n-\n-static void\n-ia64_init_machine_status (p)\n-     struct function *p;\n-{\n-  p->machine =\n-    (struct machine_function *) xcalloc (1, sizeof (struct machine_function));\n-}\n-\n-static void\n-ia64_mark_machine_status (p)\n-     struct function *p;\n-{\n-  struct machine_function *machine = p->machine;\n-\n-  if (machine)\n-    {\n-      ggc_mark_rtx (machine->ia64_eh_epilogue_sp);\n-      ggc_mark_rtx (machine->ia64_eh_epilogue_bsp);\n-      ggc_mark_rtx (machine->ia64_gp_save);\n-    }\n-}\n-\n-static void\n-ia64_free_machine_status (p)\n-     struct function *p;\n+static struct machine_function *\n+ia64_init_machine_status ()\n {\n-  free (p->machine);\n-  p->machine = NULL;\n+  return ggc_alloc_cleared (sizeof (struct machine_function));\n }\n \n /* Handle TARGET_OPTIONS switches.  */\n@@ -4219,10 +4180,6 @@ ia64_override_options ()\n   ia64_section_threshold = g_switch_set ? g_switch_value : IA64_DEFAULT_GVALUE;\n \n   init_machine_status = ia64_init_machine_status;\n-  mark_machine_status = ia64_mark_machine_status;\n-  free_machine_status = ia64_free_machine_status;\n-\n-  ia64_add_gc_roots ();\n }\n \f\n static enum attr_itanium_requires_unit0 ia64_safe_itanium_requires_unit0 PARAMS((rtx));\n@@ -8161,3 +8118,5 @@ ia64_aix_select_rtx_section (mode, x, align)\n   ia64_select_rtx_section (mode, x, align);\n   flag_pic = save_pic;\n }\n+\n+#include \"gt-ia64.h\""}, {"sha": "cfc44d4396408773ccf75d0fda8ad40b97f31f8e", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -2440,16 +2440,16 @@ extern int ia64_final_schedule;\n #define EH_RETURN_DATA_REGNO(N) ((N) < 4 ? (N) + 15 : INVALID_REGNUM)\n \n /* This function contains machine specific function data.  */\n-struct machine_function\n+struct machine_function GTY(())\n {\n   /* The new stack pointer when unwinding from EH.  */\n-  struct rtx_def* ia64_eh_epilogue_sp;\n+  rtx ia64_eh_epilogue_sp;\n \n   /* The new bsp value when unwinding from EH.  */\n-  struct rtx_def* ia64_eh_epilogue_bsp;\n+  rtx ia64_eh_epilogue_bsp;\n \n   /* The GP value save register.  */\n-  struct rtx_def* ia64_gp_save;\n+  rtx ia64_gp_save;\n \n   /* The number of varargs registers to save.  */\n   int n_varargs;"}, {"sha": "ee5bd6a7844998c22636e218be59de1496e075ff", "filename": "gcc/config/m68hc11/m68hc11-protos.h", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fm68hc11%2Fm68hc11-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fm68hc11%2Fm68hc11-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11-protos.h?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -43,10 +43,15 @@ extern void m68hc11_function_arg_advance PARAMS((CUMULATIVE_ARGS*,\n #ifdef RTX_CODE\n extern rtx m68hc11_compare_op0;\n extern rtx m68hc11_compare_op1;\n-extern rtx m68hc11_soft_tmp_reg;\n-extern rtx iy_reg;\n-extern rtx ix_reg;\n-extern rtx d_reg;\n+extern GTY(()) rtx m68hc11_soft_tmp_reg;\n+extern GTY(()) rtx ix_reg;\n+extern GTY(()) rtx iy_reg;\n+extern GTY(()) rtx d_reg;\n+extern GTY(()) rtx da_reg;\n+extern GTY(()) rtx stack_push_word;\n+extern GTY(()) rtx stack_pop_word;\n+extern GTY(()) rtx z_reg;\n+extern GTY(()) rtx z_reg_qi;\n \n extern void m68hc11_initialize_trampoline PARAMS((rtx, rtx, rtx));\n "}, {"sha": "b3dab481efa45d44a84817af92b923b351c4dc54", "filename": "gcc/config/m68hc11/m68hc11.c", "status": "modified", "additions": 2, "deletions": 19, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -72,7 +72,6 @@ static tree m68hc11_handle_fntype_attribute PARAMS ((tree *, tree, tree, int, bo\n const struct attribute_spec m68hc11_attribute_table[];\n \n void create_regs_rtx PARAMS ((void));\n-static void m68hc11_add_gc_roots PARAMS ((void));\n \n static void asm_print_register PARAMS ((FILE *, int));\n static void m68hc11_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n@@ -94,7 +93,7 @@ rtx da_reg;\n rtx stack_push_word;\n rtx stack_pop_word;\n static int regs_inited = 0;\n-static rtx z_reg;\n+rtx z_reg;\n \n /* Set to 1 by expand_prologue() when the function is an interrupt handler.  */\n int current_function_interrupt;\n@@ -229,8 +228,6 @@ struct gcc_target targetm = TARGET_INITIALIZER;\n int\n m68hc11_override_options ()\n {\n-  m68hc11_add_gc_roots ();\n-\n   memset (m68hc11_reg_valid_for_index, 0,\n \t  sizeof (m68hc11_reg_valid_for_index));\n   memset (m68hc11_reg_valid_for_base, 0, sizeof (m68hc11_reg_valid_for_base));\n@@ -4005,7 +4002,7 @@ struct replace_info\n   int z_loaded_with_sp;\n };\n \n-static rtx z_reg_qi;\n+rtx z_reg_qi;\n \n static int m68hc11_check_z_replacement PARAMS ((rtx, struct replace_info *));\n static void m68hc11_find_z_replacement PARAMS ((rtx, struct replace_info *));\n@@ -5414,20 +5411,6 @@ m68hc11_asm_file_start (out, main_file)\n }\n \n \n-static void\n-m68hc11_add_gc_roots ()\n-{\n-  ggc_add_rtx_root (&m68hc11_soft_tmp_reg, 1);\n-  ggc_add_rtx_root (&ix_reg, 1);\n-  ggc_add_rtx_root (&iy_reg, 1);\n-  ggc_add_rtx_root (&d_reg, 1);\n-  ggc_add_rtx_root (&da_reg, 1);\n-  ggc_add_rtx_root (&z_reg, 1);\n-  ggc_add_rtx_root (&z_reg_qi, 1);\n-  ggc_add_rtx_root (&stack_push_word, 1);\n-  ggc_add_rtx_root (&stack_pop_word, 1);\n-}\n-\n static void\n m68hc11_asm_out_constructor (symbol, priority)\n      rtx symbol;"}, {"sha": "9910c3a5ec0f9d1da1c06b4acdab91642d6bf77a", "filename": "gcc/config/mcore/mcore-protos.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fmcore%2Fmcore-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fmcore%2Fmcore-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore-protos.h?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -49,8 +49,8 @@ extern rtx          mcore_function_value         \tPARAMS ((tree, tree));\n \n #ifdef RTX_CODE\n \n-extern rtx arch_compare_op0;\n-extern rtx arch_compare_op1;\n+extern GTY(()) rtx arch_compare_op0;\n+extern GTY(()) rtx arch_compare_op1;\n \n extern const char * mcore_output_bclri         \t\tPARAMS ((rtx, int));\n extern const char * mcore_output_bseti         \t\tPARAMS ((rtx, int));"}, {"sha": "baf0a93f01f67f9b5e6600ff25358a82252ab2b9", "filename": "gcc/config/mcore/mcore.c", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fmcore%2Fmcore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fmcore%2Fmcore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -125,7 +125,6 @@ static cond_type  is_cond_candidate            PARAMS ((rtx));\n static rtx        emit_new_cond_insn           PARAMS ((rtx, int));\n static rtx        conditionalize_block         PARAMS ((rtx));\n static void       conditionalize_optimization  PARAMS ((rtx));\n-static void       mcore_add_gc_roots           PARAMS ((void));\n static rtx        handle_structs_in_regs       PARAMS ((enum machine_mode, tree, int));\n static void       mcore_mark_dllexport         PARAMS ((tree));\n static void       mcore_mark_dllimport         PARAMS ((tree));\n@@ -3069,15 +3068,6 @@ mcore_is_same_reg (x, y)\n   return 0;\n }\n \n-/* Called to register all of our global variables with the garbage\n-   collector.  */\n-static void\n-mcore_add_gc_roots ()\n-{\n-  ggc_add_rtx_root (&arch_compare_op0, 1);\n-  ggc_add_rtx_root (&arch_compare_op1, 1);\n-}\n-\n void\n mcore_override_options ()\n {\n@@ -3096,8 +3086,6 @@ mcore_override_options ()\n   /* Only the m340 supports little endian code.  */\n   if (TARGET_LITTLE_END && ! TARGET_M340)\n     target_flags |= M340_BIT;\n-\n-  mcore_add_gc_roots ();\n }\n \f\n int"}, {"sha": "1f6f71e42ef757c98ab1de8f01f57e857046cf5a", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 9, "deletions": 51, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -124,7 +124,6 @@ static rtx mips_find_symbol\t\t\tPARAMS ((rtx));\n static void abort_with_insn\t\t\tPARAMS ((rtx, const char *))\n   ATTRIBUTE_NORETURN;\n static int symbolic_expression_p                PARAMS ((rtx));\n-static void mips_add_gc_roots                   PARAMS ((void));\n static bool mips_assemble_integer\t  PARAMS ((rtx, unsigned int, int));\n static void mips_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n static void mips_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n@@ -143,9 +142,7 @@ static int iris6_section_align_1\t\tPARAMS ((void **, void *));\n static int mips_adjust_cost\t\t\tPARAMS ((rtx, rtx, rtx, int));\n static int mips_issue_rate\t\t\tPARAMS ((void));\n \n-static void mips_init_machine_status\t\tPARAMS ((struct function *));\n-static void mips_free_machine_status\t\tPARAMS ((struct function *));\n-static void mips_mark_machine_status\t\tPARAMS ((struct function *));\n+static struct machine_function * mips_init_machine_status PARAMS ((void));\n static void mips_select_section PARAMS ((tree, int, unsigned HOST_WIDE_INT))\n \tATTRIBUTE_UNUSED;\n static void mips_unique_section\t\t\tPARAMS ((tree, int))\n@@ -154,7 +151,7 @@ static void mips_select_rtx_section PARAMS ((enum machine_mode, rtx,\n \t\t\t\t\t     unsigned HOST_WIDE_INT));\n static void mips_encode_section_info\t\tPARAMS ((tree, int));\n \n-struct machine_function {\n+struct machine_function GTY(()) {\n   /* Pseudo-reg holding the address of the current function when\n      generating embedded PIC code.  Created by LEGITIMIZE_ADDRESS,\n      used by mips_finalize_pic if it was created.  */\n@@ -5435,44 +5432,16 @@ override_options ()\n \talign_functions = 8;\n     }\n \n-  /* Register global variables with the garbage collector.  */\n-  mips_add_gc_roots ();\n-\n-  /* Functions to allocate, mark and deallocate machine-dependent\n-     function status.  */\n+  /* Function to allocate machine-dependent function status.  */\n   init_machine_status = &mips_init_machine_status;\n-  free_machine_status = &mips_free_machine_status;\n-  mark_machine_status = &mips_mark_machine_status;\n }\n \n /* Allocate a chunk of memory for per-function machine-dependent data.  */\n-static void\n-mips_init_machine_status (fn)\n-     struct function *fn;\n-{\n-  fn->machine = ((struct machine_function *)\n-\t\t xcalloc (1, sizeof (struct machine_function)));\n-}\n-\n-/* Release the chunk of memory for per-function machine-dependent data.  */\n-static void\n-mips_free_machine_status (fn)\n-     struct function *fn;\n-{\n-  free (fn->machine);\n-  fn->machine = NULL;\n-}\n-\n-/* Mark per-function machine-dependent data.  */\n-static void\n-mips_mark_machine_status (fn)\n-     struct function *fn;\n+static struct machine_function *\n+mips_init_machine_status ()\n {\n-  if (fn->machine)\n-    {\n-      ggc_mark_rtx (fn->machine->embedded_pic_fnaddr_rtx);\n-      ggc_mark_rtx (fn->machine->mips16_gp_pseudo_rtx);\n-    }\n+  return ((struct machine_function *)\n+\t  ggc_alloc_cleared (sizeof (struct machine_function)));\n }\n \n /* On the mips16, we want to allocate $24 (T_REG) before other\n@@ -10128,19 +10097,6 @@ mips_output_conditional_branch (insn,\n   return 0;\n }\n \n-/* Called to register all of our global variables with the garbage\n-   collector.  */\n-\n-static void\n-mips_add_gc_roots ()\n-{\n-  ggc_add_rtx_root (&mips_load_reg, 1);\n-  ggc_add_rtx_root (&mips_load_reg2, 1);\n-  ggc_add_rtx_root (&mips_load_reg3, 1);\n-  ggc_add_rtx_root (&mips_load_reg4, 1);\n-  ggc_add_rtx_root (branch_cmp, ARRAY_SIZE (branch_cmp));\n-}\n-\n static enum processor_type\n mips_parse_cpu (cpu_string)\n      const char *cpu_string;\n@@ -10547,3 +10503,5 @@ iris6_asm_file_end (stream)\n   mips_asm_file_end (stream);\n }\n #endif /* TARGET_IRIX6 */\n+\n+#include \"gt-mips.h\""}, {"sha": "b17c2a0494d807ddab8ea1e4153575a3a0a6141f", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -137,7 +137,7 @@ extern int set_noat;\t\t\t/* # of nested .set noat's  */\n extern int set_volatile;\t\t/* # of nested .set volatile's  */\n extern int mips_branch_likely;\t\t/* emit 'l' after br (branch likely) */\n extern int mips_dbx_regno[];\t\t/* Map register # to debug register # */\n-extern struct rtx_def *branch_cmp[2];\t/* operands for compare */\n+extern GTY(()) rtx branch_cmp[2];\t/* operands for compare */\n extern enum cmp_type branch_type;\t/* what type of branch to use */\n extern enum processor_type mips_arch;   /* which cpu to codegen for */\n extern enum processor_type mips_tune;   /* which cpu to schedule for */\n@@ -162,10 +162,10 @@ extern int dslots_jump_total;\t\t/* total # jump related delay slots */\n extern int dslots_jump_filled;\t\t/* # filled jump delay slots */\n extern int dslots_number_nops;\t\t/* # of nops needed by previous insn */\n extern int num_refs[3];\t\t\t/* # 1/2/3 word references */\n-extern struct rtx_def *mips_load_reg;\t/* register to check for load delay */\n-extern struct rtx_def *mips_load_reg2;\t/* 2nd reg to check for load delay */\n-extern struct rtx_def *mips_load_reg3;\t/* 3rd reg to check for load delay */\n-extern struct rtx_def *mips_load_reg4;\t/* 4th reg to check for load delay */\n+extern GTY(()) rtx mips_load_reg;\t/* register to check for load delay */\n+extern GTY(()) rtx mips_load_reg2;\t/* 2nd reg to check for load delay */\n+extern GTY(()) rtx mips_load_reg3;\t/* 3rd reg to check for load delay */\n+extern GTY(()) rtx mips_load_reg4;\t/* 4th reg to check for load delay */\n extern int mips_string_length;\t\t/* length of strings for mips16 */\n \n /* Functions to change what output section we are using.  */\n@@ -2790,7 +2790,7 @@ typedef struct mips_args {\n      the shift patterns, and function_arg, which returns them when given\n      a VOIDmode argument.  */\n   unsigned int num_adjusts;\n-  struct rtx_def *adjust[MAX_ARGS_IN_REGISTERS];\n+  rtx adjust[MAX_ARGS_IN_REGISTERS];\n } CUMULATIVE_ARGS;\n \n /* Initialize a variable CUM of type CUMULATIVE_ARGS"}, {"sha": "d85b843767452b07f97e5eea60bd33d90d7633a1", "filename": "gcc/config/mmix/mmix.c", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fmmix%2Fmmix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fmmix%2Fmmix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -98,6 +98,7 @@ static void mmix_output_condition PARAMS ((FILE *, rtx, int));\n static HOST_WIDEST_INT mmix_intval PARAMS ((rtx));\n static void mmix_output_octa PARAMS ((FILE *, HOST_WIDEST_INT, int));\n static bool mmix_assemble_integer PARAMS ((rtx, unsigned int, int));\n+static struct machine_function * mmix_init_machine_status PARAMS ((void));\n static void mmix_init_machine_status PARAMS ((struct function *));\n static void mmix_encode_section_info PARAMS ((tree, int));\n static const char *mmix_strip_name_encoding PARAMS ((const char *));\n@@ -155,11 +156,6 @@ mmix_override_options ()\n       warning (\"-f%s not supported: ignored\", (flag_pic > 1) ? \"PIC\" : \"pic\");\n       flag_pic = 0;\n     }\n-\n-  /* All other targets add GC roots from their override_options function,\n-     so play along.  */\n-  ggc_add_rtx_root (&mmix_compare_op0, 1);\n-  ggc_add_rtx_root (&mmix_compare_op1, 1);\n }\n \n /* INIT_EXPANDERS.  */\n@@ -172,11 +168,10 @@ mmix_init_expanders ()\n \n /* Set the per-function data.  */\n \n-static void\n-mmix_init_machine_status (f)\n-     struct function *f;\n+static struct machine_function *\n+mmix_init_machine_status ()\n {\n-  f->machine = xcalloc (1, sizeof (struct machine_function));\n+  return ggc_alloc_cleared (sizeof (struct machine_function));\n }\n \n /* DATA_ALIGNMENT."}, {"sha": "d553aea418c5c1c38049de5bc266a5f3a9d256bc", "filename": "gcc/config/mmix/mmix.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fmmix%2Fmmix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fmmix%2Fmmix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.h?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -82,13 +82,13 @@ Boston, MA 02111-1307, USA.  */\n \n /* Declarations for helper variables that are not tied to a particular\n    target macro.  */\n-extern struct rtx_def *mmix_compare_op0;\n-extern struct rtx_def *mmix_compare_op1;\n+extern GTY(()) rtx mmix_compare_op0;\n+extern GTY(()) rtx mmix_compare_op1;\n \n /* Per-function machine data.  This is normally an opaque type just\n    defined and used in the tm.c file, but we need to see the definition in\n    mmix.md too.  */\n-struct machine_function\n+struct machine_function GTY(())\n  {\n    int has_landing_pad;\n    int highest_saved_stack_register;"}, {"sha": "4dd1a01b39335b742485423c8e4f4207cd09d1c1", "filename": "gcc/config/mn10200/mn10200.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fmn10200%2Fmn10200.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fmn10200%2Fmn10200.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10200%2Fmn10200.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -85,8 +85,6 @@ asm_file_start (file)\n   else\n     fprintf (file, \"\\n\\n\");\n   output_file_directive (file, main_input_filename);\n-  ggc_add_rtx_root (&zero_dreg, 1);\n-  ggc_add_rtx_root (&zero_areg, 1);\n }\n \n /* Print operand X using operand code CODE to assembly language output file"}, {"sha": "bc9606e7129204cc03603c2108465db8da8d8bf3", "filename": "gcc/config/mn10200/mn10200.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fmn10200%2Fmn10200.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fmn10200%2Fmn10200.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10200%2Fmn10200.h?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -983,5 +983,5 @@ struct cum_arg { int nbytes; };\n \t\t\t\t  SYMBOL_REF, LABEL_REF, SUBREG, REG, MEM }}, \\\n   {\"nshift_operator\",\t\t{ ASHIFTRT, LSHIFTRT, ASHIFT }},\n \n-extern struct rtx_def *zero_dreg;\n-extern struct rtx_def *zero_areg;\n+extern GTY(()) rtx zero_dreg;\n+extern GTY(()) rtx zero_areg;"}, {"sha": "258972534b5541f2e8bcbaddc735354a87ed0dc7", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 9, "deletions": 35, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -100,8 +100,6 @@ static void pa_combine_instructions PARAMS ((rtx));\n static int pa_can_combine_p PARAMS ((rtx, rtx, rtx, int, rtx, rtx, rtx));\n static int forward_branch_p PARAMS ((rtx));\n static int shadd_constant_p PARAMS ((int));\n-static void pa_add_gc_roots PARAMS ((void));\n-static void mark_deferred_plabels PARAMS ((void *));\n static void compute_zdepwi_operands PARAMS ((unsigned HOST_WIDE_INT, unsigned *));\n static int compute_movstrsi_length PARAMS ((rtx));\n static bool pa_assemble_integer PARAMS ((rtx, unsigned int, int));\n@@ -151,12 +149,14 @@ unsigned int total_code_bytes;\n /* Variables to handle plabels that we discover are necessary at assembly\n    output time.  They are output after the current function.  */\n \n-struct deferred_plabel\n+struct deferred_plabel GTY(())\n {\n   rtx internal_label;\n   char *name;\n-} *deferred_plabels = 0;\n-int n_deferred_plabels = 0;\n+};\n+static GTY((length (\"n_deferred_plabels\"))) struct deferred_plabel *\n+  deferred_plabels;\n+static int n_deferred_plabels = 0;\n \f\n /* Initialize the GCC target structure.  */\n \n@@ -301,9 +301,6 @@ override_options ()\n       targetm.asm_out.unaligned_op.si = NULL;\n       targetm.asm_out.unaligned_op.di = NULL;\n     }\n-\n-  /* Register global variables with the garbage collector.  */\n-  pa_add_gc_roots ();\n }\n \n /* Return non-zero only if OP is a register of mode MODE,\n@@ -6277,10 +6274,10 @@ output_call (insn, call_dest, sibcall)\n \n \t      if (deferred_plabels == 0)\n \t\tdeferred_plabels = (struct deferred_plabel *)\n-\t\t  xmalloc (1 * sizeof (struct deferred_plabel));\n+\t\t  ggc_alloc (sizeof (struct deferred_plabel));\n \t      else\n \t\tdeferred_plabels = (struct deferred_plabel *)\n-\t\t  xrealloc (deferred_plabels,\n+\t\t  ggc_realloc (deferred_plabels,\n \t\t\t    ((n_deferred_plabels + 1)\n \t\t\t     * sizeof (struct deferred_plabel)));\n \n@@ -7666,31 +7663,6 @@ cmpib_comparison_operator (op, mode)\n \t      || GET_CODE (op) == LEU));\n }\n \n-/* Mark ARG (which is really a struct deferred_plabel **) for GC.  */\n-\n-static void\n-mark_deferred_plabels (arg)\n-     void *arg;\n-{\n-  struct deferred_plabel *dp = *(struct deferred_plabel **) arg;\n-  int i;\n-\n-  for (i = 0; i < n_deferred_plabels; ++i)\n-    ggc_mark_rtx (dp[i].internal_label);\n-}\n-\n-/* Called to register all of our global variables with the garbage\n-   collector.  */\n-\n-static void\n-pa_add_gc_roots ()\n-{\n-  ggc_add_rtx_root (&hppa_compare_op0, 1);\n-  ggc_add_rtx_root (&hppa_compare_op1, 1);\n-  ggc_add_root (&deferred_plabels, 1, sizeof (&deferred_plabels),\n-\t\t&mark_deferred_plabels);\n-}\n-\n /* On hpux10, the linker will give an error if we have a reference\n    in the read-only data section to a symbol defined in a shared\n    library.  Therefore, expressions that might require a reloc can\n@@ -7717,3 +7689,5 @@ pa_select_section (exp, reloc, align)\n   else\n     data_section ();\n }\n+\n+#include \"gt-pa.h\""}, {"sha": "9dd93f4a0c198d034d7b21eaeab00dec8d00b1f4", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -865,7 +865,8 @@ struct hppa_args {int words, nargs_prototype, indirect; };\n       || ((MODE) && GET_MODE_SIZE (MODE) > 8)))\n \n \f\n-extern struct rtx_def *hppa_compare_op0, *hppa_compare_op1;\n+extern GTY(()) rtx hppa_compare_op0;\n+extern GTY(()) rtx hppa_compare_op1;\n extern enum cmp_type hppa_branch_type;\n \n #define ASM_OUTPUT_MI_THUNK(FILE, THUNK_FNDECL, DELTA, FUNCTION) \\"}, {"sha": "a645695ca10a87514c2e776c2f0ae33aa3a5f60b", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 7, "deletions": 29, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -147,8 +147,7 @@ static int toc_hash_eq PARAMS ((const void *, const void *));\n static int toc_hash_mark_entry PARAMS ((void **, void *));\n static void toc_hash_mark_table PARAMS ((void *));\n static int constant_pool_expr_1 PARAMS ((rtx, int *, int *));\n-static void rs6000_free_machine_status PARAMS ((struct function *));\n-static void rs6000_init_machine_status PARAMS ((struct function *));\n+static struct machine_function * rs6000_init_machine_status PARAMS ((void));\n static bool rs6000_assemble_integer PARAMS ((rtx, unsigned int, int));\n static int rs6000_ra_ever_killed PARAMS ((void));\n static tree rs6000_handle_longcall_attribute PARAMS ((tree *, tree, tree, int, bool *));\n@@ -631,7 +630,6 @@ rs6000_override_options (default_cpu)\n \n   /* Arrange to save and restore machine status around nested functions.  */\n   init_machine_status = rs6000_init_machine_status;\n-  free_machine_status = rs6000_free_machine_status;\n }\n \n /* Handle -mvrsave= options.  */\n@@ -6268,28 +6266,15 @@ rs6000_got_register (value)\n   return pic_offset_table_rtx;\n }\n \f\n-/* Functions to init, mark and free struct machine_function.\n-   These will be called, via pointer variables,\n-   from push_function_context and pop_function_context.  */\n+/* Function to init struct machine_function.\n+   This will be called, via a pointer variable,\n+   from push_function_context.  */\n \n-static void\n-rs6000_init_machine_status (p)\n-     struct function *p;\n-{\n-  p->machine = (machine_function *) xcalloc (1, sizeof (machine_function));\n-}\n-\n-static void\n-rs6000_free_machine_status (p)\n-     struct function *p;\n+static struct machine_function *\n+rs6000_init_machine_status ()\n {\n-  if (p->machine == NULL)\n-    return;\n-\n-  free (p->machine);\n-  p->machine = NULL;\n+  return ggc_alloc_cleared (sizeof (machine_function));\n }\n-\n \f\n /* Print an operand.  Recognize special options, documented below.  */\n \n@@ -11254,16 +11239,9 @@ rs6000_fatal_bad_address (op)\n static void\n rs6000_add_gc_roots ()\n {\n-  ggc_add_rtx_root (&rs6000_compare_op0, 1);\n-  ggc_add_rtx_root (&rs6000_compare_op1, 1);\n-\n   toc_hash_table = htab_create (1021, toc_hash_function, toc_hash_eq, NULL);\n   ggc_add_root (&toc_hash_table, 1, sizeof (toc_hash_table), \n \t\ttoc_hash_mark_table);\n-\n-#if TARGET_MACHO\n-  machopic_add_gc_roots ();\n-#endif\n }\n \n #if TARGET_MACHO"}, {"sha": "d9e0adec23e55f496445247060680b3ed3b0fef7", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -1559,7 +1559,7 @@ typedef struct rs6000_stack {\n \f\n /* A C structure for machine-specific, per-function data.\n    This is added to the cfun structure.  */\n-typedef struct machine_function\n+typedef struct machine_function GTY(())\n {\n   /* Whether a System V.4 varargs area was created.  */\n   int sysv_varargs_p;\n@@ -2400,7 +2400,8 @@ do {\t\t\t\t\t\t\t\t\t     \\\n    stored from the compare operation.  Note that we can't use \"rtx\" here\n    since it hasn't been defined!  */\n \n-extern struct rtx_def *rs6000_compare_op0, *rs6000_compare_op1;\n+extern GTY(()) rtx rs6000_compare_op0;\n+extern GTY(()) rtx rs6000_compare_op1;\n extern int rs6000_compare_fp_p;\n \f\n /* Control the assembler format that we output.  */"}, {"sha": "16295788a73361dd3e0257c221b7442a86ff5bd8", "filename": "gcc/config/rs6000/t-darwin", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Frs6000%2Ft-darwin", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Frs6000%2Ft-darwin", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Ft-darwin?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -16,13 +16,15 @@ fp-bit.c: $(srcdir)/config/fp-bit.c\n darwin.o: $(srcdir)/config/darwin.c $(CONFIG_H) $(SYSTEM_H) $(RTL_BASE_H) \\\n           $(REGS_H) hard-reg-set.h insn-config.h conditions.h output.h \\\n           insn-attr.h flags.h $(TREE_H) $(EXPR_H) reload.h \\\n-          function.h $(GGC_H) $(TM_P_H)\n+          function.h $(GGC_H) $(TM_P_H) gt-darwin.h\n \t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $<\n \n darwin-c.o: $(srcdir)/config/darwin-c.c $(CONFIG_H) $(SYSTEM_H) \\\n \t    $(TREE_H) $(C_TREE_H) c-pragma.h toplev.h cpplib.h $(TM_P_H)\n \t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $<\n \n+gt-darwin.h : s-gtype ; @true\n+\n # Build the libraries for both hard and soft floating point\n \n MULTILIB_OPTIONS = msoft-float"}, {"sha": "7656151f280fada419ec42f25522dd7419d106e2", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -6230,16 +6230,14 @@ reg_unused_after (reg, insn)\n \f\n #include \"ggc.h\"\n \n+static GTY(()) rtx fpscr_rtx;\n rtx\n get_fpscr_rtx ()\n {\n-  static rtx fpscr_rtx;\n-\n   if (! fpscr_rtx)\n     {\n       fpscr_rtx = gen_rtx (REG, PSImode, FPSCR_REG);\n       REG_USERVAR_P (fpscr_rtx) = 1;\n-      ggc_add_rtx_root (&fpscr_rtx, 1);\n       mark_user_reg (fpscr_rtx);\n     }\n   if (! reload_completed || mdep_reorg_phase != SH_AFTER_MDEP_REORG)\n@@ -6819,3 +6817,5 @@ sh_strip_name_encoding (str)\n   str += *str == '*';\n   return str;\n }\n+\n+#include \"gt-sh.h\""}, {"sha": "79528dd7d18a9c88b951319bf855e8332457a5ef", "filename": "gcc/config/sh/t-sh", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fsh%2Ft-sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fsh%2Ft-sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Ft-sh?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -44,5 +44,8 @@ $(T)crti.o: $(srcdir)/config/sh/crti.asm $(GCC_PASSES)\n $(T)crtn.o: $(srcdir)/config/sh/crtn.asm $(GCC_PASSES)\n \t$(GCC_FOR_TARGET) $(MULTILIB_CFLAGS) -c -o $(T)crtn.o -x assembler-with-cpp $(srcdir)/config/sh/crtn.asm\n \n+$(out_object_file): gt-sh.h\n+gt-sh.h : s-gtype ; @true\n+\n # These are not suitable for COFF.\n # EXTRA_MULTILIB_PARTS= crt1.o crti.o crtn.o crtbegin.o crtend.o"}, {"sha": "b9745c7c529315532a67bd29bd13aa3b70066b11", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 6, "deletions": 22, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -140,7 +140,6 @@ static int hypersparc_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n static void sparc_output_addr_vec PARAMS ((rtx));\n static void sparc_output_addr_diff_vec PARAMS ((rtx));\n static void sparc_output_deferred_case_vectors PARAMS ((void));\n-static void sparc_add_gc_roots    PARAMS ((void));\n static int check_return_regs PARAMS ((rtx));\n static int epilogue_renumber PARAMS ((rtx *, int));\n static bool sparc_assemble_integer PARAMS ((rtx, unsigned int, int));\n@@ -438,9 +437,6 @@ sparc_override_options ()\n \n   /* Do various machine dependent initializations.  */\n   sparc_init_modes ();\n-\n-  /* Register global variables with the garbage collector.  */\n-  sparc_add_gc_roots ();\n }\n \f\n /* Miscellaneous utilities.  */\n@@ -3114,10 +3110,10 @@ reg_unused_after (reg, insn)\n }\n \f\n /* The table we use to reference PIC data.  */\n-static rtx global_offset_table;\n+static GTY(()) rtx global_offset_table;\n \n /* The function we use to get at it.  */\n-static rtx get_pc_symbol;\n+static GTY(()) rtx get_pc_symbol;\n static char get_pc_symbol_name[256];\n \n /* Ensure that we are not using patterns that are not OK with PIC.  */\n@@ -7786,8 +7782,8 @@ set_extends (insn)\n }\n \n /* We _ought_ to have only one kind per function, but...  */\n-static rtx sparc_addr_diff_list;\n-static rtx sparc_addr_list;\n+static GTY(()) rtx sparc_addr_diff_list;\n+static GTY(()) rtx sparc_addr_list;\n \n void\n sparc_defer_case_vector (lab, vec, diff)\n@@ -7997,20 +7993,6 @@ sparc_profile_hook (labelno)\n   emit_library_call (fun, LCT_NORMAL, VOIDmode, 1, lab, Pmode);\n }\n \f\n-/* Called to register all of our global variables with the garbage\n-   collector.  */\n-\n-static void\n-sparc_add_gc_roots ()\n-{\n-  ggc_add_rtx_root (&sparc_compare_op0, 1);\n-  ggc_add_rtx_root (&sparc_compare_op1, 1);\n-  ggc_add_rtx_root (&global_offset_table, 1);\n-  ggc_add_rtx_root (&get_pc_symbol, 1);\n-  ggc_add_rtx_root (&sparc_addr_diff_list, 1);\n-  ggc_add_rtx_root (&sparc_addr_list, 1);\n-}\n-\n #ifdef OBJECT_FORMAT_ELF\n static void\n sparc_elf_asm_named_section (name, flags)\n@@ -8530,3 +8512,5 @@ sparc_output_mi_thunk (file, thunk_fndecl, delta, function)\n   reload_completed = 0;\n   no_new_pseudos = 0;\n }\n+\n+#include \"gt-sparc.h\""}, {"sha": "333a5d56f164b8599a76cf70ec8367840ac936b2", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -1809,7 +1809,8 @@ function_arg_padding ((MODE), (TYPE))\n    stored from the compare operation.  Note that we can't use \"rtx\" here\n    since it hasn't been defined!  */\n \n-extern struct rtx_def *sparc_compare_op0, *sparc_compare_op1;\n+extern GTY(()) rtx sparc_compare_op0;\n+extern GTY(()) rtx sparc_compare_op1;\n \n \f\n /* Generate the special assembly code needed to tell the assembler whatever"}, {"sha": "c29fff075c4a51ac72dd6ed82de26240c41f6c25", "filename": "gcc/config/xtensa/t-xtensa", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fxtensa%2Ft-xtensa", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fxtensa%2Ft-xtensa", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Ft-xtensa?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -27,3 +27,6 @@ LIB1ASMFUNCS = _mulsi3 _nsau _divsi3 _modsi3 _udivsi3 _umodsi3\n TARGET_LIBGCC2_CFLAGS += -mlongcalls\n \n LIB2FUNCS_EXTRA += $(srcdir)/config/xtensa/lib2funcs.S\n+\n+$(out_object_file): gt-xtensa.h\n+gt-xtensa.h : s-gtype ; @true"}, {"sha": "6e6c6d9a3e3839f924712849686a3d30f97971a1", "filename": "gcc/config/xtensa/xtensa.c", "status": "modified", "additions": 7, "deletions": 18, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -85,7 +85,7 @@ const char *xtensa_st_opcodes[(int) MAX_MACHINE_MODE];\n #define LARGEST_MOVE_RATIO 15\n \n /* Define the structure for the machine field in struct function.  */\n-struct machine_function\n+struct machine_function GTY(())\n {\n   int accesses_prev_frame;\n };\n@@ -193,8 +193,7 @@ static rtx gen_float_relational PARAMS ((enum rtx_code, rtx, rtx));\n static rtx gen_conditional_move PARAMS ((rtx));\n static rtx fixup_subreg_mem PARAMS ((rtx x));\n static enum machine_mode xtensa_find_mode_for_size PARAMS ((unsigned));\n-static void xtensa_init_machine_status PARAMS ((struct function *p));\n-static void xtensa_free_machine_status PARAMS ((struct function *p));\n+static struct machine_status * xtensa_init_machine_status PARAMS ((void));\n static void printx PARAMS ((FILE *, signed int));\n static void xtensa_select_rtx_section PARAMS ((enum machine_mode, rtx,\n \t\t\t\t\t       unsigned HOST_WIDE_INT));\n@@ -1549,21 +1548,10 @@ xtensa_expand_nonlocal_goto (operands)\n }\n \n \n-static void\n-xtensa_init_machine_status (p)\n-     struct function *p;\n+static struct machine_function *\n+xtensa_init_machine_status ()\n {\n-  p->machine = (struct machine_function *)\n-    xcalloc (1, sizeof (struct machine_function));\n-}\n-\n-\n-static void\n-xtensa_free_machine_status (p)\n-     struct function *p;\n-{\n-  free (p->machine);\n-  p->machine = NULL;\n+  return ggc_alloc_cleared (sizeof (struct machine_function));\n }\n \n \n@@ -1846,7 +1834,6 @@ override_options ()\n     }\n \n   init_machine_status = xtensa_init_machine_status;\n-  free_machine_status = xtensa_free_machine_status;\n \n   /* Check PIC settings.  There's no need for -fPIC on Xtensa and\n      some targets need to always use PIC.  */\n@@ -2759,3 +2746,5 @@ xtensa_encode_section_info (decl, first)\n   if (TREE_CODE (decl) == FUNCTION_DECL && ! TREE_PUBLIC (decl))\n     SYMBOL_REF_FLAG (XEXP (DECL_RTL (decl), 0)) = 1;\n }\n+\n+#include \"gt-xtensa.h\""}, {"sha": "b949926770ae8e4dcc6e84fcbce0687df303f009", "filename": "gcc/configure", "status": "modified", "additions": 39, "deletions": 29, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -2226,7 +2226,7 @@ EOF\n fi\n \n # Find some useful tools\n-for ac_prog in mawk gawk nawk awk\n+for ac_prog in gawk mawk nawk awk\n do\n # Extract the first word of \"$ac_prog\", so it can be a program name with args.\n set dummy $ac_prog; ac_word=$2\n@@ -6706,7 +6706,7 @@ for f in $tm_file; do\n     ansidecl.h )\n        tm_file_list=\"${tm_file_list} \\$(srcdir)/../include/ansidecl.h\" ;;\n     defaults.h )\n-       tm_file_list=\"${tm_file_list} $f\" ;;\n+       tm_file_list=\"${tm_file_list} \\$(srcdir)/$f\" ;;\n     *) tm_file_list=\"${tm_file_list} \\$(srcdir)/config/$f\" ;;\n   esac\n done\n@@ -6721,8 +6721,10 @@ for f in $host_xm_file; do\n   case $f in\n     ansidecl.h )\n        host_xm_file_list=\"${host_xm_file_list} \\$(srcdir)/../include/ansidecl.h\" ;;\n-    auto-host.h | defaults.h )\n+    auto-host.h )\n        host_xm_file_list=\"${host_xm_file_list} $f\" ;;\n+    defaults.h )\n+       host_xm_file_list=\"${host_xm_file_list} \\$(srcdir)/$f\" ;;\n     *) host_xm_file_list=\"${host_xm_file_list} \\$(srcdir)/config/$f\" ;;\n   esac\n done\n@@ -6732,8 +6734,10 @@ for f in $build_xm_file; do\n   case $f in\n     ansidecl.h )\n        build_xm_file_list=\"${build_xm_file_list} \\$(srcdir)/../include/ansidecl.h\" ;;\n-    auto-build.h | auto-host.h | defaults.h )\n+    auto-build.h | auto-host.h )\n        build_xm_file_list=\"${build_xm_file_list} $f\" ;;\n+    defaults.h )\n+       host_xm_file_list=\"${host_xm_file_list} \\$(srcdir)/$f\" ;;\n     *) build_xm_file_list=\"${build_xm_file_list} \\$(srcdir)/config/$f\" ;;\n   esac\n done\n@@ -6841,7 +6845,7 @@ fi\n \n # Figure out what assembler we will be using.\n echo $ac_n \"checking what assembler to use\"\"... $ac_c\" 1>&6\n-echo \"configure:6845: checking what assembler to use\" >&5\n+echo \"configure:6849: checking what assembler to use\" >&5\n gcc_cv_as=\n gcc_cv_gas_major_version=\n gcc_cv_gas_minor_version=\n@@ -6935,7 +6939,7 @@ fi\n \n # Figure out what linker we will be using.\n echo $ac_n \"checking what linker to use\"\"... $ac_c\" 1>&6\n-echo \"configure:6939: checking what linker to use\" >&5\n+echo \"configure:6943: checking what linker to use\" >&5\n gcc_cv_ld=\n gcc_cv_gld_major_version=\n gcc_cv_gld_minor_version=\n@@ -7028,7 +7032,7 @@ fi\n \n # Figure out what nm we will be using.\n echo $ac_n \"checking what nm to use\"\"... $ac_c\" 1>&6\n-echo \"configure:7032: checking what nm to use\" >&5\n+echo \"configure:7036: checking what nm to use\" >&5\n if test -x nm$host_exeext; then\n \tgcc_cv_nm=./nm$host_exeext\n elif test \"x$program_prefix\" != xNONE; then\n@@ -7040,7 +7044,7 @@ echo \"$ac_t\"\"$gcc_cv_nm\" 1>&6\n \n # Figure out what objdump we will be using.\n echo $ac_n \"checking what objdump to use\"\"... $ac_c\" 1>&6\n-echo \"configure:7044: checking what objdump to use\" >&5\n+echo \"configure:7048: checking what objdump to use\" >&5\n if test -x objdump$host_exeext; then\n \tgcc_cv_objdump=./objdump$host_exeext\n elif test \"x$program_prefix\" != xNONE; then\n@@ -7052,7 +7056,7 @@ echo \"$ac_t\"\"$gcc_cv_objdump\" 1>&6\n \n # Figure out what assembler alignment features are present.\n echo $ac_n \"checking assembler alignment features\"\"... $ac_c\" 1>&6\n-echo \"configure:7056: checking assembler alignment features\" >&5\n+echo \"configure:7060: checking assembler alignment features\" >&5\n gcc_cv_as_alignment_features=none\n if test x$gcc_cv_gas_major_version != x -a x$gcc_cv_gas_minor_version != x; then\n \t# Gas version 2.6 and later support for .balign and .p2align.\n@@ -7100,7 +7104,7 @@ fi\n echo \"$ac_t\"\"$gcc_cv_as_alignment_features\" 1>&6\n \n echo $ac_n \"checking assembler subsection support\"\"... $ac_c\" 1>&6\n-echo \"configure:7104: checking assembler subsection support\" >&5\n+echo \"configure:7108: checking assembler subsection support\" >&5\n gcc_cv_as_subsections=no\n if test x$gcc_cv_gas_major_version != x -a x$gcc_cv_gas_minor_version != x; then\n   if test \"$gcc_cv_gas_major_version\" -eq 2 -a \"$gcc_cv_gas_minor_version\" -ge 9 -o \"$gcc_cv_gas_major_version\" -gt 2 && grep 'obj_format = elf' ../gas/Makefile > /dev/null; then\n@@ -7140,7 +7144,7 @@ fi\n echo \"$ac_t\"\"$gcc_cv_as_subsections\" 1>&6\n \n echo $ac_n \"checking assembler weak support\"\"... $ac_c\" 1>&6\n-echo \"configure:7144: checking assembler weak support\" >&5\n+echo \"configure:7148: checking assembler weak support\" >&5\n gcc_cv_as_weak=no\n if test x$gcc_cv_gas_major_version != x -a x$gcc_cv_gas_minor_version != x; then\n   if test \"$gcc_cv_gas_major_version\" -eq 2 -a \"$gcc_cv_gas_minor_version\" -ge 2 -o \"$gcc_cv_gas_major_version\" -gt 2; then\n@@ -7163,7 +7167,7 @@ fi\n echo \"$ac_t\"\"$gcc_cv_as_weak\" 1>&6\n \n echo $ac_n \"checking assembler hidden support\"\"... $ac_c\" 1>&6\n-echo \"configure:7167: checking assembler hidden support\" >&5\n+echo \"configure:7171: checking assembler hidden support\" >&5\n gcc_cv_as_hidden=no\n if test x$gcc_cv_gas_major_version != x -a x$gcc_cv_gas_minor_version != x; then\n   if test \"$gcc_cv_gas_major_version\" -eq 2\t\\\n@@ -7226,7 +7230,7 @@ libgcc_visibility=$gcc_cv_as_hidden\n \n \n echo $ac_n \"checking assembler leb128 support\"\"... $ac_c\" 1>&6\n-echo \"configure:7230: checking assembler leb128 support\" >&5\n+echo \"configure:7234: checking assembler leb128 support\" >&5\n gcc_cv_as_leb128=no\n if test x$gcc_cv_gas_major_version != x -a x$gcc_cv_gas_minor_version != x; then\n   if test \"$gcc_cv_gas_major_version\" -eq 2 -a \"$gcc_cv_gas_minor_version\" -ge 11 -o \"$gcc_cv_gas_major_version\" -gt 2 && grep 'obj_format = elf' ../gas/Makefile > /dev/null; then\n@@ -7271,7 +7275,7 @@ fi\n echo \"$ac_t\"\"$gcc_cv_as_leb128\" 1>&6\n \n echo $ac_n \"checking assembler eh_frame optimization\"\"... $ac_c\" 1>&6\n-echo \"configure:7275: checking assembler eh_frame optimization\" >&5\n+echo \"configure:7279: checking assembler eh_frame optimization\" >&5\n gcc_cv_as_eh_frame=no\n if test x$gcc_cv_gas_major_version != x -a x$gcc_cv_gas_minor_version != x; then\n   if test \"$gcc_cv_gas_major_version\" -eq 2 -a \"$gcc_cv_gas_minor_version\" -ge 12 -o \"$gcc_cv_gas_major_version\" -gt 2 && grep 'obj_format = elf' ../gas/Makefile > /dev/null; then\n@@ -7352,7 +7356,7 @@ fi\n echo \"$ac_t\"\"$gcc_cv_as_eh_frame\" 1>&6\n \n echo $ac_n \"checking assembler section merging support\"\"... $ac_c\" 1>&6\n-echo \"configure:7356: checking assembler section merging support\" >&5\n+echo \"configure:7360: checking assembler section merging support\" >&5\n gcc_cv_as_shf_merge=no\n if test x$gcc_cv_gas_major_version != x -a x$gcc_cv_gas_minor_version != x; then\n   if test \"$gcc_cv_gas_major_version\" -eq 2 -a \"$gcc_cv_gas_minor_version\" -ge 12 -o \"$gcc_cv_gas_major_version\" -gt 2 && grep 'obj_format = elf' ../gas/Makefile > /dev/null; then\n@@ -7375,7 +7379,7 @@ fi\n echo \"$ac_t\"\"$gcc_cv_as_shf_merge\" 1>&6\n \n echo $ac_n \"checking assembler thread-local storage support\"\"... $ac_c\" 1>&6\n-echo \"configure:7379: checking assembler thread-local storage support\" >&5\n+echo \"configure:7383: checking assembler thread-local storage support\" >&5\n gcc_cv_as_tls=no\n conftest_s=\n tls_first_major=\n@@ -7467,7 +7471,7 @@ case \"$target\" in\n   # All TARGET_ABI_OSF targets.\n   alpha*-*-osf* | alpha*-*-linux* | alpha*-*-*bsd*)\n     echo $ac_n \"checking assembler supports explicit relocations\"\"... $ac_c\" 1>&6\n-echo \"configure:7471: checking assembler supports explicit relocations\" >&5\n+echo \"configure:7475: checking assembler supports explicit relocations\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_explicit_relocs'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -7517,7 +7521,7 @@ EOF\n     ;;\n   sparc*-*-*)\n     echo $ac_n \"checking assembler .register pseudo-op support\"\"... $ac_c\" 1>&6\n-echo \"configure:7521: checking assembler .register pseudo-op support\" >&5\n+echo \"configure:7525: checking assembler .register pseudo-op support\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_register_pseudo_op'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -7545,7 +7549,7 @@ EOF\n     fi\n \n     echo $ac_n \"checking assembler supports -relax\"\"... $ac_c\" 1>&6\n-echo \"configure:7549: checking assembler supports -relax\" >&5\n+echo \"configure:7553: checking assembler supports -relax\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_relax_opt'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -7573,7 +7577,7 @@ EOF\n     fi\n \n     echo $ac_n \"checking assembler and linker support unaligned pc related relocs\"\"... $ac_c\" 1>&6\n-echo \"configure:7577: checking assembler and linker support unaligned pc related relocs\" >&5\n+echo \"configure:7581: checking assembler and linker support unaligned pc related relocs\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_sparc_ua_pcrel'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -7600,7 +7604,7 @@ EOF\n     fi\n \n     echo $ac_n \"checking assembler and linker support unaligned pc related relocs against hidden symbols\"\"... $ac_c\" 1>&6\n-echo \"configure:7604: checking assembler and linker support unaligned pc related relocs against hidden symbols\" >&5\n+echo \"configure:7608: checking assembler and linker support unaligned pc related relocs against hidden symbols\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_sparc_ua_pcrel_hidden'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -7641,7 +7645,7 @@ EOF\n \n     if test \"x$gcc_cv_as_flags64\" != xno; then\n \techo $ac_n \"checking for assembler offsetable %lo() support\"\"... $ac_c\" 1>&6\n-echo \"configure:7645: checking for assembler offsetable %lo() support\" >&5\n+echo \"configure:7649: checking for assembler offsetable %lo() support\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_offsetable_lo10'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -7681,7 +7685,7 @@ EOF\n \n   i[34567]86-*-* | x86_64-*-*)\n     echo $ac_n \"checking assembler instructions\"\"... $ac_c\" 1>&6\n-echo \"configure:7685: checking assembler instructions\" >&5\n+echo \"configure:7689: checking assembler instructions\" >&5\n     gcc_cv_as_instructions=\n     if test x$gcc_cv_gas_major_version != x -a x$gcc_cv_gas_minor_version != x; then\n       if test \"$gcc_cv_gas_major_version\" -eq 2 -a \"$gcc_cv_gas_minor_version\" -ge 9 -o \"$gcc_cv_gas_major_version\" -gt 2; then\n@@ -7708,7 +7712,7 @@ EOF\n     echo \"$ac_t\"\"$gcc_cv_as_instructions\" 1>&6\n \n     echo $ac_n \"checking assembler GOTOFF in data directives\"\"... $ac_c\" 1>&6\n-echo \"configure:7712: checking assembler GOTOFF in data directives\" >&5\n+echo \"configure:7716: checking assembler GOTOFF in data directives\" >&5\n     gcc_cv_as_gotoff_in_data=no\n     if test x$gcc_cv_gas_major_version != x -a x$gcc_cv_gas_minor_version != x\n     then\n@@ -7738,7 +7742,7 @@ EOF\n esac\n \n echo $ac_n \"checking assembler dwarf2 debug_line support\"\"... $ac_c\" 1>&6\n-echo \"configure:7742: checking assembler dwarf2 debug_line support\" >&5\n+echo \"configure:7746: checking assembler dwarf2 debug_line support\" >&5\n gcc_cv_as_dwarf2_debug_line=no\n # ??? Not all targets support dwarf2 debug_line, even within a version\n # of gas.  Moreover, we need to emit a valid instruction to trigger any\n@@ -7794,7 +7798,7 @@ fi\n echo \"$ac_t\"\"$gcc_cv_as_dwarf2_debug_line\" 1>&6\n \n echo $ac_n \"checking assembler --gdwarf2 support\"\"... $ac_c\" 1>&6\n-echo \"configure:7798: checking assembler --gdwarf2 support\" >&5\n+echo \"configure:7802: checking assembler --gdwarf2 support\" >&5\n gcc_cv_as_gdwarf2_flag=no\n if test x$gcc_cv_gas_major_version != x -a x$gcc_cv_gas_minor_version != x;\n then\n@@ -7823,7 +7827,7 @@ fi\n echo \"$ac_t\"\"$gcc_cv_as_gdwarf2_flag\" 1>&6\n \n echo $ac_n \"checking assembler --gstabs support\"\"... $ac_c\" 1>&6\n-echo \"configure:7827: checking assembler --gstabs support\" >&5\n+echo \"configure:7831: checking assembler --gstabs support\" >&5\n gcc_cv_as_gstabs_flag=no\n if test x$gcc_cv_gas_major_version != x -a x$gcc_cv_gas_minor_version != x;\n then\n@@ -7851,7 +7855,7 @@ fi\n echo \"$ac_t\"\"$gcc_cv_as_gstabs_flag\" 1>&6\n \n echo $ac_n \"checking linker PT_GNU_EH_FRAME support\"\"... $ac_c\" 1>&6\n-echo \"configure:7855: checking linker PT_GNU_EH_FRAME support\" >&5\n+echo \"configure:7859: checking linker PT_GNU_EH_FRAME support\" >&5\n gcc_cv_ld_eh_frame_hdr=no\n if test x$gcc_cv_gld_major_version != x -a x$gcc_cv_gld_minor_version != x; then\n   if test \"$gcc_cv_gld_major_version\" -eq 2 -a \"$gcc_cv_gld_minor_version\" -ge 12 -o \"$gcc_cv_gld_major_version\" -gt 2 && grep 'EMUL = elf' ../ld/Makefile > /dev/null; then\n@@ -8014,7 +8018,7 @@ fi\n \n \n echo $ac_n \"checking whether to enable maintainer-specific portions of Makefiles\"\"... $ac_c\" 1>&6\n-echo \"configure:8018: checking whether to enable maintainer-specific portions of Makefiles\" >&5\n+echo \"configure:8022: checking whether to enable maintainer-specific portions of Makefiles\" >&5\n     # Check whether --enable-maintainer-mode or --disable-maintainer-mode was given.\n if test \"${enable_maintainer_mode+set}\" = set; then\n   enableval=\"$enable_maintainer_mode\"\n@@ -8072,6 +8076,8 @@ all_stagestuff=\n all_outputs='Makefile intl/Makefile fixinc/Makefile gccbug mklibgcc mkheaders'\n # List of language makefile fragments.\n all_lang_makefiles=\n+# Files for gengtype\n+all_gtfiles=\n \n # Add the language fragments.\n # Languages are added via two mechanisms.  Some information must be\n@@ -8092,6 +8098,7 @@ do\n \t\tcompilers=\n \t\tstagestuff=\n \t\toutputs=\n+\t\tgtfiles=\n \t\t. ${srcdir}/$s/config-lang.in\n \t\tif test \"x$language\" = x\n \t\tthen\n@@ -8110,6 +8117,7 @@ do\n \t\tall_compilers=\"$all_compilers $compilers\"\n \t\tall_stagestuff=\"$all_stagestuff $stagestuff\"\n \t\tall_outputs=\"$all_outputs $outputs\"\n+\t\tall_gtfiles=\"$all_gtfiles $gtfiles\"\n \tfi\n done\n \n@@ -8304,6 +8312,7 @@ ${CONFIG_SHELL-/bin/sh} $srcdir/configure.frag $srcdir \"$subdirs\" \"$dep_host_xma\n \n \n \n+\n \n \n # Echo that links are built\n@@ -8569,6 +8578,7 @@ s%@objdir@%$objdir%g\n s%@subdirs@%$subdirs%g\n s%@all_boot_languages@%$all_boot_languages%g\n s%@all_compilers@%$all_compilers%g\n+s%@all_gtfiles@%$all_gtfiles%g\n s%@all_lang_makefiles@%$all_lang_makefiles%g\n s%@all_languages@%$all_languages%g\n s%@all_stagestuff@%$all_stagestuff%g"}, {"sha": "d6a395ee425eae9b5fd0eea6b1dc3739ac829d16", "filename": "gcc/configure.in", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.in?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -1062,7 +1062,7 @@ for f in $tm_file; do\n     ansidecl.h )\n        tm_file_list=\"${tm_file_list} \\$(srcdir)/../include/ansidecl.h\" ;;\n     defaults.h )\n-       tm_file_list=\"${tm_file_list} $f\" ;;\n+       tm_file_list=\"${tm_file_list} \\$(srcdir)/$f\" ;;\n     *) tm_file_list=\"${tm_file_list} \\$(srcdir)/config/$f\" ;;\n   esac\n done\n@@ -1077,8 +1077,10 @@ for f in $host_xm_file; do\n   case $f in\n     ansidecl.h )\n        host_xm_file_list=\"${host_xm_file_list} \\$(srcdir)/../include/ansidecl.h\" ;;\n-    auto-host.h | defaults.h )\n+    auto-host.h )\n        host_xm_file_list=\"${host_xm_file_list} $f\" ;;\n+    defaults.h )\n+       host_xm_file_list=\"${host_xm_file_list} \\$(srcdir)/$f\" ;;\n     *) host_xm_file_list=\"${host_xm_file_list} \\$(srcdir)/config/$f\" ;;\n   esac\n done\n@@ -1088,8 +1090,10 @@ for f in $build_xm_file; do\n   case $f in\n     ansidecl.h )\n        build_xm_file_list=\"${build_xm_file_list} \\$(srcdir)/../include/ansidecl.h\" ;;\n-    auto-build.h | auto-host.h | defaults.h )\n+    auto-build.h | auto-host.h )\n        build_xm_file_list=\"${build_xm_file_list} $f\" ;;\n+    defaults.h )\n+       host_xm_file_list=\"${host_xm_file_list} \\$(srcdir)/$f\" ;;\n     *) build_xm_file_list=\"${build_xm_file_list} \\$(srcdir)/config/$f\" ;;\n   esac\n done\n@@ -2326,6 +2330,8 @@ all_stagestuff=\n all_outputs='Makefile intl/Makefile fixinc/Makefile gccbug mklibgcc mkheaders'\n # List of language makefile fragments.\n all_lang_makefiles=\n+# Files for gengtype\n+all_gtfiles=\n \n # Add the language fragments.\n # Languages are added via two mechanisms.  Some information must be\n@@ -2346,6 +2352,7 @@ do\n \t\tcompilers=\n \t\tstagestuff=\n \t\toutputs=\n+\t\tgtfiles=\n \t\t. ${srcdir}/$s/config-lang.in\n \t\tif test \"x$language\" = x\n \t\tthen\n@@ -2364,6 +2371,7 @@ do\n \t\tall_compilers=\"$all_compilers $compilers\"\n \t\tall_stagestuff=\"$all_stagestuff $stagestuff\"\n \t\tall_outputs=\"$all_outputs $outputs\"\n+\t\tall_gtfiles=\"$all_gtfiles $gtfiles\"\n \tfi\n done\n \n@@ -2496,6 +2504,7 @@ ${CONFIG_SHELL-/bin/sh} $srcdir/configure.frag $srcdir \"$subdirs\" \"$dep_host_xma\n AC_SUBST(subdirs)\n AC_SUBST(all_boot_languages)\n AC_SUBST(all_compilers)\n+AC_SUBST(all_gtfiles)\n AC_SUBST(all_lang_makefiles)\n AC_SUBST(all_languages)\n AC_SUBST(all_stagestuff)"}, {"sha": "e3af880f414e2eca3195b4b8b4ac47368563e408", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 210, "deletions": 0, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -1,3 +1,213 @@\n+2002-06-03  Geoffrey Keating  <geoffk@redhat.com>\n+\n+\t* pt.c (inline_parm_levels): Mark for GC.\n+\n+\t* mangle.c (start_mangling): Allocate G.substitutions here...\n+\t(init_mangle): ... rather than here.\n+\t(finish_mangling): Clear the varray pointer when done with it.\n+\t* spew.c (yylexstring): Don't use VARRAY_FREE. \n+\t* search.c (bfs_walk): Don't use VARRAY_FREE. \n+\t* decl2.c (pending_statics): Use gengtype to mark.\n+\t(deferred_fns): Likewise.\n+\t(ssdf_decls): Likewise.\n+\t(init_decl2): Delete.\n+\t* decl.c (pop_from_top_level): Don't use VARRAY_FREE.\n+\t(cxx_init_decl_processing): Don't call init_decl2.\n+\t(cxx_pop_function_context): Don't use VARRAY_FREE.\n+\t* cp-tree.h (struct saved_scope): No need for special marking\n+\tof varrays.\n+\t(struct language_function): Likewise.\n+\t(local_classes): Use gengtype to mark.\n+\t(init_decl2): Delete prototype.\n+\t* class.c (init_class_processing): Don't use\n+\tggc_add_tree_varray_root.\n+\t(build_vtbl_initializer): Don't use VARRAY_FREE.\n+\n+\t* decl.c (typename_compare): Don't use same_type_p.\n+\n+\t* decl.c: Include hashtab.h instead of hash.h.\n+\t(typename_hash): Update to use htab_h.\n+\t(typename_compare): Likewise.\n+\t(typename_htab): Use gengtype to mark.\n+\t(build_typename_type): Update to use htab_h.\n+\t* Make-lang.in (cp/decl.o): Use HASHTAB_H instead of hash.h.\n+\n+\t* Make-lang.in (gt-cp-tree.h): New rule.\n+\t(cp/tree.o): Depend on gt-cp-tree.h.\n+\t* config-lang.in (gtfiles): Add cp/tree.c.\n+\t* tree.c: Include gt-cp-tree.h.\n+\t(list_hash_table): Use gengtype to mark.\n+\t(init_tree): Use gengtype to mark trees.\n+\n+\t* Make-lang.in (cp/decl.o): Add debug.h dependency.\n+\t* call.c (struct z_candidate): Use gengtype.\n+\t(USER_CONV_CAND): Use WRAPPER_ZC.\n+\t(convert_class_to_reference): Use build_zc_wrapper.\n+\t(build_type_conversion_1): Likewise.\n+\t(build_over_call): Use WRAPPER_ZC.\n+\t(add_warning): Use build_zc_wrapper.\n+\t* cp-lang.c (LANG_HOOKS_MARK_TREE): Delete.\n+\t* cp-tree.h (struct lang_identifier): Use gengtype.\n+\t(struct template_parm_index_s): Likewise.\n+\t(struct ptrmem_cst): Likewise.\n+\t(struct tree_binding): Likewise.\n+\t(struct tree_overload): Likewise.\n+\t(struct tree_srcloc): Likewise.\n+\t(struct tree_wrapper): Likewise.  Also modify to have a pointer\n+\tto struct z_candidate rather than void.\n+\t(enum cp_tree_node_structure_enum): New.\n+\t(union lang_tree_node): New.\n+\t(cxx_mark_tree): Delete prototype.\n+\t(cp_tree_node_structure): New prototype.\n+\t(build_ptr_wrapper): Delete prototype.\n+\t(build_int_wrapper): Delete prototype.\n+\t(build_zc_wrapper): New prototype.\n+\t* decl.c: Include debug.h\n+\t(cxx_mark_tree): Delete.\n+\t(cp_tree_node_structure): New.\n+\t* tree.c (build_ptr_wrapper): Delete.\n+\t(build_int_wrapper): Delete.\n+\t(build_zc_wrapper): New.\n+\n+\t* cp-tree.h [! ENABLE_TREE_CHECKING] (LANG_TYPE_PTRMEM_CHECK):\n+\tCorrect typo.  Patch from k_fukui@highway.ne.jp.\n+\n+\t* semantics.c (current_stmt_tree): Update for change to\n+\tstruct language_function.\n+\t(finish_mem_initializers): Likewise.\n+\t* decl.c (cxx_init_decl_processing): Don't set mark_lang_status.\n+\t* cp-tree.h (struct language_function): Rename from\n+\tcp_language_function.  Change all uses.\n+\t(cp_function_chain): Don't need to cast.\n+\n+\t* class.c (duplicate_tag_error): Reset discriminator.\n+\t(check_bases_and_members): Update for data structure changes.\n+\t* cp-tree.h (struct lang_id2): Use gengtype.\n+\t(flagged_type_tree): Likewise.\n+\t(SET_LANG_ID): Use GGC on struct lang_id2.\n+\t(struct cp_language_function): Use gengtype.  Remove field\n+\t'x_vcalls_possible_p'.\n+\t(current_vcalls_possible_p): Delete.\n+\t(struct lang_type_header): New.\n+\t(struct lang_type_class): Rename from struct lang_type.  Include\n+\tstruct lang_type_header.\n+\t(struct lang_type_ptrmem): New.\n+\t(struct lang_type): New.\n+\t(LANG_TYPE_CLASS_CHECK): New.  Use it in all the appropriate macros.\n+\t(LANG_TYPE_PTRMEM_CHECK): New.  Use it in all the appropriate macros.\n+\t(TYPE_SET_PTRMEMFUNC_TYPE): Set discriminator, update for changes.\n+\t(struct lang_decl_flags): Use gengtype.  Add discriminators.\n+\t(struct lang_decl): Use gengtype.  Add and use discriminators.\n+\tUpdate the macros that reference moved fields.\n+\t(LANG_DECL_U2_CHECK): New function.  Use it when appropriate.\n+\t(SET_DECL_THUNK_P): Set discriminator too.\n+\t(clear_inline_text_obstack): Delete prototype.\n+\t(finish_inline_definitions): Delete prototype.\n+\t(mark_pending_inlines): Delete prototype.\n+\t(lang_check_failed): New prototype.\n+\t* decl.c (struct named_label_use_list): Use gengtype.\n+\t(struct named_label_list): Likewise.\n+\t(mark_binding_level): Delete.\n+\t(mark_named_label_lists): Delete.\n+\t(push_local_name): Set discriminator on DECL_LANG_SPECIFIC.\n+\t(cxx_init_decl_processing): Use generated marker routine.\n+\t(begin_destructor_body): Delete dead set to\n+\tcurrent_vcalls_possible_p.\n+\t(mark_lang_function): Delete.\n+\t(mark_cp_function_context): Delete.\n+\t(lang_mark_tree): Use generated marker routines.\n+\t* decl2.c (start_objects): Set discriminator when setting\n+\tGLOBAL_INIT_PRIORITY.\n+\t* lex.c (retrofit_lang_decl): Set discriminators.\n+\t(copy_lang_type): Update for changes to lang_type structure.\n+\t(cp_make_lang_type): Set discriminator.\n+\t* parse.y: Use gengtype on YYLVAL.  Don't use dots in identifiers.\n+\t* search.c: Include ggc.h.\n+\t* semantics.c (anon_aggr_type_p): Use the macro, don't hand-code it.\n+\t(finish_inline_definitions): Delete.\n+\t* spew.c (struct token): Use gengtype.\n+\t(struct token_chunk): New.\n+\t(struct unparsed_text): Use gengtype.  Store tokens in chunks.\n+\t(struct feed): Use gengtype.\n+\t(feed_obstack): Delete.\n+\t(feed): Mark as GC root.\n+\t(pending_inlines): Mark as GC root.\n+\t(pending_inlines_tail): Likewise.\n+\t(processing_these_inlines): Likewise.\n+\t(token_obstack): Make static.\n+\t(first_token): Likewise.\n+\t(init_spew): Don't initialise deleted things; use gengtype for roots.\n+\t(clear_inline_text_obstack): Delete.\n+\t(feed_input): Use GC for struct feed.  Update for changes to\n+\tstruct unparsed_text.\n+\t(mark_pending_inlines): Delete.\n+\t(next_token): Rename from add_token.  Change all callers.  Update\n+\tfor changes to struct unparsed_text.\n+\t(space_for_token): New.\n+\t(remove_last_token): New.\n+\t(alloc_unparsed_text): New.\n+\t(snarf_block): Take an unparsed_text.  Update for changes to struct\n+\tunparsed_text.\n+\t(snarf_method): Update for changes to struct unparsed_text.\n+\t(snarf_defarg): Update for changes to struct unparsed_text.\n+\t* tree.c (lang_check_failed): New.\n+\n+\t* Make-lang.in (gt-cp-call.h gt-cp-decl2.h gt-cp-parse.h\n+\tgt-cp-pt.h gt-cp-repo.h gt-cp-spew.h): New rules.\n+\t(cp/spew.o): Add dependency on gt-<filename>.h.\n+\t(cp/decl2.o): Add dependency on gt-<filename>.h.\n+\t(cp/call.o): Add dependency on gt-<filename>.h.\n+\t(cp/pt.o): Add dependency on gt-<filename>.h.\n+\t(cp/repo.o): Add dependency on gt-<filename>.h.\n+\t(cp/parse.o): Add dependency on gt-<filename>.h.\n+\t* call.c: Use gengtype for roots.\n+\t* config-lang.in (gtfiles): Add cp-tree.h decl.h lex.h call.c\n+\tdecl2.c parse.y pt.c repo.c spew.c.\n+\t* cp-tree.h: Use gengtype for roots.\n+\t(struct saved_scope): Use GGC, gengtype.\n+\t(cp_parse_init): Delete prototype.\n+\t(init_pt): Delete prototype.\n+\t* decl.c: Use gengtype for roots.\n+\t(mark_saved_scope): Delete.\n+\t(cxx_init_decl_processing): Don't call deleted initilisation\n+\troutines.\n+\t(signed_size_zero_node): Delete, unused.\n+\t* decl.h: Use gengtype for roots.\n+\t* decl2.c: Use gengtype for roots.\n+\t* lex.h: Use gengtype for roots.\n+\t* parse.y: Use gengtype for roots.\n+\t(cp_parse_init): Delete.\n+\t* pt.c: Use gengtype for roots.\n+\t(init_pt): Delete.\n+\t* repo.c: Use gengtype for roots.\n+\t* spew.c: Use gengtype for roots.\n+\n+\t* Make-lang.in: Allow for filename changes.  Add gtype-cp.h.\n+\t(cp/decl.o): Add dependency on gtype-cp.h.\n+\t* decl.c: Remove use of add_deletable_root, use GTY marker instead.\n+\tInclude gtype-cp.h.  Allow for filename changes.\n+\n+\t* Make-lang.in (cp/gt-decl.h): Generate using gengtype.\n+\t(cp/decl.o): Add cp/gt-decl.h dependency.\n+\t* config-lang.in (gtfiles): New.\n+\t* tree.h: Rename struct binding_level to struct cp_binding_level.\n+\t* decl.c: Rename struct binding_level to struct cp_binding_level.\n+\tInclude cp/gt-decl.h.\n+\t(struct cp_binding_level): Use gengtype.\n+\t(make_binding_level): Use GGC on struct cp_binding_level.\n+\t(mark_binding_level): Use gt_ggc_m_cp_binding_level.\n+\t(cxx_init_decl_processing): Mark free_binding_level as\n+\tdeletable.\n+\n+\t* decl.c (mark_cp_function_context): Update calling sequence.\n+\n+\t* decl.c (start_function): Don't free 'struct\n+\tcp_language_function'.\n+\t(pop_cp_function_context): Likewise.\n+\t(save_function_data): Allocate it using GC.\n+\t* semantics.c (genrtl_start_function): Don't free 'struct\n+\tcp_language_function'.\n+\n 2002-05-31  Matthew Woodcraft  <mattheww@chiark.greenend.org.uk>\n \n \t* lang-specs.h: Use cpp_debug_options."}, {"sha": "104adf8d7393bb105d7729adebfffd5b7b95a061", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -131,6 +131,10 @@ $(srcdir)/cp/parse.c: $(srcdir)/cp/parse.y\n \t  false ; \\\n \tfi\n \n+gtype-cp.h gt-cp-call.h gt-cp-decl.h gt-cp-decl2.h : s-gtype; @true\n+gt-cp-parse.h gt-cp-pt.h gt-cp-repo.h gt-cp-spew.h : s-gtype; @true\n+gt-cp-tree.h : s-gtype; @true\n+\n #\f\n # Build hooks:\n \n@@ -247,24 +251,26 @@ CXX_TREE_H = $(TREE_H) cp/cp-tree.h c-common.h cp/cp-tree.def c-common.def \\\n \tfunction.h varray.h $(SYSTEM_H) $(CONFIG_H) $(TARGET_H) \\\n \t$(srcdir)/../include/hashtab.h $(srcdir)/../include/splay-tree.h\n \n-cp/spew.o: cp/spew.c $(CXX_TREE_H) cp/parse.h flags.h cp/lex.h toplev.h\n+cp/spew.o: cp/spew.c $(CXX_TREE_H) cp/parse.h flags.h cp/lex.h toplev.h \\\n+  gt-cp-spew.h\n cp/lex.o: cp/lex.c $(CXX_TREE_H) cp/parse.h flags.h cp/lex.h c-pragma.h \\\n   toplev.h output.h mbchar.h $(GGC_H) input.h diagnostic.h cp/operators.def \\\n   $(TM_P_H)\n cp/cp-lang.o: cp/cp-lang.c $(CXX_TREE_H) toplev.h langhooks.h $(LANGHOOKS_DEF_H) \\\n   c-common.h\n cp/decl.o: cp/decl.c $(CXX_TREE_H) flags.h cp/lex.h cp/decl.h stack.h \\\n-  output.h $(EXPR_H) except.h toplev.h hash.h $(GGC_H) $(RTL_H) \\\n-  cp/operators.def $(TM_P_H) tree-inline.h diagnostic.h c-pragma.h\n+  output.h $(EXPR_H) except.h toplev.h $(HASHTAB_H) $(GGC_H) $(RTL_H) \\\n+  cp/operators.def $(TM_P_H) tree-inline.h diagnostic.h c-pragma.h \\\n+  debug.h gt-cp-decl.h gtype-cp.h\n cp/decl2.o: cp/decl2.c $(CXX_TREE_H) flags.h cp/lex.h cp/decl.h $(EXPR_H) \\\n-  output.h except.h toplev.h $(GGC_H) $(RTL_H) c-common.h\n+  output.h except.h toplev.h $(GGC_H) $(RTL_H) c-common.h gt-cp-decl2.h\n cp/typeck2.o: cp/typeck2.c $(CXX_TREE_H) flags.h toplev.h output.h $(TM_P_H) \\\n    diagnostic.h\n cp/typeck.o: cp/typeck.c $(CXX_TREE_H) flags.h $(RTL_H) $(EXPR_H) toplev.h \\\n    diagnostic.h\n cp/class.o: cp/class.c $(CXX_TREE_H) flags.h toplev.h $(RTL_H) $(TARGET_H)\n cp/call.o: cp/call.c $(CXX_TREE_H) flags.h toplev.h $(RTL_H) $(EXPR_H) \\\n-     $(GGC_H) diagnostic.h\n+     $(GGC_H) diagnostic.h gt-cp-call.h\n cp/friend.o: cp/friend.c $(CXX_TREE_H) flags.h $(RTL_H) toplev.h $(EXPR_H)\n cp/init.o: cp/init.c $(CXX_TREE_H) flags.h $(RTL_H) $(EXPR_H) toplev.h \\\n   $(GGC_H) except.h\n@@ -273,18 +279,19 @@ cp/method.o: cp/method.c $(CXX_TREE_H) toplev.h $(GGC_H) $(RTL_H) $(EXPR_H) \\\n cp/cvt.o: cp/cvt.c $(CXX_TREE_H) cp/decl.h flags.h toplev.h convert.h\n cp/search.o: cp/search.c $(CXX_TREE_H) stack.h flags.h toplev.h $(RTL_H)\n cp/tree.o: cp/tree.c $(CXX_TREE_H) flags.h toplev.h $(GGC_H) $(RTL_H) \\\n-  insn-config.h integrate.h tree-inline.h real.h\n+  insn-config.h integrate.h tree-inline.h real.h gt-cp-tree.h\n cp/ptree.o: cp/ptree.c $(CXX_TREE_H) $(SYSTEM_H)\n cp/rtti.o: cp/rtti.c $(CXX_TREE_H) flags.h toplev.h\n cp/except.o: cp/except.c $(CXX_TREE_H) flags.h $(RTL_H) except.h toplev.h \\\n   cp/cfns.h $(EXPR_H) libfuncs.h tree-inline.h\n cp/expr.o: cp/expr.c $(CXX_TREE_H) $(RTL_H) flags.h $(EXPR_H) toplev.h \\\n   except.h $(TM_P_H)\n cp/pt.o: cp/pt.c $(CXX_TREE_H) cp/decl.h cp/parse.h cp/lex.h toplev.h \\\n-  $(GGC_H) $(RTL_H) except.h tree-inline.h\n+  $(GGC_H) $(RTL_H) except.h tree-inline.h gt-cp-pt.h\n cp/error.o: cp/error.c $(CXX_TREE_H) toplev.h diagnostic.h flags.h real.h \\\n   $(LANGHOOKS_DEF_H)\n-cp/repo.o: cp/repo.c $(CXX_TREE_H) toplev.h $(GGC_H) diagnostic.h\n+cp/repo.o: cp/repo.c $(CXX_TREE_H) toplev.h $(GGC_H) diagnostic.h \\\n+  gt-cp-repo.h\n cp/semantics.o: cp/semantics.c $(CXX_TREE_H) cp/lex.h except.h toplev.h \\\n   flags.h $(GGC_H) debug.h output.h $(RTL_H) $(TIMEVAR_H) $(EXPR_H) \\\n   tree-inline.h\n@@ -294,7 +301,7 @@ cp/optimize.o: cp/optimize.c $(CXX_TREE_H) rtl.h integrate.h insn-config.h \\\n cp/mangle.o: cp/mangle.c $(CXX_TREE_H) toplev.h real.h\n \n cp/parse.o: cp/parse.c $(CXX_TREE_H) flags.h cp/lex.h except.h output.h \\\n-\t$(SYSTEM_H) toplev.h $(GGC_H)\n+\t$(SYSTEM_H) toplev.h $(GGC_H) gt-cp-parse.h\n \t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $(BIG_SWITCHFLAG) \\\n \t\t$(srcdir)/cp/parse.c $(OUTPUT_OPTION)\n #\f"}, {"sha": "ed6ab2e3f1b66d230cccafac3dc72cabd4ce68a4", "filename": "gcc/cp/call.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -535,7 +535,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \n /* New overloading code.  */\n \n-struct z_candidate {\n+struct z_candidate GTY(()) {\n   tree fn;\n   tree convs;\n   tree second_conv;\n@@ -572,8 +572,7 @@ struct z_candidate {\n    should be created to hold the result of the conversion.  */\n #define NEED_TEMPORARY_P(NODE) TREE_LANG_FLAG_4 (NODE)\n \n-#define USER_CONV_CAND(NODE) \\\n-  ((struct z_candidate *)WRAPPER_PTR (TREE_OPERAND (NODE, 1)))\n+#define USER_CONV_CAND(NODE) WRAPPER_ZC (TREE_OPERAND (NODE, 1))\n #define USER_CONV_FN(NODE) (USER_CONV_CAND (NODE)->fn)\n \n int\n@@ -1022,7 +1021,7 @@ convert_class_to_reference (t, s, expr)\n   conv = build1 (IDENTITY_CONV, s, expr);\n   conv = build_conv (USER_CONV, TREE_TYPE (TREE_TYPE (cand->fn)),\n \t\t     conv);\n-  TREE_OPERAND (conv, 1) = build_ptr_wrapper (cand);\n+  TREE_OPERAND (conv, 1) = build_zc_wrapper (cand);\n   ICS_USER_FLAG (conv) = 1;\n   if (cand->viable == -1)\n     ICS_BAD_FLAG (conv) = 1;\n@@ -2559,7 +2558,7 @@ build_user_type_conversion_1 (totype, expr, flags)\n     (USER_CONV,\n      (DECL_CONSTRUCTOR_P (cand->fn)\n       ? totype : non_reference (TREE_TYPE (TREE_TYPE (cand->fn)))),\n-     expr, build_ptr_wrapper (cand));\n+     expr, build_zc_wrapper (cand));\n   \n   ICS_USER_FLAG (cand->second_conv) = ICS_USER_FLAG (*p) = 1;\n   if (cand->viable == -1)\n@@ -3826,7 +3825,7 @@ convert_like_real (convs, expr, fn, argnum, inner)\n     case USER_CONV:\n       {\n \tstruct z_candidate *cand\n-\t  = WRAPPER_PTR (TREE_OPERAND (convs, 1));\n+\t  = WRAPPER_ZC (TREE_OPERAND (convs, 1));\n \ttree convfn = cand->fn;\n \ttree args;\n \n@@ -4160,7 +4159,7 @@ build_over_call (cand, args, flags)\n   /* Give any warnings we noticed during overload resolution.  */\n   if (cand->warnings)\n     for (val = cand->warnings; val; val = TREE_CHAIN (val))\n-      joust (cand, WRAPPER_PTR (TREE_VALUE (val)), 1);\n+      joust (cand, WRAPPER_ZC (TREE_VALUE (val)), 1);\n \n   if (DECL_FUNCTION_MEMBER_P (fn))\n     enforce_access (cand->basetype_path, fn);\n@@ -4405,7 +4404,7 @@ build_over_call (cand, args, flags)\n   return convert_from_reference (fn);\n }\n \n-static tree java_iface_lookup_fn;\n+static GTY(()) tree java_iface_lookup_fn;\n \n /* Make an expression which yields the address of the Java interface\n    method FN.  This is achieved by generating a call to libjava's\n@@ -4430,7 +4429,6 @@ build_java_interface_fn_ref (fn, instance)\n \t= builtin_function (\"_Jv_LookupInterfaceMethodIdx\",\n \t\t\t    build_function_type (ptr_type_node, t),\n \t\t\t    0, NOT_BUILT_IN, NULL);\n-      ggc_add_tree_root (&java_iface_lookup_fn, 1);\n     }\n \n   /* Look up the pointer to the runtime java.lang.Class object for `instance'. \n@@ -5207,7 +5205,7 @@ add_warning (winner, loser)\n      struct z_candidate *winner, *loser;\n {\n   winner->warnings = tree_cons (NULL_TREE,\n-\t\t\t\tbuild_ptr_wrapper (loser),\n+\t\t\t\tbuild_zc_wrapper (loser),\n \t\t\t\twinner->warnings);\n }\n \n@@ -5635,3 +5633,5 @@ initialize_reference (type, expr)\n \n   return convert_like (conv, expr);\n }\n+\n+#include \"gt-cp-call.h\""}, {"sha": "72f9faa0560eac13cf471da4120eb3fa7fd803b5", "filename": "gcc/cp/class.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -2157,6 +2157,7 @@ duplicate_tag_error (t)\n       memset ((char *) TYPE_LANG_SPECIFIC (t), 0, sizeof (struct lang_type));\n       BINFO_BASETYPES(binfo) = NULL_TREE;\n \n+      TYPE_LANG_SPECIFIC (t)->u.h.is_lang_type_class = 1;\n       TYPE_BINFO (t) = binfo;\n       CLASSTYPE_INTERFACE_ONLY (t) = interface_only;\n       SET_CLASSTYPE_INTERFACE_UNKNOWN_X (t, interface_unknown);\n@@ -4379,7 +4380,7 @@ check_bases_and_members (t, empty_p)\n \n   /* Figure out whether or not we will need a cookie when dynamically\n      allocating an array of this type.  */\n-  TYPE_LANG_SPECIFIC (t)->vec_new_uses_cookie\n+  TYPE_LANG_SPECIFIC (t)->u.c.vec_new_uses_cookie\n     = type_requires_array_cookie (t);\n }\n \n@@ -5470,7 +5471,6 @@ init_class_processing ()\n     = (class_stack_node_t) xmalloc (current_class_stack_size \n \t\t\t\t    * sizeof (struct class_stack_node));\n   VARRAY_TREE_INIT (local_classes, 8, \"local_classes\");\n-  ggc_add_tree_varray_root (&local_classes, 1);\n \n   access_default_node = build_int_2 (0, 0);\n   access_public_node = build_int_2 (ak_public, 0);\n@@ -7511,8 +7511,6 @@ build_vtbl_initializer (binfo, orig_binfo, t, rtti_binfo, non_fn_entries_p)\n   VARRAY_TREE_INIT (vid.fns, 32, \"fns\");\n   /* Add the vcall and vbase offset entries.  */\n   build_vcall_and_vbase_vtbl_entries (binfo, &vid);\n-  /* Clean up.  */\n-  VARRAY_FREE (vid.fns);\n   /* Clear BINFO_VTABLE_PATH_MARKED; it's set by\n      build_vbase_offset_vtbl_entries.  */\n   for (vbase = CLASSTYPE_VBASECLASSES (t); "}, {"sha": "ba3708bebb342019dd088be02c12b4ddb0c0ab48", "filename": "gcc/cp/config-lang.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fcp%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fcp%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconfig-lang.in?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -33,3 +33,5 @@ compilers=\"cc1plus\\$(exeext)\"\n stagestuff=\"g++\\$(exeext) g++-cross\\$(exeext) cc1plus\\$(exeext)\"\n \n target_libs=\"${libstdcxx_version} target-gperf\"\n+\n+gtfiles=\"\\$(srcdir)/cp/cp-tree.h \\$(srcdir)/cp/decl.h \\$(srcdir)/cp/lex.h \\$(srcdir)/cp/call.c \\$(srcdir)/cp/decl.c \\$(srcdir)/cp/decl2.c \\$(srcdir)/cp/parse.y \\$(srcdir)/cp/pt.c \\$(srcdir)/cp/repo.c \\$(srcdir)/cp/spew.c \\$(srcdir)/cp/tree.c\""}, {"sha": "f482582c8c74d4b7365c3d6c6f92d7aa67f21dc7", "filename": "gcc/cp/cp-lang.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fcp%2Fcp-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fcp%2Fcp-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-lang.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -66,8 +66,6 @@ static bool cxx_warn_unused_global_decl PARAMS ((tree));\n #define LANG_HOOKS_TRUTHVALUE_CONVERSION c_common_truthvalue_conversion\n #undef LANG_HOOKS_INSERT_DEFAULT_ATTRIBUTES\n #define LANG_HOOKS_INSERT_DEFAULT_ATTRIBUTES cxx_insert_default_attributes\n-#undef LANG_HOOKS_MARK_TREE\n-#define LANG_HOOKS_MARK_TREE cxx_mark_tree\n #undef LANG_HOOKS_UNSAFE_FOR_REEVAL\n #define LANG_HOOKS_UNSAFE_FOR_REEVAL c_common_unsafe_for_reeval\n #undef LANG_HOOKS_SET_DECL_ASSEMBLER_NAME\n@@ -93,10 +91,8 @@ static bool cxx_warn_unused_global_decl PARAMS ((tree));\n \n #undef LANG_HOOKS_FUNCTION_INIT\n #define LANG_HOOKS_FUNCTION_INIT cxx_push_function_context\n-#undef LANG_HOOKS_FUNCTION_FREE\n-#define LANG_HOOKS_FUNCTION_FREE cxx_pop_function_context\n-#undef LANG_HOOKS_FUNCTION_MARK\n-#define LANG_HOOKS_FUNCTION_MARK cxx_mark_function_context\n+#undef LANG_HOOKS_FUNCTION_FINAL\n+#define LANG_HOOKS_FUNCTION_FINAL cxx_pop_function_context\n \n /* Attribute hooks.  */\n #undef LANG_HOOKS_COMMON_ATTRIBUTE_TABLE"}, {"sha": "448cb88b6d848c1be2b6800ab835953f3719ea9e", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 293, "deletions": 205, "changes": 498, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -233,9 +233,9 @@ extern int flag_huge_objects;\n \f\n /* Language-dependent contents of an identifier.  */\n \n-struct lang_identifier\n+struct lang_identifier GTY(())\n {\n-  struct c_common_identifier ignore;\n+  struct c_common_identifier c_common;\n   tree namespace_bindings;\n   tree bindings;\n   tree class_value;\n@@ -255,20 +255,21 @@ extern const short rid_to_yy[RID_MAX];\n #define LANG_IDENTIFIER_CAST(NODE) \\\n \t((struct lang_identifier*)IDENTIFIER_NODE_CHECK (NODE))\n \n-struct lang_id2\n+struct lang_id2 GTY(())\n {\n-  tree label_value, implicit_decl;\n+  tree label_value;\n+  tree implicit_decl;\n   tree error_locus;\n };\n \n-typedef struct\n+typedef struct flagged_type_tree_s GTY(())\n {\n   tree t;\n   int new_type_flag;\n   tree lookups;\n } flagged_type_tree;\n \n-typedef struct\n+typedef struct template_parm_index_s GTY(())\n {\n   struct tree_common common;\n   HOST_WIDE_INT index;\n@@ -277,14 +278,15 @@ typedef struct\n   tree decl;\n } template_parm_index;\n \n-typedef struct ptrmem_cst\n+struct ptrmem_cst GTY(())\n {\n   struct tree_common common;\n   /* This isn't used, but the middle-end expects all constants to have\n      this field.  */\n   rtx rtl;\n   tree member;\n-}* ptrmem_cst_t;\n+};\n+typedef struct ptrmem_cst * ptrmem_cst_t;\n \n /* Nonzero if this binding is for a local scope, as opposed to a class\n    or namespace scope.  */\n@@ -346,13 +348,13 @@ typedef struct ptrmem_cst\n     && MAIN_NAME_P (DECL_NAME (NODE)))\n \n \n-struct tree_binding\n+struct tree_binding GTY(())\n {\n   struct tree_common common;\n-  union {\n-    tree scope;\n-    struct binding_level *level;\n-  } scope;\n+  union tree_binding_u {\n+    tree GTY ((tag (\"0\"))) scope;\n+    struct cp_binding_level * GTY ((tag (\"1\"))) level;\n+  } GTY ((desc (\"BINDING_HAS_LEVEL_P ((tree)&%0)\"))) scope;\n   tree value;\n };\n \n@@ -370,7 +372,7 @@ struct tree_binding\n    is not important for this node. */\n #define OVL_USED(NODE)        TREE_USED (NODE)\n \n-struct tree_overload\n+struct tree_overload GTY(())\n {\n   struct tree_common common;\n   tree function;\n@@ -384,21 +386,17 @@ struct tree_overload\n #define SET_BASELINK_P(NODE) \\\n   (TREE_LANG_FLAG_1 (NODE) = 1)\n \n-#define WRAPPER_PTR(NODE) (((struct tree_wrapper*)WRAPPER_CHECK (NODE))->u.ptr)\n-#define WRAPPER_INT(NODE) (((struct tree_wrapper*)WRAPPER_CHECK (NODE))->u.i)\n+#define WRAPPER_ZC(NODE) (((struct tree_wrapper*)WRAPPER_CHECK (NODE))->z_c)\n \n-struct tree_wrapper\n+struct tree_wrapper GTY(())\n {\n   struct tree_common common;\n-  union {\n-    void *ptr;\n-    int i;\n-  } u;\n+  struct z_candidate *z_c;\n };\n \n #define SRCLOC_FILE(NODE) (((struct tree_srcloc*)SRCLOC_CHECK (NODE))->filename)\n #define SRCLOC_LINE(NODE) (((struct tree_srcloc*)SRCLOC_CHECK (NODE))->linenum)\n-struct tree_srcloc\n+struct tree_srcloc GTY(())\n {\n   struct tree_common common;\n   const char *filename;\n@@ -450,10 +448,10 @@ struct tree_srcloc\n   (LANG_IDENTIFIER_CAST (NODE)->x\t\t\t\\\n    ? LANG_IDENTIFIER_CAST (NODE)->x->NAME : 0)\n \n-#define SET_LANG_ID(NODE, VALUE, NAME)\t\t\t\t\t  \\\n-  (LANG_IDENTIFIER_CAST (NODE)->x == 0\t\t\t\t  \t  \\\n-   ? LANG_IDENTIFIER_CAST (NODE)->x\t\t\t\t\t  \\\n-      = (struct lang_id2 *)perm_calloc (1, sizeof (struct lang_id2)) : 0, \\\n+#define SET_LANG_ID(NODE, VALUE, NAME)\t\t\t\t\t     \\\n+  (LANG_IDENTIFIER_CAST (NODE)->x == 0\t\t\t\t\t     \\\n+   ? LANG_IDENTIFIER_CAST (NODE)->x\t\t\t\t\t     \\\n+      = (struct lang_id2 *)ggc_alloc_cleared (sizeof (struct lang_id2)) : 0, \\\n    LANG_IDENTIFIER_CAST (NODE)->x->NAME = (VALUE))\n \n #define IDENTIFIER_LABEL_VALUE(NODE) \\\n@@ -495,11 +493,36 @@ struct tree_srcloc\n /* Store a value in that field.  */\n #define C_SET_EXP_ORIGINAL_CODE(EXP, CODE) \\\n   (TREE_COMPLEXITY (EXP) = (int)(CODE))\n-\f\n-/* If non-zero, a VAR_DECL whose cleanup will cause a throw to the\n-   next exception handler.  */\n-extern tree exception_throw_decl;\n \n+enum cp_tree_node_structure_enum {\n+  TS_CP_COMMON,\n+  TS_CP_GENERIC,\n+  TS_CP_IDENTIFIER,\n+  TS_CP_TPI,\n+  TS_CP_PTRMEM,\n+  TS_CP_BINDING,\n+  TS_CP_OVERLOAD,\n+  TS_CP_WRAPPER,\n+  TS_CP_SRCLOC,\n+  LAST_TS_CP_ENUM\n+};\n+\n+/* The resulting tree type.  */\n+union lang_tree_node GTY((desc (\"cp_tree_node_structure (&%h)\")))\n+{\n+  struct tree_common GTY ((tag (\"TS_CP_COMMON\"))) common;\n+  union tree_node GTY ((tag (\"TS_CP_GENERIC\"),\n+\t\t\tdesc (\"tree_node_structure (&%h)\"))) generic;\n+  struct template_parm_index_s GTY ((tag (\"TS_CP_TPI\"))) tpi;\n+  struct ptrmem_cst GTY ((tag (\"TS_CP_PTRMEM\"))) ptrmem;\n+  struct tree_binding GTY ((tag (\"TS_CP_BINDING\"))) binding;\n+  struct tree_overload GTY ((tag (\"TS_CP_OVERLOAD\"))) overload;\n+  struct tree_wrapper GTY ((tag (\"TS_CP_WRAPPER\"))) wrapper;\n+  struct tree_srcloc GTY ((tag (\"TS_CP_SRCLOC\"))) srcloc;\n+  struct lang_identifier GTY ((tag (\"TS_CP_IDENTIFIER\"))) identifier;\n+};\n+\n+\f\n enum cp_tree_index\n {\n     CPTI_JAVA_BYTE_TYPE,\n@@ -586,7 +609,7 @@ enum cp_tree_index\n     CPTI_MAX\n };\n \n-extern tree cp_global_trees[CPTI_MAX];\n+extern GTY(()) tree cp_global_trees[CPTI_MAX];\n \n #define java_byte_type_node\t\tcp_global_trees[CPTI_JAVA_BYTE_TYPE]\n #define java_short_type_node\t\tcp_global_trees[CPTI_JAVA_SHORT_TYPE]\n@@ -715,7 +738,7 @@ extern tree cp_global_trees[CPTI_MAX];\n \n /* Global state.  */\n \n-struct saved_scope\n+struct saved_scope GTY(())\n {\n   tree old_bindings;\n   tree old_namespace;\n@@ -740,8 +763,8 @@ struct saved_scope\n \n   struct stmt_tree_s x_stmt_tree;\n \n-  struct binding_level *class_bindings;\n-  struct binding_level *bindings;\n+  struct cp_binding_level *class_bindings;\n+  struct cp_binding_level *bindings;\n \n   struct saved_scope *prev;\n };\n@@ -798,15 +821,15 @@ struct saved_scope\n \n #define type_lookups scope_chain->lookups\n \n-extern struct saved_scope *scope_chain;\n+extern GTY(()) struct saved_scope *scope_chain;\n \n struct unparsed_text;\n \n /* Global state pertinent to the current function.  */\n \n-struct cp_language_function\n+struct language_function GTY(())\n {\n-  struct language_function base;\n+  struct c_language_function base;\n \n   tree x_dtor_label;\n   tree x_current_class_ptr;\n@@ -816,8 +839,6 @@ struct cp_language_function\n   tree x_vtt_parm;\n   tree x_return_value;\n \n-  tree *x_vcalls_possible_p;\n-\n   int returns_value;\n   int returns_null;\n   int returns_abnormally;\n@@ -826,7 +847,7 @@ struct cp_language_function\n \n   struct named_label_use_list *x_named_label_uses;\n   struct named_label_list *x_named_labels;\n-  struct binding_level *bindings;\n+  struct cp_binding_level *bindings;\n   varray_type x_local_names;\n \n   const char *cannot_inline;\n@@ -835,8 +856,7 @@ struct cp_language_function\n \n /* The current C++-specific per-function global variables.  */\n \n-#define cp_function_chain \\\n-  ((struct cp_language_function *) (cfun->language))\n+#define cp_function_chain (cfun->language)\n \n /* In a destructor, the point at which all derived class destroying\n    has been done, just before any base class destroying will be done.  */\n@@ -867,12 +887,6 @@ struct cp_language_function\n \n #define current_vtt_parm cp_function_chain->x_vtt_parm\n \n-/* In destructors, this is a pointer to a condition in an\n-   if-statement.  If the pointed-to value is boolean_true_node, then\n-   there may be virtual function calls in this destructor.  */\n-\n-#define current_vcalls_possible_p cp_function_chain->x_vcalls_possible_p\n-\n /* Set to 0 at beginning of a function definition, set to 1 if\n    a return statement that specifies a return value is seen.  */\n \n@@ -908,7 +922,7 @@ struct cp_language_function\n #define current_function_return_value \\\n   (cp_function_chain->x_return_value)\n \n-extern tree global_namespace;\n+extern GTY(()) tree global_namespace;\n \n #define ansi_opname(CODE) \\\n   (operator_name_info[(int) (CODE)].identifier)\n@@ -1176,6 +1190,22 @@ enum languages { lang_c, lang_cplusplus, lang_java };\n #define PUBLICLY_UNIQUELY_DERIVED_P(PARENT, TYPE) \\\n   lookup_base ((TYPE), (PARENT),  ba_not_special | ba_quiet, NULL)\n \f\n+/* This is a few header flags for 'struct lang_type'.  Actually,\n+   all but the first are used only for lang_type_class; they\n+   are put in this structure to save space.  */\n+struct lang_type_header GTY(())\n+{\n+  unsigned is_lang_type_class : 1;\n+\n+  unsigned has_type_conversion : 1;\n+  unsigned has_init_ref : 1;\n+  unsigned has_default_ctor : 1;\n+  unsigned uses_multiple_inheritance : 1;\n+  unsigned const_needs_init : 1;\n+  unsigned ref_needs_init : 1;\n+  unsigned has_const_assign_ref : 1;\n+};\n+\n /* This structure provides additional information above and beyond\n    what is provide in the ordinary tree_type.  In the past, we used it\n    for the types of class types, template parameters types, typename\n@@ -1189,19 +1219,12 @@ enum languages { lang_c, lang_cplusplus, lang_java };\n    many (i.e., thousands) of classes can easily be generated.\n    Therefore, we should endeavor to keep the size of this structure to\n    a minimum.  */\n-struct lang_type\n+struct lang_type_class GTY(())\n {\n+  struct lang_type_header h;\n+  \n   unsigned char align;\n \n-  unsigned has_type_conversion : 1;\n-  unsigned has_init_ref : 1;\n-  unsigned has_default_ctor : 1;\n-  unsigned uses_multiple_inheritance : 1;\n-  unsigned const_needs_init : 1;\n-  unsigned ref_needs_init : 1;\n-  unsigned has_const_assign_ref : 1;\n-  unsigned anon_aggr : 1;\n-\n   unsigned has_mutable : 1;\n   unsigned com_interface : 1;\n   unsigned non_pod_class : 1;\n@@ -1240,6 +1263,7 @@ struct lang_type\n   unsigned is_partial_instantiation : 1;\n   unsigned java_interface : 1;\n \n+  unsigned anon_aggr : 1;\n   unsigned non_zero_init : 1;\n \n   /* When adding a flag here, consider whether or not it ought to\n@@ -1249,7 +1273,7 @@ struct lang_type\n   /* There are some bits left to fill out a 32-bit word.  Keep track\n      of this by updating the size of this bitfield whenever you add or\n      remove a flag.  */\n-  unsigned dummy : 7;\n+  unsigned dummy : 6;\n \n   int vsize;\n \n@@ -1267,12 +1291,50 @@ struct lang_type\n   tree befriending_classes;\n };\n \n+struct lang_type_ptrmem GTY(())\n+{\n+  struct lang_type_header h;\n+  tree record;\n+};\n+\n+struct lang_type GTY(())\n+{\n+  union lang_type_u \n+  {\n+    struct lang_type_header GTY((tag (\"2\"))) h;\n+    struct lang_type_class  GTY((tag (\"1\"))) c;\n+    struct lang_type_ptrmem GTY((tag (\"0\"))) ptrmem;\n+  } GTY((desc (\"%h.h.is_lang_type_class\"))) u;\n+};\n+\n+#if defined ENABLE_TREE_CHECKING && (GCC_VERSION >= 2007)\n+\n+#define LANG_TYPE_CLASS_CHECK(NODE)\t\t\t\t\\\n+({  struct lang_type *lt = TYPE_LANG_SPECIFIC (NODE);\t\t\\\n+    if (! lt->u.h.is_lang_type_class)\t\t\t\t\\\n+      lang_check_failed (__FILE__, __LINE__, __FUNCTION__);\t\\\n+    &lt->u.c; })\n+\n+#define LANG_TYPE_PTRMEM_CHECK(NODE)\t\t\t\t\\\n+({  struct lang_type *lt = TYPE_LANG_SPECIFIC (NODE);\t\t\\\n+    if (lt->u.h.is_lang_type_class)\t\t\t\t\\\n+      lang_check_failed (__FILE__, __LINE__, __FUNCTION__);\t\\\n+    &lt->u.ptrmem; })\n+\n+#else\n+\n+#define LANG_TYPE_CLASS_CHECK(NODE) (&TYPE_LANG_SPECIFIC (NODE)->u.c)\n+#define LANG_TYPE_PTRMEM_CHECK(NODE) (&TYPE_LANG_SPECIFIC (NODE)->u.ptrmem)\n+\n+#endif /* ENABLE_TREE_CHECKING */\n+\n /* Indicates whether or not (and how) a template was expanded for this class.\n      0=no information yet/non-template class\n      1=implicit template instantiation\n      2=explicit template specialization\n      3=explicit template instantiation  */\n-#define CLASSTYPE_USE_TEMPLATE(NODE) (TYPE_LANG_SPECIFIC (NODE)->use_template)\n+#define CLASSTYPE_USE_TEMPLATE(NODE) \\\n+  (LANG_TYPE_CLASS_CHECK (NODE)->use_template)\n \n /* Fields used for storing information before the class is defined.\n    After the class is defined, these fields hold other information.  */\n@@ -1281,66 +1343,66 @@ struct lang_type\n #define CLASSTYPE_INLINE_FRIENDS(NODE) CLASSTYPE_PURE_VIRTUALS (NODE)\n \n /* Nonzero for _CLASSTYPE means that operator delete is defined.  */\n-#define TYPE_GETS_DELETE(NODE) (TYPE_LANG_SPECIFIC (NODE)->gets_delete)\n+#define TYPE_GETS_DELETE(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->gets_delete)\n #define TYPE_GETS_REG_DELETE(NODE) (TYPE_GETS_DELETE (NODE) & 1)\n \n /* Nonzero if `new NODE[x]' should cause the allocation of extra\n    storage to indicate how many array elements are in use.  */\n #define TYPE_VEC_NEW_USES_COOKIE(NODE)\t\t\t\\\n   (CLASS_TYPE_P (NODE)\t\t\t\t\t\\\n-   && TYPE_LANG_SPECIFIC (NODE)->vec_new_uses_cookie)\n+   && LANG_TYPE_CLASS_CHECK (NODE)->vec_new_uses_cookie)\n \n /* Nonzero means that this _CLASSTYPE node defines ways of converting\n    itself to other types.  */\n #define TYPE_HAS_CONVERSION(NODE) \\\n-  (TYPE_LANG_SPECIFIC (NODE)->has_type_conversion)\n+  (LANG_TYPE_CLASS_CHECK (NODE)->h.has_type_conversion)\n \n /* Nonzero means that this _CLASSTYPE node overloads operator=(X&).  */\n-#define TYPE_HAS_ASSIGN_REF(NODE) (TYPE_LANG_SPECIFIC (NODE)->has_assign_ref)\n+#define TYPE_HAS_ASSIGN_REF(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->has_assign_ref)\n #define TYPE_HAS_CONST_ASSIGN_REF(NODE) \\\n-  (TYPE_LANG_SPECIFIC (NODE)->has_const_assign_ref)\n+  (LANG_TYPE_CLASS_CHECK (NODE)->h.has_const_assign_ref)\n \n /* Nonzero means that this _CLASSTYPE node has an X(X&) constructor.  */\n-#define TYPE_HAS_INIT_REF(NODE) (TYPE_LANG_SPECIFIC (NODE)->has_init_ref)\n+#define TYPE_HAS_INIT_REF(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->h.has_init_ref)\n #define TYPE_HAS_CONST_INIT_REF(NODE) \\\n-  (TYPE_LANG_SPECIFIC (NODE)->has_const_init_ref)\n+  (LANG_TYPE_CLASS_CHECK (NODE)->has_const_init_ref)\n \n /* Nonzero if this class defines an overloaded operator new.  (An\n    operator new [] doesn't count.)  */\n #define TYPE_HAS_NEW_OPERATOR(NODE) \\\n-  (TYPE_LANG_SPECIFIC (NODE)->has_new)\n+  (LANG_TYPE_CLASS_CHECK (NODE)->has_new)\n \n /* Nonzero if this class defines an overloaded operator new[].  */\n #define TYPE_HAS_ARRAY_NEW_OPERATOR(NODE) \\\n-  (TYPE_LANG_SPECIFIC (NODE)->has_array_new)\n+  (LANG_TYPE_CLASS_CHECK (NODE)->has_array_new)\n \n /* Nonzero means that this type is being defined.  I.e., the left brace\n    starting the definition of this type has been seen.  */\n-#define TYPE_BEING_DEFINED(NODE) (TYPE_LANG_SPECIFIC (NODE)->being_defined)\n+#define TYPE_BEING_DEFINED(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->being_defined)\n /* Nonzero means that this type has been redefined.  In this case, if\n    convenient, don't reprocess any methods that appear in its redefinition.  */\n-#define TYPE_REDEFINED(NODE) (TYPE_LANG_SPECIFIC (NODE)->redefined)\n+#define TYPE_REDEFINED(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->redefined)\n \n /* The is the basetype that contains NODE's rtti.  */\n-#define CLASSTYPE_RTTI(NODE) (TYPE_LANG_SPECIFIC (NODE)->rtti)\n+#define CLASSTYPE_RTTI(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->rtti)\n \n /* Nonzero means that this _CLASSTYPE node overloads operator().  */\n #define TYPE_OVERLOADS_CALL_EXPR(NODE) \\\n-  (TYPE_LANG_SPECIFIC (NODE)->has_call_overloaded)\n+  (LANG_TYPE_CLASS_CHECK (NODE)->has_call_overloaded)\n \n /* Nonzero means that this _CLASSTYPE node overloads operator[].  */\n #define TYPE_OVERLOADS_ARRAY_REF(NODE) \\\n-  (TYPE_LANG_SPECIFIC (NODE)->has_array_ref_overloaded)\n+  (LANG_TYPE_CLASS_CHECK (NODE)->has_array_ref_overloaded)\n \n /* Nonzero means that this _CLASSTYPE node overloads operator->.  */\n #define TYPE_OVERLOADS_ARROW(NODE) \\\n-  (TYPE_LANG_SPECIFIC (NODE)->has_arrow_overloaded)\n+  (LANG_TYPE_CLASS_CHECK (NODE)->has_arrow_overloaded)\n \n /* Nonzero means that this _CLASSTYPE (or one of its ancestors) uses\n    multiple inheritance.  If this is 0 for the root of a type\n    hierarchy, then we can use more efficient search techniques.  */\n #define TYPE_USES_MULTIPLE_INHERITANCE(NODE) \\\n-  (TYPE_LANG_SPECIFIC (NODE)->uses_multiple_inheritance)\n+  (LANG_TYPE_CLASS_CHECK (NODE)->h.uses_multiple_inheritance)\n \n /* Nonzero means that this _CLASSTYPE (or one of its ancestors) uses\n    virtual base classes.  If this is 0 for the root of a type\n@@ -1359,7 +1421,7 @@ struct lang_type\n    functions.  There may be empty entries at the end of the vector.\n    The conversion operators are unsorted. The ordinary member\n    functions are sorted, once the class is complete.  */\n-#define CLASSTYPE_METHOD_VEC(NODE) (TYPE_LANG_SPECIFIC (NODE)->methods)\n+#define CLASSTYPE_METHOD_VEC(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->methods)\n \n /* The slot in the CLASSTYPE_METHOD_VEC where constructors go.  */\n #define CLASSTYPE_CONSTRUCTOR_SLOT 0\n@@ -1385,19 +1447,19 @@ struct lang_type\n \n /* Get the value of the Nth mark bit.  */\n #define CLASSTYPE_MARKED_N(NODE, N)\t\t\t\t\\\n-  (((CLASS_TYPE_P (NODE) ? TYPE_LANG_SPECIFIC (NODE)->marks\t\\\n+  (((CLASS_TYPE_P (NODE) ? LANG_TYPE_CLASS_CHECK (NODE)->marks\t\\\n      : ((unsigned) TYPE_ALIAS_SET (NODE))) & (1 << (N))) != 0)\n \n /* Set the Nth mark bit.  */\n #define SET_CLASSTYPE_MARKED_N(NODE, N)\t\t\t\t\\\n   (CLASS_TYPE_P (NODE)\t\t\t\t\t\t\\\n-   ? (void) (TYPE_LANG_SPECIFIC (NODE)->marks |= (1 << (N)))\t\\\n+   ? (void) (LANG_TYPE_CLASS_CHECK (NODE)->marks |= (1 << (N)))\t\\\n    : (void) (TYPE_ALIAS_SET (NODE) |= (1 << (N))))\n \n /* Clear the Nth mark bit.  */\n #define CLEAR_CLASSTYPE_MARKED_N(NODE, N)\t\t\t\\\n   (CLASS_TYPE_P (NODE)\t\t\t\t\t\t\\\n-   ? (void) (TYPE_LANG_SPECIFIC (NODE)->marks &= ~(1 << (N)))\t\\\n+   ? (void) (LANG_TYPE_CLASS_CHECK (NODE)->marks &= ~(1 << (N)))\t\\\n    : (void) (TYPE_ALIAS_SET (NODE) &= ~(1 << (N))))\n \n /* Get the value of the mark bits.  */\n@@ -1426,7 +1488,7 @@ struct lang_type\n    found within this class.  The TREE_PURPOSE of each node is the name\n    of the type; the TREE_VALUE is the type itself.  This list includes\n    nested member class templates.  */\n-#define CLASSTYPE_TAGS(NODE)\t\t(TYPE_LANG_SPECIFIC (NODE)->tags)\n+#define CLASSTYPE_TAGS(NODE)\t\t(LANG_TYPE_CLASS_CHECK (NODE)->tags)\n \n /* Nonzero if NODE has a primary base class, i.e., a base class with\n    which it shares the virtual function table pointer.  */\n@@ -1437,11 +1499,11 @@ struct lang_type\n    the base class which contains the virtual function table pointer\n    for this class.  */\n #define CLASSTYPE_PRIMARY_BINFO(NODE) \\\n-  (TYPE_LANG_SPECIFIC (NODE)->primary_base)\n+  (LANG_TYPE_CLASS_CHECK (NODE)->primary_base)\n \n /* The number of virtual functions present in this class' virtual\n    function table.  */\n-#define CLASSTYPE_VSIZE(NODE) (TYPE_LANG_SPECIFIC (NODE)->vsize)\n+#define CLASSTYPE_VSIZE(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->vsize)\n \n /* A chain of BINFOs for the direct and indirect virtual base classes\n    that this type uses in a post-order depth-first left-to-right\n@@ -1451,7 +1513,7 @@ struct lang_type\n    list are all \"real\"; they are the same BINFOs that will be\n    encountered when using dfs_unmarked_real_bases_queue_p and related\n    functions.  */\n-#define CLASSTYPE_VBASECLASSES(NODE) (TYPE_LANG_SPECIFIC (NODE)->vbases)\n+#define CLASSTYPE_VBASECLASSES(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->vbases)\n \n /* For a non-virtual BINFO, the BINFO itself; for a virtual BINFO, the\n    binfo_for_vbase.  C is the most derived class for the hierarchy\n@@ -1467,103 +1529,104 @@ struct lang_type\n \n /* These are the size and alignment of the type without its virtual\n    base classes, for when we use this type as a base itself.  */\n-#define CLASSTYPE_SIZE(NODE) (TYPE_LANG_SPECIFIC (NODE)->size)\n-#define CLASSTYPE_SIZE_UNIT(NODE) (TYPE_LANG_SPECIFIC (NODE)->size_unit)\n-#define CLASSTYPE_ALIGN(NODE) (TYPE_LANG_SPECIFIC (NODE)->align)\n-#define CLASSTYPE_USER_ALIGN(NODE) (TYPE_LANG_SPECIFIC (NODE)->user_align)\n+#define CLASSTYPE_SIZE(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->size)\n+#define CLASSTYPE_SIZE_UNIT(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->size_unit)\n+#define CLASSTYPE_ALIGN(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->align)\n+#define CLASSTYPE_USER_ALIGN(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->user_align)\n \n /* The alignment of NODE, without its virtual bases, in bytes.  */\n #define CLASSTYPE_ALIGN_UNIT(NODE) \\\n   (CLASSTYPE_ALIGN (NODE) / BITS_PER_UNIT)\n \n /* True if this a Java interface type, declared with \n    '__attribute__ ((java_interface))'. */\n-#define TYPE_JAVA_INTERFACE(NODE) (TYPE_LANG_SPECIFIC (NODE)->java_interface)\n+#define TYPE_JAVA_INTERFACE(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->java_interface)\n \n /* A cons list of virtual functions which cannot be inherited by\n    derived classes.  When deriving from this type, the derived\n    class must provide its own definition for each of these functions.  */\n-#define CLASSTYPE_PURE_VIRTUALS(NODE) (TYPE_LANG_SPECIFIC (NODE)->pure_virtuals)\n+#define CLASSTYPE_PURE_VIRTUALS(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->pure_virtuals)\n \n /* Nonzero means that this aggr type has been `closed' by a semicolon.  */\n-#define CLASSTYPE_GOT_SEMICOLON(NODE) (TYPE_LANG_SPECIFIC (NODE)->got_semicolon)\n+#define CLASSTYPE_GOT_SEMICOLON(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->got_semicolon)\n \n /* Nonzero means that the main virtual function table pointer needs to be\n    set because base constructors have placed the wrong value there.\n    If this is zero, it means that they placed the right value there,\n    and there is no need to change it.  */\n #define CLASSTYPE_NEEDS_VIRTUAL_REINIT(NODE) \\\n-  (TYPE_LANG_SPECIFIC (NODE)->needs_virtual_reinit)\n+  (LANG_TYPE_CLASS_CHECK (NODE)->needs_virtual_reinit)\n \n /* Nonzero means that this type has an X() constructor.  */\n #define TYPE_HAS_DEFAULT_CONSTRUCTOR(NODE) \\\n-  (TYPE_LANG_SPECIFIC (NODE)->has_default_ctor)\n+  (LANG_TYPE_CLASS_CHECK (NODE)->h.has_default_ctor)\n \n /* Nonzero means that this type contains a mutable member */\n-#define CLASSTYPE_HAS_MUTABLE(NODE) (TYPE_LANG_SPECIFIC (NODE)->has_mutable)\n+#define CLASSTYPE_HAS_MUTABLE(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->has_mutable)\n #define TYPE_HAS_MUTABLE_P(NODE) (cp_has_mutable_p (NODE))\n \n /* Nonzero means that this class type is a non-POD class.  */\n-#define CLASSTYPE_NON_POD_P(NODE) (TYPE_LANG_SPECIFIC (NODE)->non_pod_class)\n+#define CLASSTYPE_NON_POD_P(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->non_pod_class)\n \n /* Nonzero means that this class contains pod types whose default\n    initialization is not a zero initialization (namely, pointers to\n    data members).  */\n-#define CLASSTYPE_NON_ZERO_INIT_P(NODE) (TYPE_LANG_SPECIFIC (NODE)->non_zero_init)\n+#define CLASSTYPE_NON_ZERO_INIT_P(NODE) \\\n+  (LANG_TYPE_CLASS_CHECK (NODE)->non_zero_init)\n \n /* Nonzero if this class is \"nearly empty\", i.e., contains only a\n    virtual function table pointer.  */\n #define CLASSTYPE_NEARLY_EMPTY_P(NODE) \\\n-  (TYPE_LANG_SPECIFIC (NODE)->nearly_empty_p)\n+  (LANG_TYPE_CLASS_CHECK (NODE)->nearly_empty_p)\n \n /* A list of class types of which this type is a friend.  The\n    TREE_VALUE is normally a TYPE, but will be a TEMPLATE_DECL in the\n    case of a template friend.  */\n #define CLASSTYPE_FRIEND_CLASSES(NODE) \\\n-  (TYPE_LANG_SPECIFIC (NODE)->friend_classes)\n+  (LANG_TYPE_CLASS_CHECK (NODE)->friend_classes)\n \n /* A list of the classes which grant friendship to this class.  */\n #define CLASSTYPE_BEFRIENDING_CLASSES(NODE) \\\n-  (TYPE_LANG_SPECIFIC (NODE)->befriending_classes)\n+  (LANG_TYPE_CLASS_CHECK (NODE)->befriending_classes)\n \n /* Say whether this node was declared as a \"class\" or a \"struct\".  */\n #define CLASSTYPE_DECLARED_CLASS(NODE) \\\n-  (TYPE_LANG_SPECIFIC (NODE)->declared_class)\n+  (LANG_TYPE_CLASS_CHECK (NODE)->declared_class)\n \n /* Nonzero if this class has const members which have no specified initialization.  */\n #define CLASSTYPE_READONLY_FIELDS_NEED_INIT(NODE) \\\n-  (TYPE_LANG_SPECIFIC (NODE)->const_needs_init)\n+  (LANG_TYPE_CLASS_CHECK (NODE)->h.const_needs_init)\n \n /* Nonzero if this class has ref members which have no specified initialization.  */\n #define CLASSTYPE_REF_FIELDS_NEED_INIT(NODE) \\\n-  (TYPE_LANG_SPECIFIC (NODE)->ref_needs_init)\n+  (LANG_TYPE_CLASS_CHECK (NODE)->h.ref_needs_init)\n \n /* Nonzero if this class is included from a header file which employs\n    `#pragma interface', and it is not included in its implementation file.  */\n #define CLASSTYPE_INTERFACE_ONLY(NODE) \\\n-  (TYPE_LANG_SPECIFIC (NODE)->interface_only)\n+  (LANG_TYPE_CLASS_CHECK (NODE)->interface_only)\n \n /* True if we have already determined whether or not vtables, VTTs,\n    typeinfo, and other similar per-class data should be emitted in\n    this translation unit.  This flag does not indicate whether or not\n    these items should be emitted; it only indicates that we know one\n    way or the other.  */\n #define CLASSTYPE_INTERFACE_KNOWN(NODE) \\\n-  (TYPE_LANG_SPECIFIC (NODE)->interface_unknown == 0)\n+  (LANG_TYPE_CLASS_CHECK (NODE)->interface_unknown == 0)\n /* The opposite of CLASSTYPE_INTERFANCE_KNOWN.  */\n #define CLASSTYPE_INTERFACE_UNKNOWN(NODE) \\\n-  (TYPE_LANG_SPECIFIC (NODE)->interface_unknown)\n+  (LANG_TYPE_CLASS_CHECK (NODE)->interface_unknown)\n \n #define SET_CLASSTYPE_INTERFACE_UNKNOWN_X(NODE,X) \\\n-  (TYPE_LANG_SPECIFIC (NODE)->interface_unknown = !!(X))\n+  (LANG_TYPE_CLASS_CHECK (NODE)->interface_unknown = !!(X))\n #define SET_CLASSTYPE_INTERFACE_UNKNOWN(NODE) \\\n-  (TYPE_LANG_SPECIFIC (NODE)->interface_unknown = 1)\n+  (LANG_TYPE_CLASS_CHECK (NODE)->interface_unknown = 1)\n #define SET_CLASSTYPE_INTERFACE_KNOWN(NODE) \\\n-  (TYPE_LANG_SPECIFIC (NODE)->interface_unknown = 0)\n+  (LANG_TYPE_CLASS_CHECK (NODE)->interface_unknown = 0)\n \n /* Nonzero if a _DECL node requires us to output debug info for this class.  */\n #define CLASSTYPE_DEBUG_REQUESTED(NODE) \\\n-  (TYPE_LANG_SPECIFIC (NODE)->debug_requested)\n+  (LANG_TYPE_CLASS_CHECK (NODE)->debug_requested)\n \f\n /* Additional macros for inheritance information.  */\n \n@@ -1676,7 +1739,7 @@ struct lang_type\n    TREE_PURPOSE is NULL.  Otherwise, the TREE_PURPOSE is the BINFO for\n    the class containing the vfield.  The TREE_VALUE is the class where\n    the vfield was first defined.  */\n-#define CLASSTYPE_VFIELDS(NODE) (TYPE_LANG_SPECIFIC (NODE)->vfields)\n+#define CLASSTYPE_VFIELDS(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->vfields)\n \n /* Get the assoc info that caused this vfield to exist.  */\n #define VF_BINFO_VALUE(NODE) TREE_PURPOSE (NODE)\n@@ -1736,7 +1799,7 @@ struct lang_type\n      || TREE_CODE (NODE) == FIELD_DECL\t\t\\\n      || TREE_CODE (NODE) == USING_DECL))\n \n-struct lang_decl_flags\n+struct lang_decl_flags GTY(())\n {\n   struct c_lang_decl base;\n \n@@ -1757,28 +1820,29 @@ struct lang_decl_flags\n   unsigned not_really_extern : 1;\n   unsigned needs_final_overrider : 1;\n   unsigned initialized_in_class : 1;\n-  unsigned pending_inline_p : 1;\n+  unsigned assignment_operator_p : 1;\n \n   unsigned global_ctor_p : 1;\n   unsigned global_dtor_p : 1;\n-  unsigned assignment_operator_p : 1;\n   unsigned anticipated_p : 1;\n   unsigned template_conv_p : 1;\n-  \n-  unsigned unused : 3; /* Three unused bits.  */\n+  unsigned u1sel : 1;\n+  unsigned u2sel : 1;\n+  unsigned can_be_full : 1;\n+  unsigned unused : 1; /* One unused bit.  */\n \n-  union {\n+  union lang_decl_u {\n     /* In a FUNCTION_DECL, VAR_DECL, TYPE_DECL, or TEMPLATE_DECL, this\n        is DECL_TEMPLATE_INFO.  */\n-    tree template_info;\n+    tree GTY ((tag (\"0\"))) template_info;\n \n     /* In a NAMESPACE_DECL, this is NAMESPACE_LEVEL.  */\n-    struct binding_level *level;\n-  } u;\n+    struct cp_binding_level * GTY ((tag (\"1\"))) level;\n+  } GTY ((desc (\"%1.u1sel\"))) u;\n \n-  union {\n+  union lang_decl_u2 {\n     /* This is DECL_ACCESS.  */\n-    tree access;\n+    tree GTY ((tag (\"0\"))) access;\n \n     /* For VAR_DECL in function, this is DECL_DISCRIMINATOR.  */\n     int discriminator;\n@@ -1789,36 +1853,59 @@ struct lang_decl_flags\n \n     /* In a FUNCTION_DECL for which DECL_THUNK_P holds, this is\n        THUNK_VCALL_OFFSET.  */\n-    tree vcall_offset;\n-  } u2;\n+    tree GTY((tag (\"2\"))) vcall_offset;\n+  } GTY ((desc (\"%1.u2sel\"))) u2;\n };\n \n-struct lang_decl\n+struct lang_decl GTY(())\n {\n   struct lang_decl_flags decl_flags;\n \n-  tree befriending_classes;\n+  union lang_decl_u4\n+    {\n+      struct full_lang_decl \n+      {\n+\ttree befriending_classes;\n+\t\n+\t/* For a virtual FUNCTION_DECL, this is DECL_VIRTUAL_CONTEXT.  For a\n+\t   non-virtual FUNCTION_DECL, this is DECL_FRIEND_CONTEXT.  */\n+\ttree context;\n+\t\n+\t/* In a FUNCTION_DECL, this is DECL_CLONED_FUNCTION.  */\n+\ttree cloned_function;\n+\t\n+\t/* In an overloaded operator, this is the value of\n+\t   DECL_OVERLOADED_OPERATOR_P.  */\n+\tenum tree_code operator_code;\n+\n+\tunsigned u3sel : 1;\n+\tunsigned pending_inline_p : 1;\n+\t\n+\tunion lang_decl_u3\n+\t{\n+\t  tree GTY ((tag (\"0\"))) sorted_fields;\n+\t  struct unparsed_text * GTY ((tag (\"2\"))) pending_inline_info;\n+\t  struct language_function * GTY ((tag (\"1\"))) \n+\t       saved_language_function;\n+\t} GTY ((desc (\"%1.u3sel + %1.pending_inline_p\"))) u;\n+      } GTY ((tag (\"1\"))) f;\n+  } GTY ((desc (\"%1.decl_flags.can_be_full\"))) u;\n+};\n \n-  /* For a virtual FUNCTION_DECL, this is DECL_VIRTUAL_CONTEXT.  For a\n-     non-virtual FUNCTION_DECL, this is DECL_FRIEND_CONTEXT.  */\n-  tree context;\n+#if defined ENABLE_TREE_CHECKING && (GCC_VERSION >= 2007)\n \n-  /* In a FUNCTION_DECL, this is DECL_CLONED_FUNCTION.  */\n-  tree cloned_function;\n+#define LANG_DECL_U2_CHECK(NODE, TF)\t\t\t\t\\\n+({  struct lang_decl *lt = DECL_LANG_SPECIFIC (NODE);\t\t\\\n+    if (lt->decl_flags.u2sel != TF)\t\t\t\t\\\n+      lang_check_failed (__FILE__, __LINE__, __FUNCTION__);\t\\\n+    &lt->decl_flags.u2; })\n \n-  union\n-  {\n-    tree sorted_fields;\n-    struct unparsed_text *pending_inline_info;\n-    struct cp_language_function *saved_language_function;\n-  } u;\n-\n-  union {\n-    /* In an overloaded operator, this is the value of\n-       DECL_OVERLOADED_OPERATOR_P.  */\n-    enum tree_code operator_code;\n-  } u2;\n-};\n+#else\n+\n+#define LANG_DECL_U2_CHECK(NODE, TF) \\\n+  (&DECL_LANG_SPECIFIC (NODE)->decl_flags.u2)\n+\n+#endif /* ENABLE_TREE_CHECKING */\n \n #define DEFARG_POINTER(NODE) (DEFAULT_ARG_CHECK (NODE)->identifier.id.str)\n \n@@ -1927,16 +2014,15 @@ struct lang_decl\n /* If DECL_CLONED_FUNCTION_P holds, this is the function that was\n    cloned.  */\n #define DECL_CLONED_FUNCTION(NODE) \\\n-  (DECL_LANG_SPECIFIC (NODE)->cloned_function)\n+  (DECL_LANG_SPECIFIC (NODE)->u.f.cloned_function)\n \n /* Nonzero if NODE has DECL_DISCRIMINATOR and not DECL_ACCESS.  */\n #define DECL_DISCRIMINATOR_P(NODE)\t\\\n   (TREE_CODE (NODE) == VAR_DECL\t\t\\\n    && DECL_FUNCTION_SCOPE_P (NODE))\n \n /* Discriminator for name mangling.  */\n-#define DECL_DISCRIMINATOR(NODE) \\\n-  (DECL_LANG_SPECIFIC (NODE)->decl_flags.u2.discriminator)\n+#define DECL_DISCRIMINATOR(NODE) (LANG_DECL_U2_CHECK (NODE, 1)->discriminator)\n \n /* Non-zero if the VTT parm has been added to NODE.  */\n #define DECL_HAS_VTT_PARM_P(NODE) \\\n@@ -1961,7 +2047,7 @@ struct lang_decl\n \n /* Set the overloaded operator code for NODE to CODE.  */\n #define SET_OVERLOADED_OPERATOR_CODE(NODE, CODE) \\\n-  (DECL_LANG_SPECIFIC (NODE)->u2.operator_code = (CODE))\n+  (DECL_LANG_SPECIFIC (NODE)->u.f.operator_code = (CODE))\n \n /* If NODE is an overloaded operator, then this returns the TREE_CODE\n    associcated with the overloaded operator.\n@@ -1972,7 +2058,7 @@ struct lang_decl\n    to test whether or not NODE is an overloaded operator.  */\n #define DECL_OVERLOADED_OPERATOR_P(NODE)\t\t\\\n   (IDENTIFIER_OPNAME_P (DECL_NAME (NODE))\t\t\\\n-   ? DECL_LANG_SPECIFIC (NODE)->u2.operator_code : ERROR_MARK)\n+   ? DECL_LANG_SPECIFIC (NODE)->u.f.operator_code : ERROR_MARK)\n \n /* Non-zero if NODE is an assignment operator.  */\n #define DECL_ASSIGNMENT_OPERATOR_P(NODE) \\\n@@ -2007,7 +2093,7 @@ struct lang_decl\n \n /* A TREE_LIST of the types which have befriended this FUNCTION_DECL.  */\n #define DECL_BEFRIENDING_CLASSES(NODE) \\\n-  (DECL_LANG_SPECIFIC (NODE)->befriending_classes)\n+  (DECL_LANG_SPECIFIC (NODE)->u.f.befriending_classes)\n \n /* Nonzero for FUNCTION_DECL means that this decl is a static\n    member function.  */\n@@ -2081,8 +2167,9 @@ struct lang_decl\n   (DECL_NON_THUNK_FUNCTION_P (NODE) && DECL_EXTERN_C_P (NODE))\n \n /* Set DECL_THUNK_P for node.  */\n-#define SET_DECL_THUNK_P(NODE) \\\n-  (DECL_LANG_FLAG_7 (NODE) = 1)\n+#define SET_DECL_THUNK_P(NODE)\t\t\t\t\t\\\n+  (DECL_LANG_FLAG_7 (NODE) = 1, \t\t\t\t\\\n+   DECL_LANG_SPECIFIC (NODE)->u.f.u3sel = 1)\n \n /* Nonzero if this DECL is the __PRETTY_FUNCTION__ variable in a\n    template function.  */\n@@ -2102,12 +2189,12 @@ struct lang_decl\n    the DECL_FRIEND_CONTEXT for `f' will be `S'.  */\n #define DECL_FRIEND_CONTEXT(NODE)\t\t\t\t\\\n   ((DECL_FRIEND_P (NODE) && !DECL_FUNCTION_MEMBER_P (NODE))\t\\\n-   ? DECL_LANG_SPECIFIC (NODE)->context                         \\\n+   ? DECL_LANG_SPECIFIC (NODE)->u.f.context\t\t\t\\\n    : NULL_TREE)\n \n /* Set the DECL_FRIEND_CONTEXT for NODE to CONTEXT.  */\n #define SET_DECL_FRIEND_CONTEXT(NODE, CONTEXT) \\\n-  (DECL_LANG_SPECIFIC (NODE)->context = (CONTEXT))\n+  (DECL_LANG_SPECIFIC (NODE)->u.f.context = (CONTEXT))\n \n /* NULL_TREE in DECL_CONTEXT represents the global namespace. */\n #define CP_DECL_CONTEXT(NODE) \\\n@@ -2117,7 +2204,7 @@ struct lang_decl\n /* For a virtual function, the base where we find its vtable entry.\n    For a non-virtual function, the base where it is defined.  */\n #define DECL_VIRTUAL_CONTEXT(NODE) \\\n-  (DECL_LANG_SPECIFIC (NODE)->context)\n+  (DECL_LANG_SPECIFIC (NODE)->u.f.context)\n \n /* 1 iff NODE has namespace scope, including the global namespace.  */\n #define DECL_NAMESPACE_SCOPE_P(NODE)\t\t\t\t\\\n@@ -2176,17 +2263,17 @@ struct lang_decl\n    the class definition.  We have saved away the text of the function,\n    but have not yet processed it.  */\n #define DECL_PENDING_INLINE_P(NODE) \\\n-  (DECL_LANG_SPECIFIC (NODE)->decl_flags.pending_inline_p)\n+  (DECL_LANG_SPECIFIC (NODE)->u.f.pending_inline_p)\n \n /* If DECL_PENDING_INLINE_P holds, this is the saved text of the\n    function.  */\n #define DECL_PENDING_INLINE_INFO(NODE) \\\n-  (DECL_LANG_SPECIFIC (NODE)->u.pending_inline_info)\n+  (DECL_LANG_SPECIFIC (NODE)->u.f.u.pending_inline_info)\n \n /* For a TYPE_DECL: if this function has many fields, we'll sort them\n    and put them into a TREE_VEC. */\n #define DECL_SORTED_FIELDS(NODE) \\\n-  (DECL_LANG_SPECIFIC (TYPE_DECL_CHECK (NODE))->u.sorted_fields)\n+  (DECL_LANG_SPECIFIC (TYPE_DECL_CHECK (NODE))->u.f.u.sorted_fields)\n \n /* True if on the deferred_fns (see decl2.c) list.  */\n #define DECL_DEFERRED_FN(DECL) \\\n@@ -2200,7 +2287,7 @@ struct lang_decl\n \n /* Template information for a RECORD_TYPE or UNION_TYPE.  */\n #define CLASSTYPE_TEMPLATE_INFO(NODE) \\\n-  (TYPE_LANG_SPECIFIC (RECORD_OR_UNION_TYPE_CHECK (NODE))->template_info)\n+  (LANG_TYPE_CLASS_CHECK (RECORD_OR_UNION_TYPE_CHECK (NODE))->template_info)\n \n /* Template information for an ENUMERAL_TYPE.  Although an enumeration may\n    not be a primary template, it may be declared within the scope of a\n@@ -2210,7 +2297,7 @@ struct lang_decl\n \n /* Template information for a template template parameter.  */\n #define TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO(NODE) \\\n-  (TYPE_LANG_SPECIFIC (BOUND_TEMPLATE_TEMPLATE_PARM_TYPE_CHECK (NODE)) \\\n+  (LANG_TYPE_CLASS_CHECK (BOUND_TEMPLATE_TEMPLATE_PARM_TYPE_CHECK (NODE)) \\\n    ->template_info)\n \n /* Template information for an ENUMERAL_, RECORD_, or UNION_TYPE.  */\n@@ -2348,8 +2435,9 @@ struct lang_decl\n #define TEMPLATE_PARMS_FOR_INLINE(NODE) TREE_LANG_FLAG_1 (NODE)\n \n /* In a FUNCTION_DECL, the saved language-specific per-function data.  */\n-#define DECL_SAVED_FUNCTION_DATA(NODE) \\\n-  (DECL_LANG_SPECIFIC (FUNCTION_DECL_CHECK (NODE))->u.saved_language_function)\n+#define DECL_SAVED_FUNCTION_DATA(NODE)\t\t\t\\\n+  (DECL_LANG_SPECIFIC (FUNCTION_DECL_CHECK (NODE))\t\\\n+   ->u.f.u.saved_language_function)\n \n #define NEW_EXPR_USE_GLOBAL(NODE)\tTREE_LANG_FLAG_0 (NODE)\n #define DELETE_EXPR_USE_GLOBAL(NODE)\tTREE_LANG_FLAG_0 (NODE)\n@@ -2488,15 +2576,15 @@ extern int flag_new_for_scope;\n /* Nonzero means that an object of this type can not be initialized using\n    an initializer list.  */\n #define CLASSTYPE_NON_AGGREGATE(NODE) \\\n-  (TYPE_LANG_SPECIFIC (NODE)->non_aggregate)\n+  (LANG_TYPE_CLASS_CHECK (NODE)->non_aggregate)\n #define TYPE_NON_AGGREGATE_CLASS(NODE) \\\n   (IS_AGGR_TYPE (NODE) && CLASSTYPE_NON_AGGREGATE (NODE))\n \n /* Nonzero if there is a user-defined X::op=(x&) for this class.  */\n-#define TYPE_HAS_REAL_ASSIGN_REF(NODE) (TYPE_LANG_SPECIFIC (NODE)->has_real_assign_ref)\n-#define TYPE_HAS_COMPLEX_ASSIGN_REF(NODE) (TYPE_LANG_SPECIFIC (NODE)->has_complex_assign_ref)\n-#define TYPE_HAS_ABSTRACT_ASSIGN_REF(NODE) (TYPE_LANG_SPECIFIC (NODE)->has_abstract_assign_ref)\n-#define TYPE_HAS_COMPLEX_INIT_REF(NODE) (TYPE_LANG_SPECIFIC (NODE)->has_complex_init_ref)\n+#define TYPE_HAS_REAL_ASSIGN_REF(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->has_real_assign_ref)\n+#define TYPE_HAS_COMPLEX_ASSIGN_REF(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->has_complex_assign_ref)\n+#define TYPE_HAS_ABSTRACT_ASSIGN_REF(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->has_abstract_assign_ref)\n+#define TYPE_HAS_COMPLEX_INIT_REF(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->has_complex_init_ref)\n \n /* Nonzero if TYPE has a trivial destructor.  From [class.dtor]:\n \n@@ -2555,7 +2643,7 @@ extern int flag_new_for_scope;\n    && TYPE_PTRMEMFUNC_FLAG (NODE))\n \n #define TYPE_PTRMEMFUNC_FLAG(NODE) \\\n-  (TYPE_LANG_SPECIFIC (NODE)->ptrmemfunc_flag)\n+  (LANG_TYPE_CLASS_CHECK (NODE)->ptrmemfunc_flag)\n \n /* Indicates when overload resolution may resolve to a pointer to\n    member function. [expr.unary.op]/3 */\n@@ -2600,9 +2688,17 @@ enum ptrmemfunc_vbit_where_t\n /* These are use to manipulate the canonical RECORD_TYPE from the\n    hashed POINTER_TYPE, and can only be used on the POINTER_TYPE.  */\n #define TYPE_GET_PTRMEMFUNC_TYPE(NODE) \\\n-  ((tree)TYPE_LANG_SPECIFIC (NODE))\n-#define TYPE_SET_PTRMEMFUNC_TYPE(NODE, VALUE) \\\n-  (TYPE_LANG_SPECIFIC (NODE) = ((struct lang_type *)(void*)(VALUE)))\n+  (TYPE_LANG_SPECIFIC (NODE) ? LANG_TYPE_PTRMEM_CHECK (NODE)->record : NULL)\n+#define TYPE_SET_PTRMEMFUNC_TYPE(NODE, VALUE)\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    if (TYPE_LANG_SPECIFIC (NODE) == NULL)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tTYPE_LANG_SPECIFIC (NODE) = \t\t\t\t\t\\\n+\t  ggc_alloc_cleared (sizeof (struct lang_type_ptrmem));\t\t\\\n+\tTYPE_LANG_SPECIFIC (NODE)->u.ptrmem.h.is_lang_type_class = 0;\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    TYPE_LANG_SPECIFIC (NODE)->u.ptrmem.record = (VALUE);\t\t\\\n+  } while (0)\n /* Returns the pfn field from a TYPE_PTRMEMFUNC_P.  */\n #define PFN_FROM_PTRMEMFUNC(NODE) pfn_from_ptrmemfunc ((NODE))\n \n@@ -2647,9 +2743,9 @@ enum ptrmemfunc_vbit_where_t\n    flag for this because \"A union for which objects or pointers are\n    declared is not an anonymous union\" [class.union].  */\n #define ANON_AGGR_TYPE_P(NODE)\t\t\t\t\\\n-  (CLASS_TYPE_P (NODE) && TYPE_LANG_SPECIFIC (NODE)->anon_aggr)\n+  (CLASS_TYPE_P (NODE) && LANG_TYPE_CLASS_CHECK (NODE)->anon_aggr)\n #define SET_ANON_AGGR_TYPE_P(NODE)\t\t\t\\\n-  (TYPE_LANG_SPECIFIC (NODE)->anon_aggr = 1)\n+  (LANG_TYPE_CLASS_CHECK (NODE)->anon_aggr = 1)\n \n /* Nonzero if TYPE is an anonymous union type.  */\n #define ANON_UNION_TYPE_P(NODE) \\\n@@ -2659,7 +2755,7 @@ enum ptrmemfunc_vbit_where_t\n \n /* Define fields and accessors for nodes representing declared names.  */\n \n-#define TYPE_WAS_ANONYMOUS(NODE) (TYPE_LANG_SPECIFIC (NODE)->was_anonymous)\n+#define TYPE_WAS_ANONYMOUS(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->was_anonymous)\n \n /* C++: all of these are overloaded!  These apply only to TYPE_DECLs.  */\n \n@@ -2684,7 +2780,7 @@ enum ptrmemfunc_vbit_where_t\n    For example, if a member that would normally be public in a\n    derived class is made protected, then the derived class and the\n    protected_access_node will appear in the DECL_ACCESS for the node.  */\n-#define DECL_ACCESS(NODE) (DECL_LANG_SPECIFIC (NODE)->decl_flags.u2.access)\n+#define DECL_ACCESS(NODE) (LANG_DECL_U2_CHECK (NODE, 0)->access)\n \n /* Nonzero if the FUNCTION_DECL is a global constructor.  */\n #define DECL_GLOBAL_CTOR_P(NODE) \\\n@@ -2699,7 +2795,7 @@ enum ptrmemfunc_vbit_where_t\n    with lower numbers should be run first.  Destructors should be run\n    in the reverse order of constructors.  */\n #define GLOBAL_INIT_PRIORITY(NODE) \\\n-  (DECL_LANG_SPECIFIC (NODE)->decl_flags.u2.init_priority)\n+  (LANG_DECL_U2_CHECK (NODE, 1)->init_priority)\n \n /* Accessor macros for C++ template decl nodes.  */\n \n@@ -2882,7 +2978,7 @@ enum ptrmemfunc_vbit_where_t\n    i.e., an instantiation whose instantiation arguments involve\n    template types.  */\n #define PARTIAL_INSTANTIATION_P(TYPE) \\\n-  (TYPE_LANG_SPECIFIC (TYPE)->is_partial_instantiation)\n+  (LANG_TYPE_CLASS_CHECK (TYPE)->is_partial_instantiation)\n \n /* Non-zero iff we are currently processing a declaration for an\n    entity with its own template parameter list, and which is not a\n@@ -2947,7 +3043,7 @@ enum ptrmemfunc_vbit_where_t\n    is always located at offset zero from the f `this' pointer.)  If\n    NULL, then there is no vcall offset.  */\n #define THUNK_VCALL_OFFSET(DECL) \\\n-  (DECL_LANG_SPECIFIC (DECL)->decl_flags.u2.vcall_offset)\n+  (LANG_DECL_U2_CHECK (DECL, 0)->vcall_offset)\n \n /* These macros provide convenient access to the various _STMT nodes\n    created when parsing template declarations.  */\n@@ -3124,17 +3220,18 @@ extern int warn_nontemplate_friend;\n \n /* in decl{2}.c */\n /* A node that is a list (length 1) of error_mark_nodes.  */\n-extern tree error_mark_list;\n+extern GTY(()) tree error_mark_list;\n \n /* Node for \"pointer to (virtual) function\".\n    This may be distinct from ptr_type_node so gdb can distinguish them.  */\n #define vfunc_ptr_type_node  vtable_entry_type\n \n \n /* For building calls to `delete'.  */\n-extern tree integer_two_node, integer_three_node;\n+extern GTY(()) tree integer_two_node;\n+extern GTY(()) tree integer_three_node;\n \n-extern tree anonymous_namespace_name;\n+extern GTY(()) tree anonymous_namespace_name;\n \n /* The number of function bodies which we are currently processing.\n    (Zero if we are at namespace scope, one inside the body of a\n@@ -3165,13 +3262,9 @@ typedef enum unification_kind_t {\n \n extern int current_class_depth;\n \n-/* Points to the name of that function. May not be the DECL_NAME\n-   of CURRENT_FUNCTION_DECL due to overloading */\n-extern tree original_function_name;\n-\n /* An array of all local classes present in this translation unit, in\n    declaration order.  */\n-extern varray_type local_classes;\n+extern GTY(()) varray_type local_classes;\n \f\n /* Here's where we control how name mangling takes place.  */\n \n@@ -3331,8 +3424,8 @@ extern int at_eof;\n \n /* Functions called along with real static constructors and destructors.  */\n \n-extern tree static_ctors;\n-extern tree static_dtors;\n+extern GTY(()) tree static_ctors;\n+extern GTY(()) tree static_dtors;\n \n enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, OP_FLAG, TYPENAME_FLAG };\n \n@@ -3652,7 +3745,8 @@ extern void insert_block\t\t\tPARAMS ((tree));\n extern void set_block\t\t\t\tPARAMS ((tree));\n extern tree pushdecl\t\t\t\tPARAMS ((tree));\n extern void cxx_init_decl_processing\t\tPARAMS ((void));\n-extern void cxx_mark_tree\t\t\tPARAMS ((tree));\n+enum cp_tree_node_structure_enum cp_tree_node_structure \n+  PARAMS ((union lang_tree_node *));\n extern void cxx_insert_default_attributes\tPARAMS ((tree));\n extern bool cxx_mark_addressable\t\tPARAMS ((tree));\n extern void cxx_push_function_context\t\tPARAMS ((struct function *));\n@@ -3669,13 +3763,13 @@ extern void finish_scope                        PARAMS ((void));\n extern void note_level_for_for\t\t\tPARAMS ((void));\n extern void note_level_for_try\t\t\tPARAMS ((void));\n extern void note_level_for_catch\t\tPARAMS ((void));\n-extern void resume_level\t\t\tPARAMS ((struct binding_level *));\n+extern void resume_level\t\t\tPARAMS ((struct cp_binding_level *));\n extern void delete_block\t\t\tPARAMS ((tree));\n extern void add_block_current_level\t\tPARAMS ((tree));\n extern void pushlevel_class\t\t\tPARAMS ((void));\n extern void poplevel_class                      PARAMS ((void));\n extern void print_binding_stack\t\t\tPARAMS ((void));\n-extern void print_binding_level\t\t\tPARAMS ((struct binding_level *));\n+extern void print_binding_level\t\t\tPARAMS ((struct cp_binding_level *));\n extern void push_namespace\t\t\tPARAMS ((tree));\n extern void pop_namespace\t\t\tPARAMS ((void));\n extern void push_nested_namespace\t\tPARAMS ((tree));\n@@ -3764,7 +3858,7 @@ extern tree finish_method\t\t\tPARAMS ((tree));\n extern void maybe_register_incomplete_var       PARAMS ((tree));\n extern void complete_vars\t\t\tPARAMS ((tree));\n extern void finish_stmt\t\t\t\tPARAMS ((void));\n-extern void print_other_binding_stack\t\tPARAMS ((struct binding_level *));\n+extern void print_other_binding_stack\t\tPARAMS ((struct cp_binding_level *));\n extern void revert_static_member_fn             PARAMS ((tree));\n extern void fixup_anonymous_aggr                PARAMS ((tree));\n extern int check_static_variable_definition     PARAMS ((tree, tree));\n@@ -3799,7 +3893,6 @@ extern tmpl_spec_kind current_tmpl_spec_kind    PARAMS ((int));\n extern tree cp_fname_init\t\t\tPARAMS ((const char *));\n \n /* in decl2.c */\n-extern void init_decl2\t\t\t\tPARAMS ((void));\n extern int check_java_method\t\t\tPARAMS ((tree));\n extern int cxx_decode_option\t\t\tPARAMS ((int, char **));\n extern int grok_method_quals\t\t\tPARAMS ((tree, tree, tree));\n@@ -3857,9 +3950,6 @@ extern tree get_guard                           PARAMS ((tree));\n extern tree get_guard_cond                      PARAMS ((tree));\n extern tree set_guard                           PARAMS ((tree));\n \n-/* in parse.y */\n-extern void cp_parse_init\t\t\tPARAMS ((void));\n-\n extern void cp_error_at\t\tPARAMS ((const char *msgid, ...));\n extern void cp_warning_at\tPARAMS ((const char *msgid, ...));\n extern void cp_pedwarn_at\tPARAMS ((const char *msgid, ...));\n@@ -3968,7 +4058,6 @@ extern tree make_aggr_type\t\t\tPARAMS ((enum tree_code));\n extern void compiler_error\t\t\tPARAMS ((const char *, ...))\n   ATTRIBUTE_PRINTF_1;\n extern void yyerror\t\t\t\tPARAMS ((const char *));\n-extern void clear_inline_text_obstack\t\tPARAMS ((void));\n extern void yyhook\t\t\t\tPARAMS ((int));\n extern int cp_type_qual_from_rid                PARAMS ((tree));\n extern const char *cxx_init\t\t\tPARAMS ((const char *));\n@@ -3992,7 +4081,6 @@ extern int calls_setjmp_p                       PARAMS ((tree));\n extern int maybe_clone_body                     PARAMS ((tree));\n \n /* in pt.c */\n-extern void init_pt                             PARAMS ((void));\n extern void check_template_shadow\t\tPARAMS ((tree));\n extern tree get_innermost_template_args         PARAMS ((tree, int));\n extern tree tsubst\t\t\t\tPARAMS ((tree, tree, tsubst_flags_t, tree));\n@@ -4192,7 +4280,6 @@ extern tree begin_class_definition              PARAMS ((tree));\n extern tree finish_class_definition             PARAMS ((tree, tree, int, int));\n extern void finish_default_args                 PARAMS ((void));\n extern void begin_inline_definitions            PARAMS ((void));\n-extern void finish_inline_definitions           PARAMS ((void));\n extern tree finish_member_class_template        PARAMS ((tree));\n extern void finish_template_decl                PARAMS ((tree));\n extern tree finish_template_type                PARAMS ((tree, tree, int));\n@@ -4219,7 +4306,6 @@ extern tree finish_global_stmt_expr             PARAMS ((tree));\n \n /* in spew.c */\n extern void init_spew\t\t\t\tPARAMS ((void));\n-extern void mark_pending_inlines\t\tPARAMS ((PTR));\n extern int peekyylex\t\t\t\tPARAMS ((void));\n extern tree arbitrate_lookup\t\t\tPARAMS ((tree, tree, tree));\n extern tree frob_opname                         PARAMS ((tree));\n@@ -4232,8 +4318,10 @@ extern void replace_defarg\t\t\tPARAMS ((tree, tree));\n extern void end_input\t\t\t\tPARAMS ((void));\n \n /* in tree.c */\n-extern tree stabilize_expr\t\tPARAMS ((tree, tree *));\n-extern tree cxx_unsave_expr_now\t\tPARAMS ((tree));\n+extern void lang_check_failed\t\t\tPARAMS ((const char *, int,\n+\t\t\t\t\t\t\t const char *));\n+extern tree stabilize_expr\t\t\tPARAMS ((tree, tree *));\n+extern tree cxx_unsave_expr_now\t\t\tPARAMS ((tree));\n extern tree cxx_maybe_build_cleanup\t\tPARAMS ((tree));\n extern void init_tree\t\t\t        PARAMS ((void));\n extern int pod_type_p\t\t\t\tPARAMS ((tree));\n@@ -4242,7 +4330,8 @@ extern tree canonical_type_variant              PARAMS ((tree));\n extern void unshare_base_binfos\t\t\tPARAMS ((tree));\n extern int member_p\t\t\t\tPARAMS ((tree));\n extern cp_lvalue_kind real_lvalue_p\t\tPARAMS ((tree));\n-extern tree build_min\t\t\t\tPARAMS ((enum tree_code, tree, ...));\n+extern tree build_min\t\t\t\tPARAMS ((enum tree_code, tree,\n+\t\t\t\t\t\t\t ...));\n extern tree build_min_nt\t\t\tPARAMS ((enum tree_code, ...));\n extern tree build_cplus_new\t\t\tPARAMS ((tree, tree));\n extern tree get_target_expr\t\t\tPARAMS ((tree));\n@@ -4275,8 +4364,7 @@ extern tree vec_binfo_member\t\t\tPARAMS ((tree, tree));\n extern tree decl_namespace_context\t\tPARAMS ((tree));\n extern tree lvalue_type\t\t\t\tPARAMS ((tree));\n extern tree error_type\t\t\t\tPARAMS ((tree));\n-extern tree build_ptr_wrapper\t\t\tPARAMS ((void *));\n-extern tree build_int_wrapper\t\t\tPARAMS ((int));\n+extern tree build_zc_wrapper\t\t\tPARAMS ((struct z_candidate *));\n extern tree build_srcloc_here\t\t\tPARAMS ((void));\n extern int varargs_function_p\t\t\tPARAMS ((tree));\n extern int really_overloaded_fn\t\t\tPARAMS ((tree));"}, {"sha": "de6a293bb08c15b543b1df1424ea01d134bbbcb9", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 160, "deletions": 398, "changes": 558, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -41,23 +41,24 @@ Boston, MA 02111-1307, USA.  */\n #include \"output.h\"\n #include \"except.h\"\n #include \"toplev.h\"\n-#include \"../hash.h\"\n+#include \"hashtab.h\"\n #include \"ggc.h\"\n #include \"tm_p.h\"\n #include \"target.h\"\n #include \"c-common.h\"\n #include \"c-pragma.h\"\n #include \"diagnostic.h\"\n+#include \"debug.h\"\n \n static tree grokparms\t\t\t\tPARAMS ((tree));\n static const char *redeclaration_error_message\tPARAMS ((tree, tree));\n \n-static void push_binding_level PARAMS ((struct binding_level *, int,\n+static void push_binding_level PARAMS ((struct cp_binding_level *, int,\n \t\t\t\t      int));\n static void pop_binding_level PARAMS ((void));\n static void suspend_binding_level PARAMS ((void));\n-static void resume_binding_level PARAMS ((struct binding_level *));\n-static struct binding_level *make_binding_level PARAMS ((void));\n+static void resume_binding_level PARAMS ((struct cp_binding_level *));\n+static struct cp_binding_level *make_binding_level PARAMS ((void));\n static void declare_namespace_level PARAMS ((void));\n static int decl_jump_unsafe PARAMS ((tree));\n static void storedecls PARAMS ((tree));\n@@ -77,21 +78,21 @@ static tree grokfndecl PARAMS ((tree, tree, tree, tree, int,\n static tree grokvardecl PARAMS ((tree, tree, RID_BIT_TYPE *, int, int, tree));\n static tree follow_tag_typedef PARAMS ((tree));\n static tree lookup_tag PARAMS ((enum tree_code, tree,\n-\t\t\t      struct binding_level *, int));\n+\t\t\t      struct cp_binding_level *, int));\n static void set_identifier_type_value_with_scope\n-\tPARAMS ((tree, tree, struct binding_level *));\n+\tPARAMS ((tree, tree, struct cp_binding_level *));\n static void record_unknown_type PARAMS ((tree, const char *));\n static tree builtin_function_1 PARAMS ((const char *, tree, tree, int,\n                                       enum built_in_class, const char *));\n static tree build_library_fn_1 PARAMS ((tree, enum tree_code, tree));\n static int member_function_or_else PARAMS ((tree, tree, enum overload_flags));\n static void bad_specifiers PARAMS ((tree, const char *, int, int, int, int,\n \t\t\t\t  int));\n-static tree maybe_process_template_type_declaration PARAMS ((tree, int, struct binding_level*));\n+static tree maybe_process_template_type_declaration PARAMS ((tree, int, struct cp_binding_level*));\n static void check_for_uninitialized_const_var PARAMS ((tree));\n-static unsigned long typename_hash PARAMS ((hash_table_key));\n-static bool typename_compare PARAMS ((hash_table_key, hash_table_key));\n-static void push_binding PARAMS ((tree, tree, struct binding_level*));\n+static hashval_t typename_hash PARAMS ((const void *));\n+static int typename_compare PARAMS ((const void *, const void *));\n+static void push_binding PARAMS ((tree, tree, struct cp_binding_level*));\n static int add_binding PARAMS ((tree, tree));\n static void pop_binding PARAMS ((tree, tree));\n static tree local_variable_p_walkfn PARAMS ((tree *, int *, void *));\n@@ -102,17 +103,17 @@ static tree qualify_lookup PARAMS ((tree, int));\n static tree record_builtin_java_type PARAMS ((const char *, int));\n static const char *tag_name PARAMS ((enum tag_types code));\n static void find_class_binding_level PARAMS ((void));\n-static struct binding_level *innermost_nonclass_level PARAMS ((void));\n+static struct cp_binding_level *innermost_nonclass_level PARAMS ((void));\n static void warn_about_implicit_typename_lookup PARAMS ((tree, tree));\n static int walk_namespaces_r PARAMS ((tree, walk_namespaces_fn, void *));\n static int walk_globals_r PARAMS ((tree, void *));\n-static void add_decl_to_level PARAMS ((tree, struct binding_level *));\n+static void add_decl_to_level PARAMS ((tree, struct cp_binding_level *));\n static tree make_label_decl PARAMS ((tree, int));\n static void use_label PARAMS ((tree));\n-static void check_previous_goto_1 PARAMS ((tree, struct binding_level *, tree,\n+static void check_previous_goto_1 PARAMS ((tree, struct cp_binding_level *, tree,\n \t\t\t\t\t   const char *, int));\n static void check_previous_goto PARAMS ((struct named_label_use_list *));\n-static void check_switch_goto PARAMS ((struct binding_level *));\n+static void check_switch_goto PARAMS ((struct cp_binding_level *));\n static void check_previous_gotos PARAMS ((tree));\n static void pop_label PARAMS ((tree, tree));\n static void pop_labels PARAMS ((tree));\n@@ -121,10 +122,6 @@ static void layout_var_decl PARAMS ((tree));\n static void maybe_commonize_var PARAMS ((tree));\n static tree check_initializer PARAMS ((tree, tree));\n static void make_rtl_for_nonlocal_decl PARAMS ((tree, tree, const char *));\n-static void mark_binding_level PARAMS ((void *));\n-static void mark_named_label_lists PARAMS ((void *, void *));\n-static void mark_saved_scope PARAMS ((void *));\n-static void mark_lang_function PARAMS ((struct cp_language_function *));\n static void save_function_data PARAMS ((tree));\n static void check_function_type PARAMS ((tree, tree));\n static void destroy_local_var PARAMS ((tree));\n@@ -146,7 +143,7 @@ static tree build_cp_library_fn PARAMS ((tree, enum tree_code, tree));\n static void store_parm_decls PARAMS ((tree));\n static int cp_missing_noreturn_ok_p PARAMS ((tree));\n \n-#if defined (DEBUG_CP_BINDING_LEVELS)\n+#if defined (DEBUG_BINDING_LEVELS)\n static void indent PARAMS ((void));\n #endif\n \n@@ -203,17 +200,17 @@ tree cp_global_trees[CPTI_MAX];\n /* Indicates that there is a type value in some namespace, although\n    that is not necessarily in scope at the moment.  */\n \n-static tree global_type_node;\n+static GTY(()) tree global_type_node;\n \n /* Expect only namespace names now. */\n static int only_namespace_names;\n \n /* Used only for jumps to as-yet undefined labels, since jumps to\n    defined labels can have their validity checked immediately.  */\n \n-struct named_label_use_list\n+struct named_label_use_list GTY(())\n {\n-  struct binding_level *binding_level;\n+  struct cp_binding_level *binding_level;\n   tree names_in_scope;\n   tree label_decl;\n   const char *filename_o_goto;\n@@ -244,9 +241,9 @@ tree last_function_parms;\n    we can clear out their names' definitions at the end of the\n    function, and so we can check the validity of jumps to these labels.  */\n \n-struct named_label_list\n+struct named_label_list GTY(())\n {\n-  struct binding_level *binding_level;\n+  struct cp_binding_level *binding_level;\n   tree names_in_scope;\n   tree old_value;\n   tree label_decl;\n@@ -283,10 +280,6 @@ extern int flag_conserve_space;\n \f\n /* C and C++ flags are in decl2.c.  */\n \n-/* A expression of value 0 with the same precision as a sizetype\n-   node, but signed.  */\n-tree signed_size_zero_node;\n-\n /* The name of the anonymous namespace, throughout this translation\n    unit.  */\n tree anonymous_namespace_name;\n@@ -337,7 +330,7 @@ int adding_implicit_members = 0;\n /* Note that the information in the `names' component of the global contour\n    is duplicated in the IDENTIFIER_GLOBAL_VALUEs of all identifiers.  */\n \n-struct binding_level\n+struct cp_binding_level GTY(())\n   {\n     /* A chain of _DECL nodes for all variables, constants, functions,\n        and typedef types.  These are in the reverse of the order\n@@ -387,7 +380,7 @@ struct binding_level\n     tree this_class;\n \n     /* The binding level which this one is contained in (inherits from).  */\n-    struct binding_level *level_chain;\n+    struct cp_binding_level *level_chain;\n \n     /* List of VAR_DECLS saved from a previous for statement.\n        These would be dead in ISO-conforming code, but might\n@@ -438,13 +431,11 @@ struct binding_level\n \n     /* Three bits left for this word.  */\n \n-#if defined(DEBUG_CP_BINDING_LEVELS)\n     /* Binding depth at which this level began.  */\n     unsigned binding_depth;\n-#endif /* defined(DEBUG_CP_BINDING_LEVELS) */\n   };\n \n-#define NULL_BINDING_LEVEL ((struct binding_level *) NULL)\n+#define NULL_BINDING_LEVEL ((struct cp_binding_level *) NULL)\n \n /* The binding level currently in effect.  */\n \n@@ -459,13 +450,13 @@ struct binding_level\n \n /* A chain of binding_level structures awaiting reuse.  */\n \n-static struct binding_level *free_binding_level;\n+static GTY((deletable (\"\"))) struct cp_binding_level *free_binding_level;\n \n /* The outermost binding level, for names of file scope.\n    This is created when the compiler is started and exists\n    through the entire run.  */\n \n-static struct binding_level *global_binding_level;\n+static GTY(()) struct cp_binding_level *global_binding_level;\n \n /* Nonzero means unconditionally make a BLOCK for the next level pushed.  */\n \n@@ -475,9 +466,9 @@ static int keep_next_level_flag;\n    UNION_TYPE; the TREE_VALUE is a VAR_DECL with that type.  At the\n    time the VAR_DECL was declared, the type was incomplete.  */\n \n-static tree incomplete_vars;\n+static GTY(()) tree incomplete_vars;\n \n-#if defined(DEBUG_CP_BINDING_LEVELS)\n+#if defined(DEBUG_BINDING_LEVELS)\n static int binding_depth = 0;\n static int is_class_level = 0;\n \n@@ -489,32 +480,32 @@ indent ()\n   for (i = 0; i < binding_depth*2; i++)\n     putc (' ', stderr);\n }\n-#endif /* defined(DEBUG_CP_BINDING_LEVELS) */\n+#endif /* defined(DEBUG_BINDING_LEVELS) */\n \n-static tree pushdecl_with_scope\tPARAMS ((tree, struct binding_level *));\n+static tree pushdecl_with_scope\tPARAMS ((tree, struct cp_binding_level *));\n \n static void\n push_binding_level (newlevel, tag_transparent, keep)\n-     struct binding_level *newlevel;\n+     struct cp_binding_level *newlevel;\n      int tag_transparent, keep;\n {\n   /* Add this level to the front of the chain (stack) of levels that\n      are active.  */\n-  memset ((char*) newlevel, 0, sizeof (struct binding_level));\n+  memset ((char*) newlevel, 0, sizeof (struct cp_binding_level));\n   newlevel->level_chain = current_binding_level;\n   current_binding_level = newlevel;\n   newlevel->tag_transparent = tag_transparent;\n   newlevel->more_cleanups_ok = 1;\n \n   newlevel->keep = keep;\n-#if defined(DEBUG_CP_BINDING_LEVELS)\n+#if defined(DEBUG_BINDING_LEVELS)\n   newlevel->binding_depth = binding_depth;\n   indent ();\n   fprintf (stderr, \"push %s level 0x%08x line %d\\n\",\n \t   (is_class_level) ? \"class\" : \"block\", newlevel, lineno);\n   is_class_level = 0;\n   binding_depth++;\n-#endif /* defined(DEBUG_CP_BINDING_LEVELS) */\n+#endif /* defined(DEBUG_BINDING_LEVELS) */\n }\n \n /* Find the innermost enclosing class scope, and reset\n@@ -523,7 +514,7 @@ push_binding_level (newlevel, tag_transparent, keep)\n static void\n find_class_binding_level ()\n {\n-  struct binding_level *level = current_binding_level;\n+  struct cp_binding_level *level = current_binding_level;\n \n   while (level && level->parm_flag != 2)\n     level = level->level_chain;\n@@ -543,7 +534,7 @@ pop_binding_level ()\n \tabort ();\n     }\n   /* Pop the current level, and free the structure for reuse.  */\n-#if defined(DEBUG_CP_BINDING_LEVELS)\n+#if defined(DEBUG_BINDING_LEVELS)\n   binding_depth--;\n   indent ();\n   fprintf (stderr, \"pop  %s level 0x%08x line %d\\n\",\n@@ -555,15 +546,15 @@ pop_binding_level ()\n       fprintf (stderr, \"XXX is_class_level != (current_binding_level == class_binding_level)\\n\");\n     }\n   is_class_level = 0;\n-#endif /* defined(DEBUG_CP_BINDING_LEVELS) */\n+#endif /* defined(DEBUG_BINDING_LEVELS) */\n   {\n-    register struct binding_level *level = current_binding_level;\n+    register struct cp_binding_level *level = current_binding_level;\n     current_binding_level = current_binding_level->level_chain;\n     level->level_chain = free_binding_level;\n-#if 0 /* defined(DEBUG_CP_BINDING_LEVELS) */\n+#if 0 /* defined(DEBUG_BINDING_LEVELS) */\n     if (level->binding_depth != binding_depth)\n       abort ();\n-#endif /* defined(DEBUG_CP_BINDING_LEVELS) */\n+#endif /* defined(DEBUG_BINDING_LEVELS) */\n     free_binding_level = level;\n     find_class_binding_level ();\n   }\n@@ -582,7 +573,7 @@ suspend_binding_level ()\n \tabort ();\n     }\n   /* Suspend the current level.  */\n-#if defined(DEBUG_CP_BINDING_LEVELS)\n+#if defined(DEBUG_BINDING_LEVELS)\n   binding_depth--;\n   indent ();\n   fprintf (stderr, \"suspend  %s level 0x%08x line %d\\n\",\n@@ -594,39 +585,39 @@ suspend_binding_level ()\n       fprintf (stderr, \"XXX is_class_level != (current_binding_level == class_binding_level)\\n\");\n     }\n   is_class_level = 0;\n-#endif /* defined(DEBUG_CP_BINDING_LEVELS) */\n+#endif /* defined(DEBUG_BINDING_LEVELS) */\n   current_binding_level = current_binding_level->level_chain;\n   find_class_binding_level ();\n }\n \n static void\n resume_binding_level (b)\n-     struct binding_level *b;\n+     struct cp_binding_level *b;\n {\n   /* Resuming binding levels is meant only for namespaces,\n      and those cannot nest into classes. */\n   my_friendly_assert(!class_binding_level, 386);\n   /* Also, resuming a non-directly nested namespace is a no-no.  */\n   my_friendly_assert(b->level_chain == current_binding_level, 386);\n   current_binding_level = b;\n-#if defined(DEBUG_CP_BINDING_LEVELS)\n+#if defined(DEBUG_BINDING_LEVELS)\n   b->binding_depth = binding_depth;\n   indent ();\n   fprintf (stderr, \"resume %s level 0x%08x line %d\\n\",\n \t   (is_class_level) ? \"class\" : \"block\", b, lineno);\n   is_class_level = 0;\n   binding_depth++;\n-#endif /* defined(DEBUG_CP_BINDING_LEVELS) */\n+#endif /* defined(DEBUG_BINDING_LEVELS) */\n }\n \f\n-/* Create a new `struct binding_level'.  */\n+/* Create a new `struct cp_binding_level'.  */\n \n static\n-struct binding_level *\n+struct cp_binding_level *\n make_binding_level ()\n {\n   /* NOSTRICT */\n-  return (struct binding_level *) xmalloc (sizeof (struct binding_level));\n+  return (struct cp_binding_level *) ggc_alloc (sizeof (struct cp_binding_level));\n }\n \n /* Nonzero if we are currently in the global binding level.  */\n@@ -639,10 +630,10 @@ global_bindings_p ()\n \n /* Return the innermost binding level that is not for a class scope.  */\n \n-static struct binding_level *\n+static struct cp_binding_level *\n innermost_nonclass_level ()\n {\n-  struct binding_level *b;\n+  struct cp_binding_level *b;\n \n   b = current_binding_level;\n   while (b->parm_flag == 2)\n@@ -660,7 +651,7 @@ innermost_nonclass_level ()\n int\n toplevel_bindings_p ()\n {\n-  struct binding_level *b = innermost_nonclass_level ();\n+  struct cp_binding_level *b = innermost_nonclass_level ();\n \n   return b->namespace_p || b->template_parms_p;\n }\n@@ -672,7 +663,7 @@ toplevel_bindings_p ()\n int\n namespace_bindings_p ()\n {\n-  struct binding_level *b = innermost_nonclass_level ();\n+  struct cp_binding_level *b = innermost_nonclass_level ();\n \n   return b->namespace_p;\n }\n@@ -726,7 +717,7 @@ current_tmpl_spec_kind (n_class_scopes)\n   int n_template_parm_scopes = 0;\n   int seen_specialization_p = 0;\n   int innermost_specialization_p = 0;\n-  struct binding_level *b;\n+  struct cp_binding_level *b;\n \n   /* Scan through the template parameter scopes.  */\n   for (b = current_binding_level; b->template_parms_p; b = b->level_chain)\n@@ -819,17 +810,17 @@ void\n pushlevel (tag_transparent)\n      int tag_transparent;\n {\n-  struct binding_level *newlevel;\n+  struct cp_binding_level *newlevel;\n \n   if (cfun && !doing_semantic_analysis_p ())\n     return;\n \n   /* Reuse or create a struct for this binding level.  */\n-#if defined(DEBUG_CP_BINDING_LEVELS)\n+#if defined(DEBUG_BINDING_LEVELS)\n   if (0)\n-#else /* !defined(DEBUG_CP_BINDING_LEVELS) */\n+#else /* !defined(DEBUG_BINDING_LEVELS) */\n   if (free_binding_level)\n-#endif /* !defined(DEBUG_CP_BINDING_LEVELS) */\n+#endif /* !defined(DEBUG_BINDING_LEVELS) */\n     {\n       newlevel = free_binding_level;\n       free_binding_level = free_binding_level->level_chain;\n@@ -914,14 +905,14 @@ note_level_for_catch ()\n }\n \n /* For a binding between a name and an entity at a block scope,\n-   this is the `struct binding_level' for the block.  */\n+   this is the `struct cp_binding_level' for the block.  */\n #define BINDING_LEVEL(NODE) \\\n   (((struct tree_binding*)(NODE))->scope.level)\n \n /* A free list of CPLUS_BINDING nodes, connected by their\n    TREE_CHAINs.  */\n \n-static tree free_bindings;\n+static GTY((deletable (\"\"))) tree free_bindings;\n \n /* Make DECL the innermost binding for ID.  The LEVEL is the binding\n    level at which this declaration is being bound.  */\n@@ -930,7 +921,7 @@ static void\n push_binding (id, decl, level)\n      tree id;\n      tree decl;\n-     struct binding_level* level;\n+     struct cp_binding_level* level;\n {\n   tree binding;\n \n@@ -1033,7 +1024,7 @@ add_binding (id, decl)\n static void\n add_decl_to_level (decl, b)\n      tree decl;\n-     struct binding_level *b;\n+     struct cp_binding_level *b;\n {\n   /* We build up the list in reverse order, and reverse it later if\n      necessary.  */\n@@ -1052,7 +1043,7 @@ push_local_binding (id, decl, flags)\n      tree decl;\n      int flags;\n {\n-  struct binding_level *b;\n+  struct cp_binding_level *b;\n \n   /* Skip over any local classes.  This makes sense if we call\n      push_local_binding with a friend decl of a local class.  */\n@@ -1303,7 +1294,7 @@ poplevel (keep, reverse, functionbody)\n      under constraints of next binding contour.  */\n   if (cfun && !functionbody)\n     {\n-      struct binding_level *level_chain;\n+      struct cp_binding_level *level_chain;\n       level_chain = current_binding_level->level_chain;\n       if (level_chain)\n \t{\n@@ -1626,24 +1617,24 @@ set_block (block)\n void\n pushlevel_class ()\n {\n-  register struct binding_level *newlevel;\n+  register struct cp_binding_level *newlevel;\n \n   /* Reuse or create a struct for this binding level.  */\n-#if defined(DEBUG_CP_BINDING_LEVELS)\n+#if defined(DEBUG_BINDING_LEVELS)\n   if (0)\n-#else /* !defined(DEBUG_CP_BINDING_LEVELS) */\n+#else /* !defined(DEBUG_BINDING_LEVELS) */\n   if (free_binding_level)\n-#endif /* !defined(DEBUG_CP_BINDING_LEVELS) */\n+#endif /* !defined(DEBUG_BINDING_LEVELS) */\n     {\n       newlevel = free_binding_level;\n       free_binding_level = free_binding_level->level_chain;\n     }\n   else\n     newlevel = make_binding_level ();\n \n-#if defined(DEBUG_CP_BINDING_LEVELS)\n+#if defined(DEBUG_BINDING_LEVELS)\n   is_class_level = 1;\n-#endif /* defined(DEBUG_CP_BINDING_LEVELS) */\n+#endif /* defined(DEBUG_BINDING_LEVELS) */\n \n   push_binding_level (newlevel, 0, 0);\n \n@@ -1657,7 +1648,7 @@ pushlevel_class ()\n void\n poplevel_class ()\n {\n-  register struct binding_level *level = class_binding_level;\n+  register struct cp_binding_level *level = class_binding_level;\n   tree shadowed;\n \n   my_friendly_assert (level != 0, 354);\n@@ -1669,7 +1660,7 @@ poplevel_class ()\n      next time we're entering a class scope, it is the same class.  */\n   if (current_class_depth != 1)\n     {\n-      struct binding_level* b;\n+      struct cp_binding_level* b;\n \n       /* Clear out our IDENTIFIER_CLASS_VALUEs.  */\n       for (shadowed = level->class_shadowed;\n@@ -1719,9 +1710,9 @@ poplevel_class ()\n \n   /* Now, pop out of the binding level which we created up in the\n      `pushlevel_class' routine.  */\n-#if defined(DEBUG_CP_BINDING_LEVELS)\n+#if defined(DEBUG_BINDING_LEVELS)\n   is_class_level = 1;\n-#endif /* defined(DEBUG_CP_BINDING_LEVELS) */\n+#endif /* defined(DEBUG_BINDING_LEVELS) */\n \n   pop_binding_level ();\n }\n@@ -1930,58 +1921,14 @@ wrapup_globals_for_namespace (namespace, data)\n   return result;\n }\n \n-\f\n-/* Mark ARG (which is really a struct binding_level **) for GC.  */\n-\n-static void\n-mark_binding_level (arg)\n-     void *arg;\n-{\n-  struct binding_level *lvl = *(struct binding_level **)arg;\n-\n-  for (; lvl; lvl = lvl->level_chain)\n-    {\n-      ggc_mark_tree (lvl->names);\n-      ggc_mark_tree (lvl->tags);\n-      ggc_mark_tree (lvl->usings);\n-      ggc_mark_tree (lvl->using_directives);\n-      ggc_mark_tree (lvl->class_shadowed);\n-      ggc_mark_tree (lvl->type_shadowed);\n-      ggc_mark_tree (lvl->shadowed_labels);\n-      ggc_mark_tree (lvl->blocks);\n-      ggc_mark_tree (lvl->this_class);\n-      ggc_mark_tree (lvl->dead_vars_from_for);\n-    }\n-}\n-\n-static void\n-mark_named_label_lists (labs, uses)\n-     void *labs;\n-     void *uses;\n-{\n-  struct named_label_list *l = *(struct named_label_list **)labs;\n-  struct named_label_use_list *u = *(struct named_label_use_list **)uses;\n-\n-  for (; l; l = l->next)\n-    {\n-      ggc_mark (l);\n-      mark_binding_level (l->binding_level);\n-      ggc_mark_tree (l->old_value);\n-      ggc_mark_tree (l->label_decl);\n-      ggc_mark_tree (l->bad_decls);\n-    }\n-\n-  for (; u; u = u->next)\n-    ggc_mark (u);\n-}\n \f\n /* For debugging.  */\n static int no_print_functions = 0;\n static int no_print_builtins = 0;\n \n void\n print_binding_level (lvl)\n-     struct binding_level *lvl;\n+     struct cp_binding_level *lvl;\n {\n   tree t;\n   int i = 0, len;\n@@ -2082,9 +2029,9 @@ print_binding_level (lvl)\n \n void\n print_other_binding_stack (stack)\n-     struct binding_level *stack;\n+     struct cp_binding_level *stack;\n {\n-  struct binding_level *level;\n+  struct cp_binding_level *level;\n   for (level = stack; level != global_binding_level; level = level->level_chain)\n     {\n       fprintf (stderr, \"binding level \");\n@@ -2097,7 +2044,7 @@ print_other_binding_stack (stack)\n void\n print_binding_stack ()\n {\n-  struct binding_level *b;\n+  struct cp_binding_level *b;\n   fprintf (stderr, \"current_binding_level=\");\n   fprintf (stderr, HOST_PTR_PRINTF, current_binding_level);\n   fprintf (stderr, \"\\nclass_binding_level=\");\n@@ -2363,38 +2310,6 @@ pop_nested_namespace (ns)\n    scope isn't enough, because more binding levels may be pushed.  */\n struct saved_scope *scope_chain;\n \n-/* Mark ARG (which is really a struct saved_scope **) for GC.  */\n-\n-static void\n-mark_saved_scope (arg)\n-     void *arg;\n-{\n-  struct saved_scope *t = *(struct saved_scope **)arg;\n-  while (t)\n-    {\n-      mark_binding_level (&t->class_bindings);\n-      ggc_mark_tree (t->old_bindings);\n-      ggc_mark_tree (t->old_namespace);\n-      ggc_mark_tree (t->decl_ns_list);\n-      ggc_mark_tree (t->class_name);\n-      ggc_mark_tree (t->class_type);\n-      ggc_mark_tree (t->access_specifier);\n-      ggc_mark_tree (t->function_decl);\n-      if (t->lang_base)\n-\tggc_mark_tree_varray (t->lang_base);\n-      ggc_mark_tree (t->lang_name);\n-      ggc_mark_tree (t->template_parms);\n-      ggc_mark_tree (t->x_previous_class_type);\n-      ggc_mark_tree (t->x_previous_class_values);\n-      ggc_mark_tree (t->x_saved_tree);\n-      ggc_mark_tree (t->lookups);\n-\n-      mark_stmt_tree (&t->x_stmt_tree);\n-      mark_binding_level (&t->bindings);\n-      t = t->prev;\n-    }\n-}\n-\n static tree\n store_bindings (names, old_bindings)\n      tree names, old_bindings;\n@@ -2443,11 +2358,11 @@ maybe_push_to_top_level (pseudo)\n      int pseudo;\n {\n   struct saved_scope *s;\n-  struct binding_level *b;\n+  struct cp_binding_level *b;\n   tree old_bindings;\n   int need_pop;\n \n-  s = (struct saved_scope *) xcalloc (1, sizeof (struct saved_scope));\n+  s = (struct saved_scope *) ggc_alloc_cleared (sizeof (struct saved_scope));\n \n   b = scope_chain ? current_binding_level : 0;\n \n@@ -2517,7 +2432,7 @@ pop_from_top_level ()\n   if (previous_class_type)\n     invalidate_class_lookup_cache ();\n \n-  VARRAY_FREE (current_lang_base);\n+  current_lang_base = 0;\n \n   scope_chain = s->prev;\n   for (t = s->old_bindings; t; t = TREE_CHAIN (t))\n@@ -2535,8 +2450,6 @@ pop_from_top_level ()\n     pop_function_context_from (NULL_TREE);\n   current_function_decl = s->function_decl;\n   last_function_parms = s->last_parms;\n-\n-  free (s);\n }\n \f\n /* Push a definition of struct, union or enum tag \"name\".\n@@ -2556,7 +2469,7 @@ static void\n set_identifier_type_value_with_scope (id, type, b)\n      tree id;\n      tree type;\n-     struct binding_level *b;\n+     struct cp_binding_level *b;\n {\n   if (!b->namespace_p)\n     {\n@@ -2613,7 +2526,7 @@ identifier_type_value (id)\n void\n pop_everything ()\n {\n-#ifdef DEBUG_CP_BINDING_LEVELS\n+#ifdef DEBUG_BINDING_LEVELS\n   fprintf (stderr, \"XXX entering pop_everything ()\\n\");\n #endif\n   while (!toplevel_bindings_p ())\n@@ -2623,7 +2536,7 @@ pop_everything ()\n       else\n \tpoplevel (0, 0, 0);\n     }\n-#ifdef DEBUG_CP_BINDING_LEVELS\n+#ifdef DEBUG_BINDING_LEVELS\n   fprintf (stderr, \"XXX leaving pop_everything ()\\n\");\n #endif\n }\n@@ -2641,7 +2554,7 @@ static tree\n maybe_process_template_type_declaration (type, globalize, b)\n      tree type;\n      int globalize;\n-     struct binding_level* b;\n+     struct cp_binding_level* b;\n {\n   tree decl = TYPE_NAME (type);\n \n@@ -2739,6 +2652,7 @@ push_local_name (decl)\n \t{\n \t  if (!DECL_LANG_SPECIFIC (decl))\n \t    retrofit_lang_decl (decl);\n+\t  DECL_LANG_SPECIFIC (decl)->decl_flags.u2sel = 1;\n \t  if (DECL_LANG_SPECIFIC (t))\n \t    DECL_DISCRIMINATOR (decl) = DECL_DISCRIMINATOR (t) + 1;\n \t  else\n@@ -2762,7 +2676,7 @@ pushtag (name, type, globalize)\n      tree name, type;\n      int globalize;\n {\n-  register struct binding_level *b;\n+  register struct cp_binding_level *b;\n \n   b = current_binding_level;\n   while (b->tag_transparent\n@@ -2893,7 +2807,7 @@ make_anon_name ()\n void\n clear_anon_tags ()\n {\n-  register struct binding_level *b;\n+  register struct cp_binding_level *b;\n   register tree tags;\n   static int last_cnt = 0;\n \n@@ -3654,7 +3568,8 @@ duplicate_decls (newdecl, olddecl)\n       /* Don't really know how much of the language-specific\n \t values we should copy from old to new.  */\n       DECL_IN_AGGR_P (newdecl) = DECL_IN_AGGR_P (olddecl);\n-      DECL_ACCESS (newdecl) = DECL_ACCESS (olddecl);\n+      DECL_LANG_SPECIFIC (newdecl)->decl_flags.u2 = \n+\tDECL_LANG_SPECIFIC (olddecl)->decl_flags.u2;\n       DECL_NONCONVERTING_P (newdecl) = DECL_NONCONVERTING_P (olddecl);\n       DECL_TEMPLATE_INFO (newdecl) = DECL_TEMPLATE_INFO (olddecl);\n       DECL_INITIALIZED_IN_CLASS_P (newdecl)\n@@ -4212,7 +4127,7 @@ pushdecl (x)\n \t\t{\n \t\t  /* Go to where the parms should be and see if we find\n \t\t     them there.  */\n-\t\t  struct binding_level *b = current_binding_level->level_chain;\n+\t\t  struct cp_binding_level *b = current_binding_level->level_chain;\n \n \t\t  /* ARM $8.3 */\n \t\t  if (b->parm_flag == 1)\n@@ -4271,9 +4186,9 @@ pushdecl (x)\n static tree\n pushdecl_with_scope (x, level)\n      tree x;\n-     struct binding_level *level;\n+     struct cp_binding_level *level;\n {\n-  register struct binding_level *b;\n+  register struct cp_binding_level *b;\n   tree function_decl = current_function_decl;\n \n   current_function_decl = NULL_TREE;\n@@ -4302,7 +4217,7 @@ tree\n pushdecl_namespace_level (x)\n      tree x;\n {\n-  register struct binding_level *b = current_binding_level;\n+  register struct cp_binding_level *b = current_binding_level;\n   register tree t;\n \n   t = pushdecl_with_scope (x, NAMESPACE_LEVEL (current_namespace));\n@@ -4945,14 +4860,14 @@ decl_jump_unsafe (decl)\n static void\n check_previous_goto_1 (decl, level, names, file, line)\n      tree decl;\n-     struct binding_level *level;\n+     struct cp_binding_level *level;\n      tree names;\n      const char *file;\n      int line;\n {\n   int identified = 0;\n   int saw_eh = 0;\n-  struct binding_level *b = current_binding_level;\n+  struct cp_binding_level *b = current_binding_level;\n   for (; b; b = b->level_chain)\n     {\n       tree new_decls = b->names;\n@@ -5019,7 +4934,7 @@ check_previous_goto (use)\n \n static void\n check_switch_goto (level)\n-     struct binding_level *level;\n+     struct cp_binding_level *level;\n {\n   check_previous_goto_1 (NULL_TREE, level, level->names, NULL, 0);\n }\n@@ -5121,7 +5036,7 @@ define_label (filename, line, name)\n {\n   tree decl = lookup_label (name);\n   struct named_label_list *ent;\n-  register struct binding_level *p;\n+  register struct cp_binding_level *p;\n \n   for (ent = named_labels; ent; ent = ent->next)\n     if (ent->label_decl == decl)\n@@ -5159,7 +5074,7 @@ define_label (filename, line, name)\n \n struct cp_switch\n {\n-  struct binding_level *level;\n+  struct cp_binding_level *level;\n   struct cp_switch *next;\n   /* The SWITCH_STMT being built.  */\n   tree switch_stmt;\n@@ -5215,7 +5130,7 @@ finish_case_label (low_value, high_value)\n      tree high_value;\n {\n   tree cond, r;\n-  register struct binding_level *p;\n+  register struct cp_binding_level *p;\n \n   if (! switch_stack)\n     {\n@@ -5353,10 +5268,10 @@ static tree\n lookup_tag (form, name, binding_level, thislevel_only)\n      enum tree_code form;\n      tree name;\n-     struct binding_level *binding_level;\n+     struct cp_binding_level *binding_level;\n      int thislevel_only;\n {\n-  register struct binding_level *level;\n+  register struct cp_binding_level *level;\n   /* Non-zero if, we should look past a template parameter level, even\n      if THISLEVEL_ONLY.  */\n   int allow_template_parms_p = 1;\n@@ -5472,7 +5387,7 @@ lookup_tag_reverse (type, name)\n      tree type;\n      tree name;\n {\n-  register struct binding_level *level;\n+  register struct cp_binding_level *level;\n \n   for (level = current_binding_level; level; level = level->level_chain)\n     {\n@@ -5572,26 +5487,25 @@ lookup_namespace_name (namespace, name)\n \n /* Hash a TYPENAME_TYPE.  K is really of type `tree'.  */\n \n-static unsigned long\n+static hashval_t\n typename_hash (k)\n-     hash_table_key k;\n+     const void * k;\n {\n-  unsigned long hash;\n-  tree t;\n+  hashval_t hash;\n+  tree t = (tree) k;\n \n-  t = (tree) k;\n-  hash = (((unsigned long) TYPE_CONTEXT (t))\n-\t  ^ ((unsigned long) DECL_NAME (TYPE_NAME (t))));\n+  hash = (((hashval_t) TYPE_CONTEXT (t))\n+\t  ^ ((hashval_t) DECL_NAME (TYPE_NAME (t))));\n \n   return hash;\n }\n \n /* Compare two TYPENAME_TYPEs.  K1 and K2 are really of type `tree'.  */\n \n-static bool\n+static int\n typename_compare (k1, k2)\n-     hash_table_key k1;\n-     hash_table_key k2;\n+     const void * k1;\n+     const void * k2;\n {\n   tree t1;\n   tree t2;\n@@ -5604,7 +5518,7 @@ typename_compare (k1, k2)\n   d2 = TYPE_NAME (t2);\n \n   return (DECL_NAME (d1) == DECL_NAME (d2)\n-\t  && same_type_p (TYPE_CONTEXT (t1), TYPE_CONTEXT (t2))\n+\t  && TYPE_CONTEXT (t1) == TYPE_CONTEXT (t2)\n \t  && ((TREE_TYPE (t1) != NULL_TREE)\n \t      == (TREE_TYPE (t2) != NULL_TREE))\n \t  && same_type_p (TREE_TYPE (t1), TREE_TYPE (t2))\n@@ -5619,6 +5533,8 @@ typename_compare (k1, k2)\n \n    Returns the new TYPENAME_TYPE.  */\n \n+static GTY ((param_is (union tree_node))) htab_t typename_htab;\n+\n tree\n build_typename_type (context, name, fullname, base_type)\n      tree context;\n@@ -5628,16 +5544,12 @@ build_typename_type (context, name, fullname, base_type)\n {\n   tree t;\n   tree d;\n-  struct hash_entry *e;\n+  PTR *e;\n \n-  static struct hash_table ht;\n-\n-  if (!ht.table)\n+  if (typename_htab == NULL)\n     {\n-      static struct hash_table *h = &ht;\n-\n-      hash_table_init (&ht, &hash_newfunc, &typename_hash, &typename_compare);\n-      ggc_add_tree_hash_table_root (&h, 1);\n+      typename_htab = htab_create_ggc (61, &typename_hash, \n+\t\t\t\t       &typename_compare, NULL);\n     }\n \n   /* Build the TYPENAME_TYPE.  */\n@@ -5654,12 +5566,11 @@ build_typename_type (context, name, fullname, base_type)\n   DECL_ARTIFICIAL (d) = 1;\n \n   /* See if we already have this type.  */\n-  e = hash_lookup (&ht, t, /*create=*/false, /*copy=*/0);\n-  if (e)\n-    t = (tree) e->key;\n+  e = htab_find_slot (typename_htab, t, INSERT);\n+  if (*e)\n+    t = (tree) *e;\n   else\n-    /* Insert the type into the table.  */\n-    hash_lookup (&ht, t, /*create=*/true, /*copy=*/0);\n+    *e = t;\n \n   return t;\n }\n@@ -5890,7 +5801,7 @@ unqualified_namespace_lookup (name, flags, spacesp)\n   tree initial = current_decl_namespace ();\n   tree scope = initial;\n   tree siter;\n-  struct binding_level *level;\n+  struct cp_binding_level *level;\n   tree val = NULL_TREE;\n \n   if (spacesp)\n@@ -6238,7 +6149,7 @@ tree\n lookup_name_current_level (name)\n      tree name;\n {\n-  struct binding_level *b;\n+  struct cp_binding_level *b;\n   tree t = NULL_TREE;\n \n   b = current_binding_level;\n@@ -6284,7 +6195,7 @@ lookup_type_current_level (name)\n   if (REAL_IDENTIFIER_TYPE_VALUE (name) != NULL_TREE\n       && REAL_IDENTIFIER_TYPE_VALUE (name) != global_type_node)\n     {\n-      struct binding_level *b = current_binding_level;\n+      struct cp_binding_level *b = current_binding_level;\n       while (1)\n \t{\n \t  if (purpose_member (name, b->type_shadowed))\n@@ -6476,10 +6387,6 @@ cxx_init_decl_processing ()\n   /* Fill in back-end hooks.  */\n   lang_missing_noreturn_ok_p = &cp_missing_noreturn_ok_p;\n \n-  cp_parse_init ();\n-  init_decl2 ();\n-  init_pt ();\n-\n   /* Create the global variables.  */\n   push_to_top_level ();\n \n@@ -6554,9 +6461,6 @@ cxx_init_decl_processing ()\n   boolean_true_node = build_int_2 (1, 0);\n   TREE_TYPE (boolean_true_node) = boolean_type_node;\n \n-  signed_size_zero_node = build_int_2 (0, 0);\n-  TREE_TYPE (signed_size_zero_node) = make_signed_type (TYPE_PRECISION (sizetype));\n-\n   empty_except_spec = build_tree_list (NULL_TREE, NULL_TREE);\n \n #if 0\n@@ -6666,36 +6570,6 @@ cxx_init_decl_processing ()\n      say -fwritable-strings?  */\n   if (flag_writable_strings)\n     flag_const_strings = 0;\n-\n-  /* Add GC roots for all of our global variables.  */\n-  ggc_add_tree_root (c_global_trees, ARRAY_SIZE (c_global_trees));\n-  ggc_add_tree_root (cp_global_trees, ARRAY_SIZE (cp_global_trees));\n-  ggc_add_tree_root (&integer_three_node, 1);\n-  ggc_add_tree_root (&integer_two_node, 1);\n-  ggc_add_tree_root (&signed_size_zero_node, 1);\n-  ggc_add_tree_root (&size_one_node, 1);\n-  ggc_add_tree_root (&size_zero_node, 1);\n-  ggc_add_root (&global_binding_level, 1, sizeof global_binding_level,\n-\t\tmark_binding_level);\n-  ggc_add_root (&scope_chain, 1, sizeof scope_chain, &mark_saved_scope);\n-  ggc_add_tree_root (&static_ctors, 1);\n-  ggc_add_tree_root (&static_dtors, 1);\n-  ggc_add_tree_root (&lastiddecl, 1);\n-\n-  ggc_add_tree_root (&last_function_parms, 1);\n-  ggc_add_tree_root (&error_mark_list, 1);\n-\n-  ggc_add_tree_root (&global_namespace, 1);\n-  ggc_add_tree_root (&global_type_node, 1);\n-  ggc_add_tree_root (&anonymous_namespace_name, 1);\n-\n-  ggc_add_tree_root (&got_object, 1);\n-  ggc_add_tree_root (&got_scope, 1);\n-\n-  ggc_add_tree_root (&current_lang_name, 1);\n-  ggc_add_tree_root (&static_aggregates, 1);\n-  ggc_add_tree_root (&free_bindings, 1);\n-  ggc_add_tree_root (&incomplete_vars, 1);\n }\n \n /* Generate an initializer for a function naming variable from\n@@ -8017,7 +7891,7 @@ maybe_inject_for_scope_var (decl)\n \n   if (current_binding_level->is_for_scope)\n     {\n-      struct binding_level *outer\n+      struct cp_binding_level *outer\n \t= current_binding_level->level_chain;\n \n       /* Check to see if the same name is already bound at the outer\n@@ -10097,7 +9971,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \n   if (decl_context == NORMAL && !toplevel_bindings_p ())\n     {\n-      struct binding_level *b = current_binding_level;\n+      struct cp_binding_level *b = current_binding_level;\n       current_binding_level = b->level_chain;\n       if (current_binding_level != 0 && toplevel_bindings_p ())\n \tdecl_context = PARM;\n@@ -12804,7 +12678,7 @@ xref_tag (code_type_node, name, globalize)\n   enum tag_types tag_code;\n   enum tree_code code;\n   register tree ref, t;\n-  struct binding_level *b = current_binding_level;\n+  struct cp_binding_level *b = current_binding_level;\n   tree attributes = NULL_TREE;\n   tree context = NULL_TREE;\n \n@@ -13000,14 +12874,14 @@ xref_tag (code_type_node, name, globalize)\n \t}\n       else\n \t{\n-\t  struct binding_level *old_b = class_binding_level;\n+\t  struct cp_binding_level *old_b = class_binding_level;\n \n \t  ref = make_aggr_type (code);\n \t  TYPE_CONTEXT (ref) = context;\n \n #ifdef NONNESTED_CLASSES\n \t  /* Class types don't nest the way enums do.  */\n-\t  class_binding_level = (struct binding_level *)0;\n+\t  class_binding_level = (struct cp_binding_level *)0;\n #endif\n \t  pushtag (name, ref, globalize);\n \t  class_binding_level = old_b;\n@@ -13239,7 +13113,7 @@ start_enum (name)\n      tree name;\n {\n   register tree enumtype = NULL_TREE;\n-  struct binding_level *b = current_binding_level;\n+  struct cp_binding_level *b = current_binding_level;\n \n   /* If this is the real definition for a previous forward reference,\n      fill in the contents in the same object that used to be the\n@@ -13586,7 +13460,7 @@ start_function (declspecs, declarator, attrs, flags)\n   extern int have_extern_spec;\n   extern int used_extern_spec;\n   int doing_friend = 0;\n-  struct binding_level *bl;\n+  struct cp_binding_level *bl;\n   tree current_function_parms;\n \n   /* Sanity check.  */\n@@ -13810,12 +13684,8 @@ start_function (declspecs, declarator, attrs, flags)\n \n   /* If we are (erroneously) defining a function that we have already\n      defined before, wipe out what we knew before.  */\n-  if (!DECL_PENDING_INLINE_P (decl1)\n-      && DECL_SAVED_FUNCTION_DATA (decl1))\n-    {\n-      free (DECL_SAVED_FUNCTION_DATA (decl1));\n-      DECL_SAVED_FUNCTION_DATA (decl1) = NULL;\n-    }\n+  if (!DECL_PENDING_INLINE_P (decl1))\n+    DECL_SAVED_FUNCTION_DATA (decl1) = NULL;\n \n   if (ctype && !doing_friend && !DECL_STATIC_FUNCTION_P (decl1))\n     {\n@@ -14024,17 +13894,17 @@ static void\n save_function_data (decl)\n      tree decl;\n {\n-  struct cp_language_function *f;\n+  struct language_function *f;\n \n   /* Save the language-specific per-function data so that we can\n      get it back when we really expand this function.  */\n   my_friendly_assert (!DECL_PENDING_INLINE_P (decl),\n \t\t      19990908);\n \n   /* Make a copy.  */\n-  f = ((struct cp_language_function *)\n-       xmalloc (sizeof (struct cp_language_function)));\n-  memcpy (f, cp_function_chain, sizeof (struct cp_language_function));\n+  f = ((struct language_function *)\n+       ggc_alloc (sizeof (struct language_function)));\n+  memcpy (f, cp_function_chain, sizeof (struct language_function));\n   DECL_SAVED_FUNCTION_DATA (decl) = f;\n \n   /* Clear out the bits we don't need.  */\n@@ -14105,7 +13975,6 @@ begin_destructor_body ()\n      appropriately, so we just assume that we always need to\n      initialize the vtables.)  */\n   finish_if_stmt_cond (boolean_true_node, if_stmt);\n-  current_vcalls_possible_p = &IF_COND (if_stmt);\n \n   compound_stmt = begin_compound_stmt (/*has_no_scope=*/0);\n \n@@ -14688,10 +14557,10 @@ void\n cxx_push_function_context (f)\n      struct function *f;\n {\n-  struct cp_language_function *p\n-    = ((struct cp_language_function *)\n-       xcalloc (1, sizeof (struct cp_language_function)));\n-  f->language = (struct language_function *) p;\n+  struct language_function *p\n+    = ((struct language_function *)\n+       ggc_alloc_cleared (sizeof (struct language_function)));\n+  f->language = p;\n \n   /* It takes an explicit call to expand_body to generate RTL for a\n      function.  */\n@@ -14709,137 +14578,27 @@ void\n cxx_pop_function_context (f)\n      struct function *f;\n {\n-  if (f->language)\n-    {\n-      struct cp_language_function *cp =\n-\t(struct cp_language_function *) f->language;\n-      if (cp->x_local_names)\n-\tVARRAY_FREE (cp->x_local_names);\n-      free (f->language);\n-    }\n   f->language = 0;\n }\n \n-/* Mark P for GC.  */\n-\n-static void\n-mark_lang_function (p)\n-     struct cp_language_function *p;\n-{\n-  if (!p)\n-    return;\n-\n-  mark_c_language_function (&p->base);\n-\n-  ggc_mark_tree (p->x_dtor_label);\n-  ggc_mark_tree (p->x_current_class_ptr);\n-  ggc_mark_tree (p->x_current_class_ref);\n-  ggc_mark_tree (p->x_eh_spec_block);\n-  ggc_mark_tree_varray (p->x_local_names);\n-\n-  mark_named_label_lists (&p->x_named_labels, &p->x_named_label_uses);\n-  mark_binding_level (&p->bindings);\n-  mark_pending_inlines (&p->unparsed_inlines);\n-}\n+/* Return which tree structure is used by T, or TS_CP_GENERIC if T is\n+   one of the language-independent trees.  */\n \n-/* Mark the language-specific data in F for GC.  */\n-\n-void\n-cxx_mark_function_context (f)\n-     struct function *f;\n-{\n-  mark_lang_function ((struct cp_language_function *) f->language);\n-}\n-\n-void\n-cxx_mark_tree (t)\n-     tree t;\n+enum cp_tree_node_structure_enum\n+cp_tree_node_structure (t)\n+     union lang_tree_node *t;\n {\n-  enum tree_code code = TREE_CODE (t);\n-  if (code == IDENTIFIER_NODE)\n+  switch (TREE_CODE (&t->generic))\n     {\n-      struct lang_identifier *li = (struct lang_identifier *) t;\n-      struct lang_id2 *li2 = li->x;\n-      ggc_mark_tree (li->namespace_bindings);\n-      ggc_mark_tree (li->bindings);\n-      ggc_mark_tree (li->class_value);\n-      ggc_mark_tree (li->class_template_info);\n-\n-      if (li2)\n-\t{\n-\t  ggc_mark_tree (li2->label_value);\n-\t  ggc_mark_tree (li2->implicit_decl);\n-\t  ggc_mark_tree (li2->error_locus);\n-\t}\n-    }\n-  else if (code == CPLUS_BINDING)\n-    {\n-      if (BINDING_HAS_LEVEL_P (t))\n-\tmark_binding_level (&BINDING_LEVEL (t));\n-      else\n-\tggc_mark_tree (BINDING_SCOPE (t));\n-      ggc_mark_tree (BINDING_VALUE (t));\n-    }\n-  else if (code == OVERLOAD)\n-    ggc_mark_tree (OVL_FUNCTION (t));\n-  else if (code == TEMPLATE_PARM_INDEX)\n-    ggc_mark_tree (TEMPLATE_PARM_DECL (t));\n-  else if (TREE_CODE_CLASS (code) == 'd')\n-    {\n-      struct lang_decl *ld = DECL_LANG_SPECIFIC (t);\n-\n-      if (ld)\n-\t{\n-\t  ggc_mark (ld);\n-\t  c_mark_lang_decl (&ld->decl_flags.base);\n-\t  if (!DECL_GLOBAL_CTOR_P (t)\n-\t      && !DECL_GLOBAL_DTOR_P (t)\n-\t      && !DECL_THUNK_P (t)\n-\t      && !DECL_DISCRIMINATOR_P (t))\n-\t    ggc_mark_tree (ld->decl_flags.u2.access);\n-\t  else if (DECL_THUNK_P (t))\n-\t    ggc_mark_tree (ld->decl_flags.u2.vcall_offset);\n-\t  if (TREE_CODE (t) != NAMESPACE_DECL)\n-\t    ggc_mark_tree (ld->decl_flags.u.template_info);\n-\t  else\n-\t    mark_binding_level (&NAMESPACE_LEVEL (t));\n-\t  if (CAN_HAVE_FULL_LANG_DECL_P (t))\n-\t    {\n-\t      ggc_mark_tree (ld->befriending_classes);\n-\t      ggc_mark_tree (ld->context);\n-\t      ggc_mark_tree (ld->cloned_function);\n-\t      if (TREE_CODE (t) == TYPE_DECL)\n-\t\tggc_mark_tree (ld->u.sorted_fields);\n-\t      else if (TREE_CODE (t) == FUNCTION_DECL\n-\t\t       && !DECL_PENDING_INLINE_P (t))\n-\t\tmark_lang_function (DECL_SAVED_FUNCTION_DATA (t));\n-\t    }\n-\t}\n-    }\n-  else if (TREE_CODE_CLASS (code) == 't')\n-    {\n-      struct lang_type *lt = TYPE_LANG_SPECIFIC (t);\n-\n-      if (lt && !(TREE_CODE (t) == POINTER_TYPE\n-\t\t  && TREE_CODE (TREE_TYPE (t)) == METHOD_TYPE))\n-\t{\n-\t  ggc_mark (lt);\n-\t  ggc_mark_tree (lt->primary_base);\n-\t  ggc_mark_tree (lt->vfields);\n-\t  ggc_mark_tree (lt->vbases);\n-\t  ggc_mark_tree (lt->tags);\n-\t  ggc_mark_tree (lt->size);\n-\t  ggc_mark_tree (lt->pure_virtuals);\n-\t  ggc_mark_tree (lt->friend_classes);\n-\t  ggc_mark_tree (lt->rtti);\n-\t  ggc_mark_tree (lt->methods);\n-\t  ggc_mark_tree (lt->template_info);\n-\t  ggc_mark_tree (lt->befriending_classes);\n-\t}\n-      else if (lt)\n-\t/* In the case of pointer-to-member function types, the\n-\t   TYPE_LANG_SPECIFIC is really just a tree.  */\n-\tggc_mark_tree ((tree) lt);\n+    case DEFAULT_ARG:\t\treturn TS_CP_IDENTIFIER;\n+    case IDENTIFIER_NODE:\treturn TS_CP_IDENTIFIER;\n+    case CPLUS_BINDING:\t\treturn TS_CP_BINDING;\n+    case OVERLOAD:\t\treturn TS_CP_OVERLOAD;\n+    case TEMPLATE_PARM_INDEX:\treturn TS_CP_TPI;\n+    case PTRMEM_CST:\t\treturn TS_CP_PTRMEM;\n+    case WRAPPER:\t\treturn TS_CP_WRAPPER;\n+    case SRCLOC:\t\treturn TS_CP_SRCLOC;\n+    default:\t\t\treturn TS_CP_GENERIC;\n     }\n }\n \n@@ -14869,3 +14628,6 @@ cp_missing_noreturn_ok_p (decl)\n   /* A missing noreturn is ok for the `main' function.  */\n   return DECL_MAIN_P (decl);\n }\n+\n+#include \"gt-cp-decl.h\"\n+#include \"gtype-cp.h\""}, {"sha": "eeac80f29ad4afb3f0bce332bca649dacf445eaf", "filename": "gcc/cp/decl.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fcp%2Fdecl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fcp%2Fdecl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.h?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -36,13 +36,13 @@ extern tree grokdeclarator PARAMS ((tree, tree, enum decl_context, int,\n \n /* Parsing a function declarator leaves a list of parameter names\n    or a chain or parameter decls here.  */\n-extern tree last_function_parms;\n+extern GTY(()) tree last_function_parms;\n \n /* A list of objects which have constructors or destructors\n    which reside in the global scope.  The decl is stored in\n    the TREE_VALUE slot and the initializer is stored\n    in the TREE_PURPOSE slot.  */\n-extern tree static_aggregates;\n+extern GTY(()) tree static_aggregates;\n \n #ifdef DEBUG_CP_BINDING_LEVELS\n /* Purely for debugging purposes.  */"}, {"sha": "c63c48b67bcd8141fa2d517c9d790a1e0543e8f6", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -95,13 +95,13 @@ static tree get_guard_bits PARAMS ((tree));\n /* A list of static class variables.  This is needed, because a\n    static class variable can be declared inside the class without\n    an initializer, and then initialized, statically, outside the class.  */\n-static varray_type pending_statics;\n+static GTY(()) varray_type pending_statics;\n #define pending_statics_used \\\n   (pending_statics ? pending_statics->elements_used : 0)\n \n /* A list of functions which were declared inline, but which we\n    may need to emit outline anyway.  */\n-static varray_type deferred_fns;\n+static GTY(()) varray_type deferred_fns;\n #define deferred_fns_used \\\n   (deferred_fns ? deferred_fns->elements_used : 0)\n \n@@ -2712,6 +2712,7 @@ start_objects (method_type, initp)\n     DECL_GLOBAL_CTOR_P (current_function_decl) = 1;\n   else\n     DECL_GLOBAL_DTOR_P (current_function_decl) = 1;\n+  DECL_LANG_SPECIFIC (current_function_decl)->decl_flags.u2sel = 1;\n   GLOBAL_INIT_PRIORITY (current_function_decl) = initp;\n \n   body = begin_compound_stmt (/*has_no_scope=*/0);\n@@ -2768,17 +2769,17 @@ finish_objects (method_type, initp, body)\n #define SSDF_IDENTIFIER \"__static_initialization_and_destruction\"\n \n /* The declaration for the __INITIALIZE_P argument.  */\n-static tree initialize_p_decl;\n+static GTY(()) tree initialize_p_decl;\n \n /* The declaration for the __PRIORITY argument.  */\n-static tree priority_decl;\n+static GTY(()) tree priority_decl;\n \n /* The declaration for the static storage duration function.  */\n-static tree ssdf_decl;\n+static GTY(()) tree ssdf_decl;\n \n /* All the static storage duration functions created in this\n    translation unit.  */\n-static varray_type ssdf_decls;\n+static GTY(()) varray_type ssdf_decls;\n \n /* A map from priority levels to information about that priority\n    level.  There may be many such levels, so efficient lookup is\n@@ -5280,15 +5281,4 @@ handle_class_head (aggr, scope, id, defn_p, new_type_p)\n   return decl;\n }\n \n-/* Initialize decl2.c.  */\n-\n-void\n-init_decl2 ()\n-{\n-  ggc_add_tree_varray_root (&deferred_fns, 1);\n-  ggc_add_tree_varray_root (&pending_statics, 1);\n-  ggc_add_tree_varray_root (&ssdf_decls, 1);\n-  ggc_add_tree_root (&ssdf_decl, 1);\n-  ggc_add_tree_root (&priority_decl, 1);\n-  ggc_add_tree_root (&initialize_p_decl, 1);\n-}\n+#include \"gt-cp-decl2.h\""}, {"sha": "dad7df6d3b0c94c68d569637ca4f18165f2decdb", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -1434,6 +1434,12 @@ retrofit_lang_decl (t)\n \n   ld = (struct lang_decl *) ggc_alloc_cleared (size);\n \n+  ld->decl_flags.can_be_full = CAN_HAVE_FULL_LANG_DECL_P (t) ? 1 : 0;\n+  ld->decl_flags.u1sel = TREE_CODE (t) == NAMESPACE_DECL ? 1 : 0;\n+  ld->decl_flags.u2sel = 0;\n+  if (ld->decl_flags.can_be_full)\n+    ld->u.f.u3sel = TREE_CODE (t) == FUNCTION_DECL ? 1 : 0;\n+\n   DECL_LANG_SPECIFIC (t) = ld;\n   if (current_lang_name == lang_name_cplusplus)\n     SET_DECL_LANGUAGE (t, lang_cplusplus);\n@@ -1498,7 +1504,10 @@ copy_lang_type (node)\n   if (! TYPE_LANG_SPECIFIC (node))\n     return;\n \n-  size = sizeof (struct lang_type);\n+  if (TYPE_LANG_SPECIFIC (node)->u.h.is_lang_type_class)\n+    size = sizeof (struct lang_type);\n+  else\n+    size = sizeof (struct lang_type_ptrmem);\n   lt = (struct lang_type *) ggc_alloc (size);\n   memcpy (lt, TYPE_LANG_SPECIFIC (node), size);\n   TYPE_LANG_SPECIFIC (node) = lt;\n@@ -1538,6 +1547,7 @@ cxx_make_type (code)\n \t    ggc_alloc_cleared (sizeof (struct lang_type)));\n \n       TYPE_LANG_SPECIFIC (t) = pi;\n+      pi->u.c.h.is_lang_type_class = 1;\n \n #ifdef GATHER_STATISTICS\n       tree_node_counts[(int)lang_type] += 1;"}, {"sha": "15de16866b72cb0dfd009f22ada14f37215a2ed1", "filename": "gcc/cp/lex.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fcp%2Flex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fcp%2Flex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.h?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -68,15 +68,15 @@ typedef unsigned long RID_BIT_TYPE;\t/* assumed at least 32 bits */\n    yylex must look this up to detect typedefs, which get token type TYPENAME,\n    so it is left around in case the identifier is not a typedef but is\n    used in a context which makes it a reference to a variable.  */\n-extern tree lastiddecl;\n+extern GTY(()) tree lastiddecl;\n \n /* Back-door communication channel to the lexer.  */\n extern int looking_for_typename;\n extern int looking_for_template;\n \n /* Tell the lexer where to look for names.  */\n-extern tree got_scope;\n-extern tree got_object;\n+extern GTY(()) tree got_scope;\n+extern GTY(()) tree got_object;\n \n /* Pending language change.\n    Positive is push count, negative is pop count.  */"}, {"sha": "12888ace7d8ec5bc1a87a598b0e5a49ae1cd745e", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -2166,6 +2166,7 @@ write_substitution (seq_id)\n static inline void\n start_mangling ()\n {\n+  VARRAY_TREE_INIT (G.substitutions, 1, \"mangling substitutions\");\n   obstack_free (&G.name_obstack, obstack_base (&G.name_obstack));\n }\n \n@@ -2175,7 +2176,7 @@ static inline const char *\n finish_mangling ()\n {\n   /* Clear all the substitutions.  */\n-  VARRAY_POP_ALL (G.substitutions);\n+  G.substitutions = 0;\n \n   /* Null-terminate the string.  */\n   write_char ('\\0');\n@@ -2189,7 +2190,6 @@ void\n init_mangle ()\n {\n   gcc_obstack_init (&G.name_obstack);\n-  VARRAY_TREE_INIT (G.substitutions, 1, \"mangling substitutions\");\n \n   /* Cache these identifiers for quick comparison when checking for\n      standard substitutions.  */"}, {"sha": "e815addccee720ba62213eb41256b2394683cca2", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 29, "deletions": 36, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -103,21 +103,21 @@ int have_extern_spec;\n int used_extern_spec;\n \n /* List of types and structure classes of the current declaration.  */\n-static tree current_declspecs;\n+static GTY(()) tree current_declspecs;\n \n /* List of prefix attributes in effect.\n    Prefix attributes are parsed by the reserved_declspecs and declmods\n    rules.  They create a list that contains *both* declspecs and attrs.  */\n /* ??? It is not clear yet that all cases where an attribute can now appear in\n    a declspec list have been updated.  */\n-static tree prefix_attributes;\n+static GTY(()) tree prefix_attributes;\n \n /* When defining an enumeration, this is the type of the enumeration.  */\n-static tree current_enum_type;\n+static GTY(()) tree current_enum_type;\n \n /* When parsing a conversion operator name, this is the scope of the\n    operator itself.  */\n-static tree saved_scopes;\n+static GTY(()) tree saved_scopes;\n \n static tree empty_parms PARAMS ((void));\n static tree parse_decl0 PARAMS ((tree, tree, tree, tree, int));\n@@ -263,19 +263,11 @@ check_class_key (key, aggr)\n \t     : key == record_type_node ? \"struct\" : \"class\", aggr);\n }\n \n-void\n-cp_parse_init ()\n-{\n-  ggc_add_tree_root (&current_declspecs, 1);\n-  ggc_add_tree_root (&prefix_attributes, 1);\n-  ggc_add_tree_root (&current_enum_type, 1);\n-  ggc_add_tree_root (&saved_scopes, 1);\n-}\n %}\n \n %start program\n \n-%union {\n+%union { GTY(())\n   long itype; \n   tree ttype; \n   char *strtype; \n@@ -388,7 +380,7 @@ cp_parse_init ()\n %type <ttype> paren_expr_or_null nontrivial_exprlist SELFNAME\n %type <ttype> expr_no_commas expr_no_comma_rangle\n %type <ttype> cast_expr unary_expr primary STRING\n-%type <ttype> reserved_declspecs boolean.literal\n+%type <ttype> reserved_declspecs boolean_literal\n %type <ttype> reserved_typespecquals\n %type <ttype> SCSPEC TYPESPEC CV_QUALIFIER maybe_cv_qualifier\n %type <ttype> init initlist maybeasm maybe_init defarg defarg1\n@@ -436,13 +428,13 @@ cp_parse_init ()\n %token <ttype> PRE_PARSED_CLASS_DECL DEFARG DEFARG_MARKER\n %token <pi> PRE_PARSED_FUNCTION_DECL \n %type <ttype> component_constructor_declarator\n-%type <ttype> fn.def2 return_id constructor_declarator\n-%type <ttype> .begin_function_body\n+%type <ttype> fn_def2 return_id constructor_declarator\n+%type <ttype> begin_function_body_\n %type <ttype> class_head class_head_apparent_template\n %type <ftype> class_head_decl class_head_defn\n %type <ttype> base_class_list\n %type <ttype> base_class_access_list\n-%type <ttype> base_class maybe_base_class_list base_class.1\n+%type <ttype> base_class maybe_base_class_list base_class_1\n %type <ttype> exception_specification_opt ansi_raise_identifier ansi_raise_identifiers\n %type <ttype> operator_name\n %type <ttype> object aggr\n@@ -470,7 +462,7 @@ cp_parse_init ()\n %token TYPENAME_DEFN IDENTIFIER_DEFN PTYPENAME_DEFN\n %type <ttype> identifier_defn IDENTIFIER_DEFN TYPENAME_DEFN PTYPENAME_DEFN\n %type <ttype> handler_args\n-%type <ttype> self_template_type .finish_template_type\n+%type <ttype> self_template_type finish_template_type_\n \n %token NSNAME\n %type <ttype> NSNAME\n@@ -815,7 +807,7 @@ eat_saved_input:\n    mem-initializer-list, so we open one there and suppress the one that\n    actually corresponds to the curly braces.  */\n function_body:\n-\t  .begin_function_body ctor_initializer_opt save_lineno '{'\n+\t  begin_function_body_ ctor_initializer_opt save_lineno '{'\n \t\t{ $<ttype>$ = begin_compound_stmt (/*has_no_scope=*/1); }\n \t  compstmtend \n                 {\n@@ -909,7 +901,7 @@ component_constructor_declarator:\n \n /* more C++ complexity.  See component_decl for a comment on the\n    reduce/reduce conflict introduced by these rules.  */\n-fn.def2:\n+fn_def2:\n \t  declmods component_constructor_declarator\n \t\t{ $$ = parse_method ($2, $1.t, $1.lookups);\n \t\t rest_of_mdef:\n@@ -963,7 +955,7 @@ base_init:\n \t\t}\n \t;\n \n-.begin_function_body:\n+begin_function_body_:\n \t  /* empty */\n \t\t{\n \t\t  $$ = begin_function_body ();\n@@ -1095,28 +1087,28 @@ end_explicit_instantiation:\n \n template_type:\n \t  PTYPENAME '<' template_arg_list_opt template_close_bracket\n-\t    .finish_template_type\n+\t    finish_template_type_\n                 { $$ = $5; }\n \t| TYPENAME  '<' template_arg_list_opt template_close_bracket\n-\t    .finish_template_type\n+\t    finish_template_type_\n                 { $$ = $5; }\n \t| self_template_type\n \t;\n \n apparent_template_type:\n \t  template_type\n \t| identifier '<' template_arg_list_opt '>'\n-\t    .finish_template_type\n+\t    finish_template_type_\n \t\t{ $$ = $5; }\n         ;\n \n self_template_type:\n \t  SELFNAME  '<' template_arg_list_opt template_close_bracket\n-\t    .finish_template_type\n+\t    finish_template_type_\n                 { $$ = $5; }\n \t;\n \n-.finish_template_type:\n+finish_template_type_:\n                 { \n \t\t  if (yychar == YYEMPTY)\n \t\t    yychar = YYLEX;\n@@ -1615,7 +1607,7 @@ primary:\n \t\t    $$ = finish_id_expr ($1);\n \t\t}\t\t\n \t| CONSTANT\n-\t| boolean.literal\n+\t| boolean_literal\n \t| STRING\n \t\t{\n \t\t  $$ = fix_string_type ($$);\n@@ -1813,7 +1805,7 @@ delete:\n \t\t{ got_scope = NULL_TREE; $$ = 1; }\n \t;\n \n-boolean.literal:\n+boolean_literal:\n \t  CXX_TRUE\n \t\t{ $$ = boolean_true_node; }\n \t| CXX_FALSE\n@@ -2372,7 +2364,6 @@ structsp:\n \t\t}\n \t  pending_inlines\n                 {\n-\t\t  finish_inline_definitions ();\n \t\t  $$.t = $<ttype>8;\n \t\t  $$.new_type_flag = 1; \n \t\t}\n@@ -2550,13 +2541,13 @@ base_class_list:\n \t;\n \n base_class:\n-\t  base_class.1\n+\t  base_class_1\n \t\t{ $$ = finish_base_specifier (access_default_node, $1); }\n-\t| base_class_access_list see_typename base_class.1\n+\t| base_class_access_list see_typename base_class_1\n                 { $$ = finish_base_specifier ($1, $3); }\n \t;\n \n-base_class.1:\n+base_class_1:\n \t  typename_sub\n \t\t{ if (!TYPE_P ($$))\n \t\t    $$ = error_mark_node; }\n@@ -2632,13 +2623,13 @@ component_decl:\n \t\t  yyungetc ('}', 0); }\n \t/* C++: handle constructors, destructors and inline functions */\n \t/* note that INLINE is like a TYPESPEC */\n-\t| fn.def2 ':' /* base_init compstmt */\n+\t| fn_def2 ':' /* base_init compstmt */\n \t\t{ $$ = finish_method ($$); }\n-\t| fn.def2 TRY /* base_init compstmt */\n+\t| fn_def2 TRY /* base_init compstmt */\n \t\t{ $$ = finish_method ($$); }\n-\t| fn.def2 RETURN_KEYWORD /* base_init compstmt */\n+\t| fn_def2 RETURN_KEYWORD /* base_init compstmt */\n \t\t{ $$ = finish_method ($$); }\n-\t| fn.def2 '{' /* nodecls compstmt */\n+\t| fn_def2 '{' /* nodecls compstmt */\n \t\t{ $$ = finish_method ($$); }\n \t| ';'\n \t\t{ $$ = NULL_TREE; }\n@@ -4026,3 +4017,5 @@ free_parser_stacks ()\n       free (malloced_yyvs);\n     }\n }\n+\n+#include \"gt-cp-parse.h\""}, {"sha": "873e5a3f1416deb6d0670c63fdd0cafe797e05d0", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -56,17 +56,17 @@ extern struct obstack permanent_obstack;\n    the instantiate request occurred; the TREE_VALUE is a either a DECL\n    (for a function or static data member), or a TYPE (for a class)\n    indicating what we are hoping to instantiate.  */\n-static tree pending_templates;\n+static GTY(()) tree pending_templates;\n static tree last_pending_template;\n \n int processing_template_parmlist;\n static int template_header_count;\n \n-static tree saved_trees;\n-static varray_type inline_parm_levels;\n+static GTY(()) tree saved_trees;\n+static GTY(()) varray_type inline_parm_levels;\n static size_t inline_parm_levels_used;\n \n-static tree current_tinst_level;\n+static GTY(()) tree current_tinst_level;\n \n /* A map from local variable declarations in the body of the template\n    presently being instantiated to the corresponding instantiated\n@@ -170,16 +170,6 @@ static tree copy_default_args_to_explicit_spec_1 PARAMS ((tree, tree));\n static void copy_default_args_to_explicit_spec PARAMS ((tree));\n static int invalid_nontype_parm_type_p PARAMS ((tree, tsubst_flags_t));\n \n-/* Called once to initialize pt.c.  */\n-\n-void\n-init_pt ()\n-{\n-  ggc_add_tree_root (&pending_templates, 1);\n-  ggc_add_tree_root (&saved_trees, 1);\n-  ggc_add_tree_root (&current_tinst_level, 1);\n-}\n-\n /* Do any processing required when DECL (a member template declaration\n    using TEMPLATE_PARAMETERS as its innermost parameter list) is\n    finished.  Returns the TEMPLATE_DECL corresponding to DECL, unless\n@@ -10426,3 +10416,5 @@ invalid_nontype_parm_type_p (type, complain)\n               type);\n   return 1;\n }\n+\n+#include \"gt-cp-pt.h\""}, {"sha": "6aacebfdd604171b5e65d3628a76b5caaeeb1ed8", "filename": "gcc/cp/repo.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fcp%2Frepo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fcp%2Frepo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frepo.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -42,8 +42,8 @@ static void open_repo_file PARAMS ((const char *));\n static char *afgets PARAMS ((FILE *));\n static void reopen_repo_file_for_write PARAMS ((void));\n \n-static tree pending_repo;\n-static tree original_repo;\n+static GTY(()) tree pending_repo;\n+static GTY(()) tree original_repo;\n static char *repo_name;\n static FILE *repo_file;\n \n@@ -320,8 +320,6 @@ init_repo (filename)\n   if (! flag_use_repository)\n     return;\n \n-  ggc_add_tree_root (&pending_repo, 1);\n-  ggc_add_tree_root (&original_repo, 1);\n   gcc_obstack_init (&temporary_obstack);\n \n   open_repo_file (filename);\n@@ -458,3 +456,5 @@ finish_repo ()\n   if (repo_file)\n     fclose (repo_file);\n }\n+\n+#include \"gt-cp-repo.h\""}, {"sha": "9617796dfbde36aa241c7dcf5b09fa360c9c07e1", "filename": "gcc/cp/search.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -31,6 +31,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"flags.h\"\n #include \"rtl.h\"\n #include \"output.h\"\n+#include \"ggc.h\"\n #include \"toplev.h\"\n \n #define obstack_chunk_alloc xmalloc\n@@ -1673,9 +1674,6 @@ bfs_walk (binfo, fn, qfn, data)\n \t}\n     }\n \n-  /* Clean up.  */\n-  VARRAY_FREE (bfs_bases);\n-\n   return rval;\n }\n "}, {"sha": "bbc22037ecef153ace1943ba945d3d39b3cdf8b1", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 4, "deletions": 17, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -97,7 +97,7 @@ stmt_tree\n current_stmt_tree ()\n {\n   return (cfun \n-\t  ? &cfun->language->x_stmt_tree \n+\t  ? &cfun->language->base.x_stmt_tree \n \t  : &scope_chain->x_stmt_tree);\n }\n \n@@ -109,7 +109,7 @@ int\n anon_aggr_type_p (node)\n      tree node;\n {\n-  return (CLASS_TYPE_P (node) && TYPE_LANG_SPECIFIC(node)->anon_aggr);\n+  return ANON_AGGR_TYPE_P (node);\n }\n \n /* Finish a scope.  */\n@@ -1131,7 +1131,7 @@ finish_mem_initializers (init_list)\n tree *\n current_scope_stmt_stack ()\n {\n-  return &cfun->language->x_scope_stmt_stack;\n+  return &cfun->language->base.x_scope_stmt_stack;\n }\n \n /* Finish a parenthesized expression EXPR.  */\n@@ -1882,16 +1882,6 @@ begin_inline_definitions ()\n     do_pending_inlines ();\n }\n \n-/* Finish processing the inline function definitions cached during the\n-   processing of a class definition.  */\n-\n-void\n-finish_inline_definitions ()\n-{\n-  if (current_class_type == NULL_TREE)\n-    clear_inline_text_obstack (); \n-}\n-\n /* Finish processing the declaration of a member class template\n    TYPES whose template parameters are given by PARMS.  */\n \n@@ -2475,10 +2465,7 @@ genrtl_start_function (fn)\n          function; we need the named return value info for\n          cp_copy_res_decl_for_inlining.  */\n       if (! DECL_INLINE (fn))\n-\t{\n-\t  free (DECL_SAVED_FUNCTION_DATA (fn));\n-\t  DECL_SAVED_FUNCTION_DATA (fn) = NULL;\n-\t}\n+\tDECL_SAVED_FUNCTION_DATA (fn) = NULL;\n     }\n \n   /* Keep track of how many functions we're presently expanding.  */"}, {"sha": "d56f6117392ccb18dc8ae14d564089e0c429a8c9", "filename": "gcc/cp/spew.c", "status": "modified", "additions": 148, "deletions": 155, "changes": 303, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fcp%2Fspew.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fcp%2Fspew.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fspew.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -50,12 +50,12 @@ Boston, MA 02111-1307, USA.  */\n    backtracking.  */\n \n /* fifo of tokens recognized and available to parser.  */\n-struct token\n+struct token GTY(())\n {\n   /* The values for YYCHAR will fit in a short.  */\n   short\t\tyychar;\n   unsigned int\tlineno;\n-  YYSTYPE\tyylval;\n+  YYSTYPE GTY ((desc (\"%1.yychar\"))) yylval;\n };\n \n /* Since inline methods can refer to text which has not yet been seen,\n@@ -68,34 +68,46 @@ struct token\n    This function's FUNCTION_DECL will have a bit set in its common so\n    that we know to watch out for it.  */\n \n-struct unparsed_text\n+#define TOKEN_CHUNK_SIZE 20\n+struct token_chunk GTY(())\n+{\n+  struct token_chunk *next;\n+  struct token toks[TOKEN_CHUNK_SIZE];\n+};\n+\n+struct unparsed_text GTY(())\n {\n   struct unparsed_text *next;\t/* process this one next */\n   tree decl;\t\t/* associated declaration */\n   const char *filename;\t/* name of file we were processing */\n   int lineno;\t\t/* line number we got the text from */\n   int interface;\t/* remembering interface_unknown and interface_only */\n \n-  struct token *pos;\t/* current position, when rescanning */\n-  struct token *limit;\t/* end of saved text */\n+  struct token_chunk * tokens; /* Start of the token list.  */\n+\n+  struct token_chunk *last_chunk; /* End of the token list.  */\n+  short last_pos;\t/* Number of tokens used in the last chunk of \n+\t\t\t   TOKENS. */\n+\n+  short cur_pos;\t/* Current token in 'cur_chunk', when rescanning.  */\n+  struct token_chunk *cur_chunk;  /* Current chunk, when rescanning.  */\n };\n \n /* Stack of state saved off when we return to an inline method or\n    default argument that has been stored for later parsing.  */\n-struct feed\n+struct feed GTY(())\n {\n   struct unparsed_text *input;\n   const char *filename;\n   int lineno;\n   int yychar;\n-  YYSTYPE yylval;\n+  YYSTYPE GTY ((desc (\"%1.yychar\"))) yylval;\n   int first_token;\n-  struct obstack token_obstack;\n+  struct obstack GTY ((skip (\"\"))) token_obstack;\n   struct feed *next;\n-};  \n+};\n \n-static struct obstack feed_obstack;\n-static struct feed *feed;\n+static GTY(()) struct feed *feed;\n \n static SPEW_INLINE void do_aggr PARAMS ((void));\n static SPEW_INLINE int identifier_type PARAMS ((tree));\n@@ -107,25 +119,32 @@ static int read_token PARAMS ((struct token *));\n \n static SPEW_INLINE int num_tokens PARAMS ((void));\n static SPEW_INLINE struct token *nth_token PARAMS ((int));\n-static SPEW_INLINE int add_token PARAMS ((struct token *));\n+static SPEW_INLINE int next_token PARAMS ((struct token *));\n static SPEW_INLINE int shift_token PARAMS ((void));\n static SPEW_INLINE void push_token PARAMS ((struct token *));\n static SPEW_INLINE void consume_token PARAMS ((void));\n static SPEW_INLINE int read_process_identifier PARAMS ((YYSTYPE *));\n \n static SPEW_INLINE void feed_input PARAMS ((struct unparsed_text *));\n-static SPEW_INLINE void snarf_block PARAMS ((const char *, int));\n+static SPEW_INLINE struct token * space_for_token \n+  PARAMS ((struct unparsed_text *t));\n+static SPEW_INLINE struct token * remove_last_token\n+  PARAMS ((struct unparsed_text *t));\n+static struct unparsed_text * alloc_unparsed_text\n+  PARAMS ((const char *fn, int li, tree decl, int interface));\n+\n+static void snarf_block PARAMS ((struct unparsed_text *t));\n static tree snarf_defarg PARAMS ((void));\n static int frob_id PARAMS ((int, int, tree *));\n \n /* The list of inline functions being held off until we reach the end of\n    the current class declaration.  */\n-static struct unparsed_text *pending_inlines;\n-static struct unparsed_text *pending_inlines_tail;\n+static GTY(()) struct unparsed_text *pending_inlines;\n+static GTY(()) struct unparsed_text *pending_inlines_tail;\n \n /* The list of previously-deferred inline functions currently being parsed.\n    This exists solely to be a GC root.  */\n-static struct unparsed_text *processing_these_inlines;\n+static GTY(()) struct unparsed_text *processing_these_inlines;\n \n static void begin_parsing_inclass_inline PARAMS ((struct unparsed_text *));\n \n@@ -151,13 +170,8 @@ extern int\tyychar;\t\t/*  the lookahead symbol\t\t*/\n extern YYSTYPE\tyylval;\t\t/*  the semantic value of the\t\t*/\n \t\t\t\t/*  lookahead symbol\t\t\t*/\n /* The token fifo lives in this obstack.  */\n-struct obstack token_obstack;\n-int first_token;\n-\n-/* Sometimes we need to save tokens for later parsing.  If so, they are\n-   stored on this obstack.  */\n-struct obstack inline_text_obstack;\n-char *inline_text_firstobj;\n+static struct obstack token_obstack;\n+static int first_token;\n \n /* When we see a default argument in a method declaration, we snarf it as\n    text using snarf_defarg.  When we get up to namespace scope, we then go\n@@ -168,35 +182,21 @@ char *inline_text_firstobj;\n    the TREE_TYPE is the current_class_type, TREE_VALUE is the FUNCTION_DECL,\n    and TREE_PURPOSE is the list unprocessed dependent functions.  */\n \n-static tree defarg_fns;     /* list of functions with unprocessed defargs */\n-static tree defarg_parm;    /* current default parameter */\n-static tree defarg_depfns;  /* list of unprocessed fns met during current fn. */\n-static tree defarg_fnsdone; /* list of fns with circular defargs */\n+/* list of functions with unprocessed defargs */\n+static GTY(()) tree defarg_fns;\n+/* current default parameter */\n+static GTY(()) tree defarg_parm;\n+/* list of unprocessed fns met during current fn. */\n+static GTY(()) tree defarg_depfns;\n+/* list of fns with circular defargs */\n+static GTY(()) tree defarg_fnsdone;\n \n /* Initialize obstacks. Called once, from cxx_init.  */\n \n void\n init_spew ()\n {\n-  gcc_obstack_init (&inline_text_obstack);\n-  inline_text_firstobj = (char *) obstack_alloc (&inline_text_obstack, 0);\n   gcc_obstack_init (&token_obstack);\n-  gcc_obstack_init (&feed_obstack);\n-  ggc_add_tree_root (&defarg_fns, 1);\n-  ggc_add_tree_root (&defarg_parm, 1);\n-  ggc_add_tree_root (&defarg_depfns, 1);\n-  ggc_add_tree_root (&defarg_fnsdone, 1);\n-\n-  ggc_add_root (&pending_inlines, 1, sizeof (struct unparsed_text *),\n-\t\tmark_pending_inlines);\n-  ggc_add_root (&processing_these_inlines, 1, sizeof (struct unparsed_text *),\n-\t\tmark_pending_inlines);\n-}\n-\n-void\n-clear_inline_text_obstack ()\n-{\n-  obstack_free (&inline_text_obstack, inline_text_firstobj);\n }\n \n /* Subroutine of read_token.  */\n@@ -270,8 +270,6 @@ yylexstring (t)\n \n       t->yylval.ttype = combine_strings (strings);\n       last_token_id = t->yylval.ttype;\n-\n-      VARRAY_FREE (strings);\n     }\n \n   /* We will have always read one token too many.  */\n@@ -396,10 +394,10 @@ feed_input (input)\n     abort ();\n #endif\n \n-  f = obstack_alloc (&feed_obstack, sizeof (struct feed));\n+  f = ggc_alloc (sizeof (struct feed));\n \n-  /* The token list starts just after the struct unparsed_text in memory.  */\n-  input->pos = (struct token *) (input + 1);\n+  input->cur_chunk = input->tokens;\n+  input->cur_pos = 0;\n \n #ifdef SPEW_DEBUG\n   if (spew_debug)\n@@ -439,48 +437,12 @@ end_input ()\n   token_obstack = f->token_obstack;\n   feed = f->next;\n \n-  obstack_free (&feed_obstack, f);\n-\n #ifdef SPEW_DEBUG\n   if (spew_debug)\n     fprintf (stderr, \"\\treturning to %s:%d\\n\", input_filename, lineno);\n #endif\n }\n \n-/* GC callback to mark memory pointed to by the pending inline queue.  */\n-void\n-mark_pending_inlines (pi)\n-     PTR pi;\n-{\n-  struct unparsed_text *up = * (struct unparsed_text **)pi;\n-\n-  while (up)\n-    {\n-      struct token *t = (struct token *) (up + 1);\n-      struct token *l = up->limit;\n-\n-      while (t < l)\n-\t{\n-\t  /* Some of the possible values for yychar use yylval.code\n-\t     instead of yylval.ttype.  We only have to worry about\n-\t     yychars that could have been returned by read_token.  */\n-\t  switch (t->yychar)\n-\t    {\n-\t    case '+':\t    case '-':\t    case '*':\t    case '/':\n-\t    case '%':\t    case '&':\t    case '|':\t    case '^':\n-\t    case '>':\t    case '<':\t    case LSHIFT:    case RSHIFT:\n-\t    case ASSIGN:    case MIN_MAX:   case EQCOMPARE: case ARITHCOMPARE:\n-\t      t++;\n-\t      continue;\n-\t    }\n-\t  if (t->yylval.ttype)\n-\t    ggc_mark_tree (t->yylval.ttype);\n-\t  t++;\n-\t}\n-      up = up->next;\n-    }\n-}\n-  \n /* Token queue management.  */\n \n /* Return the number of tokens available on the fifo.  */\n@@ -510,16 +472,24 @@ static const struct token Tpad = { EMPTY, 0 UNION_INIT_ZERO };\n \n /* Copy the next token into T and return its value.  */\n static SPEW_INLINE int\n-add_token (t)\n+next_token (t)\n      struct token *t;\n {\n   if (!feed)\n     return read_token (t);\n \n-  if (feed->input->pos < feed->input->limit)\n+  if (feed->input->cur_chunk != feed->input->last_chunk\n+      || feed->input->cur_pos != feed->input->last_pos)\n     {\n-      memcpy (t, feed->input->pos, sizeof (struct token));\n-      return (feed->input->pos++)->yychar;\n+      if (feed->input->cur_pos == TOKEN_CHUNK_SIZE)\n+\t{\n+\t  feed->input->cur_chunk = feed->input->cur_chunk->next;\n+\t  feed->input->cur_pos = 0;\n+\t}\n+      memcpy (t, feed->input->cur_chunk->toks + feed->input->cur_pos, \n+\t      sizeof (struct token));\n+      feed->input->cur_pos++;\n+      return t->yychar;\n     }\n   \n   memcpy (t, &Teosi, sizeof (struct token));\n@@ -532,7 +502,7 @@ shift_token ()\n {\n   size_t point = obstack_object_size (&token_obstack);\n   obstack_blank (&token_obstack, sizeof (struct token));\n-  return add_token ((struct token *) (obstack_base (&token_obstack) + point));\n+  return next_token ((struct token *) (obstack_base (&token_obstack) + point));\n }\n \n /* Consume the next token out of the fifo.  */\n@@ -1060,22 +1030,73 @@ process_next_inline (i)\n       extract_interface_info ();\n     }\n }\n+\f\n+/* Create a new token at the end of the token list in T.  */\n+static SPEW_INLINE struct token *\n+space_for_token (t)\n+     struct unparsed_text *t;\n+{\n+  if (t->last_pos != TOKEN_CHUNK_SIZE)\n+    return t->last_chunk->toks + (t->last_pos++);\n \n+  t->last_chunk->next = ggc_alloc (sizeof (*t->last_chunk->next));\n+  t->last_chunk = t->last_chunk->next;\n+  t->last_chunk->next = NULL;\n+  \n+  t->last_pos = 1;\n+  return t->last_chunk->toks;\n+}\n+\n+/* Shrink the token list in T by one token.  */\n+static SPEW_INLINE struct token *\n+remove_last_token (t)\n+     struct unparsed_text *t;\n+{\n+  struct token *result = t->last_chunk->toks + t->last_pos - 1;\n+  if (t->last_pos == 0)\n+    abort ();\n+  t->last_pos--;\n+  if (t->last_pos == 0 && t->last_chunk != t->tokens)\n+    {\n+      struct token_chunk **tc;\n+      for (tc = &t->tokens; (*tc)->next != NULL; tc = &(*tc)->next)\n+\t;\n+      *tc = NULL;\n+      t->last_pos = sizeof ((*tc)->toks) / sizeof ((*tc)->toks[0]);\n+    }\n+  return result;\n+}\n+\n+/* Allocate an 'unparsed_text' structure, ready to use space_for_token.  */\n+static struct unparsed_text *\n+alloc_unparsed_text (fn, li, decl, interface)\n+     const char *fn;\n+     int li;\n+     tree decl;\n+     int interface;\n+{\n+  struct unparsed_text *r;\n+  r = ggc_alloc_cleared (sizeof (*r));\n+  r->decl = decl;\n+  r->filename = fn;\n+  r->lineno = li;\n+  r->interface = interface;\n+  r->tokens = r->last_chunk = ggc_alloc_cleared (sizeof (*r->tokens));\n+  return r;\n+}\n \n /* Subroutine of snarf_method, deals with actual absorption of the block.  */\n \n-static SPEW_INLINE void\n-snarf_block (starting_file, starting_line)\n-     const char *starting_file;\n-     int starting_line;\n+static void\n+snarf_block (t)\n+     struct unparsed_text *t;\n {\n   int blev = 1;\n   int look_for_semicolon = 0;\n   int look_for_lbrac = 0;\n   int look_for_catch = 0;\n   int yyc;\n-  struct token tmp;\n-  size_t point;\n+  struct token *current;\n \n   if (yychar == '{')\n     ;\n@@ -1092,17 +1113,14 @@ snarf_block (starting_file, starting_line)\n     yyerror (\"parse error in method specification\");\n \n   /* The current token is the first one to be recorded.  */\n-  tmp.yychar = yychar;\n-  tmp.yylval = yylval;\n-  tmp.lineno = lineno;\n-  obstack_grow (&inline_text_obstack, &tmp, sizeof (struct token));\n+  current = space_for_token (t);\n+  current->yychar = yychar;\n+  current->yylval = yylval;\n+  current->lineno = lineno;\n \n   for (;;)\n     {\n-      point = obstack_object_size (&inline_text_obstack);\n-      obstack_blank (&inline_text_obstack, sizeof (struct token));\n-      yyc = add_token ((struct token *)\n-\t\t       (obstack_base (&inline_text_obstack) + point));\n+      yyc = next_token (space_for_token (t));\n \n       if (yyc == '{')\n \t{\n@@ -1117,35 +1135,37 @@ snarf_block (starting_file, starting_line)\n \t      if (!look_for_catch)\n \t\tbreak;\n \t      \n-\t      if (add_token (&tmp) != CATCH)\n+\t      if (next_token (space_for_token (t)) != CATCH)\n \t\t{\n-\t\t  push_token (&tmp);\n+\t\t  push_token (remove_last_token (t));\n \t\t  break;\n \t\t}\n \n \t      look_for_lbrac = 1;\n-\t      obstack_grow (&inline_text_obstack, &tmp, sizeof (struct token));\n \t    }\n \t}\n       else if (yyc == ';')\n \t{\n \t  if (look_for_lbrac)\n \t    {\n+\t      struct token *fake;\n+\t      \n \t      error (\"function body for constructor missing\");\n \t      /* fake a { } to avoid further errors */\n-\t      tmp.yylval.ttype = 0;\n-\t      tmp.yychar = '{';\n-\t      obstack_grow (&inline_text_obstack, &tmp, sizeof (struct token));\n-\t      tmp.yychar = '}';\n-\t      obstack_grow (&inline_text_obstack, &tmp, sizeof (struct token));\n+\t      fake = space_for_token (t);\n+\t      fake->yylval.ttype = 0;\n+\t      fake->yychar = '{';\n+\t      fake = space_for_token (t);\n+\t      fake->yylval.ttype = 0;\n+\t      fake->yychar = '}';\n \t      break;\n \t    }\n \t  else if (look_for_semicolon && blev == 0)\n \t    break;\n \t}\n       else if (yyc == 0)\n \t{\n-\t  error_with_file_and_line (starting_file, starting_line,\n+\t  error_with_file_and_line (t->filename, t->lineno,\n \t\t\t\t    \"end of file read inside definition\");\n \t  break;\n \t}\n@@ -1160,37 +1180,24 @@ snarf_method (decl)\n {\n   int starting_lineno = lineno;\n   const char *starting_filename = input_filename;\n-  size_t len;\n-\n   struct unparsed_text *meth;\n \n-  /* Leave room for the header, then absorb the block.  */\n-  obstack_blank (&inline_text_obstack, sizeof (struct unparsed_text));\n-  snarf_block (starting_filename, starting_lineno);\n+  meth = alloc_unparsed_text (starting_filename, starting_lineno, decl,\n+\t\t\t      (interface_unknown ? 1 \n+\t\t\t       : (interface_only ? 0 : 2)));\n \n-  len = obstack_object_size (&inline_text_obstack);\n-  meth = (struct unparsed_text *) obstack_finish (&inline_text_obstack);\n+  snarf_block (meth);\n \n   /* Happens when we get two declarations of the same function in the\n      same scope.  */\n   if (decl == void_type_node\n       || (current_class_type && TYPE_REDEFINED (current_class_type)))\n-    {\n-      obstack_free (&inline_text_obstack, (char *)meth);\n-      return;\n-    }\n-\n-  meth->decl = decl;\n-  meth->filename = starting_filename;\n-  meth->lineno = starting_lineno;\n-  meth->limit = (struct token *) ((char *)meth + len);\n-  meth->interface = (interface_unknown ? 1 : (interface_only ? 0 : 2));\n-  meth->next = 0;\n+    return;\n \n #ifdef SPEW_DEBUG\n   if (spew_debug)\n     fprintf (stderr, \"\\tsaved method of %d tokens from %s:%d\\n\",\n-\t     meth->limit - (struct token *) (meth + 1),\n+\t     meth->limit,\n \t     starting_filename, starting_lineno);\n #endif\n \n@@ -1204,8 +1211,8 @@ snarf_method (decl)\n   pending_inlines_tail = meth;\n }\n \n-/* Consume a no-commas expression - a default argument - and save it\n-   on the inline_text_obstack.  */\n+/* Consume a no-commas expression - a default argument - and return\n+   a DEFAULT_ARG tree node.  */\n \n static tree\n snarf_defarg ()\n@@ -1214,19 +1221,14 @@ snarf_defarg ()\n   const char *starting_filename = input_filename;\n   int yyc;\n   int plev = 0;\n-  size_t point;\n-  size_t len;\n   struct unparsed_text *buf;\n   tree arg;\n \n-  obstack_blank (&inline_text_obstack, sizeof (struct unparsed_text));\n+  buf = alloc_unparsed_text (starting_filename, starting_lineno, 0, 0);\n \n   for (;;)\n     {\n-      point = obstack_object_size (&inline_text_obstack);\n-      obstack_blank (&inline_text_obstack, sizeof (struct token));\n-      yyc = add_token ((struct token *)\n-\t\t       (obstack_base (&inline_text_obstack) + point));\n+      yyc = next_token (space_for_token (buf));\n \n       if (plev <= 0 && (yyc == ')' || yyc == ','))\n \tbreak;\n@@ -1243,24 +1245,13 @@ snarf_defarg ()\n     }\n \n   /* Unget the last token.  */\n-  push_token ((struct token *) (obstack_base (&inline_text_obstack) + point));\n-  /* This is the documented way to shrink a growing obstack block.  */\n-  obstack_blank (&inline_text_obstack, - (int) sizeof (struct token));\n+  push_token (remove_last_token (buf));\n \n  done:\n-  len = obstack_object_size (&inline_text_obstack);\n-  buf = (struct unparsed_text *) obstack_finish (&inline_text_obstack);\n-\n-  buf->decl = 0;\n-  buf->filename = starting_filename;\n-  buf->lineno = starting_lineno;\n-  buf->limit = (struct token *) ((char *)buf + len);\n-  buf->next = 0;\n-  \n #ifdef SPEW_DEBUG\n   if (spew_debug)\n     fprintf (stderr, \"\\tsaved defarg of %d tokens from %s:%d\\n\",\n-\t     buf->limit - (struct token *) (buf + 1),\n+\t     buf->limit,\n \t     starting_filename, starting_lineno);\n #endif\n \n@@ -1531,3 +1522,5 @@ yyerror (msgid)\n   else\n     error (\"%s before `%s' token\", string, NAME (last_token));\n }\n+\n+#include \"gt-cp-spew.h\""}, {"sha": "0752d7bc8dc99f00bbdb37b9c73555e37ff35149", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -710,7 +710,7 @@ unshare_base_binfos (binfo)\n    While all these live in the same table, they are completely independent,\n    and the hash code is computed differently for each of these.  */\n \n-static htab_t list_hash_table;\n+static GTY ((param_is (union tree_node))) htab_t list_hash_table;\n \n struct list_proxy \n {\n@@ -1720,25 +1720,15 @@ cp_tree_equal (t1, t2)\n   return -1;\n }\n \n-/* Build a wrapper around some pointer PTR so we can use it as a tree.  */\n+/* Build a wrapper around a 'struct z_candidate' so we can use it as a\n+   tree.  */\n \n tree\n-build_ptr_wrapper (ptr)\n-     void *ptr;\n+build_zc_wrapper (ptr)\n+     struct z_candidate *ptr;\n {\n   tree t = make_node (WRAPPER);\n-  WRAPPER_PTR (t) = ptr;\n-  return t;\n-}\n-\n-/* Build a wrapper around some integer I so we can use it as a tree.  */\n-\n-tree\n-build_int_wrapper (i)\n-     int i;\n-{\n-  tree t = make_node (WRAPPER);\n-  WRAPPER_INT (t) = i;\n+  WRAPPER_ZC (t) = ptr;\n   return t;\n }\n \n@@ -2326,10 +2316,7 @@ void\n init_tree ()\n {\n   lang_statement_code_p = cp_statement_code_p;\n-  list_hash_table = htab_create (31, list_hash, list_hash_eq, NULL);\n-  ggc_add_root (&list_hash_table, 1, \n-\t\tsizeof (list_hash_table),\n-\t\tmark_tree_hashtable);\n+  list_hash_table = htab_create_ggc (31, list_hash, list_hash_eq, NULL);\n }\n \n /* Called via walk_tree.  If *TP points to a DECL_STMT for a local\n@@ -2557,3 +2544,20 @@ stabilize_expr (exp, initp)\n   *initp = init_expr;\n   return exp;\n }\n+\f\n+#if defined ENABLE_TREE_CHECKING && (GCC_VERSION >= 2007)\n+/* Complain that some language-specific thing hanging off a tree\n+   node has been accessed improperly.  */\n+\n+void\n+lang_check_failed (file, line, function)\n+     const char *file;\n+     int line;\n+     const char *function;\n+{\n+  internal_error (\"lang_* check: failed in %s, at %s:%d\",\n+\t\t  function, trim_filename (file), line);\n+}\n+#endif /* ENABLE_TREE_CHECKING */\n+\n+#include \"gt-cp-tree.h\""}, {"sha": "d9b6ee14e56f9dab47b0c3548fb5556c0c1ed9e2", "filename": "gcc/cselib.c", "status": "modified", "additions": 37, "deletions": 38, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -35,7 +35,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"toplev.h\"\n #include \"output.h\"\n #include \"ggc.h\"\n-#include \"obstack.h\"\n #include \"hashtab.h\"\n #include \"cselib.h\"\n \n@@ -79,7 +78,7 @@ static void cselib_record_sets\t\tPARAMS ((rtx));\n      the locations of the entries with the rtx we are looking up.  */\n \n /* A table that enables us to look up elts by their value.  */\n-static htab_t hash_table;\n+static GTY((param_is (cselib_val))) htab_t hash_table;\n \n /* This is a global so we don't have to pass this through every function.\n    It is used in new_elt_loc_list to set SETTING_INSN.  */\n@@ -101,7 +100,8 @@ static int n_useless_values;\n /* This table maps from register number to values.  It does not contain\n    pointers to cselib_val structures, but rather elt_lists.  The purpose is\n    to be able to refer to the same register in different modes.  */\n-static varray_type reg_values;\n+static GTY(()) varray_type reg_values;\n+static GTY((deletable (\"\"))) varray_type reg_values_old;\n #define REG_VALUES(I) VARRAY_ELT_LIST (reg_values, (I))\n \n /* The largest number of hard regs used by any entry added to the\n@@ -110,22 +110,17 @@ static unsigned int max_value_regs;\n \n /* Here the set of indices I with REG_VALUES(I) != 0 is saved.  This is used\n    in clear_table() for fast emptying.  */\n-static varray_type used_regs;\n+static GTY(()) varray_type used_regs;\n+static GTY((deletable (\"\"))) varray_type used_regs_old;\n \n /* We pass this to cselib_invalidate_mem to invalidate all of\n    memory for a non-const call instruction.  */\n-static rtx callmem;\n-\n-/* Memory for our structures is allocated from this obstack.  */\n-static struct obstack cselib_obstack;\n-\n-/* Used to quickly free all memory.  */\n-static char *cselib_startobj;\n+static GTY(()) rtx callmem;\n \n /* Caches for unused structures.  */\n-static cselib_val *empty_vals;\n-static struct elt_list *empty_elt_lists;\n-static struct elt_loc_list *empty_elt_loc_lists;\n+static GTY((deletable (\"\"))) cselib_val *empty_vals;\n+static GTY((deletable (\"\"))) struct elt_list *empty_elt_lists;\n+static GTY((deletable (\"\"))) struct elt_loc_list *empty_elt_loc_lists;\n \n /* Set by discard_useless_locs if it deleted the last location of any\n    value.  */\n@@ -145,8 +140,7 @@ new_elt_list (next, elt)\n   if (el)\n     empty_elt_lists = el->next;\n   else\n-    el = (struct elt_list *) obstack_alloc (&cselib_obstack,\n-\t\t\t\t\t    sizeof (struct elt_list));\n+    el = (struct elt_list *) ggc_alloc (sizeof (struct elt_list));\n   el->next = next;\n   el->elt = elt;\n   return el;\n@@ -165,8 +159,7 @@ new_elt_loc_list (next, loc)\n   if (el)\n     empty_elt_loc_lists = el->next;\n   else\n-    el = (struct elt_loc_list *) obstack_alloc (&cselib_obstack,\n-\t\t\t\t\t\tsizeof (struct elt_loc_list));\n+    el = (struct elt_loc_list *) ggc_alloc (sizeof (struct elt_loc_list));\n   el->next = next;\n   el->loc = loc;\n   el->setting_insn = cselib_current_insn;\n@@ -236,11 +229,7 @@ clear_table (clear_all)\n   VARRAY_POP_ALL (used_regs);\n \n   htab_empty (hash_table);\n-  obstack_free (&cselib_obstack, cselib_startobj);\n \n-  empty_vals = 0;\n-  empty_elt_lists = 0;\n-  empty_elt_loc_lists = 0;\n   n_useless_values = 0;\n \n   next_unknown_value = 0;\n@@ -704,7 +693,7 @@ new_cselib_val (value, mode)\n   if (e)\n     empty_vals = e->u.next_free;\n   else\n-    e = (cselib_val *) obstack_alloc (&cselib_obstack, sizeof (cselib_val));\n+    e = (cselib_val *) ggc_alloc (sizeof (cselib_val));\n \n   if (value == 0)\n     abort ();\n@@ -1399,20 +1388,25 @@ cselib_update_varray_sizes ()\n void\n cselib_init ()\n {\n-  /* These are only created once.  */\n+  /* This is only created once.  */\n   if (! callmem)\n-    {\n-      gcc_obstack_init (&cselib_obstack);\n-      cselib_startobj = obstack_alloc (&cselib_obstack, 0);\n-\n-      callmem = gen_rtx_MEM (BLKmode, const0_rtx);\n-      ggc_add_rtx_root (&callmem, 1);\n-    }\n+    callmem = gen_rtx_MEM (BLKmode, const0_rtx);\n \n   cselib_nregs = max_reg_num ();\n-  VARRAY_ELT_LIST_INIT (reg_values, cselib_nregs, \"reg_values\");\n-  VARRAY_UINT_INIT (used_regs, cselib_nregs, \"used_regs\");\n-  hash_table = htab_create (31, get_value_hash, entry_and_rtx_equal_p, NULL);\n+  if (reg_values_old != NULL && VARRAY_SIZE (reg_values_old) >= cselib_nregs)\n+    {\n+      reg_values = reg_values_old;\n+      used_regs = used_regs_old;\n+      VARRAY_CLEAR (reg_values);\n+      VARRAY_CLEAR (used_regs);\n+    }\n+  else\n+    {\n+      VARRAY_ELT_LIST_INIT (reg_values, cselib_nregs, \"reg_values\");\n+      VARRAY_UINT_INIT (used_regs, cselib_nregs, \"used_regs\");\n+    }\n+  hash_table = htab_create_ggc (31, get_value_hash, entry_and_rtx_equal_p, \n+\t\t\t\tNULL);\n   clear_table (1);\n }\n \n@@ -1421,8 +1415,13 @@ cselib_init ()\n void\n cselib_finish ()\n {\n-  clear_table (0);\n-  VARRAY_FREE (reg_values);\n-  VARRAY_FREE (used_regs);\n-  htab_delete (hash_table);\n+  reg_values_old = reg_values;\n+  reg_values = 0;\n+  used_regs_old = used_regs;\n+  used_regs = 0;\n+  hash_table = 0;\n+  n_useless_values = 0;\n+  next_unknown_value = 0;\n }\n+\n+#include \"gt-cselib.h\""}, {"sha": "8cb2e6b41e31cefd0b6dce2db1a6e572bd8b2b53", "filename": "gcc/cselib.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fcselib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fcselib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.h?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -20,17 +20,17 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n 02111-1307, USA.  */\n \n /* Describe a value.  */\n-typedef struct cselib_val_struct\n+typedef struct cselib_val_struct GTY(())\n {\n   /* The hash value.  */\n   unsigned int value;\n-  union\n+  union cselib_val_u\n   {\n     /* A VALUE rtx that points back to this structure.  */\n-    rtx val_rtx;\n+    rtx GTY ((tag (\"1\"))) val_rtx;\n     /* Used to keep a list of free cselib_val structures.  */\n-    struct cselib_val_struct *next_free;\n-  } u;\n+    struct cselib_val_struct * GTY ((skip (\"\"))) next_free;\n+  } GTY ((desc (\"1\"))) u;\n \n   /* All rtl expressions that hold this value at the current time during a\n      scan.  */\n@@ -41,7 +41,7 @@ typedef struct cselib_val_struct\n } cselib_val;\n \n /* A list of rtl expressions that hold the same value.  */\n-struct elt_loc_list\n+struct elt_loc_list GTY(())\n {\n   /* Next element in the list.  */\n   struct elt_loc_list *next;\n@@ -52,7 +52,7 @@ struct elt_loc_list\n };\n \n /* A list of cselib_val structures.  */\n-struct elt_list\n+struct elt_list GTY(())\n {\n   struct elt_list *next;\n   cselib_val *elt;"}, {"sha": "ec46d988bf191c2ce312335172b0e41b614bf406", "filename": "gcc/dependence.c", "status": "modified", "additions": 23, "deletions": 27, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fdependence.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fdependence.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdependence.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -31,6 +31,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"tree.h\"\n #include \"c-common.h\"\n #include \"flags.h\"\n+#include \"ggc.h\"\n #include \"varray.h\"\n \n #define MAX_SUBSCRIPTS 13\n@@ -81,7 +82,7 @@ enum complexity_type {ziv, strong_siv, weak_siv, weak_zero_siv,\n    for that variable.  Alternately one can sequentially follow each\n    element of def_use_chain.  */\n \n-typedef struct def_use\n+typedef struct def_use GTY(())\n {\n   /* outermost loop */\n   tree outer_loop;\n@@ -106,7 +107,7 @@ typedef struct def_use\n    element of loop_chain and check outer_loop to get all loops\n    contained within a certain loop.  */\n \n-typedef struct loop\n+typedef struct loop GTY(())\n {\n   /* outermost loop containing this loop */\n   tree outer_loop;\n@@ -124,7 +125,7 @@ typedef struct loop\n \n /* Pointed to by loop. One per induction variable.  */\n \n-typedef struct induction\n+typedef struct induction GTY(())\n {\n   /* our name */\n   const char *variable;\n@@ -140,7 +141,7 @@ typedef struct induction\n \n /* Pointed to by def/use.  One per dependence.  */\n \n-typedef struct dependence\n+typedef struct dependence GTY(())\n {\n   tree source;\n   tree destination;\n@@ -172,16 +173,16 @@ typedef struct subscript\n static tree dest_to_remember;\n \n /* Chain for def_use */\n-static varray_type def_use_chain;\n+static GTY ((param_is (def_use))) varray_type def_use_chain;\n \n /* Chain for dependence */\n-static varray_type dep_chain;\n+static GTY ((param_is (dependence))) varray_type dep_chain;\n \n /* Chain for loop */\n-static varray_type loop_chain;\n+static GTY ((param_is (loop))) varray_type loop_chain;\n \n /* Chain for induction */\n-static varray_type induction_chain;\n+static GTY ((param_is (induction))) varray_type induction_chain;\n \n void init_dependence_analysis PARAMS ((tree));\n static void build_def_use PARAMS ((tree, enum def_use_type));\n@@ -227,8 +228,6 @@ void\n init_dependence_analysis (exp)\n      tree exp;\n {\n-  def_use *du_ptr;\n-\n   VARRAY_GENERIC_PTR_INIT (def_use_chain, 50, \"def_use_chain\");\n   VARRAY_GENERIC_PTR_INIT (dep_chain, 50, \"dep_chain\");\n   VARRAY_GENERIC_PTR_INIT (loop_chain, 50, \"loop_chain\");\n@@ -242,16 +241,9 @@ init_dependence_analysis (exp)\n \n   /* dump_node_dependence (&def_use_chain);*/\n \n-  for (du_ptr = VARRAY_TOP (def_use_chain, generic);\n-       VARRAY_POP (def_use_chain);\n-       du_ptr = VARRAY_TOP (def_use_chain, generic))\n-    {\n-      free (du_ptr);\n-    }\n-\n-  VARRAY_FREE (def_use_chain);\n-  VARRAY_FREE (loop_chain);\n-  VARRAY_FREE (induction_chain);\n+  def_use_chain = 0;\n+  loop_chain = 0;\n+  induction_chain = 0;\n }\n \n /* Build ARRAY_REF def/use info 'def_use_chain' starting at EXP which is a def\n@@ -337,7 +329,8 @@ build_def_use (exp, du_type)\n \t    int i;\n \t    char null_string = '\\0';\n \n-\t    VARRAY_PUSH_GENERIC_PTR (def_use_chain, xmalloc (sizeof (def_use)));\n+\t    VARRAY_PUSH_GENERIC_PTR (def_use_chain, \n+\t\t\t\t     ggc_alloc (sizeof (def_use)));\n \t    du_ptr = VARRAY_GENERIC_PTR (def_use_chain, du_idx++);\n \t    du_ptr->type = du_type;\n \t    du_ptr->status = unseen;\n@@ -418,7 +411,7 @@ add_loop (loop_node, outer_loop, nloop)\n {\n   loop *loop_ptr;\n \n-  VARRAY_PUSH_GENERIC_PTR (loop_chain, xmalloc (sizeof (loop)));\n+  VARRAY_PUSH_GENERIC_PTR (loop_chain, ggc_alloc (sizeof (loop)));\n   loop_ptr = VARRAY_TOP (loop_chain, generic);\n   loop_ptr->outer_loop = outer_loop;\n   loop_ptr->containing_loop = loop_node;\n@@ -502,7 +495,8 @@ find_induction_variable (init_node, cond_node, incr_node, loop_def)\n       if (!INDEX_LIMIT_CHECK (cond_node))\n \treturn 0;\n \n-      VARRAY_PUSH_GENERIC_PTR (induction_chain, xmalloc (sizeof (induction)));\n+      VARRAY_PUSH_GENERIC_PTR (induction_chain, \n+\t\t\t       ggc_alloc (sizeof (induction)));\n       ind_ptr = VARRAY_TOP (induction_chain, generic);\n       loop_def->ind = ind_ptr;\n       ind_ptr->variable = IDENTIFIER_POINTER (DECL_NAME (TREE_OPERAND\n@@ -747,7 +741,7 @@ check_node_dependence (du)\n \t  if (! have_dependence)\n \t    continue;\n \n-\t  VARRAY_PUSH_GENERIC_PTR (dep_chain, xmalloc (sizeof (dependence)));\n+\t  VARRAY_PUSH_GENERIC_PTR (dep_chain, ggc_alloc (sizeof (dependence)));\n \t  dep_ptr = VARRAY_TOP (dep_chain, generic);\n \t  dep_ptr->source = use_ptr->expression;\n \t  dep_ptr->destination = def_ptr->expression;\n@@ -790,7 +784,8 @@ check_node_dependence (du)\n \t      /* Dummy for rtl interface */\n \t      dependence *dep_root_ptr;\n \n-\t      VARRAY_PUSH_GENERIC_PTR (dep_chain, xmalloc (sizeof (dependence)));\n+\t      VARRAY_PUSH_GENERIC_PTR (dep_chain, \n+\t\t\t\t       ggc_alloc (sizeof (dependence)));\n \t      dep_root_ptr = VARRAY_TOP (dep_chain, generic);\n \t      dep_root_ptr->source = 0;\n \t      dep_root_ptr->destination = def_ptr->expression;\n@@ -1364,7 +1359,6 @@ dump_node_dependence (void)\n       if (i >= VARRAY_SIZE (seen))\n \tdump_one_node (du_ptr, &seen);\n     }\n-  VARRAY_FREE (seen);\n }\n #endif\n \n@@ -1463,5 +1457,7 @@ have_dependence_p (dest_rtx, src_rtx, direction, distance)\n void\n end_dependence_analysis ()\n {\n-  VARRAY_FREE (dep_chain);\n+  dep_chain = 0;\n }\n+\n+#include \"gt-dependence.h\""}, {"sha": "35bd02cc21ac9b18a89035a836a4f4afcc0a6b9d", "filename": "gcc/doc/gccint.texi", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fdoc%2Fgccint.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fdoc%2Fgccint.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgccint.texi?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -169,6 +169,7 @@ Additional tutorial information is linked to from\n * Fragments::       Writing the @file{t-@var{target}} and @file{x-@var{host}} files.\n * Collect2::        How @code{collect2} works; how it finds @code{ld}.\n * Header Dirs::     Understanding the standard header file directories.\n+* Type Information:: GCC's memory management; generating type information.\n \n * Funding::         How to help assure funding for free software.\n * GNU Project::     The GNU Project and GNU/Linux.\n@@ -196,6 +197,7 @@ Additional tutorial information is linked to from\n @include fragments.texi\n @include collect2.texi\n @include headerdirs.texi\n+@include gty.texi\n \n @include funding.texi\n @include gnu.texi"}, {"sha": "132cd415fa1813930a6d03e5a8c7eabda661e75d", "filename": "gcc/doc/gty.texi", "status": "added", "additions": 257, "deletions": 0, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fdoc%2Fgty.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fdoc%2Fgty.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgty.texi?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -0,0 +1,257 @@\n+@c Copyright (C) 2002\n+@c Free Software Foundation, Inc.\n+@c This is part of the GCC manual.\n+@c For copying conditions, see the file gcc.texi.\n+\n+@node Type Information\n+@chapter Memory Management and Type Information\n+@cindex GGC\n+@findex GTY\n+\n+GCC uses some fairly sophisticated memory management techniques, which\n+involve determining information about GCC's data structures from GCC's\n+source code and using this information to perform garbage collection.\n+\n+A full C parser would be too overcomplicated for this task, so a limited\n+subset of C is interpreted and special markers are used to determine\n+what parts of the source to look at.  The parser can also detect\n+simple typedefs of the form @code{typedef struct ID1 *ID2;} and\n+@code{typedef int ID3;}, and these don't need to be specially marked.\n+\n+The two forms that do need to be marked are:\n+@verbatim\n+struct ID1 GTY(([options]))\n+{\n+  [fields]\n+};\n+\n+typedef struct ID2 GTY(([options]))\n+{\n+  [fields]\n+} ID3;\n+@end verbatim\n+\n+@menu\n+* GTY Options::\t\tWhat goes inside a @code{GTY(())}.\n+* GGC Roots::\t\tMaking global variables GGC roots.\n+* Files::\t\tHow the generated files work.\n+@end menu\n+\n+@node GTY Options\n+@section The Inside of a @code{GTY(())}\n+\n+Sometimes the C code is not enough to fully describe the type structure.\n+Extra information can be provided by using more @code{GTY} markers.\n+These markers can be placed:\n+@itemize @bullet\n+@item\n+In a structure definition, before the open brace;\n+@item\n+In a global variable declaration, after the keyword @code{static} or \n+@code{extern}; and\n+@item\n+In a structure field definition, before the name of the field.\n+@end itemize\n+\n+The format of a marker is\n+@verbatim\n+GTY (([name] ([param]), [name] ([param]) ...))\n+@end verbatim\n+The parameter is either a string or a type name.\n+\n+When the parameter is a string, often it is a fragment of C code.  Three\n+special escapes may be available:\n+\n+@cindex % in GTY option\n+@table @code\n+@item %h\n+This expands to an expression that evaluates to the current structure.\n+@item %1\n+This expands to an expression that evaluates to the structure that\n+immediately contains the current structure.\n+@item %0\n+This expands to an expression that evaluates to the outermost structure\n+that contains the current structure.\n+@end table\n+\n+The available options are:\n+\n+@table @code\n+@findex length\n+@item length\n+\n+There are two places the type machinery will need to be explicitly told\n+the length of an array.  The first case is when a structure ends in a\n+variable-length array, like this:\n+@verbatim\n+struct rtvec_def GTY(()) {\n+  int num_elem;\t\t/* number of elements */\n+  rtx GTY ((length (\"%h.num_elem\"))) elem[1];\n+};\n+@end verbatim\n+In this case, the @code{length} option is used to override the specified\n+array length (which should usually be @code{1}).  The parameter of the\n+option is a fragment of C code that calculates the length.\n+\n+The second case is when a structure or a global variable contains a\n+pointer to an array, like this:\n+@verbatim\n+  tree * GTY ((length (\"%h.regno_pointer_align_length\"))) regno_decl;\n+@end verbatim\n+In this case, @code{regno_decl} has been allocated by writing something like\n+@verbatim\n+  x->regno_decl = ggc_alloc (x->regno_pointer_align_length * sizeof (tree));\n+@end verbatim\n+and the @code{length} provides the length of the field.\n+\n+This second use of @code{length} also works on global variables, like:\n+@verbatim\n+static GTY((length (\"reg_base_value_size\"))) rtx *reg_base_value;\n+@end verbatim\n+\n+@findex skip\n+@item skip\n+\n+If @code{skip} is applied to a field, the type machinery will ignore it.\n+This is somewhat dangerous; the only safe use is in a union when one\n+field really isn't ever used.\n+\n+@findex desc\n+@findex tag\n+@findex always\n+@item desc\n+@itemx tag\n+@itemx always\n+\n+The type machinery needs to be told which field of a @code{union} is\n+currently active.  This is done by giving each field a constant @code{tag}\n+value, and then specifying a discriminator using @code{desc}.  For example,\n+@verbatim\n+struct tree_binding GTY(())\n+{\n+  struct tree_common common;\n+  union tree_binding_u {\n+    tree GTY ((tag (\"0\"))) scope;\n+    struct cp_binding_level * GTY ((tag (\"1\"))) level;\n+  } GTY ((desc (\"BINDING_HAS_LEVEL_P ((tree)&%0)\"))) scope;\n+  tree value;\n+};\n+@end verbatim\n+\n+In the @code{desc} option, the ``current structure'' is the union that\n+it discriminates.  Use @code{%1} to mean the structure containing it.\n+(There are no escapes available to the @code{tag} option, since it's\n+supposed to be a constant.)\n+\n+You can use @code{always} to mean that this field is always used.\n+\n+@findex param_is\n+@findex use_param\n+@item param_is\n+@itemx use_param\n+\n+Sometimes it's convenient to define some data structure to work on\n+generic pointers (that is, @code{PTR}), and then use it with specific types.\n+@code{param_is} specifies the real type pointed to, and @code{use_param}\n+says where in the generic data structure that type should be put.\n+\n+For instance, to have a @code{htab_t} that points to trees, one should write\n+@verbatim\n+  htab_t GTY ((param_is (union tree_node))) ict;\n+@end verbatim\n+\n+@findex deletable\n+@item deletable\n+\n+@code{deletable}, when applied to a global variable, indicates that when\n+garbage collection runs, there's no need to mark anything pointed to\n+by this variable, it can just be set to @code{NULL} instead.  This is used\n+to keep a list of free structures around for re-use.\n+\n+@findex if_marked\n+@item if_marked\n+\n+Suppose you want some kinds of object to be unique, and so you put them\n+in a hash table.  If garbage collection marks the hash table, these\n+objects will never be freed, even if the last other reference to them\n+goes away.  GGC has special handling to deal with this: if you use the\n+@code{if_marked} option on a global hash table, GGC will call the\n+routine whose name is the parameter to the option on each hash table\n+entry.  If the routine returns nonzero, the hash table entry will\n+be marked as usual.  If the routine returns zero, the hash table entry\n+will be deleted.\n+\n+The routine @code{ggc_marked_p} can be used to determine if an element\n+has been marked already; in fact, the usual case is to use\n+@code{if_marked (\"ggc_marked_p\")}.\n+\n+@findex maybe_undef\n+@item maybe_undef\n+\n+When applied to a field, @code{maybe_undef} indicates that it's OK if\n+the structure that this fields points to is never defined, so long as\n+this field is always @code{NULL}.  This is used to avoid requiring\n+backends to define certain optional structures.  It doesn't work with\n+language frontends.\n+\n+@findex special\n+@item special\n+\n+The @code{special} option is used for those bizarre cases that are just\n+too hard to deal with otherwise.  Don't use it for new code.\n+\n+@end table\n+\n+@node GGC Roots\n+@section Marking Roots for the Garbage Collector\n+@cindex roots, marking\n+@cindex marking roots\n+\n+In addition to keeping track of types, the type machinery also locates\n+the global variables that the garbage collector starts at.  There are\n+two syntaxes it accepts to indicate a root:\n+\n+@enumerate\n+@item\n+@verb{|extern GTY (([options])) [type] ID;|}\n+@item\n+@verb{|static GTY (([options])) [type] ID;|}\n+@end enumerate\n+\n+@node Files\n+@section Source Files Containing Type Information\n+@cindex generated files\n+@cindex files, generated\n+\n+Whenever you add @code{GTY} markers to a new source file, there are three\n+things you need to do:\n+\n+@enumerate\n+@item\n+You need to add the file to the list of source files the type machinery\n+scans.  For a back-end file, this is done automatically.  For a\n+front-end file, this is done by adding the filename to the\n+@code{gtfiles} variable defined in @file{config-lang.in}.  For other\n+files, this is done by adding the filename to the @code{GTFILES} variable\n+in @file{Makefile.in}.\n+\n+@item\n+You need to include the file that the type machinery will generate in\n+the source file you just changed.  The file will be called\n+@file{gt-@var{path}.h} where @var{path} is the pathname from the\n+@file{gcc} directory with slashes replaced by @verb{|-|}.  Don't forget\n+to mention this file as a dependency in the @file{Makefile}!\n+\n+@item\n+Finally, you need to add a @file{Makefile} rule that will ensure this file\n+can be built.  This is done by making it a dependency of @code{s-gtype},\n+like this:\n+@verbatim\n+gt-path.h : s-gtype ; @true\n+@end verbatim\n+@end enumerate\n+\n+For language frontends, there is another file that needs to be included\n+somewhere.  It will be called @file{gtype-@var{lang}.h}, where\n+@var{lang} is the name of the subdirectory the language is contained in.\n+It will need @file{Makefile} rules just like the other generated files."}, {"sha": "45a65ce25d751cf0d0b78c4e622220f0b02db5d2", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -824,11 +824,9 @@ structure contains a field called @code{machine} whose type is\n to their own specific data.\n \n If a target needs per-function specific data it should define the type\n-@code{struct machine_function} and also the macro\n-@code{INIT_EXPANDERS}.  This macro should be used to initialize some or\n-all of the function pointers @code{init_machine_status},\n-@code{free_machine_status} and @code{mark_machine_status}.  These\n-pointers are explained below.\n+@code{struct machine_function} and also the macro @code{INIT_EXPANDERS}.\n+This macro should be used to initialize the function pointer\n+@code{init_machine_status}.  This pointer is explained below.\n \n One typical use of per-function, target specific data is to create an\n RTX to hold the register containing the function's return address.  This\n@@ -864,19 +862,9 @@ specific initialization of the @code{struct function} structure.  It is\n intended that this would be used to initialize the @code{machine} of\n that structure.\n \n-@findex free_machine_status\n-@item   free_machine_status\n-This is a @code{void (*)(struct function *)} function pointer.  If this\n-pointer is non-@code{NULL} it will be called once per function, after the\n-function has been compiled, in order to allow any memory allocated\n-during the @code{init_machine_status} function call to be freed.\n-\n-@findex mark_machine_status\n-@item   mark_machine_status\n-This is a @code{void (*)(struct function *)} function pointer.  If this\n-pointer is non-@code{NULL} it will be called once per function in order to mark\n-any data items in the @code{struct machine_function} structure which\n-need garbage collection.\n+@code{struct machine_function} structures are expected to be freed by GC.\n+Generally, any memory that they reference must be allocated by using\n+@code{ggc_alloc}, including the structure itself.\n \n @end table\n "}, {"sha": "6e6a5d02303da785ee835ce691bf5d8852055c47", "filename": "gcc/dwarf2asm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fdwarf2asm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fdwarf2asm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2asm.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -704,7 +704,7 @@ mark_indirect_pool_entry (node, data)\n      splay_tree_node node;\n      void* data ATTRIBUTE_UNUSED;\n {\n-  ggc_mark_nonnull_tree ((tree) node->value);\n+  ggc_mark_tree ((tree) node->value);\n   return 0;\n }\n "}, {"sha": "3941490109dd96f3e504084f410378847a2da36e", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 26, "deletions": 22, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -134,6 +134,22 @@ default_eh_frame_section ()\n #endif\n }\n \n+/* Array of RTXes referenced by the debugging information, which therefore\n+   must be kept around forever.  */\n+static GTY(()) varray_type used_rtx_varray;\n+\n+/* A pointer to the base of a list of incomplete types which might be\n+   completed at some later time.  incomplete_types_list needs to be a VARRAY\n+   because we want to tell the garbage collector about it.  */\n+static GTY(()) varray_type incomplete_types;\n+\n+/* A pointer to the base of a table of references to declaration\n+   scopes.  This table is a display which tracks the nesting\n+   of declaration scopes at the current scope and containing\n+   scopes.  This table is used to find the proper place to\n+   define type declaration DIE's.  */\n+static GTY(()) varray_type decl_scope_table;\n+\n #if defined (DWARF2_DEBUGGING_INFO) || defined (DWARF2_UNWIND_INFO)\n \n /* How to start an assembler comment.  */\n@@ -3352,13 +3368,6 @@ static unsigned decl_die_table_in_use;\n    decl_die_table.  */\n #define DECL_DIE_TABLE_INCREMENT 256\n \n-/* A pointer to the base of a table of references to declaration\n-   scopes.  This table is a display which tracks the nesting\n-   of declaration scopes at the current scope and containing\n-   scopes.  This table is used to find the proper place to\n-   define type declaration DIE's.  */\n-varray_type decl_scope_table;\n-\n /* A pointer to the base of a list of references to DIE's that\n    are uniquely identified by their tag, presence/absence of\n    children DIE's, and list of attribute/value pairs.  */\n@@ -3441,21 +3450,12 @@ static unsigned ranges_table_in_use;\n /* Whether we have location lists that need outputting */\n static unsigned have_location_lists;\n \n-/* A pointer to the base of a list of incomplete types which might be\n-   completed at some later time.  incomplete_types_list needs to be a VARRAY\n-   because we want to tell the garbage collector about it.  */\n-varray_type incomplete_types;\n-\n /* Record whether the function being analyzed contains inlined functions.  */\n static int current_function_has_inlines;\n #if 0 && defined (MIPS_DEBUGGING_INFO)\n static int comp_unit_has_inlines;\n #endif\n \n-/* Array of RTXes referenced by the debugging information, which therefore\n-   must be kept around forever.  This is a GC root.  */\n-static varray_type used_rtx_varray;\n-\n /* Forward declarations for functions defined in this file.  */\n \n static int is_pseudo_reg\t\tPARAMS ((rtx));\n@@ -5123,7 +5123,7 @@ static inline dw_die_ref\n lookup_type_die (type)\n      tree type;\n {\n-  return (dw_die_ref) TYPE_SYMTAB_POINTER (type);\n+  return TYPE_SYMTAB_DIE (type);\n }\n \n /* Equate a DIE to a given type specifier.  */\n@@ -5133,7 +5133,7 @@ equate_type_number_to_die (type, type_die)\n      tree type;\n      dw_die_ref type_die;\n {\n-  TYPE_SYMTAB_POINTER (type) = (char *) type_die;\n+  TYPE_SYMTAB_DIE (type) = type_die;\n }\n \n /* Return the DIE associated with a given declaration.  */\n@@ -12034,7 +12034,6 @@ dwarf2out_init (main_input_filename)\n \n   /* Allocate the initial hunk of the decl_scope_table.  */\n   VARRAY_TREE_INIT (decl_scope_table, 256, \"decl_scope_table\");\n-  ggc_add_tree_varray_root (&decl_scope_table, 1);\n \n   /* Allocate the initial hunk of the abbrev_die_table.  */\n   abbrev_die_table\n@@ -12061,10 +12060,8 @@ dwarf2out_init (main_input_filename)\n   comp_unit_die = gen_compile_unit_die (main_input_filename);\n \n   VARRAY_TREE_INIT (incomplete_types, 64, \"incomplete_types\");\n-  ggc_add_tree_varray_root (&incomplete_types, 1);\n \n   VARRAY_RTX_INIT (used_rtx_varray, 32, \"used_rtx_varray\");\n-  ggc_add_rtx_varray_root (&used_rtx_varray, 1);\n \n   ggc_add_root (&limbo_die_list, 1, 1, mark_limbo_die_list);\n \n@@ -12322,4 +12319,11 @@ dwarf2out_finish (input_filename)\n   if (debug_str_hash)\n     ht_forall (debug_str_hash, output_indirect_string, NULL);\n }\n-#endif /* DWARF2_DEBUGGING_INFO || DWARF2_UNWIND_INFO */\n+#else\n+\n+/* This should never be used, but its address is needed for comparisons.  */\n+const struct gcc_debug_hooks dwarf2_debug_hooks;\n+\n+#endif /* DWARF2_DEBUGGING_INFO */\n+\n+#include \"gt-dwarf2out.h\""}, {"sha": "4ee90ef1ae97c6f846b96b227e33a92ebc672396", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 33, "deletions": 111, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -143,13 +143,16 @@ rtx const_int_rtx[MAX_SAVED_CONST_INT * 2 + 1];\n /* A hash table storing CONST_INTs whose absolute value is greater\n    than MAX_SAVED_CONST_INT.  */\n \n-static htab_t const_int_htab;\n+static GTY ((if_marked (\"ggc_marked_p\"), param_is (struct rtx_def)))\n+     htab_t const_int_htab;\n \n /* A hash table storing memory attribute structures.  */\n-static htab_t mem_attrs_htab;\n+static GTY ((if_marked (\"ggc_marked_p\"), param_is (struct mem_attrs)))\n+     htab_t mem_attrs_htab;\n \n /* A hash table storing all CONST_DOUBLEs.  */\n-static htab_t const_double_htab;\n+static GTY ((if_marked (\"ggc_marked_p\"), param_is (struct rtx_def)))\n+     htab_t const_double_htab;\n \n #define first_insn (cfun->emit->x_first_insn)\n #define last_insn (cfun->emit->x_last_insn)\n@@ -161,7 +164,6 @@ static htab_t const_double_htab;\n static rtx make_jump_insn_raw\t\tPARAMS ((rtx));\n static rtx make_call_insn_raw\t\tPARAMS ((rtx));\n static rtx find_line_note\t\tPARAMS ((rtx));\n-static void mark_sequence_stack         PARAMS ((struct sequence_stack *));\n static rtx change_address_1\t\tPARAMS ((rtx, enum machine_mode, rtx,\n \t\t\t\t\t\t int));\n static void unshare_all_rtl_1\t\tPARAMS ((rtx));\n@@ -178,7 +180,6 @@ static rtx lookup_const_double\t\tPARAMS ((rtx));\n static hashval_t mem_attrs_htab_hash    PARAMS ((const void *));\n static int mem_attrs_htab_eq            PARAMS ((const void *,\n \t\t\t\t\t\t const void *));\n-static void mem_attrs_mark\t\tPARAMS ((const void *));\n static mem_attrs *get_mem_attrs\t\tPARAMS ((HOST_WIDE_INT, tree, rtx,\n \t\t\t\t\t\t rtx, unsigned int,\n \t\t\t\t\t\t enum machine_mode));\n@@ -273,25 +274,6 @@ mem_attrs_htab_eq (x, y)\n \t  && p->size == q->size && p->align == q->align);\n }\n \n-/* This routine is called when we determine that we need a mem_attrs entry.\n-   It marks the associated decl and RTL as being used, if present.  */\n-\n-static void\n-mem_attrs_mark (x)\n-     const void *x;\n-{\n-  mem_attrs *p = (mem_attrs *) x;\n-\n-  if (p->expr)\n-    ggc_mark_tree (p->expr);\n-\n-  if (p->offset)\n-    ggc_mark_rtx (p->offset);\n-\n-  if (p->size)\n-    ggc_mark_rtx (p->size);\n-}\n-\n /* Allocate a new mem_attrs structure and insert it into the hash table if\n    one identical to it is not already in the table.  We are doing this for\n    MEM of mode MODE.  */\n@@ -811,17 +793,17 @@ gen_reg_rtx (mode)\n       rtx *new1;\n       tree *new2;\n \n-      new = xrealloc (f->emit->regno_pointer_align, old_size * 2);\n+      new = ggc_realloc (f->emit->regno_pointer_align, old_size * 2);\n       memset (new + old_size, 0, old_size);\n       f->emit->regno_pointer_align = (unsigned char *) new;\n \n-      new1 = (rtx *) xrealloc (f->emit->x_regno_reg_rtx,\n-\t\t\t       old_size * 2 * sizeof (rtx));\n+      new1 = (rtx *) ggc_realloc (f->emit->x_regno_reg_rtx,\n+\t\t\t\t  old_size * 2 * sizeof (rtx));\n       memset (new1 + old_size, 0, old_size * sizeof (rtx));\n       regno_reg_rtx = new1;\n \n-      new2 = (tree *) xrealloc (f->emit->regno_decl,\n-\t\t\t\told_size * 2 * sizeof (tree));\n+      new2 = (tree *) ggc_realloc (f->emit->regno_decl,\n+\t\t\t\t   old_size * 2 * sizeof (tree));\n       memset (new2 + old_size, 0, old_size * sizeof (tree));\n       f->emit->regno_decl = new2;\n \n@@ -2237,21 +2219,6 @@ restore_emit_status (p)\n {\n   last_label_num = 0;\n }\n-\n-/* Clear out all parts of the state in F that can safely be discarded\n-   after the function has been compiled, to let garbage collection\n-   reclaim the memory.  */\n-\n-void\n-free_emit_status (f)\n-     struct function *f;\n-{\n-  free (f->emit->x_regno_reg_rtx);\n-  free (f->emit->regno_pointer_align);\n-  free (f->emit->regno_decl);\n-  free (f->emit);\n-  f->emit = NULL;\n-}\n \f\n /* Go through all the RTL insn bodies and copy any invalid shared\n    structure.  This routine should only be called once.  */\n@@ -4436,6 +4403,9 @@ emit (x)\n     abort ();\n }\n \f\n+/* Space for free sequence stack entries.  */\n+static GTY ((deletable (\"\"))) struct sequence_stack *free_sequence_stack;\n+\n /* Begin emitting insns to a sequence which can be packaged in an\n    RTL_EXPR.  If this sequence will contain something that might cause\n    the compiler to pop arguments to function calls (because those\n@@ -4449,7 +4419,13 @@ start_sequence ()\n {\n   struct sequence_stack *tem;\n \n-  tem = (struct sequence_stack *) xmalloc (sizeof (struct sequence_stack));\n+  if (free_sequence_stack != NULL)\n+    {\n+      tem = free_sequence_stack;\n+      free_sequence_stack = tem->next;\n+    }\n+  else\n+    tem = (struct sequence_stack *) ggc_alloc (sizeof (struct sequence_stack));\n \n   tem->next = seq_stack;\n   tem->first = first_insn;\n@@ -4566,7 +4542,9 @@ end_sequence ()\n   seq_rtl_expr = tem->sequence_rtl_expr;\n   seq_stack = tem->next;\n \n-  free (tem);\n+  memset (tem, 0, sizeof (*tem));\n+  tem->next = free_sequence_stack;\n+  free_sequence_stack = tem;\n }\n \n /* This works like end_sequence, but records the old sequence in FIRST\n@@ -4824,7 +4802,7 @@ init_emit ()\n {\n   struct function *f = cfun;\n \n-  f->emit = (struct emit_status *) xmalloc (sizeof (struct emit_status));\n+  f->emit = (struct emit_status *) ggc_alloc (sizeof (struct emit_status));\n   first_insn = NULL;\n   last_insn = NULL;\n   seq_rtl_expr = NULL;\n@@ -4841,14 +4819,16 @@ init_emit ()\n   f->emit->regno_pointer_align_length = LAST_VIRTUAL_REGISTER + 101;\n \n   f->emit->regno_pointer_align\n-    = (unsigned char *) xcalloc (f->emit->regno_pointer_align_length,\n-\t\t\t\t sizeof (unsigned char));\n+    = (unsigned char *) ggc_alloc_cleared (f->emit->regno_pointer_align_length\n+\t\t\t\t\t   * sizeof (unsigned char));\n \n   regno_reg_rtx\n-    = (rtx *) xcalloc (f->emit->regno_pointer_align_length, sizeof (rtx));\n+    = (rtx *) ggc_alloc_cleared (f->emit->regno_pointer_align_length\n+\t\t\t\t * sizeof (rtx));\n \n   f->emit->regno_decl\n-    = (tree *) xcalloc (f->emit->regno_pointer_align_length, sizeof (tree));\n+    = (tree *) ggc_alloc_cleared (f->emit->regno_pointer_align_length\n+\t\t\t\t  * sizeof (tree));\n \n   /* Put copies of all the virtual register rtx into regno_reg_rtx.  */\n   init_virtual_regs (f->emit);\n@@ -4884,46 +4864,6 @@ init_emit ()\n #endif\n }\n \n-/* Mark SS for GC.  */\n-\n-static void\n-mark_sequence_stack (ss)\n-     struct sequence_stack *ss;\n-{\n-  while (ss)\n-    {\n-      ggc_mark_rtx (ss->first);\n-      ggc_mark_tree (ss->sequence_rtl_expr);\n-      ss = ss->next;\n-    }\n-}\n-\n-/* Mark ES for GC.  */\n-\n-void\n-mark_emit_status (es)\n-     struct emit_status *es;\n-{\n-  rtx *r;\n-  tree *t;\n-  int i;\n-\n-  if (es == 0)\n-    return;\n-\n-  for (i = es->regno_pointer_align_length, r = es->x_regno_reg_rtx,\n-       t = es->regno_decl;\n-       i > 0; --i, ++r, ++t)\n-    {\n-      ggc_mark_rtx (*r);\n-      ggc_mark_tree (*t);\n-    }\n-\n-  mark_sequence_stack (es->sequence_stack);\n-  ggc_mark_tree (es->sequence_rtl_expr);\n-  ggc_mark_rtx (es->x_first_insn);\n-}\n-\n /* Generate the constant 0.  */\n \n static rtx\n@@ -4966,15 +4906,12 @@ init_emit_once (line_numbers)\n      tables.  */\n   const_int_htab = htab_create (37, const_int_htab_hash,\n \t\t\t\tconst_int_htab_eq, NULL);\n-  ggc_add_deletable_htab (const_int_htab, 0, 0);\n \n   const_double_htab = htab_create (37, const_double_htab_hash,\n \t\t\t\t   const_double_htab_eq, NULL);\n-  ggc_add_deletable_htab (const_double_htab, 0, 0);\n \n   mem_attrs_htab = htab_create (37, mem_attrs_htab_hash,\n \t\t\t\tmem_attrs_htab_eq, NULL);\n-  ggc_add_deletable_htab (mem_attrs_htab, 0, mem_attrs_mark);\n \n   no_line_numbers = ! line_numbers;\n \n@@ -5029,9 +4966,6 @@ init_emit_once (line_numbers)\n     gen_raw_REG (Pmode, VIRTUAL_OUTGOING_ARGS_REGNUM);\n   virtual_cfa_rtx = gen_raw_REG (Pmode, VIRTUAL_CFA_REGNUM);\n \n-  /* These rtx must be roots if GC is enabled.  */\n-  ggc_add_rtx_root (global_rtl, GR_MAX);\n-\n #ifdef INIT_EXPANDERS\n   /* This is to initialize {init|mark|free}_machine_status before the first\n      call to push_function_context_to.  This is needed by the Chill front\n@@ -5047,7 +4981,6 @@ init_emit_once (line_numbers)\n   for (i = - MAX_SAVED_CONST_INT; i <= MAX_SAVED_CONST_INT; i++)\n     const_int_rtx[i + MAX_SAVED_CONST_INT] =\n       gen_rtx_raw_CONST_INT (VOIDmode, i);\n-  ggc_add_rtx_root (const_int_rtx, 2 * MAX_SAVED_CONST_INT + 1);\n \n   if (STORE_FLAG_VALUE >= - MAX_SAVED_CONST_INT\n       && STORE_FLAG_VALUE <= MAX_SAVED_CONST_INT)\n@@ -5100,12 +5033,6 @@ init_emit_once (line_numbers)\n   if (STORE_FLAG_VALUE == 1)\n     const_tiny_rtx[1][(int) BImode] = const1_rtx;\n \n-  /* For bounded pointers, `&const_tiny_rtx[0][0]' is not the same as\n-     `(rtx *) const_tiny_rtx'.  The former has bounds that only cover\n-     `const_tiny_rtx[0]', whereas the latter has bounds that cover all.  */\n-  ggc_add_rtx_root ((rtx *) const_tiny_rtx, sizeof const_tiny_rtx / sizeof (rtx));\n-  ggc_add_rtx_root (&const_true_rtx, 1);\n-\n #ifdef RETURN_ADDRESS_POINTER_REGNUM\n   return_address_pointer_rtx\n     = gen_raw_REG (Pmode, RETURN_ADDRESS_POINTER_REGNUM);\n@@ -5152,13 +5079,6 @@ init_emit_once (line_numbers)\n \n   if (PIC_OFFSET_TABLE_REGNUM != INVALID_REGNUM)\n     pic_offset_table_rtx = gen_raw_REG (Pmode, PIC_OFFSET_TABLE_REGNUM);\n-\n-  ggc_add_rtx_root (&pic_offset_table_rtx, 1);\n-  ggc_add_rtx_root (&struct_value_rtx, 1);\n-  ggc_add_rtx_root (&struct_value_incoming_rtx, 1);\n-  ggc_add_rtx_root (&static_chain_rtx, 1);\n-  ggc_add_rtx_root (&static_chain_incoming_rtx, 1);\n-  ggc_add_rtx_root (&return_address_pointer_rtx, 1);\n }\n \f\n /* Query and clear/ restore no_line_numbers.  This is used by the\n@@ -5249,3 +5169,5 @@ emit_copy_of_insn_after (insn, after)\n     }\n   return new;\n }\n+\n+#include \"gt-emit-rtl.h\""}, {"sha": "53db90e8c0a5c95f7a9710e6c377eba634cf60c0", "filename": "gcc/except.c", "status": "modified", "additions": 57, "deletions": 282, "changes": 339, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -100,28 +100,27 @@ tree (*lang_eh_runtime_type) PARAMS ((tree));\n \n /* A hash table of label to region number.  */\n \n-struct ehl_map_entry\n+struct ehl_map_entry GTY(())\n {\n   rtx label;\n   struct eh_region *region;\n };\n \n-static htab_t exception_handler_label_map;\n-\n static int call_site_base;\n static unsigned int sjlj_funcdef_number;\n-static htab_t type_to_runtime_map;\n+static GTY ((param_is (union tree_node)))\n+  htab_t type_to_runtime_map;\n \n /* Describe the SjLj_Function_Context structure.  */\n-static tree sjlj_fc_type_node;\n+static GTY(()) tree sjlj_fc_type_node;\n static int sjlj_fc_call_site_ofs;\n static int sjlj_fc_data_ofs;\n static int sjlj_fc_personality_ofs;\n static int sjlj_fc_lsda_ofs;\n static int sjlj_fc_jbuf_ofs;\n \f\n /* Describes one exception region.  */\n-struct eh_region\n+struct eh_region GTY(())\n {\n   /* The immediately surrounding region.  */\n   struct eh_region *outer;\n@@ -151,50 +150,50 @@ struct eh_region\n   } type;\n \n   /* Holds the action to perform based on the preceding type.  */\n-  union {\n+  union eh_region_u {\n     /* A list of catch blocks, a surrounding try block,\n        and the label for continuing after a catch.  */\n-    struct {\n+    struct eh_region_u_try {\n       struct eh_region *catch;\n       struct eh_region *last_catch;\n       struct eh_region *prev_try;\n       rtx continue_label;\n-    } try;\n+    } GTY ((tag (\"ERT_TRY\"))) try;\n \n     /* The list through the catch handlers, the list of type objects\n        matched, and the list of associated filters.  */\n-    struct {\n+    struct eh_region_u_catch {\n       struct eh_region *next_catch;\n       struct eh_region *prev_catch;\n       tree type_list;\n       tree filter_list;\n-    } catch;\n+    } GTY ((tag (\"ERT_CATCH\"))) catch;\n \n     /* A tree_list of allowed types.  */\n-    struct {\n+    struct eh_region_u_allowed {\n       tree type_list;\n       int filter;\n-    } allowed;\n+    } GTY ((tag (\"ERT_ALLOWED_EXCEPTIONS\"))) allowed;\n \n     /* The type given by a call to \"throw foo();\", or discovered\n        for a throw.  */\n-    struct {\n+    struct eh_region_u_throw {\n       tree type;\n-    } throw;\n+    } GTY ((tag (\"ERT_THROW\"))) throw;\n \n     /* Retain the cleanup expression even after expansion so that\n        we can match up fixup regions.  */\n-    struct {\n+    struct eh_region_u_cleanup {\n       tree exp;\n-    } cleanup;\n+    } GTY ((tag (\"ERT_CLEANUP\"))) cleanup;\n \n     /* The real region (by expression and by pointer) that fixup code\n        should live in.  */\n-    struct {\n+    struct eh_region_u_fixup {\n       tree cleanup_exp;\n       struct eh_region *real_region;\n-    } fixup;\n-  } u;\n+    } GTY ((tag (\"ERT_FIXUP\"))) fixup;\n+  } GTY ((desc (\"%0.type\"))) u;\n \n   /* Entry point for this region's handler before landing pads are built.  */\n   rtx label;\n@@ -210,14 +209,20 @@ struct eh_region\n   rtx resume;\n };\n \n+struct call_site_record GTY(())\n+{\n+  rtx landing_pad;\n+  int action;\n+};\n+\n /* Used to save exception status for each function.  */\n-struct eh_status\n+struct eh_status GTY(())\n {\n   /* The tree of all regions for this function.  */\n   struct eh_region *region_tree;\n \n   /* The same information as an indexable array.  */\n-  struct eh_region **region_array;\n+  struct eh_region ** GTY ((length (\"%h.last_region_number\"))) region_array;\n \n   /* The most recently open region.  */\n   struct eh_region *cur_region;\n@@ -235,11 +240,10 @@ struct eh_status\n   varray_type ehspec_data;\n   varray_type action_record_data;\n \n-  struct call_site_record\n-  {\n-    rtx landing_pad;\n-    int action;\n-  } *call_site_data;\n+  htab_t GTY ((param_is (struct ehl_map_entry))) exception_handler_label_map;\n+\n+  struct call_site_record * GTY ((length (\"%h.call_site_data_used\"))) \n+    call_site_data;\n   int call_site_data_used;\n   int call_site_data_size;\n \n@@ -252,17 +256,9 @@ struct eh_status\n };\n \n \f\n-static void mark_eh_region\t\t\tPARAMS ((struct eh_region *));\n-static int mark_ehl_map_entry\t\t\tPARAMS ((PTR *, PTR));\n-static void mark_ehl_map\t\t\tPARAMS ((void *));\n-\n-static void free_region\t\t\t\tPARAMS ((struct eh_region *));\n-\n static int t2r_eq\t\t\t\tPARAMS ((const PTR,\n \t\t\t\t\t\t\t const PTR));\n static hashval_t t2r_hash\t\t\tPARAMS ((const PTR));\n-static int t2r_mark_1\t\t\t\tPARAMS ((PTR *, PTR));\n-static void t2r_mark\t\t\t\tPARAMS ((PTR));\n static void add_type_for_runtime\t\tPARAMS ((tree));\n static tree lookup_type_for_runtime\t\tPARAMS ((tree));\n \n@@ -386,13 +382,10 @@ doing_eh (do_warn)\n void\n init_eh ()\n {\n-  ggc_add_root (&exception_handler_label_map, 1, 1, mark_ehl_map);\n-\n   if (! flag_exceptions)\n     return;\n \n-  type_to_runtime_map = htab_create (31, t2r_hash, t2r_eq, NULL);\n-  ggc_add_root (&type_to_runtime_map, 1, sizeof (htab_t), t2r_mark);\n+  type_to_runtime_map = htab_create_ggc (31, t2r_hash, t2r_eq, NULL);\n \n   /* Create the SjLj_Function_Context structure.  This should match\n      the definition in unwind-sjlj.c.  */\n@@ -401,7 +394,6 @@ init_eh ()\n       tree f_jbuf, f_per, f_lsda, f_prev, f_cs, f_data, tmp;\n \n       sjlj_fc_type_node = (*lang_hooks.types.make_type) (RECORD_TYPE);\n-      ggc_add_tree_root (&sjlj_fc_type_node, 1);\n \n       f_prev = build_decl (FIELD_DECL, get_identifier (\"__prev\"),\n \t\t\t   build_pointer_type (sjlj_fc_type_node));\n@@ -484,209 +476,9 @@ init_eh ()\n void\n init_eh_for_function ()\n {\n-  cfun->eh = (struct eh_status *) xcalloc (1, sizeof (struct eh_status));\n-}\n-\n-/* Mark EH for GC.  */\n-\n-static void\n-mark_eh_region (region)\n-     struct eh_region *region;\n-{\n-  if (! region)\n-    return;\n-\n-  switch (region->type)\n-    {\n-    case ERT_UNKNOWN:\n-      /* This can happen if a nested function is inside the body of a region\n-\t and we do a GC as part of processing it.  */\n-      break;\n-    case ERT_CLEANUP:\n-      ggc_mark_tree (region->u.cleanup.exp);\n-      break;\n-    case ERT_TRY:\n-      ggc_mark_rtx (region->u.try.continue_label);\n-      break;\n-    case ERT_CATCH:\n-      ggc_mark_tree (region->u.catch.type_list);\n-      ggc_mark_tree (region->u.catch.filter_list);\n-      break;\n-    case ERT_ALLOWED_EXCEPTIONS:\n-      ggc_mark_tree (region->u.allowed.type_list);\n-      break;\n-    case ERT_MUST_NOT_THROW:\n-      break;\n-    case ERT_THROW:\n-      ggc_mark_tree (region->u.throw.type);\n-      break;\n-    case ERT_FIXUP:\n-      ggc_mark_tree (region->u.fixup.cleanup_exp);\n-      break;\n-    default:\n-      abort ();\n-    }\n-\n-  ggc_mark_rtx (region->label);\n-  ggc_mark_rtx (region->resume);\n-  ggc_mark_rtx (region->landing_pad);\n-  ggc_mark_rtx (region->post_landing_pad);\n-}\n-\n-static int\n-mark_ehl_map_entry (pentry, data)\n-     PTR *pentry;\n-     PTR data ATTRIBUTE_UNUSED;\n-{\n-  struct ehl_map_entry *entry = *(struct ehl_map_entry **) pentry;\n-  ggc_mark_rtx (entry->label);\n-  return 1;\n-}\n-\n-static void\n-mark_ehl_map (pp)\n-    void *pp;\n-{\n-  htab_t map = *(htab_t *) pp;\n-  if (map)\n-    htab_traverse (map, mark_ehl_map_entry, NULL);\n+  cfun->eh = (struct eh_status *) \n+    ggc_alloc_cleared (sizeof (struct eh_status));\n }\n-\n-void\n-mark_eh_status (eh)\n-     struct eh_status *eh;\n-{\n-  int i;\n-\n-  if (eh == 0)\n-    return;\n-\n-  /* If we've called collect_eh_region_array, use it.  Otherwise walk\n-     the tree non-recursively.  */\n-  if (eh->region_array)\n-    {\n-      for (i = eh->last_region_number; i > 0; --i)\n-\t{\n-\t  struct eh_region *r = eh->region_array[i];\n-\t  if (r && r->region_number == i)\n-\t    mark_eh_region (r);\n-\t}\n-    }\n-  else if (eh->region_tree)\n-    {\n-      struct eh_region *r = eh->region_tree;\n-      while (1)\n-\t{\n-\t  mark_eh_region (r);\n-\t  if (r->inner)\n-\t    r = r->inner;\n-\t  else if (r->next_peer)\n-\t    r = r->next_peer;\n-\t  else\n-\t    {\n-\t      do {\n-\t\tr = r->outer;\n-\t\tif (r == NULL)\n-\t\t  goto tree_done;\n-\t      } while (r->next_peer == NULL);\n-\t      r = r->next_peer;\n-\t    }\n-\t}\n-    tree_done:;\n-    }\n-\n-  ggc_mark_rtx (eh->filter);\n-  ggc_mark_rtx (eh->exc_ptr);\n-  ggc_mark_tree_varray (eh->ttype_data);\n-\n-  if (eh->call_site_data)\n-    {\n-      for (i = eh->call_site_data_used - 1; i >= 0; --i)\n-\tggc_mark_rtx (eh->call_site_data[i].landing_pad);\n-    }\n-\n-  ggc_mark_rtx (eh->ehr_stackadj);\n-  ggc_mark_rtx (eh->ehr_handler);\n-  ggc_mark_rtx (eh->ehr_label);\n-\n-  ggc_mark_rtx (eh->sjlj_fc);\n-  ggc_mark_rtx (eh->sjlj_exit_after);\n-}\n-\n-static inline void\n-free_region (r)\n-     struct eh_region *r;\n-{\n-  /* Note that the aka bitmap is freed by regset_release_memory.  But if\n-     we ever replace with a non-obstack implementation, this would be\n-     the place to do it.  */\n-  free (r);\n-}\n-\n-void\n-free_eh_status (f)\n-     struct function *f;\n-{\n-  struct eh_status *eh = f->eh;\n-\n-  if (eh->region_array)\n-    {\n-      int i;\n-      for (i = eh->last_region_number; i > 0; --i)\n-\t{\n-\t  struct eh_region *r = eh->region_array[i];\n-\t  /* Mind we don't free a region struct more than once.  */\n-\t  if (r && r->region_number == i)\n-\t    free_region (r);\n-\t}\n-      free (eh->region_array);\n-    }\n-  else if (eh->region_tree)\n-    {\n-      struct eh_region *next, *r = eh->region_tree;\n-      while (1)\n-\t{\n-\t  if (r->inner)\n-\t    r = r->inner;\n-\t  else if (r->next_peer)\n-\t    {\n-\t      next = r->next_peer;\n-\t      free_region (r);\n-\t      r = next;\n-\t    }\n-\t  else\n-\t    {\n-\t      do {\n-\t        next = r->outer;\n-\t        free_region (r);\n-\t        r = next;\n-\t\tif (r == NULL)\n-\t\t  goto tree_done;\n-\t      } while (r->next_peer == NULL);\n-\t      next = r->next_peer;\n-\t      free_region (r);\n-\t      r = next;\n-\t    }\n-\t}\n-    tree_done:;\n-    }\n-\n-  VARRAY_FREE (eh->ttype_data);\n-  VARRAY_FREE (eh->ehspec_data);\n-  VARRAY_FREE (eh->action_record_data);\n-  if (eh->call_site_data)\n-    free (eh->call_site_data);\n-\n-  free (eh);\n-  f->eh = NULL;\n-\n-  if (exception_handler_label_map)\n-    {\n-      htab_delete (exception_handler_label_map);\n-      exception_handler_label_map = NULL;\n-    }\n-}\n-\n \f\n /* Start an exception handling region.  All instructions emitted\n    after this point are considered to be part of the region until\n@@ -703,7 +495,7 @@ expand_eh_region_start ()\n     return;\n \n   /* Insert a new blank region as a leaf in the tree.  */\n-  new_region = (struct eh_region *) xcalloc (1, sizeof (*new_region));\n+  new_region = (struct eh_region *) ggc_alloc_cleared (sizeof (*new_region));\n   cur_region = cfun->eh->cur_region;\n   new_region->outer = cur_region;\n   if (cur_region)\n@@ -1076,7 +868,8 @@ collect_eh_region_array ()\n   if (! i)\n     return;\n \n-  array = xcalloc (cfun->eh->last_region_number + 1, sizeof (*array));\n+  array = ggc_alloc_cleared ((cfun->eh->last_region_number + 1)\n+\t\t\t     * sizeof (*array));\n   cfun->eh->region_array = array;\n \n   while (1)\n@@ -1377,12 +1170,12 @@ add_ehl_entry (label, region)\n \n   LABEL_PRESERVE_P (label) = 1;\n \n-  entry = (struct ehl_map_entry *) xmalloc (sizeof (*entry));\n+  entry = (struct ehl_map_entry *) ggc_alloc (sizeof (*entry));\n   entry->label = label;\n   entry->region = region;\n \n   slot = (struct ehl_map_entry **)\n-    htab_find_slot (exception_handler_label_map, entry, INSERT);\n+    htab_find_slot (cfun->eh->exception_handler_label_map, entry, INSERT);\n \n   /* Before landing pad creation, each exception handler has its own\n      label.  After landing pad creation, the exception handlers may\n@@ -1400,23 +1193,22 @@ ehl_free (pentry)\n {\n   struct ehl_map_entry *entry = (struct ehl_map_entry *)pentry;\n   LABEL_PRESERVE_P (entry->label) = 0;\n-  free (entry);\n }\n \n void\n find_exception_handler_labels ()\n {\n   int i;\n \n-  if (exception_handler_label_map)\n-    htab_empty (exception_handler_label_map);\n+  if (cfun->eh->exception_handler_label_map)\n+    htab_empty (cfun->eh->exception_handler_label_map);\n   else\n     {\n       /* ??? The expansion factor here (3/2) must be greater than the htab\n \t occupancy factor (4/3) to avoid unnecessary resizing.  */\n-      exception_handler_label_map\n-\t= htab_create (cfun->eh->last_region_number * 3 / 2,\n-\t\t       ehl_hash, ehl_eq, ehl_free);\n+      cfun->eh->exception_handler_label_map\n+        = htab_create_ggc (cfun->eh->last_region_number * 3 / 2,\n+\t\t\t   ehl_hash, ehl_eq, NULL);\n     }\n \n   if (cfun->eh->region_tree == NULL)\n@@ -1468,7 +1260,7 @@ duplicate_eh_region_1 (o, map)\n      struct inline_remap *map;\n {\n   struct eh_region *n\n-    = (struct eh_region *) xcalloc (1, sizeof (struct eh_region));\n+    = (struct eh_region *) ggc_alloc_cleared (sizeof (struct eh_region));\n \n   n->region_number = o->region_number + cfun->eh->last_region_number;\n   n->type = o->type;\n@@ -1633,23 +1425,6 @@ t2r_hash (pentry)\n   return TYPE_HASH (TREE_PURPOSE (entry));\n }\n \n-static int\n-t2r_mark_1 (slot, data)\n-     PTR *slot;\n-     PTR data ATTRIBUTE_UNUSED;\n-{\n-  tree contents = (tree) *slot;\n-  ggc_mark_tree (contents);\n-  return 1;\n-}\n-\n-static void\n-t2r_mark (addr)\n-     PTR addr;\n-{\n-  htab_traverse (*(htab_t *)addr, t2r_mark_1, NULL);\n-}\n-\n static void\n add_type_for_runtime (type)\n      tree type;\n@@ -1681,7 +1456,7 @@ lookup_type_for_runtime (type)\n \f\n /* Represent an entry in @TTypes for either catch actions\n    or exception filter actions.  */\n-struct ttypes_filter\n+struct ttypes_filter GTY(())\n {\n   tree t;\n   int filter;\n@@ -2559,16 +2334,16 @@ remove_exception_handler_label (label)\n \n   /* If exception_handler_label_map was not built yet,\n      there is nothing to do.  */\n-  if (exception_handler_label_map == NULL)\n+  if (cfun->eh->exception_handler_label_map == NULL)\n     return;\n \n   tmp.label = label;\n   slot = (struct ehl_map_entry **)\n-    htab_find_slot (exception_handler_label_map, &tmp, NO_INSERT);\n+    htab_find_slot (cfun->eh->exception_handler_label_map, &tmp, NO_INSERT);\n   if (! slot)\n     abort ();\n \n-  htab_clear_slot (exception_handler_label_map, (void **) slot);\n+  htab_clear_slot (cfun->eh->exception_handler_label_map, (void **) slot);\n }\n \n /* Splice REGION from the region tree etc.  */\n@@ -2598,7 +2373,7 @@ remove_eh_handler (region)\n   if (outer)\n     {\n       if (!outer->aka)\n-\touter->aka = BITMAP_XMALLOC ();\n+        outer->aka = BITMAP_GGC_ALLOC ();\n       if (region->aka)\n \tbitmap_a_or_b (outer->aka, outer->aka, region->aka);\n       bitmap_set_bit (outer->aka, region->region_number);\n@@ -2657,8 +2432,6 @@ remove_eh_handler (region)\n \t    remove_eh_handler (try);\n \t}\n     }\n-\n-  free_region (region);\n }\n \n /* LABEL heads a basic block that is about to be deleted.  If this\n@@ -2681,7 +2454,7 @@ maybe_remove_eh_handler (label)\n \n   tmp.label = label;\n   slot = (struct ehl_map_entry **)\n-    htab_find_slot (exception_handler_label_map, &tmp, NO_INSERT);\n+    htab_find_slot (cfun->eh->exception_handler_label_map, &tmp, NO_INSERT);\n   if (! slot)\n     return;\n   region = (*slot)->region;\n@@ -2694,7 +2467,7 @@ maybe_remove_eh_handler (label)\n      are no more contained calls, which we don't see here.  */\n   if (region->type == ERT_MUST_NOT_THROW)\n     {\n-      htab_clear_slot (exception_handler_label_map, (void **) slot);\n+      htab_clear_slot (cfun->eh->exception_handler_label_map, (void **) slot);\n       region->label = NULL_RTX;\n     }\n   else\n@@ -2708,7 +2481,7 @@ void\n for_each_eh_label (callback)\n      void (*callback) PARAMS ((rtx));\n {\n-  htab_traverse (exception_handler_label_map, for_each_eh_label_1,\n+  htab_traverse (cfun->eh->exception_handler_label_map, for_each_eh_label_1,\n \t\t (void *)callback);\n }\n \n@@ -2727,7 +2500,7 @@ for_each_eh_label_1 (pentry, data)\n /* This section describes CFG exception edges for flow.  */\n \n /* For communicating between calls to reachable_next_level.  */\n-struct reachable_info\n+struct reachable_info GTY(())\n {\n   tree types_caught;\n   tree types_allowed;\n@@ -3507,7 +3280,7 @@ add_call_site (landing_pad, action)\n     {\n       size = (size ? size * 2 : 64);\n       data = (struct call_site_record *)\n-\txrealloc (data, sizeof (*data) * size);\n+\tggc_realloc (data, sizeof (*data) * size);\n       cfun->eh->call_site_data = data;\n       cfun->eh->call_site_data_size = size;\n     }\n@@ -3982,3 +3755,5 @@ output_function_exception_table ()\n   if (USING_SJLJ_EXCEPTIONS)\n     sjlj_funcdef_number += 1;\n }\n+\n+#include \"gt-except.h\""}, {"sha": "2846636ec202860f35e70e8ebb12602f5a9a7f0b", "filename": "gcc/explow.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -1422,14 +1422,13 @@ allocate_dynamic_stack_space (size, target, known_align)\n    run-time routine to call to check the stack, so provide a mechanism for\n    calling that routine.  */\n \n-static rtx stack_check_libfunc;\n+static GTY(()) rtx stack_check_libfunc;\n \n void\n set_stack_check_libfunc (libfunc)\n      rtx libfunc;\n {\n   stack_check_libfunc = libfunc;\n-  ggc_add_rtx_root (&stack_check_libfunc, 1);\n }\n \f\n /* Emit one stack probe at ADDRESS, an address within the stack.  */\n@@ -1684,3 +1683,6 @@ rtx_to_tree_code (code)\n     }\n   return ((int) tcode);\n }\n+\n+#include \"gt-explow.h\"\n+"}, {"sha": "e9cb241153049a3ec398b184335ddecae98408ca", "filename": "gcc/expr.c", "status": "modified", "additions": 31, "deletions": 47, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -298,7 +298,7 @@ init_expr_once ()\n void\n init_expr ()\n {\n-  cfun->expr = (struct expr_status *) xmalloc (sizeof (struct expr_status));\n+  cfun->expr = (struct expr_status *) ggc_alloc (sizeof (struct expr_status));\n \n   pending_chain = 0;\n   pending_stack_adjust = 0;\n@@ -309,26 +309,6 @@ init_expr ()\n   forced_labels = 0;\n }\n \n-void\n-mark_expr_status (p)\n-     struct expr_status *p;\n-{\n-  if (p == NULL)\n-    return;\n-\n-  ggc_mark_rtx (p->x_saveregs_value);\n-  ggc_mark_rtx (p->x_apply_args_value);\n-  ggc_mark_rtx (p->x_forced_labels);\n-}\n-\n-void\n-free_expr_status (f)\n-     struct function *f;\n-{\n-  free (f->expr);\n-  f->expr = NULL;\n-}\n-\n /* Small sanity check that the queue is empty at the end of a function.  */\n \n void\n@@ -1650,14 +1630,14 @@ move_by_pieces_1 (genfun, mode, data)\n    Return the address of the new block, if memcpy is called and returns it,\n    0 otherwise.  */\n \n+static GTY(()) tree block_move_fn;\n rtx\n emit_block_move (x, y, size)\n      rtx x, y;\n      rtx size;\n {\n   rtx retval = 0;\n #ifdef TARGET_MEM_FUNCTIONS\n-  static tree fn;\n   tree call_expr, arg_list;\n #endif\n   unsigned int align = MIN (MEM_ALIGN (x), MEM_ALIGN (y));\n@@ -1781,23 +1761,22 @@ emit_block_move (x, y, size)\n \n \t So instead of using a libcall sequence we build up a suitable\n \t CALL_EXPR and expand the call in the normal fashion.  */\n-      if (fn == NULL_TREE)\n+      if (block_move_fn == NULL_TREE)\n \t{\n \t  tree fntype;\n \n \t  /* This was copied from except.c, I don't know if all this is\n \t     necessary in this context or not.  */\n-\t  fn = get_identifier (\"memcpy\");\n+\t  block_move_fn = get_identifier (\"memcpy\");\n \t  fntype = build_pointer_type (void_type_node);\n \t  fntype = build_function_type (fntype, NULL_TREE);\n-\t  fn = build_decl (FUNCTION_DECL, fn, fntype);\n-\t  ggc_add_tree_root (&fn, 1);\n-\t  DECL_EXTERNAL (fn) = 1;\n-\t  TREE_PUBLIC (fn) = 1;\n-\t  DECL_ARTIFICIAL (fn) = 1;\n-\t  TREE_NOTHROW (fn) = 1;\n-\t  make_decl_rtl (fn, NULL);\n-\t  assemble_external (fn);\n+\t  block_move_fn = build_decl (FUNCTION_DECL, block_move_fn, fntype);\n+\t  DECL_EXTERNAL (block_move_fn) = 1;\n+\t  TREE_PUBLIC (block_move_fn) = 1;\n+\t  DECL_ARTIFICIAL (block_move_fn) = 1;\n+\t  TREE_NOTHROW (block_move_fn) = 1;\n+\t  make_decl_rtl (block_move_fn, NULL);\n+\t  assemble_external (block_move_fn);\n \t}\n \n       /* We need to make an argument list for the function call.\n@@ -1815,8 +1794,10 @@ emit_block_move (x, y, size)\n       TREE_CHAIN (TREE_CHAIN (TREE_CHAIN (arg_list))) = NULL_TREE;\n \n       /* Now we have to build up the CALL_EXPR itself.  */\n-      call_expr = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (fn)), fn);\n-      call_expr = build (CALL_EXPR, TREE_TYPE (TREE_TYPE (fn)),\n+      call_expr = build1 (ADDR_EXPR, \n+\t\t\t  build_pointer_type (TREE_TYPE (block_move_fn)), \n+\t\t\t  block_move_fn);\n+      call_expr = build (CALL_EXPR, TREE_TYPE (TREE_TYPE (block_move_fn)),\n \t\t\t call_expr, arg_list, NULL_TREE);\n       TREE_SIDE_EFFECTS (call_expr) = 1;\n \n@@ -2606,13 +2587,13 @@ store_by_pieces_2 (genfun, mode, data)\n /* Write zeros through the storage of OBJECT.  If OBJECT has BLKmode, SIZE is\n    its length in bytes.  */\n \n+static GTY(()) tree block_clear_fn;\n rtx\n clear_storage (object, size)\n      rtx object;\n      rtx size;\n {\n #ifdef TARGET_MEM_FUNCTIONS\n-  static tree fn;\n   tree call_expr, arg_list;\n #endif\n   rtx retval = 0;\n@@ -2725,23 +2706,23 @@ clear_storage (object, size)\n \n \t     So instead of using a libcall sequence we build up a suitable\n \t     CALL_EXPR and expand the call in the normal fashion.  */\n-\t  if (fn == NULL_TREE)\n+\t  if (block_clear_fn == NULL_TREE)\n \t    {\n \t      tree fntype;\n \n \t      /* This was copied from except.c, I don't know if all this is\n \t\t necessary in this context or not.  */\n-\t      fn = get_identifier (\"memset\");\n+\t      block_clear_fn = get_identifier (\"memset\");\n \t      fntype = build_pointer_type (void_type_node);\n \t      fntype = build_function_type (fntype, NULL_TREE);\n-\t      fn = build_decl (FUNCTION_DECL, fn, fntype);\n-\t      ggc_add_tree_root (&fn, 1);\n-\t      DECL_EXTERNAL (fn) = 1;\n-\t      TREE_PUBLIC (fn) = 1;\n-\t      DECL_ARTIFICIAL (fn) = 1;\n-\t      TREE_NOTHROW (fn) = 1;\n-\t      make_decl_rtl (fn, NULL);\n-\t      assemble_external (fn);\n+\t      block_clear_fn = build_decl (FUNCTION_DECL, block_clear_fn,\n+\t\t\t\t\t   fntype);\n+\t      DECL_EXTERNAL (block_clear_fn) = 1;\n+\t      TREE_PUBLIC (block_clear_fn) = 1;\n+\t      DECL_ARTIFICIAL (block_clear_fn) = 1;\n+\t      TREE_NOTHROW (block_clear_fn) = 1;\n+\t      make_decl_rtl (block_clear_fn, NULL);\n+\t      assemble_external (block_clear_fn);\n \t    }\n \n \t  /* We need to make an argument list for the function call.\n@@ -2762,8 +2743,9 @@ clear_storage (object, size)\n \n \t  /* Now we have to build up the CALL_EXPR itself.  */\n \t  call_expr = build1 (ADDR_EXPR,\n-\t\t\t      build_pointer_type (TREE_TYPE (fn)), fn);\n-\t  call_expr = build (CALL_EXPR, TREE_TYPE (TREE_TYPE (fn)),\n+\t\t\t      build_pointer_type (TREE_TYPE (block_clear_fn)),\n+\t\t\t      block_clear_fn);\n+\t  call_expr = build (CALL_EXPR, TREE_TYPE (TREE_TYPE (block_clear_fn)),\n \t\t\t     call_expr, arg_list, NULL_TREE);\n \t  TREE_SIDE_EFFECTS (call_expr) = 1;\n \n@@ -10785,3 +10767,5 @@ try_tablejump (index_type, index_expr, minval, range,\n \t\ttable_label, default_label);\n   return 1;\n }\n+\n+#include \"gt-expr.h\""}, {"sha": "5ebefbad8bad5b322a804e826ca4cb4dbcbda2ba", "filename": "gcc/expr.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -369,10 +369,6 @@ extern void init_expr_once PARAMS ((void));\n /* This is run at the start of compiling a function.  */\n extern void init_expr PARAMS ((void));\n \n-/* This function is run once to initialize stor-layout.c.  */\n-\n-extern void init_stor_layout_once PARAMS ((void));\n-\n /* This is run at the end of compiling a function.  */\n extern void finish_expr_for_function PARAMS ((void));\n "}, {"sha": "f4634d166723abf81c400aa7cabb9f867f379000", "filename": "gcc/f/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Ff%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Ff%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2FChangeLog?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -1,3 +1,42 @@\n+2002-06-03  Geoffrey Keating  <geoffk@redhat.com>\n+\n+\t* Make-lang.in (f/com.o): Depend on debug.h.\n+\t* com.c: Include debug.h.\n+\t(LANG_HOOKS_MARK_TREE): Delete.\n+\t(struct lang_identifier): Use gengtype.\n+\t(union lang_tree_node): New.\n+\t(struct lang_decl): New dummy definition.\n+\t(struct lang_type): New dummy definition.\n+\t(ffe_mark_tree): Delete.\n+\n+\t* com.c (struct language_function): New dummy structure.\n+\n+\t* Make-lang.in: Add rules to generate gt-f-ste.h gtype-f.h; allow\n+\tfor filename changes.\n+\t(com.o): Allow for filename changes; add gtype-f.h as dependency.\n+\t(ste.o): Add gt-f-ste.h as dependency.\n+\t* config-lang.in (gtfiles): Add com.h, ste.c.\n+\t* com.c: Replace uses of ggc_add_* with GTY markers.  Include\n+\tgtype-f.h.\n+\t(mark_binding_level): Delete.\n+\t* com.h: Replace uses of ggc_add_* with GTY markers.\n+\t* ste.c: Replace uses of ggc_add_* with GTY markers.  Include\n+\tgt-f-ste.h.\n+\n+\t* Make-lang.in (f/gt-com.h): Build using gengtype.\n+\t(com.o): Depend on f/gt-com.h.\n+\t* com.c: Rename struct binding_level to f_binding_level.\n+\t(struct f_binding_level): Use gengtype.\n+\t(struct tree_ggc_tracker): Use gengtype.\n+\t(mark_tracker_head): Use gt_ggc_m_tree_ggc_tracker.\n+\t(make_binding_level): Use GGC.\n+\t(mark_binding_level): Use gt_ggc_m_f_binding_level.\n+\t(ffecom_init_decl_processing): Change free_binding_level\n+\tto a deletable root.\n+\t* config-lang.in (gtfiles): Define.\n+\t* where.c: Strings need no longer be allocated in GCable memory;\n+\tremove my change of 30 Dec 1999.\n+\n 2002-05-31  Matthew Woodcraft  <mattheww@chiark.greenend.org.uk>\n \n \t* lang-specs.h: Use cpp_debug_options."}, {"sha": "86cf411fa37bc742d5e647ca41452846497cb866", "filename": "gcc/f/Make-lang.in", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Ff%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Ff%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2FMake-lang.in?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -137,6 +137,8 @@ f/fini.o:\n \t$(HOST_CC) $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) \\\n \t      -c $(srcdir)/f/fini.c $(OUTPUT_OPTION)\n \n+gt-f-com.h gt-f-ste.h gtype-f.h : s-gtype; @true\n+\n #\f\n # Build hooks:\n \n@@ -364,7 +366,7 @@ f/com.o: f/com.c f/proj.h $(CONFIG_H) $(SYSTEM_H) flags.h $(RTL_H) $(TREE_H) \\\n  f/bad.def f/where.h glimits.h f/top.h f/lex.h f/type.h f/intrin.h \\\n  f/intrin.def f/lab.h f/symbol.h f/symbol.def f/equiv.h f/storag.h f/global.h \\\n  f/name.h f/expr.h f/implic.h f/src.h f/st.h $(GGC_H) toplev.h diagnostic.h \\\n- langhooks.h langhooks-def.h intl.h real.h\n+ $(LANGHOOKS_DEF) langhooks.h intl.h real.h debug.h gt-f-com.h gtype-f.h\n f/data.o: f/data.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/data.h f/bld.h f/bld-op.def \\\n  f/bit.h f/malloc.h f/com.h f/com-rt.def $(TREE_H) f/info.h f/info-b.def \\\n  f/info-k.def f/info-w.def f/target.h f/bad.h f/bad.def f/where.h glimits.h \\\n@@ -460,7 +462,8 @@ f/ste.o: f/ste.c f/proj.h $(CONFIG_H) $(SYSTEM_H) $(RTL_H) toplev.h f/ste.h \\\n  f/info.h f/info-b.def f/info-k.def f/info-w.def f/target.h f/bad.h f/bad.def \\\n  f/where.h glimits.h f/top.h f/lex.h f/type.h f/lab.h f/storag.h f/symbol.h \\\n  f/symbol.def f/equiv.h f/global.h f/name.h f/intrin.h f/intrin.def f/stp.h \\\n- f/stt.h f/stamp-str f/sts.h f/stv.h f/stw.h f/expr.h f/sta.h $(GGC_H)\n+ f/stt.h f/stamp-str f/sts.h f/stv.h f/stw.h f/expr.h f/sta.h $(GGC_H) \\\n+ gt-f-ste.h\n f/storag.o: f/storag.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/storag.h f/bld.h  \\\n  f/bld-op.def f/bit.h f/malloc.h f/com.h f/com-rt.def $(TREE_H) \\\n  f/info.h f/info-b.def f/info-k.def f/info-w.def f/target.h f/bad.h \\"}, {"sha": "310a3107677e9da50994071b6d534f286cb92fcf", "filename": "gcc/f/com.c", "status": "modified", "additions": 89, "deletions": 176, "changes": 265, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Ff%2Fcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Ff%2Fcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fcom.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -93,6 +93,7 @@ the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"intl.h\"\n #include \"langhooks.h\"\n #include \"langhooks-def.h\"\n+#include \"debug.h\"\n \n /* VMS-specific definitions */\n #ifdef VMS\n@@ -155,7 +156,7 @@ tree string_type_node;\n    inventions should be renamed to be canonical.  Note that only\n    the ones currently required to be global are so.  */\n \n-static tree ffecom_tree_fun_type_void;\n+static GTY(()) tree ffecom_tree_fun_type_void;\n \n tree ffecom_integer_type_node;\t/* Abbrev for _tree_type[blah][blah]. */\n tree ffecom_integer_zero_node;\t/* Like *_*_* with g77's integer type. */\n@@ -166,13 +167,14 @@ tree ffecom_tree_type[FFEINFO_basictype][FFEINFO_kindtype];\n    just use build_function_type and build_pointer_type on the\n    appropriate _tree_type array element.  */\n \n-static tree ffecom_tree_fun_type[FFEINFO_basictype][FFEINFO_kindtype];\n-static tree ffecom_tree_ptr_to_fun_type[FFEINFO_basictype][FFEINFO_kindtype];\n-static tree ffecom_tree_subr_type;\n-static tree ffecom_tree_ptr_to_subr_type;\n-static tree ffecom_tree_blockdata_type;\n+static GTY(()) tree ffecom_tree_fun_type[FFEINFO_basictype][FFEINFO_kindtype];\n+static GTY(()) tree \n+  ffecom_tree_ptr_to_fun_type[FFEINFO_basictype][FFEINFO_kindtype];\n+static GTY(()) tree ffecom_tree_subr_type;\n+static GTY(()) tree ffecom_tree_ptr_to_subr_type;\n+static GTY(()) tree ffecom_tree_blockdata_type;\n \n-static tree ffecom_tree_xargc_;\n+static GTY(()) tree ffecom_tree_xargc_;\n \n ffecomSymbol ffecom_symbol_null_\n =\n@@ -188,10 +190,10 @@ ffeinfoKindtype ffecom_label_kind_ = FFEINFO_basictypeNONE;\n \n int ffecom_f2c_typecode_[FFEINFO_basictype][FFEINFO_kindtype];\n tree ffecom_f2c_integer_type_node;\n-tree ffecom_f2c_ptr_to_integer_type_node;\n+static GTY(()) tree ffecom_f2c_ptr_to_integer_type_node;\n tree ffecom_f2c_address_type_node;\n tree ffecom_f2c_real_type_node;\n-tree ffecom_f2c_ptr_to_real_type_node;\n+static GTY(()) tree ffecom_f2c_ptr_to_real_type_node;\n tree ffecom_f2c_doublereal_type_node;\n tree ffecom_f2c_complex_type_node;\n tree ffecom_f2c_doublecomplex_type_node;\n@@ -375,7 +377,7 @@ static void finish_function (int nested);\n static const char *ffe_printable_name (tree decl, int v);\n static void ffe_print_error_function (diagnostic_context *, const char *);\n static tree lookup_name_current_level (tree name);\n-static struct binding_level *make_binding_level (void);\n+static struct f_binding_level *make_binding_level (void);\n static void pop_f_function_context (void);\n static void push_f_function_context (void);\n static void push_parm_decl (tree parm);\n@@ -397,15 +399,15 @@ static ffesymbol ffecom_primary_entry_ = NULL;\n static ffesymbol ffecom_nested_entry_ = NULL;\n static ffeinfoKind ffecom_primary_entry_kind_;\n static bool ffecom_primary_entry_is_proc_;\n-static tree ffecom_outer_function_decl_;\n-static tree ffecom_previous_function_decl_;\n-static tree ffecom_which_entrypoint_decl_;\n-static tree ffecom_float_zero_ = NULL_TREE;\n-static tree ffecom_float_half_ = NULL_TREE;\n-static tree ffecom_double_zero_ = NULL_TREE;\n-static tree ffecom_double_half_ = NULL_TREE;\n-static tree ffecom_func_result_;/* For functions. */\n-static tree ffecom_func_length_;/* For CHARACTER fns. */\n+static GTY(()) tree ffecom_outer_function_decl_;\n+static GTY(()) tree ffecom_previous_function_decl_;\n+static GTY(()) tree ffecom_which_entrypoint_decl_;\n+static GTY(()) tree ffecom_float_zero_;\n+static GTY(()) tree ffecom_float_half_;\n+static GTY(()) tree ffecom_double_zero_;\n+static GTY(()) tree ffecom_double_half_;\n+static GTY(()) tree ffecom_func_result_;/* For functions. */\n+static GTY(()) tree ffecom_func_length_;/* For CHARACTER fns. */\n static ffebld ffecom_list_blockdata_;\n static ffebld ffecom_list_common_;\n static ffebld ffecom_master_arglist_;\n@@ -415,9 +417,9 @@ static ffetargetCharacterSize ffecom_master_size_;\n static int ffecom_num_fns_ = 0;\n static int ffecom_num_entrypoints_ = 0;\n static bool ffecom_is_altreturning_ = FALSE;\n-static tree ffecom_multi_type_node_;\n-static tree ffecom_multi_retval_;\n-static tree\n+static GTY(()) tree ffecom_multi_type_node_;\n+static GTY(()) tree ffecom_multi_retval_;\n+static GTY(()) tree\n   ffecom_multi_fields_[FFEINFO_basictype][FFEINFO_kindtype];\n static bool ffecom_member_namelisted_;\t/* _member_phase1_ namelisted? */\n static bool ffecom_doing_entry_ = FALSE;\n@@ -427,13 +429,7 @@ static int ffecom_typesize_integer1_;\n \n /* Holds pointer-to-function expressions.  */\n \n-static tree ffecom_gfrt_[FFECOM_gfrt]\n-=\n-{\n-#define DEFGFRT(CODE,NAME,TYPE,ARGS,VOLATILE,COMPLEX,CONST) NULL_TREE,\n-#include \"com-rt.def\"\n-#undef DEFGFRT\n-};\n+static GTY(()) tree ffecom_gfrt_[FFECOM_gfrt];\n \n /* Holds the external names of the functions.  */\n \n@@ -530,7 +526,7 @@ static const char *const ffecom_gfrt_argstring_[FFECOM_gfrt]\n /* Note that the information in the `names' component of the global contour\n    is duplicated in the IDENTIFIER_GLOBAL_VALUEs of all identifiers.  */\n \n-struct binding_level\n+struct f_binding_level GTY(())\n   {\n     /* A chain of _DECL nodes for all variables, constants, functions,\n        and typedef types.  These are in the reverse of the order supplied.\n@@ -547,44 +543,46 @@ struct binding_level\n     tree this_block;\n \n     /* The binding level which this one is contained in (inherits from).  */\n-    struct binding_level *level_chain;\n+    struct f_binding_level *level_chain;\n \n     /* 0: no ffecom_prepare_* functions called at this level yet;\n        1: ffecom_prepare* functions called, except not ffecom_prepare_end;\n        2: ffecom_prepare_end called.  */\n     int prep_state;\n   };\n \n-#define NULL_BINDING_LEVEL (struct binding_level *) NULL\n+#define NULL_BINDING_LEVEL (struct f_binding_level *) NULL\n \n /* The binding level currently in effect.  */\n \n-static struct binding_level *current_binding_level;\n+static GTY(()) struct f_binding_level *current_binding_level;\n \n /* A chain of binding_level structures awaiting reuse.  */\n \n-static struct binding_level *free_binding_level;\n+static GTY((deletable (\"\"))) struct f_binding_level *free_binding_level;\n \n /* The outermost binding level, for names of file scope.\n    This is created when the compiler is started and exists\n    through the entire run.  */\n \n-static struct binding_level *global_binding_level;\n+static struct f_binding_level *global_binding_level;\n \n /* Binding level structures are initialized by copying this one.  */\n \n-static const struct binding_level clear_binding_level\n+static const struct f_binding_level clear_binding_level\n =\n {NULL, NULL, NULL, NULL_BINDING_LEVEL, 0};\n \n /* Language-dependent contents of an identifier.  */\n \n-struct lang_identifier\n-  {\n-    struct tree_identifier ignore;\n-    tree global_value, local_value, label_value;\n-    bool invented;\n-  };\n+struct lang_identifier GTY(())\n+{\n+  struct tree_identifier common;\n+  tree global_value;\n+  tree local_value;\n+  tree label_value;\n+  bool invented;\n+};\n \n /* Macros for access to language-specific slots in an identifier.  */\n /* Each of these slots contains a DECL node or null.  */\n@@ -605,6 +603,24 @@ struct lang_identifier\n #define IDENTIFIER_INVENTED(NODE)\t\\\n   (((struct lang_identifier *)(NODE))->invented)\n \n+/* The resulting tree type.  */\n+union lang_tree_node \n+  GTY((desc (\"TREE_CODE (&%h.generic) == IDENTIFIER_NODE\")))\n+{\n+  union tree_node GTY ((tag (\"0\"), \n+\t\t\tdesc (\"tree_node_structure (&%h)\"))) \n+    generic;\n+  struct lang_identifier GTY ((tag (\"1\"))) identifier;\n+};\n+\n+/* Fortran doesn't use either of these.  */\n+struct lang_decl GTY(()) \n+{\n+};\n+struct lang_type GTY(())\n+{\n+};\n+\n /* In identifiers, C uses the following fields in a special way:\n    TREE_PUBLIC\t      to record that there was a previous local extern decl.\n    TREE_USED\t      to record that such a decl was used.\n@@ -614,11 +630,11 @@ struct lang_identifier\n    that have names.  Here so we can clear out their names' definitions\n    at the end of the function.  */\n \n-static tree named_labels;\n+static GTY(()) tree named_labels;\n \n /* A list of LABEL_DECLs from outer contexts that are currently shadowed.  */\n \n-static tree shadowed_labels;\n+static GTY(()) tree shadowed_labels;\n \f\n /* Return the subscript expression, modified to do range-checking.\n \n@@ -6276,27 +6292,12 @@ ffecom_gfrt_tree_ (ffecomGfrt ix)\n /* A somewhat evil way to prevent the garbage collector\n    from collecting 'tree' structures.  */\n #define NUM_TRACKED_CHUNK 63\n-static struct tree_ggc_tracker\n+struct tree_ggc_tracker GTY(())\n {\n   struct tree_ggc_tracker *next;\n   tree trees[NUM_TRACKED_CHUNK];\n-} *tracker_head = NULL;\n-\n-static void\n-mark_tracker_head (void *arg)\n-{\n-  struct tree_ggc_tracker *head;\n-  int i;\n-\n-  for (head = * (struct tree_ggc_tracker **) arg;\n-       head != NULL;\n-       head = head->next)\n-  {\n-    ggc_mark (head);\n-    for (i = 0; i < NUM_TRACKED_CHUNK; i++)\n-      ggc_mark_tree (head->trees[i]);\n-  }\n-}\n+};\n+static GTY(()) struct tree_ggc_tracker *tracker_head;\n \n void\n ffecom_save_tree_forever (tree t)\n@@ -9214,15 +9215,13 @@ ffecom_type_localvar_ (ffesymbol s, ffeinfoBasictype bt,\n \n /* Build Namelist type.  */\n \n+static GTY(()) tree ffecom_type_namelist_var;\n static tree\n ffecom_type_namelist_ ()\n {\n-  static tree type = NULL_TREE;\n-\n-  if (type == NULL_TREE)\n+  if (ffecom_type_namelist_var == NULL_TREE)\n     {\n-      static tree namefield, varsfield, nvarsfield;\n-      tree vardesctype;\n+      tree namefield, varsfield, nvarsfield, vardesctype, type;\n \n       vardesctype = ffecom_type_vardesc_ ();\n \n@@ -9239,22 +9238,21 @@ ffecom_type_namelist_ ()\n       TYPE_FIELDS (type) = namefield;\n       layout_type (type);\n \n-      ggc_add_tree_root (&type, 1);\n+      ffecom_type_namelist_var = type;\n     }\n \n-  return type;\n+  return ffecom_type_namelist_var;\n }\n \n /* Build Vardesc type.  */\n \n+static GTY(()) tree ffecom_type_vardesc_var;\n static tree\n ffecom_type_vardesc_ ()\n {\n-  static tree type = NULL_TREE;\n-  static tree namefield, addrfield, dimsfield, typefield;\n-\n-  if (type == NULL_TREE)\n+  if (ffecom_type_vardesc_var == NULL_TREE)\n     {\n+      tree namefield, addrfield, dimsfield, typefield, type;\n       type = make_node (RECORD_TYPE);\n \n       namefield = ffecom_decl_field (type, NULL_TREE, \"name\",\n@@ -9269,10 +9267,10 @@ ffecom_type_vardesc_ ()\n       TYPE_FIELDS (type) = namefield;\n       layout_type (type);\n \n-      ggc_add_tree_root (&type, 1);\n+      ffecom_type_vardesc_var = type;\n     }\n \n-  return type;\n+  return ffecom_type_vardesc_var;\n }\n \n static tree\n@@ -13732,13 +13730,13 @@ lookup_name_current_level (tree name)\n   return t;\n }\n \n-/* Create a new `struct binding_level'.  */\n+/* Create a new `struct f_binding_level'.  */\n \n-static struct binding_level *\n+static struct f_binding_level *\n make_binding_level ()\n {\n   /* NOSTRICT */\n-  return (struct binding_level *) xmalloc (sizeof (struct binding_level));\n+  return ggc_alloc (sizeof (struct f_binding_level));\n }\n \n /* Save and restore the variables in this file and elsewhere\n@@ -13750,7 +13748,7 @@ struct f_function\n   struct f_function *next;\n   tree named_labels;\n   tree shadowed_labels;\n-  struct binding_level *binding_level;\n+  struct f_binding_level *binding_level;\n };\n \n struct f_function *f_function_chain;\n@@ -13838,7 +13836,7 @@ pushdecl_top_level (x)\n      tree x;\n {\n   register tree t;\n-  register struct binding_level *b = current_binding_level;\n+  register struct f_binding_level *b = current_binding_level;\n   register tree f = current_function_decl;\n \n   current_binding_level = global_binding_level;\n@@ -14078,86 +14076,11 @@ global_bindings_p ()\n   return current_binding_level == global_binding_level;\n }\n \n-/* Mark ARG for GC.  */\n-static void\n-mark_binding_level (void *arg)\n-{\n-  struct binding_level *level = *(struct binding_level **) arg;\n-\n-  while (level)\n-    {\n-      ggc_mark_tree (level->names);\n-      ggc_mark_tree (level->blocks);\n-      ggc_mark_tree (level->this_block);\n-      level = level->level_chain;\n-    }\n-}\n-\n static void\n ffecom_init_decl_processing ()\n {\n-  static tree *const tree_roots[] = {\n-    &current_function_decl,\n-    &string_type_node,\n-    &ffecom_tree_fun_type_void,\n-    &ffecom_integer_zero_node,\n-    &ffecom_integer_one_node,\n-    &ffecom_tree_subr_type,\n-    &ffecom_tree_ptr_to_subr_type,\n-    &ffecom_tree_blockdata_type,\n-    &ffecom_tree_xargc_,\n-    &ffecom_f2c_integer_type_node,\n-    &ffecom_f2c_ptr_to_integer_type_node,\n-    &ffecom_f2c_address_type_node,\n-    &ffecom_f2c_real_type_node,\n-    &ffecom_f2c_ptr_to_real_type_node,\n-    &ffecom_f2c_doublereal_type_node,\n-    &ffecom_f2c_complex_type_node,\n-    &ffecom_f2c_doublecomplex_type_node,\n-    &ffecom_f2c_longint_type_node,\n-    &ffecom_f2c_logical_type_node,\n-    &ffecom_f2c_flag_type_node,\n-    &ffecom_f2c_ftnlen_type_node,\n-    &ffecom_f2c_ftnlen_zero_node,\n-    &ffecom_f2c_ftnlen_one_node,\n-    &ffecom_f2c_ftnlen_two_node,\n-    &ffecom_f2c_ptr_to_ftnlen_type_node,\n-    &ffecom_f2c_ftnint_type_node,\n-    &ffecom_f2c_ptr_to_ftnint_type_node,\n-    &ffecom_outer_function_decl_,\n-    &ffecom_previous_function_decl_,\n-    &ffecom_which_entrypoint_decl_,\n-    &ffecom_float_zero_,\n-    &ffecom_float_half_,\n-    &ffecom_double_zero_,\n-    &ffecom_double_half_,\n-    &ffecom_func_result_,\n-    &ffecom_func_length_,\n-    &ffecom_multi_type_node_,\n-    &ffecom_multi_retval_,\n-    &named_labels,\n-    &shadowed_labels\n-  };\n-  size_t i;\n-\n   malloc_init ();\n \n-  /* Record our roots.  */\n-  for (i = 0; i < ARRAY_SIZE (tree_roots); i++)\n-    ggc_add_tree_root (tree_roots[i], 1);\n-  ggc_add_tree_root (&ffecom_tree_type[0][0],\n-\t\t     FFEINFO_basictype*FFEINFO_kindtype);\n-  ggc_add_tree_root (&ffecom_tree_fun_type[0][0],\n-\t\t     FFEINFO_basictype*FFEINFO_kindtype);\n-  ggc_add_tree_root (&ffecom_tree_ptr_to_fun_type[0][0],\n-\t\t     FFEINFO_basictype*FFEINFO_kindtype);\n-  ggc_add_tree_root (ffecom_gfrt_, FFECOM_gfrt);\n-  ggc_add_root (&current_binding_level, 1, sizeof current_binding_level,\n-                mark_binding_level);\n-  ggc_add_root (&free_binding_level, 1, sizeof current_binding_level,\n-                mark_binding_level);\n-  ggc_add_root (&tracker_head, 1, sizeof tracker_head, mark_tracker_head);\n-\n   ffe_init_0 ();\n }\n \n@@ -14199,7 +14122,11 @@ static const char *ffe_init PARAMS ((const char *));\n static void ffe_finish PARAMS ((void));\n static void ffe_init_options PARAMS ((void));\n static void ffe_print_identifier PARAMS ((FILE *, tree, int));\n-static void ffe_mark_tree (tree);\n+\n+struct language_function GTY(())\n+{\n+  int unused;\n+};\n \n #undef  LANG_HOOKS_NAME\n #define LANG_HOOKS_NAME\t\t\t\"GNU F77\"\n@@ -14213,8 +14140,6 @@ static void ffe_mark_tree (tree);\n #define LANG_HOOKS_DECODE_OPTION\tffe_decode_option\n #undef  LANG_HOOKS_PARSE_FILE\n #define LANG_HOOKS_PARSE_FILE\t\tffe_parse_file\n-#undef  LANG_HOOKS_MARK_TREE\n-#define LANG_HOOKS_MARK_TREE\t\tffe_mark_tree\n #undef  LANG_HOOKS_MARK_ADDRESSABLE\n #define LANG_HOOKS_MARK_ADDRESSABLE\tffe_mark_addressable\n #undef  LANG_HOOKS_PRINT_IDENTIFIER\n@@ -14517,7 +14442,7 @@ poplevel (keep, reverse, functionbody)\n   /* Pop the current level, and free the structure for reuse.  */\n \n   {\n-    register struct binding_level *level = current_binding_level;\n+    register struct f_binding_level *level = current_binding_level;\n     current_binding_level = current_binding_level->level_chain;\n \n     level->level_chain = free_binding_level;\n@@ -14572,7 +14497,7 @@ pushdecl (x)\n {\n   register tree t;\n   register tree name = DECL_NAME (x);\n-  register struct binding_level *b = current_binding_level;\n+  register struct f_binding_level *b = current_binding_level;\n \n   if ((TREE_CODE (x) == FUNCTION_DECL)\n       && (DECL_INITIAL (x) == 0)\n@@ -14704,7 +14629,7 @@ void\n pushlevel (tag_transparent)\n      int tag_transparent;\n {\n-  register struct binding_level *newlevel = NULL_BINDING_LEVEL;\n+  register struct f_binding_level *newlevel = NULL_BINDING_LEVEL;\n \n   assert (! tag_transparent);\n \n@@ -15138,21 +15063,6 @@ ffe_unsigned_type (type)\n \n   return type;\n }\n-\n-static void\n-ffe_mark_tree (t)\n-     tree t;\n-{\n-  if (TREE_CODE (t) == IDENTIFIER_NODE)\n-    {\n-      struct lang_identifier *i = (struct lang_identifier *) t;\n-      ggc_mark_tree (IDENTIFIER_GLOBAL_VALUE (i));\n-      ggc_mark_tree (IDENTIFIER_LOCAL_VALUE (i));\n-      ggc_mark_tree (IDENTIFIER_LABEL_VALUE (i));\n-    }\n-  else if (TYPE_P (t) && TYPE_LANG_SPECIFIC (t))\n-    ggc_mark (TYPE_LANG_SPECIFIC (t));\n-}\n \f\n /* From gcc/cccp.c, the code to handle -I.  */\n \n@@ -16656,3 +16566,6 @@ typedef doublereal E_f; // real function with -R not specified //\n -------- (end output file from f2c)\n \n */\n+\n+#include \"gt-f-com.h\"\n+#include \"gtype-f.h\""}, {"sha": "8b8bb861e82da0ff63f2d9844ea0edd9bb491bba", "filename": "gcc/f/com.h", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Ff%2Fcom.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Ff%2Fcom.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fcom.h?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -167,32 +167,32 @@ extern tree pushdecl\t\t\t\tPARAMS ((tree));\n \n /* Global objects accessed by users of this module. */\n \n-extern tree string_type_node;\n-extern tree ffecom_integer_type_node;\n-extern tree ffecom_integer_zero_node;\n-extern tree ffecom_integer_one_node;\n-extern tree ffecom_tree_type[FFEINFO_basictype][FFEINFO_kindtype];\n+extern GTY(()) tree string_type_node;\n+extern GTY(()) tree ffecom_integer_type_node;\n+extern GTY(()) tree ffecom_integer_zero_node;\n+extern GTY(()) tree ffecom_integer_one_node;\n+extern GTY(()) tree ffecom_tree_type[FFEINFO_basictype][FFEINFO_kindtype];\n extern ffecomSymbol ffecom_symbol_null_;\n extern ffeinfoKindtype ffecom_pointer_kind_;\n extern ffeinfoKindtype ffecom_label_kind_;\n \n extern int ffecom_f2c_typecode_[FFEINFO_basictype][FFEINFO_kindtype];\n-extern tree ffecom_f2c_integer_type_node;\n-extern tree ffecom_f2c_address_type_node;\n-extern tree ffecom_f2c_real_type_node;\n-extern tree ffecom_f2c_doublereal_type_node;\n-extern tree ffecom_f2c_complex_type_node;\n-extern tree ffecom_f2c_doublecomplex_type_node;\n-extern tree ffecom_f2c_longint_type_node;\n-extern tree ffecom_f2c_logical_type_node;\n-extern tree ffecom_f2c_flag_type_node;\n-extern tree ffecom_f2c_ftnlen_type_node;\n-extern tree ffecom_f2c_ftnlen_zero_node;\n-extern tree ffecom_f2c_ftnlen_one_node;\n-extern tree ffecom_f2c_ftnlen_two_node;\n-extern tree ffecom_f2c_ptr_to_ftnlen_type_node;\n-extern tree ffecom_f2c_ftnint_type_node;\n-extern tree ffecom_f2c_ptr_to_ftnint_type_node;\n+extern GTY(()) tree ffecom_f2c_integer_type_node;\n+extern GTY(()) tree ffecom_f2c_address_type_node;\n+extern GTY(()) tree ffecom_f2c_real_type_node;\n+extern GTY(()) tree ffecom_f2c_doublereal_type_node;\n+extern GTY(()) tree ffecom_f2c_complex_type_node;\n+extern GTY(()) tree ffecom_f2c_doublecomplex_type_node;\n+extern GTY(()) tree ffecom_f2c_longint_type_node;\n+extern GTY(()) tree ffecom_f2c_logical_type_node;\n+extern GTY(()) tree ffecom_f2c_flag_type_node;\n+extern GTY(()) tree ffecom_f2c_ftnlen_type_node;\n+extern GTY(()) tree ffecom_f2c_ftnlen_zero_node;\n+extern GTY(()) tree ffecom_f2c_ftnlen_one_node;\n+extern GTY(()) tree ffecom_f2c_ftnlen_two_node;\n+extern GTY(()) tree ffecom_f2c_ptr_to_ftnlen_type_node;\n+extern GTY(()) tree ffecom_f2c_ftnint_type_node;\n+extern GTY(()) tree ffecom_f2c_ptr_to_ftnint_type_node;\n \n /* Declare functions with prototypes. */\n "}, {"sha": "2c5bd2d5572708f64c7a83a9afe3e3a902fa2b6b", "filename": "gcc/f/config-lang.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Ff%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Ff%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fconfig-lang.in?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -32,3 +32,5 @@ compilers=\"f771\\$(exeext)\"\n stagestuff=\"g77\\$(exeext) g77-cross\\$(exeext) f771\\$(exeext)\"\n \n target_libs=target-libf2c\n+\n+gtfiles=\"\\$(srcdir)/f/com.c \\$(srcdir)/f/com.h \\$(srcdir)/f/ste.c\""}, {"sha": "d7d84954eefde8a10558d1c5c3ff151a8f13f295", "filename": "gcc/f/ste.c", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Ff%2Fste.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Ff%2Fste.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fste.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -1162,13 +1162,13 @@ ffeste_io_douio_ (ffebld expr)\n    declaration of variables (temporaries) to the expanding of expressions,\n    statements, etc.  */\n \n+static GTY(()) tree f2c_alist_struct;\n static tree\n ffeste_io_ialist_ (bool have_err,\n \t\t   ffestvUnit unit,\n \t\t   ffebld unit_expr,\n \t\t   int unit_dflt)\n {\n-  static tree f2c_alist_struct = NULL_TREE;\n   tree t;\n   tree ttype;\n   tree field;\n@@ -1193,8 +1193,6 @@ ffeste_io_ialist_ (bool have_err,\n       TYPE_FIELDS (ref) = errfield;\n       layout_type (ref);\n \n-      ggc_add_tree_root (&f2c_alist_struct, 1);\n-\n       f2c_alist_struct = ref;\n     }\n \n@@ -1283,6 +1281,7 @@ ffeste_io_ialist_ (bool have_err,\n    declaration of variables (temporaries) to the expanding of expressions,\n    statements, etc.  */\n \n+static GTY(()) tree f2c_cilist_struct;\n static tree\n ffeste_io_cilist_ (bool have_err,\n \t\t   ffestvUnit unit,\n@@ -1294,7 +1293,6 @@ ffeste_io_cilist_ (bool have_err,\n \t\t   bool rec,\n \t\t   ffebld rec_expr)\n {\n-  static tree f2c_cilist_struct = NULL_TREE;\n   tree t;\n   tree ttype;\n   tree field;\n@@ -1325,8 +1323,6 @@ ffeste_io_cilist_ (bool have_err,\n       TYPE_FIELDS (ref) = errfield;\n       layout_type (ref);\n \n-      ggc_add_tree_root (&f2c_cilist_struct, 1);\n-\n       f2c_cilist_struct = ref;\n     }\n \n@@ -1508,12 +1504,12 @@ ffeste_io_cilist_ (bool have_err,\n    declaration of variables (temporaries) to the expanding of expressions,\n    statements, etc.  */\n \n+static GTY(()) tree f2c_close_struct;\n static tree\n ffeste_io_cllist_ (bool have_err,\n \t\t   ffebld unit_expr,\n \t\t   ffestpFile *stat_spec)\n {\n-  static tree f2c_close_struct = NULL_TREE;\n   tree t;\n   tree ttype;\n   tree field;\n@@ -1541,8 +1537,6 @@ ffeste_io_cllist_ (bool have_err,\n       TYPE_FIELDS (ref) = errfield;\n       layout_type (ref);\n \n-      ggc_add_tree_root (&f2c_close_struct, 1);\n-\n       f2c_close_struct = ref;\n     }\n \n@@ -1622,14 +1616,14 @@ ffeste_io_cllist_ (bool have_err,\n    declaration of variables (temporaries) to the expanding of expressions,\n    statements, etc.  */\n \n+static GTY(()) tree f2c_icilist_struct;\n static tree\n ffeste_io_icilist_ (bool have_err,\n \t\t    ffebld unit_expr,\n \t\t    bool have_end,\n \t\t    ffestvFormat format,\n \t\t    ffestpFile *format_spec)\n {\n-  static tree f2c_icilist_struct = NULL_TREE;\n   tree t;\n   tree ttype;\n   tree field;\n@@ -1663,8 +1657,6 @@ ffeste_io_icilist_ (bool have_err,\n       TYPE_FIELDS (ref) = errfield;\n       layout_type (ref);\n \n-      ggc_add_tree_root (&f2c_icilist_struct, 1);\n-\n       f2c_icilist_struct = ref;\n     }\n \n@@ -1851,6 +1843,7 @@ ffeste_io_icilist_ (bool have_err,\n    declaration of variables (temporaries) to the expanding of expressions,\n    statements, etc.  */\n \n+static GTY(()) tree f2c_inquire_struct;\n static tree\n ffeste_io_inlist_ (bool have_err,\n \t\t   ffestpFile *unit_spec,\n@@ -1870,7 +1863,6 @@ ffeste_io_inlist_ (bool have_err,\n \t\t   ffestpFile *nextrec_spec,\n \t\t   ffestpFile *blank_spec)\n {\n-  static tree f2c_inquire_struct = NULL_TREE;\n   tree t;\n   tree ttype;\n   tree field;\n@@ -1959,8 +1951,6 @@ ffeste_io_inlist_ (bool have_err,\n       TYPE_FIELDS (ref) = errfield;\n       layout_type (ref);\n \n-      ggc_add_tree_root (&f2c_inquire_struct, 1);\n-\n       f2c_inquire_struct = ref;\n     }\n \n@@ -2109,6 +2099,7 @@ ffeste_io_inlist_ (bool have_err,\n    declaration of variables (temporaries) to the expanding of expressions,\n    statements, etc.  */\n \n+static GTY(()) tree f2c_open_struct;\n static tree\n ffeste_io_olist_ (bool have_err,\n \t\t  ffebld unit_expr,\n@@ -2119,7 +2110,6 @@ ffeste_io_olist_ (bool have_err,\n \t\t  ffestpFile *recl_spec,\n \t\t  ffestpFile *blank_spec)\n {\n-  static tree f2c_open_struct = NULL_TREE;\n   tree t;\n   tree ttype;\n   tree field;\n@@ -2163,8 +2153,6 @@ ffeste_io_olist_ (bool have_err,\n       TYPE_FIELDS (ref) = errfield;\n       layout_type (ref);\n \n-      ggc_add_tree_root (&f2c_open_struct, 1);\n-\n       f2c_open_struct = ref;\n     }\n \n@@ -4618,3 +4606,5 @@ ffeste_terminate_2 (void)\n   assert (! ffeste_top_block_);\n }\n #endif\n+\n+#include \"gt-f-ste.h\""}, {"sha": "e7d2e990090f1832809a8ba5556a0b9b239aabc4", "filename": "gcc/f/where.c", "status": "modified", "additions": 7, "deletions": 71, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Ff%2Fwhere.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Ff%2Fwhere.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fwhere.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -33,7 +33,6 @@ the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"where.h\"\n #include \"lex.h\"\n #include \"malloc.h\"\n-#include \"ggc.h\"\n \n /* Externals defined here. */\n \n@@ -109,32 +108,6 @@ ffewhere_ll_lookup_ (ffewhereLineNumber ln)\n   return NULL;\n }\n \n-/* A somewhat evil way to prevent the garbage collector\n-   from collecting 'file' structures.  */\n-#define NUM_FFEWHERE_HEAD_FILES 31\n-static struct ffewhere_ggc_tracker \n-{\n-  struct ffewhere_ggc_tracker *next;\n-  ffewhereFile files[NUM_FFEWHERE_HEAD_FILES];\n-} *ffewhere_head = NULL;\n-\n-static void \n-mark_ffewhere_head (void *arg)\n-{\n-  struct ffewhere_ggc_tracker *head;\n-  int i;\n-  \n-  for (head = * (struct ffewhere_ggc_tracker **) arg;\n-       head != NULL;\n-       head = head->next)\n-  {\n-    ggc_mark (head);\n-    for (i = 0; i < NUM_FFEWHERE_HEAD_FILES; i++)\n-      ggc_mark (head->files[i]);\n-  }\n-}\n-\n-\n /* Kill file object.\n \n    Note that this object must not have been passed in a call\n@@ -144,18 +117,9 @@ mark_ffewhere_head (void *arg)\n void\n ffewhere_file_kill (ffewhereFile wf)\n {\n-  struct ffewhere_ggc_tracker *head;\n-  int i;\n-  \n-  for (head = ffewhere_head; head != NULL; head = head->next)\n-    for (i = 0; i < NUM_FFEWHERE_HEAD_FILES; i++)\n-      if (head->files[i] == wf)\n-\t{\n-\t  head->files[i] = NULL;\n-\t  return;\n-\t}\n-  /* Called on a file that has already been deallocated... */\n-  abort();\n+  malloc_kill_ks (ffe_pool_file (), wf,\n+\t\t  offsetof (struct _ffewhere_file_, text)\n+\t\t  + wf->length + 1);\n }\n \n /* Create file object.  */\n@@ -164,42 +128,14 @@ ffewhereFile\n ffewhere_file_new (const char *name, size_t length)\n {\n   ffewhereFile wf;\n-  int filepos;\n- \n-  wf = ggc_alloc (offsetof (struct _ffewhere_file_, text)\n-\t\t  + length + 1);\n+\n+  wf = malloc_new_ks (ffe_pool_file (), \"ffewhereFile\",\n+\t\t      offsetof (struct _ffewhere_file_, text)\n+\t\t      + length + 1);\n   wf->length = length;\n   memcpy (&wf->text[0], name, length);\n   wf->text[length] = '\\0';\n \n-  if (ffewhere_head == NULL)\n-    {\n-      ggc_add_root (&ffewhere_head, 1, sizeof ffewhere_head,\n-\t\t    mark_ffewhere_head);\n-      filepos = NUM_FFEWHERE_HEAD_FILES;\n-    }\n-  else\n-    {\n-      for (filepos = 0; filepos < NUM_FFEWHERE_HEAD_FILES; filepos++)\n-\tif (ffewhere_head->files[filepos] == NULL)\n-\t  {\n-\t    ffewhere_head->files[filepos] = wf;\n-\t    break;\n-\t  }\n-    }\n-  if (filepos == NUM_FFEWHERE_HEAD_FILES)\n-    {\n-      /* Need to allocate a new block.  */\n-      struct ffewhere_ggc_tracker *old_head = ffewhere_head;\n-      int i;\n-      \n-      ffewhere_head = ggc_alloc (sizeof (*ffewhere_head));\n-      ffewhere_head->next = old_head;\n-      ffewhere_head->files[0] = wf;\n-      for (i = 1; i < NUM_FFEWHERE_HEAD_FILES; i++)\n-\tffewhere_head->files[i] = NULL;\n-    }\n-\n   return wf;\n }\n "}, {"sha": "9fe1c11f586d11d7a67028ce3f68264357b882b5", "filename": "gcc/final.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -586,9 +586,7 @@ dbr_sequence_length ()\n \n static int *insn_lengths;\n \n-#ifdef HAVE_ATTR_length\n varray_type insn_addresses_;\n-#endif\n \n /* Max uid for which the above arrays are valid.  */\n static int insn_lengths_max_uid;"}, {"sha": "6febe585d55562bd92a2fd430140757dcf66b1c3", "filename": "gcc/fold-const.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -1376,21 +1376,21 @@ size_int_wide (number, kind)\n \n /* Likewise, but the desired type is specified explicitly.  */\n \n+static GTY (()) tree new_const;\n+static GTY ((if_marked (\"ggc_marked_p\"), param_is (union tree_node)))\n+     htab_t size_htab;\n+\n tree\n size_int_type_wide (number, type)\n      HOST_WIDE_INT number;\n      tree type;\n {\n-  static htab_t size_htab = 0;\n-  static tree new_const = 0;\n   PTR *slot;\n \n   if (size_htab == 0)\n     {\n       size_htab = htab_create (1024, size_htab_hash, size_htab_eq, NULL);\n-      ggc_add_deletable_htab (size_htab, NULL, NULL);\n       new_const = make_node (INTEGER_CST);\n-      ggc_add_tree_root (&new_const, 1);\n     }\n \n   /* Adjust NEW_CONST to be the constant we want.  If it's already in the\n@@ -7236,3 +7236,5 @@ rtl_expr_nonnegative_p (r)\n       return 0;\n     }\n }\n+\n+#include \"gt-fold-const.h\""}, {"sha": "d1f4e89d5c2355eb167d8b1fe2f4a45a0a72de3c", "filename": "gcc/function.c", "status": "modified", "additions": 77, "deletions": 216, "changes": 293, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -55,7 +55,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"basic-block.h\"\n #include \"obstack.h\"\n #include \"toplev.h\"\n-#include \"hash.h\"\n+#include \"hashtab.h\"\n #include \"ggc.h\"\n #include \"tm_p.h\"\n #include \"integrate.h\"\n@@ -129,12 +129,7 @@ static int profile_label_no;\n \n /* These variables hold pointers to functions to create and destroy\n    target specific, per-function data structures.  */\n-void (*init_machine_status) PARAMS ((struct function *));\n-void (*free_machine_status) PARAMS ((struct function *));\n-/* This variable holds a pointer to a function to register any\n-   data items in the target specific, per-function data structure\n-   that will need garbage collection.  */\n-void (*mark_machine_status) PARAMS ((struct function *));\n+struct machine_function * (*init_machine_status) PARAMS ((void));\n \n /* The FUNCTION_DECL for an inline function currently being expanded.  */\n tree inline_function_decl;\n@@ -143,12 +138,12 @@ tree inline_function_decl;\n struct function *cfun = 0;\n \n /* These arrays record the INSN_UIDs of the prologue and epilogue insns.  */\n-static varray_type prologue;\n-static varray_type epilogue;\n+static GTY(()) varray_type prologue;\n+static GTY(()) varray_type epilogue;\n \n /* Array of INSN_UIDs to hold the INSN_UIDs for each sibcall epilogue\n    in this function.  */\n-static varray_type sibcall_epilogue;\n+static GTY(()) varray_type sibcall_epilogue;\n \f\n /* In order to evaluate some expressions, such as function calls returning\n    structures in memory, we need to temporarily allocate stack locations.\n@@ -168,7 +163,7 @@ static varray_type sibcall_epilogue;\n    level where they are defined.  They are marked a \"kept\" so that\n    free_temp_slots will not free them.  */\n \n-struct temp_slot\n+struct temp_slot GTY(())\n {\n   /* Points to next temporary slot.  */\n   struct temp_slot *next;\n@@ -209,7 +204,7 @@ struct temp_slot\n    maintain this list in case two operands of an insn were required to match;\n    in that case we must ensure we use the same replacement.  */\n \n-struct fixup_replacement\n+struct fixup_replacement GTY(())\n {\n   rtx old;\n   rtx new;\n@@ -218,9 +213,9 @@ struct fixup_replacement\n \n struct insns_for_mem_entry\n {\n-  /* The KEY in HE will be a MEM.  */\n-  struct hash_entry he;\n-  /* These are the INSNS which reference the MEM.  */\n+  /* A MEM.  */\n+  rtx key;\n+  /* These are the INSNs which reference the MEM.  */\n   rtx insns;\n };\n \n@@ -232,18 +227,18 @@ static struct temp_slot *find_temp_slot_from_address  PARAMS ((rtx));\n static void put_reg_into_stack\tPARAMS ((struct function *, rtx, tree,\n \t\t\t\t\t enum machine_mode, enum machine_mode,\n \t\t\t\t\t int, unsigned int, int,\n-\t\t\t\t\t struct hash_table *));\n+\t\t\t\t\t htab_t));\n static void schedule_fixup_var_refs PARAMS ((struct function *, rtx, tree,\n \t\t\t\t\t     enum machine_mode,\n-\t\t\t\t\t     struct hash_table *));\n+\t\t\t\t\t     htab_t));\n static void fixup_var_refs\tPARAMS ((rtx, enum machine_mode, int, rtx,\n-\t\t\t\t\t struct hash_table *));\n+\t\t\t\t\t htab_t));\n static struct fixup_replacement\n   *find_fixup_replacement\tPARAMS ((struct fixup_replacement **, rtx));\n static void fixup_var_refs_insns PARAMS ((rtx, rtx, enum machine_mode,\n \t\t\t\t\t  int, int, rtx));\n static void fixup_var_refs_insns_with_hash\n-\t\t\t\tPARAMS ((struct hash_table *, rtx,\n+\t\t\t\tPARAMS ((htab_t, rtx,\n \t\t\t\t\t enum machine_mode, int, rtx));\n static void fixup_var_refs_insn PARAMS ((rtx, rtx, enum machine_mode,\n \t\t\t\t\t int, int, rtx));\n@@ -283,29 +278,24 @@ static int contains\t\tPARAMS ((rtx, varray_type));\n #ifdef HAVE_return\n static void emit_return_into_block PARAMS ((basic_block, rtx));\n #endif\n-static void put_addressof_into_stack PARAMS ((rtx, struct hash_table *));\n+static void put_addressof_into_stack PARAMS ((rtx, htab_t));\n static bool purge_addressof_1 PARAMS ((rtx *, rtx, int, int,\n-\t\t\t\t\t  struct hash_table *));\n+\t\t\t\t\t  htab_t));\n static void purge_single_hard_subreg_set PARAMS ((rtx));\n #if defined(HAVE_epilogue) && defined(INCOMING_RETURN_ADDR_RTX)\n static rtx keep_stack_depressed PARAMS ((rtx));\n #endif\n static int is_addressof\t\tPARAMS ((rtx *, void *));\n-static struct hash_entry *insns_for_mem_newfunc PARAMS ((struct hash_entry *,\n-\t\t\t\t\t\t\t struct hash_table *,\n-\t\t\t\t\t\t\t hash_table_key));\n-static unsigned long insns_for_mem_hash PARAMS ((hash_table_key));\n-static bool insns_for_mem_comp PARAMS ((hash_table_key, hash_table_key));\n+static hashval_t insns_for_mem_hash PARAMS ((const void *));\n+static int insns_for_mem_comp PARAMS ((const void *, const void *));\n static int insns_for_mem_walk   PARAMS ((rtx *, void *));\n-static void compute_insns_for_mem PARAMS ((rtx, rtx, struct hash_table *));\n-static void mark_function_status PARAMS ((struct function *));\n-static void maybe_mark_struct_function PARAMS ((void *));\n+static void compute_insns_for_mem PARAMS ((rtx, rtx, htab_t));\n static void prepare_function_start PARAMS ((void));\n static void do_clobber_return_reg PARAMS ((rtx, void *));\n static void do_use_return_reg PARAMS ((rtx, void *));\n \f\n /* Pointer to chain of `struct function' for containing functions.  */\n-static struct function *outer_function_chain;\n+static GTY(()) struct function *outer_function_chain;\n \n /* Given a function decl for a containing function,\n    return the `struct function' for it.  */\n@@ -436,8 +426,8 @@ free_after_parsing (f)\n   /* f->varasm is used by code generation.  */\n   /* f->eh->eh_return_stub_label is used by code generation.  */\n \n-  (*lang_hooks.function.free) (f);\n-  free_stmt_status (f);\n+  (*lang_hooks.function.final) (f);\n+  f->stmt = NULL;\n }\n \n /* Clear out all parts of the state in F that can safely be discarded\n@@ -448,16 +438,11 @@ void\n free_after_compilation (f)\n      struct function *f;\n {\n-  free_eh_status (f);\n-  free_expr_status (f);\n-  free_emit_status (f);\n-  free_varasm_status (f);\n-\n-  if (free_machine_status)\n-    (*free_machine_status) (f);\n-\n-  if (f->x_parm_reg_stack_loc)\n-    free (f->x_parm_reg_stack_loc);\n+  f->eh = NULL;\n+  f->expr = NULL;\n+  f->emit = NULL;\n+  f->varasm = NULL;\n+  f->machine = NULL;\n \n   f->x_temp_slots = NULL;\n   f->arg_offset_rtx = NULL;\n@@ -1497,7 +1482,7 @@ put_reg_into_stack (function, reg, type, promoted_mode, decl_mode, volatile_p,\n      int volatile_p;\n      unsigned int original_regno;\n      int used_p;\n-     struct hash_table *ht;\n+     htab_t ht;\n {\n   struct function *func = function ? function : cfun;\n   rtx new = 0;\n@@ -1545,7 +1530,7 @@ schedule_fixup_var_refs (function, reg, type, promoted_mode, ht)\n      rtx reg;\n      tree type;\n      enum machine_mode promoted_mode;\n-     struct hash_table *ht;\n+     htab_t ht;\n {\n   int unsigned_p = type ? TREE_UNSIGNED (type) : 0;\n \n@@ -1571,7 +1556,7 @@ fixup_var_refs (var, promoted_mode, unsignedp, may_share, ht)\n      rtx var;\n      enum machine_mode promoted_mode;\n      int unsignedp;\n-     struct hash_table *ht;\n+     htab_t ht;\n      rtx may_share;\n {\n   tree pending;\n@@ -1707,17 +1692,18 @@ fixup_var_refs_insns (insn, var, promoted_mode, unsignedp, toplevel, may_share)\n \n static void\n fixup_var_refs_insns_with_hash (ht, var, promoted_mode, unsignedp, may_share)\n-     struct hash_table *ht;\n+     htab_t ht;\n      rtx var;\n      enum machine_mode promoted_mode;\n      int unsignedp;\n      rtx may_share;\n {\n-  struct insns_for_mem_entry *ime\n-    = (struct insns_for_mem_entry *) hash_lookup (ht, var,\n-\t\t\t\t\t\t  /*create=*/0, /*copy=*/0);\n+  struct insns_for_mem_entry tmp;\n+  struct insns_for_mem_entry *ime;\n   rtx insn_list;\n \n+  tmp.key = var;\n+  ime = (struct insns_for_mem_entry *) htab_find (ht, &tmp);\n   for (insn_list = ime->insns; insn_list != 0; insn_list = XEXP (insn_list, 1))\n     if (INSN_P (XEXP (insn_list, 0)))\n       fixup_var_refs_insn (XEXP (insn_list, 0), var, promoted_mode,\n@@ -2979,7 +2965,7 @@ flush_addressof (decl)\n static void\n put_addressof_into_stack (r, ht)\n      rtx r;\n-     struct hash_table *ht;\n+     htab_t ht;\n {\n   tree decl, type;\n   int volatile_p, used_p;\n@@ -3031,7 +3017,7 @@ purge_addressof_1 (loc, insn, force, store, ht)\n      rtx *loc;\n      rtx insn;\n      int force, store;\n-     struct hash_table *ht;\n+     htab_t ht;\n {\n   rtx x;\n   RTX_CODE code;\n@@ -3291,50 +3277,34 @@ purge_addressof_1 (loc, insn, force, store, ht)\n   return result;\n }\n \n-/* Return a new hash table entry in HT.  */\n-\n-static struct hash_entry *\n-insns_for_mem_newfunc (he, ht, k)\n-     struct hash_entry *he;\n-     struct hash_table *ht;\n-     hash_table_key k ATTRIBUTE_UNUSED;\n-{\n-  struct insns_for_mem_entry *ifmhe;\n-  if (he)\n-    return he;\n-\n-  ifmhe = ((struct insns_for_mem_entry *)\n-\t   hash_allocate (ht, sizeof (struct insns_for_mem_entry)));\n-  ifmhe->insns = NULL_RTX;\n-\n-  return &ifmhe->he;\n-}\n-\n /* Return a hash value for K, a REG.  */\n \n-static unsigned long\n+static hashval_t\n insns_for_mem_hash (k)\n-     hash_table_key k;\n+     const void * k;\n {\n-  /* K is really a RTX.  Just use the address as the hash value.  */\n-  return (unsigned long) k;\n+  /* Use the address of the key for the hash value.  */\n+  struct insns_for_mem_entry *m = (struct insns_for_mem_entry *) k;\n+  return (hashval_t) m->key;\n }\n \n /* Return non-zero if K1 and K2 (two REGs) are the same.  */\n \n-static bool\n+static int\n insns_for_mem_comp (k1, k2)\n-     hash_table_key k1;\n-     hash_table_key k2;\n+     const void * k1;\n+     const void * k2;\n {\n-  return k1 == k2;\n+  struct insns_for_mem_entry *m1 = (struct insns_for_mem_entry *) k1;\n+  struct insns_for_mem_entry *m2 = (struct insns_for_mem_entry *) k2;\n+  return m1->key == m2->key;\n }\n \n struct insns_for_mem_walk_info\n {\n   /* The hash table that we are using to record which INSNs use which\n      MEMs.  */\n-  struct hash_table *ht;\n+  htab_t ht;\n \n   /* The INSN we are currently processing.  */\n   rtx insn;\n@@ -3356,18 +3326,26 @@ insns_for_mem_walk (r, data)\n {\n   struct insns_for_mem_walk_info *ifmwi\n     = (struct insns_for_mem_walk_info *) data;\n+  struct insns_for_mem_entry tmp;\n+  tmp.insns = NULL_RTX;\n \n   if (ifmwi->pass == 0 && *r && GET_CODE (*r) == ADDRESSOF\n       && GET_CODE (XEXP (*r, 0)) == REG)\n-    hash_lookup (ifmwi->ht, XEXP (*r, 0), /*create=*/1, /*copy=*/0);\n+    {\n+      PTR *e;\n+      tmp.key = XEXP (*r, 0);\n+      e = htab_find_slot (ifmwi->ht, &tmp, INSERT);\n+      if (*e == NULL)\n+\t{\n+\t  *e = ggc_alloc (sizeof (tmp));\n+\t  memcpy (*e, &tmp, sizeof (tmp));\n+\t}\n+    }\n   else if (ifmwi->pass == 1 && *r && GET_CODE (*r) == REG)\n     {\n-      /* Lookup this MEM in the hashtable, creating it if necessary.  */\n-      struct insns_for_mem_entry *ifme\n-\t= (struct insns_for_mem_entry *) hash_lookup (ifmwi->ht,\n-\t\t\t\t\t\t      *r,\n-\t\t\t\t\t\t      /*create=*/0,\n-\t\t\t\t\t\t      /*copy=*/0);\n+      struct insns_for_mem_entry *ifme;\n+      tmp.key = *r;\n+      ifme = (struct insns_for_mem_entry *) htab_find (ifmwi->ht, &tmp);\n \n       /* If we have not already recorded this INSN, do so now.  Since\n \t we process the INSNs in order, we know that if we have\n@@ -3387,7 +3365,7 @@ static void\n compute_insns_for_mem (insns, last_insn, ht)\n      rtx insns;\n      rtx last_insn;\n-     struct hash_table *ht;\n+     htab_t ht;\n {\n   rtx insn;\n   struct insns_for_mem_walk_info ifmwi;\n@@ -3422,7 +3400,7 @@ purge_addressof (insns)\n      rtx insns;\n {\n   rtx insn;\n-  struct hash_table ht;\n+  htab_t ht;\n \n   /* When we actually purge ADDRESSOFs, we turn REGs into MEMs.  That\n      requires a fixup pass over the instruction stream to correct\n@@ -3431,23 +3409,20 @@ purge_addressof (insns)\n      mentioned in very many instructions.  So, we speed up the process\n      by pre-calculating which REGs occur in which INSNs; that allows\n      us to perform the fixup passes much more quickly.  */\n-  hash_table_init (&ht,\n-\t\t   insns_for_mem_newfunc,\n-\t\t   insns_for_mem_hash,\n-\t\t   insns_for_mem_comp);\n-  compute_insns_for_mem (insns, NULL_RTX, &ht);\n+  ht = htab_create_ggc (1000, insns_for_mem_hash, insns_for_mem_comp, NULL);\n+  compute_insns_for_mem (insns, NULL_RTX, ht);\n \n   for (insn = insns; insn; insn = NEXT_INSN (insn))\n     if (GET_CODE (insn) == INSN || GET_CODE (insn) == JUMP_INSN\n \t|| GET_CODE (insn) == CALL_INSN)\n       {\n \tif (! purge_addressof_1 (&PATTERN (insn), insn,\n-\t\t\t\t asm_noperands (PATTERN (insn)) > 0, 0, &ht))\n+\t\t\t\t asm_noperands (PATTERN (insn)) > 0, 0, ht))\n \t  /* If we could not replace the ADDRESSOFs in the insn,\n \t     something is wrong.  */\n \t  abort ();\n \n-\tif (! purge_addressof_1 (&REG_NOTES (insn), NULL_RTX, 0, 0, &ht))\n+\tif (! purge_addressof_1 (&REG_NOTES (insn), NULL_RTX, 0, 0, ht))\n \t  {\n \t    /* If we could not replace the ADDRESSOFs in the insn's notes,\n \t       we can just remove the offending notes instead.  */\n@@ -3468,7 +3443,6 @@ purge_addressof (insns)\n       }\n \n   /* Clean up.  */\n-  hash_table_free (&ht);\n   purge_bitfield_addressof_replacements = 0;\n   purge_addressof_replacements = 0;\n \n@@ -4370,7 +4344,7 @@ assign_parms (fndecl)\n     }\n \n   max_parm_reg = LAST_VIRTUAL_REGISTER + 1;\n-  parm_reg_stack_loc = (rtx *) xcalloc (max_parm_reg, sizeof (rtx));\n+  parm_reg_stack_loc = (rtx *) ggc_alloc_cleared (max_parm_reg * sizeof (rtx));\n \n #ifdef INIT_CUMULATIVE_INCOMING_ARGS\n   INIT_CUMULATIVE_INCOMING_ARGS (args_so_far, fntype, NULL_RTX);\n@@ -4934,7 +4908,7 @@ assign_parms (fndecl)\n \t\t but it's also rare and we need max_parm_reg to be\n \t\t precisely correct.  */\n \t      max_parm_reg = regno + 1;\n-\t      new = (rtx *) xrealloc (parm_reg_stack_loc,\n+\t      new = (rtx *) ggc_realloc (parm_reg_stack_loc,\n \t\t\t\t      max_parm_reg * sizeof (rtx));\n \t      memset ((char *) (new + old_max_parm_reg), 0,\n \t\t     (max_parm_reg - old_max_parm_reg) * sizeof (rtx));\n@@ -5936,8 +5910,6 @@ reorder_blocks ()\n \n   /* Remove deleted blocks from the block fragment chains.  */\n   reorder_fix_fragments (block);\n-\n-  VARRAY_FREE (block_stack);\n }\n \n /* Helper function for reorder_blocks.  Reset TREE_ASM_WRITTEN.  */\n@@ -6326,7 +6298,7 @@ prepare_function_start ()\n \n   (*lang_hooks.function.init) (cfun);\n   if (init_machine_status)\n-    (*init_machine_status) (cfun);\n+    cfun->machine = (*init_machine_status) ();\n }\n \n /* Initialize the rtl expansion mechanism so that we can do simple things\n@@ -6797,6 +6769,8 @@ use_return_register ()\n   diddle_return_value (do_use_return_reg, NULL);\n }\n \n+static GTY(()) rtx initial_trampoline;\n+\n /* Generate RTL for the end of the current function.\n    FILENAME and LINE are the current position in the source file.\n \n@@ -6812,10 +6786,6 @@ expand_function_end (filename, line, end_bindings)\n   tree link;\n   rtx clobber_after;\n \n-#ifdef TRAMPOLINE_TEMPLATE\n-  static rtx initial_trampoline;\n-#endif\n-\n   finish_expr_for_function ();\n \n   /* If arg_pointer_save_area was referenced only from a nested\n@@ -6854,8 +6824,6 @@ expand_function_end (filename, line, end_bindings)\n \t  initial_trampoline\n \t    = gen_rtx_MEM (BLKmode, assemble_trampoline_template ());\n \t  set_mem_align (initial_trampoline, TRAMPOLINE_ALIGNMENT);\n-\n-\t  ggc_add_rtx_root (&initial_trampoline, 1);\n \t}\n #endif\n \n@@ -7955,121 +7923,14 @@ reposition_prologue_and_epilogue_notes (f)\n #endif /* HAVE_prologue or HAVE_epilogue */\n }\n \n-/* Mark P for GC.  */\n-\n-static void\n-mark_function_status (p)\n-     struct function *p;\n-{\n-  struct var_refs_queue *q;\n-  struct temp_slot *t;\n-  int i;\n-  rtx *r;\n-\n-  if (p == 0)\n-    return;\n-\n-  ggc_mark_rtx (p->arg_offset_rtx);\n-\n-  if (p->x_parm_reg_stack_loc)\n-    for (i = p->x_max_parm_reg, r = p->x_parm_reg_stack_loc;\n-\t i > 0; --i, ++r)\n-      ggc_mark_rtx (*r);\n-\n-  ggc_mark_rtx (p->return_rtx);\n-  ggc_mark_rtx (p->x_cleanup_label);\n-  ggc_mark_rtx (p->x_return_label);\n-  ggc_mark_rtx (p->x_save_expr_regs);\n-  ggc_mark_rtx (p->x_stack_slot_list);\n-  ggc_mark_rtx (p->x_parm_birth_insn);\n-  ggc_mark_rtx (p->x_tail_recursion_label);\n-  ggc_mark_rtx (p->x_tail_recursion_reentry);\n-  ggc_mark_rtx (p->internal_arg_pointer);\n-  ggc_mark_rtx (p->x_arg_pointer_save_area);\n-  ggc_mark_tree (p->x_rtl_expr_chain);\n-  ggc_mark_rtx (p->x_last_parm_insn);\n-  ggc_mark_tree (p->x_context_display);\n-  ggc_mark_tree (p->x_trampoline_list);\n-  ggc_mark_rtx (p->epilogue_delay_list);\n-  ggc_mark_rtx (p->x_clobber_return_insn);\n-\n-  for (t = p->x_temp_slots; t != 0; t = t->next)\n-    {\n-      ggc_mark (t);\n-      ggc_mark_rtx (t->slot);\n-      ggc_mark_rtx (t->address);\n-      ggc_mark_tree (t->rtl_expr);\n-      ggc_mark_tree (t->type);\n-    }\n-\n-  for (q = p->fixup_var_refs_queue; q != 0; q = q->next)\n-    {\n-      ggc_mark (q);\n-      ggc_mark_rtx (q->modified);\n-    }\n-\n-  ggc_mark_rtx (p->x_nonlocal_goto_handler_slots);\n-  ggc_mark_rtx (p->x_nonlocal_goto_handler_labels);\n-  ggc_mark_rtx (p->x_nonlocal_goto_stack_level);\n-  ggc_mark_tree (p->x_nonlocal_labels);\n-\n-  mark_hard_reg_initial_vals (p);\n-}\n-\n-/* Mark the struct function pointed to by *ARG for GC, if it is not\n-   NULL.  This is used to mark the current function and the outer\n-   function chain.  */\n-\n-static void\n-maybe_mark_struct_function (arg)\n-     void *arg;\n-{\n-  struct function *f = *(struct function **) arg;\n-\n-  if (f == 0)\n-    return;\n-\n-  ggc_mark_struct_function (f);\n-}\n-\n-/* Mark a struct function * for GC.  This is called from ggc-common.c.  */\n-\n-void\n-ggc_mark_struct_function (f)\n-     struct function *f;\n-{\n-  ggc_mark (f);\n-  ggc_mark_tree (f->decl);\n-\n-  mark_function_status (f);\n-  mark_eh_status (f->eh);\n-  mark_stmt_status (f->stmt);\n-  mark_expr_status (f->expr);\n-  mark_emit_status (f->emit);\n-  mark_varasm_status (f->varasm);\n-\n-  if (mark_machine_status)\n-    (*mark_machine_status) (f);\n-  (*lang_hooks.function.mark) (f);\n-\n-  if (f->original_arg_vector)\n-    ggc_mark_rtvec ((rtvec) f->original_arg_vector);\n-  if (f->original_decl_initial)\n-    ggc_mark_tree (f->original_decl_initial);\n-  if (f->outer)\n-    ggc_mark_struct_function (f->outer);\n-}\n-\n /* Called once, at initialization, to initialize function.c.  */\n \n void\n init_function_once ()\n {\n-  ggc_add_root (&cfun, 1, sizeof cfun, maybe_mark_struct_function);\n-  ggc_add_root (&outer_function_chain, 1, sizeof outer_function_chain,\n-\t\tmaybe_mark_struct_function);\n-\n   VARRAY_INT_INIT (prologue, 0, \"prologue\");\n   VARRAY_INT_INIT (epilogue, 0, \"epilogue\");\n   VARRAY_INT_INIT (sibcall_epilogue, 0, \"sibcall_epilogue\");\n }\n+\n+#include \"gt-function.h\""}, {"sha": "0c598be18de7a74ca13033d6d80da9ca346d2548", "filename": "gcc/function.h", "status": "modified", "additions": 19, "deletions": 28, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -19,7 +19,7 @@ along with GCC; see the file COPYING.  If not, write to the Free\n Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n 02111-1307, USA.  */\n \n-struct var_refs_queue\n+struct var_refs_queue GTY(())\n {\n   rtx modified;\n   enum machine_mode promoted_mode;\n@@ -32,10 +32,11 @@ struct var_refs_queue\n    The main insn-chain is saved in the last element of the chain,\n    unless the chain is empty.  */\n \n-struct sequence_stack\n+struct sequence_stack GTY(())\n {\n   /* First and last insns in the chain of the saved sequence.  */\n-  rtx first, last;\n+  rtx first;\n+  rtx last;\n   tree sequence_rtl_expr;\n   struct sequence_stack *next;\n };\n@@ -50,7 +51,7 @@ struct simple_obstack_stack\n   struct simple_obstack_stack *next;\n };\n \f\n-struct emit_status\n+struct emit_status GTY(())\n {\n   /* This is reset to LAST_VIRTUAL_REGISTER + 1 at the start of each function.\n      After rtl generation, it is 1 plus the largest register number used.  */\n@@ -96,15 +97,16 @@ struct emit_status\n   /* Indexed by pseudo register number, if nonzero gives the known alignment\n      for that pseudo (if REG_POINTER is set in x_regno_reg_rtx).\n      Allocated in parallel with x_regno_reg_rtx.  */\n-  unsigned char *regno_pointer_align;\n+  unsigned char * GTY ((length (\"%h.regno_pointer_align_length\"))) \n+    regno_pointer_align;\n \n   /* Indexed by pseudo register number, if nonzero gives the decl\n      corresponding to that register.  */\n-  tree *regno_decl;\n+  tree * GTY ((length (\"%h.regno_pointer_align_length\"))) regno_decl;\n \n   /* Indexed by pseudo register number, gives the rtx for that pseudo.\n      Allocated in parallel with regno_pointer_align.  */\n-  rtx *x_regno_reg_rtx;\n+  rtx * GTY ((length (\"%h.regno_pointer_align_length\"))) x_regno_reg_rtx;\n };\n \n /* For backward compatibility... eventually these should all go away.  */\n@@ -116,7 +118,7 @@ struct emit_status\n #define REGNO_POINTER_ALIGN(REGNO) (cfun->emit->regno_pointer_align[REGNO])\n #define REGNO_DECL(REGNO) (cfun->emit->regno_decl[REGNO])\n \n-struct expr_status\n+struct expr_status GTY(())\n {\n   /* Number of units that we should eventually pop off the stack.\n      These are the arguments to function calls that have already returned.  */\n@@ -171,7 +173,7 @@ struct expr_status\n /* This structure can save all the important global and static variables\n    describing the status of the current function.  */\n \n-struct function\n+struct function GTY(())\n {\n   struct eh_status *eh;\n   struct stmt_status *stmt;\n@@ -331,7 +333,7 @@ struct function\n      to put the parm which is nominally in pseudo register REGNO,\n      if we discover that that parm must go in the stack.  The highest\n      element in this vector is one less than MAX_PARM_REG, above.  */\n-  rtx *x_parm_reg_stack_loc;\n+  rtx * GTY ((length (\"%h.x_max_parm_reg\"))) x_parm_reg_stack_loc;\n \n   /* List of all temporaries allocated, both available and in use.  */\n   struct temp_slot *x_temp_slots;\n@@ -355,8 +357,7 @@ struct function\n   /* For integrate.c.  */\n   int inlinable;\n   int no_debugging_symbols;\n-  /* This is in fact an rtvec.  */\n-  void *original_arg_vector;\n+  rtvec original_arg_vector;\n   tree original_decl_initial;\n   /* Last insn of those whose job was to put parms into their nominal\n      homes.  */\n@@ -370,14 +371,14 @@ struct function\n   /* For md files.  */\n \n   /* tm.h can use this to store whatever it likes.  */\n-  struct machine_function *machine;\n+  struct machine_function * GTY ((maybe_undef (\"\"))) machine;\n   /* The largest alignment of slot allocated on the stack.  */\n   int stack_alignment_needed;\n   /* Preferred alignment of the end of stack frame.  */\n   int preferred_stack_boundary;\n \n   /* Language-specific code can use this to store whatever it likes.  */\n-  struct language_function *language;\n+  struct language_function * language;\n \n   /* For reorg.  */\n \n@@ -497,7 +498,7 @@ struct function\n };\n \n /* The function currently being compiled.  */\n-extern struct function *cfun;\n+extern GTY(()) struct function *cfun;\n \n /* Nonzero if we've already converted virtual regs to hard regs.  */\n extern int virtuals_instantiated;\n@@ -585,26 +586,16 @@ extern HOST_WIDE_INT get_frame_size\tPARAMS ((void));\n /* Likewise, but for a different than the current function.  */\n extern HOST_WIDE_INT get_func_frame_size\tPARAMS ((struct function *));\n \n-/* These variables hold pointers to functions to create and destroy\n-   target specific, per-function data structures.  */\n-extern void (*init_machine_status)\tPARAMS ((struct function *));\n-extern void (*free_machine_status)\tPARAMS ((struct function *));\n-/* This variable holds a pointer to a function to register any\n-   data items in the target specific, per-function data structure\n-   that will need garbage collection.  */\n-extern void (*mark_machine_status)\tPARAMS ((struct function *));\n+/* A pointer to a function to create target specific, per-function\n+   data structures.  */\n+extern struct machine_function * (*init_machine_status)\tPARAMS ((void));\n \n /* Save and restore status information for a nested function.  */\n extern void restore_emit_status\t\tPARAMS ((struct function *));\n extern void free_after_parsing\t\tPARAMS ((struct function *));\n extern void free_after_compilation\tPARAMS ((struct function *));\n \n extern void init_varasm_status\t\tPARAMS ((struct function *));\n-extern void free_varasm_status\t\tPARAMS ((struct function *));\n-extern void free_emit_status\t\tPARAMS ((struct function *));\n-extern void free_stmt_status            PARAMS ((struct function *));\n-extern void free_eh_status\t\tPARAMS ((struct function *));\n-extern void free_expr_status\t\tPARAMS ((struct function *));\n \n extern rtx get_first_block_beg\t\tPARAMS ((void));\n "}, {"sha": "fa20e96a395b690f1d82f39f527c5f254556e2e4", "filename": "gcc/gcse.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -1305,11 +1305,11 @@ static basic_block current_bb;\n /* See whether X, the source of a set, is something we want to consider for\n    GCSE.  */\n \n+static GTY(()) rtx test_insn;\n static int\n want_to_gcse_p (x)\n      rtx x;\n {\n-  static rtx test_insn = 0;\n   int num_clobbers = 0;\n   int icode;\n \n@@ -1343,7 +1343,6 @@ want_to_gcse_p (x)\n \t\t\t\t\t\t   FIRST_PSEUDO_REGISTER * 2),\n \t\t\t\t      const0_rtx));\n       NEXT_INSN (test_insn) = PREV_INSN (test_insn) = 0;\n-      ggc_add_rtx_root (&test_insn, 1);\n     }\n \n   /* Now make an insn like the one we would make when GCSE'ing and see if\n@@ -7206,3 +7205,5 @@ store_motion ()\n   remove_fake_edges ();\n   end_alias_analysis ();\n }\n+\n+#include \"gt-gcse.h\""}, {"sha": "a7b23461cb6301da559d7e4ecd8abf6c6ab66b33", "filename": "gcc/gengtype-lex.l", "status": "added", "additions": 322, "deletions": 0, "changes": 322, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fgengtype-lex.l", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fgengtype-lex.l", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype-lex.l?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -0,0 +1,322 @@\n+/* -*- indented-text -*- */\n+/* Process source files and output type information.\n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+%{\n+#define malloc xmalloc\n+#define realloc xrealloc\n+\n+#include \"hconfig.h\"\n+#include \"system.h\"\n+#include <ctype.h>\n+#include \"gengtype.h\"\n+#include \"gengtype-yacc.h\"\n+\n+static void update_lineno PARAMS ((const char *l, size_t len));\n+\n+struct fileloc lexer_line;\n+int lexer_toplevel_done;\n+\n+static void \n+update_lineno (l, len)\n+     const char *l;\n+     size_t len;\n+{\n+  while (len-- > 0)\n+    if (*l++ == '\\n')\n+      lexer_line.line++;\n+}\n+\n+#define IDchar(c) (isalnum(c) || (c) == '_')\n+%}\n+\n+ID\t[[:alpha:]][[:alnum:]_]*\n+WS\t[[:space:]]+\n+IWORD\tshort|long|(un)?signed|char|int|HOST_WIDE_INT|bool|size_t\n+ITYPE\t{IWORD}({WS}{IWORD})*\n+\n+%x in_struct in_struct_comment in_comment in_yacc_escape\n+%option warn noyywrap nounput nodefault perf-report\n+%option 8bit never-interactive\n+%%\n+\n+[^[:alnum:]_]typedef{WS}(struct|union){WS}{ID}{WS}?[*[:space:]]{WS}?{ID}{WS}?\";\" {\n+  char *tagstart;\n+  size_t taglen;\n+  char *namestart;\n+  size_t namelen;\n+  int is_pointer = 0;\n+  struct type *t;\n+  int union_p;\n+\n+  tagstart = yytext + strlen (\" typedef \");\n+  while (isspace (*tagstart))\n+    tagstart++;\n+  union_p = tagstart[0] == 'u';\n+  tagstart += strlen (\"union \");\n+  while (isspace (*tagstart))\n+    tagstart++;\n+  for (taglen = 1; IDchar (tagstart[taglen]); taglen++)\n+    ;\n+  for (namestart = tagstart + taglen; \n+       ! IDchar (*namestart);\n+       namestart++)\n+    if (*namestart == '*')\n+      is_pointer = 1;\n+  for (namelen = 1; IDchar (namestart[namelen]); namelen++)\n+    ;\n+  t = find_structure (xmemdup (tagstart, taglen, taglen+1), union_p);\n+  if (is_pointer)\n+    t = create_pointer (t);\n+  do_typedef (xmemdup (namestart, namelen, namelen+1), t, &lexer_line);\n+  update_lineno (yytext, yyleng);\n+}\n+\n+[^[:alnum:]_]typedef{WS}{ITYPE}{WS}{ID}{WS}?\";\" {\n+\n+  char *namestart;\n+  size_t namelen;\n+  struct type *t;\n+  char *typestart;\n+  size_t typelen;\n+\n+  for (namestart = yytext + yyleng - 2; isspace (*namestart); namestart--)\n+    ;\n+  for (namelen = 1; !isspace (namestart[-namelen]); namelen++)\n+    ;\n+  namestart -= namelen - 1;\n+  for (typestart = yytext + strlen (\" typedef \"); \n+       isspace(*typestart);\n+       typestart++)\n+    ;\n+  for (typelen = namestart - typestart; \n+       isspace(typestart[typelen-1]); \n+       typelen--)\n+    ;\n+\n+  t = create_scalar_type (typestart, typelen);\n+  do_typedef (xmemdup (namestart, namelen, namelen+1), t, &lexer_line);\n+  update_lineno (yytext, yyleng);\n+}\n+\n+[^[:alnum:]_]typedef{WS}{ID}{WS}{ID}{WS}PARAMS {\n+  char *namestart;\n+  size_t namelen;\n+  struct type *t;\n+\n+  for (namestart = yytext + yyleng - 7; isspace (*namestart); namestart--)\n+    ;\n+  for (namelen = 1; !isspace (namestart[-namelen]); namelen++)\n+    ;\n+  namestart -= namelen - 1;\n+\n+  t = create_scalar_type (\"function type\", sizeof (\"function type\")-1);\n+  do_typedef (xmemdup (namestart, namelen, namelen+1), t, &lexer_line);\n+  update_lineno (yytext, yyleng);\n+}\n+[^[:alnum:]_]typedef{WS}{ID}{WS}?\"(\"{WS}?\"*\"{WS}?{ID}{WS}?\")\"{WS}?PARAMS {\n+  char *namestart;\n+  size_t namelen;\n+  struct type *t;\n+\n+  for (namestart = yytext + yyleng - 7; !IDchar (*namestart); namestart--)\n+    ;\n+  for (namelen = 1; IDchar (namestart[-namelen]); namelen++)\n+    ;\n+  namestart -= namelen - 1;\n+\n+  t = create_scalar_type (\"function type\", sizeof (\"function type\")-1);\n+  do_typedef (xmemdup (namestart, namelen, namelen+1), t, &lexer_line);\n+  update_lineno (yytext, yyleng);\n+}\n+\n+[^[:alnum:]_](typedef{WS})?(struct|union){WS}{ID}{WS}/\"GTY\" {\n+  char *tagstart;\n+  size_t taglen;\n+  int typedef_p;\n+  int union_p;\n+\n+  typedef_p = yytext[1] == 't';\n+  if (typedef_p)\n+    for (tagstart = yytext + strlen (\" typedef \"); \n+\t isspace(*tagstart);\n+\t tagstart++)\n+      ;\n+  else\n+    tagstart = yytext + 1;\n+\n+  union_p = tagstart[0] == 'u';\n+  tagstart += strlen (\"union \");\n+  while (isspace (*tagstart))\n+    tagstart++;\n+  for (taglen = 1; IDchar (tagstart[taglen]); taglen++)\n+    ;\n+\n+  yylval.t = find_structure (xmemdup (tagstart, taglen, taglen + 1), union_p);\n+  BEGIN(in_struct);\n+  update_lineno (yytext, yyleng);\n+  return typedef_p ? ENT_TYPEDEF_STRUCT : ENT_STRUCT;\n+}\n+\n+[^[:alnum:]_](extern|static){WS}/\"GTY\" {\n+  BEGIN(in_struct);\n+  update_lineno (yytext, yyleng);\n+  return ENT_EXTERNSTATIC;\n+}\n+\n+^\"%union\"{WS}\"{\"{WS}/\"GTY\" {\n+  BEGIN(in_struct);\n+  update_lineno (yytext, yyleng);\n+  return ENT_YACCUNION;\n+}\n+\n+<in_struct>{\n+\n+\"/*\"\t\t\t\t{ BEGIN(in_struct_comment); }\n+\n+^\"%{\"\t\t\t\t{ BEGIN(in_yacc_escape); }\n+\n+{WS}\t\t\t\t{ update_lineno (yytext, yyleng); }\n+\n+\"const\"/[^[:alnum:]_]\t\t/* don't care */\n+\n+\"GTY\"/[^[:alnum:]_]\t\t{ return GTY_TOKEN; }\n+\"union\"/[^[:alnum:]_]\t\t{ return UNION; }\n+\"struct\"/[^[:alnum:]_]\t\t{ return STRUCT; }\n+\"enum\"/[^[:alnum:]_]\t\t{ return ENUM; }\n+\"ptr_alias\"/[^[:alnum:]_]\t{ return ALIAS; }\n+\"param_is\"/[^[:alnum:]_]\t{ return PARAM_IS; }\n+[0-9]+\t\t\t\t{ return NUM; }\n+\n+{IWORD}({WS}{IWORD})*/[^[:alnum:]_]\t\t|\n+\"ENUM_BITFIELD\"{WS}?\"(\"{WS}?{ID}{WS}?\")\"\t{\n+  size_t len;\n+\n+  for (len = yyleng; isspace (yytext[len-1]); len--)\n+    ;\n+\n+  yylval.t = create_scalar_type (yytext, len);\n+  update_lineno (yytext, yyleng);\n+  return SCALAR;\n+}\n+\n+{ID}/[^[:alnum:]_]\t\t{\n+  yylval.s = xmemdup (yytext, yyleng, yyleng+1);\n+  return ID;\n+}\n+\n+\\\"([^\"\\\\]|\\\\.)*\\\"\t\t{\n+  yylval.s = xmemdup (yytext+1, yyleng-2, yyleng-1);\n+  return STRING;\n+}\n+\"[\"[^\\[\\]]*\"]\"\t\t\t{\n+  yylval.s = xmemdup (yytext+1, yyleng-2, yyleng-1);\n+  return ARRAY;\n+}\n+^\"%\"{ID}\t\t\t{\n+  yylval.s = xmemdup (yytext+1, yyleng-1, yyleng);\n+  return PERCENT_ID;\n+}\n+\"'\"(\"\\\\\".|[^\\\\])\"'\"\t\t{\n+  yylval.s = xmemdup (yytext+1, yyleng-2, yyleng);\n+  return CHAR;\n+}\n+\n+[(){},*:<>]\t\t\t{ return yytext[0]; }\n+\n+[;=]\t\t\t\t{\n+  if (lexer_toplevel_done)\n+    {\n+      BEGIN(INITIAL);\n+      lexer_toplevel_done = 0;\n+    }\n+  return yytext[0];\n+}\n+\n+^\"%%\"\t\t\t\t{\n+  BEGIN(INITIAL);\n+  return PERCENTPERCENT;\n+}\n+\n+.\t\t\t\t{\n+  error_at_line (&lexer_line, \"unexpected character `%s'\", yytext);\n+}\n+}\n+\n+\"/*\"\t\t\t{ BEGIN(in_comment); }\n+\\n\t\t\t{ lexer_line.line++; }\n+{ID}\t\t\t|\n+[^\"/\\n]\t\t\t/* do nothing */\n+\\\"([^\"\\\\]|\\\\.|\\\\\\n)*\\\"\t{ update_lineno (yytext, yyleng); }\n+\"/\"/[^*]\t\t/* do nothing */\n+\n+<in_comment,in_struct_comment>{\n+\\n\t\t{ lexer_line.line++; }\n+[^*\\n]{16}\t|\n+[^*\\n]\t\t/* do nothing */\n+\"*\"/[^/]\t/* do nothing */\n+}\n+<in_comment>\"*/\"\t{ BEGIN(INITIAL); } \n+<in_struct_comment>\"*/\"\t{ BEGIN(in_struct); }\n+\n+<in_yacc_escape>{\n+\\n\t\t{ lexer_line.line++; }\n+[^%]{16}\t|\n+[^%]\t\t/* do nothing */\n+\"%\"/[^}]\t/* do nothing */\n+\"%}\"\t\t{ BEGIN(in_struct); }\n+\"%\"\t\t{\n+  error_at_line (&lexer_line, \n+\t\t \"unterminated %{; unexpected EOF\");\n+}\n+}\n+\n+\n+[\"/]    \t\t|\n+<in_struct_comment,in_comment>\"*\"\t{\n+  error_at_line (&lexer_line, \n+\t\t \"unterminated comment or string; unexpected EOF\");\n+}\n+\n+%%\n+\n+void\n+yyerror (s)\n+     const char *s;\n+{\n+  error_at_line (&lexer_line, s);\n+}\n+\n+void\n+parse_file (fname)\n+      char *fname;\n+{\n+  yyin = fopen (fname, \"r\");\n+  lexer_line.file = fname;\n+  lexer_line.line = 1;\n+  if (yyin == NULL)\n+    {\n+      perror (fname);\n+      exit (1);\n+    }\n+  if (yyparse() != 0)\n+    exit (1);\n+  fclose (yyin);\n+}"}, {"sha": "43fbea66ab751402ca9c9b8283edf79550fba0ae", "filename": "gcc/gengtype-yacc.y", "status": "added", "additions": 282, "deletions": 0, "changes": 282, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fgengtype-yacc.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fgengtype-yacc.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype-yacc.y?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -0,0 +1,282 @@\n+/* -*- indented-text -*- */\n+/* Process source files and output type information.\n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+%{\n+#include \"hconfig.h\"\n+#include \"system.h\"\n+#include \"gengtype.h\"\n+#define YYERROR_VERBOSE\n+%}\n+\n+%union {\n+  type_p t;\n+  pair_p p;\n+  options_p o;\n+  const char *s;\n+}\n+\n+%token <t>ENT_TYPEDEF_STRUCT\n+%token <t>ENT_STRUCT\n+%token ENT_EXTERNSTATIC\n+%token ENT_YACCUNION\n+%token GTY_TOKEN \"GTY\"\n+%token UNION \"union\"\n+%token STRUCT \"struct\"\n+%token ENUM \"enum\"\n+%token ALIAS \"ptr_alias\"\n+%token PARAM_IS \"param_is\"\n+%token NUM\n+%token PERCENTPERCENT \"%%\"\n+%token <t>SCALAR\n+%token <s>ID\n+%token <s>STRING\n+%token <s>ARRAY\n+%token <s>PERCENT_ID\n+%token <s>CHAR\n+\n+%type <p> struct_fields yacc_ids yacc_typematch\n+%type <t> type lasttype\n+%type <o> optionsopt options option optionseq optionseqopt\n+%type <s> type_option\n+\n+%%\n+\n+start: /* empty */\n+       | typedef_struct start\n+       | externstatic start\n+       | yacc_union start\n+\n+typedef_struct: ENT_TYPEDEF_STRUCT options '{' struct_fields '}' ID\n+\t\t   {\n+\t\t     new_structure ($1->u.s.tag, UNION_P ($1), &lexer_line,\n+\t\t\t\t    $4, $2);\n+\t\t     do_typedef ($6, $1, &lexer_line);\n+\t\t     lexer_toplevel_done = 1;\n+\t\t   }\n+\t\t ';'\n+\t\t| ENT_STRUCT options '{' struct_fields '}'\n+\t\t   {\n+\t\t     new_structure ($1->u.s.tag, UNION_P ($1), &lexer_line,\n+\t\t\t\t    $4, $2);\n+\t\t     lexer_toplevel_done = 1;\n+\t\t   }\n+\t\t ';'\n+\n+externstatic: ENT_EXTERNSTATIC options lasttype ID semiequal\n+\t         {\n+\t           note_variable ($4, adjust_field_type ($3, $2), $2, \n+\t\t\t\t  &lexer_line);\n+\t         }\n+\t      | ENT_EXTERNSTATIC options lasttype ID ARRAY semiequal\n+\t         {\n+\t           note_variable ($4, create_array ($3, $5),\n+\t      \t\t    $2, &lexer_line);\n+\t         }\n+\t      | ENT_EXTERNSTATIC options lasttype ID ARRAY ARRAY semiequal\n+\t         {\n+\t           note_variable ($4, create_array (create_array ($3, $6),\n+\t      \t\t\t\t      $5),\n+\t      \t\t    $2, &lexer_line);\n+\t         }\n+\n+lasttype: type\n+\t    { \n+\t      lexer_toplevel_done = 1;\n+\t      $$ = $1;\n+\t    }\n+\n+semiequal: ';'\n+\t   | '='\n+\t   ;\n+\n+yacc_union: ENT_YACCUNION options struct_fields '}' yacc_typematch PERCENTPERCENT\n+\t      {\n+\t        note_yacc_type ($2, $3, $5, &lexer_line);\n+\t      }\n+\n+yacc_typematch: /* empty */\n+\t\t   { $$ = NULL; }\n+\t\t| yacc_typematch PERCENT_ID yacc_ids\n+\t\t   { \n+\t\t     pair_p p;\n+\t\t     for (p = $3; p->next != NULL; p = p->next)\n+\t\t       {\n+\t\t         p->name = NULL;\n+\t\t\t p->type = NULL;\n+\t\t       }\n+\t\t     p->name = NULL;\n+\t\t     p->type = NULL;\n+\t\t     p->next = $1;\n+\t\t     $$ = $3;\n+\t\t   }\n+\t\t| yacc_typematch PERCENT_ID '<' ID '>' yacc_ids\n+\t\t   {\n+\t\t     pair_p p;\n+\t\t     type_p newtype = NULL;\n+\t\t     if (strcmp ($2, \"type\") == 0)\n+\t\t       newtype = (type_p) 1;\n+\t\t     for (p = $6; p->next != NULL; p = p->next)\n+\t\t       {\n+\t\t         p->name = $4;\n+\t\t         p->type = newtype;\n+\t\t       }\n+\t\t     p->name = $4;\n+\t\t     p->next = $1;\n+\t\t     p->type = newtype;\n+\t\t     $$ = $6;\n+\t\t   }\n+\t\t;\n+\n+yacc_ids: /* empty */\n+\t{ $$ = NULL; }\n+     | yacc_ids ID\n+        { \n+\t  pair_p p = xcalloc (1, sizeof (*p));\n+\t  p->next = $1;\n+\t  p->line = lexer_line;\n+\t  p->opt = xmalloc (sizeof (*(p->opt)));\n+\t  p->opt->name = \"tag\";\n+\t  p->opt->next = NULL;\n+\t  p->opt->info = (char *)$2;\n+\t  $$ = p;\n+\t}\n+     | yacc_ids CHAR\n+        {\n+\t  pair_p p = xcalloc (1, sizeof (*p));\n+\t  p->next = $1;\n+\t  p->line = lexer_line;\n+\t  p->opt = xmalloc (sizeof (*(p->opt)));\n+\t  p->opt->name = \"tag\";\n+\t  p->opt->next = NULL;\n+\t  p->opt->info = xmalloc (3 + strlen ($2));\n+\t  sprintf (p->opt->info, \"'%s'\", $2);\n+\t  $$ = p;\n+\t}\n+\n+struct_fields: { $$ = NULL; }\n+\t       | type optionsopt ID bitfieldopt ';' struct_fields\n+\t          {\n+\t            pair_p p = xmalloc (sizeof (*p));\n+\t\t    p->type = adjust_field_type ($1, $2);\n+\t\t    p->opt = $2;\n+\t\t    p->name = $3;\n+\t\t    p->next = $6;\n+\t\t    p->line = lexer_line;\n+\t\t    $$ = p;\n+\t\t  }\n+\t       | type optionsopt ID ARRAY ';' struct_fields\n+\t          {\n+\t            pair_p p = xmalloc (sizeof (*p));\n+\t\t    p->type = adjust_field_type (create_array ($1, $4), $2);\n+\t\t    p->opt = $2;\n+\t\t    p->name = $3;\n+\t\t    p->next = $6;\n+\t\t    p->line = lexer_line;\n+\t\t    $$ = p;\n+\t\t  }\n+\t       | type optionsopt ID ARRAY ARRAY ';' struct_fields\n+\t          {\n+\t            pair_p p = xmalloc (sizeof (*p));\n+\t\t    p->type = create_array (create_array ($1, $5), $4);\n+\t\t    p->opt = $2;\n+\t\t    p->name = $3;\n+\t\t    p->next = $7;\n+\t\t    p->line = lexer_line;\n+\t\t    $$ = p;\n+\t\t  }\n+\n+bitfieldopt: /* empty */\n+\t     | ':' NUM\n+\n+type: SCALAR\n+         { $$ = $1; }\n+      | ID\n+         { $$ = resolve_typedef ($1, &lexer_line); }\n+      | type '*'\n+         { $$ = create_pointer ($1); }\n+      | STRUCT ID '{' struct_fields '}'\n+         {\n+\t   new_structure ($2, 0, &lexer_line, $4, NULL);\n+           $$ = find_structure ($2, 0);\n+\t }\n+      | STRUCT ID\n+         { $$ = find_structure ($2, 0); }\n+      | UNION ID '{' struct_fields '}'\n+         {\n+\t   new_structure ($2, 1, &lexer_line, $4, NULL);\n+           $$ = find_structure ($2, 1);\n+\t }\n+      | UNION ID\n+         { $$ = find_structure ($2, 1); }\n+      | ENUM ID\n+         { $$ = create_scalar_type ($2, strlen ($2)); }\n+      | ENUM ID '{' enum_items '}'\n+         { $$ = create_scalar_type ($2, strlen ($2)); }\n+\n+enum_items: /* empty */\n+\t    | ID '=' NUM ',' enum_items\n+\t      { }\n+\t    | ID ',' enum_items\n+\t      { }\n+\t    | ID enum_items\n+\t      { }\n+\t    ;\n+\n+optionsopt: { $$ = NULL; }\n+\t    | options { $$ = $1; }\n+\n+options: GTY_TOKEN '(' '(' optionseqopt ')' ')' { $$ = $4; }\n+\n+type_option : ALIAS\n+\t        { $$ = \"ptr_alias\"; }\n+\t      | PARAM_IS\n+\t        { $$ = \"param_is\"; }\n+\n+option:\ttype_option '(' type ')'\n+\t   {\n+\t     options_p o = xmalloc (sizeof (*o));\n+\t     o->name = $1;\n+\t     o->info = $3;\n+\t     $$ = o;\n+\t   }\n+\t| ID '(' STRING ')'\n+\t   { \n+\t     options_p o = xmalloc (sizeof (*o));\n+\t     o->name = $1;\n+\t     o->info = (void *)$3;\n+\t     $$ = o;\n+\t   }\n+\n+optionseq: option\n+\t      {\n+\t        $1->next = NULL;\n+\t\t$$ = $1;\n+\t      }\n+\t    | optionseq ',' option\n+\t      {\n+\t        $3->next = $1;\n+\t\t$$ = $3;\n+\t      }\n+\n+optionseqopt: { $$ = NULL }\n+\t      | optionseq { $$ = $1; }\n+\n+%%"}, {"sha": "dda57e2d239e5c6f14505326e5bbd83c4d49c4e9", "filename": "gcc/gengtype.c", "status": "added", "additions": 1824, "deletions": 0, "changes": 1824, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -0,0 +1,1824 @@\n+/* Process source files and output type information.\n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+#include \"hconfig.h\"\n+#include \"system.h\"\n+#include <ctype.h>\n+#include \"gengtype.h\"\n+\n+static int hit_error = 0;\n+void\n+error_at_line VPARAMS ((struct fileloc *pos, const char *msg, ...))\n+{\n+  VA_OPEN (ap, msg);\n+  VA_FIXEDARG (ap, struct fileloc *, pos);\n+  VA_FIXEDARG (ap, const char *, msg);\n+\n+  fprintf (stderr, \"%s:%d: \", pos->file, pos->line);\n+  vfprintf (stderr, msg, ap);\n+  fputc ('\\n', stderr);\n+  hit_error = 1;\n+\n+  VA_CLOSE (ap);\n+}\n+\n+struct type string_type = {\n+  TYPE_STRING, NULL, NULL, GC_USED\n+  UNION_INIT_ZERO\n+}; \n+\n+static pair_p typedefs;\n+static type_p structures;\n+static type_p param_structs;\n+static pair_p variables;\n+\n+void\n+do_typedef (s, t, pos)\n+     const char *s;\n+     type_p t;\n+     struct fileloc *pos;\n+{\n+  pair_p p;\n+\n+  for (p = typedefs; p != NULL; p = p->next)\n+    if (strcmp (p->name, s) == 0)\n+      {\n+\tif (p->type != t)\n+\t  {\n+\t    error_at_line (pos, \"type `%s' previously defined\", s);\n+\t    error_at_line (&p->line, \"previously defined here\");\n+\t  }\n+\treturn;\n+      }\n+\n+  p = xmalloc (sizeof (struct pair));\n+  p->next = typedefs;\n+  p->name = s;\n+  p->type = t;\n+  p->line = *pos;\n+  typedefs = p;\n+}\n+\n+type_p\n+resolve_typedef (s, pos)\n+     const char *s;\n+     struct fileloc *pos;\n+{\n+  pair_p p;\n+  for (p = typedefs; p != NULL; p = p->next)\n+    if (strcmp (p->name, s) == 0)\n+      return p->type;\n+  error_at_line (pos, \"unidentified type `%s'\", s);\n+  return create_scalar_type (\"char\", 4);\n+}\n+\n+void\n+new_structure (name, isunion, pos, fields, o)\n+     const char *name;\n+     int isunion;\n+     struct fileloc *pos;\n+     pair_p fields;\n+     options_p o;\n+{\n+  type_p si;\n+  type_p s = NULL;\n+  lang_bitmap bitmap = get_base_file_bitmap (pos->file);\n+\n+  for (si = structures; si != NULL; si = si->next)\n+    if (strcmp (name, si->u.s.tag) == 0 \n+\t&& UNION_P (si) == isunion)\n+      {\n+\ttype_p ls = NULL;\n+\tif (si->kind == TYPE_LANG_STRUCT)\n+\t  {\n+\t    ls = si;\n+\t    \n+\t    for (si = ls->u.s.lang_struct; si != NULL; si = si->next)\n+\t      if (si->u.s.bitmap == bitmap)\n+\t\ts = si;\n+\t  }\n+\telse if (si->u.s.line.file != NULL && si->u.s.bitmap != bitmap)\n+\t  {\n+\t    ls = si;\n+\t    si = xcalloc (1, sizeof (struct type));\n+\t    memcpy (si, ls, sizeof (struct type));\n+\t    ls->kind = TYPE_LANG_STRUCT;\n+\t    ls->u.s.lang_struct = si;\n+\t    ls->u.s.fields = NULL;\n+\t    si->next = NULL;\n+\t    si->pointer_to = NULL;\n+\t    si->u.s.lang_struct = ls;\n+\t  }\n+\telse\n+\t  s = si;\n+\n+\tif (ls != NULL && s == NULL)\n+\t  {\n+\t    s = xcalloc (1, sizeof (struct type));\n+\t    s->next = ls->u.s.lang_struct;\n+\t    ls->u.s.lang_struct = s;\n+\t    s->u.s.lang_struct = ls;\n+\t  }\n+\tbreak;\n+      }\n+  \n+  if (s == NULL)\n+    {\n+      s = xcalloc (1, sizeof (struct type));\n+      s->next = structures;\n+      structures = s;\n+    }\n+\n+  if (s->u.s.line.file != NULL\n+      || (s->u.s.lang_struct && (s->u.s.lang_struct->u.s.bitmap & bitmap)))\n+    {\n+      error_at_line (pos, \"duplicate structure definition\");\n+      error_at_line (&s->u.s.line, \"previous definition here\");\n+    }\n+\n+  s->kind = isunion ? TYPE_UNION : TYPE_STRUCT;\n+  s->u.s.tag = name;\n+  s->u.s.line = *pos;\n+  s->u.s.fields = fields;\n+  s->u.s.opt = o;\n+  s->u.s.bitmap = bitmap;\n+  if (s->u.s.lang_struct)\n+    s->u.s.lang_struct->u.s.bitmap |= bitmap;\n+}\n+\n+type_p\n+find_structure (name, isunion)\n+     const char *name;\n+     int isunion;\n+{\n+  type_p s;\n+\n+  for (s = structures; s != NULL; s = s->next)\n+    if (strcmp (name, s->u.s.tag) == 0 \n+\t&& UNION_P (s) == isunion)\n+      return s;\n+\n+  s = xcalloc (1, sizeof (struct type));\n+  s->next = structures;\n+  structures = s;\n+  s->kind = isunion ? TYPE_UNION : TYPE_STRUCT;\n+  s->u.s.tag = name;\n+  structures = s;\n+  return s;\n+}\n+\n+type_p\n+create_scalar_type (name, name_len)\n+     const char *name;\n+     size_t name_len;\n+{\n+  type_p r = xcalloc (1, sizeof (struct type));\n+  r->kind = TYPE_SCALAR;\n+  r->u.sc = xmemdup (name, name_len, name_len + 1);\n+  return r;\n+}\n+\n+type_p\n+create_pointer (t)\n+     type_p t;\n+{\n+  if (! t->pointer_to)\n+    {\n+      type_p r = xcalloc (1, sizeof (struct type));\n+      r->kind = TYPE_POINTER;\n+      r->u.p = t;\n+      t->pointer_to = r;\n+    }\n+  return t->pointer_to;\n+}\n+\n+type_p\n+create_array (t, len)\n+     type_p t;\n+     const char *len;\n+{\n+  type_p v;\n+  \n+  v = xcalloc (1, sizeof (*v));\n+  v->kind = TYPE_ARRAY;\n+  v->u.a.p = t;\n+  v->u.a.len = len;\n+  return v;\n+}\n+\n+type_p\n+adjust_field_type (t, opt)\n+     type_p t;\n+     options_p opt;\n+{\n+  int length_p = 0;\n+  const int pointer_p = t->kind == TYPE_POINTER;\n+  \n+  for (; opt; opt = opt->next)\n+    if (strcmp (opt->name, \"length\") == 0)\n+      length_p = 1;\n+    else if (strcmp (opt->name, \"param_is\") == 0)\n+      {\n+\ttype_p realt;\n+\n+\tif (pointer_p)\n+\t  t = t->u.p;\n+\t\n+\tfor (realt = param_structs; realt; realt = realt->next)\n+\t  if (realt->u.param_struct.stru == t\n+\t      && realt->u.param_struct.param == (type_p) opt->info)\n+\t    return pointer_p ? create_pointer (realt) : realt;\n+\trealt = xcalloc (1, sizeof (*realt));\n+\trealt->kind = TYPE_PARAM_STRUCT;\n+\trealt->next = param_structs;\n+\tparam_structs = realt;\n+\trealt->u.param_struct.stru = t;\n+\trealt->u.param_struct.param = (type_p) opt->info;\n+\treturn pointer_p ? create_pointer (realt) : realt;\n+      }\n+  \n+  if (! length_p\n+      && pointer_p\n+      && t->u.p->kind == TYPE_SCALAR\n+      && (strcmp (t->u.p->u.sc, \"char\") == 0\n+\t  || strcmp (t->u.p->u.sc, \"unsigned char\") == 0))\n+    return &string_type;\n+  if (t->kind == TYPE_ARRAY && t->u.a.p->kind == TYPE_POINTER\n+      && t->u.a.p->u.p->kind == TYPE_SCALAR\n+      && (strcmp (t->u.a.p->u.p->u.sc, \"char\") == 0\n+\t  || strcmp (t->u.a.p->u.p->u.sc, \"unsigned char\") == 0))\n+    return create_array (&string_type, t->u.a.len);\n+\n+  return t;\n+}\n+\n+void\n+note_variable (s, t, o, pos)\n+     const char *s;\n+     type_p t;\n+     options_p o;\n+     struct fileloc *pos;\n+{\n+  pair_p n;\n+  n = xmalloc (sizeof (*n));\n+  n->name = s;\n+  n->type = t;\n+  n->line = *pos;\n+  n->opt = o;\n+  n->next = variables;\n+  variables = n;\n+}\n+\n+void\n+note_yacc_type (o, fields, typeinfo, pos)\n+     options_p o;\n+     pair_p fields;\n+     pair_p typeinfo;\n+     struct fileloc *pos;\n+{\n+  pair_p p;\n+  pair_p *p_p;\n+  \n+  for (p = typeinfo; p; p = p->next)\n+    {\n+      pair_p m;\n+      \n+      if (p->name == NULL)\n+\tcontinue;\n+\n+      if (p->type == (type_p) 1)\n+\t{\n+\t  pair_p pp;\n+\t  int ok = 0;\n+\t  \n+\t  for (pp = typeinfo; pp; pp = pp->next)\n+\t    if (pp->type != (type_p) 1\n+\t\t&& strcmp (pp->opt->info, p->opt->info) == 0)\n+\t      {\n+\t\tok = 1;\n+\t\tbreak;\n+\t      }\n+\t  if (! ok)\n+\t    continue;\n+\t}\n+\n+      for (m = fields; m; m = m->next)\n+\tif (strcmp (m->name, p->name) == 0)\n+\t  p->type = m->type;\n+      if (p->type == NULL)\n+\t{\n+\t  error_at_line (&p->line, \n+\t\t\t \"couldn't match fieldname `%s'\", p->name);\n+\t  p->name = NULL;\n+\t}\n+    }\n+  \n+  p_p = &typeinfo;\n+  while (*p_p)\n+    {\n+      pair_p p = *p_p;\n+\n+      if (p->name == NULL\n+\t  || p->type == (type_p) 1)\n+\t*p_p = p->next;\n+      else\n+\tp_p = &p->next;\n+    }\n+\n+  new_structure (\"yy_union\", 1, pos, typeinfo, o);\n+  do_typedef (\"YYSTYPE\", find_structure (\"yy_union\", 1), pos);\n+}\n+\f\n+static void process_gc_options PARAMS ((options_p, enum gc_used_enum, int *));\n+static void set_gc_used_type PARAMS ((type_p, enum gc_used_enum));\n+static void set_gc_used PARAMS ((pair_p));\n+\n+static void\n+process_gc_options (opt, level, maybe_undef)\n+     options_p opt;\n+     enum gc_used_enum level;\n+     int *maybe_undef;\n+{\n+  options_p o;\n+  for (o = opt; o; o = o->next)\n+    if (strcmp (o->name, \"ptr_alias\") == 0 && level == GC_POINTED_TO)\n+      set_gc_used_type ((type_p) o->info, GC_POINTED_TO);\n+    else if (strcmp (o->name, \"maybe_undef\") == 0)\n+      *maybe_undef = 1;\n+}\n+\n+static void\n+set_gc_used_type (t, level)\n+     type_p t;\n+     enum gc_used_enum level;\n+{\n+  if (t->gc_used >= level)\n+    return;\n+\n+  t->gc_used = level;\n+\n+  switch (t->kind)\n+    {\n+    case TYPE_STRUCT:\n+    case TYPE_UNION:\n+      {\n+\tpair_p f;\n+\tint dummy;\n+\n+\tprocess_gc_options (t->u.s.opt, level, &dummy);\n+\n+\tfor (f = t->u.s.fields; f; f = f->next)\n+\t  {\n+\t    int maybe_undef = 0;\n+\t    process_gc_options (t->u.s.opt, level, &maybe_undef);\n+\t    \n+\t    if (maybe_undef && f->type->kind == TYPE_POINTER)\n+\t      set_gc_used_type (f->type->u.p, GC_MAYBE_POINTED_TO);\n+\t    else\n+\t      set_gc_used_type (f->type, GC_USED);\n+\t  }\n+\tbreak;\n+      }\n+\n+    case TYPE_POINTER:\n+      set_gc_used_type (t->u.p, GC_POINTED_TO);\n+      break;\n+\n+    case TYPE_ARRAY:\n+      set_gc_used_type (t->u.a.p, GC_USED);\n+      break;\n+      \n+    case TYPE_LANG_STRUCT:\n+      for (t = t->u.s.lang_struct; t; t = t->next)\n+\tset_gc_used_type (t, level);\n+      break;\n+\n+    case TYPE_PARAM_STRUCT:\n+      set_gc_used_type (t->u.param_struct.param, GC_POINTED_TO);\n+      set_gc_used_type (t->u.param_struct.stru, GC_USED);\n+      break;\n+\n+    default:\n+      break;\n+    }\n+}\n+\n+static void\n+set_gc_used (variables)\n+     pair_p variables;\n+{\n+  pair_p p;\n+  for (p = variables; p; p = p->next)\n+    set_gc_used_type (p->type, GC_USED);\n+}\n+\f\n+/* File mapping routines.  For each input file, there is one output .c file\n+   (but some output files have many input files), and there is one .h file\n+   for the whole build.  */\n+\n+typedef struct filemap *filemap_p;\n+\n+struct filemap {\n+  filemap_p next;\n+  const char *input_name;\n+  const char *output_name;\n+  FILE *output;\n+};\n+\n+static filemap_p files;\n+FILE * header_file;\n+\n+enum {\n+  BASE_FILE_C,\n+  BASE_FILE_OBJC,\n+  BASE_FILE_CPLUSPLUS\n+};\n+static const char *lang_names[] = {\n+  \"c\", \"objc\", \"cp\", \"f\", \"ada\", \"java\"\n+};\n+#define NUM_BASE_FILES (sizeof (lang_names) / sizeof (lang_names[0]))\n+FILE *base_files[NUM_BASE_FILES];\n+\n+static FILE * create_file PARAMS ((const char *));\n+static const char * get_file_basename PARAMS ((const char *));\n+\n+static FILE *\n+create_file (name)\n+     const char *name;\n+{\n+  static const char *const hdr[] = {\n+    \"   Copyright (C) 2002 Free Software Foundation, Inc.\\n\",\n+    \"\\n\",\n+    \"This file is part of GCC.\\n\",\n+    \"\\n\",\n+    \"GCC is free software; you can redistribute it and/or modify it under\\n\",\n+    \"the terms of the GNU General Public License as published by the Free\\n\",\n+    \"Software Foundation; either version 2, or (at your option) any later\\n\",\n+    \"version.\\n\",\n+    \"\\n\",\n+    \"GCC is distributed in the hope that it will be useful, but WITHOUT ANY\\n\",\n+    \"WARRANTY; without even the implied warranty of MERCHANTABILITY or\\n\",\n+    \"FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\\n\",\n+    \"for more details.\\n\",\n+    \"\\n\",\n+    \"You should have received a copy of the GNU General Public License\\n\",\n+    \"along with GCC; see the file COPYING.  If not, write to the Free\\n\",\n+    \"Software Foundation, 59 Temple Place - Suite 330, Boston, MA\\n\",\n+    \"02111-1307, USA.  */\\n\",\n+    \"\\n\",\n+    \"/* This file is machine generated.  Do not edit.  */\\n\"\n+  };\n+  FILE *f;\n+  size_t i;\n+  \n+  f = tmpfile();\n+  if (f == NULL)\n+    {\n+      perror (\"couldn't create temporary file\");\n+      exit (1);\n+    }\n+  fprintf (f, \"/* Type information for %s.\\n\", name);\n+  for (i = 0; i < sizeof(hdr)/sizeof(hdr[0]); i++)\n+    fputs (hdr[i], f);\n+  return f;\n+}\n+\n+static void\n+open_base_files (void)\n+{\n+  size_t i;\n+  \n+  header_file = create_file (\"GCC\");\n+\n+  for (i = 0; i < NUM_BASE_FILES; i++)\n+    {\n+      filemap_p newf;\n+      char *s;\n+      \n+      base_files[i] = create_file (lang_names[i]);\n+      newf = xmalloc (sizeof (*newf));\n+      newf->next = files;\n+      files = newf;\n+      newf->input_name = NULL;\n+      newf->output = base_files[i];\n+      newf->output_name = s = xmalloc (16);\n+      sprintf (s, \"gtype-%s.h\", lang_names[i]);\n+    }\n+}\n+\n+#define startswith(len, c, s)  \\\n+  ((size_t)(len) >= strlen (s) && memcmp (c, s, strlen (s)) == 0)\n+\n+static const char *\n+get_file_basename (f)\n+     const char *f;\n+{\n+  size_t len;\n+  const char *basename;\n+  \n+  /* Determine the output file name.  */\n+  len = strlen (f);\n+  basename = strrchr (f, '/');\n+  if (basename == NULL)\n+    basename = f;\n+  else\n+    basename++;\n+  if (startswith (basename - f, basename-2, \"f/\"))\n+    basename -= 2;\n+  else if (startswith (basename - f, basename-3, \"cp/\"))\n+    basename -= 3;\n+  else if (startswith (basename - f, basename-4, \"ada/\"))\n+    basename -= 4;\n+  else if (startswith (basename - f, basename-5, \"java/\"))\n+    basename -= 5;\n+  else if (startswith (basename - f, basename-5, \"objc/\"))\n+    basename -= 5;\n+\n+  return basename;\n+}\n+\n+unsigned\n+get_base_file_bitmap (input_file)\n+     const char *input_file;\n+{\n+  const char *basename = get_file_basename (input_file);\n+  const char *slashpos = strchr (basename, '/');\n+  size_t len = strlen (basename);\n+  \n+  if (slashpos != NULL)\n+    {\n+      size_t i;\n+      for (i = 0; i < NUM_BASE_FILES; i++)\n+\tif ((size_t)(slashpos - basename) == strlen (lang_names [i])\n+\t    && memcmp (basename, lang_names[i], strlen (lang_names[i])) == 0)\n+\t  return 1 << i;\n+    }\n+  else if (strcmp (basename, \"c-lang.c\") == 0)\n+    return 1 << BASE_FILE_C;\n+  else if (strcmp (basename, \"c-parse.in\") == 0\n+\t   || strcmp (basename, \"c-tree.h\") == 0\n+\t   || strcmp (basename, \"c-decl.c\") == 0\n+\t   || strcmp (basename, \"c-objc-common.c\") == 0)\n+    return 1 << BASE_FILE_C | 1 << BASE_FILE_OBJC;\n+  else if (startswith (len, basename, \"c-\"))\n+    return 1 << BASE_FILE_C | 1 << BASE_FILE_OBJC | 1 << BASE_FILE_CPLUSPLUS;\n+  else\n+    return (1 << NUM_BASE_FILES) - 1;\n+  abort ();\n+}\n+\n+FILE *\n+get_output_file_with_visibility (input_file)\n+     const char *input_file;\n+{\n+  filemap_p fm, fmo;\n+  size_t len;\n+  const char *basename;\n+\n+  /* Do we already know the file?  */\n+  for (fm = files; fm; fm = fm->next)\n+    if (input_file == fm->input_name)\n+      return fm->output;\n+\n+  /* No, we'll be creating a new filemap.  */\n+  fm = xmalloc (sizeof (*fm));\n+  fm->next = files;\n+  files = fm;\n+  fm->input_name = input_file;\n+  \n+  /* Determine the output file name.  */\n+  basename = get_file_basename (input_file);\n+\n+  len = strlen (basename);\n+  if ((len > 2 && memcmp (basename+len-2, \".c\", 2) == 0)\n+      || (len > 2 && memcmp (basename+len-2, \".y\", 2) == 0)\n+      || (len > 3 && memcmp (basename+len-3, \".in\", 3) == 0))\n+    {\n+      char *s;\n+      \n+      fm->output_name = s = xmalloc (sizeof (\"gt-\") + len);\n+      sprintf (s, \"gt-%s\", basename);\n+      for (; *s != '.'; s++)\n+\tif (! isalnum (*s) && *s != '-')\n+\t  *s = '-';\n+      memcpy (s, \".h\", sizeof (\".h\"));\n+    }\n+  else if (strcmp (basename, \"c-common.h\") == 0)\n+    fm->output_name = \"gt-c-common.h\";\n+  else if (strcmp (basename, \"c-tree.h\") == 0)\n+    fm->output_name = \"gt-c-decl.h\";\n+  else \n+    {\n+      size_t i;\n+      \n+      fm->output_name = \"gtype-desc.c\";\n+      for (i = 0; i < NUM_BASE_FILES; i++)\n+\tif (memcmp (basename, lang_names[i], strlen (lang_names[i])) == 0\n+\t    && basename[strlen(lang_names[i])] == '/')\n+\t  {\n+\t    char *s;\n+\t    \n+\t    s = xmalloc (16);\n+\t    sprintf (s, \"gtype-%s.h\", lang_names[i]);\n+\t    fm->output_name = s;\n+\t    break;\n+\t  }\n+    }\n+\n+  /* Look through to see if we've ever seen this output filename before.  */\n+  for (fmo = fm->next; fmo; fmo = fmo->next)\n+    if (strcmp (fmo->output_name, fm->output_name) == 0)\n+      {\n+\tfm->output = fmo->output;\n+\tbreak;\n+      }\n+\n+  /* If not, create it.  */\n+  if (fmo == NULL)\n+    {\n+      fm->output = create_file (fm->output_name);\n+      if (strcmp (fm->output_name, \"gtype-desc.c\") == 0)\n+\t{\n+\t  fputs (\"#include \\\"config.h\\\"\\n\", fm->output);\n+\t  fputs (\"#include \\\"system.h\\\"\\n\", fm->output);\n+\t  fputs (\"#include \\\"varray.h\\\"\\n\", fm->output);\n+\t  fputs (\"#include \\\"hashtab.h\\\"\\n\", fm->output);\n+\t  fputs (\"#include \\\"bitmap.h\\\"\\n\", fm->output);\n+\t  fputs (\"#include \\\"tree.h\\\"\\n\", fm->output);\n+\t  fputs (\"#include \\\"rtl.h\\\"\\n\", fm->output);\n+\t  fputs (\"#include \\\"function.h\\\"\\n\", fm->output);\n+\t  fputs (\"#include \\\"insn-config.h\\\"\\n\", fm->output);\n+\t  fputs (\"#include \\\"expr.h\\\"\\n\", fm->output);\n+\t  fputs (\"#include \\\"hard-reg-set.h\\\"\\n\", fm->output);\n+\t  fputs (\"#include \\\"basic-block.h\\\"\\n\", fm->output);\n+\t  fputs (\"#include \\\"cselib.h\\\"\\n\", fm->output);\n+\t  fputs (\"#include \\\"insn-addr.h\\\"\\n\", fm->output);\n+\t  fputs (\"#include \\\"ssa.h\\\"\\n\", fm->output);\n+\t  fputs (\"#include \\\"optabs.h\\\"\\n\", fm->output);\n+\t  fputs (\"#include \\\"libfuncs.h\\\"\\n\", fm->output);\n+\t  fputs (\"#include \\\"debug.h\\\"\\n\", fm->output);\n+\t  fputs (\"#include \\\"ggc.h\\\"\\n\", fm->output);\n+\t}\n+    }\n+\n+  return fm->output;\n+}\n+\n+const char *\n+get_output_file_name (input_file)\n+     const char *input_file;\n+{\n+  filemap_p fm;\n+\n+  for (fm = files; fm; fm = fm->next)\n+    if (input_file == fm->input_name)\n+      return fm->output_name;\n+  (void) get_output_file_with_visibility (input_file);\n+  return get_output_file_name (input_file);\n+}\n+\n+static void\n+close_output_files PARAMS ((void))\n+{\n+  filemap_p fm;\n+  struct filemap header;\n+  header.next = files;\n+  header.output_name = \"gtype-desc.h\";\n+  header.output = header_file;\n+  \n+  for (fm = &header; fm; fm = fm->next)\n+    {\n+      int no_write_p;\n+      filemap_p ofm;\n+      FILE *newfile;\n+      \n+      /* Handle each output file once.  */\n+      if (fm->output == NULL)\n+\tcontinue;\n+      \n+      for (ofm = fm->next; ofm; ofm = ofm->next)\n+\tif (fm->output == ofm->output)\n+\t  ofm->output = NULL;\n+      \n+      /* Compare the output file with the file to be created, avoiding\n+\t unnecessarily changing timestamps.  */\n+      newfile = fopen (fm->output_name, \"r\");\n+      if (newfile != NULL)\n+\t{\n+\t  int ch1, ch2;\n+\t  \n+\t  rewind (fm->output);\n+\t  do {\n+\t    ch1 = fgetc (fm->output);\n+\t    ch2 = fgetc (newfile);\n+\t  } while (ch1 != EOF && ch1 == ch2);\n+\n+\t  fclose (newfile);\n+\t  \n+\t  no_write_p = ch1 == ch2;\n+\t}\n+      else\n+\tno_write_p = 0;\n+     \n+      /* Nothing interesting to do.  Close the output file.  */\n+      if (no_write_p)\n+\t{\n+\t  fclose (fm->output);\n+\t  continue;\n+\t}\n+\n+      newfile = fopen (fm->output_name, \"w\");\n+      if (newfile == NULL)\n+\t{\n+\t  perror (\"opening output file\");\n+\t  exit (1);\n+\t}\n+      {\n+\tint ch;\n+\trewind (fm->output);\n+\twhile ((ch = fgetc (fm->output)) != EOF)\n+\t  fputc (ch, newfile);\n+      }\n+      fclose (newfile);\n+      fclose (fm->output);\n+    }\n+}\n+\f\n+struct flist {\n+  struct flist *next;\n+  int started_p;\n+  const char *name;\n+  FILE *f;\n+};\n+\n+static void output_escaped_param PARAMS ((FILE *, const char *, const char *,\n+\t\t\t\t\t  const char *, const char *,\n+\t\t\t\t\t  struct fileloc *));\n+static void write_gc_structure_fields \n+  PARAMS ((FILE *, type_p, const char *, const char *, options_p, \n+\t   int, struct fileloc *, lang_bitmap, type_p));\n+static void write_gc_marker_routine_for_structure PARAMS ((type_p, type_p));\n+static void write_gc_types PARAMS ((type_p structures, type_p param_structs));\n+static void put_mangled_filename PARAMS ((FILE *, const char *));\n+static void finish_root_table PARAMS ((struct flist *flp, const char *pfx, \n+\t\t\t\t       const char *tname, const char *lastname,\n+\t\t\t\t       const char *name));\n+static void write_gc_root PARAMS ((FILE *, pair_p, type_p, const char *, int,\n+\t\t\t\t   struct fileloc *, const char *));\n+static void write_gc_roots PARAMS ((pair_p));\n+\n+static int gc_counter;\n+\n+static void\n+output_escaped_param (of, param, val, prev_val, oname, line)\n+     FILE *of;\n+     const char *param;\n+     const char *val;\n+     const char *prev_val;\n+     const char *oname;\n+     struct fileloc *line;\n+{\n+  const char *p;\n+  \n+  for (p = param; *p; p++)\n+    if (*p != '%')\n+      fputc (*p, of);\n+    else if (*++p == 'h')\n+      fprintf (of, \"(%s)\", val);\n+    else if (*p == '0')\n+      fputs (\"(*x)\", of);\n+    else if (*p == '1')\n+      fprintf (of, \"(%s)\", prev_val);\n+    else\n+      error_at_line (line, \"`%s' option contains bad escape %c%c\",\n+\t\t     oname, '%', *p);\n+}\n+\n+static void\n+write_gc_structure_fields (of, s, val, prev_val, opts, indent, line, bitmap,\n+\t\t\t   param)\n+     FILE *of;\n+     type_p s;\n+     const char *val;\n+     const char *prev_val;\n+     options_p opts;\n+     int indent;\n+     struct fileloc *line;\n+     lang_bitmap bitmap;\n+     type_p param;\n+{\n+  pair_p f;\n+  int tagcounter = -1;\n+\n+  if (! s->u.s.line.file)\n+    error_at_line (line, \"incomplete structure `%s'\", s->u.s.tag);\n+  else if ((s->u.s.bitmap & bitmap) != bitmap)\n+    {\n+      error_at_line (line, \"structure defined for mismatching languages\");\n+      error_at_line (&s->u.s.line, \"one structure defined here\");\n+    }\n+  \n+  if (s->kind == TYPE_UNION)\n+    {\n+      const char *tagexpr = NULL;\n+      options_p oo;\n+      \n+      tagcounter = ++gc_counter;\n+      for (oo = opts; oo; oo = oo->next)\n+\tif (strcmp (oo->name, \"desc\") == 0)\n+\t  tagexpr = (const char *)oo->info;\n+      if (tagexpr == NULL)\n+\t{\n+\t  tagexpr = \"1\";\n+\t  error_at_line (line, \"missing `desc' option\");\n+\t}\n+\n+      fprintf (of, \"%*s{\\n\", indent, \"\");\n+      indent += 2;\n+      fprintf (of, \"%*sunsigned int tag%d = (\", indent, \"\", tagcounter);\n+      output_escaped_param (of, tagexpr, val, prev_val, \"desc\", line);\n+      fputs (\");\\n\", of);\n+    }\n+  \n+  for (f = s->u.s.fields; f; f = f->next)\n+    {\n+      const char *tagid = NULL;\n+      const char *length = NULL;\n+      const char *special = NULL;\n+      int skip_p = 0;\n+      int always_p = 0;\n+      int maybe_undef_p = 0;\n+      int use_param_p = 0;\n+      options_p oo;\n+      type_p t = f->type;\n+      \n+      if (t->kind == TYPE_SCALAR\n+\t  || (t->kind == TYPE_ARRAY \n+\t      && t->u.a.p->kind == TYPE_SCALAR))\n+\tcontinue;\n+      \n+      for (oo = f->opt; oo; oo = oo->next)\n+\tif (strcmp (oo->name, \"length\") == 0)\n+\t  length = (const char *)oo->info;\n+\telse if (strcmp (oo->name, \"maybe_undef\") == 0)\n+\t  maybe_undef_p = 1;\n+\telse if (strcmp (oo->name, \"tag\") == 0)\n+\t  tagid = (const char *)oo->info;\n+\telse if (strcmp (oo->name, \"special\") == 0)\n+\t  special = (const char *)oo->info;\n+\telse if (strcmp (oo->name, \"skip\") == 0)\n+\t  skip_p = 1;\n+\telse if (strcmp (oo->name, \"always\") == 0)\n+\t  always_p = 1;\n+\telse if (strcmp (oo->name, \"desc\") == 0 && UNION_P (t))\n+\t  ;\n+ \telse if (strcmp (oo->name, \"descbits\") == 0 && UNION_P (t))\n+\t  ;\n+ \telse if (strcmp (oo->name, \"param_is\") == 0)\n+\t  ;\n+\telse if (strcmp (oo->name, \"use_param\") == 0)\n+\t  use_param_p = 1;\n+\telse\n+\t  error_at_line (&f->line, \"unknown field option `%s'\\n\", oo->name);\n+\n+      if (skip_p)\n+\tcontinue;\n+      \n+      if (use_param_p)\n+\t{\n+\t  if (param != NULL)\n+\t    {\n+\t      type_p t1;\n+\t      type_p nt = param;\n+\t      int arraycount = 0;\n+\t      \n+\t      for (t1 = t; t->kind == TYPE_ARRAY; t = t->u.a.p)\n+\t\tarraycount++;\n+\t      for (; t->kind == TYPE_POINTER; t = t->u.p)\n+\t\tnt = create_pointer (nt);\n+\t      while (arraycount-- > 0)\n+\t\tnt = create_array (nt, t->u.a.len);\n+\t      t = nt;\n+\t    }\n+\t  else if (s->kind == TYPE_UNION && ! always_p && tagid)\n+\t    ;\n+\t  else\n+\t    error_at_line (&f->line, \"no parameter defined\");\n+\t}\n+\n+      if (maybe_undef_p\n+\t  && (t->kind != TYPE_POINTER\n+\t      || t->u.p->kind != TYPE_STRUCT))\n+\terror_at_line (&f->line, \n+\t\t       \"field `%s' has invalid option `maybe_undef_p'\\n\",\n+\t\t       f->name);\n+      if (s->kind == TYPE_UNION && ! always_p )\n+\t{\n+\t  if (! tagid)\n+\t    {\n+\t      error_at_line (&f->line, \"field `%s' has no tag\", f->name);\n+\t      continue;\n+\t    }\n+\t  fprintf (of, \"%*sif (tag%d == (%s)) {\\n\", indent, \"\", \n+\t\t   tagcounter, tagid);\n+\t  indent += 2;\n+\t}\n+      \n+      switch (t->kind)\n+\t{\n+\tcase TYPE_STRING:\n+\t  /* Do nothing; strings go in the string pool.  */\n+\t  break;\n+\n+\tcase TYPE_LANG_STRUCT:\n+\t  {\n+\t    type_p ti;\n+\t    for (ti = t->u.s.lang_struct; ti; ti = ti->next)\n+\t      if (ti->u.s.bitmap & bitmap)\n+\t\t{\n+\t\t  t = ti;\n+\t\t  break;\n+\t\t}\n+\t    if (ti == NULL)\n+\t      {\n+\t\terror_at_line (&f->line, \n+\t\t\t       \"structure not defined for this language\");\n+\t\tbreak;\n+\t      }\n+\t  }\n+\t  /* Fall through... */\n+\tcase TYPE_STRUCT:\n+\tcase TYPE_UNION:\n+\t  {\n+\t    char *newval;\n+\n+\t    newval = xmalloc (strlen (val) + sizeof (\".\") + strlen (f->name));\n+\t    sprintf (newval, \"%s.%s\", val, f->name);\n+\t    write_gc_structure_fields (of, t, newval, val, f->opt, indent, \n+\t\t\t\t       &f->line, bitmap, param);\n+\t    free (newval);\n+\t    break;\n+\t  }\n+\n+\tcase TYPE_POINTER:\n+\t  if (! length)\n+\t    {\n+\t      if (maybe_undef_p\n+\t\t  && t->u.p->u.s.line.file == NULL)\n+\t\tfprintf (of, \"%*sif (%s.%s) abort();\\n\", indent, \"\",\n+\t\t\t val, f->name);\n+\t      else if (UNION_OR_STRUCT_P (t->u.p))\n+\t\tfprintf (of, \"%*sgt_ggc_m_%s (%s.%s);\\n\", indent, \"\", \n+\t\t\t t->u.p->u.s.tag, val, f->name);\n+\t      else if (t->u.p->kind == TYPE_PARAM_STRUCT)\n+\t\tfprintf (of, \"%*sgt_ggc_mm_%d%s_%s (%s.%s);\\n\", indent, \"\",\n+\t\t\t (int) strlen (t->u.p->u.param_struct.param->u.s.tag),\n+\t\t\t t->u.p->u.param_struct.param->u.s.tag,\n+\t\t\t t->u.p->u.param_struct.stru->u.s.tag,\n+\t\t\t val, f->name);\n+\t      else\n+\t\terror_at_line (&f->line, \"field `%s' is pointer to scalar\",\n+\t\t\t       f->name);\n+\t      break;\n+\t    }\n+\t  else if (t->u.p->kind == TYPE_SCALAR\n+\t\t   || t->u.p->kind == TYPE_STRING)\n+\t    fprintf (of, \"%*sggc_mark (%s.%s);\\n\", indent, \"\", \n+\t\t     val, f->name);\n+\t  else\n+\t    {\n+\t      int loopcounter = ++gc_counter;\n+\t      \n+\t      fprintf (of, \"%*sif (%s.%s != NULL) {\\n\", indent, \"\",\n+\t\t       val, f->name);\n+\t      indent += 2;\n+\t      fprintf (of, \"%*ssize_t i%d;\\n\", indent, \"\", loopcounter);\n+\t      fprintf (of, \"%*sggc_set_mark (%s.%s);\\n\", indent, \"\", \n+\t\t       val, f->name);\n+\t      fprintf (of, \"%*sfor (i%d = 0; i%d < (\", indent, \"\", \n+\t\t       loopcounter, loopcounter);\n+\t      output_escaped_param (of, length, val, prev_val, \"length\", line);\n+\t      fprintf (of, \"); i%d++) {\\n\", loopcounter);\n+\t      indent += 2;\n+\t      switch (t->u.p->kind)\n+\t\t{\n+\t\tcase TYPE_STRUCT:\n+\t\tcase TYPE_UNION:\n+\t\t  {\n+\t\t    char *newval;\n+\t\t    \n+\t\t    newval = xmalloc (strlen (val) + 8 + strlen (f->name));\n+\t\t    sprintf (newval, \"%s.%s[i%d]\", val, f->name, loopcounter);\n+\t\t    write_gc_structure_fields (of, t->u.p, newval, val,\n+\t\t\t\t\t       f->opt, indent, &f->line,\n+\t\t\t\t\t       bitmap, param);\n+\t\t    free (newval);\n+\t\t    break;\n+\t\t  }\n+\t\tcase TYPE_POINTER:\n+\t\t  if (UNION_OR_STRUCT_P (t->u.p->u.p))\n+\t\t    fprintf (of, \"%*sgt_ggc_m_%s (%s.%s[i%d]);\\n\", indent, \"\", \n+\t\t\t     t->u.p->u.p->u.s.tag, val, f->name,\n+\t\t\t     loopcounter);\n+\t\t  else\n+\t\t    error_at_line (&f->line, \n+\t\t\t\t   \"field `%s' is array of pointer to scalar\",\n+\t\t\t\t   f->name);\n+\t\t  break;\n+\t\tdefault:\n+\t\t  error_at_line (&f->line, \n+\t\t\t\t \"field `%s' is array of unimplemented type\",\n+\t\t\t\t f->name);\n+\t\t  break;\n+\t\t}\n+\t      indent -= 2;\n+\t      fprintf (of, \"%*s}\\n\", indent, \"\");\n+\t      indent -= 2;\n+\t      fprintf (of, \"%*s}\\n\", indent, \"\");\n+\t    }\n+\t  break;\n+\n+\tcase TYPE_ARRAY:\n+\t  {\n+\t    int loopcounter = ++gc_counter;\n+\t    type_p ta;\n+\t    int i;\n+\n+\t    if (! length &&\n+\t\t(strcmp (t->u.a.len, \"0\") == 0\n+\t\t || strcmp (t->u.a.len, \"1\") == 0))\n+\t      error_at_line (&f->line, \n+\t\t\t     \"field `%s' is array of size %s\",\n+\t\t\t     f->name, t->u.a.len);\n+\t    \n+\t    /* Arrays of scalars can be ignored.  */\n+\t    for (ta = t; ta->kind == TYPE_ARRAY; ta = ta->u.a.p)\n+\t      ;\n+\t    if (ta->kind == TYPE_SCALAR\n+\t\t|| ta->kind == TYPE_STRING)\n+\t      break;\n+\n+\t    fprintf (of, \"%*s{\\n\", indent, \"\");\n+\t    indent += 2;\n+\n+\t    if (special != NULL && strcmp (special, \"tree_exp\") == 0)\n+\t      {\n+\t\tfprintf (of, \"%*sconst size_t tree_exp_size = (\",\n+                         indent, \"\");\n+\t\toutput_escaped_param (of, length, val, prev_val,\n+\t\t\t\t      \"length\", line);\n+\t\tfputs (\");\\n\", of);\n+\n+\t\tlength = \"first_rtl_op (TREE_CODE ((tree)&%h))\";\n+\t      }\n+\n+\t    for (ta = t, i = 0; ta->kind == TYPE_ARRAY; ta = ta->u.a.p, i++)\n+\t      {\n+\t\tfprintf (of, \"%*ssize_t i%d_%d;\\n\", \n+\t\t\t indent, \"\", loopcounter, i);\n+\t\tfprintf (of, \"%*sconst size_t ilimit%d_%d = (\",\n+\t\t\t indent, \"\", loopcounter, i);\n+\t\tif (i == 0 && length != NULL)\n+\t\t  output_escaped_param (of, length, val, prev_val, \n+\t\t\t\t\t\"length\", line);\n+\t\telse\n+\t\t  fputs (ta->u.a.len, of);\n+\t\tfputs (\");\\n\", of);\n+\t      }\n+\t\t\n+\t    for (ta = t, i = 0; ta->kind == TYPE_ARRAY; ta = ta->u.a.p, i++)\n+\t      {\n+\t\tfprintf (of, \n+\t\t \"%*sfor (i%d_%d = 0; i%d_%d < ilimit%d_%d; i%d_%d++) {\\n\",\n+\t\t\t indent, \"\", loopcounter, i, loopcounter, i,\n+\t\t\t loopcounter, i, loopcounter, i);\n+\t\tindent += 2;\n+\t      }\n+\n+\t    if (ta->kind == TYPE_POINTER\n+\t\t&& (ta->u.p->kind == TYPE_STRUCT\n+\t\t    || ta->u.p->kind == TYPE_UNION))\n+\t      {\n+\t\tfprintf (of, \"%*sgt_ggc_m_%s (%s.%s\", \n+\t\t\t indent, \"\", ta->u.p->u.s.tag, val, f->name);\n+\t\tfor (ta = t, i = 0; \n+\t\t     ta->kind == TYPE_ARRAY; \n+\t\t     ta = ta->u.a.p, i++)\n+\t\t  fprintf (of, \"[i%d_%d]\", loopcounter, i);\n+\t\tfputs (\");\\n\", of);\n+\t      }\n+\t    else if (ta->kind == TYPE_STRUCT || ta->kind == TYPE_UNION)\n+\t      {\n+\t\tchar *newval;\n+\t\tint len;\n+\t\t\n+\t\tlen = strlen (val) + strlen (f->name) + 2;\n+\t\tfor (ta = t; ta->kind == TYPE_ARRAY; ta = ta->u.a.p)\n+\t\t  len += sizeof (\"[i_]\") + 2*6;\n+\t\t\n+\t\tnewval = xmalloc (len);\n+\t\tsprintf (newval, \"%s.%s\", val, f->name);\n+\t\tfor (ta = t, i = 0; \n+\t\t     ta->kind == TYPE_ARRAY; \n+\t\t     ta = ta->u.a.p, i++)\n+\t\t  sprintf (newval + strlen (newval), \"[i%d_%d]\", \n+\t\t\t   loopcounter, i);\n+\t\twrite_gc_structure_fields (of, t->u.p, newval, val,\n+\t\t\t\t\t   f->opt, indent, &f->line, bitmap,\n+\t\t\t\t\t   param);\n+\t\tfree (newval);\n+\t      }\n+\t    else if (ta->kind == TYPE_POINTER && ta->u.p->kind == TYPE_SCALAR\n+\t\t     && use_param_p && param == NULL)\n+\t      fprintf (of, \"%*sabort();\\n\", indent, \"\");\n+\t    else\n+\t      error_at_line (&f->line, \n+\t\t\t     \"field `%s' is array of unimplemented type\",\n+\t\t\t     f->name);\n+\t    for (ta = t, i = 0; ta->kind == TYPE_ARRAY; ta = ta->u.a.p, i++)\n+\t      {\n+\t\tindent -= 2;\n+\t\tfprintf (of, \"%*s}\\n\", indent, \"\");\n+\t      }\n+\n+\t    if (special != NULL && strcmp (special, \"tree_exp\") == 0)\n+\t      {\n+\t\tfprintf (of, \n+\t\t \"%*sfor (; i%d_0 < tree_exp_size; i%d_0++)\\n\",\n+\t\t\t indent, \"\", loopcounter, loopcounter);\n+\t\tfprintf (of, \"%*s  gt_ggc_m_rtx_def (%s.%s[i%d_0]);\\n\",\n+\t\t\t indent, \"\", val, f->name, loopcounter);\n+\t\tspecial = NULL;\n+\t      }\n+\n+\t    indent -= 2;\n+\t    fprintf (of, \"%*s}\\n\", indent, \"\");\n+\t    break;\n+\t  }\n+\n+\tdefault:\n+\t  error_at_line (&f->line, \n+\t\t\t \"field `%s' is unimplemented type\",\n+\t\t\t f->name);\n+\t  break;\n+\t}\n+      \n+      if (s->kind == TYPE_UNION && ! always_p )\n+\t{\n+\t  indent -= 2;\n+\t  fprintf (of, \"%*s}\\n\", indent, \"\");\n+\t}\n+      if (special)\n+\terror_at_line (&f->line, \"unhandled special `%s'\", special);\n+    }\n+  if (s->kind == TYPE_UNION)\n+    {\n+      indent -= 2;\n+      fprintf (of, \"%*s}\\n\", indent, \"\");\n+    }\n+}\n+\n+static void\n+write_gc_marker_routine_for_structure (s, param)\n+     type_p s;\n+     type_p param;\n+{\n+  FILE *f;\n+  if (param == NULL)\n+    f = get_output_file_with_visibility (s->u.s.line.file);\n+  else\n+    f = get_output_file_with_visibility (param->u.s.line.file);\n+  \n+  fputc ('\\n', f);\n+  fputs (\"void\\n\", f);\n+  if (param == NULL)\n+    fprintf (f, \"gt_ggc_mx_%s (x_p)\\n\", s->u.s.tag);\n+  else\n+    fprintf (f, \"gt_ggc_mm_%d%s_%s (x_p)\\n\", (int) strlen (param->u.s.tag),\n+\t     param->u.s.tag, s->u.s.tag);\n+  fputs (\"      void *x_p;\\n\", f);\n+  fputs (\"{\\n\", f);\n+  fprintf (f, \"  %s %s * const x = (%s %s *)x_p;\\n\",\n+\t   s->kind == TYPE_UNION ? \"union\" : \"struct\", s->u.s.tag,\n+\t   s->kind == TYPE_UNION ? \"union\" : \"struct\", s->u.s.tag);\n+  fputs (\"  if (! ggc_test_and_set_mark (x))\\n\", f);\n+  fputs (\"    return;\\n\", f);\n+  \n+  gc_counter = 0;\n+  write_gc_structure_fields (f, s, \"(*x)\", \"not valid postage\",\n+\t\t\t     s->u.s.opt, 2, &s->u.s.line, s->u.s.bitmap,\n+\t\t\t     param);\n+  \n+  fputs (\"}\\n\", f);\n+}\n+     \n+\n+static void\n+write_gc_types (structures, param_structs)\n+     type_p structures;\n+     type_p param_structs;\n+{\n+  type_p s;\n+  \n+  fputs (\"\\n/* GC marker procedures.  */\\n\", header_file);\n+  for (s = structures; s; s = s->next)\n+    if (s->gc_used == GC_POINTED_TO\n+\t|| s->gc_used == GC_MAYBE_POINTED_TO)\n+      {\n+\toptions_p opt;\n+\t\n+\tif (s->gc_used == GC_MAYBE_POINTED_TO\n+\t    && s->u.s.line.file == NULL)\n+\t  continue;\n+\n+\tfprintf (header_file,\n+\t\t \"#define gt_ggc_m_%s(X) do { \\\\\\n\", s->u.s.tag);\n+\tfprintf (header_file,\n+\t\t \"  if (X != NULL) gt_ggc_mx_%s (X);\\\\\\n\", s->u.s.tag);\n+\tfprintf (header_file,\n+\t\t \"  } while (0)\\n\");\n+\t\n+\tfor (opt = s->u.s.opt; opt; opt = opt->next)\n+\t  if (strcmp (opt->name, \"ptr_alias\") == 0)\n+\t    {\n+\t      type_p t = (type_p) opt->info;\n+\t      if (t->kind == TYPE_STRUCT \n+\t\t  || t->kind == TYPE_UNION\n+\t\t  || t->kind == TYPE_LANG_STRUCT)\n+\t\tfprintf (header_file,\n+\t\t\t \"#define gt_ggc_mx_%s gt_ggc_mx_%s\\n\",\n+\t\t\t s->u.s.tag, t->u.s.tag);\n+\t      else\n+\t\terror_at_line (&s->u.s.line, \n+\t\t\t       \"structure alias is not a structure\");\n+\t      break;\n+\t    }\n+\tif (opt)\n+\t  continue;\n+\n+\t/* Declare the marker procedure only once.  */\n+\tfprintf (header_file, \n+\t\t \"extern void gt_ggc_mx_%s PARAMS ((void *));\\n\",\n+\t\t s->u.s.tag);\n+  \n+\tif (s->u.s.line.file == NULL)\n+\t  {\n+\t    fprintf (stderr, \"warning: structure `%s' used but not defined\\n\", \n+\t\t     s->u.s.tag);\n+\t    continue;\n+\t  }\n+  \n+\tif (s->kind == TYPE_LANG_STRUCT)\n+\t  {\n+\t    type_p ss;\n+\t    for (ss = s->u.s.lang_struct; ss; ss = ss->next)\n+\t      write_gc_marker_routine_for_structure (ss, NULL);\n+\t  }\n+\telse\n+\t  write_gc_marker_routine_for_structure (s, NULL);\n+      }\n+\n+  for (s = param_structs; s; s = s->next)\n+    if (s->gc_used == GC_POINTED_TO)\n+      {\n+\ttype_p param = s->u.param_struct.param;\n+\ttype_p stru = s->u.param_struct.stru;\n+\n+\tif (param->kind != TYPE_STRUCT && param->kind != TYPE_UNION\n+\t    && param->kind != TYPE_LANG_STRUCT)\n+\t  {\n+\t    error_at_line (&s->u.param_struct.line,\n+\t\t\t   \"unsupported parameter type\");\n+\t    continue;\n+\t  }\n+\t\n+\t/* Declare the marker procedure.  */\n+\tfprintf (header_file, \n+\t\t \"extern void gt_ggc_mm_%d%s_%s PARAMS ((void *));\\n\",\n+\t\t (int) strlen (param->u.s.tag), param->u.s.tag,\n+\t\t stru->u.s.tag);\n+  \n+\tif (stru->u.s.line.file == NULL)\n+\t  {\n+\t    fprintf (stderr, \"warning: structure `%s' used but not defined\\n\", \n+\t\t     s->u.s.tag);\n+\t    continue;\n+\t  }\n+  \n+\tif (stru->kind == TYPE_LANG_STRUCT)\n+\t  {\n+\t    type_p ss;\n+\t    for (ss = stru->u.s.lang_struct; ss; ss = ss->next)\n+\t      write_gc_marker_routine_for_structure (ss, param);\n+\t  }\n+\telse\n+\t  write_gc_marker_routine_for_structure (stru, param);\n+      }\n+}\n+\n+static void\n+put_mangled_filename (f, fn)\n+     FILE *f;\n+     const char *fn;\n+{\n+  const char *name = get_output_file_name (fn);\n+  for (; *name != 0; name++)\n+    if (isalnum (*name))\n+      fputc (*name, f);\n+    else\n+      fputc ('_', f);\n+}\n+\n+static void\n+finish_root_table (flp, pfx, lastname, tname, name)\n+     struct flist *flp;\n+     const char *pfx;\n+     const char *tname;\n+     const char *lastname;\n+     const char *name;\n+{\n+  struct flist *fli2;\n+  unsigned started_bitmap = 0;\n+  \n+  for (fli2 = flp; fli2; fli2 = fli2->next)\n+    if (fli2->started_p)\n+      {\n+\tfprintf (fli2->f, \"  %s\\n\", lastname);\n+\tfputs (\"};\\n\\n\", fli2->f);\n+      }\n+\n+  for (fli2 = flp; fli2; fli2 = fli2->next)\n+    if (fli2->started_p)\n+      {\n+\tlang_bitmap bitmap = get_base_file_bitmap (fli2->name);\n+\tint fnum;\n+\n+\tfor (fnum = 0; bitmap != 0; fnum++, bitmap >>= 1)\n+\t  if (bitmap & 1)\n+\t    {\n+\t      fprintf (base_files[fnum],\n+\t\t       \"extern const struct %s gt_ggc_%s_\",\n+\t\t       tname, pfx);\n+\t      put_mangled_filename (base_files[fnum], fli2->name);\n+\t      fputs (\"[];\\n\", base_files[fnum]);\n+\t    }\n+      }\n+\n+  for (fli2 = flp; fli2; fli2 = fli2->next)\n+    if (fli2->started_p)\n+      {\n+\tlang_bitmap bitmap = get_base_file_bitmap (fli2->name);\n+\tint fnum;\n+\n+\tfli2->started_p = 0;\n+\n+\tfor (fnum = 0; bitmap != 0; fnum++, bitmap >>= 1)\n+\t  if (bitmap & 1)\n+\t    {\n+\t      if (! (started_bitmap & (1 << fnum)))\n+\t\t{\n+\t\t  fprintf (base_files [fnum],\n+\t\t\t   \"const struct %s * const %s[] = {\\n\",\n+\t\t\t   tname, name);\n+\t\t  started_bitmap |= 1 << fnum;\n+\t\t}\n+\t      fprintf (base_files[fnum], \"  gt_ggc_%s_\", pfx);\n+\t      put_mangled_filename (base_files[fnum], fli2->name);\n+\t      fputs (\",\\n\", base_files[fnum]);\n+\t    }\n+      }\n+\n+  {\n+    unsigned bitmap;\n+    int fnum;\n+    \n+    for (bitmap = started_bitmap, fnum = 0; bitmap != 0; fnum++, bitmap >>= 1)\n+      if (bitmap & 1)\n+\t{\n+\t  fputs (\"  NULL\\n\", base_files[fnum]);\n+\t  fputs (\"};\\n\\n\", base_files[fnum]);\n+\t}\n+  }\n+}\n+\n+static void\n+write_gc_root (f, v, type, name, has_length, line, if_marked)\n+     FILE *f;\n+     pair_p v;\n+     type_p type;\n+     const char *name;\n+     int has_length;\n+     struct fileloc *line;\n+     const char *if_marked;\n+{\n+  switch (type->kind)\n+    {\n+    case TYPE_STRUCT:\n+      {\n+\tpair_p fld;\n+\tfor (fld = type->u.s.fields; fld; fld = fld->next)\n+\t  {\n+\t    int skip_p = 0;\n+\t    const char *desc = NULL;\n+\t    options_p o;\n+\t    \n+\t    for (o = fld->opt; o; o = o->next)\n+\t      if (strcmp (o->name, \"skip\") == 0)\n+\t\tskip_p = 1;\n+\t      else if (strcmp (o->name, \"desc\") == 0)\n+\t\tdesc = (const char *)o->info;\n+\t      else\n+\t\terror_at_line (line,\n+\t\t       \"field `%s' of global `%s' has unknown option `%s'\",\n+\t\t\t       fld->name, name, o->name);\n+\t    \n+\t    if (skip_p)\n+\t      continue;\n+\t    else if (desc && fld->type->kind == TYPE_UNION)\n+\t      {\n+\t\tpair_p validf = NULL;\n+\t\tpair_p ufld;\n+\t\t\n+\t\tfor (ufld = fld->type->u.s.fields; ufld; ufld = ufld->next)\n+\t\t  {\n+\t\t    const char *tag = NULL;\n+\t\t    options_p oo;\n+\t\t    \n+\t\t    for (oo = ufld->opt; oo; oo = oo->next)\n+\t\t      if (strcmp (oo->name, \"tag\") == 0)\n+\t\t\ttag = (const char *)oo->info;\n+\t\t    if (tag == NULL || strcmp (tag, desc) != 0)\n+\t\t      continue;\n+\t\t    if (validf != NULL)\n+\t\t      error_at_line (line, \n+\t\t\t   \"both `%s.%s.%s' and `%s.%s.%s' have tag `%s'\",\n+\t\t\t\t     name, fld->name, validf->name,\n+\t\t\t\t     name, fld->name, ufld->name,\n+\t\t\t\t     tag);\n+\t\t    validf = ufld;\n+\t\t  }\n+\t\tif (validf != NULL)\n+\t\t  {\n+\t\t    char *newname;\n+\t\t    newname = xmalloc (strlen (name) + 3 + strlen (fld->name)\n+\t\t\t\t       + strlen (validf->name));\n+\t\t    sprintf (newname, \"%s.%s.%s\", \n+\t\t\t     name, fld->name, validf->name);\n+\t\t    write_gc_root (f, v, validf->type, newname, 0, line,\n+\t\t\t\t   if_marked);\n+\t\t    free (newname);\n+\t\t  }\n+\t      }\n+\t    else if (desc)\n+\t      error_at_line (line, \n+\t\t     \"global `%s.%s' has `desc' option but is not union\",\n+\t\t\t     name, fld->name);\n+\t    else\n+\t      {\n+\t\tchar *newname;\n+\t\tnewname = xmalloc (strlen (name) + 2 + strlen (fld->name));\n+\t\tsprintf (newname, \"%s.%s\", name, fld->name);\n+\t\twrite_gc_root (f, v, fld->type, newname, 0, line, if_marked);\n+\t\tfree (newname);\n+\t      }\n+\t  }\n+      }\n+      break;\n+\n+    case TYPE_ARRAY:\n+      {\n+\tchar *newname;\n+\tnewname = xmalloc (strlen (name) + 4);\n+\tsprintf (newname, \"%s[0]\", name);\n+\twrite_gc_root (f, v, type->u.a.p, newname, has_length, line, if_marked);\n+\tfree (newname);\n+      }\n+      break;\n+      \n+    case TYPE_POINTER:\n+      {\n+\ttype_p ap, tp;\n+\t\n+\tfputs (\"  {\\n\", f);\n+\tfprintf (f, \"    &%s,\\n\", name);\n+\tfputs (\"    1\", f);\n+\t\n+\tfor (ap = v->type; ap->kind == TYPE_ARRAY; ap = ap->u.a.p)\n+\t  if (ap->u.a.len[0])\n+\t    fprintf (f, \" * (%s)\", ap->u.a.len);\n+\t  else if (ap == v->type)\n+\t    fprintf (f, \" * (sizeof (%s) / sizeof (%s[0]))\",\n+\t\t     v->name, v->name);\n+\tfputs (\",\\n\", f);\n+\tfprintf (f, \"    sizeof (%s\", v->name);\n+\tfor (ap = v->type; ap->kind == TYPE_ARRAY; ap = ap->u.a.p)\n+\t  fputs (\"[0]\", f);\n+\tfputs (\"),\\n\", f);\n+\t\n+\ttp = type->u.p;\n+\t\n+\tif (! has_length && UNION_OR_STRUCT_P (tp))\n+\t  {\n+\t    fprintf (f, \"    &gt_ggc_mx_%s\\n\", tp->u.s.tag);\n+\t  }\n+\telse if (! has_length && tp->kind == TYPE_PARAM_STRUCT)\n+\t  {\n+\t    fprintf (f, \"    &gt_ggc_mm_%d%s_%s\",\n+\t\t     (int) strlen (tp->u.param_struct.param->u.s.tag),\n+\t\t     tp->u.param_struct.param->u.s.tag,\n+\t\t     tp->u.param_struct.stru->u.s.tag);\n+\t  }\n+\telse if (has_length\n+\t\t && tp->kind == TYPE_POINTER)\n+\t  {\n+\t    fprintf (f, \"    &gt_ggc_ma_%s\", name);\n+\t  }\n+\telse\n+\t  {\n+\t    error_at_line (line, \n+\t\t\t   \"global `%s' is pointer to unimplemented type\",\n+\t\t\t   name);\n+\t  }\n+\tif (if_marked)\n+\t  fprintf (f, \",\\n    &%s\", if_marked);\n+\tfputs (\"\\n  },\\n\", f);\n+      }\n+      break;\n+\n+    case TYPE_SCALAR:\n+    case TYPE_STRING:\n+      break;\n+      \n+    default:\n+      error_at_line (line, \n+\t\t     \"global `%s' is unimplemented type\",\n+\t\t     name);\n+    }\n+}\n+\n+static void\n+write_gc_roots (variables)\n+     pair_p variables;\n+{\n+  pair_p v;\n+  struct flist *flp = NULL;\n+\n+  for (v = variables; v; v = v->next)\n+    {\n+      FILE *f = get_output_file_with_visibility (v->line.file);\n+      struct flist *fli;\n+      const char *length = NULL;\n+      int deletable_p = 0;\n+      options_p o;\n+\n+      for (o = v->opt; o; o = o->next)\n+\tif (strcmp (o->name, \"length\") == 0)\n+\t  length = (const char *)o->info;\n+\telse if (strcmp (o->name, \"deletable\") == 0)\n+\t  deletable_p = 1;\n+\telse if (strcmp (o->name, \"param_is\") == 0)\n+\t  ;\n+\telse if (strcmp (o->name, \"if_marked\") == 0)\n+\t  ;\n+\telse\n+\t  error_at_line (&v->line, \n+\t\t\t \"global `%s' has unknown option `%s'\",\n+\t\t\t v->name, o->name);\n+\n+      for (fli = flp; fli; fli = fli->next)\n+\tif (fli->f == f)\n+\t  break;\n+      if (fli == NULL)\n+\t{\n+\t  fli = xmalloc (sizeof (*fli));\n+\t  fli->f = f;\n+\t  fli->next = flp;\n+\t  fli->started_p = 0;\n+\t  fli->name = v->line.file;\n+\t  flp = fli;\n+\n+\t  fputs (\"\\n/* GC roots.  */\\n\\n\", f);\n+\t}\n+\n+      if (! deletable_p\n+\t  && length\n+\t  && v->type->kind == TYPE_POINTER\n+\t  && (v->type->u.p->kind == TYPE_POINTER\n+\t      || v->type->u.p->kind == TYPE_STRUCT))\n+\t{\n+\t  fprintf (f, \"static void gt_ggc_ma_%s PARAMS ((void *));\\n\",\n+\t\t   v->name);\n+\t  fprintf (f, \"static void\\ngt_ggc_ma_%s (x_p)\\n      void *x_p;\\n\",\n+\t\t   v->name);\n+\t  fputs (\"{\\n\", f);\n+\t  fputs (\"  size_t i;\\n\", f);\n+\n+\t  if (v->type->u.p->kind == TYPE_POINTER)\n+\t    {\n+\t      type_p s = v->type->u.p->u.p;\n+\n+\t      fprintf (f, \"  %s %s ** const x = (%s %s **)x_p;\\n\",\n+\t\t       s->kind == TYPE_UNION ? \"union\" : \"struct\", s->u.s.tag,\n+\t\t       s->kind == TYPE_UNION ? \"union\" : \"struct\", s->u.s.tag);\n+\t      fputs (\"  if (ggc_test_and_set_mark (x))\\n\", f);\n+\t      fprintf (f, \"    for (i = 0; i < (%s); i++)\\n\", length);\n+\t      if (s->kind != TYPE_STRUCT && s->kind != TYPE_UNION)\n+\t\t{\n+\t\t  error_at_line (&v->line, \n+\t\t\t\t \"global `%s' has unsupported ** type\",\n+\t\t\t\t v->name);\n+\t\t  continue;\n+\t\t}\n+\n+\t      fprintf (f, \"      gt_ggc_m_%s (x[i]);\\n\", s->u.s.tag);\n+\t    }\n+\t  else\n+\t    {\n+\t      type_p s = v->type->u.p;\n+\n+\t      fprintf (f, \"  %s %s * const x = (%s %s *)x_p;\\n\",\n+\t\t       s->kind == TYPE_UNION ? \"union\" : \"struct\", s->u.s.tag,\n+\t\t       s->kind == TYPE_UNION ? \"union\" : \"struct\", s->u.s.tag);\n+\t      fputs (\"  if (ggc_test_and_set_mark (x))\\n\", f);\n+\t      fprintf (f, \"    for (i = 0; i < (%s); i++)\\n\", length);\n+\t      fputs (\"      {\\n\", f);\n+\t      write_gc_structure_fields (f, s, \"x[i]\", \"x[i]\",\n+\t\t\t\t\t v->opt, 8, &v->line, s->u.s.bitmap,\n+\t\t\t\t\t NULL);\n+\t      fputs (\"      }\\n\", f);\n+\t    }\n+\n+\t  fputs (\"}\\n\\n\", f);\n+\t}\n+    }\n+\n+  for (v = variables; v; v = v->next)\n+    {\n+      FILE *f = get_output_file_with_visibility (v->line.file);\n+      struct flist *fli;\n+      int skip_p = 0;\n+      int length_p = 0;\n+      options_p o;\n+      \n+      for (o = v->opt; o; o = o->next)\n+\tif (strcmp (o->name, \"length\") == 0)\n+\t  length_p = 1;\n+\telse if (strcmp (o->name, \"deletable\") == 0\n+\t\t || strcmp (o->name, \"if_marked\") == 0)\n+\t  skip_p = 1;\n+\n+      if (skip_p)\n+\tcontinue;\n+\n+      for (fli = flp; fli; fli = fli->next)\n+\tif (fli->f == f)\n+\t  break;\n+      if (! fli->started_p)\n+\t{\n+\t  fli->started_p = 1;\n+\n+\t  fputs (\"const struct ggc_root_tab gt_ggc_r_\", f);\n+\t  put_mangled_filename (f, v->line.file);\n+\t  fputs (\"[] = {\\n\", f);\n+\t}\n+\n+      write_gc_root (f, v, v->type, v->name, length_p, &v->line, NULL);\n+    }\n+\n+  finish_root_table (flp, \"r\", \"LAST_GGC_ROOT_TAB\", \"ggc_root_tab\", \n+\t\t     \"gt_ggc_rtab\");\n+\n+  for (v = variables; v; v = v->next)\n+    {\n+      FILE *f = get_output_file_with_visibility (v->line.file);\n+      struct flist *fli;\n+      int skip_p = 1;\n+      options_p o;\n+\n+      for (o = v->opt; o; o = o->next)\n+\tif (strcmp (o->name, \"deletable\") == 0)\n+\t  skip_p = 0;\n+\telse if (strcmp (o->name, \"if_marked\") == 0)\n+\t  skip_p = 1;\n+\n+      if (skip_p)\n+\tcontinue;\n+\n+      for (fli = flp; fli; fli = fli->next)\n+\tif (fli->f == f)\n+\t  break;\n+      if (! fli->started_p)\n+\t{\n+\t  fli->started_p = 1;\n+\n+\t  fputs (\"const struct ggc_root_tab gt_ggc_rd_\", f);\n+\t  put_mangled_filename (f, v->line.file);\n+\t  fputs (\"[] = {\\n\", f);\n+\t}\n+      \n+      fprintf (f, \"  { &%s, 1, sizeof (%s), NULL },\\n\",\n+\t       v->name, v->name);\n+    }\n+  \n+  finish_root_table (flp, \"rd\", \"LAST_GGC_ROOT_TAB\", \"ggc_root_tab\",\n+\t\t     \"gt_ggc_deletable_rtab\");\n+\n+  for (v = variables; v; v = v->next)\n+    {\n+      FILE *f = get_output_file_with_visibility (v->line.file);\n+      struct flist *fli;\n+      const char *if_marked = NULL;\n+      int length_p = 0;\n+      options_p o;\n+      \n+      for (o = v->opt; o; o = o->next)\n+\tif (strcmp (o->name, \"length\") == 0)\n+\t  length_p = 1;\n+\telse if (strcmp (o->name, \"if_marked\") == 0)\n+\t  if_marked = (const char *) o->info;\n+\n+      if (if_marked == NULL)\n+\tcontinue;\n+\n+      if (v->type->kind != TYPE_POINTER\n+\t  || v->type->u.p->kind != TYPE_PARAM_STRUCT\n+\t  || v->type->u.p->u.param_struct.stru != find_structure (\"htab\", 0))\n+\t{\n+\t  error_at_line (&v->line, \"if_marked option used but not hash table\");\n+\t  continue;\n+\t}\n+\n+      for (fli = flp; fli; fli = fli->next)\n+\tif (fli->f == f)\n+\t  break;\n+      if (! fli->started_p)\n+\t{\n+\t  fli->started_p = 1;\n+\n+\t  fputs (\"const struct ggc_cache_tab gt_ggc_rc_\", f);\n+\t  put_mangled_filename (f, v->line.file);\n+\t  fputs (\"[] = {\\n\", f);\n+\t}\n+      \n+      write_gc_root (f, v, create_pointer (v->type->u.p->u.param_struct.param),\n+\t\t     v->name, length_p, &v->line, if_marked);\n+    }\n+  \n+  finish_root_table (flp, \"rc\", \"LAST_GGC_CACHE_TAB\", \"ggc_cache_tab\",\n+\t\t     \"gt_ggc_cache_rtab\");\n+}\n+\n+\f\n+extern int main PARAMS ((int argc, char **argv));\n+int \n+main(argc, argv)\n+     int argc;\n+     char **argv;\n+{\n+  int i;\n+  static struct fileloc pos = { __FILE__, __LINE__ };\n+\n+  do_typedef (\"CUMULATIVE_ARGS\",\n+\t      create_scalar_type (\"CUMULATIVE_ARGS\", \n+\t\t\t\t  strlen (\"CUMULATIVE_ARGS\")),\n+\t      &pos);\n+  do_typedef (\"REAL_VALUE_TYPE\",\n+\t      create_scalar_type (\"REAL_VALUE_TYPE\", \n+\t\t\t\t  strlen (\"REAL_VALUE_TYPE\")),\n+\t      &pos);\n+  do_typedef (\"PTR\", create_pointer (create_scalar_type (\"void\",\n+\t\t\t\t\t\t\t strlen (\"void\"))),\n+\t      &pos);\n+\n+  for (i = 1; i < argc; i++)\n+    parse_file (argv[i]);\n+\n+  if (hit_error != 0)\n+    exit (1);\n+\n+  set_gc_used (variables);\n+\n+  open_base_files ();\n+  write_gc_types (structures, param_structs);\n+  write_gc_roots (variables);\n+  close_output_files ();\n+\n+  return (hit_error != 0);\n+}"}, {"sha": "e5f92f2644b2ee58ac7cfe805235de12f0afa5e3", "filename": "gcc/gengtype.h", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fgengtype.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fgengtype.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.h?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -0,0 +1,157 @@\n+/* Process source files and output type information.\n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+/* A file position, mostly for error messages.  \n+   The FILE element may be compared using pointer equality.  */\n+struct fileloc {\n+  const char *file;\n+  int line;\n+};\n+\n+/* Kinds of types we can understand.  */\n+enum typekind {\n+  TYPE_SCALAR,\n+  TYPE_STRING,\n+  TYPE_STRUCT,\n+  TYPE_UNION,\n+  TYPE_POINTER,\n+  TYPE_ARRAY,\n+  TYPE_LANG_STRUCT,\n+  TYPE_PARAM_STRUCT\n+};\n+\n+/* A way to pass data through to the output end.  */\n+typedef struct options {\n+  struct options *next;\n+  const char *name;\n+  void *info;\n+} *options_p;\n+\n+typedef struct pair *pair_p;\n+typedef struct type *type_p;\n+typedef unsigned lang_bitmap;\n+\n+/* A name and a type.  */\n+struct pair {\n+  pair_p next;\n+  const char *name;\n+  type_p type;\n+  struct fileloc line;\n+  options_p opt;\n+};\n+\n+/* A description of a type.  */\n+struct type {\n+  enum typekind kind;\n+  type_p next;\n+  type_p pointer_to;\n+  enum gc_used_enum {\n+    GC_UNUSED = 0,\n+    GC_USED,\n+    GC_MAYBE_POINTED_TO,\n+    GC_POINTED_TO\n+  } gc_used;\n+  union {\n+    type_p p;\n+    struct {\n+      const char *tag;\n+      struct fileloc line;\n+      pair_p fields;\n+      options_p opt;\n+      lang_bitmap bitmap;\n+      type_p lang_struct;\n+    } s;\n+    char *sc;\n+    struct {\n+      type_p p;\n+      const char *len;\n+    } a;\n+    struct {\n+      type_p stru;\n+      type_p param;\n+      struct fileloc line;\n+    } param_struct;\n+  } u;\n+};\n+\n+#define UNION_P(x)\t\t\t\t\t\\\n+ ((x)->kind == TYPE_UNION || \t\t\t\t\\\n+  ((x)->kind == TYPE_LANG_STRUCT \t\t\t\\\n+   && (x)->u.s.lang_struct->kind == TYPE_UNION))\n+#define UNION_OR_STRUCT_P(x)\t\t\t\\\n+ ((x)->kind == TYPE_UNION \t\t\t\\\n+  || (x)->kind == TYPE_STRUCT \t\t\t\\\n+  || (x)->kind == TYPE_LANG_STRUCT)\n+\n+/* The one and only TYPE_STRING.  */\n+extern struct type string_type;\n+\n+/* Variables used to communicate between the lexer and the parser.  */\n+extern int lexer_toplevel_done;\n+extern struct fileloc lexer_line;\n+\n+/* Print an error message.  */\n+extern void error_at_line \n+  VPARAMS ((struct fileloc *pos, const char *msg, ...));\n+\n+/* Constructor routines for types.  */\n+extern void do_typedef PARAMS ((const char *s, type_p t, struct fileloc *pos));\n+extern type_p resolve_typedef PARAMS ((const char *s, struct fileloc *pos));\n+extern void new_structure PARAMS ((const char *name, int isunion, \n+\t\t\t\t   struct fileloc *pos, pair_p fields, \n+\t\t\t\t   options_p o));\n+extern type_p find_structure PARAMS ((const char *s, int isunion));\n+extern type_p create_scalar_type PARAMS ((const char *name, size_t name_len));\n+extern type_p create_pointer PARAMS ((type_p t));\n+extern type_p create_array PARAMS ((type_p t, const char *len));\n+extern type_p adjust_field_type PARAMS ((type_p, options_p));\n+extern void note_variable PARAMS ((const char *s, type_p t, options_p o,\n+\t\t\t\t   struct fileloc *pos));\n+extern void note_yacc_type PARAMS ((options_p o, pair_p fields,\n+\t\t\t\t    pair_p typeinfo, struct fileloc *pos));\n+\n+/* Lexer and parser routines, most automatically generated.  */\n+extern int yylex PARAMS((void));\n+extern void yyerror PARAMS ((const char *));\n+extern int yyparse PARAMS ((void));\n+extern void parse_file PARAMS ((char *name));\n+\n+/* Output file handling.  */\n+\n+FILE *get_output_file PARAMS ((const char *input_file));\n+const char *get_output_file_name PARAMS ((const char *));\n+\n+/* The output header file that is included into pretty much every\n+   source file.  */\n+extern FILE *header_file;\n+\n+/* An output file, suitable for definitions, that can see declarations\n+   made in INPUT_FILE and is linked into every language that uses\n+   INPUT_FILE.  */\n+extern FILE *get_output_file_with_visibility PARAMS ((const char *input_file));\n+\n+/* A list of output files suitable for definitions.  There is one\n+   BASE_FILES entry for each language.  */\n+extern FILE *base_files[];\n+\n+/* A bitmap that specifies which of BASE_FILES should be used to\n+   output a definition that is different for each language and must be\n+   defined once in each language that uses INPUT_FILE.  */\n+extern lang_bitmap get_base_file_bitmap PARAMS ((const char *input_file));"}, {"sha": "55543dd7970ea3eb2d9dbff8ffcfc5f164c346a4", "filename": "gcc/ggc-common.c", "status": "modified", "additions": 53, "deletions": 411, "changes": 464, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fggc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fggc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-common.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -26,7 +26,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"rtl.h\"\n #include \"tree.h\"\n #include \"tm_p.h\"\n-#include \"hash.h\"\n #include \"hashtab.h\"\n #include \"varray.h\"\n #include \"ggc.h\"\n@@ -35,19 +34,8 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n /* Statistics about the allocation.  */\n static ggc_statistics *ggc_stats;\n \n-/* Trees that have been marked, but whose children still need marking.  */\n-varray_type ggc_pending_trees;\n-\n static void ggc_mark_rtx_children_1 PARAMS ((rtx));\n-static void ggc_mark_rtx_ptr PARAMS ((void *));\n-static void ggc_mark_tree_ptr PARAMS ((void *));\n-static void ggc_mark_rtx_varray_ptr PARAMS ((void *));\n-static void ggc_mark_tree_varray_ptr PARAMS ((void *));\n-static void ggc_mark_tree_hash_table_ptr PARAMS ((void *));\n static int ggc_htab_delete PARAMS ((void **, void *));\n-static void ggc_mark_trees PARAMS ((void));\n-static bool ggc_mark_tree_hash_table_entry PARAMS ((struct hash_entry *,\n-\t\t\t\t\t\t    hash_table_key));\n \n /* Maintain global roots that are preserved during GC.  */\n \n@@ -87,145 +75,19 @@ ggc_add_root (base, nelt, size, cb)\n   roots = x;\n }\n \n-/* Register an array of rtx as a GC root.  */\n-\n-void\n-ggc_add_rtx_root (base, nelt)\n-     rtx *base;\n-     int nelt;\n-{\n-  ggc_add_root (base, nelt, sizeof (rtx), ggc_mark_rtx_ptr);\n-}\n-\n-/* Register an array of trees as a GC root.  */\n-\n-void\n-ggc_add_tree_root (base, nelt)\n-     tree *base;\n-     int nelt;\n-{\n-  ggc_add_root (base, nelt, sizeof (tree), ggc_mark_tree_ptr);\n-}\n-\n-/* Register a varray of rtxs as a GC root.  */\n-\n-void\n-ggc_add_rtx_varray_root (base, nelt)\n-     varray_type *base;\n-     int nelt;\n-{\n-  ggc_add_root (base, nelt, sizeof (varray_type), \n-\t\tggc_mark_rtx_varray_ptr);\n-}\n-\n-/* Register a varray of trees as a GC root.  */\n-\n-void\n-ggc_add_tree_varray_root (base, nelt)\n-     varray_type *base;\n-     int nelt;\n-{\n-  ggc_add_root (base, nelt, sizeof (varray_type), \n-\t\tggc_mark_tree_varray_ptr);\n-}\n-\n-/* Register a hash table of trees as a GC root.  */\n-\n-void\n-ggc_add_tree_hash_table_root (base, nelt)\n-     struct hash_table **base;\n-     int nelt;\n-{\n-  ggc_add_root (base, nelt, sizeof (struct hash_table *), \n-\t\tggc_mark_tree_hash_table_ptr);\n-}\n-\n-/* Remove the previously registered GC root at BASE.  */\n-\n-void\n-ggc_del_root (base)\n-     void *base;\n-{\n-  struct ggc_root *x, **p;\n-\n-  p = &roots, x = roots;\n-  while (x)\n-    {\n-      if (x->base == base)\n-\t{\n-\t  *p = x->next;\n-\t  free (x);\n-\t  return;\n-\t}\n-      p = &x->next;\n-      x = x->next;\n-    }\n-\n-  abort ();\n-}\n-\n-/* Add a hash table to be scanned when all roots have been processed.  We\n-   delete any entry in the table that has not been marked.  */\n-\n-struct d_htab_root\n-{\n-  struct d_htab_root *next;\n-  htab_t htab;\n-  ggc_htab_marked_p marked_p;\n-  ggc_htab_mark mark;\n-};\n-\n-static struct d_htab_root *d_htab_roots;\n-\n-/* Add X, an htab, to a list of htabs that contain objects which are allocated\n-   from GC memory.  Once all other roots are marked, we check each object in\n-   the htab to see if it has already been marked.  If not, it is deleted.\n-\n-   MARKED_P, if specified, is a function that returns 1 if the entry is to\n-   be considered as \"marked\".  If not present, the data structure pointed to\n-   by the htab slot is tested.  This function should be supplied if some\n-   other object (such as something pointed to by that object) should be tested\n-   in which case the function tests whether that object (or objects) are\n-   marked (using ggc_marked_p) and returns nonzero if it is.\n-\n-   MARK, if specified, is a function that is passed the contents of a slot\n-   that has been determined to have been \"marked\" (via the above function)\n-   and marks any other objects pointed to by that object.  For example,\n-   we might have a hash table of memory attribute blocks, which are pointed\n-   to by a MEM RTL but have a pointer to a DECL.  MARKED_P in that case will\n-   not be specified because we want to know if the attribute block is pointed\n-   to by the MEM, but MARK must be specified because if the block has been\n-   marked, we need to mark the DECL.  */\n-\n-void\n-ggc_add_deletable_htab (x, marked_p, mark)\n-     PTR x;\n-     ggc_htab_marked_p marked_p;\n-     ggc_htab_mark mark;\n-{\n-  struct d_htab_root *r\n-    = (struct d_htab_root *) xmalloc (sizeof (struct d_htab_root));\n-\n-  r->next = d_htab_roots;\n-  r->htab = (htab_t) x;\n-  r->marked_p = marked_p ? marked_p : ggc_marked_p;\n-  r->mark = mark;\n-  d_htab_roots = r;\n-}\n-\n /* Process a slot of an htab by deleting it if it has not been marked.  */\n \n static int\n ggc_htab_delete (slot, info)\n      void **slot;\n      void *info;\n {\n-  struct d_htab_root *r = (struct d_htab_root *) info;\n+  const struct ggc_cache_tab *r = (const struct ggc_cache_tab *) info;\n \n   if (! (*r->marked_p) (*slot))\n-    htab_clear_slot (r->htab, slot);\n-  else if (r->mark)\n-    (*r->mark) (*slot);\n+    htab_clear_slot (*r->base, slot);\n+  else\n+    (*r->cb) (*slot);\n \n   return 1;\n }\n@@ -236,9 +98,20 @@ void\n ggc_mark_roots ()\n {\n   struct ggc_root *x;\n-  struct d_htab_root *y;\n+  const struct ggc_root_tab *const *rt;\n+  const struct ggc_root_tab *rti;\n+  const struct ggc_cache_tab *const *ct;\n+  const struct ggc_cache_tab *cti;\n+  size_t i;\n   \n-  VARRAY_TREE_INIT (ggc_pending_trees, 4096, \"ggc_pending_trees\");\n+  for (rt = gt_ggc_deletable_rtab; *rt; rt++)\n+    for (rti = *rt; rti->base != NULL; rti++)\n+      memset (rti->base, 0, rti->stride);\n+\n+  for (rt = gt_ggc_rtab; *rt; rt++)\n+    for (rti = *rt; rti->base != NULL; rti++)\n+      for (i = 0; i < rti->nelt; i++)\n+\t(*rti->cb)(*(void **)((char *)rti->base + rti->stride * i));\n \n   for (x = roots; x != NULL; x = x->next)\n     {\n@@ -251,19 +124,11 @@ ggc_mark_roots ()\n \t(*cb)(elt);\n     }\n \n-  /* Mark all the queued up trees, and their children.  */\n-  ggc_mark_trees ();\n-  VARRAY_FREE (ggc_pending_trees);\n-\n   /* Now scan all hash tables that have objects which are to be deleted if\n-     they are not already marked.  Since these may mark more trees, we need\n-     to reinitialize that varray.  */\n-  VARRAY_TREE_INIT (ggc_pending_trees, 1024, \"ggc_pending_trees\");\n-\n-  for (y = d_htab_roots; y != NULL; y = y->next)\n-    htab_traverse (y->htab, ggc_htab_delete, (PTR) y);\n-  ggc_mark_trees ();\n-  VARRAY_FREE (ggc_pending_trees);\n+     they are not already marked.  */\n+  for (ct = gt_ggc_cache_rtab; *ct; ct++)\n+    for (cti = *ct; cti->base != NULL; cti++)\n+      htab_traverse (*cti->base, ggc_htab_delete, (PTR) cti);\n }\n \n /* R had not been previously marked, but has now been marked via\n@@ -332,7 +197,7 @@ ggc_mark_rtx_children_1 (r)\n       switch (code)\n \t{\n \tcase MEM:\n-\t  ggc_mark (MEM_ATTRS (r));\n+\t  gt_ggc_m_mem_attrs (MEM_ATTRS (r));\n \t  break;\n \tcase JUMP_INSN:\n \t  ggc_mark_rtx (JUMP_LABEL (r));\n@@ -387,282 +252,59 @@ ggc_mark_rtx_children_1 (r)\n \t\t} \n \t      break;\n \t    case 'V': case 'E':\n-\t      ggc_mark_rtvec (XVEC (r, i));\n+\t      gt_ggc_m_rtvec_def (XVEC (r, i));\n \t      break;\n \t    }\n \t}\n     }\n   while ((r = next_rtx) != NULL);\n }\n \n-/* V had not been previously marked, but has now been marked via\n-   ggc_set_mark.  Now recurse and process the children.  */\n-\n+/* Various adaptor functions.  */\n void\n-ggc_mark_rtvec_children (v)\n-     rtvec v;\n+gt_ggc_mx_rtx_def (x)\n+     void *x;\n {\n-  int i;\n-\n-  i = GET_NUM_ELEM (v);\n-  while (--i >= 0)\n-    ggc_mark_rtx (RTVEC_ELT (v, i));\n+  ggc_mark_rtx((rtx)x);\n }\n \n-/* Recursively set marks on all of the children of the\n-   GCC_PENDING_TREES.  */\n-\n-static void\n-ggc_mark_trees ()\n-{\n-  while (ggc_pending_trees->elements_used)\n-    {\n-      tree t;\n-      enum tree_code code;\n-\n-      t = VARRAY_TOP_TREE (ggc_pending_trees);\n-      VARRAY_POP (ggc_pending_trees);\n-      code = TREE_CODE (t);\n-\n-      /* Collect statistics, if appropriate.  */\n-      if (ggc_stats)\n-\t{\n-\t  ++ggc_stats->num_trees[(int) code];\n-\t  ggc_stats->size_trees[(int) code] += ggc_get_size (t);\n-\t}\n-\n-      /* Bits from common.  */\n-      ggc_mark_tree (TREE_TYPE (t));\n-      ggc_mark_tree (TREE_CHAIN (t));\n-\n-      /* Some nodes require special handling.  */\n-      switch (code)\n-\t{\n-\tcase TREE_LIST:\n-\t  ggc_mark_tree (TREE_PURPOSE (t));\n-\t  ggc_mark_tree (TREE_VALUE (t));\n-\t  continue;\n-\n-\tcase TREE_VEC:\n-\t  {\n-\t    int i = TREE_VEC_LENGTH (t);\n-\n-\t    while (--i >= 0)\n-\t      ggc_mark_tree (TREE_VEC_ELT (t, i));\n-\t    continue;\n-\t  }\n-\n-\tcase COMPLEX_CST:\n-\t  ggc_mark_tree (TREE_REALPART (t));\n-\t  ggc_mark_tree (TREE_IMAGPART (t));\n-\t  break;\n-\n-\tcase REAL_CST:\n-\t  ggc_mark (TREE_REAL_CST_PTR (t));\n-\t  break;\n-\n-\tcase PARM_DECL:\n-\t  ggc_mark_rtx (DECL_INCOMING_RTL (t));\n-\t  break;\n-\n-\tcase FIELD_DECL:\n-\t  ggc_mark_tree (DECL_FIELD_BIT_OFFSET (t));\n-\t  break;\n-\n-\tcase IDENTIFIER_NODE:\n-\t  (*lang_hooks.mark_tree) (t);\n-\t  continue;\n-\n-\tdefault:\n-\t  break;\n-\t}\n-  \n-      /* But in general we can handle them by class.  */\n-      switch (TREE_CODE_CLASS (code))\n-\t{\n-\tcase 'd': /* A decl node.  */\n-\t  ggc_mark_tree (DECL_SIZE (t));\n-\t  ggc_mark_tree (DECL_SIZE_UNIT (t));\n-\t  ggc_mark_tree (DECL_NAME (t));\n-\t  ggc_mark_tree (DECL_CONTEXT (t));\n-\t  ggc_mark_tree (DECL_ARGUMENTS (t));\n-\t  ggc_mark_tree (DECL_RESULT_FLD (t));\n-\t  ggc_mark_tree (DECL_INITIAL (t));\n-\t  ggc_mark_tree (DECL_ABSTRACT_ORIGIN (t));\n-\t  ggc_mark_tree (DECL_SECTION_NAME (t));\n-\t  ggc_mark_tree (DECL_ATTRIBUTES (t));\n-\t  if (DECL_RTL_SET_P (t))\n-\t    ggc_mark_rtx (DECL_RTL (t));\n-\t  ggc_mark_rtx (DECL_LIVE_RANGE_RTL (t));\n-\t  ggc_mark_tree (DECL_VINDEX (t));\n-\t  if (DECL_ASSEMBLER_NAME_SET_P (t))\n-\t    ggc_mark_tree (DECL_ASSEMBLER_NAME (t));\n-\t  if (TREE_CODE (t) == FUNCTION_DECL)\n-\t    {\n-\t      ggc_mark_tree (DECL_SAVED_TREE (t));\n-\t      ggc_mark_tree (DECL_INLINED_FNS (t));\n-\t      if (DECL_SAVED_INSNS (t))\n-\t\tggc_mark_struct_function (DECL_SAVED_INSNS (t));\n-\t    }\n-\t  (*lang_hooks.mark_tree) (t);\n-\t  break;\n-\n-\tcase 't': /* A type node.  */\n-\t  ggc_mark_tree (TYPE_SIZE (t));\n-\t  ggc_mark_tree (TYPE_SIZE_UNIT (t));\n-\t  ggc_mark_tree (TYPE_ATTRIBUTES (t));\n-\t  ggc_mark_tree (TYPE_VALUES (t));\n-\t  ggc_mark_tree (TYPE_POINTER_TO (t));\n-\t  ggc_mark_tree (TYPE_REFERENCE_TO (t));\n-\t  ggc_mark_tree (TYPE_NAME (t));\n-\t  ggc_mark_tree (TYPE_MIN_VALUE (t));\n-\t  ggc_mark_tree (TYPE_MAX_VALUE (t));\n-\t  ggc_mark_tree (TYPE_NEXT_VARIANT (t));\n-\t  ggc_mark_tree (TYPE_MAIN_VARIANT (t));\n-\t  ggc_mark_tree (TYPE_BINFO (t));\n-\t  ggc_mark_tree (TYPE_CONTEXT (t));\n-\t  (*lang_hooks.mark_tree) (t);\n-\t  break;\n-\n-\tcase 'b': /* A lexical block.  */\n-\t  ggc_mark_tree (BLOCK_VARS (t));\n-\t  ggc_mark_tree (BLOCK_SUBBLOCKS (t));\n-\t  ggc_mark_tree (BLOCK_SUPERCONTEXT (t));\n-\t  ggc_mark_tree (BLOCK_ABSTRACT_ORIGIN (t));\n-\t  break;\n-\n-\tcase 'c': /* A constant.  */\n-\t  ggc_mark_rtx (TREE_CST_RTL (t));\n-\t  break;\n-\n-\tcase 'r': case '<': case '1':\n-\tcase '2': case 'e': case 's': /* Expressions.  */\n-\t  {\n-\t    int i = TREE_CODE_LENGTH (TREE_CODE (t));\n-\t    int first_rtl = first_rtl_op (TREE_CODE (t));\n-\n-\t    while (--i >= 0)\n-\t      {\n-\t\tif (i >= first_rtl)\n-\t\t  ggc_mark_rtx ((rtx) TREE_OPERAND (t, i));\n-\t\telse\n-\t\t  ggc_mark_tree (TREE_OPERAND (t, i));\n-\t      }\n-\t    break;\t\n-\t  }\n-\n-\tcase 'x':\n-\t  (*lang_hooks.mark_tree) (t);\n-\t  break;\n-\t}\n-    }\n-}\n-\n-/* Mark all the elements of the varray V, which contains rtxs.  */\n-\n-void\n-ggc_mark_rtx_varray (v)\n-     varray_type v;\n-{\n-  int i;\n-\n-  if (v)\n-    for (i = v->num_elements - 1; i >= 0; --i) \n-      ggc_mark_rtx (VARRAY_RTX (v, i));\n-}\n-\n-/* Mark all the elements of the varray V, which contains trees.  */\n-\n-void\n-ggc_mark_tree_varray (v)\n-     varray_type v;\n-{\n-  int i;\n-\n-  if (v)\n-    for (i = v->num_elements - 1; i >= 0; --i) \n-      ggc_mark_tree (VARRAY_TREE (v, i));\n-}\n-\n-/* Mark the hash table-entry HE.  Its key field is really a tree.  */\n-\n-static bool\n-ggc_mark_tree_hash_table_entry (he, k)\n-     struct hash_entry *he;\n-     hash_table_key k ATTRIBUTE_UNUSED;\n-{\n-  ggc_mark_tree ((tree) he->key);\n-  return true;\n-}\n-\n-/* Mark all the elements of the hash-table H, which contains trees.  */\n-\n-void\n-ggc_mark_tree_hash_table (ht)\n-     struct hash_table *ht;\n-{\n-  hash_traverse (ht, ggc_mark_tree_hash_table_entry, /*info=*/0);\n-}\n-\n-/* Type-correct function to pass to ggc_add_root.  It just forwards\n-   *ELT (which is an rtx) to ggc_mark_rtx.  */\n-\n-static void\n-ggc_mark_rtx_ptr (elt)\n-     void *elt;\n-{\n-  ggc_mark_rtx (*(rtx *) elt);\n-}\n-\n-/* Type-correct function to pass to ggc_add_root.  It just forwards\n-   *ELT (which is a tree) to ggc_mark_tree.  */\n-\n-static void\n-ggc_mark_tree_ptr (elt)\n-     void *elt;\n+/* Allocate a block of memory, then clear it.  */\n+void *\n+ggc_alloc_cleared (size)\n+     size_t size;\n {\n-  ggc_mark_tree (*(tree *) elt);\n+  void *buf = ggc_alloc (size);\n+  memset (buf, 0, size);\n+  return buf;\n }\n \n-/* Type-correct function to pass to ggc_add_root.  It just forwards\n-   ELT (which is really a varray_type *) to ggc_mark_rtx_varray.  */\n-\n-static void\n-ggc_mark_rtx_varray_ptr (elt)\n-     void *elt;\n+/* Resize a block of memory, possibly re-allocating it.  */\n+void *\n+ggc_realloc (x, size)\n+     void *x;\n+     size_t size;\n {\n-  ggc_mark_rtx_varray (*(varray_type *) elt);\n-}\n+  void *r;\n+  size_t old_size;\n \n-/* Type-correct function to pass to ggc_add_root.  It just forwards\n-   ELT (which is really a varray_type *) to ggc_mark_tree_varray.  */\n+  if (x == NULL)\n+    return ggc_alloc (size);\n \n-static void\n-ggc_mark_tree_varray_ptr (elt)\n-     void *elt;\n-{\n-  ggc_mark_tree_varray (*(varray_type *) elt);\n-}\n+  old_size = ggc_get_size (x);\n+  if (size <= old_size)\n+    return x;\n \n-/* Type-correct function to pass to ggc_add_root.  It just forwards\n-   ELT (which is really a struct hash_table **) to\n-   ggc_mark_tree_hash_table.  */\n-\n-static void\n-ggc_mark_tree_hash_table_ptr (elt)\n-     void *elt;\n-{\n-  ggc_mark_tree_hash_table (*(struct hash_table **) elt);\n+  r = ggc_alloc (size);\n+  memcpy (r, x, old_size);\n+  return r;\n }\n \n-/* Allocate a block of memory, then clear it.  */\n+/* Like ggc_alloc_cleared, but performs a multiplication.  */\n void *\n-ggc_alloc_cleared (size)\n-     size_t size;\n+ggc_calloc (s1, s2)\n+     size_t s1, s2;\n {\n-  void *buf = ggc_alloc (size);\n-  memset (buf, 0, size);\n-  return buf;\n+  return ggc_alloc_cleared (s1 * s2);\n }\n \n /* Print statistics that are independent of the collector in use.  */"}, {"sha": "3711475dc0b27c2dfd53e7524c6c202a47c62bc8", "filename": "gcc/ggc-none.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fggc-none.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fggc-none.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-none.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -32,3 +32,18 @@ ggc_alloc (size)\n {\n   return xmalloc (size);\n }\n+\n+void *\n+ggc_alloc_cleared (size)\n+     size_t size;\n+{\n+  return xcalloc (size, 1);\n+}\n+\n+void *\n+ggc_realloc (x, size)\n+     void *x;\n+     size_t size;\n+{\n+  return xrealloc (x, size);\n+}"}, {"sha": "87a38549f4b011957072103612e99287ab9455a8", "filename": "gcc/ggc.h", "status": "modified", "additions": 38, "deletions": 77, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fggc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fggc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc.h?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -19,72 +19,54 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n 02111-1307, USA.  */\n \n #include \"varray.h\"\n+#include \"gtype-desc.h\"\n \n /* Symbols are marked with `ggc' for `gcc gc' so as not to interfere with\n    an external gc library that might be linked in.  */\n \n-/* These structures are defined in various headers throughout the\n-   compiler.  However, rather than force everyone who includes this\n-   header to include all the headers in which they are declared, we\n-   just forward-declare them here.  */\n-struct eh_status;\n-struct emit_status;\n-struct expr_status;\n-struct hash_table;\n-struct label_node;\n-struct rtx_def;\n-struct rtvec_def;\n-struct stmt_status;\n-union  tree_node;\n-struct varasm_status;\n-\n /* Constants for general use.  */\n extern const char empty_string[];\t/* empty string */\n extern const char digit_vector[];\t/* \"0\" .. \"9\" */\n #define digit_string(d) (digit_vector + ((d) * 2))\n \n-/* Trees that have been marked, but whose children still need marking.  */\n-extern varray_type ggc_pending_trees;\n-\n /* Manipulate global roots that are needed between calls to gc.  */\n extern void ggc_add_root\t\tPARAMS ((void *base, int nelt,\n \t\t\t\t\t\t int size, void (*)(void *)));\n-extern void ggc_add_rtx_root\t\tPARAMS ((struct rtx_def **, int nelt));\n-extern void ggc_add_tree_root\t\tPARAMS ((union tree_node **,\n-\t\t\t\t\t\t int nelt));\n-extern void ggc_add_rtx_varray_root\tPARAMS ((struct varray_head_tag **,\n-\t\t\t\t\t\t int nelt));\n-extern void ggc_add_tree_varray_root\tPARAMS ((struct varray_head_tag **,\n-\t\t\t\t\t\t int nelt));\n-extern void ggc_add_tree_hash_table_root PARAMS ((struct hash_table **,\n-\t\t\t\t\t\t  int nelt));\n-extern void ggc_del_root\t\tPARAMS ((void *base));\n-\n-/* Types used for mark test and marking functions, if specified, in call\n-   below.  */\n-typedef int (*ggc_htab_marked_p) PARAMS ((const void *));\n-typedef void (*ggc_htab_mark) PARAMS ((const void *));\n-\n-/* Add a hash table to be scanned when all roots have been processed.  We\n-   delete any entry in the table that has not been marked.  The argument is\n-   really htab_t.  */\n-extern void ggc_add_deletable_htab\tPARAMS ((PTR, ggc_htab_marked_p,\n-\t\t\t\t\t\t ggc_htab_mark));\n-\n-/* Mark nodes from the gc_add_root callback.  These functions follow\n-   pointers to mark other objects too.  */\n-extern void ggc_mark_rtx_varray\t\tPARAMS ((struct varray_head_tag *));\n-extern void ggc_mark_tree_varray\tPARAMS ((struct varray_head_tag *));\n-extern void ggc_mark_tree_hash_table\tPARAMS ((struct hash_table *));\n+\n+/* Structures for the easy way to mark roots.  \n+   In an array, terminated by having base == NULL.*/\n+struct ggc_root_tab {\n+  void *base;\n+  size_t nelt;\n+  size_t stride;\n+  void (*cb) PARAMS ((void *));\n+};\n+#define LAST_GGC_ROOT_TAB { NULL, 0, 0, NULL }\n+/* Pointers to arrays of ggc_root_tab, terminated by NULL.  */\n+extern const struct ggc_root_tab * const gt_ggc_rtab[];\n+extern const struct ggc_root_tab * const gt_ggc_deletable_rtab[];\n+\n+/* Structure for hash table cache marking.  */\n+struct htab;\n+struct ggc_cache_tab {\n+  struct htab * *base;\n+  size_t nelt;\n+  size_t stride;\n+  void (*cb) PARAMS ((void *));\n+  int (*marked_p) PARAMS ((const void *));\n+};\n+#define LAST_GGC_CACHE_TAB { NULL, 0, 0, NULL, NULL }\n+/* Pointers to arrays of ggc_cache_tab, terminated by NULL.  */\n+extern const struct ggc_cache_tab * const gt_ggc_cache_rtab[];\n+\n extern void ggc_mark_roots\t\tPARAMS ((void));\n \n extern void ggc_mark_rtx_children\tPARAMS ((struct rtx_def *));\n-extern void ggc_mark_rtvec_children\tPARAMS ((struct rtvec_def *));\n \n /* If EXPR is not NULL and previously unmarked, mark it and evaluate\n    to true.  Otherwise evaluate to false.  */\n #define ggc_test_and_set_mark(EXPR) \\\n-  ((EXPR) != NULL && ! ggc_set_mark (EXPR))\n+  ((EXPR) != NULL && ((void *) (EXPR)) != (void *) 1 && ! ggc_set_mark (EXPR))\n \n #define ggc_mark_rtx(EXPR)                      \\\n   do {                                          \\\n@@ -93,31 +75,12 @@ extern void ggc_mark_rtvec_children\tPARAMS ((struct rtvec_def *));\n       ggc_mark_rtx_children (r__);              \\\n   } while (0)\n \n-#define ggc_mark_tree(EXPR)\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\\\n-    tree const t__ = (EXPR);\t\t\t\t\\\n-    if (ggc_test_and_set_mark (t__))\t\t\t\\\n-      VARRAY_PUSH_TREE (ggc_pending_trees, t__);\t\\\n-  } while (0)\n-\n-#define ggc_mark_nonnull_tree(EXPR)\t\t\t\\\n-  do {\t\t\t\t\t\t\t\\\n-    tree const t__ = (EXPR);\t\t\t\t\\\n-    if (! ggc_set_mark (t__))\t\t\t\t\\\n-      VARRAY_PUSH_TREE (ggc_pending_trees, t__);\t\\\n-  } while (0)\n-\n-#define ggc_mark_rtvec(EXPR)                    \\\n-  do {                                          \\\n-    rtvec const v__ = (EXPR);                   \\\n-    if (ggc_test_and_set_mark (v__))            \\\n-      ggc_mark_rtvec_children (v__);            \\\n-  } while (0)\n+#define ggc_mark_tree gt_ggc_m_tree_node\n \n #define ggc_mark(EXPR)\t\t\t\t\\\n   do {\t\t\t\t\t\t\\\n     const void *const a__ = (EXPR);\t\t\\\n-    if (a__ != NULL)\t\t\t\t\\\n+    if (a__ != NULL && a__ != (void *) 1)\t\\\n       ggc_set_mark (a__);\t\t\t\\\n   } while (0)\n \n@@ -141,6 +104,10 @@ extern void ggc_pop_context \tPARAMS ((void));\n extern void *ggc_alloc\t\tPARAMS ((size_t));\n /* Like ggc_alloc, but allocates cleared memory.  */\n extern void *ggc_alloc_cleared\tPARAMS ((size_t));\n+/* Resize a block.  */\n+extern void *ggc_realloc\tPARAMS ((void *, size_t));\n+/* Like ggc_alloc_cleared, but performs a multiplication.  */\n+extern void *ggc_calloc\t\tPARAMS ((size_t, size_t));\n \n #define ggc_alloc_rtx(NSLOTS)\t\t\t\t\t\t  \\\n   ((struct rtx_def *) ggc_alloc (sizeof (struct rtx_def)\t\t  \\\n@@ -152,6 +119,9 @@ extern void *ggc_alloc_cleared\tPARAMS ((size_t));\n \n #define ggc_alloc_tree(LENGTH) ((union tree_node *) ggc_alloc (LENGTH))\n \n+#define htab_create_ggc(SIZE, HASH, EQ, DEL) \\\n+  htab_create_alloc (SIZE, HASH, EQ, DEL, ggc_calloc, NULL)\n+\n /* Allocate a gc-able string, and fill it with LENGTH bytes from CONTENTS.\n    If LENGTH is -1, then CONTENTS is assumed to be a\n    null-terminated string and the memory sized accordingly.  */\n@@ -177,15 +147,6 @@ extern int ggc_set_mark\t\t\tPARAMS ((const void *));\n    static objects, stack variables, or memory allocated with malloc.  */\n extern int ggc_marked_p\t\t\tPARAMS ((const void *));\n \n-/* Mark functions for various structs scattered about.  */\n-\n-void mark_eh_status\t\t\tPARAMS ((struct eh_status *));\n-void mark_emit_status\t\t\tPARAMS ((struct emit_status *));\n-void mark_expr_status\t\t\tPARAMS ((struct expr_status *));\n-void mark_stmt_status\t\t\tPARAMS ((struct stmt_status *));\n-void mark_varasm_status\t\t\tPARAMS ((struct varasm_status *));\n-void mark_optab\t\t\t\tPARAMS ((void *));\n-\n /* Statistics.  */\n \n /* This structure contains the statistics common to all collectors."}, {"sha": "5cf8397692d63e08954b6a3553a7c3eb935ec52d", "filename": "gcc/hash.c", "status": "removed", "additions": 0, "deletions": 218, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ae66169b8326bbf9b1dfa63083d2560fea7ddf/gcc%2Fhash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ae66169b8326bbf9b1dfa63083d2560fea7ddf/gcc%2Fhash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash.c?ref=c2ae66169b8326bbf9b1dfa63083d2560fea7ddf", "patch": "@@ -1,218 +0,0 @@\n-/* hash.c -- hash table routines\n-   Copyright (C) 1993, 1994, 1998, 2001 Free Software Foundation, Inc.\n-   Written by Steve Chamberlain <sac@cygnus.com>\n-\n-This file was lifted from BFD, the Binary File Descriptor library.\n-\n-This program is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2 of the License, or\n-(at your option) any later version.\n-\n-This program is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this program; if not, write to the Free Software\n-Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"hash.h\"\n-#include \"obstack.h\"\n-#include \"toplev.h\"\n-\n-/* Obstack allocation and deallocation routines.  */\n-#define obstack_chunk_alloc xmalloc\n-#define obstack_chunk_free free\n-\n-/* The default number of entries to use when creating a hash table.  */\n-#define DEFAULT_SIZE 1009\n-\n-/* Create a new hash table, given a number of entries.  */\n-\n-void\n-hash_table_init_n (table, newfunc, hash, comp, size)\n-     struct hash_table *table;\n-     struct hash_entry *(*newfunc) PARAMS ((struct hash_entry *,\n-\t\t\t\t\t    struct hash_table *,\n-\t\t\t\t\t    hash_table_key));\n-     unsigned long (*hash) PARAMS ((hash_table_key));\n-     bool (*comp) PARAMS ((hash_table_key, hash_table_key));\n-     unsigned int size;\n-{\n-  unsigned int alloc;\n-\n-  alloc = size * sizeof (struct hash_entry *);\n-  obstack_begin (&table->memory, alloc);\n-  table->table = ((struct hash_entry **)\n-\t\t  obstack_alloc (&table->memory, alloc));\n-  memset ((PTR) table->table, 0, alloc);\n-  table->size = size;\n-  table->newfunc = newfunc;\n-  table->hash = hash;\n-  table->comp = comp;\n-}\n-\n-/* Create a new hash table with the default number of entries.  */\n-\n-void\n-hash_table_init (table, newfunc, hash, comp)\n-     struct hash_table *table;\n-     struct hash_entry *(*newfunc) PARAMS ((struct hash_entry *,\n-\t\t\t\t\t    struct hash_table *,\n-\t\t\t\t\t    hash_table_key));\n-     unsigned long (*hash) PARAMS ((hash_table_key));\n-     bool (*comp) PARAMS ((hash_table_key, hash_table_key));\n-{\n-  hash_table_init_n (table, newfunc, hash, comp, DEFAULT_SIZE);\n-}\n-\n-/* Free a hash table.  */\n-\n-void\n-hash_table_free (table)\n-     struct hash_table *table;\n-{\n-  obstack_free (&table->memory, (PTR) NULL);\n-}\n-\n-/* Look up KEY in TABLE.  If CREATE is non-NULL a new entry is\n-   created if one does not previously exist.  */\n-\n-struct hash_entry *\n-hash_lookup (table, key, create, copy)\n-     struct hash_table *table;\n-     hash_table_key key;\n-     int create;\n-     hash_table_key (*copy) PARAMS ((struct obstack* memory, \n-\t\t\t\t     hash_table_key key));\n-{\n-  unsigned long hash;\n-  struct hash_entry *hashp;\n-  unsigned int index;\n-  \n-  hash = (*table->hash)(key);\n-\n-  index = hash % table->size;\n-  for (hashp = table->table[index]; hashp != 0; hashp = hashp->next)\n-    if (hashp->hash == hash\n-\t&& (*table->comp)(hashp->key, key))\n-      return hashp;\n-\n-  if (! create)\n-    return 0;\n-\n-  hashp = (*table->newfunc) ((struct hash_entry *) NULL, table, key);\n-  if (hashp == 0)\n-    return 0;\n-\n-  if (copy)\n-    key = (*copy) (&table->memory, key);\n-\n-  hashp->key = key;\n-  hashp->hash = hash;\n-  hashp->next = table->table[index];\n-  table->table[index] = hashp;\n-\n-  return hashp;\n-}\n-\n-/* Base method for creating a new hash table entry.  */\n-\n-struct hash_entry *\n-hash_newfunc (entry, table, p)\n-     struct hash_entry *entry;\n-     struct hash_table *table;\n-     hash_table_key p ATTRIBUTE_UNUSED;\n-{\n-  if (entry == 0)\n-    entry = ((struct hash_entry *)\n-\t     hash_allocate (table, sizeof (struct hash_entry)));\n-  return entry;\n-}\n-\n-/* Allocate space in a hash table.  */\n-\n-PTR\n-hash_allocate (table, size)\n-     struct hash_table *table;\n-     unsigned int size;\n-{\n-  return obstack_alloc (&table->memory, size);\n-}\n-\n-/* Traverse a hash table.  */\n-\n-void\n-hash_traverse (table, func, info)\n-     struct hash_table *table;\n-     bool (*func) PARAMS ((struct hash_entry *, hash_table_key));\n-     PTR info;\n-{\n-  unsigned int i;\n-  struct hash_entry *p;\n-\n-  for (i = 0; i < table->size; i++)\n-    for (p = table->table[i]; p != 0; p = p->next)\n-      if (! (*func) (p, info))\n-\treturn;\n-}\n-\n-/* Hash a string.  Return a hash-code for the string.  */\n-\n-unsigned long\n-string_hash (k)\n-     hash_table_key k;\n-{\n-  const unsigned char *s;\n-  unsigned long hash;\n-  unsigned char c;\n-  unsigned int len;\n-\n-  s = (const unsigned char *) k;\n-  hash = 0;\n-  len = 0;\n-\n-  while ((c = *s++) != '\\0')\n-    {\n-      hash += c + (c << 17);\n-      hash ^= hash >> 2;\n-      ++len;\n-    }\n-\n-  hash += len + (len << 17);\n-  hash ^= hash >> 2;\n-\n-  return hash;\n-}\n-\n-/* Compare two strings.  Return non-zero iff the two strings are\n-   the same.  */\n-\n-bool\n-string_compare (k1, k2)\n-     hash_table_key k1;\n-     hash_table_key k2;\n-{\n-  return (strcmp ((char*) k1, (char*) k2) == 0);\n-}\n-\n-/* Copy K to OBSTACK.  */\n-\n-hash_table_key\n-string_copy (memory, k)\n-     struct obstack *memory;\n-     hash_table_key k;\n-{\n-  char *new;\n-  char *string = (char *) k;\n-\n-  new = (char *) obstack_alloc (memory, strlen (string) + 1);\n-  strcpy (new, string);\n-  \n-  return new;\n-}"}, {"sha": "bd75f94c6f9a07efeea0a877a9dff101b7000505", "filename": "gcc/hash.h", "status": "removed", "additions": 0, "deletions": 129, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ae66169b8326bbf9b1dfa63083d2560fea7ddf/gcc%2Fhash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ae66169b8326bbf9b1dfa63083d2560fea7ddf/gcc%2Fhash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash.h?ref=c2ae66169b8326bbf9b1dfa63083d2560fea7ddf", "patch": "@@ -1,129 +0,0 @@\n-/* Header file for generic hash table support.\n-   Copyright (C) 1993, 1994, 1997, 1998, 2001 Free Software Foundation, Inc.\n-   Written by Steve Chamberlain <sac@cygnus.com>\n-\n-This file was lifted from BFD, the Binary File Descriptor library.\n-\n-This program is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2 of the License, or\n-(at your option) any later version.\n-\n-This program is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this program; if not, write to the Free Software\n-Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#ifndef IN_GCC\n-#include <ansidecl.h>\n-#endif /* ! IN_GCC */\n-\n-#include \"obstack.h\"\n-\n-typedef PTR hash_table_key;\n-\n-/* Hash table routines.  There is no way to free up a hash table.  */\n-\n-/* An element in the hash table.  Most uses will actually use a larger\n-   structure, and an instance of this will be the first field.  */\n-\n-struct hash_entry\n-{\n-  /* Next entry for this hash code.  */\n-  struct hash_entry *next;\n-  /* The thing being hashed.  */\n-  hash_table_key key;\n-  /* Hash code.  This is the full hash code, not the index into the\n-     table.  */\n-  unsigned long hash;\n-};\n-\n-/* A hash table.  */\n-\n-struct hash_table\n-{\n-  /* The hash array.  */\n-  struct hash_entry **table;\n-  /* The number of slots in the hash table.  */\n-  unsigned int size;\n-  /* A function used to create new elements in the hash table.  The\n-     first entry is itself a pointer to an element.  When this\n-     function is first invoked, this pointer will be NULL.  However,\n-     having the pointer permits a hierarchy of method functions to be\n-     built each of which calls the function in the superclass.  Thus\n-     each function should be written to allocate a new block of memory\n-     only if the argument is NULL.  */\n-  struct hash_entry *(*newfunc) PARAMS ((struct hash_entry *,\n-\t\t\t\t\t struct hash_table *,\n-\t\t\t\t\t hash_table_key));\n-  /* A function to compute the hash code for a key in the hash table.  */\n-  unsigned long (*hash) PARAMS ((hash_table_key));\n-  /* A function to compare two keys.  */\n-  bool (*comp) PARAMS ((hash_table_key, hash_table_key));\n-  /* An obstack for this hash table.  */\n-  struct obstack memory;\n-};\n-\n-/* Initialize a hash table.  */\n-extern void hash_table_init\n-  PARAMS ((struct hash_table *,\n-\t   struct hash_entry *(*) (struct hash_entry *,\n-\t\t\t\t   struct hash_table *,\n-\t\t\t\t   hash_table_key),\n-\t   unsigned long (*hash) (hash_table_key),\n-\t   bool (*comp) (hash_table_key, hash_table_key)));\n-\n-/* Initialize a hash table specifying a size.  */\n-extern void hash_table_init_n\n-  PARAMS ((struct hash_table *,\n-\t   struct hash_entry *(*) (struct hash_entry *,\n-\t\t\t\t   struct hash_table *,\n-\t\t\t\t   hash_table_key),\n-\t   unsigned long (*hash) (hash_table_key),\n-\t   bool (*comp) (hash_table_key, hash_table_key),\n-\t   unsigned int size));\n-\n-/* Free up a hash table.  */\n-extern void hash_table_free PARAMS ((struct hash_table *));\n-\n-/* Look up KEY in a hash table.  If CREATE is true, a new entry\n-   will be created for this KEY if one does not already exist.  If\n-   COPY is non-NULL, it is used to copy the KEY before storing it in\n-   the hash table.  */\n-extern struct hash_entry *hash_lookup\n-  PARAMS ((struct hash_table *, hash_table_key key, int create,\n-\t   hash_table_key (*copy)(struct obstack*, hash_table_key)));\n-\n-/* Base method for creating a hash table entry.  */\n-extern struct hash_entry *hash_newfunc\n-  PARAMS ((struct hash_entry *, struct hash_table *, \n-\t   hash_table_key key));\n-\n-/* Grab some space for a hash table entry.  */\n-extern PTR hash_allocate PARAMS ((struct hash_table *,\n-\t\t\t\t  unsigned int));\n-\n-/* Traverse a hash table in a random order, calling a function on each\n-   element.  If the function returns false, the traversal stops.  The\n-   INFO argument is passed to the function.  */\n-extern void hash_traverse PARAMS ((struct hash_table *,\n-\t\t\t\t   bool (*) (struct hash_entry *,\n-\t\t\t\t\t\thash_table_key),\n-\t\t\t\t   hash_table_key info));\n-\n-/* Hash a string K, which is really of type `char*'.  */\n-extern unsigned long string_hash PARAMS ((hash_table_key k));\n-\n-/* Compare two strings K1, K2 which are really of type `char*'.  */\n-extern bool string_compare PARAMS ((hash_table_key k1, \n-\t\t\t\t       hash_table_key k2));\n-\n-/* Copy a string K, which is really of type `char*'.  */\n-extern hash_table_key string_copy PARAMS ((struct obstack* memory,\n-\t\t\t\t\t   hash_table_key k));\n-"}, {"sha": "899647b6d84854159efd967beaa5d439eb5c8580", "filename": "gcc/hashtable.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhashtable.h?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -23,7 +23,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n /* This is what each hash table entry points to.  It may be embedded\n    deeply within another object.  */\n typedef struct ht_identifier ht_identifier;\n-struct ht_identifier\n+struct ht_identifier GTY(())\n {\n   unsigned int len;\n   const unsigned char *str;"}, {"sha": "4403b0b2590b7b16c7152efbded389b323a02b27", "filename": "gcc/insn-addr.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Finsn-addr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Finsn-addr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finsn-addr.h?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -23,14 +23,14 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n #include \"varray.h\"\n \n-extern varray_type insn_addresses_;\n+extern GTY(()) varray_type insn_addresses_;\n extern int insn_current_address;\n \n #define INSN_ADDRESSES_DEFN() varray_type insn_addresses_\n #define INSN_ADDRESSES(id) VARRAY_INT (insn_addresses_, (id))\n #define INSN_ADDRESSES_ALLOC(size) \\\n   VARRAY_INT_INIT (insn_addresses_, (size), \"insn_addresses\")\n-#define INSN_ADDRESSES_FREE() VARRAY_FREE (insn_addresses_)\n+#define INSN_ADDRESSES_FREE() (insn_addresses_ = 0)\n #define INSN_ADDRESSES_SET_P() (insn_addresses_ != 0)\n #define INSN_ADDRESSES_SIZE() VARRAY_SIZE (insn_addresses_)\n #define INSN_ADDRESSES_NEW(insn, addr) do \\"}, {"sha": "6a6c5432763880bf7978ae703fc74c6f201244d0", "filename": "gcc/integrate.c", "status": "modified", "additions": 11, "deletions": 27, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -68,14 +68,14 @@ extern struct obstack *function_maybepermanent_obstack;\n \f\n \n /* Private type used by {get/has}_func_hard_reg_initial_val.  */\n-typedef struct initial_value_pair {\n+typedef struct initial_value_pair GTY(()) {\n   rtx hard_reg;\n   rtx pseudo;\n } initial_value_pair;\n-typedef struct initial_value_struct {\n+typedef struct initial_value_struct GTY(()) {\n   int num_entries;\n   int max_entries;\n-  initial_value_pair *entries;\n+  initial_value_pair * GTY ((length (\"%h.num_entries\"))) entries;\n } initial_value_struct;\n \n static void setup_initial_hard_reg_value_integration PARAMS ((struct function *, struct inline_remap *));\n@@ -663,7 +663,7 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n   rtx stack_save = 0;\n   rtx temp;\n   struct inline_remap *map = 0;\n-  rtvec arg_vector = (rtvec) inl_f->original_arg_vector;\n+  rtvec arg_vector = inl_f->original_arg_vector;\n   rtx static_chain_value = 0;\n   int inl_max_uid;\n   int eh_region_offset;\n@@ -1286,7 +1286,6 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n     free (real_label_map);\n   VARRAY_FREE (map->const_equiv_varray);\n   free (map->reg_map);\n-  VARRAY_FREE (map->block_map);\n   free (map->insn_map);\n   free (map);\n   free (arg_vals);\n@@ -3057,20 +3056,20 @@ get_func_hard_reg_initial_val (fun, reg)\n \n   if (ivs == 0)\n     {\n-      fun->hard_reg_initial_vals = (void *) xmalloc (sizeof (initial_value_struct));\n+      fun->hard_reg_initial_vals = (void *) ggc_alloc (sizeof (initial_value_struct));\n       ivs = fun->hard_reg_initial_vals;\n       ivs->num_entries = 0;\n       ivs->max_entries = 5;\n-      ivs->entries = (initial_value_pair *) xmalloc (5 * sizeof (initial_value_pair));\n+      ivs->entries = (initial_value_pair *) ggc_alloc (5 * sizeof (initial_value_pair));\n     }\n \n   if (ivs->num_entries >= ivs->max_entries)\n     {\n       ivs->max_entries += 5;\n       ivs->entries = \n-\t(initial_value_pair *) xrealloc (ivs->entries,\n-\t\t\t\t\t ivs->max_entries\n-\t\t\t\t\t * sizeof (initial_value_pair));\n+\t(initial_value_pair *) ggc_realloc (ivs->entries,\n+\t\t\t\t\t    ivs->max_entries\n+\t\t\t\t\t    * sizeof (initial_value_pair));\n     }\n \n   ivs->entries[ivs->num_entries].hard_reg = reg;\n@@ -3095,23 +3094,6 @@ has_hard_reg_initial_val (mode, regno)\n   return has_func_hard_reg_initial_val (cfun, gen_rtx_REG (mode, regno));\n }\n \n-void\n-mark_hard_reg_initial_vals (fun)\n-     struct function *fun;\n-{\n-  struct initial_value_struct *ivs = fun->hard_reg_initial_vals;\n-  int i;\n-\n-  if (ivs == 0)\n-    return;\n-\n-  for (i = 0; i < ivs->num_entries; i ++)\n-    {\n-      ggc_mark_rtx (ivs->entries[i].hard_reg);\n-      ggc_mark_rtx (ivs->entries[i].pseudo);\n-    }\n-}\n-\n static void\n setup_initial_hard_reg_value_integration (inl_f, remap)\n      struct function *inl_f;\n@@ -3181,3 +3163,5 @@ allocate_initial_values (reg_equiv_memory_loc)\n     }\n #endif\n }\n+\n+#include \"gt-integrate.h\""}, {"sha": "b4d622767c9bf9719c2fc7492170b377ff6672fd", "filename": "gcc/integrate.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fintegrate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fintegrate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.h?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -143,8 +143,6 @@ extern rtx has_hard_reg_initial_val\t\tPARAMS ((enum machine_mode, int));\n /* If a pseudo represents an initial hard reg (or expression), return\n    it, else return NULL_RTX.  */\n extern rtx get_hard_reg_initial_reg\t\tPARAMS ((struct function *, rtx));\n-/* This is for GC.  */\n-extern void mark_hard_reg_initial_vals\t\tPARAMS ((struct function *));\n /* Called from rest_of_compilation.  */\n extern void emit_initial_value_sets\t\tPARAMS ((void));\n extern void allocate_initial_values\t\tPARAMS ((rtx *));"}, {"sha": "5a7fc589c517a252568f483219f41ef163881994", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -1,3 +1,95 @@\n+2002-06-03  Geoffrey Keating  <geoffk@redhat.com>\n+\n+\t* check-init.c (attach_initialized_static_class): Delete, unused.\n+\t* parse.y: Use htab_t instead of struct hashtable, update\n+\tall uses.\n+\t* java-tree.h: Include hashtab.h instead of hash.h.\n+\t(struct lang_decl_func): Use htab_t, set up for gengtype.\n+\t(struct init_test_hash_entry): Delete.\n+\t(struct treetreehash_entry): New.\n+\t(java_treetreehash_find): New \n+\t(java_treetreehash_new): New prototype.\n+\t(java_treetreehash_create): New prototype.\n+\t(java_mark_tree): Delete prototype.\n+\t(java_hash_hash_tree_node): Delete prototype.\n+\t(java_hash_compare_tree_node): Delete prototype.\n+\t(attach_initialized_static_class): Delete prototype.\n+\t* expr.c (build_class_init): Update to use java_treetreehash\n+\tfunctions.\n+\t(java_expand_expr): Update to use htab_t.\n+\t(emit_init_test_initialization): Likewise.\n+\t* decl.c (java_mark_tree): Delete.\n+\t* class.c (init_test_hash_newfunc): Delete.\n+\t(java_hash_hash_tree_node): Delete.\n+\t(java_hash_compare_tree_node): Delete.\n+\t(add_method_1): Update to use java_treetreehash functions.\n+\t(JAVA_TREEHASHHASH_H): New macro.\n+\t(java_treetreehash_hash): New function.\n+\t(java_treetreehash_compare): New function.\n+\t(java_treetreehash_find): New function.\n+\t(java_treetreehash_new): New function.\n+\t(java_treetreehash_create): New function.\n+\t* Make-lang.in (JAVA_TREE_H): Replace hash.h by HASHTAB_H.\n+\n+\t* Make-lang.in (java/parse.o): Depend on debug.h.\n+\t* java-tree.h (struct lang_identifier): Use gengtype.\n+\t(union lang_tree_node): New.\n+\t(struct lang_decl_func): Use gengtype.\n+\t(struct lang_decl_var): Likewise.\n+\t(struct lang_decl): Likewise.\n+\t* parse.y: Include debug.h.\n+\t* lang.c (LANG_HOOKS_MARK_TREE): Delete.\n+\n+\t* lang.c (struct language_function): New dummy structure.\n+\n+\t* java-tree.h (MAYBE_CREATE_VAR_LANG_DECL_SPECIFIC): Set\n+\tdescriminator for DECL_LANG_SPECIFIC.\n+\t(struct lang_decl_func): Rename from struct lang_decl.\n+\t(enum lang_decl_desc): New.\n+\t(struct lang_decl): Make it a union.  Update all the accessor macros.\n+\t(struct lang_type): Use gengtype.\n+\t* class.c (add_method_1): Set descriminator for DECL_LANG_SPECIFIC.\n+\t* decl.c (java_dup_lang_specific_decl): All lang_decl structures\n+\tare now the same size.\n+\t(lang_mark_tree): Use gengtype to mark TYPE_LANG_SPECIFIC;\n+\tuse discriminator to mark DECL_LANG_SPECIFIC.\n+\n+\t* Make-lang.in (gt-java-builtins.h): New rule.\n+\t(java/builtins.o): Add dependency on gt-<filename>.h.\n+\t* builtins.c: Use gengtype for roots.\n+\t(union string_or_tree): Use gengtype.\n+\t(struct builtin_record): Use gengtype.\n+\t* config-lang.in (gtfiles): Add builtins.c.\n+\n+\t* Make-lang.in (gt-java-class.h, gt-java-constants.h,\n+\tgt-java-decl.h, gt-java-expr.h, gt-java-jcf-parse.h,\n+\tgt-java-jcf-write.h, gt-java-lang.h, gt-java-mangle.h,\n+\tgt-java-parse.h, gtype-java.h): Add rules to generate.\n+\t(parse.o): Add dependency on gt-java-parse.h, gt-java.h.\n+\t(class.o): Add dependency on gt-*.h.\n+\t(constants.o): Likewise.\n+\t(decl.o): Likewise.\n+\t(expr.o): Likewise.\n+\t(jcf-parse.o): Likewise.\n+\t(jcf-write.o): Likewise.\n+\t(lang.o): Likewise.\n+\t* config-lang.in (gtfiles): New.\n+\t* class.c: Replace uses of ggc_add_* with GTY markers.  Include gt-*.h.\n+\t* constants.c: Replace uses of ggc_add_* with GTY markers.\n+\tInclude gt-*.h.\n+\t* decl.c: Replace uses of ggc_add_* with GTY markers.  Include gt-*.h.\n+\t* expr.c: Replace uses of ggc_add_* with GTY markers.  Include gt-*.h.\n+\t* java-tree.h: Replace uses of ggc_add_* with GTY markers.\n+\t* jcf-parse.c: Replace uses of ggc_add_* with GTY markers.\n+\tInclude gt-*.h.\n+\t* jcf-write.c: Replace uses of ggc_add_* with GTY markers.\n+\tInclude gt-*.h.\n+\t* lang.c: Replace uses of ggc_add_* with GTY markers.  Include gt-*.h.\n+\t* mangle.c: Replace uses of ggc_add_* with GTY markers.  Include\n+\tgt-*.h.\n+\t* parse.y: Replace uses of ggc_add_* with GTY markers.  Include gt-*.h.\n+\tInclude gtype-java.h.\n+\n 2002-06-02  Tom Tromey  <tromey@redhat.com>\n \n \tFix for PR java/5913:"}, {"sha": "05dc9ea44410ce09fbb50073c93401221438ee0e", "filename": "gcc/java/Make-lang.in", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fjava%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fjava%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FMake-lang.in?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -98,6 +98,11 @@ $(srcdir)/java/keyword.h: $(srcdir)/java/keyword.gperf\n \texit 1; } ; \\\n \tmv -f k$$$$.h keyword.h)\n \n+gt-java-class.h gt-java-constants.h gt-java-decl.h : s-gtype ; @true\n+gt-java-expr.h gt-java-jcf-parse.h gt-java-jcf-write.h : s-gtype ; @true\n+gt-java-lang.h gt-java-mangle.h gt-java-parse.h : s-gtype ; @true\n+gt-java-builtins.h gtype-java.h : s-gtype ; @true\n+\n # Executables built by this Makefile:\n JAVA_OBJS = java/parse.o java/class.o java/decl.o java/expr.o \\\n   java/constants.o java/lang.o java/typeck.o java/except.o java/verify.o \\\n@@ -251,11 +256,12 @@ java.stage4: stage4-start\n \n #\f\n # .o:.h dependencies.\n-JAVA_TREE_H = $(TREE_H) java/java-tree.h java/java-tree.def\n+JAVA_TREE_H = $(TREE_H) $(HASHTAB_H) java/java-tree.h java/java-tree.def\n JAVA_LEX_C = java/lex.c java/keyword.h java/chartables.h\n \n java/parse.o: java/parse.c java/jcf-reader.c $(CONFIG_H) $(SYSTEM_H) \\\n-  function.h $(JAVA_TREE_H) $(JAVA_LEX_C) java/parse.h java/lex.h $(GGC_H)\n+  function.h $(JAVA_TREE_H) $(JAVA_LEX_C) java/parse.h java/lex.h $(GGC_H) \\\n+  debug.h gt-java-parse.h gtype-java.h\n java/jcf-dump.o: $(CONFIG_H) $(SYSTEM_H) $(JAVA_TREE_H) java/jcf-dump.c \\\n   java/jcf-reader.c java/jcf.h java/javaop.h java/javaop.def version.h\n java/gjavah.o: $(CONFIG_H) $(SYSTEM_H) $(JAVA_TREE_H) java/gjavah.c \\\n@@ -264,37 +270,38 @@ java/boehm.o: java/boehm.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(JAVA_TREE_H) \\\n   java/parse.h toplev.h\n java/buffer.o: java/buffer.c $(CONFIG_H) java/buffer.h $(SYSTEM_H) toplev.h\n java/builtins.o: java/builtins.c $(CONFIG_H) $(SYSTEM_H) $(JAVA_TREE_H) \\\n-  $(GGC_H) flags.h builtin-types.def langhooks.h\n+  $(GGC_H) flags.h builtin-types.def langhooks.h gt-java-builtins.h\n java/check-init.o: java/check-init.c $(CONFIG_H) \\\n   $(JAVA_TREE_H) $(SYSTEM_H) toplev.h\n java/class.o: java/class.c $(CONFIG_H) $(JAVA_TREE_H) $(RTL_H) java/jcf.h \\\n-  java/parse.h toplev.h $(SYSTEM_H) output.h $(GGC_H) $(TARGET_H) function.h\n+  java/parse.h toplev.h $(SYSTEM_H) output.h $(GGC_H) $(TARGET_H) function.h \\\n+  gt-java-class.h\n java/constants.o: java/constants.c $(CONFIG_H) $(JAVA_TREE_H) java/jcf.h \\\n-  toplev.h $(SYSTEM_H) $(GGC_H)\n+  toplev.h $(SYSTEM_H) $(GGC_H) gt-java-constants.h\n java/decl.o: java/decl.c $(CONFIG_H) $(JAVA_TREE_H) $(RTL_H) java/jcf.h \\\n   toplev.h flags.h $(SYSTEM_H) function.h expr.h libfuncs.h except.h \\\n-  java/java-except.h $(GGC_H) real.h\n+  java/java-except.h $(GGC_H) real.h gt-java-decl.h\n java/except.o: java/except.c $(CONFIG_H) $(JAVA_TREE_H) java/jcf.h real.h \\\n   $(RTL_H) java/javaop.h java/java-opcodes.h except.h java/java-except.h \\\n   toplev.h $(SYSTEM_H) function.h \n java/expr.o: java/expr.c $(CONFIG_H) $(JAVA_TREE_H) java/jcf.h real.h \\\n   $(RTL_H) $(EXPR_H) java/javaop.h java/java-opcodes.h except.h \\\n   java/java-except.h java/java-except.h java/parse.h toplev.h \\\n-  $(SYSTEM_H) $(GGC_H)\n+  $(SYSTEM_H) $(GGC_H) gt-java-expr.h\n java/jcf-depend.o: java/jcf-depend.c $(CONFIG_H) $(SYSTEM_H) java/jcf.h\n java/jcf-parse.o: java/jcf-parse.c $(CONFIG_H) $(JAVA_TREE_H) flags.h \\\n   input.h java/java-except.h $(SYSTEM_H) toplev.h java/parse.h $(GGC_H) \\\n-  debug.h real.h\n+  debug.h real.h gt-java-jcf-parse.h\n java/jcf-write.o: java/jcf-write.c $(CONFIG_H) $(JAVA_TREE_H) java/jcf.h \\\n   $(RTL_H) java/java-opcodes.h java/parse.h java/buffer.h $(SYSTEM_H) \\\n-  toplev.h $(GGC_H)\n+  toplev.h $(GGC_H) gt-java-jcf-write.h\n java/jv-scan.o: java/jv-scan.c $(CONFIG_H) $(SYSTEM_H) version.h\n java/jvgenmain.o: java/jvgenmain.c $(CONFIG_H) $(JAVA_TREE_H) $(SYSTEM_H)\n java/lang.o: java/lang.c $(CONFIG_H) $(JAVA_TREE_H) java/jcf.h input.h \\\n   toplev.h $(SYSTEM_H) $(RTL_H) $(EXPR_H) diagnostic.h langhooks.h \\\n-  langhooks-def.h\n+  langhooks-def.h gt-java-lang.h\n java/mangle.o: java/mangle.c $(CONFIG_H) java/jcf.h $(JAVA_TREE_H) $(SYSTEM_H) \\\n-  toplev.h $(GGC_H)\n+  toplev.h $(GGC_H) gt-java-mangle.h\n java/mangle_name.o: java/mangle_name.c $(CONFIG_H) java/jcf.h $(JAVA_TREE_H) \\\n   $(SYSTEM_H) toplev.h $(GGC_H)\n java/parse-scan.o: $(CONFIG_H) $(SYSTEM_H) toplev.h $(JAVA_LEX_C) java/parse.h \\"}, {"sha": "c167df5b16b930980dd9b7a1d85da3fdc6c0276f", "filename": "gcc/java/builtins.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fjava%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fjava%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fbuiltins.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -83,21 +83,21 @@ typedef tree builtin_creator_function PARAMS ((tree, tree));\n \n /* Hold a char*, before initialization, or a tree, after\n    initialization.  */\n-union string_or_tree\n+union string_or_tree GTY(())\n {\n-  const char *s;\n-  tree t;\n+  const char * GTY ((tag (\"0\"))) s;\n+  tree GTY ((tag (\"1\"))) t;\n };\n \n /* Used to hold a single builtin record.  */\n-struct builtin_record\n+struct builtin_record GTY(())\n {\n-  union string_or_tree class_name;\n-  union string_or_tree method_name;\n-  builtin_creator_function *creator;\n+  union string_or_tree GTY ((desc (\"1\"))) class_name;\n+  union string_or_tree GTY ((desc (\"1\"))) method_name;\n+  builtin_creator_function * GTY((skip (\"\"))) creator;\n };\n \n-static struct builtin_record java_builtins[] =\n+static GTY(()) struct builtin_record java_builtins[] =\n {\n   { { \"java.lang.Math\" }, { \"min\" }, min_builtin },\n   { { \"java.lang.Math\" }, { \"max\" }, max_builtin },\n@@ -273,8 +273,6 @@ initialize_builtins ()\n \n       java_builtins[i].class_name.t = klass_id;\n       java_builtins[i].method_name.t = m;\n-      ggc_add_tree_root (&java_builtins[i].class_name.t, 1);\n-      ggc_add_tree_root (&java_builtins[i].method_name.t, 1);\n     }\n \n   void_list_node = end_params_node;\n@@ -348,3 +346,5 @@ check_for_builtin (method, call)\n     }\n   return call;\n }\n+\n+#include \"gt-java-builtins.h\""}, {"sha": "e02237664bd3dee9fdab7a1c7d3cbc8075d9b465", "filename": "gcc/java/check-init.c", "status": "modified", "additions": 4, "deletions": 26, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fjava%2Fcheck-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fjava%2Fcheck-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fcheck-init.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -607,8 +607,10 @@ check_init (exp, before)\n \t\t  if (fndecl && METHOD_STATIC (fndecl)\n \t\t      && (DECL_INITIAL (decl) == boolean_true_node\n \t\t\t  || (index >= 0 && ASSIGNED_P (tmp, index))))\n-\t\t    hash_lookup (&DECL_FUNCTION_INITIALIZED_CLASS_TABLE (fndecl),\n-\t\t\t\t DECL_FUNCTION_INIT_TEST_CLASS(decl), TRUE, NULL);  \n+\t\t    *(htab_find_slot \n+\t\t      (DECL_FUNCTION_INITIALIZED_CLASS_TABLE (fndecl),\n+\t\t       DECL_FUNCTION_INIT_TEST_CLASS (decl), INSERT)) =\n+\t\t      DECL_FUNCTION_INIT_TEST_CLASS (decl);\n \t\t}\n \t      DECL_BIT_INDEX (decl) = -1;\n \t    }\n@@ -999,27 +1001,3 @@ check_for_initialization (body, mdecl)\n \n   start_current_locals = num_current_locals = 0;\n }\n-\n-/* Call for every element in DECL_FUNCTION_INITIALIZED_CLASS_TABLE of\n-   a method to consider whether the type indirectly described by ENTRY\n-   is definitly initialized and thus remembered as such. */\n-\n-bool\n-attach_initialized_static_class (entry, ptr)\n-     struct hash_entry *entry;\n-     PTR ptr;\n-{\n-  struct init_test_hash_entry *ite = (struct init_test_hash_entry *) entry;\n-  tree fndecl = DECL_CONTEXT (ite->init_test_decl);\n-  int index = DECL_BIT_INDEX (ite->init_test_decl);\n-\n-  /* If the initializer flag has been definitly assigned (not taking\n-     into account its first mandatory assignment which has been\n-     already added but escaped analysis.) */\n-  if (fndecl && METHOD_STATIC (fndecl)\n-      && (DECL_INITIAL (ite->init_test_decl) == boolean_true_node\n-\t  || (index >= 0 && ASSIGNED_P (((word *) ptr), index))))\n-    hash_lookup (&DECL_FUNCTION_INITIALIZED_CLASS_TABLE (fndecl),\n-\t\t entry->key, TRUE, NULL);\n-  return true;\n-}"}, {"sha": "0b9c6a9889e6f1fb21481bc56980f9fd49743332", "filename": "gcc/java/class.c", "status": "modified", "additions": 86, "deletions": 54, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -55,13 +55,10 @@ static tree get_dispatch_table PARAMS ((tree, tree));\n static void add_interface_do PARAMS ((tree, tree, int));\n static tree maybe_layout_super_class PARAMS ((tree, tree));\n static int assume_compiled PARAMS ((const char *));\n-static struct hash_entry *init_test_hash_newfunc PARAMS ((struct hash_entry *,\n-\t\t\t\t\t\t\t  struct hash_table *,\n-\t\t\t\t\t\t\t  hash_table_key));\n static tree build_method_symbols_entry PARAMS ((tree));\n \n-static rtx registerClass_libfunc;\n-static rtx registerResource_libfunc;\n+static GTY(()) rtx registerClass_libfunc;\n+static GTY(()) rtx registerResource_libfunc;\n \n extern struct obstack permanent_obstack;\n struct obstack temporary_obstack;\n@@ -95,8 +92,7 @@ static assume_compiled_node *find_assume_compiled_node\n \n static assume_compiled_node *assume_compiled_tree;\n \n-static tree class_roots[5]\n-= { NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE };\n+static GTY(()) tree class_roots[5];\n #define registered_class class_roots[0]\n #define fields_ident class_roots[1]  /* get_identifier (\"fields\") */\n #define info_ident class_roots[2]  /* get_identifier (\"info\") */\n@@ -625,43 +621,6 @@ build_java_method_type (fntype, this_class, access_flags)\n   return build_method_type (CLASS_TO_HANDLE_TYPE (this_class), fntype);\n }\n \n-static struct hash_entry *\n-init_test_hash_newfunc (entry, table, string)\n-     struct hash_entry *entry;\n-     struct hash_table *table;\n-     hash_table_key string ATTRIBUTE_UNUSED;\n-{\n-  struct init_test_hash_entry *ret = (struct init_test_hash_entry *) entry;\n-  if (ret == NULL)\n-    {\n-      ret = ((struct init_test_hash_entry *)\n-\t     hash_allocate (table, sizeof (struct init_test_hash_entry)));\n-      if (ret == NULL)\n-\treturn NULL;\n-    }\n-  ret->init_test_decl = 0;\n-  return (struct hash_entry *) ret;\n-}\n-\n-/* Hash table helpers. Also reused in find_applicable_accessible_methods_list \n-   (parse.y). The hash of a tree node is its pointer value, comparison\n-   is direct. */\n-\n-unsigned long\n-java_hash_hash_tree_node (k)\n-     hash_table_key k;\n-{\n-  return (long) k;\n-}\n-\n-bool\n-java_hash_compare_tree_node (k1, k2)\n-     hash_table_key k1;\n-     hash_table_key k2;\n-{\n-  return ((tree) k1 == (tree) k2);\n-}\n-\n tree\n add_method_1 (handle_class, access_flags, name, function_type)\n      tree handle_class;\n@@ -679,17 +638,17 @@ add_method_1 (handle_class, access_flags, name, function_type)\n \n   DECL_LANG_SPECIFIC (fndecl)\n     = (struct lang_decl *) ggc_alloc_cleared (sizeof (struct lang_decl));\n+  DECL_LANG_SPECIFIC (fndecl)->desc = LANG_DECL_FUNC;\n \n   /* Initialize the static initializer test table.  */\n-  hash_table_init (&DECL_FUNCTION_INIT_TEST_TABLE (fndecl),\n-\t\t   init_test_hash_newfunc, java_hash_hash_tree_node, \n-\t\t   java_hash_compare_tree_node);\n+  \n+  DECL_FUNCTION_INIT_TEST_TABLE (fndecl) = \n+    java_treetreehash_create (10, 1);\n \n   /* Initialize the initialized (static) class table. */\n   if (access_flags & ACC_STATIC)\n-    hash_table_init (&DECL_FUNCTION_INITIALIZED_CLASS_TABLE (fndecl),\n-\t\t     init_test_hash_newfunc, java_hash_hash_tree_node,\n-\t\t     java_hash_compare_tree_node);\n+    DECL_FUNCTION_INITIALIZED_CLASS_TABLE (fndecl) =\n+      htab_create_ggc (50, htab_hash_pointer, htab_eq_pointer, NULL);\n \n   /* Initialize the static method invocation compound list */\n   DECL_FUNCTION_STATIC_METHOD_INVOCATION_COMPOUND (fndecl) = NULL_TREE;\n@@ -2327,12 +2286,85 @@ emit_offset_symbol_table ()\n void\n init_class_processing ()\n {\n-  registerClass_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"_Jv_RegisterClass\");\n+  registerClass_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"_Jv_RegisterClass\");\n   registerResource_libfunc = \n-    gen_rtx (SYMBOL_REF, Pmode, \"_Jv_RegisterResource\");\n-  ggc_add_tree_root (class_roots, ARRAY_SIZE (class_roots));\n+    gen_rtx_SYMBOL_REF (Pmode, \"_Jv_RegisterResource\");\n   fields_ident = get_identifier (\"fields\");\n   info_ident = get_identifier (\"info\");\n-  ggc_add_rtx_root (&registerClass_libfunc, 1);\n   gcc_obstack_init (&temporary_obstack);\n }\n+\f\n+static hashval_t java_treetreehash_hash PARAMS ((const void *));\n+static int java_treetreehash_compare PARAMS ((const void *, const void *));\n+\n+/* A hash table mapping trees to trees.  Used generally.  */\n+\n+#define JAVA_TREEHASHHASH_H(t) ((hashval_t) (t))\n+\n+static hashval_t\n+java_treetreehash_hash (k_p)\n+     const void *k_p;\n+{\n+  struct treetreehash_entry *k = (struct treetreehash_entry *) k_p;\n+  return JAVA_TREEHASHHASH_H (k->key);\n+}\n+\n+static int\n+java_treetreehash_compare (k1_p, k2_p)\n+     const void * k1_p;\n+     const void * k2_p;\n+{\n+  struct treetreehash_entry * k1 = (struct treetreehash_entry *) k1_p;\n+  tree k2 = (tree) k2_p;\n+  return (k1->key == k2);\n+}\n+\n+tree \n+java_treetreehash_find (ht, t)\n+     htab_t ht;\n+     tree t;\n+{\n+  struct treetreehash_entry *e;\n+  hashval_t hv = JAVA_TREEHASHHASH_H (t);\n+  e = (struct treetreehash_entry *) htab_find_with_hash (ht, t, hv);\n+  if (e == NULL)\n+    return NULL;\n+  else\n+    return e->value;\n+}\n+\n+tree *\n+java_treetreehash_new (ht, t)\n+     htab_t ht;\n+     tree t;\n+{\n+  PTR *e;\n+  struct treetreehash_entry *tthe;\n+  hashval_t hv = JAVA_TREEHASHHASH_H (t);\n+\n+  e = htab_find_slot_with_hash (ht, t, hv, INSERT);\n+  if (*e == NULL)\n+    {\n+      tthe = (*ht->alloc_f) (1, sizeof (*tthe));\n+      tthe->key = t;\n+      *e = (PTR) tthe;\n+    }\n+  else\n+    tthe = (struct treetreehash_entry *) *e;\n+  return &tthe->value;\n+}\n+\n+htab_t\n+java_treetreehash_create (size, gc)\n+     size_t size;\n+     int gc;\n+{\n+  if (gc)\n+    return htab_create_ggc (size, java_treetreehash_hash,\n+\t\t\t    java_treetreehash_compare, NULL);\n+  else\n+    return htab_create_alloc (size, java_treetreehash_hash,\n+\t\t\t      java_treetreehash_compare, free, xcalloc, free);\n+}\n+\n+#include \"gt-java-class.h\""}, {"sha": "d4511b5c5546f8614ad869361bbf6054fc0f567d", "filename": "gcc/java/config-lang.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fjava%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fjava%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fconfig-lang.in?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -36,6 +36,8 @@ compilers=\"jc1\\$(exeext) jvgenmain\\$(exeext)\"\n \n stagestuff=\"jc1\\$(exeext) gcj\\$(exeext) jvgenmain\\$(exeext) gcjh\\$(exeext) jv-scan\\$(exeext) jcf-dump\\$(exeext)\"\n \n+gtfiles=\"\\$(srcdir)/java/java-tree.h \\$(srcdir)/java/builtins.c \\$(srcdir)/java/class.c \\$(srcdir)/java/constants.c \\$(srcdir)/java/decl.c \\$(srcdir)/java/expr.c \\$(srcdir)/java/jcf-parse.c \\$(srcdir)/java/jcf-write.c \\$(srcdir)/java/lang.c \\$(srcdir)/java/mangle.c \\$(srcdir)/java/parse.y\"\n+\n target_libs=${libgcj_saved}\n lang_dirs=\"zlib fastjar\"\n #build_by_default=no"}, {"sha": "e3642d5d67dfa01aedf77eb527bf7c1361676de6", "filename": "gcc/java/constants.c", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fjava%2Fconstants.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fjava%2Fconstants.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fconstants.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -326,20 +326,12 @@ write_constant_pool (cpool, buffer, length)\n \n CPool *outgoing_cpool;\n \n+static GTY(()) tree tag_nodes[13];\n static tree\n get_tag_node (tag)\n      int tag;\n {\n   /* A Cache for build_int_2 (CONSTANT_XXX, 0). */\n-  static tree tag_nodes[13];\n-  static int initialized_p;\n-\n-  /* Register the TAG_NODES with the garbage collector.  */\n-  if (!initialized_p)\n-    {\n-      ggc_add_tree_root (tag_nodes, 13);\n-      initialized_p = 1;\n-    }\n \n   if (tag_nodes[tag] == NULL_TREE)\n     tag_nodes[tag] = build_int_2 (tag, 0);\n@@ -492,3 +484,5 @@ build_constants_constructor ()\n   FINISH_RECORD_CONSTRUCTOR (cons);\n   return cons;\n }\n+\n+#include \"gt-java-constants.h\""}, {"sha": "1b883caec361fdd1a6f6af2da6794c194b206183", "filename": "gcc/java/decl.c", "status": "modified", "additions": 4, "deletions": 72, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -66,12 +66,12 @@ extern int always_initialize_class_p;\n    DECL_LOCAL_SLOT_CHAIN; the index finds the TREE_VEC element, and then\n    we search the chain for a decl with a matching TREE_TYPE. */\n \n-tree decl_map;\n+static GTY(()) tree decl_map;\n \n /* A list of local variables VAR_DECLs for this method that we have seen\n    debug information, but we have not reached their starting (byte) PC yet. */\n \n-static tree pending_local_decls = NULL_TREE;\n+static GTY(()) tree pending_local_decls;\n \n /* Push a local variable or stack slot into the decl_map,\n    and assign it an rtl. */\n@@ -908,11 +908,6 @@ java_init_decl_processing ()\n \n   init_jcf_parse ();\n \n-  /* Register nodes with the garbage collector.  */\n-  ggc_add_tree_root (java_global_trees, ARRAY_SIZE (java_global_trees));\n-  ggc_add_tree_root (&decl_map, 1);\n-  ggc_add_tree_root (&pending_local_decls, 1);\n-\n   initialize_builtins ();\n }\n \n@@ -1553,10 +1548,7 @@ java_dup_lang_specific_decl (node)\n   if (!DECL_LANG_SPECIFIC (node))\n     return;\n \n-  if (TREE_CODE (node) == VAR_DECL)\n-    lang_decl_size = sizeof (struct lang_decl_var);\n-  else\n-    lang_decl_size = sizeof (struct lang_decl);\n+  lang_decl_size = sizeof (struct lang_decl);\n   x = (struct lang_decl *) ggc_alloc (lang_decl_size);\n   memcpy (x, DECL_LANG_SPECIFIC (node), lang_decl_size);\n   DECL_LANG_SPECIFIC (node) = x;\n@@ -1829,64 +1821,4 @@ end_java_method ()\n   current_function_decl = NULL_TREE;\n }\n \n-/* Mark language-specific parts of T for garbage-collection.  */\n-\n-void\n-java_mark_tree (t)\n-     tree t;\n-{\n-  if (TREE_CODE (t) == IDENTIFIER_NODE)\n-    {\n-      struct lang_identifier *li = (struct lang_identifier *) t;\n-      ggc_mark_tree (li->global_value);\n-      ggc_mark_tree (li->local_value);\n-      ggc_mark_tree (li->utf8_ref);\n-    }\n-  else if (TREE_CODE (t) == VAR_DECL\n-\t   || TREE_CODE (t) == PARM_DECL\n-\t   || TREE_CODE (t) == FIELD_DECL)\n-    {\n-      struct lang_decl_var *ldv = \n-\t((struct lang_decl_var *) DECL_LANG_SPECIFIC (t));\n-      if (ldv)\n-\t{\n-\t  ggc_mark (ldv);\n-\t  ggc_mark_tree (ldv->slot_chain);\n-\t  ggc_mark_tree (ldv->am);\n-\t  ggc_mark_tree (ldv->wfl);\n-\t}\n-    }\n-  else if (TREE_CODE (t) == FUNCTION_DECL)\n-    {\n-      struct lang_decl *ld = DECL_LANG_SPECIFIC (t);\n-      \n-      if (ld)\n-\t{\n-\t  ggc_mark (ld);\n-\t  ggc_mark_tree (ld->wfl);\n-\t  ggc_mark_tree (ld->throws_list);\n-\t  ggc_mark_tree (ld->function_decl_body);\n-\t  ggc_mark_tree (ld->called_constructor);\n-\t  ggc_mark_tree (ld->inner_access);\n-\t  ggc_mark_tree_hash_table (&ld->init_test_table);\n-\t  ggc_mark_tree_hash_table (&ld->ict);\n-\t  ggc_mark_tree (ld->smic);\n-\t}\n-    }\n-  else if (TYPE_P (t))\n-    {\n-      struct lang_type *lt = TYPE_LANG_SPECIFIC (t);\n-      \n-      if (lt)\n-\t{\n-\t  ggc_mark (lt);\n-\t  ggc_mark_tree (lt->signature);\n-\t  ggc_mark_tree (lt->cpool_data_ref);\n-\t  ggc_mark_tree (lt->finit_stmt_list);\n-\t  ggc_mark_tree (lt->clinit_stmt_list);\n-\t  ggc_mark_tree (lt->ii_block);\n-\t  ggc_mark_tree (lt->dot_class);\n-\t  ggc_mark_tree (lt->package_list);\n-\t}\n-    }\n-}\n+#include \"gt-java-decl.h\""}, {"sha": "34be4d52e646acff6899f7a1c51b65a0a9ce2932", "filename": "gcc/java/expr.c", "status": "modified", "additions": 35, "deletions": 40, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -81,15 +81,15 @@ static tree build_java_throw_out_of_bounds_exception PARAMS ((tree));\n static tree build_java_check_indexed_type PARAMS ((tree, tree)); \n static tree case_identity PARAMS ((tree, tree)); \n static unsigned char peek_opcode_at_pc PARAMS ((struct JCF *, int, int));\n-static bool emit_init_test_initialization PARAMS ((struct hash_entry *,\n-\t\t\t\t\t\t   PTR ptr));\n+static int emit_init_test_initialization PARAMS ((void **entry,\n+\t\t\t\t\t\t  void * ptr));\n static int get_offset_table_index PARAMS ((tree));\n \n-static tree operand_type[59];\n+static GTY(()) tree operand_type[59];\n extern struct obstack permanent_obstack;\n \n-static tree methods_ident = NULL_TREE;\n-static tree ncode_ident = NULL_TREE;\n+static GTY(()) tree methods_ident;\n+static GTY(()) tree ncode_ident;\n tree dtable_ident = NULL_TREE;\n \n /* Set to non-zero value in order to emit class initilization code\n@@ -123,10 +123,10 @@ int always_initialize_class_p;\n    So dup cannot just add an extra element to the quick_stack, but iadd can.\n */\n \n-static tree quick_stack = NULL_TREE;\n+static GTY(()) tree quick_stack;\n \n /* A free-list of unused permamnet TREE_LIST nodes. */\n-static tree tree_list_free_list = NULL_TREE;\n+static GTY((deletable (\"\"))) tree tree_list_free_list;\n \n /* The stack pointer of the Java virtual machine.\n    This does include the size of the quick_stack. */\n@@ -144,11 +144,6 @@ init_expr_processing()\n   operand_type[23] = operand_type[56] = float_type_node;\n   operand_type[24] = operand_type[57] = double_type_node;\n   operand_type[25] = operand_type[58] = ptr_type_node;\n-  ggc_add_tree_root (operand_type, 59);\n-  ggc_add_tree_root (&methods_ident, 1);\n-  ggc_add_tree_root (&ncode_ident, 1);\n-  ggc_add_tree_root (&quick_stack, 1);\n-  ggc_add_tree_root (&tree_list_free_list, 1);\n }\n \n tree\n@@ -1756,7 +1751,6 @@ build_class_init (clas, expr)\n      tree clas, expr;\n {\n   tree init;\n-  struct init_test_hash_entry *ite;\n   if (inherits_from_p (current_class, clas))\n     return expr;\n \n@@ -1770,25 +1764,24 @@ build_class_init (clas, expr)\n     }\n   else\n     {\n-      ite = (struct init_test_hash_entry *)\n-\thash_lookup (&DECL_FUNCTION_INIT_TEST_TABLE (current_function_decl),\n-\t\t     (const hash_table_key) clas,\n-\t\t     TRUE, NULL);\n-      \n-      if (ite->init_test_decl == 0)\n+      tree *init_test_decl;\n+      init_test_decl = java_treetreehash_new\n+\t(DECL_FUNCTION_INIT_TEST_TABLE (current_function_decl), clas);\n+\n+      if (*init_test_decl == NULL)\n \t{\n \t  /* Build a declaration and mark it as a flag used to track\n \t     static class initializations. */\n-\t  ite->init_test_decl = build_decl (VAR_DECL, NULL_TREE,\n-\t\t\t\t\t    boolean_type_node);\n-\t  MAYBE_CREATE_VAR_LANG_DECL_SPECIFIC (ite->init_test_decl);\n-\t  LOCAL_CLASS_INITIALIZATION_FLAG (ite->init_test_decl) = 1;\n-\t  DECL_CONTEXT (ite->init_test_decl) = current_function_decl;\n-\t  DECL_FUNCTION_INIT_TEST_CLASS (ite->init_test_decl) = clas;\n+\t  *init_test_decl = build_decl (VAR_DECL, NULL_TREE,\n+\t\t\t\t       boolean_type_node);\n+\t  MAYBE_CREATE_VAR_LANG_DECL_SPECIFIC (*init_test_decl);\n+\t  LOCAL_CLASS_INITIALIZATION_FLAG (*init_test_decl) = 1;\n+\t  DECL_CONTEXT (*init_test_decl) = current_function_decl;\n+\t  DECL_FUNCTION_INIT_TEST_CLASS (*init_test_decl) = clas;\n \t  /* Tell the check-init code to ignore this decl when not\n              optimizing class initialization. */\n \t  if (!STATIC_CLASS_INIT_OPT_P ())\n-\t    DECL_BIT_INDEX(ite->init_test_decl) = -1;\n+\t    DECL_BIT_INDEX(*init_test_decl) = -1;\n \t}\n \n       init = build (CALL_EXPR, void_type_node,\n@@ -1798,12 +1791,12 @@ build_class_init (clas, expr)\n       TREE_SIDE_EFFECTS (init) = 1;\n       init = build (COND_EXPR, void_type_node,\n \t\t    build (EQ_EXPR, boolean_type_node, \n-\t\t\t   ite->init_test_decl, boolean_false_node),\n+\t\t\t   *init_test_decl, boolean_false_node),\n \t\t    init, integer_zero_node);\n       TREE_SIDE_EFFECTS (init) = 1;\n       init = build (COMPOUND_EXPR, TREE_TYPE (expr), init, \n \t\t    build (MODIFY_EXPR, boolean_type_node,\n-\t\t\t   ite->init_test_decl, boolean_true_node));\n+\t\t\t   *init_test_decl, boolean_true_node));\n       TREE_SIDE_EFFECTS (init) = 1;\n     }\n \n@@ -1976,11 +1969,11 @@ build_invokevirtual (dtable, method)\n   return func;\n }\n \n+static GTY(()) tree class_ident;\n tree\n build_invokeinterface (dtable, method)\n      tree dtable, method;\n {\n-  static tree class_ident = NULL_TREE;\n   tree lookup_arg;\n   tree interface;\n   tree idx;\n@@ -1995,7 +1988,6 @@ build_invokeinterface (dtable, method)\n   if (class_ident == NULL_TREE)\n     {\n       class_ident = get_identifier (\"class\");\n-      ggc_add_tree_root (&class_ident, 1);\n     }\n \n   dtable = build_java_indirect_ref (dtable_type, dtable, flag_check_references);\n@@ -2588,8 +2580,8 @@ java_expand_expr (exp, target, tmode, modifier)\n \t  if (! always_initialize_class_p \n \t      && current_function_decl\n \t      && found_class_initialization_flag)\n-\t    hash_traverse \n-\t      (&DECL_FUNCTION_INIT_TEST_TABLE (current_function_decl),\n+\t    htab_traverse \n+\t      (DECL_FUNCTION_INIT_TEST_TABLE (current_function_decl),\n \t       emit_init_test_initialization, NULL);\n \n \t  /* Avoid deep recursion for long block.  */\n@@ -3458,19 +3450,19 @@ force_evaluation_order (node)\n /* Called for every element in DECL_FUNCTION_INIT_TEST_TABLE of a\n    method in order to emit initialization code for each test flag.  */\n \n-static bool\n-emit_init_test_initialization (entry, key)\n-  struct hash_entry *entry;\n-  hash_table_key key ATTRIBUTE_UNUSED;\n+static int\n+emit_init_test_initialization (entry, x)\n+     void * * entry;\n+     void * x ATTRIBUTE_UNUSED;\n {\n-  struct init_test_hash_entry *ite = (struct init_test_hash_entry *) entry;\n-  tree klass = build_class_ref ((tree) entry->key);\n+  struct treetreehash_entry *ite = (struct treetreehash_entry *) *entry;\n+  tree klass = build_class_ref (ite->key);\n   tree rhs;\n \n   /* If the DECL_INITIAL of the test flag is set to true, it\n      means that the class is already initialized the time it\n      is in use. */\n-  if (DECL_INITIAL (ite->init_test_decl) == boolean_true_node)\n+  if (DECL_INITIAL (ite->value) == boolean_true_node)\n     rhs = boolean_true_node;\n   /* Otherwise, we initialize the class init check variable by looking\n      at the `state' field of the class to see if it is already\n@@ -3485,6 +3477,9 @@ emit_init_test_initialization (entry, key)\n \t\t build_int_2 (JV_STATE_DONE, 0));\n \n   expand_expr_stmt (build (MODIFY_EXPR, boolean_type_node, \n-\t\t\t   ite->init_test_decl, rhs));\n+\t\t\t   ite->value, rhs));\n   return true;\n }\n+\n+#include \"gt-java-expr.h\"\n+"}, {"sha": "71a63887ce7be4b6d3ae8474363fa786622bc0b7", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 90, "deletions": 55, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -26,7 +26,7 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n \n /* Hacked by Per Bothner <bothner@cygnus.com> February 1996. */\n \n-#include \"hash.h\"\n+#include \"hashtab.h\"\n \n /* Java language-specific tree codes.  */\n #define DEFTREECODE(SYM, NAME, TYPE, LENGTH) SYM,\n@@ -404,7 +404,7 @@ enum java_tree_index\n   JTI_MAX\n };\n \n-extern tree java_global_trees[JTI_MAX];\n+extern GTY(()) tree java_global_trees[JTI_MAX];\n \n /* \"Promoted types\" that are used for primitive types smaller\n    than int.  We could use int_type_node, but then we would lose\n@@ -679,16 +679,27 @@ extern struct CPool *outgoing_cpool;\n \n extern const char *cyclic_inheritance_report;\n \n-struct lang_identifier\n+struct lang_identifier GTY(())\n {\n   struct tree_identifier ignore;\n-  tree global_value, local_value;\n+  tree global_value;\n+  tree local_value;\n \n   /* If non-NULL:  An ADDR_REF to a VAR_DECL that contains\n    * the Utf8Const representation of the identifier.  */\n   tree utf8_ref;\n };\n \n+/* The resulting tree type.  */\n+union lang_tree_node \n+  GTY((desc (\"TREE_CODE (&%h.generic) == IDENTIFIER_NODE\")))\n+{\n+  union tree_node GTY ((tag (\"0\"), \n+\t\t\tdesc (\"tree_node_structure (&%h)\"))) \n+    generic;\n+  struct lang_identifier GTY ((tag (\"1\"))) identifier;\n+};\n+\n /* Macros for access to language-specific slots in an identifier.  */\n /* Unless specified, each of these slots contains a DECL node or null.  */\n \n@@ -728,41 +739,43 @@ struct lang_identifier\n /* For a FUNCTION_DECL, if we are compiling a .class file, then this is\n    the position in the .class file of the method code.\n    Specifically, this is the code itself, not the code attribute. */\n-#define DECL_CODE_OFFSET(DECL) (DECL_LANG_SPECIFIC(DECL)->code_offset)\n+#define DECL_CODE_OFFSET(DECL) (DECL_LANG_SPECIFIC(DECL)->u.f.code_offset)\n /* Similarly, the length of the bytecode. */\n-#define DECL_CODE_LENGTH(DECL) (DECL_LANG_SPECIFIC(DECL)->code_length)\n+#define DECL_CODE_LENGTH(DECL) (DECL_LANG_SPECIFIC(DECL)->u.f.code_length)\n /* Similarly, the position of the LineNumberTable attribute. */\n #define DECL_LINENUMBERS_OFFSET(DECL) \\\n-  (DECL_LANG_SPECIFIC(DECL)->linenumbers_offset)\n+  (DECL_LANG_SPECIFIC(DECL)->u.f.linenumbers_offset)\n /* Similarly, the position of the LocalVariableTable attribute\n    (following the standard attribute header). */\n #define DECL_LOCALVARIABLES_OFFSET(DECL) \\\n-  (DECL_LANG_SPECIFIC(DECL)->localvariables_offset)\n+  (DECL_LANG_SPECIFIC(DECL)->u.f.localvariables_offset)\n \n-#define DECL_MAX_LOCALS(DECL) (DECL_LANG_SPECIFIC(DECL)->max_locals)\n-#define DECL_MAX_STACK(DECL) (DECL_LANG_SPECIFIC(DECL)->max_stack)\n+#define DECL_MAX_LOCALS(DECL) (DECL_LANG_SPECIFIC(DECL)->u.f.max_locals)\n+#define DECL_MAX_STACK(DECL) (DECL_LANG_SPECIFIC(DECL)->u.f.max_stack)\n /* Number of local variable slots needed for the arguments of this function. */\n-#define DECL_ARG_SLOT_COUNT(DECL) (DECL_LANG_SPECIFIC(DECL)->arg_slot_count)\n+#define DECL_ARG_SLOT_COUNT(DECL) \\\n+  (DECL_LANG_SPECIFIC(DECL)->u.f.arg_slot_count)\n /* Information on declaration location */\n-#define DECL_FUNCTION_WFL(DECL)  (DECL_LANG_SPECIFIC(DECL)->wfl)\n+#define DECL_FUNCTION_WFL(DECL)  (DECL_LANG_SPECIFIC(DECL)->u.f.wfl)\n /* List of checked thrown exceptions, as specified with the `throws'\n    keyword */\n-#define DECL_FUNCTION_THROWS(DECL) (DECL_LANG_SPECIFIC(DECL)->throws_list)\n+#define DECL_FUNCTION_THROWS(DECL) (DECL_LANG_SPECIFIC(DECL)->u.f.throws_list)\n /* List of other constructors of the same class that this constructor\n    calls */\n #define DECL_CONSTRUCTOR_CALLS(DECL) \\\n-  (DECL_LANG_SPECIFIC(DECL)->called_constructor)\n+  (DECL_LANG_SPECIFIC(DECL)->u.f.called_constructor)\n /* When the function is an access function, the DECL it was trying to\n    access */\n #define DECL_FUNCTION_ACCESS_DECL(DECL) \\\n-  (DECL_LANG_SPECIFIC(DECL)->called_constructor)\n+  (DECL_LANG_SPECIFIC(DECL)->u.f.called_constructor)\n /* The identifier of the access method used to invoke this method from\n    an inner class.  */\n #define DECL_FUNCTION_INNER_ACCESS(DECL) \\\n-  (DECL_LANG_SPECIFIC(DECL)->inner_access)\n+  (DECL_LANG_SPECIFIC(DECL)->u.f.inner_access)\n /* Pointer to the function's current's COMPOUND_EXPR tree (while\n    completing its body) or the function's block */\n-#define DECL_FUNCTION_BODY(DECL) (DECL_LANG_SPECIFIC(DECL)->function_decl_body)\n+#define DECL_FUNCTION_BODY(DECL) \\\n+  (DECL_LANG_SPECIFIC(DECL)->u.f.function_decl_body)\n /* How specific the function is (for method selection - Java source\n    code front-end */\n #define DECL_SPECIFIC_COUNT(DECL) DECL_ARG_SLOT_COUNT(DECL)\n@@ -771,31 +784,33 @@ struct lang_identifier\n    boolean decls.  The variables are intended to be TRUE when the\n    class has been initialized in this function, and FALSE otherwise.  */\n #define DECL_FUNCTION_INIT_TEST_TABLE(DECL) \\\n-  (DECL_LANG_SPECIFIC(DECL)->init_test_table)\n+  (DECL_LANG_SPECIFIC(DECL)->u.f.init_test_table)\n /* If LOCAL_CLASS_INITIALIZATION_FLAG_P(decl), give class it initializes. */\n #define DECL_FUNCTION_INIT_TEST_CLASS(DECL) \\\n-  (((struct lang_decl_var*)DECL_LANG_SPECIFIC(DECL))->slot_chain)\n+  (DECL_LANG_SPECIFIC(DECL)->u.v.slot_chain)\n /* For each static function decl, itc contains a hash table whose\n    entries are keyed on class named that are definitively initialized\n    in DECL.  */\n #define DECL_FUNCTION_INITIALIZED_CLASS_TABLE(DECL) \\\n-  (DECL_LANG_SPECIFIC(DECL)->ict)\n+  (DECL_LANG_SPECIFIC(DECL)->u.f.ict)\n /* A list of all the static method calls in the method DECL (if optimizing).\n    Actually each TREE_VALUE points to a COMPONT_EXPR that wraps the\n    invoation so we can later patch it. */\n #define DECL_FUNCTION_STATIC_METHOD_INVOCATION_COMPOUND(DECL) \\\n-  (DECL_LANG_SPECIFIC(DECL)->smic)\n+  (DECL_LANG_SPECIFIC(DECL)->u.f.smic)\n /* The Number of Artificial Parameters (NAP) DECL contains. this$<n>\n    is excluded, because sometimes created as a parameter before the\n    function decl exists. */\n-#define DECL_FUNCTION_NAP(DECL) (DECL_LANG_SPECIFIC(DECL)->nap)\n+#define DECL_FUNCTION_NAP(DECL) (DECL_LANG_SPECIFIC(DECL)->u.f.nap)\n /* True if DECL is a synthetic ctor.  */\n #define DECL_FUNCTION_SYNTHETIC_CTOR(DECL) \\\n-  (DECL_LANG_SPECIFIC(DECL)->synthetic_ctor)\n-#define DECL_FIXED_CONSTRUCTOR_P(DECL) (DECL_LANG_SPECIFIC(DECL)->fixed_ctor)\n+  (DECL_LANG_SPECIFIC(DECL)->u.f.synthetic_ctor)\n+#define DECL_FIXED_CONSTRUCTOR_P(DECL) \\\n+  (DECL_LANG_SPECIFIC(DECL)->u.f.fixed_ctor)\n \n /* A constructor that calls this. */\n-#define DECL_INIT_CALLS_THIS(DECL) (DECL_LANG_SPECIFIC(DECL)->init_calls_this)\n+#define DECL_INIT_CALLS_THIS(DECL) \\\n+  (DECL_LANG_SPECIFIC(DECL)->u.f.init_calls_this)\n \n /* True when DECL aliases an outer context local variable.  */\n #define FIELD_LOCAL_ALIAS(DECL) DECL_LANG_FLAG_6 (DECL)\n@@ -858,31 +873,31 @@ struct lang_identifier\n \n /* The slot number for this local variable. */\n #define DECL_LOCAL_SLOT_NUMBER(NODE) \\\n-  (((struct lang_decl_var*)DECL_LANG_SPECIFIC(NODE))->slot_number)\n+  (DECL_LANG_SPECIFIC(NODE)->u.v.slot_number)\n /* The start (bytecode) pc for the valid range of this local variable. */\n #define DECL_LOCAL_START_PC(NODE) \\\n-  (((struct lang_decl_var*)DECL_LANG_SPECIFIC(NODE))->start_pc)\n+  (DECL_LANG_SPECIFIC(NODE)->u.v.start_pc)\n /* The end (bytecode) pc for the valid range of this local variable. */\n #define DECL_LOCAL_END_PC(NODE) \\\n-  (((struct lang_decl_var*)DECL_LANG_SPECIFIC(NODE))->end_pc)\n+  (DECL_LANG_SPECIFIC(NODE)->u.v.end_pc)\n /* For a VAR_DECLor PARM_DECL, used to chain decls with the same\n    slot_number in decl_map. */\n #define DECL_LOCAL_SLOT_CHAIN(NODE) \\\n-  (((struct lang_decl_var*)DECL_LANG_SPECIFIC(NODE))->slot_chain)\n+  (DECL_LANG_SPECIFIC(NODE)->u.v.slot_chain)\n /* For a FIELD_DECL, holds the name of the access method. Used to\n    read/write the content of the field from an inner class.  */\n #define FIELD_INNER_ACCESS(DECL) \\\n-  (((struct lang_decl_var*)DECL_LANG_SPECIFIC(DECL))->am)\n+  (DECL_LANG_SPECIFIC(DECL)->u.v.am)\n /* Safely tests whether FIELD_INNER_ACCESS exists or not. */\n #define FIELD_INNER_ACCESS_P(DECL) \\\n   DECL_LANG_SPECIFIC (DECL) && FIELD_INNER_ACCESS (DECL)\n /* True if a final variable was initialized upon its declaration,\n    or (if a field) in an initializer.  Set after definite assignment. */\n #define DECL_FIELD_FINAL_IUD(NODE) \\\n-  (((struct lang_decl_var*)DECL_LANG_SPECIFIC(NODE))->final_iud)\n+  (DECL_LANG_SPECIFIC(NODE)->u.v.final_iud)\n /* The original WFL of a final variable. */\n #define DECL_FIELD_FINAL_WFL(NODE) \\\n-  (((struct lang_decl_var*)DECL_LANG_SPECIFIC(NODE))->wfl)\n+  (DECL_LANG_SPECIFIC(NODE)->u.v.wfl)\n /* True if NODE is a local variable final. */\n #define LOCAL_FINAL_P(NODE) (DECL_LANG_SPECIFIC (NODE) && DECL_FINAL (NODE))\n /* True if NODE is a final field. */\n@@ -893,7 +908,7 @@ struct lang_identifier\n /* True if NODE is a class initialization flag. This macro accesses\n    the flag to read or set it.  */\n #define LOCAL_CLASS_INITIALIZATION_FLAG(NODE) \\\n-    (((struct lang_decl_var*)DECL_LANG_SPECIFIC(NODE))->cif)\n+    (DECL_LANG_SPECIFIC(NODE)->u.v.cif)\n /* True if NODE is a class initialization flag. */\n #define LOCAL_CLASS_INITIALIZATION_FLAG_P(NODE) \\\n     (DECL_LANG_SPECIFIC (NODE) && LOCAL_CLASS_INITIALIZATION_FLAG(NODE))\n@@ -903,7 +918,8 @@ struct lang_identifier\n     {\t\t\t\t\t\t\t\t\\\n       DECL_LANG_SPECIFIC ((T))\t\t\t\t\t\\\n \t= ((struct lang_decl *)\t\t\t\t\t\\\n-\t   ggc_alloc_cleared (sizeof (struct lang_decl_var)));\t\\\n+\t   ggc_alloc_cleared (sizeof (struct lang_decl)));\t\\\n+      DECL_LANG_SPECIFIC (T)->desc = LANG_DECL_VAR;\t\t\\\n     }\n \n /* A ConstantExpression, after folding and name resolution. */\n@@ -920,23 +936,29 @@ struct lang_identifier\n #define DECL_BIT_INDEX(DECL) (DECL_CHECK (DECL)->decl.pointer_alias_set)\n \n /* DECL_LANG_SPECIFIC for FUNCTION_DECLs. */\n-struct lang_decl\n+struct lang_decl_func GTY(())\n {\n   /*  tree chain; not yet used. */\n   long code_offset;\n   int code_length;\n   long linenumbers_offset;\n   long localvariables_offset;\n   int arg_slots;\n-  int max_locals, max_stack, arg_slot_count;\n+  int max_locals;\n+  int max_stack;\n+  int arg_slot_count;\n   tree wfl;\t\t\t/* Information on the original location */\n   tree throws_list;\t\t/* Exception specified by `throws' */\n   tree function_decl_body;\t/* Hold all function's statements */\n   tree called_constructor;\t/* When decl is a constructor, the\n \t\t\t\t   list of other constructor it calls */\n-  struct hash_table init_test_table;\n-\t\t\t\t/* Class initialization test variables  */\n-  struct hash_table ict;\t/* Initialized (static) Class Table */\n+\n+  /* Class initialization test variables  */\n+  htab_t GTY ((param_is (struct treetreehash_entry))) init_test_table;\n+\t\t\t\t\n+  /* Initialized (static) Class Table */\n+  htab_t GTY ((param_is (union tree_node))) ict;\n+\n   tree smic;\t\t\t/* Static method invocation compound */\n   tree inner_access;\t\t/* The identifier of the access method\n \t\t\t\t   used for invocation from inner classes */\n@@ -949,16 +971,19 @@ struct lang_decl\n   unsigned int strictfp : 1;\n };\n \n-/* init_test_table hash table entry structure.  */\n-struct init_test_hash_entry\n+struct treetreehash_entry GTY(())\n {\n-  struct hash_entry root;\n-  tree init_test_decl;\n+  tree key;\n+  tree value;\n };\n \n+extern tree java_treetreehash_find PARAMS ((htab_t, tree));\n+extern tree * java_treetreehash_new PARAMS ((htab_t, tree));\n+extern htab_t java_treetreehash_create PARAMS ((size_t size, int ggc));\n+\n /* DECL_LANG_SPECIFIC for VAR_DECL, PARM_DECL and sometimes FIELD_DECL\n    (access methods on outer class fields) and final fields. */\n-struct lang_decl_var\n+struct lang_decl_var GTY(())\n {\n   int slot_number;\n   int start_pc;\n@@ -970,6 +995,22 @@ struct lang_decl_var\n   unsigned int cif : 1;\t\t/* True: decl is a class initialization flag */\n };\n \n+/* This is what 'lang_decl' really points to.  */\n+\n+enum lang_decl_desc {\n+  LANG_DECL_FUNC,\n+  LANG_DECL_VAR\n+};\n+\n+struct lang_decl GTY(())\n+{\n+  enum lang_decl_desc desc;\n+  union lang_decl_u {\n+    struct lang_decl_func GTY ((tag (\"LANG_DECL_FUNC\"))) f;\n+    struct lang_decl_var GTY ((tag (\"LANG_DECL_VAR\"))) v;\n+  } GTY ((desc (\"%0.desc\"))) u;\n+};\n+\n /* Macro to access fields in `struct lang_type'.  */\n \n #define TYPE_SIGNATURE(T) (TYPE_LANG_SPECIFIC(T)->signature)\n@@ -997,11 +1038,11 @@ struct lang_decl_var\n #define TYPE_PROTECTED_INNER_CLASS(T) (TYPE_LANG_SPECIFIC(T)->poic)\n #define TYPE_STRICTFP(T) (TYPE_LANG_SPECIFIC(T)->strictfp)\n \n-struct lang_type\n+struct lang_type GTY(())\n {\n   tree signature;\n-  struct JCF *jcf;\n-  struct CPool *cpool;\n+  struct JCF * GTY ((skip (\"\"))) jcf;\n+  struct CPool * GTY ((skip (\"\"))) cpool;\n   tree cpool_data_ref;\t\t/* Cached */\n   tree finit_stmt_list;\t\t/* List of statements finit$ will use */\n   tree clinit_stmt_list;\t/* List of statements <clinit> will use  */\n@@ -1038,7 +1079,6 @@ struct lang_type\n #define JCF_u2 unsigned short\n \n extern void java_parse_file PARAMS ((int));\n-extern void java_mark_tree PARAMS ((tree));\n extern bool java_mark_addressable PARAMS ((tree));\n extern tree java_type_for_mode PARAMS ((enum machine_mode, int));\n extern tree java_type_for_size PARAMS ((unsigned int, int));\n@@ -1234,11 +1274,6 @@ extern void safe_layout_class PARAMS ((tree));\n \n extern tree get_boehm_type_descriptor PARAMS ((tree));\n extern bool class_has_finalize_method PARAMS ((tree));\n-extern unsigned long java_hash_hash_tree_node PARAMS ((hash_table_key));\n-extern bool java_hash_compare_tree_node PARAMS ((hash_table_key, \n-\t\t\t\t\t\t    hash_table_key));\n-extern bool attach_initialized_static_class PARAMS ((struct hash_entry *,\n-\t\t\t\t\t\t     PTR));\n extern void java_check_methods PARAMS ((tree));\n extern void init_jcf_parse PARAMS((void));\n extern void init_src_parse PARAMS((void));\n@@ -1269,10 +1304,10 @@ struct rtx_def * java_expand_expr PARAMS ((tree, rtx, enum machine_mode,\n #define METHOD_STATIC(DECL) DECL_LANG_FLAG_2 (DECL)\n #define METHOD_FINAL(DECL) DECL_FINAL (DECL)\n #define METHOD_SYNCHRONIZED(DECL) DECL_LANG_FLAG_4 (DECL)\n-#define METHOD_NATIVE(DECL) (DECL_LANG_SPECIFIC(DECL)->native)\n+#define METHOD_NATIVE(DECL) (DECL_LANG_SPECIFIC(DECL)->u.f.native)\n #define METHOD_ABSTRACT(DECL) DECL_LANG_FLAG_5 (DECL)\n #define METHOD_TRANSIENT(DECL) DECL_LANG_FLAG_6 (DECL)\n-#define METHOD_STRICTFP(DECL) (DECL_LANG_SPECIFIC (DECL)->strictfp)\n+#define METHOD_STRICTFP(DECL) (DECL_LANG_SPECIFIC (DECL)->u.f.strictfp)\n \n #define JAVA_FILE_P(NODE) TREE_LANG_FLAG_2 (NODE)\n #define CLASS_FILE_P(NODE) TREE_LANG_FLAG_3 (NODE)"}, {"sha": "af9022b9ec6b6118c0a45f634e72eeebe161494b", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -74,7 +74,7 @@ extern struct obstack permanent_obstack;\n    before static field references.  */\n extern int always_initialize_class_p;\n \n-static tree parse_roots[3] = { NULL_TREE, NULL_TREE, NULL_TREE };\n+static GTY(()) tree parse_roots[3];\n \n /* The FIELD_DECL for the current field.  */\n #define current_field parse_roots[0]\n@@ -1270,9 +1270,9 @@ void\n init_jcf_parse ()\n {\n   /* Register roots with the garbage collector.  */\n-  ggc_add_tree_root (parse_roots, ARRAY_SIZE (parse_roots));\n-\n   ggc_add_root (&current_jcf, 1, sizeof (JCF), (void (*)(void *))ggc_mark_jcf);\n \n   init_src_parse ();\n }\n+\n+#include \"gt-java-jcf-parse.h\""}, {"sha": "7ddca448448fdec0af86c5f2ff69d234c9376a77", "filename": "gcc/java/jcf-write.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fjava%2Fjcf-write.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fjava%2Fjcf-write.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-write.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -2853,6 +2853,7 @@ release_jcf_state (state)\n    in the .class file representation.  The list can be written to a\n    .class file using write_chunks.  Allocate chunks from obstack WORK. */\n \n+static GTY(()) tree SourceFile_node;\n static struct chunk *\n generate_classfile (clas, state)\n      tree clas;\n@@ -2866,7 +2867,6 @@ generate_classfile (clas, state)\n   int fields_count = 0;\n   char *methods_count_ptr;\n   int methods_count = 0;\n-  static tree SourceFile_node = NULL_TREE;\n   tree part;\n   int total_supers\n     = clas == object_type_node ? 0\n@@ -3154,7 +3154,6 @@ generate_classfile (clas, state)\n   if (SourceFile_node == NULL_TREE) \n     {\n       SourceFile_node = get_identifier (\"SourceFile\");\n-      ggc_add_tree_root (&SourceFile_node, 1);\n     }\n \n   i = find_utf8_constant (&state->cpool, SourceFile_node);\n@@ -3174,18 +3173,17 @@ generate_classfile (clas, state)\n   return state->first;\n }\n \n+static GTY(()) tree Synthetic_node;\n static unsigned char *\n append_synthetic_attribute (state)\n      struct jcf_partial *state;\n {\n-  static tree Synthetic_node = NULL_TREE;\n   unsigned char *ptr = append_chunk (NULL, 6, state);\n   int i;\n \n   if (Synthetic_node == NULL_TREE)\n     {\n       Synthetic_node = get_identifier (\"Synthetic\");\n-      ggc_add_tree_root (&Synthetic_node, 1);\n     }\n   i = find_utf8_constant (&state->cpool, Synthetic_node);\n   PUT2 (i);\t\t/* Attribute string index */\n@@ -3212,12 +3210,12 @@ append_gcj_attribute (state, class)\n   PUT4 (0);\t\t\t/* Attribute length */\n }\n \n+static tree InnerClasses_node;\n static void\n append_innerclasses_attribute (state, class)\n      struct jcf_partial *state;\n      tree class;\n {\n-  static tree InnerClasses_node = NULL_TREE;\n   tree orig_decl = TYPE_NAME (class);\n   tree current, decl;\n   int length = 0, i;\n@@ -3231,7 +3229,6 @@ append_innerclasses_attribute (state, class)\n   if (InnerClasses_node == NULL_TREE) \n     {\n       InnerClasses_node = get_identifier (\"InnerClasses\");\n-      ggc_add_tree_root (&InnerClasses_node, 1);\n     }\n   i = find_utf8_constant (&state->cpool, InnerClasses_node);\n   PUT2 (i);\n@@ -3406,3 +3403,5 @@ write_classfile (clas)\n    string concatenation\n    synchronized statement\n    */\n+\n+#include \"gt-java-jcf-write.h\""}, {"sha": "a0f823f75b7ac363011703ca80ef7e6ae82024c3", "filename": "gcc/java/lang.c", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fjava%2Flang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fjava%2Flang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -213,6 +213,11 @@ static int dependency_tracking = 0;\n #define DEPEND_TARGET_SET 4\n #define DEPEND_FILE_ALREADY_SET 8\n \n+struct language_function GTY(())\n+{\n+  int unused;\n+};\n+\n #undef LANG_HOOKS_NAME\n #define LANG_HOOKS_NAME \"GNU Java\"\n #undef LANG_HOOKS_INIT\n@@ -225,8 +230,6 @@ static int dependency_tracking = 0;\n #define LANG_HOOKS_DECODE_OPTION java_decode_option\n #undef LANG_HOOKS_PARSE_FILE\n #define LANG_HOOKS_PARSE_FILE java_parse_file\n-#undef LANG_HOOKS_MARK_TREE\n-#define LANG_HOOKS_MARK_TREE java_mark_tree\n #undef LANG_HOOKS_MARK_ADDRESSABLE\n #define LANG_HOOKS_MARK_ADDRESSABLE java_mark_addressable\n #undef LANG_HOOKS_EXPAND_EXPR\n@@ -694,24 +697,13 @@ lang_printable_name_wls (decl, v)\n /* Print on stderr the current class and method context.  This function\n    is the value of the hook print_error_function. */\n \n+static GTY(()) tree last_error_function_context;\n+static GTY(()) tree last_error_function;\n static void\n java_print_error_function (context, file)\n      diagnostic_context *context __attribute__((__unused__));\n      const char *file;\n {\n-  static tree last_error_function_context = NULL_TREE;\n-  static tree last_error_function = NULL;\n-  static int initialized_p;\n-\n-  /* Register LAST_ERROR_FUNCTION_CONTEXT and LAST_ERROR_FUNCTION with\n-     the garbage collector.  */\n-  if (!initialized_p)\n-    {\n-      ggc_add_tree_root (&last_error_function_context, 1);\n-      ggc_add_tree_root (&last_error_function, 1);\n-      initialized_p = 1;\n-    }\n-\n   /* Don't print error messages with bogus function prototypes.  */\n   if (inhibit_error_function_printing)\n     return;\n@@ -770,3 +762,5 @@ java_init_options ()\n   /* In Java floating point operations never trap.  */\n   flag_trapping_math = 0;\n }\n+\n+#include \"gt-java-lang.h\""}, {"sha": "ef70ff9d2215bf3ee21121b8121b6d6ac12ddaa9", "filename": "gcc/java/mangle.c", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fjava%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fjava%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fmangle.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -245,7 +245,7 @@ mangle_type (type)\n    COMPRESSION_NEXT is the index to the location of the next insertion\n    of an element.  */\n \n-static tree compression_table;\n+static GTY(()) tree compression_table;\n static int  compression_next;\n \n /* Find a POINTER_TYPE in the compression table. Use a special\n@@ -431,12 +431,12 @@ mangle_pointer_type (type)\n    the template indicator where already used an compress appropriately.\n    It handles pointers. */\n \n+/* atms: array template mangled string. */\n+static GTY(()) tree atms;\n static void\n mangle_array_type (p_type)\n      tree p_type;\n {\n-  /* atms: array template mangled string. */\n-  static tree atms = NULL_TREE;\n   tree type, elt_type;\n   int match;\n \n@@ -450,7 +450,6 @@ mangle_array_type (p_type)\n   if (!atms)\n     {\n       atms = get_identifier (\"6JArray\");\n-      ggc_add_tree_root (&atms, 1);\n     }\n \n   /* Maybe we have what we're looking in the compression table. */\n@@ -602,9 +601,7 @@ compression_table_add (type)\n       for (i = 0; i < compression_next; i++)\n \tTREE_VEC_ELT (new, i) = TREE_VEC_ELT (compression_table, i);\n \n-      ggc_del_root (&compression_table);\n       compression_table = new;\n-      ggc_add_tree_root (&compression_table, 1);\n     }\n   TREE_VEC_ELT (compression_table, compression_next++) = type;\n }\n@@ -624,9 +621,6 @@ init_mangling (obstack)\n \n   /* Mangled name are to be suffixed */\n   obstack_grow (mangle_obstack, \"_Z\", 2);\n-\n-  /* Register the compression table with the GC */\n-  ggc_add_tree_root (&compression_table, 1);\n }\n \n /* Mangling finalization routine. The mangled name is returned as a\n@@ -641,7 +635,6 @@ finish_mangling ()\n     /* Mangling already finished.  */\n     abort ();\n \n-  ggc_del_root (&compression_table);\n   compression_table = NULL_TREE;\n   compression_next = 0;\n   obstack_1grow (mangle_obstack, '\\0');\n@@ -652,3 +645,5 @@ finish_mangling ()\n #endif\n   return result;\n }\n+\n+#include \"gt-java-mangle.h\""}, {"sha": "960bd9075da7e2d4c3fc5d5ec4d1e117b1957539", "filename": "gcc/java/parse.y", "status": "modified", "additions": 102, "deletions": 169, "changes": 271, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -66,6 +66,7 @@ definitions and other extensions.  */\n #include \"function.h\"\n #include \"except.h\"\n #include \"ggc.h\"\n+#include \"debug.h\"\n \n #ifndef DIR_SEPARATOR\n #define DIR_SEPARATOR '/'\n@@ -298,8 +299,7 @@ static tree maybe_make_nested_class_name PARAMS ((tree));\n static int make_nested_class_name PARAMS ((tree));\n static void set_nested_class_simple_name_value PARAMS ((tree, int));\n static void link_nested_class_to_enclosing PARAMS ((void));\n-static tree resolve_inner_class PARAMS ((struct hash_table *, tree, tree *,\n-\t\t\t\t\t tree *, tree));\n+static tree resolve_inner_class PARAMS ((htab_t, tree, tree *, tree *, tree));\n static tree find_as_inner_class PARAMS ((tree, tree, tree));\n static tree find_as_inner_class_do PARAMS ((tree, tree));\n static int check_inner_class_redefinition PARAMS ((tree, tree));\n@@ -334,9 +334,8 @@ static void create_new_parser_context PARAMS ((int));\n static void mark_parser_ctxt PARAMS ((void *));\n static tree maybe_build_class_init_for_field PARAMS ((tree, tree));\n \n-static bool attach_init_test_initialization_flags PARAMS ((struct hash_entry *,\n-\t\t\t\t\t\t\t  PTR));\n-static bool emit_test_initialization PARAMS ((struct hash_entry *, PTR));\n+static int attach_init_test_initialization_flags PARAMS ((PTR *, PTR));\n+static int emit_test_initialization PARAMS ((PTR *, PTR));\n \n static char *string_convert_int_cst PARAMS ((tree));\n \n@@ -376,58 +375,58 @@ static const enum tree_code binop_lookup[19] =\n #define BINOP_COMPOUND_CANDIDATES 11\n \n /* The \"$L\" identifier we use to create labels.  */\n-static tree label_id = NULL_TREE;\n+static GTY(()) tree label_id;\n \n /* The \"StringBuffer\" identifier used for the String `+' operator. */\n-static tree wfl_string_buffer = NULL_TREE; \n+static GTY(()) tree wfl_string_buffer; \n \n /* The \"append\" identifier used for String `+' operator.  */\n-static tree wfl_append = NULL_TREE;\n+static GTY(()) tree wfl_append;\n \n /* The \"toString\" identifier used for String `+' operator. */\n-static tree wfl_to_string = NULL_TREE;\n+static GTY(()) tree wfl_to_string;\n \n /* The \"java.lang\" import qualified name.  */\n-static tree java_lang_id = NULL_TREE;\n+static GTY(()) tree java_lang_id;\n \n /* The generated `inst$' identifier used for generated enclosing\n    instance/field access functions.  */\n-static tree inst_id = NULL_TREE;\n+static GTY(()) tree inst_id;\n \n /* The \"java.lang.Cloneable\" qualified name.  */\n-static tree java_lang_cloneable = NULL_TREE;\n+static GTY(()) tree java_lang_cloneable;\n \n /* The \"java.io.Serializable\" qualified name.  */\n-static tree java_io_serializable = NULL_TREE; \n+static GTY(()) tree java_io_serializable; \n \n /* Context and flag for static blocks */\n-static tree current_static_block = NULL_TREE;\n+static GTY(()) tree current_static_block;\n \n /* The generated `write_parm_value$' identifier.  */\n-static tree wpv_id;\n+static GTY(()) tree wpv_id;\n \n /* The list of all packages we've seen so far */\n-static tree package_list = NULL_TREE;\n+static GTY(()) tree package_list;\n  \n /* Hold THIS for the scope of the current method decl.  */\n-static tree current_this;\n+static GTY(()) tree current_this;\n \n /* Hold a list of catch clauses list. The first element of this list is\n    the list of the catch clauses of the currently analysed try block. */\n-static tree currently_caught_type_list;\n+static GTY(()) tree currently_caught_type_list;\n \n /* This holds a linked list of all the case labels for the current\n    switch statement.  It is only used when checking to see if there\n    are duplicate labels.  FIXME: probably this should just be attached\n    to the switch itself; then it could be referenced via\n    `ctxp->current_loop'.  */\n-static tree case_label_list; \n+static GTY(()) tree case_label_list; \n \n /* Anonymous class counter. Will be reset to 1 every time a non\n    anonymous class gets created. */\n static int anonymous_class_counter = 1;\n \n-static tree src_parse_roots[1];\n+static GTY(()) tree src_parse_roots[1];\n \n /* All classes seen from source code */\n #define gclass_list src_parse_roots[0]\n@@ -614,20 +613,6 @@ goal:\n                 {\n \t\t  /* Register static variables with the garbage\n \t\t     collector.  */\n-\t\t  ggc_add_tree_root (&label_id, 1);\n-\t\t  ggc_add_tree_root (&wfl_string_buffer, 1);\n-\t\t  ggc_add_tree_root (&wfl_append, 1);\n-\t\t  ggc_add_tree_root (&wfl_to_string, 1);\n-\t\t  ggc_add_tree_root (&java_lang_id, 1);\n-\t\t  ggc_add_tree_root (&inst_id, 1);\n-\t\t  ggc_add_tree_root (&java_lang_cloneable, 1);\n-\t\t  ggc_add_tree_root (&java_io_serializable, 1);\n-\t\t  ggc_add_tree_root (&current_static_block, 1);\n-\t\t  ggc_add_tree_root (&wpv_id, 1);\n-\t\t  ggc_add_tree_root (&package_list, 1);\n-\t\t  ggc_add_tree_root (&current_this, 1);\n-\t\t  ggc_add_tree_root (&currently_caught_type_list, 1);\n-\t\t  ggc_add_tree_root (&case_label_list, 1);\n \t\t  ggc_add_root (&ctxp, 1, \n \t\t\t\tsizeof (struct parser_ctxt *),\n \t\t\t\tmark_parser_ctxt);\n@@ -3550,7 +3535,7 @@ check_inner_class_redefinition (raw_name, cl)\n \n static tree\n resolve_inner_class (circularity_hash, cl, enclosing, super, class_type)\n-     struct hash_table *circularity_hash;\n+     htab_t circularity_hash;\n      tree cl, *enclosing, *super, class_type;\n {\n   tree local_enclosing = *enclosing;\n@@ -3560,8 +3545,8 @@ resolve_inner_class (circularity_hash, cl, enclosing, super, class_type)\n     {\n       tree intermediate, decl;\n \n-      hash_lookup (circularity_hash, \n-\t\t   (const  hash_table_key) local_enclosing, TRUE, NULL);\n+      *htab_find_slot (circularity_hash, local_enclosing, INSERT) =\n+\tlocal_enclosing;\n \n       if ((decl = find_as_inner_class (local_enclosing, class_type, cl)))\n \treturn decl;\n@@ -3589,8 +3574,7 @@ resolve_inner_class (circularity_hash, cl, enclosing, super, class_type)\n \n       /* We may not have checked for circular inheritance yet, so do so\n          here to prevent an infinite loop. */\n-      if (hash_lookup (circularity_hash,\n-\t\t       (const hash_table_key) local_super, FALSE, NULL))\n+      if (htab_find (circularity_hash, local_super) != NULL)\n         {\n           if (!cl)\n             cl = lookup_cl (local_enclosing);\n@@ -4840,32 +4824,23 @@ constructor_circularity_msg (from, to)\n /* Verify a circular call to METH. Return 1 if an error is found, 0\n    otherwise.  */\n \n+static GTY(()) tree vcc_list;\n static int\n verify_constructor_circularity (meth, current)\n      tree meth, current;\n {\n-  static tree list = NULL_TREE;\n-  static int initialized_p;\n   tree c;\n \n-  /* If we haven't already registered LIST with the garbage collector,\n-     do so now.  */\n-  if (!initialized_p)\n-    {\n-      ggc_add_tree_root (&list, 1);\n-      initialized_p = 1;\n-    }\n-\n   for (c = DECL_CONSTRUCTOR_CALLS (current); c; c = TREE_CHAIN (c))\n     {\n       if (TREE_VALUE (c) == meth)\n \t{\n \t  char *t;\n-\t  if (list)\n+\t  if (vcc_list)\n \t    {\n \t      tree liste;\n-\t      list = nreverse (list);\n-\t      for (liste = list; liste; liste = TREE_CHAIN (liste))\n+\t      vcc_list = nreverse (vcc_list);\n+\t      for (liste = vcc_list; liste; liste = TREE_CHAIN (liste))\n \t\t{\n \t\t  parse_error_context \n \t\t    (TREE_PURPOSE (TREE_PURPOSE (liste)), \"%s\",\n@@ -4879,16 +4854,16 @@ verify_constructor_circularity (meth, current)\n \t\t\t       \"%s: recursive invocation of constructor `%s'\",\n \t\t\t       constructor_circularity_msg (current, meth), t);\n \t  free (t);\n-\t  list = NULL_TREE;\n+\t  vcc_list = NULL_TREE;\n \t  return 1;\n \t}\n     }\n   for (c = DECL_CONSTRUCTOR_CALLS (current); c; c = TREE_CHAIN (c))\n     {\n-      list = tree_cons (c, current, list);\n+      vcc_list = tree_cons (c, current, vcc_list);\n       if (verify_constructor_circularity (meth, TREE_VALUE (c)))\n \treturn 1;\n-      list = TREE_CHAIN (list);\n+      vcc_list = TREE_CHAIN (vcc_list);\n     }\n   return 0;\n }\n@@ -5782,14 +5757,14 @@ do_resolve_class (enclosing, class_type, decl, cl)\n   tree new_class_decl = NULL_TREE, super = NULL_TREE;\n   tree saved_enclosing_type = enclosing ? TREE_TYPE (enclosing) : NULL_TREE;\n   tree decl_result;\n-  struct hash_table _ht, *circularity_hash = &_ht;\n+  htab_t circularity_hash;\n \n   /* This hash table is used to register the classes we're going\n      through when searching the current class as an inner class, in\n      order to detect circular references. Remember to free it before\n      returning the section 0- of this function. */\n-  hash_table_init (circularity_hash, hash_newfunc,\n-\t\t   java_hash_hash_tree_node, java_hash_compare_tree_node);\n+  circularity_hash = htab_create (20, htab_hash_pointer, htab_eq_pointer, \n+\t\t\t\t  NULL);\n \n   /* 0- Search in the current class as an inner class.\n      Maybe some code here should be added to load the class or\n@@ -5811,7 +5786,7 @@ do_resolve_class (enclosing, class_type, decl, cl)\n \tenclosing = NULL_TREE;\n     }\n \n-  hash_table_free (circularity_hash);\n+  htab_delete (circularity_hash);\n \n   if (new_class_decl)\n     return new_class_decl;\n@@ -6668,34 +6643,33 @@ lookup_java_method2 (clas, method_decl, do_interface)\n /* Return the line that matches DECL line number, and try its best to\n    position the column number. Used during error reports.  */\n \n+static GTY(()) tree cl_v;\n static tree\n lookup_cl (decl)\n      tree decl;\n {\n-  static tree cl = NULL_TREE;\n   char *line, *found;\n   \n   if (!decl)\n     return NULL_TREE;\n \n-  if (cl == NULL_TREE)\n+  if (cl_v == NULL_TREE)\n     {\n-      cl = build_expr_wfl (NULL_TREE, NULL, 0, 0);\n-      ggc_add_tree_root (&cl, 1);\n+      cl_v = build_expr_wfl (NULL_TREE, NULL, 0, 0);\n     }\n \n-  EXPR_WFL_FILENAME_NODE (cl) = get_identifier (DECL_SOURCE_FILE (decl));\n-  EXPR_WFL_SET_LINECOL (cl, DECL_SOURCE_LINE_FIRST (decl), -1);\n+  EXPR_WFL_FILENAME_NODE (cl_v) = get_identifier (DECL_SOURCE_FILE (decl));\n+  EXPR_WFL_SET_LINECOL (cl_v, DECL_SOURCE_LINE_FIRST (decl), -1);\n \n-  line = java_get_line_col (EXPR_WFL_FILENAME (cl), \n-\t\t\t    EXPR_WFL_LINENO (cl), EXPR_WFL_COLNO (cl));\n+  line = java_get_line_col (EXPR_WFL_FILENAME (cl_v), \n+\t\t\t    EXPR_WFL_LINENO (cl_v), EXPR_WFL_COLNO (cl_v));\n \n   found = strstr ((const char *)line, \n \t\t  (const char *)IDENTIFIER_POINTER (DECL_NAME (decl)));\n   if (found)\n-    EXPR_WFL_SET_LINECOL (cl, EXPR_WFL_LINENO (cl), found - line);\n+    EXPR_WFL_SET_LINECOL (cl_v, EXPR_WFL_LINENO (cl_v), found - line);\n \n-  return cl;\n+  return cl_v;\n }\n \n /* Look for a simple name in the single-type import list */\n@@ -7044,19 +7018,17 @@ static void\n register_package (name)\n      tree name;\n {\n-  static struct hash_table _pht, *pht = NULL;\n+  static htab_t pht;\n+  PTR *e;\n \n-  if (!pht)\n-    {\n-      hash_table_init (&_pht, hash_newfunc, \n-\t\t       java_hash_hash_tree_node, java_hash_compare_tree_node);\n-      pht = &_pht;\n-    }\n-  \n-  if (!hash_lookup (pht, (const hash_table_key) name, FALSE, NULL))\n+  if (pht == NULL)\n+    pht = htab_create (50, htab_hash_pointer, htab_eq_pointer, NULL);\n+\n+  e = htab_find_slot (pht, name, INSERT);\n+  if (*e == NULL)\n     {\n       package_list = chainon (package_list, build_tree_list (name, NULL));\n-      hash_lookup (pht, (const hash_table_key) name, TRUE, NULL);\n+      *e = name;\n     }\n }\n \n@@ -7559,20 +7531,12 @@ void java_layout_seen_class_methods ()\n     }\n }\n \n+static GTY(()) tree stop_reordering;\n void\n java_reorder_fields ()\n {\n-  static tree stop_reordering = NULL_TREE;\n-  static int initialized_p;\n   tree current;\n \n-  /* Register STOP_REORDERING with the garbage collector.  */\n-  if (!initialized_p)\n-    {\n-      ggc_add_tree_root (&stop_reordering, 1);\n-      initialized_p = 1;\n-    }\n-\n   for (current = gclass_list; current; current = TREE_CHAIN (current))\n     {\n       current_class = TREE_TYPE (TREE_VALUE (current));\n@@ -8060,7 +8024,7 @@ java_complete_expand_method (mdecl)\n       \n       /* Before we check initialization, attached all class initialization\n \t variable to the block_body */\n-      hash_traverse (&DECL_FUNCTION_INIT_TEST_TABLE (mdecl),\n+      htab_traverse (DECL_FUNCTION_INIT_TEST_TABLE (mdecl),\n \t\t     attach_init_test_initialization_flags, block_body);\n       \n       if (! flag_emit_xref && ! METHOD_NATIVE (mdecl))\n@@ -8077,9 +8041,11 @@ java_complete_expand_method (mdecl)\n \t\t MDECL. This used with caution helps removing extra\n \t\t initialization of self. */\n \t      if (METHOD_STATIC (mdecl))\n-\t\thash_lookup (&DECL_FUNCTION_INITIALIZED_CLASS_TABLE (mdecl),\n-\t\t\t     (hash_table_key) DECL_CONTEXT (mdecl),\n-\t\t\t     TRUE, NULL);\n+\t\t{\n+\t\t  *(htab_find_slot \n+\t\t    (DECL_FUNCTION_INITIALIZED_CLASS_TABLE (mdecl),\n+\t\t     DECL_CONTEXT (mdecl), INSERT)) = DECL_CONTEXT (mdecl);\n+\t\t}\n \t    }\n \t}\n       ctxp->explicit_constructor_p = 0;\n@@ -8147,7 +8113,7 @@ java_expand_method_bodies (class)\n \t      /* For each class definitely initialized in\n \t\t CALLED_METHOD, fill ASSIGNMENT_COMPOUND with\n \t\t assignment to the class initialization flag. */\n-\t      hash_traverse (&DECL_FUNCTION_INITIALIZED_CLASS_TABLE (called_method),\n+\t      htab_traverse (DECL_FUNCTION_INITIALIZED_CLASS_TABLE (called_method),\n \t\t\t     emit_test_initialization,\n \t\t\t     assignment_compound_list);\n \n@@ -8635,27 +8601,19 @@ maybe_build_thisn_access_method (type)\n    This function can be invoked with TYPE to NULL, available and then\n    has to count the parser context.  */\n \n+static GTY(()) tree saved_thisn;\n+static GTY(()) tree saved_type;\n+\n static tree\n build_current_thisn (type)\n     tree type;\n {\n   static int saved_i = -1;\n-  static tree saved_thisn = NULL_TREE;\n-  static tree saved_type = NULL_TREE;\n   static int saved_type_i = 0;\n-  static int initialized_p;\n   tree decl;\n   char buffer [24];\n   int i = 0;\n \n-  /* Register SAVED_THISN and SAVED_TYPE with the garbage collector.  */\n-  if (!initialized_p)\n-    {\n-      ggc_add_tree_root (&saved_thisn, 1);\n-      ggc_add_tree_root (&saved_type, 1);\n-      initialized_p = 1;\n-    }\n-\n   if (type)\n     {\n       if (type == saved_type)\n@@ -8712,6 +8670,9 @@ build_thisn_assign ()\n         throw new NoClassDefFoundError(e.getMessage());}\n     } */\n \n+static GTY(()) tree get_message_wfl;\n+static GTY(()) tree type_parm_wfl;\n+\n static tree\n build_dot_class_method (class)\n      tree class;\n@@ -8721,14 +8682,10 @@ build_dot_class_method (class)\n   tree args, tmp, saved_current_function_decl, mdecl;\n   tree stmt, throw_stmt;\n \n-  static tree get_message_wfl, type_parm_wfl;\n-\n   if (!get_message_wfl)\n     {\n       get_message_wfl = build_wfl_node (get_identifier (\"getMessage\"));\n       type_parm_wfl = build_wfl_node (get_identifier (\"type$\"));\n-      ggc_add_tree_root (&get_message_wfl, 1);\n-      ggc_add_tree_root (&type_parm_wfl, 1);\n     }\n \n   /* Build the arguments */\n@@ -8985,6 +8942,7 @@ verify_constructor_super (mdecl)\n \n /* Generate code for all context remembered for code generation.  */\n \n+static GTY(()) tree reversed_class_list;\n void\n java_expand_classes ()\n {\n@@ -9066,7 +9024,7 @@ java_expand_classes ()\n   for (cur_ctxp = ctxp_for_generation; cur_ctxp; cur_ctxp = cur_ctxp->next)\n     {\n       tree current;\n-      tree reversed_class_list = NULL;\n+      reversed_class_list = NULL;\n \n       ctxp = cur_ctxp;\n \n@@ -9083,7 +9041,6 @@ java_expand_classes ()\n \t   current = TREE_CHAIN (current))\n \treversed_class_list\n \t  = tree_cons (NULL_TREE, current, reversed_class_list);\n-      ggc_add_tree_root (&reversed_class_list, 1);\n \n       for (current = reversed_class_list; \n \t   current; \n@@ -9101,8 +9058,6 @@ java_expand_classes ()\n \t      finish_class ();\n \t    }\n \t}\n-\n-      ggc_del_root (&reversed_class_list);\n     }\n }\n \n@@ -10094,15 +10049,15 @@ check_deprecation (wfl, decl)\n \n /* Returns 1 if class was declared in the current package, 0 otherwise */\n \n+static GTY(()) tree cicp_cache;\n static int\n class_in_current_package (class)\n      tree class;\n {\n-  static tree cache = NULL_TREE;\n   int qualified_flag;\n   tree left;\n \n-  if (cache == class)\n+  if (cicp_cache == class)\n     return 1;\n \n   qualified_flag = QUALIFIED_P (DECL_NAME (TYPE_NAME (class)));\n@@ -10123,15 +10078,7 @@ class_in_current_package (class)\n   breakdown_qualified (&left, NULL, DECL_NAME (TYPE_NAME (class)));\n   if (ctxp->package == left)\n     {\n-      static int initialized_p;\n-      /* Register CACHE with the garbage collector.  */\n-      if (!initialized_p)\n-\t{\n-\t  ggc_add_tree_root (&cache, 1);\n-\t  initialized_p = 1;\n-\t}\n-\n-      cache = class;\n+      cicp_cache = class;\n       return 1;\n     }\n   return 0;\n@@ -10939,28 +10886,25 @@ find_applicable_accessible_methods_list (lc, class, name, arglist)\n      int lc;\n      tree class, name, arglist;\n {\n-  static struct hash_table t, *searched_classes = NULL;\n+  static htab_t searched_classes;\n   static int search_not_done = 0;\n   tree list = NULL_TREE, all_list = NULL_TREE;\n \n   /* Check the hash table to determine if this class has been searched \n      already. */\n   if (searched_classes)\n     {\n-      if (hash_lookup (searched_classes, \n-                      (const hash_table_key) class, FALSE, NULL))\n-       return NULL;\n+      if (htab_find (searched_classes, class) != NULL)\n+\treturn NULL;\n     }\n   else\n     {\n-      hash_table_init (&t, hash_newfunc, java_hash_hash_tree_node,\n-                      java_hash_compare_tree_node);\n-      searched_classes = &t;\n+      searched_classes = htab_create (10, htab_hash_pointer,\n+\t\t\t\t      htab_eq_pointer, NULL);\n     }\n     \n   search_not_done++;\n-  hash_lookup (searched_classes, \n-\t       (const hash_table_key) class, TRUE, NULL);\n+  *htab_find_slot (searched_classes, class, INSERT) = class;\n \n   if (!CLASS_LOADED_P (class) && !CLASS_FROM_SOURCE_P (class))\n     {\n@@ -11040,15 +10984,13 @@ find_applicable_accessible_methods_list (lc, class, name, arglist)\n     {\n       if (!lc\n \t  && TYPE_METHODS (object_type_node)\n-\t  && !hash_lookup (searched_classes, \n-                           (const hash_table_key) object_type_node, \n-                           FALSE, NULL))\n+\t  && htab_find (searched_classes, object_type_node) == NULL)\n \t{\n           search_applicable_methods_list (lc, \n                                           TYPE_METHODS (object_type_node),\n                                           name, arglist, &list, &all_list);\n         }\n-      hash_table_free (searched_classes);\n+      htab_delete (searched_classes);\n       searched_classes = NULL;\n     }\n \n@@ -11178,25 +11120,15 @@ find_most_specific_methods_list (list)\n    corresponding parameter of M1. Implementation expects M2_OR_ARGLIST\n    to change less often than M1. */\n \n+static GTY(()) tree m2_arg_value;\n+static GTY(()) tree m2_arg_cache;\n+\n static int\n argument_types_convertible (m1, m2_or_arglist)\n     tree m1, m2_or_arglist;\n {\n-  static tree m2_arg_value = NULL_TREE;\n-  static tree m2_arg_cache = NULL_TREE;\n-  static int initialized_p;\n-\n   register tree m1_arg, m2_arg;\n \n-  /* Register M2_ARG_VALUE and M2_ARG_CACHE with the garbage\n-     collector.  */\n-  if (!initialized_p)\n-    {\n-      ggc_add_tree_root (&m2_arg_value, 1);\n-      ggc_add_tree_root (&m2_arg_cache, 1);\n-      initialized_p = 1;\n-    }\n-\n   SKIP_THIS_AND_ARTIFICIAL_PARMS (m1_arg, m1)\n \n   if (m2_arg_value == m2_or_arglist)\n@@ -16140,9 +16072,6 @@ mark_parser_ctxt (p)\n void\n init_src_parse ()\n {\n-  /* Register roots with the garbage collector.  */\n-  ggc_add_tree_root (src_parse_roots, ARRAY_SIZE (src_parse_roots));\n-\n   /* Sanity check; we've been bit by this before.  */\n   if (ARRAY_SIZE (ctxp->modifier_ctx) != MODIFIER_TK - PUBLIC_TK)\n     abort ();\n@@ -16155,16 +16084,16 @@ init_src_parse ()\n \n /* Attach to PTR (a block) the declaration found in ENTRY. */\n \n-static bool\n+static int\n attach_init_test_initialization_flags (entry, ptr)\n-     struct hash_entry *entry;\n+     PTR *entry;\n      PTR ptr;\n {\n   tree block = (tree)ptr;\n-  struct init_test_hash_entry *ite = (struct init_test_hash_entry *) entry;\n+  struct treetreehash_entry *ite = (struct treetreehash_entry *) *entry;\n   \n-  TREE_CHAIN (ite->init_test_decl) = BLOCK_EXPR_DECLS (block);\n-  BLOCK_EXPR_DECLS (block) = ite->init_test_decl;\n+  TREE_CHAIN (ite->value) = BLOCK_EXPR_DECLS (block);\n+  BLOCK_EXPR_DECLS (block) = ite->value;\n   return true;\n }\n \n@@ -16174,28 +16103,29 @@ attach_init_test_initialization_flags (entry, ptr)\n    initialized static class flags if a flag already existed, otherwise\n    a new one is created.  */\n \n-static bool\n-emit_test_initialization (entry, info)\n-     struct hash_entry *entry;\n+static int\n+emit_test_initialization (entry_p, info)\n+     PTR *entry_p;\n      PTR info;\n {\n   tree l = (tree) info;\n   tree decl, init;\n-\n-  struct init_test_hash_entry *ite = (struct init_test_hash_entry *)\n-    hash_lookup (&DECL_FUNCTION_INIT_TEST_TABLE (current_function_decl),\n-\t\t entry->key,\n-\t\t current_function_decl != TREE_PURPOSE (l), NULL);\n+  tree key = (tree) *entry_p;\n+  tree *ite;\n+  htab_t cf_ht = DECL_FUNCTION_INIT_TEST_TABLE (current_function_decl);\n \n   /* If we haven't found a flag and we're dealing with self registered\n      with current_function_decl, then don't do anything. Self is\n      always added as definitely initialized but this information is\n      valid only if used outside the current function. */\n-  if (! ite)\n+  if (current_function_decl == TREE_PURPOSE (l)\n+      && java_treetreehash_find (cf_ht, key) == NULL)\n     return true;\n+    \n+  ite = java_treetreehash_new (cf_ht, key);\n \n   /* If we don't have a variable, create one and install it. */\n-  if (! ite->init_test_decl)\n+  if (*ite == NULL)\n     {\n       tree block;\n       \n@@ -16209,10 +16139,10 @@ emit_test_initialization (entry, info)\n       block = BLOCK_SUBBLOCKS (GET_CURRENT_BLOCK (current_function_decl));\n       TREE_CHAIN (decl) = BLOCK_EXPR_DECLS (block);\n       BLOCK_EXPR_DECLS (block) = decl;\n-      ite->init_test_decl = decl;\n+      *ite = decl;\n     }\n   else\n-    decl = ite->init_test_decl;\n+    decl = *ite;\n \n   /* Now simply augment the compound that holds all the assignments\n      pertaining to this method invocation. */\n@@ -16223,3 +16153,6 @@ emit_test_initialization (entry, info)\n \n   return true;\n }\n+\n+#include \"gt-java-parse.h\"\n+#include \"gtype-java.h\""}, {"sha": "6715159bd53f7310ea2aa3bb662ffd8e20a5e9bd", "filename": "gcc/langhooks-def.h", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Flanghooks-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Flanghooks-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks-def.h?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -100,7 +100,6 @@ tree lhd_tree_inlining_convert_parm_for_inlining PARAMS ((tree, tree, tree));\n #define LANG_HOOKS_DUP_LANG_SPECIFIC_DECL lhd_do_nothing_t\n #define LANG_HOOKS_UNSAVE_EXPR_NOW\tlhd_unsave_expr_now\n #define LANG_HOOKS_MAYBE_BUILD_CLEANUP\tlhd_return_null_tree\n-#define LANG_HOOKS_MARK_TREE\t\tlhd_do_nothing_t\n #define LANG_HOOKS_SET_DECL_ASSEMBLER_NAME lhd_set_decl_assembler_name\n #define LANG_HOOKS_HONOR_READONLY\tfalse\n #define LANG_HOOKS_PRINT_STATISTICS\tlhd_do_nothing\n@@ -112,10 +111,9 @@ tree lhd_tree_inlining_convert_parm_for_inlining PARAMS ((tree, tree, tree));\n #define LANG_HOOKS_DECL_PRINTABLE_NAME\tlhd_decl_printable_name\n \n #define LANG_HOOKS_FUNCTION_INIT\tlhd_do_nothing_f\n-#define LANG_HOOKS_FUNCTION_FREE\tlhd_do_nothing_f\n+#define LANG_HOOKS_FUNCTION_FINAL\tlhd_do_nothing_f\n #define LANG_HOOKS_FUNCTION_ENTER_NESTED lhd_do_nothing_f\n #define LANG_HOOKS_FUNCTION_LEAVE_NESTED lhd_do_nothing_f\n-#define LANG_HOOKS_FUNCTION_MARK\tlhd_do_nothing_f\n \n /* Attribute hooks.  */\n #define LANG_HOOKS_ATTRIBUTE_TABLE\t\tNULL\n@@ -159,12 +157,11 @@ tree lhd_tree_inlining_convert_parm_for_inlining PARAMS ((tree, tree, tree));\n   LANG_HOOKS_TREE_INLINING_CONVERT_PARM_FOR_INLINING \\\n } \\\n \n-#define LANG_HOOKS_FUNCTION_INITIALIZER { \\\n-  LANG_HOOKS_FUNCTION_INIT, \\\n-  LANG_HOOKS_FUNCTION_FREE, \\\n-  LANG_HOOKS_FUNCTION_ENTER_NESTED, \\\n-  LANG_HOOKS_FUNCTION_LEAVE_NESTED, \\\n-  LANG_HOOKS_FUNCTION_MARK \\\n+#define LANG_HOOKS_FUNCTION_INITIALIZER {\t\\\n+  LANG_HOOKS_FUNCTION_INIT,\t\t\t\\\n+  LANG_HOOKS_FUNCTION_FINAL,\t\t\t\\\n+  LANG_HOOKS_FUNCTION_ENTER_NESTED,\t\t\\\n+  LANG_HOOKS_FUNCTION_LEAVE_NESTED\t\t\\\n }\n \n /* Tree dump hooks.  */\n@@ -241,7 +238,6 @@ int lhd_tree_dump_type_quals\t\t\tPARAMS ((tree));\n   LANG_HOOKS_DUP_LANG_SPECIFIC_DECL, \\\n   LANG_HOOKS_UNSAVE_EXPR_NOW, \\\n   LANG_HOOKS_MAYBE_BUILD_CLEANUP, \\\n-  LANG_HOOKS_MARK_TREE, \\\n   LANG_HOOKS_SET_DECL_ASSEMBLER_NAME, \\\n   LANG_HOOKS_HONOR_READONLY, \\\n   LANG_HOOKS_PRINT_STATISTICS, \\"}, {"sha": "71ae251c4abaaa27f8405c4203d68956fa7295e1", "filename": "gcc/langhooks.h", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -65,16 +65,13 @@ struct lang_hooks_for_functions\n   void (*init) PARAMS ((struct function *));\n \n   /* Called when leaving a function.  */\n-  void (*free) PARAMS ((struct function *));\n+  void (*final) PARAMS ((struct function *));\n \n   /* Called when entering a nested function.  */\n   void (*enter_nested) PARAMS ((struct function *));\n \n   /* Called when leaving a nested function.  */\n   void (*leave_nested) PARAMS ((struct function *));\n-\n-  /* Lang-specific function data marking for GC.  */\n-  void (*mark) PARAMS ((struct function *));\n };\n \n /* The following hooks are used by tree-dump.c.  */\n@@ -292,9 +289,6 @@ struct lang_hooks\n      for the passed TARGET_EXPR.  Return NULL if there is none.  */\n   tree (*maybe_build_cleanup) PARAMS ((tree));\n \n-  /* Mark nodes held through the lang_specific hooks in the tree.  */\n-  void (*mark_tree) PARAMS ((tree));\n-\n   /* Set the DECL_ASSEMBLER_NAME for a node.  If it is the sort of\n      thing that the assembler should talk about, set\n      DECL_ASSEMBLER_NAME to an appropriate IDENTIFIER_NODE."}, {"sha": "bb2aa17f3647bac0619f55bd575c245a019a2482", "filename": "gcc/libfuncs.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Flibfuncs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Flibfuncs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibfuncs.h?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -148,7 +148,7 @@ enum libfunc_index\n \n /* SYMBOL_REF rtx's for the library functions that are called\n    implicitly and not via optabs.  */\n-extern rtx libfunc_table[LTI_MAX];\n+extern GTY(()) rtx libfunc_table[LTI_MAX];\n \n /* Accessor macros for libfunc_table.  */\n #define extendsfdf2_libfunc\t(libfunc_table[LTI_extendsfdf2])"}, {"sha": "b57b138010d724b7ab8b62dea8ee16752a59fc74", "filename": "gcc/lists.c", "status": "modified", "additions": 4, "deletions": 19, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Flists.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Flists.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flists.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -26,15 +26,14 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"ggc.h\"\n \n static void free_list PARAMS ((rtx *, rtx *));\n-static void zap_lists PARAMS ((void *));\n \n /* Functions for maintaining cache-able lists of EXPR_LIST and INSN_LISTs.  */\n \n /* An INSN_LIST containing all INSN_LISTs allocated but currently unused.  */\n-static rtx unused_insn_list;\n+static GTY ((deletable (\"\"))) rtx unused_insn_list;\n \n /* An EXPR_LIST containing all EXPR_LISTs allocated but currently unused.  */\n-static rtx unused_expr_list;\n+static GTY ((deletable (\"\"))) rtx unused_expr_list;\n \n \n /* This function will free an entire list of either EXPR_LIST or INSN_LIST\n@@ -108,22 +107,6 @@ alloc_EXPR_LIST (kind, val, next)\n   return r;\n }\n \n-/* This function will initialize the EXPR_LIST and INSN_LIST caches.  */\n-\n-static void\n-zap_lists (dummy)\n-     void *dummy ATTRIBUTE_UNUSED;\n-{\n-  unused_expr_list = NULL;\n-  unused_insn_list = NULL;\n-}\n-\n-void\n-init_EXPR_INSN_LIST_cache ()\n-{\n-  ggc_add_root (&unused_expr_list, 1, 1, zap_lists);\n-}\n-\n /* This function will free up an entire list of EXPR_LIST nodes.  */\n void\n free_EXPR_LIST_list (listp)\n@@ -161,3 +144,5 @@ free_INSN_LIST_node (ptr)\n   XEXP (ptr, 1) = unused_insn_list;\n   unused_insn_list = ptr;\n }\n+\n+#include \"gt-lists.h\""}, {"sha": "5b86b79f8b940d9c12da5cb2573ab9fc49e4a453", "filename": "gcc/mkconfig.sh", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fmkconfig.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fmkconfig.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmkconfig.sh?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -50,6 +50,7 @@ typedef struct rtvec_def *rtvec;\n union tree_node;\n typedef union tree_node *tree;\n #endif\n+#define GTY(x)\n EOF\n         ;;\n esac"}, {"sha": "86b3dabc08424334ecba7dae4e575c596dc56520", "filename": "gcc/objc/Make-lang.in", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fobjc%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fobjc%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FMake-lang.in?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -93,10 +93,12 @@ objc-act.o : $(srcdir)/objc/objc-act.c \\\n    $(C_COMMON_H) $(srcdir)/c-tree.h \\\n    $(srcdir)/toplev.h $(srcdir)/flags.h $(srcdir)/objc/objc-act.h \\\n    $(srcdir)/input.h $(srcdir)/function.h $(srcdir)/output.h $(srcdir)/debug.h \\\n-   $(srcdir)/langhooks.h $(LANGHOOKS_DEF_H)\n+   $(srcdir)/langhooks.h $(LANGHOOKS_DEF_H) gtype-objc.h\n \t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) -I$(srcdir)/objc \\\n \t-c $(srcdir)/objc/objc-act.c\n \n+gtype-objc.h : s-gtype ; @true\n+\n #\f\n # Build hooks:\n "}, {"sha": "62ff455f3d172c0625acd58462dc4cbed59f954b", "filename": "gcc/objc/config-lang.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fobjc%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fobjc%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fconfig-lang.in?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -32,3 +32,5 @@ compilers=\"cc1obj\\$(exeext)\"\n stagestuff=\"\"\n \n target_libs=target-libobjc\n+\n+gtfiles=\"\\$(srcdir)/objc/objc-act.h\""}, {"sha": "2835f835b30a521ffbb197f70c23f76943dc6281", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 7, "deletions": 73, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -294,9 +294,6 @@ static void generate_classref_translation_entry\tPARAMS ((tree));\n static void handle_class_ref\t\t\tPARAMS ((tree));\n static void generate_struct_by_value_array\tPARAMS ((void))\n      ATTRIBUTE_NORETURN;\n-static void objc_act_parse_init\t\t\tPARAMS ((void));\n-static void ggc_mark_imp_list\t\t\tPARAMS ((void *));\n-static void ggc_mark_hash_table\t\t\tPARAMS ((void *));\n \n /*** Private Interface (data) ***/\n \n@@ -516,8 +513,6 @@ objc_init (filename)\n   if (print_struct_values)\n     generate_struct_by_value_array ();\n \n-  objc_act_parse_init ();\n-\n   return filename;\n }\n \n@@ -1234,8 +1229,6 @@ build_objc_string_object (strings)\n \tVARRAY_PUSH_TREE (vstrings, strings);\n \n       string = combine_strings (vstrings);\n-\n-      VARRAY_FREE (vstrings);\n     }\n   else\n     string = strings;\n@@ -5279,8 +5272,8 @@ hash_func (sel_name)\n static void\n hash_init ()\n {\n-  nst_method_hash_list = (hash *) xcalloc (SIZEHASHTABLE, sizeof (hash));\n-  cls_method_hash_list = (hash *) xcalloc (SIZEHASHTABLE, sizeof (hash));\n+  nst_method_hash_list = (hash *) ggc_calloc (SIZEHASHTABLE, sizeof (hash));\n+  cls_method_hash_list = (hash *) ggc_calloc (SIZEHASHTABLE, sizeof (hash));\n }\n \n /* WARNING!!!!  hash_enter is called with a method, and will peek\n@@ -5293,18 +5286,10 @@ hash_enter (hashlist, method)\n      hash *hashlist;\n      tree method;\n {\n-  static hash \thash_alloc_list = 0;\n-  static int\thash_alloc_index = 0;\n   hash obj;\n   int slot = hash_func (METHOD_SEL_NAME (method)) % SIZEHASHTABLE;\n \n-  if (! hash_alloc_list || hash_alloc_index >= HASH_ALLOC_LIST_SIZE)\n-    {\n-      hash_alloc_index = 0;\n-      hash_alloc_list = (hash) xmalloc (sizeof (struct hashed_entry)\n-\t\t\t\t\t* HASH_ALLOC_LIST_SIZE);\n-    }\n-  obj = &hash_alloc_list[hash_alloc_index++];\n+  obj = (hash) ggc_alloc (sizeof (struct hashed_entry));\n   obj->list = 0;\n   obj->next = hashlist[slot];\n   obj->key = method;\n@@ -5336,17 +5321,9 @@ hash_add_attr (entry, value)\n      hash entry;\n      tree value;\n {\n-  static attr \tattr_alloc_list = 0;\n-  static int\tattr_alloc_index = 0;\n   attr obj;\n \n-  if (! attr_alloc_list || attr_alloc_index >= ATTR_ALLOC_LIST_SIZE)\n-    {\n-      attr_alloc_index = 0;\n-      attr_alloc_list = (attr) xmalloc (sizeof (struct hashed_attribute)\n-\t\t\t\t\t* ATTR_ALLOC_LIST_SIZE);\n-    }\n-  obj = &attr_alloc_list[attr_alloc_index++];\n+  obj = (attr) ggc_alloc (sizeof (struct hashed_attribute));\n   obj->next = entry->list;\n   obj->value = value;\n \n@@ -6147,7 +6124,7 @@ continue_class (class)\n       if (!objc_class_template)\n \tbuild_class_template ();\n \n-      imp_entry = (struct imp_entry *) xmalloc (sizeof (struct imp_entry));\n+      imp_entry = (struct imp_entry *) ggc_alloc (sizeof (struct imp_entry));\n \n       imp_entry->next = imp_list;\n       imp_entry->imp_context = class;\n@@ -8319,51 +8296,6 @@ handle_impent (impent)\n     }\n }\n \f\n-static void\n-ggc_mark_imp_list (arg)\n-     void *arg;\n-{\n-  struct imp_entry *impent;\n-\n-  for (impent = *(struct imp_entry **)arg; impent; impent = impent->next)\n-    {\n-      ggc_mark_tree (impent->imp_context);\n-      ggc_mark_tree (impent->imp_template);\n-      ggc_mark_tree (impent->class_decl);\n-      ggc_mark_tree (impent->meta_decl);\n-    }\n-}\n-\n-static void\n-ggc_mark_hash_table (arg)\n-     void *arg;\n-{\n-  hash *hash_table = *(hash **)arg;\n-  hash hst;\n-  attr list;\n-  int i;\n-\n-  if (hash_table == NULL)\n-    return;\n-  for (i = 0; i < SIZEHASHTABLE; i++)\n-    for (hst = hash_table [i]; hst; hst = hst->next)\n-      {\n-\tggc_mark_tree (hst->key);\n-\tfor (list = hst->list; list; list = list->next)\n-\t  ggc_mark_tree (list->value);\n-      }\n-}\n-\n-/* Add GC roots for variables local to this file.  */\n-static void\n-objc_act_parse_init ()\n-{\n-  ggc_add_tree_root (objc_global_trees, OCTI_MAX);\n-  ggc_add_root (&imp_list, 1, sizeof imp_list, ggc_mark_imp_list);\n-  ggc_add_root (&nst_method_hash_list, 1, sizeof nst_method_hash_list, ggc_mark_hash_table);\n-  ggc_add_root (&cls_method_hash_list, 1, sizeof cls_method_hash_list, ggc_mark_hash_table);\n-}\n-\n /* Look up ID as an instance variable.  */\n tree\n lookup_objc_ivar (id)\n@@ -8384,3 +8316,5 @@ lookup_objc_ivar (id)\n   else\n     return 0;\n }\n+\n+#include \"gtype-objc.h\""}, {"sha": "17e5bd58c4d2b558892094e78e06c042768fad26", "filename": "gcc/objc/objc-act.h", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fobjc%2Fobjc-act.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fobjc%2Fobjc-act.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.h?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -133,28 +133,26 @@ enum objc_tree_code {\n typedef struct hashed_entry\t*hash;\n typedef struct hashed_attribute\t*attr;\n \n-struct hashed_attribute\n+struct hashed_attribute GTY(())\n {\n   attr next;\n   tree value;\n };\n-struct hashed_entry\n+struct hashed_entry GTY(())\n {\n   attr list;\n   hash next;\n   tree key;\n };\n \n-extern hash *nst_method_hash_list;\n-extern hash *cls_method_hash_list;\n+extern GTY ((length (\"SIZEHASHTABLE\"))) hash *nst_method_hash_list;\n+extern GTY ((length (\"SIZEHASHTABLE\"))) hash *cls_method_hash_list;\n \n-#define HASH_ALLOC_LIST_SIZE\t170\n-#define ATTR_ALLOC_LIST_SIZE\t170\n #define SIZEHASHTABLE \t\t257\n \n /* Objective-C/Objective-C++ @implementation list.  */\n \n-struct imp_entry\n+struct imp_entry GTY(())\n {\n   struct imp_entry *next;\n   tree imp_context;\n@@ -163,7 +161,7 @@ struct imp_entry\n   tree meta_decl;\t\t/* _OBJC_METACLASS_<my_name>; */\n };\n \n-extern struct imp_entry *imp_list;\n+extern GTY(()) struct imp_entry *imp_list;\n extern int imp_count;\t/* `@implementation' */\n extern int cat_count;\t/* `@category' */\n \n@@ -248,7 +246,7 @@ enum objc_tree_index\n     OCTI_MAX\n };\n \n-extern tree objc_global_trees[OCTI_MAX];\n+extern GTY(()) tree objc_global_trees[OCTI_MAX];\n \n /* List of classes with list of their static instances.  */\n #define objc_static_instances\tobjc_global_trees[OCTI_STATIC_NST]"}, {"sha": "f5b74486750a3761dafe6657fa47934ec6a051a9", "filename": "gcc/objc/objc-lang.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fobjc%2Fobjc-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fobjc%2Fobjc-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-lang.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -45,8 +45,6 @@ static void objc_init_options                   PARAMS ((void));\n #define LANG_HOOKS_POST_OPTIONS c_common_post_options\n #undef LANG_HOOKS_PARSE_FILE\n #define LANG_HOOKS_PARSE_FILE c_common_parse_file\n-#undef LANG_HOOKS_MARK_TREE\n-#define LANG_HOOKS_MARK_TREE c_mark_tree\n #undef LANG_HOOKS_EXPAND_EXPR\n #define LANG_HOOKS_EXPAND_EXPR c_expand_expr\n #undef LANG_HOOKS_MARK_ADDRESSABLE\n@@ -74,8 +72,6 @@ static void objc_init_options                   PARAMS ((void));\n #define LANG_HOOKS_FUNCTION_ENTER_NESTED c_push_function_context\n #undef LANG_HOOKS_FUNCTION_LEAVE_NESTED\n #define LANG_HOOKS_FUNCTION_LEAVE_NESTED c_pop_function_context\n-#undef LANG_HOOKS_FUNCTION_MARK\n-#define LANG_HOOKS_FUNCTION_MARK c_mark_function_context\n \n /* Attribute hooks.  */\n #undef LANG_HOOKS_COMMON_ATTRIBUTE_TABLE"}, {"sha": "2b366ad61f0aac3db6bc3b05259a2d74b852e33f", "filename": "gcc/optabs.c", "status": "modified", "additions": 7, "deletions": 22, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -1208,7 +1208,7 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n       && GET_MODE_SIZE (mode) >= 2 * UNITS_PER_WORD\n       && binoptab->handlers[(int) word_mode].insn_code != CODE_FOR_nothing)\n     {\n-      int i;\n+      unsigned int i;\n       optab otheroptab = binoptab == add_optab ? sub_optab : add_optab;\n       int nwords = GET_MODE_BITSIZE (mode) / BITS_PER_WORD;\n       rtx carry_in = NULL_RTX, carry_out = NULL_RTX;\n@@ -1296,7 +1296,7 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \t  carry_in = carry_out;\n \t}\t\n \n-      if (i == GET_MODE_BITSIZE (mode) / BITS_PER_WORD)\n+      if (i == GET_MODE_BITSIZE (mode) / (unsigned) BITS_PER_WORD)\n \t{\n \t  if (mov_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n \t    {\n@@ -4733,7 +4733,7 @@ static optab\n new_optab ()\n {\n   int i;\n-  optab op = (optab) xmalloc (sizeof (struct optab));\n+  optab op = (optab) ggc_alloc (sizeof (struct optab));\n   for (i = 0; i < NUM_MACHINE_MODES; i++)\n     {\n       op->handlers[i].insn_code = CODE_FOR_nothing;\n@@ -4865,19 +4865,6 @@ init_one_libfunc (name)\n   return XEXP (DECL_RTL (decl), 0);\n }\n \n-/* Mark ARG (which is really an OPTAB *) for GC.  */\n-\n-void\n-mark_optab (arg)\n-     void *arg;\n-{\n-  optab o = *(optab *) arg;\n-  int i;\n-\n-  for (i = 0; i < NUM_MACHINE_MODES; ++i)\n-    ggc_mark_rtx (o->handlers[i].libfunc);\n-}\n-\n /* Call this once to initialize the contents of the optabs\n    appropriately for the current target machine.  */\n \n@@ -5228,26 +5215,22 @@ init_optabs ()\n   /* Allow the target to add more libcalls or rename some, etc.  */\n   INIT_TARGET_OPTABS;\n #endif\n-\n-  /* Add these GC roots.  */\n-  ggc_add_root (optab_table, OTI_MAX, sizeof(optab), mark_optab);\n-  ggc_add_rtx_root (libfunc_table, LTI_MAX);\n }\n \f\n+static GTY(()) rtx trap_rtx;\n+\n #ifdef HAVE_conditional_trap\n /* The insn generating function can not take an rtx_code argument.\n    TRAP_RTX is used as an rtx argument.  Its code is replaced with\n    the code to be used in the trap insn and all other fields are\n    ignored.  */\n-static rtx trap_rtx;\n \n static void\n init_traps ()\n {\n   if (HAVE_conditional_trap)\n     {\n       trap_rtx = gen_rtx_fmt_ee (EQ, VOIDmode, NULL_RTX, NULL_RTX);\n-      ggc_add_rtx_root (&trap_rtx, 1);\n     }\n }\n #endif\n@@ -5286,3 +5269,5 @@ gen_cond_trap (code, op1, op2, tcode)\n \n   return 0;\n }\n+\n+#include \"gt-optabs.h\""}, {"sha": "08dbec1e80a4b2c34b333de43e2ec4f31fde417d", "filename": "gcc/optabs.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -38,14 +38,15 @@ Boston, MA 02111-1307, USA.  */\n    A few optabs, such as move_optab and cmp_optab, are used\n    by special code.  */\n \n-typedef struct optab\n+struct optab GTY(())\n {\n   enum rtx_code code;\n-  struct {\n+  struct optab_handlers {\n     enum insn_code insn_code;\n     rtx libfunc;\n   } handlers [NUM_MACHINE_MODES];\n-} * optab;\n+};\n+typedef struct optab * optab;\n \n /* Given an enum insn_code, access the function to construct\n    the body of that kind of insn.  */\n@@ -152,7 +153,7 @@ enum optab_index\n   OTI_MAX\n };\n \n-extern optab optab_table[OTI_MAX];\n+extern GTY(()) optab optab_table[OTI_MAX];\n \n #define add_optab (optab_table[OTI_add])\n #define sub_optab (optab_table[OTI_sub])"}, {"sha": "53ed810972709c25e9eac1673ce588fdb0cd12c5", "filename": "gcc/output.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -349,7 +349,7 @@ extern bool assemble_integer\t\tPARAMS ((rtx, unsigned, unsigned, int));\n #define assemble_aligned_integer(SIZE, VALUE) \\\n   assemble_integer (VALUE, SIZE, (SIZE) * BITS_PER_UNIT, 1)\n \n-#ifdef REAL_VALUE_TYPE\n+#ifdef REAL_VALUE_TYPE_SIZE\n /* Assemble the floating-point constant D into an object of size MODE.  */\n extern void assemble_real\t\tPARAMS ((REAL_VALUE_TYPE,\n \t\t\t\t\t         enum machine_mode,"}, {"sha": "8470a1d2aab8eecb66f8a6a5fdcabe32b32b5f6a", "filename": "gcc/profile.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -1258,7 +1258,7 @@ end_branch_prob ()\n \f\n /* The label used by the edge profiling code.  */\n \n-static rtx profiler_label;\n+static GTY(()) rtx profiler_label;\n \n /* Initialize the profiler_label.  */\n \n@@ -1269,7 +1269,6 @@ init_edge_profiler ()\n   char buf[20];\n   ASM_GENERATE_INTERNAL_LABEL (buf, \"LPBX\", 2);\n   profiler_label = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (buf));\n-  ggc_add_rtx_root (&profiler_label, 1);\n }\n \n /* Output instructions as RTL to increment the edge execution count.  */\n@@ -1386,3 +1385,5 @@ output_func_start_profiler ()\n     (* targetm.asm_out.constructor) (XEXP (DECL_RTL (fndecl), 0),\n \t\t\t\t     DEFAULT_INIT_PRIORITY);\n }\n+\n+#include \"gt-profile.h\""}, {"sha": "174d2c46abff1d6e64b0e593114231196f54ad2b", "filename": "gcc/real.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Freal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Freal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.h?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -89,7 +89,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #define REAL_WIDTH \\\n   (REAL_VALUE_TYPE_SIZE/HOST_BITS_PER_WIDE_INT \\\n    + (REAL_VALUE_TYPE_SIZE%HOST_BITS_PER_WIDE_INT ? 1 : 0)) /* round up */\n-struct realvaluetype {\n+struct realvaluetype GTY(()) {\n   HOST_WIDE_INT r[REAL_WIDTH];\n };\n /* Various headers condition prototypes on #ifdef REAL_VALUE_TYPE, so it needs"}, {"sha": "90a3cbf002897a937d59df86338a83bcfe796016", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -167,6 +167,15 @@\n #include \"basic-block.h\"\n #include \"varray.h\"\n #include \"reload.h\"\n+#include \"ggc.h\"\n+\n+/* We use this array to cache info about insns, because otherwise we\n+   spend too much time in stack_regs_mentioned_p.\n+\n+   Indexed by insn UIDs.  A value of zero is uninitialized, one indicates\n+   the insn uses stack registers, two indicates the insn does not use\n+   stack registers.  */\n+static GTY(()) varray_type stack_regs_mentioned_data;\n \n #ifdef STACK_REGS\n \n@@ -210,14 +219,6 @@ enum emit_where\n   EMIT_BEFORE\n };\n \n-/* We use this array to cache info about insns, because otherwise we\n-   spend too much time in stack_regs_mentioned_p.\n-\n-   Indexed by insn UIDs.  A value of zero is uninitialized, one indicates\n-   the insn uses stack registers, two indicates the insn does not use\n-   stack registers.  */\n-static varray_type stack_regs_mentioned_data;\n-\n /* The block we're currently working on.  */\n static basic_block current_block;\n \n@@ -423,11 +424,7 @@ reg_to_stack (first, file)\n   int max_uid;\n \n   /* Clean up previous run.  */\n-  if (stack_regs_mentioned_data)\n-    {\n-      VARRAY_FREE (stack_regs_mentioned_data);\n-      stack_regs_mentioned_data = 0;\n-    }\n+  stack_regs_mentioned_data = 0;\n \n   if (!optimize)\n     split_all_insns (0);\n@@ -2862,3 +2859,5 @@ convert_regs (file)\n   return inserted;\n }\n #endif /* STACK_REGS */\n+\n+#include \"gt-reg-stack.h\""}, {"sha": "84c7ba330bbe058af3745232c2951c956aac04d2", "filename": "gcc/regclass.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -242,13 +242,9 @@ static regset reg_changes_mode;\n \n #endif /* CLASS_CANNOT_CHANGE_MODE */\n \n-#ifdef HAVE_SECONDARY_RELOADS\n-\n /* Sample MEM values for use by memory_move_secondary_cost.  */\n \n-static rtx top_of_stack[MAX_MACHINE_MODE];\n-\n-#endif /* HAVE_SECONDARY_RELOADS */\n+static GTY(()) rtx top_of_stack[MAX_MACHINE_MODE];\n \n /* Linked list of reg_info structures allocated for reg_n_info array.\n    Grouping all of the allocated structures together in one lump\n@@ -614,7 +610,6 @@ init_regs ()\n \n     for (i = 0; i < MAX_MACHINE_MODE; i++)\n       top_of_stack[i] = gen_rtx_MEM (i, stack_pointer_rtx);\n-    ggc_add_rtx_root (top_of_stack, MAX_MACHINE_MODE);\n   }\n #endif\n }\n@@ -2598,3 +2593,5 @@ regset_release_memory ()\n {\n   bitmap_release_memory ();\n }\n+\n+#include \"gt-regclass.h\""}, {"sha": "35e1f2fc5289e3eba4ce4ca9694ddbedd983e9ef", "filename": "gcc/rtl.h", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -89,7 +89,7 @@ typedef struct\n    so MEMs that the same attributes share a data structure.  This means\n    they cannot be modified in place.  If any element is nonzero, it means\n    the value of the corresponding attribute is unknown.  */\n-typedef struct\n+typedef struct mem_attrs GTY(())\n {\n   HOST_WIDE_INT alias;\t\t/* Memory alias set.  */\n   tree expr;\t\t\t/* expr corresponding to MEM.  */\n@@ -212,9 +212,9 @@ struct rtx_def\n    for a variable number of things.  The principle use is inside\n    PARALLEL expressions.  */\n \n-struct rtvec_def {\n+struct rtvec_def GTY(()) {\n   int num_elem;\t\t/* number of elements */\n-  rtx elem[1];\n+  rtx GTY ((length (\"%h.num_elem\"))) elem[1];\n };\n \n #define NULL_RTVEC (rtvec) 0\n@@ -1677,7 +1677,9 @@ extern bool keep_with_call_p\t\tPARAMS ((rtx));\n /* flow.c */\n \n extern rtx find_use_as_address\t\tPARAMS ((rtx, rtx, HOST_WIDE_INT));\n-void init_EXPR_INSN_LIST_cache\t\tPARAMS ((void));\n+\n+/* lists.c */\n+\n void free_EXPR_LIST_list \t\tPARAMS ((rtx *));\n void free_INSN_LIST_list \t\tPARAMS ((rtx *));\n void free_EXPR_LIST_node \t\tPARAMS ((rtx));\n@@ -1711,15 +1713,15 @@ extern void split_all_insns\t\tPARAMS ((int));\n extern void split_all_insns_noflow\tPARAMS ((void));\n \n #define MAX_SAVED_CONST_INT 64\n-extern rtx const_int_rtx[MAX_SAVED_CONST_INT * 2 + 1];\n+extern GTY(()) rtx const_int_rtx[MAX_SAVED_CONST_INT * 2 + 1];\n \n #define const0_rtx\t(const_int_rtx[MAX_SAVED_CONST_INT])\n #define const1_rtx\t(const_int_rtx[MAX_SAVED_CONST_INT+1])\n #define const2_rtx\t(const_int_rtx[MAX_SAVED_CONST_INT+2])\n #define constm1_rtx\t(const_int_rtx[MAX_SAVED_CONST_INT-1])\n-extern rtx const_true_rtx;\n+extern GTY(()) rtx const_true_rtx;\n \n-extern rtx const_tiny_rtx[3][(int) MAX_MACHINE_MODE];\n+extern GTY(()) rtx const_tiny_rtx[3][(int) MAX_MACHINE_MODE];\n \n /* Returns a constant 0 rtx in mode MODE.  Integer modes are treated the\n    same as VOIDmode.  */\n@@ -1776,7 +1778,7 @@ enum global_rtl_index\n };\n \n /* Pointers to standard pieces of rtx are stored here.  */\n-extern rtx global_rtl[GR_MAX];\n+extern GTY(()) rtx global_rtl[GR_MAX];\n \n /* Standard pieces of rtx, to be substituted directly into things.  */\n #define pc_rtx                  (global_rtl[GR_PC])\n@@ -1790,12 +1792,12 @@ extern rtx global_rtl[GR_MAX];\n #define hard_frame_pointer_rtx\t(global_rtl[GR_HARD_FRAME_POINTER])\n #define arg_pointer_rtx\t\t(global_rtl[GR_ARG_POINTER])\n \n-extern rtx pic_offset_table_rtx;\n-extern rtx struct_value_rtx;\n-extern rtx struct_value_incoming_rtx;\n-extern rtx static_chain_rtx;\n-extern rtx static_chain_incoming_rtx;\n-extern rtx return_address_pointer_rtx;\n+extern GTY(()) rtx pic_offset_table_rtx;\n+extern GTY(()) rtx struct_value_rtx;\n+extern GTY(()) rtx struct_value_incoming_rtx;\n+extern GTY(()) rtx static_chain_rtx;\n+extern GTY(()) rtx static_chain_incoming_rtx;\n+extern GTY(()) rtx return_address_pointer_rtx;\n \n /* Include the RTL generation functions.  */\n \n@@ -2278,7 +2280,7 @@ extern int stack_regs_mentioned\t\tPARAMS ((rtx insn));\n #endif\n \n /* In toplev.c */\n-extern rtx stack_limit_rtx;\n+extern GTY(()) rtx stack_limit_rtx;\n \n /* In regrename.c */\n extern void regrename_optimize\t\tPARAMS ((void));"}, {"sha": "0ec5abb5631cb3b8a16caacd35e60ddc262bf912", "filename": "gcc/sdbout.c", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fsdbout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fsdbout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsdbout.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -42,22 +42,24 @@ AT&T C compiler.  From the example below I would conclude the following:\n */\n \n #include \"config.h\"\n+#include \"system.h\"\n+#include \"debug.h\"\n+#include \"tree.h\"\n+#include \"ggc.h\"\n+\n+static GTY(()) tree anonymous_types;\n \n #ifdef SDB_DEBUGGING_INFO\n \n-#include \"system.h\"\n-#include \"tree.h\"\n #include \"rtl.h\"\n #include \"regs.h\"\n #include \"flags.h\"\n #include \"insn-config.h\"\n #include \"reload.h\"\n #include \"output.h\"\n #include \"toplev.h\"\n-#include \"ggc.h\"\n #include \"tm_p.h\"\n #include \"gsyms.h\"\n-#include \"debug.h\"\n #include \"langhooks.h\"\n \n /* 1 if PARM is passed to this function in memory.  */\n@@ -989,8 +991,6 @@ sdbout_toplevel_data (decl)\n \n /* Machinery to record and output anonymous types.  */\n \n-static tree anonymous_types;\n-\n static void\n sdbout_queue_anonymous_type (type)\n      tree type;\n@@ -1759,11 +1759,14 @@ sdbout_init (input_file_name)\n     if (DECL_NAME (t) && IDENTIFIER_POINTER (DECL_NAME (t)) != 0\n \t&& !strcmp (IDENTIFIER_POINTER (DECL_NAME (t)), \"__vtbl_ptr_type\"))\n       sdbout_symbol (t, 0);\n-#endif\n-\n-#ifdef SDB_ALLOW_FORWARD_REFERENCES\n-  ggc_add_tree_root (&anonymous_types, 1);\n-#endif\n+#endif  \n }\n \n+#else  /* SDB_DEBUGGING_INFO */\n+\n+/* This should never be used, but its address is needed for comparisons.  */\n+const struct gcc_debug_hooks sdb_debug_hooks;\n+\n #endif /* SDB_DEBUGGING_INFO */\n+\n+#include \"gt-sdbout.h\""}, {"sha": "4f89941fa8599c448fbe3251a20f060f992364f8", "filename": "gcc/ssa-dce.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fssa-dce.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -734,7 +734,6 @@ ssa_eliminate_dead_code ()\n     RESURRECT_INSN (insn);\n   if (VARRAY_ACTIVE_SIZE (unprocessed_instructions) != 0)\n     abort ();\n-  VARRAY_FREE (unprocessed_instructions);\n   control_dependent_block_to_edge_map_free (cdbte);\n   free ((PTR) pdom);\n   free_edge_list (el);"}, {"sha": "4c989d764e404e8e1c42da18cc066ceea96575bf", "filename": "gcc/ssa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fssa.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -2220,7 +2220,7 @@ convert_from_ssa ()\n   count_or_remove_death_notes (NULL, 1);\n \n   /* Deallocate the data structures.  */\n-  VARRAY_FREE (ssa_definition);\n+  ssa_definition = 0;\n   ssa_rename_from_free ();\n }\n "}, {"sha": "cbea11c3d5cccbf3d50ee50e6c813f1c5050fb3c", "filename": "gcc/ssa.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fssa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fssa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fssa.h?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a", "patch": "@@ -44,7 +44,7 @@ extern void ssa_const_prop\t\tPARAMS ((void));\n extern int in_ssa_form;\n \n /* Element I is the single instruction that sets register I.  */\n-extern varray_type ssa_definition;\n+extern GTY(()) varray_type ssa_definition;\n \n /* Element I is an INSN_LIST of instructions that use register I.  */\n extern varray_type ssa_uses;"}, {"sha": "4994fe21c3b40ef046fadff2035101b523c652c4", "filename": "gcc/stmt.c", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a"}, {"sha": "8569ca2538dc8d00d9dcba757bd0e1454576a282", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a"}, {"sha": "639048625d969f86d4cac3c078b7b0af0e4bbc7d", "filename": "gcc/stringpool.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fstringpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fstringpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstringpool.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a"}, {"sha": "e028df177e3296180ee79d83f3ce1136481cbea2", "filename": "gcc/system.h", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a"}, {"sha": "b2111dcf4d5f0b3e885001e6be0db57d1eab149c", "filename": "gcc/tlink.c", "status": "modified", "additions": 82, "deletions": 109, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Ftlink.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Ftlink.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftlink.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a"}, {"sha": "9dd6468aebb17700e38a62c1721ad1e2e953748b", "filename": "gcc/toplev.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a"}, {"sha": "145cfe8f75cf02950c54417cf4d598d9b6055368", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a"}, {"sha": "1ee045b906565b3121b2479d5805be909a5feb3b", "filename": "gcc/tree.c", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a"}, {"sha": "4888bc72fe7a4d1b5b8207f53888dcb491954ed6", "filename": "gcc/tree.h", "status": "modified", "additions": 81, "deletions": 49, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a"}, {"sha": "1b728bb2549edacaa75e3e855936e116e22e65ab", "filename": "gcc/varasm.c", "status": "modified", "additions": 180, "deletions": 582, "changes": 762, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a"}, {"sha": "51e3e8bc142ed9d5c6a848874c31101fbaeea304", "filename": "gcc/varray.c", "status": "modified", "additions": 59, "deletions": 13, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fvarray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fvarray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarray.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a"}, {"sha": "8d4dafb6ca66797fa145526634e5eed571a31bc2", "filename": "gcc/varray.h", "status": "modified", "additions": 103, "deletions": 56, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fvarray.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/gcc%2Fvarray.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarray.h?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a"}, {"sha": "75ce45ab2764df1797490ab31dab00261acc2304", "filename": "include/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a"}, {"sha": "a3ae5ae37fa7622e243309c03b0ed497ce29e336", "filename": "include/hashtab.h", "status": "modified", "additions": 26, "deletions": 13, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/include%2Fhashtab.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/include%2Fhashtab.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fhashtab.h?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a"}, {"sha": "5abfbebaa26736355466c381f64b847b462a420b", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a"}, {"sha": "06e41ac29e5021162b77be0e21e78afcffc781fb", "filename": "libiberty/hashtab.c", "status": "modified", "additions": 22, "deletions": 45, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/libiberty%2Fhashtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2500fedef1a1c5b9e818fd1e2c281adff80df4a/libiberty%2Fhashtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fhashtab.c?ref=e2500fedef1a1c5b9e818fd1e2c281adff80df4a"}]}