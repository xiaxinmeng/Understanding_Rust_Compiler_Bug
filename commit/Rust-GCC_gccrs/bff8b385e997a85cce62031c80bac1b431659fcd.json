{"sha": "bff8b385e997a85cce62031c80bac1b431659fcd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmZmOGIzODVlOTk3YTg1Y2NlNjIwMzFjODBiYWMxYjQzMTY1OWZjZA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-08-25T11:37:10Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-08-25T11:37:10Z"}, "message": "Conversion operators have a special name\n\n\tConversion operators have a special name\n\t* cp-tree.h (CPTI_CONV_OP_MARKER, CPTI_CONV_OP_IDENTIFIER): New.\n\t(conv_op_marker, conv_op_identifier): New.\n\t(CLASSTYPE_FIRST_CONVERSION_SLOT): Delete.\n\t* decl.c (initialize_predefined_identifiers): Add\n\tconv_op_identifier.\n\t(cxx_init_decl_processing): Create conv_op_marker.\n\t* decl2.c (check_classfn): Lookup conv-ops by name.\n\t* class.c (add_method): Use conv_op_identifier & conv_op_marker.\n\t(resort_type_method_vec): Don't skip conv-ops.\n\t(finish_struct_methods, warn_hidden): Likewise.\n\t* name-lookup.h (lookup_all_conversions): Delete.\n\t* name-lookup.c (lookup_conversion_operator): Replace with ...\n\t(extract_conversion_operator): ... this.\n\t(lookup_fnfields_slot_nolazy): Find conv-ops by name.\n\t(lookup_all_conversions): Delete.\n\t* pt.c (check_explicit_specialization): Find conv-ops by name.\n\t* search.c (lookup_conversions_r): Likewise.\n\nFrom-SVN: r251348", "tree": {"sha": "f02f660066158abece2226c1baa96e2f8c16f826", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f02f660066158abece2226c1baa96e2f8c16f826"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bff8b385e997a85cce62031c80bac1b431659fcd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bff8b385e997a85cce62031c80bac1b431659fcd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bff8b385e997a85cce62031c80bac1b431659fcd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bff8b385e997a85cce62031c80bac1b431659fcd/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6512c0f187d84dd046380aa53673dc5ae20795e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6512c0f187d84dd046380aa53673dc5ae20795e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6512c0f187d84dd046380aa53673dc5ae20795e3"}], "stats": {"total": 281, "additions": 132, "deletions": 149}, "files": [{"sha": "3557e4881dcdc78065ecf7149f1ef5a5d94d16cf", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bff8b385e997a85cce62031c80bac1b431659fcd/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bff8b385e997a85cce62031c80bac1b431659fcd/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=bff8b385e997a85cce62031c80bac1b431659fcd", "patch": "@@ -1,3 +1,24 @@\n+2017-08-25  Nathan Sidwell  <nathan@acm.org>\n+\n+\tConversion operators have a special name\n+\t* cp-tree.h (CPTI_CONV_OP_MARKER, CPTI_CONV_OP_IDENTIFIER): New.\n+\t(conv_op_marker, conv_op_identifier): New.\n+\t(CLASSTYPE_FIRST_CONVERSION_SLOT): Delete.\n+\t* decl.c (initialize_predefined_identifiers): Add\n+\tconv_op_identifier.\n+\t(cxx_init_decl_processing): Create conv_op_marker.\n+\t* decl2.c (check_classfn): Lookup conv-ops by name.\n+\t* class.c (add_method): Use conv_op_identifier & conv_op_marker.\n+\t(resort_type_method_vec): Don't skip conv-ops.\n+\t(finish_struct_methods, warn_hidden): Likewise.\n+\t* name-lookup.h (lookup_all_conversions): Delete.\n+\t* name-lookup.c (lookup_conversion_operator): Replace with ...\n+\t(extract_conversion_operator): ... this.\n+\t(lookup_fnfields_slot_nolazy): Find conv-ops by name.\n+\t(lookup_all_conversions): Delete.\n+\t* pt.c (check_explicit_specialization): Find conv-ops by name.\n+\t* search.c (lookup_conversions_r): Likewise.\n+\n 2017-08-24  Nathan Sidwell  <nathan@acm.org>\n \n \tConversion operators kept on single overload set"}, {"sha": "fc37bd8aa9c8e0085068fdfe453a6e7308d67b46", "filename": "gcc/cp/class.c", "status": "modified", "additions": 43, "deletions": 58, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bff8b385e997a85cce62031c80bac1b431659fcd/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bff8b385e997a85cce62031c80bac1b431659fcd/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=bff8b385e997a85cce62031c80bac1b431659fcd", "patch": "@@ -1017,9 +1017,6 @@ add_method (tree type, tree method, bool via_using)\n   if (method == error_mark_node)\n     return false;\n \n-  bool complete_p = COMPLETE_TYPE_P (type);\n-  bool conv_p = DECL_CONV_FN_P (method);\n-\n   vec<tree, va_gc> *method_vec = CLASSTYPE_METHOD_VEC (type);\n   if (!method_vec)\n     {\n@@ -1032,32 +1029,45 @@ add_method (tree type, tree method, bool via_using)\n   grok_special_member_properties (method);\n \n   bool insert_p = true;\n-  unsigned slot;\n-  tree m;\n+  tree method_name = DECL_NAME (method);\n+  bool complete_p = COMPLETE_TYPE_P (type);\n+  bool conv_p = IDENTIFIER_CONV_OP_P (method_name);\n+\n+  if (conv_p)\n+    method_name = conv_op_identifier;\n \n   /* See if we already have an entry with this name.  */\n-  for (slot = CLASSTYPE_FIRST_CONVERSION_SLOT;\n-       vec_safe_iterate (method_vec, slot, &m);\n-       ++slot)\n+  unsigned slot;\n+  tree m;\n+  for (slot = 0; vec_safe_iterate (method_vec, slot, &m); ++slot)\n     {\n-      m = OVL_FIRST (m);\n-      if (conv_p)\n-\t{\n-\t  if (DECL_CONV_FN_P (m))\n-\t    insert_p = false;\n-\t  break;\n-\t}\n-      if (DECL_NAME (m) == DECL_NAME (method))\n+      m = DECL_NAME (OVL_FIRST (m));\n+      if (m == method_name)\n \t{\n \t  insert_p = false;\n \t  break;\n \t}\n-      if (complete_p\n-\t  && !DECL_CONV_FN_P (m)\n-\t  && DECL_NAME (m) > DECL_NAME (method))\n+      if (complete_p && m > method_name)\n \tbreak;\n     }\n   tree current_fns = insert_p ? NULL_TREE : (*method_vec)[slot];\n+\n+  tree conv_marker = NULL_TREE;\n+  if (conv_p)\n+    {\n+      /* For conversion operators, we prepend a dummy overload\n+\t pointing at conv_op_marker.  That function's DECL_NAME is\n+\t conv_op_identifier, so we can use identifier equality to\n+\t locate it.  */\n+      if (current_fns)\n+\t{\n+\t  gcc_checking_assert (OVL_FUNCTION (current_fns) == conv_op_marker);\n+\t  conv_marker = current_fns;\n+\t  current_fns = OVL_CHAIN (current_fns);\n+\t}\n+      else\n+\tconv_marker = ovl_make (conv_op_marker, NULL_TREE);\n+    }\n   gcc_assert (!DECL_EXTERN_C_P (method));\n \n   /* Check to see if we've already got this method.  */\n@@ -1206,7 +1216,12 @@ add_method (tree type, tree method, bool via_using)\n   current_fns = ovl_insert (method, current_fns, via_using);\n \n   if (conv_p)\n-    TYPE_HAS_CONVERSION (type) = 1;\n+    {\n+      TYPE_HAS_CONVERSION (type) = 1;\n+      /* Prepend the marker function.  */\n+      OVL_CHAIN (conv_marker) = current_fns;\n+      current_fns = conv_marker;\n+    }\n   else if (!complete_p && !IDENTIFIER_CDTOR_P (DECL_NAME (method)))\n     push_class_level_binding (DECL_NAME (method), current_fns);\n \n@@ -2294,23 +2309,10 @@ resort_type_method_vec (void* obj,\n {\n   if (vec<tree, va_gc> *method_vec = (vec<tree, va_gc> *) obj)\n     {\n-      int len = method_vec->length ();\n-      int slot;\n-\n-      /* The type conversion ops have to live at the front of the vec, so we\n-\t can't sort them.  */\n-      for (slot = CLASSTYPE_FIRST_CONVERSION_SLOT;\n-\t   slot < len; slot++)\n-\tif (!DECL_CONV_FN_P (OVL_FIRST ((*method_vec)[slot])))\n-\t  break;\n-\n-      if (len > slot + 1)\n-\t{\n-\t  resort_data.new_value = new_value;\n-\t  resort_data.cookie = cookie;\n-\t  qsort (method_vec->address () + slot, len - slot, sizeof (tree),\n-\t\t resort_method_name_cmp);\n-\t}\n+      resort_data.new_value = new_value;\n+      resort_data.cookie = cookie;\n+      qsort (method_vec->address (), method_vec->length (), sizeof (tree),\n+\t     resort_method_name_cmp);\n     }\n }\n \n@@ -2323,15 +2325,10 @@ resort_type_method_vec (void* obj,\n static void\n finish_struct_methods (tree t)\n {\n-  vec<tree, va_gc> *method_vec;\n-  int slot, len;\n-\n-  method_vec = CLASSTYPE_METHOD_VEC (t);\n+  vec<tree, va_gc> *method_vec = CLASSTYPE_METHOD_VEC (t);\n   if (!method_vec)\n     return;\n \n-  len = method_vec->length ();\n-\n   /* Clear DECL_IN_AGGR_P for all functions.  */\n   for (tree fn = TYPE_FIELDS (t); fn; fn = DECL_CHAIN (fn))\n     if (DECL_DECLARES_FUNCTION_P (fn))\n@@ -2341,17 +2338,8 @@ finish_struct_methods (tree t)\n      no methods, then some public defaults are generated.  */\n   maybe_warn_about_overly_private_class (t);\n \n-  /* The type conversion ops have to live at the front of the vec, so we\n-     can't sort them.  */\n-  tree fn_fields;\n-  for (slot = CLASSTYPE_FIRST_CONVERSION_SLOT;\n-       method_vec->iterate (slot, &fn_fields);\n-       ++slot)\n-    if (!DECL_CONV_FN_P (OVL_FIRST (fn_fields)))\n-      break;\n-  if (len - slot > 1)\n-    qsort (method_vec->address () + slot,\n-\t   len-slot, sizeof (tree), method_name_cmp);\n+  qsort (method_vec->address (), method_vec->length (),\n+\t sizeof (tree), method_name_cmp);\n }\n \n /* Make BINFO's vtable have N entries, including RTTI entries,\n@@ -3000,12 +2988,9 @@ warn_hidden (tree t)\n {\n   vec<tree, va_gc> *method_vec = CLASSTYPE_METHOD_VEC (t);\n   tree fns;\n-  size_t i;\n \n   /* We go through each separately named virtual function.  */\n-  for (i = CLASSTYPE_FIRST_CONVERSION_SLOT;\n-       vec_safe_iterate (method_vec, i, &fns);\n-       ++i)\n+  for (int i = 0; vec_safe_iterate (method_vec, i, &fns); ++i)\n     {\n       tree fndecl;\n       tree base_binfo;"}, {"sha": "d04c00cf4cf90a98a8eb712075a7bc58e42b630d", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bff8b385e997a85cce62031c80bac1b431659fcd/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bff8b385e997a85cce62031c80bac1b431659fcd/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=bff8b385e997a85cce62031c80bac1b431659fcd", "patch": "@@ -125,6 +125,7 @@ enum cp_tree_index\n     CPTI_TYPE_INFO_PTR_TYPE,\n     CPTI_ABORT_FNDECL,\n     CPTI_AGGR_TAG,\n+    CPTI_CONV_OP_MARKER,\n \n     CPTI_CTOR_IDENTIFIER,\n     CPTI_COMPLETE_CTOR_IDENTIFIER,\n@@ -133,6 +134,7 @@ enum cp_tree_index\n     CPTI_COMPLETE_DTOR_IDENTIFIER,\n     CPTI_BASE_DTOR_IDENTIFIER,\n     CPTI_DELETING_DTOR_IDENTIFIER,\n+    CPTI_CONV_OP_IDENTIFIER,\n     CPTI_DELTA_IDENTIFIER,\n     CPTI_IN_CHARGE_IDENTIFIER,\n     CPTI_VTT_PARM_IDENTIFIER,\n@@ -199,6 +201,7 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n #define global_type_node\t\tcp_global_trees[CPTI_GLOBAL_TYPE]\n #define const_type_info_type_node\tcp_global_trees[CPTI_CONST_TYPE_INFO_TYPE]\n #define type_info_ptr_type\t\tcp_global_trees[CPTI_TYPE_INFO_PTR_TYPE]\n+#define conv_op_marker\t\t\tcp_global_trees[CPTI_CONV_OP_MARKER]\n #define abort_fndecl\t\t\tcp_global_trees[CPTI_ABORT_FNDECL]\n #define current_aggr\t\t\tcp_global_trees[CPTI_AGGR_TAG]\n #define nullptr_node\t\t\tcp_global_trees[CPTI_NULLPTR]\n@@ -239,6 +242,10 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n /* The name of a destructor that destroys virtual base classes, and\n    then deletes the entire object.  */\n #define deleting_dtor_identifier\tcp_global_trees[CPTI_DELETING_DTOR_IDENTIFIER]\n+/* The name used for conversion operators -- but note that actual\n+   conversion functions use special identifiers outside the identifier\n+   table.  */\n+#define conv_op_identifier\t\tcp_global_trees[CPTI_CONV_OP_IDENTIFIER]\n \n /* The name of the identifier used internally to represent operator CODE.  */\n #define cp_operator_id(CODE) \\\n@@ -2148,10 +2155,6 @@ struct GTY(()) lang_type {\n    and the RECORD_TYPE for the class template otherwise.  */\n #define CLASSTYPE_DECL_LIST(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->decl_list)\n \n-/* The first slot in the CLASSTYPE_METHOD_VEC where conversion\n-   operators can appear.  */\n-#define CLASSTYPE_FIRST_CONVERSION_SLOT 0\n-\n /* A FUNCTION_DECL or OVERLOAD for the constructors for NODE.  These\n    are the constructors that take an in-charge parameter.  */\n #define CLASSTYPE_CONSTRUCTORS(NODE) \\"}, {"sha": "bd6926a486a9f8ad458457a37c1c79ffc4f094b4", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bff8b385e997a85cce62031c80bac1b431659fcd/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bff8b385e997a85cce62031c80bac1b431659fcd/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=bff8b385e997a85cce62031c80bac1b431659fcd", "patch": "@@ -3979,6 +3979,7 @@ initialize_predefined_identifiers (void)\n     {\"__dt_base \", &base_dtor_identifier, cik_dtor},\n     {\"__dt_comp \", &complete_dtor_identifier, cik_dtor},\n     {\"__dt_del \", &deleting_dtor_identifier, cik_dtor},\n+    {\"__conv_op \", &conv_op_identifier, cik_conv_op},\n     {\"__in_chrg\", &in_charge_identifier, cik_normal},\n     {\"this\", &this_identifier, cik_normal},\n     {\"__delta\", &delta_identifier, cik_normal},\n@@ -4072,6 +4073,13 @@ cxx_init_decl_processing (void)\n   noexcept_deferred_spec = build_tree_list (make_node (DEFERRED_NOEXCEPT),\n \t\t\t\t\t    NULL_TREE);\n \n+  /* Create the conversion operator marker.  This operator's DECL_NAME\n+     is in the identifier table, so we can use identifier equality to\n+     find it.  This has no type and no context, so we can't\n+     accidentally think it a real function.  */\n+  conv_op_marker = build_lang_decl (FUNCTION_DECL, conv_op_identifier,\n+\t\t\t\t    NULL_TREE);\n+\n #if 0\n   record_builtin_type (RID_MAX, NULL, string_type_node);\n #endif"}, {"sha": "0f828b57396365684ce06ca5a6a6c91b899ffe58", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bff8b385e997a85cce62031c80bac1b431659fcd/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bff8b385e997a85cce62031c80bac1b431659fcd/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=bff8b385e997a85cce62031c80bac1b431659fcd", "patch": "@@ -664,7 +664,7 @@ check_classfn (tree ctype, tree function, tree template_parms)\n       else\n \t{\n \t  if (DECL_CONV_FN_P (function))\n-\t    fns = lookup_all_conversions (ctype);\n+\t    fns = lookup_fnfields_slot (ctype, conv_op_identifier);\n \n \t  error_at (DECL_SOURCE_LOCATION (function),\n \t\t    \"no declaration matches %q#D\", function);"}, {"sha": "df29331b95db55f5c6f0ccae9bf7317f86a719ea", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 43, "deletions": 69, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bff8b385e997a85cce62031c80bac1b431659fcd/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bff8b385e997a85cce62031c80bac1b431659fcd/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=bff8b385e997a85cce62031c80bac1b431659fcd", "patch": "@@ -1089,37 +1089,27 @@ lookup_arg_dependent (tree name, tree fns, vec<tree, va_gc> *args)\n   return fns;\n }\n \n-/* Return the conversion operators in CLASS_TYPE corresponding to\n-   \"operator TYPE ()\".  Only CLASS_TYPE itself is searched; this\n-   routine does not scan the base classes of CLASS_TYPE.  */\n+/* FNS is an overload set of conversion functions.  Return the\n+   overloads converting to TYPE.  */\n \n static tree\n-lookup_conversion_operator (tree class_type, tree type)\n+extract_conversion_operator (tree fns, tree type)\n {\n   tree convs = NULL_TREE;\n+  tree tpls = NULL_TREE;\n \n-  if (TYPE_HAS_CONVERSION (class_type))\n+  for (ovl_iterator iter (fns); iter; ++iter)\n     {\n-      tree fns = NULL_TREE;\n-      tree tpls = NULL_TREE;\n-      vec<tree, va_gc> *methods = CLASSTYPE_METHOD_VEC (class_type);\n+      if (same_type_p (DECL_CONV_FN_TYPE (*iter), type))\n+\tconvs = lookup_add (*iter, convs);\n \n-      vec_safe_iterate (methods, CLASSTYPE_FIRST_CONVERSION_SLOT, &fns);\n-      if (fns && !DECL_CONV_FN_P (OVL_FIRST (fns)))\n-\tfns = NULL_TREE;\n-      for (ovl_iterator iter (fns); iter; ++iter)\n-\t{\n-\t  if (same_type_p (DECL_CONV_FN_TYPE (*iter), type))\n-\t    convs = lookup_add (*iter, convs);\n-\n-\t  if (TREE_CODE (*iter) == TEMPLATE_DECL)\n-\t    tpls = lookup_add (*iter, tpls);\n-\t}\n-\n-      if (!convs)\n-\tconvs = tpls;\n+      if (TREE_CODE (*iter) == TEMPLATE_DECL)\n+\ttpls = lookup_add (*iter, tpls);\n     }\n \n+  if (!convs)\n+    convs = tpls;\n+\n   return convs;\n }\n \n@@ -1134,48 +1124,56 @@ lookup_fnfields_slot_nolazy (tree type, tree name)\n   if (!method_vec)\n     return NULL_TREE;\n \n-  if (IDENTIFIER_CONV_OP_P (name))\n-    return lookup_conversion_operator (type, TREE_TYPE (name));\n-\n-  /* Skip the conversion operators.  */\n-  int i;\n+  /* Conversion operators can only be found by the marker conversion\n+     operator name.  */\n+  bool conv_op = IDENTIFIER_CONV_OP_P (name);\n+  tree lookup = conv_op ? conv_op_identifier : name;\n+  tree val = NULL_TREE;\n   tree fns;\n-  for (i = CLASSTYPE_FIRST_CONVERSION_SLOT;\n-       vec_safe_iterate (method_vec, i, &fns);\n-       ++i)\n-    if (!DECL_CONV_FN_P (OVL_FIRST (fns)))\n-      break;\n \n   /* If the type is complete, use binary search.  */\n   if (COMPLETE_TYPE_P (type))\n     {\n-      int lo;\n-      int hi;\n-\n-      lo = i;\n-      hi = method_vec->length ();\n+      int lo = 0;\n+      int hi = method_vec->length ();\n       while (lo < hi)\n \t{\n-\t  i = (lo + hi) / 2;\n+\t  int i = (lo + hi) / 2;\n \n \t  fns = (*method_vec)[i];\n \t  tree fn_name = OVL_NAME (fns);\n-\t  if (fn_name > name)\n+\t  if (fn_name > lookup)\n \t    hi = i;\n-\t  else if (fn_name < name)\n+\t  else if (fn_name < lookup)\n \t    lo = i + 1;\n \t  else\n-\t    return fns;\n+\t    {\n+\t      val = fns;\n+\t      break;\n+\t    }\n \t}\n     }\n   else\n-    for (; vec_safe_iterate (method_vec, i, &fns); ++i)\n+    for (int i = 0; vec_safe_iterate (method_vec, i, &fns); ++i)\n       {\n-\tif (OVL_NAME (fns) == name)\n-\t  return fns;\n+\tif (OVL_NAME (fns) == lookup)\n+\t  {\n+\t    val = fns;\n+\t    break;\n+\t  }\n       }\n \n-  return NULL_TREE;\n+  /* Extract the conversion operators asked for, unless the general\n+     conversion operator was requested.   */\n+  if (val && conv_op)\n+    {\n+      gcc_checking_assert (OVL_FUNCTION (val) == conv_op_marker);\n+      val = OVL_CHAIN (val);\n+      if (tree type = TREE_TYPE (name))\n+\tval = extract_conversion_operator (val, type);\n+    }\n+\n+  return val;\n }\n \n /* Do a 1-level search for NAME as a member of TYPE.  The caller must\n@@ -1314,30 +1312,6 @@ lookup_fnfields_slot (tree type, tree name)\n   return lookup_fnfields_slot_nolazy (type, name);\n }\n \n-/* Collect all the conversion operators of KLASS.  */\n-\n-tree\n-lookup_all_conversions (tree klass)\n-{\n-  tree lkp = NULL_TREE;\n-\n-  if (vec<tree, va_gc> *methods = CLASSTYPE_METHOD_VEC (klass))\n-    {\n-      tree ovl;\n-      for (int idx = CLASSTYPE_FIRST_CONVERSION_SLOT;\n-\t   methods->iterate (idx, &ovl); ++idx)\n-\t{\n-\t  if (!DECL_CONV_FN_P (OVL_FIRST (ovl)))\n-\t    /* There are no more conversion functions.  */\n-\t    break;\n-\n-\t  lkp = lookup_add (ovl, lkp);\n-\t}\n-    }\n-\n-  return lkp;\n-}\n-\n /* Compute the chain index of a binding_entry given the HASH value of its\n    name and the total COUNT of chains.  COUNT is assumed to be a power\n    of 2.  */"}, {"sha": "99f9b9bb45d2d0ff63cc227b37575df13cff7162", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bff8b385e997a85cce62031c80bac1b431659fcd/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bff8b385e997a85cce62031c80bac1b431659fcd/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=bff8b385e997a85cce62031c80bac1b431659fcd", "patch": "@@ -322,7 +322,6 @@ extern tree lookup_arg_dependent (tree, tree, vec<tree, va_gc> *);\n extern tree lookup_field_1\t\t\t(tree, tree, bool);\n extern tree lookup_fnfields_slot\t\t(tree, tree);\n extern tree lookup_fnfields_slot_nolazy\t\t(tree, tree);\n-extern tree lookup_all_conversions\t\t(tree);\n extern tree innermost_non_namespace_value (tree);\n extern cxx_binding *outer_binding (tree, cxx_binding *, bool);\n extern void cp_emit_debug_info_for_using (tree, tree);"}, {"sha": "564ffb05f28849126da8a7af442f103aa5365de6", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bff8b385e997a85cce62031c80bac1b431659fcd/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bff8b385e997a85cce62031c80bac1b431659fcd/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=bff8b385e997a85cce62031c80bac1b431659fcd", "patch": "@@ -2894,16 +2894,13 @@ check_explicit_specialization (tree declarator,\n \t      name = DECL_NAME (decl);\n \t    }\n \n-\t  tree fns = NULL_TREE;\n-\t  if (DECL_CONV_FN_P (decl))\n-\t    /* For a type-conversion operator, we cannot do a\n-\t       name-based lookup.  We might be looking for `operator\n-\t       int' which will be a specialization of `operator T'.\n-\t       Grab all the conversion operators, and then select from\n-\t       them.  */\n-\t    fns = lookup_all_conversions (ctype);\n-\t  else\n-\t    fns = lookup_fnfields_slot_nolazy (ctype, name);\n+\t  /* For a type-conversion operator, We might be looking for\n+\t     `operator int' which will be a specialization of\n+\t     `operator T'.  Grab all the conversion operators, and\n+\t     then select from them.  */\n+\t  tree fns = lookup_fnfields_slot_nolazy (ctype,\n+\t\t\t\t\t\t  IDENTIFIER_CONV_OP_P (name)\n+\t\t\t\t\t\t  ? conv_op_identifier : name);\n \n \t  if (fns == NULL_TREE)\n \t    {"}, {"sha": "266d8dd36d6e3678475b59207b6acb05835a3a3a", "filename": "gcc/cp/search.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bff8b385e997a85cce62031c80bac1b431659fcd/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bff8b385e997a85cce62031c80bac1b431659fcd/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=bff8b385e997a85cce62031c80bac1b431659fcd", "patch": "@@ -2370,12 +2370,8 @@ lookup_conversions_r (tree binfo, int virtual_depth, int virtualness,\n     virtual_depth++;\n \n   /* First, locate the unhidden ones at this level.  */\n-  vec<tree, va_gc> *method_vec = CLASSTYPE_METHOD_VEC (BINFO_TYPE (binfo));\n-  tree conv = NULL_TREE;\n-  vec_safe_iterate (method_vec, CLASSTYPE_FIRST_CONVERSION_SLOT, &conv);\n-  if (conv && !DECL_CONV_FN_P (OVL_FIRST (conv)))\n-    conv = NULL_TREE;\n-\n+  tree conv = lookup_fnfields_slot_nolazy (BINFO_TYPE (binfo),\n+\t\t\t\t\t   conv_op_identifier);\n   for (ovl_iterator iter (conv); iter; ++iter)\n     {\n       tree fn = *iter;"}]}