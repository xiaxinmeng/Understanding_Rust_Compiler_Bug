{"sha": "1b992148d7a6a6b0fffd946131dd7cd6e6cc3958", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWI5OTIxNDhkN2E2YTZiMGZmZmQ5NDYxMzFkZDdjZDZlNmNjMzk1OA==", "commit": {"author": {"name": "Steve Chamberlain", "email": "sac@pobox.com", "date": "2000-01-05T05:57:17Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2000-01-05T05:57:17Z"}, "message": "configure.in: Add pj target.\n\n        * configure.in: Add pj target.\n        * configure: Regenerate.\n        * config/pj: New directory.\n        * config/pj/lib1funcs.S: New file.\n        * config/pj/linux.h: New file.\n        * config/pj/pj.c: New file.\n        * config/pj/pj.md: New file.\n        * config/pj/pjl.h: New file.\n        * config/pj/t-pj: New file.\n        * config/pj/xm-pj.h: New file\n\nFrom-SVN: r31225", "tree": {"sha": "2a608261fe1d5fa5730177f61de1aa3915d6188f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2a608261fe1d5fa5730177f61de1aa3915d6188f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1b992148d7a6a6b0fffd946131dd7cd6e6cc3958", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b992148d7a6a6b0fffd946131dd7cd6e6cc3958", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b992148d7a6a6b0fffd946131dd7cd6e6cc3958", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b992148d7a6a6b0fffd946131dd7cd6e6cc3958/comments", "author": {"login": "0x5ac", "id": 5324565, "node_id": "MDQ6VXNlcjUzMjQ1NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5324565?v=4", "gravatar_id": "", "url": "https://api.github.com/users/0x5ac", "html_url": "https://github.com/0x5ac", "followers_url": "https://api.github.com/users/0x5ac/followers", "following_url": "https://api.github.com/users/0x5ac/following{/other_user}", "gists_url": "https://api.github.com/users/0x5ac/gists{/gist_id}", "starred_url": "https://api.github.com/users/0x5ac/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/0x5ac/subscriptions", "organizations_url": "https://api.github.com/users/0x5ac/orgs", "repos_url": "https://api.github.com/users/0x5ac/repos", "events_url": "https://api.github.com/users/0x5ac/events{/privacy}", "received_events_url": "https://api.github.com/users/0x5ac/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "67e1e279c3b40476b000d67dfbc649e1aa6bc3ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67e1e279c3b40476b000d67dfbc649e1aa6bc3ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67e1e279c3b40476b000d67dfbc649e1aa6bc3ae"}], "stats": {"total": 4141, "additions": 4053, "deletions": 88}, "files": [{"sha": "6bde0bd13410fe1ec3fa7db6fafe015f74e560e1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b992148d7a6a6b0fffd946131dd7cd6e6cc3958/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b992148d7a6a6b0fffd946131dd7cd6e6cc3958/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1b992148d7a6a6b0fffd946131dd7cd6e6cc3958", "patch": "@@ -1,3 +1,16 @@\n+Tue Jan  4 22:55:41 2000  Steve Chamberlain <sac@pobox.com>\n+\n+\t* configure.in: Add pj target.\n+\t* configure: Regenerate.\n+\t* config/pj: New directory.\n+\t* config/pj/lib1funcs.S: New file.\n+\t* config/pj/linux.h: New file.\n+\t* config/pj/pj.c: New file.\n+\t* config/pj/pj.md: New file.\n+\t* config/pj/pjl.h: New file.\n+\t* config/pj/t-pj: New file.\n+\t* config/pj/xm-pj.h: New file\n+\n Tue Jan  4 22:30:16 2000  Jeffrey A Law  (law@cygnus.com)\n \n \t* toplev.c (rest_of_compilation): Run shorten-branches before"}, {"sha": "8f50b818c5c8c89bb6d77ff4ceee3e042c74997f", "filename": "gcc/config/pj/lib1funcs.S", "status": "added", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b992148d7a6a6b0fffd946131dd7cd6e6cc3958/gcc%2Fconfig%2Fpj%2Flib1funcs.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b992148d7a6a6b0fffd946131dd7cd6e6cc3958/gcc%2Fconfig%2Fpj%2Flib1funcs.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpj%2Flib1funcs.S?ref=1b992148d7a6a6b0fffd946131dd7cd6e6cc3958", "patch": "@@ -0,0 +1,192 @@\n+! lib1funcs.S for picoJava.\n+!   Copyright (C) 2000 Free Software Foundation, Inc.\n+! \n+! This file is free software; you can redistribute it and/or modify it\n+! under the terms of the GNU General Public License as published by the\n+! Free Software Foundation; either version 2, or (at your option) any\n+! later version.\n+! \n+! In addition to the permissions in the GNU General Public License, the\n+! Free Software Foundation gives you unlimited permission to link the\n+! compiled version of this file with other programs, and to distribute\n+! those programs without any restriction coming from the use of this\n+! file.  (The General Public License restrictions do apply in other\n+! respects; for example, they cover modification of the file, and\n+! distribution when not linked into another program.)\n+! \n+! This file is distributed in the hope that it will be useful, but\n+! WITHOUT ANY WARRANTY; without even the implied warranty of\n+! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+! General Public License for more details.\n+! \n+! You should have received a copy of the GNU General Public License\n+! along with this program; see the file COPYING.  If not, write to\n+! the Free Software Foundation, 59 Temple Place - Suite 330,\n+! Boston, MA 02111-1307, USA.\n+! \n+!    As a special exception, if you link this library with files\n+!    compiled with GCC to produce an executable, this does not cause\n+!    the resulting executable to be covered by the GNU General Public License.\n+!    This exception does not however invalidate any other reasons why\n+!    the executable file might be covered by the GNU General Public License.\n+! \n+\n+\n+#ifdef Lvhelper\n+\n+! The vhelper copies unnamed args in a varargs function from the\n+! opstack onto the aggregate stack.  It is a bit tricky since the\n+! opstack does not exist in real memory, so can not have its address taken,\n+! and since the opstack is being played with, there is nowhere to stick\n+! the temporaries.\n+\t\n+\t.globl __vhelper\n+__vhelper:\n+\n+\n+! incoming\n+! vars->  named0\n+!         named1\n+!         ...\n+!         unnamed0\n+!         unnamed1\n+!         ...\n+!         pc\n+!         vars\n+!         #named\n+!         return pc\n+\n+\t! work out total size everything below the named args and\t\n+\t! allocate that space on the aggregate stack + 3 extra words\n+\t! for some temps.\n+\t! g0   = old g0\n+\t! g0+4 = vars\n+\t! g0+8 = pc\n+\t! g0+12 = last unnamed arg\n+\t! ....\n+\n+\twrite_global1\n+\twrite_global2\n+\n+\t! tos = #named args provided by callee.\n+\n+\t! move down the aggstack to make room for all the unnamed args\n+\t! and the 12 bytes of extra stuff we have to pay attention to.\n+\t! g0 = old_g0 - ((vars - optop) + named_bytes + 12) - stuff we just pushed\n+\n+\t! build new global0\n+\tread_global0\n+ \t read_vars\n+\t  read_optop\n+\t isub                ! tos = vars - optop (# bytes in all args)\n+          bipush 4\n+         isub                ! subtract out fudge for current stuff on stack.\n+ \t  read_global2\n+\t isub                ! subtract out # words named.\n+        isub\n+\n+\tdup\n+\tdup\n+\t! store old global0 in new global0 spot.\n+\t\n+\tread_global0\n+        swap\n+\tstore_word\n+\n+\t! store new global0 value into global0\n+\twrite_global0\n+\n+\t! work out address to stop copying, which is vars - #named args bytes\n+\t! but since we will have pushed stuff onto the stack when the comparison\n+\t! is made, adjust by the fudge factor.\n+\t read_vars\n+ \t  read_global2\n+\t   bipush 12\n+\t  iadd\n+ \t isub\n+\n+\t! optop= finish, vars, pc, ... \n+\t! now pop off args from the opstack and copy to aggstack till all done.\n+\t! during the loop the opstack looks like\n+\t! (optop_finish_addr) (destination_addr) (named_n) (named_n-1) ....\n+\t! each iteration pops off one more element.\n+\n+\n+again:\n+\t  dup_x2\n+\t   read_optop\n+\t if_icmpeq done\n+\t  iconst_4\n+\t iadd \n+\t  dup_x2\n+\tstore_word\n+\tgoto again\n+\n+done:\n+\tdup2_x1 ; pop2 ; pop   !leave pointer on top.\n+\n+\t! return to caller with varargs pointer as\t\n+\t! the next argument and the restoring global0 as the next. \n+\n+\tread_global0 ; load_word\n+\n+\t! restore returning pc and vars\n+\tread_global0 ; bipush 8; iadd; load_word\n+\tread_global0 ; bipush 4; iadd; load_word\n+\n+\t! return to caller.\n+\tread_global1\n+\twrite_pc\n+#endif\n+\n+\n+#ifdef __LITTLE_ENDIAN__\n+#define AL iload_1\n+#define AH iload_0\n+#define BL iload_3\t\n+#define BH iload_2\n+#else\n+#define AL iload_0\n+#define AH iload_1\n+#define BL iload_2\n+#define BH iload_3\n+#endif\t\n+#ifdef Lpjucmpdi2\n+\n+! like ucmpdi2, but returns <0,0,>0 depending on comparison input.\n+! and returns answer on the stack, not in global1.  - much like an\n+! actual lucmp instruction would do if there was one.\n+!\t      big         little\n+!  \n+!  vars-> 0 a low         high\n+!\t  1 a high        low\n+!         2 b low         high\n+!\t  3 b high        low\n+!\n+! compares a to b\n+! a > b return 1\n+! a = b return 0\n+! a < b return -1\t\t\n+\t\n+\t.globl __pjucmpdi2\n+__pjucmpdi2:\n+\n+! first see if we can compare the numbers using\n+! the signed instruction.\n+\t\n+\tAH\n+\tBH\n+\tif_icmpne\thigh_words_diff\n+\tAL\n+\tBL\n+\tiucmp\n+\treturn1\n+\n+! and low word if high word is equal.\t\n+\n+high_words_diff:\t\t\n+\tAH\n+\tBH\n+\tiucmp\n+\treturn1\n+#endif"}, {"sha": "41d275ee10a77c7dc0b754d04a304da23d0441e8", "filename": "gcc/config/pj/linux.h", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b992148d7a6a6b0fffd946131dd7cd6e6cc3958/gcc%2Fconfig%2Fpj%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b992148d7a6a6b0fffd946131dd7cd6e6cc3958/gcc%2Fconfig%2Fpj%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpj%2Flinux.h?ref=1b992148d7a6a6b0fffd946131dd7cd6e6cc3958", "patch": "@@ -0,0 +1,36 @@\n+/* Definitions for a picoJava Linux-based GNU system.\n+   Copyright (C) 2000 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* contributed by Steve Chamberlain, of Transmeta. sac@pobox.com. */\n+\n+#define TARGET_LITTLE_ENDIAN_DEFAULT 1\n+\n+#undef CPP_PREDEFINES\n+#undef STARTFILE_SPEC\n+#undef ENDFILE_SPEC\n+\n+#define CPP_PREDEFINES \"-D__ELF__ -Dunix -D__pj__ -Dlinux -Asystem(posix)\"\n+#define STARTFILE_SPEC \"crt1.o%s crti.o%s crtbegin.o%s\"\n+#define ENDFILE_SPEC   \"crtend.o%s crtn.o%s\"\n+\n+#undef WCHAR_TYPE_SIZE\n+#undef WCHAR_TYPE\n+#define WCHAR_TYPE \"long int\"\n+#define WCHAR_TYPE_SIZE BITS_PER_WORD"}, {"sha": "d26df656fec8d8ee876608f635168cec03d6a569", "filename": "gcc/config/pj/pj-protos.h", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b992148d7a6a6b0fffd946131dd7cd6e6cc3958/gcc%2Fconfig%2Fpj%2Fpj-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b992148d7a6a6b0fffd946131dd7cd6e6cc3958/gcc%2Fconfig%2Fpj%2Fpj-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpj%2Fpj-protos.h?ref=1b992148d7a6a6b0fffd946131dd7cd6e6cc3958", "patch": "@@ -0,0 +1,46 @@\n+/* Prototypes for pj.c functions used in the md file & elsewhere.\n+   Copyright (C) 2000 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+void pj_expand_prologue PARAMS ((void));\n+void pj_expand_epilogue PARAMS ((void));\n+void pj_asm_output_opcode PARAMS ((FILE *, const char *));\n+\n+#ifdef RTX_CODE\n+extern rtx pj_cmp_op0;\n+extern rtx pj_cmp_op1;\n+extern enum machine_mode pj_cmp_mode;\n+extern int pj_stuff_on_line;\n+extern const char *pj_standard_float_constant PARAMS ((rtx));\n+extern int pj_source_operand PARAMS ((rtx op, enum machine_mode mode));\n+extern int pj_signed_comparison_operator PARAMS ((rtx, enum machine_mode));\n+extern int pj_unsigned_comparison_operator PARAMS ((rtx, enum machine_mode));\n+extern rtx pj_workout_arg_words PARAMS ((rtx, rtx));\n+extern void pj_machine_dependent_reorg PARAMS ((rtx));\n+extern void pj_print_operand PARAMS ((FILE * stream, rtx x, int code));\n+extern char *pj_output_addsi3 PARAMS ((rtx * operands));\n+\n+#ifdef TREE_CODE\n+extern rtx pj_expand_builtin_va_arg PARAMS ((tree valist, tree type));\n+extern rtx pj_function_incoming_arg PARAMS ((CUMULATIVE_ARGS * args_so_far,\n+\t\t\t\t\t     enum machine_mode promote_mode,\n+\t\t\t\t\t     tree passed_type,\n+\t\t\t\t\t     int named_arg));\n+#endif\n+#endif"}, {"sha": "ce8380335a5d28383bcb88f544159b9ce7147e4e", "filename": "gcc/config/pj/pj.c", "status": "added", "additions": 1279, "deletions": 0, "changes": 1279, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b992148d7a6a6b0fffd946131dd7cd6e6cc3958/gcc%2Fconfig%2Fpj%2Fpj.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b992148d7a6a6b0fffd946131dd7cd6e6cc3958/gcc%2Fconfig%2Fpj%2Fpj.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpj%2Fpj.c?ref=1b992148d7a6a6b0fffd946131dd7cd6e6cc3958", "patch": "@@ -0,0 +1,1279 @@\n+/* Output routines for GCC for picoJava II\n+   Copyright (C) 2000 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* Contributed by Steve Chamberlain (sac@pobox.com), of Transmeta.  */\n+\n+/* The picoJava architecture doesn't have general registers, it has an\n+   operand stack.  Any of the first 256 words on the operand stack between\n+   the locations indicated by the vars register and the optop register\n+   are accessible with one instruction, almost as if they were registers.\n+   The opstack isn't aliased into memory, so deferecencing address of\n+   something on the opstack is impossible.\n+\n+   Small scalar incoming arguments to a function arrive on the operand\n+   stack, large scalars and aggregates arrive in the `aggregate'\n+   stack.  The aggregate stack lives in normal memory.\n+\n+\n+   just before a call       after the call insn and frame setup.\n+\n+   vars->   ....\n+   \n+      \t   arg-5            vars->arg-5\n+   \t   arg-4                  arg-4\n+   \t   arg-3                  arg-3\n+   \t   arg-2                  arg-2\n+   \t   arg-1                  arg-1\n+   \t   arg-0                  arg-0\n+   \t   target-addr            old-vars\n+   \t   #arg words             old-pc\n+   optop->                        saved globals\n+                                  local-0\n+                                  local-1\n+           \t\t          ....\n+       \t\t            optop->\n+\n+   This port generates code for a machine with 32 general purpose\n+   registers, and on output changes the references to the fake registers\n+   into offsets from the vars register.  Because the opstack grows\n+   downwards and all indexes are negated, some care has to be taken here\n+   to deal with endian problems; for example after a call on a little endian\n+   machine, an incoming DImode argument of value 0x1122334455667788 in\n+   `register 0', would live on the opstack like this:\n+\n+     vars - 0   0x11223344\n+     vars - 4   0x55667788\n+     vars - 8   old-vars\n+     vars - 12  old-pc\n+\n+   The picoJava instructon to read and put that onto the opstack as a\n+   DImode value is `lload 0', yet the least significant word lives at\n+   vars - 4, for which the instruction is `iload 1'.  The incoming\n+   argument code remembers which arguments arrive swapped in the\n+   CUMULATIVE_ARGS structure.  The information is used to fill in\n+   pj_si_vars_offset_vec and pj_di_vars_offset_vec during the prologue\n+   printing.\n+\n+   Outgoing arguments are collected in fake `outgoing' registers, or\n+   in the aggregate stack.  The emitted code to write into an outgoing\n+   register does nothing, which leaves the expression to be written on\n+   the top of the opstack.  GCC always evaluates arguments in the right\n+   order, so nothing more needs to be done.  */\n+\n+\n+#include <setjmp.h>\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"rtl.h\"\n+#include \"tree.h\"\n+#include \"tm_p.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"real.h\"\n+#include \"insn-config.h\"\n+#include \"conditions.h\"\n+#include \"insn-flags.h\"\n+#include \"output.h\"\n+#include \"insn-attr.h\"\n+#include \"flags.h\"\n+#include \"except.h\"\n+#include \"function.h\"\n+#include \"recog.h\"\n+#include \"expr.h\"\n+#include \"toplev.h\"\n+#include \"basic-block.h\"\n+#include \"ggc.h\"\n+\n+/* Compare insns in pj.md store the information needed to generate\n+   branch instructions here.  */\n+rtx pj_cmp_op0;\n+rtx pj_cmp_op1;\n+enum machine_mode pj_cmp_mode;\n+\n+static void pj_output_rval PROTO ((rtx, enum machine_mode, rtx));\n+static void pj_output_store_into_lval PROTO ((enum machine_mode mode, rtx op));\n+\n+/* These vectors turn a register number into an offset from the vars\n+   pointer register.  */\n+short pj_si_vars_offset_vec[FIRST_PSEUDO_REGISTER];\n+short pj_di_vars_offset_vec[FIRST_PSEUDO_REGISTER];\n+short pj_debugreg_renumber_vec[FIRST_PSEUDO_REGISTER];\n+\n+/* Number of fake registers in the frame, used by prologue and epilogue\n+   code.  */\n+static int nfakes;\n+\n+/* Whether anything has been printed to the current assembly output\n+   line. */\n+int pj_stuff_on_line;\n+\n+/* printf to the asm_out_file, with special format control characters\n+   for decoding operands.  \n+\n+ %*              - start of opcode\n+ %d,%x,%c,%s     - as printf\n+ %X              - address constant.\n+ %<alpha><digit> - operand <digit> passed to pj_print_operand with code <alpha>.  */\n+\n+static void pj_printf\n+VPROTO ((const char *template, ...))\n+{\n+#ifndef ANSI_PROTOTYPES\n+  const char *template;\n+#endif\n+  register int c;\n+\n+  va_list argptr;\n+  int ops_read = 0;\n+  rtx operands[10];\n+  VA_START (argptr, template);\n+#ifndef ANSI_PROTOTYPES\n+  template = va_arg (argptr, const char *);\n+#endif\n+\n+  while ((c = *template++))\n+    {\n+      int was_stuff_on_line = pj_stuff_on_line;\n+      pj_stuff_on_line = 1;\n+      switch (c)\n+\t{\n+\tcase '\\n':\n+\t  putc (c, asm_out_file);\n+\t  pj_stuff_on_line = 0;\n+\t  break;\n+\tdefault:\n+\t  putc (c, asm_out_file);\n+\t  break;\n+\tcase '%':\n+\t  {\n+\t    switch (*template)\n+\t      {\n+\t      case '%':\n+\t\tputc ('%', asm_out_file);\n+\t\ttemplate++;\n+\t\tpj_stuff_on_line = 1;\n+\t\tbreak;\n+\t      case '*':\n+\t\t/* Marks start of opcode, tab out.  */\n+\t\tif (was_stuff_on_line)\n+\t\t  fprintf (asm_out_file, \"; \");\n+\t\ttemplate++;\n+\t\tbreak;\n+\t      case 'd':\n+\t\ttemplate++;\n+\t\tfprintf (asm_out_file, \"%d\", va_arg (argptr, int));\n+\t\tbreak;\n+\t      case 'x':\n+\t\ttemplate++;\n+\t\tfprintf (asm_out_file, \"%x\", va_arg (argptr, int));\n+\t\tbreak;\n+\t      case 'c':\n+\t\ttemplate++;\n+\t\tfprintf (asm_out_file, \"%c\", va_arg (argptr, int));\n+\t\tbreak;\n+\t      case 's':\n+\t\ttemplate++;\n+\t\tfputs (va_arg (argptr, const char *), asm_out_file);\n+\t\tbreak;\n+\t      case 'X':\n+\t\ttemplate++;\n+\t\toutput_addr_const (asm_out_file, va_arg (argptr, rtx));\n+\t\tbreak;\n+\t      default:\n+\t\t{\n+\t\t  int code = 0;\n+\t\t  rtx send;\n+\n+\t\t  if (ISALPHA (*template))\n+\t\t    code = *template++;\n+\t\t  if (ISDIGIT (*template))\n+\t\t    {\n+\t\t      int num = atoi (template);\n+\t\t      template++;\n+\t\t      while (ops_read <= num)\n+\t\t\toperands[ops_read++] = va_arg (argptr, rtx);\n+\t\t      send = operands[num];\n+\t\t    }\n+\t\t  else\n+\t\t    send = va_arg (argptr, rtx);\n+\n+\t\t  /* A null means leave the word on the stack, so there's\n+\t\t     no need to do anything for that.  */\n+\n+\t\t  if (send)\n+\t\t    pj_print_operand (asm_out_file, send, code);\n+\t\t}\n+\t      }\n+\t  }\n+\t}\n+    }\n+  va_end (argptr);\n+}\n+\n+/* Output code to efficiently push a single word integer constant onto\n+   the opstack.  */\n+\n+static void\n+pj_output_push_int (val)\n+     int val;\n+{\n+  int low = ((val & 0x8000) ? ~0xffff : 0) | (val & 0xffff);\n+\n+  if (low == -1)\n+    pj_printf (\"%*iconst_m1\");\n+  else if (low >= 0 && low <= 5)\n+    pj_printf (\"%*iconst_%d\", low);\n+  else if (low >= -128 && low < 128)\n+    pj_printf (\"%*bipush %d\", low);\n+  else\n+    pj_printf (\"%*sipush %d\", low);\n+\n+  if ((low & 0xffff0000) != (val & 0xffff0000))\n+    pj_printf (\"%*sethi 0x%x\", (val >> 16) & 0xffff);\n+}\n+\n+/* Output code to add a constant to the value on the top of the\n+   opstack.  */\n+\n+static void\n+pj_output_print_add_k (int size)\n+{\n+  if (size >= 0)\n+    {\n+      pj_output_push_int (size);\n+      pj_printf (\"%*iadd\");\n+    }\n+  else\n+    {\n+      pj_output_push_int (-size);\n+      pj_printf (\"%*isub\");\n+    }\n+}\n+\n+/* Output code to load the value pointed to by the top of stack onto\n+   the stack.  */\n+\n+static void\n+pj_output_load (mode, uns)\n+     enum machine_mode mode;\n+     int uns;\n+{\n+  int i;\n+  switch (GET_MODE_SIZE (mode))\n+    {\n+    case 1:\n+      pj_printf (uns ? \"%*load_ubyte\" : \"%*load_byte\");\n+      break;\n+    case 2:\n+      pj_printf (uns ? \"%*load_char\" : \"%*load_short\");\n+      break;\n+    case 8:\n+      if (TARGET_TM_EXTENSIONS)\n+\t{\n+\t  pj_printf (\"%*tm_load_long\");\n+\t  break;\n+\t}\n+      /* Fall through.  */\n+    default:\n+      for (i = GET_MODE_SIZE (mode); i > 4; i -= 4)\n+\t{\n+\t  pj_printf (\"%*dup\");\n+\t  pj_output_print_add_k (i - 4);\n+\t  pj_printf (\"%*load_word\");\n+\t  pj_printf (\"%*swap\");\n+\t}\n+      pj_printf (\"%*load_word\");\n+    }\n+}\n+\n+/*  Output code to increment the provided lval operand.  */\n+\n+static void\n+pj_output_inc (op, size)\n+     rtx op;\n+     int size;\n+{\n+  if (STACK_REG_RTX_P (op))\n+    pj_printf (\"%*iinc %d,%d\", pj_si_vars_offset_vec[REGNO (op)], size);\n+  else\n+    {\n+      pj_output_rval (op, SImode, 0);\n+      pj_output_push_int (size);\n+      pj_printf (\"%*iadd\");\n+      pj_output_store_into_lval (SImode, op);\n+    }\n+}\n+\n+/* Output the text for a conversion operator.  */\n+\n+static void\n+pj_output_cnv_op (e, op)\n+     enum insn_code e;\n+     rtx op;\n+{\n+  pj_printf ((const char *) insn_data[(int) e].output, 0, XEXP (op, 0));\n+}\n+\n+/* Turn a machine_mode into an opcode modifier chararacter.  */\n+\n+static char\n+mode_to_char (mode)\n+     enum machine_mode mode;\n+{\n+  switch (mode)\n+    {\n+    case QImode:\n+    case HImode:\n+    case SImode:\n+      return 'i';\n+      break;\n+    case DImode:\n+      return 'l';\n+      break;\n+    case DFmode:\n+      return 'd';\n+      break;\n+    case SFmode:\n+      return 'f';\n+      break;\n+    default:\n+      abort ();\n+    }\n+}\n+\n+/* Output an index off the var register. If we're moving an 8 byte\n+   value then reduce the index, since the picoJava instruction loading\n+   the value uses the index of the highest part of the register as\n+   it's name.  */\n+\n+static void\n+pj_output_varidx (mode, do_store, idx)\n+     enum machine_mode mode;\n+     int do_store;\n+     int idx;\n+{\n+  pj_printf (\"%*%c%s%c%d\",\n+\t     mode_to_char (mode),\n+\t     do_store ? \"store\" : \"load\",\n+\t     (GET_MODE_SIZE (mode) == 4 || GET_MODE_SIZE (mode) == 8)\n+\t     && idx <= 3 ? '_' : ' ', idx);\n+}\n+\n+/* Output an rvalue expression.  */\n+\n+static void\n+pj_output_rval (op, mode, outer_op)\n+     rtx op;\n+     enum machine_mode mode;\n+     rtx outer_op;\n+{\n+  enum rtx_code code = GET_CODE (op);\n+\n+  optab tab;\n+\n+  if (code == DIV && GET_MODE_CLASS (mode) == MODE_INT)\n+    tab = sdiv_optab;\n+  else\n+    tab = code_to_optab[code];\n+\n+  if (code == PLUS)\n+    {\n+      pj_output_rval (XEXP (op, 0), mode, op);\n+      pj_output_rval (XEXP (op, 1), mode, op);\n+      pj_printf (\"%*%cadd\", mode_to_char (mode));\n+    }\n+  else if (tab && tab->handlers[mode].insn_code != CODE_FOR_nothing)\n+    {\n+      const char *template =\n+\t(const char *) insn_data[tab->handlers[mode].insn_code].output;\n+      if (code == NEG)\n+\tpj_printf (template, 0, XEXP (op, 0));\n+      else\n+\tpj_printf (template, 0, XEXP (op, 0), XEXP (op, 1));\n+    }\n+  else\n+    switch (GET_CODE (op))\n+      {\n+      case PC:\n+\tfprintf (asm_out_file, \" pc \");\n+\tbreak;\n+\n+      case CONST:\n+\tpj_output_rval (XEXP (op, 0), mode, op);\n+\tbreak;\n+\n+      case MEM:\n+\tpj_output_rval (XEXP (op, 0), Pmode, op);\n+\tpj_output_load (mode, 0);\n+\tbreak;\n+\n+      case SYMBOL_REF:\n+\tpj_printf (\"%*ipush %X\", op);\n+\tbreak;\n+\n+      case REG:\n+\tswitch (mode)\n+\t  {\n+\t  case SImode:\n+\t  case SFmode:\n+\t  case HImode:\n+\t  case QImode:\n+\t    if (pj_si_vars_offset_vec[REGNO (op)] >= 0)\n+\t      pj_output_varidx (mode, 0, pj_si_vars_offset_vec[REGNO (op)]);\n+\t    else\n+\t      pj_printf (\"%*read_%s\", reg_names[REGNO (op)]);\n+\t    break;\n+\t  case DImode:\n+\t  case DFmode:\n+\t    if (pj_di_vars_offset_vec[REGNO (op)] >= 0)\n+\t      pj_output_varidx (mode, 0, pj_di_vars_offset_vec[REGNO (op)]);\n+\t    else\n+\t      switch (REGNO (op))\n+\t\t{\n+\t\tcase G1_REG:\n+\t\t  pj_printf (\"%*read_global2\");\n+\t\t  pj_printf (\"%*read_global1\");\n+\t\t  break;\n+\n+\t\t  /* A 64 bit read of global0 gives global0 and\n+\t\t     optop.  */\n+\t\tcase G0_REG:\n+\t\t  pj_printf (\"%*read_optop\");\n+\t\t  pj_printf (\"%*read_global0\");\n+\t\t  break;\n+\n+\t\tdefault:\n+\t\t  abort ();\n+\t\t}\n+\t    break;\n+\t  default:\n+\t    abort ();\n+\t  }\n+\tbreak;\n+\n+      case CONST_DOUBLE:\n+\tpj_printf (pj_standard_float_constant (op));\n+\tbreak;\n+\n+      case CONST_INT:\n+\tif (mode == SImode || mode == HImode || mode == QImode)\n+\t  pj_output_push_int (INTVAL (op));\n+\telse if (mode == DImode)\n+\t  {\n+\t    int v = INTVAL (op);\n+\t    if (v == 1)\n+\t      pj_printf (\"%*lconst_1\", 0);\n+\t    else if (v == 0)\n+\t      pj_printf (\"%*lconst_0\", 0);\n+\t    else\n+\t      {\n+\t\trtx hi = GEN_INT (v < 0 ? -1 : 0);\n+\t\trtx lo = op;\n+\t\tpj_output_rval (TARGET_LITTLE_ENDIAN ? hi : lo, SImode, op);\n+\t\tpj_output_rval (TARGET_LITTLE_ENDIAN ? lo : hi, SImode, op);\n+\t      }\n+\t  }\n+\telse\n+\t  abort ();\n+\tbreak;\n+\n+      case FLOAT_TRUNCATE:\n+\tpj_printf (\"%S0%*d2f\", XEXP (op, 0));\n+\tbreak;\n+      case LABEL_REF:\n+\tpj_printf (\"%*ipush %X\", XEXP (op, 0));\n+\tbreak;\n+\n+      case SUBREG:\n+\tpj_output_rval (alter_subreg (op), mode, outer_op);\n+\tbreak;\n+\n+      case POST_INC:\n+\tpj_output_rval (XEXP (op, 0), mode, op);\n+\tpj_output_inc (XEXP (op, 0), GET_MODE_SIZE (GET_MODE (outer_op)));\n+\tbreak;\n+\n+      case POST_DEC:\n+\tpj_output_rval (XEXP (op, 0), mode, op);\n+\tpj_output_inc (XEXP (op, 0), -GET_MODE_SIZE (GET_MODE (outer_op)));\n+\tbreak;\n+\n+      case PRE_INC:\n+\tpj_output_inc (XEXP (op, 0), GET_MODE_SIZE (GET_MODE (outer_op)));\n+\tpj_output_rval (XEXP (op, 0), mode, op);\n+\tbreak;\n+\n+      case PRE_DEC:\n+\tif (OPTOP_REG_RTX_P (XEXP (op, 0)))\n+\t  pj_output_rval (XEXP (op, 0), mode, op);\n+\telse if (STACK_REG_RTX_P (XEXP (op, 0)))\n+\t  {\n+\t    pj_output_inc (XEXP (op, 0),\n+\t\t\t   -GET_MODE_SIZE (GET_MODE (outer_op)));\n+\t    pj_output_rval (XEXP (op, 0), mode, op);\n+\t  }\n+\telse\n+\t  {\n+\t    pj_printf (\"%S0\", XEXP (op, 0));\n+\t    pj_output_print_add_k (-GET_MODE_SIZE (GET_MODE (outer_op)));\n+\t    pj_printf (\"%*dup%R0\", XEXP (op, 0));\n+\t  }\n+\tbreak;\n+\n+      case FIX:\n+\tpj_output_cnv_op (fixtrunctab[GET_MODE (XEXP (op, 0))][mode][0], op);\n+\tbreak;\n+\n+      case FLOAT:\n+\tif (mode == DFmode && GET_CODE (XEXP (op, 0)) == CONST_INT)\n+\t  pj_output_cnv_op (floattab[mode][SImode][0], op);\n+\telse\n+\t  pj_output_cnv_op (floattab[mode][GET_MODE (XEXP (op, 0))][0], op);\n+\tbreak;\n+\n+      case FLOAT_EXTEND:\n+      case SIGN_EXTEND:\n+\t/* Sign extending from a memop to register is automatic.  */\n+\tif (mode == SImode && GET_CODE (XEXP (op, 0)) == MEM)\n+\t  pj_output_rval (XEXP (op, 0), GET_MODE (XEXP (op, 0)), op);\n+\telse\n+\t  pj_output_cnv_op (extendtab[mode][GET_MODE (XEXP (op, 0))][0], op);\n+\tbreak;\n+\n+      case ZERO_EXTEND:\n+\tpj_output_cnv_op (extendtab[mode][GET_MODE (XEXP (op, 0))][1], op);\n+\tbreak;\n+\n+      default:\n+\tabort ();\n+\tbreak;\n+      }\n+}\n+\n+/* Store the top of stack into the lval operand OP.  */\n+\n+void\n+pj_output_store_into_lval (mode, op)\n+     enum machine_mode mode;\n+     rtx op;\n+{\n+  if (GET_CODE (op) == REG)\n+    {\n+      int rn = REGNO (op);\n+\n+      /* Outgoing values are left on the stack and not written\n+         anywhere.  */\n+      if (!OUTGOING_REG_RTX_P (op))\n+\t{\n+\t  switch (GET_MODE (op))\n+\t    {\n+\t    case SImode:\n+\t    case QImode:\n+\t    case HImode:\n+\t    case SFmode:\n+\t      if (pj_si_vars_offset_vec[rn] >= 0)\n+\t\tpj_output_varidx (mode, 1, pj_si_vars_offset_vec[rn]);\n+\t      else\n+\t\tpj_printf (\"%*write_%s\", reg_names[rn]);\n+\t      break;\n+\t    case DImode:\n+\t    case DFmode:\n+\t      if (pj_di_vars_offset_vec[rn] >= 0)\n+\t\tpj_output_varidx (mode, 1, pj_di_vars_offset_vec[rn]);\n+\t      else\n+\t\tswitch (rn)\n+\t\t  {\n+\t\t  case G1_REG:\n+\t\t    pj_printf (\"%*write_global1\");\n+\t\t    pj_printf (\"%*write_global2\");\n+\t\t    break;\n+\t\t  default:\n+\t\t    abort ();\n+\t\t  }\n+\t      break;\n+\t    default:\n+\t      abort ();\n+\t    }\n+\t}\n+    }\n+  else\n+    {\n+      pj_output_rval (XEXP (op, 0), Pmode, op);\n+\n+      switch (GET_MODE_SIZE (mode))\n+\t{\n+\tcase 1:\n+\t  pj_printf (\"%*store_byte\", 0);\n+\t  break;\n+\tcase 2:\n+\t  pj_printf (\"%*store_short\", 0);\n+\t  break;\n+\tcase 8:\n+\t  if (TARGET_TM_EXTENSIONS)\n+\t    {\n+\t      pj_printf (\"%*tm_store_long\");\n+\t      break;\n+\t    }\n+\t  /* Fall through.  */\n+\tdefault:\n+\t  {\n+\t    int i;\n+\t    for (i = GET_MODE_SIZE (mode); i > 4; i -= 4)\n+\t      {\n+\t\tpj_printf (\"%*dup_x1\", 0);\n+\t\tpj_printf (\"%*store_word\", 0);\n+\t\tpj_printf (\"%*iconst_4\", 0);\n+\t\tpj_printf (\"%*iadd\", 0);\n+\t      }\n+\t  }\n+\t  pj_printf (\"%*store_word\", 0);\n+\t  break;\n+\t}\n+    }\n+}\n+\n+/* Print a condition, unsigned and signed have the same text because\n+   the unsigned operands have been run through icmp first.  */\n+\n+static void\n+pj_print_cond (code)\n+     enum rtx_code code;\n+{\n+  switch (code)\n+    {\n+    case EQ:\n+      fputs (\"eq\", asm_out_file);\n+      break;\n+    case NE:\n+      fputs (\"ne\", asm_out_file);\n+      break;\n+    case GT:\n+    case GTU:\n+      fputs (\"gt\", asm_out_file);\n+      break;\n+    case GE:\n+    case GEU:\n+      fputs (\"ge\", asm_out_file);\n+      break;\n+    case LT:\n+    case LTU:\n+      fputs (\"lt\", asm_out_file);\n+      break;\n+    case LE:\n+    case LEU:\n+      fputs (\"le\", asm_out_file);\n+      break;\n+    default:\n+      abort ();\n+    }\n+}\n+/* Print operand X (an rtx) in assembler syntax to file STREAM\n+   according to modifier CODE.\n+\n+   C  emit the first part of a Check_call pseudop. \n+   D  emit operand, if no mode, assume DImode.\n+   E  emit the second part of a check_call pseudop. \n+   I  print the XEXP (X, 0) Inside of the operand.\n+   J  print Just the integer or register part of an operand, for iinc.\n+   P  emit source is SI padded to DI with 0, used for unsigned mod and divide.\n+   R  emit the operand as an lval Result.\n+   S  emit Source operand, if no mode, assume SImode.\n+   X  nan choice suffix for floating point comparision.\n+   Y  condition name from op.\n+   Z  Y, reversed.\n+   *  marks start of opcode.  */\n+\n+void\n+pj_print_operand (stream, x, code)\n+     FILE *stream;\n+     rtx x;\n+     int code;\n+{\n+  static int last_call_known;\n+  switch (code)\n+    {\n+    case 'C':\n+      if (GET_CODE (x) == SYMBOL_REF)\n+\t{\n+\t  last_call_known = 1;\n+\t  pj_printf (\"%*.check_call %0\", x);\n+\t}\n+      else\n+\tlast_call_known = 0;\n+      break;\n+\n+    case 'D':\n+      pj_output_rval (x,\n+\t\t      GET_MODE (x) == VOIDmode ? DImode : GET_MODE (x),\n+\t\t      NULL_RTX);\n+      break;\n+\n+    case 'E':\n+      if (last_call_known)\n+\tpj_printf (\",%d\", INTVAL (x));\n+      break;\n+\n+    case 'I':\n+      pj_output_rval (XEXP (x, 0), GET_MODE (XEXP (x, 0)), NULL_RTX);\n+      break;\n+\n+    case 'J':\n+      if (GET_CODE (x) == CONST_INT)\n+\tpj_printf (\"%d\", INTVAL (x));\n+      else if (GET_CODE (x) == REG)\n+\tpj_printf (\"%d\", pj_si_vars_offset_vec[REGNO (x)]);\n+      else\n+\tabort ();\n+      break;\n+\n+    case 'P':\n+      if (TARGET_LITTLE_ENDIAN)\n+\tpj_printf (\"%*iconst_0\", 0);\n+      pj_output_rval (x,\n+\t\t      GET_MODE (x) == VOIDmode ? SImode : GET_MODE (x),\n+\t\t      NULL_RTX);\n+      if (!TARGET_LITTLE_ENDIAN)\n+\tpj_printf (\"%*iconst_0\", 0);\n+      break;\n+\n+    case 'R':\n+      pj_output_store_into_lval (GET_MODE (x), x);\n+      break;\n+\n+    case 'S':\n+      pj_output_rval (x,\n+\t\t      GET_MODE (x) == VOIDmode ? SImode : GET_MODE (x),\n+\t\t      NULL_RTX);\n+      break;\n+\n+    case 'X':\n+      fputc (GET_CODE (x) == LT || GET_CODE (x) == LE ? 'g' : 'l', stream);\n+      break;\n+\n+    case 'Y':\n+      pj_print_cond (GET_CODE (x));\n+      break;\n+\n+    case 'Z':\n+      pj_print_cond (reverse_condition (GET_CODE (x)));\n+      break;\n+\n+    case '*':\n+      pj_printf (\"%*\");\n+      break;\n+\n+    default:\n+      output_addr_const (stream, x);\n+      break;\n+    }\n+}\n+\f\n+/* Return in an rtx the number of words pushed onto the optop to be\n+   used as the word count in a call insn.  (NEXT_ARG_REG is NULL when\n+   called from expand_builtin_apply).  */\n+\n+rtx\n+pj_workout_arg_words (stack_size, next_arg_reg)\n+     rtx stack_size ATTRIBUTE_UNUSED;\n+     rtx next_arg_reg;\n+{\n+  return GEN_INT ((next_arg_reg ? REGNO (next_arg_reg) - O0_REG : 0) + 2);\n+}\n+\n+/* Handle the INCOMING_FUNCTION_ARG macro.\n+   Determine where to put an argument to a function.\n+   Value is zero to push the argument on the stack,\n+   or a hard register in which to store the argument.\n+\n+   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n+    the preceding args and about the function being called.\n+   MODE is the argument's machine mode.\n+   TYPE is the data type of the argument (as a tree).\n+    This is null for libcalls where that information may\n+    not be available.\n+   NAMED is nonzero if this argument is a named parameter\n+    (otherwise it is an extra parameter matching an ellipsis). */\n+\n+rtx\n+pj_function_incoming_arg (cum, mode, passed_type, named_arg)\n+     CUMULATIVE_ARGS *cum;\n+     enum machine_mode mode;\n+     tree passed_type ATTRIBUTE_UNUSED;\n+     int named_arg ATTRIBUTE_UNUSED;\n+{\n+  int arg_words = PJ_ARG_WORDS (mode);\n+\n+  /* If the whole argument will fit into registers, return the first\n+     register needed.  Also fill in the arg_adjust information so that\n+     we can work out the right offset to use when looking at the\n+     insides of a DI or DF value.  */\n+\n+  if (cum->total_words + arg_words <= ARGS_IN_REGS)\n+    {\n+      int i;\n+      if (mode == DImode || mode == DFmode)\n+\t{\n+\t  cum->arg_adjust[cum->total_words + 0] = +1;\n+\t  cum->arg_adjust[cum->total_words + 1] = -1;\n+\t}\n+      else\n+\tfor (i = 0; i < arg_words; i++)\n+\t  cum->arg_adjust[cum->total_words + i] = 0;\n+\n+      return gen_rtx (REG, mode, I0_REG + cum->total_words);\n+    }\n+  return NULL_RTX;\n+}\n+\n+/* Output code to add two SImode values.  Deals carefully with the the common\n+   case of moving the optop.  */\n+\n+char *\n+pj_output_addsi3 (operands)\n+     rtx *operands;\n+{\n+  if (OPTOP_REG_RTX_P (operands[0]) && OPTOP_REG_RTX_P (operands[1])\n+      && GET_CODE (operands[2]) == CONST_INT\n+      && INTVAL (operands[2]) >= -32 && INTVAL (operands[2]) <= 32)\n+    {\n+      static struct\n+      {\n+\tconst char *two;\n+\tconst char *one;\n+      }\n+      name[2] =\n+      {\n+\t{ \"pop2\", \"pop\"},\n+\t{ \"lconst_0\", \"iconst_0\"}\n+      };\n+      int size = INTVAL (operands[2]);\n+      int d = 0;\n+\n+      if (size < 0)\n+\t{\n+\t  d = 1;\n+\t  size = -size;\n+\t}\n+\n+      for (; size >= 8; size -= 8)\n+\toutput_asm_insn (name[d].two, 0);\n+\n+\n+      if (size > 0)\n+\toutput_asm_insn (name[d].one, 0);\n+\n+      return \"\";\n+    }\n+\n+  if (STACK_REG_RTX_P (operands[0])\n+      && rtx_equal_p (operands[0], operands[1])\n+      && GET_CODE (operands[2]) == CONST_INT\n+      && INTVAL (operands[2]) >= -128 && INTVAL (operands[2]) <= 127)\n+    {\n+      return \"iinc %J0,%J2\";\n+    }\n+\n+  return \"%S1%S2%*iadd%R0\";\n+}\n+\f\n+/* Generate rtl for the prologue of the current function.  */\n+\n+void\n+pj_expand_prologue ()\n+{\n+  int i;\n+  int off = 0;\n+  int arg_words = current_function->args_info.named_words;\n+\n+  memset (pj_si_vars_offset_vec, -1, sizeof (pj_si_vars_offset_vec));\n+  memset (pj_di_vars_offset_vec, -1, sizeof (pj_di_vars_offset_vec));\n+\n+  /* Work out the register numbers of the named arguments.  */\n+  for (i = 0; i < current_function->args_info.named_words; i++)\n+    {\n+      pj_debugreg_renumber_vec[I0_REG + i]\n+\t= off + R0_REG + current_function->args_info.arg_adjust[i];\n+      pj_si_vars_offset_vec[I0_REG + i]\n+\t= off + current_function->args_info.arg_adjust[i];\n+      pj_di_vars_offset_vec[I0_REG + i] = off;\n+      off++;\n+    }\n+\n+  if (current_function_varargs || current_function_stdarg)\n+    {\n+      /* If the function is varadic we need to call the vhelper\n+         function.  vhelper pops off the unnamed argument words from\n+         the opstack and puts them onto the the aggregate stack.  The\n+         unnamed words are replacedwith two extra arguments, a pointer\n+         to the aggreagate stack for the first vararg and the original\n+         global0 value.  */\n+\n+      emit_insn (gen_varargs (GEN_INT (arg_words * 4)));\n+      pj_si_vars_offset_vec[VA_REG] = off++;\n+      off++;\n+      arg_words += 2;\n+    }\n+\n+  /* Skip over the return pc and old vars in the frame.  */\n+  off += 2;\n+\n+  /* Work out the register numbers and offsets from the var pointer\n+     for the normal registers.  */\n+  nfakes = 0;\n+\n+  for (i = LAST_I_REG; i >= R0_REG; i--)\n+    if (regs_ever_live[i] && pj_si_vars_offset_vec[i] == -1)\n+      {\n+\tnfakes++;\n+\tpj_si_vars_offset_vec[i] = off;\n+\tpj_di_vars_offset_vec[i] = off - 1;\n+\tpj_debugreg_renumber_vec[i] = off + R0_REG;\n+\toff++;\n+      }\n+\n+  if (TARGET_TEST)\n+    {\n+      fprintf (asm_out_file, \"\\n\\t! args %d, size %d, fakes %d\\n\", \n+\t       arg_words,\n+\t       get_frame_size () / 4,\n+\t       nfakes);\n+\n+      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\tif (pj_si_vars_offset_vec[i] >= 0)\n+\t  fprintf (asm_out_file, \"\\t!vars - %d %d: %s\\n\",\n+\t\t   pj_si_vars_offset_vec[i],\n+\t\t   pj_di_vars_offset_vec[i], \n+\t\t   reg_names[i]);\n+    }\n+\n+  /* Make room on the opstack for the fake registers.  */\n+  if (TARGET_TM_EXTENSIONS)\n+    RTX_FRAME_RELATED_P (emit_insn (gen_tm_frame (GEN_INT (arg_words),\n+\t\t\t\t\t\t  GEN_INT (nfakes)))) = 1;\n+  else\n+    RTX_FRAME_RELATED_P (emit_insn\n+\t\t\t (gen_addsi3\n+\t\t\t  (gen_rtx_REG (SImode, OPTOP_REG),\n+\t\t\t   gen_rtx_REG (SImode, OPTOP_REG),\n+\t\t\t   GEN_INT (-nfakes * 4)))) = 1;\n+\n+\n+  if (frame_pointer_needed)\n+      emit_move_insn (frame_pointer_rtx, stack_pointer_rtx);\n+\n+  if (get_frame_size ())\n+    RTX_FRAME_RELATED_P (emit_insn (gen_addsi3 (stack_pointer_rtx,\n+\t\t\t\t\t\tstack_pointer_rtx,\n+\t\t\t\t\t\tGEN_INT\n+\t\t\t\t\t\t(-get_frame_size ())))) = 1;\n+\n+  emit_insn (gen_rtx_USE (VOIDmode, gen_rtx_REG (SImode, OPTOP_REG)));\n+}\n+\n+/* Generate rtl for the epilogue of the current function.  */\n+\n+void\n+pj_expand_epilogue ()\n+{\n+  if (frame_pointer_needed)\n+    emit_move_insn (stack_pointer_rtx, frame_pointer_rtx);\n+  else if (get_frame_size ())\n+    emit_insn (gen_addsi3 (stack_pointer_rtx,\n+\t\t\t   stack_pointer_rtx, GEN_INT (get_frame_size ())));\n+  if (nfakes)\n+    emit_insn (gen_addsi3 (gen_rtx_REG (SImode, OPTOP_REG),\n+\t\t\t   gen_rtx_REG (SImode, OPTOP_REG),\n+\t\t\t   GEN_INT (nfakes * 4)));\n+\n+\n+  /* If this is a varargs function, then global0 is stashed away on\n+     the top of the optop stack as the last secret argument by the\n+     __vhelper.  Pop off the va pointer provided too.  */\n+\n+  if (current_function_varargs || current_function_stdarg)\n+    emit_insn (gen_varargs_finish\n+\t       (GEN_INT (current_function->args_info.named_words + 1)));\n+\n+  emit_insn (gen_rtx_USE (VOIDmode, gen_rtx_REG (SImode, OPTOP_REG)));\n+}\n+\n+/* Return the opcode name for an instruction to load a standard\n+   floating point constant, or NULL.  */\n+\n+const char *\n+pj_standard_float_constant (op)\n+     rtx op;\n+{\n+  REAL_VALUE_TYPE r;\n+  enum machine_mode mode = GET_MODE (op);\n+\n+  if (GET_CODE (op) != CONST_DOUBLE || (mode != DFmode && mode != SFmode))\n+    return NULL;\n+\n+  REAL_VALUE_FROM_CONST_DOUBLE (r, op);\n+\n+  if (REAL_VALUES_EQUAL (r, dconst0) && !REAL_VALUE_MINUS_ZERO (r))\n+    return mode == DFmode ? \"%*dconst_0\" : \"%*fconst_0\";\n+\n+  if (REAL_VALUES_EQUAL (r, dconst1))\n+    return mode == DFmode ? \"%*dconst_1\" : \"%*fconst_1\";\n+\n+  if (REAL_VALUES_EQUAL (r, dconst2))\n+    return mode == DFmode ? 0 : \"%*fconst_2\";\n+\n+  return NULL;\n+}\n+\n+/* Read the value at the current address, and decrement by the size.\n+   The function is interesting because we're reading from high memory to low memory\n+   and have to adjust the addresses of reads of 8 byte values\n+   accordingly.  */\n+\n+rtx\n+pj_expand_builtin_va_arg (valist, type)\n+     tree valist;\n+     tree type;\n+{\n+  tree addr_tree, t;\n+  HOST_WIDE_INT align;\n+  HOST_WIDE_INT rounded_size;\n+  rtx addr;\n+\n+  /* Compute the rounded size of the type.  */\n+  align = PARM_BOUNDARY / BITS_PER_UNIT;\n+  rounded_size = (((int_size_in_bytes (type) + align - 1) / align) * align);\n+\n+  /* Get AP.  */\n+  addr_tree = valist;\n+  addr = expand_expr (addr_tree, NULL_RTX, Pmode, EXPAND_NORMAL);\n+  addr = copy_to_reg (addr);\n+\n+  /* Aggregates and large scalars are passed by reference.  */\n+  if (AGGREGATE_TYPE_P (type) || rounded_size > 8)\n+    {\n+      addr = gen_rtx_MEM (Pmode, addr);\n+      rounded_size = 4;\n+    }\n+\n+  /* adjust address to cope with double word sizes */\n+  if (rounded_size > 4)\n+    addr = gen_rtx_PLUS (Pmode, addr, GEN_INT (-4));\n+\n+  /* Compute new value for AP; AP = AP - SIZE */\n+  t = build (MODIFY_EXPR, TREE_TYPE (valist), valist,\n+\t     build (MINUS_EXPR, TREE_TYPE (valist), valist,\n+\t\t    build_int_2 (rounded_size, 0)));\n+\n+  TREE_SIDE_EFFECTS (t) = 1;\n+\n+  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\n+  return addr;\n+}\n+\f\n+/* Return nonzero if the operand is valid as a source operand; it's\n+   general and it's not an outgoing argument register.  */\n+\n+int\n+pj_source_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return !OUTGOING_REG_RTX_P (op) && general_operand (op, mode);\n+}\n+\n+/* Return nonzero if the operator is a signed compare.  */\n+\n+int\n+pj_signed_comparison_operator (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (mode != GET_MODE (op))\n+    return 0;\n+\n+  switch (GET_CODE (op))\n+    {\n+    case EQ:\n+    case NE:\n+    case LE:\n+    case LT:\n+    case GE:\n+    case GT:\n+      return 1;\n+    default:\n+      return 0;\n+    }\n+}\n+\n+/* Return nonzero if the operator is an unsigned compare.  */\n+\n+int\n+pj_unsigned_comparison_operator (op, mode)\n+     rtx op;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n+{\n+  if (mode != GET_MODE (op))\n+    return 0;\n+\n+  switch (GET_CODE (op))\n+    {\n+    case GTU:\n+    case GEU:\n+    case LTU:\n+    case LEU:\n+      return 1;\n+    default:\n+      return 0;\n+    }\n+}\n+\f\n+/* Helper function for pj_machine_dependent_reorg.  Find the one\n+   instance of register OP in the source part of PAT.  If there are no\n+   copies return NULL, if there are more than one, return NOT_UNIQUE.  */\n+\n+#define NOT_UNIQUE (&const0_rtx)\n+\n+static rtx *\n+unique_src_operand (pat, reg)\n+     rtx *pat;\n+     rtx reg;\n+{\n+  register rtx *result = 0;\n+  register const char *fmt;\n+  register int i;\n+  register int j;\n+\n+  if (GET_CODE (*pat) == SET)\n+    {\n+      if (GET_CODE (XEXP (*pat, 0)) == MEM)\n+\tresult = unique_src_operand (&XEXP (SET_DEST (*pat), 0), reg);\n+      pat = &SET_SRC (*pat);\n+    }\n+\n+  if (GET_CODE (*pat) == REG && REGNO (*pat) == REGNO (reg))\n+    return pat;\n+\n+  fmt = GET_RTX_FORMAT (GET_CODE (*pat));\n+  for (i = GET_RTX_LENGTH (GET_CODE (*pat)) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+\t{\n+\t  rtx *new_result = unique_src_operand (&XEXP (*pat, i), reg);\n+\n+\t  if (new_result)\n+\t    {\n+\t      if (result)\n+\t\treturn NOT_UNIQUE;\n+\t      result = new_result;\n+\t    }\n+\t}\n+      else if (fmt[i] == 'E')\n+\t{\n+\t  for (j = XVECLEN (*pat, i) - 1; j >= 0; j--)\n+\t    {\n+\t      rtx *new_result =\n+\t\tunique_src_operand (&XVECEXP (*pat, i, j), reg);\n+\n+\t      if (new_result)\n+\t\t{\n+\t\t  if (result)\n+\t\t    return NOT_UNIQUE;\n+\t\t  result = new_result;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  return result;\n+}\n+\n+/* Clean up the instructions to remove unneeded loads and stores.\n+\n+   For example, rewrite\n+\n+   iload a; iload b; iadd; istore z\n+   iload z; iload c; iadd; istore z\n+\n+   as\n+\n+   iload a; iload b; iadd ; iload c; iadd; istore z\n+\n+   This function moves a cursor over each instruction, inspecting the\n+   LOG_LINKS.  Each of the cursor's LOG_LINK incoming instructions are\n+   inspected, any which have a simple register destination which is\n+   also used as a source in the cursor instruction, and aren't used\n+   again between the the incoming instruction and the cursor, and\n+   which become dead or set after the cursor get their sources\n+   substituted into the position of the source register in the cursor\n+   instruction.  */\n+\n+void\n+pj_machine_dependent_reorg (insns)\n+     rtx insns;\n+{\n+  rtx cursor;\n+\n+  if (!optimize || !TARGET_REORG)\n+    return;\n+\n+  for (cursor = insns; cursor; cursor = NEXT_INSN (cursor))\n+    {\n+      rtx links;\n+      rtx cursor_pat;\n+\n+      /* We only care about INSNs, JUMP_INSNs. Ignore any special USE insns.  */\n+\n+      if ((GET_CODE (cursor) != INSN && GET_CODE (cursor) != JUMP_INSN)\n+\t  || GET_CODE (cursor_pat = PATTERN (cursor)) == USE\n+\t  || GET_CODE (cursor_pat) == CLOBBER\n+\t  || GET_CODE (cursor_pat) == ADDR_VEC\n+\t  || GET_CODE (cursor_pat) == ADDR_DIFF_VEC)\n+\tcontinue;\n+\n+      for (links = LOG_LINKS (cursor); links; links = XEXP (links, 1))\n+\t{\n+\t  rtx prev = XEXP (links, 0);\n+\t  rtx prev_pat;\n+\t  rtx prev_dest;\n+\t  rtx prev_src;\n+\t  rtx *dst_place;\n+\n+\t  if (GET_CODE (prev) == INSN\n+\t      && GET_CODE (prev_pat = PATTERN (prev)) == SET\n+\t      && GET_CODE (prev_dest = SET_DEST (prev_pat)) == REG\n+\t      && dead_or_set_p (cursor, prev_dest)\n+\t      && !reg_used_between_p (prev_dest, prev, cursor)\n+\t      && no_labels_between_p (prev, cursor)\n+\t      && no_jumps_between_p (prev, cursor)\n+\t      && !modified_between_p ((prev_src = SET_SRC (prev_pat)), prev,\n+\t\t\t\t      cursor)\n+\t      && (dst_place = unique_src_operand (&cursor_pat, prev_dest))\n+\t      && dst_place != NOT_UNIQUE\n+\t      && REGNO (prev_dest) != OPTOP_REG\n+\t      && GET_MODE (prev_dest) != XFmode\n+\t      && GET_MODE (*dst_place) == GET_MODE (SET_DEST (prev_pat)))\n+\t    {\n+\t      *dst_place = SET_SRC (prev_pat);\n+\t      PUT_CODE (prev, NOTE);\n+\t      NOTE_LINE_NUMBER (prev) = NOTE_INSN_DELETED;\n+\t    }\n+\t}\n+    }\n+}"}, {"sha": "816fa89795125a3287c8251db75f4d946715c52b", "filename": "gcc/config/pj/pj.h", "status": "added", "additions": 1333, "deletions": 0, "changes": 1333, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b992148d7a6a6b0fffd946131dd7cd6e6cc3958/gcc%2Fconfig%2Fpj%2Fpj.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b992148d7a6a6b0fffd946131dd7cd6e6cc3958/gcc%2Fconfig%2Fpj%2Fpj.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpj%2Fpj.h?ref=1b992148d7a6a6b0fffd946131dd7cd6e6cc3958", "patch": "@@ -0,0 +1,1333 @@\n+/* Definitions of target machine for GNU compiler for picoJava\n+   Copyright (C) 2000 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* Contributed by Steve Chamberlain of Transmeta (sac@pobox.com).  */\n+\n+\n+#define TARGET_VERSION  fputs (\"(picoJava)\", stderr);\n+\n+/* We support two different default configurations.  */\n+#undef ASM_SPEC\n+#ifdef TARGET_LITTLE_ENDIAN_DEFAULT\n+#define CPP_SPEC        \"%{mb:-D__BIG_ENDIAN__ }%{!mb:-D__LITTLE_ENDIAN__ }\" \n+#define ASM_SPEC        \"%{mb:-mb }%{!mb:-ml }\"\n+#else\n+#define CPP_SPEC        \"%{ml:-D__LITTLE_ENDIAN__ }%{!ml:-D__BIG_ENDIAN__}\"\n+#define ASM_SPEC        \"%{ml:-ml } %{!ml:-mb }\"\n+#endif\n+\n+#ifndef CPP_PREDEFINES\n+#define CPP_PREDEFINES \"-D__ELF__ -D__pj__ -Asystem(posix)\"\n+#endif\n+\f\n+/* Run-time compilation parameters selecting different hardware subsets.  */\n+\n+extern int target_flags;\n+\n+#define LITTLE_ENDIAN_BIT (1<<0)\n+#define EXTENSIONS_BIT    (1<<1)\n+#define PJ_TEST_BIT       (1<<2)\n+#define REORG_BIT         (1<<3)\n+\n+/* Nonzero if generating code for a little endian pico java.  */\n+\n+#define TARGET_LITTLE_ENDIAN     (target_flags & LITTLE_ENDIAN_BIT)\n+\n+/* Nonzero to turn on internal tests.  */\n+\n+#define TARGET_TEST              (target_flags & PJ_TEST_BIT)\n+\n+/* Nonzero to turn on picoJava extensions.  */\n+\n+#define TARGET_TM_EXTENSIONS     (target_flags & EXTENSIONS_BIT)\n+\n+/* Nonzero to turn on the reorganization pass.  */\n+\n+#define TARGET_REORG             (target_flags & REORG_BIT)\n+\n+#ifdef TARGET_LITTLE_ENDIAN_DEFAULT\n+#define TARGET_DEFAULT  (LITTLE_ENDIAN_BIT|EXTENSIONS_BIT|REORG_BIT)\n+#else\n+#define TARGET_DEFAULT  REORG_BIT\n+#endif\n+\n+#define TARGET_SWITCHES  \\\n+{ {\"l\",         LITTLE_ENDIAN_BIT, \"Generate little endian data\"           }, \\\n+  {\"b\",        -LITTLE_ENDIAN_BIT, \"Generate big endian data\"              }, \\\n+  {\"t\",         PJ_TEST_BIT,       \"Turn on maintainer testing code\"       }, \\\n+  {\"ext\",       EXTENSIONS_BIT,    \"Enable Transmeta picoJava extensions\"  }, \\\n+  {\"no-ext\",   -EXTENSIONS_BIT,    \"Disable Transmeta picoJava extensions\" }, \\\n+  {\"no-reorg\", -REORG_BIT,         \"Disable reorganization pass\"           }, \\\n+  {\"\",          TARGET_DEFAULT,    0 }}\n+\n+/* Sometimes certain combinations of command options do not make\n+   sense on a particular target machine.  You can define a macro\n+   `OVERRIDE_OPTIONS' to take account of this.  This macro, if\n+   defined, is executed once just after all the command options have\n+   been parsed.\n+\n+   Don't use this macro to turn on various extra optimizations for\n+   `-O'.  That is what `OPTIMIZATION_OPTIONS' is for.  \n+\n+   We take this chance to register the global variables with the garbage\n+   collector. */\n+\n+#define OVERRIDE_OPTIONS                                                \\\n+ do {                                                                   \\\n+   ggc_add_rtx_root (&pj_cmp_op0, 1);                                   \\\n+   ggc_add_rtx_root (&pj_cmp_op1, 1);                                   \\\n+ } while (0)\n+\n+/* Define this to change the optimizations performed by default.  */\n+#define OPTIMIZATION_OPTIONS(LEVEL,SIZE)                                \\\n+ do {                                                                   \\\n+   if (optimize)                                                        \\\n+       flag_force_addr = 1;                                             \\\n+ } while (0)\n+\f\n+/* Target machine storage layout.  */\n+\n+/* Define to use software floating point emulator for REAL_ARITHMETIC and\n+   decimal <-> binary conversion.  */\n+#define REAL_ARITHMETIC\n+\n+/* Define this if most significant bit is lowest numbered\n+   in instructions that operate on numbered bit-fields.  */\n+#define BITS_BIG_ENDIAN  0\n+\n+/* Define this if most significant byte of a word is the lowest numbered.  */\n+#define BYTES_BIG_ENDIAN (TARGET_LITTLE_ENDIAN == 0)\n+\n+/* Define this if most significant word of a multiword number is the lowest\n+   numbered.  */\n+#define WORDS_BIG_ENDIAN (TARGET_LITTLE_ENDIAN == 0)\n+\n+/* Define this to set the endianness to use in libgcc2.c, which can\n+   not depend on target_flags.  */\n+#if defined(TARGET_LITTLE_ENDIAN_DEFAULT)\n+#define LIBGCC2_WORDS_BIG_ENDIAN 0\n+#else\n+#define LIBGCC2_WORDS_BIG_ENDIAN 1\n+#endif\n+\n+/* Number of bits in an addressable storage unit.  */\n+#define BITS_PER_UNIT  8\n+\n+/* Width in bits of a \"word\", which is the contents of a machine register.\n+   Note that this is not necessarily the width of data type `int';\n+   if using 16-bit ints on a 68000, this would still be 32.\n+   But on a machine with 16-bit registers, this would be 16.  */\n+#define BITS_PER_WORD  32\n+#define MAX_BITS_PER_WORD 32\n+\n+/* Width of a word, in units (bytes).  */\n+#define UNITS_PER_WORD  4\n+\n+/* Width in bits of a pointer.\n+   See also the macro `Pmode' defined below.  */\n+#define POINTER_SIZE  32\n+\n+/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n+#define PARM_BOUNDARY   32\n+\n+/* Boundary (in *bits*) on which stack pointer should be aligned.  */\n+#define STACK_BOUNDARY  32\n+\n+/* Allocation boundary (in *bits*) for the code of a function.  */\n+#define FUNCTION_BOUNDARY  8\n+\n+/* Alignment of field after `int : 0' in a structure.  */\n+#define EMPTY_FIELD_BOUNDARY  32\n+\n+/* No data type wants to be aligned rounder than this.  */\n+#define BIGGEST_ALIGNMENT  32\n+\n+/* The best alignment to use in cases where we have a choice.  */\n+#define FASTEST_ALIGNMENT 32\n+\n+/* Make strings word-aligned so strcpy from constants will be faster.  */\n+#define CONSTANT_ALIGNMENT(EXP, ALIGN)  \\\n+  ((TREE_CODE (EXP) == STRING_CST       \\\n+    && (ALIGN) < FASTEST_ALIGNMENT)     \\\n+    ? FASTEST_ALIGNMENT : (ALIGN))\n+\n+/* Make arrays of chars word-aligned for the same reasons.  */\n+#define DATA_ALIGNMENT(TYPE, ALIGN)             \\\n+  (TREE_CODE (TYPE) == ARRAY_TYPE               \\\n+   && TYPE_MODE (TREE_TYPE (TYPE)) == QImode    \\\n+   && (ALIGN) < FASTEST_ALIGNMENT ? FASTEST_ALIGNMENT : (ALIGN))\n+\n+/* Set this non-zero if move instructions will actually fail to work\n+   when given unaligned data.  */\n+#define STRICT_ALIGNMENT 1\n+\f\n+\n+/* Standard register usage.  */\n+\n+/* Enumerate the hardware registers.  */\n+\n+enum\n+{\n+  R0_REG,       R1_REG,         R2_REG,         R3_REG, \n+  R4_REG,       R5_REG,         R6_REG,         R7_REG, \n+  R8_REG,       R9_REG,         R10_REG,        R11_REG,\n+  R12_REG,      R13_REG,        R14_REG,        R15_REG,\n+\n+  R16_REG,      R17_REG,        R18_REG,        R19_REG,\n+  R20_REG,      R21_REG,        R22_REG,        R23_REG,\n+  R24_REG,      R25_REG,        R26_REG,        R27_REG,\n+  R28_REG,      R29_REG,        R30_REG,        R31_REG,\n+\n+  I0_REG,       I1_REG,         I2_REG,         I3_REG,  \n+  I4_REG,       I5_REG,         I6_REG,         I7_REG,  \n+  I8_REG,       I9_REG,         I10_REG,        I11_REG, \n+  I12_REG,      I13_REG,        I14_REG,        I15_REG, \n+\n+  I16_REG,      I17_REG,        I18_REG,        I19_REG, \n+  I20_REG,      I21_REG,        I22_REG,        I23_REG, \n+  I24_REG,      I25_REG,        I26_REG,        I27_REG, \n+  I28_REG,      I29_REG,        I30_REG,        ISC_REG, \n+\n+  G0_REG,       G1_REG,         G2_REG,         G3_REG,  \n+  G4_REG,       G5_REG,         G6_REG,         G7_REG,  \n+  VARS_REG,     OPTOP_REG,      SC_REG,         PC_REG,  \n+  TICKS_REG,    SLOW_REG,       VA_REG,         D3_REG, \n+\n+  D4_REG,       D5_REG,         D6_REG,         D7_REG,\n+  Q0_REG,       Q1_REG,         Q2_REG,         Q3_REG,\n+  P0_REG,       P1_REG,         P2_REG,         P3_REG,\n+  P4_REG,       P5_REG,         P6_REG,         P7_REG,\n+\n+  O0_REG,       O1_REG,         O2_REG,         O3_REG, \n+  O4_REG,       O5_REG,         O6_REG,         O7_REG, \n+  O8_REG,       O9_REG,         O10_REG,        O11_REG,\n+  O12_REG,      O13_REG,        O14_REG,        O15_REG,\n+\n+  O16_REG,      O17_REG,        O18_REG,        O19_REG,\n+  O20_REG,      O21_REG,        O22_REG,        O23_REG,\n+  O24_REG,      O25_REG,        O26_REG,        O27_REG,\n+  O28_REG,      O29_REG,        O30_REG,        OSC_REG,\n+  \n+  LAST_O_REG=OSC_REG,\n+  LAST_R_REG=R31_REG,\n+  LAST_I_REG=ISC_REG,\n+  LAST_S_REG=P7_REG,\n+\n+};\n+\n+/* Useful predicates.  */\n+\n+#define STACK_REGNO_P(REGNO) \t\t\\\n+\t(((unsigned) (REGNO)) <= LAST_I_REG)\n+\n+#define OUTGOING_REGNO_P(REGNO) \t\\\n+  \t(((REGNO) >= O0_REG) && ((REGNO) <= LAST_O_REG))\n+\n+#define INCOMING_REGNO_P(REGNO)   \t\\\n+\t(((REGNO) >= I0_REG) && ((REGNO) <= LAST_I_REG))\n+\n+#define STACK_REG_RTX_P(RTX)    \t\\\n+\t(GET_CODE (RTX) == REG && STACK_REGNO_P (REGNO (RTX)))\n+\n+#define OUTGOING_REG_RTX_P(RTX) \t\\\n+\t(GET_CODE (RTX) == REG && OUTGOING_REGNO_P (REGNO (RTX)))\n+\n+#define OPTOP_REG_RTX_P(RTX) \t\t\\\n+\t(GET_CODE (RTX) == REG && REGNO (RTX) == OPTOP_REG)\n+\n+#define FIRST_PSEUDO_REGISTER 128\n+\n+/* 1 for registers that have pervasive standard uses\n+   and are not available for the register allocator.  */\n+\n+#define FIXED_REGISTERS                                                 \\\n+ {                                                                      \\\n+   0,0,0,0, 0,0,0,0,  /* r0 .. r7  */                                   \\\n+   0,0,0,0, 0,0,0,0,  /* r8 .. r15 */                                   \\\n+   0,0,0,0, 0,0,0,0,  /* r16.. r23 */                                   \\\n+   0,0,0,0, 0,0,0,0,  /* r24.. r31 */                                   \\\n+                                                                        \\\n+   0,0,0,0, 0,0,0,0,  /* i0 .. i7  */                                   \\\n+   0,0,0,0, 0,0,0,0,  /* i8 .. i15 */                                   \\\n+   0,0,0,0, 0,0,0,0,  /* i16.. i23 */                                   \\\n+   0,0,0,0, 0,0,0,0,  /* i24.. i31 */                                   \\\n+                                                                        \\\n+   1,0,0,1, 1,1,1,1,  /* g0 .. g7  */                                   \\\n+   1,1,1,1, 1,1,1,1,  /* vars, optop, sc, pc, ticks, slow, va, sgo */   \\\n+   1,1,1,1, 1,1,1,1,  /* d4 d5 d6 ap p0 p1 p2 p3 */                     \\\n+   1,1,1,1, 1,1,1,1,  /* q1 .. q7 */                                    \\\n+                                                                        \\\n+   0,0,0,0, 0,0,0,0,  /* o0 .. o7  */                                   \\\n+   0,0,0,0, 0,0,0,0,  /* o8 .. o15 */                                   \\\n+   0,0,0,0, 0,0,0,0,  /* o16.. o23 */                                   \\\n+   0,0,0,0, 0,0,0,0 } /* o24.. o31 */                                   \n+                                                                          \n+\n+/* 1 for registers not available across function calls.\n+   These must include the FIXED_REGISTERS and also any\n+   registers that can be used without being saved.\n+   The latter must include the registers where values are returned\n+   and the register where structure-value addresses are passed.\n+   Aside from that, you can include as many other registers as you like.  \n+\n+   We pretend that some standard registers are call clobbered so the\n+   exception handler code has somewhere to play.  */\n+\n+#define CALL_USED_REGISTERS                                             \\\n+ {                                                                      \\\n+   0,0,0,0, 0,0,0,0,  /* r0 ..r7  */                                    \\\n+   0,0,0,0, 0,0,0,0,  /* r8 ..r15 */                                    \\\n+   0,0,0,0, 1,1,1,1,  /* r16..r23 */                                    \\\n+   1,1,1,1, 1,1,1,1,  /* r24..r31 */                                    \\\n+                                                                        \\\n+   0,0,0,0, 0,0,0,0,  /* i0 ..i7  */                                    \\\n+   0,0,0,0, 0,0,0,0,  /* i8 ..i15 */                                    \\\n+   0,0,0,0, 0,0,0,0,  /* i16..i23 */                                    \\\n+   0,0,0,0, 0,0,0,0,  /* i24..i31 */                                    \\\n+                                                                        \\\n+   1,1,1,1, 0,0,0,0,  /* g0 ..g7  */                                    \\\n+   1,1,1,1, 1,1,1,1,  /* vars, optop, sc, pc, ticls, slow, va, sgo */   \\\n+   1,1,1,1, 1,1,1,1,  /* d4 d5 d6 ap p0..p3*/                           \\\n+   1,1,1,1, 1,1,1,1,  /* q0..q7  */                                     \\\n+                                                                        \\\n+   1,1,1,1, 1,1,1,1,  /* o0 ..o7  */                                    \\\n+   1,1,1,1, 1,1,1,1,  /* o8 ..o15 */                                    \\\n+   1,1,1,1, 1,1,1,1,  /* o16..o23 */                                    \\\n+   1,1,1,1, 1,1,1,1 } /* o24..o31 */                                    \n+  \n+/* Return number of consecutive hard regs needed starting at reg REGNO\n+   to hold something of mode MODE.\n+   This is ordinarily the length in words of a value of mode MODE\n+   but can be less for certain modes in special long registers.  */\n+\n+#define HARD_REGNO_NREGS(REGNO, MODE) \\\n+   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n+\n+   We can allow any mode in the general register or the result\n+   register.  It's only safe to put up to 4 bytes values elsewhere.  */\n+\n+#define HARD_REGNO_MODE_OK(REGNO, MODE)                               \\\n+   (((REGNO) <= LAST_R_REG || (REGNO) == G1_REG || GET_MODE_SIZE(MODE) <= 4 ) && !OUTGOING_REGNO_P(REGNO))\n+\n+/* Value is 1 if it is a good idea to tie two pseudo registers\n+   when one has mode MODE1 and one has mode MODE2.\n+   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n+   for any hard reg, then this must be 0 for correct output.  */\n+#define MODES_TIEABLE_P(MODE1, MODE2) 1\n+\n+/* Specify the registers used for certain standard purposes.\n+   The values of these macros are register numbers.  */\n+\n+/* Define this if the program counter is overloaded on a register.  */\n+#define PC_REGNUM               PC_REG\n+\n+/* Register to use for pushing function arguments.  */\n+#define STACK_POINTER_REGNUM    G0_REG\n+\n+/* Base register for access to local variables of the function.  */\n+#define FRAME_POINTER_REGNUM    R31_REG\n+\n+/* Base register for access to arguments of the function.  */\n+#define ARG_POINTER_REGNUM      R30_REG\n+\n+/* Register in which the static-chain is passed to a function.  */\n+#define STATIC_CHAIN_REGNUM     G1_REG\n+\n+/* Value should be nonzero if functions must have frame pointers.\n+   Zero means the frame pointer need not be set up (and parms may be\n+   accessed via the stack pointer) in functions that seem suitable.  */\n+#define FRAME_POINTER_REQUIRED  0\n+\n+/* This is an array of structures.  Each structure initializes one pair\n+   of eliminable registers.  The \"from\" register number is given first,\n+   followed by \"to\".  Eliminations of the same \"from\" register are listed\n+   in order of preference.  */\n+\n+#define ELIMINABLE_REGS                                                 \\\n+   { { VA_REG,                          STACK_POINTER_REGNUM    },      \\\n+     { FRAME_POINTER_REGNUM,            STACK_POINTER_REGNUM    },      \\\n+     { ARG_POINTER_REGNUM,              STACK_POINTER_REGNUM    } }    \n+     \n+/* Given FROM and TO register numbers, say whether this elimination\n+   is allowed.  */\n+#define CAN_ELIMINATE(FROM, TO) 1\n+\n+/* Define the offset between two registers, one to be eliminated, and the other\n+   its replacement, at the start of a routine.  */\n+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \\\n+  OFFSET =  (((FROM) == FRAME_POINTER_REGNUM) ? get_frame_size() : 0)\n+\n+/* For picoJava we have to save 12 bytes of information for a non local \n+   jump.  */\n+\n+#define STACK_SAVEAREA_MODE(x) ((x)==SAVE_NONLOCAL ? XFmode : Pmode)\n+\n+/* If the structure value address is not passed in a register, define\n+   `STRUCT_VALUE' as an expression returning an RTX for the place\n+   where the address is passed.  If it returns 0, the address is\n+   passed as an \"invisible\" first argument.  */\n+#define STRUCT_VALUE 0\n+\n+/* A C expression which can inhibit the returning of certain function\n+   values in registers, based on the type of value.  A nonzero value\n+   says to return the function value in memory, just as large\n+   structures are always returned.  Here TYPE will be a C expression\n+   of type `tree', representing the data type of the value.\n+\n+   Note that values of mode `BLKmode' must be explicitly handled by\n+   this macro.  Also, the option `-fpcc-struct-return' takes effect\n+   regardless of this macro.  On most systems, it is possible to\n+   leave the macro undefined; this causes a default definition to be\n+   used, whose value is the constant 1 for `BLKmode' values, and 0\n+   otherwise.\n+\n+   Do not use this macro to indicate that structures and unions\n+   should always be returned in memory.  You should instead use\n+   `DEFAULT_PCC_STRUCT_RETURN' to indicate this.  */\n+#define RETURN_IN_MEMORY(TYPE) \\\n+  ((TYPE_MODE (TYPE) == BLKmode) || int_size_in_bytes (TYPE) > 8)\n+\n+/* Don't default to pcc-struct-return, because we have already specified\n+   exactly how to return structures in the RETURN_IN_MEMORY macro.  */\n+#define DEFAULT_PCC_STRUCT_RETURN 0\n+\f\n+/* Define the classes of registers for register constraints in the\n+   machine description.  Also define ranges of constants.\n+\n+   One of the classes must always be named ALL_REGS and include all hard regs.\n+   If there is more than one class, another class must be named NO_REGS\n+   and contain no registers.\n+\n+   The name GENERAL_REGS must be the name of a class (or an alias for\n+   another name such as ALL_REGS).  This is the class of registers\n+   that is allowed by \"g\" or \"r\" in a register constraint.\n+   Also, registers outside this class are allocated only when\n+   instructions express preferences for them.\n+\n+   The classes must be numbered in nondecreasing order; that is,\n+   a larger-numbered class must never be contained completely\n+   in a smaller-numbered class.\n+\n+   For any two classes, it is very desirable that there be another\n+   class that represents their union.  */\n+\n+enum reg_class\n+{\n+  NO_REGS,\n+  OUT_REGS,         /* Registers for passing outgoing parameters.  */\n+  STD_REGS,         /* Standard registers, on opstack.  */\n+  ARG_REGS,         /* Incoming argument registers.  */\n+  SRC_REGS,         /* All registers valid as a source.  */\n+  DST_REGS,         /* All registers valid as a destination.  */\n+  ALL_REGS,\n+  LIM_REG_CLASSES,\n+};\n+\n+#define GENERAL_REGS SRC_REGS\n+#define N_REG_CLASSES  (int) LIM_REG_CLASSES\n+\n+/* Give names of register classes as strings for dump files.  */\n+#define REG_CLASS_NAMES   \\\n+{                         \\\n+  \"NO_REGS\",              \\\n+  \"OUT_REGS\",             \\\n+  \"STD_REGS\",             \\\n+  \"ARG_REGS\",             \\\n+  \"SRC_REGS\",             \\\n+  \"DST_REGS\",             \\\n+  \"ALL_REGS\",             \\\n+}\n+\n+/* Define which registers fit in which classes.\n+   This is an initializer for a vector of HARD_REG_SET\n+   of length N_REG_CLASSES.  */\n+\n+#define REG_CLASS_CONTENTS                                              \\\n+{                                                                       \\\n+  { 0x00000000, 0x00000000, 0x00000000, 0x00000000 }, /* NO_REGS  */    \\\n+  { 0x00000000, 0x00000000, 0x00000000, 0xffffffff }, /* OUT_REGS */    \\\n+  { 0xffffffff, 0x00000000, 0x00000000, 0x00000000 }, /* STD_REGS */    \\\n+  { 0x00000000, 0xffffffff, 0x00000000, 0x00000000 }, /* ARG_REGS */    \\\n+  { 0xffffffff, 0xffffffff, 0x000fff0f, 0x00000000 }, /* SRC_REGS */    \\\n+  { 0xffffffff, 0xffffffff, 0x000fff0f, 0xffffffff }, /* DST_REGS */    \\\n+  { 0xffffffff, 0xffffffff, 0x000fff0f, 0xffffffff }, /* ALL_REGS */    \\\n+}\n+\n+/* The same information, inverted:\n+   Return the class number of the smallest class containing\n+   reg number REGNO.  This could be a conditional expression\n+   or could index an array.  */\n+\n+#define REGNO_REG_CLASS(REGNO)                  \\\n+     ( ((REGNO) <= LAST_R_REG) ? STD_REGS       \\\n+     : ((REGNO) <= LAST_I_REG) ? ARG_REGS       \\\n+     : ((REGNO) <= LAST_S_REG) ? SRC_REGS       \\\n+     : OUT_REGS)\n+        \n+/* The class value for index registers, and the one for base regs.  */\n+#define INDEX_REG_CLASS  GENERAL_REGS\n+#define BASE_REG_CLASS   GENERAL_REGS\n+\n+/* Get reg_class from a letter such as appears in the machine\n+   description.  */\n+\n+#define REG_CLASS_FROM_LETTER(C) \\\n+   ( (C) == 'S' ? SRC_REGS \\\n+   : (C) == 'D' ? DST_REGS \\\n+   : NO_REGS)\n+\f\n+/* The letters I, J, K, L and M in a register constraint string\n+   can be used to stand for particular ranges of immediate operands.\n+   This macro defines what the ranges are.\n+   C is the letter, and VALUE is a constant value.\n+   Return 1 if VALUE is in the range specified by C.\n+\n+   I: arithmetic operand -127..128, as used in inc.\n+   K: 0.\n+   */\n+\n+#define CONST_OK_FOR_I(VALUE) \\\n+ (((HOST_WIDE_INT)(VALUE))>= -128 && ((HOST_WIDE_INT)(VALUE)) <= 127)\n+\n+#define CONST_OK_FOR_K(VALUE) ((VALUE)==0)\n+\n+#define CONST_OK_FOR_LETTER_P(VALUE, C)         \\\n+     ((C) == 'I' ? CONST_OK_FOR_I (VALUE)       \\\n+    : (C) == 'K' ? CONST_OK_FOR_K (VALUE)       \\\n+    : 0)\n+\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C) 0\n+\n+/* Given an rtx X being reloaded into a reg required to be\n+   in class CLASS, return the class of reg to actually use.\n+   In general this is just CLASS; but on some machines\n+   in some cases it is preferable to use a more restrictive class.  */\n+\n+#define PREFERRED_RELOAD_CLASS(X, CLASS) (CLASS)\n+\n+/* Return the maximum number of consecutive registers\n+   needed to represent mode MODE in a register of class CLASS.\n+\n+   With picoJava this is the size of MODE in words.  */\n+\n+#define CLASS_MAX_NREGS(CLASS, MODE) \\\n+     ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+\n+/* A C expression whose value is nonzero if pseudos that have been\n+   assigned to registers of class CLASS would likely be spilled\n+   because registers of CLASS are needed for spill registers.\n+\n+   For picoJava, something that isn't an incoming argument or a normal\n+   register is going to be very hard to get at. */\n+\n+#define CLASS_LIKELY_SPILLED_P(X) ((X) != STD_REGS && (X) != ARG_REGS)\n+\f\n+/* Stack layout; function entry, exit and calling.  */\n+\n+/* Define this if pushing a word on the stack\n+   makes the stack pointer a smaller address.  */\n+\n+#define STACK_GROWS_DOWNWARD 1\n+\n+/* Define this macro if successive arguments to a function occupy\n+   decreasing addresses on the stack.  */\n+\n+#define ARGS_GROW_DOWNWARD 1\n+\n+/*  Define this macro if the addresses of local variable slots are at\n+    negative offsets from the frame pointer.  */\n+\n+#define FRAME_GROWS_DOWNWARD 1\n+\n+/* Offset from the frame pointer to the first local variable slot to\n+   be allocated.  */\n+\n+#define STARTING_FRAME_OFFSET  0\n+\n+/* If we generate an insn to push BYTES bytes,\n+   this says how many the stack pointer really advances by.  */\n+\n+/* Don't define PUSH_ROUNDING, since the hardware doesn't do this.\n+   When PUSH_ROUNDING is not defined, PARM_BOUNDARY will cause gcc to\n+   do correct alignment.  */\n+\n+#define PUSH_ROUNDING(NPUSHED)  (((NPUSHED) + 3) & ~3)\n+\n+/* Offset of first parameter from the argument pointer register value.  */\n+\n+#define FIRST_PARM_OFFSET(FNDECL)  0\n+\n+/* Value is the number of byte of arguments automatically\n+   popped when returning from a subroutine call.\n+   FUNDECL is the declaration node of the function (as a tree),\n+   FUNTYPE is the data type of the function (as a tree),\n+   or for a library call it is an identifier node for the subroutine name.\n+   SIZE is the number of bytes of arguments passed on the stack.  */\n+\n+#define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE) 0 \n+\n+/* Define how to find the value returned by a function.\n+   VALTYPE is the data type of the value (as a tree).\n+   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n+   otherwise, FUNC is 0.  */\n+\n+#define FUNCTION_VALUE(VALTYPE, FUNC) \\\n+   gen_rtx_REG (TYPE_MODE (VALTYPE), G1_REG)\n+\n+/* 1 if N is a possible register number for a function value\n+   as seen by the caller.  */\n+\n+#define FUNCTION_VALUE_REGNO_P(N)  \\\n+  ((N) == G1_REG)\n+\n+/* 1 if N is a possible register number for function argument passing.  */\n+#define FUNCTION_ARG_REGNO_P(N) 0\n+\n+/* Define how to find the value returned by a library function\n+   assuming the value has mode MODE.  */\n+\n+#define LIBCALL_VALUE(MODE) \\\n+  gen_rtx_REG (MODE, G1_REG)\n+\n+/* Define this macro to be a nonzero value if the location where a\n+   function argument is passed depends on whether or not it is a\n+   named argument.  */\n+\n+#define STRICT_ARGUMENT_NAMING 1\n+\n+/* Define a data type for recording info about an argument list\n+   during the scan of that argument list.  This data type should\n+   hold all necessary information about the function itself\n+   and about the args processed so far, enough to enable macros\n+   such as FUNCTION_ARG to determine where the next arg should go.\n+\n+   For picoJava this is a struct which remembers the number of\n+   arguments named, the total number of words passed and an adjustment\n+   factor to use if accessing a double word argument with a single\n+   word memop.  See the comments at the head pj.c for more information */\n+\n+#define ARGS_IN_REGS 32\n+\n+struct pj_args\n+{\n+  int named_words;\n+  int total_words;\n+  int arg_count;\n+  int arg_adjust[ARGS_IN_REGS];\n+};\n+\n+#define CUMULATIVE_ARGS  struct pj_args\n+\n+#define FUNCTION_INCOMING_ARG(asf,pmode,passtyped,named) \\\n+    pj_function_incoming_arg(&asf,pmode,passtyped,named)\n+\n+/* Initialize a variable CUM of type CUMULATIVE_ARGS\n+   for a call to a function whose data type is FNTYPE.\n+   For a library call, FNTYPE is 0.\n+ */\n+\n+#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, INDIRECT) \\\n+  (CUM).named_words = 0;                                     \\\n+  (CUM).total_words = 0;                                     \\\n+  (CUM).arg_count = 0;\n+\n+/* Update the data in CUM to advance over an argument\n+   of mode MODE and data type TYPE.\n+\n+   picoJava only ever sends scalars as arguments.  Aggregates are sent\n+   by reference.  */\n+\n+#define PJ_ARG_WORDS(MODE)  \\\n+   ((GET_MODE_SIZE (MODE) + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD)\n+\n+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)                    \\\n+{                                                                       \\\n+  (CUM).total_words += PJ_ARG_WORDS (MODE);                             \\\n+  if (NAMED)                                                            \\\n+    (CUM).named_words += PJ_ARG_WORDS (MODE);                           \\\n+  (CUM).arg_count++;                                                    \\\n+}\n+\n+/* Define where to put the arguments to a function.\n+   Value is zero to push the argument on the stack,\n+   or a hard register in which to store the argument.\n+\n+   MODE is the argument's machine mode.\n+   TYPE is the data type of the argument (as a tree).\n+    This is null for libcalls where that information may\n+    not be available.\n+   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n+    the preceding args and about the function being called.\n+   NAMED is nonzero if this argument is a named parameter\n+    (otherwise it is an extra parameter matching an ellipsis).\n+\n+   For picoJava scalar arguments are normally in registers.  */\n+\n+\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED)                            \\\n+    ( ((CUM).total_words + PJ_ARG_WORDS (MODE) < ARGS_IN_REGS)          \\\n+       ? gen_rtx (REG, MODE, O0_REG + (CUM).total_words)                \\\n+       : NULL_RTX)\n+\n+\n+/* A C expression that indicates when an argument must be passed by\n+   reference.  If nonzero for an argument, a copy of that argument is\n+   made in memory and a pointer to the argument is passed instead of\n+   the argument itself.  The pointer is passed in whatever way is\n+   appropriate for passing a pointer to that type.  */\n+\n+/* All aggregates and arguments larger than 8 bytes are passed this way.  */\n+\n+#define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED) \\\n+ (TYPE && (AGGREGATE_TYPE_P (TYPE) || int_size_in_bytes (TYPE) > 8))\n+\n+/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n+   the stack pointer does not matter.  The value is tested only in\n+   functions that have frame pointers.\n+   No definition is equivalent to always zero.  */\n+\n+#define EXIT_IGNORE_STACK 0\n+\f\n+/* Trampoline support.  */\n+\n+/* A picoJava trampoline looks like:\n+\n+ 0000 11DEAD            sipush %lo16(static)\n+ 0003 EDDEAD            sethi  %hi16(static)\n+ 0006 FF7D              write_global1\n+ 0008 11DEAD            sipush %lo16(fn)\n+ 000b EDDEAD            sethi  %hi16(fn)\n+ 000e FF60              write_pc\n+*/ \n+\n+/* Length in units of the trampoline for entering a nested function.  */\n+#define TRAMPOLINE_SIZE  16\n+\n+/* Alignment required for a trampoline in bits .  */\n+#define TRAMPOLINE_ALIGNMENT  32\n+\n+#define TRAMPOLINE_TEMPLATE(FILE) \\\n+  fprintf (FILE, \"\\tsipush 0xdead\\n\"); \\\n+  fprintf (FILE, \"\\tsethi  0xdead\\n\"); \\\n+  fprintf (FILE, \"\\twrite_global1\\n\"); \\\n+  fprintf (FILE, \"\\tsipush 0xdead\\n\"); \\\n+  fprintf (FILE, \"\\tsethi  0xdead\\n\"); \\\n+  fprintf (FILE, \"\\twrite_pc\\n\"); \n+\n+/* Emit RTL insns to initialize the variable parts of a trampoline.\n+   FNADDR is an RTX for the address of the function's pure code.\n+   CXT is an RTX for the static chain value for the function.  */\n+\n+#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)                             \\\n+{                                                                             \\\n+  static int off[4] = { 1, 0, 4, 3 };                                         \\\n+  int i;                                                                      \\\n+                                                                              \\\n+  /* Move the FNADDR and CXT into the instruction stream. Do this byte        \\\n+     by byte to make sure it works for either endianness.  */                 \\\n+                                                                              \\\n+  for (i = 0; i < 4; i++)                                                     \\\n+    emit_move_insn                                                            \\\n+      (gen_rtx_MEM (QImode,                                                   \\\n+                    plus_constant (tramp, off[i] + 1)),                       \\\n+       gen_rtx_TRUNCATE (QImode,                                              \\\n+                         expand_shift (RSHIFT_EXPR, SImode,                   \\\n+                                       CXT, size_int (i * 8), 0, 1)));        \\\n+                                                                              \\\n+  for (i = 0; i < 4; i++)                                                     \\\n+    emit_move_insn                                                            \\\n+      (gen_rtx_MEM (QImode,                                                   \\\n+                    plus_constant (tramp, off[i] + 9)),                       \\\n+       gen_rtx_TRUNCATE (QImode,                                              \\\n+                         expand_shift (RSHIFT_EXPR, SImode,                   \\\n+                                       FNADDR, size_int (i * 8), 0, 1)));     \\\n+}\n+\n+/* Output assembler code to FILE to increment profiler label # LABELNO\n+   for profiling a function entry.  */\n+\n+#define FUNCTION_PROFILER(FILE, LABELNO)                        \\\n+ fprintf (FILE, \"\\tsipush %%lo16(.LP%d)\\n\", (LABELNO));         \\\n+ fprintf (FILE, \"\\tsethi  %%hi16(.LP%d)\\n\", (LABELNO));         \\\n+ fprintf (FILE, \"\\tsipush %%lo16(_mcount)\\n\");                  \\\n+ fprintf (FILE, \"\\tsethi  %%hi16(_mcount)\\n\");                  \\\n+ fprintf (FILE, \"\\ticonst_3\\n\");                                \\\n+ fprintf (FILE, \"\\tcall\\n\");                                    \n+\n+\f\n+/* Addressing modes, and classification of registers for them.  */\n+\n+#define HAVE_POST_INCREMENT  1\n+#define HAVE_PRE_INCREMENT   1\n+#define HAVE_POST_DECREMENT  1\n+#define HAVE_PRE_DECREMENT   1\n+\n+/* These assume that REGNO is a hard or pseudo reg number.\n+   They give nonzero only if REGNO is a hard reg of the suitable class\n+   or a pseudo reg currently allocated to a suitable hard reg.\n+   Since they use reg_renumber, they are safe only once reg_renumber\n+   has been allocated, which happens in local-alloc.c.  */\n+\n+/* Any register is OK for a base or an index.  As is something that has\n+   been spilled to memory.  */\n+\n+#define REGNO_OK_FOR_BASE_P(REGNO) 1\n+#define REGNO_OK_FOR_INDEX_P(REGNO) 1\n+\n+/* Maximum number of registers that can appear in a valid memory\n+   address.  \n+\n+   Arbitarily limited to 20.  */\n+\n+#define MAX_REGS_PER_ADDRESS 20\n+\n+/* Recognize any constant value that is a valid address.  */\n+\n+#define CONSTANT_ADDRESS_P(X)                                   \\\n+  (GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF      \\\n+   || GET_CODE (X) == CONST_INT || GET_CODE (X) == CONST)\n+\n+/* Nonzero if the constant value X is a legitimate general operand.  */\n+\n+#define LEGITIMATE_CONSTANT_P(X) \\\n+  (GET_CODE (X) == CONST_DOUBLE ? (pj_standard_float_constant (X)!=0) : 1)\n+\n+/* Letters in the range `Q' through `U' in a register constraint string\n+   may be defined in a machine-dependent fashion to stand for arbitrary\n+   operand types.\n+\n+   For picoJava, `S' handles a source operand. */\n+\n+#define EXTRA_CONSTRAINT(OP, C)                         \\\n+   ((C) == 'S' ? pj_source_operand (OP, GET_MODE (OP)) : 0)\n+\n+/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx and\n+   check its validity for a certain class.  */\n+\n+#define REG_OK_FOR_BASE_P(X) 1\n+#define REG_OK_FOR_INDEX_P(x) 0\n+\n+\f\n+/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n+   that is a valid memory address for an instruction.\n+   The MODE argument is the machine mode for the MEM expression\n+   that wants to use this address.  \n+\n+   We may have arbitrarily complex addressing modes, but we get better\n+   cse of address expressions if we generate code with simple\n+   addressing modes and clean up redundant register operations later\n+   in the machine dependent reorg pass.  */\n+\n+#define SRC_REG_P(X) \\\n+ (REG_P(X) && !OUTGOING_REG_RTX_P (X))\n+\n+#define SIMPLE_ADDRESS(X) \\\n+ (SRC_REG_P(X) || CONSTANT_ADDRESS_P(X))\n+\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, LABEL)                          \\\n+   if (SIMPLE_ADDRESS(X)) goto LABEL;                                     \\\n+   if ((GET_CODE (X) == POST_INC                                          \\\n+       || GET_CODE (X) == PRE_INC                                         \\\n+       || GET_CODE (X) == POST_DEC                                        \\\n+       || GET_CODE (X) == PRE_DEC) && SRC_REG_P(XEXP (X, 0))) goto LABEL; \\\n+\n+/* Try machine-dependent ways of modifying an illegitimate address\n+   to be legitimate.  If we find one, return the new, valid address.\n+   This macro is used in only one place: `memory_address' in explow.c.\n+\n+   OLDX is the address as it was before break_out_memory_refs was called.\n+   In some cases it is useful to look at this to decide what needs to be done.\n+\n+   MODE and WIN are passed so that this macro can use\n+   GO_IF_LEGITIMATE_ADDRESS.\n+\n+   It is always safe for this macro to do nothing.  It exists to recognize\n+   opportunities to optimize the output.  */\n+\n+#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)\n+\n+/* Go to LABEL if ADDR (a legitimate address expression)\n+   has an effect that depends on the machine mode it is used for.  */\n+\n+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)                        \\\n+{                                                                       \\\n+  if (GET_CODE(ADDR) == PRE_DEC || GET_CODE(ADDR) == POST_INC           \\\n+      || GET_CODE(ADDR) == PRE_INC || GET_CODE(ADDR) == POST_DEC)       \\\n+    goto LABEL;                                                         \\\n+}\n+\f\n+/* Specify the machine mode that this machine uses\n+   for the index in the tablejump instruction.  */\n+#define CASE_VECTOR_MODE SImode\n+\n+/* Define as C expression which evaluates to nonzero if the tablejump\n+   instruction expects the table to contain offsets from the address of the\n+   table.  */\n+\n+#define CASE_VECTOR_PC_RELATIVE 1\n+\n+/* Specify the tree operation to be used to convert reals to integers.  */\n+#define IMPLICIT_FIX_EXPR  FIX_ROUND_EXPR\n+\n+/* This is the kind of divide that is easiest to do in the general case.  */\n+#define EASY_DIV_EXPR  TRUNC_DIV_EXPR\n+\n+/* 'char' is signed by default.  */\n+#define DEFAULT_SIGNED_CHAR  1\n+\n+/* The type of size_t unsigned int.  */\n+#define SIZE_TYPE \"unsigned int\"\n+\n+/* Don't cse the address of the function being compiled.  */\n+\n+#define NO_RECURSIVE_FUNCTION_CSE (!optimize_size)\n+\n+/* Max number of bytes we can move from memory to memory\n+   in one reasonably fast instruction.  */\n+\n+#define MOVE_MAX 4\n+\n+/* Max number of bytes we want move_by_pieces to be able to copy\n+   efficiently.  */\n+\n+#define MOVE_MAX_PIECES 4\n+\n+/* Define if operations between registers always perform the operation\n+   on the full register even if a narrower mode is specified.  */\n+/*#define WORD_REGISTER_OPERATIONS*/\n+\n+/* Define if loading in MODE, an integral mode narrower than BITS_PER_WORD\n+   will either zero-extend or sign-extend.  The value of this macro should\n+   be the code that says which one of the two operations is implicitly\n+   done, NIL if none.  */\n+\n+#define LOAD_EXTEND_OP(MODE) SIGN_EXTEND\n+\n+/* Define if loading short immediate values into registers sign extends.  */\n+\n+#define SHORT_IMMEDIATES_SIGN_EXTEND\n+\n+/* Define this if zero-extension is slow (more than one real\n+   instruction).  */\n+\n+/* #define SLOW_ZERO_EXTEND  */\n+\n+/* Nonzero if access to memory by bytes is no faster than for words.  */\n+#define SLOW_BYTE_ACCESS 1\n+\n+#define INT_TYPE_SIZE           32\n+\n+/* A C expression that is nonzero if on this machine the number of\n+   bits actually used for the count of a shift operation is equal to the\n+   number of bits needed to represent the size of the object being\n+   shifted.  */\n+\n+#define SHIFT_COUNT_TRUNCATED 1\n+\n+/* All integers have the same format so truncation is easy.  */\n+\n+#define TRULY_NOOP_TRUNCATION(OUTPREC,INPREC)  1\n+\n+/* Define this if addresses of constant functions\n+   shouldn't be put through pseudo regs where they can be cse'd.\n+   Desirable on machines where ordinary constants are expensive\n+   but a CALL with constant address is cheap.  */\n+\n+#define NO_FUNCTION_CSE (!optimize_size)\n+\n+/* Chars and shorts should be passed as ints.  */\n+\n+#define PROMOTE_PROTOTYPES 1\n+\n+/* The machine modes of pointers and functions.  */\n+\n+#define Pmode  SImode\n+#define FUNCTION_MODE  Pmode\n+\n+\f\n+/* A part of a C `switch' statement that describes the relative costs\n+   of constant RTL expressions.  It must contain `case' labels for\n+   expression codes `const_int', `const', `symbol_ref', `label_ref'\n+   and `const_double'.  Each case must ultimately reach a `return'\n+   statement to return the relative cost of the use of that kind of\n+   constant value in an expression.  The cost may depend on the\n+   precise value of the constant, which is available for examination\n+   in X, and the rtx code of the expression in which it is contained,\n+   found in OUTER_CODE.\n+  \n+   CODE is the expression code--redundant, since it can be obtained\n+   with `GET_CODE (X)'.  */\n+\n+#define CONST_COSTS(RTX,CODE,OUTER_CODE)                        \\\n+  case CONST_INT:                                               \\\n+    return INTVAL (RTX) >= -1 && INTVAL (RTX) <= 5 ?  1         \\\n+         : INTVAL (RTX) >= -32768 && INTVAL (RTX) <= 32767 ? 2  \\\n+         : 3;                                                   \\\n+  case CONST:                                                   \\\n+  case LABEL_REF:                                               \\\n+  case SYMBOL_REF:                                              \\\n+    return 3;                                                   \\\n+  case CONST_DOUBLE:                                            \\\n+   return pj_standard_float_constant (RTX) ? 1 : 4;             \\\n+\n+/* Like `CONST_COSTS' but applies to nonconstant RTL expressions.\n+   This can be used, for example, to indicate how costly a multiply\n+   instruction is.  In writing this macro, you can use the construct\n+   `COSTS_N_INSNS (N)' to specify a cost equal to N fast\n+   instructions.  OUTER_CODE is the code of the expression in which X\n+   is contained. */\n+\n+#define RTX_COSTS(X,CODE,OUTER_CODE)                                    \\\n+  case MULT:                                                            \\\n+    if (GET_CODE (XEXP (X, 1)) == CONST_INT)                            \\\n+      {                                                                 \\\n+        unsigned HOST_WIDE_INT value = INTVAL (XEXP (X, 1));            \\\n+        int nbits = 0;                                                  \\\n+                                                                        \\\n+        while (value != 0)                                              \\\n+          {                                                             \\\n+            nbits++;                                                    \\\n+            value >>= 1;                                                \\\n+          }                                                             \\\n+                                                                        \\\n+          total = COSTS_N_INSNS (nbits);                                \\\n+      }                                                                 \\\n+    else                                                                \\\n+      total = COSTS_N_INSNS (10);                                       \\\n+    break;\n+\n+/* Compute extra cost of moving data between one register class and\n+   another.  */\n+\n+#define REGISTER_MOVE_COST(SRC_CLASS, DST_CLASS)                \\\n+      ((SRC_CLASS == STD_REGS || SRC_CLASS == ARG_REGS)?  2 : 10)\n+\n+\f\n+/* Assembler output control.  */\n+\n+/* A C string constant describing how to begin a comment in the target\n+   assembler language.  The compiler assumes that the comment will end at\n+   the end of the line.  */\n+#define ASM_COMMENT_START \"!\"\n+\n+/* The text to go at the start of the assembler file.  */\n+\n+#undef ASM_FILE_START\n+#define ASM_FILE_START(FILE)                                                 \\\n+  fprintf (FILE,\"\\t.file\\t\\\"%s\\\"\\n\", main_input_filename);                   \\\n+  fprintf (FILE,\"\\t! %s\\n\", TARGET_LITTLE_ENDIAN ? \".little\" : \".big\");      \\\n+  fprintf (FILE,\"\\t.align 4\\n\");\n+\n+#define ASM_LONG \".long\"\n+#define ASM_APP_ON              \"\"\n+#define ASM_APP_OFF             \"\"\n+#define FILE_ASM_OP             \"\\t.file\\n\"\n+\n+#define SET_ASM_OP              \".set\"\n+\n+/* How to change between sections.  */\n+\n+#define TEXT_SECTION_ASM_OP             \"\\t.text\"\n+#define DATA_SECTION_ASM_OP             \"\\t.data\"\n+\n+/* This special macro is used to output the asm pseduo op which allows\n+   the linker to fixup broken calling conentions.  */\n+\n+#define ASM_OUTPUT_FUNCTION_PREFIX(FILE, FNNAME)                        \\\n+do { fputs (current_function_varargs || current_function_stdarg         \\\n+            ? \"\\t.varargs_words_needed\\t\" : \"\\t.words_needed\\t\",        \\\n+            FILE);                                                      \\\n+     assemble_name (FILE, FNNAME);                                      \\\n+     fprintf (FILE, \", %d\\n\", current_function_args_info.named_words);  \\\n+   } while (0)\n+\n+/* If defined, a C expression whose value is a string containing the\n+   assembler operation to identify the following data as\n+   uninitialized G data.  If not defined, and neither\n+   `ASM_OUTPUT_BSS' nor `ASM_OUTPUT_ALIGNED_BSS' are defined,\n+   uninitialized global data will be output in the data section if\n+   `-fno-common' is passed, otherwise `ASM_OUTPUT_COMMON' will be\n+   used.  */\n+\n+#define BSS_SECTION_ASM_OP      \".section\\t.bss\"\n+\n+/* Like `ASM_OUTPUT_BSS' except takes the required alignment as a\n+   separate, explicit argument.  If you define this macro, it is used\n+   in place of `ASM_OUTPUT_BSS', and gives you more flexibility in\n+   handling the required alignment of the variable.  The alignment is\n+   specified as the number of bits.\n+\n+   Try to use function `asm_output_aligned_bss' defined in file\n+   `varasm.c' when defining this macro.  */\n+\n+#define ASM_OUTPUT_ALIGNED_BSS(FILE, DECL, NAME, SIZE, ALIGN) \\\n+  asm_output_aligned_bss (FILE, DECL, NAME, SIZE, ALIGN)\n+\n+\n+/* Define this so that jump tables go in same section as the current function,\n+   which could be text or it could be a user defined section.  */\n+#define JUMP_TABLES_IN_TEXT_SECTION 1\n+\n+/* The assembler's names for the registers.  */\n+\n+#define REGISTER_NAMES                                          \\\n+{                                                               \\\n+   \"r0\", \"r1\",  \"r2\",  \"r3\",  \"r4\",  \"r5\",  \"r6\", \"r7\",         \\\n+   \"r8\", \"r9\",  \"r10\", \"r11\", \"r12\", \"r13\", \"r14\",\"r15\",        \\\n+   \"r16\",\"r17\", \"r18\", \"r19\", \"r20\", \"r21\", \"r22\",\"r23\",        \\\n+   \"r24\",\"r25\", \"r26\", \"r27\", \"r28\", \"r29\", \"r30\",\"r31\",        \\\n+                                                                \\\n+   \"i0\", \"i1\",  \"i2\",  \"i3\",  \"i4\",  \"i5\",  \"i6\", \"i7\",         \\\n+   \"i8\", \"i9\",  \"i10\", \"i11\", \"i12\", \"i13\", \"i14\",\"i15\",        \\\n+   \"i16\",\"i17\", \"i18\", \"i19\", \"i20\", \"i21\", \"i22\",\"i23\",        \\\n+   \"i24\",\"i25\", \"i26\", \"i27\", \"i28\", \"i29\", \"i30\",\"i31\",        \\\n+                                                                \\\n+   \"global0\",   \"global1\",    \"global2\",    \"global3\",          \\\n+   \"global4\",   \"global5\",    \"global6\",    \"global7\",          \\\n+   \"vars\",      \"optop\",      \"sc\",         \"pc\",               \\\n+   \"ticks\",     \"slow\",       \"va\",         \"d3\",               \\\n+   \"d4\",        \"d5\",         \"d6\",         \"ap\",               \\\n+   \"p0\",        \"p1\",         \"p2\",         \"p3\",               \\\n+   \"q0\", \"q1\",  \"q2\",  \"q3\",  \"q4\",  \"q5\",  \"q6\", \"q7\",         \\\n+                                                                \\\n+   \"o0\", \"o1\",  \"o2\",  \"o3\",  \"o4\",  \"o5\",  \"o6\", \"o7\",         \\\n+   \"o8\", \"o9\",  \"o10\", \"o11\", \"o12\", \"o13\", \"o14\",\"o15\",        \\\n+   \"o16\",\"o17\", \"o18\", \"o19\", \"o20\", \"o21\", \"o22\",\"o23\",        \\\n+   \"o24\",\"o25\", \"o26\", \"o27\", \"o28\", \"o29\", \"o30\",\"o31\"}        \\\n+\n+\n+/* Output a label definition.  */\n+\n+#define ASM_OUTPUT_LABEL(FILE,NAME) \\\n+  do { assemble_name ((FILE), (NAME)); fputs (\":\\n\", (FILE)); } while (0)\n+\n+/* This is how to output an assembler line\n+   that says to advance the location counter\n+   to a multiple of 2**LOG bytes.  */\n+\n+#define ASM_OUTPUT_ALIGN(FILE,LOG)      \t\\\n+  if ((LOG) != 0)                       \t\\\n+    fprintf ((FILE), \"\\t.align %d\\n\", (LOG))\n+\n+/* Output a globalising directive for a label.  */\n+\n+#define ASM_GLOBALIZE_LABEL(STREAM,NAME)        \\\n+  (fprintf ((STREAM), \"\\t.global\\t\"),           \\\n+   assemble_name ((STREAM), (NAME)),            \\\n+   fputc ('\\n', (STREAM)))\n+\n+/* After an opcode has been printed, there's nothing on the line any\n+   more.  */\n+\n+#define ASM_OUTPUT_OPCODE(STREAM, P)  \t\t\\\n+   pj_stuff_on_line = 0;\n+\n+/* The prefix to add to user-visible assembler symbols.  */\n+\n+//#define USER_LABEL_PREFIX \"\"\n+\n+/* The prefix to add to an internally generated label.  */\n+\n+//#define LOCAL_LABEL_PREFIX \"\"\n+\n+/* Construct a private name.  */\n+\n+#define ASM_FORMAT_PRIVATE_NAME(OUTVAR,NAME,NUMBER)     \\\n+  ((OUTVAR) = (char *) alloca (strlen (NAME) + 10),     \\\n+   sprintf ((OUTVAR), \"%s.%d\", (NAME), (NUMBER)))\n+\n+/* Output a relative address table.  */\n+\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(STREAM,BODY,VALUE,REL)                 \\\n+      asm_fprintf ((STREAM), \"\\t.long\\t.L%d-.L%di\\n\", (VALUE),(REL));\n+\n+#define ADDR_VEC_ALIGN(VEC) 0\n+\n+/* Output various types of constants.  */\n+\n+/* This is how to output an assembler line defining a `double'.  */\n+\n+#define ASM_OUTPUT_DOUBLE(FILE,VALUE)                   \\\n+do { char dstr[30];                                     \\\n+     REAL_VALUE_TO_DECIMAL ((VALUE), \"%.20e\", dstr);    \\\n+     fprintf ((FILE), \"\\t.double %s\\n\", dstr);          \\\n+   } while (0)\n+\n+/* This is how to output an assembler line defining a `float' constant.  */\n+\n+#define ASM_OUTPUT_FLOAT(FILE,VALUE)                    \\\n+do { char dstr[30];                                     \\\n+     REAL_VALUE_TO_DECIMAL ((VALUE), \"%.20e\", dstr);    \\\n+     fprintf ((FILE), \"\\t.float %s\\n\", dstr);           \\\n+   } while (0)\n+\n+#define ASM_OUTPUT_INT(STREAM, EXP)             \\\n+  (fprintf ((STREAM), \"\\t.long\\t\"),             \\\n+   output_addr_const ((STREAM), (EXP)),         \\\n+   fputc ('\\n', (STREAM)))\n+\n+#define ASM_OUTPUT_SHORT(STREAM, EXP)   \\\n+  (fprintf ((STREAM), \"\\t.short\\t\"),    \\\n+   output_addr_const ((STREAM), (EXP)), \\\n+   fputc ('\\n', (STREAM)))\n+\n+#define ASM_OUTPUT_CHAR(STREAM, EXP)            \\\n+  (fprintf ((STREAM), \"\\t.byte\\t\"),             \\\n+   output_addr_const ((STREAM), (EXP)),         \\\n+   fputc ('\\n', (STREAM)))\n+\n+#define ASM_OUTPUT_BYTE(STREAM, VALUE)          \\\n+  fprintf ((STREAM), \"\\t.byte\\t%d\\n\", (VALUE))  \n+\n+/* This says how to output an assembler line\n+   to define a global common symbol.  */\n+\n+#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)    \\\n+( fputs (\"\\t.comm \", (FILE)),                   \t\\\n+  assemble_name ((FILE), (NAME)),               \t\\\n+  fprintf ((FILE), \",%d\\n\", (SIZE)))\n+\n+/* This says how to output an assembler line\n+   to define a local common symbol.  */\n+\n+#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)     \\\n+( fputs (\"\\t.lcomm \", (FILE)),                          \\\n+  assemble_name ((FILE), (NAME)),                       \\\n+  fprintf ((FILE), \",%d\\n\", (SIZE)))\n+\n+/* The assembler's parentheses characters.  */\n+#define ASM_OPEN_PAREN \"(\"\n+#define ASM_CLOSE_PAREN \")\"\n+\n+/* We don't want the default switch handling.  */\n+#undef ASM_OUTPUT_BEFORE_CASE_LABEL\n+#undef ASM_OUTPUT_CASE_LABEL\n+\n+/* Target characters.  */\n+#define TARGET_BELL     007\n+#define TARGET_BS       010\n+#define TARGET_TAB      011\n+#define TARGET_NEWLINE  012\n+#define TARGET_VT       013\n+#define TARGET_FF       014\n+#define TARGET_CR       015\n+\f\n+/* Print operand X (an rtx) in assembler syntax to file FILE.\n+   CODE is a letter or star or 0 if no letter was specified.\n+   For `%' followed by punctuation, CODE is the punctuation and X is null.  */\n+\n+#define PRINT_OPERAND(STREAM, X, CODE)  pj_print_operand ((STREAM), (X), (CODE))\n+\n+/* Print a memory address as an operand to reference that memory location.  */\n+\n+#define PRINT_OPERAND_ADDRESS(STREAM,X)  output_addr_const (STREAM, X)\n+\n+/* Punctuation valid for print_operand.  */\n+\n+#define PRINT_OPERAND_PUNCT_VALID_P(CODE) ((CODE) == '*')\n+\f\n+\n+/* Define this macro if it is advisable to hold scalars in registers\n+   in a wider mode than that declared by the program.  In such cases, \n+   the value is constrained to be within the bounds of the declared\n+   type, but kept valid in the wider mode.  The signedness of the\n+   extension may differ from that of the type.\n+\n+   Since picoJava doesn't have unsigned compares, prefer signed\n+   arithmetic.  */\n+\n+#define PROMOTE_MODE(MODE, UNSIGNEDP, TYPE)             \\\n+ if (GET_MODE_CLASS (MODE) == MODE_INT                  \\\n+     && GET_MODE_SIZE (MODE) < UNITS_PER_WORD)          \\\n+     {                                                  \\\n+       (MODE) = SImode;                                 \\\n+       (UNSIGNEDP) = 0;                                 \\\n+      }\n+\n+/* Defining PROMOTE_FUNCTION_ARGS eliminates some unnecessary zero/sign\n+   extensions applied to char/short functions arguments.  Defining\n+   PROMOTE_FUNCTION_RETURN does the same for function returns.  */\n+#define PROMOTE_FUNCTION_ARGS\n+\n+/* For the sake of libgcc2.c, indicate target supports atexit.  */\n+#define HAVE_ATEXIT\n+\n+\f\n+/* We can debug without a frame pointer.  */\n+#define CAN_DEBUG_WITHOUT_FP \n+\n+/* How to renumber registers for dbx and gdb.  */\n+extern short pj_debugreg_renumber_vec[];\n+\n+#define DBX_REGISTER_NUMBER(REG) (pj_debugreg_renumber_vec[REG])\n+\n+#define DONT_USE_BUILTIN_SETJMP\n+\n+/* We prefer to use dwarf2. */\n+#undef  PREFERRED_DEBUGGING_TYPE \n+#define PREFERRED_DEBUGGING_TYPE DWARF2_DEBUG\n+#define DWARF2_UNWIND_INFO 1\n+#define DWARF_LINE_MIN_INSTR_LENGTH 1\n+\n+\f\n+/* varargs and stdarg builtins.  */\n+\n+#define EXPAND_BUILTIN_VA_START(stdarg, valist, nextarg)                      \\\n+do {                                                                          \\\n+   tree t = build (MODIFY_EXPR, TREE_TYPE (valist), valist,                   \\\n+                   make_tree (ptr_type_node, gen_rtx_REG (Pmode, VA_REG)));   \\\n+   TREE_SIDE_EFFECTS (t) = 1;                                                 \\\n+   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);                      \\\n+    } while (0)\n+\n+\n+#define EXPAND_BUILTIN_VA_ARG(valist, type)                             \\\n+   pj_expand_builtin_va_arg(valist, type)\n+\n+#define EXPAND_BUILTIN_NEXT_ARG(OFFSET)                                 \\\n+   gen_rtx_MEM (Pmode,                                                  \\\n+                plus_constant (gen_rtx_REG (SImode, VARS_REG),          \\\n+                               (INTVAL (offset) + 1) * -4));     \n+\n+/* Before the prologue, the return address is just above optop.  */\n+#define INCOMING_RETURN_ADDR_RTX  \\\n+  plus_constant (gen_rtx_REG (Pmode, OPTOP_REG), 4)\n+\n+/* Use thunks for vtables.  */\n+#define DEFAULT_VTABLE_THUNKS 1\n+\n+/* Rewrite the rtl to use take advantage of the opstack.  */\n+#define MACHINE_DEPENDENT_REORG(INSNS) pj_machine_dependent_reorg(INSNS)\n+\n+\n+/* Define the codes that are matched by predicates in pj.c.  */\n+#define PREDICATE_CODES \t\t\t\t\t\t \\\n+  {\"pj_dest_operand\",                 {SUBREG, REG, MEM,}},              \\\n+  {\"pj_signed_comparison_operator\",   {EQ, NE, LE, LT, GE, GT}},         \\\n+  {\"pj_unsigned_comparison_operator\", {LEU, LTU, GEU, GTU}},             \\\n+  {\"pj_source_operand\",               {CONST_INT, CONST_DOUBLE, CONST,   \\\n+                                       SYMBOL_REF, LABEL_REF, SUBREG,    \\\n+                                       REG, MEM}},\n+\n+/* Generate calls to memcpy, memcmp and memset.  */\n+#define TARGET_MEM_FUNCTIONS"}, {"sha": "f5a3054ab08865d786e807707274ecbeb2b2173c", "filename": "gcc/config/pj/pj.md", "status": "added", "additions": 991, "deletions": 0, "changes": 991, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b992148d7a6a6b0fffd946131dd7cd6e6cc3958/gcc%2Fconfig%2Fpj%2Fpj.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b992148d7a6a6b0fffd946131dd7cd6e6cc3958/gcc%2Fconfig%2Fpj%2Fpj.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpj%2Fpj.md?ref=1b992148d7a6a6b0fffd946131dd7cd6e6cc3958", "patch": "@@ -0,0 +1,991 @@\n+;; Machine description for GNU compiler, picoJava Version\n+;; Copyright (C) 2000 Free Software Foundation, Inc.\n+;; Contributed by Steve Chamberlain, of Transmeta (sac@pobox.com).\n+\n+;; This file is part of GNU CC.\n+\n+;; GNU CC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 1, or (at your option)\n+;; any later version.\n+\n+;; GNU CC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GNU CC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 59 Temple Place - Suite 330,\n+;; Boston, MA 02111-1307, USA.\n+\n+;; Move instructions.\n+\n+(define_insn \"movsi\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=gD\")\n+        (match_operand:SI 1 \"pj_source_operand\" \"gS\"))]\n+  \"\"\n+  \"%S1%R0\")\n+\n+(define_insn \"movhi\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=gD\")\n+        (match_operand:HI 1 \"pj_source_operand\" \"gS\"))]\n+  \"\"\n+  \"%S1%R0\")\n+\n+(define_insn \"movqi\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=gD\")\n+        (match_operand:QI 1 \"pj_source_operand\" \"gS\"))]\n+  \"\"\n+  \"%S1%R0\")\n+\n+(define_insn \"movdi\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=gD\")\n+        (match_operand:DI 1 \"pj_source_operand\" \"gS\"))]\n+  \"\"\n+  \"%D1%*%R0\")\n+\n+(define_insn \"movdf\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=gD\")\n+        (match_operand:DF 1 \"pj_source_operand\" \"gS\"))]\n+  \"\"\n+  \"%D1%R0\")\n+\n+(define_insn \"movsf\"\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=gD\")\n+        (match_operand:SF 1 \"pj_source_operand\" \"gS\"))]\n+  \"\"\n+  \"%S1%R0\")\n+\n+\f\n+;; Arithmetic.\n+\n+(define_insn \"addsi3\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=gD\")\n+        (plus:SI (match_operand:SI 1 \"pj_source_operand\" \"%gS\")\n+                 (match_operand:SI 2 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"* return pj_output_addsi3 (operands);\")\n+\n+(define_insn \"adddi3\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=gD\")\n+        (plus:DI (match_operand:DI 1 \"pj_source_operand\" \"%gS\")\n+                 (match_operand:DI 2 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"%D1%D2%*ladd%R0\")\n+\n+(define_insn \"addsf3\"\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=gD\")\n+        (plus:SF (match_operand:SF 1 \"pj_source_operand\" \"%gS\")\n+                 (match_operand:SF 2 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"%S1%S2%*fadd%R0\")\n+\n+(define_insn \"adddf3\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=gD\")\n+        (plus:DF (match_operand:DF 1 \"pj_source_operand\" \"%gS\")\n+                 (match_operand:DF 2 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"%D1%D2%*dadd%R0\")\n+\n+(define_insn \"negsi2\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=gD\")\n+        (neg:SI (match_operand:SI 1 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"%S1%*ineg%R0\")\n+\n+(define_insn \"negdi2\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=gD\")\n+        (neg:DI (match_operand:DI 1 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"%S1%*lneg%R0\")\n+\n+(define_insn \"negsf2\"\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=gD\")\n+        (neg:SF (match_operand:SF 1 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"%S1%*fneg%R0\")\n+\n+(define_insn \"negdf2\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=gD\")\n+        (neg:DF (match_operand:DF 1 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"%D1%*dneg%R0\")\n+\n+(define_insn \"subsi3\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=gD\")\n+        (minus:SI (match_operand:SI 1 \"pj_source_operand\" \"gS\")\n+                  (match_operand:SI 2 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"%S1%S2%*isub%R0\")\n+\n+(define_insn \"subdi3\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=gD\")\n+        (minus:DI (match_operand:DI 1 \"pj_source_operand\" \"gS\")\n+                  (match_operand:DI 2 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"%D1%D2%*lsub%R0\")\n+\n+(define_insn \"subsf3\"\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=gD\")\n+        (minus:SF (match_operand:SF 1 \"pj_source_operand\" \"gS\")\n+                 (match_operand:SF 2 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"%S1%S2%*fsub%R0\")\n+\n+(define_insn \"subdf3\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=gD\")\n+        (minus:DF (match_operand:DF 1 \"pj_source_operand\" \"gS\")\n+                 (match_operand:DF 2 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"%D1%D2%*dsub%R0\")\n+\n+(define_insn \"divsi3\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=gD\")\n+        (div:SI (match_operand:SI 1 \"pj_source_operand\" \"gS\")\n+                (match_operand:SI 2 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"%S1%S2%*idiv%R0\")\n+\n+(define_insn \"divdi3\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=gD\")\n+        (div:DI (match_operand:DI 1 \"pj_source_operand\" \"gS\")\n+                (match_operand:DI 2 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"%D1%D2%*ldiv%R0\")\n+\n+(define_insn \"divsf3\"\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=gD\")\n+        (div:SF (match_operand:SF 1 \"pj_source_operand\" \"gS\")\n+\t\t(match_operand:SF 2 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"%S1%S2%*fdiv%R0\")\n+\n+(define_insn \"divdf3\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=gD\")\n+        (div:DF (match_operand:DF 1 \"pj_source_operand\" \"gS\")\n+\t\t(match_operand:DF 2 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"%D1%D2%*ddiv%R0\")\n+\n+(define_insn \"udivsi3\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=gD\")\n+        (udiv:SI (match_operand:SI 1 \"pj_source_operand\" \"gS\")\n+                (match_operand:SI 2 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"%P1%P2%*ldiv%*l2i%R0\")\n+\n+(define_insn \"mulsi3\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=gD\")\n+        (mult:SI (match_operand:SI 1 \"pj_source_operand\" \"gS\")\n+                 (match_operand:SI 2 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"%S1%S2%*imul%R0\")\n+\n+(define_insn \"muldi3\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=gD\")\n+        (mult:DI (match_operand:DI 1 \"pj_source_operand\" \"gS\")\n+                 (match_operand:DI 2 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"%D1%D2%*lmul%R0\")\n+\n+(define_insn \"muldf3\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=gD\")\n+        (mult:DF (match_operand:DF 1 \"pj_source_operand\" \"%gS\")\n+\t\t(match_operand:DF 2 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"%D1%D2%*dmul%R0\")\n+\n+(define_insn \"mulsf3\"\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=gD\")\n+        (mult:SF (match_operand:SF 1 \"pj_source_operand\" \"%gS\")\n+\t\t(match_operand:SF 2 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"%S1%S2%*fmul%R0\")\n+\n+(define_insn \"modsi3\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=gD\")\n+        (mod:SI (match_operand:SI 1 \"pj_source_operand\" \"gS\")\n+                (match_operand:SI 2 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"%S1%S2%*irem%R0\")\n+\n+(define_insn \"moddi3\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=gD\")\n+        (mod:DI (match_operand:DI 1 \"pj_source_operand\" \"gS\")\n+                (match_operand:DI 2 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"%D1%D2%*lrem%R0\")\n+\n+(define_insn \"moddf3\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=gD\")\n+        (mod:DF (match_operand:DF 1 \"pj_source_operand\" \"gS\")\n+\t\t(match_operand:DF 2 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"%D1%D2%*drem%R0\")\n+\n+(define_insn \"modsf3\"\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=gD\")\n+        (mod:SF (match_operand:SF 1 \"pj_source_operand\" \"gS\")\n+\t\t(match_operand:SF 2 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"%S1%S2%*frem%R0\")\n+\n+(define_insn \"umodsi3\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=gD\")\n+        (umod:SI (match_operand:SI 1 \"pj_source_operand\" \"gS\")\n+                (match_operand:SI 2 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"%P1%P2%*lrem%*l2i%R0\")\n+\n+\f\n+;; Logical operations.\n+\n+(define_insn \"andsi3\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=gD\")\n+        (and:SI (match_operand:SI 1 \"pj_source_operand\" \"%gS\")\n+                (match_operand:SI 2 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"%S1%S2%*iand%R0\")\n+\n+(define_insn \"anddi3\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=gD\")\n+        (and:DI (match_operand:DI 1 \"pj_source_operand\" \"%gS\")\n+                (match_operand:DI 2 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"%D1%D2%*land%R0\")\n+\n+(define_insn \"iorsi3\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=gD\")\n+        (ior:SI (match_operand:SI 1 \"pj_source_operand\" \"%gS\")\n+                (match_operand:SI 2 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"%S1%S2%*ior%R0\")\n+\n+(define_insn \"iordi3\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=gD\")\n+        (ior:DI (match_operand:DI 1 \"pj_source_operand\" \"%gS\")\n+                (match_operand:DI 2 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"%D1%D2%*lor%R0\")\n+\n+(define_insn \"xorsi3\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=gD\")\n+        (xor:SI (match_operand:SI 1 \"pj_source_operand\" \"%gS\")\n+                (match_operand:SI 2 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"%S1%S2%*ixor%R0\")\n+\n+(define_insn \"xordi3\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=gD\")\n+        (xor:DI (match_operand:DI 1 \"pj_source_operand\" \"%gS\")\n+                (match_operand:DI 2 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"%D1%D2%*lxor%R0\")\n+\n+(define_insn \"one_cmplsi2\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=gD\")\n+        (not:SI (match_operand:SI 1 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"%S1%*iconst_m1%*ixor%R0\")\n+\n+(define_insn \"one_cmpldi2\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=gD\")\n+        (not:DI (match_operand:DI 1 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"%S1%*iconst_m1%*iconst_m1%*lxor%R0\")\n+\n+\f\n+;; Shift instructions.\n+\n+(define_insn \"ashlsi3\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=gD\")\n+        (ashift:SI (match_operand:SI 1 \"pj_source_operand\" \"gS\")\n+                   (match_operand:SI 2 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"%S1%S2%*ishl%R0\")\n+\n+\n+(define_insn \"ashldi3\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=gD\")\n+        (ashift:DI (match_operand:DI 1 \"pj_source_operand\" \"gS\")\n+                   (match_operand:SI 2 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"%D1%S2%*lshl%R0\")\n+\n+(define_insn \"ashrsi3\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=gD\")\n+        (ashiftrt:SI (match_operand:SI 1 \"pj_source_operand\" \"gS\")\n+                     (match_operand:SI 2 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"%S1%S2%*ishr%R0\")\n+\n+(define_insn \"ashrdi3\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=gD\")\n+        (ashiftrt:DI (match_operand:DI 1 \"pj_source_operand\" \"gS\")\n+                     (match_operand:SI 2 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"%D1%S2%*lshr%R0\")\n+\n+(define_insn \"lshrsi3\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=gD\")\n+        (lshiftrt:SI (match_operand:SI 1 \"pj_source_operand\" \"gS\")\n+                     (match_operand:SI 2 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"%S1%S2%*iushr%R0\")\n+\n+(define_insn \"lshrdi3\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=gD\")\n+        (lshiftrt:DI (match_operand:DI 1 \"pj_source_operand\" \"gS\")\n+                     (match_operand:SI 2 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"%D1%S2%*lushr%R0\")\n+\n+\f\n+;; Comparisons.\n+\n+(define_expand \"cmpsi\"\n+  [(set (cc0) (compare (match_operand:SI 0 \"pj_source_operand\" \"gS\")\n+                       (match_operand:SI 1 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"{ \n+     pj_cmp_op0 = operands[0];\n+     pj_cmp_op1 = operands[1];\n+     pj_cmp_mode = SImode;\n+     DONE;\n+   }\")\n+\n+(define_expand \"cmpdi\"\n+  [(set (cc0) (compare (match_operand:DI 0 \"pj_source_operand\" \"gS\")\n+                       (match_operand:DI 1 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"{ \n+     pj_cmp_op0 = operands[0];\n+     pj_cmp_op1 = operands[1];\n+     pj_cmp_mode = DImode; \n+     DONE;\n+   }\")\n+\n+(define_expand \"cmpsf\"\n+  [(set (cc0) (compare (match_operand:SF 0 \"pj_source_operand\" \"gS\")\n+                       (match_operand:SF 1 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"{ \n+     pj_cmp_op0 = operands[0];\n+     pj_cmp_op1 = operands[1];\n+     pj_cmp_mode = SFmode;\n+     DONE;\n+   }\")\n+\n+(define_expand \"cmpdf\"\n+  [(set (cc0) (compare (match_operand:DF 0 \"pj_source_operand\" \"gS\")\n+                       (match_operand:DF 1 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"{ \n+     pj_cmp_op0 = operands[0];\n+     pj_cmp_op1 = operands[1];\n+     pj_cmp_mode = DFmode;\n+     DONE;\n+   }\")\n+\n+\f\n+;; Conversions.\n+\n+(define_insn \"truncsiqi2\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=gD\")\n+        (truncate:QI (match_operand:SI 1 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"%S1%*%R0\")\n+\n+(define_insn \"truncsihi2\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=gD\")\n+        (truncate:HI (match_operand:SI 1 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"%S1%*i2c%R0\")\n+\n+(define_insn \"truncdisi2\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=gD\")\n+        (truncate:SI (match_operand:DI 1 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"%D1%*l2i%R0\")\n+\n+(define_insn \"fix_truncsfsi2\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=gD\")\n+\t(fix:SI (match_operand:SF 1 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"%S1%*f2i%R0\")\n+\n+(define_insn \"fix_truncsfdi2\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=gD\")\n+\t(fix:DI (match_operand:SF 1 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"%S1%*f2l%R0\")\n+\n+(define_insn \"truncdfsf2\"\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=gD\")\n+\t(float_truncate:SF (match_operand:DF  1 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"%D1%*d2f%R0\")\n+\n+(define_insn \"fix_truncdfsi2\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=gD\")\n+\t(fix:SI (match_operand:DF 1 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"%D1%*d2i%R0\")\n+\n+(define_insn \"fix_truncdfdi2\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=gD\")\n+\t(fix:DI (match_operand:DF 1 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"%D1%*d2l%R0\")\n+\n+(define_insn \"floatsisf2\"\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=gD\")\n+\t(float:SF (match_operand:SI 1 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"%S1%*i2f%R0\")\n+\n+(define_insn \"floatsidf2\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=gD\")\n+\t(float:DF (match_operand:SI 1 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"%S1%*i2d%R0\")\n+\n+(define_insn \"floatdisf2\"\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=gD\")\n+\t(float:SF (match_operand:DI 1 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"%D1%*l2f%R0\")\n+\n+(define_insn \"floatdidf2\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=gD\")\n+\t(float:DF (match_operand:DI 1 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"%D1%*l2d%R0\")\n+\n+\f\n+;; Zero-extend move instructions.\n+\n+(define_insn \"zero_extendsidi2\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=gD\")\n+        (zero_extend:DI (match_operand:SI 1 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"%P1%R0\")\n+\n+(define_insn \"zero_extendhisi2\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=gD\")\n+        (zero_extend:SI (match_operand:HI 1 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"%S1%*i2c%R0\")\n+\n+(define_insn \"zero_extendqisi2\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=gD\")\n+        (zero_extend:SI (match_operand:QI 1 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"%S1%*sipush 0xff%*iand%R0\")\n+\n+\f\n+;; Conditional branch instructions.\n+\n+(define_expand \"beq\"\n+  [(set (pc) (if_then_else (match_op_dup 3  [(match_dup 1) (match_dup 2)])\n+                           (label_ref (match_operand 0 \"\" \"\"))\n+                           (pc)))]\n+  \"\"\n+  \"operands[3] = gen_rtx (EQ, pj_cmp_mode);\n+   operands[1] = pj_cmp_op0;\n+   operands[2] = pj_cmp_op1;\")\n+\n+(define_expand \"bne\"\n+  [(set (pc) (if_then_else (match_op_dup 3  [(match_dup 1) (match_dup 2)])\n+                           (label_ref (match_operand 0 \"\" \"\"))\n+                           (pc)))]\n+  \"\"\n+  \"operands[3] = gen_rtx (NE, pj_cmp_mode);\n+   operands[1] = pj_cmp_op0;\n+   operands[2] = pj_cmp_op1;\")\n+\n+(define_expand \"bgt\"\n+  [(set (pc) (if_then_else (match_op_dup 3  [(match_dup 1) (match_dup 2)])\n+                           (label_ref (match_operand 0 \"\" \"\"))\n+                           (pc)))]\n+  \"\"\n+  \"operands[3] = gen_rtx (GT, pj_cmp_mode);\n+   operands[1] = pj_cmp_op0;\n+   operands[2] = pj_cmp_op1;\")\n+\n+(define_expand \"blt\"\n+  [(set (pc) (if_then_else (match_op_dup 3  [(match_dup 1) (match_dup 2)])\n+                           (label_ref (match_operand 0 \"\" \"\"))\n+                           (pc)))]\n+  \"\"\n+  \"operands[3] = gen_rtx (LT, pj_cmp_mode);\n+   operands[1] = pj_cmp_op0;\n+   operands[2] = pj_cmp_op1;\")\n+\n+(define_expand \"bge\"\n+  [(set (pc) (if_then_else (match_op_dup 3  [(match_dup 1) (match_dup 2)])\n+                           (label_ref (match_operand 0 \"\" \"\"))\n+                           (pc)))]\n+  \"\"\n+  \"operands[3] = gen_rtx (GE, pj_cmp_mode);\n+   operands[1] = pj_cmp_op0;\n+   operands[2] = pj_cmp_op1;\")\n+\n+(define_expand \"ble\"\n+  [(set (pc) (if_then_else (match_op_dup 3  [(match_dup 1) (match_dup 2)])\n+                           (label_ref (match_operand 0 \"\" \"\"))\n+                           (pc)))]\n+  \"\"\n+  \"operands[3] = gen_rtx (LE, pj_cmp_mode);\n+   operands[1] = pj_cmp_op0;\n+   operands[2] = pj_cmp_op1;\")\n+\n+(define_expand \"bgtu\"\n+  [(set (pc) (if_then_else (match_op_dup 3  [(match_dup 1) (match_dup 2)])\n+                           (label_ref (match_operand 0 \"\" \"\"))\n+                           (pc)))]\n+  \"\"\n+  \"operands[3] = gen_rtx (GTU, pj_cmp_mode);\n+   operands[1] = pj_cmp_op0;\n+   operands[2] = pj_cmp_op1;\")\n+\n+(define_expand \"bltu\"\n+  [(set (pc) (if_then_else (match_op_dup 3  [(match_dup 1) (match_dup 2)])\n+                           (label_ref (match_operand 0 \"\" \"\"))\n+                           (pc)))]\n+  \"\"\n+  \"operands[3] = gen_rtx (LTU, pj_cmp_mode);\n+   operands[1] = pj_cmp_op0;\n+   operands[2] = pj_cmp_op1;\")\n+\n+(define_expand \"bgeu\"\n+  [(set (pc) (if_then_else (match_op_dup 3  [(match_dup 1) (match_dup 2)])\n+                           (label_ref (match_operand 0 \"\" \"\"))\n+                           (pc)))]\n+  \"\"\n+  \"operands[3] = gen_rtx (GEU, pj_cmp_mode);\n+   operands[1] = pj_cmp_op0;\n+   operands[2] = pj_cmp_op1;\")\n+\n+(define_expand \"bleu\"\n+  [(set (pc) (if_then_else (match_op_dup 3  [(match_dup 1) (match_dup 2)])\n+                           (label_ref (match_operand 0 \"\" \"\"))\n+                           (pc)))]\n+  \"\"\n+  \"operands[3] = gen_rtx (LEU, pj_cmp_mode);\n+   operands[1] = pj_cmp_op0;\n+   operands[2] = pj_cmp_op1;\")\n+\n+(define_insn \"*bop\"\n+  [(set (pc) (if_then_else (match_operand:SI 0 \"pj_source_operand\" \"gS\")\n+\t\t\t   (label_ref (match_operand 1 \"\" \"\"))\n+\t\t\t   (pc)))]\n+  \"\"\n+  \"%S0%*ifne %1\")\n+\n+(define_insn \"*rev_bop\"\n+  [(set (pc) (if_then_else (match_operand:SI 0 \"pj_source_operand\" \"gS\")\n+\t\t\t   (pc)\n+\t\t\t   (label_ref (match_operand 1 \"\" \"\"))))]\n+\n+  \"\"\n+  \"%S0%*ifeq %1\")\n+\n+(define_insn \"*blopsi\"\n+  [(set (pc) \n+\t(if_then_else \n+\t (match_operator:SI 3 \"pj_signed_comparison_operator\" \n+\t\t\t    [(match_operand:SI 0 \"pj_source_operand\" \"gS,gS\")\n+\t\t\t     (match_operand:SI 1 \"pj_source_operand\" \"K,gS\")])\n+\t (label_ref (match_operand 2 \"\" \"\"))\n+\t (pc)))]\n+  \"\"\n+  \"@\n+\t%S0%*if%Y3 %2\n+\t%S0%S1%*if_icmp%Y3 %2\")\n+\n+(define_insn \"*rev_blopsi\"\n+  [(set (pc) \n+\t(if_then_else \n+\t (match_operator:SI 3 \"pj_signed_comparison_operator\" \n+\t\t\t    [(match_operand:SI 0 \"pj_source_operand\" \"gS,gS\")\n+\t\t\t     (match_operand:SI 1 \"pj_source_operand\" \"K,gS\")])\n+\t (pc)\n+\t (label_ref (match_operand 2 \"\" \"\"))))]\n+  \"\"\n+  \"@\n+\t%S0%*if%Z3 %2\n+\t%S0%S1%*if_icmp%Z3 %2\")\n+\n+(define_insn \"*bluopsi\"\n+  [(set (pc) \n+\t(if_then_else \n+\t (match_operator:SI 3 \"pj_unsigned_comparison_operator\" \n+\t\t\t    [(match_operand:SI 0 \"pj_source_operand\" \"gS\")\n+\t\t\t     (match_operand:SI 1 \"pj_source_operand\" \"gS\")])\n+\t (label_ref (match_operand 2 \"\" \"\"))\n+\t (pc)))]\n+  \"\"\n+  \"%S0%S1%*iucmp%*if%Y3 %2\")\n+\n+(define_insn \"*rev_bluopsi\"\n+  [(set (pc) \n+\t(if_then_else \n+\t (match_operator:SI 3 \"pj_unsigned_comparison_operator\" \n+\t\t\t    [(match_operand:SI 0 \"pj_source_operand\" \"gS\")\n+\t\t\t     (match_operand:SI 1 \"pj_source_operand\" \"gS\")])\n+\t (pc)\n+\t (label_ref (match_operand 2 \"\" \"\"))))]\n+  \"\"\n+  \"%S0%S1%*iucmp%*if%Z3 %2\")\n+\n+(define_insn \"*blopdi\"\n+  [(set (pc) \n+\t(if_then_else \n+\t (match_operator:DI 3 \"pj_signed_comparison_operator\" \n+\t\t\t    [(match_operand:DI 0 \"pj_source_operand\" \"gS\")\n+\t\t\t     (match_operand:DI 1 \"pj_source_operand\" \"gS\")])\n+\t (label_ref (match_operand 2 \"\" \"\"))\n+\t (pc)))]\n+  \"\"\n+  \"%D0%D1%*lcmp%*if%Y3 %2\")\n+\n+(define_insn \"*rev_blopdi\"\n+  [(set (pc)\n+\t(if_then_else \n+\t (match_operator:DI 3 \"pj_signed_comparison_operator\" \n+\t\t\t    [(match_operand:DI 0 \"pj_source_operand\" \"gS\")\n+\t\t\t     (match_operand:DI 1 \"pj_source_operand\" \"gS\")])\n+\t (pc)\n+\t (label_ref (match_operand 2 \"\" \"\"))))]\n+  \"\"\n+  \"%D0%D1%*lcmp%*if%Z3 %2\")\n+\n+(define_insn \"*bluopdi\"\n+  [(set (pc)\n+\t(if_then_else \n+\t (match_operator:DI 3 \"pj_unsigned_comparison_operator\" \n+\t\t\t    [(match_operand:DI 0 \"pj_source_operand\" \"gS\")\n+\t\t\t     (match_operand:DI 1 \"pj_source_operand\" \"gS\")])\n+\t (label_ref (match_operand 2 \"\" \"\"))\n+\t (pc)))]\n+  \"\"\n+  \"%D0%D1%*ipush __pjucmpdi2%*bipush 6%*call%*if%Y3 %2\")\n+\n+(define_insn \"*rev_bluopdi\"\n+  [(set (pc) \n+\t(if_then_else \n+\t (match_operator:DI 3 \"pj_unsigned_comparison_operator\" \n+\t\t\t    [(match_operand:DI 0 \"pj_source_operand\" \"gS\")\n+\t\t\t     (match_operand:DI 1 \"pj_source_operand\" \"gS\")])\n+\t (pc)\n+\t (label_ref (match_operand 2 \"\" \"\"))))]\n+  \"\"\n+  \"%D0%D1%*ipush __pjucmpdi2%*bipush 6%*call%*if%Z3 %2\")\n+\n+(define_insn \"*blopsf\"\n+  [(set (pc) \n+\t(if_then_else \n+\t (match_operator:SF 3 \"comparison_operator\" \n+\t\t\t    [(match_operand:SF 0 \"pj_source_operand\" \"gS\")\n+\t\t\t     (match_operand:SF 1 \"pj_source_operand\" \"gS\")])\n+\t (label_ref (match_operand 2 \"\" \"\"))\n+\t (pc)))]\n+  \"\"\n+  \"%S0%S1%*fcmp%X3%*if%Y3 %2\")\n+\n+(define_insn \"*rev_bluopsf\"\n+  [(set (pc) \n+\t(if_then_else \n+\t (match_operator:SF 3 \"comparison_operator\" \n+\t\t\t    [(match_operand:SF 0 \"pj_source_operand\" \"gS\")\n+\t\t\t     (match_operand:SF 1 \"pj_source_operand\" \"gS\")])\n+\t (pc)\n+\t (label_ref (match_operand 2 \"\" \"\"))))]\n+  \"\"\n+  \"%S0%S1%*fcmp%X3%*if%Z3 %2\")\n+\n+(define_insn \"*blopdf\"\n+  [(set (pc) \n+\t(if_then_else \n+\t (match_operator:DF 3 \"comparison_operator\" \n+\t\t\t    [(match_operand:DF 0 \"pj_source_operand\" \"gS\")\n+\t\t\t     (match_operand:DF 1 \"pj_source_operand\" \"gS\")])\n+\t (label_ref (match_operand 2 \"\" \"\"))\n+\t (pc)))]\n+  \"\"\n+  \"%D0%D1%*dcmp%X3%*if%Y3 %2\")\n+\n+(define_insn \"*rev_bluopdf\"\n+  [(set (pc) \n+\t(if_then_else \n+\t (match_operator:DF 3 \"comparison_operator\" \n+\t\t\t    [(match_operand:DF 0 \"pj_source_operand\" \"gS\")\n+\t\t\t     (match_operand:DF 1 \"pj_source_operand\" \"gS\")])\n+\t (pc)\n+\t (label_ref (match_operand 2 \"\" \"\"))))]\n+  \"\"\n+  \"%D0%D1%*dcmp%X3%*if%Z3 %2\")\n+\n+\f\n+;; call instructions\n+\n+(define_insn \"pj_call\"\n+  [(call (mem:QI (match_operand:SI 0 \"pj_source_operand\" \"gS\"))\n+\t         (match_operand:SI 1 \"immediate_operand\" \"i\"))]\n+  \"\"\n+  \"%C0%E1%S0%S1%*call\")\n+\n+(define_insn \"pj_call_value\"\n+  [(set (match_operand 0 \"nonimmediate_operand\" \"=gD\")\n+\t(call (mem:QI (match_operand:SI 1 \"pj_source_operand\" \"gS\"))\n+\t\t      (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n+\n+  \"\"\n+  \"%C1%E2%S1%S2%*call\")\n+\n+(define_expand \"call\"\n+  [(call (match_operand:SI 0 \"pj_source_operand\" \"gS\")\n+         (match_operand:SI 1 \"immediate_operand\" \"i\"))\n+   (use (match_operand:SI 2 \"register_operand\" \"r\"))\n+   (use (match_operand:SI 3 \"\" \"\"))]\n+  \"\"\n+  \"{\n+     emit_call_insn (gen_pj_call (XEXP (operands[0], 0),\n+\t\t                   pj_workout_arg_words (operands[1],\n+\t                                         operands[2])));\n+     DONE;\n+   }\")\n+\n+(define_expand \"call_value\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"gS\")\n+\t(call (match_operand:SI 1 \"pj_source_operand\" \"gS\")\n+         (match_operand:SI 2 \"immediate_operand\" \"i\")))\n+   (use (match_operand:SI 3 \"register_operand\" \"r\"))\n+   (use (match_operand:SI 4 \"\" \"\"))]\n+  \"\"\n+  \"{\n+     emit_call_insn (gen_pj_call_value (operands[0], \n+\t            \t                 XEXP (operands[1], 0),\n+\t                              \t pj_workout_arg_words (operands[2],\n+\t                                               operands[3])));\n+     DONE;\n+   }\")\n+\n+\f\n+;; No-op instruction.\n+\n+(define_insn \"nop\"\n+  [(const_int 0)]\n+  \"\"\n+  \"nop\")\n+\n+\f\n+;; Jump instructions\n+\n+(define_insn \"jump\"\n+  [(set (pc) (label_ref (match_operand 0 \"\" \"\")))]\n+  \"\"\n+  \"%*goto %l0\")\n+\n+(define_insn \"indirect_jump\"\n+  [(set (pc) (match_operand:SI 0 \"pj_source_operand\" \"gS\"))]\n+  \"\"\n+  \"%S0%*write_pc\")\n+\n+(define_insn \"casesi\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (leu (minus:SI (match_operand:SI 0 \"pj_source_operand\" \"gS\")\n+\t\t\t(match_operand:SI 1 \"immediate_operand\" \"i\"))\n+\t      (match_operand:SI 2 \"immediate_operand\" \"i\"))\n+\t (plus:SI (sign_extend:SI\n+\t\t   (mem:SI\n+\t\t    (plus:SI (pc)\n+\t\t\t     (mult:SI (minus:SI (match_dup 0)\n+\t\t\t\t\t\t(match_dup 1))\n+\t\t\t\t      (const_int 4)))))\n+\t\t  (label_ref (match_operand 3 \"\" \"\")))\n+\t (label_ref (match_operand 4 \"\" \"\"))))]\n+  \"\"\n+  \"%S0\\\\n%3i:%*tableswitch\\\\n\\\\t%*.align 2%*.long %4-%3i%*.long %1%*.long %1+%2\")\n+\f\n+;; Sign-extend move instructions.\n+\n+(define_insn \"extendsfdf2\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=gD\")\n+\t (float_extend:DF (match_operand:SF 1 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"%S1%*f2d%R0\")\n+\n+(define_insn \"extendhisi2\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=gD\")\n+        (sign_extend:SI (match_operand:HI 1 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"%S1%*bipush 16%*ishl%*bipush 16%*ishr%R0\")\n+\n+(define_insn \"extendqisi2\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=gD\")\n+        (sign_extend:SI (match_operand:QI 1 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"%S1%*bipush 24%*ishl%*bipush 24%*ishr%R0\")\n+\n+(define_insn \"extendqihi2\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=gD\")\n+        (sign_extend:HI (match_operand:QI 1 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"%S1%*bipush 24%*ishl%*bipush 24%*ishr%R0\")\n+\n+(define_insn \"extendsidi2\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=gD\")\n+        (sign_extend:DI (match_operand:SI 1 \"pj_source_operand\" \"gS\")))]\n+  \"\"\n+  \"%S1%*i2l%R0\")\n+\n+\f\n+;; non local control flow.\n+\n+(define_expand \"save_stack_nonlocal\"\n+  [(set (match_operand 0 \"nonimmediate_operand\" \"=gD\")\n+\t(match_operand 1 \"pj_source_operand\" \"gS\"))]\n+  \"\"\n+  \"{\n+     rtx reg = force_reg (Pmode, XEXP (operands[0], 0));\n+     rtx addr0 = gen_rtx_MEM (SImode,reg);\n+     rtx addr1 = gen_rtx_MEM (SImode, gen_rtx_PRE_INC (SImode, reg)); \n+     rtx addr2 = gen_rtx_MEM (SImode, gen_rtx_PRE_INC (SImode, reg));\n+\n+     emit_move_insn (addr0, gen_rtx_REG (SImode, 64));\n+     emit_move_insn (addr1, gen_rtx_REG (SImode, 72));\n+     emit_move_insn (addr2, gen_rtx_REG (SImode, 73));\n+\n+     DONE;\n+   }\")\n+\n+(define_insn \"restore_stack_nonlocal_helper\"\n+  [(set (reg:SI 64) (mem:SI (match_operand:SI 0 \"register_operand\" \"r\")))\n+   (set (reg:SI 72) (mem:SI (pre_inc:SI (match_dup 0))))\n+   (set (reg:SI 73) (mem:SI (pre_inc:SI (match_dup 0))))]\n+  \"\"\n+  \"%S0%*load_word%*write_global0%*iinc %J0,4%S0%*load_word%*iinc %J0,4%S0%*load_word%*write_vars%*write_optop\")\n+\n+(define_expand \"restore_stack_nonlocal\"\n+  [(set (match_operand 0 \"nonimmediate_operand\" \"=gD\")\n+\t(match_operand 1 \"pj_source_operand\" \"gS\"))]\n+  \"\"\n+  \"{\n+    rtx reg = force_reg (Pmode, XEXP (operands[1], 0));\n+    emit_insn (gen_restore_stack_nonlocal_helper (reg));\n+    DONE;\n+  }\")\n+\n+(define_insn \"nonlocal_goto_helper\"\n+  [(set (reg:SI 64) (mem:SI (match_operand:SI 0 \"register_operand\" \"r\")))\n+   (set (reg:SI 72) (mem:SI (pre_inc:SI (match_dup 0))))\n+   (set (reg:SI 73) (mem:SI (pre_inc:SI (match_dup 0))))\n+   (set (pc) (match_operand:SI 1 \"pj_source_operand\" \"gS\"))]\n+  \"\"\n+  \"%S0%*load_word%*write_global0%*iinc %J0,4%*%S0%*load_word%*%S1%*iinc %J0,4%*%S0%*load_word%*iinc %J0,4%*write_vars%*return0\")\n+\n+(define_expand \"nonlocal_goto\"\n+  [(match_operand:SI 0 \"pj_source_operand\" \"\")\n+   (match_operand:SI 1 \"pj_source_operand\" \"\")\n+   (match_operand:SI 2 \"pj_source_operand\" \"\")\n+   (match_operand:SI 3 \"\" \"\")]\n+  \"\"\n+  \"{ \n+     rtx addr;\n+     rtx temp;\n+     emit_move_insn (hard_frame_pointer_rtx, operands[0]);\n+\n+     temp = copy_to_reg (replace_rtx (operands[1], \n+\t                              virtual_stack_vars_rtx,\n+         \t\t  \t      hard_frame_pointer_rtx));\n+\t  \n+     addr = replace_rtx (copy_rtx (operands[2]),\n+  \t \t\t virtual_stack_vars_rtx,\n+ \t\t \t hard_frame_pointer_rtx);\n+\n+     emit_insn (gen_rtx_USE (VOIDmode, stack_pointer_rtx));\n+     emit_insn (gen_nonlocal_goto_helper (force_reg (Pmode, XEXP (addr, 0)),\n+\t\t                          temp));\n+     emit_barrier ();\n+     DONE;\n+    }\")\n+\f\n+;; Function overhead.\n+\n+(define_expand \"prologue\"\n+  [(const_int 0)]\n+  \"\"\n+  \"pj_expand_prologue (); DONE;\")\n+\n+(define_expand \"epilogue\"\n+  [(return)]\n+  \"\"\n+  \"pj_expand_epilogue();\")\n+\n+(define_insn \"return\"\n+  [(return)]\n+  \"reload_completed\"\n+  \"%*return0\")\n+\n+(define_insn \"tm_frame\"\n+  [(use  (match_operand:SI 0 \"pj_source_operand\" \"gS\"))\n+   (set (reg:SI 73) \n+\t(minus:SI (reg:SI 73) \n+\t\t  (mult:SI (match_operand:SI 1 \"pj_source_operand\" \"gS\")\n+\t\t\t   (const_int 4))))]\n+\n+  \"\"\n+  \"%S0%S1%*tm_frame\")\n+\n+(define_insn \"varargs\"\n+  [(unspec_volatile [(match_operand:SI 0 \"pj_source_operand\" \"gS\")] 10)]\n+  \"\"\n+  \"%S0%*jsr_w __vhelper\")\n+\n+(define_insn \"varargs_finish\"\n+  [(unspec_volatile [(match_operand:SI 0 \"pj_source_operand\" \"gS\")] 11)]\n+  \"\"\n+  \"%*iload %J0%*write_global0\")\n+\f\n+;; Extensions to picoJava.\n+\n+(define_insn \"strlensi\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n+\t(unspec:SI [(match_operand:BLK 1 \"memory_operand\" \"gS\")\n+\t\t    (match_operand:QI 2 \"pj_source_operand\" \"gS\")\n+\t\t    (match_operand:SI 3 \"immediate_operand\" \"gS\")] 0))\n+   (clobber (reg:SI 65))]\n+  \"TARGET_TM_EXTENSIONS\"\n+  \"%I1%S2%S3%*iconst_0%*write_global1%*tm_strlensi%R0\")\n+\n+(define_insn \"movstrsi\"\n+  [(set (match_operand:BLK 0 \"memory_operand\" \"=gS\")\n+\t(match_operand:BLK 1 \"memory_operand\" \"gS\"))\n+   (use (match_operand:SI 2 \"pj_source_operand\" \"gS\"))\n+   (use (match_operand:SI 3 \"pj_source_operand\" \"gS\"))\n+   (clobber (reg:SI 65))]\n+  \"TARGET_TM_EXTENSIONS\"\n+  \"%I0%I1%S2%S3%*iconst_0%*write_global1%*tm_movstrsi\")\n+\n+(define_insn \"clrstrsi\"\n+  [(set (match_operand:BLK 0 \"memory_operand\" \"=gS\")\n+\t(const_int 0))\n+   (use (match_operand:SI 1 \"pj_source_operand\" \"gS\"))\n+   (use (match_operand:SI 2 \"pj_source_operand\" \"gS\"))\n+   (clobber (reg:SI 65))]\n+  \"TARGET_TM_EXTENSIONS\"\n+  \"%I0%*iconst_0%S1%S2%*iconst_0%*write_global1%*tm_memsetsi\")\n+\n+(define_insn \"cmpstrsi\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=gD\")\n+\t(compare:SI (match_operand:BLK 1 \"memory_operand\" \"g\")\n+\t\t    (match_operand:BLK 2 \"memory_operand\" \"g\")))\n+   (use (match_operand:SI 3 \"pj_source_operand\" \"gS\"))\n+   (use (match_operand:SI 4 \"pj_source_operand\" \"gS\"))\n+   (clobber (reg:SI 65))]\n+  \"TARGET_TM_EXTENSIONS\"\n+  \"%I1%I2%S3%S4%*iconst_0%*write_global1%*tm_cmpstrsi%R0\")"}, {"sha": "dcfe8612e280963ece40ccc568793c1a00b196c5", "filename": "gcc/config/pj/pjl.h", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b992148d7a6a6b0fffd946131dd7cd6e6cc3958/gcc%2Fconfig%2Fpj%2Fpjl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b992148d7a6a6b0fffd946131dd7cd6e6cc3958/gcc%2Fconfig%2Fpj%2Fpjl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpj%2Fpjl.h?ref=1b992148d7a6a6b0fffd946131dd7cd6e6cc3958", "patch": "@@ -0,0 +1 @@\n+#define TARGET_LITTLE_ENDIAN_DEFAULT 1"}, {"sha": "2ba90874d5740af9b3c8b84f7f271164a9ddaaf8", "filename": "gcc/config/pj/t-pj", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b992148d7a6a6b0fffd946131dd7cd6e6cc3958/gcc%2Fconfig%2Fpj%2Ft-pj", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b992148d7a6a6b0fffd946131dd7cd6e6cc3958/gcc%2Fconfig%2Fpj%2Ft-pj", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpj%2Ft-pj?ref=1b992148d7a6a6b0fffd946131dd7cd6e6cc3958", "patch": "@@ -0,0 +1,9 @@\n+CROSS_LIBGCC1 = libgcc1-asm.a\n+LIB1ASMSRC = pj/lib1funcs.S\n+LIB1ASMFUNCS = vhelper pjucmpdi2\n+LIB2FUNCS_EXTRA =\n+\n+# For svr4 we build crtbegin.o and crtend.o which serve to add begin and\n+# end labels to the .ctors and .dtors section when we link using gcc.\n+\n+EXTRA_PARTS=crtbegin.o crtend.o"}, {"sha": "e635cce87c91298a5408ad94bf6411a8ff55bbaa", "filename": "gcc/config/pj/xm-pj.h", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b992148d7a6a6b0fffd946131dd7cd6e6cc3958/gcc%2Fconfig%2Fpj%2Fxm-pj.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b992148d7a6a6b0fffd946131dd7cd6e6cc3958/gcc%2Fconfig%2Fpj%2Fxm-pj.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpj%2Fxm-pj.h?ref=1b992148d7a6a6b0fffd946131dd7cd6e6cc3958", "patch": "@@ -0,0 +1,39 @@\n+/* Configuration for GNU C-compiler for picoJava.\n+   Copyright (C) 2000 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* #defines that need visibility everywhere.  */\n+#define FALSE 0\n+#define TRUE 1\n+\n+/* This describes the machine the compiler is hosted on.  */\n+#define HOST_BITS_PER_CHAR 8\n+#define HOST_BITS_PER_SHORT 16\n+#define HOST_BITS_PER_INT 32\n+#define HOST_BITS_PER_LONG 32\n+#define HOST_BITS_PER_LONGLONG 64\n+\n+/* Arguments to use with `exit'.  */\n+#define SUCCESS_EXIT_CODE 0\n+#define FATAL_EXIT_CODE 33\n+\n+/* target machine dependencies.\n+   tm.h is a symbolic link to the actual target specific file.   */\n+\n+#include \"tm.h\""}, {"sha": "1c1e1788bdf5bb62e1b7c38cf11cd82d7d9299a4", "filename": "gcc/configure", "status": "modified", "additions": 101, "deletions": 88, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b992148d7a6a6b0fffd946131dd7cd6e6cc3958/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b992148d7a6a6b0fffd946131dd7cd6e6cc3958/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=1b992148d7a6a6b0fffd946131dd7cd6e6cc3958", "patch": "@@ -3311,6 +3311,9 @@ for machine in $build $host $target; do\n \tmips*-*-*)\n \t\tcpu_type=mips\n \t\t;;\n+ \tpj*-*-*)\n+ \t\tcpu_type=pj\n+ \t\t;;\n \tpowerpc*-*-*)\n \t\tcpu_type=rs6000\n \t\t;;\n@@ -5587,6 +5590,16 @@ for machine in $build $host $target; do\n #\t\txmake_file=pyr/x-pyr\n #\t\tuse_collect2=yes\n #\t\t;;\n+\n+  \tpj*-linux*)\n+\t\ttm_file=\"svr4.h pj/linux.h ${tm_file}\"\n+ \t\t;;\n+  \tpj-*)\n+ \t\t;;\n+  \tpjl-*)\n+\t\ttm_file=\"svr4.h pj/pjl.h ${tm_file}\"\n+ \t\t;;\n+\n \tromp-*-aos*)\n \t\tuse_collect2=yes\n \t\t;;\n@@ -6672,15 +6685,15 @@ fi\n \n \n         echo $ac_n \"checking for strerror in -lcposix\"\"... $ac_c\" 1>&6\n-echo \"configure:6665: checking for strerror in -lcposix\" >&5\n+echo \"configure:6689: checking for strerror in -lcposix\" >&5\n ac_lib_var=`echo cposix'_'strerror | sed 'y%./+-%__p_%'`\n if eval \"test \\\"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   ac_save_LIBS=\"$LIBS\"\n LIBS=\"-lcposix  $LIBS\"\n cat > conftest.$ac_ext <<EOF\n-#line 6673 \"configure\"\n+#line 6697 \"configure\"\n #include \"confdefs.h\"\n /* Override any gcc2 internal prototype to avoid an error.  */\n /* We use char because int might match the return type of a gcc2\n@@ -6691,7 +6704,7 @@ int main() {\n strerror()\n ; return 0; }\n EOF\n-if { (eval echo configure:6684: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:6708: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_lib_$ac_lib_var=yes\"\n else\n@@ -6714,12 +6727,12 @@ fi\n   \n \n echo $ac_n \"checking for working const\"\"... $ac_c\" 1>&6\n-echo \"configure:6707: checking for working const\" >&5\n+echo \"configure:6731: checking for working const\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_c_const'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 6712 \"configure\"\n+#line 6736 \"configure\"\n #include \"confdefs.h\"\n \n int main() {\n@@ -6768,7 +6781,7 @@ ccp = (char const *const *) p;\n \n ; return 0; }\n EOF\n-if { (eval echo configure:6761: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:6785: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   ac_cv_c_const=yes\n else\n@@ -6789,21 +6802,21 @@ EOF\n fi\n \n echo $ac_n \"checking for inline\"\"... $ac_c\" 1>&6\n-echo \"configure:6782: checking for inline\" >&5\n+echo \"configure:6806: checking for inline\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_c_inline'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   ac_cv_c_inline=no\n for ac_kw in inline __inline__ __inline; do\n   cat > conftest.$ac_ext <<EOF\n-#line 6789 \"configure\"\n+#line 6813 \"configure\"\n #include \"confdefs.h\"\n \n int main() {\n } $ac_kw foo() {\n ; return 0; }\n EOF\n-if { (eval echo configure:6796: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:6820: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   ac_cv_c_inline=$ac_kw; break\n else\n@@ -6829,12 +6842,12 @@ EOF\n esac\n \n echo $ac_n \"checking for off_t\"\"... $ac_c\" 1>&6\n-echo \"configure:6822: checking for off_t\" >&5\n+echo \"configure:6846: checking for off_t\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_type_off_t'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 6827 \"configure\"\n+#line 6851 \"configure\"\n #include \"confdefs.h\"\n #include <sys/types.h>\n #if STDC_HEADERS\n@@ -6862,12 +6875,12 @@ EOF\n fi\n \n echo $ac_n \"checking for size_t\"\"... $ac_c\" 1>&6\n-echo \"configure:6855: checking for size_t\" >&5\n+echo \"configure:6879: checking for size_t\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_type_size_t'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 6860 \"configure\"\n+#line 6884 \"configure\"\n #include \"confdefs.h\"\n #include <sys/types.h>\n #if STDC_HEADERS\n@@ -6897,19 +6910,19 @@ fi\n # The Ultrix 4.2 mips builtin alloca declared by alloca.h only works\n # for constant arguments.  Useless!\n echo $ac_n \"checking for working alloca.h\"\"... $ac_c\" 1>&6\n-echo \"configure:6890: checking for working alloca.h\" >&5\n+echo \"configure:6914: checking for working alloca.h\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_header_alloca_h'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 6895 \"configure\"\n+#line 6919 \"configure\"\n #include \"confdefs.h\"\n #include <alloca.h>\n int main() {\n char *p = alloca(2 * sizeof(int));\n ; return 0; }\n EOF\n-if { (eval echo configure:6902: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:6926: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   ac_cv_header_alloca_h=yes\n else\n@@ -6930,12 +6943,12 @@ EOF\n fi\n \n echo $ac_n \"checking for alloca\"\"... $ac_c\" 1>&6\n-echo \"configure:6923: checking for alloca\" >&5\n+echo \"configure:6947: checking for alloca\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_alloca_works'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 6928 \"configure\"\n+#line 6952 \"configure\"\n #include \"confdefs.h\"\n \n #ifdef __GNUC__\n@@ -6963,7 +6976,7 @@ int main() {\n char *p = (char *) alloca(1);\n ; return 0; }\n EOF\n-if { (eval echo configure:6956: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:6980: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   ac_cv_func_alloca_works=yes\n else\n@@ -6995,12 +7008,12 @@ EOF\n \n \n echo $ac_n \"checking whether alloca needs Cray hooks\"\"... $ac_c\" 1>&6\n-echo \"configure:6988: checking whether alloca needs Cray hooks\" >&5\n+echo \"configure:7012: checking whether alloca needs Cray hooks\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_os_cray'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 6993 \"configure\"\n+#line 7017 \"configure\"\n #include \"confdefs.h\"\n #if defined(CRAY) && ! defined(CRAY2)\n webecray\n@@ -7025,12 +7038,12 @@ echo \"$ac_t\"\"$ac_cv_os_cray\" 1>&6\n if test $ac_cv_os_cray = yes; then\n for ac_func in _getb67 GETB67 getb67; do\n   echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:7018: checking for $ac_func\" >&5\n+echo \"configure:7042: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 7023 \"configure\"\n+#line 7047 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -7053,7 +7066,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:7046: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:7070: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -7080,15 +7093,15 @@ done\n fi\n \n echo $ac_n \"checking stack direction for C alloca\"\"... $ac_c\" 1>&6\n-echo \"configure:7073: checking stack direction for C alloca\" >&5\n+echo \"configure:7097: checking stack direction for C alloca\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_c_stack_direction'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   if test \"$cross_compiling\" = yes; then\n   ac_cv_c_stack_direction=0\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 7081 \"configure\"\n+#line 7105 \"configure\"\n #include \"confdefs.h\"\n find_stack_direction ()\n {\n@@ -7107,7 +7120,7 @@ main ()\n   exit (find_stack_direction() < 0);\n }\n EOF\n-if { (eval echo configure:7100: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n+if { (eval echo configure:7124: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n then\n   ac_cv_c_stack_direction=1\n else\n@@ -7134,17 +7147,17 @@ unistd.h sys/param.h\n do\n ac_safe=`echo \"$ac_hdr\" | sed 'y%./+-%__p_%'`\n echo $ac_n \"checking for $ac_hdr\"\"... $ac_c\" 1>&6\n-echo \"configure:7127: checking for $ac_hdr\" >&5\n+echo \"configure:7151: checking for $ac_hdr\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 7132 \"configure\"\n+#line 7156 \"configure\"\n #include \"confdefs.h\"\n #include <$ac_hdr>\n EOF\n ac_try=\"$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out\"\n-{ (eval echo configure:7137: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n+{ (eval echo configure:7161: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n ac_err=`grep -v '^ *+' conftest.out | grep -v \"^conftest.${ac_ext}\\$\"`\n if test -z \"$ac_err\"; then\n   rm -rf conftest*\n@@ -7174,12 +7187,12 @@ done\n strdup __argz_count __argz_stringify __argz_next\n do\n echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:7167: checking for $ac_func\" >&5\n+echo \"configure:7191: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 7172 \"configure\"\n+#line 7196 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -7202,7 +7215,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:7195: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:7219: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -7231,12 +7244,12 @@ done\n      for ac_func in stpcpy\n do\n echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:7224: checking for $ac_func\" >&5\n+echo \"configure:7248: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 7229 \"configure\"\n+#line 7253 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -7259,7 +7272,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:7252: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:7276: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -7293,19 +7306,19 @@ EOF\n \n    if test $ac_cv_header_locale_h = yes; then\n     echo $ac_n \"checking for LC_MESSAGES\"\"... $ac_c\" 1>&6\n-echo \"configure:7286: checking for LC_MESSAGES\" >&5\n+echo \"configure:7310: checking for LC_MESSAGES\" >&5\n if eval \"test \\\"`echo '$''{'am_cv_val_LC_MESSAGES'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 7291 \"configure\"\n+#line 7315 \"configure\"\n #include \"confdefs.h\"\n #include <locale.h>\n int main() {\n return LC_MESSAGES\n ; return 0; }\n EOF\n-if { (eval echo configure:7298: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:7322: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   am_cv_val_LC_MESSAGES=yes\n else\n@@ -7326,7 +7339,7 @@ EOF\n     fi\n   fi\n    echo $ac_n \"checking whether NLS is requested\"\"... $ac_c\" 1>&6\n-echo \"configure:7319: checking whether NLS is requested\" >&5\n+echo \"configure:7343: checking whether NLS is requested\" >&5\n         # Check whether --enable-nls or --disable-nls was given.\n if test \"${enable_nls+set}\" = set; then\n   enableval=\"$enable_nls\"\n@@ -7346,7 +7359,7 @@ fi\n EOF\n \n       echo $ac_n \"checking whether included gettext is requested\"\"... $ac_c\" 1>&6\n-echo \"configure:7339: checking whether included gettext is requested\" >&5\n+echo \"configure:7363: checking whether included gettext is requested\" >&5\n       # Check whether --with-included-gettext or --without-included-gettext was given.\n if test \"${with_included_gettext+set}\" = set; then\n   withval=\"$with_included_gettext\"\n@@ -7365,17 +7378,17 @@ fi\n \n \tac_safe=`echo \"libintl.h\" | sed 'y%./+-%__p_%'`\n echo $ac_n \"checking for libintl.h\"\"... $ac_c\" 1>&6\n-echo \"configure:7358: checking for libintl.h\" >&5\n+echo \"configure:7382: checking for libintl.h\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 7363 \"configure\"\n+#line 7387 \"configure\"\n #include \"confdefs.h\"\n #include <libintl.h>\n EOF\n ac_try=\"$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out\"\n-{ (eval echo configure:7368: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n+{ (eval echo configure:7392: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n ac_err=`grep -v '^ *+' conftest.out | grep -v \"^conftest.${ac_ext}\\$\"`\n if test -z \"$ac_err\"; then\n   rm -rf conftest*\n@@ -7392,19 +7405,19 @@ fi\n if eval \"test \\\"`echo '$ac_cv_header_'$ac_safe`\\\" = yes\"; then\n   echo \"$ac_t\"\"yes\" 1>&6\n   echo $ac_n \"checking for gettext in libc\"\"... $ac_c\" 1>&6\n-echo \"configure:7385: checking for gettext in libc\" >&5\n+echo \"configure:7409: checking for gettext in libc\" >&5\n if eval \"test \\\"`echo '$''{'gt_cv_func_gettext_libc'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 7390 \"configure\"\n+#line 7414 \"configure\"\n #include \"confdefs.h\"\n #include <libintl.h>\n int main() {\n return (int) gettext (\"\")\n ; return 0; }\n EOF\n-if { (eval echo configure:7397: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:7421: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   gt_cv_func_gettext_libc=yes\n else\n@@ -7420,15 +7433,15 @@ echo \"$ac_t\"\"$gt_cv_func_gettext_libc\" 1>&6\n \n \t   if test \"$gt_cv_func_gettext_libc\" != \"yes\"; then\n \t     echo $ac_n \"checking for bindtextdomain in -lintl\"\"... $ac_c\" 1>&6\n-echo \"configure:7413: checking for bindtextdomain in -lintl\" >&5\n+echo \"configure:7437: checking for bindtextdomain in -lintl\" >&5\n ac_lib_var=`echo intl'_'bindtextdomain | sed 'y%./+-%__p_%'`\n if eval \"test \\\"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   ac_save_LIBS=\"$LIBS\"\n LIBS=\"-lintl  $LIBS\"\n cat > conftest.$ac_ext <<EOF\n-#line 7421 \"configure\"\n+#line 7445 \"configure\"\n #include \"confdefs.h\"\n /* Override any gcc2 internal prototype to avoid an error.  */\n /* We use char because int might match the return type of a gcc2\n@@ -7439,7 +7452,7 @@ int main() {\n bindtextdomain()\n ; return 0; }\n EOF\n-if { (eval echo configure:7432: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:7456: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_lib_$ac_lib_var=yes\"\n else\n@@ -7455,20 +7468,20 @@ fi\n if eval \"test \\\"`echo '$ac_cv_lib_'$ac_lib_var`\\\" = yes\"; then\n   echo \"$ac_t\"\"yes\" 1>&6\n   echo $ac_n \"checking for gettext in libintl\"\"... $ac_c\" 1>&6\n-echo \"configure:7448: checking for gettext in libintl\" >&5\n+echo \"configure:7472: checking for gettext in libintl\" >&5\n if eval \"test \\\"`echo '$''{'gt_cv_func_gettext_libintl'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   echo $ac_n \"checking for gettext in -lintl\"\"... $ac_c\" 1>&6\n-echo \"configure:7453: checking for gettext in -lintl\" >&5\n+echo \"configure:7477: checking for gettext in -lintl\" >&5\n ac_lib_var=`echo intl'_'gettext | sed 'y%./+-%__p_%'`\n if eval \"test \\\"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   ac_save_LIBS=\"$LIBS\"\n LIBS=\"-lintl  $LIBS\"\n cat > conftest.$ac_ext <<EOF\n-#line 7461 \"configure\"\n+#line 7485 \"configure\"\n #include \"confdefs.h\"\n /* Override any gcc2 internal prototype to avoid an error.  */\n /* We use char because int might match the return type of a gcc2\n@@ -7479,7 +7492,7 @@ int main() {\n gettext()\n ; return 0; }\n EOF\n-if { (eval echo configure:7472: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:7496: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_lib_$ac_lib_var=yes\"\n else\n@@ -7518,7 +7531,7 @@ EOF\n \t      # Extract the first word of \"msgfmt\", so it can be a program name with args.\n set dummy msgfmt; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:7511: checking for $ac_word\" >&5\n+echo \"configure:7535: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_path_MSGFMT'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -7552,12 +7565,12 @@ fi\n \t\tfor ac_func in dcgettext\n do\n echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:7545: checking for $ac_func\" >&5\n+echo \"configure:7569: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 7550 \"configure\"\n+#line 7574 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -7580,7 +7593,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:7573: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:7597: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -7607,7 +7620,7 @@ done\n \t\t# Extract the first word of \"gmsgfmt\", so it can be a program name with args.\n set dummy gmsgfmt; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:7600: checking for $ac_word\" >&5\n+echo \"configure:7624: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_path_GMSGFMT'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -7643,7 +7656,7 @@ fi\n \t\t# Extract the first word of \"xgettext\", so it can be a program name with args.\n set dummy xgettext; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:7636: checking for $ac_word\" >&5\n+echo \"configure:7660: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_path_XGETTEXT'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -7675,15 +7688,15 @@ else\n fi\n \n \t\tcat > conftest.$ac_ext <<EOF\n-#line 7668 \"configure\"\n+#line 7692 \"configure\"\n #include \"confdefs.h\"\n \n int main() {\n extern int _nl_msg_cat_cntr;\n \t\t\t       return _nl_msg_cat_cntr\n ; return 0; }\n EOF\n-if { (eval echo configure:7676: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:7700: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   CATOBJEXT=.gmo\n \t\t   DATADIRNAME=share\n@@ -7706,7 +7719,7 @@ fi\n \n         if test \"$CATOBJEXT\" = \"NONE\"; then\n \t  echo $ac_n \"checking whether catgets can be used\"\"... $ac_c\" 1>&6\n-echo \"configure:7699: checking whether catgets can be used\" >&5\n+echo \"configure:7723: checking whether catgets can be used\" >&5\n \t  # Check whether --with-catgets or --without-catgets was given.\n if test \"${with_catgets+set}\" = set; then\n   withval=\"$with_catgets\"\n@@ -7719,22 +7732,22 @@ fi\n \n \t  if test \"$nls_cv_use_catgets\" = \"yes\"; then\n \t    \t    echo $ac_n \"checking for main in -li\"\"... $ac_c\" 1>&6\n-echo \"configure:7712: checking for main in -li\" >&5\n+echo \"configure:7736: checking for main in -li\" >&5\n ac_lib_var=`echo i'_'main | sed 'y%./+-%__p_%'`\n if eval \"test \\\"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   ac_save_LIBS=\"$LIBS\"\n LIBS=\"-li  $LIBS\"\n cat > conftest.$ac_ext <<EOF\n-#line 7720 \"configure\"\n+#line 7744 \"configure\"\n #include \"confdefs.h\"\n \n int main() {\n main()\n ; return 0; }\n EOF\n-if { (eval echo configure:7727: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:7751: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_lib_$ac_lib_var=yes\"\n else\n@@ -7762,12 +7775,12 @@ else\n fi\n \n \t    echo $ac_n \"checking for catgets\"\"... $ac_c\" 1>&6\n-echo \"configure:7755: checking for catgets\" >&5\n+echo \"configure:7779: checking for catgets\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_catgets'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 7760 \"configure\"\n+#line 7784 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char catgets(); below.  */\n@@ -7790,7 +7803,7 @@ catgets();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:7783: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:7807: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_catgets=yes\"\n else\n@@ -7812,7 +7825,7 @@ EOF\n \t       # Extract the first word of \"gencat\", so it can be a program name with args.\n set dummy gencat; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:7805: checking for $ac_word\" >&5\n+echo \"configure:7829: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_path_GENCAT'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -7848,7 +7861,7 @@ fi\n \t\t # Extract the first word of \"gmsgfmt\", so it can be a program name with args.\n set dummy gmsgfmt; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:7841: checking for $ac_word\" >&5\n+echo \"configure:7865: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_path_GMSGFMT'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -7885,7 +7898,7 @@ fi\n \t\t   # Extract the first word of \"msgfmt\", so it can be a program name with args.\n set dummy msgfmt; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:7878: checking for $ac_word\" >&5\n+echo \"configure:7902: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_path_GMSGFMT'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -7920,7 +7933,7 @@ fi\n \t\t # Extract the first word of \"xgettext\", so it can be a program name with args.\n set dummy xgettext; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:7913: checking for $ac_word\" >&5\n+echo \"configure:7937: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_path_XGETTEXT'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -7978,7 +7991,7 @@ fi\n         # Extract the first word of \"msgfmt\", so it can be a program name with args.\n set dummy msgfmt; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:7971: checking for $ac_word\" >&5\n+echo \"configure:7995: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_path_MSGFMT'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -8012,7 +8025,7 @@ fi\n         # Extract the first word of \"gmsgfmt\", so it can be a program name with args.\n set dummy gmsgfmt; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:8005: checking for $ac_word\" >&5\n+echo \"configure:8029: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_path_GMSGFMT'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -8048,7 +8061,7 @@ fi\n         # Extract the first word of \"xgettext\", so it can be a program name with args.\n set dummy xgettext; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:8041: checking for $ac_word\" >&5\n+echo \"configure:8065: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_path_XGETTEXT'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -8141,7 +8154,7 @@ fi\n        LINGUAS=\n      else\n        echo $ac_n \"checking for catalogs to be installed\"\"... $ac_c\" 1>&6\n-echo \"configure:8134: checking for catalogs to be installed\" >&5\n+echo \"configure:8158: checking for catalogs to be installed\" >&5\n        NEW_LINGUAS=\n        for lang in ${LINGUAS=$ALL_LINGUAS}; do\n          case \"$ALL_LINGUAS\" in\n@@ -8169,17 +8182,17 @@ echo \"configure:8134: checking for catalogs to be installed\" >&5\n    if test \"$CATOBJEXT\" = \".cat\"; then\n      ac_safe=`echo \"linux/version.h\" | sed 'y%./+-%__p_%'`\n echo $ac_n \"checking for linux/version.h\"\"... $ac_c\" 1>&6\n-echo \"configure:8162: checking for linux/version.h\" >&5\n+echo \"configure:8186: checking for linux/version.h\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 8167 \"configure\"\n+#line 8191 \"configure\"\n #include \"confdefs.h\"\n #include <linux/version.h>\n EOF\n ac_try=\"$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out\"\n-{ (eval echo configure:8172: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n+{ (eval echo configure:8196: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n ac_err=`grep -v '^ *+' conftest.out | grep -v \"^conftest.${ac_ext}\\$\"`\n if test -z \"$ac_err\"; then\n   rm -rf conftest*\n@@ -8254,7 +8267,7 @@ fi\n \n \n echo $ac_n \"checking whether windows registry support is requested\"\"... $ac_c\" 1>&6\n-echo \"configure:8247: checking whether windows registry support is requested\" >&5\n+echo \"configure:8271: checking whether windows registry support is requested\" >&5\n if test x$enable_win32_registry != xno; then\n   cat >> confdefs.h <<\\EOF\n #define ENABLE_WIN32_REGISTRY 1\n@@ -8283,7 +8296,7 @@ esac\n \n if test x$enable_win32_registry != xno; then\n   echo $ac_n \"checking registry key on windows hosts\"\"... $ac_c\" 1>&6\n-echo \"configure:8276: checking registry key on windows hosts\" >&5\n+echo \"configure:8300: checking registry key on windows hosts\" >&5\n   cat >> confdefs.h <<EOF\n #define WIN32_REGISTRY_KEY \"$gcc_cv_win32_registry_key\"\n EOF\n@@ -8459,7 +8472,7 @@ fi\n \n # Figure out what assembler alignment features are present.\n echo $ac_n \"checking assembler alignment features\"\"... $ac_c\" 1>&6\n-echo \"configure:8452: checking assembler alignment features\" >&5\n+echo \"configure:8476: checking assembler alignment features\" >&5\n gcc_cv_as=\n gcc_cv_as_alignment_features=\n gcc_cv_as_gas_srcdir=`echo $srcdir | sed -e 's,/gcc$,,'`/gas\n@@ -8580,7 +8593,7 @@ fi\n echo \"$ac_t\"\"$gcc_cv_as_alignment_features\" 1>&6\n \n echo $ac_n \"checking assembler subsection support\"\"... $ac_c\" 1>&6\n-echo \"configure:8573: checking assembler subsection support\" >&5\n+echo \"configure:8597: checking assembler subsection support\" >&5\n gcc_cv_as_subsections=\n if test x$gcc_cv_as != x; then\n \t# Check if we have .subsection\n@@ -8622,7 +8635,7 @@ echo \"$ac_t\"\"$gcc_cv_as_subsections\" 1>&6\n case \"$target\" in \n   sparc*-*-*)\n     echo $ac_n \"checking assembler .register pseudo-op support\"\"... $ac_c\" 1>&6\n-echo \"configure:8615: checking assembler .register pseudo-op support\" >&5\n+echo \"configure:8639: checking assembler .register pseudo-op support\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_register_pseudo_op'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -8652,7 +8665,7 @@ EOF\n     case \"$tm_file\" in\n     *64*)\n \techo $ac_n \"checking for 64 bit support in assembler ($gcc_cv_as)\"\"... $ac_c\" 1>&6\n-echo \"configure:8645: checking for 64 bit support in assembler ($gcc_cv_as)\" >&5\n+echo \"configure:8669: checking for 64 bit support in assembler ($gcc_cv_as)\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_flags64'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -8697,7 +8710,7 @@ EOF\n \n     if test \"x$gcc_cv_as_flags64\" != xno; then\n \techo $ac_n \"checking for assembler offsetable %lo() support\"\"... $ac_c\" 1>&6\n-echo \"configure:8690: checking for assembler offsetable %lo() support\" >&5\n+echo \"configure:8714: checking for assembler offsetable %lo() support\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_offsetable_lo10'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -8736,7 +8749,7 @@ EOF\n \n   i[34567]86-*-*)\n     echo $ac_n \"checking assembler instructions\"\"... $ac_c\" 1>&6\n-echo \"configure:8729: checking assembler instructions\" >&5\n+echo \"configure:8753: checking assembler instructions\" >&5\n     gcc_cv_as_instructions=\n     if test x$gcc_cv_as != x; then\n \tset \"filds fists\" \"filds mem; fists mem\""}, {"sha": "80ad395c05a90e885bfb5fa4b296ece64db226e9", "filename": "gcc/configure.in", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b992148d7a6a6b0fffd946131dd7cd6e6cc3958/gcc%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b992148d7a6a6b0fffd946131dd7cd6e6cc3958/gcc%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.in?ref=1b992148d7a6a6b0fffd946131dd7cd6e6cc3958", "patch": "@@ -513,6 +513,9 @@ changequote([,])dnl\n \tmips*-*-*)\n \t\tcpu_type=mips\n \t\t;;\n+ \tpj*-*-*)\n+ \t\tcpu_type=pj\n+ \t\t;;\n \tpowerpc*-*-*)\n \t\tcpu_type=rs6000\n \t\t;;\n@@ -2911,6 +2914,16 @@ changequote([,])dnl\n #\t\txmake_file=pyr/x-pyr\n #\t\tuse_collect2=yes\n #\t\t;;\n+\n+  \tpj*-linux*)\n+\t\ttm_file=\"svr4.h pj/linux.h ${tm_file}\"\n+ \t\t;;\n+  \tpj-*)\n+ \t\t;;\n+  \tpjl-*)\n+\t\ttm_file=\"svr4.h pj/pjl.h ${tm_file}\"\n+ \t\t;;\n+\n \tromp-*-aos*)\n \t\tuse_collect2=yes\n \t\t;;"}]}