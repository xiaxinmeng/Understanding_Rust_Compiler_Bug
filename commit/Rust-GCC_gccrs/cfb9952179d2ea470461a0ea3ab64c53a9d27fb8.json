{"sha": "cfb9952179d2ea470461a0ea3ab64c53a9d27fb8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2ZiOTk1MjE3OWQyZWE0NzA0NjFhMGVhM2FiNjRjNTNhOWQyN2ZiOA==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2011-11-17T17:11:16Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2011-11-17T17:11:16Z"}, "message": "re PR rtl-optimization/50663 (conditional propagation missed in cprop.c pass)\n\n\tPR rtl-optimization/50663\n\t* cprop.c (implicit_set_indexes): New global variable.\n\t(insert_set_in_table): Add additional parameter and record implicit\n\tset information.\n\t(hash_scan_set): Add additional parameter and pass it to above.\n\t(hash_scan_insn): Pass false to hash_scan_set.\n\t(compute_hash_table_work): Pass true to hash_scan_set.\n\t(compute_cprop_data): Add implicit set to AVIN of block which the\n\timplicit set is recorded for.\n\t(one_cprop_pass): Handle implicit_set_indexes array.\n\nFrom-SVN: r181446", "tree": {"sha": "eaf8b25a0580521f9e761b6dd9a6c6960735a596", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eaf8b25a0580521f9e761b6dd9a6c6960735a596"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cfb9952179d2ea470461a0ea3ab64c53a9d27fb8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfb9952179d2ea470461a0ea3ab64c53a9d27fb8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cfb9952179d2ea470461a0ea3ab64c53a9d27fb8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfb9952179d2ea470461a0ea3ab64c53a9d27fb8/comments", "author": null, "committer": null, "parents": [{"sha": "830dea94f2bfdf797d368aa71d7bccb4fc215431", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/830dea94f2bfdf797d368aa71d7bccb4fc215431", "html_url": "https://github.com/Rust-GCC/gccrs/commit/830dea94f2bfdf797d368aa71d7bccb4fc215431"}], "stats": {"total": 69, "additions": 61, "deletions": 8}, "files": [{"sha": "32da92ad2c0a2395534914aaad915fc4811275eb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfb9952179d2ea470461a0ea3ab64c53a9d27fb8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfb9952179d2ea470461a0ea3ab64c53a9d27fb8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cfb9952179d2ea470461a0ea3ab64c53a9d27fb8", "patch": "@@ -1,3 +1,16 @@\n+2011-11-17  Bin Cheng  <bin.cheng@arm.com>\n+\n+\tPR rtl-optimization/50663\n+\t* cprop.c (implicit_set_indexes): New global variable.\n+\t(insert_set_in_table): Add additional parameter and record implicit\n+\tset information.\n+\t(hash_scan_set): Add additional parameter and pass it to above.\n+\t(hash_scan_insn): Pass false to hash_scan_set.\n+\t(compute_hash_table_work): Pass true to hash_scan_set.\n+\t(compute_cprop_data): Add implicit set to AVIN of block which the\n+\timplicit set is recorded for.\n+\t(one_cprop_pass): Handle implicit_set_indexes array.\n+\n 2011-11-17  Michael Matz  <matz@suse.de>\n \n \tPR middle-end/50644"}, {"sha": "01f40f0bc724e0b4d899396a42b5d23d5965798b", "filename": "gcc/cprop.c", "status": "modified", "additions": 48, "deletions": 8, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfb9952179d2ea470461a0ea3ab64c53a9d27fb8/gcc%2Fcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfb9952179d2ea470461a0ea3ab64c53a9d27fb8/gcc%2Fcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcprop.c?ref=cfb9952179d2ea470461a0ea3ab64c53a9d27fb8", "patch": "@@ -116,6 +116,11 @@ static struct hash_table_d set_hash_table;\n /* Array of implicit set patterns indexed by basic block index.  */\n static rtx *implicit_sets;\n \n+/* Array of indexes of expressions for implicit set patterns indexed by basic\n+   block index.  In other words, implicit_set_indexes[i] is the bitmap_index\n+   of the expression whose RTX is implicit_sets[i].  */\n+static int *implicit_set_indexes;\n+\n /* Bitmap containing one bit for each register in the program.\n    Used when performing GCSE to track which registers have been set since\n    the start or end of the basic block while traversing that block.  */\n@@ -177,10 +182,12 @@ hash_set (int regno, int hash_table_size)\n /* Insert assignment DEST:=SET from INSN in the hash table.\n    DEST is a register and SET is a register or a suitable constant.\n    If the assignment is already present in the table, record it as\n-   the last occurrence in INSN's basic block.  */\n+   the last occurrence in INSN's basic block.\n+   IMPLICIT is true if it's an implicit set, false otherwise.  */\n \n static void\n-insert_set_in_table (rtx dest, rtx src, rtx insn, struct hash_table_d *table)\n+insert_set_in_table (rtx dest, rtx src, rtx insn, struct hash_table_d *table,\n+\t\t     bool implicit)\n {\n   bool found = false;\n   unsigned int hash;\n@@ -243,6 +250,10 @@ insert_set_in_table (rtx dest, rtx src, rtx insn, struct hash_table_d *table)\n       cur_occr->next = cur_expr->avail_occr;\n       cur_expr->avail_occr = cur_occr;\n     }\n+\n+  /* Record bitmap_index of the implicit set in implicit_set_indexes.  */\n+  if (implicit)\n+    implicit_set_indexes[BLOCK_FOR_INSN(insn)->index] = cur_expr->bitmap_index;\n }\n \n /* Determine whether the rtx X should be treated as a constant for CPROP.\n@@ -255,10 +266,11 @@ cprop_constant_p (const_rtx x)\n   return CONSTANT_P (x) && (GET_CODE (x) != CONST || shared_const_p (x));\n }\n \n-/* Scan SET present in INSN and add an entry to the hash TABLE.  */\n+/* Scan SET present in INSN and add an entry to the hash TABLE.\n+   IMPLICIT is true if it's an implicit set, false otherwise.  */\n \n static void\n-hash_scan_set (rtx set, rtx insn, struct hash_table_d *table)\n+hash_scan_set (rtx set, rtx insn, struct hash_table_d *table, bool implicit)\n {\n   rtx src = SET_SRC (set);\n   rtx dest = SET_DEST (set);\n@@ -294,7 +306,7 @@ hash_scan_set (rtx set, rtx insn, struct hash_table_d *table)\n \t   && ! HARD_REGISTER_P (src)\n \t   && reg_available_p (src, insn))\n \t  || cprop_constant_p (src))\n-\tinsert_set_in_table (dest, src, insn, table);\n+\tinsert_set_in_table (dest, src, insn, table, implicit);\n     }\n }\n \n@@ -310,14 +322,14 @@ hash_scan_insn (rtx insn, struct hash_table_d *table)\n      what's been modified.  */\n \n   if (GET_CODE (pat) == SET)\n-    hash_scan_set (pat, insn, table);\n+    hash_scan_set (pat, insn, table, false);\n   else if (GET_CODE (pat) == PARALLEL)\n     for (i = 0; i < XVECLEN (pat, 0); i++)\n       {\n \trtx x = XVECEXP (pat, 0, i);\n \n \tif (GET_CODE (x) == SET)\n-\t  hash_scan_set (x, insn, table);\n+\t  hash_scan_set (x, insn, table, false);\n       }\n }\n \n@@ -421,7 +433,7 @@ compute_hash_table_work (struct hash_table_d *table)\n       /* Insert implicit sets in the hash table, pretending they appear as\n \t insns at the head of the basic block.  */\n       if (implicit_sets[bb->index] != NULL_RTX)\n-\thash_scan_set (implicit_sets[bb->index], BB_HEAD (bb), table);\n+\thash_scan_set (implicit_sets[bb->index], BB_HEAD (bb), table, true);\n     }\n \n   FREE_REG_SET (reg_set_bitmap);\n@@ -633,8 +645,22 @@ compute_local_properties (sbitmap *kill, sbitmap *comp,\n static void\n compute_cprop_data (void)\n {\n+  basic_block bb;\n+\n   compute_local_properties (cprop_kill, cprop_avloc, &set_hash_table);\n   compute_available (cprop_avloc, cprop_kill, cprop_avout, cprop_avin);\n+\n+  /* Merge implicit sets into CPROP_AVIN.  They are always available at the\n+     entry of their basic block.  We need to do this because 1) implicit sets\n+     aren't recorded for the local pass so they cannot be propagated within\n+     their basic block by this pass and 2) the global pass would otherwise\n+     propagate them only in the successors of their basic block.  */\n+  FOR_EACH_BB (bb)\n+    {\n+      int index = implicit_set_indexes[bb->index];\n+      if (index != -1)\n+\tSET_BIT (cprop_avin[bb->index], index);\n+    }\n }\n \f\n /* Copy/constant propagation.  */\n@@ -1727,6 +1753,7 @@ is_too_expensive (const char *pass)\n static int\n one_cprop_pass (void)\n {\n+  int i;\n   int changed = 0;\n \n   /* Return if there's nothing to do, or it is too expensive.  */\n@@ -1774,6 +1801,11 @@ one_cprop_pass (void)\n   if (changed)\n     df_analyze ();\n \n+  /* Initialize implicit_set_indexes array.  */\n+  implicit_set_indexes = XNEWVEC (int, last_basic_block);\n+  for (i = 0; i < last_basic_block; i++)\n+    implicit_set_indexes[i] = -1;\n+\n   alloc_hash_table (&set_hash_table);\n   compute_hash_table (&set_hash_table);\n \n@@ -1791,6 +1823,9 @@ one_cprop_pass (void)\n       alloc_cprop_mem (last_basic_block, set_hash_table.n_elems);\n       compute_cprop_data ();\n \n+      free (implicit_set_indexes);\n+      implicit_set_indexes = NULL;\n+\n       /* Allocate vars to track sets of regs.  */\n       reg_set_bitmap = ALLOC_REG_SET (NULL);\n \n@@ -1820,6 +1855,11 @@ one_cprop_pass (void)\n       FREE_REG_SET (reg_set_bitmap);\n       free_cprop_mem ();\n     }\n+  else\n+    {\n+      free (implicit_set_indexes);\n+      implicit_set_indexes = NULL;\n+    }\n \n   free_hash_table (&set_hash_table);\n   obstack_free (&cprop_obstack, NULL);"}]}