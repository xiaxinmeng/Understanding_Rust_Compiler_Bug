{"sha": "e4876be5f5c5524ea742527100e36c5095181b28", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTQ4NzZiZTVmNWM1NTI0ZWE3NDI1MjcxMDBlMzZjNTA5NTE4MWIyOA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-01-10T05:15:52Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-01-10T05:15:52Z"}, "message": "runtime: noescape some functions/variables\n    \n    This is in preparation of turning on escape analysis for the\n    runtime.\n    \n    - In gccgo, systemstack is implemented with mcall, which is not\n      go:noescape. Wrap the closure in noescape so the escape analysis\n      does not think it escapes.\n    \n    - Mark some C functions go:noescape. They do not leak arguments.\n    \n    - Use noescape function to make a few local variables' addresses\n      not escape. The escape analysis cannot figure out because they\n      are assigned to pointer indirections.\n    \n    Reviewed-on: https://go-review.googlesource.com/86244\n\nFrom-SVN: r256418", "tree": {"sha": "c910fc6515e88a22e58ae52d5a5d7f80e0cfc982", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c910fc6515e88a22e58ae52d5a5d7f80e0cfc982"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e4876be5f5c5524ea742527100e36c5095181b28", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4876be5f5c5524ea742527100e36c5095181b28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4876be5f5c5524ea742527100e36c5095181b28", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4876be5f5c5524ea742527100e36c5095181b28/comments", "author": null, "committer": null, "parents": [{"sha": "fe9e1702687db062ad2f13939177e1c5f68c8e05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe9e1702687db062ad2f13939177e1c5f68c8e05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe9e1702687db062ad2f13939177e1c5f68c8e05"}], "stats": {"total": 40, "additions": 29, "deletions": 11}, "files": [{"sha": "4404ee2598aadb7f662e3467c3edd330936f2842", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4876be5f5c5524ea742527100e36c5095181b28/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4876be5f5c5524ea742527100e36c5095181b28/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=e4876be5f5c5524ea742527100e36c5095181b28", "patch": "@@ -1,4 +1,4 @@\n-8e20ba6b6c4906f2f0be4b0a1515d11e0f41fb29\n+5cae6a4e0849a3586ee7ce9c915c1520a17db982\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "b2deb6e65802b64c8a5d3828400e99efd90df098", "filename": "libgo/go/runtime/panic.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4876be5f5c5524ea742527100e36c5095181b28/libgo%2Fgo%2Fruntime%2Fpanic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4876be5f5c5524ea742527100e36c5095181b28/libgo%2Fgo%2Fruntime%2Fpanic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fpanic.go?ref=e4876be5f5c5524ea742527100e36c5095181b28", "patch": "@@ -201,7 +201,7 @@ func deferreturn(frame *bool) {\n \t\t\t// The gc compiler does this using assembler\n \t\t\t// code in jmpdefer.\n \t\t\tvar fn func(unsafe.Pointer)\n-\t\t\t*(*uintptr)(unsafe.Pointer(&fn)) = uintptr(unsafe.Pointer(&pfn))\n+\t\t\t*(*uintptr)(unsafe.Pointer(&fn)) = uintptr(noescape(unsafe.Pointer(&pfn)))\n \t\t\tfn(d.arg)\n \t\t}\n \n@@ -264,7 +264,7 @@ func checkdefer(frame *bool) {\n \t\tvar p _panic\n \t\tp.isforeign = true\n \t\tp.link = gp._panic\n-\t\tgp._panic = &p\n+\t\tgp._panic = (*_panic)(noescape(unsafe.Pointer(&p)))\n \t\tfor {\n \t\t\td := gp._defer\n \t\t\tif d == nil || d.frame != frame || d.pfn == 0 {\n@@ -275,7 +275,7 @@ func checkdefer(frame *bool) {\n \t\t\tgp._defer = d.link\n \n \t\t\tvar fn func(unsafe.Pointer)\n-\t\t\t*(*uintptr)(unsafe.Pointer(&fn)) = uintptr(unsafe.Pointer(&pfn))\n+\t\t\t*(*uintptr)(unsafe.Pointer(&fn)) = uintptr(noescape(unsafe.Pointer(&pfn)))\n \t\t\tfn(d.arg)\n \n \t\t\tfreedefer(d)\n@@ -368,7 +368,7 @@ func Goexit() {\n \t\td.pfn = 0\n \n \t\tvar fn func(unsafe.Pointer)\n-\t\t*(*uintptr)(unsafe.Pointer(&fn)) = uintptr(unsafe.Pointer(&pfn))\n+\t\t*(*uintptr)(unsafe.Pointer(&fn)) = uintptr(noescape(unsafe.Pointer(&pfn)))\n \t\tfn(d.arg)\n \n \t\tif gp._defer != d {\n@@ -491,7 +491,7 @@ func gopanic(e interface{}) {\n \t\td._panic = p\n \n \t\tvar fn func(unsafe.Pointer)\n-\t\t*(*uintptr)(unsafe.Pointer(&fn)) = uintptr(unsafe.Pointer(&pfn))\n+\t\t*(*uintptr)(unsafe.Pointer(&fn)) = uintptr(noescape(unsafe.Pointer(&pfn)))\n \t\tfn(d.arg)\n \n \t\tif gp._defer != d {"}, {"sha": "515efaa7516c116d9e5ed0ddfde7d21869849ba5", "filename": "libgo/go/runtime/proc.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4876be5f5c5524ea742527100e36c5095181b28/libgo%2Fgo%2Fruntime%2Fproc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4876be5f5c5524ea742527100e36c5095181b28/libgo%2Fgo%2Fruntime%2Fproc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fproc.go?ref=e4876be5f5c5524ea742527100e36c5095181b28", "patch": "@@ -46,7 +46,11 @@ import (\n \n // C functions for thread and context management.\n func newosproc(*m)\n+\n+//go:noescape\n func malg(bool, bool, *unsafe.Pointer, *uintptr) *g\n+\n+//go:noescape\n func resetNewG(*g, *unsafe.Pointer, *uintptr)\n func gogo(*g)\n func setGContext()"}, {"sha": "92143ea6fbb419c719b614f18d26eea46fd62d07", "filename": "libgo/go/runtime/signal_gccgo.go", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4876be5f5c5524ea742527100e36c5095181b28/libgo%2Fgo%2Fruntime%2Fsignal_gccgo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4876be5f5c5524ea742527100e36c5095181b28/libgo%2Fgo%2Fruntime%2Fsignal_gccgo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fsignal_gccgo.go?ref=e4876be5f5c5524ea742527100e36c5095181b28", "patch": "@@ -13,24 +13,31 @@ import (\n // Functions for gccgo to support signal handling. In the gc runtime\n // these are written in OS-specific files and in assembler.\n \n+//go:noescape\n //extern sigaction\n func sigaction(signum uint32, act *_sigaction, oact *_sigaction) int32\n \n+//go:noescape\n //extern sigprocmask\n func sigprocmask(how int32, set *sigset, oldset *sigset) int32\n \n+//go:noescape\n //extern sigfillset\n func sigfillset(set *sigset) int32\n \n+//go:noescape\n //extern sigemptyset\n func sigemptyset(set *sigset) int32\n \n+//go:noescape\n //extern sigaddset\n func c_sigaddset(set *sigset, signum uint32) int32\n \n+//go:noescape\n //extern sigdelset\n func c_sigdelset(set *sigset, signum uint32) int32\n \n+//go:noescape\n //extern sigaltstack\n func sigaltstack(ss *_stack_t, oss *_stack_t) int32\n \n@@ -43,6 +50,7 @@ func getpid() _pid_t\n //extern kill\n func kill(pid _pid_t, sig uint32) int32\n \n+//go:noescape\n //extern setitimer\n func setitimer(which int32, new *_itimerval, old *_itimerval) int32\n "}, {"sha": "fa3b1ce955224cb367f25723cfafb032f7f2f765", "filename": "libgo/go/runtime/stubs.go", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4876be5f5c5524ea742527100e36c5095181b28/libgo%2Fgo%2Fruntime%2Fstubs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4876be5f5c5524ea742527100e36c5095181b28/libgo%2Fgo%2Fruntime%2Fstubs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fstubs.go?ref=e4876be5f5c5524ea742527100e36c5095181b28", "patch": "@@ -60,10 +60,11 @@ func systemstack(fn func()) {\n \tif gp == mp.g0 || gp == mp.gsignal {\n \t\tfn()\n \t} else if gp == mp.curg {\n-\t\tmcall(func(origg *g) {\n+\t\tfn1 := func(origg *g) {\n \t\t\tfn()\n \t\t\tgogo(origg)\n-\t\t})\n+\t\t}\n+\t\tmcall(*(*func(*g))(noescape(unsafe.Pointer(&fn1))))\n \t} else {\n \t\tbadsystemstack()\n \t}\n@@ -160,6 +161,7 @@ func breakpoint()\n func asminit() {}\n \n //go:linkname reflectcall reflect.call\n+//go:noescape\n func reflectcall(fntype *functype, fn *funcval, isInterface, isMethod bool, params, results *unsafe.Pointer)\n \n func procyield(cycles uint32)\n@@ -355,7 +357,10 @@ func atomicstorep(ptr unsafe.Pointer, new unsafe.Pointer) {\n func getSigtramp() uintptr\n \n // The sa_handler field is generally hidden in a union, so use C accessors.\n+//go:noescape\n func getSigactionHandler(*_sigaction) uintptr\n+\n+//go:noescape\n func setSigactionHandler(*_sigaction, uintptr)\n \n // Retrieve fields from the siginfo_t and ucontext_t pointers passed"}, {"sha": "8551ec19ac30ea7dad3d927870bcde81f3276419", "filename": "libgo/go/runtime/traceback_gccgo.go", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4876be5f5c5524ea742527100e36c5095181b28/libgo%2Fgo%2Fruntime%2Ftraceback_gccgo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4876be5f5c5524ea742527100e36c5095181b28/libgo%2Fgo%2Fruntime%2Ftraceback_gccgo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Ftraceback_gccgo.go?ref=e4876be5f5c5524ea742527100e36c5095181b28", "patch": "@@ -9,7 +9,7 @@ package runtime\n \n import (\n \t\"runtime/internal/sys\"\n-\t_ \"unsafe\" // for go:linkname\n+\t\"unsafe\"\n )\n \n func printcreatedby(gp *g) {\n@@ -46,6 +46,7 @@ type location struct {\n \tlineno   int\n }\n \n+//go:noescape\n //extern runtime_callers\n func c_callers(skip int32, locbuf *location, max int32, keepThunks bool) int32\n \n@@ -185,7 +186,7 @@ func tracebackothers(me *g) {\n \tif gp != nil && gp != me {\n \t\tprint(\"\\n\")\n \t\tgoroutineheader(gp)\n-\t\tgp.traceback = &tb\n+\t\tgp.traceback = (*tracebackg)(noescape(unsafe.Pointer(&tb)))\n \t\tgetTraceback(me, gp)\n \t\tprinttrace(tb.locbuf[:tb.c], nil)\n \t\tprintcreatedby(gp)\n@@ -219,7 +220,7 @@ func tracebackothers(me *g) {\n \t\t\tprint(\"\\tgoroutine in C code; stack unavailable\\n\")\n \t\t\tprintcreatedby(gp)\n \t\t} else {\n-\t\t\tgp.traceback = &tb\n+\t\t\tgp.traceback = (*tracebackg)(noescape(unsafe.Pointer(&tb)))\n \t\t\tgetTraceback(me, gp)\n \t\t\tprinttrace(tb.locbuf[:tb.c], nil)\n \t\t\tprintcreatedby(gp)"}]}