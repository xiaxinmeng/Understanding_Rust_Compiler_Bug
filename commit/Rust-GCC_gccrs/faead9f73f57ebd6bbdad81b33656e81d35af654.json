{"sha": "faead9f73f57ebd6bbdad81b33656e81d35af654", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmFlYWQ5ZjczZjU3ZWJkNmJiZGFkODFiMzM2NTZlODFkMzVhZjY1NA==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2012-01-07T21:37:15Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2012-01-07T21:37:15Z"}, "message": "re PR bootstrap/51725 (segfault in stage 3 when compiling gcc/opts.c for sparc64-linux)\n\nPR bootstrap/51725\n* cselib.c (new_elt_loc_list): Promote addr_list to canonical node.\nAdd canonical node to containing_mem chain after the non-canonical\none, even if there weren't any locs to propagate.\n(remove_useless_values): Keep only canonical values.\n(add_mem_for_addr, cselib_lookup_mem): Canonicalize addr.\n(cselib_invalidate_mem): Likewise.  Ensure v is canonical, and\ncanonicalize mem_chain elements that are not discarded.\n\nFrom-SVN: r182982", "tree": {"sha": "ec96ad4cd466791636722eef9137d3e821672768", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ec96ad4cd466791636722eef9137d3e821672768"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/faead9f73f57ebd6bbdad81b33656e81d35af654", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/faead9f73f57ebd6bbdad81b33656e81d35af654", "html_url": "https://github.com/Rust-GCC/gccrs/commit/faead9f73f57ebd6bbdad81b33656e81d35af654", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/faead9f73f57ebd6bbdad81b33656e81d35af654/comments", "author": null, "committer": null, "parents": [{"sha": "e991086dd64c5b95b33229589171fce6882edd2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e991086dd64c5b95b33229589171fce6882edd2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e991086dd64c5b95b33229589171fce6882edd2e"}], "stats": {"total": 51, "additions": 43, "deletions": 8}, "files": [{"sha": "c3a9eaef68d6897bb86008f0f2eacbfa77f6269f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faead9f73f57ebd6bbdad81b33656e81d35af654/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faead9f73f57ebd6bbdad81b33656e81d35af654/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=faead9f73f57ebd6bbdad81b33656e81d35af654", "patch": "@@ -1,3 +1,14 @@\n+2012-01-07  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\tPR bootstrap/51725\n+\t* cselib.c (new_elt_loc_list): Promote addr_list to canonical node.\n+\tAdd canonical node to containing_mem chain after the non-canonical\n+\tone, even if there weren't any locs to propagate.\n+\t(remove_useless_values): Keep only canonical values.\n+\t(add_mem_for_addr, cselib_lookup_mem): Canonicalize addr.\n+\t(cselib_invalidate_mem): Likewise.  Ensure v is canonical, and\n+\tcanonicalize mem_chain elements that are not discarded.\n+\n 2012-01-06  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/47333"}, {"sha": "ab9c458fe8213fd375034a62850b8b43934e54ea", "filename": "gcc/cselib.c", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faead9f73f57ebd6bbdad81b33656e81d35af654/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faead9f73f57ebd6bbdad81b33656e81d35af654/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=faead9f73f57ebd6bbdad81b33656e81d35af654", "patch": "@@ -277,12 +277,27 @@ new_elt_loc_list (cselib_val *val, rtx loc)\n \t    }\n \t  el->next = val->locs;\n \t  next = val->locs = CSELIB_VAL_PTR (loc)->locs;\n-\t  if (CSELIB_VAL_PTR (loc)->next_containing_mem != NULL\n-\t      && val->next_containing_mem == NULL)\n-\t    {\n-\t      val->next_containing_mem = first_containing_mem;\n-\t      first_containing_mem = val;\n-\t    }\n+\t}\n+\n+      if (CSELIB_VAL_PTR (loc)->addr_list)\n+\t{\n+\t  /* Bring in addr_list into canonical node.  */\n+\t  struct elt_list *last = CSELIB_VAL_PTR (loc)->addr_list;\n+\t  while (last->next)\n+\t    last = last->next;\n+\t  last->next = val->addr_list;\n+\t  val->addr_list = CSELIB_VAL_PTR (loc)->addr_list;\n+\t  CSELIB_VAL_PTR (loc)->addr_list = NULL;\n+\t}\n+\n+      if (CSELIB_VAL_PTR (loc)->next_containing_mem != NULL\n+\t  && val->next_containing_mem == NULL)\n+\t{\n+\t  /* Add VAL to the containing_mem list after LOC.  LOC will\n+\t     be removed when we notice it doesn't contain any\n+\t     MEMs.  */\n+\t  val->next_containing_mem = CSELIB_VAL_PTR (loc)->next_containing_mem;\n+\t  CSELIB_VAL_PTR (loc)->next_containing_mem = val;\n \t}\n \n       /* Chain LOC back to VAL.  */\n@@ -641,7 +656,7 @@ remove_useless_values (void)\n \n   p = &first_containing_mem;\n   for (v = *p; v != &dummy_val; v = v->next_containing_mem)\n-    if (v->locs)\n+    if (v->locs && v == canonical_cselib_val (v))\n       {\n \t*p = v;\n \tp = &(*p)->next_containing_mem;\n@@ -1274,6 +1289,7 @@ add_mem_for_addr (cselib_val *addr_elt, cselib_val *mem_elt, rtx x)\n {\n   struct elt_loc_list *l;\n \n+  addr_elt = canonical_cselib_val (addr_elt);\n   mem_elt = canonical_cselib_val (mem_elt);\n \n   /* Avoid duplicates.  */\n@@ -1322,6 +1338,7 @@ cselib_lookup_mem (rtx x, int create)\n   if (! addr)\n     return 0;\n \n+  addr = canonical_cselib_val (addr);\n   /* Find a value that describes a value of our mode at that address.  */\n   for (l = addr->addr_list; l; l = l->next)\n     if (GET_MODE (l->elt->val_rtx) == mode)\n@@ -2218,15 +2235,22 @@ cselib_invalidate_mem (rtx mem_rtx)\n \t  /* We must have a mapping from this MEM's address to the\n \t     value (E).  Remove that, too.  */\n \t  addr = cselib_lookup (XEXP (x, 0), VOIDmode, 0, GET_MODE (x));\n+\t  addr = canonical_cselib_val (addr);\n+\t  gcc_checking_assert (v == canonical_cselib_val (v));\n \t  mem_chain = &addr->addr_list;\n \t  for (;;)\n \t    {\n-\t      if (canonical_cselib_val ((*mem_chain)->elt) == v)\n+\t      cselib_val *canon = canonical_cselib_val ((*mem_chain)->elt);\n+\n+\t      if (canon == v)\n \t\t{\n \t\t  unchain_one_elt_list (mem_chain);\n \t\t  break;\n \t\t}\n \n+\t      /* Record canonicalized elt.  */\n+\t      (*mem_chain)->elt = canon;\n+\n \t      mem_chain = &(*mem_chain)->next;\n \t    }\n "}]}