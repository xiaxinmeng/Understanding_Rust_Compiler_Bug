{"sha": "91b2d1199a36e4799d1a238a6ec52ecb36893661", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTFiMmQxMTk5YTM2ZTQ3OTlkMWEyMzhhNmVjNTJlY2IzNjg5MzY2MQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-01-07T13:06:43Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-01-07T13:06:43Z"}, "message": "rtlanal.c (set_of_1): New static function.\n\n\n\t* rtlanal.c (set_of_1): New static function.\n\t(reg_set_last_1, reg_set_p_1, reg_set_reg, reg_set_flag,\n\t reg_set_last_unknown, reg_set_last_value, reg_set_last_first_regno,\n\t reg_set_last_last_regno): Remove.\n\t(set_of): New global function.\n\t(set_of_data): New structure.\n\t(reg_set_p, reg_set_last): Revamp for set_of.\n\t* rtl.h (set_of): New.\n\nFrom-SVN: r38772", "tree": {"sha": "a6cc4c90e6c6bd79c136ac5f230c44bcb11cc27c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a6cc4c90e6c6bd79c136ac5f230c44bcb11cc27c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/91b2d1199a36e4799d1a238a6ec52ecb36893661", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91b2d1199a36e4799d1a238a6ec52ecb36893661", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91b2d1199a36e4799d1a238a6ec52ecb36893661", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91b2d1199a36e4799d1a238a6ec52ecb36893661/comments", "author": null, "committer": null, "parents": [{"sha": "796cdb659f4c0f015e92c41b3fcf3ff1ad7c3f88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/796cdb659f4c0f015e92c41b3fcf3ff1ad7c3f88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/796cdb659f4c0f015e92c41b3fcf3ff1ad7c3f88"}], "stats": {"total": 143, "additions": 59, "deletions": 84}, "files": [{"sha": "887605c45c781fa9b092c85675ccab279e36ee05", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91b2d1199a36e4799d1a238a6ec52ecb36893661/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91b2d1199a36e4799d1a238a6ec52ecb36893661/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=91b2d1199a36e4799d1a238a6ec52ecb36893661", "patch": "@@ -1,3 +1,14 @@\n+Sun Jan  7 13:49:19 MET 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* rtlanal.c (set_of_1): New static function.\n+\t(reg_set_last_1, reg_set_p_1, reg_set_reg, reg_set_flag,\n+\t reg_set_last_unknown, reg_set_last_value, reg_set_last_first_regno,\n+\t reg_set_last_last_regno): Remove.\n+\t(set_of): New global function.\n+\t(set_of_data): New structure.\n+\t(reg_set_p, reg_set_last): Revamp for set_of.\n+\t* rtl.h (set_of): New.\n+\n 2001-01-07  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* c-common.c (c_common_nodes_and_builtins): Add _Exit builtin."}, {"sha": "6e2aee68c07b532c43316f46b44825f8f145f03d", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91b2d1199a36e4799d1a238a6ec52ecb36893661/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91b2d1199a36e4799d1a238a6ec52ecb36893661/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=91b2d1199a36e4799d1a238a6ec52ecb36893661", "patch": "@@ -1378,6 +1378,7 @@ extern rtx find_last_value\t\tPARAMS ((rtx, rtx *, rtx, int));\n extern int refers_to_regno_p\t\tPARAMS ((unsigned int, unsigned int,\n \t\t\t\t\t\t rtx, rtx *));\n extern int reg_overlap_mentioned_p\tPARAMS ((rtx, rtx));\n+extern rtx set_of\t\t\tPARAMS ((rtx, rtx));\n extern void note_stores\t\t\tPARAMS ((rtx,\n \t\t\t\t\t\t void (*) (rtx, rtx, void *),\n \t\t\t\t\t\t void *));"}, {"sha": "d58f392cc0cbad209526b56705763b41f960c522", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 47, "deletions": 84, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91b2d1199a36e4799d1a238a6ec52ecb36893661/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91b2d1199a36e4799d1a238a6ec52ecb36893661/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=91b2d1199a36e4799d1a238a6ec52ecb36893661", "patch": "@@ -25,10 +25,8 @@ Boston, MA 02111-1307, USA.  */\n #include \"toplev.h\"\n #include \"rtl.h\"\n \n-static void reg_set_p_1\t\tPARAMS ((rtx, rtx, void *));\n+static void set_of_1\t\tPARAMS ((rtx, rtx, void *));\n static void insn_dependent_p_1\tPARAMS ((rtx, rtx, void *));\n-static void reg_set_last_1\tPARAMS ((rtx, rtx, void *));\n-\n \n /* Forward declarations */\n static int jmp_uses_reg_or_mem\t\tPARAMS ((rtx));\n@@ -617,24 +615,6 @@ reg_set_between_p (reg, from_insn, to_insn)\n }\n \n /* Internals of reg_set_between_p.  */\n-\n-static rtx reg_set_reg;\n-static int reg_set_flag;\n-\n-static void\n-reg_set_p_1 (x, pat, data)\n-     rtx x;\n-     rtx pat ATTRIBUTE_UNUSED;\n-     void *data ATTRIBUTE_UNUSED;\n-{\n-  /* We don't want to return 1 if X is a MEM that contains a register\n-     within REG_SET_REG.  */\n-\n-  if ((GET_CODE (x) != MEM)\n-      && reg_overlap_mentioned_p (reg_set_reg, x))\n-    reg_set_flag = 1;\n-}\n-\n int\n reg_set_p (reg, insn)\n      rtx reg, insn;\n@@ -662,10 +642,7 @@ reg_set_p (reg, insn)\n       body = PATTERN (insn);\n     }\n \n-  reg_set_reg = reg;\n-  reg_set_flag = 0;\n-  note_stores (body, reg_set_p_1, NULL);\n-  return reg_set_flag;\n+  return set_of (reg, insn) != NULL_RTX;\n }\n \n /* Similar to reg_set_between_p, but check all registers in X.  Return 0\n@@ -863,6 +840,38 @@ insn_dependent_p_1 (x, pat, data)\n     *pinsn = NULL_RTX;\n }\n \f\n+/* Helper function for set_of.  */\n+struct set_of_data\n+  {\n+    rtx found;\n+    rtx pat;\n+  };\n+\n+static void\n+set_of_1 (x, pat, data1)\n+     rtx x;\n+     rtx pat;\n+     void *data1;\n+{\n+   struct set_of_data *data = (struct set_of_data *) (data1);\n+   if (rtx_equal_p (x, data->pat)\n+       || (GET_CODE (x) != MEM && reg_overlap_mentioned_p (data->pat, x)))\n+     data->found = pat;\n+}\n+\n+/* Give an INSN, return a SET or CLOBBER expression that does modify PAT\n+   (eighter directly or via STRICT_LOW_PART and similar modifiers).  */\n+rtx\n+set_of (pat, insn)\n+     rtx pat, insn;\n+{\n+  struct set_of_data data;\n+  data.found = NULL_RTX;\n+  data.pat = pat;\n+  note_stores (INSN_P (insn) ? PATTERN (insn) : insn, set_of_1, &data);\n+  return data.found;\n+}\n+\f\n /* Given an INSN, return a SET expression if this insn has only a single SET.\n    It may also have CLOBBERs, USEs, or SET whose output\n    will not be used, which we ignore.  */\n@@ -1196,45 +1205,6 @@ reg_overlap_mentioned_p (x, in)\n   abort ();\n }\n \f\n-/* Used for communications between the next few functions.  */\n-\n-static int reg_set_last_unknown;\n-static rtx reg_set_last_value;\n-static unsigned int reg_set_last_first_regno, reg_set_last_last_regno;\n-\n-/* Called via note_stores from reg_set_last.  */\n-\n-static void\n-reg_set_last_1 (x, pat, data)\n-     rtx x;\n-     rtx pat;\n-     void *data ATTRIBUTE_UNUSED;\n-{\n-  unsigned int first, last;\n-\n-  /* If X is not a register, or is not one in the range we care\n-     about, ignore.  */\n-  if (GET_CODE (x) != REG)\n-    return;\n-\n-  first = REGNO (x);\n-  last = first + (first < FIRST_PSEUDO_REGISTER\n-\t\t  ? HARD_REGNO_NREGS (first, GET_MODE (x)) : 1);\n-\n-  if (first >= reg_set_last_last_regno\n-      || last <= reg_set_last_first_regno)\n-    return;\n-\n-  /* If this is a CLOBBER or is some complex LHS, or doesn't modify\n-     exactly the registers we care about, show we don't know the value.  */\n-  if (GET_CODE (pat) == CLOBBER || SET_DEST (pat) != x\n-      || first != reg_set_last_first_regno\n-      || last != reg_set_last_last_regno)\n-    reg_set_last_unknown = 1;\n-  else\n-    reg_set_last_value = SET_SRC (pat);\n-}\n-\n /* Return the last value to which REG was set prior to INSN.  If we can't\n    find it easily, return 0.\n \n@@ -1248,16 +1218,6 @@ reg_set_last (x, insn)\n {\n   rtx orig_insn = insn;\n \n-  reg_set_last_first_regno = REGNO (x);\n-\n-  reg_set_last_last_regno\n-    = reg_set_last_first_regno\n-      + (reg_set_last_first_regno < FIRST_PSEUDO_REGISTER\n-\t ? HARD_REGNO_NREGS (reg_set_last_first_regno, GET_MODE (x)) : 1);\n-\n-  reg_set_last_unknown = 0;\n-  reg_set_last_value = 0;\n-\n   /* Scan backwards until reg_set_last_1 changed one of the above flags.\n      Stop when we reach a label or X is a hard reg and we reach a\n      CALL_INSN (if reg_set_last_last_regno is a hard reg).\n@@ -1269,21 +1229,24 @@ reg_set_last (x, insn)\n   for (;\n        insn && GET_CODE (insn) != CODE_LABEL\n        && ! (GET_CODE (insn) == CALL_INSN\n-\t     && reg_set_last_last_regno <= FIRST_PSEUDO_REGISTER);\n+\t     && REGNO (x) <= FIRST_PSEUDO_REGISTER);\n        insn = PREV_INSN (insn))\n     if (INSN_P (insn))\n       {\n-\tnote_stores (PATTERN (insn), reg_set_last_1, NULL);\n-\tif (reg_set_last_unknown)\n-\t  return 0;\n-\telse if (reg_set_last_value)\n+\trtx set = set_of (x, insn);\n+\t/* OK, this function modify our register.  See if we understand it.  */\n+\tif (set)\n \t  {\n-\t    if (CONSTANT_P (reg_set_last_value)\n-\t\t|| ((GET_CODE (reg_set_last_value) == REG\n-\t\t     || GET_CODE (reg_set_last_value) == SUBREG)\n-\t\t    && ! reg_set_between_p (reg_set_last_value,\n+\t    rtx last_value;\n+\t    if (GET_CODE (set) != SET || SET_DEST (set) != x)\n+\t      return 0;\n+\t    last_value = SET_SRC (x);\n+\t    if (CONSTANT_P (last_value)\n+\t\t|| ((GET_CODE (last_value) == REG\n+\t\t     || GET_CODE (last_value) == SUBREG)\n+\t\t    && ! reg_set_between_p (last_value,\n \t\t\t\t\t    insn, orig_insn)))\n-\t      return reg_set_last_value;\n+\t      return last_value;\n \t    else\n \t      return 0;\n \t  }"}]}