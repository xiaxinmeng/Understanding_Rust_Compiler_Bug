{"sha": "7cb73573606d5b0881b0af778a81b5b9c1569f36", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2NiNzM1NzM2MDZkNWIwODgxYjBhZjc3OGE4MWI1YjljMTU2OWYzNg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2015-03-19T19:31:48Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2015-03-19T19:31:48Z"}, "message": "re PR c++/65046 (-Wabi-tag doesn't warn about variables or function return types)\n\n\tPR c++/65046\n\tAutomatically propagate ABI tags to variables and functions\n\tfrom their (return) type.\n\t* class.c (check_tag): Handle variables and functions.\n\t(mark_or_check_attr_tags): Split out from find_abi_tags_r.\n\t(mark_or_check_tags): Likewise.\n\t(mark_abi_tags): Use it.  Rename from mark_type_abi_tags.\n\t(check_abi_tags): Add single argument overload for decls.\n\tHandle inheriting tags for decls.\n\t* mangle.c (write_mangled_name): Call it.\n\t(mangle_return_type_p): Split out from write_encoding.\n\t(unmangled_name_p): Split out from write_mangled_name.\n\t(write_mangled_name): Ignore abi_tag on namespace.\n\t* cp-tree.h (NAMESPACE_IS_INLINE): Replace NAMESPACE_ABI_TAG.\n\t* parser.c (cp_parser_namespace_definition): Set it.\n\t* name-lookup.c (handle_namespace_attrs): Use arguments. Warn\n\tabout abi_tag attribute on non-inline namespace.\n\t* tree.c (check_abi_tag_args): Split out from handle_abi_tag_attribute.\n\t(handle_abi_tag_attribute): Allow tags on variables.\n\nFrom-SVN: r221521", "tree": {"sha": "1366bd2f145ea6b0f0e6fc74fb3092fea4a40db4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1366bd2f145ea6b0f0e6fc74fb3092fea4a40db4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7cb73573606d5b0881b0af778a81b5b9c1569f36", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cb73573606d5b0881b0af778a81b5b9c1569f36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7cb73573606d5b0881b0af778a81b5b9c1569f36", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cb73573606d5b0881b0af778a81b5b9c1569f36/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9b65e171edf31cd83fd075f6ed4f3943ebecc505", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b65e171edf31cd83fd075f6ed4f3943ebecc505", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b65e171edf31cd83fd075f6ed4f3943ebecc505"}], "stats": {"total": 490, "additions": 369, "deletions": 121}, "files": [{"sha": "f90e447cc988f26825fcbcaaf384f839c2a11901", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cb73573606d5b0881b0af778a81b5b9c1569f36/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cb73573606d5b0881b0af778a81b5b9c1569f36/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=7cb73573606d5b0881b0af778a81b5b9c1569f36", "patch": "@@ -1,3 +1,25 @@\n+2015-03-19  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/65046\n+\tAutomatically propagate ABI tags to variables and functions\n+\tfrom their (return) type.\n+\t* class.c (check_tag): Handle variables and functions.\n+\t(mark_or_check_attr_tags): Split out from find_abi_tags_r.\n+\t(mark_or_check_tags): Likewise.\n+\t(mark_abi_tags): Use it.  Rename from mark_type_abi_tags.\n+\t(check_abi_tags): Add single argument overload for decls.\n+\tHandle inheriting tags for decls.\n+\t* mangle.c (write_mangled_name): Call it.\n+\t(mangle_return_type_p): Split out from write_encoding.\n+\t(unmangled_name_p): Split out from write_mangled_name.\n+\t(write_mangled_name): Ignore abi_tag on namespace.\n+\t* cp-tree.h (NAMESPACE_IS_INLINE): Replace NAMESPACE_ABI_TAG.\n+\t* parser.c (cp_parser_namespace_definition): Set it.\n+\t* name-lookup.c (handle_namespace_attrs): Use arguments. Warn\n+\tabout abi_tag attribute on non-inline namespace.\n+\t* tree.c (check_abi_tag_args): Split out from handle_abi_tag_attribute.\n+\t(handle_abi_tag_attribute): Allow tags on variables.\n+\n 2015-03-19  Jakub Jelinek  <jakub@redhat.com>\n \n \t* decl2.c (cplus_decl_attributes): Also add \"omp declare target\""}, {"sha": "0518320d6b9953517fc72fe7f075fb3747dbf1ee", "filename": "gcc/cp/class.c", "status": "modified", "additions": 158, "deletions": 55, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cb73573606d5b0881b0af778a81b5b9c1569f36/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cb73573606d5b0881b0af778a81b5b9c1569f36/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=7cb73573606d5b0881b0af778a81b5b9c1569f36", "patch": "@@ -1382,44 +1382,53 @@ struct abi_tag_data\n    a tag NAMESPACE_DECL) or a STRING_CST (a tag attribute).  */\n \n static void\n-check_tag (tree tag, tree *tp, abi_tag_data *p)\n+check_tag (tree tag, tree id, tree *tp, abi_tag_data *p)\n {\n-  tree id;\n-\n-  if (TREE_CODE (tag) == STRING_CST)\n-    id = get_identifier (TREE_STRING_POINTER (tag));\n-  else\n-    {\n-      id = tag;\n-      tag = NULL_TREE;\n-    }\n-\n   if (!IDENTIFIER_MARKED (id))\n     {\n-      if (!tag)\n-\ttag = build_string (IDENTIFIER_LENGTH (id) + 1,\n-\t\t\t    IDENTIFIER_POINTER (id));\n       if (p->tags != error_mark_node)\n \t{\n-\t  /* We're collecting tags from template arguments.  */\n+\t  /* We're collecting tags from template arguments or from\n+\t     the type of a variable or function return type.  */\n \t  p->tags = tree_cons (NULL_TREE, tag, p->tags);\n-\t  ABI_TAG_IMPLICIT (p->tags) = true;\n \n \t  /* Don't inherit this tag multiple times.  */\n \t  IDENTIFIER_MARKED (id) = true;\n+\n+\t  if (TYPE_P (p->t))\n+\t    {\n+\t      /* Tags inherited from type template arguments are only used\n+\t\t to avoid warnings.  */\n+\t      ABI_TAG_IMPLICIT (p->tags) = true;\n+\t      return;\n+\t    }\n+\t  /* For functions and variables we want to warn, too.  */\n \t}\n \n       /* Otherwise we're diagnosing missing tags.  */\n+      if (TREE_CODE (p->t) == FUNCTION_DECL)\n+\t{\n+\t  if (warning (OPT_Wabi_tag, \"%qD inherits the %E ABI tag \"\n+\t\t       \"that %qT (used in its return type) has\",\n+\t\t       p->t, tag, *tp))\n+\t    inform (location_of (*tp), \"%qT declared here\", *tp);\n+\t}\n+      else if (TREE_CODE (p->t) == VAR_DECL)\n+\t{\n+\t  if (warning (OPT_Wabi_tag, \"%qD inherits the %E ABI tag \"\n+\t\t       \"that %qT (used in its type) has\", p->t, tag, *tp))\n+\t    inform (location_of (*tp), \"%qT declared here\", *tp);\n+\t}\n       else if (TYPE_P (p->subob))\n \t{\n-\t  if (warning (OPT_Wabi_tag, \"%qT does not have the %E abi tag \"\n+\t  if (warning (OPT_Wabi_tag, \"%qT does not have the %E ABI tag \"\n \t\t       \"that base %qT has\", p->t, tag, p->subob))\n \t    inform (location_of (p->subob), \"%qT declared here\",\n \t\t    p->subob);\n \t}\n       else\n \t{\n-\t  if (warning (OPT_Wabi_tag, \"%qT does not have the %E abi tag \"\n+\t  if (warning (OPT_Wabi_tag, \"%qT does not have the %E ABI tag \"\n \t\t       \"that %qT (used in the type of %qD) has\",\n \t\t       p->t, tag, *tp, p->subob))\n \t    {\n@@ -1431,8 +1440,53 @@ check_tag (tree tag, tree *tp, abi_tag_data *p)\n     }\n }\n \n+/* Find all the ABI tags in the attribute list ATTR and either call\n+   check_tag (if TP is non-null) or set IDENTIFIER_MARKED to val.  */\n+\n+static void\n+mark_or_check_attr_tags (tree attr, tree *tp, abi_tag_data *p, bool val)\n+{\n+  if (!attr)\n+    return;\n+  for (; (attr = lookup_attribute (\"abi_tag\", attr));\n+       attr = TREE_CHAIN (attr))\n+    for (tree list = TREE_VALUE (attr); list;\n+\t list = TREE_CHAIN (list))\n+      {\n+\ttree tag = TREE_VALUE (list);\n+\ttree id = get_identifier (TREE_STRING_POINTER (tag));\n+\tif (tp)\n+\t  check_tag (tag, id, tp, p);\n+\telse\n+\t  IDENTIFIER_MARKED (id) = val;\n+      }\n+}\n+\n+/* Find all the ABI tags on T and its enclosing scopes and either call\n+   check_tag (if TP is non-null) or set IDENTIFIER_MARKED to val.  */\n+\n+static void\n+mark_or_check_tags (tree t, tree *tp, abi_tag_data *p, bool val)\n+{\n+  while (t != global_namespace)\n+    {\n+      tree attr;\n+      if (TYPE_P (t))\n+\t{\n+\t  attr = TYPE_ATTRIBUTES (t);\n+\t  t = CP_TYPE_CONTEXT (t);\n+\t}\n+      else\n+\t{\n+\t  attr = DECL_ATTRIBUTES (t);\n+\t  t = CP_DECL_CONTEXT (t);\n+\t}\n+      mark_or_check_attr_tags (attr, tp, p, val);\n+    }\n+}\n+\n /* walk_tree callback for check_abi_tags: if the type at *TP involves any\n-   types with abi tags, add the corresponding identifiers to the VEC in\n+   types with ABI tags, add the corresponding identifiers to the VEC in\n    *DATA and set IDENTIFIER_MARKED.  */\n \n static tree\n@@ -1447,63 +1501,112 @@ find_abi_tags_r (tree *tp, int *walk_subtrees, void *data)\n \n   abi_tag_data *p = static_cast<struct abi_tag_data*>(data);\n \n-  for (tree ns = decl_namespace_context (*tp);\n-       ns != global_namespace;\n-       ns = CP_DECL_CONTEXT (ns))\n-    if (NAMESPACE_ABI_TAG (ns))\n-      check_tag (DECL_NAME (ns), tp, p);\n+  mark_or_check_tags (*tp, tp, p, false);\n \n-  if (tree attributes = lookup_attribute (\"abi_tag\", TYPE_ATTRIBUTES (*tp)))\n-    {\n-      for (tree list = TREE_VALUE (attributes); list;\n-\t   list = TREE_CHAIN (list))\n-\t{\n-\t  tree tag = TREE_VALUE (list);\n-\t  check_tag (tag, tp, p);\n-\t}\n-    }\n   return NULL_TREE;\n }\n \n-/* Set IDENTIFIER_MARKED on all the ABI tags on T and its (transitively\n-   complete) template arguments.  */\n+/* walk_tree callback for mark_abi_tags: if *TP is a class, set\n+   IDENTIFIER_MARKED on its ABI tags.  */\n \n-static void\n-mark_type_abi_tags (tree t, bool val)\n+static tree\n+mark_abi_tags_r (tree *tp, int *walk_subtrees, void *data)\n {\n-  for (tree ns = decl_namespace_context (t);\n-       ns != global_namespace;\n-       ns = CP_DECL_CONTEXT (ns))\n-    if (NAMESPACE_ABI_TAG (ns))\n-      IDENTIFIER_MARKED (DECL_NAME (ns)) = val;\n+  if (!OVERLOAD_TYPE_P (*tp))\n+    return NULL_TREE;\n+\n+  /* walk_tree shouldn't be walking into any subtrees of a RECORD_TYPE\n+     anyway, but let's make sure of it.  */\n+  *walk_subtrees = false;\n+\n+  bool *valp = static_cast<bool*>(data);\n \n-  tree attributes = lookup_attribute (\"abi_tag\", TYPE_ATTRIBUTES (t));\n-  if (attributes)\n+  mark_or_check_tags (*tp, NULL, NULL, *valp);\n+\n+  return NULL_TREE;\n+}\n+\n+/* Set IDENTIFIER_MARKED on all the ABI tags on T and its enclosing\n+   scopes.  */\n+\n+static void\n+mark_abi_tags (tree t, bool val)\n+{\n+  mark_or_check_tags (t, NULL, NULL, val);\n+  if (DECL_P (t))\n     {\n-      for (tree list = TREE_VALUE (attributes); list;\n-\t   list = TREE_CHAIN (list))\n+      if (DECL_LANG_SPECIFIC (t) && DECL_USE_TEMPLATE (t)\n+\t  && PRIMARY_TEMPLATE_P (DECL_TI_TEMPLATE (t)))\n \t{\n-\t  tree tag = TREE_VALUE (list);\n-\t  tree id = get_identifier (TREE_STRING_POINTER (tag));\n-\t  IDENTIFIER_MARKED (id) = val;\n+\t  /* Template arguments are part of the signature.  */\n+\t  tree level = INNERMOST_TEMPLATE_ARGS (DECL_TI_ARGS (t));\n+\t  for (int j = 0; j < TREE_VEC_LENGTH (level); ++j)\n+\t    {\n+\t      tree arg = TREE_VEC_ELT (level, j);\n+\t      cp_walk_tree_without_duplicates (&arg, mark_abi_tags_r, &val);\n+\t    }\n \t}\n+      if (TREE_CODE (t) == FUNCTION_DECL)\n+\t/* A function's parameter types are part of the signature, so\n+\t   we don't need to inherit any tags that are also in them.  */\n+\tfor (tree arg = FUNCTION_FIRST_USER_PARMTYPE (t); arg;\n+\t     arg = TREE_CHAIN (arg))\n+\t  cp_walk_tree_without_duplicates (&TREE_VALUE (arg),\n+\t\t\t\t\t   mark_abi_tags_r, &val);\n     }\n }\n \n-/* Check that class T has all the abi tags that subobject SUBOB has, or\n-   warn if not.  */\n+/* Check that T has all the ABI tags that subobject SUBOB has, or\n+   warn if not.  If T is a (variable or function) declaration, also\n+   add any missing tags.  */\n \n static void\n check_abi_tags (tree t, tree subob)\n {\n-  mark_type_abi_tags (t, true);\n+  bool inherit = DECL_P (t);\n+\n+  if (!inherit && !warn_abi_tag)\n+    return;\n+\n+  tree decl = TYPE_P (t) ? TYPE_NAME (t) : t;\n+  if (!TREE_PUBLIC (decl))\n+    /* No need to worry about things local to this TU.  */\n+    return;\n+\n+  mark_abi_tags (t, true);\n \n   tree subtype = TYPE_P (subob) ? subob : TREE_TYPE (subob);\n   struct abi_tag_data data = { t, subob, error_mark_node };\n+  if (inherit)\n+    data.tags = NULL_TREE;\n \n   cp_walk_tree_without_duplicates (&subtype, find_abi_tags_r, &data);\n \n-  mark_type_abi_tags (t, false);\n+  if (inherit && data.tags)\n+    {\n+      tree attr = lookup_attribute (\"abi_tag\", DECL_ATTRIBUTES (t));\n+      if (attr)\n+\tTREE_VALUE (attr) = chainon (data.tags, TREE_VALUE (attr));\n+      else\n+\tDECL_ATTRIBUTES (t)\n+\t  = tree_cons (get_identifier (\"abi_tag\"), data.tags,\n+\t\t       DECL_ATTRIBUTES (t));\n+    }\n+\n+  mark_abi_tags (t, false);\n+}\n+\n+/* Check that DECL has all the ABI tags that are used in parts of its type\n+   that are not reflected in its mangled name.  */\n+\n+void\n+check_abi_tags (tree decl)\n+{\n+  if (TREE_CODE (decl) == VAR_DECL)\n+    check_abi_tags (decl, TREE_TYPE (decl));\n+  else if (TREE_CODE (decl) == FUNCTION_DECL\n+\t   && !mangle_return_type_p (decl))\n+    check_abi_tags (decl, TREE_TYPE (TREE_TYPE (decl)));\n }\n \n void\n@@ -1513,7 +1616,7 @@ inherit_targ_abi_tags (tree t)\n       || CLASSTYPE_TEMPLATE_INFO (t) == NULL_TREE)\n     return;\n \n-  mark_type_abi_tags (t, true);\n+  mark_abi_tags (t, true);\n \n   tree args = CLASSTYPE_TI_ARGS (t);\n   struct abi_tag_data data = { t, NULL_TREE, NULL_TREE };\n@@ -1541,7 +1644,7 @@ inherit_targ_abi_tags (tree t)\n \t\t       TYPE_ATTRIBUTES (t));\n     }\n \n-  mark_type_abi_tags (t, false);\n+  mark_abi_tags (t, false);\n }\n \n /* Return true, iff class T has a non-virtual destructor that is"}, {"sha": "7111449da4b55d45ecb5fece8858d77d3c0983db", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cb73573606d5b0881b0af778a81b5b9c1569f36/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cb73573606d5b0881b0af778a81b5b9c1569f36/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=7cb73573606d5b0881b0af778a81b5b9c1569f36", "patch": "@@ -152,7 +152,7 @@ c-common.h, not after.\n       DECL_MUTABLE_P (in FIELD_DECL)\n       DECL_DEPENDENT_P (in USING_DECL)\n       LABEL_DECL_BREAK (in LABEL_DECL)\n-      NAMESPACE_ABI_TAG (in NAMESPACE_DECL)\n+      NAMESPACE_IS_INLINE (in NAMESPACE_DECL)\n    1: C_TYPEDEF_EXPLICITLY_SIGNED (in TYPE_DECL).\n       DECL_TEMPLATE_INSTANTIATED (in a VAR_DECL or a FUNCTION_DECL)\n       DECL_MEMBER_TEMPLATE_P (in TEMPLATE_DECL)\n@@ -2657,9 +2657,8 @@ struct GTY(()) lang_decl {\n #define LOCAL_CLASS_P(NODE)\t\t\t\t\\\n   (decl_function_context (TYPE_MAIN_DECL (NODE)) != NULL_TREE)\n \n-/* 1 iff this NAMESPACE_DECL should also be treated as an ABI tag for\n-   -Wabi-tag.  */\n-#define NAMESPACE_ABI_TAG(NODE)\t\t\t\t\\\n+/* 1 iff this NAMESPACE_DECL is an inline namespace.  */\n+#define NAMESPACE_IS_INLINE(NODE)\t\t\t\t\\\n   DECL_LANG_FLAG_0 (NAMESPACE_DECL_CHECK (NODE))\n \n /* For a NAMESPACE_DECL: the list of using namespace directives\n@@ -5311,6 +5310,7 @@ extern void explain_non_literal_class\t\t(tree);\n extern void inherit_targ_abi_tags\t\t(tree);\n extern void defaulted_late_check\t\t(tree);\n extern bool defaultable_fn_check\t\t(tree);\n+extern void check_abi_tags\t\t\t(tree);\n extern void fixup_type_variants\t\t\t(tree);\n extern void fixup_attribute_variants\t\t(tree);\n extern tree* decl_cloned_function_p\t\t(const_tree, bool);\n@@ -6069,6 +6069,7 @@ extern bool type_has_nontrivial_copy_init\t(const_tree);\n extern bool class_tmpl_impl_spec_p\t\t(const_tree);\n extern int zero_init_p\t\t\t\t(const_tree);\n extern bool check_abi_tag_redeclaration\t\t(const_tree, const_tree, const_tree);\n+extern bool check_abi_tag_args\t\t\t(tree, tree);\n extern tree strip_typedefs\t\t\t(tree);\n extern tree strip_typedefs_expr\t\t\t(tree);\n extern tree copy_binfo\t\t\t\t(tree, tree, tree,\n@@ -6345,6 +6346,7 @@ extern tree mangle_tls_wrapper_fn\t\t(tree);\n extern bool decl_tls_wrapper_p\t\t\t(tree);\n extern tree mangle_ref_init_variable\t\t(tree);\n extern char * get_mangled_vtable_map_var_name   (tree);\n+extern bool mangle_return_type_p\t\t(tree);\n \n /* in dump.c */\n extern bool cp_dump_tree\t\t\t(void *, tree);"}, {"sha": "b0f72d1ff14e37c9c210e331cc2bb5a0e0e3d6b6", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 59, "deletions": 23, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cb73573606d5b0881b0af778a81b5b9c1569f36/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cb73573606d5b0881b0af778a81b5b9c1569f36/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=7cb73573606d5b0881b0af778a81b5b9c1569f36", "patch": "@@ -648,6 +648,48 @@ find_substitution (tree node)\n   return 1;\n }\n \n+/* Returns whether DECL's symbol name should be the plain unqualified-id\n+   rather than a more complicated mangled name.  */\n+\n+static bool\n+unmangled_name_p (const tree decl)\n+{\n+  if (TREE_CODE (decl) == FUNCTION_DECL)\n+    {\n+      /* The names of `extern \"C\"' functions are not mangled.  */\n+      return (DECL_EXTERN_C_FUNCTION_P (decl)\n+\t      /* But overloaded operator names *are* mangled.  */\n+\t      && !DECL_OVERLOADED_OPERATOR_P (decl));\n+    }\n+  else if (VAR_P (decl))\n+    {\n+      /* static variables are mangled.  */\n+      if (!DECL_EXTERNAL_LINKAGE_P (decl))\n+\treturn false;\n+\n+      /* extern \"C\" declarations aren't mangled.  */\n+      if (DECL_EXTERN_C_P (decl))\n+\treturn true;\n+\n+      /* Other variables at non-global scope are mangled.  */\n+      if (CP_DECL_CONTEXT (decl) != global_namespace)\n+\treturn false;\n+\n+      /* Variable template instantiations are mangled.  */\n+      if (DECL_LANG_SPECIFIC (decl) && DECL_TEMPLATE_INFO (decl)\n+\t  && variable_template_p (DECL_TI_TEMPLATE (decl)))\n+\treturn false;\n+\n+      /* Declarations with ABI tags are mangled.  */\n+      if (lookup_attribute (\"abi_tag\", DECL_ATTRIBUTES (decl)))\n+\treturn false;\n+\n+      /* The names of non-static global variables aren't mangled.  */\n+      return true;\n+    }\n+\n+  return false;\n+}\n \n /* TOP_LEVEL is true, if this is being called at outermost level of\n   mangling. It should be false when mangling a decl appearing in an\n@@ -660,13 +702,10 @@ write_mangled_name (const tree decl, bool top_level)\n {\n   MANGLE_TRACE_TREE (\"mangled-name\", decl);\n \n-  if (/* The names of `extern \"C\"' functions are not mangled.  */\n-      DECL_EXTERN_C_FUNCTION_P (decl)\n-      /* But overloaded operator names *are* mangled.  */\n-      && !DECL_OVERLOADED_OPERATOR_P (decl))\n-    {\n-    unmangled_name:;\n+  check_abi_tags (decl);\n \n+  if (unmangled_name_p (decl))\n+    {\n       if (top_level)\n \twrite_string (IDENTIFIER_POINTER (DECL_NAME (decl)));\n       else\n@@ -680,25 +719,25 @@ write_mangled_name (const tree decl, bool top_level)\n \t  write_source_name (DECL_NAME (decl));\n \t}\n     }\n-  else if (VAR_P (decl)\n-\t   /* Variable template instantiations are mangled.  */\n-\t   && !(DECL_LANG_SPECIFIC (decl) && DECL_TEMPLATE_INFO (decl)\n-\t\t&& variable_template_p (DECL_TI_TEMPLATE (decl)))\n-\t   /* The names of non-static global variables aren't mangled.  */\n-\t   && DECL_EXTERNAL_LINKAGE_P (decl)\n-\t   && (CP_DECL_CONTEXT (decl) == global_namespace\n-\t       /* And neither are `extern \"C\"' variables.  */\n-\t       || DECL_EXTERN_C_P (decl)))\n-    {\n-      goto unmangled_name;\n-    }\n   else\n     {\n       write_string (\"_Z\");\n       write_encoding (decl);\n     }\n }\n \n+/* Returns true if the return type of DECL is part of its signature, and\n+   therefore its mangling.  */\n+\n+bool\n+mangle_return_type_p (tree decl)\n+{\n+  return (!DECL_CONSTRUCTOR_P (decl)\n+\t  && !DECL_DESTRUCTOR_P (decl)\n+\t  && !DECL_CONV_FN_P (decl)\n+\t  && decl_is_template_id (decl, NULL));\n+}\n+\n /*   <encoding>\t\t::= <function name> <bare-function-type>\n \t\t\t::= <data name>  */\n \n@@ -740,10 +779,7 @@ write_encoding (const tree decl)\n \t}\n \n       write_bare_function_type (fn_type,\n-\t\t\t\t(!DECL_CONSTRUCTOR_P (decl)\n-\t\t\t\t && !DECL_DESTRUCTOR_P (decl)\n-\t\t\t\t && !DECL_CONV_FN_P (decl)\n-\t\t\t\t && decl_is_template_id (decl, NULL)),\n+\t\t\t\tmangle_return_type_p (decl),\n \t\t\t\td);\n     }\n }\n@@ -1290,7 +1326,7 @@ write_unqualified_name (tree decl)\n   if (tree tmpl = most_general_template (decl))\n     decl = DECL_TEMPLATE_RESULT (tmpl);\n   /* Don't crash on an unbound class template.  */\n-  if (decl)\n+  if (decl && TREE_CODE (decl) != NAMESPACE_DECL)\n     {\n       tree attrs = (TREE_CODE (decl) == TYPE_DECL\n \t\t    ? TYPE_ATTRIBUTES (TREE_TYPE (decl))"}, {"sha": "c845d521a53ebc319ee34896f070f4d5d928b58b", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cb73573606d5b0881b0af778a81b5b9c1569f36/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cb73573606d5b0881b0af778a81b5b9c1569f36/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=7cb73573606d5b0881b0af778a81b5b9c1569f36", "patch": "@@ -3657,7 +3657,24 @@ handle_namespace_attrs (tree ns, tree attributes)\n \t}\n       else if (is_attribute_p (\"abi_tag\", name))\n \t{\n-\t  NAMESPACE_ABI_TAG (ns) = true;\n+\t  if (!NAMESPACE_IS_INLINE (ns))\n+\t    {\n+\t      warning (OPT_Wattributes, \"ignoring %qD attribute on non-inline \"\n+\t\t       \"namespace\", name);\n+\t      continue;\n+\t    }\n+\t  if (!args)\n+\t    {\n+\t      tree dn = DECL_NAME (ns);\n+\t      args = build_string (IDENTIFIER_LENGTH (dn) + 1,\n+\t\t\t\t   IDENTIFIER_POINTER (dn));\n+\t      TREE_TYPE (args) = char_array_type_node;\n+\t      args = fix_string_type (args);\n+\t      args = build_tree_list (NULL_TREE, args);\n+\t    }\n+\t  if (check_abi_tag_args (args, name))\n+\t    DECL_ATTRIBUTES (ns) = tree_cons (name, args,\n+\t\t\t\t\t      DECL_ATTRIBUTES (ns));\n \t}\n       else\n \t{"}, {"sha": "98d741f440a720182ae9887936b8906f7da2da11", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cb73573606d5b0881b0af778a81b5b9c1569f36/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cb73573606d5b0881b0af778a81b5b9c1569f36/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=7cb73573606d5b0881b0af778a81b5b9c1569f36", "patch": "@@ -16233,6 +16233,7 @@ cp_parser_namespace_definition (cp_parser* parser)\n   if (is_inline)\n     {\n       tree name_space = current_namespace;\n+      NAMESPACE_IS_INLINE (name_space) = true;\n       /* Set up namespace association.  */\n       DECL_NAMESPACE_ASSOCIATIONS (name_space)\n \t= tree_cons (CP_DECL_CONTEXT (name_space), NULL_TREE,"}, {"sha": "ef53aff87f74cff4427b9aa5a8a8829166f90e43", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 29, "deletions": 11, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cb73573606d5b0881b0af778a81b5b9c1569f36/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cb73573606d5b0881b0af778a81b5b9c1569f36/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=7cb73573606d5b0881b0af778a81b5b9c1569f36", "patch": "@@ -3485,13 +3485,17 @@ check_abi_tag_redeclaration (const_tree decl, const_tree old, const_tree new_)\n   return true;\n }\n \n-/* Handle an \"abi_tag\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n+/* The abi_tag attribute with the name NAME was given ARGS.  If they are\n+   ill-formed, give an error and return false; otherwise, return true.  */\n \n-static tree\n-handle_abi_tag_attribute (tree* node, tree name, tree args,\n-\t\t\t  int flags, bool* no_add_attrs)\n+bool\n+check_abi_tag_args (tree args, tree name)\n {\n+  if (!args)\n+    {\n+      error (\"the %qE attribute requires arguments\", name);\n+      return false;\n+    }\n   for (tree arg = args; arg; arg = TREE_CHAIN (arg))\n     {\n       tree elt = TREE_VALUE (arg);\n@@ -3502,7 +3506,7 @@ handle_abi_tag_attribute (tree* node, tree name, tree args,\n \t{\n \t  error (\"arguments to the %qE attribute must be narrow string \"\n \t\t \"literals\", name);\n-\t  goto fail;\n+\t  return false;\n \t}\n       const char *begin = TREE_STRING_POINTER (elt);\n       const char *end = begin + TREE_STRING_LENGTH (elt);\n@@ -3517,7 +3521,7 @@ handle_abi_tag_attribute (tree* node, tree name, tree args,\n \t\t\t \"identifiers\", name);\n \t\t  inform (input_location, \"%<%c%> is not a valid first \"\n \t\t\t  \"character for an identifier\", c);\n-\t\t  goto fail;\n+\t\t  return false;\n \t\t}\n \t    }\n \t  else if (p == end - 1)\n@@ -3530,11 +3534,23 @@ handle_abi_tag_attribute (tree* node, tree name, tree args,\n \t\t\t \"identifiers\", name);\n \t\t  inform (input_location, \"%<%c%> is not a valid character \"\n \t\t\t  \"in an identifier\", c);\n-\t\t  goto fail;\n+\t\t  return false;\n \t\t}\n \t    }\n \t}\n     }\n+  return true;\n+}\n+\n+/* Handle an \"abi_tag\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_abi_tag_attribute (tree* node, tree name, tree args,\n+\t\t\t  int flags, bool* no_add_attrs)\n+{\n+  if (!check_abi_tag_args (args, name))\n+    goto fail;\n \n   if (TYPE_P (*node))\n     {\n@@ -3578,14 +3594,16 @@ handle_abi_tag_attribute (tree* node, tree name, tree args,\n     }\n   else\n     {\n-      if (TREE_CODE (*node) != FUNCTION_DECL)\n+      if (TREE_CODE (*node) != FUNCTION_DECL\n+\t  && TREE_CODE (*node) != VAR_DECL)\n \t{\n-\t  error (\"%qE attribute applied to non-function %qD\", name, *node);\n+\t  error (\"%qE attribute applied to non-function, non-variable %qD\",\n+\t\t name, *node);\n \t  goto fail;\n \t}\n       else if (DECL_LANGUAGE (*node) == lang_c)\n \t{\n-\t  error (\"%qE attribute applied to extern \\\"C\\\" function %qD\",\n+\t  error (\"%qE attribute applied to extern \\\"C\\\" declaration %qD\",\n \t\t name, *node);\n \t  goto fail;\n \t}"}, {"sha": "c6fdb2453c85b81bafae5d12e4e77934db8ebb29", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cb73573606d5b0881b0af778a81b5b9c1569f36/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cb73573606d5b0881b0af778a81b5b9c1569f36/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=7cb73573606d5b0881b0af778a81b5b9c1569f36", "patch": "@@ -18722,18 +18722,26 @@ Some attributes only make sense for C++ programs.\n @table @code\n @item abi_tag (\"@var{tag}\", ...)\n @cindex @code{abi_tag} attribute\n-The @code{abi_tag} attribute can be applied to a function or class\n-declaration.  It modifies the mangled name of the function or class to\n+The @code{abi_tag} attribute can be applied to a function, variable, or class\n+declaration.  It modifies the mangled name of the entity to\n incorporate the tag name, in order to distinguish the function or\n class from an earlier version with a different ABI; perhaps the class\n has changed size, or the function has a different return type that is\n not encoded in the mangled name.\n \n+The attribute can also be applied to an inline namespace, but does not\n+affect the mangled name of the namespace; in this case it is only used\n+for @option{-Wabi-tag} warnings and automatic tagging of functions and\n+variables.  Tagging inline namespaces is generally preferable to\n+tagging individual declarations, but the latter is sometimes\n+necessary, such as when only certain members of a class need to be\n+tagged.\n+\n The argument can be a list of strings of arbitrary length.  The\n strings are sorted on output, so the order of the list is\n unimportant.\n \n-A redeclaration of a function or class must not add new ABI tags,\n+A redeclaration of an entity must not add new ABI tags,\n since doing so would change the mangled name.\n \n The ABI tags apply to a name, so all instantiations and\n@@ -18745,6 +18753,13 @@ not have all the ABI tags used by its subobjects and virtual functions; for user\n that needs to coexist with an earlier ABI, using this option can help\n to find all affected types that need to be tagged.\n \n+When a type involving an ABI tag is used as the type of a variable or\n+return type of a function where that tag is not already present in the\n+signature of the function, the tag is automatically applied to the\n+variable or function.  @option{-Wabi-tag} also warns about this\n+situation; this warning can be avoided by explicitly tagging the\n+variable or function or moving it into a tagged inline namespace.\n+\n @item init_priority (@var{priority})\n @cindex @code{init_priority} attribute\n "}, {"sha": "133cca9042ec630a385852508e376f02ee8ee6a6", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cb73573606d5b0881b0af778a81b5b9c1569f36/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cb73573606d5b0881b0af778a81b5b9c1569f36/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=7cb73573606d5b0881b0af778a81b5b9c1569f36", "patch": "@@ -197,7 +197,7 @@ in the following sections.\n -fvtv-counts -fvtv-debug @gol\n -fvisibility-ms-compat @gol\n -fext-numeric-literals @gol\n--Wabi=@var{n}  -Wconversion-null  -Wctor-dtor-privacy @gol\n+-Wabi=@var{n}  -Wabi-tag  -Wconversion-null  -Wctor-dtor-privacy @gol\n -Wdelete-non-virtual-dtor -Wliteral-suffix -Wnarrowing @gol\n -Wnoexcept -Wnon-virtual-dtor  -Wreorder @gol\n -Weffc++  -Wstrict-null-sentinel @gol\n@@ -2641,6 +2641,13 @@ union U @{\n \n @end itemize\n \n+@item -Wabi-tag @r{(C++ and Objective-C++ only)}\n+@opindex Wabi-tag\n+@opindex -Wabi-tag\n+Warn when a type with an ABI tag is used in a context that does not\n+have that ABI tag.  See @ref{C++ Attributes} for more information\n+about ABI tags.\n+\n @item -Wctor-dtor-privacy @r{(C++ and Objective-C++ only)}\n @opindex Wctor-dtor-privacy\n @opindex Wno-ctor-dtor-privacy"}, {"sha": "d57ed87d80378e88534b9b0d236c184ee9c0627e", "filename": "gcc/testsuite/g++.dg/abi/abi-tag1.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cb73573606d5b0881b0af778a81b5b9c1569f36/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fabi-tag1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cb73573606d5b0881b0af778a81b5b9c1569f36/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fabi-tag1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fabi-tag1.C?ref=7cb73573606d5b0881b0af778a81b5b9c1569f36", "patch": "@@ -5,8 +5,8 @@ void f(int) __attribute ((abi_tag (\"foo\",\"bar\")));\n \n struct __attribute ((abi_tag (\"bar\"))) A { };\n \n-struct B: A { };\t\t// { dg-warning \"bar. abi tag\" }\n-struct D { A* ap; };\t\t// { dg-warning \"bar. abi tag\" }\n+struct B: A { };\t\t// { dg-warning \"bar. ABI tag\" }\n+struct D { A* ap; };\t\t// { dg-warning \"bar. ABI tag\" }\n \n // { dg-final { scan-assembler \"_Z1gB3baz1AB3bar\" } }\n void g(A) __attribute ((abi_tag (\"baz\")));"}, {"sha": "a66e6552cbab18c96f37bf2cefd296771d35286f", "filename": "gcc/testsuite/g++.dg/abi/abi-tag14.C", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cb73573606d5b0881b0af778a81b5b9c1569f36/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fabi-tag14.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cb73573606d5b0881b0af778a81b5b9c1569f36/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fabi-tag14.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fabi-tag14.C?ref=7cb73573606d5b0881b0af778a81b5b9c1569f36", "patch": "@@ -0,0 +1,30 @@\n+// { dg-options \"-Wabi-tag\" }\n+\n+inline namespace __cxx11 __attribute ((abi_tag (\"cxx11\"))) {\n+  struct A {};\n+};\n+\n+// { dg-final { scan-assembler \"_Z1aB5cxx11\" } }\n+A a;\t\t\t\t// { dg-warning \"\\\"cxx11\\\"\" }\n+\n+// { dg-final { scan-assembler \"_Z1fB5cxx11v\" } }\n+A f() {}\t\t\t// { dg-warning \"\\\"cxx11\\\"\" }\n+\n+namespace {\n+  A a2;\n+  A f2() {}\n+  struct B: A {};\n+}\n+\n+// { dg-final { scan-assembler \"_Z1fPN7__cxx111AE\" } }\n+A f(A*) {}\n+\n+// { dg-final { scan-assembler \"_Z1gIN7__cxx111AEET_v\" } }\n+template <class T> T g() { }\n+template <> A g<A>() { }\n+\n+// { dg-final { scan-assembler \"_Z1vIN7__cxx111AEE\" { target c++14 } } }\n+#if __cplusplus >= 201402L\n+template <class T> T v = T();\n+void *p = &v<A>;\n+#endif"}, {"sha": "6bf4fa1c538575edca149a3ef1e471c0697801a6", "filename": "gcc/testsuite/g++.dg/abi/abi-tag4.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cb73573606d5b0881b0af778a81b5b9c1569f36/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fabi-tag4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cb73573606d5b0881b0af778a81b5b9c1569f36/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fabi-tag4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fabi-tag4.C?ref=7cb73573606d5b0881b0af778a81b5b9c1569f36", "patch": "@@ -2,7 +2,7 @@\n \n struct __attribute ((abi_tag (\"X\"))) A { };\n \n-struct B\t\t\t// { dg-warning \"abi tag\" }\n+struct B\t\t\t// { dg-warning \"ABI tag\" }\n {\n   virtual void f(A);\t\t// { dg-message \"declared here\" }\n };"}, {"sha": "7ead1cb86b44f2c68a73578ba9b9ce230524af57", "filename": "gcc/testsuite/g++.dg/abi/abi-tag8.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cb73573606d5b0881b0af778a81b5b9c1569f36/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fabi-tag8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cb73573606d5b0881b0af778a81b5b9c1569f36/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fabi-tag8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fabi-tag8.C?ref=7cb73573606d5b0881b0af778a81b5b9c1569f36", "patch": "@@ -4,6 +4,6 @@ template<class T>\n struct __attribute ((__abi_tag__(\"cxx11\"))) list // { dg-message \"list\" }\n { };\n \n-struct X {\t\t\t// { dg-warning \"abi tag\" }\n+struct X {\t\t\t// { dg-warning \"ABI tag\" }\n   list<int> l;\t\t\t// { dg-message \"X::l\" }\n };"}, {"sha": "6836423e7d1be274249fc06d955dcc6c51733cbe", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cb73573606d5b0881b0af778a81b5b9c1569f36/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cb73573606d5b0881b0af778a81b5b9c1569f36/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=7cb73573606d5b0881b0af778a81b5b9c1569f36", "patch": "@@ -1,3 +1,8 @@\n+2015-03-19  Jason Merrill  <jason@redhat.com>\n+\n+\t* config/locale/gnu/messages_members.cc: Revert abi-tag change.\n+\t* src/c++11/cxx11-shim_facets.cc: Revert abi-tag change.\n+\n 2015-03-18  Jonathan Wakely  <jwakely@redhat.com>\n \n \tPR c++/65046"}, {"sha": "2e6122d2ea520fca9f44659b2b34d9c6f1fa1772", "filename": "libstdc++-v3/config/locale/gnu/messages_members.cc", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cb73573606d5b0881b0af778a81b5b9c1569f36/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fgnu%2Fmessages_members.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cb73573606d5b0881b0af778a81b5b9c1569f36/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fgnu%2Fmessages_members.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fgnu%2Fmessages_members.cc?ref=7cb73573606d5b0881b0af778a81b5b9c1569f36", "patch": "@@ -46,8 +46,8 @@ namespace\n \n   typedef messages_base::catalog catalog;\n \n-  struct _GLIBCXX_DEFAULT_ABI_TAG Catalog_info\n-  {\n+  struct Catalog_info\n+    {\n     Catalog_info(catalog __id, const string& __domain, locale __loc)\n       : _M_id(__id), _M_domain(__domain), _M_locale(__loc)\n     { }\n@@ -57,7 +57,7 @@ namespace\n     locale _M_locale;\n   };\n \n-  class _GLIBCXX_DEFAULT_ABI_TAG Catalogs\n+  class Catalogs\n   {\n   public:\n     Catalogs() : _M_catalog_counter(0) { }\n@@ -133,7 +133,6 @@ namespace\n     std::vector<Catalog_info*> _M_infos;\n   };\n \n-  _GLIBCXX_DEFAULT_ABI_TAG\n   Catalogs&\n   get_catalogs()\n   {"}, {"sha": "eebe34c604c636edd99beaf3ddae0757f8d9bb8c", "filename": "libstdc++-v3/include/bits/c++config", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cb73573606d5b0881b0af778a81b5b9c1569f36/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fc%2B%2Bconfig", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cb73573606d5b0881b0af778a81b5b9c1569f36/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fc%2B%2Bconfig", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fc%2B%2Bconfig?ref=7cb73573606d5b0881b0af778a81b5b9c1569f36", "patch": "@@ -215,7 +215,7 @@ namespace std\n #if _GLIBCXX_USE_CXX11_ABI\n namespace std\n {\n-  inline namespace __cxx11 __attribute__((__abi_tag__)) { }\n+  inline namespace __cxx11 __attribute__((__abi_tag__ (\"cxx11\"))) { }\n }\n # define _GLIBCXX_NAMESPACE_CXX11 __cxx11::\n # define _GLIBCXX_BEGIN_NAMESPACE_CXX11 namespace __cxx11 {"}, {"sha": "4e30088bac3732520c35744018ed8bd5940277b0", "filename": "libstdc++-v3/src/c++11/cxx11-shim_facets.cc", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cb73573606d5b0881b0af778a81b5b9c1569f36/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fcxx11-shim_facets.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cb73573606d5b0881b0af778a81b5b9c1569f36/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fcxx11-shim_facets.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fcxx11-shim_facets.cc?ref=7cb73573606d5b0881b0af778a81b5b9c1569f36", "patch": "@@ -227,8 +227,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   namespace // unnamed\n   {\n     template<typename _CharT>\n-      struct _GLIBCXX_DEFAULT_ABI_TAG numpunct_shim\n-      : std::numpunct<_CharT>, facet::__shim\n+      struct numpunct_shim : std::numpunct<_CharT>, facet::__shim\n       {\n \ttypedef typename numpunct<_CharT>::__cache_type __cache_type;\n \n@@ -252,8 +251,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       };\n \n     template<typename _CharT>\n-      struct _GLIBCXX_DEFAULT_ABI_TAG collate_shim\n-      : std::collate<_CharT>, facet::__shim\n+      struct collate_shim : std::collate<_CharT>, facet::__shim\n       {\n \ttypedef basic_string<_CharT>\tstring_type;\n \n@@ -278,8 +276,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       };\n \n     template<typename _CharT>\n-      struct _GLIBCXX_DEFAULT_ABI_TAG time_get_shim\n-      : std::time_get<_CharT>, facet::__shim\n+      struct time_get_shim : std::time_get<_CharT>, facet::__shim\n       {\n \ttypedef typename std::time_get<_CharT>::iter_type iter_type;\n \ttypedef typename std::time_get<_CharT>::char_type char_type;\n@@ -333,8 +330,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       };\n \n     template<typename _CharT, bool _Intl>\n-      struct _GLIBCXX_DEFAULT_ABI_TAG moneypunct_shim\n-      : std::moneypunct<_CharT, _Intl>, facet::__shim\n+      struct moneypunct_shim : std::moneypunct<_CharT, _Intl>, facet::__shim\n       {\n \ttypedef typename moneypunct<_CharT, _Intl>::__cache_type __cache_type;\n \n@@ -361,8 +357,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       };\n \n     template<typename _CharT>\n-      struct _GLIBCXX_DEFAULT_ABI_TAG money_get_shim\n-      : std::money_get<_CharT>, facet::__shim\n+      struct money_get_shim : std::money_get<_CharT>, facet::__shim\n       {\n \ttypedef typename std::money_get<_CharT>::iter_type iter_type;\n \ttypedef typename std::money_get<_CharT>::char_type char_type;\n@@ -403,8 +398,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       };\n \n     template<typename _CharT>\n-      struct _GLIBCXX_DEFAULT_ABI_TAG money_put_shim\n-      : std::money_put<_CharT>, facet::__shim\n+      struct money_put_shim : std::money_put<_CharT>, facet::__shim\n       {\n \ttypedef typename std::money_put<_CharT>::iter_type iter_type;\n \ttypedef typename std::money_put<_CharT>::char_type char_type;\n@@ -433,8 +427,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       };\n \n     template<typename _CharT>\n-      struct _GLIBCXX_DEFAULT_ABI_TAG messages_shim\n-      : std::messages<_CharT>, facet::__shim\n+      struct messages_shim : std::messages<_CharT>, facet::__shim\n       {\n \ttypedef messages_base::catalog  catalog;\n \ttypedef basic_string<_CharT>\tstring_type;"}]}