{"sha": "aac04c15d761628889f138b16219bce27f25bbb2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWFjMDRjMTVkNzYxNjI4ODg5ZjEzOGIxNjIxOWJjZTI3ZjI1YmJiMg==", "commit": {"author": {"name": "DJ Delorie", "email": "dj@redhat.com", "date": "2001-10-16T02:50:13Z"}, "committer": {"name": "DJ Delorie", "email": "dj@gcc.gnu.org", "date": "2001-10-16T02:50:13Z"}, "message": "Makefile.in (TEXIFILES): Add fnmatch.txh.\n\n* Makefile.in (TEXIFILES): Add fnmatch.txh.\n(maint-undoc): New.\nmaint-tool: Add \"undoc\" tool.\n* alloca.c, argv.c, asprintf.c, choose-temp.c, concat.c,\nfdmatch.c, ffs.c, getruntime.c, insque.c, lbasename.c,\nmake-temp-file.c, mkstemps.c, pexecute.c, random.c, spaces.c,\nstrerror.s, strsignal.c, strtol.c, vasprintf.c: Add or update\ndocumentation.\n* fnmatch.txh: New.\n* functions.texi: Regenerate.\n\nFrom-SVN: r46274", "tree": {"sha": "58903ff3e4335306b7c9f5c24e8baf3b9a9922a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/58903ff3e4335306b7c9f5c24e8baf3b9a9922a8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aac04c15d761628889f138b16219bce27f25bbb2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aac04c15d761628889f138b16219bce27f25bbb2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aac04c15d761628889f138b16219bce27f25bbb2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aac04c15d761628889f138b16219bce27f25bbb2/comments", "author": null, "committer": null, "parents": [{"sha": "2d4368e6cd739fadc7e3cc1111f30f2941e8a8a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d4368e6cd739fadc7e3cc1111f30f2941e8a8a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d4368e6cd739fadc7e3cc1111f30f2941e8a8a3"}], "stats": {"total": 1242, "additions": 944, "deletions": 298}, "files": [{"sha": "e291900c272108ded789d76a0c77c85bf4bfd22c", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aac04c15d761628889f138b16219bce27f25bbb2/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aac04c15d761628889f138b16219bce27f25bbb2/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=aac04c15d761628889f138b16219bce27f25bbb2", "patch": "@@ -1,3 +1,16 @@\n+2001-10-15  DJ Delorie  <dj@redhat.com>\n+\n+\t* Makefile.in (TEXIFILES): Add fnmatch.txh.\n+\t(maint-undoc): New.\n+\tmaint-tool: Add \"undoc\" tool.\n+\t* alloca.c, argv.c, asprintf.c, choose-temp.c, concat.c,\n+\tfdmatch.c, ffs.c, getruntime.c, insque.c, lbasename.c,\n+\tmake-temp-file.c, mkstemps.c, pexecute.c, random.c, spaces.c,\n+\tstrerror.s, strsignal.c, strtol.c, vasprintf.c: Add or update\n+\tdocumentation.\n+\t* fnmatch.txh: New.\n+\t* functions.texi: Regenerate.\n+\t\n 2001-10-10  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* bcmp.c, setenv.c: Use \"nonzero\" instead of \"non-zero\"."}, {"sha": "f5499029696d5915a468454bfee5dff8d1edafa6", "filename": "libiberty/Makefile.in", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aac04c15d761628889f138b16219bce27f25bbb2/libiberty%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aac04c15d761628889f138b16219bce27f25bbb2/libiberty%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FMakefile.in?ref=aac04c15d761628889f138b16219bce27f25bbb2", "patch": "@@ -172,8 +172,9 @@ TEXISRC = \\\n \t$(srcdir)/functions.texi\n \n # Additional files that have texi snippets that need to be collected\n-# and sorted.\n-TEXIFILES = \n+# and sorted.  Some are here because the sources are imported from\n+# elsewhere.  Others represent headers in ../include.\n+TEXIFILES = fnmatch.txh\n \n libiberty.info : $(srcdir)/libiberty.texi $(TEXISRC)\n \t$(MAKEINFO) -I$(srcdir) $(srcdir)/libiberty.texi\n@@ -257,6 +258,9 @@ maint-missing :\n maint-buildall : $(REQUIRED_OFILES) $(CONFIGURED_OFILES)\n \t@true\n \n+maint-undoc : $(srcdir)/functions.texi\n+\t@$(PERL) $(srcdir)/maint-tool -s $(srcdir) undoc\n+\n # Need to deal with profiled libraries, too.\n \n # Cleaning has to be done carefully to ensure that we don't clean our SUBDIRS"}, {"sha": "918235df465203df525fe58b41afc9ab53b1a4cf", "filename": "libiberty/alloca.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aac04c15d761628889f138b16219bce27f25bbb2/libiberty%2Falloca.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aac04c15d761628889f138b16219bce27f25bbb2/libiberty%2Falloca.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Falloca.c?ref=aac04c15d761628889f138b16219bce27f25bbb2", "patch": "@@ -150,6 +150,8 @@ static header *last_alloca_header = NULL;\t/* -> last alloca header.  */\n    caller, but that method cannot be made to work for some\n    implementations of C, for example under Gould's UTX/32.  */\n \n+/* @undocumented C_alloca */\n+\n PTR\n C_alloca (size)\n      size_t size;"}, {"sha": "ede61cb541be5751a6d9d666e7f5b790607f34bf", "filename": "libiberty/argv.c", "status": "modified", "additions": 40, "deletions": 68, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aac04c15d761628889f138b16219bce27f25bbb2/libiberty%2Fargv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aac04c15d761628889f138b16219bce27f25bbb2/libiberty%2Fargv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fargv.c?ref=aac04c15d761628889f138b16219bce27f25bbb2", "patch": "@@ -62,26 +62,15 @@ extern char *strdup ();\t\t/* Duplicate a string */\n \n /*\n \n-NAME\n+@deftypefn Extension char** dupargv (char **@var{vector})\n \n-\tdupargv -- duplicate an argument vector\n+Duplicate an argument vector.  Simply scans through @var{vector},\n+duplicating each argument until the terminating @code{NULL} is found.\n+Returns a pointer to the argument vector if successful. Returns\n+@code{NULL} if there is insufficient memory to complete building the\n+argument vector.\n \n-SYNOPSIS\n-\n-\tchar **dupargv (vector)\n-\tchar **vector;\n-\n-DESCRIPTION\n-\n-\tDuplicate an argument vector.  Simply scans through the\n-\tvector, duplicating each argument until the\n-\tterminating NULL is found.\n-\n-RETURNS\n-\n-\tReturns a pointer to the argument vector if\n-\tsuccessful. Returns NULL if there is insufficient memory to\n-\tcomplete building the argument vector.\n+@end deftypefn\n \n */\n \n@@ -119,24 +108,14 @@ dupargv (argv)\n \n /*\n \n-NAME\n-\n-\tfreeargv -- free an argument vector\n-\n-SYNOPSIS\n+@deftypefn Extension void freeargv (char **@var{vector})\n \n-\tvoid freeargv (vector)\n-\tchar **vector;\n+Free an argument vector that was built using @code{buildargv}.  Simply\n+scans through @var{vector}, freeing the memory for each argument until\n+the terminating @code{NULL} is found, and then frees @var{vector}\n+itself.\n \n-DESCRIPTION\n-\n-\tFree an argument vector that was built using buildargv.  Simply scans\n-\tthrough the vector, freeing the memory for each argument until the\n-\tterminating NULL is found, and then frees the vector itself.\n-\n-RETURNS\n-\n-\tNo value.\n+@end deftypefn\n \n */\n \n@@ -157,49 +136,42 @@ char **vector;\n \n /*\n \n-NAME\n-\n-\tbuildargv -- build an argument vector from a string\n-\n-SYNOPSIS\n-\n-\tchar **buildargv (sp)\n-\tchar *sp;\n-\n-DESCRIPTION\n+@deftypefn Extension char** buildargv (char *@var{sp})\n \n-\tGiven a pointer to a string, parse the string extracting fields\n-\tseparated by whitespace and optionally enclosed within either single\n-\tor double quotes (which are stripped off), and build a vector of\n-\tpointers to copies of the string for each field.  The input string\n-\tremains unchanged.\n+Given a pointer to a string, parse the string extracting fields\n+separated by whitespace and optionally enclosed within either single\n+or double quotes (which are stripped off), and build a vector of\n+pointers to copies of the string for each field.  The input string\n+remains unchanged.  The last element of the vector is followed by a\n+@code{NULL} element.\n \n-\tAll of the memory for the pointer array and copies of the string\n-\tis obtained from malloc.  All of the memory can be returned to the\n-\tsystem with the single function call freeargv, which takes the\n-\treturned result of buildargv, as it's argument.\n+All of the memory for the pointer array and copies of the string\n+is obtained from @code{malloc}.  All of the memory can be returned to the\n+system with the single function call @code{freeargv}, which takes the\n+returned result of @code{buildargv}, as it's argument.\n \n-\tThe memory for the argv array is dynamically expanded as necessary.\n+Returns a pointer to the argument vector if successful. Returns\n+@code{NULL} if @var{sp} is @code{NULL} or if there is insufficient\n+memory to complete building the argument vector.\n \n-RETURNS\n+If the input is a null string (as opposed to a @code{NULL} pointer),\n+then buildarg returns an argument vector that has one arg, a null\n+string.\n \n-\tReturns a pointer to the argument vector if successful. Returns NULL\n-\tif the input string pointer is NULL or if there is insufficient\n-\tmemory to complete building the argument vector.\n+@end deftypefn\n \n-NOTES\n+The memory for the argv array is dynamically expanded as necessary.\n \n-\tIn order to provide a working buffer for extracting arguments into,\n-\twith appropriate stripping of quotes and translation of backslash\n-\tsequences, we allocate a working buffer at least as long as the input\n-\tstring.  This ensures that we always have enough space in which to\n-\twork, since the extracted arg is never larger than the input string.\n+In order to provide a working buffer for extracting arguments into,\n+with appropriate stripping of quotes and translation of backslash\n+sequences, we allocate a working buffer at least as long as the input\n+string.  This ensures that we always have enough space in which to\n+work, since the extracted arg is never larger than the input string.\n \n-\tIf the input is a null string (as opposed to a NULL pointer), then\n-\tbuildarg returns an argv that has one arg, a null string.\n+The argument vector is always kept terminated with a @code{NULL} arg\n+pointer, so it can be passed to @code{freeargv} at any time, or\n+returned, as appropriate.\n \n-\tArgv is always kept terminated with a NULL arg pointer, so it can\n-\tbe passed to freeargv at any time, or returned, as appropriate.\n */\n \n char **buildargv (input)"}, {"sha": "7693ac01818061d84063ee7983d496cffe640d01", "filename": "libiberty/asprintf.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aac04c15d761628889f138b16219bce27f25bbb2/libiberty%2Fasprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aac04c15d761628889f138b16219bce27f25bbb2/libiberty%2Fasprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fasprintf.c?ref=aac04c15d761628889f138b16219bce27f25bbb2", "patch": "@@ -28,6 +28,22 @@ Boston, MA 02111-1307, USA.  */\n #include <varargs.h>\n #endif\n \n+/*\n+\n+@deftypefn Extension int asprintf (char **@var{resptr}, char *@var{format}, ...)\n+\n+Like @code{sprintf}, but instead of passing a pointer to a buffer, you\n+pass a pointer to a pointer.  This function will compute the size of\n+the buffer needed, allocate memory with @code{malloc}, and store a\n+pointer to the allocated memory in @code{*@var{resptr}}.  The value\n+returned is the same as @code{sprintf} would return.  If memory could\n+not be allocated, zero is returned and @code{NULL} is stored in\n+@code{*@var{resptr}}.\n+\n+@end deftypefn\n+\n+*/\n+\n int\n asprintf VPARAMS ((char **buf, const char *fmt, ...))\n {"}, {"sha": "de6fbed4b7dade5c5f37833c8bfcabbe418b0c4c", "filename": "libiberty/choose-temp.c", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aac04c15d761628889f138b16219bce27f25bbb2/libiberty%2Fchoose-temp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aac04c15d761628889f138b16219bce27f25bbb2/libiberty%2Fchoose-temp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fchoose-temp.c?ref=aac04c15d761628889f138b16219bce27f25bbb2", "patch": "@@ -37,13 +37,21 @@ extern char *choose_tmpdir PARAMS ((void));\n #define TEMP_FILE \"ccXXXXXX\"\n #define TEMP_FILE_LEN (sizeof(TEMP_FILE) - 1)\n \n-/* Return a prefix for temporary file names or NULL if unable to find one.\n-   The current directory is chosen if all else fails so the program is\n-   exited if a temporary directory can't be found (mktemp fails).\n-   The buffer for the result is obtained with xmalloc. \n+/*\n \n-   This function is provided for backwards compatability only.  It use\n-   is not recommended.  */\n+@deftypefn Extension char* choose_temp_base ()\n+\n+Return a prefix for temporary file names or @code{NULL} if unable to\n+find one.  The current directory is chosen if all else fails so the\n+program is exited if a temporary directory can't be found (@code{mktemp}\n+fails).  The buffer for the result is obtained with @code{xmalloc}.\n+\n+This function is provided for backwards compatability only.  Its use is\n+not recommended.\n+\n+@end deftypefn\n+\n+*/\n \n char *\n choose_temp_base ()"}, {"sha": "a7e642880fa20d88535b25df0ae68dffb292b5ad", "filename": "libiberty/concat.c", "status": "modified", "additions": 30, "deletions": 16, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aac04c15d761628889f138b16219bce27f25bbb2/libiberty%2Fconcat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aac04c15d761628889f138b16219bce27f25bbb2/libiberty%2Fconcat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fconcat.c?ref=aac04c15d761628889f138b16219bce27f25bbb2", "patch": "@@ -21,24 +21,14 @@ Boston, MA 02111-1307, USA.  */\n \n /*\n \n-NAME\n+@deftypefn Extension char* concat (char *@var{s1}, char *@var{s2}, ..., @code{NULL})\n \n-\tconcat -- concatenate a variable number of strings\n+Concatenate zero or more of strings and return the result in freshly\n+xmalloc'd memory.  Returns @code{NULL} if insufficient memory is\n+available.  The argument list is terminated by the first @code{NULL}\n+pointer encountered.  Pointers to empty strings are ignored.\n \n-SYNOPSIS\n-\n-\t#include <varargs.h>\n-\n-\tchar *concat (s1, s2, s3, ..., NULL)\n-\n-DESCRIPTION\n-\n-\tConcatenate a variable number of strings and return the result\n-\tin freshly malloc'd memory.\n-\n-\tReturns NULL if insufficient memory is available.  The argument\n-\tlist is terminated by the first NULL pointer encountered.  Pointers\n-\tto empty strings are ignored.\n+@end deftypefn\n \n NOTES\n \n@@ -50,6 +40,7 @@ NOTES\n \tdeal with low memory situations itself, it should supply an xmalloc\n \tthat just directly invokes malloc and blindly returns whatever\n \tmalloc returns.\n+\n */\n \n \n@@ -114,6 +105,8 @@ vconcat_copy (dst, first, args)\n   return dst;\n }\n \n+/* @undocumented concat_length */\n+\n unsigned long\n concat_length VPARAMS ((const char *first, ...))\n {\n@@ -127,6 +120,8 @@ concat_length VPARAMS ((const char *first, ...))\n   return length;\n }\n \n+/* @undocumented concat_copy */\n+\n char *\n concat_copy VPARAMS ((char *dst, const char *first, ...))\n {\n@@ -144,6 +139,8 @@ concat_copy VPARAMS ((char *dst, const char *first, ...))\n \n char *libiberty_concat_ptr;\n \n+/* @undocumented concat_copy2 */\n+\n char *\n concat_copy2 VPARAMS ((const char *first, ...))\n {\n@@ -175,6 +172,23 @@ concat VPARAMS ((const char *first, ...))\n   return newstr;\n }\n \n+/*\n+\n+@deftypefn Extension char* reconcat (char *@var{optr}, char *@var{s1}, ..., @code{NULL})\n+\n+Same as @code{concat}, except that if @var{optr} is not @code{NULL} it\n+is freed after the string is created.  This is intended to be useful\n+when you're extending an existing string or building up a string in a\n+loop:\n+\n+@example\n+  str = reconcat (str, \"pre-\", str, NULL);\n+@end example\n+\n+@end deftypefn\n+\n+*/\n+\n char *\n reconcat VPARAMS ((char *optr, const char *first, ...))\n {"}, {"sha": "979c214d5d4d3e835f72b04ad9376de944ee0bc2", "filename": "libiberty/fdmatch.c", "status": "modified", "additions": 13, "deletions": 19, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aac04c15d761628889f138b16219bce27f25bbb2/libiberty%2Ffdmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aac04c15d761628889f138b16219bce27f25bbb2/libiberty%2Ffdmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Ffdmatch.c?ref=aac04c15d761628889f138b16219bce27f25bbb2", "patch": "@@ -20,25 +20,19 @@ Boston, MA 02111-1307, USA.  */\n \n /*\n \n-NAME\n-\n-\tfdmatch -- see if two file descriptors refer to same file\n-\n-SYNOPSIS\n-\n-\tint fdmatch (int fd1, int fd2)\n-\n-DESCRIPTION\n-\n-\tCheck to see if two open file descriptors refer to the same file.\n-\tThis is useful, for example, when we have an open file descriptor\n-\tfor an unnamed file, and the name of a file that we believe to \n-\tcorrespond to that fd.  This can happen when we are exec'd with\n-\tan already open file (stdout for example) or from the SVR4 /proc\n-\tcalls that return open file descriptors for mapped address spaces.\n-\tAll we have to do is open the file by name and check the two file\n-\tdescriptors for a match, which is done by comparing major&minor\n-\tdevice numbers and inode numbers.\n+@deftypefn Extension int fdmatch (int @var{fd1}, int @var{fd2})\n+\n+Check to see if two open file descriptors refer to the same file.\n+This is useful, for example, when we have an open file descriptor for\n+an unnamed file, and the name of a file that we believe to correspond\n+to that fd.  This can happen when we are exec'd with an already open\n+file (@code{stdout} for example) or from the SVR4 @file{/proc} calls\n+that return open file descriptors for mapped address spaces.  All we\n+have to do is open the file by name and check the two file descriptors\n+for a match, which is done by comparing major and minor device numbers\n+and inode numbers.\n+\n+@end deftypefn\n \n BUGS\n "}, {"sha": "4a92c828a819b2ceb7a9fa6affe5b69fbad0cfbb", "filename": "libiberty/ffs.c", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aac04c15d761628889f138b16219bce27f25bbb2/libiberty%2Fffs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aac04c15d761628889f138b16219bce27f25bbb2/libiberty%2Fffs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fffs.c?ref=aac04c15d761628889f138b16219bce27f25bbb2", "patch": "@@ -1,14 +1,12 @@\n /* ffs -- Find the first bit set in the parameter\n \n-NAME\n-\tffs -- Find the first bit set in the parameter\n+@deftypefn Supplemental int ffs (int @var{valu})\n \n-SYNOPSIS\n-\tint ffs (int valu)\n+Find the first (least significant) bit set in @var{valu}. Bits are\n+numbered from right to left, starting with bit 1 (corresponding to the\n+value 1).  If @var{valu} is zero, zero is returned.\n \n-DESCRIPTION\n-\tFind the first bit set in the parameter. Bits are numbered from\n-\tright to left, starting with bit 1.\n+@end deftypefn\n \n */\n "}, {"sha": "dfdac2406aa55cf5c70645642a4fbb3f8c1a1f43", "filename": "libiberty/fnmatch.txh", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aac04c15d761628889f138b16219bce27f25bbb2/libiberty%2Ffnmatch.txh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aac04c15d761628889f138b16219bce27f25bbb2/libiberty%2Ffnmatch.txh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Ffnmatch.txh?ref=aac04c15d761628889f138b16219bce27f25bbb2", "patch": "@@ -0,0 +1,48 @@\n+@deftypefn Replacement int fnmatch (const char *@var{pattern}, const char *@var{string}, int @var{flags})\n+\n+Matches @var{string} against @var{pattern}, returning zero if it\n+matches, @code{FNM_NOMATCH} if not.  @var{pattern} may contain the\n+wildcards @code{?} to match any one character, @code{*} to match any\n+zero or more characters, or a set of alternate characters in square\n+brackets, like @samp{[a-gt8]}, which match one character (@code{a}\n+through @code{g}, or @code{t}, or @code{8}, in this example) if that one\n+character is in the set.  A set may be inverted (i.e. match anything\n+except what's in the set) by giving @code{^} or @code{!} as the first\n+character in the set.  To include those characters in the set, list them\n+as anything other than the first character of the set.  To include a\n+dash in the set, list it last in the set.  A backslash character makes\n+the following character not special, so for example you could match\n+against a literal asterisk with @samp{\\*}.  To match a literal\n+backslash, use @samp{\\\\}.\n+\n+@code{flags} controls various aspects of the matching process, and is a\n+boolean OR of zero or more of the following values (defined in\n+@code{<fnmatch.h>}:\n+\n+@table @code\n+\n+@item FNM_PATHNAME\n+@itemx FNM_FILE_NAME\n+@var{string} is assumed to be a path name.  No wildcard will ever match\n+@code{/}.\n+\n+@item FNM_NOESCAPE\n+Do not interpret backslashes as quoting the following special character.\n+\n+@item FNM_PERIOD\n+A leading period (at the beginning of @var{string}, or if\n+@code{FNM_PATHNAME} after a slash) is not matched by @code{*} or\n+@code{?} but must be matched explicitly.\n+\n+@item FNM_LEADING_DIR\n+Means that @var{string} also matches @var{pattern} if some initial part\n+of @var{string} matches, and is followed by @code{/} and zero or more\n+characters.  For example, @samp{foo*} would match either @samp{foobar}\n+or @samp{foobar/grill}.\n+\n+@item FNM_CASEFOLD\n+Ignores case when performing the comparison.\n+\n+@end table\n+\n+@end deftypefn"}, {"sha": "6668ce35e48fa303d72e5958a3b2d3667aa02a64", "filename": "libiberty/functions.texi", "status": "modified", "additions": 428, "deletions": 7, "changes": 435, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aac04c15d761628889f138b16219bce27f25bbb2/libiberty%2Ffunctions.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aac04c15d761628889f138b16219bce27f25bbb2/libiberty%2Ffunctions.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Ffunctions.texi?ref=aac04c15d761628889f138b16219bce27f25bbb2", "patch": "@@ -21,6 +21,19 @@ the possibility of a GCC built-in function.\n \n @end deftypefn\n \n+@c asprintf.c:33\n+@deftypefn Extension int asprintf (char **@var{resptr}, char *@var{format}, ...)\n+\n+Like @code{sprintf}, but instead of passing a pointer to a buffer, you\n+pass a pointer to a pointer.  This function will compute the size of\n+the buffer needed, allocate memory with @code{malloc}, and store a\n+pointer to the allocated memory in @code{*@var{resptr}}.  The value\n+returned is the same as @code{sprintf} would return.  If memory could\n+not be allocated, zero is returned and @code{NULL} is stored in\n+@code{*@var{resptr}}.\n+\n+@end deftypefn\n+\n @c atexit.c:6\n @deftypefn Supplemental int atexit (void (*@var{f})())\n \n@@ -69,6 +82,31 @@ is respectively less than, matching, or greater than the array member.\n \n @end deftypefn\n \n+@c argv.c:139\n+@deftypefn Extension char** buildargv (char *@var{sp})\n+\n+Given a pointer to a string, parse the string extracting fields\n+separated by whitespace and optionally enclosed within either single\n+or double quotes (which are stripped off), and build a vector of\n+pointers to copies of the string for each field.  The input string\n+remains unchanged.  The last element of the vector is followed by a\n+@code{NULL} element.\n+\n+All of the memory for the pointer array and copies of the string\n+is obtained from @code{malloc}.  All of the memory can be returned to the\n+system with the single function call @code{freeargv}, which takes the\n+returned result of @code{buildargv}, as it's argument.\n+\n+Returns a pointer to the argument vector if successful. Returns\n+@code{NULL} if @var{sp} is @code{NULL} or if there is insufficient\n+memory to complete building the argument vector.\n+\n+If the input is a null string (as opposed to a @code{NULL} pointer),\n+then buildarg returns an argument vector that has one arg, a null\n+string.\n+\n+@end deftypefn\n+\n @c bzero.c:6\n @deftypefn Supplemental void bzero (char *@var{mem}, int @var{count})\n \n@@ -85,6 +123,27 @@ Uses @code{malloc} to allocate storage for @var{nelem} objects of\n \n @end deftypefn\n \n+@c choose-temp.c:42\n+@deftypefn Extension char* choose_temp_base ()\n+\n+Return a prefix for temporary file names or @code{NULL} if unable to\n+find one.  The current directory is chosen if all else fails so the\n+program is exited if a temporary directory can't be found (@code{mktemp}\n+fails).  The buffer for the result is obtained with @code{xmalloc}.\n+\n+This function is provided for backwards compatability only.  Its use is\n+not recommended.\n+\n+@end deftypefn\n+\n+@c make-temp-file.c:88\n+@deftypefn Replacement char* choose_tmpdir ()\n+\n+Returns a pointer to a directory path suitable for creating temporary\n+files in.\n+\n+@end deftypefn\n+\n @c clock.c:27\n @deftypefn Supplemental long clock (void)\n \n@@ -94,8 +153,29 @@ number of seconds used.\n \n @end deftypefn\n \n+@c concat.c:24\n+@deftypefn Extension char* concat (char *@var{s1}, char *@var{s2}, ..., @code{NULL})\n+\n+Concatenate zero or more of strings and return the result in freshly\n+xmalloc'd memory.  Returns @code{NULL} if insufficient memory is\n+available.  The argument list is terminated by the first @code{NULL}\n+pointer encountered.  Pointers to empty strings are ignored.\n+\n+@end deftypefn\n+\n+@c argv.c:65\n+@deftypefn Extension char** dupargv (char **@var{vector})\n+\n+Duplicate an argument vector.  Simply scans through @var{vector},\n+duplicating each argument until the terminating @code{NULL} is found.\n+Returns a pointer to the argument vector if successful. Returns\n+@code{NULL} if there is insufficient memory to complete building the\n+argument vector.\n+\n+@end deftypefn\n+\n @c strerror.c:566\n-@deftypefn Replacement int errno_max (void)\n+@deftypefn Extension int errno_max (void)\n \n Returns the maximum @code{errno} value for which a corresponding\n symbolic name or message is available.  Note that in the case where we\n@@ -112,6 +192,99 @@ symbolic name or message.\n \n @end deftypefn\n \n+@c fdmatch.c:23\n+@deftypefn Extension int fdmatch (int @var{fd1}, int @var{fd2})\n+\n+Check to see if two open file descriptors refer to the same file.\n+This is useful, for example, when we have an open file descriptor for\n+an unnamed file, and the name of a file that we believe to correspond\n+to that fd.  This can happen when we are exec'd with an already open\n+file (@code{stdout} for example) or from the SVR4 @file{/proc} calls\n+that return open file descriptors for mapped address spaces.  All we\n+have to do is open the file by name and check the two file descriptors\n+for a match, which is done by comparing major and minor device numbers\n+and inode numbers.\n+\n+@end deftypefn\n+\n+@c ffs.c:3\n+@deftypefn Supplemental int ffs (int @var{valu})\n+\n+Find the first (least significant) bit set in @var{valu}. Bits are\n+numbered from right to left, starting with bit 1 (corresponding to the\n+value 1).  If @var{valu} is zero, zero is returned.\n+\n+@end deftypefn\n+\n+@c fnmatch.txh:1\n+@deftypefn Replacement int fnmatch (const char *@var{pattern}, const char *@var{string}, int @var{flags})\n+\n+Matches @var{string} against @var{pattern}, returning zero if it\n+matches, @code{FNM_NOMATCH} if not.  @var{pattern} may contain the\n+wildcards @code{?} to match any one character, @code{*} to match any\n+zero or more characters, or a set of alternate characters in square\n+brackets, like @samp{[a-gt8]}, which match one character (@code{a}\n+through @code{g}, or @code{t}, or @code{8}, in this example) if that one\n+character is in the set.  A set may be inverted (i.e. match anything\n+except what's in the set) by giving @code{^} or @code{!} as the first\n+character in the set.  To include those characters in the set, list them\n+as anything other than the first character of the set.  To include a\n+dash in the set, list it last in the set.  A backslash character makes\n+the following character not special, so for example you could match\n+against a literal asterisk with @samp{\\*}.  To match a literal\n+backslash, use @samp{\\\\}.\n+\n+@code{flags} controls various aspects of the matching process, and is a\n+boolean OR of zero or more of the following values (defined in\n+@code{<fnmatch.h>}:\n+\n+@table @code\n+\n+@item FNM_PATHNAME\n+@itemx FNM_FILE_NAME\n+@var{string} is assumed to be a path name.  No wildcard will ever match\n+@code{/}.\n+\n+@item FNM_NOESCAPE\n+Do not interpret backslashes as quoting the following special character.\n+\n+@item FNM_PERIOD\n+A leading period (at the beginning of @var{string}, or if\n+@code{FNM_PATHNAME} after a slash) is not matched by @code{*} or\n+@code{?} but must be matched explicitly.\n+\n+@item FNM_LEADING_DIR\n+Means that @var{string} also matches @var{pattern} if some initial part\n+of @var{string} matches, and is followed by @code{/} and zero or more\n+characters.  For example, @samp{foo*} would match either @samp{foobar}\n+or @samp{foobar/grill}.\n+\n+@item FNM_CASEFOLD\n+Ignores case when performing the comparison.\n+\n+@end table\n+\n+@end deftypefn\n+\n+@c argv.c:111\n+@deftypefn Extension void freeargv (char **@var{vector})\n+\n+Free an argument vector that was built using @code{buildargv}.  Simply\n+scans through @var{vector}, freeing the memory for each argument until\n+the terminating @code{NULL} is found, and then frees @var{vector}\n+itself.\n+\n+@end deftypefn\n+\n+@c getruntime.c:78\n+@deftypefn Replacement long get_run_time ()\n+\n+Returns the time used so far, in microseconds.  If possible, this is\n+the time used by this process, else it is the elapsed time since the\n+process started.\n+\n+@end deftypefn\n+\n @c getcwd.c:6\n @deftypefn Supplemental char* getcwd (char *@var{pathname}, int @var{len})\n \n@@ -153,6 +326,52 @@ deprecated in new programs in favor of @code{strchr}.\n \n @end deftypefn\n \n+@c insque.c:6\n+@deftypefn Supplemental void insque (struct qelem *@var{elem}, struct qelem *@var{pred})\n+@deftypefnx Supplemental void remque (struct qelem *@var{elem})\n+\n+Routines to manipulate queues built from doubly linked lists.  The\n+@code{insque} routine inserts @var{elem} in the queue immediately\n+after @var{pred}.  The @code{remque} routine removes @var{elem} from\n+its containing queue.  These routines expect to be passed pointers to\n+structures which have as their first members a forward pointer and a\n+back pointer, like this prototype (although no prototype is provided):\n+\n+@example\n+struct qelem @{\n+  struct qelem *q_forw;\n+  struct qelem *q_back;\n+  char q_data[];\n+@};\n+@end example\n+\n+@end deftypefn\n+\n+@c lbasename.c:23\n+@deftypefn Replacement {const char*} lbasename (const char *@var{name})\n+\n+Given a pointer to a string containing a typical pathname\n+(@samp{/usr/src/cmd/ls/ls.c} for example), returns a pointer to the\n+last component of the pathname (@samp{ls.c} in this case).  The\n+returned pointer is guaranteed to lie within the original\n+string.  This latter fact is not true of many vendor C\n+libraries, which return special strings or modify the passed\n+strings for particular input.\n+\n+In particular, the empty string returns the same empty string,\n+and a path ending in @code{/} returns the empty string after it.\n+\n+@end deftypefn\n+\n+@c make-temp-file.c:138\n+@deftypefn Replacement char* make_temp_file (const char *@var{suffix})\n+\n+Return a temporary file name (as a string) or @code{NULL} if unable to\n+create one.  @var{suffix} is a suffix to append to the file name.  The\n+string is malloced, and the temporary file has been created.\n+\n+@end deftypefn\n+\n @c memchr.c:3\n @deftypefn Supplemental void* memchr (const void *@var{s}, int @var{c}, size_t @var{n})\n \n@@ -201,6 +420,71 @@ Sets the first @var{count} bytes of @var{s} to the constant byte\n \n @end deftypefn\n \n+@c mkstemps.c:54\n+@deftypefn Replacement int mkstemps (char *@var{template}, int @var{suffix_len})\n+\n+Generate a unique temporary file name from @var{template}.\n+@var{template} has the form:\n+\n+@example\n+   <path>/ccXXXXXX<suffix>\n+@end example\n+\n+@var{suffix_len} tells us how long <suffix> is (it can be zero\n+length).  The last six characters of @var{template} before <suffix>\n+must be @code{XXXXXX}; they are replaced with a string that makes the\n+filename unique.  Returns a file descriptor open on the file for\n+reading and writing.\n+\n+@end deftypefn\n+\n+@c pexecute.c:67\n+@deftypefn Extension int pexecute (const char *@var{program}, char * const *@var{argv}, const char *@var{this_pname}, const char *@var{temp_base}, char **@var{errmsg_fmt}, char **@var{errmsg_arg}, int flags)\n+\n+Executes a program.\n+\n+@var{program} and @var{argv} are the arguments to\n+@code{execv}/@code{execvp}.\n+\n+@var{this_pname} is name of the calling program (i.e. @code{argv[0]}).\n+\n+@var{temp_base} is the path name, sans suffix, of a temporary file to\n+use if needed.  This is currently only needed for MS-DOS ports that\n+don't use @code{go32} (do any still exist?).  Ports that don't need it\n+can pass @code{NULL}.\n+\n+(@var{flags} & @code{PEXECUTE_SEARCH}) is non-zero if @code{$PATH} should be searched\n+(??? It's not clear that GCC passes this flag correctly). (@var{flags} &\n+@code{PEXECUTE_FIRST}) is nonzero for the first process in chain.\n+(@var{flags} & @code{PEXECUTE_FIRST}) is nonzero for the last process\n+in chain.  The first/last flags could be simplified to only mark the\n+last of a chain of processes but that requires the caller to always\n+mark the last one (and not give up early if some error occurs).\n+It's more robust to require the caller to mark both ends of the chain.\n+\n+The result is the pid on systems like Unix where we\n+@code{fork}/@code{exec} and on systems like WIN32 and OS/2 where we\n+use @code{spawn}.  It is up to the caller to wait for the child.\n+\n+The result is the WEXITSTATUS on systems like MS-DOS where we\n+@code{spawn} and wait for the child here.\n+\n+Upon failure, @var{errmsg_fmt} and @var{errmsg_arg} are set to the\n+text of the error message with an optional argument (if not needed,\n+@var{errmsg_arg} is set to @code{NULL}), and -1 is returned.\n+@code{errno} is available to the caller to use.\n+\n+@end deftypefn\n+\n+@c strsignal.c:547\n+@deftypefn Supplemental void psignal (unsigned @var{signo}, char *@var{message})\n+\n+Print @var{message} to the standard error, followed by a colon,\n+followed by the description of the signal specified by @var{signo},\n+followed by a newline.\n+\n+@end deftypefn\n+\n @c putenv.c:21\n @deftypefn Supplemental int putenv (const char *@var{string})\n \n@@ -211,6 +495,53 @@ name is unset/removed.\n \n @end deftypefn\n \n+@c pexecute.c:104\n+@deftypefn Extension int pwait (int @var{pid}, int *@var{status}, int @var{flags})\n+\n+Waits for a program started by @code{pexecute} to finish.\n+\n+@var{pid} is the process id of the task to wait for. @var{status} is\n+the `status' argument to wait. @var{flags} is currently unused (allows\n+future enhancement without breaking upward compatibility).  Pass 0 for now.\n+\n+The result is the pid of the child reaped, or -1 for failure\n+(@code{errno} says why).\n+\n+On systems that don't support waiting for a particular child, @var{pid} is\n+ignored.  On systems like MS-DOS that don't really multitask @code{pwait}\n+is just a mechanism to provide a consistent interface for the caller.\n+\n+@end deftypefn\n+\n+@c random.c:39\n+@deftypefn Supplement {long int} random ()\n+@deftypefnx Supplement void srandom (unsigned int @var{seed})\n+@deftypefnx Supplement void* initstate (unsigned int @var{seed}, void *@var{arg_state}, unsigned long @var{n})\n+@deftypefnx Supplement void* setstate (void *@var{arg_state})\n+\n+Random number functions.  @code{random} returns a random number in the\n+range @code{0..LONG_MAX}.  @code{srandom} initializes the random\n+number generator to some starting point determined by @var{seed}\n+(else, the values returned by @code{random} are always the same for each\n+run of the program).  @code{initstate} and @code{setstate} allow fine-grain\n+control over the state of the random number generator.\n+\n+@end deftypefn\n+\n+@c concat.c:177\n+@deftypefn Extension char* reconcat (char *@var{optr}, char *@var{s1}, ..., @code{NULL})\n+\n+Same as @code{concat}, except that if @var{optr} is not @code{NULL} it\n+is freed after the string is created.  This is intended to be useful\n+when you're extending an existing string or building up a string in a\n+loop:\n+\n+@example\n+  str = reconcat (str, \"pre-\", str, NULL);\n+@end example\n+\n+@end deftypefn\n+\n @c rename.c:6\n @deftypefn Supplemental int rename (const char *@var{old}, const char *@var{new})\n \n@@ -240,6 +571,24 @@ environment.  This implementation is not safe for multithreaded code.\n \n @end deftypefn\n \n+@c strsignal.c:353\n+@deftypefn Extension int signo_max ()\n+\n+Returns the maximum signal value for which a corresponding symbolic\n+name or message is available.  Note that in the case where we use the\n+@code{sys_siglist} supplied by the system, it is possible for there to\n+be more symbolic names than messages, or vice versa.  In fact, the\n+manual page for @code{psignal(3b)} explicitly warns that one should\n+check the size of the table (@code{NSIG}) before indexing it, since\n+new signal codes may be added to the system before they are added to\n+the table.  Thus @code{NSIG} might be smaller than value implied by\n+the largest signo value defined in @code{<signal.h>}.\n+\n+We return the maximum value that can be used to obtain a meaningful\n+symbolic name or message.\n+\n+@end deftypefn\n+\n @c sigsetmask.c:8\n @deftypefn Supplemental int sigsetmask (int @var{set})\n \n@@ -249,6 +598,15 @@ be the value @code{1}).\n \n @end deftypefn\n \n+@c spaces.c:22\n+@deftypefn Extension char* spaces (int @var{count})\n+\n+Returns a pointer to a memory region filled with the specified\n+number of spaces and null terminated.  The returned pointer is\n+valid until at least the next call.\n+\n+@end deftypefn\n+\n @c strcasecmp.c:15\n @deftypefn Supplemental int strcasecmp (const char *@var{s1}, const char *@var{s2})\n \n@@ -274,15 +632,15 @@ Returns a pointer to a copy of @var{s} in memory obtained from\n @end deftypefn\n \n @c strerror.c:670\n-@deftypefn Replacement const char* strerrno (int @var{errnum})\n+@deftypefn Replacement {const char*} strerrno (int @var{errnum})\n \n Given an error number returned from a system call (typically returned\n in @code{errno}), returns a pointer to a string containing the\n symbolic name of that error number, as found in @code{<errno.h>}.\n \n If the supplied error number is within the valid range of indices for\n symbolic names, but no name is available for the particular error\n-number, then returns the string @samp{\"Error @var{num}\"}, where @var{num}\n+number, then returns the string @samp{Error @var{num}}, where @var{num}\n is the error number.\n \n If the supplied error number is not within the range of valid\n@@ -294,7 +652,7 @@ valid until the next call to @code{strerrno}.\n @end deftypefn\n \n @c strerror.c:602\n-@deftypefn Replacement char* strerror (int @var{errnoval})\n+@deftypefn Supplemental char* strerror (int @var{errnoval})\n \n Maps an @code{errno} number to an error message string, the contents\n of which are implementation defined.  On systems which have the\n@@ -303,7 +661,7 @@ strings will be the same as the ones used by @code{perror}.\n \n If the supplied error number is within the valid range of indices for\n the @code{sys_errlist}, but no message is available for the particular\n-error number, then returns the string @samp{\"Error @var{num}\"}, where\n+error number, then returns the string @samp{Error @var{num}}, where\n @var{num} is the error number.\n \n If the supplied error number is not a valid index into\n@@ -338,6 +696,46 @@ null character, the results are undefined.\n \n @end deftypefn\n \n+@c strsignal.c:388\n+@deftypefn Supplemental {const char *} strsignal (int @var{signo})\n+\n+Maps an signal number to an signal message string, the contents of\n+which are implementation defined.  On systems which have the external\n+variable @code{sys_siglist}, these strings will be the same as the\n+ones used by @code{psignal()}.\n+\n+If the supplied signal number is within the valid range of indices for\n+the @code{sys_siglist}, but no message is available for the particular\n+signal number, then returns the string @samp{Signal @var{num}}, where\n+@var{num} is the signal number.\n+\n+If the supplied signal number is not a valid index into\n+@code{sys_siglist}, returns @code{NULL}.\n+\n+The returned string is only guaranteed to be valid only until the next\n+call to @code{strsignal}.\n+\n+@end deftypefn\n+\n+@c strsignal.c:452\n+@deftypefn Extension {const char*} strsigno (int @var{signo})\n+\n+Given an signal number, returns a pointer to a string containing the\n+symbolic name of that signal number, as found in @code{<signal.h>}.\n+\n+If the supplied signal number is within the valid range of indices for\n+symbolic names, but no name is available for the particular signal\n+number, then returns the string @samp{Signal @var{num}}, where\n+@var{num} is the signal number.\n+\n+If the supplied signal number is not within the range of valid\n+indices, then returns @code{NULL}.\n+\n+The contents of the location pointed to are only guaranteed to be\n+valid until the next call to @code{strsigno}.\n+\n+@end deftypefn\n+\n @c strstr.c:6\n @deftypefn Supplemental char* strstr (const char *@var{string}, const char *@var{sub})\n \n@@ -362,7 +760,7 @@ the location referenced by @var{endptr}.\n @end deftypefn\n \n @c strerror.c:730\n-@deftypefn Replacement int strtoerrno (const char *@var{name})\n+@deftypefn Extension int strtoerrno (const char *@var{name})\n \n Given the symbolic name of a error number (e.g., @code{EACCES}), map it\n to an errno value.  If no translation is found, returns 0.\n@@ -371,6 +769,7 @@ to an errno value.  If no translation is found, returns 0.\n \n @c strtol.c:33\n @deftypefn Supplemental {long int} strtol (const char *@var{string}, char **@var{endptr}, int @var{base})\n+@deftypefnx Supplemental {unsigned long int} strtoul (const char *@var{string}, char **@var{endptr}, int @var{base})\n \n The @code{strtol} function converts the string in @var{string} to a\n long integer value according to the given @var{base}, which must be\n@@ -379,7 +778,16 @@ is 0, @code{strtol} will look for the prefixes @code{0} and @code{0x}\n to indicate bases 8 and 16, respectively, else default to base 10.\n When the base is 16 (either explicitly or implicitly), a prefix of\n @code{0x} is allowed.  The handling of @var{endptr} is as that of\n-@code{strtod} above.\n+@code{strtod} above.  The @code{strtoul} function is the same, except\n+that the converted value is unsigned.\n+\n+@end deftypefn\n+\n+@c strsignal.c:507\n+@deftypefn Extension int strtosigno (const char *@var{name})\n+\n+Given the symbolic name of a signal, map it to a signal number.  If no\n+translation is found, returns 0.\n \n @end deftypefn\n \n@@ -394,6 +802,19 @@ not be used in new projects.  Use @code{mkstemp} instead.\n \n @end deftypefn\n \n+@c vasprintf.c:48\n+@deftypefn Extension int vasprintf (char **@var{resptr}, char *@var{format}, va_list @var{args})\n+\n+Like @code{vsprintf}, but instead of passing a pointer to a buffer,\n+you pass a pointer to a pointer.  This function will compute the size\n+of the buffer needed, allocate memory with @code{malloc}, and store a\n+pointer to the allocated memory in @code{*@var{resptr}}.  The value\n+returned is the same as @code{vsprintf} would return.  If memory could\n+not be allocated, zero is returned and @code{NULL} is stored in\n+@code{*@var{resptr}}.\n+\n+@end deftypefn\n+\n @c vfork.c:6\n @deftypefn Supplemental int vfork (void)\n "}, {"sha": "f610c940248eeca1349b58e8a4f3b28fff45aa42", "filename": "libiberty/getruntime.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aac04c15d761628889f138b16219bce27f25bbb2/libiberty%2Fgetruntime.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aac04c15d761628889f138b16219bce27f25bbb2/libiberty%2Fgetruntime.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fgetruntime.c?ref=aac04c15d761628889f138b16219bce27f25bbb2", "patch": "@@ -73,6 +73,18 @@ Boston, MA 02111-1307, USA.  */\n #endif\n #endif\n \n+/*\n+\n+@deftypefn Replacement long get_run_time ()\n+\n+Returns the time used so far, in microseconds.  If possible, this is\n+the time used by this process, else it is the elapsed time since the\n+process started.\n+\n+@end deftypefn\n+\n+*/\n+\n long\n get_run_time ()\n {"}, {"sha": "c0c1180d42115eb727dd35b7a687c635388c6c5b", "filename": "libiberty/insque.c", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aac04c15d761628889f138b16219bce27f25bbb2/libiberty%2Finsque.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aac04c15d761628889f138b16219bce27f25bbb2/libiberty%2Finsque.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Finsque.c?ref=aac04c15d761628889f138b16219bce27f25bbb2", "patch": "@@ -2,24 +2,27 @@\n    This file is in the public domain.  */\n \n /*\n-NAME\n-\tinsque, remque -- insert, remove an element from a queue\n \n-SYNOPSIS\n-\tstruct qelem {\n-\t  struct qelem *q_forw;\n-\t  struct qelem *q_back;\n-\t  char q_data[];\n-\t};\n+@deftypefn Supplemental void insque (struct qelem *@var{elem}, struct qelem *@var{pred})\n+@deftypefnx Supplemental void remque (struct qelem *@var{elem})\n \n-\tvoid insque (struct qelem *elem, struct qelem *pred)\n+Routines to manipulate queues built from doubly linked lists.  The\n+@code{insque} routine inserts @var{elem} in the queue immediately\n+after @var{pred}.  The @code{remque} routine removes @var{elem} from\n+its containing queue.  These routines expect to be passed pointers to\n+structures which have as their first members a forward pointer and a\n+back pointer, like this prototype (although no prototype is provided):\n \n-\tvoid remque (struct qelem *elem)\n+@example\n+struct qelem @{\n+  struct qelem *q_forw;\n+  struct qelem *q_back;\n+  char q_data[];\n+@};\n+@end example\n+\n+@end deftypefn\n \n-DESCRIPTION\n-\tRoutines to manipulate queues built from doubly linked lists.\n-\tThe insque routine inserts ELEM in the queue immediately after\n-\tPRED.  The remque routine removes ELEM from its containing queue.\n */\n \n "}, {"sha": "cea0253887b89a34690f76c65fa8be3f7e59a79f", "filename": "libiberty/lbasename.c", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aac04c15d761628889f138b16219bce27f25bbb2/libiberty%2Flbasename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aac04c15d761628889f138b16219bce27f25bbb2/libiberty%2Flbasename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Flbasename.c?ref=aac04c15d761628889f138b16219bce27f25bbb2", "patch": "@@ -19,23 +19,22 @@ not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n /*\n-NAME\n-\tlbasename -- return pointer to last component of a pathname\n-\n-SYNOPSIS\n-\tconst char *lbasename (const char *name)\n-\n-DESCRIPTION\n-\tGiven a pointer to a string containing a typical pathname\n-\t(/usr/src/cmd/ls/ls.c for example), returns a pointer to the\n-\tlast component of the pathname (\"ls.c\" in this case).  The\n-\treturned pointer is guaranteed to lie within the original\n-\tstring.  This latter fact is not true of many vendor C\n-\tlibraries, which return special strings or modify the passed\n-\tstrings for particular input.\n-\n-\tIn particular, the empty string returns the same empty string,\n-\tand a path ending in '/' returns the empty string after it.\n+\n+@deftypefn Replacement {const char*} lbasename (const char *@var{name})\n+\n+Given a pointer to a string containing a typical pathname\n+(@samp{/usr/src/cmd/ls/ls.c} for example), returns a pointer to the\n+last component of the pathname (@samp{ls.c} in this case).  The\n+returned pointer is guaranteed to lie within the original\n+string.  This latter fact is not true of many vendor C\n+libraries, which return special strings or modify the passed\n+strings for particular input.\n+\n+In particular, the empty string returns the same empty string,\n+and a path ending in @code{/} returns the empty string after it.\n+\n+@end deftypefn\n+\n */\n \n #include \"ansidecl.h\""}, {"sha": "75b0c508cd910051a305f5a120a22526ef473b8c", "filename": "libiberty/maint-tool", "status": "modified", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aac04c15d761628889f138b16219bce27f25bbb2/libiberty%2Fmaint-tool", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aac04c15d761628889f138b16219bce27f25bbb2/libiberty%2Fmaint-tool", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fmaint-tool?ref=aac04c15d761628889f138b16219bce27f25bbb2", "patch": "@@ -35,9 +35,17 @@ if ($mode eq \"-s\") {\n }\n \n &missing() if $mode eq \"missing\";\n+&undoc() if $mode eq \"undoc\";\n \n exit 0;\n \n+format STDOUT =\n+^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~\n+$out\n+        ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~~\n+$out\n+.\n+\n ######################################################################\n \n sub missing {\n@@ -73,3 +81,100 @@ sub missing {\n \t}\n     }\n }\n+\n+######################################################################\n+\n+sub undoc {\n+\n+    opendir(S, $srcdir);\n+    while ($file = readdir S) {\n+\tif ($file =~ /\\.texi$/) {\n+\t    open(T, \"$srcdir/$file\");\n+\t    while (<T>) {\n+\t\tif (/^\\@deftype[^\\(]* ([^\\s\\(]+) *\\(/) {\n+\t\t    $documented{$1} = 1;\n+\t\t}\n+\t    }\n+\t    close(T);\n+\t}\n+\tif ($file =~ /\\.c$/) {\n+\t    open(C, \"$srcdir/$file\");\n+\t    while (<C>) {\n+\t\tif (/\\@undocumented (\\S+)/) {\n+\t\t    $documented{$1} = 1;\n+\t\t}\n+\t\tif (/^static /) {\n+\t\t    if (! /[\\(;]/) {\n+\t\t\ts/[\\r\\n]+$/ /;\n+\t\t\t$_ .= <C>;\n+\t\t    }\n+\t\t    while ($_ =~ /\\([^\\)]*$/) {\n+\t\t\ts/[\\r\\n]+$/ /;\n+\t\t\t$_ .= <C>;\n+\t\t    }\n+\t\t}\n+\t\ts/ VPARAMS([ \\(])/$1/;\n+\t\ts/PREFIX\\(([^\\)]*)\\)/byte_$1/;\n+\t\tif (/^static [^\\(]* ([^\\s\\(]+) *\\(.*\\)$/) {\n+\t\t    $documented{$1} = 1;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+    closedir(D);\n+\n+    # $out = join(' ', sort keys %documented);\n+    # write;\n+    # print \"\\n\";\n+\n+    system \"etags $srcdir/*.c $srcdir/../include/*.h\";\n+    open(TAGS, \"TAGS\");\n+    while (<TAGS>) {\n+\ts/[\\r\\n]+$//;\n+\tif (/^\\014$/) {\n+\t    $filename = <TAGS>;\n+\t    $filename =~ s/[\\r\\n]+$//;\n+\t    $filename =~ s/,\\d+$//;\n+\t    $filename =~ s@.*[/\\\\]@@;\n+\t    next;\n+\t}\n+\tif ($filename =~ /\\.c$/ ) {\n+\t    next unless /^[_a-zA-Z]/;\n+\t} else {\n+\t    next unless /^\\# *define/;\n+\t    s/\\# *define *//;\n+\t}\n+\tnext if $filename =~ /mpw\\.c/;\n+\n+\ts/ VPARAMS//;\n+\ts/ *\\177.*//;\n+\ts/,$//;\n+\ts/DEFUN\\(//;\n+\ts/\\(//;\n+\n+\tnext if /^static /;\n+\tnext if /\\s/;\n+\tnext if /^_/;\n+\tnext if $documented{$_};\n+\tnext if /_H_?$/;\n+\n+\tif ($seen_in{$_} ne $filename) {\n+\t    $saw{$_} ++;\n+\t}\n+\t$seen_in{$_} = $filename;\n+    }\n+\n+    for $k (keys %saw) {\n+\tdelete $saw{$k} if $saw{$k} > 1;\n+    }\n+\n+    for $k (sort keys %saw) {\n+\t$fromfile{$seen_in{$k}} .= \" \" if $fromfile{$seen_in{$k}};\n+\t$fromfile{$seen_in{$k}} .= $k;\n+    }\n+\n+    for $f (sort keys %fromfile) {\n+\t$out = \"$f: $fromfile{$f}\";\n+\twrite;\n+    }\n+}"}, {"sha": "db4bd9e5e4a948f3282e5b535f1a753b1f6f1de2", "filename": "libiberty/make-temp-file.c", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aac04c15d761628889f138b16219bce27f25bbb2/libiberty%2Fmake-temp-file.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aac04c15d761628889f138b16219bce27f25bbb2/libiberty%2Fmake-temp-file.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fmake-temp-file.c?ref=aac04c15d761628889f138b16219bce27f25bbb2", "patch": "@@ -83,6 +83,17 @@ static const char vartmp[] =\n \n static char *memoized_tmpdir;\n \n+/*\n+\n+@deftypefn Replacement char* choose_tmpdir ()\n+\n+Returns a pointer to a directory path suitable for creating temporary\n+files in.\n+\n+@end deftypefn\n+\n+*/\n+\n char *\n choose_tmpdir ()\n {\n@@ -122,9 +133,17 @@ choose_tmpdir ()\n   return tmpdir;\n }\n \n-/* Return a temporary file name (as a string) or NULL if unable to create\n-   one.  SUFFIX is a suffix to append to the file name.  The string is\n-   malloced, and the temporary file has been created.  */\n+/*\n+\n+@deftypefn Replacement char* make_temp_file (const char *@var{suffix})\n+\n+Return a temporary file name (as a string) or @code{NULL} if unable to\n+create one.  @var{suffix} is a suffix to append to the file name.  The\n+string is malloced, and the temporary file has been created.\n+\n+@end deftypefn\n+\n+*/\n \n char *\n make_temp_file (suffix)"}, {"sha": "56b0baea77e13a6806e6185017186976cd27f736", "filename": "libiberty/mkstemps.c", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aac04c15d761628889f138b16219bce27f25bbb2/libiberty%2Fmkstemps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aac04c15d761628889f138b16219bce27f25bbb2/libiberty%2Fmkstemps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fmkstemps.c?ref=aac04c15d761628889f138b16219bce27f25bbb2", "patch": "@@ -49,18 +49,27 @@ typedef unsigned long gcc_uint64_t;\n #define TMP_MAX 16384\n #endif\n \n-/* Generate a unique temporary file name from TEMPLATE.\n+/*\n \n-   TEMPLATE has the form:\n+@deftypefn Replacement int mkstemps (char *@var{template}, int @var{suffix_len})\n \n+Generate a unique temporary file name from @var{template}.\n+@var{template} has the form:\n+\n+@example\n    <path>/ccXXXXXX<suffix>\n+@end example\n+\n+@var{suffix_len} tells us how long <suffix> is (it can be zero\n+length).  The last six characters of @var{template} before <suffix>\n+must be @code{XXXXXX}; they are replaced with a string that makes the\n+filename unique.  Returns a file descriptor open on the file for\n+reading and writing.\n \n-   SUFFIX_LEN tells us how long <suffix> is (it can be zero length).\n+@end deftypefn\n \n-   The last six characters of TEMPLATE before <suffix> must be \"XXXXXX\";\n-   they are replaced with a string that makes the filename unique.\n+*/\n \n-   Returns a file descriptor open on the file for reading and writing.  */\n int\n mkstemps (template, suffix_len)\n      char *template;"}, {"sha": "4a3fbeda8be9d2cd649e7347f3426f9a575121df", "filename": "libiberty/pexecute.c", "status": "modified", "additions": 47, "deletions": 34, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aac04c15d761628889f138b16219bce27f25bbb2/libiberty%2Fpexecute.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aac04c15d761628889f138b16219bce27f25bbb2/libiberty%2Fpexecute.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fpexecute.c?ref=aac04c15d761628889f138b16219bce27f25bbb2", "patch": "@@ -64,53 +64,66 @@ static char *install_error_msg = \"installation problem, cannot exec `%s'\";\n \n /* pexecute: execute a program.\n \n-   PROGRAM and ARGV are the arguments to execv/execvp.\n+@deftypefn Extension int pexecute (const char *@var{program}, char * const *@var{argv}, const char *@var{this_pname}, const char *@var{temp_base}, char **@var{errmsg_fmt}, char **@var{errmsg_arg}, int flags)\n \n-   THIS_PNAME is name of the calling program (i.e. argv[0]).\n+Executes a program.\n \n-   TEMP_BASE is the path name, sans suffix, of a temporary file to use\n-   if needed.  This is currently only needed for MSDOS ports that don't use\n-   GO32 (do any still exist?).  Ports that don't need it can pass NULL.\n+@var{program} and @var{argv} are the arguments to\n+@code{execv}/@code{execvp}.\n \n-   (FLAGS & PEXECUTE_SEARCH) is non-zero if $PATH should be searched\n-   (??? It's not clear that GCC passes this flag correctly).\n-   (FLAGS & PEXECUTE_FIRST) is nonzero for the first process in chain.\n-   (FLAGS & PEXECUTE_FIRST) is nonzero for the last process in chain.\n-   FIRST_LAST could be simplified to only mark the last of a chain of processes\n-   but that requires the caller to always mark the last one (and not give up\n-   early if some error occurs).  It's more robust to require the caller to\n-   mark both ends of the chain.\n+@var{this_pname} is name of the calling program (i.e. @code{argv[0]}).\n \n-   The result is the pid on systems like Unix where we fork/exec and on systems\n-   like WIN32 and OS2 where we use spawn.  It is up to the caller to wait for\n-   the child.\n+@var{temp_base} is the path name, sans suffix, of a temporary file to\n+use if needed.  This is currently only needed for MS-DOS ports that\n+don't use @code{go32} (do any still exist?).  Ports that don't need it\n+can pass @code{NULL}.\n \n-   The result is the WEXITSTATUS on systems like MSDOS where we spawn and wait\n-   for the child here.\n+(@var{flags} & @code{PEXECUTE_SEARCH}) is non-zero if @code{$PATH} should be searched\n+(??? It's not clear that GCC passes this flag correctly). (@var{flags} &\n+@code{PEXECUTE_FIRST}) is nonzero for the first process in chain.\n+(@var{flags} & @code{PEXECUTE_FIRST}) is nonzero for the last process\n+in chain.  The first/last flags could be simplified to only mark the\n+last of a chain of processes but that requires the caller to always\n+mark the last one (and not give up early if some error occurs).\n+It's more robust to require the caller to mark both ends of the chain.\n \n-   Upon failure, ERRMSG_FMT and ERRMSG_ARG are set to the text of the error\n-   message with an optional argument (if not needed, ERRMSG_ARG is set to\n-   NULL), and -1 is returned.  `errno' is available to the caller to use.\n+The result is the pid on systems like Unix where we\n+@code{fork}/@code{exec} and on systems like WIN32 and OS/2 where we\n+use @code{spawn}.  It is up to the caller to wait for the child.\n \n-   pwait: cover function for wait.\n+The result is the WEXITSTATUS on systems like MS-DOS where we\n+@code{spawn} and wait for the child here.\n \n-   PID is the process id of the task to wait for.\n-   STATUS is the `status' argument to wait.\n-   FLAGS is currently unused (allows future enhancement without breaking\n-   upward compatibility).  Pass 0 for now.\n+Upon failure, @var{errmsg_fmt} and @var{errmsg_arg} are set to the\n+text of the error message with an optional argument (if not needed,\n+@var{errmsg_arg} is set to @code{NULL}), and -1 is returned.\n+@code{errno} is available to the caller to use.\n \n-   The result is the pid of the child reaped,\n-   or -1 for failure (errno says why).\n+@end deftypefn\n \n-   On systems that don't support waiting for a particular child, PID is\n-   ignored.  On systems like MSDOS that don't really multitask pwait\n-   is just a mechanism to provide a consistent interface for the caller.\n+@deftypefn Extension int pwait (int @var{pid}, int *@var{status}, int @var{flags})\n+\n+Waits for a program started by @code{pexecute} to finish.\n+\n+@var{pid} is the process id of the task to wait for. @var{status} is\n+the `status' argument to wait. @var{flags} is currently unused (allows\n+future enhancement without breaking upward compatibility).  Pass 0 for now.\n+\n+The result is the pid of the child reaped, or -1 for failure\n+(@code{errno} says why).\n+\n+On systems that don't support waiting for a particular child, @var{pid} is\n+ignored.  On systems like MS-DOS that don't really multitask @code{pwait}\n+is just a mechanism to provide a consistent interface for the caller.\n+\n+@end deftypefn\n+\n+@undocumented pfinish\n \n    pfinish: finish generation of script\n \n    pfinish is necessary for systems like MPW where a script is generated that\n-   runs the requested programs.\n-*/\n+   runs the requested programs.  */\n \n #ifdef __MSDOS__\n \n@@ -254,7 +267,7 @@ extern int _spawnvp ();\n /* This is a kludge to get around the Microsoft C spawn functions' propensity\n    to remove the outermost set of double quotes from all arguments.  */\n \n-const char * const *\n+static const char * const *\n fix_argv (argvec)\n      char **argvec;\n {"}, {"sha": "7c46bac6448b406ca80c2bcc1e76708f87ec2902", "filename": "libiberty/random.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aac04c15d761628889f138b16219bce27f25bbb2/libiberty%2Frandom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aac04c15d761628889f138b16219bce27f25bbb2/libiberty%2Frandom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Frandom.c?ref=aac04c15d761628889f138b16219bce27f25bbb2", "patch": "@@ -34,6 +34,24 @@\n  * It was reworked for the GNU C Library by Roland McGrath.\n  */\n \n+/*\n+\n+@deftypefn Supplement {long int} random ()\n+@deftypefnx Supplement void srandom (unsigned int @var{seed})\n+@deftypefnx Supplement void* initstate (unsigned int @var{seed}, void *@var{arg_state}, unsigned long @var{n})\n+@deftypefnx Supplement void* setstate (void *@var{arg_state})\n+\n+Random number functions.  @code{random} returns a random number in the\n+range @code{0..LONG_MAX}.  @code{srandom} initializes the random\n+number generator to some starting point determined by @var{seed}\n+(else, the values returned by @code{random} are always the same for each\n+run of the program).  @code{initstate} and @code{setstate} allow fine-grain\n+control over the state of the random number generator.\n+\n+@end deftypefn\n+\n+*/\n+\n #include <errno.h>\n \n #if 0"}, {"sha": "bfead7ed7a4aebd3bccc2a411e9e0e018cb426be", "filename": "libiberty/spaces.c", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aac04c15d761628889f138b16219bce27f25bbb2/libiberty%2Fspaces.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aac04c15d761628889f138b16219bce27f25bbb2/libiberty%2Fspaces.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fspaces.c?ref=aac04c15d761628889f138b16219bce27f25bbb2", "patch": "@@ -19,21 +19,13 @@ Boston, MA 02111-1307, USA.  */\n \n /*\n \n-NAME\n+@deftypefn Extension char* spaces (int @var{count})\n \n-\tspaces -- return a pointer to a buffer full of spaces\n+Returns a pointer to a memory region filled with the specified\n+number of spaces and null terminated.  The returned pointer is\n+valid until at least the next call.\n \n-SYNOPSIS\n-\n-\tchar *spaces (int count)\n-\n-DESCRIPTION\n-\n-\tReturns a pointer to a memory region filled with the specified\n-\tnumber of spaces and null terminated.  The returned pointer is\n-\tvalid until at least the next call.\n-\t\n-BUGS\n+@end deftypefn\n \n */\n "}, {"sha": "18050c2c15f739bc18a5f43e37323069403a9fcf", "filename": "libiberty/strerror.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aac04c15d761628889f138b16219bce27f25bbb2/libiberty%2Fstrerror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aac04c15d761628889f138b16219bce27f25bbb2/libiberty%2Fstrerror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fstrerror.c?ref=aac04c15d761628889f138b16219bce27f25bbb2", "patch": "@@ -563,7 +563,7 @@ init_error_tables ()\n /*\n \n \n-@deftypefn Replacement int errno_max (void)\n+@deftypefn Extension int errno_max (void)\n \n Returns the maximum @code{errno} value for which a corresponding\n symbolic name or message is available.  Note that in the case where we\n@@ -599,7 +599,7 @@ errno_max ()\n \n /*\n \n-@deftypefn Replacement char* strerror (int @var{errnoval})\n+@deftypefn Supplemental char* strerror (int @var{errnoval})\n \n Maps an @code{errno} number to an error message string, the contents\n of which are implementation defined.  On systems which have the\n@@ -608,7 +608,7 @@ strings will be the same as the ones used by @code{perror}.\n \n If the supplied error number is within the valid range of indices for\n the @code{sys_errlist}, but no message is available for the particular\n-error number, then returns the string @samp{\"Error @var{num}\"}, where\n+error number, then returns the string @samp{Error @var{num}}, where\n @var{num} is the error number.\n \n If the supplied error number is not a valid index into\n@@ -667,15 +667,15 @@ strerror (errnoval)\n \n /*\n \n-@deftypefn Replacement const char* strerrno (int @var{errnum})\n+@deftypefn Replacement {const char*} strerrno (int @var{errnum})\n \n Given an error number returned from a system call (typically returned\n in @code{errno}), returns a pointer to a string containing the\n symbolic name of that error number, as found in @code{<errno.h>}.\n \n If the supplied error number is within the valid range of indices for\n symbolic names, but no name is available for the particular error\n-number, then returns the string @samp{\"Error @var{num}\"}, where @var{num}\n+number, then returns the string @samp{Error @var{num}}, where @var{num}\n is the error number.\n \n If the supplied error number is not within the range of valid\n@@ -727,7 +727,7 @@ strerrno (errnoval)\n \n /*\n \n-@deftypefn Replacement int strtoerrno (const char *@var{name})\n+@deftypefn Extension int strtoerrno (const char *@var{name})\n \n Given the symbolic name of a error number (e.g., @code{EACCES}), map it\n to an errno value.  If no translation is found, returns 0."}, {"sha": "521a2a83a670baececf4d0cb19160295f49dd753", "filename": "libiberty/strsignal.c", "status": "modified", "additions": 48, "deletions": 79, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aac04c15d761628889f138b16219bce27f25bbb2/libiberty%2Fstrsignal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aac04c15d761628889f138b16219bce27f25bbb2/libiberty%2Fstrsignal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fstrsignal.c?ref=aac04c15d761628889f138b16219bce27f25bbb2", "patch": "@@ -350,28 +350,22 @@ init_signal_tables ()\n \n /*\n \n-NAME\n-\n-\tsigno_max -- return the max signo value\n-\n-SYNOPSIS\n+@deftypefn Extension int signo_max ()\n \n-\tint signo_max ();\n+Returns the maximum signal value for which a corresponding symbolic\n+name or message is available.  Note that in the case where we use the\n+@code{sys_siglist} supplied by the system, it is possible for there to\n+be more symbolic names than messages, or vice versa.  In fact, the\n+manual page for @code{psignal(3b)} explicitly warns that one should\n+check the size of the table (@code{NSIG}) before indexing it, since\n+new signal codes may be added to the system before they are added to\n+the table.  Thus @code{NSIG} might be smaller than value implied by\n+the largest signo value defined in @code{<signal.h>}.\n \n-DESCRIPTION\n-\n-\tReturns the maximum signo value for which a corresponding symbolic\n-\tname or message is available.  Note that in the case where\n-\twe use the sys_siglist supplied by the system, it is possible for\n-\tthere to be more symbolic names than messages, or vice versa.\n-\tIn fact, the manual page for psignal(3b) explicitly warns that one\n-\tshould check the size of the table (NSIG) before indexing it,\n-\tsince new signal codes may be added to the system before they are\n-\tadded to the table.  Thus NSIG might be smaller than value\n-\timplied by the largest signo value defined in <signal.h>.\n+We return the maximum value that can be used to obtain a meaningful\n+symbolic name or message.\n \n-\tWe return the maximum value that can be used to obtain a meaningful\n-\tsymbolic name or message.\n+@end deftypefn\n \n */\n \n@@ -391,31 +385,25 @@ signo_max ()\n \n /*\n \n-NAME\n-\n-\tstrsignal -- map a signal number to a signal message string\n+@deftypefn Supplemental {const char *} strsignal (int @var{signo})\n \n-SYNOPSIS\n-\n-\tconst char *strsignal (int signo)\n-\n-DESCRIPTION\n+Maps an signal number to an signal message string, the contents of\n+which are implementation defined.  On systems which have the external\n+variable @code{sys_siglist}, these strings will be the same as the\n+ones used by @code{psignal()}.\n \n-\tMaps an signal number to an signal message string, the contents of\n-\twhich are implementation defined.  On systems which have the external\n-\tvariable sys_siglist, these strings will be the same as the ones used\n-\tby psignal().\n+If the supplied signal number is within the valid range of indices for\n+the @code{sys_siglist}, but no message is available for the particular\n+signal number, then returns the string @samp{Signal @var{num}}, where\n+@var{num} is the signal number.\n \n-\tIf the supplied signal number is within the valid range of indices\n-\tfor the sys_siglist, but no message is available for the particular\n-\tsignal number, then returns the string \"Signal NUM\", where NUM is the\n-\tsignal number.\n+If the supplied signal number is not a valid index into\n+@code{sys_siglist}, returns @code{NULL}.\n \n-\tIf the supplied signal number is not a valid index into sys_siglist,\n-\treturns NULL.\n+The returned string is only guaranteed to be valid only until the next\n+call to @code{strsignal}.\n \n-\tThe returned string is only guaranteed to be valid only until the\n-\tnext call to strsignal.\n+@end deftypefn\n \n */\n \n@@ -461,31 +449,23 @@ strsignal (signo)\n \n /*\n \n-NAME\n-\n-\tstrsigno -- map an signal number to a symbolic name string\n+@deftypefn Extension {const char*} strsigno (int @var{signo})\n \n-SYNOPSIS\n+Given an signal number, returns a pointer to a string containing the\n+symbolic name of that signal number, as found in @code{<signal.h>}.\n \n-\tconst char *strsigno (int signo)\n+If the supplied signal number is within the valid range of indices for\n+symbolic names, but no name is available for the particular signal\n+number, then returns the string @samp{Signal @var{num}}, where\n+@var{num} is the signal number.\n \n-DESCRIPTION\n+If the supplied signal number is not within the range of valid\n+indices, then returns @code{NULL}.\n \n-\tGiven an signal number, returns a pointer to a string containing\n-\tthe symbolic name of that signal number, as found in <signal.h>.\n+The contents of the location pointed to are only guaranteed to be\n+valid until the next call to @code{strsigno}.\n \n-\tIf the supplied signal number is within the valid range of indices\n-\tfor symbolic names, but no name is available for the particular\n-\tsignal number, then returns the string \"Signal NUM\", where NUM is\n-\tthe signal number.\n-\n-\tIf the supplied signal number is not within the range of valid\n-\tindices, then returns NULL.\n-\n-BUGS\n-\n-\tThe contents of the location pointed to are only guaranteed to be\n-\tvalid until the next call to strsigno.\n+@end deftypefn\n \n */\n \n@@ -524,18 +504,12 @@ strsigno (signo)\n \n /*\n \n-NAME\n-\n-\tstrtosigno -- map a symbolic signal name to a numeric value\n+@deftypefn Extension int strtosigno (const char *@var{name})\n \n-SYNOPSIS\n+Given the symbolic name of a signal, map it to a signal number.  If no\n+translation is found, returns 0.\n \n-\tint strtosigno (char *name)\n-\n-DESCRIPTION\n-\n-\tGiven the symbolic name of a signal, map it to a signal number.\n-\tIf no translation is found, returns 0.\n+@end deftypefn\n \n */\n \n@@ -570,19 +544,14 @@ strtosigno (name)\n \n /*\n \n-NAME\n+@deftypefn Supplemental void psignal (unsigned @var{signo}, char *@var{message})\n \n-\tpsignal -- print message about signal to stderr\n+Print @var{message} to the standard error, followed by a colon,\n+followed by the description of the signal specified by @var{signo},\n+followed by a newline.\n \n-SYNOPSIS\n-\n-\tvoid psignal (unsigned signo, char *message);\n-\n-DESCRIPTION\n+@end deftypefn\n \n-\tPrint to the standard error the message, followed by a colon,\n-\tfollowed by the description of the signal specified by signo,\n-\tfollowed by a newline.\n */\n \n #ifndef HAVE_PSIGNAL"}, {"sha": "d9f54cc8f7ac23e13cce3dd241dab43860792e31", "filename": "libiberty/strtol.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aac04c15d761628889f138b16219bce27f25bbb2/libiberty%2Fstrtol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aac04c15d761628889f138b16219bce27f25bbb2/libiberty%2Fstrtol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fstrtol.c?ref=aac04c15d761628889f138b16219bce27f25bbb2", "patch": "@@ -31,6 +31,7 @@\n /*\n \n @deftypefn Supplemental {long int} strtol (const char *@var{string}, char **@var{endptr}, int @var{base})\n+@deftypefnx Supplemental {unsigned long int} strtoul (const char *@var{string}, char **@var{endptr}, int @var{base})\n \n The @code{strtol} function converts the string in @var{string} to a\n long integer value according to the given @var{base}, which must be\n@@ -39,7 +40,8 @@ is 0, @code{strtol} will look for the prefixes @code{0} and @code{0x}\n to indicate bases 8 and 16, respectively, else default to base 10.\n When the base is 16 (either explicitly or implicitly), a prefix of\n @code{0x} is allowed.  The handling of @var{endptr} is as that of\n-@code{strtod} above.\n+@code{strtod} above.  The @code{strtoul} function is the same, except\n+that the converted value is unsigned.\n \n @end deftypefn\n "}, {"sha": "d69dc323b5c8efe57ed2d5fba982e70ccd595fde", "filename": "libiberty/vasprintf.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aac04c15d761628889f138b16219bce27f25bbb2/libiberty%2Fvasprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aac04c15d761628889f138b16219bce27f25bbb2/libiberty%2Fvasprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fvasprintf.c?ref=aac04c15d761628889f138b16219bce27f25bbb2", "patch": "@@ -43,6 +43,21 @@ extern PTR malloc ();\n int global_total_width;\n #endif\n \n+/*\n+\n+@deftypefn Extension int vasprintf (char **@var{resptr}, char *@var{format}, va_list @var{args})\n+\n+Like @code{vsprintf}, but instead of passing a pointer to a buffer,\n+you pass a pointer to a pointer.  This function will compute the size\n+of the buffer needed, allocate memory with @code{malloc}, and store a\n+pointer to the allocated memory in @code{*@var{resptr}}.  The value\n+returned is the same as @code{vsprintf} would return.  If memory could\n+not be allocated, zero is returned and @code{NULL} is stored in\n+@code{*@var{resptr}}.\n+\n+@end deftypefn\n+\n+*/\n \n static int int_vasprintf PARAMS ((char **, const char *, va_list *));\n "}]}