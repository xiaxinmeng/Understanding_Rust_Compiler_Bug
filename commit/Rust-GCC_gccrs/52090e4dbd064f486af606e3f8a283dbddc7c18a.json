{"sha": "52090e4dbd064f486af606e3f8a283dbddc7c18a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTIwOTBlNGRiZDA2NGY0ODZhZjYwNmUzZjhhMjgzZGJkZGM3YzE4YQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-08-20T08:52:40Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-08-20T08:52:40Z"}, "message": "Use function_arg_info for TARGET_PASS_BY_REFERENCE\n\nThe hook is passed the unpromoted type mode instead of the promoted mode.\n\n2019-08-20  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* target.def (pass_by_reference): Take a function_arg_info instead\n\tof a mode, type and named flag.\n\t* doc/tm.texi: Regenerate.\n\t* targhooks.h (hook_pass_by_reference_must_pass_in_stack): Update\n\taccordingly.\n\t(hook_bool_CUMULATIVE_ARGS_arg_info_false): Declare.\n\t* targhooks.c (hook_pass_by_reference_must_pass_in_stack): Take a\n\tfunction_arg_info instead of a mode, type and named flag.\n\t(hook_bool_CUMULATIVE_ARGS_arg_info_false): New function.\n\t* calls.h (pass_by_reference): Take a function_arg_info instead of a\n\tmode, type and named flag.\n\t* calls.c (pass_by_reference): Likewise.\n\t(pass_va_arg_by_reference): Update call accordingly.\n\t(initialize_argument_information): Likewise.\n\t(emit_library_call_value_1): Likewise.\n\t* function.c (assign_parm_find_data_types): Likewise.\n\t* var-tracking.c (prepare_call_arguments): Likewise.\n\t* stor-layout.c: Include calls.h.\n\t(compute_record_mode): Update call to targetm.calls.pass_by_reference.\n\t* config/aarch64/aarch64.c (aarch64_pass_by_reference): Take a\n\tfunction_arg_info instead of a mode, type and named flag.\n\t* config/alpha/alpha.c (alpha_pass_by_reference): Likewise.\n\t* config/arc/arc.c (arc_pass_by_reference): Likewise.\n\t* config/arm/arm.c (arm_pass_by_reference): Likewise.\n\t* config/bfin/bfin.c (bfin_pass_by_reference): Likewise.\n\t* config/c6x/c6x.c (c6x_pass_by_reference): Likewise.\n\t(c6x_call_saved_register_used): Update call to pass_by_reference.\n\t* config/cris/cris.c (cris_pass_by_reference): Take a\n\tfunction_arg_info instead of a mode, type and named flag.\n\t* config/epiphany/epiphany.c (epiphany_pass_by_reference): Take a\n\tfunction_arg_info instead of a mode, type and named flag.\n\t(epiphany_arg_partial_bytes): Update call accordingly.\n\t* config/ft32/ft32.c (ft32_pass_by_reference): Take a\n\tfunction_arg_info instead of a mode, type and named flag.\n\t(ft32_arg_partial_bytes): Update call accordingly.\n\t* config/i386/i386.c (ix86_pass_by_reference): Take a\n\tfunction_arg_info instead of a mode, type and named flag.\n\t* config/iq2000/iq2000.c (iq2000_pass_by_reference): Likewise.\n\t* config/m32c/m32c.c (m32c_pass_by_reference): Likewise.\n\t* config/m32r/m32r.c (m32r_pass_by_reference): Likewise.\n\t(m32r_return_in_memory): Update call accordingly.\n\t* config/mips/mips.c (mips_pass_by_reference): Take a\n\tfunction_arg_info instead of a mode, type and named flag.\n\t* config/mmix/mmix.c (mmix_pass_by_reference): Likewise.\n\t* config/mn10300/mn10300.c (mn10300_pass_by_reference): Likewise.\n\t* config/moxie/moxie.c (moxie_pass_by_reference): Likewise.\n\t(moxie_arg_partial_bytes): Update call accordingly.\n\t* config/msp430/msp430.c (msp430_pass_by_reference): Take a\n\tfunction_arg_info instead of a mode, type and named flag.\n\t* config/nvptx/nvptx.c (nvptx_pass_by_reference): Likewise.\n\t* config/or1k/or1k.c (or1k_pass_by_reference): Likewise.\n\t* config/pa/pa.c (pa_pass_by_reference): Likewise.\n\t* config/riscv/riscv.c (riscv_pass_by_reference): Likewise.\n\t(riscv_return_in_memory): Update call accordingly.\n\t* config/rs6000/rs6000-internal.h (rs6000_pass_by_reference): Take a\n\tfunction_arg_info instead of a mode, type and named flag.\n\t* config/rs6000/rs6000-call.c (rs6000_pass_by_reference): Likewise.\n\t(rs6000_parm_needs_stack): Update call to pass_by_reference.\n\t* config/s390/s390.c (s390_pass_by_reference): Take a\n\tfunction_arg_info instead of a mode, type and named flag.\n\t(s390_call_saved_register_used): Update call accordingly.\n\t* config/sh/sh.c (sh_pass_by_reference): Take a function_arg_info\n\tinstead of a mode, type and named flag.\n\t* config/sparc/sparc.c (sparc_pass_by_reference): Likewise.\n\t* config/spu/spu.c (spu_pass_by_reference): Likewise.\n\t* config/tilegx/tilegx.c (tilegx_pass_by_reference): Likewise.\n\t* config/tilepro/tilepro.c (tilepro_pass_by_reference): Likewise.\n\t* config/v850/v850.c (v850_pass_by_reference): Likewise.\n\t* config/visium/visium.c (visium_pass_by_reference): Likewise.\n\ngcc/ada/\n\t* gcc-interface/misc.c (default_pass_by_ref): Update call to\n\tpass_by_reference.\n\nFrom-SVN: r274698", "tree": {"sha": "c854f18544d6d5f48e8e0d584200ea54f9da1bba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c854f18544d6d5f48e8e0d584200ea54f9da1bba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/52090e4dbd064f486af606e3f8a283dbddc7c18a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52090e4dbd064f486af606e3f8a283dbddc7c18a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52090e4dbd064f486af606e3f8a283dbddc7c18a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52090e4dbd064f486af606e3f8a283dbddc7c18a/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a7c81bc1fb43366ca1b4332d8a6042b648a84cdc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc"}], "stats": {"total": 582, "additions": 281, "deletions": 301}, "files": [{"sha": "026a7c8f7e8aeeac1bb2536de7935ea44c8a5b70", "filename": "gcc/ChangeLog", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=52090e4dbd064f486af606e3f8a283dbddc7c18a", "patch": "@@ -1,3 +1,75 @@\n+2019-08-20  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* target.def (pass_by_reference): Take a function_arg_info instead\n+\tof a mode, type and named flag.\n+\t* doc/tm.texi: Regenerate.\n+\t* targhooks.h (hook_pass_by_reference_must_pass_in_stack): Update\n+\taccordingly.\n+\t(hook_bool_CUMULATIVE_ARGS_arg_info_false): Declare.\n+\t* targhooks.c (hook_pass_by_reference_must_pass_in_stack): Take a\n+\tfunction_arg_info instead of a mode, type and named flag.\n+\t(hook_bool_CUMULATIVE_ARGS_arg_info_false): New function.\n+\t* calls.h (pass_by_reference): Take a function_arg_info instead of a\n+\tmode, type and named flag.\n+\t* calls.c (pass_by_reference): Likewise.\n+\t(pass_va_arg_by_reference): Update call accordingly.\n+\t(initialize_argument_information): Likewise.\n+\t(emit_library_call_value_1): Likewise.\n+\t* function.c (assign_parm_find_data_types): Likewise.\n+\t* var-tracking.c (prepare_call_arguments): Likewise.\n+\t* stor-layout.c: Include calls.h.\n+\t(compute_record_mode): Update call to targetm.calls.pass_by_reference.\n+\t* config/aarch64/aarch64.c (aarch64_pass_by_reference): Take a\n+\tfunction_arg_info instead of a mode, type and named flag.\n+\t* config/alpha/alpha.c (alpha_pass_by_reference): Likewise.\n+\t* config/arc/arc.c (arc_pass_by_reference): Likewise.\n+\t* config/arm/arm.c (arm_pass_by_reference): Likewise.\n+\t* config/bfin/bfin.c (bfin_pass_by_reference): Likewise.\n+\t* config/c6x/c6x.c (c6x_pass_by_reference): Likewise.\n+\t(c6x_call_saved_register_used): Update call to pass_by_reference.\n+\t* config/cris/cris.c (cris_pass_by_reference): Take a\n+\tfunction_arg_info instead of a mode, type and named flag.\n+\t* config/epiphany/epiphany.c (epiphany_pass_by_reference): Take a\n+\tfunction_arg_info instead of a mode, type and named flag.\n+\t(epiphany_arg_partial_bytes): Update call accordingly.\n+\t* config/ft32/ft32.c (ft32_pass_by_reference): Take a\n+\tfunction_arg_info instead of a mode, type and named flag.\n+\t(ft32_arg_partial_bytes): Update call accordingly.\n+\t* config/i386/i386.c (ix86_pass_by_reference): Take a\n+\tfunction_arg_info instead of a mode, type and named flag.\n+\t* config/iq2000/iq2000.c (iq2000_pass_by_reference): Likewise.\n+\t* config/m32c/m32c.c (m32c_pass_by_reference): Likewise.\n+\t* config/m32r/m32r.c (m32r_pass_by_reference): Likewise.\n+\t(m32r_return_in_memory): Update call accordingly.\n+\t* config/mips/mips.c (mips_pass_by_reference): Take a\n+\tfunction_arg_info instead of a mode, type and named flag.\n+\t* config/mmix/mmix.c (mmix_pass_by_reference): Likewise.\n+\t* config/mn10300/mn10300.c (mn10300_pass_by_reference): Likewise.\n+\t* config/moxie/moxie.c (moxie_pass_by_reference): Likewise.\n+\t(moxie_arg_partial_bytes): Update call accordingly.\n+\t* config/msp430/msp430.c (msp430_pass_by_reference): Take a\n+\tfunction_arg_info instead of a mode, type and named flag.\n+\t* config/nvptx/nvptx.c (nvptx_pass_by_reference): Likewise.\n+\t* config/or1k/or1k.c (or1k_pass_by_reference): Likewise.\n+\t* config/pa/pa.c (pa_pass_by_reference): Likewise.\n+\t* config/riscv/riscv.c (riscv_pass_by_reference): Likewise.\n+\t(riscv_return_in_memory): Update call accordingly.\n+\t* config/rs6000/rs6000-internal.h (rs6000_pass_by_reference): Take a\n+\tfunction_arg_info instead of a mode, type and named flag.\n+\t* config/rs6000/rs6000-call.c (rs6000_pass_by_reference): Likewise.\n+\t(rs6000_parm_needs_stack): Update call to pass_by_reference.\n+\t* config/s390/s390.c (s390_pass_by_reference): Take a\n+\tfunction_arg_info instead of a mode, type and named flag.\n+\t(s390_call_saved_register_used): Update call accordingly.\n+\t* config/sh/sh.c (sh_pass_by_reference): Take a function_arg_info\n+\tinstead of a mode, type and named flag.\n+\t* config/sparc/sparc.c (sparc_pass_by_reference): Likewise.\n+\t* config/spu/spu.c (spu_pass_by_reference): Likewise.\n+\t* config/tilegx/tilegx.c (tilegx_pass_by_reference): Likewise.\n+\t* config/tilepro/tilepro.c (tilepro_pass_by_reference): Likewise.\n+\t* config/v850/v850.c (v850_pass_by_reference): Likewise.\n+\t* config/visium/visium.c (visium_pass_by_reference): Likewise.\n+\n 2019-08-20  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* target.def (arg_partial_bytes): Take a function_arg_info instead"}, {"sha": "66514c114cc9cea34e5fe9cc059cd2e3ed2e3238", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=52090e4dbd064f486af606e3f8a283dbddc7c18a", "patch": "@@ -1,3 +1,8 @@\n+2019-08-20  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* gcc-interface/misc.c (default_pass_by_ref): Update call to\n+\tpass_by_reference.\n+\n 2019-08-19  Bob Duff  <duff@adacore.com>\n \n \t* doc/gnat_rm/implementation_advice.rst: Fix documentation for"}, {"sha": "c5822f6cb7b6351c014c297e4ac3f4f6430fd0f0", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=52090e4dbd064f486af606e3f8a283dbddc7c18a", "patch": "@@ -1136,7 +1136,7 @@ default_pass_by_ref (tree gnu_type)\n \t\t\t       TYPE_ALIGN (gnu_type)) > 0))\n     return true;\n \n-  if (pass_by_reference (NULL, TYPE_MODE (gnu_type), gnu_type, true))\n+  if (pass_by_reference (NULL, function_arg_info (gnu_type, /*named=*/true)))\n     return true;\n \n   if (targetm.calls.return_in_memory (gnu_type, NULL_TREE))"}, {"sha": "8943800b186e1e18afb4196b0f074e8521bae8e4", "filename": "gcc/calls.c", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=52090e4dbd064f486af606e3f8a283dbddc7c18a", "patch": "@@ -897,13 +897,12 @@ call_expr_flags (const_tree t)\n   return flags;\n }\n \n-/* Return true if TYPE should be passed by invisible reference.  */\n+/* Return true if ARG should be passed by invisible reference.  */\n \n bool\n-pass_by_reference (CUMULATIVE_ARGS *ca, machine_mode mode,\n-\t\t   tree type, bool named_arg)\n+pass_by_reference (CUMULATIVE_ARGS *ca, function_arg_info arg)\n {\n-  if (type)\n+  if (tree type = arg.type)\n     {\n       /* If this type contains non-trivial constructors, then it is\n \t forbidden for the middle-end to create any new copies.  */\n@@ -918,13 +917,12 @@ pass_by_reference (CUMULATIVE_ARGS *ca, machine_mode mode,\n \t member, use the type and mode of that member.  */\n       if (TREE_CODE (type) == RECORD_TYPE && TYPE_TRANSPARENT_AGGR (type))\n \t{\n-\t  type = TREE_TYPE (first_field (type));\n-\t  mode = TYPE_MODE (type);\n+\t  arg.type = TREE_TYPE (first_field (type));\n+\t  arg.mode = TYPE_MODE (arg.type);\n \t}\n     }\n \n-  return targetm.calls.pass_by_reference (pack_cumulative_args (ca), mode,\n-\t\t\t\t\t  type, named_arg);\n+  return targetm.calls.pass_by_reference (pack_cumulative_args (ca), arg);\n }\n \n /* Return true if TYPE should be passed by reference when passed to\n@@ -933,7 +931,7 @@ pass_by_reference (CUMULATIVE_ARGS *ca, machine_mode mode,\n bool\n pass_va_arg_by_reference (tree type)\n {\n-  return pass_by_reference (NULL, TYPE_MODE (type), type, false);\n+  return pass_by_reference (NULL, function_arg_info (type, /*named=*/false));\n }\n \n /* Return true if TYPE, which is passed by reference, should be callee\n@@ -1997,8 +1995,8 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n \t with those made by function.c.  */\n \n       /* See if this argument should be passed by invisible reference.  */\n-      if (pass_by_reference (args_so_far_pnt, TYPE_MODE (type),\n-\t\t\t     type, argpos < n_named_args))\n+      function_arg_info orig_arg (type, argpos < n_named_args);\n+      if (pass_by_reference (args_so_far_pnt, orig_arg))\n \t{\n \t  bool callee_copies;\n \t  tree base = NULL_TREE;\n@@ -4909,7 +4907,8 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \t  && !(CONSTANT_P (val) && targetm.legitimate_constant_p (mode, val)))\n \tval = force_operand (val, NULL_RTX);\n \n-      if (pass_by_reference (&args_so_far_v, mode, NULL_TREE, 1))\n+      function_arg_info orig_arg (mode, /*named=*/true);\n+      if (pass_by_reference (&args_so_far_v, orig_arg))\n \t{\n \t  rtx slot;\n \t  int must_copy"}, {"sha": "6845193fe3999a6ccdeafa943af06503a96be7b4", "filename": "gcc/calls.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fcalls.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fcalls.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.h?ref=52090e4dbd064f486af606e3f8a283dbddc7c18a", "patch": "@@ -105,8 +105,7 @@ extern bool shift_return_value (machine_mode, bool, rtx);\n extern rtx expand_call (tree, rtx, int);\n extern void fixup_tail_calls (void);\n \n-extern bool pass_by_reference (CUMULATIVE_ARGS *, machine_mode,\n-\t\t\t       tree, bool);\n+extern bool pass_by_reference (CUMULATIVE_ARGS *, function_arg_info);\n extern bool pass_va_arg_by_reference (tree);\n extern bool reference_callee_copied (CUMULATIVE_ARGS *, machine_mode,\n \t\t\t\t     tree, bool);"}, {"sha": "5694dd796f7411ff7256b6d22a4f3085caf53402", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=52090e4dbd064f486af606e3f8a283dbddc7c18a", "patch": "@@ -4409,35 +4409,30 @@ aarch64_function_ok_for_sibcall (tree decl ATTRIBUTE_UNUSED,\n /* Implement TARGET_PASS_BY_REFERENCE.  */\n \n static bool\n-aarch64_pass_by_reference (cumulative_args_t pcum ATTRIBUTE_UNUSED,\n-\t\t\t   machine_mode mode,\n-\t\t\t   const_tree type,\n-\t\t\t   bool named ATTRIBUTE_UNUSED)\n+aarch64_pass_by_reference (cumulative_args_t, const function_arg_info &arg)\n {\n   HOST_WIDE_INT size;\n   machine_mode dummymode;\n   int nregs;\n \n   /* GET_MODE_SIZE (BLKmode) is useless since it is 0.  */\n-  if (mode == BLKmode && type)\n-    size = int_size_in_bytes (type);\n+  if (arg.mode == BLKmode && arg.type)\n+    size = int_size_in_bytes (arg.type);\n   else\n     /* No frontends can create types with variable-sized modes, so we\n        shouldn't be asked to pass or return them.  */\n-    size = GET_MODE_SIZE (mode).to_constant ();\n+    size = GET_MODE_SIZE (arg.mode).to_constant ();\n \n   /* Aggregates are passed by reference based on their size.  */\n-  if (type && AGGREGATE_TYPE_P (type))\n-    {\n-      size = int_size_in_bytes (type);\n-    }\n+  if (arg.aggregate_type_p ())\n+    size = int_size_in_bytes (arg.type);\n \n   /* Variable sized arguments are always returned by reference.  */\n   if (size < 0)\n     return true;\n \n   /* Can this be a candidate to be passed in fp/simd register(s)?  */\n-  if (aarch64_vfp_is_call_or_return_candidate (mode, type,\n+  if (aarch64_vfp_is_call_or_return_candidate (arg.mode, arg.type,\n \t\t\t\t\t       &dummymode, &nregs,\n \t\t\t\t\t       NULL))\n     return false;"}, {"sha": "e4313673b4c99607810187a4a04f075c5f642104", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=52090e4dbd064f486af606e3f8a283dbddc7c18a", "patch": "@@ -5710,13 +5710,10 @@ alpha_return_in_memory (const_tree type, const_tree fndecl ATTRIBUTE_UNUSED)\n   return size > UNITS_PER_WORD;\n }\n \n-/* Return true if TYPE should be passed by invisible reference.  */\n+/* Return true if ARG should be passed by invisible reference.  */\n \n static bool\n-alpha_pass_by_reference (cumulative_args_t ca ATTRIBUTE_UNUSED,\n-\t\t\t machine_mode mode,\n-\t\t\t const_tree type ATTRIBUTE_UNUSED,\n-\t\t\t bool named)\n+alpha_pass_by_reference (cumulative_args_t, const function_arg_info &arg)\n {\n   /* Pass float and _Complex float variable arguments by reference.\n      This avoids 64-bit store from a FP register to a pretend args save area\n@@ -5736,10 +5733,10 @@ alpha_pass_by_reference (cumulative_args_t ca ATTRIBUTE_UNUSED,\n      to worry about, and passing unpromoted _Float32 and _Complex float\n      as a variable argument will actually work in the future.  */\n \n-  if (mode == SFmode || mode == SCmode)\n-    return !named;\n+  if (arg.mode == SFmode || arg.mode == SCmode)\n+    return !arg.named;\n \n-  return mode == TFmode || mode == TCmode;\n+  return arg.mode == TFmode || arg.mode == TCmode;\n }\n \n /* Define how to find the value returned by a function.  VALTYPE is the"}, {"sha": "5b0d8b9b134c3379ff77879c1a56cf9d5be40548", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=52090e4dbd064f486af606e3f8a283dbddc7c18a", "patch": "@@ -7566,14 +7566,11 @@ arc_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)\n }\n \n static bool\n-arc_pass_by_reference (cumulative_args_t ca_v ATTRIBUTE_UNUSED,\n-\t\t       machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t       const_tree type,\n-\t\t       bool named ATTRIBUTE_UNUSED)\n-{\n-  return (type != 0\n-\t  && (TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST\n-\t      || TREE_ADDRESSABLE (type)));\n+arc_pass_by_reference (cumulative_args_t, const function_arg_info &arg)\n+{\n+  return (arg.type != 0\n+\t  && (TREE_CODE (TYPE_SIZE (arg.type)) != INTEGER_CST\n+\t      || TREE_ADDRESSABLE (arg.type)));\n }\n \n /* Implement TARGET_CAN_USE_DOLOOP_P.  */"}, {"sha": "cceb3c7ff33f43dddc368c00860c53dda54832e3", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=52090e4dbd064f486af606e3f8a283dbddc7c18a", "patch": "@@ -215,7 +215,7 @@ static void arm_insert_attributes (tree, tree *);\n static void arm_setup_incoming_varargs (cumulative_args_t, machine_mode,\n \t\t\t\t\ttree, int *, int);\n static bool arm_pass_by_reference (cumulative_args_t,\n-\t\t\t\t   machine_mode, const_tree, bool);\n+\t\t\t\t   const function_arg_info &);\n static bool arm_promote_prototypes (const_tree);\n static bool arm_default_short_enums (void);\n static bool arm_align_anon_bitfield (void);\n@@ -6819,11 +6819,9 @@ arm_function_arg_advance (cumulative_args_t pcum_v, machine_mode mode,\n    extension to the ARM ABI.  */\n \n static bool\n-arm_pass_by_reference (cumulative_args_t cum ATTRIBUTE_UNUSED,\n-\t\t       machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t       const_tree type, bool named ATTRIBUTE_UNUSED)\n+arm_pass_by_reference (cumulative_args_t, const function_arg_info &arg)\n {\n-  return type && TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST;\n+  return arg.type && TREE_CODE (TYPE_SIZE (arg.type)) != INTEGER_CST;\n }\n \f\n /* Encode the current state of the #pragma [no_]long_calls.  */"}, {"sha": "783befff93872949d990073feb866b214b536624", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=52090e4dbd064f486af606e3f8a283dbddc7c18a", "patch": "@@ -1741,11 +1741,9 @@ bfin_arg_partial_bytes (cumulative_args_t cum, const function_arg_info &arg)\n /* Variable sized types are passed by reference.  */\n \n static bool\n-bfin_pass_by_reference (cumulative_args_t cum ATTRIBUTE_UNUSED,\n-\t\t\tmachine_mode mode ATTRIBUTE_UNUSED,\n-\t\t\tconst_tree type, bool named ATTRIBUTE_UNUSED)\n+bfin_pass_by_reference (cumulative_args_t, const function_arg_info &arg)\n {\n-  return type && TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST;\n+  return arg.type && TREE_CODE (TYPE_SIZE (arg.type)) != INTEGER_CST;\n }\n \n /* Decide whether a type should be returned in memory (true)"}, {"sha": "500dec6091dda49507df4659f47c74cc3e322140", "filename": "gcc/config/c6x/c6x.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2Fc6x%2Fc6x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2Fc6x%2Fc6x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc6x%2Fc6x.c?ref=52090e4dbd064f486af606e3f8a283dbddc7c18a", "patch": "@@ -642,15 +642,13 @@ c6x_function_value_regno_p (const unsigned int regno)\n    reference.  The callee must copy them; see c6x_callee_copies.  */\n \n static bool\n-c6x_pass_by_reference (cumulative_args_t cum_v ATTRIBUTE_UNUSED,\n-\t\t       machine_mode mode, const_tree type,\n-\t\t       bool named ATTRIBUTE_UNUSED)\n+c6x_pass_by_reference (cumulative_args_t, const function_arg_info &arg)\n {\n   int size = -1;\n-  if (type)\n-    size = int_size_in_bytes (type);\n-  else if (mode != VOIDmode)\n-    size = GET_MODE_SIZE (mode);\n+  if (arg.type)\n+    size = int_size_in_bytes (arg.type);\n+  else if (arg.mode != VOIDmode)\n+    size = GET_MODE_SIZE (arg.mode);\n   return size > 2 * UNITS_PER_WORD || size == -1;\n }\n \n@@ -1130,7 +1128,7 @@ c6x_call_saved_register_used (tree call_expr)\n       mode = TYPE_MODE (type);\n       gcc_assert (mode);\n \n-      if (pass_by_reference (&cum_v, mode, type, true))\n+      if (pass_by_reference (&cum_v, function_arg_info (type, /*named=*/true)))\n  \t{\n  \t  mode = Pmode;\n  \t  type = build_pointer_type (type);"}, {"sha": "e2a78de5302f234c88a78436ccfbda57ee67ec1d", "filename": "gcc/config/cris/cris.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2Fcris%2Fcris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2Fcris%2Fcris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.c?ref=52090e4dbd064f486af606e3f8a283dbddc7c18a", "patch": "@@ -139,8 +139,8 @@ static int cris_register_move_cost (machine_mode, reg_class_t, reg_class_t);\n static int cris_memory_move_cost (machine_mode, reg_class_t, bool);\n static bool cris_rtx_costs (rtx, machine_mode, int, int, int *, bool);\n static int cris_address_cost (rtx, machine_mode, addr_space_t, bool);\n-static bool cris_pass_by_reference (cumulative_args_t, machine_mode,\n-\t\t\t\t    const_tree, bool);\n+static bool cris_pass_by_reference (cumulative_args_t,\n+\t\t\t\t    const function_arg_info &);\n static int cris_arg_partial_bytes (cumulative_args_t,\n \t\t\t\t   const function_arg_info &);\n static rtx cris_function_arg (cumulative_args_t, machine_mode,\n@@ -4041,16 +4041,14 @@ cris_setup_incoming_varargs (cumulative_args_t ca_v,\n \t     ca->regs, *pretend_arg_size, second_time);\n }\n \n-/* Return true if TYPE must be passed by invisible reference.\n+/* Return true if ARG must be passed by invisible reference.\n    For cris, we pass <= 8 bytes by value, others by reference.  */\n \n static bool\n-cris_pass_by_reference (cumulative_args_t ca ATTRIBUTE_UNUSED,\n-\t\t\tmachine_mode mode, const_tree type,\n-\t\t\tbool named ATTRIBUTE_UNUSED)\n+cris_pass_by_reference (cumulative_args_t, const function_arg_info &arg)\n {\n-  return (targetm.calls.must_pass_in_stack (mode, type)\n-\t  || CRIS_FUNCTION_ARG_SIZE (mode, type) > 8);\n+  return (targetm.calls.must_pass_in_stack (arg.mode, arg.type)\n+\t  || CRIS_FUNCTION_ARG_SIZE (arg.mode, arg.type) > 8);\n }\n \n /* A combination of defining TARGET_PROMOTE_FUNCTION_MODE, promoting arguments"}, {"sha": "c98fc5269195b20f0af8da16c84f3647ec13485c", "filename": "gcc/config/epiphany/epiphany.c", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2Fepiphany%2Fepiphany.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2Fepiphany%2Fepiphany.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fepiphany%2Fepiphany.c?ref=52090e4dbd064f486af606e3f8a283dbddc7c18a", "patch": "@@ -71,8 +71,8 @@ static int get_epiphany_condition_code (rtx);\n static tree epiphany_handle_interrupt_attribute (tree *, tree, tree, int, bool *);\n static tree epiphany_handle_forwarder_attribute (tree *, tree, tree, int,\n \t\t\t\t\t\t bool *);\n-static bool epiphany_pass_by_reference (cumulative_args_t, machine_mode,\n-\t\t\t\t\tconst_tree, bool);\n+static bool epiphany_pass_by_reference (cumulative_args_t,\n+\t\t\t\t\tconst function_arg_info &);\n static rtx_insn *frame_insn (rtx);\n \f\n /* defines for the initialization of the GCC target structure.  */\n@@ -749,8 +749,7 @@ epiphany_arg_partial_bytes (cumulative_args_t cum,\n {\n   int words = 0, rounded_cum;\n \n-  gcc_assert (!epiphany_pass_by_reference (cum, arg.mode, arg.type,\n-\t\t\t\t\t   arg.named));\n+  gcc_assert (!epiphany_pass_by_reference (cum, arg));\n \n   rounded_cum = ROUND_ADVANCE_CUM (*get_cumulative_args (cum),\n \t\t\t\t   arg.mode, arg.type);\n@@ -1487,14 +1486,12 @@ epiphany_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)\n    passed by reference.  */\n \n static bool\n-epiphany_pass_by_reference (cumulative_args_t ca ATTRIBUTE_UNUSED,\n-\t\t       machine_mode mode, const_tree type,\n-\t\t       bool named ATTRIBUTE_UNUSED)\n+epiphany_pass_by_reference (cumulative_args_t, const function_arg_info &arg)\n {\n-  if (type)\n+  if (tree type = arg.type)\n     {\n       if (AGGREGATE_TYPE_P (type)\n-\t  && (mode == BLKmode || TYPE_NEEDS_CONSTRUCTING (type)))\n+\t  && (arg.mode == BLKmode || TYPE_NEEDS_CONSTRUCTING (type)))\n \treturn true;\n     }\n   return false;"}, {"sha": "d5b66df4a5698c8fbdfae7fc29c87229dca03d65", "filename": "gcc/config/ft32/ft32.c", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2Fft32%2Fft32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2Fft32%2Fft32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fft32%2Fft32.c?ref=52090e4dbd064f486af606e3f8a283dbddc7c18a", "patch": "@@ -684,25 +684,15 @@ ft32_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n           ? *cum + ((3 + FT32_FUNCTION_ARG_SIZE (mode, type)) / 4) : *cum);\n }\n \n-/* Return non-zero if the function argument described by TYPE is to be\n+/* Return non-zero if the function argument described by ARG is to be\n    passed by reference.  */\n \n static bool\n-ft32_pass_by_reference (cumulative_args_t cum ATTRIBUTE_UNUSED,\n-                        machine_mode mode, const_tree type,\n-                        bool named ATTRIBUTE_UNUSED)\n+ft32_pass_by_reference (cumulative_args_t, const function_arg_info &arg)\n {\n-  unsigned HOST_WIDE_INT size;\n-\n-  if (type)\n-    {\n-      if (AGGREGATE_TYPE_P (type))\n-        return true;\n-      size = int_size_in_bytes (type);\n-    }\n-  else\n-    size = GET_MODE_SIZE (mode);\n-\n+  if (arg.aggregate_type_p ())\n+    return true;\n+  unsigned HOST_WIDE_INT size = arg.type_size_in_bytes ();\n   return size > 4 * 6;\n }\n \n@@ -719,7 +709,7 @@ ft32_arg_partial_bytes (cumulative_args_t cum_v, const function_arg_info &arg)\n   if (*cum >= 8)\n     return 0;\n \n-  if (ft32_pass_by_reference (cum_v, arg.mode, arg.type, arg.named))\n+  if (ft32_pass_by_reference (cum_v, arg))\n     size = 4;\n   else if (arg.type)\n     {"}, {"sha": "02a551cbc383cb420f8486e98a494ec60cd89240", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=52090e4dbd064f486af606e3f8a283dbddc7c18a", "patch": "@@ -3286,8 +3286,7 @@ ix86_function_arg (cumulative_args_t cum_v, machine_mode omode,\n    appropriate for passing a pointer to that type.  */\n \n static bool\n-ix86_pass_by_reference (cumulative_args_t cum_v, machine_mode mode,\n-\t\t\tconst_tree type, bool)\n+ix86_pass_by_reference (cumulative_args_t cum_v, const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n \n@@ -3298,9 +3297,9 @@ ix86_pass_by_reference (cumulative_args_t cum_v, machine_mode mode,\n       /* See Windows x64 Software Convention.  */\n       if (call_abi == MS_ABI)\n \t{\n-\t  HOST_WIDE_INT msize = GET_MODE_SIZE (mode);\n+\t  HOST_WIDE_INT msize = GET_MODE_SIZE (arg.mode);\n \n-\t  if (type)\n+\t  if (tree type = arg.type)\n \t    {\n \t      /* Arrays are passed by reference.  */\n \t      if (TREE_CODE (type) == ARRAY_TYPE)\n@@ -3317,7 +3316,7 @@ ix86_pass_by_reference (cumulative_args_t cum_v, machine_mode mode,\n \t  /* __m128 is passed by reference.  */\n \t  return msize != 1 && msize != 2 && msize != 4 && msize != 8;\n \t}\n-      else if (type && int_size_in_bytes (type) == -1)\n+      else if (arg.type && int_size_in_bytes (arg.type) == -1)\n \treturn true;\n     }\n "}, {"sha": "db54423322333fafe071daba6e2caed7c3924b5f", "filename": "gcc/config/iq2000/iq2000.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.c?ref=52090e4dbd064f486af606e3f8a283dbddc7c18a", "patch": "@@ -159,8 +159,8 @@ static int  iq2000_address_cost       (rtx, machine_mode, addr_space_t,\n \t\t\t\t       bool);\n static section *iq2000_select_section (tree, int, unsigned HOST_WIDE_INT);\n static rtx  iq2000_legitimize_address (rtx, rtx, machine_mode);\n-static bool iq2000_pass_by_reference  (cumulative_args_t, machine_mode,\n-\t\t\t\t       const_tree, bool);\n+static bool iq2000_pass_by_reference  (cumulative_args_t,\n+\t\t\t\t       const function_arg_info &);\n static int  iq2000_arg_partial_bytes  (cumulative_args_t,\n \t\t\t\t       const function_arg_info &arg);\n static rtx iq2000_function_arg\t      (cumulative_args_t,\n@@ -2292,32 +2292,32 @@ iq2000_function_value_regno_p (const unsigned int regno)\n /* Return true when an argument must be passed by reference.  */\n \n static bool\n-iq2000_pass_by_reference (cumulative_args_t cum_v, machine_mode mode,\n-\t\t\t  const_tree type, bool named ATTRIBUTE_UNUSED)\n+iq2000_pass_by_reference (cumulative_args_t cum_v,\n+\t\t\t  const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   int size;\n \n   /* We must pass by reference if we would be both passing in registers\n      and the stack.  This is because any subsequent partial arg would be\n      handled incorrectly in this case.  */\n-  if (cum && targetm.calls.must_pass_in_stack (mode, type))\n+  if (cum && targetm.calls.must_pass_in_stack (arg.mode, arg.type))\n      {\n        /* Don't pass the actual CUM to FUNCTION_ARG, because we would\n \t  get double copies of any offsets generated for small structs\n \t  passed in registers.  */\n        CUMULATIVE_ARGS temp;\n \n        temp = *cum;\n-       if (iq2000_function_arg (pack_cumulative_args (&temp), mode, type, named)\n-\t   != 0)\n+       if (iq2000_function_arg (pack_cumulative_args (&temp), arg.mode,\n+\t\t\t\targ.type, arg.named) != 0)\n \t return 1;\n      }\n \n-  if (type == NULL_TREE || mode == DImode || mode == DFmode)\n+  if (arg.type == NULL_TREE || arg.mode == DImode || arg.mode == DFmode)\n     return 0;\n \n-  size = int_size_in_bytes (type);\n+  size = int_size_in_bytes (arg.type);\n   return size == -1 || size > UNITS_PER_WORD;\n }\n "}, {"sha": "12249abb58460023494f4286aa9dfddf0b4aadc4", "filename": "gcc/config/m32c/m32c.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2Fm32c%2Fm32c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2Fm32c%2Fm32c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.c?ref=52090e4dbd064f486af606e3f8a283dbddc7c18a", "patch": "@@ -78,8 +78,8 @@ static bool m32c_legitimate_address_p (machine_mode, rtx, bool);\n static bool m32c_addr_space_legitimate_address_p (machine_mode, rtx, bool, addr_space_t);\n static rtx m32c_function_arg (cumulative_args_t, machine_mode,\n \t\t\t      const_tree, bool);\n-static bool m32c_pass_by_reference (cumulative_args_t, machine_mode,\n-\t\t\t\t    const_tree, bool);\n+static bool m32c_pass_by_reference (cumulative_args_t,\n+\t\t\t\t    const function_arg_info &);\n static void m32c_function_arg_advance (cumulative_args_t, machine_mode,\n \t\t\t\t       const_tree, bool);\n static unsigned int m32c_function_arg_boundary (machine_mode, const_tree);\n@@ -1373,10 +1373,7 @@ m32c_function_arg (cumulative_args_t ca_v,\n #undef TARGET_PASS_BY_REFERENCE\n #define TARGET_PASS_BY_REFERENCE m32c_pass_by_reference\n static bool\n-m32c_pass_by_reference (cumulative_args_t ca ATTRIBUTE_UNUSED,\n-\t\t\tmachine_mode mode ATTRIBUTE_UNUSED,\n-\t\t\tconst_tree type ATTRIBUTE_UNUSED,\n-\t\t\tbool named ATTRIBUTE_UNUSED)\n+m32c_pass_by_reference (cumulative_args_t, const function_arg_info &)\n {\n   return 0;\n }"}, {"sha": "7ee4fed84ef45d0e67d72e3036a64bc40c47d15f", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=52090e4dbd064f486af606e3f8a283dbddc7c18a", "patch": "@@ -91,8 +91,8 @@ static void m32r_setup_incoming_varargs (cumulative_args_t, machine_mode,\n static void init_idents (void);\n static bool m32r_rtx_costs (rtx, machine_mode, int, int, int *, bool speed);\n static int m32r_memory_move_cost (machine_mode, reg_class_t, bool);\n-static bool m32r_pass_by_reference (cumulative_args_t, machine_mode,\n-\t\t\t\t    const_tree, bool);\n+static bool m32r_pass_by_reference (cumulative_args_t,\n+\t\t\t\t    const function_arg_info &arg);\n static int m32r_arg_partial_bytes (cumulative_args_t,\n \t\t\t\t   const function_arg_info &);\n static rtx m32r_function_arg (cumulative_args_t, machine_mode,\n@@ -680,20 +680,12 @@ memreg_operand (rtx op, machine_mode mode ATTRIBUTE_UNUSED)\n   return MEM_P (op) && REG_P (XEXP (op, 0));\n }\n \n-/* Return nonzero if TYPE must be passed by indirect reference.  */\n+/* Return nonzero if ARG must be passed by indirect reference.  */\n \n static bool\n-m32r_pass_by_reference (cumulative_args_t ca ATTRIBUTE_UNUSED,\n-\t\t\tmachine_mode mode, const_tree type,\n-\t\t\tbool named ATTRIBUTE_UNUSED)\n+m32r_pass_by_reference (cumulative_args_t, const function_arg_info &arg)\n {\n-  int size;\n-\n-  if (type)\n-    size = int_size_in_bytes (type);\n-  else\n-    size = GET_MODE_SIZE (mode);\n-\n+  int size = arg.type_size_in_bytes ();\n   return (size < 0 || size > 8);\n }\n \f\n@@ -1251,8 +1243,8 @@ static bool\n m32r_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)\n {\n   cumulative_args_t dummy = pack_cumulative_args (NULL);\n-\n-  return m32r_pass_by_reference (dummy, TYPE_MODE (type), type, false);\n+  function_arg_info arg (const_cast<tree> (type), /*named=*/false);\n+  return m32r_pass_by_reference (dummy, arg);\n }\n \n /* Worker function for TARGET_FUNCTION_VALUE.  */"}, {"sha": "8a8adb9a3540c0f0ccef2d2de43ebd42b2395717", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=52090e4dbd064f486af606e3f8a283dbddc7c18a", "patch": "@@ -6235,27 +6235,25 @@ mips_pad_reg_upward (machine_mode mode, tree type)\n /* Return nonzero when an argument must be passed by reference.  */\n \n static bool\n-mips_pass_by_reference (cumulative_args_t cum ATTRIBUTE_UNUSED,\n-\t\t\tmachine_mode mode, const_tree type,\n-\t\t\tbool named ATTRIBUTE_UNUSED)\n+mips_pass_by_reference (cumulative_args_t, const function_arg_info &arg)\n {\n   if (mips_abi == ABI_EABI)\n     {\n       int size;\n \n       /* ??? How should SCmode be handled?  */\n-      if (mode == DImode || mode == DFmode\n-\t  || mode == DQmode || mode == UDQmode\n-\t  || mode == DAmode || mode == UDAmode)\n+      if (arg.mode == DImode || arg.mode == DFmode\n+\t  || arg.mode == DQmode || arg.mode == UDQmode\n+\t  || arg.mode == DAmode || arg.mode == UDAmode)\n \treturn 0;\n \n-      size = type ? int_size_in_bytes (type) : GET_MODE_SIZE (mode);\n+      size = arg.type_size_in_bytes ();\n       return size == -1 || size > UNITS_PER_WORD;\n     }\n   else\n     {\n       /* If we have a variable-sized parameter, we have no choice.  */\n-      return targetm.calls.must_pass_in_stack (mode, type);\n+      return targetm.calls.must_pass_in_stack (arg.mode, arg.type);\n     }\n }\n "}, {"sha": "1b3a60916165f253b9ea2e9c58ffbd8f6b1b7fd7", "filename": "gcc/config/mmix/mmix.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2Fmmix%2Fmmix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2Fmmix%2Fmmix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.c?ref=52090e4dbd064f486af606e3f8a283dbddc7c18a", "patch": "@@ -161,7 +161,7 @@ static rtx mmix_function_value (const_tree, const_tree, bool);\n static rtx mmix_libcall_value (machine_mode, const_rtx);\n static bool mmix_function_value_regno_p (const unsigned int);\n static bool mmix_pass_by_reference (cumulative_args_t,\n-\t\t\t\t    machine_mode, const_tree, bool);\n+\t\t\t\t    const function_arg_info &);\n static bool mmix_frame_pointer_required (void);\n static void mmix_asm_trampoline_template (FILE *);\n static void mmix_trampoline_init (rtx, tree, rtx);\n@@ -690,17 +690,17 @@ mmix_function_incoming_arg (cumulative_args_t argsp,\n    everything that goes by value.  */\n \n static bool\n-mmix_pass_by_reference (cumulative_args_t argsp_v, machine_mode mode,\n-\t\t\tconst_tree type, bool named ATTRIBUTE_UNUSED)\n+mmix_pass_by_reference (cumulative_args_t argsp_v,\n+\t\t\tconst function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *argsp = get_cumulative_args (argsp_v);\n \n   /* FIXME: Check: I'm not sure the must_pass_in_stack check is\n      necessary.  */\n-  if (targetm.calls.must_pass_in_stack (mode, type))\n+  if (targetm.calls.must_pass_in_stack (arg.mode, arg.type))\n     return true;\n \n-  if (MMIX_FUNCTION_ARG_SIZE (mode, type) > 8\n+  if (MMIX_FUNCTION_ARG_SIZE (arg.mode, arg.type) > 8\n       && !TARGET_LIBFUNC\n       && (!argsp || !argsp->lib))\n     return true;"}, {"sha": "f17c8c3859af4160ba140de945890789224a6524", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=52090e4dbd064f486af606e3f8a283dbddc7c18a", "patch": "@@ -1526,17 +1526,9 @@ mn10300_va_start (tree valist, rtx nextarg)\n /* Return true when a parameter should be passed by reference.  */\n \n static bool\n-mn10300_pass_by_reference (cumulative_args_t cum ATTRIBUTE_UNUSED,\n-\t\t\t   machine_mode mode, const_tree type,\n-\t\t\t   bool named ATTRIBUTE_UNUSED)\n+mn10300_pass_by_reference (cumulative_args_t, const function_arg_info &arg)\n {\n-  unsigned HOST_WIDE_INT size;\n-\n-  if (type)\n-    size = int_size_in_bytes (type);\n-  else\n-    size = GET_MODE_SIZE (mode);\n-\n+  unsigned HOST_WIDE_INT size = arg.type_size_in_bytes ();\n   return (size > 8 || size == 0);\n }\n "}, {"sha": "e8eaedf2b98eccf0d2f670c1979430f67dc2fdba", "filename": "gcc/config/moxie/moxie.c", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2Fmoxie%2Fmoxie.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2Fmoxie%2Fmoxie.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmoxie%2Fmoxie.c?ref=52090e4dbd064f486af606e3f8a283dbddc7c18a", "patch": "@@ -451,25 +451,15 @@ moxie_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n \t  : *cum);\n }\n \n-/* Return non-zero if the function argument described by TYPE is to be\n+/* Return non-zero if the function argument described by ARG is to be\n    passed by reference.  */\n \n static bool\n-moxie_pass_by_reference (cumulative_args_t cum ATTRIBUTE_UNUSED,\n-\t\t\t machine_mode mode, const_tree type,\n-\t\t\t bool named ATTRIBUTE_UNUSED)\n+moxie_pass_by_reference (cumulative_args_t, const function_arg_info &arg)\n {\n-  unsigned HOST_WIDE_INT size;\n-\n-  if (type)\n-    {\n-      if (AGGREGATE_TYPE_P (type))\n-\treturn true;\n-      size = int_size_in_bytes (type);\n-    }\n-  else\n-    size = GET_MODE_SIZE (mode);\n-\n+  if (arg.aggregate_type_p ())\n+    return true;\n+  unsigned HOST_WIDE_INT size = arg.type_size_in_bytes ();\n   return size > 4*6;\n }\n \n@@ -486,7 +476,7 @@ moxie_arg_partial_bytes (cumulative_args_t cum_v, const function_arg_info &arg)\n   if (*cum >= 8)\n     return 0;\n \n-  if (moxie_pass_by_reference (cum_v, arg.mode, arg.type, arg.named))\n+  if (moxie_pass_by_reference (cum_v, arg))\n     size = 4;\n   else if (arg.type)\n     {"}, {"sha": "5eac09c0dab9d357e8b215a7f6ad245ce85cc167", "filename": "gcc/config/msp430/msp430.c", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2Fmsp430%2Fmsp430.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2Fmsp430%2Fmsp430.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430.c?ref=52090e4dbd064f486af606e3f8a283dbddc7c18a", "patch": "@@ -744,14 +744,11 @@ msp430_arg_partial_bytes (cumulative_args_t cap, const function_arg_info &arg)\n #define TARGET_PASS_BY_REFERENCE msp430_pass_by_reference\n \n static bool\n-msp430_pass_by_reference (cumulative_args_t cap ATTRIBUTE_UNUSED,\n-\t\t\t  machine_mode mode,\n-\t\t\t  const_tree type,\n-\t\t\t  bool named ATTRIBUTE_UNUSED)\n-{\n-  return (mode == BLKmode\n-\t  || (type && TREE_CODE (type) == RECORD_TYPE)\n-\t  || (type && TREE_CODE (type) == UNION_TYPE));\n+msp430_pass_by_reference (cumulative_args_t, const function_arg_info &arg)\n+{\n+  return (arg.mode == BLKmode\n+\t  || (arg.type && TREE_CODE (arg.type) == RECORD_TYPE)\n+\t  || (arg.type && TREE_CODE (arg.type) == UNION_TYPE));\n }\n \n #undef  TARGET_CALLEE_COPIES"}, {"sha": "82266ff8bf09b5540667d8d2aa2c3332e27ae0b7", "filename": "gcc/config/nvptx/nvptx.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.c?ref=52090e4dbd064f486af606e3f8a283dbddc7c18a", "patch": "@@ -633,11 +633,9 @@ nvptx_function_value_regno_p (const unsigned int regno)\n    reference in memory.  */\n \n static bool\n-nvptx_pass_by_reference (cumulative_args_t ARG_UNUSED (cum),\n-\t\t\t machine_mode mode, const_tree type,\n-\t\t\t bool ARG_UNUSED (named))\n+nvptx_pass_by_reference (cumulative_args_t, const function_arg_info &arg)\n {\n-  return pass_in_memory (mode, type, false);\n+  return pass_in_memory (arg.mode, arg.type, false);\n }\n \n /* Implement TARGET_RETURN_IN_MEMORY.  */"}, {"sha": "3a55d11321bf162821c6f9abbdce00bf4baf6790", "filename": "gcc/config/or1k/or1k.c", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2For1k%2For1k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2For1k%2For1k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2For1k%2For1k.c?ref=52090e4dbd064f486af606e3f8a283dbddc7c18a", "patch": "@@ -928,23 +928,16 @@ or1k_legitimate_constant_p (machine_mode, rtx x)\n #define TARGET_LEGITIMATE_CONSTANT_P or1k_legitimate_constant_p\n \n /* Worker for TARGET_PASS_BY_REFERENCE.\n-   Returns true if an argument of TYPE in MODE should be passed by reference\n-   as required by the OpenRISC ABI.  On OpenRISC structures, unions and\n+   Returns true if an argument ARG should be passed by reference as\n+   required by the OpenRISC ABI.  On OpenRISC structures, unions and\n    arguments larger than 64-bits are passed by reference.  */\n \n static bool\n-or1k_pass_by_reference (cumulative_args_t, machine_mode mode,\n-\t\t\tconst_tree type, bool)\n+or1k_pass_by_reference (cumulative_args_t, const function_arg_info &arg)\n {\n-  HOST_WIDE_INT size;\n-  if (type)\n-    {\n-      if (AGGREGATE_TYPE_P (type))\n-\treturn true;\n-      size = int_size_in_bytes (type);\n-    }\n-  else\n-    size = GET_MODE_SIZE (mode);\n+  if (arg.aggregate_type_p ())\n+    return true;\n+  HOST_WIDE_INT size = arg.type_size_in_bytes ();\n   return size < 0 || size > 8;\n }\n "}, {"sha": "d72221ca8029ad2f1c8f864cad4a670e02792f93", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=52090e4dbd064f486af606e3f8a283dbddc7c18a", "patch": "@@ -164,8 +164,8 @@ static void output_deferred_profile_counters (void) ATTRIBUTE_UNUSED;\n static void pa_file_end (void);\n static void pa_init_libfuncs (void);\n static rtx pa_struct_value_rtx (tree, int);\n-static bool pa_pass_by_reference (cumulative_args_t, machine_mode,\n-\t\t\t\t  const_tree, bool);\n+static bool pa_pass_by_reference (cumulative_args_t,\n+\t\t\t\t  const function_arg_info &);\n static int pa_arg_partial_bytes (cumulative_args_t, const function_arg_info &);\n static void pa_function_arg_advance (cumulative_args_t, machine_mode,\n \t\t\t\t     const_tree, bool);\n@@ -6222,17 +6222,9 @@ pa_eh_return_handler_rtx (void)\n    or updates the ABI.  */\n \n static bool\n-pa_pass_by_reference (cumulative_args_t ca ATTRIBUTE_UNUSED,\n-\t\t      machine_mode mode, const_tree type,\n-\t\t      bool named ATTRIBUTE_UNUSED)\n+pa_pass_by_reference (cumulative_args_t, const function_arg_info &arg)\n {\n-  HOST_WIDE_INT size;\n-\n-  if (type)\n-    size = int_size_in_bytes (type);\n-  else\n-    size = GET_MODE_SIZE (mode);\n-\n+  HOST_WIDE_INT size = arg.type_size_in_bytes ();\n   if (TARGET_64BIT)\n     return size <= 0;\n   else"}, {"sha": "659e3ed8587a2a6f957ec6bcf0e6e0ea73be058b", "filename": "gcc/config/riscv/riscv.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2Friscv%2Friscv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2Friscv%2Friscv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.c?ref=52090e4dbd064f486af606e3f8a283dbddc7c18a", "patch": "@@ -2815,10 +2815,9 @@ riscv_function_value (const_tree type, const_tree func, machine_mode mode)\n /* Implement TARGET_PASS_BY_REFERENCE. */\n \n static bool\n-riscv_pass_by_reference (cumulative_args_t cum_v, machine_mode mode,\n-\t\t\t const_tree type, bool named)\n+riscv_pass_by_reference (cumulative_args_t cum_v, const function_arg_info &arg)\n {\n-  HOST_WIDE_INT size = type ? int_size_in_bytes (type) : GET_MODE_SIZE (mode);\n+  HOST_WIDE_INT size = arg.type_size_in_bytes ();\n   struct riscv_arg_info info;\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n \n@@ -2828,7 +2827,7 @@ riscv_pass_by_reference (cumulative_args_t cum_v, machine_mode mode,\n   if (cum != NULL)\n     {\n       /* Don't pass by reference if we can use a floating-point register.  */\n-      riscv_get_arg_info (&info, cum, mode, type, named, false);\n+      riscv_get_arg_info (&info, cum, arg.mode, arg.type, arg.named, false);\n       if (info.num_fprs)\n \treturn false;\n     }\n@@ -2848,7 +2847,8 @@ riscv_return_in_memory (const_tree type, const_tree fndecl ATTRIBUTE_UNUSED)\n   /* The rules for returning in memory are the same as for passing the\n      first named argument by reference.  */\n   memset (&args, 0, sizeof args);\n-  return riscv_pass_by_reference (cum, TYPE_MODE (type), type, true);\n+  function_arg_info arg (const_cast<tree> (type), /*named=*/true);\n+  return riscv_pass_by_reference (cum, arg);\n }\n \n /* Implement TARGET_SETUP_INCOMING_VARARGS.  */"}, {"sha": "4f006aa511d0deed4da174b853ecbd676fe3341d", "filename": "gcc/config/rs6000/rs6000-call.c", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2Frs6000%2Frs6000-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2Frs6000%2Frs6000-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-call.c?ref=52090e4dbd064f486af606e3f8a283dbddc7c18a", "patch": "@@ -2111,29 +2111,27 @@ rs6000_arg_partial_bytes (cumulative_args_t cum_v,\n    reference.  */\n \n bool\n-rs6000_pass_by_reference (cumulative_args_t cum ATTRIBUTE_UNUSED,\n-\t\t\t  machine_mode mode, const_tree type,\n-\t\t\t  bool named ATTRIBUTE_UNUSED)\n+rs6000_pass_by_reference (cumulative_args_t, const function_arg_info &arg)\n {\n-  if (!type)\n+  if (!arg.type)\n     return 0;\n \n   if (DEFAULT_ABI == ABI_V4 && TARGET_IEEEQUAD\n-      && FLOAT128_IEEE_P (TYPE_MODE (type)))\n+      && FLOAT128_IEEE_P (TYPE_MODE (arg.type)))\n     {\n       if (TARGET_DEBUG_ARG)\n \tfprintf (stderr, \"function_arg_pass_by_reference: V4 IEEE 128-bit\\n\");\n       return 1;\n     }\n \n-  if (DEFAULT_ABI == ABI_V4 && AGGREGATE_TYPE_P (type))\n+  if (DEFAULT_ABI == ABI_V4 && AGGREGATE_TYPE_P (arg.type))\n     {\n       if (TARGET_DEBUG_ARG)\n \tfprintf (stderr, \"function_arg_pass_by_reference: V4 aggregate\\n\");\n       return 1;\n     }\n \n-  if (int_size_in_bytes (type) < 0)\n+  if (int_size_in_bytes (arg.type) < 0)\n     {\n       if (TARGET_DEBUG_ARG)\n \tfprintf (stderr, \"function_arg_pass_by_reference: variable size\\n\");\n@@ -2142,16 +2140,16 @@ rs6000_pass_by_reference (cumulative_args_t cum ATTRIBUTE_UNUSED,\n \n   /* Allow -maltivec -mabi=no-altivec without warning.  Altivec vector\n      modes only exist for GCC vector types if -maltivec.  */\n-  if (TARGET_32BIT && !TARGET_ALTIVEC_ABI && ALTIVEC_VECTOR_MODE (mode))\n+  if (TARGET_32BIT && !TARGET_ALTIVEC_ABI && ALTIVEC_VECTOR_MODE (arg.mode))\n     {\n       if (TARGET_DEBUG_ARG)\n \tfprintf (stderr, \"function_arg_pass_by_reference: AltiVec\\n\");\n       return 1;\n     }\n \n   /* Pass synthetic vectors in memory.  */\n-  if (TREE_CODE (type) == VECTOR_TYPE\n-      && int_size_in_bytes (type) > (TARGET_ALTIVEC_ABI ? 16 : 8))\n+  if (TREE_CODE (arg.type) == VECTOR_TYPE\n+      && int_size_in_bytes (arg.type) > (TARGET_ALTIVEC_ABI ? 16 : 8))\n     {\n       static bool warned_for_pass_big_vectors = false;\n       if (TARGET_DEBUG_ARG)\n@@ -2200,7 +2198,7 @@ rs6000_parm_needs_stack (cumulative_args_t args_so_far, tree type)\n \n   /* See if this arg was passed by invisible reference.  */\n   if (pass_by_reference (get_cumulative_args (args_so_far),\n-\t\t\t TYPE_MODE (type), type, true))\n+\t\t\t function_arg_info (type, /*named=*/true)))\n     type = build_pointer_type (type);\n \n   /* Find mode as it is passed by the ABI.  */"}, {"sha": "96017825f6a64385d925e1c311260d26a5d76430", "filename": "gcc/config/rs6000/rs6000-internal.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2Frs6000%2Frs6000-internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2Frs6000%2Frs6000-internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-internal.h?ref=52090e4dbd064f486af606e3f8a283dbddc7c18a", "patch": "@@ -150,9 +150,8 @@ extern machine_mode rs6000_promote_function_mode (const_tree type ATTRIBUTE_UNUS\n extern bool rs6000_return_in_memory (const_tree type, \n \t\t\t\t     const_tree fntype ATTRIBUTE_UNUSED);\n extern bool rs6000_return_in_msb (const_tree valtype);\n-extern bool rs6000_pass_by_reference (cumulative_args_t cum ATTRIBUTE_UNUSED,\n-\t\t\t\t      machine_mode mode, const_tree type,\n-\t\t\t\t      bool named ATTRIBUTE_UNUSED);\n+extern bool rs6000_pass_by_reference (cumulative_args_t,\n+\t\t\t\t      const function_arg_info &);\n extern void setup_incoming_varargs (cumulative_args_t cum, machine_mode mode,\n \t\t\t\t    tree type, int *pretend_size ATTRIBUTE_UNUSED,\n \t\t\t\t    int no_rtl);"}, {"sha": "5be8f60692ccb373caef6cc6647a29c793a5d85f", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=52090e4dbd064f486af606e3f8a283dbddc7c18a", "patch": "@@ -11953,26 +11953,23 @@ s390_function_arg_integer (machine_mode mode, const_tree type)\n   return false;\n }\n \n-/* Return 1 if a function argument of type TYPE and mode MODE\n-   is to be passed by reference.  The ABI specifies that only\n-   structures of size 1, 2, 4, or 8 bytes are passed by value,\n-   all other structures (and complex numbers) are passed by\n-   reference.  */\n+/* Return 1 if a function argument ARG is to be passed by reference.\n+   The ABI specifies that only structures of size 1, 2, 4, or 8 bytes\n+   are passed by value, all other structures (and complex numbers) are\n+   passed by reference.  */\n \n static bool\n-s390_pass_by_reference (cumulative_args_t ca ATTRIBUTE_UNUSED,\n-\t\t\tmachine_mode mode, const_tree type,\n-\t\t\tbool named ATTRIBUTE_UNUSED)\n+s390_pass_by_reference (cumulative_args_t, const function_arg_info &arg)\n {\n-  int size = s390_function_arg_size (mode, type);\n+  int size = s390_function_arg_size (arg.mode, arg.type);\n \n-  if (s390_function_arg_vector (mode, type))\n+  if (s390_function_arg_vector (arg.mode, arg.type))\n     return false;\n \n   if (size > 8)\n     return true;\n \n-  if (type)\n+  if (tree type = arg.type)\n     {\n       if (AGGREGATE_TYPE_P (type) && exact_log2 (size) < 0)\n \treturn true;\n@@ -13349,7 +13346,7 @@ s390_call_saved_register_used (tree call_expr)\n       /* We assume that in the target function all parameters are\n \t named.  This only has an impact on vector argument register\n \t usage none of which is call-saved.  */\n-      if (pass_by_reference (&cum_v, mode, type, true))\n+      if (pass_by_reference (&cum_v, function_arg_info (type, /*named=*/true)))\n \t{\n \t  mode = Pmode;\n \t  type = build_pointer_type (type);"}, {"sha": "e84a3ddc0fcf31da7cc2dbc4f2c015a17296dbc0", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=52090e4dbd064f486af606e3f8a283dbddc7c18a", "patch": "@@ -294,8 +294,8 @@ static machine_mode sh_promote_function_mode (const_tree type,\n \t\t\t\t\t\t   int *punsignedp,\n \t\t\t\t\t\t   const_tree funtype,\n \t\t\t\t\t\t   int for_return);\n-static bool sh_pass_by_reference (cumulative_args_t, machine_mode,\n-\t\t\t\t  const_tree, bool);\n+static bool sh_pass_by_reference (cumulative_args_t,\n+\t\t\t\t  const function_arg_info &);\n static bool sh_callee_copies (cumulative_args_t, machine_mode,\n \t\t\t      const_tree, bool);\n static int sh_arg_partial_bytes (cumulative_args_t, const function_arg_info &);\n@@ -7899,12 +7899,11 @@ sh_promote_prototypes (const_tree type)\n }\n \n static bool\n-sh_pass_by_reference (cumulative_args_t cum_v, machine_mode mode,\n-\t\t      const_tree type, bool named ATTRIBUTE_UNUSED)\n+sh_pass_by_reference (cumulative_args_t cum_v, const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n \n-  if (targetm.calls.must_pass_in_stack (mode, type))\n+  if (targetm.calls.must_pass_in_stack (arg.mode, arg.type))\n     return true;\n \n   /* ??? std_gimplify_va_arg_expr passes NULL for cum.  That function"}, {"sha": "2c4c84a78c6f6cb86ee78a6462f65611c37b0679", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=52090e4dbd064f486af606e3f8a283dbddc7c18a", "patch": "@@ -655,7 +655,7 @@ static rtx sparc_legitimize_address (rtx, rtx, machine_mode);\n static rtx sparc_delegitimize_address (rtx);\n static bool sparc_mode_dependent_address_p (const_rtx, addr_space_t);\n static bool sparc_pass_by_reference (cumulative_args_t,\n-\t\t\t\t     machine_mode, const_tree, bool);\n+\t\t\t\t     const function_arg_info &);\n static void sparc_function_arg_advance (cumulative_args_t,\n \t\t\t\t\tmachine_mode, const_tree, bool);\n static rtx sparc_function_arg_1 (cumulative_args_t,\n@@ -6743,10 +6743,10 @@ sparc_strict_argument_naming (cumulative_args_t ca ATTRIBUTE_UNUSED)\n    Specify whether to pass the argument by reference.  */\n \n static bool\n-sparc_pass_by_reference (cumulative_args_t cum ATTRIBUTE_UNUSED,\n-\t\t\t machine_mode mode, const_tree type,\n-\t\t\t bool named ATTRIBUTE_UNUSED)\n+sparc_pass_by_reference (cumulative_args_t, const function_arg_info &arg)\n {\n+  tree type = arg.type;\n+  machine_mode mode = arg.mode;\n   if (TARGET_ARCH32)\n     /* Original SPARC 32-bit ABI says that structures and unions,\n        and quad-precision floats are passed by reference."}, {"sha": "43a25c4df122de671d72fd6765f2e9712351cc5c", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=52090e4dbd064f486af606e3f8a283dbddc7c18a", "patch": "@@ -3902,11 +3902,9 @@ spu_function_arg_padding (machine_mode, const_tree)\n \n /* Variable sized types are passed by reference.  */\n static bool\n-spu_pass_by_reference (cumulative_args_t cum ATTRIBUTE_UNUSED,\n-\t\t       machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t       const_tree type, bool named ATTRIBUTE_UNUSED)\n+spu_pass_by_reference (cumulative_args_t, const function_arg_info &arg)\n {\n-  return type && TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST;\n+  return arg.type && TREE_CODE (TYPE_SIZE (arg.type)) != INTEGER_CST;\n }\n \f\n "}, {"sha": "f800e9e4642620c6d4a3ffd6edaf991beec45142", "filename": "gcc/config/tilegx/tilegx.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2Ftilegx%2Ftilegx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2Ftilegx%2Ftilegx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Ftilegx.c?ref=52090e4dbd064f486af606e3f8a283dbddc7c18a", "patch": "@@ -159,12 +159,11 @@ tilegx_function_ok_for_sibcall (tree decl, tree exp ATTRIBUTE_UNUSED)\n /* Implement TARGET_PASS_BY_REFERENCE.  Variable sized types are\n    passed by reference.  */\n static bool\n-tilegx_pass_by_reference (cumulative_args_t cum ATTRIBUTE_UNUSED,\n-\t\t\t  machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t\t  const_tree type, bool named ATTRIBUTE_UNUSED)\n+tilegx_pass_by_reference (cumulative_args_t, const function_arg_info &arg)\n {\n-  return (type && TYPE_SIZE (type)\n-\t  && TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST);\n+  return (arg.type\n+\t  && TYPE_SIZE (arg.type)\n+\t  && TREE_CODE (TYPE_SIZE (arg.type)) != INTEGER_CST);\n }\n \n "}, {"sha": "483a897a6d896f019f6f9bd0d9733e1a7b97db49", "filename": "gcc/config/tilepro/tilepro.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2Ftilepro%2Ftilepro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2Ftilepro%2Ftilepro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilepro%2Ftilepro.c?ref=52090e4dbd064f486af606e3f8a283dbddc7c18a", "patch": "@@ -134,12 +134,11 @@ tilepro_function_ok_for_sibcall (tree decl, tree exp ATTRIBUTE_UNUSED)\n /* Implement TARGET_PASS_BY_REFERENCE.  Variable sized types are\n    passed by reference.  */\n static bool\n-tilepro_pass_by_reference (cumulative_args_t cum ATTRIBUTE_UNUSED,\n-\t\t\t   machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t\t   const_tree type, bool named ATTRIBUTE_UNUSED)\n+tilepro_pass_by_reference (cumulative_args_t, const function_arg_info &arg)\n {\n-  return (type && TYPE_SIZE (type)\n-\t  && TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST);\n+  return (arg.type\n+\t  && TYPE_SIZE (arg.type)\n+\t  && TREE_CODE (TYPE_SIZE (arg.type)) != INTEGER_CST);\n }\n \n "}, {"sha": "92ec84576a36269ebbc251a38fdd40a497be71c3", "filename": "gcc/config/v850/v850.c", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=52090e4dbd064f486af606e3f8a283dbddc7c18a", "patch": "@@ -110,20 +110,12 @@ v850_all_frame_related (rtx par)\n    Specify whether to pass the argument by reference.  */\n \n static bool\n-v850_pass_by_reference (cumulative_args_t cum ATTRIBUTE_UNUSED,\n-\t\t\tmachine_mode mode, const_tree type,\n-\t\t\tbool named ATTRIBUTE_UNUSED)\n+v850_pass_by_reference (cumulative_args_t, const function_arg_info &arg)\n {\n-  unsigned HOST_WIDE_INT size;\n-\n   if (!TARGET_GCC_ABI)\n     return 0;\n \n-  if (type)\n-    size = int_size_in_bytes (type);\n-  else\n-    size = GET_MODE_SIZE (mode);\n-\n+  unsigned HOST_WIDE_INT size = arg.type_size_in_bytes ();\n   return size > 8;\n }\n "}, {"sha": "456bba200010420ef0456e2a2f3a1a4b850c9f6a", "filename": "gcc/config/visium/visium.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2Fvisium%2Fvisium.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fconfig%2Fvisium%2Fvisium.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvisium%2Fvisium.c?ref=52090e4dbd064f486af606e3f8a283dbddc7c18a", "patch": "@@ -158,8 +158,8 @@ static struct machine_function *visium_init_machine_status (void);\n \n /* Target hooks and TARGET_INITIALIZER  */\n \n-static bool visium_pass_by_reference (cumulative_args_t, machine_mode,\n-\t\t\t\t      const_tree, bool);\n+static bool visium_pass_by_reference (cumulative_args_t,\n+\t\t\t\t      const function_arg_info &);\n \n static rtx visium_function_arg (cumulative_args_t, machine_mode,\n \t\t\t\tconst_tree, bool);\n@@ -1310,11 +1310,9 @@ visium_reorg (void)\n /* Return true if an argument must be passed by indirect reference.  */\n \n static bool\n-visium_pass_by_reference (cumulative_args_t ca ATTRIBUTE_UNUSED,\n-\t\t\t  machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t\t  const_tree type,\n-\t\t\t  bool named ATTRIBUTE_UNUSED)\n+visium_pass_by_reference (cumulative_args_t, const function_arg_info &arg)\n {\n+  tree type = arg.type;\n   return type && (AGGREGATE_TYPE_P (type) || TREE_CODE (type) == VECTOR_TYPE);\n }\n "}, {"sha": "1a82bcc99b954d49455f92269ace29349075ac89", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=52090e4dbd064f486af606e3f8a283dbddc7c18a", "patch": "@@ -4076,11 +4076,11 @@ register to be used by the caller for this argument; likewise\n @code{TARGET_FUNCTION_INCOMING_ARG}, for the called function.\n @end deftypefn\n \n-@deftypefn {Target Hook} bool TARGET_PASS_BY_REFERENCE (cumulative_args_t @var{cum}, machine_mode @var{mode}, const_tree @var{type}, bool @var{named})\n-This target hook should return @code{true} if an argument at the\n+@deftypefn {Target Hook} bool TARGET_PASS_BY_REFERENCE (cumulative_args_t @var{cum}, const function_arg_info @var{&arg})\n+This target hook should return @code{true} if argument @var{arg} at the\n position indicated by @var{cum} should be passed by reference.  This\n predicate is queried after target independent reasons for being\n-passed by reference, such as @code{TREE_ADDRESSABLE (type)}.\n+passed by reference, such as @code{TREE_ADDRESSABLE (@var{arg}.type)}.\n \n If the hook returns true, a copy of that argument is made in memory and a\n pointer to the argument is passed instead of the argument itself."}, {"sha": "37223caee7659a8184e6bf8b189a99ad08df08af", "filename": "gcc/function.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=52090e4dbd064f486af606e3f8a283dbddc7c18a", "patch": "@@ -2454,13 +2454,15 @@ assign_parm_find_data_types (struct assign_parm_data_all *all, tree parm,\n     passed_type = TREE_TYPE (first_field (passed_type));\n \n   /* See if this arg was passed by invisible reference.  */\n-  if (pass_by_reference (&all->args_so_far_v, passed_mode,\n-\t\t\t passed_type, data->named_arg))\n-    {\n-      passed_type = nominal_type = build_pointer_type (passed_type);\n-      data->passed_pointer = true;\n-      passed_mode = nominal_mode = TYPE_MODE (nominal_type);\n-    }\n+  {\n+    function_arg_info arg (passed_type, passed_mode, data->named_arg);\n+    if (pass_by_reference (&all->args_so_far_v, arg))\n+      {\n+\tpassed_type = nominal_type = build_pointer_type (passed_type);\n+\tdata->passed_pointer = true;\n+\tpassed_mode = nominal_mode = TYPE_MODE (nominal_type);\n+      }\n+  }\n \n   /* Find mode as it is passed by the ABI.  */\n   unsignedp = TYPE_UNSIGNED (passed_type);"}, {"sha": "0e59cfb7246576ff8ff5ce90b0fabf6b0651f92f", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=52090e4dbd064f486af606e3f8a283dbddc7c18a", "patch": "@@ -42,6 +42,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimplify.h\"\n #include \"attribs.h\"\n #include \"debug.h\"\n+#include \"calls.h\"\n \n /* Data type for the expressions representing sizes of data types.\n    It is the first integer type laid out.  */\n@@ -1859,8 +1860,9 @@ compute_record_mode (tree type)\n        || (TREE_CODE (type) == UNION_TYPE\n \t   && (GET_MODE_CLASS (mode) == MODE_INT\n \t       || (GET_MODE_CLASS (mode) == MODE_PARTIAL_INT\n-\t\t   && targetm.calls.pass_by_reference (pack_cumulative_args (0),\n-\t\t\t\t\t\t       mode, type, 0)))))\n+\t\t   && (targetm.calls.pass_by_reference\n+\t\t       (pack_cumulative_args (0),\n+\t\t\tfunction_arg_info (type, mode, /*named=*/false)))))))\n       && mode != VOIDmode\n       && poly_int_tree_p (TYPE_SIZE (type), &type_size)\n       && known_eq (GET_MODE_BITSIZE (mode), type_size))"}, {"sha": "9e798bc6e00c16ab2b738add32ab0269ec30145a", "filename": "gcc/target.def", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=52090e4dbd064f486af606e3f8a283dbddc7c18a", "patch": "@@ -4450,18 +4450,18 @@ or 3-byte structure is returned at the most significant end of a\\n\\\n    from __builtin_va_arg.  */\n DEFHOOK\n (pass_by_reference,\n- \"This target hook should return @code{true} if an argument at the\\n\\\n+ \"This target hook should return @code{true} if argument @var{arg} at the\\n\\\n position indicated by @var{cum} should be passed by reference.  This\\n\\\n predicate is queried after target independent reasons for being\\n\\\n-passed by reference, such as @code{TREE_ADDRESSABLE (type)}.\\n\\\n+passed by reference, such as @code{TREE_ADDRESSABLE (@var{arg}.type)}.\\n\\\n \\n\\\n If the hook returns true, a copy of that argument is made in memory and a\\n\\\n pointer to the argument is passed instead of the argument itself.\\n\\\n The pointer is passed in whatever way is appropriate for passing a pointer\\n\\\n to that type.\",\n  bool,\n- (cumulative_args_t cum, machine_mode mode, const_tree type, bool named),\n- hook_bool_CUMULATIVE_ARGS_mode_tree_bool_false)\n+ (cumulative_args_t cum, const function_arg_info &arg),\n+ hook_bool_CUMULATIVE_ARGS_arg_info_false)\n \n DEFHOOK\n (expand_builtin_saveregs,"}, {"sha": "de144bf2f5bad1e7ae9f1bbc87e95861a8a0e3e3", "filename": "gcc/targhooks.c", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=52090e4dbd064f486af606e3f8a283dbddc7c18a", "patch": "@@ -323,11 +323,10 @@ default_cxx_get_cookie_size (tree type)\n    of the TARGET_PASS_BY_REFERENCE hook uses just MUST_PASS_IN_STACK.  */\n \n bool\n-hook_pass_by_reference_must_pass_in_stack (cumulative_args_t c ATTRIBUTE_UNUSED,\n-\tmachine_mode mode ATTRIBUTE_UNUSED, const_tree type ATTRIBUTE_UNUSED,\n-\tbool named_arg ATTRIBUTE_UNUSED)\n+hook_pass_by_reference_must_pass_in_stack (cumulative_args_t,\n+\t\t\t\t\t   const function_arg_info &arg)\n {\n-  return targetm.calls.must_pass_in_stack (mode, type);\n+  return targetm.calls.must_pass_in_stack (arg.mode, arg.type);\n }\n \n /* Return true if a parameter follows callee copies conventions.  This\n@@ -767,6 +766,13 @@ hook_bool_CUMULATIVE_ARGS_mode_tree_bool_true (\n   return true;\n }\n \n+bool\n+hook_bool_CUMULATIVE_ARGS_arg_info_false (cumulative_args_t,\n+\t\t\t\t\t  const function_arg_info &)\n+{\n+  return false;\n+}\n+\n int\n hook_int_CUMULATIVE_ARGS_arg_info_0 (cumulative_args_t,\n \t\t\t\t     const function_arg_info &)"}, {"sha": "2009f183c5fadaaa5d07b712c5f3f0403141f228", "filename": "gcc/targhooks.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=52090e4dbd064f486af606e3f8a283dbddc7c18a", "patch": "@@ -63,7 +63,7 @@ extern tree default_cxx_guard_type (void);\n extern tree default_cxx_get_cookie_size (tree);\n \n extern bool hook_pass_by_reference_must_pass_in_stack\n-  (cumulative_args_t, machine_mode mode, const_tree, bool);\n+  (cumulative_args_t, const function_arg_info &);\n extern bool hook_callee_copies_named\n   (cumulative_args_t ca, machine_mode, const_tree, bool);\n \n@@ -137,6 +137,8 @@ extern bool hook_bool_CUMULATIVE_ARGS_mode_tree_bool_false\n   (cumulative_args_t, machine_mode, const_tree, bool);\n extern bool hook_bool_CUMULATIVE_ARGS_mode_tree_bool_true\n   (cumulative_args_t, machine_mode, const_tree, bool);\n+extern bool hook_bool_CUMULATIVE_ARGS_arg_info_false\n+  (cumulative_args_t, const function_arg_info &);\n extern int hook_int_CUMULATIVE_ARGS_arg_info_0\n   (cumulative_args_t, const function_arg_info &);\n extern void hook_void_CUMULATIVE_ARGS_tree"}, {"sha": "87d5b03b2fd127c3ce4532706ca5fdb8e5e92a2e", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52090e4dbd064f486af606e3f8a283dbddc7c18a/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=52090e4dbd064f486af606e3f8a283dbddc7c18a", "patch": "@@ -6431,13 +6431,11 @@ prepare_call_arguments (basic_block bb, rtx_insn *insn)\n \tif (t && t != void_list_node)\n \t  {\n \t    tree argtype = TREE_VALUE (t);\n-\t    machine_mode mode = TYPE_MODE (argtype);\n \t    rtx reg;\n-\t    if (pass_by_reference (&args_so_far_v, mode, argtype, true))\n-\t      {\n-\t\targtype = build_pointer_type (argtype);\n-\t\tmode = TYPE_MODE (argtype);\n-\t      }\n+\t    function_arg_info orig_arg (argtype, /*named=*/true);\n+\t    if (pass_by_reference (&args_so_far_v, orig_arg))\n+\t      argtype = build_pointer_type (argtype);\n+\t    machine_mode mode = TYPE_MODE (argtype);\n \t    reg = targetm.calls.function_arg (args_so_far, mode,\n \t\t\t\t\t      argtype, true);\n \t    if (TREE_CODE (argtype) == REFERENCE_TYPE"}]}