{"sha": "6748787813f8080f853766877f6933bc0823c19d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njc0ODc4NzgxM2Y4MDgwZjg1Mzc2Njg3N2Y2OTMzYmMwODIzYzE5ZA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-09-29T00:56:44Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-09-29T00:56:44Z"}, "message": "runtime: copy runtime.go and runtime1.go from Go 1.7\n    \n    Also copy over cputicks.go, env_posix.go, vdso_none.go, stubs2.go, and a\n    part of os_linux.go.  Remove the corresponding functions from the C code\n    in libgo/go/runtime.  Add some transitional support functions to\n    stubs.go.  This converts several minor functions from C to Go.\n    \n    Reviewed-on: https://go-review.googlesource.com/29962\n\nFrom-SVN: r240609", "tree": {"sha": "6027c64554992aac2983e759bd0b0ac9d443369e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6027c64554992aac2983e759bd0b0ac9d443369e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6748787813f8080f853766877f6933bc0823c19d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6748787813f8080f853766877f6933bc0823c19d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6748787813f8080f853766877f6933bc0823c19d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6748787813f8080f853766877f6933bc0823c19d/comments", "author": null, "committer": null, "parents": [{"sha": "83194649d2ba2461b60be6e4b1a8db2b7d10412d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83194649d2ba2461b60be6e4b1a8db2b7d10412d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83194649d2ba2461b60be6e4b1a8db2b7d10412d"}], "stats": {"total": 1323, "additions": 927, "deletions": 396}, "files": [{"sha": "6e5d3c4675202a0d17cacd519da228d4c1d05a17", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6748787813f8080f853766877f6933bc0823c19d/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6748787813f8080f853766877f6933bc0823c19d/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=6748787813f8080f853766877f6933bc0823c19d", "patch": "@@ -1,4 +1,4 @@\n-c79a35411c1065c71add196fdeca6e5207a79248\n+e51657a576367c7a498c94baf985b79066fc082a\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "ee15aca24efeb91b04c2e1713fe2cd6455e5b2fd", "filename": "libgo/go/runtime/cputicks.go", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6748787813f8080f853766877f6933bc0823c19d/libgo%2Fgo%2Fruntime%2Fcputicks.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6748787813f8080f853766877f6933bc0823c19d/libgo%2Fgo%2Fruntime%2Fcputicks.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fcputicks.go?ref=6748787813f8080f853766877f6933bc0823c19d", "patch": "@@ -0,0 +1,9 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package runtime\n+\n+// careful: cputicks is not guaranteed to be monotonic!  In particular, we have\n+// noticed drift between cpus on certain os/arch combinations. See issue 8976.\n+func cputicks() int64"}, {"sha": "e076edb85d012f2f383709da45f6635cc82a9f5d", "filename": "libgo/go/runtime/env_posix.go", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6748787813f8080f853766877f6933bc0823c19d/libgo%2Fgo%2Fruntime%2Fenv_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6748787813f8080f853766877f6933bc0823c19d/libgo%2Fgo%2Fruntime%2Fenv_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fenv_posix.go?ref=6748787813f8080f853766877f6933bc0823c19d", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build darwin dragonfly freebsd linux nacl netbsd openbsd solaris windows\n+\n+package runtime\n+\n+func gogetenv(key string) string {\n+\tenv := environ()\n+\tif env == nil {\n+\t\tthrow(\"getenv before env init\")\n+\t}\n+\tfor _, s := range environ() {\n+\t\tif len(s) > len(key) && s[len(key)] == '=' && s[:len(key)] == key {\n+\t\t\treturn s[len(key)+1:]\n+\t\t}\n+\t}\n+\treturn \"\"\n+}"}, {"sha": "b13e3829423a2c3313406a7590ddbf4cedea986a", "filename": "libgo/go/runtime/export_test.go", "status": "modified", "additions": 10, "deletions": 37, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6748787813f8080f853766877f6933bc0823c19d/libgo%2Fgo%2Fruntime%2Fexport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6748787813f8080f853766877f6933bc0823c19d/libgo%2Fgo%2Fruntime%2Fexport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fexport_test.go?ref=6748787813f8080f853766877f6933bc0823c19d", "patch": "@@ -6,10 +6,6 @@\n \n package runtime\n \n-import (\n-\t\"unsafe\"\n-)\n-\n //var Fadd64 = fadd64\n //var Fsub64 = fsub64\n //var Fmul64 = fmul64\n@@ -103,20 +99,6 @@ var HashLoad = &hashLoad\n \n //type Uintreg uintreg\n \n-//extern __go_open\n-func open(path *byte, mode int32, perm int32) int32\n-\n-func Open(path *byte, mode int32, perm int32) int32 {\n-\treturn open(path, mode, perm)\n-}\n-\n-//extern close\n-func close(int32) int32\n-\n-func Close(fd int32) int32 {\n-\treturn close(fd)\n-}\n-\n /*\n func RunSchedLocalQueueTest() {\n \t_p_ := new(p)\n@@ -224,25 +206,13 @@ var IfaceHash = ifaceHash\n var MemclrBytes = memclrBytes\n */\n \n-//extern read\n-func read(fd int32, buf unsafe.Pointer, size int32) int32\n+var Open = open\n+var Close = closefd\n+var Read = read\n+var Write = write\n \n-func Read(fd int32, buf unsafe.Pointer, size int32) int32 {\n-\treturn read(fd, buf, size)\n-}\n-\n-//extern write\n-func write(fd int32, buf unsafe.Pointer, size int32) int32\n-\n-func Write(fd uintptr, buf unsafe.Pointer, size int32) int32 {\n-\treturn write(int32(fd), buf, size)\n-}\n-\n-func envs() []string\n-func setenvs([]string)\n-\n-var Envs = envs\n-var SetEnvs = setenvs\n+func Envs() []string     { return envs }\n+func SetEnvs(e []string) { envs = e }\n \n //var BigEndian = sys.BigEndian\n \n@@ -287,7 +257,10 @@ var ForceGCPeriod = &forcegcperiod\n // SetTracebackEnv is like runtime/debug.SetTraceback, but it raises\n // the \"environment\" traceback level, so later calls to\n // debug.SetTraceback (e.g., from testing timeouts) can't lower it.\n-func SetTracebackEnv(level string)\n+func SetTracebackEnv(level string) {\n+\tsetTraceback(level)\n+\ttraceback_env = traceback_cache\n+}\n \n /*\n var ReadUnaligned32 = readUnaligned32"}, {"sha": "c44e4e8287ef42b8b3eda80334b40a2cc9b3b39a", "filename": "libgo/go/runtime/os_linux.go", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6748787813f8080f853766877f6933bc0823c19d/libgo%2Fgo%2Fruntime%2Fos_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6748787813f8080f853766877f6933bc0823c19d/libgo%2Fgo%2Fruntime%2Fos_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fos_linux.go?ref=6748787813f8080f853766877f6933bc0823c19d", "patch": "@@ -0,0 +1,56 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package runtime\n+\n+import (\n+\t\"runtime/internal/sys\"\n+\t\"unsafe\"\n+)\n+\n+const (\n+\t_AT_NULL   = 0  // End of vector\n+\t_AT_PAGESZ = 6  // System physical page size\n+\t_AT_RANDOM = 25 // introduced in 2.6.29\n+)\n+\n+func sysargs(argc int32, argv **byte) {\n+\tn := argc + 1\n+\n+\t// skip over argv, envp to get to auxv\n+\tfor argv_index(argv, n) != nil {\n+\t\tn++\n+\t}\n+\n+\t// skip NULL separator\n+\tn++\n+\n+\t// now argv+n is auxv\n+\tauxv := (*[1 << 28]uintptr)(add(unsafe.Pointer(argv), uintptr(n)*sys.PtrSize))\n+\tfor i := 0; auxv[i] != _AT_NULL; i += 2 {\n+\t\ttag, val := auxv[i], auxv[i+1]\n+\t\tswitch tag {\n+\t\tcase _AT_RANDOM:\n+\t\t\t// The kernel provides a pointer to 16-bytes\n+\t\t\t// worth of random data.\n+\t\t\tstartupRandomData = (*[16]byte)(unsafe.Pointer(val))[:]\n+\n+\t\tcase _AT_PAGESZ:\n+\t\t\t// Check that the true physical page size is\n+\t\t\t// compatible with the runtime's assumed\n+\t\t\t// physical page size.\n+\t\t\tif sys.PhysPageSize < val {\n+\t\t\t\tprint(\"runtime: kernel page size (\", val, \") is larger than runtime page size (\", sys.PhysPageSize, \")\\n\")\n+\t\t\t\texit(1)\n+\t\t\t}\n+\t\t\tif sys.PhysPageSize%val != 0 {\n+\t\t\t\tprint(\"runtime: runtime page size (\", sys.PhysPageSize, \") is not a multiple of kernel page size (\", val, \")\\n\")\n+\t\t\t\texit(1)\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Commented out for gccgo for now.\n+\t\t// archauxv(tag, val)\n+\t}\n+}"}, {"sha": "23601e1fc6632dfa753408e3da2fa9fe5457e100", "filename": "libgo/go/runtime/runtime.go", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6748787813f8080f853766877f6933bc0823c19d/libgo%2Fgo%2Fruntime%2Fruntime.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6748787813f8080f853766877f6933bc0823c19d/libgo%2Fgo%2Fruntime%2Fruntime.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fruntime.go?ref=6748787813f8080f853766877f6933bc0823c19d", "patch": "@@ -0,0 +1,69 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package runtime\n+\n+import (\n+\t\"runtime/internal/atomic\"\n+\t_ \"unsafe\" // for go:linkname\n+)\n+\n+//go:generate go run wincallback.go\n+//go:generate go run mkduff.go\n+//go:generate go run mkfastlog2table.go\n+\n+// For gccgo, while we still have C runtime code, use go:linkname to\n+// rename some functions to themselves, so that the compiler will\n+// export them.\n+//\n+//go:linkname tickspersecond runtime.tickspersecond\n+\n+var ticks struct {\n+\tlock mutex\n+\tpad  uint32 // ensure 8-byte alignment of val on 386\n+\tval  uint64\n+}\n+\n+// Note: Called by runtime/pprof in addition to runtime code.\n+func tickspersecond() int64 {\n+\tr := int64(atomic.Load64(&ticks.val))\n+\tif r != 0 {\n+\t\treturn r\n+\t}\n+\tlock(&ticks.lock)\n+\tr = int64(ticks.val)\n+\tif r == 0 {\n+\t\tt0 := nanotime()\n+\t\tc0 := cputicks()\n+\t\tusleep(100 * 1000)\n+\t\tt1 := nanotime()\n+\t\tc1 := cputicks()\n+\t\tif t1 == t0 {\n+\t\t\tt1++\n+\t\t}\n+\t\tr = (c1 - c0) * 1000 * 1000 * 1000 / (t1 - t0)\n+\t\tif r == 0 {\n+\t\t\tr++\n+\t\t}\n+\t\tatomic.Store64(&ticks.val, uint64(r))\n+\t}\n+\tunlock(&ticks.lock)\n+\treturn r\n+}\n+\n+var envs []string\n+var argslice []string\n+\n+//go:linkname syscall_runtime_envs syscall.runtime_envs\n+func syscall_runtime_envs() []string { return append([]string{}, envs...) }\n+\n+//go:linkname os_runtime_args os.runtime_args\n+func os_runtime_args() []string { return append([]string{}, argslice...) }\n+\n+// Temporary, for the gccgo runtime code written in C.\n+//go:linkname get_envs runtime_get_envs\n+func get_envs() []string { return envs }\n+\n+//go:linkname get_args runtime_get_args\n+func get_args() []string { return argslice }"}, {"sha": "dea19da997f54c4723859e1ba3c63ded3b9c2ce5", "filename": "libgo/go/runtime/runtime1.go", "status": "added", "additions": 509, "deletions": 0, "changes": 509, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6748787813f8080f853766877f6933bc0823c19d/libgo%2Fgo%2Fruntime%2Fruntime1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6748787813f8080f853766877f6933bc0823c19d/libgo%2Fgo%2Fruntime%2Fruntime1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fruntime1.go?ref=6748787813f8080f853766877f6933bc0823c19d", "patch": "@@ -0,0 +1,509 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package runtime\n+\n+import (\n+\t\"runtime/internal/atomic\"\n+\t\"runtime/internal/sys\"\n+\t\"unsafe\"\n+)\n+\n+// For gccgo, while we still have C runtime code, use go:linkname to\n+// rename some functions to themselves, so that the compiler will\n+// export them.\n+//\n+//go:linkname gotraceback runtime.gotraceback\n+//go:linkname args runtime.args\n+//go:linkname goargs runtime.goargs\n+//go:linkname check runtime.check\n+//go:linkname goenvs_unix runtime.goenvs_unix\n+//go:linkname parsedebugvars runtime.parsedebugvars\n+//go:linkname timediv runtime.timediv\n+\n+// Keep a cached value to make gotraceback fast,\n+// since we call it on every call to gentraceback.\n+// The cached value is a uint32 in which the low bits\n+// are the \"crash\" and \"all\" settings and the remaining\n+// bits are the traceback value (0 off, 1 on, 2 include system).\n+const (\n+\ttracebackCrash = 1 << iota\n+\ttracebackAll\n+\ttracebackShift = iota\n+)\n+\n+var traceback_cache uint32 = 2 << tracebackShift\n+var traceback_env uint32\n+\n+// gotraceback returns the current traceback settings.\n+//\n+// If level is 0, suppress all tracebacks.\n+// If level is 1, show tracebacks, but exclude runtime frames.\n+// If level is 2, show tracebacks including runtime frames.\n+// If all is set, print all goroutine stacks. Otherwise, print just the current goroutine.\n+// If crash is set, crash (core dump, etc) after tracebacking.\n+//\n+//go:nosplit\n+func gotraceback() (level int32, all, crash bool) {\n+\t_g_ := getg()\n+\tall = _g_.m.throwing > 0\n+\tif _g_.m.traceback != 0 {\n+\t\tlevel = int32(_g_.m.traceback)\n+\t\treturn\n+\t}\n+\tt := atomic.Load(&traceback_cache)\n+\tcrash = t&tracebackCrash != 0\n+\tall = all || t&tracebackAll != 0\n+\tlevel = int32(t >> tracebackShift)\n+\treturn\n+}\n+\n+var (\n+\targc int32\n+\targv **byte\n+)\n+\n+// nosplit for use in linux startup sysargs\n+//go:nosplit\n+func argv_index(argv **byte, i int32) *byte {\n+\treturn *(**byte)(add(unsafe.Pointer(argv), uintptr(i)*sys.PtrSize))\n+}\n+\n+func args(c int32, v **byte) {\n+\targc = c\n+\targv = v\n+\tsysargs(c, v)\n+}\n+\n+func goargs() {\n+\tif GOOS == \"windows\" {\n+\t\treturn\n+\t}\n+\n+\targslice = make([]string, argc)\n+\tfor i := int32(0); i < argc; i++ {\n+\t\targslice[i] = gostringnocopy(argv_index(argv, i))\n+\t}\n+}\n+\n+func goenvs_unix() {\n+\t// TODO(austin): ppc64 in dynamic linking mode doesn't\n+\t// guarantee env[] will immediately follow argv. Might cause\n+\t// problems.\n+\tn := int32(0)\n+\tfor argv_index(argv, argc+1+n) != nil {\n+\t\tn++\n+\t}\n+\n+\tenvs = make([]string, n)\n+\tfor i := int32(0); i < n; i++ {\n+\t\tenvs[i] = gostring(argv_index(argv, argc+1+i))\n+\t}\n+}\n+\n+func environ() []string {\n+\treturn envs\n+}\n+\n+// TODO: These should be locals in testAtomic64, but we don't 8-byte\n+// align stack variables on 386.\n+var test_z64, test_x64 uint64\n+\n+func testAtomic64() {\n+\ttest_z64 = 42\n+\ttest_x64 = 0\n+\t// prefetcht0(uintptr(unsafe.Pointer(&test_z64)))\n+\t// prefetcht1(uintptr(unsafe.Pointer(&test_z64)))\n+\t// prefetcht2(uintptr(unsafe.Pointer(&test_z64)))\n+\t// prefetchnta(uintptr(unsafe.Pointer(&test_z64)))\n+\tif atomic.Cas64(&test_z64, test_x64, 1) {\n+\t\tthrow(\"cas64 failed\")\n+\t}\n+\tif test_x64 != 0 {\n+\t\tthrow(\"cas64 failed\")\n+\t}\n+\ttest_x64 = 42\n+\tif !atomic.Cas64(&test_z64, test_x64, 1) {\n+\t\tthrow(\"cas64 failed\")\n+\t}\n+\tif test_x64 != 42 || test_z64 != 1 {\n+\t\tthrow(\"cas64 failed\")\n+\t}\n+\tif atomic.Load64(&test_z64) != 1 {\n+\t\tthrow(\"load64 failed\")\n+\t}\n+\tatomic.Store64(&test_z64, (1<<40)+1)\n+\tif atomic.Load64(&test_z64) != (1<<40)+1 {\n+\t\tthrow(\"store64 failed\")\n+\t}\n+\tif atomic.Xadd64(&test_z64, (1<<40)+1) != (2<<40)+2 {\n+\t\tthrow(\"xadd64 failed\")\n+\t}\n+\tif atomic.Load64(&test_z64) != (2<<40)+2 {\n+\t\tthrow(\"xadd64 failed\")\n+\t}\n+\tif atomic.Xchg64(&test_z64, (3<<40)+3) != (2<<40)+2 {\n+\t\tthrow(\"xchg64 failed\")\n+\t}\n+\tif atomic.Load64(&test_z64) != (3<<40)+3 {\n+\t\tthrow(\"xchg64 failed\")\n+\t}\n+}\n+\n+func check() {\n+\n+\t// This doesn't currently work for gccgo.  Because escape\n+\t// analysis is not turned on by default, the code below that\n+\t// takes the address of local variables causes memory\n+\t// allocation, but this function is called before the memory\n+\t// allocator has been initialized.\n+\treturn\n+\n+\tvar (\n+\t\ta     int8\n+\t\tb     uint8\n+\t\tc     int16\n+\t\td     uint16\n+\t\te     int32\n+\t\tf     uint32\n+\t\tg     int64\n+\t\th     uint64\n+\t\ti, i1 float32\n+\t\tj, j1 float64\n+\t\tk, k1 unsafe.Pointer\n+\t\tl     *uint16\n+\t\tm     [4]byte\n+\t)\n+\ttype x1t struct {\n+\t\tx uint8\n+\t}\n+\ttype y1t struct {\n+\t\tx1 x1t\n+\t\ty  uint8\n+\t}\n+\tvar x1 x1t\n+\tvar y1 y1t\n+\n+\tif unsafe.Sizeof(a) != 1 {\n+\t\tthrow(\"bad a\")\n+\t}\n+\tif unsafe.Sizeof(b) != 1 {\n+\t\tthrow(\"bad b\")\n+\t}\n+\tif unsafe.Sizeof(c) != 2 {\n+\t\tthrow(\"bad c\")\n+\t}\n+\tif unsafe.Sizeof(d) != 2 {\n+\t\tthrow(\"bad d\")\n+\t}\n+\tif unsafe.Sizeof(e) != 4 {\n+\t\tthrow(\"bad e\")\n+\t}\n+\tif unsafe.Sizeof(f) != 4 {\n+\t\tthrow(\"bad f\")\n+\t}\n+\tif unsafe.Sizeof(g) != 8 {\n+\t\tthrow(\"bad g\")\n+\t}\n+\tif unsafe.Sizeof(h) != 8 {\n+\t\tthrow(\"bad h\")\n+\t}\n+\tif unsafe.Sizeof(i) != 4 {\n+\t\tthrow(\"bad i\")\n+\t}\n+\tif unsafe.Sizeof(j) != 8 {\n+\t\tthrow(\"bad j\")\n+\t}\n+\tif unsafe.Sizeof(k) != sys.PtrSize {\n+\t\tthrow(\"bad k\")\n+\t}\n+\tif unsafe.Sizeof(l) != sys.PtrSize {\n+\t\tthrow(\"bad l\")\n+\t}\n+\tif unsafe.Sizeof(x1) != 1 {\n+\t\tthrow(\"bad unsafe.Sizeof x1\")\n+\t}\n+\tif unsafe.Offsetof(y1.y) != 1 {\n+\t\tthrow(\"bad offsetof y1.y\")\n+\t}\n+\tif unsafe.Sizeof(y1) != 2 {\n+\t\tthrow(\"bad unsafe.Sizeof y1\")\n+\t}\n+\n+\tif timediv(12345*1000000000+54321, 1000000000, &e) != 12345 || e != 54321 {\n+\t\tthrow(\"bad timediv\")\n+\t}\n+\n+\tvar z uint32\n+\tz = 1\n+\tif !atomic.Cas(&z, 1, 2) {\n+\t\tthrow(\"cas1\")\n+\t}\n+\tif z != 2 {\n+\t\tthrow(\"cas2\")\n+\t}\n+\n+\tz = 4\n+\tif atomic.Cas(&z, 5, 6) {\n+\t\tthrow(\"cas3\")\n+\t}\n+\tif z != 4 {\n+\t\tthrow(\"cas4\")\n+\t}\n+\n+\tz = 0xffffffff\n+\tif !atomic.Cas(&z, 0xffffffff, 0xfffffffe) {\n+\t\tthrow(\"cas5\")\n+\t}\n+\tif z != 0xfffffffe {\n+\t\tthrow(\"cas6\")\n+\t}\n+\n+\tk = unsafe.Pointer(uintptr(0xfedcb123))\n+\tif sys.PtrSize == 8 {\n+\t\tk = unsafe.Pointer(uintptr(k) << 10)\n+\t}\n+\tif casp(&k, nil, nil) {\n+\t\tthrow(\"casp1\")\n+\t}\n+\tk1 = add(k, 1)\n+\tif !casp(&k, k, k1) {\n+\t\tthrow(\"casp2\")\n+\t}\n+\tif k != k1 {\n+\t\tthrow(\"casp3\")\n+\t}\n+\n+\tm = [4]byte{1, 1, 1, 1}\n+\tatomic.Or8(&m[1], 0xf0)\n+\tif m[0] != 1 || m[1] != 0xf1 || m[2] != 1 || m[3] != 1 {\n+\t\tthrow(\"atomicor8\")\n+\t}\n+\n+\t*(*uint64)(unsafe.Pointer(&j)) = ^uint64(0)\n+\tif j == j {\n+\t\tthrow(\"float64nan\")\n+\t}\n+\tif !(j != j) {\n+\t\tthrow(\"float64nan1\")\n+\t}\n+\n+\t*(*uint64)(unsafe.Pointer(&j1)) = ^uint64(1)\n+\tif j == j1 {\n+\t\tthrow(\"float64nan2\")\n+\t}\n+\tif !(j != j1) {\n+\t\tthrow(\"float64nan3\")\n+\t}\n+\n+\t*(*uint32)(unsafe.Pointer(&i)) = ^uint32(0)\n+\tif i == i {\n+\t\tthrow(\"float32nan\")\n+\t}\n+\tif i == i {\n+\t\tthrow(\"float32nan1\")\n+\t}\n+\n+\t*(*uint32)(unsafe.Pointer(&i1)) = ^uint32(1)\n+\tif i == i1 {\n+\t\tthrow(\"float32nan2\")\n+\t}\n+\tif i == i1 {\n+\t\tthrow(\"float32nan3\")\n+\t}\n+\n+\ttestAtomic64()\n+\n+\t// if _FixedStack != round2(_FixedStack) {\n+\t// \tthrow(\"FixedStack is not power-of-2\")\n+\t// }\n+\n+\tif !checkASM() {\n+\t\tthrow(\"assembly checks failed\")\n+\t}\n+}\n+\n+type dbgVar struct {\n+\tname  string\n+\tvalue *int32\n+}\n+\n+// Holds variables parsed from GODEBUG env var,\n+// except for \"memprofilerate\" since there is an\n+// existing int var for that value, which may\n+// already have an initial value.\n+\n+// For gccgo we use a named type so that the C code can see the\n+// definition.\n+type debugVars struct {\n+\tallocfreetrace    int32\n+\tcgocheck          int32\n+\tefence            int32\n+\tgccheckmark       int32\n+\tgcpacertrace      int32\n+\tgcshrinkstackoff  int32\n+\tgcstackbarrieroff int32\n+\tgcstackbarrierall int32\n+\tgcstoptheworld    int32\n+\tgctrace           int32\n+\tinvalidptr        int32\n+\tsbrk              int32\n+\tscavenge          int32\n+\tscheddetail       int32\n+\tschedtrace        int32\n+\twbshadow          int32\n+}\n+\n+var debug debugVars\n+\n+// For gccgo's C code.\n+//extern runtime_setdebug\n+func runtime_setdebug(*debugVars)\n+\n+var dbgvars = []dbgVar{\n+\t{\"allocfreetrace\", &debug.allocfreetrace},\n+\t{\"cgocheck\", &debug.cgocheck},\n+\t{\"efence\", &debug.efence},\n+\t{\"gccheckmark\", &debug.gccheckmark},\n+\t{\"gcpacertrace\", &debug.gcpacertrace},\n+\t{\"gcshrinkstackoff\", &debug.gcshrinkstackoff},\n+\t{\"gcstackbarrieroff\", &debug.gcstackbarrieroff},\n+\t{\"gcstackbarrierall\", &debug.gcstackbarrierall},\n+\t{\"gcstoptheworld\", &debug.gcstoptheworld},\n+\t{\"gctrace\", &debug.gctrace},\n+\t{\"invalidptr\", &debug.invalidptr},\n+\t{\"sbrk\", &debug.sbrk},\n+\t{\"scavenge\", &debug.scavenge},\n+\t{\"scheddetail\", &debug.scheddetail},\n+\t{\"schedtrace\", &debug.schedtrace},\n+\t{\"wbshadow\", &debug.wbshadow},\n+}\n+\n+func parsedebugvars() {\n+\t// defaults\n+\tdebug.cgocheck = 1\n+\tdebug.invalidptr = 1\n+\n+\tfor p := gogetenv(\"GODEBUG\"); p != \"\"; {\n+\t\tfield := \"\"\n+\t\ti := index(p, \",\")\n+\t\tif i < 0 {\n+\t\t\tfield, p = p, \"\"\n+\t\t} else {\n+\t\t\tfield, p = p[:i], p[i+1:]\n+\t\t}\n+\t\ti = index(field, \"=\")\n+\t\tif i < 0 {\n+\t\t\tcontinue\n+\t\t}\n+\t\tkey, value := field[:i], field[i+1:]\n+\n+\t\t// Update MemProfileRate directly here since it\n+\t\t// is int, not int32, and should only be updated\n+\t\t// if specified in GODEBUG.\n+\t\tif key == \"memprofilerate\" {\n+\t\t\tMemProfileRate = atoi(value)\n+\t\t} else {\n+\t\t\tfor _, v := range dbgvars {\n+\t\t\t\tif v.name == key {\n+\t\t\t\t\t*v.value = int32(atoi(value))\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tsetTraceback(gogetenv(\"GOTRACEBACK\"))\n+\ttraceback_env = traceback_cache\n+\n+\t// if debug.gcstackbarrierall > 0 {\n+\t// \tfirstStackBarrierOffset = 0\n+\t// }\n+\n+\t// For cgocheck > 1, we turn on the write barrier at all times\n+\t// and check all pointer writes.\n+\tif debug.cgocheck > 1 {\n+\t\twriteBarrier.cgo = true\n+\t\twriteBarrier.enabled = true\n+\t}\n+\n+\t// Tell the C code what the value is.\n+\truntime_setdebug(&debug)\n+}\n+\n+//go:linkname setTraceback runtime_debug.SetTraceback\n+func setTraceback(level string) {\n+\tvar t uint32\n+\tswitch level {\n+\tcase \"none\":\n+\t\tt = 0\n+\tcase \"single\", \"\":\n+\t\tt = 1 << tracebackShift\n+\tcase \"all\":\n+\t\tt = 1<<tracebackShift | tracebackAll\n+\tcase \"system\":\n+\t\tt = 2<<tracebackShift | tracebackAll\n+\tcase \"crash\":\n+\t\tt = 2<<tracebackShift | tracebackAll | tracebackCrash\n+\tdefault:\n+\t\tt = uint32(atoi(level))<<tracebackShift | tracebackAll\n+\t}\n+\t// when C owns the process, simply exit'ing the process on fatal errors\n+\t// and panics is surprising. Be louder and abort instead.\n+\tif islibrary || isarchive {\n+\t\tt |= tracebackCrash\n+\t}\n+\n+\tt |= traceback_env\n+\n+\tatomic.Store(&traceback_cache, t)\n+}\n+\n+// Poor mans 64-bit division.\n+// This is a very special function, do not use it if you are not sure what you are doing.\n+// int64 division is lowered into _divv() call on 386, which does not fit into nosplit functions.\n+// Handles overflow in a time-specific manner.\n+//go:nosplit\n+func timediv(v int64, div int32, rem *int32) int32 {\n+\tres := int32(0)\n+\tfor bit := 30; bit >= 0; bit-- {\n+\t\tif v >= int64(div)<<uint(bit) {\n+\t\t\tv = v - (int64(div) << uint(bit))\n+\t\t\tres += 1 << uint(bit)\n+\t\t}\n+\t}\n+\tif v >= int64(div) {\n+\t\tif rem != nil {\n+\t\t\t*rem = 0\n+\t\t}\n+\t\treturn 0x7fffffff\n+\t}\n+\tif rem != nil {\n+\t\t*rem = int32(v)\n+\t}\n+\treturn res\n+}\n+\n+// Helpers for Go. Must be NOSPLIT, must only call NOSPLIT functions, and must not block.\n+\n+//go:nosplit\n+func acquirem() *m {\n+\t_g_ := getg()\n+\t_g_.m.locks++\n+\treturn _g_.m\n+}\n+\n+//go:nosplit\n+func releasem(mp *m) {\n+\t// _g_ := getg()\n+\tmp.locks--\n+\t// if mp.locks == 0 && _g_.preempt {\n+\t//\t// restore the preemption request in case we've cleared it in newstack\n+\t//\t_g_.stackguard0 = stackPreempt\n+\t// }\n+}\n+\n+//go:nosplit\n+func gomcache() *mcache {\n+\treturn getg().m.mcache\n+}"}, {"sha": "4fba428d7af0fa3aecd33d0ccc78e1220a8bd69b", "filename": "libgo/go/runtime/runtime2.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6748787813f8080f853766877f6933bc0823c19d/libgo%2Fgo%2Fruntime%2Fruntime2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6748787813f8080f853766877f6933bc0823c19d/libgo%2Fgo%2Fruntime%2Fruntime2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fruntime2.go?ref=6748787813f8080f853766877f6933bc0823c19d", "patch": "@@ -678,11 +678,11 @@ type forcegcstate struct {\n \tidle uint32\n }\n \n-/*\n // startup_random_data holds random bytes initialized at startup. These come from\n // the ELF AT_RANDOM auxiliary vector (vdso_linux_amd64.go or os_linux_386.go).\n var startupRandomData []byte\n \n+/*\n // extendRandom extends the random numbers in r[:n] to the whole slice r.\n // Treats n<0 as n==0.\n func extendRandom(r []byte, n int) {\n@@ -797,8 +797,8 @@ var (\n \n // Set by the linker so the runtime can determine the buildmode.\n var (\n-//\tislibrary bool // -buildmode=c-shared\n-//\tisarchive bool // -buildmode=c-archive\n+\tislibrary bool // -buildmode=c-shared\n+\tisarchive bool // -buildmode=c-archive\n )\n \n // Types that are only used by gccgo."}, {"sha": "3ff3aef2216300a0425761cae89194d52cb499bd", "filename": "libgo/go/runtime/stubs.go", "status": "modified", "additions": 120, "deletions": 3, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6748787813f8080f853766877f6933bc0823c19d/libgo%2Fgo%2Fruntime%2Fstubs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6748787813f8080f853766877f6933bc0823c19d/libgo%2Fgo%2Fruntime%2Fstubs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fstubs.go?ref=6748787813f8080f853766877f6933bc0823c19d", "patch": "@@ -5,6 +5,7 @@\n package runtime\n \n import (\n+\t\"runtime/internal/atomic\"\n \t\"runtime/internal/sys\"\n \t\"unsafe\"\n )\n@@ -209,10 +210,10 @@ func round(n, a uintptr) uintptr {\n \treturn (n + a - 1) &^ (a - 1)\n }\n \n-/*\n // checkASM returns whether assembly runtime checks have passed.\n-func checkASM() bool\n-*/\n+func checkASM() bool {\n+\treturn true\n+}\n \n // throw crashes the program.\n // For gccgo unless and until we port panic.go.\n@@ -251,3 +252,119 @@ type stringStruct struct {\n func stringStructOf(sp *string) *stringStruct {\n \treturn (*stringStruct)(unsafe.Pointer(sp))\n }\n+\n+// Here for gccgo unless and until we port slice.go.\n+type slice struct {\n+\tarray unsafe.Pointer\n+\tlen   int\n+\tcap   int\n+}\n+\n+// Here for gccgo until we port malloc.go.\n+const (\n+\t_64bit              = 1 << (^uintptr(0) >> 63) / 2\n+\t_MHeapMap_TotalBits = (_64bit*sys.GoosWindows)*35 + (_64bit*(1-sys.GoosWindows)*(1-sys.GoosDarwin*sys.GoarchArm64))*39 + sys.GoosDarwin*sys.GoarchArm64*31 + (1-_64bit)*32\n+\t_MaxMem             = uintptr(1<<_MHeapMap_TotalBits - 1)\n+)\n+\n+// Here for gccgo until we port malloc.go.\n+//extern runtime_mallocgc\n+func c_mallocgc(size uintptr, typ uintptr, flag uint32) unsafe.Pointer\n+func mallocgc(size uintptr, typ *_type, needzero bool) unsafe.Pointer {\n+\tflag := uint32(0)\n+\tif !needzero {\n+\t\tflag = 1 << 3\n+\t}\n+\treturn c_mallocgc(size, uintptr(unsafe.Pointer(typ)), flag)\n+}\n+\n+// Here for gccgo unless and until we port string.go.\n+func rawstring(size int) (p unsafe.Pointer, s string) {\n+\tp = mallocgc(uintptr(size), nil, false)\n+\n+\t(*(*stringStruct)(unsafe.Pointer(&s))).str = p\n+\t(*(*stringStruct)(unsafe.Pointer(&s))).len = size\n+\n+\treturn\n+}\n+\n+// Here for gccgo unless and until we port string.go.\n+func gostring(p *byte) string {\n+\tl := findnull(p)\n+\tif l == 0 {\n+\t\treturn \"\"\n+\t}\n+\tm, s := rawstring(l)\n+\tmemmove(m, unsafe.Pointer(p), uintptr(l))\n+\treturn s\n+}\n+\n+// Here for gccgo unless and until we port string.go.\n+func index(s, t string) int {\n+\tif len(t) == 0 {\n+\t\treturn 0\n+\t}\n+\tfor i := 0; i < len(s); i++ {\n+\t\tif s[i] == t[0] && hasprefix(s[i:], t) {\n+\t\t\treturn i\n+\t\t}\n+\t}\n+\treturn -1\n+}\n+\n+// Here for gccgo unless and until we port string.go.\n+func hasprefix(s, t string) bool {\n+\treturn len(s) >= len(t) && s[:len(t)] == t\n+}\n+\n+// Here for gccgo unless and until we port string.go.\n+//go:nosplit\n+func findnull(s *byte) int {\n+\tif s == nil {\n+\t\treturn 0\n+\t}\n+\tp := (*[_MaxMem/2 - 1]byte)(unsafe.Pointer(s))\n+\tl := 0\n+\tfor p[l] != 0 {\n+\t\tl++\n+\t}\n+\treturn l\n+}\n+\n+// Here for gccgo unless and until we port string.go.\n+//go:nosplit\n+func gostringnocopy(str *byte) string {\n+\tss := stringStruct{str: unsafe.Pointer(str), len: findnull(str)}\n+\treturn *(*string)(unsafe.Pointer(&ss))\n+}\n+\n+// Here for gccgo unless and until we port string.go.\n+func atoi(s string) int {\n+\tn := 0\n+\tfor len(s) > 0 && '0' <= s[0] && s[0] <= '9' {\n+\t\tn = n*10 + int(s[0]) - '0'\n+\t\ts = s[1:]\n+\t}\n+\treturn n\n+}\n+\n+// Here for gccgo until we port mgc.go.\n+var writeBarrier struct {\n+\tenabled bool   // compiler emits a check of this before calling write barrier\n+\tneeded  bool   // whether we need a write barrier for current GC phase\n+\tcgo     bool   // whether we need a write barrier for a cgo check\n+\talignme uint64 // guarantee alignment so that compiler can use a 32 or 64-bit load\n+}\n+\n+// Here for gccgo until we port atomic_pointer.go and mgc.go.\n+//go:nosplit\n+func casp(ptr *unsafe.Pointer, old, new unsafe.Pointer) bool {\n+\tif !atomic.Casp1((*unsafe.Pointer)(noescape(unsafe.Pointer(ptr))), noescape(old), new) {\n+\t\treturn false\n+\t}\n+\treturn true\n+}\n+\n+// Here for gccgo until we port lock_*.go.\n+func lock(l *mutex)\n+func unlock(l *mutex)"}, {"sha": "d96022674b69840f39584a03fabe603078e029f7", "filename": "libgo/go/runtime/stubs2.go", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6748787813f8080f853766877f6933bc0823c19d/libgo%2Fgo%2Fruntime%2Fstubs2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6748787813f8080f853766877f6933bc0823c19d/libgo%2Fgo%2Fruntime%2Fstubs2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fstubs2.go?ref=6748787813f8080f853766877f6933bc0823c19d", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build !plan9\n+// +build !windows\n+// +build !nacl\n+\n+package runtime\n+\n+import \"unsafe\"\n+\n+func read(fd int32, p unsafe.Pointer, n int32) int32\n+func closefd(fd int32) int32\n+\n+//extern exit\n+func exit(code int32)\n+func nanotime() int64\n+func usleep(usec uint32)\n+\n+func munmap(addr unsafe.Pointer, n uintptr)\n+\n+//go:noescape\n+func write(fd uintptr, p unsafe.Pointer, n int32) int32\n+\n+//go:noescape\n+func open(name *byte, mode, perm int32) int32\n+\n+func madvise(addr unsafe.Pointer, n uintptr, flags int32)"}, {"sha": "efae23f6eeb907821425f54dc78f49d1b9c97cb5", "filename": "libgo/go/runtime/vdso_none.go", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6748787813f8080f853766877f6933bc0823c19d/libgo%2Fgo%2Fruntime%2Fvdso_none.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6748787813f8080f853766877f6933bc0823c19d/libgo%2Fgo%2Fruntime%2Fvdso_none.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fvdso_none.go?ref=6748787813f8080f853766877f6933bc0823c19d", "patch": "@@ -0,0 +1,10 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build !linux\n+\n+package runtime\n+\n+func sysargs(argc int32, argv **byte) {\n+}"}, {"sha": "3a60682597219f150bc168713f01f0b9f7d9c0b3", "filename": "libgo/runtime/env_posix.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6748787813f8080f853766877f6933bc0823c19d/libgo%2Fruntime%2Fenv_posix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6748787813f8080f853766877f6933bc0823c19d/libgo%2Fruntime%2Fenv_posix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fenv_posix.c?ref=6748787813f8080f853766877f6933bc0823c19d", "patch": "@@ -9,20 +9,22 @@\n #include \"arch.h\"\n #include \"malloc.h\"\n \n-extern Slice envs;\n+extern Slice runtime_get_envs(void);\n \n String\n runtime_getenv(const char *s)\n {\n \tint32 i, j;\n \tintgo len;\n \tconst byte *v, *bs;\n+\tSlice envs;\n \tString* envv;\n \tint32 envc;\n \tString ret;\n \n \tbs = (const byte*)s;\n \tlen = runtime_findnull(bs);\n+\tenvs = runtime_get_envs();\n \tenvv = (String*)envs.__values;\n \tenvc = envs.__count;\n \tfor(i=0; i<envc; i++){"}, {"sha": "34abf6c9ffce2b936a4db37e34a4a7060b896344", "filename": "libgo/runtime/go-caller.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6748787813f8080f853766877f6933bc0823c19d/libgo%2Fruntime%2Fgo-caller.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6748787813f8080f853766877f6933bc0823c19d/libgo%2Fruntime%2Fgo-caller.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-caller.c?ref=6748787813f8080f853766877f6933bc0823c19d", "patch": "@@ -76,6 +76,10 @@ static void *back_state;\n \n static Lock back_state_lock;\n \n+/* The program arguments.  */\n+\n+extern Slice runtime_get_args(void);\n+\n /* Fetch back_state, creating it if necessary.  */\n \n struct backtrace_state *\n@@ -84,15 +88,19 @@ __go_get_backtrace_state ()\n   runtime_lock (&back_state_lock);\n   if (back_state == NULL)\n     {\n+      Slice args;\n       const char *filename;\n       struct stat s;\n \n-      filename = (const char *) runtime_progname ();\n+      args = runtime_get_args();\n+      filename = NULL;\n+      if (args.__count > 0)\n+\tfilename = (const char*)((String*)args.__values)[0].str;\n \n       /* If there is no '/' in FILENAME, it was found on PATH, and\n \t might not be the same as the file with the same name in the\n \t current directory.  */\n-      if (__builtin_strchr (filename, '/') == NULL)\n+      if (filename != NULL && __builtin_strchr (filename, '/') == NULL)\n \tfilename = NULL;\n \n       /* If the file is small, then it's not the real executable."}, {"sha": "e5e88ed292f046908eed957bf231e83698f9f150", "filename": "libgo/runtime/runtime.c", "status": "modified", "additions": 51, "deletions": 301, "changes": 352, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6748787813f8080f853766877f6933bc0823c19d/libgo%2Fruntime%2Fruntime.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6748787813f8080f853766877f6933bc0823c19d/libgo%2Fruntime%2Fruntime.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.c?ref=6748787813f8080f853766877f6933bc0823c19d", "patch": "@@ -15,118 +15,27 @@ enum {\n \tmaxround = sizeof(uintptr),\n };\n \n-// Keep a cached value to make gotraceback fast,\n-// since we call it on every call to gentraceback.\n-// The cached value is a uint32 in which the low bit\n-// is the \"crash\" setting and the top 31 bits are the\n-// gotraceback value.\n-enum {\n-\ttracebackCrash = 1 << 0,\n-\ttracebackAll = 1 << 1,\n-\ttracebackShift = 2,\n-};\n-static uint32 traceback_cache = 2 << tracebackShift;\n-static uint32 traceback_env;\n-\n extern volatile intgo runtime_MemProfileRate\n   __asm__ (GOSYM_PREFIX \"runtime.MemProfileRate\");\n \n+struct gotraceback_ret {\n+\tint32 level;\n+\tbool crash;\n+};\n+\n+extern struct gotraceback_ret gotraceback(void)\n+  __asm__ (GOSYM_PREFIX \"runtime.gotraceback\");\n \n-// gotraceback returns the current traceback settings.\n-//\n-// If level is 0, suppress all tracebacks.\n-// If level is 1, show tracebacks, but exclude runtime frames.\n-// If level is 2, show tracebacks including runtime frames.\n-// If all is set, print all goroutine stacks. Otherwise, print just the current goroutine.\n-// If crash is set, crash (core dump, etc) after tracebacking.\n+// runtime_gotraceback is the C interface to runtime.gotraceback.\n int32\n runtime_gotraceback(bool *crash)\n {\n-\tuint32 x;\n+\tstruct gotraceback_ret r;\n \n+\tr = gotraceback();\n \tif(crash != nil)\n-\t\t*crash = false;\n-\tif(runtime_m()->traceback != 0)\n-\t\treturn runtime_m()->traceback;\n-\tx = runtime_atomicload(&traceback_cache);\n-\tif(crash != nil)\n-\t\t*crash = x&tracebackCrash;\n-\treturn x>>tracebackShift;\n-}\n-\n-static int32\targc;\n-static byte**\targv;\n-\n-static Slice args;\n-Slice envs;\n-\n-void (*runtime_sysargs)(int32, uint8**);\n-\n-void\n-runtime_args(int32 c, byte **v)\n-{\n-\targc = c;\n-\targv = v;\n-\tif(runtime_sysargs != nil)\n-\t\truntime_sysargs(c, v);\n-}\n-\n-byte*\n-runtime_progname()\n-{\n-  return argc == 0 ? nil : argv[0];\n-}\n-\n-void\n-runtime_goargs(void)\n-{\n-\tString *s;\n-\tint32 i;\n-\n-\t// for windows implementation see \"os\" package\n-\tif(Windows)\n-\t\treturn;\n-\n-\ts = runtime_malloc(argc*sizeof s[0]);\n-\tfor(i=0; i<argc; i++)\n-\t\ts[i] = runtime_gostringnocopy((const byte*)argv[i]);\n-\targs.__values = (void*)s;\n-\targs.__count = argc;\n-\targs.__capacity = argc;\n-}\n-\n-void\n-runtime_goenvs_unix(void)\n-{\n-\tString *s;\n-\tint32 i, n;\n-\n-\tfor(n=0; argv[argc+1+n] != 0; n++)\n-\t\t;\n-\n-\ts = runtime_malloc(n*sizeof s[0]);\n-\tfor(i=0; i<n; i++)\n-\t\ts[i] = runtime_gostringnocopy(argv[argc+1+i]);\n-\tenvs.__values = (void*)s;\n-\tenvs.__count = n;\n-\tenvs.__capacity = n;\n-}\n-\n-// Called from the syscall package.\n-Slice runtime_envs(void) __asm__ (GOSYM_PREFIX \"syscall.runtime_envs\");\n-\n-Slice\n-runtime_envs()\n-{\n-\treturn envs;\n-}\n-\n-Slice os_runtime_args(void) __asm__ (GOSYM_PREFIX \"os.runtime_args\");\n-\n-Slice\n-os_runtime_args()\n-{\n-\treturn args;\n+\t\t*crash = r.crash;\n+\treturn r.level;\n }\n \n int32\n@@ -142,53 +51,6 @@ runtime_atoi(const byte *p, intgo len)\n \treturn n;\n }\n \n-static struct root_list runtime_roots =\n-{ nil,\n-  { { &envs, sizeof envs },\n-    { &args, sizeof args },\n-    { nil, 0 } },\n-};\n-\n-static void\n-TestAtomic64(void)\n-{\n-\tuint64 z64, x64;\n-\n-\tz64 = 42;\n-\tx64 = 0;\n-\tPREFETCH(&z64);\n-\tif(runtime_cas64(&z64, x64, 1))\n-\t\truntime_throw(\"cas64 failed\");\n-\tif(x64 != 0)\n-\t\truntime_throw(\"cas64 failed\");\n-\tx64 = 42;\n-\tif(!runtime_cas64(&z64, x64, 1))\n-\t\truntime_throw(\"cas64 failed\");\n-\tif(x64 != 42 || z64 != 1)\n-\t\truntime_throw(\"cas64 failed\");\n-\tif(runtime_atomicload64(&z64) != 1)\n-\t\truntime_throw(\"load64 failed\");\n-\truntime_atomicstore64(&z64, (1ull<<40)+1);\n-\tif(runtime_atomicload64(&z64) != (1ull<<40)+1)\n-\t\truntime_throw(\"store64 failed\");\n-\tif(runtime_xadd64(&z64, (1ull<<40)+1) != (2ull<<40)+2)\n-\t\truntime_throw(\"xadd64 failed\");\n-\tif(runtime_atomicload64(&z64) != (2ull<<40)+2)\n-\t\truntime_throw(\"xadd64 failed\");\n-\tif(runtime_xchg64(&z64, (3ull<<40)+3) != (2ull<<40)+2)\n-\t\truntime_throw(\"xchg64 failed\");\n-\tif(runtime_atomicload64(&z64) != (3ull<<40)+3)\n-\t\truntime_throw(\"xchg64 failed\");\n-}\n-\n-void\n-runtime_check(void)\n-{\n-\t__go_register_gc_roots(&runtime_roots);\n-\n-\tTestAtomic64();\n-}\n-\n uint32\n runtime_fastrand1(void)\n {\n@@ -220,8 +82,10 @@ runtime_cputicks(void)\n   asm volatile(\".insn s,0xb27c0000,%0\" /* stckf */ : \"+Q\" (clock) : : \"cc\" );\n   return (int64)clock;\n #else\n-  // FIXME: implement for other processors.\n-  return 0;\n+  // Currently cputicks() is used in blocking profiler and to seed runtime\u00b7fastrand1().\n+  // runtime\u00b7nanotime() is a poor approximation of CPU ticks that is enough for the profiler.\n+  // TODO: need more entropy to better seed fastrand1.\n+  return runtime_nanotime();\n #endif\n }\n \n@@ -237,36 +101,6 @@ runtime_showframe(String s, bool current)\n \treturn traceback > 1 || (__builtin_memchr(s.str, '.', s.len) != nil && __builtin_memcmp(s.str, \"runtime.\", 7) != 0);\n }\n \n-static Lock ticksLock;\n-static int64 ticks;\n-\n-int64\n-runtime_tickspersecond(void)\n-{\n-\tint64 res, t0, t1, c0, c1;\n-\n-\tres = (int64)runtime_atomicload64((uint64*)&ticks);\n-\tif(res != 0)\n-\t\treturn ticks;\n-\truntime_lock(&ticksLock);\n-\tres = ticks;\n-\tif(res == 0) {\n-\t\tt0 = runtime_nanotime();\n-\t\tc0 = runtime_cputicks();\n-\t\truntime_usleep(100*1000);\n-\t\tt1 = runtime_nanotime();\n-\t\tc1 = runtime_cputicks();\n-\t\tif(t1 == t0)\n-\t\t\tt1++;\n-\t\tres = (c1-c0)*1000*1000*1000/(t1-t0);\n-\t\tif(res == 0)\n-\t\t\tres++;\n-\t\truntime_atomicstore64((uint64*)&ticks, res);\n-\t}\n-\truntime_unlock(&ticksLock);\n-\treturn res;\n-}\n-\n // Called to initialize a new m (including the bootstrap m).\n // Called on the parent thread (main thread in case of bootstrap), can allocate memory.\n void\n@@ -321,142 +155,58 @@ runtime_signalstack(byte *p, int32 n)\n \t\t*(int *)0xf1 = 0xf1;\n }\n \n-void setTraceback(String level)\n-  __asm__ (GOSYM_PREFIX \"runtime_debug.SetTraceback\");\n-\n-void setTraceback(String level) {\n-\tuint32 t;\n-\n-\tif (level.len == 4 && __builtin_memcmp(level.str, \"none\", 4) == 0) {\n-\t\tt = 0;\n-\t} else if (level.len == 0 || (level.len == 6 && __builtin_memcmp(level.str, \"single\", 6) == 0)) {\n-\t\tt = 1 << tracebackShift;\n-\t} else if (level.len == 3 && __builtin_memcmp(level.str, \"all\", 3) == 0) {\n-\t\tt = (1<<tracebackShift) | tracebackAll;\n-\t} else if (level.len == 6 && __builtin_memcmp(level.str, \"system\", 6) == 0) {\n-\t\tt = (2<<tracebackShift) | tracebackAll;\n-\t} else if (level.len == 5 && __builtin_memcmp(level.str, \"crash\", 5) == 0) {\n-\t\tt = (2<<tracebackShift) | tracebackAll | tracebackCrash;\n-\t} else {\n-\t\tt = (runtime_atoi(level.str, level.len)<<tracebackShift) | tracebackAll;\n-\t}\n-\n-\tt |= traceback_env;\n+struct debugVars\truntime_debug;\n \n-\truntime_atomicstore(&traceback_cache, t);\n+void\n+runtime_setdebug(struct debugVars* d) {\n+  runtime_debug = *d;\n }\n \n-DebugVars\truntime_debug;\n-\n-// Holds variables parsed from GODEBUG env var,\n-// except for \"memprofilerate\" since there is an\n-// existing var for that value which is int\n-// instead of in32 and might have an\n-// initial value.\n-static struct {\n-\tconst char* name;\n-\tint32*\tvalue;\n-} dbgvar[] = {\n-\t{\"allocfreetrace\", &runtime_debug.allocfreetrace},\n-\t{\"cgocheck\", &runtime_debug.cgocheck},\n-\t{\"efence\", &runtime_debug.efence},\n-\t{\"gccheckmark\", &runtime_debug.gccheckmark},\n-\t{\"gcpacertrace\", &runtime_debug.gcpacertrace},\n-\t{\"gcshrinkstackoff\", &runtime_debug.gcshrinkstackoff},\n-\t{\"gcstackbarrieroff\", &runtime_debug.gcstackbarrieroff},\n-\t{\"gcstackbarrierall\", &runtime_debug.gcstackbarrierall},\n-\t{\"gcstoptheworld\", &runtime_debug.gcstoptheworld},\n-\t{\"gctrace\", &runtime_debug.gctrace},\n-\t{\"gcdead\", &runtime_debug.gcdead},\n-\t{\"invalidptr\", &runtime_debug.invalidptr},\n-\t{\"sbrk\", &runtime_debug.sbrk},\n-\t{\"scavenge\", &runtime_debug.scavenge},\n-\t{\"scheddetail\", &runtime_debug.scheddetail},\n-\t{\"schedtrace\", &runtime_debug.schedtrace},\n-\t{\"wbshadow\", &runtime_debug.wbshadow},\n-};\n+// Setting the max stack size doesn't really do anything for gccgo.\n+\n+uintptr runtime_maxstacksize = 1<<20; // enough until runtime.main sets it for real\n+\n+void memclrBytes(Slice)\n+     __asm__ (GOSYM_PREFIX \"runtime.memclrBytes\");\n \n void\n-runtime_parsedebugvars(void)\n+memclrBytes(Slice s)\n {\n-\tString s;\n-\tconst byte *p, *pn;\n-\tintgo len;\n-\tintgo i, n;\n-\t\n-\ts = runtime_getenv(\"GODEBUG\");\n-\tif(s.len == 0)\n-\t\treturn;\n-\tp = s.str;\n-\tlen = s.len;\n-\tfor(;;) {\n-\t\tfor(i=0; i<(intgo)nelem(dbgvar); i++) {\n-\t\t\tn = runtime_findnull((const byte*)dbgvar[i].name);\n-\t\t\tif(len > n && runtime_mcmp(p, \"memprofilerate\", n) == 0 && p[n] == '=')\n-\t\t\t\t// Set the MemProfileRate directly since it\n-\t\t\t\t// is an int, not int32, and should only lbe\n-\t\t\t\t// set here if specified by GODEBUG\n-\t\t\t\truntime_MemProfileRate = runtime_atoi(p+n+1, len-(n+1));\n-\t\t\telse if(len > n && runtime_mcmp(p, dbgvar[i].name, n) == 0 && p[n] == '=')\n-\t\t\t\t*dbgvar[i].value = runtime_atoi(p+n+1, len-(n+1));\n-\t\t}\n-\t\tpn = (const byte *)runtime_strstr((const char *)p, \",\");\n-\t\tif(pn == nil || pn - p >= len)\n-\t\t\tbreak;\n-\t\tlen -= (pn - p) - 1;\n-\t\tp = pn + 1;\n-\t}\n-\n-\tsetTraceback(runtime_getenv(\"GOTRACEBACK\"));\n-\ttraceback_env = traceback_cache;\n+\truntime_memclr(s.__values, s.__count);\n }\n \n-// SetTracebackEnv is like runtime/debug.SetTraceback, but it raises\n-// the \"environment\" traceback level, so later calls to\n-// debug.SetTraceback (e.g., from testing timeouts) can't lower it.\n-void SetTracebackEnv(String level)\n-  __asm__ (GOSYM_PREFIX \"runtime.SetTracebackEnv\");\n+int32 go_open(char *, int32, int32)\n+  __asm__ (GOSYM_PREFIX \"runtime.open\");\n \n-void SetTracebackEnv(String level) {\n-\tsetTraceback(level);\n-\ttraceback_env = traceback_cache;\n+int32\n+go_open(char *name, int32 mode, int32 perm)\n+{\n+  return runtime_open(name, mode, perm);\n }\n \n-// Poor mans 64-bit division.\n-// This is a very special function, do not use it if you are not sure what you are doing.\n-// int64 division is lowered into _divv() call on 386, which does not fit into nosplit functions.\n-// Handles overflow in a time-specific manner.\n+int32 go_read(int32, void *, int32)\n+  __asm__ (GOSYM_PREFIX \"runtime.read\");\n+\n int32\n-runtime_timediv(int64 v, int32 div, int32 *rem)\n+go_read(int32 fd, void *p, int32 n)\n {\n-\tint32 res, bit;\n-\n-\tif(v >= (int64)div*0x7fffffffLL) {\n-\t\tif(rem != nil)\n-\t\t\t*rem = 0;\n-\t\treturn 0x7fffffff;\n-\t}\n-\tres = 0;\n-\tfor(bit = 30; bit >= 0; bit--) {\n-\t\tif(v >= ((int64)div<<bit)) {\n-\t\t\tv = v - ((int64)div<<bit);\n-\t\t\tres += 1<<bit;\n-\t\t}\n-\t}\n-\tif(rem != nil)\n-\t\t*rem = v;\n-\treturn res;\n+  return runtime_read(fd, p, n);\n }\n \n-// Setting the max stack size doesn't really do anything for gccgo.\n+int32 go_write(uintptr, void *, int32)\n+  __asm__ (GOSYM_PREFIX \"runtime.write\");\n \n-uintptr runtime_maxstacksize = 1<<20; // enough until runtime.main sets it for real\n+int32\n+go_write(uintptr fd, void *p, int32 n)\n+{\n+  return runtime_write(fd, p, n);\n+}\n \n-void memclrBytes(Slice)\n-     __asm__ (GOSYM_PREFIX \"runtime.memclrBytes\");\n+int32 go_closefd(int32)\n+  __asm__ (GOSYM_PREFIX \"runtime.closefd\");\n \n-void\n-memclrBytes(Slice s)\n+int32\n+go_closefd(int32 fd)\n {\n-\truntime_memclr(s.__values, s.__count);\n+  return runtime_close(fd);\n }"}, {"sha": "d223ec0ddda672205dbce678a2878473ec105f65", "filename": "libgo/runtime/runtime.h", "status": "modified", "additions": 27, "deletions": 38, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6748787813f8080f853766877f6933bc0823c19d/libgo%2Fruntime%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6748787813f8080f853766877f6933bc0823c19d/libgo%2Fruntime%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.h?ref=6748787813f8080f853766877f6933bc0823c19d", "patch": "@@ -75,7 +75,6 @@ typedef\tstruct\tParFor\t\tParFor;\n typedef\tstruct\tParForThread\tParForThread;\n typedef\tstruct\tcgoMal\t\tCgoMal;\n typedef\tstruct\tPollDesc\tPollDesc;\n-typedef\tstruct\tDebugVars\tDebugVars;\n \n typedef\tstruct\t__go_open_array\t\tSlice;\n typedef struct\t__go_interface\t\tIface;\n@@ -115,7 +114,8 @@ struct FuncVal\n  * Per-CPU declaration.\n  */\n extern M*\truntime_m(void);\n-extern G*\truntime_g(void);\n+extern G*\truntime_g(void)\n+  __asm__(GOSYM_PREFIX \"runtime.getg\");\n \n extern M\truntime_m0;\n extern G\truntime_g0;\n@@ -240,28 +240,6 @@ struct ParFor\n \tuint64 nsleep;\n };\n \n-// Holds variables parsed from GODEBUG env var.\n-struct DebugVars\n-{\n-\tint32\tallocfreetrace;\n-\tint32   cgocheck;\n-\tint32\tefence;\n-\tint32   gccheckmark;\n-\tint32   gcpacertrace;\n-\tint32   gcshrinkstackoff;\n-\tint32   gcstackbarrieroff;\n-\tint32   gcstackbarrierall;\n-\tint32   gcstoptheworld;\n-\tint32\tgctrace;\n-\tint32\tgcdead;\n-\tint32   invalidptr;\n-\tint32   sbrk;\n-\tint32   scavenge;\n-\tint32\tscheddetail;\n-\tint32\tschedtrace;\n-\tint32   wbshadow;\n-};\n-\n extern bool runtime_precisestack;\n extern bool runtime_copystack;\n \n@@ -309,7 +287,7 @@ extern\tint8*\truntime_goos;\n extern\tint32\truntime_ncpu;\n extern \tvoid\t(*runtime_sysargs)(int32, uint8**);\n extern\tuint32\truntime_Hchansize;\n-extern\tDebugVars\truntime_debug;\n+extern\tstruct debugVars runtime_debug;\n extern\tuintptr\truntime_maxstacksize;\n \n extern\tbool\truntime_isstarted;\n@@ -327,11 +305,14 @@ void\truntime_dump(byte*, int32);\n \n void\truntime_gogo(G*);\n struct __go_func_type;\n-void\truntime_args(int32, byte**);\n+void\truntime_args(int32, byte**)\n+  __asm__ (GOSYM_PREFIX \"runtime.args\");\n void\truntime_osinit();\n-void\truntime_goargs(void);\n+void\truntime_goargs(void)\n+  __asm__ (GOSYM_PREFIX \"runtime.goargs\");\n void\truntime_goenvs(void);\n-void\truntime_goenvs_unix(void);\n+void\truntime_goenvs_unix(void)\n+  __asm__ (GOSYM_PREFIX \"runtime.goenvs_unix\");\n void\truntime_throw(const char*) __attribute__ ((noreturn));\n void\truntime_panicstring(const char*) __attribute__ ((noreturn));\n bool\truntime_canpanic(G*);\n@@ -377,7 +358,8 @@ int32\truntime_mcount(void);\n int32\truntime_gcount(void);\n void\truntime_mcall(void(*)(G*));\n uint32\truntime_fastrand1(void) __asm__ (GOSYM_PREFIX \"runtime.fastrand1\");\n-int32\truntime_timediv(int64, int32, int32*);\n+int32\truntime_timediv(int64, int32, int32*)\n+  __asm__ (GOSYM_PREFIX \"runtime.timediv\");\n int32\truntime_round2(int32 x); // round x up to a power of 2.\n \n // atomic operations\n@@ -417,7 +399,8 @@ G*\t__go_go(void (*pfn)(void*), void*);\n void\tsiginit(void);\n bool\t__go_sigsend(int32 sig);\n int32\truntime_callers(int32, Location*, int32, bool keep_callers);\n-int64\truntime_nanotime(void);\t// monotonic time\n+int64\truntime_nanotime(void)\t// monotonic time\n+  __asm__(GOSYM_PREFIX \"runtime.nanotime\");\n int64\truntime_unixnanotime(void); // real time, can skip\n void\truntime_dopanic(int32) __attribute__ ((noreturn));\n void\truntime_startpanic(void);\n@@ -426,9 +409,12 @@ void\truntime_unwindstack(G*, byte*);\n void\truntime_sigprof();\n void\truntime_resetcpuprofiler(int32);\n void\truntime_setcpuprofilerate(void(*)(uintptr*, int32), int32);\n-void\truntime_usleep(uint32);\n-int64\truntime_cputicks(void);\n-int64\truntime_tickspersecond(void);\n+void\truntime_usleep(uint32)\n+     __asm__ (GOSYM_PREFIX \"runtime.usleep\");\n+int64\truntime_cputicks(void)\n+     __asm__ (GOSYM_PREFIX \"runtime.cputicks\");\n+int64\truntime_tickspersecond(void)\n+     __asm__ (GOSYM_PREFIX \"runtime.tickspersecond\");\n void\truntime_blockevent(int64, int32);\n extern int64 runtime_blockprofilerate;\n void\truntime_addtimer(Timer*);\n@@ -445,7 +431,8 @@ bool\truntime_netpollclosing(PollDesc*);\n void\truntime_netpolllock(PollDesc*);\n void\truntime_netpollunlock(PollDesc*);\n void\truntime_crash(void);\n-void\truntime_parsedebugvars(void);\n+void\truntime_parsedebugvars(void)\n+  __asm__(GOSYM_PREFIX \"runtime.parsedebugvars\");\n void\t_rt0_go(void);\n void*\truntime_funcdata(Func*, int32);\n int32\truntime_setmaxthreads(int32);\n@@ -462,8 +449,10 @@ extern uint32 runtime_worldsema;\n  * but on the contention path they sleep in the kernel.\n  * a zeroed Lock is unlocked (no need to initialize each lock).\n  */\n-void\truntime_lock(Lock*);\n-void\truntime_unlock(Lock*);\n+void\truntime_lock(Lock*)\n+  __asm__(GOSYM_PREFIX \"runtime.lock\");\n+void\truntime_unlock(Lock*)\n+  __asm__(GOSYM_PREFIX \"runtime.unlock\");\n \n /*\n  * sleep and wakeup on one-time events.\n@@ -609,7 +598,8 @@ enum\n \n #define runtime_setitimer setitimer\n \n-void\truntime_check(void);\n+void\truntime_check(void)\n+  __asm__ (GOSYM_PREFIX \"runtime.check\");\n \n // A list of global variables that the garbage collector must scan.\n struct root_list {\n@@ -630,7 +620,6 @@ extern uintptr runtime_stacks_sys;\n struct backtrace_state;\n extern struct backtrace_state *__go_get_backtrace_state(void);\n extern _Bool __go_file_line(uintptr, int, String*, String*, intgo *);\n-extern byte* runtime_progname();\n extern void runtime_main(void*);\n extern uint32 runtime_in_callers;\n "}, {"sha": "2238980e8c3a5993d343c05b4a4ff6a73b7b0628", "filename": "libgo/runtime/runtime1.goc", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6748787813f8080f853766877f6933bc0823c19d/libgo%2Fruntime%2Fruntime1.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6748787813f8080f853766877f6933bc0823c19d/libgo%2Fruntime%2Fruntime1.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime1.goc?ref=6748787813f8080f853766877f6933bc0823c19d", "patch": "@@ -84,13 +84,3 @@ func sync_atomic.runtime_procPin() (p int) {\n func sync_atomic.runtime_procUnpin() {\n \truntime_m()->locks--;\n }\n-\n-extern Slice envs;\n-\n-func envs() (s Slice) {\n-\ts = envs;\n-}\n-\n-func setenvs(e Slice) {\n-\tenvs = e;\n-}"}]}