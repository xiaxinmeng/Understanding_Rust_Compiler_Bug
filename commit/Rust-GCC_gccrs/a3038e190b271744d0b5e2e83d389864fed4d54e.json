{"sha": "a3038e190b271744d0b5e2e83d389864fed4d54e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTMwMzhlMTkwYjI3MTc0NGQwYjVlMmU4M2QzODk4NjRmZWQ0ZDU0ZQ==", "commit": {"author": {"name": "Wilco Dijkstra", "email": "wdijkstr@arm.com", "date": "2016-12-15T17:51:46Z"}, "committer": {"name": "Wilco Dijkstra", "email": "wilco@gcc.gnu.org", "date": "2016-12-15T17:51:46Z"}, "message": "Using leaf_function_p in a backend is dangerous as it incorrectly returns false...\n\nUsing leaf_function_p in a backend is dangerous as it incorrectly returns\nfalse if it is called while in a sequence (for example during prolog/epilog\ngeneration).  Replace all uses with crtl->is_leaf as this is now initialized\nearly enough in ira.c.  This typically causes no code generation differences\nunless there was a bug due to leaf_function_p returning the wrong value.\n\n    gcc/\n        * config/arm/arm.h (TARGET_BACKTRACE): Use crtl->is_leaf.\n        * config/arm/arm.c (arm_option_check_internal): Improve comment.\n        (thumb_force_lr_save): Use crtl->is_leaf.\n        (arm_get_frame_offsets): Remove comment.  Use crtl->is_leaf.\n        (thumb_far_jump_used_p): Remove comment.\n        (arm_frame_pointer_required): Use crtl->is_leaf.\n\nFrom-SVN: r243720", "tree": {"sha": "3efaf35c4f2642a0e1b90f31d9f0f631446ba7f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3efaf35c4f2642a0e1b90f31d9f0f631446ba7f9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a3038e190b271744d0b5e2e83d389864fed4d54e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3038e190b271744d0b5e2e83d389864fed4d54e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3038e190b271744d0b5e2e83d389864fed4d54e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3038e190b271744d0b5e2e83d389864fed4d54e/comments", "author": null, "committer": null, "parents": [{"sha": "4d044f0bb743d2c5afcab8e52536975b5ff48cc9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d044f0bb743d2c5afcab8e52536975b5ff48cc9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d044f0bb743d2c5afcab8e52536975b5ff48cc9"}], "stats": {"total": 36, "additions": 14, "deletions": 22}, "files": [{"sha": "0d31d0d7a8df57e14561fbe4d724f028d81aae6d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3038e190b271744d0b5e2e83d389864fed4d54e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3038e190b271744d0b5e2e83d389864fed4d54e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a3038e190b271744d0b5e2e83d389864fed4d54e", "patch": "@@ -1,3 +1,12 @@\n+2016-12-15  Wilco Dijkstra  <wdijkstr@arm.com>\n+\n+\t* config/arm/arm.h (TARGET_BACKTRACE): Use crtl->is_leaf.\n+\t* config/arm/arm.c (arm_option_check_internal): Improve comment.\n+\t(thumb_force_lr_save): Use crtl->is_leaf.\n+\t(arm_get_frame_offsets): Remove comment.  Use crtl->is_leaf.\n+\t(thumb_far_jump_used_p): Remove comment.\n+\t(arm_frame_pointer_required): Use crtl->is_leaf.\n+\n 2016-12-15  Jakub Jelinek  <jakub@redhat.com>\n \n \t* doc/extend.texi: Clean up @xref{...} uses."}, {"sha": "899c001bf89753fcba8d88cedcb6cb482563946b", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 4, "deletions": 21, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3038e190b271744d0b5e2e83d389864fed4d54e/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3038e190b271744d0b5e2e83d389864fed4d54e/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=a3038e190b271744d0b5e2e83d389864fed4d54e", "patch": "@@ -2828,8 +2828,7 @@ arm_option_check_internal (struct gcc_options *opts)\n       && !bitmap_bit_p (arm_active_target.isa, isa_bit_notm))\n     error (\"target CPU does not support ARM mode\");\n \n-  /* TARGET_BACKTRACE calls leaf_function_p, which causes a crash if done\n-     from here where no function is being compiled currently.  */\n+  /* TARGET_BACKTRACE cannot be used here as crtl->is_leaf is not set yet.  */\n   if ((TARGET_TPCS_FRAME || TARGET_TPCS_LEAF_FRAME) && TARGET_ARM_P (flags))\n     warning (0, \"enabling backtrace support is only meaningful when compiling for the Thumb\");\n \n@@ -20587,7 +20586,7 @@ static bool\n thumb_force_lr_save (void)\n {\n   return !cfun->machine->lr_save_eliminated\n-\t && (!leaf_function_p ()\n+\t && (!crtl->is_leaf\n \t     || thumb_far_jump_used_p ()\n \t     || df_regs_ever_live_p (LR_REGNUM));\n }\n@@ -20692,33 +20691,20 @@ arm_get_frame_offsets (void)\n {\n   struct arm_stack_offsets *offsets;\n   unsigned long func_type;\n-  int leaf;\n   int saved;\n   int core_saved;\n   HOST_WIDE_INT frame_size;\n   int i;\n \n   offsets = &cfun->machine->stack_offsets;\n \n-  /* We need to know if we are a leaf function.  Unfortunately, it\n-     is possible to be called after start_sequence has been called,\n-     which causes get_insns to return the insns for the sequence,\n-     not the function, which will cause leaf_function_p to return\n-     the incorrect result.\n-\n-     to know about leaf functions once reload has completed, and the\n-     frame size cannot be changed after that time, so we can safely\n-     use the cached value.  */\n-\n   if (reload_completed)\n     return offsets;\n \n   /* Initially this is the size of the local variables.  It will translated\n      into an offset once we have determined the size of preceding data.  */\n   frame_size = ROUND_UP_WORD (get_frame_size ());\n \n-  leaf = leaf_function_p ();\n-\n   /* Space for variadic functions.  */\n   offsets->saved_args = crtl->args.pretend_args_size;\n \n@@ -20772,7 +20758,7 @@ arm_get_frame_offsets (void)\n \n   /* A leaf function does not need any stack alignment if it has nothing\n      on the stack.  */\n-  if (leaf && frame_size == 0\n+  if (crtl->is_leaf && frame_size == 0\n       /* However if it calls alloca(), we have a dynamically allocated\n \t block of BIGGEST_ALIGNMENT on stack, so still do stack alignment.  */\n       && ! cfun->calls_alloca)\n@@ -24125,9 +24111,6 @@ thumb_far_jump_used_p (void)\n   bool far_jump = false;\n   unsigned int func_size = 0;\n \n-  /* This test is only important for leaf functions.  */\n-  /* assert (!leaf_function_p ()); */\n-\n   /* If we have already decided that far jumps may be used,\n      do not bother checking again, and always return true even if\n      it turns out that they are not being used.  Once we have made\n@@ -27679,7 +27662,7 @@ arm_frame_pointer_required (void)\n     return true;\n \n   /* The frame pointer is required for non-leaf APCS frames.  */\n-  if (TARGET_ARM && TARGET_APCS_FRAME && !leaf_function_p ())\n+  if (TARGET_ARM && TARGET_APCS_FRAME && !crtl->is_leaf)\n     return true;\n \n   /* If we are probing the stack in the prologue, we will have a faulting"}, {"sha": "8c62038aaa6479591e66d03b38aa101031ea119d", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3038e190b271744d0b5e2e83d389864fed4d54e/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3038e190b271744d0b5e2e83d389864fed4d54e/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=a3038e190b271744d0b5e2e83d389864fed4d54e", "patch": "@@ -131,7 +131,7 @@ extern tree arm_fp16_type_node;\n #define TARGET_IWMMXT_ABI (TARGET_32BIT && arm_abi == ARM_ABI_IWMMXT)\n #define TARGET_ARM                      (! TARGET_THUMB)\n #define TARGET_EITHER\t\t\t1 /* (TARGET_ARM | TARGET_THUMB) */\n-#define TARGET_BACKTRACE\t        (leaf_function_p () \\\n+#define TARGET_BACKTRACE\t        (crtl->is_leaf \\\n \t\t\t\t         ? TARGET_TPCS_LEAF_FRAME \\\n \t\t\t\t         : TARGET_TPCS_FRAME)\n #define TARGET_AAPCS_BASED \\"}]}