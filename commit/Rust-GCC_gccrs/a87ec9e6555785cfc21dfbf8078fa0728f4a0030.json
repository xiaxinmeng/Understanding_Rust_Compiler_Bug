{"sha": "a87ec9e6555785cfc21dfbf8078fa0728f4a0030", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTg3ZWM5ZTY1NTU3ODVjZmMyMWRmYmY4MDc4ZmEwNzI4ZjRhMDAzMA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1998-11-17T11:50:24Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-11-17T11:50:24Z"}, "message": "hash.h (hash_table_key): New type.\n\n\t* hash.h (hash_table_key): New type.\n\t(hash_entry): Change `string' field to generic `key'.\n\t(hash_table): Add `comp' and `hash' functions.\n\t(hash_table_init): Take them as input.\n\t(hash_table_init_n): Likewise.\n\t(hash_lookup): Modify for generic keys.\n\t(hash_newfunc): Likewise.\n\t(hash_traverse): Likewise.\n\t(string_hash): New function.\n\t(string_compare): Likewise.\n\t(string_copy): Likewise.\n\t* hash.c (hash_table_init_n): Modify for generic keys.\n\t(hash_table_init): Likewise.\n\t(hash_lookup): Likewise.\n\t(hash_newfunc): Likewise.\n\t(hash_traverse): Likewise.\n\t(string_hash): Split out from hash_lookup.\n\t(string_compare): New function.\n\t(string_copy): Split out from hash_lookup.\n\t* tlink.c (symbol_hash_newfunc): Modify for new interfaces to hash\n\ttables.\n\t(symbol_hash_lookup): Likewise.\n\t(file_hash_newfunc): Likewise.\n\t(file_hash_lookup): Likewise.\n\t(demangled_hash_newfunc): Likewise.\n\t(demangled_hash_lookup): Likewise.\n\t(tlink_int): Likewise.\n\t(read_repo_file): Likewise.\n\t(recompile_files): Likewise.\n\t(demangle_new_symbols): Likewise.\n\t(scan_linker_output): Likewise.\n\nFrom-SVN: r23683", "tree": {"sha": "ef9a03446edddcfd9973bbd42794b02e7d002f1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ef9a03446edddcfd9973bbd42794b02e7d002f1c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a87ec9e6555785cfc21dfbf8078fa0728f4a0030", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a87ec9e6555785cfc21dfbf8078fa0728f4a0030", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a87ec9e6555785cfc21dfbf8078fa0728f4a0030", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a87ec9e6555785cfc21dfbf8078fa0728f4a0030/comments", "author": null, "committer": null, "parents": [{"sha": "e398aa80628423ec3d52bca83864a8fc908641c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e398aa80628423ec3d52bca83864a8fc908641c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e398aa80628423ec3d52bca83864a8fc908641c1"}], "stats": {"total": 260, "additions": 185, "deletions": 75}, "files": [{"sha": "42e8abd6a2dc614a7008dea02ad5a8dd9ca96ba2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87ec9e6555785cfc21dfbf8078fa0728f4a0030/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87ec9e6555785cfc21dfbf8078fa0728f4a0030/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a87ec9e6555785cfc21dfbf8078fa0728f4a0030", "patch": "@@ -1,3 +1,37 @@\n+Tue Nov 17 11:51:16 1998  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* hash.h (hash_table_key): New type.\n+\t(hash_entry): Change `string' field to generic `key'.\n+\t(hash_table): Add `comp' and `hash' functions.\n+\t(hash_table_init): Take them as input.\n+\t(hash_table_init_n): Likewise.\n+\t(hash_lookup): Modify for generic keys.\n+\t(hash_newfunc): Likewise.\n+\t(hash_traverse): Likewise.\n+\t(string_hash): New function.\n+\t(string_compare): Likewise.\n+\t(string_copy): Likewise.\n+\t* hash.c (hash_table_init_n): Modify for generic keys.\n+\t(hash_table_init): Likewise.\n+\t(hash_lookup): Likewise.\n+\t(hash_newfunc): Likewise.\n+\t(hash_traverse): Likewise.\n+\t(string_hash): Split out from hash_lookup.\n+\t(string_compare): New function.\n+\t(string_copy): Split out from hash_lookup.\n+\t* tlink.c (symbol_hash_newfunc): Modify for new interfaces to hash\n+\ttables.\n+\t(symbol_hash_lookup): Likewise.\n+\t(file_hash_newfunc): Likewise.\n+\t(file_hash_lookup): Likewise.\n+\t(demangled_hash_newfunc): Likewise.\n+\t(demangled_hash_lookup): Likewise.\n+\t(tlink_int): Likewise.\n+\t(read_repo_file): Likewise.\n+\t(recompile_files): Likewise.\n+\t(demangle_new_symbols): Likewise.\n+\t(scan_linker_output): Likewise.\n+\t\n Tue Nov 17 17:13:53 1998  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \n \t* flow.c (insn_dead_p): New argument NOTES.  Changed all callers."}, {"sha": "473d0ffbd93267d56151b073358fdd2a96497982", "filename": "gcc/hash.c", "status": "modified", "additions": 86, "deletions": 43, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87ec9e6555785cfc21dfbf8078fa0728f4a0030/gcc%2Fhash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87ec9e6555785cfc21dfbf8078fa0728f4a0030/gcc%2Fhash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash.c?ref=a87ec9e6555785cfc21dfbf8078fa0728f4a0030", "patch": "@@ -36,11 +36,13 @@ extern char * xmalloc ();\n /* Create a new hash table, given a number of entries.  */\n \n boolean\n-hash_table_init_n (table, newfunc, size)\n+hash_table_init_n (table, newfunc, hash, comp, size)\n      struct hash_table *table;\n      struct hash_entry *(*newfunc) PARAMS ((struct hash_entry *,\n-\t\t\t\t\t\tstruct hash_table *,\n-\t\t\t\t\t\tconst char *));\n+\t\t\t\t\t    struct hash_table *,\n+\t\t\t\t\t    hash_table_key));\n+     unsigned long (*hash) (hash_table_key);\n+     boolean (*comp) (hash_table_key, hash_table_key);\n      unsigned int size;\n {\n   unsigned int alloc;\n@@ -61,19 +63,23 @@ hash_table_init_n (table, newfunc, size)\n   memset ((PTR) table->table, 0, alloc);\n   table->size = size;\n   table->newfunc = newfunc;\n+  table->hash = hash;\n+  table->comp = comp;\n   return true;\n }\n \n /* Create a new hash table with the default number of entries.  */\n \n boolean\n-hash_table_init (table, newfunc)\n+hash_table_init (table, newfunc, hash, comp)\n      struct hash_table *table;\n      struct hash_entry *(*newfunc) PARAMS ((struct hash_entry *,\n-\t\t\t\t\t\tstruct hash_table *,\n-\t\t\t\t\t\tconst char *));\n+\t\t\t\t\t    struct hash_table *,\n+\t\t\t\t\t    hash_table_key));\n+     unsigned long (*hash) PARAMS ((hash_table_key));\n+     boolean (*comp) PARAMS ((hash_table_key, hash_table_key));\n {\n-  return hash_table_init_n (table, newfunc, DEFAULT_SIZE);\n+  return hash_table_init_n (table, newfunc, hash, comp, DEFAULT_SIZE);\n }\n \n /* Free a hash table.  */\n@@ -85,64 +91,42 @@ hash_table_free (table)\n   obstack_free (&table->memory, (PTR) NULL);\n }\n \n-/* Look up a string in a hash table.  */\n+/* Look up KEY in TABLE.  If CREATE is non-NULL a new entry is\n+   created if one does not previously exist.  */\n \n struct hash_entry *\n-hash_lookup (table, string, create, copy)\n+hash_lookup (table, key, create, copy)\n      struct hash_table *table;\n-     const char *string;\n+     hash_table_key key;\n      boolean create;\n-     boolean copy;\n+     hash_table_key (*copy) PARAMS ((struct obstack* memory, \n+\t\t\t\t     hash_table_key key));\n {\n-  register const unsigned char *s;\n   register unsigned long hash;\n-  register unsigned int c;\n   struct hash_entry *hashp;\n-  unsigned int len;\n   unsigned int index;\n   \n-  hash = 0;\n-  len = 0;\n-  s = (const unsigned char *) string;\n-  while ((c = *s++) != '\\0')\n-    {\n-      hash += c + (c << 17);\n-      hash ^= hash >> 2;\n-      ++len;\n-    }\n-  hash += len + (len << 17);\n-  hash ^= hash >> 2;\n+  hash = (*table->hash)(key);\n \n   index = hash % table->size;\n   for (hashp = table->table[index];\n        hashp != (struct hash_entry *) NULL;\n        hashp = hashp->next)\n     {\n       if (hashp->hash == hash\n-\t  && strcmp (hashp->string, string) == 0)\n+\t  && (*table->comp)(hashp->key, key))\n \treturn hashp;\n     }\n \n   if (! create)\n     return (struct hash_entry *) NULL;\n \n-  hashp = (*table->newfunc) ((struct hash_entry *) NULL, table, string);\n+  hashp = (*table->newfunc) ((struct hash_entry *) NULL, table, key);\n   if (hashp == (struct hash_entry *) NULL)\n     return (struct hash_entry *) NULL;\n   if (copy)\n-    {\n-      char *new;\n-\n-      new = (char *) obstack_alloc (&table->memory, len + 1);\n-      if (!new)\n-\t{\n-\t  error (\"no memory\");\n-\t  return (struct hash_entry *) NULL;\n-\t}\n-      strcpy (new, string);\n-      string = new;\n-    }\n-  hashp->string = string;\n+    key = (*copy) (&table->memory, key);\n+  hashp->key = key;\n   hashp->hash = hash;\n   hashp->next = table->table[index];\n   table->table[index] = hashp;\n@@ -154,10 +138,10 @@ hash_lookup (table, string, create, copy)\n \n /*ARGSUSED*/\n struct hash_entry *\n-hash_newfunc (entry, table, string)\n+hash_newfunc (entry, table, p)\n      struct hash_entry *entry;\n      struct hash_table *table;\n-     const char *string;\n+     hash_table_key p;\n {\n   if (entry == (struct hash_entry *) NULL)\n     entry = ((struct hash_entry *)\n@@ -185,7 +169,7 @@ hash_allocate (table, size)\n void\n hash_traverse (table, func, info)\n      struct hash_table *table;\n-     boolean (*func) PARAMS ((struct hash_entry *, PTR));\n+     boolean (*func) PARAMS ((struct hash_entry *, hash_table_key));\n      PTR info;\n {\n   unsigned int i;\n@@ -201,3 +185,62 @@ hash_traverse (table, func, info)\n \t}\n     }\n }\n+\n+/* Hash a string.  Return a hash-code for the string.  */\n+\n+unsigned long\n+string_hash (k)\n+     hash_table_key k;\n+{\n+  const unsigned char *s;\n+  unsigned long hash;\n+  unsigned char c;\n+  unsigned int len;\n+\n+  s = (const unsigned char *) k;\n+  hash = 0;\n+  len = 0;\n+\n+  while ((c = *s++) != '\\0')\n+    {\n+      hash += c + (c << 17);\n+      hash ^= hash >> 2;\n+      ++len;\n+    }\n+  hash += len + (len << 17);\n+  hash ^= hash >> 2;\n+\n+  return hash;\n+}\n+\n+/* Compare two strings.  Return non-zero iff the two strings are\n+   the same.  */\n+\n+boolean\n+string_compare (k1, k2)\n+     hash_table_key k1;\n+     hash_table_key k2;\n+{\n+  return (strcmp ((char*) k1, (char*) k2) == 0);\n+}\n+\n+/* Copy K to OBSTACK.  */\n+\n+hash_table_key\n+string_copy (memory, k)\n+     struct obstack* memory;\n+     hash_table_key k;\n+{\n+  char *new;\n+  char *string = (char*) k;\n+\n+  new = (char *) obstack_alloc (memory, strlen (string) + 1);\n+  if (!new)\n+    {\n+      error (\"no memory\");\n+      return NULL;\n+    }\n+  strcpy (new, string);\n+  \n+  return new;\n+}"}, {"sha": "bf64af789dfeb9b057a475a938ff20a048ebfdb5", "filename": "gcc/hash.h", "status": "modified", "additions": 37, "deletions": 15, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87ec9e6555785cfc21dfbf8078fa0728f4a0030/gcc%2Fhash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87ec9e6555785cfc21dfbf8078fa0728f4a0030/gcc%2Fhash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash.h?ref=a87ec9e6555785cfc21dfbf8078fa0728f4a0030", "patch": "@@ -26,6 +26,8 @@ Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n typedef enum {false, true} boolean;\n \n+typedef PTR hash_table_key;\n+\n /* Hash table routines.  There is no way to free up a hash table.  */\n \n /* An element in the hash table.  Most uses will actually use a larger\n@@ -35,8 +37,8 @@ struct hash_entry\n {\n   /* Next entry for this hash code.  */\n   struct hash_entry *next;\n-  /* String being hashed.  */\n-  const char *string;\n+  /* The thing being hashed.  */\n+  hash_table_key key;\n   /* Hash code.  This is the full hash code, not the index into the\n      table.  */\n   unsigned long hash;\n@@ -59,7 +61,11 @@ struct hash_table\n      only if the argument is NULL.  */\n   struct hash_entry *(*newfunc) PARAMS ((struct hash_entry *,\n \t\t\t\t\t struct hash_table *,\n-\t\t\t\t\t const char *));\n+\t\t\t\t\t hash_table_key));\n+  /* A function to compute the hash code for a key in the hash table.  */\n+  unsigned long (*hash) PARAMS ((hash_table_key));\n+  /* A function to compare two keys.  */\n+  boolean (*comp) PARAMS ((hash_table_key, hash_table_key));\n   /* An obstack for this hash table.  */\n   struct obstack memory;\n };\n@@ -69,31 +75,35 @@ extern boolean hash_table_init\n   PARAMS ((struct hash_table *,\n \t   struct hash_entry *(*) (struct hash_entry *,\n \t\t\t\t   struct hash_table *,\n-\t\t\t\t   const char *)));\n+\t\t\t\t   hash_table_key),\n+\t   unsigned long (*hash) (hash_table_key),\n+\t   boolean (*comp) (hash_table_key, hash_table_key)));\n \n /* Initialize a hash table specifying a size.  */\n extern boolean hash_table_init_n\n   PARAMS ((struct hash_table *,\n \t   struct hash_entry *(*) (struct hash_entry *,\n \t\t\t\t   struct hash_table *,\n-\t\t\t\t   const char *),\n+\t\t\t\t   hash_table_key),\n+\t   unsigned long (*hash) (hash_table_key),\n+\t   boolean (*comp) (hash_table_key, hash_table_key),\n \t   unsigned int size));\n \n /* Free up a hash table.  */\n extern void hash_table_free PARAMS ((struct hash_table *));\n \n-/* Look up a string in a hash table.  If CREATE is true, a new entry\n-   will be created for this string if one does not already exist.  The\n-   COPY argument must be true if this routine should copy the string\n-   into newly allocated memory when adding an entry.  */\n+/* Look up KEY in a hash table.  If CREATE is true, a new entry\n+   will be created for this KEY if one does not already exist.  If\n+   COPY is non-NULL, it is used to copy the KEY before storing it in\n+   the hash table.  */\n extern struct hash_entry *hash_lookup\n-  PARAMS ((struct hash_table *, const char *, boolean create,\n-\t   boolean copy));\n+  PARAMS ((struct hash_table *, hash_table_key key, boolean create,\n+\t   hash_table_key (*copy)(struct obstack*, hash_table_key)));\n \n /* Base method for creating a hash table entry.  */\n extern struct hash_entry *hash_newfunc\n-  PARAMS ((struct hash_entry *, struct hash_table *,\n-\t   const char *));\n+  PARAMS ((struct hash_entry *, struct hash_table *, \n+\t   hash_table_key key));\n \n /* Grab some space for a hash table entry.  */\n extern PTR hash_allocate PARAMS ((struct hash_table *,\n@@ -104,5 +114,17 @@ extern PTR hash_allocate PARAMS ((struct hash_table *,\n    INFO argument is passed to the function.  */\n extern void hash_traverse PARAMS ((struct hash_table *,\n \t\t\t\t   boolean (*) (struct hash_entry *,\n-\t\t\t\t\t\tPTR),\n-\t\t\t\t   PTR info));\n+\t\t\t\t\t\thash_table_key),\n+\t\t\t\t   hash_table_key info));\n+\n+/* Hash a string K, which is really of type `char*'.  */\n+extern unsigned long string_hash PARAMS ((hash_table_key k));\n+\n+/* Compare two strings K1, K2 which are really of type `char*'.  */\n+extern boolean string_compare PARAMS ((hash_table_key k1, \n+\t\t\t\t       hash_table_key k2));\n+\n+/* Copy a string K, which is really of type `char*'.  */\n+extern hash_table_key string_copy PARAMS ((struct obstack* memory,\n+\t\t\t\t\t   hash_table_key k));\n+"}, {"sha": "ec308c045f270f1e9a5fec723138b22dae69af47", "filename": "gcc/tlink.c", "status": "modified", "additions": 28, "deletions": 17, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87ec9e6555785cfc21dfbf8078fa0728f4a0030/gcc%2Ftlink.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87ec9e6555785cfc21dfbf8078fa0728f4a0030/gcc%2Ftlink.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftlink.c?ref=a87ec9e6555785cfc21dfbf8078fa0728f4a0030", "patch": "@@ -90,7 +90,8 @@ symbol_hash_newfunc (entry, table, string)\n \treturn NULL;\n     }\n   ret = ((struct symbol_hash_entry *)\n-     \t hash_newfunc ((struct hash_entry *) ret, table, string));\n+     \t hash_newfunc ((struct hash_entry *) ret, table, \n+\t\t       (hash_table_key) string));\n   ret->file = NULL;\n   ret->chosen = 0;\n   ret->tweaking = 0;\n@@ -104,7 +105,8 @@ symbol_hash_lookup (string, create)\n      boolean create;\n {\n   return ((struct symbol_hash_entry *)\n-\t  hash_lookup (&symbol_table, string, create, true));\n+\t  hash_lookup (&symbol_table, (hash_table_key) string, \n+\t\t       create, &string_copy));\n }\n \n static struct hash_table file_table;\n@@ -124,7 +126,8 @@ file_hash_newfunc (entry, table, string)\n \treturn NULL;\n     }\n   ret = ((struct file_hash_entry *)\n-     \t hash_newfunc ((struct hash_entry *) ret, table, string));\n+     \t hash_newfunc ((struct hash_entry *) ret, table, \n+\t\t       (hash_table_key) string));\n   ret->args = NULL;\n   ret->dir = NULL;\n   ret->main = NULL;\n@@ -137,7 +140,8 @@ file_hash_lookup (string)\n      const char *string;\n {\n   return ((struct file_hash_entry *)\n-\t  hash_lookup (&file_table, string, true, true));\n+\t  hash_lookup (&file_table, (hash_table_key) string, true, \n+\t\t       &string_copy));\n }\n \n static struct hash_table demangled_table;\n@@ -157,7 +161,8 @@ demangled_hash_newfunc (entry, table, string)\n \treturn NULL;\n     }\n   ret = ((struct demangled_hash_entry *)\n-     \t hash_newfunc ((struct hash_entry *) ret, table, string));\n+     \t hash_newfunc ((struct hash_entry *) ret, table, \n+\t\t       (hash_table_key) string));\n   ret->mangled = NULL;\n   return (struct hash_entry *) ret;\n }\n@@ -168,7 +173,8 @@ demangled_hash_lookup (string, create)\n      boolean create;\n {\n   return ((struct demangled_hash_entry *)\n-\t  hash_lookup (&demangled_table, string, create, true));\n+\t  hash_lookup (&demangled_table, (hash_table_key) string, \n+\t\t       create, &string_copy));\n }\n \f\n /* Stack code.  */\n@@ -251,9 +257,12 @@ tlink_init ()\n {\n   char *p;\n \n-  hash_table_init (&symbol_table, symbol_hash_newfunc);\n-  hash_table_init (&file_table, file_hash_newfunc);\n-  hash_table_init (&demangled_table, demangled_hash_newfunc);\n+  hash_table_init (&symbol_table, symbol_hash_newfunc, &string_hash,\n+\t\t   &string_compare);\n+  hash_table_init (&file_table, file_hash_newfunc, &string_hash, \n+\t\t   &string_compare);\n+  hash_table_init (&demangled_table, demangled_hash_newfunc,\n+\t\t   &string_hash, &string_compare);\n   obstack_begin (&symbol_stack_obstack, 0);\n   obstack_begin (&file_stack_obstack, 0);\n \n@@ -367,10 +376,11 @@ read_repo_file (f)\n      file *f;\n {\n   char c;\n-  FILE *stream = fopen (f->root.string, \"r\");\n+  FILE *stream = fopen ((char*) f->root.key, \"r\");\n \n   if (tlink_verbose >= 2)\n-    fprintf (stderr, \"collect: reading %s\\n\", f->root.string);\n+    fprintf (stderr, \"collect: reading %s\\n\", \n+\t     (char*) f->root.key);\n \n   while (fscanf (stream, \"%c \", &c) == 1)\n     {\n@@ -432,8 +442,8 @@ recompile_files ()\n   while ((f = file_pop ()) != NULL)\n     {\n       char *line, *command;\n-      FILE *stream = fopen (f->root.string, \"r\");\n-      char *outname = frob_extension (f->root.string, \".rnw\");\n+      FILE *stream = fopen ((char*) f->root.key, \"r\");\n+      char *outname = frob_extension ((char*) f->root.key, \".rnw\");\n       FILE *output = fopen (outname, \"w\");\n \n       while ((line = tfgets (stream)) != NULL)\n@@ -448,7 +458,7 @@ recompile_files ()\n \t}\n       fclose (stream);\n       fclose (output);\n-      rename (outname, f->root.string);\n+      rename (outname, (char*) f->root.key);\n \n       obstack_grow (&temporary_obstack, \"cd \", 3);\n       obstack_grow (&temporary_obstack, f->dir, strlen (f->dir));\n@@ -507,13 +517,14 @@ demangle_new_symbols ()\n   while ((sym = symbol_pop ()) != NULL)\n     {\n       demangled *dem;\n-      char *p = cplus_demangle (sym->root.string, DMGL_PARAMS | DMGL_ANSI);\n+      char *p = cplus_demangle ((char*) sym->root.key, \n+\t\t\t\tDMGL_PARAMS | DMGL_ANSI);\n \n       if (! p)\n \tcontinue;\n \n       dem = demangled_hash_lookup (p, true);\n-      dem->mangled = sym->root.string;\n+      dem->mangled = (char*) sym->root.key;\n     }\n }\n \n@@ -584,7 +595,7 @@ scan_linker_output (fname)\n \t{\n \t  if (tlink_verbose >= 2)\n \t    fprintf (stderr, \"collect: tweaking %s in %s\\n\",\n-\t\t     sym->root.string, sym->file->root.string);\n+\t\t     (char*) sym->root.key, (char*) sym->file->root.key);\n \t  sym->tweaking = 1;\n \t  file_push (sym->file);\n \t}"}]}