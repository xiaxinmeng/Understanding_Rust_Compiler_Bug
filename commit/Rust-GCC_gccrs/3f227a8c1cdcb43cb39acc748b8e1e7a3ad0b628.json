{"sha": "3f227a8c1cdcb43cb39acc748b8e1e7a3ad0b628", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2YyMjdhOGMxY2RjYjQzY2IzOWFjYzc0OGI4ZTFlN2EzYWQwYjYyOA==", "commit": {"author": {"name": "Jan Sjodin", "email": "jan.sjodin@amd.com", "date": "2008-05-09T16:17:47Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2008-05-09T16:17:47Z"}, "message": "tree-scalar-evolution.c: Document instantiate_scev.\n\n2008-05-09  Jan Sjodin  <jan.sjodin@amd.com>\n\t    Sebastian Pop  <sebastian.pop@amd.com>\n\n\t* tree-scalar-evolution.c: Document instantiate_scev.\n\t(instantiate_parameters_1): Renamed instantiate_scev_1.\n\tDon't use the same loop for instantiation_loop and evolution_loop.\n\t(instantiate_scev): New.\n\t(instantiate_parameters): Moved...\n\t(resolve_mixers): Update call to instantiate_scev_1 to pass the\n\tsame loop twice.  Maintains the semantics for this function.\n\t* tree-scalar-evolution.h (instantiate_scev): Declare.\n\t(instantiate_parameters): ...here.  Now static inline.\n\t* tree-data-ref.c (dr_analyze_indices): Call instantiate_scev\n\tinstead of resolve_mixers.\n\n\nCo-Authored-By: Sebastian Pop <sebastian.pop@amd.com>\n\nFrom-SVN: r135116", "tree": {"sha": "b769fe842aeb1e7594a9c1c3bfaaf9512a24bd92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b769fe842aeb1e7594a9c1c3bfaaf9512a24bd92"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3f227a8c1cdcb43cb39acc748b8e1e7a3ad0b628", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f227a8c1cdcb43cb39acc748b8e1e7a3ad0b628", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f227a8c1cdcb43cb39acc748b8e1e7a3ad0b628", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f227a8c1cdcb43cb39acc748b8e1e7a3ad0b628/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a3e19be6b06e8ca103708f035ea4ee1bc154cbe1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3e19be6b06e8ca103708f035ea4ee1bc154cbe1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3e19be6b06e8ca103708f035ea4ee1bc154cbe1"}], "stats": {"total": 223, "additions": 161, "deletions": 62}, "files": [{"sha": "f36b2b898bcc6097327cecd0b8b18d4c53a82cc6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f227a8c1cdcb43cb39acc748b8e1e7a3ad0b628/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f227a8c1cdcb43cb39acc748b8e1e7a3ad0b628/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3f227a8c1cdcb43cb39acc748b8e1e7a3ad0b628", "patch": "@@ -1,3 +1,18 @@\n+2008-05-09  Jan Sjodin  <jan.sjodin@amd.com>\n+\t    Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\t* tree-scalar-evolution.c: Document instantiate_scev.\n+\t(instantiate_parameters_1): Renamed instantiate_scev_1.\n+\tDon't use the same loop for instantiation_loop and evolution_loop.\n+\t(instantiate_scev): New.\n+\t(instantiate_parameters): Moved...\n+\t(resolve_mixers): Update call to instantiate_scev_1 to pass the\n+\tsame loop twice.  Maintains the semantics for this function.\n+\t* tree-scalar-evolution.h (instantiate_scev): Declare.\n+\t(instantiate_parameters): ...here.  Now static inline.\n+\t* tree-data-ref.c (dr_analyze_indices): Call instantiate_scev\n+\tinstead of resolve_mixers.\n+\n 2008-05-09  Maxim Kuvyrkov  <maxim@codesourcery.com>\n \n \t* rtl-factoring.c (collect_pattern_seqs): Fix typo."}, {"sha": "f6c39eae0688528e18c7ad6851e2cf0850da1dac", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f227a8c1cdcb43cb39acc748b8e1e7a3ad0b628/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f227a8c1cdcb43cb39acc748b8e1e7a3ad0b628/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3f227a8c1cdcb43cb39acc748b8e1e7a3ad0b628", "patch": "@@ -1,3 +1,8 @@\n+2008-01-08  Jan Sjodin  <jan.sjodin@amd.com>\n+\t    Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\t* gcc.dg/tree-ssa/data-dep-1.c: New.\n+\n 2008-05-08  Richard Guenther  <rguenther@suse.de>\n \n \t* gcc.dg/tree-ssa/20040911-1.c: Adjust."}, {"sha": "b0225e13ebc626eceb6245b92eb3b025f89b85ff", "filename": "gcc/testsuite/gcc.dg/tree-ssa/data-dep-1.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f227a8c1cdcb43cb39acc748b8e1e7a3ad0b628/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fdata-dep-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f227a8c1cdcb43cb39acc748b8e1e7a3ad0b628/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fdata-dep-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fdata-dep-1.c?ref=3f227a8c1cdcb43cb39acc748b8e1e7a3ad0b628", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -ftree-loop-linear -fdump-tree-ltrans-all\" } */\n+\n+int foo (int n, int m)\n+{\n+  int a[10000][10000];\n+  int i, j, k;\n+\n+  for(k = 0; k < 1234; k++)\n+    for(j = 0; j < 5; j++)\n+      for(i = 0; i < 67; i++)\n+\t{\n+\t  a[j+i-(-m+n+3)][i-k+4] = a[k+j][i];\n+\t}\n+\n+  return a[0][0];\n+}\n+\n+\n+/* For the data dependence analysis of the outermost loop, the\n+   evolution of \"k+j\" should be instantiated in the outermost loop \"k\"\n+   and the evolution should be taken in the innermost loop \"i\".  The\n+   pattern below ensures that the evolution is not computed in the\n+   outermost \"k\" loop: the 4 comes from the instantiation of the\n+   number of iterations of loop \"j\".  */\n+\n+/* { dg-final { scan-tree-dump-times \"4, \\\\+, 1\" 0 \"ltrans\" } } */ \n+/* { dg-final { cleanup-tree-dump \"ltrans\" } } */"}, {"sha": "90ce7e9d95562810d11d4e081efee2dc2ecbd04c", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f227a8c1cdcb43cb39acc748b8e1e7a3ad0b628/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f227a8c1cdcb43cb39acc748b8e1e7a3ad0b628/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=3f227a8c1cdcb43cb39acc748b8e1e7a3ad0b628", "patch": "@@ -741,7 +741,7 @@ dr_analyze_indices (struct data_reference *dr, struct loop *nest)\n \t{\n \t  op = TREE_OPERAND (aref, 1);\n \t  access_fn = analyze_scalar_evolution (loop, op);\n-\t  access_fn = resolve_mixers (nest, access_fn);\n+\t  access_fn = instantiate_scev (nest, loop, access_fn);\n \t  VEC_safe_push (tree, heap, access_fns, access_fn);\n \n \t  TREE_OPERAND (aref, 1) = build_int_cst (TREE_TYPE (op), 0);"}, {"sha": "cc2df6172942f8cc14a6d9f113f19cffea716f0f", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 101, "deletions": 60, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f227a8c1cdcb43cb39acc748b8e1e7a3ad0b628/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f227a8c1cdcb43cb39acc748b8e1e7a3ad0b628/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=3f227a8c1cdcb43cb39acc748b8e1e7a3ad0b628", "patch": "@@ -101,7 +101,7 @@ along with GCC; see the file COPYING3.  If not see\n    that the scev for \"b\" is known, it is possible to compute the\n    scev for \"c\", that is \"c -> {a + 1, +, 1}_1\".  In order to\n    determine the number of iterations in the loop_1, we have to\n-   instantiate_parameters ({a + 1, +, 1}_1), that gives after some\n+   instantiate_parameters (loop_1, {a + 1, +, 1}_1), that gives after some\n    more analysis the scev {4, +, 1}_1, or in other words, this is\n    the function \"f (x) = x + 4\", where x is the iteration count of\n    the loop_1.  Now we have to solve the inequality \"x + 4 > 10\",\n@@ -125,7 +125,7 @@ along with GCC; see the file COPYING3.  If not see\n    |     c = x + 4\n    |   }\n      \n-   Example 2: Illustration of the algorithm on nested loops.\n+   Example 2a: Illustration of the algorithm on nested loops.\n      \n    | loop_1\n    |   a = phi (1, b)\n@@ -153,7 +153,30 @@ along with GCC; see the file COPYING3.  If not see\n      \n    a -> {1, +, 32}_1\n    c -> {3, +, 32}_1\n-     \n+\n+   Example 2b: Multivariate chains of recurrences.\n+\n+   | loop_1\n+   |   k = phi (0, k + 1)\n+   |   loop_2  4 times\n+   |     j = phi (0, j + 1)\n+   |     loop_3 4 times\n+   |       i = phi (0, i + 1)\n+   |       A[j + k] = ...\n+   |     endloop\n+   |   endloop\n+   | endloop\n+\n+   Analyzing the access function of array A with\n+   instantiate_parameters (loop_1, \"j + k\"), we obtain the\n+   instantiation and the analysis of the scalar variables \"j\" and \"k\"\n+   in loop_1.  This leads to the scalar evolution {4, +, 1}_1: the end\n+   value of loop_2 for \"j\" is 4, and the evolution of \"k\" in loop_1 is\n+   {0, +, 1}_1.  To obtain the evolution function in loop_3 and\n+   instantiate the scalar variables up to loop_1, one has to use:\n+   instantiate_scev (loop_1, loop_3, \"j + k\").  The result of this\n+   call is {{0, +, 1}_1, +, 1}_2.\n+\n    Example 3: Higher degree polynomials.\n      \n    | loop_1\n@@ -168,8 +191,8 @@ along with GCC; see the file COPYING3.  If not see\n    c -> {5, +, a}_1\n    d -> {5 + a, +, a}_1\n      \n-   instantiate_parameters ({5, +, a}_1) -> {5, +, 2, +, 1}_1\n-   instantiate_parameters ({5 + a, +, a}_1) -> {7, +, 3, +, 1}_1\n+   instantiate_parameters (loop_1, {5, +, a}_1) -> {5, +, 2, +, 1}_1\n+   instantiate_parameters (loop_1, {5 + a, +, a}_1) -> {7, +, 3, +, 1}_1\n      \n    Example 4: Lucas, Fibonacci, or mixers in general.\n      \n@@ -1802,8 +1825,7 @@ analyze_scalar_evolution_1 (struct loop *loop, tree var, tree res)\n    \n    unsigned loop_nb = loop_containing_stmt (stmt)->num;\n    tree chrec_with_symbols = analyze_scalar_evolution (loop_nb, var);\n-   tree chrec_instantiated = instantiate_parameters \n-   (loop_nb, chrec_with_symbols);\n+   tree chrec_instantiated = instantiate_parameters (loop, chrec_with_symbols);\n */\n \n tree \n@@ -1929,11 +1951,12 @@ loop_closed_phi_def (tree var)\n   return NULL_TREE;\n }\n \n-/* Analyze all the parameters of the chrec that were left under a symbolic form,\n-   with respect to LOOP.  CHREC is the chrec to instantiate.  CACHE is the cache\n-   of already instantiated values.  FLAGS modify the way chrecs are\n-   instantiated.  SIZE_EXPR is used for computing the size of the expression to\n-   be instantiated, and to stop if it exceeds some limit.  */\n+/* Analyze all the parameters of the chrec, between INSTANTIATION_LOOP\n+   and EVOLUTION_LOOP, that were left under a symbolic form.  CHREC is\n+   the scalar evolution to instantiate.  CACHE is the cache of already\n+   instantiated values.  FLAGS modify the way chrecs are instantiated.\n+   SIZE_EXPR is used for computing the size of the expression to be\n+   instantiated, and to stop if it exceeds some limit.  */\n \n /* Values for FLAGS.  */\n enum\n@@ -1946,8 +1969,9 @@ enum\n };\n   \n static tree\n-instantiate_parameters_1 (struct loop *loop, tree chrec, int flags, htab_t cache,\n-\t\t\t  int size_expr)\n+instantiate_scev_1 (struct loop *instantiation_loop,\n+\t\t    struct loop *evolution_loop, tree chrec,\n+\t\t    int flags, htab_t cache, int size_expr)\n {\n   tree res, op0, op1, op2;\n   basic_block def_bb;\n@@ -1972,7 +1996,7 @@ instantiate_parameters_1 (struct loop *loop, tree chrec, int flags, htab_t cache\n       if (!def_bb\n \t  || loop_depth (def_bb->loop_father) == 0\n \t  || (!(flags & INSERT_SUPERLOOP_CHRECS)\n-\t      && !flow_bb_inside_loop_p (loop, def_bb)))\n+\t      && !flow_bb_inside_loop_p (instantiation_loop, def_bb)))\n \treturn chrec;\n \n       /* We cache the value of instantiated variable to avoid exponential\n@@ -1992,18 +2016,19 @@ instantiate_parameters_1 (struct loop *loop, tree chrec, int flags, htab_t cache\n \t is defined outside of the loop, we may just leave it in symbolic\n \t form, otherwise we need to admit that we do not know its behavior\n \t inside the loop.  */\n-      res = !flow_bb_inside_loop_p (loop, def_bb) ? chrec : chrec_dont_know;\n+      res = !flow_bb_inside_loop_p (instantiation_loop, def_bb) \n+\t? chrec : chrec_dont_know;\n       set_instantiated_value (cache, chrec, res);\n \n-      /* To make things even more complicated, instantiate_parameters_1\n+      /* To make things even more complicated, instantiate_scev_1\n \t calls analyze_scalar_evolution that may call # of iterations\n-\t analysis that may in turn call instantiate_parameters_1 again.\n+\t analysis that may in turn call instantiate_scev_1 again.\n \t To prevent the infinite recursion, keep also the bitmap of\n \t ssa names that are being instantiated globally.  */\n       if (bitmap_bit_p (already_instantiated, SSA_NAME_VERSION (chrec)))\n \treturn res;\n \n-      def_loop = find_common_loop (loop, def_bb->loop_father);\n+      def_loop = find_common_loop (evolution_loop, def_bb->loop_father);\n \n       /* If the analysis yields a parametric chrec, instantiate the\n \t result again.  */\n@@ -2026,7 +2051,8 @@ instantiate_parameters_1 (struct loop *loop, tree chrec, int flags, htab_t cache\n \t}\n \n       else if (res != chrec_dont_know)\n-\tres = instantiate_parameters_1 (loop, res, flags, cache, size_expr);\n+\tres = instantiate_scev_1 (instantiation_loop, evolution_loop, res,\n+\t\t\t\t  flags, cache, size_expr);\n \n       bitmap_clear_bit (already_instantiated, SSA_NAME_VERSION (chrec));\n \n@@ -2035,13 +2061,13 @@ instantiate_parameters_1 (struct loop *loop, tree chrec, int flags, htab_t cache\n       return res;\n \n     case POLYNOMIAL_CHREC:\n-      op0 = instantiate_parameters_1 (loop, CHREC_LEFT (chrec),\n-\t\t\t\t      flags, cache, size_expr);\n+      op0 = instantiate_scev_1 (instantiation_loop, evolution_loop,\n+\t\t\t\tCHREC_LEFT (chrec), flags, cache, size_expr);\n       if (op0 == chrec_dont_know)\n \treturn chrec_dont_know;\n \n-      op1 = instantiate_parameters_1 (loop, CHREC_RIGHT (chrec),\n-\t\t\t\t      flags, cache, size_expr);\n+      op1 = instantiate_scev_1 (instantiation_loop, evolution_loop,\n+\t\t\t\tCHREC_RIGHT (chrec), flags, cache, size_expr);\n       if (op1 == chrec_dont_know)\n \treturn chrec_dont_know;\n \n@@ -2055,13 +2081,15 @@ instantiate_parameters_1 (struct loop *loop, tree chrec, int flags, htab_t cache\n \n     case POINTER_PLUS_EXPR:\n     case PLUS_EXPR:\n-      op0 = instantiate_parameters_1 (loop, TREE_OPERAND (chrec, 0),\n-\t\t\t\t      flags, cache, size_expr);\n+      op0 = instantiate_scev_1 (instantiation_loop, evolution_loop,\n+\t\t\t\tTREE_OPERAND (chrec, 0), flags, cache,\n+\t\t\t\tsize_expr);\n       if (op0 == chrec_dont_know)\n \treturn chrec_dont_know;\n \n-      op1 = instantiate_parameters_1 (loop, TREE_OPERAND (chrec, 1),\n-\t\t\t\t      flags, cache, size_expr);\n+      op1 = instantiate_scev_1 (instantiation_loop, evolution_loop,\n+\t\t\t\tTREE_OPERAND (chrec, 1), flags, cache,\n+\t\t\t\tsize_expr);\n       if (op1 == chrec_dont_know)\n \treturn chrec_dont_know;\n \n@@ -2075,13 +2103,15 @@ instantiate_parameters_1 (struct loop *loop, tree chrec, int flags, htab_t cache\n       return chrec;\n \n     case MINUS_EXPR:\n-      op0 = instantiate_parameters_1 (loop, TREE_OPERAND (chrec, 0),\n-\t\t\t\t      flags, cache, size_expr);\n+      op0 = instantiate_scev_1 (instantiation_loop, evolution_loop,\n+\t\t\t\tTREE_OPERAND (chrec, 0), flags, cache,\n+\t\t\t\tsize_expr);\n       if (op0 == chrec_dont_know)\n \treturn chrec_dont_know;\n \n-      op1 = instantiate_parameters_1 (loop, TREE_OPERAND (chrec, 1),\n-\t\t\t\t      flags, cache, size_expr);\n+      op1 = instantiate_scev_1 (instantiation_loop, evolution_loop,\n+\t\t\t\tTREE_OPERAND (chrec, 1),\n+\t\t\t\tflags, cache, size_expr);\n       if (op1 == chrec_dont_know)\n \treturn chrec_dont_know;\n \n@@ -2095,13 +2125,15 @@ instantiate_parameters_1 (struct loop *loop, tree chrec, int flags, htab_t cache\n       return chrec;\n \n     case MULT_EXPR:\n-      op0 = instantiate_parameters_1 (loop, TREE_OPERAND (chrec, 0),\n-\t\t\t\t      flags, cache, size_expr);\n+      op0 = instantiate_scev_1 (instantiation_loop, evolution_loop,\n+\t\t\t\tTREE_OPERAND (chrec, 0),\n+\t\t\t\tflags, cache, size_expr);\n       if (op0 == chrec_dont_know)\n \treturn chrec_dont_know;\n \n-      op1 = instantiate_parameters_1 (loop, TREE_OPERAND (chrec, 1),\n-\t\t\t\t      flags, cache, size_expr);\n+      op1 = instantiate_scev_1 (instantiation_loop, evolution_loop,\n+\t\t\t\tTREE_OPERAND (chrec, 1),\n+\t\t\t\tflags, cache, size_expr);\n       if (op1 == chrec_dont_know)\n \treturn chrec_dont_know;\n \n@@ -2115,8 +2147,9 @@ instantiate_parameters_1 (struct loop *loop, tree chrec, int flags, htab_t cache\n       return chrec;\n \n     CASE_CONVERT:\n-      op0 = instantiate_parameters_1 (loop, TREE_OPERAND (chrec, 0),\n-\t\t\t\t      flags, cache, size_expr);\n+      op0 = instantiate_scev_1 (instantiation_loop, evolution_loop,\n+\t\t\t\tTREE_OPERAND (chrec, 0),\n+\t\t\t\tflags, cache, size_expr);\n       if (op0 == chrec_dont_know)\n         return chrec_dont_know;\n \n@@ -2152,18 +2185,21 @@ instantiate_parameters_1 (struct loop *loop, tree chrec, int flags, htab_t cache\n   switch (TREE_CODE_LENGTH (TREE_CODE (chrec)))\n     {\n     case 3:\n-      op0 = instantiate_parameters_1 (loop, TREE_OPERAND (chrec, 0),\n-\t\t\t\t      flags, cache, size_expr);\n+      op0 = instantiate_scev_1 (instantiation_loop, evolution_loop,\n+\t\t\t\tTREE_OPERAND (chrec, 0),\n+\t\t\t\tflags, cache, size_expr);\n       if (op0 == chrec_dont_know)\n \treturn chrec_dont_know;\n \n-      op1 = instantiate_parameters_1 (loop, TREE_OPERAND (chrec, 1),\n-\t\t\t\t      flags, cache, size_expr);\n+      op1 = instantiate_scev_1 (instantiation_loop, evolution_loop,\n+\t\t\t\tTREE_OPERAND (chrec, 1),\n+\t\t\t\tflags, cache, size_expr);\n       if (op1 == chrec_dont_know)\n \treturn chrec_dont_know;\n \n-      op2 = instantiate_parameters_1 (loop, TREE_OPERAND (chrec, 2),\n-\t\t\t\t      flags, cache, size_expr);\n+      op2 = instantiate_scev_1 (instantiation_loop, evolution_loop,\n+\t\t\t\tTREE_OPERAND (chrec, 2),\n+\t\t\t\tflags, cache, size_expr);\n       if (op2 == chrec_dont_know)\n         return chrec_dont_know;\n \n@@ -2176,13 +2212,15 @@ instantiate_parameters_1 (struct loop *loop, tree chrec, int flags, htab_t cache\n \t\t\t  TREE_TYPE (chrec), op0, op1, op2);\n \n     case 2:\n-      op0 = instantiate_parameters_1 (loop, TREE_OPERAND (chrec, 0),\n-\t\t\t\t      flags, cache, size_expr);\n+      op0 = instantiate_scev_1 (instantiation_loop, evolution_loop,\n+\t\t\t\tTREE_OPERAND (chrec, 0),\n+\t\t\t\tflags, cache, size_expr);\n       if (op0 == chrec_dont_know)\n \treturn chrec_dont_know;\n \n-      op1 = instantiate_parameters_1 (loop, TREE_OPERAND (chrec, 1),\n-\t\t\t\t      flags, cache, size_expr);\n+      op1 = instantiate_scev_1 (instantiation_loop, evolution_loop,\n+\t\t\t\tTREE_OPERAND (chrec, 1),\n+\t\t\t\tflags, cache, size_expr);\n       if (op1 == chrec_dont_know)\n         return chrec_dont_know;\n \n@@ -2192,8 +2230,9 @@ instantiate_parameters_1 (struct loop *loop, tree chrec, int flags, htab_t cache\n       return fold_build2 (TREE_CODE (chrec), TREE_TYPE (chrec), op0, op1);\n \t    \n     case 1:\n-      op0 = instantiate_parameters_1 (loop, TREE_OPERAND (chrec, 0),\n-\t\t\t\t      flags, cache, size_expr);\n+      op0 = instantiate_scev_1 (instantiation_loop, evolution_loop,\n+\t\t\t\tTREE_OPERAND (chrec, 0),\n+\t\t\t\tflags, cache, size_expr);\n       if (op0 == chrec_dont_know)\n         return chrec_dont_know;\n       if (op0 == TREE_OPERAND (chrec, 0))\n@@ -2212,27 +2251,29 @@ instantiate_parameters_1 (struct loop *loop, tree chrec, int flags, htab_t cache\n }\n \n /* Analyze all the parameters of the chrec that were left under a\n-   symbolic form.  LOOP is the loop in which symbolic names have to\n-   be analyzed and instantiated.  */\n+   symbolic form.  INSTANTIATION_LOOP is the loop in which symbolic\n+   names have to be instantiated, and EVOLUTION_LOOP is the loop in\n+   which the evolution of scalars have to be analyzed.  */\n \n tree\n-instantiate_parameters (struct loop *loop,\n-\t\t\ttree chrec)\n+instantiate_scev (struct loop *instantiation_loop, struct loop *evolution_loop,\n+\t\t  tree chrec)\n {\n   tree res;\n   htab_t cache = htab_create (10, hash_scev_info, eq_scev_info, del_scev_info);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n-      fprintf (dump_file, \"(instantiate_parameters \\n\");\n-      fprintf (dump_file, \"  (loop_nb = %d)\\n\", loop->num);\n+      fprintf (dump_file, \"(instantiate_scev \\n\");\n+      fprintf (dump_file, \"  (instantiation_loop = %d)\\n\", instantiation_loop->num);\n+      fprintf (dump_file, \"  (evolution_loop = %d)\\n\", evolution_loop->num);\n       fprintf (dump_file, \"  (chrec = \");\n       print_generic_expr (dump_file, chrec, 0);\n       fprintf (dump_file, \")\\n\");\n     }\n  \n-  res = instantiate_parameters_1 (loop, chrec, INSERT_SUPERLOOP_CHRECS, cache,\n-\t\t\t\t  0);\n+  res = instantiate_scev_1 (instantiation_loop, evolution_loop, chrec, \n+\t\t\t    INSERT_SUPERLOOP_CHRECS, cache, 0);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n@@ -2255,7 +2296,7 @@ tree\n resolve_mixers (struct loop *loop, tree chrec)\n {\n   htab_t cache = htab_create (10, hash_scev_info, eq_scev_info, del_scev_info);\n-  tree ret = instantiate_parameters_1 (loop, chrec, FOLD_CONVERSIONS, cache, 0);\n+  tree ret = instantiate_scev_1 (loop, loop, chrec, FOLD_CONVERSIONS, cache, 0);\n   htab_delete (cache);\n   return ret;\n }\n@@ -2520,7 +2561,7 @@ analyze_scalar_evolution_for_all_loop_phi_nodes (VEC(tree,heap) **exit_condition\n       for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n \tif (is_gimple_reg (PHI_RESULT (phi)))\n \t  {\n-\t    chrec = instantiate_parameters \n+\t    chrec = instantiate_parameters\n \t      (loop, \n \t       analyze_scalar_evolution (loop, PHI_RESULT (phi)));\n \t    "}, {"sha": "54e543ceccc93c516ed3432d9bc1e74f5d1e9c98", "filename": "gcc/tree-scalar-evolution.h", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f227a8c1cdcb43cb39acc748b8e1e7a3ad0b628/gcc%2Ftree-scalar-evolution.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f227a8c1cdcb43cb39acc748b8e1e7a3ad0b628/gcc%2Ftree-scalar-evolution.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.h?ref=3f227a8c1cdcb43cb39acc748b8e1e7a3ad0b628", "patch": "@@ -30,14 +30,24 @@ extern void scev_reset (void);\n extern void scev_reset_except_niters (void);\n extern void scev_finalize (void);\n extern tree analyze_scalar_evolution (struct loop *, tree);\n-extern tree instantiate_parameters (struct loop *, tree);\n+extern tree instantiate_scev (struct loop *, struct loop *, tree);\n extern tree resolve_mixers (struct loop *, tree);\n extern void gather_stats_on_scev_database (void);\n extern void scev_analysis (void);\n unsigned int scev_const_prop (void);\n \n extern bool simple_iv (struct loop *, tree, tree, affine_iv *, bool);\n \n+/* Analyze all the parameters of the chrec that were left under a\n+   symbolic form.  LOOP is the loop in which symbolic names have to\n+   be analyzed and instantiated.  */\n+\n+static inline tree\n+instantiate_parameters (struct loop *loop, tree chrec)\n+{\n+  return instantiate_scev (loop, loop, chrec);\n+}\n+\n /* Returns the loop of the polynomial chrec CHREC.  */\n \n static inline struct loop *"}]}